{"text": "['`timescale 1 ns / 1 ps\\n', '\\n', 'module ALU #(\\n', '    parameter [ 0:0] REG_ALU = 1,\\n', '    parameter [ 0:0] REG_OUT = 1\\n', '    )\\n', '    (\\n', '    \\n', '    input clk,\\n', '    input reset,\\n', '    input en, //habilita el dezplazamiento\\n', '    input [11:0] decinst,  //operacion que se desea ver a la salida (instruction decoder)\\n', '    // from Datapath\\n', '    input [31:0] rs2,\\n', '    input [31:0] imm,\\n', '    input [31:0] rs1,\\n', '    \\n', '    output [31:0] rd,\\n', '    output reg cmp,\\n', '    output reg carry,\\n', '    output is_rd,\\n', '    output is_inst);\\n', '    \\n', '    reg [31:0] oper2;\\n', '    reg [31:0] OUT_Alu_rd;\\n', '    \\n', '    reg [31:0] OUT_Alu;\\n', '    wire [32:0] ADD_Alu;\\n', '    wire [31:0] SUB_Alu;\\n', '    wire [31:0] AND_Alu;\\n', '    wire [31:0] XOR_Alu;\\n', '    wire [31:0] OR_Alu;\\n', '    reg [31:0] SLT_Alu;\\n', '    reg [31:0] SLTU_Alu;\\n', '    wire  BEQ_Alu;\\n', '    wire  BGE_Alu;\\n', '    wire  BNE_Alu;\\n', '    wire  BLT_Alu;\\n', '    wire  BLTU_Alu;\\n', '    wire  BGEU_Alu;\\n', '    wire  sl_ok;\\n', '    wire [31:0] SRL_Alu;\\n', '    wire [31:0] SLL_Alu; \\n', '    wire [31:0] SRA_Alu;\\n', '    \\n', '    reg [1:0] is_rd_reg;\\n', '    reg [1:0] is_inst_reg;\\n', '    reg en_reg;\\n', '    reg is_rd_nr, is_inst_nr;\\n', '    \\n', '    always @(posedge clk) begin\\n', \"        if(reset == 1'b0 || en == 1'b0) begin\\n\", '            is_rd_reg <= 0;\\n', '            is_inst_reg <= 0;\\n', '            en_reg <= 0;\\n', '        end else begin\\n', '            is_rd_reg <= {is_rd_reg[0],is_rd_nr};\\n', '            is_inst_reg <= {is_inst_reg[0],is_inst_nr};\\n', '            en_reg <= en;\\n', '        end\\n', '    end\\n', '    \\n', '    generate\\n', '        if (REG_ALU & REG_OUT) begin  \\n', '            assign is_rd = is_rd_nr & (&is_rd_reg);\\n', '            assign is_inst = is_inst_nr & (&is_inst_reg);\\n', '        end else if(REG_ALU | REG_OUT) begin\\n', '            assign is_rd = is_rd_nr & is_rd_reg[0];\\n', '            assign is_inst = is_inst_nr & is_inst_reg[0];\\n', '        end else begin\\n', '            assign is_rd = is_rd_nr;\\n', '            assign is_inst = is_inst_nr;\\n', '        end\\n', '    endgenerate\\n', '    \\n', \"    // WORKAROUND ABOUT 'oper2' and 'rd enable'\\n\", '    always @* begin\\n', '        is_rd_nr = en;\\n', '        is_inst_nr = en;\\n', '        case (decinst)\\n', \"            12'b000000010011:   begin // addi\\n\", '                                oper2 = imm;\\n', '                                end\\n', \"            12'b000000110011:   begin // add\\n\", '                                oper2 = rs2;\\n', '                                end                    \\n', \"            12'b100000110011:   begin //sub \\n\", '                                oper2 = rs2;\\n', '                                end                    \\n', \"            12'b001110010011:   begin //andi\\n\", '                                oper2 = imm;\\n', '                                end\\n', \"            12'b001110110011:   begin //and\\n\", '                                oper2 = rs2;\\n', '                                end\\n', \"            12'b001000010011:   begin //xori\\n\", '                                oper2 = imm;\\n', '                                end\\n', \"            12'b001000110011:   begin //xor\\n\", '                                oper2 = rs2;\\n', '                                end                    \\n', \"            12'b001100010011:   begin //ori\\n\", '                                oper2 = imm;\\n', '                                end\\n', \"            12'b001100110011:   begin //or\\n\", '                                oper2 = rs2;\\n', '                                end\\n', \"            12'b000100010011:   begin //slti\\n\", '                                oper2 = imm;\\n', '                                end\\n', \"            12'b000110010011:   begin //sltiu\\n\", '                                oper2 = imm;\\n', '                                end\\n', \"            12'b000100110011:   begin //slt\\n\", '                                oper2 = rs2;\\n', '                                end\\n', \"            12'b000110110011:   begin //sltu\\n\", '                                oper2 = rs2;\\n', '                                end                    \\n', \"            12'b000001100011:   begin //beq\\n\", '                                oper2 = rs2;\\n', \"                                is_rd_nr = 1'b0;\\n\", '                                end\\n', \"            12'b001011100011:   begin //bge\\n\", '                                oper2 = rs2;\\n', \"                                is_rd_nr = 1'b0;\\n\", '                                end\\n', \"            12'b000011100011:   begin //bne\\n\", '                                oper2 = rs2;\\n', \"                                is_rd_nr = 1'b0;\\n\", '                                end\\n', \"            12'b001001100011:   begin //blt\\n\", '                                oper2 = rs2;\\n', \"                                is_rd_nr = 1'b0;\\n\", '                                end\\n', \"            12'b001101100011:   begin //bltu\\n\", '                                oper2 = rs2;\\n', \"                                is_rd_nr = 1'b0;\\n\", '                                end\\n', \"            12'b001111100011:   begin //bgeu\\n\", '                                oper2 = rs2;\\n', \"                                is_rd_nr = 1'b0;\\n\", '                                end\\n', \"            12'b001010110011:   begin //srl\\n\", '                                oper2 = rs2;\\n', '                                is_rd_nr = sl_ok;\\n', '                                is_inst_nr = sl_ok;\\n', '                                end\\n', \"            12'b001010010011:   begin //srli\\n\", '                                oper2 = imm;\\n', '                                is_rd_nr = sl_ok;\\n', '                                is_inst_nr = sl_ok;\\n', '                                end                    \\n', \"            12'b000010110011:   begin //sll\\n\", '                                oper2 = rs2;\\n', '                                is_rd_nr = sl_ok;\\n', '                                is_inst_nr = sl_ok;\\n', '                                end\\n', \"            12'b000010010011:   begin //slli\\n\", '                                oper2 = imm;\\n', '                                is_rd_nr = sl_ok;\\n', '                                is_inst_nr = sl_ok;\\n', '                                end\\n', \"            12'b101010110011:   begin //sra\\n\", '                                oper2 = rs2;\\n', '                                is_rd_nr = sl_ok;\\n', '                                is_inst_nr = sl_ok;\\n', '                                end\\n', \"            12'b011010010011:   begin //srai\\n\", '                                oper2 = imm;\\n', '                                is_rd_nr = sl_ok;\\n', '                                is_inst_nr = sl_ok;\\n', '                                end\\n', '            default:            begin // NO INSTRUCTION\\n', \"                                oper2 = 'bx;\\n\", \"                                is_rd_nr = 1'b0;\\n\", \"                                is_inst_nr = 1'b0;\\n\", '                                end\\n', '        endcase\\n', '    end\\n', '    \\n', '    // ALU\\n', '    // Granularity, each operation can be activated or deactivated\\n', '    ALU_add #(.REG_ALU(REG_ALU), .REG_OUT(REG_OUT)) ALU_add_inst\\n', '        (.clk(clk), .reset(reset), .rs1(rs1), .oper2(oper2), .ADD_Alu(ADD_Alu));\\n', '    ALU_sub #(.REG_ALU(REG_ALU), .REG_OUT(REG_OUT)) ALU_sub_inst\\n', '        (.clk(clk), .reset(reset), .rs1(rs1), .oper2(oper2), .SUB_Alu(SUB_Alu));\\n', '    ALU_and #(.REG_ALU(REG_ALU), .REG_OUT(REG_OUT)) ALU_and_inst\\n', '        (.clk(clk), .reset(reset), .rs1(rs1), .oper2(oper2), .AND_Alu(AND_Alu));\\n', '    ALU_xor #(.REG_ALU(REG_ALU), .REG_OUT(REG_OUT)) ALU_xor_inst\\n', '        (.clk(clk), .reset(reset), .rs1(rs1), .oper2(oper2), .XOR_Alu(XOR_Alu));\\n', '    ALU_or #(.REG_ALU(REG_ALU), .REG_OUT(REG_OUT)) ALU_or_inst\\n', '        (.clk(clk), .reset(reset), .rs1(rs1), .oper2(oper2), .OR_Alu(OR_Alu));\\n', '    ALU_beq #(.REG_ALU(REG_ALU), .REG_OUT(REG_OUT)) ALU_beq_inst\\n', '        (.clk(clk), .reset(reset), .rs1(rs1), .oper2(oper2), .BEQ_Alu(BEQ_Alu));\\n', '    ALU_blt #(.REG_ALU(REG_ALU), .REG_OUT(REG_OUT)) ALU_blt_inst\\n', '        (.clk(clk), .reset(reset), .rs1(rs1), .oper2(oper2), .BLT_Alu(BLT_Alu));\\n', '    ALU_bltu #(.REG_ALU(REG_ALU), .REG_OUT(REG_OUT)) ALU_bltu_inst\\n', '        (.clk(clk), .reset(reset), .rs1(rs1), .oper2(oper2), .BLTU_Alu(BLTU_Alu));\\n', '    // Shifts\\n', '    ALU_sXXx #(.REG_ALU(REG_ALU), .REG_OUT(REG_OUT)) ALU_sXXx_inst\\n', '        (.clk(clk), .reset(reset), .rs1(rs1), .oper2(oper2), .en(en_reg), .SRL_Alu(SRL_Alu), .SLL_Alu(SLL_Alu), .SRA_Alu(SRA_Alu), .sl_ok(sl_ok));\\n', '    \\n', '    // Always this result, there is no need to modularize this\\n', '    assign BNE_Alu = !BEQ_Alu;\\n', '    assign BGE_Alu = !BLT_Alu;\\n', '    assign BGEU_Alu = !BLTU_Alu;\\n', '    \\n', '    // SLTx are actually the same as BLTx, so we do not modularize them\\n', '    generate \\n', '        if (REG_ALU) begin            \\n', '            always @(posedge clk) begin    \\n', '                if (!reset) begin\\n', '                    SLT_Alu <= 0;\\n', '                    SLTU_Alu <= 0;\\n', '                end else begin \\n', \"                    SLT_Alu <= {31'd0, BLT_Alu};\\n\", \"                    SLTU_Alu <= {31'd0, BLTU_Alu};\\n\", '                end\\n', '            end\\n', '        end else begin\\n', '            always @* begin     \\n', \"                SLT_Alu = {31'd0, BLT_Alu};\\n\", \"                SLTU_Alu = {31'd0, BLTU_Alu};\\n\", '            end\\n', '        end\\n', '    endgenerate\\n', '\\n', '    // DEFINE FINAL OUTPUT\\n', '    always @* begin\\n', '        \\n', '        case (decinst)\\n', \"            12'b000000010011:   begin      // addi\\n\", '                                OUT_Alu = ADD_Alu[31:0];\\n', '                                carry = ADD_Alu[32];\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b000000110011:   begin      // add\\n\", '                                OUT_Alu = ADD_Alu[31:0];\\n', '                                carry = ADD_Alu[32];\\n', '                                cmp = 0;\\n', '                                end                    \\n', \"            12'b100000110011:    begin //sub \\n\", '                                OUT_Alu = SUB_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end                    \\n', \"            12'b001110010011:   begin   //andi\\n\", '                                OUT_Alu = AND_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b001110110011:   begin   //and\\n\", '                                OUT_Alu = AND_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b001000010011:   begin //xori\\n\", '                                OUT_Alu = XOR_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b001000110011:   begin //xor\\n\", '                                OUT_Alu = XOR_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end                    \\n', \"            12'b001100010011:   begin //ori\\n\", '                                OUT_Alu = OR_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b001100110011:   begin //or\\n\", '                                OUT_Alu = OR_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b000100010011:   begin //slt pide imm\\n\", '                                OUT_Alu = SLT_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b000110010011:   begin //sltu pide imm\\n\", '                                OUT_Alu = SLTU_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b000100110011:   begin //slt pide rs2\\n\", '                                OUT_Alu = SLT_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b000110110011:   begin //sltu pide rs2\\n\", '                                OUT_Alu = SLTU_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end                    \\n', \"            12'b000001100011:   begin //beq\\n\", '                                cmp = BEQ_Alu;\\n', '                                carry = 0;\\n', '                                OUT_Alu = 0;\\n', '                                end\\n', \"            12'b001011100011:   begin //bge\\n\", '                                cmp = BGE_Alu;\\n', '                                carry = 0;\\n', '                                OUT_Alu = 0;\\n', '                                end\\n', \"            12'b000011100011:   begin //bne\\n\", '                                cmp = BNE_Alu;\\n', '                                carry = 0;\\n', '                                OUT_Alu = 0;\\n', '                                end\\n', \"            12'b001001100011:   begin //blt\\n\", '                                cmp = BLT_Alu;\\n', '                                carry = 0;\\n', '                                OUT_Alu = 0;\\n', '                                end\\n', \"            12'b001101100011:   begin //bltu\\n\", '                                cmp = BLTU_Alu;\\n', '                                carry = 0;\\n', '                                OUT_Alu = 0;\\n', '                                end\\n', \"            12'b001111100011:   begin   //bgeu\\n\", '                                cmp = BGEU_Alu;\\n', '                                carry = 0;\\n', '                                OUT_Alu = 0;\\n', '                                end\\n', \"            12'b001010110011:   begin  //srl pide rs2\\n\", '                                OUT_Alu = SRL_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b001010010011:   begin  //srl pide imm\\n\", '                                OUT_Alu = SRL_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end                    \\n', \"            12'b000010110011:   begin  //sll pide rs2\\n\", '                                OUT_Alu = SLL_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b000010010011:   begin  //sll pide imm\\n\", '                                OUT_Alu = SLL_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b101010110011:   begin  //sra pide rs2\\n\", '                                OUT_Alu = SRA_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', \"            12'b011010010011:   begin  //sra pide imm\\n\", '                                OUT_Alu = SRA_Alu;\\n', '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', '            default:            begin\\n', \"                                OUT_Alu = 'bx;\\n\", '                                carry = 0;\\n', '                                cmp = 0;\\n', '                                end\\n', '        endcase\\n', '    end\\n', '    \\n', '    generate \\n', '        if (REG_ALU) begin            \\n', '            always @(posedge clk) begin    \\n', '                if (!reset) begin\\n', '                    OUT_Alu_rd <= 0;\\n', '                end else begin\\n', '                    OUT_Alu_rd <= OUT_Alu; \\n', '                end\\n', '            end\\n', '        end else begin\\n', '            always @(OUT_Alu) begin    \\n', '                OUT_Alu_rd = OUT_Alu; \\n', '            end\\n', '        end\\n', '    endgenerate\\n', '    \\n', \"    assign rd = is_rd_nr?OUT_Alu_rd:32'bz;\\n\", '    \\n', '\\n', 'endmodule\\n', '\\n', 'module ALU_add\\n', '    #(\\n', '    parameter [ 0:0] REG_ALU = 1,\\n', '    parameter [ 0:0] REG_OUT = 1\\n', '    )\\n', '    (\\n', '    \\n', '    input clk,\\n', '    input reset,\\n', '    input [31:0] rs1,\\n', '    input [31:0] oper2,\\n', '    output reg [32:0] ADD_Alu\\n', '    );\\n', '\\n', 'generate \\n', '        if (REG_ALU) begin            \\n', '            always @(posedge clk) begin    \\n', '                if (!reset) begin\\n', '                    ADD_Alu <= 0;\\n', '                end else begin \\n', '                    ADD_Alu <= rs1 + oper2;\\n', '                end\\n', '            end\\n', '        end else begin\\n', '            always @* begin     \\n', '                // ARITH\\n', '                ADD_Alu = rs1 + oper2;\\n', '            end\\n', '        end\\n', '    endgenerate\\n', 'endmodule\\n', '\\n', 'module ALU_sub\\n', '    #(\\n', '    parameter [ 0:0] REG_ALU = 1,\\n', '    parameter [ 0:0] REG_OUT = 1\\n', '    )\\n', '    (\\n', '    \\n', '    input clk,\\n', '    input reset,\\n', '    input [31:0] rs1,\\n', '    input [31:0] oper2,\\n', '    output reg [31:0] SUB_Alu\\n', '    );\\n', '\\n', 'generate \\n', '        if (REG_ALU) begin            \\n', '            always @(posedge clk) begin    \\n', '                if (!reset) begin\\n', '                    SUB_Alu <= 0;\\n', '                end else begin \\n', '                    SUB_Alu <= rs1 - oper2; \\n', '                end\\n', '            end\\n', '        end else begin\\n', '            always @* begin     \\n', '                SUB_Alu = rs1 - oper2; \\n', '            end\\n', '        end\\n', '    endgenerate\\n', 'endmodule\\n', '\\n', 'module ALU_and\\n', '    #(\\n', '    parameter [ 0:0] REG_ALU = 1,\\n', '    parameter [ 0:0] REG_OUT = 1\\n', '    )\\n', '    (\\n', '    \\n', '    input clk,\\n', '    input reset,\\n', '    input [31:0] rs1,\\n', '    input [31:0] oper2,\\n', '    output reg [31:0] AND_Alu\\n', '    );\\n', '\\n', 'generate \\n', '        if (REG_ALU) begin            \\n', '            always @(posedge clk) begin    \\n', '                if (!reset) begin\\n', '                    AND_Alu <= 0;\\n', '                end else begin \\n', '                    AND_Alu <= rs1 & oper2;\\n', '                end\\n', '            end\\n', '        end else begin\\n', '            always @* begin     \\n', '                AND_Alu = rs1 & oper2;\\n', '            end\\n', '        end\\n', '    endgenerate\\n', 'endmodule\\n', '\\n', 'module ALU_xor\\n', '    #(\\n', '    parameter [ 0:0] REG_ALU = 1,\\n', '    parameter [ 0:0] REG_OUT = 1\\n', '    )\\n', '    (\\n', '    \\n', '    input clk,\\n', '    input reset,\\n', '    input [31:0] rs1,\\n', '    input [31:0] oper2,\\n', '    output reg [31:0] XOR_Alu\\n', '    );\\n', '\\n', 'generate \\n', '        if (REG_ALU) begin            \\n', '            always @(posedge clk) begin    \\n', '                if (!reset) begin\\n', '                    XOR_Alu <= 0;    \\n', '                end else begin \\n', '                    XOR_Alu <= rs1 ^ oper2;    \\n', '                end\\n', '            end\\n', '        end else begin\\n', '            always @* begin     \\n', '                XOR_Alu = rs1 ^ oper2;    \\n', '            end\\n', '        end\\n', '    endgenerate\\n', 'endmodule\\n', '\\n', 'module ALU_or\\n', '    #(\\n', '    parameter [ 0:0] REG_ALU = 1,\\n', '    parameter [ 0:0] REG_OUT = 1\\n', '    )\\n', '    (\\n', '    \\n', '    input clk,\\n', '    input reset,\\n', '    input [31:0] rs1,\\n', '    input [31:0] oper2,\\n', '    output reg [31:0] OR_Alu\\n', '    );\\n', '\\n', 'generate \\n', '        if (REG_ALU) begin            \\n', '            always @(posedge clk) begin    \\n', '                if (!reset) begin   \\n', '                    OR_Alu  <= 0;\\n', '                end else begin \\n', '                    OR_Alu  <= rs1 | oper2;\\n', '                end\\n', '            end\\n', '        end else begin\\n', '            always @* begin         \\n', '                OR_Alu  = rs1 | oper2;\\n', '            end\\n', '        end\\n', '    endgenerate\\n', 'endmodule\\n', '\\n', 'module ALU_beq\\n', '    #(\\n', '    parameter [ 0:0] REG_ALU = 1,\\n', '    parameter [ 0:0] REG_OUT = 1\\n', '    )\\n', '    (\\n', '    \\n', '    input clk,\\n', '    input reset,\\n', '    input [31:0] rs1,\\n', '    input [31:0] oper2,\\n', '    output reg BEQ_Alu\\n', '    ); \\n', '    always @* begin     \\n', '        BEQ_Alu = rs1 == oper2;\\n', '    end\\n', 'endmodule\\n', '\\n', 'module ALU_blt\\n', '    #(\\n', '    parameter [ 0:0] REG_ALU = 1,\\n', '    parameter [ 0:0] REG_OUT = 1\\n', '    )\\n', '    (\\n', '    \\n', '    input clk,\\n', '    input reset,\\n', '    input [31:0] rs1,\\n', '    input [31:0] oper2,\\n', '    output reg BLT_Alu\\n', '    );   \\n', '    always @* begin     \\n', '        BLT_Alu = $signed(rs1) < $signed(oper2);\\n', '    end\\n', 'endmodule\\n', '\\n', 'module ALU_bltu \\n', '    #(\\n', '    parameter [ 0:0] REG_ALU = 1,\\n', '    parameter [ 0:0] REG_OUT = 1\\n', '    )\\n', '    (\\n', '    \\n', '    input clk,\\n', '    input reset,\\n', '    input [31:0] rs1,\\n', '    input [31:0] oper2,\\n', '    output reg BLTU_Alu\\n', '    );   \\n', '    always @* begin     \\n', '        BLTU_Alu = rs1 < oper2;\\n', '    end\\n', 'endmodule\\n', '\\n', 'module ALU_sXXx\\n', '    #(\\n', '    parameter [ 0:0] REG_ALU = 1,\\n', '    parameter [ 0:0] REG_OUT = 1\\n', '    )\\n', '    (\\n', '    \\n', '    input clk,\\n', '    input reset,\\n', '    input [31:0] rs1,\\n', '    input [31:0] oper2,\\n', '    input en,\\n', '    output reg [31:0] SRL_Alu,\\n', '    output reg [31:0] SLL_Alu,\\n', '    output reg [31:0] SRA_Alu,\\n', '    output reg sl_ok\\n', '    );   \\n', '    reg [4:0]  count;\\n', '    always @(posedge clk) begin    \\n', '        if (!reset) begin\\n', '            SRL_Alu <= 0;\\n', '            SLL_Alu <= 0;\\n', '            SRA_Alu <= 0;\\n', '            count <= 0;\\n', '            sl_ok <= 0;\\n', \"        end else if(en == 1'b1) begin\\n\", \"            if(count >= 5'd4) begin\\n\", '                SRL_Alu <= SRL_Alu >> 4;\\n', '                SLL_Alu <= SLL_Alu << 4;\\n', '                SRA_Alu <= $signed(SRA_Alu) >>> 4;\\n', '                //SRA_Alu <= {4{SRA_Alu[31]},SRA_Alu[31:4]};\\n', '                count <= count - 4;\\n', \"            end else if(count != 5'd0) begin\\n\", '                SRL_Alu <= SRL_Alu >> 1;\\n', '                SLL_Alu <= SLL_Alu << 1;\\n', '                SRA_Alu <= $signed(SRA_Alu) >>> 1;\\n', '                count <= count - 1;\\n', '            end else if (count ==0) begin \\n', \"                sl_ok<=1'b1;\\n\", '            end \\n', '        end else begin\\n', '            SRL_Alu <= rs1;\\n', '            SLL_Alu <= rs1;\\n', '            SRA_Alu <= rs1;\\n', '            count <= oper2[4:0];\\n', '            sl_ok <= 0;\\n', '        end \\n', '    end\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module sim1;\\n', '    \\n', '   reg clk;\\n', '   reg reset;\\n', '   reg en;\\n', '   reg [11:0] decinst; \\n', '   reg [31:0] operando1;\\n', '   reg [31:0] rs2;\\n', '   reg [31:0] inm;\\n', '   \\n', '   wire [31:0] SALIDA_Alu;\\n', '   wire SALIDA_comparativa; \\n', '   wire carry;\\n', '   wire sl_ok;\\n', '    \\n', '  ALU uut (\\n', '           .clk(clk), \\n', '           .reset(reset),\\n', '           .decinst(decinst),\\n', '           .en(en), \\n', '           .operando1(operando1), \\n', '           .rs2(rs2),\\n', '           .inm(inm),\\n', '           .SALIDA_Alu(SALIDA_Alu),\\n', '           .SALIDA_comparativa(SALIDA_comparativa),\\n', '           .carry(carry),\\n', '           .sl_ok(sl_ok)\\n', '       \\n', '       );\\n', '       \\n', 'initial begin\\n', '               \\n', '       clk=0;\\n', '       en=0;\\n', '             \\n', '      //iniciar\\n', \"       operando1 = 32'hc0404040;\\n\", \"       rs2 = 32'h00000fff;\\n\", \"       inm = 32'h00000fff;\\n\", \"       decinst = 12'b000000110011;\\n\", '       reset=1; \\n', '       en=0;                                                                                        \\n', '       #20;\\n', '              \\n', '       //para que reste\\n', '       \\n', \"       decinst = 12'b100000110011;\\n\", '       reset=0;\\n', '       en=0;                                                                                        \\n', '        #20;\\n', '      \\n', '       //para que reste\\n', '              \\n', \"          decinst = 12'b100000110011;\\n\", '          reset=0; \\n', '          en=1;                                                                                        \\n', '          #20;\\n', '       //para que sume\\n', \"            //operando1 = 32'h0000000f;\\n\", \"            //rs2 = 32'h00000fff;            \\n\", \"            decinst = 12'b000000110011;\\n\", '            reset=0; \\n', '            #20;\\n', '         //para que compare SLT\\n', '                                   \\n', \"           decinst = 12'b000100010011;\\n\", '           reset=0; \\n', '        #20;\\n', '          //para que desplaze  SRA\\n', '                                         \\n', \"         decinst = 12'b011010010011;\\n\", '         reset=0; \\n', '         en=1;\\n', '          #20;\\n', 'end\\n', 'always #5 clk=~clk;          \\n', '         \\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module DECO_INSTR(\\n', '    input clk,\\n', '    input [31:0] inst,\\n', '     //output state,\\n', '    output reg [4:0] rs1i,\\n', '    output reg [4:0] rs2i,\\n', '    output reg [4:0] rdi,\\n', '    output reg [31:0] imm,\\n', '    output reg  [11:0] code,\\n', '    output reg [11:0] codif\\n', '     );\\n', '     \\n', '    reg [31:0] immr;\\n', '\\n', '    always @(posedge clk) begin\\n', '        imm <= immr;\\n', '        code <= codif;\\n', '    end\\n', '\\n', '    always @* begin\\n', \"        immr = {32{1'b1}};\\n\", \"        rdi = {5{1'b1}};\\n\", \"        rs1i ={5{1'b1}};\\n\", \"        rs2i = {5{1'b1}};\\n\", \"        codif = {12{1'b1}};   // ILLISN\\n\", '        case (inst[6:0])\\n', \"        7'b0010111,7'b0110111: begin                 // lui, auipc\\n\", \"            immr = {inst[31:12], {12{1'b0}}};\\n\", '            rdi = inst[11:7];\\n', \"            rs1i = {5{1'b0}};\\n\", \"            rs2i = {5{1'b0}};\\n\", \"            codif = {{5{1'b0}} , inst[6:0]};\\n\", '        end\\n', \"        7'b1101111: begin                             // jal\\n\", \"            immr = {{11{inst[31]}},inst[31],inst[19:12],inst[20],inst[30:21],1'b0};\\n\", '            rdi = inst[11:7];\\n', \"            rs1i = {5{1'b0}};\\n\", \"            rs2i = {5{1'b0}};\\n\", \"            codif = {{5{1'b0}} , inst[6:0]}; \\n\", '        end\\n', \"        7'b1100111: begin                             // jalr\\n\", \"            if (inst[14:12] == 3'b000) begin \\n\", '                immr = {{20{inst[31]}},inst[31:20]}; \\n', '                rs1i = inst[19:15];\\n', '                rdi = inst[11:7];\\n', \"                rs2i = {5{1'b0}};\\n\", \"                codif = {{2{1'b0}} ,inst[14:12] , inst[6:0]};\\n\", '            end\\n', '        end\\n', \"        7'b1100011: begin                             // bXX\\n\", \"            if((inst[14] == 1'b1)||(inst[14:13] == 2'b00)) begin\\n\", \"                immr = {{19{inst[31]}},inst[31],inst[7],inst[30:25],inst[11:8],1'b0};\\n\", \"                rdi = {5{1'b0}};\\n\", '                rs1i = inst[19:15];\\n', '                rs2i = inst[24:20];\\n', \"                codif = {{2{1'b0}} ,inst[14:12] , inst[6:0]};\\n\", '            end\\n', '        end  \\n', \"        7'b0000011: begin                             // lX\\n\", \"            if(((inst[14] == 1'b0)&&(inst[13:12] != 2'b11))||(inst[14:13] == 2'b10)) begin // lX\\n\", '                immr = {{20{inst[31]}},inst[31:20]}; \\n', '                rs1i = inst[19:15];\\n', '                rdi = inst[11:7];\\n', \"                rs2i = {5{1'b0}};\\n\", \"                codif = {{2{1'b0}} ,inst[14:12] , inst[6:0]};\\n\", '            end\\n', '        end\\n', \"        7'b0100011: begin                             // sX\\n\", \"            if((inst[14] == 1'b0)&&(inst[13:12] != 2'b11)) begin    // sX\\n\", '                immr = {{20{inst[31]}},inst[31:25],inst[11:7]} ;\\n', '                rs1i = inst[19:15];\\n', '                rs2i = inst[24:20];\\n', \"                rdi = {5{1'b0}};\\n\", \"                codif = {{2{1'b0}} ,inst[14:12] , inst[6:0]};\\n\", '            end\\n', '        end\\n', \"        7'b0010011: begin // arith & logic immr\\n\", \"            if (inst[13:12] != 2'b01)begin // arith immr\\n\", '                rdi = inst[11:7];\\n', '                rs1i = inst[19:15];\\n', \"                rs2i = {5{1'b0}};\\n\", '                immr = {{20{inst[31]}},inst[31:20]}; \\n', \"                codif = {2'b00 ,inst[14:12] , inst[6:0]};\\n\", \"            end else /*if (inst[13:12] == 2'b01)*/ begin // sXXi\\n\", '                rdi = inst[11:7];\\n', '                rs1i = inst[19:15];\\n', \"                rs2i = {5{1'b0}};\\n\", '                immr = {{20{inst[31]}},inst[31:20]}; \\n', \"                codif = {1'b0, inst[30] ,inst[14:12] , inst[6:0]};  // Diferentiation between SRLI and SRAI is implicit on codif\\n\", '            end\\n', '        end\\n', \"        7'b0110011: begin // arith and logic\\n\", \"            if(({inst[31], inst[29:25]} == 6'b000000) || //add,sllst,sltu,xor,srl,or,and,sub,sra (inst[30] can be 1 or 0)\\n\", \"               ((inst[31:25] == 7'b0000001)&&(inst[14] == 1'b0)) // mul[h[u|su]] (do not support divs)\\n\", '               ) begin \\n', '                rs2i = inst[24:20];\\n', '                rs1i = inst[19:15];\\n', '                rdi  = inst[11:7];\\n', \"                immr = {32{1'b0}};\\n\", '                codif = {inst[30],inst[25] ,inst[14:12] , inst[6:0]};\\n', '            end\\n', '        end\\n', \"        7'b1110011: begin // ECALL, EBREAK\\n\", \"            if(inst[14:12] == 3'b000) begin\\n\", '                // Quite the same as arith immr\\n', '                rdi = inst[11:7];\\n', '                rs1i = inst[19:15];        // WARN: This can be also zimm for CSRRX calls\\n', \"                rs2i = {5{1'b0}};\\n\", \"                immr = {{20{1'b0}},inst[31:20]}; \\n\", \"                codif = {2'b0000 ,inst[20] , inst[6:0]};\\n\", \"            end else if(inst[14:12] != 3'b100) begin // CSRRX\\n\", '                // Quite the same as arith immr\\n', '                rdi = inst[11:7];\\n', '                rs1i = inst[19:15];        // WARN: This can be also zimm for CSRRX calls\\n', \"                rs2i = {5{1'b0}};\\n\", \"                immr = {{20{1'b0}},inst[31:20]}; \\n\", '\\n', \"                codif = {2'b00 ,inst[14:12] , inst[6:0]};\\n\", '            end\\n', '        end\\n', \"        7'b0011000: begin // IRQ\\n\", \"            if (inst[14:12] != 3'b000) begin                    // IRQXX (NOT SBREAK)\\n\", '                immr = {{20{inst[31]}},inst[31:20]};\\n', '                rdi = {inst[11:7]};\\n', '                rs1i = {inst[19:15]};\\n', '                rs2i = {inst[24:20]};\\n', \"                codif = {{2{1'b0}} ,inst[14:12] , inst[6:0]};\\n\", '            end\\n', '        end\\n', '        endcase\\n', '    end\\n', '\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module Sim_DecInstru1;\\n', '\\n', '\\t// Inputs\\n', '\\treg [31:0] inst;\\n', '\\treg clock;\\n', '\\treg resetDec;\\n', '\\treg enableDec;\\n', '\\n', '\\t// Outputs\\n', '\\twire [4:0] rs1;\\n', '\\twire [4:0] rs2;\\n', '\\twire [4:0] rd;\\n', '\\twire [31:0] imm_out;\\n', '\\twire [11:0] codif;\\n', '//\\twire state;\\n', '\\n', '\\t// Instantiate the Unit Under Test (UUT)\\n', '\\tDECO_INSTR uut (\\n', '\\t\\t.inst(inst), \\n', '\\t\\t.clock(clock),\\n', '\\t\\t.resetDec(resetDec),\\n', '\\t\\t.enableDec(enableDec),\\n', '\\t\\t.rs1(rs1), \\n', '\\t\\t.rs2(rs2), \\n', '\\t\\t.rd(rd), \\n', '\\t\\t.imm_out(imm_out), \\n', '\\t\\t.codif(codif)\\n', '//\\t\\t.state(state)\\n', '\\t);\\n', '\\n', '\\n', '\\n', '\\n', '\\tinitial begin\\n', '\\t\\t// Initialize Inputs\\n', '\\t//\\talways\\n', 'clock=0;\\n', '//#40;\\n', '\\n', '//INSTRUCCI\u00d3N AUIPC, RESET\\n', \"inst = 32'b00001111000011110000111100010111;\\n\", 'resetDec=1;  \\n', 'enableDec=0;                                                                                       \\n', '#20;\\n', '//INSTRUCCI\u00d3N AUIPC (#1)\\n', \"inst = 32'b00001111000011110000111100010111;\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//INSTRUCCI\u00d3N lui (#2)\\n', '\\n', \"inst = 32'b00001111000011110000111100110111;\\n\", 'resetDec=0; \\n', 'enableDec=1;                                                                                           \\n', '#20;\\n', '\\n', '\\n', '//INSTRUCCI\u00d3N JAL (#3) funcional\\n', \"inst = 32'b00001111000011110000111101101111;\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//INSTRUCCI\u00d3N JAL (#3) reset desactivado y enable desactivado\\n', \"inst = 32'b00001111000011110000111101101111;\\n\", 'resetDec=0;\\n', 'enableDec=0; \\n', '#20\\n', '//INSTRUCCI\u00d3N JAL (#3) reset activado y enable activado\\n', \"inst = 32'b00001111000011110000111101101111;\\n\", 'resetDec=1;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N JAL (#3) reset desactivado y enable desactivado\\n', \"inst = 32'b00001111000011110000111101101111;\\n\", 'resetDec=0;\\n', 'enableDec=0; \\n', '#20\\n', '\\n', '//Instrucci\u00f3n BEQ (#4)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b000,5'b11011,7'b1100011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n BNE (#5)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b001,5'b11011,7'b1100011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//Instrucci\u00f3n BLT (#6)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b100,5'b11011,7'b1100011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n BGE (#7)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b101,5'b11011,7'b1100011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n BLTU (#8)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b110,5'b11011,7'b1100011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n BGEU (#9)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b111,5'b11011,7'b1100011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n SB (#10)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b000,5'b11011,7'b0100011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n SH (#11)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b001,5'b11011,7'b0100011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n SW (#12)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b010,5'b11011,7'b0100011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//Instrucci\u00f3n LB (#13)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b000,5'b11011,7'b0000011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n LH (#14)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b001,5'b11011,7'b0000011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n LW (#15)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b010,5'b11011,7'b0000011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n LBU (#16)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b100,5'b11011,7'b0000011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n LHU (#17)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b101,5'b11011,7'b0000011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//Instrucci\u00f3n ADDI (#18)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b000,5'b11011,7'b0010011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n SLTI (#19)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b010,5'b11011,7'b0010011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n sltiu (#20)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b011,5'b11011,7'b0010011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n XORI (#21)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b100,5'b11011,7'b0010011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n ORI (#22)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b110,5'b11011,7'b0010011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n ANDI (#23)\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b111,5'b11011,7'b0010011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n SLLI (#24)\\n', \"inst = {7'b0000000,5'b00011,5'b00110,3'b001,5'b11011,7'b0010011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n SRLI (#25)\\n', \"inst = {7'b0000000,5'b00011,5'b00110,3'b101,5'b11011,7'b0010011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n SRAI (#26)\\n', \"inst = {7'b0100000,5'b00011,5'b00110,3'b101,5'b11011,7'b0010011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n JALR (#27)\\n', \"inst = {17'b010000000011,5'b00100,3'b000,5'b11011,7'b1100111};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '\\n', '//INSTRUCCI\u00d3N add (#28)\\n', \"inst = {2'b00,{5{1'b0}},5'b11001,5'b11001,3'b000, 5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//INSTRUCCI\u00d3N sub (#29)\\n', \"inst = {2'b01,{5{1'b0}},5'b11001,5'b11001,3'b000, 5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//INSTRUCCI\u00d3N sll (#30)\\n', \"inst = {2'b00,{5{1'b0}},5'b11001,5'b11001,3'b001, 5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N slt (#31)\\n', \"inst = {2'b00,{5{1'b0}},5'b11001,5'b11001,3'b010, 5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N sltu (#32)\\n', \"inst = {2'b00,{5{1'b0}},5'b11001,5'b11001,3'b011, 5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N xor (#33)\\n', \"inst = {2'b00,{5{1'b0}},5'b11001,5'b11001,3'b100, 5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N srl (#34)\\n', \"inst = {2'b00,{5{1'b0}},5'b11001,5'b11001,3'b101, 5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N sra (#35)\\n', \"inst = {2'b01,{5{1'b0}},5'b11001,5'b11001,3'b101, 5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N or (#36)\\n', \"inst = {2'b00,{5{1'b0}},5'b11001,5'b11001,3'b110, 5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//INSTRUCCI\u00d3N and (#37)\\n', \"inst = {2'b00,{5{1'b0}},5'b11001,5'b11001,3'b111, 5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//IRQ\\n', '//INSTRUCCI\u00d3N SBREAK (#38)\\n', \"inst = {{11{1'b0}},1'b1,{13{1'b0}},7'b0011000};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//INSTRUCCI\u00d3N ADDRMS (#39) rs1=00100\\n', \"inst = {{12{1'b0}},5'b00100,3'b001,5'b00000,7'b0011000};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N ADDRME (#40) \\n', \"inst = {{17{1'b0}},3'b010,5'b00100,7'b0011000};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N TISIRR (#41) rs1=00100\\n', \"inst = {{7{1'b0}},5'b00100,5'b00100,3'b011,5'b00000,7'b0011000};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N IRRSTATE (#42) \\n', \"inst = {{17{1'b0}},3'b100,5'b00100,7'b0011000};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N clraddrm (#43) \\n', \"inst = {{17{1'b0}},3'b101,5'b00000,7'b0011000};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//INSTRUCCI\u00d3N CLRIRQ (#44)\\n', \"inst = {12'b101010101010,5'b00100,3'b110, 5'b00000,7'b0011000};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N RETIRQ (#45) \\n', \"inst = {{17{1'b0}},3'b111,5'b00000,7'b0011000};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//MULTIPLICADOR\\n', '//INSTRUCCI\u00d3N MUL (#46)\\n', \"inst = {{6{1'b0}},1'b1,5'b00011,5'b00110,3'b000,5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N MULH (#47)\\n', \"inst = {{6{1'b0}},1'b1,5'b00011,5'b00110,3'b001,5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N MULHSU (#48)\\n', \"inst = {{6{1'b0}},1'b1,5'b00011,5'b00110,3'b010,5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N MULHU (#49)\\n', \"inst = {{6{1'b0}},1'b1,5'b00011,5'b00110,3'b011,5'b11001,7'b0110011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '\\n', '//INSTRUCCIONES INV\u00c1LIDAS\\n', '//Instrucci\u00f3n tipo sb inv\u00e1lida 5,6\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b010,5'b11011,7'b1100011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n tipo sb inv\u00e1lida\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b011,5'b11011,7'b1100011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n Inv\u00e1lida tipo s\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b100,5'b11011,7'b0100011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//Instrucci\u00f3n TIPO i inv\u00e1lida 17\\n', \"inst = {7'b1010101,5'b00011,5'b00110,3'b111,5'b11011,7'b0000011};\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//INSTRUCCI\u00d3N 24-26 (INV\u00c1LIDA)\\n', \"inst = 32'b00001111000011110001111100010011;\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '//INSTRUCCI\u00d3N 28-37 (NO CUMPLE)\\n', \"inst = 32'b00001111000011110000111100110011;\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '\\n', '//UNA INSTRUCCI\u00d3N Parecida IRQ (Inv\u00e1lida)\\n', \"inst = 32'b00001111000011110000111100011000;\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '\\n', '//UNA INSTRUCCI\u00d3N DEL MULTIPLIPLICADOR (Inv\u00e1lida)\\n', \"inst = 32'b00000011010101010110001100110011;\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '\\n', '//UNA INSTRUCCI\u00d3N DEL MULTIPLIPLICADOR (Inv\u00e1lida)\\n', \"inst = 32'b00001111000011110000111100110011;\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '//INSTRUCCI\u00d3N DIFERENTE A LAS CODIFICADAS (opcode distinto)\\n', \"inst = 32'b10001111000011110000111100110011;\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '#20\\n', '\\n', '\\n', '\\n', '//INSTRUCCI\u00d3N DIFERENTE A LAS CODIFICADAS2 (opcode distinto)\\n', \"inst = 32'b00001111000011110000111111111111;\\n\", 'resetDec=0;\\n', 'enableDec=1; \\n', '\\t\\t\\n', '\\t\\t// Wait 100 ns for global reset to finish\\n', '\\t//\\t#100;\\n', '        \\n', '\\t\\t// Add stimulus here\\n', 'end\\n', '\\n', 'always #5 clock=~clock;   \\n', 'endmodule\\n']"}
{"text": "['`timescale 1 ns / 1 ps\\n', '\\n', 'module FSM \\n', '    (\\n', '    input clk,\\n', '    input reset,\\n', '    \\n', '    // Auxiliars from DATAPATH\\n', '    input [11:0] codif,\\n', '    \\n', '    // Inputs from DATAPATH\\n', '    input busy_mem, \\n', '    input done_mem,\\n', '    input aligned_mem,\\n', '    input done_exec,\\n', '    input is_exec,\\n', '    \\n', '    // Outputs to DATAPATH\\n', '    output reg [1:0] W_R_mem,\\n', '    output [1:0] wordsize_mem,\\n', '    output     sign_mem,\\n', '    output reg en_mem,\\n', '    output reg enable_exec,\\n', '    output reg enable_exec_mem,\\n', '    output reg trap,\\n', '    output     enable_pc\\n', '    );\\n', '    \\n', '    // MEMORY INTERFACE Auxiliar determination\\n', '    wire write_mem;\\n', '    wire is_mem;\\n', '    wire is_illisn;\\n', '    assign write_mem = ~codif[5];    // This is the only bit differs write/read\\n', \"    assign is_mem = codif[6:0] == 7'b0100011 || codif[6:0] == 7'b0000011 ? 1'b1 : 1'b0;    // OPCODE detection\\n\", '    assign sign_mem = ~codif[9];    // This is the only bit differs signed/unsigned\\n', '    assign wordsize_mem = codif[8:7];    // This is the only bit differs wordsize\\n', \"    assign is_illisn = &codif || (codif == 12'b000011110011); // FIXME: Also is illegal if ebreak\\n\", '    \\n', '    // CHANGE PC Auxiliar determination\\n', '    reg enable_pc_aux, enable_pc_fsm;\\n', '    always @ (posedge clk) begin\\n', \"        if (reset == 1'b0)\\n\", \"            enable_pc_aux <= 1'b0;\\n\", '        else\\n', '            enable_pc_aux <= enable_pc_fsm;\\n', '    end\\n', \"    assign enable_pc = enable_pc_aux == 1'b0 && enable_pc_fsm == 1'b1 ? 1'b1 : 1'b0;\\n\", '    \\n', '    // ERROR Auxiliar determination\\n', '    wire err;\\n', '    assign err = ~aligned_mem;    // TODO: ILLISN\\n', '    \\n', '    // Declare state register\\n', '    reg        [3:0] state;\\n', '    \\n', '    // Declare states\\n', '    parameter S0_fetch = 0, S1_decode = 1, S2_exec = 2, S3_memory = 3, S4_trap = 4,\\n', '              SW0_fetch_wait = 5, SW3_mem_wait = 6;\\n', '    \\n', '    // Output depends only on the state (transition)\\n', '    // Determine the next state (Moore state machine)\\n', '    always @ (posedge clk) begin\\n', \"        if (reset == 1'b0) begin\\n\", '            state <= S0_fetch;\\n', '            \\n', \"            en_mem <= 1'b0;\\n\", \"            W_R_mem <= 2'b00;\\n\", \"            enable_exec <= 1'b0;\\n\", \"            enable_exec_mem <= 1'b0;\\n\", \"            enable_pc_fsm <= 1'b0;\\n\", \"            trap <= 1'b0;\\n\", '        end else\\n', '            if(err) begin\\n', '                state <= S4_trap;\\n', \"                trap <= 1'b1;\\n\", '            end else\\n', '                case (state)\\n', '                    S0_fetch: begin\\n', '                        if(!en_mem) begin\\n', \"                            en_mem <= 1'b1;\\n\", \"                            W_R_mem <= 2'b11;                // For instruction fetching\\n\", '                        end else if (en_mem && !done_mem) begin\\n', '                            state <= SW0_fetch_wait;\\n', \"                            en_mem <= 1'b0;\\n\", '                        end else if (en_mem && done_mem) begin\\n', '                            state <= S1_decode;\\n', \"                            W_R_mem <= 2'b00;\\n\", \"                            en_mem <= 1'b0;\\n\", '                        end\\n', '                        \\n', '                        \\n', '                    end\\n', '                    SW0_fetch_wait: begin\\n', '                        if (done_mem) begin\\n', '                            state <= S1_decode;\\n', \"                            W_R_mem <= 2'b00;\\n\", \"                            en_mem <= 1'b0;\\n\", '                        end \\n', '                    end\\n', '                    S1_decode: begin\\n', '                        if ( is_illisn ) begin\\n', '                            state <= S4_trap;\\n', '                        end else begin\\n', '                            state <= S2_exec;\\n', \"                            enable_exec <= 2'b11;\\n\", \"                            enable_pc_fsm <= 1'b1;\\n\", '                        end\\n', '                    end\\n', '                    S2_exec:\\n', '                        if (is_mem) begin\\n', '                            state <= S3_memory;\\n', \"                            enable_exec <= 2'b00;\\n\", \"                            enable_pc_fsm <= 1'b0;\\n\", '                        end else if (done_exec) begin\\n', '                            state <= S0_fetch;\\n', \"                            enable_exec <= 2'b00;\\n\", \"                            enable_pc_fsm <= 1'b0;\\n\", '                        end else\\n', '                            state <= S2_exec;\\n', '                    S3_memory: begin\\n', '                        if(!en_mem) begin\\n', \"                            en_mem <= 1'b1;\\n\", '                            enable_exec_mem <= write_mem;\\n', \"                            W_R_mem <= {1'b0, write_mem};                // For reading/writting\\n\", '                        end else if (en_mem && !done_mem) begin\\n', '                            state <= SW3_mem_wait;\\n', \"                            en_mem <= 1'b0;\\n\", '                        end else if (en_mem && done_mem) begin\\n', '                            state <= S0_fetch;\\n', \"                            W_R_mem <= 2'b00;\\n\", \"                            en_mem <= 1'b0;\\n\", \"                            enable_exec_mem <= 1'b0;\\n\", '                        end\\n', '                    end\\n', '                    SW3_mem_wait: begin\\n', '                        if (done_mem) begin\\n', '                            state <= S0_fetch;\\n', '                            \\n', \"                            W_R_mem <= 2'b00;\\n\", \"                            enable_exec_mem <= 1'b0;\\n\", \"                            en_mem <= 1'b0;\\n\", '                        end else\\n', '                            state <= SW3_mem_wait;\\n', '                    end\\n', '                    S4_trap: begin\\n', '                        state <= S4_trap;\\n', \"                        trap <= 1'b1;\\n\", '                    end\\n', '                endcase\\n', '    end\\n', '    \\n', '\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module divM(\\n', '    input wire clk_in, enable,\\n', '    input wire RESET,\\n', '    input wire [31:0] freq,\\n', '    output reg clk_out);\\n', '\\n', '    //-- Valor por defecto del divisor\\n', '    //-- Como en la iCEstick el reloj es de 12MHz, ponermos un valor de 12M\\n', '    //-- para obtener una frecuencia de salida de 1Hz\\n', '\\n', '    //assign M = freq;\\n', '    // M = 12_000_000;\\n', '\\n', '    //-- Numero de bits para almacenar el divisor\\n', '    //-- Se calculan con la funcion de verilog $clog2, que nos devuelve el \\n', '    //-- numero de bits necesarios para representar el numero M\\n', '    //-- Es un parametro local, que no se puede modificar al instanciar\\n', '    localparam N = 32;\\n', '\\n', '    //-- Registro para implementar el contador modulo M\\n', '    reg [N-1:0] divcounter = 0;\\n', '\\n', '    //-- M module counter\\n', '    always @(posedge clk_in)\\n', '        if (!RESET || !enable)\\n', '        begin\\n', \"            divcounter = 32'b0;\\n\", \"            clk_out    =  1'b0;\\n\", '        end else if (divcounter == freq - 1) begin\\n', \"            divcounter = 32'b0;\\n\", \"            clk_out    =  1'b1;\\n\", '        end else begin\\n', '            divcounter = divcounter + 1;\\n', '            clk_out    = 0; \\n', '        end\\n', '\\n', 'endmodule\\n', '\\n', 'module Count(\\n', '    input clk_in, enable,\\n', '    input wire [31:0]freq,\\n', '    input wire [31:0] Max_count,\\n', '    input RESET,\\n', '    output reg Ready_count,\\n', '    output wire [31:0] Count_out\\n', '    );\\n', '\\n', '    wire clk;\\n', '    reg [31:0] Max_count_int, freq_int;\\n', '    reg enable_int,Ready_count_int    ;\\n', '    \\n', '    divM instance_name (\\n', '    .clk_in(clk_in),\\n', '     .enable(enable_int),\\n', '     .freq(freq_int),\\n', '     .RESET(RESET),\\n', '     .clk_out(clk)\\n', '    );\\n', '    \\n', '    localparam N = 32;\\n', '    reg b;wire c;    \\n', '    always @(posedge clk_in)\\n', '        if (!RESET)    begin\\n', '            enable_int   = 0;\\n', \"            Ready_count  = 1'b0;\\n\", '        end else if (enable) begin\\n', '            enable_int   = 1;\\n', \"            Ready_count  = 1'b0;\\n\", \"            b            = 1'b1;\\n\", '        end    else if (Ready_count_int) begin\\n', '            enable_int   = 0; \\n', \"            b  =  1'b0;\\n\", '            Ready_count = c;\\n', '        end    else begin\\n', '            Ready_count = c;\\n', '        end\\n', '            \\n', \"    assign c = b? Ready_count_int:1'b0;\\n\", '      always @(posedge clk_in)\\n', '      if (!RESET)\\n', '        begin\\n', \"            Max_count_int = 32'b0;\\n\", \"            freq_int      = 32'b0;\\n\", '        end    else if (enable_int) begin\\n', '            Max_count_int = Max_count;\\n', '            freq_int      = freq;\\n', '        end    else begin\\n', \"            Max_count_int = 32'b0;\\n\", \"            freq_int      = 32'b0;\\n\", '        end\\n', '\\n', '  \\n', '    reg [N-1:0] divcounter = 0;\\n', '\\n', '    //-- M module counter\\n', '    always @(posedge clk_in)\\n', '        if (!RESET ) begin\\n', \"            divcounter = 32'b0;\\n\", \"            Ready_count_int   = 1'b0;\\n\", '        end else if (clk && enable_int) begin\\n', '            if (divcounter == Max_count_int ) begin\\n', \"                divcounter =32'b0;\\n\", \"                Ready_count_int   = 1'b1;\\n\", '            end else begin\\n', '                divcounter = divcounter + 1;\\n', \"                Ready_count_int   = 1'b0; \\n\", '            end\\n', '        end\\n', '      assign Count_out = divcounter;\\n', 'endmodule\\n', '\\n', 'module IRQ(\\n', '    input rst,clk,savepc,en,\\n', '    input [11:0] instr,\\n', '    input [31:0] rs1, rs2, inirr, pc, imm,\\n', '    output [31:0] rd, addrm, outirr, pc_irq, pc_c, // pc_c es el pc en d\u00f3nde se estaba antes de la irr, a donde hay q volver una vez finalice la(s) irr\\n', '    output flag\\n', '    );\\n', '\\n', '    reg flag_q,irr_tisirr,enable,irr_ebreak;\\n', '    wire any_inirr,any_regirr,rs1_chg,act_irr,flag_ind,imm_chg,R_C;\\n', '    wire [31:0] ss2,erased_irrstate,irrstate,C_O,irr_toerase;\\n', '    reg [31:0] regirr,pc_c_q,addrm_q,true_irrstate,m6,rs1t,immt,timer_count,timer_max_count,div_freq,q,irrstate_rd,pc_irq_reg,rd1;\\n', '    reg [8:0] instr_sel;\\n', '    \\n', '    wire is_ebreak;\\n', '    wire is_addrms;\\n', '    wire is_addrme;\\n', '    wire is_tisirr;\\n', '    wire is_irrstate;\\n', '    wire is_clraddrm;\\n', '    wire is_clrirq;\\n', '    wire is_retirq;\\n', '    wire is_addpcirq;\\n', '    \\n', '    ////////////////////////////////////////////////////////////.\\n', '    // ** Interruption generation\\n', '    assign any_inirr = inirr ? 1:0;\\n', '    \\n', '    always@(posedge clk) // ebreak interrupt\\n', '        if (!rst) irr_ebreak=0;\\n', '        else if (is_ebreak) irr_ebreak=1;\\n', '        else irr_ebreak=0;\\n', '    \\n', '    always@(posedge clk) // timer interrupt\\n', '        if(!rst) begin \\n', '            enable=0; \\n', '            irr_tisirr=0; \\n', '            timer_count=0; \\n', '            div_freq=0; \\n', '            timer_max_count=0; \\n', '        end else if (is_tisirr) begin \\n', '            enable=1; \\n', '            irr_tisirr=0; \\n', '            timer_count=0; \\n', '            div_freq=rs1; \\n', '            timer_max_count=rs2; \\n', '        end    else begin\\n', '            enable=0; \\n', '            irr_tisirr=R_C; \\n', '            timer_count=C_O;     // Basically is not used\\n', '            div_freq=0; \\n', '            timer_max_count=0; \\n', '        end\\n', '    Count timer_counter (\\n', '        .clk_in(clk), \\n', '        .enable(enable), \\n', '        .freq(div_freq), \\n', '        .Max_count(timer_max_count), \\n', '        .RESET(rst), \\n', '        .Ready_count(R_C), \\n', '        .Count_out(C_O)\\n', '        );\\n', '\\n', '    always@(posedge clk)\\n', '        if(!rst) regirr=0;\\n', '        else regirr={inirr[31:2],irr_tisirr,irr_ebreak};\\n', '        \\n', '    assign any_regirr = regirr ? 1:0;\\n', '    \\n', '    ////////////////////////////////////////////////////////////\\n', '    // ** Interrupt erasing and flagging\\n', '        \\n', \"    // irr_toerase assign, this is the interrupt indicated to be erased via 'is_clrirq'\\n\", '    assign irr_toerase=rs1|imm;\\n', '    assign erased_irrstate = (~irr_toerase)&true_irrstate;\\n', '    \\n', '    // Update new irrstate\\n', '    always@(posedge clk)\\n', '        if(!rst) true_irrstate<=0;\\n', '        else if(is_clrirq) true_irrstate <= erased_irrstate;\\n', '        else true_irrstate <= regirr | true_irrstate;\\n', '        \\n', '    assign irrstate = true_irrstate;\\n', '    \\n', '    // Acknoledge generation\\n', '    always@(posedge clk)\\n', '        if (!rst) q<=0;\\n', '        else if (is_clrirq) q<=irr_toerase&true_irrstate;\\n', '        else q<=0;\\n', '    assign outirr=q;\\n', '        \\n', '    // Flag generation\\n', '    assign act_irr = irrstate? 0:1;         // Active irr indicator\\n', '    assign flag_ind= act_irr & is_retirq;     // Flag indicator    \\n', '    always@(posedge clk)                     // Flag\\n', '        if(!rst) flag_q=0;\\n', '        else if(any_inirr) flag_q=1;\\n', '        else if (flag_ind) flag_q=0;\\n', '        else flag_q=flag_q; \\n', '    assign flag=flag_q;\\n', '    \\n', '    ////////////////////////////////////////////////////////////\\n', '    // ** Instruction Selector\\n', '    always @* \\n', '        case({instr,en})\\n', \"            13'b0000001110011: begin instr_sel = 9'b000000001;     rd1=0;          end     //EBREAK 0 \\n\", \"            13'b0000100110001: begin instr_sel = 9'b000000010;     rd1=0;          end     //ADDRMS 1 \\n\", \"             13'b0001000110001: begin instr_sel = 9'b000000100;     rd1=addrm_q;     end      //ADDRME 2\\n\", \"            13'b0001100110001: begin instr_sel = 9'b000001000;     rd1=0;          end      //TISIRR 3 \\n\", \"            13'b0010000110001: begin instr_sel = 9'b000010000;     rd1=irrstate_rd;end      //IRRSTATE 4\\n\", \"            13'b0010100110001: begin instr_sel = 9'b000100000;     rd1=0;          end      //CLRADDRM 5\\n\", \"            13'b0011000110001: begin instr_sel = 9'b001000000;     rd1=0;          end      //CLRIRQ 6\\n\", \"            13'b0011100110001: begin instr_sel = 9'b010000000;     rd1=0;          end      //RETIRQ 7\\n\", \"            13'b0000000110001: begin instr_sel = 9'b100000000;     rd1=0;          end      //ADDPCIRQ 8\\n\", \"            default          : begin instr_sel = 9'b000000000;     rd1={32{1'bz}};    end\\n\", '        endcase\\n', '    assign is_ebreak   = instr_sel[0];\\n', '    assign is_addrms   = instr_sel[1];\\n', '    assign is_addrme   = instr_sel[2];\\n', '    assign is_tisirr   = instr_sel[3];\\n', '    assign is_irrstate = instr_sel[4];\\n', '    assign is_clraddrm = instr_sel[5];\\n', '    assign is_clrirq   = instr_sel[6];\\n', '    assign is_retirq   = instr_sel[7];\\n', '    assign is_addpcirq = instr_sel[8];\\n', '    \\n', '    assign rd=rd1;\\n', '        \\n', '    /////////////////////////////////////////////////////////////\\n', '    // ** Instruction - dedicated registers\\n', '    always@(posedge clk) // pc_irq with addpcirq\\n', '        if(!rst) pc_irq_reg=0;\\n', '        else if (is_addpcirq) pc_irq_reg=rs1+imm;\\n', '        else pc_irq_reg=pc_irq_reg; \\n', '    assign pc_irq=pc_irq_reg;\\n', '    \\n', '    always@(posedge clk) // irrstate out (rd)\\n', '        if (!rst) irrstate_rd=0;\\n', '        else if (is_irrstate) irrstate_rd=irrstate;\\n', '        else irrstate_rd=irrstate_rd;    \\n', '    \\n', \"    always@(posedge clk) // Stores accord to instruction in 'addrm' and erases it\\n\", '        if(!rst) addrm_q=0;\\n', '        else if (is_addrms)addrm_q=rs1;    // for addrms\\n', '        else if (is_clraddrm)addrm_q=0;    // for clraddrm\\n', '        else addrm_q=addrm_q;\\n', '    assign addrm=addrm_q;\\n', '    \\n', '    always@(posedge clk)    // Not an instruction, this is backup pc when there is an interrupt\\n', '        if(!rst) pc_c_q=0;\\n', '        else if(savepc) pc_c_q=pc;\\n', '        else pc_c_q=pc_c_q;\\n', '    assign pc_c=pc_c_q;\\n', '    \\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module sim_IRQf;\\n', '\\n', '\\t// Inputs\\n', '\\treg rst;\\n', '\\treg clk;\\n', '\\treg savepc;\\n', '\\treg en;\\n', '\\treg [11:0] instr;\\n', '\\treg [31:0] rs1;\\n', '\\treg [31:0] rs2;\\n', '\\treg [31:0] inirr;\\n', '\\treg [31:0] pc;\\n', '\\treg [31:0] imm;\\n', '\\n', '\\t// Outputs\\n', '\\twire [31:0] rd;\\n', '\\twire [31:0] addrm;\\n', '\\twire [31:0] outirr;\\n', '\\twire [31:0] pc_irq;\\n', '\\twire [31:0] pc_c;\\n', '\\twire flag;\\n', '\\n', '\\t// Instantiate the Unit Under Test (UUT)\\n', '\\tIRQ uut (\\n', '\\t\\t.rst(rst), \\n', '\\t\\t.clk(clk), \\n', '\\t\\t.savepc(savepc), \\n', '\\t\\t.en(en), \\n', '\\t\\t.instr(instr), \\n', '\\t\\t.rs1(rs1), \\n', '\\t\\t.rs2(rs2), \\n', '\\t\\t.inirr(inirr), \\n', '\\t\\t.pc(pc), \\n', '\\t\\t.imm(imm), \\n', '\\t\\t.rd(rd), \\n', '\\t\\t.addrm(addrm), \\n', '\\t\\t.outirr(outirr), \\n', '\\t\\t.pc_irq(pc_irq), \\n', '\\t\\t.pc_c(pc_c), \\n', '\\t\\t.flag(flag)\\n', '\\t);\\n', '\\n', '\\tinitial begin\\n', '\\t\\t// Initialize Inputs\\n', '\\t\\trst = 0;\\n', '\\t\\tclk = 1;\\n', '\\t\\tsavepc = 0;\\n', '\\t\\ten = 0;\\n', '\\t\\tinstr = 0;\\n', '\\t\\trs1 = 0;\\n', '\\t\\trs2 = 0;\\n', '\\t\\tinirr = 0;\\n', '\\t\\tpc = 0;\\n', '\\t\\timm = 0;\\n', '\\n', '\\t\\t// Wait 100 ns for global reset to finish\\n', '\\t\\t#100;\\n', '      rst=1;\\n', '\\t\\t#20;\\n', '\\t\\tsavepc=1;\\n', '\\t\\tpc=5;\\n', '\\t\\t#20;\\n', '\\t\\tpc=0;\\n', '\\t\\t#20;\\n', '\\t\\tsavepc=0;\\n', '\\t\\t#20;\\n', '\\t\\ten=1;\\n', '\\t\\t#15;\\n', '\\t\\t// Add stimulus here\\n', '\\t\\tinirr=4;\\n', '\\t\\t#10;\\n', '\\t\\tinirr=0;\\n', '\\t\\t#30;\\n', '\\t\\tinirr=8;\\n', '\\t\\t#20;\\n', '\\t\\tinirr=1024;\\n', '\\t\\t#20;\\n', '\\t\\tinirr=256;\\n', '\\t\\t#20;\\n', '\\t\\tinirr=0;\\n', '\\t\\t#10;\\n', \"\\t\\tinstr=12'b000000111001;\\n\", '\\t\\t#20;\\n', '\\t\\tinstr=0;\\n', '\\t\\t#55;\\n', \"\\t\\tinstr=12'b001100011000;\\n\", '\\t\\trs1=7;\\n', \"\\t\\timm=11'b10100001000;\\n\", '\\t\\t#20;\\n', '\\t\\tinstr=0;\\n', '\\t\\trs1=0;\\n', '\\t\\timm=2;\\n', '\\t\\t#20;\\n', '\\t\\tinstr=0;\\n', '\\t\\trs1=0;\\n', '\\t\\timm=0;\\n', '\\t\\t#20;\\n', \"\\t\\tinstr=12'b001110011000;\\n\", '\\t\\t#20;\\n', '\\t\\tinstr=0;\\n', '\\t\\t#20;\\n', \"\\t\\tinstr=12'b000000011000;\\n\", '\\t\\trs1=32;\\n', '\\t\\timm=4;\\n', '\\t\\t#20;\\n', \"\\t\\tinstr=12'b000010011000;\\n\", '\\t\\t#40;\\n', '\\t\\tinstr=0;\\n', '\\t\\t//rs1=0;\\n', '\\t\\timm=0;\\n', '\\t\\t#40;\\n', \"\\t\\tinstr=12'b000100011000;\\n\", '\\t\\t#20;\\n', \"\\t\\tinstr=12'b001010011000;\\n\", '\\t\\t#20;\\n', '\\t\\tinstr=0;\\n', '\\t\\t#20;\\n', \"\\t\\tinirr=5'b10101;\\n\", '\\t\\t#20;\\n', '\\t\\tinirr=0;\\n', '\\t\\t#20\\n', \"\\t\\tinstr=12'b001000011000;\\n\", '\\t\\t#40\\n', '\\t\\tinstr=0;\\n', '\\n', '\\t\\t\\n', '\\tend\\n', '\\t\\n', '   always\\t#10 clk = !clk;  \\n', '      \\n', 'endmodule\\n', '\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module MEMORY_INTERFACE(\\n', '    input clock,\\n', '    input resetn,\\n', '    input [31:0] rs1,\\n', '    input [31:0] rs2,\\n', '    input [31:0] Rdata_mem,\\n', '    input ARready,\\n', '    input Rvalid,\\n', '    input AWready,\\n', '    input Wready,\\n', '    input Bvalid,\\n', '    input [31:0] imm, \\n', '    input [1:0] W_R,\\n', '    input [1:0] wordsize,\\n', '    input enable,\\n', '    input [31:0] pc,\\n', '    input signo,\\n', '    \\n', '    output reg busy, \\n', '    output reg done,\\n', '    output reg align, \\n', '    output reg [31:0] AWdata,\\n', '    output reg [31:0] ARdata,\\n', '    output reg [31:0] Wdata,\\n', '    output [31:0] rd,\\n', '    output reg [31:0] inst,\\n', '    output reg ARvalid,\\n', '    output reg RReady,\\n', '    output reg AWvalid,\\n', '    output reg Wvalid,\\n', '    output reg [2:0] arprot,\\n', '    output reg [2:0] awprot,\\n', '    output reg Bready,\\n', '    output reg [3:0] Wstrb,\\n', '    output reg rd_en\\n', '    //output reg [3:0] Rstrb\\n', '    );\\n', '    \\n', '    \\n', '    reg [15:0] relleno16;\\n', '    reg [23:0] relleno24;\\n', '    reg [31:0] Rdataq,Wdataq;\\n', '    reg [3:0] Wstrbq;\\n', '    reg [31:0] rdu;\\n', '    reg en_instr;\\n', '    reg en_read;\\n', '///////////////////////////////////////////////////////////////////////////////////\\n', '/////////////// BEGIN FSM\\n', '/////////////// FIX: CREATE THE MEALY FSM!\\n', '//////////////////////////////////////////////////////////////////////////////////    \\n', '    reg [3:0] state,nexstate;\\n', '\\n', \"    parameter reposo     = 4'd0;\\n\", \"    parameter inicioR     = 4'd1;\\n\", \"    parameter SR1         = 4'd2;\\n\", \"    parameter SR2         = 4'd3;\\n\", \"    parameter inicioW     = 4'd4;\\n\", \"    parameter SW0         = 4'd5;\\n\", \"    parameter SW1         = 4'd6;\\n\", \"    parameter SW2        = 4'd7;\\n\", \"    parameter SWB         = 4'd8;\\n\", '    \\n', '    // Next state and output logic\\n', '    always @* begin\\n', \"        ARvalid    = 1'b0;\\n\", \"        RReady     = 1'b0;\\n\", \"        AWvalid    = 1'b0;\\n\", \"        Wvalid    = 1'b0;\\n\", \"        Bready    = 1'b0;\\n\", \"        busy    = 1'b0;\\n\", \"        en_read = 1'b0;\\n\", '        nexstate = state;\\n', \"        if(resetn == 1'b1) begin\\n\", '            case (state)\\n', '                reposo : begin\\n', '                    // If reading or gathering instructions?\\n', \"                    if ( (W_R[1]==1'b1 || W_R==2'b01) && enable==1'b1 ) begin\\n\", \"                        ARvalid    = 1'b1;     // Pre-issue the ARvalid\\n\", \"                        RReady = 1'b1;      // There is no problem if this is issued since before\\n\", \"                        if(ARready && Rvalid) begin en_read = 1'b1; busy = 1'b0; end     // In the same cycle sync read\\n\", \"                        else if(ARready && !Rvalid) begin nexstate = SR2; busy = 1'b1; end // Wait for Rvalid\\n\", \"                        else begin nexstate = SR1; busy = 1'b1; end\\n\", '                    // If writing?\\n', \"                    end else if (W_R==2'b00 && enable==1'b1) begin\\n\", \"                        AWvalid    = 1'b1;     // Pre-issue AWvalid\\n\", \"                        Wvalid = 1'b1;      // Pre-issue Wvalid\\n\", \"                        Bready = 1'b1;      // There is no problem if this is issued since before\\n\", \"                        if(!AWready && !Wready) begin                    nexstate = SW0; busy = 1'b1;\\n\", \"                        end else if(AWready && !Wready) begin            nexstate = SW1; busy = 1'b1;\\n\", \"                        end else if(!AWready && Wready) begin            nexstate = SW2; busy = 1'b1;\\n\", \"                        end else if(AWready && Wready && !Bvalid) begin  nexstate = SWB; busy = 1'b1;\\n\", '                        end //else if(AWready && Wready && Bvalid)  // Action not necesary\\n', '                    end else begin\\n', '                        nexstate = reposo;\\n', '                    end\\n', '                end\\n', '\\n', '                SR1 : begin\\n', \"                    RReady = 1'b1;\\n\", \"                    ARvalid    = 1'b1;\\n\", '                    if(ARready && Rvalid) begin\\n', \"                        en_read = 1'b1;     // In the same cycle sync read\\n\", '                        nexstate = reposo;\\n', '                    end else if(ARready && !Rvalid) begin\\n', '                        nexstate = SR2;\\n', \"                        busy = 1'b1;\\n\", '                    end else begin\\n', '                        nexstate = SR1;\\n', \"                        busy = 1'b1;\\n\", '                    end\\n', '                end\\n', '\\n', '                SR2 : begin\\n', \"                    RReady = 1'b1;\\n\", '                    if(Rvalid) begin\\n', \"                        en_read = 1'b1;     // In the same cycle sync read\\n\", '                        nexstate = reposo;\\n', '                    end else begin\\n', '                        nexstate = SR2;\\n', \"                        busy = 1'b1;\\n\", '                    end\\n', '                end\\n', '\\n', '                SW0 : begin\\n', \"                    AWvalid = 1'b1;\\n\", \"                    Wvalid = 1'b1;\\n\", \"                    Bready = 1'b1;      // There is no problem if this is issued since before\\n\", '                    if(AWready && !Wready) begin\\n', '                        nexstate = SW1;\\n', \"                        busy = 1'b1;\\n\", '                    end else if(!AWready && Wready) begin             \\n', '                        nexstate = SW2;\\n', \"                        busy = 1'b1;\\n\", '                    end else if(AWready && Wready && !Bvalid) begin  \\n', '                        nexstate = SWB;\\n', \"                        busy = 1'b1;\\n\", '                    end else if(AWready && Wready && Bvalid) begin   \\n', '                        nexstate = reposo;\\n', '                    end else begin\\n', '                        nexstate = SW0;\\n', \"                        busy = 1'b1;\\n\", '                    end\\n', '                end\\n', '\\n', '                SW1 : begin\\n', \"                    //AWvalid = 1'b1;\\n\", \"                    Wvalid = 1'b1;\\n\", \"                    Bready = 1'b1;      // There is no problem if this is issued since before\\n\", '                    if (Wready && !Bvalid) begin\\n', '                        nexstate=SWB;\\n', \"                        busy = 1'b1;\\n\", '                    end else if(Wready && Bvalid) begin\\n', '                        nexstate=reposo;\\n', '                    end else begin\\n', '                        nexstate=SW1;\\n', \"                        busy = 1'b1;\\n\", '                    end\\n', '                end\\n', '\\n', '                SW2 : begin\\n', \"                    AWvalid = 1'b1;\\n\", \"                    //Wvalid = 1'b1;\\n\", \"                    Bready = 1'b1;      // There is no problem if this is issued since before\\n\", '                    if (AWready && !Bvalid) begin\\n', '                        nexstate=SWB;\\n', \"                        busy = 1'b1;\\n\", '                    end else if(AWready && Bvalid) begin\\n', '                        nexstate=reposo;\\n', '                    end else begin\\n', '                        nexstate=SW2;\\n', \"                        busy = 1'b1;\\n\", '                    end\\n', '                end\\n', '            \\n', '                SWB : begin\\n', \"                    Bready = 1'b1;\\n\", '                    if (Bvalid) begin\\n', '                        nexstate=reposo;\\n', '                    end else begin\\n', '                        nexstate=SWB;\\n', \"                        busy = 1'b1;\\n\", '                    end\\n', '                end\\n', '\\n', '                default : begin  // Fault Recovery\\n', '                    nexstate = reposo;\\n', '                end   \\n', '            endcase\\n', '        end\\n', '        \\n', '        done    = !busy;    // Because fuck this\\n', '    end\\n', '\\n', '    // State Sync\\n', '    always @(posedge clock)\\n', '        if(resetn == 0) state <= reposo;\\n', '        else state <= nexstate;\\n', '        \\n', '/////////////////////////////////////////////////////////////////////////////////////////////////////////////    \\n', '////////////////////// END FSM\\n', '///////////////////////////////////////////////////////////////////////////////////////////\\n', '    \\n', '    always @* begin\\n', '        // Default values\\n', '        en_instr     = 0;\\n', '        rd_en        = 0;\\n', \"        awprot       = 3'b000;\\n\", '        AWdata       = rs1+imm;\\n', \"        arprot       = 3'b000;\\n\", '        ARdata       = rs1+imm;\\n', '        align        = 1;\\n', '        Wdataq       = 0;\\n', \"        Wstrbq       = 4'b0000;\\n\", '        Rdataq       = 0;\\n', '        relleno16    = 0;\\n', '        relleno24    = 0;\\n', '        \\n', '        case (W_R)\\n', \"            2'b00  : begin\\n\", '                en_instr = 0;\\n', \"                awprot = 3'b000;\\n\", '                AWdata = rs1+imm;\\n', '                case (wordsize)\\n', \"                    2'b10  : begin\\n\", \"                        if(enable) align=(AWdata[1:0]==2'b00)? 1:0;\\n\", '                        Wdataq=rs2;\\n', \"                        Wstrbq=4'b1111;\\n\", '                    end\\n', \"                    2'b01  : begin\\n\", \"                        if(enable) align=(AWdata[0]==1'b0)? 1:0;\\n\", \"                        Wstrbq = AWdata[1] ? 4'b1100 : 4'b0011;\\n\", '                        Wdataq={2{rs2[15:0]}};\\n', '                    end\\n', \"                    2'b00  : begin\\n\", '                        align=1;\\n', \"                        Wstrbq = 4'b0001 << ARdata[1:0];\\n\", '                        Wdataq={4{rs2[7:0]}};\\n', '                    end\\n', '                endcase                        \\n', '            end\\n', '\\n', \"            2'b10,2'b11  : begin\\n\", \"                en_instr=1'b1;\\n\", '                AWdata=pc;\\n', '                ARdata=pc;\\n', \"                arprot=3'b100;\\n\", '            end\\n', '\\n', \"            2'b01 : begin\\n\", '                if(en_read) rd_en=1;\\n', \"                arprot=3'b000;\\n\", '                en_instr=0;\\n', '                ARdata= rs1+imm;\\n', '                case (wordsize)\\n', \"                    2'b10  : begin\\n\", '                        if(enable) align=(ARdata[1:0]==0)? 1:0;\\n', '                        Rdataq=Rdata_mem;\\n', '                    end\\n', '                    \\n', \"                    2'b01  : begin\\n\", '                        if(enable) align=(ARdata[0]==0)? 1:0;\\n', '                        case (ARdata[1])\\n', \"                            1'b0: begin \\n\", '                                case (signo) \\n', \"                                    1'b1: relleno16={16{Rdata_mem[15]}};\\n\", \"                                    1'b0: relleno16=16'd0;\\n\", '                                endcase\\n', '                                Rdataq= {relleno16,Rdata_mem[15:0]};\\n', '                            end\\n', \"                            1'b1: begin \\n\", '                                case (signo) \\n', \"                                    1'b1: relleno16={16{Rdata_mem[31]}};\\n\", \"                                    1'b0: relleno16=16'd0;\\n\", '                                endcase\\n', '                                Rdataq = {relleno16,Rdata_mem[31:16]};\\n', '                            end\\n', '                        endcase\\n', '                    end\\n', '            \\n', \"                    2'b00  : begin\\n\", '                        align=1;\\n', '                        case (ARdata[1:0])\\n', \"                            2'b00:  begin \\n\", '                                case (signo) \\n', \"                                    1'b0: relleno24=24'd0;\\n\", \"                                    1'b1: relleno24={24{Rdata_mem[7]}};\\n\", '                                endcase\\n', '                                Rdataq = {relleno24,Rdata_mem[ 7: 0]}; \\n', '                            end\\n', \"                            2'b01:  begin \\n\", '                                case (signo) \\n', \"                                    1'b0: relleno24=24'd0;\\n\", \"                                    1'b1: relleno24={24{Rdata_mem[15]}};\\n\", '                                endcase \\n', '                                Rdataq = {relleno24,Rdata_mem[15: 8]}; \\n', '                            end\\n', \"                            2'b10:  begin \\n\", '                                case (signo) \\n', \"                                    1'b0: relleno24=24'd0;\\n\", \"                                    1'b1: relleno24={24{Rdata_mem[23]}};\\n\", '                                endcase\\n', '                                Rdataq = {relleno24,Rdata_mem[23:16]}; \\n', '                            end\\n', \"                            2'b11:  begin \\n\", '                                case (signo) \\n', \"                                    1'b0: relleno24=24'd0;\\n\", \"                                    1'b1: relleno24={24{Rdata_mem[31]}};\\n\", '                                endcase \\n', '                                Rdataq = {relleno24,Rdata_mem[31:24]}; \\n', '                            end\\n', '                        endcase\\n', '                    end\\n', '                endcase    \\n', '            end\\n', '        endcase\\n', '    end\\n', '    \\n', '\\n', '    always @ (posedge clock) begin\\n', '        if (!resetn) begin\\n', \"            Wdata <= 32'd0;\\n\", \"            rdu <= 32'd0;\\n\", \"            Wstrb <= 4'b0000;\\n\", \"            inst <= 32'd0;\\n\", '                 \\n', '        end else begin \\n', '            Wdata<=Wdataq;\\n', '            Wstrb<=Wstrbq;\\n', '            if(en_read) rdu<=Rdataq;\\n', '            if(en_instr && en_read) inst <= Rdata_mem;\\n', '        end\\n', '    end\\n', '    \\n', \"    assign rd= rd_en?Rdataq:32'bz;\\n\", '         \\n', '\\n', 'endmodule\\n', '\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', '/*\\n', 'mriscvcore\\n', 'by CKDUR\\n', '\\n', 'This is the definitive core.\\n', '*/\\n', '\\n', 'module mriscvcore(\\n', '    input clk,\\n', '    input rstn,\\n', '    \\n', '    // AXI-4 LITE INTERFACE\\n', '    input [31:0] Rdata,\\n', '    input ARready,\\n', '    input Rvalid,\\n', '    input AWready,\\n', '    input Wready,\\n', '    input Bvalid, \\n', '    output [31:0] AWdata,\\n', '    output [31:0] ARdata,\\n', '    output [31:0] Wdata,\\n', '    output ARvalid,\\n', '    output RReady,\\n', '    output AWvalid,\\n', '    output Wvalid,\\n', '    output [2:0] ARprot,AWprot,\\n', '    output Bready,\\n', '    output [3:0] Wstrb,\\n', '    \\n', '    // IRQ interface\\n', '    \\n', '    input [31:0] inirr,\\n', '    output [31:0] outirr,\\n', '    output trap\\n', '     \\n', '    );\\n', '    \\n', '// SIGNAL DECLARATION     *********************************************************\\n', '\\n', '// Data Buses\\n', 'wire [31:0] rd, rs1, rs2, imm, pc, inst;\\n', 'wire [11:0] code;\\n', 'wire [11:0] codif;\\n', '\\n', '// Auxiliars\\n', 'wire [4:0] rs1i, rs2i, rdi;\\n', '\\n', '//IRQ SIGNALS\\n', 'wire [31:0] pc_c, addrm, pc_irq;\\n', 'wire flag;\\n', '//MEMORY INTERFACE SIGNALS\\n', 'wire is_rd_mem;\\n', 'wire [1:0] W_R_mem, wordsize_mem;\\n', 'wire sign_mem, en_mem, busy_mem, done_mem, align_mem;\\n', '//SIGNALS DECO INST\\n', 'wire enableDec;    \\n', '//SIGNALS MULT\\n', 'wire enable_mul, done_mul, is_inst_mul;\\n', '//SIGNALS ALU\\n', 'wire cmp, carry, enable_alu, is_inst_alu, is_rd_alu;\\n', '//SIGNALS UTILITY\\n', 'wire is_inst_util, is_rd_util;\\n', '//SIGNALS FSM\\n', 'wire is_exec;\\n', '\\n', '\\n', '// DATAPATH PHASE    *************************************************************\\n', '\\n', 'MEMORY_INTERFACE MEMORY_INTERFACE_inst(\\n', '    .clock(clk),\\n', '    .resetn(rstn),\\n', '    // Data buses\\n', '    .rs1(rs1),\\n', '    .rs2(rs2),\\n', '    .rd(rd),\\n', '    .imm(imm), \\n', '    .pc(pc),\\n', '    .rd_en(is_rd_mem),\\n', '    // AXI4-Interface\\n', '    .Rdata_mem(Rdata),\\n', '    .ARready(ARready),\\n', '    .Rvalid(Rvalid),\\n', '    .AWready(AWready),\\n', '    .Wready(Wready),\\n', '    .Bvalid(Bvalid),\\n', '    .AWdata(AWdata),\\n', '    .ARdata(ARdata),\\n', '    .Wdata(Wdata),\\n', '    .ARvalid(ARvalid),\\n', '    .RReady(RReady),\\n', '    .AWvalid(AWvalid),\\n', '    .Wvalid(Wvalid),\\n', '    .arprot(ARprot),\\n', '    .awprot(AWprot),\\n', '    .Bready(Bready),\\n', '    .Wstrb(Wstrb),\\n', '    // To DECO_INSTR\\n', '    .inst(inst),\\n', '    // To FSM\\n', '    .W_R(W_R_mem),\\n', '    .wordsize(wordsize_mem),\\n', '    .signo(sign_mem),\\n', '    .enable(en_mem),\\n', '    .busy(busy_mem), \\n', '    .done(done_mem),\\n', '    .align(align_mem)\\n', '    );\\n', '\\n', '\\n', 'DECO_INSTR DECO_INSTR_inst(\\n', '    .clk(clk),\\n', '    // From MEMORY_INTERFACE\\n', '    .inst(inst),\\n', '    // Auxiliars to BUS\\n', '    .rs1i(rs1i),\\n', '    .rs2i(rs2i),\\n', '    .rdi(rdi),\\n', '    .imm(imm),\\n', '    .code(code),\\n', '    .codif(codif)\\n', '    );\\n', '\\n', 'REG_FILE REG_FILE_inst(\\n', '    .clk(clk),\\n', '    .rst(rstn),\\n', '    .rd(rd),\\n', '    .rdi(rdi),\\n', '    .rdw_rsrn(rdw_rsrn),\\n', '    .rs1(rs1),\\n', '    .rs1i(rs1i),\\n', '    .rs2(rs2),\\n', '    .rs2i(rs2i)\\n', '    );\\n', '\\n', '    \\n', 'ALU ALU_inst(\\n', '    .clk(clk),\\n', '    .reset(rstn),\\n', '    // Data Buses\\n', '    .rs1(rs1),\\n', '    .rs2(rs2),\\n', '    .rd(rd),\\n', '    .decinst(code),\\n', '    .imm(imm),\\n', '    // To UTILITY\\n', '    .cmp(cmp),\\n', '    // To FSM\\n', '    .en(enable_alu),\\n', '    .carry(carry),\\n', '    .is_rd(is_rd_alu),\\n', '    .is_inst(is_inst_alu)\\n', '    );\\n', '    \\n', '     \\n', 'IRQ IRQ_inst(\\n', '    .rst(rstn),\\n', '    .clk(clk),\\n', \"    .savepc(1'b0),\\n\", \"    .en(1'b0),\\n\", '    .instr(code),\\n', '    .rs1(rs1),\\n', '    .rs2(rs2),\\n', '    .inirr(inirr),\\n', '    .pc(pc),\\n', '    .imm(imm),\\n', '    .rd(rd),\\n', '    .addrm(addrm),\\n', '    .outirr(outirr),\\n', '    .pc_irq(pc_irq),\\n', '    .pc_c(pc_c),\\n', '    .flag(flag)\\n', '    );\\n', '\\n', 'MULT MULT_inst(\\n', '    .clk(clk),\\n', '    .reset(rstn),\\n', '    .rs1(rs1),\\n', '    .rs2(rs2),\\n', '    .rd(rd),\\n', '    .Enable(enable_mul),\\n', '    .is_oper(is_inst_mul),\\n', '    .Done(done_mul),\\n', '    .codif(code)\\n', '    );\\n', '\\n', 'UTILITY UTILITY_inst(\\n', '    .clk(clk),\\n', '    .rst(rstn),\\n', '    // FROM DATA BUS\\n', '    .rs1(rs1),\\n', '    .rd(rd),\\n', '    .opcode(code),\\n', '    .imm(imm),\\n', '    .pc(pc),\\n', '    // FROM IRQ\\n', '    .irr_ret(pc_c),\\n', '    .irr_dest(pc_irq),\\n', '    // FROM ALU\\n', '    .branch(cmp),\\n', '    // FSM\\n', \"    .irr(1'b0),\\n\", '    .enable_pc(enable_pc),\\n', '    .is_inst(is_inst_util),\\n', '    .is_rd(is_rd_util)\\n', '    );\\n', '\\n', '// FINITE-STATE MACHINE PHASE    *************************************************\\n', '\\n', 'FSM FSM_inst\\n', '    (\\n', '    .clk(clk),\\n', '    .reset(rstn),\\n', '    \\n', '    // Auxiliars from DATAPATH\\n', '    .codif(codif),\\n', '    \\n', '    // Inputs from DATAPATH\\n', '    .busy_mem(busy_mem), \\n', '    .done_mem(done_mem),\\n', '    .aligned_mem(align_mem),\\n', '    .done_exec(done_exec),\\n', '    .is_exec(is_exec),\\n', '    \\n', '    // Outputs to DATAPATH\\n', '    .W_R_mem(W_R_mem),\\n', '    .wordsize_mem(wordsize_mem),\\n', '    .sign_mem(sign_mem),\\n', '    .en_mem(en_mem),\\n', '    .enable_exec(enable_exec),\\n', '    .enable_exec_mem(enable_exec_mem),\\n', '    .trap(trap),\\n', '    .enable_pc(enable_pc)\\n', '    );\\n', '    \\n', '    // Enable Assign\\n', '    assign enable_mul = enable_exec; \\n', '    assign enable_alu = enable_exec;\\n', '    \\n', '    // Done Assign\\n', '    assign done_exec = is_inst_util | is_inst_alu | (done_mul & is_inst_mul);\\n', '    \\n', '    // Is exec assign\\n', '    assign is_exec = ~(&(code));\\n', '    \\n', '    // Write to rd flag\\n', '    assign rdw_rsrn = (is_rd_util | is_rd_alu | done_mul | (is_rd_mem & done_mem)) & (enable_exec | enable_exec_mem);\\n', '\\n', 'endmodule\\n']"}
{"text": "['`timescale 1 ns / 1 ps\\n', ' //`define VERBOSE\\n', ' //`define AXI_TEST\\n', '\\n', 'module mriscvcore_tb;\\n', '\\n', '\\treg clk = 1;\\n', '\\treg resetn = 0;\\n', '\\treg [31:0] irq;\\n', '\\twire trap;\\n', '\\n', '\\talways @* begin\\n', '\\t\\tirq = 0;\\n', '\\t\\t//irq[4] = &uut.picorv32_core.count_cycle[12:0];\\n', '\\t\\t//irq[5] = &uut.picorv32_core.count_cycle[15:0];\\n', '\\tend\\n', '\\n', '\\talways #10 clk = ~clk;\\n', '\\n', '\\tinitial begin\\n', '\\t\\trepeat (100) @(posedge clk);\\n', '\\t\\tresetn <= 1;\\n', '\\tend\\n', '\\n', '\\twire        mem_axi_awvalid;\\n', '\\treg         mem_axi_awready = 0;\\n', '\\twire [31:0] mem_axi_awaddr;\\n', '\\twire [ 2:0] mem_axi_awprot;\\n', '\\n', '\\twire        mem_axi_wvalid;\\n', '\\treg         mem_axi_wready = 0;\\n', '\\twire [31:0] mem_axi_wdata;\\n', '\\twire [ 3:0] mem_axi_wstrb;\\n', '\\n', '\\treg  mem_axi_bvalid = 0;\\n', '\\twire mem_axi_bready;\\n', '\\n', '\\twire        mem_axi_arvalid;\\n', '\\treg         mem_axi_arready = 0;\\n', '\\twire [31:0] mem_axi_araddr;\\n', '\\twire [ 2:0] mem_axi_arprot;\\n', '\\n', '\\treg         mem_axi_rvalid = 0;\\n', '\\twire        mem_axi_rready;\\n', \"\\treg  [31:0] mem_axi_rdata = {32{1'b0}};\\n\", '\\treg is_o = 0;\\n', '\\treg is_ok = 0;\\n', '\\n', '\\tmriscvcore mriscvcore_inst (\\n', '\\t\\t.clk    (clk            ),\\n', '\\t\\t.rstn   (resetn         ),\\n', '\\t\\t.trap   (trap           ),\\n', '\\t\\t.AWvalid(mem_axi_awvalid),\\n', '\\t\\t.AWready(mem_axi_awready),\\n', '\\t\\t.AWdata (mem_axi_awaddr ),\\n', '\\t\\t.AWprot (mem_axi_awprot ),\\n', '\\t\\t.Wvalid (mem_axi_wvalid ),\\n', '\\t\\t.Wready (mem_axi_wready ),\\n', '\\t\\t.Wdata  (mem_axi_wdata  ),\\n', '\\t\\t.Wstrb  (mem_axi_wstrb  ),\\n', '\\t\\t.Bvalid (mem_axi_bvalid ),\\n', '\\t\\t.Bready (mem_axi_bready ),\\n', '\\t\\t.ARvalid(mem_axi_arvalid),\\n', '\\t\\t.ARready(mem_axi_arready),\\n', '\\t\\t.ARdata (mem_axi_araddr ),\\n', '\\t\\t.ARprot (mem_axi_arprot ),\\n', '\\t\\t.Rvalid (mem_axi_rvalid ),\\n', '\\t\\t.RReady (mem_axi_rready ),\\n', '\\t\\t.Rdata  (mem_axi_rdata  ),\\n', '\\t\\t//.outirr (irq            ),\\n', '\\t\\t.inirr  (irq            )\\n', '\\t);\\n', '\\n', '\\treg [31:0] memory [0:64*1024/4-1];\\n', '\\tinitial $readmemh(\"firmware.hex\", memory);\\n', '\\n', \"\\treg [63:0] xorshift64_state = 64'd88172645463325252;\\n\", '\\n', '\\ttask xorshift64_next;\\n', '\\t\\tbegin\\n', '\\t\\t\\t// see page 4 of Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software 8 (14).\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state << 13);\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state >>  7);\\n', '\\t\\t\\txorshift64_state = xorshift64_state ^ (xorshift64_state << 17);\\n', '\\t\\tend\\n', '\\tendtask\\n', '\\n', '\\treg [2:0] fast_axi_transaction = ~0;\\n', '\\treg [4:0] async_axi_transaction = ~0;\\n', '\\treg [4:0] delay_axi_transaction = 0;\\n', '\\n', '`ifdef AXI_TEST\\n', '\\talways @(posedge clk) begin\\n', '\\t\\txorshift64_next;\\n', '\\t\\t{fast_axi_transaction, async_axi_transaction, delay_axi_transaction} <= xorshift64_state;\\n', '\\tend\\n', '`endif\\n', '\\n', '\\treg latched_raddr_en = 0;\\n', '\\treg latched_waddr_en = 0;\\n', '\\treg latched_wdata_en = 0;\\n', '\\n', '\\treg fast_raddr = 0;\\n', '\\treg fast_waddr = 0;\\n', '\\treg fast_wdata = 0;\\n', '\\n', '\\treg [31:0] latched_raddr;\\n', '\\treg [31:0] latched_waddr;\\n', '\\treg [31:0] latched_wdata;\\n', '\\treg [ 3:0] latched_wstrb;\\n', '\\treg        latched_rinsn;\\n', '\\n', '\\ttask handle_axi_arvalid; begin\\n', '\\t\\tmem_axi_arready <= 1;\\n', '\\t\\tlatched_raddr = mem_axi_araddr;\\n', '\\t\\tlatched_rinsn = mem_axi_arprot[2];\\n', '\\t\\tlatched_raddr_en = 1;\\n', '\\t\\tfast_raddr <= 1;\\n', '\\tend endtask\\n', '\\n', '\\ttask handle_axi_awvalid; begin\\n', '\\t\\tmem_axi_awready <= 1;\\n', '\\t\\tlatched_waddr = mem_axi_awaddr;\\n', '\\t\\tlatched_waddr_en = 1;\\n', '\\t\\tfast_waddr <= 1;\\n', '\\tend endtask\\n', '\\n', '\\ttask handle_axi_wvalid; begin\\n', '\\t\\tmem_axi_wready <= 1;\\n', '\\t\\tlatched_wdata = mem_axi_wdata;\\n', '\\t\\tlatched_wstrb = mem_axi_wstrb;\\n', '\\t\\tlatched_wdata_en = 1;\\n', '\\t\\tfast_wdata <= 1;\\n', '\\tend endtask\\n', '\\n', '\\ttask handle_axi_rvalid; begin\\n', '`ifdef VERBOSE\\n', '\\t\\t$display(\"RD: ADDR=%08x DATA=%08x%s\", latched_raddr, memory[latched_raddr >> 2], latched_rinsn ? \" INSN\" : \"\");\\n', '`endif\\n', '\\t\\tif (latched_raddr < 64*1024) begin\\n', '\\t\\t\\tmem_axi_rdata <= memory[latched_raddr >> 2];\\n', '\\t\\t\\tmem_axi_rvalid <= 1;\\n', '\\t\\t\\tlatched_raddr_en = 0;\\n', '\\t\\tend else begin\\n', '\\t\\t\\t$display(\"OUT-OF-BOUNDS MEMORY READ FROM %08x\", latched_raddr);\\n', '\\t\\t\\t$finish;\\n', '\\t\\tend\\n', '\\tend endtask\\n', '\\n', '\\ttask handle_axi_bvalid; begin\\n', '`ifdef VERBOSE\\n', '\\t\\t$display(\"WR: ADDR=%08x DATA=%08x STRB=%04b\", latched_waddr, latched_wdata, latched_wstrb);\\n', '\\t\\tif (latched_waddr == 0) $finish;\\n', '`endif\\n', '\\t\\tif (latched_waddr < 64*1024) begin\\n', '\\t\\t\\tif (latched_wstrb[0]) memory[latched_waddr >> 2][ 7: 0] <= latched_wdata[ 7: 0];\\n', '\\t\\t\\tif (latched_wstrb[1]) memory[latched_waddr >> 2][15: 8] <= latched_wdata[15: 8];\\n', '\\t\\t\\tif (latched_wstrb[2]) memory[latched_waddr >> 2][23:16] <= latched_wdata[23:16];\\n', '\\t\\t\\tif (latched_wstrb[3]) memory[latched_waddr >> 2][31:24] <= latched_wdata[31:24];\\n', '\\t\\tend else\\n', \"\\t\\tif (latched_waddr == 32'h1000_0000) begin\\n\", \"\\t\\t\\tif(latched_wdata == 79 || (latched_wdata == 75 && latched_wdata == 1'b1))\\n\", \"\\t\\t\\t\\tis_o <= 1'b1;\\n\", '\\t\\t\\telse\\n', \"\\t\\t\\t\\tis_o <= 1'b0;\\n\", \"\\t\\t\\tif(latched_wdata == 75 && is_o == 1'b1)\\n\", \"\\t\\t\\t\\tis_ok <= 1'b1;\\n\", '`ifdef VERBOSE\\n', '\\t\\t\\tif (32 <= latched_wdata && latched_wdata < 128)\\n', '\\t\\t\\t\\t$display(\"OUT: \\'%c\\'\", latched_wdata);\\n', '\\t\\t\\telse\\n', '\\t\\t\\t\\t$display(\"OUT: %3d\", latched_wdata);\\n', '`else\\n', '\\t\\t\\t$write(\"%c\", latched_wdata);\\n', '\\t\\t\\t$fflush();\\n', '`endif\\n', '\\t\\tend else begin\\n', '\\t\\t\\t$display(\"OUT-OF-BOUNDS MEMORY WRITE TO %08x\", latched_waddr);\\n', '\\t\\t\\t$finish;\\n', '\\t\\tend\\n', '\\t\\tmem_axi_bvalid <= 1;\\n', '\\t\\tlatched_waddr_en = 0;\\n', '\\t\\tlatched_wdata_en = 0;\\n', '\\tend endtask\\n', '\\n', '\\talways @(posedge clk) begin\\n', '\\t\\tif (mem_axi_arvalid && !(latched_raddr_en || fast_raddr) && async_axi_transaction[0]) handle_axi_arvalid;\\n', '\\t\\tif (mem_axi_awvalid && !(latched_waddr_en || fast_waddr) && async_axi_transaction[1]) handle_axi_awvalid;\\n', '\\t\\tif (mem_axi_wvalid  && !(latched_wdata_en || fast_wdata) && async_axi_transaction[2]) handle_axi_wvalid;\\n', '\\t\\tif (!mem_axi_rvalid && latched_raddr_en && async_axi_transaction[3]) handle_axi_rvalid;\\n', '\\t\\tif (!mem_axi_bvalid && latched_waddr_en && latched_wdata_en && async_axi_transaction[4]) handle_axi_bvalid;\\n', '\\tend\\n', '\\n', '\\talways @(posedge clk) begin\\n', '\\t\\tmem_axi_arready <= 0;\\n', '\\t\\tmem_axi_awready <= 0;\\n', '\\t\\tmem_axi_wready <= 0;\\n', '\\n', '\\t\\tfast_raddr <= 0;\\n', '\\t\\tfast_waddr <= 0;\\n', '\\t\\tfast_wdata <= 0;\\n', '\\n', '\\t\\tif (mem_axi_rvalid && mem_axi_rready) begin\\n', '\\t\\t\\tmem_axi_rvalid <= 0;\\n', '\\t\\tend\\n', '\\n', '\\t\\tif (mem_axi_bvalid && mem_axi_bready) begin\\n', '\\t\\t\\tmem_axi_bvalid <= 0;\\n', '\\t\\tend\\n', '\\n', '\\t\\tif (mem_axi_arvalid && mem_axi_arready && !fast_raddr) begin\\n', '\\t\\t\\tlatched_raddr = mem_axi_araddr;\\n', '\\t\\t\\tlatched_rinsn = mem_axi_arprot[2];\\n', '\\t\\t\\tlatched_raddr_en = 1;\\n', '\\t\\tend\\n', '\\n', '\\t\\tif (mem_axi_awvalid && mem_axi_awready && !fast_waddr) begin\\n', '\\t\\t\\tlatched_waddr = mem_axi_awaddr;\\n', '\\t\\t\\tlatched_waddr_en = 1;\\n', '\\t\\tend\\n', '\\n', '\\t\\tif (mem_axi_wvalid && mem_axi_wready && !fast_wdata) begin\\n', '\\t\\t\\tlatched_wdata = mem_axi_wdata;\\n', '\\t\\t\\tlatched_wstrb = mem_axi_wstrb;\\n', '\\t\\t\\tlatched_wdata_en = 1;\\n', '\\t\\tend\\n', '\\n', '\\t\\tif (mem_axi_arvalid && !(latched_raddr_en || fast_raddr) && !delay_axi_transaction[0]) handle_axi_arvalid;\\n', '\\t\\tif (mem_axi_awvalid && !(latched_waddr_en || fast_waddr) && !delay_axi_transaction[1]) handle_axi_awvalid;\\n', '\\t\\tif (mem_axi_wvalid  && !(latched_wdata_en || fast_wdata) && !delay_axi_transaction[2]) handle_axi_wvalid;\\n', '\\n', '\\t\\tif (!mem_axi_rvalid && latched_raddr_en && !delay_axi_transaction[3]) handle_axi_rvalid;\\n', '\\t\\tif (!mem_axi_bvalid && latched_waddr_en && latched_wdata_en && !delay_axi_transaction[4]) handle_axi_bvalid;\\n', '\\tend\\n', '\\n', '\\tinitial begin\\n', '\\t\\tif ($test$plusargs(\"vcd\")) begin\\n', '\\t\\t\\t$dumpfile(\"mriscvcore_tb.vcd\");\\n', '\\t\\t\\t$dumpvars(0, mriscvcore_tb);\\n', '\\t\\tend\\n', '\\t\\trepeat (10000000) begin\\n', '\\t\\t  @(posedge clk);\\n', '\\t\\t  /*if(is_ok) begin\\n', '\\t\\t    $display(\"Program terminated sucesfully\");\\n', '\\t\\t    $finish;\\n', '\\t\\t  end*/\\n', '\\t\\tend\\n', '\\t\\t$display(\"TIMEOUT\");\\n', '\\t\\t$finish;\\n', '\\tend\\n', '\\n', '\\tinteger cycle_counter;\\n', '\\talways @(posedge clk) begin\\n', '\\t\\tcycle_counter <= resetn ? cycle_counter + 1 : 0;\\n', '\\t\\tif (resetn && trap) begin\\n', '\\t\\t\\trepeat (10) @(posedge clk);\\n', '\\t\\t\\t$display(\"TRAP after %1d clock cycles\", cycle_counter);\\n', '\\t\\t\\t$finish;\\n', '\\t\\tend\\n', '\\tend\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module FSM_Booth\\n', '\\t#(\\n', '\\tparameter  COUNT_BIT = 5,\\n', '\\tparameter  BITS_BOOTH = 16\\n', '\\t)\\n', '\\t(input clk,reset,Enable,\\n', '\\tinput[COUNT_BIT-1:0] cont,\\n', '\\toutput reg [2:0] OutFSM);\\n', '\\t\\n', '\\n', '\\treg [1:0]state,nextState;\\n', '\\n', '\\n', '\\t//Asignacion asincrona de estados\\n', '\\talways@(state,cont,Enable)\\n', '\\tcase(state)\\n', \"\\t2'b00:\\n\", \"\\t\\tif(Enable==1) nextState = 2'b01;\\n\", \"\\t\\telse nextState = 2'b00;\\n\", \"\\t2'b01:\\n\", \"\\t\\tnextState = 2'b10;\\n\", \"\\t2'b10:\\n\", \"\\t\\tif(cont==BITS_BOOTH) nextState = 2'b11;\\n\", \"\\t\\telse nextState = 2'b10;\\n\", \"\\t2'b11:\\n\", \"\\t\\tif(Enable==0) nextState = 2'b00;\\n\", \"\\t\\telse nextState = 2'b11;\\n\", \"\\t//default: nextState = 2'b00;\\n\", '\\tendcase\\n', '\\t//Asignacion sincrona: Actualizacion del estado\\n', '\\talways@(posedge clk)\\n', '\\tbegin\\n', \"\\t\\tif(reset==0) state = 2'b0;\\n\", '\\t\\telse state = nextState;\\n', '\\tend\\n', '\\t//Asignacion de las salidas\\n', '\\talways@(state)\\n', \"\\t\\tif(state==2'b00) OutFSM = 3'b100;\\n\", \"\\t\\telse if (state==2'b01) OutFSM = 3'b110;\\n\", \"\\t\\telse if (state==2'b10) OutFSM = 3'b101;\\n\", \"\\t\\telse OutFSM = 3'b000;\\n\", '\\t\\n', 'endmodule \\n', '\\n', 'module Alg_Booth\\n', '\\t#(\\n', '\\tparameter  SWORD = 17\\n', '\\t)\\n', '\\t(input clk,reset,Busy,Em,Er,\\n', '\\tinput [SWORD-1:0] R2,R1,\\n', '\\toutput[SWORD*2-1:0] Z);\\n', '\\t\\n', '\\n', '\\n', '\\t//reg[16:0] Q2;\\n', '\\treg[SWORD-1:0] Q1,aux;\\n', '\\treg[SWORD*2:0] S,address2,subres2;\\n', '\\twire[SWORD-1:0] NQ1;\\n', '\\n', '\\tassign NQ1 = ~Q1+1;\\n', '\\t//FF-D de R1 y R2\\n', '\\talways@ (posedge clk)\\n', '\\tbegin\\n', '\\t\\tif(!reset) begin\\n', '\\t\\t\\tQ1 = 0;\\n', '\\t\\t\\tS = 0;\\n', '\\t\\tend else if(Er)\\tbegin\\n', '\\t\\t\\tQ1 =R1;\\n', \"\\t\\t\\tS = {{SWORD{1'b0}}, R2, 1'b0};\\n\", '\\t\\tend else if(Em) begin\\n', '\\t\\t\\tcase(S[1:0])\\n', \"\\t\\t\\t\\t2'b00:begin \\n\", '\\t\\t\\t\\t\\tS = {S[SWORD*2],S[SWORD*2:1]};\\n', \"\\t\\t\\t\\t\\t//S = {1'b0,S[SWORD*2:1]};\\n\", '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\t2'b01:begin\\n\", '\\t\\t\\t\\t\\taux = S[SWORD*2:SWORD+1]+Q1;\\n', '\\t\\t\\t\\t\\tS = {aux[SWORD-1],aux,S[SWORD:1]};\\n', \"\\t\\t\\t\\t\\t//S = {1'b0,aux,S[SWORD:1]};\\n\", '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\t2'b10:begin\\n\", '\\t\\t\\t\\t\\taux = S[SWORD*2:SWORD+1]+NQ1;\\n', '\\t\\t\\t\\t\\tS = {aux[SWORD-1],aux,S[SWORD:1]};\\n', \"\\t\\t\\t\\t\\t//S = {1'b0,aux,S[SWORD:1]};\\n\", '\\t\\t\\t\\tend\\n', \"\\t\\t\\t\\t2'b11:begin \\n\", '\\t\\t\\t\\t\\tS = {S[SWORD*2],S[SWORD*2:1]};\\n', \"\\t\\t\\t\\t\\t//S = {1'b0,S[SWORD*2:1]};\\n\", '\\t\\t\\t\\tend\\n', '\\t\\t\\tendcase\\n', '\\t\\tend\\telse begin\\n', '\\t\\t\\tQ1 = Q1;\\n', '\\t\\t\\tS = S;\\n', '\\t\\tend\\n', '\\tend\\n', '\\n', '\\n', '\\tassign Z = Busy ? 0 : S[SWORD*2:1];\\n', '\\n', '\\n', 'endmodule\\n', '\\n', 'module MULT(input clk,reset,Enable,\\n', '\\tinput [31:0] rs1,rs2,\\n', '\\tinput [11:0] codif,\\n', '\\toutput [31:0] rd,\\n', '\\toutput reg is_oper,\\n', '\\toutput reg Done);\\n', '\\n', '\\tlocalparam COUNT_BIT = 5;\\n', '\\tlocalparam BITS_BOOTH = 16;\\n', '\\t\\n', '\\n', '\\treg[COUNT_BIT-1:0] cont1,cont2,cont3;\\n', '\\twire[63:0] Out1,Out0,Out2,Out;\\n', '\\twire [2:0] OutFSM1,OutFSM2,OutFSM3;\\n', '\\treg[16:0] X1,X0,Y1,Y0;\\n', '\\treg[17:0] M1,M2;\\n', '\\twire [33:0] Z0,Z2;\\n', '\\twire [35:0] Z1,Z1_Z2_Z0,NZ2,NZ0;\\n', '\\treg [31:0] ss1,ss2,srd;\\n', '\\treg [16:0] ss1_ss1;\\n', '\\treg [16:0] ss2_ss2;\\n', '\\treg [63:0] rdu;\\n', '\\treg sig,signo;\\n', '\\treg [11:0] Op;\\n', '\\twire EnableMul;\\n', '\\twire Ready;\\n', '\\t//reg is_oper;\\n', '\\n', '\\n', '\\tFSM_Booth u1 (.clk(clk),.reset(reset),.OutFSM(OutFSM1),.cont(cont1),.Enable(EnableMul)); //FSM1 (X1Y1)\\n', '\\tAlg_Booth u2 (.clk(clk),.reset(reset),.R2(Y1),.R1(X1),.Z(Z2),.Busy(OutFSM1[2]),.Em(OutFSM1[0]),.Er(OutFSM1[1])); //Mul 1 (X1Y1)\\n', '\\tFSM_Booth #(.BITS_BOOTH(17)) u3 (.clk(clk),.reset(reset),.OutFSM(OutFSM2),.cont(cont2),.Enable(EnableMul)); //FSM2 (M1M2)\\n', '\\tAlg_Booth #(.SWORD(18)) u4 (.clk(clk),.reset(reset),.R2(M2),.R1(M1),.Z(Z1),.Busy(OutFSM2[2]),.Em(OutFSM2[0]),.Er(OutFSM2[1])); //Mul 2 (M1M2)\\n', '\\tFSM_Booth u5 (.clk(clk),.reset(reset),.OutFSM(OutFSM3),.cont(cont3),.Enable(EnableMul)); //FSM3 (X0Y0)\\n', '\\tAlg_Booth u6 (.clk(clk),.reset(reset),.R2(Y0),.R1(X0),.Z(Z0),.Busy(OutFSM3[2]),.Em(OutFSM3[0]),.Er(OutFSM3[1])); //Mul 3 (X0Y0)\\n', '\\n', '\\n', '\\n', '\\talways@* begin\\n', '\\t\\tcase(codif)\\n', \"\\t\\t\\t12'b010010110011: begin\\n\", '\\t\\t\\t\\t// Algoritmo KARATSUBA MULH (SxS)\\n', '\\t\\t\\t\\tif (rs1[31]) ss1 = ~rs1+1;\\n', '\\t\\t\\t\\telse ss1 = rs1;\\n', '\\t\\t\\t\\tif (rs2[31]) ss2 = ~rs2+1;\\n', '\\t\\t\\t\\telse ss2 = rs2;\\n', '\\t\\t\\t\\tsig = rs1[31] ^ rs2[31];\\n', '\\t\\t\\t\\tis_oper = 1;\\n', '\\t\\t\\t\\tsrd = rdu[63:32];\\n', '\\t\\t\\tend\\n', \"\\t\\t\\t12'b010100110011: begin\\n\", '\\t\\t\\t\\t// Algoritmo KARATSUBA MULHSU (SxU)\\n', '\\t\\t\\t\\tif (rs1[31]) ss1 = ~rs1+1;\\n', '\\t\\t\\t\\telse ss1 = rs1;\\t\\n', '\\t\\t\\t\\tss2 = rs2;\\n', '\\t\\t\\t\\tsig = rs1[31];\\n', '\\t\\t\\t\\tis_oper = 1;\\n', '\\t\\t\\t\\tsrd = rdu[63:32];\\n', '\\t\\t\\tend\\n', \"\\t\\t\\t12'b010110110011: begin\\n\", '\\t\\t\\t\\t// Algoritmo KARATSUBA MULHU (UxU)\\n', '\\t\\t\\t\\tss1 = rs1;\\n', '\\t\\t\\t\\tss2 = rs2;\\n', '\\t\\t\\t\\tsig = 0;\\n', '\\t\\t\\t\\tis_oper = 1;\\n', '\\t\\t\\t\\tsrd = rdu[63:32];\\n', '\\t\\t\\tend\\n', \"\\t\\t\\t12'b010000110011: begin\\n\", '\\t\\t\\t\\t// Algoritmo KARATSUBA MUL (UxU)\\n', '\\t\\t\\t\\tss1 = rs1;\\n', '\\t\\t\\t\\tss2 = rs2;\\n', '\\t\\t\\t\\tsig = 0;\\n', '\\t\\t\\t\\tis_oper = 1;\\n', '\\t\\t\\t\\tsrd = rdu[31:0];\\n', '\\t\\t\\tend\\n', '\\t\\t\\tdefault: begin\\n', '\\t\\t\\t\\tss1 = rs1;\\n', '\\t\\t\\t\\tss2 = rs2;\\n', '\\t\\t\\t\\tsig = 0;\\n', '\\t\\t\\t\\tis_oper = 0;\\n', \"\\t\\t\\t\\tsrd = 32'hxxxxxxxx;\\n\", '\\t\\t\\tend\\n', '\\t\\tendcase\\n', \"\\t\\tX1 = {1'b0, ss1[31:16]}; // First 16 Bits of R1\\n\", \"\\t\\tX0 = {1'b0, ss1[15:0]};\\n\", \"\\t\\tY1 = {1'b0, ss2[31:16]}; // First 16 Bits of R2\\n\", \"\\t\\tY0 = {1'b0, ss2[15:0]};\\n\", '\\t\\tss1_ss1 = ss1[31:16] + ss1[15:0];\\n', \"\\t\\tM1 = {1'b0, ss1_ss1}; // (X1+X0)\\n\", '\\t\\tss2_ss2 = ss2[31:16] + ss2[15:0];\\n', \"\\t\\tM2 = {1'b0, ss2_ss2}; // (Y1+Y0)\\t\\n\", '\\tend\\n', \"\\tassign rd = is_oper?srd:32'hzzzzzzzz;\\n\", '\\t\\n', \"\\tassign EnableMul = /*X1==0&&X0==0&&Y1==0&&Y0==0 ? 1'b0 :*/ (Enable & is_oper);\\n\", '\\t//Salida Algoritmo KARATSUBA \\n', '\\tassign Ready = OutFSM1[2]==0&&OutFSM2[2]==0&&OutFSM3[2]==0;\\n', '\\tassign NZ2 = -$signed(Z2);\\n', '\\tassign NZ0 = -$signed(Z0);\\n', '\\tassign Z1_Z2_Z0 = (Z1+NZ2+NZ0);\\n', '\\tassign Out2 = Z2<<32;\\n', '\\tassign Out1 = {{14{Z1_Z2_Z0[33]}}, Z1_Z2_Z0}<<16;\\n', '\\tassign Out0 = {{30{Z0[33]}}, Z0};\\n', '\\tassign Out = Out2+Out1+Out0;\\n', '\\t\\n', '\\n', '\\talways@ (posedge clk) begin\\n', '\\t\\tif(Ready) begin\\n', '\\t\\t\\tif(sig) rdu = ~Out+1;\\n', '\\t\\t\\telse rdu = Out;\\n', '\\t\\t\\tDone = 1;\\n', '\\t\\tend else if(is_oper) begin\\n', '\\t\\t\\tDone = 0;\\n', \"\\t\\t\\trdu = 64'b0;\\n\", '\\t\\tend\\telse begin\\n', \"\\t\\t\\trdu = 64'b0;\\n\", '\\t\\t\\tDone = 0;\\n', '\\t\\tend\\n', '\\tend\\n', '\\n', '\\t//// Contador 1\\n', '\\talways@(posedge clk )\\n', '\\t\\tif (reset==0||cont1==BITS_BOOTH) cont1 = 0;\\n', '\\t\\telse if (OutFSM1[0]==1) cont1 = cont1 + 1;\\n', '\\t//// Contador 2\\n', '\\talways@(posedge clk )\\n', '\\t\\tif (reset==0||cont2==17) cont2 = 0;\\n', '\\t\\telse if (OutFSM2[0]==1) cont2 = cont2 + 1;\\n', '\\t//// Contador 3\\n', '\\talways@(posedge clk )\\n', '\\t\\tif (reset==0||cont3==BITS_BOOTH) cont3 = 0;\\n', '\\t\\telse if (OutFSM3[0]==1) cont3 = cont3 + 1;\\t\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module MULT_tb;\\n', 'parameter clkperiodo=2;\\n', 'parameter sword = 32;\\n', '\\n', '\\t// Inputs\\n', '\\treg clk;\\n', '\\treg reset;\\n', '\\treg Enable;\\n', '\\treg [11:0]funct3;\\n', '\\treg [31:0] rs1;\\n', '\\treg [31:0] rs2;\\n', '\\treg [32:0] rs1e;\\n', '\\treg [32:0] rs2e;\\n', '\\n', '\\t// Outputs\\n', '\\twire [31:0] rd;\\n', '\\treg [63:0] vmult;\\n', '\\treg [31:0] rde;\\n', '\\twire Done;\\n', '\\t\\n', '\\tlocalparam tries = 30;\\n', '\\tinteger i, j, error, l;\\n', '\\t\\n', '\\t// Instantiate the Unit Under Test (UUT)\\n', '\\tMULT uut (\\n', '\\t\\t.clk(clk), \\n', '\\t\\t.reset(reset), \\n', '\\t    .Enable(Enable),\\n', '\\t\\t.rs1(rs1), \\n', '\\t\\t.rs2(rs2), \\n', '\\t\\t.rd(rd),\\n', '\\t\\t.Done(Done),\\n', '\\t\\t.funct3(funct3)\\n', '\\t);\\n', '\\talways #(clkperiodo/2) clk =!clk;\\n', '\\t\\n', '\\t// Task for expect something (helper)\\n', '\\ttask aexpect;\\n', '\\t\\tinput [sword-1:0] av, e;\\n', '\\t\\tbegin\\n', '\\t\\t if (av == e)\\n', '\\t\\t\\t$display (\"TIME=%t.\" , $time, \" Actual value of mult=%b, expected is %b. MATCH!\", av, e);\\n', '\\t\\t else\\n', '\\t\\t  begin\\n', '\\t\\t\\t$display (\"TIME=%t.\" , $time, \" Actual value of mult=%b, expected is %b. ERROR!\", av, e);\\n', '\\t\\t\\terror = error + 1;\\n', '\\t\\t  end\\n', '\\t\\tend\\n', '\\tendtask\\n', '\\t\\n', '\\t\\n', '\\tinitial begin\\n', '\\t\\t// Initialize Inputs\\n', \"\\t\\tclk = 1'b0;\\n\", \"\\t\\treset = 1'b0;\\n\", \"\\t\\tEnable = 1'b0;\\n\", \"\\t\\tfunct3 = 12'b0;\\n\", \"\\t\\trs1 = 32'b0;\\n\", \"\\t\\trs2 = 32'b0;\\n\", '\\t\\tvmult = 0;\\n', '\\t\\ti = 0; error = 0;\\n', '\\t\\t// Wait 100 ns for global reset to finish\\n', '\\t  #(clkperiodo*5);\\n', \"\\t\\treset = 1'b1;\\n\", '\\t\\t#(clkperiodo*5);\\n', '\\t\\t// Begin testing:\\n', \"\\t\\tfunct3 = 12'b010000110011; // MUL (UxU)\\n\", '\\t\\tfor(i = 0; i < tries; i=i+1) begin\\n', '\\t\\t\\trs1e = $unsigned($random()); rs1 = rs1e[31:0];\\n', '\\t\\t\\trs2e = $unsigned($random()); rs2 = rs2e[31:0];\\n', '\\t\\t\\tvmult = $signed(rs1e)*$signed(rs2e);\\n', '\\t\\t\\trde = vmult[31:0];\\n', \"\\t\\t\\tEnable = 1'b0;\\n\", '\\t\\t\\t#(clkperiodo*5);\\n', \"\\t\\t\\tEnable = 1'b1;\\n\", '\\t\\t\\t#(clkperiodo*5);\\n', '\\t\\t\\twhile(!Done) #(clkperiodo);\\n', \"\\t\\t\\tEnable = 1'b0;\\n\", '\\t\\t\\taexpect(rd, rde);\\n', '\\t\\tend\\n', \"\\t\\tfunct3 = 12'b010100110011; //MULHSU (SxU)\\n\", '\\t\\tfor(i = 0; i < tries; i=i+1) begin\\n', '\\t\\t\\trs1e = $signed($random()); rs1 = rs1e[31:0];\\n', '\\t\\t\\trs2e = $unsigned($random()); rs2 = rs2e[31:0];\\n', '\\t\\t\\tvmult = $signed(rs1e)*$signed(rs2e);\\n', '\\t\\t\\trde = vmult[63:32];\\n', \"\\t\\t\\tEnable = 1'b0;\\n\", '\\t\\t\\t#(clkperiodo*5);\\n', \"\\t\\t\\tEnable = 1'b1;\\n\", '\\t\\t\\t#(clkperiodo*5);\\n', '\\t\\t\\twhile(!Done) #(clkperiodo);\\n', \"\\t\\t\\tEnable = 1'b0;\\n\", '\\t\\t\\taexpect(rd, rde);\\n', '\\t\\tend\\n', \"\\t\\tfunct3 = 12'b010010110011; //MULH (SxS)\\n\", '\\t\\tfor(i = 0; i < tries; i=i+1) begin\\n', '\\t\\t\\trs1e = $signed($random()); rs1 = rs1e[31:0];\\n', '\\t\\t\\trs2e = $signed($random()); rs2 = rs2e[31:0];\\n', '\\t\\t\\tvmult = $signed(rs1e)*$signed(rs2e);\\n', '\\t\\t\\trde = vmult[63:32];\\n', \"\\t\\t\\tEnable = 1'b0;\\n\", '\\t\\t\\t#(clkperiodo*5);\\n', \"\\t\\t\\tEnable = 1'b1;\\n\", '\\t\\t\\t#(clkperiodo*5);\\n', '\\t\\t\\twhile(!Done) #(clkperiodo);\\n', \"\\t\\t\\tEnable = 1'b0;\\n\", '\\t\\t\\taexpect(rd, rde);\\n', '\\t\\tend\\n', \"\\t\\tfunct3 = 12'b010110110011; // MULHU (UxU)\\n\", '\\t\\tfor(i = 0; i < tries; i=i+1) begin\\n', '\\t\\t\\trs1e = $unsigned($random()); rs1 = rs1e[31:0];\\n', '\\t\\t\\trs2e = $unsigned($random()); rs2 = rs2e[31:0];\\n', '\\t\\t\\tvmult = $signed(rs1e)*$signed(rs2e);\\n', '\\t\\t\\trde = vmult[63:32];\\n', \"\\t\\t\\tEnable = 1'b0;\\n\", '\\t\\t\\t#(clkperiodo*5);\\n', \"\\t\\t\\tEnable = 1'b1;\\n\", '\\t\\t\\t#(clkperiodo*5);\\n', '\\t\\t\\twhile(!Done) #(clkperiodo);\\n', \"\\t\\t\\tEnable = 1'b0;\\n\", '\\t\\t\\taexpect(rd, rde);\\n', '\\t\\tend\\n', '\\n', '\\t\\tif (error == 0)\\n', '\\t\\t\\t$display(\"All match\");\\n', '\\t\\telse\\n', '\\t\\t\\t$display(\"Mismatches = %d\", error);\\n', '\\t\\t$finish;\\n', '\\n', '\\tend\\n', '      \\n', 'endmodule\\n', '\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '/*\\n', 'REG_FILE by CKDUR.\\n', '\\n', 'Instructions: \\n', '1. Instance REG_FILE, not true_dpram_sclk\\n', '2. Connect rd, rs1 and rs2 input/output to their respective buses.\\n', '3. Connect rdi, rs1i, rs2i from DECO_INSTR (These are the indexes)\\n', \"4. If 'rdw_rsrn' is 1 logic, then rd data is written to registers according to rdi\\n\", \"   If 'rdw_rsrn' is 0 logic, then rs1 and rs2 are filled with data from registers according to rs1 and rs2.\\n\", '   Note: ALWAYS is doing this, if you dont want rd write the registers, you MUST put rdw_rsrn to 0 and maintain rs1i and rs2i constant.\\n', '5. Profit!\\n', '\\n', '*/\\n', '\\n', '// Code extracted from: https://www.altera.com/support/support-resources/design-examples/design-software/verilog/ver-true-dual-port-ram-sclk.html\\n', 'module true_dpram_sclk\\n', '(\\n', '\\tinput [31:0] data_a,\\n', '\\tinput [4:0] addr_a, addr_b,\\n', '\\tinput we_a, clk, rst,\\n', '\\toutput reg [31:0] q_a, q_b\\n', ');\\n', '\\t// Declare the RAM variable\\n', '\\treg [31:0] ram[31:0];\\n', '\\t\\n', '\\t// Port A\\n', '\\talways @ (posedge clk)\\n', '\\tbegin\\n', '\\t\\tif (we_a) \\n', '\\t\\tbegin\\n', '\\t\\t\\tram[addr_a] <= data_a;\\n', '\\t\\tend\\n', \"\\t\\tq_a <= addr_a?ram[addr_a]:32'd0;\\t\\t// Assign zero if index is zero because zero register\\n\", \"\\t\\tq_b <= addr_b?ram[addr_b]:32'd0;\\t\\t// Assign zero if index is zero because zero register\\n\", '\\tend\\n', '\\t\\n', 'endmodule\\n', '\\n', 'module REG_FILE(\\n', '    input clk,\\n', '    input rst,\\n', '    \\n', '\\tinput [31:0] rd,\\n', '\\tinput [4:0] rdi,\\n', '\\tinput rdw_rsrn,\\n', '\\toutput [31:0] rs1,\\n', '\\tinput [4:0] rs1i,\\n', '\\toutput [31:0] rs2,\\n', '\\tinput [4:0] rs2i\\n', '\\t);\\n', '\\t\\n', '\\twire [31:0] data_a;\\n', '\\twire [4:0] addr_a, addr_b;\\n', '\\twire we_a;\\n', '\\twire [31:0] q_a, q_b;\\n', '\\t\\n', '\\tassign data_a = rd;\\n', '\\tassign addr_a = rdw_rsrn?rdi:rs1i;\\n', '\\tassign addr_b = rs2i;\\n', '\\tassign we_a = rdw_rsrn;\\n', '\\tassign rs1 = q_a;\\n', '\\tassign rs2 = q_b;\\n', '\\t\\n', '\\ttrue_dpram_sclk MEM_FILE\\n', '(\\n', '\\t.data_a(data_a),\\n', '\\t.addr_a(addr_a), .addr_b(addr_b),\\n', '\\t.we_a(we_a), .clk(clk), .rst(rst),\\n', '\\t.q_a(q_a), .q_b(q_b)\\n', ');\\n', '\\t\\n', 'endmodule\\n']"}
{"text": "['`timescale 1ns / 1ps\\n', '\\n', 'module UTILITY(\\n', '    input           clk,\\n', '    input           rst,\\n', '    input           enable_pc,\\n', '    input [31:0]  imm,\\n', '    input [31:0]  irr_ret,\\n', '    input [31:0]  irr_dest,\\n', '    input           irr,\\n', '    input [11:0]  opcode,\\n', '    input [31:0]  rs1,\\n', '    input           branch, \\n', '    output [31:0] rd,\\n', '    output [31:0] pc,\\n', '    output reg    is_rd,\\n', '    output reg    is_inst);\\n', '\\n', '    reg [63:0] N_CYCLE=0,N_INSTRUC=0,REAL_TIME=0;\\n', '    reg [31:0] TIME=0,rd_n=0,PC_N=0,PC_N2=0,RD_DATA=0;\\n', '    wire [31:0] PC_BRANCH, PC_SALTOS, PC_ORIG;\\n', '\\n', '    // RDCYCLE REGISTER\\n', '    always @(posedge clk )\\n', '        begin\\n', \"            if (rst == 1'b0) N_CYCLE<=0;\\n\", '            else  N_CYCLE <= N_CYCLE + 1;\\n', '        end\\n', '\\n', '    // REAL TIME REGISTER\\n', '    always @(posedge clk )\\n', '        begin\\n', \"            if (rst == 1'b0) begin\\n\", '                TIME<=0;\\n', '                REAL_TIME<=0;\\n', '            end else if(TIME==100) begin\\n', '                TIME<=0;\\n', '                REAL_TIME<=REAL_TIME+1;\\n', '            end else \\n', '                TIME <= TIME + 1;\\n', '        end    \\n', '    \\n', '    // INSTRUCTION NUMBER REGISTER\\n', '    always @(posedge clk )\\n', '        begin\\n', \"            if (rst == 1'b0) N_INSTRUC<=0;\\n\", '            else if (enable_pc)  N_INSTRUC <= N_INSTRUC + 1;    \\n', '        end\\n', '\\n', '\\n', '    // RD assignation phase 1: CSRR* Assigns\\n', '    always @(imm, N_CYCLE, REAL_TIME, N_INSTRUC)\\n', '        case (imm)\\n', \"            32'b00000000000000000000110010000000: RD_DATA = N_CYCLE[63:32];        // RDCYCLEH\\n\", \"            32'b00000000000000000000110000000000: RD_DATA = N_CYCLE[31:0];        // RDCYCLE\\n\", \"            32'b00000000000000000000110010000001: RD_DATA = REAL_TIME[63:32];    // RDTIMEH\\n\", \"            32'b00000000000000000000110000000001: RD_DATA = REAL_TIME[31:0];    // RDTIME\\n\", \"            32'b00000000000000000000110010000010: RD_DATA = N_INSTRUC[63:32];    // RDINSTRETH\\n\", \"            32'b00000000000000000000110000000010: RD_DATA = N_INSTRUC[31:0];    // RDINSTRET\\n\", '            default: RD_DATA = 0;                                                // Other CSRR* (Read zero)\\n', '        endcase\\n', '    \\n', '    // RD assignation phase 2: instruction-specific\\n', '    always @(opcode,RD_DATA,PC_N,imm,PC_ORIG,PC_N2) begin\\n', '        is_rd = 1;\\n', '        is_inst = 1;\\n', '        rd_n = 0; \\n', '        case (opcode)\\n', \"            12'b000001110011 : rd_n = RD_DATA;        // CSRR*\\n\", \"            12'b000001101111 : rd_n = PC_ORIG;        // JAL\\n\", \"            12'b000001100111 : rd_n = PC_ORIG;        // JALR\\n\", \"            12'b000000010111 : rd_n = PC_N2+imm;    // AUIPC\\n\", \"            12'b000000110111 : rd_n = imm;            // LUI\\n\", '            default: begin is_rd = 0; is_inst = 0; end    // ILLEGAL\\n', '        endcase\\n', '    end\\n', '    \\n', \"    assign rd = is_rd?rd_n:32'hzzzzzzzz;\\n\", '\\n', '    // Next PC Determination\\n', '    assign PC_SALTOS = PC_N2 + imm;\\n', '    assign PC_ORIG = PC_N2 + 4;\\n', '    assign PC_BRANCH = branch ? PC_SALTOS : PC_ORIG;\\n', '    always @* begin\\n', '        if(irr) begin\\n', '            PC_N = irr_dest;                                // An interrupt (Who saves the previous PC is IRQ module via irr_ret)\\n', \"        end else if(opcode[6:0] == 7'b1100011) begin\\n\", '            PC_N = PC_BRANCH;                            // BXX \\n', '        end else begin\\n', '            case (opcode)\\n', \"                12'b000001100111: PC_N = rs1+imm;        // JALR\\n\", \"                12'b000001101111: PC_N = PC_SALTOS;        // JAL\\n\", \"                12'b001110011000: PC_N = irr_ret;        // RETIRQ\\n\", '                default:           PC_N = PC_ORIG;        // Advance the program counter\\n', '            endcase\\n', '        end        \\n', '    end\\n', '\\n', '    // PC sync\\n', '    always @(posedge clk)\\n', '        begin    \\n', \"            if (rst == 1'b0) PC_N2<=0;\\n\", '            else if(enable_pc) PC_N2 <= PC_N ;\\n', '        end\\n', '    assign pc = PC_N2;\\n', 'endmodule\\n']"}
