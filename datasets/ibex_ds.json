{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Arithmetic logic unit\n */\nmodule ibex_alu #(\n  parameter ibex_pkg::rv32b_e RV32B = ibex_pkg::RV32BNone\n) (\n  input  ibex_pkg::alu_op_e operator_i,\n  input  logic [31:0]       operand_a_i,\n  input  logic [31:0]       operand_b_i,\n\n  input  logic              instr_first_cycle_i,\n\n  input  logic [32:0]       multdiv_operand_a_i,\n  input  logic [32:0]       multdiv_operand_b_i,\n\n  input  logic              multdiv_sel_i,\n\n  input  logic [31:0]       imd_val_q_i[2],\n  output logic [31:0]       imd_val_d_o[2],\n  output logic [1:0]        imd_val_we_o,\n\n  output logic [31:0]       adder_result_o,\n  output logic [33:0]       adder_result_ext_o,\n\n  output logic [31:0]       result_o,\n  output logic              comparison_result_o,\n  output logic              is_equal_result_o\n);\n  import ibex_pkg::*;\n\n  logic [31:0] operand_a_rev;\n  logic [32:0] operand_b_neg;\n\n  // bit reverse operand_a for left shifts and bit counting\n  for (genvar k = 0; k < 32; k++) begin : gen_rev_operand_a\n    assign operand_a_rev[k] = operand_a_i[31-k];\n  end\n\n  ///////////\n  // Adder //\n  ///////////\n\n  logic        adder_op_a_shift1;\n  logic        adder_op_a_shift2;\n  logic        adder_op_a_shift3;\n  logic        adder_op_b_negate;\n  logic [32:0] adder_in_a, adder_in_b;\n  logic [31:0] adder_result;\n\n  always_comb begin\n    adder_op_a_shift1 = 1'b0;\n    adder_op_a_shift2 = 1'b0;\n    adder_op_a_shift3 = 1'b0;\n    adder_op_b_negate = 1'b0;\n    unique case (operator_i)\n      // Adder OPs\n      ALU_SUB,\n\n      // Comparator OPs\n      ALU_EQ,   ALU_NE,\n      ALU_GE,   ALU_GEU,\n      ALU_LT,   ALU_LTU,\n      ALU_SLT,  ALU_SLTU,\n\n      // MinMax OPs (RV32B Ops)\n      ALU_MIN,  ALU_MINU,\n      ALU_MAX,  ALU_MAXU: adder_op_b_negate = 1'b1;\n\n      // Address Calculation OPs (RV32B Ops)\n      ALU_SH1ADD: if (RV32B != RV32BNone) adder_op_a_shift1 = 1'b1;\n      ALU_SH2ADD: if (RV32B != RV32BNone) adder_op_a_shift2 = 1'b1;\n      ALU_SH3ADD: if (RV32B != RV32BNone) adder_op_a_shift3 = 1'b1;\n\n      default:;\n    endcase\n  end\n\n  // prepare operand a\n  always_comb begin\n    unique case (1'b1)\n      multdiv_sel_i:     adder_in_a = multdiv_operand_a_i;\n      adder_op_a_shift1: adder_in_a = {operand_a_i[30:0],2'b01};\n      adder_op_a_shift2: adder_in_a = {operand_a_i[29:0],3'b001};\n      adder_op_a_shift3: adder_in_a = {operand_a_i[28:0],4'b0001};\n      default:           adder_in_a = {operand_a_i,1'b1};\n    endcase\n  end\n\n  // prepare operand b\n  assign operand_b_neg = {operand_b_i,1'b0} ^ {33{1'b1}};\n  always_comb begin\n    unique case (1'b1)\n      multdiv_sel_i:     adder_in_b = multdiv_operand_b_i;\n      adder_op_b_negate: adder_in_b = operand_b_neg;\n      default:           adder_in_b = {operand_b_i, 1'b0};\n    endcase\n  end\n\n  // actual adder\n  assign adder_result_ext_o = $unsigned(adder_in_a) + $unsigned(adder_in_b);\n\n  assign adder_result       = adder_result_ext_o[32:1];\n\n  assign adder_result_o     = adder_result;\n\n  ////////////////\n  // Comparison //\n  ////////////////\n\n  logic is_equal;\n  logic is_greater_equal;  // handles both signed and unsigned forms\n  logic cmp_signed;\n\n  always_comb begin\n    unique case (operator_i)\n      ALU_GE,\n      ALU_LT,\n      ALU_SLT,\n      // RV32B only\n      ALU_MIN,\n      ALU_MAX: cmp_signed = 1'b1;\n\n      default: cmp_signed = 1'b0;\n    endcase\n  end\n\n  assign is_equal = (adder_result == 32'b0);\n  assign is_equal_result_o = is_equal;\n\n  // Is greater equal\n  always_comb begin\n    if ((operand_a_i[31] ^ operand_b_i[31]) == 1'b0) begin\n      is_greater_equal = (adder_result[31] == 1'b0);\n    end else begin\n      is_greater_equal = operand_a_i[31] ^ (cmp_signed);\n    end\n  end\n\n  // GTE unsigned:\n  // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0\n  // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0\n  // (a[31] == 1 && b[31] == 0) => 1\n  // (a[31] == 0 && b[31] == 1) => 0\n\n  // GTE signed:\n  // (a[31] == 1 && b[31] == 1) => adder_result[31] == 0\n  // (a[31] == 0 && b[31] == 0) => adder_result[31] == 0\n  // (a[31] == 1 && b[31] == 0) => 0\n  // (a[31] == 0 && b[31] == 1) => 1\n\n  // generate comparison result\n  logic cmp_result;\n\n  always_comb begin\n    unique case (operator_i)\n      ALU_EQ:             cmp_result =  is_equal;\n      ALU_NE:             cmp_result = ~is_equal;\n      ALU_GE,   ALU_GEU,\n      ALU_MAX,  ALU_MAXU: cmp_result = is_greater_equal; // RV32B only\n      ALU_LT,   ALU_LTU,\n      ALU_MIN,  ALU_MINU, //RV32B only\n      ALU_SLT,  ALU_SLTU: cmp_result = ~is_greater_equal;\n\n      default: cmp_result = is_equal;\n    endcase\n  end\n\n  assign comparison_result_o = cmp_result;\n\n  ///////////\n  // Shift //\n  ///////////\n\n  // The shifter structure consists of a 33-bit shifter: 32-bit operand + 1 bit extension for\n  // arithmetic shifts and one-shift support.\n  // Rotations and funnel shifts are implemented as multi-cycle instructions.\n  // The shifter is also used for single-bit instructions and bit-field place as detailed below.\n  //\n  // Standard Shifts\n  // ===============\n  // For standard shift instructions, the direction of the shift is to the right by default. For\n  // left shifts, the signal shift_left signal is set. If so, the operand is initially reversed,\n  // shifted to the right by the specified amount and shifted back again. For arithmetic- and\n  // one-shifts the 33rd bit of the shifter operand can is set accordingly.\n  //\n  // Multicycle Shifts\n  // =================\n  //\n  // Rotation\n  // --------\n  // For rotations, the operand signals operand_a_i and operand_b_i are kept constant to rs1 and\n  // rs2 respectively.\n  //\n  // Rotation pseudocode:\n  //   shift_amt = rs2 & 31;\n  //   multicycle_result = (rs1 >> shift_amt) | (rs1 << (32 - shift_amt));\n  //                       ^-- cycle 0 -----^ ^-- cycle 1 --------------^\n  //\n  // Funnel Shifts\n  // -------------\n  // For funnel shifs, operand_a_i is tied to rs1 in the first cycle and rs3 in the\n  // second cycle. operand_b_i is always tied to rs2. The order of applying the shift amount or\n  // its complement is determined by bit [5] of shift_amt.\n  //\n  // Funnel shift Pseudocode: (fsl)\n  //  shift_amt = rs2 & 63;\n  //  shift_amt_compl = 32 - shift_amt[4:0]\n  //  if (shift_amt >=33):\n  //     multicycle_result = (rs1 >> shift_amt_compl[4:0]) | (rs3 << shift_amt[4:0]);\n  //                         ^-- cycle 0 ----------------^ ^-- cycle 1 ------------^\n  //  else if (shift_amt <= 31 && shift_amt > 0):\n  //     multicycle_result = (rs1 << shift_amt[4:0]) | (rs3 >> shift_amt_compl[4:0]);\n  //                         ^-- cycle 0 ----------^ ^-- cycle 1 -------------------^\n  //  For shift_amt == 0, 32, both shift_amt[4:0] and shift_amt_compl[4:0] == '0.\n  //  these cases need to be handled separately outside the shifting structure:\n  //  else if (shift_amt == 32):\n  //     multicycle_result = rs3\n  //  else if (shift_amt == 0):\n  //     multicycle_result = rs1.\n  //\n  // Single-Bit Instructions\n  // =======================\n  // Single bit instructions operate on bit operand_b_i[4:0] of operand_a_i.\n\n  // The operations bset, bclr and binv are implemented by generation of a bit-mask using the\n  // shifter structure. This is done by left-shifting the operand 32'h1 by the required amount.\n  // The signal shift_sbmode multiplexes the shifter input and sets the signal shift_left.\n  // Further processing is taken care of by a separate structure.\n  //\n  // For bext, the bit defined by operand_b_i[4:0] is to be returned. This is done by simply\n  // shifting operand_a_i to the right by the required amount and returning bit [0] of the result.\n  //\n  // Bit-Field Place\n  // ===============\n  // The shifter structure is shared to compute bfp_mask << bfp_off.\n\n  logic       shift_left;\n  logic       shift_ones;\n  logic       shift_arith;\n  logic       shift_funnel;\n  logic       shift_sbmode;\n  logic [5:0] shift_amt;\n  logic [5:0] shift_amt_compl; // complementary shift amount (32 - shift_amt)\n\n  logic        [31:0] shift_operand;\n  logic signed [32:0] shift_result_ext_signed;\n  logic        [32:0] shift_result_ext;\n  logic               unused_shift_result_ext;\n  logic        [31:0] shift_result;\n  logic        [31:0] shift_result_rev;\n\n  // zbf\n  logic bfp_op;\n  logic [4:0]  bfp_len;\n  logic [4:0]  bfp_off;\n  logic [31:0] bfp_mask;\n  logic [31:0] bfp_mask_rev;\n  logic [31:0] bfp_result;\n\n  // bfp: shares the shifter structure to compute bfp_mask << bfp_off\n  assign bfp_op = (RV32B != RV32BNone) ? (operator_i == ALU_BFP) : 1'b0;\n  assign bfp_len = {~(|operand_b_i[27:24]), operand_b_i[27:24]}; // len = 0 encodes for len = 16\n  assign bfp_off = operand_b_i[20:16];\n  assign bfp_mask = (RV32B != RV32BNone) ? ~(32'hffff_ffff << bfp_len) : '0;\n  for (genvar i = 0; i < 32; i++) begin : gen_rev_bfp_mask\n    assign bfp_mask_rev[i] = bfp_mask[31-i];\n  end\n\n  assign bfp_result =(RV32B != RV32BNone) ?\n      (~shift_result & operand_a_i) | ((operand_b_i & bfp_mask) << bfp_off) : '0;\n\n  // bit shift_amt[5]: word swap bit: only considered for FSL/FSR.\n  // if set, reverse operations in first and second cycle.\n  assign shift_amt[5] = operand_b_i[5] & shift_funnel;\n  assign shift_amt_compl = 32 - operand_b_i[4:0];\n\n  always_comb begin\n    if (bfp_op) begin\n      shift_amt[4:0] = bfp_off;  // length field of bfp control word\n    end else begin\n      shift_amt[4:0] = instr_first_cycle_i ?\n          (operand_b_i[5] && shift_funnel ? shift_amt_compl[4:0] : operand_b_i[4:0]) :\n          (operand_b_i[5] && shift_funnel ? operand_b_i[4:0] : shift_amt_compl[4:0]);\n    end\n  end\n\n  // single-bit mode: shift\n  assign shift_sbmode = (RV32B != RV32BNone) ?\n      (operator_i == ALU_BSET) | (operator_i == ALU_BCLR) | (operator_i == ALU_BINV) : 1'b0;\n\n  // left shift if this is:\n  // * a standard left shift (slo, sll)\n  // * a rol in the first cycle\n  // * a ror in the second cycle\n  // * fsl: without word-swap bit: first cycle, else: second cycle\n  // * fsr: without word-swap bit: second cycle, else: first cycle\n  // * a single-bit instruction: bclr, bset, binv (excluding bext)\n  // * bfp: bfp_mask << bfp_off\n  always_comb begin\n    unique case (operator_i)\n      ALU_SLL: shift_left = 1'b1;\n      ALU_SLO: shift_left = (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) ? 1'b1 : 1'b0;\n      ALU_BFP: shift_left = (RV32B != RV32BNone) ? 1'b1 : 1'b0;\n      ALU_ROL: shift_left = (RV32B != RV32BNone) ? instr_first_cycle_i : 0;\n      ALU_ROR: shift_left = (RV32B != RV32BNone) ? ~instr_first_cycle_i : 0;\n      ALU_FSL: shift_left = (RV32B != RV32BNone) ?\n        (shift_amt[5] ? ~instr_first_cycle_i : instr_first_cycle_i) : 1'b0;\n      ALU_FSR: shift_left = (RV32B != RV32BNone) ?\n          (shift_amt[5] ? instr_first_cycle_i : ~instr_first_cycle_i) : 1'b0;\n      default: shift_left = 1'b0;\n    endcase\n    if (shift_sbmode) begin\n      shift_left = 1'b1;\n    end\n  end\n\n  assign shift_arith  = (operator_i == ALU_SRA);\n  assign shift_ones   = (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) ?\n      (operator_i == ALU_SLO) | (operator_i == ALU_SRO) : 1'b0;\n  assign shift_funnel = (RV32B != RV32BNone) ?\n      (operator_i == ALU_FSL) | (operator_i == ALU_FSR) : 1'b0;\n\n  // shifter structure.\n  always_comb begin\n    // select shifter input\n    // for bfp, sbmode and shift_left the corresponding bit-reversed input is chosen.\n    if (RV32B == RV32BNone) begin\n      shift_operand = shift_left ? operand_a_rev : operand_a_i;\n    end else begin\n      unique case (1'b1)\n        bfp_op:       shift_operand = bfp_mask_rev;\n        shift_sbmode: shift_operand = 32'h8000_0000;\n        default:      shift_operand = shift_left ? operand_a_rev : operand_a_i;\n      endcase\n    end\n\n    shift_result_ext_signed =\n        $signed({shift_ones | (shift_arith & shift_operand[31]), shift_operand}) >>> shift_amt[4:0];\n    shift_result_ext = $unsigned(shift_result_ext_signed);\n\n    shift_result            = shift_result_ext[31:0];\n    unused_shift_result_ext = shift_result_ext[32];\n\n    for (int unsigned i = 0; i < 32; i++) begin\n      shift_result_rev[i] = shift_result[31-i];\n    end\n\n    shift_result = shift_left ? shift_result_rev : shift_result;\n\n  end\n\n  ///////////////////\n  // Bitwise Logic //\n  ///////////////////\n\n  logic bwlogic_or;\n  logic bwlogic_and;\n  logic [31:0] bwlogic_operand_b;\n  logic [31:0] bwlogic_or_result;\n  logic [31:0] bwlogic_and_result;\n  logic [31:0] bwlogic_xor_result;\n  logic [31:0] bwlogic_result;\n\n  logic bwlogic_op_b_negate;\n\n  always_comb begin\n    unique case (operator_i)\n      // Logic-with-negate OPs (RV32B Ops)\n      ALU_XNOR,\n      ALU_ORN,\n      ALU_ANDN: bwlogic_op_b_negate = (RV32B != RV32BNone) ? 1'b1 : 1'b0;\n      ALU_CMIX: bwlogic_op_b_negate = (RV32B != RV32BNone) ? ~instr_first_cycle_i : 1'b0;\n      default:  bwlogic_op_b_negate = 1'b0;\n    endcase\n  end\n\n  assign bwlogic_operand_b = bwlogic_op_b_negate ? operand_b_neg[32:1] : operand_b_i;\n\n  assign bwlogic_or_result  = operand_a_i | bwlogic_operand_b;\n  assign bwlogic_and_result = operand_a_i & bwlogic_operand_b;\n  assign bwlogic_xor_result = operand_a_i ^ bwlogic_operand_b;\n\n  assign bwlogic_or  = (operator_i == ALU_OR)  | (operator_i == ALU_ORN);\n  assign bwlogic_and = (operator_i == ALU_AND) | (operator_i == ALU_ANDN);\n\n  always_comb begin\n    unique case (1'b1)\n      bwlogic_or:  bwlogic_result = bwlogic_or_result;\n      bwlogic_and: bwlogic_result = bwlogic_and_result;\n      default:     bwlogic_result = bwlogic_xor_result;\n    endcase\n  end\n\n  logic [5:0]  bitcnt_result;\n  logic [31:0] minmax_result;\n  logic [31:0] pack_result;\n  logic [31:0] sext_result;\n  logic [31:0] singlebit_result;\n  logic [31:0] rev_result;\n  logic [31:0] shuffle_result;\n  logic [31:0] xperm_result;\n  logic [31:0] butterfly_result;\n  logic [31:0] invbutterfly_result;\n  logic [31:0] clmul_result;\n  logic [31:0] multicycle_result;\n\n  if (RV32B != RV32BNone) begin : g_alu_rvb\n\n    /////////////////\n    // Bitcounting //\n    /////////////////\n\n    // The bit-counter structure computes the number of set bits in its operand. Partial results\n    // (from left to right) are needed to compute the control masks for computation of\n    // bcompress/bdecompress by the butterfly network, if implemented.\n    // For cpop, clz and ctz, only the end result is used.\n\n    logic        zbe_op;\n    logic        bitcnt_ctz;\n    logic        bitcnt_clz;\n    logic        bitcnt_cz;\n    logic [31:0] bitcnt_bits;\n    logic [31:0] bitcnt_mask_op;\n    logic [31:0] bitcnt_bit_mask;\n    logic [ 5:0] bitcnt_partial [32];\n    logic [31:0] bitcnt_partial_lsb_d;\n    logic [31:0] bitcnt_partial_msb_d;\n\n\n    assign bitcnt_ctz    = operator_i == ALU_CTZ;\n    assign bitcnt_clz    = operator_i == ALU_CLZ;\n    assign bitcnt_cz     = bitcnt_ctz | bitcnt_clz;\n    assign bitcnt_result = bitcnt_partial[31];\n\n    // Bit-mask generation for clz and ctz:\n    // The bit mask is generated by spreading the lowest-order set bit in the operand to all\n    // higher order bits. The resulting mask is inverted to cover the lowest order zeros. In order\n    // to create the bit mask for leading zeros, the input operand needs to be reversed.\n    assign bitcnt_mask_op = bitcnt_clz ? operand_a_rev : operand_a_i;\n\n    always_comb begin\n      bitcnt_bit_mask = bitcnt_mask_op;\n      bitcnt_bit_mask |= bitcnt_bit_mask << 1;\n      bitcnt_bit_mask |= bitcnt_bit_mask << 2;\n      bitcnt_bit_mask |= bitcnt_bit_mask << 4;\n      bitcnt_bit_mask |= bitcnt_bit_mask << 8;\n      bitcnt_bit_mask |= bitcnt_bit_mask << 16;\n      bitcnt_bit_mask = ~bitcnt_bit_mask;\n    end\n\n    assign zbe_op = (operator_i == ALU_BCOMPRESS) | (operator_i == ALU_BDECOMPRESS);\n\n    always_comb begin\n      unique case (1'b1)\n        zbe_op:      bitcnt_bits = operand_b_i;\n        bitcnt_cz:   bitcnt_bits = bitcnt_bit_mask & ~bitcnt_mask_op; // clz / ctz\n        default:     bitcnt_bits = operand_a_i; // cpop\n      endcase\n    end\n\n    // The parallel prefix counter is of the structure of a Brent-Kung Adder. In the first\n    // log2(width) stages, the sum of the n preceding bit lines is computed for the bit lines at\n    // positions 2**n-1 (power-of-two positions) where n denotes the current stage.\n    // In stage n=log2(width), the count for position width-1 (the MSB) is finished.\n    // For the intermediate values, an inverse adder tree then computes the bit counts for the bit\n    // lines at positions\n    // m = 2**(n-1) + i*2**(n-2), where i = [1 ... width / 2**(n-1)-1] and n = [log2(width) ... 2].\n    // Thus, at every subsequent stage the result of two previously unconnected sub-trees is\n    // summed, starting at the node summing bits [width/2-1 : 0] and [3*width/4-1: width/2]\n    // and moving to iteratively sum up all the sub-trees.\n    // The inverse adder tree thus features log2(width) - 1 stages the first of these stages is a\n    // single addition at position 3*width/4 - 1. It does not interfere with the last\n    // stage of the primary adder tree. These stages can thus be folded together, resulting in a\n    // total of 2*log2(width)-2 stages.\n    // For more details refer to R. Brent, H. T. Kung, \"A Regular Layout for Parallel Adders\",\n    // (1982).\n    // For a bitline at position p, only bits\n    // bitcnt_partial[max(i, such that p % log2(i) == 0)-1 : 0] are needed for generation of the\n    // butterfly network control signals. The adders in the intermediate value adder tree thus need\n    // not be full 5-bit adders. We leave the optimization to the synthesis tools.\n    //\n    // Consider the following 8-bit example for illustraton.\n    //\n    // let bitcnt_bits = 8'babcdefgh.\n    //\n    //                   a  b  c  d  e  f  g  h\n    //                   | /:  | /:  | /:  | /:\n    //                   |/ :  |/ :  |/ :  |/ :\n    // stage 1:          +  :  +  :  +  :  +  :\n    //                   |  : /:  :  |  : /:  :\n    //                   |,--+ :  :  |,--+ :  :\n    // stage 2:          +  :  :  :  +  :  :  :\n    //                   |  :  |  : /:  :  :  :\n    //                   |,-----,--+ :  :  :  : ^-primary adder tree\n    // stage 3:          +  :  +  :  :  :  :  : -------------------------\n    //                   :  | /| /| /| /| /|  : ,-intermediate adder tree\n    //                   :  |/ |/ |/ |/ |/ :  :\n    // stage 4           :  +  +  +  +  +  :  :\n    //                   :  :  :  :  :  :  :  :\n    // bitcnt_partial[i] 7  6  5  4  3  2  1  0\n\n    always_comb begin\n      bitcnt_partial = '{default: '0};\n      // stage 1\n      for (int unsigned i = 1; i < 32; i += 2) begin\n        bitcnt_partial[i] = {5'h0, bitcnt_bits[i]} + {5'h0, bitcnt_bits[i-1]};\n      end\n      // stage 2\n      for (int unsigned i = 3; i < 32; i += 4) begin\n        bitcnt_partial[i] = bitcnt_partial[i-2] + bitcnt_partial[i];\n      end\n      // stage 3\n      for (int unsigned i = 7; i < 32; i += 8) begin\n        bitcnt_partial[i] = bitcnt_partial[i-4] + bitcnt_partial[i];\n      end\n      // stage 4\n      for (int unsigned i = 15; i < 32; i += 16) begin\n        bitcnt_partial[i] = bitcnt_partial[i-8] + bitcnt_partial[i];\n      end\n      // stage 5\n      bitcnt_partial[31] = bitcnt_partial[15] + bitcnt_partial[31];\n      // ^- primary adder tree\n      // -------------------------------\n      // ,-intermediate value adder tree\n      bitcnt_partial[23] = bitcnt_partial[15] + bitcnt_partial[23];\n\n      // stage 6\n      for (int unsigned i = 11; i < 32; i += 8) begin\n        bitcnt_partial[i] = bitcnt_partial[i-4] + bitcnt_partial[i];\n      end\n\n      // stage 7\n      for (int unsigned i = 5; i < 32; i += 4) begin\n        bitcnt_partial[i] = bitcnt_partial[i-2] + bitcnt_partial[i];\n      end\n      // stage 8\n      bitcnt_partial[0] = {5'h0, bitcnt_bits[0]};\n      for (int unsigned i = 2; i < 32; i += 2) begin\n        bitcnt_partial[i] = bitcnt_partial[i-1] + {5'h0, bitcnt_bits[i]};\n      end\n    end\n\n    ///////////"}
{"text": "////\n    // Min / Max //\n    ///////////////\n\n    assign minmax_result = cmp_result ? operand_a_i : operand_b_i;\n\n    //////////\n    // Pack //\n    //////////\n\n    logic packu;\n    logic packh;\n    assign packu = operator_i == ALU_PACKU;\n    assign packh = operator_i == ALU_PACKH;\n\n    always_comb begin\n      unique case (1'b1)\n        packu:   pack_result = {operand_b_i[31:16], operand_a_i[31:16]};\n        packh:   pack_result = {16'h0, operand_b_i[7:0], operand_a_i[7:0]};\n        default: pack_result = {operand_b_i[15:0], operand_a_i[15:0]};\n      endcase\n    end\n\n    //////////\n    // Sext //\n    //////////\n\n    assign sext_result = (operator_i == ALU_SEXTB) ?\n        { {24{operand_a_i[7]}}, operand_a_i[7:0]} : { {16{operand_a_i[15]}}, operand_a_i[15:0]};\n\n    /////////////////////////////\n    // Single-bit Instructions //\n    /////////////////////////////\n\n    always_comb begin\n      unique case (operator_i)\n        ALU_BSET: singlebit_result = operand_a_i | shift_result;\n        ALU_BCLR: singlebit_result = operand_a_i & ~shift_result;\n        ALU_BINV: singlebit_result = operand_a_i ^ shift_result;\n        default:  singlebit_result = {31'h0, shift_result[0]}; // ALU_BEXT\n      endcase\n    end\n\n    ////////////////////////////////////\n    // General Reverse and Or-combine //\n    ////////////////////////////////////\n\n    // Only a subset of the general reverse and or-combine instructions are implemented in the\n    // balanced version of the B extension. Currently rev8 (shift_amt = 5'b11000) and orc.b\n    // (shift_amt = 5'b00111) are supported in the base extension.\n\n    logic [4:0] zbp_shift_amt;\n    logic gorc_op;\n\n    assign gorc_op = (operator_i == ALU_GORC);\n    assign zbp_shift_amt[2:0] =\n        (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) ? shift_amt[2:0] : {3{shift_amt[0]}};\n    assign zbp_shift_amt[4:3] =\n        (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) ? shift_amt[4:3] : {2{shift_amt[3]}};\n\n    always_comb begin\n      rev_result = operand_a_i;\n\n      if (zbp_shift_amt[0]) begin\n        rev_result = (gorc_op ? rev_result : 32'h0)       |\n                     ((rev_result & 32'h5555_5555) <<  1) |\n                     ((rev_result & 32'haaaa_aaaa) >>  1);\n      end\n\n      if (zbp_shift_amt[1]) begin\n        rev_result = (gorc_op ? rev_result : 32'h0)       |\n                     ((rev_result & 32'h3333_3333) <<  2) |\n                     ((rev_result & 32'hcccc_cccc) >>  2);\n      end\n\n      if (zbp_shift_amt[2]) begin\n        rev_result = (gorc_op ? rev_result : 32'h0)       |\n                     ((rev_result & 32'h0f0f_0f0f) <<  4) |\n                     ((rev_result & 32'hf0f0_f0f0) >>  4);\n      end\n\n      if (zbp_shift_amt[3]) begin\n        rev_result = ((RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) &&\n                      gorc_op ? rev_result : 32'h0) |\n                     ((rev_result & 32'h00ff_00ff) <<  8) |\n                     ((rev_result & 32'hff00_ff00) >>  8);\n      end\n\n      if (zbp_shift_amt[4]) begin\n        rev_result = ((RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) &&\n                      gorc_op ? rev_result : 32'h0) |\n                     ((rev_result & 32'h0000_ffff) << 16) |\n                     ((rev_result & 32'hffff_0000) >> 16);\n      end\n    end\n\n    logic crc_hmode;\n    logic crc_bmode;\n    logic [31:0] clmul_result_rev;\n\n    if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) begin : gen_alu_rvb_otearlgrey_full\n\n      /////////////////////////\n      // Shuffle / Unshuffle //\n      /////////////////////////\n\n      localparam logic [31:0] SHUFFLE_MASK_L [4] =\n          '{32'h00ff_0000, 32'h0f00_0f00, 32'h3030_3030, 32'h4444_4444};\n      localparam logic [31:0] SHUFFLE_MASK_R [4] =\n          '{32'h0000_ff00, 32'h00f0_00f0, 32'h0c0c_0c0c, 32'h2222_2222};\n\n      localparam logic [31:0] FLIP_MASK_L [4] =\n          '{32'h2200_1100, 32'h0044_0000, 32'h4411_0000, 32'h1100_0000};\n      localparam logic [31:0] FLIP_MASK_R [4] =\n          '{32'h0088_0044, 32'h0000_2200, 32'h0000_8822, 32'h0000_0088};\n\n      logic [31:0] SHUFFLE_MASK_NOT [4];\n      for(genvar i = 0; i < 4; i++) begin : gen_shuffle_mask_not\n        assign SHUFFLE_MASK_NOT[i] = ~(SHUFFLE_MASK_L[i] | SHUFFLE_MASK_R[i]);\n      end\n\n      logic shuffle_flip;\n      assign shuffle_flip = operator_i == ALU_UNSHFL;\n\n      logic [3:0] shuffle_mode;\n\n      always_comb begin\n        shuffle_result = operand_a_i;\n\n        if (shuffle_flip) begin\n          shuffle_mode[3] = shift_amt[0];\n          shuffle_mode[2] = shift_amt[1];\n          shuffle_mode[1] = shift_amt[2];\n          shuffle_mode[0] = shift_amt[3];\n        end else begin\n          shuffle_mode = shift_amt[3:0];\n        end\n\n        if (shuffle_flip) begin\n          shuffle_result = (shuffle_result & 32'h8822_4411) |\n              ((shuffle_result << 6)  & FLIP_MASK_L[0]) |\n              ((shuffle_result >> 6)  & FLIP_MASK_R[0]) |\n              ((shuffle_result << 9)  & FLIP_MASK_L[1]) |\n              ((shuffle_result >> 9)  & FLIP_MASK_R[1]) |\n              ((shuffle_result << 15) & FLIP_MASK_L[2]) |\n              ((shuffle_result >> 15) & FLIP_MASK_R[2]) |\n              ((shuffle_result << 21) & FLIP_MASK_L[3]) |\n              ((shuffle_result >> 21) & FLIP_MASK_R[3]);\n        end\n\n        if (shuffle_mode[3]) begin\n          shuffle_result = (shuffle_result & SHUFFLE_MASK_NOT[0]) |\n              (((shuffle_result << 8) & SHUFFLE_MASK_L[0]) |\n              ((shuffle_result >> 8) & SHUFFLE_MASK_R[0]));\n        end\n        if (shuffle_mode[2]) begin\n          shuffle_result = (shuffle_result & SHUFFLE_MASK_NOT[1]) |\n              (((shuffle_result << 4) & SHUFFLE_MASK_L[1]) |\n              ((shuffle_result >> 4) & SHUFFLE_MASK_R[1]));\n        end\n        if (shuffle_mode[1]) begin\n          shuffle_result = (shuffle_result & SHUFFLE_MASK_NOT[2]) |\n              (((shuffle_result << 2) & SHUFFLE_MASK_L[2]) |\n              ((shuffle_result >> 2) & SHUFFLE_MASK_R[2]));\n        end\n        if (shuffle_mode[0]) begin\n          shuffle_result = (shuffle_result & SHUFFLE_MASK_NOT[3]) |\n              (((shuffle_result << 1) & SHUFFLE_MASK_L[3]) |\n              ((shuffle_result >> 1) & SHUFFLE_MASK_R[3]));\n        end\n\n        if (shuffle_flip) begin\n          shuffle_result = (shuffle_result & 32'h8822_4411) |\n              ((shuffle_result << 6)  & FLIP_MASK_L[0]) |\n              ((shuffle_result >> 6)  & FLIP_MASK_R[0]) |\n              ((shuffle_result << 9)  & FLIP_MASK_L[1]) |\n              ((shuffle_result >> 9)  & FLIP_MASK_R[1]) |\n              ((shuffle_result << 15) & FLIP_MASK_L[2]) |\n              ((shuffle_result >> 15) & FLIP_MASK_R[2]) |\n              ((shuffle_result << 21) & FLIP_MASK_L[3]) |\n              ((shuffle_result >> 21) & FLIP_MASK_R[3]);\n        end\n      end\n\n      //////////////\n      // Crossbar //\n      //////////////\n      // The crossbar permutation instructions xperm.[nbh] (Zbp) can be implemented using 8\n      // parallel 4-bit-wide, 8-input crossbars. Basically, we permute the 8 nibbles of operand_a_i\n      // based on operand_b_i.\n\n      // Generate selector indices and valid signals.\n      // - sel_n[x] indicates which nibble of operand_a_i is selected for output nibble x.\n      // - vld_n[x] indicates if the selection is valid.\n      logic  [7:0][2:0] sel_n; // nibbles\n      logic  [7:0]      vld_n; // nibbles\n      logic  [3:0][1:0] sel_b; // bytes\n      logic  [3:0]      vld_b; // bytes\n      logic  [1:0][0:0] sel_h; // half words\n      logic  [1:0]      vld_h; // half words\n\n      // Per nibble, 3 bits are needed for the selection. Other bits must be zero.\n      // sel_n bit mask: 32'b0111_0111_0111_0111_0111_0111_0111_0111\n      // vld_n bit mask: 32'b1000_1000_1000_1000_1000_1000_1000_1000\n      for (genvar i = 0; i < 8; i++) begin : gen_sel_vld_n\n        assign sel_n[i] =   operand_b_i[i*4     +: 3];\n        assign vld_n[i] = ~|operand_b_i[i*4 + 3 +: 1];\n      end\n\n      // Per byte, 2 bits are needed for the selection. Other bits must be zero.\n      // sel_b bit mask: 32'b0000_0011_0000_0011_0000_0011_0000_0011\n      // vld_b bit mask: 32'b1111_1100_1111_1100_1111_1100_1111_1100\n      for (genvar i = 0; i < 4; i++) begin : gen_sel_vld_b\n        assign sel_b[i] =   operand_b_i[i*8     +: 2];\n        assign vld_b[i] = ~|operand_b_i[i*8 + 2 +: 6];\n      end\n\n      // Per half word, 1 bit is needed for the selection only. All other bits must be zero.\n      // sel_h bit mask: 32'b0000_0000_0000_0001_0000_0000_0000_0001\n      // vld_h bit mask: 32'b1111_1111_1111_1110_1111_1111_1111_1110\n      for (genvar i = 0; i < 2; i++) begin : gen_sel_vld_h\n        assign sel_h[i] =   operand_b_i[i*16     +: 1];\n        assign vld_h[i] = ~|operand_b_i[i*16 + 1 +: 15];\n      end\n\n      // Convert selector indices and valid signals to control the nibble-based\n      // crossbar logic.\n      logic [7:0][2:0] sel;\n      logic [7:0]      vld;\n      always_comb begin\n        unique case (operator_i)\n          ALU_XPERM_N: begin\n            // No conversion needed.\n            sel = sel_n;\n            vld = vld_n;\n          end\n\n          ALU_XPERM_B: begin\n            // Convert byte to nibble indicies.\n            for (int b = 0; b < 4; b++) begin\n              sel[b*2 +  0] =   {sel_b[b], 1'b0};\n              sel[b*2 +  1] =   {sel_b[b], 1'b1};\n              vld[b*2 +: 2] = {2{vld_b[b]}};\n            end\n          end\n\n          ALU_XPERM_H: begin\n            // Convert half-word to nibble indices.\n            for (int h = 0; h < 2; h++) begin\n              sel[h*4 +  0] =   {sel_h[h], 2'b00};\n              sel[h*4 +  1] =   {sel_h[h], 2'b01};\n              sel[h*4 +  2] =   {sel_h[h], 2'b10};\n              sel[h*4 +  3] =   {sel_h[h], 2'b11};\n              vld[h*4 +: 4] = {4{vld_h[h]}};\n            end\n          end\n\n          default: begin\n            // Tie valid to zero to disable the crossbar unless we need it.\n            sel = sel_n;\n            vld = '0;\n          end\n        endcase\n      end\n\n      // The actual nibble-based crossbar logic.\n      logic [7:0][3:0] val_n;\n      logic [7:0][3:0] xperm_n;\n      assign val_n = operand_a_i;\n      for (genvar i = 0; i < 8; i++) begin : gen_xperm_n\n        assign xperm_n[i] = vld[i] ? val_n[sel[i]] : '0;\n      end\n      assign xperm_result = xperm_n;\n\n      ///////////////////////////////////////////////////\n      // Carry-less Multiply + Cyclic Redundancy Check //\n      ///////////////////////////////////////////////////\n\n      // Carry-less multiplication can be understood as multiplication based on\n      // the addition interpreted as the bit-wise xor operation.\n      //\n      // Example: 1101 X 1011 = 1111111:\n      //\n      //       1011 X 1101\n      //       -----------\n      //              1101\n      //         xor 1101\n      //         ---------\n      //             10111\n      //        xor 0000\n      //        ----------\n      //            010111\n      //       xor 1101\n      //       -----------\n      //           1111111\n      //\n      // Architectural details:\n      //         A 32 x 32-bit array\n      //         [ operand_b[i] ? (operand_a << i) : '0 for i in 0 ... 31 ]\n      //         is generated. The entries of the array are pairwise 'xor-ed'\n      //         together in a 5-stage binary tree.\n      //\n      //\n      // Cyclic Redundancy Check:\n      //\n      // CRC-32 (CRC-32/ISO-HDLC) and CRC-32C (CRC-32/ISCSI) are directly implemented. For\n      // documentation of the crc configuration (crc-polynomials, initialization, reflection, etc.)\n      // see http://reveng.sourceforge.net/crc-catalogue/all.htm\n      // A useful guide to crc arithmetic and algorithms is given here:\n      // http://www.piclist.com/techref/method/math/crcguide.html.\n      //\n      // The CRC operation solves the following equation using binary polynomial arithmetic:\n      //\n      // rev(rd)(x) = rev(rs1)(x) * x**n mod {1, P}(x)\n      //\n      // where P denotes lower 32 bits of the corresponding CRC polynomial, rev(a) the bit reversal\n      // of a, n = 8,16, or 32 for .b, .h, .w -variants. {a, b} denotes bit concatenation.\n      //\n      // Using barret reduction, one can show that\n      //\n      // M(x) mod P(x) = R(x) =\n      //          (M(x) * x**n) & {deg(P(x)'{1'b1}}) ^ (M(x) x**-(deg(P(x) - n)) cx mu(x) cx P(x),\n      //\n      // Where mu(x) = polydiv(x**64, {1,P}) & 0xffffffff. Here, 'cx' refers to carry-less\n      // multiplication. Substituting rev(rd)(x) for R(x) and rev(rs1)(x) for M(x) and solving for\n      // rd(x) with P(x) a crc32 polynomial (deg(P(x)) = 32), we get\n      //\n      // rd = rev( (rev(rs1) << n)  ^ ((rev(rs1) >> (32-n)) cx mu cx P)\n      //    = (rs1 >> n) ^ rev(rev( (rs1 << (32-n)) cx rev(mu)) cx P)\n      //                       ^-- cycle 0--------------------^\n      //      ^- cycle 1 -------------------------------------------^\n      //\n      // In the last step we used the fact that carry-less multiplication is bit-order agnostic:\n      // rev(a cx b) = rev(a) cx rev(b).\n\n      logic clmul_rmode;\n      logic clmul_hmode;\n      logic [31:0] clmul_op_a;\n      logic [31:0] clmul_op_b;\n      logic [31:0] operand_b_rev;\n      logic [31:0] clmul_and_stage[32];\n      logic [31:0] clmul_xor_stage1[16];\n      logic [31:0] clmul_xor_stage2[8];\n      logic [31:0] clmul_xor_stage3[4];\n      logic [31:0] clmul_xor_stage4[2];\n\n      logic [31:0] clmul_result_raw;\n\n      for (genvar i = 0; i < 32; i++) begin : gen_rev_operand_b\n        assign operand_b_rev[i] = operand_b_i[31-i];\n      end\n\n      assign clmul_rmode = operator_i == ALU_CLMULR;\n      assign clmul_hmode = operator_i == ALU_CLMULH;\n\n      // CRC\n      localparam logic [31:0] CRC32_POLYNOMIAL = 32'h04c1_1db7;\n      localparam logic [31:0] CRC32_MU_REV = 32'hf701_1641;\n\n      localparam logic [31:0] CRC32C_POLYNOMIAL = 32'h1edc_6f41;\n      localparam logic [31:0] CRC32C_MU_REV = 32'hdea7_13f1;\n\n      logic crc_op;\n\n      logic crc_cpoly;\n\n      logic [31:0] crc_operand;\n      logic [31:0] crc_poly;\n      logic [31:0] crc_mu_rev;\n\n      assign crc_op = (operator_i == ALU_CRC32C_W) | (operator_i == ALU_CRC32_W) |\n                      (operator_i == ALU_CRC32C_H) | (operator_i == ALU_CRC32_H) |\n                      (operator_i == ALU_CRC32C_B) | (operator_i == ALU_CRC32_B);\n\n      assign crc_cpoly = (operator_i == ALU_CRC32C_W) |\n                         (operator_i == ALU_CRC32C_H) |\n                         (operator_i == ALU_CRC32C_B);\n\n      assign crc_hmode = (operator_i == ALU_CRC32_H) | (operator_i == ALU_CRC32C_H);\n      assign crc_bmode = (operator_i == ALU_CRC32_B) | (operator_i == ALU_CRC32C_B);\n\n      assign crc_poly   = crc_cpoly ? CRC32C_POLYNOMIAL : CRC32_POLYNOMIAL;\n      assign crc_mu_rev = crc_cpoly ? CRC32C_MU_REV : CRC32_MU_REV;\n\n      always_comb begin\n        unique case (1'b1)\n          crc_bmode: crc_operand = {operand_a_i[7:0], 24'h0};\n          crc_hmode: crc_operand = {operand_a_i[15:0], 16'h0};\n          default:   crc_operand = operand_a_i;\n        endcase\n      end\n\n      // Select clmul input\n      always_comb begin\n        if (crc_op) begin\n          clmul_op_a = instr_first_cycle_i ? crc_operand : imd_val_q_i[0];\n          clmul_op_b = instr_first_cycle_i ? crc_mu_rev : crc_poly;\n        end else begin\n          clmul_op_a = clmul_rmode | clmul_hmode ? operand_a_rev : operand_a_i;\n          clmul_op_b = clmul_rmode | clmul_hmode ? operand_b_rev : operand_b_i;\n        end\n      end\n\n      for (genvar i = 0; i < 32; i++) begin : gen_clmul_and_op\n        assign clmul_and_stage[i] = clmul_op_b[i] ? clmul_op_a << i : '0;\n      end\n\n      for (genvar i = 0; i < 16; i++) begin : gen_clmul_xor_op_l1\n        assign clmul_xor_stage1[i] = clmul_and_stage[2*i] ^ clmul_and_stage[2*i+1];\n      end\n\n      for (genvar i = 0; i < 8; i++) begin : gen_clmul_xor_op_l2\n        assign clmul_xor_stage2[i] = clmul_xor_stage1[2*i] ^ clmul_xor_stage1[2*i+1];\n      end\n\n      for (genvar i = 0; i < 4; i++) begin : gen_clmul_xor_op_l3\n        assign clmul_xor_stage3[i] = clmul_xor_stage2[2*i] ^ clmul_xor_stage2[2*i+1];\n      end\n\n      for (genvar i = 0; i < 2; i++) begin : gen_clmul_xor_op_l4\n        assign clmul_xor_stage4[i] = clmul_xor_stage3[2*i] ^ clmul_xor_stage3[2*i+1];\n      end\n\n      assign clmul_result_raw = clmul_xor_stage4[0] ^ clmul_xor_stage4[1];\n\n      for (genvar i = 0; i < 32; i++) begin : gen_rev_clmul_result\n        assign clmul_result_rev[i] = clmul_result_raw[31-i];\n      end\n\n      // clmulr_result = rev(clmul(rev(a), rev(b)))\n      // clmulh_result = clmulr_result >> 1\n      always_comb begin\n        unique case (1'b1)\n          clmul_rmode: clmul_result = clmul_result_rev;\n          clmul_hmode: clmul_result = {1'b0, clmul_result_rev[31:1]};\n          default:     clmul_result = clmul_result_raw;\n        endcase\n      end\n    end else begin : gen_alu_rvb_not_otearlgrey_full\n      assign shuffle_result       = '0;\n      assign xperm_result         = '0;\n      assign clmul_result         = '0;\n      // support signals\n      assign clmul_result_rev     = '0;\n      assign crc_bmode            = '0;\n      assign crc_hmode            = '0;\n    end\n\n    if (RV32B == RV32BFull) begin : gen_alu_rvb_full\n\n      ///////////////\n      // Butterfly //\n      ///////////////\n\n      // The butterfly / inverse butterfly network executing bcompress/bdecompress (zbe)\n      // instructions. For bdecompress, the control bits mask of a local left region is generated\n      // by the inverse of a n-bit left rotate and complement upon wrap (LROTC) operation by the\n      // number of ones in the deposit bitmask to the right of the segment. n hereby denotes the\n      // width of the according segment. The bitmask for a pertaining local right region is equal\n      // to the corresponding local left region. Bcompress uses an analogue inverse process.\n      // Consider the following 8-bit example.  For details, see Hilewitz et al. \"Fast Bit Gather,\n      // Bit Scatter and Bit Permuation Instructions for Commodity Microprocessors\", (2008).\n      //\n      // The bcompress/bdecompress instructions are completed in 2 cycles. In the first cycle, the\n      // control bitmask is prepared by executing the parallel prefix bit count. In the second\n      // cycle, the bit swapping is executed according to the control masks.\n\n      // 8-bit example:  (Hilewitz et al.)\n      // Consider the instruction bdecompress operand_a_i deposit_mask\n      // Let operand_a_i = 8'babcd_efgh\n      //    deposit_mask = 8'b1010_1101\n      //\n      // control bitmask for stage 1:\n      //  - number of ones in the right half of the deposit bitmask: 3\n      //  - width of the segment: 4\n      //  - control bitmask = ~LROTC(4'b0, 3)[3:0] = 4'b1000\n      //\n      // control bitmask:   c3 c2  c1 c0  c3 c2  c1 c0\n      //                    1  0   0  0   1  0   0  0\n      //                    <- L ----->   <- R ----->\n      // operand_a_i        a  b   c  d   e  f   g  h\n      //                    :\\ |   |  |  /:  |   |  |\n      //                    : +|---|--|-+ :  |   |  |\n      //                    :/ |   |  |  \\:  |   |  |\n      // stage 1            e  b   c  d   a  f   g  h\n      //                    <L->   <R->   <L->   <R->\n      // control bitmask:   c3 c2  c3 c2  c1 c0  c1 c0\n      //                    1  1   1  1   1  0   1  0\n      //                    :\\ :\\ /: /:   :\\ |  /:  |\n      //                    : +:-+-:+ :   : +|-+ :  |\n      //                    :/ :/ \\: \\:   :/ |  \\:  |\n      // stage 2            c  d   e  b   g  f   a  h\n      //                    L  R   L  R   L  R   L  R\n      // control bitmask:   c3 c3  c2 c2  c1 c1  c0 c0\n      //                    1  1   0  0   1  1   0  0\n      //                    :\\/:   |  |   :\\/:   |  |\n      //                    :  :   |  |   :  :   |  |\n      //                    :/\\:   |  |   :/\\:   |  |\n      // stage 3            d  c   e  b   f  g   a  h\n      // & deposit bitmask: 1  0   1  0   1  1   0  1\n      // result:            d  0   e  0   f  g   0  h\n\n"}
{"text": "      logic [ 5:0] bitcnt_partial_q [32];\n\n      // first cycle\n      // Store partial bitcnts\n      for (genvar i = 0; i < 32; i++) begin : gen_bitcnt_reg_in_lsb\n        assign bitcnt_partial_lsb_d[i] = bitcnt_partial[i][0];\n      end\n\n      for (genvar i = 0; i < 16; i++) begin : gen_bitcnt_reg_in_b1\n        assign bitcnt_partial_msb_d[i] = bitcnt_partial[2*i+1][1];\n      end\n\n      for (genvar i = 0; i < 8; i++) begin : gen_bitcnt_reg_in_b2\n        assign bitcnt_partial_msb_d[16+i] = bitcnt_partial[4*i+3][2];\n      end\n\n      for (genvar i = 0; i < 4; i++) begin : gen_bitcnt_reg_in_b3\n        assign bitcnt_partial_msb_d[24+i] = bitcnt_partial[8*i+7][3];\n      end\n\n      for (genvar i = 0; i < 2; i++) begin : gen_bitcnt_reg_in_b4\n        assign bitcnt_partial_msb_d[28+i] = bitcnt_partial[16*i+15][4];\n      end\n\n      assign bitcnt_partial_msb_d[30] = bitcnt_partial[31][5];\n      assign bitcnt_partial_msb_d[31] = 1'b0; // unused\n\n      // Second cycle\n      // Load partial bitcnts\n      always_comb begin\n        bitcnt_partial_q = '{default: '0};\n\n        for (int unsigned i = 0; i < 32; i++) begin : gen_bitcnt_reg_out_lsb\n          bitcnt_partial_q[i][0] = imd_val_q_i[0][i];\n        end\n\n        for (int unsigned i = 0; i < 16; i++) begin : gen_bitcnt_reg_out_b1\n          bitcnt_partial_q[2*i+1][1] = imd_val_q_i[1][i];\n        end\n\n        for (int unsigned i = 0; i < 8; i++) begin : gen_bitcnt_reg_out_b2\n          bitcnt_partial_q[4*i+3][2] = imd_val_q_i[1][16+i];\n        end\n\n        for (int unsigned i = 0; i < 4; i++) begin : gen_bitcnt_reg_out_b3\n          bitcnt_partial_q[8*i+7][3] = imd_val_q_i[1][24+i];\n        end\n\n        for (int unsigned i = 0; i < 2; i++) begin : gen_bitcnt_reg_out_b4\n          bitcnt_partial_q[16*i+15][4] = imd_val_q_i[1][28+i];\n        end\n\n        bitcnt_partial_q[31][5] = imd_val_q_i[1][30];\n      end\n\n      logic [31:0] butterfly_mask_l[5];\n      logic [31:0] butterfly_mask_r[5];\n      logic [31:0] butterfly_mask_not[5];\n      logic [31:0] lrotc_stage [5]; // left rotate and complement upon wrap\n\n      // number of bits in local r = 32 / 2**(stage + 1) = 16/2**stage\n      `define _N(stg) (16 >> stg)\n\n      // bcompress / bdecompress control bit generation\n      for (genvar stg = 0; stg < 5; stg++) begin : gen_butterfly_ctrl_stage\n        // number of segs: 2** stg\n        for (genvar seg=0; seg<2**stg; seg++) begin : gen_butterfly_ctrl\n\n          assign lrotc_stage[stg][2*`_N(stg)*(seg+1)-1 : 2*`_N(stg)*seg] =\n              {{`_N(stg){1'b0}},{`_N(stg){1'b1}}} <<\n                bitcnt_partial_q[`_N(stg)*(2*seg+1)-1][$clog2(`_N(stg)):0];\n\n          assign butterfly_mask_l[stg][`_N(stg)*(2*seg+2)-1 : `_N(stg)*(2*seg+1)]\n                   = ~lrotc_stage[stg][`_N(stg)*(2*seg+2)-1 : `_N(stg)*(2*seg+1)];\n\n          assign butterfly_mask_r[stg][`_N(stg)*(2*seg+1)-1 : `_N(stg)*(2*seg)]\n                   = ~lrotc_stage[stg][`_N(stg)*(2*seg+2)-1 : `_N(stg)*(2*seg+1)];\n\n          assign butterfly_mask_l[stg][`_N(stg)*(2*seg+1)-1 : `_N(stg)*(2*seg)]   = '0;\n          assign butterfly_mask_r[stg][`_N(stg)*(2*seg+2)-1 : `_N(stg)*(2*seg+1)] = '0;\n        end\n      end\n      `undef _N\n\n      for (genvar stg = 0; stg < 5; stg++) begin : gen_butterfly_not\n        assign butterfly_mask_not[stg] =\n            ~(butterfly_mask_l[stg] | butterfly_mask_r[stg]);\n      end\n\n      always_comb begin\n        butterfly_result = operand_a_i;\n\n        butterfly_result = butterfly_result & butterfly_mask_not[0] |\n            ((butterfly_result & butterfly_mask_l[0]) >> 16)|\n            ((butterfly_result & butterfly_mask_r[0]) << 16);\n\n        butterfly_result = butterfly_result & butterfly_mask_not[1] |\n            ((butterfly_result & butterfly_mask_l[1]) >> 8)|\n            ((butterfly_result & butterfly_mask_r[1]) << 8);\n\n        butterfly_result = butterfly_result & butterfly_mask_not[2] |\n            ((butterfly_result & butterfly_mask_l[2]) >> 4)|\n            ((butterfly_result & butterfly_mask_r[2]) << 4);\n\n        butterfly_result = butterfly_result & butterfly_mask_not[3] |\n            ((butterfly_result & butterfly_mask_l[3]) >> 2)|\n            ((butterfly_result & butterfly_mask_r[3]) << 2);\n\n        butterfly_result = butterfly_result & butterfly_mask_not[4] |\n            ((butterfly_result & butterfly_mask_l[4]) >> 1)|\n            ((butterfly_result & butterfly_mask_r[4]) << 1);\n\n        butterfly_result = butterfly_result & operand_b_i;\n      end\n\n      always_comb begin\n        invbutterfly_result = operand_a_i & operand_b_i;\n\n        invbutterfly_result = invbutterfly_result & butterfly_mask_not[4] |\n            ((invbutterfly_result & butterfly_mask_l[4]) >> 1)|\n            ((invbutterfly_result & butterfly_mask_r[4]) << 1);\n\n        invbutterfly_result = invbutterfly_result & butterfly_mask_not[3] |\n            ((invbutterfly_result & butterfly_mask_l[3]) >> 2)|\n            ((invbutterfly_result & butterfly_mask_r[3]) << 2);\n\n        invbutterfly_result = invbutterfly_result & butterfly_mask_not[2] |\n            ((invbutterfly_result & butterfly_mask_l[2]) >> 4)|\n            ((invbutterfly_result & butterfly_mask_r[2]) << 4);\n\n        invbutterfly_result = invbutterfly_result & butterfly_mask_not[1] |\n            ((invbutterfly_result & butterfly_mask_l[1]) >> 8)|\n            ((invbutterfly_result & butterfly_mask_r[1]) << 8);\n\n        invbutterfly_result = invbutterfly_result & butterfly_mask_not[0] |\n            ((invbutterfly_result & butterfly_mask_l[0]) >> 16)|\n            ((invbutterfly_result & butterfly_mask_r[0]) << 16);\n      end\n    end else begin : gen_alu_rvb_not_full\n      logic [31:0] unused_imd_val_q_1;\n      assign unused_imd_val_q_1   = imd_val_q_i[1];\n      assign butterfly_result     = '0;\n      assign invbutterfly_result  = '0;\n      // support signals\n      assign bitcnt_partial_lsb_d = '0;\n      assign bitcnt_partial_msb_d = '0;\n    end\n\n    //////////////////////////////////////\n    // Multicycle Bitmanip Instructions //\n    //////////////////////////////////////\n    // Ternary instructions + Shift Rotations + Bit Compress/Decompress + CRC\n    // For ternary instructions (zbt), operand_a_i is tied to rs1 in the first cycle and rs3 in the\n    // second cycle. operand_b_i is always tied to rs2.\n\n    always_comb begin\n      unique case (operator_i)\n        ALU_CMOV: begin\n          multicycle_result = (operand_b_i == 32'h0) ? operand_a_i : imd_val_q_i[0];\n          imd_val_d_o = '{operand_a_i, 32'h0};\n          if (instr_first_cycle_i) begin\n            imd_val_we_o = 2'b01;\n          end else begin\n            imd_val_we_o = 2'b00;\n          end\n        end\n\n        ALU_CMIX: begin\n          multicycle_result = imd_val_q_i[0] | bwlogic_and_result;\n          imd_val_d_o = '{bwlogic_and_result, 32'h0};\n          if (instr_first_cycle_i) begin\n            imd_val_we_o = 2'b01;\n          end else begin\n            imd_val_we_o = 2'b00;\n          end\n        end\n\n        ALU_FSR, ALU_FSL,\n        ALU_ROL, ALU_ROR: begin\n          if (shift_amt[4:0] == 5'h0) begin\n            multicycle_result = shift_amt[5] ? operand_a_i : imd_val_q_i[0];\n          end else begin\n            multicycle_result = imd_val_q_i[0] | shift_result;\n          end\n          imd_val_d_o = '{shift_result, 32'h0};\n          if (instr_first_cycle_i) begin\n            imd_val_we_o = 2'b01;\n          end else begin\n            imd_val_we_o = 2'b00;\n          end\n        end\n\n        ALU_CRC32_W, ALU_CRC32C_W,\n        ALU_CRC32_H, ALU_CRC32C_H,\n        ALU_CRC32_B, ALU_CRC32C_B: begin\n          if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) begin\n            unique case (1'b1)\n              crc_bmode: multicycle_result = clmul_result_rev ^ (operand_a_i >> 8);\n              crc_hmode: multicycle_result = clmul_result_rev ^ (operand_a_i >> 16);\n              default:   multicycle_result = clmul_result_rev;\n            endcase\n            imd_val_d_o = '{clmul_result_rev, 32'h0};\n            if (instr_first_cycle_i) begin\n              imd_val_we_o = 2'b01;\n            end else begin\n              imd_val_we_o = 2'b00;\n            end\n          end else begin\n            imd_val_d_o = '{operand_a_i, 32'h0};\n            imd_val_we_o = 2'b00;\n            multicycle_result = '0;\n          end\n        end\n\n        ALU_BCOMPRESS, ALU_BDECOMPRESS: begin\n          if (RV32B == RV32BFull) begin\n            multicycle_result = (operator_i == ALU_BDECOMPRESS) ? butterfly_result :\n                                                                  invbutterfly_result;\n            imd_val_d_o = '{bitcnt_partial_lsb_d, bitcnt_partial_msb_d};\n            if (instr_first_cycle_i) begin\n              imd_val_we_o = 2'b11;\n            end else begin\n              imd_val_we_o = 2'b00;\n            end\n          end else begin\n            imd_val_d_o = '{operand_a_i, 32'h0};\n            imd_val_we_o = 2'b00;\n            multicycle_result = '0;\n          end\n        end\n\n        default: begin\n          imd_val_d_o = '{operand_a_i, 32'h0};\n          imd_val_we_o = 2'b00;\n          multicycle_result = '0;\n        end\n      endcase\n    end\n\n\n  end else begin : g_no_alu_rvb\n    logic [31:0] unused_imd_val_q[2];\n    assign unused_imd_val_q           = imd_val_q_i;\n    logic [31:0] unused_butterfly_result;\n    assign unused_butterfly_result    = butterfly_result;\n    logic [31:0] unused_invbutterfly_result;\n    assign unused_invbutterfly_result = invbutterfly_result;\n    // RV32B result signals\n    assign bitcnt_result       = '0;\n    assign minmax_result       = '0;\n    assign pack_result         = '0;\n    assign sext_result         = '0;\n    assign singlebit_result    = '0;\n    assign rev_result          = '0;\n    assign shuffle_result      = '0;\n    assign xperm_result        = '0;\n    assign butterfly_result    = '0;\n    assign invbutterfly_result = '0;\n    assign clmul_result        = '0;\n    assign multicycle_result   = '0;\n    // RV32B support signals\n    assign imd_val_d_o         = '{default: '0};\n    assign imd_val_we_o        = '{default: '0};\n  end\n\n  ////////////////\n  // Result mux //\n  ////////////////\n\n  always_comb begin\n    result_o   = '0;\n\n    unique case (operator_i)\n      // Bitwise Logic Operations (negate: RV32B)\n      ALU_XOR,  ALU_XNOR,\n      ALU_OR,   ALU_ORN,\n      ALU_AND,  ALU_ANDN: result_o = bwlogic_result;\n\n      // Adder Operations\n      ALU_ADD,  ALU_SUB,\n      // RV32B\n      ALU_SH1ADD, ALU_SH2ADD,\n      ALU_SH3ADD: result_o = adder_result;\n\n      // Shift Operations\n      ALU_SLL,  ALU_SRL,\n      ALU_SRA,\n      // RV32B\n      ALU_SLO,  ALU_SRO: result_o = shift_result;\n\n      // Shuffle Operations (RV32B)\n      ALU_SHFL, ALU_UNSHFL: result_o = shuffle_result;\n\n      // Crossbar Permutation Operations (RV32B)\n      ALU_XPERM_N, ALU_XPERM_B, ALU_XPERM_H: result_o = xperm_result;\n\n      // Comparison Operations\n      ALU_EQ,   ALU_NE,\n      ALU_GE,   ALU_GEU,\n      ALU_LT,   ALU_LTU,\n      ALU_SLT,  ALU_SLTU: result_o = {31'h0,cmp_result};\n\n      // MinMax Operations (RV32B)\n      ALU_MIN,  ALU_MAX,\n      ALU_MINU, ALU_MAXU: result_o = minmax_result;\n\n      // Bitcount Operations (RV32B)\n      ALU_CLZ, ALU_CTZ,\n      ALU_CPOP: result_o = {26'h0, bitcnt_result};\n\n      // Pack Operations (RV32B)\n      ALU_PACK, ALU_PACKH,\n      ALU_PACKU: result_o = pack_result;\n\n      // Sign-Extend (RV32B)\n      ALU_SEXTB, ALU_SEXTH: result_o = sext_result;\n\n      // Ternary Bitmanip Operations (RV32B)\n      ALU_CMIX, ALU_CMOV,\n      ALU_FSL,  ALU_FSR,\n      // Rotate Shift (RV32B)\n      ALU_ROL, ALU_ROR,\n      // Cyclic Redundancy Checks (RV32B)\n      ALU_CRC32_W, ALU_CRC32C_W,\n      ALU_CRC32_H, ALU_CRC32C_H,\n      ALU_CRC32_B, ALU_CRC32C_B,\n      // Bit Compress / Decompress (RV32B)\n      ALU_BCOMPRESS, ALU_BDECOMPRESS: result_o = multicycle_result;\n\n      // Single-Bit Bitmanip Operations (RV32B)\n      ALU_BSET, ALU_BCLR,\n      ALU_BINV, ALU_BEXT: result_o = singlebit_result;\n\n      // General Reverse / Or-combine (RV32B)\n      ALU_GREV, ALU_GORC: result_o = rev_result;\n\n      // Bit Field Place (RV32B)\n      ALU_BFP: result_o = bfp_result;\n\n      // Carry-less Multiply Operations (RV32B)\n      ALU_CLMUL, ALU_CLMULR,\n      ALU_CLMULH: result_o = clmul_result;\n\n      default: ;\n    endcase\n  end\n\n  logic unused_shift_amt_compl;\n  assign unused_shift_amt_compl = shift_amt_compl[5];\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Branch Predictor\n *\n * This implements static branch prediction. It takes an instruction and its PC and determines if\n * it's a branch or a jump and calculates its target. For jumps it will always predict taken. For\n * branches it will predict taken if the PC offset is negative.\n *\n * This handles both compressed and uncompressed instructions. Compressed instructions must be in\n * the lower 16-bits of instr.\n *\n * The predictor is entirely combinational but takes clk/rst_n signals for use by assertions.\n */\n\n`include \"prim_assert.sv\"\n\nmodule ibex_branch_predict (\n  input  logic clk_i,\n  input  logic rst_ni,\n\n  // Instruction from fetch stage\n  input  logic [31:0] fetch_rdata_i,\n  input  logic [31:0] fetch_pc_i,\n  input  logic        fetch_valid_i,\n\n  // Prediction for supplied instruction\n  output logic        predict_branch_taken_o,\n  output logic [31:0] predict_branch_pc_o\n);\n  import ibex_pkg::*;\n\n  logic [31:0] imm_j_type;\n  logic [31:0] imm_b_type;\n  logic [31:0] imm_cj_type;\n  logic [31:0] imm_cb_type;\n\n  logic [31:0] branch_imm;\n\n  logic [31:0] instr;\n\n  logic instr_j;\n  logic instr_b;\n  logic instr_cj;\n  logic instr_cb;\n\n  logic instr_b_taken;\n\n  // Provide short internal name for fetch_rdata_i due to reduce line wrapping\n  assign instr = fetch_rdata_i;\n\n  // Extract and sign-extend to 32-bit the various immediates that may be used to calculate the\n  // target\n\n  // Uncompressed immediates\n  assign imm_j_type = { {12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n  assign imm_b_type = { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n\n  // Compressed immediates\n  assign imm_cj_type = { {20{instr[12]}}, instr[12], instr[8], instr[10:9], instr[6], instr[7],\n    instr[2], instr[11], instr[5:3], 1'b0 };\n\n  assign imm_cb_type = { {23{instr[12]}}, instr[12], instr[6:5], instr[2], instr[11:10],\n    instr[4:3], 1'b0};\n\n  // Determine if the instruction is a branch or a jump\n\n  // Uncompressed branch/jump\n  assign instr_b = opcode_e'(instr[6:0]) == OPCODE_BRANCH;\n  assign instr_j = opcode_e'(instr[6:0]) == OPCODE_JAL;\n\n  // Compressed branch/jump\n  assign instr_cb = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b110) | (instr[15:13] == 3'b111));\n  assign instr_cj = (instr[1:0] == 2'b01) & ((instr[15:13] == 3'b101) | (instr[15:13] == 3'b001));\n\n  // Select out the branch offset for target calculation based upon the instruction type\n  always_comb begin\n    branch_imm = imm_b_type;\n\n    unique case (1'b1)\n      instr_j  : branch_imm = imm_j_type;\n      instr_b  : branch_imm = imm_b_type;\n      instr_cj : branch_imm = imm_cj_type;\n      instr_cb : branch_imm = imm_cb_type;\n      default : ;\n    endcase\n  end\n\n  `ASSERT_IF(BranchInsTypeOneHot, $onehot0({instr_j, instr_b, instr_cj, instr_cb}), fetch_valid_i)\n\n  // Determine branch prediction, taken if offset is negative\n  assign instr_b_taken = (instr_b & imm_b_type[31]) | (instr_cb & imm_cb_type[31]);\n\n  // Always predict jumps taken otherwise take prediction from `instr_b_taken`\n  assign predict_branch_taken_o = fetch_valid_i & (instr_j | instr_cj | instr_b_taken);\n  // Calculate target\n  assign predict_branch_pc_o    = fetch_pc_i + branch_imm;\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Compressed instruction decoder\n *\n * Decodes RISC-V compressed instructions into their RV32 equivalent.\n * This module is fully combinatorial, clock and reset are used for\n * assertions only.\n */\n\n`include \"prim_assert.sv\"\n\nmodule ibex_compressed_decoder (\n  input  logic        clk_i,\n  input  logic        rst_ni,\n  input  logic        valid_i,\n  input  logic [31:0] instr_i,\n  output logic [31:0] instr_o,\n  output logic        is_compressed_o,\n  output logic        illegal_instr_o\n);\n  import ibex_pkg::*;\n\n  // valid_i indicates if instr_i is valid and is used for assertions only.\n  // The following signal is used to avoid possible lint errors.\n  logic unused_valid;\n  assign unused_valid = valid_i;\n\n  ////////////////////////\n  // Compressed decoder //\n  ////////////////////////\n\n  always_comb begin\n    // By default, forward incoming instruction, mark it as legal.\n    instr_o         = instr_i;\n    illegal_instr_o = 1'b0;\n\n    // Check if incoming instruction is compressed.\n    unique case (instr_i[1:0])\n      // C0\n      2'b00: begin\n        unique case (instr_i[15:13])\n          3'b000: begin\n            // c.addi4spn -> addi rd', x2, imm\n            instr_o = {2'b0, instr_i[10:7], instr_i[12:11], instr_i[5],\n                       instr_i[6], 2'b00, 5'h02, 3'b000, 2'b01, instr_i[4:2], {OPCODE_OP_IMM}};\n            if (instr_i[12:5] == 8'b0)  illegal_instr_o = 1'b1;\n          end\n\n          3'b010: begin\n            // c.lw -> lw rd', imm(rs1')\n            instr_o = {5'b0, instr_i[5], instr_i[12:10], instr_i[6],\n                       2'b00, 2'b01, instr_i[9:7], 3'b010, 2'b01, instr_i[4:2], {OPCODE_LOAD}};\n          end\n\n          3'b110: begin\n            // c.sw -> sw rs2', imm(rs1')\n            instr_o = {5'b0, instr_i[5], instr_i[12], 2'b01, instr_i[4:2],\n                       2'b01, instr_i[9:7], 3'b010, instr_i[11:10], instr_i[6],\n                       2'b00, {OPCODE_STORE}};\n          end\n\n          3'b001,\n          3'b011,\n          3'b100,\n          3'b101,\n          3'b111: begin\n            illegal_instr_o = 1'b1;\n          end\n\n          default: begin\n            illegal_instr_o = 1'b1;\n          end\n        endcase\n      end\n\n      // C1\n      //\n      // Register address checks for RV32E are performed in the regular instruction decoder.\n      // If this check fails, an illegal instruction exception is triggered and the controller\n      // writes the actual faulting instruction to mtval.\n      2'b01: begin\n        unique case (instr_i[15:13])\n          3'b000: begin\n            // c.addi -> addi rd, rd, nzimm\n            // c.nop\n            instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2],\n                       instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP_IMM}};\n          end\n\n          3'b001, 3'b101: begin\n            // 001: c.jal -> jal x1, imm\n            // 101: c.j   -> jal x0, imm\n            instr_o = {instr_i[12], instr_i[8], instr_i[10:9], instr_i[6],\n                       instr_i[7], instr_i[2], instr_i[11], instr_i[5:3],\n                       {9 {instr_i[12]}}, 4'b0, ~instr_i[15], {OPCODE_JAL}};\n          end\n\n          3'b010: begin\n            // c.li -> addi rd, x0, nzimm\n            // (c.li hints are translated into an addi hint)\n            instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 5'b0,\n                       3'b0, instr_i[11:7], {OPCODE_OP_IMM}};\n          end\n\n          3'b011: begin\n            // c.lui -> lui rd, imm\n            // (c.lui hints are translated into a lui hint)\n            instr_o = {{15 {instr_i[12]}}, instr_i[6:2], instr_i[11:7], {OPCODE_LUI}};\n\n            if (instr_i[11:7] == 5'h02) begin\n              // c.addi16sp -> addi x2, x2, nzimm\n              instr_o = {{3 {instr_i[12]}}, instr_i[4:3], instr_i[5], instr_i[2],\n                         instr_i[6], 4'b0, 5'h02, 3'b000, 5'h02, {OPCODE_OP_IMM}};\n            end\n\n            if ({instr_i[12], instr_i[6:2]} == 6'b0) illegal_instr_o = 1'b1;\n          end\n\n          3'b100: begin\n            unique case (instr_i[11:10])\n              2'b00,\n              2'b01: begin\n                // 00: c.srli -> srli rd, rd, shamt\n                // 01: c.srai -> srai rd, rd, shamt\n                // (c.srli/c.srai hints are translated into a srli/srai hint)\n                instr_o = {1'b0, instr_i[10], 5'b0, instr_i[6:2], 2'b01, instr_i[9:7],\n                           3'b101, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};\n                if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1;\n              end\n\n              2'b10: begin\n                // c.andi -> andi rd, rd, imm\n                instr_o = {{6 {instr_i[12]}}, instr_i[12], instr_i[6:2], 2'b01, instr_i[9:7],\n                           3'b111, 2'b01, instr_i[9:7], {OPCODE_OP_IMM}};\n              end\n\n              2'b11: begin\n                unique case ({instr_i[12], instr_i[6:5]})\n                  3'b000: begin\n                    // c.sub -> sub rd', rd', rs2'\n                    instr_o = {2'b01, 5'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7],\n                               3'b000, 2'b01, instr_i[9:7], {OPCODE_OP}};\n                  end\n\n                  3'b001: begin\n                    // c.xor -> xor rd', rd', rs2'\n                    instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b100,\n                               2'b01, instr_i[9:7], {OPCODE_OP}};\n                  end\n\n                  3'b010: begin\n                    // c.or  -> or  rd', rd', rs2'\n                    instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b110,\n                               2'b01, instr_i[9:7], {OPCODE_OP}};\n                  end\n\n                  3'b011: begin\n                    // c.and -> and rd', rd', rs2'\n                    instr_o = {7'b0, 2'b01, instr_i[4:2], 2'b01, instr_i[9:7], 3'b111,\n                               2'b01, instr_i[9:7], {OPCODE_OP}};\n                  end\n\n                  3'b100,\n                  3'b101,\n                  3'b110,\n                  3'b111: begin\n                    // 100: c.subw\n                    // 101: c.addw\n                    illegal_instr_o = 1'b1;\n                  end\n\n                  default: begin\n                    illegal_instr_o = 1'b1;\n                  end\n                endcase\n              end\n\n              default: begin\n                illegal_instr_o = 1'b1;\n              end\n            endcase\n          end\n\n          3'b110, 3'b111: begin\n            // 0: c.beqz -> beq rs1', x0, imm\n            // 1: c.bnez -> bne rs1', x0, imm\n            instr_o = {{4 {instr_i[12]}}, instr_i[6:5], instr_i[2], 5'b0, 2'b01,\n                       instr_i[9:7], 2'b00, instr_i[13], instr_i[11:10], instr_i[4:3],\n                       instr_i[12], {OPCODE_BRANCH}};\n          end\n\n          default: begin\n            illegal_instr_o = 1'b1;\n          end\n        endcase\n      end\n\n      // C2\n      //\n      // Register address checks for RV32E are performed in the regular instruction decoder.\n      // If this check fails, an illegal instruction exception is triggered and the controller\n      // writes the actual faulting instruction to mtval.\n      2'b10: begin\n        unique case (instr_i[15:13])\n          3'b000: begin\n            // c.slli -> slli rd, rd, shamt\n            // (c.ssli hints are translated into a slli hint)\n            instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], {OPCODE_OP_IMM}};\n            if (instr_i[12] == 1'b1)  illegal_instr_o = 1'b1; // reserved for custom extensions\n          end\n\n          3'b010: begin\n            // c.lwsp -> lw rd, imm(x2)\n            instr_o = {4'b0, instr_i[3:2], instr_i[12], instr_i[6:4], 2'b00, 5'h02,\n                       3'b010, instr_i[11:7], OPCODE_LOAD};\n            if (instr_i[11:7] == 5'b0)  illegal_instr_o = 1'b1;\n          end\n\n          3'b100: begin\n            if (instr_i[12] == 1'b0) begin\n              if (instr_i[6:2] != 5'b0) begin\n                // c.mv -> add rd/rs1, x0, rs2\n                // (c.mv hints are translated into an add hint)\n                instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], {OPCODE_OP}};\n              end else begin\n                // c.jr -> jalr x0, rd/rs1, 0\n                instr_o = {12'b0, instr_i[11:7], 3'b0, 5'b0, {OPCODE_JALR}};\n                if (instr_i[11:7] == 5'b0) illegal_instr_o = 1'b1;\n              end\n            end else begin\n              if (instr_i[6:2] != 5'b0) begin\n                // c.add -> add rd, rd, rs2\n                // (c.add hints are translated into an add hint)\n                instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], {OPCODE_OP}};\n              end else begin\n                if (instr_i[11:7] == 5'b0) begin\n                  // c.ebreak -> ebreak\n                  instr_o = {32'h00_10_00_73};\n                end else begin\n                  // c.jalr -> jalr x1, rs1, 0\n                  instr_o = {12'b0, instr_i[11:7], 3'b000, 5'b00001, {OPCODE_JALR}};\n                end\n              end\n            end\n          end\n\n          3'b110: begin\n            // c.swsp -> sw rs2, imm(x2)\n            instr_o = {4'b0, instr_i[8:7], instr_i[12], instr_i[6:2], 5'h02, 3'b010,\n                       instr_i[11:9], 2'b00, {OPCODE_STORE}};\n          end\n\n          3'b001,\n          3'b011,\n          3'b101,\n          3'b111: begin\n            illegal_instr_o = 1'b1;\n          end\n\n          default: begin\n            illegal_instr_o = 1'b1;\n          end\n        endcase\n      end\n\n      // Incoming instruction is not compressed.\n      2'b11:;\n\n      default: begin\n        illegal_instr_o = 1'b1;\n      end\n    endcase\n  end\n\n  assign is_compressed_o = (instr_i[1:0] != 2'b11);\n\n  ////////////////\n  // Assertions //\n  ////////////////\n\n  // The valid_i signal used to gate below assertions must be known.\n  `ASSERT_KNOWN(IbexInstrValidKnown, valid_i)\n\n  // Selectors must be known/valid.\n  `ASSERT(IbexInstrLSBsKnown, valid_i |->\n      !$isunknown(instr_i[1:0]))\n  `ASSERT(IbexC0Known1, (valid_i && (instr_i[1:0] == 2'b00)) |->\n      !$isunknown(instr_i[15:13]))\n  `ASSERT(IbexC1Known1, (valid_i && (instr_i[1:0] == 2'b01)) |->\n      !$isunknown(instr_i[15:13]))\n  `ASSERT(IbexC1Known2, (valid_i && (instr_i[1:0] == 2'b01) && (instr_i[15:13] == 3'b100)) |->\n      !$isunknown(instr_i[11:10]))\n  `ASSERT(IbexC1Known3, (valid_i &&\n      (instr_i[1:0] == 2'b01) && (instr_i[15:13] == 3'b100) && (instr_i[11:10] == 2'b11)) |->\n      !$isunknown({instr_i[12], instr_i[6:5]}))\n  `ASSERT(IbexC2Known1, (valid_i && (instr_i[1:0] == 2'b10)) |->\n      !$isunknown(instr_i[15:13]))\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Main controller of the processor\n */\n\n`include \"prim_assert.sv\"\n`include \"dv_fcov_macros.svh\"\n\nmodule ibex_controller #(\n  parameter bit WritebackStage  = 1'b0,\n  parameter bit BranchPredictor = 1'b0,\n  parameter bit MemECC          = 1'b0\n ) (\n  input  logic                  clk_i,\n  input  logic                  rst_ni,\n\n  output logic                  ctrl_busy_o,             // core is busy processing instrs\n\n  // decoder related signals\n  input  logic                  illegal_insn_i,          // decoder has an invalid instr\n  input  logic                  ecall_insn_i,            // decoder has ECALL instr\n  input  logic                  mret_insn_i,             // decoder has MRET instr\n  input  logic                  dret_insn_i,             // decoder has DRET instr\n  input  logic                  wfi_insn_i,              // decoder has WFI instr\n  input  logic                  ebrk_insn_i,             // decoder has EBREAK instr\n  input  logic                  csr_pipe_flush_i,        // do CSR-related pipeline flush\n\n  // instr from IF-ID pipeline stage\n  input  logic                  instr_valid_i,           // instr is valid\n  input  logic [31:0]           instr_i,                 // uncompressed instr data for mtval\n  input  logic [15:0]           instr_compressed_i,      // instr compressed data for mtval\n  input  logic                  instr_is_compressed_i,   // instr is compressed\n  input  logic                  instr_bp_taken_i,        // instr was predicted taken branch\n  input  logic                  instr_fetch_err_i,       // instr has error\n  input  logic                  instr_fetch_err_plus2_i, // instr error is x32\n  input  logic [31:0]           pc_id_i,                 // instr address\n\n  // to IF-ID pipeline stage\n  output logic                  instr_valid_clear_o,     // kill instr in IF-ID reg\n  output logic                  id_in_ready_o,           // ID stage is ready for new instr\n  output logic                  controller_run_o,        // Controller is in standard instruction\n                                                         // run mode\n  input  logic                  instr_exec_i,            // Execution control, when clear ID/EX\n                                                         // stage stops accepting instructions from\n                                                         // IF\n  // to prefetcher\n  output logic                  instr_req_o,             // start fetching instructions\n  output logic                  pc_set_o,                // jump to address set by pc_mux\n  output ibex_pkg::pc_sel_e     pc_mux_o,                // IF stage fetch address selector\n                                                         // (boot, normal, exception...)\n  output logic                  nt_branch_mispredict_o,  // Not-taken branch in ID/EX was\n                                                         // mispredicted (predicted taken)\n  output ibex_pkg::exc_pc_sel_e exc_pc_mux_o,            // IF stage selector for exception PC\n  output ibex_pkg::exc_cause_t  exc_cause_o,             // for IF stage, CSRs\n\n  // LSU\n  input  logic [31:0]           lsu_addr_last_i,         // for mtval\n  input  logic                  load_err_i,\n  input  logic                  store_err_i,\n  input  logic                  mem_resp_intg_err_i,\n  output logic                  wb_exception_o,          // Instruction in WB taking an exception\n  output logic                  id_exception_o,          // Instruction in ID taking an exception\n\n  // jump/branch signals\n  input  logic                  branch_set_i,            // branch set signal (branch definitely\n                                                         // taken)\n  input  logic                  branch_not_set_i,        // branch is definitely not taken\n  input  logic                  jump_set_i,              // jump taken set signal\n\n  // interrupt signals\n  input  logic                  csr_mstatus_mie_i,       // M-mode interrupt enable bit\n  input  logic                  irq_pending_i,           // interrupt request pending\n  input  ibex_pkg::irqs_t       irqs_i,                  // interrupt requests qualified with\n                                                         // mie CSR\n  input  logic                  irq_nm_ext_i,            // non-maskeable interrupt\n  output logic                  nmi_mode_o,              // core executing NMI handler\n\n  // debug signals\n  input  logic                  debug_req_i,\n  output ibex_pkg::dbg_cause_e  debug_cause_o,\n  output logic                  debug_csr_save_o,\n  output logic                  debug_mode_o,\n  output logic                  debug_mode_entering_o,\n  input  logic                  debug_single_step_i,\n  input  logic                  debug_ebreakm_i,\n  input  logic                  debug_ebreaku_i,\n  input  logic                  trigger_match_i,\n\n  output logic                  csr_save_if_o,\n  output logic                  csr_save_id_o,\n  output logic                  csr_save_wb_o,\n  output logic                  csr_restore_mret_id_o,\n  output logic                  csr_restore_dret_id_o,\n  output logic                  csr_save_cause_o,\n  output logic [31:0]           csr_mtval_o,\n  input  ibex_pkg::priv_lvl_e   priv_mode_i,\n\n  // stall & flush signals\n  input  logic                  stall_id_i,\n  input  logic                  stall_wb_i,\n  output logic                  flush_id_o,\n  input  logic                  ready_wb_i,\n\n  // performance monitors\n  output logic                  perf_jump_o,             // we are executing a jump\n                                                         // instruction (j, jr, jal, jalr)\n  output logic                  perf_tbranch_o           // we are executing a taken branch\n                                                         // instruction\n);\n  import ibex_pkg::*;\n\n  ctrl_fsm_e ctrl_fsm_cs, ctrl_fsm_ns;\n\n  logic nmi_mode_q, nmi_mode_d;\n  logic debug_mode_q, debug_mode_d;\n  dbg_cause_e debug_cause_d, debug_cause_q;\n  logic load_err_q, load_err_d;\n  logic store_err_q, store_err_d;\n  logic exc_req_q, exc_req_d;\n  logic illegal_insn_q, illegal_insn_d;\n\n  // Of the various exception/fault signals, which one takes priority in FLUSH and hence controls\n  // what happens next (setting exc_cause, csr_mtval etc)\n  logic instr_fetch_err_prio;\n  logic illegal_insn_prio;\n  logic ecall_insn_prio;\n  logic ebrk_insn_prio;\n  logic store_err_prio;\n  logic load_err_prio;\n\n  logic stall;\n  logic halt_if;\n  logic retain_id;\n  logic flush_id;\n  logic exc_req_lsu;\n  logic special_req;\n  logic special_req_pc_change;\n  logic special_req_flush_only;\n  logic do_single_step_d;\n  logic do_single_step_q;\n  logic enter_debug_mode_prio_d;\n  logic enter_debug_mode_prio_q;\n  logic enter_debug_mode;\n  logic ebreak_into_debug;\n  logic irq_enabled;\n  logic handle_irq;\n  logic id_wb_pending;\n\n  logic                     irq_nm;\n  logic                     irq_nm_int;\n  logic [31:0]              irq_nm_int_mtval;\n  ibex_pkg::nmi_int_cause_e irq_nm_int_cause;\n\n\n  logic [3:0] mfip_id;\n  logic       unused_irq_timer;\n\n  logic ecall_insn;\n  logic mret_insn;\n  logic dret_insn;\n  logic wfi_insn;\n  logic ebrk_insn;\n  logic csr_pipe_flush;\n  logic instr_fetch_err;\n\n`ifndef SYNTHESIS\n  // synopsys translate_off\n  // make sure we are called later so that we do not generate messages for\n  // glitches\n  always_ff @(negedge clk_i) begin\n    // print warning in case of decoding errors\n    if ((ctrl_fsm_cs == DECODE) && instr_valid_i && !instr_fetch_err_i && illegal_insn_d) begin\n      $display(\"%t: Illegal instruction (hart %0x) at PC 0x%h: 0x%h\", $time, u_ibex_core.hart_id_i,\n               pc_id_i, id_stage_i.instr_rdata_i);\n    end\n  end\n  // synopsys translate_on\n`endif\n\n  ////////////////\n  // Exceptions //\n  ////////////////\n\n  assign load_err_d  = load_err_i;\n  assign store_err_d = store_err_i;\n\n  // Decoder doesn't take instr_valid into account, factor it in here.\n  assign ecall_insn      = ecall_insn_i      & instr_valid_i;\n  assign mret_insn       = mret_insn_i       & instr_valid_i;\n  assign dret_insn       = dret_insn_i       & instr_valid_i;\n  assign wfi_insn        = wfi_insn_i        & instr_valid_i;\n  assign ebrk_insn       = ebrk_insn_i       & instr_valid_i;\n  assign csr_pipe_flush  = csr_pipe_flush_i  & instr_valid_i;\n  assign instr_fetch_err = instr_fetch_err_i & instr_valid_i;\n\n  // This is recorded in the illegal_insn_q flop to help timing.  Specifically\n  // it is needed to break the path from ibex_cs_registers/illegal_csr_insn_o\n  // to pc_set_o.  Clear when controller is in FLUSH so it won't remain set\n  // once illegal instruction is handled.\n  // illegal_insn_i only set when instr_valid_i is set.\n  assign illegal_insn_d = illegal_insn_i & (ctrl_fsm_cs != FLUSH);\n\n  `ASSERT(IllegalInsnOnlyIfInsnValid, illegal_insn_i |-> instr_valid_i)\n\n  // exception requests\n  // requests are flopped in exc_req_q.  This is cleared when controller is in\n  // the FLUSH state so the cycle following exc_req_q won't remain set for an\n  // exception request that has just been handled.\n  // All terms in this expression are qualified by instr_valid_i\n  assign exc_req_d = (ecall_insn | ebrk_insn | illegal_insn_d | instr_fetch_err) &\n                     (ctrl_fsm_cs != FLUSH);\n\n  // LSU exception requests\n  assign exc_req_lsu = store_err_i | load_err_i;\n\n  assign id_exception_o = exc_req_d & ~wb_exception_o;\n\n  // special requests: special instructions, pipeline flushes, exceptions...\n  // All terms in these expressions are qualified by instr_valid_i except exc_req_lsu which can come\n  // from the Writeback stage with no instr_valid_i from the ID stage\n\n  // These special requests only cause a pipeline flush and in particular don't cause a PC change\n  // that is outside the normal execution flow\n  assign special_req_flush_only = wfi_insn | csr_pipe_flush;\n\n  // These special requests cause a change in PC\n  assign special_req_pc_change = mret_insn | dret_insn | exc_req_d | exc_req_lsu;\n\n  // generic special request signal, applies to all instructions\n  assign special_req = special_req_pc_change | special_req_flush_only;\n\n  // Is there an instruction in ID or WB that has yet to complete?\n  assign id_wb_pending = instr_valid_i | ~ready_wb_i;\n\n  // Logic to determine which exception takes priority where multiple are possible.\n  if (WritebackStage) begin : g_wb_exceptions\n    always_comb begin\n      instr_fetch_err_prio = 0;\n      illegal_insn_prio    = 0;\n      ecall_insn_prio      = 0;\n      ebrk_insn_prio       = 0;\n      store_err_prio       = 0;\n      load_err_prio        = 0;\n\n      // Note that with the writeback stage store/load errors occur on the instruction in writeback,\n      // all other exception/faults occur on the instruction in ID/EX. The faults from writeback\n      // must take priority as that instruction is architecurally ordered before the one in ID/EX.\n      if (store_err_q) begin\n        store_err_prio = 1'b1;\n      end else if (load_err_q) begin\n        load_err_prio  = 1'b1;\n      end else if (instr_fetch_err) begin\n        instr_fetch_err_prio = 1'b1;\n      end else if (illegal_insn_q) begin\n        illegal_insn_prio = 1'b1;\n      end else if (ecall_insn) begin\n        ecall_insn_prio = 1'b1;\n      end else if (ebrk_insn) begin\n        ebrk_insn_prio = 1'b1;\n      end\n    end\n\n    // Instruction in writeback is generating an exception so instruction in ID must not execute\n    assign wb_exception_o = load_err_q | store_err_q | load_err_i | store_err_i;\n  end else begin : g_no_wb_exceptions\n    always_comb begin\n      instr_fetch_err_prio = 0;\n      illegal_insn_prio    = 0;\n      ecall_insn_prio      = 0;\n      ebrk_insn_prio       = 0;\n      store_err_prio       = 0;\n      load_err_prio        = 0;\n\n      if (instr_fetch_err) begin\n        instr_fetch_err_prio = 1'b1;\n      end else if (illegal_insn_q) begin\n        illegal_insn_prio = 1'b1;\n      end else if (ecall_insn) begin\n        ecall_insn_prio = 1'b1;\n      end else if (ebrk_insn) begin\n        ebrk_insn_prio = 1'b1;\n      end else if (store_err_q) begin\n        store_err_prio = 1'b1;\n      end else if (load_err_q) begin\n        load_err_prio  = 1'b1;\n      end\n    end\n    assign wb_exception_o = 1'b0;\n  end\n\n  `ASSERT_IF(IbexExceptionPrioOnehot,\n             $onehot({instr_fetch_err_prio,\n                      illegal_insn_prio,\n                      ecall_insn_prio,\n                      ebrk_insn_prio,\n                      store_err_prio,\n                      load_err_prio}),\n             (ctrl_fsm_cs == FLUSH) & exc_req_q)\n\n  ////////////////\n  // Interrupts //\n  ////////////////\n\n  // Internal interrupt control\n  // All internal interrupts act as an NMI and go to the NMI vector. mcause is set based upon\n  // irq_nm_int_cause.\n\n  if (MemECC) begin : g_intg_irq_int\n    logic        mem_resp_intg_err_irq_pending_q, mem_resp_intg_err_irq_pending_d;\n    logic [31:0] mem_resp_intg_err_addr_q, mem_resp_intg_err_addr_d;\n    logic        mem_resp_intg_err_irq_set, mem_resp_intg_err_irq_clear;\n    logic        entering_nmi;\n\n    assign entering_nmi = nmi_mode_d & ~nmi_mode_q;\n\n    // Load integerity error internal interrupt\n    always_comb begin\n      mem_resp_intg_err_addr_d        = mem_resp_intg_err_addr_q;\n      mem_resp_intg_err_irq_set       = 1'b0;\n      mem_resp_intg_err_irq_clear     = 1'b0;\n\n      if (mem_resp_intg_err_irq_pending_q) begin\n        // Clear ECC error interrupt when it is handled. External NMI takes a higher priority so\n        // don't clear the ECC error interrupt if an external NMI is present.\n        if (entering_nmi & !irq_nm_ext_i) begin\n          mem_resp_intg_err_irq_clear = 1'b1;\n        end\n      end else if (mem_resp_intg_err_i) begin\n        // When an ECC error is seen set the ECC error interrupt and capture the address that saw\n        // the error. If there is already an ecc error IRQ pending ignore any ECC errors coming in.\n        mem_resp_intg_err_addr_d        = lsu_addr_last_i;\n        mem_resp_intg_err_irq_set       = 1'b1;\n      end\n    end\n\n    assign mem_resp_intg_err_irq_pending_d =\n      (mem_resp_intg_err_irq_pending_q & ~mem_resp_intg_err_irq_clear) | mem_resp_intg_err_irq_set;\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        mem_resp_intg_err_irq_pending_q <= 1'b0;\n        mem_resp_intg_err_addr_q        <= '0;\n      end else begin\n        mem_resp_intg_err_irq_pending_q <= mem_resp_intg_err_irq_pending_d;\n        mem_resp_intg_err_addr_q        <= mem_resp_intg_err_addr_d;\n      end\n    end\n\n    // As integrity error is the only internal interrupt implement, set irq_nm_* signals directly\n    // within this generate block.\n    assign irq_nm_int       = mem_resp_intg_err_irq_set | mem_resp_intg_err_irq_pending_q;\n    assign irq_nm_int_cause = NMI_INT_CAUSE_ECC;\n    assign irq_nm_int_mtval = mem_resp_intg_err_addr_q;\n  end else begin : g_no_intg_irq_int\n    logic unused_mem_resp_intg_err_i;\n\n    assign unused_mem_resp_intg_err_i = mem_resp_intg_err_i;\n\n    // No integrity checking on incoming load data so no internal interrupts\n    assign irq_nm_int       = 1'b0;\n    assign irq_nm_int_cause = nmi_int_cause_e'(0);\n    assign irq_nm_int_mtval = '0;\n  end\n\n\n  // Enter debug mode due to an external debug_req_i or because the core is in\n  // single step mode (dcsr.step == 1). Single step must be qualified with\n  // instruction valid otherwise the core will immediately enter debug mode\n  // due to a recently flushed IF (or a delay in an instruction returning from\n  // memory) before it has had anything to single step.\n  // Also enter debug mode on a trigger match (hardware breakpoint)\n\n  // Set `do_single_step_q` when a valid instruction is seen outside of debug mode and core is in\n  // single step mode. The first valid instruction on debug mode entry will clear it. Hold its value\n  // when there is no valid instruction so `do_single_step_d` remains asserted until debug mode is\n  // entered.\n  assign do_single_step_d = instr_valid_i ? ~debug_mode_q & debug_single_step_i : do_single_step_q;\n  // Enter debug mode due to:\n  // * external `debug_req_i`\n  // * core in single step mode (dcsr.step == 1).\n  // * trigger match (hardware breakpoint)\n  //\n  // `debug_req_i` and `do_single_step_d` request debug mode with priority. This results in a debug\n  // mode entry even if the controller goes to `FLUSH` in preparation for handling an exception or\n  // interrupt. `trigger_match_i` is not a priority entry into debug mode as it must be ignored\n  // where control flow changes such that the instruction causing the trigger is no longer being\n  // executed.\n  assign enter_debug_mode_prio_d = (debug_req_i | do_single_step_d) & ~debug_mode_q;\n  assign enter_debug_mode = enter_debug_mode_prio_d | (trigger_match_i & ~debug_mode_q);\n\n  // Set when an ebreak should enter debug mode rather than jump to exception\n  // handler\n  assign ebreak_into_debug = priv_mode_i == PRIV_LVL_M ? debug_ebreakm_i :\n                             priv_mode_i == PRIV_LVL_U ? debug_ebreaku_i :\n                                                         1'b0;\n\n  // NMI can be produced from an external (irq_nm_i top level input) or an internal (within\n  // ibex_core) source. For internal sources the cause is specified via irq_nm_int_cause.\n  assign irq_nm = irq_nm_ext_i | irq_nm_int;\n\n  // MIE bit only applies when in M mode\n  assign irq_enabled = csr_mstatus_mie_i | (priv_mode_i == PRIV_LVL_U);\n\n  // Interrupts including NMI are ignored,\n  // - while in debug mode,\n  // - while in NMI mode (nested NMIs are not supported, NMI has highest priority and\n  //   cannot be interrupted by regular interrupts),\n  // - while single stepping.\n  assign handle_irq = ~debug_mode_q & ~debug_single_step_i & ~nmi_mode_q &\n      (irq_nm | (irq_pending_i & irq_enabled));\n\n  // generate ID of fast interrupts, highest priority to lowest ID\n  always_comb begin : gen_mfip_id\n    mfip_id = 4'd0;\n\n    for (int i = 14; i >= 0; i--) begin\n      if (irqs_i.irq_fast[i]) begin\n        mfip_id = i[3:0];\n      end\n    end\n  end\n\n  assign unused_irq_timer = irqs_i.irq_timer;\n\n  // Record the debug cause outside of the FSM\n  // The decision to enter debug_mode and the write of the cause to DCSR happen\n  // in seperate steps within the FSM. Hence, there are a small number of cycles\n  // where a change in external stimulus can cause the cause to be recorded incorrectly.\n  assign debug_cause_d = trigger_match_i                    ? DBG_CAUSE_TRIGGER :\n                         ebrk_insn_prio & ebreak_into_debug ? DBG_CAUSE_EBREAK  :\n                         debug_req_i                        ? DBG_CAUSE_HALTREQ :\n                         do_single_step_d                   ? DBG_CAUSE_STEP    :\n                                                              DBG_CAUSE_NONE ;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      debug_cause_q <= DBG_CAUSE_NONE;\n    end else begin\n      debug_cause_q <= debug_cause_d;\n    end\n  end\n\n  assign debug_cause_o = debug_cause_q;\n\n  /////////////////////\n  // Core controller //\n  /////////////////////\n\n  always_comb begin\n    // Default values\n    instr_req_o           = 1'b1;\n\n    csr_save_if_o         = 1'b0;\n    csr_save_id_o         = 1'b0;\n    csr_save_wb_o         = 1'b0;\n    csr_restore_mret_id_o = 1'b0;\n    csr_restore_dret_id_o = 1'b0;\n    csr_save_cause_o      = 1'b0;\n    csr_mtval_o           = '0;\n\n    // The values of pc_mux and exc_pc_mux are only relevant if pc_set is set. Some of the states\n    // below always set pc_mux and exc_pc_mux but only set pc_set if certain conditions are met.\n    // This avoid having to factor those conditions into the pc_mux and exc_pc_mux select signals\n "}
{"text": "   // helping timing.\n    pc_mux_o               = PC_BOOT;\n    pc_set_o               = 1'b0;\n    nt_branch_mispredict_o = 1'b0;\n\n    exc_pc_mux_o           = EXC_PC_IRQ;\n    exc_cause_o            = ExcCauseInsnAddrMisa; // = 6'h00\n\n    ctrl_fsm_ns            = ctrl_fsm_cs;\n\n    ctrl_busy_o            = 1'b1;\n\n    halt_if                = 1'b0;\n    retain_id              = 1'b0;\n    flush_id               = 1'b0;\n\n    debug_csr_save_o       = 1'b0;\n    debug_mode_d           = debug_mode_q;\n    debug_mode_entering_o  = 1'b0;\n    nmi_mode_d             = nmi_mode_q;\n\n    perf_tbranch_o         = 1'b0;\n    perf_jump_o            = 1'b0;\n\n    controller_run_o       = 1'b0;\n\n    unique case (ctrl_fsm_cs)\n      RESET: begin\n        instr_req_o   = 1'b0;\n        pc_mux_o      = PC_BOOT;\n        pc_set_o      = 1'b1;\n        ctrl_fsm_ns   = BOOT_SET;\n      end\n\n      BOOT_SET: begin\n        // copy boot address to instr fetch address\n        instr_req_o   = 1'b1;\n        pc_mux_o      = PC_BOOT;\n        pc_set_o      = 1'b1;\n\n        ctrl_fsm_ns = FIRST_FETCH;\n      end\n\n      WAIT_SLEEP: begin\n        ctrl_busy_o   = 1'b0;\n        instr_req_o   = 1'b0;\n        halt_if       = 1'b1;\n        flush_id      = 1'b1;\n        ctrl_fsm_ns   = SLEEP;\n      end\n\n      SLEEP: begin\n        // instruction in IF stage is already valid\n        // we begin execution when an interrupt has arrived\n        instr_req_o   = 1'b0;\n        halt_if       = 1'b1;\n        flush_id      = 1'b1;\n\n        // normal execution flow\n        // in debug mode or single step mode we leave immediately (wfi=nop)\n        if (irq_nm || irq_pending_i || debug_req_i || debug_mode_q || debug_single_step_i) begin\n          ctrl_fsm_ns = FIRST_FETCH;\n        end else begin\n          // Make sure clock remains disabled.\n          ctrl_busy_o = 1'b0;\n        end\n      end\n\n      FIRST_FETCH: begin\n        // Stall because of IF miss\n        if (id_in_ready_o) begin\n          ctrl_fsm_ns = DECODE;\n        end\n\n        // handle interrupts\n        if (handle_irq) begin\n          // We are handling an interrupt. Set halt_if to tell IF not to give\n          // us any more instructions before it redirects to the handler, but\n          // don't set flush_id: we must allow this instruction to complete\n          // (since it might have outstanding loads or stores).\n          ctrl_fsm_ns = IRQ_TAKEN;\n          halt_if     = 1'b1;\n        end\n\n        // enter debug mode\n        if (enter_debug_mode) begin\n          ctrl_fsm_ns = DBG_TAKEN_IF;\n          // Halt IF only for now, ID will be flushed in DBG_TAKEN_IF as the\n          // ID state is needed for correct debug mode entry\n          halt_if     = 1'b1;\n        end\n      end\n\n      DECODE: begin\n        // normal operating mode of the ID stage, in case of debug and interrupt requests,\n        // priorities are as follows (lower number == higher priority)\n        // 1. currently running (multicycle) instructions and exceptions caused by these\n        // 2. debug requests\n        // 3. interrupt requests\n\n        controller_run_o = 1'b1;\n\n        // Set PC mux for branch and jump here to ease timing. Value is only relevant if pc_set_o is\n        // also set. Setting the mux value here avoids factoring in special_req and instr_valid_i\n        // which helps timing.\n        pc_mux_o = PC_JUMP;\n\n\n        // Get ready for special instructions, exceptions, pipeline flushes\n        if (special_req) begin\n          // Halt IF but don't flush ID. This leaves a valid instruction in\n          // ID so controller can determine appropriate action in the\n          // FLUSH state.\n          retain_id = 1'b1;\n\n          // Wait for the writeback stage to either be ready for a new instruction or raise its own\n          // exception before going to FLUSH. If the instruction in writeback raises an exception it\n          // must take priority over any exception from an instruction in ID/EX. Only once the\n          // writeback stage is ready can we be certain that won't happen. Without a writeback\n          // stage ready_wb_i == 1 so the FSM will always go directly to FLUSH.\n\n          if (ready_wb_i | wb_exception_o) begin\n            ctrl_fsm_ns = FLUSH;\n          end\n        end\n\n        if (branch_set_i || jump_set_i) begin\n          // Only set the PC if the branch predictor hasn't already done the branch for us\n          pc_set_o       = BranchPredictor ? ~instr_bp_taken_i : 1'b1;\n\n          perf_tbranch_o = branch_set_i;\n          perf_jump_o    = jump_set_i;\n        end\n\n        if (BranchPredictor) begin\n          if (instr_bp_taken_i & branch_not_set_i) begin\n            // If the instruction is a branch that was predicted to be taken but was not taken\n            // signal a mispredict.\n            nt_branch_mispredict_o = 1'b1;\n          end\n        end\n\n        // If entering debug mode or handling an IRQ the core needs to wait until any instruction in\n        // ID or WB has finished executing. Stall IF during that time.\n        if ((enter_debug_mode || handle_irq) && (stall || id_wb_pending)) begin\n          halt_if = 1'b1;\n        end\n\n        if (!stall && !special_req && !id_wb_pending) begin\n          if (enter_debug_mode) begin\n            // enter debug mode\n            ctrl_fsm_ns = DBG_TAKEN_IF;\n            // Halt IF only for now, ID will be flushed in DBG_TAKEN_IF as the\n            // ID state is needed for correct debug mode entry\n            halt_if     = 1'b1;\n          end else if (handle_irq) begin\n            // handle interrupt (not in debug mode)\n            ctrl_fsm_ns = IRQ_TAKEN;\n            // We are handling an interrupt (not in debug mode). Set halt_if to\n            // tell IF not to give us any more instructions before it redirects\n            // to the handler, but don't set flush_id: we must allow this\n            // instruction to complete (since it might have outstanding loads\n            // or stores).\n            halt_if     = 1'b1;\n          end\n        end\n\n      end // DECODE\n\n      IRQ_TAKEN: begin\n        pc_mux_o     = PC_EXC;\n        exc_pc_mux_o = EXC_PC_IRQ;\n\n        if (handle_irq) begin\n          pc_set_o         = 1'b1;\n\n          csr_save_if_o    = 1'b1;\n          csr_save_cause_o = 1'b1;\n\n          // Prioritise interrupts as required by the architecture\n          if (irq_nm && !nmi_mode_q) begin\n            exc_cause_o =\n              irq_nm_ext_i ? ExcCauseIrqNm :\n                             '{irq_ext: 1'b0, irq_int: 1'b1, lower_cause: irq_nm_int_cause};\n\n            if (irq_nm_int & !irq_nm_ext_i) begin\n              csr_mtval_o = irq_nm_int_mtval;\n            end\n\n            nmi_mode_d  = 1'b1; // enter NMI mode\n          end else if (irqs_i.irq_fast != 15'b0) begin\n            // generate exception cause ID from fast interrupt ID:\n            // - first bit distinguishes interrupts from exceptions,\n            // - second bit adds 16 to fast interrupt ID\n            // for example ExcCauseIrqFast0 = {1'b1, 5'd16}\n            exc_cause_o = '{irq_ext: 1'b1, irq_int: 1'b0, lower_cause: {1'b1, mfip_id}};\n          end else if (irqs_i.irq_external) begin\n            exc_cause_o = ExcCauseIrqExternalM;\n          end else if (irqs_i.irq_software) begin\n            exc_cause_o = ExcCauseIrqSoftwareM;\n          end else begin // irqs_i.irq_timer\n            exc_cause_o = ExcCauseIrqTimerM;\n          end\n        end\n\n        ctrl_fsm_ns = DECODE;\n      end\n\n      DBG_TAKEN_IF: begin\n        pc_mux_o     = PC_EXC;\n        exc_pc_mux_o = EXC_PC_DBD;\n\n        // enter debug mode and save PC in IF to dpc\n        // jump to debug exception handler in debug memory\n        flush_id         = 1'b1;\n        pc_set_o         = 1'b1;\n\n        csr_save_if_o    = 1'b1;\n        debug_csr_save_o = 1'b1;\n\n        csr_save_cause_o = 1'b1;\n\n        // enter debug mode\n        debug_mode_d          = 1'b1;\n        debug_mode_entering_o = 1'b1;\n\n        ctrl_fsm_ns  = DECODE;\n      end\n\n      DBG_TAKEN_ID: begin\n        // enter debug mode and save PC in ID to dpc, used when encountering\n        // 1. EBREAK during debug mode\n        // 2. EBREAK with forced entry into debug mode (ebreakm or ebreaku set).\n        // regular ebreak's go through FLUSH.\n        //\n        // for 1. do not update dcsr and dpc, for 2. do so\n        // jump to debug exception handler in debug memory\n        flush_id      = 1'b1;\n        pc_mux_o      = PC_EXC;\n        pc_set_o      = 1'b1;\n        exc_pc_mux_o  = EXC_PC_DBD;\n\n        // update dcsr and dpc\n        if (ebreak_into_debug && !debug_mode_q) begin // ebreak with forced entry\n\n          // dpc (set to the address of the EBREAK, i.e. set to PC in ID stage)\n          csr_save_cause_o = 1'b1;\n          csr_save_id_o    = 1'b1;\n\n          // dcsr\n          debug_csr_save_o = 1'b1;\n        end\n\n        // enter debug mode\n        debug_mode_d          = 1'b1;\n        debug_mode_entering_o = 1'b1;\n\n        ctrl_fsm_ns  = DECODE;\n      end\n\n      FLUSH: begin\n        // flush the pipeline\n        halt_if     = 1'b1;\n        flush_id    = 1'b1;\n        ctrl_fsm_ns = DECODE;\n\n        // As pc_mux and exc_pc_mux can take various values in this state they aren't set early\n        // here.\n\n        // exceptions: set exception PC, save PC and exception cause\n        // exc_req_lsu is high for one clock cycle only (in DECODE)\n        if (exc_req_q || store_err_q || load_err_q) begin\n          pc_set_o         = 1'b1;\n          pc_mux_o         = PC_EXC;\n          exc_pc_mux_o     = debug_mode_q ? EXC_PC_DBG_EXC : EXC_PC_EXC;\n\n          if (WritebackStage) begin : g_writeback_mepc_save\n            // With the writeback stage present whether an instruction accessing memory will cause\n            // an exception is only known when it is in writeback. So when taking such an exception\n            // epc must come from writeback.\n            csr_save_id_o  = ~(store_err_q | load_err_q);\n            csr_save_wb_o  = store_err_q | load_err_q;\n          end else begin : g_no_writeback_mepc_save\n            csr_save_id_o  = 1'b0;\n          end\n\n          csr_save_cause_o = 1'b1;\n\n          // Exception/fault prioritisation logic will have set exactly 1 X_prio signal\n          unique case (1'b1)\n            instr_fetch_err_prio: begin\n              exc_cause_o = ExcCauseInstrAccessFault;\n              csr_mtval_o = instr_fetch_err_plus2_i ? (pc_id_i + 32'd2) : pc_id_i;\n            end\n            illegal_insn_prio: begin\n              exc_cause_o = ExcCauseIllegalInsn;\n              csr_mtval_o = instr_is_compressed_i ? {16'b0, instr_compressed_i} : instr_i;\n            end\n            ecall_insn_prio: begin\n              exc_cause_o = (priv_mode_i == PRIV_LVL_M) ? ExcCauseEcallMMode :\n                                                          ExcCauseEcallUMode;\n            end\n            ebrk_insn_prio: begin\n              if (debug_mode_q | ebreak_into_debug) begin\n                // EBREAK enters debug mode when dcsr.ebreakm or dcsr.ebreaku is set and we're in\n                // M or U mode respectively. If we're already in debug mode we re-enter debug mode.\n\n                pc_set_o         = 1'b0;\n                csr_save_id_o    = 1'b0;\n                csr_save_cause_o = 1'b0;\n                ctrl_fsm_ns      = DBG_TAKEN_ID;\n                flush_id         = 1'b0;\n              end else begin\n                // If EBREAK won't enter debug mode (dcsr.ebreakm/u not set) then raise a breakpoint\n                // exception.\n                exc_cause_o      = ExcCauseBreakpoint;\n              end\n            end\n            store_err_prio: begin\n              exc_cause_o = ExcCauseStoreAccessFault;\n              csr_mtval_o = lsu_addr_last_i;\n            end\n            load_err_prio: begin\n              exc_cause_o = ExcCauseLoadAccessFault;\n              csr_mtval_o = lsu_addr_last_i;\n            end\n            default: ;\n          endcase\n        end else begin\n          // special instructions and pipeline flushes\n          if (mret_insn) begin\n            pc_mux_o              = PC_ERET;\n            pc_set_o              = 1'b1;\n            csr_restore_mret_id_o = 1'b1;\n            if (nmi_mode_q) begin\n              nmi_mode_d          = 1'b0; // exit NMI mode\n            end\n          end else if (dret_insn) begin\n            pc_mux_o              = PC_DRET;\n            pc_set_o              = 1'b1;\n            debug_mode_d          = 1'b0;\n            csr_restore_dret_id_o = 1'b1;\n          end else if (wfi_insn) begin\n            ctrl_fsm_ns           = WAIT_SLEEP;\n          end\n        end // exc_req_q\n\n        // Entering debug mode due to either single step or debug_req. Ensure\n        // registers are set for exception but then enter debug handler rather\n        // than exception handler\n        // Leave all other signals as is to ensure CSRs and PC get set as if\n        // core was entering exception handler, entry to debug mode will then\n        // see the appropriate state and setup dpc correctly.\n\n        // If an EBREAK instruction is causing us to enter debug mode on the\n        // same cycle as a debug_req or single step, honor the EBREAK and\n        // proceed to DBG_TAKEN_ID, as it has the highest priority.\n        //\n        // cause==EBREAK    -> prio 3 (highest)\n        // cause==debug_req -> prio 2\n        // cause==step      -> prio 1 (lowest)\n        if (enter_debug_mode_prio_q && !(ebrk_insn_prio && ebreak_into_debug)) begin\n          ctrl_fsm_ns = DBG_TAKEN_IF;\n        end\n      end // FLUSH\n\n      default: begin\n        instr_req_o = 1'b0;\n        ctrl_fsm_ns = RESET;\n      end\n    endcase\n\n    if (~instr_exec_i) begin\n      // Hold halt_if high when instr_exec_i is low to stop accepting instructions from the IF stage\n      halt_if = 1'b1;\n    end\n  end\n\n  assign flush_id_o = flush_id;\n\n  // signal to CSR when in debug mode\n  assign debug_mode_o = debug_mode_q;\n\n  // signal to CSR when in an NMI handler (for nested exception handling)\n  assign nmi_mode_o = nmi_mode_q;\n\n  ///////////////////\n  // Stall control //\n  ///////////////////\n\n  // If high current instruction cannot complete this cycle. Either because it needs more cycles to\n  // finish (stall_id_i) or because the writeback stage cannot accept it yet (stall_wb_i). If there\n  // is no writeback stage stall_wb_i is a constant 0.\n  assign stall = stall_id_i | stall_wb_i;\n\n  // signal to IF stage that ID stage is ready for next instr\n  assign id_in_ready_o = ~stall & ~halt_if & ~retain_id;\n\n  // kill instr in IF-ID pipeline reg that are done, or if a\n  // multicycle instr causes an exception for example\n  // retain_id is another kind of stall, where the instr_valid bit must remain\n  // set (unless flush_id is set also). It cannot be factored directly into\n  // stall as this causes a combinational loop.\n  assign instr_valid_clear_o = ~(stall | retain_id) | flush_id;\n\n  // update registers\n  always_ff @(posedge clk_i or negedge rst_ni) begin : update_regs\n    if (!rst_ni) begin\n      ctrl_fsm_cs             <= RESET;\n      nmi_mode_q              <= 1'b0;\n      do_single_step_q        <= 1'b0;\n      debug_mode_q            <= 1'b0;\n      enter_debug_mode_prio_q <= 1'b0;\n      load_err_q              <= 1'b0;\n      store_err_q             <= 1'b0;\n      exc_req_q               <= 1'b0;\n      illegal_insn_q          <= 1'b0;\n    end else begin\n      ctrl_fsm_cs             <= ctrl_fsm_ns;\n      nmi_mode_q              <= nmi_mode_d;\n      do_single_step_q        <= do_single_step_d;\n      debug_mode_q            <= debug_mode_d;\n      enter_debug_mode_prio_q <= enter_debug_mode_prio_d;\n      load_err_q              <= load_err_d;\n      store_err_q             <= store_err_d;\n      exc_req_q               <= exc_req_d;\n      illegal_insn_q          <= illegal_insn_d;\n    end\n  end\n\n  `ASSERT(PipeEmptyOnIrq, ctrl_fsm_cs != IRQ_TAKEN & ctrl_fsm_ns == IRQ_TAKEN |->\n    ~instr_valid_i & ready_wb_i)\n\n  //////////\n  // FCOV //\n  //////////\n\n  `DV_FCOV_SIGNAL(logic, all_debug_req, debug_req_i || debug_mode_q || debug_single_step_i)\n  `DV_FCOV_SIGNAL(logic, debug_wakeup, (ctrl_fsm_cs == SLEEP) & (ctrl_fsm_ns == FIRST_FETCH) &\n                                        (debug_req_i || debug_mode_q || debug_single_step_i))\n  `DV_FCOV_SIGNAL(logic, interrupt_taken, (ctrl_fsm_cs != IRQ_TAKEN) & (ctrl_fsm_ns == IRQ_TAKEN))\n  `DV_FCOV_SIGNAL(logic, debug_entry_if,\n      (ctrl_fsm_cs != DBG_TAKEN_IF) & (ctrl_fsm_ns == DBG_TAKEN_IF))\n  `DV_FCOV_SIGNAL(logic, debug_entry_id,\n      (ctrl_fsm_cs != DBG_TAKEN_ID) & (ctrl_fsm_ns == DBG_TAKEN_ID))\n  `DV_FCOV_SIGNAL(logic, pipe_flush, (ctrl_fsm_cs != FLUSH) & (ctrl_fsm_ns == FLUSH))\n  `DV_FCOV_SIGNAL(logic, debug_req, debug_req_i & ~debug_mode_q)\n  `DV_FCOV_SIGNAL(logic, debug_single_step_taken, do_single_step_d & ~do_single_step_q)\n\n  ////////////////\n  // Assertions //\n  ////////////////\n\n  `ASSERT(AlwaysInstrClearOnMispredict, nt_branch_mispredict_o |-> instr_valid_clear_o)\n\n  // Selectors must be known/valid.\n  `ASSERT(IbexCtrlStateValid, ctrl_fsm_cs inside {\n      RESET, BOOT_SET, WAIT_SLEEP, SLEEP, FIRST_FETCH, DECODE, FLUSH,\n      IRQ_TAKEN, DBG_TAKEN_IF, DBG_TAKEN_ID})\n\n  `ifdef INC_ASSERT\n    // If something that causes a jump into an exception handler is seen that jump must occur before\n    // the next instruction executes. The logic tracks whether a jump into an exception handler is\n    // expected. Assertions check the jump occurs.\n\n    logic exception_req, exception_req_pending, exception_req_accepted, exception_req_done;\n    logic exception_pc_set, seen_exception_pc_set, expect_exception_pc_set;\n    logic exception_req_needs_pc_set;\n\n    assign exception_req = (special_req | enter_debug_mode | handle_irq);\n    // Any exception rquest will cause a transition out of DECODE, once the controller transitions\n    // back into DECODE we're done handling the request.\n    assign exception_req_done =\n      exception_req_pending & (ctrl_fsm_cs != DECODE) & (ctrl_fsm_ns == DECODE);\n\n    assign exception_req_needs_pc_set = enter_debug_mode | handle_irq | special_req_pc_change;\n\n    // An exception PC set uses specific PC types\n    assign exception_pc_set =\n      exception_req_pending & (pc_set_o & (pc_mux_o inside {PC_EXC, PC_ERET, PC_DRET}));\n\n    always @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        exception_req_pending   <= 1'b0;\n        exception_req_accepted  <= 1'b0;\n        expect_exception_pc_set <= 1'b0;\n        seen_exception_pc_set   <= 1'b0;\n      end else begin\n        // Keep `exception_req_pending` asserted once an exception_req is seen until it is done\n        exception_req_pending <= (exception_req_pending | exception_req) & ~exception_req_done;\n\n        // The exception req has been accepted once the controller transitions out of decode\n        exception_req_accepted <= (exception_req_accepted & ~exception_req_done) |\n          (exception_req & ctrl_fsm_ns != DECODE);\n\n        // Set `expect_exception_pc_set` if exception req needs one and keep it asserted until\n        // exception req is done\n        expect_exception_pc_set <= (expect_exception_pc_set | exception_req_needs_pc_set) &\n          ~exception_req_done;\n\n        // Keep `seen_exception_pc_set` asserted once an exception PC set is seen until the\n        // exception req is done\n        seen_exception_pc_set <= (seen_exception_pc_set | exception_pc_set) & ~exception_req_done;\n      end\n    end\n\n    // Once an exception request has been accepted it must be handled before controller goes back to\n    // DECODE\n    `ASSERT(IbexNoDoubleExceptionReq, exception_req_accepted |-> ctrl_fsm_cs != DECODE)\n\n    // Only signal ready, allowing a new instruction into ID, if there is no exception request\n    // pending or it is done this cycle.\n    `ASSERT(IbexDontSkipExceptionReq,\n      id_in_ready_o |-> !exception_req_pending || exception_req_done)\n\n    // Once a PC set has been performed for an exception request there must not be any other\n    // excepting those to move into debug "}
{"text": "mode.\n    `ASSERT(IbexNoDoubleSpecialReqPCSet,\n      seen_exception_pc_set &&\n        !((ctrl_fsm_cs inside {DBG_TAKEN_IF, DBG_TAKEN_ID}) &&\n          (pc_mux_o == PC_EXC) && (exc_pc_mux_o == EXC_PC_DBD))\n      |-> !pc_set_o)\n\n    // When an exception request is done there must have been an appropriate PC set (either this\n    // cycle or a previous one).\n    `ASSERT(IbexSetExceptionPCOnSpecialReqIfExpected,\n      exception_req_pending && expect_exception_pc_set && exception_req_done |->\n      seen_exception_pc_set || exception_pc_set)\n\n    // If there's a pending exception req that doesn't need a PC set we must not see one\n    `ASSERT(IbexNoPCSetOnSpecialReqIfNotExpected,\n      exception_req_pending && !expect_exception_pc_set |-> ~pc_set_o)\n  `endif\n\n  `ifdef RVFI\n    // Workaround for internal verilator error when using hierarchical refers to calcuate this\n    // directly in ibex_core\n    logic rvfi_flush_next;\n\n    assign rvfi_flush_next = ctrl_fsm_ns == FLUSH;\n  `endif\nendmodule\n"}
{"text": "ibex_pkg.sv\nibex_alu.sv\nibex_compressed_decoder.sv\nibex_controller.sv\nibex_counter.sv\nibex_cs_registers.sv\nibex_decoder.sv\nibex_ex_block.sv\nibex_id_stage.sv\nibex_if_stage.sv\nibex_load_store_unit.sv\nibex_multdiv_slow.sv\nibex_multdiv_fast.sv\nibex_prefetch_buffer.sv\nibex_fetch_fifo.sv\nibex_register_file_ff.sv\nibex_core.sv\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n`ifdef RISCV_FORMAL\n  `define RVFI\n`endif\n\n`include \"prim_assert.sv\"\n`include \"dv_fcov_macros.svh\"\n\n/**\n * Top level module of the ibex RISC-V core\n */\nmodule ibex_core import ibex_pkg::*; #(\n  parameter bit          PMPEnable         = 1'b0,\n  parameter int unsigned PMPGranularity    = 0,\n  parameter int unsigned PMPNumRegions     = 4,\n  parameter int unsigned MHPMCounterNum    = 0,\n  parameter int unsigned MHPMCounterWidth  = 40,\n  parameter bit          RV32E             = 1'b0,\n  parameter rv32m_e      RV32M             = RV32MFast,\n  parameter rv32b_e      RV32B             = RV32BNone,\n  parameter bit          BranchTargetALU   = 1'b0,\n  parameter bit          WritebackStage    = 1'b0,\n  parameter bit          ICache            = 1'b0,\n  parameter bit          ICacheECC         = 1'b0,\n  parameter int unsigned BusSizeECC        = BUS_SIZE,\n  parameter int unsigned TagSizeECC        = IC_TAG_SIZE,\n  parameter int unsigned LineSizeECC       = IC_LINE_SIZE,\n  parameter bit          BranchPredictor   = 1'b0,\n  parameter bit          DbgTriggerEn      = 1'b0,\n  parameter int unsigned DbgHwBreakNum     = 1,\n  parameter bit          ResetAll          = 1'b0,\n  parameter lfsr_seed_t  RndCnstLfsrSeed   = RndCnstLfsrSeedDefault,\n  parameter lfsr_perm_t  RndCnstLfsrPerm   = RndCnstLfsrPermDefault,\n  parameter bit          SecureIbex        = 1'b0,\n  parameter bit          DummyInstructions = 1'b0,\n  parameter bit          RegFileECC        = 1'b0,\n  parameter int unsigned RegFileDataWidth  = 32,\n  parameter bit          MemECC            = 1'b0,\n  parameter int unsigned MemDataWidth      = MemECC ? 32 + 7 : 32,\n  parameter int unsigned DmHaltAddr        = 32'h1A110800,\n  parameter int unsigned DmExceptionAddr   = 32'h1A110808\n) (\n  // Clock and Reset\n  input  logic                         clk_i,\n  // Internally generated resets in ibex_lockstep cause IMPERFECTSCH warnings.\n  // TODO: Remove when upgrading Verilator #2134.\n  /* verilator lint_off IMPERFECTSCH */\n  input  logic                         rst_ni,\n  /* verilator lint_on IMPERFECTSCH */\n\n  input  logic [31:0]                  hart_id_i,\n  input  logic [31:0]                  boot_addr_i,\n\n  // Instruction memory interface\n  output logic                         instr_req_o,\n  input  logic                         instr_gnt_i,\n  input  logic                         instr_rvalid_i,\n  output logic [31:0]                  instr_addr_o,\n  input  logic [MemDataWidth-1:0]      instr_rdata_i,\n  input  logic                         instr_err_i,\n\n  // Data memory interface\n  output logic                         data_req_o,\n  input  logic                         data_gnt_i,\n  input  logic                         data_rvalid_i,\n  output logic                         data_we_o,\n  output logic [3:0]                   data_be_o,\n  output logic [31:0]                  data_addr_o,\n  output logic [MemDataWidth-1:0]      data_wdata_o,\n  input  logic [MemDataWidth-1:0]      data_rdata_i,\n  input  logic                         data_err_i,\n\n  // Register file interface\n  output logic                         dummy_instr_id_o,\n  output logic                         dummy_instr_wb_o,\n  output logic [4:0]                   rf_raddr_a_o,\n  output logic [4:0]                   rf_raddr_b_o,\n  output logic [4:0]                   rf_waddr_wb_o,\n  output logic                         rf_we_wb_o,\n  output logic [RegFileDataWidth-1:0]  rf_wdata_wb_ecc_o,\n  input  logic [RegFileDataWidth-1:0]  rf_rdata_a_ecc_i,\n  input  logic [RegFileDataWidth-1:0]  rf_rdata_b_ecc_i,\n\n  // RAMs interface\n  output logic [IC_NUM_WAYS-1:0]       ic_tag_req_o,\n  output logic                         ic_tag_write_o,\n  output logic [IC_INDEX_W-1:0]        ic_tag_addr_o,\n  output logic [TagSizeECC-1:0]        ic_tag_wdata_o,\n  input  logic [TagSizeECC-1:0]        ic_tag_rdata_i [IC_NUM_WAYS],\n  output logic [IC_NUM_WAYS-1:0]       ic_data_req_o,\n  output logic                         ic_data_write_o,\n  output logic [IC_INDEX_W-1:0]        ic_data_addr_o,\n  output logic [LineSizeECC-1:0]       ic_data_wdata_o,\n  input  logic [LineSizeECC-1:0]       ic_data_rdata_i [IC_NUM_WAYS],\n  input  logic                         ic_scr_key_valid_i,\n  output logic                         ic_scr_key_req_o,\n\n  // Interrupt inputs\n  input  logic                         irq_software_i,\n  input  logic                         irq_timer_i,\n  input  logic                         irq_external_i,\n  input  logic [14:0]                  irq_fast_i,\n  input  logic                         irq_nm_i,       // non-maskeable interrupt\n  output logic                         irq_pending_o,\n\n  // Debug Interface\n  input  logic                         debug_req_i,\n  output crash_dump_t                  crash_dump_o,\n  // SEC_CM: EXCEPTION.CTRL_FLOW.LOCAL_ESC\n  // SEC_CM: EXCEPTION.CTRL_FLOW.GLOBAL_ESC\n  output logic                         double_fault_seen_o,\n\n  // RISC-V Formal Interface\n  // Does not comply with the coding standards of _i/_o suffixes, but follows\n  // the convention of RISC-V Formal Interface Specification.\n`ifdef RVFI\n  output logic                         rvfi_valid,\n  output logic [63:0]                  rvfi_order,\n  output logic [31:0]                  rvfi_insn,\n  output logic                         rvfi_trap,\n  output logic                         rvfi_halt,\n  output logic                         rvfi_intr,\n  output logic [ 1:0]                  rvfi_mode,\n  output logic [ 1:0]                  rvfi_ixl,\n  output logic [ 4:0]                  rvfi_rs1_addr,\n  output logic [ 4:0]                  rvfi_rs2_addr,\n  output logic [ 4:0]                  rvfi_rs3_addr,\n  output logic [31:0]                  rvfi_rs1_rdata,\n  output logic [31:0]                  rvfi_rs2_rdata,\n  output logic [31:0]                  rvfi_rs3_rdata,\n  output logic [ 4:0]                  rvfi_rd_addr,\n  output logic [31:0]                  rvfi_rd_wdata,\n  output logic [31:0]                  rvfi_pc_rdata,\n  output logic [31:0]                  rvfi_pc_wdata,\n  output logic [31:0]                  rvfi_mem_addr,\n  output logic [ 3:0]                  rvfi_mem_rmask,\n  output logic [ 3:0]                  rvfi_mem_wmask,\n  output logic [31:0]                  rvfi_mem_rdata,\n  output logic [31:0]                  rvfi_mem_wdata,\n  output logic [31:0]                  rvfi_ext_mip,\n  output logic                         rvfi_ext_nmi,\n  output logic                         rvfi_ext_nmi_int,\n  output logic                         rvfi_ext_debug_req,\n  output logic                         rvfi_ext_debug_mode,\n  output logic                         rvfi_ext_rf_wr_suppress,\n  output logic [63:0]                  rvfi_ext_mcycle,\n  output logic [31:0]                  rvfi_ext_mhpmcounters [10],\n  output logic [31:0]                  rvfi_ext_mhpmcountersh [10],\n  output logic                         rvfi_ext_ic_scr_key_valid,\n  output logic                         rvfi_ext_irq_valid,\n  `endif\n\n  // CPU Control Signals\n  // SEC_CM: FETCH.CTRL.LC_GATED\n  input  ibex_mubi_t                   fetch_enable_i,\n  output logic                         alert_minor_o,\n  output logic                         alert_major_internal_o,\n  output logic                         alert_major_bus_o,\n  output ibex_mubi_t                   core_busy_o\n);\n\n  localparam int unsigned PMPNumChan      = 3;\n  // SEC_CM: CORE.DATA_REG_SW.SCA\n  localparam bit          DataIndTiming     = SecureIbex;\n  localparam bit          PCIncrCheck       = SecureIbex;\n  localparam bit          ShadowCSR         = 1'b0;\n\n  // IF/ID signals\n  logic        dummy_instr_id;\n  logic        instr_valid_id;\n  logic        instr_new_id;\n  logic [31:0] instr_rdata_id;                 // Instruction sampled inside IF stage\n  logic [31:0] instr_rdata_alu_id;             // Instruction sampled inside IF stage (replicated to\n                                               // ease fan-out)\n  logic [15:0] instr_rdata_c_id;               // Compressed instruction sampled inside IF stage\n  logic        instr_is_compressed_id;\n  logic        instr_perf_count_id;\n  logic        instr_bp_taken_id;\n  logic        instr_fetch_err;                // Bus error on instr fetch\n  logic        instr_fetch_err_plus2;          // Instruction error is misaligned\n  logic        illegal_c_insn_id;              // Illegal compressed instruction sent to ID stage\n  logic [31:0] pc_if;                          // Program counter in IF stage\n  logic [31:0] pc_id;                          // Program counter in ID stage\n  logic [31:0] pc_wb;                          // Program counter in WB stage\n  logic [33:0] imd_val_d_ex[2];                // Intermediate register for multicycle Ops\n  logic [33:0] imd_val_q_ex[2];                // Intermediate register for multicycle Ops\n  logic [1:0]  imd_val_we_ex;\n\n  logic        data_ind_timing;\n  logic        dummy_instr_en;\n  logic [2:0]  dummy_instr_mask;\n  logic        dummy_instr_seed_en;\n  logic [31:0] dummy_instr_seed;\n  logic        icache_enable;\n  logic        icache_inval;\n  logic        icache_ecc_error;\n  logic        pc_mismatch_alert;\n  logic        csr_shadow_err;\n\n  logic        instr_first_cycle_id;\n  logic        instr_valid_clear;\n  logic        pc_set;\n  logic        nt_branch_mispredict;\n  logic [31:0] nt_branch_addr;\n  pc_sel_e     pc_mux_id;                      // Mux selector for next PC\n  exc_pc_sel_e exc_pc_mux_id;                  // Mux selector for exception PC\n  exc_cause_t  exc_cause;                      // Exception cause\n\n  logic        instr_intg_err;\n  logic        lsu_load_err;\n  logic        lsu_store_err;\n  logic        lsu_load_resp_intg_err;\n  logic        lsu_store_resp_intg_err;\n\n  // LSU signals\n  logic        lsu_addr_incr_req;\n  logic [31:0] lsu_addr_last;\n\n  // Jump and branch target and decision (EX->IF)\n  logic [31:0] branch_target_ex;\n  logic        branch_decision;\n\n  // Core busy signals\n  logic        ctrl_busy;\n  logic        if_busy;\n  logic        lsu_busy;\n\n  // Register File\n  logic [4:0]  rf_raddr_a;\n  logic [31:0] rf_rdata_a;\n  logic [4:0]  rf_raddr_b;\n  logic [31:0] rf_rdata_b;\n  logic        rf_ren_a;\n  logic        rf_ren_b;\n  logic [4:0]  rf_waddr_wb;\n  logic [31:0] rf_wdata_wb;\n  // Writeback register write data that can be used on the forwarding path (doesn't factor in memory\n  // read data as this is too late for the forwarding path)\n  logic [31:0] rf_wdata_fwd_wb;\n  logic [31:0] rf_wdata_lsu;\n  logic        rf_we_wb;\n  logic        rf_we_lsu;\n  logic        rf_ecc_err_comb;\n\n  logic [4:0]  rf_waddr_id;\n  logic [31:0] rf_wdata_id;\n  logic        rf_we_id;\n  logic        rf_rd_a_wb_match;\n  logic        rf_rd_b_wb_match;\n\n  // ALU Control\n  alu_op_e     alu_operator_ex;\n  logic [31:0] alu_operand_a_ex;\n  logic [31:0] alu_operand_b_ex;\n\n  logic [31:0] bt_a_operand;\n  logic [31:0] bt_b_operand;\n\n  logic [31:0] alu_adder_result_ex;    // Used to forward computed address to LSU\n  logic [31:0] result_ex;\n\n  // Multiplier Control\n  logic        mult_en_ex;\n  logic        div_en_ex;\n  logic        mult_sel_ex;\n  logic        div_sel_ex;\n  md_op_e      multdiv_operator_ex;\n  logic [1:0]  multdiv_signed_mode_ex;\n  logic [31:0] multdiv_operand_a_ex;\n  logic [31:0] multdiv_operand_b_ex;\n  logic        multdiv_ready_id;\n\n  // CSR control\n  logic        csr_access;\n  csr_op_e     csr_op;\n  logic        csr_op_en;\n  csr_num_e    csr_addr;\n  logic [31:0] csr_rdata;\n  logic [31:0] csr_wdata;\n  logic        illegal_csr_insn_id;    // CSR access to non-existent register,\n                                       // with wrong priviledge level,\n                                       // or missing write permissions\n\n  // Data Memory Control\n  logic        lsu_we;\n  logic [1:0]  lsu_type;\n  logic        lsu_sign_ext;\n  logic        lsu_req;\n  logic [31:0] lsu_wdata;\n  logic        lsu_req_done;\n\n  // stall control\n  logic        id_in_ready;\n  logic        ex_valid;\n\n  logic        lsu_resp_valid;\n  logic        lsu_resp_err;\n\n  // Signals between instruction core interface and pipe (if and id stages)\n  logic        instr_req_int;          // Id stage asserts a req to instruction core interface\n  logic        instr_req_gated;\n  logic        instr_exec;\n\n  // Writeback stage\n  logic           en_wb;\n  wb_instr_type_e instr_type_wb;\n  logic           ready_wb;\n  logic           rf_write_wb;\n  logic           outstanding_load_wb;\n  logic           outstanding_store_wb;\n  logic           dummy_instr_wb;\n\n  // Interrupts\n  logic        nmi_mode;\n  irqs_t       irqs;\n  logic        csr_mstatus_mie;\n  logic [31:0] csr_mepc, csr_depc;\n\n  // PMP signals\n  logic [33:0]  csr_pmp_addr [PMPNumRegions];\n  pmp_cfg_t     csr_pmp_cfg  [PMPNumRegions];\n  pmp_mseccfg_t csr_pmp_mseccfg;\n  logic         pmp_req_err  [PMPNumChan];\n  logic         data_req_out;\n\n  logic        csr_save_if;\n  logic        csr_save_id;\n  logic        csr_save_wb;\n  logic        csr_restore_mret_id;\n  logic        csr_restore_dret_id;\n  logic        csr_save_cause;\n  logic        csr_mtvec_init;\n  logic [31:0] csr_mtvec;\n  logic [31:0] csr_mtval;\n  logic        csr_mstatus_tw;\n  priv_lvl_e   priv_mode_id;\n  priv_lvl_e   priv_mode_lsu;\n\n  // debug mode and dcsr configuration\n  logic        debug_mode;\n  logic        debug_mode_entering;\n  dbg_cause_e  debug_cause;\n  logic        debug_csr_save;\n  logic        debug_single_step;\n  logic        debug_ebreakm;\n  logic        debug_ebreaku;\n  logic        trigger_match;\n\n  // signals relating to instruction movements between pipeline stages\n  // used by performance counters and RVFI\n  logic        instr_id_done;\n  logic        instr_done_wb;\n\n  logic        perf_instr_ret_wb;\n  logic        perf_instr_ret_compressed_wb;\n  logic        perf_instr_ret_wb_spec;\n  logic        perf_instr_ret_compressed_wb_spec;\n  logic        perf_iside_wait;\n  logic        perf_dside_wait;\n  logic        perf_mul_wait;\n  logic        perf_div_wait;\n  logic        perf_jump;\n  logic        perf_branch;\n  logic        perf_tbranch;\n  logic        perf_load;\n  logic        perf_store;\n\n  // for RVFI\n  logic        illegal_insn_id, unused_illegal_insn_id; // ID stage sees an illegal instruction\n\n  //////////////////////\n  // Clock management //\n  //////////////////////\n\n  // Before going to sleep, wait for I- and D-side\n  // interfaces to finish ongoing operations.\n  if (SecureIbex) begin : g_core_busy_secure\n    // For secure Ibex, the individual bits of core_busy_o are generated from different copies of\n    // the various busy signal.\n    localparam int unsigned NumBusySignals = 3;\n    localparam int unsigned NumBusyBits = $bits(ibex_mubi_t) * NumBusySignals;\n    logic [NumBusyBits-1:0] busy_bits_buf;\n    prim_buf #(\n      .Width(NumBusyBits)\n    ) u_fetch_enable_buf (\n      .in_i ({$bits(ibex_mubi_t){ctrl_busy, if_busy, lsu_busy}}),\n      .out_o(busy_bits_buf)\n    );\n\n    // Set core_busy_o to IbexMuBiOn if even a single input is high.\n    for (genvar i = 0; i < $bits(ibex_mubi_t); i++) begin : g_core_busy_bits\n      if (IbexMuBiOn[i] == 1'b1) begin : g_pos\n        assign core_busy_o[i] =  |busy_bits_buf[i*NumBusySignals +: NumBusySignals];\n      end else begin : g_neg\n        assign core_busy_o[i] = ~|busy_bits_buf[i*NumBusySignals +: NumBusySignals];\n      end\n    end\n  end else begin : g_core_busy_non_secure\n    // For non secure Ibex, synthesis is allowed to optimize core_busy_o.\n    assign core_busy_o = (ctrl_busy || if_busy || lsu_busy) ? IbexMuBiOn : IbexMuBiOff;\n  end\n\n  //////////////\n  // IF stage //\n  //////////////\n\n  ibex_if_stage #(\n    .DmHaltAddr       (DmHaltAddr),\n    .DmExceptionAddr  (DmExceptionAddr),\n    .DummyInstructions(DummyInstructions),\n    .ICache           (ICache),\n    .ICacheECC        (ICacheECC),\n    .BusSizeECC       (BusSizeECC),\n    .TagSizeECC       (TagSizeECC),\n    .LineSizeECC      (LineSizeECC),\n    .PCIncrCheck      (PCIncrCheck),\n    .ResetAll         (ResetAll),\n    .RndCnstLfsrSeed  (RndCnstLfsrSeed),\n    .RndCnstLfsrPerm  (RndCnstLfsrPerm),\n    .BranchPredictor  (BranchPredictor),\n    .MemECC           (MemECC),\n    .MemDataWidth     (MemDataWidth)\n  ) if_stage_i (\n    .clk_i (clk_i),\n    .rst_ni(rst_ni),\n\n    .boot_addr_i(boot_addr_i),\n    .req_i      (instr_req_gated),  // instruction request control\n\n    // instruction cache interface\n    .instr_req_o       (instr_req_o),\n    .instr_addr_o      (instr_addr_o),\n    .instr_gnt_i       (instr_gnt_i),\n    .instr_rvalid_i    (instr_rvalid_i),\n    .instr_rdata_i     (instr_rdata_i),\n    .instr_bus_err_i   (instr_err_i),\n    .instr_intg_err_o  (instr_intg_err),\n\n    .ic_tag_req_o      (ic_tag_req_o),\n    .ic_tag_write_o    (ic_tag_write_o),\n    .ic_tag_addr_o     (ic_tag_addr_o),\n    .ic_tag_wdata_o    (ic_tag_wdata_o),\n    .ic_tag_rdata_i    (ic_tag_rdata_i),\n    .ic_data_req_o     (ic_data_req_o),\n    .ic_data_write_o   (ic_data_write_o),\n    .ic_data_addr_o    (ic_data_addr_o),\n    .ic_data_wdata_o   (ic_data_wdata_o),\n    .ic_data_rdata_i   (ic_data_rdata_i),\n    .ic_scr_key_valid_i(ic_scr_key_valid_i),\n    .ic_scr_key_req_o  (ic_scr_key_req_o),\n\n    // outputs to ID stage\n    .instr_valid_id_o        (instr_valid_id),\n    .instr_new_id_o          (instr_new_id),\n    .instr_rdata_id_o        (instr_rdata_id),\n    .instr_rdata_alu_id_o    (instr_rdata_alu_id),\n    .instr_rdata_c_id_o      (instr_rdata_c_id),\n    .instr_is_compressed_id_o(instr_is_compressed_id),\n    .instr_bp_taken_o        (instr_bp_taken_id),\n    .instr_fetch_err_o       (instr_fetch_err),\n    .instr_fetch_err_plus2_o (instr_fetch_err_plus2),\n    .illegal_c_insn_id_o     (illegal_c_insn_id),\n    .dummy_instr_id_o        (dummy_instr_id),\n    .pc_if_o                 (pc_if),\n    .pc_id_o                 (pc_id),\n    .pmp_err_if_i            (pmp_req_err[PMP_I]),\n    .pmp_err_if_plus2_i      (pmp_req_err[PMP_I2]),\n\n    // control signals\n    .instr_valid_clear_i   (instr_valid_clear),\n    .pc_set_i              (pc_set),\n    .pc_mux_i              (pc_mux_id),\n    .nt_branch_mispredict_i(nt_branch_mispredict),\n    .exc_pc_mux_i          (exc_pc_mux_id),\n    .exc_cause             (exc_cause),\n    .dummy_instr_en_i      (dummy_instr_en),\n    .dummy_instr_mask_i    (dummy_instr_mask),\n    .dummy_instr_seed_en_i (dummy_instr_seed_en),\n    .dummy_instr_seed_i    (dummy_instr_seed),\n    .icache_enable_i       (icache_enable),\n    .icache_inval_i        (icache_inval),\n    .icache_ecc_error_o    (icache_ecc_error),\n\n    // branch targets\n    .branch_target_ex_i(branch_target_ex),\n    .nt_branch_addr_i  (nt_branch_addr),\n\n    // CSRs\n    .csr_mepc_i      (csr_mepc),  // exception return address\n    .csr_depc_i      (csr_depc),  // debug return address\n    .csr_mtvec_i     (csr_mtvec),  // trap-vector base address\n    .csr_mtvec_init_o(csr_mtvec_init),\n\n    // pipeline stalls\n    .id_in_ready_i(id_in_ready),\n\n    .pc_mismatch_alert_o(pc_mismatch_alert),\n    .if_busy_o          (if_busy)\n  );\n\n  // Core is waiting for the ISide when ID/EX stage is ready for a new instruction but none are\n  // available\n  assign perf_iside_wait = id_in_ready & ~instr_valid_id;\n\n  // Multi-bit fetch enable used when SecureIbex == 1. When SecureIbex == 0 only use the bottom-bit\n  // of fetch_enable_i. Ensure the multi-bit encoding has the bottom bit set for on and unset for\n  // off so IbexMuBiOn/IbexMuBiOff can be used without needing to know the value of SecureIbex.\n  `ASSERT_INIT(IbexMuBiSecureOnBottomBitSet,    IbexMuBiOn[0] == 1'b1)\n  `ASSERT_INIT(IbexMuBiSecureOffBottomBitClear, IbexMuBiOff[0] == 1'b0)\n\n  // fetch_enable_i can be used to stop the core fetching new instructions\n  if (SecureIbex) begin : g_instr_req_gated_secure\n    // For secure Ibex fetch_enable_i must be a specific multi-bit pattern to enable "}
{"text": "instruction\n    // fetch\n    // SEC_CM: FETCH.CTRL.LC_GATED\n    assign instr_req_gated = instr_req_int & (fetch_enable_i == IbexMuBiOn);\n    assign instr_exec      = fetch_enable_i == IbexMuBiOn;\n  end else begin : g_instr_req_gated_non_secure\n    // For non secure Ibex only the bottom bit of fetch enable is considered\n    logic unused_fetch_enable;\n    assign unused_fetch_enable = ^fetch_enable_i[$bits(ibex_mubi_t)-1:1];\n\n    assign instr_req_gated = instr_req_int & fetch_enable_i[0];\n    assign instr_exec      = fetch_enable_i[0];\n  end\n\n  //////////////\n  // ID stage //\n  //////////////\n\n  ibex_id_stage #(\n    .RV32E          (RV32E),\n    .RV32M          (RV32M),\n    .RV32B          (RV32B),\n    .BranchTargetALU(BranchTargetALU),\n    .DataIndTiming  (DataIndTiming),\n    .WritebackStage (WritebackStage),\n    .BranchPredictor(BranchPredictor),\n    .MemECC         (MemECC)\n  ) id_stage_i (\n    .clk_i (clk_i),\n    .rst_ni(rst_ni),\n\n    // Processor Enable\n    .ctrl_busy_o   (ctrl_busy),\n    .illegal_insn_o(illegal_insn_id),\n\n    // from/to IF-ID pipeline register\n    .instr_valid_i        (instr_valid_id),\n    .instr_rdata_i        (instr_rdata_id),\n    .instr_rdata_alu_i    (instr_rdata_alu_id),\n    .instr_rdata_c_i      (instr_rdata_c_id),\n    .instr_is_compressed_i(instr_is_compressed_id),\n    .instr_bp_taken_i     (instr_bp_taken_id),\n\n    // Jumps and branches\n    .branch_decision_i(branch_decision),\n\n    // IF and ID control signals\n    .instr_first_cycle_id_o(instr_first_cycle_id),\n    .instr_valid_clear_o   (instr_valid_clear),\n    .id_in_ready_o         (id_in_ready),\n    .instr_exec_i          (instr_exec),\n    .instr_req_o           (instr_req_int),\n    .pc_set_o              (pc_set),\n    .pc_mux_o              (pc_mux_id),\n    .nt_branch_mispredict_o(nt_branch_mispredict),\n    .nt_branch_addr_o      (nt_branch_addr),\n    .exc_pc_mux_o          (exc_pc_mux_id),\n    .exc_cause_o           (exc_cause),\n    .icache_inval_o        (icache_inval),\n\n    .instr_fetch_err_i      (instr_fetch_err),\n    .instr_fetch_err_plus2_i(instr_fetch_err_plus2),\n    .illegal_c_insn_i       (illegal_c_insn_id),\n\n    .pc_id_i(pc_id),\n\n    // Stalls\n    .ex_valid_i      (ex_valid),\n    .lsu_resp_valid_i(lsu_resp_valid),\n\n    .alu_operator_ex_o (alu_operator_ex),\n    .alu_operand_a_ex_o(alu_operand_a_ex),\n    .alu_operand_b_ex_o(alu_operand_b_ex),\n\n    .imd_val_q_ex_o (imd_val_q_ex),\n    .imd_val_d_ex_i (imd_val_d_ex),\n    .imd_val_we_ex_i(imd_val_we_ex),\n\n    .bt_a_operand_o(bt_a_operand),\n    .bt_b_operand_o(bt_b_operand),\n\n    .mult_en_ex_o            (mult_en_ex),\n    .div_en_ex_o             (div_en_ex),\n    .mult_sel_ex_o           (mult_sel_ex),\n    .div_sel_ex_o            (div_sel_ex),\n    .multdiv_operator_ex_o   (multdiv_operator_ex),\n    .multdiv_signed_mode_ex_o(multdiv_signed_mode_ex),\n    .multdiv_operand_a_ex_o  (multdiv_operand_a_ex),\n    .multdiv_operand_b_ex_o  (multdiv_operand_b_ex),\n    .multdiv_ready_id_o      (multdiv_ready_id),\n\n    // CSR ID/EX\n    .csr_access_o         (csr_access),\n    .csr_op_o             (csr_op),\n    .csr_op_en_o          (csr_op_en),\n    .csr_save_if_o        (csr_save_if),  // control signal to save PC\n    .csr_save_id_o        (csr_save_id),  // control signal to save PC\n    .csr_save_wb_o        (csr_save_wb),  // control signal to save PC\n    .csr_restore_mret_id_o(csr_restore_mret_id),  // restore mstatus upon MRET\n    .csr_restore_dret_id_o(csr_restore_dret_id),  // restore mstatus upon MRET\n    .csr_save_cause_o     (csr_save_cause),\n    .csr_mtval_o          (csr_mtval),\n    .priv_mode_i          (priv_mode_id),\n    .csr_mstatus_tw_i     (csr_mstatus_tw),\n    .illegal_csr_insn_i   (illegal_csr_insn_id),\n    .data_ind_timing_i    (data_ind_timing),\n\n    // LSU\n    .lsu_req_o     (lsu_req),  // to load store unit\n    .lsu_we_o      (lsu_we),  // to load store unit\n    .lsu_type_o    (lsu_type),  // to load store unit\n    .lsu_sign_ext_o(lsu_sign_ext),  // to load store unit\n    .lsu_wdata_o   (lsu_wdata),  // to load store unit\n    .lsu_req_done_i(lsu_req_done),  // from load store unit\n\n    .lsu_addr_incr_req_i(lsu_addr_incr_req),\n    .lsu_addr_last_i    (lsu_addr_last),\n\n    .lsu_load_err_i           (lsu_load_err),\n    .lsu_load_resp_intg_err_i (lsu_load_resp_intg_err),\n    .lsu_store_err_i          (lsu_store_err),\n    .lsu_store_resp_intg_err_i(lsu_store_resp_intg_err),\n\n    // Interrupt Signals\n    .csr_mstatus_mie_i(csr_mstatus_mie),\n    .irq_pending_i    (irq_pending_o),\n    .irqs_i           (irqs),\n    .irq_nm_i         (irq_nm_i),\n    .nmi_mode_o       (nmi_mode),\n\n    // Debug Signal\n    .debug_mode_o         (debug_mode),\n    .debug_mode_entering_o(debug_mode_entering),\n    .debug_cause_o        (debug_cause),\n    .debug_csr_save_o     (debug_csr_save),\n    .debug_req_i          (debug_req_i),\n    .debug_single_step_i  (debug_single_step),\n    .debug_ebreakm_i      (debug_ebreakm),\n    .debug_ebreaku_i      (debug_ebreaku),\n    .trigger_match_i      (trigger_match),\n\n    // write data to commit in the register file\n    .result_ex_i(result_ex),\n    .csr_rdata_i(csr_rdata),\n\n    .rf_raddr_a_o      (rf_raddr_a),\n    .rf_rdata_a_i      (rf_rdata_a),\n    .rf_raddr_b_o      (rf_raddr_b),\n    .rf_rdata_b_i      (rf_rdata_b),\n    .rf_ren_a_o        (rf_ren_a),\n    .rf_ren_b_o        (rf_ren_b),\n    .rf_waddr_id_o     (rf_waddr_id),\n    .rf_wdata_id_o     (rf_wdata_id),\n    .rf_we_id_o        (rf_we_id),\n    .rf_rd_a_wb_match_o(rf_rd_a_wb_match),\n    .rf_rd_b_wb_match_o(rf_rd_b_wb_match),\n\n    .rf_waddr_wb_i    (rf_waddr_wb),\n    .rf_wdata_fwd_wb_i(rf_wdata_fwd_wb),\n    .rf_write_wb_i    (rf_write_wb),\n\n    .en_wb_o               (en_wb),\n    .instr_type_wb_o       (instr_type_wb),\n    .instr_perf_count_id_o (instr_perf_count_id),\n    .ready_wb_i            (ready_wb),\n    .outstanding_load_wb_i (outstanding_load_wb),\n    .outstanding_store_wb_i(outstanding_store_wb),\n\n    // Performance Counters\n    .perf_jump_o      (perf_jump),\n    .perf_branch_o    (perf_branch),\n    .perf_tbranch_o   (perf_tbranch),\n    .perf_dside_wait_o(perf_dside_wait),\n    .perf_mul_wait_o  (perf_mul_wait),\n    .perf_div_wait_o  (perf_div_wait),\n    .instr_id_done_o  (instr_id_done)\n  );\n\n  // for RVFI only\n  assign unused_illegal_insn_id = illegal_insn_id;\n\n  ibex_ex_block #(\n    .RV32M          (RV32M),\n    .RV32B          (RV32B),\n    .BranchTargetALU(BranchTargetALU)\n  ) ex_block_i (\n    .clk_i (clk_i),\n    .rst_ni(rst_ni),\n\n    // ALU signal from ID stage\n    .alu_operator_i         (alu_operator_ex),\n    .alu_operand_a_i        (alu_operand_a_ex),\n    .alu_operand_b_i        (alu_operand_b_ex),\n    .alu_instr_first_cycle_i(instr_first_cycle_id),\n\n    // Branch target ALU signal from ID stage\n    .bt_a_operand_i(bt_a_operand),\n    .bt_b_operand_i(bt_b_operand),\n\n    // Multipler/Divider signal from ID stage\n    .multdiv_operator_i   (multdiv_operator_ex),\n    .mult_en_i            (mult_en_ex),\n    .div_en_i             (div_en_ex),\n    .mult_sel_i           (mult_sel_ex),\n    .div_sel_i            (div_sel_ex),\n    .multdiv_signed_mode_i(multdiv_signed_mode_ex),\n    .multdiv_operand_a_i  (multdiv_operand_a_ex),\n    .multdiv_operand_b_i  (multdiv_operand_b_ex),\n    .multdiv_ready_id_i   (multdiv_ready_id),\n    .data_ind_timing_i    (data_ind_timing),\n\n    // Intermediate value register\n    .imd_val_we_o(imd_val_we_ex),\n    .imd_val_d_o (imd_val_d_ex),\n    .imd_val_q_i (imd_val_q_ex),\n\n    // Outputs\n    .alu_adder_result_ex_o(alu_adder_result_ex),  // to LSU\n    .result_ex_o          (result_ex),  // to ID\n\n    .branch_target_o  (branch_target_ex),  // to IF\n    .branch_decision_o(branch_decision),  // to ID\n\n    .ex_valid_o(ex_valid)\n  );\n\n  /////////////////////\n  // Load/store unit //\n  /////////////////////\n\n  assign data_req_o   = data_req_out & ~pmp_req_err[PMP_D];\n  assign lsu_resp_err = lsu_load_err | lsu_store_err;\n\n  ibex_load_store_unit #(\n    .MemECC(MemECC),\n    .MemDataWidth(MemDataWidth)\n  ) load_store_unit_i (\n    .clk_i (clk_i),\n    .rst_ni(rst_ni),\n\n    // data interface\n    .data_req_o    (data_req_out),\n    .data_gnt_i    (data_gnt_i),\n    .data_rvalid_i (data_rvalid_i),\n    .data_bus_err_i(data_err_i),\n    .data_pmp_err_i(pmp_req_err[PMP_D]),\n\n    .data_addr_o      (data_addr_o),\n    .data_we_o        (data_we_o),\n    .data_be_o        (data_be_o),\n    .data_wdata_o     (data_wdata_o),\n    .data_rdata_i     (data_rdata_i),\n\n    // signals to/from ID/EX stage\n    .lsu_we_i      (lsu_we),\n    .lsu_type_i    (lsu_type),\n    .lsu_wdata_i   (lsu_wdata),\n    .lsu_sign_ext_i(lsu_sign_ext),\n\n    .lsu_rdata_o      (rf_wdata_lsu),\n    .lsu_rdata_valid_o(rf_we_lsu),\n    .lsu_req_i        (lsu_req),\n    .lsu_req_done_o   (lsu_req_done),\n\n    .adder_result_ex_i(alu_adder_result_ex),\n\n    .addr_incr_req_o(lsu_addr_incr_req),\n    .addr_last_o    (lsu_addr_last),\n\n\n    .lsu_resp_valid_o(lsu_resp_valid),\n\n    // exception signals\n    .load_err_o           (lsu_load_err),\n    .load_resp_intg_err_o (lsu_load_resp_intg_err),\n    .store_err_o          (lsu_store_err),\n    .store_resp_intg_err_o(lsu_store_resp_intg_err),\n\n    .busy_o(lsu_busy),\n\n    .perf_load_o (perf_load),\n    .perf_store_o(perf_store)\n  );\n\n  ibex_wb_stage #(\n    .ResetAll         (ResetAll),\n    .WritebackStage   (WritebackStage),\n    .DummyInstructions(DummyInstructions)\n  ) wb_stage_i (\n    .clk_i                   (clk_i),\n    .rst_ni                  (rst_ni),\n    .en_wb_i                 (en_wb),\n    .instr_type_wb_i         (instr_type_wb),\n    .pc_id_i                 (pc_id),\n    .instr_is_compressed_id_i(instr_is_compressed_id),\n    .instr_perf_count_id_i   (instr_perf_count_id),\n\n    .ready_wb_o                         (ready_wb),\n    .rf_write_wb_o                      (rf_write_wb),\n    .outstanding_load_wb_o              (outstanding_load_wb),\n    .outstanding_store_wb_o             (outstanding_store_wb),\n    .pc_wb_o                            (pc_wb),\n    .perf_instr_ret_wb_o                (perf_instr_ret_wb),\n    .perf_instr_ret_compressed_wb_o     (perf_instr_ret_compressed_wb),\n    .perf_instr_ret_wb_spec_o           (perf_instr_ret_wb_spec),\n    .perf_instr_ret_compressed_wb_spec_o(perf_instr_ret_compressed_wb_spec),\n\n    .rf_waddr_id_i(rf_waddr_id),\n    .rf_wdata_id_i(rf_wdata_id),\n    .rf_we_id_i   (rf_we_id),\n\n    .dummy_instr_id_i(dummy_instr_id),\n\n    .rf_wdata_lsu_i(rf_wdata_lsu),\n    .rf_we_lsu_i   (rf_we_lsu),\n\n    .rf_wdata_fwd_wb_o(rf_wdata_fwd_wb),\n\n    .rf_waddr_wb_o(rf_waddr_wb),\n    .rf_wdata_wb_o(rf_wdata_wb),\n    .rf_we_wb_o   (rf_we_wb),\n\n    .dummy_instr_wb_o(dummy_instr_wb),\n\n    .lsu_resp_valid_i(lsu_resp_valid),\n    .lsu_resp_err_i  (lsu_resp_err),\n\n    .instr_done_wb_o(instr_done_wb)\n  );\n\n  /////////////////////////////\n  // Register file interface //\n  /////////////////////////////\n\n  assign dummy_instr_id_o = dummy_instr_id;\n  assign dummy_instr_wb_o = dummy_instr_wb;\n  assign rf_raddr_a_o     = rf_raddr_a;\n  assign rf_waddr_wb_o    = rf_waddr_wb;\n  assign rf_we_wb_o       = rf_we_wb;\n  assign rf_raddr_b_o     = rf_raddr_b;\n\n  if (RegFileECC) begin : gen_regfile_ecc\n\n    // SEC_CM: DATA_REG_SW.INTEGRITY\n    logic [1:0] rf_ecc_err_a, rf_ecc_err_b;\n    logic       rf_ecc_err_a_id, rf_ecc_err_b_id;\n\n    // ECC checkbit generation for regiter file wdata\n    prim_secded_inv_39_32_enc regfile_ecc_enc (\n      .data_i(rf_wdata_wb),\n      .data_o(rf_wdata_wb_ecc_o)\n    );\n\n    // ECC checking on register file rdata\n    prim_secded_inv_39_32_dec regfile_ecc_dec_a (\n      .data_i    (rf_rdata_a_ecc_i),\n      .data_o    (),\n      .syndrome_o(),\n      .err_o     (rf_ecc_err_a)\n    );\n    prim_secded_inv_39_32_dec regfile_ecc_dec_b (\n      .data_i    (rf_rdata_b_ecc_i),\n      .data_o    (),\n      .syndrome_o(),\n      .err_o     (rf_ecc_err_b)\n    );\n\n    // Assign read outputs - no error correction, just trigger an alert\n    assign rf_rdata_a = rf_rdata_a_ecc_i[31:0];\n    assign rf_rdata_b = rf_rdata_b_ecc_i[31:0];\n\n    // Calculate errors - qualify with WB forwarding to avoid xprop into the alert signal\n    assign rf_ecc_err_a_id = |rf_ecc_err_a & rf_ren_a & ~rf_rd_a_wb_match;\n    assign rf_ecc_err_b_id = |rf_ecc_err_b & rf_ren_b & ~rf_rd_b_wb_match;\n\n    // Combined error\n    assign rf_ecc_err_comb = instr_valid_id & (rf_ecc_err_a_id | rf_ecc_err_b_id);\n\n  end else begin : gen_no_regfile_ecc\n    logic unused_rf_ren_a, unused_rf_ren_b;\n    logic unused_rf_rd_a_wb_match, unused_rf_rd_b_wb_match;\n\n    assign unused_rf_ren_a         = rf_ren_a;\n    assign unused_rf_ren_b         = rf_ren_b;\n    assign unused_rf_rd_a_wb_match = rf_rd_a_wb_match;\n    assign unused_rf_rd_b_wb_match = rf_rd_b_wb_match;\n    assign rf_wdata_wb_ecc_o       = rf_wdata_wb;\n    assign rf_rdata_a              = rf_rdata_a_ecc_i;\n    assign rf_rdata_b              = rf_rdata_b_ecc_i;\n    assign rf_ecc_err_comb         = 1'b0;\n  end\n\n  ///////////////////////\n  // Crash dump output //\n  ///////////////////////\n\n  logic [31:0] crash_dump_mtval;\n  assign crash_dump_o.current_pc     = pc_id;\n  assign crash_dump_o.next_pc        = pc_if;\n  assign crash_dump_o.last_data_addr = lsu_addr_last;\n  assign crash_dump_o.exception_pc   = csr_mepc;\n  assign crash_dump_o.exception_addr = crash_dump_mtval;\n\n  ///////////////////\n  // Alert outputs //\n  ///////////////////\n\n  // Minor alert - core is in a recoverable state\n  assign alert_minor_o = icache_ecc_error;\n\n  // Major internal alert - core is unrecoverable\n  assign alert_major_internal_o = rf_ecc_err_comb | pc_mismatch_alert | csr_shadow_err;\n  // Major bus alert\n  assign alert_major_bus_o = lsu_load_resp_intg_err | lsu_store_resp_intg_err | instr_intg_err;\n\n  // Explict INC_ASSERT block to avoid unused signal lint warnings were asserts are not included\n  `ifdef INC_ASSERT\n  // Signals used for assertions only\n  logic outstanding_load_resp;\n  logic outstanding_store_resp;\n\n  logic outstanding_load_id;\n  logic outstanding_store_id;\n\n  assign outstanding_load_id  = id_stage_i.instr_executing & id_stage_i.lsu_req_dec &\n                                ~id_stage_i.lsu_we;\n  assign outstanding_store_id = id_stage_i.instr_executing & id_stage_i.lsu_req_dec &\n                                id_stage_i.lsu_we;\n\n  if (WritebackStage) begin : gen_wb_stage\n    // When the writeback stage is present a load/store could be in ID or WB. A Load/store in ID can\n    // see a response before it moves to WB when it is unaligned otherwise we should only see\n    // a response when load/store is in WB.\n    assign outstanding_load_resp  = outstanding_load_wb |\n      (outstanding_load_id  & load_store_unit_i.split_misaligned_access);\n\n    assign outstanding_store_resp = outstanding_store_wb |\n      (outstanding_store_id & load_store_unit_i.split_misaligned_access);\n\n    // When writing back the result of a load, the load must have made it to writeback\n    `ASSERT(NoMemRFWriteWithoutPendingLoad, rf_we_lsu |-> outstanding_load_wb, clk_i, !rst_ni)\n  end else begin : gen_no_wb_stage\n    // Without writeback stage only look into whether load or store is in ID to determine if\n    // a response is expected.\n    assign outstanding_load_resp  = outstanding_load_id;\n    assign outstanding_store_resp = outstanding_store_id;\n\n    `ASSERT(NoMemRFWriteWithoutPendingLoad, rf_we_lsu |-> outstanding_load_id, clk_i, !rst_ni)\n  end\n\n  `ASSERT(NoMemResponseWithoutPendingAccess,\n    data_rvalid_i |-> outstanding_load_resp | outstanding_store_resp, clk_i, !rst_ni)\n\n\n  // Keep track of the PC last seen in the ID stage when fetch is disabled\n  logic [31:0]   pc_at_fetch_disable;\n  ibex_mubi_t    last_fetch_enable;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      pc_at_fetch_disable <= '0;\n      last_fetch_enable   <= '0;\n    end else begin\n      last_fetch_enable <= fetch_enable_i;\n\n      if ((fetch_enable_i != IbexMuBiOn) && (last_fetch_enable == IbexMuBiOn)) begin\n        pc_at_fetch_disable <= pc_id;\n      end\n    end\n  end\n\n  // When fetch is disabled no instructions should be executed. Once fetch is disabled either the\n  // ID/EX stage is not valid or the PC of the ID/EX stage must remain as it was at disable. The\n  // ID/EX valid should not ressert once it has been cleared.\n  `ASSERT(NoExecWhenFetchEnableNotOn, fetch_enable_i != IbexMuBiOn |=>\n    (~instr_valid_id || (pc_id == pc_at_fetch_disable)) && ~$rose(instr_valid_id))\n\n  `endif\n\n  ////////////////////////\n  // RF (Register File) //\n  ////////////////////////\n`ifdef RVFI\n`endif\n\n\n  /////////////////////////////////////////\n  // CSRs (Control and Status Registers) //\n  /////////////////////////////////////////\n\n  assign csr_wdata  = alu_operand_a_ex;\n  assign csr_addr   = csr_num_e'(csr_access ? alu_operand_b_ex[11:0] : 12'b0);\n\n  ibex_cs_registers #(\n    .DbgTriggerEn     (DbgTriggerEn),\n    .DbgHwBreakNum    (DbgHwBreakNum),\n    .DataIndTiming    (DataIndTiming),\n    .DummyInstructions(DummyInstructions),\n    .ShadowCSR        (ShadowCSR),\n    .ICache           (ICache),\n    .MHPMCounterNum   (MHPMCounterNum),\n    .MHPMCounterWidth (MHPMCounterWidth),\n    .PMPEnable        (PMPEnable),\n    .PMPGranularity   (PMPGranularity),\n    .PMPNumRegions    (PMPNumRegions),\n    .RV32E            (RV32E),\n    .RV32M            (RV32M),\n    .RV32B            (RV32B)\n  ) cs_registers_i (\n    .clk_i (clk_i),\n    .rst_ni(rst_ni),\n\n    // Hart ID from outside\n    .hart_id_i      (hart_id_i),\n    .priv_mode_id_o (priv_mode_id),\n    .priv_mode_lsu_o(priv_mode_lsu),\n\n    // mtvec\n    .csr_mtvec_o     (csr_mtvec),\n    .csr_mtvec_init_i(csr_mtvec_init),\n    .boot_addr_i     (boot_addr_i),\n\n    // Interface to CSRs     ( SRAM like                    )\n    .csr_access_i(csr_access),\n    .csr_addr_i  (csr_addr),\n    .csr_wdata_i (csr_wdata),\n    .csr_op_i    (csr_op),\n    .csr_op_en_i (csr_op_en),\n    .csr_rdata_o (csr_rdata),\n\n    // Interrupt related control signals\n    .irq_software_i   (irq_software_i),\n    .irq_timer_i      (irq_timer_i),\n    .irq_external_i   (irq_external_i),\n    .irq_fast_i       (irq_fast_i),\n    .nmi_mode_i       (nmi_mode),\n    .irq_pending_o    (irq_pending_o),\n    .irqs_o           (irqs),\n    .csr_mstatus_mie_o(csr_mstatus_mie),\n    .csr_mstatus_tw_o (csr_mstatus_tw),\n    .csr_mepc_o       (csr_mepc),\n    .csr_mtval_o      (crash_dump_mtval),\n\n    // PMP\n    .csr_pmp_cfg_o    (csr_pmp_cfg),\n    .csr_pmp_addr_o   (csr_pmp_addr),\n    .csr_pmp_mseccfg_o(csr_pmp_mseccfg),\n\n    // debug\n    .csr_depc_o           (csr_depc),\n    .debug_mode_i         (debug_mode),\n    .debug_mode_entering_i(debug_mode_entering),\n    .debug_cause_i        (debug_cause),\n    .debug_csr_save_i     (debug_csr_save),\n    .debug_single_step_o  (debug_single_step),\n    .debug_ebreakm_o      (debug_ebreakm),\n    .debug_ebreaku_o      (debug_ebreaku),\n    .trigger_match_o      (trigger_match),\n\n    .pc_if_i(pc_if),\n    .pc_id_i(pc_id),\n    .pc_wb_i(pc_wb),\n\n    .data_ind_timing_o    (data_ind_timing),\n    .dummy_instr_en_o     (dummy_instr_en),\n    .dummy_instr_mask_o   (dummy_instr_mask),\n    .dummy_instr_seed_en_o(dummy_instr_seed_en),\n    .dummy_instr_seed_o   (dummy_instr_seed),\n    .icache_enable_o      (icache_enable),\n    .csr_shadow_err_o     (csr_shadow_err),\n    .ic_scr_key_valid_i   (ic_scr_key_valid_i),\n\n    .csr_save_if_i     (csr_save_if),\n    .csr_save_id_i     (csr_save_id),\n    .csr_save_wb_i     (csr_save_wb),\n    .csr_restore_mret_i(csr_restore_mret_id),\n    .csr_restore_dret_i(csr_restore_dret_id),\n    .csr_save_cause_i  (csr_save_cause),\n    .csr_mcause_i      (exc_cause),\n    .csr_mtval_i       (csr_mtval),\n    .illegal_csr_insn_o(illegal_csr_insn_id),\n\n    .double_fault_seen_o,\n\n    // performance counter related signals\n    .instr_ret_i                (perf_instr_ret_wb),\n    .instr_ret_compressed_i     (perf_instr_ret_compressed_wb),\n    .instr_ret_spec_i           (perf_instr_ret_wb_spec),\n    .instr_ret_compressed_spec_i(perf_instr_ret_compressed_wb_spec),\n    .iside_wait_i               (perf_iside_wait),\n    .jump_i           "}
{"text": "          (perf_jump),\n    .branch_i                   (perf_branch),\n    .branch_taken_i             (perf_tbranch),\n    .mem_load_i                 (perf_load),\n    .mem_store_i                (perf_store),\n    .dside_wait_i               (perf_dside_wait),\n    .mul_wait_i                 (perf_mul_wait),\n    .div_wait_i                 (perf_div_wait)\n  );\n\n  // These assertions are in top-level as instr_valid_id required as the enable term\n  `ASSERT(IbexCsrOpValid, instr_valid_id |-> csr_op inside {\n      CSR_OP_READ,\n      CSR_OP_WRITE,\n      CSR_OP_SET,\n      CSR_OP_CLEAR\n      })\n  `ASSERT_KNOWN_IF(IbexCsrWdataIntKnown, cs_registers_i.csr_wdata_int, csr_op_en)\n\n  if (PMPEnable) begin : g_pmp\n    logic [31:0] pc_if_inc;\n    logic [33:0] pmp_req_addr [PMPNumChan];\n    pmp_req_e    pmp_req_type [PMPNumChan];\n    priv_lvl_e   pmp_priv_lvl [PMPNumChan];\n\n    assign pc_if_inc            = pc_if + 32'd2;\n    assign pmp_req_addr[PMP_I]  = {2'b00, pc_if};\n    assign pmp_req_type[PMP_I]  = PMP_ACC_EXEC;\n    assign pmp_priv_lvl[PMP_I]  = priv_mode_id;\n    assign pmp_req_addr[PMP_I2] = {2'b00, pc_if_inc};\n    assign pmp_req_type[PMP_I2] = PMP_ACC_EXEC;\n    assign pmp_priv_lvl[PMP_I2] = priv_mode_id;\n    assign pmp_req_addr[PMP_D]  = {2'b00, data_addr_o[31:0]};\n    assign pmp_req_type[PMP_D]  = data_we_o ? PMP_ACC_WRITE : PMP_ACC_READ;\n    assign pmp_priv_lvl[PMP_D]  = priv_mode_lsu;\n\n    ibex_pmp #(\n      .PMPGranularity(PMPGranularity),\n      .PMPNumChan    (PMPNumChan),\n      .PMPNumRegions (PMPNumRegions)\n    ) pmp_i (\n      // Interface to CSRs\n      .csr_pmp_cfg_i    (csr_pmp_cfg),\n      .csr_pmp_addr_i   (csr_pmp_addr),\n      .csr_pmp_mseccfg_i(csr_pmp_mseccfg),\n      .priv_mode_i      (pmp_priv_lvl),\n      // Access checking channels\n      .pmp_req_addr_i   (pmp_req_addr),\n      .pmp_req_type_i   (pmp_req_type),\n      .pmp_req_err_o    (pmp_req_err)\n    );\n  end else begin : g_no_pmp\n    // Unused signal tieoff\n    priv_lvl_e unused_priv_lvl_ls;\n    logic [33:0] unused_csr_pmp_addr [PMPNumRegions];\n    pmp_cfg_t    unused_csr_pmp_cfg  [PMPNumRegions];\n    pmp_mseccfg_t unused_csr_pmp_mseccfg;\n    assign unused_priv_lvl_ls = priv_mode_lsu;\n    assign unused_csr_pmp_addr = csr_pmp_addr;\n    assign unused_csr_pmp_cfg = csr_pmp_cfg;\n    assign unused_csr_pmp_mseccfg = csr_pmp_mseccfg;\n\n    // Output tieoff\n    assign pmp_req_err[PMP_I]  = 1'b0;\n    assign pmp_req_err[PMP_I2] = 1'b0;\n    assign pmp_req_err[PMP_D]  = 1'b0;\n  end\n\n`ifdef RVFI\n  // When writeback stage is present RVFI information is emitted when instruction is finished in\n  // third stage but some information must be captured whilst the instruction is in the second\n  // stage. Without writeback stage RVFI information is all emitted when instruction retires in\n  // second stage. RVFI outputs are all straight from flops. So 2 stage pipeline requires a single\n  // set of flops (instr_info => RVFI_out), 3 stage pipeline requires two sets (instr_info => wb\n  // => RVFI_out)\n  localparam int RVFI_STAGES = WritebackStage ? 2 : 1;\n\n  logic        rvfi_stage_valid     [RVFI_STAGES];\n  logic [63:0] rvfi_stage_order     [RVFI_STAGES];\n  logic [31:0] rvfi_stage_insn      [RVFI_STAGES];\n  logic        rvfi_stage_trap      [RVFI_STAGES];\n  logic        rvfi_stage_halt      [RVFI_STAGES];\n  logic        rvfi_stage_intr      [RVFI_STAGES];\n  logic [ 1:0] rvfi_stage_mode      [RVFI_STAGES];\n  logic [ 1:0] rvfi_stage_ixl       [RVFI_STAGES];\n  logic [ 4:0] rvfi_stage_rs1_addr  [RVFI_STAGES];\n  logic [ 4:0] rvfi_stage_rs2_addr  [RVFI_STAGES];\n  logic [ 4:0] rvfi_stage_rs3_addr  [RVFI_STAGES];\n  logic [31:0] rvfi_stage_rs1_rdata [RVFI_STAGES];\n  logic [31:0] rvfi_stage_rs2_rdata [RVFI_STAGES];\n  logic [31:0] rvfi_stage_rs3_rdata [RVFI_STAGES];\n  logic [ 4:0] rvfi_stage_rd_addr   [RVFI_STAGES];\n  logic [31:0] rvfi_stage_rd_wdata  [RVFI_STAGES];\n  logic [31:0] rvfi_stage_pc_rdata  [RVFI_STAGES];\n  logic [31:0] rvfi_stage_pc_wdata  [RVFI_STAGES];\n  logic [31:0] rvfi_stage_mem_addr  [RVFI_STAGES];\n  logic [ 3:0] rvfi_stage_mem_rmask [RVFI_STAGES];\n  logic [ 3:0] rvfi_stage_mem_wmask [RVFI_STAGES];\n  logic [31:0] rvfi_stage_mem_rdata [RVFI_STAGES];\n  logic [31:0] rvfi_stage_mem_wdata [RVFI_STAGES];\n\n  logic        rvfi_instr_new_wb;\n  logic        rvfi_intr_d;\n  logic        rvfi_intr_q;\n  logic        rvfi_set_trap_pc_d;\n  logic        rvfi_set_trap_pc_q;\n  logic [31:0] rvfi_insn_id;\n  logic [4:0]  rvfi_rs1_addr_d;\n  logic [4:0]  rvfi_rs1_addr_q;\n  logic [4:0]  rvfi_rs2_addr_d;\n  logic [4:0]  rvfi_rs2_addr_q;\n  logic [4:0]  rvfi_rs3_addr_d;\n  logic [31:0] rvfi_rs1_data_d;\n  logic [31:0] rvfi_rs1_data_q;\n  logic [31:0] rvfi_rs2_data_d;\n  logic [31:0] rvfi_rs2_data_q;\n  logic [31:0] rvfi_rs3_data_d;\n  logic [4:0]  rvfi_rd_addr_wb;\n  logic [4:0]  rvfi_rd_addr_q;\n  logic [4:0]  rvfi_rd_addr_d;\n  logic [31:0] rvfi_rd_wdata_wb;\n  logic [31:0] rvfi_rd_wdata_d;\n  logic [31:0] rvfi_rd_wdata_q;\n  logic        rvfi_rd_we_wb;\n  logic [3:0]  rvfi_mem_mask_int;\n  logic [31:0] rvfi_mem_rdata_d;\n  logic [31:0] rvfi_mem_rdata_q;\n  logic [31:0] rvfi_mem_wdata_d;\n  logic [31:0] rvfi_mem_wdata_q;\n  logic [31:0] rvfi_mem_addr_d;\n  logic [31:0] rvfi_mem_addr_q;\n  logic        rvfi_trap_id;\n  logic        rvfi_trap_wb;\n  logic        rvfi_irq_valid;\n  logic [63:0] rvfi_stage_order_d;\n  logic        rvfi_id_done;\n  logic        rvfi_wb_done;\n\n  logic            new_debug_req;\n  logic            new_nmi;\n  logic            new_nmi_int;\n  logic            new_irq;\n  ibex_pkg::irqs_t captured_mip;\n  logic            captured_nmi;\n  logic            captured_nmi_int;\n  logic            captured_debug_req;\n  logic            captured_valid;\n\n  // RVFI extension for co-simulation support\n  // debug_req and MIP captured at IF -> ID transition so one extra stage\n  ibex_pkg::irqs_t rvfi_ext_stage_mip              [RVFI_STAGES+1];\n  logic            rvfi_ext_stage_nmi              [RVFI_STAGES+1];\n  logic            rvfi_ext_stage_nmi_int          [RVFI_STAGES+1];\n  logic            rvfi_ext_stage_debug_req        [RVFI_STAGES+1];\n  logic            rvfi_ext_stage_debug_mode       [RVFI_STAGES];\n  logic [63:0]     rvfi_ext_stage_mcycle           [RVFI_STAGES];\n  logic [31:0]     rvfi_ext_stage_mhpmcounters     [RVFI_STAGES][10];\n  logic [31:0]     rvfi_ext_stage_mhpmcountersh    [RVFI_STAGES][10];\n  logic            rvfi_ext_stage_ic_scr_key_valid [RVFI_STAGES];\n  logic            rvfi_ext_stage_irq_valid        [RVFI_STAGES+1];\n\n\n  logic        rvfi_stage_valid_d   [RVFI_STAGES];\n\n  assign rvfi_valid     = rvfi_stage_valid    [RVFI_STAGES-1];\n  assign rvfi_order     = rvfi_stage_order    [RVFI_STAGES-1];\n  assign rvfi_insn      = rvfi_stage_insn     [RVFI_STAGES-1];\n  assign rvfi_trap      = rvfi_stage_trap     [RVFI_STAGES-1];\n  assign rvfi_halt      = rvfi_stage_halt     [RVFI_STAGES-1];\n  assign rvfi_intr      = rvfi_stage_intr     [RVFI_STAGES-1];\n  assign rvfi_mode      = rvfi_stage_mode     [RVFI_STAGES-1];\n  assign rvfi_ixl       = rvfi_stage_ixl      [RVFI_STAGES-1];\n  assign rvfi_rs1_addr  = rvfi_stage_rs1_addr [RVFI_STAGES-1];\n  assign rvfi_rs2_addr  = rvfi_stage_rs2_addr [RVFI_STAGES-1];\n  assign rvfi_rs3_addr  = rvfi_stage_rs3_addr [RVFI_STAGES-1];\n  assign rvfi_rs1_rdata = rvfi_stage_rs1_rdata[RVFI_STAGES-1];\n  assign rvfi_rs2_rdata = rvfi_stage_rs2_rdata[RVFI_STAGES-1];\n  assign rvfi_rs3_rdata = rvfi_stage_rs3_rdata[RVFI_STAGES-1];\n  assign rvfi_rd_addr   = rvfi_stage_rd_addr  [RVFI_STAGES-1];\n  assign rvfi_rd_wdata  = rvfi_stage_rd_wdata [RVFI_STAGES-1];\n  assign rvfi_pc_rdata  = rvfi_stage_pc_rdata [RVFI_STAGES-1];\n  assign rvfi_pc_wdata  = rvfi_stage_pc_wdata [RVFI_STAGES-1];\n  assign rvfi_mem_addr  = rvfi_stage_mem_addr [RVFI_STAGES-1];\n  assign rvfi_mem_rmask = rvfi_stage_mem_rmask[RVFI_STAGES-1];\n  assign rvfi_mem_wmask = rvfi_stage_mem_wmask[RVFI_STAGES-1];\n  assign rvfi_mem_rdata = rvfi_stage_mem_rdata[RVFI_STAGES-1];\n  assign rvfi_mem_wdata = rvfi_stage_mem_wdata[RVFI_STAGES-1];\n\n  assign rvfi_rd_addr_wb  = rf_waddr_wb;\n  assign rvfi_rd_wdata_wb = rf_we_wb ? rf_wdata_wb : rf_wdata_lsu;\n  assign rvfi_rd_we_wb    = rf_we_wb | rf_we_lsu;\n\n  always_comb begin\n    // Use always_comb instead of continuous assign so first assign can set 0 as default everywhere\n    // that is overridden by more specific settings.\n    rvfi_ext_mip                                     = '0;\n    rvfi_ext_mip[CSR_MSIX_BIT]                       = rvfi_ext_stage_mip[RVFI_STAGES].irq_software;\n    rvfi_ext_mip[CSR_MTIX_BIT]                       = rvfi_ext_stage_mip[RVFI_STAGES].irq_timer;\n    rvfi_ext_mip[CSR_MEIX_BIT]                       = rvfi_ext_stage_mip[RVFI_STAGES].irq_external;\n    rvfi_ext_mip[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = rvfi_ext_stage_mip[RVFI_STAGES].irq_fast;\n  end\n\n  assign rvfi_ext_nmi              = rvfi_ext_stage_nmi              [RVFI_STAGES];\n  assign rvfi_ext_nmi_int          = rvfi_ext_stage_nmi_int          [RVFI_STAGES];\n  assign rvfi_ext_debug_req        = rvfi_ext_stage_debug_req        [RVFI_STAGES];\n  assign rvfi_ext_debug_mode       = rvfi_ext_stage_debug_mode       [RVFI_STAGES-1];\n  assign rvfi_ext_mcycle           = rvfi_ext_stage_mcycle           [RVFI_STAGES-1];\n  assign rvfi_ext_mhpmcounters     = rvfi_ext_stage_mhpmcounters     [RVFI_STAGES-1];\n  assign rvfi_ext_mhpmcountersh    = rvfi_ext_stage_mhpmcountersh    [RVFI_STAGES-1];\n  assign rvfi_ext_ic_scr_key_valid = rvfi_ext_stage_ic_scr_key_valid [RVFI_STAGES-1];\n  assign rvfi_ext_irq_valid        = rvfi_ext_stage_irq_valid        [RVFI_STAGES];\n\n  // When an instruction takes a trap the `rvfi_trap` signal will be set. Instructions that take\n  // traps flush the pipeline so ordinarily wouldn't be seen to be retire. The RVFI tracking\n  // pipeline is kept going for flushed instructions that trapped so they are still visible on the\n  // RVFI interface.\n\n  // Factor in exceptions taken in ID so RVFI tracking picks up flushed instructions that took\n  // a trap\n  assign rvfi_id_done = instr_id_done | (id_stage_i.controller_i.rvfi_flush_next &\n                                         id_stage_i.controller_i.id_exception_o);\n\n  if (WritebackStage) begin : gen_rvfi_wb_stage\n    logic unused_instr_new_id;\n\n    assign unused_instr_new_id = instr_new_id;\n\n    // With writeback stage first RVFI stage buffers instruction information captured in ID/EX\n    // awaiting instruction retirement and RF Write data/Mem read data whilst instruction is in WB\n    // So first stage becomes valid when instruction leaves ID/EX stage and remains valid until\n    // instruction leaves WB\n    assign rvfi_stage_valid_d[0] = (rvfi_id_done & ~dummy_instr_id) |\n                                   (rvfi_stage_valid[0] & ~rvfi_wb_done);\n    // Second stage is output stage so simple valid cycle after instruction leaves WB (and so has\n    // retired)\n    assign rvfi_stage_valid_d[1] = rvfi_wb_done;\n\n    // Signal new instruction in WB cycle after instruction leaves ID/EX (to enter WB)\n    logic rvfi_instr_new_wb_q;\n\n    // Signal new instruction in WB either when one has just entered or when a trap is progressing\n    // through the tracking pipeline\n    assign rvfi_instr_new_wb = rvfi_instr_new_wb_q | (rvfi_stage_valid[0] & rvfi_stage_trap[0]);\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        rvfi_instr_new_wb_q <= 0;\n      end else begin\n        rvfi_instr_new_wb_q <= rvfi_id_done;\n      end\n    end\n\n    assign rvfi_trap_id = id_stage_i.controller_i.id_exception_o &\n      ~(id_stage_i.ebrk_insn & id_stage_i.controller_i.ebreak_into_debug);\n\n    assign rvfi_trap_wb = id_stage_i.controller_i.exc_req_lsu;\n    // WB is instantly done in the tracking pipeline when a trap is progress through the pipeline\n    assign rvfi_wb_done = rvfi_stage_valid[0] & (instr_done_wb | rvfi_stage_trap[0]);\n  end else begin : gen_rvfi_no_wb_stage\n    // Without writeback stage first RVFI stage is output stage so simply valid the cycle after\n    // instruction leaves ID/EX (and so has retired)\n    assign rvfi_stage_valid_d[0] = rvfi_id_done & ~dummy_instr_id;\n    // Without writeback stage signal new instr_new_wb when instruction enters ID/EX to correctly\n    // setup register write signals\n    assign rvfi_instr_new_wb = instr_new_id;\n    assign rvfi_trap_id =\n      (id_stage_i.controller_i.exc_req_d | id_stage_i.controller_i.exc_req_lsu) &\n      ~(id_stage_i.ebrk_insn & id_stage_i.controller_i.ebreak_into_debug);\n    assign rvfi_trap_wb = 1'b0;\n    assign rvfi_wb_done = instr_done_wb;\n  end\n\n  assign rvfi_stage_order_d = dummy_instr_id ? rvfi_stage_order[0] : rvfi_stage_order[0] + 64'd1;\n\n  // For interrupts and debug Ibex will take the relevant trap as soon as whatever instruction in ID\n  // finishes or immediately if the ID stage is empty. The rvfi_ext interface provides the DV\n  // environment with information about the irq/debug_req/nmi state that applies to a particular\n  // instruction.\n  //\n  // When a irq/debug_req/nmi appears the ID stage will finish whatever instruction it is currently\n  // executing (if any) then take the trap the cycle after that instruction leaves the ID stage. The\n  // trap taken depends upon the state of irq/debug_req/nmi on that cycle. In the cycles following\n  // that before the first instruction of the trap handler enters the ID stage the state of\n  // irq/debug_req/nmi could change but this has no effect on the trap handler (e.g. a higher\n  // priority interrupt might appear but this wouldn't stop the lower priority interrupt trap\n  // handler executing first as it's already being fetched). To provide the DV environment with the\n  // correct information for it to verify execution we need to capture the irq/debug_req/nmi state\n  // the cycle the trap decision is made. Which the captured_X signals below do.\n  //\n  // The new_X signals take the raw irq/debug_req/nmi inputs and factor in the enable terms required\n  // to determine if a trap will actually happen.\n  //\n  // These signals and the comment above are referred to in the documentation (cosim.rst). If\n  // altering the names or meanings of these signals or this comment please adjust the documentation\n  // appropriately.\n  assign new_debug_req = (debug_req_i & ~debug_mode);\n  assign new_nmi = irq_nm_i & ~nmi_mode & ~debug_mode;\n  assign new_nmi_int = id_stage_i.controller_i.irq_nm_int & ~nmi_mode & ~debug_mode;\n  assign new_irq = irq_pending_o & (csr_mstatus_mie || (priv_mode_id == PRIV_LVL_U)) & ~nmi_mode &\n                   ~debug_mode;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      captured_valid     <= 1'b0;\n      captured_mip       <= '0;\n      captured_nmi       <= 1'b0;\n      captured_nmi_int   <= 1'b0;\n      captured_debug_req <= 1'b0;\n      rvfi_irq_valid     <= 1'b0;\n    end else  begin\n      // Capture when ID stage has emptied out and something occurs that will cause a trap and we\n      // haven't yet captured\n      //\n      // When we already captured a trap, and there is upcoming nmi interrupt or\n      // a debug request then recapture as nmi or debug request are supposed to\n      // be serviced.\n      if (~instr_valid_id & (new_debug_req | new_irq | new_nmi | new_nmi_int) &\n          ((~captured_valid) |\n           (new_debug_req & ~captured_debug_req) |\n           (new_nmi & ~captured_nmi & ~captured_debug_req))) begin\n        captured_valid     <= 1'b1;\n        captured_nmi       <= irq_nm_i;\n        captured_nmi_int   <= id_stage_i.controller_i.irq_nm_int;\n        captured_mip       <= cs_registers_i.mip;\n        captured_debug_req <= debug_req_i;\n      end\n\n      // When the pipeline has emptied in preparation for handling a new interrupt send\n      // a notification up the RVFI pipeline. This is used by the cosim to deal with cases where an\n      // interrupt occurs before another interrupt or debug request but both occur before the first\n      // instruction of the handler is executed and retired (where the cosim will see all the\n      // interrupts and debug requests at once with no way to determine which occurred first).\n      if (~instr_valid_id & ~new_debug_req & (new_irq | new_nmi | new_nmi_int) & ready_wb &\n          ~captured_valid) begin\n        rvfi_irq_valid <= 1'b1;\n      end else begin\n        rvfi_irq_valid <= 1'b0;\n      end\n\n      // Capture cleared out as soon as a new instruction appears in ID\n      if (if_stage_i.instr_valid_id_d) begin\n        captured_valid <= 1'b0;\n      end\n    end\n  end\n\n  // Pass the captured irq/debug_req/nmi state to the rvfi_ext interface tracking pipeline.\n  //\n  // To correctly capture we need to factor in various enable terms, should there be a fault in this\n  // logic we won't tell the DV environment about a trap that should have been taken. So if there's\n  // no valid capture we grab the raw values of the irq/debug_req/nmi inputs whatever they are and\n  // the DV environment will see if a trap should have been taken but wasn't.\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      rvfi_ext_stage_mip[0]       <= '0;\n      rvfi_ext_stage_nmi[0]       <= '0;\n      rvfi_ext_stage_nmi_int[0]   <= '0;\n      rvfi_ext_stage_debug_req[0] <= '0;\n    end else if ((if_stage_i.instr_valid_id_d & if_stage_i.instr_new_id_d) | rvfi_irq_valid) begin\n      rvfi_ext_stage_mip[0]       <= instr_valid_id | ~captured_valid ? cs_registers_i.mip :\n                                                                        captured_mip;\n      rvfi_ext_stage_nmi[0]       <= instr_valid_id | ~captured_valid ? irq_nm_i :\n                                                                        captured_nmi;\n      rvfi_ext_stage_nmi_int[0]   <=\n        instr_valid_id | ~captured_valid ? id_stage_i.controller_i.irq_nm_int :\n                                           captured_nmi_int;\n      rvfi_ext_stage_debug_req[0] <= instr_valid_id | ~captured_valid ? debug_req_i        :\n                                                                        captured_debug_req;\n    end\n  end\n\n\n  // rvfi_irq_valid signals an interrupt event to the cosim. These should only occur when the RVFI\n  // pipe is empty so just send it straigh through.\n  for (genvar i = 0; i < RVFI_STAGES + 1; i = i + 1) begin : g_rvfi_irq_valid\n    if (i == 0) begin : g_rvfi_irq_valid_first_stage\n      always_ff @(posedge clk_i or negedge rst_ni) begin\n        if (!rst_ni) begin\n          rvfi_ext_stage_irq_valid[i] <= 1'b0;\n        end else begin\n          rvfi_ext_stage_irq_valid[i] <= rvfi_irq_valid;\n        end\n      end\n    end else begin : g_rvfi_irq_valid_other_stages\n      always_ff @(posedge clk_i or negedge rst_ni) begin\n        if (!rst_ni) begin\n          rvfi_ext_stage_irq_valid[i] <= 1'b0;\n        end else begin\n          rvfi_ext_stage_irq_valid[i] <= rvfi_ext_stage_irq_valid[i-1];\n        end\n      end\n    end\n  end\n\n  for (genvar i = 0; i < RVFI_STAGES; i = i + 1) begin : g_rvfi_stages\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        rvfi_stage_halt[i]                 <= '0;\n        rvfi_stage_trap[i]                 <= '0;\n        rvfi_stage_intr[i]                 <= '0;\n        rvfi_stage_order[i]                <= '0;\n        rvfi_stage_insn[i]                 <= '0;\n        rvfi_stage_mode[i]                 <= {PRIV_LVL_M};\n        rvfi_stage_ixl[i]                  <= CSR_MISA_MXL;\n        rvfi_stage_rs1_addr[i]             <= '0;\n        rvfi_stage_rs2_addr[i]             <= '0;\n        rvfi_stage_rs3_addr[i]             <= '0;\n        rvfi_stage_pc_rdata[i]             <= '0;\n        rvfi_stage_pc_wdata[i]             <= '0;\n        rvfi_stage_mem_rmask[i]            <= '0;\n        rvfi_stage_mem_wmask[i]            <= '0;\n        rvfi_stage_valid[i]                <= '0;\n        rvfi_stage_rs1_rdata[i]            <= '0;\n        rvfi_stage_rs2_rdata[i]            <= '0;\n        rvfi_stage_rs3_rdata[i]            <= '0;\n        rvfi_stage_rd_wdata[i]             <= '0;\n        rvfi_stage_rd_addr[i]              <= '0;\n        rvfi_stage"}
{"text": "_mem_rdata[i]            <= '0;\n        rvfi_stage_mem_wdata[i]            <= '0;\n        rvfi_stage_mem_addr[i]             <= '0;\n        rvfi_ext_stage_mip[i+1]            <= '0;\n        rvfi_ext_stage_nmi[i+1]            <= '0;\n        rvfi_ext_stage_nmi_int[i+1]        <= '0;\n        rvfi_ext_stage_debug_req[i+1]      <= '0;\n        rvfi_ext_stage_debug_mode[i]       <= '0;\n        rvfi_ext_stage_mcycle[i]           <= '0;\n        rvfi_ext_stage_mhpmcounters[i]     <= '{10{'0}};\n        rvfi_ext_stage_mhpmcountersh[i]    <= '{10{'0}};\n        rvfi_ext_stage_ic_scr_key_valid[i] <= '0;\n      end else begin\n        rvfi_stage_valid[i] <= rvfi_stage_valid_d[i];\n\n        if (i == 0) begin\n          if (rvfi_id_done) begin\n            rvfi_stage_halt[i]      <= '0;\n            rvfi_stage_trap[i]                 <= rvfi_trap_id;\n            rvfi_stage_intr[i]                 <= rvfi_intr_d;\n            rvfi_stage_order[i]                <= rvfi_stage_order_d;\n            rvfi_stage_insn[i]                 <= rvfi_insn_id;\n            rvfi_stage_mode[i]                 <= {priv_mode_id};\n            rvfi_stage_ixl[i]                  <= CSR_MISA_MXL;\n            rvfi_stage_rs1_addr[i]             <= rvfi_rs1_addr_d;\n            rvfi_stage_rs2_addr[i]             <= rvfi_rs2_addr_d;\n            rvfi_stage_rs3_addr[i]             <= rvfi_rs3_addr_d;\n            rvfi_stage_pc_rdata[i]             <= pc_id;\n            rvfi_stage_pc_wdata[i]             <= pc_set ? branch_target_ex : pc_if;\n            rvfi_stage_mem_rmask[i]            <= rvfi_mem_mask_int;\n            rvfi_stage_mem_wmask[i]            <= data_we_o ? rvfi_mem_mask_int : 4'b0000;\n            rvfi_stage_rs1_rdata[i]            <= rvfi_rs1_data_d;\n            rvfi_stage_rs2_rdata[i]            <= rvfi_rs2_data_d;\n            rvfi_stage_rs3_rdata[i]            <= rvfi_rs3_data_d;\n            rvfi_stage_rd_addr[i]              <= rvfi_rd_addr_d;\n            rvfi_stage_rd_wdata[i]             <= rvfi_rd_wdata_d;\n            rvfi_stage_mem_rdata[i]            <= rvfi_mem_rdata_d;\n            rvfi_stage_mem_wdata[i]            <= rvfi_mem_wdata_d;\n            rvfi_stage_mem_addr[i]             <= rvfi_mem_addr_d;\n            rvfi_ext_stage_debug_mode[i]       <= debug_mode;\n            rvfi_ext_stage_mcycle[i]           <= cs_registers_i.mcycle_counter_i.counter_val_o;\n            rvfi_ext_stage_ic_scr_key_valid[i] <= cs_registers_i.cpuctrlsts_ic_scr_key_valid_q;\n            // This is done this way because SystemVerilog does not support looping through\n            // gen_cntrs[k] within a for loop.\n            for (int k=0; k < 10; k++) begin\n              rvfi_ext_stage_mhpmcounters[i][k]  <= cs_registers_i.mhpmcounter[k+3][31:0];\n              rvfi_ext_stage_mhpmcountersh[i][k] <= cs_registers_i.mhpmcounter[k+3][63:32];\n            end\n          end\n\n          // Some of the rvfi_ext_* signals are used to provide an interrupt notification (signalled\n          // via rvfi_ext_irq_valid) when there isn't a valid retired instruction as well as\n          // providing information along with a retired instruction. Move these up the rvfi pipeline\n          // for both cases.\n          if (rvfi_id_done | rvfi_ext_stage_irq_valid[i]) begin\n            rvfi_ext_stage_mip[i+1]       <= rvfi_ext_stage_mip[i];\n            rvfi_ext_stage_nmi[i+1]       <= rvfi_ext_stage_nmi[i];\n            rvfi_ext_stage_nmi_int[i+1]   <= rvfi_ext_stage_nmi_int[i];\n            rvfi_ext_stage_debug_req[i+1] <= rvfi_ext_stage_debug_req[i];\n          end\n        end else begin\n          if (rvfi_wb_done) begin\n            rvfi_stage_halt[i]      <= rvfi_stage_halt[i-1];\n            rvfi_stage_trap[i]      <= rvfi_stage_trap[i-1] | rvfi_trap_wb;\n            rvfi_stage_intr[i]      <= rvfi_stage_intr[i-1];\n            rvfi_stage_order[i]     <= rvfi_stage_order[i-1];\n            rvfi_stage_insn[i]      <= rvfi_stage_insn[i-1];\n            rvfi_stage_mode[i]      <= rvfi_stage_mode[i-1];\n            rvfi_stage_ixl[i]       <= rvfi_stage_ixl[i-1];\n            rvfi_stage_rs1_addr[i]  <= rvfi_stage_rs1_addr[i-1];\n            rvfi_stage_rs2_addr[i]  <= rvfi_stage_rs2_addr[i-1];\n            rvfi_stage_rs3_addr[i]  <= rvfi_stage_rs3_addr[i-1];\n            rvfi_stage_pc_rdata[i]  <= rvfi_stage_pc_rdata[i-1];\n            rvfi_stage_pc_wdata[i]  <= rvfi_stage_pc_wdata[i-1];\n            rvfi_stage_mem_rmask[i] <= rvfi_stage_mem_rmask[i-1];\n            rvfi_stage_mem_wmask[i] <= rvfi_stage_mem_wmask[i-1];\n            rvfi_stage_rs1_rdata[i] <= rvfi_stage_rs1_rdata[i-1];\n            rvfi_stage_rs2_rdata[i] <= rvfi_stage_rs2_rdata[i-1];\n            rvfi_stage_rs3_rdata[i] <= rvfi_stage_rs3_rdata[i-1];\n            rvfi_stage_mem_wdata[i] <= rvfi_stage_mem_wdata[i-1];\n            rvfi_stage_mem_addr[i]  <= rvfi_stage_mem_addr[i-1];\n\n            // For 2 RVFI_STAGES/Writeback Stage ignore first stage flops for rd_addr, rd_wdata and\n            // mem_rdata. For RF write addr/data actual write happens in writeback so capture\n            // address/data there. For mem_rdata that is only available from the writeback stage.\n            // Previous stage flops still exist in RTL as they are used by the non writeback config\n            rvfi_stage_rd_addr[i]   <= rvfi_rd_addr_d;\n            rvfi_stage_rd_wdata[i]  <= rvfi_rd_wdata_d;\n            rvfi_stage_mem_rdata[i] <= rvfi_mem_rdata_d;\n\n            rvfi_ext_stage_debug_mode[i]       <= rvfi_ext_stage_debug_mode[i-1];\n            rvfi_ext_stage_mcycle[i]           <= rvfi_ext_stage_mcycle[i-1];\n            rvfi_ext_stage_ic_scr_key_valid[i] <= rvfi_ext_stage_ic_scr_key_valid[i-1];\n            rvfi_ext_stage_mhpmcounters[i]     <= rvfi_ext_stage_mhpmcounters[i-1];\n            rvfi_ext_stage_mhpmcountersh[i]    <= rvfi_ext_stage_mhpmcountersh[i-1];\n          end\n\n          // Some of the rvfi_ext_* signals are used to provide an interrupt notification (signalled\n          // via rvfi_ext_irq_valid) when there isn't a valid retired instruction as well as\n          // providing information along with a retired instruction. Move these up the rvfi pipeline\n          // for both cases.\n          if (rvfi_wb_done | rvfi_ext_stage_irq_valid[i]) begin\n            rvfi_ext_stage_mip[i+1]       <= rvfi_ext_stage_mip[i];\n            rvfi_ext_stage_nmi[i+1]       <= rvfi_ext_stage_nmi[i];\n            rvfi_ext_stage_nmi_int[i+1]   <= rvfi_ext_stage_nmi_int[i];\n            rvfi_ext_stage_debug_req[i+1] <= rvfi_ext_stage_debug_req[i];\n          end\n        end\n      end\n    end\n  end\n\n\n  // Memory adddress/write data available first cycle of ld/st instruction from register read\n  always_comb begin\n    if (instr_first_cycle_id) begin\n      rvfi_mem_addr_d  = alu_adder_result_ex;\n      rvfi_mem_wdata_d = lsu_wdata;\n    end else begin\n      rvfi_mem_addr_d  = rvfi_mem_addr_q;\n      rvfi_mem_wdata_d = rvfi_mem_wdata_q;\n    end\n  end\n\n  // Capture read data from LSU when it becomes valid\n  always_comb begin\n    if (lsu_resp_valid) begin\n      rvfi_mem_rdata_d = rf_wdata_lsu;\n    end else begin\n      rvfi_mem_rdata_d = rvfi_mem_rdata_q;\n    end\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      rvfi_mem_addr_q  <= '0;\n      rvfi_mem_rdata_q <= '0;\n      rvfi_mem_wdata_q <= '0;\n    end else begin\n      rvfi_mem_addr_q  <= rvfi_mem_addr_d;\n      rvfi_mem_rdata_q <= rvfi_mem_rdata_d;\n      rvfi_mem_wdata_q <= rvfi_mem_wdata_d;\n    end\n  end\n  // Byte enable based on data type\n  always_comb begin\n    unique case (lsu_type)\n      2'b00:   rvfi_mem_mask_int = 4'b1111;\n      2'b01:   rvfi_mem_mask_int = 4'b0011;\n      2'b10:   rvfi_mem_mask_int = 4'b0001;\n      default: rvfi_mem_mask_int = 4'b0000;\n    endcase\n  end\n\n  always_comb begin\n    if (instr_is_compressed_id) begin\n      rvfi_insn_id = {16'b0, instr_rdata_c_id};\n    end else begin\n      rvfi_insn_id = instr_rdata_id;\n    end\n  end\n\n  // Source registers 1 and 2 are read in the first instruction cycle\n  // Source register 3 is read in the second instruction cycle.\n  always_comb begin\n    if (instr_first_cycle_id) begin\n      rvfi_rs1_data_d = rf_ren_a ? multdiv_operand_a_ex : '0;\n      rvfi_rs1_addr_d = rf_ren_a ? rf_raddr_a : '0;\n      rvfi_rs2_data_d = rf_ren_b ? multdiv_operand_b_ex : '0;\n      rvfi_rs2_addr_d = rf_ren_b ? rf_raddr_b : '0;\n      rvfi_rs3_data_d = '0;\n      rvfi_rs3_addr_d = '0;\n    end else begin\n      rvfi_rs1_data_d = rvfi_rs1_data_q;\n      rvfi_rs1_addr_d = rvfi_rs1_addr_q;\n      rvfi_rs2_data_d = rvfi_rs2_data_q;\n      rvfi_rs2_addr_d = rvfi_rs2_addr_q;\n      rvfi_rs3_data_d = multdiv_operand_a_ex;\n      rvfi_rs3_addr_d = rf_raddr_a;\n    end\n  end\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      rvfi_rs1_data_q <= '0;\n      rvfi_rs1_addr_q <= '0;\n      rvfi_rs2_data_q <= '0;\n      rvfi_rs2_addr_q <= '0;\n\n    end else begin\n      rvfi_rs1_data_q <= rvfi_rs1_data_d;\n      rvfi_rs1_addr_q <= rvfi_rs1_addr_d;\n      rvfi_rs2_data_q <= rvfi_rs2_data_d;\n      rvfi_rs2_addr_q <= rvfi_rs2_addr_d;\n    end\n  end\n\n  always_comb begin\n    if (rvfi_rd_we_wb) begin\n      // Capture address/data of write to register file\n      rvfi_rd_addr_d = rvfi_rd_addr_wb;\n      // If writing to x0 zero write data as required by RVFI specification\n      if (rvfi_rd_addr_wb == 5'b0) begin\n        rvfi_rd_wdata_d = '0;\n      end else begin\n        rvfi_rd_wdata_d = rvfi_rd_wdata_wb;\n      end\n    end else if (rvfi_instr_new_wb) begin\n      // If no RF write but new instruction in Writeback (when present) or ID/EX (when no writeback\n      // stage present) then zero RF write address/data as required by RVFI specification\n      rvfi_rd_addr_d  = '0;\n      rvfi_rd_wdata_d = '0;\n    end else begin\n      // Otherwise maintain previous value\n      rvfi_rd_addr_d  = rvfi_rd_addr_q;\n      rvfi_rd_wdata_d = rvfi_rd_wdata_q;\n    end\n  end\n\n  // RD write register is refreshed only once per cycle and\n  // then it is kept stable for the cycle.\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      rvfi_rd_addr_q    <= '0;\n      rvfi_rd_wdata_q   <= '0;\n    end else begin\n      rvfi_rd_addr_q    <= rvfi_rd_addr_d;\n      rvfi_rd_wdata_q   <= rvfi_rd_wdata_d;\n    end\n  end\n\n  if (WritebackStage) begin : g_rvfi_rf_wr_suppress_wb\n    logic rvfi_stage_rf_wr_suppress_wb;\n    logic rvfi_rf_wr_suppress_wb;\n\n    // Set when RF write from load data is suppressed due to an integrity error\n    assign rvfi_rf_wr_suppress_wb =\n      instr_done_wb & ~rf_we_wb_o & outstanding_load_wb & lsu_load_resp_intg_err;\n\n    always@(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        rvfi_stage_rf_wr_suppress_wb <= 1'b0;\n      end else if (rvfi_wb_done) begin\n        rvfi_stage_rf_wr_suppress_wb <= rvfi_rf_wr_suppress_wb;\n      end\n    end\n\n    assign rvfi_ext_rf_wr_suppress = rvfi_stage_rf_wr_suppress_wb;\n  end else begin : g_rvfi_no_rf_wr_suppress_wb\n    assign rvfi_ext_rf_wr_suppress = 1'b0;\n  end\n\n  // rvfi_intr must be set for first instruction that is part of a trap handler.\n  // On the first cycle of a new instruction see if a trap PC was set by the previous instruction,\n  // otherwise maintain value.\n  assign rvfi_intr_d = instr_first_cycle_id ? rvfi_set_trap_pc_q : rvfi_intr_q;\n\n  always_comb begin\n    rvfi_set_trap_pc_d = rvfi_set_trap_pc_q;\n\n    if (pc_set && pc_mux_id == PC_EXC &&\n        (exc_pc_mux_id == EXC_PC_EXC || exc_pc_mux_id == EXC_PC_IRQ)) begin\n      // PC is set to enter a trap handler\n      rvfi_set_trap_pc_d = 1'b1;\n    end else if (rvfi_set_trap_pc_q && rvfi_id_done) begin\n      // first instruction has been executed after PC is set to trap handler\n      rvfi_set_trap_pc_d = 1'b0;\n    end\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      rvfi_set_trap_pc_q <= 1'b0;\n      rvfi_intr_q        <= 1'b0;\n    end else begin\n      rvfi_set_trap_pc_q <= rvfi_set_trap_pc_d;\n      rvfi_intr_q        <= rvfi_intr_d;\n    end\n  end\n\n`else\n  logic unused_instr_new_id, unused_instr_id_done, unused_instr_done_wb;\n  assign unused_instr_id_done = instr_id_done;\n  assign unused_instr_new_id = instr_new_id;\n  assign unused_instr_done_wb = instr_done_wb;\n`endif\n\n  // Certain parameter combinations are not supported\n  `ASSERT_INIT(IllegalParamSecure, !(SecureIbex && (RV32M == RV32MNone)))\n\n  //////////\n  // FCOV //\n  //////////\n\n`ifndef SYNTHESIS\n  // fcov signals for V2S\n  `DV_FCOV_SIGNAL_GEN_IF(logic, rf_ecc_err_a_id, gen_regfile_ecc.rf_ecc_err_a_id, RegFileECC)\n  `DV_FCOV_SIGNAL_GEN_IF(logic, rf_ecc_err_b_id, gen_regfile_ecc.rf_ecc_err_b_id, RegFileECC)\n\n  // fcov signals for CSR access. These are complicated by illegal accesses. Where an access is\n  // legal `csr_op_en` signals the operation occurring, but this is deasserted where an access is\n  // illegal. Instead `illegal_insn_id` confirms the instruction is taking an illegal instruction\n  // exception.\n  // All CSR operations perform a read, `CSR_OP_READ` is the only one that only performs a read\n  `DV_FCOV_SIGNAL(logic, csr_read_only,\n      (csr_op == CSR_OP_READ) && csr_access && (csr_op_en || illegal_insn_id))\n  `DV_FCOV_SIGNAL(logic, csr_write,\n      cs_registers_i.csr_wr && csr_access && (csr_op_en || illegal_insn_id))\n\n  if (PMPEnable) begin : g_pmp_fcov_signals\n    logic [PMPNumRegions-1:0] fcov_pmp_region_ichan_priority;\n    logic [PMPNumRegions-1:0] fcov_pmp_region_ichan2_priority;\n    logic [PMPNumRegions-1:0] fcov_pmp_region_dchan_priority;\n\n    logic unused_fcov_pmp_region_priority;\n\n    assign unused_fcov_pmp_region_priority = ^{fcov_pmp_region_ichan_priority,\n                                               fcov_pmp_region_ichan2_priority,\n                                               fcov_pmp_region_dchan_priority};\n\n    for (genvar i_region = 0; i_region < PMPNumRegions; i_region += 1) begin : g_pmp_region_fcov\n      `DV_FCOV_SIGNAL(logic, pmp_region_ichan_access,\n          g_pmp.pmp_i.region_match_all[PMP_I][i_region] & if_stage_i.if_id_pipe_reg_we)\n      `DV_FCOV_SIGNAL(logic, pmp_region_ichan2_access,\n          g_pmp.pmp_i.region_match_all[PMP_I2][i_region] & if_stage_i.if_id_pipe_reg_we)\n      `DV_FCOV_SIGNAL(logic, pmp_region_dchan_access,\n          g_pmp.pmp_i.region_match_all[PMP_D][i_region] & data_req_out)\n      // pmp_cfg[5:6] is reserved and because of that the width of it inside cs_registers module\n      // is 6-bit.\n      `DV_FCOV_SIGNAL(logic, warl_check_pmpcfg,\n          fcov_csr_write &&\n          (cs_registers_i.g_pmp_registers.g_pmp_csrs[i_region].u_pmp_cfg_csr.wr_data_i !=\n          {cs_registers_i.csr_wdata_int[(i_region%4)*PMP_CFG_W+:5],\n           cs_registers_i.csr_wdata_int[(i_region%4)*PMP_CFG_W+7]}))\n\n      if (i_region > 0) begin : g_region_priority\n        assign fcov_pmp_region_ichan_priority[i_region] =\n          g_pmp.pmp_i.region_match_all[PMP_I][i_region] &\n          ~|g_pmp.pmp_i.region_match_all[PMP_I][i_region-1:0];\n\n        assign fcov_pmp_region_ichan2_priority[i_region] =\n          g_pmp.pmp_i.region_match_all[PMP_I2][i_region] &\n          ~|g_pmp.pmp_i.region_match_all[PMP_I2][i_region-1:0];\n\n        assign fcov_pmp_region_dchan_priority[i_region] =\n          g_pmp.pmp_i.region_match_all[PMP_D][i_region] &\n          ~|g_pmp.pmp_i.region_match_all[PMP_D][i_region-1:0];\n      end else begin : g_region_highest_priority\n        assign fcov_pmp_region_ichan_priority[i_region] =\n          g_pmp.pmp_i.region_match_all[PMP_I][i_region];\n\n        assign fcov_pmp_region_ichan2_priority[i_region] =\n          g_pmp.pmp_i.region_match_all[PMP_I2][i_region];\n\n        assign fcov_pmp_region_dchan_priority[i_region] =\n          g_pmp.pmp_i.region_match_all[PMP_D][i_region];\n      end\n    end\n  end\n`endif\n\nendmodule\n"}
{"text": "module ibex_counter #(\n  parameter int CounterWidth = 32,\n  // When set `counter_val_upd_o` provides an incremented version of the counter value, otherwise\n  // the output is hard-wired to 0. This is required to allow Xilinx DSP inference to work\n  // correctly. When `ProvideValUpd` is set no DSPs are inferred.\n  parameter bit ProvideValUpd = 0\n) (\n  input  logic        clk_i,\n  input  logic        rst_ni,\n\n  input  logic        counter_inc_i,\n  input  logic        counterh_we_i,\n  input  logic        counter_we_i,\n  input  logic [31:0] counter_val_i,\n  output logic [63:0] counter_val_o,\n  output logic [63:0] counter_val_upd_o\n);\n\n  logic [63:0]             counter;\n  logic [CounterWidth-1:0] counter_upd;\n  logic [63:0]             counter_load;\n  logic                    we;\n  logic [CounterWidth-1:0] counter_d;\n\n  // Increment\n  assign counter_upd = counter[CounterWidth-1:0] + {{CounterWidth - 1{1'b0}}, 1'b1};\n\n  // Update\n  always_comb begin\n    // Write\n    we = counter_we_i | counterh_we_i;\n    counter_load[63:32] = counter[63:32];\n    counter_load[31:0]  = counter_val_i;\n    if (counterh_we_i) begin\n      counter_load[63:32] = counter_val_i;\n      counter_load[31:0]  = counter[31:0];\n    end\n\n    // Next value logic\n    if (we) begin\n      counter_d = counter_load[CounterWidth-1:0];\n    end else if (counter_inc_i) begin\n      counter_d = counter_upd[CounterWidth-1:0];\n    end else begin\n      counter_d = counter[CounterWidth-1:0];\n    end\n  end\n\n`ifdef FPGA_XILINX\n  // Set DSP pragma for supported xilinx FPGAs\n  localparam int DspPragma = CounterWidth < 49 ? \"yes\" : \"no\";\n  (* use_dsp = DspPragma *) logic [CounterWidth-1:0] counter_q;\n\n  // DSP output register requires synchronous reset.\n  `define COUNTER_FLOP_RST posedge clk_i\n`else\n  logic [CounterWidth-1:0] counter_q;\n\n  `define COUNTER_FLOP_RST posedge clk_i or negedge rst_ni\n`endif\n\n  // Counter flop\n  always_ff @(`COUNTER_FLOP_RST) begin\n    if (!rst_ni) begin\n      counter_q <= '0;\n    end else begin\n      counter_q <= counter_d;\n    end\n  end\n\n  if (CounterWidth < 64) begin : g_counter_narrow\n    logic [63:CounterWidth] unused_counter_load;\n\n    assign counter[CounterWidth-1:0]           = counter_q;\n    assign counter[63:CounterWidth]            = '0;\n\n    if (ProvideValUpd) begin : g_counter_val_upd_o\n      assign counter_val_upd_o[CounterWidth-1:0] = counter_upd;\n    end else begin : g_no_counter_val_upd_o\n      assign counter_val_upd_o[CounterWidth-1:0] = '0;\n    end\n    assign counter_val_upd_o[63:CounterWidth]  = '0;\n    assign unused_counter_load                 = counter_load[63:CounterWidth];\n  end else begin : g_counter_full\n    assign counter           = counter_q;\n\n    if (ProvideValUpd) begin : g_counter_val_upd_o\n      assign counter_val_upd_o = counter_upd;\n    end else begin : g_no_counter_val_upd_o\n      assign counter_val_upd_o = '0;\n    end\n  end\n\n  assign counter_val_o = counter;\n\nendmodule\n\n// Keep helper defines file-local.\n`undef COUNTER_FLOP_RST\n"}
{"text": "// Copyright lowRISC contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Control / status register primitive\n */\n\n`include \"prim_assert.sv\"\n\nmodule ibex_csr #(\n  parameter int unsigned    Width      = 32,\n  parameter bit             ShadowCopy = 1'b0,\n  parameter bit [Width-1:0] ResetValue = '0\n ) (\n  input  logic             clk_i,\n  input  logic             rst_ni,\n\n  input  logic [Width-1:0] wr_data_i,\n  input  logic             wr_en_i,\n  output logic [Width-1:0] rd_data_o,\n\n  output logic             rd_error_o\n);\n\n  logic [Width-1:0] rdata_q;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      rdata_q <= ResetValue;\n    end else if (wr_en_i) begin\n      rdata_q <= wr_data_i;\n    end\n  end\n\n  assign rd_data_o = rdata_q;\n\n  if (ShadowCopy) begin : gen_shadow\n    logic [Width-1:0] shadow_q;\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        shadow_q <= ~ResetValue;\n      end else if (wr_en_i) begin\n        shadow_q <= ~wr_data_i;\n      end\n    end\n\n    assign rd_error_o = rdata_q != ~shadow_q;\n\n  end else begin : gen_no_shadow\n    assign rd_error_o = 1'b0;\n  end\n\n  `ASSERT_KNOWN(IbexCSREnValid, wr_en_i)\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Control and Status Registers\n */\n\n`include \"prim_assert.sv\"\n\nmodule ibex_cs_registers #(\n  parameter bit               DbgTriggerEn      = 0,\n  parameter int unsigned      DbgHwBreakNum     = 1,\n  parameter bit               DataIndTiming     = 1'b0,\n  parameter bit               DummyInstructions = 1'b0,\n  parameter bit               ShadowCSR         = 1'b0,\n  parameter bit               ICache            = 1'b0,\n  parameter int unsigned      MHPMCounterNum    = 10,\n  parameter int unsigned      MHPMCounterWidth  = 40,\n  parameter bit               PMPEnable         = 0,\n  parameter int unsigned      PMPGranularity    = 0,\n  parameter int unsigned      PMPNumRegions     = 4,\n  parameter bit               RV32E             = 0,\n  parameter ibex_pkg::rv32m_e RV32M             = ibex_pkg::RV32MFast,\n  parameter ibex_pkg::rv32b_e RV32B             = ibex_pkg::RV32BNone\n) (\n  // Clock and Reset\n  input  logic                 clk_i,\n  input  logic                 rst_ni,\n\n  // Hart ID\n  input  logic [31:0]          hart_id_i,\n\n  // Privilege mode\n  output ibex_pkg::priv_lvl_e  priv_mode_id_o,\n  output ibex_pkg::priv_lvl_e  priv_mode_lsu_o,\n  output logic                 csr_mstatus_tw_o,\n\n  // mtvec\n  output logic [31:0]          csr_mtvec_o,\n  input  logic                 csr_mtvec_init_i,\n  input  logic [31:0]          boot_addr_i,\n\n  // Interface to registers (SRAM like)\n  input  logic                 csr_access_i,\n  input  ibex_pkg::csr_num_e   csr_addr_i,\n  input  logic [31:0]          csr_wdata_i,\n  input  ibex_pkg::csr_op_e    csr_op_i,\n  input                        csr_op_en_i,\n  output logic [31:0]          csr_rdata_o,\n\n  // interrupts\n  input  logic                 irq_software_i,\n  input  logic                 irq_timer_i,\n  input  logic                 irq_external_i,\n  input  logic [14:0]          irq_fast_i,\n  input  logic                 nmi_mode_i,\n  output logic                 irq_pending_o,          // interrupt request pending\n  output ibex_pkg::irqs_t      irqs_o,                 // interrupt requests qualified with mie\n  output logic                 csr_mstatus_mie_o,\n  output logic [31:0]          csr_mepc_o,\n  output logic [31:0]          csr_mtval_o,\n\n  // PMP\n  output ibex_pkg::pmp_cfg_t     csr_pmp_cfg_o  [PMPNumRegions],\n  output logic [33:0]            csr_pmp_addr_o [PMPNumRegions],\n  output ibex_pkg::pmp_mseccfg_t csr_pmp_mseccfg_o,\n\n  // debug\n  input  logic                 debug_mode_i,\n  input  logic                 debug_mode_entering_i,\n  input  ibex_pkg::dbg_cause_e debug_cause_i,\n  input  logic                 debug_csr_save_i,\n  output logic [31:0]          csr_depc_o,\n  output logic                 debug_single_step_o,\n  output logic                 debug_ebreakm_o,\n  output logic                 debug_ebreaku_o,\n  output logic                 trigger_match_o,\n\n  input  logic [31:0]          pc_if_i,\n  input  logic [31:0]          pc_id_i,\n  input  logic [31:0]          pc_wb_i,\n\n  // CPU control and status bits\n  output logic                 data_ind_timing_o,\n  output logic                 dummy_instr_en_o,\n  output logic [2:0]           dummy_instr_mask_o,\n  output logic                 dummy_instr_seed_en_o,\n  output logic [31:0]          dummy_instr_seed_o,\n  output logic                 icache_enable_o,\n  output logic                 csr_shadow_err_o,\n  input  logic                 ic_scr_key_valid_i,\n\n  // Exception save/restore\n  input  logic                 csr_save_if_i,\n  input  logic                 csr_save_id_i,\n  input  logic                 csr_save_wb_i,\n  input  logic                 csr_restore_mret_i,\n  input  logic                 csr_restore_dret_i,\n  input  logic                 csr_save_cause_i,\n  input  ibex_pkg::exc_cause_t csr_mcause_i,\n  input  logic [31:0]          csr_mtval_i,\n  output logic                 illegal_csr_insn_o,     // access to non-existent CSR,\n                                                        // with wrong priviledge level, or\n                                                        // missing write permissions\n  output logic                 double_fault_seen_o,\n  // Performance Counters\n  input  logic                 instr_ret_i,                 // instr retired in ID/EX stage\n  input  logic                 instr_ret_compressed_i,      // compressed instr retired\n  input  logic                 instr_ret_spec_i,            // speculative instr_ret_i\n  input  logic                 instr_ret_compressed_spec_i, // speculative instr_ret_compressed_i\n  input  logic                 iside_wait_i,                // core waiting for the iside\n  input  logic                 jump_i,                      // jump instr seen (j, jr, jal, jalr)\n  input  logic                 branch_i,                    // branch instr seen (bf, bnf)\n  input  logic                 branch_taken_i,              // branch was taken\n  input  logic                 mem_load_i,                  // load from memory in this cycle\n  input  logic                 mem_store_i,                 // store to memory in this cycle\n  input  logic                 dside_wait_i,                // core waiting for the dside\n  input  logic                 mul_wait_i,                  // core waiting for multiply\n  input  logic                 div_wait_i                   // core waiting for divide\n);\n\n  import ibex_pkg::*;\n\n  // Is a PMP config a locked one that allows M-mode execution when MSECCFG.MML is set (either\n  // M mode alone or shared M/U mode execution)?\n  function automatic logic is_mml_m_exec_cfg(ibex_pkg::pmp_cfg_t pmp_cfg);\n    logic unused_cfg = ^{pmp_cfg.mode};\n    logic value = 1'b0;\n\n    if (pmp_cfg.lock) begin\n      unique case ({pmp_cfg.read, pmp_cfg.write, pmp_cfg.exec})\n        3'b001, 3'b010, 3'b011, 3'b101: value = 1'b1;\n        default: value = 1'b0;\n      endcase\n    end\n\n    return value;\n  endfunction\n\n  // All bitmanip configs enable non-ratified sub-extensions\n  localparam int unsigned RV32BExtra   = (RV32B != RV32BNone) ? 1 : 0;\n  localparam int unsigned RV32MEnabled = (RV32M == RV32MNone) ? 0 : 1;\n  localparam int unsigned PMPAddrWidth = (PMPGranularity > 0) ? 33 - PMPGranularity : 32;\n\n  // misa\n  localparam logic [31:0] MISA_VALUE =\n      (0                 <<  0)  // A - Atomic Instructions extension\n    | (0                 <<  1)  // B - Bit-Manipulation extension\n    | (1                 <<  2)  // C - Compressed extension\n    | (0                 <<  3)  // D - Double precision floating-point extension\n    | (32'(RV32E)        <<  4)  // E - RV32E base ISA\n    | (0                 <<  5)  // F - Single precision floating-point extension\n    | (32'(!RV32E)       <<  8)  // I - RV32I/64I/128I base ISA\n    | (RV32MEnabled      << 12)  // M - Integer Multiply/Divide extension\n    | (0                 << 13)  // N - User level interrupts supported\n    | (0                 << 18)  // S - Supervisor mode implemented\n    | (1                 << 20)  // U - User mode implemented\n    | (RV32BExtra        << 23)  // X - Non-standard extensions present\n    | (32'(CSR_MISA_MXL) << 30); // M-XLEN\n\n  typedef struct packed {\n    logic      mie;\n    logic      mpie;\n    priv_lvl_e mpp;\n    logic      mprv;\n    logic      tw;\n  } status_t;\n\n  typedef struct packed {\n    logic      mpie;\n    priv_lvl_e mpp;\n  } status_stk_t;\n\n  typedef struct packed {\n      x_debug_ver_e xdebugver;\n      logic [11:0]  zero2;\n      logic         ebreakm;\n      logic         zero1;\n      logic         ebreaks;\n      logic         ebreaku;\n      logic         stepie;\n      logic         stopcount;\n      logic         stoptime;\n      dbg_cause_e   cause;\n      logic         zero0;\n      logic         mprven;\n      logic         nmip;\n      logic         step;\n      priv_lvl_e    prv;\n  } dcsr_t;\n\n  // Partial CPU control and status register fields\n  // ICache scramble key valid (ic_scr_key_valid) is registered seperately to this struct. This is\n  // because it is sampled from the top-level every cycle whilst the other fields only change\n  // occasionally.\n  typedef struct packed {\n    logic        double_fault_seen;\n    logic        sync_exc_seen;\n    logic [2:0]  dummy_instr_mask;\n    logic        dummy_instr_en;\n    logic        data_ind_timing;\n    logic        icache_enable;\n  } cpu_ctrl_sts_part_t;\n\n  // Interrupt and exception control signals\n  logic [31:0] exception_pc;\n\n  // CSRs\n  priv_lvl_e   priv_lvl_q, priv_lvl_d;\n  status_t     mstatus_q, mstatus_d;\n  logic        mstatus_err;\n  logic        mstatus_en;\n  irqs_t       mie_q, mie_d;\n  logic        mie_en;\n  logic [31:0] mscratch_q;\n  logic        mscratch_en;\n  logic [31:0] mepc_q, mepc_d;\n  logic        mepc_en;\n  exc_cause_t  mcause_q, mcause_d;\n  logic        mcause_en;\n  logic [31:0] mtval_q, mtval_d;\n  logic        mtval_en;\n  logic [31:0] mtvec_q, mtvec_d;\n  logic        mtvec_err;\n  logic        mtvec_en;\n  irqs_t       mip;\n  dcsr_t       dcsr_q, dcsr_d;\n  logic        dcsr_en;\n  logic [31:0] depc_q, depc_d;\n  logic        depc_en;\n  logic [31:0] dscratch0_q;\n  logic [31:0] dscratch1_q;\n  logic        dscratch0_en, dscratch1_en;\n\n  // CSRs for recoverable NMIs\n  // NOTE: these CSRS are nonstandard, see https://github.com/riscv/riscv-isa-manual/issues/261\n  status_stk_t mstack_q, mstack_d;\n  logic        mstack_en;\n  logic [31:0] mstack_epc_q, mstack_epc_d;\n  exc_cause_t  mstack_cause_q, mstack_cause_d;\n\n  // PMP Signals\n  logic [31:0]                 pmp_addr_rdata  [PMP_MAX_REGIONS];\n  logic [PMP_CFG_W-1:0]        pmp_cfg_rdata   [PMP_MAX_REGIONS];\n  logic                        pmp_csr_err;\n  pmp_mseccfg_t                pmp_mseccfg;\n\n  // Hardware performance monitor signals\n  logic [31:0]                 mcountinhibit;\n  // Only have mcountinhibit flops for counters that actually exist\n  logic [MHPMCounterNum+3-1:0] mcountinhibit_d, mcountinhibit_q;\n  logic                        mcountinhibit_we;\n\n  // mhpmcounter flops are elaborated below providing only the precise number that is required based\n  // on MHPMCounterNum/MHPMCounterWidth. This signal connects to the Q output of these flops\n  // where they exist and is otherwise 0.\n  logic [63:0] mhpmcounter [32];\n  logic [31:0] mhpmcounter_we;\n  logic [31:0] mhpmcounterh_we;\n  logic [31:0] mhpmcounter_incr;\n  logic [31:0] mhpmevent [32];\n  logic  [4:0] mhpmcounter_idx;\n  logic        unused_mhpmcounter_we_1;\n  logic        unused_mhpmcounterh_we_1;\n  logic        unused_mhpmcounter_incr_1;\n\n  logic [63:0] minstret_next, minstret_raw;\n\n  // Debug / trigger registers\n  logic [31:0] tselect_rdata;\n  logic [31:0] tmatch_control_rdata;\n  logic [31:0] tmatch_value_rdata;\n\n  // CPU control bits\n  cpu_ctrl_sts_part_t cpuctrlsts_part_q, cpuctrlsts_part_d;\n  cpu_ctrl_sts_part_t cpuctrlsts_part_wdata_raw, cpuctrlsts_part_wdata;\n  logic               cpuctrlsts_part_we;\n  logic               cpuctrlsts_part_err;\n\n  logic cpuctrlsts_ic_scr_key_valid_q;\n  logic cpuctrlsts_ic_scr_key_err;\n\n  // CSR update logic\n  logic [31:0] csr_wdata_int;\n  logic [31:0] csr_rdata_int;\n  logic        csr_we_int;\n  logic        csr_wr;\n\n  // Access violation signals\n  logic        dbg_csr;\n  logic        illegal_csr;\n  logic        illegal_csr_priv;\n  logic        illegal_csr_dbg;\n  logic        illegal_csr_write;\n\n  logic [7:0]  unused_boot_addr;\n  logic [2:0]  unused_csr_addr;\n\n  assign unused_boot_addr = boot_addr_i[7:0];\n\n  /////////////\n  // CSR reg //\n  /////////////\n\n  logic [$bits(csr_num_e)-1:0] csr_addr;\n  assign csr_addr           = {csr_addr_i};\n  assign unused_csr_addr    = csr_addr[7:5];\n  assign mhpmcounter_idx    = csr_addr[4:0];\n\n  assign illegal_csr_dbg    = dbg_csr & ~debug_mode_i;\n  assign illegal_csr_priv   = (csr_addr[9:8] > {priv_lvl_q});\n  assign illegal_csr_write  = (csr_addr[11:10] == 2'b11) && csr_wr;\n  assign illegal_csr_insn_o = csr_access_i & (illegal_csr | illegal_csr_write | illegal_csr_priv |\n                                              illegal_csr_dbg);\n\n  // mip CSR is purely combinational - must be able to re-enable the clock upon WFI\n  assign mip.irq_software = irq_software_i;\n  assign mip.irq_timer    = irq_timer_i;\n  assign mip.irq_external = irq_external_i;\n  assign mip.irq_fast     = irq_fast_i;\n\n  // read logic\n  always_comb begin\n    csr_rdata_int = '0;\n    illegal_csr   = 1'b0;\n    dbg_csr       = 1'b0;\n\n    unique case (csr_addr_i)\n      // mvendorid: encoding of manufacturer/provider\n      CSR_MVENDORID: csr_rdata_int = CSR_MVENDORID_VALUE;\n      // marchid: encoding of base microarchitecture\n      CSR_MARCHID: csr_rdata_int = CSR_MARCHID_VALUE;\n      // mimpid: encoding of processor implementation version\n      CSR_MIMPID: csr_rdata_int = CSR_MIMPID_VALUE;\n      // mhartid: unique hardware thread id\n      CSR_MHARTID: csr_rdata_int = hart_id_i;\n      // mconfigptr: pointer to configuration data structre\n      CSR_MCONFIGPTR: csr_rdata_int = CSR_MCONFIGPTR_VALUE;\n\n      // mstatus: always M-mode, contains IE bit\n      CSR_MSTATUS: begin\n        csr_rdata_int                                                   = '0;\n        csr_rdata_int[CSR_MSTATUS_MIE_BIT]                              = mstatus_q.mie;\n        csr_rdata_int[CSR_MSTATUS_MPIE_BIT]                             = mstatus_q.mpie;\n        csr_rdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW] = mstatus_q.mpp;\n        csr_rdata_int[CSR_MSTATUS_MPRV_BIT]                             = mstatus_q.mprv;\n        csr_rdata_int[CSR_MSTATUS_TW_BIT]                               = mstatus_q.tw;\n      end\n\n      // mstatush: All zeros for Ibex (fixed little endian and all other bits reserved)\n      CSR_MSTATUSH: csr_rdata_int = '0;\n\n      // menvcfg: machine environment configuration, all zeros for Ibex (none of the relevant\n      // features are implemented)\n      CSR_MENVCFG, CSR_MENVCFGH: csr_rdata_int = '0;\n\n      // misa\n      CSR_MISA: csr_rdata_int = MISA_VALUE;\n\n      // interrupt enable\n      CSR_MIE: begin\n        csr_rdata_int                                     = '0;\n        csr_rdata_int[CSR_MSIX_BIT]                       = mie_q.irq_software;\n        csr_rdata_int[CSR_MTIX_BIT]                       = mie_q.irq_timer;\n        csr_rdata_int[CSR_MEIX_BIT]                       = mie_q.irq_external;\n        csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mie_q.irq_fast;\n      end\n\n      // mcounteren: machine counter enable\n      CSR_MCOUNTEREN: begin\n        csr_rdata_int = '0;\n      end\n\n      CSR_MSCRATCH: csr_rdata_int = mscratch_q;\n\n      // mtvec: trap-vector base address\n      CSR_MTVEC: csr_rdata_int = mtvec_q;\n\n      // mepc: exception program counter\n      CSR_MEPC: csr_rdata_int = mepc_q;\n\n      // mcause: exception cause\n      CSR_MCAUSE: csr_rdata_int = {mcause_q.irq_ext | mcause_q.irq_int,\n                                   mcause_q.irq_int ? {26{1'b1}} : 26'b0,\n                                   mcause_q.lower_cause[4:0]};\n\n      // mtval: trap value\n      CSR_MTVAL: csr_rdata_int = mtval_q;\n\n      // mip: interrupt pending\n      CSR_MIP: begin\n        csr_rdata_int                                     = '0;\n        csr_rdata_int[CSR_MSIX_BIT]                       = mip.irq_software;\n        csr_rdata_int[CSR_MTIX_BIT]                       = mip.irq_timer;\n        csr_rdata_int[CSR_MEIX_BIT]                       = mip.irq_external;\n        csr_rdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW] = mip.irq_fast;\n      end\n\n      CSR_MSECCFG: begin\n        if (PMPEnable) begin\n          csr_rdata_int                       = '0;\n          csr_rdata_int[CSR_MSECCFG_MML_BIT]  = pmp_mseccfg.mml;\n          csr_rdata_int[CSR_MSECCFG_MMWP_BIT] = pmp_mseccfg.mmwp;\n          csr_rdata_int[CSR_MSECCFG_RLB_BIT]  = pmp_mseccfg.rlb;\n        end else begin\n          illegal_csr = 1'b1;\n        end\n      end\n\n      CSR_MSECCFGH: begin\n        if (PMPEnable) begin\n          csr_rdata_int = '0;\n        end else begin\n          illegal_csr = 1'b1;\n        end\n      end\n\n      // PMP registers\n      CSR_PMPCFG0:   csr_rdata_int = {pmp_cfg_rdata[3],  pmp_cfg_rdata[2],\n                                      pmp_cfg_rdata[1],  pmp_cfg_rdata[0]};\n      CSR_PMPCFG1:   csr_rdata_int = {pmp_cfg_rdata[7],  pmp_cfg_rdata[6],\n                                      pmp_cfg_rdata[5],  pmp_cfg_rdata[4]};\n      CSR_PMPCFG2:   csr_rdata_int = {pmp_cfg_rdata[11], pmp_cfg_rdata[10],\n                                      pmp_cfg_rdata[9],  pmp_cfg_rdata[8]};\n      CSR_PMPCFG3:   csr_rdata_int = {pmp_cfg_rdata[15], pmp_cfg_rdata[14],\n                                      pmp_cfg_rdata[13], pmp_cfg_rdata[12]};\n      CSR_PMPADDR0:  csr_rdata_int = pmp_addr_rdata[0];\n      CSR_PMPADDR1:  csr_rdata_int = pmp_addr_rdata[1];\n      CSR_PMPADDR2:  csr_rdata_int = pmp_addr_rdata[2];\n      CSR_PMPADDR3:  csr_rdata_int = pmp_addr_rdata[3];\n      CSR_PMPADDR4:  csr_rdata_int = pmp_addr_rdata[4];\n      CSR_PMPADDR5:  csr_rdata_int = pmp_addr_rdata[5];\n      CSR_PMPADDR6:  csr_rdata_int = pmp_addr_rdata[6];\n      CSR_PMPADDR7:  csr_rdata_int = pmp_addr_rdata[7];\n      CSR_PMPADDR8:  csr_rdata_int = pmp_addr_rdata[8];\n      CSR_PMPADDR9:  csr_rdata_int = pmp_addr_rdata[9];\n      CSR_PMPADDR10: csr_rdata_int = pmp_addr_rdata[10];\n      CSR_PMPADDR11: csr_rdata_int = pmp_addr_rdata[11];\n      CSR_PMPADDR12: csr_rdata_int = pmp_addr_rdata[12];\n      CSR_PMPADDR13: csr_rdata_int = pmp_addr_rdata[13];\n      CSR_PMPADDR14: csr_rdata_int = pmp_addr_rdata[14];\n      CSR_PMPADDR15: csr_rdata_int = pmp_addr_rdata[15];\n\n      CSR_DCSR: begin\n        csr_rdata_int = dcsr_q;\n        dbg_csr       = 1'b1;\n      end\n      CSR_DPC: begin\n        csr_rdata_int = depc_q;\n        dbg_csr       = 1'b1;\n      end\n      CSR_DSCRATCH0: begin\n        csr_rdata_int = dscratch0_q;\n        dbg_csr       = 1'b1;\n      end\n      CSR_DSCRATCH1: begin\n        csr_rdata_int = dscratch1_q;\n        dbg_csr       = 1'b1;\n      end\n\n      // machine counter/timers\n      CSR_MCOUNTINHIBIT: csr_rdata_int = mcountinhibit;\n      CSR_MHPMEVENT3,\n      CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,\n      CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,\n      CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,\n      CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,\n      CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,\n      CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,\n      CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31: begin\n        csr_rdata_int = mhpmevent[mhpmcounter_idx];\n      end\n\n      CSR_MCYCLE,\n      CSR_MINSTRET,\n      CSR_MHPMCOUNTER3,\n      CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,\n      CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,\n      CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,\n      CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,\n      CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,\n      CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,\n      CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin\n        csr_rdata_int = mhpmcounter[mhpmcounter_idx][31:0];\n      end\n\n      CSR_MCYCLEH,\n      CSR_MINSTRETH,\n      CSR_MHPMCOUNTER3H,\n      CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,\n      CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,\n      CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,\n      CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,\n      CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,\n      CSR_MHPMCOUNTER24H,"}
{"text": " CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,\n      CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin\n        csr_rdata_int = mhpmcounter[mhpmcounter_idx][63:32];\n      end\n\n      // Debug triggers\n      CSR_TSELECT: begin\n        csr_rdata_int = tselect_rdata;\n        illegal_csr   = ~DbgTriggerEn;\n      end\n      CSR_TDATA1: begin\n        csr_rdata_int = tmatch_control_rdata;\n        illegal_csr   = ~DbgTriggerEn;\n      end\n      CSR_TDATA2: begin\n        csr_rdata_int = tmatch_value_rdata;\n        illegal_csr   = ~DbgTriggerEn;\n      end\n      CSR_TDATA3: begin\n        csr_rdata_int = '0;\n        illegal_csr   = ~DbgTriggerEn;\n      end\n      CSR_MCONTEXT: begin\n        csr_rdata_int = '0;\n        illegal_csr   = ~DbgTriggerEn;\n      end\n      CSR_SCONTEXT: begin\n        csr_rdata_int = '0;\n        illegal_csr   = ~DbgTriggerEn;\n      end\n      CSR_MSCONTEXT: begin\n        csr_rdata_int = '0;\n        illegal_csr   = ~DbgTriggerEn;\n      end\n\n      // Custom CSR for controlling CPU features and reporting CPU status\n      CSR_CPUCTRLSTS: begin\n        csr_rdata_int = {{32 - $bits(cpu_ctrl_sts_part_t) - 1 {1'b0}},\n                         cpuctrlsts_ic_scr_key_valid_q,\n                         cpuctrlsts_part_q};\n      end\n\n      // Custom CSR for LFSR re-seeding (cannot be read)\n      CSR_SECURESEED: begin\n        csr_rdata_int = '0;\n      end\n\n      default: begin\n        illegal_csr = 1'b1;\n      end\n    endcase\n\n    if (!PMPEnable) begin\n      if (csr_addr inside {CSR_PMPCFG0,   CSR_PMPCFG1,   CSR_PMPCFG2,   CSR_PMPCFG3,\n                           CSR_PMPADDR0,  CSR_PMPADDR1,  CSR_PMPADDR2,  CSR_PMPADDR3,\n                           CSR_PMPADDR4,  CSR_PMPADDR5,  CSR_PMPADDR6,  CSR_PMPADDR7,\n                           CSR_PMPADDR8,  CSR_PMPADDR9,  CSR_PMPADDR10, CSR_PMPADDR11,\n                           CSR_PMPADDR12, CSR_PMPADDR13, CSR_PMPADDR14, CSR_PMPADDR15}) begin\n        illegal_csr = 1'b1;\n      end\n    end\n  end\n\n  // write logic\n  always_comb begin\n    exception_pc = pc_id_i;\n\n    priv_lvl_d   = priv_lvl_q;\n    mstatus_en   = 1'b0;\n    mstatus_d    = mstatus_q;\n    mie_en       = 1'b0;\n    mscratch_en  = 1'b0;\n    mepc_en      = 1'b0;\n    mepc_d       = {csr_wdata_int[31:1], 1'b0};\n    mcause_en    = 1'b0;\n    mcause_d     = '{irq_ext :    csr_wdata_int[31:30] == 2'b10,\n                     irq_int :    csr_wdata_int[31:30] == 2'b11,\n                     lower_cause: csr_wdata_int[4:0]};\n    mtval_en     = 1'b0;\n    mtval_d      = csr_wdata_int;\n    mtvec_en     = csr_mtvec_init_i;\n    // mtvec.MODE set to vectored\n    // mtvec.BASE must be 256-byte aligned\n    mtvec_d      = csr_mtvec_init_i ? {boot_addr_i[31:8], 6'b0, 2'b01} :\n                                      {csr_wdata_int[31:8], 6'b0, 2'b01};\n    dcsr_en      = 1'b0;\n    dcsr_d       = dcsr_q;\n    depc_d       = {csr_wdata_int[31:1], 1'b0};\n    depc_en      = 1'b0;\n    dscratch0_en = 1'b0;\n    dscratch1_en = 1'b0;\n\n    mstack_en      = 1'b0;\n    mstack_d.mpie  = mstatus_q.mpie;\n    mstack_d.mpp   = mstatus_q.mpp;\n    mstack_epc_d   = mepc_q;\n    mstack_cause_d = mcause_q;\n\n    mcountinhibit_we = 1'b0;\n    mhpmcounter_we   = '0;\n    mhpmcounterh_we  = '0;\n\n    cpuctrlsts_part_we = 1'b0;\n    cpuctrlsts_part_d  = cpuctrlsts_part_q;\n\n    double_fault_seen_o = 1'b0;\n\n    if (csr_we_int) begin\n      unique case (csr_addr_i)\n        // mstatus: IE bit\n        CSR_MSTATUS: begin\n          mstatus_en = 1'b1;\n          mstatus_d    = '{\n              mie:  csr_wdata_int[CSR_MSTATUS_MIE_BIT],\n              mpie: csr_wdata_int[CSR_MSTATUS_MPIE_BIT],\n              mpp:  priv_lvl_e'(csr_wdata_int[CSR_MSTATUS_MPP_BIT_HIGH:CSR_MSTATUS_MPP_BIT_LOW]),\n              mprv: csr_wdata_int[CSR_MSTATUS_MPRV_BIT],\n              tw:   csr_wdata_int[CSR_MSTATUS_TW_BIT]\n          };\n          // Convert illegal values to U-mode\n          if ((mstatus_d.mpp != PRIV_LVL_M) && (mstatus_d.mpp != PRIV_LVL_U)) begin\n            mstatus_d.mpp = PRIV_LVL_U;\n          end\n        end\n\n        // interrupt enable\n        CSR_MIE: mie_en = 1'b1;\n\n        CSR_MSCRATCH: mscratch_en = 1'b1;\n\n        // mepc: exception program counter\n        CSR_MEPC: mepc_en = 1'b1;\n\n        // mcause\n        CSR_MCAUSE: mcause_en = 1'b1;\n\n        // mtval: trap value\n        CSR_MTVAL: mtval_en = 1'b1;\n\n        // mtvec\n        CSR_MTVEC: mtvec_en = 1'b1;\n\n        CSR_DCSR: begin\n          dcsr_d = csr_wdata_int;\n          dcsr_d.xdebugver = XDEBUGVER_STD;\n          // Change to PRIV_LVL_U if software writes an unsupported value\n          if ((dcsr_d.prv != PRIV_LVL_M) && (dcsr_d.prv != PRIV_LVL_U)) begin\n            dcsr_d.prv = PRIV_LVL_U;\n          end\n\n          // Read-only for SW\n          dcsr_d.cause = dcsr_q.cause;\n\n          // Interrupts always disabled during single stepping\n          dcsr_d.stepie = 1'b0;\n\n          // currently not supported:\n          dcsr_d.nmip = 1'b0;\n          dcsr_d.mprven = 1'b0;\n          dcsr_d.stopcount = 1'b0;\n          dcsr_d.stoptime = 1'b0;\n\n          // forced to be zero\n          dcsr_d.zero0 = 1'b0;\n          dcsr_d.zero1 = 1'b0;\n          dcsr_d.zero2 = 12'h0;\n          dcsr_en      = 1'b1;\n        end\n\n        // dpc: debug program counter\n        CSR_DPC: depc_en = 1'b1;\n\n        CSR_DSCRATCH0: dscratch0_en = 1'b1;\n        CSR_DSCRATCH1: dscratch1_en = 1'b1;\n\n        // machine counter/timers\n        CSR_MCOUNTINHIBIT: mcountinhibit_we = 1'b1;\n\n        CSR_MCYCLE,\n        CSR_MINSTRET,\n        CSR_MHPMCOUNTER3,\n        CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,\n        CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,\n        CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,\n        CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,\n        CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,\n        CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,\n        CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31: begin\n          mhpmcounter_we[mhpmcounter_idx] = 1'b1;\n        end\n\n        CSR_MCYCLEH,\n        CSR_MINSTRETH,\n        CSR_MHPMCOUNTER3H,\n        CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,\n        CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,\n        CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,\n        CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,\n        CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,\n        CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,\n        CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H: begin\n          mhpmcounterh_we[mhpmcounter_idx] = 1'b1;\n        end\n\n        CSR_CPUCTRLSTS: begin\n          cpuctrlsts_part_d  = cpuctrlsts_part_wdata;\n          cpuctrlsts_part_we = 1'b1;\n        end\n\n        default:;\n      endcase\n    end\n\n    // exception controller gets priority over other writes\n    unique case (1'b1)\n\n      csr_save_cause_i: begin\n        unique case (1'b1)\n          csr_save_if_i: begin\n            exception_pc = pc_if_i;\n          end\n          csr_save_id_i: begin\n            exception_pc = pc_id_i;\n          end\n          csr_save_wb_i: begin\n            exception_pc = pc_wb_i;\n          end\n          default:;\n        endcase\n\n        // Any exception, including debug mode, causes a switch to M-mode\n        priv_lvl_d = PRIV_LVL_M;\n\n        if (debug_csr_save_i) begin\n          // all interrupts are masked\n          // do not update cause, epc, tval, epc and status\n          dcsr_d.prv   = priv_lvl_q;\n          dcsr_d.cause = debug_cause_i;\n          dcsr_en      = 1'b1;\n          depc_d       = exception_pc;\n          depc_en      = 1'b1;\n        end else if (!debug_mode_i) begin\n          // Exceptions do not update CSRs in debug mode, so ony write these CSRs if we're not in\n          // debug mode.\n          mtval_en       = 1'b1;\n          mtval_d        = csr_mtval_i;\n          mstatus_en     = 1'b1;\n          mstatus_d.mie  = 1'b0; // disable interrupts\n          // save current status\n          mstatus_d.mpie = mstatus_q.mie;\n          mstatus_d.mpp  = priv_lvl_q;\n          mepc_en        = 1'b1;\n          mepc_d         = exception_pc;\n          mcause_en      = 1'b1;\n          mcause_d       = csr_mcause_i;\n          // save previous status for recoverable NMI\n          mstack_en      = 1'b1;\n\n          if (!(mcause_d.irq_ext || mcause_d.irq_int)) begin\n            // SEC_CM: EXCEPTION.CTRL_FLOW.LOCAL_ESC\n            // SEC_CM: EXCEPTION.CTRL_FLOW.GLOBAL_ESC\n            cpuctrlsts_part_we = 1'b1;\n\n            cpuctrlsts_part_d.sync_exc_seen = 1'b1;\n            if (cpuctrlsts_part_q.sync_exc_seen) begin\n              double_fault_seen_o                 = 1'b1;\n              cpuctrlsts_part_d.double_fault_seen = 1'b1;\n            end\n          end\n        end\n      end // csr_save_cause_i\n\n      csr_restore_dret_i: begin // DRET\n        priv_lvl_d = dcsr_q.prv;\n      end // csr_restore_dret_i\n\n      csr_restore_mret_i: begin // MRET\n        priv_lvl_d     = mstatus_q.mpp;\n        mstatus_en     = 1'b1;\n        mstatus_d.mie  = mstatus_q.mpie; // re-enable interrupts\n\n        if (mstatus_q.mpp != PRIV_LVL_M) begin\n          mstatus_d.mprv = 1'b0;\n        end\n\n        // SEC_CM: EXCEPTION.CTRL_FLOW.LOCAL_ESC\n        // SEC_CM: EXCEPTION.CTRL_FLOW.GLOBAL_ESC\n        cpuctrlsts_part_we              = 1'b1;\n        cpuctrlsts_part_d.sync_exc_seen = 1'b0;\n\n        if (nmi_mode_i) begin\n          // when returning from an NMI restore state from mstack CSR\n          mstatus_d.mpie = mstack_q.mpie;\n          mstatus_d.mpp  = mstack_q.mpp;\n          mepc_en        = 1'b1;\n          mepc_d         = mstack_epc_q;\n          mcause_en      = 1'b1;\n          mcause_d       = mstack_cause_q;\n        end else begin\n          // otherwise just set mstatus.MPIE/MPP\n          mstatus_d.mpie = 1'b1;\n          mstatus_d.mpp  = PRIV_LVL_U;\n        end\n      end // csr_restore_mret_i\n\n      default:;\n    endcase\n  end\n\n  // Update current priv level\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      priv_lvl_q     <= PRIV_LVL_M;\n    end else begin\n      priv_lvl_q     <= priv_lvl_d;\n    end\n  end\n\n  // Send current priv level to the decoder\n  assign priv_mode_id_o = priv_lvl_q;\n  // Load/store instructions must factor in MPRV for PMP checking\n  assign priv_mode_lsu_o = mstatus_q.mprv ? mstatus_q.mpp : priv_lvl_q;\n\n  // CSR operation logic\n  always_comb begin\n    unique case (csr_op_i)\n      CSR_OP_WRITE: csr_wdata_int =  csr_wdata_i;\n      CSR_OP_SET:   csr_wdata_int =  csr_wdata_i | csr_rdata_o;\n      CSR_OP_CLEAR: csr_wdata_int = ~csr_wdata_i & csr_rdata_o;\n      CSR_OP_READ:  csr_wdata_int = csr_wdata_i;\n      default:      csr_wdata_int = csr_wdata_i;\n    endcase\n  end\n\n  assign csr_wr = (csr_op_i inside {CSR_OP_WRITE, CSR_OP_SET, CSR_OP_CLEAR});\n\n  // only write CSRs during one clock cycle\n  assign csr_we_int  = csr_wr & csr_op_en_i & ~illegal_csr_insn_o;\n\n  assign csr_rdata_o = csr_rdata_int;\n\n  // directly output some registers\n  assign csr_mepc_o  = mepc_q;\n  assign csr_depc_o  = depc_q;\n  assign csr_mtvec_o = mtvec_q;\n  assign csr_mtval_o = mtval_q;\n\n  assign csr_mstatus_mie_o   = mstatus_q.mie;\n  assign csr_mstatus_tw_o    = mstatus_q.tw;\n  assign debug_single_step_o = dcsr_q.step;\n  assign debug_ebreakm_o     = dcsr_q.ebreakm;\n  assign debug_ebreaku_o     = dcsr_q.ebreaku;\n\n  // Qualify incoming interrupt requests in mip CSR with mie CSR for controller and to re-enable\n  // clock upon WFI (must be purely combinational).\n  assign irqs_o        = mip & mie_q;\n  assign irq_pending_o = |irqs_o;\n\n  ////////////////////////\n  // CSR instantiations //\n  ////////////////////////\n\n  // MSTATUS\n  localparam status_t MSTATUS_RST_VAL = '{mie:  1'b0,\n                                          mpie: 1'b1,\n                                          mpp:  PRIV_LVL_U,\n                                          mprv: 1'b0,\n                                          tw:   1'b0};\n  ibex_csr #(\n    .Width     ($bits(status_t)),\n    .ShadowCopy(ShadowCSR),\n    .ResetValue({MSTATUS_RST_VAL})\n  ) u_mstatus_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i ({mstatus_d}),\n    .wr_en_i   (mstatus_en),\n    .rd_data_o (mstatus_q),\n    .rd_error_o(mstatus_err)\n  );\n\n  // MEPC\n  ibex_csr #(\n    .Width     (32),\n    .ShadowCopy(1'b0),\n    .ResetValue('0)\n  ) u_mepc_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i (mepc_d),\n    .wr_en_i   (mepc_en),\n    .rd_data_o (mepc_q),\n    .rd_error_o()\n  );\n\n  // MIE\n  assign mie_d.irq_software = csr_wdata_int[CSR_MSIX_BIT];\n  assign mie_d.irq_timer    = csr_wdata_int[CSR_MTIX_BIT];\n  assign mie_d.irq_external = csr_wdata_int[CSR_MEIX_BIT];\n  assign mie_d.irq_fast     = csr_wdata_int[CSR_MFIX_BIT_HIGH:CSR_MFIX_BIT_LOW];\n  ibex_csr #(\n    .Width     ($bits(irqs_t)),\n    .ShadowCopy(1'b0),\n    .ResetValue('0)\n  ) u_mie_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i ({mie_d}),\n    .wr_en_i   (mie_en),\n    .rd_data_o (mie_q),\n    .rd_error_o()\n  );\n\n  // MSCRATCH\n  ibex_csr #(\n    .Width     (32),\n    .ShadowCopy(1'b0),\n    .ResetValue('0)\n  ) u_mscratch_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i (csr_wdata_int),\n    .wr_en_i   (mscratch_en),\n    .rd_data_o (mscratch_q),\n    .rd_error_o()\n  );\n\n  // MCAUSE\n  ibex_csr #(\n    .Width     ($bits(exc_cause_t)),\n    .ShadowCopy(1'b0),\n    .ResetValue('0)\n  ) u_mcause_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i ({mcause_d}),\n    .wr_en_i   (mcause_en),\n    .rd_data_o (mcause_q),\n    .rd_error_o()\n  );\n\n  // MTVAL\n  ibex_csr #(\n    .Width     (32),\n    .ShadowCopy(1'b0),\n    .ResetValue('0)\n  ) u_mtval_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i (mtval_d),\n    .wr_en_i   (mtval_en),\n    .rd_data_o (mtval_q),\n    .rd_error_o()\n  );\n\n  // MTVEC\n  ibex_csr #(\n    .Width     (32),\n    .ShadowCopy(ShadowCSR),\n    .ResetValue(32'd1)\n  ) u_mtvec_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i (mtvec_d),\n    .wr_en_i   (mtvec_en),\n    .rd_data_o (mtvec_q),\n    .rd_error_o(mtvec_err)\n  );\n\n  // DCSR\n  localparam dcsr_t DCSR_RESET_VAL = '{\n      xdebugver: XDEBUGVER_STD,\n      cause: DBG_CAUSE_NONE,  // 3'h0\n      prv: PRIV_LVL_M,\n      default: '0\n  };\n  ibex_csr #(\n    .Width     ($bits(dcsr_t)),\n    .ShadowCopy(1'b0),\n    .ResetValue({DCSR_RESET_VAL})\n  ) u_dcsr_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i ({dcsr_d}),\n    .wr_en_i   (dcsr_en),\n    .rd_data_o (dcsr_q),\n    .rd_error_o()\n  );\n\n  // DEPC\n  ibex_csr #(\n    .Width     (32),\n    .ShadowCopy(1'b0),\n    .ResetValue('0)\n  ) u_depc_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i (depc_d),\n    .wr_en_i   (depc_en),\n    .rd_data_o (depc_q),\n    .rd_error_o()\n  );\n\n  // DSCRATCH0\n  ibex_csr #(\n    .Width     (32),\n    .ShadowCopy(1'b0),\n    .ResetValue('0)\n  ) u_dscratch0_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i (csr_wdata_int),\n    .wr_en_i   (dscratch0_en),\n    .rd_data_o (dscratch0_q),\n    .rd_error_o()\n  );\n\n  // DSCRATCH1\n  ibex_csr #(\n    .Width     (32),\n    .ShadowCopy(1'b0),\n    .ResetValue('0)\n  ) u_dscratch1_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i (csr_wdata_int),\n    .wr_en_i   (dscratch1_en),\n    .rd_data_o (dscratch1_q),\n    .rd_error_o()\n  );\n\n  // MSTACK\n  localparam status_stk_t MSTACK_RESET_VAL = '{mpie: 1'b1, mpp: PRIV_LVL_U};\n  ibex_csr #(\n    .Width     ($bits(status_stk_t)),\n    .ShadowCopy(1'b0),\n    .ResetValue({MSTACK_RESET_VAL})\n  ) u_mstack_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i ({mstack_d}),\n    .wr_en_i   (mstack_en),\n    .rd_data_o (mstack_q),\n    .rd_error_o()\n  );\n\n  // MSTACK_EPC\n  ibex_csr #(\n    .Width     (32),\n    .ShadowCopy(1'b0),\n    .ResetValue('0)\n  ) u_mstack_epc_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i (mstack_epc_d),\n    .wr_en_i   (mstack_en),\n    .rd_data_o (mstack_epc_q),\n    .rd_error_o()\n  );\n\n  // MSTACK_CAUSE\n  ibex_csr #(\n    .Width     ($bits(exc_cause_t)),\n    .ShadowCopy(1'b0),\n    .ResetValue('0)\n  ) u_mstack_cause_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i (mstack_cause_d),\n    .wr_en_i   (mstack_en),\n    .rd_data_o (mstack_cause_q),\n    .rd_error_o()\n  );\n\n  // -----------------\n  // PMP registers\n  // -----------------\n\n  if (PMPEnable) begin : g_pmp_registers\n    // PMP reset values\n    `ifdef IBEX_CUSTOM_PMP_RESET_VALUES\n      `include \"ibex_pmp_reset.svh\"\n    `else\n      `include \"ibex_pmp_reset_default.svh\"\n    `endif\n\n    pmp_mseccfg_t                pmp_mseccfg_q, pmp_mseccfg_d;\n    logic                        pmp_mseccfg_we;\n    logic                        pmp_mseccfg_err;\n    pmp_cfg_t                    pmp_cfg         [PMPNumRegions];\n    logic [PMPNumRegions-1:0]    pmp_cfg_locked;\n    logic [PMPNumRegions-1:0]    pmp_cfg_wr_suppress;\n    pmp_cfg_t                    pmp_cfg_wdata   [PMPNumRegions];\n    logic [PMPAddrWidth-1:0]     pmp_addr        [PMPNumRegions];\n    logic [PMPNumRegions-1:0]    pmp_cfg_we;\n    logic [PMPNumRegions-1:0]    pmp_cfg_err;\n    logic [PMPNumRegions-1:0]    pmp_addr_we;\n    logic [PMPNumRegions-1:0]    pmp_addr_err;\n    logic                        any_pmp_entry_locked;\n\n    // Expanded / qualified register read data\n    for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_exp_rd_data\n      if (i < PMPNumRegions) begin : g_implemented_regions\n        // Add in zero padding for reserved fields\n        assign pmp_cfg_rdata[i] = {pmp_cfg[i].lock, 2'b00, pmp_cfg[i].mode,\n                                   pmp_cfg[i].exec, pmp_cfg[i].write, pmp_cfg[i].read};\n\n        // Address field read data depends on the current programmed mode and the granularity\n        if (PMPGranularity == 0) begin : g_pmp_g0\n          // If G == 0, read data is unmodified\n          assign pmp_addr_rdata[i] = pmp_addr[i];\n\n        end else if (PMPGranularity == 1) begin : g_pmp_g1\n          // If G == 1, bit [G-1] reads as zero in TOR or OFF mode\n          always_comb begin\n            pmp_addr_rdata[i] = pmp_addr[i];\n            if ((pmp_cfg[i].mode == PMP_MODE_OFF) || (pmp_cfg[i].mode == PMP_MODE_TOR)) begin\n              pmp_addr_rdata[i][PMPGranularity-1:0] = '0;\n            end\n          end\n\n        end else begin : g_pmp_g2\n          // For G >= 2, bits are masked to one or zero depending on the mode\n          always_comb begin\n            // In NAPOT mode, bits [G-2:0] must read as one\n            pmp_addr_rdata[i] = {pmp_addr[i], {PMPGranularity - 1{1'b1}}};\n\n            if ((pmp_cfg[i].mode == PMP_MODE_OFF) || (pmp_cfg[i].mode == PMP_MODE_TOR)) begin\n              // In TOR or OFF mode, bits [G-1:0] must read as zero\n              pmp_addr_rdata[i][PMPGranularity-1:0] = '0;\n            end\n          end\n        end\n\n      end else begin : g_other_regions\n        // Non-implemented regions read as zero\n        assign pmp_cfg_rdata[i]  = '0;\n        assign pmp_addr_rdata[i] = '0;\n      end\n    end\n\n    // Write data calculation\n    for (genvar i = 0; i < PMPNumRegions; i++) begin : g_pmp_csrs\n      // -------------------------\n      // Instantiate cfg registers\n      // -------------------------\n      assign pmp_cfg_we[i] = csr_we_int                                       &\n                             ~pmp_cfg_locked[i]                               &\n                             ~pmp_cfg_wr_suppress[i]                          &\n                             (csr_addr == (CSR_OFF_PMP_CFG + (i[11:0] >> 2)));\n\n      // Select the correct WDATA (each CSR contains 4 CFG fields, each with 2 RES bits)\n     "}
{"text": " assign pmp_cfg_wdata[i].lock  = csr_wdata_int[(i%4)*PMP_CFG_W+7];\n      // NA4 mode is not selectable when G > 0, mode is treated as OFF\n      always_comb begin\n        unique case (csr_wdata_int[(i%4)*PMP_CFG_W+3+:2])\n          2'b00   : pmp_cfg_wdata[i].mode = PMP_MODE_OFF;\n          2'b01   : pmp_cfg_wdata[i].mode = PMP_MODE_TOR;\n          2'b10   : pmp_cfg_wdata[i].mode = (PMPGranularity == 0) ? PMP_MODE_NA4:\n                                                                    PMP_MODE_OFF;\n          2'b11   : pmp_cfg_wdata[i].mode = PMP_MODE_NAPOT;\n          default : pmp_cfg_wdata[i].mode = PMP_MODE_OFF;\n        endcase\n      end\n      assign pmp_cfg_wdata[i].exec  = csr_wdata_int[(i%4)*PMP_CFG_W+2];\n      // When MSECCFG.MML is unset, W = 1, R = 0 is a reserved combination, so force W to 0 if R ==\n      // 0. Otherwise allow all possible values to be written.\n      assign pmp_cfg_wdata[i].write = pmp_mseccfg_q.mml ? csr_wdata_int[(i%4)*PMP_CFG_W+1] :\n                                                          &csr_wdata_int[(i%4)*PMP_CFG_W+:2];\n      assign pmp_cfg_wdata[i].read  = csr_wdata_int[(i%4)*PMP_CFG_W];\n\n      ibex_csr #(\n        .Width     ($bits(pmp_cfg_t)),\n        .ShadowCopy(ShadowCSR),\n        .ResetValue(pmp_cfg_rst[i])\n      ) u_pmp_cfg_csr (\n        .clk_i     (clk_i),\n        .rst_ni    (rst_ni),\n        .wr_data_i ({pmp_cfg_wdata[i]}),\n        .wr_en_i   (pmp_cfg_we[i]),\n        .rd_data_o (pmp_cfg[i]),\n        .rd_error_o(pmp_cfg_err[i])\n      );\n\n      // MSECCFG.RLB allows the lock bit to be bypassed (allowing cfg writes when MSECCFG.RLB is\n      // set).\n      assign pmp_cfg_locked[i] = pmp_cfg[i].lock & ~pmp_mseccfg_q.rlb;\n\n      // When MSECCFG.MML is set cannot add new regions allowing M mode execution unless MSECCFG.RLB\n      // is set\n      assign pmp_cfg_wr_suppress[i] = pmp_mseccfg_q.mml                   &\n                                      ~pmp_mseccfg.rlb                    &\n                                      is_mml_m_exec_cfg(pmp_cfg_wdata[i]);\n\n      // --------------------------\n      // Instantiate addr registers\n      // --------------------------\n      if (i < PMPNumRegions - 1) begin : g_lower\n        assign pmp_addr_we[i] = csr_we_int & ~pmp_cfg_locked[i] &\n                                (~pmp_cfg_locked[i+1] | (pmp_cfg[i+1].mode != PMP_MODE_TOR)) &\n                                (csr_addr == (CSR_OFF_PMP_ADDR + i[11:0]));\n      end else begin : g_upper\n        assign pmp_addr_we[i] = csr_we_int & ~pmp_cfg_locked[i] &\n                                (csr_addr == (CSR_OFF_PMP_ADDR + i[11:0]));\n      end\n\n      ibex_csr #(\n        .Width     (PMPAddrWidth),\n        .ShadowCopy(ShadowCSR),\n        .ResetValue(pmp_addr_rst[i][33-:PMPAddrWidth])\n      ) u_pmp_addr_csr (\n        .clk_i     (clk_i),\n        .rst_ni    (rst_ni),\n        .wr_data_i (csr_wdata_int[31-:PMPAddrWidth]),\n        .wr_en_i   (pmp_addr_we[i]),\n        .rd_data_o (pmp_addr[i]),\n        .rd_error_o(pmp_addr_err[i])\n      );\n\n      `ASSERT_INIT(PMPAddrRstLowBitsZero_A, pmp_addr_rst[i][33-PMPAddrWidth:0] == '0)\n\n      assign csr_pmp_cfg_o[i]  = pmp_cfg[i];\n      assign csr_pmp_addr_o[i] = {pmp_addr_rdata[i], 2'b00};\n    end\n\n    assign pmp_mseccfg_we = csr_we_int & (csr_addr == CSR_MSECCFG);\n\n    // MSECCFG.MML/MSECCFG.MMWP cannot be unset once set\n    assign pmp_mseccfg_d.mml  = pmp_mseccfg_q.mml  ? 1'b1 : csr_wdata_int[CSR_MSECCFG_MML_BIT];\n    assign pmp_mseccfg_d.mmwp = pmp_mseccfg_q.mmwp ? 1'b1 : csr_wdata_int[CSR_MSECCFG_MMWP_BIT];\n\n    // pmp_cfg_locked factors in MSECCFG.RLB so any_pmp_entry_locked will only be set if MSECCFG.RLB\n    // is unset\n    assign any_pmp_entry_locked = |pmp_cfg_locked;\n\n    // When any PMP entry is locked (A PMP entry has the L bit set and MSECCFG.RLB is unset),\n    // MSECCFG.RLB cannot be set again\n    assign pmp_mseccfg_d.rlb = any_pmp_entry_locked ? 1'b0 : csr_wdata_int[CSR_MSECCFG_RLB_BIT];\n\n    ibex_csr #(\n      .Width     ($bits(pmp_mseccfg_t)),\n      .ShadowCopy(ShadowCSR),\n      .ResetValue(pmp_mseccfg_rst)\n    ) u_pmp_mseccfg (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .wr_data_i (pmp_mseccfg_d),\n      .wr_en_i   (pmp_mseccfg_we),\n      .rd_data_o (pmp_mseccfg_q),\n      .rd_error_o(pmp_mseccfg_err)\n    );\n\n    assign pmp_csr_err = (|pmp_cfg_err) | (|pmp_addr_err) | pmp_mseccfg_err;\n    assign pmp_mseccfg = pmp_mseccfg_q;\n\n  end else begin : g_no_pmp_tieoffs\n    // Generate tieoffs when PMP is not configured\n    for (genvar i = 0; i < PMP_MAX_REGIONS; i++) begin : g_rdata\n      assign pmp_addr_rdata[i] = '0;\n      assign pmp_cfg_rdata[i]  = '0;\n    end\n    for (genvar i = 0; i < PMPNumRegions; i++) begin : g_outputs\n      assign csr_pmp_cfg_o[i]  = pmp_cfg_t'(1'b0);\n      assign csr_pmp_addr_o[i] = '0;\n    end\n    assign pmp_csr_err = 1'b0;\n    assign pmp_mseccfg = '0;\n  end\n\n  assign csr_pmp_mseccfg_o = pmp_mseccfg;\n\n  //////////////////////////\n  //  Performance monitor //\n  //////////////////////////\n\n  // update enable signals\n  always_comb begin : mcountinhibit_update\n    if (mcountinhibit_we == 1'b1) begin\n      // bit 1 must always be 0\n      mcountinhibit_d = {csr_wdata_int[MHPMCounterNum+2:2], 1'b0, csr_wdata_int[0]};\n    end else begin\n      mcountinhibit_d = mcountinhibit_q;\n    end\n  end\n\n  // event selection (hardwired) & control\n  always_comb begin : gen_mhpmcounter_incr\n\n    // Assign inactive counters (first to prevent latch inference)\n    for (int unsigned i = 0; i < 32; i++) begin : gen_mhpmcounter_incr_inactive\n      mhpmcounter_incr[i] = 1'b0;\n    end\n\n    // When adding or altering performance counter meanings and default\n    // mappings please update dv/verilator/pcount/cpp/ibex_pcounts.cc\n    // appropriately.\n    //\n    // active counters\n    mhpmcounter_incr[0]  = 1'b1;                   // mcycle\n    mhpmcounter_incr[1]  = 1'b0;                   // reserved\n    mhpmcounter_incr[2]  = instr_ret_i;            // minstret\n    mhpmcounter_incr[3]  = dside_wait_i;           // cycles waiting for data memory\n    mhpmcounter_incr[4]  = iside_wait_i;           // cycles waiting for instr fetches\n    mhpmcounter_incr[5]  = mem_load_i;             // num of loads\n    mhpmcounter_incr[6]  = mem_store_i;            // num of stores\n    mhpmcounter_incr[7]  = jump_i;                 // num of jumps (unconditional)\n    mhpmcounter_incr[8]  = branch_i;               // num of branches (conditional)\n    mhpmcounter_incr[9]  = branch_taken_i;         // num of taken branches (conditional)\n    mhpmcounter_incr[10] = instr_ret_compressed_i; // num of compressed instr\n    mhpmcounter_incr[11] = mul_wait_i;             // cycles waiting for multiply\n    mhpmcounter_incr[12] = div_wait_i;             // cycles waiting for divide\n  end\n\n  // event selector (hardwired, 0 means no event)\n  always_comb begin : gen_mhpmevent\n\n    // activate all\n    for (int i = 0; i < 32; i++) begin : gen_mhpmevent_active\n      mhpmevent[i] = '0;\n\n      if (i >= 3) begin\n        mhpmevent[i][i - 3] = 1'b1;\n      end\n    end\n\n    // deactivate\n    mhpmevent[1] = '0; // not existing, reserved\n    for (int unsigned i = 3 + MHPMCounterNum; i < 32; i++) begin : gen_mhpmevent_inactive\n      mhpmevent[i] = '0;\n    end\n  end\n\n  // mcycle\n  ibex_counter #(\n    .CounterWidth(64)\n  ) mcycle_counter_i (\n    .clk_i(clk_i),\n    .rst_ni(rst_ni),\n    .counter_inc_i(mhpmcounter_incr[0] & ~mcountinhibit[0]),\n    .counterh_we_i(mhpmcounterh_we[0]),\n    .counter_we_i(mhpmcounter_we[0]),\n    .counter_val_i(csr_wdata_int),\n    .counter_val_o(mhpmcounter[0]),\n    .counter_val_upd_o()\n  );\n\n\n  // minstret\n  ibex_counter #(\n    .CounterWidth(64),\n    .ProvideValUpd(1)\n  ) minstret_counter_i (\n    .clk_i(clk_i),\n    .rst_ni(rst_ni),\n    .counter_inc_i(mhpmcounter_incr[2] & ~mcountinhibit[2]),\n    .counterh_we_i(mhpmcounterh_we[2]),\n    .counter_we_i(mhpmcounter_we[2]),\n    .counter_val_i(csr_wdata_int),\n    .counter_val_o(minstret_raw),\n    .counter_val_upd_o(minstret_next)\n  );\n\n  // Where the writeback stage is present instruction in ID observing value of minstret must take\n  // into account any instruction in the writeback stage. If one is present the incremented value of\n  // minstret is used. A speculative version of the signal is used to aid timing. When the writeback\n  // stage sees an exception (so the speculative signal is incorrect) the ID stage will be flushed\n  // so the incorrect value doesn't matter. A similar behaviour is required for the compressed\n  // instruction retired counter below. When the writeback stage isn't present the speculative\n  // signals are always 0.\n  assign mhpmcounter[2] = instr_ret_spec_i & ~mcountinhibit[2] ? minstret_next : minstret_raw;\n\n  // reserved:\n  assign mhpmcounter[1]            = '0;\n  assign unused_mhpmcounter_we_1   = mhpmcounter_we[1];\n  assign unused_mhpmcounterh_we_1  = mhpmcounterh_we[1];\n  assign unused_mhpmcounter_incr_1 = mhpmcounter_incr[1];\n\n  // Iterate through optionally included counters (MHPMCounterNum controls how many are included)\n  for (genvar i = 0; i < 29; i++) begin : gen_cntrs\n    localparam int Cnt = i + 3;\n\n    if (i < MHPMCounterNum) begin : gen_imp\n      logic [63:0] mhpmcounter_raw, mhpmcounter_next;\n\n      ibex_counter #(\n        .CounterWidth(MHPMCounterWidth),\n        .ProvideValUpd(Cnt == 10)\n      ) mcounters_variable_i (\n        .clk_i(clk_i),\n        .rst_ni(rst_ni),\n        .counter_inc_i(mhpmcounter_incr[Cnt] & ~mcountinhibit[Cnt]),\n        .counterh_we_i(mhpmcounterh_we[Cnt]),\n        .counter_we_i(mhpmcounter_we[Cnt]),\n        .counter_val_i(csr_wdata_int),\n        .counter_val_o(mhpmcounter_raw),\n        .counter_val_upd_o(mhpmcounter_next)\n      );\n\n      if (Cnt == 10) begin : gen_compressed_instr_cnt\n        // Special behaviour for reading compressed instruction retired counter, see comment on\n        // `mhpmcounter[2]` above for further information.\n        assign mhpmcounter[Cnt] =\n          instr_ret_compressed_spec_i & ~mcountinhibit[Cnt] ? mhpmcounter_next:\n                                                              mhpmcounter_raw;\n      end else begin : gen_other_cnts\n        logic [63:0] unused_mhpmcounter_next;\n        // All other counters just see the raw counter value directly.\n        assign mhpmcounter[Cnt] = mhpmcounter_raw;\n        assign unused_mhpmcounter_next = mhpmcounter_next;\n      end\n    end else begin : gen_unimp\n      assign mhpmcounter[Cnt] = '0;\n\n      if (Cnt == 10) begin : gen_no_compressed_instr_cnt\n        logic unused_instr_ret_compressed_spec_i;\n        assign unused_instr_ret_compressed_spec_i = instr_ret_compressed_spec_i;\n      end\n    end\n  end\n\n  if (MHPMCounterNum < 29) begin : g_mcountinhibit_reduced\n    logic [29-MHPMCounterNum-1:0] unused_mhphcounter_we;\n    logic [29-MHPMCounterNum-1:0] unused_mhphcounterh_we;\n    logic [29-MHPMCounterNum-1:0] unused_mhphcounter_incr;\n\n    assign mcountinhibit = {{29 - MHPMCounterNum{1'b0}}, mcountinhibit_q};\n    // Lint tieoffs for unused bits\n    assign unused_mhphcounter_we   = mhpmcounter_we[31:MHPMCounterNum+3];\n    assign unused_mhphcounterh_we  = mhpmcounterh_we[31:MHPMCounterNum+3];\n    assign unused_mhphcounter_incr = mhpmcounter_incr[31:MHPMCounterNum+3];\n  end else begin : g_mcountinhibit_full\n    assign mcountinhibit = mcountinhibit_q;\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      mcountinhibit_q <= '0;\n    end else begin\n      mcountinhibit_q <= mcountinhibit_d;\n    end\n  end\n\n  /////////////////////////////\n  // Debug trigger registers //\n  /////////////////////////////\n\n  if (DbgTriggerEn) begin : gen_trigger_regs\n    localparam int unsigned DbgHwNumLen = DbgHwBreakNum > 1 ? $clog2(DbgHwBreakNum) : 1;\n    localparam int unsigned MaxTselect = DbgHwBreakNum - 1;\n\n    // Register values\n    logic [DbgHwNumLen-1:0]   tselect_d, tselect_q;\n    logic                     tmatch_control_d;\n    logic [DbgHwBreakNum-1:0] tmatch_control_q;\n    logic [31:0]              tmatch_value_d;\n    logic [31:0]              tmatch_value_q[DbgHwBreakNum];\n    logic                     selected_tmatch_control;\n    logic [31:0]              selected_tmatch_value;\n\n    // Write enables\n    logic                     tselect_we;\n    logic [DbgHwBreakNum-1:0] tmatch_control_we;\n    logic [DbgHwBreakNum-1:0] tmatch_value_we;\n    // Trigger comparison result\n    logic [DbgHwBreakNum-1:0] trigger_match;\n\n    // Write select\n    assign tselect_we = csr_we_int & debug_mode_i & (csr_addr_i == CSR_TSELECT);\n    for (genvar i = 0; i < DbgHwBreakNum; i++) begin : g_dbg_tmatch_we\n      assign tmatch_control_we[i] = (i[DbgHwNumLen-1:0] == tselect_q) & csr_we_int & debug_mode_i &\n                                    (csr_addr_i == CSR_TDATA1);\n      assign tmatch_value_we[i]   = (i[DbgHwNumLen-1:0] == tselect_q) & csr_we_int & debug_mode_i &\n                                    (csr_addr_i == CSR_TDATA2);\n    end\n\n    // Debug interface tests the available number of triggers by writing and reading the trigger\n    // select register. Only allow changes to the register if it is within the supported region.\n    assign tselect_d = (csr_wdata_int < DbgHwBreakNum) ? csr_wdata_int[DbgHwNumLen-1:0] :\n                                                         MaxTselect[DbgHwNumLen-1:0];\n\n    // tmatch_control is enabled when the execute bit is set\n    assign tmatch_control_d = csr_wdata_int[2];\n    assign tmatch_value_d   = csr_wdata_int[31:0];\n\n    // Registers\n    ibex_csr #(\n      .Width     (DbgHwNumLen),\n      .ShadowCopy(1'b0),\n      .ResetValue('0)\n    ) u_tselect_csr (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .wr_data_i (tselect_d),\n      .wr_en_i   (tselect_we),\n      .rd_data_o (tselect_q),\n      .rd_error_o()\n    );\n\n    for (genvar i = 0; i < DbgHwBreakNum; i++) begin : g_dbg_tmatch_reg\n      ibex_csr #(\n        .Width     (1),\n        .ShadowCopy(1'b0),\n        .ResetValue('0)\n      ) u_tmatch_control_csr (\n        .clk_i     (clk_i),\n        .rst_ni    (rst_ni),\n        .wr_data_i (tmatch_control_d),\n        .wr_en_i   (tmatch_control_we[i]),\n        .rd_data_o (tmatch_control_q[i]),\n        .rd_error_o()\n      );\n\n      ibex_csr #(\n        .Width     (32),\n        .ShadowCopy(1'b0),\n        .ResetValue('0)\n      ) u_tmatch_value_csr (\n        .clk_i     (clk_i),\n        .rst_ni    (rst_ni),\n        .wr_data_i (tmatch_value_d),\n        .wr_en_i   (tmatch_value_we[i]),\n        .rd_data_o (tmatch_value_q[i]),\n        .rd_error_o()\n      );\n    end\n\n    // Assign read data\n    // TSELECT - number of supported triggers defined by parameter DbgHwBreakNum\n    localparam int unsigned TSelectRdataPadlen = DbgHwNumLen >= 32 ? 0 : (32 - DbgHwNumLen);\n    assign tselect_rdata = {{TSelectRdataPadlen{1'b0}}, tselect_q};\n\n    if (DbgHwBreakNum > 1) begin : g_dbg_tmatch_multiple_select\n      assign selected_tmatch_control = tmatch_control_q[tselect_q];\n      assign selected_tmatch_value   = tmatch_value_q[tselect_q];\n    end else begin : g_dbg_tmatch_single_select\n      assign selected_tmatch_control = tmatch_control_q[0];\n      assign selected_tmatch_value   = tmatch_value_q[0];\n    end\n\n    // TDATA0 - only support simple address matching\n    assign tmatch_control_rdata = {4'h2,                    // type    : address/data match\n                                   1'b1,                    // dmode   : access from D mode only\n                                   6'h00,                   // maskmax : exact match only\n                                   1'b0,                    // hit     : not supported\n                                   1'b0,                    // select  : address match only\n                                   1'b0,                    // timing  : match before execution\n                                   2'b00,                   // sizelo  : match any access\n                                   4'h1,                    // action  : enter debug mode\n                                   1'b0,                    // chain   : not supported\n                                   4'h0,                    // match   : simple match\n                                   1'b1,                    // m       : match in m-mode\n                                   1'b0,                    // 0       : zero\n                                   1'b0,                    // s       : not supported\n                                   1'b1,                    // u       : match in u-mode\n                                   selected_tmatch_control, // execute : match instruction address\n                                   1'b0,                    // store   : not supported\n                                   1'b0};                   // load    : not supported\n\n    // TDATA1 - address match value only\n    assign tmatch_value_rdata = selected_tmatch_value;\n\n    // Breakpoint matching\n    // We match against the next address, as the breakpoint must be taken before execution\n    for (genvar i = 0; i < DbgHwBreakNum; i++) begin : g_dbg_trigger_match\n      assign trigger_match[i] = tmatch_control_q[i] & (pc_if_i[31:0] == tmatch_value_q[i]);\n    end\n    assign trigger_match_o = |trigger_match;\n\n  end else begin : gen_no_trigger_regs\n    assign tselect_rdata        = 'b0;\n    assign tmatch_control_rdata = 'b0;\n    assign tmatch_value_rdata   = 'b0;\n    assign trigger_match_o      = 'b0;\n  end\n\n  //////////////////////////\n  // CPU control register //\n  //////////////////////////\n\n  // Cast register write data\n  assign cpuctrlsts_part_wdata_raw =\n    cpu_ctrl_sts_part_t'(csr_wdata_int[$bits(cpu_ctrl_sts_part_t)-1:0]);\n\n  // Generate fixed time execution bit\n  if (DataIndTiming) begin : gen_dit\n    // SEC_CM: CORE.DATA_REG_SW.SCA\n    assign cpuctrlsts_part_wdata.data_ind_timing = cpuctrlsts_part_wdata_raw.data_ind_timing;\n\n  end else begin : gen_no_dit\n    // tieoff for the unused bit\n    logic unused_dit;\n    assign unused_dit = cpuctrlsts_part_wdata_raw.data_ind_timing;\n\n    // field will always read as zero if not configured\n    assign cpuctrlsts_part_wdata.data_ind_timing = 1'b0;\n  end\n\n  assign data_ind_timing_o = cpuctrlsts_part_q.data_ind_timing;\n\n  // Generate dummy instruction signals\n  if (DummyInstructions) begin : gen_dummy\n    // SEC_CM: CTRL_FLOW.UNPREDICTABLE\n    assign cpuctrlsts_part_wdata.dummy_instr_en   = cpuctrlsts_part_wdata_raw.dummy_instr_en;\n    assign cpuctrlsts_part_wdata.dummy_instr_mask = cpuctrlsts_part_wdata_raw.dummy_instr_mask;\n\n    // Signal a write to the seed register\n    assign dummy_instr_seed_en_o = csr_we_int && (csr_addr == CSR_SECURESEED);\n    assign dummy_instr_seed_o    = csr_wdata_int;\n\n  end else begin : gen_no_dummy\n    // tieoff for the unused bit\n    logic       unused_dummy_en;\n    logic [2:0] unused_dummy_mask;\n    assign unused_dummy_en   = cpuctrlsts_part_wdata_raw.dummy_instr_en;\n    assign unused_dummy_mask = cpuctrlsts_part_wdata_raw.dummy_instr_mask;\n\n    // field will always read as zero if not configured\n    assign cpuctrlsts_part_wdata.dummy_instr_en   = 1'b0;\n    assign cpuctrlsts_part_wdata.dummy_instr_mask = 3'b000;\n    assign dummy_instr_seed_en_o             = 1'b0;\n    assign dummy_instr_seed_o                = '0;\n  end\n\n  assign dummy_instr_en_o   = cpuctrlsts_part_q.dummy_instr_en;\n  assign dummy_instr_mask_o = cpuctrlsts_part_q.dummy_instr_mask;\n\n  // Generate icache enable bit\n  if (ICache) begin : gen_icache_enable\n    assign cpuctrlsts_part_wdata.icache_enable = cpuctrlsts_part_wdata_raw.icache_enable;\n\n    ibex_csr #(\n      .Width     (1),\n      .ShadowCopy(ShadowCSR),\n      .ResetValue(1'b0)\n    ) u_cpuctrlsts_ic_scr_key_valid_q_csr (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .wr_data_i (ic_scr_key_valid_i),\n      .wr_en_i   (1'b1),\n      .rd_data_o (cpuctrlsts_ic_scr_key_valid_q),\n      .rd_error_o(cpuctrlsts_ic_scr_key_err)\n    );\n  end else begin : gen_no_icache\n    // tieoff for the unused icen bit\n    logic unused_icen;\n    assign unused_icen = cpuctrlsts_part_wdata_raw.icache_enable;\n\n    // icen field will always read a"}
{"text": "s zero if ICache not configured\n    assign cpuctrlsts_part_wdata.icache_enable = 1'b0;\n\n\n    logic unused_ic_scr_key_valid;\n    assign unused_ic_scr_key_valid = ic_scr_key_valid_i;\n\n    // ic_scr_key_valid will always read as zero if ICache not configured\n    assign cpuctrlsts_ic_scr_key_valid_q = 1'b0;\n    assign cpuctrlsts_ic_scr_key_err     = 1'b0;\n  end\n\n  assign cpuctrlsts_part_wdata.double_fault_seen = cpuctrlsts_part_wdata_raw.double_fault_seen;\n  assign cpuctrlsts_part_wdata.sync_exc_seen     = cpuctrlsts_part_wdata_raw.sync_exc_seen;\n\n  assign icache_enable_o =\n    cpuctrlsts_part_q.icache_enable & ~(debug_mode_i | debug_mode_entering_i);\n\n  ibex_csr #(\n    .Width     ($bits(cpu_ctrl_sts_part_t)),\n    .ShadowCopy(ShadowCSR),\n    .ResetValue('0)\n  ) u_cpuctrlsts_part_csr (\n    .clk_i     (clk_i),\n    .rst_ni    (rst_ni),\n    .wr_data_i ({cpuctrlsts_part_d}),\n    .wr_en_i   (cpuctrlsts_part_we),\n    .rd_data_o (cpuctrlsts_part_q),\n    .rd_error_o(cpuctrlsts_part_err)\n  );\n\n  assign csr_shadow_err_o =\n    mstatus_err | mtvec_err | pmp_csr_err | cpuctrlsts_part_err | cpuctrlsts_ic_scr_key_err;\n\n  ////////////////\n  // Assertions //\n  ////////////////\n\n  `ASSERT(IbexCsrOpEnRequiresAccess, csr_op_en_i |-> csr_access_i)\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n\n/**\n * Instruction decoder\n *\n * This module is fully combinatorial, clock and reset are used for\n * assertions only.\n */\n\n`include \"prim_assert.sv\"\n\nmodule ibex_decoder #(\n  parameter bit RV32E               = 0,\n  parameter ibex_pkg::rv32m_e RV32M = ibex_pkg::RV32MFast,\n  parameter ibex_pkg::rv32b_e RV32B = ibex_pkg::RV32BNone,\n  parameter bit BranchTargetALU     = 0\n) (\n  input  logic                 clk_i,\n  input  logic                 rst_ni,\n\n  // to/from controller\n  output logic                 illegal_insn_o,        // illegal instr encountered\n  output logic                 ebrk_insn_o,           // trap instr encountered\n  output logic                 mret_insn_o,           // return from exception instr\n                                                      // encountered\n  output logic                 dret_insn_o,           // return from debug instr encountered\n  output logic                 ecall_insn_o,          // syscall instr encountered\n  output logic                 wfi_insn_o,            // wait for interrupt instr encountered\n  output logic                 jump_set_o,            // jump taken set signal\n  input  logic                 branch_taken_i,        // registered branch decision\n  output logic                 icache_inval_o,\n\n  // from IF-ID pipeline register\n  input  logic                 instr_first_cycle_i,   // instruction read is in its first cycle\n  input  logic [31:0]          instr_rdata_i,         // instruction read from memory/cache\n  input  logic [31:0]          instr_rdata_alu_i,     // instruction read from memory/cache\n                                                      // replicated to ease fan-out)\n\n  input  logic                 illegal_c_insn_i,      // compressed instruction decode failed\n\n  // immediates\n  output ibex_pkg::imm_a_sel_e  imm_a_mux_sel_o,       // immediate selection for operand a\n  output ibex_pkg::imm_b_sel_e  imm_b_mux_sel_o,       // immediate selection for operand b\n  output ibex_pkg::op_a_sel_e   bt_a_mux_sel_o,        // branch target selection operand a\n  output ibex_pkg::imm_b_sel_e  bt_b_mux_sel_o,        // branch target selection operand b\n  output logic [31:0]           imm_i_type_o,\n  output logic [31:0]           imm_s_type_o,\n  output logic [31:0]           imm_b_type_o,\n  output logic [31:0]           imm_u_type_o,\n  output logic [31:0]           imm_j_type_o,\n  output logic [31:0]           zimm_rs1_type_o,\n\n  // register file\n  output ibex_pkg::rf_wd_sel_e rf_wdata_sel_o,   // RF write data selection\n  output logic                 rf_we_o,          // write enable for regfile\n  output logic [4:0]           rf_raddr_a_o,\n  output logic [4:0]           rf_raddr_b_o,\n  output logic [4:0]           rf_waddr_o,\n  output logic                 rf_ren_a_o,          // Instruction reads from RF addr A\n  output logic                 rf_ren_b_o,          // Instruction reads from RF addr B\n\n  // ALU\n  output ibex_pkg::alu_op_e    alu_operator_o,        // ALU operation selection\n  output ibex_pkg::op_a_sel_e  alu_op_a_mux_sel_o,    // operand a selection: reg value, PC,\n                                                      // immediate or zero\n  output ibex_pkg::op_b_sel_e  alu_op_b_mux_sel_o,    // operand b selection: reg value or\n                                                      // immediate\n  output logic                 alu_multicycle_o,      // ternary bitmanip instruction\n\n  // MULT & DIV\n  output logic                 mult_en_o,             // perform integer multiplication\n  output logic                 div_en_o,              // perform integer division or remainder\n  output logic                 mult_sel_o,            // as above but static, for data muxes\n  output logic                 div_sel_o,             // as above but static, for data muxes\n\n  output ibex_pkg::md_op_e     multdiv_operator_o,\n  output logic [1:0]           multdiv_signed_mode_o,\n\n  // CSRs\n  output logic                 csr_access_o,          // access to CSR\n  output ibex_pkg::csr_op_e    csr_op_o,              // operation to perform on CSR\n\n  // LSU\n  output logic                 data_req_o,            // start transaction to data memory\n  output logic                 data_we_o,             // write enable\n  output logic [1:0]           data_type_o,           // size of transaction: byte, half\n                                                      // word or word\n  output logic                 data_sign_extension_o, // sign extension for data read from\n                                                      // memory\n\n  // jump/branches\n  output logic                 jump_in_dec_o,         // jump is being calculated in ALU\n  output logic                 branch_in_dec_o\n);\n\n  import ibex_pkg::*;\n\n  logic        illegal_insn;\n  logic        illegal_reg_rv32e;\n  logic        csr_illegal;\n  logic        rf_we;\n\n  logic [31:0] instr;\n  logic [31:0] instr_alu;\n  logic [9:0]  unused_instr_alu;\n  // Source/Destination register instruction index\n  logic [4:0] instr_rs1;\n  logic [4:0] instr_rs2;\n  logic [4:0] instr_rs3;\n  logic [4:0] instr_rd;\n\n  logic        use_rs3_d;\n  logic        use_rs3_q;\n\n  csr_op_e     csr_op;\n\n  opcode_e     opcode;\n  opcode_e     opcode_alu;\n\n  // To help timing the flops containing the current instruction are replicated to reduce fan-out.\n  // instr_alu is used to determine the ALU control logic and associated operand/imm select signals\n  // as the ALU is often on the more critical timing paths. instr is used for everything else.\n  assign instr     = instr_rdata_i;\n  assign instr_alu = instr_rdata_alu_i;\n\n  //////////////////////////////////////\n  // Register and immediate selection //\n  //////////////////////////////////////\n\n  // immediate extraction and sign extension\n  assign imm_i_type_o = { {20{instr[31]}}, instr[31:20] };\n  assign imm_s_type_o = { {20{instr[31]}}, instr[31:25], instr[11:7] };\n  assign imm_b_type_o = { {19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0 };\n  assign imm_u_type_o = { instr[31:12], 12'b0 };\n  assign imm_j_type_o = { {12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0 };\n\n  // immediate for CSR manipulation (zero extended)\n  assign zimm_rs1_type_o = { 27'b0, instr_rs1 }; // rs1\n\n  if (RV32B != RV32BNone) begin : gen_rs3_flop\n    // the use of rs3 is known one cycle ahead.\n    always_ff  @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        use_rs3_q <= 1'b0;\n      end else begin\n        use_rs3_q <= use_rs3_d;\n      end\n    end\n  end else begin : gen_no_rs3_flop\n    logic unused_clk;\n    logic unused_rst_n;\n\n    // Clock and reset unused when there's no rs3 flop\n    assign unused_clk = clk_i;\n    assign unused_rst_n = rst_ni;\n\n    // always zero\n    assign use_rs3_q = use_rs3_d;\n  end\n\n  // source registers\n  assign instr_rs1 = instr[19:15];\n  assign instr_rs2 = instr[24:20];\n  assign instr_rs3 = instr[31:27];\n  assign rf_raddr_a_o = (use_rs3_q & ~instr_first_cycle_i) ? instr_rs3 : instr_rs1; // rs3 / rs1\n  assign rf_raddr_b_o = instr_rs2; // rs2\n\n  // destination register\n  assign instr_rd = instr[11:7];\n  assign rf_waddr_o   = instr_rd; // rd\n\n  ////////////////////\n  // Register check //\n  ////////////////////\n  if (RV32E) begin : gen_rv32e_reg_check_active\n    assign illegal_reg_rv32e = ((rf_raddr_a_o[4] & (alu_op_a_mux_sel_o == OP_A_REG_A)) |\n                                (rf_raddr_b_o[4] & (alu_op_b_mux_sel_o == OP_B_REG_B)) |\n                                (rf_waddr_o[4]   & rf_we));\n  end else begin : gen_rv32e_reg_check_inactive\n    assign illegal_reg_rv32e = 1'b0;\n  end\n\n  ///////////////////////\n  // CSR operand check //\n  ///////////////////////\n  always_comb begin : csr_operand_check\n    csr_op_o = csr_op;\n\n    // CSRRSI/CSRRCI must not write 0 to CSRs (uimm[4:0]=='0)\n    // CSRRS/CSRRC must not write from x0 to CSRs (rs1=='0)\n    if ((csr_op == CSR_OP_SET || csr_op == CSR_OP_CLEAR) &&\n        instr_rs1 == '0) begin\n      csr_op_o = CSR_OP_READ;\n    end\n  end\n\n  /////////////\n  // Decoder //\n  /////////////\n\n  always_comb begin\n    jump_in_dec_o         = 1'b0;\n    jump_set_o            = 1'b0;\n    branch_in_dec_o       = 1'b0;\n    icache_inval_o        = 1'b0;\n\n    multdiv_operator_o    = MD_OP_MULL;\n    multdiv_signed_mode_o = 2'b00;\n\n    rf_wdata_sel_o        = RF_WD_EX;\n    rf_we                 = 1'b0;\n    rf_ren_a_o            = 1'b0;\n    rf_ren_b_o            = 1'b0;\n\n    csr_access_o          = 1'b0;\n    csr_illegal           = 1'b0;\n    csr_op                = CSR_OP_READ;\n\n    data_we_o             = 1'b0;\n    data_type_o           = 2'b00;\n    data_sign_extension_o = 1'b0;\n    data_req_o            = 1'b0;\n\n    illegal_insn          = 1'b0;\n    ebrk_insn_o           = 1'b0;\n    mret_insn_o           = 1'b0;\n    dret_insn_o           = 1'b0;\n    ecall_insn_o          = 1'b0;\n    wfi_insn_o            = 1'b0;\n\n    opcode                = opcode_e'(instr[6:0]);\n\n    unique case (opcode)\n\n      ///////////\n      // Jumps //\n      ///////////\n\n      OPCODE_JAL: begin   // Jump and Link\n        jump_in_dec_o      = 1'b1;\n\n        if (instr_first_cycle_i) begin\n          // Calculate jump target (and store PC + 4 if BranchTargetALU is configured)\n          rf_we            = BranchTargetALU;\n          jump_set_o       = 1'b1;\n        end else begin\n          // Calculate and store PC+4\n          rf_we            = 1'b1;\n        end\n      end\n\n      OPCODE_JALR: begin  // Jump and Link Register\n        jump_in_dec_o      = 1'b1;\n\n        if (instr_first_cycle_i) begin\n          // Calculate jump target (and store PC + 4 if BranchTargetALU is configured)\n          rf_we            = BranchTargetALU;\n          jump_set_o       = 1'b1;\n        end else begin\n          // Calculate and store PC+4\n          rf_we            = 1'b1;\n        end\n        if (instr[14:12] != 3'b0) begin\n          illegal_insn = 1'b1;\n        end\n\n        rf_ren_a_o = 1'b1;\n      end\n\n      OPCODE_BRANCH: begin // Branch\n        branch_in_dec_o       = 1'b1;\n        // Check branch condition selection\n        unique case (instr[14:12])\n          3'b000,\n          3'b001,\n          3'b100,\n          3'b101,\n          3'b110,\n          3'b111:  illegal_insn = 1'b0;\n          default: illegal_insn = 1'b1;\n        endcase\n\n        rf_ren_a_o = 1'b1;\n        rf_ren_b_o = 1'b1;\n      end\n\n      ////////////////\n      // Load/store //\n      ////////////////\n\n      OPCODE_STORE: begin\n        rf_ren_a_o         = 1'b1;\n        rf_ren_b_o         = 1'b1;\n        data_req_o         = 1'b1;\n        data_we_o          = 1'b1;\n\n        if (instr[14]) begin\n          illegal_insn = 1'b1;\n        end\n\n        // store size\n        unique case (instr[13:12])\n          2'b00:   data_type_o  = 2'b10; // sb\n          2'b01:   data_type_o  = 2'b01; // sh\n          2'b10:   data_type_o  = 2'b00; // sw\n          default: illegal_insn = 1'b1;\n        endcase\n      end\n\n      OPCODE_LOAD: begin\n        rf_ren_a_o          = 1'b1;\n        data_req_o          = 1'b1;\n        data_type_o         = 2'b00;\n\n        // sign/zero extension\n        data_sign_extension_o = ~instr[14];\n\n        // load size\n        unique case (instr[13:12])\n          2'b00: data_type_o = 2'b10; // lb(u)\n          2'b01: data_type_o = 2'b01; // lh(u)\n          2'b10: begin\n            data_type_o = 2'b00;      // lw\n            if (instr[14]) begin\n              illegal_insn = 1'b1;    // lwu does not exist\n            end\n          end\n          default: begin\n            illegal_insn = 1'b1;\n          end\n        endcase\n      end\n\n      /////////\n      // ALU //\n      /////////\n\n      OPCODE_LUI: begin  // Load Upper Immediate\n        rf_we            = 1'b1;\n      end\n\n      OPCODE_AUIPC: begin  // Add Upper Immediate to PC\n        rf_we            = 1'b1;\n      end\n\n      OPCODE_OP_IMM: begin // Register-Immediate ALU Operations\n        rf_ren_a_o       = 1'b1;\n        rf_we            = 1'b1;\n\n        unique case (instr[14:12])\n          3'b000,\n          3'b010,\n          3'b011,\n          3'b100,\n          3'b110,\n          3'b111: illegal_insn = 1'b0;\n\n          3'b001: begin\n            unique case (instr[31:27])\n              5'b0_0000: illegal_insn = (instr[26:25] == 2'b00) ? 1'b0 : 1'b1;        // slli\n              5'b0_0100: begin                                                        // sloi\n                illegal_insn = (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) ? 1'b0 : 1'b1;\n              end\n              5'b0_1001,                                                              // bclri\n              5'b0_0101,                                                              // bseti\n              5'b0_1101: illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1;           // binvi\n              5'b0_0001: begin\n                if (instr[26] == 1'b0) begin                                          // shfl\n                  illegal_insn = (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) ? 1'b0 : 1'b1;\n                end else begin\n                  illegal_insn = 1'b1;\n                end\n              end\n              5'b0_1100: begin\n                unique case(instr[26:20])\n                  7'b000_0000,                                                         // clz\n                  7'b000_0001,                                                         // ctz\n                  7'b000_0010,                                                         // cpop\n                  7'b000_0100,                                                         // sext.b\n                  7'b000_0101: illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1;      // sext.h\n                  7'b001_0000,                                                         // crc32.b\n                  7'b001_0001,                                                         // crc32.h\n                  7'b001_0010,                                                         // crc32.w\n                  7'b001_1000,                                                         // crc32c.b\n                  7'b001_1001,                                                         // crc32c.h\n                  7'b001_1010: begin                                                   // crc32c.w\n                    illegal_insn = (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) ? 1'b0 : 1'b1;\n                  end\n                  default: illegal_insn = 1'b1;\n                endcase\n              end\n              default : illegal_insn = 1'b1;\n            endcase\n          end\n\n          3'b101: begin\n            if (instr[26]) begin\n              illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1;                       // fsri\n            end else begin\n              unique case (instr[31:27])\n                5'b0_0000,                                                             // srli\n                5'b0_1000: illegal_insn = (instr[26:25] == 2'b00) ? 1'b0 : 1'b1;       // srai\n\n                5'b0_0100: begin                                                       // sroi\n                  illegal_insn = (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) ? 1'b0 : 1'b1;\n                end\n                5'b0_1100,                                                             // rori\n                5'b0_1001: illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1;          // bexti\n\n                5'b0_1101: begin\n                  if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) begin\n                    illegal_insn = 1'b0;                                               // grevi\n                  end else if (RV32B == RV32BBalanced) begin\n                    illegal_insn = (instr[24:20] == 5'b11000) ? 1'b0 : 1'b1;           // rev8\n                  end else begin\n                    illegal_insn = 1'b1;\n                  end\n                end\n                5'b0_0101: begin\n                  if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) begin\n                    illegal_insn = 1'b0;                                              // gorci\n                  end else if (instr[24:20] == 5'b00111) begin\n                    illegal_insn = (RV32B == RV32BBalanced) ? 1'b0 : 1'b1;            // orc.b\n                  end else begin\n                    illegal_insn = 1'b1;\n                  end\n                end\n                5'b0_0001: begin\n                  if (instr[26] == 1'b0) begin                                        // unshfl\n                    illegal_insn = (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) ? 1'b0 : 1'b1;\n                  end else begin\n                    illegal_insn = 1'b1;\n                  end\n                end\n\n                default: illegal_insn = 1'b1;\n              endcase\n            end\n          end\n\n          default: illegal_insn = 1'b1;\n        endcase\n      end\n\n      OPCODE_OP: begin  // Register-Register ALU operation\n        rf_ren_a_o      = 1'b1;\n        rf_ren_b_o      = 1'b1;\n        rf_we           = 1'b1;\n        if ({instr[26], instr[13:12]} == {1'b1, 2'b01}) begin\n          illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1; // cmix / cmov / fsl / fsr\n        end else begin\n          unique case ({instr[31:25], instr[14:12]})\n            // RV32I ALU operations\n            {7'b000_0000, 3'b000},\n            {7'b010_0000, 3'b000},\n            {7'b000_0000, 3'b010},\n            {7'b000_0000, 3'b011},\n            {7'b000_0000, 3'b100},\n            {7'b000_0000, 3'b110},\n            {7'b000_0000, 3'b111},\n            {7'b000_0000, 3'b001},\n            {7'b000_0000, 3'b101},\n            {7'b010_0000, 3'b101}: illegal_insn = 1'b0;\n\n            // RV32B zba\n            {7'b001_0000, 3'b010}, // sh1add\n            {7'b001_0000, 3'b100}, // sh2add\n            {7'b001_0000, 3'b110}, // sh3add\n            // RV32B zbb\n            {7'b010_0000, 3'b111}, // andn\n            {7'b010_0000, 3'b110}, // orn\n            {7'b010_0000, 3'b100}, // xnor\n            {7'b011_0000, 3'b001}, // rol\n            {7'b011_0000, 3'b101}, // ror\n            {7'b000_0101, 3'b100}, // min\n            {7'b000_0101, 3'b110}, // max\n            {7'b000_0101, 3'b101}, // minu\n            {7'b000_0101, 3'b111}, // maxu\n            {7'b000_0100, 3'b100}, // pack\n            {7'b010_0100, 3'b100}, // packu\n            {7'b000_0100, 3'b111}, // packh\n            // RV32B zbs\n            {7'b010_0100, 3'b001}, // bclr\n            {7'b001_0100, 3'b001}, // bset\n            {7'b011_0100, 3'b001}, // binv\n            {7'b010_0100, 3'b101}, // bext\n            // RV32B zbf\n            {7'b010_0100, 3'b111}: illegal_insn = (RV32B != RV32BNone) ? 1'b0 : 1'b1; // bfp\n            // RV32B zbp\n            {7'b011_0100, 3'b101}, // grev\n            {7'b001_0100, 3'b101}, // gorc\n            {7'b000_0100, 3'b001}, // shfl\n            {7'b000_0100, 3'b101}, // unshfl\n            {7'b001_0100, 3'b010}, // xperm.n\n            {7'b001_0100, 3'b100}, // xperm.b\n            {7'b001_0100, 3'b110}, // xperm.h\n            {7'b001_0000, 3'b001}, // slo\n            {7'b001_0000, 3'b101}, // sro\n            // RV32B zbc\n            {7'b000_0101, 3'b001}, // clmul\n            {7'b000_0101, 3'b010}, // clmulr\n            {7'b000_0101, 3'b011}: begin // clmulh\n              illegal_insn = (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) ? 1'b0 : 1'b1;\n            end\n            // RV32B zbe\n            {7'b010_0100, 3'b110}, // bdecompress\n            {7'b000_0100, 3'b110}: illegal_insn = (RV32B == RV32BFull) ? 1'b0 : 1'b1; // bcompress\n\n            // RV32M instructions\n            {7'b000_0001, 3'b000}: begin // mul\n              multdiv_operator_o    = MD_OP_MULL;\n              multdiv_signed_mode_o = 2'b00;\n              illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;\n            end\n            {7'b000_0001, 3'b001}: begin //"}
{"text": " mulh\n              multdiv_operator_o    = MD_OP_MULH;\n              multdiv_signed_mode_o = 2'b11;\n              illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;\n            end\n            {7'b000_0001, 3'b010}: begin // mulhsu\n              multdiv_operator_o    = MD_OP_MULH;\n              multdiv_signed_mode_o = 2'b01;\n              illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;\n            end\n            {7'b000_0001, 3'b011}: begin // mulhu\n              multdiv_operator_o    = MD_OP_MULH;\n              multdiv_signed_mode_o = 2'b00;\n              illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;\n            end\n            {7'b000_0001, 3'b100}: begin // div\n              multdiv_operator_o    = MD_OP_DIV;\n              multdiv_signed_mode_o = 2'b11;\n              illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;\n            end\n            {7'b000_0001, 3'b101}: begin // divu\n              multdiv_operator_o    = MD_OP_DIV;\n              multdiv_signed_mode_o = 2'b00;\n              illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;\n            end\n            {7'b000_0001, 3'b110}: begin // rem\n              multdiv_operator_o    = MD_OP_REM;\n              multdiv_signed_mode_o = 2'b11;\n              illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;\n            end\n            {7'b000_0001, 3'b111}: begin // remu\n              multdiv_operator_o    = MD_OP_REM;\n              multdiv_signed_mode_o = 2'b00;\n              illegal_insn          = (RV32M == RV32MNone) ? 1'b1 : 1'b0;\n            end\n            default: begin\n              illegal_insn = 1'b1;\n            end\n          endcase\n        end\n      end\n\n      /////////////\n      // Special //\n      /////////////\n\n      OPCODE_MISC_MEM: begin\n        unique case (instr[14:12])\n          3'b000: begin\n            // FENCE is treated as a NOP since all memory operations are already strictly ordered.\n            rf_we           = 1'b0;\n          end\n          3'b001: begin\n            // FENCE.I is implemented as a jump to the next PC, this gives the required flushing\n            // behaviour (iside prefetch buffer flushed and response to any outstanding iside\n            // requests will be ignored).\n            // If present, the ICache will also be flushed.\n            jump_in_dec_o   = 1'b1;\n\n            rf_we           = 1'b0;\n\n            if (instr_first_cycle_i) begin\n              jump_set_o       = 1'b1;\n              icache_inval_o   = 1'b1;\n            end\n          end\n          default: begin\n            illegal_insn       = 1'b1;\n          end\n        endcase\n      end\n\n      OPCODE_SYSTEM: begin\n        if (instr[14:12] == 3'b000) begin\n          // non CSR related SYSTEM instructions\n          unique case (instr[31:20])\n            12'h000:  // ECALL\n              // environment (system) call\n              ecall_insn_o = 1'b1;\n\n            12'h001:  // ebreak\n              // debugger trap\n              ebrk_insn_o = 1'b1;\n\n            12'h302:  // mret\n              mret_insn_o = 1'b1;\n\n            12'h7b2:  // dret\n              dret_insn_o = 1'b1;\n\n            12'h105:  // wfi\n              wfi_insn_o = 1'b1;\n\n            default:\n              illegal_insn = 1'b1;\n          endcase\n\n          // rs1 and rd must be 0\n          if (instr_rs1 != 5'b0 || instr_rd != 5'b0) begin\n            illegal_insn = 1'b1;\n          end\n        end else begin\n          // instruction to read/modify CSR\n          csr_access_o     = 1'b1;\n          rf_wdata_sel_o   = RF_WD_CSR;\n          rf_we            = 1'b1;\n\n          if (~instr[14]) begin\n            rf_ren_a_o         = 1'b1;\n          end\n\n          unique case (instr[13:12])\n            2'b01:   csr_op = CSR_OP_WRITE;\n            2'b10:   csr_op = CSR_OP_SET;\n            2'b11:   csr_op = CSR_OP_CLEAR;\n            default: csr_illegal = 1'b1;\n          endcase\n\n          illegal_insn = csr_illegal;\n        end\n\n      end\n      default: begin\n        illegal_insn = 1'b1;\n      end\n    endcase\n\n    // make sure illegal compressed instructions cause illegal instruction exceptions\n    if (illegal_c_insn_i) begin\n      illegal_insn = 1'b1;\n    end\n\n    // make sure illegal instructions detected in the decoder do not propagate from decoder\n    // into register file, LSU, EX, WB, CSRs, PC\n    // NOTE: instructions can also be detected to be illegal inside the CSRs (upon accesses with\n    // insufficient privileges), or when accessing non-available registers in RV32E,\n    // these cases are not handled here\n    if (illegal_insn) begin\n      rf_we           = 1'b0;\n      data_req_o      = 1'b0;\n      data_we_o       = 1'b0;\n      jump_in_dec_o   = 1'b0;\n      jump_set_o      = 1'b0;\n      branch_in_dec_o = 1'b0;\n      csr_access_o    = 1'b0;\n    end\n  end\n\n  /////////////////////////////\n  // Decoder for ALU control //\n  /////////////////////////////\n\n  always_comb begin\n    alu_operator_o     = ALU_SLTU;\n    alu_op_a_mux_sel_o = OP_A_IMM;\n    alu_op_b_mux_sel_o = OP_B_IMM;\n\n    imm_a_mux_sel_o    = IMM_A_ZERO;\n    imm_b_mux_sel_o    = IMM_B_I;\n\n    bt_a_mux_sel_o     = OP_A_CURRPC;\n    bt_b_mux_sel_o     = IMM_B_I;\n\n\n    opcode_alu         = opcode_e'(instr_alu[6:0]);\n\n    use_rs3_d          = 1'b0;\n    alu_multicycle_o   = 1'b0;\n    mult_sel_o         = 1'b0;\n    div_sel_o          = 1'b0;\n\n    unique case (opcode_alu)\n\n      ///////////\n      // Jumps //\n      ///////////\n\n      OPCODE_JAL: begin // Jump and Link\n        if (BranchTargetALU) begin\n          bt_a_mux_sel_o = OP_A_CURRPC;\n          bt_b_mux_sel_o = IMM_B_J;\n        end\n\n        // Jumps take two cycles without the BTALU\n        if (instr_first_cycle_i && !BranchTargetALU) begin\n          // Calculate jump target\n          alu_op_a_mux_sel_o  = OP_A_CURRPC;\n          alu_op_b_mux_sel_o  = OP_B_IMM;\n          imm_b_mux_sel_o     = IMM_B_J;\n          alu_operator_o      = ALU_ADD;\n        end else begin\n          // Calculate and store PC+4\n          alu_op_a_mux_sel_o  = OP_A_CURRPC;\n          alu_op_b_mux_sel_o  = OP_B_IMM;\n          imm_b_mux_sel_o     = IMM_B_INCR_PC;\n          alu_operator_o      = ALU_ADD;\n        end\n      end\n\n      OPCODE_JALR: begin // Jump and Link Register\n        if (BranchTargetALU) begin\n          bt_a_mux_sel_o = OP_A_REG_A;\n          bt_b_mux_sel_o = IMM_B_I;\n        end\n\n        // Jumps take two cycles without the BTALU\n        if (instr_first_cycle_i && !BranchTargetALU) begin\n          // Calculate jump target\n          alu_op_a_mux_sel_o  = OP_A_REG_A;\n          alu_op_b_mux_sel_o  = OP_B_IMM;\n          imm_b_mux_sel_o     = IMM_B_I;\n          alu_operator_o      = ALU_ADD;\n        end else begin\n          // Calculate and store PC+4\n          alu_op_a_mux_sel_o  = OP_A_CURRPC;\n          alu_op_b_mux_sel_o  = OP_B_IMM;\n          imm_b_mux_sel_o     = IMM_B_INCR_PC;\n          alu_operator_o      = ALU_ADD;\n        end\n      end\n\n      OPCODE_BRANCH: begin // Branch\n        // Check branch condition selection\n        unique case (instr_alu[14:12])\n          3'b000:  alu_operator_o = ALU_EQ;\n          3'b001:  alu_operator_o = ALU_NE;\n          3'b100:  alu_operator_o = ALU_LT;\n          3'b101:  alu_operator_o = ALU_GE;\n          3'b110:  alu_operator_o = ALU_LTU;\n          3'b111:  alu_operator_o = ALU_GEU;\n          default: ;\n        endcase\n\n        if (BranchTargetALU) begin\n          bt_a_mux_sel_o = OP_A_CURRPC;\n          // Not-taken branch will jump to next instruction (used in secure mode)\n          bt_b_mux_sel_o = branch_taken_i ? IMM_B_B : IMM_B_INCR_PC;\n        end\n\n        // Without branch target ALU, a branch is a two-stage operation using the Main ALU in both\n        // stages\n        if (instr_first_cycle_i) begin\n          // First evaluate the branch condition\n          alu_op_a_mux_sel_o  = OP_A_REG_A;\n          alu_op_b_mux_sel_o  = OP_B_REG_B;\n        end else if (!BranchTargetALU) begin\n          // Then calculate jump target\n          alu_op_a_mux_sel_o  = OP_A_CURRPC;\n          alu_op_b_mux_sel_o  = OP_B_IMM;\n          // Not-taken branch will jump to next instruction (used in secure mode)\n          imm_b_mux_sel_o     = branch_taken_i ? IMM_B_B : IMM_B_INCR_PC;\n          alu_operator_o      = ALU_ADD;\n        end\n      end\n\n      ////////////////\n      // Load/store //\n      ////////////////\n\n      OPCODE_STORE: begin\n        alu_op_a_mux_sel_o = OP_A_REG_A;\n        alu_op_b_mux_sel_o = OP_B_REG_B;\n        alu_operator_o     = ALU_ADD;\n\n        if (!instr_alu[14]) begin\n          // offset from immediate\n          imm_b_mux_sel_o     = IMM_B_S;\n          alu_op_b_mux_sel_o  = OP_B_IMM;\n        end\n      end\n\n      OPCODE_LOAD: begin\n        alu_op_a_mux_sel_o  = OP_A_REG_A;\n\n        // offset from immediate\n        alu_operator_o      = ALU_ADD;\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_b_mux_sel_o     = IMM_B_I;\n      end\n\n      /////////\n      // ALU //\n      /////////\n\n      OPCODE_LUI: begin  // Load Upper Immediate\n        alu_op_a_mux_sel_o  = OP_A_IMM;\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_a_mux_sel_o     = IMM_A_ZERO;\n        imm_b_mux_sel_o     = IMM_B_U;\n        alu_operator_o      = ALU_ADD;\n      end\n\n      OPCODE_AUIPC: begin  // Add Upper Immediate to PC\n        alu_op_a_mux_sel_o  = OP_A_CURRPC;\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_b_mux_sel_o     = IMM_B_U;\n        alu_operator_o      = ALU_ADD;\n      end\n\n      OPCODE_OP_IMM: begin // Register-Immediate ALU Operations\n        alu_op_a_mux_sel_o  = OP_A_REG_A;\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_b_mux_sel_o     = IMM_B_I;\n\n        unique case (instr_alu[14:12])\n          3'b000: alu_operator_o = ALU_ADD;  // Add Immediate\n          3'b010: alu_operator_o = ALU_SLT;  // Set to one if Lower Than Immediate\n          3'b011: alu_operator_o = ALU_SLTU; // Set to one if Lower Than Immediate Unsigned\n          3'b100: alu_operator_o = ALU_XOR;  // Exclusive Or with Immediate\n          3'b110: alu_operator_o = ALU_OR;   // Or with Immediate\n          3'b111: alu_operator_o = ALU_AND;  // And with Immediate\n\n          3'b001: begin\n            if (RV32B != RV32BNone) begin\n              unique case (instr_alu[31:27])\n                5'b0_0000: alu_operator_o = ALU_SLL;    // Shift Left Logical by Immediate\n                // Shift Left Ones by Immediate\n                5'b0_0100: begin\n                  if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) alu_operator_o = ALU_SLO;\n                end\n                5'b0_1001: alu_operator_o = ALU_BCLR; // Clear bit specified by immediate\n                5'b0_0101: alu_operator_o = ALU_BSET; // Set bit specified by immediate\n                5'b0_1101: alu_operator_o = ALU_BINV; // Invert bit specified by immediate.\n                // Shuffle with Immediate Control Value\n                5'b0_0001: if (instr_alu[26] == 0) alu_operator_o = ALU_SHFL;\n                5'b0_1100: begin\n                  unique case (instr_alu[26:20])\n                    7'b000_0000: alu_operator_o = ALU_CLZ;   // clz\n                    7'b000_0001: alu_operator_o = ALU_CTZ;   // ctz\n                    7'b000_0010: alu_operator_o = ALU_CPOP;  // cpop\n                    7'b000_0100: alu_operator_o = ALU_SEXTB; // sext.b\n                    7'b000_0101: alu_operator_o = ALU_SEXTH; // sext.h\n                    7'b001_0000: begin\n                      if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) begin\n                        alu_operator_o = ALU_CRC32_B;  // crc32.b\n                        alu_multicycle_o = 1'b1;\n                      end\n                    end\n                    7'b001_0001: begin\n                      if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) begin\n                        alu_operator_o = ALU_CRC32_H;  // crc32.h\n                        alu_multicycle_o = 1'b1;\n                      end\n                    end\n                    7'b001_0010: begin\n                      if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) begin\n                        alu_operator_o = ALU_CRC32_W;  // crc32.w\n                        alu_multicycle_o = 1'b1;\n                      end\n                    end\n                    7'b001_1000: begin\n                      if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) begin\n                        alu_operator_o = ALU_CRC32C_B; // crc32c.b\n                        alu_multicycle_o = 1'b1;\n                      end\n                    end\n                    7'b001_1001: begin\n                      if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) begin\n                        alu_operator_o = ALU_CRC32C_H; // crc32c.h\n                        alu_multicycle_o = 1'b1;\n                      end\n                    end\n                    7'b001_1010: begin\n                      if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) begin\n                        alu_operator_o = ALU_CRC32C_W; // crc32c.w\n                        alu_multicycle_o = 1'b1;\n                      end\n                    end\n                    default: ;\n                  endcase\n                end\n\n                default: ;\n              endcase\n            end else begin\n              alu_operator_o = ALU_SLL; // Shift Left Logical by Immediate\n            end\n          end\n\n          3'b101: begin\n            if (RV32B != RV32BNone) begin\n              if (instr_alu[26] == 1'b1) begin\n                alu_operator_o = ALU_FSR;\n                alu_multicycle_o = 1'b1;\n                if (instr_first_cycle_i) begin\n                  use_rs3_d = 1'b1;\n                end else begin\n                  use_rs3_d = 1'b0;\n                end\n              end else begin\n                unique case (instr_alu[31:27])\n                  5'b0_0000: alu_operator_o = ALU_SRL;   // Shift Right Logical by Immediate\n                  5'b0_1000: alu_operator_o = ALU_SRA;   // Shift Right Arithmetically by Immediate\n                  // Shift Right Ones by Immediate\n                  5'b0_0100: begin\n                    if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) alu_operator_o = ALU_SRO;\n                  end\n                  5'b0_1001: alu_operator_o = ALU_BEXT;  // Extract bit specified by immediate.\n                  5'b0_1100: begin\n                    alu_operator_o = ALU_ROR;            // Rotate Right by Immediate\n                    alu_multicycle_o = 1'b1;\n                  end\n                  5'b0_1101: alu_operator_o = ALU_GREV;  // General Reverse with Imm Control Val\n                  5'b0_0101: alu_operator_o = ALU_GORC;  // General Or-combine with Imm Control Val\n                  // Unshuffle with Immediate Control Value\n                  5'b0_0001: begin\n                    if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) begin\n                      if (instr_alu[26] == 1'b0) alu_operator_o = ALU_UNSHFL;\n                    end\n                  end\n                  default: ;\n                endcase\n              end\n\n            end else begin\n              if (instr_alu[31:27] == 5'b0_0000) begin\n                alu_operator_o = ALU_SRL;               // Shift Right Logical by Immediate\n              end else if (instr_alu[31:27] == 5'b0_1000) begin\n                alu_operator_o = ALU_SRA;               // Shift Right Arithmetically by Immediate\n              end\n            end\n          end\n\n          default: ;\n        endcase\n      end\n\n      OPCODE_OP: begin  // Register-Register ALU operation\n        alu_op_a_mux_sel_o = OP_A_REG_A;\n        alu_op_b_mux_sel_o = OP_B_REG_B;\n\n        if (instr_alu[26]) begin\n          if (RV32B != RV32BNone) begin\n            unique case ({instr_alu[26:25], instr_alu[14:12]})\n              {2'b11, 3'b001}: begin\n                alu_operator_o   = ALU_CMIX; // cmix\n                alu_multicycle_o = 1'b1;\n                if (instr_first_cycle_i) begin\n                  use_rs3_d = 1'b1;\n                end else begin\n                  use_rs3_d = 1'b0;\n                end\n              end\n              {2'b11, 3'b101}: begin\n                alu_operator_o   = ALU_CMOV; // cmov\n                alu_multicycle_o = 1'b1;\n                if (instr_first_cycle_i) begin\n                  use_rs3_d = 1'b1;\n                end else begin\n                  use_rs3_d = 1'b0;\n                end\n              end\n              {2'b10, 3'b001}: begin\n                alu_operator_o   = ALU_FSL;  // fsl\n                alu_multicycle_o = 1'b1;\n                if (instr_first_cycle_i) begin\n                  use_rs3_d = 1'b1;\n                end else begin\n                  use_rs3_d = 1'b0;\n                end\n              end\n              {2'b10, 3'b101}: begin\n                alu_operator_o   = ALU_FSR;  // fsr\n                alu_multicycle_o = 1'b1;\n                if (instr_first_cycle_i) begin\n                  use_rs3_d = 1'b1;\n                end else begin\n                  use_rs3_d = 1'b0;\n                end\n              end\n              default: ;\n            endcase\n          end\n        end else begin\n          unique case ({instr_alu[31:25], instr_alu[14:12]})\n            // RV32I ALU operations\n            {7'b000_0000, 3'b000}: alu_operator_o = ALU_ADD;   // Add\n            {7'b010_0000, 3'b000}: alu_operator_o = ALU_SUB;   // Sub\n            {7'b000_0000, 3'b010}: alu_operator_o = ALU_SLT;   // Set Lower Than\n            {7'b000_0000, 3'b011}: alu_operator_o = ALU_SLTU;  // Set Lower Than Unsigned\n            {7'b000_0000, 3'b100}: alu_operator_o = ALU_XOR;   // Xor\n            {7'b000_0000, 3'b110}: alu_operator_o = ALU_OR;    // Or\n            {7'b000_0000, 3'b111}: alu_operator_o = ALU_AND;   // And\n            {7'b000_0000, 3'b001}: alu_operator_o = ALU_SLL;   // Shift Left Logical\n            {7'b000_0000, 3'b101}: alu_operator_o = ALU_SRL;   // Shift Right Logical\n            {7'b010_0000, 3'b101}: alu_operator_o = ALU_SRA;   // Shift Right Arithmetic\n\n            // RV32B ALU Operations\n            {7'b011_0000, 3'b001}: begin\n              if (RV32B != RV32BNone) begin\n                alu_operator_o = ALU_ROL;\n                alu_multicycle_o = 1'b1;\n              end\n            end\n            {7'b011_0000, 3'b101}: begin\n              if (RV32B != RV32BNone) begin\n                alu_operator_o = ALU_ROR;\n                alu_multicycle_o = 1'b1;\n              end\n            end\n\n            {7'b000_0101, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_MIN;\n            {7'b000_0101, 3'b110}: if (RV32B != RV32BNone) alu_operator_o = ALU_MAX;\n            {7'b000_0101, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_MINU;\n            {7'b000_0101, 3'b111}: if (RV32B != RV32BNone) alu_operator_o = ALU_MAXU;\n\n            {7'b000_0100, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_PACK;\n            {7'b010_0100, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_PACKU;\n            {7'b000_0100, 3'b111}: if (RV32B != RV32BNone) alu_operator_o = ALU_PACKH;\n\n            {7'b010_0000, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_XNOR;\n            {7'b010_0000, 3'b110}: if (RV32B != RV32BNone) alu_operator_o = ALU_ORN;\n            {7'b010_0000, 3'b111}: if (RV32B != RV32BNone) alu_operator_o = ALU_ANDN;\n\n            // RV32B zba\n            {7'b001_0000, 3'b010}: if (RV32B != RV32BNone) alu_operator_o = ALU_SH1ADD;\n            {7'b001_0000, 3'b100}: if (RV32B != RV32BNone) alu_operator_o = ALU_SH2ADD;\n            {7'b001_0000, 3'b110}: if (RV32B != RV32BNone) alu_operator_o = ALU_SH3ADD;\n\n            // RV32B zbs\n            {7'b010_0100, 3'b001}: if (RV32B != RV32BNone) alu_operator_o = ALU_BCLR;\n            {7'b001_0100, 3'b001}: if (RV32B != RV32BNone) alu_operator_o = ALU_BSET;\n            {7'b011_0100, 3'b001}: if (RV32B != RV32BNone) alu_operator_o = ALU_BINV;\n            {7'b010_0100, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_BEXT;\n\n            // RV32B zbf\n            {7'b010_0100, 3'b111}: if (RV32B != RV32BNone) "}
{"text": "alu_operator_o = ALU_BFP;\n\n            // RV32B zbp\n            {7'b011_0100, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_GREV;\n            {7'b001_0100, 3'b101}: if (RV32B != RV32BNone) alu_operator_o = ALU_GORC;\n            {7'b000_0100, 3'b001}: begin\n              if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) alu_operator_o = ALU_SHFL;\n            end\n            {7'b000_0100, 3'b101}: begin\n              if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) alu_operator_o = ALU_UNSHFL;\n            end\n            {7'b001_0100, 3'b010}: begin\n              if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) alu_operator_o = ALU_XPERM_N;\n            end\n            {7'b001_0100, 3'b100}: begin\n              if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) alu_operator_o = ALU_XPERM_B;\n            end\n            {7'b001_0100, 3'b110}: begin\n              if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) alu_operator_o = ALU_XPERM_H;\n            end\n            {7'b001_0000, 3'b001}: begin\n              if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) alu_operator_o = ALU_SLO;\n            end\n            {7'b001_0000, 3'b101}: begin\n              if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) alu_operator_o = ALU_SRO;\n            end\n\n            // RV32B zbc\n            {7'b000_0101, 3'b001}: begin\n              if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) alu_operator_o = ALU_CLMUL;\n            end\n            {7'b000_0101, 3'b010}: begin\n              if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) alu_operator_o = ALU_CLMULR;\n            end\n            {7'b000_0101, 3'b011}: begin\n              if (RV32B == RV32BOTEarlGrey || RV32B == RV32BFull) alu_operator_o = ALU_CLMULH;\n            end\n\n            // RV32B zbe\n            {7'b010_0100, 3'b110}: begin\n              if (RV32B == RV32BFull) begin\n                alu_operator_o = ALU_BDECOMPRESS;\n                alu_multicycle_o = 1'b1;\n              end\n            end\n            {7'b000_0100, 3'b110}: begin\n              if (RV32B == RV32BFull) begin\n                alu_operator_o = ALU_BCOMPRESS;\n                alu_multicycle_o = 1'b1;\n              end\n            end\n\n            // RV32M instructions, all use the same ALU operation\n            {7'b000_0001, 3'b000}: begin // mul\n              alu_operator_o = ALU_ADD;\n              mult_sel_o     = (RV32M == RV32MNone) ? 1'b0 : 1'b1;\n            end\n            {7'b000_0001, 3'b001}: begin // mulh\n              alu_operator_o = ALU_ADD;\n              mult_sel_o     = (RV32M == RV32MNone) ? 1'b0 : 1'b1;\n            end\n            {7'b000_0001, 3'b010}: begin // mulhsu\n              alu_operator_o = ALU_ADD;\n              mult_sel_o     = (RV32M == RV32MNone) ? 1'b0 : 1'b1;\n            end\n            {7'b000_0001, 3'b011}: begin // mulhu\n              alu_operator_o = ALU_ADD;\n              mult_sel_o     = (RV32M == RV32MNone) ? 1'b0 : 1'b1;\n            end\n            {7'b000_0001, 3'b100}: begin // div\n              alu_operator_o = ALU_ADD;\n              div_sel_o      = (RV32M == RV32MNone) ? 1'b0 : 1'b1;\n            end\n            {7'b000_0001, 3'b101}: begin // divu\n              alu_operator_o = ALU_ADD;\n              div_sel_o      = (RV32M == RV32MNone) ? 1'b0 : 1'b1;\n            end\n            {7'b000_0001, 3'b110}: begin // rem\n              alu_operator_o = ALU_ADD;\n              div_sel_o      = (RV32M == RV32MNone) ? 1'b0 : 1'b1;\n            end\n            {7'b000_0001, 3'b111}: begin // remu\n              alu_operator_o = ALU_ADD;\n              div_sel_o      = (RV32M == RV32MNone) ? 1'b0 : 1'b1;\n            end\n\n            default: ;\n          endcase\n        end\n      end\n\n      /////////////\n      // Special //\n      /////////////\n\n      OPCODE_MISC_MEM: begin\n        unique case (instr_alu[14:12])\n          3'b000: begin\n            // FENCE is treated as a NOP since all memory operations are already strictly ordered.\n            alu_operator_o     = ALU_ADD; // nop\n            alu_op_a_mux_sel_o = OP_A_REG_A;\n            alu_op_b_mux_sel_o = OP_B_IMM;\n          end\n          3'b001: begin\n            // FENCE.I will flush the IF stage, prefetch buffer and ICache if present.\n            if (BranchTargetALU) begin\n              bt_a_mux_sel_o     = OP_A_CURRPC;\n              bt_b_mux_sel_o     = IMM_B_INCR_PC;\n            end else begin\n              alu_op_a_mux_sel_o = OP_A_CURRPC;\n              alu_op_b_mux_sel_o = OP_B_IMM;\n              imm_b_mux_sel_o    = IMM_B_INCR_PC;\n              alu_operator_o     = ALU_ADD;\n            end\n          end\n          default: ;\n        endcase\n      end\n\n      OPCODE_SYSTEM: begin\n        if (instr_alu[14:12] == 3'b000) begin\n          // non CSR related SYSTEM instructions\n          alu_op_a_mux_sel_o = OP_A_REG_A;\n          alu_op_b_mux_sel_o = OP_B_IMM;\n        end else begin\n          // instruction to read/modify CSR\n          alu_op_b_mux_sel_o = OP_B_IMM;\n          imm_a_mux_sel_o    = IMM_A_Z;\n          imm_b_mux_sel_o    = IMM_B_I;  // CSR address is encoded in I imm\n\n          if (instr_alu[14]) begin\n            // rs1 field is used as immediate\n            alu_op_a_mux_sel_o = OP_A_IMM;\n          end else begin\n            alu_op_a_mux_sel_o = OP_A_REG_A;\n          end\n        end\n\n      end\n      default: ;\n    endcase\n  end\n\n  // do not enable multdiv in case of illegal instruction exceptions\n  assign mult_en_o = illegal_insn ? 1'b0 : mult_sel_o;\n  assign div_en_o  = illegal_insn ? 1'b0 : div_sel_o;\n\n  // make sure instructions accessing non-available registers in RV32E cause illegal\n  // instruction exceptions\n  assign illegal_insn_o = illegal_insn | illegal_reg_rv32e;\n\n  // do not propgate regfile write enable if non-available registers are accessed in RV32E\n  assign rf_we_o = rf_we & ~illegal_reg_rv32e;\n\n  // Not all bits are used\n  assign unused_instr_alu = {instr_alu[19:15],instr_alu[11:7]};\n\n  ////////////////\n  // Assertions //\n  ////////////////\n\n  // Selectors must be known/valid.\n  `ASSERT(IbexRegImmAluOpKnown, (opcode == OPCODE_OP_IMM) |->\n      !$isunknown(instr[14:12]))\nendmodule // controller\n"}
{"text": "// Copyright lowRISC contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Dummy instruction module\n *\n * Provides pseudo-randomly inserted fake instructions for secure code obfuscation\n */\n\n// SEC_CM: CTRL_FLOW.UNPREDICTABLE\nmodule ibex_dummy_instr import ibex_pkg::*; #(\n    parameter lfsr_seed_t RndCnstLfsrSeed = RndCnstLfsrSeedDefault,\n    parameter lfsr_perm_t RndCnstLfsrPerm = RndCnstLfsrPermDefault\n) (\n  // Clock and reset\n  input  logic        clk_i,\n  input  logic        rst_ni,\n\n  // Interface to CSRs\n  input  logic        dummy_instr_en_i,\n  input  logic [2:0]  dummy_instr_mask_i,\n  input  logic        dummy_instr_seed_en_i,\n  input  logic [31:0] dummy_instr_seed_i,\n\n  // Interface to IF stage\n  input  logic        fetch_valid_i,\n  input  logic        id_in_ready_i,\n  output logic        insert_dummy_instr_o,\n  output logic [31:0] dummy_instr_data_o\n);\n\n  localparam int unsigned TIMEOUT_CNT_W = 5;\n  localparam int unsigned OP_W          = 5;\n\n  typedef enum logic [1:0] {\n    DUMMY_ADD = 2'b00,\n    DUMMY_MUL = 2'b01,\n    DUMMY_DIV = 2'b10,\n    DUMMY_AND = 2'b11\n  } dummy_instr_e;\n\n  typedef struct packed {\n    dummy_instr_e             instr_type;\n    logic [OP_W-1:0]          op_b;\n    logic [OP_W-1:0]          op_a;\n    logic [TIMEOUT_CNT_W-1:0] cnt;\n  } lfsr_data_t;\n  localparam int unsigned LFSR_OUT_W = $bits(lfsr_data_t);\n\n  lfsr_data_t               lfsr_data;\n  logic [TIMEOUT_CNT_W-1:0] dummy_cnt_incr, dummy_cnt_threshold;\n  logic [TIMEOUT_CNT_W-1:0] dummy_cnt_d, dummy_cnt_q;\n  logic                     dummy_cnt_en;\n  logic                     lfsr_en;\n  logic [LFSR_OUT_W-1:0]    lfsr_state;\n  logic                     insert_dummy_instr;\n  logic [6:0]               dummy_set;\n  logic [2:0]               dummy_opcode;\n  logic [31:0]              dummy_instr;\n  logic [31:0]              dummy_instr_seed_q, dummy_instr_seed_d;\n\n  // Shift the LFSR every time we insert an instruction\n  assign lfsr_en = insert_dummy_instr & id_in_ready_i;\n\n  assign dummy_instr_seed_d = dummy_instr_seed_q ^ dummy_instr_seed_i;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      dummy_instr_seed_q <= '0;\n    end else if (dummy_instr_seed_en_i) begin\n      dummy_instr_seed_q <= dummy_instr_seed_d;\n    end\n  end\n\n  prim_lfsr #(\n      .LfsrDw      ( LfsrWidth       ),\n      .StateOutDw  ( LFSR_OUT_W      ),\n      .DefaultSeed ( RndCnstLfsrSeed ),\n      .StatePermEn ( 1'b1            ),\n      .StatePerm   ( RndCnstLfsrPerm )\n  ) lfsr_i (\n      .clk_i     ( clk_i                 ),\n      .rst_ni    ( rst_ni                ),\n      .seed_en_i ( dummy_instr_seed_en_i ),\n      .seed_i    ( dummy_instr_seed_d    ),\n      .lfsr_en_i ( lfsr_en               ),\n      .entropy_i ( '0                    ),\n      .state_o   ( lfsr_state            )\n  );\n\n  // Extract fields from LFSR\n  assign lfsr_data = lfsr_data_t'(lfsr_state);\n\n  // Set count threshold for inserting a new instruction. This is the pseudo-random value from the\n  // LFSR with a mask applied (based on CSR config data) to shorten the period if required.\n  assign dummy_cnt_threshold = lfsr_data.cnt & {dummy_instr_mask_i,{TIMEOUT_CNT_W-3{1'b1}}};\n  assign dummy_cnt_incr      = dummy_cnt_q + {{TIMEOUT_CNT_W-1{1'b0}},1'b1};\n  // Clear the counter everytime a new instruction is inserted\n  assign dummy_cnt_d         = insert_dummy_instr ? '0 : dummy_cnt_incr;\n  // Increment the counter for each executed instruction while dummy instuctions are\n  // enabled.\n  assign dummy_cnt_en        = dummy_instr_en_i & id_in_ready_i &\n                               (fetch_valid_i | insert_dummy_instr);\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      dummy_cnt_q <= '0;\n    end else if (dummy_cnt_en) begin\n      dummy_cnt_q <= dummy_cnt_d;\n    end\n  end\n\n  // Insert a dummy instruction each time the counter hits the threshold\n  assign insert_dummy_instr = dummy_instr_en_i & (dummy_cnt_q == dummy_cnt_threshold);\n\n  // Encode instruction\n  always_comb begin\n    unique case (lfsr_data.instr_type)\n      DUMMY_ADD: begin\n        dummy_set    = 7'b0000000;\n        dummy_opcode = 3'b000;\n      end\n      DUMMY_MUL: begin\n        dummy_set    = 7'b0000001;\n        dummy_opcode = 3'b000;\n      end\n      DUMMY_DIV: begin\n        dummy_set    = 7'b0000001;\n        dummy_opcode = 3'b100;\n      end\n      DUMMY_AND: begin\n        dummy_set    = 7'b0000000;\n        dummy_opcode = 3'b111;\n      end\n      default: begin\n        dummy_set    = 7'b0000000;\n        dummy_opcode = 3'b000;\n      end\n    endcase\n  end\n\n  //                    SET        RS2             RS1             OP            RD\n  assign dummy_instr = {dummy_set, lfsr_data.op_b, lfsr_data.op_a, dummy_opcode, 5'h00, 7'h33};\n\n  // Assign outputs\n  assign insert_dummy_instr_o = insert_dummy_instr;\n  assign dummy_instr_data_o   = dummy_instr;\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Execution stage\n *\n * Execution block: Hosts ALU and MUL/DIV unit\n */\nmodule ibex_ex_block #(\n  parameter ibex_pkg::rv32m_e RV32M           = ibex_pkg::RV32MFast,\n  parameter ibex_pkg::rv32b_e RV32B           = ibex_pkg::RV32BNone,\n  parameter bit               BranchTargetALU = 0\n) (\n  input  logic                  clk_i,\n  input  logic                  rst_ni,\n\n  // ALU\n  input  ibex_pkg::alu_op_e     alu_operator_i,\n  input  logic [31:0]           alu_operand_a_i,\n  input  logic [31:0]           alu_operand_b_i,\n  input  logic                  alu_instr_first_cycle_i,\n\n  // Branch Target ALU\n  // All of these signals are unusued when BranchTargetALU == 0\n  input  logic [31:0]           bt_a_operand_i,\n  input  logic [31:0]           bt_b_operand_i,\n\n  // Multiplier/Divider\n  input  ibex_pkg::md_op_e      multdiv_operator_i,\n  input  logic                  mult_en_i,             // dynamic enable signal, for FSM control\n  input  logic                  div_en_i,              // dynamic enable signal, for FSM control\n  input  logic                  mult_sel_i,            // static decoder output, for data muxes\n  input  logic                  div_sel_i,             // static decoder output, for data muxes\n  input  logic  [1:0]           multdiv_signed_mode_i,\n  input  logic [31:0]           multdiv_operand_a_i,\n  input  logic [31:0]           multdiv_operand_b_i,\n  input  logic                  multdiv_ready_id_i,\n  input  logic                  data_ind_timing_i,\n\n  // intermediate val reg\n  output logic [1:0]            imd_val_we_o,\n  output logic [33:0]           imd_val_d_o[2],\n  input  logic [33:0]           imd_val_q_i[2],\n\n  // Outputs\n  output logic [31:0]           alu_adder_result_ex_o, // to LSU\n  output logic [31:0]           result_ex_o,\n  output logic [31:0]           branch_target_o,       // to IF\n  output logic                  branch_decision_o,     // to ID\n\n  output logic                  ex_valid_o             // EX has valid output\n);\n\n  import ibex_pkg::*;\n\n  logic [31:0] alu_result, multdiv_result;\n\n  logic [32:0] multdiv_alu_operand_b, multdiv_alu_operand_a;\n  logic [33:0] alu_adder_result_ext;\n  logic        alu_cmp_result, alu_is_equal_result;\n  logic        multdiv_valid;\n  logic        multdiv_sel;\n  logic [31:0] alu_imd_val_q[2];\n  logic [31:0] alu_imd_val_d[2];\n  logic [ 1:0] alu_imd_val_we;\n  logic [33:0] multdiv_imd_val_d[2];\n  logic [ 1:0] multdiv_imd_val_we;\n\n  /*\n    The multdiv_i output is never selected if RV32M=RV32MNone\n    At synthesis time, all the combinational and sequential logic\n    from the multdiv_i module are eliminated\n  */\n  if (RV32M != RV32MNone) begin : gen_multdiv_m\n    assign multdiv_sel = mult_sel_i | div_sel_i;\n  end else begin : gen_multdiv_no_m\n    assign multdiv_sel = 1'b0;\n  end\n\n  // Intermediate Value Register Mux\n  assign imd_val_d_o[0] = multdiv_sel ? multdiv_imd_val_d[0] : {2'b0, alu_imd_val_d[0]};\n  assign imd_val_d_o[1] = multdiv_sel ? multdiv_imd_val_d[1] : {2'b0, alu_imd_val_d[1]};\n  assign imd_val_we_o   = multdiv_sel ? multdiv_imd_val_we : alu_imd_val_we;\n\n  assign alu_imd_val_q = '{imd_val_q_i[0][31:0], imd_val_q_i[1][31:0]};\n\n  assign result_ex_o  = multdiv_sel ? multdiv_result : alu_result;\n\n  // branch handling\n  assign branch_decision_o  = alu_cmp_result;\n\n  if (BranchTargetALU) begin : g_branch_target_alu\n    logic [32:0] bt_alu_result;\n    logic        unused_bt_carry;\n\n    assign bt_alu_result   = bt_a_operand_i + bt_b_operand_i;\n\n    assign unused_bt_carry = bt_alu_result[32];\n    assign branch_target_o = bt_alu_result[31:0];\n  end else begin : g_no_branch_target_alu\n    // Unused bt_operand signals cause lint errors, this avoids them\n    logic [31:0] unused_bt_a_operand, unused_bt_b_operand;\n\n    assign unused_bt_a_operand = bt_a_operand_i;\n    assign unused_bt_b_operand = bt_b_operand_i;\n\n    assign branch_target_o = alu_adder_result_ex_o;\n  end\n\n  /////////\n  // ALU //\n  /////////\n\n  ibex_alu #(\n    .RV32B(RV32B)\n  ) alu_i (\n    .operator_i         (alu_operator_i),\n    .operand_a_i        (alu_operand_a_i),\n    .operand_b_i        (alu_operand_b_i),\n    .instr_first_cycle_i(alu_instr_first_cycle_i),\n    .imd_val_q_i        (alu_imd_val_q),\n    .imd_val_we_o       (alu_imd_val_we),\n    .imd_val_d_o        (alu_imd_val_d),\n    .multdiv_operand_a_i(multdiv_alu_operand_a),\n    .multdiv_operand_b_i(multdiv_alu_operand_b),\n    .multdiv_sel_i      (multdiv_sel),\n    .adder_result_o     (alu_adder_result_ex_o),\n    .adder_result_ext_o (alu_adder_result_ext),\n    .result_o           (alu_result),\n    .comparison_result_o(alu_cmp_result),\n    .is_equal_result_o  (alu_is_equal_result)\n  );\n\n  ////////////////\n  // Multiplier //\n  ////////////////\n\n  if (RV32M == RV32MSlow) begin : gen_multdiv_slow\n    ibex_multdiv_slow multdiv_i (\n      .clk_i             (clk_i),\n      .rst_ni            (rst_ni),\n      .mult_en_i         (mult_en_i),\n      .div_en_i          (div_en_i),\n      .mult_sel_i        (mult_sel_i),\n      .div_sel_i         (div_sel_i),\n      .operator_i        (multdiv_operator_i),\n      .signed_mode_i     (multdiv_signed_mode_i),\n      .op_a_i            (multdiv_operand_a_i),\n      .op_b_i            (multdiv_operand_b_i),\n      .alu_adder_ext_i   (alu_adder_result_ext),\n      .alu_adder_i       (alu_adder_result_ex_o),\n      .equal_to_zero_i   (alu_is_equal_result),\n      .data_ind_timing_i (data_ind_timing_i),\n      .valid_o           (multdiv_valid),\n      .alu_operand_a_o   (multdiv_alu_operand_a),\n      .alu_operand_b_o   (multdiv_alu_operand_b),\n      .imd_val_q_i       (imd_val_q_i),\n      .imd_val_d_o       (multdiv_imd_val_d),\n      .imd_val_we_o      (multdiv_imd_val_we),\n      .multdiv_ready_id_i(multdiv_ready_id_i),\n      .multdiv_result_o  (multdiv_result)\n    );\n  end else if (RV32M == RV32MFast || RV32M == RV32MSingleCycle) begin : gen_multdiv_fast\n    ibex_multdiv_fast #(\n      .RV32M(RV32M)\n    ) multdiv_i (\n      .clk_i             (clk_i),\n      .rst_ni            (rst_ni),\n      .mult_en_i         (mult_en_i),\n      .div_en_i          (div_en_i),\n      .mult_sel_i        (mult_sel_i),\n      .div_sel_i         (div_sel_i),\n      .operator_i        (multdiv_operator_i),\n      .signed_mode_i     (multdiv_signed_mode_i),\n      .op_a_i            (multdiv_operand_a_i),\n      .op_b_i            (multdiv_operand_b_i),\n      .alu_operand_a_o   (multdiv_alu_operand_a),\n      .alu_operand_b_o   (multdiv_alu_operand_b),\n      .alu_adder_ext_i   (alu_adder_result_ext),\n      .alu_adder_i       (alu_adder_result_ex_o),\n      .equal_to_zero_i   (alu_is_equal_result),\n      .data_ind_timing_i (data_ind_timing_i),\n      .imd_val_q_i       (imd_val_q_i),\n      .imd_val_d_o       (multdiv_imd_val_d),\n      .imd_val_we_o      (multdiv_imd_val_we),\n      .multdiv_ready_id_i(multdiv_ready_id_i),\n      .valid_o           (multdiv_valid),\n      .multdiv_result_o  (multdiv_result)\n    );\n  end\n\n  // Multiplier/divider may require multiple cycles. The ALU output is valid in the same cycle\n  // unless the intermediate result register is being written (which indicates this isn't the\n  // final cycle of ALU operation).\n  assign ex_valid_o = multdiv_sel ? multdiv_valid : ~(|alu_imd_val_we);\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Fetch Fifo for 32 bit memory interface\n *\n * input port: send address and data to the FIFO\n * clear_i clears the FIFO for the following cycle, including any new request\n */\n\n`include \"prim_assert.sv\"\n\nmodule ibex_fetch_fifo #(\n  parameter int unsigned NUM_REQS = 2,\n  parameter bit          ResetAll = 1'b0\n) (\n  input  logic                clk_i,\n  input  logic                rst_ni,\n\n  // control signals\n  input  logic                clear_i,   // clears the contents of the FIFO\n  output logic [NUM_REQS-1:0] busy_o,\n\n  // input port\n  input  logic                in_valid_i,\n  input  logic [31:0]         in_addr_i,\n  input  logic [31:0]         in_rdata_i,\n  input  logic                in_err_i,\n\n  // output port\n  output logic                out_valid_o,\n  input  logic                out_ready_i,\n  output logic [31:0]         out_addr_o,\n  output logic [31:0]         out_rdata_o,\n  output logic                out_err_o,\n  output logic                out_err_plus2_o\n);\n\n  localparam int unsigned DEPTH = NUM_REQS+1;\n\n  // index 0 is used for output\n  logic [DEPTH-1:0] [31:0]  rdata_d,   rdata_q;\n  logic [DEPTH-1:0]         err_d,     err_q;\n  logic [DEPTH-1:0]         valid_d,   valid_q;\n  logic [DEPTH-1:0]         lowest_free_entry;\n  logic [DEPTH-1:0]         valid_pushed, valid_popped;\n  logic [DEPTH-1:0]         entry_en;\n\n  logic                     pop_fifo;\n  logic             [31:0]  rdata, rdata_unaligned;\n  logic                     err,   err_unaligned, err_plus2;\n  logic                     valid, valid_unaligned;\n\n  logic                     aligned_is_compressed, unaligned_is_compressed;\n\n  logic                     addr_incr_two;\n  logic [31:1]              instr_addr_next;\n  logic [31:1]              instr_addr_d, instr_addr_q;\n  logic                     instr_addr_en;\n  logic                     unused_addr_in;\n\n  /////////////////\n  // Output port //\n  /////////////////\n\n  assign rdata = valid_q[0] ? rdata_q[0] : in_rdata_i;\n  assign err   = valid_q[0] ? err_q[0]   : in_err_i;\n  assign valid = valid_q[0] | in_valid_i;\n\n  // The FIFO contains word aligned memory fetches, but the instructions contained in each entry\n  // might be half-word aligned (due to compressed instructions)\n  // e.g.\n  //              | 31               16 | 15               0 |\n  // FIFO entry 0 | Instr 1 [15:0]      | Instr 0 [15:0]     |\n  // FIFO entry 1 | Instr 2 [15:0]      | Instr 1 [31:16]    |\n  //\n  // The FIFO also has a direct bypass path, so a complete instruction might be made up of data\n  // from the FIFO and new incoming data.\n  //\n\n  // Construct the output data for an unaligned instruction\n  assign rdata_unaligned = valid_q[1] ? {rdata_q[1][15:0], rdata[31:16]} :\n                                        {in_rdata_i[15:0], rdata[31:16]};\n\n  // If entry[1] is valid, an error can come from entry[0] or entry[1], unless the\n  // instruction in entry[0] is compressed (entry[1] is a new instruction)\n  // If entry[1] is not valid, and entry[0] is, an error can come from entry[0] or the incoming\n  // data, unless the instruction in entry[0] is compressed\n  // If entry[0] is not valid, the error must come from the incoming data\n  assign err_unaligned   = valid_q[1] ? ((err_q[1] & ~unaligned_is_compressed) | err_q[0]) :\n                                        ((valid_q[0] & err_q[0]) |\n                                         (in_err_i & (~valid_q[0] | ~unaligned_is_compressed)));\n\n  // Record when an error is caused by the second half of an unaligned 32bit instruction.\n  // Only needs to be correct when unaligned and if err_unaligned is set\n  assign err_plus2       = valid_q[1] ? (err_q[1] & ~err_q[0]) :\n                                        (in_err_i & valid_q[0] & ~err_q[0]);\n\n  // An uncompressed unaligned instruction is only valid if both parts are available\n  assign valid_unaligned = valid_q[1] ? 1'b1 :\n                                        (valid_q[0] & in_valid_i);\n\n  // If there is an error, rdata is unknown\n  assign unaligned_is_compressed = (rdata[17:16] != 2'b11) & ~err;\n  assign aligned_is_compressed   = (rdata[ 1: 0] != 2'b11) & ~err;\n\n  ////////////////////////////////////////\n  // Instruction aligner (if unaligned) //\n  ////////////////////////////////////////\n\n  always_comb begin\n    if (out_addr_o[1]) begin\n      // unaligned case\n      out_rdata_o     = rdata_unaligned;\n      out_err_o       = err_unaligned;\n      out_err_plus2_o = err_plus2;\n\n      if (unaligned_is_compressed) begin\n        out_valid_o = valid;\n      end else begin\n        out_valid_o = valid_unaligned;\n      end\n    end else begin\n      // aligned case\n      out_rdata_o     = rdata;\n      out_err_o       = err;\n      out_err_plus2_o = 1'b0;\n      out_valid_o     = valid;\n    end\n  end\n\n  /////////////////////////\n  // Instruction address //\n  /////////////////////////\n\n  // Update the address on branches and every time an instruction is driven\n  assign instr_addr_en = clear_i | (out_ready_i & out_valid_o);\n\n  // Increment the address by two every time a compressed instruction is popped\n  assign addr_incr_two = instr_addr_q[1] ? unaligned_is_compressed :\n                                           aligned_is_compressed;\n\n  assign instr_addr_next = (instr_addr_q[31:1] +\n                            // Increment address by 4 or 2\n                            {29'd0,~addr_incr_two,addr_incr_two});\n\n  assign instr_addr_d = clear_i ? in_addr_i[31:1] :\n                                  instr_addr_next;\n\n  if (ResetAll) begin : g_instr_addr_ra\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        instr_addr_q <= '0;\n      end else if (instr_addr_en) begin\n        instr_addr_q <= instr_addr_d;\n      end\n    end\n  end else begin : g_instr_addr_nr\n    always_ff @(posedge clk_i) begin\n      if (instr_addr_en) begin\n        instr_addr_q <= instr_addr_d;\n      end\n    end\n  end\n\n  // Output PC of current instruction\n  assign out_addr_o      = {instr_addr_q, 1'b0};\n\n  // The LSB of the address is unused, since all addresses are halfword aligned\n  assign unused_addr_in = in_addr_i[0];\n\n  /////////////////\n  // FIFO status //\n  /////////////////\n\n  // Indicate the fill level of fifo-entries. This is used to determine when a new request can be\n  // made on the bus. The prefetch buffer only needs to know about the upper entries which overlap\n  // with NUM_REQS.\n  assign busy_o = valid_q[DEPTH-1:DEPTH-NUM_REQS];\n\n  /////////////////////\n  // FIFO management //\n  /////////////////////\n\n  // Since an entry can contain unaligned instructions, popping an entry can leave the entry valid\n  assign pop_fifo = out_ready_i & out_valid_o & (~aligned_is_compressed | out_addr_o[1]);\n\n  for (genvar i = 0; i < (DEPTH - 1); i++) begin : g_fifo_next\n    // Calculate lowest free entry (write pointer)\n    if (i == 0) begin : g_ent0\n      assign lowest_free_entry[i] = ~valid_q[i];\n    end else begin : g_ent_others\n      assign lowest_free_entry[i] = ~valid_q[i] & valid_q[i-1];\n    end\n\n    // An entry is set when an incoming request chooses the lowest available entry\n    assign valid_pushed[i] = (in_valid_i & lowest_free_entry[i]) |\n                             valid_q[i];\n    // Popping the FIFO shifts all entries down\n    assign valid_popped[i] = pop_fifo ? valid_pushed[i+1] : valid_pushed[i];\n    // All entries are wiped out on a clear\n    assign valid_d[i] = valid_popped[i] & ~clear_i;\n\n    // data flops are enabled if there is new data to shift into it, or\n    assign entry_en[i] = (valid_pushed[i+1] & pop_fifo) |\n                         // a new request is incoming and this is the lowest free entry\n                         (in_valid_i & lowest_free_entry[i] & ~pop_fifo);\n\n    // take the next entry or the incoming data\n    assign rdata_d[i]  = valid_q[i+1] ? rdata_q[i+1] : in_rdata_i;\n    assign err_d  [i]  = valid_q[i+1] ? err_q  [i+1] : in_err_i;\n  end\n  // The top entry is similar but with simpler muxing\n  assign lowest_free_entry[DEPTH-1] = ~valid_q[DEPTH-1] & valid_q[DEPTH-2];\n  assign valid_pushed     [DEPTH-1] = valid_q[DEPTH-1] | (in_valid_i & lowest_free_entry[DEPTH-1]);\n  assign valid_popped     [DEPTH-1] = pop_fifo ? 1'b0 : valid_pushed[DEPTH-1];\n  assign valid_d [DEPTH-1]          = valid_popped[DEPTH-1] & ~clear_i;\n  assign entry_en[DEPTH-1]          = in_valid_i & lowest_free_entry[DEPTH-1];\n  assign rdata_d [DEPTH-1]          = in_rdata_i;\n  assign err_d   [DEPTH-1]          = in_err_i;\n\n  ////////////////////\n  // FIFO registers //\n  ////////////////////\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      valid_q <= '0;\n    end else begin\n      valid_q <= valid_d;\n    end\n  end\n\n  for (genvar i = 0; i < DEPTH; i++) begin : g_fifo_regs\n    if (ResetAll) begin : g_rdata_ra\n      always_ff @(posedge clk_i or negedge rst_ni) begin\n        if (!rst_ni) begin\n          rdata_q[i] <= '0;\n          err_q[i]   <= '0;\n        end else if (entry_en[i]) begin\n          rdata_q[i] <= rdata_d[i];\n          err_q[i]   <= err_d[i];\n        end\n      end\n    end else begin : g_rdata_nr\n      always_ff @(posedge clk_i) begin\n        if (entry_en[i]) begin\n          rdata_q[i] <= rdata_d[i];\n          err_q[i]   <= err_d[i];\n        end\n      end\n    end\n  end\n\n  ////////////////\n  // Assertions //\n  ////////////////\n\n  // Must not push and pop simultaneously when FIFO full.\n  `ASSERT(IbexFetchFifoPushPopFull,\n      (in_valid_i && pop_fifo) |-> (!valid_q[DEPTH-1] || clear_i))\n\n  // Must not push to FIFO when full.\n  `ASSERT(IbexFetchFifoPushFull,\n      (in_valid_i) |-> (!valid_q[DEPTH-1] || clear_i))\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Instruction cache\n *\n * Provides an instruction cache along with cache management, instruction buffering and prefetching\n */\n\n`include \"prim_assert.sv\"\n\nmodule ibex_icache import ibex_pkg::*; #(\n  parameter bit          ICacheECC       = 1'b0,\n  parameter bit          ResetAll        = 1'b0,\n  parameter int unsigned BusSizeECC      = BUS_SIZE,\n  parameter int unsigned TagSizeECC      = IC_TAG_SIZE,\n  parameter int unsigned LineSizeECC     = IC_LINE_SIZE,\n  // Only cache branch targets\n  parameter bit          BranchCache     = 1'b0\n) (\n  // Clock and reset\n  input  logic                           clk_i,\n  input  logic                           rst_ni,\n\n  // Signal that the core would like instructions\n  input  logic                           req_i,\n\n  // Set the cache's address counter\n  input  logic                           branch_i,\n  input  logic [31:0]                    addr_i,\n\n  // IF stage interface: Pass fetched instructions to the core\n  input  logic                           ready_i,\n  output logic                           valid_o,\n  output logic [31:0]                    rdata_o,\n  output logic [31:0]                    addr_o,\n  output logic                           err_o,\n  output logic                           err_plus2_o,\n\n  // Instruction memory / interconnect interface: Fetch instruction data from memory\n  output logic                           instr_req_o,\n  input  logic                           instr_gnt_i,\n  output logic [31:0]                    instr_addr_o,\n  input  logic [BUS_SIZE-1:0]            instr_rdata_i,\n  input  logic                           instr_err_i,\n  input  logic                           instr_rvalid_i,\n\n  // RAM IO\n  output logic [IC_NUM_WAYS-1:0]         ic_tag_req_o,\n  output logic                           ic_tag_write_o,\n  output logic [IC_INDEX_W-1:0]          ic_tag_addr_o,\n  output logic [TagSizeECC-1:0]          ic_tag_wdata_o,\n  input  logic [TagSizeECC-1:0]          ic_tag_rdata_i [IC_NUM_WAYS],\n  output logic [IC_NUM_WAYS-1:0]         ic_data_req_o,\n  output logic                           ic_data_write_o,\n  output logic [IC_INDEX_W-1:0]          ic_data_addr_o,\n  output logic [LineSizeECC-1:0]         ic_data_wdata_o,\n  input  logic [LineSizeECC-1:0]         ic_data_rdata_i [IC_NUM_WAYS],\n  input  logic                           ic_scr_key_valid_i,\n  output logic                           ic_scr_key_req_o,\n\n  // Cache status\n  input  logic                           icache_enable_i,\n  input  logic                           icache_inval_i,\n  output logic                           busy_o,\n  output logic                           ecc_error_o\n);\n\n  // Number of fill buffers (must be >= 2)\n  localparam int unsigned NUM_FB        = 4;\n  // Request throttling threshold\n  localparam int unsigned FB_THRESHOLD  = NUM_FB - 2;\n\n  // Prefetch signals\n  logic [ADDR_W-1:0]                      lookup_addr_aligned;\n  logic [ADDR_W-1:0]                      prefetch_addr_d, prefetch_addr_q;\n  logic                                   prefetch_addr_en;\n  // Cache pipelipe IC0 signals\n  logic                                   lookup_throttle;\n  logic                                   lookup_req_ic0;\n  logic [ADDR_W-1:0]                      lookup_addr_ic0;\n  logic [IC_INDEX_W-1:0]                  lookup_index_ic0;\n  logic                                   fill_req_ic0;\n  logic [IC_INDEX_W-1:0]                  fill_index_ic0;\n  logic [IC_TAG_SIZE-1:0]                 fill_tag_ic0;\n  logic [IC_LINE_SIZE-1:0]                fill_wdata_ic0;\n  logic                                   lookup_grant_ic0;\n  logic                                   lookup_actual_ic0;\n  logic                                   fill_grant_ic0;\n  logic                                   tag_req_ic0;\n  logic [IC_INDEX_W-1:0]                  tag_index_ic0;\n  logic [IC_NUM_WAYS-1:0]                 tag_banks_ic0;\n  logic                                   tag_write_ic0;\n  logic [TagSizeECC-1:0]                  tag_wdata_ic0;\n  logic                                   data_req_ic0;\n  logic [IC_INDEX_W-1:0]                  data_index_ic0;\n  logic [IC_NUM_WAYS-1:0]                 data_banks_ic0;\n  logic                                   data_write_ic0;\n  logic [LineSizeECC-1:0]                 data_wdata_ic0;\n  // Cache pipelipe IC1 signals\n  logic [TagSizeECC-1:0]                  tag_rdata_ic1  [IC_NUM_WAYS];\n  logic [LineSizeECC-1:0]                 data_rdata_ic1 [IC_NUM_WAYS];\n  logic [LineSizeECC-1:0]                 hit_data_ecc_ic1;\n  logic [IC_LINE_SIZE-1:0]                hit_data_ic1;\n  logic                                   lookup_valid_ic1;\n  logic [ADDR_W-1:IC_INDEX_HI+1]          lookup_addr_ic1;\n  logic [IC_NUM_WAYS-1:0]                 tag_match_ic1;\n  logic                                   tag_hit_ic1;\n  logic [IC_NUM_WAYS-1:0]                 tag_invalid_ic1;\n  logic [IC_NUM_WAYS-1:0]                 lowest_invalid_way_ic1;\n  logic [IC_NUM_WAYS-1:0]                 round_robin_way_ic1, round_robin_way_q;\n  logic [IC_NUM_WAYS-1:0]                 sel_way_ic1;\n  logic                                   ecc_err_ic1;\n  logic                                   ecc_write_req;\n  logic [IC_NUM_WAYS-1:0]                 ecc_write_ways;\n  logic [IC_INDEX_W-1:0]                  ecc_write_index;\n  // Fill buffer signals\n  logic [$clog2(NUM_FB)-1:0]              fb_fill_level;\n  logic                                   fill_cache_new;\n  logic                                   fill_new_alloc;\n  logic                                   fill_spec_req, fill_spec_done, fill_spec_hold;\n  logic [NUM_FB-1:0][NUM_FB-1:0]          fill_older_d, fill_older_q;\n  logic [NUM_FB-1:0]                      fill_alloc_sel, fill_alloc;\n  logic [NUM_FB-1:0]                      fill_busy_d, fill_busy_q;\n  logic [NUM_FB-1:0]                      fill_done;\n  logic [NUM_FB-1:0]                      fill_in_ic1;\n  logic [NUM_FB-1:0]                      fill_stale_d, fill_stale_q;\n  logic [NUM_FB-1:0]                      fill_cache_d, fill_cache_q;\n  logic [NUM_FB-1:0]                      fill_hit_ic1, fill_hit_d, fill_hit_q;\n  logic [NUM_FB-1:0][IC_LINE_BEATS_W:0]   fill_ext_cnt_d, fill_ext_cnt_q;\n  logic [NUM_FB-1:0]                      fill_ext_hold_d, fill_ext_hold_q;\n  logic [NUM_FB-1:0]                      fill_ext_done_d, fill_ext_done_q;\n  logic [NUM_FB-1:0][IC_LINE_BEATS_W:0]   fill_rvd_cnt_d, fill_rvd_cnt_q;\n  logic [NUM_FB-1:0]                      fill_rvd_done;\n  logic [NUM_FB-1:0]                      fill_ram_done_d, fill_ram_done_q;\n  logic [NUM_FB-1:0]                      fill_out_grant;\n  logic [NUM_FB-1:0][IC_LINE_BEATS_W:0]   fill_out_cnt_d, fill_out_cnt_q;\n  logic [NUM_FB-1:0]                      fill_out_done;\n  logic [NUM_FB-1:0]                      fill_ext_req, fill_rvd_exp, fill_ram_req, fill_out_req;\n  logic [NUM_FB-1:0]                      fill_data_sel, fill_data_reg;\n  logic [NUM_FB-1:0]                      fill_data_hit, fill_data_rvd;\n  logic [NUM_FB-1:0][IC_LINE_BEATS_W-1:0] fill_ext_off, fill_rvd_off;\n  logic [NUM_FB-1:0][IC_LINE_BEATS_W:0]   fill_ext_beat, fill_rvd_beat;\n  logic [NUM_FB-1:0]                      fill_ext_arb, fill_ram_arb, fill_out_arb;\n  logic [NUM_FB-1:0]                      fill_rvd_arb;\n  logic [NUM_FB-1:0]                      fill_entry_en;\n  logic [NUM_FB-1:0]                      fill_addr_en;\n  logic [NUM_FB-1:0]                      fill_way_en;\n  logic [NUM_FB-1:0][IC_LINE_BEATS-1:0]   fill_data_en;\n  logic [NUM_FB-1:0][IC_LINE_BEATS-1:0]   fill_err_d, fill_err_q;\n  logic [ADDR_W-1:0]                      fill_addr_q [NUM_FB];\n  logic [IC_NUM_WAYS-1:0]                 fill_way_q  [NUM_FB];\n  logic [IC_LINE_SIZE-1:0]                fill_data_d [NUM_FB];\n  logic [IC_LINE_SIZE-1:0]                fill_data_q [NUM_FB];\n  logic [ADDR_W-1:BUS_W]                  fill_ext_req_addr;\n  logic [ADDR_W-1:0]                      fill_ram_req_addr;\n  logic [IC_NUM_WAYS-1:0]                 fill_ram_req_way;\n  logic [IC_LINE_SIZE-1:0]                fill_ram_req_data;\n  logic [IC_LINE_SIZE-1:0]                fill_out_data;\n  logic [IC_LINE_BEATS-1:0]               fill_out_err;\n  // External req signals\n  logic                                   instr_req;\n  logic [ADDR_W-1:BUS_W]                  instr_addr;\n  // Data output signals\n  logic                                   skid_complete_instr;\n  logic                                   skid_ready;\n  logic                                   output_compressed;\n  logic                                   skid_valid_d, skid_valid_q, skid_en;\n  logic [15:0]                            skid_data_d, skid_data_q;\n  logic                                   skid_err_q;\n  logic                                   output_valid;\n  logic                                   addr_incr_two;\n  logic                                   output_addr_en;\n  logic [ADDR_W-1:1]                      output_addr_incr;\n  logic [ADDR_W-1:1]                      output_addr_d, output_addr_q;\n  logic [15:0]                            output_data_lo, output_data_hi;\n  logic                                   data_valid, output_ready;\n  logic [IC_LINE_SIZE-1:0]                line_data;\n  logic [IC_LINE_BEATS-1:0]               line_err;\n  logic [31:0]                            line_data_muxed;\n  logic                                   line_err_muxed;\n  logic [31:0]                            output_data;\n  logic                                   output_err;\n  // Invalidations\n  typedef enum logic [1:0] {\n    OUT_OF_RESET,\n    AWAIT_SCRAMBLE_KEY,\n    INVAL_CACHE,\n    IDLE\n  } inval_state_e;\n\n  inval_state_e          inval_state_q, inval_state_d;\n  logic                  inval_write_req;\n  logic                  inval_block_cache;\n  logic [IC_INDEX_W-1:0] inval_index_d, inval_index_q;\n  logic                  inval_index_en;\n  logic                  inval_active;\n\n  //////////////////////////\n  // Instruction prefetch //\n  //////////////////////////\n\n  assign lookup_addr_aligned = {lookup_addr_ic0[ADDR_W-1:IC_LINE_W], {IC_LINE_W{1'b0}}};\n\n  // The prefetch address increments by one cache line for each granted request.\n  // This address is also updated if there is a branch that is not granted, since the target\n  // address (addr_i) is only valid for one cycle while branch_i is high.\n\n  // The captured branch target address is not forced to be aligned since the offset in the cache\n  // line must also be recorded for later use by the fill buffers.\n  assign prefetch_addr_d     =\n      lookup_grant_ic0 ? (lookup_addr_aligned +\n                          {{ADDR_W-IC_LINE_W-1{1'b0}}, 1'b1, {IC_LINE_W{1'b0}}}) :\n                         addr_i;\n\n  assign prefetch_addr_en    = branch_i | lookup_grant_ic0;\n\n  if (ResetAll) begin : g_prefetch_addr_ra\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        prefetch_addr_q <= '0;\n      end else if (prefetch_addr_en) begin\n        prefetch_addr_q <= prefetch_addr_d;\n      end\n    end\n  end else begin : g_prefetch_addr_nr\n    always_ff @(posedge clk_i) begin\n      if (prefetch_addr_en) begin\n        prefetch_addr_q <= prefetch_addr_d;\n      end\n    end\n  end\n\n  ////////////////////////\n  // Pipeline stage IC0 //\n  ////////////////////////\n\n  // Cache lookup\n  assign lookup_throttle  = (fb_fill_level > FB_THRESHOLD[$clog2(NUM_FB)-1:0]);\n\n  assign lookup_req_ic0   = req_i & ~&fill_busy_q & (branch_i | ~lookup_throttle) &\n                            ~ecc_write_req;\n  assign lookup_addr_ic0  = branch_i ? addr_i : prefetch_addr_q;\n  assign lookup_index_ic0 = lookup_addr_ic0[IC_INDEX_HI:IC_LINE_W];\n\n  // Cache write\n  assign fill_req_ic0   = (|fill_ram_req);\n  assign fill_index_ic0 = fill_ram_req_addr[IC_INDEX_HI:IC_LINE_W];\n  assign fill_tag_ic0   = {(~inval_write_req & ~ecc_write_req),\n                           fill_ram_req_addr[ADDR_W-1:IC_INDEX_HI+1]};\n  assign fill_wdata_ic0 = fill_ram_req_data;\n\n  // Arbitrated signals - lookups have highest priority\n  assign lookup_grant_ic0  = lookup_req_ic0;\n  assign fill_grant_ic0    = fill_req_ic0 & ~lookup_req_ic0 & ~inval_write_req &\n                             ~ecc_write_req;\n  // Qualified lookup grant to mask ram signals in IC1 if access was not made\n  assign lookup_actual_ic0 = lookup_grant_ic0 & icache_enable_i & ~inval_block_cache;\n\n  // Tagram\n  assign tag_req_ic0   = lookup_req_ic0 | fill_req_ic0 | inval_write_req | ecc_write_req;\n  assign tag_index_ic0 = inval_write_req ? inval_index_q :\n                         ecc_write_req   ? ecc_write_index :\n                         fill_grant_ic0  ? fill_index_ic0 :\n                                           lookup_index_ic0;\n  assign tag_banks_ic0 = ecc_write_req  ? ecc_write_ways :\n                         fill_grant_ic0 ? fill_ram_req_way :\n                                          {IC_NUM_WAYS{1'b1}};\n  assign tag_write_ic0 = fill_grant_ic0 | inval_write_req | ecc_write_req;\n\n  // Dataram\n  assign data_req_ic0   = lookup_req_ic0 | fill_req_ic0;\n  assign data_index_ic0 = tag_index_ic0;\n  assign data_banks_ic0 = tag_banks_ic0;\n  assign data_write_ic0 = tag_write_ic0;\n\n  // Append ECC checkbits to write data if required\n  if (ICacheECC) begin : gen_ecc_wdata\n    // SEC_CM: ICACHE.MEM.INTEGRITY\n    // Tagram ECC\n    // Reuse the same ecc encoding module for larger cache sizes by padding with zeros\n    logic [21:0]             tag_ecc_input_padded;\n    logic [27:0]             tag_ecc_output_padded;\n    logic [22-IC_TAG_SIZE:0] unused_tag_ecc_output;\n\n    assign tag_ecc_input_padded  = {{22-IC_TAG_SIZE{1'b0}},fill_tag_ic0};\n    assign unused_tag_ecc_output = tag_ecc_output_padded[21:IC_TAG_SIZE-1];\n\n    prim_secded_inv_28_22_enc tag_ecc_enc (\n      .data_i (tag_ecc_input_padded),\n      .data_o (tag_ecc_output_padded)\n    );\n\n    assign tag_wdata_ic0 = {tag_ecc_output_padded[27:22],tag_ecc_output_padded[IC_TAG_SIZE-1:0]};\n\n    // Dataram ECC\n    for (genvar bank = 0; bank < IC_LINE_BEATS; bank++) begin : gen_ecc_banks\n      prim_secded_inv_39_32_enc data_ecc_enc (\n        .data_i (fill_wdata_ic0[bank*BUS_SIZE+:BUS_SIZE]),\n        .data_o (data_wdata_ic0[bank*BusSizeECC+:BusSizeECC])\n      );\n    end\n\n  end else begin : gen_noecc_wdata\n    assign tag_wdata_ic0  = fill_tag_ic0;\n    assign data_wdata_ic0 = fill_wdata_ic0;\n  end\n\n  ////////////////\n  // IC0 -> IC1 //\n  ////////////////\n\n  // Tag RAMs outputs\n  assign ic_tag_req_o    = {IC_NUM_WAYS{tag_req_ic0}} & tag_banks_ic0;\n  assign ic_tag_write_o  = tag_write_ic0;\n  assign ic_tag_addr_o   = tag_index_ic0;\n  assign ic_tag_wdata_o  = tag_wdata_ic0;\n\n  // Tag RAMs inputs\n  assign tag_rdata_ic1   = ic_tag_rdata_i;\n\n  // Data RAMs outputs\n  assign ic_data_req_o   = {IC_NUM_WAYS{data_req_ic0}} & data_banks_ic0;\n  assign ic_data_write_o = data_write_ic0;\n  assign ic_data_addr_o  = data_index_ic0;\n  assign ic_data_wdata_o = data_wdata_ic0;\n\n  // Data RAMs inputs\n  assign data_rdata_ic1  = ic_data_rdata_i;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      lookup_valid_ic1 <= 1'b0;\n    end else begin\n      lookup_valid_ic1 <= lookup_actual_ic0;\n    end\n  end\n\n  if (ResetAll) begin : g_lookup_addr_ra\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        lookup_addr_ic1 <= '0;\n        fill_in_ic1     <= '0;\n      end else if (lookup_grant_ic0) begin\n        lookup_addr_ic1 <= lookup_addr_ic0[ADDR_W-1:IC_INDEX_HI+1];\n        fill_in_ic1     <= fill_alloc_sel;\n      end\n    end\n  end else begin : g_lookup_addr_nr\n    always_ff @(posedge clk_i) begin\n      if (lookup_grant_ic0) begin\n        lookup_addr_ic1 <= lookup_addr_ic0[ADDR_W-1:IC_INDEX_HI+1];\n        fill_in_ic1     <= fill_alloc_sel;\n      end\n    end\n  end\n\n  ////////////////////////\n  // Pipeline stage IC1 //\n  ////////////////////////\n\n  // Tag matching\n  for (genvar way = 0; way < IC_NUM_WAYS; way++) begin : gen_tag_match\n    assign tag_match_ic1[way]   = (tag_rdata_ic1[way][IC_TAG_SIZE-1:0] ==\n                                   {1'b1,lookup_addr_ic1[ADDR_W-1:IC_INDEX_HI+1]});\n    assign tag_invalid_ic1[way] = ~tag_rdata_ic1[way][IC_TAG_SIZE-1];\n  end\n\n  assign tag_hit_ic1 = |tag_match_ic1;\n\n  // Hit data mux\n  always_comb begin\n    hit_data_ecc_ic1 = 'b0;\n    for (int way = 0; way < IC_NUM_WAYS; way++) begin\n      if (tag_match_ic1[way]) begin\n        hit_data_ecc_ic1 |= data_rdata_ic1[way];\n      end\n    end\n  end\n\n  // Way selection for allocations to the cache (onehot signals)\n  // 1 first invalid way\n  // 2 global round-robin (pseudorandom) way\n  assign lowest_invalid_way_ic1[0] = tag_invalid_ic1[0];\n  assign round_robin_way_ic1[0]    = round_robin_way_q[IC_NUM_WAYS-1];\n  for (genvar way = 1; way < IC_NUM_WAYS; way++) begin : gen_lowest_way\n    assign lowest_invalid_way_ic1[way] = tag_invalid_ic1[way] & ~|tag_invalid_ic1[way-1:0];\n    assign round_robin_way_ic1[way]    = round_robin_way_q[way-1];\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      round_robin_way_q <= {{IC_NUM_WAYS-1{1'b0}}, 1'b1};\n    end else if (lookup_valid_ic1) begin\n      round_robin_way_q <= round_robin_way_ic1;\n    end\n  end\n\n  assign sel_way_ic1 = |tag_invalid_ic1 ? lowest_invalid_way_ic1 :\n                                          round_robin_way_q;\n\n  // ECC checking logic\n  if (ICacheECC) begin : gen_data_ecc_checking\n    // SEC_CM: ICACHE.MEM.INTEGRITY\n    logic [IC_NUM_WAYS-1:0]     tag_err_ic1;\n    logic [IC_LINE_BEATS*2-1:0] data_err_ic1;\n    logic                       ecc_correction_write_d, ecc_correction_write_q;\n    logic [IC_NUM_WAYS-1:0]     ecc_correction_ways_d, ecc_correction_ways_q;\n    logic [IC_INDEX_W-1:0]      lookup_index_ic1, ecc_correction_index_q;\n\n    // Tag ECC checking\n    for (genvar way = 0; way < IC_NUM_WAYS; way++) begin : gen_tag_ecc\n      logic [1:0]  tag_err_bank_ic1;\n      logic [27:0] tag_rdata_padded_ic1;\n\n      // Expand the tag rdata with extra padding if the tag size is less than the maximum\n      assign tag_rdata_padded_ic1 = {tag_rdata_ic1[way][TagSizeECC-1-:6],\n                                     {22-IC_TAG_SIZE{1'b0}},\n                                     tag_rdata_ic1[way][IC_TAG_SIZE-1:0]};\n\n      prim_secded_inv_28_22_dec data_ecc_dec (\n        .data_i     (tag_rdata_padded_ic1),\n        .data_o     (),\n        .syndrome_o (),\n        .err_o      (tag_err_bank_ic1)\n      );\n      assign tag_err_ic1[way] = |tag_err_bank_ic1;\n    end\n\n    // Data ECC checking\n    // Note - could generate for all ways and mux after\n    for (genvar bank = 0; bank < IC_LINE_BEATS; bank++) begin : gen_ecc_banks\n      prim_secded_inv_39_32_dec data_ecc_dec (\n        .data_i     (hit_data_ecc_ic1[bank*BusSizeECC+:BusSizeECC]),\n        .data_o     (),\n        .syndrome_o (),\n        .err_o      (data_err_ic1[bank*2+:2])\n      );\n\n      assign hit_data_ic1[bank*BUS_SIZE+:BUS_SIZE] =\n          hit_data_ecc_ic1[bank*BusSizeECC+:BUS_SIZE];\n\n    end\n\n    // Tag ECC across all ways is always expected to be correct so the check does not need to be\n    // qualified by hit or tag valid. Initial (invalid with correct ECC) tags are written on reset\n    // and all further tag writes produce correct ECC. For data ECC no initialisation is done on\n    // reset so unused data (in particular those ways that don't have a valid tag) may have\n    // incorrect ECC. We only check data ECC where tags indicate it is valid and we have hit on it.\n    assign ecc_err_ic1 = lookup_valid_ic1 & (((|data_err_ic1) & tag_hit_ic1) | (|tag_err_ic1));\n\n    // Error correction\n    // All ways will be invalidated on a tag error to prevent X-propagation from data_err_ic1 on\n    // spurious hits. Also prevents the same line being allocated twice when there was a true\n    // hit and a spurious hit.\n    assign ecc_correction_ways_d  = {IC_NUM_WAYS{|tag_err_ic1}} |\n                           "}
{"text": "         (tag_match_ic1 & {IC_NUM_WAYS{|data_err_ic1}});\n    assign ecc_correction_write_d = ecc_err_ic1;\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        ecc_correction_write_q <= 1'b0;\n      end else begin\n        ecc_correction_write_q <= ecc_correction_write_d;\n      end\n    end\n\n    // The index is required in IC1 only when ECC is configured so is registered here\n    if (ResetAll) begin : g_lookup_ind_ra\n      always_ff @(posedge clk_i or negedge rst_ni) begin\n        if (!rst_ni) begin\n          lookup_index_ic1 <= '0;\n        end else if (lookup_grant_ic0) begin\n          lookup_index_ic1 <= lookup_addr_ic0[IC_INDEX_HI-:IC_INDEX_W];\n        end\n      end\n    end else begin : g_lookup_ind_nr\n      always_ff @(posedge clk_i) begin\n        if (lookup_grant_ic0) begin\n          lookup_index_ic1 <= lookup_addr_ic0[IC_INDEX_HI-:IC_INDEX_W];\n        end\n      end\n    end\n\n    // Store the ways with errors to be invalidated\n    if (ResetAll) begin : g_ecc_correction_ra\n      always_ff @(posedge clk_i or negedge rst_ni) begin\n        if (!rst_ni) begin\n          ecc_correction_ways_q  <= '0;\n          ecc_correction_index_q <= '0;\n        end else if (ecc_err_ic1) begin\n          ecc_correction_ways_q  <= ecc_correction_ways_d;\n          ecc_correction_index_q <= lookup_index_ic1;\n        end\n      end\n    end else begin : g_ecc_correction_nr\n      always_ff @(posedge clk_i) begin\n        if (ecc_err_ic1) begin\n          ecc_correction_ways_q  <= ecc_correction_ways_d;\n          ecc_correction_index_q <= lookup_index_ic1;\n        end\n      end\n    end\n\n    assign ecc_write_req   = ecc_correction_write_q;\n    assign ecc_write_ways  = ecc_correction_ways_q;\n    assign ecc_write_index = ecc_correction_index_q;\n\n    assign ecc_error_o = ecc_err_ic1;\n  end else begin : gen_no_data_ecc\n    assign ecc_err_ic1     = 1'b0;\n    assign ecc_write_req   = 1'b0;\n    assign ecc_write_ways  = '0;\n    assign ecc_write_index = '0;\n    assign hit_data_ic1    = hit_data_ecc_ic1;\n\n    assign ecc_error_o = 1'b0;\n  end\n\n  ///////////////////////////////\n  // Cache allocation decision //\n  ///////////////////////////////\n\n  if (BranchCache) begin : gen_caching_logic\n\n    // Cache branch target + a number of subsequent lines\n    localparam int unsigned CACHE_AHEAD = 2;\n    localparam int unsigned CACHE_CNT_W = (CACHE_AHEAD == 1) ? 1 : $clog2(CACHE_AHEAD) + 1;\n    logic                   cache_cnt_dec;\n    logic [CACHE_CNT_W-1:0] cache_cnt_d, cache_cnt_q;\n\n    assign cache_cnt_dec = lookup_grant_ic0 & (|cache_cnt_q);\n    assign cache_cnt_d   = branch_i ? CACHE_AHEAD[CACHE_CNT_W-1:0] :\n                                      (cache_cnt_q - {{CACHE_CNT_W-1{1'b0}},cache_cnt_dec});\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        cache_cnt_q <= '0;\n      end else begin\n        cache_cnt_q <= cache_cnt_d;\n      end\n    end\n\n    assign fill_cache_new = (branch_i | (|cache_cnt_q)) & icache_enable_i & ~inval_block_cache;\n  end else begin : gen_cache_all\n\n    // Cache all missing fetches\n    assign fill_cache_new = icache_enable_i & ~inval_block_cache;\n  end\n\n  //////////////////////////\n  // Fill buffer tracking //\n  //////////////////////////\n\n  always_comb begin\n    fb_fill_level = '0;\n    for (int i = 0; i < NUM_FB; i++) begin\n      if (fill_busy_q[i] & ~fill_stale_q[i]) begin\n        fb_fill_level += {{$clog2(NUM_FB) - 1{1'b0}}, 1'b1};\n      end\n    end\n  end\n\n  // Allocate a new buffer for every granted lookup\n  assign fill_new_alloc = lookup_grant_ic0;\n  // Track whether a speculative external request was made from IC0, and whether it was granted\n  // Speculative requests are only made for branches, or if the cache is disabled\n  assign fill_spec_req  = (~icache_enable_i | branch_i) & ~|fill_ext_req;\n  assign fill_spec_done = fill_spec_req & instr_gnt_i;\n  assign fill_spec_hold = fill_spec_req & ~instr_gnt_i;\n\n  for (genvar fb = 0; fb < NUM_FB; fb++) begin : gen_fbs\n\n    /////////////////////////////\n    // Fill buffer allocations //\n    /////////////////////////////\n\n    // Allocate the lowest available buffer\n    if (fb == 0) begin : gen_fb_zero\n      assign fill_alloc_sel[fb] = ~fill_busy_q[fb];\n    end else begin : gen_fb_rest\n      assign fill_alloc_sel[fb] = ~fill_busy_q[fb] & (&fill_busy_q[fb-1:0]);\n    end\n\n    assign fill_alloc[fb]      = fill_alloc_sel[fb] & fill_new_alloc;\n    assign fill_busy_d[fb]     = fill_alloc[fb] | (fill_busy_q[fb] & ~fill_done[fb]);\n\n    // Track which other fill buffers are older than this one (for age-based arbitration)\n    // TODO sparsify\n    assign fill_older_d[fb]    = (fill_alloc[fb] ? fill_busy_q : fill_older_q[fb]) & ~fill_done;\n\n    // A fill buffer can release once all its actions are completed\n                                 // all data written to the cache (unless hit or error)\n    assign fill_done[fb]       = (fill_ram_done_q[fb] | fill_hit_q[fb] | ~fill_cache_q[fb] |\n                                  (|fill_err_q[fb])) &\n                                 // all data output unless stale due to intervening branch\n                                 (fill_out_done[fb] | fill_stale_q[fb] | branch_i) &\n                                 // all external requests completed\n                                 fill_rvd_done[fb];\n\n    /////////////////////////////////\n    // Fill buffer status tracking //\n    /////////////////////////////////\n\n    // Track staleness (requests become stale when a branch intervenes)\n    assign fill_stale_d[fb]    = fill_busy_q[fb] & (branch_i | fill_stale_q[fb]);\n    // Track whether or not this request should allocate to the cache\n    // Any invalidation or disabling of the cache while the buffer is busy will stop allocation\n    assign fill_cache_d[fb]    = (fill_alloc[fb] & fill_cache_new) |\n                                 (fill_cache_q[fb] & fill_busy_q[fb] &\n                                  icache_enable_i & ~icache_inval_i);\n    // Record whether the request hit in the cache\n    assign fill_hit_ic1[fb]    = lookup_valid_ic1 & fill_in_ic1[fb] & tag_hit_ic1 & ~ecc_err_ic1;\n    assign fill_hit_d[fb]      = fill_hit_ic1[fb] | (fill_hit_q[fb] & fill_busy_q[fb]);\n\n    ///////////////////////////////////////////\n    // Fill buffer external request tracking //\n    ///////////////////////////////////////////\n\n    // Make an external request\n    assign fill_ext_req[fb]    = fill_busy_q[fb] & ~fill_ext_done_d[fb];\n\n    // Count the number of completed external requests (each line requires IC_LINE_BEATS requests)\n    assign fill_ext_cnt_d[fb]  = fill_alloc[fb] ?\n                                   {{IC_LINE_BEATS_W{1'b0}},fill_spec_done} :\n                                   (fill_ext_cnt_q[fb] + {{IC_LINE_BEATS_W{1'b0}},\n                                                          fill_ext_arb[fb] & instr_gnt_i});\n    // External request must be held until granted\n    assign fill_ext_hold_d[fb] = (fill_alloc[fb] & fill_spec_hold) |\n                                 (fill_ext_arb[fb] & ~instr_gnt_i);\n    // External requests are completed when the counter is filled or when the request is cancelled\n    assign fill_ext_done_d[fb] = (fill_ext_cnt_q[fb][IC_LINE_BEATS_W] |\n                                  // external requests are considered complete if the request hit\n                                  fill_hit_ic1[fb] | fill_hit_q[fb] |\n                                  // cancel if the line won't be cached and, it is stale\n                                  (~fill_cache_q[fb] & (branch_i | fill_stale_q[fb] |\n                                   // or we're already at the end of the line\n                                                        fill_ext_beat[fb][IC_LINE_BEATS_W]))) &\n                                 // can't cancel while we are waiting for a grant on the bus\n                                 ~fill_ext_hold_q[fb] & fill_busy_q[fb];\n    // Track whether this fill buffer expects to receive beats of data\n    assign fill_rvd_exp[fb]    = fill_busy_q[fb] & ~fill_rvd_done[fb];\n    // Count the number of rvalid beats received\n    assign fill_rvd_cnt_d[fb]  = fill_alloc[fb] ? '0 :\n                                                  (fill_rvd_cnt_q[fb] +\n                                                   {{IC_LINE_BEATS_W{1'b0}},fill_rvd_arb[fb]});\n    // External data is complete when all issued external requests have received their data\n    assign fill_rvd_done[fb]   = (fill_ext_done_q[fb] & ~fill_ext_hold_q[fb]) &\n                                 (fill_rvd_cnt_q[fb] == fill_ext_cnt_q[fb]);\n\n    //////////////////////////////////////\n    // Fill buffer data output tracking //\n    //////////////////////////////////////\n\n    // Send data to the IF stage for requests that are not stale, have not completed their\n    // data output, and have data available to send.\n    // Data is available if:\n    // - The request hit in the cache\n    // - Buffered data is available (fill_rvd_cnt_q is ahead of fill_out_cnt_q)\n    // - Data is available from the bus this cycle (fill_rvd_arb)\n    assign fill_out_req[fb]    = fill_busy_q[fb] & ~fill_stale_q[fb] & ~fill_out_done[fb] &\n                                 (fill_hit_ic1[fb] | fill_hit_q[fb] |\n                                  (fill_rvd_beat[fb] > fill_out_cnt_q[fb]) | fill_rvd_arb[fb]);\n\n    // Calculate when a beat of data is output. Any ECC error squashes the output that cycle.\n    assign fill_out_grant[fb]  = fill_out_arb[fb] & output_ready;\n\n    // Count the beats of data output to the IF stage\n    assign fill_out_cnt_d[fb]  = fill_alloc[fb] ? {1'b0,lookup_addr_ic0[IC_LINE_W-1:BUS_W]} :\n                                                  (fill_out_cnt_q[fb] +\n                                                   {{IC_LINE_BEATS_W{1'b0}},fill_out_grant[fb]});\n    // Data output complete when the counter fills\n    assign fill_out_done[fb]   = fill_out_cnt_q[fb][IC_LINE_BEATS_W];\n\n    //////////////////////////////////////\n    // Fill buffer ram request tracking //\n    //////////////////////////////////////\n\n                                 // make a fill request once all data beats received\n    assign fill_ram_req[fb]    = fill_busy_q[fb] & fill_rvd_cnt_q[fb][IC_LINE_BEATS_W] &\n                                 // unless the request hit, was non-allocating or got an error\n                                 ~fill_hit_q[fb] & fill_cache_q[fb] & ~|fill_err_q[fb] &\n                                 // or the request was already completed\n                                 ~fill_ram_done_q[fb];\n\n    // Record when a cache allocation request has been completed\n    assign fill_ram_done_d[fb] = fill_ram_arb[fb] | (fill_ram_done_q[fb] & fill_busy_q[fb]);\n\n    //////////////////////////////\n    // Fill buffer line offsets //\n    //////////////////////////////\n\n    // When we branch into the middle of a line, the output count will not start from zero. This\n    // beat count is used to know which incoming rdata beats are relevant.\n    assign fill_ext_beat[fb]   = {1'b0,fill_addr_q[fb][IC_LINE_W-1:BUS_W]} +\n                                 fill_ext_cnt_q[fb][IC_LINE_BEATS_W:0];\n    assign fill_ext_off[fb]    = fill_ext_beat[fb][IC_LINE_BEATS_W-1:0];\n    assign fill_rvd_beat[fb]   = {1'b0,fill_addr_q[fb][IC_LINE_W-1:BUS_W]} +\n                                 fill_rvd_cnt_q[fb][IC_LINE_BEATS_W:0];\n    assign fill_rvd_off[fb]    = fill_rvd_beat[fb][IC_LINE_BEATS_W-1:0];\n\n    /////////////////////////////\n    // Fill buffer arbitration //\n    /////////////////////////////\n\n    // Age based arbitration - all these signals are one-hot\n    assign fill_ext_arb[fb]    = fill_ext_req[fb] & ~|(fill_ext_req & fill_older_q[fb]);\n    assign fill_ram_arb[fb]    = fill_ram_req[fb] & fill_grant_ic0 &\n                                 ~|(fill_ram_req & fill_older_q[fb]);\n    // Calculate which fill buffer is the oldest one which still needs to output data to IF\n    assign fill_data_sel[fb]   = ~|(fill_busy_q & ~fill_out_done & ~fill_stale_q &\n                                    fill_older_q[fb]);\n    // Arbitrate the request which has data available to send, and is the oldest outstanding\n    assign fill_out_arb[fb]    = fill_out_req[fb] & fill_data_sel[fb];\n    // Assign incoming rvalid data to the oldest fill buffer expecting it\n    assign fill_rvd_arb[fb]    = instr_rvalid_i & fill_rvd_exp[fb] &\n                                 ~|(fill_rvd_exp & fill_older_q[fb]);\n\n    /////////////////////////////\n    // Fill buffer data muxing //\n    /////////////////////////////\n\n    // Output data muxing controls\n    // 1. Select data from the fill buffer data register\n    assign fill_data_reg[fb]   = fill_busy_q[fb] & ~fill_stale_q[fb] &\n                                 ~fill_out_done[fb] & fill_data_sel[fb] &\n    //                           The incoming data is already ahead of the output count\n                                 ((fill_rvd_beat[fb] > fill_out_cnt_q[fb]) | fill_hit_q[fb] |\n                                  (|fill_err_q[fb]));\n    // 2. Select IC1 hit data\n    assign fill_data_hit[fb]   = fill_busy_q[fb] & fill_hit_ic1[fb] & fill_data_sel[fb];\n    // 3. Select incoming instr_rdata_i\n    assign fill_data_rvd[fb]   = fill_busy_q[fb] & fill_rvd_arb[fb] & ~fill_hit_q[fb] &\n                                 ~fill_hit_ic1[fb] & ~fill_stale_q[fb] & ~fill_out_done[fb] &\n    //                           The incoming data lines up with the output count\n                                 (fill_rvd_beat[fb] == fill_out_cnt_q[fb]) & fill_data_sel[fb];\n\n\n    ///////////////////////////\n    // Fill buffer registers //\n    ///////////////////////////\n\n    // Fill buffer general enable\n    assign fill_entry_en[fb]   = fill_alloc[fb] | fill_busy_q[fb];\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        fill_busy_q[fb]     <= 1'b0;\n        fill_older_q[fb]    <= '0;\n        fill_stale_q[fb]    <= 1'b0;\n        fill_cache_q[fb]    <= 1'b0;\n        fill_hit_q[fb]      <= 1'b0;\n        fill_ext_cnt_q[fb]  <= '0;\n        fill_ext_hold_q[fb] <= 1'b0;\n        fill_ext_done_q[fb] <= 1'b0;\n        fill_rvd_cnt_q[fb]  <= '0;\n        fill_ram_done_q[fb] <= 1'b0;\n        fill_out_cnt_q[fb]  <= '0;\n      end else if (fill_entry_en[fb]) begin\n        fill_busy_q[fb]     <= fill_busy_d[fb];\n        fill_older_q[fb]    <= fill_older_d[fb];\n        fill_stale_q[fb]    <= fill_stale_d[fb];\n        fill_cache_q[fb]    <= fill_cache_d[fb];\n        fill_hit_q[fb]      <= fill_hit_d[fb];\n        fill_ext_cnt_q[fb]  <= fill_ext_cnt_d[fb];\n        fill_ext_hold_q[fb] <= fill_ext_hold_d[fb];\n        fill_ext_done_q[fb] <= fill_ext_done_d[fb];\n        fill_rvd_cnt_q[fb]  <= fill_rvd_cnt_d[fb];\n        fill_ram_done_q[fb] <= fill_ram_done_d[fb];\n        fill_out_cnt_q[fb]  <= fill_out_cnt_d[fb];\n      end\n    end\n\n    ////////////////////////////////////////\n    // Fill buffer address / data storage //\n    ////////////////////////////////////////\n\n    assign fill_addr_en[fb]    = fill_alloc[fb];\n    assign fill_way_en[fb]     = (lookup_valid_ic1 & fill_in_ic1[fb]);\n\n    if (ResetAll) begin : g_fill_addr_ra\n      always_ff @(posedge clk_i or negedge rst_ni) begin\n        if (!rst_ni) begin\n          fill_addr_q[fb] <= '0;\n        end else if (fill_addr_en[fb]) begin\n          fill_addr_q[fb] <= lookup_addr_ic0;\n        end\n      end\n    end else begin : g_fill_addr_nr\n      always_ff @(posedge clk_i) begin\n        if (fill_addr_en[fb]) begin\n          fill_addr_q[fb] <= lookup_addr_ic0;\n        end\n      end\n    end\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        fill_way_q[fb]  <= '0;\n      end else if (fill_way_en[fb]) begin\n        fill_way_q[fb]  <= sel_way_ic1;\n      end\n    end\n\n    // Data either comes from the cache or the bus. If there was an ECC error, we must take\n    // the incoming bus data since the cache hit data is corrupted.\n    assign fill_data_d[fb] = fill_hit_ic1[fb] ? hit_data_ic1 :\n                                                {IC_LINE_BEATS{instr_rdata_i}};\n\n    for (genvar b = 0; b < IC_LINE_BEATS; b++) begin : gen_data_buf\n      // Error tracking (per beat)\n      assign fill_err_d[fb][b]   = (fill_rvd_arb[fb] & instr_err_i &\n                                    (fill_rvd_off[fb] == b[IC_LINE_BEATS_W-1:0])) |\n      //                           Hold the error once recorded\n                                   (fill_busy_q[fb] & fill_err_q[fb][b]);\n\n      always_ff @(posedge clk_i or negedge rst_ni) begin\n        if (!rst_ni) begin\n          fill_err_q[fb][b] <= '0;\n        end else if (fill_entry_en[fb]) begin\n          fill_err_q[fb][b] <= fill_err_d[fb][b];\n        end\n      end\n\n      // Enable the relevant part of the data register (or all for cache hits)\n      // Ignore incoming rvalid data when we already have cache hit data\n      assign fill_data_en[fb][b] = fill_hit_ic1[fb] |\n                                   (fill_rvd_arb[fb] & ~fill_hit_q[fb] &\n                                    (fill_rvd_off[fb] == b[IC_LINE_BEATS_W-1:0]));\n\n      if (ResetAll) begin : g_fill_data_ra\n        always_ff @(posedge clk_i or negedge rst_ni) begin\n          if (!rst_ni) begin\n            fill_data_q[fb][b*BUS_SIZE+:BUS_SIZE] <= '0;\n          end else if (fill_data_en[fb][b]) begin\n            fill_data_q[fb][b*BUS_SIZE+:BUS_SIZE] <= fill_data_d[fb][b*BUS_SIZE+:BUS_SIZE];\n          end\n        end\n      end else begin : g_fill_data_nr\n        always_ff @(posedge clk_i) begin\n          if (fill_data_en[fb][b]) begin\n            fill_data_q[fb][b*BUS_SIZE+:BUS_SIZE] <= fill_data_d[fb][b*BUS_SIZE+:BUS_SIZE];\n          end\n        end\n      end\n\n    end\n  end\n\n  ////////////////////////////////\n  // Fill buffer one-hot muxing //\n  ////////////////////////////////\n\n  // External req info\n  always_comb begin\n    fill_ext_req_addr = '0;\n    for (int i = 0; i < NUM_FB; i++) begin\n      if (fill_ext_arb[i]) begin\n        fill_ext_req_addr |= {fill_addr_q[i][ADDR_W-1:IC_LINE_W], fill_ext_off[i]};\n      end\n    end\n  end\n\n  // Cache req info\n  always_comb begin\n    fill_ram_req_addr = '0;\n    fill_ram_req_way  = '0;\n    fill_ram_req_data = '0;\n    for (int i = 0; i < NUM_FB; i++) begin\n      if (fill_ram_arb[i]) begin\n        fill_ram_req_addr |= fill_addr_q[i];\n        fill_ram_req_way  |= fill_way_q[i];\n        fill_ram_req_data |= fill_data_q[i];\n      end\n    end\n  end\n\n  // IF stage output data\n  always_comb begin\n    fill_out_data = '0;\n    fill_out_err  = '0;\n    for (int i = 0; i < NUM_FB; i++) begin\n      if (fill_data_reg[i]) begin\n        fill_out_data |= fill_data_q[i];\n        // Ignore any speculative errors accumulated on cache hits\n        fill_out_err  |= (fill_err_q[i] & ~{IC_LINE_BEATS{fill_hit_q[i]}});\n      end\n    end\n  end\n\n  ///////////////////////\n  // External requests //\n  ///////////////////////\n\n  assign instr_req  = ((~icache_enable_i | branch_i) & lookup_grant_ic0) |\n                      (|fill_ext_req);\n\n  assign instr_addr = |fill_ext_req ? fill_ext_req_addr :\n                                      lookup_addr_ic0[ADDR_W-1:BUS_W];\n\n  assign instr_req_o  = instr_req;\n  assign instr_addr_o = {instr_addr[ADDR_W-1:BUS_W],{BUS_W{1'b0}}};\n\n  ////////////////////////\n  // Output data muxing //\n  ////////////////////////\n\n  // Mux between line-width data sources\n  assign line_data = |fill_data_hit ? hit_data_ic1 : fill_out_data;\n  assign line_err  = |fill_data_hit ? {IC_LINE_BEATS{1'b0}} : fill_out_err;\n\n  // Mux the relevant beat of line data, based on the output address\n  always_comb begin\n    line_data_muxed = '0;\n    line_err_muxed  = 1'b0;\n    for (int unsigned i = 0; i < IC_LINE_BEATS; i++) begin\n      // When data has been skidded, the output address is behind by one\n      if ((output_addr_q[IC_LINE_W-1:BUS_W] + {{IC_LINE_BEATS_W-1{1'b0}},skid_valid_q}) ==\n          i[IC_LINE_BEATS_W-1:0]) begin\n        line_data_muxed |= line_data[i*32+:32];\n        line_err_muxed  |= line_err[i];\n      end\n    end\n  end\n\n  // Mux between incoming rdata and the muxed line"}
{"text": " data\n  assign output_data = |fill_data_rvd ? instr_rdata_i : line_data_muxed;\n  assign output_err  = |fill_data_rvd ? instr_err_i   : line_err_muxed;\n\n  // Output data is valid (from any of the three possible sources). Note that fill_out_arb\n  // must be used here rather than fill_out_req because data can become valid out of order\n  // (e.g. cache hit data can become available ahead of an older outstanding miss).\n  assign data_valid = |fill_out_arb;\n\n  // Skid buffer data\n  assign skid_data_d = output_data[31:16];\n\n  assign skid_en     = data_valid & (ready_i | skid_ready);\n\n  if (ResetAll) begin : g_skid_data_ra\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        skid_data_q <= '0;\n        skid_err_q  <= '0;\n      end else if (skid_en) begin\n        skid_data_q <= skid_data_d;\n        skid_err_q  <= output_err;\n      end\n    end\n  end else begin : g_skid_data_nr\n    always_ff @(posedge clk_i) begin\n      if (skid_en) begin\n        skid_data_q <= skid_data_d;\n        skid_err_q  <= output_err;\n      end\n    end\n  end\n\n  // The data in the skid buffer is ready if it's a complete compressed instruction or if there's\n  // an error (no need to wait for the second half)\n  assign skid_complete_instr = skid_valid_q & ((skid_data_q[1:0] != 2'b11) | skid_err_q);\n\n  // Data can be loaded into the skid buffer for an unaligned uncompressed instruction\n  assign skid_ready = output_addr_q[1] & ~skid_valid_q & (~output_compressed | output_err);\n\n  assign output_ready = (ready_i | skid_ready) & ~skid_complete_instr;\n\n  assign output_compressed = (rdata_o[1:0] != 2'b11);\n\n  assign skid_valid_d =\n      // Branches invalidate the skid buffer\n      branch_i ? 1'b0 :\n      // Once valid, the skid buffer stays valid until a compressed instruction realigns the stream\n      (skid_valid_q ? ~(ready_i & ((skid_data_q[1:0] != 2'b11) | skid_err_q)) :\n      // The skid buffer becomes valid when:\n                        // - we branch to an unaligned uncompressed instruction\n                      (data_valid &\n                       (((output_addr_q[1] & (~output_compressed | output_err)) |\n                        // - a compressed instruction misaligns the stream\n                        (~output_addr_q[1] & output_compressed & ~output_err & ready_i)))));\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      skid_valid_q <= 1'b0;\n    end else begin\n      skid_valid_q <= skid_valid_d;\n    end\n  end\n\n  // Signal that valid data is available to the IF stage\n  // Note that if the first half of an unaligned instruction reports an error, we do not need\n  // to wait for the second half\n                        // Compressed instruction completely satisfied by skid buffer\n  assign output_valid = skid_complete_instr |\n                        // Output data available and, output stream aligned, or skid data available,\n                        (data_valid & (~output_addr_q[1] | skid_valid_q |\n                                       // or this is an error or an unaligned compressed instruction\n                                       output_err | (output_data[17:16] != 2'b11)));\n\n  // Update the address on branches and every time an instruction is driven\n  assign output_addr_en = branch_i | (ready_i & valid_o);\n\n  // Increment the address by two every time a compressed instruction is popped\n  assign addr_incr_two = output_compressed & ~err_o;\n\n  // Next IF stage PC\n  assign output_addr_incr = (output_addr_q[31:1] +\n                             // Increment address by 4 or 2\n                             {29'd0, ~addr_incr_two, addr_incr_two});\n\n  // Redirect the address on branches\n  assign output_addr_d = branch_i ? addr_i[31:1] : output_addr_incr;\n\n  if (ResetAll) begin : g_output_addr_ra\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        output_addr_q <= '0;\n      end else if (output_addr_en) begin\n        output_addr_q <= output_addr_d;\n      end\n    end\n  end else begin : g_output_addr_nr\n    always_ff @(posedge clk_i) begin\n      if (output_addr_en) begin\n        output_addr_q <= output_addr_d;\n      end\n    end\n  end\n\n  // Mux the data from BUS_SIZE to halfword\n  // This muxing realigns data when instruction words are split across BUS_W e.g.\n  // word 1 |----|*h1*|\n  // word 0 |*h0*|----| --> |*h1*|*h0*|\n  //        31   15   0     31   15   0\n  always_comb begin\n    output_data_lo = '0;\n    for (int unsigned i = 0; i < IC_OUTPUT_BEATS; i++) begin\n      if (output_addr_q[BUS_W-1:1] == i[BUS_W-2:0]) begin\n        output_data_lo |= output_data[i*16+:16];\n      end\n    end\n  end\n\n  always_comb begin\n    output_data_hi = '0;\n    for (int unsigned i = 0; i < IC_OUTPUT_BEATS - 1; i++) begin\n      if (output_addr_q[BUS_W-1:1] == i[BUS_W-2:0]) begin\n        output_data_hi |= output_data[(i+1)*16+:16];\n      end\n    end\n    if (&output_addr_q[BUS_W-1:1]) begin\n      output_data_hi |= output_data[15:0];\n    end\n  end\n\n  assign valid_o     = output_valid;\n  assign rdata_o     = {output_data_hi, (skid_valid_q ? skid_data_q : output_data_lo)};\n  assign addr_o      = {output_addr_q, 1'b0};\n  assign err_o       = (skid_valid_q & skid_err_q) | (~skid_complete_instr & output_err);\n  // Error caused by the second half of a misaligned uncompressed instruction\n  // (only relevant when err_o is set)\n  assign err_plus2_o = skid_valid_q & ~skid_err_q;\n\n  ///////////////////\n  // Invalidations //\n  ///////////////////\n\n  // Invalidation (writing all entries in the tag RAM with an invalid tag) occurs straight out of\n  // reset and after any invalidation request (signalled via icache_inval_i). An invalidation\n  // request coming whilst another is writing tags causes the invalidation to start again. This\n  // ensures a new scramble key is requested where a previous one is in use.\n  // TODO: Ditch this behaviour for non-secure ibex?\n  always_comb begin\n    inval_state_d     = inval_state_q;\n    inval_index_d     = inval_index_q;\n    inval_index_en    = 1'b0;\n    inval_write_req   = 1'b0;\n    ic_scr_key_req_o  = 1'b0;\n\n    // Prevent other cache activity (cache lookups and cache allocations) whilst an invalidation is\n    // in progress. Set to 1 by default as the only time we don't block is when the state machine is\n    // IDLE.\n    inval_block_cache = 1'b1;\n\n    unique case (inval_state_q)\n      OUT_OF_RESET: begin\n        // Initial state, this initialises the tag RAMs out of reset before the icache can be used\n        inval_state_d = AWAIT_SCRAMBLE_KEY;\n\n        if (~ic_scr_key_valid_i) begin\n          ic_scr_key_req_o = 1'b1;\n        end\n      end\n      AWAIT_SCRAMBLE_KEY: begin\n        // When invalidating a new scrambling key is requested on all invalidation requests. Wait\n        // for that new key to be available before beginning with the actual invalidation (cannot\n        // write to the tag RAM until we have the new scrambling key that will be used). Ignore any\n        // requests in this phase (once a scramble key request has started we cannot request a new\n        // one until the on-going request is done).\n        if (ic_scr_key_valid_i) begin\n          inval_state_d  = INVAL_CACHE;\n          inval_index_d  = '0;\n          inval_index_en = 1'b1;\n        end\n      end\n      INVAL_CACHE: begin\n        // Actually invalidate the cache. Write every entry in the tag RAM with an invalid tag. Once\n        // all are written we're done.\n        inval_write_req = 1'b1;\n        inval_index_d   = (inval_index_q + {{IC_INDEX_W-1{1'b0}},1'b1});\n        inval_index_en  = 1'b1;\n\n        if (icache_inval_i) begin\n          // If a new invalidaiton requests comes in go back to the beginning with a new scramble\n          // key\n          ic_scr_key_req_o = 1'b1;\n          inval_state_d = AWAIT_SCRAMBLE_KEY;\n        end else if (&inval_index_q) begin\n          // When the final index is written we're done\n            inval_state_d = IDLE;\n        end\n      end\n      IDLE: begin\n        // Usual running state\n        if (icache_inval_i) begin\n          ic_scr_key_req_o = 1'b1;\n          inval_state_d = AWAIT_SCRAMBLE_KEY;\n        end else begin\n          // Allow other cache activies whilst in IDLE and no invalidation has been requested\n          inval_block_cache = 1'b0;\n        end\n      end\n      default: ;\n    endcase\n  end\n\n  assign inval_active = inval_state_q != IDLE;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      inval_state_q <= OUT_OF_RESET;\n    end else begin\n      inval_state_q <= inval_state_d;\n    end\n  end\n\n  if (ResetAll) begin : g_inval_index_ra\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        inval_index_q <= '0;\n      end else if (inval_index_en) begin\n        inval_index_q <= inval_index_d;\n      end\n    end\n  end else begin : g_inval_index_nr\n    always_ff @(posedge clk_i) begin\n      if (inval_index_en) begin\n        inval_index_q <= inval_index_d;\n      end\n    end\n  end\n\n  /////////////////\n  // Busy status //\n  /////////////////\n\n  // Only busy (for WFI purposes) while an invalidation is in-progress, or external requests are\n  // outstanding.\n  assign busy_o = inval_active | (|(fill_busy_q & ~fill_rvd_done));\n\n  ////////////////\n  // Assertions //\n  ////////////////\n\n  `ASSERT_INIT(size_param_legal, (IC_LINE_SIZE > 32))\n\n  // ECC primitives will need to be changed for different sizes\n  `ASSERT_INIT(ecc_tag_param_legal, (IC_TAG_SIZE <= 27))\n  `ASSERT_INIT(ecc_data_param_legal, !ICacheECC || (BUS_SIZE == 32))\n\n  // Lookups in the tag ram should always give a known result\n  `ASSERT_KNOWN(TagHitKnown,     lookup_valid_ic1 & tag_hit_ic1)\n  `ASSERT_KNOWN(TagInvalidKnown, lookup_valid_ic1 & tag_invalid_ic1)\n\n  // This is only used for the Yosys-based formal flow. Once we have working bind support, we can\n  // get rid of it.\n`ifdef FORMAL\n `ifdef YOSYS\n  // Unfortunately, Yosys doesn't support passing unpacked arrays as ports. Explicitly pack up the\n  // signals we need.\n  logic [NUM_FB-1:0][ADDR_W-1:0] packed_fill_addr_q;\n  always_comb begin\n    for (int i = 0; i < NUM_FB; i++) begin\n      packed_fill_addr_q[i][ADDR_W-1:0] = fill_addr_q[i];\n    end\n  end\n\n  `include \"formal_tb_frag.svh\"\n `endif\n`endif\n\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n`ifdef RISCV_FORMAL\n  `define RVFI\n`endif\n\n/**\n * Instruction Decode Stage\n *\n * Decode stage of the core. It decodes the instructions and hosts the register\n * file.\n */\n\n`include \"prim_assert.sv\"\n`include \"dv_fcov_macros.svh\"\n\nmodule ibex_id_stage #(\n  parameter bit               RV32E           = 0,\n  parameter ibex_pkg::rv32m_e RV32M           = ibex_pkg::RV32MFast,\n  parameter ibex_pkg::rv32b_e RV32B           = ibex_pkg::RV32BNone,\n  parameter bit               DataIndTiming   = 1'b0,\n  parameter bit               BranchTargetALU = 0,\n  parameter bit               WritebackStage  = 0,\n  parameter bit               BranchPredictor = 0,\n  parameter bit               MemECC          = 1'b0\n) (\n  input  logic                      clk_i,\n  input  logic                      rst_ni,\n\n  output logic                      ctrl_busy_o,\n  output logic                      illegal_insn_o,\n\n  // Interface to IF stage\n  input  logic                      instr_valid_i,\n  input  logic [31:0]               instr_rdata_i,         // from IF-ID pipeline registers\n  input  logic [31:0]               instr_rdata_alu_i,     // from IF-ID pipeline registers\n  input  logic [15:0]               instr_rdata_c_i,       // from IF-ID pipeline registers\n  input  logic                      instr_is_compressed_i,\n  input  logic                      instr_bp_taken_i,\n  output logic                      instr_req_o,\n  output logic                      instr_first_cycle_id_o,\n  output logic                      instr_valid_clear_o,   // kill instr in IF-ID reg\n  output logic                      id_in_ready_o,         // ID stage is ready for next instr\n  input  logic                      instr_exec_i,\n  output logic                      icache_inval_o,\n\n  // Jumps and branches\n  input  logic                      branch_decision_i,\n\n  // IF and ID stage signals\n  output logic                      pc_set_o,\n  output ibex_pkg::pc_sel_e         pc_mux_o,\n  output logic                      nt_branch_mispredict_o,\n  output logic [31:0]               nt_branch_addr_o,\n  output ibex_pkg::exc_pc_sel_e     exc_pc_mux_o,\n  output ibex_pkg::exc_cause_t      exc_cause_o,\n\n  input  logic                      illegal_c_insn_i,\n  input  logic                      instr_fetch_err_i,\n  input  logic                      instr_fetch_err_plus2_i,\n\n  input  logic [31:0]               pc_id_i,\n\n  // Stalls\n  input  logic                      ex_valid_i,       // EX stage has valid output\n  input  logic                      lsu_resp_valid_i, // LSU has valid output, or is done\n  // ALU\n  output ibex_pkg::alu_op_e         alu_operator_ex_o,\n  output logic [31:0]               alu_operand_a_ex_o,\n  output logic [31:0]               alu_operand_b_ex_o,\n\n  // Multicycle Operation Stage Register\n  input  logic [1:0]                imd_val_we_ex_i,\n  input  logic [33:0]               imd_val_d_ex_i[2],\n  output logic [33:0]               imd_val_q_ex_o[2],\n\n  // Branch target ALU\n  output logic [31:0]               bt_a_operand_o,\n  output logic [31:0]               bt_b_operand_o,\n\n  // MUL, DIV\n  output logic                      mult_en_ex_o,\n  output logic                      div_en_ex_o,\n  output logic                      mult_sel_ex_o,\n  output logic                      div_sel_ex_o,\n  output ibex_pkg::md_op_e          multdiv_operator_ex_o,\n  output logic  [1:0]               multdiv_signed_mode_ex_o,\n  output logic [31:0]               multdiv_operand_a_ex_o,\n  output logic [31:0]               multdiv_operand_b_ex_o,\n  output logic                      multdiv_ready_id_o,\n\n  // CSR\n  output logic                      csr_access_o,\n  output ibex_pkg::csr_op_e         csr_op_o,\n  output logic                      csr_op_en_o,\n  output logic                      csr_save_if_o,\n  output logic                      csr_save_id_o,\n  output logic                      csr_save_wb_o,\n  output logic                      csr_restore_mret_id_o,\n  output logic                      csr_restore_dret_id_o,\n  output logic                      csr_save_cause_o,\n  output logic [31:0]               csr_mtval_o,\n  input  ibex_pkg::priv_lvl_e       priv_mode_i,\n  input  logic                      csr_mstatus_tw_i,\n  input  logic                      illegal_csr_insn_i,\n  input  logic                      data_ind_timing_i,\n\n  // Interface to load store unit\n  output logic                      lsu_req_o,\n  output logic                      lsu_we_o,\n  output logic [1:0]                lsu_type_o,\n  output logic                      lsu_sign_ext_o,\n  output logic [31:0]               lsu_wdata_o,\n\n  input  logic                      lsu_req_done_i, // Data req to LSU is complete and\n                                                    // instruction can move to writeback\n                                                    // (only relevant where writeback stage is\n                                                    // present)\n\n  input  logic                      lsu_addr_incr_req_i,\n  input  logic [31:0]               lsu_addr_last_i,\n\n  // Interrupt signals\n  input  logic                      csr_mstatus_mie_i,\n  input  logic                      irq_pending_i,\n  input  ibex_pkg::irqs_t           irqs_i,\n  input  logic                      irq_nm_i,\n  output logic                      nmi_mode_o,\n\n  input  logic                      lsu_load_err_i,\n  input  logic                      lsu_load_resp_intg_err_i,\n  input  logic                      lsu_store_err_i,\n  input  logic                      lsu_store_resp_intg_err_i,\n\n  // Debug Signal\n  output logic                      debug_mode_o,\n  output logic                      debug_mode_entering_o,\n  output ibex_pkg::dbg_cause_e      debug_cause_o,\n  output logic                      debug_csr_save_o,\n  input  logic                      debug_req_i,\n  input  logic                      debug_single_step_i,\n  input  logic                      debug_ebreakm_i,\n  input  logic                      debug_ebreaku_i,\n  input  logic                      trigger_match_i,\n\n  // Write back signal\n  input  logic [31:0]               result_ex_i,\n  input  logic [31:0]               csr_rdata_i,\n\n  // Register file read\n  output logic [4:0]                rf_raddr_a_o,\n  input  logic [31:0]               rf_rdata_a_i,\n  output logic [4:0]                rf_raddr_b_o,\n  input  logic [31:0]               rf_rdata_b_i,\n  output logic                      rf_ren_a_o,\n  output logic                      rf_ren_b_o,\n\n  // Register file write (via writeback)\n  output logic [4:0]                rf_waddr_id_o,\n  output logic [31:0]               rf_wdata_id_o,\n  output logic                      rf_we_id_o,\n  output logic                      rf_rd_a_wb_match_o,\n  output logic                      rf_rd_b_wb_match_o,\n\n  // Register write information from writeback (for resolving data hazards)\n  input  logic [4:0]                rf_waddr_wb_i,\n  input  logic [31:0]               rf_wdata_fwd_wb_i,\n  input  logic                      rf_write_wb_i,\n\n  output  logic                     en_wb_o,\n  output  ibex_pkg::wb_instr_type_e instr_type_wb_o,\n  output  logic                     instr_perf_count_id_o,\n  input logic                       ready_wb_i,\n  input logic                       outstanding_load_wb_i,\n  input logic                       outstanding_store_wb_i,\n\n  // Performance Counters\n  output logic                      perf_jump_o,    // executing a jump instr\n  output logic                      perf_branch_o,  // executing a branch instr\n  output logic                      perf_tbranch_o, // executing a taken branch instr\n  output logic                      perf_dside_wait_o, // instruction in ID/EX is awaiting memory\n                                                        // access to finish before proceeding\n  output logic                      perf_mul_wait_o,\n  output logic                      perf_div_wait_o,\n  output logic                      instr_id_done_o\n);\n\n  import ibex_pkg::*;\n\n  // Decoder/Controller, ID stage internal signals\n  logic        illegal_insn_dec;\n  logic        illegal_dret_insn;\n  logic        illegal_umode_insn;\n  logic        ebrk_insn;\n  logic        mret_insn_dec;\n  logic        dret_insn_dec;\n  logic        ecall_insn_dec;\n  logic        wfi_insn_dec;\n\n  logic        wb_exception;\n  logic        id_exception;\n\n  logic        branch_in_dec;\n  logic        branch_set, branch_set_raw, branch_set_raw_d;\n  logic        branch_jump_set_done_q, branch_jump_set_done_d;\n  logic        branch_not_set;\n  logic        branch_taken;\n  logic        jump_in_dec;\n  logic        jump_set_dec;\n  logic        jump_set, jump_set_raw;\n\n  logic        instr_first_cycle;\n  logic        instr_executing_spec;\n  logic        instr_executing;\n  logic        instr_done;\n  logic        controller_run;\n  logic        stall_ld_hz;\n  logic        stall_mem;\n  logic        stall_multdiv;\n  logic        stall_branch;\n  logic        stall_jump;\n  logic        stall_id;\n  logic        stall_wb;\n  logic        flush_id;\n  logic        multicycle_done;\n\n  logic        mem_resp_intg_err;\n\n  // Immediate decoding and sign extension\n  logic [31:0] imm_i_type;\n  logic [31:0] imm_s_type;\n  logic [31:0] imm_b_type;\n  logic [31:0] imm_u_type;\n  logic [31:0] imm_j_type;\n  logic [31:0] zimm_rs1_type;\n\n  logic [31:0] imm_a;       // contains the immediate for operand b\n  logic [31:0] imm_b;       // contains the immediate for operand b\n\n  // Register file interface\n\n  rf_wd_sel_e  rf_wdata_sel;\n  logic        rf_we_dec, rf_we_raw;\n  logic        rf_ren_a, rf_ren_b;\n  logic        rf_ren_a_dec, rf_ren_b_dec;\n\n  // Read enables should only be asserted for valid and legal instructions\n  assign rf_ren_a = instr_valid_i & ~instr_fetch_err_i & ~illegal_insn_o & rf_ren_a_dec;\n  assign rf_ren_b = instr_valid_i & ~instr_fetch_err_i & ~illegal_insn_o & rf_ren_b_dec;\n\n  assign rf_ren_a_o = rf_ren_a;\n  assign rf_ren_b_o = rf_ren_b;\n\n  logic [31:0] rf_rdata_a_fwd;\n  logic [31:0] rf_rdata_b_fwd;\n\n  // ALU Control\n  alu_op_e     alu_operator;\n  op_a_sel_e   alu_op_a_mux_sel, alu_op_a_mux_sel_dec;\n  op_b_sel_e   alu_op_b_mux_sel, alu_op_b_mux_sel_dec;\n  logic        alu_multicycle_dec;\n  logic        stall_alu;\n\n  logic [33:0] imd_val_q[2];\n\n  op_a_sel_e   bt_a_mux_sel;\n  imm_b_sel_e  bt_b_mux_sel;\n\n  imm_a_sel_e  imm_a_mux_sel;\n  imm_b_sel_e  imm_b_mux_sel, imm_b_mux_sel_dec;\n\n  // Multiplier Control\n  logic        mult_en_id, mult_en_dec; // use integer multiplier\n  logic        div_en_id, div_en_dec;   // use integer division or reminder\n  logic        multdiv_en_dec;\n  md_op_e      multdiv_operator;\n  logic [1:0]  multdiv_signed_mode;\n\n  // Data Memory Control\n  logic        lsu_we;\n  logic [1:0]  lsu_type;\n  logic        lsu_sign_ext;\n  logic        lsu_req, lsu_req_dec;\n  logic        data_req_allowed;\n\n  // CSR control\n  logic        csr_pipe_flush;\n\n  logic [31:0] alu_operand_a;\n  logic [31:0] alu_operand_b;\n\n  /////////////\n  // LSU Mux //\n  /////////////\n\n  // Misaligned loads/stores result in two aligned loads/stores, compute second address\n  assign alu_op_a_mux_sel = lsu_addr_incr_req_i ? OP_A_FWD        : alu_op_a_mux_sel_dec;\n  assign alu_op_b_mux_sel = lsu_addr_incr_req_i ? OP_B_IMM        : alu_op_b_mux_sel_dec;\n  assign imm_b_mux_sel    = lsu_addr_incr_req_i ? IMM_B_INCR_ADDR : imm_b_mux_sel_dec;\n\n  ///////////////////\n  // Operand MUXES //\n  ///////////////////\n\n  // Main ALU immediate MUX for Operand A\n  assign imm_a = (imm_a_mux_sel == IMM_A_Z) ? zimm_rs1_type : '0;\n\n  // Main ALU MUX for Operand A\n  always_comb begin : alu_operand_a_mux\n    unique case (alu_op_a_mux_sel)\n      OP_A_REG_A:  alu_operand_a = rf_rdata_a_fwd;\n      OP_A_FWD:    alu_operand_a = lsu_addr_last_i;\n      OP_A_CURRPC: alu_operand_a = pc_id_i;\n      OP_A_IMM:    alu_operand_a = imm_a;\n      default:     alu_operand_a = pc_id_i;\n    endcase\n  end\n\n  if (BranchTargetALU) begin : g_btalu_muxes\n    // Branch target ALU operand A mux\n    always_comb begin : bt_operand_a_mux\n      unique case (bt_a_mux_sel)\n        OP_A_REG_A:  bt_a_operand_o = rf_rdata_a_fwd;\n        OP_A_CURRPC: bt_a_operand_o = pc_id_i;\n        default:     bt_a_operand_o = pc_id_i;\n      endcase\n    end\n\n    // Branch target ALU operand B mux\n    always_comb begin : bt_immediate_b_mux\n      unique case (bt_b_mux_sel)\n        IMM_B_I:         bt_b_operand_o = imm_i_type;\n        IMM_B_B:         bt_b_operand_o = imm_b_type;\n        IMM_B_J:         bt_b_operand_o = imm_j_type;\n        IMM_B_INCR_PC:   bt_b_operand_o = instr_is_compressed_i ? 32'h2 : 32'h4;\n        default:         bt_b_operand_o = instr_is_compressed_i ? 32'h2 : 32'h4;\n      endcase\n    end\n\n    // Reduced main ALU immediate MUX for Operand B\n    always_comb begin : immediate_b_mux\n      unique case (imm_b_mux_sel)\n        IMM_B_I:         imm_b = imm_i_type;\n        IMM_B_S:         imm_b = imm_s_type;\n        IMM_B_U:         imm_b = imm_u_type;\n        IMM_B_INCR_PC:   imm_b = instr_is_compressed_i ? 32'h2 : 32'h4;\n        IMM_B_INCR_ADDR: imm_b = 32'h4;\n        default:         imm_b = 32'h4;\n      endcase\n    end\n    `ASSERT(IbexImmBMuxSelValid, instr_valid_i |-> imm_b_mux_sel inside {\n        IMM_B_I,\n        IMM_B_S,\n        IMM_B_U,\n        IMM_B_INCR_PC,\n        IMM_B_INCR_ADDR})\n  end else begin : g_nobtalu\n    op_a_sel_e  unused_a_mux_sel;\n    imm_b_sel_e unused_b_mux_sel;\n\n    assign unused_a_mux_sel = bt_a_mux_sel;\n    assign unused_b_mux_sel = bt_b_mux_sel;\n    assign bt_a_operand_o   = '0;\n    assign bt_b_operand_o   = '0;\n\n    // Full main ALU immediate MUX for Operand B\n    always_comb begin : immediate_b_mux\n      unique case (imm_b_mux_sel)\n        IMM_B_I:         imm_b = imm_i_type;\n        IMM_B_S:         imm_b = imm_s_type;\n        IMM_B_B:         imm_b = imm_b_type;\n        IMM_B_U:         imm_b = imm_u_type;\n        IMM_B_J:         imm_b = imm_j_type;\n        IMM_B_INCR_PC:   imm_b = instr_is_compressed_i ? 32'h2 : 32'h4;\n        IMM_B_INCR_ADDR: imm_b = 32'h4;\n        default:         imm_b = 32'h4;\n      endcase\n    end\n    `ASSERT(IbexImmBMuxSelValid, instr_valid_i |-> imm_b_mux_sel inside {\n        IMM_B_I,\n        IMM_B_S,\n        IMM_B_B,\n        IMM_B_U,\n        IMM_B_J,\n        IMM_B_INCR_PC,\n        IMM_B_INCR_ADDR})\n  end\n\n  // ALU MUX for Operand B\n  assign alu_operand_b = (alu_op_b_mux_sel == OP_B_IMM) ? imm_b : rf_rdata_b_fwd;\n\n  /////////////////////////////////////////\n  // Multicycle Operation Stage Register //\n  /////////////////////////////////////////\n\n  for (genvar i = 0; i < 2; i++) begin : gen_intermediate_val_reg\n    always_ff @(posedge clk_i or negedge rst_ni) begin : intermediate_val_reg\n      if (!rst_ni) begin\n        imd_val_q[i] <= '0;\n      end else if (imd_val_we_ex_i[i]) begin\n        imd_val_q[i] <= imd_val_d_ex_i[i];\n      end\n    end\n  end\n\n  assign imd_val_q_ex_o = imd_val_q;\n\n  ///////////////////////\n  // Register File MUX //\n  ///////////////////////\n\n  // Suppress register write if there is an illegal CSR access or instruction is not executing\n  assign rf_we_id_o = rf_we_raw & instr_executing & ~illegal_csr_insn_i;\n\n  // Register file write data mux\n  always_comb begin : rf_wdata_id_mux\n    unique case (rf_wdata_sel)\n      RF_WD_EX:  rf_wdata_id_o = result_ex_i;\n      RF_WD_CSR: rf_wdata_id_o = csr_rdata_i;\n      default:   rf_wdata_id_o = result_ex_i;\n    endcase\n  end\n\n  /////////////\n  // Decoder //\n  /////////////\n\n  ibex_decoder #(\n    .RV32E          (RV32E),\n    .RV32M          (RV32M),\n    .RV32B          (RV32B),\n    .BranchTargetALU(BranchTargetALU)\n  ) decoder_i (\n    .clk_i (clk_i),\n    .rst_ni(rst_ni),\n\n    // controller\n    .illegal_insn_o(illegal_insn_dec),\n    .ebrk_insn_o   (ebrk_insn),\n    .mret_insn_o   (mret_insn_dec),\n    .dret_insn_o   (dret_insn_dec),\n    .ecall_insn_o  (ecall_insn_dec),\n    .wfi_insn_o    (wfi_insn_dec),\n    .jump_set_o    (jump_set_dec),\n    .branch_taken_i(branch_taken),\n    .icache_inval_o(icache_inval_o),\n\n    // from IF-ID pipeline register\n    .instr_first_cycle_i(instr_first_cycle),\n    .instr_rdata_i      (instr_rdata_i),\n    .instr_rdata_alu_i  (instr_rdata_alu_i),\n    .illegal_c_insn_i   (illegal_c_insn_i),\n\n    // immediates\n    .imm_a_mux_sel_o(imm_a_mux_sel),\n    .imm_b_mux_sel_o(imm_b_mux_sel_dec),\n    .bt_a_mux_sel_o (bt_a_mux_sel),\n    .bt_b_mux_sel_o (bt_b_mux_sel),\n\n    .imm_i_type_o   (imm_i_type),\n    .imm_s_type_o   (imm_s_type),\n    .imm_b_type_o   (imm_b_type),\n    .imm_u_type_o   (imm_u_type),\n    .imm_j_type_o   (imm_j_type),\n    .zimm_rs1_type_o(zimm_rs1_type),\n\n    // register file\n    .rf_wdata_sel_o(rf_wdata_sel),\n    .rf_we_o       (rf_we_dec),\n\n    .rf_raddr_a_o(rf_raddr_a_o),\n    .rf_raddr_b_o(rf_raddr_b_o),\n    .rf_waddr_o  (rf_waddr_id_o),\n    .rf_ren_a_o  (rf_ren_a_dec),\n    .rf_ren_b_o  (rf_ren_b_dec),\n\n    // ALU\n    .alu_operator_o    (alu_operator),\n    .alu_op_a_mux_sel_o(alu_op_a_mux_sel_dec),\n    .alu_op_b_mux_sel_o(alu_op_b_mux_sel_dec),\n    .alu_multicycle_o  (alu_multicycle_dec),\n\n    // MULT & DIV\n    .mult_en_o            (mult_en_dec),\n    .div_en_o             (div_en_dec),\n    .mult_sel_o           (mult_sel_ex_o),\n    .div_sel_o            (div_sel_ex_o),\n    .multdiv_operator_o   (multdiv_operator),\n    .multdiv_signed_mode_o(multdiv_signed_mode),\n\n    // CSRs\n    .csr_access_o(csr_access_o),\n    .csr_op_o    (csr_op_o),\n\n    // LSU\n    .data_req_o           (lsu_req_dec),\n    .data_we_o            (lsu_we),\n    .data_type_o          (lsu_type),\n    .data_sign_extension_o(lsu_sign_ext),\n\n    // jump/branches\n    .jump_in_dec_o  (jump_in_dec),\n    .branch_in_dec_o(branch_in_dec)\n  );\n\n  /////////////////////////////////\n  // CSR-related pipeline flushes //\n  /////////////////////////////////\n  always_comb begin : csr_pipeline_flushes\n    csr_pipe_flush = 1'b0;\n\n    // A pipeline flush is needed to let the controller react after modifying certain CSRs:\n    // - When enabling interrupts, pending IRQs become visible to the controller only during\n    //   the next cycle. If during that cycle the core disables interrupts again, it does not\n    //   see any pending IRQs and consequently does not start to handle interrupts.\n    // - When modifying any PMP CSR, PMP check of the next instruction might get invalidated.\n    //   Hence, a pipeline flush is needed to instantiate another PMP check with the updated CSRs.\n    // - When modifying debug CSRs.\n    if (csr_op_en_o == 1'b1 && (csr_op_o == CSR_OP_WRITE || csr_op_o == CSR_OP_SET)) begin\n      if (csr_num_e'(instr_rdata_i[31:20]) == CSR_MSTATUS ||\n          csr_num_e'(instr_rdata_i[31:20]) == CSR_MIE     ||\n          csr_num_e'(instr_rdata_i[31:20]) == CSR_MSECCFG ||\n          // To catch all PMPCFG/PMPADDR registers, get the shared top most 7 bits.\n          instr_rdata_i[31:25] == 7'h1D) begin\n        csr_pipe_flush = 1'b1;\n      end\n    end else if (csr_op_en_o == 1'b1 && csr_op_o != CSR_OP_READ) begin\n      if (csr_num_e'(instr_rdata_i[31:20]) == CSR_DCSR      ||\n          csr_num_e'(instr_rdata_i[31:20]) == CSR_DPC       ||\n          csr_num_e'(instr_rdata_i[31:20]) == CSR_DSCRATCH0 ||\n          csr_num_e'(instr_rdata_i[31:20]) == CSR_DSCRATCH1) begin\n        csr_pipe_flush = 1'b1;\n      end\n    end\n  end\n\n  ////////////////\n  // Controller //\n  ////////////////\n\n  // Executing DRET outside of Debug Mode causes an illegal instruction exception.\n  assign illegal_dret_insn  = dret_insn_dec & ~debug_mode_o;\n  // Some instructions can only be executed in M-Mode\n  assign illegal_umode_insn = (priv_mode_i != PRIV_LVL_M) &\n                              // MRET must be in M-Mode. TW means trap WFI to M-Mode.\n                              (mret_insn_dec | (csr_mstatus_tw_i & wfi_insn_dec));\n\n  assign illegal_insn_o = instr_valid_i "}
{"text": "&\n      (illegal_insn_dec | illegal_csr_insn_i | illegal_dret_insn | illegal_umode_insn);\n\n  assign mem_resp_intg_err = lsu_load_resp_intg_err_i | lsu_store_resp_intg_err_i;\n\n  ibex_controller #(\n    .WritebackStage (WritebackStage),\n    .BranchPredictor(BranchPredictor),\n    .MemECC(MemECC)\n  ) controller_i (\n    .clk_i (clk_i),\n    .rst_ni(rst_ni),\n\n    .ctrl_busy_o(ctrl_busy_o),\n\n    // decoder related signals\n    .illegal_insn_i  (illegal_insn_o),\n    .ecall_insn_i    (ecall_insn_dec),\n    .mret_insn_i     (mret_insn_dec),\n    .dret_insn_i     (dret_insn_dec),\n    .wfi_insn_i      (wfi_insn_dec),\n    .ebrk_insn_i     (ebrk_insn),\n    .csr_pipe_flush_i(csr_pipe_flush),\n\n    // from IF-ID pipeline\n    .instr_valid_i          (instr_valid_i),\n    .instr_i                (instr_rdata_i),\n    .instr_compressed_i     (instr_rdata_c_i),\n    .instr_is_compressed_i  (instr_is_compressed_i),\n    .instr_bp_taken_i       (instr_bp_taken_i),\n    .instr_fetch_err_i      (instr_fetch_err_i),\n    .instr_fetch_err_plus2_i(instr_fetch_err_plus2_i),\n    .pc_id_i                (pc_id_i),\n\n    // to IF-ID pipeline\n    .instr_valid_clear_o(instr_valid_clear_o),\n    .id_in_ready_o      (id_in_ready_o),\n    .controller_run_o   (controller_run),\n    .instr_exec_i       (instr_exec_i),\n\n    // to prefetcher\n    .instr_req_o           (instr_req_o),\n    .pc_set_o              (pc_set_o),\n    .pc_mux_o              (pc_mux_o),\n    .nt_branch_mispredict_o(nt_branch_mispredict_o),\n    .exc_pc_mux_o          (exc_pc_mux_o),\n    .exc_cause_o           (exc_cause_o),\n\n    // LSU\n    .lsu_addr_last_i    (lsu_addr_last_i),\n    .load_err_i         (lsu_load_err_i),\n    .mem_resp_intg_err_i(mem_resp_intg_err),\n    .store_err_i        (lsu_store_err_i),\n    .wb_exception_o     (wb_exception),\n    .id_exception_o     (id_exception),\n\n    // jump/branch control\n    .branch_set_i     (branch_set),\n    .branch_not_set_i (branch_not_set),\n    .jump_set_i       (jump_set),\n\n    // interrupt signals\n    .csr_mstatus_mie_i(csr_mstatus_mie_i),\n    .irq_pending_i    (irq_pending_i),\n    .irqs_i           (irqs_i),\n    .irq_nm_ext_i     (irq_nm_i),\n    .nmi_mode_o       (nmi_mode_o),\n\n    // CSR Controller Signals\n    .csr_save_if_o        (csr_save_if_o),\n    .csr_save_id_o        (csr_save_id_o),\n    .csr_save_wb_o        (csr_save_wb_o),\n    .csr_restore_mret_id_o(csr_restore_mret_id_o),\n    .csr_restore_dret_id_o(csr_restore_dret_id_o),\n    .csr_save_cause_o     (csr_save_cause_o),\n    .csr_mtval_o          (csr_mtval_o),\n    .priv_mode_i          (priv_mode_i),\n\n    // Debug Signal\n    .debug_mode_o         (debug_mode_o),\n    .debug_mode_entering_o(debug_mode_entering_o),\n    .debug_cause_o        (debug_cause_o),\n    .debug_csr_save_o     (debug_csr_save_o),\n    .debug_req_i          (debug_req_i),\n    .debug_single_step_i  (debug_single_step_i),\n    .debug_ebreakm_i      (debug_ebreakm_i),\n    .debug_ebreaku_i      (debug_ebreaku_i),\n    .trigger_match_i      (trigger_match_i),\n\n    .stall_id_i(stall_id),\n    .stall_wb_i(stall_wb),\n    .flush_id_o(flush_id),\n    .ready_wb_i(ready_wb_i),\n\n    // Performance Counters\n    .perf_jump_o   (perf_jump_o),\n    .perf_tbranch_o(perf_tbranch_o)\n  );\n\n  assign multdiv_en_dec   = mult_en_dec | div_en_dec;\n\n  assign lsu_req         = instr_executing ? data_req_allowed & lsu_req_dec  : 1'b0;\n  assign mult_en_id      = instr_executing ? mult_en_dec                     : 1'b0;\n  assign div_en_id       = instr_executing ? div_en_dec                      : 1'b0;\n\n  assign lsu_req_o               = lsu_req;\n  assign lsu_we_o                = lsu_we;\n  assign lsu_type_o              = lsu_type;\n  assign lsu_sign_ext_o          = lsu_sign_ext;\n  assign lsu_wdata_o             = rf_rdata_b_fwd;\n  // csr_op_en_o is set when CSR access should actually happen.\n  // csv_access_o is set when CSR access instruction is present and is used to compute whether a CSR\n  // access is illegal. A combinational loop would be created if csr_op_en_o was used along (as\n  // asserting it for an illegal csr access would result in a flush that would need to deassert it).\n  assign csr_op_en_o             = csr_access_o & instr_executing & instr_id_done_o;\n\n  assign alu_operator_ex_o           = alu_operator;\n  assign alu_operand_a_ex_o          = alu_operand_a;\n  assign alu_operand_b_ex_o          = alu_operand_b;\n\n  assign mult_en_ex_o                = mult_en_id;\n  assign div_en_ex_o                 = div_en_id;\n\n  assign multdiv_operator_ex_o       = multdiv_operator;\n  assign multdiv_signed_mode_ex_o    = multdiv_signed_mode;\n  assign multdiv_operand_a_ex_o      = rf_rdata_a_fwd;\n  assign multdiv_operand_b_ex_o      = rf_rdata_b_fwd;\n\n  ////////////////////////\n  // Branch set control //\n  ////////////////////////\n\n  if (BranchTargetALU && !DataIndTiming) begin : g_branch_set_direct\n    // Branch set fed straight to controller with branch target ALU\n    // (condition pass/fail used same cycle as generated instruction request)\n    assign branch_set_raw      = branch_set_raw_d;\n  end else begin : g_branch_set_flop\n    // SEC_CM: CORE.DATA_REG_SW.SCA\n    // Branch set flopped without branch target ALU, or in fixed time execution mode\n    // (condition pass/fail used next cycle where branch target is calculated)\n    logic branch_set_raw_q;\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        branch_set_raw_q <= 1'b0;\n      end else begin\n        branch_set_raw_q <= branch_set_raw_d;\n      end\n    end\n\n    // Branches always take two cycles in fixed time execution mode, with or without the branch\n    // target ALU (to avoid a path from the branch decision into the branch target ALU operand\n    // muxing).\n    assign branch_set_raw      = (BranchTargetALU && !data_ind_timing_i) ? branch_set_raw_d :\n                                                                           branch_set_raw_q;\n\n  end\n\n  // Track whether the current instruction in ID/EX has done a branch or jump set.\n  assign branch_jump_set_done_d = (branch_set_raw | jump_set_raw | branch_jump_set_done_q) &\n    ~instr_valid_clear_o;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      branch_jump_set_done_q <= 1'b0;\n    end else begin\n      branch_jump_set_done_q <= branch_jump_set_done_d;\n    end\n  end\n\n  // the _raw signals from the state machine may be asserted for multiple cycles when\n  // instr_executing_spec is asserted and instr_executing is not asserted. This may occur where\n  // a memory error is seen or a there are outstanding memory accesses (indicate a load or store is\n  // in the WB stage). The branch or jump speculatively begins the fetch but is held back from\n  // completing until it is certain the outstanding access hasn't seen a memory error. This logic\n  // ensures only the first cycle of a branch or jump set is sent to the controller to prevent\n  // needless extra IF flushes and fetches.\n  assign jump_set        = jump_set_raw        & ~branch_jump_set_done_q;\n  assign branch_set      = branch_set_raw      & ~branch_jump_set_done_q;\n\n  // Branch condition is calculated in the first cycle and flopped for use in the second cycle\n  // (only used in fixed time execution mode to determine branch destination).\n  if (DataIndTiming) begin : g_sec_branch_taken\n    // SEC_CM: CORE.DATA_REG_SW.SCA\n    logic branch_taken_q;\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        branch_taken_q <= 1'b0;\n      end else begin\n        branch_taken_q <= branch_decision_i;\n      end\n    end\n\n    assign branch_taken = ~data_ind_timing_i | branch_taken_q;\n\n  end else begin : g_nosec_branch_taken\n\n    // Signal unused without fixed time execution mode - only taken branches will trigger\n    // branch_set_raw\n    assign branch_taken = 1'b1;\n\n  end\n\n  // Holding branch_set/jump_set high for more than one cycle should not cause a functional issue.\n  // However it could generate needless prefetch buffer flushes and instruction fetches. The ID/EX\n  // designs ensures that this never happens for non-predicted branches.\n  `ASSERT(NeverDoubleBranch, branch_set & ~instr_bp_taken_i |=> ~branch_set)\n  `ASSERT(NeverDoubleJump, jump_set & ~instr_bp_taken_i |=> ~jump_set)\n\n  //////////////////////////////\n  // Branch not-taken address //\n  //////////////////////////////\n\n  if (BranchPredictor) begin : g_calc_nt_addr\n    assign nt_branch_addr_o = pc_id_i + (instr_is_compressed_i ? 32'd2 : 32'd4);\n  end else begin : g_n_calc_nt_addr\n    assign nt_branch_addr_o = 32'd0;\n  end\n\n  ///////////////\n  // ID-EX FSM //\n  ///////////////\n\n  typedef enum logic { FIRST_CYCLE, MULTI_CYCLE } id_fsm_e;\n  id_fsm_e id_fsm_q, id_fsm_d;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : id_pipeline_reg\n    if (!rst_ni) begin\n      id_fsm_q <= FIRST_CYCLE;\n    end else if (instr_executing) begin\n      id_fsm_q <= id_fsm_d;\n    end\n  end\n\n  // ID/EX stage can be in two states, FIRST_CYCLE and MULTI_CYCLE. An instruction enters\n  // MULTI_CYCLE if it requires multiple cycles to complete regardless of stalls and other\n  // considerations. An instruction may be held in FIRST_CYCLE if it's unable to begin executing\n  // (this is controlled by instr_executing).\n\n  always_comb begin\n    id_fsm_d                = id_fsm_q;\n    rf_we_raw               = rf_we_dec;\n    stall_multdiv           = 1'b0;\n    stall_jump              = 1'b0;\n    stall_branch            = 1'b0;\n    stall_alu               = 1'b0;\n    branch_set_raw_d        = 1'b0;\n    branch_not_set          = 1'b0;\n    jump_set_raw            = 1'b0;\n    perf_branch_o           = 1'b0;\n\n    if (instr_executing_spec) begin\n      unique case (id_fsm_q)\n        FIRST_CYCLE: begin\n          unique case (1'b1)\n            lsu_req_dec: begin\n              if (!WritebackStage) begin\n                // LSU operation\n                id_fsm_d    = MULTI_CYCLE;\n              end else begin\n                if(~lsu_req_done_i) begin\n                  id_fsm_d  = MULTI_CYCLE;\n                end\n              end\n            end\n            multdiv_en_dec: begin\n              // MUL or DIV operation\n              if (~ex_valid_i) begin\n                // When single-cycle multiply is configured mul can finish in the first cycle so\n                // only enter MULTI_CYCLE state if a result isn't immediately available\n                id_fsm_d      = MULTI_CYCLE;\n                rf_we_raw     = 1'b0;\n                stall_multdiv = 1'b1;\n              end\n            end\n            branch_in_dec: begin\n              // cond branch operation\n              // All branches take two cycles in fixed time execution mode, regardless of branch\n              // condition.\n              // SEC_CM: CORE.DATA_REG_SW.SCA\n              id_fsm_d         = (data_ind_timing_i || (!BranchTargetALU && branch_decision_i)) ?\n                                     MULTI_CYCLE : FIRST_CYCLE;\n              stall_branch     = (~BranchTargetALU & branch_decision_i) | data_ind_timing_i;\n              branch_set_raw_d = (branch_decision_i | data_ind_timing_i);\n\n              if (BranchPredictor) begin\n                branch_not_set = ~branch_decision_i;\n              end\n\n              perf_branch_o = 1'b1;\n            end\n            jump_in_dec: begin\n              // uncond branch operation\n              // BTALU means jumps only need one cycle\n              id_fsm_d      = BranchTargetALU ? FIRST_CYCLE : MULTI_CYCLE;\n              stall_jump    = ~BranchTargetALU;\n              jump_set_raw  = jump_set_dec;\n            end\n            alu_multicycle_dec: begin\n              stall_alu     = 1'b1;\n              id_fsm_d      = MULTI_CYCLE;\n              rf_we_raw     = 1'b0;\n            end\n            default: begin\n              id_fsm_d      = FIRST_CYCLE;\n            end\n          endcase\n        end\n\n        MULTI_CYCLE: begin\n          if(multdiv_en_dec) begin\n            rf_we_raw       = rf_we_dec & ex_valid_i;\n          end\n\n          if (multicycle_done & ready_wb_i) begin\n            id_fsm_d        = FIRST_CYCLE;\n          end else begin\n            stall_multdiv   = multdiv_en_dec;\n            stall_branch    = branch_in_dec;\n            stall_jump      = jump_in_dec;\n          end\n        end\n\n        default: begin\n          id_fsm_d          = FIRST_CYCLE;\n        end\n      endcase\n    end\n  end\n\n  // Note for the two-stage configuration ready_wb_i is always set\n  assign multdiv_ready_id_o = ready_wb_i;\n\n  `ASSERT(StallIDIfMulticycle, (id_fsm_q == FIRST_CYCLE) & (id_fsm_d == MULTI_CYCLE) |-> stall_id)\n\n\n  // Stall ID/EX stage for reason that relates to instruction in ID/EX, update assertion below if\n  // modifying this.\n  assign stall_id = stall_ld_hz | stall_mem | stall_multdiv | stall_jump | stall_branch |\n                      stall_alu;\n\n  // Generally illegal instructions have no reason to stall, however they must still stall waiting\n  // for outstanding memory requests so exceptions related to them take priority over the illegal\n  // instruction exception.\n  `ASSERT(IllegalInsnStallMustBeMemStall, illegal_insn_o & stall_id |-> stall_mem &\n    ~(stall_ld_hz | stall_multdiv | stall_jump | stall_branch | stall_alu))\n\n  assign instr_done = ~stall_id & ~flush_id & instr_executing;\n\n  // Signal instruction in ID is in it's first cycle. It can remain in its\n  // first cycle if it is stalled.\n  assign instr_first_cycle      = instr_valid_i & (id_fsm_q == FIRST_CYCLE);\n  // Used by RVFI to know when to capture register read data\n  // Used by ALU to access RS3 if ternary instruction.\n  assign instr_first_cycle_id_o = instr_first_cycle;\n\n  if (WritebackStage) begin : gen_stall_mem\n    // Register read address matches write address in WB\n    logic rf_rd_a_wb_match;\n    logic rf_rd_b_wb_match;\n    // Hazard between registers being read and written\n    logic rf_rd_a_hz;\n    logic rf_rd_b_hz;\n\n    logic outstanding_memory_access;\n\n    logic instr_kill;\n\n    assign multicycle_done = lsu_req_dec ? ~stall_mem : ex_valid_i;\n\n    // Is a memory access ongoing that isn't finishing this cycle\n    assign outstanding_memory_access = (outstanding_load_wb_i | outstanding_store_wb_i) &\n                                       ~lsu_resp_valid_i;\n\n    // Can start a new memory access if any previous one has finished or is finishing\n    assign data_req_allowed = ~outstanding_memory_access;\n\n    // Instruction won't execute because:\n    // - There is a pending exception in writeback\n    //   The instruction in ID/EX will be flushed and the core will jump to an exception handler\n    // - The controller isn't running instructions\n    //   This either happens in preparation for a flush and jump to an exception handler e.g. in\n    //   response to an IRQ or debug request or whilst the core is sleeping or resetting/fetching\n    //   first instruction in which case any valid instruction in ID/EX should be ignored.\n    // - There was an error on instruction fetch\n    assign instr_kill = instr_fetch_err_i |\n                        wb_exception      |\n                        id_exception      |\n                        ~controller_run;\n\n    // With writeback stage instructions must be prevented from executing if there is:\n    // - A load hazard\n    // - A pending memory access\n    //   If it receives an error response this results in a precise exception from WB so ID/EX\n    //   instruction must not execute until error response is known).\n    // - A load/store error\n    //   This will cause a precise exception for the instruction in WB so ID/EX instruction must not\n    //   execute\n    //\n    // instr_executing_spec is a speculative signal. It indicates an instruction can execute\n    // assuming there are no exceptions from writeback and any outstanding memory access won't\n    // receive an error. It is required so branch and jump requests don't factor in an incoming dmem\n    // error (that in turn would factor directly into imem requests leading to a feedthrough path).\n    //\n    // instr_executing is the full signal, it will only allow execution once any potential\n    // exceptions from writeback have been resolved.\n    assign instr_executing_spec = instr_valid_i      &\n                                  ~instr_fetch_err_i &\n                                  controller_run     &\n                                  ~stall_ld_hz;\n\n    assign instr_executing = instr_valid_i              &\n                             ~instr_kill                &\n                             ~stall_ld_hz               &\n                             ~outstanding_memory_access;\n\n    `ASSERT(IbexExecutingSpecIfExecuting, instr_executing |-> instr_executing_spec)\n\n    `ASSERT(IbexStallIfValidInstrNotExecuting,\n      instr_valid_i & ~instr_kill & ~instr_executing |-> stall_id)\n\n    `ASSERT(IbexCannotRetireWithPendingExceptions,\n      instr_done |-> ~(wb_exception | outstanding_memory_access))\n\n    // Stall for reasons related to memory:\n    // * There is an outstanding memory access that won't resolve this cycle (need to wait to allow\n    //   precise exceptions)\n    // * There is a load/store request not being granted or which is unaligned and waiting to issue\n    //   a second request (needs to stay in ID for the address calculation)\n    assign stall_mem = instr_valid_i &\n                       (outstanding_memory_access | (lsu_req_dec & ~lsu_req_done_i));\n\n    // If we stall a load in ID for any reason, it must not make an LSU request\n    // (otherwide we might issue two requests for the same instruction)\n    `ASSERT(IbexStallMemNoRequest,\n      instr_valid_i & lsu_req_dec & ~instr_done |-> ~lsu_req_done_i)\n\n    assign rf_rd_a_wb_match = (rf_waddr_wb_i == rf_raddr_a_o) & |rf_raddr_a_o;\n    assign rf_rd_b_wb_match = (rf_waddr_wb_i == rf_raddr_b_o) & |rf_raddr_b_o;\n\n    assign rf_rd_a_wb_match_o = rf_rd_a_wb_match;\n    assign rf_rd_b_wb_match_o = rf_rd_b_wb_match;\n\n    // If instruction is reading register that load will be writing stall in\n    // ID until load is complete. No need to stall when reading zero register.\n    assign rf_rd_a_hz = rf_rd_a_wb_match & rf_ren_a;\n    assign rf_rd_b_hz = rf_rd_b_wb_match & rf_ren_b;\n\n    // If instruction is read register that writeback is writing forward writeback data to read\n    // data. Note this doesn't factor in load data as it arrives too late, such hazards are\n    // resolved via a stall (see above).\n    assign rf_rdata_a_fwd = rf_rd_a_wb_match & rf_write_wb_i ? rf_wdata_fwd_wb_i : rf_rdata_a_i;\n    assign rf_rdata_b_fwd = rf_rd_b_wb_match & rf_write_wb_i ? rf_wdata_fwd_wb_i : rf_rdata_b_i;\n\n    assign stall_ld_hz = outstanding_load_wb_i & (rf_rd_a_hz | rf_rd_b_hz);\n\n    assign instr_type_wb_o = ~lsu_req_dec ? WB_INSTR_OTHER :\n                              lsu_we      ? WB_INSTR_STORE :\n                                            WB_INSTR_LOAD;\n\n    assign instr_id_done_o = en_wb_o & ready_wb_i;\n\n    // Stall ID/EX as instruction in ID/EX cannot proceed to writeback yet\n    assign stall_wb = en_wb_o & ~ready_wb_i;\n\n    assign perf_dside_wait_o = instr_valid_i & ~instr_kill &\n                               (outstanding_memory_access | stall_ld_hz);\n  end else begin : gen_no_stall_mem\n\n    assign multicycle_done = lsu_req_dec ? lsu_resp_valid_i : ex_valid_i;\n\n    assign data_req_allowed = instr_first_cycle;\n\n    // Without Writeback Stage always stall the first cycle of a load/store.\n    // Then stall until it is complete\n    assign stall_mem = instr_valid_i & (lsu_req_dec & (~lsu_resp_valid_i | instr_first_cycle));\n\n    // No load hazards without Writeback Stage\n    assign stall_ld_hz   = 1'b0;\n\n    // Without writeback stage any valid instruction that hasn't seen an error will execute\n    assign instr_executing_spec = instr_valid_i & ~instr_fetch_err_i & controller_run;\n    assign instr_executing = instr_executing_spec;\n\n    `ASSERT(IbexStallIfValidInstrNotExecuting,\n      instr_valid_i & ~instr_fetch_err_i & ~instr_executing & controller_run |-> stall_id)\n\n    // No data forwarding without writeback stage "}
{"text": "so always take source register data direct from\n    // register file\n    assign rf_rdata_a_fwd = rf_rdata_a_i;\n    assign rf_rdata_b_fwd = rf_rdata_b_i;\n\n    assign rf_rd_a_wb_match_o = 1'b0;\n    assign rf_rd_b_wb_match_o = 1'b0;\n\n    // Unused Writeback stage only IO & wiring\n    // Assign inputs and internal wiring to unused signals to satisfy lint checks\n    // Tie-off outputs to constant values\n    logic unused_data_req_done_ex;\n    logic [4:0] unused_rf_waddr_wb;\n    logic unused_rf_write_wb;\n    logic unused_outstanding_load_wb;\n    logic unused_outstanding_store_wb;\n    logic unused_wb_exception;\n    logic [31:0] unused_rf_wdata_fwd_wb;\n    logic unused_id_exception;\n\n    assign unused_data_req_done_ex     = lsu_req_done_i;\n    assign unused_rf_waddr_wb          = rf_waddr_wb_i;\n    assign unused_rf_write_wb          = rf_write_wb_i;\n    assign unused_outstanding_load_wb  = outstanding_load_wb_i;\n    assign unused_outstanding_store_wb = outstanding_store_wb_i;\n    assign unused_wb_exception         = wb_exception;\n    assign unused_rf_wdata_fwd_wb      = rf_wdata_fwd_wb_i;\n    assign unused_id_exception         = id_exception;\n\n    assign instr_type_wb_o = WB_INSTR_OTHER;\n    assign stall_wb        = 1'b0;\n\n    assign perf_dside_wait_o = instr_executing & lsu_req_dec & ~lsu_resp_valid_i;\n\n    assign instr_id_done_o = instr_done;\n  end\n\n  // Signal which instructions to count as retired in minstret, all traps along with ebrk and\n  // ecall instructions are not counted.\n  assign instr_perf_count_id_o = ~ebrk_insn & ~ecall_insn_dec & ~illegal_insn_dec &\n      ~illegal_csr_insn_i & ~instr_fetch_err_i;\n\n  // An instruction is ready to move to the writeback stage (or retire if there is no writeback\n  // stage)\n  assign en_wb_o = instr_done;\n\n  assign perf_mul_wait_o = stall_multdiv & mult_en_dec;\n  assign perf_div_wait_o = stall_multdiv & div_en_dec;\n\n  //////////\n  // FCOV //\n  //////////\n\n  `DV_FCOV_SIGNAL_GEN_IF(logic, rf_rd_wb_hz,\n    (gen_stall_mem.rf_rd_a_hz | gen_stall_mem.rf_rd_b_hz) & instr_valid_i, WritebackStage)\n  `DV_FCOV_SIGNAL(logic, branch_taken,\n    instr_executing & (id_fsm_q == FIRST_CYCLE) & branch_decision_i)\n  `DV_FCOV_SIGNAL(logic, branch_not_taken,\n    instr_executing & (id_fsm_q == FIRST_CYCLE) & ~branch_decision_i)\n\n  ////////////////\n  // Assertions //\n  ////////////////\n\n  // Selectors must be known/valid.\n  `ASSERT_KNOWN_IF(IbexAluOpMuxSelKnown, alu_op_a_mux_sel, instr_valid_i)\n  `ASSERT(IbexAluAOpMuxSelValid, instr_valid_i |-> alu_op_a_mux_sel inside {\n      OP_A_REG_A,\n      OP_A_FWD,\n      OP_A_CURRPC,\n      OP_A_IMM})\n  `ASSERT_KNOWN_IF(IbexBTAluAOpMuxSelKnown, bt_a_mux_sel, instr_valid_i)\n  `ASSERT(IbexBTAluAOpMuxSelValid, instr_valid_i |-> bt_a_mux_sel inside {\n      OP_A_REG_A,\n      OP_A_CURRPC})\n  `ASSERT_KNOWN_IF(IbexBTAluBOpMuxSelKnown, bt_b_mux_sel, instr_valid_i)\n  `ASSERT(IbexBTAluBOpMuxSelValid, instr_valid_i |-> bt_b_mux_sel inside {\n      IMM_B_I,\n      IMM_B_B,\n      IMM_B_J,\n      IMM_B_INCR_PC})\n  `ASSERT(IbexRegfileWdataSelValid, instr_valid_i |-> rf_wdata_sel inside {\n      RF_WD_EX,\n      RF_WD_CSR})\n  `ASSERT_KNOWN(IbexWbStateKnown, id_fsm_q)\n\n  // Branch decision must be valid when jumping.\n  `ASSERT_KNOWN_IF(IbexBranchDecisionValid, branch_decision_i,\n      instr_valid_i && !(illegal_csr_insn_i || instr_fetch_err_i))\n\n  // Instruction delivered to ID stage can not contain X.\n  `ASSERT_KNOWN_IF(IbexIdInstrKnown, instr_rdata_i,\n      instr_valid_i && !(illegal_c_insn_i || instr_fetch_err_i))\n\n  // Instruction delivered to ID stage can not contain X.\n  `ASSERT_KNOWN_IF(IbexIdInstrALUKnown, instr_rdata_alu_i,\n      instr_valid_i && !(illegal_c_insn_i || instr_fetch_err_i))\n\n  // Multicycle enable signals must be unique.\n  `ASSERT(IbexMulticycleEnableUnique,\n      $onehot0({lsu_req_dec, multdiv_en_dec, branch_in_dec, jump_in_dec}))\n\n  // Duplicated instruction flops must match\n  // === as DV environment can produce instructions with Xs in, so must use precise match that\n  // includes Xs\n  `ASSERT(IbexDuplicateInstrMatch, instr_valid_i |-> instr_rdata_i === instr_rdata_alu_i)\n\n  `ifdef CHECK_MISALIGNED\n  `ASSERT(IbexMisalignedMemoryAccess, !lsu_addr_incr_req_i)\n  `endif\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Instruction Fetch Stage\n *\n * Instruction fetch unit: Selection of the next PC, and buffering (sampling) of\n * the read instruction.\n */\n\n`include \"prim_assert.sv\"\n`include \"dv_fcov_macros.svh\"\n\nmodule ibex_if_stage import ibex_pkg::*; #(\n  parameter int unsigned DmHaltAddr        = 32'h1A110800,\n  parameter int unsigned DmExceptionAddr   = 32'h1A110808,\n  parameter bit          DummyInstructions = 1'b0,\n  parameter bit          ICache            = 1'b0,\n  parameter bit          ICacheECC         = 1'b0,\n  parameter int unsigned BusSizeECC        = BUS_SIZE,\n  parameter int unsigned TagSizeECC        = IC_TAG_SIZE,\n  parameter int unsigned LineSizeECC       = IC_LINE_SIZE,\n  parameter bit          PCIncrCheck       = 1'b0,\n  parameter bit          ResetAll          = 1'b0,\n  parameter lfsr_seed_t  RndCnstLfsrSeed   = RndCnstLfsrSeedDefault,\n  parameter lfsr_perm_t  RndCnstLfsrPerm   = RndCnstLfsrPermDefault,\n  parameter bit          BranchPredictor   = 1'b0,\n  parameter bit          MemECC            = 1'b0,\n  parameter int unsigned MemDataWidth      = MemECC ? 32 + 7 : 32\n) (\n  input  logic                         clk_i,\n  input  logic                         rst_ni,\n\n  input  logic [31:0]                  boot_addr_i,              // also used for mtvec\n  input  logic                         req_i,                    // instruction request control\n\n  // instruction cache interface\n  output logic                        instr_req_o,\n  output logic [31:0]                 instr_addr_o,\n  input  logic                        instr_gnt_i,\n  input  logic                        instr_rvalid_i,\n  input  logic [MemDataWidth-1:0]     instr_rdata_i,\n  input  logic                        instr_bus_err_i,\n  output logic                        instr_intg_err_o,\n\n  // ICache RAM IO\n  output logic [IC_NUM_WAYS-1:0]      ic_tag_req_o,\n  output logic                        ic_tag_write_o,\n  output logic [IC_INDEX_W-1:0]       ic_tag_addr_o,\n  output logic [TagSizeECC-1:0]       ic_tag_wdata_o,\n  input  logic [TagSizeECC-1:0]       ic_tag_rdata_i [IC_NUM_WAYS],\n  output logic [IC_NUM_WAYS-1:0]      ic_data_req_o,\n  output logic                        ic_data_write_o,\n  output logic [IC_INDEX_W-1:0]       ic_data_addr_o,\n  output logic [LineSizeECC-1:0]      ic_data_wdata_o,\n  input  logic [LineSizeECC-1:0]      ic_data_rdata_i [IC_NUM_WAYS],\n  input  logic                        ic_scr_key_valid_i,\n  output logic                        ic_scr_key_req_o,\n\n  // output of ID stage\n  output logic                        instr_valid_id_o,         // instr in IF-ID is valid\n  output logic                        instr_new_id_o,           // instr in IF-ID is new\n  output logic [31:0]                 instr_rdata_id_o,         // instr for ID stage\n  output logic [31:0]                 instr_rdata_alu_id_o,     // replicated instr for ID stage\n                                                                // to reduce fan-out\n  output logic [15:0]                 instr_rdata_c_id_o,       // compressed instr for ID stage\n                                                                // (mtval), meaningful only if\n                                                                // instr_is_compressed_id_o = 1'b1\n  output logic                        instr_is_compressed_id_o, // compressed decoder thinks this\n                                                                // is a compressed instr\n  output logic                        instr_bp_taken_o,         // instruction was predicted to be\n                                                                // a taken branch\n  output logic                        instr_fetch_err_o,        // bus error on fetch\n  output logic                        instr_fetch_err_plus2_o,  // bus error misaligned\n  output logic                        illegal_c_insn_id_o,      // compressed decoder thinks this\n                                                                // is an invalid instr\n  output logic                        dummy_instr_id_o,         // Instruction is a dummy\n  output logic [31:0]                 pc_if_o,\n  output logic [31:0]                 pc_id_o,\n  input  logic                        pmp_err_if_i,\n  input  logic                        pmp_err_if_plus2_i,\n\n  // control signals\n  input  logic                        instr_valid_clear_i,      // clear instr valid bit in IF-ID\n  input  logic                        pc_set_i,                 // set the PC to a new value\n  input  pc_sel_e                     pc_mux_i,                 // selector for PC multiplexer\n  input  logic                        nt_branch_mispredict_i,   // Not-taken branch in ID/EX was\n                                                                // mispredicted (predicted taken)\n  input  logic [31:0]                 nt_branch_addr_i,         // Not-taken branch address in ID/EX\n  input  exc_pc_sel_e                 exc_pc_mux_i,             // selects ISR address\n  input  exc_cause_t                  exc_cause,                // selects ISR address for\n                                                                // vectorized interrupt lines\n  input  logic                        dummy_instr_en_i,\n  input  logic [2:0]                  dummy_instr_mask_i,\n  input  logic                        dummy_instr_seed_en_i,\n  input  logic [31:0]                 dummy_instr_seed_i,\n  input  logic                        icache_enable_i,\n  input  logic                        icache_inval_i,\n  output logic                        icache_ecc_error_o,\n\n  // jump and branch target\n  input  logic [31:0]                 branch_target_ex_i,       // branch/jump target address\n\n  // CSRs\n  input  logic [31:0]                 csr_mepc_i,               // PC to restore after handling\n                                                                // the interrupt/exception\n  input  logic [31:0]                 csr_depc_i,               // PC to restore after handling\n                                                                // the debug request\n  input  logic [31:0]                 csr_mtvec_i,              // base PC to jump to on exception\n  output logic                        csr_mtvec_init_o,         // tell CS regfile to init mtvec\n\n  // pipeline stall\n  input  logic                        id_in_ready_i,            // ID stage is ready for new instr\n\n  // misc signals\n  output logic                        pc_mismatch_alert_o,\n  output logic                        if_busy_o                 // IF stage is busy fetching instr\n);\n\n  logic              instr_valid_id_d, instr_valid_id_q;\n  logic              instr_new_id_d, instr_new_id_q;\n\n  logic              instr_err, instr_intg_err;\n\n  // prefetch buffer related signals\n  logic              prefetch_busy;\n  logic              branch_req;\n  logic       [31:0] fetch_addr_n;\n  logic              unused_fetch_addr_n0;\n\n  logic              prefetch_branch;\n  logic [31:0]       prefetch_addr;\n\n  logic              fetch_valid_raw;\n  logic              fetch_valid;\n  logic              fetch_ready;\n  logic       [31:0] fetch_rdata;\n  logic       [31:0] fetch_addr;\n  logic              fetch_err;\n  logic              fetch_err_plus2;\n\n  logic [31:0]       instr_decompressed;\n  logic              illegal_c_insn;\n  logic              instr_is_compressed;\n\n  logic              if_instr_valid;\n  logic       [31:0] if_instr_rdata;\n  logic       [31:0] if_instr_addr;\n  logic              if_instr_bus_err;\n  logic              if_instr_pmp_err;\n  logic              if_instr_err;\n  logic              if_instr_err_plus2;\n\n  logic       [31:0] exc_pc;\n\n  logic              if_id_pipe_reg_we; // IF-ID pipeline reg write enable\n\n  // Dummy instruction signals\n  logic              stall_dummy_instr;\n  logic [31:0]       instr_out;\n  logic              instr_is_compressed_out;\n  logic              illegal_c_instr_out;\n  logic              instr_err_out;\n\n  logic              predict_branch_taken;\n  logic       [31:0] predict_branch_pc;\n\n  logic        [4:0] irq_vec;\n\n  ibex_pkg::pc_sel_e pc_mux_internal;\n\n  logic        [7:0] unused_boot_addr;\n  logic        [7:0] unused_csr_mtvec;\n  logic              unused_exc_cause;\n\n  assign unused_boot_addr = boot_addr_i[7:0];\n  assign unused_csr_mtvec = csr_mtvec_i[7:0];\n\n  assign unused_exc_cause = |{exc_cause.irq_ext, exc_cause.irq_int};\n\n  // exception PC selection mux\n  always_comb begin : exc_pc_mux\n    irq_vec = exc_cause.lower_cause;\n\n    if (exc_cause.irq_int) begin\n      // All internal interrupts go to the NMI vector\n      irq_vec = ExcCauseIrqNm.lower_cause;\n    end\n\n    unique case (exc_pc_mux_i)\n      EXC_PC_EXC:     exc_pc = { csr_mtvec_i[31:8], 8'h00                };\n      EXC_PC_IRQ:     exc_pc = { csr_mtvec_i[31:8], 1'b0, irq_vec, 2'b00 };\n      EXC_PC_DBD:     exc_pc = DmHaltAddr;\n      EXC_PC_DBG_EXC: exc_pc = DmExceptionAddr;\n      default:        exc_pc = { csr_mtvec_i[31:8], 8'h00                };\n    endcase\n  end\n\n  // The Branch predictor can provide a new PC which is internal to if_stage. Only override the mux\n  // select to choose this if the core isn't already trying to set a PC.\n  assign pc_mux_internal =\n    (BranchPredictor && predict_branch_taken && !pc_set_i) ? PC_BP : pc_mux_i;\n\n  // fetch address selection mux\n  always_comb begin : fetch_addr_mux\n    unique case (pc_mux_internal)\n      PC_BOOT: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };\n      PC_JUMP: fetch_addr_n = branch_target_ex_i;\n      PC_EXC:  fetch_addr_n = exc_pc;                       // set PC to exception handler\n      PC_ERET: fetch_addr_n = csr_mepc_i;                   // restore PC when returning from EXC\n      PC_DRET: fetch_addr_n = csr_depc_i;\n      // Without branch predictor will never get pc_mux_internal == PC_BP. We still handle no branch\n      // predictor case here to ensure redundant mux logic isn't synthesised.\n      PC_BP:   fetch_addr_n = BranchPredictor ? predict_branch_pc : { boot_addr_i[31:8], 8'h80 };\n      default: fetch_addr_n = { boot_addr_i[31:8], 8'h80 };\n    endcase\n  end\n\n  // tell CS register file to initialize mtvec on boot\n  assign csr_mtvec_init_o = (pc_mux_i == PC_BOOT) & pc_set_i;\n\n  // SEC_CM: BUS.INTEGRITY\n  if (MemECC) begin : g_mem_ecc\n    logic [1:0] ecc_err;\n    logic [MemDataWidth-1:0] instr_rdata_buf;\n\n    prim_buf #(.Width(MemDataWidth)) u_prim_buf_instr_rdata (\n      .in_i (instr_rdata_i),\n      .out_o(instr_rdata_buf)\n    );\n\n    prim_secded_inv_39_32_dec u_instr_intg_dec (\n      .data_i     (instr_rdata_buf),\n      .data_o     (),\n      .syndrome_o (),\n      .err_o      (ecc_err)\n    );\n\n    // Don't care if error is correctable or not, they're all treated the same\n    assign instr_intg_err = |ecc_err;\n  end else begin : g_no_mem_ecc\n    assign instr_intg_err            = 1'b0;\n  end\n\n  assign instr_err        = instr_intg_err | instr_bus_err_i;\n  assign instr_intg_err_o = instr_intg_err & instr_rvalid_i;\n\n  // There are two possible \"branch please\" signals that are computed in the IF stage: branch_req\n  // and nt_branch_mispredict_i. These should be mutually exclusive (see the NoMispredBranch\n  // assertion), so we can just OR the signals together.\n  assign prefetch_branch = branch_req | nt_branch_mispredict_i;\n  assign prefetch_addr   = branch_req ? {fetch_addr_n[31:1], 1'b0} : nt_branch_addr_i;\n\n  // The fetch_valid signal that comes out of the icache or prefetch buffer should be squashed if we\n  // had a misprediction.\n  assign fetch_valid = fetch_valid_raw & ~nt_branch_mispredict_i;\n\n  // We should never see a mispredict and an incoming branch on the same cycle. The mispredict also\n  // cancels any predicted branch so overall branch_req must be low.\n  `ASSERT(NoMispredBranch, nt_branch_mispredict_i |-> ~branch_req)\n\n  if (ICache) begin : gen_icache\n    // Full I-Cache option\n    ibex_icache #(\n      .ICacheECC       (ICacheECC),\n      .ResetAll        (ResetAll),\n      .BusSizeECC      (BusSizeECC),\n      .TagSizeECC      (TagSizeECC),\n      .LineSizeECC     (LineSizeECC)\n    ) icache_i (\n        .clk_i               ( clk_i                      ),\n        .rst_ni              ( rst_ni                     ),\n\n        .req_i               ( req_i                      ),\n\n        .branch_i            ( prefetch_branch            ),\n        .addr_i              ( prefetch_addr              ),\n\n        .ready_i             ( fetch_ready                ),\n        .valid_o             ( fetch_valid_raw            ),\n        .rdata_o             ( fetch_rdata                ),\n        .addr_o              ( fetch_addr                 ),\n        .err_o               ( fetch_err                  ),\n        .err_plus2_o         ( fetch_err_plus2            ),\n\n        .instr_req_o         ( instr_req_o                ),\n        .instr_addr_o        ( instr_addr_o               ),\n        .instr_gnt_i         ( instr_gnt_i                ),\n        .instr_rvalid_i      ( instr_rvalid_i             ),\n        .instr_rdata_i       ( instr_rdata_i[31:0]        ),\n        .instr_err_i         ( instr_err                  ),\n\n        .ic_tag_req_o        ( ic_tag_req_o               ),\n        .ic_tag_write_o      ( ic_tag_write_o             ),\n        .ic_tag_addr_o       ( ic_tag_addr_o              ),\n        .ic_tag_wdata_o      ( ic_tag_wdata_o             ),\n        .ic_tag_rdata_i      ( ic_tag_rdata_i             ),\n        .ic_data_req_o       ( ic_data_req_o              ),\n        .ic_data_write_o     ( ic_data_write_o            ),\n        .ic_data_addr_o      ( ic_data_addr_o             ),\n        .ic_data_wdata_o     ( ic_data_wdata_o            ),\n        .ic_data_rdata_i     ( ic_data_rdata_i            ),\n        .ic_scr_key_valid_i  ( ic_scr_key_valid_i         ),\n        .ic_scr_key_req_o    ( ic_scr_key_req_o           ),\n\n        .icache_enable_i     ( icache_enable_i            ),\n        .icache_inval_i      ( icache_inval_i             ),\n        .busy_o              ( prefetch_busy              ),\n        .ecc_error_o         ( icache_ecc_error_o         )\n    );\n  end else begin : gen_prefetch_buffer\n    // prefetch buffer, caches a fixed number of instructions\n    ibex_prefetch_buffer #(\n      .ResetAll        (ResetAll)\n    ) prefetch_buffer_i (\n        .clk_i               ( clk_i                      ),\n        .rst_ni              ( rst_ni                     ),\n\n        .req_i               ( req_i                      ),\n\n        .branch_i            ( prefetch_branch            ),\n        .addr_i              ( prefetch_addr              ),\n\n        .ready_i             ( fetch_ready                ),\n        .valid_o             ( fetch_valid_raw            ),\n        .rdata_o             ( fetch_rdata                ),\n        .addr_o              ( fetch_addr                 ),\n        .err_o               ( fetch_err                  ),\n        .err_plus2_o         ( fetch_err_plus2            ),\n\n        .instr_req_o         ( instr_req_o                ),\n        .instr_addr_o        ( instr_addr_o               ),\n        .instr_gnt_i         ( instr_gnt_i                ),\n        .instr_rvalid_i      ( instr_rvalid_i             ),\n        .instr_rdata_i       ( instr_rdata_i[31:0]        ),\n        .instr_err_i         ( instr_err                  ),\n\n        .busy_o              ( prefetch_busy              )\n    );\n    // ICache tieoffs\n    logic                   unused_icen, unused_icinv, unused_scr_key_valid;\n    logic [TagSizeECC-1:0]  unused_tag_ram_input [IC_NUM_WAYS];\n    logic [LineSizeECC-1:0] unused_data_ram_input [IC_NUM_WAYS];\n    assign unused_icen           = icache_enable_i;\n    assign unused_icinv          = icache_inval_i;\n    assign unused_tag_ram_input  = ic_tag_rdata_i;\n    assign unused_data_ram_input = ic_data_rdata_i;\n    assign unused_scr_key_valid  = ic_scr_key_valid_i;\n    assign ic_tag_req_o          = 'b0;\n    assign ic_tag_write_o        = 'b0;\n    assign ic_tag_addr_o         = 'b0;\n    assign ic_tag_wdata_o        = 'b0;\n    assign ic_data_req_o         = 'b0;\n    assign ic_data_write_o       = 'b0;\n    assign ic_data_addr_o        = 'b0;\n    assign ic_data_wdata_o       = 'b0;\n    assign ic_scr_key_req_o      = 'b0;\n    assign icache_ecc_error_o    = 'b0;\n\n`ifndef SYNTHESIS\n    // If we don't instantiate an icache and this is a simulation then we have a problem because the\n    // simulator might discard the icache module entirely, including some DPI exports that it\n    // implies. This then causes problems for linking against C++ testbench code that expected them.\n    // As a slightly ugly hack, let's define the DPI functions here (the real versions are defined\n    // in prim_util_get_scramble_params.svh)\n    export \"DPI-C\" function simutil_get_scramble_key;\n    export \"DPI-C\" function simutil_get_scramble_nonce;\n    function automatic int simutil_get_scramble_key(output bit [127:0] val);\n      return 0;\n    endfunction\n    function automatic int simutil_get_scramble_nonce(output bit [319:0] nonce);\n      return 0;\n    endfunction\n`endif\n  end\n\n  assign unused_fetch_addr_n0 = fetch_addr_n[0];\n\n  assign branch_req  = pc_set_i | predict_branch_taken;\n\n  assign pc_if_o     = if_instr_addr;\n  assign if_busy_o   = prefetch_busy;\n\n  // PMP errors\n  // An error can come from the instruction address, or the next instruction address for unaligned,\n  // uncompressed instructions.\n  assign if_instr_pmp_err = pmp_err_if_i |\n                            (if_instr_addr[1] & ~instr_is_compressed & pmp_err_if_plus2_i);\n\n  // Combine bus errors and pmp errors\n  assign if_instr_err = if_instr_bus_err | if_instr_pmp_err;\n\n  // Capture the second half of the address for errors on the second part of an instruction\n  assign if_instr_err_plus2 = ((if_instr_addr[1] & ~instr_is_compressed & pmp_err_if_plus2_i) |\n                               fetch_err_plus2) & ~pmp_err_if_i;\n\n  // compressed instruction decoding, or more precisely compressed instruction\n  // expander\n  //\n  // since it does not matter where we decompress instructions, we do it here\n  // to ease timing closure\n  ibex_compressed_decoder compressed_decoder_i (\n    .clk_i          (clk_i),\n    .rst_ni         (rst_ni),\n    .valid_i        (fetch_valid & ~fetch_err),\n    .instr_i        (if_instr_rdata),\n    .instr_o        (instr_decompressed),\n    .is_compressed_o(instr_is_compressed),\n    .illegal_instr_o(illegal_c_insn)\n  );\n\n  // Dummy instruction insertion\n  if (DummyInstructions) begin : gen_dummy_instr\n    // SEC_CM: CTRL_FLOW.UNPREDICTABLE\n    logic        insert_dummy_instr;\n    logic [31:0] dummy_instr_data;\n\n    ibex_dummy_instr #(\n      .RndCnstLfsrSeed (RndCnstLfsrSeed),\n      .RndCnstLfsrPerm (RndCnstLfsrPerm)\n    ) dummy_instr_i (\n      .clk_i                (clk_i),\n      .rst_ni               (rst_ni),\n      .dummy_instr_en_i     (dummy_instr_en_i),\n      .dummy_instr_mask_i   (dummy_instr_mask_i),\n      .dummy_instr_seed_en_i(dummy_instr_seed_en_i),\n      .dummy_instr_seed_i   (dummy_instr_seed_i),\n      .fetch_valid_i        (fetch_valid),\n      .id_in_ready_i        (id_in_ready_i),\n      .insert_dummy_instr_o (insert_dummy_instr),\n      .dummy_instr_data_o   (dummy_instr_data)\n    );\n\n    // Mux between actual instructions and dummy instructions\n    assign instr_out               = insert_dummy_instr ? dummy_instr_data : instr_decompressed;\n    assign instr_is_compressed_out = insert_dummy_instr ? 1'b0 : instr_is_compressed;\n    assign illegal_c_instr_out     = insert_dummy_instr ? 1'b0 : illegal_c_insn;\n    assign instr_err_out           = insert_dummy_instr ? 1'b0 : if_instr_err;\n\n    // Stall the IF stage if we insert a dummy instruction. The dummy will execute between whatever\n    // is currently in the ID stage and whatever is valid from the prefet"}
{"text": "ch buffer this cycle. The\n    // PC of the dummy instruction will match whatever is next from the prefetch buffer.\n    assign stall_dummy_instr = insert_dummy_instr;\n\n    // Register the dummy instruction indication into the ID stage\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        dummy_instr_id_o <= 1'b0;\n      end else if (if_id_pipe_reg_we) begin\n        dummy_instr_id_o <= insert_dummy_instr;\n      end\n    end\n\n  end else begin : gen_no_dummy_instr\n    logic        unused_dummy_en;\n    logic [2:0]  unused_dummy_mask;\n    logic        unused_dummy_seed_en;\n    logic [31:0] unused_dummy_seed;\n\n    assign unused_dummy_en         = dummy_instr_en_i;\n    assign unused_dummy_mask       = dummy_instr_mask_i;\n    assign unused_dummy_seed_en    = dummy_instr_seed_en_i;\n    assign unused_dummy_seed       = dummy_instr_seed_i;\n    assign instr_out               = instr_decompressed;\n    assign instr_is_compressed_out = instr_is_compressed;\n    assign illegal_c_instr_out     = illegal_c_insn;\n    assign instr_err_out           = if_instr_err;\n    assign stall_dummy_instr       = 1'b0;\n    assign dummy_instr_id_o        = 1'b0;\n  end\n\n  // The ID stage becomes valid as soon as any instruction is registered in the ID stage flops.\n  // Note that the current instruction is squashed by the incoming pc_set_i signal.\n  // Valid is held until it is explicitly cleared (due to an instruction completing or an exception)\n  assign instr_valid_id_d = (if_instr_valid & id_in_ready_i & ~pc_set_i) |\n                            (instr_valid_id_q & ~instr_valid_clear_i);\n  assign instr_new_id_d   = if_instr_valid & id_in_ready_i;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      instr_valid_id_q <= 1'b0;\n      instr_new_id_q   <= 1'b0;\n    end else begin\n      instr_valid_id_q <= instr_valid_id_d;\n      instr_new_id_q   <= instr_new_id_d;\n    end\n  end\n\n  assign instr_valid_id_o = instr_valid_id_q;\n  // Signal when a new instruction enters the ID stage (only used for RVFI signalling).\n  assign instr_new_id_o   = instr_new_id_q;\n\n  // IF-ID pipeline registers, frozen when the ID stage is stalled\n  assign if_id_pipe_reg_we = instr_new_id_d;\n\n  if (ResetAll) begin : g_instr_rdata_ra\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        instr_rdata_id_o         <= '0;\n        instr_rdata_alu_id_o     <= '0;\n        instr_fetch_err_o        <= '0;\n        instr_fetch_err_plus2_o  <= '0;\n        instr_rdata_c_id_o       <= '0;\n        instr_is_compressed_id_o <= '0;\n        illegal_c_insn_id_o      <= '0;\n        pc_id_o                  <= '0;\n      end else if (if_id_pipe_reg_we) begin\n        instr_rdata_id_o         <= instr_out;\n        // To reduce fan-out and help timing from the instr_rdata_id flops they are replicated.\n        instr_rdata_alu_id_o     <= instr_out;\n        instr_fetch_err_o        <= instr_err_out;\n        instr_fetch_err_plus2_o  <= if_instr_err_plus2;\n        instr_rdata_c_id_o       <= if_instr_rdata[15:0];\n        instr_is_compressed_id_o <= instr_is_compressed_out;\n        illegal_c_insn_id_o      <= illegal_c_instr_out;\n        pc_id_o                  <= pc_if_o;\n      end\n    end\n  end else begin : g_instr_rdata_nr\n    always_ff @(posedge clk_i) begin\n      if (if_id_pipe_reg_we) begin\n        instr_rdata_id_o         <= instr_out;\n        // To reduce fan-out and help timing from the instr_rdata_id flops they are replicated.\n        instr_rdata_alu_id_o     <= instr_out;\n        instr_fetch_err_o        <= instr_err_out;\n        instr_fetch_err_plus2_o  <= if_instr_err_plus2;\n        instr_rdata_c_id_o       <= if_instr_rdata[15:0];\n        instr_is_compressed_id_o <= instr_is_compressed_out;\n        illegal_c_insn_id_o      <= illegal_c_instr_out;\n        pc_id_o                  <= pc_if_o;\n      end\n    end\n  end\n\n  // Check for expected increments of the PC when security hardening enabled\n  if (PCIncrCheck) begin : g_secure_pc\n    // SEC_CM: PC.CTRL_FLOW.CONSISTENCY\n    logic [31:0] prev_instr_addr_incr, prev_instr_addr_incr_buf;\n    logic        prev_instr_seq_q, prev_instr_seq_d;\n\n    // Do not check for sequential increase after a branch, jump, exception, interrupt or debug\n    // request, all of which will set branch_req. Also do not check after reset or for dummys.\n    assign prev_instr_seq_d = (prev_instr_seq_q | instr_new_id_d) &\n        ~branch_req & ~if_instr_err & ~stall_dummy_instr;\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        prev_instr_seq_q <= 1'b0;\n      end else begin\n        prev_instr_seq_q <= prev_instr_seq_d;\n      end\n    end\n\n    assign prev_instr_addr_incr = pc_id_o + (instr_is_compressed_id_o ? 32'd2 : 32'd4);\n\n    // Buffer anticipated next PC address to ensure optimiser cannot remove the check.\n    prim_buf #(.Width(32)) u_prev_instr_addr_incr_buf (\n      .in_i (prev_instr_addr_incr),\n      .out_o(prev_instr_addr_incr_buf)\n    );\n\n    // Check that the address equals the previous address +2/+4\n    assign pc_mismatch_alert_o = prev_instr_seq_q & (pc_if_o != prev_instr_addr_incr_buf);\n\n  end else begin : g_no_secure_pc\n    assign pc_mismatch_alert_o = 1'b0;\n  end\n\n  if (BranchPredictor) begin : g_branch_predictor\n    logic [31:0] instr_skid_data_q;\n    logic [31:0] instr_skid_addr_q;\n    logic        instr_skid_bp_taken_q;\n    logic        instr_skid_valid_q, instr_skid_valid_d;\n    logic        instr_skid_en;\n    logic        instr_bp_taken_q, instr_bp_taken_d;\n\n    logic        predict_branch_taken_raw;\n\n    // ID stages needs to know if branch was predicted taken so it can signal mispredicts\n    if (ResetAll) begin : g_bp_taken_ra\n      always_ff @(posedge clk_i or negedge rst_ni) begin\n        if (!rst_ni) begin\n          instr_bp_taken_q <= '0;\n        end else if (if_id_pipe_reg_we) begin\n          instr_bp_taken_q <= instr_bp_taken_d;\n        end\n      end\n    end else begin : g_bp_taken_nr\n      always_ff @(posedge clk_i) begin\n        if (if_id_pipe_reg_we) begin\n          instr_bp_taken_q <= instr_bp_taken_d;\n        end\n      end\n    end\n\n    // When branch prediction is enabled a skid buffer between the IF and ID/EX stage is introduced.\n    // If an instruction in IF is predicted to be a taken branch and ID/EX is not ready the\n    // instruction in IF is moved to the skid buffer which becomes the output of the IF stage until\n    // the ID/EX stage accepts the instruction. The skid buffer is required as otherwise the ID/EX\n    // ready signal is coupled to the instr_req_o output which produces a feedthrough path from\n    // data_gnt_i -> instr_req_o (which needs to be avoided as for some interconnects this will\n    // result in a combinational loop).\n\n    assign instr_skid_en = predict_branch_taken & ~pc_set_i & ~id_in_ready_i & ~instr_skid_valid_q;\n\n    assign instr_skid_valid_d = (instr_skid_valid_q & ~id_in_ready_i & ~stall_dummy_instr) |\n                                instr_skid_en;\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        instr_skid_valid_q <= 1'b0;\n      end else begin\n        instr_skid_valid_q <= instr_skid_valid_d;\n      end\n    end\n\n    if (ResetAll) begin : g_instr_skid_ra\n      always_ff @(posedge clk_i or negedge rst_ni) begin\n        if (!rst_ni) begin\n          instr_skid_bp_taken_q <= '0;\n          instr_skid_data_q     <= '0;\n          instr_skid_addr_q     <= '0;\n        end else if (instr_skid_en) begin\n          instr_skid_bp_taken_q <= predict_branch_taken;\n          instr_skid_data_q     <= fetch_rdata;\n          instr_skid_addr_q     <= fetch_addr;\n        end\n      end\n    end else begin : g_instr_skid_nr\n      always_ff @(posedge clk_i) begin\n        if (instr_skid_en) begin\n          instr_skid_bp_taken_q <= predict_branch_taken;\n          instr_skid_data_q     <= fetch_rdata;\n          instr_skid_addr_q     <= fetch_addr;\n        end\n      end\n    end\n\n    ibex_branch_predict branch_predict_i (\n      .clk_i        (clk_i),\n      .rst_ni       (rst_ni),\n      .fetch_rdata_i(fetch_rdata),\n      .fetch_pc_i   (fetch_addr),\n      .fetch_valid_i(fetch_valid),\n\n      .predict_branch_taken_o(predict_branch_taken_raw),\n      .predict_branch_pc_o   (predict_branch_pc)\n    );\n\n    // If there is an instruction in the skid buffer there must be no branch prediction.\n    // Instructions are only placed in the skid after they have been predicted to be a taken branch\n    // so with the skid valid any prediction has already occurred.\n    // Do not branch predict on instruction errors.\n    assign predict_branch_taken = predict_branch_taken_raw & ~instr_skid_valid_q & ~fetch_err;\n\n    assign if_instr_valid   = fetch_valid | (instr_skid_valid_q & ~nt_branch_mispredict_i);\n    assign if_instr_rdata   = instr_skid_valid_q ? instr_skid_data_q : fetch_rdata;\n    assign if_instr_addr    = instr_skid_valid_q ? instr_skid_addr_q : fetch_addr;\n\n    // Don't branch predict on instruction error so only instructions without errors end up in the\n    // skid buffer.\n    assign if_instr_bus_err = ~instr_skid_valid_q & fetch_err;\n    assign instr_bp_taken_d = instr_skid_valid_q ? instr_skid_bp_taken_q : predict_branch_taken;\n\n    assign fetch_ready = id_in_ready_i & ~stall_dummy_instr & ~instr_skid_valid_q;\n\n    assign instr_bp_taken_o = instr_bp_taken_q;\n\n    `ASSERT(NoPredictSkid, instr_skid_valid_q |-> ~predict_branch_taken)\n    `ASSERT(NoPredictIllegal, predict_branch_taken |-> ~illegal_c_insn)\n  end else begin : g_no_branch_predictor\n    assign instr_bp_taken_o     = 1'b0;\n    assign predict_branch_taken = 1'b0;\n    assign predict_branch_pc    = 32'b0;\n\n    assign if_instr_valid = fetch_valid;\n    assign if_instr_rdata = fetch_rdata;\n    assign if_instr_addr  = fetch_addr;\n    assign if_instr_bus_err = fetch_err;\n    assign fetch_ready = id_in_ready_i & ~stall_dummy_instr;\n  end\n\n  //////////\n  // FCOV //\n  //////////\n\n`ifndef SYNTHESIS\n  // fcov signals for V2S\n  `DV_FCOV_SIGNAL_GEN_IF(logic [1:0], dummy_instr_type,\n    gen_dummy_instr.dummy_instr_i.lfsr_data.instr_type, DummyInstructions)\n  `DV_FCOV_SIGNAL_GEN_IF(logic, insert_dummy_instr,\n    gen_dummy_instr.insert_dummy_instr, DummyInstructions)\n`endif\n\n  ////////////////\n  // Assertions //\n  ////////////////\n\n  // Selectors must be known/valid.\n  `ASSERT_KNOWN(IbexExcPcMuxKnown, exc_pc_mux_i)\n\n  if (BranchPredictor) begin : g_branch_predictor_asserts\n    `ASSERT_IF(IbexPcMuxValid, pc_mux_internal inside {\n        PC_BOOT,\n        PC_JUMP,\n        PC_EXC,\n        PC_ERET,\n        PC_DRET,\n        PC_BP},\n      pc_set_i)\n\n`ifdef INC_ASSERT\n    /**\n     * Checks for branch prediction interface to fetch_fifo/icache\n     *\n     * The interface has two signals:\n     * - predicted_branch_i: When set with a branch (branch_i) indicates the branch is a predicted\n     *   one, it should be ignored when a branch_i isn't set.\n     * - branch_mispredict_i: Indicates the previously predicted branch was mis-predicted and\n     *   execution should resume with the not-taken side of the branch (i.e. continue with the PC\n     *   that followed the predicted branch). This must be raised before the instruction that is\n     *   made available following a predicted branch is accepted (Following a cycle with branch_i\n     *   & predicted_branch_i, branch_mispredict_i can only be asserted before or on the same cycle\n     *   as seeing fetch_valid & fetch_ready). When branch_mispredict_i is asserted, fetch_valid may\n     *   be asserted in response. If fetch_valid is asserted on the same cycle as\n     *   branch_mispredict_i this indicates the fetch_fifo/icache has the not-taken side of the\n     *   branch immediately ready for use\n     */\n    logic        predicted_branch_live_q, predicted_branch_live_d;\n    logic [31:0] predicted_branch_nt_pc_q, predicted_branch_nt_pc_d;\n    logic [31:0] awaiting_instr_after_mispredict_q, awaiting_instr_after_mispredict_d;\n    logic [31:0] next_pc;\n\n    logic mispredicted, mispredicted_d, mispredicted_q;\n\n    assign next_pc = fetch_addr + (instr_is_compressed_out ? 32'd2 : 32'd4);\n\n    logic predicted_branch;\n\n    // pc_set_i takes precendence over branch prediction\n    assign predicted_branch = predict_branch_taken & ~pc_set_i;\n\n    always_comb begin\n      predicted_branch_live_d = predicted_branch_live_q;\n      mispredicted_d          = mispredicted_q;\n\n      if (branch_req & predicted_branch) begin\n        predicted_branch_live_d = 1'b1;\n        mispredicted_d          = 1'b0;\n      end else if (predicted_branch_live_q) begin\n        if (fetch_valid & fetch_ready) begin\n          predicted_branch_live_d = 1'b0;\n        end else if (nt_branch_mispredict_i) begin\n          mispredicted_d = 1'b1;\n        end\n      end\n    end\n\n    always @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        predicted_branch_live_q <= 1'b0;\n        mispredicted_q          <= 1'b0;\n      end else begin\n        predicted_branch_live_q <= predicted_branch_live_d;\n        mispredicted_q          <= mispredicted_d;\n      end\n    end\n\n    always @(posedge clk_i) begin\n      if (branch_req & predicted_branch) begin\n        predicted_branch_nt_pc_q <= next_pc;\n      end\n    end\n\n    // Must only see mispredict after we've performed a predicted branch but before we've accepted\n    // any instruction (with fetch_ready & fetch_valid) that follows that predicted branch.\n    `ASSERT(MispredictOnlyImmediatelyAfterPredictedBranch,\n      nt_branch_mispredict_i |-> predicted_branch_live_q)\n    // Check that on mispredict we get the correct PC for the non-taken side of the branch when\n    // prefetch buffer/icache makes that PC available.\n    `ASSERT(CorrectPCOnMispredict,\n      predicted_branch_live_q & mispredicted_d & fetch_valid |->\n      fetch_addr == predicted_branch_nt_pc_q)\n    // Must not signal mispredict over multiple cycles but it's possible to have back to back\n    // mispredicts for different branches (core signals mispredict, prefetch buffer/icache immediate\n    // has not-taken side of the mispredicted branch ready, which itself is a predicted branch,\n    // following cycle core signal that that branch has mispredicted).\n    `ASSERT(MispredictSingleCycle,\n      nt_branch_mispredict_i & ~(fetch_valid & fetch_ready) |=> ~nt_branch_mispredict_i)\n`endif\n\n  end else begin : g_no_branch_predictor_asserts\n    `ASSERT_IF(IbexPcMuxValid, pc_mux_internal inside {\n        PC_BOOT,\n        PC_JUMP,\n        PC_EXC,\n        PC_ERET,\n        PC_DRET},\n      pc_set_i)\n  end\n\n  // Boot address must be aligned to 256 bytes.\n  `ASSERT(IbexBootAddrUnaligned, boot_addr_i[7:0] == 8'h00)\n\n  // Address must not contain X when request is sent.\n  `ASSERT(IbexInstrAddrUnknown, instr_req_o |-> !$isunknown(instr_addr_o))\n\n  // Address must be word aligned when request is sent.\n  `ASSERT(IbexInstrAddrUnaligned, instr_req_o |-> (instr_addr_o[1:0] == 2'b00))\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n\n/**\n * Load Store Unit\n *\n * Load Store Unit, used to eliminate multiple access during processor stalls,\n * and to align bytes and halfwords.\n */\n\n`include \"prim_assert.sv\"\n`include \"dv_fcov_macros.svh\"\n\nmodule ibex_load_store_unit #(\n  parameter bit          MemECC       = 1'b0,\n  parameter int unsigned MemDataWidth = MemECC ? 32 + 7 : 32\n) (\n  input  logic         clk_i,\n  input  logic         rst_ni,\n\n  // data interface\n  output logic         data_req_o,\n  input  logic         data_gnt_i,\n  input  logic         data_rvalid_i,\n  input  logic         data_bus_err_i,\n  input  logic         data_pmp_err_i,\n\n  output logic [31:0]             data_addr_o,\n  output logic                    data_we_o,\n  output logic [3:0]              data_be_o,\n  output logic [MemDataWidth-1:0] data_wdata_o,\n  input  logic [MemDataWidth-1:0] data_rdata_i,\n\n  // signals to/from ID/EX stage\n  input  logic         lsu_we_i,             // write enable                     -> from ID/EX\n  input  logic [1:0]   lsu_type_i,           // data type: word, half word, byte -> from ID/EX\n  input  logic [31:0]  lsu_wdata_i,          // data to write to memory          -> from ID/EX\n  input  logic         lsu_sign_ext_i,       // sign extension                   -> from ID/EX\n\n  output logic [31:0]  lsu_rdata_o,          // requested data                   -> to ID/EX\n  output logic         lsu_rdata_valid_o,\n  input  logic         lsu_req_i,            // data request                     -> from ID/EX\n\n  input  logic [31:0]  adder_result_ex_i,    // address computed in ALU          -> from ID/EX\n\n  output logic         addr_incr_req_o,      // request address increment for\n                                              // misaligned accesses              -> to ID/EX\n  output logic [31:0]  addr_last_o,          // address of last transaction      -> to controller\n                                              // -> mtval\n                                              // -> AGU for misaligned accesses\n\n  output logic         lsu_req_done_o,       // Signals that data request is complete\n                                              // (only need to await final data\n                                              // response)                        -> to ID/EX\n\n  output logic         lsu_resp_valid_o,     // LSU has response from transaction -> to ID/EX\n\n  // exception signals\n  output logic         load_err_o,\n  output logic         load_resp_intg_err_o,\n  output logic         store_err_o,\n  output logic         store_resp_intg_err_o,\n\n  output logic         busy_o,\n\n  output logic         perf_load_o,\n  output logic         perf_store_o\n);\n\n  logic [31:0]  data_addr;\n  logic [31:0]  data_addr_w_aligned;\n  logic [31:0]  addr_last_q, addr_last_d;\n\n  logic         addr_update;\n  logic         ctrl_update;\n  logic         rdata_update;\n  logic [31:8]  rdata_q;\n  logic [1:0]   rdata_offset_q;\n  logic [1:0]   data_type_q;\n  logic         data_sign_ext_q;\n  logic         data_we_q;\n\n  logic [1:0]   data_offset;   // mux control for data to be written to memory\n\n  logic [3:0]   data_be;\n  logic [31:0]  data_wdata;\n\n  logic [31:0]  data_rdata_ext;\n\n  logic [31:0]  rdata_w_ext; // word realignment for misaligned loads\n  logic [31:0]  rdata_h_ext; // sign extension for half words\n  logic [31:0]  rdata_b_ext; // sign extension for bytes\n\n  logic         split_misaligned_access;\n  logic         handle_misaligned_q, handle_misaligned_d; // high after receiving grant for first\n                                                          // part of a misaligned access\n  logic         pmp_err_q, pmp_err_d;\n  logic         lsu_err_q, lsu_err_d;\n  logic         data_intg_err, data_or_pmp_err;\n\n  typedef enum logic [2:0]  {\n    IDLE, WAIT_GNT_MIS, WAIT_RVALID_MIS, WAIT_GNT,\n    WAIT_RVALID_MIS_GNTS_DONE\n  } ls_fsm_e;\n\n  ls_fsm_e ls_fsm_cs, ls_fsm_ns;\n\n  assign data_addr   = adder_result_ex_i;\n  assign data_offset = data_addr[1:0];\n\n  ///////////////////\n  // BE generation //\n  ///////////////////\n\n  always_comb begin\n    unique case (lsu_type_i) // Data type 00 Word, 01 Half word, 11,10 byte\n      2'b00: begin // Writing a word\n        if (!handle_misaligned_q) begin // first part of potentially misaligned transaction\n          unique case (data_offset)\n            2'b00:   data_be = 4'b1111;\n            2'b01:   data_be = 4'b1110;\n            2'b10:   data_be = 4'b1100;\n            2'b11:   data_be = 4'b1000;\n            default: data_be = 4'b1111;\n          endcase // case (data_offset)\n        end else begin // second part of misaligned transaction\n          unique case (data_offset)\n            2'b00:   data_be = 4'b0000; // this is not used, but included for completeness\n            2'b01:   data_be = 4'b0001;\n            2'b10:   data_be = 4'b0011;\n            2'b11:   data_be = 4'b0111;\n            default: data_be = 4'b1111;\n          endcase // case (data_offset)\n        end\n      end\n\n      2'b01: begin // Writing a half word\n        if (!handle_misaligned_q) begin // first part of potentially misaligned transaction\n          unique case (data_offset)\n            2'b00:   data_be = 4'b0011;\n            2'b01:   data_be = 4'b0110;\n            2'b10:   data_be = 4'b1100;\n            2'b11:   data_be = 4'b1000;\n            default: data_be = 4'b1111;\n          endcase // case (data_offset)\n        end else begin // second part of misaligned transaction\n          data_be = 4'b0001;\n        end\n      end\n\n      2'b10,\n      2'b11: begin // Writing a byte\n        unique case (data_offset)\n          2'b00:   data_be = 4'b0001;\n          2'b01:   data_be = 4'b0010;\n          2'b10:   data_be = 4'b0100;\n          2'b11:   data_be = 4'b1000;\n          default: data_be = 4'b1111;\n        endcase // case (data_offset)\n      end\n\n      default:     data_be = 4'b1111;\n    endcase // case (lsu_type_i)\n  end\n\n  /////////////////////\n  // WData alignment //\n  /////////////////////\n\n  // prepare data to be written to the memory\n  // we handle misaligned accesses, half word and byte accesses here\n  always_comb begin\n    unique case (data_offset)\n      2'b00:   data_wdata =  lsu_wdata_i[31:0];\n      2'b01:   data_wdata = {lsu_wdata_i[23:0], lsu_wdata_i[31:24]};\n      2'b10:   data_wdata = {lsu_wdata_i[15:0], lsu_wdata_i[31:16]};\n      2'b11:   data_wdata = {lsu_wdata_i[ 7:0], lsu_wdata_i[31: 8]};\n      default: data_wdata =  lsu_wdata_i[31:0];\n    endcase // case (data_offset)\n  end\n\n  /////////////////////\n  // RData alignment //\n  /////////////////////\n\n  // register for unaligned rdata\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      rdata_q <= '0;\n    end else if (rdata_update) begin\n      rdata_q <= data_rdata_i[31:8];\n    end\n  end\n\n  // registers for transaction control\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      rdata_offset_q  <= 2'h0;\n      data_type_q     <= 2'h0;\n      data_sign_ext_q <= 1'b0;\n      data_we_q       <= 1'b0;\n    end else if (ctrl_update) begin\n      rdata_offset_q  <= data_offset;\n      data_type_q     <= lsu_type_i;\n      data_sign_ext_q <= lsu_sign_ext_i;\n      data_we_q       <= lsu_we_i;\n    end\n  end\n\n  // Store last address for mtval + AGU for misaligned transactions.  Do not update in case of\n  // errors, mtval needs the (first) failing address.  Where an aligned access or the first half of\n  // a misaligned access sees an error provide the calculated access address. For the second half of\n  // a misaligned access provide the word aligned address of the second half.\n  assign addr_last_d = addr_incr_req_o ? data_addr_w_aligned : data_addr;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      addr_last_q <= '0;\n    end else if (addr_update) begin\n      addr_last_q <= addr_last_d;\n    end\n  end\n\n  // take care of misaligned words\n  always_comb begin\n    unique case (rdata_offset_q)\n      2'b00:   rdata_w_ext =  data_rdata_i[31:0];\n      2'b01:   rdata_w_ext = {data_rdata_i[ 7:0], rdata_q[31:8]};\n      2'b10:   rdata_w_ext = {data_rdata_i[15:0], rdata_q[31:16]};\n      2'b11:   rdata_w_ext = {data_rdata_i[23:0], rdata_q[31:24]};\n      default: rdata_w_ext =  data_rdata_i[31:0];\n    endcase\n  end\n\n  ////////////////////\n  // Sign extension //\n  ////////////////////\n\n  // sign extension for half words\n  always_comb begin\n    unique case (rdata_offset_q)\n      2'b00: begin\n        if (!data_sign_ext_q) begin\n          rdata_h_ext = {16'h0000, data_rdata_i[15:0]};\n        end else begin\n          rdata_h_ext = {{16{data_rdata_i[15]}}, data_rdata_i[15:0]};\n        end\n      end\n\n      2'b01: begin\n        if (!data_sign_ext_q) begin\n          rdata_h_ext = {16'h0000, data_rdata_i[23:8]};\n        end else begin\n          rdata_h_ext = {{16{data_rdata_i[23]}}, data_rdata_i[23:8]};\n        end\n      end\n\n      2'b10: begin\n        if (!data_sign_ext_q) begin\n          rdata_h_ext = {16'h0000, data_rdata_i[31:16]};\n        end else begin\n          rdata_h_ext = {{16{data_rdata_i[31]}}, data_rdata_i[31:16]};\n        end\n      end\n\n      2'b11: begin\n        if (!data_sign_ext_q) begin\n          rdata_h_ext = {16'h0000, data_rdata_i[7:0], rdata_q[31:24]};\n        end else begin\n          rdata_h_ext = {{16{data_rdata_i[7]}}, data_rdata_i[7:0], rdata_q[31:24]};\n        end\n      end\n\n      default: rdata_h_ext = {16'h0000, data_rdata_i[15:0]};\n    endcase // case (rdata_offset_q)\n  end\n\n  // sign extension for bytes\n  always_comb begin\n    unique case (rdata_offset_q)\n      2'b00: begin\n        if (!data_sign_ext_q) begin\n          rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};\n        end else begin\n          rdata_b_ext = {{24{data_rdata_i[7]}}, data_rdata_i[7:0]};\n        end\n      end\n\n      2'b01: begin\n        if (!data_sign_ext_q) begin\n          rdata_b_ext = {24'h00_0000, data_rdata_i[15:8]};\n        end else begin\n          rdata_b_ext = {{24{data_rdata_i[15]}}, data_rdata_i[15:8]};\n        end\n      end\n\n      2'b10: begin\n        if (!data_sign_ext_q) begin\n          rdata_b_ext = {24'h00_0000, data_rdata_i[23:16]};\n        end else begin\n          rdata_b_ext = {{24{data_rdata_i[23]}}, data_rdata_i[23:16]};\n        end\n      end\n\n      2'b11: begin\n        if (!data_sign_ext_q) begin\n          rdata_b_ext = {24'h00_0000, data_rdata_i[31:24]};\n        end else begin\n          rdata_b_ext = {{24{data_rdata_i[31]}}, data_rdata_i[31:24]};\n        end\n      end\n\n      default: rdata_b_ext = {24'h00_0000, data_rdata_i[7:0]};\n    endcase // case (rdata_offset_q)\n  end\n\n  // select word, half word or byte sign extended version\n  always_comb begin\n    unique case (data_type_q)\n      2'b00:       data_rdata_ext = rdata_w_ext;\n      2'b01:       data_rdata_ext = rdata_h_ext;\n      2'b10,2'b11: data_rdata_ext = rdata_b_ext;\n      default:     data_rdata_ext = rdata_w_ext;\n    endcase // case (data_type_q)\n  end\n\n  ///////////////////////////////\n  // Read data integrity check //\n  ///////////////////////////////\n\n  // SEC_CM: BUS.INTEGRITY\n  if (MemECC) begin : g_mem_rdata_ecc\n    logic [1:0] ecc_err;\n    logic [MemDataWidth-1:0] data_rdata_buf;\n\n    prim_buf #(.Width(MemDataWidth)) u_prim_buf_instr_rdata (\n      .in_i (data_rdata_i),\n      .out_o(data_rdata_buf)\n    );\n\n    prim_secded_inv_39_32_dec u_data_intg_dec (\n      .data_i     (data_rdata_buf),\n      .data_o     (),\n      .syndrome_o (),\n      .err_o      (ecc_err)\n    );\n\n    // Don't care if error is correctable or not, they're all treated the same\n    assign data_intg_err = |ecc_err;\n  end else begin : g_no_mem_data_ecc\n    assign data_intg_err = 1'b0;\n  end\n\n  /////////////\n  // LSU FSM //\n  /////////////\n\n  // check for misaligned accesses that need to be split into two word-aligned accesses\n  assign split_misaligned_access =\n      ((lsu_type_i == 2'b00) && (data_offset != 2'b00)) || // misaligned word access\n      ((lsu_type_i == 2'b01) && (data_offset == 2'b11));   // misaligned half-word access\n\n  // FSM\n  always_comb begin\n    ls_fsm_ns       = ls_fsm_cs;\n\n    data_req_o          = 1'b0;\n    addr_incr_req_o     = 1'b0;\n    handle_misaligned_d = handle_misaligned_q;\n    pmp_err_d           = pmp_err_q;\n    lsu_err_d           = lsu_err_q;\n\n    addr_update         = 1'b0;\n    ctrl_update         = 1'b0;\n    rdata_update        = 1'b0;\n\n    perf_load_o         = 1'b0;\n    perf_store_o        = 1'b0;\n\n    unique case (ls_fsm_cs)\n\n      IDLE: begin\n        pmp_err_d = 1'b0;\n        if (lsu_req_i) begin\n          data_req_o   = 1'b1;\n          pmp_err_d    = data_pmp_err_i;\n          lsu_err_d    = 1'b0;\n          perf_load_o  = ~lsu_we_i;\n          perf_store_o = lsu_we_i;\n\n          if (data_gnt_i) begin\n            ctrl_update         = 1'b1;\n            addr_update         = 1'b1;\n            handle_misaligned_d = split_misaligned_access;\n            ls_fsm_ns           = split_misaligned_access ? WAIT_RVALID_MIS : IDLE;\n          end else begin\n            ls_fsm_ns           = split_misaligned_access ? WAIT_GNT_MIS    : WAIT_GNT;\n          end\n        end\n      end\n\n      WAIT_GNT_MIS: begin\n        data_req_o = 1'b1;\n        // data_pmp_err_i is valid during the address phase of a request. An error will block the\n        // external request and so a data_gnt_i might never be signalled. The registered version\n        // pmp_err_q is only updated for new address phases and so can be used in WAIT_GNT* and\n        // WAIT_RVALID* states\n        if (data_gnt_i || pmp_err_q) begin\n          addr_update         = 1'b1;\n          ctrl_update         = 1'b1;\n          handle_misaligned_d = 1'b1;\n          ls_fsm_ns           = WAIT_RVALID_MIS;\n        end\n      end\n\n      WAIT_RVALID_MIS: begin\n        // push out second request\n        data_req_o = 1'b1;\n        // tell ID/EX stage to update the address\n        addr_incr_req_o = 1'b1;\n\n        // first part rvalid is received, or gets a PMP error\n        if (data_rvalid_i || pmp_err_q) begin\n          // Update the PMP error for the second part\n          pmp_err_d = data_pmp_err_i;\n          // Record the error status of the first part\n          lsu_err_d = data_bus_err_i | pmp_err_q;\n          // Capture the first rdata for loads\n          rdata_update = ~data_we_q;\n          // If already granted, wait for second rvalid\n          ls_fsm_ns = data_gnt_i ? IDLE : WAIT_GNT;\n          // Update the address for the second part, if no error\n          addr_update = data_gnt_i & ~(data_bus_err_i | pmp_err_q);\n          // clear handle_misaligned if second request is granted\n          handle_misaligned_d = ~data_gnt_i;\n        end else begin\n          // first part rvalid is NOT received\n          if (data_gnt_i) begin\n            // second grant is received\n            ls_fsm_ns = WAIT_RVALID_MIS_GNTS_DONE;\n            handle_misaligned_d = 1'b0;\n          end\n        end\n      end\n\n      WAIT_GNT: begin\n        // tell ID/EX stage to update the address\n        addr_incr_req_o = handle_misaligned_q;\n        data_req_o      = 1'b1;\n        if (data_gnt_i || pmp_err_q) begin\n          ctrl_update         = 1'b1;\n          // Update the address, unless there was an error\n          addr_update         = ~lsu_err_q;\n          ls_fsm_ns           = IDLE;\n          handle_misaligned_d = 1'b0;\n        end\n      end\n\n      WAIT_RVALID_MIS_GNTS_DONE: begin\n        // tell ID/EX stage to update the address (to make sure the\n        // second address can be captured correctly for mtval and PMP checking)\n        addr_incr_req_o = 1'b1;\n        // Wait for the first rvalid, second request is already granted\n        if (data_rvalid_i) begin\n          // Update the pmp error for the second part\n          pmp_err_d = data_pmp_err_i;\n          // The first part cannot see a PMP error in this state\n          lsu_err_d = data_bus_err_i;\n          // Now we can update the address for the second part if no error\n          addr_update = ~data_bus_err_i;\n          // Capture the first rdata for loads\n          rdata_update = ~data_we_q;\n          // Wait for second rvalid\n          ls_fsm_ns = IDLE;\n        end\n      end\n\n      default: begin\n        ls_fsm_ns = IDLE;\n      end\n    endcase\n  end\n\n  assign lsu_req_done_o = (lsu_req_i | (ls_fsm_cs != IDLE)) & (ls_fsm_ns == IDLE);\n\n  // registers for FSM\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      ls_fsm_cs           <= IDLE;\n      handle_misaligned_q <= '0;\n      pmp_err_q           <= '0;\n      lsu_err_q           <= '0;\n    end else begin\n      ls_fsm_cs           <= ls_fsm_ns;\n      handle_misaligned_q <= handle_misaligned_d;\n      pmp_err_q           <= pmp_err_d;\n      lsu_err_q           <= lsu_err_d;\n    end\n  end\n\n  /////////////\n  // Outputs //\n  /////////////\n\n  assign data_or_pmp_err    = lsu_err_q | data_bus_err_i | pmp_err_q;\n  assign lsu_resp_valid_o   = (data_rvalid_i | pmp_err_q) & (ls_fsm_cs == IDLE);\n  assign lsu_rdata_valid_o  =\n    (ls_fsm_cs == IDLE) & data_rvalid_i & ~data_or_pmp_err & ~data_we_q & ~data_intg_err;\n\n  // output to register file\n  assign lsu_rdata_o = data_rdata_ext;\n\n  // output data address must be word aligned\n  assign data_addr_w_aligned = {data_addr[31:2], 2'b00};\n\n  // output to data interface\n  assign data_addr_o   = data_addr_w_aligned;\n  assign data_we_o     = lsu_we_i;\n  assign data_be_o     = data_be;\n\n  /////////////////////////////////////\n  // Write data integrity generation //\n  /////////////////////////////////////\n\n  // SEC_CM: BUS.INTEGRITY\n  if (MemECC) begin : g_mem_wdata_ecc\n    prim_secded_inv_39_32_enc u_data_gen (\n      .data_i (data_wdata),\n      .data_o (data_wdata_o)\n    );\n  end else begin : g_no_mem_wdata_ecc\n    assign data_wdata_o = data_wdata;\n  end\n\n  // output to ID stage: mtval + AGU for misaligned transactions\n  assign addr_last_o   = addr_last_q;\n\n  // Signal a load or store error depending on the transaction type outstanding\n  assign load_err_o      = data_or_pmp_err & ~data_we_q & lsu_resp_valid_o;\n  assign store_err_o     = data_or_pmp_err &  data_we_q & lsu_resp_valid_o;\n  // Integrity errors are their own category for timing reasons. load_err_o is factored directly\n  // into data_req_o to enable synchronous exception on load errors without performance loss (An\n  // upcoming load cannot request until the current load has seen its response, so the earliest\n  // point the new request can be sent is the same cycle the response is seen). If load_err_o isn't\n  // factored into data_req_o there would have to be a stall cycle between all back to back loads.\n  // The data_intg_err signal is generated combinatorially from the incoming data_rdata_i. Were it\n  // to be factored into load_err_o there would be a feedthrough path from data_rdata_i to\n  // data_req_o which is undesirable.\n  assign load_resp_intg_err_o  = data_intg_err & data_rvalid_i & ~data_we_q;\n  assign store_resp_intg_err_o = data_intg_err & data_rvalid_i & data_we_q;\n\n  assign busy_o = (ls_fsm_cs != IDLE);\n\n  //////////\n  // FCOV //\n  //////////\n`ifndef DV_FCOV_DISABLE\n  // Set when awaiting the response for the second half of a misaligned access\n  logic fcov_mis_2_en_d, fcov_mis_2_en_q;\n\n  // fcov_mis_rvalid_1: Set when the response is received to the first half of a misaligned access,\n  // fcov_mis_rvalid_2: Set when response is received for the second half\n  logic fcov_mis_rvalid_1, fcov_mis_rvalid_2;\n\n  // Set when the first half of a misaligned access saw a bus errror\n  logic fcov_mis_bus_err_1_d, fcov_mis_bus_err_1_q;\n\n  assign fcov_mis_rvalid_1 = ls_fsm_cs inside {WAIT_RVALID_MIS, WAIT_RVALID_MIS_GNTS_DONE} &&\n                                data_rvalid_i;\n\n  assign fcov_mis_rvalid_2 = ls_fsm_cs inside {IDLE} && fcov_mis_2_en_q && data_rvalid_i;\n\n  assign fcov_mis_2_en_d = fcov_mis_rvalid_2 ? 1'b0            :  // clr\n                "}
{"text": "           fcov_mis_rvalid_1 ? 1'b1            :  // set\n                                               fcov_mis_2_en_q ;\n\n  assign fcov_mis_bus_err_1_d = fcov_mis_rvalid_2                   ? 1'b0                 : // clr\n                                fcov_mis_rvalid_1 && data_bus_err_i ? 1'b1                 : // set\n                                                                      fcov_mis_bus_err_1_q ;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      fcov_mis_2_en_q <= 1'b0;\n      fcov_mis_bus_err_1_q <= 1'b0;\n    end else begin\n      fcov_mis_2_en_q <= fcov_mis_2_en_d;\n      fcov_mis_bus_err_1_q <= fcov_mis_bus_err_1_d;\n    end\n  end\n`endif\n\n  `DV_FCOV_SIGNAL(logic, ls_error_exception, (load_err_o | store_err_o) & ~pmp_err_q)\n  `DV_FCOV_SIGNAL(logic, ls_pmp_exception, (load_err_o | store_err_o) & pmp_err_q)\n  `DV_FCOV_SIGNAL(logic, ls_first_req, lsu_req_i & (ls_fsm_cs == IDLE))\n  `DV_FCOV_SIGNAL(logic, ls_second_req,\n    (ls_fsm_cs inside {WAIT_RVALID_MIS}) & data_req_o & addr_incr_req_o)\n  `DV_FCOV_SIGNAL(logic, ls_mis_pmp_err_1,\n    (ls_fsm_cs inside {WAIT_RVALID_MIS, WAIT_GNT_MIS}) && pmp_err_q)\n  `DV_FCOV_SIGNAL(logic, ls_mis_pmp_err_2,\n    (ls_fsm_cs inside {WAIT_RVALID_MIS, WAIT_RVALID_MIS_GNTS_DONE}) && data_pmp_err_i)\n\n  ////////////////\n  // Assertions //\n  ////////////////\n\n  // Selectors must be known/valid.\n  `ASSERT(IbexDataTypeKnown, (lsu_req_i | busy_o) |-> !$isunknown(lsu_type_i))\n  `ASSERT(IbexDataOffsetKnown, (lsu_req_i | busy_o) |-> !$isunknown(data_offset))\n  `ASSERT_KNOWN(IbexRDataOffsetQKnown, rdata_offset_q)\n  `ASSERT_KNOWN(IbexDataTypeQKnown, data_type_q)\n  `ASSERT(IbexLsuStateValid, ls_fsm_cs inside {\n      IDLE, WAIT_GNT_MIS, WAIT_RVALID_MIS, WAIT_GNT,\n      WAIT_RVALID_MIS_GNTS_DONE})\n\n  // Address must not contain X when request is sent.\n  `ASSERT(IbexDataAddrUnknown, data_req_o |-> !$isunknown(data_addr_o))\n\n  // Address must be word aligned when request is sent.\n  `ASSERT(IbexDataAddrUnaligned, data_req_o |-> (data_addr_o[1:0] == 2'b00))\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n// Ibex lockstep module\n// This module instantiates a second copy of the core logic, and compares it's outputs against\n// those from the main core. The second core runs synchronously with the main core, delayed by\n// LockstepOffset cycles.\n\n// SEC_CM: LOGIC.SHADOW\nmodule ibex_lockstep import ibex_pkg::*; #(\n  parameter int unsigned LockstepOffset    = 2,\n  parameter bit          PMPEnable         = 1'b0,\n  parameter int unsigned PMPGranularity    = 0,\n  parameter int unsigned PMPNumRegions     = 4,\n  parameter int unsigned MHPMCounterNum    = 0,\n  parameter int unsigned MHPMCounterWidth  = 40,\n  parameter bit          RV32E             = 1'b0,\n  parameter rv32m_e      RV32M             = RV32MFast,\n  parameter rv32b_e      RV32B             = RV32BNone,\n  parameter bit          BranchTargetALU   = 1'b0,\n  parameter bit          WritebackStage    = 1'b0,\n  parameter bit          ICache            = 1'b0,\n  parameter bit          ICacheECC         = 1'b0,\n  parameter int unsigned BusSizeECC        = BUS_SIZE,\n  parameter int unsigned TagSizeECC        = IC_TAG_SIZE,\n  parameter int unsigned LineSizeECC       = IC_LINE_SIZE,\n  parameter bit          BranchPredictor   = 1'b0,\n  parameter bit          DbgTriggerEn      = 1'b0,\n  parameter int unsigned DbgHwBreakNum     = 1,\n  parameter bit          ResetAll          = 1'b0,\n  parameter lfsr_seed_t  RndCnstLfsrSeed   = RndCnstLfsrSeedDefault,\n  parameter lfsr_perm_t  RndCnstLfsrPerm   = RndCnstLfsrPermDefault,\n  parameter bit          SecureIbex        = 1'b0,\n  parameter bit          DummyInstructions = 1'b0,\n  parameter bit          RegFileECC        = 1'b0,\n  parameter int unsigned RegFileDataWidth  = 32,\n  parameter bit          MemECC            = 1'b0,\n  parameter int unsigned MemDataWidth      = MemECC ? 32 + 7 : 32,\n  parameter int unsigned DmHaltAddr        = 32'h1A110800,\n  parameter int unsigned DmExceptionAddr   = 32'h1A110808\n) (\n  input  logic                         clk_i,\n  input  logic                         rst_ni,\n\n  input  logic [31:0]                  hart_id_i,\n  input  logic [31:0]                  boot_addr_i,\n\n  input  logic                         instr_req_i,\n  input  logic                         instr_gnt_i,\n  input  logic                         instr_rvalid_i,\n  input  logic [31:0]                  instr_addr_i,\n  input  logic [MemDataWidth-1:0]      instr_rdata_i,\n  input  logic                         instr_err_i,\n\n  input  logic                         data_req_i,\n  input  logic                         data_gnt_i,\n  input  logic                         data_rvalid_i,\n  input  logic                         data_we_i,\n  input  logic [3:0]                   data_be_i,\n  input  logic [31:0]                  data_addr_i,\n  input  logic [MemDataWidth-1:0]      data_wdata_i,\n  input  logic [MemDataWidth-1:0]      data_rdata_i,\n  input  logic                         data_err_i,\n\n  input  logic                         dummy_instr_id_i,\n  input  logic                         dummy_instr_wb_i,\n  input  logic [4:0]                   rf_raddr_a_i,\n  input  logic [4:0]                   rf_raddr_b_i,\n  input  logic [4:0]                   rf_waddr_wb_i,\n  input  logic                         rf_we_wb_i,\n  input  logic [RegFileDataWidth-1:0]  rf_wdata_wb_ecc_i,\n  input  logic [RegFileDataWidth-1:0]  rf_rdata_a_ecc_i,\n  input  logic [RegFileDataWidth-1:0]  rf_rdata_b_ecc_i,\n\n  input  logic [IC_NUM_WAYS-1:0]       ic_tag_req_i,\n  input  logic                         ic_tag_write_i,\n  input  logic [IC_INDEX_W-1:0]        ic_tag_addr_i,\n  input  logic [TagSizeECC-1:0]        ic_tag_wdata_i,\n  input  logic [TagSizeECC-1:0]        ic_tag_rdata_i [IC_NUM_WAYS],\n  input  logic [IC_NUM_WAYS-1:0]       ic_data_req_i,\n  input  logic                         ic_data_write_i,\n  input  logic [IC_INDEX_W-1:0]        ic_data_addr_i,\n  input  logic [LineSizeECC-1:0]       ic_data_wdata_i,\n  input  logic [LineSizeECC-1:0]       ic_data_rdata_i [IC_NUM_WAYS],\n  input  logic                         ic_scr_key_valid_i,\n  input  logic                         ic_scr_key_req_i,\n\n  input  logic                         irq_software_i,\n  input  logic                         irq_timer_i,\n  input  logic                         irq_external_i,\n  input  logic [14:0]                  irq_fast_i,\n  input  logic                         irq_nm_i,\n  input  logic                         irq_pending_i,\n\n  input  logic                         debug_req_i,\n  input  crash_dump_t                  crash_dump_i,\n  input  logic                         double_fault_seen_i,\n\n  input  ibex_mubi_t                   fetch_enable_i,\n  output logic                         alert_minor_o,\n  output logic                         alert_major_internal_o,\n  output logic                         alert_major_bus_o,\n  input  ibex_mubi_t                   core_busy_i,\n  input  logic                         test_en_i,\n  input  logic                         scan_rst_ni\n);\n\n  localparam int unsigned LockstepOffsetW = $clog2(LockstepOffset);\n  // Core outputs are delayed for an extra cycle due to shadow output registers\n  localparam int unsigned OutputsOffset = LockstepOffset + 1;\n\n  //////////////////////\n  // Reset generation //\n  //////////////////////\n\n  // Upon reset, the comparison is stopped and the shadow core is reset, both immediately. A\n  // counter is started. After LockstepOffset clock cycles:\n  // - The counter is stopped.\n  // - The reset of the shadow core is synchronously released.\n  // The comparison is started in the following clock cycle.\n\n  logic [LockstepOffsetW-1:0] rst_shadow_cnt;\n  logic                       rst_shadow_cnt_err;\n  ibex_mubi_t                 rst_shadow_set_d, rst_shadow_set_q;\n  logic                       rst_shadow_n, rst_shadow_set_single_bit;\n  ibex_mubi_t                 enable_cmp_d, enable_cmp_q;\n\n  // This counter primitive starts counting to LockstepOffset after a system\n  // reset. The counter value saturates at LockstepOffset.\n  prim_count #(\n    .Width      (LockstepOffsetW        ),\n    .ResetValue (LockstepOffsetW'(1'b0) )\n  ) u_rst_shadow_cnt (\n    .clk_i              (clk_i                  ),\n    .rst_ni             (rst_ni                 ),\n    .clr_i              (1'b0                   ),\n    .set_i              (1'b0                   ),\n    .set_cnt_i          ('0                     ),\n    .incr_en_i          (1'b1                   ),\n    .decr_en_i          (1'b0                   ),\n    .step_i             (LockstepOffsetW'(1'b1) ),\n    .commit_i           (1'b1                   ),\n    .cnt_o              (rst_shadow_cnt         ),\n    .cnt_after_commit_o (                       ),\n    .err_o              (rst_shadow_cnt_err     )\n  );\n\n  // When the LockstepOffset counter value is reached, activate the lockstep\n  // comparison. We do not explicitly check whether rst_shadow_set_q forms a valid\n  // multibit signal as this value is implicitly checked by the enable_cmp\n  // comparison below.\n  assign rst_shadow_set_d =\n    (rst_shadow_cnt >= LockstepOffsetW'(LockstepOffset - 1)) ? IbexMuBiOn : IbexMuBiOff;\n\n  // Enable lockstep comparison.\n  assign enable_cmp_d = rst_shadow_set_q;\n\n  // This assignment is needed in order to avoid \"Warning-IMPERFECTSCH\" messages.\n  // TODO: Remove when updating Verilator #2134.\n  assign rst_shadow_set_single_bit = rst_shadow_set_q[0];\n\n  // The primitives below are used to place size-only constraints in order to prevent\n  // synthesis optimizations and preserve anchor points for constraining backend tools.\n  prim_flop #(\n    .Width(IbexMuBiWidth),\n    .ResetValue(IbexMuBiOff)\n  ) u_prim_rst_shadow_set_flop (\n    .clk_i (clk_i),\n    .rst_ni(rst_ni),\n    .d_i   (rst_shadow_set_d),\n    .q_o   (rst_shadow_set_q)\n  );\n\n  prim_flop #(\n    .Width(IbexMuBiWidth),\n    .ResetValue(IbexMuBiOff)\n  ) u_prim_enable_cmp_flop (\n    .clk_i (clk_i),\n    .rst_ni(rst_ni),\n    .d_i   (enable_cmp_d),\n    .q_o   (enable_cmp_q)\n  );\n\n  prim_clock_mux2 #(\n    .NoFpgaBufG(1'b1)\n  ) u_prim_rst_shadow_n_mux2 (\n    .clk0_i(rst_shadow_set_single_bit),\n    .clk1_i(scan_rst_ni),\n    .sel_i (test_en_i),\n    .clk_o (rst_shadow_n)\n  );\n\n  //////////////////\n  // Input delays //\n  //////////////////\n\n  typedef struct packed {\n    logic                        instr_gnt;\n    logic                        instr_rvalid;\n    logic [MemDataWidth-1:0]     instr_rdata;\n    logic                        instr_err;\n    logic                        data_gnt;\n    logic                        data_rvalid;\n    logic [MemDataWidth-1:0]     data_rdata;\n    logic                        data_err;\n    logic [RegFileDataWidth-1:0] rf_rdata_a_ecc;\n    logic [RegFileDataWidth-1:0] rf_rdata_b_ecc;\n    logic                        irq_software;\n    logic                        irq_timer;\n    logic                        irq_external;\n    logic [14:0]                 irq_fast;\n    logic                        irq_nm;\n    logic                        debug_req;\n    ibex_mubi_t                  fetch_enable;\n    logic                        ic_scr_key_valid;\n  } delayed_inputs_t;\n\n  delayed_inputs_t [LockstepOffset-1:0] shadow_inputs_q;\n  delayed_inputs_t                      shadow_inputs_in;\n  // Packed arrays must be dealt with separately\n  logic [TagSizeECC-1:0]                shadow_tag_rdata_q [IC_NUM_WAYS][LockstepOffset];\n  logic [LineSizeECC-1:0]               shadow_data_rdata_q [IC_NUM_WAYS][LockstepOffset];\n\n  // Assign the inputs to the delay structure\n  assign shadow_inputs_in.instr_gnt        = instr_gnt_i;\n  assign shadow_inputs_in.instr_rvalid     = instr_rvalid_i;\n  assign shadow_inputs_in.instr_rdata      = instr_rdata_i;\n  assign shadow_inputs_in.instr_err        = instr_err_i;\n  assign shadow_inputs_in.data_gnt         = data_gnt_i;\n  assign shadow_inputs_in.data_rvalid      = data_rvalid_i;\n  assign shadow_inputs_in.data_rdata       = data_rdata_i;\n  assign shadow_inputs_in.data_err         = data_err_i;\n  assign shadow_inputs_in.rf_rdata_a_ecc   = rf_rdata_a_ecc_i;\n  assign shadow_inputs_in.rf_rdata_b_ecc   = rf_rdata_b_ecc_i;\n  assign shadow_inputs_in.irq_software     = irq_software_i;\n  assign shadow_inputs_in.irq_timer        = irq_timer_i;\n  assign shadow_inputs_in.irq_external     = irq_external_i;\n  assign shadow_inputs_in.irq_fast         = irq_fast_i;\n  assign shadow_inputs_in.irq_nm           = irq_nm_i;\n  assign shadow_inputs_in.debug_req        = debug_req_i;\n  assign shadow_inputs_in.fetch_enable     = fetch_enable_i;\n  assign shadow_inputs_in.ic_scr_key_valid = ic_scr_key_valid_i;\n\n  // Delay the inputs\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      for (int unsigned i = 0; i < LockstepOffset; i++) begin\n        shadow_inputs_q[i]     <= delayed_inputs_t'('0);\n        shadow_tag_rdata_q[i]  <= '{default: 0};\n        shadow_data_rdata_q[i] <= '{default: 0};\n      end\n    end else begin\n      for (int unsigned i = 0; i < LockstepOffset - 1; i++) begin\n        shadow_inputs_q[i]     <= shadow_inputs_q[i+1];\n        shadow_tag_rdata_q[i]  <= shadow_tag_rdata_q[i+1];\n        shadow_data_rdata_q[i] <= shadow_data_rdata_q[i+1];\n      end\n      shadow_inputs_q[LockstepOffset-1]     <= shadow_inputs_in;\n      shadow_tag_rdata_q[LockstepOffset-1]  <= ic_tag_rdata_i;\n      shadow_data_rdata_q[LockstepOffset-1] <= ic_data_rdata_i;\n    end\n  end\n\n  ///////////////////\n  // Output delays //\n  ///////////////////\n\n  typedef struct packed {\n    logic                        instr_req;\n    logic [31:0]                 instr_addr;\n    logic                        data_req;\n    logic                        data_we;\n    logic [3:0]                  data_be;\n    logic [31:0]                 data_addr;\n    logic [MemDataWidth-1:0]     data_wdata;\n    logic                        dummy_instr_id;\n    logic                        dummy_instr_wb;\n    logic [4:0]                  rf_raddr_a;\n    logic [4:0]                  rf_raddr_b;\n    logic [4:0]                  rf_waddr_wb;\n    logic                        rf_we_wb;\n    logic [RegFileDataWidth-1:0] rf_wdata_wb_ecc;\n    logic [IC_NUM_WAYS-1:0]      ic_tag_req;\n    logic                        ic_tag_write;\n    logic [IC_INDEX_W-1:0]       ic_tag_addr;\n    logic [TagSizeECC-1:0]       ic_tag_wdata;\n    logic [IC_NUM_WAYS-1:0]      ic_data_req;\n    logic                        ic_data_write;\n    logic [IC_INDEX_W-1:0]       ic_data_addr;\n    logic [LineSizeECC-1:0]      ic_data_wdata;\n    logic                        ic_scr_key_req;\n    logic                        irq_pending;\n    crash_dump_t                 crash_dump;\n    logic                        double_fault_seen;\n    ibex_mubi_t                  core_busy;\n  } delayed_outputs_t;\n\n  delayed_outputs_t [OutputsOffset-1:0]  core_outputs_q;\n  delayed_outputs_t                      core_outputs_in;\n  delayed_outputs_t                      shadow_outputs_d, shadow_outputs_q;\n\n  // Assign core outputs to the structure\n  assign core_outputs_in.instr_req           = instr_req_i;\n  assign core_outputs_in.instr_addr          = instr_addr_i;\n  assign core_outputs_in.data_req            = data_req_i;\n  assign core_outputs_in.data_we             = data_we_i;\n  assign core_outputs_in.data_be             = data_be_i;\n  assign core_outputs_in.data_addr           = data_addr_i;\n  assign core_outputs_in.data_wdata          = data_wdata_i;\n  assign core_outputs_in.dummy_instr_id      = dummy_instr_id_i;\n  assign core_outputs_in.dummy_instr_wb      = dummy_instr_wb_i;\n  assign core_outputs_in.rf_raddr_a          = rf_raddr_a_i;\n  assign core_outputs_in.rf_raddr_b          = rf_raddr_b_i;\n  assign core_outputs_in.rf_waddr_wb         = rf_waddr_wb_i;\n  assign core_outputs_in.rf_we_wb            = rf_we_wb_i;\n  assign core_outputs_in.rf_wdata_wb_ecc     = rf_wdata_wb_ecc_i;\n  assign core_outputs_in.ic_tag_req          = ic_tag_req_i;\n  assign core_outputs_in.ic_tag_write        = ic_tag_write_i;\n  assign core_outputs_in.ic_tag_addr         = ic_tag_addr_i;\n  assign core_outputs_in.ic_tag_wdata        = ic_tag_wdata_i;\n  assign core_outputs_in.ic_data_req         = ic_data_req_i;\n  assign core_outputs_in.ic_data_write       = ic_data_write_i;\n  assign core_outputs_in.ic_data_addr        = ic_data_addr_i;\n  assign core_outputs_in.ic_data_wdata       = ic_data_wdata_i;\n  assign core_outputs_in.ic_scr_key_req      = ic_scr_key_req_i;\n  assign core_outputs_in.irq_pending         = irq_pending_i;\n  assign core_outputs_in.crash_dump          = crash_dump_i;\n  assign core_outputs_in.double_fault_seen   = double_fault_seen_i;\n  assign core_outputs_in.core_busy           = core_busy_i;\n\n  // Delay the outputs\n  always_ff @(posedge clk_i) begin\n    for (int unsigned i = 0; i < OutputsOffset - 1; i++) begin\n      core_outputs_q[i] <= core_outputs_q[i+1];\n    end\n    core_outputs_q[OutputsOffset-1] <= core_outputs_in;\n  end\n\n  ///////////////////////////////\n  // Shadow core instantiation //\n  ///////////////////////////////\n\n  logic shadow_alert_minor, shadow_alert_major_internal, shadow_alert_major_bus;\n\n  ibex_core #(\n    .PMPEnable         ( PMPEnable         ),\n    .PMPGranularity    ( PMPGranularity    ),\n    .PMPNumRegions     ( PMPNumRegions     ),\n    .MHPMCounterNum    ( MHPMCounterNum    ),\n    .MHPMCounterWidth  ( MHPMCounterWidth  ),\n    .RV32E             ( RV32E             ),\n    .RV32M             ( RV32M             ),\n    .RV32B             ( RV32B             ),\n    .BranchTargetALU   ( BranchTargetALU   ),\n    .ICache            ( ICache            ),\n    .ICacheECC         ( ICacheECC         ),\n    .BusSizeECC        ( BusSizeECC        ),\n    .TagSizeECC        ( TagSizeECC        ),\n    .LineSizeECC       ( LineSizeECC       ),\n    .BranchPredictor   ( BranchPredictor   ),\n    .DbgTriggerEn      ( DbgTriggerEn      ),\n    .DbgHwBreakNum     ( DbgHwBreakNum     ),\n    .WritebackStage    ( WritebackStage    ),\n    .ResetAll          ( ResetAll          ),\n    .RndCnstLfsrSeed   ( RndCnstLfsrSeed   ),\n    .RndCnstLfsrPerm   ( RndCnstLfsrPerm   ),\n    .SecureIbex        ( SecureIbex        ),\n    .DummyInstructions ( DummyInstructions ),\n    .RegFileECC        ( RegFileECC        ),\n    .RegFileDataWidth  ( RegFileDataWidth  ),\n    .MemECC            ( MemECC            ),\n    .MemDataWidth      ( MemDataWidth      ),\n    .DmHaltAddr        ( DmHaltAddr        ),\n    .DmExceptionAddr   ( DmExceptionAddr   )\n  ) u_shadow_core (\n    .clk_i               (clk_i),\n    .rst_ni              (rst_shadow_n),\n\n    .hart_id_i           (hart_id_i),\n    .boot_addr_i         (boot_addr_i),\n\n    .instr_req_o         (shadow_outputs_d.instr_req),\n    .instr_gnt_i         (shadow_inputs_q[0].instr_gnt),\n    .instr_rvalid_i      (shadow_inputs_q[0].instr_rvalid),\n    .instr_addr_o        (shadow_outputs_d.instr_addr),\n    .instr_rdata_i       (shadow_inputs_q[0].instr_rdata),\n    .instr_err_i         (shadow_inputs_q[0].instr_err),\n\n    .data_req_o          (shadow_outputs_d.data_req),\n    .data_gnt_i          (shadow_inputs_q[0].data_gnt),\n    .data_rvalid_i       (shadow_inputs_q[0].data_rvalid),\n    .data_we_o           (shadow_outputs_d.data_we),\n    .data_be_o           (shadow_outputs_d.data_be),\n    .data_addr_o         (shadow_outputs_d.data_addr),\n    .data_wdata_o        (shadow_outputs_d.data_wdata),\n    .data_rdata_i        (shadow_inputs_q[0].data_rdata),\n    .data_err_i          (shadow_inputs_q[0].data_err),\n\n    .dummy_instr_id_o    (shadow_outputs_d.dummy_instr_id),\n    .dummy_instr_wb_o    (shadow_outputs_d.dummy_instr_wb),\n    .rf_raddr_a_o        (shadow_outputs_d.rf_raddr_a),\n    .rf_raddr_b_o        (shadow_outputs_d.rf_raddr_b),\n    .rf_waddr_wb_o       (shadow_outputs_d.rf_waddr_wb),\n    .rf_we_wb_o          (shadow_outputs_d.rf_we_wb),\n    .rf_wdata_wb_ecc_o   (shadow_outputs_d.rf_wdata_wb_ecc),\n    .rf_rdata_a_ecc_i    (shadow_inputs_q[0].rf_rdata_a_ecc),\n    .rf_rdata_b_ecc_i    (shadow_inputs_q[0].rf_rdata_b_ecc),\n\n    .ic_tag_req_o        (shadow_outputs_d.ic_tag_req),\n    .ic_tag_write_o      (shadow_outputs_d.ic_tag_write),\n    .ic_tag_addr_o       (shadow_outputs_d.ic_tag_addr),\n    .ic_tag_wdata_o      (shadow_outputs_d.ic_tag_wdata),\n    .ic_tag_rdata_i      (shadow_tag_rdata_q[0]),\n    .ic_data_req_o       (shadow_outputs_d.ic_data_req),\n    .ic_data_write_o     (shadow_outputs_d.ic_data_write),\n    .ic_data_addr_o      (shadow_outputs_d.ic_data_addr),\n    .ic_data_wdata_o     (shadow_outputs_d.ic_data_wdata),\n    .ic_data_rdata_i     (shadow_data_rdata_q[0]),\n    .ic_scr_key_valid_i  (shadow_inputs_q[0].ic_scr_key_valid),\n    .ic_scr_key_req_o    (shadow_outputs_d.ic_scr_key_req),\n\n    .irq_software_i      (shadow_inputs_q[0].irq_software),\n    .irq_timer_i         (shadow_inputs_q[0].irq_timer),\n    .irq_external_i      (shadow_inputs_q[0].irq_external),\n    .irq_fast_i          (shadow_inputs_q[0].irq_fast),\n    .irq_nm_i            (shadow_inputs_q[0].irq_nm),\n    .irq_pending_o       (shadow_outputs_d.irq_pending),\n\n    .debug_req_i         (shadow_inputs_q[0].debug_req),\n    .crash_dump_o        (shadow_outputs_d.crash_dump),\n    .double_fault_seen_o (shadow_outputs_d.double_fault_seen),\n\n`ifdef RVFI\n    .rvfi_valid                (),\n    .rvfi_order                (),\n    .rvfi_insn                 (),\n    .rvfi_trap                 (),\n    .rvfi_halt                 (),\n    .rvfi_intr                 (),\n    .rvfi_mode                 (),\n    .rvfi_ixl                  (),\n    .rvfi_rs1_addr             (),\n    .rvfi_rs2_addr             (),\n    .rvfi_rs3_addr             (),\n    .rvfi_rs1_rdata            (),\n    .rvfi_rs2_rdata            (),\n    .rvfi_rs3_rdata            (),\n    .rvfi_rd_addr              (),\n    .rvfi_rd_wdata             (),\n    .rvfi_pc_rdata             (),\n    .rvfi_pc_wdata             (),\n    .rvfi_mem_addr             (),\n    .rvfi_mem_rma"}
{"text": "sk            (),\n    .rvfi_mem_wmask            (),\n    .rvfi_mem_rdata            (),\n    .rvfi_mem_wdata            (),\n    .rvfi_ext_mip              (),\n    .rvfi_ext_nmi              (),\n    .rvfi_ext_nmi_int          (),\n    .rvfi_ext_debug_req        (),\n    .rvfi_ext_debug_mode       (),\n    .rvfi_ext_rf_wr_suppress   (),\n    .rvfi_ext_mcycle           (),\n    .rvfi_ext_mhpmcounters     (),\n    .rvfi_ext_mhpmcountersh    (),\n    .rvfi_ext_ic_scr_key_valid (),\n    .rvfi_ext_irq_valid        (),\n`endif\n\n    .fetch_enable_i         (shadow_inputs_q[0].fetch_enable),\n    .alert_minor_o          (shadow_alert_minor),\n    .alert_major_internal_o (shadow_alert_major_internal),\n    .alert_major_bus_o      (shadow_alert_major_bus),\n    .core_busy_o            (shadow_outputs_d.core_busy)\n  );\n\n  // Register the shadow core outputs\n  always_ff @(posedge clk_i) begin\n    shadow_outputs_q <= shadow_outputs_d;\n  end\n\n  /////////////////////////\n  // Compare the outputs //\n  /////////////////////////\n\n  logic outputs_mismatch;\n\n  assign outputs_mismatch =\n    (enable_cmp_q != IbexMuBiOff) & (shadow_outputs_q != core_outputs_q[0]);\n  assign alert_major_internal_o\n    = outputs_mismatch | shadow_alert_major_internal | rst_shadow_cnt_err;\n  assign alert_major_bus_o      = shadow_alert_major_bus;\n  assign alert_minor_o          = shadow_alert_minor;\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n`define OP_L 15:0\n`define OP_H 31:16\n\n/**\n * Fast Multiplier and Division\n *\n * 16x16 kernel multiplier and Long Division\n */\n\n`include \"prim_assert.sv\"\n\nmodule ibex_multdiv_fast #(\n  parameter ibex_pkg::rv32m_e RV32M = ibex_pkg::RV32MFast\n  ) (\n  input  logic             clk_i,\n  input  logic             rst_ni,\n  input  logic             mult_en_i,  // dynamic enable signal, for FSM control\n  input  logic             div_en_i,   // dynamic enable signal, for FSM control\n  input  logic             mult_sel_i, // static decoder output, for data muxes\n  input  logic             div_sel_i,  // static decoder output, for data muxes\n  input  ibex_pkg::md_op_e operator_i,\n  input  logic  [1:0]      signed_mode_i,\n  input  logic [31:0]      op_a_i,\n  input  logic [31:0]      op_b_i,\n  input  logic [33:0]      alu_adder_ext_i,\n  input  logic [31:0]      alu_adder_i,\n  input  logic             equal_to_zero_i,\n  input  logic             data_ind_timing_i,\n\n  output logic [32:0]      alu_operand_a_o,\n  output logic [32:0]      alu_operand_b_o,\n\n  input  logic [33:0]      imd_val_q_i[2],\n  output logic [33:0]      imd_val_d_o[2],\n  output logic [1:0]       imd_val_we_o,\n\n  input  logic             multdiv_ready_id_i,\n\n  output logic [31:0]      multdiv_result_o,\n  output logic             valid_o\n);\n\n  import ibex_pkg::*;\n\n  // Both multiplier variants\n  logic signed [34:0] mac_res_signed;\n  logic        [34:0] mac_res_ext;\n  logic        [33:0] accum;\n  logic        sign_a, sign_b;\n  logic        mult_valid;\n  logic        signed_mult;\n\n  // Results that become intermediate value depending on whether mul or div is being calculated\n  logic [33:0] mac_res_d, op_remainder_d;\n  // Raw output of MAC calculation\n  logic [33:0] mac_res;\n\n  // Divider signals\n  logic        div_sign_a, div_sign_b;\n  logic        is_greater_equal;\n  logic        div_change_sign, rem_change_sign;\n  logic [31:0] one_shift;\n  logic [31:0] op_denominator_q;\n  logic [31:0] op_numerator_q;\n  logic [31:0] op_quotient_q;\n  logic [31:0] op_denominator_d;\n  logic [31:0] op_numerator_d;\n  logic [31:0] op_quotient_d;\n  logic [31:0] next_remainder;\n  logic [32:0] next_quotient;\n  logic [31:0] res_adder_h;\n  logic        div_valid;\n  logic [ 4:0] div_counter_q, div_counter_d;\n  logic        multdiv_en;\n  logic        mult_hold;\n  logic        div_hold;\n  logic        div_by_zero_d, div_by_zero_q;\n\n  logic        mult_en_internal;\n  logic        div_en_internal;\n\n  typedef enum logic [2:0] {\n    MD_IDLE, MD_ABS_A, MD_ABS_B, MD_COMP, MD_LAST, MD_CHANGE_SIGN, MD_FINISH\n  } md_fsm_e;\n  md_fsm_e md_state_q, md_state_d;\n\n  logic unused_mult_sel_i;\n  assign unused_mult_sel_i = mult_sel_i;\n\n  assign mult_en_internal = mult_en_i & ~mult_hold;\n  assign div_en_internal  = div_en_i & ~div_hold;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      div_counter_q    <= '0;\n      md_state_q       <= MD_IDLE;\n      op_numerator_q   <= '0;\n      op_quotient_q    <= '0;\n      div_by_zero_q    <= '0;\n    end else if (div_en_internal) begin\n      div_counter_q    <= div_counter_d;\n      op_numerator_q   <= op_numerator_d;\n      op_quotient_q    <= op_quotient_d;\n      md_state_q       <= md_state_d;\n      div_by_zero_q    <= div_by_zero_d;\n    end\n  end\n\n  `ASSERT_KNOWN(DivEnKnown, div_en_internal)\n  `ASSERT_KNOWN(MultEnKnown, mult_en_internal)\n  `ASSERT_KNOWN(MultDivEnKnown, multdiv_en)\n\n  assign multdiv_en = mult_en_internal | div_en_internal;\n\n  // Intermediate value register shared with ALU\n  assign imd_val_d_o[0] = div_sel_i ? op_remainder_d : mac_res_d;\n  assign imd_val_we_o[0] = multdiv_en;\n\n  assign imd_val_d_o[1] = {2'b0, op_denominator_d};\n  assign imd_val_we_o[1] = div_en_internal;\n  assign op_denominator_q = imd_val_q_i[1][31:0];\n  logic [1:0] unused_imd_val;\n  assign unused_imd_val = imd_val_q_i[1][33:32];\n  logic unused_mac_res_ext;\n  assign unused_mac_res_ext = mac_res_ext[34];\n\n  assign signed_mult      = (signed_mode_i != 2'b00);\n  assign multdiv_result_o = div_sel_i ? imd_val_q_i[0][31:0] : mac_res_d[31:0];\n\n  // The single cycle multiplier uses three 17 bit multipliers to compute MUL instructions in a\n  // single cycle and MULH instructions in two cycles.\n  if (RV32M == RV32MSingleCycle) begin : gen_mult_single_cycle\n\n    typedef enum logic {\n      MULL, MULH\n    } mult_fsm_e;\n    mult_fsm_e mult_state_q, mult_state_d;\n\n    logic signed [33:0] mult1_res, mult2_res, mult3_res;\n    logic [33:0]        mult1_res_uns;\n    logic [33:32]       unused_mult1_res_uns;\n    logic [15:0]        mult1_op_a, mult1_op_b;\n    logic [15:0]        mult2_op_a, mult2_op_b;\n    logic [15:0]        mult3_op_a, mult3_op_b;\n    logic               mult1_sign_a, mult1_sign_b;\n    logic               mult2_sign_a, mult2_sign_b;\n    logic               mult3_sign_a, mult3_sign_b;\n    logic [33:0]        summand1, summand2, summand3;\n\n    assign mult1_res = $signed({mult1_sign_a, mult1_op_a}) * $signed({mult1_sign_b, mult1_op_b});\n    assign mult2_res = $signed({mult2_sign_a, mult2_op_a}) * $signed({mult2_sign_b, mult2_op_b});\n    assign mult3_res = $signed({mult3_sign_a, mult3_op_a}) * $signed({mult3_sign_b, mult3_op_b});\n\n    assign mac_res_signed = $signed(summand1) + $signed(summand2) + $signed(summand3);\n\n    assign mult1_res_uns  = $unsigned(mult1_res);\n    assign mac_res_ext    = $unsigned(mac_res_signed);\n    assign mac_res        = mac_res_ext[33:0];\n\n    assign sign_a = signed_mode_i[0] & op_a_i[31];\n    assign sign_b = signed_mode_i[1] & op_b_i[31];\n\n    // The first two multipliers are only used in state 1 (MULL). We can assign them statically.\n    // al*bl\n    assign mult1_sign_a = 1'b0;\n    assign mult1_sign_b = 1'b0;\n    assign mult1_op_a = op_a_i[`OP_L];\n    assign mult1_op_b = op_b_i[`OP_L];\n\n    // al*bh\n    assign mult2_sign_a = 1'b0;\n    assign mult2_sign_b = sign_b;\n    assign mult2_op_a = op_a_i[`OP_L];\n    assign mult2_op_b = op_b_i[`OP_H];\n\n    // used in MULH\n    assign accum[17:0] = imd_val_q_i[0][33:16];\n    assign accum[33:18] = {16{signed_mult & imd_val_q_i[0][33]}};\n\n    always_comb begin\n      // Default values == MULL\n\n      // ah*bl\n      mult3_sign_a = sign_a;\n      mult3_sign_b = 1'b0;\n      mult3_op_a = op_a_i[`OP_H];\n      mult3_op_b = op_b_i[`OP_L];\n\n      summand1 = {18'h0, mult1_res_uns[`OP_H]};\n      summand2 = $unsigned(mult2_res);\n      summand3 = $unsigned(mult3_res);\n\n      // mac_res = A*B[47:16], mult1_res = A*B[15:0]\n      mac_res_d = {2'b0, mac_res[`OP_L], mult1_res_uns[`OP_L]};\n      mult_valid = mult_en_i;\n      mult_state_d = MULL;\n\n      mult_hold = 1'b0;\n\n      unique case (mult_state_q)\n\n        MULL: begin\n          if (operator_i != MD_OP_MULL) begin\n            mac_res_d = mac_res;\n            mult_valid = 1'b0;\n            mult_state_d = MULH;\n          end else begin\n            mult_hold = ~multdiv_ready_id_i;\n          end\n        end\n\n        MULH: begin\n          // ah*bh\n          mult3_sign_a = sign_a;\n          mult3_sign_b = sign_b;\n          mult3_op_a = op_a_i[`OP_H];\n          mult3_op_b = op_b_i[`OP_H];\n          mac_res_d = mac_res;\n\n          summand1 = '0;\n          summand2 = accum;\n          summand3 = $unsigned(mult3_res);\n\n          mult_state_d = MULL;\n          mult_valid = 1'b1;\n\n          mult_hold = ~multdiv_ready_id_i;\n        end\n\n        default: begin\n          mult_state_d = MULL;\n        end\n\n      endcase // mult_state_q\n    end\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        mult_state_q <= MULL;\n      end else begin\n        if (mult_en_internal) begin\n          mult_state_q <= mult_state_d;\n        end\n      end\n    end\n\n    assign unused_mult1_res_uns = mult1_res_uns[33:32];\n\n    // States must be knwon/valid.\n    `ASSERT_KNOWN(IbexMultStateKnown, mult_state_q)\n\n  // The fast multiplier uses one 17 bit multiplier to compute MUL instructions in 3 cycles\n  // and MULH instructions in 4 cycles.\n  end else begin : gen_mult_fast\n    logic [15:0] mult_op_a;\n    logic [15:0] mult_op_b;\n\n    typedef enum logic [1:0] {\n      ALBL, ALBH, AHBL, AHBH\n    } mult_fsm_e;\n    mult_fsm_e mult_state_q, mult_state_d;\n\n    // The 2 MSBs of mac_res_ext (mac_res_ext[34:33]) are always equal since:\n    // 1. The 2 MSBs of the multiplicants are always equal, and\n    // 2. The 16 MSBs of the addend (accum[33:18]) are always equal.\n    // Thus, it is safe to ignore mac_res_ext[34].\n    assign mac_res_signed =\n        $signed({sign_a, mult_op_a}) * $signed({sign_b, mult_op_b}) + $signed(accum);\n    assign mac_res_ext    = $unsigned(mac_res_signed);\n    assign mac_res        = mac_res_ext[33:0];\n\n    always_comb begin\n      mult_op_a    = op_a_i[`OP_L];\n      mult_op_b    = op_b_i[`OP_L];\n      sign_a       = 1'b0;\n      sign_b       = 1'b0;\n      accum        = imd_val_q_i[0];\n      mac_res_d    = mac_res;\n      mult_state_d = mult_state_q;\n      mult_valid   = 1'b0;\n      mult_hold    = 1'b0;\n\n      unique case (mult_state_q)\n\n        ALBL: begin\n          // al*bl\n          mult_op_a = op_a_i[`OP_L];\n          mult_op_b = op_b_i[`OP_L];\n          sign_a    = 1'b0;\n          sign_b    = 1'b0;\n          accum     = '0;\n          mac_res_d = mac_res;\n          mult_state_d = ALBH;\n        end\n\n        ALBH: begin\n          // al*bh<<16\n          mult_op_a = op_a_i[`OP_L];\n          mult_op_b = op_b_i[`OP_H];\n          sign_a    = 1'b0;\n          sign_b    = signed_mode_i[1] & op_b_i[31];\n          // result of AL*BL (in imd_val_q_i[0]) always unsigned with no carry\n          accum     = {18'b0, imd_val_q_i[0][31:16]};\n          if (operator_i == MD_OP_MULL) begin\n            mac_res_d = {2'b0, mac_res[`OP_L], imd_val_q_i[0][`OP_L]};\n          end else begin\n            // MD_OP_MULH\n            mac_res_d = mac_res;\n          end\n          mult_state_d = AHBL;\n        end\n\n        AHBL: begin\n          // ah*bl<<16\n          mult_op_a = op_a_i[`OP_H];\n          mult_op_b = op_b_i[`OP_L];\n          sign_a    = signed_mode_i[0] & op_a_i[31];\n          sign_b    = 1'b0;\n          if (operator_i == MD_OP_MULL) begin\n            accum        = {18'b0, imd_val_q_i[0][31:16]};\n            mac_res_d    = {2'b0, mac_res[15:0], imd_val_q_i[0][15:0]};\n            mult_valid   = 1'b1;\n\n            // Note no state transition will occur if mult_hold is set\n            mult_state_d = ALBL;\n            mult_hold    = ~multdiv_ready_id_i;\n          end else begin\n            accum        = imd_val_q_i[0];\n            mac_res_d    = mac_res;\n            mult_state_d = AHBH;\n          end\n        end\n\n        AHBH: begin\n          // only MD_OP_MULH here\n          // ah*bh\n          mult_op_a = op_a_i[`OP_H];\n          mult_op_b = op_b_i[`OP_H];\n          sign_a    = signed_mode_i[0] & op_a_i[31];\n          sign_b    = signed_mode_i[1] & op_b_i[31];\n          accum[17: 0]  = imd_val_q_i[0][33:16];\n          accum[33:18]  = {16{signed_mult & imd_val_q_i[0][33]}};\n          // result of AH*BL is not signed only if signed_mode_i == 2'b00\n          mac_res_d    = mac_res;\n          mult_valid   = 1'b1;\n\n          // Note no state transition will occur if mult_hold is set\n          mult_state_d = ALBL;\n          mult_hold    = ~multdiv_ready_id_i;\n        end\n        default: begin\n          mult_state_d = ALBL;\n        end\n      endcase // mult_state_q\n    end\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        mult_state_q <= ALBL;\n      end else begin\n        if (mult_en_internal) begin\n          mult_state_q <= mult_state_d;\n        end\n      end\n    end\n\n    // States must be knwon/valid.\n    `ASSERT_KNOWN(IbexMultStateKnown, mult_state_q)\n\n  end // gen_mult_fast\n\n  // Divider\n  assign res_adder_h    = alu_adder_ext_i[32:1];\n  logic [1:0] unused_alu_adder_ext;\n  assign unused_alu_adder_ext = {alu_adder_ext_i[33],alu_adder_ext_i[0]};\n\n  assign next_remainder = is_greater_equal ? res_adder_h[31:0] : imd_val_q_i[0][31:0];\n  assign next_quotient  = is_greater_equal ? {1'b0, op_quotient_q} | {1'b0, one_shift} :\n                                             {1'b0, op_quotient_q};\n\n  assign one_shift      = {31'b0, 1'b1} << div_counter_q;\n\n  // The adder in the ALU computes alu_operand_a_o + alu_operand_b_o which means\n  // Remainder - Divisor. If Remainder - Divisor >= 0, is_greater_equal is equal to 1,\n  // the next Remainder is Remainder - Divisor contained in res_adder_h and the\n  always_comb begin\n    if ((imd_val_q_i[0][31] ^ op_denominator_q[31]) == 1'b0) begin\n      is_greater_equal = (res_adder_h[31] == 1'b0);\n    end else begin\n      is_greater_equal = imd_val_q_i[0][31];\n    end\n  end\n\n  assign div_sign_a      = op_a_i[31] & signed_mode_i[0];\n  assign div_sign_b      = op_b_i[31] & signed_mode_i[1];\n  assign div_change_sign = (div_sign_a ^ div_sign_b) & ~div_by_zero_q;\n  assign rem_change_sign = div_sign_a;\n\n\n  always_comb begin\n    div_counter_d    = div_counter_q - 5'h1;\n    op_remainder_d   = imd_val_q_i[0];\n    op_quotient_d    = op_quotient_q;\n    md_state_d       = md_state_q;\n    op_numerator_d   = op_numerator_q;\n    op_denominator_d = op_denominator_q;\n    alu_operand_a_o  = {32'h0  , 1'b1};\n    alu_operand_b_o  = {~op_b_i, 1'b1};\n    div_valid        = 1'b0;\n    div_hold         = 1'b0;\n    div_by_zero_d    = div_by_zero_q;\n\n    unique case (md_state_q)\n      MD_IDLE: begin\n        if (operator_i == MD_OP_DIV) begin\n          // Check if the Denominator is 0\n          // quotient for division by 0 is specified to be -1\n          // Note with data-independent time option, the full divide operation will proceed as\n          // normal and will naturally return -1\n          op_remainder_d = '1;\n          // SEC_CM: CORE.DATA_REG_SW.SCA\n          md_state_d     = (!data_ind_timing_i && equal_to_zero_i) ? MD_FINISH : MD_ABS_A;\n          // Record that this is a div by zero to stop the sign change at the end of the\n          // division (in data_ind_timing mode).\n          div_by_zero_d  = equal_to_zero_i;\n        end else begin\n          // Check if the Denominator is 0\n          // remainder for division by 0 is specified to be the numerator (operand a)\n          // Note with data-independent time option, the full divide operation will proceed as\n          // normal and will naturally return operand a\n          op_remainder_d = {2'b0, op_a_i};\n          // SEC_CM: CORE.DATA_REG_SW.SCA\n          md_state_d     = (!data_ind_timing_i && equal_to_zero_i) ? MD_FINISH : MD_ABS_A;\n        end\n        // 0 - B = 0 iff B == 0\n        alu_operand_a_o  = {32'h0  , 1'b1};\n        alu_operand_b_o  = {~op_b_i, 1'b1};\n        div_counter_d    = 5'd31;\n      end\n\n      MD_ABS_A: begin\n        // quotient\n        op_quotient_d   = '0;\n        // A abs value\n        op_numerator_d  = div_sign_a ? alu_adder_i : op_a_i;\n        md_state_d      = MD_ABS_B;\n        div_counter_d   = 5'd31;\n        // ABS(A) = 0 - A\n        alu_operand_a_o = {32'h0  , 1'b1};\n        alu_operand_b_o = {~op_a_i, 1'b1};\n      end\n\n      MD_ABS_B: begin\n        // remainder\n        op_remainder_d   = { 33'h0, op_numerator_q[31]};\n        // B abs value\n        op_denominator_d = div_sign_b ? alu_adder_i : op_b_i;\n        md_state_d       = MD_COMP;\n        div_counter_d    = 5'd31;\n        // ABS(B) = 0 - B\n        alu_operand_a_o  = {32'h0  , 1'b1};\n        alu_operand_b_o  = {~op_b_i, 1'b1};\n      end\n\n      MD_COMP: begin\n        op_remainder_d  = {1'b0, next_remainder[31:0], op_numerator_q[div_counter_d]};\n        op_quotient_d   = next_quotient[31:0];\n        md_state_d      = (div_counter_q == 5'd1) ? MD_LAST : MD_COMP;\n        // Division\n        alu_operand_a_o = {imd_val_q_i[0][31:0], 1'b1}; // it contains the remainder\n        alu_operand_b_o = {~op_denominator_q[31:0], 1'b1};  // -denominator two's compliment\n      end\n\n      MD_LAST: begin\n        if (operator_i == MD_OP_DIV) begin\n          // this time we save the quotient in op_remainder_d (i.e. imd_val_q_i[0]) since\n          // we do not need anymore the remainder\n          op_remainder_d = {1'b0, next_quotient};\n        end else begin\n          // this time we do not save the quotient anymore since we need only the remainder\n          op_remainder_d = {2'b0, next_remainder[31:0]};\n        end\n        // Division\n        alu_operand_a_o  = {imd_val_q_i[0][31:0], 1'b1}; // it contains the remainder\n        alu_operand_b_o  = {~op_denominator_q[31:0], 1'b1};  // -denominator two's compliment\n\n        md_state_d = MD_CHANGE_SIGN;\n      end\n\n      MD_CHANGE_SIGN: begin\n        md_state_d  = MD_FINISH;\n        if (operator_i == MD_OP_DIV) begin\n          op_remainder_d = (div_change_sign) ? {2'h0, alu_adder_i} : imd_val_q_i[0];\n        end else begin\n          op_remainder_d = (rem_change_sign) ? {2'h0, alu_adder_i} : imd_val_q_i[0];\n        end\n        // ABS(Quotient) = 0 - Quotient (or Remainder)\n        alu_operand_a_o  = {32'h0  , 1'b1};\n        alu_operand_b_o  = {~imd_val_q_i[0][31:0], 1'b1};\n      end\n\n      MD_FINISH: begin\n        // Hold result until ID stage is ready to accept it\n        // Note no state transition will occur if div_hold is set\n        md_state_d = MD_IDLE;\n        div_hold   = ~multdiv_ready_id_i;\n        div_valid   = 1'b1;\n      end\n\n      default: begin\n        md_state_d = MD_IDLE;\n      end\n    endcase // md_state_q\n  end\n\n  assign valid_o = mult_valid | div_valid;\n\n  // States must be knwon/valid.\n  `ASSERT(IbexMultDivStateValid, md_state_q inside {\n      MD_IDLE, MD_ABS_A, MD_ABS_B, MD_COMP, MD_LAST, MD_CHANGE_SIGN, MD_FINISH})\n\n`ifdef FORMAL\n  `ifdef YOSYS\n    `include \"formal_tb_frag.svh\"\n  `endif\n`endif\n\nendmodule // ibex_mult\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Slow Multiplier and Division\n *\n * Baugh-Wooley multiplier and Long Division\n */\n\n`include \"prim_assert.sv\"\n\nmodule ibex_multdiv_slow\n(\n  input  logic             clk_i,\n  input  logic             rst_ni,\n  input  logic             mult_en_i,  // dynamic enable signal, for FSM control\n  input  logic             div_en_i,   // dynamic enable signal, for FSM control\n  input  logic             mult_sel_i, // static decoder output, for data muxes\n  input  logic             div_sel_i,  // static decoder output, for data muxes\n  input  ibex_pkg::md_op_e operator_i,\n  input  logic  [1:0]      signed_mode_i,\n  input  logic [31:0]      op_a_i,\n  input  logic [31:0]      op_b_i,\n  input  logic [33:0]      alu_adder_ext_i,\n  input  logic [31:0]      alu_adder_i,\n  input  logic             equal_to_zero_i,\n  input  logic             data_ind_timing_i,\n\n  output logic [32:0]      alu_operand_a_o,\n  output logic [32:0]      alu_operand_b_o,\n\n  input  logic [33:0]      imd_val_q_i[2],\n  output logic [33:0]      imd_val_d_o[2],\n  output logic  [1:0]      imd_val_we_o,\n\n  input  logic             multdiv_ready_id_i,\n\n  output logic [31:0]      multdiv_result_o,\n\n  output logic             valid_o\n);\n\n  import ibex_pkg::*;\n\n  typedef enum logic [2:0] {\n    MD_IDLE, MD_ABS_A, MD_ABS_B, MD_COMP, MD_LAST, MD_CHANGE_SIGN, MD_FINISH\n  } md_fsm_e;\n  md_fsm_e md_state_q, md_state_d;\n\n  logic [32:0] accum_window_q, accum_window_d;\n  logic        unused_imd_val0;\n  logic [ 1:0] unused_imd_val1;\n\n  logic [32:0] res_adder_l;\n  logic [32:0] res_adder_h;\n\n  logic [ 4:0] multdiv_count_q, multdiv_count_d;\n  logic [32:0] op_b_shift_q, op_b_shift_d;\n  logic [32:0] op_a_shift_q, op_a_shift_d;\n  logic [32:0] op_a_ext, op_b_ext;\n  logic [32:0] one_shift;\n  logic [32:0] op_a_bw_pp, op_a_bw_last_pp;\n  logic [31:0] b_0;\n  logic        sign_a, sign_b;\n  logic [32:0] next_quotient;\n  logic [31:0] next_remainder;\n  logic [31:0] op_numerator_q, op_numerator_d;\n  logic        is_greater_equal;\n  logic        div_change_sign, rem_change_sign;\n  logic        div_by_zero_d, div_by_zero_q;\n  logic        multdiv_hold;\n  logic        multdiv_en;\n\n   // (accum_window_q + op_a_shift_q)\n  assign res_adder_l = alu_adder_ext_i[32:0];\n   // (accum_window_q + op_a_shift_q)>>1\n  assign res_adder_h = alu_adder_ext_i[33:1];\n\n  /////////////////////\n  // ALU Operand MUX //\n  /////////////////////\n\n  // Intermediate value register shared with ALU\n  assign imd_val_d_o[0]  = {1'b0,accum_window_d};\n  assign imd_val_we_o[0] = ~multdiv_hold;\n  assign accum_window_q  = imd_val_q_i[0][32:0];\n  assign unused_imd_val0 = imd_val_q_i[0][33];\n\n  assign imd_val_d_o[1]  = {2'b00, op_numerator_d};\n  assign imd_val_we_o[1] = multdiv_en;\n  assign op_numerator_q  = imd_val_q_i[1][31:0];\n  assign unused_imd_val1 = imd_val_q_i[1][33:32];\n\n  always_comb begin\n    alu_operand_a_o = accum_window_q;\n\n    unique case (operator_i)\n\n      MD_OP_MULL: begin\n        alu_operand_b_o = op_a_bw_pp;\n      end\n\n      MD_OP_MULH: begin\n        alu_operand_b_o = (md_state_q == MD_LAST) ? op_a_bw_last_pp : op_a_bw_pp;\n      end\n\n      MD_OP_DIV,\n      MD_OP_REM: begin\n        unique case (md_state_q)\n          MD_IDLE: begin\n            // 0 - B = 0 iff B == 0\n            alu_operand_a_o = {32'h0  , 1'b1};\n            alu_operand_b_o = {~op_b_i, 1'b1};\n          end\n          MD_ABS_A: begin\n            // ABS(A) = 0 - A\n            alu_operand_a_o = {32'h0  , 1'b1};\n            alu_operand_b_o = {~op_a_i, 1'b1};\n          end\n          MD_ABS_B: begin\n            // ABS(B) = 0 - B\n            alu_operand_a_o = {32'h0  , 1'b1};\n            alu_operand_b_o = {~op_b_i, 1'b1};\n          end\n          MD_CHANGE_SIGN: begin\n            // ABS(Quotient) = 0 - Quotient (or Reminder)\n            alu_operand_a_o = {32'h0  , 1'b1};\n            alu_operand_b_o = {~accum_window_q[31:0], 1'b1};\n          end\n          default: begin\n            // Division\n            alu_operand_a_o = {accum_window_q[31:0], 1'b1}; // it contains the remainder\n            alu_operand_b_o = {~op_b_shift_q[31:0], 1'b1};  // -denominator two's compliment\n          end\n        endcase\n      end\n      default: begin\n        alu_operand_a_o = accum_window_q;\n        alu_operand_b_o = {~op_b_shift_q[31:0], 1'b1};\n      end\n    endcase\n  end\n\n  // Multiplier partial product calculation\n  assign b_0             = {32{op_b_shift_q[0]}};\n  assign op_a_bw_pp      = { ~(op_a_shift_q[32] & op_b_shift_q[0]),  (op_a_shift_q[31:0] & b_0) };\n  assign op_a_bw_last_pp = {  (op_a_shift_q[32] & op_b_shift_q[0]), ~(op_a_shift_q[31:0] & b_0) };\n\n  // Sign extend the input operands\n  assign sign_a   = op_a_i[31] & signed_mode_i[0];\n  assign sign_b   = op_b_i[31] & signed_mode_i[1];\n\n  assign op_a_ext = {sign_a, op_a_i};\n  assign op_b_ext = {sign_b, op_b_i};\n\n  // Divider calculations\n\n  // The adder in the ALU computes Remainder - Divisor. If Remainder - Divisor >= 0,\n  // is_greater_equal is true, the next Remainder is the subtraction result and the Quotient\n  // multdiv_count_q-th bit is set to 1.\n  assign is_greater_equal = (accum_window_q[31] == op_b_shift_q[31]) ?\n      ~res_adder_h[31] : accum_window_q[31];\n\n  assign one_shift      = {32'b0, 1'b1} << multdiv_count_q;\n\n  assign next_remainder = is_greater_equal ? res_adder_h[31:0]        : accum_window_q[31:0];\n  assign next_quotient  = is_greater_equal ? op_a_shift_q | one_shift : op_a_shift_q;\n\n  assign div_change_sign  = (sign_a ^ sign_b) & ~div_by_zero_q;\n  assign rem_change_sign  = sign_a;\n\n  always_comb begin\n    multdiv_count_d  = multdiv_count_q;\n    accum_window_d   = accum_window_q;\n    op_b_shift_d     = op_b_shift_q;\n    op_a_shift_d     = op_a_shift_q;\n    op_numerator_d   = op_numerator_q;\n    md_state_d       = md_state_q;\n    multdiv_hold     = 1'b0;\n    div_by_zero_d    = div_by_zero_q;\n    if (mult_sel_i || div_sel_i) begin\n      unique case (md_state_q)\n        MD_IDLE: begin\n          unique case (operator_i)\n            MD_OP_MULL: begin\n              op_a_shift_d   = op_a_ext << 1;\n              accum_window_d = {       ~(op_a_ext[32]   &     op_b_i[0]),\n                                         op_a_ext[31:0] & {32{op_b_i[0]}}  };\n              op_b_shift_d   = op_b_ext >> 1;\n              // Proceed with multiplication by 0/1 in data-independent time mode\n              // SEC_CM: CORE.DATA_REG_SW.SCA\n              md_state_d     = (!data_ind_timing_i && ((op_b_ext >> 1) == 0)) ? MD_LAST : MD_COMP;\n            end\n            MD_OP_MULH: begin\n              op_a_shift_d   = op_a_ext;\n              accum_window_d = { 1'b1, ~(op_a_ext[32]   &     op_b_i[0]),\n                                         op_a_ext[31:1] & {31{op_b_i[0]}}  };\n              op_b_shift_d   = op_b_ext >> 1;\n              md_state_d     = MD_COMP;\n            end\n            MD_OP_DIV: begin\n              // Check if the denominator is 0\n              // quotient for division by 0 is specified to be -1\n              // Note with data-independent time option, the full divide operation will proceed as\n              // normal and will naturally return -1\n              accum_window_d = {33{1'b1}};\n              // SEC_CM: CORE.DATA_REG_SW.SCA\n              md_state_d     = (!data_ind_timing_i && equal_to_zero_i) ? MD_FINISH : MD_ABS_A;\n              // Record that this is a div by zero to stop the sign change at the end of the\n              // division (in data_ind_timing mode).\n              div_by_zero_d  = equal_to_zero_i;\n            end\n            MD_OP_REM: begin\n              // Check if the denominator is 0\n              // remainder for division by 0 is specified to be the numerator (operand a)\n              // Note with data-independent time option, the full divide operation will proceed as\n              // normal and will naturally return operand a\n              accum_window_d = op_a_ext;\n              // SEC_CM: CORE.DATA_REG_SW.SCA\n              md_state_d     = (!data_ind_timing_i && equal_to_zero_i) ? MD_FINISH : MD_ABS_A;\n            end\n            default:;\n          endcase\n          multdiv_count_d   = 5'd31;\n        end\n\n        MD_ABS_A: begin\n          // quotient\n          op_a_shift_d   = '0;\n          // A abs value\n          op_numerator_d = sign_a ? alu_adder_i : op_a_i;\n          md_state_d     = MD_ABS_B;\n        end\n\n        MD_ABS_B: begin\n          // remainder\n          accum_window_d = {32'h0, op_numerator_q[31]};\n          // B abs value\n          op_b_shift_d   = sign_b ? {1'b0, alu_adder_i} : {1'b0, op_b_i};\n          md_state_d     = MD_COMP;\n        end\n\n        MD_COMP: begin\n          multdiv_count_d = multdiv_count_q - 5'h1;\n          unique case (operator_i)\n            MD_OP_MULL: begin\n              accum_window_d = res_adder_l;\n              op_a_shift_d   = op_a_shift_q << 1;\n              op_b_shift_d   = op_b_shift_q >> 1;\n              // Multiplication is complete once op_b is zero, unless in data_ind_timing mode where\n              // the maximum possible shift-add operations will be completed regardless of op_b\n              // SEC_CM: CORE.DATA_REG_SW.SCA\n              md_state_d     = ((!data_ind_timing_i && (op_b_shift_d == 0)) ||\n                                (multdiv_count_q == 5'd1)) ? MD_LAST : MD_COMP;\n            end\n            MD_OP_MULH: begin\n              accum_window_d = res_adder_h;\n              op_a_shift_d   = op_a_shift_q;\n              op_b_shift_d   = op_b_shift_q >> 1;\n              md_state_d     = (multdiv_count_q == 5'd1) ? MD_LAST : MD_COMP;\n            end\n            MD_OP_DIV,\n            MD_OP_REM: begin\n              accum_window_d = {next_remainder[31:0], op_numerator_q[multdiv_count_d]};\n              op_a_shift_d   = next_quotient;\n              md_state_d     = (multdiv_count_q == 5'd1) ? MD_LAST : MD_COMP;\n            end\n            default: ;\n          endcase\n        end\n\n        MD_LAST: begin\n          unique case (operator_i)\n            MD_OP_MULL: begin\n              accum_window_d = res_adder_l;\n\n              // Note no state transition will occur if multdiv_hold is set\n              md_state_d   = MD_IDLE;\n              multdiv_hold = ~multdiv_ready_id_i;\n            end\n            MD_OP_MULH: begin\n              accum_window_d = res_adder_l;\n              md_state_d     = MD_IDLE;\n\n              // Note no state transition will occur if multdiv_hold is set\n              md_state_d   = MD_IDLE;\n              multdiv_hold = ~multdiv_ready_id_i;\n            end\n            MD_OP_DIV: begin\n              // this time we save the quotient in accum_window_q since we do not need anymore the\n              // remainder\n              accum_window_d = next_quotient;\n              md_state_d     = MD_CHANGE_SIGN;\n            end\n            MD_OP_REM: begin\n              // this time we do not save the quotient anymore since we need only the remainder\n              accum_window_d = {1'b0, next_remainder[31:0]};\n              md_state_d     = MD_CHANGE_SIGN;\n            end\n            default: ;\n          endcase\n        end\n\n        MD_CHANGE_SIGN: begin\n          md_state_d = MD_FINISH;\n          unique case (operator_i)\n            MD_OP_DIV:\n              accum_window_d = div_change_sign ? {1'b0,alu_adder_i} : accum_window_q;\n            MD_OP_REM:\n              accum_window_d = rem_change_sign ? {1'b0,alu_adder_i} : accum_window_q;\n            default: ;\n          endcase\n        end\n\n        MD_FINISH: begin\n          // Note no state transition will occur if multdiv_hold is set\n          md_state_d   = MD_IDLE;\n          multdiv_hold = ~multdiv_ready_id_i;\n        end\n\n        default: begin\n          md_state_d = MD_IDLE;\n        end\n      endcase // md_state_q\n    end // (mult_sel_i || div_sel_i)\n  end\n\n  //////////////////////////////////////////\n  // Mutliplier / Divider state registers //\n  //////////////////////////////////////////\n\n  assign multdiv_en = (mult_en_i | div_en_i) & ~multdiv_hold;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      multdiv_count_q  <= 5'h0;\n      op_b_shift_q     <= 33'h0;\n      op_a_shift_q     <= 33'h0;\n      md_state_q       <= MD_IDLE;\n      div_by_zero_q    <= 1'b0;\n    end else if (multdiv_en) begin\n      multdiv_count_q  <= multdiv_count_d;\n      op_b_shift_q     <= op_b_shift_d;\n      op_a_shift_q     <= op_a_shift_d;\n      md_state_q       <= md_state_d;\n      div_by_zero_q    <= div_by_zero_d;\n    end\n  end\n\n  /////////////\n  // Outputs //\n  /////////////\n\n  assign valid_o = (md_state_q == MD_FINISH) |\n                   (md_state_q == MD_LAST &\n                   (operator_i == MD_OP_MULL |\n                    operator_i == MD_OP_MULH));\n\n  assign multdiv_result_o = div_en_i ? accum_window_q[31:0] : res_adder_l[31:0];\n\n  ////////////////\n  // Assertions //\n  ////////////////\n\n  // State must be valid.\n  `ASSERT(IbexMultDivStateValid, md_state_q inside {\n      MD_IDLE, MD_ABS_A, MD_ABS_B, MD_COMP, MD_LAST, MD_CHANGE_SIGN, MD_FINISH\n      }, clk_i, !rst_ni)\n\n`ifdef FORMAL\n  `ifdef YOSYS\n    `include \"formal_tb_frag.svh\"\n  `endif\n`endif\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2017 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Package with constants used by Ibex\n */\npackage ibex_pkg;\n\n  ////////////////\n  // IO Structs //\n  ////////////////\n\n  typedef struct packed {\n    logic [31:0] current_pc;\n    logic [31:0] next_pc;\n    logic [31:0] last_data_addr;\n    logic [31:0] exception_pc;\n    logic [31:0] exception_addr;\n  } crash_dump_t;\n\n  typedef struct packed {\n    logic        dummy_instr_id;\n    logic [4:0]  raddr_a;\n    logic [4:0]  waddr_a;\n    logic        we_a;\n    logic [4:0]  raddr_b;\n  } core2rf_t;\n\n  /////////////////////\n  // Parameter Enums //\n  /////////////////////\n\n  typedef enum integer {\n    RegFileFF    = 0,\n    RegFileFPGA  = 1,\n    RegFileLatch = 2\n  } regfile_e;\n\n  typedef enum integer {\n    RV32MNone        = 0,\n    RV32MSlow        = 1,\n    RV32MFast        = 2,\n    RV32MSingleCycle = 3\n  } rv32m_e;\n\n  typedef enum integer {\n    RV32BNone       = 0,\n    RV32BBalanced   = 1,\n    RV32BOTEarlGrey = 2,\n    RV32BFull       = 3\n  } rv32b_e;\n\n  /////////////\n  // Opcodes //\n  /////////////\n\n  typedef enum logic [6:0] {\n    OPCODE_LOAD     = 7'h03,\n    OPCODE_MISC_MEM = 7'h0f,\n    OPCODE_OP_IMM   = 7'h13,\n    OPCODE_AUIPC    = 7'h17,\n    OPCODE_STORE    = 7'h23,\n    OPCODE_OP       = 7'h33,\n    OPCODE_LUI      = 7'h37,\n    OPCODE_BRANCH   = 7'h63,\n    OPCODE_JALR     = 7'h67,\n    OPCODE_JAL      = 7'h6f,\n    OPCODE_SYSTEM   = 7'h73\n  } opcode_e;\n\n\n  ////////////////////\n  // ALU operations //\n  ////////////////////\n\n  typedef enum logic [6:0] {\n    // Arithmetics\n    ALU_ADD,\n    ALU_SUB,\n\n    // Logics\n    ALU_XOR,\n    ALU_OR,\n    ALU_AND,\n    // RV32B\n    ALU_XNOR,\n    ALU_ORN,\n    ALU_ANDN,\n\n    // Shifts\n    ALU_SRA,\n    ALU_SRL,\n    ALU_SLL,\n    // RV32B\n    ALU_SRO,\n    ALU_SLO,\n    ALU_ROR,\n    ALU_ROL,\n    ALU_GREV,\n    ALU_GORC,\n    ALU_SHFL,\n    ALU_UNSHFL,\n    ALU_XPERM_N,\n    ALU_XPERM_B,\n    ALU_XPERM_H,\n\n    // Address Calculations\n    // RV32B\n    ALU_SH1ADD,\n    ALU_SH2ADD,\n    ALU_SH3ADD,\n\n    // Comparisons\n    ALU_LT,\n    ALU_LTU,\n    ALU_GE,\n    ALU_GEU,\n    ALU_EQ,\n    ALU_NE,\n    // RV32B\n    ALU_MIN,\n    ALU_MINU,\n    ALU_MAX,\n    ALU_MAXU,\n\n    // Pack\n    // RV32B\n    ALU_PACK,\n    ALU_PACKU,\n    ALU_PACKH,\n\n    // Sign-Extend\n    // RV32B\n    ALU_SEXTB,\n    ALU_SEXTH,\n\n    // Bitcounting\n    // RV32B\n    ALU_CLZ,\n    ALU_CTZ,\n    ALU_CPOP,\n\n    // Set lower than\n    ALU_SLT,\n    ALU_SLTU,\n\n    // Ternary Bitmanip Operations\n    // RV32B\n    ALU_CMOV,\n    ALU_CMIX,\n    ALU_FSL,\n    ALU_FSR,\n\n    // Single-Bit Operations\n    // RV32B\n    ALU_BSET,\n    ALU_BCLR,\n    ALU_BINV,\n    ALU_BEXT,\n\n    // Bit Compress / Decompress\n    // RV32B\n    ALU_BCOMPRESS,\n    ALU_BDECOMPRESS,\n\n    // Bit Field Place\n    // RV32B\n    ALU_BFP,\n\n    // Carry-less Multiply\n    // RV32B\n    ALU_CLMUL,\n    ALU_CLMULR,\n    ALU_CLMULH,\n\n    // Cyclic Redundancy Check\n    ALU_CRC32_B,\n    ALU_CRC32C_B,\n    ALU_CRC32_H,\n    ALU_CRC32C_H,\n    ALU_CRC32_W,\n    ALU_CRC32C_W\n  } alu_op_e;\n\n  typedef enum logic [1:0] {\n    // Multiplier/divider\n    MD_OP_MULL,\n    MD_OP_MULH,\n    MD_OP_DIV,\n    MD_OP_REM\n  } md_op_e;\n\n\n  //////////////////////////////////\n  // Control and status registers //\n  //////////////////////////////////\n\n  // CSR operations\n  typedef enum logic [1:0] {\n    CSR_OP_READ,\n    CSR_OP_WRITE,\n    CSR_OP_SET,\n    CSR_OP_CLEAR\n  } csr_op_e;\n\n  // Privileged mode\n  typedef enum logic[1:0] {\n    PRIV_LVL_M = 2'b11,\n    PRIV_LVL_H = 2'b10,\n    PRIV_LVL_S = 2'b01,\n    PRIV_LVL_U = 2'b00\n  } priv_lvl_e;\n\n  // Constants for the dcsr.xdebugver fields\n  typedef enum logic[3:0] {\n    XDEBUGVER_NO     = 4'd0, // no external debug support\n    XDEBUGVER_STD    = 4'd4, // external debug according to RISC-V debug spec\n    XDEBUGVER_NONSTD = 4'd15 // debug not conforming to RISC-V debug spec\n  } x_debug_ver_e;\n\n  //////////////\n  // WB stage //\n  //////////////\n\n  // Type of instruction present in writeback stage\n  typedef enum logic[1:0] {\n    WB_INSTR_LOAD,  // Instruction is awaiting load data\n    WB_INSTR_STORE, // Instruction is awaiting store response\n    WB_INSTR_OTHER  // Instruction doesn't fit into above categories\n  } wb_instr_type_e;\n\n  //////////////\n  // ID stage //\n  //////////////\n\n  // Operand a selection\n  typedef enum logic[1:0] {\n    OP_A_REG_A,\n    OP_A_FWD,\n    OP_A_CURRPC,\n    OP_A_IMM\n  } op_a_sel_e;\n\n  // Immediate a selection\n  typedef enum logic {\n    IMM_A_Z,\n    IMM_A_ZERO\n  } imm_a_sel_e;\n\n  // Operand b selection\n  typedef enum logic {\n    OP_B_REG_B,\n    OP_B_IMM\n  } op_b_sel_e;\n\n  // Immediate b selection\n  typedef enum logic [2:0] {\n    IMM_B_I,\n    IMM_B_S,\n    IMM_B_B,\n    IMM_B_U,\n    IMM_B_J,\n    IMM_B_INCR_PC,\n    IMM_B_INCR_ADDR\n  } imm_b_sel_e;\n\n  // Regfile write data selection\n  typedef enum logic {\n    RF_WD_EX,\n    RF_WD_CSR\n  } rf_wd_sel_e;\n\n  // Controller FSM state encoding\n  typedef enum logic [3:0] {\n    RESET,\n    BOOT_SET,\n    WAIT_SLEEP,\n    SLEEP,\n    FIRST_FETCH,\n    DECODE,\n    FLUSH,\n    IRQ_TAKEN,\n    DBG_TAKEN_IF,\n    DBG_TAKEN_ID\n  } ctrl_fsm_e;\n\n  //////////////\n  // IF stage //\n  //////////////\n\n  // PC mux selection\n  typedef enum logic [2:0] {\n    PC_BOOT,\n    PC_JUMP,\n    PC_EXC,\n    PC_ERET,\n    PC_DRET,\n    PC_BP\n  } pc_sel_e;\n\n  // Exception PC mux selection\n  typedef enum logic [1:0] {\n    EXC_PC_EXC,\n    EXC_PC_IRQ,\n    EXC_PC_DBD,\n    EXC_PC_DBG_EXC // Exception while in debug mode\n  } exc_pc_sel_e;\n\n  // Interrupt requests\n  typedef struct packed {\n    logic        irq_software;\n    logic        irq_timer;\n    logic        irq_external;\n    logic [14:0] irq_fast; // 15 fast interrupts,\n                          // one interrupt is reserved for NMI (not visible through mip/mie)\n  } irqs_t;\n\n  typedef struct packed {\n    logic       irq_int;\n    logic       irq_ext;\n    logic [4:0] lower_cause;\n  } exc_cause_t;\n\n  localparam exc_cause_t ExcCauseIrqSoftwareM =\n    '{irq_ext: 1'b1, irq_int: 1'b0, lower_cause: 5'd03};\n  localparam exc_cause_t ExcCauseIrqTimerM =\n    '{irq_ext: 1'b1, irq_int: 1'b0, lower_cause: 5'd07};\n  localparam exc_cause_t ExcCauseIrqExternalM =\n    '{irq_ext: 1'b1, irq_int: 1'b0, lower_cause: 5'd11};\n  localparam exc_cause_t ExcCauseIrqNm =\n    '{irq_ext: 1'b1, irq_int: 1'b0, lower_cause: 5'd31};\n\n  localparam exc_cause_t ExcCauseInsnAddrMisa =\n    '{irq_ext: 1'b0, irq_int: 1'b0, lower_cause: 5'd00};\n  localparam exc_cause_t ExcCauseInstrAccessFault =\n    '{irq_ext: 1'b0, irq_int: 1'b0, lower_cause: 5'd01};\n  localparam exc_cause_t ExcCauseIllegalInsn =\n    '{irq_ext: 1'b0, irq_int: 1'b0, lower_cause: 5'd02};\n  localparam exc_cause_t ExcCauseBreakpoint =\n    '{irq_ext: 1'b0, irq_int: 1'b0, lower_cause: 5'd03};\n  localparam exc_cause_t ExcCauseLoadAccessFault  =\n    '{irq_ext: 1'b0, irq_int: 1'b0, lower_cause: 5'd05};\n  localparam exc_cause_t ExcCauseStoreAccessFault =\n    '{irq_ext: 1'b0, irq_int: 1'b0, lower_cause: 5'd07};\n  localparam exc_cause_t ExcCauseEcallUMode =\n    '{irq_ext: 1'b0, irq_int: 1'b0, lower_cause: 5'd08};\n  localparam exc_cause_t ExcCauseEcallMMode =\n    '{irq_ext: 1'b0, irq_int: 1'b0, lower_cause: 5'd11};\n\n  // Internal NMI cause\n  typedef enum logic [4:0] {\n    NMI_INT_CAUSE_ECC = 5'b0\n  } nmi_int_cause_e;\n\n  // Debug cause\n  typedef enum logic [2:0] {\n    DBG_CAUSE_NONE    = 3'h0,\n    DBG_CAUSE_EBREAK  = 3'h1,\n    DBG_CAUSE_TRIGGER = 3'h2,\n    DBG_CAUSE_HALTREQ = 3'h3,\n    DBG_CAUSE_STEP    = 3'h4\n  } dbg_cause_e;\n\n  // ICache constants\n  parameter int unsigned ADDR_W           = 32;\n  parameter int unsigned BUS_SIZE         = 32;\n  parameter int unsigned BUS_BYTES        = BUS_SIZE/8;\n  parameter int unsigned BUS_W            = $clog2(BUS_BYTES);\n  parameter int unsigned IC_SIZE_BYTES    = 4096;\n  parameter int unsigned IC_NUM_WAYS      = 2;\n  parameter int unsigned IC_LINE_SIZE     = 64;\n  parameter int unsigned IC_LINE_BYTES    = IC_LINE_SIZE/8;\n  parameter int unsigned IC_LINE_W        = $clog2(IC_LINE_BYTES);\n  parameter int unsigned IC_NUM_LINES     = IC_SIZE_BYTES / IC_NUM_WAYS / IC_LINE_BYTES;\n  parameter int unsigned IC_LINE_BEATS    = IC_LINE_BYTES / BUS_BYTES;\n  parameter int unsigned IC_LINE_BEATS_W  = $clog2(IC_LINE_BEATS);\n  parameter int unsigned IC_INDEX_W       = $clog2(IC_NUM_LINES);\n  parameter int unsigned IC_INDEX_HI      = IC_INDEX_W + IC_LINE_W - 1;\n  parameter int unsigned IC_TAG_SIZE      = ADDR_W - IC_INDEX_W - IC_LINE_W + 1; // 1 valid bit\n  parameter int unsigned IC_OUTPUT_BEATS  = (BUS_BYTES / 2); // number of halfwords\n  // ICache Scrambling Parameters\n  parameter int unsigned SCRAMBLE_KEY_W   = 128;\n  parameter int unsigned SCRAMBLE_NONCE_W = 64;\n\n  // PMP constants\n  parameter int unsigned PMP_MAX_REGIONS      = 16;\n  parameter int unsigned PMP_CFG_W            = 8;\n\n  // PMP acces type\n  parameter int unsigned PMP_I  = 0;\n  parameter int unsigned PMP_I2 = 1;\n  parameter int unsigned PMP_D  = 2;\n\n  typedef enum logic [1:0] {\n    PMP_ACC_EXEC    = 2'b00,\n    PMP_ACC_WRITE   = 2'b01,\n    PMP_ACC_READ    = 2'b10\n  } pmp_req_e;\n\n  // PMP cfg structures\n  typedef enum logic [1:0] {\n    PMP_MODE_OFF   = 2'b00,\n    PMP_MODE_TOR   = 2'b01,\n    PMP_MODE_NA4   = 2'b10,\n    PMP_MODE_NAPOT = 2'b11\n  } pmp_cfg_mode_e;\n\n  typedef struct packed {\n    logic          lock;\n    pmp_cfg_mode_e mode;\n    logic          exec;\n    logic          write;\n    logic          read;\n  } pmp_cfg_t;\n\n  // Machine Security Configuration (ePMP)\n  typedef struct packed {\n    logic rlb;  // Rule Locking Bypass\n    logic mmwp; // Machine Mode Whitelist Policy\n    logic mml;  // Machine Mode Lockdown\n  } pmp_mseccfg_t;\n\n  // CSRs\n  typedef enum logic[11:0] {\n    // Machine information\n    CSR_MVENDORID  = 12'hF11,\n    CSR_MARCHID    = 12'hF12,\n    CSR_MIMPID     = 12'hF13,\n    CSR_MHARTID    = 12'hF14,\n    CSR_MCONFIGPTR = 12'hF15,\n\n    // Machine trap setup\n    CSR_MSTATUS   = 12'h300,\n    CSR_MISA      = 12'h301,\n    CSR_MIE       = 12'h304,\n    CSR_MTVEC     = 12'h305,\n    CSR_MCOUNTEREN= 12'h306,\n    CSR_MSTATUSH  = 12'h310,\n\n    CSR_MENVCFG   = 12'h30A,\n    CSR_MENVCFGH  = 12'h31A,\n\n    // Machine trap handling\n    CSR_MSCRATCH  = 12'h340,\n    CSR_MEPC      = 12'h341,\n    CSR_MCAUSE    = 12'h342,\n    CSR_MTVAL     = 12'h343,\n    CSR_MIP       = 12'h344,\n\n    // Physical memory protection\n    CSR_PMPCFG0   = 12'h3A0,\n    CSR_PMPCFG1   = 12'h3A1,\n    CSR_PMPCFG2   = 12'h3A2,\n    CSR_PMPCFG3   = 12'h3A3,\n    CSR_PMPADDR0  = 12'h3B0,\n    CSR_PMPADDR1  = 12'h3B1,\n    CSR_PMPADDR2  = 12'h3B2,\n    CSR_PMPADDR3  = 12'h3B3,\n    CSR_PMPADDR4  = 12'h3B4,\n    CSR_PMPADDR5  = 12'h3B5,\n    CSR_PMPADDR6  = 12'h3B6,\n    CSR_PMPADDR7  = 12'h3B7,\n    CSR_PMPADDR8  = 12'h3B8,\n    CSR_PMPADDR9  = 12'h3B9,\n    CSR_PMPADDR10 = 12'h3BA,\n    CSR_PMPADDR11 = 12'h3BB,\n    CSR_PMPADDR12 = 12'h3BC,\n    CSR_PMPADDR13 = 12'h3BD,\n    CSR_PMPADDR14 = 12'h3BE,\n    CSR_PMPADDR15 = 12'h3BF,\n\n    CSR_SCONTEXT  = 12'h5A8,\n\n    // ePMP control\n    CSR_MSECCFG   = 12'h747,\n    CSR_MSECCFGH  = 12'h757,\n\n    // Debug trigger\n    CSR_TSELECT   = 12'h7A0,\n    CSR_TDATA1    = 12'h7A1,\n    CSR_TDATA2    = 12'h7A2,\n    CSR_TDATA3    = 12'h7A3,\n    CSR_MCONTEXT  = 12'h7A8,\n    CSR_MSCONTEXT = 12'h7AA,\n\n    // Debug/trace\n    CSR_DCSR      = 12'h7b0,\n    CSR_DPC       = 12'h7b1,\n\n    // Debug\n    CSR_DSCRATCH0 = 12'h7b2, // optional\n    CSR_DSCRATCH1 = 12'h7b3, // optional\n\n    // Machine Counter/Timers\n    CSR_MCOUNTINHIBIT  = 12'h320,\n    CSR_MHPMEVENT3     = 12'h323,\n    CSR_MHPMEVENT4     = 12'h324,\n    CSR_MHPMEVENT5     = 12'h325,\n    CSR_MHPMEVENT6     = 12'h326,\n    CSR_MHPMEVENT7     = 12'h327,\n    CSR_MHPMEVENT8     = 12'h328,\n    CSR_MHPMEVENT9     = 12'h329,\n    CSR_MHPMEVENT10    = 12'h32A,\n    CSR_MHPMEVENT11    = 12'h32B,\n    CSR_MHPMEVENT12    = 12'h32C,\n    CSR_MHPMEVENT13    = 12'h32D,\n    CSR_MHPMEVENT14    = 12'h32E,\n    CSR_MHPMEVENT15    = 12'h32F,\n    CSR_MHPMEVENT16    = 12'h330,\n    CSR_MHPMEVENT17    = 12'h331,\n    CSR_MHPMEVENT18    = 12'h332,\n    CSR_MHPMEVENT19    = 12'h333,\n    CSR_MHPMEVENT20    = 12'h334,\n    CSR_MHPMEVENT21    = 12'h335,\n    CSR_MHPMEVENT22    = 12'h336,\n    CSR_MHPMEVENT23    = 12'h337,\n    CSR_MHPMEVENT24    = 12'h338,\n    CSR_MHPMEVENT25    = 12'h339,\n    CSR_MHPMEVENT26    = 12'h33A,\n    CSR_MHPMEVENT27    = 12'h33B,\n    CSR_MHPMEVENT28    = 12'h33C,\n    CSR_MHPMEVENT29    = 12'h33D,\n    CSR_MHPMEVENT30    = 12'h33E,\n    CSR_MHPMEVENT31    = 12'h33F,\n    CSR_MCYCLE         = 12'hB00,\n    CSR_MINSTRET       = 12'hB02,\n    CSR_MHPMCOUNTER3   = 12'hB03,\n    CSR_MHPMCOUNTER4   = 12'hB04,\n    CSR_MHPMCOUNTER5   = 12'hB05,\n    CSR_MHPMCOUNTER6   = 12'hB06,\n    CSR_MHPMCOUNTER7   = 12'hB07,\n    CSR_MHPMCOUNTER8   = 12'hB08,\n    CSR_MHPMCOUNTER9   = 12'hB09,\n    CSR_MHPMCOUNTER10  = 12'hB0A,\n    CSR_MHPMCOUNTER11  = 12'hB0B,\n    CSR_MHPMCOUNTER12  = 12'hB0C,\n    CSR_MHPMCOUNTER13  = 12'hB0D,\n    CSR_MHPMCOUNTER14  = 12'hB0E,\n    CSR_MHPMCOUNTER15  = 12'hB0F,\n    CSR_MHPMCOUNTER16  = 12'hB10,\n    CSR_MHPMCOUNTER17  = 12'hB11,\n    CSR_MHPMCOUNTER18  = 12'hB12,\n    CSR_MHPMCOUNTER19  = 12'hB13,\n    CSR_MHPMCOUNTER20  = 12'hB14,\n    CSR_MHPMCOUNTER21  = 12'hB15,\n    CSR_MHPMCOUNTER22  = 12'hB16,\n    CSR_MHPMCOUNTER23  = 12'hB17,\n    CSR_MHPMCOUNTER24  = 12'hB18,\n    CSR_MHPMCOUNTER25  = 12'hB19,\n    CSR_MHPMCOUNTER26  = 12'hB1A,\n    CSR_MHPMCOUNTER27  = 12'hB1B,\n    CSR_MHPMCOUNTER28  = 12'hB1C,\n    CSR_MHPMCOUNTER29  = 12'hB1D,\n    CSR_MHPMCOUNTER30  = 12'hB1E,\n    CSR_MHPMCOUNTER31  = 12'hB1F,\n    CSR_MCYCLEH        = 12'hB80,\n    CSR_MINSTRETH      = 12'hB82,\n    CSR_MHPMCOUNTER3H  = 12'hB83,\n    CSR_MHPMCOUNTER4H  = 12'hB84,\n    CSR_MHPMCOUNTER5H  = 12'hB85,\n    CSR_MHPMCOUNTER6H  = 12'hB86,\n    CSR_MHPMCOUNTER7H  = 12'hB87,\n    CSR_MHPMCOUNTER8H  = 12'hB88,\n    CSR_MHPMCOUNTER9H  = 12'hB89,\n    CSR_MHPMCOUNTER10H = 12'hB8A,\n    CSR_MHPMCOUNTER11H = 12'hB8B,\n    CSR_MHPMCOUNTER12H = 12'hB8C,\n    CSR_MHPMCOUNTER13H = 12'hB8D,\n    CSR_MHPMCOUNTER14H = 12'hB8E,\n    CSR_MHPMCOUNTER15H = 12'hB8F,\n    CSR_MHPMCOUNTER16H = 12'hB90,\n    CSR_MHPMCOUNTER17H = 12'hB91,\n    CSR_MHPMCOUNTER18H = 12'hB92,\n    CSR_MHPMCOUNTER19H = 12'hB93,\n    CSR_MHPMCOUNTER20H = 12'hB94,\n    CSR_MHPMCOUNTER21H = 12'hB95,\n    CSR_MHPMCOUNTER22H = 12'hB96,\n    CSR_MHPMCOUNTER23H = 12'hB97,\n    CSR_MHPMCOUNTER24H = 12'hB98,\n    CSR_MHPMCOUNTER25H = 12'hB99,\n    CSR_MHPMCOUNTER26H = 12'hB9A,\n    CSR_MHPMCOUNTER27H = 12'hB9B,\n    CSR_MHPMCOUNTER28H = 12'hB9C,\n    CSR_MHPMCOUNTER29H = 12'hB9D,\n    CSR_MHPMCOUNTER30H = 12'hB9E,\n    CSR_MHPMCOUNTER31H = 12'hB9F,\n    CSR_CPUCTRLSTS     = 12'h7C0,\n    CSR_SECURESEED     = 12'h7C1\n  } csr_num_e;\n\n  // CSR pmp-related offsets\n  parameter logic [11:0] CSR_OFF_PMP_CFG  = 12'h3A0; // pmp_cfg  @ 12'h3a0 - 12'h3a3\n  parameter logic [11:0] CSR_OFF_PMP_ADDR = 12'h3B0; // pmp_addr @ 12'h3b0 - 12'h3bf\n\n  // CSR status bits\n  parameter int unsigned CSR_MSTATUS_MIE_BIT      = 3;\n  parameter int unsigned CSR_MSTATUS_MPIE_BIT     = 7;\n  parameter int unsigned CSR_MSTATUS_MPP_BIT_LOW  = 11;\n  parameter int unsigned CSR_MSTATUS_MPP_BIT_HIGH = 12;\n  parameter int unsigned CSR_MSTATUS_MPRV_BIT     = 17;\n  parameter int unsigned CSR_MSTATUS_TW_BIT       = 21;\n\n  // CSR machine ISA\n  parameter logic [1:0] CSR_MISA_MXL = 2'd1; // M-XLEN: XLEN in M-Mode for RV32\n\n  // CSR interrupt pending/enable bits\n  parameter int unsigned CSR_MSIX_BIT      = 3;\n  parameter int unsigned CSR_MTIX_BIT      = 7;\n  parameter int unsigned CSR_MEIX_BIT      = 11;\n  parameter int unsigned CSR_MFIX_BIT_LOW  = 16;\n  parameter int unsigned CSR_MFIX_BIT_HIGH = 30;\n\n  // CSR Machine Security Configuration bits\n  parameter int unsigned CSR_MSECCFG_MML_BIT  = 0;\n  parameter int unsigned CSR_MSECCFG_MMWP_BIT = 1;\n  parameter int unsigned CSR_MSECCFG_RLB_BIT  = 2;\n\n  // Vendor ID\n  // No JEDEC ID has been allocated to lowRISC so the value is 0 to indicate the field is not\n  // implemented\n  localparam logic [31:0] CSR_MVENDORID_VALUE  = 32'b0;\n\n  // Architecture ID\n  // Top bit is unset to indicate an open source project. The lower bits are an ID allocated by the\n  // RISC-V Foundation. Note this is allocated specifically to Ibex, should significant changes be\n  // made a different architecture ID should be supplied.\n  localparam logic [31:0] CSR_MARCHID_VALUE = {1'b0, 31'd22};\n\n  // Implementation ID\n  // 0 indicates this field is not implemeted. Ibex implementors may wish to indicate an RTL/netlist\n  // version here using their own unique encoding (e.g. 32 bits of the git hash of the implemented\n  // commit).\n  localparam logic [31:0] CSR_MIMPID_VALUE = 32'b0;\n\n  // Machine Configuration Pointer\n  // 0 indicates the configuration data structure does not eixst. Ibex implementors may wish to\n  // alter this to point to their system specific configuration data structure.\n  localparam logic [31:0] CSR_MCONFIGPTR_VALUE = 32'b0;\n\n  // These LFSR parameters have been generated with\n  // $ opentitan/util/design/gen-lfsr-seed.py --width 32 --seed 2480124384 --prefix \"\"\n  parameter int LfsrWidth = 32;\n  typedef logic [LfsrWidth-1:0] lfsr_seed_t;\n  typedef logic [LfsrWidth-1:0][$clog2(LfsrWidth)-1:0] lfsr_perm_t;\n  parameter lfsr_seed_t RndCnstLfsrSeedDefault = 32'hac533bf4;\n  parameter lfsr_perm_t RndCnstLfsrPermDefault = {\n    160'h1e35ecba467fd1b12e958152c04fa43878a8daed\n  };\n  parameter logic [SCRAMBLE_KEY_W-1:0]   RndCnstIbexKeyDefault =\n      128'h14e8cecae3040d5e12286bb3cc113298;\n  parameter logic [SCRAMBLE_NONCE_W-1:0] RndCnstIbexNonceDefault =\n      64'hf79780bc735f3843;\n\n  // Mult-bit signal used for security hardening. For non-secure implementation all bits other than\n  // the bottom bit are ignored.\n  parameter int IbexMuBiWidth = 4;\n  typedef logic [IbexMuBiWidth-1:0] ibex_mubi_t;\n\n  // Note that if adjusting these parameters it is assumed the bottom bit is set for On and unset\n  // for Off. This allows the use of IbexMuBiOn/IbexMuBiOff to work for both secure and non-secure\n  // Ibex. If this assumption is broken the RTL that uses ibex_mubi_t types such as the fetch_enable\n  // and core_busy signals within `ibex_core` may need adjusting.\n  parameter ibex_mubi_t IbexMuBiOn  = 4'b0101;\n  parameter ibex_mubi_t IbexMuBiOff = 4'b1010;\nendpackage\n"}
{"text": "// Copyright lowRISC contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n`include \"dv_fcov_macros.svh\"\n\nmodule ibex_pmp #(\n  // Granularity of NAPOT access,\n  // 0 = No restriction, 1 = 8 byte, 2 = 16 byte, 3 = 32 byte, etc.\n  parameter int unsigned PMPGranularity = 0,\n  // Number of access channels (e.g. i-side + d-side)\n  parameter int unsigned PMPNumChan     = 2,\n  // Number of implemented regions\n  parameter int unsigned PMPNumRegions  = 4\n) (\n  // Interface to CSRs\n  input  ibex_pkg::pmp_cfg_t      csr_pmp_cfg_i     [PMPNumRegions],\n  input  logic [33:0]             csr_pmp_addr_i    [PMPNumRegions],\n  input  ibex_pkg::pmp_mseccfg_t  csr_pmp_mseccfg_i,\n\n  input  ibex_pkg::priv_lvl_e     priv_mode_i    [PMPNumChan],\n  // Access checking channels\n  input  logic [33:0]             pmp_req_addr_i [PMPNumChan],\n  input  ibex_pkg::pmp_req_e      pmp_req_type_i [PMPNumChan],\n  output logic                    pmp_req_err_o  [PMPNumChan]\n\n);\n\n  import ibex_pkg::*;\n\n  // Access Checking Signals\n  logic [33:0]                                region_start_addr [PMPNumRegions];\n  logic [33:PMPGranularity+2]                 region_addr_mask  [PMPNumRegions];\n  logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_gt;\n  logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_lt;\n  logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_eq;\n  logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_match_all;\n  logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_basic_perm_check;\n  logic [PMPNumChan-1:0][PMPNumRegions-1:0]   region_perm_check;\n\n  ///////////////////////\n  // Functions for PMP //\n  ///////////////////////\n\n  // Flow of the PMP checking operation follows as below\n  //\n  // basic_perm_check ---> perm_check_wrapper ---> mml_perm_check/orig_perm_check ---/\n  //                                                                                 |\n  // region_match_all --------------------------------> access_fault_check <----------\n  //                                                            |\n  //                                                            \\--> pmp_req_err_o\n\n  // Compute permissions checks that apply when MSECCFG.MML is set. Added for Smepmp support.\n  function automatic logic mml_perm_check(ibex_pkg::pmp_cfg_t  region_csr_pmp_cfg,\n                                          ibex_pkg::pmp_req_e  pmp_req_type,\n                                          ibex_pkg::priv_lvl_e priv_mode,\n                                          logic                permission_check);\n    logic result = 1'b0;\n    logic unused_cfg = |region_csr_pmp_cfg.mode;\n\n    if (!region_csr_pmp_cfg.read && region_csr_pmp_cfg.write) begin\n      // Special-case shared regions where R = 0, W = 1\n      unique case ({region_csr_pmp_cfg.lock, region_csr_pmp_cfg.exec})\n        // Read/write in M, read only in S/U\n        2'b00: result =\n            (pmp_req_type == PMP_ACC_READ) |\n            ((pmp_req_type == PMP_ACC_WRITE) & (priv_mode == PRIV_LVL_M));\n        // Read/write in M/S/U\n        2'b01: result =\n            (pmp_req_type == PMP_ACC_READ) | (pmp_req_type == PMP_ACC_WRITE);\n        // Execute only on M/S/U\n        2'b10: result = (pmp_req_type == PMP_ACC_EXEC);\n        // Read/execute in M, execute only on S/U\n        2'b11: result =\n            (pmp_req_type == PMP_ACC_EXEC) |\n            ((pmp_req_type == PMP_ACC_READ) & (priv_mode == PRIV_LVL_M));\n        default: ;\n      endcase\n    end else begin\n      if (region_csr_pmp_cfg.read & region_csr_pmp_cfg.write &\n          region_csr_pmp_cfg.exec & region_csr_pmp_cfg.lock) begin\n        // Special-case shared read only region when R = 1, W = 1, X = 1, L = 1\n        result = pmp_req_type == PMP_ACC_READ;\n      end else begin\n        // Otherwise use basic permission check. Permission is always denied if in S/U mode and\n        // L is set or if in M mode and L is unset.\n        result = permission_check &\n                 (priv_mode == PRIV_LVL_M ? region_csr_pmp_cfg.lock : ~region_csr_pmp_cfg.lock);\n      end\n    end\n    return result;\n  endfunction\n\n  // Compute permissions checks that apply when MSECCFG.MML is unset. This is the original PMP\n  // behaviour before Smepmp was added.\n  function automatic logic orig_perm_check(logic                pmp_cfg_lock,\n                                           ibex_pkg::priv_lvl_e priv_mode,\n                                           logic                permission_check);\n      return (priv_mode == PRIV_LVL_M) ?\n          // For M-mode, any region which matches with the L-bit clear, or with sufficient\n          // access permissions will be allowed\n          (~pmp_cfg_lock | permission_check) :\n          // For other modes, the lock bit doesn't matter\n          permission_check;\n  endfunction\n\n  // A wrapper function in which it is decided which form of permission check function gets called\n  function automatic logic perm_check_wrapper(logic                csr_pmp_mseccfg_mml,\n                                              ibex_pkg::pmp_cfg_t  region_csr_pmp_cfg,\n                                              ibex_pkg::pmp_req_e  pmp_req_type,\n                                              ibex_pkg::priv_lvl_e priv_mode,\n                                              logic                permission_check);\n    return csr_pmp_mseccfg_mml ? mml_perm_check(region_csr_pmp_cfg,\n                                                pmp_req_type,\n                                                priv_mode,\n                                                permission_check) :\n                                 orig_perm_check(region_csr_pmp_cfg.lock,\n                                                 priv_mode,\n                                                 permission_check);\n  endfunction\n\n  // Access fault determination / prioritization\n  function automatic logic access_fault_check (logic                     csr_pmp_mseccfg_mmwp,\n                                               logic                     csr_pmp_mseccfg_mml,\n                                               ibex_pkg::pmp_req_e       pmp_req_type,\n                                               logic [PMPNumRegions-1:0] match_all,\n                                               ibex_pkg::priv_lvl_e      priv_mode,\n                                               logic [PMPNumRegions-1:0] final_perm_check);\n\n\n    // When MSECCFG.MMWP is set default deny always, otherwise allow for M-mode, deny for other\n    // modes. Also deny unmatched for M-mode whe MSECCFG.MML is set and request type is EXEC.\n    logic access_fail = csr_pmp_mseccfg_mmwp | (priv_mode != PRIV_LVL_M) |\n                        (csr_pmp_mseccfg_mml && (pmp_req_type == PMP_ACC_EXEC));\n    logic matched = 1'b0;\n\n    // PMP entries are statically prioritized, from 0 to N-1\n    // The lowest-numbered PMP entry which matches an address determines accessibility\n    for (int r = 0; r < PMPNumRegions; r++) begin\n      if (!matched && match_all[r]) begin\n        access_fail = ~final_perm_check[r];\n        matched = 1'b1;\n      end\n    end\n    return access_fail;\n  endfunction\n\n  // ---------------\n  // Access checking\n  // ---------------\n\n  for (genvar r = 0; r < PMPNumRegions; r++) begin : g_addr_exp\n    // Start address for TOR matching\n    if (r == 0) begin : g_entry0\n      assign region_start_addr[r] = (csr_pmp_cfg_i[r].mode == PMP_MODE_TOR) ? 34'h000000000 :\n                                                                              csr_pmp_addr_i[r];\n    end else begin : g_oth\n      assign region_start_addr[r] = (csr_pmp_cfg_i[r].mode == PMP_MODE_TOR) ? csr_pmp_addr_i[r-1] :\n                                                                              csr_pmp_addr_i[r];\n    end\n    // Address mask for NA matching\n    for (genvar b = PMPGranularity + 2; b < 34; b++) begin : g_bitmask\n      if (b == 2) begin : g_bit0\n        // Always mask bit 2 for NAPOT\n        assign region_addr_mask[r][b] = (csr_pmp_cfg_i[r].mode != PMP_MODE_NAPOT);\n      end else begin : g_others\n        // We will mask this bit if it is within the programmed granule\n        // i.e. addr = yyyy 0111\n        //                  ^\n        //                  | This bit pos is the top of the mask, all lower bits set\n        // thus mask = 1111 0000\n        if (PMPGranularity == 0) begin : g_region_addr_mask_zero_granularity\n          assign region_addr_mask[r][b] = (csr_pmp_cfg_i[r].mode != PMP_MODE_NAPOT) |\n                                          ~&csr_pmp_addr_i[r][b-1:2];\n        end else begin : g_region_addr_mask_other_granularity\n          assign region_addr_mask[r][b] = (csr_pmp_cfg_i[r].mode != PMP_MODE_NAPOT) |\n                                          ~&csr_pmp_addr_i[r][b-1:PMPGranularity+1];\n        end\n      end\n    end\n  end\n\n  for (genvar c = 0; c < PMPNumChan; c++) begin : g_access_check\n    for (genvar r = 0; r < PMPNumRegions; r++) begin : g_regions\n      // Comparators are sized according to granularity\n      assign region_match_eq[c][r] = (pmp_req_addr_i[c][33:PMPGranularity+2] &\n                                      region_addr_mask[r]) ==\n                                     (region_start_addr[r][33:PMPGranularity+2] &\n                                      region_addr_mask[r]);\n      assign region_match_gt[c][r] = pmp_req_addr_i[c][33:PMPGranularity+2] >\n                                     region_start_addr[r][33:PMPGranularity+2];\n      assign region_match_lt[c][r] = pmp_req_addr_i[c][33:PMPGranularity+2] <\n                                     csr_pmp_addr_i[r][33:PMPGranularity+2];\n\n      always_comb begin\n        region_match_all[c][r] = 1'b0;\n        unique case (csr_pmp_cfg_i[r].mode)\n          PMP_MODE_OFF:   region_match_all[c][r] = 1'b0;\n          PMP_MODE_NA4:   region_match_all[c][r] = region_match_eq[c][r];\n          PMP_MODE_NAPOT: region_match_all[c][r] = region_match_eq[c][r];\n          PMP_MODE_TOR: begin\n            region_match_all[c][r] = (region_match_eq[c][r] | region_match_gt[c][r]) &\n                                     region_match_lt[c][r];\n          end\n          default:        region_match_all[c][r] = 1'b0;\n        endcase\n      end\n\n      // Basic permission check compares cfg register only.\n      assign region_basic_perm_check[c][r] =\n          ((pmp_req_type_i[c] == PMP_ACC_EXEC)  & csr_pmp_cfg_i[r].exec) |\n          ((pmp_req_type_i[c] == PMP_ACC_WRITE) & csr_pmp_cfg_i[r].write) |\n          ((pmp_req_type_i[c] == PMP_ACC_READ)  & csr_pmp_cfg_i[r].read);\n\n      // Check specific required permissions since the behaviour is different\n      // between Smepmp implementation and original PMP.\n      assign region_perm_check[c][r] = perm_check_wrapper(csr_pmp_mseccfg_i.mml,\n                                                          csr_pmp_cfg_i[r],\n                                                          pmp_req_type_i[c],\n                                                          priv_mode_i[c],\n                                                          region_basic_perm_check[c][r]);\n\n      // Address bits below PMP granularity (which starts at 4 byte) are deliberately unused.\n      logic unused_sigs;\n      assign unused_sigs = ^{region_start_addr[r][PMPGranularity+2-1:0],\n                             pmp_req_addr_i[c][PMPGranularity+2-1:0]};\n    end\n\n    // Once the permission checks of the regions are done, decide if the access is\n    // denied by figuring out the matching region and its permission check.\n    assign pmp_req_err_o[c] = access_fault_check(csr_pmp_mseccfg_i.mmwp,\n                                                 csr_pmp_mseccfg_i.mml,\n                                                 pmp_req_type_i[c],\n                                                 region_match_all[c],\n                                                 priv_mode_i[c],\n                                                 region_perm_check[c]);\n\n    // Access fails check against one region but access allowed due to another higher-priority\n    // region.\n    `DV_FCOV_SIGNAL(logic, pmp_region_override,\n      ~pmp_req_err_o[c] & |(region_match_all[c] & ~region_perm_check[c]))\n  end\n\n  // RLB, rule locking bypass, is only relevant to ibex_cs_registers which controls writes to the\n  // PMP CSRs. Tie to unused signal here to prevent lint warnings.\n  logic unused_csr_pmp_mseccfg_rlb;\n  assign unused_csr_pmp_mseccfg_rlb = csr_pmp_mseccfg_i.rlb;\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n// Default reset values for PMP CSRs. Where the number of regions\n// (PMPNumRegions) is less than 16 the reset values for the higher numbered\n// regions are ignored.\n//\n// See the Ibex Reference Guide (Custom Reset Values under Physical Memory\n// Protection) for more information.\n\nlocalparam pmp_cfg_t pmp_cfg_rst[16] = '{\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 0\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 1\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 2\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 3\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 4\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 5\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 6\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 7\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 8\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 9\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 10\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 11\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 12\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 13\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}, // region 14\n  '{lock: 1'b0, mode: PMP_MODE_OFF, exec: 1'b0, write: 1'b0, read: 1'b0}  // region 15\n};\n\n// Addresses are given in byte granularity for readibility. A minimum of two\n// bits will be stripped off the bottom (PMPGranularity == 0) with more stripped\n// off at coarser granularities.\nlocalparam [33:0] pmp_addr_rst[16] = '{\n  34'h0, // region 0\n  34'h0, // region 1\n  34'h0, // region 2\n  34'h0, // region 3\n  34'h0, // region 4\n  34'h0, // region 5\n  34'h0, // region 6\n  34'h0, // region 7\n  34'h0, // region 8\n  34'h0, // region 9\n  34'h0, // region 10\n  34'h0, // region 11\n  34'h0, // region 12\n  34'h0, // region 13\n  34'h0, // region 14\n  34'h0  // region 15\n};\n\nlocalparam pmp_mseccfg_t pmp_mseccfg_rst = '{rlb : 1'b0, mmwp: 1'b0, mml: 1'b0};\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Prefetcher Buffer for 32 bit memory interface\n *\n * Prefetch Buffer that caches instructions. This cuts overly long critical\n * paths to the instruction cache.\n */\nmodule ibex_prefetch_buffer #(\n  parameter bit ResetAll        = 1'b0\n) (\n  input  logic        clk_i,\n  input  logic        rst_ni,\n\n  input  logic        req_i,\n\n  input  logic        branch_i,\n  input  logic [31:0] addr_i,\n\n  input  logic        ready_i,\n  output logic        valid_o,\n  output logic [31:0] rdata_o,\n  output logic [31:0] addr_o,\n  output logic        err_o,\n  output logic        err_plus2_o,\n\n  // goes to instruction memory / instruction cache\n  output logic        instr_req_o,\n  input  logic        instr_gnt_i,\n  output logic [31:0] instr_addr_o,\n  input  logic [31:0] instr_rdata_i,\n  input  logic        instr_err_i,\n  input  logic        instr_rvalid_i,\n\n  // Prefetch Buffer Status\n  output logic        busy_o\n);\n\n  localparam int unsigned NUM_REQS  = 2;\n\n  logic                valid_new_req, valid_req;\n  logic                valid_req_d, valid_req_q;\n  logic                discard_req_d, discard_req_q;\n  logic [NUM_REQS-1:0] rdata_outstanding_n, rdata_outstanding_s, rdata_outstanding_q;\n  logic [NUM_REQS-1:0] branch_discard_n, branch_discard_s, branch_discard_q;\n  logic [NUM_REQS-1:0] rdata_outstanding_rev;\n\n  logic [31:0]         stored_addr_d, stored_addr_q;\n  logic                stored_addr_en;\n  logic [31:0]         fetch_addr_d, fetch_addr_q;\n  logic                fetch_addr_en;\n  logic [31:0]         instr_addr, instr_addr_w_aligned;\n\n  logic                fifo_valid;\n  logic [31:0]         fifo_addr;\n  logic                fifo_ready;\n  logic                fifo_clear;\n  logic [NUM_REQS-1:0] fifo_busy;\n\n  ////////////////////////////\n  // Prefetch buffer status //\n  ////////////////////////////\n\n  assign busy_o = (|rdata_outstanding_q) | instr_req_o;\n\n  //////////////////////////////////////////////\n  // Fetch fifo - consumes addresses and data //\n  //////////////////////////////////////////////\n\n  // A branch will invalidate any previously fetched instructions.\n  // Note that the FENCE.I instruction relies on this flushing behaviour on branch. If it is\n  // altered the FENCE.I implementation may require changes.\n  assign fifo_clear = branch_i;\n\n  // Reversed version of rdata_outstanding_q which can be overlaid with fifo fill state\n  for (genvar i = 0; i < NUM_REQS; i++) begin : gen_rd_rev\n    assign rdata_outstanding_rev[i] = rdata_outstanding_q[NUM_REQS-1-i];\n  end\n\n  // The fifo is ready to accept a new request if it is not full - including space reserved for\n  // requests already outstanding.\n  // Overlay the fifo fill state with the outstanding requests to see if there is space.\n  assign fifo_ready = ~&(fifo_busy | rdata_outstanding_rev);\n\n  ibex_fetch_fifo #(\n    .NUM_REQS (NUM_REQS),\n    .ResetAll (ResetAll)\n  ) fifo_i (\n      .clk_i                 ( clk_i             ),\n      .rst_ni                ( rst_ni            ),\n\n      .clear_i               ( fifo_clear        ),\n      .busy_o                ( fifo_busy         ),\n\n      .in_valid_i            ( fifo_valid        ),\n      .in_addr_i             ( fifo_addr         ),\n      .in_rdata_i            ( instr_rdata_i     ),\n      .in_err_i              ( instr_err_i       ),\n\n      .out_valid_o           ( valid_o           ),\n      .out_ready_i           ( ready_i           ),\n      .out_rdata_o           ( rdata_o           ),\n      .out_addr_o            ( addr_o            ),\n      .out_err_o             ( err_o             ),\n      .out_err_plus2_o       ( err_plus2_o       )\n  );\n\n  //////////////\n  // Requests //\n  //////////////\n\n  // Make a new request any time there is space in the FIFO, and space in the request queue\n  assign valid_new_req = req_i & (fifo_ready | branch_i) &\n                         ~rdata_outstanding_q[NUM_REQS-1];\n\n  assign valid_req = valid_req_q | valid_new_req;\n\n  // Hold the request stable for requests that didn't get granted\n  assign valid_req_d = valid_req & ~instr_gnt_i;\n\n  // Record whether an outstanding bus request is cancelled by a branch\n  assign discard_req_d = valid_req_q & (branch_i | discard_req_q);\n\n  ////////////////\n  // Fetch addr //\n  ////////////////\n\n  // Two addresses are tracked in the prefetch buffer:\n  // 1. stored_addr_q - This is the address issued on the bus. It stays stable until\n  //                    the request is granted.\n  // 2. fetch_addr_q  - This is our next address to fetch from. It is updated on branches to\n  //                    capture the new address, and then for each new request issued.\n  // A third address is tracked in the fetch FIFO itself:\n  // 3. instr_addr_q  - This is the address at the head of the FIFO, efectively our oldest fetched\n  //                    address. This address is updated on branches, and does its own increment\n  //                    each time the FIFO is popped.\n\n  // 1. stored_addr_q\n\n  // Only update stored_addr_q for new ungranted requests\n  assign stored_addr_en = valid_new_req & ~valid_req_q & ~instr_gnt_i;\n\n  // Store whatever address was issued on the bus\n  assign stored_addr_d = instr_addr;\n\n  // CPU resets with a branch, so no need to reset these addresses\n  if (ResetAll) begin : g_stored_addr_ra\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        stored_addr_q <= '0;\n      end else if (stored_addr_en) begin\n        stored_addr_q <= stored_addr_d;\n      end\n    end\n  end else begin : g_stored_addr_nr\n    always_ff @(posedge clk_i) begin\n      if (stored_addr_en) begin\n        stored_addr_q <= stored_addr_d;\n      end\n    end\n  end\n  // 2. fetch_addr_q\n\n  // Update on a branch or as soon as a request is issued\n  assign fetch_addr_en = branch_i | (valid_new_req & ~valid_req_q);\n\n  assign fetch_addr_d = (branch_i ? addr_i : {fetch_addr_q[31:2], 2'b00}) +\n                        // Current address + 4\n                        {{29{1'b0}},(valid_new_req & ~valid_req_q),2'b00};\n\n  if (ResetAll) begin : g_fetch_addr_ra\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        fetch_addr_q <= '0;\n      end else if (fetch_addr_en) begin\n        fetch_addr_q <= fetch_addr_d;\n      end\n    end\n  end else begin : g_fetch_addr_nr\n    always_ff @(posedge clk_i) begin\n      if (fetch_addr_en) begin\n        fetch_addr_q <= fetch_addr_d;\n      end\n    end\n  end\n\n  // Address mux\n  assign instr_addr = valid_req_q ? stored_addr_q :\n                      branch_i    ? addr_i :\n                                    fetch_addr_q;\n\n  assign instr_addr_w_aligned = {instr_addr[31:2], 2'b00};\n\n  ///////////////////////////////\n  // Request outstanding queue //\n  ///////////////////////////////\n\n  for (genvar i = 0; i < NUM_REQS; i++) begin : g_outstanding_reqs\n    // Request 0 (always the oldest outstanding request)\n    if (i == 0) begin : g_req0\n      // A request becomes outstanding once granted, and is cleared once the rvalid is received.\n      // Outstanding requests shift down the queue towards entry 0.\n      assign rdata_outstanding_n[i] = (valid_req & instr_gnt_i) |\n                                      rdata_outstanding_q[i];\n      // If a branch is received at any point while a request is outstanding, it must be tracked\n      // to ensure we discard the data once received\n      assign branch_discard_n[i]    = (valid_req & instr_gnt_i & discard_req_d) |\n                                      (branch_i & rdata_outstanding_q[i]) |\n                                      branch_discard_q[i];\n\n    end else begin : g_reqtop\n    // Entries > 0 consider the FIFO fill state to calculate their next state (by checking\n    // whether the previous entry is valid)\n\n      assign rdata_outstanding_n[i] = (valid_req & instr_gnt_i &\n                                       rdata_outstanding_q[i-1]) |\n                                      rdata_outstanding_q[i];\n      assign branch_discard_n[i]    = (valid_req & instr_gnt_i & discard_req_d &\n                                       rdata_outstanding_q[i-1]) |\n                                      (branch_i & rdata_outstanding_q[i]) |\n                                      branch_discard_q[i];\n    end\n  end\n\n  // Shift the entries down on each instr_rvalid_i\n  assign rdata_outstanding_s = instr_rvalid_i ? {1'b0,rdata_outstanding_n[NUM_REQS-1:1]} :\n                                                rdata_outstanding_n;\n  assign branch_discard_s    = instr_rvalid_i ? {1'b0,branch_discard_n[NUM_REQS-1:1]} :\n                                                branch_discard_n;\n\n  // Push a new entry to the FIFO once complete (and not cancelled by a branch)\n  assign fifo_valid = instr_rvalid_i & ~branch_discard_q[0];\n\n  assign fifo_addr = addr_i;\n\n  ///////////////\n  // Registers //\n  ///////////////\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      valid_req_q          <= 1'b0;\n      discard_req_q        <= 1'b0;\n      rdata_outstanding_q  <= 'b0;\n      branch_discard_q     <= 'b0;\n    end else begin\n      valid_req_q          <= valid_req_d;\n      discard_req_q        <= discard_req_d;\n      rdata_outstanding_q  <= rdata_outstanding_s;\n      branch_discard_q     <= branch_discard_s;\n    end\n  end\n\n  /////////////\n  // Outputs //\n  /////////////\n\n  assign instr_req_o  = valid_req;\n  assign instr_addr_o = instr_addr_w_aligned;\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * RISC-V register file\n *\n * Register file with 31 or 15x 32 bit wide registers. Register 0 is fixed to 0.\n * This register file is based on flip flops. Use this register file when\n * targeting FPGA synthesis or Verilator simulation.\n */\nmodule ibex_register_file_ff #(\n  parameter bit                   RV32E             = 0,\n  parameter int unsigned          DataWidth         = 32,\n  parameter bit                   DummyInstructions = 0,\n  parameter bit                   WrenCheck         = 0,\n  parameter bit                   RdataMuxCheck     = 0,\n  parameter logic [DataWidth-1:0] WordZeroVal       = '0\n) (\n  // Clock and Reset\n  input  logic                 clk_i,\n  input  logic                 rst_ni,\n\n  input  logic                 test_en_i,\n  input  logic                 dummy_instr_id_i,\n  input  logic                 dummy_instr_wb_i,\n\n  //Read port R1\n  input  logic [4:0]           raddr_a_i,\n  output logic [DataWidth-1:0] rdata_a_o,\n\n  //Read port R2\n  input  logic [4:0]           raddr_b_i,\n  output logic [DataWidth-1:0] rdata_b_o,\n\n\n  // Write port W1\n  input  logic [4:0]           waddr_a_i,\n  input  logic [DataWidth-1:0] wdata_a_i,\n  input  logic                 we_a_i,\n\n  // This indicates whether spurious WE or non-one-hot encoded raddr are detected.\n  output logic                 err_o\n);\n\n  localparam int unsigned ADDR_WIDTH = RV32E ? 4 : 5;\n  localparam int unsigned NUM_WORDS  = 2**ADDR_WIDTH;\n\n  logic [DataWidth-1:0] rf_reg   [NUM_WORDS];\n  logic [NUM_WORDS-1:0] we_a_dec;\n\n  logic oh_raddr_a_err, oh_raddr_b_err, oh_we_err;\n\n  always_comb begin : we_a_decoder\n    for (int unsigned i = 0; i < NUM_WORDS; i++) begin\n      we_a_dec[i] = (waddr_a_i == 5'(i)) ? we_a_i : 1'b0;\n    end\n  end\n\n  // SEC_CM: DATA_REG_SW.GLITCH_DETECT\n  // This checks for spurious WE strobes on the regfile.\n  if (WrenCheck) begin : gen_wren_check\n    // Buffer the decoded write enable bits so that the checker\n    // is not optimized into the address decoding logic.\n    logic [NUM_WORDS-1:0] we_a_dec_buf;\n    prim_buf #(\n      .Width(NUM_WORDS)\n    ) u_prim_buf (\n      .in_i(we_a_dec),\n      .out_o(we_a_dec_buf)\n    );\n\n    prim_onehot_check #(\n      .AddrWidth(ADDR_WIDTH),\n      .AddrCheck(1),\n      .EnableCheck(1)\n    ) u_prim_onehot_check (\n      .clk_i,\n      .rst_ni,\n      .oh_i(we_a_dec_buf),\n      .addr_i(waddr_a_i),\n      .en_i(we_a_i),\n      .err_o(oh_we_err)\n    );\n  end else begin : gen_no_wren_check\n    logic unused_strobe;\n    assign unused_strobe = we_a_dec[0]; // this is never read from in this case\n    assign oh_we_err = 1'b0;\n  end\n\n  // No flops for R0 as it's hard-wired to 0\n  for (genvar i = 1; i < NUM_WORDS; i++) begin : g_rf_flops\n    logic [DataWidth-1:0] rf_reg_q;\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        rf_reg_q <= WordZeroVal;\n      end else if (we_a_dec[i]) begin\n        rf_reg_q <= wdata_a_i;\n      end\n    end\n\n    assign rf_reg[i] = rf_reg_q;\n  end\n\n  // With dummy instructions enabled, R0 behaves as a real register but will always return 0 for\n  // real instructions.\n  if (DummyInstructions) begin : g_dummy_r0\n    // SEC_CM: CTRL_FLOW.UNPREDICTABLE\n    logic                 we_r0_dummy;\n    logic [DataWidth-1:0] rf_r0_q;\n\n    // Write enable for dummy R0 register (waddr_a_i will always be 0 for dummy instructions)\n    assign we_r0_dummy = we_a_i & dummy_instr_wb_i;\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        rf_r0_q <= WordZeroVal;\n      end else if (we_r0_dummy) begin\n        rf_r0_q <= wdata_a_i;\n      end\n    end\n\n    // Output the dummy data for dummy instructions, otherwise R0 reads as zero\n    assign rf_reg[0] = dummy_instr_id_i ? rf_r0_q : WordZeroVal;\n\n  end else begin : g_normal_r0\n    logic unused_dummy_instr;\n    assign unused_dummy_instr = dummy_instr_id_i ^ dummy_instr_wb_i;\n\n    // R0 is nil\n    assign rf_reg[0] = WordZeroVal;\n  end\n\n  if (RdataMuxCheck) begin : gen_rdata_mux_check\n    // Encode raddr_a/b into one-hot encoded signals.\n    logic [NUM_WORDS-1:0] raddr_onehot_a, raddr_onehot_b;\n    logic [NUM_WORDS-1:0] raddr_onehot_a_buf, raddr_onehot_b_buf;\n    prim_onehot_enc #(\n      .OneHotWidth(NUM_WORDS)\n    ) u_prim_onehot_enc_raddr_a (\n      .in_i  (raddr_a_i),\n      .en_i  (1'b1),\n      .out_o (raddr_onehot_a)\n    );\n\n    prim_onehot_enc #(\n      .OneHotWidth(NUM_WORDS)\n    ) u_prim_onehot_enc_raddr_b (\n      .in_i  (raddr_b_i),\n      .en_i  (1'b1),\n      .out_o (raddr_onehot_b)\n    );\n\n    // Buffer the one-hot encoded signals so that the checkers\n    // are not optimized.\n    prim_buf #(\n      .Width(NUM_WORDS)\n    ) u_prim_buf_raddr_a (\n      .in_i (raddr_onehot_a),\n      .out_o(raddr_onehot_a_buf)\n    );\n\n    prim_buf #(\n      .Width(NUM_WORDS)\n    ) u_prim_buf_raddr_b (\n      .in_i (raddr_onehot_b),\n      .out_o(raddr_onehot_b_buf)\n    );\n\n    // SEC_CM: DATA_REG_SW.GLITCH_DETECT\n    // Check the one-hot encoded signals for glitches.\n    prim_onehot_check #(\n      .AddrWidth(ADDR_WIDTH),\n      .OneHotWidth(NUM_WORDS),\n      .AddrCheck(1),\n      // When AddrCheck=1 also EnableCheck needs to be 1.\n      .EnableCheck(1)\n    ) u_prim_onehot_check_raddr_a (\n      .clk_i,\n      .rst_ni,\n      .oh_i   (raddr_onehot_a_buf),\n      .addr_i (raddr_a_i),\n      // Set enable=1 as address is always valid.\n      .en_i   (1'b1),\n      .err_o  (oh_raddr_a_err)\n    );\n\n    prim_onehot_check #(\n      .AddrWidth(ADDR_WIDTH),\n      .OneHotWidth(NUM_WORDS),\n      .AddrCheck(1),\n      // When AddrCheck=1 also EnableCheck needs to be 1.\n      .EnableCheck(1)\n    ) u_prim_onehot_check_raddr_b (\n      .clk_i,\n      .rst_ni,\n      .oh_i   (raddr_onehot_b_buf),\n      .addr_i (raddr_b_i),\n      // Set enable=1 as address is always valid.\n      .en_i   (1'b1),\n      .err_o  (oh_raddr_b_err)\n    );\n\n    // MUX register to rdata_a/b_o according to raddr_a/b_onehot.\n    prim_onehot_mux  #(\n      .Width(DataWidth),\n      .Inputs(NUM_WORDS)\n    ) u_rdata_a_mux (\n      .clk_i,\n      .rst_ni,\n      .in_i  (rf_reg),\n      .sel_i (raddr_onehot_a),\n      .out_o (rdata_a_o)\n    );\n\n    prim_onehot_mux  #(\n      .Width(DataWidth),\n      .Inputs(NUM_WORDS)\n    ) u_rdata_b_mux (\n      .clk_i,\n      .rst_ni,\n      .in_i  (rf_reg),\n      .sel_i (raddr_onehot_b),\n      .out_o (rdata_b_o)\n    );\n  end else begin : gen_no_rdata_mux_check\n    assign rdata_a_o = rf_reg[raddr_a_i];\n    assign rdata_b_o = rf_reg[raddr_b_i];\n    assign oh_raddr_a_err = 1'b0;\n    assign oh_raddr_b_err = 1'b0;\n  end\n\n  assign err_o = oh_raddr_a_err || oh_raddr_b_err || oh_we_err;\n\n  // Signal not used in FF register file\n  logic unused_test_en;\n  assign unused_test_en = test_en_i;\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * RISC-V register file\n *\n * Register file with 31 or 15x 32 bit wide registers. Register 0 is fixed to 0.\n *\n * This register file is designed to make FPGA synthesis tools infer RAM primitives. For Xilinx\n * FPGA architectures, it will produce RAM32M primitives. Other vendors have not yet been tested.\n */\nmodule ibex_register_file_fpga #(\n    parameter bit                   RV32E             = 0,\n    parameter int unsigned          DataWidth         = 32,\n    parameter bit                   DummyInstructions = 0,\n    parameter bit                   WrenCheck         = 0,\n    parameter bit                   RdataMuxCheck     = 0,\n    parameter logic [DataWidth-1:0] WordZeroVal       = '0\n) (\n  // Clock and Reset\n  input  logic                 clk_i,\n  input  logic                 rst_ni,\n\n  input  logic                 test_en_i,\n  input  logic                 dummy_instr_id_i,\n  input  logic                 dummy_instr_wb_i,\n\n  //Read port R1\n  input  logic [          4:0] raddr_a_i,\n  output logic [DataWidth-1:0] rdata_a_o,\n  //Read port R2\n  input  logic [          4:0] raddr_b_i,\n  output logic [DataWidth-1:0] rdata_b_o,\n  // Write port W1\n  input  logic [          4:0] waddr_a_i,\n  input  logic [DataWidth-1:0] wdata_a_i,\n  input  logic                 we_a_i,\n\n  // This indicates whether spurious WE or non-one-hot encoded raddr are detected.\n  output logic                 err_o\n);\n\n  localparam int ADDR_WIDTH = RV32E ? 4 : 5;\n  localparam int NUM_WORDS = 2 ** ADDR_WIDTH;\n\n  logic [DataWidth-1:0] mem[NUM_WORDS];\n  logic we; // write enable if writing to any register other than R0\n\n  logic [DataWidth-1:0] mem_o_a, mem_o_b;\n\n  // WE strobe and one-hot encoded raddr alert.\n  logic oh_raddr_a_err, oh_raddr_b_err, oh_we_err;\n  assign err_o = oh_raddr_a_err || oh_raddr_b_err || oh_we_err;\n\n  if (RdataMuxCheck) begin : gen_rdata_mux_check\n    // Encode raddr_a/b into one-hot encoded signals.\n    logic [NUM_WORDS-1:0] raddr_onehot_a, raddr_onehot_b;\n    logic [NUM_WORDS-1:0] raddr_onehot_a_buf, raddr_onehot_b_buf;\n    prim_onehot_enc #(\n      .OneHotWidth(NUM_WORDS)\n    ) u_prim_onehot_enc_raddr_a (\n      .in_i  (raddr_a_i),\n      .en_i  (1'b1),\n      .out_o (raddr_onehot_a)\n    );\n\n    prim_onehot_enc #(\n      .OneHotWidth(NUM_WORDS)\n    ) u_prim_onehot_enc_raddr_b (\n      .in_i  (raddr_b_i),\n      .en_i  (1'b1),\n      .out_o (raddr_onehot_b)\n    );\n\n    // Buffer the one-hot encoded signals so that the checkers\n    // are not optimized.\n    prim_buf #(\n      .Width(NUM_WORDS)\n    ) u_prim_buf_raddr_a (\n      .in_i (raddr_onehot_a),\n      .out_o(raddr_onehot_a_buf)\n    );\n\n    prim_buf #(\n      .Width(NUM_WORDS)\n    ) u_prim_buf_raddr_b (\n      .in_i (raddr_onehot_b),\n      .out_o(raddr_onehot_b_buf)\n    );\n\n    // SEC_CM: DATA_REG_SW.GLITCH_DETECT\n    // Check the one-hot encoded signals for glitches.\n    prim_onehot_check #(\n      .AddrWidth(ADDR_WIDTH),\n      .OneHotWidth(NUM_WORDS),\n      .AddrCheck(1),\n      // When AddrCheck=1 also EnableCheck needs to be 1.\n      .EnableCheck(1)\n    ) u_prim_onehot_check_raddr_a (\n      .clk_i,\n      .rst_ni,\n      .oh_i   (raddr_onehot_a_buf),\n      .addr_i (raddr_a_i),\n      // Set enable=1 as address is always valid.\n      .en_i   (1'b1),\n      .err_o  (oh_raddr_a_err)\n    );\n\n    prim_onehot_check #(\n      .AddrWidth(ADDR_WIDTH),\n      .OneHotWidth(NUM_WORDS),\n      .AddrCheck(1),\n      // When AddrCheck=1 also EnableCheck needs to be 1.\n      .EnableCheck(1)\n    ) u_prim_onehot_check_raddr_b (\n      .clk_i,\n      .rst_ni,\n      .oh_i   (raddr_onehot_b_buf),\n      .addr_i (raddr_b_i),\n      // Set enable=1 as address is always valid.\n      .en_i   (1'b1),\n      .err_o  (oh_raddr_b_err)\n    );\n\n    // MUX register to rdata_a/b_o according to raddr_a/b_onehot.\n    prim_onehot_mux  #(\n      .Width(DataWidth),\n      .Inputs(NUM_WORDS)\n    ) u_rdata_a_mux (\n      .clk_i,\n      .rst_ni,\n      .in_i  (mem),\n      .sel_i (raddr_onehot_a),\n      .out_o (mem_o_a)\n    );\n\n    prim_onehot_mux  #(\n      .Width(DataWidth),\n      .Inputs(NUM_WORDS)\n    ) u_rdata_b_mux (\n      .clk_i,\n      .rst_ni,\n      .in_i  (mem),\n      .sel_i (raddr_onehot_b),\n      .out_o (mem_o_b)\n    );\n\n    assign rdata_a_o = (raddr_a_i == '0) ? '0 : mem_o_a;\n    assign rdata_b_o = (raddr_b_i == '0) ? '0 : mem_o_b;\n  end else begin : gen_no_rdata_mux_check\n    // async_read a\n    assign rdata_a_o = (raddr_a_i == '0) ? '0 : mem[raddr_a_i];\n\n    // async_read b\n    assign rdata_b_o = (raddr_b_i == '0) ? '0 : mem[raddr_b_i];\n  end\n\n  // we select\n  assign we = (waddr_a_i == '0) ? 1'b0 : we_a_i;\n\n  // SEC_CM: DATA_REG_SW.GLITCH_DETECT\n  // This checks for spurious WE strobes on the regfile.\n  if (WrenCheck) begin : gen_wren_check\n    // Since the FPGA uses a memory macro, there is only one write-enable strobe to check.\n    assign oh_we_err = we && !we_a_i;\n  end else begin : gen_no_wren_check\n    assign oh_we_err = 1'b0;\n  end\n\n  // Note that the SystemVerilog LRM requires variables on the LHS of assignments within\n  // \"always_ff\" to not be written to by any other process. However, to enable the initialization\n  // of the inferred RAM32M primitives with non-zero values, below \"initial\" procedure is needed.\n  // Therefore, we use \"always\" instead of the generally preferred \"always_ff\" for the synchronous\n  // write procedure.\n  always @(posedge clk_i) begin : sync_write\n    if (we == 1'b1) begin\n      mem[waddr_a_i] <= wdata_a_i;\n    end\n  end : sync_write\n\n  // Make sure we initialize the BRAM with the correct register reset value.\n  initial begin\n    for (int k = 0; k < NUM_WORDS; k++) begin\n      mem[k] = WordZeroVal;\n    end\n  end\n\n  // Reset not used in this register file version\n  logic unused_rst_ni;\n  assign unused_rst_ni = rst_ni;\n\n  // Dummy instruction changes not relevant for FPGA implementation\n  logic unused_dummy_instr;\n  assign unused_dummy_instr = dummy_instr_id_i ^ dummy_instr_wb_i;\n  // Test enable signal not used in FPGA implementation\n  logic unused_test_en;\n  assign unused_test_en = test_en_i;\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * RISC-V register file\n *\n * Register file with 31 or 15x 32 bit wide registers. Register 0 is fixed to 0.\n * This register file is based on latches and is thus smaller than the flip-flop\n * based RF. It requires a target technology-specific clock gating cell. Use this\n * register file when targeting ASIC synthesis or event-based simulators.\n */\nmodule ibex_register_file_latch #(\n  parameter bit                   RV32E             = 0,\n  parameter int unsigned          DataWidth         = 32,\n  parameter bit                   DummyInstructions = 0,\n  parameter bit                   WrenCheck         = 0,\n  parameter bit                   RdataMuxCheck     = 0,\n  parameter logic [DataWidth-1:0] WordZeroVal       = '0\n) (\n  // Clock and Reset\n  input  logic                 clk_i,\n  input  logic                 rst_ni,\n\n  input  logic                 test_en_i,\n  input  logic                 dummy_instr_id_i,\n  input  logic                 dummy_instr_wb_i,\n\n  //Read port R1\n  input  logic [4:0]           raddr_a_i,\n  output logic [DataWidth-1:0] rdata_a_o,\n\n  //Read port R2\n  input  logic [4:0]           raddr_b_i,\n  output logic [DataWidth-1:0] rdata_b_o,\n\n  // Write port W1\n  input  logic [4:0]           waddr_a_i,\n  input  logic [DataWidth-1:0] wdata_a_i,\n  input  logic                 we_a_i,\n\n  // This indicates whether spurious WE or non-one-hot encoded raddr are detected.\n  output logic                 err_o\n);\n\n  localparam int unsigned ADDR_WIDTH = RV32E ? 4 : 5;\n  localparam int unsigned NUM_WORDS  = 2**ADDR_WIDTH;\n\n  logic [DataWidth-1:0] mem[NUM_WORDS];\n\n  logic [NUM_WORDS-1:0] waddr_onehot_a;\n\n  logic oh_raddr_a_err, oh_raddr_b_err, oh_we_err;\n\n  logic [NUM_WORDS-1:1] mem_clocks;\n  logic [DataWidth-1:0] wdata_a_q;\n\n  // internal addresses\n  logic [ADDR_WIDTH-1:0] raddr_a_int, raddr_b_int, waddr_a_int;\n\n  assign raddr_a_int = raddr_a_i[ADDR_WIDTH-1:0];\n  assign raddr_b_int = raddr_b_i[ADDR_WIDTH-1:0];\n  assign waddr_a_int = waddr_a_i[ADDR_WIDTH-1:0];\n\n  logic clk_int;\n\n  assign err_o = oh_raddr_a_err || oh_raddr_b_err || oh_we_err;\n\n  //////////\n  // READ //\n  //////////\n  if (RdataMuxCheck) begin : gen_rdata_mux_check\n    // Encode raddr_a/b into one-hot encoded signals.\n    logic [NUM_WORDS-1:0] raddr_onehot_a, raddr_onehot_b;\n    logic [NUM_WORDS-1:0] raddr_onehot_a_buf, raddr_onehot_b_buf;\n    prim_onehot_enc #(\n      .OneHotWidth(NUM_WORDS)\n    ) u_prim_onehot_enc_raddr_a (\n      .in_i  (raddr_a_int),\n      .en_i  (1'b1),\n      .out_o (raddr_onehot_a)\n    );\n\n    prim_onehot_enc #(\n      .OneHotWidth(NUM_WORDS)\n    ) u_prim_onehot_enc_raddr_b (\n      .in_i  (raddr_b_int),\n      .en_i  (1'b1),\n      .out_o (raddr_onehot_b)\n    );\n\n    // Buffer the one-hot encoded signals so that the checkers\n    // are not optimized.\n    prim_buf #(\n      .Width(NUM_WORDS)\n    ) u_prim_buf_raddr_a (\n      .in_i(raddr_onehot_a),\n      .out_o(raddr_onehot_a_buf)\n    );\n\n    prim_buf #(\n      .Width(NUM_WORDS)\n    ) u_prim_buf_raddr_b (\n      .in_i(raddr_onehot_b),\n      .out_o(raddr_onehot_b_buf)\n    );\n\n    // SEC_CM: DATA_REG_SW.GLITCH_DETECT\n    // Check the one-hot encoded signals for glitches.\n    prim_onehot_check #(\n      .AddrWidth(ADDR_WIDTH),\n      .OneHotWidth(NUM_WORDS),\n      .AddrCheck(1),\n      // When AddrCheck=1 also EnableCheck needs to be 1.\n      .EnableCheck(1)\n    ) u_prim_onehot_check_raddr_a (\n      .clk_i,\n      .rst_ni,\n      .oh_i   (raddr_onehot_a_buf),\n      .addr_i (raddr_b_int),\n      // Set enable=1 as address is always valid.\n      .en_i   (1'b1),\n      .err_o  (oh_raddr_a_err)\n    );\n\n    prim_onehot_check #(\n      .AddrWidth(ADDR_WIDTH),\n      .OneHotWidth(NUM_WORDS),\n      .AddrCheck(1),\n      // When AddrCheck=1 also EnableCheck needs to be 1.\n      .EnableCheck(1)\n    ) u_prim_onehot_check_raddr_b (\n      .clk_i,\n      .rst_ni,\n      .oh_i   (raddr_onehot_b_buf),\n      .addr_i (raddr_b_int),\n      // Set enable=1 as address is always valid.\n      .en_i   (1'b1),\n      .err_o  (oh_raddr_b_err)\n    );\n\n    // MUX register to rdata_a/b_o according to raddr_a/b_onehot.\n    prim_onehot_mux  #(\n      .Width(DataWidth),\n      .Inputs(NUM_WORDS)\n    ) u_rdata_a_mux (\n      .clk_i,\n      .rst_ni,\n      .in_i  (mem),\n      .sel_i (raddr_onehot_a),\n      .out_o (rdata_a_o)\n    );\n\n    prim_onehot_mux  #(\n      .Width(DataWidth),\n      .Inputs(NUM_WORDS)\n    ) u_rdata_b_mux (\n      .clk_i,\n      .rst_ni,\n      .in_i  (mem),\n      .sel_i (raddr_onehot_b),\n      .out_o (rdata_b_o)\n    );\n  end else begin : gen_no_rdata_mux_check\n    assign rdata_a_o = mem[raddr_a_int];\n    assign rdata_b_o = mem[raddr_b_int];\n    assign oh_raddr_a_err = 1'b0;\n    assign oh_raddr_b_err = 1'b0;\n  end\n\n  ///////////\n  // WRITE //\n  ///////////\n  // Global clock gating\n  prim_clock_gating cg_we_global (\n      .clk_i     ( clk_i     ),\n      .en_i      ( we_a_i    ),\n      .test_en_i ( test_en_i ),\n      .clk_o     ( clk_int   )\n  );\n\n  // Sample input data\n  // Use clk_int here, since otherwise we don't want to write anything anyway.\n  always_ff @(posedge clk_int or negedge rst_ni) begin : sample_wdata\n    if (!rst_ni) begin\n      wdata_a_q   <= WordZeroVal;\n    end else begin\n      if (we_a_i) begin\n        wdata_a_q <= wdata_a_i;\n      end\n    end\n  end\n\n  // Write address decoding\n  always_comb begin : wad\n    for (int i = 0; i < NUM_WORDS; i++) begin : wad_word_iter\n      if (we_a_i && (waddr_a_int == 5'(i))) begin\n        waddr_onehot_a[i] = 1'b1;\n      end else begin\n        waddr_onehot_a[i] = 1'b0;\n      end\n    end\n  end\n\n  // SEC_CM: DATA_REG_SW.GLITCH_DETECT\n  // This checks for spurious WE strobes on the regfile.\n  if (WrenCheck) begin : gen_wren_check\n    // Buffer the decoded write enable bits so that the checker\n    // is not optimized into the address decoding logic.\n    logic [NUM_WORDS-1:0] waddr_onehot_a_buf;\n    prim_buf #(\n      .Width(NUM_WORDS)\n    ) u_prim_buf (\n      .in_i(waddr_onehot_a),\n      .out_o(waddr_onehot_a_buf)\n    );\n\n    prim_onehot_check #(\n      .AddrWidth(ADDR_WIDTH),\n      .AddrCheck(1),\n      .EnableCheck(1)\n    ) u_prim_onehot_check (\n      .clk_i,\n      .rst_ni,\n      .oh_i(waddr_onehot_a_buf),\n      .addr_i(waddr_a_i),\n      .en_i(we_a_i),\n      .err_o(oh_we_err)\n    );\n  end else begin : gen_no_wren_check\n    logic unused_strobe;\n    assign unused_strobe = waddr_onehot_a[0]; // this is never read from in this case\n    assign oh_we_err = 1'b0;\n  end\n\n  // Individual clock gating (if integrated clock-gating cells are available)\n  for (genvar x = 1; x < NUM_WORDS; x++) begin : gen_cg_word_iter\n    prim_clock_gating cg_i (\n        .clk_i     ( clk_int           ),\n        .en_i      ( waddr_onehot_a[x] ),\n        .test_en_i ( test_en_i         ),\n        .clk_o     ( mem_clocks[x]     )\n    );\n  end\n\n  // Actual write operation:\n  // Generate the sequential process for the NUM_WORDS words of the memory.\n  // The process is synchronized with the clocks mem_clocks[i], i = 1, ..., NUM_WORDS-1.\n  for (genvar i = 1; i < NUM_WORDS; i++) begin : g_rf_latches\n    always_latch begin\n      if (mem_clocks[i]) begin\n        mem[i] = wdata_a_q;\n      end\n    end\n  end\n\n  // With dummy instructions enabled, R0 behaves as a real register but will always return 0 for\n  // real instructions.\n  if (DummyInstructions) begin : g_dummy_r0\n    // SEC_CM: CTRL_FLOW.UNPREDICTABLE\n    logic                 we_r0_dummy;\n    logic                 r0_clock;\n    logic [DataWidth-1:0] mem_r0;\n\n    // Write enable for dummy R0 register (waddr_a_i will always be 0 for dummy instructions)\n    assign we_r0_dummy = we_a_i & dummy_instr_wb_i;\n\n    // R0 clock gate\n    prim_clock_gating cg_i (\n        .clk_i     ( clk_int     ),\n        .en_i      ( we_r0_dummy ),\n        .test_en_i ( test_en_i   ),\n        .clk_o     ( r0_clock    )\n    );\n\n    always_latch begin : latch_wdata\n      if (r0_clock) begin\n        mem_r0 = wdata_a_q;\n      end\n    end\n\n    // Output the dummy data for dummy instructions, otherwise R0 reads as zero\n    assign mem[0] = dummy_instr_id_i ? mem_r0 : WordZeroVal;\n\n  end else begin : g_normal_r0\n    logic unused_dummy_instr;\n    assign unused_dummy_instr = dummy_instr_id_i ^ dummy_instr_wb_i;\n\n    assign mem[0] = WordZeroVal;\n  end\n\n`ifdef VERILATOR\n  initial begin\n    $display(\"Latch-based register file not supported for Verilator simulation\");\n    $fatal;\n  end\n`endif\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n`ifdef RISCV_FORMAL\n  `define RVFI\n`endif\n\n`include \"prim_assert.sv\"\n\n/**\n * Top level module of the ibex RISC-V core\n */\nmodule ibex_top import ibex_pkg::*; #(\n  parameter bit          PMPEnable        = 1'b0,\n  parameter int unsigned PMPGranularity   = 0,\n  parameter int unsigned PMPNumRegions    = 4,\n  parameter int unsigned MHPMCounterNum   = 0,\n  parameter int unsigned MHPMCounterWidth = 40,\n  parameter bit          RV32E            = 1'b0,\n  parameter rv32m_e      RV32M            = RV32MFast,\n  parameter rv32b_e      RV32B            = RV32BNone,\n  parameter regfile_e    RegFile          = RegFileFF,\n  parameter bit          BranchTargetALU  = 1'b0,\n  parameter bit          WritebackStage   = 1'b0,\n  parameter bit          ICache           = 1'b0,\n  parameter bit          ICacheECC        = 1'b0,\n  parameter bit          BranchPredictor  = 1'b0,\n  parameter bit          DbgTriggerEn     = 1'b0,\n  parameter int unsigned DbgHwBreakNum    = 1,\n  parameter bit          SecureIbex       = 1'b0,\n  parameter bit          ICacheScramble   = 1'b0,\n  parameter lfsr_seed_t  RndCnstLfsrSeed  = RndCnstLfsrSeedDefault,\n  parameter lfsr_perm_t  RndCnstLfsrPerm  = RndCnstLfsrPermDefault,\n  parameter int unsigned DmHaltAddr       = 32'h1A110800,\n  parameter int unsigned DmExceptionAddr  = 32'h1A110808,\n  // Default seed and nonce for scrambling\n  parameter logic [SCRAMBLE_KEY_W-1:0]   RndCnstIbexKey   = RndCnstIbexKeyDefault,\n  parameter logic [SCRAMBLE_NONCE_W-1:0] RndCnstIbexNonce = RndCnstIbexNonceDefault\n) (\n  // Clock and Reset\n  input  logic                         clk_i,\n  input  logic                         rst_ni,\n\n  input  logic                         test_en_i,     // enable all clock gates for testing\n  input  prim_ram_1p_pkg::ram_1p_cfg_t ram_cfg_i,\n\n  input  logic [31:0]                  hart_id_i,\n  input  logic [31:0]                  boot_addr_i,\n\n  // Instruction memory interface\n  output logic                         instr_req_o,\n  input  logic                         instr_gnt_i,\n  input  logic                         instr_rvalid_i,\n  output logic [31:0]                  instr_addr_o,\n  input  logic [31:0]                  instr_rdata_i,\n  input  logic [6:0]                   instr_rdata_intg_i,\n  input  logic                         instr_err_i,\n\n  // Data memory interface\n  output logic                         data_req_o,\n  input  logic                         data_gnt_i,\n  input  logic                         data_rvalid_i,\n  output logic                         data_we_o,\n  output logic [3:0]                   data_be_o,\n  output logic [31:0]                  data_addr_o,\n  output logic [31:0]                  data_wdata_o,\n  output logic [6:0]                   data_wdata_intg_o,\n  input  logic [31:0]                  data_rdata_i,\n  input  logic [6:0]                   data_rdata_intg_i,\n  input  logic                         data_err_i,\n\n  // Interrupt inputs\n  input  logic                         irq_software_i,\n  input  logic                         irq_timer_i,\n  input  logic                         irq_external_i,\n  input  logic [14:0]                  irq_fast_i,\n  input  logic                         irq_nm_i,       // non-maskeable interrupt\n\n  // Scrambling Interface\n  input  logic                         scramble_key_valid_i,\n  input  logic [SCRAMBLE_KEY_W-1:0]    scramble_key_i,\n  input  logic [SCRAMBLE_NONCE_W-1:0]  scramble_nonce_i,\n  output logic                         scramble_req_o,\n\n  // Debug Interface\n  input  logic                         debug_req_i,\n  output crash_dump_t                  crash_dump_o,\n  output logic                         double_fault_seen_o,\n\n  // RISC-V Formal Interface\n  // Does not comply with the coding standards of _i/_o suffixes, but follows\n  // the convention of RISC-V Formal Interface Specification.\n`ifdef RVFI\n  output logic                         rvfi_valid,\n  output logic [63:0]                  rvfi_order,\n  output logic [31:0]                  rvfi_insn,\n  output logic                         rvfi_trap,\n  output logic                         rvfi_halt,\n  output logic                         rvfi_intr,\n  output logic [ 1:0]                  rvfi_mode,\n  output logic [ 1:0]                  rvfi_ixl,\n  output logic [ 4:0]                  rvfi_rs1_addr,\n  output logic [ 4:0]                  rvfi_rs2_addr,\n  output logic [ 4:0]                  rvfi_rs3_addr,\n  output logic [31:0]                  rvfi_rs1_rdata,\n  output logic [31:0]                  rvfi_rs2_rdata,\n  output logic [31:0]                  rvfi_rs3_rdata,\n  output logic [ 4:0]                  rvfi_rd_addr,\n  output logic [31:0]                  rvfi_rd_wdata,\n  output logic [31:0]                  rvfi_pc_rdata,\n  output logic [31:0]                  rvfi_pc_wdata,\n  output logic [31:0]                  rvfi_mem_addr,\n  output logic [ 3:0]                  rvfi_mem_rmask,\n  output logic [ 3:0]                  rvfi_mem_wmask,\n  output logic [31:0]                  rvfi_mem_rdata,\n  output logic [31:0]                  rvfi_mem_wdata,\n  output logic [31:0]                  rvfi_ext_mip,\n  output logic                         rvfi_ext_nmi,\n  output logic                         rvfi_ext_nmi_int,\n  output logic                         rvfi_ext_debug_req,\n  output logic                         rvfi_ext_debug_mode,\n  output logic                         rvfi_ext_rf_wr_suppress,\n  output logic [63:0]                  rvfi_ext_mcycle,\n  output logic [31:0]                  rvfi_ext_mhpmcounters [10],\n  output logic [31:0]                  rvfi_ext_mhpmcountersh [10],\n  output logic                         rvfi_ext_ic_scr_key_valid,\n  output logic                         rvfi_ext_irq_valid,\n`endif\n\n  // CPU Control Signals\n  input  ibex_mubi_t                   fetch_enable_i,\n  output logic                         alert_minor_o,\n  output logic                         alert_major_internal_o,\n  output logic                         alert_major_bus_o,\n  output logic                         core_sleep_o,\n\n  // DFT bypass controls\n  input logic                          scan_rst_ni\n);\n\n  localparam bit          Lockstep              = SecureIbex;\n  localparam bit          ResetAll              = Lockstep;\n  localparam bit          DummyInstructions     = SecureIbex;\n  localparam bit          RegFileECC            = SecureIbex;\n  localparam bit          RegFileWrenCheck      = SecureIbex;\n  localparam bit          RegFileRdataMuxCheck  = SecureIbex;\n  localparam int unsigned RegFileDataWidth      = RegFileECC ? 32 + 7 : 32;\n  localparam bit          MemECC                = SecureIbex;\n  localparam int unsigned MemDataWidth          = MemECC ? 32 + 7 : 32;\n  // Icache parameters\n  localparam int unsigned BusSizeECC        = ICacheECC ? (BUS_SIZE + 7) : BUS_SIZE;\n  localparam int unsigned LineSizeECC       = BusSizeECC * IC_LINE_BEATS;\n  localparam int unsigned TagSizeECC        = ICacheECC ? (IC_TAG_SIZE + 6) : IC_TAG_SIZE;\n  // Scrambling Parameter\n  localparam int unsigned NumAddrScrRounds  = ICacheScramble ? 2 : 0;\n\n  // Clock signals\n  logic                        clk;\n  ibex_mubi_t                  core_busy_d, core_busy_q;\n  logic                        clock_en;\n  logic                        irq_pending;\n  // Core <-> Register file signals\n  logic                        dummy_instr_id;\n  logic                        dummy_instr_wb;\n  logic [4:0]                  rf_raddr_a;\n  logic [4:0]                  rf_raddr_b;\n  logic [4:0]                  rf_waddr_wb;\n  logic                        rf_we_wb;\n  logic [RegFileDataWidth-1:0] rf_wdata_wb_ecc;\n  logic [RegFileDataWidth-1:0] rf_rdata_a_ecc, rf_rdata_a_ecc_buf;\n  logic [RegFileDataWidth-1:0] rf_rdata_b_ecc, rf_rdata_b_ecc_buf;\n\n  // Combined data and integrity for data and instruction busses\n  logic [MemDataWidth-1:0]     data_wdata_core;\n  logic [MemDataWidth-1:0]     data_rdata_core;\n  logic [MemDataWidth-1:0]     instr_rdata_core;\n\n  // Core <-> RAMs signals\n  logic [IC_NUM_WAYS-1:0]      ic_tag_req;\n  logic                        ic_tag_write;\n  logic [IC_INDEX_W-1:0]       ic_tag_addr;\n  logic [TagSizeECC-1:0]       ic_tag_wdata;\n  logic [TagSizeECC-1:0]       ic_tag_rdata [IC_NUM_WAYS];\n  logic [IC_NUM_WAYS-1:0]      ic_data_req;\n  logic                        ic_data_write;\n  logic [IC_INDEX_W-1:0]       ic_data_addr;\n  logic [LineSizeECC-1:0]      ic_data_wdata;\n  logic [LineSizeECC-1:0]      ic_data_rdata [IC_NUM_WAYS];\n  logic                        ic_scr_key_req;\n  // Alert signals\n  logic                        core_alert_major_internal, core_alert_major_bus, core_alert_minor;\n  logic                        lockstep_alert_major_internal, lockstep_alert_major_bus;\n  logic                        lockstep_alert_minor;\n  // Scramble signals\n  logic [SCRAMBLE_KEY_W-1:0]   scramble_key_q;\n  logic [SCRAMBLE_NONCE_W-1:0] scramble_nonce_q;\n  logic                        scramble_key_valid_d, scramble_key_valid_q;\n  logic                        scramble_req_d, scramble_req_q;\n\n  ibex_mubi_t                  fetch_enable_buf;\n\n  /////////////////////\n  // Main clock gate //\n  /////////////////////\n\n  if (SecureIbex) begin : g_clock_en_secure\n    // For secure Ibex core_busy_q must be a specific multi-bit pattern to enable the clock.\n    prim_flop #(\n      .Width($bits(ibex_mubi_t)),\n      .ResetValue(IbexMuBiOff)\n    ) u_prim_core_busy_flop (\n      .clk_i (clk_i),\n      .rst_ni(rst_ni),\n      .d_i   (core_busy_d),\n      .q_o   (core_busy_q)\n    );\n    assign clock_en = (core_busy_q != IbexMuBiOff) | debug_req_i | irq_pending | irq_nm_i;\n  end else begin : g_clock_en_non_secure\n    // For non secure Ibex only the bottom bit of core_busy_q is considered. Other FFs can be\n    // optimized away during synthesis.\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        core_busy_q <= IbexMuBiOff;\n      end else begin\n        core_busy_q <= core_busy_d;\n      end\n    end\n    assign clock_en = core_busy_q[0] | debug_req_i | irq_pending | irq_nm_i;\n\n    logic unused_core_busy;\n    assign unused_core_busy = ^core_busy_q[$bits(ibex_mubi_t)-1:1];\n  end\n\n  assign core_sleep_o = ~clock_en;\n\n  prim_clock_gating core_clock_gate_i (\n    .clk_i    (clk_i),\n    .en_i     (clock_en),\n    .test_en_i(test_en_i),\n    .clk_o    (clk)\n  );\n\n  ////////////////////////\n  // Core instantiation //\n  ////////////////////////\n\n  // Buffer security critical signals to prevent synthesis optimisation removing them\n  prim_buf #(.Width($bits(ibex_mubi_t))) u_fetch_enable_buf (\n    .in_i (fetch_enable_i),\n    .out_o(fetch_enable_buf)\n  );\n\n  prim_buf #(.Width(RegFileDataWidth)) u_rf_rdata_a_ecc_buf (\n    .in_i (rf_rdata_a_ecc),\n    .out_o(rf_rdata_a_ecc_buf)\n  );\n\n  prim_buf #(.Width(RegFileDataWidth)) u_rf_rdata_b_ecc_buf (\n    .in_i (rf_rdata_b_ecc),\n    .out_o(rf_rdata_b_ecc_buf)\n  );\n\n\n  // ibex_core takes integrity and data bits together. Combine the separate integrity and data\n  // inputs here.\n  assign data_rdata_core[31:0] = data_rdata_i;\n  assign instr_rdata_core[31:0] = instr_rdata_i;\n\n  if (MemECC) begin : gen_mem_rdata_ecc\n    assign data_rdata_core[38:32] = data_rdata_intg_i;\n    assign instr_rdata_core[38:32] = instr_rdata_intg_i;\n  end else begin : gen_non_mem_rdata_ecc\n    logic unused_intg;\n\n    assign unused_intg = ^{instr_rdata_intg_i, data_rdata_intg_i};\n  end\n\n  ibex_core #(\n    .PMPEnable        (PMPEnable),\n    .PMPGranularity   (PMPGranularity),\n    .PMPNumRegions    (PMPNumRegions),\n    .MHPMCounterNum   (MHPMCounterNum),\n    .MHPMCounterWidth (MHPMCounterWidth),\n    .RV32E            (RV32E),\n    .RV32M            (RV32M),\n    .RV32B            (RV32B),\n    .BranchTargetALU  (BranchTargetALU),\n    .ICache           (ICache),\n    .ICacheECC        (ICacheECC),\n    .BusSizeECC       (BusSizeECC),\n    .TagSizeECC       (TagSizeECC),\n    .LineSizeECC      (LineSizeECC),\n    .BranchPredictor  (BranchPredictor),\n    .DbgTriggerEn     (DbgTriggerEn),\n    .DbgHwBreakNum    (DbgHwBreakNum),\n    .WritebackStage   (WritebackStage),\n    .ResetAll         (ResetAll),\n    .RndCnstLfsrSeed  (RndCnstLfsrSeed),\n    .RndCnstLfsrPerm  (RndCnstLfsrPerm),\n    .SecureIbex       (SecureIbex),\n    .DummyInstructions(DummyInstructions),\n    .RegFileECC       (RegFileECC),\n    .RegFileDataWidth (RegFileDataWidth),\n    .MemECC           (MemECC),\n    .MemDataWidth     (MemDataWidth),\n    .DmHaltAddr       (DmHaltAddr),\n    .DmExceptionAddr  (DmExceptionAddr)\n  ) u_ibex_core (\n    .clk_i(clk),\n    .rst_ni,\n\n    .hart_id_i,\n    .boot_addr_i,\n\n    .instr_req_o,\n    .instr_gnt_i,\n    .instr_rvalid_i,\n    .instr_addr_o,\n    .instr_rdata_i(instr_rdata_core),\n    .instr_err_i,\n\n    .data_req_o,\n    .data_gnt_i,\n    .data_rvalid_i,\n    .data_we_o,\n    .data_be_o,\n    .data_addr_o,\n    .data_wdata_o(data_wdata_core),\n    .data_rdata_i(data_rdata_core),\n    .data_err_i,\n\n    .dummy_instr_id_o (dummy_instr_id),\n    .dummy_instr_wb_o (dummy_instr_wb),\n    .rf_raddr_a_o     (rf_raddr_a),\n    .rf_raddr_b_o     (rf_raddr_b),\n    .rf_waddr_wb_o    (rf_waddr_wb),\n    .rf_we_wb_o       (rf_we_wb),\n    .rf_wdata_wb_ecc_o(rf_wdata_wb_ecc),\n    .rf_rdata_a_ecc_i (rf_rdata_a_ecc_buf),\n    .rf_rdata_b_ecc_i (rf_rdata_b_ecc_buf),\n\n    .ic_tag_req_o      (ic_tag_req),\n    .ic_tag_write_o    (ic_tag_write),\n    .ic_tag_addr_o     (ic_tag_addr),\n    .ic_tag_wdata_o    (ic_tag_wdata),\n    .ic_tag_rdata_i    (ic_tag_rdata),\n    .ic_data_req_o     (ic_data_req),\n    .ic_data_write_o   (ic_data_write),\n    .ic_data_addr_o    (ic_data_addr),\n    .ic_data_wdata_o   (ic_data_wdata),\n    .ic_data_rdata_i   (ic_data_rdata),\n    .ic_scr_key_valid_i(scramble_key_valid_q),\n    .ic_scr_key_req_o  (ic_scr_key_req),\n\n    .irq_software_i,\n    .irq_timer_i,\n    .irq_external_i,\n    .irq_fast_i,\n    .irq_nm_i,\n    .irq_pending_o(irq_pending),\n\n    .debug_req_i,\n    .crash_dump_o,\n    .double_fault_seen_o,\n\n`ifdef RVFI\n    .rvfi_valid,\n    .rvfi_order,\n    .rvfi_insn,\n    .rvfi_trap,\n    .rvfi_halt,\n    .rvfi_intr,\n    .rvfi_mode,\n    .rvfi_ixl,\n    .rvfi_rs1_addr,\n    .rvfi_rs2_addr,\n    .rvfi_rs3_addr,\n    .rvfi_rs1_rdata,\n    .rvfi_rs2_rdata,\n    .rvfi_rs3_rdata,\n    .rvfi_rd_addr,\n    .rvfi_rd_wdata,\n    .rvfi_pc_rdata,\n    .rvfi_pc_wdata,\n    .rvfi_mem_addr,\n    .rvfi_mem_rmask,\n    .rvfi_mem_wmask,\n    .rvfi_mem_rdata,\n    .rvfi_mem_wdata,\n    .rvfi_ext_mip,\n    .rvfi_ext_nmi,\n    .rvfi_ext_nmi_int,\n    .rvfi_ext_debug_req,\n    .rvfi_ext_debug_mode,\n    .rvfi_ext_rf_wr_suppress,\n    .rvfi_ext_mcycle,\n    .rvfi_ext_mhpmcounters,\n    .rvfi_ext_mhpmcountersh,\n    .rvfi_ext_ic_scr_key_valid,\n    .rvfi_ext_irq_valid,\n`endif\n\n    .fetch_enable_i        (fetch_enable_buf),\n    .alert_minor_o         (core_alert_minor),\n    .alert_major_internal_o(core_alert_major_internal),\n    .alert_major_bus_o     (core_alert_major_bus),\n    .core_busy_o           (core_busy_d)\n  );\n\n  /////////////////////////////////\n  // Register file Instantiation //\n  /////////////////////////////////\n\n  logic rf_alert_major_internal;\n  if (RegFile == RegFileFF) begin : gen_regfile_ff\n    ibex_register_file_ff #(\n      .RV32E            (RV32E),\n      .DataWidth        (RegFileDataWidth),\n      .DummyInstructions(DummyInstructions),\n      // SEC_CM: DATA_REG_SW.GLITCH_DETECT\n      .WrenCheck        (RegFileWrenCheck),\n      .RdataMuxCheck    (RegFileRdataMuxCheck),\n      .WordZeroVal      (RegFileDataWidth'(prim_secded_pkg::SecdedInv3932ZeroWord))\n    ) register_file_i (\n      .clk_i (clk),\n      .rst_ni(rst_ni),\n\n      .test_en_i       (test_en_i),\n      .dummy_instr_id_i(dummy_instr_id),\n      .dummy_instr_wb_i(dummy_instr_wb),\n\n      .raddr_a_i(rf_raddr_a),\n      .rdata_a_o(rf_rdata_a_ecc),\n      .raddr_b_i(rf_raddr_b),\n      .rdata_b_o(rf_rdata_b_ecc),\n      .waddr_a_i(rf_waddr_wb),\n      .wdata_a_i(rf_wdata_wb_ecc),\n      .we_a_i   (rf_we_wb),\n      .err_o    (rf_alert_major_internal)\n    );\n  end else if (RegFile == RegFileFPGA) begin : gen_regfile_fpga\n    ibex_register_file_fpga #(\n      .RV32E            (RV32E),\n      .DataWidth        (RegFileDataWidth),\n      .DummyInstructions(DummyInstructions),\n      // SEC_CM: DATA_REG_SW.GLITCH_DETECT\n      .WrenCheck        (RegFileWrenCheck),\n      .RdataMuxCheck    (RegFileRdataMuxCheck),\n      .WordZeroVal      (RegFileDataWidth'(prim_secded_pkg::SecdedInv3932ZeroWord))\n    ) register_file_i (\n      .clk_i (clk),\n      .rst_ni(rst_ni),\n\n      .test_en_i       (test_en_i),\n      .dummy_instr_id_i(dummy_instr_id),\n      .dummy_instr_wb_i(dummy_instr_wb),\n\n      .raddr_a_i(rf_raddr_a),\n      .rdata_a_o(rf_rdata_a_ecc),\n      .raddr_b_i(rf_raddr_b),\n      .rdata_b_o(rf_rdata_b_ecc),\n      .waddr_a_i(rf_waddr_wb),\n      .wdata_a_i(rf_wdata_wb_ecc),\n      .we_a_i   (rf_we_wb),\n      .err_o    (rf_alert_major_internal)\n    );\n  end else if (RegFile == RegFileLatch) begin : gen_regfile_latch\n    ibex_register_file_latch #(\n      .RV32E            (RV32E),\n      .DataWidth        (RegFileDataWidth),\n      .DummyInstructions(DummyInstructions),\n      // SEC_CM: DATA_REG_SW.GLITCH_DETECT\n      .WrenCheck        (RegFileWrenCheck),\n      .RdataMuxCheck    (RegFileRdataMuxCheck),\n      .WordZeroVal      (RegFileDataWidth'(prim_secded_pkg::SecdedInv3932ZeroWord))\n    ) register_file_i (\n      .clk_i (clk),\n      .rst_ni(rst_ni),\n\n      .test_en_i       (test_en_i),\n      .dummy_instr_id_i(dummy_instr_id),\n      .dummy_instr_wb_i(dummy_instr_wb),\n\n      .raddr_a_i(rf_raddr_a),\n      .rdata_a_o(rf_rdata_a_ecc),\n      .raddr_b_i(rf_raddr_b),\n      .rdata_b_o(rf_rdata_b_ecc),\n      .waddr_a_i(rf_waddr_wb),\n      .wdata_a_i(rf_wdata_wb_ecc),\n      .we_a_i   (rf_we_wb),\n      .err_o    (rf_alert_major_internal)\n    );\n  end\n\n  ///////////////////////////////\n  // Scrambling Infrastructure //\n  ///////////////////////////////\n\n  if (ICacheScramble) begin : gen_scramble\n\n    // SEC_CM: ICACHE.MEM.SCRAMBLE\n    // Scramble key valid starts with OTP returning new valid key and stays high\n    // until we request a new valid key.\n    assign scramble_key_valid_d = scramble_req_q ? scramble_key_valid_i :\n                                  ic_scr_key_req ? 1'b0                 :\n                                                   scramble_key_valid_q;\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        scramble_key_q       <= RndCnstIbexKey;\n        scramble_nonce_q     <= RndCnstIbexNonce;\n      end else if (scramble_key_valid_i) begin\n        scramble_key_q       <= scramble_key_i;\n        scramble_nonce_q     <= scramble_nonce_i;\n      end\n    end\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        scramble_key_valid_q <= 1'b1;\n        scramble_req_q       <= '0;\n      end else begin\n        scramble_key_valid_q <= scramble_key_valid_d;\n        scramble_req_q       <= scramble_req_d;\n      end\n    end\n\n  // Scramble key request starts with invalidate signal from ICache and stays high\n  // until we got a valid key.\n    assign scramble_req_d = scramble_req_q ? ~scramble_key_valid_i : ic_scr_key_req;\n    assign scramble_req_o = scramble_req_q;\n\n  end else begin : gen_noscramble\n\n    logic unused_scramble_inputs = scramble_key_valid_i & (|scramble_key_i) & (|RndCnstIbexKey) &\n                                   (|scramble_nonce_i) & (|RndCnstIbexNonce) & scramble_req_q &\n                                   ic_scr_key_req & scramble_key_valid_d & scramble_req_d;\n\n    assign scramble_req_d       = 1'b0;\n    assign scramble_req_q       = 1'b0;\n    assign scramble_req_o       = 1'b0;\n    assign scramble_key_q       = '0;\n    assign scramble_nonce_q     = '0;\n    assign scramble_key_valid_q = 1'b1;\n    assign scramble_key_valid_d = 1'b1;\n  end\n\n  ////////////////////////\n  // Rams Instantiation "}
{"text": "//\n  ////////////////////////\n\n  if (ICache) begin : gen_rams\n\n    for (genvar way = 0; way < IC_NUM_WAYS; way++) begin : gen_rams_inner\n\n      if (ICacheScramble) begin : gen_scramble_rams\n\n        // SEC_CM: ICACHE.MEM.SCRAMBLE\n        // Tag RAM instantiation\n        prim_ram_1p_scr #(\n          .Width            (TagSizeECC),\n          .Depth            (IC_NUM_LINES),\n          .DataBitsPerMask  (TagSizeECC),\n          .EnableParity     (0),\n          .NumAddrScrRounds (NumAddrScrRounds)\n        ) tag_bank (\n          .clk_i,\n          .rst_ni,\n\n          .key_valid_i (scramble_key_valid_q),\n          .key_i       (scramble_key_q),\n          .nonce_i     (scramble_nonce_q),\n\n          .req_i       (ic_tag_req[way]),\n\n          .gnt_o       (),\n          .write_i     (ic_tag_write),\n          .addr_i      (ic_tag_addr),\n          .wdata_i     (ic_tag_wdata),\n          .wmask_i     ({TagSizeECC{1'b1}}),\n          .intg_error_i(1'b0),\n\n          .rdata_o     (ic_tag_rdata[way]),\n          .rvalid_o    (),\n          .raddr_o     (),\n          .rerror_o    (),\n          .cfg_i       (ram_cfg_i)\n        );\n\n        // Data RAM instantiation\n        prim_ram_1p_scr #(\n          .Width              (LineSizeECC),\n          .Depth              (IC_NUM_LINES),\n          .DataBitsPerMask    (LineSizeECC),\n          .ReplicateKeyStream (1),\n          .EnableParity       (0),\n          .NumAddrScrRounds   (NumAddrScrRounds)\n        ) data_bank (\n          .clk_i,\n          .rst_ni,\n\n          .key_valid_i (scramble_key_valid_q),\n          .key_i       (scramble_key_q),\n          .nonce_i     (scramble_nonce_q),\n\n          .req_i       (ic_data_req[way]),\n\n          .gnt_o       (),\n          .write_i     (ic_data_write),\n          .addr_i      (ic_data_addr),\n          .wdata_i     (ic_data_wdata),\n          .wmask_i     ({LineSizeECC{1'b1}}),\n          .intg_error_i(1'b0),\n\n          .rdata_o     (ic_data_rdata[way]),\n          .rvalid_o    (),\n          .raddr_o     (),\n          .rerror_o    (),\n          .cfg_i       (ram_cfg_i)\n        );\n\n        `ifdef INC_ASSERT\n          // Sample scramble key whenever it is valid for use in the assertions below.  This may be\n          // redundant with the sampling performed in the actual design, but that is okay because\n          // the assertions exist to check the correct functioning of the design.\n          logic [SCRAMBLE_KEY_W-1:0] sampled_scramble_key;\n          always_ff @(posedge clk_i, negedge rst_ni) begin\n            if (!rst_ni) begin\n              sampled_scramble_key <= 'x;\n            end else if (scramble_key_valid_i) begin\n              sampled_scramble_key <= scramble_key_i;\n            end\n          end\n\n          // Ensure that when a scramble key is received, it is correctly applied to the icache\n          // scrambled memory primitives.  The upper bound in the cycle ranges below is not exact,\n          // but it should not take more than 10 cycles.\n          `ASSERT(ScrambleKeyAppliedAtTagBank_A,\n                  scramble_key_valid_i\n                  |-> ##[0:10]\n                  tag_bank.key_valid_i && (tag_bank.key_i == sampled_scramble_key),\n                  clk_i, !rst_ni\n          )\n          `ASSERT(ScrambleKeyAppliedAtDataBank_A,\n                  scramble_key_valid_i\n                  |-> ##[0:10]\n                  data_bank.key_valid_i && (data_bank.key_i == sampled_scramble_key),\n                  clk_i, !rst_ni\n          )\n        `endif\n\n      end else begin : gen_noscramble_rams\n\n        // Tag RAM instantiation\n        prim_ram_1p #(\n          .Width            (TagSizeECC),\n          .Depth            (IC_NUM_LINES),\n          .DataBitsPerMask  (TagSizeECC)\n        ) tag_bank (\n          .clk_i,\n\n          .req_i       (ic_tag_req[way]),\n\n          .write_i     (ic_tag_write),\n          .addr_i      (ic_tag_addr),\n          .wdata_i     (ic_tag_wdata),\n          .wmask_i     ({TagSizeECC{1'b1}}),\n\n          .rdata_o     (ic_tag_rdata[way]),\n          .cfg_i       (ram_cfg_i)\n        );\n\n        // Data RAM instantiation\n        prim_ram_1p #(\n          .Width              (LineSizeECC),\n          .Depth              (IC_NUM_LINES),\n          .DataBitsPerMask    (LineSizeECC)\n        ) data_bank (\n          .clk_i,\n\n          .req_i       (ic_data_req[way]),\n\n          .write_i     (ic_data_write),\n          .addr_i      (ic_data_addr),\n          .wdata_i     (ic_data_wdata),\n          .wmask_i     ({LineSizeECC{1'b1}}),\n\n          .rdata_o     (ic_data_rdata[way]),\n          .cfg_i       (ram_cfg_i)\n        );\n\n      end\n    end\n\n  end else begin : gen_norams\n\n    prim_ram_1p_pkg::ram_1p_cfg_t unused_ram_cfg;\n    logic unused_ram_inputs;\n\n    assign unused_ram_cfg    = ram_cfg_i;\n    assign unused_ram_inputs = (|ic_tag_req) & ic_tag_write & (|ic_tag_addr) & (|ic_tag_wdata) &\n                               (|ic_data_req) & ic_data_write & (|ic_data_addr) & (|ic_data_wdata) &\n                               (|scramble_key_q) & (|scramble_nonce_q) & scramble_key_valid_q &\n                               scramble_key_valid_d & (|scramble_nonce_q) &\n                               (|NumAddrScrRounds);\n\n    assign ic_tag_rdata      = '{default:'b0};\n    assign ic_data_rdata     = '{default:'b0};\n\n  end\n\n  assign data_wdata_o = data_wdata_core[31:0];\n\n  if (MemECC) begin : gen_mem_wdata_ecc\n    prim_buf #(.Width(7)) u_prim_buf_data_wdata_intg (\n      .in_i (data_wdata_core[38:32]),\n      .out_o(data_wdata_intg_o)\n    );\n  end else begin : gen_no_mem_ecc\n    assign data_wdata_intg_o = '0;\n  end\n\n  // Redundant lockstep core implementation\n  if (Lockstep) begin : gen_lockstep\n    // SEC_CM: LOGIC.SHADOW\n    // Note: certain synthesis tools like DC are very smart at optimizing away redundant logic.\n    // Hence, we have to insert an optimization barrier at the IOs of the lockstep Ibex.\n    // This is achieved by manually buffering each bit using prim_buf.\n    // Our Xilinx and DC synthesis flows make sure that these buffers cannot be optimized away\n    // using keep attributes (Vivado) and size_only constraints (DC).\n\n    localparam int NumBufferBits = $bits({\n      hart_id_i,\n      boot_addr_i,\n      instr_req_o,\n      instr_gnt_i,\n      instr_rvalid_i,\n      instr_addr_o,\n      instr_rdata_core,\n      instr_err_i,\n      data_req_o,\n      data_gnt_i,\n      data_rvalid_i,\n      data_we_o,\n      data_be_o,\n      data_addr_o,\n      data_wdata_core,\n      data_rdata_core,\n      data_err_i,\n      dummy_instr_id,\n      dummy_instr_wb,\n      rf_raddr_a,\n      rf_raddr_b,\n      rf_waddr_wb,\n      rf_we_wb,\n      rf_wdata_wb_ecc,\n      rf_rdata_a_ecc,\n      rf_rdata_b_ecc,\n      ic_tag_req,\n      ic_tag_write,\n      ic_tag_addr,\n      ic_tag_wdata,\n      ic_data_req,\n      ic_data_write,\n      ic_data_addr,\n      ic_data_wdata,\n      scramble_key_valid_i,\n      ic_scr_key_req,\n      irq_software_i,\n      irq_timer_i,\n      irq_external_i,\n      irq_fast_i,\n      irq_nm_i,\n      irq_pending,\n      debug_req_i,\n      crash_dump_o,\n      double_fault_seen_o,\n      fetch_enable_i,\n      core_busy_d\n    });\n\n    logic [NumBufferBits-1:0] buf_in, buf_out;\n\n    logic [31:0]                  hart_id_local;\n    logic [31:0]                  boot_addr_local;\n\n    logic                         instr_req_local;\n    logic                         instr_gnt_local;\n    logic                         instr_rvalid_local;\n    logic [31:0]                  instr_addr_local;\n    logic [MemDataWidth-1:0]      instr_rdata_local;\n    logic                         instr_err_local;\n\n    logic                         data_req_local;\n    logic                         data_gnt_local;\n    logic                         data_rvalid_local;\n    logic                         data_we_local;\n    logic [3:0]                   data_be_local;\n    logic [31:0]                  data_addr_local;\n    logic [MemDataWidth-1:0]      data_wdata_local;\n    logic [MemDataWidth-1:0]      data_rdata_local;\n    logic                         data_err_local;\n\n    logic                         dummy_instr_id_local;\n    logic                         dummy_instr_wb_local;\n    logic [4:0]                   rf_raddr_a_local;\n    logic [4:0]                   rf_raddr_b_local;\n    logic [4:0]                   rf_waddr_wb_local;\n    logic                         rf_we_wb_local;\n    logic [RegFileDataWidth-1:0]  rf_wdata_wb_ecc_local;\n    logic [RegFileDataWidth-1:0]  rf_rdata_a_ecc_local;\n    logic [RegFileDataWidth-1:0]  rf_rdata_b_ecc_local;\n\n    logic [IC_NUM_WAYS-1:0]       ic_tag_req_local;\n    logic                         ic_tag_write_local;\n    logic [IC_INDEX_W-1:0]        ic_tag_addr_local;\n    logic [TagSizeECC-1:0]        ic_tag_wdata_local;\n    logic [IC_NUM_WAYS-1:0]       ic_data_req_local;\n    logic                         ic_data_write_local;\n    logic [IC_INDEX_W-1:0]        ic_data_addr_local;\n    logic [LineSizeECC-1:0]       ic_data_wdata_local;\n    logic                         scramble_key_valid_local;\n    logic                         ic_scr_key_req_local;\n\n    logic                         irq_software_local;\n    logic                         irq_timer_local;\n    logic                         irq_external_local;\n    logic [14:0]                  irq_fast_local;\n    logic                         irq_nm_local;\n    logic                         irq_pending_local;\n\n    logic                         debug_req_local;\n    crash_dump_t                  crash_dump_local;\n    logic                         double_fault_seen_local;\n    ibex_mubi_t                   fetch_enable_local;\n\n    ibex_mubi_t                   core_busy_local;\n\n    assign buf_in = {\n      hart_id_i,\n      boot_addr_i,\n      instr_req_o,\n      instr_gnt_i,\n      instr_rvalid_i,\n      instr_addr_o,\n      instr_rdata_core,\n      instr_err_i,\n      data_req_o,\n      data_gnt_i,\n      data_rvalid_i,\n      data_we_o,\n      data_be_o,\n      data_addr_o,\n      data_wdata_core,\n      data_rdata_core,\n      data_err_i,\n      dummy_instr_id,\n      dummy_instr_wb,\n      rf_raddr_a,\n      rf_raddr_b,\n      rf_waddr_wb,\n      rf_we_wb,\n      rf_wdata_wb_ecc,\n      rf_rdata_a_ecc,\n      rf_rdata_b_ecc,\n      ic_tag_req,\n      ic_tag_write,\n      ic_tag_addr,\n      ic_tag_wdata,\n      ic_data_req,\n      ic_data_write,\n      ic_data_addr,\n      ic_data_wdata,\n      scramble_key_valid_q,\n      ic_scr_key_req,\n      irq_software_i,\n      irq_timer_i,\n      irq_external_i,\n      irq_fast_i,\n      irq_nm_i,\n      irq_pending,\n      debug_req_i,\n      crash_dump_o,\n      double_fault_seen_o,\n      fetch_enable_i,\n      core_busy_d\n    };\n\n    assign {\n      hart_id_local,\n      boot_addr_local,\n      instr_req_local,\n      instr_gnt_local,\n      instr_rvalid_local,\n      instr_addr_local,\n      instr_rdata_local,\n      instr_err_local,\n      data_req_local,\n      data_gnt_local,\n      data_rvalid_local,\n      data_we_local,\n      data_be_local,\n      data_addr_local,\n      data_wdata_local,\n      data_rdata_local,\n      data_err_local,\n      dummy_instr_id_local,\n      dummy_instr_wb_local,\n      rf_raddr_a_local,\n      rf_raddr_b_local,\n      rf_waddr_wb_local,\n      rf_we_wb_local,\n      rf_wdata_wb_ecc_local,\n      rf_rdata_a_ecc_local,\n      rf_rdata_b_ecc_local,\n      ic_tag_req_local,\n      ic_tag_write_local,\n      ic_tag_addr_local,\n      ic_tag_wdata_local,\n      ic_data_req_local,\n      ic_data_write_local,\n      ic_data_addr_local,\n      ic_data_wdata_local,\n      scramble_key_valid_local,\n      ic_scr_key_req_local,\n      irq_software_local,\n      irq_timer_local,\n      irq_external_local,\n      irq_fast_local,\n      irq_nm_local,\n      irq_pending_local,\n      debug_req_local,\n      crash_dump_local,\n      double_fault_seen_local,\n      fetch_enable_local,\n      core_busy_local\n    } = buf_out;\n\n    // Manually buffer all input signals.\n    prim_buf #(.Width(NumBufferBits)) u_signals_prim_buf (\n      .in_i(buf_in),\n      .out_o(buf_out)\n    );\n\n    logic [TagSizeECC-1:0]  ic_tag_rdata_local [IC_NUM_WAYS];\n    logic [LineSizeECC-1:0] ic_data_rdata_local [IC_NUM_WAYS];\n    for (genvar k = 0; k < IC_NUM_WAYS; k++) begin : gen_ways\n      prim_buf #(.Width(TagSizeECC)) u_tag_prim_buf (\n        .in_i(ic_tag_rdata[k]),\n        .out_o(ic_tag_rdata_local[k])\n      );\n      prim_buf #(.Width(LineSizeECC)) u_data_prim_buf (\n        .in_i(ic_data_rdata[k]),\n        .out_o(ic_data_rdata_local[k])\n      );\n    end\n\n    logic lockstep_alert_minor_local, lockstep_alert_major_internal_local;\n    logic lockstep_alert_major_bus_local;\n\n    ibex_lockstep #(\n      .PMPEnable        (PMPEnable),\n      .PMPGranularity   (PMPGranularity),\n      .PMPNumRegions    (PMPNumRegions),\n      .MHPMCounterNum   (MHPMCounterNum),\n      .MHPMCounterWidth (MHPMCounterWidth),\n      .RV32E            (RV32E),\n      .RV32M            (RV32M),\n      .RV32B            (RV32B),\n      .BranchTargetALU  (BranchTargetALU),\n      .ICache           (ICache),\n      .ICacheECC        (ICacheECC),\n      .BusSizeECC       (BusSizeECC),\n      .TagSizeECC       (TagSizeECC),\n      .LineSizeECC      (LineSizeECC),\n      .BranchPredictor  (BranchPredictor),\n      .DbgTriggerEn     (DbgTriggerEn),\n      .DbgHwBreakNum    (DbgHwBreakNum),\n      .WritebackStage   (WritebackStage),\n      .ResetAll         (ResetAll),\n      .RndCnstLfsrSeed  (RndCnstLfsrSeed),\n      .RndCnstLfsrPerm  (RndCnstLfsrPerm),\n      .SecureIbex       (SecureIbex),\n      .DummyInstructions(DummyInstructions),\n      .RegFileECC       (RegFileECC),\n      .RegFileDataWidth (RegFileDataWidth),\n      .MemECC           (MemECC),\n      .DmHaltAddr       (DmHaltAddr),\n      .DmExceptionAddr  (DmExceptionAddr)\n    ) u_ibex_lockstep (\n      .clk_i                  (clk),\n      .rst_ni                 (rst_ni),\n\n      .hart_id_i              (hart_id_local),\n      .boot_addr_i            (boot_addr_local),\n\n      .instr_req_i            (instr_req_local),\n      .instr_gnt_i            (instr_gnt_local),\n      .instr_rvalid_i         (instr_rvalid_local),\n      .instr_addr_i           (instr_addr_local),\n      .instr_rdata_i          (instr_rdata_local),\n      .instr_err_i            (instr_err_local),\n\n      .data_req_i             (data_req_local),\n      .data_gnt_i             (data_gnt_local),\n      .data_rvalid_i          (data_rvalid_local),\n      .data_we_i              (data_we_local),\n      .data_be_i              (data_be_local),\n      .data_addr_i            (data_addr_local),\n      .data_wdata_i           (data_wdata_local),\n      .data_rdata_i           (data_rdata_local),\n      .data_err_i             (data_err_local),\n\n      .dummy_instr_id_i       (dummy_instr_id_local),\n      .dummy_instr_wb_i       (dummy_instr_wb_local),\n      .rf_raddr_a_i           (rf_raddr_a_local),\n      .rf_raddr_b_i           (rf_raddr_b_local),\n      .rf_waddr_wb_i          (rf_waddr_wb_local),\n      .rf_we_wb_i             (rf_we_wb_local),\n      .rf_wdata_wb_ecc_i      (rf_wdata_wb_ecc_local),\n      .rf_rdata_a_ecc_i       (rf_rdata_a_ecc_local),\n      .rf_rdata_b_ecc_i       (rf_rdata_b_ecc_local),\n\n      .ic_tag_req_i           (ic_tag_req_local),\n      .ic_tag_write_i         (ic_tag_write_local),\n      .ic_tag_addr_i          (ic_tag_addr_local),\n      .ic_tag_wdata_i         (ic_tag_wdata_local),\n      .ic_tag_rdata_i         (ic_tag_rdata_local),\n      .ic_data_req_i          (ic_data_req_local),\n      .ic_data_write_i        (ic_data_write_local),\n      .ic_data_addr_i         (ic_data_addr_local),\n      .ic_data_wdata_i        (ic_data_wdata_local),\n      .ic_data_rdata_i        (ic_data_rdata_local),\n      .ic_scr_key_valid_i     (scramble_key_valid_local),\n      .ic_scr_key_req_i       (ic_scr_key_req_local),\n\n      .irq_software_i         (irq_software_local),\n      .irq_timer_i            (irq_timer_local),\n      .irq_external_i         (irq_external_local),\n      .irq_fast_i             (irq_fast_local),\n      .irq_nm_i               (irq_nm_local),\n      .irq_pending_i          (irq_pending_local),\n\n      .debug_req_i            (debug_req_local),\n      .crash_dump_i           (crash_dump_local),\n      .double_fault_seen_i    (double_fault_seen_local),\n\n      .fetch_enable_i         (fetch_enable_local),\n      .alert_minor_o          (lockstep_alert_minor_local),\n      .alert_major_internal_o (lockstep_alert_major_internal_local),\n      .alert_major_bus_o      (lockstep_alert_major_bus_local),\n      .core_busy_i            (core_busy_local),\n      .test_en_i              (test_en_i),\n      .scan_rst_ni            (scan_rst_ni)\n    );\n\n    prim_buf u_prim_buf_alert_minor (\n      .in_i (lockstep_alert_minor_local),\n      .out_o(lockstep_alert_minor)\n    );\n\n    prim_buf u_prim_buf_alert_major_internal (\n      .in_i (lockstep_alert_major_internal_local),\n      .out_o(lockstep_alert_major_internal)\n    );\n\n    prim_buf u_prim_buf_alert_major_bus (\n      .in_i (lockstep_alert_major_bus_local),\n      .out_o(lockstep_alert_major_bus)\n    );\n\n  end else begin : gen_no_lockstep\n    assign lockstep_alert_major_internal = 1'b0;\n    assign lockstep_alert_major_bus      = 1'b0;\n    assign lockstep_alert_minor          = 1'b0;\n    logic unused_scan;\n    assign unused_scan = scan_rst_ni;\n  end\n\n  assign alert_major_internal_o = core_alert_major_internal |\n                                  lockstep_alert_major_internal |\n                                  rf_alert_major_internal;\n  assign alert_major_bus_o      = core_alert_major_bus | lockstep_alert_major_bus;\n  assign alert_minor_o          = core_alert_minor | lockstep_alert_minor;\n\n  // X checks for top-level outputs\n  `ASSERT_KNOWN(IbexInstrReqX, instr_req_o)\n  `ASSERT_KNOWN_IF(IbexInstrReqPayloadX, instr_addr_o, instr_req_o)\n\n  `ASSERT_KNOWN(IbexDataReqX, data_req_o)\n  `ASSERT_KNOWN_IF(IbexDataReqPayloadX,\n    {data_we_o, data_be_o, data_addr_o, data_wdata_o, data_wdata_intg_o}, data_req_o)\n\n  `ASSERT_KNOWN(IbexScrambleReqX, scramble_req_o)\n  `ASSERT_KNOWN(IbexDoubleFaultSeenX, double_fault_seen_o)\n  `ASSERT_KNOWN(IbexAlertMinorX, alert_minor_o)\n  `ASSERT_KNOWN(IbexAlertMajorInternalX, alert_major_internal_o)\n  `ASSERT_KNOWN(IbexAlertMajorBusX, alert_major_bus_o)\n  `ASSERT_KNOWN(IbexCoreSleepX, core_sleep_o)\n\n  // X check for top-level inputs\n  `ASSERT_KNOWN(IbexTestEnX, test_en_i)\n  `ASSERT_KNOWN(IbexRamCfgX, ram_cfg_i)\n  `ASSERT_KNOWN(IbexHartIdX, hart_id_i)\n  `ASSERT_KNOWN(IbexBootAddrX, boot_addr_i)\n\n  `ASSERT_KNOWN(IbexInstrGntX, instr_gnt_i)\n  `ASSERT_KNOWN(IbexInstrRValidX, instr_rvalid_i)\n  `ASSERT_KNOWN_IF(IbexInstrRPayloadX,\n    {instr_rdata_i, instr_rdata_intg_i, instr_err_i}, instr_rvalid_i)\n\n  `ASSERT_KNOWN(IbexDataGntX, data_gnt_i)\n  `ASSERT_KNOWN(IbexDataRValidX, data_rvalid_i)\n  `ifdef INC_ASSERT\n    // Ibex can have a maximum of 2 accesses outstanding on the DSide. This is because it does not\n    // speculative data accesses so the only requests that can be in flight must relate to a single\n    // ongoing load or store instruction. Due to unaligned access support a single load or store can\n    // generate 2 accesses.\n    localparam int unsigned MaxOutstandingDSideAccesses = 2;\n\n    typedef struct packed {\n      logic valid;\n      logic is_read;\n    } pending_access_t;\n\n    pending_access_t pending_dside_accesses_q[MaxOutstandingDSideAccesses];\n    pending_access_t pending_dside_accesses_d[MaxOutstandingDSideAccesses];\n    pending_access_t pending_dside_accesses_shifted[MaxOutstandingDSideAccesses];\n\n    for (genvar i = 0; i < MaxOutstandingDSideAccesses; i++) begin : g_dside_tracker\n      always_ff @(posedge clk or negedge rst_ni) begin\n        if (!rst_ni) begin\n          pending_dside_accesses_q[i] <= '0;\n        end else begin\n          pending_dside_accesses_q[i] <= pending_dside_accesses_d[i];\n        end\n      end\n\n      always_comb begin\n        pending_dside_accesses_shifted[i] = pending_dside_accesses_q[i];\n\n        if (data_rvalid_i) begin\n          if (i != MaxOutstandingDSideAccesses - 1) begin\n            pending_dside_accesses_shifted[i] = pending_dside_ac"}
{"text": "cesses_q[i + 1];\n          end else begin\n            pending_dside_accesses_shifted[i] = '0;\n          end\n        end\n      end\n\n      if (i == 0) begin : g_track_first_entry\n        always_comb begin\n          pending_dside_accesses_d[i] = pending_dside_accesses_shifted[i];\n\n          if (data_req_o && data_gnt_i && !pending_dside_accesses_shifted[i].valid) begin\n            pending_dside_accesses_d[i].valid = 1'b1;\n            pending_dside_accesses_d[i].is_read = ~data_we_o;\n          end\n        end\n      end else begin : g_track_other_entries\n        always_comb begin\n          pending_dside_accesses_d[i] = pending_dside_accesses_shifted[i];\n\n          if (data_req_o && data_gnt_i && pending_dside_accesses_shifted[i - 1].valid &&\n              !pending_dside_accesses_shifted[i].valid) begin\n            pending_dside_accesses_d[i].valid = 1'b1;\n            pending_dside_accesses_d[i].is_read = ~data_we_o;\n          end\n        end\n      end\n    end\n\n    // We should never start a new data request if we've already got the maximum outstanding. We can\n    // start a new request in the same cycle an old one ends, in which case we'll see all pending\n    // accesses valid but one will be ending this cycle so the empty slot can be immediately used by\n    // the new request.\n    `ASSERT(MaxOutstandingDSideAccessesCorrect,\n        data_req_o |->\n        ~pending_dside_accesses_q[MaxOutstandingDSideAccesses-1].valid | data_rvalid_i)\n\n    // Should only see a request response if we're expecting one\n    `ASSERT(PendingAccessTrackingCorrect, data_rvalid_i |-> pending_dside_accesses_q[0])\n\n    if (SecureIbex) begin : g_secure_ibex_mem_assert\n      // For SecureIbex responses to both writes and reads must specify rdata and rdata_intg (for\n      // writes rdata is effectively ignored by rdata_intg still checked against rdata)\n      `ASSERT_KNOWN_IF(IbexDataRPayloadX, {data_rdata_i, data_rdata_intg_i},\n          data_rvalid_i)\n    end else begin : g_no_secure_ibex_mem_assert\n      // Without SecureIbex data_rdata_i and data_rdata_intg_i are only relevant to reads. Check\n      // neither are X on a response to a read.\n      `ASSERT_KNOWN_IF(IbexDataRPayloadX, {data_rdata_i, data_rdata_intg_i},\n          data_rvalid_i & pending_dside_accesses_q[0].is_read)\n    end\n\n    // data_err_i relevant to both reads and writes. Check it isn't X on any response.\n    `ASSERT_KNOWN_IF(IbexDataRErrPayloadX, data_err_i, data_rvalid_i)\n\n    `ifdef RVFI\n    // Tracking logic and predictor for double_fault_seen_o output, relies on RVFI so only include\n    // it where RVFI is available.\n\n    // Returns 1'b1 if the provided instruction decodes to one that would write the sync_exc_bit of\n    // the CPUCTRLSTS CSR\n    function automatic logic insn_write_sync_exc_seen(logic [31:0] insn_bits);\n      return (insn_bits[6:0] == OPCODE_SYSTEM) &&\n             (insn_bits[14:12] inside {3'b001, 3'b010, 3'b011, 3'b101}) &&\n             (insn_bits[31:20] == CSR_CPUCTRLSTS);\n    endfunction\n\n    // Given an instruction that writes the sync_exc_bit of the CPUCTRLSTS CSR along with the value\n    // of the rs1 register read for that instruction and the current predicted sync_exc_bit bit\n    // return the new value of the sync_exc_bit after the instruction is executed.\n    function automatic logic new_sync_exc_bit(logic [31:0] insn_bits, logic [31:0] rs1,\n        logic cur_bit);\n      logic sync_exc_update_bit;\n\n      sync_exc_update_bit = insn_bits[14] ? 1'b0 : rs1[6];\n\n      case (insn_bits[13:12])\n        2'b01: return sync_exc_update_bit;\n        2'b10: return cur_bit | sync_exc_update_bit;\n        2'b11: return cur_bit & ~sync_exc_update_bit;\n        default: return 1'bx;\n      endcase\n    endfunction\n\n    localparam int DoubleFaultSeenLatency = 3;\n    logic [DoubleFaultSeenLatency-1:0] double_fault_seen_delay_buffer;\n    logic [DoubleFaultSeenLatency-2:0] double_fault_seen_delay_buffer_q;\n    logic                              sync_exc_seen;\n    logic                              new_sync_exc;\n    logic                              double_fault_seen_predicted;\n\n    assign new_sync_exc                = rvfi_valid & rvfi_trap & ~rvfi_ext_debug_mode;\n    assign double_fault_seen_predicted = sync_exc_seen & new_sync_exc;\n\n    // Depending on whether the exception comes from the WB or ID/EX stage the precise timing of the\n    // double_fault_seen_o output vs the double fault instruction being visible on RVFI differs. At\n    // the earliest extreme it can be asserted the same cycle the instruction is visible on the\n    // RVFI.  Buffer the last few cycles of double_fault_seen_o output for checking. We can\n    // guarantee the minimum spacing between double_fault_seen_o assertions  (occurring when the\n    // first instruction of an exception handler continuously double faults with a single cycle\n    // memory access time) is sufficient that we'll only see a single bit set in the delay buffer.\n    assign double_fault_seen_delay_buffer = {double_fault_seen_delay_buffer_q, double_fault_seen_o};\n\n    always @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        double_fault_seen_delay_buffer_q <= '0;\n        sync_exc_seen <= 1'b0;\n      end else begin\n        double_fault_seen_delay_buffer_q <=\n          double_fault_seen_delay_buffer[DoubleFaultSeenLatency-2:0];\n\n        if (new_sync_exc) begin\n          // Set flag when we see a new synchronous exception\n          sync_exc_seen <= 1'b1;\n        end else if (rvfi_valid && rvfi_insn == 32'h30200073) begin\n          // Clear flag when we see an MRET\n          sync_exc_seen <= 1'b0;\n        end else if (rvfi_valid && insn_write_sync_exc_seen(rvfi_insn)) begin\n          // Update predicted sync_exc_seen when the instruction modifies the relevant CPUCTRLSTS\n          // CSR bit.\n          sync_exc_seen <= new_sync_exc_bit(rvfi_insn, rvfi_rs1_rdata, sync_exc_seen);\n        end\n      end\n    end\n\n    // We should only have a single assertion of double_fault_seen in the delay buffer\n    `ASSERT(DoubleFaultSinglePulse, $onehot0(double_fault_seen_delay_buffer))\n    // If we predict a double_fault_seen_o we should see one in the delay buffer\n    `ASSERT(DoubleFaultPulseSeenOnDoubleFault,\n      double_fault_seen_predicted |-> |double_fault_seen_delay_buffer)\n    // If double_fault_seen_o is asserted we should see predict one occurring within a bounded time\n    `ASSERT(DoubleFaultPulseOnlyOnDoubleFault,\n      double_fault_seen_o |-> ##[0:DoubleFaultSeenLatency] double_fault_seen_predicted)\n    `endif // RVFI\n  `endif\n\n  `ASSERT_KNOWN(IbexIrqX, {irq_software_i, irq_timer_i, irq_external_i, irq_fast_i, irq_nm_i})\n\n  `ASSERT_KNOWN(IbexScrambleKeyValidX, scramble_key_valid_i)\n  `ASSERT_KNOWN_IF(IbexScramblePayloadX, {scramble_key_i, scramble_nonce_i}, scramble_key_valid_i)\n\n  `ASSERT_KNOWN(IbexDebugReqX, debug_req_i)\n  `ASSERT_KNOWN(IbexFetchEnableX, fetch_enable_i)\n\n  // Dummy instructions may only write to register 0, which is a special register when dummy\n  // instructions are enabled.\n  `ASSERT(WaddrAZeroForDummyInstr, dummy_instr_wb && rf_we_wb |-> rf_waddr_wb == '0)\n\n  // Ensure the crash dump is connected to the correct internal signals\n  `ASSERT(CrashDumpCurrentPCConn, crash_dump_o.current_pc === u_ibex_core.pc_id)\n  `ASSERT(CrashDumpNextPCConn, crash_dump_o.next_pc === u_ibex_core.pc_if)\n  `ASSERT(CrashDumpLastDataAddrConn,\n    crash_dump_o.last_data_addr === u_ibex_core.load_store_unit_i.addr_last_q)\n  `ASSERT(CrashDumpExceptionPCConn,\n    crash_dump_o.exception_pc === u_ibex_core.cs_registers_i.mepc_q)\n  `ASSERT(CrashDumpExceptionAddrConn,\n    crash_dump_o.exception_addr === u_ibex_core.cs_registers_i.mtval_q)\n\n  // Explicit INC_ASSERT due to instantiation of prim_secded_inv_39_32_dec below that is only used\n  // by assertions\n  `ifdef INC_ASSERT\n  if (MemECC) begin : g_mem_ecc_asserts\n    logic [1:0] data_ecc_err, instr_ecc_err;\n\n    // Check alerts from memory integrity failures\n\n    prim_secded_inv_39_32_dec u_data_intg_dec (\n      .data_i     (data_rdata_core),\n      .data_o     (),\n      .syndrome_o (),\n      .err_o      (data_ecc_err)\n    );\n    `ASSERT(MajorAlertOnDMemIntegrityErr,\n      data_rvalid_i && (|data_ecc_err) |-> ##[0:5] alert_major_bus_o)\n\n    prim_secded_inv_39_32_dec u_instr_intg_dec (\n      .data_i     (instr_rdata_core),\n      .data_o     (),\n      .syndrome_o (),\n      .err_o      (instr_ecc_err)\n    );\n    // Check alerts from memory integrity failures\n    `ASSERT(MajorAlertOnIMemIntegrityErr,\n      instr_rvalid_i && (|instr_ecc_err) |-> ##[0:5] alert_major_bus_o)\n  end\n  `endif\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Top level module of the ibex RISC-V core with tracing enabled\n */\n\nmodule ibex_top_tracing import ibex_pkg::*; #(\n  parameter bit          PMPEnable        = 1'b0,\n  parameter int unsigned PMPGranularity   = 0,\n  parameter int unsigned PMPNumRegions    = 4,\n  parameter int unsigned MHPMCounterNum   = 0,\n  parameter int unsigned MHPMCounterWidth = 40,\n  parameter bit          RV32E            = 1'b0,\n  parameter rv32m_e      RV32M            = RV32MFast,\n  parameter rv32b_e      RV32B            = RV32BNone,\n  parameter regfile_e    RegFile          = RegFileFF,\n  parameter bit          BranchTargetALU  = 1'b0,\n  parameter bit          WritebackStage   = 1'b0,\n  parameter bit          ICache           = 1'b0,\n  parameter bit          ICacheECC        = 1'b0,\n  parameter bit          BranchPredictor  = 1'b0,\n  parameter bit          DbgTriggerEn     = 1'b0,\n  parameter int unsigned DbgHwBreakNum    = 1,\n  parameter bit          SecureIbex       = 1'b0,\n  parameter bit          ICacheScramble   = 1'b0,\n  parameter lfsr_seed_t  RndCnstLfsrSeed  = RndCnstLfsrSeedDefault,\n  parameter lfsr_perm_t  RndCnstLfsrPerm  = RndCnstLfsrPermDefault,\n  parameter int unsigned DmHaltAddr       = 32'h1A110800,\n  parameter int unsigned DmExceptionAddr  = 32'h1A110808\n) (\n  // Clock and Reset\n  input  logic                         clk_i,\n  input  logic                         rst_ni,\n\n  input  logic                         test_en_i,     // enable all clock gates for testing\n  input  logic                         scan_rst_ni,\n  input  prim_ram_1p_pkg::ram_1p_cfg_t ram_cfg_i,\n\n\n  input  logic [31:0]                  hart_id_i,\n  input  logic [31:0]                  boot_addr_i,\n\n  // Instruction memory interface\n  output logic                         instr_req_o,\n  input  logic                         instr_gnt_i,\n  input  logic                         instr_rvalid_i,\n  output logic [31:0]                  instr_addr_o,\n  input  logic [31:0]                  instr_rdata_i,\n  input  logic [6:0]                   instr_rdata_intg_i,\n  input  logic                         instr_err_i,\n\n  // Data memory interface\n  output logic                         data_req_o,\n  input  logic                         data_gnt_i,\n  input  logic                         data_rvalid_i,\n  output logic                         data_we_o,\n  output logic [3:0]                   data_be_o,\n  output logic [31:0]                  data_addr_o,\n  output logic [31:0]                  data_wdata_o,\n  output logic [6:0]                   data_wdata_intg_o,\n  input  logic [31:0]                  data_rdata_i,\n  input  logic [6:0]                   data_rdata_intg_i,\n  input  logic                         data_err_i,\n\n  // Interrupt inputs\n  input  logic                         irq_software_i,\n  input  logic                         irq_timer_i,\n  input  logic                         irq_external_i,\n  input  logic [14:0]                  irq_fast_i,\n  input  logic                         irq_nm_i,       // non-maskeable interrupt\n\n  // Scrambling Interface\n  input  logic                         scramble_key_valid_i,\n  input  logic [SCRAMBLE_KEY_W-1:0]    scramble_key_i,\n  input  logic [SCRAMBLE_NONCE_W-1:0]  scramble_nonce_i,\n  output logic                         scramble_req_o,\n\n  // Debug Interface\n  input  logic                         debug_req_i,\n  output crash_dump_t                  crash_dump_o,\n  output logic                         double_fault_seen_o,\n\n  // CPU Control Signals\n  input  ibex_mubi_t                   fetch_enable_i,\n  output logic                         alert_minor_o,\n  output logic                         alert_major_internal_o,\n  output logic                         alert_major_bus_o,\n  output logic                         core_sleep_o\n\n);\n\n  // ibex_tracer relies on the signals from the RISC-V Formal Interface\n  `ifndef RVFI\n    $fatal(\"Fatal error: RVFI needs to be defined globally.\");\n  `endif\n\n  logic        rvfi_valid;\n  logic [63:0] rvfi_order;\n  logic [31:0] rvfi_insn;\n  logic        rvfi_trap;\n  logic        rvfi_halt;\n  logic        rvfi_intr;\n  logic [ 1:0] rvfi_mode;\n  logic [ 1:0] rvfi_ixl;\n  logic [ 4:0] rvfi_rs1_addr;\n  logic [ 4:0] rvfi_rs2_addr;\n  logic [ 4:0] rvfi_rs3_addr;\n  logic [31:0] rvfi_rs1_rdata;\n  logic [31:0] rvfi_rs2_rdata;\n  logic [31:0] rvfi_rs3_rdata;\n  logic [ 4:0] rvfi_rd_addr;\n  logic [31:0] rvfi_rd_wdata;\n  logic [31:0] rvfi_pc_rdata;\n  logic [31:0] rvfi_pc_wdata;\n  logic [31:0] rvfi_mem_addr;\n  logic [ 3:0] rvfi_mem_rmask;\n  logic [ 3:0] rvfi_mem_wmask;\n  logic [31:0] rvfi_mem_rdata;\n  logic [31:0] rvfi_mem_wdata;\n  logic [31:0] rvfi_ext_mip;\n  logic        rvfi_ext_nmi;\n  logic        rvfi_ext_nmi_int;\n  logic        rvfi_ext_debug_req;\n  logic        rvfi_ext_debug_mode;\n  logic        rvfi_ext_rf_wr_suppress;\n  logic [63:0] rvfi_ext_mcycle;\n\n  logic [31:0] rvfi_ext_mhpmcounters [10];\n  logic [31:0] rvfi_ext_mhpmcountersh [10];\n  logic        rvfi_ext_ic_scr_key_valid;\n  logic        rvfi_ext_irq_valid;\n\n  logic [31:0] unused_perf_regs [10];\n  logic [31:0] unused_perf_regsh [10];\n\n\n  logic [31:0] unused_rvfi_ext_mip;\n  logic        unused_rvfi_ext_nmi;\n  logic        unused_rvfi_ext_nmi_int;\n  logic        unused_rvfi_ext_debug_req;\n  logic        unused_rvfi_ext_debug_mode;\n  logic        unused_rvfi_ext_rf_wr_suppress;\n  logic [63:0] unused_rvfi_ext_mcycle;\n  logic        unused_rvfi_ext_ic_scr_key_valid;\n  logic        unused_rvfi_ext_irq_valid;\n\n  // Tracer doesn't use these signals, though other modules may probe down into tracer to observe\n  // them.\n  assign unused_rvfi_ext_mip = rvfi_ext_mip;\n  assign unused_rvfi_ext_nmi = rvfi_ext_nmi;\n  assign unused_rvfi_ext_nmi_int = rvfi_ext_nmi_int;\n  assign unused_rvfi_ext_debug_req = rvfi_ext_debug_req;\n  assign unused_rvfi_ext_debug_mode = rvfi_ext_debug_mode;\n  assign unused_rvfi_ext_rf_wr_suppress = rvfi_ext_rf_wr_suppress;\n  assign unused_rvfi_ext_mcycle = rvfi_ext_mcycle;\n  assign unused_perf_regs = rvfi_ext_mhpmcounters;\n  assign unused_perf_regsh = rvfi_ext_mhpmcountersh;\n  assign unused_rvfi_ext_ic_scr_key_valid = rvfi_ext_ic_scr_key_valid;\n  assign unused_rvfi_ext_irq_valid = rvfi_ext_irq_valid;\n\n  ibex_top #(\n    .PMPEnable        ( PMPEnable        ),\n    .PMPGranularity   ( PMPGranularity   ),\n    .PMPNumRegions    ( PMPNumRegions    ),\n    .MHPMCounterNum   ( MHPMCounterNum   ),\n    .MHPMCounterWidth ( MHPMCounterWidth ),\n    .RV32E            ( RV32E            ),\n    .RV32M            ( RV32M            ),\n    .RV32B            ( RV32B            ),\n    .RegFile          ( RegFile          ),\n    .BranchTargetALU  ( BranchTargetALU  ),\n    .ICache           ( ICache           ),\n    .ICacheECC        ( ICacheECC        ),\n    .BranchPredictor  ( BranchPredictor  ),\n    .DbgTriggerEn     ( DbgTriggerEn     ),\n    .DbgHwBreakNum    ( DbgHwBreakNum    ),\n    .WritebackStage   ( WritebackStage   ),\n    .SecureIbex       ( SecureIbex       ),\n    .ICacheScramble   ( ICacheScramble   ),\n    .RndCnstLfsrSeed  ( RndCnstLfsrSeed  ),\n    .RndCnstLfsrPerm  ( RndCnstLfsrPerm  ),\n    .DmHaltAddr       ( DmHaltAddr       ),\n    .DmExceptionAddr  ( DmExceptionAddr  )\n  ) u_ibex_top (\n    .clk_i,\n    .rst_ni,\n\n    .test_en_i,\n    .scan_rst_ni,\n    .ram_cfg_i,\n\n    .hart_id_i,\n    .boot_addr_i,\n\n    .instr_req_o,\n    .instr_gnt_i,\n    .instr_rvalid_i,\n    .instr_addr_o,\n    .instr_rdata_i,\n    .instr_rdata_intg_i,\n    .instr_err_i,\n\n    .data_req_o,\n    .data_gnt_i,\n    .data_rvalid_i,\n    .data_we_o,\n    .data_be_o,\n    .data_addr_o,\n    .data_wdata_o,\n    .data_wdata_intg_o,\n    .data_rdata_i,\n    .data_rdata_intg_i,\n    .data_err_i,\n\n    .irq_software_i,\n    .irq_timer_i,\n    .irq_external_i,\n    .irq_fast_i,\n    .irq_nm_i,\n\n    .scramble_key_valid_i,\n    .scramble_key_i,\n    .scramble_nonce_i,\n    .scramble_req_o,\n\n    .debug_req_i,\n    .crash_dump_o,\n    .double_fault_seen_o,\n\n    .rvfi_valid,\n    .rvfi_order,\n    .rvfi_insn,\n    .rvfi_trap,\n    .rvfi_halt,\n    .rvfi_intr,\n    .rvfi_mode,\n    .rvfi_ixl,\n    .rvfi_rs1_addr,\n    .rvfi_rs2_addr,\n    .rvfi_rs3_addr,\n    .rvfi_rs1_rdata,\n    .rvfi_rs2_rdata,\n    .rvfi_rs3_rdata,\n    .rvfi_rd_addr,\n    .rvfi_rd_wdata,\n    .rvfi_pc_rdata,\n    .rvfi_pc_wdata,\n    .rvfi_mem_addr,\n    .rvfi_mem_rmask,\n    .rvfi_mem_wmask,\n    .rvfi_mem_rdata,\n    .rvfi_mem_wdata,\n    .rvfi_ext_mip,\n    .rvfi_ext_nmi,\n    .rvfi_ext_nmi_int,\n    .rvfi_ext_debug_req,\n    .rvfi_ext_debug_mode,\n    .rvfi_ext_rf_wr_suppress,\n    .rvfi_ext_mcycle,\n    .rvfi_ext_mhpmcounters,\n    .rvfi_ext_mhpmcountersh,\n    .rvfi_ext_ic_scr_key_valid,\n    .rvfi_ext_irq_valid,\n\n    .fetch_enable_i,\n    .alert_minor_o,\n    .alert_major_internal_o,\n    .alert_major_bus_o,\n    .core_sleep_o\n  );\n\n  ibex_tracer\n  u_ibex_tracer (\n    .clk_i,\n    .rst_ni,\n\n    .hart_id_i,\n\n    .rvfi_valid,\n    .rvfi_order,\n    .rvfi_insn,\n    .rvfi_trap,\n    .rvfi_halt,\n    .rvfi_intr,\n    .rvfi_mode,\n    .rvfi_ixl,\n    .rvfi_rs1_addr,\n    .rvfi_rs2_addr,\n    .rvfi_rs3_addr,\n    .rvfi_rs1_rdata,\n    .rvfi_rs2_rdata,\n    .rvfi_rs3_rdata,\n    .rvfi_rd_addr,\n    .rvfi_rd_wdata,\n    .rvfi_pc_rdata,\n    .rvfi_pc_wdata,\n    .rvfi_mem_addr,\n    .rvfi_mem_rmask,\n    .rvfi_mem_wmask,\n    .rvfi_mem_rdata,\n    .rvfi_mem_wdata\n  );\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2018 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Trace executed instructions in simulation\n *\n * This tracer takes execution information from the RISC-V Verification Interface (RVFI) and\n * produces a text file with a human-readable trace.\n *\n * All traced instructions are written to a log file. By default, the log file is named\n * trace_core_<HARTID>.log, with <HARTID> being the 8 digit hart ID of the core being traced.\n *\n * The file name base, defaulting to \"trace_core\" can be set using the \"ibex_tracer_file_base\"\n * plusarg passed to the simulation, e.g. \"+ibex_tracer_file_base=ibex_my_trace\". The exact syntax\n * of passing plusargs to a simulation depends on the simulator.\n *\n * The creation of the instruction trace is enabled by default but can be disabled for a simulation.\n * This behaviour is controlled by the plusarg \"ibex_tracer_enable\". Use \"ibex_tracer_enable=0\" to\n * disable the tracer.\n *\n * The trace contains six columns, separated by tabs:\n * - The simulation time\n * - The clock cycle count since reset\n * - The program counter (PC)\n * - The instruction\n * - The decoded instruction in the same format as objdump, together with the accessed registers and\n *   read/written memory values. Jumps and branches show the target address.\n *   This column may be omitted if the instruction does not decode into a long form.\n * - Accessed registers and memory locations.\n *\n * Significant effort is spent to make the decoding produced by this tracer as similar as possible\n * to the one produced by objdump. This simplifies the correlation between the static program\n * information from the objdump-generated disassembly, and the runtime information from this tracer.\n */\nmodule ibex_tracer (\n  input logic        clk_i,\n  input logic        rst_ni,\n\n  input logic [31:0] hart_id_i,\n\n  // RVFI as described at https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/rvfi.md\n  // The standard interface does not have _i/_o suffixes. For consistency with the standard the\n  // signals in this module don't have the suffixes either.\n  input logic        rvfi_valid,\n  input logic [63:0] rvfi_order,\n  input logic [31:0] rvfi_insn,\n  input logic        rvfi_trap,\n  input logic        rvfi_halt,\n  input logic        rvfi_intr,\n  input logic [ 1:0] rvfi_mode,\n  input logic [ 1:0] rvfi_ixl,\n  input logic [ 4:0] rvfi_rs1_addr,\n  input logic [ 4:0] rvfi_rs2_addr,\n  input logic [ 4:0] rvfi_rs3_addr,\n  input logic [31:0] rvfi_rs1_rdata,\n  input logic [31:0] rvfi_rs2_rdata,\n  input logic [31:0] rvfi_rs3_rdata,\n  input logic [ 4:0] rvfi_rd_addr,\n  input logic [31:0] rvfi_rd_wdata,\n  input logic [31:0] rvfi_pc_rdata,\n  input logic [31:0] rvfi_pc_wdata,\n  input logic [31:0] rvfi_mem_addr,\n  input logic [ 3:0] rvfi_mem_rmask,\n  input logic [ 3:0] rvfi_mem_wmask,\n  input logic [31:0] rvfi_mem_rdata,\n  input logic [31:0] rvfi_mem_wdata\n);\n\n  // These signals are part of RVFI, but not used in this module currently.\n  // Keep them as part of the interface to change the tracer more easily in the future. Assigning\n  // these signals to unused_* signals marks them explicitly as unused, an annotation picked up by\n  // linters, including Verilator lint.\n  logic [63:0] unused_rvfi_order = rvfi_order;\n  logic        unused_rvfi_trap = rvfi_trap;\n  logic        unused_rvfi_halt = rvfi_halt;\n  logic        unused_rvfi_intr = rvfi_intr;\n  logic [ 1:0] unused_rvfi_mode = rvfi_mode;\n  logic [ 1:0] unused_rvfi_ixl = rvfi_ixl;\n\n  import ibex_tracer_pkg::*;\n\n  int          file_handle;\n  string       file_name;\n\n  int unsigned cycle;\n  string       decoded_str;\n  logic        insn_is_compressed;\n\n  // Data items accessed during this instruction\n  localparam logic [4:0] RS1 = (1 << 0);\n  localparam logic [4:0] RS2 = (1 << 1);\n  localparam logic [4:0] RS3 = (1 << 2);\n  localparam logic [4:0] RD  = (1 << 3);\n  localparam logic [4:0] MEM = (1 << 4);\n  logic [4:0] data_accessed;\n\n  logic trace_log_enable;\n  initial begin\n    if ($value$plusargs(\"ibex_tracer_enable=%b\", trace_log_enable)) begin\n      if (trace_log_enable == 1'b0) begin\n        $display(\"%m: Instruction trace disabled.\");\n      end\n    end else begin\n      trace_log_enable = 1'b1;\n    end\n  end\n\n  function automatic void printbuffer_dumpline(int fh);\n    string rvfi_insn_str;\n\n    // Write compressed instructions as four hex digits (16 bit word), and\n    // uncompressed ones as 8 hex digits (32 bit words).\n    if (insn_is_compressed) begin\n      rvfi_insn_str = $sformatf(\"%h\", rvfi_insn[15:0]);\n    end else begin\n      rvfi_insn_str = $sformatf(\"%h\", rvfi_insn);\n    end\n\n    $fwrite(fh, \"%15t\\t%d\\t%h\\t%s\\t%s\\t\",\n            $time, cycle, rvfi_pc_rdata, rvfi_insn_str, decoded_str);\n\n    if ((data_accessed & RS1) != 0) begin\n      $fwrite(fh, \" %s:0x%08x\", reg_addr_to_str(rvfi_rs1_addr), rvfi_rs1_rdata);\n    end\n    if ((data_accessed & RS2) != 0) begin\n      $fwrite(fh, \" %s:0x%08x\", reg_addr_to_str(rvfi_rs2_addr), rvfi_rs2_rdata);\n    end\n    if ((data_accessed & RS3) != 0) begin\n      $fwrite(fh, \" %s:0x%08x\", reg_addr_to_str(rvfi_rs3_addr), rvfi_rs3_rdata);\n    end\n    if ((data_accessed & RD) != 0) begin\n      $fwrite(fh, \" %s=0x%08x\", reg_addr_to_str(rvfi_rd_addr), rvfi_rd_wdata);\n    end\n    if ((data_accessed & MEM) != 0) begin\n      $fwrite(fh, \" PA:0x%08x\", rvfi_mem_addr);\n\n      if (rvfi_mem_wmask != 4'b0000) begin\n        $fwrite(fh, \" store:0x%08x\", rvfi_mem_wdata);\n      end\n      if (rvfi_mem_rmask != 4'b0000) begin\n        $fwrite(fh, \" load:0x%08x\", rvfi_mem_rdata);\n      end\n    end\n\n    $fwrite(fh, \"\\n\");\n  endfunction\n\n\n  // Format register address with \"x\" prefix, left-aligned to a fixed width of 3 characters.\n  function automatic string reg_addr_to_str(input logic [4:0] addr);\n    if (addr < 10) begin\n      return $sformatf(\" x%0d\", addr);\n    end else begin\n      return $sformatf(\"x%0d\", addr);\n    end\n  endfunction\n\n  // Get a CSR name for a CSR address.\n  function automatic string get_csr_name(input logic [11:0] csr_addr);\n    unique case (csr_addr)\n      12'd0: return \"ustatus\";\n      12'd4: return \"uie\";\n      12'd5: return \"utvec\";\n      12'd64: return \"uscratch\";\n      12'd65: return \"uepc\";\n      12'd66: return \"ucause\";\n      12'd67: return \"utval\";\n      12'd68: return \"uip\";\n      12'd1: return \"fflags\";\n      12'd2: return \"frm\";\n      12'd3: return \"fcsr\";\n      12'd3072: return \"cycle\";\n      12'd3073: return \"time\";\n      12'd3074: return \"instret\";\n      12'd3075: return \"hpmcounter3\";\n      12'd3076: return \"hpmcounter4\";\n      12'd3077: return \"hpmcounter5\";\n      12'd3078: return \"hpmcounter6\";\n      12'd3079: return \"hpmcounter7\";\n      12'd3080: return \"hpmcounter8\";\n      12'd3081: return \"hpmcounter9\";\n      12'd3082: return \"hpmcounter10\";\n      12'd3083: return \"hpmcounter11\";\n      12'd3084: return \"hpmcounter12\";\n      12'd3085: return \"hpmcounter13\";\n      12'd3086: return \"hpmcounter14\";\n      12'd3087: return \"hpmcounter15\";\n      12'd3088: return \"hpmcounter16\";\n      12'd3089: return \"hpmcounter17\";\n      12'd3090: return \"hpmcounter18\";\n      12'd3091: return \"hpmcounter19\";\n      12'd3092: return \"hpmcounter20\";\n      12'd3093: return \"hpmcounter21\";\n      12'd3094: return \"hpmcounter22\";\n      12'd3095: return \"hpmcounter23\";\n      12'd3096: return \"hpmcounter24\";\n      12'd3097: return \"hpmcounter25\";\n      12'd3098: return \"hpmcounter26\";\n      12'd3099: return \"hpmcounter27\";\n      12'd3100: return \"hpmcounter28\";\n      12'd3101: return \"hpmcounter29\";\n      12'd3102: return \"hpmcounter30\";\n      12'd3103: return \"hpmcounter31\";\n      12'd3200: return \"cycleh\";\n      12'd3201: return \"timeh\";\n      12'd3202: return \"instreth\";\n      12'd3203: return \"hpmcounter3h\";\n      12'd3204: return \"hpmcounter4h\";\n      12'd3205: return \"hpmcounter5h\";\n      12'd3206: return \"hpmcounter6h\";\n      12'd3207: return \"hpmcounter7h\";\n      12'd3208: return \"hpmcounter8h\";\n      12'd3209: return \"hpmcounter9h\";\n      12'd3210: return \"hpmcounter10h\";\n      12'd3211: return \"hpmcounter11h\";\n      12'd3212: return \"hpmcounter12h\";\n      12'd3213: return \"hpmcounter13h\";\n      12'd3214: return \"hpmcounter14h\";\n      12'd3215: return \"hpmcounter15h\";\n      12'd3216: return \"hpmcounter16h\";\n      12'd3217: return \"hpmcounter17h\";\n      12'd3218: return \"hpmcounter18h\";\n      12'd3219: return \"hpmcounter19h\";\n      12'd3220: return \"hpmcounter20h\";\n      12'd3221: return \"hpmcounter21h\";\n      12'd3222: return \"hpmcounter22h\";\n      12'd3223: return \"hpmcounter23h\";\n      12'd3224: return \"hpmcounter24h\";\n      12'd3225: return \"hpmcounter25h\";\n      12'd3226: return \"hpmcounter26h\";\n      12'd3227: return \"hpmcounter27h\";\n      12'd3228: return \"hpmcounter28h\";\n      12'd3229: return \"hpmcounter29h\";\n      12'd3230: return \"hpmcounter30h\";\n      12'd3231: return \"hpmcounter31h\";\n      12'd256: return \"sstatus\";\n      12'd258: return \"sedeleg\";\n      12'd259: return \"sideleg\";\n      12'd260: return \"sie\";\n      12'd261: return \"stvec\";\n      12'd262: return \"scounteren\";\n      12'd320: return \"sscratch\";\n      12'd321: return \"sepc\";\n      12'd322: return \"scause\";\n      12'd323: return \"stval\";\n      12'd324: return \"sip\";\n      12'd384: return \"satp\";\n      12'd3857: return \"mvendorid\";\n      12'd3858: return \"marchid\";\n      12'd3859: return \"mimpid\";\n      12'd3860: return \"mhartid\";\n      12'd768: return \"mstatus\";\n      12'd769: return \"misa\";\n      12'd770: return \"medeleg\";\n      12'd771: return \"mideleg\";\n      12'd772: return \"mie\";\n      12'd773: return \"mtvec\";\n      12'd774: return \"mcounteren\";\n      12'd832: return \"mscratch\";\n      12'd833: return \"mepc\";\n      12'd834: return \"mcause\";\n      12'd835: return \"mtval\";\n      12'd836: return \"mip\";\n      12'd928: return \"pmpcfg0\";\n      12'd929: return \"pmpcfg1\";\n      12'd930: return \"pmpcfg2\";\n      12'd931: return \"pmpcfg3\";\n      12'd944: return \"pmpaddr0\";\n      12'd945: return \"pmpaddr1\";\n      12'd946: return \"pmpaddr2\";\n      12'd947: return \"pmpaddr3\";\n      12'd948: return \"pmpaddr4\";\n      12'd949: return \"pmpaddr5\";\n      12'd950: return \"pmpaddr6\";\n      12'd951: return \"pmpaddr7\";\n      12'd952: return \"pmpaddr8\";\n      12'd953: return \"pmpaddr9\";\n      12'd954: return \"pmpaddr10\";\n      12'd955: return \"pmpaddr11\";\n      12'd956: return \"pmpaddr12\";\n      12'd957: return \"pmpaddr13\";\n      12'd958: return \"pmpaddr14\";\n      12'd959: return \"pmpaddr15\";\n      12'd2816: return \"mcycle\";\n      12'd2818: return \"minstret\";\n      12'd2819: return \"mhpmcounter3\";\n      12'd2820: return \"mhpmcounter4\";\n      12'd2821: return \"mhpmcounter5\";\n      12'd2822: return \"mhpmcounter6\";\n      12'd2823: return \"mhpmcounter7\";\n      12'd2824: return \"mhpmcounter8\";\n      12'd2825: return \"mhpmcounter9\";\n      12'd2826: return \"mhpmcounter10\";\n      12'd2827: return \"mhpmcounter11\";\n      12'd2828: return \"mhpmcounter12\";\n      12'd2829: return \"mhpmcounter13\";\n      12'd2830: return \"mhpmcounter14\";\n      12'd2831: return \"mhpmcounter15\";\n      12'd2832: return \"mhpmcounter16\";\n      12'd2833: return \"mhpmcounter17\";\n      12'd2834: return \"mhpmcounter18\";\n      12'd2835: return \"mhpmcounter19\";\n      12'd2836: return \"mhpmcounter20\";\n      12'd2837: return \"mhpmcounter21\";\n      12'd2838: return \"mhpmcounter22\";\n      12'd2839: return \"mhpmcounter23\";\n      12'd2840: return \"mhpmcounter24\";\n      12'd2841: return \"mhpmcounter25\";\n      12'd2842: return \"mhpmcounter26\";\n      12'd2843: return \"mhpmcounter27\";\n      12'd2844: return \"mhpmcounter28\";\n      12'd2845: return \"mhpmcounter29\";\n      12'd2846: return \"mhpmcounter30\";\n      12'd2847: return \"mhpmcounter31\";\n      12'd2944: return \"mcycleh\";\n      12'd2946: return \"minstreth\";\n      12'd2947: return \"mhpmcounter3h\";\n      12'd2948: return \"mhpmcounter4h\";\n      12'd2949: return \"mhpmcounter5h\";\n      12'd2950: return \"mhpmcounter6h\";\n      12'd2951: return \"mhpmcounter7h\";\n      12'd2952: return \"mhpmcounter8h\";\n      12'd2953: return \"mhpmcounter9h\";\n      12'd2954: return \"mhpmcounter10h\";\n      12'd2955: return \"mhpmcounter11h\";\n      12'd2956: return \"mhpmcounter12h\";\n      12'd2957: return \"mhpmcounter13h\";\n      12'd2958: return \"mhpmcounter14h\";\n      12'd2959: return \"mhpmcounter15h\";\n      12'd2960: return \"mhpmcounter16h\";\n      12'd2961: return \"mhpmcounter17h\";\n      12'd2962: return \"mhpmcounter18h\";\n      12'd2963: return \"mhpmcounter19h\";\n      12'd2964: return \"mhpmcounter20h\";\n      12'd2965: return \"mhpmcounter21h\";\n      12'd2966: return \"mhpmcounter22h\";\n      12'd2967: return \"mhpmcounter23h\";\n      12'd2968: return \"mhpmcounter24h\";\n      12'd2969: return \"mhpmcounter25h\";\n      12'd2970: return \"mhpmcounter26h\";\n      12'd2971: return \"mhpmcounter27h\";\n      12'd2972: return \"mhpmcounter28h\";\n      12'd2973: return \"mhpmcounter29h\";\n      12'd2974: return \"mhpmcounter30h\";\n      12'd2975: return \"mhpmcounter31h\";\n      12'd803: return \"mhpmevent3\";\n      12'd804: return \"mhpmevent4\";\n      12'd805: return \"mhpmevent5\";\n      12'd806: return \"mhpmevent6\";\n      12'd807: return \"mhpmevent7\";\n      12'd808: return \"mhpmevent8\";\n      12'd809: return \"mhpmevent9\";\n      12'd810: return \"mhpmevent10\";\n      12'd811: return \"mhpmevent11\";\n      12'd812: return \"mhpmevent12\";\n      12'd813: return \"mhpmevent13\";\n      12'd814: return \"mhpmevent14\";\n      12'd815: return \"mhpmevent15\";\n      12'd816: return \"mhpmevent16\";\n      12'd817: return \"mhpmevent17\";\n      12'd818: return \"mhpmevent18\";\n      12'd819: return \"mhpmevent19\";\n      12'd820: return \"mhpmevent20\";\n      12'd821: return \"mhpmevent21\";\n      12'd822: return \"mhpmevent22\";\n      12'd823: return \"mhpmevent23\";\n      12'd824: return \"mhpmevent24\";\n      12'd825: return \"mhpmevent25\";\n      12'd826: return \"mhpmevent26\";\n      12'd827: return \"mhpmevent27\";\n      12'd828: return \"mhpmevent28\";\n      12'd829: return \"mhpmevent29\";\n      12'd830: return \"mhpmevent30\";\n      12'd831: return \"mhpmevent31\";\n      12'd1952: return \"tselect\";\n      12'd1953: return \"tdata1\";\n      12'd1954: return \"tdata2\";\n      12'd1955: return \"tdata3\";\n      12'd1968: return \"dcsr\";\n      12'd1969: return \"dpc\";\n      12'd1970: return \"dscratch\";\n      12'd512: return \"hstatus\";\n      12'd514: return \"hedeleg\";\n      12'd515: return \"hideleg\";\n      12'd516: return \"hie\";\n      12'd517: return \"htvec\";\n      12'd576: return \"hscratch\";\n      12'd577: return \"hepc\";\n      12'd578: return \"hcause\";\n      12'd579: return \"hbadaddr\";\n      12'd580: return \"hip\";\n      12'd896: return \"mbase\";\n      12'd897: return \"mbound\";\n      12'd898: return \"mibase\";\n      12'd899: return \"mibound\";\n      12'd900: return \"mdbase\";\n      12'd901: return \"mdbound\";\n      12'd800: return \"mcountinhibit\";\n      default: return $sformatf(\"0x%x\", csr_addr);\n    endcase\n  endfunction\n\n  function automatic void decode_mnemonic(input string mnemonic);\n    decoded_str = mnemonic;\n  endfunction\n\n  function automatic void decode_r_insn(input string mnemonic);\n    data_accessed = RS1 | RS2 | RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,x%0d,x%0d\", mnemonic, rvfi_rd_addr, rvfi_rs1_addr,\n        rvfi_rs2_addr);\n  endfunction\n\n  function automatic void decode_r1_insn(input string mnemonic);\n    data_accessed = RS1 | RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,x%0d\", mnemonic, rvfi_rd_addr, rvfi_rs1_addr);\n  endfunction\n\n  function automatic void decode_r_cmixcmov_insn(input string mnemonic);\n    data_accessed = RS1 | RS2 | RS3 | RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,x%0d,x%0d,x%0d\", mnemonic, rvfi_rd_addr, rvfi_rs2_addr,\n        rvfi_rs1_addr, rvfi_rs3_addr);\n  endfunction\n\n  function automatic void decode_r_funnelshift_insn(input string mnemonic);\n    data_accessed = RS1 | RS2 | RS3 | RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,x%0d,x%0d,x%0d\", mnemonic, rvfi_rd_addr, rvfi_rs1_addr,\n        rvfi_rs3_addr, rvfi_rs2_addr);\n  endfunction\n\n  function automatic void decode_i_insn(input string mnemonic);\n    data_accessed = RS1 | RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,x%0d,%0d\", mnemonic, rvfi_rd_addr, rvfi_rs1_addr,\n                    $signed({{20 {rvfi_insn[31]}}, rvfi_insn[31:20]}));\n  endfunction\n\n  function automatic void decode_i_shift_insn(input string mnemonic);\n    // SLLI, SRLI, SRAI, SROI, SLOI, RORI\n    logic [4:0] shamt;\n    shamt = {rvfi_insn[24:20]};\n    data_accessed = RS1 | RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,x%0d,0x%0x\", mnemonic, rvfi_rd_addr, rvfi_rs1_addr, shamt);\n  endfunction\n\n  function automatic void decode_i_funnelshift_insn( input string mnemonic);\n    // fsri\n    logic [5:0] shamt;\n    shamt = {rvfi_insn[25:20]};\n    data_accessed = RS1 | RS3 | RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,x%0d,x%0d,0x%0x\", mnemonic, rvfi_rd_addr, rvfi_rs1_addr,\n        rvfi_rs3_addr, shamt);\n  endfunction\n\n  function automatic void decode_i_jalr_insn(input string mnemonic);\n    // JALR\n    data_accessed = RS1 | RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,%0d(x%0d)\", mnemonic, rvfi_rd_addr,\n        $signed({{20 {rvfi_insn[31]}}, rvfi_insn[31:20]}), rvfi_rs1_addr);\n  endfunction\n\n  function automatic void decode_u_insn(input string mnemonic);\n    data_accessed = RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,0x%0x\", mnemonic, rvfi_rd_addr, {rvfi_insn[31:12]});\n  endfunction\n\n  function automatic void decode_j_insn(input string mnemonic);\n    // JAL\n    data_accessed = RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,%0x\", mnemonic, rvfi_rd_addr, rvfi_pc_wdata);\n  endfunction\n\n  function automatic void decode_b_insn(input string mnemonic);\n    logic [31:0] branch_target;\n    logic [31:0] imm;\n\n    // We cannot use rvfi_pc_wdata for conditional jumps.\n    imm = $signed({ {19 {rvfi_insn[31]}}, rvfi_insn[31], rvfi_insn[7],\n             rvfi_insn[30:25], rvfi_insn[11:8], 1'b0 });\n    branch_target = rvfi_pc_rdata + imm;\n\n    data_accessed = RS1 | RS2;\n    decoded_str = $sformatf(\"%s\\tx%0d,x%0d,%0x\",\n                            mnemonic, rvfi_rs1_addr, rvfi_rs2_addr, branch_target);\n  endfunction\n\n  function automatic void decode_csr_insn(input string mnemonic);\n    logic [11:0] csr;\n    string csr_name;\n    csr = rvfi_insn[31:20];\n    csr_name = get_csr_name(csr);\n\n    data_accessed = RD;\n\n    if (!rvfi_insn[14]) begin\n      data_accessed |= RS1;\n      decoded_str = $sformatf(\"%s\\tx%0d,%s,x%0d\",\n                              mnemonic, rvfi_rd_addr, csr_name, rvfi_rs1_addr);\n    end else begin\n      decoded_str = $sformatf(\"%s\\tx%0d,%s,%0d\",\n                              mnemonic, rvfi_rd_addr, csr_name, {27'b0, rvfi_insn[19:15]});\n    end\n  endfunction\n\n  function automatic void decode_cr_insn(input string mnemonic);\n    if (rvfi_rs2_addr == 5'b0) begin\n      if (rvfi_insn[12] == 1'b1) begin\n        // C.JALR\n        data_accessed = RS1 | RD;\n      end else begin\n        // C.JR\n        data_accessed = RS1;\n      end\n      decoded_str = $sformatf(\"%s\\tx%0d\", mnemonic, rvfi_rs1_addr);\n    end else begin\n      data_accessed = RS1 | RS2 | RD; // RS1 == RD\n      decoded_str = $sformatf(\"%s\\tx%0d,x%0d\", mnemonic, rvfi_rd_addr, rvfi_rs2_addr);\n    end\n  endfunction\n\n  function automatic void decode_ci_cli_insn(input string mnemonic);\n    logic [5:0] imm;\n    imm = {rvfi_insn[12], rvfi_insn[6:2]};\n    data_accessed = RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,%0d\", mnemonic, rvfi_rd_addr, $signed(imm));\n  endfunction\n\n  function automatic void decode_ci_caddi_insn(input string mnemonic);\n    logic [5:0] nzimm;\n    nzimm = {rvfi_insn[12], rvfi_insn[6:2]};\n    data_accessed = RS1 | RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,%0d\", mnemonic, rvfi_rd_addr, $signed(nzimm));\n  endfunction\n\n  function automatic void decode_ci_caddi16sp_insn(input string mnemonic);\n    logic [9:0] nzimm;\n    nzimm = {rvfi_insn[12], rvfi_insn[4:3], rvfi_insn[5], rvfi_insn[2], rvfi_insn[6], 4'b0};\n    data_accessed = RS1 | RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,%0d\", mnemonic, "}
{"text": "rvfi_rd_addr, $signed(nzimm));\n  endfunction\n\n  function automatic void decode_ci_clui_insn(input string mnemonic);\n    logic [5:0] nzimm;\n    nzimm = {rvfi_insn[12], rvfi_insn[6:2]};\n    data_accessed = RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,0x%0x\", mnemonic, rvfi_rd_addr, 20'($signed(nzimm)));\n  endfunction\n\n  function automatic void decode_ci_cslli_insn(input string mnemonic);\n    logic [5:0] shamt;\n    shamt = {rvfi_insn[12], rvfi_insn[6:2]};\n    data_accessed = RS1 | RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,0x%0x\", mnemonic, rvfi_rd_addr, shamt);\n  endfunction\n\n  function automatic void decode_ciw_insn(input string mnemonic);\n    // C.ADDI4SPN\n    logic [9:0] nzuimm;\n    nzuimm = {rvfi_insn[10:7], rvfi_insn[12:11], rvfi_insn[5], rvfi_insn[6], 2'b00};\n    data_accessed = RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,x2,%0d\", mnemonic, rvfi_rd_addr, nzuimm);\n  endfunction\n\n  function automatic void decode_cb_sr_insn(input string mnemonic);\n    logic [5:0] shamt;\n    shamt = {rvfi_insn[12], rvfi_insn[6:2]};\n    data_accessed = RS1 | RD;\n    decoded_str = $sformatf(\"%s\\tx%0d,0x%0x\", mnemonic, rvfi_rs1_addr, shamt);\n  endfunction\n\n  function automatic void decode_cb_insn(input string mnemonic);\n    logic [7:0] imm;\n    logic [31:0] jump_target;\n    if (rvfi_insn[15:13] == 3'b110 || rvfi_insn[15:13] == 3'b111) begin\n      // C.BNEZ and C.BEQZ\n      // We cannot use rvfi_pc_wdata for conditional jumps.\n      imm = {rvfi_insn[12], rvfi_insn[6:5], rvfi_insn[2], rvfi_insn[11:10], rvfi_insn[4:3]};\n      jump_target = rvfi_pc_rdata + 32'($signed({imm, 1'b0}));\n      data_accessed = RS1;\n      decoded_str = $sformatf(\"%s\\tx%0d,%0x\", mnemonic, rvfi_rs1_addr, jump_target);\n    end else if (rvfi_insn[15:13] == 3'b100) begin\n      // C.ANDI\n      imm = {{2{rvfi_insn[12]}}, rvfi_insn[12], rvfi_insn[6:2]};\n      data_accessed = RS1 | RD; // RS1 == RD\n      decoded_str = $sformatf(\"%s\\tx%0d,%0d\", mnemonic, rvfi_rd_addr, $signed(imm));\n    end else begin\n      imm = {rvfi_insn[12], rvfi_insn[6:2], 2'b00};\n      data_accessed = RS1;\n      decoded_str = $sformatf(\"%s\\tx%0d,0x%0x\", mnemonic, rvfi_rs1_addr, imm);\n    end\n  endfunction\n\n  function automatic void decode_cs_insn(input string mnemonic);\n    data_accessed = RS1 | RS2 | RD; // RS1 == RD\n    decoded_str = $sformatf(\"%s\\tx%0d,x%0d\", mnemonic, rvfi_rd_addr, rvfi_rs2_addr);\n  endfunction\n\n  function automatic void decode_cj_insn(input string mnemonic);\n    if (rvfi_insn[15:13] == 3'b001) begin\n      // C.JAL\n      data_accessed = RD;\n    end\n    decoded_str = $sformatf(\"%s\\t%0x\", mnemonic, rvfi_pc_wdata);\n  endfunction\n\n  function automatic void decode_compressed_load_insn(input string mnemonic);\n    logic [7:0] imm;\n\n    if (rvfi_insn[1:0] == OPCODE_C0) begin\n      // C.LW\n      imm = {1'b0, rvfi_insn[5], rvfi_insn[12:10], rvfi_insn[6], 2'b00};\n    end else begin\n      // C.LWSP\n      imm = {rvfi_insn[3:2], rvfi_insn[12], rvfi_insn[6:4], 2'b00};\n    end\n    data_accessed = RS1 | RD | MEM;\n    decoded_str = $sformatf(\"%s\\tx%0d,%0d(x%0d)\", mnemonic, rvfi_rd_addr, imm, rvfi_rs1_addr);\n  endfunction\n\n  function automatic void decode_compressed_store_insn(input string mnemonic);\n    logic [7:0] imm;\n    if (rvfi_insn[1:0] == OPCODE_C0) begin\n      // C.SW\n      imm = {1'b0, rvfi_insn[5], rvfi_insn[12:10], rvfi_insn[6], 2'b00};\n    end else begin\n      // C.SWSP\n      imm = {rvfi_insn[8:7], rvfi_insn[12:9], 2'b00};\n    end\n    data_accessed = RS1 | RS2 | MEM;\n    decoded_str = $sformatf(\"%s\\tx%0d,%0d(x%0d)\", mnemonic, rvfi_rs2_addr, imm, rvfi_rs1_addr);\n  endfunction\n\n  function automatic void decode_load_insn();\n    string      mnemonic;\n\n    /*\n    Gives wrong results in Verilator < 4.020.\n    See https://github.com/lowRISC/ibex/issues/372 and\n    https://www.veripool.org/issues/1536-Verilator-Misoptimization-in-if-and-case-with-default-statement-inside-a-function\n\n    unique case (rvfi_insn[14:12])\n      3'b000: mnemonic = \"lb\";\n      3'b001: mnemonic = \"lh\";\n      3'b010: mnemonic = \"lw\";\n      3'b100: mnemonic = \"lbu\";\n      3'b101: mnemonic = \"lhu\";\n      default: begin\n        decode_mnemonic(\"INVALID\");\n        return;\n      end\n    endcase\n    */\n    logic [2:0] size;\n    size = rvfi_insn[14:12];\n    if (size == 3'b000) begin\n      mnemonic = \"lb\";\n    end else if (size == 3'b001) begin\n      mnemonic = \"lh\";\n    end else if (size == 3'b010) begin\n      mnemonic = \"lw\";\n    end else if (size == 3'b100) begin\n      mnemonic = \"lbu\";\n    end else if (size == 3'b101) begin\n      mnemonic = \"lhu\";\n    end else begin\n      decode_mnemonic(\"INVALID\");\n      return;\n    end\n\n\n    data_accessed = RD | RS1 | MEM;\n    decoded_str = $sformatf(\"%s\\tx%0d,%0d(x%0d)\", mnemonic, rvfi_rd_addr,\n                    $signed({{20 {rvfi_insn[31]}}, rvfi_insn[31:20]}), rvfi_rs1_addr);\n  endfunction\n\n  function automatic void decode_store_insn();\n    string    mnemonic;\n\n    unique case (rvfi_insn[13:12])\n      2'b00:  mnemonic = \"sb\";\n      2'b01:  mnemonic = \"sh\";\n      2'b10:  mnemonic = \"sw\";\n      default: begin\n        decode_mnemonic(\"INVALID\");\n        return;\n      end\n    endcase\n\n    if (!rvfi_insn[14]) begin\n      // regular store\n      data_accessed = RS1 | RS2 | MEM;\n      decoded_str = $sformatf(\"%s\\tx%0d,%0d(x%0d)\",\n                              mnemonic,\n                              rvfi_rs2_addr,\n                              $signed({{20{rvfi_insn[31]}}, rvfi_insn[31:25], rvfi_insn[11:7]}),\n                              rvfi_rs1_addr);\n    end else begin\n      decode_mnemonic(\"INVALID\");\n    end\n  endfunction\n\n  function automatic string get_fence_description(logic [3:0] bits);\n    string desc = \"\";\n    if (bits[3]) begin\n      desc = {desc, \"i\"};\n    end\n    if (bits[2]) begin\n      desc = {desc, \"o\"};\n    end\n    if (bits[1]) begin\n      desc = {desc, \"r\"};\n    end\n    if (bits[0]) begin\n      desc = {desc, \"w\"};\n    end\n    return desc;\n  endfunction\n\n  function automatic void decode_fence();\n    string predecessor;\n    string successor;\n    predecessor = get_fence_description(rvfi_insn[27:24]);\n    successor = get_fence_description(rvfi_insn[23:20]);\n    decoded_str = $sformatf(\"fence\\t%s,%s\", predecessor, successor);\n  endfunction\n\n  // cycle counter\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      cycle <= 0;\n    end else begin\n      cycle <= cycle + 1;\n    end\n  end\n\n  // close output file for writing\n  final begin\n    if (file_handle != 32'h0) begin\n      // This dance with \"fh\" is a bit silly. Some versions of Verilator treat a call of $fclose(xx)\n      // as a blocking assignment to xx. They then complain about the mixture with that an the\n      // non-blocking assignment we use when opening the file. The bug is fixed with recent versions\n      // of Verilator, but this hack is probably worth it for now.\n      int fh = file_handle;\n      $fclose(fh);\n    end\n  end\n\n  // log execution\n  always @(posedge clk_i) begin\n    if (rvfi_valid && trace_log_enable) begin\n\n      int fh = file_handle;\n\n      if (fh == 32'h0) begin\n        string file_name_base = \"trace_core\";\n        void'($value$plusargs(\"ibex_tracer_file_base=%s\", file_name_base));\n        $sformat(file_name, \"%s_%h.log\", file_name_base, hart_id_i);\n\n        $display(\"%m: Writing execution trace to %s\", file_name);\n        fh = $fopen(file_name, \"w\");\n        file_handle <= fh;\n        $fwrite(fh, \"Time\\tCycle\\tPC\\tInsn\\tDecoded instruction\\tRegister and memory contents\\n\");\n      end\n\n      printbuffer_dumpline(fh);\n    end\n  end\n\n  always_comb begin\n    decoded_str = \"\";\n    data_accessed = 5'h0;\n    insn_is_compressed = 0;\n\n    // Check for compressed instructions\n    if (rvfi_insn[1:0] != 2'b11) begin\n      insn_is_compressed = 1;\n      // Separate case to avoid overlapping decoding\n      if (rvfi_insn[15:13] == INSN_CMV[15:13] && rvfi_insn[1:0] == OPCODE_C2) begin\n        if (rvfi_insn[12] == INSN_CADD[12]) begin\n          if (rvfi_insn[11:2] == INSN_CEBREAK[11:2]) begin\n            decode_mnemonic(\"c.ebreak\");\n          end else if (rvfi_insn[6:2] == INSN_CJALR[6:2]) begin\n            decode_cr_insn(\"c.jalr\");\n          end else begin\n            decode_cr_insn(\"c.add\");\n          end\n        end else begin\n          if (rvfi_insn[6:2] == INSN_CJR[6:2]) begin\n            decode_cr_insn(\"c.jr\");\n          end else begin\n            decode_cr_insn(\"c.mv\");\n          end\n        end\n      end else begin\n        unique casez (rvfi_insn[15:0])\n          // C0 Opcodes\n          INSN_CADDI4SPN: begin\n            if (rvfi_insn[12:2] == 11'h0) begin\n              // Align with pseudo-mnemonic used by GNU binutils and LLVM's MC layer\n              decode_mnemonic(\"c.unimp\");\n            end else begin\n              decode_ciw_insn(\"c.addi4spn\");\n            end\n          end\n          INSN_CLW:        decode_compressed_load_insn(\"c.lw\");\n          INSN_CSW:        decode_compressed_store_insn(\"c.sw\");\n          // C1 Opcodes\n          INSN_CADDI:      decode_ci_caddi_insn(\"c.addi\");\n          INSN_CJAL:       decode_cj_insn(\"c.jal\");\n          INSN_CJ:         decode_cj_insn(\"c.j\");\n          INSN_CLI:        decode_ci_cli_insn(\"c.li\");\n          INSN_CLUI: begin\n            // These two instructions share opcode\n            if (rvfi_insn[11:7] == 5'd2) begin\n              decode_ci_caddi16sp_insn(\"c.addi16sp\");\n            end else begin\n              decode_ci_clui_insn(\"c.lui\");\n            end\n          end\n          INSN_CSRLI:      decode_cb_sr_insn(\"c.srli\");\n          INSN_CSRAI:      decode_cb_sr_insn(\"c.srai\");\n          INSN_CANDI:      decode_cb_insn(\"c.andi\");\n          INSN_CSUB:       decode_cs_insn(\"c.sub\");\n          INSN_CXOR:       decode_cs_insn(\"c.xor\");\n          INSN_COR:        decode_cs_insn(\"c.or\");\n          INSN_CAND:       decode_cs_insn(\"c.and\");\n          INSN_CBEQZ:      decode_cb_insn(\"c.beqz\");\n          INSN_CBNEZ:      decode_cb_insn(\"c.bnez\");\n          // C2 Opcodes\n          INSN_CSLLI:      decode_ci_cslli_insn(\"c.slli\");\n          INSN_CLWSP:      decode_compressed_load_insn(\"c.lwsp\");\n          INSN_SWSP:       decode_compressed_store_insn(\"c.swsp\");\n          default:         decode_mnemonic(\"INVALID\");\n        endcase\n      end\n    end else begin\n      unique casez (rvfi_insn)\n        // Regular opcodes\n        INSN_LUI:        decode_u_insn(\"lui\");\n        INSN_AUIPC:      decode_u_insn(\"auipc\");\n        INSN_JAL:        decode_j_insn(\"jal\");\n        INSN_JALR:       decode_i_jalr_insn(\"jalr\");\n        // BRANCH\n        INSN_BEQ:        decode_b_insn(\"beq\");\n        INSN_BNE:        decode_b_insn(\"bne\");\n        INSN_BLT:        decode_b_insn(\"blt\");\n        INSN_BGE:        decode_b_insn(\"bge\");\n        INSN_BLTU:       decode_b_insn(\"bltu\");\n        INSN_BGEU:       decode_b_insn(\"bgeu\");\n        // OPIMM\n        INSN_ADDI: begin\n          if (rvfi_insn == 32'h00_00_00_13) begin\n            // TODO: objdump doesn't decode this as nop currently, even though it would be helpful\n            // Decide what to do here: diverge from objdump, or make the trace less readable to\n            // users.\n            //decode_mnemonic(\"nop\");\n            decode_i_insn(\"addi\");\n          end else begin\n            decode_i_insn(\"addi\");\n          end\n        end\n        INSN_SLTI:       decode_i_insn(\"slti\");\n        INSN_SLTIU:      decode_i_insn(\"sltiu\");\n        INSN_XORI:       decode_i_insn(\"xori\");\n        INSN_ORI:        decode_i_insn(\"ori\");\n        // Unlike the ratified v.1.0.0 bitmanip extension, the v.0.94 draft extension continues to\n        // define the pseudo-instruction\n        //   zext.b rd rs = andi rd, rs, 255.\n        // However, for now the tracer doesn't emit this due to a lack of support in the LLVM and\n        // GCC toolchains. Enabling this functionality when the time is right is tracked in\n        // https://github.com/lowRISC/ibex/issues/1228\n        INSN_ANDI:       decode_i_insn(\"andi\");\n        // INSN_ANDI:begin\n          // casez (rvfi_insn)\n            // INSN_ZEXTB:  decode_r1_insn(\"zext.b\");\n            // default:     decode_i_insn(\"andi\");\n          // endcase\n        // end\n        INSN_SLLI:       decode_i_shift_insn(\"slli\");\n        INSN_SRLI:       decode_i_shift_insn(\"srli\");\n        INSN_SRAI:       decode_i_shift_insn(\"srai\");\n        // OP\n        INSN_ADD:        decode_r_insn(\"add\");\n        INSN_SUB:        decode_r_insn(\"sub\");\n        INSN_SLL:        decode_r_insn(\"sll\");\n        INSN_SLT:        decode_r_insn(\"slt\");\n        INSN_SLTU:       decode_r_insn(\"sltu\");\n        INSN_XOR:        decode_r_insn(\"xor\");\n        INSN_SRL:        decode_r_insn(\"srl\");\n        INSN_SRA:        decode_r_insn(\"sra\");\n        INSN_OR:         decode_r_insn(\"or\");\n        INSN_AND:        decode_r_insn(\"and\");\n        // SYSTEM (CSR manipulation)\n        INSN_CSRRW:      decode_csr_insn(\"csrrw\");\n        INSN_CSRRS:      decode_csr_insn(\"csrrs\");\n        INSN_CSRRC:      decode_csr_insn(\"csrrc\");\n        INSN_CSRRWI:     decode_csr_insn(\"csrrwi\");\n        INSN_CSRRSI:     decode_csr_insn(\"csrrsi\");\n        INSN_CSRRCI:     decode_csr_insn(\"csrrci\");\n        // SYSTEM (others)\n        INSN_ECALL:      decode_mnemonic(\"ecall\");\n        INSN_EBREAK:     decode_mnemonic(\"ebreak\");\n        INSN_MRET:       decode_mnemonic(\"mret\");\n        INSN_DRET:       decode_mnemonic(\"dret\");\n        INSN_WFI:        decode_mnemonic(\"wfi\");\n        // RV32M\n        INSN_PMUL:       decode_r_insn(\"mul\");\n        INSN_PMUH:       decode_r_insn(\"mulh\");\n        INSN_PMULHSU:    decode_r_insn(\"mulhsu\");\n        INSN_PMULHU:     decode_r_insn(\"mulhu\");\n        INSN_DIV:        decode_r_insn(\"div\");\n        INSN_DIVU:       decode_r_insn(\"divu\");\n        INSN_REM:        decode_r_insn(\"rem\");\n        INSN_REMU:       decode_r_insn(\"remu\");\n        // LOAD & STORE\n        INSN_LOAD:       decode_load_insn();\n        INSN_STORE:      decode_store_insn();\n        // MISC-MEM\n        INSN_FENCE:      decode_fence();\n        INSN_FENCEI:     decode_mnemonic(\"fence.i\");\n        // RV32B - ZBA\n        INSN_SH1ADD:     decode_r_insn(\"sh1add\");\n        INSN_SH2ADD:     decode_r_insn(\"sh2add\");\n        INSN_SH3ADD:     decode_r_insn(\"sh3add\");\n        // RV32B - ZBB\n        INSN_RORI:       decode_i_shift_insn(\"rori\");\n        INSN_ROL:        decode_r_insn(\"rol\");\n        INSN_ROR:        decode_r_insn(\"ror\");\n        INSN_MIN:        decode_r_insn(\"min\");\n        INSN_MAX:        decode_r_insn(\"max\");\n        INSN_MINU:       decode_r_insn(\"minu\");\n        INSN_MAXU:       decode_r_insn(\"maxu\");\n        INSN_XNOR:       decode_r_insn(\"xnor\");\n        INSN_ORN:        decode_r_insn(\"orn\");\n        INSN_ANDN:       decode_r_insn(\"andn\");\n        // The ratified v.1.0.0 bitmanip extension defines the pseudo-instruction\n        //   zext.h rd rs = pack rd, rs, zero.\n        // However, for now the tracer doesn't emit this due to a lack of support in the LLVM and\n        // GCC toolchains. Enabling this functionality when the time is right is tracked in\n        // https://github.com/lowRISC/ibex/issues/1228\n        INSN_PACK:       decode_r_insn(\"pack\");\n        // INSN_PACK: begin\n          // casez (rvfi_insn)\n            // INSN_ZEXTH:  decode_r1_insn(\"zext.h\");\n            // default:     decode_r_insn(\"pack\");\n          // endcase\n        // end\n        INSN_PACKH:      decode_r_insn(\"packh\");\n        INSN_PACKU:      decode_r_insn(\"packu\");\n        INSN_CLZ:        decode_r1_insn(\"clz\");\n        INSN_CTZ:        decode_r1_insn(\"ctz\");\n        INSN_CPOP:       decode_r1_insn(\"cpop\");\n        INSN_SEXTB:      decode_r1_insn(\"sext.b\");\n        INSN_SEXTH:      decode_r1_insn(\"sext.h\");\n        // RV32B - ZBS\n        INSN_BCLRI:     decode_i_shift_insn(\"bclri\");\n        INSN_BSETI:     decode_i_shift_insn(\"bseti\");\n        INSN_BINVI:     decode_i_shift_insn(\"binvi\");\n        INSN_BEXTI:     decode_i_shift_insn(\"bexti\");\n        INSN_BCLR:      decode_r_insn(\"bclr\");\n        INSN_BSET:      decode_r_insn(\"bset\");\n        INSN_BINV:      decode_r_insn(\"binv\");\n        INSN_BEXT:      decode_r_insn(\"bext\");\n        // RV32B - ZBE\n        INSN_BDECOMPRESS: decode_r_insn(\"bdecompress\");\n        INSN_BCOMPRESS:   decode_r_insn(\"bcompress\");\n        // RV32B - ZBP\n        INSN_GREV:       decode_r_insn(\"grev\");\n        INSN_GREVI: begin\n          unique casez (rvfi_insn)\n            INSN_REV_P:  decode_r1_insn(\"rev.p\");\n            INSN_REV2_N: decode_r1_insn(\"rev2.n\");\n            INSN_REV_N:  decode_r1_insn(\"rev.n\");\n            INSN_REV4_B: decode_r1_insn(\"rev4.b\");\n            INSN_REV2_B: decode_r1_insn(\"rev2.b\");\n            INSN_REV_B:  decode_r1_insn(\"rev.b\");\n            INSN_REV8_H: decode_r1_insn(\"rev8.h\");\n            INSN_REV4_H: decode_r1_insn(\"rev4.h\");\n            INSN_REV2_H: decode_r1_insn(\"rev2.h\");\n            INSN_REV_H:  decode_r1_insn(\"rev.h\");\n            INSN_REV16:  decode_r1_insn(\"rev16\");\n            INSN_REV8:   decode_r1_insn(\"rev8\");\n            INSN_REV4:   decode_r1_insn(\"rev4\");\n            INSN_REV2:   decode_r1_insn(\"rev2\");\n            INSN_REV:    decode_r1_insn(\"rev\");\n            default:     decode_i_insn(\"grevi\");\n          endcase\n        end\n        INSN_GORC:       decode_r_insn(\"gorc\");\n        INSN_GORCI: begin\n          unique casez (rvfi_insn)\n            INSN_ORC_P:  decode_r1_insn(\"orc.p\");\n            INSN_ORC2_N: decode_r1_insn(\"orc2.n\");\n            INSN_ORC_N:  decode_r1_insn(\"orc.n\");\n            INSN_ORC4_B: decode_r1_insn(\"orc4.b\");\n            INSN_ORC2_B: decode_r1_insn(\"orc2.b\");\n            INSN_ORC_B:  decode_r1_insn(\"orc.b\");\n            INSN_ORC8_H: decode_r1_insn(\"orc8.h\");\n            INSN_ORC4_H: decode_r1_insn(\"orc4.h\");\n            INSN_ORC2_H: decode_r1_insn(\"orc2.h\");\n            INSN_ORC_H:  decode_r1_insn(\"orc.h\");\n            INSN_ORC16:  decode_r1_insn(\"orc16\");\n            INSN_ORC8:   decode_r1_insn(\"orc8\");\n            INSN_ORC4:   decode_r1_insn(\"orc4\");\n            INSN_ORC2:   decode_r1_insn(\"orc2\");\n            INSN_ORC:    decode_r1_insn(\"orc\");\n            default:     decode_i_insn(\"gorci\");\n          endcase\n        end\n        INSN_SHFL:       decode_r_insn(\"shfl\");\n        INSN_SHFLI: begin\n          unique casez (rvfi_insn)\n            INSN_ZIP_N:  decode_r1_insn(\"zip.n\");\n            INSN_ZIP2_B: decode_r1_insn(\"zip2.b\");\n            INSN_ZIP_B:  decode_r1_insn(\"zip.b\");\n            INSN_ZIP4_H: decode_r1_insn(\"zip4.h\");\n            INSN_ZIP2_H: decode_r1_insn(\"zip2.h\");\n            INSN_ZIP_H:  decode_r1_insn(\"zip.h\");\n            INSN_ZIP8:   decode_r1_insn(\"zip8\");\n            INSN_ZIP4:   decode_r1_insn(\"zip4\");\n            INSN_ZIP2:   decode_r1_insn(\"zip2\");\n            INSN_ZIP:    decode_r1_insn(\"zip\");\n            default:     decode_i_insn(\"shfli\");\n          endcase\n        end\n        INSN_UNSHFL:       decode_r_insn(\"unshfl\");\n        INSN_UNSHFLI: begin\n          unique casez (rvfi_insn)\n            INSN_UNZIP_N:  decode_r1_insn(\"unzip.n\");\n            INSN_UNZIP2_B: decode_r1_insn(\"unzip2.b\");\n            INSN_UNZIP_B:  decode_r1_insn(\"unzip.b\");\n            INSN_UNZIP4_H: decode_r1_insn(\"unzip4.h\");\n            INSN_UNZIP2_H: decode_r1_insn(\"unzip2.h\");\n            INSN_UNZIP_H:  decode_r1_insn(\"unzip.h\");\n            INSN_UNZIP8:   decode_r1_insn(\"unzip8\");\n            INSN_UNZIP4:   decode_r1_insn(\"unzip4\");\n            INSN_UNZIP2:   decode_r1_insn(\"unzip2\");\n            INSN_UNZIP:    decode_r1_insn(\"unzip\");\n            default:       decode_i_insn(\"unshfli\");\n          endcase\n        end\n        INSN_XPERM_N:    decode_r_insn(\"xperm_n\");\n        INSN_XPERM_B:    decode_r_insn(\"xperm_b\");\n        INSN_XPERM_H:    decode_r_insn(\"xperm_h\");\n        INSN_SLO:        decode_r_insn(\"slo\");\n        INSN_SRO:        decode_r_insn(\"sro\");\n        INSN_SLOI:       decode_i_shift_insn(\"sloi\");\n        INSN_SROI:       decode_i_shift_insn(\"sroi\");\n\n        // RV32B - ZBT\n        INSN_CMIX:       decode_r_cmixcmov_insn(\"cmix\");\n        INSN_CMOV:       "}
{"text": "decode_r_cmixcmov_insn(\"cmov\");\n        INSN_FSR:        decode_r_funnelshift_insn(\"fsr\");\n        INSN_FSL:        decode_r_funnelshift_insn(\"fsl\");\n        INSN_FSRI:       decode_i_funnelshift_insn(\"fsri\");\n\n        // RV32B - ZBF\n        INSN_BFP:        decode_r_insn(\"bfp\");\n\n        // RV32B - ZBC\n        INSN_CLMUL:      decode_r_insn(\"clmul\");\n        INSN_CLMULR:     decode_r_insn(\"clmulr\");\n        INSN_CLMULH:     decode_r_insn(\"clmulh\");\n\n        // RV32B - ZBR\n        INSN_CRC32_B:    decode_r1_insn(\"crc32.b\");\n        INSN_CRC32_H:    decode_r1_insn(\"crc32.h\");\n        INSN_CRC32_W:    decode_r1_insn(\"crc32.w\");\n        INSN_CRC32C_B:   decode_r1_insn(\"crc32c.b\");\n        INSN_CRC32C_H:   decode_r1_insn(\"crc32c.h\");\n        INSN_CRC32C_W:   decode_r1_insn(\"crc32c.w\");\n\n        default:         decode_mnemonic(\"INVALID\");\n      endcase\n    end\n  end\n\nendmodule\n"}
{"text": "// Copyright lowRISC contributors.\n// Copyright 2017 ETH Zurich and University of Bologna, see also CREDITS.md.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\npackage ibex_tracer_pkg;\n  import ibex_pkg::*;\n\n  parameter logic [1:0] OPCODE_C0 = 2'b00;\n  parameter logic [1:0] OPCODE_C1 = 2'b01;\n  parameter logic [1:0] OPCODE_C2 = 2'b10;\n\n  // instruction masks (for tracer)\n  parameter logic [31:0] INSN_LUI     = { 25'h?,                           {OPCODE_LUI  } };\n  parameter logic [31:0] INSN_AUIPC   = { 25'h?,                           {OPCODE_AUIPC} };\n  parameter logic [31:0] INSN_JAL     = { 25'h?,                           {OPCODE_JAL  } };\n  parameter logic [31:0] INSN_JALR    = { 17'h?,             3'b000, 5'h?, {OPCODE_JALR } };\n\n  // BRANCH\n  parameter logic [31:0] INSN_BEQ     = { 17'h?,             3'b000, 5'h?, {OPCODE_BRANCH} };\n  parameter logic [31:0] INSN_BNE     = { 17'h?,             3'b001, 5'h?, {OPCODE_BRANCH} };\n  parameter logic [31:0] INSN_BLT     = { 17'h?,             3'b100, 5'h?, {OPCODE_BRANCH} };\n  parameter logic [31:0] INSN_BGE     = { 17'h?,             3'b101, 5'h?, {OPCODE_BRANCH} };\n  parameter logic [31:0] INSN_BLTU    = { 17'h?,             3'b110, 5'h?, {OPCODE_BRANCH} };\n  parameter logic [31:0] INSN_BGEU    = { 17'h?,             3'b111, 5'h?, {OPCODE_BRANCH} };\n\n  // OPIMM\n  parameter logic [31:0] INSN_ADDI    = { 17'h?,             3'b000, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_SLTI    = { 17'h?,             3'b010, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_SLTIU   = { 17'h?,             3'b011, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_XORI    = { 17'h?,             3'b100, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORI     = { 17'h?,             3'b110, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ANDI    = { 17'h?,             3'b111, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_SLLI    = { 7'b0000000, 10'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_SRLI    = { 7'b0000000, 10'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_SRAI    = { 7'b0100000, 10'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n\n  // OP\n  parameter logic [31:0] INSN_ADD     = { 7'b0000000, 10'h?, 3'b000, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_SUB     = { 7'b0100000, 10'h?, 3'b000, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_SLL     = { 7'b0000000, 10'h?, 3'b001, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_SLT     = { 7'b0000000, 10'h?, 3'b010, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_SLTU    = { 7'b0000000, 10'h?, 3'b011, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_XOR     = { 7'b0000000, 10'h?, 3'b100, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_SRL     = { 7'b0000000, 10'h?, 3'b101, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_SRA     = { 7'b0100000, 10'h?, 3'b101, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_OR      = { 7'b0000000, 10'h?, 3'b110, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_AND     = { 7'b0000000, 10'h?, 3'b111, 5'h?, {OPCODE_OP} };\n\n  // SYSTEM\n  parameter logic [31:0] INSN_CSRRW   = { 17'h?,             3'b001, 5'h?, {OPCODE_SYSTEM} };\n  parameter logic [31:0] INSN_CSRRS   = { 17'h?,             3'b010, 5'h?, {OPCODE_SYSTEM} };\n  parameter logic [31:0] INSN_CSRRC   = { 17'h?,             3'b011, 5'h?, {OPCODE_SYSTEM} };\n  parameter logic [31:0] INSN_CSRRWI  = { 17'h?,             3'b101, 5'h?, {OPCODE_SYSTEM} };\n  parameter logic [31:0] INSN_CSRRSI  = { 17'h?,             3'b110, 5'h?, {OPCODE_SYSTEM} };\n  parameter logic [31:0] INSN_CSRRCI  = { 17'h?,             3'b111, 5'h?, {OPCODE_SYSTEM} };\n  parameter logic [31:0] INSN_ECALL   = { 12'b000000000000,         13'b0, {OPCODE_SYSTEM} };\n  parameter logic [31:0] INSN_EBREAK  = { 12'b000000000001,         13'b0, {OPCODE_SYSTEM} };\n  parameter logic [31:0] INSN_MRET    = { 12'b001100000010,         13'b0, {OPCODE_SYSTEM} };\n  parameter logic [31:0] INSN_DRET    = { 12'b011110110010,         13'b0, {OPCODE_SYSTEM} };\n  parameter logic [31:0] INSN_WFI     = { 12'b000100000101,         13'b0, {OPCODE_SYSTEM} };\n\n  // RV32M\n  parameter logic [31:0] INSN_DIV     = { 7'b0000001, 10'h?, 3'b100, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_DIVU    = { 7'b0000001, 10'h?, 3'b101, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_REM     = { 7'b0000001, 10'h?, 3'b110, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_REMU    = { 7'b0000001, 10'h?, 3'b111, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_PMUL    = { 7'b0000001, 10'h?, 3'b000, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_PMUH    = { 7'b0000001, 10'h?, 3'b001, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_PMULHSU = { 7'b0000001, 10'h?, 3'b010, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_PMULHU  = { 7'b0000001, 10'h?, 3'b011, 5'h?, {OPCODE_OP} };\n\n  // RV32B\n  // ZBA\n  parameter logic [31:0] INSN_SH1ADD = { 7'b0010000, 10'h?, 3'b010, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_SH2ADD = { 7'b0010000, 10'h?, 3'b100, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_SH3ADD = { 7'b0010000, 10'h?, 3'b110, 5'h?, {OPCODE_OP} };\n\n  // ZBB\n  // Only log2(XLEN) bits of the immediate are used. For RV32, this means only the bits in\n  // instr[24:20] are effectively used. Whenever instr[26] is set, sroi/rori is instead decoded as\n  // fsri.\n  parameter logic [31:0] INSN_RORI = { 5'b01100  , 1'b0, 11'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_CLZ  = { 12'b011000000000, 5'h?,  3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_CTZ  = { 12'b011000000001, 5'h?,  3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_CPOP = { 12'b011000000010, 5'h?,  3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_SEXTB = { 12'b011000000100, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_SEXTH = { 12'b011000000101, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n\n  // The zext.h and zext.b pseudo-instructions are defined in the ratified v.1.0.0 and draft v.0.94\n  // specifications of the bitmanip extension, respectively. They are currently not emitted by the\n  // tracer due to a lack of support in the LLVM and GCC toolchains. Enabling this functionality\n  // when the time is right is tracked in https://github.com/lowRISC/ibex/issues/1228\n  // zext.b -- pseudo-instruction: andi rd, rs 255\n  // parameter logic [31:0] INSN_ZEXTB =\n  //     { 4'b0000, 8'b11111111, 5'h?, 3'b111, 5'h?, {OPCODE_OP_IMM} };\n  // zext.h -- pseudo-instruction: pack rd, rs zero\n  // parameter logic [31:0] INSN_ZEXTH = { 7'b0000100, 5'b00000, 5'h?, 3'b100, 5'h?, {OPCODE_OP} };\n\n  parameter logic [31:0] INSN_ROL   = { 7'b0110000, 10'h?, 3'b001, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_ROR   = { 7'b0110000, 10'h?, 3'b101, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_MIN   = { 7'b0000101, 10'h?, 3'b100, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_MAX   = { 7'b0000101, 10'h?, 3'b110, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_MINU  = { 7'b0000101, 10'h?, 3'b101, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_MAXU  = { 7'b0000101, 10'h?, 3'b111, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_XNOR  = { 7'b0100000, 10'h?, 3'b100, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_ORN   = { 7'b0100000, 10'h?, 3'b110, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_ANDN  = { 7'b0100000, 10'h?, 3'b111, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_PACK  = { 7'b0000100, 10'h?, 3'b100, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_PACKU = { 7'b0100100, 10'h?, 3'b100, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_PACKH = { 7'b0000100, 10'h?, 3'b111, 5'h?, {OPCODE_OP} };\n\n  // ZBS\n  parameter logic [31:0] INSN_BCLRI = { 5'b01001, 12'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_BSETI = { 5'b00101, 12'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_BINVI = { 5'b01101, 12'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  // Only log2(XLEN) bits of the immediate are used. For RV32, this means only the bits in\n  // instr[24:20] are effectively used. Whenever instr[26] is set, bexti is instead decoded as fsri.\n  parameter logic [31:0] INSN_BEXTI = { 5'b01001, 1'b0, 11'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n\n  parameter logic [31:0] INSN_BCLR = { 7'b0100100, 10'h?, 3'b001, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_BSET = { 7'b0010100, 10'h?, 3'b001, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_BINV = { 7'b0110100, 10'h?, 3'b001, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_BEXT = { 7'b0100100, 10'h?, 3'b101, 5'h?, {OPCODE_OP} };\n\n  // ZBP\n  // grevi\n  // Only log2(XLEN) bits of the immediate are used. For RV32, this means only the bits in\n  // instr[24:20] are effectively used. Whenever instr[26] is set, grevi is instead decoded as fsri.\n  parameter logic [31:0] INSN_GREVI = { 5'b01101, 1'b0, 11'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  // grevi -- pseudo-instructions\n  parameter logic [31:0] INSN_REV_P =\n      { 5'b01101, 1'b0, 1'b?, 5'b00001, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV2_N =\n      { 5'b01101, 1'b0, 1'b?, 5'b00010, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV_N =\n      { 5'b01101, 1'b0, 1'b?, 5'b00011, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV4_B =\n      { 5'b01101, 1'b0, 1'b?, 5'b00100, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV2_B =\n      { 5'b01101, 1'b0, 1'b?, 5'b00110, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV_B =\n      { 5'b01101, 1'b0, 1'b?, 5'b00111, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV8_H =\n      { 5'b01101, 1'b0, 1'b?, 5'b01000, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV4_H =\n      { 5'b01101, 1'b0, 1'b?, 5'b01100, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV2_H =\n      { 5'b01101, 1'b0, 1'b?, 5'b01110, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV_H =\n      { 5'b01101, 1'b0, 1'b?, 5'b01111, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV16 =\n      { 5'b01101, 1'b0, 1'b?, 5'b10000, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV8 =\n      { 5'b01101, 1'b0, 1'b?, 5'b11000, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV4 =\n      { 5'b01101, 1'b0, 1'b?, 5'b11100, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV2 =\n      { 5'b01101, 1'b0, 1'b?, 5'b11110, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_REV =\n      { 5'b01101, 1'b0, 1'b?, 5'b11111, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  // gorci\n  // Only log2(XLEN) bits of the immediate are used. For RV32, this means only the bits in\n  // instr[24:20] are effectively used. Whenever instr[26] is set, gorci is instead decoded as fsri.\n  parameter logic [31:0] INSN_GORCI = { 5'b00101, 1'b0, 11'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  // gorci -- pseudo-instructions\n  parameter logic [31:0] INSN_ORC_P =\n      { 5'b00101, 1'b0, 1'b?, 5'b00001, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC2_N =\n      { 5'b00101, 1'b0, 1'b?, 5'b00010, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC_N =\n      { 5'b00101, 1'b0, 1'b?, 5'b00011, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC4_B =\n      { 5'b00101, 1'b0, 1'b?, 5'b00100, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC2_B =\n      { 5'b00101, 1'b0, 1'b?, 5'b00110, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC_B =\n      { 5'b00101, 1'b0, 1'b?, 5'b00111, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC8_H =\n      { 5'b00101, 1'b0, 1'b?, 5'b01000, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC4_H =\n      { 5'b00101, 1'b0, 1'b?, 5'b01100, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC2_H =\n      { 5'b00101, 1'b0, 1'b?, 5'b01110, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC_H =\n      { 5'b00101, 1'b0, 1'b?, 5'b01111, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC16 =\n      { 5'b00101, 1'b0, 1'b?, 5'b10000, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC8 =\n      { 5'b00101, 1'b0, 1'b?, 5'b11000, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC4 =\n      { 5'b00101, 1'b0, 1'b?, 5'b11100, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC2 =\n      { 5'b00101, 1'b0, 1'b?, 5'b11110, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ORC =\n      { 5'b00101, 1'b0, 1'b?, 5'b11111, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  // shfli\n  parameter logic [31:0] INSN_SHFLI = { 6'b000010, 11'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  // shfli -- pseudo-instructions\n  parameter logic [31:0] INSN_ZIP_N =\n      { 6'b000010, 2'h?, 4'b0001, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ZIP2_B =\n      { 6'b000010, 2'h?, 4'b0010, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ZIP_B =\n      { 6'b000010, 2'h?, 4'b0011, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ZIP4_H =\n      { 6'b000010, 2'h?, 4'b0100, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ZIP2_H =\n      { 6'b000010, 2'h?, 4'b0110, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ZIP_H =\n      { 6'b000010, 2'h?, 4'b0111, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ZIP8 =\n      { 6'b000010, 2'h?, 4'b1000, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ZIP4 =\n      { 6'b000010, 2'h?, 4'b1100, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ZIP2 =\n      { 6'b000010, 2'h?, 4'b1110, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_ZIP =\n      { 6'b000010, 2'h?, 4'b1111, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  // unshfli\n  parameter logic [31:0] INSN_UNSHFLI = { 6'b000010, 11'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  // unshfli -- pseudo-instructions\n  parameter logic [31:0] INSN_UNZIP_N =\n      { 6'b000010, 2'h?, 4'b0001, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_UNZIP2_B =\n      { 6'b000010, 2'h?, 4'b0010, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_UNZIP_B =\n      { 6'b000010, 2'h?, 4'b0011, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_UNZIP4_H =\n      { 6'b000010, 2'h?, 4'b0100, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_UNZIP2_H =\n      { 6'b000010, 2'h?, 4'b0110, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_UNZIP_H =\n      { 6'b000010, 2'h?, 4'b0111, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_UNZIP8 =\n      { 6'b000010, 2'h?, 4'b1000, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_UNZIP4 =\n      { 6'b000010, 2'h?, 4'b1100, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_UNZIP2 =\n      { 6'b000010, 2'h?, 4'b1110, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_UNZIP =\n      { 6'b000010, 2'h?, 4'b1111, 5'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n\n  parameter logic [31:0] INSN_GREV   = { 7'b0110100, 10'h?, 3'b101, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_GORC   = { 7'b0010100, 10'h?, 3'b101, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_SHFL   = { 7'b0000100, 10'h?, 3'b001, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_UNSHFL = { 7'b0000100, 10'h?, 3'b101, 5'h?, {OPCODE_OP} };\n\n  parameter logic [31:0] INSN_XPERM_N = { 7'b0010100, 10'h?, 3'b010, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_XPERM_B = { 7'b0010100, 10'h?, 3'b100, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_XPERM_H = { 7'b0010100, 10'h?, 3'b110, 5'h?, {OPCODE_OP} };\n\n  parameter logic [31:0] INSN_SLO    = { 7'b0010000, 10'h?, 3'b001, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_SRO    = { 7'b0010000, 10'h?, 3'b101, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_SLOI   = { 5'b00100        , 12'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  // Only log2(XLEN) bits of the immediate are used. For RV32, this means only the bits in\n  // instr[24:20] are effectively used. Whenever instr[26] is set, sroi/rori is instead decoded as\n  // fsri.\n  parameter logic [31:0] INSN_SROI   = { 5'b00100  , 1'b0, 11'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n\n  // ZBE\n  parameter logic [31:0] INSN_BDECOMPRESS = {7'b0100100, 10'h?, 3'b110, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_BCOMPRESS   = {7'b0000100, 10'h?, 3'b110, 5'h?, {OPCODE_OP} };\n\n  // ZBT\n  parameter logic [31:0] INSN_FSRI = { 5'h?, 1'b1, 11'h?, 3'b101, 5'h?, {OPCODE_OP_IMM} };\n\n  parameter logic [31:0] INSN_CMIX = {5'h?, 2'b11, 10'h?, 3'b001, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_CMOV = {5'h?, 2'b11, 10'h?, 3'b101, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_FSL  = {5'h?, 2'b10, 10'h?, 3'b001, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_FSR  = {5'h?, 2'b10, 10'h?, 3'b101, 5'h?, {OPCODE_OP} };\n\n  // ZBF\n  parameter logic [31:0] INSN_BFP  = {7'b0100100, 10'h?, 3'b111, 5'h?, {OPCODE_OP} };\n\n  // ZBC\n  parameter logic [31:0] INSN_CLMUL  = {7'b0000101, 10'h?, 3'b001, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_CLMULR = {7'b0000101, 10'h?, 3'b010, 5'h?, {OPCODE_OP} };\n  parameter logic [31:0] INSN_CLMULH = {7'b0000101, 10'h?, 3'b011, 5'h?, {OPCODE_OP} };\n\n  // ZBR\n  parameter logic [31:0] INSN_CRC32_B  =\n      {7'b0110000, 5'b10000, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_CRC32_H  =\n      {7'b0110000, 5'b10001, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_CRC32_W  =\n      {7'b0110000, 5'b10010, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_CRC32C_B =\n      {7'b0110000, 5'b11000, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_CRC32C_H =\n      {7'b0110000, 5'b11001, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n  parameter logic [31:0] INSN_CRC32C_W =\n      {7'b0110000, 5'b11010, 5'h?, 3'b001, 5'h?, {OPCODE_OP_IMM} };\n\n  // LOAD & STORE\n  parameter logic [31:0] INSN_LOAD    = {25'h?,                            {OPCODE_LOAD } };\n  parameter logic [31:0] INSN_STORE   = {25'h?,                            {OPCODE_STORE} };\n\n  // MISC-MEM\n  parameter logic [31:0] INSN_FENCE   = { 17'h?,             3'b000, 5'h?, {OPCODE_MISC_MEM} };\n  parameter logic [31:0] INSN_FENCEI  = { 17'h0,             3'b001, 5'h0, {OPCODE_MISC_MEM} };\n\n  // Compressed Instructions\n  // C0\n  parameter logic [15:0] INSN_CADDI4SPN  = { 3'b000,       11'h?,                    {OPCODE_C0} };\n  parameter logic [15:0] INSN_CLW        = { 3'b010,       11'h?,                    {OPCODE_C0} };\n  parameter logic [15:0] INSN_CSW        = { 3'b110,       11'h?,                    {OPCODE_C0} };\n\n  // C1\n  parameter logic [15:0] INSN_CADDI      = { 3'b000,       11'h?,                    {OPCODE_C1} };\n  parameter logic [15:0] INSN_CJAL       = { 3'b001,       11'h?,                    {OPCODE_C1} };\n  parameter logic [15:0] INSN_CJ         = { 3'b101,       11'h?,                    {OPCODE_C1} };\n  parameter logic [15:0] INSN_CLI        = { 3'b010,       11'h?,                    {OPCODE_C1} };\n  parameter logic [15:0] INSN_CLUI       = { 3'b011,       11'h?,                    {OPCODE_C1} };\n  parameter logic [15:0] INSN_CBEQZ      = { 3'b110,       11'h?,                    {OPCODE_C1} };\n  parameter logic [15:0] INSN_CBNEZ      = { 3'b111,       11'h?,                    {OPCODE_C1} };\n  parameter logic [15:0] INSN_CSRLI      = { 3'b100, 1'h?, 2'b00, 8'h?,              {OPCODE_C1} };\n  parameter logic [15:0] INSN_CSRAI      = { 3'b100, 1'h?, 2'b01, 8'h?,              {OPCODE_C1} };\n  parameter logic [15:0] INSN_CANDI      = { 3'b100, 1'h?, 2'b"}
{"text": "10, 8'h?,              {OPCODE_C1} };\n  parameter logic [15:0] INSN_CSUB       = { 3'b100, 1'b0, 2'b11, 3'h?, 2'b00, 3'h?, {OPCODE_C1} };\n  parameter logic [15:0] INSN_CXOR       = { 3'b100, 1'b0, 2'b11, 3'h?, 2'b01, 3'h?, {OPCODE_C1} };\n  parameter logic [15:0] INSN_COR        = { 3'b100, 1'b0, 2'b11, 3'h?, 2'b10, 3'h?, {OPCODE_C1} };\n  parameter logic [15:0] INSN_CAND       = { 3'b100, 1'b0, 2'b11, 3'h?, 2'b11, 3'h?, {OPCODE_C1} };\n\n  // C2\n  parameter logic [15:0] INSN_CSLLI      = { 3'b000,       11'h?,                    {OPCODE_C2} };\n  parameter logic [15:0] INSN_CLWSP      = { 3'b010,       11'h?,                    {OPCODE_C2} };\n  parameter logic [15:0] INSN_SWSP       = { 3'b110,       11'h?,                    {OPCODE_C2} };\n  parameter logic [15:0] INSN_CMV        = { 3'b100, 1'b0, 10'h?,                    {OPCODE_C2} };\n  parameter logic [15:0] INSN_CADD       = { 3'b100, 1'b1, 10'h?,                    {OPCODE_C2} };\n  parameter logic [15:0] INSN_CEBREAK    = { 3'b100, 1'b1,        5'h0,  5'h0,       {OPCODE_C2} };\n  parameter logic [15:0] INSN_CJR        = { 3'b100, 1'b0,        5'h0,  5'h0,       {OPCODE_C2} };\n  parameter logic [15:0] INSN_CJALR      = { 3'b100, 1'b1,        5'h?,  5'h0,       {OPCODE_C2} };\n\nendpackage\n"}
{"text": "// Copyright lowRISC contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * Writeback Stage\n *\n * Writeback is an optional third pipeline stage. It writes data back to the register file that was\n * produced in the ID/EX stage or awaits a response to a load/store (LSU writes direct to register\n * file for load data). If the writeback stage is not present (WritebackStage == 0) this acts as\n * a simple passthrough to write data direct to the register file.\n */\n\n`include \"prim_assert.sv\"\n`include \"dv_fcov_macros.svh\"\n\nmodule ibex_wb_stage #(\n  parameter bit ResetAll          = 1'b0,\n  parameter bit WritebackStage    = 1'b0,\n  parameter bit DummyInstructions = 1'b0\n) (\n  input  logic                     clk_i,\n  input  logic                     rst_ni,\n\n  input  logic                     en_wb_i,\n  input  ibex_pkg::wb_instr_type_e instr_type_wb_i,\n  input  logic [31:0]              pc_id_i,\n  input  logic                     instr_is_compressed_id_i,\n  input  logic                     instr_perf_count_id_i,\n\n  output logic                     ready_wb_o,\n  output logic                     rf_write_wb_o,\n  output logic                     outstanding_load_wb_o,\n  output logic                     outstanding_store_wb_o,\n  output logic [31:0]              pc_wb_o,\n  output logic                     perf_instr_ret_wb_o,\n  output logic                     perf_instr_ret_compressed_wb_o,\n  output logic                     perf_instr_ret_wb_spec_o,\n  output logic                     perf_instr_ret_compressed_wb_spec_o,\n\n  input  logic [4:0]               rf_waddr_id_i,\n  input  logic [31:0]              rf_wdata_id_i,\n  input  logic                     rf_we_id_i,\n\n  input  logic                     dummy_instr_id_i,\n\n  input  logic [31:0]              rf_wdata_lsu_i,\n  input  logic                     rf_we_lsu_i,\n\n  output logic [31:0]              rf_wdata_fwd_wb_o,\n\n  output logic [4:0]               rf_waddr_wb_o,\n  output logic [31:0]              rf_wdata_wb_o,\n  output logic                     rf_we_wb_o,\n\n  output logic                     dummy_instr_wb_o,\n\n  input logic                      lsu_resp_valid_i,\n  input logic                      lsu_resp_err_i,\n\n  output logic                     instr_done_wb_o\n);\n\n  import ibex_pkg::*;\n\n  // 0 == RF write from ID\n  // 1 == RF write from LSU\n  logic [31:0] rf_wdata_wb_mux    [2];\n  logic [1:0]  rf_wdata_wb_mux_we;\n\n  if (WritebackStage) begin : g_writeback_stage\n    logic [31:0]    rf_wdata_wb_q;\n    logic           rf_we_wb_q;\n    logic [4:0]     rf_waddr_wb_q;\n\n    logic           wb_done;\n\n    logic           wb_valid_q;\n    logic [31:0]    wb_pc_q;\n    logic           wb_compressed_q;\n    logic           wb_count_q;\n    wb_instr_type_e wb_instr_type_q;\n\n    logic           wb_valid_d;\n\n    // Stage becomes valid if an instruction enters for ID/EX and valid is cleared when instruction\n    // is done\n    assign wb_valid_d = (en_wb_i & ready_wb_o) | (wb_valid_q & ~wb_done);\n\n    // Writeback for non load/store instructions always completes in a cycle (so instantly done)\n    // Writeback for load/store must wait for response to be received by the LSU\n    // Signal only relevant if wb_valid_q set\n    assign wb_done = (wb_instr_type_q == WB_INSTR_OTHER) | lsu_resp_valid_i;\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        wb_valid_q <= 1'b0;\n      end else begin\n        wb_valid_q <= wb_valid_d;\n      end\n    end\n\n    if (ResetAll) begin : g_wb_regs_ra\n      always_ff @(posedge clk_i or negedge rst_ni) begin\n        if (!rst_ni) begin\n          rf_we_wb_q      <= '0;\n          rf_waddr_wb_q   <= '0;\n          rf_wdata_wb_q   <= '0;\n          wb_instr_type_q <= wb_instr_type_e'(0);\n          wb_pc_q         <= '0;\n          wb_compressed_q <= '0;\n          wb_count_q      <= '0;\n        end else if (en_wb_i) begin\n          rf_we_wb_q      <= rf_we_id_i;\n          rf_waddr_wb_q   <= rf_waddr_id_i;\n          rf_wdata_wb_q   <= rf_wdata_id_i;\n          wb_instr_type_q <= instr_type_wb_i;\n          wb_pc_q         <= pc_id_i;\n          wb_compressed_q <= instr_is_compressed_id_i;\n          wb_count_q      <= instr_perf_count_id_i;\n        end\n      end\n    end else begin : g_wb_regs_nr\n      always_ff @(posedge clk_i) begin\n        if (en_wb_i) begin\n          rf_we_wb_q      <= rf_we_id_i;\n          rf_waddr_wb_q   <= rf_waddr_id_i;\n          rf_wdata_wb_q   <= rf_wdata_id_i;\n          wb_instr_type_q <= instr_type_wb_i;\n          wb_pc_q         <= pc_id_i;\n          wb_compressed_q <= instr_is_compressed_id_i;\n          wb_count_q      <= instr_perf_count_id_i;\n        end\n      end\n    end\n\n    assign rf_waddr_wb_o         = rf_waddr_wb_q;\n    assign rf_wdata_wb_mux[0]    = rf_wdata_wb_q;\n    assign rf_wdata_wb_mux_we[0] = rf_we_wb_q & wb_valid_q;\n\n    assign ready_wb_o = ~wb_valid_q | wb_done;\n\n    // Instruction in writeback will be writing to register file if either rf_we is set or writeback\n    // is awaiting load data. This is used for determining RF read hazards in ID/EX\n    assign rf_write_wb_o = wb_valid_q & (rf_we_wb_q | (wb_instr_type_q == WB_INSTR_LOAD));\n\n    assign outstanding_load_wb_o  = wb_valid_q & (wb_instr_type_q == WB_INSTR_LOAD);\n    assign outstanding_store_wb_o = wb_valid_q & (wb_instr_type_q == WB_INSTR_STORE);\n\n    assign pc_wb_o = wb_pc_q;\n\n    assign instr_done_wb_o = wb_valid_q & wb_done;\n\n    // Increment instruction retire counters for valid instructions which are not lsu errors.\n    // Speculative versions of the signals do not factor in exceptions and whether the instruction\n    // is done yet. These are used to get correct values for instructions reading the relevant\n    // performance counters in the ID stage.\n    assign perf_instr_ret_wb_spec_o            = wb_count_q;\n    assign perf_instr_ret_compressed_wb_spec_o = perf_instr_ret_wb_spec_o & wb_compressed_q;\n    assign perf_instr_ret_wb_o                 = instr_done_wb_o & wb_count_q &\n                                                 ~(lsu_resp_valid_i & lsu_resp_err_i);\n    assign perf_instr_ret_compressed_wb_o      = perf_instr_ret_wb_o & wb_compressed_q;\n\n    // Forward data that will be written to the RF back to ID to resolve data hazards. The flopped\n    // rf_wdata_wb_q is used rather than rf_wdata_wb_o as the latter includes read data from memory\n    // that returns too late to be used on the forwarding path.\n    assign rf_wdata_fwd_wb_o = rf_wdata_wb_q;\n\n    // For FI hardening, only forward LSU write enable if we're actually waiting for it.\n    assign rf_wdata_wb_mux_we[1] = outstanding_load_wb_o & rf_we_lsu_i;\n\n    if (DummyInstructions) begin : g_dummy_instr_wb\n      logic dummy_instr_wb_q;\n\n      if (ResetAll) begin : g_dummy_instr_wb_regs_ra\n        always_ff @(posedge clk_i or negedge rst_ni) begin\n          if (!rst_ni) begin\n            dummy_instr_wb_q <= 1'b0;\n          end else if (en_wb_i) begin\n            dummy_instr_wb_q <= dummy_instr_id_i;\n          end\n        end\n      end else begin : g_dummy_instr_wb_regs_nr\n        always_ff @(posedge clk_i) begin\n          if (en_wb_i) begin\n            dummy_instr_wb_q <= dummy_instr_id_i;\n          end\n        end\n      end\n\n      assign dummy_instr_wb_o = dummy_instr_wb_q;\n    end else begin : g_no_dummy_instr_wb\n      logic  unused_dummy_instr_id;\n      assign unused_dummy_instr_id = dummy_instr_id_i;\n\n      assign dummy_instr_wb_o = 1'b0;\n    end\n  end else begin : g_bypass_wb\n    // without writeback stage just pass through register write signals\n    assign rf_waddr_wb_o         = rf_waddr_id_i;\n    assign rf_wdata_wb_mux[0]    = rf_wdata_id_i;\n    assign rf_wdata_wb_mux_we[0] = rf_we_id_i;\n    assign rf_wdata_wb_mux_we[1] = rf_we_lsu_i;\n\n    assign dummy_instr_wb_o = dummy_instr_id_i;\n\n    // Increment instruction retire counters for valid instructions which are not lsu errors.\n    // The speculative signals are always 0 when no writeback stage is present as the raw counter\n    // values will be correct.\n    assign perf_instr_ret_wb_spec_o            = 1'b0;\n    assign perf_instr_ret_compressed_wb_spec_o = 1'b0;\n    assign perf_instr_ret_wb_o                 = instr_perf_count_id_i & en_wb_i &\n                                                 ~(lsu_resp_valid_i & lsu_resp_err_i);\n    assign perf_instr_ret_compressed_wb_o      = perf_instr_ret_wb_o & instr_is_compressed_id_i;\n\n    // ready needs to be constant 1 without writeback stage (otherwise ID/EX stage will stall)\n    assign ready_wb_o    = 1'b1;\n\n    // Unused Writeback stage only IO & wiring\n    // Assign inputs and internal wiring to unused signals to satisfy lint checks\n    // Tie-off outputs to constant values\n    logic           unused_clk;\n    logic           unused_rst;\n    wb_instr_type_e unused_instr_type_wb;\n    logic [31:0]    unused_pc_id;\n    logic           unused_dummy_instr_id;\n\n    assign unused_clk            = clk_i;\n    assign unused_rst            = rst_ni;\n    assign unused_instr_type_wb  = instr_type_wb_i;\n    assign unused_pc_id          = pc_id_i;\n    assign unused_dummy_instr_id = dummy_instr_id_i;\n\n    assign outstanding_load_wb_o  = 1'b0;\n    assign outstanding_store_wb_o = 1'b0;\n    assign pc_wb_o                = '0;\n    assign rf_write_wb_o          = 1'b0;\n    assign rf_wdata_fwd_wb_o      = 32'b0;\n    assign instr_done_wb_o        = 1'b0;\n  end\n\n  assign rf_wdata_wb_mux[1] = rf_wdata_lsu_i;\n\n  // RF write data can come from ID results (all RF writes that aren't because of loads will come\n  // from here) or the LSU (RF writes for load data)\n  assign rf_wdata_wb_o = ({32{rf_wdata_wb_mux_we[0]}} & rf_wdata_wb_mux[0]) |\n                         ({32{rf_wdata_wb_mux_we[1]}} & rf_wdata_wb_mux[1]);\n  assign rf_we_wb_o    = |rf_wdata_wb_mux_we;\n\n  `DV_FCOV_SIGNAL_GEN_IF(logic, wb_valid, g_writeback_stage.wb_valid_q, WritebackStage)\n\n  `ASSERT(RFWriteFromOneSourceOnly, $onehot0(rf_wdata_wb_mux_we))\nendmodule\n"}
