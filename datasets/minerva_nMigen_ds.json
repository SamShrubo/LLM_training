{"text": "['from amaranth import *\\n', '\\n', '\\n', '__all__ = [\"Adder\"]\\n', '\\n', '\\n', 'class Adder(Elaboratable):\\n', '    def __init__(self):\\n', '        self.d_sub      = Signal()\\n', '        self.d_stall    = Signal()\\n', '        self.x_src1     = Signal(32)\\n', '        self.x_src2     = Signal(32)\\n', '\\n', '        self.x_result   = Signal(32)\\n', '        self.x_carry    = Signal()\\n', '        self.x_overflow = Signal()\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        x_sub = Signal()\\n', '\\n', '        with m.If(~self.d_stall):\\n', '            m.d.sync += x_sub.eq(self.d_sub)\\n', '\\n', '        x_add_result   = Signal(32)\\n', '        x_add_carry    = Signal()\\n', '        x_add_overflow = Signal()\\n', '\\n', '        m.d.comb += [\\n', '            Cat(x_add_result, x_add_carry).eq(self.x_src1 + self.x_src2),\\n', '            x_add_overflow.eq(~self.x_src1[-1] & self.x_src2[-1] & x_add_result[-1]),\\n', '        ]\\n', '\\n', '        x_sub_result   = Signal(32)\\n', '        x_sub_carry    = Signal()\\n', '        x_sub_overflow = Signal()\\n', '\\n', '        m.d.comb += [\\n', '            Cat(x_sub_result, x_sub_carry).eq(self.x_src1 - self.x_src2),\\n', '            x_sub_overflow.eq((self.x_src1[-1] != self.x_src2[-1]) & (x_sub_result[-1] == self.x_src2[-1])),\\n', '        ]\\n', '\\n', '        with m.If(x_sub):\\n', '            m.d.comb += [\\n', '                self.x_result  .eq(x_sub_result),\\n', '                self.x_carry   .eq(x_sub_carry),\\n', '                self.x_overflow.eq(x_sub_overflow),\\n', '            ]\\n', '        with m.Else():\\n', '            m.d.comb += [\\n', '                self.x_result  .eq(x_add_result),\\n', '                self.x_carry   .eq(x_add_carry),\\n', '                self.x_overflow.eq(x_add_overflow),\\n', '            ]\\n', '\\n', '        return m\\n']"}
{"text": "['from amaranth import *\\n', 'from amaranth.asserts import *\\n', 'from amaranth.lib.coding import Encoder\\n', 'from amaranth.utils import log2_int, bits_for\\n', '\\n', 'from .mem import ForwardingMemory\\n', '\\n', '\\n', '__all__ = [\"L1Cache\"]\\n', '\\n', '\\n', 'class L1Cache(Elaboratable):\\n', '    def __init__(self, nways, nlines, nwords, base, limit):\\n', '        if not isinstance(nlines, int):\\n', '            raise TypeError(\"nlines must be an integer, not {!r}\".format(nlines))\\n', '        if nlines == 0 or nlines & nlines - 1:\\n', '            raise ValueError(\"nlines must be a power of 2, not {}\".format(nlines))\\n', '        if nwords not in {4, 8, 16}:\\n', '            raise ValueError(\"nwords must be 4, 8 or 16, not {!r}\".format(nwords))\\n', '        if nways not in {1, 2}:\\n', '            raise ValueError(\"nways must be 1 or 2, not {!r}\".format(nways))\\n', '\\n', '        if not isinstance(base, int) or base not in range(0, 2**32):\\n', '            raise ValueError(\"base must be an integer between {:#x} and {:#x} inclusive, not {!r}\"\\n', '                             .format(0, 2**32-1, base))\\n', '        if limit not in range(0, 2**32):\\n', '            raise ValueError(\"limit must be an integer between {:#x} and {:#x} inclusive, not {!r}\"\\n', '                             .format(0, 2**32-1, limit))\\n', '\\n', '        if base >= limit:\\n', '            raise ValueError(\"limit {:#x} must be greater than base {:#x}\"\\n', '                             .format(limit, base))\\n', '        if (limit - base) & (limit - base) - 1:\\n', '            raise ValueError(\"limit - base must be a power of 2, not {:#x}\"\\n', '                             .format(limit - base))\\n', '        if base % (limit - base):\\n', '            raise ValueError(\"base must be a multiple of limit - base, but {:#x} is not a multiple \"\\n', '                             \"of {:#x}\"\\n', '                             .format(base, limit - base))\\n', '\\n', '        self.nways = nways\\n', '        self.nlines = nlines\\n', '        self.nwords = nwords\\n', '        self.base = base\\n', '        self.limit = limit\\n', '\\n', '        offsetbits = log2_int(nwords)\\n', '        linebits = log2_int(nlines)\\n', '        tagbits = bits_for(limit) - linebits - offsetbits - 2\\n', '\\n', '        self.s1_addr = Record([(\"offset\", offsetbits), (\"line\", linebits), (\"tag\", tagbits)])\\n', '        self.s1_stall = Signal()\\n', '        self.s1_valid = Signal()\\n', '        self.s2_addr = Record.like(self.s1_addr)\\n', '        self.s2_re = Signal()\\n', '        self.s2_flush = Signal()\\n', '        self.s2_evict = Signal()\\n', '        self.s2_valid = Signal()\\n', '        self.bus_valid = Signal()\\n', '        self.bus_error = Signal()\\n', '        self.bus_rdata = Signal(32)\\n', '\\n', '        self.s2_miss = Signal()\\n', '        self.s2_flush_ack = Signal()\\n', '        self.s2_rdata = Signal(32)\\n', '        self.bus_re = Signal()\\n', '        self.bus_addr = Record.like(self.s1_addr)\\n', '        self.bus_last = Signal()\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        ways = Array(Record([(\"data\",   self.nwords * 32),\\n', '                             (\"tag\",    self.s2_addr.tag.shape()),\\n', '                             (\"valid\",  1),\\n', '                             (\"bus_re\", 1)])\\n', '                     for _ in range(self.nways))\\n', '\\n', '        if self.nways == 1:\\n', '            way_lru = Const(0)\\n', '        elif self.nways == 2:\\n', '            way_lru = Signal()\\n', '            with m.If(self.bus_re & self.bus_valid & self.bus_last & ~self.bus_error):\\n', '                m.d.sync += way_lru.eq(~way_lru)\\n', '\\n', '        m.d.comb += ways[way_lru].bus_re.eq(self.bus_re)\\n', '\\n', '        way_hit = m.submodules.way_hit = Encoder(self.nways)\\n', '        for j, way in enumerate(ways):\\n', '            m.d.comb += way_hit.i[j].eq((way.tag == self.s2_addr.tag) & way.valid)\\n', '\\n', '        m.d.comb += [\\n', '            self.s2_miss.eq(way_hit.n),\\n', '            self.s2_rdata.eq(ways[way_hit.o].data.word_select(self.s2_addr.offset, 32))\\n', '        ]\\n', '\\n', '        flush_line = Signal(range(self.nlines), reset=self.nlines - 1)\\n', '        with m.If(self.s1_valid & ~self.s1_stall):\\n', '            m.d.sync += self.s2_flush_ack.eq(0)\\n', '\\n', '        with m.FSM() as fsm:\\n', '            last_offset = Signal.like(self.s2_addr.offset)\\n', '\\n', '            with m.State(\"CHECK\"):\\n', '                with m.If(self.s2_valid):\\n', '                    with m.If(self.s2_flush & ~self.s2_flush_ack):\\n', '                        m.d.sync += flush_line.eq(flush_line.reset)\\n', '                        m.next = \"FLUSH\"\\n', '                    with m.Elif(self.s2_re & self.s2_miss):\\n', '                        m.d.sync += [\\n', '                            self.bus_addr.eq(self.s2_addr),\\n', '                            self.bus_re.eq(1),\\n', '                            last_offset.eq(self.s2_addr.offset - 1)\\n', '                        ]\\n', '                        m.next = \"REFILL\"\\n', '\\n', '            with m.State(\"REFILL\"):\\n', '                m.d.comb += self.bus_last.eq(self.bus_addr.offset == last_offset)\\n', '                with m.If(~self.s1_stall):\\n', '                    m.d.sync += self.bus_re.eq(0)\\n', '                    m.next = \"CHECK\"\\n', '                with m.Else():\\n', '                    with m.If(self.bus_valid):\\n', '                        m.d.sync += self.bus_addr.offset.eq(self.bus_addr.offset + 1)\\n', '                    with m.If(self.bus_valid & self.bus_last | self.bus_error):\\n', '                        m.d.sync += self.bus_re.eq(0)\\n', '\\n', '            with m.State(\"FLUSH\"):\\n', '                with m.If(flush_line == 0):\\n', '                    m.d.sync += self.s2_flush_ack.eq(1)\\n', '                    m.next = \"CHECK\"\\n', '                with m.Else():\\n', '                    m.d.sync += flush_line.eq(flush_line - 1)\\n', '\\n', '        if platform == \"formal\":\\n', '            with m.If(Initial()):\\n', '                m.d.comb += Assume(fsm.ongoing(\"CHECK\"))\\n', '\\n', '        for i, way in enumerate(ways):\\n', '            tag_mem    = ForwardingMemory(width=1 + len(way.tag), depth=self.nlines)\\n', '            tag_mem_rp = tag_mem.read_port()\\n', '            tag_mem_wp = tag_mem.write_port()\\n', '            m.submodules[f\"tag_mem_{i}\"] = tag_mem\\n', '\\n', '            dat_mem    = ForwardingMemory(width=len(way.data), depth=self.nlines)\\n', '            dat_mem_rp = dat_mem.read_port()\\n', '            dat_mem_wp = dat_mem.write_port(granularity=32)\\n', '            m.submodules[f\"dat_mem_{i}\"] = dat_mem\\n', '\\n', '            mem_rp_addr = Signal.like(self.s1_addr.line)\\n', '            with m.If(self.s1_stall):\\n', '                m.d.comb += mem_rp_addr.eq(self.s2_addr.line)\\n', '            with m.Else():\\n', '                m.d.comb += mem_rp_addr.eq(self.s1_addr.line)\\n', '\\n', '            m.d.comb += [\\n', '                tag_mem_rp.addr.eq(mem_rp_addr),\\n', '                dat_mem_rp.addr.eq(mem_rp_addr),\\n', '                Cat(way.tag, way.valid).eq(tag_mem_rp.data),\\n', '                way.data.eq(dat_mem_rp.data),\\n', '            ]\\n', '\\n', '            with m.If(fsm.ongoing(\"FLUSH\")):\\n', '                m.d.comb += [\\n', '                    tag_mem_wp.addr.eq(flush_line),\\n', '                    tag_mem_wp.en.eq(1),\\n', '                    tag_mem_wp.data.eq(0),\\n', '                ]\\n', '            with m.Elif(way.bus_re):\\n', '                m.d.comb += [\\n', '                    tag_mem_wp.addr.eq(self.bus_addr.line),\\n', '                    tag_mem_wp.en.eq(way.bus_re & self.bus_valid),\\n', '                    tag_mem_wp.data.eq(Cat(self.bus_addr.tag, self.bus_last & ~self.bus_error)),\\n', '                ]\\n', '            with m.Else():\\n', '                m.d.comb += [\\n', '                    tag_mem_wp.addr.eq(self.s2_addr.line),\\n', '                    tag_mem_wp.en.eq(self.s2_evict & self.s2_valid & (way.tag == self.s2_addr.tag)),\\n', '                    tag_mem_wp.data.eq(0),\\n', '                ]\\n', '\\n', '            m.d.comb += [\\n', '                dat_mem_wp.addr.eq(self.bus_addr.line),\\n', '                dat_mem_wp.en.bit_select(self.bus_addr.offset, 1).eq(way.bus_re & self.bus_valid),\\n', '                dat_mem_wp.data.eq(self.bus_rdata.replicate(self.nwords)),\\n', '            ]\\n', '\\n', '        return m\\n']"}
{"text": "['from amaranth import *\\n', '\\n', 'from ..isa import Funct3\\n', '\\n', '\\n', '__all__ = [\"CompareUnit\"]\\n', '\\n', '\\n', 'class CompareUnit(Elaboratable):\\n', '    def __init__(self):\\n', '        self.op = Signal(3)\\n', '        self.zero = Signal()\\n', '        self.negative = Signal()\\n', '        self.overflow = Signal()\\n', '        self.carry = Signal()\\n', '\\n', '        self.condition_met = Signal()\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        with m.Switch(self.op):\\n', '            with m.Case(Funct3.BEQ):\\n', '                m.d.comb += self.condition_met.eq(self.zero)\\n', '            with m.Case(Funct3.BNE):\\n', '                m.d.comb += self.condition_met.eq(~self.zero)\\n', '            with m.Case(Funct3.BLT):\\n', '                m.d.comb += self.condition_met.eq(~self.zero & (self.negative != self.overflow))\\n', '            with m.Case(Funct3.BGE):\\n', '                m.d.comb += self.condition_met.eq(self.negative == self.overflow)\\n', '            with m.Case(Funct3.BLTU):\\n', '                m.d.comb += self.condition_met.eq(~self.zero & self.carry)\\n', '            with m.Case(Funct3.BGEU):\\n', '                m.d.comb += self.condition_met.eq(~self.carry)\\n', '\\n', '        return m\\n']"}
{"text": "['from functools import reduce\\n', 'from operator import or_\\n', 'from itertools import tee\\n', '\\n', 'from amaranth import *\\n', 'from amaranth.lib.coding import PriorityEncoder\\n', '\\n', 'from .isa import *\\n', 'from .stage import *\\n', 'from .csr import *\\n', 'from . import gpr\\n', '\\n', 'from .units.adder import *\\n', 'from .units.compare import *\\n', 'from .units.debug import *\\n', 'from .units.decoder import *\\n', 'from .units.divider import *\\n', 'from .units.exception import *\\n', 'from .units.fetch import *\\n', 'from .units.rvficon import *\\n', 'from .units.loadstore import *\\n', 'from .units.logic import *\\n', 'from .units.multiplier import *\\n', 'from .units.predict import *\\n', 'from .units.shifter import *\\n', 'from .units.trigger import *\\n', '\\n', 'from .units.debug.jtag import jtag_layout\\n', 'from .wishbone import wishbone_layout, WishboneArbiter\\n', '\\n', '\\n', '__all__ = [\"Minerva\"]\\n', '\\n', '\\n', '_af_layout = [\\n', '    (\"pc\", signed(33)),\\n', ']\\n', '\\n', '\\n', '_fd_layout = [\\n', '    (\"pc\",               32),\\n', '    (\"instruction\",      32),\\n', '    (\"fetch_error\",       1),\\n', '    (\"fetch_badaddr\",    30)\\n', ']\\n', '\\n', '\\n', '_dx_layout = [\\n', '    (\"pc\",                  32),\\n', '    (\"instruction\",         32),\\n', '    (\"fetch_error\",          1),\\n', '    (\"fetch_badaddr\",       30),\\n', '    (\"illegal\",              1),\\n', '    (\"rd\",                   5),\\n', '    (\"rs1\",                  5),\\n', '    (\"rd_we\",                1),\\n', '    (\"rs1_re\",               1),\\n', '    (\"src1\",                32),\\n', '    (\"src2\",                32),\\n', '    (\"store_operand\",       32),\\n', '    (\"bypass_x\",             1),\\n', '    (\"bypass_m\",             1),\\n', '    (\"funct3\",               3),\\n', '    (\"load\",                 1),\\n', '    (\"store\",                1),\\n', '    (\"adder_sub\",            1),\\n', '    (\"logic\",                1),\\n', '    (\"multiply\",             1),\\n', '    (\"divide\",               1),\\n', '    (\"shift\",                1),\\n', '    (\"direction\",            1),\\n', '    (\"sext\",                 1),\\n', '    (\"jump\",                 1),\\n', '    (\"compare\",              1),\\n', '    (\"branch\",               1),\\n', '    (\"branch_target\",       32),\\n', '    (\"branch_predict_taken\", 1),\\n', '    (\"fence_i\",              1),\\n', '    (\"csr\",                  1),\\n', '    (\"csr_adr\",             12),\\n', '    (\"csr_we\",               1),\\n', '    (\"ecall\",                1),\\n', '    (\"ebreak\",               1),\\n', '    (\"mret\",                 1),\\n', ']\\n', '\\n', '\\n', '_xm_layout = [\\n', '    (\"pc\",                  32),\\n', '    (\"instruction\",         32),\\n', '    (\"fetch_error\",          1),\\n', '    (\"fetch_badaddr\",       30),\\n', '    (\"illegal\",              1),\\n', '    (\"loadstore_misaligned\", 1),\\n', '    (\"ecall\",                1),\\n', '    (\"ebreak\",               1),\\n', '    (\"rd\",                   5),\\n', '    (\"rd_we\",                1),\\n', '    (\"bypass_m\",             1),\\n', '    (\"funct3\",               3),\\n', '    (\"result\",              32),\\n', '    (\"shift\",                1),\\n', '    (\"load\",                 1),\\n', '    (\"store\",                1),\\n', '    (\"store_data\",          32),\\n', '    (\"compare\",              1),\\n', '    (\"multiply\",             1),\\n', '    (\"divide\",               1),\\n', '    (\"condition_met\",        1),\\n', '    (\"branch_target\",       32),\\n', '    (\"branch_taken\",         1),\\n', '    (\"branch_predict_taken\", 1),\\n', '    (\"csr\",                  1),\\n', '    (\"csr_adr\",             12),\\n', '    (\"csr_we\",               1),\\n', '    (\"csr_result\",          32),\\n', '    (\"mret\",                 1),\\n', '    (\"exception\",            1)\\n', ']\\n', '\\n', '\\n', '_mw_layout = [\\n', '    (\"pc\",                32),\\n', '    (\"rd\",                 5),\\n', '    (\"rd_we\",              1),\\n', '    (\"funct3\",             3),\\n', '    (\"result\",            32),\\n', '    (\"load\",               1),\\n', '    (\"load_data\",         32),\\n', '    (\"multiply\",           1),\\n', '    (\"exception\",          1)\\n', ']\\n', '\\n', '\\n', 'class Minerva(Elaboratable):\\n', '    def __init__(self,\\n', '            reset_address = 0x00000000,\\n', '            with_icache   = False,\\n', '            icache_nways  = 1,\\n', '            icache_nlines = 32,\\n', '            icache_nwords = 4,\\n', '            icache_base   = 0,\\n', '            icache_limit  = 2**31,\\n', '            with_dcache   = False,\\n', '            dcache_nways  = 1,\\n', '            dcache_nlines = 32,\\n', '            dcache_nwords = 4,\\n', '            dcache_base   = 0,\\n', '            dcache_limit  = 2**31,\\n', '            wrbuf_depth   = 8,\\n', '            with_muldiv   = False,\\n', '            with_debug    = False,\\n', '            with_trigger  = False,\\n', '            nb_triggers   = 8,\\n', '            with_rvfi     = False):\\n', '\\n', '        # Ports\\n', '\\n', '        self.external_interrupt = Signal(32)\\n', '        self.timer_interrupt    = Signal()\\n', '        self.software_interrupt = Signal()\\n', '\\n', '        self.ibus = Record(wishbone_layout)\\n', '        self.dbus = Record(wishbone_layout)\\n', '\\n', '        if with_debug:\\n', '            self.jtag = Record(jtag_layout)\\n', '        else:\\n', '            self.jtag = None\\n', '\\n', '        if with_rvfi:\\n', '            self.rvfi = Record(rvfi_layout)\\n', '        else:\\n', '            self.rvfi = None\\n', '\\n', '        self.reset_address = reset_address\\n', '        self.with_icache   = with_icache\\n', '        self.with_dcache   = with_dcache\\n', '        self.with_muldiv   = with_muldiv\\n', '        self.with_debug    = with_debug\\n', '        self.with_trigger  = with_trigger\\n', '        self.with_rvfi     = with_rvfi\\n', '\\n', '        # Pipeline stages\\n', '\\n', '        self._a = Stage(None, _af_layout)\\n', '        self._f = Stage(_af_layout, _fd_layout)\\n', '        self._d = Stage(_fd_layout, _dx_layout)\\n', '        self._x = Stage(_dx_layout, _xm_layout)\\n', '        self._m = Stage(_xm_layout, _mw_layout)\\n', '        self._w = Stage(_mw_layout, None)\\n', '\\n', '        # Units\\n', '\\n', '        self._pc_sel    = PCSelector()\\n', '        self._data_sel  = DataSelector()\\n', '        self._adder     = Adder()\\n', '        self._compare   = CompareUnit()\\n', '        self._decoder   = InstructionDecoder(with_muldiv)\\n', '        self._exception = ExceptionUnit()\\n', '        self._logic     = LogicUnit()\\n', '        self._predict   = BranchPredictor()\\n', '        self._shifter   = Shifter()\\n', '\\n', '        if with_icache:\\n', '            self._fetch = CachedFetchUnit(\\n', '                icache_nways  = icache_nways,\\n', '                icache_nlines = icache_nlines,\\n', '                icache_nwords = icache_nwords,\\n', '                icache_base   = icache_base,\\n', '                icache_limit  = icache_limit,\\n', '            )\\n', '        else:\\n', '            self._fetch = BareFetchUnit()\\n', '\\n', '        if with_dcache:\\n', '            self._loadstore = CachedLoadStoreUnit(\\n', '                dcache_nways  = dcache_nways,\\n', '                dcache_nlines = dcache_nlines,\\n', '                dcache_nwords = dcache_nwords,\\n', '                dcache_base   = dcache_base,\\n', '                dcache_limit  = dcache_limit,\\n', '                wrbuf_depth   = wrbuf_depth,\\n', '            )\\n', '        else:\\n', '            self._loadstore = BareLoadStoreUnit()\\n', '\\n', '        if with_muldiv:\\n', '            if with_rvfi:\\n', '                self._multiplier = DummyMultiplier()\\n', '                self._divider    = DummyDivider()\\n', '            else:\\n', '                self._multiplier = Multiplier()\\n', '                self._divider    = Divider()\\n', '        else:\\n', '            self._multiplier = None\\n', '            self._divider    = None\\n', '\\n', '        if with_debug:\\n', '            self._debug        = DebugUnit()\\n', '            self._dbus_arbiter = WishboneArbiter()\\n', '        else:\\n', '            self._debug        = None\\n', '            self._dbus_arbiter = None\\n', '\\n', '        if self.with_trigger:\\n', '            self._trigger = TriggerUnit(nb_triggers)\\n', '        else:\\n', '            self._trigger = None\\n', '\\n', '        if self.with_rvfi:\\n', '            self._rvficon = RVFIController()\\n', '        else:\\n', '            self._rvficon = None\\n', '\\n', '        # Register files\\n', '\\n', '        self._gprf = gpr.File(width=32, depth=32)\\n', '        self._csrf = CSRFile()\\n', '\\n', '        self._csrf.add_csrs(self._exception.iter_csrs())\\n', '        if with_debug:\\n', '            self._csrf.add_csrs(self._debug.iter_csrs())\\n', '        if with_trigger:\\n', '            self._csrf.add_csrs(self._trigger.iter_csrs())\\n', '\\n', '    def elaborate(self, platform):\\n', '        cpu = Module()\\n', '\\n', '        cpu.submodules.a = self._a\\n', '        cpu.submodules.f = self._f\\n', '        cpu.submodules.d = self._d\\n', '        cpu.submodules.x = self._x\\n', '        cpu.submodules.m = self._m\\n', '        cpu.submodules.w = self._w\\n', '\\n', '        stages = self._a, self._f, self._d, self._x, self._m, self._w\\n', '        sources, sinks = tee(stages)\\n', '        next(sinks)\\n', '        for s1, s2 in zip(sources, sinks):\\n', '            cpu.d.comb += s1.source.connect(s2.sink)\\n', '\\n', '        self._a.source.pc.reset = self.reset_address - 4\\n', '        cpu.d.comb += self._a.valid.eq(Const(1))\\n', '\\n', '        cpu.submodules.pc_sel    = self._pc_sel\\n', '        cpu.submodules.data_sel  = self._data_sel\\n', '        cpu.submodules.adder     = self._adder\\n', '        cpu.submodules.compare   = self._compare\\n', '        cpu.submodules.decoder   = self._decoder\\n', '        cpu.submodules.exception = self._exception\\n', '        cpu.submodules.logic     = self._logic\\n', '        cpu.submodules.predict   = self._predict\\n', '        cpu.submodules.shifter   = self._shifter\\n', '        cpu.submodules.fetch     = self._fetch\\n', '        cpu.submodules.loadstore = self._loadstore\\n', '\\n', '        if self.with_muldiv:\\n', '            cpu.submodules.multiplier = self._multiplier\\n', '            cpu.submodules.divider    = self._divider\\n', '\\n', '        if self.with_debug:\\n', '            cpu.submodules.debug        = self._debug\\n', '            cpu.submodules.dbus_arbiter = self._dbus_arbiter\\n', '\\n', '        if self.with_trigger:\\n', '            cpu.submodules.trigger = self._trigger\\n', '\\n', '        if self.with_rvfi:\\n', '            cpu.submodules.rvficon = self._rvficon\\n', '\\n', '        cpu.submodules.gprf = self._gprf\\n', '        cpu.submodules.csrf = self._csrf\\n', '\\n', '        csrf_rp = self._csrf.read_port()\\n', '        csrf_wp = self._csrf.write_port()\\n', '\\n', '        # Pipeline logic\\n', '\\n', '        cpu.d.comb += [\\n', '            self._pc_sel.f_pc                  .eq(self._f.sink.pc),\\n', '            self._pc_sel.d_pc                  .eq(self._d.sink.pc),\\n', '            self._pc_sel.d_branch_predict_taken.eq(self._predict.d_branch_taken),\\n', '            self._pc_sel.d_branch_target       .eq(self._predict.d_branch_target),\\n', '            self._pc_sel.d_valid               .eq(self._d.valid),\\n', '            self._pc_sel.x_pc                  .eq(self._x.sink.pc),\\n', '            self._pc_sel.x_fence_i             .eq(self._x.sink.fence_i),\\n', '            self._pc_sel.x_valid               .eq(self._x.valid),\\n', '            self._pc_sel.m_branch_predict_taken.eq(self._m.sink.branch_predict_taken),\\n', '            self._pc_sel.m_branch_taken        .eq(self._m.sink.branch_taken),\\n', '            self._pc_sel.m_branch_target       .eq(self._m.sink.branch_target),\\n', '            self._pc_sel.m_exception           .eq(self._exception.m_raise),\\n', '            self._pc_sel.m_mret                .eq(self._m.sink.mret),\\n', '            self._pc_sel.m_valid               .eq(self._m.valid),\\n', '            self._pc_sel.mtvec_r_base          .eq(self._exception.mtvec.r.base),\\n', '            self._pc_sel.mepc_r_base           .eq(self._exception.mepc.r.base)\\n', '        ]\\n', '\\n', '        cpu.d.comb += [\\n', '            self._fetch.a_pc   .eq(self._pc_sel.a_pc),\\n', '            self._fetch.a_stall.eq(self._a.stall),\\n', '            self._fetch.a_valid.eq(self._a.valid),\\n', '            self._fetch.f_stall.eq(self._f.stall),\\n', '            self._fetch.f_valid.eq(self._f.valid),\\n', '\\n', '            self._fetch.ibus.connect(self.ibus),\\n', '        ]\\n', '\\n', '        self._m.stall_on(self._fetch.a_busy & self._a.valid)\\n', '        self._m.stall_on(self._fetch.f_busy & self._f.valid)\\n', '\\n', '        if self.with_icache:\\n', '            flush_icache = self._x.sink.fence_i & self._x.valid\\n', '            if self.with_debug:\\n', '                flush_icache |= self._debug.resumereq\\n', '\\n', '            cpu.d.comb += [\\n', '                self._fetch.f_pc   .eq(self._f.sink.pc),\\n', '                self._fetch.a_flush.eq(flush_icache)\\n', '            ]\\n', '\\n', '        cpu.d.comb += [\\n', '            self._decoder.instruction.eq(self._d.sink.instruction)\\n', '        ]\\n', '\\n', '        if self.with_debug:\\n', '            with cpu.If(self._debug.halt & self._debug.halted):\\n', '                cpu.d.comb += self._gprf.rp1.addr.eq(self._debug.gprf_addr)\\n', '            with cpu.Elif(~self._d.stall):\\n', '                cpu.d.comb += self._gprf.rp1.addr.eq(self._fetch.f_instruction[15:20])\\n', '            with cpu.Else():\\n', '                cpu.d.comb += self._gprf.rp1.addr.eq(self._decoder.rs1)\\n', '\\n', '            cpu.d.comb += self._debug.gprf_dat_r.eq(self._gprf.rp1.data)\\n', '        else:\\n', '            with cpu.If(~self._d.stall):\\n', '                cpu.d.comb += self._gprf.rp1.addr.eq(self._fetch.f_instruction[15:20])\\n', '            with cpu.Else():\\n', '                cpu.d.comb += self._gprf.rp1.addr.eq(self._decoder.rs1)\\n', '\\n', '        with cpu.If(~self._d.stall):\\n', '            cpu.d.comb += self._gprf.rp2.addr.eq(self._fetch.f_instruction[20:25])\\n', '        with cpu.Else():\\n', '            cpu.d.comb += self._gprf.rp2.addr.eq(self._decoder.rs2)\\n', '\\n', '        with cpu.If(~self._f.stall):\\n', '            cpu.d.sync += csrf_rp.addr.eq(self._fetch.f_instruction[20:32])\\n', '        cpu.d.comb += csrf_rp.en.eq(self._decoder.csr & self._d.valid)\\n', '\\n', '        # CSR set/clear instructions are translated to logic operations.\\n', '        x_csr_set_clear = self._x.sink.funct3[1]\\n', '        x_csr_clear     = x_csr_set_clear & self._x.sink.funct3[0]\\n', '        x_csr_fmt_i     = self._x.sink.funct3[2]\\n', '        x_csr_src1      = Mux(x_csr_fmt_i, self._x.sink.rs1, self._x.sink.src1)\\n', '        x_csr_src1      = Mux(x_csr_clear, ~x_csr_src1, x_csr_src1)\\n', '        x_csr_logic_op  = self._x.sink.funct3 | 0b100\\n', '\\n', '        cpu.d.comb += [\\n', '            self._logic.op  .eq(Mux(self._x.sink.csr, x_csr_logic_op, self._x.sink.funct3)),\\n', '            self._logic.src1.eq(Mux(self._x.sink.csr, x_csr_src1, self._x.sink.src1)),\\n', '            self._logic.src2.eq(self._x.sink.src2)\\n', '        ]\\n', '\\n', '        cpu.d.comb += [\\n', '            self._adder.d_sub  .eq(self._decoder.adder & self._decoder.adder_sub\\n', '                                 | self._decoder.compare | self._decoder.branch),\\n', '            self._adder.d_stall.eq(self._d.stall),\\n', '            self._adder.x_src1 .eq(self._x.sink.src1),\\n', '            self._adder.x_src2 .eq(self._x.sink.src2),\\n', '        ]\\n', '\\n', '        if self.with_muldiv:\\n', '            cpu.d.comb += [\\n', '                self._multiplier.d_op   .eq(self._decoder.funct3),\\n', '                self._multiplier.d_stall.eq(self._d.stall),\\n', '                self._multiplier.x_src1 .eq(self._x.sink.src1),\\n', '                self._multiplier.x_src2 .eq(self._x.sink.src2),\\n', '                self._multiplier.x_stall.eq(self._x.stall),\\n', '                self._multiplier.m_stall.eq(self._m.stall),\\n', '            ]\\n', '\\n', '            cpu.d.comb += [\\n', '                self._divider.x_op   .eq(self._x.sink.funct3),\\n', '                self._divider.x_src1 .eq(self._x.sink.src1),\\n', '                self._divider.x_src2 .eq(self._x.sink.src2),\\n', '                self._divider.x_valid.eq(self._x.sink.valid),\\n', '                self._divider.x_stall.eq(self._x.stall),\\n', '            ]\\n', '\\n', '            self._m.stall_on(self._divider.m_busy)\\n', '\\n', '        cpu.d.comb += [\\n', '            self._shifter.x_direction.eq(self._x.sink.direction),\\n', '            self._shifter.x_sext     .eq(self._x.sink.sext),\\n', '            self._shifter.x_shamt    .eq(self._x.sink.src2),\\n', '            self._shifter.x_src1     .eq(self._x.sink.src1),\\n', '            self._shifter.x_stall    .eq(self._x.stall),\\n', '        ]\\n', '\\n', '        # compare.op is shared by compare and branch instructions.\\n', '        with cpu.If(self._x.sink.compare):\\n', '            cpu.d.comb += self._compare.op.eq(self._x.sink.funct3[:2] << 1)\\n', '        with cpu.Else():\\n', '            cpu.d.comb += self._compare.op.eq(self._x.sink.funct3)\\n', '\\n', '        cpu.d.comb += [\\n', '            self._compare.zero    .eq(self._x.sink.src1 == self._x.sink.src2),\\n', '            self._compare.negative.eq(self._adder.x_result[-1]),\\n', '            self._compare.overflow.eq(self._adder.x_overflow),\\n', '            self._compare.carry   .eq(self._adder.x_carry)\\n', '        ]\\n', '\\n', '        cpu.d.comb += [\\n', '            self._exception.external_interrupt .eq(self.external_interrupt),\\n', '            self._exception.timer_interrupt    .eq(self.timer_interrupt),\\n', '            self._exception.software_interrupt .eq(self.software_interrupt),\\n', '            self._exception.m_fetch_misaligned .eq(self._m.sink.branch_taken\\n', '                                                 & self._m.sink.branch_target[:2].bool()),\\n', '            self._exception.m_fetch_error      .eq(self._m.sink.fetch_error),\\n', '            self._exception.m_fetch_badaddr    .eq(self._m.sink.fetch_badaddr),\\n', '            self._exception.m_load_misaligned  .eq(self._m.sink.load\\n', '                                                 & self._m.sink.loadstore_misaligned),\\n', '            self._exception.m_load_error       .eq(self._loadstore.m_load_error),\\n', '            self._exception.m_store_misaligned .eq(self._m.sink.store\\n', '                                                 & self._m.sink.loadstore_misaligned),\\n', '            self._exception.m_store_error      .eq(self._loadstore.m_store_error),\\n', '            self._exception.m_loadstore_badaddr.eq(self._loadstore.m_badaddr),\\n', '            self._exception.m_branch_target    .eq(self._m.sink.branch_target),\\n', '            self._exception.m_illegal          .eq(self._m.sink.illegal),\\n', '            self._exception.m_ecall            .eq(self._m.sink.ecall),\\n', '            self._exception.m_pc               .eq(self._m.sink.pc),\\n', '            self._exception.m_instruction      .eq(self._m.sink.instruction),\\n', '            self._exception.m_result           .eq(self._m.sink.result),\\n', '            self._exception.m_mret             .eq(self._m.sink.mret),\\n', '            self._exception.m_stall            .eq(self._m.sink.stall),\\n', '            self._exception.m_valid            .eq(self._m.valid)\\n', '        ]\\n', '\\n', '        m_ebreak = self._m.sink.ebreak\\n', '        if self.with_debug:\\n', '            # If dcsr.ebreakm is set, EBREAK instructions enter Debug Mode.\\n', '            # We do not want to raise an exception in this case because Debug Mode\\n', '            # should be invisible to software execution.\\n', '            m_ebreak &= ~self._debug.dcsr_ebreakm\\n', '        if self.with_trigger:\\n', '            m_trigger_trap = Signal()\\n', '            with cpu.If(~self._x.stall):\\n', '                cpu.d.sync += m_trigger_trap.eq(self._trigger.x_trap)\\n', '            m_ebreak |= m_trigger_trap\\n', '        cpu.d.comb += self._exception.m_ebreak.eq(m_ebreak)\\n', '\\n', '        self._m.kill_on(self._m.source.exception & self._m.source.valid)\\n', '\\n', '        cpu.d.comb += [\\n', '            self._data_sel.x_offset       .eq(self._adder.x_result[:2]),\\n', '            self._data_sel.x_funct3       .eq(self._x.sink.funct3),\\n', '            self._data_sel.x_store_operand.eq(self._x.sink.store_operand),\\n', '            self._data_sel.w_offset       .eq(self._w.sink.result[:2]),\\n', '            self._data_sel.w_funct3       .eq(self._w.sink.funct3),\\n', '            self._data_sel.w_load_data    .eq(self._w.sink.load_data)\\n', '        ]\\n', '\\n', '        cpu.d.comb += [\\n', '            self._loadstore.x_addr      .eq(self._adder.x_result),\\n', '            self._loadstore.x_mask      .eq(self._data_sel.x_mask),\\n', '            self._loadstore.x_load      .eq(self._x.sink.load),\\n', '            self._loadstore.x_store     .eq(self._x.sink.store),\\n', '            self._loadstore.x_store_data.eq(self._data_sel.x_store_data),\\n', '            self._loadstore.x_stall     .eq(self._x.stall),\\n', '            self._loadstore.x_valid     .eq(self._x.valid),\\n', '            self._loadstore.m_stall     .eq(self._m.stall),\\n', '            self._loadstore.m_valid     .eq(self._m.valid)\\n', '        ]\\n', '\\n', '        self._m.stall_on(self._loadstore.x_busy & self._x.valid)\\n', '        self._m.stall_on(self._loadstore.m_busy & self._m.valid)\\n', '\\n', '        if self.with_dcache:\\n', '            if self.with_debug:\\n', '                cpu.d.comb += self._loadstore.m_flush.eq(self._debug.resumereq)\\n', '\\n', '            cpu.d.comb += [\\n', '                self._loadstore.x_fence_i.eq(self._x.sink.fence_i),\\n', '                self._loadstore.m_load   .eq(self._m.sink.load),\\n', '                self._loadstore.m_store  .eq(self._m.sink.store),\\n', '            ]\\n', '\\n', '        for s in self._a, self._f:\\n', '            s.kill_on(self._x.sink.fence_i & self._x.valid)\\n', '\\n', '        if self.with_debug:\\n', '            debug_dbus_port     = self._dbus_arbiter.port(priority=0)\\n', '            loadstore_dbus_port = self._dbus_arbiter.port(priority=1)\\n', '            cpu.d.comb += [\\n', '                self._loadstore.dbus  .connect(loadstore_dbus_port),\\n', '                self._debug.dbus      .connect(debug_dbus_port),\\n', '                self._dbus_arbiter.bus.connect(self.dbus),\\n', '            ]\\n', '        else:\\n', '            cpu.d.comb += self._loadstore.dbus.connect(self.dbus)\\n', '\\n', '        # RAW hazard management\\n', '\\n', '        d_raw_rs1_x = Signal()\\n', '        d_raw_rs1_m = Signal()\\n', '        d_raw_rs1_w = Signal()\\n', '        d_raw_rs2_x = Signal()\\n', '        d_raw_rs2_m = Signal()\\n', '        d_raw_rs2_w = Signal()\\n', '\\n', '        with cpu.If((self._x.sink.rd != 0) & self._x.sink.rd_we):\\n', '            cpu.d.comb += [\\n', '                d_raw_rs1_x.eq(self._x.sink.rd == self._decoder.rs1),\\n', '                d_raw_rs2_x.eq(self._x.sink.rd == self._decoder.rs2),\\n', '            ]\\n', '\\n', '        with cpu.If((self._m.sink.rd != 0) & self._m.sink.rd_we):\\n', '            cpu.d.comb += [\\n', '                d_raw_rs1_m.eq(self._m.sink.rd == self._decoder.rs1),\\n', '                d_raw_rs2_m.eq(self._m.sink.rd == self._decoder.rs2),\\n', '            ]\\n', '\\n', '        with cpu.If((self._w.sink.rd != 0) & self._w.sink.rd_we):\\n', '            cpu.d.comb += [\\n', '                d_raw_rs1_w.eq(self._w.sink.rd == self._decoder.rs1),\\n', '                d_raw_rs2_w.eq(self._w.sink.rd == self._decoder.rs2),\\n', '            ]\\n', '\\n', '        d_raw_csr_x = Signal()\\n', '        d_raw_csr_m = Signal()\\n', '\\n', '        with cpu.If(self._x.sink.csr_we):\\n', '            cpu.d.comb += d_raw_csr_x.eq(self._x.sink.csr_adr == self._decoder.immediate)\\n', '\\n', '        with cpu.If(self._m.sink.csr_we):\\n', '            cpu.d.comb += d_raw_csr_m.eq(self._m.sink.csr_adr == self._decoder.immediate)\\n', '\\n', '        d_lock_x = Signal()\\n', '        d_lock_m = Signal()\\n', '        d_lock   = Signal()\\n', '\\n', '        with cpu.If(~self._x.sink.bypass_x):\\n', '            cpu.d.comb += d_lock_x.eq(self._decoder.rs1_re & d_raw_rs1_x\\n', '                                    | self._decoder.rs2_re & d_raw_rs2_x\\n', '                                    | self._decoder.csr    & d_raw_csr_x)\\n', '\\n', '        with cpu.If(~self._m.sink.bypass_m):\\n', '            cpu.d.comb += d_lock_m.eq(self._decoder.rs1_re & d_raw_rs1_m\\n', '                                    | self._decoder.rs2_re & d_raw_rs2_m\\n', '                                    | self._decoder.csr    & d_raw_csr_m)\\n', '\\n', '        cpu.d.comb += d_lock.eq(d_lock_x & self._x.valid | d_lock_m & self._m.valid)\\n', '\\n', '        if self.with_debug:\\n', '            self._d.stall_on(d_lock & self._d.valid & ~self._debug.dcsr_step)\\n', '        else:\\n', '            self._d.stall_on(d_lock & self._d.valid)\\n', '\\n', '        # Result selection\\n', '\\n', '        x_result     = Signal(32)\\n', '        m_result     = Signal(32)\\n', '        w_result     = Signal(32)\\n', '        x_csr_result = Signal(32)\\n', '\\n', '        with cpu.If(self._x.sink.jump):\\n', '            cpu.d.comb += x_result.eq(self._x.sink.pc + 4)\\n', '        with cpu.Elif(self._x.sink.logic):\\n', '            cpu.d.comb += x_result.eq(self._logic.result)\\n', '        with cpu.Elif(self._x.sink.csr):\\n', '            cpu.d.comb += x_result.eq(self._x.sink.src2)\\n', '        with cpu.Else():\\n', '            cpu.d.comb += x_result.eq(self._adder.x_result)\\n', '\\n', '        with cpu.If(self._m.sink.compare):\\n', '            cpu.d.comb += m_result.eq(self._m.sink.condition_met)\\n', '        if self.with_muldiv:\\n', '            with cpu.Elif(self._m.sink.divide):\\n', '                cpu.d.comb += m_result.eq(self._divider.m_result)\\n', '        with cpu.Elif(self._m.sink.shift):\\n', '            cpu.d.comb += m_result.eq(self._shifter.m_result)\\n', '        with cpu.Else():\\n', '            cpu.d.comb += m_result.eq(self._m.sink.result)\\n', '\\n', '        with cpu.If(self._w.sink.load):\\n', '            cpu.d.comb += w_result.eq(self._data_sel.w_load_result)\\n', '        if self.with_muldiv:\\n', '            with cpu.Elif(self._w.sink.multiply):\\n', '                cpu.d.comb += w_result.eq(self._multiplier.w_result)\\n', '        with cpu.Else():\\n', '            cpu.d.comb += w_result.eq(self._w.sink.result)\\n', '\\n', '        with cpu.If(x_csr_set_clear):\\n', '            cpu.d.comb += x_csr_result.eq(self._logic.result)\\n', '        with cpu.Else():\\n', '            cpu.d.comb += x_csr_result.eq(x_csr_src1)\\n', '\\n', '        # Register writeback\\n', '\\n', '        with cpu.If(~self._exception.m_raise & ~self._m.stall):\\n', '            cpu.d.comb += csrf_wp.en.eq(self._m.sink.csr & self._m.sink.csr_we & self._m.valid)\\n', '        cpu.d.comb += [\\n', '            csrf_wp.addr.eq(self._m.sink.csr_adr),\\n', '            csrf_wp.data.eq(self._m.sink.csr_result)\\n', '        ]\\n', '\\n', '        if self.with_debug:\\n', '            with cpu.If(self._debug.halt & self._debug.halted):\\n', '                cpu.d.comb += [\\n', '                    self._gprf.wp.addr.eq(self._debug.gprf_addr),\\n', '                    self._gprf.wp.en  .eq(self._debug.gprf_we),\\n', '                    self._gprf.wp.data.eq(self._debug.gprf_dat_w)\\n', '                ]\\n', '            with cpu.Else():\\n', '                with cpu.If((self._w.sink.rd != 0) & ~self._w.sink.exception):\\n', '                    cpu.d.comb += self._gprf.wp.en.eq(self._w.sink.rd_we & self._w.valid)\\n', '                cpu.d.comb += [\\n', '                    self._gprf.wp.addr.eq(self._w.sink.rd),\\n', '                    self._gprf.wp.data.eq(w_result)\\n', '                ]\\n', '        else:\\n', '            with cpu.If((self._w.sink.rd != 0) & ~self._w.sink.exception):\\n', '                cpu.d.comb += self._gprf.wp.en.eq(self._w.sink.rd_we & self._w.valid)\\n', '            cpu.d.comb += [\\n', '                self._gprf.wp.addr.eq(self._w.sink.rd),\\n', '                self._gprf.wp.data.eq(w_result)\\n', '            ]\\n', '\\n', '        # D stage operand selection\\n', '\\n', '        d_src1 = Signal(32)\\n', '        d_src2 = Signal(32)\\n', '\\n', '        with cpu.If(self._decoder.lui):\\n', '            cpu.d.comb += d_src1.eq(0)\\n', '        with cpu.Elif(self._decoder.auipc):\\n', '            cpu.d.comb += d_src1.eq(self._d.sink.pc)\\n', '        with cpu.Elif(self._decoder.rs1_re & (self._decoder.rs1 == 0)):\\n', '            cpu.d.comb += d_src1.eq(0)\\n', '        with cpu.Elif(d_raw_rs1_x & self._x.sink.valid):\\n', '            cpu.d.comb += d_src1.eq(x_result)\\n', '        with cpu.Elif(d_raw_rs1_m & self._m.sink.valid):\\n', '            cpu.d.comb += d_src1.eq(m_result)\\n', '        with cpu.Elif(d_raw_rs1_w & self._w.sink.valid):\\n', '            cpu.d.comb += d_src1.eq(w_result)\\n', '        with cpu.Else():\\n', '            cpu.d.comb += d_src1.eq(self._gprf.rp1.data)\\n', '\\n', '        with cpu.If(self._decoder.csr):\\n', '            cpu.d.comb += d_src2.eq(csrf_rp.data)\\n', '        with cpu.Elif(~self._decoder.rs2_re):\\n', '            cpu.d.comb += d_src2.eq(self._decoder.immediate)\\n', '        with cpu.Elif(self._decoder.rs2 == 0):\\n', '            cpu.d.comb += d_src2.eq(0)\\n', '        with cpu.Elif(d_raw_rs2_x & self._x.sink.valid):\\n', '            cpu.d.comb += d_src2.eq(x_result)\\n', '        with cpu.Elif(d_raw_rs2_m & self._m.sink.valid):\\n', '            cpu.d.comb += d_src2.eq(m_result)\\n', '        with cpu.Elif(d_raw_rs2_w & self._w.sink.valid):\\n', '            cpu.d.comb += d_src2.eq(w_result)\\n', '        with cpu.Else():\\n', '            cpu.d.comb += d_src2.eq(self._gprf.rp2.data)\\n', '\\n', '        # Branch prediction\\n', '\\n', '        cpu.d.comb += [\\n', '            self._predict.d_branch.eq(self._decoder.branch),\\n', '            self._predict.d_jump  .eq(self._decoder.jump),\\n', '            self._predict.d_offset.eq(self._decoder.immediate),\\n', '            self._predict.d_pc    .eq(self._d.sink.pc),\\n', '            self._predict.d_rs1_re.eq(self._decoder.rs1_re)\\n', '        ]\\n', '\\n', '        self._a.kill_on(self._predict.d_branch_taken & self._d.valid)\\n', '        for s in self._a, self._f:\\n', '            s.kill_on(self._m.sink.branch_predict_taken & ~self._m.sink.branch_taken\\n', '                    & self._m.valid)\\n', '        for s in self._a, self._f, self._d:\\n', '            s.kill_on(~self._m.sink.branch_predict_taken & self._m.sink.branch_taken\\n', '                    & self._m.valid)\\n', '            s.kill_on((self._exception.m_raise | self._m.sink.mret) & self._m.valid)\\n', '\\n', '        # Debug unit\\n', '\\n', '        if self.with_debug:\\n', '            cpu.d.comb += [\\n', '                self._debug.jtag.connect(self.jtag),\\n', '\\n', '                self._debug.x_pc           .eq(self._x.sink.pc),\\n', '                self._debug.x_ebreak       .eq(self._x.sink.ebreak),\\n', '                self._debug.x_stall        .eq(self._x.stall),\\n', '                self._debug.m_branch_taken .eq(self._m.sink.branch_taken),\\n', '                self._debug.m_branch_target.eq(self._m.sink.branch_target),\\n', '                self._debug.m_mret         .eq(self._m.sink.mret),\\n', '                self._debug.m_exception    .eq(self._exception.m_raise),\\n', '                self._debug.m_pc           .eq(self._m.sink.pc),\\n', '                self._debug.m_valid        .eq(self._m.valid),\\n', '                self._debug.mepc_r_base    .eq(self._exception.mepc.r.base),\\n', '                self._debug.mtvec_r_base   .eq(self._exception.mtvec.r.base)\\n', '            ]\\n', '\\n', '            if self.with_trigger:\\n', '                cpu.d.comb += self._debug.trigger_haltreq.eq(self._trigger.haltreq)\\n', '            else:\\n', '                cpu.d.comb += self._debug.trigger_haltreq.eq(Const(0))\\n', '\\n', '            csrf_debug_rp = self._csrf.read_port()\\n', '            csrf_debug_wp = self._csrf.write_port()\\n', '            cpu.d.comb += [\\n', '                csrf_debug_rp.addr.eq(self._debug.csrf_addr),\\n', '                csrf_debug_rp.en  .eq(self._debug.csrf_re),\\n', '                self._debug.csrf_dat_r.eq(csrf_debug_rp.data),\\n', '\\n', '                csrf_debug_wp.addr.eq(self._debug.csrf_addr),\\n', '                csrf_debug_wp.en  .eq(self._debug.csrf_we),\\n', '                csrf_debug_wp.data.eq(self._debug.csrf_dat_w)\\n', '            ]\\n', '\\n', '            self._x.stall_on(self._debug.halt)\\n', '            self._m.stall_on(self._debug.dcsr_step & self._m.valid & ~self._debug.halt)\\n', '            for s in self._a, self._f, self._d, self._x:\\n', '                s.kill_on(self._debug.killall)\\n', '\\n', '            halted = self._x.stall & ~reduce(or_, (s.valid for s in (self._m, self._w)))\\n', '            cpu.d.sync += self._debug.halted.eq(halted)\\n', '\\n', '            with cpu.If(self._debug.resumereq):\\n', '                with cpu.If(~self._debug.dbus_busy):\\n', '                    cpu.d.comb += self._debug.resumeack.eq(1)\\n', '                    cpu.d.sync += self._a.source.pc.eq(self._debug.dpc_value - 4)\\n', '\\n', '        if self.with_trigger:\\n', '            cpu.d.comb += [\\n', '                self._trigger.x_pc   .eq(self._x.sink.pc),\\n', '                self._trigger.x_valid.eq(self._x.valid),\\n', '            ]\\n', '\\n', '        # riscv-formal\\n', '\\n', '        if self.with_rvfi:\\n', '            rvficon_d_rs1_addr  = Signal.like(self._rvficon.d_rs1_addr)\\n', '            rvficon_d_rs2_addr  = Signal.like(self._rvficon.d_rs2_addr)\\n', '            rvficon_d_rs1_rdata = Signal.like(self._rvficon.d_rs1_rdata)\\n', '            rvficon_d_rs2_rdata = Signal.like(self._rvficon.d_rs2_rdata)\\n', '            rvficon_x_mem_wmask = Signal.like(self._rvficon.x_mem_wmask)\\n', '            rvficon_x_mem_rmask = Signal.like(self._rvficon.x_mem_rmask)\\n', '            rvficon_w_rd_addr   = Signal.like(self._rvficon.w_rd_addr)\\n', '            rvficon_w_rd_wdata  = Signal.like(self._rvficon.w_rd_wdata)\\n', '\\n', '            with cpu.If(self._decoder.rs1_re):\\n', '                cpu.d.comb += [\\n', '                    rvficon_d_rs1_addr .eq(self._decoder.rs1),\\n', '                    rvficon_d_rs1_rdata.eq(d_src1),\\n', '                ]\\n', '            with cpu.If(self._decoder.rs2_re):\\n', '                cpu.d.comb += [\\n', '                    rvficon_d_rs2_addr .eq(self._decoder.rs2),\\n', '                    rvficon_d_rs2_rdata.eq(d_src2),\\n', '                ]\\n', '\\n', '            with cpu.If(self._loadstore.x_store):\\n', '                cpu.d.comb += rvficon_x_mem_wmask.eq(self._loadstore.x_mask)\\n', '            with cpu.If(self._loadstore.x_load):\\n', '                cpu.d.comb += rvficon_x_mem_rmask.eq(self._loadstore.x_mask)\\n', '\\n', '            with cpu.If(self._gprf.wp.en):\\n', '                cpu.d.comb += [\\n', '                    rvficon_w_rd_addr .eq(self._gprf.wp.addr),\\n', '                    rvficon_w_rd_wdata.eq(self._gprf.wp.data),\\n', '                ]\\n', '\\n', '            cpu.d.comb += [\\n', '                self._rvficon.d_insn            .eq(self._decoder.instruction),\\n', '                self._rvficon.d_rs1_addr        .eq(rvficon_d_rs1_addr),\\n', '                self._rvficon.d_rs2_addr        .eq(rvficon_d_rs2_addr),\\n', '                self._rvficon.d_rs1_rdata       .eq(rvficon_d_rs1_rdata),\\n', '                self._rvficon.d_rs2_rdata       .eq(rvficon_d_rs2_rdata),\\n', '                self._rvficon.d_stall           .eq(self._d.stall),\\n', '                self._rvficon.x_mem_addr        .eq(self._loadstore.x_addr[2:] << 2),\\n', '                self._rvficon.x_mem_wmask       .eq(rvficon_x_mem_wmask),\\n', '                self._rvficon.x_mem_rmask       .eq(rvficon_x_mem_rmask),\\n', '                self._rvficon.x_mem_wdata       .eq(self._loadstore.x_store_data),\\n', '                self._rvficon.x_stall           .eq(self._x.stall),\\n', '                self._rvficon.m_mem_rdata       .eq(self._loadstore.m_load_data),\\n', '                self._rvficon.m_fetch_misaligned.eq(self._exception.m_fetch_misaligned),\\n', '                self._rvficon.m_illegal_insn    .eq(self._m.sink.illegal),\\n', '                self._rvficon.m_load_misaligned .eq(self._exception.m_load_misaligned),\\n', '                self._rvficon.m_store_misaligned.eq(self._exception.m_store_misaligned),\\n', '                self._rvficon.m_exception       .eq(self._exception.m_raise),\\n', '                self._rvficon.m_mret            .eq(self._m.sink.mret),\\n', '                self._rvficon.m_branch_taken    .eq(self._m.sink.branch_taken),\\n', '                self._rvficon.m_branch_target   .eq(self._m.sink.branch_target),\\n', '                self._rvficon.m_pc_rdata        .eq(self._m.sink.pc),\\n', '                self._rvficon.m_stall           .eq(self._m.stall),\\n', '                self._rvficon.m_valid           .eq(self._m.valid),\\n', '                self._rvficon.w_rd_addr         .eq(rvficon_w_rd_addr),\\n', '                self._rvficon.w_rd_wdata        .eq(rvficon_w_rd_wdata),\\n', '                self._rvficon.mtvec_r_base      .eq(self._exception.mtvec.r.base),\\n', '                self._rvficon.mepc_r_value      .eq(self._exception.mepc.r),\\n', '\\n', '                self._rvficon.rvfi.connect(self.rvfi),\\n', '            ]\\n', '\\n', '        # Pipeline registers\\n', '\\n', '        # A/F\\n', '\\n', '        with cpu.If(~self._a.stall):\\n', '            cpu.d.sync += self._a.source.pc.eq(self._fetch.a_pc)\\n', '\\n', '        # F/D\\n', '\\n', '        with cpu.If(~self._f.stall):\\n', '            cpu.d.sync += [\\n', '                self._f.source.pc           .eq(self._f.sink.pc),\\n', '                self._f.source.instruction  .eq(self._fetch.f_instruction),\\n', '                self._f.source.fetch_error  .eq(self._fetch.f_fetch_error),\\n', '                self._f.source.fetch_badaddr.eq(self._fetch.f_badaddr)\\n', '            ]\\n', '\\n', '        # D/X\\n', '\\n', '        d_adder_sub = Signal()\\n', '\\n', '        cpu.d.comb += d_adder_sub.eq(self._decoder.adder & self._decoder.adder_sub\\n', '                                   | self._decoder.compare\\n', '                                   | self._decoder.branch)\\n', '\\n', '        with cpu.If(~self._d.stall):\\n', '            cpu.d.sync += [\\n', '                self._d.source.pc                  .eq(self._d.sink.pc),\\n', '                self._d.source.instruction         .eq(self._d.sink.instruction),\\n', '                self._d.source.fetch_error         .eq(self._d.sink.fetch_error),\\n', '                self._d.source.fetch_badaddr       .eq(self._d.sink.fetch_badaddr),\\n', '                self._d.source.illegal             .eq(self._decoder.illegal),\\n', '                self._d.source.rd                  .eq(self._decoder.rd),\\n', '                self._d.source.rs1                 .eq(self._decoder.rs1),\\n', '                self._d.source.rd_we               .eq(self._decoder.rd_we),\\n', '                self._d.source.rs1_re              .eq(self._decoder.rs1_re),\\n', '                self._d.source.bypass_x            .eq(self._decoder.bypass_x),\\n', '                self._d.source.bypass_m            .eq(self._decoder.bypass_m),\\n', '                self._d.source.funct3              .eq(self._decoder.funct3),\\n', '                self._d.source.load                .eq(self._decoder.load),\\n', '                self._d.source.store               .eq(self._decoder.store),\\n', '                self._d.source.adder_sub           .eq(d_adder_sub),\\n', '                self._d.source.compare             .eq(self._decoder.compare),\\n', '                self._d.source.logic               .eq(self._decoder.logic),\\n', '                self._d.source.shift               .eq(self._decoder.shift),\\n', '                self._d.source.direction           .eq(self._decoder.direction),\\n', '                self._d.source.sext                .eq(self._decoder.sext),\\n', '                self._d.source.jump                .eq(self._decoder.jump),\\n', '                self._d.source.branch              .eq(self._decoder.branch),\\n', '                self._d.source.fence_i             .eq(self._decoder.fence_i),\\n', '                self._d.source.csr                 .eq(self._decoder.csr),\\n', '                self._d.source.csr_adr             .eq(self._decoder.immediate),\\n', '                self._d.source.csr_we              .eq(self._decoder.csr_we),\\n', '                self._d.source.ecall               .eq(self._decoder.ecall),\\n', '                self._d.source.ebreak              .eq(self._decoder.ebreak),\\n', '                self._d.source.mret                .eq(self._decoder.mret),\\n', '                self._d.source.src1                .eq(d_src1),\\n', '                self._d.source.store_operand       .eq(d_src2),\\n', '                self._d.source.branch_predict_taken.eq(self._predict.d_branch_taken),\\n', '                self._d.source.branch_target       .eq(self._predict.d_branch_target)\\n', '            ]\\n', '\\n', '            with cpu.If(self._decoder.store):\\n', '                cpu.d.sync += self._d.source.src2.eq(self._decoder.immediate)\\n', '            with cpu.Else():\\n', '                cpu.d.sync += self._d.source.src2.eq(d_src2)\\n', '\\n', '            if self.with_muldiv:\\n', '                cpu.d.sync += [\\n', '                    self._d.source.multiply.eq(self._decoder.multiply),\\n', '                    self._d.source.divide  .eq(self._decoder.divide)\\n', '                ]\\n', '\\n', '        # X/M\\n', '\\n', '        x_bypass_m = Signal()\\n', '\\n', '        cpu.d.comb += x_bypass_m.eq(self._x.sink.bypass_m | self._x.sink.bypass_x)\\n', '\\n', '        x_branch_taken  = Signal()\\n', '        x_branch_target = Signal(32)\\n', '\\n', '        cpu.d.comb += x_branch_taken.eq(self._x.sink.jump\\n', '                                      | self._x.sink.branch & self._compare.condition_met)\\n', '\\n', '        with cpu.If(self._x.sink.jump & self._x.sink.rs1_re): # JALR\\n', '            cpu.d.comb += x_branch_target.eq(self._adder.x_result[1:] << 1)\\n', '        with cpu.Else():\\n', '            cpu.d.comb += x_branch_target.eq(self._x.sink.branch_target)\\n', '\\n', '        with cpu.If(~self._x.stall):\\n', '            cpu.d.sync += [\\n', '                self._x.source.pc                  .eq(self._x.sink.pc),\\n', '                self._x.source.instruction         .eq(self._x.sink.instruction),\\n', '                self._x.source.fetch_error         .eq(self._x.sink.fetch_error),\\n', '                self._x.source.fetch_badaddr       .eq(self._x.sink.fetch_badaddr),\\n', '                self._x.source.illegal             .eq(self._x.sink.illegal),\\n', '                self._x.source.loadstore_misaligned.eq(self._data_sel.x_misaligned),\\n', '                self._x.source.ecall               .eq(self._x.sink.ecall),\\n', '                self._x.source.ebreak              .eq(self._x.sink.ebreak),\\n', '                self._x.source.rd                  .eq(self._x.sink.rd),\\n', '                self._x.source.rd_we               .eq(self._x.sink.rd_we),\\n', '                self._x.source.bypass_m            .eq(x_bypass_m),\\n', '                self._x.source.funct3              .eq(self._x.sink.funct3),\\n', '                self._x.source.load                .eq(self._x.sink.load),\\n', '                self._x.source.store               .eq(self._x.sink.store),\\n', '                self._x.source.store_data          .eq(self._loadstore.x_store_data),\\n', '                self._x.source.compare             .eq(self._x.sink.compare),\\n', '                self._x.source.shift               .eq(self._x.sink.shift),\\n', '                self._x.source.mret                .eq(self._x.sink.mret),\\n', '                self._x.source.condition_met       .eq(self._compare.condition_met),\\n', '                self._x.source.branch_taken        .eq(x_branch_taken),\\n', '                self._x.source.branch_target       .eq(x_branch_target),\\n', '                self._x.source.branch_predict_taken.eq(self._x.sink.branch_predict_taken),\\n', '                self._x.source.csr                 .eq(self._x.sink.csr),\\n', '                self._x.source.csr_adr             .eq(self._x.sink.csr_adr),\\n', '                self._x.source.csr_we              .eq(self._x.sink.csr_we),\\n', '                self._x.source.csr_result          .eq(x_csr_result),\\n', '                self._x.source.result              .eq(x_result)\\n', '            ]\\n', '\\n', '            if self.with_muldiv:\\n', '                cpu.d.sync += [\\n', '                    self._x.source.multiply.eq(self._x.sink.multiply),\\n', '                    self._x.source.divide  .eq(self._x.sink.divide)\\n', '                ]\\n', '\\n', '        # M/W\\n', '\\n', '        with cpu.If(~self._m.stall):\\n', '            cpu.d.sync += [\\n', '                self._m.source.pc       .eq(self._m.sink.pc),\\n', '                self._m.source.rd       .eq(self._m.sink.rd),\\n', '                self._m.source.load     .eq(self._m.sink.load),\\n', '                self._m.source.funct3   .eq(self._m.sink.funct3),\\n', '                self._m.source.load_data.eq(self._loadstore.m_load_data),\\n', '                self._m.source.rd_we    .eq(self._m.sink.rd_we),\\n', '                self._m.source.result   .eq(m_result),\\n', '                self._m.source.exception.eq(self._exception.m_raise)\\n', '            ]\\n', '            if self.with_muldiv:\\n', '                cpu.d.sync += [\\n', '                    self._m.source.multiply.eq(self._m.sink.multiply)\\n', '                ]\\n', '\\n', '        return cpu\\n']"}
{"text": "['from enum import Enum\\n', 'from collections import OrderedDict\\n', '\\n', 'from amaranth import *\\n', 'from amaranth.utils import bits_for\\n', '\\n', '\\n', '__all__ = [\"CSRAccess\", \"CSR\", \"AutoCSR\", \"CSRFile\"]\\n', '\\n', '\\n', 'class CSRAccess(Enum):\\n', '    RW = 0\\n', '    RO = 1\\n', '\\n', '\\n', 'class CSR(Record):\\n', '    def __init__(self, addr, description, name=None, src_loc_at=0):\\n', '        fields = []\\n', '        mask   = 0\\n', '        offset = 0\\n', '        for fname, shape, access in description:\\n', '            if isinstance(shape, int):\\n', '                shape = unsigned(shape)\\n', '            width = shape.width\\n', '            fields.append((fname, shape))\\n', '            if access is CSRAccess.RW:\\n', '                mask |= ((1 << width) - 1) << offset\\n', '            offset += width\\n', '\\n', '        self.addr = addr\\n', '        self.mask = mask\\n', '\\n', '        super().__init__([\\n', '            (\"r\",  fields),\\n', '            (\"w\",  fields),\\n', '            (\"re\", 1),\\n', '            (\"we\", 1),\\n', '        ], name=name, src_loc_at=1 + src_loc_at)\\n', '\\n', '\\n', 'class AutoCSR():\\n', '    def iter_csrs(self):\\n', '        for v in vars(self).values():\\n', '            if isinstance(v, CSR):\\n', '                yield v\\n', '            elif hasattr(v, \"iter_csrs\"):\\n', '                yield from v.iter_csrs()\\n', '\\n', '\\n', 'class CSRFile(Elaboratable):\\n', '    def __init__(self, width=32, depth=2**12):\\n', '        self.width = width\\n', '        self.depth = depth\\n', '        self._csr_map = OrderedDict()\\n', '        self._read_ports = []\\n', '        self._write_ports = []\\n', '\\n', '    def add_csrs(self, csrs):\\n', '        for csr in csrs:\\n', '            if not isinstance(csr, CSR):\\n', '                raise TypeError(\"Object {!r} is not a CSR\".format(csr))\\n', '            if csr.addr in self._csr_map:\\n', '                raise ValueError(\"CSR address 0x{:x} has already been allocated\"\\n', '                                 .format(csr.addr))\\n', '            self._csr_map[csr.addr] = csr\\n', '\\n', '    def read_port(self):\\n', '        port = Record([(\"addr\", bits_for(self.depth)), (\"en\", 1), (\"data\", self.width)], name=\"rp\")\\n', '        self._read_ports.append(port)\\n', '        return port\\n', '\\n', '    def write_port(self):\\n', '        port = Record([(\"addr\", bits_for(self.depth)), (\"en\", 1), (\"data\", self.width)], name=\"wp\")\\n', '        self._write_ports.append(port)\\n', '        return port\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        for rp in self._read_ports:\\n', '            with m.Switch(rp.addr):\\n', '                for addr, csr in self._csr_map.items():\\n', '                    with m.Case(addr):\\n', '                        m.d.comb += [\\n', '                            csr.re.eq(rp.en),\\n', '                            rp.data.eq(csr.r)\\n', '                        ]\\n', '\\n', '        for wp in self._write_ports:\\n', '            with m.Switch(wp.addr):\\n', '                for addr, csr in self._csr_map.items():\\n', '                    with m.Case(addr):\\n', '                        m.d.comb += csr.we.eq(wp.en)\\n', '                        for i in range(self.width):\\n', '                            rw = (1 << i) & csr.mask\\n', '                            m.d.comb += csr.w[i].eq(wp.data[i] if rw else csr.r[i])\\n', '\\n', '        return m\\n']"}
{"text": "['from functools import reduce\\n', 'from itertools import starmap\\n', 'from operator import or_\\n', '\\n', 'from amaranth import *\\n', '\\n', 'from ..isa import Opcode, Funct3, Funct7, Funct12\\n', '\\n', '\\n', '__all__ = [\"InstructionDecoder\"]\\n', '\\n', '\\n', 'class Type:\\n', '    R = 0\\n', '    I = 1\\n', '    S = 2\\n', '    B = 3\\n', '    U = 4\\n', '    J = 5\\n', '\\n', '\\n', 'class InstructionDecoder(Elaboratable):\\n', '    def __init__(self, with_muldiv):\\n', '        self.with_muldiv = with_muldiv\\n', '\\n', '        self.instruction = Signal(32)\\n', '\\n', '        self.rd = Signal(5)\\n', '        self.rd_we = Signal()\\n', '        self.rs1 = Signal(5)\\n', '        self.rs1_re = Signal()\\n', '        self.rs2 = Signal(5)\\n', '        self.rs2_re = Signal()\\n', '        self.immediate = Signal(signed(32))\\n', '        self.bypass_x = Signal()\\n', '        self.bypass_m = Signal()\\n', '        self.load = Signal()\\n', '        self.store = Signal()\\n', '        self.fence_i = Signal()\\n', '        self.adder = Signal()\\n', '        self.adder_sub = Signal()\\n', '        self.logic = Signal()\\n', '        self.multiply = Signal()\\n', '        self.divide = Signal()\\n', '        self.shift = Signal()\\n', '        self.direction = Signal()\\n', '        self.sext = Signal()\\n', '        self.lui = Signal()\\n', '        self.auipc = Signal()\\n', '        self.jump = Signal()\\n', '        self.branch = Signal()\\n', '        self.compare = Signal()\\n', '        self.csr = Signal()\\n', '        self.csr_we = Signal()\\n', '        self.privileged = Signal()\\n', '        self.ecall = Signal()\\n', '        self.ebreak = Signal()\\n', '        self.mret = Signal()\\n', '        self.funct3 = Signal(3)\\n', '        self.illegal = Signal()\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        opcode = Signal(5)\\n', '        funct3 = Signal(3)\\n', '        funct7 = Signal(7)\\n', '        funct12 = Signal(12)\\n', '\\n', '        iimm12 = Signal(signed(12))\\n', '        simm12 = Signal(signed(12))\\n', '        bimm12 = Signal(signed(13))\\n', '        uimm20 = Signal(20)\\n', '        jimm20 = Signal(signed(21))\\n', '\\n', '        insn = self.instruction\\n', '        fmt = Signal(range(Type.J + 1))\\n', '\\n', '        m.d.comb += [\\n', '            opcode.eq(insn[2:7]),\\n', '            funct3.eq(insn[12:15]),\\n', '            funct7.eq(insn[25:32]),\\n', '            funct12.eq(insn[20:32]),\\n', '\\n', '            iimm12.eq(insn[20:32]),\\n', '            simm12.eq(Cat(insn[7:12], insn[25:32])),\\n', '            bimm12.eq(Cat(0, insn[8:12], insn[25:31], insn[7], insn[31])),\\n', '            uimm20.eq(insn[12:32]),\\n', '            jimm20.eq(Cat(0, insn[21:31], insn[20], insn[12:20], insn[31])),\\n', '        ]\\n', '\\n', '        with m.Switch(opcode):\\n', '            with m.Case(Opcode.LUI):\\n', '                m.d.comb += fmt.eq(Type.U)\\n', '            with m.Case(Opcode.AUIPC):\\n', '                m.d.comb += fmt.eq(Type.U)\\n', '            with m.Case(Opcode.JAL):\\n', '                m.d.comb += fmt.eq(Type.J)\\n', '            with m.Case(Opcode.JALR):\\n', '                m.d.comb += fmt.eq(Type.I)\\n', '            with m.Case(Opcode.BRANCH):\\n', '                m.d.comb += fmt.eq(Type.B)\\n', '            with m.Case(Opcode.LOAD):\\n', '                m.d.comb += fmt.eq(Type.I)\\n', '            with m.Case(Opcode.STORE):\\n', '                m.d.comb += fmt.eq(Type.S)\\n', '            with m.Case(Opcode.OP_IMM_32):\\n', '                m.d.comb += fmt.eq(Type.I)\\n', '            with m.Case(Opcode.OP_32):\\n', '                m.d.comb += fmt.eq(Type.R)\\n', '            with m.Case(Opcode.MISC_MEM):\\n', '                m.d.comb += fmt.eq(Type.I)\\n', '            with m.Case(Opcode.SYSTEM):\\n', '                m.d.comb += fmt.eq(Type.I)\\n', '\\n', '        with m.Switch(fmt):\\n', '            with m.Case(Type.I):\\n', '                m.d.comb += self.immediate.eq(iimm12)\\n', '            with m.Case(Type.S):\\n', '                m.d.comb += self.immediate.eq(simm12)\\n', '            with m.Case(Type.B):\\n', '                m.d.comb += self.immediate.eq(bimm12)\\n', '            with m.Case(Type.U):\\n', '                m.d.comb += self.immediate.eq(uimm20 << 12)\\n', '            with m.Case(Type.J):\\n', '                m.d.comb += self.immediate.eq(jimm20)\\n', '\\n', '        m.d.comb += [\\n', '            self.rd.eq(insn[7:12]),\\n', '            self.rs1.eq(insn[15:20]),\\n', '            self.rs2.eq(insn[20:25]),\\n', '\\n', '            self.rd_we.eq(reduce(or_, (fmt == T for T in (Type.R, Type.I, Type.U, Type.J)))),\\n', '            self.rs1_re.eq(reduce(or_, (fmt == T for T in (Type.R, Type.I, Type.S, Type.B)))),\\n', '            self.rs2_re.eq(reduce(or_, (fmt == T for T in (Type.R, Type.S, Type.B)))),\\n', '\\n', '            self.funct3.eq(funct3)\\n', '        ]\\n', '\\n', '        def matcher(encodings):\\n', '            return reduce(or_, starmap(\\n', '                lambda opc, f3=None, f7=None, f12=None:\\n', '                    (opcode  == opc if opc is not None else 1) \\\\\\n', '                  & (funct3  == f3  if f3  is not None else 1) \\\\\\n', '                  & (funct7  == f7  if f7  is not None else 1) \\\\\\n', '                  & (funct12 == f12 if f12 is not None else 1),\\n', '                encodings))\\n', '\\n', '        m.d.comb += [\\n', '            self.compare.eq(matcher([\\n', '                (Opcode.OP_IMM_32, Funct3.SLT,  None), # slti\\n', '                (Opcode.OP_IMM_32, Funct3.SLTU, None), # sltiu\\n', '                (Opcode.OP_32,     Funct3.SLT,  0),    # slt\\n', '                (Opcode.OP_32,     Funct3.SLTU, 0)     # sltu\\n', '            ])),\\n', '            self.branch.eq(matcher([\\n', '                (Opcode.BRANCH, Funct3.BEQ,  None), # beq\\n', '                (Opcode.BRANCH, Funct3.BNE,  None), # bne\\n', '                (Opcode.BRANCH, Funct3.BLT,  None), # blt\\n', '                (Opcode.BRANCH, Funct3.BGE,  None), # bge\\n', '                (Opcode.BRANCH, Funct3.BLTU, None), # bltu\\n', '                (Opcode.BRANCH, Funct3.BGEU, None)  # bgeu\\n', '            ])),\\n', '\\n', '            self.adder.eq(matcher([\\n', '                (Opcode.OP_IMM_32, Funct3.ADD, None),       # addi\\n', '                (Opcode.OP_32,     Funct3.ADD, Funct7.ADD), # add\\n', '                (Opcode.OP_32,     Funct3.ADD, Funct7.SUB)  # sub\\n', '            ])),\\n', '            self.adder_sub.eq(self.rs2_re & (funct7 == Funct7.SUB)),\\n', '\\n', '            self.logic.eq(matcher([\\n', '                (Opcode.OP_IMM_32, Funct3.XOR, None), # xori\\n', '                (Opcode.OP_IMM_32, Funct3.OR,  None), # ori\\n', '                (Opcode.OP_IMM_32, Funct3.AND, None), # andi\\n', '                (Opcode.OP_32,     Funct3.XOR, 0),    # xor\\n', '                (Opcode.OP_32,     Funct3.OR,  0),    # or\\n', '                (Opcode.OP_32,     Funct3.AND, 0)     # and\\n', '            ])),\\n', '        ]\\n', '\\n', '        if self.with_muldiv:\\n', '            m.d.comb += [\\n', '                self.multiply.eq(matcher([\\n', '                    (Opcode.OP_32, Funct3.MUL,    Funct7.MULDIV), # mul\\n', '                    (Opcode.OP_32, Funct3.MULH,   Funct7.MULDIV), # mulh\\n', '                    (Opcode.OP_32, Funct3.MULHSU, Funct7.MULDIV), # mulhsu\\n', '                    (Opcode.OP_32, Funct3.MULHU,  Funct7.MULDIV), # mulhu\\n', '                ])),\\n', '\\n', '                self.divide.eq(matcher([\\n', '                    (Opcode.OP_32, Funct3.DIV,  Funct7.MULDIV), # div\\n', '                    (Opcode.OP_32, Funct3.DIVU, Funct7.MULDIV), # divu\\n', '                    (Opcode.OP_32, Funct3.REM,  Funct7.MULDIV), # rem\\n', '                    (Opcode.OP_32, Funct3.REMU, Funct7.MULDIV)  # remu\\n', '                ])),\\n', '            ]\\n', '\\n', '        m.d.comb += [\\n', '            self.shift.eq(matcher([\\n', '                (Opcode.OP_IMM_32, Funct3.SLL, 0),          # slli\\n', '                (Opcode.OP_IMM_32, Funct3.SR,  Funct7.SRL), # srli\\n', '                (Opcode.OP_IMM_32, Funct3.SR,  Funct7.SRA), # srai\\n', '                (Opcode.OP_32,     Funct3.SLL, 0),          # sll\\n', '                (Opcode.OP_32,     Funct3.SR,  Funct7.SRL), # srl\\n', '                (Opcode.OP_32,     Funct3.SR,  Funct7.SRA)  # sra\\n', '            ])),\\n', '            self.direction.eq(funct3 == Funct3.SR),\\n', '            self.sext.eq(funct7 == Funct7.SRA),\\n', '\\n', '            self.lui.eq(opcode == Opcode.LUI),\\n', '            self.auipc.eq(opcode == Opcode.AUIPC),\\n', '\\n', '            self.jump.eq(matcher([\\n', '                (Opcode.JAL,  None), # jal\\n', '                (Opcode.JALR, 0)     # jalr\\n', '            ])),\\n', '\\n', '            self.load.eq(matcher([\\n', '                (Opcode.LOAD, Funct3.B),  # lb\\n', '                (Opcode.LOAD, Funct3.BU), # lbu\\n', '                (Opcode.LOAD, Funct3.H),  # lh\\n', '                (Opcode.LOAD, Funct3.HU), # lhu\\n', '                (Opcode.LOAD, Funct3.W)   # lw\\n', '            ])),\\n', '            self.store.eq(matcher([\\n', '                (Opcode.STORE, Funct3.B), # sb\\n', '                (Opcode.STORE, Funct3.H), # sh\\n', '                (Opcode.STORE, Funct3.W)  # sw\\n', '            ])),\\n', '\\n', '            self.fence_i.eq(matcher([\\n', '                (Opcode.MISC_MEM, Funct3.FENCEI) # fence.i\\n', '            ])),\\n', '\\n', '            self.csr.eq(matcher([\\n', '                (Opcode.SYSTEM, Funct3.CSRRW),  # csrrw\\n', '                (Opcode.SYSTEM, Funct3.CSRRS),  # csrrs\\n', '                (Opcode.SYSTEM, Funct3.CSRRC),  # csrrc\\n', '                (Opcode.SYSTEM, Funct3.CSRRWI), # csrrwi\\n', '                (Opcode.SYSTEM, Funct3.CSRRSI), # csrrsi\\n', '                (Opcode.SYSTEM, Funct3.CSRRCI)  # csrrci\\n', '            ])),\\n', '            self.csr_we.eq(~funct3[1] | (self.rs1 != 0)),\\n', '\\n', '            self.privileged.eq((opcode == Opcode.SYSTEM) & (funct3 == Funct3.PRIV)),\\n', '            self.ecall.eq(self.privileged & (funct12 == Funct12.ECALL)),\\n', '            self.ebreak.eq(self.privileged & (funct12 == Funct12.EBREAK)),\\n', '            self.mret.eq(self.privileged & (funct12 == Funct12.MRET)),\\n', '\\n', '            self.bypass_x.eq(self.adder | self.logic | self.lui | self.auipc | self.csr),\\n', '            self.bypass_m.eq(self.compare | self.divide | self.shift),\\n', '\\n', '            self.illegal.eq((self.instruction[:2] != 0b11) | ~reduce(or_, (\\n', '                self.compare, self.branch, self.adder, self.logic, self.multiply, self.divide, self.shift,\\n', '                self.lui, self.auipc, self.jump, self.load, self.store,\\n', '                self.csr, self.ecall, self.ebreak, self.mret, self.fence_i,\\n', '            )))\\n', '        ]\\n', '\\n', '        return m\\n']"}
{"text": "['from amaranth import *\\n', '\\n', 'from ..isa import Funct3\\n', '\\n', '\\n', '__all__ = [\"DividerInterface\", \"Divider\", \"DummyDivider\"]\\n', '\\n', '\\n', 'class DividerInterface:\\n', '    def __init__(self):\\n', '        self.x_op     = Signal(3)\\n', '        self.x_src1   = Signal(32)\\n', '        self.x_src2   = Signal(32)\\n', '        self.x_valid  = Signal()\\n', '        self.x_stall  = Signal()\\n', '\\n', '        self.m_result = Signal(32)\\n', '        self.m_busy   = Signal()\\n', '\\n', '\\n', 'class Divider(DividerInterface, Elaboratable):\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        x_enable  = Signal()\\n', '        x_modulus = Signal()\\n', '        x_signed  = Signal()\\n', '\\n', '        with m.Switch(self.x_op):\\n', '            with m.Case(Funct3.DIV):\\n', '                m.d.comb += x_enable.eq(1), x_signed.eq(1)\\n', '            with m.Case(Funct3.DIVU):\\n', '                m.d.comb += x_enable.eq(1)\\n', '            with m.Case(Funct3.REM):\\n', '                m.d.comb += x_enable.eq(1), x_modulus.eq(1), x_signed.eq(1)\\n', '            with m.Case(Funct3.REMU):\\n', '                m.d.comb += x_enable.eq(1), x_modulus.eq(1)\\n', '\\n', '        x_negative = Signal()\\n', '        with m.If(x_modulus):\\n', '            m.d.comb += x_negative.eq(x_signed & self.x_src1[31])\\n', '        with m.Else():\\n', '            m.d.comb += x_negative.eq(x_signed & (self.x_src1[31] ^ self.x_src2[31]))\\n', '\\n', '        x_dividend = Signal(32)\\n', '        x_divisor  = Signal(32)\\n', '        m.d.comb += [\\n', '            x_dividend.eq(Mux(x_signed & self.x_src1[31], -self.x_src1, self.x_src1)),\\n', '            x_divisor.eq(Mux(x_signed & self.x_src2[31], -self.x_src2, self.x_src2))\\n', '        ]\\n', '\\n', '        m_modulus  = Signal()\\n', '        m_negative = Signal()\\n', '\\n', '        timer      = Signal(range(33), reset=32)\\n', '        quotient   = Signal(32)\\n', '        divisor    = Signal(32)\\n', '        remainder  = Signal(32)\\n', '        difference = Signal(33)\\n', '\\n', '        with m.FSM() as fsm:\\n', '            with m.State(\"IDLE\"):\\n', '                with m.If(x_enable & self.x_valid & ~self.x_stall):\\n', '                    m.d.sync += [\\n', '                        m_modulus.eq(x_modulus),\\n', '                        m_negative.eq(x_negative)\\n', '                    ]\\n', '                    with m.If(x_divisor == 0):\\n', '                        # Division by zero\\n', '                        m.d.sync += [\\n', '                            quotient.eq(-1),\\n', '                            remainder.eq(self.x_src1)\\n', '                        ]\\n', '                    with m.Elif(x_signed & (self.x_src1 == -2**31) & (self.x_src2 == -1)):\\n', '                        # Signed overflow\\n', '                        m.d.sync += [\\n', '                            quotient.eq(self.x_src1),\\n', '                            remainder.eq(0)\\n', '                        ]\\n', '                    with m.Elif(x_dividend == 0):\\n', '                        m.d.sync += [\\n', '                            quotient.eq(0),\\n', '                            remainder.eq(0)\\n', '                        ]\\n', '                    with m.Else():\\n', '                        m.d.sync += [\\n', '                            quotient.eq(x_dividend),\\n', '                            remainder.eq(0),\\n', '                            divisor.eq(x_divisor),\\n', '                            timer.eq(timer.reset)\\n', '                        ]\\n', '                        m.next = \"DIVIDE\"\\n', '\\n', '            with m.State(\"DIVIDE\"):\\n', '                m.d.comb += self.m_busy.eq(1)\\n', '                with m.If(timer != 0):\\n', '                    m.d.sync += timer.eq(timer - 1)\\n', '                    m.d.comb += difference.eq(Cat(quotient[31], remainder) - divisor)\\n', '                    with m.If(difference[32]):\\n', '                        m.d.sync += [\\n', '                            remainder.eq(Cat(quotient[31], remainder)),\\n', '                            quotient.eq(Cat(0, quotient))\\n', '                        ]\\n', '                    with m.Else():\\n', '                        m.d.sync += [\\n', '                            remainder.eq(difference),\\n', '                            quotient.eq(Cat(1, quotient))\\n', '                        ]\\n', '                with m.Else():\\n', '                    m.d.sync += [\\n', '                        quotient.eq(Mux(m_negative, -quotient, quotient)),\\n', '                        remainder.eq(Mux(m_negative, -remainder, remainder))\\n', '                    ]\\n', '                    m.next = \"IDLE\"\\n', '\\n', '        m.d.comb += self.m_result.eq(Mux(m_modulus, remainder, quotient))\\n', '\\n', '        return m\\n', '\\n', '\\n', 'class DummyDivider(DividerInterface, Elaboratable):\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        x_result = Signal.like(self.m_result)\\n', '\\n', '        with m.Switch(self.x_op):\\n', '            # As per the RVFI specification (\u00c2\u00a7 \"Alternative Arithmetic Operations\").\\n', '            # https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/rvfi.md\\n', '            with m.Case(Funct3.DIV):\\n', '                m.d.comb += x_result.eq((self.x_src1 - self.x_src2) ^ C(0x7f8529ec))\\n', '            with m.Case(Funct3.DIVU):\\n', '                m.d.comb += x_result.eq((self.x_src1 - self.x_src2) ^ C(0x10e8fd70))\\n', '            with m.Case(Funct3.REM):\\n', '                m.d.comb += x_result.eq((self.x_src1 - self.x_src2) ^ C(0x8da68fa5))\\n', '            with m.Case(Funct3.REMU):\\n', '                m.d.comb += x_result.eq((self.x_src1 - self.x_src2) ^ C(0x3138d0e1))\\n', '\\n', '        with m.If(~self.x_stall):\\n', '            m.d.sync += self.m_result.eq(x_result)\\n', '\\n', '        m.d.comb += self.m_busy.eq(C(0))\\n', '\\n', '        return m\\n']"}
{"text": "['from amaranth import *\\n', 'from amaranth.lib.coding import PriorityEncoder\\n', '\\n', 'from ..csr import *\\n', 'from ..isa import *\\n', '\\n', '\\n', '__all__ = [\"ExceptionUnit\"]\\n', '\\n', '\\n', 'class ExceptionUnit(Elaboratable, AutoCSR):\\n', '    def __init__(self):\\n', '        self.mstatus     = CSR(0x300, mstatus_layout)\\n', '        self.misa        = CSR(0x301, misa_layout) # FIXME move elsewhere\\n', '        self.mie         = CSR(0x304, mie_layout)\\n', '        self.mtvec       = CSR(0x305, mtvec_layout)\\n', '        self.mscratch    = CSR(0x340, flat_layout) # FIXME move elsewhere\\n', '        self.mepc        = CSR(0x341, mepc_layout)\\n', '        self.mcause      = CSR(0x342, mcause_layout)\\n', '        self.mtval       = CSR(0x343, flat_layout)\\n', '        self.mip         = CSR(0x344, mip_layout)\\n', '        self.irq_mask    = CSR(0x330, flat_layout)\\n', '        self.irq_pending = CSR(0x360, flat_layout)\\n', '\\n', '        self.external_interrupt = Signal(32)\\n', '        self.timer_interrupt = Signal()\\n', '        self.software_interrupt = Signal()\\n', '\\n', '        self.m_fetch_misaligned = Signal()\\n', '        self.m_fetch_error = Signal()\\n', '        self.m_fetch_badaddr = Signal(30)\\n', '        self.m_load_misaligned = Signal()\\n', '        self.m_load_error = Signal()\\n', '        self.m_store_misaligned = Signal()\\n', '        self.m_store_error = Signal()\\n', '        self.m_loadstore_badaddr = Signal(30)\\n', '        self.m_branch_target = Signal(32)\\n', '        self.m_illegal = Signal()\\n', '        self.m_ebreak = Signal()\\n', '        self.m_ecall = Signal()\\n', '        self.m_pc = Signal(32)\\n', '        self.m_instruction = Signal(32)\\n', '        self.m_result = Signal(32)\\n', '        self.m_mret = Signal()\\n', '        self.m_stall = Signal()\\n', '        self.m_valid = Signal()\\n', '\\n', '        self.m_raise = Signal()\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        for csr in self.iter_csrs():\\n', '            with m.If(csr.we):\\n', '                m.d.sync += csr.r.eq(csr.w)\\n', '\\n', '        trap_pe = m.submodules.trap_pe = PriorityEncoder(16)\\n', '        m.d.comb += [\\n', '            trap_pe.i[Cause.FETCH_MISALIGNED   ].eq(self.m_fetch_misaligned),\\n', '            trap_pe.i[Cause.FETCH_ACCESS_FAULT ].eq(self.m_fetch_error),\\n', '            trap_pe.i[Cause.ILLEGAL_INSTRUCTION].eq(self.m_illegal),\\n', '            trap_pe.i[Cause.BREAKPOINT         ].eq(self.m_ebreak),\\n', '            trap_pe.i[Cause.LOAD_MISALIGNED    ].eq(self.m_load_misaligned),\\n', '            trap_pe.i[Cause.LOAD_ACCESS_FAULT  ].eq(self.m_load_error),\\n', '            trap_pe.i[Cause.STORE_MISALIGNED   ].eq(self.m_store_misaligned),\\n', '            trap_pe.i[Cause.STORE_ACCESS_FAULT ].eq(self.m_store_error),\\n', '            trap_pe.i[Cause.ECALL_FROM_M       ].eq(self.m_ecall)\\n', '        ]\\n', '\\n', '        m.d.sync += [\\n', '            self.irq_pending.r.eq(self.external_interrupt & self.irq_mask.r),\\n', '            self.mip.r.msip.eq(self.software_interrupt),\\n', '            self.mip.r.mtip.eq(self.timer_interrupt),\\n', '            self.mip.r.meip.eq(self.irq_pending.r.bool())\\n', '        ]\\n', '\\n', '        interrupt_pe = m.submodules.interrupt_pe = PriorityEncoder(16)\\n', '        m.d.comb += [\\n', '            interrupt_pe.i[Cause.M_SOFTWARE_INTERRUPT].eq(self.mip.r.msip & self.mie.r.msie),\\n', '            interrupt_pe.i[Cause.M_TIMER_INTERRUPT   ].eq(self.mip.r.mtip & self.mie.r.mtie),\\n', '            interrupt_pe.i[Cause.M_EXTERNAL_INTERRUPT].eq(self.mip.r.meip & self.mie.r.meie)\\n', '        ]\\n', '\\n', '        m.d.comb += self.m_raise.eq(~trap_pe.n | ~interrupt_pe.n & self.mstatus.r.mie)\\n', '\\n', '        with m.If(self.m_valid & ~self.m_stall):\\n', '            with m.If(self.m_raise):\\n', '                m.d.sync += [\\n', '                    self.mstatus.r.mpie.eq(self.mstatus.r.mie),\\n', '                    self.mstatus.r.mie.eq(0),\\n', '                    self.mepc.r.base.eq(self.m_pc[2:])\\n', '                ]\\n', '                with m.If(~trap_pe.n):\\n', '                    m.d.sync += [\\n', '                        self.mcause.r.ecode.eq(trap_pe.o),\\n', '                        self.mcause.r.interrupt.eq(0)\\n', '                    ]\\n', '                    with m.Switch(trap_pe.o):\\n', '                        with m.Case(Cause.FETCH_MISALIGNED):\\n', '                            m.d.sync += self.mtval.r.eq(self.m_branch_target)\\n', '                        with m.Case(Cause.FETCH_ACCESS_FAULT):\\n', '                            m.d.sync += self.mtval.r.eq(self.m_fetch_badaddr << 2)\\n', '                        with m.Case(Cause.ILLEGAL_INSTRUCTION):\\n', '                            m.d.sync += self.mtval.r.eq(self.m_instruction)\\n', '                        with m.Case(Cause.BREAKPOINT):\\n', '                            m.d.sync += self.mtval.r.eq(self.m_pc)\\n', '                        with m.Case(Cause.LOAD_MISALIGNED, Cause.STORE_MISALIGNED):\\n', '                            m.d.sync += self.mtval.r.eq(self.m_result)\\n', '                        with m.Case(Cause.LOAD_ACCESS_FAULT, Cause.STORE_ACCESS_FAULT):\\n', '                            m.d.sync += self.mtval.r.eq(self.m_loadstore_badaddr << 2)\\n', '                        with m.Case():\\n', '                            m.d.sync += self.mtval.r.eq(0)\\n', '                with m.Else():\\n', '                    m.d.sync += [\\n', '                        self.mcause.r.ecode.eq(interrupt_pe.o),\\n', '                        self.mcause.r.interrupt.eq(1)\\n', '                    ]\\n', '            with m.Elif(self.m_mret):\\n', '                m.d.sync += self.mstatus.r.mie.eq(self.mstatus.r.mpie)\\n', '\\n', '        return m\\n']"}
{"text": "['from amaranth import *\\n', 'from amaranth.utils import log2_int\\n', '\\n', 'from ..cache import *\\n', 'from ..wishbone import *\\n', '\\n', '\\n', '__all__ = [\"PCSelector\", \"FetchUnitInterface\", \"BareFetchUnit\", \"CachedFetchUnit\"]\\n', '\\n', '\\n', 'class PCSelector(Elaboratable):\\n', '    def __init__(self):\\n', '        self.f_pc = Signal(32)\\n', '        self.d_pc = Signal(32)\\n', '        self.d_branch_predict_taken = Signal()\\n', '        self.d_branch_target = Signal(32)\\n', '        self.d_valid = Signal()\\n', '        self.x_pc = Signal(32)\\n', '        self.x_fence_i = Signal()\\n', '        self.x_valid = Signal()\\n', '        self.m_branch_predict_taken = Signal()\\n', '        self.m_branch_taken = Signal()\\n', '        self.m_branch_target = Signal(32)\\n', '        self.m_exception = Signal()\\n', '        self.m_mret = Signal()\\n', '        self.m_valid = Signal()\\n', '        self.mtvec_r_base = Signal(30)\\n', '        self.mepc_r_base = Signal(30)\\n', '\\n', '        self.a_pc = Signal(32)\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        m_sel   = Signal(reset=1)\\n', '        m_pc4_a = Signal(30)\\n', '        a_pc4   = Signal(30)\\n', '\\n', '        with m.If(self.m_exception):\\n', '            m.d.comb += m_pc4_a.eq(self.mtvec_r_base)\\n', '        with m.Elif(self.m_mret):\\n', '            m.d.comb += m_pc4_a.eq(self.mepc_r_base)\\n', '        with m.Elif(self.m_branch_predict_taken & ~self.m_branch_taken):\\n', '            m.d.comb += m_pc4_a.eq(self.x_pc[2:])\\n', '        with m.Elif(~self.m_branch_predict_taken & self.m_branch_taken):\\n', '            m.d.comb += m_pc4_a.eq(self.m_branch_target[2:]),\\n', '        with m.Else():\\n', '            m.d.comb += m_sel.eq(0)\\n', '\\n', '        with m.If(m_sel & self.m_valid):\\n', '            m.d.comb += a_pc4.eq(m_pc4_a)\\n', '        with m.Elif(self.x_fence_i & self.x_valid):\\n', '            m.d.comb += a_pc4.eq(self.d_pc[2:])\\n', '        with m.Elif(self.d_branch_predict_taken & self.d_valid):\\n', '            m.d.comb += a_pc4.eq(self.d_branch_target[2:]),\\n', '        with m.Else():\\n', '            m.d.comb += a_pc4.eq(self.f_pc[2:] + 1)\\n', '\\n', '        m.d.comb += self.a_pc[2:].eq(a_pc4)\\n', '\\n', '        return m\\n', '\\n', '\\n', 'class FetchUnitInterface:\\n', '    def __init__(self):\\n', '        self.ibus = Record(wishbone_layout)\\n', '\\n', '        self.a_pc = Signal(32)\\n', '        self.a_stall = Signal()\\n', '        self.a_valid = Signal()\\n', '        self.f_stall = Signal()\\n', '        self.f_valid = Signal()\\n', '\\n', '        self.a_busy = Signal()\\n', '        self.f_busy = Signal()\\n', '        self.f_instruction = Signal(32)\\n', '        self.f_fetch_error = Signal()\\n', '        self.f_badaddr = Signal(30)\\n', '\\n', '\\n', 'class BareFetchUnit(FetchUnitInterface, Elaboratable):\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        ibus_rdata = Signal.like(self.ibus.dat_r)\\n', '        with m.If(self.ibus.cyc):\\n', '            with m.If(self.ibus.ack | self.ibus.err | ~self.f_valid):\\n', '                m.d.sync += [\\n', '                    self.ibus.cyc.eq(0),\\n', '                    self.ibus.stb.eq(0),\\n', '                    ibus_rdata.eq(self.ibus.dat_r)\\n', '                ]\\n', '        with m.Elif(self.a_valid & ~self.a_stall):\\n', '            m.d.sync += [\\n', '                self.ibus.adr.eq(self.a_pc[2:]),\\n', '                self.ibus.cyc.eq(1),\\n', '                self.ibus.stb.eq(1)\\n', '            ]\\n', '        m.d.comb += self.ibus.sel.eq(0b1111)\\n', '\\n', '        with m.If(self.ibus.cyc & self.ibus.err):\\n', '            m.d.sync += [\\n', '                self.f_fetch_error.eq(1),\\n', '                self.f_badaddr.eq(self.ibus.adr)\\n', '            ]\\n', '        with m.Elif(~self.f_stall):\\n', '            m.d.sync += self.f_fetch_error.eq(0)\\n', '\\n', '        m.d.comb += self.a_busy.eq(self.ibus.cyc)\\n', '\\n', '        with m.If(self.f_fetch_error):\\n', '            m.d.comb += [\\n', '                self.f_busy.eq(0),\\n', '                self.f_instruction.eq(0x00000013), # nop (addi x0, x0, 0)\\n', '            ]\\n', '        with m.Else():\\n', '            m.d.comb += [\\n', '                self.f_busy.eq(self.ibus.cyc),\\n', '                self.f_instruction.eq(ibus_rdata)\\n', '            ]\\n', '\\n', '        return m\\n', '\\n', '\\n', 'class CachedFetchUnit(FetchUnitInterface, Elaboratable):\\n', '    def __init__(self, *, icache_nways, icache_nlines, icache_nwords, icache_base, icache_limit):\\n', '        super().__init__()\\n', '\\n', '        self._icache = L1Cache(\\n', '            nways  = icache_nways,\\n', '            nlines = icache_nlines,\\n', '            nwords = icache_nwords,\\n', '            base   = icache_base,\\n', '            limit  = icache_limit\\n', '        )\\n', '\\n', '        self.f_pc = Signal(32)\\n', '        self.a_flush = Signal()\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        m.submodules.icache = self._icache\\n', '\\n', '        a_icache_select = Signal()\\n', '\\n', '        # Test whether the target address is inside the L1 cache region. We use a bit mask in order\\n', '        # to avoid carry chains from arithmetic comparisons. To this end, the base and limit\\n', '        # addresses of the cached region must satisfy the following constraints:\\n', '        # 1) the region size (i.e. ``limit - base``) must be a power of 2\\n', '        # 2) ``base`` must be a multiple of the region size\\n', '\\n', '        def addr_between(base, limit):\\n', '            assert base  in range(0, 2**30 + 1)\\n', '            assert limit in range(0, 2**30 + 1)\\n', '            assert limit >= base\\n', '            assert base % (limit - base) == 0\\n', '            addr_width = log2_int(limit - base, need_pow2=True)\\n', '            const_bits = 30 - addr_width\\n', '            if const_bits > 0:\\n', '                const_pat = \"{:0{}b}\".format(base >> addr_width, const_bits)\\n', '            else:\\n', '                const_pat = \"\"\\n', '            return \"{}{}\".format(const_pat, \"-\" * addr_width)\\n', '\\n', '        icache_pattern = addr_between(self._icache.base >> 2, self._icache.limit >> 2)\\n', '        with m.If(self.a_pc[2:].matches(icache_pattern)):\\n', '            m.d.comb += a_icache_select.eq(1)\\n', '\\n', '        f_icache_select = Signal()\\n', '        f_flush = Signal()\\n', '\\n', '        with m.If(~self.a_stall):\\n', '            m.d.sync += [\\n', '                f_icache_select.eq(a_icache_select),\\n', '                f_flush.eq(self.a_flush),\\n', '            ]\\n', '\\n', '        m.d.comb += [\\n', '            self._icache.s1_addr .eq(self.a_pc[2:]),\\n', '            self._icache.s1_stall.eq(self.a_stall),\\n', '            self._icache.s1_valid.eq(self.a_valid),\\n', '            self._icache.s2_addr .eq(self.f_pc[2:]),\\n', '            self._icache.s2_re   .eq(f_icache_select),\\n', '            self._icache.s2_evict.eq(Const(0)),\\n', '            self._icache.s2_flush.eq(f_flush),\\n', '            self._icache.s2_valid.eq(self.f_valid),\\n', '        ]\\n', '\\n', '        ibus_arbiter = m.submodules.ibus_arbiter = WishboneArbiter()\\n', '        m.d.comb += ibus_arbiter.bus.connect(self.ibus)\\n', '\\n', '        icache_port = ibus_arbiter.port(priority=0)\\n', '        m.d.comb += [\\n', '            icache_port.cyc.eq(self._icache.bus_re),\\n', '            icache_port.stb.eq(self._icache.bus_re),\\n', '            icache_port.adr.eq(self._icache.bus_addr),\\n', '            icache_port.sel.eq(0b1111),\\n', '            icache_port.cti.eq(Mux(self._icache.bus_last, Cycle.END, Cycle.INCREMENT)),\\n', '            icache_port.bte.eq(Const(log2_int(self._icache.nwords) - 1)),\\n', '            self._icache.bus_valid.eq(icache_port.ack),\\n', '            self._icache.bus_error.eq(icache_port.err),\\n', '            self._icache.bus_rdata.eq(icache_port.dat_r)\\n', '        ]\\n', '\\n', '        bare_port = ibus_arbiter.port(priority=1)\\n', '        bare_rdata = Signal.like(bare_port.dat_r)\\n', '        with m.If(bare_port.cyc):\\n', '            with m.If(bare_port.ack | bare_port.err | ~self.f_valid):\\n', '                m.d.sync += [\\n', '                    bare_port.cyc.eq(0),\\n', '                    bare_port.stb.eq(0),\\n', '                    bare_rdata.eq(bare_port.dat_r)\\n', '                ]\\n', '        with m.Elif(~a_icache_select & self.a_valid & ~self.a_stall):\\n', '            m.d.sync += [\\n', '                bare_port.cyc.eq(1),\\n', '                bare_port.stb.eq(1),\\n', '                bare_port.adr.eq(self.a_pc[2:])\\n', '            ]\\n', '        m.d.comb += bare_port.sel.eq(0b1111)\\n', '\\n', '        m.d.comb += self.a_busy.eq(bare_port.cyc)\\n', '\\n', '        with m.If(self.ibus.cyc & self.ibus.err):\\n', '            m.d.sync += [\\n', '                self.f_fetch_error.eq(1),\\n', '                self.f_badaddr.eq(self.ibus.adr)\\n', '            ]\\n', '        with m.Elif(~self.f_stall):\\n', '            m.d.sync += self.f_fetch_error.eq(0)\\n', '\\n', '        with m.If(f_flush):\\n', '            m.d.comb += self.f_busy.eq(f_icache_select & ~self._icache.s2_flush_ack)\\n', '        with m.Elif(self.f_fetch_error):\\n', '            m.d.comb += self.f_busy.eq(0)\\n', '        with m.Elif(f_icache_select):\\n', '            m.d.comb += self.f_busy.eq(self._icache.s2_miss)\\n', '        with m.Else():\\n', '            m.d.comb += self.f_busy.eq(bare_port.cyc)\\n', '\\n', '        with m.If(self.f_fetch_error):\\n', '            m.d.comb += self.f_instruction.eq(0x00000013) # nop (addi x0, x0, 0)\\n', '        with m.Elif(f_icache_select):\\n', '            m.d.comb += self.f_instruction.eq(self._icache.s2_rdata)\\n', '        with m.Else():\\n', '            m.d.comb += self.f_instruction.eq(bare_rdata)\\n', '\\n', '        return m\\n']"}
{"text": "['from amaranth import *\\n', '\\n', 'from .mem import ForwardingMemory\\n', '\\n', '\\n', '__all__ = [\"File\"]\\n', '\\n', '\\n', 'class File(Elaboratable):\\n', '    def __init__(self, *, width, depth, init=None, name=None, attrs=None):\\n', '        self._mem  = ForwardingMemory(width=width, depth=depth, init=init, name=name, attrs=attrs)\\n', '        self.rp1   = self._mem.read_port()\\n', '        self.rp2   = self._mem.read_port()\\n', '        self.wp    = self._mem.write_port()\\n', '\\n', '        self.width = self._mem.width\\n', '        self.depth = self._mem.depth\\n', '        self.attrs = self._mem.attrs\\n', '        self.init  = self._mem.init\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '        m.submodules.mem = self._mem\\n', '        return m\\n']"}
{"text": "['from .csr import *\\n', '\\n', '\\n', 'class Opcode:\\n', '    LUI       = 0b01101\\n', '    AUIPC     = 0b00101\\n', '    JAL       = 0b11011\\n', '    JALR      = 0b11001\\n', '    BRANCH    = 0b11000\\n', '    LOAD      = 0b00000\\n', '    STORE     = 0b01000\\n', '    OP_IMM_32 = 0b00100\\n', '    OP_32     = 0b01100\\n', '    MISC_MEM  = 0b00011\\n', '    SYSTEM    = 0b11100\\n', '\\n', '\\n', 'class Funct3:\\n', '    BEQ  = B  = ADD  = FENCE  = PRIV   = MUL    = 0b000\\n', '    BNE  = H  = SLL  = FENCEI = CSRRW  = MULH   = 0b001\\n', '    _    = W  = SLT  = _      = CSRRS  = MULHSU = 0b010\\n', '    _    = _  = SLTU = _      = CSRRC  = MULHU  = 0b011\\n', '    BLT  = BU = XOR  = _      = _      = DIV    = 0b100\\n', '    BGE  = HU = SR   = _      = CSRRWI = DIVU   = 0b101\\n', '    BLTU = _  = OR   = _      = CSRRSI = REM    = 0b110\\n', '    BGEU = _  = AND  = _      = CSRRCI = REMU   = 0b111\\n', '\\n', '\\n', 'class Funct7:\\n', '    SRL = ADD = 0b0000000\\n', '    MULDIV    = 0b0000001\\n', '    SRA = SUB = 0b0100000\\n', '\\n', '\\n', 'class Funct12:\\n', '    ECALL  = 0b000000000000\\n', '    EBREAK = 0b000000000001\\n', '    MRET   = 0b001100000010\\n', '    WFI    = 0b000100000101\\n', '\\n', '\\n', 'class CSRIndex:\\n', '    MVENDORID   = 0xF11\\n', '    MARCHID     = 0xF12\\n', '    MIMPID      = 0xF13\\n', '    MHARTID     = 0xF14\\n', '    MSTATUS     = 0x300\\n', '    MISA        = 0x301\\n', '    MEDELEG     = 0x302\\n', '    MIDELEG     = 0x303\\n', '    MIE         = 0x304\\n', '    MTVEC       = 0x305\\n', '    MCOUTEREN   = 0x306\\n', '    MSCRATCH    = 0x340\\n', '    MEPC        = 0x341\\n', '    MCAUSE      = 0x342\\n', '    MTVAL       = 0x343\\n', '    MIP         = 0x344\\n', '    # \u00c2\u00b5arch specific\\n', '    IRQ_MASK    = 0x330\\n', '    IRQ_PENDING = 0x360\\n', '    # trigger module\\n', '    TSELECT     = 0x7a0\\n', '    TDATA1      = 0x7a1\\n', '    TDATA2      = 0x7a2\\n', '    TDATA3      = 0x7a3\\n', '    TINFO       = 0x7a4\\n', '    MCONTEXT    = 0x7a8\\n', '    # debug module\\n', '    DCSR        = 0x7b0\\n', '    DPC         = 0x7b1\\n', '\\n', '\\n', 'class Cause:\\n', '    FETCH_MISALIGNED     = 0\\n', '    FETCH_ACCESS_FAULT   = 1\\n', '    ILLEGAL_INSTRUCTION  = 2\\n', '    BREAKPOINT           = 3\\n', '    LOAD_MISALIGNED      = 4\\n', '    LOAD_ACCESS_FAULT    = 5\\n', '    STORE_MISALIGNED     = 6\\n', '    STORE_ACCESS_FAULT   = 7\\n', '    ECALL_FROM_U         = 8\\n', '    ECALL_FROM_S         = 9\\n', '    ECALL_FROM_M         = 11\\n', '    FETCH_PAGE_FAULT     = 12\\n', '    LOAD_PAGE_FAULT      = 13\\n', '    STORE_PAGE_FAULT     = 15\\n', '    # interrupts\\n', '    U_SOFTWARE_INTERRUPT = 0\\n', '    S_SOFTWARE_INTERRUPT = 1\\n', '    M_SOFTWARE_INTERRUPT = 3\\n', '    U_TIMER_INTERRUPT    = 4\\n', '    S_TIMER_INTERRUPT    = 5\\n', '    M_TIMER_INTERRUPT    = 7\\n', '    U_EXTERNAL_INTERRUPT = 8\\n', '    S_EXTERNAL_INTERRUPT = 9\\n', '    M_EXTERNAL_INTERRUPT = 11\\n', '\\n', '\\n', '# CSR layouts\\n', '\\n', 'flat_layout = [\\n', '    (\"value\", 32, CSRAccess.RW),\\n', ']\\n', '\\n', '\\n', 'misa_layout = [\\n', '    (\"extensions\", 26, CSRAccess.RW),\\n', '    (\"zero\",        4, CSRAccess.RO),\\n', '    (\"mxl\",         2, CSRAccess.RW),\\n', ']\\n', '\\n', '\\n', 'mstatus_layout = [\\n', '    (\"uie\",   1, CSRAccess.RO), # User Interrupt Enable\\n', '    (\"sie\",   1, CSRAccess.RO), # Supervisor Interrupt Enable\\n', '    (\"zero0\", 1, CSRAccess.RO),\\n', '    (\"mie\",   1, CSRAccess.RW), # Machine Interrupt Enable\\n', '    (\"upie\",  1, CSRAccess.RO), # User Previous Interrupt Enable\\n', '    (\"spie\",  1, CSRAccess.RO), # Supervisor Previous Interrupt Enable\\n', '    (\"zero1\", 1, CSRAccess.RO),\\n', '    (\"mpie\",  1, CSRAccess.RW), # Machine Previous Interrupt Enable\\n', '    (\"spp\",   1, CSRAccess.RO), # Supervisor Previous Privilege\\n', '    (\"zero2\", 2, CSRAccess.RO),\\n', '    (\"mpp\",   2, CSRAccess.RW), # Machine Previous Privilege\\n', '    (\"fs\",    2, CSRAccess.RO), # FPU Status\\n', '    (\"xs\",    2, CSRAccess.RO), # user-mode eXtensions Status\\n', '    (\"mprv\",  1, CSRAccess.RO), # Modify PRiVilege\\n', '    (\"sum\",   1, CSRAccess.RO), # Supervisor User Memory access\\n', '    (\"mxr\",   1, CSRAccess.RO), # Make eXecutable Readable\\n', '    (\"tvm\",   1, CSRAccess.RO), # Trap Virtual Memory\\n', '    (\"tw\",    1, CSRAccess.RO), # Timeout Wait\\n', '    (\"tsr\",   1, CSRAccess.RO), # Trap SRET\\n', '    (\"zero3\", 8, CSRAccess.RO),\\n', '    (\"sd\",    1, CSRAccess.RO), # State Dirty (set if XS or FS are set to dirty)\\n', ']\\n', '\\n', '\\n', 'mtvec_layout = [\\n', '    (\"mode\",  2, CSRAccess.RW),\\n', '    (\"base\", 30, CSRAccess.RW),\\n', ']\\n', '\\n', '\\n', 'mepc_layout = [\\n', '    (\"zero\",  2, CSRAccess.RO), # 16-bit instructions are not supported\\n', '    (\"base\", 30, CSRAccess.RW),\\n', ']\\n', '\\n', '\\n', 'mip_layout = [\\n', '    (\"usip\",   1, CSRAccess.RO),\\n', '    (\"ssip\",   1, CSRAccess.RO),\\n', '    (\"zero0\",  1, CSRAccess.RO),\\n', '    (\"msip\",   1, CSRAccess.RW),\\n', '    (\"utip\",   1, CSRAccess.RO),\\n', '    (\"stip\",   1, CSRAccess.RO),\\n', '    (\"zero1\",  1, CSRAccess.RO),\\n', '    (\"mtip\",   1, CSRAccess.RW),\\n', '    (\"ueip\",   1, CSRAccess.RO),\\n', '    (\"seip\",   1, CSRAccess.RO),\\n', '    (\"zero2\",  1, CSRAccess.RO),\\n', '    (\"meip\",   1, CSRAccess.RW),\\n', '    (\"zero3\", 20, CSRAccess.RO),\\n', ']\\n', '\\n', '\\n', 'mie_layout = [\\n', '    (\"usie\",   1, CSRAccess.RO),\\n', '    (\"ssie\",   1, CSRAccess.RO),\\n', '    (\"zero0\",  1, CSRAccess.RO),\\n', '    (\"msie\",   1, CSRAccess.RW),\\n', '    (\"utie\",   1, CSRAccess.RO),\\n', '    (\"stie\",   1, CSRAccess.RO),\\n', '    (\"zero1\",  1, CSRAccess.RO),\\n', '    (\"mtie\",   1, CSRAccess.RW),\\n', '    (\"ueie\",   1, CSRAccess.RO),\\n', '    (\"seie\",   1, CSRAccess.RO),\\n', '    (\"zero2\",  1, CSRAccess.RO),\\n', '    (\"meie\",   1, CSRAccess.RW),\\n', '    (\"zero3\", 20, CSRAccess.RO),\\n', ']\\n', '\\n', '\\n', 'mcause_layout = [\\n', '    (\"ecode\",    31, CSRAccess.RW),\\n', '    (\"interrupt\", 1, CSRAccess.RW),\\n', ']\\n', '\\n', '\\n', 'dcsr_layout = [\\n', '    (\"prv\",        2, CSRAccess.RW), # Privilege level before Debug Mode was entered\\n', '    (\"step\",       1, CSRAccess.RW), # Execute a single instruction and re-enter Debug Mode\\n', '    (\"nmip\",       1, CSRAccess.RO), # A non-maskable interrupt is pending\\n', '    (\"mprven\",     1, CSRAccess.RW), # Use mstatus.mprv in Debug Mode\\n', '    (\"zero0\",      1, CSRAccess.RO),\\n', '    (\"cause\",      3, CSRAccess.RO), # Explains why Debug Mode was entered\\n', '    (\"stoptime\",   1, CSRAccess.RW), # Stop timer increment during Debug Mode\\n', '    (\"stopcount\",  1, CSRAccess.RW), # Stop counter increment during Debug Mode\\n', '    (\"stepie\",     1, CSRAccess.RW), # Enable interrupts during single stepping\\n', '    (\"ebreaku\",    1, CSRAccess.RW), # EBREAKs in U-mode enter Debug Mode\\n', '    (\"ebreaks\",    1, CSRAccess.RW), # EBREAKs in S-mode enter Debug Mode\\n', '    (\"zero1\",      1, CSRAccess.RO),\\n', '    (\"ebreakm\",    1, CSRAccess.RW), # EBREAKs in M-mode enter Debug Mode\\n', '    (\"zero2\",     12, CSRAccess.RO),\\n', '    (\"xdebugver\",  4, CSRAccess.RO), # External Debug specification version\\n', ']\\n', '\\n', '\\n', 'tdata1_layout = [\\n', '    (\"data\",  27, CSRAccess.RW),\\n', '    (\"dmode\",  1, CSRAccess.RW),\\n', '    (\"type\",   4, CSRAccess.RW),\\n', ']\\n']"}
{"text": "['from amaranth import *\\n', 'from amaranth.utils import log2_int\\n', 'from amaranth.lib.fifo import SyncFIFOBuffered\\n', '\\n', 'from ..cache import *\\n', 'from ..isa import Funct3\\n', 'from ..wishbone import *\\n', '\\n', '\\n', '__all__ = [\"DataSelector\", \"LoadStoreUnitInterface\", \"BareLoadStoreUnit\", \"CachedLoadStoreUnit\"]\\n', '\\n', '\\n', 'class DataSelector(Elaboratable):\\n', '    def __init__(self):\\n', '        self.x_offset = Signal(2)\\n', '        self.x_funct3 = Signal(3)\\n', '        self.x_store_operand = Signal(32)\\n', '        self.w_offset = Signal(2)\\n', '        self.w_funct3 = Signal(3)\\n', '        self.w_load_data = Signal(32)\\n', '\\n', '        self.x_misaligned = Signal()\\n', '        self.x_mask = Signal(4)\\n', '        self.x_store_data = Signal(32)\\n', '        self.w_load_result = Signal(signed(32))\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        with m.Switch(self.x_funct3):\\n', '            with m.Case(Funct3.H, Funct3.HU):\\n', '                m.d.comb += self.x_misaligned.eq(self.x_offset[0])\\n', '            with m.Case(Funct3.W):\\n', '                m.d.comb += self.x_misaligned.eq(self.x_offset.bool())\\n', '\\n', '        with m.Switch(self.x_funct3):\\n', '            with m.Case(Funct3.B, Funct3.BU):\\n', '                m.d.comb += self.x_mask.eq(0b1 << self.x_offset)\\n', '            with m.Case(Funct3.H, Funct3.HU):\\n', '                m.d.comb += self.x_mask.eq(0b11 << self.x_offset)\\n', '            with m.Case(Funct3.W):\\n', '                m.d.comb += self.x_mask.eq(0b1111)\\n', '\\n', '        with m.Switch(self.x_funct3):\\n', '            with m.Case(Funct3.B):\\n', '                m.d.comb += self.x_store_data.eq(self.x_store_operand[:8] << self.x_offset*8)\\n', '            with m.Case(Funct3.H):\\n', '                m.d.comb += self.x_store_data.eq(self.x_store_operand[:16] << self.x_offset[1]*16)\\n', '            with m.Case(Funct3.W):\\n', '                m.d.comb += self.x_store_data.eq(self.x_store_operand)\\n', '\\n', '        w_byte = Signal(signed(8))\\n', '        w_half = Signal(signed(16))\\n', '\\n', '        m.d.comb += [\\n', '            w_byte.eq(self.w_load_data.word_select(self.w_offset, 8)),\\n', '            w_half.eq(self.w_load_data.word_select(self.w_offset[1], 16))\\n', '        ]\\n', '\\n', '        with m.Switch(self.w_funct3):\\n', '            with m.Case(Funct3.B):\\n', '                m.d.comb += self.w_load_result.eq(w_byte)\\n', '            with m.Case(Funct3.BU):\\n', '                m.d.comb += self.w_load_result.eq(Cat(w_byte, 0))\\n', '            with m.Case(Funct3.H):\\n', '                m.d.comb += self.w_load_result.eq(w_half)\\n', '            with m.Case(Funct3.HU):\\n', '                m.d.comb += self.w_load_result.eq(Cat(w_half, 0))\\n', '            with m.Case(Funct3.W):\\n', '                m.d.comb += self.w_load_result.eq(self.w_load_data)\\n', '\\n', '        return m\\n', '\\n', '\\n', 'class LoadStoreUnitInterface:\\n', '    def __init__(self):\\n', '        self.dbus = Record(wishbone_layout)\\n', '\\n', '        self.x_addr = Signal(32)\\n', '        self.x_mask = Signal(4)\\n', '        self.x_load = Signal()\\n', '        self.x_store = Signal()\\n', '        self.x_store_data = Signal(32)\\n', '        self.x_stall = Signal()\\n', '        self.x_valid = Signal()\\n', '        self.m_stall = Signal()\\n', '        self.m_valid = Signal()\\n', '\\n', '        self.x_busy = Signal()\\n', '        self.m_busy = Signal()\\n', '        self.m_load_data = Signal(32)\\n', '        self.m_load_error = Signal()\\n', '        self.m_store_error = Signal()\\n', '        self.m_badaddr = Signal(30)\\n', '\\n', '\\n', 'class BareLoadStoreUnit(LoadStoreUnitInterface, Elaboratable):\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        with m.If(self.dbus.cyc):\\n', '            with m.If(self.dbus.ack | self.dbus.err | ~self.m_valid):\\n', '                m.d.sync += [\\n', '                    self.dbus.cyc.eq(0),\\n', '                    self.dbus.stb.eq(0),\\n', '                    self.m_load_data.eq(self.dbus.dat_r)\\n', '                ]\\n', '        with m.Elif((self.x_load | self.x_store) & self.x_valid & ~self.x_stall):\\n', '            m.d.sync += [\\n', '                self.dbus.cyc.eq(1),\\n', '                self.dbus.stb.eq(1),\\n', '                self.dbus.adr.eq(self.x_addr[2:]),\\n', '                self.dbus.sel.eq(self.x_mask),\\n', '                self.dbus.we.eq(self.x_store),\\n', '                self.dbus.dat_w.eq(self.x_store_data)\\n', '            ]\\n', '\\n', '        with m.If(self.dbus.cyc & self.dbus.err):\\n', '            m.d.sync += [\\n', '                self.m_load_error.eq(~self.dbus.we),\\n', '                self.m_store_error.eq(self.dbus.we),\\n', '                self.m_badaddr.eq(self.dbus.adr)\\n', '            ]\\n', '        with m.Elif(~self.m_stall):\\n', '            m.d.sync += [\\n', '                self.m_load_error.eq(0),\\n', '                self.m_store_error.eq(0)\\n', '            ]\\n', '\\n', '        m.d.comb += self.x_busy.eq(self.dbus.cyc)\\n', '\\n', '        with m.If(self.m_load_error | self.m_store_error):\\n', '            m.d.comb += self.m_busy.eq(0)\\n', '        with m.Else():\\n', '            m.d.comb += self.m_busy.eq(self.dbus.cyc)\\n', '\\n', '        return m\\n', '\\n', '\\n', 'class WriteBuffer(Elaboratable):\\n', '    def __init__(self, *, depth, addr_width, data_width, granularity):\\n', '        self.w = Record([\\n', '            (\"en\",  1),\\n', '            (\"rdy\", 1),\\n', '            (\"op\", [\\n', '                (\"addr\", addr_width),\\n', '                (\"mask\", data_width // granularity),\\n', '                (\"data\", data_width),\\n', '            ])\\n', '        ])\\n', '        self.r = Record.like(self.w)\\n', '\\n', '        self._fifo = SyncFIFOBuffered(width=len(self.w.op), depth=depth)\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        m.submodules.fifo = self._fifo\\n', '        m.d.comb += [\\n', '            self.w.rdy.eq(self._fifo.w_rdy),\\n', '            self._fifo.w_en  .eq(self.w.en),\\n', '            self._fifo.w_data.eq(self.w.op),\\n', '\\n', '            self._fifo.r_en.eq(self.r.en),\\n', '            self.r.rdy.eq(self._fifo.r_rdy),\\n', '            self.r.op .eq(self._fifo.r_data),\\n', '        ]\\n', '\\n', '        return m\\n', '\\n', '\\n', 'class CachedLoadStoreUnit(LoadStoreUnitInterface, Elaboratable):\\n', '    def __init__(self, *,\\n', '            dcache_nways, dcache_nlines, dcache_nwords, dcache_base, dcache_limit,\\n', '            wrbuf_depth):\\n', '        super().__init__()\\n', '\\n', '        self._dcache = L1Cache(\\n', '            nways  = dcache_nways,\\n', '            nlines = dcache_nlines,\\n', '            nwords = dcache_nwords,\\n', '            base   = dcache_base,\\n', '            limit  = dcache_limit\\n', '        )\\n', '        self._wrbuf  = WriteBuffer(\\n', '            depth       = wrbuf_depth,\\n', '            addr_width  = 30,\\n', '            data_width  = 32,\\n', '            granularity = 8,\\n', '        )\\n', '\\n', '        self.x_fence_i = Signal()\\n', '        self.m_load = Signal()\\n', '        self.m_store = Signal()\\n', '        self.m_flush = Signal()\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        m.submodules.dcache = self._dcache\\n', '\\n', '        x_dcache_select = Signal()\\n', '\\n', '        # Test whether the target address is inside the L1 cache region. We use a bit mask in order\\n', '        # to avoid carry chains from arithmetic comparisons. To this end, the base and limit\\n', '        # addresses of the cached region must satisfy the following constraints:\\n', '        # 1) the region size (i.e. ``limit - base``) must be a power of 2\\n', '        # 2) ``base`` must be a multiple of the region size\\n', '\\n', '        def addr_between(base, limit):\\n', '            assert base  in range(0, 2**30 + 1)\\n', '            assert limit in range(0, 2**30 + 1)\\n', '            assert limit >= base\\n', '            assert base % (limit - base) == 0\\n', '            addr_width = log2_int(limit - base, need_pow2=True)\\n', '            const_bits = 30 - addr_width\\n', '            if const_bits > 0:\\n', '                const_pat = \"{:0{}b}\".format(base >> addr_width, const_bits)\\n', '            else:\\n', '                const_pat = \"\"\\n', '            return \"{}{}\".format(const_pat, \"-\" * addr_width)\\n', '\\n', '        dcache_pattern = addr_between(self._dcache.base >> 2, self._dcache.limit >> 2)\\n', '        with m.If(self.x_addr[2:].matches(dcache_pattern)):\\n', '            m.d.comb += x_dcache_select.eq(1)\\n', '\\n', '        m_dcache_select = Signal()\\n', '        m_addr = Signal.like(self.x_addr)\\n', '\\n', '        with m.If(~self.x_stall):\\n', '            m.d.sync += [\\n', '                m_dcache_select.eq(x_dcache_select),\\n', '                m_addr.eq(self.x_addr),\\n', '            ]\\n', '\\n', '        m.d.comb += [\\n', '            self._dcache.s1_addr .eq(self.x_addr[2:]),\\n', '            self._dcache.s1_stall.eq(self.x_stall),\\n', '            self._dcache.s1_valid.eq(self.x_valid),\\n', '            self._dcache.s2_addr .eq(m_addr[2:]),\\n', '            self._dcache.s2_re   .eq(self.m_load  & m_dcache_select),\\n', '            self._dcache.s2_evict.eq(self.m_store & m_dcache_select),\\n', '            self._dcache.s2_flush.eq(self.m_flush),\\n', '            self._dcache.s2_valid.eq(self.m_valid),\\n', '        ]\\n', '\\n', '        m.submodules.wrbuf = self._wrbuf\\n', '        m.d.comb += [\\n', '            self._wrbuf.w.en     .eq(self.x_store & self.x_valid & x_dcache_select & ~self.x_stall),\\n', '            self._wrbuf.w.op.addr.eq(self.x_addr[2:]),\\n', '            self._wrbuf.w.op.mask.eq(self.x_mask),\\n', '            self._wrbuf.w.op.data.eq(self.x_store_data),\\n', '        ]\\n', '\\n', '        dbus_arbiter = m.submodules.dbus_arbiter = WishboneArbiter()\\n', '        m.d.comb += dbus_arbiter.bus.connect(self.dbus)\\n', '\\n', '        wrbuf_port = dbus_arbiter.port(priority=0)\\n', '        m.d.comb += [\\n', '            wrbuf_port.cyc.eq(self._wrbuf.r.rdy),\\n', '            wrbuf_port.we.eq(Const(1)),\\n', '        ]\\n', '        with m.If(wrbuf_port.stb):\\n', '            with m.If(wrbuf_port.ack | wrbuf_port.err):\\n', '                m.d.sync += wrbuf_port.stb.eq(0)\\n', '                m.d.comb += self._wrbuf.r.en.eq(1)\\n', '        with m.Elif(self._wrbuf.r.rdy):\\n', '            m.d.sync += [\\n', '                wrbuf_port.stb  .eq(1),\\n', '                wrbuf_port.adr  .eq(self._wrbuf.r.op.addr),\\n', '                wrbuf_port.sel  .eq(self._wrbuf.r.op.mask),\\n', '                wrbuf_port.dat_w.eq(self._wrbuf.r.op.data),\\n', '            ]\\n', '\\n', '        dcache_port = dbus_arbiter.port(priority=1)\\n', '        m.d.comb += [\\n', '            dcache_port.cyc.eq(self._dcache.bus_re),\\n', '            dcache_port.stb.eq(self._dcache.bus_re),\\n', '            dcache_port.adr.eq(self._dcache.bus_addr),\\n', '            dcache_port.sel.eq(0b1111),\\n', '            dcache_port.cti.eq(Mux(self._dcache.bus_last, Cycle.END, Cycle.INCREMENT)),\\n', '            dcache_port.bte.eq(Const(log2_int(self._dcache.nwords) - 1)),\\n', '            self._dcache.bus_valid.eq(dcache_port.ack),\\n', '            self._dcache.bus_error.eq(dcache_port.err),\\n', '            self._dcache.bus_rdata.eq(dcache_port.dat_r)\\n', '        ]\\n', '\\n', '        bare_port = dbus_arbiter.port(priority=2)\\n', '        bare_rdata = Signal.like(bare_port.dat_r)\\n', '        with m.If(bare_port.cyc):\\n', '            with m.If(bare_port.ack | bare_port.err | ~self.m_valid):\\n', '                m.d.sync += [\\n', '                    bare_port.cyc.eq(0),\\n', '                    bare_port.stb.eq(0),\\n', '                    bare_rdata.eq(bare_port.dat_r)\\n', '                ]\\n', '        with m.Elif((self.x_load | self.x_store) & ~x_dcache_select & self.x_valid & ~self.x_stall):\\n', '            m.d.sync += [\\n', '                bare_port.cyc.eq(1),\\n', '                bare_port.stb.eq(1),\\n', '                bare_port.adr.eq(self.x_addr[2:]),\\n', '                bare_port.sel.eq(self.x_mask),\\n', '                bare_port.we.eq(self.x_store),\\n', '                bare_port.dat_w.eq(self.x_store_data)\\n', '            ]\\n', '\\n', '        with m.If(self.dbus.cyc & self.dbus.err):\\n', '            m.d.sync += [\\n', '                self.m_load_error.eq(~self.dbus.we),\\n', '                self.m_store_error.eq(self.dbus.we),\\n', '                self.m_badaddr.eq(self.dbus.adr)\\n', '            ]\\n', '        with m.Elif(~self.m_stall):\\n', '            m.d.sync += [\\n', '                self.m_load_error.eq(0),\\n', '                self.m_store_error.eq(0)\\n', '            ]\\n', '\\n', '        with m.If(self.x_fence_i):\\n', '            m.d.comb += self.x_busy.eq(self._wrbuf.r.rdy)\\n', '        with m.Elif(x_dcache_select):\\n', '            m.d.comb += self.x_busy.eq(self.x_store & ~self._wrbuf.w.rdy)\\n', '        with m.Else():\\n', '            m.d.comb += self.x_busy.eq(bare_port.cyc)\\n', '\\n', '        with m.If(self.m_flush):\\n', '            m.d.comb += self.m_busy.eq(m_dcache_select & ~self._dcache.s2_flush_ack)\\n', '        with m.Elif(self.m_load_error | self.m_store_error):\\n', '            m.d.comb += self.m_busy.eq(0)\\n', '        with m.Elif(m_dcache_select):\\n', '            m.d.comb += self.m_busy.eq(self.m_load & self._dcache.s2_miss)\\n', '        with m.Else():\\n', '            m.d.comb += self.m_busy.eq(bare_port.cyc)\\n', '\\n', '        with m.If(self.m_load_error):\\n', '            m.d.comb += self.m_load_data.eq(0)\\n', '        with m.Elif(m_dcache_select):\\n', '            m.d.comb += self.m_load_data.eq(self._dcache.s2_rdata)\\n', '        with m.Else():\\n', '            m.d.comb += self.m_load_data.eq(bare_rdata)\\n', '\\n', '        return m\\n']"}
{"text": "['from amaranth import *\\n', '\\n', 'from ..isa import Funct3\\n', '\\n', '\\n', '__all__ = [\"LogicUnit\"]\\n', '\\n', '\\n', 'class LogicUnit(Elaboratable):\\n', '    def __init__(self):\\n', '        self.op = Signal(3)\\n', '        self.src1 = Signal(32)\\n', '        self.src2 = Signal(32)\\n', '\\n', '        self.result = Signal(32)\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        with m.Switch(self.op):\\n', '            with m.Case(Funct3.XOR):\\n', '                m.d.comb += self.result.eq(self.src1 ^ self.src2)\\n', '            with m.Case(Funct3.OR):\\n', '                m.d.comb += self.result.eq(self.src1 | self.src2)\\n', '            with m.Case(Funct3.AND):\\n', '                m.d.comb += self.result.eq(self.src1 & self.src2)\\n', '\\n', '        return m\\n']"}
{"text": "['from amaranth import *\\n', '\\n', '\\n', '__all__ = [\"ForwardingMemory\"]\\n', '\\n', '\\n', 'class ForwardingMemory(Elaboratable):\\n', '    \"\"\"\\n', '    A memory with conflict resolution circuitry and transparent (\"write-first\") ports.\\n', '\\n', '    Some BRAMs (such as those of Xilinx 7 Series FPGAs) are subject to undefined behaviour\\n', '    when a transparent port writes to an address that is being read by another port\\n', '    (cf. Xilinx UG473: \"Conflict Avoidance\", Table 1-4).\\n', '    To avoid this, this memory uses non-transparent ports internally. On an address collision,\\n', '    the write port data is forwarded to the read port.\\n', '    \"\"\"\\n', '    def __init__(self, width, depth, init=None, name=None, attrs=None):\\n', '        self._mem  = Memory(width=width, depth=depth, init=init, name=name, attrs=attrs)\\n', '        self._rp   = []\\n', '        self._wp   = None\\n', '\\n', '        self.width = self._mem.width\\n', '        self.depth = self._mem.depth\\n', '        self.attrs = self._mem.attrs\\n', '        self.init  = self._mem.init\\n', '\\n', '    def read_port(self, *, src_loc_at=0):\\n', '        if len(self._rp) >= 2:\\n', '            raise AttributeError(\"ForwardingMemory {!r} cannot have more than two read ports, \"\\n', '                                 \"and both {!r} and {!r} have already been requested.\"\\n', '                                 .format(self, self._rp[0][1], self._rp[1][1]))\\n', '\\n', '        mem_rp = self._mem.read_port(transparent=False)\\n', '        pub_rp = Record([\\n', '            (\"addr\", range(self.depth)),\\n', '            (\"data\", self.width),\\n', '        ], src_loc_at=1 + src_loc_at)\\n', '\\n', '        self._rp.append((mem_rp, pub_rp))\\n', '        return pub_rp\\n', '\\n', '    def write_port(self, *, granularity=None, src_loc_at=0):\\n', '        if self._wp is not None:\\n', '            raise AttributeError(\"ForwardingMemory {!r} cannot have more than one write port, \"\\n', '                                 \"and {!r} has already been requested.\"\\n', '                                 .format(self, self._wp[1]))\\n', '\\n', '        mem_wp = self._mem.write_port(granularity=granularity)\\n', '        pub_wp = Record([\\n', '            (\"addr\", range(self.depth)),\\n', '            (\"en\",   int(self.width // mem_wp.granularity)),\\n', '            (\"data\", self.width),\\n', '        ], src_loc_at=1 + src_loc_at)\\n', '\\n', '        self._wp = mem_wp, pub_wp\\n', '        return pub_wp\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        for i, (mem_rp, pub_rp) in enumerate(self._rp, start=1):\\n', '            m.submodules[f\"mem_rp{i}\"] = mem_rp\\n', '            m.d.comb += [\\n', '                mem_rp.addr.eq(pub_rp.addr),\\n', '                mem_rp.en  .eq(Const(1)),\\n', '            ]\\n', '\\n', '        if self._wp is not None:\\n', '            mem_wp, pub_wp = self._wp\\n', '\\n', '            m.submodules.mem_wp = mem_wp\\n', '            m.d.comb += [\\n', '                mem_wp.addr.eq(pub_wp.addr),\\n', '                mem_wp.en  .eq(pub_wp.en),\\n', '                mem_wp.data.eq(pub_wp.data),\\n', '            ]\\n', '\\n', '            collision   = Signal(len(self._rp))\\n', '            fwd_wp_en   = Signal.like(pub_wp.en)\\n', '            fwd_wp_data = Signal.like(pub_wp.data)\\n', '\\n', '            m.d.sync += [\\n', '                fwd_wp_en  .eq(pub_wp.en),\\n', '                fwd_wp_data.eq(pub_wp.data),\\n', '            ]\\n', '\\n', '            for i, (mem_rp, pub_rp) in enumerate(self._rp):\\n', '                m.d.sync += collision[i].eq(pub_wp.addr == pub_rp.addr)\\n', '\\n', '                for j, forward in enumerate(fwd_wp_en):\\n', '                    pub_rp_word = pub_rp.data.word_select(j, mem_wp.granularity)\\n', '                    fwd_wp_word = fwd_wp_data.word_select(j, mem_wp.granularity)\\n', '                    mem_rp_word = mem_rp.data.word_select(j, mem_wp.granularity)\\n', '\\n', '                    with m.If(collision[i] & forward):\\n', '                        m.d.comb += pub_rp_word.eq(fwd_wp_word)\\n', '                    with m.Else():\\n', '                        m.d.comb += pub_rp_word.eq(mem_rp_word)\\n', '\\n', '        return m\\n']"}
{"text": "['from amaranth import *\\n', '\\n', 'from ..isa import Funct3\\n', '\\n', '\\n', '__all__ = [\"MultiplierInterface\", \"Multiplier\", \"DummyMultiplier\"]\\n', '\\n', '\\n', 'class MultiplierInterface:\\n', '    def __init__(self):\\n', '        self.d_op     = Signal(3)\\n', '        self.d_stall  = Signal()\\n', '        self.x_src1   = Signal(32)\\n', '        self.x_src2   = Signal(32)\\n', '        self.x_stall  = Signal()\\n', '        self.m_stall  = Signal()\\n', '\\n', '        self.w_result = Signal(32)\\n', '\\n', '\\n', 'class Multiplier(MultiplierInterface, Elaboratable):\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        d_low = Signal()\\n', '        d_src1_signed = Signal()\\n', '        d_src2_signed = Signal()\\n', '\\n', '        m.d.comb += [\\n', '            d_low.eq(self.d_op == Funct3.MUL),\\n', '            d_src1_signed.eq((self.d_op == Funct3.MULH) | (self.d_op == Funct3.MULHSU)),\\n', '            d_src2_signed.eq(self.d_op == Funct3.MULH)\\n', '        ]\\n', '\\n', '        x_low = Signal()\\n', '        x_src1_signed = Signal()\\n', '        x_src2_signed = Signal()\\n', '\\n', '        with m.If(~self.d_stall):\\n', '            m.d.sync += [\\n', '                x_low.eq(d_low),\\n', '                x_src1_signed.eq(d_src1_signed),\\n', '                x_src2_signed.eq(d_src2_signed),\\n', '            ]\\n', '\\n', '        x_src1 = Signal(signed(33))\\n', '        x_src2 = Signal(signed(33))\\n', '        x_prod = Signal(signed(66))\\n', '\\n', '        m.d.comb += [\\n', '            x_src1.eq(Cat(self.x_src1, x_src1_signed & self.x_src1[31])),\\n', '            x_src2.eq(Cat(self.x_src2, x_src2_signed & self.x_src2[31])),\\n', '            x_prod.eq(x_src1 * x_src2),\\n', '        ]\\n', '\\n', '        m_low = Signal()\\n', '        m_prod = Signal(signed(66))\\n', '\\n', '        with m.If(~self.x_stall):\\n', '            m.d.sync += [\\n', '                m_low.eq(x_low),\\n', '                m_prod.eq(x_prod),\\n', '            ]\\n', '\\n', '        m_result = Signal(32)\\n', '\\n', '        with m.If(m_low):\\n', '            m.d.comb += m_result.eq(m_prod[:32])\\n', '        with m.Else():\\n', '            m.d.comb += m_result.eq(m_prod[32:])\\n', '\\n', '        with m.If(~self.m_stall):\\n', '            m.d.sync += self.w_result.eq(m_result)\\n', '\\n', '        return m\\n', '\\n', '\\n', 'class DummyMultiplier(MultiplierInterface, Elaboratable):\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        x_op = Signal.like(self.d_op)\\n', '\\n', '        with m.If(~self.x_stall):\\n', '            m.d.sync += x_op.eq(self.d_op)\\n', '\\n', '        x_result = Signal.like(self.w_result)\\n', '        m_result = Signal.like(self.w_result)\\n', '\\n', '        with m.Switch(x_op):\\n', '            # As per the RVFI specification (\u00c2\u00a7 \"Alternative Arithmetic Operations\").\\n', '            # https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/rvfi.md\\n', '            with m.Case(Funct3.MUL):\\n', '                m.d.comb += x_result.eq((self.x_src1 + self.x_src2) ^ C(0x5876063e))\\n', '            with m.Case(Funct3.MULH):\\n', '                m.d.comb += x_result.eq((self.x_src1 + self.x_src2) ^ C(0xf6583fb7))\\n', '            with m.Case(Funct3.MULHSU):\\n', '                m.d.comb += x_result.eq((self.x_src1 - self.x_src2) ^ C(0xecfbe137))\\n', '            with m.Case(Funct3.MULHU):\\n', '                m.d.comb += x_result.eq((self.x_src1 + self.x_src2) ^ C(0x949ce5e8))\\n', '\\n', '        with m.If(~self.x_stall):\\n', '            m.d.sync += m_result.eq(x_result)\\n', '        with m.If(~self.m_stall):\\n', '            m.d.sync += self.w_result.eq(m_result)\\n', '\\n', '        return m\\n']"}
{"text": "['from amaranth import *\\n', '\\n', '\\n', '__all__ = [\"BranchPredictor\"]\\n', '\\n', '\\n', 'class BranchPredictor(Elaboratable):\\n', '    def __init__(self):\\n', '        self.d_branch = Signal()\\n', '        self.d_jump = Signal()\\n', '        self.d_offset = Signal(signed(32))\\n', '        self.d_pc = Signal(32)\\n', '        self.d_rs1_re = Signal()\\n', '\\n', '        self.d_branch_taken = Signal()\\n', '        self.d_branch_target = Signal(32)\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        d_fetch_misaligned = Signal()\\n', '        m.d.comb += [\\n', '            d_fetch_misaligned.eq(self.d_pc[:2].bool() | self.d_offset[:2].bool()),\\n', '            self.d_branch_target.eq(self.d_pc + self.d_offset),\\n', '        ]\\n', '\\n', '        with m.If(d_fetch_misaligned):\\n', '            m.d.comb += self.d_branch_taken.eq(0)\\n', '        with m.Elif(self.d_branch):\\n', '            # Backward conditional branches are predicted as taken.\\n', '            # Forward conditional branches are predicted as not taken.\\n', '            m.d.comb += self.d_branch_taken.eq(self.d_offset[-1])\\n', '        with m.Else():\\n', '            # Direct jumps are predicted as taken.\\n', '            # Other branch types (ie. indirect jumps, exceptions) are not predicted.\\n', '            m.d.comb += self.d_branch_taken.eq(self.d_jump & ~self.d_rs1_re)\\n', '\\n', '        return m\\n']"}
{"text": "['from functools import reduce\\n', 'from operator import or_\\n', '\\n', 'from amaranth import *\\n', 'from amaranth.hdl.rec import *\\n', '\\n', 'from ..isa import *\\n', 'from ..wishbone import *\\n', '\\n', '\\n', '__all__ = [\"rvfi_layout\", \"RVFIController\"]\\n', '\\n', '# RISC-V Formal Interface\\n', '# https://github.com/SymbioticEDA/riscv-formal/blob/master/docs/rvfi.md\\n', '\\n', 'rvfi_layout = [\\n', '    (\"valid\",      1, DIR_FANOUT),\\n', '    (\"order\",     64, DIR_FANOUT),\\n', '    (\"insn\",      32, DIR_FANOUT),\\n', '    (\"trap\",       1, DIR_FANOUT),\\n', '    (\"halt\",       1, DIR_FANOUT),\\n', '    (\"intr\",       1, DIR_FANOUT),\\n', '    (\"mode\",       2, DIR_FANOUT),\\n', '    (\"ixl\",        2, DIR_FANOUT),\\n', '\\n', '    (\"rs1_addr\",   5, DIR_FANOUT),\\n', '    (\"rs2_addr\",   5, DIR_FANOUT),\\n', '    (\"rs1_rdata\", 32, DIR_FANOUT),\\n', '    (\"rs2_rdata\", 32, DIR_FANOUT),\\n', '    (\"rd_addr\",    5, DIR_FANOUT),\\n', '    (\"rd_wdata\",  32, DIR_FANOUT),\\n', '\\n', '    (\"pc_rdata\",  32, DIR_FANOUT),\\n', '    (\"pc_wdata\",  32, DIR_FANOUT),\\n', '\\n', '    (\"mem_addr\",  32, DIR_FANOUT),\\n', '    (\"mem_rmask\",  4, DIR_FANOUT),\\n', '    (\"mem_wmask\",  4, DIR_FANOUT),\\n', '    (\"mem_rdata\", 32, DIR_FANOUT),\\n', '    (\"mem_wdata\", 32, DIR_FANOUT)\\n', ']\\n', '\\n', '\\n', 'class RVFIController(Elaboratable):\\n', '    def __init__(self):\\n', '        self.rvfi               = Record(rvfi_layout)\\n', '\\n', '        self.d_insn             = Signal.like(self.rvfi.insn)\\n', '        self.d_rs1_addr         = Signal.like(self.rvfi.rs1_addr)\\n', '        self.d_rs2_addr         = Signal.like(self.rvfi.rs2_addr)\\n', '        self.d_rs1_rdata        = Signal.like(self.rvfi.rs1_rdata)\\n', '        self.d_rs2_rdata        = Signal.like(self.rvfi.rs2_rdata)\\n', '        self.d_stall            = Signal()\\n', '        self.x_mem_addr         = Signal.like(self.rvfi.mem_addr)\\n', '        self.x_mem_wmask        = Signal.like(self.rvfi.mem_wmask)\\n', '        self.x_mem_rmask        = Signal.like(self.rvfi.mem_rmask)\\n', '        self.x_mem_wdata        = Signal.like(self.rvfi.mem_wdata)\\n', '        self.x_stall            = Signal()\\n', '        self.m_mem_rdata        = Signal.like(self.rvfi.mem_rdata)\\n', '        self.m_fetch_misaligned = Signal()\\n', '        self.m_illegal_insn     = Signal()\\n', '        self.m_load_misaligned  = Signal()\\n', '        self.m_store_misaligned = Signal()\\n', '        self.m_exception        = Signal()\\n', '        self.m_mret             = Signal()\\n', '        self.m_branch_taken     = Signal()\\n', '        self.m_branch_target    = Signal(32)\\n', '        self.m_pc_rdata         = Signal.like(self.rvfi.pc_rdata)\\n', '        self.m_stall            = Signal()\\n', '        self.m_valid            = Signal()\\n', '        self.w_rd_addr          = Signal.like(self.rvfi.rd_addr)\\n', '        self.w_rd_wdata         = Signal.like(self.rvfi.rd_wdata)\\n', '\\n', '        self.mtvec_r_base       = Signal(30)\\n', '        self.mepc_r_value       = Signal(32)\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        # Instruction Metadata\\n', '\\n', '        with m.If(~self.m_stall):\\n', '            m.d.sync += self.rvfi.valid.eq(self.m_valid)\\n', '        with m.Elif(self.rvfi.valid):\\n', '            m.d.sync += self.rvfi.valid.eq(0)\\n', '\\n', '        with m.If(self.rvfi.valid):\\n', '            m.d.sync += self.rvfi.order.eq(self.rvfi.order + 1)\\n', '\\n', '        x_insn = Signal.like(self.rvfi.insn)\\n', '        m_insn = Signal.like(self.rvfi.insn)\\n', '\\n', '        with m.If(~self.d_stall):\\n', '            m.d.sync += x_insn.eq(self.d_insn)\\n', '        with m.If(~self.x_stall):\\n', '            m.d.sync += m_insn.eq(x_insn)\\n', '        with m.If(~self.m_stall):\\n', '            m.d.sync += self.rvfi.insn.eq(m_insn)\\n', '\\n', '        with m.If(~self.m_stall):\\n', '            m.d.sync += [\\n', '                self.rvfi.trap.eq(reduce(or_, (\\n', '                    self.m_fetch_misaligned,\\n', '                    self.m_illegal_insn,\\n', '                    self.m_load_misaligned,\\n', '                    self.m_store_misaligned\\n', '                ))),\\n', '                self.rvfi.intr.eq(self.m_pc_rdata == self.mtvec_r_base << 2)\\n', '            ]\\n', '\\n', '        m.d.comb += [\\n', '            self.rvfi.mode.eq(Const(3)), # M-mode\\n', '            self.rvfi.ixl.eq(Const(1)) # XLEN=32\\n', '        ]\\n', '\\n', '        # Integer Register Read/Write\\n', '\\n', '        x_rs1_addr  = Signal.like(self.rvfi.rs1_addr)\\n', '        x_rs2_addr  = Signal.like(self.rvfi.rs2_addr)\\n', '        x_rs1_rdata = Signal.like(self.rvfi.rs1_rdata)\\n', '        x_rs2_rdata = Signal.like(self.rvfi.rs2_rdata)\\n', '\\n', '        m_rs1_addr  = Signal.like(self.rvfi.rs1_addr)\\n', '        m_rs2_addr  = Signal.like(self.rvfi.rs2_addr)\\n', '        m_rs1_rdata = Signal.like(self.rvfi.rs1_rdata)\\n', '        m_rs2_rdata = Signal.like(self.rvfi.rs2_rdata)\\n', '\\n', '        with m.If(~self.d_stall):\\n', '            m.d.sync += [\\n', '                x_rs1_addr.eq(self.d_rs1_addr),\\n', '                x_rs2_addr.eq(self.d_rs2_addr),\\n', '                x_rs1_rdata.eq(self.d_rs1_rdata),\\n', '                x_rs2_rdata.eq(self.d_rs2_rdata)\\n', '            ]\\n', '        with m.If(~self.x_stall):\\n', '            m.d.sync += [\\n', '                m_rs1_addr.eq(x_rs1_addr),\\n', '                m_rs2_addr.eq(x_rs2_addr),\\n', '                m_rs1_rdata.eq(x_rs1_rdata),\\n', '                m_rs2_rdata.eq(x_rs2_rdata)\\n', '            ]\\n', '        with m.If(~self.m_stall):\\n', '            m.d.sync += [\\n', '                self.rvfi.rs1_addr.eq(m_rs1_addr),\\n', '                self.rvfi.rs2_addr.eq(m_rs2_addr),\\n', '                self.rvfi.rs1_rdata.eq(m_rs1_rdata),\\n', '                self.rvfi.rs2_rdata.eq(m_rs2_rdata)\\n', '            ]\\n', '\\n', '        m.d.comb += [\\n', '            self.rvfi.rd_addr.eq(self.w_rd_addr),\\n', '            self.rvfi.rd_wdata.eq(self.w_rd_wdata)\\n', '        ]\\n', '\\n', '        # Program Counter\\n', '\\n', '        m_pc_wdata = Signal.like(self.rvfi.pc_wdata)\\n', '\\n', '        with m.If(self.m_exception):\\n', '            m.d.comb += m_pc_wdata.eq(self.mtvec_r_base << 2)\\n', '        with m.Elif(self.m_mret):\\n', '            m.d.comb += m_pc_wdata.eq(self.mepc_r_value)\\n', '        with m.Elif(self.m_branch_taken):\\n', '            m.d.comb += m_pc_wdata.eq(self.m_branch_target)\\n', '        with m.Else():\\n', '            m.d.comb += m_pc_wdata.eq(self.m_pc_rdata + 4)\\n', '\\n', '        with m.If(~self.m_stall):\\n', '            m.d.sync += [\\n', '                self.rvfi.pc_rdata.eq(self.m_pc_rdata),\\n', '                self.rvfi.pc_wdata.eq(m_pc_wdata)\\n', '            ]\\n', '\\n', '        # Memory Access\\n', '\\n', '        m_mem_addr  = Signal.like(self.rvfi.mem_addr)\\n', '        m_mem_wmask = Signal.like(self.rvfi.mem_wmask)\\n', '        m_mem_rmask = Signal.like(self.rvfi.mem_rmask)\\n', '        m_mem_wdata = Signal.like(self.rvfi.mem_wdata)\\n', '\\n', '        with m.If(~self.x_stall):\\n', '            m.d.sync += [\\n', '                m_mem_addr.eq(self.x_mem_addr),\\n', '                m_mem_wmask.eq(self.x_mem_wmask),\\n', '                m_mem_rmask.eq(self.x_mem_rmask),\\n', '                m_mem_wdata.eq(self.x_mem_wdata)\\n', '            ]\\n', '        with m.If(~self.m_stall):\\n', '            m.d.sync += [\\n', '                self.rvfi.mem_addr.eq(m_mem_addr),\\n', '                self.rvfi.mem_wmask.eq(m_mem_wmask),\\n', '                self.rvfi.mem_rmask.eq(m_mem_rmask),\\n', '                self.rvfi.mem_wdata.eq(m_mem_wdata),\\n', '                self.rvfi.mem_rdata.eq(self.m_mem_rdata)\\n', '            ]\\n', '\\n', '        return m\\n']"}
{"text": "['from amaranth import *\\n', '\\n', '\\n', '__all__ = [\"Shifter\"]\\n', '\\n', '\\n', 'class Shifter(Elaboratable):\\n', '    def __init__(self):\\n', '        self.x_direction = Signal()\\n', '        self.x_sext = Signal()\\n', '        self.x_shamt = Signal(5)\\n', '        self.x_src1 = Signal(32)\\n', '        self.x_stall = Signal()\\n', '\\n', '        self.m_result = Signal(32)\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        x_operand = Signal(32)\\n', '        x_filler = Signal()\\n', '        m_direction = Signal()\\n', '        m_result = Signal(32)\\n', '\\n', '        m.d.comb += [\\n', '            # left shifts are equivalent to right shifts with reversed bits\\n', '            x_operand.eq(Mux(self.x_direction, self.x_src1, self.x_src1[::-1])),\\n', '            x_filler.eq(Mux(self.x_direction & self.x_sext, self.x_src1[-1], 0))\\n', '        ]\\n', '\\n', '        with m.If(~self.x_stall):\\n', '            m.d.sync += [\\n', '                m_direction.eq(self.x_direction),\\n', '                m_result.eq(Cat(x_operand, x_filler.replicate(32)) >> self.x_shamt)\\n', '            ]\\n', '\\n', '        m.d.comb += self.m_result.eq(Mux(m_direction, m_result, m_result[::-1]))\\n', '\\n', '        return m\\n']"}
{"text": "['from functools import reduce\\n', 'from operator import or_\\n', '\\n', 'from amaranth import *\\n', 'from amaranth.hdl.rec import *\\n', '\\n', '\\n', '__all__ = [\"Stage\"]\\n', '\\n', '\\n', 'def _force_fanout(layout):\\n', '    fields = []\\n', '    for name, shape, dir in Layout.cast(layout):\\n', '        if isinstance(shape, int):\\n', '            shape = Shape(shape)\\n', '        if isinstance(shape, Shape):\\n', '            fields.append((name, shape, DIR_FANOUT))\\n', '        else:\\n', '            fields.append((name, _force_fanout(shape)))\\n', '    return Layout(fields)\\n', '\\n', '\\n', 'class _EndpointDescription:\\n', '    def __init__(self, payload_layout):\\n', '        self.payload_layout = Layout.cast(payload_layout)\\n', '\\n', '    def get_full_layout(self):\\n', '        reserved = {\"valid\", \"stall\", \"kill\"}\\n', '        attributed = set()\\n', '        for name, shape, dir in self.payload_layout:\\n', '            if name in attributed:\\n', '                raise ValueError(name + \" already attributed in payload layout\")\\n', '            if name in reserved:\\n', '                raise ValueError(name + \" cannot be used in endpoint layout\")\\n', '            attributed.add(name)\\n', '\\n', '        full_layout = [\\n', '            (\"valid\",   1, DIR_FANOUT),\\n', '            (\"stall\",   1, DIR_FANIN),\\n', '            (\"kill\",    1, DIR_FANOUT),\\n', '            (\"payload\", _force_fanout(self.payload_layout))\\n', '        ]\\n', '        return Layout(full_layout)\\n', '\\n', '\\n', 'class _Endpoint(Record):\\n', '    def __init__(self, layout):\\n', '        self.description = _EndpointDescription(layout)\\n', '        super().__init__(self.description.get_full_layout())\\n', '\\n', '    def __getattr__(self, name):\\n', '        try:\\n', '            return super().__getattr__(name)\\n', '        except AttributeError:\\n', '            return self.fields[\"payload\"][name]\\n', '\\n', '\\n', 'class Stage(Elaboratable):\\n', '    def __init__(self, sink_layout, source_layout):\\n', '        self.kill = Signal()\\n', '        self.stall = Signal()\\n', '        self.valid = Signal()\\n', '\\n', '        if sink_layout is None and source_layout is None:\\n', '            raise ValueError\\n', '        if sink_layout is not None:\\n', '            self.sink = _Endpoint(sink_layout)\\n', '        if source_layout is not None:\\n', '            self.source = _Endpoint(source_layout)\\n', '\\n', '        self._kill_sources = []\\n', '        self._stall_sources = []\\n', '\\n', '    def kill_on(self, cond):\\n', '        self._kill_sources.append(cond)\\n', '\\n', '    def stall_on(self, cond):\\n', '        self._stall_sources.append(cond)\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        if hasattr(self, \"sink\"):\\n', '            m.d.comb += [\\n', '                self.valid.eq(self.sink.valid & ~self.sink.kill),\\n', '                self.sink.stall.eq(self.stall)\\n', '            ]\\n', '\\n', '        if hasattr(self, \"source\"):\\n', '            with m.If(~self.stall):\\n', '                m.d.sync += self.source.valid.eq(self.valid)\\n', '            with m.Elif(~self.source.stall | self.kill):\\n', '                m.d.sync += self.source.valid.eq(0)\\n', '            self.stall_on(self.source.stall)\\n', '            m.d.comb += [\\n', '                self.source.kill.eq(self.kill),\\n', '                self.kill.eq(reduce(or_, self._kill_sources, 0))\\n', '            ]\\n', '\\n', '        m.d.comb += self.stall.eq(reduce(or_, self._stall_sources, 0))\\n', '\\n', '        return m\\n']"}
{"text": "['from functools import reduce\\n', 'from operator import or_\\n', '\\n', 'from amaranth import *\\n', 'from amaranth.hdl.rec import *\\n', '\\n', 'from ..csr import *\\n', 'from ..isa import *\\n', '\\n', '\\n', '__all__ = [\"TriggerUnit\"]\\n', '\\n', '\\n', 'class Type:\\n', '    NOP        = 0\\n', '    LEGACY     = 1\\n', '    MATCH      = 2\\n', '    INSN_COUNT = 3\\n', '    INTERRUPT  = 4\\n', '    EXCEPTION  = 5\\n', '\\n', '\\n', 'mcontrol_layout = [\\n', '    (\"load\",    1),\\n', '    (\"store\",   1),\\n', '    (\"execute\", 1),\\n', '    (\"u\",       1),\\n', '    (\"s\",       1),\\n', '    (\"zero0\",   1),\\n', '    (\"m\",       1),\\n', '    (\"match\",   4),\\n', '    (\"chain\",   1),\\n', '    (\"action\",  4),\\n', '    (\"size\",    2),\\n', '    (\"timing\",  1),\\n', '    (\"select\",  1),\\n', '    (\"hit\",     1),\\n', '    (\"maskmax\", 6)\\n', ']\\n', '\\n', '\\n', 'class TriggerUnit(Elaboratable, AutoCSR):\\n', '    def __init__(self, nb_triggers):\\n', '        if not isinstance(nb_triggers, int):\\n', '            raise TypeError(\"Number of triggers must be an int, not {!r}\"\\n', '                            .format(nb_triggers))\\n', '        if nb_triggers == 0 or nb_triggers & nb_triggers - 1:\\n', '            raise ValueError(\"Number of triggers must be a power of 2, not {!r}\"\\n', '                             .format(nb_triggers))\\n', '        self.nb_triggers = nb_triggers\\n', '\\n', '        self.tselect = CSR(0x7a0, flat_layout)\\n', '        self.tdata1  = CSR(0x7a1, tdata1_layout)\\n', '        self.tdata2  = CSR(0x7a2, flat_layout)\\n', '\\n', '        self.x_pc = Signal(32)\\n', '        self.x_valid = Signal()\\n', '\\n', '        self.haltreq = Signal()\\n', '        self.x_trap = Signal()\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        triggers = [Record.like(self.tdata1.r) for _ in range(self.nb_triggers)]\\n', '        for t in triggers:\\n', '            # We only support address/data match triggers.\\n', '            m.d.comb += t.type.eq(Type.MATCH)\\n', '\\n', '        def do_trigger_update(trigger):\\n', '            m.d.sync += trigger.dmode.eq(self.tdata1.w.dmode)\\n', '            mcontrol = Record([(\"i\", mcontrol_layout), (\"o\", mcontrol_layout)])\\n', '            m.d.comb += [\\n', '                mcontrol.i.eq(self.tdata1.w.data),\\n', '                mcontrol.o.execute.eq(mcontrol.i.execute),\\n', '                mcontrol.o.m.eq(mcontrol.i.m),\\n', '                mcontrol.o.action.eq(mcontrol.i.action),\\n', '            ]\\n', '            m.d.sync += trigger.data.eq(mcontrol.o)\\n', '\\n', '        with m.Switch(self.tselect.r.value):\\n', '            for i, t in enumerate(triggers):\\n', '                with m.Case(i):\\n', '                    m.d.comb += self.tdata1.r.eq(t)\\n', '                    with m.If(self.tdata1.we):\\n', '                        do_trigger_update(t)\\n', '\\n', '        with m.If(self.tselect.we):\\n', '            with m.If(self.tselect.w.value & (self.nb_triggers - 1)):\\n', '                m.d.sync += self.tselect.r.value.eq(self.tselect.w.value)\\n', '\\n', '        with m.If(self.tdata2.we):\\n', '            m.d.sync += self.tdata2.r.eq(self.tdata2.w)\\n', '\\n', '        hit = Signal()\\n', '        halt = Signal()\\n', '\\n', '        with m.Switch(self.tdata1.r.type):\\n', '            with m.Case(Type.MATCH):\\n', '                mcontrol = Record(mcontrol_layout)\\n', '                m.d.comb += mcontrol.eq(self.tdata1.r.data)\\n', '\\n', '                match = Signal()\\n', '                with m.If(mcontrol.execute):\\n', '                    m.d.comb += match.eq(self.tdata2.r == self.x_pc & self.x_valid)\\n', '                m.d.comb += [\\n', '                    hit.eq(match & mcontrol.m),\\n', '                    halt.eq(mcontrol.action)\\n', '                ]\\n', '\\n', '        with m.If(hit):\\n', '            with m.If(halt):\\n', '                m.d.comb += self.haltreq.eq(self.tdata1.r.dmode)\\n', '            with m.Else():\\n', '                m.d.comb += self.x_trap.eq(1)\\n', '\\n', '        return m\\n']"}
{"text": "['from amaranth import *\\n', 'from amaranth.hdl.rec import *\\n', 'from amaranth.lib.coding import *\\n', '\\n', '\\n', '__all__ = [\"Cycle\", \"wishbone_layout\", \"WishboneArbiter\"]\\n', '\\n', '\\n', 'class Cycle:\\n', '    CLASSIC   = 0\\n', '    CONSTANT  = 1\\n', '    INCREMENT = 2\\n', '    END       = 7\\n', '\\n', '\\n', 'wishbone_layout = [\\n', '    (\"adr\",   30, DIR_FANOUT),\\n', '    (\"dat_w\", 32, DIR_FANOUT),\\n', '    (\"dat_r\", 32, DIR_FANIN),\\n', '    (\"sel\",    4, DIR_FANOUT),\\n', '    (\"cyc\",    1, DIR_FANOUT),\\n', '    (\"stb\",    1, DIR_FANOUT),\\n', '    (\"ack\",    1, DIR_FANIN),\\n', '    (\"we\",     1, DIR_FANOUT),\\n', '    (\"cti\",    3, DIR_FANOUT),\\n', '    (\"bte\",    2, DIR_FANOUT),\\n', '    (\"err\",    1, DIR_FANIN)\\n', ']\\n', '\\n', '\\n', 'class WishboneArbiter(Elaboratable):\\n', '    def __init__(self):\\n', '        self.bus = Record(wishbone_layout)\\n', '        self._port_map = dict()\\n', '\\n', '    def port(self, priority):\\n', '        if not isinstance(priority, int) or priority < 0:\\n', '            raise TypeError(\"Priority must be a non-negative integer, not \\'{!r}\\'\"\\n', '                            .format(priority))\\n', '        if priority in self._port_map:\\n', '            raise ValueError(\"Conflicting priority: \\'{!r}\\'\".format(priority))\\n', '        port = self._port_map[priority] = Record.like(self.bus)\\n', '        return port\\n', '\\n', '    def elaborate(self, platform):\\n', '        m = Module()\\n', '\\n', '        ports = [port for priority, port in sorted(self._port_map.items())]\\n', '\\n', '        for port in ports:\\n', '            m.d.comb += port.dat_r.eq(self.bus.dat_r)\\n', '\\n', '        bus_pe = m.submodules.bus_pe = PriorityEncoder(len(ports))\\n', '        with m.If(~self.bus.cyc):\\n', '            for j, port in enumerate(ports):\\n', '                m.d.sync += bus_pe.i[j].eq(port.cyc)\\n', '\\n', '        source = Array(ports)[bus_pe.o]\\n', '        m.d.comb += [\\n', '            self.bus.adr.eq(source.adr),\\n', '            self.bus.dat_w.eq(source.dat_w),\\n', '            self.bus.sel.eq(source.sel),\\n', '            self.bus.cyc.eq(source.cyc),\\n', '            self.bus.stb.eq(source.stb),\\n', '            self.bus.we.eq(source.we),\\n', '            self.bus.cti.eq(source.cti),\\n', '            self.bus.bte.eq(source.bte),\\n', '            source.ack.eq(self.bus.ack),\\n', '            source.err.eq(self.bus.err)\\n', '        ]\\n', '\\n', '        return m\\n']"}
