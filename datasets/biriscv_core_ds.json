{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', 'module biriscv_alu\\n', '(\\n', '    // Inputs\\n', '     input  [  3:0]  alu_op_i\\n', '    ,input  [ 31:0]  alu_a_i\\n', '    ,input  [ 31:0]  alu_b_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  alu_p_o\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Includes\\n', '//-----------------------------------------------------------------\\n', '`include \"biriscv_defs.v\"\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers\\n', '//-----------------------------------------------------------------\\n', 'reg [31:0]      result_r;\\n', '\\n', 'reg [31:16]     shift_right_fill_r;\\n', 'reg [31:0]      shift_right_1_r;\\n', 'reg [31:0]      shift_right_2_r;\\n', 'reg [31:0]      shift_right_4_r;\\n', 'reg [31:0]      shift_right_8_r;\\n', '\\n', 'reg [31:0]      shift_left_1_r;\\n', 'reg [31:0]      shift_left_2_r;\\n', 'reg [31:0]      shift_left_4_r;\\n', 'reg [31:0]      shift_left_8_r;\\n', '\\n', 'wire [31:0]     sub_res_w = alu_a_i - alu_b_i;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// ALU\\n', '//-----------------------------------------------------------------\\n', 'always @ (alu_op_i or alu_a_i or alu_b_i or sub_res_w)\\n', 'begin\\n', \"    shift_right_fill_r = 16'b0;\\n\", \"    shift_right_1_r = 32'b0;\\n\", \"    shift_right_2_r = 32'b0;\\n\", \"    shift_right_4_r = 32'b0;\\n\", \"    shift_right_8_r = 32'b0;\\n\", '\\n', \"    shift_left_1_r = 32'b0;\\n\", \"    shift_left_2_r = 32'b0;\\n\", \"    shift_left_4_r = 32'b0;\\n\", \"    shift_left_8_r = 32'b0;\\n\", '\\n', '    case (alu_op_i)\\n', '       //----------------------------------------------\\n', '       // Shift Left\\n', '       //----------------------------------------------   \\n', '       `ALU_SHIFTL :\\n', '       begin\\n', \"            if (alu_b_i[0] == 1'b1)\\n\", \"                shift_left_1_r = {alu_a_i[30:0],1'b0};\\n\", '            else\\n', '                shift_left_1_r = alu_a_i;\\n', '\\n', \"            if (alu_b_i[1] == 1'b1)\\n\", \"                shift_left_2_r = {shift_left_1_r[29:0],2'b00};\\n\", '            else\\n', '                shift_left_2_r = shift_left_1_r;\\n', '\\n', \"            if (alu_b_i[2] == 1'b1)\\n\", \"                shift_left_4_r = {shift_left_2_r[27:0],4'b0000};\\n\", '            else\\n', '                shift_left_4_r = shift_left_2_r;\\n', '\\n', \"            if (alu_b_i[3] == 1'b1)\\n\", \"                shift_left_8_r = {shift_left_4_r[23:0],8'b00000000};\\n\", '            else\\n', '                shift_left_8_r = shift_left_4_r;\\n', '\\n', \"            if (alu_b_i[4] == 1'b1)\\n\", \"                result_r = {shift_left_8_r[15:0],16'b0000000000000000};\\n\", '            else\\n', '                result_r = shift_left_8_r;\\n', '       end\\n', '       //----------------------------------------------\\n', '       // Shift Right\\n', '       //----------------------------------------------\\n', '       `ALU_SHIFTR, `ALU_SHIFTR_ARITH:\\n', '       begin\\n', \"            // Arithmetic shift? Fill with 1's if MSB set\\n\", \"            if (alu_a_i[31] == 1'b1 && alu_op_i == `ALU_SHIFTR_ARITH)\\n\", \"                shift_right_fill_r = 16'b1111111111111111;\\n\", '            else\\n', \"                shift_right_fill_r = 16'b0000000000000000;\\n\", '\\n', \"            if (alu_b_i[0] == 1'b1)\\n\", '                shift_right_1_r = {shift_right_fill_r[31], alu_a_i[31:1]};\\n', '            else\\n', '                shift_right_1_r = alu_a_i;\\n', '\\n', \"            if (alu_b_i[1] == 1'b1)\\n\", '                shift_right_2_r = {shift_right_fill_r[31:30], shift_right_1_r[31:2]};\\n', '            else\\n', '                shift_right_2_r = shift_right_1_r;\\n', '\\n', \"            if (alu_b_i[2] == 1'b1)\\n\", '                shift_right_4_r = {shift_right_fill_r[31:28], shift_right_2_r[31:4]};\\n', '            else\\n', '                shift_right_4_r = shift_right_2_r;\\n', '\\n', \"            if (alu_b_i[3] == 1'b1)\\n\", '                shift_right_8_r = {shift_right_fill_r[31:24], shift_right_4_r[31:8]};\\n', '            else\\n', '                shift_right_8_r = shift_right_4_r;\\n', '\\n', \"            if (alu_b_i[4] == 1'b1)\\n\", '                result_r = {shift_right_fill_r[31:16], shift_right_8_r[31:16]};\\n', '            else\\n', '                result_r = shift_right_8_r;\\n', '       end       \\n', '       //----------------------------------------------\\n', '       // Arithmetic\\n', '       //----------------------------------------------\\n', '       `ALU_ADD : \\n', '       begin\\n', '            result_r      = (alu_a_i + alu_b_i);\\n', '       end\\n', '       `ALU_SUB : \\n', '       begin\\n', '            result_r      = sub_res_w;\\n', '       end\\n', '       //----------------------------------------------\\n', '       // Logical\\n', '       //----------------------------------------------       \\n', '       `ALU_AND : \\n', '       begin\\n', '            result_r      = (alu_a_i & alu_b_i);\\n', '       end\\n', '       `ALU_OR  : \\n', '       begin\\n', '            result_r      = (alu_a_i | alu_b_i);\\n', '       end\\n', '       `ALU_XOR : \\n', '       begin\\n', '            result_r      = (alu_a_i ^ alu_b_i);\\n', '       end\\n', '       //----------------------------------------------\\n', '       // Comparision\\n', '       //----------------------------------------------\\n', '       `ALU_LESS_THAN : \\n', '       begin\\n', \"            result_r      = (alu_a_i < alu_b_i) ? 32'h1 : 32'h0;\\n\", '       end\\n', '       `ALU_LESS_THAN_SIGNED : \\n', '       begin\\n', '            if (alu_a_i[31] != alu_b_i[31])\\n', \"                result_r  = alu_a_i[31] ? 32'h1 : 32'h0;\\n\", '            else\\n', \"                result_r  = sub_res_w[31] ? 32'h1 : 32'h0;            \\n\", '       end       \\n', '       default  : \\n', '       begin\\n', '            result_r      = alu_a_i;\\n', '       end\\n', '    endcase\\n', 'end\\n', '\\n', 'assign alu_p_o    = result_r;\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module biriscv_csr\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter SUPPORT_MULDIV   = 1\\n', '    ,parameter SUPPORT_SUPER    = 1\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           intr_i\\n', '    ,input           opcode_valid_i\\n', '    ,input  [ 31:0]  opcode_opcode_i\\n', '    ,input  [ 31:0]  opcode_pc_i\\n', '    ,input           opcode_invalid_i\\n', '    ,input  [  4:0]  opcode_rd_idx_i\\n', '    ,input  [  4:0]  opcode_ra_idx_i\\n', '    ,input  [  4:0]  opcode_rb_idx_i\\n', '    ,input  [ 31:0]  opcode_ra_operand_i\\n', '    ,input  [ 31:0]  opcode_rb_operand_i\\n', '    ,input           csr_writeback_write_i\\n', '    ,input  [ 11:0]  csr_writeback_waddr_i\\n', '    ,input  [ 31:0]  csr_writeback_wdata_i\\n', '    ,input  [  5:0]  csr_writeback_exception_i\\n', '    ,input  [ 31:0]  csr_writeback_exception_pc_i\\n', '    ,input  [ 31:0]  csr_writeback_exception_addr_i\\n', '    ,input  [ 31:0]  cpu_id_i\\n', '    ,input  [ 31:0]  reset_vector_i\\n', '    ,input           interrupt_inhibit_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  csr_result_e1_value_o\\n', '    ,output          csr_result_e1_write_o\\n', '    ,output [ 31:0]  csr_result_e1_wdata_o\\n', '    ,output [  5:0]  csr_result_e1_exception_o\\n', '    ,output          branch_csr_request_o\\n', '    ,output [ 31:0]  branch_csr_pc_o\\n', '    ,output [  1:0]  branch_csr_priv_o\\n', '    ,output          take_interrupt_o\\n', '    ,output          ifence_o\\n', '    ,output [  1:0]  mmu_priv_d_o\\n', '    ,output          mmu_sum_o\\n', '    ,output          mmu_mxr_o\\n', '    ,output          mmu_flush_o\\n', '    ,output [ 31:0]  mmu_satp_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Includes\\n', '//-----------------------------------------------------------------\\n', '`include \"biriscv_defs.v\"\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers / Wires\\n', '//-----------------------------------------------------------------\\n', 'wire ecall_w             = opcode_valid_i && ((opcode_opcode_i & `INST_ECALL_MASK)      == `INST_ECALL);\\n', 'wire ebreak_w            = opcode_valid_i && ((opcode_opcode_i & `INST_EBREAK_MASK)     == `INST_EBREAK);\\n', 'wire eret_w              = opcode_valid_i && ((opcode_opcode_i & `INST_ERET_MASK)       == `INST_ERET);\\n', 'wire [1:0] eret_priv_w   = opcode_opcode_i[29:28];\\n', 'wire csrrw_w             = opcode_valid_i && ((opcode_opcode_i & `INST_CSRRW_MASK)      == `INST_CSRRW);\\n', 'wire csrrs_w             = opcode_valid_i && ((opcode_opcode_i & `INST_CSRRS_MASK)      == `INST_CSRRS);\\n', 'wire csrrc_w             = opcode_valid_i && ((opcode_opcode_i & `INST_CSRRC_MASK)      == `INST_CSRRC);\\n', 'wire csrrwi_w            = opcode_valid_i && ((opcode_opcode_i & `INST_CSRRWI_MASK)     == `INST_CSRRWI);\\n', 'wire csrrsi_w            = opcode_valid_i && ((opcode_opcode_i & `INST_CSRRSI_MASK)     == `INST_CSRRSI);\\n', 'wire csrrci_w            = opcode_valid_i && ((opcode_opcode_i & `INST_CSRRCI_MASK)     == `INST_CSRRCI);\\n', 'wire wfi_w               = opcode_valid_i && ((opcode_opcode_i & `INST_WFI_MASK)        == `INST_WFI);\\n', 'wire fence_w             = opcode_valid_i && ((opcode_opcode_i & `INST_FENCE_MASK)      == `INST_FENCE);\\n', 'wire sfence_w            = opcode_valid_i && ((opcode_opcode_i & `INST_SFENCE_MASK)     == `INST_SFENCE);\\n', 'wire ifence_w            = opcode_valid_i && ((opcode_opcode_i & `INST_IFENCE_MASK)     == `INST_IFENCE);\\n', '\\n', '//-----------------------------------------------------------------\\n', '// CSR handling\\n', '//-----------------------------------------------------------------\\n', 'wire [1:0]  current_priv_w;\\n', 'reg [1:0]   csr_priv_r;\\n', 'reg         csr_readonly_r;\\n', 'reg         csr_write_r;\\n', 'reg         set_r;\\n', 'reg         clr_r;\\n', 'reg         csr_fault_r;\\n', '\\n', 'reg [31:0]  data_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', '    set_r           = csrrw_w | csrrs_w | csrrwi_w | csrrsi_w;\\n', '    clr_r           = csrrw_w | csrrc_w | csrrwi_w | csrrci_w;\\n', '\\n', '    csr_priv_r      = opcode_opcode_i[29:28];\\n', \"    csr_readonly_r  = (opcode_opcode_i[31:30] == 2'd3);\\n\", \"    csr_write_r     = (opcode_ra_idx_i != 5'b0) | csrrw_w | csrrwi_w;\\n\", '\\n', '    data_r          = (csrrwi_w | \\n', '                       csrrsi_w | \\n', '                       csrrci_w) ?\\n', \"                            {27'b0, opcode_ra_idx_i} : opcode_ra_operand_i;\\n\", '\\n', '    // Detect access fault on CSR access\\n', \"    csr_fault_r     = SUPPORT_SUPER ? (opcode_valid_i && (set_r | clr_r) && ((csr_write_r && csr_readonly_r) || (current_priv_w < csr_priv_r))) : 1'b0;\\n\", 'end\\n', '\\n', 'wire satp_update_w = (opcode_valid_i && (set_r || clr_r) && csr_write_r && (opcode_opcode_i[31:20] == `CSR_SATP));\\n', '\\n', '//-----------------------------------------------------------------\\n', '// CSR register file\\n', '//-----------------------------------------------------------------\\n', \"wire timer_irq_w = 1'b0;\\n\", '\\n', 'wire [31:0] misa_w = SUPPORT_MULDIV ? (`MISA_RV32 | `MISA_RVI | `MISA_RVM): (`MISA_RV32 | `MISA_RVI);\\n', '\\n', 'wire [31:0] csr_rdata_w;\\n', '\\n', 'wire        csr_branch_w;\\n', 'wire [31:0] csr_target_w;\\n', '\\n', 'wire [31:0] interrupt_w;\\n', 'wire [31:0] status_reg_w;\\n', 'wire [31:0] satp_reg_w;\\n', '\\n', 'biriscv_csr_regfile\\n', '#( .SUPPORT_MTIMECMP(1)\\n', '  ,.SUPPORT_SUPER(SUPPORT_SUPER) )\\n', 'u_csrfile\\n', '(\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '\\n', '    ,.ext_intr_i(intr_i)\\n', '    ,.timer_intr_i(timer_irq_w)\\n', '    ,.cpu_id_i(cpu_id_i)\\n', '    ,.misa_i(misa_w)\\n', '\\n', '    // Issue\\n', '    ,.csr_ren_i(opcode_valid_i)\\n', '    ,.csr_raddr_i(opcode_opcode_i[31:20])\\n', '    ,.csr_rdata_o(csr_rdata_w)\\n', '\\n', '    // Exception (WB)\\n', '    ,.exception_i(csr_writeback_exception_i)\\n', '    ,.exception_pc_i(csr_writeback_exception_pc_i)\\n', '    ,.exception_addr_i(csr_writeback_exception_addr_i)\\n', '\\n', '    // CSR register writes (WB)\\n', \"    ,.csr_waddr_i(csr_writeback_write_i ? csr_writeback_waddr_i : 12'b0)\\n\", '    ,.csr_wdata_i(csr_writeback_wdata_i)\\n', '\\n', '    // CSR branches\\n', '    ,.csr_branch_o(csr_branch_w)\\n', '    ,.csr_target_o(csr_target_w)\\n', '\\n', '    // Various CSR registers\\n', '    ,.priv_o(current_priv_w)\\n', '    ,.status_o(status_reg_w)\\n', '    ,.satp_o(satp_reg_w)\\n', '\\n', '    // Masked interrupt output\\n', '    ,.interrupt_o(interrupt_w)\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// CSR Read Result (E1) / Early exceptions\\n', '//-----------------------------------------------------------------\\n', 'reg                     rd_valid_e1_q;\\n', 'reg [ 31:0]             rd_result_e1_q;\\n', 'reg [ 31:0]             csr_wdata_e1_q;\\n', 'reg [`EXCEPTION_W-1:0]  exception_e1_q;\\n', '\\n', '// Inappropriate xRET for the current exec priv level\\n', 'wire                    eret_fault_w = eret_w && (current_priv_w < eret_priv_w);\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    rd_valid_e1_q   <= 1'b0;\\n\", \"    rd_result_e1_q  <= 32'b0;\\n\", \"    csr_wdata_e1_q  <= 32'b0;\\n\", \"    exception_e1_q  <= `EXCEPTION_W'b0;\\n\", 'end\\n', 'else if (opcode_valid_i)\\n', 'begin\\n', '    rd_valid_e1_q   <= (set_r || clr_r) && ~csr_fault_r;\\n', '\\n', '    // Invalid instruction / CSR access fault?\\n', '    // Record opcode for writing to csr_xtval later.\\n', '    if (opcode_invalid_i || csr_fault_r || eret_fault_w)\\n', '        rd_result_e1_q  <= opcode_opcode_i;\\n', '    else    \\n', '        rd_result_e1_q  <= csr_rdata_w;\\n', '\\n', '    // E1 CSR exceptions\\n', '    if ((opcode_opcode_i & `INST_ECALL_MASK) == `INST_ECALL)\\n', \"        exception_e1_q  <= `EXCEPTION_ECALL + {4'b0, current_priv_w};\\n\", '    // xRET for priv level above this one - fault\\n', '    else if (eret_fault_w)\\n', '        exception_e1_q  <= `EXCEPTION_ILLEGAL_INSTRUCTION;\\n', '    else if ((opcode_opcode_i & `INST_ERET_MASK) == `INST_ERET)\\n', \"        exception_e1_q  <= `EXCEPTION_ERET_U + {4'b0, eret_priv_w};\\n\", '    else if ((opcode_opcode_i & `INST_EBREAK_MASK) == `INST_EBREAK)\\n', '        exception_e1_q  <= `EXCEPTION_BREAKPOINT;\\n', '    else if (opcode_invalid_i || csr_fault_r)\\n', '        exception_e1_q  <= `EXCEPTION_ILLEGAL_INSTRUCTION;\\n', '    // Fence / MMU settings cause a pipeline flush\\n', '    else if (satp_update_w || ifence_w || sfence_w)\\n', '        exception_e1_q  <= `EXCEPTION_FENCE;\\n', '    else\\n', \"        exception_e1_q  <= `EXCEPTION_W'b0;\\n\", '\\n', '    // Value to be written to CSR registers\\n', '    if (set_r && clr_r)\\n', '        csr_wdata_e1_q <= data_r;\\n', '    else if (set_r)\\n', '        csr_wdata_e1_q <= csr_rdata_w | data_r;\\n', '    else if (clr_r)\\n', '        csr_wdata_e1_q <= csr_rdata_w & ~data_r;\\n', 'end\\n', 'else\\n', 'begin\\n', \"    rd_valid_e1_q   <= 1'b0;\\n\", \"    rd_result_e1_q  <= 32'b0;\\n\", \"    csr_wdata_e1_q  <= 32'b0;\\n\", \"    exception_e1_q  <= `EXCEPTION_W'b0;\\n\", 'end\\n', '\\n', 'assign csr_result_e1_value_o     = rd_result_e1_q;\\n', 'assign csr_result_e1_write_o     = rd_valid_e1_q;\\n', 'assign csr_result_e1_wdata_o     = csr_wdata_e1_q;\\n', 'assign csr_result_e1_exception_o = exception_e1_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Interrupt launch enable\\n', '//-----------------------------------------------------------------\\n', 'reg take_interrupt_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    take_interrupt_q    <= 1'b0;\\n\", 'else\\n', '    take_interrupt_q    <= (|interrupt_w) & ~interrupt_inhibit_i;\\n', '\\n', 'assign take_interrupt_o = take_interrupt_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// TLB flush\\n', '//-----------------------------------------------------------------\\n', 'reg tlb_flush_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    tlb_flush_q <= 1'b0;\\n\", 'else\\n', '    tlb_flush_q <= satp_update_w || sfence_w;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// ifence\\n', '//-----------------------------------------------------------------\\n', 'reg ifence_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    ifence_q    <= 1'b0;\\n\", 'else\\n', '    ifence_q    <= ifence_w;\\n', '\\n', 'assign ifence_o = ifence_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Execute - Branch operations\\n', '//-----------------------------------------------------------------\\n', 'reg        branch_q;\\n', 'reg [31:0] branch_target_q;\\n', 'reg        reset_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    branch_target_q <= 32'b0;\\n\", \"    branch_q        <= 1'b0;\\n\", \"    reset_q         <= 1'b1;\\n\", 'end\\n', 'else if (reset_q)\\n', 'begin\\n', '    branch_target_q <= reset_vector_i;\\n', \"    branch_q        <= 1'b1;\\n\", \"    reset_q         <= 1'b0;\\n\", 'end\\n', 'else\\n', 'begin\\n', '    branch_q        <= csr_branch_w;\\n', '    branch_target_q <= csr_target_w;\\n', 'end\\n', '\\n', 'assign branch_csr_request_o = branch_q;\\n', 'assign branch_csr_pc_o      = branch_target_q;\\n', 'assign branch_csr_priv_o    = satp_reg_w[`SATP_MODE_R] ? current_priv_w : `PRIV_MACHINE;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// MMU\\n', '//-----------------------------------------------------------------\\n', 'assign mmu_priv_d_o     = status_reg_w[`SR_MPRV_R] ? status_reg_w[`SR_MPP_R] : current_priv_w;\\n', 'assign mmu_satp_o       = satp_reg_w;\\n', 'assign mmu_flush_o      = tlb_flush_q;\\n', 'assign mmu_sum_o        = status_reg_w[`SR_SUM_R];\\n', 'assign mmu_mxr_o        = status_reg_w[`SR_MXR_R];\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', 'module biriscv_csr_regfile\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter SUPPORT_MTIMECMP    = 1,\\n', '     parameter SUPPORT_SUPER       = 0\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '\\n', '    ,input           ext_intr_i\\n', '    ,input           timer_intr_i\\n', '\\n', '    ,input [31:0]    cpu_id_i\\n', '    ,input [31:0]    misa_i\\n', '\\n', '    ,input [5:0]     exception_i\\n', '    ,input [31:0]    exception_pc_i\\n', '    ,input [31:0]    exception_addr_i\\n', '\\n', '    // CSR read port\\n', '    ,input           csr_ren_i\\n', '    ,input  [11:0]   csr_raddr_i\\n', '    ,output [31:0]   csr_rdata_o\\n', '\\n', '    // CSR write port\\n', '    ,input  [11:0]   csr_waddr_i\\n', '    ,input  [31:0]   csr_wdata_i\\n', '\\n', '    ,output          csr_branch_o\\n', '    ,output [31:0]   csr_target_o\\n', '\\n', '    // CSR registers\\n', '    ,output [1:0]    priv_o\\n', '    ,output [31:0]   status_o\\n', '    ,output [31:0]   satp_o\\n', '\\n', '    // Masked interrupt output\\n', '    ,output [31:0]   interrupt_o\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Includes\\n', '//-----------------------------------------------------------------\\n', '`include \"biriscv_defs.v\"\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers / Wires\\n', '//-----------------------------------------------------------------\\n', '// CSR - Machine\\n', 'reg [31:0]  csr_mepc_q;\\n', 'reg [31:0]  csr_mcause_q;\\n', 'reg [31:0]  csr_sr_q;\\n', 'reg [31:0]  csr_mtvec_q;\\n', 'reg [31:0]  csr_mip_q;\\n', 'reg [31:0]  csr_mie_q;\\n', 'reg [1:0]   csr_mpriv_q;\\n', 'reg [31:0]  csr_mcycle_q;\\n', 'reg [31:0]  csr_mcycle_h_q;\\n', 'reg [31:0]  csr_mscratch_q;\\n', 'reg [31:0]  csr_mtval_q;\\n', 'reg [31:0]  csr_mtimecmp_q;\\n', 'reg         csr_mtime_ie_q;\\n', 'reg [31:0]  csr_medeleg_q;\\n', 'reg [31:0]  csr_mideleg_q;\\n', '\\n', '// CSR - Supervisor\\n', 'reg [31:0]  csr_sepc_q;\\n', 'reg [31:0]  csr_stvec_q;\\n', 'reg [31:0]  csr_scause_q;\\n', 'reg [31:0]  csr_stval_q;\\n', 'reg [31:0]  csr_satp_q;\\n', 'reg [31:0]  csr_sscratch_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Masked Interrupts\\n', '//-----------------------------------------------------------------\\n', 'reg [31:0] irq_pending_r;\\n', 'reg [31:0] irq_masked_r;\\n', 'reg [1:0]  irq_priv_r;\\n', '\\n', 'reg        m_enabled_r;\\n', 'reg [31:0] m_interrupts_r;\\n', 'reg        s_enabled_r;\\n', 'reg [31:0] s_interrupts_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', '    if (SUPPORT_SUPER)\\n', '    begin\\n', '        irq_pending_r   = (csr_mip_q & csr_mie_q);\\n', '        m_enabled_r     = (csr_mpriv_q < `PRIV_MACHINE) || (csr_mpriv_q == `PRIV_MACHINE && csr_sr_q[`SR_MIE_R]);\\n', '        s_enabled_r     = (csr_mpriv_q < `PRIV_SUPER)   || (csr_mpriv_q == `PRIV_SUPER   && csr_sr_q[`SR_SIE_R]);\\n', \"        m_interrupts_r  = m_enabled_r    ? (irq_pending_r & ~csr_mideleg_q) : 32'b0;\\n\", \"        s_interrupts_r  = s_enabled_r    ? (irq_pending_r &  csr_mideleg_q) : 32'b0;\\n\", '        irq_masked_r    = (|m_interrupts_r) ? m_interrupts_r : s_interrupts_r;\\n', '        irq_priv_r      = (|m_interrupts_r) ? `PRIV_MACHINE : `PRIV_SUPER;\\n', '    end\\n', '    else\\n', '    begin\\n', '        irq_pending_r   = (csr_mip_q & csr_mie_q);\\n', \"        irq_masked_r    = csr_sr_q[`SR_MIE_R] ? irq_pending_r : 32'b0;\\n\", '        irq_priv_r      = `PRIV_MACHINE;\\n', '    end\\n', 'end\\n', '\\n', 'reg [1:0] irq_priv_q;\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', '    irq_priv_q <= `PRIV_MACHINE;\\n', 'else if (|irq_masked_r)\\n', '    irq_priv_q <= irq_priv_r;\\n', '\\n', 'assign interrupt_o = irq_masked_r;\\n', '\\n', '\\n', 'reg csr_mip_upd_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    csr_mip_upd_q <= 1'b0;\\n\", 'else if ((csr_ren_i && csr_raddr_i == `CSR_MIP) || (csr_ren_i && csr_raddr_i == `CSR_SIP))\\n', \"    csr_mip_upd_q <= 1'b1;\\n\", 'else if (csr_waddr_i == `CSR_MIP || csr_waddr_i == `CSR_SIP || (|exception_i))\\n', \"    csr_mip_upd_q <= 1'b0;\\n\", '\\n', 'wire buffer_mip_w = (csr_ren_i && csr_raddr_i == `CSR_MIP) | (csr_ren_i && csr_raddr_i == `CSR_SIP) | csr_mip_upd_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// CSR Read Port\\n', '//-----------------------------------------------------------------\\n', 'reg [31:0] rdata_r;\\n', 'always @ *\\n', 'begin\\n', \"    rdata_r = 32'b0;\\n\", '\\n', '    case (csr_raddr_i)\\n', '    // CSR - Machine\\n', '    `CSR_MSCRATCH: rdata_r = csr_mscratch_q & `CSR_MSCRATCH_MASK;\\n', '    `CSR_MEPC:     rdata_r = csr_mepc_q & `CSR_MEPC_MASK;\\n', '    `CSR_MTVEC:    rdata_r = csr_mtvec_q & `CSR_MTVEC_MASK;\\n', '    `CSR_MCAUSE:   rdata_r = csr_mcause_q & `CSR_MCAUSE_MASK;\\n', '    `CSR_MTVAL:    rdata_r = csr_mtval_q & `CSR_MTVAL_MASK;\\n', '    `CSR_MSTATUS:  rdata_r = csr_sr_q & `CSR_MSTATUS_MASK;\\n', '    `CSR_MIP:      rdata_r = csr_mip_q & `CSR_MIP_MASK;\\n', '    `CSR_MIE:      rdata_r = csr_mie_q & `CSR_MIE_MASK;\\n', '    `CSR_MCYCLE,\\n', '    `CSR_MTIME:    rdata_r = csr_mcycle_q;\\n', '    `CSR_MTIMEH:   rdata_r = csr_mcycle_h_q;\\n', '    `CSR_MHARTID:  rdata_r = cpu_id_i;\\n', '    `CSR_MISA:     rdata_r = misa_i;\\n', \"    `CSR_MEDELEG:  rdata_r = SUPPORT_SUPER ? (csr_medeleg_q & `CSR_MEDELEG_MASK) : 32'b0;\\n\", \"    `CSR_MIDELEG:  rdata_r = SUPPORT_SUPER ? (csr_mideleg_q & `CSR_MIDELEG_MASK) : 32'b0;\\n\", '    // Non-std behaviour\\n', \"    `CSR_MTIMECMP: rdata_r = SUPPORT_MTIMECMP ? csr_mtimecmp_q : 32'b0;\\n\", '    // CSR - Super\\n', \"    `CSR_SSTATUS:  rdata_r = SUPPORT_SUPER ? (csr_sr_q       & `CSR_SSTATUS_MASK)  : 32'b0;\\n\", \"    `CSR_SIP:      rdata_r = SUPPORT_SUPER ? (csr_mip_q      & `CSR_SIP_MASK)      : 32'b0;\\n\", \"    `CSR_SIE:      rdata_r = SUPPORT_SUPER ? (csr_mie_q      & `CSR_SIE_MASK)      : 32'b0;\\n\", \"    `CSR_SEPC:     rdata_r = SUPPORT_SUPER ? (csr_sepc_q     & `CSR_SEPC_MASK)     : 32'b0;\\n\", \"    `CSR_STVEC:    rdata_r = SUPPORT_SUPER ? (csr_stvec_q    & `CSR_STVEC_MASK)    : 32'b0;\\n\", \"    `CSR_SCAUSE:   rdata_r = SUPPORT_SUPER ? (csr_scause_q   & `CSR_SCAUSE_MASK)   : 32'b0;\\n\", \"    `CSR_STVAL:    rdata_r = SUPPORT_SUPER ? (csr_stval_q    & `CSR_STVAL_MASK)    : 32'b0;\\n\", \"    `CSR_SATP:     rdata_r = SUPPORT_SUPER ? (csr_satp_q     & `CSR_SATP_MASK)     : 32'b0;\\n\", \"    `CSR_SSCRATCH: rdata_r = SUPPORT_SUPER ? (csr_sscratch_q & `CSR_SSCRATCH_MASK) : 32'b0;\\n\", \"    default:       rdata_r = 32'b0;\\n\", '    endcase\\n', 'end\\n', '\\n', 'assign csr_rdata_o = rdata_r;\\n', 'assign priv_o      = csr_mpriv_q;\\n', 'assign status_o    = csr_sr_q;\\n', 'assign satp_o      = csr_satp_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// CSR register next state\\n', '//-----------------------------------------------------------------\\n', '// CSR - Machine\\n', 'reg [31:0]  csr_mepc_r;\\n', 'reg [31:0]  csr_mcause_r;\\n', 'reg [31:0]  csr_mtval_r;\\n', 'reg [31:0]  csr_sr_r;\\n', 'reg [31:0]  csr_mtvec_r;\\n', 'reg [31:0]  csr_mip_r;\\n', 'reg [31:0]  csr_mie_r;\\n', 'reg [1:0]   csr_mpriv_r;\\n', 'reg [31:0]  csr_mcycle_r;\\n', 'reg [31:0]  csr_mscratch_r;\\n', 'reg [31:0]  csr_mtimecmp_r;\\n', 'reg         csr_mtime_ie_r;\\n', 'reg [31:0]  csr_medeleg_r;\\n', 'reg [31:0]  csr_mideleg_r;\\n', '\\n', 'reg [31:0]  csr_mip_next_q;\\n', 'reg [31:0]  csr_mip_next_r;\\n', '\\n', '// CSR - Supervisor\\n', 'reg [31:0]  csr_sepc_r;\\n', 'reg [31:0]  csr_stvec_r;\\n', 'reg [31:0]  csr_scause_r;\\n', 'reg [31:0]  csr_stval_r;\\n', 'reg [31:0]  csr_satp_r;\\n', 'reg [31:0]  csr_sscratch_r;\\n', '\\n', 'wire is_exception_w = ((exception_i & `EXCEPTION_TYPE_MASK) == `EXCEPTION_EXCEPTION);\\n', \"wire exception_s_w  = SUPPORT_SUPER ? ((csr_mpriv_q <= `PRIV_SUPER) & is_exception_w & csr_medeleg_q[{1'b0, exception_i[`EXCEPTION_SUBTYPE_R]}]) : 1'b0;\\n\", '\\n', 'always @ *\\n', 'begin\\n', '    // CSR - Machine\\n', '    csr_mip_next_r  = csr_mip_next_q;\\n', '    csr_mepc_r      = csr_mepc_q;\\n', '    csr_sr_r        = csr_sr_q;\\n', '    csr_mcause_r    = csr_mcause_q;\\n', '    csr_mtval_r     = csr_mtval_q;\\n', '    csr_mtvec_r     = csr_mtvec_q;\\n', '    csr_mip_r       = csr_mip_q;\\n', '    csr_mie_r       = csr_mie_q;\\n', '    csr_mpriv_r     = csr_mpriv_q;\\n', '    csr_mscratch_r  = csr_mscratch_q;\\n', \"    csr_mcycle_r    = csr_mcycle_q + 32'd1;\\n\", '    csr_mtimecmp_r  = csr_mtimecmp_q;\\n', '    csr_mtime_ie_r  = csr_mtime_ie_q;\\n', '    csr_medeleg_r   = csr_medeleg_q;\\n', '    csr_mideleg_r   = csr_mideleg_q;\\n', '\\n', '    // CSR - Super\\n', '    csr_sepc_r      = csr_sepc_q;\\n', '    csr_stvec_r     = csr_stvec_q;\\n', '    csr_scause_r    = csr_scause_q;\\n', '    csr_stval_r     = csr_stval_q;\\n', '    csr_satp_r      = csr_satp_q;\\n', '    csr_sscratch_r  = csr_sscratch_q;\\n', '\\n', '    // Interrupts\\n', '    if ((exception_i & `EXCEPTION_TYPE_MASK) == `EXCEPTION_INTERRUPT)\\n', '    begin\\n', '        // Machine mode interrupts\\n', '        if (irq_priv_q == `PRIV_MACHINE)\\n', '        begin\\n', '            // Save interrupt / supervisor state\\n', '            csr_sr_r[`SR_MPIE_R] = csr_sr_r[`SR_MIE_R];\\n', '            csr_sr_r[`SR_MPP_R]  = csr_mpriv_q;\\n', '\\n', '            // Disable interrupts and enter supervisor mode\\n', \"            csr_sr_r[`SR_MIE_R]  = 1'b0;\\n\", '\\n', '            // Raise priviledge to machine level\\n', '            csr_mpriv_r          = `PRIV_MACHINE;\\n', '\\n', '            // Record interrupt source PC\\n', '            csr_mepc_r           = exception_pc_i;\\n', \"            csr_mtval_r          = 32'b0;\\n\", '\\n', '            // Piority encoded interrupt cause\\n', '            if (interrupt_o[`IRQ_M_SOFT])\\n', \"                csr_mcause_r = `MCAUSE_INTERRUPT + 32'd`IRQ_M_SOFT;\\n\", '            else if (interrupt_o[`IRQ_M_TIMER])\\n', \"                csr_mcause_r = `MCAUSE_INTERRUPT + 32'd`IRQ_M_TIMER;\\n\", '            else if (interrupt_o[`IRQ_M_EXT])\\n', \"                csr_mcause_r = `MCAUSE_INTERRUPT + 32'd`IRQ_M_EXT;\\n\", '        end\\n', '        // Supervisor mode interrupts\\n', '        else\\n', '        begin\\n', '            // Save interrupt / supervisor state\\n', '            csr_sr_r[`SR_SPIE_R] = csr_sr_r[`SR_SIE_R];\\n', '            csr_sr_r[`SR_SPP_R]  = (csr_mpriv_q == `PRIV_SUPER);\\n', '\\n', '            // Disable interrupts and enter supervisor mode\\n', \"            csr_sr_r[`SR_SIE_R]  = 1'b0;\\n\", '\\n', '            // Raise priviledge to machine level\\n', '            csr_mpriv_r  = `PRIV_SUPER;\\n', '\\n', '            // Record fault source PC\\n', '            csr_sepc_r   = exception_pc_i;\\n', \"            csr_stval_r  = 32'b0;\\n\", '\\n', '            // Piority encoded interrupt cause\\n', '            if (interrupt_o[`IRQ_S_SOFT])\\n', \"                csr_scause_r = `MCAUSE_INTERRUPT + 32'd`IRQ_S_SOFT;\\n\", '            else if (interrupt_o[`IRQ_S_TIMER])\\n', \"                csr_scause_r = `MCAUSE_INTERRUPT + 32'd`IRQ_S_TIMER;\\n\", '            else if (interrupt_o[`IRQ_S_EXT])\\n', \"                csr_scause_r = `MCAUSE_INTERRUPT + 32'd`IRQ_S_EXT;\\n\", '        end\\n', '    end\\n', '    // Exception return\\n', '    else if (exception_i >= `EXCEPTION_ERET_U && exception_i <= `EXCEPTION_ERET_M)\\n', '    begin\\n', '        // MRET (return from machine)\\n', '        if (exception_i[1:0] == `PRIV_MACHINE)\\n', '        begin\\n', '            // Set privilege level to previous MPP\\n', '            csr_mpriv_r          = csr_sr_r[`SR_MPP_R];\\n', '\\n', '            // Interrupt enable pop\\n', '            csr_sr_r[`SR_MIE_R]  = csr_sr_r[`SR_MPIE_R];\\n', \"            csr_sr_r[`SR_MPIE_R] = 1'b1;\\n\", '\\n', '            // TODO: Set next MPP to user mode??\\n', '            csr_sr_r[`SR_MPP_R] = `SR_MPP_U;\\n', '        end\\n', '        // SRET (return from supervisor)\\n', '        else\\n', '        begin\\n', '            // Set privilege level to previous privilege level\\n', '            csr_mpriv_r          = csr_sr_r[`SR_SPP_R] ? `PRIV_SUPER : `PRIV_USER;\\n', '\\n', '            // Interrupt enable pop\\n', '            csr_sr_r[`SR_SIE_R]  = csr_sr_r[`SR_SPIE_R];\\n', \"            csr_sr_r[`SR_SPIE_R] = 1'b1;\\n\", '\\n', '            // Set next SPP to user mode\\n', \"            csr_sr_r[`SR_SPP_R] = 1'b0;\\n\", '        end\\n', '    end\\n', '    // Exception - handled in super mode\\n', '    else if (is_exception_w && exception_s_w)\\n', '    begin\\n', '        // Save interrupt / supervisor state\\n', '        csr_sr_r[`SR_SPIE_R] = csr_sr_r[`SR_SIE_R];\\n', '        csr_sr_r[`SR_SPP_R]  = (csr_mpriv_q == `PRIV_SUPER);\\n', '\\n', '        // Disable interrupts and enter supervisor mode\\n', \"        csr_sr_r[`SR_SIE_R]  = 1'b0;\\n\", '\\n', '        // Raise priviledge to machine level\\n', '        csr_mpriv_r  = `PRIV_SUPER;\\n', '\\n', '        // Record fault source PC\\n', '        csr_sepc_r   = exception_pc_i;\\n', '\\n', '        // Bad address / PC\\n', '        case (exception_i)\\n', '        `EXCEPTION_MISALIGNED_FETCH,\\n', '        `EXCEPTION_FAULT_FETCH,\\n', '        `EXCEPTION_PAGE_FAULT_INST:     csr_stval_r = exception_pc_i;\\n', '        `EXCEPTION_ILLEGAL_INSTRUCTION,\\n', '        `EXCEPTION_MISALIGNED_LOAD,\\n', '        `EXCEPTION_FAULT_LOAD,\\n', '        `EXCEPTION_MISALIGNED_STORE,\\n', '        `EXCEPTION_FAULT_STORE,\\n', '        `EXCEPTION_PAGE_FAULT_LOAD,\\n', '        `EXCEPTION_PAGE_FAULT_STORE:    csr_stval_r = exception_addr_i;\\n', \"        default:                        csr_stval_r = 32'b0;\\n\", '        endcase\\n', '\\n', '        // Fault cause\\n', \"        csr_scause_r = {28'b0, exception_i[3:0]};\\n\", '    end\\n', '    // Exception - handled in machine mode\\n', '    else if (is_exception_w)\\n', '    begin\\n', '        // Save interrupt / supervisor state\\n', '        csr_sr_r[`SR_MPIE_R] = csr_sr_r[`SR_MIE_R];\\n', '        csr_sr_r[`SR_MPP_R]  = csr_mpriv_q;\\n', '\\n', '        // Disable interrupts and enter supervisor mode\\n', \"        csr_sr_r[`SR_MIE_R]  = 1'b0;\\n\", '\\n', '        // Raise priviledge to machine level\\n', '        csr_mpriv_r  = `PRIV_MACHINE;\\n', '\\n', '        // Record fault source PC\\n', '        csr_mepc_r   = exception_pc_i;\\n', '\\n', '        // Bad address / PC\\n', '        case (exception_i)\\n', '        `EXCEPTION_MISALIGNED_FETCH,\\n', '        `EXCEPTION_FAULT_FETCH,\\n', '        `EXCEPTION_PAGE_FAULT_INST:     csr_mtval_r = exception_pc_i;\\n', '        `EXCEPTION_ILLEGAL_INSTRUCTION,\\n', '        `EXCEPTION_MISALIGNED_LOAD,\\n', '        `EXCEPTION_FAULT_LOAD,\\n', '        `EXCEPTION_MISALIGNED_STORE,\\n', '        `EXCEPTION_FAULT_STORE,\\n', '        `EXCEPTION_PAGE_FAULT_LOAD,\\n', '        `EXCEPTION_PAGE_FAULT_STORE:    csr_mtval_r = exception_addr_i;\\n', \"        default:                        csr_mtval_r = 32'b0;\\n\", '        endcase        \\n', '\\n', '        // Fault cause\\n', \"        csr_mcause_r = {28'b0, exception_i[3:0]};\\n\", '    end\\n', '    else\\n', '    begin\\n', '        case (csr_waddr_i)\\n', '        // CSR - Machine\\n', '        `CSR_MSCRATCH: csr_mscratch_r = csr_wdata_i & `CSR_MSCRATCH_MASK;\\n', '        `CSR_MEPC:     csr_mepc_r     = csr_wdata_i & `CSR_MEPC_MASK;\\n', '        `CSR_MTVEC:    csr_mtvec_r    = csr_wdata_i & `CSR_MTVEC_MASK;\\n', '        `CSR_MCAUSE:   csr_mcause_r   = csr_wdata_i & `CSR_MCAUSE_MASK;\\n', '        `CSR_MTVAL:    csr_mtval_r    = csr_wdata_i & `CSR_MTVAL_MASK;\\n', '        `CSR_MSTATUS:  csr_sr_r       = csr_wdata_i & `CSR_MSTATUS_MASK;\\n', '        `CSR_MIP:      csr_mip_r      = csr_wdata_i & `CSR_MIP_MASK;\\n', '        `CSR_MIE:      csr_mie_r      = csr_wdata_i & `CSR_MIE_MASK;\\n', '        `CSR_MEDELEG:  csr_medeleg_r  = csr_wdata_i & `CSR_MEDELEG_MASK;\\n', '        `CSR_MIDELEG:  csr_mideleg_r  = csr_wdata_i & `CSR_MIDELEG_MASK;\\n', '        // Non-std behaviour\\n', '        `CSR_MTIMECMP:\\n', '        begin\\n', '            csr_mtimecmp_r = csr_wdata_i & `CSR_MTIMECMP_MASK;\\n', \"            csr_mtime_ie_r = 1'b1;\\n\", '        end\\n', '        // CSR - Super\\n', '        `CSR_SEPC:     csr_sepc_r     = csr_wdata_i & `CSR_SEPC_MASK;\\n', '        `CSR_STVEC:    csr_stvec_r    = csr_wdata_i & `CSR_STVEC_MASK;\\n', '        `CSR_SCAUSE:   csr_scause_r   = csr_wdata_i & `CSR_SCAUSE_MASK;\\n', '        `CSR_STVAL:    csr_stval_r    = csr_wdata_i & `CSR_STVAL_MASK;\\n', '        `CSR_SATP:     csr_satp_r     = csr_wdata_i & `CSR_SATP_MASK;\\n', '        `CSR_SSCRATCH: csr_sscratch_r = csr_wdata_i & `CSR_SSCRATCH_MASK;\\n', '        `CSR_SSTATUS:  csr_sr_r       = (csr_sr_r & ~`CSR_SSTATUS_MASK) | (csr_wdata_i & `CSR_SSTATUS_MASK);\\n', '        `CSR_SIP:      csr_mip_r      = (csr_mip_r & ~`CSR_SIP_MASK) | (csr_wdata_i & `CSR_SIP_MASK);\\n', '        `CSR_SIE:      csr_mie_r      = (csr_mie_r & ~`CSR_SIE_MASK) | (csr_wdata_i & `CSR_SIE_MASK);\\n', '        default:\\n', '            ;\\n', '        endcase\\n', '    end\\n', ' \\n', '    // External interrupts\\n', '    // NOTE: If the machine level interrupts are delegated to supervisor, route the interrupts there instead..\\n', \"    if (ext_intr_i   &&  csr_mideleg_q[`SR_IP_MEIP_R]) csr_mip_next_r[`SR_IP_SEIP_R] = 1'b1;\\n\", \"    if (ext_intr_i   && ~csr_mideleg_q[`SR_IP_MEIP_R]) csr_mip_next_r[`SR_IP_MEIP_R] = 1'b1;\\n\", \"    if (timer_intr_i &&  csr_mideleg_q[`SR_IP_MTIP_R]) csr_mip_next_r[`SR_IP_STIP_R] = 1'b1;\\n\", \"    if (timer_intr_i && ~csr_mideleg_q[`SR_IP_MTIP_R]) csr_mip_next_r[`SR_IP_MTIP_R] = 1'b1;\\n\", '\\n', '    // Optional: Internal timer compare interrupt\\n', '    if (SUPPORT_MTIMECMP && csr_mcycle_q == csr_mtimecmp_q)\\n', '    begin\\n', '        if (csr_mideleg_q[`SR_IP_MTIP_R])\\n', '            csr_mip_next_r[`SR_IP_STIP_R] = csr_mtime_ie_q;\\n', '        else\\n', '            csr_mip_next_r[`SR_IP_MTIP_R] = csr_mtime_ie_q;\\n', \"        csr_mtime_ie_r  = 1'b0;\\n\", '    end\\n', '\\n', '    csr_mip_r = csr_mip_r | csr_mip_next_r;\\n', 'end\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Sequential\\n', '//-----------------------------------------------------------------\\n', '`ifdef verilator\\n', '`define HAS_SIM_CTRL\\n', '`endif\\n', '`ifdef verilog_sim\\n', '`define HAS_SIM_CTRL\\n', '`endif\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', '    // CSR - Machine\\n', \"    csr_mepc_q         <= 32'b0;\\n\", \"    csr_sr_q           <= 32'b0;\\n\", \"    csr_mcause_q       <= 32'b0;\\n\", \"    csr_mtval_q        <= 32'b0;\\n\", \"    csr_mtvec_q        <= 32'b0;\\n\", \"    csr_mip_q          <= 32'b0;\\n\", \"    csr_mie_q          <= 32'b0;\\n\", '    csr_mpriv_q        <= `PRIV_MACHINE;\\n', \"    csr_mcycle_q       <= 32'b0;\\n\", \"    csr_mcycle_h_q     <= 32'b0;\\n\", \"    csr_mscratch_q     <= 32'b0;\\n\", \"    csr_mtimecmp_q     <= 32'b0;\\n\", \"    csr_mtime_ie_q     <= 1'b0;\\n\", \"    csr_medeleg_q      <= 32'b0;\\n\", \"    csr_mideleg_q      <= 32'b0;\\n\", '\\n', '    // CSR - Super\\n', \"    csr_sepc_q         <= 32'b0;\\n\", \"    csr_stvec_q        <= 32'b0;\\n\", \"    csr_scause_q       <= 32'b0;\\n\", \"    csr_stval_q        <= 32'b0;\\n\", \"    csr_satp_q         <= 32'b0;\\n\", \"    csr_sscratch_q     <= 32'b0;\\n\", '\\n', \"    csr_mip_next_q     <= 32'b0;\\n\", 'end\\n', 'else\\n', 'begin\\n', '    // CSR - Machine\\n', '    csr_mepc_q         <= csr_mepc_r;\\n', '    csr_sr_q           <= csr_sr_r;\\n', '    csr_mcause_q       <= csr_mcause_r;\\n', '    csr_mtval_q        <= csr_mtval_r;\\n', '    csr_mtvec_q        <= csr_mtvec_r;\\n', '    csr_mip_q          <= csr_mip_r;\\n', '    csr_mie_q          <= csr_mie_r;\\n', '    csr_mpriv_q        <= SUPPORT_SUPER ? csr_mpriv_r : `PRIV_MACHINE;\\n', '    csr_mcycle_q       <= csr_mcycle_r;\\n', '    csr_mscratch_q     <= csr_mscratch_r;\\n', \"    csr_mtimecmp_q     <= SUPPORT_MTIMECMP ? csr_mtimecmp_r : 32'b0;\\n\", \"    csr_mtime_ie_q     <= SUPPORT_MTIMECMP ? csr_mtime_ie_r : 1'b0;\\n\", \"    csr_medeleg_q      <= SUPPORT_SUPER ? (csr_medeleg_r   & `CSR_MEDELEG_MASK) : 32'b0;\\n\", \"    csr_mideleg_q      <= SUPPORT_SUPER ? (csr_mideleg_r   & `CSR_MIDELEG_MASK) : 32'b0;\\n\", '\\n', '    // CSR - Super\\n', \"    csr_sepc_q         <= SUPPORT_SUPER ? (csr_sepc_r     & `CSR_SEPC_MASK)     : 32'b0;\\n\", \"    csr_stvec_q        <= SUPPORT_SUPER ? (csr_stvec_r    & `CSR_STVEC_MASK)    : 32'b0;\\n\", \"    csr_scause_q       <= SUPPORT_SUPER ? (csr_scause_r   & `CSR_SCAUSE_MASK)   : 32'b0;\\n\", \"    csr_stval_q        <= SUPPORT_SUPER ? (csr_stval_r    & `CSR_STVAL_MASK)    : 32'b0;\\n\", \"    csr_satp_q         <= SUPPORT_SUPER ? (csr_satp_r     & `CSR_SATP_MASK)     : 32'b0;\\n\", \"    csr_sscratch_q     <= SUPPORT_SUPER ? (csr_sscratch_r & `CSR_SSCRATCH_MASK) : 32'b0;\\n\", '\\n', \"    csr_mip_next_q     <= buffer_mip_w ? csr_mip_next_r : 32'b0;\\n\", '\\n', '    // Increment upper cycle counter on lower 32-bit overflow\\n', \"    if (csr_mcycle_q == 32'hFFFFFFFF)\\n\", \"        csr_mcycle_h_q <= csr_mcycle_h_q + 32'd1;\\n\", '\\n', '`ifdef HAS_SIM_CTRL\\n', '    // CSR SIM_CTRL (or DSCRATCH)\\n', '    if ((csr_waddr_i == `CSR_DSCRATCH || csr_waddr_i == `CSR_SIM_CTRL) && ~(|exception_i))\\n', '    begin\\n', \"        case (csr_wdata_i & 32'hFF000000)\\n\", '        `CSR_SIM_CTRL_EXIT:\\n', '        begin\\n', '            //exit(csr_wdata_i[7:0]);\\n', '            $finish;\\n', '            $finish;\\n', '        end\\n', '        `CSR_SIM_CTRL_PUTC:\\n', '        begin\\n', '            $write(\"%c\", csr_wdata_i[7:0]);\\n', '        end\\n', '        endcase\\n', '    end\\n', '`endif\\n', 'end\\n', '\\n', '//-----------------------------------------------------------------\\n', '// CSR branch\\n', '//-----------------------------------------------------------------\\n', 'reg        branch_r;\\n', 'reg [31:0] branch_target_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', \"    branch_r        = 1'b0;\\n\", \"    branch_target_r = 32'b0;\\n\", '\\n', '    // Interrupts\\n', '    if (exception_i == `EXCEPTION_INTERRUPT)\\n', '    begin\\n', \"        branch_r        = 1'b1;\\n\", '        branch_target_r = (irq_priv_q == `PRIV_MACHINE) ? csr_mtvec_q : csr_stvec_q;\\n', '    end\\n', '    // Exception return\\n', '    else if (exception_i >= `EXCEPTION_ERET_U && exception_i <= `EXCEPTION_ERET_M)\\n', '    begin\\n', '        // MRET (return from machine)\\n', '        if (exception_i[1:0] == `PRIV_MACHINE)\\n', '        begin    \\n', \"            branch_r        = 1'b1;\\n\", '            branch_target_r = csr_mepc_q;\\n', '        end\\n', '        // SRET (return from supervisor)\\n', '        else\\n', '        begin\\n', \"            branch_r        = 1'b1;\\n\", '            branch_target_r = csr_sepc_q;\\n', '        end\\n', '    end\\n', '    // Exception - handled in super mode\\n', '    else if (is_exception_w && exception_s_w)\\n', '    begin\\n', \"        branch_r        = 1'b1;\\n\", '        branch_target_r = csr_stvec_q;\\n', '    end\\n', '    // Exception - handled in machine mode\\n', '    else if (is_exception_w)\\n', '    begin\\n', \"        branch_r        = 1'b1;\\n\", '        branch_target_r = csr_mtvec_q;\\n', '    end\\n', '    // Fence / SATP register writes cause pipeline flushes\\n', '    else if (exception_i == `EXCEPTION_FENCE)\\n', '    begin\\n', \"        branch_r        = 1'b1;\\n\", \"        branch_target_r = exception_pc_i + 32'd4;\\n\", '    end\\n', 'end\\n', '\\n', 'assign csr_branch_o = branch_r;\\n', 'assign csr_target_o = branch_target_r;\\n', '\\n', '`ifdef verilator\\n', 'function [31:0] get_mcycle; /*verilator public*/\\n', 'begin\\n', '    get_mcycle = csr_mcycle_q;\\n', 'end\\n', 'endfunction\\n', '`endif\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module biriscv_decode\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter SUPPORT_MULDIV   = 1\\n', '    ,parameter EXTRA_DECODE_STAGE = 0\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           fetch_in_valid_i\\n', '    ,input  [ 63:0]  fetch_in_instr_i\\n', '    ,input  [  1:0]  fetch_in_pred_branch_i\\n', '    ,input           fetch_in_fault_fetch_i\\n', '    ,input           fetch_in_fault_page_i\\n', '    ,input  [ 31:0]  fetch_in_pc_i\\n', '    ,input           fetch_out0_accept_i\\n', '    ,input           fetch_out1_accept_i\\n', '    ,input           branch_request_i\\n', '    ,input  [ 31:0]  branch_pc_i\\n', '    ,input  [  1:0]  branch_priv_i\\n', '\\n', '    // Outputs\\n', '    ,output          fetch_in_accept_o\\n', '    ,output          fetch_out0_valid_o\\n', '    ,output [ 31:0]  fetch_out0_instr_o\\n', '    ,output [ 31:0]  fetch_out0_pc_o\\n', '    ,output          fetch_out0_fault_fetch_o\\n', '    ,output          fetch_out0_fault_page_o\\n', '    ,output          fetch_out0_instr_exec_o\\n', '    ,output          fetch_out0_instr_lsu_o\\n', '    ,output          fetch_out0_instr_branch_o\\n', '    ,output          fetch_out0_instr_mul_o\\n', '    ,output          fetch_out0_instr_div_o\\n', '    ,output          fetch_out0_instr_csr_o\\n', '    ,output          fetch_out0_instr_rd_valid_o\\n', '    ,output          fetch_out0_instr_invalid_o\\n', '    ,output          fetch_out1_valid_o\\n', '    ,output [ 31:0]  fetch_out1_instr_o\\n', '    ,output [ 31:0]  fetch_out1_pc_o\\n', '    ,output          fetch_out1_fault_fetch_o\\n', '    ,output          fetch_out1_fault_page_o\\n', '    ,output          fetch_out1_instr_exec_o\\n', '    ,output          fetch_out1_instr_lsu_o\\n', '    ,output          fetch_out1_instr_branch_o\\n', '    ,output          fetch_out1_instr_mul_o\\n', '    ,output          fetch_out1_instr_div_o\\n', '    ,output          fetch_out1_instr_csr_o\\n', '    ,output          fetch_out1_instr_rd_valid_o\\n', '    ,output          fetch_out1_instr_invalid_o\\n', ');\\n', '\\n', '\\n', '\\n', 'wire        enable_muldiv_w     = SUPPORT_MULDIV;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// 2 cycle frontend latency\\n', '//-----------------------------------------------------------------\\n', 'generate\\n', 'if (EXTRA_DECODE_STAGE)\\n', 'begin\\n', '    wire        fetch_in_fault_page_w;\\n', '    wire        fetch_in_fault_fetch_w;\\n', '    wire [1:0]  fetch_in_pred_branch_w;\\n', '    wire [63:0] fetch_in_instr_raw_w;\\n', '    wire [63:0] fetch_in_instr_w;\\n', '    wire [31:0] fetch_in_pc_w;\\n', '    wire        fetch_in_valid_w;\\n', '\\n', '    reg [100:0] fetch_buffer_q;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', \"        fetch_buffer_q <= 101'b0;\\n\", '    else if (branch_request_i)\\n', \"        fetch_buffer_q <= 101'b0;\\n\", '    else if (!fetch_in_valid_w || fetch_in_accept_o)\\n', '        fetch_buffer_q <= {fetch_in_fault_page_i, fetch_in_fault_fetch_i, fetch_in_pred_branch_i, fetch_in_instr_i, fetch_in_pc_i, fetch_in_valid_i};\\n', '\\n', '    assign {fetch_in_fault_page_w, \\n', '            fetch_in_fault_fetch_w, \\n', '            fetch_in_pred_branch_w, \\n', '            fetch_in_instr_raw_w, \\n', '            fetch_in_pc_w, \\n', '            fetch_in_valid_w} = fetch_buffer_q;\\n', '\\n', \"    assign fetch_in_instr_w = (fetch_in_fault_page_w | fetch_in_fault_fetch_w) ? 64'b0 : fetch_in_instr_raw_w;\\n\", '\\n', '    wire [7:0] info0_in_w;\\n', '    wire [9:0] info0_out_w;\\n', '    wire [7:0] info1_in_w;\\n', '    wire [9:0] info1_out_w;\\n', '\\n', '\\n', '    biriscv_decoder\\n', '    u_dec0\\n', '    (\\n', '         .valid_i(fetch_in_valid_w)\\n', '        ,.fetch_fault_i(fetch_in_fault_fetch_w | fetch_in_fault_page_w)\\n', '        ,.enable_muldiv_i(enable_muldiv_w)\\n', '        ,.opcode_i(fetch_in_instr_w[31:0])\\n', '\\n', '        ,.invalid_o(info0_in_w[7])\\n', '        ,.exec_o(info0_in_w[6])\\n', '        ,.lsu_o(info0_in_w[5])\\n', '        ,.branch_o(info0_in_w[4])\\n', '        ,.mul_o(info0_in_w[3])\\n', '        ,.div_o(info0_in_w[2])\\n', '        ,.csr_o(info0_in_w[1])\\n', '        ,.rd_valid_o(info0_in_w[0])\\n', '    );\\n', '\\n', '    biriscv_decoder\\n', '    u_dec1\\n', '    (\\n', '         .valid_i(fetch_in_valid_w)\\n', '        ,.fetch_fault_i(fetch_in_fault_fetch_w | fetch_in_fault_page_w)\\n', '        ,.enable_muldiv_i(enable_muldiv_w)\\n', '        ,.opcode_i(fetch_in_instr_w[63:32])\\n', '\\n', '        ,.invalid_o(info1_in_w[7])\\n', '        ,.exec_o(info1_in_w[6])\\n', '        ,.lsu_o(info1_in_w[5])\\n', '        ,.branch_o(info1_in_w[4])\\n', '        ,.mul_o(info1_in_w[3])\\n', '        ,.div_o(info1_in_w[2])\\n', '        ,.csr_o(info1_in_w[1])\\n', '        ,.rd_valid_o(info1_in_w[0])\\n', '    );\\n', '\\n', '    fetch_fifo\\n', '    #( .OPC_INFO_W(10) )\\n', '    u_fifo\\n', '    (\\n', '         .clk_i(clk_i)\\n', '        ,.rst_i(rst_i)\\n', '\\n', '        ,.flush_i(branch_request_i)\\n', '\\n', '        // Input side\\n', '        ,.push_i(fetch_in_valid_w)\\n', '        ,.pc_in_i(fetch_in_pc_w)\\n', '        ,.pred_in_i(fetch_in_pred_branch_w)\\n', '        ,.data_in_i(fetch_in_instr_w)\\n', '        ,.info0_in_i({info0_in_w, fetch_in_fault_page_w, fetch_in_fault_fetch_w})\\n', '        ,.info1_in_i({info1_in_w, fetch_in_fault_page_w, fetch_in_fault_fetch_w})\\n', '        ,.accept_o(fetch_in_accept_o)\\n', '\\n', '        // Outputs\\n', '        ,.valid0_o(fetch_out0_valid_o)\\n', '        ,.pc0_out_o(fetch_out0_pc_o)\\n', '        ,.data0_out_o(fetch_out0_instr_o)\\n', '        ,.info0_out_o({fetch_out0_instr_invalid_o, fetch_out0_instr_exec_o,\\n', '                       fetch_out0_instr_lsu_o,     fetch_out0_instr_branch_o,\\n', '                       fetch_out0_instr_mul_o,     fetch_out0_instr_div_o,\\n', '                       fetch_out0_instr_csr_o,     fetch_out0_instr_rd_valid_o,\\n', '                       fetch_out0_fault_page_o,    fetch_out0_fault_fetch_o})\\n', '        ,.pop0_i(fetch_out0_accept_i)\\n', '\\n', '        ,.valid1_o(fetch_out1_valid_o)\\n', '        ,.pc1_out_o(fetch_out1_pc_o)\\n', '        ,.data1_out_o(fetch_out1_instr_o)\\n', '        ,.info1_out_o({fetch_out1_instr_invalid_o, fetch_out1_instr_exec_o,\\n', '                       fetch_out1_instr_lsu_o,     fetch_out1_instr_branch_o,\\n', '                       fetch_out1_instr_mul_o,     fetch_out1_instr_div_o,\\n', '                       fetch_out1_instr_csr_o,     fetch_out1_instr_rd_valid_o,\\n', '                       fetch_out1_fault_page_o,    fetch_out1_fault_fetch_o})\\n', '        ,.pop1_i(fetch_out1_accept_i)\\n', '    );\\n', 'end\\n', '//-----------------------------------------------------------------\\n', '// 1 cycle frontend latency\\n', '//-----------------------------------------------------------------\\n', 'else\\n', 'begin\\n', '    fetch_fifo\\n', '    #( .OPC_INFO_W(2) )\\n', '    u_fifo\\n', '    (\\n', '         .clk_i(clk_i)\\n', '        ,.rst_i(rst_i)\\n', '\\n', '        ,.flush_i(branch_request_i)\\n', '\\n', '        // Input side\\n', '        ,.push_i(fetch_in_valid_i)\\n', '        ,.pc_in_i(fetch_in_pc_i)\\n', '        ,.pred_in_i(fetch_in_pred_branch_i)\\n', \"        ,.data_in_i((fetch_in_fault_page_i | fetch_in_fault_fetch_i) ? 64'b0 : fetch_in_instr_i)\\n\", '        ,.info0_in_i({fetch_in_fault_page_i, fetch_in_fault_fetch_i})\\n', '        ,.info1_in_i({fetch_in_fault_page_i, fetch_in_fault_fetch_i})\\n', '        ,.accept_o(fetch_in_accept_o)\\n', '\\n', '        // Outputs\\n', '        ,.valid0_o(fetch_out0_valid_o)\\n', '        ,.pc0_out_o(fetch_out0_pc_o)\\n', '        ,.data0_out_o(fetch_out0_instr_o)\\n', '        ,.info0_out_o({fetch_out0_fault_page_o, fetch_out0_fault_fetch_o})\\n', '        ,.pop0_i(fetch_out0_accept_i)\\n', '\\n', '        ,.valid1_o(fetch_out1_valid_o)\\n', '        ,.pc1_out_o(fetch_out1_pc_o)\\n', '        ,.data1_out_o(fetch_out1_instr_o)\\n', '        ,.info1_out_o({fetch_out1_fault_page_o, fetch_out1_fault_fetch_o})\\n', '        ,.pop1_i(fetch_out1_accept_i)\\n', '    );\\n', '\\n', '    biriscv_decoder\\n', '    u_dec0\\n', '    (\\n', '         .valid_i(fetch_out0_valid_o)\\n', '        ,.fetch_fault_i(fetch_out0_fault_fetch_o | fetch_out0_fault_page_o)\\n', '        ,.enable_muldiv_i(enable_muldiv_w)\\n', '        ,.opcode_i(fetch_out0_instr_o)\\n', '\\n', '        ,.invalid_o(fetch_out0_instr_invalid_o)\\n', '        ,.exec_o(fetch_out0_instr_exec_o)\\n', '        ,.lsu_o(fetch_out0_instr_lsu_o)\\n', '        ,.branch_o(fetch_out0_instr_branch_o)\\n', '        ,.mul_o(fetch_out0_instr_mul_o)\\n', '        ,.div_o(fetch_out0_instr_div_o)\\n', '        ,.csr_o(fetch_out0_instr_csr_o)\\n', '        ,.rd_valid_o(fetch_out0_instr_rd_valid_o)\\n', '    );\\n', '\\n', '    biriscv_decoder\\n', '    u_dec1\\n', '    (\\n', '         .valid_i(fetch_out1_valid_o)\\n', '        ,.fetch_fault_i(fetch_out1_fault_fetch_o | fetch_out1_fault_page_o)\\n', '        ,.enable_muldiv_i(enable_muldiv_w)\\n', '        ,.opcode_i(fetch_out1_instr_o)\\n', '\\n', '        ,.invalid_o(fetch_out1_instr_invalid_o)\\n', '        ,.exec_o(fetch_out1_instr_exec_o)\\n', '        ,.lsu_o(fetch_out1_instr_lsu_o)\\n', '        ,.branch_o(fetch_out1_instr_branch_o)\\n', '        ,.mul_o(fetch_out1_instr_mul_o)\\n', '        ,.div_o(fetch_out1_instr_div_o)\\n', '        ,.csr_o(fetch_out1_instr_csr_o)\\n', '        ,.rd_valid_o(fetch_out1_instr_rd_valid_o)\\n', '    );\\n', 'end\\n', 'endgenerate\\n', '\\n', 'endmodule\\n', '\\n', 'module fetch_fifo\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '    parameter WIDTH   = 64,\\n', '    parameter DEPTH   = 2,\\n', '    parameter ADDR_W  = 1,\\n', '    parameter OPC_INFO_W = 10\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '     input                  clk_i\\n', '    ,input                  rst_i\\n', '\\n', '    ,input                  flush_i\\n', '\\n', '    // Input side\\n', '    ,input                  push_i\\n', '    ,input  [31:0]          pc_in_i\\n', '    ,input  [1:0]           pred_in_i\\n', '    ,input  [WIDTH-1:0]     data_in_i\\n', '    ,input [OPC_INFO_W-1:0] info0_in_i\\n', '    ,input [OPC_INFO_W-1:0] info1_in_i\\n', '    ,output                 accept_o\\n', '\\n', '    // Outputs\\n', '    ,output                 valid0_o\\n', '    ,output  [31:0]         pc0_out_o\\n', '    ,output [(WIDTH/2)-1:0] data0_out_o\\n', '    ,output[OPC_INFO_W-1:0] info0_out_o\\n', '    ,input                  pop0_i\\n', '\\n', '    ,output                 valid1_o\\n', '    ,output  [31:0]         pc1_out_o\\n', '    ,output [(WIDTH/2)-1:0] data1_out_o\\n', '    ,output[OPC_INFO_W-1:0] info1_out_o\\n', '    ,input                  pop1_i\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Local Params\\n', '//-----------------------------------------------------------------\\n', 'localparam COUNT_W = ADDR_W + 1;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers\\n', '//-----------------------------------------------------------------\\n', 'reg [31:0]           pc_q[DEPTH-1:0];\\n', 'reg                  valid0_q[DEPTH-1:0];\\n', 'reg                  valid1_q[DEPTH-1:0];\\n', 'reg [OPC_INFO_W-1:0] info0_q[DEPTH-1:0];\\n', 'reg [OPC_INFO_W-1:0] info1_q[DEPTH-1:0];\\n', 'reg [WIDTH-1:0]      ram_q[DEPTH-1:0];\\n', 'reg [ADDR_W-1:0]     rd_ptr_q;\\n', 'reg [ADDR_W-1:0]     wr_ptr_q;\\n', 'reg [COUNT_W-1:0]    count_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Sequential\\n', '//-----------------------------------------------------------------\\n', 'wire push_w         = (push_i & accept_o);\\n', 'wire pop1_w         = (pop0_i & valid0_o);\\n', 'wire pop2_w         = (pop1_i & valid1_o);\\n', 'wire pop_complete_w = ((pop1_w && ~valid1_o) || (pop2_w && ~valid0_o) || (pop1_w && pop2_w));\\n', '\\n', 'integer i;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    count_q   <= {(COUNT_W) {1'b0}};\\n\", \"    rd_ptr_q  <= {(ADDR_W) {1'b0}};\\n\", \"    wr_ptr_q  <= {(ADDR_W) {1'b0}};\\n\", '\\n', '    for (i = 0; i < DEPTH; i = i + 1) \\n', '    begin\\n', \"        ram_q[i]         <= {(WIDTH) {1'b0}};\\n\", \"        pc_q[i]          <= 32'b0;\\n\", \"        info0_q[i]       <= {(OPC_INFO_W) {1'b0}};\\n\", \"        info1_q[i]       <= {(OPC_INFO_W) {1'b0}};\\n\", \"        valid0_q[i]      <= 1'b0;\\n\", \"        valid1_q[i]      <= 1'b0;\\n\", '    end\\n', 'end\\n', 'else if (flush_i)\\n', 'begin\\n', \"    count_q   <= {(COUNT_W) {1'b0}};\\n\", \"    rd_ptr_q  <= {(ADDR_W) {1'b0}};\\n\", \"    wr_ptr_q  <= {(ADDR_W) {1'b0}};\\n\", '\\n', '    for (i = 0; i < DEPTH; i = i + 1) \\n', '    begin\\n', \"        info0_q[i]       <= {(OPC_INFO_W) {1'b0}};\\n\", \"        info1_q[i]       <= {(OPC_INFO_W) {1'b0}};\\n\", \"        //valid0_q[i]      <= 1'b0; // TODO:...\\n\", \"        //valid1_q[i]      <= 1'b0; // TODO:...\\n\", '    end\\n', 'end\\n', 'else\\n', 'begin\\n', '    // Push\\n', '    if (push_w)\\n', '    begin\\n', '        ram_q[wr_ptr_q]     <= data_in_i;\\n', '        pc_q[wr_ptr_q]      <= pc_in_i;\\n', '        info0_q[wr_ptr_q]   <= info0_in_i;\\n', '        info1_q[wr_ptr_q]   <= info1_in_i;\\n', \"        valid0_q[wr_ptr_q]  <= 1'b1;\\n\", '        valid1_q[wr_ptr_q]  <= ~pred_in_i[0];\\n', '        wr_ptr_q            <= wr_ptr_q + 1;\\n', '    end\\n', '\\n', '    if (pop1_w)\\n', \"        valid0_q[rd_ptr_q] <= 1'b0;\\n\", '    if (pop2_w)\\n', \"        valid1_q[rd_ptr_q] <= 1'b0;\\n\", '\\n', '    // Both instructions completed\\n', '    if (pop_complete_w)\\n', '        rd_ptr_q  <= rd_ptr_q + 1;\\n', '\\n', '    if (push_w & ~pop_complete_w)\\n', '        count_q <= count_q + 1;\\n', '    else if (~push_w & pop_complete_w)\\n', '        count_q <= count_q - 1;\\n', 'end\\n', '\\n', '//-------------------------------------------------------------------\\n', '// Combinatorial\\n', '//-------------------------------------------------------------------\\n', '/* verilator lint_off WIDTH */\\n', 'assign valid0_o      = (count_q != 0) & valid0_q[rd_ptr_q];\\n', 'assign valid1_o      = (count_q != 0) & valid1_q[rd_ptr_q];\\n', 'assign accept_o      = (count_q != DEPTH);\\n', '/* verilator lint_on WIDTH */\\n', '\\n', \"assign pc0_out_o     = {pc_q[rd_ptr_q][31:3],3'b000};\\n\", \"assign pc1_out_o     = {pc_q[rd_ptr_q][31:3],3'b100};\\n\", 'assign data0_out_o   = ram_q[rd_ptr_q][(WIDTH/2)-1:0];\\n', 'assign data1_out_o   = ram_q[rd_ptr_q][WIDTH-1:(WIDTH/2)];\\n', '\\n', 'assign info0_out_o   = info0_q[rd_ptr_q];\\n', 'assign info1_out_o   = info1_q[rd_ptr_q];\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '`include \"biriscv_defs.v\"\\n', '\\n', 'module biriscv_decoder\\n', '(\\n', '     input                        valid_i\\n', '    ,input                        fetch_fault_i\\n', '    ,input                        enable_muldiv_i\\n', '    ,input  [31:0]                opcode_i\\n', '\\n', '    ,output                       invalid_o\\n', '    ,output                       exec_o\\n', '    ,output                       lsu_o\\n', '    ,output                       branch_o\\n', '    ,output                       mul_o\\n', '    ,output                       div_o\\n', '    ,output                       csr_o\\n', '    ,output                       rd_valid_o\\n', ');\\n', '\\n', '// Invalid instruction\\n', 'wire invalid_w =    valid_i && \\n', '                   ~(((opcode_i & `INST_ANDI_MASK) == `INST_ANDI)             ||\\n', '                    ((opcode_i & `INST_ADDI_MASK) == `INST_ADDI)              ||\\n', '                    ((opcode_i & `INST_SLTI_MASK) == `INST_SLTI)              ||\\n', '                    ((opcode_i & `INST_SLTIU_MASK) == `INST_SLTIU)            ||\\n', '                    ((opcode_i & `INST_ORI_MASK) == `INST_ORI)                ||\\n', '                    ((opcode_i & `INST_XORI_MASK) == `INST_XORI)              ||\\n', '                    ((opcode_i & `INST_SLLI_MASK) == `INST_SLLI)              ||\\n', '                    ((opcode_i & `INST_SRLI_MASK) == `INST_SRLI)              ||\\n', '                    ((opcode_i & `INST_SRAI_MASK) == `INST_SRAI)              ||\\n', '                    ((opcode_i & `INST_LUI_MASK) == `INST_LUI)                ||\\n', '                    ((opcode_i & `INST_AUIPC_MASK) == `INST_AUIPC)            ||\\n', '                    ((opcode_i & `INST_ADD_MASK) == `INST_ADD)                ||\\n', '                    ((opcode_i & `INST_SUB_MASK) == `INST_SUB)                ||\\n', '                    ((opcode_i & `INST_SLT_MASK) == `INST_SLT)                ||\\n', '                    ((opcode_i & `INST_SLTU_MASK) == `INST_SLTU)              ||\\n', '                    ((opcode_i & `INST_XOR_MASK) == `INST_XOR)                ||\\n', '                    ((opcode_i & `INST_OR_MASK) == `INST_OR)                  ||\\n', '                    ((opcode_i & `INST_AND_MASK) == `INST_AND)                ||\\n', '                    ((opcode_i & `INST_SLL_MASK) == `INST_SLL)                ||\\n', '                    ((opcode_i & `INST_SRL_MASK) == `INST_SRL)                ||\\n', '                    ((opcode_i & `INST_SRA_MASK) == `INST_SRA)                ||\\n', '                    ((opcode_i & `INST_JAL_MASK) == `INST_JAL)                ||\\n', '                    ((opcode_i & `INST_JALR_MASK) == `INST_JALR)              ||\\n', '                    ((opcode_i & `INST_BEQ_MASK) == `INST_BEQ)                ||\\n', '                    ((opcode_i & `INST_BNE_MASK) == `INST_BNE)                ||\\n', '                    ((opcode_i & `INST_BLT_MASK) == `INST_BLT)                ||\\n', '                    ((opcode_i & `INST_BGE_MASK) == `INST_BGE)                ||\\n', '                    ((opcode_i & `INST_BLTU_MASK) == `INST_BLTU)              ||\\n', '                    ((opcode_i & `INST_BGEU_MASK) == `INST_BGEU)              ||\\n', '                    ((opcode_i & `INST_LB_MASK) == `INST_LB)                  ||\\n', '                    ((opcode_i & `INST_LH_MASK) == `INST_LH)                  ||\\n', '                    ((opcode_i & `INST_LW_MASK) == `INST_LW)                  ||\\n', '                    ((opcode_i & `INST_LBU_MASK) == `INST_LBU)                ||\\n', '                    ((opcode_i & `INST_LHU_MASK) == `INST_LHU)                ||\\n', '                    ((opcode_i & `INST_LWU_MASK) == `INST_LWU)                ||\\n', '                    ((opcode_i & `INST_SB_MASK) == `INST_SB)                  ||\\n', '                    ((opcode_i & `INST_SH_MASK) == `INST_SH)                  ||\\n', '                    ((opcode_i & `INST_SW_MASK) == `INST_SW)                  ||\\n', '                    ((opcode_i & `INST_ECALL_MASK) == `INST_ECALL)            ||\\n', '                    ((opcode_i & `INST_EBREAK_MASK) == `INST_EBREAK)          ||\\n', '                    ((opcode_i & `INST_ERET_MASK) == `INST_ERET)              ||\\n', '                    ((opcode_i & `INST_CSRRW_MASK) == `INST_CSRRW)            ||\\n', '                    ((opcode_i & `INST_CSRRS_MASK) == `INST_CSRRS)            ||\\n', '                    ((opcode_i & `INST_CSRRC_MASK) == `INST_CSRRC)            ||\\n', '                    ((opcode_i & `INST_CSRRWI_MASK) == `INST_CSRRWI)          ||\\n', '                    ((opcode_i & `INST_CSRRSI_MASK) == `INST_CSRRSI)          ||\\n', '                    ((opcode_i & `INST_CSRRCI_MASK) == `INST_CSRRCI)          ||\\n', '                    ((opcode_i & `INST_WFI_MASK) == `INST_WFI)                ||\\n', '                    ((opcode_i & `INST_FENCE_MASK) == `INST_FENCE)            ||\\n', '                    ((opcode_i & `INST_IFENCE_MASK) == `INST_IFENCE)          ||\\n', '                    ((opcode_i & `INST_SFENCE_MASK) == `INST_SFENCE)          ||\\n', '                    (enable_muldiv_i && (opcode_i & `INST_MUL_MASK) == `INST_MUL)       ||\\n', '                    (enable_muldiv_i && (opcode_i & `INST_MULH_MASK) == `INST_MULH)     ||\\n', '                    (enable_muldiv_i && (opcode_i & `INST_MULHSU_MASK) == `INST_MULHSU) ||\\n', '                    (enable_muldiv_i && (opcode_i & `INST_MULHU_MASK) == `INST_MULHU)   ||\\n', '                    (enable_muldiv_i && (opcode_i & `INST_DIV_MASK) == `INST_DIV)       ||\\n', '                    (enable_muldiv_i && (opcode_i & `INST_DIVU_MASK) == `INST_DIVU)     ||\\n', '                    (enable_muldiv_i && (opcode_i & `INST_REM_MASK) == `INST_REM)       ||\\n', '                    (enable_muldiv_i && (opcode_i & `INST_REMU_MASK) == `INST_REMU));\\n', '\\n', 'assign invalid_o = invalid_w;\\n', '\\n', 'assign rd_valid_o = ((opcode_i & `INST_JALR_MASK) == `INST_JALR)     ||\\n', '                    ((opcode_i & `INST_JAL_MASK) == `INST_JAL)       ||\\n', '                    ((opcode_i & `INST_LUI_MASK) == `INST_LUI)       ||\\n', '                    ((opcode_i & `INST_AUIPC_MASK) == `INST_AUIPC)   ||\\n', '                    ((opcode_i & `INST_ADDI_MASK) == `INST_ADDI)     ||\\n', '                    ((opcode_i & `INST_SLLI_MASK) == `INST_SLLI)     ||\\n', '                    ((opcode_i & `INST_SLTI_MASK) == `INST_SLTI)     ||\\n', '                    ((opcode_i & `INST_SLTIU_MASK) == `INST_SLTIU)   ||\\n', '                    ((opcode_i & `INST_XORI_MASK) == `INST_XORI)     ||\\n', '                    ((opcode_i & `INST_SRLI_MASK) == `INST_SRLI)     ||\\n', '                    ((opcode_i & `INST_SRAI_MASK) == `INST_SRAI)     ||\\n', '                    ((opcode_i & `INST_ORI_MASK) == `INST_ORI)       ||\\n', '                    ((opcode_i & `INST_ANDI_MASK) == `INST_ANDI)     ||\\n', '                    ((opcode_i & `INST_ADD_MASK) == `INST_ADD)       ||\\n', '                    ((opcode_i & `INST_SUB_MASK) == `INST_SUB)       ||\\n', '                    ((opcode_i & `INST_SLL_MASK) == `INST_SLL)       ||\\n', '                    ((opcode_i & `INST_SLT_MASK) == `INST_SLT)       ||\\n', '                    ((opcode_i & `INST_SLTU_MASK) == `INST_SLTU)     ||\\n', '                    ((opcode_i & `INST_XOR_MASK) == `INST_XOR)       ||\\n', '                    ((opcode_i & `INST_SRL_MASK) == `INST_SRL)       ||\\n', '                    ((opcode_i & `INST_SRA_MASK) == `INST_SRA)       ||\\n', '                    ((opcode_i & `INST_OR_MASK) == `INST_OR)         ||\\n', '                    ((opcode_i & `INST_AND_MASK) == `INST_AND)       ||\\n', '                    ((opcode_i & `INST_LB_MASK) == `INST_LB)         ||\\n', '                    ((opcode_i & `INST_LH_MASK) == `INST_LH)         ||\\n', '                    ((opcode_i & `INST_LW_MASK) == `INST_LW)         ||\\n', '                    ((opcode_i & `INST_LBU_MASK) == `INST_LBU)       ||\\n', '                    ((opcode_i & `INST_LHU_MASK) == `INST_LHU)       ||\\n', '                    ((opcode_i & `INST_LWU_MASK) == `INST_LWU)       ||\\n', '                    ((opcode_i & `INST_MUL_MASK) == `INST_MUL)       ||\\n', '                    ((opcode_i & `INST_MULH_MASK) == `INST_MULH)     ||\\n', '                    ((opcode_i & `INST_MULHSU_MASK) == `INST_MULHSU) ||\\n', '                    ((opcode_i & `INST_MULHU_MASK) == `INST_MULHU)   ||\\n', '                    ((opcode_i & `INST_DIV_MASK) == `INST_DIV)       ||\\n', '                    ((opcode_i & `INST_DIVU_MASK) == `INST_DIVU)     ||\\n', '                    ((opcode_i & `INST_REM_MASK) == `INST_REM)       ||\\n', '                    ((opcode_i & `INST_REMU_MASK) == `INST_REMU)     ||\\n', '                    ((opcode_i & `INST_CSRRW_MASK) == `INST_CSRRW)   ||\\n', '                    ((opcode_i & `INST_CSRRS_MASK) == `INST_CSRRS)   ||\\n', '                    ((opcode_i & `INST_CSRRC_MASK) == `INST_CSRRC)   ||\\n', '                    ((opcode_i & `INST_CSRRWI_MASK) == `INST_CSRRWI) ||\\n', '                    ((opcode_i & `INST_CSRRSI_MASK) == `INST_CSRRSI) ||\\n', '                    ((opcode_i & `INST_CSRRCI_MASK) == `INST_CSRRCI);\\n', '\\n', 'assign exec_o =     ((opcode_i & `INST_ANDI_MASK) == `INST_ANDI)  ||\\n', '                    ((opcode_i & `INST_ADDI_MASK) == `INST_ADDI)  ||\\n', '                    ((opcode_i & `INST_SLTI_MASK) == `INST_SLTI)  ||\\n', '                    ((opcode_i & `INST_SLTIU_MASK) == `INST_SLTIU)||\\n', '                    ((opcode_i & `INST_ORI_MASK) == `INST_ORI)    ||\\n', '                    ((opcode_i & `INST_XORI_MASK) == `INST_XORI)  ||\\n', '                    ((opcode_i & `INST_SLLI_MASK) == `INST_SLLI)  ||\\n', '                    ((opcode_i & `INST_SRLI_MASK) == `INST_SRLI)  ||\\n', '                    ((opcode_i & `INST_SRAI_MASK) == `INST_SRAI)  ||\\n', '                    ((opcode_i & `INST_LUI_MASK) == `INST_LUI)    ||\\n', '                    ((opcode_i & `INST_AUIPC_MASK) == `INST_AUIPC)||\\n', '                    ((opcode_i & `INST_ADD_MASK) == `INST_ADD)    ||\\n', '                    ((opcode_i & `INST_SUB_MASK) == `INST_SUB)    ||\\n', '                    ((opcode_i & `INST_SLT_MASK) == `INST_SLT)    ||\\n', '                    ((opcode_i & `INST_SLTU_MASK) == `INST_SLTU)  ||\\n', '                    ((opcode_i & `INST_XOR_MASK) == `INST_XOR)    ||\\n', '                    ((opcode_i & `INST_OR_MASK) == `INST_OR)      ||\\n', '                    ((opcode_i & `INST_AND_MASK) == `INST_AND)    ||\\n', '                    ((opcode_i & `INST_SLL_MASK) == `INST_SLL)    ||\\n', '                    ((opcode_i & `INST_SRL_MASK) == `INST_SRL)    ||\\n', '                    ((opcode_i & `INST_SRA_MASK) == `INST_SRA);\\n', '\\n', 'assign lsu_o =      ((opcode_i & `INST_LB_MASK) == `INST_LB)   ||\\n', '                    ((opcode_i & `INST_LH_MASK) == `INST_LH)   ||\\n', '                    ((opcode_i & `INST_LW_MASK) == `INST_LW)   ||\\n', '                    ((opcode_i & `INST_LBU_MASK) == `INST_LBU) ||\\n', '                    ((opcode_i & `INST_LHU_MASK) == `INST_LHU) ||\\n', '                    ((opcode_i & `INST_LWU_MASK) == `INST_LWU) ||\\n', '                    ((opcode_i & `INST_SB_MASK) == `INST_SB)   ||\\n', '                    ((opcode_i & `INST_SH_MASK) == `INST_SH)   ||\\n', '                    ((opcode_i & `INST_SW_MASK) == `INST_SW);\\n', '\\n', 'assign branch_o =   ((opcode_i & `INST_JAL_MASK) == `INST_JAL)   ||\\n', '                    ((opcode_i & `INST_JALR_MASK) == `INST_JALR) ||\\n', '                    ((opcode_i & `INST_BEQ_MASK) == `INST_BEQ)   ||\\n', '                    ((opcode_i & `INST_BNE_MASK) == `INST_BNE)   ||\\n', '                    ((opcode_i & `INST_BLT_MASK) == `INST_BLT)   ||\\n', '                    ((opcode_i & `INST_BGE_MASK) == `INST_BGE)   ||\\n', '                    ((opcode_i & `INST_BLTU_MASK) == `INST_BLTU) ||\\n', '                    ((opcode_i & `INST_BGEU_MASK) == `INST_BGEU);\\n', '\\n', 'assign mul_o =      enable_muldiv_i &&\\n', '                    (((opcode_i & `INST_MUL_MASK) == `INST_MUL)    ||\\n', '                    ((opcode_i & `INST_MULH_MASK) == `INST_MULH)   ||\\n', '                    ((opcode_i & `INST_MULHSU_MASK) == `INST_MULHSU) ||\\n', '                    ((opcode_i & `INST_MULHU_MASK) == `INST_MULHU));\\n', '\\n', 'assign div_o =      enable_muldiv_i &&\\n', '                    (((opcode_i & `INST_DIV_MASK) == `INST_DIV) ||\\n', '                    ((opcode_i & `INST_DIVU_MASK) == `INST_DIVU) ||\\n', '                    ((opcode_i & `INST_REM_MASK) == `INST_REM) ||\\n', '                    ((opcode_i & `INST_REMU_MASK) == `INST_REMU));\\n', '\\n', 'assign csr_o =      ((opcode_i & `INST_ECALL_MASK) == `INST_ECALL)            ||\\n', '                    ((opcode_i & `INST_EBREAK_MASK) == `INST_EBREAK)          ||\\n', '                    ((opcode_i & `INST_ERET_MASK) == `INST_ERET)              ||\\n', '                    ((opcode_i & `INST_CSRRW_MASK) == `INST_CSRRW)            ||\\n', '                    ((opcode_i & `INST_CSRRS_MASK) == `INST_CSRRS)            ||\\n', '                    ((opcode_i & `INST_CSRRC_MASK) == `INST_CSRRC)            ||\\n', '                    ((opcode_i & `INST_CSRRWI_MASK) == `INST_CSRRWI)          ||\\n', '                    ((opcode_i & `INST_CSRRSI_MASK) == `INST_CSRRSI)          ||\\n', '                    ((opcode_i & `INST_CSRRCI_MASK) == `INST_CSRRCI)          ||\\n', '                    ((opcode_i & `INST_WFI_MASK) == `INST_WFI)                ||\\n', '                    ((opcode_i & `INST_FENCE_MASK) == `INST_FENCE)            ||\\n', '                    ((opcode_i & `INST_IFENCE_MASK) == `INST_IFENCE)          ||\\n', '                    ((opcode_i & `INST_SFENCE_MASK) == `INST_SFENCE)          ||\\n', '                    invalid_w || fetch_fault_i;\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '//--------------------------------------------------------------------\\n', '// ALU Operations\\n', '//--------------------------------------------------------------------\\n', \"`define ALU_NONE                                4'b0000\\n\", \"`define ALU_SHIFTL                              4'b0001\\n\", \"`define ALU_SHIFTR                              4'b0010\\n\", \"`define ALU_SHIFTR_ARITH                        4'b0011\\n\", \"`define ALU_ADD                                 4'b0100\\n\", \"`define ALU_SUB                                 4'b0110\\n\", \"`define ALU_AND                                 4'b0111\\n\", \"`define ALU_OR                                  4'b1000\\n\", \"`define ALU_XOR                                 4'b1001\\n\", \"`define ALU_LESS_THAN                           4'b1010\\n\", \"`define ALU_LESS_THAN_SIGNED                    4'b1011\\n\", '\\n', '//--------------------------------------------------------------------\\n', '// Instructions Masks\\n', '//--------------------------------------------------------------------\\n', '// andi\\n', \"`define INST_ANDI 32'h7013\\n\", \"`define INST_ANDI_MASK 32'h707f\\n\", '\\n', '// addi\\n', \"`define INST_ADDI 32'h13\\n\", \"`define INST_ADDI_MASK 32'h707f\\n\", '\\n', '// slti\\n', \"`define INST_SLTI 32'h2013\\n\", \"`define INST_SLTI_MASK 32'h707f\\n\", '\\n', '// sltiu\\n', \"`define INST_SLTIU 32'h3013\\n\", \"`define INST_SLTIU_MASK 32'h707f\\n\", '\\n', '// ori\\n', \"`define INST_ORI 32'h6013\\n\", \"`define INST_ORI_MASK 32'h707f\\n\", '\\n', '// xori\\n', \"`define INST_XORI 32'h4013\\n\", \"`define INST_XORI_MASK 32'h707f\\n\", '\\n', '// slli\\n', \"`define INST_SLLI 32'h1013\\n\", \"`define INST_SLLI_MASK 32'hfc00707f\\n\", '\\n', '// srli\\n', \"`define INST_SRLI 32'h5013\\n\", \"`define INST_SRLI_MASK 32'hfc00707f\\n\", '\\n', '// srai\\n', \"`define INST_SRAI 32'h40005013\\n\", \"`define INST_SRAI_MASK 32'hfc00707f\\n\", '\\n', '// lui\\n', \"`define INST_LUI 32'h37\\n\", \"`define INST_LUI_MASK 32'h7f\\n\", '\\n', '// auipc\\n', \"`define INST_AUIPC 32'h17\\n\", \"`define INST_AUIPC_MASK 32'h7f\\n\", '\\n', '// add\\n', \"`define INST_ADD 32'h33\\n\", \"`define INST_ADD_MASK 32'hfe00707f\\n\", '\\n', '// sub\\n', \"`define INST_SUB 32'h40000033\\n\", \"`define INST_SUB_MASK 32'hfe00707f\\n\", '\\n', '// slt\\n', \"`define INST_SLT 32'h2033\\n\", \"`define INST_SLT_MASK 32'hfe00707f\\n\", '\\n', '// sltu\\n', \"`define INST_SLTU 32'h3033\\n\", \"`define INST_SLTU_MASK 32'hfe00707f\\n\", '\\n', '// xor\\n', \"`define INST_XOR 32'h4033\\n\", \"`define INST_XOR_MASK 32'hfe00707f\\n\", '\\n', '// or\\n', \"`define INST_OR 32'h6033\\n\", \"`define INST_OR_MASK 32'hfe00707f\\n\", '\\n', '// and\\n', \"`define INST_AND 32'h7033\\n\", \"`define INST_AND_MASK 32'hfe00707f\\n\", '\\n', '// sll\\n', \"`define INST_SLL 32'h1033\\n\", \"`define INST_SLL_MASK 32'hfe00707f\\n\", '\\n', '// srl\\n', \"`define INST_SRL 32'h5033\\n\", \"`define INST_SRL_MASK 32'hfe00707f\\n\", '\\n', '// sra\\n', \"`define INST_SRA 32'h40005033\\n\", \"`define INST_SRA_MASK 32'hfe00707f\\n\", '\\n', '// jal\\n', \"`define INST_JAL 32'h6f\\n\", \"`define INST_JAL_MASK 32'h7f\\n\", '\\n', '// jalr\\n', \"`define INST_JALR 32'h67\\n\", \"`define INST_JALR_MASK 32'h707f\\n\", '\\n', '// beq\\n', \"`define INST_BEQ 32'h63\\n\", \"`define INST_BEQ_MASK 32'h707f\\n\", '\\n', '// bne\\n', \"`define INST_BNE 32'h1063\\n\", \"`define INST_BNE_MASK 32'h707f\\n\", '\\n', '// blt\\n', \"`define INST_BLT 32'h4063\\n\", \"`define INST_BLT_MASK 32'h707f\\n\", '\\n', '// bge\\n', \"`define INST_BGE 32'h5063\\n\", \"`define INST_BGE_MASK 32'h707f\\n\", '\\n', '// bltu\\n', \"`define INST_BLTU 32'h6063\\n\", \"`define INST_BLTU_MASK 32'h707f\\n\", '\\n', '// bgeu\\n', \"`define INST_BGEU 32'h7063\\n\", \"`define INST_BGEU_MASK 32'h707f\\n\", '\\n', '// lb\\n', \"`define INST_LB 32'h3\\n\", \"`define INST_LB_MASK 32'h707f\\n\", '\\n', '// lh\\n', \"`define INST_LH 32'h1003\\n\", \"`define INST_LH_MASK 32'h707f\\n\", '\\n', '// lw\\n', \"`define INST_LW 32'h2003\\n\", \"`define INST_LW_MASK 32'h707f\\n\", '\\n', '// lbu\\n', \"`define INST_LBU 32'h4003\\n\", \"`define INST_LBU_MASK 32'h707f\\n\", '\\n', '// lhu\\n', \"`define INST_LHU 32'h5003\\n\", \"`define INST_LHU_MASK 32'h707f\\n\", '\\n', '// lwu\\n', \"`define INST_LWU 32'h6003\\n\", \"`define INST_LWU_MASK 32'h707f\\n\", '\\n', '// sb\\n', \"`define INST_SB 32'h23\\n\", \"`define INST_SB_MASK 32'h707f\\n\", '\\n', '// sh\\n', \"`define INST_SH 32'h1023\\n\", \"`define INST_SH_MASK 32'h707f\\n\", '\\n', '// sw\\n', \"`define INST_SW 32'h2023\\n\", \"`define INST_SW_MASK 32'h707f\\n\", '\\n', '// ecall\\n', \"`define INST_ECALL 32'h73\\n\", \"`define INST_ECALL_MASK 32'hffffffff\\n\", '\\n', '// ebreak\\n', \"`define INST_EBREAK 32'h100073\\n\", \"`define INST_EBREAK_MASK 32'hffffffff\\n\", '\\n', '// eret\\n', \"`define INST_ERET 32'h200073\\n\", \"`define INST_ERET_MASK 32'hcfffffff\\n\", '\\n', '// csrrw\\n', \"`define INST_CSRRW 32'h1073\\n\", \"`define INST_CSRRW_MASK 32'h707f\\n\", '\\n', '// csrrs\\n', \"`define INST_CSRRS 32'h2073\\n\", \"`define INST_CSRRS_MASK 32'h707f\\n\", '\\n', '// csrrc\\n', \"`define INST_CSRRC 32'h3073\\n\", \"`define INST_CSRRC_MASK 32'h707f\\n\", '\\n', '// csrrwi\\n', \"`define INST_CSRRWI 32'h5073\\n\", \"`define INST_CSRRWI_MASK 32'h707f\\n\", '\\n', '// csrrsi\\n', \"`define INST_CSRRSI 32'h6073\\n\", \"`define INST_CSRRSI_MASK 32'h707f\\n\", '\\n', '// csrrci\\n', \"`define INST_CSRRCI 32'h7073\\n\", \"`define INST_CSRRCI_MASK 32'h707f\\n\", '\\n', '// mul\\n', \"`define INST_MUL 32'h2000033\\n\", \"`define INST_MUL_MASK 32'hfe00707f\\n\", '\\n', '// mulh\\n', \"`define INST_MULH 32'h2001033\\n\", \"`define INST_MULH_MASK 32'hfe00707f\\n\", '\\n', '// mulhsu\\n', \"`define INST_MULHSU 32'h2002033\\n\", \"`define INST_MULHSU_MASK 32'hfe00707f\\n\", '\\n', '// mulhu\\n', \"`define INST_MULHU 32'h2003033\\n\", \"`define INST_MULHU_MASK 32'hfe00707f\\n\", '\\n', '// div\\n', \"`define INST_DIV 32'h2004033\\n\", \"`define INST_DIV_MASK 32'hfe00707f\\n\", '\\n', '// divu\\n', \"`define INST_DIVU 32'h2005033\\n\", \"`define INST_DIVU_MASK 32'hfe00707f\\n\", '\\n', '// rem\\n', \"`define INST_REM 32'h2006033\\n\", \"`define INST_REM_MASK 32'hfe00707f\\n\", '\\n', '// remu\\n', \"`define INST_REMU 32'h2007033\\n\", \"`define INST_REMU_MASK 32'hfe00707f\\n\", '\\n', '// wfi\\n', \"`define INST_WFI 32'h10500073\\n\", \"`define INST_WFI_MASK 32'hffff8fff\\n\", '\\n', '// fence\\n', \"`define INST_FENCE 32'hf\\n\", \"`define INST_FENCE_MASK 32'h707f\\n\", '\\n', '// sfence\\n', \"`define INST_SFENCE 32'h12000073\\n\", \"`define INST_SFENCE_MASK 32'hfe007fff\\n\", '\\n', '// fence.i\\n', \"`define INST_IFENCE 32'h100f\\n\", \"`define INST_IFENCE_MASK 32'h707f\\n\", '\\n', '//--------------------------------------------------------------------\\n', '// Privilege levels\\n', '//--------------------------------------------------------------------\\n', \"`define PRIV_USER         2'd0\\n\", \"`define PRIV_SUPER        2'd1\\n\", \"`define PRIV_MACHINE      2'd3\\n\", '\\n', '//--------------------------------------------------------------------\\n', '// IRQ Numbers\\n', '//--------------------------------------------------------------------\\n', '`define IRQ_S_SOFT   1\\n', '`define IRQ_M_SOFT   3\\n', '`define IRQ_S_TIMER  5\\n', '`define IRQ_M_TIMER  7\\n', '`define IRQ_S_EXT    9\\n', '`define IRQ_M_EXT    11\\n', '`define IRQ_MIN      (`IRQ_S_SOFT)\\n', '`define IRQ_MAX      (`IRQ_M_EXT + 1)\\n', '`define IRQ_MASK     ((1 << `IRQ_M_EXT)   | (1 << `IRQ_S_EXT)   |                       (1 << `IRQ_M_TIMER) | (1 << `IRQ_S_TIMER) |                       (1 << `IRQ_M_SOFT)  | (1 << `IRQ_S_SOFT))\\n', '\\n', '`define SR_IP_MSIP_R      `IRQ_M_SOFT\\n', '`define SR_IP_MTIP_R      `IRQ_M_TIMER\\n', '`define SR_IP_MEIP_R      `IRQ_M_EXT\\n', '`define SR_IP_SSIP_R      `IRQ_S_SOFT\\n', '`define SR_IP_STIP_R      `IRQ_S_TIMER\\n', '`define SR_IP_SEIP_R      `IRQ_S_EXT\\n', '\\n', '//--------------------------------------------------------------------\\n', '// CSR Registers - Simulation control\\n', '//--------------------------------------------------------------------\\n', \"`define CSR_DSCRATCH       12'h7b2\\n\", \"`define CSR_SIM_CTRL       12'h8b2\\n\", \"`define CSR_SIM_CTRL_MASK  32'hFFFFFFFF\\n\", '    `define CSR_SIM_CTRL_EXIT (0 << 24)\\n', '    `define CSR_SIM_CTRL_PUTC (1 << 24)\\n', '\\n', '//--------------------------------------------------------------------\\n', '// CSR Registers\\n', '//--------------------------------------------------------------------\\n', \"`define CSR_MSTATUS       12'h300\\n\", \"`define CSR_MSTATUS_MASK  32'hFFFFFFFF\\n\", \"`define CSR_MISA          12'h301\\n\", \"`define CSR_MISA_MASK     32'hFFFFFFFF\\n\", \"    `define MISA_RV32     32'h40000000\\n\", \"    `define MISA_RVI      32'h00000100\\n\", \"    `define MISA_RVE      32'h00000010\\n\", \"    `define MISA_RVM      32'h00001000\\n\", \"    `define MISA_RVA      32'h00000001\\n\", \"    `define MISA_RVF      32'h00000020\\n\", \"    `define MISA_RVD      32'h00000008\\n\", \"    `define MISA_RVC      32'h00000004\\n\", \"    `define MISA_RVS      32'h00040000\\n\", \"    `define MISA_RVU      32'h00100000\\n\", \"`define CSR_MEDELEG       12'h302\\n\", \"`define CSR_MEDELEG_MASK  32'h0000FFFF\\n\", \"`define CSR_MIDELEG       12'h303\\n\", \"`define CSR_MIDELEG_MASK  32'h0000FFFF\\n\", \"`define CSR_MIE           12'h304\\n\", '`define CSR_MIE_MASK      `IRQ_MASK\\n', \"`define CSR_MTVEC         12'h305\\n\", \"`define CSR_MTVEC_MASK    32'hFFFFFFFF\\n\", \"`define CSR_MSCRATCH      12'h340\\n\", \"`define CSR_MSCRATCH_MASK 32'hFFFFFFFF\\n\", \"`define CSR_MEPC          12'h341\\n\", \"`define CSR_MEPC_MASK     32'hFFFFFFFF\\n\", \"`define CSR_MCAUSE        12'h342\\n\", \"`define CSR_MCAUSE_MASK   32'h8000000F\\n\", \"`define CSR_MTVAL         12'h343\\n\", \"`define CSR_MTVAL_MASK    32'hFFFFFFFF\\n\", \"`define CSR_MIP           12'h344\\n\", '`define CSR_MIP_MASK      `IRQ_MASK\\n', \"`define CSR_MCYCLE        12'hc00\\n\", \"`define CSR_MCYCLE_MASK   32'hFFFFFFFF\\n\", \"`define CSR_MTIME         12'hc01\\n\", \"`define CSR_MTIME_MASK    32'hFFFFFFFF\\n\", \"`define CSR_MTIMEH        12'hc81\\n\", \"`define CSR_MTIMEH_MASK   32'hFFFFFFFF\\n\", \"`define CSR_MHARTID       12'hF14\\n\", \"`define CSR_MHARTID_MASK  32'hFFFFFFFF\\n\", '\\n', '// Non-std\\n', \"`define CSR_MTIMECMP        12'h7c0\\n\", \"`define CSR_MTIMECMP_MASK   32'hFFFFFFFF\\n\", '\\n', '//-----------------------------------------------------------------\\n', '// CSR Registers - Supervisor\\n', '//-----------------------------------------------------------------\\n', \"`define CSR_SSTATUS       12'h100\\n\", '`define CSR_SSTATUS_MASK  `SR_SMODE_MASK\\n', \"`define CSR_SIE           12'h104\\n\", '`define CSR_SIE_MASK      ((1 << `IRQ_S_EXT) | (1 << `IRQ_S_TIMER) | (1 << `IRQ_S_SOFT))\\n', \"`define CSR_STVEC         12'h105\\n\", \"`define CSR_STVEC_MASK    32'hFFFFFFFF\\n\", \"`define CSR_SSCRATCH      12'h140\\n\", \"`define CSR_SSCRATCH_MASK 32'hFFFFFFFF\\n\", \"`define CSR_SEPC          12'h141\\n\", \"`define CSR_SEPC_MASK     32'hFFFFFFFF\\n\", \"`define CSR_SCAUSE        12'h142\\n\", \"`define CSR_SCAUSE_MASK   32'h8000000F\\n\", \"`define CSR_STVAL         12'h143\\n\", \"`define CSR_STVAL_MASK    32'hFFFFFFFF\\n\", \"`define CSR_SIP           12'h144\\n\", '`define CSR_SIP_MASK      ((1 << `IRQ_S_EXT) | (1 << `IRQ_S_TIMER) | (1 << `IRQ_S_SOFT))\\n', \"`define CSR_SATP          12'h180\\n\", \"`define CSR_SATP_MASK     32'hFFFFFFFF\\n\", '\\n', '//--------------------------------------------------------------------\\n', '// CSR Registers - DCACHE control\\n', '//--------------------------------------------------------------------\\n', \"`define CSR_DFLUSH            12'h3a0 // pmpcfg0\\n\", \"`define CSR_DFLUSH_MASK       32'hFFFFFFFF\\n\", \"`define CSR_DWRITEBACK        12'h3a1 // pmpcfg1\\n\", \"`define CSR_DWRITEBACK_MASK   32'hFFFFFFFF\\n\", \"`define CSR_DINVALIDATE       12'h3a2 // pmpcfg2\\n\", \"`define CSR_DINVALIDATE_MASK  32'hFFFFFFFF\\n\", '\\n', '//--------------------------------------------------------------------\\n', '// Status Register\\n', '//--------------------------------------------------------------------\\n', '`define SR_UIE         (1 << 0)\\n', '`define SR_UIE_R       0\\n', '`define SR_SIE         (1 << 1)\\n', '`define SR_SIE_R       1\\n', '`define SR_MIE         (1 << 3)\\n', '`define SR_MIE_R       3\\n', '`define SR_UPIE        (1 << 4)\\n', '`define SR_UPIE_R      4\\n', '`define SR_SPIE        (1 << 5)\\n', '`define SR_SPIE_R      5\\n', '`define SR_MPIE        (1 << 7)\\n', '`define SR_MPIE_R      7\\n', '`define SR_SPP         (1 << 8)\\n', '`define SR_SPP_R       8\\n', '\\n', '`define SR_MPP_SHIFT   11\\n', \"`define SR_MPP_MASK    2'h3\\n\", '`define SR_MPP_R       12:11\\n', '`define SR_MPP_U       `PRIV_USER\\n', '`define SR_MPP_S       `PRIV_SUPER\\n', '`define SR_MPP_M       `PRIV_MACHINE\\n', '\\n', '`define SR_SUM_R        18\\n', '`define SR_SUM          (1 << `SR_SUM_R)\\n', '\\n', '`define SR_MPRV_R       17\\n', '`define SR_MPRV         (1 << `SR_MPRV_R)\\n', '\\n', '`define SR_MXR_R        19\\n', '`define SR_MXR          (1 << `SR_MXR_R)\\n', '\\n', '`define SR_SMODE_MASK   (`SR_UIE | `SR_SIE | `SR_UPIE | `SR_SPIE | `SR_SPP | `SR_SUM)\\n', '\\n', '//--------------------------------------------------------------------\\n', '// SATP definitions\\n', '//--------------------------------------------------------------------\\n', '`define SATP_PPN_R        19:0 // TODO: Should be 21??\\n', '`define SATP_ASID_R       30:22\\n', '`define SATP_MODE_R       31\\n', '\\n', '//--------------------------------------------------------------------\\n', '// MMU Defs (SV32)\\n', '//--------------------------------------------------------------------\\n', '`define MMU_LEVELS        2\\n', '`define MMU_PTIDXBITS     10\\n', '`define MMU_PTESIZE       4\\n', '`define MMU_PGSHIFT       (`MMU_PTIDXBITS + 2)\\n', '`define MMU_PGSIZE        (1 << `MMU_PGSHIFT)\\n', '`define MMU_VPN_BITS      (`MMU_PTIDXBITS * `MMU_LEVELS)\\n', '`define MMU_PPN_BITS      (32 - `MMU_PGSHIFT)\\n', '`define MMU_VA_BITS       (`MMU_VPN_BITS + `MMU_PGSHIFT)\\n', '\\n', '`define PAGE_PRESENT      0\\n', '`define PAGE_READ         1\\n', '`define PAGE_WRITE        2\\n', '`define PAGE_EXEC         3\\n', '`define PAGE_USER         4\\n', '`define PAGE_GLOBAL       5\\n', '`define PAGE_ACCESSED     6\\n', '`define PAGE_DIRTY        7\\n', '`define PAGE_SOFT         9:8\\n', '\\n', \"`define PAGE_FLAGS       10'h3FF\\n\", '\\n', '`define PAGE_PFN_SHIFT   10\\n', '`define PAGE_SIZE        4096\\n', '\\n', '//--------------------------------------------------------------------\\n', '// Exception Causes\\n', '//--------------------------------------------------------------------\\n', '`define EXCEPTION_W                        6\\n', \"`define EXCEPTION_MISALIGNED_FETCH         6'h10\\n\", \"`define EXCEPTION_FAULT_FETCH              6'h11\\n\", \"`define EXCEPTION_ILLEGAL_INSTRUCTION      6'h12\\n\", \"`define EXCEPTION_BREAKPOINT               6'h13\\n\", \"`define EXCEPTION_MISALIGNED_LOAD          6'h14\\n\", \"`define EXCEPTION_FAULT_LOAD               6'h15\\n\", \"`define EXCEPTION_MISALIGNED_STORE         6'h16\\n\", \"`define EXCEPTION_FAULT_STORE              6'h17\\n\", \"`define EXCEPTION_ECALL                    6'h18\\n\", \"`define EXCEPTION_ECALL_U                  6'h18\\n\", \"`define EXCEPTION_ECALL_S                  6'h19\\n\", \"`define EXCEPTION_ECALL_H                  6'h1a\\n\", \"`define EXCEPTION_ECALL_M                  6'h1b\\n\", \"`define EXCEPTION_PAGE_FAULT_INST          6'h1c\\n\", \"`define EXCEPTION_PAGE_FAULT_LOAD          6'h1d\\n\", \"`define EXCEPTION_PAGE_FAULT_STORE         6'h1f\\n\", \"`define EXCEPTION_EXCEPTION                6'h10\\n\", \"`define EXCEPTION_INTERRUPT                6'h20\\n\", \"`define EXCEPTION_ERET_U                   6'h30\\n\", \"`define EXCEPTION_ERET_S                   6'h31\\n\", \"`define EXCEPTION_ERET_H                   6'h32\\n\", \"`define EXCEPTION_ERET_M                   6'h33\\n\", \"`define EXCEPTION_FENCE                    6'h34\\n\", \"`define EXCEPTION_TYPE_MASK                6'h30\\n\", '`define EXCEPTION_SUBTYPE_R                3:0\\n', '\\n', '`define MCAUSE_INT                      31\\n', '`define MCAUSE_MISALIGNED_FETCH         ((0 << `MCAUSE_INT) | 0)\\n', '`define MCAUSE_FAULT_FETCH              ((0 << `MCAUSE_INT) | 1)\\n', '`define MCAUSE_ILLEGAL_INSTRUCTION      ((0 << `MCAUSE_INT) | 2)\\n', '`define MCAUSE_BREAKPOINT               ((0 << `MCAUSE_INT) | 3)\\n', '`define MCAUSE_MISALIGNED_LOAD          ((0 << `MCAUSE_INT) | 4)\\n', '`define MCAUSE_FAULT_LOAD               ((0 << `MCAUSE_INT) | 5)\\n', '`define MCAUSE_MISALIGNED_STORE         ((0 << `MCAUSE_INT) | 6)\\n', '`define MCAUSE_FAULT_STORE              ((0 << `MCAUSE_INT) | 7)\\n', '`define MCAUSE_ECALL_U                  ((0 << `MCAUSE_INT) | 8)\\n', '`define MCAUSE_ECALL_S                  ((0 << `MCAUSE_INT) | 9)\\n', '`define MCAUSE_ECALL_H                  ((0 << `MCAUSE_INT) | 10)\\n', '`define MCAUSE_ECALL_M                  ((0 << `MCAUSE_INT) | 11)\\n', '`define MCAUSE_PAGE_FAULT_INST          ((0 << `MCAUSE_INT) | 12)\\n', '`define MCAUSE_PAGE_FAULT_LOAD          ((0 << `MCAUSE_INT) | 13)\\n', '`define MCAUSE_PAGE_FAULT_STORE         ((0 << `MCAUSE_INT) | 15)\\n', '`define MCAUSE_INTERRUPT                (1 << `MCAUSE_INT)\\n', '\\n', '//--------------------------------------------------------------------\\n', '// Debug\\n', '//--------------------------------------------------------------------\\n', \"`define RISCV_REGNO_FIRST   13'd0\\n\", \"`define RISCV_REGNO_GPR0    13'd0\\n\", \"`define RISCV_REGNO_GPR31   13'd31\\n\", \"`define RISCV_REGNO_PC      13'd32\\n\", \"`define RISCV_REGNO_CSR0    13'd65\\n\", \"`define RISCV_REGNO_CSR4095 (`RISCV_REGNO_CSR0 +  13'd4095)\\n\", \"`define RISCV_REGNO_PRIV    13'd4161\\n\"]"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module biriscv_divider\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           opcode_valid_i\\n', '    ,input  [ 31:0]  opcode_opcode_i\\n', '    ,input  [ 31:0]  opcode_pc_i\\n', '    ,input           opcode_invalid_i\\n', '    ,input  [  4:0]  opcode_rd_idx_i\\n', '    ,input  [  4:0]  opcode_ra_idx_i\\n', '    ,input  [  4:0]  opcode_rb_idx_i\\n', '    ,input  [ 31:0]  opcode_ra_operand_i\\n', '    ,input  [ 31:0]  opcode_rb_operand_i\\n', '\\n', '    // Outputs\\n', '    ,output          writeback_valid_o\\n', '    ,output [ 31:0]  writeback_value_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Includes\\n', '//-----------------------------------------------------------------\\n', '`include \"biriscv_defs.v\"\\n', '\\n', '//-------------------------------------------------------------\\n', '// Registers / Wires\\n', '//-------------------------------------------------------------\\n', 'reg          valid_q;\\n', 'reg  [31:0]  wb_result_q;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Divider\\n', '//-------------------------------------------------------------\\n', 'wire inst_div_w         = (opcode_opcode_i & `INST_DIV_MASK) == `INST_DIV;\\n', 'wire inst_divu_w        = (opcode_opcode_i & `INST_DIVU_MASK) == `INST_DIVU;\\n', 'wire inst_rem_w         = (opcode_opcode_i & `INST_REM_MASK) == `INST_REM;\\n', 'wire inst_remu_w        = (opcode_opcode_i & `INST_REMU_MASK) == `INST_REMU;\\n', '\\n', 'wire div_rem_inst_w     = ((opcode_opcode_i & `INST_DIV_MASK) == `INST_DIV)  || \\n', '                          ((opcode_opcode_i & `INST_DIVU_MASK) == `INST_DIVU) ||\\n', '                          ((opcode_opcode_i & `INST_REM_MASK) == `INST_REM)  ||\\n', '                          ((opcode_opcode_i & `INST_REMU_MASK) == `INST_REMU);\\n', '\\n', 'wire signed_operation_w = ((opcode_opcode_i & `INST_DIV_MASK) == `INST_DIV) || ((opcode_opcode_i & `INST_REM_MASK) == `INST_REM);\\n', 'wire div_operation_w    = ((opcode_opcode_i & `INST_DIV_MASK) == `INST_DIV) || ((opcode_opcode_i & `INST_DIVU_MASK) == `INST_DIVU);\\n', '\\n', 'reg [31:0] dividend_q;\\n', 'reg [62:0] divisor_q;\\n', 'reg [31:0] quotient_q;\\n', 'reg [31:0] q_mask_q;\\n', 'reg        div_inst_q;\\n', 'reg        div_busy_q;\\n', 'reg        invert_res_q;\\n', '\\n', 'reg [31:0] last_a_q;\\n', 'reg [31:0] last_b_q;\\n', 'reg        last_div_q;\\n', 'reg        last_divu_q;\\n', 'reg        last_rem_q;\\n', 'reg        last_remu_q;\\n', '\\n', 'wire div_start_w    = opcode_valid_i & div_rem_inst_w;\\n', 'wire div_complete_w = !(|q_mask_q) & div_busy_q;\\n', '\\n', 'always @(posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    div_busy_q     <= 1'b0;\\n\", \"    dividend_q     <= 32'b0;\\n\", \"    divisor_q      <= 63'b0;\\n\", \"    invert_res_q   <= 1'b0;\\n\", \"    quotient_q     <= 32'b0;\\n\", \"    q_mask_q       <= 32'b0;\\n\", \"    div_inst_q     <= 1'b0;\\n\", \"    last_a_q       <= 32'b0;\\n\", \"    last_b_q       <= 32'b0;\\n\", \"    last_div_q     <= 1'b0;\\n\", \"    last_divu_q    <= 1'b0;\\n\", \"    last_rem_q     <= 1'b0;\\n\", \"    last_remu_q    <= 1'b0;\\n\", 'end\\n', 'else if (div_start_w)\\n', 'begin\\n', '    // Repeat same operation with same inputs...\\n', '    if (last_a_q    == opcode_ra_operand_i && \\n', '        last_b_q    == opcode_rb_operand_i &&\\n', '        last_div_q  == inst_div_w &&\\n', '        last_divu_q == inst_divu_w &&\\n', '        last_rem_q  == inst_rem_w &&\\n', '        last_remu_q == inst_remu_w)\\n', '    begin\\n', \"        div_busy_q     <= 1'b1;\\n\", '    end\\n', '    else\\n', '    begin\\n', '        last_a_q       <= opcode_ra_operand_i;\\n', '        last_b_q       <= opcode_rb_operand_i;\\n', '        last_div_q     <= inst_div_w;\\n', '        last_divu_q    <= inst_divu_w;\\n', '        last_rem_q     <= inst_rem_w;\\n', '        last_remu_q    <= inst_remu_w;\\n', '\\n', \"        div_busy_q     <= 1'b1;\\n\", '        div_inst_q     <= div_operation_w;\\n', '\\n', '        if (signed_operation_w && opcode_ra_operand_i[31])\\n', '            dividend_q <= -opcode_ra_operand_i;\\n', '        else\\n', '            dividend_q <= opcode_ra_operand_i;\\n', '\\n', '        if (signed_operation_w && opcode_rb_operand_i[31])\\n', \"            divisor_q <= {-opcode_rb_operand_i, 31'b0};\\n\", '        else\\n', \"            divisor_q <= {opcode_rb_operand_i, 31'b0};\\n\", '\\n', '        invert_res_q  <= (((opcode_opcode_i & `INST_DIV_MASK) == `INST_DIV) && (opcode_ra_operand_i[31] != opcode_rb_operand_i[31]) && |opcode_rb_operand_i) || \\n', '                         (((opcode_opcode_i & `INST_REM_MASK) == `INST_REM) && opcode_ra_operand_i[31]);\\n', '\\n', \"        quotient_q     <= 32'b0;\\n\", \"        q_mask_q       <= 32'h80000000;\\n\", '    end\\n', 'end\\n', 'else if (div_complete_w)\\n', 'begin\\n', \"    div_busy_q <= 1'b0;\\n\", 'end\\n', 'else if (div_busy_q)\\n', 'begin\\n', \"    if (divisor_q <= {31'b0, dividend_q})\\n\", '    begin\\n', '        dividend_q <= dividend_q - divisor_q[31:0];\\n', '        quotient_q <= quotient_q | q_mask_q;\\n', '    end\\n', '\\n', \"    divisor_q <= {1'b0, divisor_q[62:1]};\\n\", \"    q_mask_q  <= {1'b0, q_mask_q[31:1]};\\n\", 'end\\n', '\\n', 'reg [31:0] div_result_r;\\n', 'always @ *\\n', 'begin\\n', \"    div_result_r = 32'b0;\\n\", '\\n', '    if (div_inst_q)\\n', '        div_result_r = invert_res_q ? -quotient_q : quotient_q;\\n', '    else\\n', '        div_result_r = invert_res_q ? -dividend_q : dividend_q;\\n', 'end\\n', '\\n', 'always @(posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    valid_q <= 1'b0;\\n\", 'else\\n', '    valid_q <= div_complete_w;\\n', '\\n', 'always @(posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    wb_result_q <= 32'b0;\\n\", 'else if (div_complete_w)\\n', '    wb_result_q <= div_result_r;\\n', '\\n', 'assign writeback_valid_o = valid_q;\\n', 'assign writeback_value_o  = wb_result_q;\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module biriscv_exec\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           opcode_valid_i\\n', '    ,input  [ 31:0]  opcode_opcode_i\\n', '    ,input  [ 31:0]  opcode_pc_i\\n', '    ,input           opcode_invalid_i\\n', '    ,input  [  4:0]  opcode_rd_idx_i\\n', '    ,input  [  4:0]  opcode_ra_idx_i\\n', '    ,input  [  4:0]  opcode_rb_idx_i\\n', '    ,input  [ 31:0]  opcode_ra_operand_i\\n', '    ,input  [ 31:0]  opcode_rb_operand_i\\n', '    ,input           hold_i\\n', '\\n', '    // Outputs\\n', '    ,output          branch_request_o\\n', '    ,output          branch_is_taken_o\\n', '    ,output          branch_is_not_taken_o\\n', '    ,output [ 31:0]  branch_source_o\\n', '    ,output          branch_is_call_o\\n', '    ,output          branch_is_ret_o\\n', '    ,output          branch_is_jmp_o\\n', '    ,output [ 31:0]  branch_pc_o\\n', '    ,output          branch_d_request_o\\n', '    ,output [ 31:0]  branch_d_pc_o\\n', '    ,output [  1:0]  branch_d_priv_o\\n', '    ,output [ 31:0]  writeback_value_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Includes\\n', '//-----------------------------------------------------------------\\n', '`include \"biriscv_defs.v\"\\n', '\\n', '//-------------------------------------------------------------\\n', '// Opcode decode\\n', '//-------------------------------------------------------------\\n', 'reg [31:0]  imm20_r;\\n', 'reg [31:0]  imm12_r;\\n', 'reg [31:0]  bimm_r;\\n', 'reg [31:0]  jimm20_r;\\n', 'reg [4:0]   shamt_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', \"    imm20_r     = {opcode_opcode_i[31:12], 12'b0};\\n\", '    imm12_r     = {{20{opcode_opcode_i[31]}}, opcode_opcode_i[31:20]};\\n', \"    bimm_r      = {{19{opcode_opcode_i[31]}}, opcode_opcode_i[31], opcode_opcode_i[7], opcode_opcode_i[30:25], opcode_opcode_i[11:8], 1'b0};\\n\", \"    jimm20_r    = {{12{opcode_opcode_i[31]}}, opcode_opcode_i[19:12], opcode_opcode_i[20], opcode_opcode_i[30:25], opcode_opcode_i[24:21], 1'b0};\\n\", '    shamt_r     = opcode_opcode_i[24:20];\\n', 'end\\n', '\\n', '//-------------------------------------------------------------\\n', '// Execute - ALU operations\\n', '//-------------------------------------------------------------\\n', 'reg [3:0]  alu_func_r;\\n', 'reg [31:0] alu_input_a_r;\\n', 'reg [31:0] alu_input_b_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', '    alu_func_r     = `ALU_NONE;\\n', \"    alu_input_a_r  = 32'b0;\\n\", \"    alu_input_b_r  = 32'b0;\\n\", '\\n', '    if ((opcode_opcode_i & `INST_ADD_MASK) == `INST_ADD) // add\\n', '    begin\\n', '        alu_func_r     = `ALU_ADD;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = opcode_rb_operand_i;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_AND_MASK) == `INST_AND) // and\\n', '    begin\\n', '        alu_func_r     = `ALU_AND;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = opcode_rb_operand_i;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_OR_MASK) == `INST_OR) // or\\n', '    begin\\n', '        alu_func_r     = `ALU_OR;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = opcode_rb_operand_i;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_SLL_MASK) == `INST_SLL) // sll\\n', '    begin\\n', '        alu_func_r     = `ALU_SHIFTL;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = opcode_rb_operand_i;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_SRA_MASK) == `INST_SRA) // sra\\n', '    begin\\n', '        alu_func_r     = `ALU_SHIFTR_ARITH;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = opcode_rb_operand_i;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_SRL_MASK) == `INST_SRL) // srl\\n', '    begin\\n', '        alu_func_r     = `ALU_SHIFTR;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = opcode_rb_operand_i;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_SUB_MASK) == `INST_SUB) // sub\\n', '    begin\\n', '        alu_func_r     = `ALU_SUB;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = opcode_rb_operand_i;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_XOR_MASK) == `INST_XOR) // xor\\n', '    begin\\n', '        alu_func_r     = `ALU_XOR;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = opcode_rb_operand_i;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_SLT_MASK) == `INST_SLT) // slt\\n', '    begin\\n', '        alu_func_r     = `ALU_LESS_THAN_SIGNED;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = opcode_rb_operand_i;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_SLTU_MASK) == `INST_SLTU) // sltu\\n', '    begin\\n', '        alu_func_r     = `ALU_LESS_THAN;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = opcode_rb_operand_i;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_ADDI_MASK) == `INST_ADDI) // addi\\n', '    begin\\n', '        alu_func_r     = `ALU_ADD;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = imm12_r;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_ANDI_MASK) == `INST_ANDI) // andi\\n', '    begin\\n', '        alu_func_r     = `ALU_AND;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = imm12_r;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_SLTI_MASK) == `INST_SLTI) // slti\\n', '    begin\\n', '        alu_func_r     = `ALU_LESS_THAN_SIGNED;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = imm12_r;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_SLTIU_MASK) == `INST_SLTIU) // sltiu\\n', '    begin\\n', '        alu_func_r     = `ALU_LESS_THAN;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = imm12_r;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_ORI_MASK) == `INST_ORI) // ori\\n', '    begin\\n', '        alu_func_r     = `ALU_OR;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = imm12_r;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_XORI_MASK) == `INST_XORI) // xori\\n', '    begin\\n', '        alu_func_r     = `ALU_XOR;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', '        alu_input_b_r  = imm12_r;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_SLLI_MASK) == `INST_SLLI) // slli\\n', '    begin\\n', '        alu_func_r     = `ALU_SHIFTL;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', \"        alu_input_b_r  = {27'b0, shamt_r};\\n\", '    end\\n', '    else if ((opcode_opcode_i & `INST_SRLI_MASK) == `INST_SRLI) // srli\\n', '    begin\\n', '        alu_func_r     = `ALU_SHIFTR;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', \"        alu_input_b_r  = {27'b0, shamt_r};\\n\", '    end\\n', '    else if ((opcode_opcode_i & `INST_SRAI_MASK) == `INST_SRAI) // srai\\n', '    begin\\n', '        alu_func_r     = `ALU_SHIFTR_ARITH;\\n', '        alu_input_a_r  = opcode_ra_operand_i;\\n', \"        alu_input_b_r  = {27'b0, shamt_r};\\n\", '    end\\n', '    else if ((opcode_opcode_i & `INST_LUI_MASK) == `INST_LUI) // lui\\n', '    begin\\n', '        alu_input_a_r  = imm20_r;\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_AUIPC_MASK) == `INST_AUIPC) // auipc\\n', '    begin\\n', '        alu_func_r     = `ALU_ADD;\\n', '        alu_input_a_r  = opcode_pc_i;\\n', '        alu_input_b_r  = imm20_r;\\n', '    end     \\n', '    else if (((opcode_opcode_i & `INST_JAL_MASK) == `INST_JAL) || ((opcode_opcode_i & `INST_JALR_MASK) == `INST_JALR)) // jal, jalr\\n', '    begin\\n', '        alu_func_r     = `ALU_ADD;\\n', '        alu_input_a_r  = opcode_pc_i;\\n', \"        alu_input_b_r  = 32'd4;\\n\", '    end\\n', 'end\\n', '\\n', '\\n', '//-------------------------------------------------------------\\n', '// ALU\\n', '//-------------------------------------------------------------\\n', 'wire [31:0]  alu_p_w;\\n', 'biriscv_alu\\n', 'u_alu\\n', '(\\n', '    .alu_op_i(alu_func_r),\\n', '    .alu_a_i(alu_input_a_r),\\n', '    .alu_b_i(alu_input_b_r),\\n', '    .alu_p_o(alu_p_w)\\n', ');\\n', '\\n', '//-------------------------------------------------------------\\n', '// Flop ALU output\\n', '//-------------------------------------------------------------\\n', 'reg [31:0] result_q;\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    result_q  <= 32'b0;\\n\", 'else if (~hold_i)\\n', '    result_q <= alu_p_w;\\n', '\\n', 'assign writeback_value_o  = result_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// less_than_signed: Less than operator (signed)\\n', '// Inputs: x = left operand, y = right operand\\n', '// Return: (int)x < (int)y\\n', '//-----------------------------------------------------------------\\n', 'function [0:0] less_than_signed;\\n', '    input  [31:0] x;\\n', '    input  [31:0] y;\\n', '    reg [31:0] v;\\n', 'begin\\n', '    v = (x - y);\\n', '    if (x[31] != y[31])\\n', '        less_than_signed = x[31];\\n', '    else\\n', '        less_than_signed = v[31];\\n', 'end\\n', 'endfunction\\n', '\\n', '//-----------------------------------------------------------------\\n', '// greater_than_signed: Greater than operator (signed)\\n', '// Inputs: x = left operand, y = right operand\\n', '// Return: (int)x > (int)y\\n', '//-----------------------------------------------------------------\\n', 'function [0:0] greater_than_signed;\\n', '    input  [31:0] x;\\n', '    input  [31:0] y;\\n', '    reg [31:0] v;\\n', 'begin\\n', '    v = (y - x);\\n', '    if (x[31] != y[31])\\n', '        greater_than_signed = y[31];\\n', '    else\\n', '        greater_than_signed = v[31];\\n', 'end\\n', 'endfunction\\n', '\\n', '//-------------------------------------------------------------\\n', '// Execute - Branch operations\\n', '//-------------------------------------------------------------\\n', 'reg        branch_r;\\n', 'reg        branch_taken_r;\\n', 'reg [31:0] branch_target_r;\\n', 'reg        branch_call_r;\\n', 'reg        branch_ret_r;\\n', 'reg        branch_jmp_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', \"    branch_r        = 1'b0;\\n\", \"    branch_taken_r  = 1'b0;\\n\", \"    branch_call_r   = 1'b0;\\n\", \"    branch_ret_r    = 1'b0;\\n\", \"    branch_jmp_r    = 1'b0;\\n\", '\\n', '    // Default branch_r target is relative to current PC\\n', '    branch_target_r = opcode_pc_i + bimm_r;\\n', '\\n', '    if ((opcode_opcode_i & `INST_JAL_MASK) == `INST_JAL) // jal\\n', '    begin\\n', \"        branch_r        = 1'b1;\\n\", \"        branch_taken_r  = 1'b1;\\n\", '        branch_target_r = opcode_pc_i + jimm20_r;\\n', \"        branch_call_r   = (opcode_rd_idx_i == 5'd1); // RA\\n\", \"        branch_jmp_r    = 1'b1;\\n\", '    end\\n', '    else if ((opcode_opcode_i & `INST_JALR_MASK) == `INST_JALR) // jalr\\n', '    begin\\n', \"        branch_r            = 1'b1;\\n\", \"        branch_taken_r      = 1'b1;\\n\", '        branch_target_r     = opcode_ra_operand_i + imm12_r;\\n', \"        branch_target_r[0]  = 1'b0;\\n\", \"        branch_ret_r        = (opcode_ra_idx_i == 5'd1 && imm12_r[11:0] == 12'b0); // RA\\n\", \"        branch_call_r       = ~branch_ret_r && (opcode_rd_idx_i == 5'd1); // RA\\n\", '        branch_jmp_r        = ~(branch_call_r | branch_ret_r);\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_BEQ_MASK) == `INST_BEQ) // beq\\n', '    begin\\n', \"        branch_r      = 1'b1;\\n\", '        branch_taken_r= (opcode_ra_operand_i == opcode_rb_operand_i);\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_BNE_MASK) == `INST_BNE) // bne\\n', '    begin\\n', \"        branch_r      = 1'b1;    \\n\", '        branch_taken_r= (opcode_ra_operand_i != opcode_rb_operand_i);\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_BLT_MASK) == `INST_BLT) // blt\\n', '    begin\\n', \"        branch_r      = 1'b1;\\n\", '        branch_taken_r= less_than_signed(opcode_ra_operand_i, opcode_rb_operand_i);\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_BGE_MASK) == `INST_BGE) // bge\\n', '    begin\\n', \"        branch_r      = 1'b1;    \\n\", '        branch_taken_r= greater_than_signed(opcode_ra_operand_i,opcode_rb_operand_i) | (opcode_ra_operand_i == opcode_rb_operand_i);\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_BLTU_MASK) == `INST_BLTU) // bltu\\n', '    begin\\n', \"        branch_r      = 1'b1;    \\n\", '        branch_taken_r= (opcode_ra_operand_i < opcode_rb_operand_i);\\n', '    end\\n', '    else if ((opcode_opcode_i & `INST_BGEU_MASK) == `INST_BGEU) // bgeu\\n', '    begin\\n', \"        branch_r      = 1'b1;\\n\", '        branch_taken_r= (opcode_ra_operand_i >= opcode_rb_operand_i);\\n', '    end\\n', 'end\\n', '\\n', 'reg        branch_taken_q;\\n', 'reg        branch_ntaken_q;\\n', 'reg [31:0] pc_x_q;\\n', 'reg [31:0] pc_m_q;\\n', 'reg        branch_call_q;\\n', 'reg        branch_ret_q;\\n', 'reg        branch_jmp_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    branch_taken_q   <= 1'b0;\\n\", \"    branch_ntaken_q  <= 1'b0;\\n\", \"    pc_x_q           <= 32'b0;\\n\", \"    pc_m_q           <= 32'b0;\\n\", \"    branch_call_q    <= 1'b0;\\n\", \"    branch_ret_q     <= 1'b0;\\n\", \"    branch_jmp_q     <= 1'b0;\\n\", 'end\\n', 'else if (opcode_valid_i)\\n', 'begin\\n', '    branch_taken_q   <= branch_r && opcode_valid_i & branch_taken_r;\\n', '    branch_ntaken_q  <= branch_r && opcode_valid_i & ~branch_taken_r;\\n', \"    pc_x_q           <= branch_taken_r ? branch_target_r : opcode_pc_i + 32'd4;\\n\", '    branch_call_q    <= branch_r && opcode_valid_i && branch_call_r;\\n', '    branch_ret_q     <= branch_r && opcode_valid_i && branch_ret_r;\\n', '    branch_jmp_q     <= branch_r && opcode_valid_i && branch_jmp_r;\\n', '    pc_m_q           <= opcode_pc_i;\\n', 'end\\n', '\\n', 'assign branch_request_o   = branch_taken_q | branch_ntaken_q;\\n', 'assign branch_is_taken_o  = branch_taken_q;\\n', 'assign branch_is_not_taken_o = branch_ntaken_q;\\n', 'assign branch_source_o    = pc_m_q;\\n', 'assign branch_pc_o        = pc_x_q;\\n', 'assign branch_is_call_o   = branch_call_q;\\n', 'assign branch_is_ret_o    = branch_ret_q;\\n', 'assign branch_is_jmp_o    = branch_jmp_q;\\n', '\\n', 'assign branch_d_request_o = (branch_r && opcode_valid_i && branch_taken_r);\\n', 'assign branch_d_pc_o      = branch_target_r;\\n', \"assign branch_d_priv_o    = 2'b0; // don't care\\n\", '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module biriscv_fetch\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter SUPPORT_MMU      = 1\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           fetch_accept_i\\n', '    ,input           icache_accept_i\\n', '    ,input           icache_valid_i\\n', '    ,input           icache_error_i\\n', '    ,input  [ 63:0]  icache_inst_i\\n', '    ,input           icache_page_fault_i\\n', '    ,input           fetch_invalidate_i\\n', '    ,input           branch_request_i\\n', '    ,input  [ 31:0]  branch_pc_i\\n', '    ,input  [  1:0]  branch_priv_i\\n', '    ,input  [ 31:0]  next_pc_f_i\\n', '    ,input  [  1:0]  next_taken_f_i\\n', '\\n', '    // Outputs\\n', '    ,output          fetch_valid_o\\n', '    ,output [ 63:0]  fetch_instr_o\\n', '    ,output [  1:0]  fetch_pred_branch_o\\n', '    ,output          fetch_fault_fetch_o\\n', '    ,output          fetch_fault_page_o\\n', '    ,output [ 31:0]  fetch_pc_o\\n', '    ,output          icache_rd_o\\n', '    ,output          icache_flush_o\\n', '    ,output          icache_invalidate_o\\n', '    ,output [ 31:0]  icache_pc_o\\n', '    ,output [  1:0]  icache_priv_o\\n', '    ,output [ 31:0]  pc_f_o\\n', '    ,output          pc_accept_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-------------------------------------------------------------\\n', '// Registers / Wires\\n', '//-------------------------------------------------------------\\n', 'reg         active_q;\\n', '\\n', 'wire        icache_busy_w;\\n', 'wire        stall_w       = !fetch_accept_i || icache_busy_w || !icache_accept_i;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Buffered branch\\n', '//-------------------------------------------------------------\\n', 'reg         branch_q;\\n', 'reg [31:0]  branch_pc_q;\\n', 'reg [1:0]   branch_priv_q;\\n', '\\n', 'wire        branch_w;\\n', 'wire [31:0] branch_pc_w;\\n', 'wire [1:0]  branch_priv_w;\\n', '\\n', 'generate\\n', 'if (SUPPORT_MMU)\\n', 'begin\\n', '    assign branch_w      = branch_q;\\n', '    assign branch_pc_w   = branch_pc_q;\\n', '    assign branch_priv_w = branch_priv_q;\\n', '    \\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', '    begin\\n', \"        branch_q       <= 1'b0;\\n\", \"        branch_pc_q    <= 32'b0;\\n\", '        branch_priv_q  <= `PRIV_MACHINE;\\n', '    end\\n', '    else if (branch_request_i)\\n', '    begin\\n', \"        branch_q       <= 1'b1;\\n\", '        branch_pc_q    <= branch_pc_i;\\n', '        branch_priv_q  <= branch_priv_i;\\n', '    end\\n', '    else if (icache_rd_o && icache_accept_i)\\n', '    begin\\n', \"        branch_q       <= 1'b0;\\n\", \"        branch_pc_q    <= 32'b0;\\n\", '    end\\n', 'end\\n', 'else\\n', 'begin\\n', '    assign branch_w      = branch_q || branch_request_i;\\n', '    assign branch_pc_w   = (branch_q & !branch_request_i) ? branch_pc_q   : branch_pc_i;\\n', \"    assign branch_priv_w = `PRIV_MACHINE; // don't care\\n\", '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', '    begin\\n', \"        branch_q       <= 1'b0;\\n\", \"        branch_pc_q    <= 32'b0;\\n\", '    end\\n', '    else if (branch_request_i && (icache_busy_w || !active_q))\\n', '    begin\\n', '        branch_q       <= branch_w;\\n', '        branch_pc_q    <= branch_pc_w;\\n', '    end\\n', '    else if (~icache_busy_w)\\n', '    begin\\n', \"        branch_q       <= 1'b0;\\n\", \"        branch_pc_q    <= 32'b0;\\n\", '    end\\n', '\\n', 'end\\n', 'endgenerate\\n', '\\n', '//-------------------------------------------------------------\\n', '// Active flag\\n', '//-------------------------------------------------------------\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    active_q    <= 1'b0;\\n\", 'else if (SUPPORT_MMU && branch_w && ~stall_w)\\n', \"    active_q    <= 1'b1;\\n\", 'else if (!SUPPORT_MMU && branch_w)\\n', \"    active_q    <= 1'b1;\\n\", '\\n', '//-------------------------------------------------------------\\n', '// Stall flag\\n', '//-------------------------------------------------------------\\n', 'reg stall_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    stall_q    <= 1'b0;\\n\", 'else\\n', '    stall_q    <= stall_w;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Request tracking\\n', '//-------------------------------------------------------------\\n', 'reg icache_fetch_q;\\n', 'reg icache_invalidate_q;\\n', '\\n', '// ICACHE fetch tracking\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    icache_fetch_q <= 1'b0;\\n\", 'else if (icache_rd_o && icache_accept_i)\\n', \"    icache_fetch_q <= 1'b1;\\n\", 'else if (icache_valid_i)\\n', \"    icache_fetch_q <= 1'b0;\\n\", '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    icache_invalidate_q <= 1'b0;\\n\", 'else if (icache_invalidate_o && !icache_accept_i)\\n', \"    icache_invalidate_q <= 1'b1;\\n\", 'else\\n', \"    icache_invalidate_q <= 1'b0;\\n\", '\\n', '//-------------------------------------------------------------\\n', '// PC\\n', '//-------------------------------------------------------------\\n', 'reg [31:0]  pc_f_q;\\n', 'reg [31:0]  pc_d_q;\\n', 'reg [1:0]   pred_d_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pc_f_q  <= 32'b0;\\n\", '// Branch request\\n', 'else if (SUPPORT_MMU && branch_w && ~stall_w)\\n', '    pc_f_q  <= branch_pc_w;\\n', 'else if (!SUPPORT_MMU && (stall_w || !active_q || stall_q) && branch_w)\\n', '    pc_f_q  <= branch_pc_w;\\n', '// NPC\\n', 'else if (!stall_w)\\n', '    pc_f_q  <= next_pc_f_i;\\n', '\\n', 'wire [31:0] icache_pc_w;\\n', 'wire [1:0]  icache_priv_w;\\n', 'wire        fetch_resp_drop_w;\\n', '\\n', 'generate\\n', 'if (SUPPORT_MMU)\\n', 'begin\\n', '    reg [1:0] priv_f_q;\\n', '    reg       branch_d_q;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', '        priv_f_q  <= `PRIV_MACHINE;\\n', '    // Branch request\\n', '    else if (branch_w && ~stall_w)\\n', '        priv_f_q  <= branch_priv_w;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', \"        branch_d_q  <= 1'b0;\\n\", '    // Branch request\\n', '    else if (branch_w && ~stall_w)\\n', \"        branch_d_q  <= 1'b1;\\n\", '    // NPC\\n', '    else if (!stall_w)\\n', \"        branch_d_q  <= 1'b0;\\n\", '\\n', '    assign icache_pc_w       = pc_f_q;\\n', '    assign icache_priv_w     = priv_f_q;\\n', '    assign fetch_resp_drop_w = branch_w | branch_d_q;\\n', 'end\\n', 'else\\n', 'begin\\n', '    assign icache_pc_w       = (branch_w & ~stall_q) ? branch_pc_w : pc_f_q;\\n', \"    assign icache_priv_w     = `PRIV_MACHINE; // Don't care\\n\", '    assign fetch_resp_drop_w = branch_w;\\n', 'end\\n', 'endgenerate\\n', '\\n', '// Last fetch address\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pc_d_q <= 32'b0;\\n\", 'else if (icache_rd_o && icache_accept_i)\\n', '    pc_d_q <= icache_pc_w;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pred_d_q <= 2'b0;\\n\", 'else if (icache_rd_o && icache_accept_i)\\n', '    pred_d_q <= next_taken_f_i;\\n', 'else if (icache_valid_i)\\n', \"    pred_d_q <= 2'b0;\\n\", '\\n', '//-------------------------------------------------------------\\n', '// Outputs\\n', '//-------------------------------------------------------------\\n', 'assign icache_rd_o         = active_q & fetch_accept_i & !icache_busy_w;\\n', \"assign icache_pc_o         = {icache_pc_w[31:3],3'b0};\\n\", 'assign icache_priv_o       = icache_priv_w;\\n', 'assign icache_flush_o      = fetch_invalidate_i | icache_invalidate_q;\\n', \"assign icache_invalidate_o = 1'b0;\\n\", '\\n', 'assign icache_busy_w       =  icache_fetch_q && !icache_valid_i;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Response Buffer\\n', '//-------------------------------------------------------------\\n', 'reg [99:0]  skid_buffer_q;\\n', 'reg         skid_valid_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    skid_buffer_q  <= 100'b0;\\n\", \"    skid_valid_q   <= 1'b0;\\n\", 'end \\n', '// Instruction output back-pressured - hold in skid buffer\\n', 'else if (fetch_valid_o && !fetch_accept_i)\\n', 'begin\\n', \"    skid_valid_q  <= 1'b1;\\n\", '    skid_buffer_q <= {fetch_fault_page_o, fetch_fault_fetch_o, fetch_pred_branch_o, fetch_pc_o, fetch_instr_o};\\n', 'end\\n', 'else\\n', 'begin\\n', \"    skid_valid_q  <= 1'b0;\\n\", \"    skid_buffer_q <= 100'b0;\\n\", 'end\\n', '\\n', 'assign fetch_valid_o       = (icache_valid_i || skid_valid_q) & !fetch_resp_drop_w;\\n', \"assign fetch_pc_o          = skid_valid_q ? skid_buffer_q[95:64] : {pc_d_q[31:3],3'b0};\\n\", 'assign fetch_instr_o       = skid_valid_q ? skid_buffer_q[63:0]  : icache_inst_i;\\n', 'assign fetch_pred_branch_o = skid_valid_q ? skid_buffer_q[97:96] : pred_d_q;\\n', '\\n', '// Faults\\n', 'assign fetch_fault_fetch_o = skid_valid_q ? skid_buffer_q[98] : icache_error_i;\\n', 'assign fetch_fault_page_o  = skid_valid_q ? skid_buffer_q[99] : icache_page_fault_i;\\n', '\\n', 'assign pc_f_o              = icache_pc_w;\\n', 'assign pc_accept_o         = ~stall_w;\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module biriscv_frontend\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter SUPPORT_BRANCH_PREDICTION = 1\\n', '    ,parameter SUPPORT_MULDIV   = 1\\n', '    ,parameter SUPPORT_MMU      = 1\\n', '    ,parameter EXTRA_DECODE_STAGE = 0\\n', '    ,parameter NUM_BTB_ENTRIES  = 32\\n', '    ,parameter NUM_BTB_ENTRIES_W = 5\\n', '    ,parameter NUM_BHT_ENTRIES  = 512\\n', '    ,parameter NUM_BHT_ENTRIES_W = 9\\n', '    ,parameter RAS_ENABLE       = 1\\n', '    ,parameter GSHARE_ENABLE    = 0\\n', '    ,parameter BHT_ENABLE       = 1\\n', '    ,parameter NUM_RAS_ENTRIES  = 8\\n', '    ,parameter NUM_RAS_ENTRIES_W = 3\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           icache_accept_i\\n', '    ,input           icache_valid_i\\n', '    ,input           icache_error_i\\n', '    ,input  [ 63:0]  icache_inst_i\\n', '    ,input           icache_page_fault_i\\n', '    ,input           fetch0_accept_i\\n', '    ,input           fetch1_accept_i\\n', '    ,input           fetch_invalidate_i\\n', '    ,input           branch_request_i\\n', '    ,input  [ 31:0]  branch_pc_i\\n', '    ,input  [  1:0]  branch_priv_i\\n', '    ,input           branch_info_request_i\\n', '    ,input           branch_info_is_taken_i\\n', '    ,input           branch_info_is_not_taken_i\\n', '    ,input  [ 31:0]  branch_info_source_i\\n', '    ,input           branch_info_is_call_i\\n', '    ,input           branch_info_is_ret_i\\n', '    ,input           branch_info_is_jmp_i\\n', '    ,input  [ 31:0]  branch_info_pc_i\\n', '\\n', '    // Outputs\\n', '    ,output          icache_rd_o\\n', '    ,output          icache_flush_o\\n', '    ,output          icache_invalidate_o\\n', '    ,output [ 31:0]  icache_pc_o\\n', '    ,output [  1:0]  icache_priv_o\\n', '    ,output          fetch0_valid_o\\n', '    ,output [ 31:0]  fetch0_instr_o\\n', '    ,output [ 31:0]  fetch0_pc_o\\n', '    ,output          fetch0_fault_fetch_o\\n', '    ,output          fetch0_fault_page_o\\n', '    ,output          fetch0_instr_exec_o\\n', '    ,output          fetch0_instr_lsu_o\\n', '    ,output          fetch0_instr_branch_o\\n', '    ,output          fetch0_instr_mul_o\\n', '    ,output          fetch0_instr_div_o\\n', '    ,output          fetch0_instr_csr_o\\n', '    ,output          fetch0_instr_rd_valid_o\\n', '    ,output          fetch0_instr_invalid_o\\n', '    ,output          fetch1_valid_o\\n', '    ,output [ 31:0]  fetch1_instr_o\\n', '    ,output [ 31:0]  fetch1_pc_o\\n', '    ,output          fetch1_fault_fetch_o\\n', '    ,output          fetch1_fault_page_o\\n', '    ,output          fetch1_instr_exec_o\\n', '    ,output          fetch1_instr_lsu_o\\n', '    ,output          fetch1_instr_branch_o\\n', '    ,output          fetch1_instr_mul_o\\n', '    ,output          fetch1_instr_div_o\\n', '    ,output          fetch1_instr_csr_o\\n', '    ,output          fetch1_instr_rd_valid_o\\n', '    ,output          fetch1_instr_invalid_o\\n', ');\\n', '\\n', 'wire           fetch_valid_w;\\n', 'wire  [ 63:0]  fetch_instr_w;\\n', 'wire           fetch_fault_page_w;\\n', 'wire  [ 31:0]  next_pc_f_w;\\n', 'wire  [  1:0]  next_taken_f_w;\\n', 'wire  [ 31:0]  fetch_pc_f_w;\\n', 'wire           fetch_accept_w;\\n', 'wire  [  1:0]  fetch_pred_branch_w;\\n', 'wire  [ 31:0]  fetch_pc_w;\\n', 'wire           fetch_fault_fetch_w;\\n', 'wire           fetch_pc_accept_w;\\n', '\\n', '\\n', 'biriscv_npc\\n', '#(\\n', '     .NUM_BTB_ENTRIES(NUM_BTB_ENTRIES)\\n', '    ,.SUPPORT_BRANCH_PREDICTION(SUPPORT_BRANCH_PREDICTION)\\n', '    ,.GSHARE_ENABLE(GSHARE_ENABLE)\\n', '    ,.NUM_RAS_ENTRIES_W(NUM_RAS_ENTRIES_W)\\n', '    ,.NUM_BHT_ENTRIES_W(NUM_BHT_ENTRIES_W)\\n', '    ,.BHT_ENABLE(BHT_ENABLE)\\n', '    ,.NUM_BTB_ENTRIES_W(NUM_BTB_ENTRIES_W)\\n', '    ,.NUM_BHT_ENTRIES(NUM_BHT_ENTRIES)\\n', '    ,.RAS_ENABLE(RAS_ENABLE)\\n', '    ,.NUM_RAS_ENTRIES(NUM_RAS_ENTRIES)\\n', ')\\n', 'u_npc\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', \"    ,.invalidate_i(1'b0)\\n\", '    ,.branch_request_i(branch_info_request_i)\\n', '    ,.branch_is_taken_i(branch_info_is_taken_i)\\n', '    ,.branch_is_not_taken_i(branch_info_is_not_taken_i)\\n', '    ,.branch_source_i(branch_info_source_i)\\n', '    ,.branch_is_call_i(branch_info_is_call_i)\\n', '    ,.branch_is_ret_i(branch_info_is_ret_i)\\n', '    ,.branch_is_jmp_i(branch_info_is_jmp_i)\\n', '    ,.branch_pc_i(branch_info_pc_i)\\n', '    ,.pc_f_i(fetch_pc_f_w)\\n', '    ,.pc_accept_i(fetch_pc_accept_w)\\n', '\\n', '    // Outputs\\n', '    ,.next_pc_f_o(next_pc_f_w)\\n', '    ,.next_taken_f_o(next_taken_f_w)\\n', ');\\n', '\\n', '\\n', 'biriscv_decode\\n', '#(\\n', '     .EXTRA_DECODE_STAGE(EXTRA_DECODE_STAGE)\\n', '    ,.SUPPORT_MULDIV(SUPPORT_MULDIV)\\n', ')\\n', 'u_decode\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.fetch_in_valid_i(fetch_valid_w)\\n', '    ,.fetch_in_instr_i(fetch_instr_w)\\n', '    ,.fetch_in_pred_branch_i(fetch_pred_branch_w)\\n', '    ,.fetch_in_fault_fetch_i(fetch_fault_fetch_w)\\n', '    ,.fetch_in_fault_page_i(fetch_fault_page_w)\\n', '    ,.fetch_in_pc_i(fetch_pc_w)\\n', '    ,.fetch_out0_accept_i(fetch0_accept_i)\\n', '    ,.fetch_out1_accept_i(fetch1_accept_i)\\n', '    ,.branch_request_i(branch_request_i)\\n', '    ,.branch_pc_i(branch_pc_i)\\n', '    ,.branch_priv_i(branch_priv_i)\\n', '\\n', '    // Outputs\\n', '    ,.fetch_in_accept_o(fetch_accept_w)\\n', '    ,.fetch_out0_valid_o(fetch0_valid_o)\\n', '    ,.fetch_out0_instr_o(fetch0_instr_o)\\n', '    ,.fetch_out0_pc_o(fetch0_pc_o)\\n', '    ,.fetch_out0_fault_fetch_o(fetch0_fault_fetch_o)\\n', '    ,.fetch_out0_fault_page_o(fetch0_fault_page_o)\\n', '    ,.fetch_out0_instr_exec_o(fetch0_instr_exec_o)\\n', '    ,.fetch_out0_instr_lsu_o(fetch0_instr_lsu_o)\\n', '    ,.fetch_out0_instr_branch_o(fetch0_instr_branch_o)\\n', '    ,.fetch_out0_instr_mul_o(fetch0_instr_mul_o)\\n', '    ,.fetch_out0_instr_div_o(fetch0_instr_div_o)\\n', '    ,.fetch_out0_instr_csr_o(fetch0_instr_csr_o)\\n', '    ,.fetch_out0_instr_rd_valid_o(fetch0_instr_rd_valid_o)\\n', '    ,.fetch_out0_instr_invalid_o(fetch0_instr_invalid_o)\\n', '    ,.fetch_out1_valid_o(fetch1_valid_o)\\n', '    ,.fetch_out1_instr_o(fetch1_instr_o)\\n', '    ,.fetch_out1_pc_o(fetch1_pc_o)\\n', '    ,.fetch_out1_fault_fetch_o(fetch1_fault_fetch_o)\\n', '    ,.fetch_out1_fault_page_o(fetch1_fault_page_o)\\n', '    ,.fetch_out1_instr_exec_o(fetch1_instr_exec_o)\\n', '    ,.fetch_out1_instr_lsu_o(fetch1_instr_lsu_o)\\n', '    ,.fetch_out1_instr_branch_o(fetch1_instr_branch_o)\\n', '    ,.fetch_out1_instr_mul_o(fetch1_instr_mul_o)\\n', '    ,.fetch_out1_instr_div_o(fetch1_instr_div_o)\\n', '    ,.fetch_out1_instr_csr_o(fetch1_instr_csr_o)\\n', '    ,.fetch_out1_instr_rd_valid_o(fetch1_instr_rd_valid_o)\\n', '    ,.fetch_out1_instr_invalid_o(fetch1_instr_invalid_o)\\n', ');\\n', '\\n', '\\n', 'biriscv_fetch\\n', '#(\\n', '     .SUPPORT_MMU(SUPPORT_MMU)\\n', ')\\n', 'u_fetch\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.fetch_accept_i(fetch_accept_w)\\n', '    ,.icache_accept_i(icache_accept_i)\\n', '    ,.icache_valid_i(icache_valid_i)\\n', '    ,.icache_error_i(icache_error_i)\\n', '    ,.icache_inst_i(icache_inst_i)\\n', '    ,.icache_page_fault_i(icache_page_fault_i)\\n', '    ,.fetch_invalidate_i(fetch_invalidate_i)\\n', '    ,.branch_request_i(branch_request_i)\\n', '    ,.branch_pc_i(branch_pc_i)\\n', '    ,.branch_priv_i(branch_priv_i)\\n', '    ,.next_pc_f_i(next_pc_f_w)\\n', '    ,.next_taken_f_i(next_taken_f_w)\\n', '\\n', '    // Outputs\\n', '    ,.fetch_valid_o(fetch_valid_w)\\n', '    ,.fetch_instr_o(fetch_instr_w)\\n', '    ,.fetch_pred_branch_o(fetch_pred_branch_w)\\n', '    ,.fetch_fault_fetch_o(fetch_fault_fetch_w)\\n', '    ,.fetch_fault_page_o(fetch_fault_page_w)\\n', '    ,.fetch_pc_o(fetch_pc_w)\\n', '    ,.icache_rd_o(icache_rd_o)\\n', '    ,.icache_flush_o(icache_flush_o)\\n', '    ,.icache_invalidate_o(icache_invalidate_o)\\n', '    ,.icache_pc_o(icache_pc_o)\\n', '    ,.icache_priv_o(icache_priv_o)\\n', '    ,.pc_f_o(fetch_pc_f_w)\\n', '    ,.pc_accept_o(fetch_pc_accept_w)\\n', ');\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module biriscv_issue\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter SUPPORT_MULDIV   = 1\\n', '    ,parameter SUPPORT_DUAL_ISSUE = 1\\n', '    ,parameter SUPPORT_LOAD_BYPASS = 1\\n', '    ,parameter SUPPORT_MUL_BYPASS = 1\\n', '    ,parameter SUPPORT_REGFILE_XILINX = 0\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           fetch0_valid_i\\n', '    ,input  [ 31:0]  fetch0_instr_i\\n', '    ,input  [ 31:0]  fetch0_pc_i\\n', '    ,input           fetch0_fault_fetch_i\\n', '    ,input           fetch0_fault_page_i\\n', '    ,input           fetch0_instr_exec_i\\n', '    ,input           fetch0_instr_lsu_i\\n', '    ,input           fetch0_instr_branch_i\\n', '    ,input           fetch0_instr_mul_i\\n', '    ,input           fetch0_instr_div_i\\n', '    ,input           fetch0_instr_csr_i\\n', '    ,input           fetch0_instr_rd_valid_i\\n', '    ,input           fetch0_instr_invalid_i\\n', '    ,input           fetch1_valid_i\\n', '    ,input  [ 31:0]  fetch1_instr_i\\n', '    ,input  [ 31:0]  fetch1_pc_i\\n', '    ,input           fetch1_fault_fetch_i\\n', '    ,input           fetch1_fault_page_i\\n', '    ,input           fetch1_instr_exec_i\\n', '    ,input           fetch1_instr_lsu_i\\n', '    ,input           fetch1_instr_branch_i\\n', '    ,input           fetch1_instr_mul_i\\n', '    ,input           fetch1_instr_div_i\\n', '    ,input           fetch1_instr_csr_i\\n', '    ,input           fetch1_instr_rd_valid_i\\n', '    ,input           fetch1_instr_invalid_i\\n', '    ,input           branch_exec0_request_i\\n', '    ,input           branch_exec0_is_taken_i\\n', '    ,input           branch_exec0_is_not_taken_i\\n', '    ,input  [ 31:0]  branch_exec0_source_i\\n', '    ,input           branch_exec0_is_call_i\\n', '    ,input           branch_exec0_is_ret_i\\n', '    ,input           branch_exec0_is_jmp_i\\n', '    ,input  [ 31:0]  branch_exec0_pc_i\\n', '    ,input           branch_d_exec0_request_i\\n', '    ,input  [ 31:0]  branch_d_exec0_pc_i\\n', '    ,input  [  1:0]  branch_d_exec0_priv_i\\n', '    ,input           branch_exec1_request_i\\n', '    ,input           branch_exec1_is_taken_i\\n', '    ,input           branch_exec1_is_not_taken_i\\n', '    ,input  [ 31:0]  branch_exec1_source_i\\n', '    ,input           branch_exec1_is_call_i\\n', '    ,input           branch_exec1_is_ret_i\\n', '    ,input           branch_exec1_is_jmp_i\\n', '    ,input  [ 31:0]  branch_exec1_pc_i\\n', '    ,input           branch_d_exec1_request_i\\n', '    ,input  [ 31:0]  branch_d_exec1_pc_i\\n', '    ,input  [  1:0]  branch_d_exec1_priv_i\\n', '    ,input           branch_csr_request_i\\n', '    ,input  [ 31:0]  branch_csr_pc_i\\n', '    ,input  [  1:0]  branch_csr_priv_i\\n', '    ,input  [ 31:0]  writeback_exec0_value_i\\n', '    ,input  [ 31:0]  writeback_exec1_value_i\\n', '    ,input           writeback_mem_valid_i\\n', '    ,input  [ 31:0]  writeback_mem_value_i\\n', '    ,input  [  5:0]  writeback_mem_exception_i\\n', '    ,input  [ 31:0]  writeback_mul_value_i\\n', '    ,input           writeback_div_valid_i\\n', '    ,input  [ 31:0]  writeback_div_value_i\\n', '    ,input  [ 31:0]  csr_result_e1_value_i\\n', '    ,input           csr_result_e1_write_i\\n', '    ,input  [ 31:0]  csr_result_e1_wdata_i\\n', '    ,input  [  5:0]  csr_result_e1_exception_i\\n', '    ,input           lsu_stall_i\\n', '    ,input           take_interrupt_i\\n', '\\n', '    // Outputs\\n', '    ,output          fetch0_accept_o\\n', '    ,output          fetch1_accept_o\\n', '    ,output          branch_request_o\\n', '    ,output [ 31:0]  branch_pc_o\\n', '    ,output [  1:0]  branch_priv_o\\n', '    ,output          branch_info_request_o\\n', '    ,output          branch_info_is_taken_o\\n', '    ,output          branch_info_is_not_taken_o\\n', '    ,output [ 31:0]  branch_info_source_o\\n', '    ,output          branch_info_is_call_o\\n', '    ,output          branch_info_is_ret_o\\n', '    ,output          branch_info_is_jmp_o\\n', '    ,output [ 31:0]  branch_info_pc_o\\n', '    ,output          exec0_opcode_valid_o\\n', '    ,output          exec1_opcode_valid_o\\n', '    ,output          lsu_opcode_valid_o\\n', '    ,output          csr_opcode_valid_o\\n', '    ,output          mul_opcode_valid_o\\n', '    ,output          div_opcode_valid_o\\n', '    ,output [ 31:0]  opcode0_opcode_o\\n', '    ,output [ 31:0]  opcode0_pc_o\\n', '    ,output          opcode0_invalid_o\\n', '    ,output [  4:0]  opcode0_rd_idx_o\\n', '    ,output [  4:0]  opcode0_ra_idx_o\\n', '    ,output [  4:0]  opcode0_rb_idx_o\\n', '    ,output [ 31:0]  opcode0_ra_operand_o\\n', '    ,output [ 31:0]  opcode0_rb_operand_o\\n', '    ,output [ 31:0]  opcode1_opcode_o\\n', '    ,output [ 31:0]  opcode1_pc_o\\n', '    ,output          opcode1_invalid_o\\n', '    ,output [  4:0]  opcode1_rd_idx_o\\n', '    ,output [  4:0]  opcode1_ra_idx_o\\n', '    ,output [  4:0]  opcode1_rb_idx_o\\n', '    ,output [ 31:0]  opcode1_ra_operand_o\\n', '    ,output [ 31:0]  opcode1_rb_operand_o\\n', '    ,output [ 31:0]  lsu_opcode_opcode_o\\n', '    ,output [ 31:0]  lsu_opcode_pc_o\\n', '    ,output          lsu_opcode_invalid_o\\n', '    ,output [  4:0]  lsu_opcode_rd_idx_o\\n', '    ,output [  4:0]  lsu_opcode_ra_idx_o\\n', '    ,output [  4:0]  lsu_opcode_rb_idx_o\\n', '    ,output [ 31:0]  lsu_opcode_ra_operand_o\\n', '    ,output [ 31:0]  lsu_opcode_rb_operand_o\\n', '    ,output [ 31:0]  mul_opcode_opcode_o\\n', '    ,output [ 31:0]  mul_opcode_pc_o\\n', '    ,output          mul_opcode_invalid_o\\n', '    ,output [  4:0]  mul_opcode_rd_idx_o\\n', '    ,output [  4:0]  mul_opcode_ra_idx_o\\n', '    ,output [  4:0]  mul_opcode_rb_idx_o\\n', '    ,output [ 31:0]  mul_opcode_ra_operand_o\\n', '    ,output [ 31:0]  mul_opcode_rb_operand_o\\n', '    ,output [ 31:0]  csr_opcode_opcode_o\\n', '    ,output [ 31:0]  csr_opcode_pc_o\\n', '    ,output          csr_opcode_invalid_o\\n', '    ,output [  4:0]  csr_opcode_rd_idx_o\\n', '    ,output [  4:0]  csr_opcode_ra_idx_o\\n', '    ,output [  4:0]  csr_opcode_rb_idx_o\\n', '    ,output [ 31:0]  csr_opcode_ra_operand_o\\n', '    ,output [ 31:0]  csr_opcode_rb_operand_o\\n', '    ,output          csr_writeback_write_o\\n', '    ,output [ 11:0]  csr_writeback_waddr_o\\n', '    ,output [ 31:0]  csr_writeback_wdata_o\\n', '    ,output [  5:0]  csr_writeback_exception_o\\n', '    ,output [ 31:0]  csr_writeback_exception_pc_o\\n', '    ,output [ 31:0]  csr_writeback_exception_addr_o\\n', '    ,output          exec0_hold_o\\n', '    ,output          exec1_hold_o\\n', '    ,output          mul_hold_o\\n', '    ,output          interrupt_inhibit_o\\n', ');\\n', '\\n', '\\n', '\\n', '`include \"biriscv_defs.v\"\\n', '\\n', 'wire enable_dual_issue_w = SUPPORT_DUAL_ISSUE;\\n', 'wire enable_muldiv_w     = SUPPORT_MULDIV;\\n', 'wire enable_mul_bypass_w = SUPPORT_MUL_BYPASS;\\n', '\\n', 'wire stall_w;\\n', 'wire squash_w;\\n', '\\n', '//-------------------------------------------------------------\\n', '// PC\\n', '//-------------------------------------------------------------\\n', 'wire        single_issue_w;\\n', 'wire        dual_issue_w;\\n', 'reg  [31:0] pc_x_q;\\n', 'reg   [1:0] priv_x_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pc_x_q <= 32'b0;\\n\", 'else if (branch_csr_request_i)\\n', '    pc_x_q <= branch_csr_pc_i;\\n', 'else if (branch_d_exec1_request_i)\\n', '    pc_x_q <= branch_d_exec1_pc_i;\\n', 'else if (branch_d_exec0_request_i)\\n', '    pc_x_q <= branch_d_exec0_pc_i;\\n', 'else if (dual_issue_w)\\n', \"    pc_x_q <= pc_x_q + 32'd8;\\n\", 'else if (single_issue_w)\\n', \"    pc_x_q <= pc_x_q + 32'd4;\\n\", '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', '    priv_x_q <= `PRIV_MACHINE;\\n', 'else if (branch_csr_request_i)\\n', '    priv_x_q <= branch_csr_priv_i;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Issue Select\\n', '//-------------------------------------------------------------\\n', 'reg mispredicted_r;\\n', 'reg slot0_valid_r;\\n', 'reg slot1_valid_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', \"    mispredicted_r = 1'b0;\\n\", \"    slot0_valid_r  = 1'b0;\\n\", \"    slot1_valid_r  = 1'b0;\\n\", '\\n', '    // Flush due to CSR branch\\n', '    if (branch_csr_request_i || squash_w)\\n', '    begin\\n', \"        slot0_valid_r  = 1'b0;\\n\", \"        slot1_valid_r  = 1'b0;\\n\", '    end\\n', '    // Word 0 valid and expected PC (word 1 may also be valid)\\n', \"    else if (fetch0_valid_i && {fetch0_pc_i[31:2], 2'b0} == {pc_x_q[31:2], 2'b0})\\n\", \"        slot0_valid_r  = 1'b1;\\n\", '    // Word 1 valid and expected PC\\n', \"    else if (fetch1_valid_i && {fetch1_pc_i[31:2], 2'b0} == {pc_x_q[31:2], 2'b0})\\n\", \"        slot1_valid_r  = 1'b1;\\n\", '    // Neither word is the expected PC - must be a branch misprediction\\n', '    else if (fetch0_valid_i || fetch1_valid_i)\\n', \"        mispredicted_r = 1'b1;\\n\", 'end\\n', '\\n', '// Branch request (CSR branch - ecall, xret, or branch misprediction)\\n', '// Note: Correctly predicted branches are silent\\n', 'assign branch_request_o          = branch_csr_request_i | mispredicted_r;\\n', 'assign branch_pc_o               = branch_csr_request_i ? branch_csr_pc_i : pc_x_q;\\n', 'assign branch_priv_o             = branch_csr_request_i ? branch_csr_priv_i : priv_x_q;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Instruction Decoder\\n', '//-------------------------------------------------------------\\n', 'reg        opcode_a_valid_r;\\n', 'reg        opcode_b_valid_r;\\n', 'reg [1:0]  opcode_a_fault_r;\\n', 'reg [1:0]  opcode_b_fault_r;\\n', 'reg [31:0] opcode_a_r;\\n', 'reg [31:0] opcode_b_r;\\n', 'reg [31:0] opcode_a_pc_r;\\n', 'reg [31:0] opcode_b_pc_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', \"    opcode_a_r       = 32'b0;\\n\", \"    opcode_b_r       = 32'b0;\\n\", \"    opcode_a_valid_r = 1'b0;\\n\", \"    opcode_b_valid_r = 1'b0;\\n\", \"    opcode_a_fault_r = 2'b0;\\n\", \"    opcode_b_fault_r = 2'b0;\\n\", \"    opcode_a_pc_r    = 32'b0;\\n\", \"    opcode_b_pc_r    = 32'b0;\\n\", '\\n', '    // Word 0 (and possibly slot 1) are valid instructions\\n', '    if (slot0_valid_r)\\n', '    begin\\n', \"        opcode_a_valid_r = 1'b1;\\n\", '        opcode_b_valid_r = fetch1_valid_i;\\n', '        opcode_a_r       = fetch0_instr_i;\\n', '        opcode_a_pc_r    = fetch0_pc_i;\\n', '        opcode_a_fault_r = {fetch0_fault_page_i, fetch0_fault_fetch_i};\\n', '        opcode_b_r       = fetch1_instr_i;\\n', '        opcode_b_pc_r    = fetch1_pc_i;\\n', '        opcode_b_fault_r = {fetch1_fault_page_i, fetch1_fault_fetch_i};\\n', '    end\\n', '    // Word 1 valid - mux to first issue slot\\n', '    // Note: Some instruction types can only issue in slot0, hence this muxing\\n', '    else if (slot1_valid_r)\\n', '    begin\\n', \"        opcode_a_valid_r = 1'b1;\\n\", \"        opcode_b_valid_r = 1'b0;\\n\", '        opcode_a_r       = fetch1_instr_i;\\n', '        opcode_a_pc_r    = fetch1_pc_i;\\n', '        opcode_a_fault_r = {fetch1_fault_page_i, fetch1_fault_fetch_i};\\n', \"        opcode_b_r       = 32'b0;\\n\", \"        opcode_b_pc_r    = 32'b0;\\n\", \"        opcode_b_fault_r = 2'b0;\\n\", '    end\\n', 'end\\n', '\\n', 'wire [4:0] issue_a_ra_idx_w   = opcode_a_r[19:15];\\n', 'wire [4:0] issue_a_rb_idx_w   = opcode_a_r[24:20];\\n', 'wire [4:0] issue_a_rd_idx_w   = opcode_a_r[11:7];\\n', 'wire       issue_a_sb_alloc_w = (slot0_valid_r ? fetch0_instr_rd_valid_i : fetch1_instr_rd_valid_i);\\n', 'wire       issue_a_exec_w     = (slot0_valid_r ? fetch0_instr_exec_i     : fetch1_instr_exec_i);\\n', 'wire       issue_a_lsu_w      = (slot0_valid_r ? fetch0_instr_lsu_i      : fetch1_instr_lsu_i);\\n', 'wire       issue_a_branch_w   = (slot0_valid_r ? fetch0_instr_branch_i   : fetch1_instr_branch_i);\\n', 'wire       issue_a_mul_w      = (slot0_valid_r ? fetch0_instr_mul_i      : fetch1_instr_mul_i);\\n', 'wire       issue_a_div_w      = (slot0_valid_r ? fetch0_instr_div_i      : fetch1_instr_div_i);\\n', 'wire       issue_a_csr_w      = (slot0_valid_r ? fetch0_instr_csr_i      : fetch1_instr_csr_i);\\n', 'wire       issue_a_invalid_w  = (slot0_valid_r ? fetch0_instr_invalid_i  : fetch1_instr_invalid_i);\\n', '\\n', '\\n', 'wire [4:0] issue_b_ra_idx_w   = opcode_b_r[19:15];\\n', 'wire [4:0] issue_b_rb_idx_w   = opcode_b_r[24:20];\\n', 'wire [4:0] issue_b_rd_idx_w   = opcode_b_r[11:7];\\n', 'wire       issue_b_sb_alloc_w = fetch1_instr_rd_valid_i;\\n', 'wire       issue_b_exec_w     = fetch1_instr_exec_i;\\n', 'wire       issue_b_lsu_w      = fetch1_instr_lsu_i;\\n', 'wire       issue_b_branch_w   = fetch1_instr_branch_i;\\n', 'wire       issue_b_mul_w      = fetch1_instr_mul_i;\\n', 'wire       issue_b_div_w      = fetch1_instr_div_i;\\n', 'wire       issue_b_csr_w      = fetch1_instr_csr_i;\\n', 'wire       issue_b_invalid_w  = fetch1_instr_invalid_i;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Pipe0 - Status tracking\\n', '//------------------------------------------------------------- \\n', 'wire        pipe0_squash_e1_e2_w;\\n', 'wire        pipe1_squash_e1_e2_w;\\n', '\\n', 'reg         opcode_a_issue_r;\\n', 'reg         opcode_a_accept_r;\\n', 'wire        pipe0_stall_raw_w;\\n', '\\n', 'wire        pipe0_load_e1_w;\\n', 'wire        pipe0_store_e1_w;\\n', 'wire        pipe0_mul_e1_w;\\n', 'wire        pipe0_branch_e1_w;\\n', 'wire [4:0]  pipe0_rd_e1_w;\\n', '\\n', 'wire [31:0] pipe0_pc_e1_w;\\n', 'wire [31:0] pipe0_opcode_e1_w;\\n', 'wire [31:0] pipe0_operand_ra_e1_w;\\n', 'wire [31:0] pipe0_operand_rb_e1_w;\\n', '\\n', 'wire        pipe0_load_e2_w;\\n', 'wire        pipe0_mul_e2_w;\\n', 'wire [4:0]  pipe0_rd_e2_w;\\n', 'wire [31:0] pipe0_result_e2_w;\\n', '\\n', 'wire        pipe0_valid_wb_w;\\n', 'wire        pipe0_csr_wb_w;\\n', 'wire [4:0]  pipe0_rd_wb_w;\\n', 'wire [31:0] pipe0_result_wb_w;\\n', 'wire [31:0] pipe0_pc_wb_w;\\n', 'wire [31:0] pipe0_opc_wb_w;\\n', 'wire [31:0] pipe0_ra_val_wb_w;\\n', 'wire [31:0] pipe0_rb_val_wb_w;\\n', 'wire [`EXCEPTION_W-1:0] pipe0_exception_wb_w;\\n', '\\n', 'wire [`EXCEPTION_W-1:0] issue_a_fault_w = opcode_a_fault_r[0] ? `EXCEPTION_FAULT_FETCH:\\n', \"                                          opcode_a_fault_r[1] ? `EXCEPTION_PAGE_FAULT_INST: `EXCEPTION_W'b0;\\n\", '\\n', 'biriscv_pipe_ctrl\\n', '#( \\n', '     .SUPPORT_LOAD_BYPASS(SUPPORT_LOAD_BYPASS)\\n', '    ,.SUPPORT_MUL_BYPASS(SUPPORT_MUL_BYPASS)\\n', ')\\n', 'u_pipe0_ctrl\\n', '(\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)    \\n', '\\n', '    // Issue\\n', '    ,.issue_valid_i(opcode_a_issue_r)\\n', '    ,.issue_accept_i(opcode_a_accept_r)\\n', '    ,.issue_stall_i(stall_w)\\n', '    ,.issue_lsu_i(issue_a_lsu_w)\\n', '    ,.issue_csr_i(issue_a_csr_w)\\n', '    ,.issue_div_i(issue_a_div_w)\\n', '    ,.issue_mul_i(issue_a_mul_w)\\n', '    ,.issue_branch_i(issue_a_branch_w)\\n', '    ,.issue_rd_valid_i(issue_a_sb_alloc_w)\\n', '    ,.issue_rd_i(issue_a_rd_idx_w)\\n', '    ,.issue_exception_i(issue_a_fault_w)\\n', '    ,.issue_pc_i(opcode0_pc_o)\\n', '    ,.issue_opcode_i(opcode0_opcode_o)\\n', '    ,.issue_operand_ra_i(opcode0_ra_operand_o)\\n', '    ,.issue_operand_rb_i(opcode0_rb_operand_o)\\n', '    ,.issue_branch_taken_i(branch_d_exec0_request_i)\\n', '    ,.issue_branch_target_i(branch_d_exec0_pc_i)\\n', '    ,.take_interrupt_i(take_interrupt_i)\\n', '\\n', '    // Execution stage 1: ALU result\\n', '    ,.alu_result_e1_i(writeback_exec0_value_i)\\n', '    ,.csr_result_value_e1_i(csr_result_e1_value_i)\\n', '    ,.csr_result_write_e1_i(csr_result_e1_write_i)\\n', '    ,.csr_result_wdata_e1_i(csr_result_e1_wdata_i)\\n', '    ,.csr_result_exception_e1_i(csr_result_e1_exception_i)\\n', '\\n', '    // Execution stage 1\\n', '    ,.load_e1_o(pipe0_load_e1_w)\\n', '    ,.store_e1_o(pipe0_store_e1_w)\\n', '    ,.mul_e1_o(pipe0_mul_e1_w)\\n', '    ,.branch_e1_o(pipe0_branch_e1_w)\\n', '    ,.rd_e1_o(pipe0_rd_e1_w)\\n', '    ,.pc_e1_o(pipe0_pc_e1_w)\\n', '    ,.opcode_e1_o(pipe0_opcode_e1_w)\\n', '    ,.operand_ra_e1_o(pipe0_operand_ra_e1_w)\\n', '    ,.operand_rb_e1_o(pipe0_operand_rb_e1_w)\\n', '\\n', '    // Execution stage 2: Other results\\n', '    ,.mem_complete_i(writeback_mem_valid_i)\\n', '    ,.mem_result_e2_i(writeback_mem_value_i)\\n', '    ,.mem_exception_e2_i(writeback_mem_exception_i)\\n', '    ,.mul_result_e2_i(writeback_mul_value_i)\\n', '\\n', '    // Execution stage 2\\n', '    ,.load_e2_o(pipe0_load_e2_w)\\n', '    ,.mul_e2_o(pipe0_mul_e2_w)\\n', '    ,.rd_e2_o(pipe0_rd_e2_w)\\n', '    ,.result_e2_o(pipe0_result_e2_w)\\n', '\\n', '    ,.stall_o(pipe0_stall_raw_w)\\n', '    ,.squash_e1_e2_o(pipe0_squash_e1_e2_w)\\n', '    ,.squash_e1_e2_i(pipe1_squash_e1_e2_w)\\n', \"    ,.squash_wb_i(1'b0)\\n\", '\\n', '    // Out of pipe: Divide Result\\n', '    ,.div_complete_i(writeback_div_valid_i)\\n', '    ,.div_result_i(writeback_div_value_i)\\n', '\\n', '    // Commit\\n', '    ,.valid_wb_o(pipe0_valid_wb_w)\\n', '    ,.csr_wb_o(pipe0_csr_wb_w)\\n', '    ,.rd_wb_o(pipe0_rd_wb_w)\\n', '    ,.result_wb_o(pipe0_result_wb_w)\\n', '    ,.pc_wb_o(pipe0_pc_wb_w)\\n', '    ,.opcode_wb_o(pipe0_opc_wb_w)\\n', '    ,.operand_ra_wb_o(pipe0_ra_val_wb_w)\\n', '    ,.operand_rb_wb_o(pipe0_rb_val_wb_w)\\n', '    ,.exception_wb_o(pipe0_exception_wb_w)\\n', '    ,.csr_write_wb_o(csr_writeback_write_o)\\n', '    ,.csr_waddr_wb_o(csr_writeback_waddr_o)\\n', '    ,.csr_wdata_wb_o(csr_writeback_wdata_o)   \\n', ');\\n', '\\n', 'assign exec0_hold_o = stall_w;\\n', 'assign mul_hold_o   = stall_w;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Pipe1 - Status tracking\\n', '//-------------------------------------------------------------\\n', 'reg         opcode_b_issue_r;\\n', 'reg         opcode_b_accept_r;\\n', 'wire        pipe1_stall_raw_w;\\n', '\\n', 'wire        pipe1_load_e1_w;\\n', 'wire        pipe1_store_e1_w;\\n', 'wire        pipe1_mul_e1_w;\\n', 'wire        pipe1_branch_e1_w;\\n', 'wire [4:0]  pipe1_rd_e1_w;\\n', '\\n', 'wire [31:0] pipe1_pc_e1_w;\\n', 'wire [31:0] pipe1_opcode_e1_w;\\n', 'wire [31:0] pipe1_operand_ra_e1_w;\\n', 'wire [31:0] pipe1_operand_rb_e1_w;\\n', '\\n', 'wire        pipe1_load_e2_w;\\n', 'wire        pipe1_mul_e2_w;\\n', 'wire [4:0]  pipe1_rd_e2_w;\\n', 'wire [31:0] pipe1_result_e2_w;\\n', '\\n', 'wire        pipe1_valid_wb_w;\\n', 'wire [4:0]  pipe1_rd_wb_w;\\n', 'wire [31:0] pipe1_result_wb_w;\\n', 'wire [31:0] pipe1_pc_wb_w;\\n', 'wire [31:0] pipe1_opc_wb_w;\\n', 'wire [31:0] pipe1_ra_val_wb_w;\\n', 'wire [31:0] pipe1_rb_val_wb_w;\\n', 'wire [`EXCEPTION_W-1:0] pipe1_exception_wb_w;\\n', '\\n', 'wire [`EXCEPTION_W-1:0] issue_b_fault_w = opcode_b_fault_r[0] ? `EXCEPTION_FAULT_FETCH:\\n', \"                                          opcode_b_fault_r[1] ? `EXCEPTION_PAGE_FAULT_INST: `EXCEPTION_W'b0;\\n\", '\\n', 'biriscv_pipe_ctrl\\n', '#( \\n', '     .SUPPORT_LOAD_BYPASS(SUPPORT_LOAD_BYPASS)\\n', '    ,.SUPPORT_MUL_BYPASS(SUPPORT_MUL_BYPASS)\\n', ')\\n', 'u_pipe1_ctrl\\n', '(\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '\\n', '    // Issue\\n', '    ,.issue_valid_i(opcode_b_issue_r)\\n', '    ,.issue_accept_i(opcode_b_accept_r)\\n', '    ,.issue_stall_i(stall_w)\\n', '    ,.issue_lsu_i(issue_b_lsu_w)\\n', \"    ,.issue_csr_i(1'b0)\\n\", \"    ,.issue_div_i(1'b0)\\n\", '    ,.issue_mul_i(issue_b_mul_w)\\n', '    ,.issue_branch_i(issue_b_branch_w)\\n', '    ,.issue_rd_valid_i(issue_b_sb_alloc_w)\\n', '    ,.issue_rd_i(issue_b_rd_idx_w)\\n', '    ,.issue_exception_i(issue_b_fault_w)\\n', '    ,.issue_pc_i(opcode1_pc_o)\\n', '    ,.issue_opcode_i(opcode1_opcode_o)\\n', '    ,.issue_operand_ra_i(opcode1_ra_operand_o)\\n', '    ,.issue_operand_rb_i(opcode1_rb_operand_o)\\n', '    ,.issue_branch_taken_i(branch_d_exec1_request_i)\\n', '    ,.issue_branch_target_i(branch_d_exec1_pc_i)\\n', '    ,.take_interrupt_i(take_interrupt_i)\\n', '\\n', '    // Execution stage 1: ALU, CSR result\\n', '    ,.alu_result_e1_i(writeback_exec1_value_i)\\n', '    ,.csr_result_value_e1_i(csr_result_e1_value_i)\\n', '    ,.csr_result_write_e1_i(csr_result_e1_write_i)\\n', '    ,.csr_result_wdata_e1_i(csr_result_e1_wdata_i)\\n', '    ,.csr_result_exception_e1_i(csr_result_e1_exception_i)\\n', '\\n', '    // Execution stage 1\\n', '    ,.load_e1_o(pipe1_load_e1_w)\\n', '    ,.store_e1_o(pipe1_store_e1_w)\\n', '    ,.mul_e1_o(pipe1_mul_e1_w)\\n', '    ,.branch_e1_o(pipe1_branch_e1_w)\\n', '    ,.rd_e1_o(pipe1_rd_e1_w)\\n', '    ,.pc_e1_o(pipe1_pc_e1_w)\\n', '    ,.opcode_e1_o(pipe1_opcode_e1_w)\\n', '    ,.operand_ra_e1_o(pipe1_operand_ra_e1_w)\\n', '    ,.operand_rb_e1_o(pipe1_operand_rb_e1_w)\\n', '\\n', '    // Execution stage 2: Other results\\n', '    ,.mem_complete_i(writeback_mem_valid_i)\\n', '    ,.mem_result_e2_i(writeback_mem_value_i)\\n', '    ,.mem_exception_e2_i(writeback_mem_exception_i)\\n', '    ,.mul_result_e2_i(writeback_mul_value_i)\\n', '\\n', '    // Execution stage 2\\n', '    ,.load_e2_o(pipe1_load_e2_w)\\n', '    ,.mul_e2_o(pipe1_mul_e2_w)\\n', '    ,.rd_e2_o(pipe1_rd_e2_w)\\n', '    ,.result_e2_o(pipe1_result_e2_w)\\n', '\\n', '    ,.stall_o(pipe1_stall_raw_w)\\n', '    ,.squash_e1_e2_o(pipe1_squash_e1_e2_w)\\n', '    ,.squash_e1_e2_i(pipe0_squash_e1_e2_w)\\n', '    ,.squash_wb_i(pipe0_squash_e1_e2_w)\\n', '\\n', '    // Out of pipe: Divide Result\\n', '    ,.div_complete_i(writeback_div_valid_i)\\n', '    ,.div_result_i(writeback_div_value_i)\\n', '\\n', '    // Commit\\n', '    ,.valid_wb_o(pipe1_valid_wb_w)\\n', '    ,.csr_wb_o()\\n', '    ,.rd_wb_o(pipe1_rd_wb_w)\\n', '    ,.result_wb_o(pipe1_result_wb_w)\\n', '    ,.pc_wb_o(pipe1_pc_wb_w)\\n', '    ,.opcode_wb_o(pipe1_opc_wb_w)\\n', '    ,.operand_ra_wb_o(pipe1_ra_val_wb_w)\\n', '    ,.operand_rb_wb_o(pipe1_rb_val_wb_w)\\n', '    ,.exception_wb_o(pipe1_exception_wb_w)\\n', '    ,.csr_write_wb_o()\\n', '    ,.csr_waddr_wb_o()\\n', '    ,.csr_wdata_wb_o()\\n', ');\\n', '\\n', 'assign exec1_hold_o = stall_w;\\n', '\\n', 'assign csr_writeback_exception_o      = pipe0_exception_wb_w | pipe1_exception_wb_w;\\n', 'assign csr_writeback_exception_pc_o   = (|pipe0_exception_wb_w) ? pipe0_pc_wb_w     : pipe1_pc_wb_w;\\n', 'assign csr_writeback_exception_addr_o = (|pipe0_exception_wb_w) ? pipe0_result_wb_w : pipe1_result_wb_w;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Branch predictor info\\n', '//-------------------------------------------------------------\\n', '// This info is used to learn future prediction, and to correct \\n', '// BTB, BHT, GShare, RAS indexes on mispredictions.\\n', 'assign branch_info_request_o      = mispredicted_r;\\n', 'assign branch_info_is_taken_o     = (pipe1_branch_e1_w & branch_exec1_is_taken_i)     | (pipe0_branch_e1_w & branch_exec0_is_taken_i);\\n', 'assign branch_info_is_not_taken_o = (pipe1_branch_e1_w & branch_exec1_is_not_taken_i) | (pipe0_branch_e1_w & branch_exec0_is_not_taken_i);\\n', 'assign branch_info_is_call_o      = (pipe1_branch_e1_w & branch_exec1_is_call_i)      | (pipe0_branch_e1_w & branch_exec0_is_call_i);\\n', 'assign branch_info_is_ret_o       = (pipe1_branch_e1_w & branch_exec1_is_ret_i)       | (pipe0_branch_e1_w & branch_exec0_is_ret_i);\\n', 'assign branch_info_is_jmp_o       = (pipe1_branch_e1_w & branch_exec1_is_jmp_i)       | (pipe0_branch_e1_w & branch_exec0_is_jmp_i);\\n', 'assign branch_info_source_o       = (pipe1_branch_e1_w & branch_exec1_request_i)      ? branch_exec1_source_i : branch_exec0_source_i;\\n', 'assign branch_info_pc_o           = (pipe1_branch_e1_w & branch_exec1_request_i)      ? branch_exec1_pc_i     : branch_exec0_pc_i;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Blocking events (division, CSR unit access)\\n', '//-------------------------------------------------------------\\n', 'reg div_pending_q;\\n', 'reg csr_pending_q;\\n', '\\n', '// Division operations take 2 - 34 cycles and stall\\n', '// the pipeline (complete out-of-pipe) until completed.\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    div_pending_q <= 1'b0;\\n\", 'else if (pipe0_squash_e1_e2_w || pipe1_squash_e1_e2_w)\\n', \"    div_pending_q <= 1'b0;\\n\", 'else if (div_opcode_valid_o && issue_a_div_w)\\n', \"    div_pending_q <= 1'b1;\\n\", 'else if (writeback_div_valid_i)\\n', \"    div_pending_q <= 1'b0;\\n\", '\\n', '// CSR operations are infrequent - avoid any complications of pipelining them.\\n', '// These only take a 2-3 cycles anyway and may result in a pipe flush (e.g. ecall, ebreak..).\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    csr_pending_q <= 1'b0;\\n\", 'else if (pipe0_squash_e1_e2_w || pipe1_squash_e1_e2_w)\\n', \"    csr_pending_q <= 1'b0;\\n\", 'else if (csr_opcode_valid_o && issue_a_csr_w)\\n', \"    csr_pending_q <= 1'b1;\\n\", 'else if (pipe0_csr_wb_w)\\n', \"    csr_pending_q <= 1'b0;\\n\", '\\n', 'assign squash_w = pipe0_squash_e1_e2_w || pipe1_squash_e1_e2_w;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Issue / scheduling logic\\n', '//-------------------------------------------------------------\\n', 'reg [31:0] scoreboard_r;\\n', 'reg        pipe1_mux_lsu_r;\\n', 'reg        pipe1_mux_mul_r;\\n', '\\n', '// Check instructions can be issued in the second execution unit\\n', 'wire pipe1_ok_w      = issue_b_exec_w | issue_b_branch_w | issue_b_lsu_w | issue_b_mul_w;\\n', '\\n', '// Is this combination of instructions possible to execute concurrently.\\n', '// This excludes result dependencies which may also block secondary execution.\\n', 'wire dual_issue_ok_w =   enable_dual_issue_w &&  // Second pipe switched on\\n', '                         pipe1_ok_w &&           // Instruction 2 is possible on second exec unit\\n', '                        (((issue_a_exec_w | issue_a_lsu_w | issue_a_mul_w) && issue_b_exec_w)   ||\\n', '                         ((issue_a_exec_w | issue_a_lsu_w | issue_a_mul_w) && issue_b_branch_w) ||\\n', '                         ((issue_a_exec_w | issue_a_mul_w) && issue_b_lsu_w)                    ||\\n', '                         ((issue_a_exec_w | issue_a_lsu_w) && issue_b_mul_w)\\n', '                         ) && ~take_interrupt_i;\\n', '\\n', 'always @ *\\n', 'begin\\n', \"    opcode_a_issue_r     = 1'b0;\\n\", \"    opcode_b_issue_r     = 1'b0;\\n\", \"    opcode_a_accept_r    = 1'b0;\\n\", \"    opcode_b_accept_r    = 1'b0;\\n\", \"    scoreboard_r         = 32'b0;\\n\", \"    pipe1_mux_lsu_r      = 1'b0;\\n\", \"    pipe1_mux_mul_r      = 1'b0;\\n\", '\\n', '    // Execution units with >= 2 cycle latency\\n', '    if (SUPPORT_LOAD_BYPASS == 0)\\n', '    begin\\n', '        if (pipe0_load_e2_w)\\n', \"            scoreboard_r[pipe0_rd_e2_w] = 1'b1;\\n\", '        if (pipe1_load_e2_w)\\n', \"            scoreboard_r[pipe1_rd_e2_w] = 1'b1;\\n\", '    end\\n', '    if (SUPPORT_MUL_BYPASS == 0)\\n', '    begin\\n', '        if (pipe0_mul_e2_w)\\n', \"            scoreboard_r[pipe0_rd_e2_w] = 1'b1;\\n\", '        if (pipe1_mul_e2_w)\\n', \"            scoreboard_r[pipe1_rd_e2_w] = 1'b1;\\n\", '    end\\n', '\\n', '    // Execution units with >= 1 cycle latency (loads / multiply)\\n', '    if (pipe0_load_e1_w || pipe0_mul_e1_w)\\n', \"        scoreboard_r[pipe0_rd_e1_w] = 1'b1;\\n\", '    if (pipe1_load_e1_w || pipe1_mul_e1_w)\\n', \"        scoreboard_r[pipe1_rd_e1_w] = 1'b1;\\n\", '\\n', '    // Do not start multiply, division or CSR operation in the cycle after a load (leaving only ALU operations and branches)\\n', '    if ((pipe0_load_e1_w || pipe0_store_e1_w || pipe1_load_e1_w || pipe1_store_e1_w ) && (issue_a_mul_w || issue_a_div_w || issue_a_csr_w))\\n', \"        scoreboard_r = 32'hFFFFFFFF;\\n\", '\\n', '    // Stall - no issues...\\n', '    if (lsu_stall_i || stall_w || div_pending_q || csr_pending_q)\\n', '        ;\\n', '    // Primary slot (lsu, branch, alu, mul, div, csr)\\n', '    else if (opcode_a_valid_r &&\\n', '        !(scoreboard_r[issue_a_ra_idx_w] || \\n', '          scoreboard_r[issue_a_rb_idx_w] ||\\n', '          scoreboard_r[issue_a_rd_idx_w]))\\n', '    begin\\n', \"        opcode_a_issue_r  = 1'b1;\\n\", \"        opcode_a_accept_r = 1'b1;\\n\", '\\n', '        if (opcode_a_accept_r && issue_a_sb_alloc_w && (|issue_a_rd_idx_w))\\n', \"            scoreboard_r[issue_a_rd_idx_w] = 1'b1;\\n\", '    end\\n', '\\n', '    // Stall - no issues...\\n', '    if (lsu_stall_i || stall_w || div_pending_q || csr_pending_q)\\n', '        ;\\n', '    // Secondary Slot (lsu, branch, alu, mul)\\n', '    else if (dual_issue_ok_w && opcode_b_valid_r && opcode_a_accept_r &&\\n', '        !(scoreboard_r[issue_b_ra_idx_w] || \\n', '          scoreboard_r[issue_b_rb_idx_w] ||\\n', '          scoreboard_r[issue_b_rd_idx_w]))\\n', '    begin\\n', \"        opcode_b_issue_r  = 1'b1;\\n\", \"        opcode_b_accept_r = 1'b1;\\n\", '        pipe1_mux_lsu_r   = issue_b_lsu_w;\\n', '        pipe1_mux_mul_r   = issue_b_mul_w;\\n', '\\n', '        if (opcode_b_accept_r && issue_b_sb_alloc_w && (|issue_b_rd_idx_w))\\n', \"            scoreboard_r[issue_b_rd_idx_w] = 1'b1;\\n\", '    end    \\n', 'end\\n', '\\n', 'assign lsu_opcode_valid_o   = (pipe1_mux_lsu_r ? opcode_b_issue_r : opcode_a_issue_r) & ~take_interrupt_i;\\n', 'assign exec0_opcode_valid_o = opcode_a_issue_r;\\n', 'assign mul_opcode_valid_o   = enable_muldiv_w & (pipe1_mux_mul_r ? opcode_b_issue_r : opcode_a_issue_r);\\n', 'assign div_opcode_valid_o   = enable_muldiv_w & (opcode_a_issue_r);\\n', 'assign interrupt_inhibit_o  = csr_pending_q || issue_a_csr_w;\\n', '\\n', 'assign exec1_opcode_valid_o = opcode_b_issue_r;\\n', '\\n', 'assign dual_issue_w         = opcode_b_issue_r & opcode_b_accept_r & ~take_interrupt_i;\\n', 'assign single_issue_w       = (opcode_a_issue_r & opcode_a_accept_r) & ~dual_issue_w & ~take_interrupt_i;\\n', '\\n', 'assign fetch0_accept_o      = ((slot0_valid_r & opcode_a_accept_r) | slot1_valid_r) & ~take_interrupt_i;\\n', 'assign fetch1_accept_o      = ((slot1_valid_r & opcode_a_accept_r) | (opcode_b_accept_r)) & ~take_interrupt_i;\\n', '\\n', 'assign stall_w              = pipe0_stall_raw_w | pipe1_stall_raw_w;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Register File\\n', '//------------------------------------------------------------- \\n', 'wire [31:0] issue_a_ra_value_w;\\n', 'wire [31:0] issue_a_rb_value_w;\\n', 'wire [31:0] issue_b_ra_value_w;\\n', 'wire [31:0] issue_b_rb_value_w;\\n', '\\n', '// Register file: 2W4R\\n', 'biriscv_regfile\\n', '#(\\n', '     .SUPPORT_REGFILE_XILINX(SUPPORT_REGFILE_XILINX)\\n', '    ,.SUPPORT_DUAL_ISSUE(SUPPORT_DUAL_ISSUE)\\n', ')\\n', 'u_regfile\\n', '(\\n', '    .clk_i(clk_i),\\n', '    .rst_i(rst_i),\\n', '\\n', '    // Write ports\\n', '    .rd0_i(pipe0_rd_wb_w),\\n', '    .rd0_value_i(pipe0_result_wb_w),\\n', '    .rd1_i(pipe1_rd_wb_w),\\n', '    .rd1_value_i(pipe1_result_wb_w),\\n', '\\n', '    // Read ports\\n', '    .ra0_i(issue_a_ra_idx_w),\\n', '    .rb0_i(issue_a_rb_idx_w),\\n', '    .ra0_value_o(issue_a_ra_value_w),\\n', '    .rb0_value_o(issue_a_rb_value_w),\\n', '\\n', '    .ra1_i(issue_b_ra_idx_w),\\n', '    .rb1_i(issue_b_rb_idx_w),\\n', '    .ra1_value_o(issue_b_ra_value_w),\\n', '    .rb1_value_o(issue_b_rb_value_w)    \\n', ');\\n', '\\n', '//-------------------------------------------------------------\\n', '// Issue Slot 0\\n', '//------------------------------------------------------------- \\n', 'assign opcode0_opcode_o = opcode_a_r;\\n', 'assign opcode0_pc_o     = opcode_a_pc_r;\\n', 'assign opcode0_rd_idx_o = issue_a_rd_idx_w;\\n', 'assign opcode0_ra_idx_o = issue_a_ra_idx_w;\\n', 'assign opcode0_rb_idx_o = issue_a_rb_idx_w;\\n', \"assign opcode0_invalid_o= 1'b0; \\n\", '\\n', 'reg [31:0] issue_a_ra_value_r;\\n', 'reg [31:0] issue_a_rb_value_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', '    // NOTE: Newest version of operand takes priority\\n', '    issue_a_ra_value_r = issue_a_ra_value_w;\\n', '    issue_a_rb_value_r = issue_a_rb_value_w;\\n', '\\n', '    // Bypass - WB\\n', '    if (pipe0_rd_wb_w == issue_a_ra_idx_w)\\n', '        issue_a_ra_value_r = pipe0_result_wb_w;\\n', '    if (pipe0_rd_wb_w == issue_a_rb_idx_w)\\n', '        issue_a_rb_value_r = pipe0_result_wb_w;\\n', '\\n', '    if (pipe1_rd_wb_w == issue_a_ra_idx_w)\\n', '        issue_a_ra_value_r = pipe1_result_wb_w;\\n', '    if (pipe1_rd_wb_w == issue_a_rb_idx_w)\\n', '        issue_a_rb_value_r = pipe1_result_wb_w;\\n', '\\n', '    // Bypass - E2\\n', '    if (pipe0_rd_e2_w == issue_a_ra_idx_w)\\n', '        issue_a_ra_value_r = pipe0_result_e2_w;\\n', '    if (pipe0_rd_e2_w == issue_a_rb_idx_w)\\n', '        issue_a_rb_value_r = pipe0_result_e2_w;\\n', '\\n', '    if (pipe1_rd_e2_w == issue_a_ra_idx_w)\\n', '        issue_a_ra_value_r = pipe1_result_e2_w;\\n', '    if (pipe1_rd_e2_w == issue_a_rb_idx_w)\\n', '        issue_a_rb_value_r = pipe1_result_e2_w;\\n', '\\n', '    // Bypass - E1\\n', '    if (pipe0_rd_e1_w == issue_a_ra_idx_w)\\n', '        issue_a_ra_value_r = writeback_exec0_value_i;\\n', '    if (pipe0_rd_e1_w == issue_a_rb_idx_w)\\n', '        issue_a_rb_value_r = writeback_exec0_value_i;\\n', '\\n', '    if (pipe1_rd_e1_w == issue_a_ra_idx_w)\\n', '        issue_a_ra_value_r = writeback_exec1_value_i;\\n', '    if (pipe1_rd_e1_w == issue_a_rb_idx_w)\\n', '        issue_a_rb_value_r = writeback_exec1_value_i;\\n', '\\n', '    // Reg 0 source\\n', \"    if (issue_a_ra_idx_w == 5'b0)\\n\", \"        issue_a_ra_value_r = 32'b0;\\n\", \"    if (issue_a_rb_idx_w == 5'b0)\\n\", \"        issue_a_rb_value_r = 32'b0;\\n\", 'end\\n', '\\n', 'assign opcode0_ra_operand_o = issue_a_ra_value_r;\\n', 'assign opcode0_rb_operand_o = issue_a_rb_value_r;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Issue Slot 1\\n', '//------------------------------------------------------------- \\n', 'assign opcode1_opcode_o = opcode_b_r;\\n', 'assign opcode1_pc_o     = opcode_b_pc_r;\\n', 'assign opcode1_rd_idx_o = issue_b_rd_idx_w;\\n', 'assign opcode1_ra_idx_o = issue_b_ra_idx_w;\\n', 'assign opcode1_rb_idx_o = issue_b_rb_idx_w;\\n', \"assign opcode1_invalid_o= 1'b0;\\n\", '\\n', 'reg [31:0] issue_b_ra_value_r;\\n', 'reg [31:0] issue_b_rb_value_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', '    // NOTE: Newest version of operand takes priority\\n', '    issue_b_ra_value_r = issue_b_ra_value_w;\\n', '    issue_b_rb_value_r = issue_b_rb_value_w;\\n', '\\n', '    // Bypass - WB\\n', '    if (pipe0_rd_wb_w == issue_b_ra_idx_w)\\n', '        issue_b_ra_value_r = pipe0_result_wb_w;\\n', '    if (pipe0_rd_wb_w == issue_b_rb_idx_w)\\n', '        issue_b_rb_value_r = pipe0_result_wb_w;\\n', '\\n', '    if (pipe1_rd_wb_w == issue_b_ra_idx_w)\\n', '        issue_b_ra_value_r = pipe1_result_wb_w;\\n', '    if (pipe1_rd_wb_w == issue_b_rb_idx_w)\\n', '        issue_b_rb_value_r = pipe1_result_wb_w;\\n', '\\n', '    // Bypass - E2\\n', '    if (pipe0_rd_e2_w == issue_b_ra_idx_w)\\n', '        issue_b_ra_value_r = pipe0_result_e2_w;\\n', '    if (pipe0_rd_e2_w == issue_b_rb_idx_w)\\n', '        issue_b_rb_value_r = pipe0_result_e2_w;\\n', '\\n', '    if (pipe1_rd_e2_w == issue_b_ra_idx_w)\\n', '        issue_b_ra_value_r = pipe1_result_e2_w;\\n', '    if (pipe1_rd_e2_w == issue_b_rb_idx_w)\\n', '        issue_b_rb_value_r = pipe1_result_e2_w;\\n', '\\n', '    // Bypass - E1\\n', '    if (pipe0_rd_e1_w == issue_b_ra_idx_w)\\n', '        issue_b_ra_value_r = writeback_exec0_value_i;\\n', '    if (pipe0_rd_e1_w == issue_b_rb_idx_w)\\n', '        issue_b_rb_value_r = writeback_exec0_value_i;\\n', '\\n', '    if (pipe1_rd_e1_w == issue_b_ra_idx_w)\\n', '        issue_b_ra_value_r = writeback_exec1_value_i;\\n', '    if (pipe1_rd_e1_w == issue_b_rb_idx_w)\\n', '        issue_b_rb_value_r = writeback_exec1_value_i;\\n', '\\n', '    // Reg 0 source\\n', \"    if (issue_b_ra_idx_w == 5'b0)\\n\", \"        issue_b_ra_value_r = 32'b0;\\n\", \"    if (issue_b_rb_idx_w == 5'b0)\\n\", \"        issue_b_rb_value_r = 32'b0;\\n\", 'end\\n', '\\n', 'assign opcode1_ra_operand_o = issue_b_ra_value_r;\\n', 'assign opcode1_rb_operand_o = issue_b_rb_value_r;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Load store unit\\n', '//-------------------------------------------------------------\\n', 'assign lsu_opcode_opcode_o      = pipe1_mux_lsu_r ? opcode1_opcode_o     : opcode0_opcode_o;\\n', 'assign lsu_opcode_pc_o          = pipe1_mux_lsu_r ? opcode1_pc_o         : opcode0_pc_o;\\n', 'assign lsu_opcode_rd_idx_o      = pipe1_mux_lsu_r ? opcode1_rd_idx_o     : opcode0_rd_idx_o;\\n', 'assign lsu_opcode_ra_idx_o      = pipe1_mux_lsu_r ? opcode1_ra_idx_o     : opcode0_ra_idx_o;\\n', 'assign lsu_opcode_rb_idx_o      = pipe1_mux_lsu_r ? opcode1_rb_idx_o     : opcode0_rb_idx_o;\\n', 'assign lsu_opcode_ra_operand_o  = pipe1_mux_lsu_r ? opcode1_ra_operand_o : opcode0_ra_operand_o;\\n', 'assign lsu_opcode_rb_operand_o  = pipe1_mux_lsu_r ? opcode1_rb_operand_o : opcode0_rb_operand_o;\\n', \"assign lsu_opcode_invalid_o     = 1'b0;\\n\", '\\n', '//-------------------------------------------------------------\\n', '// Multiply\\n', '//-------------------------------------------------------------\\n', 'assign mul_opcode_opcode_o      = pipe1_mux_mul_r ? opcode1_opcode_o     : opcode0_opcode_o;\\n', 'assign mul_opcode_pc_o          = pipe1_mux_mul_r ? opcode1_pc_o         : opcode0_pc_o;\\n', 'assign mul_opcode_rd_idx_o      = pipe1_mux_mul_r ? opcode1_rd_idx_o     : opcode0_rd_idx_o;\\n', 'assign mul_opcode_ra_idx_o      = pipe1_mux_mul_r ? opcode1_ra_idx_o     : opcode0_ra_idx_o;\\n', 'assign mul_opcode_rb_idx_o      = pipe1_mux_mul_r ? opcode1_rb_idx_o     : opcode0_rb_idx_o;\\n', 'assign mul_opcode_ra_operand_o  = pipe1_mux_mul_r ? opcode1_ra_operand_o : opcode0_ra_operand_o;\\n', 'assign mul_opcode_rb_operand_o  = pipe1_mux_mul_r ? opcode1_rb_operand_o : opcode0_rb_operand_o;\\n', \"assign mul_opcode_invalid_o     = 1'b0;\\n\", '\\n', '//-------------------------------------------------------------\\n', '// CSR unit\\n', '//-------------------------------------------------------------\\n', 'assign csr_opcode_valid_o       = opcode_a_issue_r & ~take_interrupt_i;\\n', 'assign csr_opcode_opcode_o      = opcode0_opcode_o;\\n', 'assign csr_opcode_pc_o          = opcode0_pc_o;\\n', 'assign csr_opcode_rd_idx_o      = opcode0_rd_idx_o;\\n', 'assign csr_opcode_ra_idx_o      = opcode0_ra_idx_o;\\n', 'assign csr_opcode_rb_idx_o      = opcode0_rb_idx_o;\\n', 'assign csr_opcode_ra_operand_o  = opcode0_ra_operand_o;\\n', 'assign csr_opcode_rb_operand_o  = opcode0_rb_operand_o;\\n', 'assign csr_opcode_invalid_o     = opcode_a_issue_r && issue_a_invalid_w;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Checker Interface\\n', '//-------------------------------------------------------------\\n', '`ifdef verilator\\n', 'biriscv_trace_sim\\n', 'u_pipe0_dec0_verif\\n', '(\\n', '     .valid_i(pipe0_valid_wb_w)\\n', '    ,.pc_i(pipe0_pc_wb_w)\\n', '    ,.opcode_i(pipe0_opc_wb_w)\\n', ');\\n', '\\n', 'wire [4:0] v_pipe0_rs1_w = pipe0_opc_wb_w[19:15];\\n', 'wire [4:0] v_pipe0_rs2_w = pipe0_opc_wb_w[24:20];\\n', '\\n', 'function [0:0] complete_valid0; /*verilator public*/\\n', 'begin\\n', '    complete_valid0 = pipe0_valid_wb_w;\\n', 'end\\n', 'endfunction\\n', 'function [31:0] complete_pc0; /*verilator public*/\\n', 'begin\\n', '    complete_pc0 = pipe0_pc_wb_w;\\n', 'end\\n', 'endfunction\\n', 'function [31:0] complete_opcode0; /*verilator public*/\\n', 'begin\\n', '    complete_opcode0 = pipe0_opc_wb_w;\\n', 'end\\n', 'endfunction\\n', 'function [4:0] complete_ra0; /*verilator public*/\\n', 'begin\\n', '    complete_ra0 = v_pipe0_rs1_w;\\n', 'end\\n', 'endfunction\\n', 'function [4:0] complete_rb0; /*verilator public*/\\n', 'begin\\n', '    complete_rb0 = v_pipe0_rs2_w;\\n', 'end\\n', 'endfunction\\n', 'function [4:0] complete_rd0; /*verilator public*/\\n', 'begin\\n', '    complete_rd0 = pipe0_rd_wb_w;\\n', 'end\\n', 'endfunction\\n', 'function [31:0] complete_ra_val0; /*verilator public*/\\n', 'begin\\n', '    complete_ra_val0 = pipe0_ra_val_wb_w;\\n', 'end\\n', 'endfunction\\n', 'function [31:0] complete_rb_val0; /*verilator public*/\\n', 'begin\\n', '    complete_rb_val0 = pipe0_rb_val_wb_w;\\n', 'end\\n', 'endfunction\\n', 'function [31:0] complete_rd_val0; /*verilator public*/\\n', 'begin\\n', '    if (|pipe0_rd_wb_w)\\n', '        complete_rd_val0 = pipe0_result_wb_w;\\n', '    else\\n', \"        complete_rd_val0 = 32'b0;\\n\", 'end\\n', 'endfunction\\n', '\\n', 'biriscv_trace_sim\\n', 'u_pipe0_dec1_verif\\n', '(\\n', '     .valid_i(pipe1_valid_wb_w)\\n', '    ,.pc_i(pipe1_pc_wb_w)\\n', '    ,.opcode_i(pipe1_opc_wb_w)\\n', ');\\n', '\\n', 'wire [4:0] v_pipe1_rs1_w = pipe1_opc_wb_w[19:15];\\n', 'wire [4:0] v_pipe1_rs2_w = pipe1_opc_wb_w[24:20];\\n', '\\n', 'function [0:0] complete_valid1; /*verilator public*/\\n', 'begin\\n', '    complete_valid1 = pipe1_valid_wb_w;\\n', 'end\\n', 'endfunction\\n', 'function [31:0] complete_pc1; /*verilator public*/\\n', 'begin\\n', '    complete_pc1 = pipe1_pc_wb_w;\\n', 'end\\n', 'endfunction\\n', 'function [31:0] complete_opcode1; /*verilator public*/\\n', 'begin\\n', '    complete_opcode1 = pipe1_opc_wb_w;\\n', 'end\\n', 'endfunction\\n', 'function [4:0] complete_ra1; /*verilator public*/\\n', 'begin\\n', '    complete_ra1 = v_pipe1_rs1_w;\\n', 'end\\n', 'endfunction\\n', 'function [4:0] complete_rb1; /*verilator public*/\\n', 'begin\\n', '    complete_rb1 = v_pipe1_rs2_w;\\n', 'end\\n', 'endfunction\\n', 'function [4:0] complete_rd1; /*verilator public*/\\n', 'begin\\n', '    complete_rd1 = pipe1_rd_wb_w;\\n', 'end\\n', 'endfunction\\n', 'function [31:0] complete_ra_val1; /*verilator public*/\\n', 'begin\\n', '    complete_ra_val1 = pipe1_ra_val_wb_w;\\n', 'end\\n', 'endfunction\\n', 'function [31:0] complete_rb_val1; /*verilator public*/\\n', 'begin\\n', '    complete_rb_val1 = pipe1_rb_val_wb_w;\\n', 'end\\n', 'endfunction\\n', 'function [31:0] complete_rd_val1; /*verilator public*/\\n', 'begin\\n', '    if (|pipe1_rd_wb_w)\\n', '        complete_rd_val1 = pipe1_result_wb_w;\\n', '    else\\n', \"        complete_rd_val1 = 32'b0;\\n\", 'end\\n', 'endfunction\\n', 'function [5:0] complete_exception; /*verilator public*/\\n', 'begin\\n', '    complete_exception = pipe0_exception_wb_w | pipe1_exception_wb_w;\\n', 'end\\n', 'endfunction\\n', '`endif\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module biriscv_lsu\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter MEM_CACHE_ADDR_MIN = 0\\n', \"    ,parameter MEM_CACHE_ADDR_MAX = 32'hffffffff\\n\", ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           opcode_valid_i\\n', '    ,input  [ 31:0]  opcode_opcode_i\\n', '    ,input  [ 31:0]  opcode_pc_i\\n', '    ,input           opcode_invalid_i\\n', '    ,input  [  4:0]  opcode_rd_idx_i\\n', '    ,input  [  4:0]  opcode_ra_idx_i\\n', '    ,input  [  4:0]  opcode_rb_idx_i\\n', '    ,input  [ 31:0]  opcode_ra_operand_i\\n', '    ,input  [ 31:0]  opcode_rb_operand_i\\n', '    ,input  [ 31:0]  mem_data_rd_i\\n', '    ,input           mem_accept_i\\n', '    ,input           mem_ack_i\\n', '    ,input           mem_error_i\\n', '    ,input  [ 10:0]  mem_resp_tag_i\\n', '    ,input           mem_load_fault_i\\n', '    ,input           mem_store_fault_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  mem_addr_o\\n', '    ,output [ 31:0]  mem_data_wr_o\\n', '    ,output          mem_rd_o\\n', '    ,output [  3:0]  mem_wr_o\\n', '    ,output          mem_cacheable_o\\n', '    ,output [ 10:0]  mem_req_tag_o\\n', '    ,output          mem_invalidate_o\\n', '    ,output          mem_writeback_o\\n', '    ,output          mem_flush_o\\n', '    ,output          writeback_valid_o\\n', '    ,output [ 31:0]  writeback_value_o\\n', '    ,output [  5:0]  writeback_exception_o\\n', '    ,output          stall_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Includes\\n', '//-----------------------------------------------------------------\\n', '`include \"biriscv_defs.v\"\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers / Wires\\n', '//-----------------------------------------------------------------\\n', 'reg [ 31:0]  mem_addr_q;\\n', 'reg [ 31:0]  mem_data_wr_q;\\n', 'reg          mem_rd_q;\\n', 'reg [  3:0]  mem_wr_q;\\n', 'reg          mem_cacheable_q;\\n', 'reg          mem_invalidate_q;\\n', 'reg          mem_writeback_q;\\n', 'reg          mem_flush_q;\\n', 'reg          mem_unaligned_e1_q;\\n', 'reg          mem_unaligned_e2_q;\\n', '\\n', 'reg          mem_load_q;\\n', 'reg          mem_xb_q;\\n', 'reg          mem_xh_q;\\n', 'reg          mem_ls_q;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Outstanding Access Tracking\\n', '//-----------------------------------------------------------------\\n', 'reg pending_lsu_e2_q;\\n', '\\n', 'wire issue_lsu_e1_w    = (mem_rd_o || (|mem_wr_o) || mem_writeback_o || mem_invalidate_o || mem_flush_o) && mem_accept_i;\\n', 'wire complete_ok_e2_w  = mem_ack_i & ~mem_error_i;\\n', 'wire complete_err_e2_w = mem_ack_i & mem_error_i;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    pending_lsu_e2_q <= 1'b0;\\n\", 'else if (issue_lsu_e1_w)\\n', \"    pending_lsu_e2_q <= 1'b1;\\n\", 'else if (complete_ok_e2_w || complete_err_e2_w)\\n', \"    pending_lsu_e2_q <= 1'b0;\\n\", '\\n', '// Delay next instruction if outstanding response is late\\n', 'wire delay_lsu_e2_w = pending_lsu_e2_q && !complete_ok_e2_w;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Dummy Ack (unaligned access /E2)\\n', '//-----------------------------------------------------------------\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    mem_unaligned_e2_q <= 1'b0;\\n\", 'else\\n', '    mem_unaligned_e2_q <= mem_unaligned_e1_q & ~delay_lsu_e2_w;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Opcode decode\\n', '//-----------------------------------------------------------------\\n', '\\n', 'wire load_inst_w = (((opcode_opcode_i & `INST_LB_MASK) == `INST_LB)  || \\n', '                    ((opcode_opcode_i & `INST_LH_MASK) == `INST_LH)  || \\n', '                    ((opcode_opcode_i & `INST_LW_MASK) == `INST_LW)  || \\n', '                    ((opcode_opcode_i & `INST_LBU_MASK) == `INST_LBU) || \\n', '                    ((opcode_opcode_i & `INST_LHU_MASK) == `INST_LHU) || \\n', '                    ((opcode_opcode_i & `INST_LWU_MASK) == `INST_LWU));\\n', '\\n', 'wire load_signed_inst_w = (((opcode_opcode_i & `INST_LB_MASK) == `INST_LB)  || \\n', '                           ((opcode_opcode_i & `INST_LH_MASK) == `INST_LH)  || \\n', '                           ((opcode_opcode_i & `INST_LW_MASK) == `INST_LW));\\n', '\\n', 'wire store_inst_w = (((opcode_opcode_i & `INST_SB_MASK) == `INST_SB)  || \\n', '                     ((opcode_opcode_i & `INST_SH_MASK) == `INST_SH)  || \\n', '                     ((opcode_opcode_i & `INST_SW_MASK) == `INST_SW));\\n', '\\n', 'wire req_lb_w = ((opcode_opcode_i & `INST_LB_MASK) == `INST_LB) || ((opcode_opcode_i & `INST_LBU_MASK) == `INST_LBU);\\n', 'wire req_lh_w = ((opcode_opcode_i & `INST_LH_MASK) == `INST_LH) || ((opcode_opcode_i & `INST_LHU_MASK) == `INST_LHU);\\n', 'wire req_lw_w = ((opcode_opcode_i & `INST_LW_MASK) == `INST_LW) || ((opcode_opcode_i & `INST_LWU_MASK) == `INST_LWU);\\n', 'wire req_sb_w = ((opcode_opcode_i & `INST_LB_MASK) == `INST_SB);\\n', 'wire req_sh_w = ((opcode_opcode_i & `INST_LH_MASK) == `INST_SH);\\n', 'wire req_sw_w = ((opcode_opcode_i & `INST_LW_MASK) == `INST_SW);\\n', '\\n', 'wire req_sw_lw_w = ((opcode_opcode_i & `INST_SW_MASK) == `INST_SW) || ((opcode_opcode_i & `INST_LW_MASK) == `INST_LW) || ((opcode_opcode_i & `INST_LWU_MASK) == `INST_LWU);\\n', 'wire req_sh_lh_w = ((opcode_opcode_i & `INST_SH_MASK) == `INST_SH) || ((opcode_opcode_i & `INST_LH_MASK) == `INST_LH) || ((opcode_opcode_i & `INST_LHU_MASK) == `INST_LHU);\\n', '\\n', 'reg [31:0]  mem_addr_r;\\n', 'reg         mem_unaligned_r;\\n', 'reg [31:0]  mem_data_r;\\n', 'reg         mem_rd_r;\\n', 'reg [3:0]   mem_wr_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', \"    mem_addr_r      = 32'b0;\\n\", \"    mem_data_r      = 32'b0;\\n\", \"    mem_unaligned_r = 1'b0;\\n\", \"    mem_wr_r        = 4'b0;\\n\", \"    mem_rd_r        = 1'b0;\\n\", '\\n', '    if (opcode_valid_i && ((opcode_opcode_i & `INST_CSRRW_MASK) == `INST_CSRRW))\\n', '        mem_addr_r = opcode_ra_operand_i;\\n', '    else if (opcode_valid_i && load_inst_w)\\n', '        mem_addr_r = opcode_ra_operand_i + {{20{opcode_opcode_i[31]}}, opcode_opcode_i[31:20]};\\n', '    else\\n', '        mem_addr_r = opcode_ra_operand_i + {{20{opcode_opcode_i[31]}}, opcode_opcode_i[31:25], opcode_opcode_i[11:7]};\\n', '\\n', '    if (opcode_valid_i && req_sw_lw_w)\\n', \"        mem_unaligned_r = (mem_addr_r[1:0] != 2'b0);\\n\", '    else if (opcode_valid_i && req_sh_lh_w)\\n', '        mem_unaligned_r = mem_addr_r[0];\\n', '\\n', '    mem_rd_r = (opcode_valid_i && load_inst_w && !mem_unaligned_r);\\n', '\\n', '    if (opcode_valid_i && ((opcode_opcode_i & `INST_SW_MASK) == `INST_SW) && !mem_unaligned_r)\\n', '    begin\\n', '        mem_data_r  = opcode_rb_operand_i;\\n', \"        mem_wr_r    = 4'hF;\\n\", '    end\\n', '    else if (opcode_valid_i && ((opcode_opcode_i & `INST_SH_MASK) == `INST_SH) && !mem_unaligned_r)\\n', '    begin\\n', '        case (mem_addr_r[1:0])\\n', \"        2'h2 :\\n\", '        begin\\n', \"            mem_data_r  = {opcode_rb_operand_i[15:0],16'h0000};\\n\", \"            mem_wr_r    = 4'b1100;\\n\", '        end\\n', '        default :\\n', '        begin\\n', \"            mem_data_r  = {16'h0000,opcode_rb_operand_i[15:0]};\\n\", \"            mem_wr_r    = 4'b0011;\\n\", '        end\\n', '        endcase\\n', '    end\\n', '    else if (opcode_valid_i && ((opcode_opcode_i & `INST_SB_MASK) == `INST_SB))\\n', '    begin\\n', '        case (mem_addr_r[1:0])\\n', \"        2'h3 :\\n\", '        begin\\n', \"            mem_data_r  = {opcode_rb_operand_i[7:0],24'h000000};\\n\", \"            mem_wr_r    = 4'b1000;\\n\", '        end\\n', \"        2'h2 :\\n\", '        begin\\n', \"            mem_data_r  = {{8'h00,opcode_rb_operand_i[7:0]},16'h0000};\\n\", \"            mem_wr_r    = 4'b0100;\\n\", '        end\\n', \"        2'h1 :\\n\", '        begin\\n', \"            mem_data_r  = {{16'h0000,opcode_rb_operand_i[7:0]},8'h00};\\n\", \"            mem_wr_r    = 4'b0010;\\n\", '        end\\n', \"        2'h0 :\\n\", '        begin\\n', \"            mem_data_r  = {24'h000000,opcode_rb_operand_i[7:0]};\\n\", \"            mem_wr_r    = 4'b0001;\\n\", '        end\\n', '        default :\\n', '        ;\\n', '        endcase\\n', '    end\\n', '    else\\n', \"        mem_wr_r    = 4'b0;\\n\", 'end\\n', '\\n', 'wire dcache_flush_w      = ((opcode_opcode_i & `INST_CSRRW_MASK) == `INST_CSRRW) && (opcode_opcode_i[31:20] == `CSR_DFLUSH);\\n', 'wire dcache_writeback_w  = ((opcode_opcode_i & `INST_CSRRW_MASK) == `INST_CSRRW) && (opcode_opcode_i[31:20] == `CSR_DWRITEBACK);\\n', 'wire dcache_invalidate_w = ((opcode_opcode_i & `INST_CSRRW_MASK) == `INST_CSRRW) && (opcode_opcode_i[31:20] == `CSR_DINVALIDATE);\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Sequential\\n', '//-----------------------------------------------------------------\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    mem_addr_q         <= 32'b0;\\n\", \"    mem_data_wr_q      <= 32'b0;\\n\", \"    mem_rd_q           <= 1'b0;\\n\", \"    mem_wr_q           <= 4'b0;\\n\", \"    mem_cacheable_q    <= 1'b0;\\n\", \"    mem_invalidate_q   <= 1'b0;\\n\", \"    mem_writeback_q    <= 1'b0;\\n\", \"    mem_flush_q        <= 1'b0;\\n\", \"    mem_unaligned_e1_q <= 1'b0;\\n\", \"    mem_load_q         <= 1'b0;\\n\", \"    mem_xb_q           <= 1'b0;\\n\", \"    mem_xh_q           <= 1'b0;\\n\", \"    mem_ls_q           <= 1'b0;\\n\", 'end\\n', '// Memory access fault - squash next operation (exception coming...)\\n', 'else if (complete_err_e2_w || mem_unaligned_e2_q)\\n', 'begin\\n', \"    mem_addr_q         <= 32'b0;\\n\", \"    mem_data_wr_q      <= 32'b0;\\n\", \"    mem_rd_q           <= 1'b0;\\n\", \"    mem_wr_q           <= 4'b0;\\n\", \"    mem_cacheable_q    <= 1'b0;\\n\", \"    mem_invalidate_q   <= 1'b0;\\n\", \"    mem_writeback_q    <= 1'b0;\\n\", \"    mem_flush_q        <= 1'b0;\\n\", \"    mem_unaligned_e1_q <= 1'b0;\\n\", \"    mem_load_q         <= 1'b0;\\n\", \"    mem_xb_q           <= 1'b0;\\n\", \"    mem_xh_q           <= 1'b0;\\n\", \"    mem_ls_q           <= 1'b0;\\n\", 'end\\n', 'else if ((mem_rd_q || (|mem_wr_q) || mem_unaligned_e1_q) && delay_lsu_e2_w)\\n', '    ;\\n', \"else if (!((mem_writeback_o || mem_invalidate_o || mem_flush_o || mem_rd_o || mem_wr_o != 4'b0) && !mem_accept_i))\\n\", 'begin\\n', \"    mem_addr_q         <= 32'b0;\\n\", '    mem_data_wr_q      <= mem_data_r;\\n', '    mem_rd_q           <= mem_rd_r;\\n', '    mem_wr_q           <= mem_wr_r;\\n', \"    mem_cacheable_q    <= 1'b0;\\n\", \"    mem_invalidate_q   <= 1'b0;\\n\", \"    mem_writeback_q    <= 1'b0;\\n\", \"    mem_flush_q        <= 1'b0;\\n\", '    mem_unaligned_e1_q <= mem_unaligned_r;\\n', '    mem_load_q         <= opcode_valid_i && load_inst_w;\\n', '    mem_xb_q           <= req_lb_w | req_sb_w;\\n', '    mem_xh_q           <= req_lh_w | req_sh_w;\\n', '    mem_ls_q           <= load_signed_inst_w;\\n', '\\n', '/* verilator lint_off UNSIGNED */\\n', '/* verilator lint_off CMPCONST */\\n', '    mem_cacheable_q  <= (mem_addr_r >= MEM_CACHE_ADDR_MIN && mem_addr_r <= MEM_CACHE_ADDR_MAX) ||\\n', '                        (opcode_valid_i && (dcache_invalidate_w || dcache_writeback_w || dcache_flush_w));\\n', '/* verilator lint_on CMPCONST */\\n', '/* verilator lint_on UNSIGNED */\\n', '\\n', '    mem_invalidate_q <= opcode_valid_i & dcache_invalidate_w;\\n', '    mem_writeback_q  <= opcode_valid_i & dcache_writeback_w;\\n', '    mem_flush_q      <= opcode_valid_i & dcache_flush_w;\\n', '    mem_addr_q       <= mem_addr_r;\\n', 'end\\n', '\\n', \"assign mem_addr_o       = {mem_addr_q[31:2], 2'b0};\\n\", 'assign mem_data_wr_o    = mem_data_wr_q;\\n', 'assign mem_rd_o         = mem_rd_q & ~delay_lsu_e2_w;\\n', 'assign mem_wr_o         = mem_wr_q & ~{4{delay_lsu_e2_w}};\\n', 'assign mem_cacheable_o  = mem_cacheable_q;\\n', \"assign mem_req_tag_o    = 11'b0;\\n\", 'assign mem_invalidate_o = mem_invalidate_q;\\n', 'assign mem_writeback_o  = mem_writeback_q;\\n', 'assign mem_flush_o      = mem_flush_q;\\n', '\\n', '// Stall upstream if cache is busy\\n', \"assign stall_o          = ((mem_writeback_o || mem_invalidate_o || mem_flush_o || mem_rd_o || mem_wr_o != 4'b0) && !mem_accept_i) || delay_lsu_e2_w || mem_unaligned_e1_q;\\n\", '\\n', 'wire        resp_load_w;\\n', 'wire [31:0] resp_addr_w;\\n', 'wire        resp_byte_w;\\n', 'wire        resp_half_w;\\n', 'wire        resp_signed_w;\\n', '\\n', 'biriscv_lsu_fifo\\n', '#(\\n', '     .WIDTH(36)\\n', '    ,.DEPTH(2)\\n', '    ,.ADDR_W(1)\\n', ')\\n', 'u_lsu_request\\n', '(\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '\\n', '    ,.push_i(((mem_rd_o || (|mem_wr_o) || mem_writeback_o || mem_invalidate_o || mem_flush_o) && mem_accept_i) || (mem_unaligned_e1_q && ~delay_lsu_e2_w))\\n', '    ,.data_in_i({mem_addr_q, mem_ls_q, mem_xh_q, mem_xb_q, mem_load_q})\\n', '    ,.accept_o()\\n', '\\n', '    ,.valid_o()\\n', '    ,.data_out_o({resp_addr_w, resp_signed_w, resp_half_w, resp_byte_w, resp_load_w})\\n', '    ,.pop_i(mem_ack_i || mem_unaligned_e2_q)\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Load response\\n', '//-----------------------------------------------------------------\\n', 'reg [1:0]  addr_lsb_r;\\n', 'reg        load_byte_r;\\n', 'reg        load_half_r;\\n', 'reg        load_signed_r;\\n', 'reg [31:0] wb_result_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', \"    wb_result_r   = 32'b0;\\n\", '\\n', '    // Tag associated with load\\n', '    addr_lsb_r    = resp_addr_w[1:0];\\n', '    load_byte_r   = resp_byte_w;\\n', '    load_half_r   = resp_half_w;\\n', '    load_signed_r = resp_signed_w;\\n', '\\n', '    // Access fault - pass badaddr on writeback result bus\\n', '    if ((mem_ack_i && mem_error_i) || mem_unaligned_e2_q)\\n', '        wb_result_r = resp_addr_w;\\n', '    // Handle responses\\n', '    else if (mem_ack_i && resp_load_w)\\n', '    begin\\n', '        if (load_byte_r)\\n', '        begin\\n', '            case (addr_lsb_r[1:0])\\n', \"            2'h3: wb_result_r = {24'b0, mem_data_rd_i[31:24]};\\n\", \"            2'h2: wb_result_r = {24'b0, mem_data_rd_i[23:16]};\\n\", \"            2'h1: wb_result_r = {24'b0, mem_data_rd_i[15:8]};\\n\", \"            2'h0: wb_result_r = {24'b0, mem_data_rd_i[7:0]};\\n\", '            endcase\\n', '\\n', '            if (load_signed_r && wb_result_r[7])\\n', \"                wb_result_r = {24'hFFFFFF, wb_result_r[7:0]};\\n\", '        end\\n', '        else if (load_half_r)\\n', '        begin\\n', '            if (addr_lsb_r[1])\\n', \"                wb_result_r = {16'b0, mem_data_rd_i[31:16]};\\n\", '            else\\n', \"                wb_result_r = {16'b0, mem_data_rd_i[15:0]};\\n\", '\\n', '            if (load_signed_r && wb_result_r[15])\\n', \"                wb_result_r = {16'hFFFF, wb_result_r[15:0]};\\n\", '        end\\n', '        else\\n', '            wb_result_r = mem_data_rd_i;\\n', '    end\\n', 'end\\n', '\\n', 'assign writeback_valid_o    = mem_ack_i | mem_unaligned_e2_q;\\n', 'assign writeback_value_o    = wb_result_r;\\n', '\\n', 'wire fault_load_align_w     = mem_unaligned_e2_q & resp_load_w;\\n', 'wire fault_store_align_w    = mem_unaligned_e2_q & ~resp_load_w;\\n', 'wire fault_load_bus_w       = mem_error_i &&  resp_load_w;\\n', 'wire fault_store_bus_w      = mem_error_i && ~resp_load_w;\\n', 'wire fault_load_page_w      = mem_error_i && mem_load_fault_i;\\n', 'wire fault_store_page_w     = mem_error_i && mem_store_fault_i;\\n', '\\n', '\\n', 'assign writeback_exception_o         = fault_load_align_w  ? `EXCEPTION_MISALIGNED_LOAD:\\n', '                                       fault_store_align_w ? `EXCEPTION_MISALIGNED_STORE:\\n', '                                       fault_load_page_w   ? `EXCEPTION_PAGE_FAULT_LOAD:\\n', '                                       fault_store_page_w  ? `EXCEPTION_PAGE_FAULT_STORE:\\n', '                                       fault_load_bus_w    ? `EXCEPTION_FAULT_LOAD:\\n', '                                       fault_store_bus_w   ? `EXCEPTION_FAULT_STORE:\\n', \"                                       `EXCEPTION_W'b0;\\n\", '\\n', 'endmodule \\n', '\\n', 'module biriscv_lsu_fifo\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '    parameter WIDTH   = 8,\\n', '    parameter DEPTH   = 4,\\n', '    parameter ADDR_W  = 2\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input               clk_i\\n', '    ,input               rst_i\\n', '    ,input  [WIDTH-1:0]  data_in_i\\n', '    ,input               push_i\\n', '    ,input               pop_i\\n', '\\n', '    // Outputs\\n', '    ,output [WIDTH-1:0]  data_out_o\\n', '    ,output              accept_o\\n', '    ,output              valid_o\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Local Params\\n', '//-----------------------------------------------------------------\\n', 'localparam COUNT_W = ADDR_W + 1;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers\\n', '//-----------------------------------------------------------------\\n', 'reg [WIDTH-1:0]   ram_q[DEPTH-1:0];\\n', 'reg [ADDR_W-1:0]  rd_ptr_q;\\n', 'reg [ADDR_W-1:0]  wr_ptr_q;\\n', 'reg [COUNT_W-1:0] count_q;\\n', '\\n', 'integer i;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Sequential\\n', '//-----------------------------------------------------------------\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    count_q   <= {(COUNT_W) {1'b0}};\\n\", \"    rd_ptr_q  <= {(ADDR_W) {1'b0}};\\n\", \"    wr_ptr_q  <= {(ADDR_W) {1'b0}};\\n\", '\\n', '    for (i=0;i<DEPTH;i=i+1)\\n', '    begin\\n', \"        ram_q[i] <= {(WIDTH) {1'b0}};\\n\", '    end\\n', 'end\\n', 'else\\n', 'begin\\n', '    // Push\\n', '    if (push_i & accept_o)\\n', '    begin\\n', '        ram_q[wr_ptr_q] <= data_in_i;\\n', '        wr_ptr_q        <= wr_ptr_q + 1;\\n', '    end\\n', '\\n', '    // Pop\\n', '    if (pop_i & valid_o)\\n', '        rd_ptr_q      <= rd_ptr_q + 1;\\n', '\\n', '    // Count up\\n', '    if ((push_i & accept_o) & ~(pop_i & valid_o))\\n', '        count_q <= count_q + 1;\\n', '    // Count down\\n', '    else if (~(push_i & accept_o) & (pop_i & valid_o))\\n', '        count_q <= count_q - 1;\\n', 'end\\n', '\\n', '//-------------------------------------------------------------------\\n', '// Combinatorial\\n', '//-------------------------------------------------------------------\\n', '/* verilator lint_off WIDTH */\\n', 'assign valid_o       = (count_q != 0);\\n', 'assign accept_o      = (count_q != DEPTH);\\n', '/* verilator lint_on WIDTH */\\n', '\\n', 'assign data_out_o    = ram_q[rd_ptr_q];\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module biriscv_mmu\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter MEM_CACHE_ADDR_MIN = 0\\n', \"    ,parameter MEM_CACHE_ADDR_MAX = 32'hffffffff\\n\", '    ,parameter SUPPORT_MMU      = 1\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input  [  1:0]  priv_d_i\\n', '    ,input           sum_i\\n', '    ,input           mxr_i\\n', '    ,input           flush_i\\n', '    ,input  [ 31:0]  satp_i\\n', '    ,input           fetch_in_rd_i\\n', '    ,input           fetch_in_flush_i\\n', '    ,input           fetch_in_invalidate_i\\n', '    ,input  [ 31:0]  fetch_in_pc_i\\n', '    ,input  [  1:0]  fetch_in_priv_i\\n', '    ,input           fetch_out_accept_i\\n', '    ,input           fetch_out_valid_i\\n', '    ,input           fetch_out_error_i\\n', '    ,input  [ 63:0]  fetch_out_inst_i\\n', '    ,input  [ 31:0]  lsu_in_addr_i\\n', '    ,input  [ 31:0]  lsu_in_data_wr_i\\n', '    ,input           lsu_in_rd_i\\n', '    ,input  [  3:0]  lsu_in_wr_i\\n', '    ,input           lsu_in_cacheable_i\\n', '    ,input  [ 10:0]  lsu_in_req_tag_i\\n', '    ,input           lsu_in_invalidate_i\\n', '    ,input           lsu_in_writeback_i\\n', '    ,input           lsu_in_flush_i\\n', '    ,input  [ 31:0]  lsu_out_data_rd_i\\n', '    ,input           lsu_out_accept_i\\n', '    ,input           lsu_out_ack_i\\n', '    ,input           lsu_out_error_i\\n', '    ,input  [ 10:0]  lsu_out_resp_tag_i\\n', '\\n', '    // Outputs\\n', '    ,output          fetch_in_accept_o\\n', '    ,output          fetch_in_valid_o\\n', '    ,output          fetch_in_error_o\\n', '    ,output [ 63:0]  fetch_in_inst_o\\n', '    ,output          fetch_out_rd_o\\n', '    ,output          fetch_out_flush_o\\n', '    ,output          fetch_out_invalidate_o\\n', '    ,output [ 31:0]  fetch_out_pc_o\\n', '    ,output          fetch_in_fault_o\\n', '    ,output [ 31:0]  lsu_in_data_rd_o\\n', '    ,output          lsu_in_accept_o\\n', '    ,output          lsu_in_ack_o\\n', '    ,output          lsu_in_error_o\\n', '    ,output [ 10:0]  lsu_in_resp_tag_o\\n', '    ,output [ 31:0]  lsu_out_addr_o\\n', '    ,output [ 31:0]  lsu_out_data_wr_o\\n', '    ,output          lsu_out_rd_o\\n', '    ,output [  3:0]  lsu_out_wr_o\\n', '    ,output          lsu_out_cacheable_o\\n', '    ,output [ 10:0]  lsu_out_req_tag_o\\n', '    ,output          lsu_out_invalidate_o\\n', '    ,output          lsu_out_writeback_o\\n', '    ,output          lsu_out_flush_o\\n', '    ,output          lsu_in_load_fault_o\\n', '    ,output          lsu_in_store_fault_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Includes\\n', '//-----------------------------------------------------------------\\n', '`include \"biriscv_defs.v\"\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Local defs\\n', '//-----------------------------------------------------------------\\n', 'localparam  STATE_W            = 2;\\n', 'localparam  STATE_IDLE         = 0;\\n', 'localparam  STATE_LEVEL_FIRST  = 1;\\n', 'localparam  STATE_LEVEL_SECOND = 2;\\n', 'localparam  STATE_UPDATE       = 3;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Basic MMU support\\n', '//-----------------------------------------------------------------\\n', 'generate\\n', 'if (SUPPORT_MMU)\\n', 'begin\\n', '\\n', '    //-----------------------------------------------------------------\\n', '    // Registers\\n', '    //-----------------------------------------------------------------\\n', '    reg [STATE_W-1:0] state_q;\\n', '    wire              idle_w = (state_q == STATE_IDLE);\\n', '\\n', '    // Magic combo used only by MMU\\n', \"    wire        resp_mmu_w   = (lsu_out_resp_tag_i[9:7] == 3'b111);\\n\", '    wire        resp_valid_w = resp_mmu_w & lsu_out_ack_i;\\n', '    wire        resp_error_w = resp_mmu_w & lsu_out_error_i;\\n', '    wire [31:0] resp_data_w  = lsu_out_data_rd_i;\\n', '\\n', '    wire        cpu_accept_w;\\n', '\\n', '    //-----------------------------------------------------------------\\n', '    // Load / Store\\n', '    //-----------------------------------------------------------------\\n', '    reg       load_q;\\n', '    reg [3:0] store_q;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', \"        load_q <= 1'b0;\\n\", '    else if (lsu_in_rd_i)\\n', '        load_q <= ~lsu_in_accept_o;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', \"        store_q <= 4'b0;\\n\", '    else if (|lsu_in_wr_i)\\n', \"        store_q <= lsu_in_accept_o ? 4'b0 : lsu_in_wr_i;\\n\", '\\n', '    wire       load_w  = lsu_in_rd_i | load_q;\\n', '    wire [3:0] store_w = lsu_in_wr_i | store_q;\\n', '\\n', '    reg [31:0] lsu_in_addr_q;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', \"        lsu_in_addr_q <= 32'b0;\\n\", '    else if (load_w || (|store_w))\\n', '        lsu_in_addr_q <= lsu_in_addr_i;\\n', '\\n', '    wire [31:0] lsu_addr_w = (load_w || (|store_w)) ? lsu_in_addr_i : lsu_in_addr_q;\\n', '\\n', '    //-----------------------------------------------------------------\\n', '    // Page table walker\\n', '    //-----------------------------------------------------------------\\n', '    wire        itlb_hit_w;\\n', '    wire        dtlb_hit_w;\\n', '\\n', '    reg         dtlb_req_q;\\n', '\\n', '    // Global enable\\n', '    wire        vm_enable_w = satp_i[`SATP_MODE_R];\\n', \"    wire [31:0] ptbr_w      = {satp_i[`SATP_PPN_R], 12'b0};\\n\", '\\n', '    wire        ifetch_vm_w = (fetch_in_priv_i != `PRIV_MACHINE);\\n', '    wire        dfetch_vm_w = (priv_d_i != `PRIV_MACHINE);\\n', '\\n', '    wire        supervisor_i_w = (fetch_in_priv_i == `PRIV_SUPER);\\n', '    wire        supervisor_d_w = (priv_d_i == `PRIV_SUPER);\\n', '\\n', '    wire        vm_i_enable_w = (ifetch_vm_w);\\n', '    wire        vm_d_enable_w = (vm_enable_w & dfetch_vm_w);\\n', '\\n', '    // TLB entry does not match request address\\n', '    wire        itlb_miss_w = fetch_in_rd_i & vm_i_enable_w & ~itlb_hit_w;\\n', '    wire        dtlb_miss_w = (load_w || (|store_w)) & vm_d_enable_w & ~dtlb_hit_w;\\n', '\\n', '    // Data miss is higher priority than instruction...\\n', '    wire [31:0] request_addr_w = idle_w ? \\n', '                                (dtlb_miss_w ? lsu_addr_w : fetch_in_pc_i) :\\n', '                                 dtlb_req_q ? lsu_addr_w : fetch_in_pc_i;\\n', '\\n', '    reg [31:0]  pte_addr_q;\\n', '    reg [31:0]  pte_entry_q;\\n', '    reg [31:0]  virt_addr_q;\\n', '\\n', \"    wire [31:0] pte_ppn_w   = {`PAGE_PFN_SHIFT'b0, resp_data_w[31:`PAGE_PFN_SHIFT]};\\n\", '    wire [9:0]  pte_flags_w = resp_data_w[9:0];\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', '    begin\\n', \"        pte_addr_q  <= 32'b0;\\n\", \"        pte_entry_q <= 32'b0;\\n\", \"        virt_addr_q <= 32'b0;\\n\", \"        dtlb_req_q  <= 1'b0;\\n\", '        state_q     <= STATE_IDLE;\\n', '    end\\n', '    else\\n', '    begin\\n', '        // TLB miss, walk page table\\n', '        if (state_q == STATE_IDLE && (itlb_miss_w || dtlb_miss_w))\\n', '        begin\\n', \"            pte_addr_q  <= ptbr_w + {20'b0, request_addr_w[31:22], 2'b0};\\n\", '            virt_addr_q <= request_addr_w;\\n', '            dtlb_req_q  <= dtlb_miss_w;\\n', '\\n', '            state_q     <= STATE_LEVEL_FIRST;\\n', '        end\\n', '        // First level (4MB superpage)\\n', '        else if (state_q == STATE_LEVEL_FIRST && resp_valid_w)\\n', '        begin\\n', '            // Error or page not present\\n', '            if (resp_error_w || !resp_data_w[`PAGE_PRESENT])\\n', '            begin\\n', \"                pte_entry_q <= 32'b0;\\n\", '                state_q     <= STATE_UPDATE;\\n', '            end\\n', '            // Valid entry, but another level to fetch\\n', '            else if (!(resp_data_w[`PAGE_READ] || resp_data_w[`PAGE_WRITE] || resp_data_w[`PAGE_EXEC]))\\n', '            begin\\n', \"                pte_addr_q  <= {resp_data_w[29:10], 12'b0} + {20'b0, request_addr_w[21:12], 2'b0};\\n\", '                state_q     <= STATE_LEVEL_SECOND;\\n', '            end\\n', '            // Valid entry, actual valid PTE\\n', '            else\\n', '            begin\\n', \"                pte_entry_q <= ((pte_ppn_w | {22'b0, request_addr_w[21:12]}) << `MMU_PGSHIFT) | {22'b0, pte_flags_w};\\n\", '                state_q     <= STATE_UPDATE;\\n', '            end\\n', '        end\\n', '        // Second level (4KB page)\\n', '        else if (state_q == STATE_LEVEL_SECOND && resp_valid_w)\\n', '        begin\\n', '            // Valid entry, final level\\n', '            if (resp_data_w[`PAGE_PRESENT])\\n', '            begin\\n', \"                pte_entry_q <= (pte_ppn_w << `MMU_PGSHIFT) | {22'b0, pte_flags_w};\\n\", '                state_q     <= STATE_UPDATE;\\n', '            end\\n', '            // Page fault\\n', '            else\\n', '            begin\\n', \"                pte_entry_q <= 32'b0;\\n\", '                state_q     <= STATE_UPDATE;\\n', '            end\\n', '        end\\n', '        else if (state_q == STATE_UPDATE)\\n', '        begin\\n', '            state_q    <= STATE_IDLE;\\n', '        end\\n', '    end\\n', '\\n', '    //-----------------------------------------------------------------\\n', '    // IMMU TLB\\n', '    //-----------------------------------------------------------------\\n', '    reg         itlb_valid_q;\\n', '    reg [31:12] itlb_va_addr_q;\\n', '    reg [31:0]  itlb_entry_q;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', \"        itlb_valid_q <= 1'b0;\\n\", '    else if (flush_i)\\n', \"        itlb_valid_q <= 1'b0;\\n\", '    else if (state_q == STATE_UPDATE && !dtlb_req_q)\\n', '        itlb_valid_q <= (itlb_va_addr_q == fetch_in_pc_i[31:12]); // Fetch TLB still matches incoming request\\n', '    else if (state_q != STATE_IDLE && !dtlb_req_q)\\n', \"        itlb_valid_q <= 1'b0;\\n\", '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', '    begin\\n', \"        itlb_va_addr_q <= 20'b0;\\n\", \"        itlb_entry_q   <= 32'b0;\\n\", '    end\\n', '    else if (state_q == STATE_UPDATE && !dtlb_req_q)\\n', '    begin\\n', '        itlb_va_addr_q <= virt_addr_q[31:12];\\n', '        itlb_entry_q   <= pte_entry_q;\\n', '    end\\n', '\\n', '    // TLB address matched (even on page fault)\\n', '    assign itlb_hit_w   = fetch_in_rd_i & itlb_valid_q & (itlb_va_addr_q == fetch_in_pc_i[31:12]);\\n', '\\n', '    reg pc_fault_r;\\n', '    always @ *\\n', '    begin\\n', \"        pc_fault_r = 1'b0;\\n\", '\\n', '        if (vm_i_enable_w && itlb_hit_w)\\n', '        begin\\n', '            // Supervisor mode\\n', '            if (supervisor_i_w)\\n', '            begin\\n', '                // User page, supervisor cannot execute\\n', '                if (itlb_entry_q[`PAGE_USER])\\n', \"                    pc_fault_r = 1'b1;\\n\", '                // Check exec permissions\\n', '                else\\n', '                    pc_fault_r = ~itlb_entry_q[`PAGE_EXEC];\\n', '            end\\n', '            // User mode\\n', '            else\\n', '                pc_fault_r = (~itlb_entry_q[`PAGE_EXEC]) | (~itlb_entry_q[`PAGE_USER]);\\n', '        end\\n', '    end\\n', '\\n', '    reg pc_fault_q;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', \"        pc_fault_q <= 1'b0;\\n\", '    else\\n', '        pc_fault_q <= pc_fault_r;\\n', '\\n', '    assign fetch_out_rd_o         = (~vm_i_enable_w & fetch_in_rd_i) || (itlb_hit_w & ~pc_fault_r);\\n', '    assign fetch_out_pc_o         = vm_i_enable_w ? {itlb_entry_q[31:12], fetch_in_pc_i[11:0]} : fetch_in_pc_i;\\n', '    assign fetch_out_flush_o      = fetch_in_flush_i;\\n', '    assign fetch_out_invalidate_o = fetch_in_invalidate_i; // TODO: ...\\n', '\\n', '    assign fetch_in_accept_o      = (~vm_i_enable_w & fetch_out_accept_i) | (vm_i_enable_w & itlb_hit_w & fetch_out_accept_i) | pc_fault_r;\\n', '    assign fetch_in_valid_o       = fetch_out_valid_i | pc_fault_q;\\n', '    assign fetch_in_error_o       = fetch_out_valid_i & fetch_out_error_i;\\n', '    assign fetch_in_fault_o       = pc_fault_q;\\n', '    assign fetch_in_inst_o        = fetch_out_inst_i;\\n', '\\n', '    //-----------------------------------------------------------------\\n', '    // DMMU TLB\\n', '    //-----------------------------------------------------------------\\n', '    reg         dtlb_valid_q;\\n', '    reg [31:12] dtlb_va_addr_q;\\n', '    reg [31:0]  dtlb_entry_q;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', \"        dtlb_valid_q <= 1'b0;\\n\", '    else if (flush_i)\\n', \"        dtlb_valid_q <= 1'b0;\\n\", '    else if (state_q == STATE_UPDATE && dtlb_req_q)\\n', \"        dtlb_valid_q <= 1'b1;\\n\", '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', '    begin\\n', \"        dtlb_va_addr_q <= 20'b0;\\n\", \"        dtlb_entry_q   <= 32'b0;\\n\", '    end\\n', '    else if (state_q == STATE_UPDATE && dtlb_req_q)\\n', '    begin\\n', '        dtlb_va_addr_q <= virt_addr_q[31:12];\\n', '        dtlb_entry_q   <= pte_entry_q;\\n', '    end\\n', '\\n', '    // TLB address matched (even on page fault)\\n', '    assign dtlb_hit_w   = dtlb_valid_q & (dtlb_va_addr_q == lsu_addr_w[31:12]);\\n', '\\n', '    reg load_fault_r;\\n', '    always @ *\\n', '    begin\\n', \"        load_fault_r = 1'b0;\\n\", '\\n', '        if (vm_d_enable_w && load_w && dtlb_hit_w)\\n', '        begin\\n', '            // Supervisor mode\\n', '            if (supervisor_d_w)\\n', '            begin\\n', '                // User page, supervisor user mode not enabled\\n', '                if (dtlb_entry_q[`PAGE_USER] && !sum_i)\\n', \"                    load_fault_r = 1'b1;\\n\", '                // Check exec permissions\\n', '                else\\n', '                    load_fault_r = ~(dtlb_entry_q[`PAGE_READ] | (mxr_i & dtlb_entry_q[`PAGE_EXEC]));\\n', '            end\\n', '            // User mode\\n', '            else\\n', '                load_fault_r = (~dtlb_entry_q[`PAGE_READ]) | (~dtlb_entry_q[`PAGE_USER]);\\n', '        end\\n', '    end\\n', '\\n', '    reg store_fault_r;\\n', '    always @ *\\n', '    begin\\n', \"        store_fault_r = 1'b0;\\n\", '\\n', '        if (vm_d_enable_w && (|store_w) && dtlb_hit_w)\\n', '        begin\\n', '            // Supervisor mode\\n', '            if (supervisor_d_w)\\n', '            begin\\n', '                // User page, supervisor user mode not enabled\\n', '                if (dtlb_entry_q[`PAGE_USER] && !sum_i)\\n', \"                    store_fault_r = 1'b1;\\n\", '                // Check exec permissions\\n', '                else\\n', '                    store_fault_r = (~dtlb_entry_q[`PAGE_READ]) | (~dtlb_entry_q[`PAGE_WRITE]);\\n', '            end\\n', '            // User mode\\n', '            else\\n', '                store_fault_r = (~dtlb_entry_q[`PAGE_READ]) | (~dtlb_entry_q[`PAGE_WRITE]) | (~dtlb_entry_q[`PAGE_USER]);\\n', '        end\\n', '    end\\n', '\\n', '    reg store_fault_q;\\n', '    reg load_fault_q;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', \"        store_fault_q <= 1'b0;\\n\", '    else\\n', '        store_fault_q <= store_fault_r;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', \"        load_fault_q <= 1'b0;\\n\", '    else\\n', '        load_fault_q <= load_fault_r;   \\n', '\\n', '    wire        lsu_out_rd_w         = vm_d_enable_w ? (load_w  & dtlb_hit_w & ~load_fault_r)       : lsu_in_rd_i;\\n', '    wire [3:0]  lsu_out_wr_w         = vm_d_enable_w ? (store_w & {4{dtlb_hit_w & ~store_fault_r}}) : lsu_in_wr_i;\\n', '    wire [31:0] lsu_out_addr_w       = vm_d_enable_w ? {dtlb_entry_q[31:12], lsu_addr_w[11:0]}      : lsu_addr_w;\\n', '    wire [31:0] lsu_out_data_wr_w    = lsu_in_data_wr_i;\\n', '\\n', '    wire        lsu_out_invalidate_w = lsu_in_invalidate_i;\\n', '    wire        lsu_out_writeback_w  = lsu_in_writeback_i;\\n', '\\n', '    reg         lsu_out_cacheable_r;\\n', '    always @ *\\n', '    begin\\n', '/* verilator lint_off UNSIGNED */\\n', '/* verilator lint_off CMPCONST */\\n', '        if (lsu_in_invalidate_i || lsu_in_writeback_i || lsu_in_flush_i)\\n', \"            lsu_out_cacheable_r = 1'b1;\\n\", '        else\\n', '            lsu_out_cacheable_r = (lsu_out_addr_w >= MEM_CACHE_ADDR_MIN && lsu_out_addr_w <= MEM_CACHE_ADDR_MAX);\\n', '/* verilator lint_on CMPCONST */\\n', '/* verilator lint_on UNSIGNED */\\n', '    end\\n', '\\n', '    wire [10:0] lsu_out_req_tag_w    = lsu_in_req_tag_i;\\n', '    wire        lsu_out_flush_w      = lsu_in_flush_i;\\n', '\\n', '    assign lsu_in_ack_o         = (lsu_out_ack_i & ~resp_mmu_w) | store_fault_q | load_fault_q;\\n', '    assign lsu_in_resp_tag_o    = lsu_out_resp_tag_i;\\n', '    assign lsu_in_error_o       = (lsu_out_error_i & ~resp_mmu_w) | store_fault_q | load_fault_q;\\n', '    assign lsu_in_data_rd_o     = lsu_out_data_rd_i;\\n', '    assign lsu_in_store_fault_o = store_fault_q;\\n', '    assign lsu_in_load_fault_o  = load_fault_q;\\n', '\\n', '    assign lsu_in_accept_o      = (~vm_d_enable_w & cpu_accept_w) | (vm_d_enable_w & dtlb_hit_w & cpu_accept_w) | store_fault_r | load_fault_r;\\n', '\\n', '    //-----------------------------------------------------------------\\n', '    // PTE Fetch Port\\n', '    //-----------------------------------------------------------------\\n', '    reg mem_req_q;\\n', '    wire mmu_accept_w;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', \"        mem_req_q <= 1'b0;\\n\", '    else if (state_q == STATE_IDLE && (itlb_miss_w || dtlb_miss_w))\\n', \"        mem_req_q <= 1'b1;\\n\", '    else if (state_q == STATE_LEVEL_FIRST && resp_valid_w && !resp_error_w && resp_data_w[`PAGE_PRESENT] && (!(resp_data_w[`PAGE_READ] || resp_data_w[`PAGE_WRITE] || resp_data_w[`PAGE_EXEC])))\\n', \"        mem_req_q <= 1'b1;    \\n\", '    else if (mmu_accept_w)\\n', \"        mem_req_q <= 1'b0;\\n\", '\\n', '    //-----------------------------------------------------------------\\n', '    // Request Muxing\\n', '    //-----------------------------------------------------------------\\n', '    reg  read_hold_q;\\n', '    reg  src_mmu_q;\\n', '    wire src_mmu_w = read_hold_q ? src_mmu_q : mem_req_q;\\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', '    begin\\n', \"        read_hold_q  <= 1'b0;\\n\", \"        src_mmu_q    <= 1'b0;\\n\", '    end\\n', '    else if ((lsu_out_rd_o || (|lsu_out_wr_o)) && !lsu_out_accept_i)\\n', '    begin\\n', \"        read_hold_q  <= 1'b1;\\n\", '        src_mmu_q    <= src_mmu_w;\\n', '    end\\n', '    else if (lsu_out_accept_i)\\n', \"        read_hold_q  <= 1'b0;\\n\", '\\n', '    assign mmu_accept_w         = src_mmu_w  & lsu_out_accept_i;\\n', '    assign cpu_accept_w         = ~src_mmu_w & lsu_out_accept_i;\\n', '\\n', '    assign lsu_out_rd_o         = src_mmu_w ? mem_req_q  : lsu_out_rd_w;\\n', \"    assign lsu_out_wr_o         = src_mmu_w ? 4'b0       : lsu_out_wr_w;\\n\", '    assign lsu_out_addr_o       = src_mmu_w ? pte_addr_q : lsu_out_addr_w;\\n', '    assign lsu_out_data_wr_o    = lsu_out_data_wr_w;\\n', '\\n', \"    assign lsu_out_invalidate_o = src_mmu_w ? 1'b0 : lsu_out_invalidate_w;\\n\", \"    assign lsu_out_writeback_o  = src_mmu_w ? 1'b0 : lsu_out_writeback_w;\\n\", \"    assign lsu_out_cacheable_o  = src_mmu_w ? 1'b1 : lsu_out_cacheable_r;\\n\", \"    assign lsu_out_req_tag_o    = src_mmu_w ? {1'b0, 3'b111, 7'b0} : lsu_out_req_tag_w;\\n\", \"    assign lsu_out_flush_o      = src_mmu_w ? 1'b0 : lsu_out_flush_w;\\n\", '\\n', 'end\\n', '//-----------------------------------------------------------------\\n', '// No MMU support\\n', '//-----------------------------------------------------------------\\n', 'else\\n', 'begin\\n', '    assign fetch_out_rd_o         = fetch_in_rd_i;\\n', '    assign fetch_out_pc_o         = fetch_in_pc_i;\\n', '    assign fetch_out_flush_o      = fetch_in_flush_i;\\n', '    assign fetch_out_invalidate_o = fetch_in_invalidate_i;\\n', '    assign fetch_in_accept_o      = fetch_out_accept_i;\\n', '    assign fetch_in_valid_o       = fetch_out_valid_i;\\n', '    assign fetch_in_error_o       = fetch_out_error_i;\\n', \"    assign fetch_in_fault_o       = 1'b0;\\n\", '    assign fetch_in_inst_o        = fetch_out_inst_i;\\n', '\\n', '    assign lsu_out_rd_o           = lsu_in_rd_i;\\n', '    assign lsu_out_wr_o           = lsu_in_wr_i;\\n', '    assign lsu_out_addr_o         = lsu_in_addr_i;\\n', '    assign lsu_out_data_wr_o      = lsu_in_data_wr_i;\\n', '    assign lsu_out_invalidate_o   = lsu_in_invalidate_i;\\n', '    assign lsu_out_writeback_o    = lsu_in_writeback_i;\\n', '    assign lsu_out_cacheable_o    = lsu_in_cacheable_i;\\n', '    assign lsu_out_req_tag_o      = lsu_in_req_tag_i;\\n', '    assign lsu_out_flush_o        = lsu_in_flush_i;\\n', '    \\n', '    assign lsu_in_ack_o           = lsu_out_ack_i;\\n', '    assign lsu_in_resp_tag_o      = lsu_out_resp_tag_i;\\n', '    assign lsu_in_error_o         = lsu_out_error_i;\\n', '    assign lsu_in_data_rd_o       = lsu_out_data_rd_i;\\n', \"    assign lsu_in_store_fault_o   = 1'b0;\\n\", \"    assign lsu_in_load_fault_o    = 1'b0;\\n\", '\\n', '    assign lsu_in_accept_o        = lsu_out_accept_i;\\n', 'end\\n', 'endgenerate\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module biriscv_multiplier\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           opcode_valid_i\\n', '    ,input  [ 31:0]  opcode_opcode_i\\n', '    ,input  [ 31:0]  opcode_pc_i\\n', '    ,input           opcode_invalid_i\\n', '    ,input  [  4:0]  opcode_rd_idx_i\\n', '    ,input  [  4:0]  opcode_ra_idx_i\\n', '    ,input  [  4:0]  opcode_rb_idx_i\\n', '    ,input  [ 31:0]  opcode_ra_operand_i\\n', '    ,input  [ 31:0]  opcode_rb_operand_i\\n', '    ,input           hold_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  writeback_value_o\\n', ');\\n', '\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Includes\\n', '//-----------------------------------------------------------------\\n', '`include \"biriscv_defs.v\"\\n', '\\n', 'localparam MULT_STAGES = 2; // 2 or 3\\n', '\\n', '//-------------------------------------------------------------\\n', '// Registers / Wires\\n', '//-------------------------------------------------------------\\n', 'reg  [31:0]  result_e2_q;\\n', 'reg  [31:0]  result_e3_q;\\n', '\\n', 'reg [32:0]   operand_a_e1_q;\\n', 'reg [32:0]   operand_b_e1_q;\\n', 'reg          mulhi_sel_e1_q;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Multiplier\\n', '//-------------------------------------------------------------\\n', 'wire [64:0]  mult_result_w;\\n', 'reg  [32:0]  operand_b_r;\\n', 'reg  [32:0]  operand_a_r;\\n', 'reg  [31:0]  result_r;\\n', '\\n', 'wire mult_inst_w    = ((opcode_opcode_i & `INST_MUL_MASK) == `INST_MUL)        || \\n', '                      ((opcode_opcode_i & `INST_MULH_MASK) == `INST_MULH)      ||\\n', '                      ((opcode_opcode_i & `INST_MULHSU_MASK) == `INST_MULHSU)  ||\\n', '                      ((opcode_opcode_i & `INST_MULHU_MASK) == `INST_MULHU);\\n', '\\n', '\\n', 'always @ *\\n', 'begin\\n', '    if ((opcode_opcode_i & `INST_MULHSU_MASK) == `INST_MULHSU)\\n', '        operand_a_r = {opcode_ra_operand_i[31], opcode_ra_operand_i[31:0]};\\n', '    else if ((opcode_opcode_i & `INST_MULH_MASK) == `INST_MULH)\\n', '        operand_a_r = {opcode_ra_operand_i[31], opcode_ra_operand_i[31:0]};\\n', '    else // MULHU || MUL\\n', \"        operand_a_r = {1'b0, opcode_ra_operand_i[31:0]};\\n\", 'end\\n', '\\n', 'always @ *\\n', 'begin\\n', '    if ((opcode_opcode_i & `INST_MULHSU_MASK) == `INST_MULHSU)\\n', \"        operand_b_r = {1'b0, opcode_rb_operand_i[31:0]};\\n\", '    else if ((opcode_opcode_i & `INST_MULH_MASK) == `INST_MULH)\\n', '        operand_b_r = {opcode_rb_operand_i[31], opcode_rb_operand_i[31:0]};\\n', '    else // MULHU || MUL\\n', \"        operand_b_r = {1'b0, opcode_rb_operand_i[31:0]};\\n\", 'end\\n', '\\n', '\\n', '// Pipeline flops for multiplier\\n', 'always @(posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    operand_a_e1_q <= 33'b0;\\n\", \"    operand_b_e1_q <= 33'b0;\\n\", \"    mulhi_sel_e1_q <= 1'b0;\\n\", 'end\\n', 'else if (hold_i)\\n', '    ;\\n', 'else if (opcode_valid_i && mult_inst_w)\\n', 'begin\\n', '    operand_a_e1_q <= operand_a_r;\\n', '    operand_b_e1_q <= operand_b_r;\\n', '    mulhi_sel_e1_q <= ~((opcode_opcode_i & `INST_MUL_MASK) == `INST_MUL);\\n', 'end\\n', 'else\\n', 'begin\\n', \"    operand_a_e1_q <= 33'b0;\\n\", \"    operand_b_e1_q <= 33'b0;\\n\", \"    mulhi_sel_e1_q <= 1'b0;\\n\", 'end\\n', '\\n', 'assign mult_result_w = {{ 32 {operand_a_e1_q[32]}}, operand_a_e1_q}*{{ 32 {operand_b_e1_q[32]}}, operand_b_e1_q};\\n', '\\n', 'always @ *\\n', 'begin\\n', '    result_r = mulhi_sel_e1_q ? mult_result_w[63:32] : mult_result_w[31:0];\\n', 'end\\n', '\\n', 'always @(posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    result_e2_q <= 32'b0;\\n\", 'else if (~hold_i)\\n', '    result_e2_q <= result_r;\\n', '\\n', 'always @(posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    result_e3_q <= 32'b0;\\n\", 'else if (~hold_i)\\n', '    result_e3_q <= result_e2_q;\\n', '\\n', 'assign writeback_value_o  = (MULT_STAGES == 3) ? result_e3_q : result_e2_q;\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module biriscv_npc\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter SUPPORT_BRANCH_PREDICTION = 1\\n', '    ,parameter NUM_BTB_ENTRIES  = 32\\n', '    ,parameter NUM_BTB_ENTRIES_W = 5\\n', '    ,parameter NUM_BHT_ENTRIES  = 512\\n', '    ,parameter NUM_BHT_ENTRIES_W = 9\\n', '    ,parameter RAS_ENABLE       = 1\\n', '    ,parameter GSHARE_ENABLE    = 0\\n', '    ,parameter BHT_ENABLE       = 1\\n', '    ,parameter NUM_RAS_ENTRIES  = 8\\n', '    ,parameter NUM_RAS_ENTRIES_W = 3\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           invalidate_i\\n', '    ,input           branch_request_i\\n', '    ,input           branch_is_taken_i\\n', '    ,input           branch_is_not_taken_i\\n', '    ,input  [ 31:0]  branch_source_i\\n', '    ,input           branch_is_call_i\\n', '    ,input           branch_is_ret_i\\n', '    ,input           branch_is_jmp_i\\n', '    ,input  [ 31:0]  branch_pc_i\\n', '    ,input  [ 31:0]  pc_f_i\\n', '    ,input           pc_accept_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  next_pc_f_o\\n', '    ,output [  1:0]  next_taken_f_o\\n', ');\\n', '\\n', '\\n', '\\n', \"localparam RAS_INVALID = 32'h00000001;\\n\", '\\n', '//-----------------------------------------------------------------\\n', '// Branch prediction (BTB, BHT, RAS)\\n', '//-----------------------------------------------------------------\\n', 'generate\\n', 'if (SUPPORT_BRANCH_PREDICTION)\\n', 'begin: BRANCH_PREDICTION\\n', '\\n', 'wire        pred_taken_w;\\n', 'wire        pred_ntaken_w;\\n', '\\n', '// Info from BTB\\n', 'wire        btb_valid_w;\\n', 'wire        btb_upper_w;\\n', 'wire [31:0] btb_next_pc_w;\\n', 'wire        btb_is_call_w;\\n', 'wire        btb_is_ret_w;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Return Address Stack (actual)\\n', '//-----------------------------------------------------------------\\n', 'reg [NUM_RAS_ENTRIES_W-1:0] ras_index_real_q;\\n', 'reg [NUM_RAS_ENTRIES_W-1:0] ras_index_real_r;\\n', '\\n', 'always @ *\\n', 'begin\\n', '    ras_index_real_r = ras_index_real_q;\\n', '\\n', '    if (branch_request_i & branch_is_call_i)\\n', '        ras_index_real_r = ras_index_real_q + 1;\\n', '    else if (branch_request_i & branch_is_ret_i)\\n', '        ras_index_real_r = ras_index_real_q - 1;\\n', 'end\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    ras_index_real_q <= {NUM_RAS_ENTRIES_W{1'b0}};\\n\", 'else\\n', '    ras_index_real_q <= ras_index_real_r;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Return Address Stack (speculative)\\n', '//-----------------------------------------------------------------\\n', 'reg [31:0] ras_stack_q[NUM_RAS_ENTRIES-1:0];\\n', 'reg [NUM_RAS_ENTRIES_W-1:0] ras_index_q;\\n', '\\n', 'reg [NUM_RAS_ENTRIES_W-1:0] ras_index_r;\\n', '\\n', 'wire [31:0] ras_pc_pred_w   = ras_stack_q[ras_index_q];\\n', 'wire        ras_call_pred_w = RAS_ENABLE & (btb_valid_w & btb_is_call_w) & ~ras_pc_pred_w[0];\\n', 'wire        ras_ret_pred_w  = RAS_ENABLE & (btb_valid_w & btb_is_ret_w) & ~ras_pc_pred_w[0];\\n', '\\n', 'always @ *\\n', 'begin\\n', '    ras_index_r = ras_index_q;\\n', '\\n', '    // Mispredict - go from confirmed call stack index\\n', '    if (branch_request_i & branch_is_call_i)\\n', '        ras_index_r = ras_index_real_q + 1;\\n', '    else if (branch_request_i & branch_is_ret_i)\\n', '        ras_index_r = ras_index_real_q - 1;\\n', '    // Speculative call / returns\\n', '    else if (ras_call_pred_w & pc_accept_i)\\n', '        ras_index_r = ras_index_q + 1;\\n', '    else if (ras_ret_pred_w & pc_accept_i)\\n', '        ras_index_r = ras_index_q - 1;\\n', 'end\\n', '\\n', 'integer i3;\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', '    for (i3 = 0; i3 < NUM_RAS_ENTRIES; i3 = i3 + 1) \\n', '    begin\\n', '        ras_stack_q[i3] <= RAS_INVALID;\\n', '    end\\n', '\\n', \"    ras_index_q <= {NUM_RAS_ENTRIES_W{1'b0}};\\n\", 'end\\n', '// On a call push return address onto RAS stack (current PC + 4)\\n', 'else if (branch_request_i & branch_is_call_i)\\n', 'begin\\n', \"    ras_stack_q[ras_index_r] <= branch_source_i + 32'd4;\\n\", '    ras_index_q              <= ras_index_r;\\n', 'end\\n', '// On a call push return address onto RAS stack (current PC + 4)\\n', 'else if (ras_call_pred_w & pc_accept_i)\\n', 'begin\\n', \"    ras_stack_q[ras_index_r] <= (btb_upper_w ? (pc_f_i | 32'd4) : pc_f_i) + 32'd4;\\n\", '    ras_index_q              <= ras_index_r;\\n', 'end\\n', '// Return - pop item from stack\\n', 'else if ((ras_ret_pred_w & pc_accept_i) || (branch_request_i & branch_is_ret_i))\\n', 'begin\\n', '    ras_index_q              <= ras_index_r;\\n', 'end\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Global history register (actual history)\\n', '//-----------------------------------------------------------------\\n', 'reg [NUM_BHT_ENTRIES_W-1:0] global_history_real_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    global_history_real_q <= {NUM_BHT_ENTRIES_W{1'b0}};\\n\", 'else if (branch_is_taken_i || branch_is_not_taken_i)\\n', '    global_history_real_q <= {global_history_real_q[NUM_BHT_ENTRIES_W-2:0], branch_is_taken_i};\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Global history register (speculative)\\n', '//-----------------------------------------------------------------\\n', 'reg [NUM_BHT_ENTRIES_W-1:0] global_history_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    global_history_q <= {NUM_BHT_ENTRIES_W{1'b0}};\\n\", '// Mispredict - revert to actual branch history to flush out speculative errors\\n', 'else if (branch_request_i)\\n', '    global_history_q <= {global_history_real_q[NUM_BHT_ENTRIES_W-2:0], branch_is_taken_i};\\n', '// Predicted branch\\n', 'else if (pred_taken_w || pred_ntaken_w)\\n', '    global_history_q <= {global_history_q[NUM_BHT_ENTRIES_W-2:0], pred_taken_w};\\n', '\\n', 'wire [NUM_BHT_ENTRIES_W-1:0] gshare_wr_entry_w = (branch_request_i ? global_history_real_q : global_history_q) ^ branch_source_i[2+NUM_BHT_ENTRIES_W-1:2];\\n', 'wire [NUM_BHT_ENTRIES_W-1:0] gshare_rd_entry_w = global_history_q ^ {pc_f_i[3+NUM_BHT_ENTRIES_W-2:3],btb_upper_w};\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Branch prediction bits\\n', '//-----------------------------------------------------------------\\n', 'reg [1:0]                    bht_sat_q[NUM_BHT_ENTRIES-1:0];\\n', '\\n', 'wire [NUM_BHT_ENTRIES_W-1:0] bht_wr_entry_w = GSHARE_ENABLE ? gshare_wr_entry_w : branch_source_i[2+NUM_BHT_ENTRIES_W-1:2];\\n', 'wire [NUM_BHT_ENTRIES_W-1:0] bht_rd_entry_w = GSHARE_ENABLE ? gshare_rd_entry_w : {pc_f_i[3+NUM_BHT_ENTRIES_W-2:3],btb_upper_w};\\n', '\\n', 'integer i4;\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', '    for (i4 = 0; i4 < NUM_BHT_ENTRIES; i4 = i4 + 1)\\n', '    begin\\n', \"        bht_sat_q[i4] <= 2'd3;\\n\", '    end\\n', 'end\\n', \"else if (branch_is_taken_i && bht_sat_q[bht_wr_entry_w] < 2'd3)\\n\", \"    bht_sat_q[bht_wr_entry_w] <= bht_sat_q[bht_wr_entry_w] + 2'd1;\\n\", \"else if (branch_is_not_taken_i && bht_sat_q[bht_wr_entry_w] > 2'd0)\\n\", \"    bht_sat_q[bht_wr_entry_w] <= bht_sat_q[bht_wr_entry_w] - 2'd1;\\n\", '\\n', \"wire bht_predict_taken_w = BHT_ENABLE && (bht_sat_q[bht_rd_entry_w] >= 2'd2);\\n\", '\\n', '//-----------------------------------------------------------------\\n', '// Branch target buffer\\n', '//-----------------------------------------------------------------\\n', 'reg [31:0]  btb_pc_q[NUM_BTB_ENTRIES-1:0];\\n', 'reg [31:0]  btb_target_q[NUM_BTB_ENTRIES-1:0];\\n', 'reg         btb_is_call_q[NUM_BTB_ENTRIES-1:0];\\n', 'reg         btb_is_ret_q[NUM_BTB_ENTRIES-1:0];\\n', 'reg         btb_is_jmp_q[NUM_BTB_ENTRIES-1:0];\\n', '\\n', 'reg         btb_valid_r;\\n', 'reg         btb_upper_r;\\n', 'reg         btb_is_call_r;\\n', 'reg         btb_is_ret_r;\\n', 'reg [31:0]  btb_next_pc_r;\\n', 'reg         btb_is_jmp_r;\\n', '\\n', 'reg [NUM_BTB_ENTRIES_W-1:0] btb_entry_r;\\n', 'integer i0;\\n', '\\n', 'always @ *\\n', 'begin\\n', \"    btb_valid_r   = 1'b0;\\n\", \"    btb_upper_r   = 1'b0;\\n\", \"    btb_is_call_r = 1'b0;\\n\", \"    btb_is_ret_r  = 1'b0;\\n\", \"    btb_is_jmp_r  = 1'b0;\\n\", \"    btb_next_pc_r = {pc_f_i[31:3],3'b0} + 32'd8;\\n\", \"    btb_entry_r   = {NUM_BTB_ENTRIES_W{1'b0}};\\n\", '\\n', '    for (i0 = 0; i0 < NUM_BTB_ENTRIES; i0 = i0 + 1)\\n', '    begin\\n', '        if (btb_pc_q[i0] == pc_f_i)\\n', '        begin\\n', \"            btb_valid_r   = 1'b1;\\n\", '            btb_upper_r   = pc_f_i[2];\\n', '            btb_is_call_r = btb_is_call_q[i0];\\n', '            btb_is_ret_r  = btb_is_ret_q[i0];\\n', '            btb_is_jmp_r  = btb_is_jmp_q[i0];\\n', '            btb_next_pc_r = btb_target_q[i0];\\n', '/* verilator lint_off WIDTH */\\n', '            btb_entry_r   = i0;\\n', '/* verilator lint_on WIDTH */\\n', '        end\\n', '    end\\n', '\\n', '    if (~btb_valid_r && ~pc_f_i[2])\\n', '        for (i0 = 0; i0 < NUM_BTB_ENTRIES; i0 = i0 + 1)\\n', '        begin\\n', \"            if (btb_pc_q[i0] == (pc_f_i | 32'd4))\\n\", '            begin\\n', \"                btb_valid_r   = 1'b1;\\n\", \"                btb_upper_r   = 1'b1;\\n\", '                btb_is_call_r = btb_is_call_q[i0];\\n', '                btb_is_ret_r  = btb_is_ret_q[i0];\\n', '                btb_is_jmp_r  = btb_is_jmp_q[i0];\\n', '                btb_next_pc_r = btb_target_q[i0];\\n', '/* verilator lint_off WIDTH */\\n', '                btb_entry_r   = i0;\\n', '/* verilator lint_on WIDTH */\\n', '            end\\n', '        end\\n', 'end\\n', '\\n', 'reg [NUM_BTB_ENTRIES_W-1:0]  btb_wr_entry_r;\\n', 'wire [NUM_BTB_ENTRIES_W-1:0] btb_wr_alloc_w;\\n', '\\n', 'reg btb_hit_r;\\n', 'reg btb_miss_r;\\n', 'integer i1;\\n', 'always @ *\\n', 'begin\\n', \"    btb_wr_entry_r = {NUM_BTB_ENTRIES_W{1'b0}};\\n\", \"    btb_hit_r      = 1'b0;\\n\", \"    btb_miss_r     = 1'b0;\\n\", '\\n', '    // Misprediction - learn / update branch details\\n', '    if (branch_request_i)\\n', '    begin\\n', '        for (i1 = 0; i1 < NUM_BTB_ENTRIES; i1 = i1 + 1)\\n', '        begin\\n', '            if (btb_pc_q[i1] == branch_source_i)\\n', '            begin\\n', \"                btb_hit_r      = 1'b1;\\n\", '    /* verilator lint_off WIDTH */\\n', '                btb_wr_entry_r = i1;\\n', '    /* verilator lint_on WIDTH */\\n', '            end\\n', '        end\\n', '        btb_miss_r = ~btb_hit_r;\\n', '    end\\n', 'end\\n', '\\n', 'integer i2;\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', '    for (i2 = 0; i2 < NUM_BTB_ENTRIES; i2 = i2 + 1)\\n', '    begin\\n', \"        btb_pc_q[i2]     <= 32'b0;\\n\", \"        btb_target_q[i2] <= 32'b0;\\n\", \"        btb_is_call_q[i2]<= 1'b0;\\n\", \"        btb_is_ret_q[i2] <= 1'b0;\\n\", \"        btb_is_jmp_q[i2] <= 1'b0;\\n\", '    end\\n', 'end\\n', '// Hit - update entry\\n', 'else if (btb_hit_r)\\n', 'begin\\n', '    btb_pc_q[btb_wr_entry_r]     <= branch_source_i;\\n', '    if (branch_is_taken_i)\\n', '        btb_target_q[btb_wr_entry_r] <= branch_pc_i;\\n', '    btb_is_call_q[btb_wr_entry_r]<= branch_is_call_i;\\n', '    btb_is_ret_q[btb_wr_entry_r] <= branch_is_ret_i;\\n', '    btb_is_jmp_q[btb_wr_entry_r] <= branch_is_jmp_i;\\n', 'end\\n', '// Miss - allocate entry\\n', 'else if (btb_miss_r)\\n', 'begin\\n', '    btb_pc_q[btb_wr_alloc_w]     <= branch_source_i;\\n', '    btb_target_q[btb_wr_alloc_w] <= branch_pc_i;\\n', '    btb_is_call_q[btb_wr_alloc_w]<= branch_is_call_i;\\n', '    btb_is_ret_q[btb_wr_alloc_w] <= branch_is_ret_i;\\n', '    btb_is_jmp_q[btb_wr_alloc_w] <= branch_is_jmp_i;\\n', 'end\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Replacement Selection\\n', '//-----------------------------------------------------------------\\n', 'biriscv_npc_lfsr\\n', '#(\\n', '    .DEPTH(NUM_BTB_ENTRIES)\\n', '   ,.ADDR_W(NUM_BTB_ENTRIES_W)\\n', ')\\n', 'u_lru\\n', '(\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '\\n', '    ,.hit_i(btb_valid_r)\\n', '    ,.hit_entry_i(btb_entry_r)\\n', '\\n', '    ,.alloc_i(btb_miss_r)\\n', '    ,.alloc_entry_o(btb_wr_alloc_w)\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Outputs\\n', '//-----------------------------------------------------------------\\n', 'assign btb_valid_w   = btb_valid_r;\\n', 'assign btb_upper_w   = btb_upper_r;\\n', 'assign btb_is_call_w = btb_is_call_r;\\n', 'assign btb_is_ret_w  = btb_is_ret_r;\\n', 'assign next_pc_f_o   = ras_ret_pred_w      ? ras_pc_pred_w : \\n', '                       (bht_predict_taken_w | btb_is_jmp_r) ? btb_next_pc_r :\\n', \"                       {pc_f_i[31:3],3'b0} + 32'd8;\\n\", '\\n', 'assign next_taken_f_o = (btb_valid_w & (ras_ret_pred_w | bht_predict_taken_w | btb_is_jmp_r)) ? \\n', \"                        pc_f_i[2] ? {btb_upper_r, 1'b0} :\\n\", \"                        {btb_upper_r, ~btb_upper_r} : 2'b0;\\n\", '\\n', 'assign pred_taken_w   = btb_valid_w & (ras_ret_pred_w | bht_predict_taken_w | btb_is_jmp_r) & pc_accept_i;\\n', 'assign pred_ntaken_w  = btb_valid_w & ~pred_taken_w & pc_accept_i;\\n', '\\n', '\\n', 'end\\n', '//-----------------------------------------------------------------\\n', '// No branch prediction\\n', '//-----------------------------------------------------------------\\n', 'else\\n', 'begin: NO_BRANCH_PREDICTION\\n', '\\n', \"assign next_pc_f_o    = {pc_f_i[31:3],3'b0} + 32'd8;\\n\", \"assign next_taken_f_o = 2'b0;\\n\", '\\n', 'end\\n', 'endgenerate\\n', '\\n', 'endmodule\\n', '\\n', '\\n', 'module biriscv_npc_lfsr\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter DEPTH            = 32\\n', '    ,parameter ADDR_W           = 5\\n', \"    ,parameter INITIAL_VALUE    = 16'h0001\\n\", \"    ,parameter TAP_VALUE        = 16'hB400\\n\", ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input           hit_i\\n', '    ,input  [ADDR_W-1:0]  hit_entry_i\\n', '    ,input           alloc_i\\n', '\\n', '    // Outputs\\n', '    ,output [ADDR_W-1:0]  alloc_entry_o\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Scheme: LFSR\\n', '//-----------------------------------------------------------------\\n', 'reg [15:0] lfsr_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', '    lfsr_q <= INITIAL_VALUE;\\n', 'else if (alloc_i)\\n', 'begin\\n', '    if (lfsr_q[0])\\n', \"        lfsr_q <= {1'b0, lfsr_q[15:1]} ^ TAP_VALUE;\\n\", '    else\\n', \"        lfsr_q <= {1'b0, lfsr_q[15:1]};\\n\", 'end\\n', '\\n', 'assign alloc_entry_o = lfsr_q[ADDR_W-1:0];\\n', '\\n', '\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', 'module biriscv_pipe_ctrl\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter SUPPORT_LOAD_BYPASS = 1\\n', '    ,parameter SUPPORT_MUL_BYPASS  = 1\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '\\n', '    // Issue\\n', '    ,input           issue_valid_i\\n', '    ,input           issue_accept_i\\n', '    ,input           issue_stall_i\\n', '    ,input           issue_lsu_i\\n', '    ,input           issue_csr_i\\n', '    ,input           issue_div_i\\n', '    ,input           issue_mul_i\\n', '    ,input           issue_branch_i\\n', '    ,input           issue_rd_valid_i\\n', '    ,input  [4:0]    issue_rd_i\\n', '    ,input  [5:0]    issue_exception_i\\n', '    ,input           take_interrupt_i\\n', '    ,input           issue_branch_taken_i\\n', '    ,input [31:0]    issue_branch_target_i\\n', '    ,input [31:0]    issue_pc_i\\n', '    ,input [31:0]    issue_opcode_i\\n', '    ,input [31:0]    issue_operand_ra_i\\n', '    ,input [31:0]    issue_operand_rb_i\\n', '\\n', '    // Execution stage 1: ALU result\\n', '    ,input [31:0]    alu_result_e1_i\\n', '\\n', '    // Execution stage 1: CSR read result / early exceptions\\n', '    ,input [ 31:0]   csr_result_value_e1_i\\n', '    ,input           csr_result_write_e1_i\\n', '    ,input [ 31:0]   csr_result_wdata_e1_i\\n', '    ,input [  5:0]   csr_result_exception_e1_i\\n', '\\n', '    // Execution stage 1\\n', '    ,output          load_e1_o\\n', '    ,output          store_e1_o\\n', '    ,output          mul_e1_o\\n', '    ,output          branch_e1_o\\n', '    ,output [  4:0]  rd_e1_o\\n', '    ,output [31:0]   pc_e1_o\\n', '    ,output [31:0]   opcode_e1_o\\n', '    ,output [31:0]   operand_ra_e1_o\\n', '    ,output [31:0]   operand_rb_e1_o\\n', '\\n', '    // Execution stage 2: Other results\\n', '    ,input           mem_complete_i\\n', '    ,input [31:0]    mem_result_e2_i\\n', '    ,input  [5:0]    mem_exception_e2_i\\n', '    ,input [31:0]    mul_result_e2_i\\n', '\\n', '    // Execution stage 2\\n', '    ,output          load_e2_o\\n', '    ,output          mul_e2_o\\n', '    ,output [  4:0]  rd_e2_o\\n', '    ,output [31:0]   result_e2_o\\n', '\\n', '    // Out of pipe: Divide Result\\n', '    ,input           div_complete_i\\n', '    ,input  [31:0]   div_result_i\\n', '\\n', '    // Commit\\n', '    ,output          valid_wb_o\\n', '    ,output          csr_wb_o\\n', '    ,output [  4:0]  rd_wb_o\\n', '    ,output [31:0]   result_wb_o\\n', '    ,output [31:0]   pc_wb_o\\n', '    ,output [31:0]   opcode_wb_o\\n', '    ,output [31:0]   operand_ra_wb_o\\n', '    ,output [31:0]   operand_rb_wb_o\\n', '    ,output [5:0]    exception_wb_o\\n', '    ,output          csr_write_wb_o\\n', '    ,output [11:0]   csr_waddr_wb_o\\n', '    ,output [31:0]   csr_wdata_wb_o\\n', '\\n', '    ,output          stall_o\\n', '    ,output          squash_e1_e2_o\\n', '    ,input           squash_e1_e2_i\\n', '    ,input           squash_wb_i\\n', ');\\n', '\\n', '//-------------------------------------------------------------\\n', '// Includes\\n', '//-------------------------------------------------------------\\n', '`include \"biriscv_defs.v\"\\n', '\\n', 'wire squash_e1_e2_w;\\n', \"wire branch_misaligned_w = (issue_branch_taken_i && issue_branch_target_i[1:0] != 2'b0);\\n\", '\\n', '//-------------------------------------------------------------\\n', '// E1 / Address\\n', '//------------------------------------------------------------- \\n', '`define PCINFO_W     10\\n', '`define PCINFO_ALU       0\\n', '`define PCINFO_LOAD      1\\n', '`define PCINFO_STORE     2\\n', '`define PCINFO_CSR       3\\n', '`define PCINFO_DIV       4\\n', '`define PCINFO_MUL       5\\n', '`define PCINFO_BRANCH    6\\n', '`define PCINFO_RD_VALID  7\\n', '`define PCINFO_INTR      8\\n', '`define PCINFO_COMPLETE  9\\n', '\\n', '`define RD_IDX_R    11:7\\n', '\\n', 'reg                     valid_e1_q;\\n', 'reg [`PCINFO_W-1:0]     ctrl_e1_q;\\n', 'reg [31:0]              pc_e1_q;\\n', 'reg [31:0]              npc_e1_q;\\n', 'reg [31:0]              opcode_e1_q;\\n', 'reg [31:0]              operand_ra_e1_q;\\n', 'reg [31:0]              operand_rb_e1_q;\\n', 'reg [`EXCEPTION_W-1:0]  exception_e1_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    valid_e1_q      <= 1'b0;\\n\", \"    ctrl_e1_q       <= `PCINFO_W'b0;\\n\", \"    pc_e1_q         <= 32'b0;\\n\", \"    npc_e1_q        <= 32'b0;\\n\", \"    opcode_e1_q     <= 32'b0;\\n\", \"    operand_ra_e1_q <= 32'b0;\\n\", \"    operand_rb_e1_q <= 32'b0;\\n\", \"    exception_e1_q  <= `EXCEPTION_W'b0;\\n\", 'end\\n', '// Stall - no change in E1 state\\n', 'else if (issue_stall_i)\\n', '    ;\\n', 'else if ((issue_valid_i && issue_accept_i) && ~(squash_e1_e2_o || squash_e1_e2_i))\\n', 'begin\\n', \"    valid_e1_q                  <= 1'b1;\\n\", '    ctrl_e1_q[`PCINFO_ALU]      <= ~(issue_lsu_i | issue_csr_i | issue_div_i | issue_mul_i);\\n', '    ctrl_e1_q[`PCINFO_LOAD]     <= issue_lsu_i &  issue_rd_valid_i & ~take_interrupt_i; // TODO: Check\\n', '    ctrl_e1_q[`PCINFO_STORE]    <= issue_lsu_i & ~issue_rd_valid_i & ~take_interrupt_i;\\n', '    ctrl_e1_q[`PCINFO_CSR]      <= issue_csr_i & ~take_interrupt_i;\\n', '    ctrl_e1_q[`PCINFO_DIV]      <= issue_div_i & ~take_interrupt_i;\\n', '    ctrl_e1_q[`PCINFO_MUL]      <= issue_mul_i & ~take_interrupt_i;\\n', '    ctrl_e1_q[`PCINFO_BRANCH]   <= issue_branch_i & ~take_interrupt_i;\\n', '    ctrl_e1_q[`PCINFO_RD_VALID] <= issue_rd_valid_i & ~take_interrupt_i;\\n', '    ctrl_e1_q[`PCINFO_INTR]     <= take_interrupt_i;\\n', \"    ctrl_e1_q[`PCINFO_COMPLETE] <= 1'b1;\\n\", '\\n', '    pc_e1_q         <= issue_pc_i;\\n', \"    npc_e1_q        <= issue_branch_taken_i ? issue_branch_target_i : issue_pc_i + 32'd4;\\n\", '    opcode_e1_q     <= issue_opcode_i;\\n', '    operand_ra_e1_q <= issue_operand_ra_i;\\n', '    operand_rb_e1_q <= issue_operand_rb_i;\\n', '    exception_e1_q  <= (|issue_exception_i) ? issue_exception_i : \\n', \"                       branch_misaligned_w  ? `EXCEPTION_MISALIGNED_FETCH : `EXCEPTION_W'b0;\\n\", 'end\\n', '// No valid instruction (or pipeline flush event)\\n', 'else\\n', 'begin\\n', \"    valid_e1_q      <= 1'b0;\\n\", \"    ctrl_e1_q       <= `PCINFO_W'b0;\\n\", \"    pc_e1_q         <= 32'b0;\\n\", \"    npc_e1_q        <= 32'b0;\\n\", \"    opcode_e1_q     <= 32'b0;\\n\", \"    operand_ra_e1_q <= 32'b0;\\n\", \"    operand_rb_e1_q <= 32'b0;\\n\", \"    exception_e1_q  <= `EXCEPTION_W'b0;\\n\", 'end\\n', '\\n', 'wire   alu_e1_w        = ctrl_e1_q[`PCINFO_ALU];\\n', 'assign load_e1_o       = ctrl_e1_q[`PCINFO_LOAD];\\n', 'assign store_e1_o      = ctrl_e1_q[`PCINFO_STORE];\\n', 'wire   csr_e1_w        = ctrl_e1_q[`PCINFO_CSR];\\n', 'wire   div_e1_w        = ctrl_e1_q[`PCINFO_DIV];\\n', 'assign mul_e1_o        = ctrl_e1_q[`PCINFO_MUL];\\n', 'assign branch_e1_o     = ctrl_e1_q[`PCINFO_BRANCH];\\n', 'assign rd_e1_o         = {5{ctrl_e1_q[`PCINFO_RD_VALID]}} & opcode_e1_q[`RD_IDX_R];\\n', 'assign pc_e1_o         = pc_e1_q;\\n', 'assign opcode_e1_o     = opcode_e1_q;\\n', 'assign operand_ra_e1_o = operand_ra_e1_q;\\n', 'assign operand_rb_e1_o = operand_rb_e1_q;\\n', '\\n', '//-------------------------------------------------------------\\n', '// E2 / Mem result\\n', '//------------------------------------------------------------- \\n', 'reg                     valid_e2_q;\\n', 'reg [`PCINFO_W-1:0]     ctrl_e2_q;\\n', 'reg                     csr_wr_e2_q;\\n', 'reg [31:0]              csr_wdata_e2_q;\\n', 'reg [31:0]              result_e2_q;\\n', 'reg [31:0]              pc_e2_q;\\n', 'reg [31:0]              npc_e2_q;\\n', 'reg [31:0]              opcode_e2_q;\\n', 'reg [31:0]              operand_ra_e2_q;\\n', 'reg [31:0]              operand_rb_e2_q;\\n', 'reg [`EXCEPTION_W-1:0]  exception_e2_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    valid_e2_q      <= 1'b0;\\n\", \"    ctrl_e2_q       <= `PCINFO_W'b0;\\n\", \"    csr_wr_e2_q     <= 1'b0;\\n\", \"    csr_wdata_e2_q  <= 32'b0;\\n\", \"    pc_e2_q         <= 32'b0;\\n\", \"    npc_e2_q        <= 32'b0;\\n\", \"    opcode_e2_q     <= 32'b0;\\n\", \"    operand_ra_e2_q <= 32'b0;\\n\", \"    operand_rb_e2_q <= 32'b0;\\n\", \"    result_e2_q     <= 32'b0;\\n\", \"    exception_e2_q  <= `EXCEPTION_W'b0;\\n\", 'end\\n', '// Stall - no change in E2 state\\n', 'else if (issue_stall_i)\\n', '    ;\\n', '// Pipeline flush\\n', 'else if (squash_e1_e2_o || squash_e1_e2_i)\\n', 'begin\\n', \"    valid_e2_q      <= 1'b0;\\n\", \"    ctrl_e2_q       <= `PCINFO_W'b0;\\n\", \"    csr_wr_e2_q     <= 1'b0;\\n\", \"    csr_wdata_e2_q  <= 32'b0;\\n\", \"    pc_e2_q         <= 32'b0;\\n\", \"    npc_e2_q        <= 32'b0;\\n\", \"    opcode_e2_q     <= 32'b0;\\n\", \"    operand_ra_e2_q <= 32'b0;\\n\", \"    operand_rb_e2_q <= 32'b0;\\n\", \"    result_e2_q     <= 32'b0;\\n\", \"    exception_e2_q  <= `EXCEPTION_W'b0;\\n\", 'end\\n', '// Normal pipeline advance\\n', 'else\\n', 'begin\\n', '    valid_e2_q      <= valid_e1_q;\\n', '    ctrl_e2_q       <= ctrl_e1_q;\\n', '    csr_wr_e2_q     <= csr_result_write_e1_i;\\n', '    csr_wdata_e2_q  <= csr_result_wdata_e1_i;\\n', '    pc_e2_q         <= pc_e1_q;\\n', '    npc_e2_q        <= npc_e1_q;\\n', '    opcode_e2_q     <= opcode_e1_q;\\n', '    operand_ra_e2_q <= operand_ra_e1_q;\\n', '    operand_rb_e2_q <= operand_rb_e1_q;\\n', '\\n', '    // Launch interrupt\\n', '    if (ctrl_e1_q[`PCINFO_INTR])\\n', '        exception_e2_q  <= `EXCEPTION_INTERRUPT;\\n', '    // If frontend reports bad instruction, ignore later CSR errors...\\n', '    else if (|exception_e1_q)\\n', '    begin\\n', \"        valid_e2_q      <= 1'b0;\\n\", '        exception_e2_q  <= exception_e1_q;\\n', '    end\\n', '    else\\n', '        exception_e2_q  <= csr_result_exception_e1_i;\\n', '\\n', '    if (ctrl_e1_q[`PCINFO_DIV])\\n', '        result_e2_q <= div_result_i; \\n', '    else if (ctrl_e1_q[`PCINFO_CSR])\\n', '        result_e2_q <= csr_result_value_e1_i;\\n', '    else\\n', '        result_e2_q <= alu_result_e1_i;\\n', 'end\\n', '\\n', 'reg [31:0] result_e2_r;\\n', '\\n', 'wire valid_e2_w      = valid_e2_q & ~issue_stall_i;\\n', '\\n', 'always @ *\\n', 'begin\\n', '    // Default: ALU result\\n', '    result_e2_r = result_e2_q;\\n', '\\n', '    if (SUPPORT_LOAD_BYPASS && valid_e2_w && (ctrl_e2_q[`PCINFO_LOAD] || ctrl_e2_q[`PCINFO_STORE]))\\n', '        result_e2_r = mem_result_e2_i;\\n', '    else if (SUPPORT_MUL_BYPASS && valid_e2_w && ctrl_e2_q[`PCINFO_MUL])\\n', '        result_e2_r = mul_result_e2_i;\\n', 'end\\n', '\\n', 'wire   load_store_e2_w = ctrl_e2_q[`PCINFO_LOAD] | ctrl_e2_q[`PCINFO_STORE];\\n', 'assign load_e2_o       = ctrl_e2_q[`PCINFO_LOAD];\\n', 'assign mul_e2_o        = ctrl_e2_q[`PCINFO_MUL];\\n', 'assign rd_e2_o         = {5{(valid_e2_w && ctrl_e2_q[`PCINFO_RD_VALID] && ~stall_o)}} & opcode_e2_q[`RD_IDX_R];\\n', 'assign result_e2_o     = result_e2_r;\\n', '\\n', '// Load store result not ready when reaching E2\\n', 'assign stall_o         = (ctrl_e1_q[`PCINFO_DIV] && ~div_complete_i) || ((ctrl_e2_q[`PCINFO_LOAD] | ctrl_e2_q[`PCINFO_STORE]) & ~mem_complete_i);\\n', '\\n', 'reg [`EXCEPTION_W-1:0] exception_e2_r;\\n', 'always @ *\\n', 'begin\\n', '    if (valid_e2_q && (ctrl_e2_q[`PCINFO_LOAD] || ctrl_e2_q[`PCINFO_STORE]) && mem_complete_i)\\n', '        exception_e2_r = mem_exception_e2_i;\\n', '    else\\n', '        exception_e2_r = exception_e2_q;\\n', 'end\\n', '\\n', 'assign squash_e1_e2_w = |exception_e2_r;\\n', '\\n', 'reg squash_e1_e2_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', \"    squash_e1_e2_q <= 1'b0;\\n\", 'else if (~issue_stall_i)\\n', '    squash_e1_e2_q <= squash_e1_e2_w;\\n', '\\n', 'assign squash_e1_e2_o = squash_e1_e2_w | squash_e1_e2_q;\\n', '\\n', '//-------------------------------------------------------------\\n', '// Writeback / Commit\\n', '//------------------------------------------------------------- \\n', 'reg                     valid_wb_q;\\n', 'reg [`PCINFO_W-1:0]     ctrl_wb_q;\\n', 'reg                     csr_wr_wb_q;\\n', 'reg [31:0]              csr_wdata_wb_q;\\n', 'reg [31:0]              result_wb_q;\\n', 'reg [31:0]              pc_wb_q;\\n', 'reg [31:0]              npc_wb_q;\\n', 'reg [31:0]              opcode_wb_q;\\n', 'reg [31:0]              operand_ra_wb_q;\\n', 'reg [31:0]              operand_rb_wb_q;\\n', 'reg [`EXCEPTION_W-1:0]  exception_wb_q;\\n', '\\n', 'always @ (posedge clk_i or posedge rst_i)\\n', 'if (rst_i)\\n', 'begin\\n', \"    valid_wb_q      <= 1'b0;\\n\", \"    ctrl_wb_q       <= `PCINFO_W'b0;\\n\", \"    csr_wr_wb_q     <= 1'b0;\\n\", \"    csr_wdata_wb_q  <= 32'b0;\\n\", \"    pc_wb_q         <= 32'b0;\\n\", \"    npc_wb_q        <= 32'b0;\\n\", \"    opcode_wb_q     <= 32'b0;\\n\", \"    operand_ra_wb_q <= 32'b0;\\n\", \"    operand_rb_wb_q <= 32'b0;\\n\", \"    result_wb_q     <= 32'b0;\\n\", \"    exception_wb_q  <= `EXCEPTION_W'b0;\\n\", 'end\\n', '// Stall - no change in WB state\\n', 'else if (issue_stall_i)\\n', '    ;\\n', 'else if (squash_wb_i)\\n', 'begin\\n', \"    valid_wb_q      <= 1'b0;\\n\", \"    ctrl_wb_q       <= `PCINFO_W'b0;\\n\", \"    csr_wr_wb_q     <= 1'b0;\\n\", \"    csr_wdata_wb_q  <= 32'b0;\\n\", \"    pc_wb_q         <= 32'b0;\\n\", \"    npc_wb_q        <= 32'b0;\\n\", \"    opcode_wb_q     <= 32'b0;\\n\", \"    operand_ra_wb_q <= 32'b0;\\n\", \"    operand_rb_wb_q <= 32'b0;\\n\", \"    result_wb_q     <= 32'b0;\\n\", \"    exception_wb_q  <= `EXCEPTION_W'b0;\\n\", 'end\\n', 'else\\n', 'begin\\n', '    // Squash instruction valid on memory faults\\n', '    case (exception_e2_r)\\n', '    `EXCEPTION_MISALIGNED_LOAD,\\n', '    `EXCEPTION_FAULT_LOAD,\\n', '    `EXCEPTION_MISALIGNED_STORE,\\n', '    `EXCEPTION_FAULT_STORE,\\n', '    `EXCEPTION_PAGE_FAULT_LOAD,\\n', '    `EXCEPTION_PAGE_FAULT_STORE:\\n', \"        valid_wb_q      <= 1'b0;\\n\", '    default:\\n', '        valid_wb_q      <= valid_e2_q;\\n', '    endcase\\n', '\\n', '    csr_wr_wb_q     <= csr_wr_e2_q;  // TODO: Fault disable???\\n', '    csr_wdata_wb_q  <= csr_wdata_e2_q;\\n', '\\n', '    // Exception - squash writeback\\n', '    if (|exception_e2_r)\\n', '        ctrl_wb_q       <= ctrl_e2_q & ~(1 << `PCINFO_RD_VALID);\\n', '    else\\n', '        ctrl_wb_q       <= ctrl_e2_q;\\n', '\\n', '    pc_wb_q         <= pc_e2_q;\\n', '    npc_wb_q        <= npc_e2_q;\\n', '    opcode_wb_q     <= opcode_e2_q;\\n', '    operand_ra_wb_q <= operand_ra_e2_q;\\n', '    operand_rb_wb_q <= operand_rb_e2_q;\\n', '    exception_wb_q  <= exception_e2_r;\\n', '\\n', '    if (valid_e2_w && (ctrl_e2_q[`PCINFO_LOAD] || ctrl_e2_q[`PCINFO_STORE]))\\n', '        result_wb_q <= mem_result_e2_i;\\n', '    else if (valid_e2_w && ctrl_e2_q[`PCINFO_MUL])\\n', '        result_wb_q <= mul_result_e2_i;\\n', '    else\\n', '        result_wb_q <= result_e2_q;\\n', 'end\\n', '\\n', '// Instruction completion (for debug)\\n', 'wire complete_wb_w     = ctrl_wb_q[`PCINFO_COMPLETE] & ~issue_stall_i;\\n', '\\n', 'assign valid_wb_o      = valid_wb_q & ~issue_stall_i;\\n', 'assign csr_wb_o        = ctrl_wb_q[`PCINFO_CSR] & ~issue_stall_i; // TODO: Fault disable???\\n', 'assign rd_wb_o         = {5{(valid_wb_o && ctrl_wb_q[`PCINFO_RD_VALID] && ~stall_o)}} & opcode_wb_q[`RD_IDX_R];\\n', 'assign result_wb_o     = result_wb_q;\\n', 'assign pc_wb_o         = pc_wb_q;\\n', 'assign opcode_wb_o     = opcode_wb_q;\\n', 'assign operand_ra_wb_o = operand_ra_wb_q;\\n', 'assign operand_rb_wb_o = operand_rb_wb_q;\\n', '\\n', 'assign exception_wb_o  = exception_wb_q;\\n', '\\n', 'assign csr_write_wb_o  = csr_wr_wb_q;\\n', 'assign csr_waddr_wb_o  = opcode_wb_q[31:20];\\n', 'assign csr_wdata_wb_o  = csr_wdata_wb_q;\\n', '\\n', '`ifdef verilator\\n', 'biriscv_trace_sim\\n', 'u_trace_d\\n', '(\\n', '     .valid_i(issue_valid_i)\\n', '    ,.pc_i(issue_pc_i)\\n', '    ,.opcode_i(issue_opcode_i)\\n', ');\\n', '\\n', 'biriscv_trace_sim\\n', 'u_trace_wb\\n', '(\\n', '     .valid_i(valid_wb_o)\\n', '    ,.pc_i(pc_wb_o)\\n', '    ,.opcode_i(opcode_wb_o)\\n', ');\\n', '`endif\\n', '\\n', 'endmodule']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', 'module biriscv_regfile\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter SUPPORT_REGFILE_XILINX = 0,\\n', '     parameter SUPPORT_DUAL_ISSUE = 1\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input  [  4:0]  rd0_i\\n', '    ,input  [  4:0]  rd1_i\\n', '    ,input  [ 31:0]  rd0_value_i\\n', '    ,input  [ 31:0]  rd1_value_i\\n', '    ,input  [  4:0]  ra0_i\\n', '    ,input  [  4:0]  rb0_i\\n', '    ,input  [  4:0]  ra1_i\\n', '    ,input  [  4:0]  rb1_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  ra0_value_o\\n', '    ,output [ 31:0]  rb0_value_o\\n', '    ,output [ 31:0]  ra1_value_o\\n', '    ,output [ 31:0]  rb1_value_o\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Xilinx specific register file (dual issue)\\n', '//-----------------------------------------------------------------\\n', 'generate\\n', 'if (SUPPORT_REGFILE_XILINX && SUPPORT_DUAL_ISSUE)\\n', 'begin: REGFILE_XILINX\\n', '    wire [31:0] ra0_value_w[1:0];\\n', '    wire [31:0] rb0_value_w[1:0];\\n', '    wire [31:0] ra1_value_w[1:0];\\n', '    wire [31:0] rb1_value_w[1:0];\\n', '\\n', '    biriscv_xilinx_2r1w\\n', '    u_a_0\\n', '    (\\n', '        // Inputs\\n', '         .clk_i(clk_i)\\n', '        ,.rst_i(rst_i)\\n', '        ,.rd0_i(rd0_i)\\n', '        ,.rd0_value_i(rd0_value_i)\\n', '        ,.ra_i(ra0_i)\\n', '        ,.rb_i(rb0_i)\\n', '\\n', '        // Outputs\\n', '        ,.ra_value_o(ra0_value_w[0])\\n', '        ,.rb_value_o(rb0_value_w[0])\\n', '    );\\n', '\\n', '    biriscv_xilinx_2r1w\\n', '    u_a_1\\n', '    (\\n', '        // Inputs\\n', '         .clk_i(clk_i)\\n', '        ,.rst_i(rst_i)\\n', '        ,.rd0_i(rd1_i)\\n', '        ,.rd0_value_i(rd1_value_i)\\n', '        ,.ra_i(ra0_i)\\n', '        ,.rb_i(rb0_i)\\n', '\\n', '        // Outputs\\n', '        ,.ra_value_o(ra0_value_w[1])\\n', '        ,.rb_value_o(rb0_value_w[1])\\n', '    );\\n', '\\n', '    biriscv_xilinx_2r1w\\n', '    u_b_0\\n', '    (\\n', '        // Inputs\\n', '         .clk_i(clk_i)\\n', '        ,.rst_i(rst_i)\\n', '        ,.rd0_i(rd0_i)\\n', '        ,.rd0_value_i(rd0_value_i)\\n', '        ,.ra_i(ra1_i)\\n', '        ,.rb_i(rb1_i)\\n', '\\n', '        // Outputs\\n', '        ,.ra_value_o(ra1_value_w[0])\\n', '        ,.rb_value_o(rb1_value_w[0])\\n', '    );\\n', '\\n', '    biriscv_xilinx_2r1w\\n', '    u_b_1\\n', '    (\\n', '        // Inputs\\n', '         .clk_i(clk_i)\\n', '        ,.rst_i(rst_i)\\n', '        ,.rd0_i(rd1_i)\\n', '        ,.rd0_value_i(rd1_value_i)\\n', '        ,.ra_i(ra1_i)\\n', '        ,.rb_i(rb1_i)\\n', '\\n', '        // Outputs\\n', '        ,.ra_value_o(ra1_value_w[1])\\n', '        ,.rb_value_o(rb1_value_w[1])\\n', '    );\\n', '\\n', '    // Track latest register write \\n', '    reg [31:0] reg_src_q;\\n', '    reg [31:0] reg_src_r;\\n', '\\n', '    always @ *\\n', '    begin\\n', '        reg_src_r = reg_src_q;\\n', '\\n', \"        reg_src_r[rd0_i] = 1'b0;\\n\", \"        reg_src_r[rd1_i] = 1'b1;\\n\", '\\n', '        // Ignore register 0\\n', \"        reg_src_r[0] = 1'b0;\\n\", '    end \\n', '\\n', '    always @ (posedge clk_i or posedge rst_i)\\n', '    if (rst_i)\\n', \"        reg_src_q <= 32'b0;\\n\", '    else\\n', '        reg_src_q <= reg_src_r;\\n', '\\n', '\\n', '    assign ra0_value_o = reg_src_q[ra0_i] ? ra0_value_w[1] : ra0_value_w[0];\\n', '    assign rb0_value_o = reg_src_q[rb0_i] ? rb0_value_w[1] : rb0_value_w[0];\\n', '    assign ra1_value_o = reg_src_q[ra1_i] ? ra1_value_w[1] : ra1_value_w[0];\\n', '    assign rb1_value_o = reg_src_q[rb1_i] ? rb1_value_w[1] : rb1_value_w[0];\\n', 'end\\n', '//-----------------------------------------------------------------\\n', '// Xilinx specific register file (single issue)\\n', '//-----------------------------------------------------------------\\n', 'else if (SUPPORT_REGFILE_XILINX && !SUPPORT_DUAL_ISSUE)\\n', 'begin: REGFILE_XILINX_SINGLE\\n', '\\n', '    biriscv_xilinx_2r1w\\n', '    u_reg\\n', '    (\\n', '        // Inputs\\n', '         .clk_i(clk_i)\\n', '        ,.rst_i(rst_i)\\n', '        ,.rd0_i(rd0_i)\\n', '        ,.rd0_value_i(rd0_value_i)\\n', '        ,.ra_i(ra0_i)\\n', '        ,.rb_i(rb0_i)\\n', '\\n', '        // Outputs\\n', '        ,.ra_value_o(ra0_value_o)\\n', '        ,.rb_value_o(rb0_value_o)\\n', '    );\\n', '\\n', \"    assign ra1_value_o = 32'b0;\\n\", \"    assign rb1_value_o = 32'b0;\\n\", 'end\\n', '//-----------------------------------------------------------------\\n', '// Flop based register file\\n', '//-----------------------------------------------------------------\\n', 'else\\n', 'begin: REGFILE\\n', '    reg [31:0] reg_r1_q;\\n', '    reg [31:0] reg_r2_q;\\n', '    reg [31:0] reg_r3_q;\\n', '    reg [31:0] reg_r4_q;\\n', '    reg [31:0] reg_r5_q;\\n', '    reg [31:0] reg_r6_q;\\n', '    reg [31:0] reg_r7_q;\\n', '    reg [31:0] reg_r8_q;\\n', '    reg [31:0] reg_r9_q;\\n', '    reg [31:0] reg_r10_q;\\n', '    reg [31:0] reg_r11_q;\\n', '    reg [31:0] reg_r12_q;\\n', '    reg [31:0] reg_r13_q;\\n', '    reg [31:0] reg_r14_q;\\n', '    reg [31:0] reg_r15_q;\\n', '    reg [31:0] reg_r16_q;\\n', '    reg [31:0] reg_r17_q;\\n', '    reg [31:0] reg_r18_q;\\n', '    reg [31:0] reg_r19_q;\\n', '    reg [31:0] reg_r20_q;\\n', '    reg [31:0] reg_r21_q;\\n', '    reg [31:0] reg_r22_q;\\n', '    reg [31:0] reg_r23_q;\\n', '    reg [31:0] reg_r24_q;\\n', '    reg [31:0] reg_r25_q;\\n', '    reg [31:0] reg_r26_q;\\n', '    reg [31:0] reg_r27_q;\\n', '    reg [31:0] reg_r28_q;\\n', '    reg [31:0] reg_r29_q;\\n', '    reg [31:0] reg_r30_q;\\n', '    reg [31:0] reg_r31_q;\\n', '\\n', '    // Simulation friendly names\\n', \"    wire [31:0] x0_zero_w = 32'b0;\\n\", '    wire [31:0] x1_ra_w   = reg_r1_q;\\n', '    wire [31:0] x2_sp_w   = reg_r2_q;\\n', '    wire [31:0] x3_gp_w   = reg_r3_q;\\n', '    wire [31:0] x4_tp_w   = reg_r4_q;\\n', '    wire [31:0] x5_t0_w   = reg_r5_q;\\n', '    wire [31:0] x6_t1_w   = reg_r6_q;\\n', '    wire [31:0] x7_t2_w   = reg_r7_q;\\n', '    wire [31:0] x8_s0_w   = reg_r8_q;\\n', '    wire [31:0] x9_s1_w   = reg_r9_q;\\n', '    wire [31:0] x10_a0_w  = reg_r10_q;\\n', '    wire [31:0] x11_a1_w  = reg_r11_q;\\n', '    wire [31:0] x12_a2_w  = reg_r12_q;\\n', '    wire [31:0] x13_a3_w  = reg_r13_q;\\n', '    wire [31:0] x14_a4_w  = reg_r14_q;\\n', '    wire [31:0] x15_a5_w  = reg_r15_q;\\n', '    wire [31:0] x16_a6_w  = reg_r16_q;\\n', '    wire [31:0] x17_a7_w  = reg_r17_q;\\n', '    wire [31:0] x18_s2_w  = reg_r18_q;\\n', '    wire [31:0] x19_s3_w  = reg_r19_q;\\n', '    wire [31:0] x20_s4_w  = reg_r20_q;\\n', '    wire [31:0] x21_s5_w  = reg_r21_q;\\n', '    wire [31:0] x22_s6_w  = reg_r22_q;\\n', '    wire [31:0] x23_s7_w  = reg_r23_q;\\n', '    wire [31:0] x24_s8_w  = reg_r24_q;\\n', '    wire [31:0] x25_s9_w  = reg_r25_q;\\n', '    wire [31:0] x26_s10_w = reg_r26_q;\\n', '    wire [31:0] x27_s11_w = reg_r27_q;\\n', '    wire [31:0] x28_t3_w  = reg_r28_q;\\n', '    wire [31:0] x29_t4_w  = reg_r29_q;\\n', '    wire [31:0] x30_t5_w  = reg_r30_q;\\n', '    wire [31:0] x31_t6_w  = reg_r31_q;\\n', '\\n', '    //-----------------------------------------------------------------\\n', '    // Flop based register File (for simulation)\\n', '    //-----------------------------------------------------------------\\n', '\\n', '    // Synchronous register write back\\n', '    always @ (posedge clk_i )\\n', '    if (rst_i)\\n', '    begin\\n', \"        reg_r1_q       <= 32'h00000000;\\n\", \"        reg_r2_q       <= 32'h00000000;\\n\", \"        reg_r3_q       <= 32'h00000000;\\n\", \"        reg_r4_q       <= 32'h00000000;\\n\", \"        reg_r5_q       <= 32'h00000000;\\n\", \"        reg_r6_q       <= 32'h00000000;\\n\", \"        reg_r7_q       <= 32'h00000000;\\n\", \"        reg_r8_q       <= 32'h00000000;\\n\", \"        reg_r9_q       <= 32'h00000000;\\n\", \"        reg_r10_q      <= 32'h00000000;\\n\", \"        reg_r11_q      <= 32'h00000000;\\n\", \"        reg_r12_q      <= 32'h00000000;\\n\", \"        reg_r13_q      <= 32'h00000000;\\n\", \"        reg_r14_q      <= 32'h00000000;\\n\", \"        reg_r15_q      <= 32'h00000000;\\n\", \"        reg_r16_q      <= 32'h00000000;\\n\", \"        reg_r17_q      <= 32'h00000000;\\n\", \"        reg_r18_q      <= 32'h00000000;\\n\", \"        reg_r19_q      <= 32'h00000000;\\n\", \"        reg_r20_q      <= 32'h00000000;\\n\", \"        reg_r21_q      <= 32'h00000000;\\n\", \"        reg_r22_q      <= 32'h00000000;\\n\", \"        reg_r23_q      <= 32'h00000000;\\n\", \"        reg_r24_q      <= 32'h00000000;\\n\", \"        reg_r25_q      <= 32'h00000000;\\n\", \"        reg_r26_q      <= 32'h00000000;\\n\", \"        reg_r27_q      <= 32'h00000000;\\n\", \"        reg_r28_q      <= 32'h00000000;\\n\", \"        reg_r29_q      <= 32'h00000000;\\n\", \"        reg_r30_q      <= 32'h00000000;\\n\", \"        reg_r31_q      <= 32'h00000000;\\n\", '    end\\n', '    else\\n', '    begin\\n', \"        if      (rd0_i == 5'd1) reg_r1_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd1) reg_r1_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd2) reg_r2_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd2) reg_r2_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd3) reg_r3_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd3) reg_r3_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd4) reg_r4_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd4) reg_r4_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd5) reg_r5_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd5) reg_r5_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd6) reg_r6_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd6) reg_r6_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd7) reg_r7_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd7) reg_r7_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd8) reg_r8_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd8) reg_r8_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd9) reg_r9_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd9) reg_r9_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd10) reg_r10_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd10) reg_r10_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd11) reg_r11_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd11) reg_r11_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd12) reg_r12_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd12) reg_r12_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd13) reg_r13_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd13) reg_r13_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd14) reg_r14_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd14) reg_r14_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd15) reg_r15_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd15) reg_r15_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd16) reg_r16_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd16) reg_r16_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd17) reg_r17_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd17) reg_r17_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd18) reg_r18_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd18) reg_r18_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd19) reg_r19_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd19) reg_r19_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd20) reg_r20_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd20) reg_r20_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd21) reg_r21_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd21) reg_r21_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd22) reg_r22_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd22) reg_r22_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd23) reg_r23_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd23) reg_r23_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd24) reg_r24_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd24) reg_r24_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd25) reg_r25_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd25) reg_r25_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd26) reg_r26_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd26) reg_r26_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd27) reg_r27_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd27) reg_r27_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd28) reg_r28_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd28) reg_r28_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd29) reg_r29_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd29) reg_r29_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd30) reg_r30_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd30) reg_r30_q <= rd1_value_i;\\n\", \"        if      (rd0_i == 5'd31) reg_r31_q <= rd0_value_i;\\n\", \"        else if (rd1_i == 5'd31) reg_r31_q <= rd1_value_i;\\n\", '    end\\n', '\\n', '    //-----------------------------------------------------------------\\n', '    // Asynchronous read\\n', '    //-----------------------------------------------------------------\\n', '    reg [31:0] ra0_value_r;\\n', '    reg [31:0] rb0_value_r;\\n', '    always @ *\\n', '    begin\\n', '        case (ra0_i)\\n', \"        5'd1: ra0_value_r = reg_r1_q;\\n\", \"        5'd2: ra0_value_r = reg_r2_q;\\n\", \"        5'd3: ra0_value_r = reg_r3_q;\\n\", \"        5'd4: ra0_value_r = reg_r4_q;\\n\", \"        5'd5: ra0_value_r = reg_r5_q;\\n\", \"        5'd6: ra0_value_r = reg_r6_q;\\n\", \"        5'd7: ra0_value_r = reg_r7_q;\\n\", \"        5'd8: ra0_value_r = reg_r8_q;\\n\", \"        5'd9: ra0_value_r = reg_r9_q;\\n\", \"        5'd10: ra0_value_r = reg_r10_q;\\n\", \"        5'd11: ra0_value_r = reg_r11_q;\\n\", \"        5'd12: ra0_value_r = reg_r12_q;\\n\", \"        5'd13: ra0_value_r = reg_r13_q;\\n\", \"        5'd14: ra0_value_r = reg_r14_q;\\n\", \"        5'd15: ra0_value_r = reg_r15_q;\\n\", \"        5'd16: ra0_value_r = reg_r16_q;\\n\", \"        5'd17: ra0_value_r = reg_r17_q;\\n\", \"        5'd18: ra0_value_r = reg_r18_q;\\n\", \"        5'd19: ra0_value_r = reg_r19_q;\\n\", \"        5'd20: ra0_value_r = reg_r20_q;\\n\", \"        5'd21: ra0_value_r = reg_r21_q;\\n\", \"        5'd22: ra0_value_r = reg_r22_q;\\n\", \"        5'd23: ra0_value_r = reg_r23_q;\\n\", \"        5'd24: ra0_value_r = reg_r24_q;\\n\", \"        5'd25: ra0_value_r = reg_r25_q;\\n\", \"        5'd26: ra0_value_r = reg_r26_q;\\n\", \"        5'd27: ra0_value_r = reg_r27_q;\\n\", \"        5'd28: ra0_value_r = reg_r28_q;\\n\", \"        5'd29: ra0_value_r = reg_r29_q;\\n\", \"        5'd30: ra0_value_r = reg_r30_q;\\n\", \"        5'd31: ra0_value_r = reg_r31_q;\\n\", \"        default : ra0_value_r = 32'h00000000;\\n\", '        endcase\\n', '\\n', '        case (rb0_i)\\n', \"        5'd1: rb0_value_r = reg_r1_q;\\n\", \"        5'd2: rb0_value_r = reg_r2_q;\\n\", \"        5'd3: rb0_value_r = reg_r3_q;\\n\", \"        5'd4: rb0_value_r = reg_r4_q;\\n\", \"        5'd5: rb0_value_r = reg_r5_q;\\n\", \"        5'd6: rb0_value_r = reg_r6_q;\\n\", \"        5'd7: rb0_value_r = reg_r7_q;\\n\", \"        5'd8: rb0_value_r = reg_r8_q;\\n\", \"        5'd9: rb0_value_r = reg_r9_q;\\n\", \"        5'd10: rb0_value_r = reg_r10_q;\\n\", \"        5'd11: rb0_value_r = reg_r11_q;\\n\", \"        5'd12: rb0_value_r = reg_r12_q;\\n\", \"        5'd13: rb0_value_r = reg_r13_q;\\n\", \"        5'd14: rb0_value_r = reg_r14_q;\\n\", \"        5'd15: rb0_value_r = reg_r15_q;\\n\", \"        5'd16: rb0_value_r = reg_r16_q;\\n\", \"        5'd17: rb0_value_r = reg_r17_q;\\n\", \"        5'd18: rb0_value_r = reg_r18_q;\\n\", \"        5'd19: rb0_value_r = reg_r19_q;\\n\", \"        5'd20: rb0_value_r = reg_r20_q;\\n\", \"        5'd21: rb0_value_r = reg_r21_q;\\n\", \"        5'd22: rb0_value_r = reg_r22_q;\\n\", \"        5'd23: rb0_value_r = reg_r23_q;\\n\", \"        5'd24: rb0_value_r = reg_r24_q;\\n\", \"        5'd25: rb0_value_r = reg_r25_q;\\n\", \"        5'd26: rb0_value_r = reg_r26_q;\\n\", \"        5'd27: rb0_value_r = reg_r27_q;\\n\", \"        5'd28: rb0_value_r = reg_r28_q;\\n\", \"        5'd29: rb0_value_r = reg_r29_q;\\n\", \"        5'd30: rb0_value_r = reg_r30_q;\\n\", \"        5'd31: rb0_value_r = reg_r31_q;\\n\", \"        default : rb0_value_r = 32'h00000000;\\n\", '        endcase\\n', '    end\\n', '\\n', '    assign ra0_value_o = ra0_value_r;\\n', '    assign rb0_value_o = rb0_value_r;\\n', '\\n', '\\n', '    reg [31:0] ra1_value_r;\\n', '    reg [31:0] rb1_value_r;\\n', '    always @ *\\n', '    begin\\n', '        case (ra1_i)\\n', \"        5'd1: ra1_value_r = reg_r1_q;\\n\", \"        5'd2: ra1_value_r = reg_r2_q;\\n\", \"        5'd3: ra1_value_r = reg_r3_q;\\n\", \"        5'd4: ra1_value_r = reg_r4_q;\\n\", \"        5'd5: ra1_value_r = reg_r5_q;\\n\", \"        5'd6: ra1_value_r = reg_r6_q;\\n\", \"        5'd7: ra1_value_r = reg_r7_q;\\n\", \"        5'd8: ra1_value_r = reg_r8_q;\\n\", \"        5'd9: ra1_value_r = reg_r9_q;\\n\", \"        5'd10: ra1_value_r = reg_r10_q;\\n\", \"        5'd11: ra1_value_r = reg_r11_q;\\n\", \"        5'd12: ra1_value_r = reg_r12_q;\\n\", \"        5'd13: ra1_value_r = reg_r13_q;\\n\", \"        5'd14: ra1_value_r = reg_r14_q;\\n\", \"        5'd15: ra1_value_r = reg_r15_q;\\n\", \"        5'd16: ra1_value_r = reg_r16_q;\\n\", \"        5'd17: ra1_value_r = reg_r17_q;\\n\", \"        5'd18: ra1_value_r = reg_r18_q;\\n\", \"        5'd19: ra1_value_r = reg_r19_q;\\n\", \"        5'd20: ra1_value_r = reg_r20_q;\\n\", \"        5'd21: ra1_value_r = reg_r21_q;\\n\", \"        5'd22: ra1_value_r = reg_r22_q;\\n\", \"        5'd23: ra1_value_r = reg_r23_q;\\n\", \"        5'd24: ra1_value_r = reg_r24_q;\\n\", \"        5'd25: ra1_value_r = reg_r25_q;\\n\", \"        5'd26: ra1_value_r = reg_r26_q;\\n\", \"        5'd27: ra1_value_r = reg_r27_q;\\n\", \"        5'd28: ra1_value_r = reg_r28_q;\\n\", \"        5'd29: ra1_value_r = reg_r29_q;\\n\", \"        5'd30: ra1_value_r = reg_r30_q;\\n\", \"        5'd31: ra1_value_r = reg_r31_q;\\n\", \"        default : ra1_value_r = 32'h00000000;\\n\", '        endcase\\n', '\\n', '        case (rb1_i)\\n', \"        5'd1: rb1_value_r = reg_r1_q;\\n\", \"        5'd2: rb1_value_r = reg_r2_q;\\n\", \"        5'd3: rb1_value_r = reg_r3_q;\\n\", \"        5'd4: rb1_value_r = reg_r4_q;\\n\", \"        5'd5: rb1_value_r = reg_r5_q;\\n\", \"        5'd6: rb1_value_r = reg_r6_q;\\n\", \"        5'd7: rb1_value_r = reg_r7_q;\\n\", \"        5'd8: rb1_value_r = reg_r8_q;\\n\", \"        5'd9: rb1_value_r = reg_r9_q;\\n\", \"        5'd10: rb1_value_r = reg_r10_q;\\n\", \"        5'd11: rb1_value_r = reg_r11_q;\\n\", \"        5'd12: rb1_value_r = reg_r12_q;\\n\", \"        5'd13: rb1_value_r = reg_r13_q;\\n\", \"        5'd14: rb1_value_r = reg_r14_q;\\n\", \"        5'd15: rb1_value_r = reg_r15_q;\\n\", \"        5'd16: rb1_value_r = reg_r16_q;\\n\", \"        5'd17: rb1_value_r = reg_r17_q;\\n\", \"        5'd18: rb1_value_r = reg_r18_q;\\n\", \"        5'd19: rb1_value_r = reg_r19_q;\\n\", \"        5'd20: rb1_value_r = reg_r20_q;\\n\", \"        5'd21: rb1_value_r = reg_r21_q;\\n\", \"        5'd22: rb1_value_r = reg_r22_q;\\n\", \"        5'd23: rb1_value_r = reg_r23_q;\\n\", \"        5'd24: rb1_value_r = reg_r24_q;\\n\", \"        5'd25: rb1_value_r = reg_r25_q;\\n\", \"        5'd26: rb1_value_r = reg_r26_q;\\n\", \"        5'd27: rb1_value_r = reg_r27_q;\\n\", \"        5'd28: rb1_value_r = reg_r28_q;\\n\", \"        5'd29: rb1_value_r = reg_r29_q;\\n\", \"        5'd30: rb1_value_r = reg_r30_q;\\n\", \"        5'd31: rb1_value_r = reg_r31_q;\\n\", \"        default : rb1_value_r = 32'h00000000;\\n\", '        endcase\\n', '    end\\n', '\\n', '    assign ra1_value_o = ra1_value_r;\\n', '    assign rb1_value_o = rb1_value_r;\\n', '\\n', '    //-------------------------------------------------------------\\n', '    // get_register: Read register file\\n', '    //-------------------------------------------------------------\\n', '    `ifdef verilator\\n', '    function [31:0] get_register; /*verilator public*/\\n', '        input [4:0] r;\\n', '    begin\\n', '        case (r)\\n', \"        5'd1: get_register = reg_r1_q;\\n\", \"        5'd2: get_register = reg_r2_q;\\n\", \"        5'd3: get_register = reg_r3_q;\\n\", \"        5'd4: get_register = reg_r4_q;\\n\", \"        5'd5: get_register = reg_r5_q;\\n\", \"        5'd6: get_register = reg_r6_q;\\n\", \"        5'd7: get_register = reg_r7_q;\\n\", \"        5'd8: get_register = reg_r8_q;\\n\", \"        5'd9: get_register = reg_r9_q;\\n\", \"        5'd10: get_register = reg_r10_q;\\n\", \"        5'd11: get_register = reg_r11_q;\\n\", \"        5'd12: get_register = reg_r12_q;\\n\", \"        5'd13: get_register = reg_r13_q;\\n\", \"        5'd14: get_register = reg_r14_q;\\n\", \"        5'd15: get_register = reg_r15_q;\\n\", \"        5'd16: get_register = reg_r16_q;\\n\", \"        5'd17: get_register = reg_r17_q;\\n\", \"        5'd18: get_register = reg_r18_q;\\n\", \"        5'd19: get_register = reg_r19_q;\\n\", \"        5'd20: get_register = reg_r20_q;\\n\", \"        5'd21: get_register = reg_r21_q;\\n\", \"        5'd22: get_register = reg_r22_q;\\n\", \"        5'd23: get_register = reg_r23_q;\\n\", \"        5'd24: get_register = reg_r24_q;\\n\", \"        5'd25: get_register = reg_r25_q;\\n\", \"        5'd26: get_register = reg_r26_q;\\n\", \"        5'd27: get_register = reg_r27_q;\\n\", \"        5'd28: get_register = reg_r28_q;\\n\", \"        5'd29: get_register = reg_r29_q;\\n\", \"        5'd30: get_register = reg_r30_q;\\n\", \"        5'd31: get_register = reg_r31_q;\\n\", \"        default : get_register = 32'h00000000;\\n\", '        endcase\\n', '    end\\n', '    endfunction\\n', '    //-------------------------------------------------------------\\n', '    // set_register: Write register file\\n', '    //-------------------------------------------------------------\\n', '    function set_register; /*verilator public*/\\n', '        input [4:0] r;\\n', '        input [31:0] value;\\n', '    begin\\n', '        //case (r)\\n', \"        //5'd1:  reg_r1_q  <= value;\\n\", \"        //5'd2:  reg_r2_q  <= value;\\n\", \"        //5'd3:  reg_r3_q  <= value;\\n\", \"        //5'd4:  reg_r4_q  <= value;\\n\", \"        //5'd5:  reg_r5_q  <= value;\\n\", \"        //5'd6:  reg_r6_q  <= value;\\n\", \"        //5'd7:  reg_r7_q  <= value;\\n\", \"        //5'd8:  reg_r8_q  <= value;\\n\", \"        //5'd9:  reg_r9_q  <= value;\\n\", \"        //5'd10: reg_r10_q <= value;\\n\", \"        //5'd11: reg_r11_q <= value;\\n\", \"        //5'd12: reg_r12_q <= value;\\n\", \"        //5'd13: reg_r13_q <= value;\\n\", \"        //5'd14: reg_r14_q <= value;\\n\", \"        //5'd15: reg_r15_q <= value;\\n\", \"        //5'd16: reg_r16_q <= value;\\n\", \"        //5'd17: reg_r17_q <= value;\\n\", \"        //5'd18: reg_r18_q <= value;\\n\", \"        //5'd19: reg_r19_q <= value;\\n\", \"        //5'd20: reg_r20_q <= value;\\n\", \"        //5'd21: reg_r21_q <= value;\\n\", \"        //5'd22: reg_r22_q <= value;\\n\", \"        //5'd23: reg_r23_q <= value;\\n\", \"        //5'd24: reg_r24_q <= value;\\n\", \"        //5'd25: reg_r25_q <= value;\\n\", \"        //5'd26: reg_r26_q <= value;\\n\", \"        //5'd27: reg_r27_q <= value;\\n\", \"        //5'd28: reg_r28_q <= value;\\n\", \"        //5'd29: reg_r29_q <= value;\\n\", \"        //5'd30: reg_r30_q <= value;\\n\", \"        //5'd31: reg_r31_q <= value;\\n\", '        //default :\\n', '        //    ;\\n', '        //endcase\\n', '    end\\n', '    endfunction\\n', '    `endif\\n', '\\n', 'end\\n', 'endgenerate\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '`include \"biriscv_defs.v\"\\n', '\\n', 'module biriscv_trace_sim\\n', '(\\n', '     input                        valid_i\\n', '    ,input  [31:0]                pc_i\\n', '    ,input  [31:0]                opcode_i\\n', ');\\n', '\\n', '//-----------------------------------------------------------------\\n', '// get_regname_str: Convert register number to string\\n', '//-----------------------------------------------------------------\\n', '`ifdef verilator\\n', 'function [79:0] get_regname_str;\\n', '    input  [4:0] regnum;\\n', 'begin\\n', '    case (regnum)\\n', '        5\\'d0:  get_regname_str = \"zero\";\\n', '        5\\'d1:  get_regname_str = \"ra\";\\n', '        5\\'d2:  get_regname_str = \"sp\";\\n', '        5\\'d3:  get_regname_str = \"gp\";\\n', '        5\\'d4:  get_regname_str = \"tp\";\\n', '        5\\'d5:  get_regname_str = \"t0\";\\n', '        5\\'d6:  get_regname_str = \"t1\";\\n', '        5\\'d7:  get_regname_str = \"t2\";\\n', '        5\\'d8:  get_regname_str = \"s0\";\\n', '        5\\'d9:  get_regname_str = \"s1\";\\n', '        5\\'d10: get_regname_str = \"a0\";\\n', '        5\\'d11: get_regname_str = \"a1\";\\n', '        5\\'d12: get_regname_str = \"a2\";\\n', '        5\\'d13: get_regname_str = \"a3\";\\n', '        5\\'d14: get_regname_str = \"a4\";\\n', '        5\\'d15: get_regname_str = \"a5\";\\n', '        5\\'d16: get_regname_str = \"a6\";\\n', '        5\\'d17: get_regname_str = \"a7\";\\n', '        5\\'d18: get_regname_str = \"s2\";\\n', '        5\\'d19: get_regname_str = \"s3\";\\n', '        5\\'d20: get_regname_str = \"s4\";\\n', '        5\\'d21: get_regname_str = \"s5\";\\n', '        5\\'d22: get_regname_str = \"s6\";\\n', '        5\\'d23: get_regname_str = \"s7\";\\n', '        5\\'d24: get_regname_str = \"s8\";\\n', '        5\\'d25: get_regname_str = \"s9\";\\n', '        5\\'d26: get_regname_str = \"s10\";\\n', '        5\\'d27: get_regname_str = \"s11\";\\n', '        5\\'d28: get_regname_str = \"t3\";\\n', '        5\\'d29: get_regname_str = \"t4\";\\n', '        5\\'d30: get_regname_str = \"t5\";\\n', '        5\\'d31: get_regname_str = \"t6\";\\n', '    endcase\\n', 'end\\n', 'endfunction\\n', '\\n', '//-------------------------------------------------------------------\\n', '// Debug strings\\n', '//-------------------------------------------------------------------\\n', 'reg [79:0] dbg_inst_str;\\n', 'reg [79:0] dbg_inst_ra;\\n', 'reg [79:0] dbg_inst_rb;\\n', 'reg [79:0] dbg_inst_rd;\\n', 'reg [31:0] dbg_inst_imm;\\n', 'reg [31:0] dbg_inst_pc;\\n', '\\n', 'wire [4:0] ra_idx_w = opcode_i[19:15];\\n', 'wire [4:0] rb_idx_w = opcode_i[24:20];\\n', 'wire [4:0] rd_idx_w = opcode_i[11:7];\\n', '\\n', \"`define DBG_IMM_IMM20     {opcode_i[31:12], 12'b0}\\n\", '`define DBG_IMM_IMM12     {{20{opcode_i[31]}}, opcode_i[31:20]}\\n', \"`define DBG_IMM_BIMM      {{19{opcode_i[31]}}, opcode_i[31], opcode_i[7], opcode_i[30:25], opcode_i[11:8], 1'b0}\\n\", \"`define DBG_IMM_JIMM20    {{12{opcode_i[31]}}, opcode_i[19:12], opcode_i[20], opcode_i[30:25], opcode_i[24:21], 1'b0}\\n\", '`define DBG_IMM_STOREIMM  {{20{opcode_i[31]}}, opcode_i[31:25], opcode_i[11:7]}\\n', '`define DBG_IMM_SHAMT     opcode_i[24:20]\\n', '\\n', 'always @ *\\n', 'begin\\n', '    dbg_inst_str = \"-\";\\n', '    dbg_inst_ra  = \"-\";\\n', '    dbg_inst_rb  = \"-\";\\n', '    dbg_inst_rd  = \"-\";\\n', \"    dbg_inst_pc  = 32'bx;\\n\", '\\n', '    if (valid_i)\\n', '    begin\\n', '        dbg_inst_pc  = pc_i;\\n', '        dbg_inst_ra  = get_regname_str(ra_idx_w);\\n', '        dbg_inst_rb  = get_regname_str(rb_idx_w);\\n', '        dbg_inst_rd  = get_regname_str(rd_idx_w);\\n', '\\n', \"        case (1'b1)\\n\", '            ((opcode_i & `INST_ANDI_MASK) == `INST_ANDI)   : dbg_inst_str = \"andi\";\\n', '            ((opcode_i & `INST_ADDI_MASK) == `INST_ADDI)   : dbg_inst_str = \"addi\";\\n', '            ((opcode_i & `INST_SLTI_MASK) == `INST_SLTI)   : dbg_inst_str = \"slti\";\\n', '            ((opcode_i & `INST_SLTIU_MASK) == `INST_SLTIU)  : dbg_inst_str = \"sltiu\";\\n', '            ((opcode_i & `INST_ORI_MASK) == `INST_ORI)    : dbg_inst_str = \"ori\";\\n', '            ((opcode_i & `INST_XORI_MASK) == `INST_XORI)   : dbg_inst_str = \"xori\";\\n', '            ((opcode_i & `INST_SLLI_MASK) == `INST_SLLI)   : dbg_inst_str = \"slli\";\\n', '            ((opcode_i & `INST_SRLI_MASK) == `INST_SRLI)   : dbg_inst_str = \"srli\";\\n', '            ((opcode_i & `INST_SRAI_MASK) == `INST_SRAI)   : dbg_inst_str = \"srai\";\\n', '            ((opcode_i & `INST_LUI_MASK) == `INST_LUI)    : dbg_inst_str = \"lui\";\\n', '            ((opcode_i & `INST_AUIPC_MASK) == `INST_AUIPC)  : dbg_inst_str = \"auipc\";\\n', '            ((opcode_i & `INST_ADD_MASK) == `INST_ADD)    : dbg_inst_str = \"add\";\\n', '            ((opcode_i & `INST_SUB_MASK) == `INST_SUB)    : dbg_inst_str = \"sub\";\\n', '            ((opcode_i & `INST_SLT_MASK) == `INST_SLT)    : dbg_inst_str = \"slt\";\\n', '            ((opcode_i & `INST_SLTU_MASK) == `INST_SLTU)   : dbg_inst_str = \"sltu\";\\n', '            ((opcode_i & `INST_XOR_MASK) == `INST_XOR)    : dbg_inst_str = \"xor\";\\n', '            ((opcode_i & `INST_OR_MASK) == `INST_OR)     : dbg_inst_str = \"or\";\\n', '            ((opcode_i & `INST_AND_MASK) == `INST_AND)    : dbg_inst_str = \"and\";\\n', '            ((opcode_i & `INST_SLL_MASK) == `INST_SLL)    : dbg_inst_str = \"sll\";\\n', '            ((opcode_i & `INST_SRL_MASK) == `INST_SRL)    : dbg_inst_str = \"srl\";\\n', '            ((opcode_i & `INST_SRA_MASK) == `INST_SRA)    : dbg_inst_str = \"sra\";\\n', '            ((opcode_i & `INST_JAL_MASK) == `INST_JAL)    : dbg_inst_str = \"jal\";\\n', '            ((opcode_i & `INST_JALR_MASK) == `INST_JALR)   : dbg_inst_str = \"jalr\";\\n', '            ((opcode_i & `INST_BEQ_MASK) == `INST_BEQ)    : dbg_inst_str = \"beq\";\\n', '            ((opcode_i & `INST_BNE_MASK) == `INST_BNE)    : dbg_inst_str = \"bne\";\\n', '            ((opcode_i & `INST_BLT_MASK) == `INST_BLT)    : dbg_inst_str = \"blt\";\\n', '            ((opcode_i & `INST_BGE_MASK) == `INST_BGE)    : dbg_inst_str = \"bge\";\\n', '            ((opcode_i & `INST_BLTU_MASK) == `INST_BLTU)   : dbg_inst_str = \"bltu\";\\n', '            ((opcode_i & `INST_BGEU_MASK) == `INST_BGEU)   : dbg_inst_str = \"bgeu\";\\n', '            ((opcode_i & `INST_LB_MASK) == `INST_LB)     : dbg_inst_str = \"lb\";\\n', '            ((opcode_i & `INST_LH_MASK) == `INST_LH)     : dbg_inst_str = \"lh\";\\n', '            ((opcode_i & `INST_LW_MASK) == `INST_LW)     : dbg_inst_str = \"lw\";\\n', '            ((opcode_i & `INST_LBU_MASK) == `INST_LBU)    : dbg_inst_str = \"lbu\";\\n', '            ((opcode_i & `INST_LHU_MASK) == `INST_LHU)    : dbg_inst_str = \"lhu\";\\n', '            ((opcode_i & `INST_LWU_MASK) == `INST_LWU)    : dbg_inst_str = \"lwu\";\\n', '            ((opcode_i & `INST_SB_MASK) == `INST_SB)     : dbg_inst_str = \"sb\";\\n', '            ((opcode_i & `INST_SH_MASK) == `INST_SH)     : dbg_inst_str = \"sh\";\\n', '            ((opcode_i & `INST_SW_MASK) == `INST_SW)     : dbg_inst_str = \"sw\";\\n', '            ((opcode_i & `INST_ECALL_MASK) == `INST_ECALL)  : dbg_inst_str = \"ecall\";\\n', '            ((opcode_i & `INST_EBREAK_MASK) == `INST_EBREAK) : dbg_inst_str = \"ebreak\";\\n', '            ((opcode_i & `INST_ERET_MASK) == `INST_ERET)   : dbg_inst_str = \"eret\";\\n', '            ((opcode_i & `INST_CSRRW_MASK) == `INST_CSRRW)  : dbg_inst_str = \"csrrw\";\\n', '            ((opcode_i & `INST_CSRRS_MASK) == `INST_CSRRS)  : dbg_inst_str = \"csrrs\";\\n', '            ((opcode_i & `INST_CSRRC_MASK) == `INST_CSRRC)  : dbg_inst_str = \"csrrc\";\\n', '            ((opcode_i & `INST_CSRRWI_MASK) == `INST_CSRRWI) : dbg_inst_str = \"csrrwi\";\\n', '            ((opcode_i & `INST_CSRRSI_MASK) == `INST_CSRRSI) : dbg_inst_str = \"csrrsi\";\\n', '            ((opcode_i & `INST_CSRRCI_MASK) == `INST_CSRRCI) : dbg_inst_str = \"csrrci\";\\n', '            ((opcode_i & `INST_MUL_MASK) == `INST_MUL)    : dbg_inst_str = \"mul\";\\n', '            ((opcode_i & `INST_MULH_MASK) == `INST_MULH)   : dbg_inst_str = \"mulh\";\\n', '            ((opcode_i & `INST_MULHSU_MASK) == `INST_MULHSU) : dbg_inst_str = \"mulhsu\";\\n', '            ((opcode_i & `INST_MULHU_MASK) == `INST_MULHU)  : dbg_inst_str = \"mulhu\";\\n', '            ((opcode_i & `INST_DIV_MASK) == `INST_DIV)    : dbg_inst_str = \"div\";\\n', '            ((opcode_i & `INST_DIVU_MASK) == `INST_DIVU)   : dbg_inst_str = \"divu\";\\n', '            ((opcode_i & `INST_REM_MASK) == `INST_REM)    : dbg_inst_str = \"rem\";\\n', '            ((opcode_i & `INST_REMU_MASK) == `INST_REMU)   : dbg_inst_str = \"remu\";\\n', '            ((opcode_i & `INST_IFENCE_MASK) == `INST_IFENCE)  : dbg_inst_str = \"fence.i\";\\n', '        endcase\\n', '\\n', \"        case (1'b1)\\n\", '\\n', '            ((opcode_i & `INST_ADDI_MASK) == `INST_ADDI) ,  // addi\\n', '            ((opcode_i & `INST_ANDI_MASK) == `INST_ANDI) ,  // andi\\n', '            ((opcode_i & `INST_SLTI_MASK) == `INST_SLTI) ,  // slti\\n', '            ((opcode_i & `INST_SLTIU_MASK) == `INST_SLTIU) , // sltiu\\n', '            ((opcode_i & `INST_ORI_MASK) == `INST_ORI) ,   // ori\\n', '            ((opcode_i & `INST_XORI_MASK) == `INST_XORI) ,  // xori\\n', '            ((opcode_i & `INST_CSRRW_MASK) == `INST_CSRRW) , // csrrw\\n', '            ((opcode_i & `INST_CSRRS_MASK) == `INST_CSRRS) , // csrrs\\n', '            ((opcode_i & `INST_CSRRC_MASK) == `INST_CSRRC) , // csrrc\\n', '            ((opcode_i & `INST_CSRRWI_MASK) == `INST_CSRRWI) ,// csrrwi\\n', '            ((opcode_i & `INST_CSRRSI_MASK) == `INST_CSRRSI) ,// csrrsi\\n', '            ((opcode_i & `INST_CSRRCI_MASK) == `INST_CSRRCI) :// csrrci\\n', '            begin\\n', '                dbg_inst_rb  = \"-\";\\n', '                dbg_inst_imm = `DBG_IMM_IMM12;\\n', '            end\\n', '\\n', '            ((opcode_i & `INST_SLLI_MASK) == `INST_SLLI) , // slli\\n', '            ((opcode_i & `INST_SRLI_MASK) == `INST_SRLI) , // srli\\n', '            ((opcode_i & `INST_SRAI_MASK) == `INST_SRAI) : // srai\\n', '            begin\\n', '                dbg_inst_rb  = \"-\";\\n', \"                dbg_inst_imm = {27'b0, `DBG_IMM_SHAMT};\\n\", '            end\\n', '\\n', '            ((opcode_i & `INST_LUI_MASK) == `INST_LUI) : // lui\\n', '            begin\\n', '                dbg_inst_ra  = \"-\";\\n', '                dbg_inst_rb  = \"-\";\\n', '                dbg_inst_imm = `DBG_IMM_IMM20;\\n', '            end\\n', '\\n', '            ((opcode_i & `INST_AUIPC_MASK) == `INST_AUIPC) : // auipc\\n', '            begin\\n', '                dbg_inst_ra  = \"pc\";\\n', '                dbg_inst_rb  = \"-\";\\n', '                dbg_inst_imm = `DBG_IMM_IMM20;\\n', '            end   \\n', '\\n', '            ((opcode_i & `INST_JAL_MASK) == `INST_JAL) :  // jal\\n', '            begin\\n', '                dbg_inst_ra  = \"-\";\\n', '                dbg_inst_rb  = \"-\";\\n', '                dbg_inst_imm = pc_i + `DBG_IMM_JIMM20;\\n', '\\n', \"                if (rd_idx_w == 5'd1)\\n\", '                    dbg_inst_str = \"call\";\\n', '            end\\n', '\\n', '            ((opcode_i & `INST_JALR_MASK) == `INST_JALR) : // jalr\\n', '            begin\\n', '                dbg_inst_rb  = \"-\";\\n', '                dbg_inst_imm = `DBG_IMM_IMM12;\\n', '\\n', \"               if (ra_idx_w == 5'd1 && `DBG_IMM_IMM12 == 32'b0)\\n\", '                    dbg_inst_str = \"ret\";\\n', \"               else if (rd_idx_w == 5'd1)\\n\", '                    dbg_inst_str = \"call (R)\";\\n', '            end\\n', '\\n', '            // lb lh lw lbu lhu lwu\\n', '            ((opcode_i & `INST_LB_MASK) == `INST_LB) ,\\n', '            ((opcode_i & `INST_LH_MASK) == `INST_LH) ,\\n', '            ((opcode_i & `INST_LW_MASK) == `INST_LW) ,\\n', '            ((opcode_i & `INST_LBU_MASK) == `INST_LBU) ,\\n', '            ((opcode_i & `INST_LHU_MASK) == `INST_LHU) ,\\n', '            ((opcode_i & `INST_LWU_MASK) == `INST_LWU) :\\n', '            begin\\n', '                dbg_inst_rb  = \"-\";\\n', '                dbg_inst_imm = `DBG_IMM_IMM12;\\n', '            end \\n', '\\n', '            // sb sh sw\\n', '            ((opcode_i & `INST_SB_MASK) == `INST_SB) ,\\n', '            ((opcode_i & `INST_SH_MASK) == `INST_SH) ,\\n', '            ((opcode_i & `INST_SW_MASK) == `INST_SW) :\\n', '            begin\\n', '                dbg_inst_rd  = \"-\";\\n', '                dbg_inst_imm = `DBG_IMM_STOREIMM;\\n', '            end\\n', '        endcase        \\n', '    end\\n', 'end\\n', '`endif\\n', '\\n', 'endmodule\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '//-----------------------------------------------------------------\\n', '// Module - Xilinx register file (2 async read, 1 write port)\\n', '//-----------------------------------------------------------------\\n', 'module biriscv_xilinx_2r1w\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input  [  4:0]  rd0_i\\n', '    ,input  [ 31:0]  rd0_value_i\\n', '    ,input  [  4:0]  ra_i\\n', '    ,input  [  4:0]  rb_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  ra_value_o\\n', '    ,output [ 31:0]  rb_value_o\\n', ');\\n', '\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Registers / Wires\\n', '//-----------------------------------------------------------------\\n', 'wire [31:0]     reg_rs1_w;\\n', 'wire [31:0]     reg_rs2_w;\\n', 'wire [31:0]     rs1_0_15_w;\\n', 'wire [31:0]     rs1_16_31_w;\\n', 'wire [31:0]     rs2_0_15_w;\\n', 'wire [31:0]     rs2_16_31_w;\\n', 'wire            write_enable_w;\\n', 'wire            write_banka_w;\\n', 'wire            write_bankb_w;\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Register File (using RAM16X1D )\\n', '//-----------------------------------------------------------------\\n', 'genvar i;\\n', '\\n', '// Registers 0 - 15\\n', 'generate\\n', 'for (i=0;i<32;i=i+1)\\n', 'begin : reg_loop1\\n', '    RAM16X1D reg_bit1a(.WCLK(clk_i), .WE(write_banka_w), .A0(rd0_i[0]), .A1(rd0_i[1]), .A2(rd0_i[2]), .A3(rd0_i[3]), .D(rd0_value_i[i]), .DPRA0(ra_i[0]), .DPRA1(ra_i[1]), .DPRA2(ra_i[2]), .DPRA3(ra_i[3]), .DPO(rs1_0_15_w[i]), .SPO(/* open */));\\n', '    RAM16X1D reg_bit2a(.WCLK(clk_i), .WE(write_banka_w), .A0(rd0_i[0]), .A1(rd0_i[1]), .A2(rd0_i[2]), .A3(rd0_i[3]), .D(rd0_value_i[i]), .DPRA0(rb_i[0]), .DPRA1(rb_i[1]), .DPRA2(rb_i[2]), .DPRA3(rb_i[3]), .DPO(rs2_0_15_w[i]), .SPO(/* open */));\\n', 'end\\n', 'endgenerate\\n', '\\n', '// Registers 16 - 31\\n', 'generate\\n', 'for (i=0;i<32;i=i+1)\\n', 'begin : reg_loop2\\n', '    RAM16X1D reg_bit1b(.WCLK(clk_i), .WE(write_bankb_w), .A0(rd0_i[0]), .A1(rd0_i[1]), .A2(rd0_i[2]), .A3(rd0_i[3]), .D(rd0_value_i[i]), .DPRA0(ra_i[0]), .DPRA1(ra_i[1]), .DPRA2(ra_i[2]), .DPRA3(ra_i[3]), .DPO(rs1_16_31_w[i]), .SPO(/* open */));\\n', '    RAM16X1D reg_bit2b(.WCLK(clk_i), .WE(write_bankb_w), .A0(rd0_i[0]), .A1(rd0_i[1]), .A2(rd0_i[2]), .A3(rd0_i[3]), .D(rd0_value_i[i]), .DPRA0(rb_i[0]), .DPRA1(rb_i[1]), .DPRA2(rb_i[2]), .DPRA3(rb_i[3]), .DPO(rs2_16_31_w[i]), .SPO(/* open */));\\n', 'end\\n', 'endgenerate\\n', '\\n', '//-----------------------------------------------------------------\\n', '// Combinatorial Assignments\\n', '//-----------------------------------------------------------------\\n', \"assign reg_rs1_w       = (ra_i[4] == 1'b0) ? rs1_0_15_w : rs1_16_31_w;\\n\", \"assign reg_rs2_w       = (rb_i[4] == 1'b0) ? rs2_0_15_w : rs2_16_31_w;\\n\", '\\n', \"assign write_enable_w = (rd0_i != 5'b00000);\\n\", '\\n', 'assign write_banka_w  = (write_enable_w & (~rd0_i[4]));\\n', 'assign write_bankb_w  = (write_enable_w & rd0_i[4]);\\n', '\\n', 'reg [31:0] ra_value_r;\\n', 'reg [31:0] rb_value_r;\\n', '\\n', '// Register read ports\\n', 'always @ *\\n', 'begin\\n', \"    if (ra_i == 5'b00000)\\n\", \"        ra_value_r = 32'h00000000;\\n\", '    else\\n', '        ra_value_r = reg_rs1_w;\\n', '\\n', \"    if (rb_i == 5'b00000)\\n\", \"        rb_value_r = 32'h00000000;\\n\", '    else\\n', '        rb_value_r = reg_rs2_w;\\n', 'end\\n', '\\n', 'assign ra_value_o = ra_value_r;\\n', 'assign rb_value_o = rb_value_r;\\n', '\\n', 'endmodule\\n', '\\n', '//-------------------------------------------------------------\\n', '// RAM16X1D: Verilator target RAM16X1D model\\n', '//-------------------------------------------------------------\\n', '`ifdef verilator\\n', 'module RAM16X1D (DPO, SPO, A0, A1, A2, A3, D, DPRA0, DPRA1, DPRA2, DPRA3, WCLK, WE);\\n', '\\n', \"    parameter INIT = 16'h0000;\\n\", '\\n', '    output DPO, SPO;\\n', '\\n', '    input  A0, A1, A2, A3, D, DPRA0, DPRA1, DPRA2, DPRA3, WCLK, WE;\\n', '\\n', '    reg  [15:0] mem;\\n', '    wire [3:0] adr;\\n', '\\n', '    assign adr = {A3, A2, A1, A0};\\n', '    assign SPO = mem[adr];\\n', '    assign DPO = mem[{DPRA3, DPRA2, DPRA1, DPRA0}];\\n', '\\n', '    initial \\n', '        mem = INIT;\\n', '\\n', '    always @(posedge WCLK) \\n', \"        if (WE == 1'b1)\\n\", '            mem[adr] <= D;\\n', '\\n', 'endmodule\\n', '`endif\\n']"}
{"text": "['//-----------------------------------------------------------------\\n', '//                         biRISC-V CPU\\n', '//                            V0.8.1\\n', '//                     Ultra-Embedded.com\\n', '//                     Copyright 2019-2020\\n', '//\\n', '//                   admin@ultra-embedded.com\\n', '//\\n', '//                     License: Apache 2.0\\n', '//-----------------------------------------------------------------\\n', '// Copyright 2020 Ultra-Embedded.com\\n', '// \\n', '// Licensed under the Apache License, Version 2.0 (the \"License\");\\n', '// you may not use this file except in compliance with the License.\\n', '// You may obtain a copy of the License at\\n', '// \\n', '//     http://www.apache.org/licenses/LICENSE-2.0\\n', '// \\n', '// Unless required by applicable law or agreed to in writing, software\\n', '// distributed under the License is distributed on an \"AS IS\" BASIS,\\n', '// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n', '// See the License for the specific language governing permissions and\\n', '// limitations under the License.\\n', '//-----------------------------------------------------------------\\n', '\\n', 'module riscv_core\\n', '//-----------------------------------------------------------------\\n', '// Params\\n', '//-----------------------------------------------------------------\\n', '#(\\n', '     parameter SUPPORT_BRANCH_PREDICTION = 1\\n', '    ,parameter SUPPORT_MULDIV   = 1\\n', '    ,parameter SUPPORT_SUPER    = 0\\n', '    ,parameter SUPPORT_MMU      = 0\\n', '    ,parameter SUPPORT_DUAL_ISSUE = 1\\n', '    ,parameter SUPPORT_LOAD_BYPASS = 1\\n', '    ,parameter SUPPORT_MUL_BYPASS = 1\\n', '    ,parameter SUPPORT_REGFILE_XILINX = 0\\n', '    ,parameter EXTRA_DECODE_STAGE = 0\\n', \"    ,parameter MEM_CACHE_ADDR_MIN = 32'h80000000\\n\", \"    ,parameter MEM_CACHE_ADDR_MAX = 32'h8fffffff\\n\", '    ,parameter NUM_BTB_ENTRIES  = 32\\n', '    ,parameter NUM_BTB_ENTRIES_W = 5\\n', '    ,parameter NUM_BHT_ENTRIES  = 512\\n', '    ,parameter NUM_BHT_ENTRIES_W = 9\\n', '    ,parameter RAS_ENABLE       = 1\\n', '    ,parameter GSHARE_ENABLE    = 0\\n', '    ,parameter BHT_ENABLE       = 1\\n', '    ,parameter NUM_RAS_ENTRIES  = 8\\n', '    ,parameter NUM_RAS_ENTRIES_W = 3\\n', ')\\n', '//-----------------------------------------------------------------\\n', '// Ports\\n', '//-----------------------------------------------------------------\\n', '(\\n', '    // Inputs\\n', '     input           clk_i\\n', '    ,input           rst_i\\n', '    ,input  [ 31:0]  mem_d_data_rd_i\\n', '    ,input           mem_d_accept_i\\n', '    ,input           mem_d_ack_i\\n', '    ,input           mem_d_error_i\\n', '    ,input  [ 10:0]  mem_d_resp_tag_i\\n', '    ,input           mem_i_accept_i\\n', '    ,input           mem_i_valid_i\\n', '    ,input           mem_i_error_i\\n', '    ,input  [ 63:0]  mem_i_inst_i\\n', '    ,input           intr_i\\n', '    ,input  [ 31:0]  reset_vector_i\\n', '    ,input  [ 31:0]  cpu_id_i\\n', '\\n', '    // Outputs\\n', '    ,output [ 31:0]  mem_d_addr_o\\n', '    ,output [ 31:0]  mem_d_data_wr_o\\n', '    ,output          mem_d_rd_o\\n', '    ,output [  3:0]  mem_d_wr_o\\n', '    ,output          mem_d_cacheable_o\\n', '    ,output [ 10:0]  mem_d_req_tag_o\\n', '    ,output          mem_d_invalidate_o\\n', '    ,output          mem_d_writeback_o\\n', '    ,output          mem_d_flush_o\\n', '    ,output          mem_i_rd_o\\n', '    ,output          mem_i_flush_o\\n', '    ,output          mem_i_invalidate_o\\n', '    ,output [ 31:0]  mem_i_pc_o\\n', ');\\n', '\\n', 'wire           mmu_lsu_writeback_w;\\n', 'wire  [  4:0]  csr_opcode_rd_idx_w;\\n', 'wire  [  4:0]  mul_opcode_rd_idx_w;\\n', 'wire           fetch1_instr_csr_w;\\n', 'wire           branch_d_exec1_request_w;\\n', 'wire           mmu_flush_w;\\n', 'wire  [ 31:0]  lsu_opcode_pc_w;\\n', 'wire  [ 31:0]  branch_exec0_source_w;\\n', 'wire  [  1:0]  fetch_in_priv_w;\\n', 'wire  [ 31:0]  csr_opcode_rb_operand_w;\\n', 'wire  [ 31:0]  writeback_mem_value_w;\\n', 'wire  [ 31:0]  writeback_div_value_w;\\n', 'wire           csr_opcode_valid_w;\\n', 'wire           branch_csr_request_w;\\n', 'wire  [ 63:0]  mmu_ifetch_inst_w;\\n', 'wire           mmu_lsu_error_w;\\n', 'wire  [ 31:0]  fetch0_pc_w;\\n', 'wire           branch_exec0_is_call_w;\\n', 'wire           mul_opcode_valid_w;\\n', 'wire           branch_exec0_request_w;\\n', 'wire           mmu_mxr_w;\\n', 'wire  [ 31:0]  branch_exec0_pc_w;\\n', 'wire  [ 31:0]  opcode0_pc_w;\\n', 'wire  [ 31:0]  opcode0_ra_operand_w;\\n', 'wire           mmu_ifetch_valid_w;\\n', 'wire           csr_opcode_invalid_w;\\n', 'wire  [  5:0]  csr_writeback_exception_w;\\n', 'wire           branch_exec1_is_call_w;\\n', 'wire           branch_exec1_is_not_taken_w;\\n', 'wire  [  1:0]  branch_d_exec0_priv_w;\\n', 'wire           branch_exec1_is_taken_w;\\n', 'wire  [  4:0]  opcode1_rd_idx_w;\\n', 'wire  [ 31:0]  opcode0_rb_operand_w;\\n', 'wire  [ 31:0]  fetch1_instr_w;\\n', 'wire  [ 31:0]  csr_writeback_exception_addr_w;\\n', 'wire           fetch1_instr_invalid_w;\\n', 'wire  [  3:0]  mmu_lsu_wr_w;\\n', 'wire           fetch_in_fault_w;\\n', 'wire           fetch0_instr_rd_valid_w;\\n', 'wire           branch_request_w;\\n', 'wire  [ 31:0]  csr_opcode_pc_w;\\n', 'wire           mmu_lsu_ack_w;\\n', 'wire           writeback_mem_valid_w;\\n', 'wire  [  5:0]  csr_result_e1_exception_w;\\n', 'wire           fetch0_instr_div_w;\\n', 'wire           fetch0_fault_fetch_w;\\n', 'wire  [ 31:0]  branch_info_pc_w;\\n', 'wire           fetch1_fault_page_w;\\n', 'wire  [ 31:0]  mmu_lsu_data_wr_w;\\n', 'wire  [ 10:0]  mmu_lsu_resp_tag_w;\\n', 'wire  [ 10:0]  mmu_lsu_req_tag_w;\\n', 'wire           fetch1_instr_div_w;\\n', 'wire  [ 31:0]  branch_exec1_source_w;\\n', 'wire  [ 31:0]  mul_opcode_opcode_w;\\n', 'wire  [ 31:0]  branch_d_exec0_pc_w;\\n', 'wire  [ 31:0]  branch_pc_w;\\n', 'wire  [  4:0]  mul_opcode_ra_idx_w;\\n', 'wire  [  4:0]  csr_opcode_rb_idx_w;\\n', 'wire           lsu_stall_w;\\n', 'wire  [ 31:0]  opcode1_pc_w;\\n', 'wire           branch_info_is_not_taken_w;\\n', 'wire  [ 31:0]  branch_csr_pc_w;\\n', 'wire  [  4:0]  opcode0_ra_idx_w;\\n', 'wire           branch_info_is_taken_w;\\n', 'wire  [ 31:0]  mul_opcode_pc_w;\\n', 'wire  [ 31:0]  mul_opcode_rb_operand_w;\\n', 'wire           branch_info_is_ret_w;\\n', 'wire           branch_exec0_is_taken_w;\\n', 'wire  [ 31:0]  mul_opcode_ra_operand_w;\\n', 'wire           fetch1_instr_exec_w;\\n', 'wire           fetch0_instr_exec_w;\\n', 'wire           exec1_hold_w;\\n', 'wire           exec0_opcode_valid_w;\\n', 'wire  [ 31:0]  writeback_exec1_value_w;\\n', 'wire           branch_info_is_jmp_w;\\n', 'wire  [ 31:0]  opcode1_rb_operand_w;\\n', 'wire           fetch1_instr_lsu_w;\\n', 'wire           branch_exec1_request_w;\\n', 'wire           lsu_opcode_invalid_w;\\n', 'wire  [ 31:0]  mmu_lsu_addr_w;\\n', 'wire           mul_hold_w;\\n', 'wire           mmu_ifetch_accept_w;\\n', 'wire           branch_exec1_is_jmp_w;\\n', 'wire           mmu_ifetch_invalidate_w;\\n', 'wire  [  1:0]  branch_csr_priv_w;\\n', 'wire  [ 31:0]  lsu_opcode_ra_operand_w;\\n', 'wire           mmu_lsu_rd_w;\\n', 'wire           fetch0_instr_mul_w;\\n', 'wire           fetch0_accept_w;\\n', 'wire  [  1:0]  branch_priv_w;\\n', 'wire           div_opcode_valid_w;\\n', 'wire           fetch0_instr_lsu_w;\\n', 'wire           interrupt_inhibit_w;\\n', 'wire           mmu_ifetch_error_w;\\n', 'wire  [ 31:0]  branch_exec1_pc_w;\\n', 'wire           fetch0_instr_csr_w;\\n', 'wire  [  5:0]  writeback_mem_exception_w;\\n', 'wire           fetch1_instr_branch_w;\\n', 'wire           fetch0_valid_w;\\n', 'wire           csr_result_e1_write_w;\\n', 'wire  [ 31:0]  csr_opcode_ra_operand_w;\\n', 'wire  [ 31:0]  opcode0_opcode_w;\\n', 'wire  [  1:0]  branch_d_exec1_priv_w;\\n', 'wire           branch_exec0_is_not_taken_w;\\n', 'wire           branch_exec1_is_ret_w;\\n', 'wire           writeback_div_valid_w;\\n', 'wire  [ 31:0]  opcode1_ra_operand_w;\\n', 'wire  [  4:0]  mul_opcode_rb_idx_w;\\n', 'wire  [ 31:0]  mmu_ifetch_pc_w;\\n', 'wire           mmu_ifetch_rd_w;\\n', 'wire           fetch0_fault_page_w;\\n', 'wire           mmu_ifetch_flush_w;\\n', 'wire  [ 31:0]  opcode1_opcode_w;\\n', 'wire  [  4:0]  lsu_opcode_rd_idx_w;\\n', 'wire  [ 31:0]  lsu_opcode_opcode_w;\\n', 'wire           mmu_load_fault_w;\\n', 'wire  [ 31:0]  mmu_satp_w;\\n', 'wire  [ 31:0]  csr_result_e1_wdata_w;\\n', 'wire  [  4:0]  opcode1_ra_idx_w;\\n', 'wire           mmu_lsu_invalidate_w;\\n', 'wire  [ 31:0]  writeback_exec0_value_w;\\n', 'wire  [  4:0]  csr_opcode_ra_idx_w;\\n', 'wire           ifence_w;\\n', 'wire           exec1_opcode_valid_w;\\n', 'wire           branch_exec0_is_jmp_w;\\n', 'wire  [ 31:0]  fetch1_pc_w;\\n', 'wire  [ 31:0]  csr_writeback_wdata_w;\\n', 'wire           fetch1_accept_w;\\n', 'wire           csr_writeback_write_w;\\n', 'wire           take_interrupt_w;\\n', 'wire  [ 31:0]  csr_result_e1_value_w;\\n', 'wire  [  4:0]  opcode1_rb_idx_w;\\n', 'wire           fetch0_instr_invalid_w;\\n', 'wire  [ 11:0]  csr_writeback_waddr_w;\\n', 'wire           fetch1_fault_fetch_w;\\n', 'wire           fetch1_valid_w;\\n', 'wire  [ 31:0]  fetch0_instr_w;\\n', 'wire           mmu_lsu_cacheable_w;\\n', 'wire           branch_d_exec0_request_w;\\n', 'wire           opcode1_invalid_w;\\n', 'wire           exec0_hold_w;\\n', 'wire  [  4:0]  opcode0_rb_idx_w;\\n', 'wire           opcode0_invalid_w;\\n', 'wire           lsu_opcode_valid_w;\\n', 'wire           branch_info_request_w;\\n', 'wire  [  1:0]  mmu_priv_d_w;\\n', 'wire  [ 31:0]  csr_opcode_opcode_w;\\n', 'wire           fetch0_instr_branch_w;\\n', 'wire           mul_opcode_invalid_w;\\n', 'wire           branch_exec0_is_ret_w;\\n', 'wire  [ 31:0]  mmu_lsu_data_rd_w;\\n', 'wire  [ 31:0]  writeback_mul_value_w;\\n', 'wire           mmu_lsu_flush_w;\\n', 'wire  [  4:0]  lsu_opcode_rb_idx_w;\\n', 'wire           mmu_lsu_accept_w;\\n', 'wire           fetch1_instr_rd_valid_w;\\n', 'wire  [ 31:0]  lsu_opcode_rb_operand_w;\\n', 'wire           mmu_sum_w;\\n', 'wire  [ 31:0]  branch_info_source_w;\\n', 'wire           branch_info_is_call_w;\\n', 'wire  [  4:0]  opcode0_rd_idx_w;\\n', 'wire  [ 31:0]  branch_d_exec1_pc_w;\\n', 'wire  [  4:0]  lsu_opcode_ra_idx_w;\\n', 'wire  [ 31:0]  csr_writeback_exception_pc_w;\\n', 'wire           fetch1_instr_mul_w;\\n', 'wire           mmu_store_fault_w;\\n', '\\n', '\\n', 'biriscv_frontend\\n', '#(\\n', '     .EXTRA_DECODE_STAGE(EXTRA_DECODE_STAGE)\\n', '    ,.NUM_BTB_ENTRIES(NUM_BTB_ENTRIES)\\n', '    ,.SUPPORT_BRANCH_PREDICTION(SUPPORT_BRANCH_PREDICTION)\\n', '    ,.GSHARE_ENABLE(GSHARE_ENABLE)\\n', '    ,.NUM_RAS_ENTRIES_W(NUM_RAS_ENTRIES_W)\\n', '    ,.NUM_BHT_ENTRIES_W(NUM_BHT_ENTRIES_W)\\n', '    ,.BHT_ENABLE(BHT_ENABLE)\\n', '    ,.SUPPORT_MULDIV(SUPPORT_MULDIV)\\n', '    ,.NUM_BTB_ENTRIES_W(NUM_BTB_ENTRIES_W)\\n', '    ,.SUPPORT_MMU(SUPPORT_MMU)\\n', '    ,.NUM_BHT_ENTRIES(NUM_BHT_ENTRIES)\\n', '    ,.RAS_ENABLE(RAS_ENABLE)\\n', '    ,.NUM_RAS_ENTRIES(NUM_RAS_ENTRIES)\\n', ')\\n', 'u_frontend\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.icache_accept_i(mmu_ifetch_accept_w)\\n', '    ,.icache_valid_i(mmu_ifetch_valid_w)\\n', '    ,.icache_error_i(mmu_ifetch_error_w)\\n', '    ,.icache_inst_i(mmu_ifetch_inst_w)\\n', '    ,.icache_page_fault_i(fetch_in_fault_w)\\n', '    ,.fetch0_accept_i(fetch0_accept_w)\\n', '    ,.fetch1_accept_i(fetch1_accept_w)\\n', '    ,.fetch_invalidate_i(ifence_w)\\n', '    ,.branch_request_i(branch_request_w)\\n', '    ,.branch_pc_i(branch_pc_w)\\n', '    ,.branch_priv_i(branch_priv_w)\\n', '    ,.branch_info_request_i(branch_info_request_w)\\n', '    ,.branch_info_is_taken_i(branch_info_is_taken_w)\\n', '    ,.branch_info_is_not_taken_i(branch_info_is_not_taken_w)\\n', '    ,.branch_info_source_i(branch_info_source_w)\\n', '    ,.branch_info_is_call_i(branch_info_is_call_w)\\n', '    ,.branch_info_is_ret_i(branch_info_is_ret_w)\\n', '    ,.branch_info_is_jmp_i(branch_info_is_jmp_w)\\n', '    ,.branch_info_pc_i(branch_info_pc_w)\\n', '\\n', '    // Outputs\\n', '    ,.icache_rd_o(mmu_ifetch_rd_w)\\n', '    ,.icache_flush_o(mmu_ifetch_flush_w)\\n', '    ,.icache_invalidate_o(mmu_ifetch_invalidate_w)\\n', '    ,.icache_pc_o(mmu_ifetch_pc_w)\\n', '    ,.icache_priv_o(fetch_in_priv_w)\\n', '    ,.fetch0_valid_o(fetch0_valid_w)\\n', '    ,.fetch0_instr_o(fetch0_instr_w)\\n', '    ,.fetch0_pc_o(fetch0_pc_w)\\n', '    ,.fetch0_fault_fetch_o(fetch0_fault_fetch_w)\\n', '    ,.fetch0_fault_page_o(fetch0_fault_page_w)\\n', '    ,.fetch0_instr_exec_o(fetch0_instr_exec_w)\\n', '    ,.fetch0_instr_lsu_o(fetch0_instr_lsu_w)\\n', '    ,.fetch0_instr_branch_o(fetch0_instr_branch_w)\\n', '    ,.fetch0_instr_mul_o(fetch0_instr_mul_w)\\n', '    ,.fetch0_instr_div_o(fetch0_instr_div_w)\\n', '    ,.fetch0_instr_csr_o(fetch0_instr_csr_w)\\n', '    ,.fetch0_instr_rd_valid_o(fetch0_instr_rd_valid_w)\\n', '    ,.fetch0_instr_invalid_o(fetch0_instr_invalid_w)\\n', '    ,.fetch1_valid_o(fetch1_valid_w)\\n', '    ,.fetch1_instr_o(fetch1_instr_w)\\n', '    ,.fetch1_pc_o(fetch1_pc_w)\\n', '    ,.fetch1_fault_fetch_o(fetch1_fault_fetch_w)\\n', '    ,.fetch1_fault_page_o(fetch1_fault_page_w)\\n', '    ,.fetch1_instr_exec_o(fetch1_instr_exec_w)\\n', '    ,.fetch1_instr_lsu_o(fetch1_instr_lsu_w)\\n', '    ,.fetch1_instr_branch_o(fetch1_instr_branch_w)\\n', '    ,.fetch1_instr_mul_o(fetch1_instr_mul_w)\\n', '    ,.fetch1_instr_div_o(fetch1_instr_div_w)\\n', '    ,.fetch1_instr_csr_o(fetch1_instr_csr_w)\\n', '    ,.fetch1_instr_rd_valid_o(fetch1_instr_rd_valid_w)\\n', '    ,.fetch1_instr_invalid_o(fetch1_instr_invalid_w)\\n', ');\\n', '\\n', '\\n', 'biriscv_mmu\\n', '#(\\n', '     .MEM_CACHE_ADDR_MAX(MEM_CACHE_ADDR_MAX)\\n', '    ,.SUPPORT_MMU(SUPPORT_MMU)\\n', '    ,.MEM_CACHE_ADDR_MIN(MEM_CACHE_ADDR_MIN)\\n', ')\\n', 'u_mmu\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.priv_d_i(mmu_priv_d_w)\\n', '    ,.sum_i(mmu_sum_w)\\n', '    ,.mxr_i(mmu_mxr_w)\\n', '    ,.flush_i(mmu_flush_w)\\n', '    ,.satp_i(mmu_satp_w)\\n', '    ,.fetch_in_rd_i(mmu_ifetch_rd_w)\\n', '    ,.fetch_in_flush_i(mmu_ifetch_flush_w)\\n', '    ,.fetch_in_invalidate_i(mmu_ifetch_invalidate_w)\\n', '    ,.fetch_in_pc_i(mmu_ifetch_pc_w)\\n', '    ,.fetch_in_priv_i(fetch_in_priv_w)\\n', '    ,.fetch_out_accept_i(mem_i_accept_i)\\n', '    ,.fetch_out_valid_i(mem_i_valid_i)\\n', '    ,.fetch_out_error_i(mem_i_error_i)\\n', '    ,.fetch_out_inst_i(mem_i_inst_i)\\n', '    ,.lsu_in_addr_i(mmu_lsu_addr_w)\\n', '    ,.lsu_in_data_wr_i(mmu_lsu_data_wr_w)\\n', '    ,.lsu_in_rd_i(mmu_lsu_rd_w)\\n', '    ,.lsu_in_wr_i(mmu_lsu_wr_w)\\n', '    ,.lsu_in_cacheable_i(mmu_lsu_cacheable_w)\\n', '    ,.lsu_in_req_tag_i(mmu_lsu_req_tag_w)\\n', '    ,.lsu_in_invalidate_i(mmu_lsu_invalidate_w)\\n', '    ,.lsu_in_writeback_i(mmu_lsu_writeback_w)\\n', '    ,.lsu_in_flush_i(mmu_lsu_flush_w)\\n', '    ,.lsu_out_data_rd_i(mem_d_data_rd_i)\\n', '    ,.lsu_out_accept_i(mem_d_accept_i)\\n', '    ,.lsu_out_ack_i(mem_d_ack_i)\\n', '    ,.lsu_out_error_i(mem_d_error_i)\\n', '    ,.lsu_out_resp_tag_i(mem_d_resp_tag_i)\\n', '\\n', '    // Outputs\\n', '    ,.fetch_in_accept_o(mmu_ifetch_accept_w)\\n', '    ,.fetch_in_valid_o(mmu_ifetch_valid_w)\\n', '    ,.fetch_in_error_o(mmu_ifetch_error_w)\\n', '    ,.fetch_in_inst_o(mmu_ifetch_inst_w)\\n', '    ,.fetch_out_rd_o(mem_i_rd_o)\\n', '    ,.fetch_out_flush_o(mem_i_flush_o)\\n', '    ,.fetch_out_invalidate_o(mem_i_invalidate_o)\\n', '    ,.fetch_out_pc_o(mem_i_pc_o)\\n', '    ,.fetch_in_fault_o(fetch_in_fault_w)\\n', '    ,.lsu_in_data_rd_o(mmu_lsu_data_rd_w)\\n', '    ,.lsu_in_accept_o(mmu_lsu_accept_w)\\n', '    ,.lsu_in_ack_o(mmu_lsu_ack_w)\\n', '    ,.lsu_in_error_o(mmu_lsu_error_w)\\n', '    ,.lsu_in_resp_tag_o(mmu_lsu_resp_tag_w)\\n', '    ,.lsu_out_addr_o(mem_d_addr_o)\\n', '    ,.lsu_out_data_wr_o(mem_d_data_wr_o)\\n', '    ,.lsu_out_rd_o(mem_d_rd_o)\\n', '    ,.lsu_out_wr_o(mem_d_wr_o)\\n', '    ,.lsu_out_cacheable_o(mem_d_cacheable_o)\\n', '    ,.lsu_out_req_tag_o(mem_d_req_tag_o)\\n', '    ,.lsu_out_invalidate_o(mem_d_invalidate_o)\\n', '    ,.lsu_out_writeback_o(mem_d_writeback_o)\\n', '    ,.lsu_out_flush_o(mem_d_flush_o)\\n', '    ,.lsu_in_load_fault_o(mmu_load_fault_w)\\n', '    ,.lsu_in_store_fault_o(mmu_store_fault_w)\\n', ');\\n', '\\n', '\\n', 'biriscv_lsu\\n', '#(\\n', '     .MEM_CACHE_ADDR_MAX(MEM_CACHE_ADDR_MAX)\\n', '    ,.MEM_CACHE_ADDR_MIN(MEM_CACHE_ADDR_MIN)\\n', ')\\n', 'u_lsu\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.opcode_valid_i(lsu_opcode_valid_w)\\n', '    ,.opcode_opcode_i(lsu_opcode_opcode_w)\\n', '    ,.opcode_pc_i(lsu_opcode_pc_w)\\n', '    ,.opcode_invalid_i(lsu_opcode_invalid_w)\\n', '    ,.opcode_rd_idx_i(lsu_opcode_rd_idx_w)\\n', '    ,.opcode_ra_idx_i(lsu_opcode_ra_idx_w)\\n', '    ,.opcode_rb_idx_i(lsu_opcode_rb_idx_w)\\n', '    ,.opcode_ra_operand_i(lsu_opcode_ra_operand_w)\\n', '    ,.opcode_rb_operand_i(lsu_opcode_rb_operand_w)\\n', '    ,.mem_data_rd_i(mmu_lsu_data_rd_w)\\n', '    ,.mem_accept_i(mmu_lsu_accept_w)\\n', '    ,.mem_ack_i(mmu_lsu_ack_w)\\n', '    ,.mem_error_i(mmu_lsu_error_w)\\n', '    ,.mem_resp_tag_i(mmu_lsu_resp_tag_w)\\n', '    ,.mem_load_fault_i(mmu_load_fault_w)\\n', '    ,.mem_store_fault_i(mmu_store_fault_w)\\n', '\\n', '    // Outputs\\n', '    ,.mem_addr_o(mmu_lsu_addr_w)\\n', '    ,.mem_data_wr_o(mmu_lsu_data_wr_w)\\n', '    ,.mem_rd_o(mmu_lsu_rd_w)\\n', '    ,.mem_wr_o(mmu_lsu_wr_w)\\n', '    ,.mem_cacheable_o(mmu_lsu_cacheable_w)\\n', '    ,.mem_req_tag_o(mmu_lsu_req_tag_w)\\n', '    ,.mem_invalidate_o(mmu_lsu_invalidate_w)\\n', '    ,.mem_writeback_o(mmu_lsu_writeback_w)\\n', '    ,.mem_flush_o(mmu_lsu_flush_w)\\n', '    ,.writeback_valid_o(writeback_mem_valid_w)\\n', '    ,.writeback_value_o(writeback_mem_value_w)\\n', '    ,.writeback_exception_o(writeback_mem_exception_w)\\n', '    ,.stall_o(lsu_stall_w)\\n', ');\\n', '\\n', '\\n', 'biriscv_csr\\n', '#(\\n', '     .SUPPORT_SUPER(SUPPORT_SUPER)\\n', '    ,.SUPPORT_MULDIV(SUPPORT_MULDIV)\\n', ')\\n', 'u_csr\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.intr_i(intr_i)\\n', '    ,.opcode_valid_i(csr_opcode_valid_w)\\n', '    ,.opcode_opcode_i(csr_opcode_opcode_w)\\n', '    ,.opcode_pc_i(csr_opcode_pc_w)\\n', '    ,.opcode_invalid_i(csr_opcode_invalid_w)\\n', '    ,.opcode_rd_idx_i(csr_opcode_rd_idx_w)\\n', '    ,.opcode_ra_idx_i(csr_opcode_ra_idx_w)\\n', '    ,.opcode_rb_idx_i(csr_opcode_rb_idx_w)\\n', '    ,.opcode_ra_operand_i(csr_opcode_ra_operand_w)\\n', '    ,.opcode_rb_operand_i(csr_opcode_rb_operand_w)\\n', '    ,.csr_writeback_write_i(csr_writeback_write_w)\\n', '    ,.csr_writeback_waddr_i(csr_writeback_waddr_w)\\n', '    ,.csr_writeback_wdata_i(csr_writeback_wdata_w)\\n', '    ,.csr_writeback_exception_i(csr_writeback_exception_w)\\n', '    ,.csr_writeback_exception_pc_i(csr_writeback_exception_pc_w)\\n', '    ,.csr_writeback_exception_addr_i(csr_writeback_exception_addr_w)\\n', '    ,.cpu_id_i(cpu_id_i)\\n', '    ,.reset_vector_i(reset_vector_i)\\n', '    ,.interrupt_inhibit_i(interrupt_inhibit_w)\\n', '\\n', '    // Outputs\\n', '    ,.csr_result_e1_value_o(csr_result_e1_value_w)\\n', '    ,.csr_result_e1_write_o(csr_result_e1_write_w)\\n', '    ,.csr_result_e1_wdata_o(csr_result_e1_wdata_w)\\n', '    ,.csr_result_e1_exception_o(csr_result_e1_exception_w)\\n', '    ,.branch_csr_request_o(branch_csr_request_w)\\n', '    ,.branch_csr_pc_o(branch_csr_pc_w)\\n', '    ,.branch_csr_priv_o(branch_csr_priv_w)\\n', '    ,.take_interrupt_o(take_interrupt_w)\\n', '    ,.ifence_o(ifence_w)\\n', '    ,.mmu_priv_d_o(mmu_priv_d_w)\\n', '    ,.mmu_sum_o(mmu_sum_w)\\n', '    ,.mmu_mxr_o(mmu_mxr_w)\\n', '    ,.mmu_flush_o(mmu_flush_w)\\n', '    ,.mmu_satp_o(mmu_satp_w)\\n', ');\\n', '\\n', '\\n', 'biriscv_multiplier\\n', 'u_mul\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.opcode_valid_i(mul_opcode_valid_w)\\n', '    ,.opcode_opcode_i(mul_opcode_opcode_w)\\n', '    ,.opcode_pc_i(mul_opcode_pc_w)\\n', '    ,.opcode_invalid_i(mul_opcode_invalid_w)\\n', '    ,.opcode_rd_idx_i(mul_opcode_rd_idx_w)\\n', '    ,.opcode_ra_idx_i(mul_opcode_ra_idx_w)\\n', '    ,.opcode_rb_idx_i(mul_opcode_rb_idx_w)\\n', '    ,.opcode_ra_operand_i(mul_opcode_ra_operand_w)\\n', '    ,.opcode_rb_operand_i(mul_opcode_rb_operand_w)\\n', '    ,.hold_i(mul_hold_w)\\n', '\\n', '    // Outputs\\n', '    ,.writeback_value_o(writeback_mul_value_w)\\n', ');\\n', '\\n', '\\n', 'biriscv_divider\\n', 'u_div\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.opcode_valid_i(div_opcode_valid_w)\\n', '    ,.opcode_opcode_i(opcode0_opcode_w)\\n', '    ,.opcode_pc_i(opcode0_pc_w)\\n', '    ,.opcode_invalid_i(opcode0_invalid_w)\\n', '    ,.opcode_rd_idx_i(opcode0_rd_idx_w)\\n', '    ,.opcode_ra_idx_i(opcode0_ra_idx_w)\\n', '    ,.opcode_rb_idx_i(opcode0_rb_idx_w)\\n', '    ,.opcode_ra_operand_i(opcode0_ra_operand_w)\\n', '    ,.opcode_rb_operand_i(opcode0_rb_operand_w)\\n', '\\n', '    // Outputs\\n', '    ,.writeback_valid_o(writeback_div_valid_w)\\n', '    ,.writeback_value_o(writeback_div_value_w)\\n', ');\\n', '\\n', '\\n', 'biriscv_issue\\n', '#(\\n', '     .SUPPORT_REGFILE_XILINX(SUPPORT_REGFILE_XILINX)\\n', '    ,.SUPPORT_LOAD_BYPASS(SUPPORT_LOAD_BYPASS)\\n', '    ,.SUPPORT_MULDIV(SUPPORT_MULDIV)\\n', '    ,.SUPPORT_MUL_BYPASS(SUPPORT_MUL_BYPASS)\\n', '    ,.SUPPORT_DUAL_ISSUE(SUPPORT_DUAL_ISSUE)\\n', ')\\n', 'u_issue\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.fetch0_valid_i(fetch0_valid_w)\\n', '    ,.fetch0_instr_i(fetch0_instr_w)\\n', '    ,.fetch0_pc_i(fetch0_pc_w)\\n', '    ,.fetch0_fault_fetch_i(fetch0_fault_fetch_w)\\n', '    ,.fetch0_fault_page_i(fetch0_fault_page_w)\\n', '    ,.fetch0_instr_exec_i(fetch0_instr_exec_w)\\n', '    ,.fetch0_instr_lsu_i(fetch0_instr_lsu_w)\\n', '    ,.fetch0_instr_branch_i(fetch0_instr_branch_w)\\n', '    ,.fetch0_instr_mul_i(fetch0_instr_mul_w)\\n', '    ,.fetch0_instr_div_i(fetch0_instr_div_w)\\n', '    ,.fetch0_instr_csr_i(fetch0_instr_csr_w)\\n', '    ,.fetch0_instr_rd_valid_i(fetch0_instr_rd_valid_w)\\n', '    ,.fetch0_instr_invalid_i(fetch0_instr_invalid_w)\\n', '    ,.fetch1_valid_i(fetch1_valid_w)\\n', '    ,.fetch1_instr_i(fetch1_instr_w)\\n', '    ,.fetch1_pc_i(fetch1_pc_w)\\n', '    ,.fetch1_fault_fetch_i(fetch1_fault_fetch_w)\\n', '    ,.fetch1_fault_page_i(fetch1_fault_page_w)\\n', '    ,.fetch1_instr_exec_i(fetch1_instr_exec_w)\\n', '    ,.fetch1_instr_lsu_i(fetch1_instr_lsu_w)\\n', '    ,.fetch1_instr_branch_i(fetch1_instr_branch_w)\\n', '    ,.fetch1_instr_mul_i(fetch1_instr_mul_w)\\n', '    ,.fetch1_instr_div_i(fetch1_instr_div_w)\\n', '    ,.fetch1_instr_csr_i(fetch1_instr_csr_w)\\n', '    ,.fetch1_instr_rd_valid_i(fetch1_instr_rd_valid_w)\\n', '    ,.fetch1_instr_invalid_i(fetch1_instr_invalid_w)\\n', '    ,.branch_exec0_request_i(branch_exec0_request_w)\\n', '    ,.branch_exec0_is_taken_i(branch_exec0_is_taken_w)\\n', '    ,.branch_exec0_is_not_taken_i(branch_exec0_is_not_taken_w)\\n', '    ,.branch_exec0_source_i(branch_exec0_source_w)\\n', '    ,.branch_exec0_is_call_i(branch_exec0_is_call_w)\\n', '    ,.branch_exec0_is_ret_i(branch_exec0_is_ret_w)\\n', '    ,.branch_exec0_is_jmp_i(branch_exec0_is_jmp_w)\\n', '    ,.branch_exec0_pc_i(branch_exec0_pc_w)\\n', '    ,.branch_d_exec0_request_i(branch_d_exec0_request_w)\\n', '    ,.branch_d_exec0_pc_i(branch_d_exec0_pc_w)\\n', '    ,.branch_d_exec0_priv_i(branch_d_exec0_priv_w)\\n', '    ,.branch_exec1_request_i(branch_exec1_request_w)\\n', '    ,.branch_exec1_is_taken_i(branch_exec1_is_taken_w)\\n', '    ,.branch_exec1_is_not_taken_i(branch_exec1_is_not_taken_w)\\n', '    ,.branch_exec1_source_i(branch_exec1_source_w)\\n', '    ,.branch_exec1_is_call_i(branch_exec1_is_call_w)\\n', '    ,.branch_exec1_is_ret_i(branch_exec1_is_ret_w)\\n', '    ,.branch_exec1_is_jmp_i(branch_exec1_is_jmp_w)\\n', '    ,.branch_exec1_pc_i(branch_exec1_pc_w)\\n', '    ,.branch_d_exec1_request_i(branch_d_exec1_request_w)\\n', '    ,.branch_d_exec1_pc_i(branch_d_exec1_pc_w)\\n', '    ,.branch_d_exec1_priv_i(branch_d_exec1_priv_w)\\n', '    ,.branch_csr_request_i(branch_csr_request_w)\\n', '    ,.branch_csr_pc_i(branch_csr_pc_w)\\n', '    ,.branch_csr_priv_i(branch_csr_priv_w)\\n', '    ,.writeback_exec0_value_i(writeback_exec0_value_w)\\n', '    ,.writeback_exec1_value_i(writeback_exec1_value_w)\\n', '    ,.writeback_mem_valid_i(writeback_mem_valid_w)\\n', '    ,.writeback_mem_value_i(writeback_mem_value_w)\\n', '    ,.writeback_mem_exception_i(writeback_mem_exception_w)\\n', '    ,.writeback_mul_value_i(writeback_mul_value_w)\\n', '    ,.writeback_div_valid_i(writeback_div_valid_w)\\n', '    ,.writeback_div_value_i(writeback_div_value_w)\\n', '    ,.csr_result_e1_value_i(csr_result_e1_value_w)\\n', '    ,.csr_result_e1_write_i(csr_result_e1_write_w)\\n', '    ,.csr_result_e1_wdata_i(csr_result_e1_wdata_w)\\n', '    ,.csr_result_e1_exception_i(csr_result_e1_exception_w)\\n', '    ,.lsu_stall_i(lsu_stall_w)\\n', '    ,.take_interrupt_i(take_interrupt_w)\\n', '\\n', '    // Outputs\\n', '    ,.fetch0_accept_o(fetch0_accept_w)\\n', '    ,.fetch1_accept_o(fetch1_accept_w)\\n', '    ,.branch_request_o(branch_request_w)\\n', '    ,.branch_pc_o(branch_pc_w)\\n', '    ,.branch_priv_o(branch_priv_w)\\n', '    ,.branch_info_request_o(branch_info_request_w)\\n', '    ,.branch_info_is_taken_o(branch_info_is_taken_w)\\n', '    ,.branch_info_is_not_taken_o(branch_info_is_not_taken_w)\\n', '    ,.branch_info_source_o(branch_info_source_w)\\n', '    ,.branch_info_is_call_o(branch_info_is_call_w)\\n', '    ,.branch_info_is_ret_o(branch_info_is_ret_w)\\n', '    ,.branch_info_is_jmp_o(branch_info_is_jmp_w)\\n', '    ,.branch_info_pc_o(branch_info_pc_w)\\n', '    ,.exec0_opcode_valid_o(exec0_opcode_valid_w)\\n', '    ,.exec1_opcode_valid_o(exec1_opcode_valid_w)\\n', '    ,.lsu_opcode_valid_o(lsu_opcode_valid_w)\\n', '    ,.csr_opcode_valid_o(csr_opcode_valid_w)\\n', '    ,.mul_opcode_valid_o(mul_opcode_valid_w)\\n', '    ,.div_opcode_valid_o(div_opcode_valid_w)\\n', '    ,.opcode0_opcode_o(opcode0_opcode_w)\\n', '    ,.opcode0_pc_o(opcode0_pc_w)\\n', '    ,.opcode0_invalid_o(opcode0_invalid_w)\\n', '    ,.opcode0_rd_idx_o(opcode0_rd_idx_w)\\n', '    ,.opcode0_ra_idx_o(opcode0_ra_idx_w)\\n', '    ,.opcode0_rb_idx_o(opcode0_rb_idx_w)\\n', '    ,.opcode0_ra_operand_o(opcode0_ra_operand_w)\\n', '    ,.opcode0_rb_operand_o(opcode0_rb_operand_w)\\n', '    ,.opcode1_opcode_o(opcode1_opcode_w)\\n', '    ,.opcode1_pc_o(opcode1_pc_w)\\n', '    ,.opcode1_invalid_o(opcode1_invalid_w)\\n', '    ,.opcode1_rd_idx_o(opcode1_rd_idx_w)\\n', '    ,.opcode1_ra_idx_o(opcode1_ra_idx_w)\\n', '    ,.opcode1_rb_idx_o(opcode1_rb_idx_w)\\n', '    ,.opcode1_ra_operand_o(opcode1_ra_operand_w)\\n', '    ,.opcode1_rb_operand_o(opcode1_rb_operand_w)\\n', '    ,.lsu_opcode_opcode_o(lsu_opcode_opcode_w)\\n', '    ,.lsu_opcode_pc_o(lsu_opcode_pc_w)\\n', '    ,.lsu_opcode_invalid_o(lsu_opcode_invalid_w)\\n', '    ,.lsu_opcode_rd_idx_o(lsu_opcode_rd_idx_w)\\n', '    ,.lsu_opcode_ra_idx_o(lsu_opcode_ra_idx_w)\\n', '    ,.lsu_opcode_rb_idx_o(lsu_opcode_rb_idx_w)\\n', '    ,.lsu_opcode_ra_operand_o(lsu_opcode_ra_operand_w)\\n', '    ,.lsu_opcode_rb_operand_o(lsu_opcode_rb_operand_w)\\n', '    ,.mul_opcode_opcode_o(mul_opcode_opcode_w)\\n', '    ,.mul_opcode_pc_o(mul_opcode_pc_w)\\n', '    ,.mul_opcode_invalid_o(mul_opcode_invalid_w)\\n', '    ,.mul_opcode_rd_idx_o(mul_opcode_rd_idx_w)\\n', '    ,.mul_opcode_ra_idx_o(mul_opcode_ra_idx_w)\\n', '    ,.mul_opcode_rb_idx_o(mul_opcode_rb_idx_w)\\n', '    ,.mul_opcode_ra_operand_o(mul_opcode_ra_operand_w)\\n', '    ,.mul_opcode_rb_operand_o(mul_opcode_rb_operand_w)\\n', '    ,.csr_opcode_opcode_o(csr_opcode_opcode_w)\\n', '    ,.csr_opcode_pc_o(csr_opcode_pc_w)\\n', '    ,.csr_opcode_invalid_o(csr_opcode_invalid_w)\\n', '    ,.csr_opcode_rd_idx_o(csr_opcode_rd_idx_w)\\n', '    ,.csr_opcode_ra_idx_o(csr_opcode_ra_idx_w)\\n', '    ,.csr_opcode_rb_idx_o(csr_opcode_rb_idx_w)\\n', '    ,.csr_opcode_ra_operand_o(csr_opcode_ra_operand_w)\\n', '    ,.csr_opcode_rb_operand_o(csr_opcode_rb_operand_w)\\n', '    ,.csr_writeback_write_o(csr_writeback_write_w)\\n', '    ,.csr_writeback_waddr_o(csr_writeback_waddr_w)\\n', '    ,.csr_writeback_wdata_o(csr_writeback_wdata_w)\\n', '    ,.csr_writeback_exception_o(csr_writeback_exception_w)\\n', '    ,.csr_writeback_exception_pc_o(csr_writeback_exception_pc_w)\\n', '    ,.csr_writeback_exception_addr_o(csr_writeback_exception_addr_w)\\n', '    ,.exec0_hold_o(exec0_hold_w)\\n', '    ,.exec1_hold_o(exec1_hold_w)\\n', '    ,.mul_hold_o(mul_hold_w)\\n', '    ,.interrupt_inhibit_o(interrupt_inhibit_w)\\n', ');\\n', '\\n', '\\n', 'biriscv_exec\\n', 'u_exec0\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.opcode_valid_i(exec0_opcode_valid_w)\\n', '    ,.opcode_opcode_i(opcode0_opcode_w)\\n', '    ,.opcode_pc_i(opcode0_pc_w)\\n', '    ,.opcode_invalid_i(opcode0_invalid_w)\\n', '    ,.opcode_rd_idx_i(opcode0_rd_idx_w)\\n', '    ,.opcode_ra_idx_i(opcode0_ra_idx_w)\\n', '    ,.opcode_rb_idx_i(opcode0_rb_idx_w)\\n', '    ,.opcode_ra_operand_i(opcode0_ra_operand_w)\\n', '    ,.opcode_rb_operand_i(opcode0_rb_operand_w)\\n', '    ,.hold_i(exec0_hold_w)\\n', '\\n', '    // Outputs\\n', '    ,.branch_request_o(branch_exec0_request_w)\\n', '    ,.branch_is_taken_o(branch_exec0_is_taken_w)\\n', '    ,.branch_is_not_taken_o(branch_exec0_is_not_taken_w)\\n', '    ,.branch_source_o(branch_exec0_source_w)\\n', '    ,.branch_is_call_o(branch_exec0_is_call_w)\\n', '    ,.branch_is_ret_o(branch_exec0_is_ret_w)\\n', '    ,.branch_is_jmp_o(branch_exec0_is_jmp_w)\\n', '    ,.branch_pc_o(branch_exec0_pc_w)\\n', '    ,.branch_d_request_o(branch_d_exec0_request_w)\\n', '    ,.branch_d_pc_o(branch_d_exec0_pc_w)\\n', '    ,.branch_d_priv_o(branch_d_exec0_priv_w)\\n', '    ,.writeback_value_o(writeback_exec0_value_w)\\n', ');\\n', '\\n', '\\n', 'biriscv_exec\\n', 'u_exec1\\n', '(\\n', '    // Inputs\\n', '     .clk_i(clk_i)\\n', '    ,.rst_i(rst_i)\\n', '    ,.opcode_valid_i(exec1_opcode_valid_w)\\n', '    ,.opcode_opcode_i(opcode1_opcode_w)\\n', '    ,.opcode_pc_i(opcode1_pc_w)\\n', '    ,.opcode_invalid_i(opcode1_invalid_w)\\n', '    ,.opcode_rd_idx_i(opcode1_rd_idx_w)\\n', '    ,.opcode_ra_idx_i(opcode1_ra_idx_w)\\n', '    ,.opcode_rb_idx_i(opcode1_rb_idx_w)\\n', '    ,.opcode_ra_operand_i(opcode1_ra_operand_w)\\n', '    ,.opcode_rb_operand_i(opcode1_rb_operand_w)\\n', '    ,.hold_i(exec1_hold_w)\\n', '\\n', '    // Outputs\\n', '    ,.branch_request_o(branch_exec1_request_w)\\n', '    ,.branch_is_taken_o(branch_exec1_is_taken_w)\\n', '    ,.branch_is_not_taken_o(branch_exec1_is_not_taken_w)\\n', '    ,.branch_source_o(branch_exec1_source_w)\\n', '    ,.branch_is_call_o(branch_exec1_is_call_w)\\n', '    ,.branch_is_ret_o(branch_exec1_is_ret_w)\\n', '    ,.branch_is_jmp_o(branch_exec1_is_jmp_w)\\n', '    ,.branch_pc_o(branch_exec1_pc_w)\\n', '    ,.branch_d_request_o(branch_d_exec1_request_w)\\n', '    ,.branch_d_pc_o(branch_d_exec1_pc_w)\\n', '    ,.branch_d_priv_o(branch_d_exec1_priv_w)\\n', '    ,.writeback_value_o(writeback_exec1_value_w)\\n', ');\\n', '\\n', '\\n', '\\n', 'endmodule\\n']"}
