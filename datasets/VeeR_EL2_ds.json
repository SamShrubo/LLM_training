{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n// $Id$\n//\n// Owner:\n// Function: AHB to AXI4 Bridge\n// Comments:\n//\n//********************************************************************************\nmodule ahb_to_axi4\nimport el2_pkg::*;\n#(\n   TAG = 1,\n   `include \"el2_param.vh\"\n)\n//   ,TAG  = 1)\n(\n   input                   clk,\n   input                   rst_l,\n   input                   scan_mode,\n   input                   bus_clk_en,\n   input                   clk_override,\n\n   // AXI signals\n   // AXI Write Channels\n   output logic            axi_awvalid,\n   input  logic            axi_awready,\n   output logic [TAG-1:0]  axi_awid,\n   output logic [31:0]     axi_awaddr,\n   output logic [2:0]      axi_awsize,\n   output logic [2:0]      axi_awprot,\n   output logic [7:0]      axi_awlen,\n   output logic [1:0]      axi_awburst,\n\n   output logic            axi_wvalid,\n   input  logic            axi_wready,\n   output logic [63:0]     axi_wdata,\n   output logic [7:0]      axi_wstrb,\n   output logic            axi_wlast,\n\n   input  logic            axi_bvalid,\n   output logic            axi_bready,\n   input  logic [1:0]      axi_bresp,\n   input  logic [TAG-1:0]  axi_bid,\n\n   // AXI Read Channels\n   output logic            axi_arvalid,\n   input  logic            axi_arready,\n   output logic [TAG-1:0]  axi_arid,\n   output logic [31:0]     axi_araddr,\n   output logic [2:0]      axi_arsize,\n   output logic [2:0]      axi_arprot,\n   output logic [7:0]      axi_arlen,\n   output logic [1:0]      axi_arburst,\n\n   input  logic            axi_rvalid,\n   output logic            axi_rready,\n   input  logic [TAG-1:0]  axi_rid,\n   input  logic [63:0]     axi_rdata,\n   input  logic [1:0]      axi_rresp,\n\n   // AHB-Lite signals\n   input logic [31:0]      ahb_haddr,     // ahb bus address\n   input logic [2:0]       ahb_hburst,    // tied to 0\n   input logic             ahb_hmastlock, // tied to 0\n   input logic [3:0]       ahb_hprot,     // tied to 4'b0011\n   input logic [2:0]       ahb_hsize,     // size of bus transaction (possible values 0,1,2,3)\n   input logic [1:0]       ahb_htrans,    // Transaction type (possible values 0,2 only right now)\n   input logic             ahb_hwrite,    // ahb bus write\n   input logic [63:0]      ahb_hwdata,    // ahb bus write data\n   input logic             ahb_hsel,      // this slave was selected\n   input logic             ahb_hreadyin,  // previous hready was accepted or not\n\n   output logic [63:0]      ahb_hrdata,      // ahb bus read data\n   output logic             ahb_hreadyout,   // slave ready to accept transaction\n   output logic             ahb_hresp        // slave response (high indicates erro)\n\n);\n\n   logic [7:0]       master_wstrb;\n\n typedef enum logic [1:0] {   IDLE   = 2'b00,    // Nothing in the buffer. No commands yet recieved\n                              WR     = 2'b01,    // Write Command recieved\n                              RD     = 2'b10,    // Read Command recieved\n                              PEND   = 2'b11     // Waiting on Read Data from core\n                            } state_t;\n   state_t      buf_state, buf_nxtstate;\n   logic        buf_state_en;\n\n   // Buffer signals (one entry buffer)\n   logic                    buf_read_error_in, buf_read_error;\n   logic [63:0]             buf_rdata;\n\n   logic                    ahb_hready;\n   logic                    ahb_hready_q;\n   logic [1:0]              ahb_htrans_in, ahb_htrans_q;\n   logic [2:0]              ahb_hsize_q;\n   logic                    ahb_hwrite_q;\n   logic [31:0]             ahb_haddr_q;\n   logic [63:0]             ahb_hwdata_q;\n   logic                    ahb_hresp_q;\n\n    //Miscellaneous signals\n   logic                    ahb_addr_in_dccm, ahb_addr_in_iccm, ahb_addr_in_pic;\n   logic                    ahb_addr_in_dccm_region_nc, ahb_addr_in_iccm_region_nc, ahb_addr_in_pic_region_nc;\n   // signals needed for the read data coming back from the core and to block any further commands as AHB is a blocking bus\n   logic                    buf_rdata_en;\n\n   logic                    ahb_addr_clk_en, buf_rdata_clk_en;\n   logic                    bus_clk, ahb_addr_clk, buf_rdata_clk;\n   // Command buffer is the holding station where we convert to AXI and send to core\n   logic                    cmdbuf_wr_en, cmdbuf_rst;\n   logic                    cmdbuf_full;\n   logic                    cmdbuf_vld, cmdbuf_write;\n   logic [1:0]              cmdbuf_size;\n   logic [7:0]              cmdbuf_wstrb;\n   logic [31:0]             cmdbuf_addr;\n   logic [63:0]             cmdbuf_wdata;\n\n// FSM to control the bus states and when to block the hready and load the command buffer\n   always_comb begin\n      buf_nxtstate      = IDLE;\n      buf_state_en      = 1'b0;\n      buf_rdata_en      = 1'b0;              // signal to load the buffer when the core sends read data back\n      buf_read_error_in = 1'b0;              // signal indicating that an error came back with the read from the core\n      cmdbuf_wr_en      = 1'b0;              // all clear from the gasket to load the buffer with the command for reads, command/dat for writes\n      case (buf_state)\n         IDLE: begin  // No commands recieved\n                  buf_nxtstate      = ahb_hwrite ? WR : RD;\n                  buf_state_en      = ahb_hready & ahb_htrans[1] & ahb_hsel;                 // only transition on a valid hrtans\n          end\n         WR: begin // Write command recieved last cycle\n                  buf_nxtstate      = (ahb_hresp | (ahb_htrans[1:0] == 2'b0) | ~ahb_hsel) ? IDLE : ahb_hwrite  ? WR : RD;\n                  buf_state_en      = (~cmdbuf_full | ahb_hresp) ;\n                  cmdbuf_wr_en      = ~cmdbuf_full & ~(ahb_hresp | ((ahb_htrans[1:0] == 2'b01) & ahb_hsel));   // Dont send command to the buffer in case of an error or when the master is not ready with the data now.\n         end\n         RD: begin // Read command recieved last cycle.\n                 buf_nxtstate      = ahb_hresp ? IDLE :PEND;                                       // If error go to idle, else wait for read data\n                 buf_state_en      = (~cmdbuf_full | ahb_hresp);                                   // only when command can go, or if its an error\n                 cmdbuf_wr_en      = ~ahb_hresp & ~cmdbuf_full;                                    // send command only when no error\n         end\n         PEND: begin // Read Command has been sent. Waiting on Data.\n                 buf_nxtstate      = IDLE;                                                          // go back for next command and present data next cycle\n                 buf_state_en      = axi_rvalid & ~cmdbuf_write;                                    // read data is back\n                 buf_rdata_en      = buf_state_en;                                                  // buffer the read data coming back from core\n                 buf_read_error_in = buf_state_en & |axi_rresp[1:0];                                // buffer error flag if return has Error ( ECC )\n         end\n     endcase\n   end // always_comb begin\n\n    rvdffs_fpga #($bits(state_t)) state_reg (.*, .din(buf_nxtstate), .dout({buf_state}), .en(buf_state_en), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk));\n\n   assign master_wstrb[7:0]   = ({8{ahb_hsize_q[2:0] == 3'b0}}  & (8'b1    << ahb_haddr_q[2:0])) |\n                                ({8{ahb_hsize_q[2:0] == 3'b1}}  & (8'b11   << ahb_haddr_q[2:0])) |\n                                ({8{ahb_hsize_q[2:0] == 3'b10}} & (8'b1111 << ahb_haddr_q[2:0])) |\n                                ({8{ahb_hsize_q[2:0] == 3'b11}} & 8'b1111_1111);\n\n   // AHB signals\n   assign ahb_hreadyout       = ahb_hresp ? (ahb_hresp_q & ~ahb_hready_q) :\n                                         ((~cmdbuf_full | (buf_state == IDLE)) & ~(buf_state == RD | buf_state == PEND)  & ~buf_read_error);\n\n   assign ahb_hready          = ahb_hreadyout & ahb_hreadyin;\n   assign ahb_htrans_in[1:0]  = {2{ahb_hsel}} & ahb_htrans[1:0];\n   assign ahb_hrdata[63:0]    = buf_rdata[63:0];\n   assign ahb_hresp        = ((ahb_htrans_q[1:0] != 2'b0) & (buf_state != IDLE)  &\n\n                             ((~(ahb_addr_in_dccm | ahb_addr_in_iccm)) |                                                                                   // request not for ICCM or DCCM\n                             ((ahb_addr_in_iccm | (ahb_addr_in_dccm &  ahb_hwrite_q)) & ~((ahb_hsize_q[1:0] == 2'b10) | (ahb_hsize_q[1:0] == 2'b11))) |    // ICCM Rd/Wr OR DCCM Wr not the right size\n                             ((ahb_hsize_q[2:0] == 3'h1) & ahb_haddr_q[0])   |                                                                             // HW size but unaligned\n                             ((ahb_hsize_q[2:0] == 3'h2) & (|ahb_haddr_q[1:0])) |                                                                          // W size but unaligned\n                             ((ahb_hsize_q[2:0] == 3'h3) & (|ahb_haddr_q[2:0])))) |                                                                        // DW size but unaligned\n                             buf_read_error |                                                                                                              // Read ECC error\n                             (ahb_hresp_q & ~ahb_hready_q);\n\n   // Buffer signals - needed for the read data and ECC error response\n   rvdff_fpga  #(.WIDTH(64)) buf_rdata_ff     (.din(axi_rdata[63:0]),   .dout(buf_rdata[63:0]), .clk(buf_rdata_clk), .clken(buf_rdata_clk_en), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(1))  buf_read_error_ff(.din(buf_read_error_in), .dout(buf_read_error),  .clk(bus_clk),       .clken(bus_clk_en),       .rawclk(clk), .*);          // buf_read_error will be high only one cycle\n\n   // All the Master signals are captured before presenting it to the command buffer. We check for Hresp before sending it to the cmd buffer.\n   rvdff_fpga #(.WIDTH(1))  hresp_ff  (.din(ahb_hresp),          .dout(ahb_hresp_q),       .clk(bus_clk),      .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))  hready_ff (.din(ahb_hready),         .dout(ahb_hready_q),      .clk(bus_clk),      .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(2))  htrans_ff (.din(ahb_htrans_in[1:0]), .dout(ahb_htrans_q[1:0]), .clk(bus_clk),      .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(3))  hsize_ff  (.din(ahb_hsize[2:0]),     .dout(ahb_hsize_q[2:0]),  .clk(ahb_addr_clk), .clken(ahb_addr_clk_en), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))  hwrite_ff (.din(ahb_hwrite),         .dout(ahb_hwrite_q),      .clk(ahb_addr_clk), .clken(ahb_addr_clk_en), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(32)) haddr_ff  (.din(ahb_haddr[31:0]),    .dout(ahb_haddr_q[31:0]), .clk(ahb_addr_clk), .clken(ahb_addr_clk_en), .rawclk(clk), .*);\n\n   // Address check  dccm\n   rvrangecheck #(.CCM_SADR(pt.DCCM_SADR),\n                  .CCM_SIZE(pt.DCCM_SIZE)) addr_dccm_rangecheck (\n      .addr(ahb_haddr_q[31:0]),\n      .in_range(ahb_addr_in_dccm),\n      .in_region(ahb_addr_in_dccm_region_nc)\n   );\n\n   // Address check  iccm\n   if (pt.ICCM_ENABLE == 1) begin: GenICCM\n      rvrangecheck #(.CCM_SADR(pt.ICCM_SADR),\n                     .CCM_SIZE(pt.ICCM_SIZE)) addr_iccm_rangecheck (\n         .addr(ahb_haddr_q[31:0]),\n         .in_range(ahb_addr_in_iccm),\n         .in_region(ahb_addr_in_iccm_region_nc)\n      );\n   end else begin: GenNoICCM\n      assign ahb_addr_in_iccm = '0;\n      assign ahb_addr_in_iccm_region_nc = '0;\n   end\n\n   // PIC memory address check\n   rvrangecheck #(.CCM_SADR(pt.PIC_BASE_ADDR),\n                  .CCM_SIZE(pt.PIC_SIZE)) addr_pic_rangecheck (\n      .addr(ahb_haddr_q[31:0]),\n      .in_range(ahb_addr_in_pic),\n      .in_region(ahb_addr_in_pic_region_nc)\n   );\n\n   // Command Buffer - Holding for the commands to be sent for the AXI. It will be converted to the AXI signals.\n   assign cmdbuf_rst         = (((axi_awvalid & axi_awready) | (axi_arvalid & axi_arready)) & ~cmdbuf_wr_en) | (ahb_hresp & ~cmdbuf_write);\n   assign cmdbuf_full        = (cmdbuf_vld & ~((axi_awvalid & axi_awready) | (axi_arvalid & axi_arready)));\n\n   rvdffsc_fpga #(.WIDTH(1))  cmdbuf_vldff      (.din(1'b1),              .dout(cmdbuf_vld),         .en(cmdbuf_wr_en), .clear(cmdbuf_rst), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga  #(.WIDTH(1))  cmdbuf_writeff    (.din(ahb_hwrite_q),      .dout(cmdbuf_write),       .en(cmdbuf_wr_en),                     .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga  #(.WIDTH(2))  cmdbuf_sizeff     (.din(ahb_hsize_q[1:0]),  .dout(cmdbuf_size[1:0]),   .en(cmdbuf_wr_en),                     .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga  #(.WIDTH(8))  cmdbuf_wstrbff    (.din(master_wstrb[7:0]), .dout(cmdbuf_wstrb[7:0]),  .en(cmdbuf_wr_en),                     .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffe       #(.WIDTH(32)) cmdbuf_addrff     (.din(ahb_haddr_q[31:0]), .dout(cmdbuf_addr[31:0]),  .en(cmdbuf_wr_en & bus_clk_en),        .clk(clk), .*);\n   rvdffe       #(.WIDTH(64)) cmdbuf_wdataff    (.din(ahb_hwdata[63:0]),  .dout(cmdbuf_wdata[63:0]), .en(cmdbuf_wr_en & bus_clk_en),        .clk(clk), .*);\n\n   // AXI Write Command Channel\n   assign axi_awvalid           = cmdbuf_vld & cmdbuf_write;\n   assign axi_awid[TAG-1:0]     = '0;\n   assign axi_awaddr[31:0]      = cmdbuf_addr[31:0];\n   assign axi_awsize[2:0]       = {1'b0, cmdbuf_size[1:0]};\n   assign axi_awprot[2:0]       = 3'b0;\n   assign axi_awlen[7:0]        = '0;\n   assign axi_awburst[1:0]      = 2'b01;\n   // AXI Write Data Channel - This is tied to the command channel as we only write the command buffer once we have the data.\n   assign axi_wvalid            = cmdbuf_vld & cmdbuf_write;\n   assign axi_wdata[63:0]       = cmdbuf_wdata[63:0];\n   assign axi_wstrb[7:0]        = cmdbuf_wstrb[7:0];\n   assign axi_wlast             = 1'b1;\n  // AXI Write Response - Always ready. AHB does not require a write response.\n   assign axi_bready            = 1'b1;\n   // AXI Read Channels\n   assign axi_arvalid           = cmdbuf_vld & ~cmdbuf_write;\n   assign axi_arid[TAG-1:0]     = '0;\n   assign axi_araddr[31:0]      = cmdbuf_addr[31:0];\n   assign axi_arsize[2:0]       = {1'b0, cmdbuf_size[1:0]};\n   assign axi_arprot            = 3'b0;\n   assign axi_arlen[7:0]        = '0;\n   assign axi_arburst[1:0]      = 2'b01;\n   // AXI Read Response Channel - Always ready as AHB reads are blocking and the the buffer is available for the read coming back always.\n   assign axi_rready            = 1'b1;\n\n   // Clock header logic\n   assign ahb_addr_clk_en = bus_clk_en & (ahb_hready & ahb_htrans[1]);\n   assign buf_rdata_clk_en    = bus_clk_en & buf_rdata_en;\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign bus_clk = 1'b0;\n   assign ahb_addr_clk = 1'b0;\n   assign buf_rdata_clk = 1'b0;\n`else\n   rvclkhdr bus_cgc       (.en(bus_clk_en),       .l1clk(bus_clk),       .*);\n   rvclkhdr ahb_addr_cgc  (.en(ahb_addr_clk_en),  .l1clk(ahb_addr_clk),  .*);\n   rvclkhdr buf_rdata_cgc (.en(buf_rdata_clk_en), .l1clk(buf_rdata_clk), .*);\n`endif\n\n`ifdef RV_ASSERT_ON\n   property ahb_error_protocol;\n      @(posedge bus_clk) (ahb_hready & ahb_hresp) |-> (~$past(ahb_hready) & $past(ahb_hresp));\n   endproperty\n   assert_ahb_error_protocol: assert property (ahb_error_protocol) else\n      $display(\"Bus Error with hReady isn't preceded with Bus Error without hready\");\n\n`endif\n\nendmodule // ahb_to_axi4"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n// Owner:\n// Function: AXI4 -> AHB Bridge\n// Comments:\n//\n//********************************************************************************\nmodule axi4_to_ahb\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n,parameter TAG  = 1) (\n\n   input                   clk,\n   input                   free_clk,\n   input                   rst_l,\n   input                   scan_mode,\n   input                   bus_clk_en,\n   input                   clk_override,\n   input                   dec_tlu_force_halt,\n\n   // AXI signals\n   // AXI Write Channels\n   input  logic            axi_awvalid,\n   output logic            axi_awready,\n   input  logic [TAG-1:0]  axi_awid,\n   input  logic [31:0]     axi_awaddr,\n   input  logic [2:0]      axi_awsize,\n   input  logic [2:0]      axi_awprot,\n\n   input  logic            axi_wvalid,\n   output logic            axi_wready,\n   input  logic [63:0]     axi_wdata,\n   input  logic [7:0]      axi_wstrb,\n   input  logic            axi_wlast,\n\n   output logic            axi_bvalid,\n   input  logic            axi_bready,\n   output logic [1:0]      axi_bresp,\n   output logic [TAG-1:0]  axi_bid,\n\n   // AXI Read Channels\n   input  logic            axi_arvalid,\n   output logic            axi_arready,\n   input  logic [TAG-1:0]  axi_arid,\n   input  logic [31:0]     axi_araddr,\n   input  logic [2:0]      axi_arsize,\n   input  logic [2:0]      axi_arprot,\n\n   output logic            axi_rvalid,\n   input  logic            axi_rready,\n   output logic [TAG-1:0]  axi_rid,\n   output logic [63:0]     axi_rdata,\n   output logic [1:0]      axi_rresp,\n   output logic            axi_rlast,\n\n   // AHB-Lite signals\n   output logic [31:0]     ahb_haddr,       // ahb bus address\n   output logic [2:0]      ahb_hburst,      // tied to 0\n   output logic            ahb_hmastlock,   // tied to 0\n   output logic [3:0]      ahb_hprot,       // tied to 4'b0011\n   output logic [2:0]      ahb_hsize,       // size of bus transaction (possible values 0,1,2,3)\n   output logic [1:0]      ahb_htrans,      // Transaction type (possible values 0,2 only right now)\n   output logic            ahb_hwrite,      // ahb bus write\n   output logic [63:0]     ahb_hwdata,      // ahb bus write data\n\n   input logic [63:0]      ahb_hrdata,      // ahb bus read data\n   input logic             ahb_hready,      // slave ready to accept transaction\n   input logic             ahb_hresp        // slave response (high indicates erro)\n\n);\n\n   localparam ID   = 1;\n   localparam PRTY = 1;\n   typedef enum logic [3:0] {\n        IDLE            = 4'b0000,\n        CMD_RD          = 4'b0001,\n        CMD_WR          = 4'b1001,\n        DATA_RD         = 4'b0010,\n        DATA_WR         = 4'b1010,\n        DONE_RD         = 4'b0011,\n        DONE_WR         = 4'b1011,\n        STREAM_RD       = 4'b0101,\n        STREAM_ERR_RD   = 4'b0110\n    } state_t;\n\n   state_t buf_state, buf_nxtstate;\n\n   logic             slave_valid;\n   logic [TAG-1:0]   slave_tag;\n   logic [63:0]      slave_rdata;\n   logic [3:0]       slave_opc;\n\n   logic             wrbuf_en, wrbuf_data_en;\n   logic             wrbuf_cmd_sent, wrbuf_rst;\n   logic             wrbuf_vld;\n   logic             wrbuf_data_vld;\n   logic [TAG-1:0]   wrbuf_tag;\n   logic [2:0]       wrbuf_size;\n   logic [31:0]      wrbuf_addr;\n   logic [63:0]      wrbuf_data;\n   logic [7:0]       wrbuf_byteen;\n\n   logic             master_valid;\n   logic             master_ready;\n   logic [TAG-1:0]   master_tag;\n   logic [31:0]      master_addr;\n   logic [63:0]      master_wdata;\n   logic [2:0]       master_size;\n   logic [2:0]       master_opc;\n   logic [7:0]       master_byteen;\n\n   // Buffer signals (one entry buffer)\n   logic [31:0]                buf_addr;\n   logic [1:0]                 buf_size;\n   logic                       buf_write;\n   logic [7:0]                 buf_byteen;\n   logic                       buf_aligned;\n   logic [63:0]                buf_data;\n   logic [TAG-1:0]             buf_tag;\n\n   //Miscellaneous signals\n   logic                       buf_rst;\n   logic [TAG-1:0]             buf_tag_in;\n   logic [31:0]                buf_addr_in;\n   logic [7:0]                 buf_byteen_in;\n   logic [63:0]                buf_data_in;\n   logic                       buf_write_in;\n   logic                       buf_aligned_in;\n   logic [2:0]                 buf_size_in;\n\n   logic                       buf_state_en;\n   logic                       buf_wr_en;\n   logic                       buf_data_wr_en;\n   logic                       slvbuf_error_en;\n   logic                       wr_cmd_vld;\n\n   logic                       cmd_done_rst, cmd_done, cmd_doneQ;\n   logic                       trxn_done;\n   logic [2:0]                 buf_cmd_byte_ptr, buf_cmd_byte_ptrQ, buf_cmd_nxtbyte_ptr;\n   logic                       buf_cmd_byte_ptr_en;\n   logic                       found;\n\n   logic                       slave_valid_pre;\n   logic                       ahb_hready_q;\n   logic                       ahb_hresp_q;\n   logic [1:0]                 ahb_htrans_q;\n   logic                       ahb_hwrite_q;\n   logic [63:0]                ahb_hrdata_q;\n\n\n   logic                       slvbuf_write;\n   logic                       slvbuf_error;\n   logic [TAG-1:0]             slvbuf_tag;\n\n   logic                       slvbuf_error_in;\n   logic                       slvbuf_wr_en;\n   logic                       bypass_en;\n   logic                       rd_bypass_idle;\n\n   logic                       last_addr_en;\n   logic [31:0]                last_bus_addr;\n\n   // Clocks\n   logic                       buf_clken;\n   logic                       ahbm_data_clken;\n\n   logic                       buf_clk;\n   logic                       bus_clk;\n   logic                       ahbm_data_clk;\n\n   logic                       dec_tlu_force_halt_bus, dec_tlu_force_halt_bus_ns, dec_tlu_force_halt_bus_q;\n\n   // Function to get the length from byte enable\n   function automatic logic [1:0] get_write_size;\n      input logic [7:0] byteen;\n\n      logic [1:0]       size;\n\n      size[1:0] = (2'b11 & {2{(byteen[7:0] == 8'hff)}}) |\n                  (2'b10 & {2{((byteen[7:0] == 8'hf0) | (byteen[7:0] == 8'h0f))}}) |\n                  (2'b01 & {2{((byteen[7:0] == 8'hc0) | (byteen[7:0] == 8'h30) | (byteen[7:0] == 8'h0c) | (byteen[7:0] == 8'h03))}});\n\n      return size[1:0];\n   endfunction // get_write_size\n\n   // Function to get the length from byte enable\n   function automatic logic [2:0] get_write_addr;\n      input logic [7:0] byteen;\n\n      logic [2:0]       addr;\n\n      addr[2:0] = (3'h0 & {3{((byteen[7:0] == 8'hff) | (byteen[7:0] == 8'h0f) | (byteen[7:0] == 8'h03))}}) |\n                  (3'h2 & {3{(byteen[7:0] == 8'h0c)}})                                                     |\n                  (3'h4 & {3{((byteen[7:0] == 8'hf0) | (byteen[7:0] == 8'h03))}})                          |\n                  (3'h6 & {3{(byteen[7:0] == 8'hc0)}});\n\n      return addr[2:0];\n   endfunction // get_write_addr\n\n   // Function to get the next byte pointer\n   function automatic logic [2:0] get_nxtbyte_ptr (logic [2:0] current_byte_ptr, logic [7:0] byteen, logic get_next);\n      logic [2:0] start_ptr;\n      logic       found;\n      found = '0;\n      //get_nxtbyte_ptr[2:0] = current_byte_ptr[2:0];\n      start_ptr[2:0] = get_next ? (current_byte_ptr[2:0] + 3'b1) : current_byte_ptr[2:0];\n      for (int j=0; j<8; j++) begin\n         if (~found) begin\n            get_nxtbyte_ptr[2:0] = 3'(j);\n            found |= (byteen[j] & (3'(j) >= start_ptr[2:0])) ;\n         end\n      end\n   endfunction // get_nextbyte_ptr\n\n   // Create bus synchronized version of force halt\n   assign dec_tlu_force_halt_bus = dec_tlu_force_halt | dec_tlu_force_halt_bus_q;\n   assign dec_tlu_force_halt_bus_ns = ~bus_clk_en & dec_tlu_force_halt_bus;\n   rvdff  #(.WIDTH(1))   force_halt_busff(.din(dec_tlu_force_halt_bus_ns), .dout(dec_tlu_force_halt_bus_q), .clk(free_clk), .*);\n\n   // Write buffer\n   assign wrbuf_en       = axi_awvalid & axi_awready & master_ready;\n   assign wrbuf_data_en  = axi_wvalid & axi_wready & master_ready;\n   assign wrbuf_cmd_sent = master_valid & master_ready & (master_opc[2:1] == 2'b01);\n   assign wrbuf_rst      = (wrbuf_cmd_sent & ~wrbuf_en) | dec_tlu_force_halt_bus;\n\n   assign axi_awready = ~(wrbuf_vld & ~wrbuf_cmd_sent) & master_ready;\n   assign axi_wready  = ~(wrbuf_data_vld & ~wrbuf_cmd_sent) & master_ready;\n   assign axi_arready = ~(wrbuf_vld & wrbuf_data_vld) & master_ready;\n   assign axi_rlast   = 1'b1;\n\n   assign wr_cmd_vld          = (wrbuf_vld & wrbuf_data_vld);\n   assign master_valid        = wr_cmd_vld | axi_arvalid;\n   assign master_tag[TAG-1:0] = wr_cmd_vld ? wrbuf_tag[TAG-1:0] : axi_arid[TAG-1:0];\n   assign master_opc[2:0]     = wr_cmd_vld ? 3'b011 : 3'b0;\n   assign master_addr[31:0]   = wr_cmd_vld ? wrbuf_addr[31:0] : axi_araddr[31:0];\n   assign master_size[2:0]    = wr_cmd_vld ? wrbuf_size[2:0] : axi_arsize[2:0];\n   assign master_byteen[7:0]  = wrbuf_byteen[7:0];\n   assign master_wdata[63:0]  = wrbuf_data[63:0];\n\n   // AXI response channel signals\n   assign axi_bvalid       = slave_valid & slave_opc[3];\n   assign axi_bresp[1:0]   = slave_opc[0] ? 2'b10 : (slave_opc[1] ? 2'b11 : 2'b0);\n   assign axi_bid[TAG-1:0] = slave_tag[TAG-1:0];\n\n   assign axi_rvalid       = slave_valid & (slave_opc[3:2] == 2'b0);\n   assign axi_rresp[1:0]   = slave_opc[0] ? 2'b10 : (slave_opc[1] ? 2'b11 : 2'b0);\n   assign axi_rid[TAG-1:0] = slave_tag[TAG-1:0];\n   assign axi_rdata[63:0]  = slave_rdata[63:0];\n\n // FIFO state machine\n   always_comb begin\n      buf_nxtstate   = IDLE;\n      buf_state_en   = 1'b0;\n      buf_wr_en      = 1'b0;\n      buf_data_wr_en = 1'b0;\n      slvbuf_error_in   = 1'b0;\n      slvbuf_error_en   = 1'b0;\n      buf_write_in   = 1'b0;\n      cmd_done       = 1'b0;\n      trxn_done      = 1'b0;\n      buf_cmd_byte_ptr_en = 1'b0;\n      buf_cmd_byte_ptr[2:0] = '0;\n      slave_valid_pre   = 1'b0;\n      master_ready   = 1'b0;\n      ahb_htrans[1:0]  = 2'b0;\n      slvbuf_wr_en     = 1'b0;\n      bypass_en        = 1'b0;\n      rd_bypass_idle   = 1'b0;\n\n      case (buf_state)\n         IDLE: begin\n                  master_ready   = 1'b1;\n                  buf_write_in = (master_opc[2:1] == 2'b01);\n                  buf_nxtstate = buf_write_in ? CMD_WR : CMD_RD;\n                  buf_state_en = master_valid & master_ready;\n                  buf_wr_en    = buf_state_en;\n                  buf_data_wr_en = buf_state_en & (buf_nxtstate == CMD_WR);\n                  buf_cmd_byte_ptr_en   = buf_state_en;\n                  buf_cmd_byte_ptr[2:0] = buf_write_in ? get_nxtbyte_ptr(3'b0,buf_byteen_in[7:0],1'b0) : master_addr[2:0];\n                  bypass_en       = buf_state_en;\n                  rd_bypass_idle  = bypass_en & (buf_nxtstate == CMD_RD);\n                  ahb_htrans[1:0] = {2{bypass_en}} & 2'b10;\n          end\n         CMD_RD: begin\n                  buf_nxtstate    = (master_valid & (master_opc[2:0] == 3'b000))? STREAM_RD : DATA_RD;\n                  buf_state_en    = ahb_hready_q & (ahb_htrans_q[1:0] != 2'b0) & ~ahb_hwrite_q;\n                  cmd_done        = buf_state_en & ~master_valid;\n                  slvbuf_wr_en    = buf_state_en;\n                  master_ready  = buf_state_en & (buf_nxtstate == STREAM_RD);\n                  buf_wr_en       = master_ready;\n                  bypass_en       = master_ready & master_valid;\n                  buf_cmd_byte_ptr[2:0] = bypass_en ? master_addr[2:0] : buf_addr[2:0];\n                  ahb_htrans[1:0] = 2'b10 & {2{~buf_state_en | bypass_en}};\n         end\n         STREAM_RD: begin\n                  master_ready  =  (ahb_hready_q & ~ahb_hresp_q) & ~(master_valid & master_opc[2:1] == 2'b01);\n                  buf_wr_en       = (master_valid & master_ready & (master_opc[2:0] == 3'b000)); // update the fifo if we are streaming the read commands\n                  buf_nxtstate    = ahb_hresp_q ? STREAM_ERR_RD : (buf_wr_en ? STREAM_RD : DATA_RD);            // assuming that the master accpets the slave response right away.\n                  buf_state_en    = (ahb_hready_q | ahb_hresp_q);\n                  buf_data_wr_en  = buf_state_en;\n                  slvbuf_error_in = ahb_hresp_q;\n                  slvbuf_error_en = buf_state_en;\n                  slave_valid_pre  = buf_state_en & ~ahb_hresp_q;             // send a response right away if we are not going through an error response.\n                  cmd_done        = buf_state_en & ~master_valid;                     // last one of the stream should not send a htrans\n                  bypass_en       = master_ready & master_valid & (buf_nxtstate == STREAM_RD) & buf_state_en;\n                  buf_cmd_byte_ptr[2:0] = bypass_en ? master_addr[2:0] : buf_addr[2:0];\n                  ahb_htrans[1:0] = 2'b10 & {2{~((buf_nxtstate != STREAM_RD) & buf_state_en)}};\n                  slvbuf_wr_en    = buf_wr_en;                                         // shifting the contents from the buf to slv_buf for streaming cases\n         end // case: STREAM_RD\n         STREAM_ERR_RD: begin\n                  buf_nxtstate = DATA_RD;\n                  buf_state_en = ahb_hready_q & (ahb_htrans_q[1:0] != 2'b0) & ~ahb_hwrite_q;\n                  slave_valid_pre = buf_state_en;\n                  slvbuf_wr_en   = buf_state_en;     // Overwrite slvbuf with buffer\n                  buf_cmd_byte_ptr[2:0] = buf_addr[2:0];\n                  ahb_htrans[1:0] = 2'b10 & {2{~buf_state_en}};\n         end\n         DATA_RD: begin\n                  buf_nxtstate   = DONE_RD;\n                  buf_state_en   = (ahb_hready_q | ahb_hresp_q);\n                  buf_data_wr_en = buf_state_en;\n                  slvbuf_error_in= ahb_hresp_q;\n                  slvbuf_error_en= buf_state_en;\n                  slvbuf_wr_en   = buf_state_en;\n\n         end\n         CMD_WR: begin\n                  buf_nxtstate = DATA_WR;\n                  trxn_done    = ahb_hready_q & ahb_hwrite_q & (ahb_htrans_q[1:0] != 2'b0);\n                  buf_state_en = trxn_done;\n                  buf_cmd_byte_ptr_en = buf_state_en;\n                  slvbuf_wr_en    = buf_state_en;\n                  buf_cmd_byte_ptr    = trxn_done ? get_nxtbyte_ptr(buf_cmd_byte_ptrQ[2:0],buf_byteen[7:0],1'b1) : buf_cmd_byte_ptrQ;\n                  cmd_done            = trxn_done & (buf_aligned | (buf_cmd_byte_ptrQ == 3'b111) |\n                                                     (buf_byteen[get_nxtbyte_ptr(buf_cmd_byte_ptrQ[2:0],buf_byteen[7:0],1'b1)] == 1'b0));\n                  ahb_htrans[1:0] = {2{~(cmd_done | cmd_doneQ)}} & 2'b10;\n         end\n         DATA_WR: begin\n                  buf_state_en = (cmd_doneQ & ahb_hready_q) | ahb_hresp_q;\n                  master_ready = buf_state_en & ~ahb_hresp_q & axi_bready;   // Ready to accept new command if current command done and no error\n                  buf_nxtstate = (ahb_hresp_q | ~axi_bready) ? DONE_WR :\n                                  ((master_valid & master_ready) ? ((master_opc[2:1] == 2'b01) ? CMD_WR : CMD_RD) : IDLE);\n                  slvbuf_error_in = ahb_hresp_q;\n                  slvbuf_error_en = buf_state_en;\n\n                  buf_write_in = (master_opc[2:1] == 2'b01);\n                  buf_wr_en = buf_state_en & ((buf_nxtstate == CMD_WR) | (buf_nxtstate == CMD_RD));\n                  buf_data_wr_en = buf_wr_en;\n\n                  cmd_done     = (ahb_hresp_q | (ahb_hready_q & (ahb_htrans_q[1:0] != 2'b0) &\n                                 ((buf_cmd_byte_ptrQ == 3'b111) | (buf_byteen[get_nxtbyte_ptr(buf_cmd_byte_ptrQ[2:0],buf_byteen[7:0],1'b1)] == 1'b0))));\n                  bypass_en       = buf_state_en & buf_write_in & (buf_nxtstate == CMD_WR);   // Only bypass for writes for the time being\n                  ahb_htrans[1:0] = {2{(~(cmd_done | cmd_doneQ) | bypass_en)}} & 2'b10;\n                  slave_valid_pre  = buf_state_en & (buf_nxtstate != DONE_WR);\n\n                  trxn_done = ahb_hready_q & ahb_hwrite_q & (ahb_htrans_q[1:0] != 2'b0);\n                  buf_cmd_byte_ptr_en = trxn_done | bypass_en;\n                  buf_cmd_byte_ptr = bypass_en ? get_nxtbyte_ptr(3'b0,buf_byteen_in[7:0],1'b0) :\n                                                 trxn_done ? get_nxtbyte_ptr(buf_cmd_byte_ptrQ[2:0],buf_byteen[7:0],1'b1) : buf_cmd_byte_ptrQ;\n         end\n         DONE_WR: begin\n                  buf_nxtstate = IDLE;\n                  buf_state_en = axi_bvalid & axi_bready;\n                  slvbuf_error_en = 1'b1;\n                  slave_valid_pre = 1'b1;\n         end\n         DONE_RD: begin\n                  buf_nxtstate = IDLE;\n                  buf_state_en = axi_rvalid & axi_rready; // axi_rlast == 1\n                  slvbuf_error_en = 1'b1;\n                  slave_valid_pre = 1'b1;\n         end\n         default: begin\n                  buf_nxtstate = IDLE;\n                  buf_state_en = 1'b1;\n         end\n      endcase\n   end\n\n   assign buf_rst              = dec_tlu_force_halt_bus;\n   assign cmd_done_rst         = slave_valid_pre;\n   assign buf_addr_in[31:3]    = master_addr[31:3];\n   assign buf_addr_in[2:0]     = (buf_aligned_in & (master_opc[2:1] == 2'b01)) ? get_write_addr(master_byteen[7:0]) : master_addr[2:0];\n   assign buf_tag_in[TAG-1:0]  = master_tag[TAG-1:0];\n   assign buf_byteen_in[7:0]   = wrbuf_byteen[7:0];\n   assign buf_data_in[63:0]    = (buf_state == DATA_RD) ? ahb_hrdata_q[63:0] : master_wdata[63:0];\n   assign buf_size_in[1:0]     = (buf_aligned_in & (master_size[1:0] == 2'b11) & (master_opc[2:1] == 2'b01)) ? get_write_size(master_byteen[7:0]) : master_size[1:0];\n   assign buf_aligned_in       = (master_opc[2:0] == 3'b0)    |   // reads are always aligned since they are either DW or sideeffects\n                                 (master_size[1:0] == 2'b0) |  (master_size[1:0] == 2'b01) | (master_size[1:0] == 2'b10) | // Always aligned for Byte/HW/Word since they can be only for non-idempotent. IFU/SB are always aligned\n                                 ((master_size[1:0] == 2'b11) &\n                                  ((master_byteen[7:0] == 8'h3)  | (master_byteen[7:0] == 8'hc)   | (master_byteen[7:0] == 8'h30) | (master_byteen[7:0] == 8'hc0) |\n                                   (master_byteen[7:0] == 8'hf)  | (master_byteen[7:0] == 8'hf0)  | (master_byteen[7:0] == 8'hff)));\n\n   // Generate the ahb signals\n   assign ahb_haddr[31:3] = bypass_en ? master_addr[31:3]  : buf_addr[31:3];\n   assign ahb_haddr[2:0]  = {3{(ahb_htrans == 2'b10)}} & buf_cmd_byte_ptr[2:0];    // Trxn should be aligned during IDLE\n   assign ahb_hsize[2:0]  = bypass_en ? {1'b0, ({2{buf_aligned_in}} & buf_size_in[1:0])} :\n                                        {1'b0, ({2{buf_aligned}} & buf_size[1:0])};   // Send the full size for aligned trxn\n   assign ahb_hburst[2:0] = 3'b0;\n   assign ahb_hmastlock   = 1'b0;\n   assign ahb_hprot[3:0]  = {3'b001,~axi_arprot[2]};\n   assign ahb_hwrite      = bypass_en ? (master_opc[2:1] == 2'b01) : buf_write;\n   assign ahb_hwdata[63:0] = buf_data[63:0];\n\n   assign slave_valid          = slave_valid_pre;// & (~slvbuf_posted_write | slvbuf_error);\n   assign slave_opc[3:2]       = slvbuf_write ? 2'b11 : 2'b00;\n   assign slave_opc[1:0]       = {2{slvbuf_error}} & 2'b10;\n   assign slave_rdata[63:0]    = slvbuf_error ? {2{last_bus_addr[31:0]}} : ((buf_state == DONE_RD) ? buf_data[63"}
{"text": ":0] : ahb_hrdata_q[63:0]);\n   assign slave_tag[TAG-1:0]   = slvbuf_tag[TAG-1:0];\n\n   assign last_addr_en = (ahb_htrans[1:0] != 2'b0) & ahb_hready & ahb_hwrite ;\n\n\n   rvdffsc_fpga #(.WIDTH(1))   wrbuf_vldff     (.din(1'b1),              .dout(wrbuf_vld),          .en(wrbuf_en),      .clear(wrbuf_rst), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffsc_fpga #(.WIDTH(1))   wrbuf_data_vldff(.din(1'b1),              .dout(wrbuf_data_vld),     .en(wrbuf_data_en), .clear(wrbuf_rst), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga  #(.WIDTH(TAG)) wrbuf_tagff     (.din(axi_awid[TAG-1:0]), .dout(wrbuf_tag[TAG-1:0]), .en(wrbuf_en),                         .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga  #(.WIDTH(3))   wrbuf_sizeff    (.din(axi_awsize[2:0]),   .dout(wrbuf_size[2:0]),    .en(wrbuf_en),                         .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffe       #(.WIDTH(32))  wrbuf_addrff    (.din(axi_awaddr[31:0]),  .dout(wrbuf_addr[31:0]),   .en(wrbuf_en & bus_clk_en),            .clk(clk), .*);\n   rvdffe       #(.WIDTH(64))  wrbuf_dataff    (.din(axi_wdata[63:0]),   .dout(wrbuf_data[63:0]),   .en(wrbuf_data_en & bus_clk_en),       .clk(clk), .*);\n   rvdffs_fpga  #(.WIDTH(8))   wrbuf_byteenff  (.din(axi_wstrb[7:0]),    .dout(wrbuf_byteen[7:0]),  .en(wrbuf_data_en),                    .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n\n   rvdffs_fpga #(.WIDTH(32))   last_bus_addrff (.din(ahb_haddr[31:0]),   .dout(last_bus_addr[31:0]), .en(last_addr_en), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n\n   rvdffsc_fpga #(.WIDTH($bits(state_t))) buf_state_ff  (.din(buf_nxtstate),        .dout({buf_state}),      .en(buf_state_en), .clear(buf_rst), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(1))               buf_writeff   (.din(buf_write_in),        .dout(buf_write),        .en(buf_wr_en),                     .clk(buf_clk), .clken(buf_clken),  .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(TAG))             buf_tagff     (.din(buf_tag_in[TAG-1:0]), .dout(buf_tag[TAG-1:0]), .en(buf_wr_en),                     .clk(buf_clk), .clken(buf_clken),  .rawclk(clk), .*);\n   rvdffe      #(.WIDTH(32))              buf_addrff    (.din(buf_addr_in[31:0]),   .dout(buf_addr[31:0]),   .en(buf_wr_en & bus_clk_en),        .clk(clk), .*);\n   rvdffs_fpga #(.WIDTH(2))               buf_sizeff    (.din(buf_size_in[1:0]),    .dout(buf_size[1:0]),    .en(buf_wr_en),                     .clk(buf_clk), .clken(buf_clken),  .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(1))               buf_alignedff (.din(buf_aligned_in),      .dout(buf_aligned),      .en(buf_wr_en),                     .clk(buf_clk), .clken(buf_clken),  .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(8))               buf_byteenff  (.din(buf_byteen_in[7:0]),  .dout(buf_byteen[7:0]),  .en(buf_wr_en),                     .clk(buf_clk), .clken(buf_clken),  .rawclk(clk), .*);\n   rvdffe      #(.WIDTH(64))              buf_dataff    (.din(buf_data_in[63:0]),   .dout(buf_data[63:0]),   .en(buf_data_wr_en & bus_clk_en),   .clk(clk), .*);\n\n\n   rvdffs_fpga #(.WIDTH(1))   slvbuf_writeff  (.din(buf_write),        .dout(slvbuf_write),        .en(slvbuf_wr_en),    .clk(buf_clk), .clken(buf_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(TAG)) slvbuf_tagff    (.din(buf_tag[TAG-1:0]), .dout(slvbuf_tag[TAG-1:0]), .en(slvbuf_wr_en),    .clk(buf_clk), .clken(buf_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(1))   slvbuf_errorff  (.din(slvbuf_error_in),  .dout(slvbuf_error),        .en(slvbuf_error_en), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n\n   rvdffsc_fpga #(.WIDTH(1)) buf_cmd_doneff     (.din(1'b1),                  .dout(cmd_doneQ),              .en(cmd_done),            .clear(cmd_done_rst), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(3))  buf_cmd_byte_ptrff (.din(buf_cmd_byte_ptr[2:0]), .dout(buf_cmd_byte_ptrQ[2:0]), .en(buf_cmd_byte_ptr_en),                       .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n\n   rvdff_fpga #(.WIDTH(1))  hready_ff (.din(ahb_hready),       .dout(ahb_hready_q),       .clk(bus_clk),       .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(2))  htrans_ff (.din(ahb_htrans[1:0]),  .dout(ahb_htrans_q[1:0]),  .clk(bus_clk),       .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))  hwrite_ff (.din(ahb_hwrite),       .dout(ahb_hwrite_q),       .clk(bus_clk),       .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))  hresp_ff  (.din(ahb_hresp),        .dout(ahb_hresp_q),        .clk(bus_clk),       .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(64)) hrdata_ff (.din(ahb_hrdata[63:0]), .dout(ahb_hrdata_q[63:0]), .clk(ahbm_data_clk), .clken(ahbm_data_clken), .rawclk(clk), .*);\n\n   // Clock headers\n   // clock enables for ahbm addr/data\n   assign buf_clken       = bus_clk_en & (buf_wr_en | slvbuf_wr_en | clk_override);\n   assign ahbm_data_clken = bus_clk_en & ((buf_state != IDLE) | clk_override);\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign bus_clk = 1'b0;\n   assign buf_clk = 1'b0;\n   assign ahbm_data_clk = 1'b0;\n`else\n   rvclkhdr bus_cgc       (.en(bus_clk_en),      .l1clk(bus_clk),       .*);\n   rvclkhdr buf_cgc       (.en(buf_clken),       .l1clk(buf_clk), .*);\n   rvclkhdr ahbm_data_cgc (.en(ahbm_data_clken), .l1clk(ahbm_data_clk), .*);\n`endif\n\n`ifdef RV_ASSERT_ON\n   property ahb_trxn_aligned;\n     @(posedge bus_clk) ahb_htrans[1]  |-> ((ahb_hsize[2:0] == 3'h0)                              |\n                                        ((ahb_hsize[2:0] == 3'h1) & (ahb_haddr[0] == 1'b0))   |\n                                        ((ahb_hsize[2:0] == 3'h2) & (ahb_haddr[1:0] == 2'b0)) |\n                                        ((ahb_hsize[2:0] == 3'h3) & (ahb_haddr[2:0] == 3'b0)));\n   endproperty\n   assert_ahb_trxn_aligned: assert property (ahb_trxn_aligned) else\n     $display(\"Assertion ahb_trxn_aligned failed: ahb_htrans=2'h%h, ahb_hsize=3'h%h, ahb_haddr=32'h%h\",ahb_htrans[1:0], ahb_hsize[2:0], ahb_haddr[31:0]);\n\n   property ahb_error_protocol;\n      @(posedge bus_clk) (ahb_hready & ahb_hresp) |-> (~$past(ahb_hready) & $past(ahb_hresp));\n   endproperty\n   assert_ahb_error_protocol: assert property (ahb_error_protocol) else\n      $display(\"Bus Error with hReady isn't preceded with Bus Error without hready\");\n`endif\n\nendmodule // axi4_to_ahb\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// all flops call the rvdff flop\n\n\nmodule rvdff #( parameter WIDTH=1, SHORT=0 )\n   (\n     input logic [WIDTH-1:0] din,\n     input logic           clk,\n     input logic                   rst_l,\n\n     output logic [WIDTH-1:0] dout\n     );\n\nif (SHORT == 1) begin\n   assign dout = din;\nend\nelse begin\n`ifdef RV_CLOCKGATE\n   always @(posedge tb_top.clk) begin\n      #0 $strobe(\"CG: %0t %m din %x dout %x clk %b width %d\",$time,din,dout,clk,WIDTH);\n   end\n`endif\n\n   always_ff @(posedge clk or negedge rst_l) begin\n      if (rst_l == 0)\n        dout[WIDTH-1:0] <= 0;\n      else\n        dout[WIDTH-1:0] <= din[WIDTH-1:0];\n   end\n\nend\nendmodule\n\n// rvdff with 2:1 input mux to flop din iff sel==1\nmodule rvdffs #( parameter WIDTH=1, SHORT=0 )\n   (\n     input logic [WIDTH-1:0] din,\n     input logic             en,\n     input logic           clk,\n     input logic                   rst_l,\n     output logic [WIDTH-1:0] dout\n     );\n\nif (SHORT == 1) begin : genblock\n   assign dout = din;\nend\nelse begin : genblock\n   rvdff #(WIDTH) dffs (.din((en) ? din[WIDTH-1:0] : dout[WIDTH-1:0]), .*);\nend\n\nendmodule\n\n// rvdff with en and clear\nmodule rvdffsc #( parameter WIDTH=1, SHORT=0 )\n   (\n     input logic [WIDTH-1:0] din,\n     input logic             en,\n     input logic             clear,\n     input logic           clk,\n     input logic                   rst_l,\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic [WIDTH-1:0]          din_new;\nif (SHORT == 1) begin\n   assign dout = din;\nend\nelse begin\n   assign din_new = {WIDTH{~clear}} & (en ? din[WIDTH-1:0] : dout[WIDTH-1:0]);\n   rvdff #(WIDTH) dffsc (.din(din_new[WIDTH-1:0]), .*);\nend\nendmodule\n\n// _fpga versions\nmodule rvdff_fpga #( parameter WIDTH=1, SHORT=0 )\n   (\n     input logic [WIDTH-1:0] din,\n     input logic           clk,\n     input logic           clken,\n     input logic           rawclk,\n     input logic           rst_l,\n\n     output logic [WIDTH-1:0] dout\n     );\n\nif (SHORT == 1) begin\n   assign dout = din;\nend\nelse begin\n   `ifdef RV_FPGA_OPTIMIZE\n    rvdffs #(WIDTH) dffs (.clk(rawclk), .en(clken), .*);\n`else\n    rvdff #(WIDTH)  dff (.*);\n`endif\nend\nendmodule\n\n// rvdff with 2:1 input mux to flop din iff sel==1\nmodule rvdffs_fpga #( parameter WIDTH=1, SHORT=0 )\n   (\n     input logic [WIDTH-1:0] din,\n     input logic             en,\n     input logic           clk,\n     input logic           clken,\n     input logic           rawclk,\n     input logic           rst_l,\n\n     output logic [WIDTH-1:0] dout\n     );\n\nif (SHORT == 1) begin : genblock\n   assign dout = din;\nend\nelse begin : genblock\n`ifdef RV_FPGA_OPTIMIZE\n   rvdffs #(WIDTH)   dffs (.clk(rawclk), .en(clken & en), .*);\n`else\n   rvdffs #(WIDTH)   dffs (.*);\n`endif\nend\n\nendmodule\n\n// rvdff with en and clear\nmodule rvdffsc_fpga #( parameter WIDTH=1, SHORT=0 )\n   (\n     input logic [WIDTH-1:0] din,\n     input logic             en,\n     input logic             clear,\n     input logic             clk,\n     input logic             clken,\n     input logic             rawclk,\n     input logic             rst_l,\n\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic [WIDTH-1:0]          din_new;\nif (SHORT == 1) begin\n   assign dout = din;\nend\nelse begin\n`ifdef RV_FPGA_OPTIMIZE\n   rvdffs  #(WIDTH)   dffs  (.clk(rawclk), .din(din[WIDTH-1:0] & {WIDTH{~clear}}),.en((en | clear) & clken), .*);\n`else\n   rvdffsc #(WIDTH)   dffsc (.*);\n`endif\nend\nendmodule\n\n\nmodule rvdffe #( parameter WIDTH=1, SHORT=0, OVERRIDE=0 )\n   (\n     input  logic [WIDTH-1:0] din,\n     input  logic           en,\n     input  logic           clk,\n     input  logic           rst_l,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic                      l1clk;\n\nif (SHORT == 1) begin : genblock\n   if (1) begin : genblock\n      assign dout = din;\n   end\nend\nelse begin : genblock\n\n`ifndef RV_PHYSICAL\n   if (WIDTH >= 8 || OVERRIDE==1) begin: genblock\n`endif\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .* );\n`else\n      rvclkhdr clkhdr ( .* );\n      rvdff #(WIDTH) dff (.*, .clk(l1clk));\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdffe must be WIDTH >= 8\");\n`endif\nend // else: !if(SHORT == 1)\n\nendmodule // rvdffe\n\n\nmodule rvdffpcie #( parameter WIDTH=31 )\n   (\n     input  logic [WIDTH-1:0] din,\n     input  logic             clk,\n     input  logic             rst_l,\n     input  logic             en,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH == 31) begin: genblock\n`endif\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .* );\n`else\n\n      rvdfflie #(.WIDTH(WIDTH), .LEFT(19)) dff (.*);\n\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdffpcie width must be 31\");\n`endif\nendmodule\n\n// format: { LEFT, EXTRA }\n// LEFT # of bits will be done with rvdffie, all else EXTRA with rvdffe\nmodule rvdfflie #( parameter WIDTH=16, LEFT=8 )\n   (\n     input  logic [WIDTH-1:0] din,\n     input  logic             clk,\n     input  logic             rst_l,\n     input  logic             en,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   localparam EXTRA = WIDTH-LEFT;\n\n\n\n\n\n\n\n   localparam LMSB = WIDTH-1;\n   localparam LLSB = LMSB-LEFT+1;\n   localparam XMSB = LLSB-1;\n   localparam XLSB = LLSB-EXTRA;\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH >= 16 && LEFT >= 8 && EXTRA >= 8) begin: genblock\n`endif\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .* );\n`else\n\n      rvdffiee #(LEFT)  dff_left  (.*, .din(din[LMSB:LLSB]), .dout(dout[LMSB:LLSB]));\n\n\n      rvdffe  #(EXTRA)  dff_extra (.*, .din(din[XMSB:XLSB]), .dout(dout[XMSB:XLSB]));\n\n\n\n\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdfflie musb be WIDTH >= 16 && LEFT >= 8 && EXTRA >= 8\");\n`endif\nendmodule\n\n\n\n\n// special power flop for predict packet\n// format: { LEFT, RIGHT==31 }\n// LEFT # of bits will be done with rvdffe; RIGHT is enabled by LEFT[LSB] & en\nmodule rvdffppe #( parameter integer WIDTH = 39 )\n   (\n     input  logic [WIDTH-1:0] din,\n     input  logic             clk,\n     input  logic             rst_l,\n     input  logic             en,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   localparam integer RIGHT = 31;\n   localparam integer LEFT  = WIDTH - RIGHT;\n\n   localparam integer LMSB  = WIDTH-1;\n   localparam integer LLSB  = LMSB-LEFT+1;\n   localparam integer RMSB  = LLSB-1;\n   localparam integer RLSB  = LLSB-RIGHT;\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH>=32 && LEFT>=8 && RIGHT>=8) begin: genblock\n`endif\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .* );\n`else\n      rvdffe #(LEFT)     dff_left (.*, .din(din[LMSB:LLSB]), .dout(dout[LMSB:LLSB]));\n\n      rvdffe #(RIGHT)   dff_right (.*, .din(din[RMSB:RLSB]), .dout(dout[RMSB:RLSB]), .en(en & din[LLSB]));  // qualify with pret\n\n\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: must be WIDTH>=32 && LEFT>=8 && RIGHT>=8\");\n`endif\nendmodule\n\n\n\n\nmodule rvdffie #( parameter WIDTH=1, OVERRIDE=0 )\n   (\n     input  logic [WIDTH-1:0] din,\n\n     input  logic           clk,\n     input  logic           rst_l,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic                      l1clk;\n   logic                      en;\n\n\n\n\n\n\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH >= 8 || OVERRIDE==1) begin: genblock\n`endif\n\n      assign en = |(din ^ dout);\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .* );\n`else\n      rvclkhdr clkhdr ( .* );\n      rvdff #(WIDTH) dff (.*, .clk(l1clk));\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n     $error(\"%m: rvdffie must be WIDTH >= 8\");\n`endif\n\n\nendmodule\n\n// ie flop but it has an .en input\nmodule rvdffiee #( parameter WIDTH=1, OVERRIDE=0 )\n   (\n     input  logic [WIDTH-1:0] din,\n\n     input  logic           clk,\n     input  logic           rst_l,\n     input  logic           scan_mode,\n     input  logic           en,\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic                      l1clk;\n   logic                      final_en;\n\n`ifndef RV_PHYSICAL\n   if (WIDTH >= 8 || OVERRIDE==1) begin: genblock\n`endif\n\n      assign final_en = (|(din ^ dout)) & en;\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .*, .en(final_en) );\n`else\n      rvdffe #(WIDTH) dff (.*,  .en(final_en));\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdffie width must be >= 8\");\n`endif\n\nendmodule\n\n\n\nmodule rvsyncss #(parameter WIDTH = 251)\n   (\n     input  logic                 clk,\n     input  logic                 rst_l,\n     input  logic [WIDTH-1:0]     din,\n     output logic [WIDTH-1:0]     dout\n     );\n\n   logic [WIDTH-1:0]              din_ff1;\n\n   rvdff #(WIDTH) sync_ff1  (.*, .din (din[WIDTH-1:0]),     .dout(din_ff1[WIDTH-1:0]));\n   rvdff #(WIDTH) sync_ff2  (.*, .din (din_ff1[WIDTH-1:0]), .dout(dout[WIDTH-1:0]));\n\nendmodule // rvsyncss\n\nmodule rvsyncss_fpga #(parameter WIDTH = 251)\n   (\n     input  logic                 gw_clk,\n     input  logic                 rawclk,\n     input  logic                 clken,\n     input  logic                 rst_l,\n     input  logic [WIDTH-1:0]     din,\n     output logic [WIDTH-1:0]     dout\n     );\n\n   logic [WIDTH-1:0]              din_ff1;\n\n   rvdff_fpga #(WIDTH) sync_ff1  (.*, .clk(gw_clk), .rawclk(rawclk), .clken(clken), .din (din[WIDTH-1:0]),     .dout(din_ff1[WIDTH-1:0]));\n   rvdff_fpga #(WIDTH) sync_ff2  (.*, .clk(gw_clk), .rawclk(rawclk), .clken(clken), .din (din_ff1[WIDTH-1:0]), .dout(dout[WIDTH-1:0]));\n\nendmodule // rvsyncss\n\nmodule rvlsadder\n  (\n    input logic [31:0] rs1,\n    input logic [11:0] offset,\n\n    output logic [31:0] dout\n    );\n\n   logic                cout;\n   logic                sign;\n\n   logic [31:12]        rs1_inc;\n   logic [31:12]        rs1_dec;\n\n   assign {cout,dout[11:0]} = {1'b0,rs1[11:0]} + {1'b0,offset[11:0]};\n\n   assign rs1_inc[31:12] = rs1[31:12] + 1;\n\n   assign rs1_dec[31:12] = rs1[31:12] - 1;\n\n   assign sign = offset[11];\n\n   assign dout[31:12] = ({20{  sign ^~  cout}} &     rs1[31:12]) |\n                        ({20{ ~sign &   cout}}  & rs1_inc[31:12]) |\n                        ({20{  sign &  ~cout}}  & rs1_dec[31:12]);\n\nendmodule // rvlsadder\n\n// assume we only maintain pc[31:1] in the pipe\n\nmodule rvbradder\n  (\n    input [31:1] pc,\n    input [12:1] offset,\n\n    output [31:1] dout\n    );\n\n   logic          cout;\n   logic          sign;\n\n   logic [31:13]  pc_inc;\n   logic [31:13]  pc_dec;\n\n   assign {cout,dout[12:1]} = {1'b0,pc[12:1]} + {1'b0,offset[12:1]};\n\n   assign pc_inc[31:13] = pc[31:13] + 1;\n\n   assign pc_dec[31:13] = pc[31:13] - 1;\n\n   assign sign = offset[12];\n\n\n   assign dout[31:13] = ({19{  sign ^~  cout}} &     pc[31:13]) |\n                        ({19{ ~sign &   cout}}  & pc_inc[31:13]) |\n                        ({19{  sign &  ~cout}}  & pc_dec[31:13]);\n\n\nendmodule // rvbradder\n\n\n// 2s complement circuit\nmodule rvtwoscomp #( parameter WIDTH=32 )\n   (\n     input logic [WIDTH-1:0] din,\n\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic [WIDTH-1:1]          dout_temp;   // holding for all other bits except for the lsb. LSB is always din\n\n   genvar                     i;\n\n   for ( i = 1; i < WIDTH; i++ )  begin : flip_after_first_one\n      assign dout_temp[i] = (|din[i-1:0]) ? ~din[i] : din[i];\n   end : flip_after_first_one\n\n   assign dout[WIDTH-1:0]  = { dout_temp[WIDTH-1:1], din[0] };\n\nendmodule  // 2'scomp\n\n// find first\nmodule rvfindfirst1 #( parameter WIDTH=32, SHIFT=$clog2(WIDTH) )\n   (\n     input logic [WIDTH-1:0] din,\n\n     output logic [SHIFT-1:0] dout\n     );\n   logic                      done;\n\n   always_comb begin\n      dout[SHIFT-1:0] = {SHIFT{1'b0}};\n      done    = 1'b0;\n\n      for ( int i = WIDTH-1; i > 0; i-- )  begin : find_first_one\n         done |= din[i];\n         dout[SHIFT-1:0] += done ? 1'b0 : 1'b1;\n      end : find_first_one\n   end\nendmodule // rvfindfirst1\n\nmodule rvfindfirst1hot #( parameter WIDTH=32 )\n   (\n     input logic [WIDTH-1:0] din,\n\n     output logic [WIDTH-1:0] dout\n     );\n   logic                      done;\n\n   always_comb begin\n      dout[WIDTH-1:0] = {WIDTH{1'b0}};\n      done    = 1'b0;\n      for ( int i = 0; i < WIDTH; i++ )  begin : find_first_one\n         dout[i] = ~done & din[i];\n         done   |= din[i];\n      end : find_first_one\n   end\nendmodule // rvfindfirst1hot\n\n// mask and match function matches bits after finding the first 0 position\n// find first starting from LSB. Skip that location and match the rest of the bits\nmodule rvmaskandmatch #( parameter WIDTH=32 )\n   (\n     input  logic [WIDTH-1:0] mask,     // this will have the mask in the lower bit positions\n     input  logic [WIDTH-1:0] data,     // this is what needs to be matched on the upper bits with the mask's upper bits\n     input  logic             masken,   // when 1 : do mask. 0 : full match\n     output logic             match\n     );\n\n   logic [WIDTH-1:0]          matchvec;\n   logic                      masken_or_fullmask;\n\n   assign masken_or_fullmask = masken &  ~(&mask[WIDTH-1:0]);\n\n   assign matchvec[0]        = masken_or_fullmask | (mask[0] == data[0]);\n   genvar                     i;\n\n   for ( i = 1; i < WIDTH; i++ )  begin : match_after_first_zero\n      assign matchvec[i] = (&mask[i-1:0] & masken_or_fullmask) ? 1'b1 : (mask[i] == data[i]);\n   end : match_after_first_zero\n\n   assign match  = &matchvec[WIDTH-1:0];    // all bits either matched or were masked off\n\nendmodule // rvmaskandmatch\n\n\n\n\n// Check if the S_ADDR <= addr < E_ADDR\nmodule rvrangecheck  #(CCM_SADR = 32'h0,\n                       CCM_SIZE  = 128) (\n   input  logic [31:0]   addr,                             // Address to be checked for range\n   output logic          in_range,                            // S_ADDR <= start_addr < E_ADDR\n   output logic          in_region\n);\n\n   localparam REGION_BITS = 4;\n   localparam MASK_BITS = 10 + $clog2(CCM_SIZE);\n\n   logic [31:0]          start_addr;\n   logic [3:0]           region;\n\n   assign start_addr[31:0]        = CCM_SADR;\n   assign region[REGION_BITS-1:0] = start_addr[31:(32-REGION_BITS)];\n\n   assign in_region = (addr[31:(32-REGION_BITS)] == region[REGION_BITS-1:0]);\n   if (CCM_SIZE  == 48)\n    assign in_range  = (addr[31:MASK_BITS] == start_addr[31:MASK_BITS]) & ~(&addr[MASK_BITS-1 : MASK_BITS-2]);\n   else\n    assign in_range  = (addr[31:MASK_BITS] == start_addr[31:MASK_BITS]);\n\nendmodule  // rvrangechecker\n\n// 16 bit even parity generator\nmodule rveven_paritygen #(WIDTH = 16)  (\n                                         input  logic [WIDTH-1:0]  data_in,         // Data\n                                         output logic              parity_out       // generated even parity\n                                         );\n\n   assign  parity_out =  ^(data_in[WIDTH-1:0]) ;\n\nendmodule  // rveven_paritygen\n\nmodule rveven_paritycheck #(WIDTH = 16)  (\n                                           input  logic [WIDTH-1:0]  data_in,         // Data\n                                           input  logic              parity_in,\n                                           output logic              parity_err       // Parity error\n                                           );\n\n   assign  parity_err =  ^(data_in[WIDTH-1:0]) ^ parity_in ;\n\nendmodule  // rveven_paritycheck\n\nmodule rvecc_encode  (\n                      input [31:0] din,\n                      output [6:0] ecc_out\n                      );\nlogic [5:0] ecc_out_temp;\n\n   assign ecc_out_temp[0] = din[0]^din[1]^din[3]^din[4]^din[6]^din[8]^din[10]^din[11]^din[13]^din[15]^din[17]^din[19]^din[21]^din[23]^din[25]^din[26]^din[28]^din[30];\n   assign ecc_out_temp[1] = din[0]^din[2]^din[3]^din[5]^din[6]^din[9]^din[10]^din[12]^din[13]^din[16]^din[17]^din[20]^din[21]^din[24]^din[25]^din[27]^din[28]^din[31];\n   assign ecc_out_temp[2] = din[1]^din[2]^din[3]^din[7]^din[8]^din[9]^din[10]^din[14]^din[15]^din[16]^din[17]^din[22]^din[23]^din[24]^din[25]^din[29]^din[30]^din[31];\n   assign ecc_out_temp[3] = din[4]^din[5]^din[6]^din[7]^din[8]^din[9]^din[10]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25];\n   assign ecc_out_temp[4] = din[11]^din[12]^din[13]^din[14]^din[15]^din[16]^din[17]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25];\n   assign ecc_out_temp[5] = din[26]^din[27]^din[28]^din[29]^din[30]^din[31];\n\n   assign ecc_out[6:0] = {(^din[31:0])^(^ecc_out_temp[5:0]),ecc_out_temp[5:0]};\n\nendmodule // rvecc_encode\n\nmodule rvecc_decode  (\n                      input         en,\n                      input [31:0]  din,\n                      input [6:0]   ecc_in,\n                      input         sed_ded,    // only do detection and no correction. Used for the I$\n                      output [31:0] dout,\n                      output [6:0]  ecc_out,\n                      output        single_ecc_error,\n                      output        double_ecc_error\n\n                      );\n\n   logic [6:0]                      ecc_check;\n   logic [38:0]                     error_mask;\n   logic [38:0]                     din_plus_parity, dout_plus_parity;\n\n   // Generate the ecc bits\n   assign ecc_check[0] = ecc_in[0]^din[0]^din[1]^din[3]^din[4]^din[6]^din[8]^din[10]^din[11]^din[13]^din[15]^din[17]^din[19]^din[21]^din[23]^din[25]^din[26]^din[28]^din[30];\n   assign ecc_check[1] = ecc_in[1]^din[0]^din[2]^din[3]^din[5]^din[6]^din[9]^din[10]^din[12]^din[13]^din[16]^din[17]^din[20]^din[21]^din[24]^din[25]^din[27]^din[28]^din[31];\n   assign ecc_check[2] = ecc_in[2]^din[1]^din[2]^din[3]^din[7]^din[8]^din[9]^din[10]^din[14]^din[15]^din[16]^din[17]^din[22]^din[23]^din[24]^din[25]^din[29]^din[30]^din[31];\n   assign ecc_check[3] = ecc_in[3]^din[4]^din[5]^din[6]^din[7]^din[8]^din[9]^din[10]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25];\n   assign ecc_check[4] = ecc_in[4]^din[11]^din[12]^din[13]^din[14]^din[15]^din[16]^din[17]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25];\n   assign ecc_check[5] = ecc_in[5]^din[26]^din[27]^din[28]^din[29]^din[30]^din[31];\n\n   // This is the parity bit\n   assign ecc_check[6] = ((^din[31:0])^(^ecc_in[6:0])) & ~sed_ded;\n\n   assign single_ecc_error = en & (ecc_check[6:0] != 0) & ecc_check[6];   // this will never be on for sed_ded\n   assign double_ecc_error = en & (ecc_check[6:0] != 0) & ~ecc_check[6];  // all errors in the sed_ded case will be recorded as DE\n\n   // Generate the mask for error correctiong\n   for (genvar i=1; i<40; i++) begin\n      assign error_mask[i-1] = (ecc_check[5:0] == i);\n   end\n\n   // Generate the corrected data\n   assign din_plus_parity[38:0] = {ecc_in[6], din[31:26], ecc_in[5], din[25:11], ecc_in[4], din[10:4], ecc_in[3], din[3:1], ecc_in[2], din[0], ecc_in[1:0]};\n\n   assign dout_plus_parity[38:0] = single_ecc_error ? (error_mask[38:0] ^ din_plus_parity[38:0]) : din_plus_parity[38:0];\n   assign dout[31:0]             = {dout_plus_parity[37:32], dout_plus_parity[30:16], dout_plus_parity[14:8], dout_plus_parity[6:4], dout_plus_parity[2]};\n   assign ecc_out[6:0]           = {(dout_plus_parity[38] ^ (ecc_check[6:0] == 7'b1000000)), dout_plus_parity[31], dout_plus_parity[15], dout_plus_parity[7], dout_plus_parity[3], dout_plus_parity[1:0]};\n\nendmodule // rvecc_decode\n\nmodule rvecc_encode_64  (\n                      input [63:0] din,\n                      output [6:0] ecc_out\n                      );\n  assign ecc_out[0] = din[0]^din[1]^din[3]^din[4]^din[6]^din[8]^din[10]^din[11]^din[13]^din[15]^din[17"}
{"text": "]^din[19]^din[21]^din[23]^din[25]^din[26]^din[28]^din[30]^din[32]^din[34]^din[36]^din[38]^din[40]^din[42]^din[44]^din[46]^din[48]^din[50]^din[52]^din[54]^din[56]^din[57]^din[59]^din[61]^din[63];\n\n   assign ecc_out[1] = din[0]^din[2]^din[3]^din[5]^din[6]^din[9]^din[10]^din[12]^din[13]^din[16]^din[17]^din[20]^din[21]^din[24]^din[25]^din[27]^din[28]^din[31]^din[32]^din[35]^din[36]^din[39]^din[40]^din[43]^din[44]^din[47]^din[48]^din[51]^din[52]^din[55]^din[56]^din[58]^din[59]^din[62]^din[63];\n\n   assign ecc_out[2] = din[1]^din[2]^din[3]^din[7]^din[8]^din[9]^din[10]^din[14]^din[15]^din[16]^din[17]^din[22]^din[23]^din[24]^din[25]^din[29]^din[30]^din[31]^din[32]^din[37]^din[38]^din[39]^din[40]^din[45]^din[46]^din[47]^din[48]^din[53]^din[54]^din[55]^din[56]^din[60]^din[61]^din[62]^din[63];\n\n   assign ecc_out[3] = din[4]^din[5]^din[6]^din[7]^din[8]^din[9]^din[10]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25]^din[33]^din[34]^din[35]^din[36]^din[37]^din[38]^din[39]^din[40]^din[49]^din[50]^din[51]^din[52]^din[53]^din[54]^din[55]^din[56];\n\n   assign ecc_out[4] = din[11]^din[12]^din[13]^din[14]^din[15]^din[16]^din[17]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25]^din[41]^din[42]^din[43]^din[44]^din[45]^din[46]^din[47]^din[48]^din[49]^din[50]^din[51]^din[52]^din[53]^din[54]^din[55]^din[56];\n\n   assign ecc_out[5] = din[26]^din[27]^din[28]^din[29]^din[30]^din[31]^din[32]^din[33]^din[34]^din[35]^din[36]^din[37]^din[38]^din[39]^din[40]^din[41]^din[42]^din[43]^din[44]^din[45]^din[46]^din[47]^din[48]^din[49]^din[50]^din[51]^din[52]^din[53]^din[54]^din[55]^din[56];\n\n   assign ecc_out[6] = din[57]^din[58]^din[59]^din[60]^din[61]^din[62]^din[63];\n\nendmodule // rvecc_encode_64\n\n\nmodule rvecc_decode_64  (\n                      input         en,\n                      input [63:0]  din,\n                      input [6:0]   ecc_in,\n                      output        ecc_error\n                      );\n\n   logic [6:0]                      ecc_check;\n\n   // Generate the ecc bits\n   assign ecc_check[0] = ecc_in[0]^din[0]^din[1]^din[3]^din[4]^din[6]^din[8]^din[10]^din[11]^din[13]^din[15]^din[17]^din[19]^din[21]^din[23]^din[25]^din[26]^din[28]^din[30]^din[32]^din[34]^din[36]^din[38]^din[40]^din[42]^din[44]^din[46]^din[48]^din[50]^din[52]^din[54]^din[56]^din[57]^din[59]^din[61]^din[63];\n\n   assign ecc_check[1] = ecc_in[1]^din[0]^din[2]^din[3]^din[5]^din[6]^din[9]^din[10]^din[12]^din[13]^din[16]^din[17]^din[20]^din[21]^din[24]^din[25]^din[27]^din[28]^din[31]^din[32]^din[35]^din[36]^din[39]^din[40]^din[43]^din[44]^din[47]^din[48]^din[51]^din[52]^din[55]^din[56]^din[58]^din[59]^din[62]^din[63];\n\n   assign ecc_check[2] = ecc_in[2]^din[1]^din[2]^din[3]^din[7]^din[8]^din[9]^din[10]^din[14]^din[15]^din[16]^din[17]^din[22]^din[23]^din[24]^din[25]^din[29]^din[30]^din[31]^din[32]^din[37]^din[38]^din[39]^din[40]^din[45]^din[46]^din[47]^din[48]^din[53]^din[54]^din[55]^din[56]^din[60]^din[61]^din[62]^din[63];\n\n   assign ecc_check[3] = ecc_in[3]^din[4]^din[5]^din[6]^din[7]^din[8]^din[9]^din[10]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25]^din[33]^din[34]^din[35]^din[36]^din[37]^din[38]^din[39]^din[40]^din[49]^din[50]^din[51]^din[52]^din[53]^din[54]^din[55]^din[56];\n\n   assign ecc_check[4] = ecc_in[4]^din[11]^din[12]^din[13]^din[14]^din[15]^din[16]^din[17]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25]^din[41]^din[42]^din[43]^din[44]^din[45]^din[46]^din[47]^din[48]^din[49]^din[50]^din[51]^din[52]^din[53]^din[54]^din[55]^din[56];\n\n   assign ecc_check[5] = ecc_in[5]^din[26]^din[27]^din[28]^din[29]^din[30]^din[31]^din[32]^din[33]^din[34]^din[35]^din[36]^din[37]^din[38]^din[39]^din[40]^din[41]^din[42]^din[43]^din[44]^din[45]^din[46]^din[47]^din[48]^din[49]^din[50]^din[51]^din[52]^din[53]^din[54]^din[55]^din[56];\n\n   assign ecc_check[6] = ecc_in[6]^din[57]^din[58]^din[59]^din[60]^din[61]^din[62]^din[63];\n\n   assign ecc_error = en & (ecc_check[6:0] != 0);  // all errors in the sed_ded case will be recorded as DE\n\n endmodule // rvecc_decode_64\n\n`ifndef TECH_SPECIFIC_EC_RV_ICG\nmodule `TEC_RV_ICG\n  (\n   input logic SE, EN, CK,\n   output Q\n   );\n\n   logic  en_ff;\n   logic  enable;\n\n   assign      enable = EN | SE;\n\n`ifdef VERILATOR\n   always @(negedge CK) begin\n      en_ff <= enable;\n   end\n`else\n   always @(CK, enable) begin\n      if(!CK)\n        en_ff = enable;\n   end\n`endif\n   assign Q = CK & en_ff;\n\nendmodule\n`endif\n\n`ifndef RV_FPGA_OPTIMIZE\nmodule rvclkhdr\n  (\n   input  logic en,\n   input  logic clk,\n   input  logic scan_mode,\n   output logic l1clk\n   );\n\n   logic   SE;\n   assign       SE = 0;\n\n`ifdef TECH_SPECIFIC_EC_RV_ICG\n   `USER_EC_RV_ICG clkhdr ( .*, .EN(en), .CK(clk), .Q(l1clk));\n`else\n   `TEC_RV_ICG clkhdr ( .*, .EN(en), .CK(clk), .Q(l1clk));\n`endif\n\nendmodule // rvclkhdr\n`endif\n\nmodule rvoclkhdr\n  (\n   input  logic en,\n   input  logic clk,\n   input  logic scan_mode,\n   output logic l1clk\n   );\n\n   logic   SE;\n   assign       SE = 0;\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign l1clk = clk;\n`else\n   `ifdef TECH_SPECIFIC_EC_RV_ICG\n      `USER_EC_RV_ICG clkhdr ( .*, .EN(en), .CK(clk), .Q(l1clk));\n   `else\n      `TEC_RV_ICG clkhdr ( .*, .EN(en), .CK(clk), .Q(l1clk));\n    `endif\n`endif\n\nendmodule\n\n\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2018 Western Digital Corporation or it's affiliates.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//------------------------------------------------------------------------------------\n//\n//  Copyright Western Digital, 2019\n//  Owner : Alex Grobman\n//  Description:  \n//                This module Synchronizes the signals between JTAG (TCK) and\n//                processor (Core_clk)\n//\n//-------------------------------------------------------------------------------------\n\nmodule dmi_jtag_to_core_sync (\n// JTAG signals\ninput       rd_en,      // 1 bit  Read Enable from JTAG\ninput       wr_en,      // 1 bit  Write enable from JTAG\n\n// Processor Signals\ninput       rst_n,      // Core reset\ninput       clk,        // Core clock\n\noutput      reg_en,     // 1 bit  Write interface bit to Processor\noutput      reg_wr_en   // 1 bit  Write enable to Processor\n);\n  \nwire        c_rd_en;\nwire        c_wr_en;\nreg [2:0]   rden, wren;\n \n\n// Outputs\nassign reg_en    = c_wr_en | c_rd_en;\nassign reg_wr_en = c_wr_en;\n\n\n// synchronizers  \nalways @ ( posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        rden <= '0;\n        wren <= '0;\n    end\n    else begin\n        rden <= {rden[1:0], rd_en};\n        wren <= {wren[1:0], wr_en};\n    end\nend\n\nassign c_rd_en = rden[1] & ~rden[2];\nassign c_wr_en = wren[1] & ~wren[2];\n \n\nendmodule\n"}
{"text": "// DMI core aperture ranges from 0x00 to 0x4F. Addresses starting from 0x50\n// and above are considered uncore.\n\nmodule dmi_mux (\n\n    // Uncore access enable\n    input wire uncore_enable,\n\n    // DMI upstream\n    input  wire        dmi_en,\n    input  wire        dmi_wr_en,\n    input  wire [ 6:0] dmi_addr,\n    input  wire [31:0] dmi_wdata,\n    output wire [31:0] dmi_rdata,\n\n    // DMI downstream for core\n    output wire        dmi_core_en,\n    output wire        dmi_core_wr_en,\n    output wire [ 6:0] dmi_core_addr,\n    output wire [31:0] dmi_core_wdata,\n    input  wire [31:0] dmi_core_rdata,\n\n    // DMI downstream for uncore\n    output wire        dmi_uncore_en,\n    output wire        dmi_uncore_wr_en,\n    output wire [ 6:0] dmi_uncore_addr,\n    output wire [31:0] dmi_uncore_wdata,\n    input  wire [31:0] dmi_uncore_rdata\n);\n  logic is_uncore_aperture;\n\n  // Uncore address decoder\n  assign is_uncore_aperture = (dmi_addr[6] & (dmi_addr[5] | dmi_addr[4]));\n\n  // Core signals\n  assign dmi_core_en        = dmi_en & ~is_uncore_aperture;\n  assign dmi_core_wr_en     = dmi_wr_en & ~is_uncore_aperture;\n  assign dmi_core_addr      = dmi_addr;\n  assign dmi_core_wdata     = dmi_wdata;\n\n  // Uncore signals\n  assign dmi_uncore_en      = dmi_en & is_uncore_aperture & uncore_enable;\n  assign dmi_uncore_wr_en   = dmi_wr_en & is_uncore_aperture & uncore_enable;\n  assign dmi_uncore_addr    = dmi_addr;\n  assign dmi_uncore_wdata   = dmi_wdata;\n\n  // Read mux\n  assign dmi_rdata          = is_uncore_aperture ? dmi_uncore_rdata : dmi_core_rdata;\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2018 Western Digital Corporation or it's affiliates.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//------------------------------------------------------------------------------------\n//\n//  Copyright Western Digital, 2018\n//  Owner : Anusha Narayanamoorthy\n//  Description:  \n//                Wrapper module for JTAG_TAP and DMI synchronizer\n//\n//-------------------------------------------------------------------------------------\n\nmodule dmi_wrapper(\n\n  // JTAG signals\n  input              trst_n,              // JTAG reset\n  input              tck,                 // JTAG clock\n  input              tms,                 // Test mode select   \n  input              tdi,                 // Test Data Input\n  output             tdo,                 // Test Data Output           \n  output             tdoEnable,           // Test Data Output enable             \n\n  // Processor Signals\n  input              core_rst_n,          // Core reset                  \n  input              core_clk,            // Core clock                  \n  input [31:1]       jtag_id,             // JTAG ID\n  input [31:0]       rd_data,             // 32 bit Read data from  Processor                       \n  output [31:0]      reg_wr_data,         // 32 bit Write data to Processor                      \n  output [6:0]       reg_wr_addr,         // 7 bit reg address to Processor                   \n  output             reg_en,              // 1 bit  Read enable to Processor                                    \n  output             reg_wr_en,           // 1 bit  Write enable to Processor \n  output             dmi_hard_reset  \n);\n\n\n  \n\n\n  //Wire Declaration\n  wire                     rd_en;\n  wire                     wr_en;\n  wire                     dmireset;\n\n \n  //jtag_tap instantiation\n rvjtag_tap i_jtag_tap(\n   .trst(trst_n),                      // dedicated JTAG TRST (active low) pad signal or asynchronous active low power on reset\n   .tck(tck),                          // dedicated JTAG TCK pad signal\n   .tms(tms),                          // dedicated JTAG TMS pad signal\n   .tdi(tdi),                          // dedicated JTAG TDI pad signal\n   .tdo(tdo),                          // dedicated JTAG TDO pad signal\n   .tdoEnable(tdoEnable),              // enable for TDO pad\n   .wr_data(reg_wr_data),              // 32 bit Write data\n   .wr_addr(reg_wr_addr),              // 7 bit Write address\n   .rd_en(rd_en),                      // 1 bit  read enable\n   .wr_en(wr_en),                      // 1 bit  Write enable\n   .rd_data(rd_data),                  // 32 bit Read data\n   .rd_status(2'b0),\n   .idle(3'h0),                         // no need to wait to sample data\n   .dmi_stat(2'b0),                     // no need to wait or error possible\n   .version(4'h1),                      // debug spec 0.13 compliant\n   .jtag_id(jtag_id),\n   .dmi_hard_reset(dmi_hard_reset),\n   .dmi_reset(dmireset)\n);\n\n\n  // dmi_jtag_to_core_sync instantiation\n  dmi_jtag_to_core_sync i_dmi_jtag_to_core_sync(\n    .wr_en(wr_en),                          // 1 bit  Write enable\n    .rd_en(rd_en),                          // 1 bit  Read enable\n\n    .rst_n(core_rst_n),\n    .clk(core_clk),\n    .reg_en(reg_en),                          // 1 bit  Write interface bit\n    .reg_wr_en(reg_wr_en)                          // 1 bit  Write enable\n  );\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n// $Id$\n//\n// Function: Top level VeeR core file to control the debug mode\n// Comments: Responsible to put the rest of the core in quiesce mode,\n//           Send the commands/address. sends WrData and Recieve read Data.\n//           And then Resume the core to do the normal mode\n// Author  :\n//********************************************************************************\nmodule el2_dbg\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n   // outputs to the core for command and data interface\n   output logic [31:0]                 dbg_cmd_addr,\n   output logic [31:0]                 dbg_cmd_wrdata,\n   output logic                        dbg_cmd_valid,\n   output logic                        dbg_cmd_write,             // 1: write command, 0: read_command\n   output logic [1:0]                  dbg_cmd_type,              // 0:gpr 1:csr 2: memory\n   output logic [1:0]                  dbg_cmd_size,              // size of the abstract mem access debug command\n   output logic                        dbg_core_rst_l,            // core reset from dm\n\n   // inputs back from the core/dec\n   input logic [31:0]                  core_dbg_rddata,\n   input logic                         core_dbg_cmd_done,         // This will be treated like a valid signal\n   input logic                         core_dbg_cmd_fail,         // Exception during command run\n\n   // Signals to dma to get a bubble\n   output logic                        dbg_dma_bubble,            // Debug needs a bubble to send a valid\n   input  logic                        dma_dbg_ready,             // DMA is ready to accept debug request\n\n   // interface with the rest of the core to halt/resume handshaking\n   output logic                        dbg_halt_req,              // This is a pulse\n   output logic                        dbg_resume_req,            // Debug sends a resume requests. Pulse\n   input  logic                        dec_tlu_debug_mode,        // Core is in debug mode\n   input  logic                        dec_tlu_dbg_halted,        // The core has finished the queiscing sequence. Core is halted now\n   input  logic                        dec_tlu_mpc_halted_only,   // Only halted due to MPC\n   input  logic                        dec_tlu_resume_ack,        // core sends back an ack for the resume (pulse)\n\n   // inputs from the JTAG\n   input logic                         dmi_reg_en,                // read or write\n   input logic [6:0]                   dmi_reg_addr,              // address of DM register\n   input logic                         dmi_reg_wr_en,             // write instruction\n   input logic [31:0]                  dmi_reg_wdata,             // write data\n\n   // output\n   output logic [31:0]                 dmi_reg_rdata,             // read data\n\n   // AXI Write Channels\n   output logic                        sb_axi_awvalid,\n   input  logic                        sb_axi_awready,\n   output logic [pt.SB_BUS_TAG-1:0]    sb_axi_awid,\n   output logic [31:0]                 sb_axi_awaddr,\n   output logic [3:0]                  sb_axi_awregion,\n   output logic [7:0]                  sb_axi_awlen,\n   output logic [2:0]                  sb_axi_awsize,\n   output logic [1:0]                  sb_axi_awburst,\n   output logic                        sb_axi_awlock,\n   output logic [3:0]                  sb_axi_awcache,\n   output logic [2:0]                  sb_axi_awprot,\n   output logic [3:0]                  sb_axi_awqos,\n\n   output logic                        sb_axi_wvalid,\n   input  logic                        sb_axi_wready,\n   output logic [63:0]                 sb_axi_wdata,\n   output logic [7:0]                  sb_axi_wstrb,\n   output logic                        sb_axi_wlast,\n\n   input  logic                        sb_axi_bvalid,\n   output logic                        sb_axi_bready,\n   input  logic [1:0]                  sb_axi_bresp,\n\n   // AXI Read Channels\n   output logic                        sb_axi_arvalid,\n   input  logic                        sb_axi_arready,\n   output logic [pt.SB_BUS_TAG-1:0]    sb_axi_arid,\n   output logic [31:0]                 sb_axi_araddr,\n   output logic [3:0]                  sb_axi_arregion,\n   output logic [7:0]                  sb_axi_arlen,\n   output logic [2:0]                  sb_axi_arsize,\n   output logic [1:0]                  sb_axi_arburst,\n   output logic                        sb_axi_arlock,\n   output logic [3:0]                  sb_axi_arcache,\n   output logic [2:0]                  sb_axi_arprot,\n   output logic [3:0]                  sb_axi_arqos,\n\n   input  logic                        sb_axi_rvalid,\n   output logic                        sb_axi_rready,\n   input  logic [63:0]                 sb_axi_rdata,\n   input  logic [1:0]                  sb_axi_rresp,\n\n   input logic                         dbg_bus_clk_en,\n\n   // general inputs\n   input logic                         clk,\n   input logic                         free_clk,\n   input logic                         rst_l,        // This includes both top rst and debug rst\n   input logic                         dbg_rst_l,\n   input logic                         clk_override,\n   input logic                         scan_mode\n);\n\n\n   typedef enum logic [3:0] {IDLE=4'h0, HALTING=4'h1, HALTED=4'h2, CORE_CMD_START=4'h3, CORE_CMD_WAIT=4'h4, SB_CMD_START=4'h5, SB_CMD_SEND=4'h6, SB_CMD_RESP=4'h7, CMD_DONE=4'h8, RESUMING=4'h9} state_t;\n   typedef enum logic [3:0] {SBIDLE=4'h0, WAIT_RD=4'h1, WAIT_WR=4'h2, CMD_RD=4'h3, CMD_WR=4'h4, CMD_WR_ADDR=4'h5, CMD_WR_DATA=4'h6, RSP_RD=4'h7, RSP_WR=4'h8, DONE=4'h9} sb_state_t;\n\n   state_t       dbg_state;\n   state_t       dbg_nxtstate;\n   logic         dbg_state_en;\n   // these are the registers that the debug module implements\n   logic [31:0]  dmstatus_reg;        // [26:24]-dmerr, [17:16]-resume ack, [9:8]-halted, [3:0]-version\n   logic [31:0]  dmcontrol_reg;       // dmcontrol register has only 6 bits implemented. 31: haltreq, 30: resumereq, 29: haltreset, 28: ackhavereset, 1: ndmreset, 0: dmactive.\n   logic [31:0]  command_reg;\n   logic [31:0]  abstractcs_reg;      // bits implemted are [12] - busy and [10:8]= command error\n   logic [31:0]  haltsum0_reg;\n   logic [31:0]  data0_reg;\n   logic [31:0]  data1_reg;\n\n   // data 0\n   logic [31:0]  data0_din;\n   logic         data0_reg_wren, data0_reg_wren0, data0_reg_wren1, data0_reg_wren2;\n   // data 1\n   logic [31:0]  data1_din;\n   logic         data1_reg_wren, data1_reg_wren0, data1_reg_wren1;\n   // abstractcs\n   logic         abstractcs_busy_wren;\n   logic         abstractcs_busy_din;\n   logic [2:0]   abstractcs_error_din;\n   logic         abstractcs_error_sel0, abstractcs_error_sel1, abstractcs_error_sel2, abstractcs_error_sel3, abstractcs_error_sel4, abstractcs_error_sel5, abstractcs_error_sel6;\n   logic         dbg_sb_bus_error;\n   // abstractauto\n   logic         abstractauto_reg_wren;\n   logic [1:0]   abstractauto_reg;\n\n   // dmstatus\n   logic         dmstatus_resumeack_wren;\n   logic         dmstatus_resumeack_din;\n   logic         dmstatus_haveresetn_wren;\n   logic         dmstatus_resumeack;\n   logic         dmstatus_unavail;\n   logic         dmstatus_running;\n   logic         dmstatus_halted;\n   logic         dmstatus_havereset, dmstatus_haveresetn;\n\n   // dmcontrol\n   logic         resumereq;\n   logic         dmcontrol_wren, dmcontrol_wren_Q;\n   // command\n   logic         execute_command_ns, execute_command;\n   logic         command_wren, command_regno_wren;\n   logic         command_transfer_din;\n   logic         command_postexec_din;\n   logic [31:0]  command_din;\n   logic [3:0]   dbg_cmd_addr_incr;\n   logic [31:0]  dbg_cmd_curr_addr;\n   logic [31:0]  dbg_cmd_next_addr;\n\n   // needed to send the read data back for dmi reads\n   logic  [31:0] dmi_reg_rdata_din;\n\n   sb_state_t    sb_state;\n   sb_state_t    sb_nxtstate;\n   logic         sb_state_en;\n\n   //System bus section\n   logic              sbcs_wren;\n   logic              sbcs_sbbusy_wren;\n   logic              sbcs_sbbusy_din;\n   logic              sbcs_sbbusyerror_wren;\n   logic              sbcs_sbbusyerror_din;\n\n   logic              sbcs_sberror_wren;\n   logic [2:0]        sbcs_sberror_din;\n   logic              sbcs_unaligned;\n   logic              sbcs_illegal_size;\n   logic [19:15]      sbcs_reg_int;\n\n   // data\n   logic              sbdata0_reg_wren0;\n   logic              sbdata0_reg_wren1;\n   logic              sbdata0_reg_wren;\n   logic [31:0]       sbdata0_din;\n\n   logic              sbdata1_reg_wren0;\n   logic              sbdata1_reg_wren1;\n   logic              sbdata1_reg_wren;\n   logic [31:0]       sbdata1_din;\n\n   logic              sbaddress0_reg_wren0;\n   logic              sbaddress0_reg_wren1;\n   logic              sbaddress0_reg_wren;\n   logic [31:0]       sbaddress0_reg_din;\n   logic [3:0]        sbaddress0_incr;\n   logic              sbreadonaddr_access;\n   logic              sbreadondata_access;\n   logic              sbdata0wr_access;\n\n   logic              sb_abmem_cmd_done_in, sb_abmem_data_done_in;\n   logic              sb_abmem_cmd_done_en, sb_abmem_data_done_en;\n   logic              sb_abmem_cmd_done, sb_abmem_data_done;\n   logic [31:0]       abmem_addr;\n   logic              abmem_addr_in_dccm_region, abmem_addr_in_iccm_region, abmem_addr_in_pic_region;\n   logic              abmem_addr_core_local;\n   logic              abmem_addr_external;\n\n   logic              sb_cmd_pending, sb_abmem_cmd_pending;\n   logic              sb_abmem_cmd_write;\n   logic [2:0]        sb_abmem_cmd_size;\n   logic [31:0]       sb_abmem_cmd_addr;\n   logic [31:0]       sb_abmem_cmd_wdata;\n\n   logic [2:0]        sb_cmd_size;\n   logic [31:0]       sb_cmd_addr;\n   logic [63:0]       sb_cmd_wdata;\n\n   logic              sb_bus_cmd_read, sb_bus_cmd_write_addr, sb_bus_cmd_write_data;\n   logic              sb_bus_rsp_read, sb_bus_rsp_write;\n   logic              sb_bus_rsp_error;\n   logic [63:0]       sb_bus_rdata;\n\n   //registers\n   logic [31:0]       sbcs_reg;\n   logic [31:0]       sbaddress0_reg;\n   logic [31:0]       sbdata0_reg;\n   logic [31:0]       sbdata1_reg;\n\n   logic              sb_abmem_cmd_arvalid, sb_abmem_cmd_awvalid, sb_abmem_cmd_wvalid;\n   logic              sb_abmem_read_pend;\n   logic              sb_cmd_awvalid, sb_cmd_wvalid, sb_cmd_arvalid;\n   logic              sb_read_pend;\n   logic [31:0]       sb_axi_addr;\n   logic [63:0]       sb_axi_wrdata;\n   logic [2:0]        sb_axi_size;\n\n   logic              dbg_dm_rst_l;\n   logic              rst_l_sync;\n\n   //clken\n   logic              dbg_free_clken;\n   logic              dbg_free_clk;\n\n   logic              sb_free_clken;\n   logic              sb_free_clk;\n\n   // clocking\n   // used for the abstract commands.\n   assign dbg_free_clken  = dmi_reg_en | execute_command | (dbg_state != IDLE) | dbg_state_en | dec_tlu_dbg_halted | dec_tlu_mpc_halted_only | dec_tlu_debug_mode | dbg_halt_req | clk_override;\n\n   // used for the system bus\n   assign sb_free_clken = dmi_reg_en | execute_command | sb_state_en | (sb_state != SBIDLE) | clk_override;\n\n   rvoclkhdr dbg_free_cgc    (.en(dbg_free_clken), .l1clk(dbg_free_clk), .*);\n   rvoclkhdr sb_free_cgc     (.en(sb_free_clken), .l1clk(sb_free_clk), .*);\n\n   // end clocking section\n\n   // Reset logic\n   assign dbg_dm_rst_l = dbg_rst_l & (dmcontrol_reg[0] | scan_mode);\n   assign dbg_core_rst_l = ~dmcontrol_reg[1] | scan_mode;\n\n   // synchronize the rst\n   rvsyncss #(1) rstl_syncff (.din(rst_l), .dout(rst_l_sync), .clk(free_clk), .rst_l(dbg_rst_l));\n\n   // system bus register\n   // sbcs[31:29], sbcs - [22]:sbbusyerror, [21]: sbbusy, [20]:sbreadonaddr, [19:17]:sbaccess, [16]:sbautoincrement, [15]:sbreadondata, [14:12]:sberror, sbsize=32, 128=0, 64/32/16/8 are legal\n   assign        sbcs_reg[31:29] = 3'b1;\n   assign        sbcs_reg[28:23] = '0;\n   assign        sbcs_reg[19:15] = {sbcs_reg_int[19], ~sbcs_reg_int[18], sbcs_reg_int[17:15]};\n   assign        sbcs_reg[11:5]  = 7'h20;\n   assign        sbcs_reg[4:0]   = 5'b01111;\n   assign        sbcs_wren = (dmi_reg_addr ==  7'h38) & dmi_reg_en & dmi_reg_wr_en & (sb_state == SBIDLE);\n   assign        sbcs_sbbusyerror_wren = (sbcs_wren & dmi_reg_wdata[22]) |\n                                         (sbcs_reg[21] & dmi_reg_en & ((dmi_reg_wr_en & (dmi_reg_addr == 7'h39)) | (dmi_reg_addr == 7'h3c) | (dmi_reg_addr == 7'h3d)));\n   assign        sbcs_sbbusyerror_din = ~(sbcs_wren & dmi_reg_wdata[22]);   // Clear when writing one\n\n   rvdffs #(1) sbcs_sbbusyerror_reg  (.din(sbcs_sbbusyerror_din),  .dout(sbcs_reg[22]),    .en(sbcs_sbbusyerror_wren), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n   rvdffs #(1) sbcs_sbbusy_reg       (.din(sbcs_sbbusy_din),       .dout(sbcs_reg[21]),    .en(sbcs_sbbusy_wren),      .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n   rvdffs #(1) sbcs_sbreadonaddr_reg (.din(dmi_reg_wdata[20]),     .dout(sbcs_reg[20]),    .en(sbcs_wren),             .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n   rvdffs #(5) sbcs_misc_reg         (.din({dmi_reg_wdata[19],~dmi_reg_wdata[18],dmi_reg_wdata[17:15]}),\n                                      .dout(sbcs_reg_int[19:15]), .en(sbcs_wren),             .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n   rvdffs #(3) sbcs_error_reg        (.din(sbcs_sberror_din[2:0]), .dout(sbcs_reg[14:12]), .en(sbcs_sberror_wren),     .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n\n   assign sbcs_unaligned =    ((sbcs_reg[19:17] == 3'b001) &  sbaddress0_reg[0]) |\n                              ((sbcs_reg[19:17] == 3'b010) &  (|sbaddress0_reg[1:0])) |\n                              ((sbcs_reg[19:17] == 3'b011) &  (|sbaddress0_reg[2:0]));\n\n   assign sbcs_illegal_size = sbcs_reg[19];    // Anything bigger than 64 bits is illegal\n\n   assign sbaddress0_incr[3:0] = ({4{(sbcs_reg[19:17] == 3'h0)}} &  4'b0001) |\n                                 ({4{(sbcs_reg[19:17] == 3'h1)}} &  4'b0010) |\n                                 ({4{(sbcs_reg[19:17] == 3'h2)}} &  4'b0100) |\n                                 ({4{(sbcs_reg[19:17] == 3'h3)}} &  4'b1000);\n\n   // sbdata\n   assign        sbdata0_reg_wren0   = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h3c);   // write data only when single read is 0\n   assign        sbdata0_reg_wren1   = (sb_state == RSP_RD) & sb_state_en & ~sbcs_sberror_wren;\n   assign        sbdata0_reg_wren    = sbdata0_reg_wren0 | sbdata0_reg_wren1;\n\n   assign        sbdata1_reg_wren0   = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h3d);   // write data only when single read is 0;\n   assign        sbdata1_reg_wren1   = (sb_state == RSP_RD) & sb_state_en & ~sbcs_sberror_wren;\n   assign        sbdata1_reg_wren    = sbdata1_reg_wren0 | sbdata1_reg_wren1;\n\n   assign        sbdata0_din[31:0]   = ({32{sbdata0_reg_wren0}} & dmi_reg_wdata[31:0]) |\n                                       ({32{sbdata0_reg_wren1}} & sb_bus_rdata[31:0]);\n   assign        sbdata1_din[31:0]   = ({32{sbdata1_reg_wren0}} & dmi_reg_wdata[31:0]) |\n                                       ({32{sbdata1_reg_wren1}} & sb_bus_rdata[63:32]);\n\n   rvdffe #(32)    dbg_sbdata0_reg    (.*, .din(sbdata0_din[31:0]), .dout(sbdata0_reg[31:0]), .en(sbdata0_reg_wren), .rst_l(dbg_dm_rst_l));\n   rvdffe #(32)    dbg_sbdata1_reg    (.*, .din(sbdata1_din[31:0]), .dout(sbdata1_reg[31:0]), .en(sbdata1_reg_wren), .rst_l(dbg_dm_rst_l));\n\n    // sbaddress\n   assign        sbaddress0_reg_wren0   = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h39);\n   assign        sbaddress0_reg_wren    = sbaddress0_reg_wren0 | sbaddress0_reg_wren1;\n   assign        sbaddress0_reg_din[31:0]= ({32{sbaddress0_reg_wren0}} & dmi_reg_wdata[31:0]) |\n                                           ({32{sbaddress0_reg_wren1}} & (sbaddress0_reg[31:0] + {28'b0,sbaddress0_incr[3:0]}));\n   rvdffe #(32)    dbg_sbaddress0_reg    (.*, .din(sbaddress0_reg_din[31:0]), .dout(sbaddress0_reg[31:0]), .en(sbaddress0_reg_wren), .rst_l(dbg_dm_rst_l));\n\n   assign sbreadonaddr_access = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h39) & sbcs_reg[20];   // if readonaddr is set the next command will start upon writing of addr0\n   assign sbreadondata_access = dmi_reg_en & ~dmi_reg_wr_en & (dmi_reg_addr == 7'h3c) & sbcs_reg[15];  // if readondata is set the next command will start upon reading of data0\n   assign sbdata0wr_access  = dmi_reg_en &  dmi_reg_wr_en & (dmi_reg_addr == 7'h3c);                   // write to sbdata0 will start write command to system bus\n\n   // memory mapped registers\n   // dmcontrol register has only 5 bits implemented. 31: haltreq, 30: resumereq, 28: ackhavereset, 1: ndmreset, 0: dmactive.\n   // rest all the bits are zeroed out\n   // dmactive flop is reset based on core rst_l, all other flops use dm_rst_l\n   assign dmcontrol_wren      = (dmi_reg_addr ==  7'h10) & dmi_reg_en & dmi_reg_wr_en;\n   assign dmcontrol_reg[29]   = '0;\n   assign dmcontrol_reg[27:2] = '0;\n   assign resumereq           = dmcontrol_reg[30] & ~dmcontrol_reg[31] & dmcontrol_wren_Q;\n   rvdffs #(4) dmcontrolff (.din({dmi_reg_wdata[31:30],dmi_reg_wdata[28],dmi_reg_wdata[1]}), .dout({dmcontrol_reg[31:30], dmcontrol_reg[28], dmcontrol_reg[1]}), .en(dmcontrol_wren), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n   rvdffs #(1) dmcontrol_dmactive_ff (.din(dmi_reg_wdata[0]), .dout(dmcontrol_reg[0]), .en(dmcontrol_wren), .rst_l(dbg_rst_l), .clk(dbg_free_clk));\n   rvdff  #(1) dmcontrol_wrenff(.din(dmcontrol_wren), .dout(dmcontrol_wren_Q), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n\n   // dmstatus register bits that are implemented\n   // [19:18]-havereset,[17:16]-resume ack, [9:8]-halted, [3:0]-version\n   // rest all the bits are zeroed out\n   //assign dmstatus_wren       = (dmi_reg_addr[31:0] ==  32'h11) & dmi_reg_en;\n   assign dmstatus_reg[31:20] = '0;\n   assign dmstatus_reg[19:18] = {2{dmstatus_havereset}};\n   assign dmstatus_reg[15:14] = '0;\n   assign dmstatus_reg[7]     = '1;\n   assign dmstatus_reg[6:4]   = '0;\n   assign dmstatus_reg[17:16] = {2{dmstatus_resumeack}};\n   assign dmstatus_reg[13:12] = {2{dmstatus_unavail}};\n   assign dmstatus_reg[11:10] = {2{dmstatus_running}};\n   assign dmstatus_reg[9:8]   = {2{dmstatus_halted}};\n   assign dmstatus_reg[3:0]   = 4'h2;\n\n   assign dmstatus_resumeack_wren = ((dbg_state == RESUMING) & dec_tlu_resume_ack) | (dmstatus_resumeack & resumereq & dmstatus_halted);\n   assign dmstatus_resumeack_din  = (dbg_state == RESUMING) & dec_tlu_resume_ack;\n\n   assign dmstatus_haveresetn_wren  = (dmi_reg_addr == 7'h10) & dmi_reg_wdata[28] & dmi_reg_en & dmi_reg_wr_en & dmcontrol_reg[0];   // clear the havereset\n   assign dmstatus_havereset        = ~dmstatus_haveresetn;\n\n   assign dmstatus_unavail = dmcontrol_reg[1] | ~rst_l_sync;\n   assign dmstatus_running = ~(dmstatus_unavail | dmstatus_halted);\n\n   rvdffs  #(1) dmstatus_resumeack_reg  (.din(dmstatus_resumeack_din), .dout(dmstatus_resumeack), .en(dmstatus_resumeack_wren), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n   rvdff   #(1) dmstatus_halted_reg     (.din(dec_tlu_dbg_halted & ~dec_tlu_mpc_halted_only),     .dout(dmstatus_halted), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n   rvdffs  #(1) dmstatus_haveresetn_reg (.din(1'b1), .dout(dmstatus_haveresetn), .en(dmstatus_haveresetn_wren), .rst_l(rst_l), .clk(dbg_free_clk));\n\n   // haltsum0 register\n   assign haltsum0_reg[31:1] = '0;\n   assign haltsum0_reg[0]    = dmstatus_halted;\n\n   // abstractcs register\n   // bits implemted a"}
{"text": "re [12] - busy and [10:8]= command error\n   assign        abstractcs_reg[31:13] = '0;\n   assign        abstractcs_reg[11]    = '0;\n   assign        abstractcs_reg[7:4]   = '0;\n   assign        abstractcs_reg[3:0]   = 4'h2;    // One data register\n\n   assign        abstractcs_error_sel0 = abstractcs_reg[12] & ~(|abstractcs_reg[10:8]) & dmi_reg_en & ((dmi_reg_wr_en & ((dmi_reg_addr == 7'h16) | (dmi_reg_addr == 7'h17)) | (dmi_reg_addr == 7'h18)) |\n                                                                                                       (dmi_reg_addr == 7'h4) | (dmi_reg_addr == 7'h5));\n   assign        abstractcs_error_sel1 = execute_command & ~(|abstractcs_reg[10:8]) &\n                                         ((~((command_reg[31:24] == 8'b0) | (command_reg[31:24] == 8'h2)))                      |   // Illegal command\n                                          (((command_reg[22:20] == 3'b011) | (command_reg[22])) & (command_reg[31:24] == 8'h2)) |   // Illegal abstract memory size (can't be DW or higher)\n                                          ((command_reg[22:20] != 3'b010) & ((command_reg[31:24] == 8'h0) & command_reg[17]))   |   // Illegal abstract reg size\n                                          ((command_reg[31:24] == 8'h0) & command_reg[18]));                                          //postexec for abstract register access\n   assign        abstractcs_error_sel2 = ((core_dbg_cmd_done & core_dbg_cmd_fail) |                   // exception from core\n                                          (execute_command & (command_reg[31:24] == 8'h0) &           // unimplemented regs\n                                                (((command_reg[15:12] == 4'h1) & (command_reg[11:5] != 0)) | (command_reg[15:13] != 0)))) & ~(|abstractcs_reg[10:8]);\n   assign        abstractcs_error_sel3 = execute_command & (dbg_state != HALTED) & ~(|abstractcs_reg[10:8]);\n   assign        abstractcs_error_sel4 = dbg_sb_bus_error & dbg_bus_clk_en & ~(|abstractcs_reg[10:8]);// sb bus error for abstract memory command\n   assign        abstractcs_error_sel5 = execute_command & (command_reg[31:24] == 8'h2) & ~(|abstractcs_reg[10:8]) &\n                                         (((command_reg[22:20] == 3'b001) & data1_reg[0]) | ((command_reg[22:20] == 3'b010) & (|data1_reg[1:0])));  //Unaligned address for abstract memory\n   assign        abstractcs_error_sel6 = (dmi_reg_addr ==  7'h16) & dmi_reg_en & dmi_reg_wr_en;\n\n   assign        abstractcs_error_din[2:0]  = abstractcs_error_sel0 ? 3'b001 :                  // writing command or abstractcs while a command was executing. Or accessing data0\n                                                 abstractcs_error_sel1 ? 3'b010 :               // writing a illegal command type to cmd field of command\n                                                    abstractcs_error_sel2 ? 3'b011 :            // exception while running command\n                                                       abstractcs_error_sel3 ? 3'b100 :         // writing a comnand when not in the halted state\n                                                          abstractcs_error_sel4 ? 3'b101 :      // Bus error\n                                                             abstractcs_error_sel5 ? 3'b111 :   // unaligned or illegal size abstract memory command\n                                                                abstractcs_error_sel6 ? (~dmi_reg_wdata[10:8] & abstractcs_reg[10:8]) :   //W1C\n                                                                                        abstractcs_reg[10:8];                             //hold\n\n   rvdffs #(1) dmabstractcs_busy_reg  (.din(abstractcs_busy_din), .dout(abstractcs_reg[12]), .en(abstractcs_busy_wren), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n   rvdff  #(3) dmabstractcs_error_reg (.din(abstractcs_error_din[2:0]), .dout(abstractcs_reg[10:8]), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n\n    // abstract auto reg\n   assign abstractauto_reg_wren  = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h18) & ~abstractcs_reg[12];\n   rvdffs #(2) dbg_abstractauto_reg (.*, .din(dmi_reg_wdata[1:0]), .dout(abstractauto_reg[1:0]), .en(abstractauto_reg_wren), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n\n   // command register - implemented all the bits in this register\n   // command[16] = 1: write, 0: read\n   assign execute_command_ns = command_wren |\n                               (dmi_reg_en & ~abstractcs_reg[12] & (((dmi_reg_addr == 7'h4) & abstractauto_reg[0]) | ((dmi_reg_addr == 7'h5) & abstractauto_reg[1])));\n   assign command_wren = (dmi_reg_addr ==  7'h17) & dmi_reg_en & dmi_reg_wr_en;\n   assign command_regno_wren = command_wren | ((command_reg[31:24] == 8'h0) & command_reg[19] & (dbg_state == CMD_DONE) & ~(|abstractcs_reg[10:8]));  // aarpostincrement\n   assign command_postexec_din = (dmi_reg_wdata[31:24] == 8'h0) & dmi_reg_wdata[18];\n   assign command_transfer_din = (dmi_reg_wdata[31:24] == 8'h0) & dmi_reg_wdata[17];\n   assign command_din[31:16] = {dmi_reg_wdata[31:24],1'b0,dmi_reg_wdata[22:19],command_postexec_din,command_transfer_din, dmi_reg_wdata[16]};\n   assign command_din[15:0] =  command_wren ? dmi_reg_wdata[15:0] : dbg_cmd_next_addr[15:0];\n   rvdff  #(1)  execute_commandff   (.*, .din(execute_command_ns), .dout(execute_command), .clk(dbg_free_clk), .rst_l(dbg_dm_rst_l));\n   rvdffe #(16) dmcommand_reg       (.*, .din(command_din[31:16]), .dout(command_reg[31:16]), .en(command_wren), .rst_l(dbg_dm_rst_l));\n   rvdffe #(16) dmcommand_regno_reg (.*, .din(command_din[15:0]),  .dout(command_reg[15:0]),  .en(command_regno_wren), .rst_l(dbg_dm_rst_l));\n\n  // data0 reg\n   assign data0_reg_wren0   = (dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h4) & (dbg_state == HALTED) & ~abstractcs_reg[12]);\n   assign data0_reg_wren1   = core_dbg_cmd_done & (dbg_state == CORE_CMD_WAIT) & ~command_reg[16];\n   assign data0_reg_wren    = data0_reg_wren0 | data0_reg_wren1 | data0_reg_wren2;\n\n   assign data0_din[31:0]   = ({32{data0_reg_wren0}} & dmi_reg_wdata[31:0])   |\n                              ({32{data0_reg_wren1}} & core_dbg_rddata[31:0]) |\n                              ({32{data0_reg_wren2}} & sb_bus_rdata[31:0]);\n\n   rvdffe #(32) dbg_data0_reg (.*, .din(data0_din[31:0]), .dout(data0_reg[31:0]), .en(data0_reg_wren), .rst_l(dbg_dm_rst_l));\n\n   // data 1\n   assign data1_reg_wren0   = (dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h5) & (dbg_state == HALTED) & ~abstractcs_reg[12]);\n   assign data1_reg_wren1   = (dbg_state == CMD_DONE) & (command_reg[31:24] == 8'h2) & command_reg[19] & ~(|abstractcs_reg[10:8]);   // aampostincrement\n   assign data1_reg_wren    = data1_reg_wren0 | data1_reg_wren1;\n\n   assign data1_din[31:0]   = ({32{data1_reg_wren0}} & dmi_reg_wdata[31:0]) |\n                              ({32{data1_reg_wren1}} & dbg_cmd_next_addr[31:0]);\n\n   rvdffe #(32)    dbg_data1_reg    (.*, .din(data1_din[31:0]), .dout(data1_reg[31:0]), .en(data1_reg_wren), .rst_l(dbg_dm_rst_l));\n\n   rvdffs #(1) sb_abmem_cmd_doneff  (.din(sb_abmem_cmd_done_in),  .dout(sb_abmem_cmd_done),  .en(sb_abmem_cmd_done_en),  .clk(dbg_free_clk), .rst_l(dbg_dm_rst_l), .*);\n   rvdffs #(1) sb_abmem_data_doneff (.din(sb_abmem_data_done_in), .dout(sb_abmem_data_done), .en(sb_abmem_data_done_en), .clk(dbg_free_clk), .rst_l(dbg_dm_rst_l), .*);\n\n   // FSM to control the debug mode entry, command send/recieve, and Resume flow.\n   always_comb begin\n      dbg_nxtstate            = IDLE;\n      dbg_state_en            = 1'b0;\n      abstractcs_busy_wren    = 1'b0;\n      abstractcs_busy_din     = 1'b0;\n      dbg_halt_req            = dmcontrol_wren_Q & dmcontrol_reg[31];      // single pulse output to the core. Need to drive every time this register is written since core might be halted due to MPC\n      dbg_resume_req          = 1'b0;                                      // single pulse output to the core\n      dbg_sb_bus_error        = 1'b0;\n      data0_reg_wren2         = 1'b0;\n      sb_abmem_cmd_done_in    = 1'b0;\n      sb_abmem_data_done_in   = 1'b0;\n      sb_abmem_cmd_done_en    = 1'b0;\n      sb_abmem_data_done_en   = 1'b0;\n\n       case (dbg_state)\n            IDLE: begin\n                     dbg_nxtstate         = (dmstatus_reg[9] | dec_tlu_mpc_halted_only) ? HALTED : HALTING;         // initiate the halt command to the core\n                     dbg_state_en         = dmcontrol_reg[31] | dmstatus_reg[9] | dec_tlu_mpc_halted_only;      // when the jtag writes the halt bit in the DM register, OR when the status indicates H\n                     dbg_halt_req         = dmcontrol_reg[31];               // only when jtag has written the halt_req bit in the control. Removed debug mode qualification during MPC changes\n            end\n            HALTING : begin\n                     dbg_nxtstate         = HALTED;                                 // Goto HALTED once the core sends an ACK\n                     dbg_state_en         = dmstatus_reg[9] | dec_tlu_mpc_halted_only;     // core indicates halted\n            end\n            HALTED: begin\n                     // wait for halted to go away before send to resume. Else start of new command\n                     dbg_nxtstate         = dmstatus_reg[9] ? (resumereq ? RESUMING : (((command_reg[31:24] == 8'h2) & abmem_addr_external) ? SB_CMD_START : CORE_CMD_START)) :\n                                                                                    (dmcontrol_reg[31] ? HALTING : IDLE);       // This is MPC halted case\n                     dbg_state_en         = (dmstatus_reg[9] & resumereq) | execute_command | ~(dmstatus_reg[9] | dec_tlu_mpc_halted_only);\n                     abstractcs_busy_wren = dbg_state_en & ((dbg_nxtstate == CORE_CMD_START) | (dbg_nxtstate == SB_CMD_START));                 // write busy when a new command was written by jtag\n                     abstractcs_busy_din  = 1'b1;\n                     dbg_resume_req       = dbg_state_en & (dbg_nxtstate == RESUMING);                       // single cycle pulse to core if resuming\n            end\n            CORE_CMD_START: begin\n                     // Don't execute the command if cmderror or transfer=0 for abstract register access\n                     dbg_nxtstate         = ((|abstractcs_reg[10:8]) | ((command_reg[31:24] == 8'h0) & ~command_reg[17])) ? CMD_DONE : CORE_CMD_WAIT;     // new command sent to the core\n                     dbg_state_en         = dbg_cmd_valid | (|abstractcs_reg[10:8]) | ((command_reg[31:24] == 8'h0) & ~command_reg[17]);\n            end\n            CORE_CMD_WAIT: begin\n                     dbg_nxtstate         = CMD_DONE;\n                     dbg_state_en         = core_dbg_cmd_done;                   // go to done state for one cycle after completing current command\n            end\n            SB_CMD_START: begin\n                     dbg_nxtstate         = (|abstractcs_reg[10:8]) ? CMD_DONE : SB_CMD_SEND;\n                     dbg_state_en         = (dbg_bus_clk_en & ~sb_cmd_pending) | (|abstractcs_reg[10:8]);\n            end\n            SB_CMD_SEND: begin\n                     sb_abmem_cmd_done_in = 1'b1;\n                     sb_abmem_data_done_in= 1'b1;\n                     sb_abmem_cmd_done_en = (sb_bus_cmd_read | sb_bus_cmd_write_addr) & dbg_bus_clk_en;\n                     sb_abmem_data_done_en= (sb_bus_cmd_read | sb_bus_cmd_write_data) & dbg_bus_clk_en;\n                     dbg_nxtstate         = SB_CMD_RESP;\n                     dbg_state_en         = (sb_abmem_cmd_done | sb_abmem_cmd_done_en) & (sb_abmem_data_done | sb_abmem_data_done_en) & dbg_bus_clk_en;\n            end\n            SB_CMD_RESP: begin\n                     dbg_nxtstate         = CMD_DONE;\n                     dbg_state_en         = (sb_bus_rsp_read | sb_bus_rsp_write) & dbg_bus_clk_en;\n                     dbg_sb_bus_error     = (sb_bus_rsp_read | sb_bus_rsp_write) & sb_bus_rsp_error & dbg_bus_clk_en;\n                     data0_reg_wren2      = dbg_state_en & ~sb_abmem_cmd_write & ~dbg_sb_bus_error;\n            end\n            CMD_DONE: begin\n                     dbg_nxtstate         = HALTED;\n                     dbg_state_en         = 1'b1;\n                     abstractcs_busy_wren = dbg_state_en;                    // remove the busy bit from the abstracts ( bit 12 )\n                     abstractcs_busy_din  = 1'b0;\n                     sb_abmem_cmd_done_in = 1'b0;\n                     sb_abmem_data_done_in= 1'b0;\n                     sb_abmem_cmd_done_en = 1'b1;\n                     sb_abmem_data_done_en= 1'b1;\n            end\n            RESUMING : begin\n                     dbg_nxtstate            = IDLE;\n                     dbg_state_en            = dmstatus_reg[17];             // resume ack has been updated in the dmstatus register\n           end\n           default : begin\n                     dbg_nxtstate            = IDLE;\n                     dbg_state_en            = 1'b0;\n                     abstractcs_busy_wren    = 1'b0;\n                     abstractcs_busy_din     = 1'b0;\n                     dbg_halt_req            = 1'b0;         // single pulse output to the core\n                     dbg_resume_req          = 1'b0;         // single pulse output to the core\n                     dbg_sb_bus_error        = 1'b0;\n                     data0_reg_wren2         = 1'b0;\n                     sb_abmem_cmd_done_in    = 1'b0;\n                     sb_abmem_data_done_in   = 1'b0;\n                     sb_abmem_cmd_done_en    = 1'b0;\n                     sb_abmem_data_done_en   = 1'b0;\n          end\n         endcase\n   end // always_comb begin\n\n   assign dmi_reg_rdata_din[31:0] = ({32{dmi_reg_addr == 7'h4}}  & data0_reg[31:0])      |\n                                    ({32{dmi_reg_addr == 7'h5}}  & data1_reg[31:0])      |\n                                    ({32{dmi_reg_addr == 7'h10}} & {2'b0,dmcontrol_reg[29],1'b0,dmcontrol_reg[27:0]})  |  // Read0 to Write only bits\n                                    ({32{dmi_reg_addr == 7'h11}} & dmstatus_reg[31:0])   |\n                                    ({32{dmi_reg_addr == 7'h16}} & abstractcs_reg[31:0]) |\n                                    ({32{dmi_reg_addr == 7'h17}} & command_reg[31:0])    |\n                                    ({32{dmi_reg_addr == 7'h18}} & {30'h0,abstractauto_reg[1:0]})    |\n                                    ({32{dmi_reg_addr == 7'h40}} & haltsum0_reg[31:0])   |\n                                    ({32{dmi_reg_addr == 7'h38}} & sbcs_reg[31:0])       |\n                                    ({32{dmi_reg_addr == 7'h39}} & sbaddress0_reg[31:0]) |\n                                    ({32{dmi_reg_addr == 7'h3c}} & sbdata0_reg[31:0])    |\n                                    ({32{dmi_reg_addr == 7'h3d}} & sbdata1_reg[31:0]);\n\n\n   rvdffs #($bits(state_t)) dbg_state_reg    (.din(dbg_nxtstate), .dout({dbg_state}), .en(dbg_state_en), .rst_l(dbg_dm_rst_l & rst_l), .clk(dbg_free_clk));\n   rvdffe #(32)             dmi_rddata_reg   (.din(dmi_reg_rdata_din[31:0]), .dout(dmi_reg_rdata[31:0]), .en(dmi_reg_en), .rst_l(dbg_dm_rst_l), .clk(clk), .*);\n\n   assign abmem_addr[31:0]      = data1_reg[31:0];\n   assign abmem_addr_core_local = (abmem_addr_in_dccm_region | abmem_addr_in_iccm_region | abmem_addr_in_pic_region);\n   assign abmem_addr_external   = ~abmem_addr_core_local;\n\n   assign abmem_addr_in_dccm_region = (abmem_addr[31:28] == pt.DCCM_REGION) & pt.DCCM_ENABLE;\n   assign abmem_addr_in_iccm_region = (abmem_addr[31:28] == pt.ICCM_REGION) & pt.ICCM_ENABLE;\n   assign abmem_addr_in_pic_region  = (abmem_addr[31:28] == pt.PIC_REGION);\n\n   // interface for the core\n   assign dbg_cmd_addr[31:0]    = (command_reg[31:24] == 8'h2) ? data1_reg[31:0]  : {20'b0, command_reg[11:0]};\n   assign dbg_cmd_wrdata[31:0]  = data0_reg[31:0];\n   assign dbg_cmd_valid         = (dbg_state == CORE_CMD_START) & ~((|abstractcs_reg[10:8]) | ((command_reg[31:24] == 8'h0) & ~command_reg[17]) | ((command_reg[31:24] == 8'h2) & abmem_addr_external)) & dma_dbg_ready;\n   assign dbg_cmd_write         = command_reg[16];\n   assign dbg_cmd_type[1:0]     = (command_reg[31:24] == 8'h2) ? 2'b10 : {1'b0, (command_reg[15:12] == 4'b0)};\n   assign dbg_cmd_size[1:0]     = command_reg[21:20];\n\n   assign dbg_cmd_addr_incr[3:0]  = (command_reg[31:24] == 8'h2) ? (4'h1 << sb_abmem_cmd_size[1:0]) : 4'h1;\n   assign dbg_cmd_curr_addr[31:0] = (command_reg[31:24] == 8'h2) ? data1_reg[31:0]  : {16'b0, command_reg[15:0]};\n   assign dbg_cmd_next_addr[31:0] = dbg_cmd_curr_addr[31:0] + {28'h0,dbg_cmd_addr_incr[3:0]};\n\n   // Ask DMA to stop taking bus trxns since debug request is done\n   assign dbg_dma_bubble = ((dbg_state == CORE_CMD_START) & ~(|abstractcs_reg[10:8])) | (dbg_state == CORE_CMD_WAIT);\n\n   assign sb_cmd_pending       = (sb_state == CMD_RD) | (sb_state == CMD_WR) | (sb_state == CMD_WR_ADDR) | (sb_state == CMD_WR_DATA) | (sb_state == RSP_RD) | (sb_state == RSP_WR);\n   assign sb_abmem_cmd_pending = (dbg_state == SB_CMD_START) | (dbg_state == SB_CMD_SEND) | (dbg_state== SB_CMD_RESP);\n\n\n  // system bus FSM\n  always_comb begin\n      sb_nxtstate            = SBIDLE;\n      sb_state_en            = 1'b0;\n      sbcs_sbbusy_wren       = 1'b0;\n      sbcs_sbbusy_din        = 1'b0;\n      sbcs_sberror_wren      = 1'b0;\n      sbcs_sberror_din[2:0]  = 3'b0;\n      sbaddress0_reg_wren1   = 1'b0;\n      case (sb_state)\n            SBIDLE: begin\n                     sb_nxtstate            = sbdata0wr_access ? WAIT_WR : WAIT_RD;\n                     sb_state_en            = (sbdata0wr_access | sbreadondata_access | sbreadonaddr_access) & ~(|sbcs_reg[14:12]) & ~sbcs_reg[22];\n                     sbcs_sbbusy_wren       = sb_state_en;                                                 // set the single read bit if it is a singlread command\n                     sbcs_sbbusy_din        = 1'b1;\n                     sbcs_sberror_wren      = sbcs_wren & (|dmi_reg_wdata[14:12]);                                            // write to clear the error bits\n                     sbcs_sberror_din[2:0]  = ~dmi_reg_wdata[14:12] & sbcs_reg[14:12];\n            end\n            WAIT_RD: begin\n                     sb_nxtstate           = (sbcs_unaligned | sbcs_illegal_size) ? DONE : CMD_RD;\n                     sb_state_en           = (dbg_bus_clk_en & ~sb_abmem_cmd_pending) | sbcs_unaligned | sbcs_illegal_size;\n                     sbcs_sberror_wren     = sbcs_unaligned | sbcs_illegal_size;\n                     sbcs_sberror_din[2:0] = sbcs_unaligned ? 3'b011 : 3'b100;\n            end\n            WAIT_WR: begin\n                     sb_nxtstate           = (sbcs_unaligned | sbcs_illegal_size) ? DONE : CMD_WR;\n                     sb_state_en           = (dbg_bus_clk_en & ~sb_abmem_cmd_pending) | sbcs_unaligned | sbcs_illegal_size;\n                     sbcs_sberror_wren     = sbcs_unaligned | sbcs_illegal_size;\n                     sbcs_sberror_din[2:0] = sbcs_unaligned ? 3'b011 : 3'b100;\n            end\n            CMD_RD : begin\n                     sb_nxtstate           = RSP_RD;\n                     sb_state_en           = sb_bus_cmd_read & dbg_bus_clk_en;\n            end\n            CMD_WR : begin\n                     sb_nxtstate           = (sb_bus_cmd_write_addr & sb_bus_cmd_write_data) ? RSP_WR : (sb_bus_cmd_write_data ? CMD_WR_ADDR : CMD_WR_DATA);\n                     sb_state_en           = (sb_bus_cmd_write_addr | sb_bus_cmd_write_data) & dbg_bus_clk_en;\n            end\n            CMD_WR_ADDR : begin\n                     sb_nxtstate           = RSP_WR;\n                     sb_state_en           = sb_bus_cmd_write_addr & dbg_bus_clk_en;\n            end\n            CMD_WR_DATA : begin\n                     sb_nxtstate           = RSP_WR;\n                     sb_state_en           = sb_bus_cmd_write_data & dbg_bus_clk_en;\n            end\n            RSP_RD: begin\n                     sb_nxtstate           = DONE;\n                     sb_state_en           = sb_bus_rsp_read & dbg_bus_clk_en;\n                     sbcs_sberror_wren     = sb_state_en & sb_bus_rsp_error;\n                     sbcs_sberror_din[2:0] = 3'b010;\n            end\n            RSP_WR: begin"}
{"text": "\n                     sb_nxtstate           = DONE;\n                     sb_state_en           = sb_bus_rsp_write & dbg_bus_clk_en;\n                     sbcs_sberror_wren     = sb_state_en & sb_bus_rsp_error;\n                     sbcs_sberror_din[2:0] = 3'b010;\n            end\n            DONE: begin\n                     sb_nxtstate            = SBIDLE;\n                     sb_state_en            = 1'b1;\n                     sbcs_sbbusy_wren       = 1'b1;                           // reset the single read\n                     sbcs_sbbusy_din        = 1'b0;\n                     sbaddress0_reg_wren1   = sbcs_reg[16] & (sbcs_reg[14:12] == 3'b0);    // auto increment was set and no error. Update to new address after completing the current command\n            end\n            default : begin\n                     sb_nxtstate            = SBIDLE;\n                     sb_state_en            = 1'b0;\n                     sbcs_sbbusy_wren       = 1'b0;\n                     sbcs_sbbusy_din        = 1'b0;\n                     sbcs_sberror_wren      = 1'b0;\n                     sbcs_sberror_din[2:0]  = 3'b0;\n                     sbaddress0_reg_wren1   = 1'b0;\n           end\n         endcase\n   end // always_comb begin\n\n   rvdffs #($bits(sb_state_t)) sb_state_reg (.din(sb_nxtstate), .dout({sb_state}), .en(sb_state_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n\n   assign sb_abmem_cmd_write      = command_reg[16];\n   assign sb_abmem_cmd_size[2:0]  = {1'b0, command_reg[21:20]};\n   assign sb_abmem_cmd_addr[31:0] = abmem_addr[31:0];\n   assign sb_abmem_cmd_wdata[31:0] = data0_reg[31:0];\n\n   assign sb_cmd_size[2:0]   = sbcs_reg[19:17];\n   assign sb_cmd_wdata[63:0] = {sbdata1_reg[31:0], sbdata0_reg[31:0]};\n   assign sb_cmd_addr[31:0]  = sbaddress0_reg[31:0];\n\n   assign sb_abmem_cmd_awvalid    = (dbg_state == SB_CMD_SEND) & sb_abmem_cmd_write & ~sb_abmem_cmd_done;\n   assign sb_abmem_cmd_wvalid     = (dbg_state == SB_CMD_SEND) & sb_abmem_cmd_write & ~sb_abmem_data_done;\n   assign sb_abmem_cmd_arvalid    = (dbg_state == SB_CMD_SEND) & ~sb_abmem_cmd_write & ~sb_abmem_cmd_done & ~sb_abmem_data_done;\n   assign sb_abmem_read_pend      = (dbg_state == SB_CMD_RESP) & ~sb_abmem_cmd_write;\n\n   assign sb_cmd_awvalid     = ((sb_state == CMD_WR) | (sb_state == CMD_WR_ADDR));\n   assign sb_cmd_wvalid      = ((sb_state == CMD_WR) | (sb_state == CMD_WR_DATA));\n   assign sb_cmd_arvalid     = (sb_state == CMD_RD);\n   assign sb_read_pend       = (sb_state == RSP_RD);\n\n   assign sb_axi_size[2:0]    = (sb_abmem_cmd_awvalid | sb_abmem_cmd_wvalid | sb_abmem_cmd_arvalid | sb_abmem_read_pend) ? sb_abmem_cmd_size[2:0] : sb_cmd_size[2:0];\n   assign sb_axi_addr[31:0]   = (sb_abmem_cmd_awvalid | sb_abmem_cmd_wvalid | sb_abmem_cmd_arvalid | sb_abmem_read_pend) ? sb_abmem_cmd_addr[31:0] : sb_cmd_addr[31:0];\n   assign sb_axi_wrdata[63:0] = (sb_abmem_cmd_awvalid | sb_abmem_cmd_wvalid) ? {2{sb_abmem_cmd_wdata[31:0]}} : sb_cmd_wdata[63:0];\n\n   // Generic bus response signals\n   assign sb_bus_cmd_read       = sb_axi_arvalid & sb_axi_arready;\n   assign sb_bus_cmd_write_addr = sb_axi_awvalid & sb_axi_awready;\n   assign sb_bus_cmd_write_data = sb_axi_wvalid  & sb_axi_wready;\n\n   assign sb_bus_rsp_read  = sb_axi_rvalid & sb_axi_rready;\n   assign sb_bus_rsp_write = sb_axi_bvalid & sb_axi_bready;\n   assign sb_bus_rsp_error = (sb_bus_rsp_read & (|(sb_axi_rresp[1:0]))) | (sb_bus_rsp_write & (|(sb_axi_bresp[1:0])));\n\n   // AXI Request signals\n   assign sb_axi_awvalid              = sb_abmem_cmd_awvalid | sb_cmd_awvalid;\n   assign sb_axi_awaddr[31:0]         = sb_axi_addr[31:0];\n   assign sb_axi_awid[pt.SB_BUS_TAG-1:0] = '0;\n   assign sb_axi_awsize[2:0]          = sb_axi_size[2:0];\n   assign sb_axi_awprot[2:0]          = 3'b001;\n   assign sb_axi_awcache[3:0]         = 4'b1111;\n   assign sb_axi_awregion[3:0]        = sb_axi_addr[31:28];\n   assign sb_axi_awlen[7:0]           = '0;\n   assign sb_axi_awburst[1:0]         = 2'b01;\n   assign sb_axi_awqos[3:0]           = '0;\n   assign sb_axi_awlock               = '0;\n\n   assign sb_axi_wvalid       = sb_abmem_cmd_wvalid | sb_cmd_wvalid;\n   assign sb_axi_wdata[63:0]  = ({64{(sb_axi_size[2:0] == 3'h0)}} & {8{sb_axi_wrdata[7:0]}}) |\n                                ({64{(sb_axi_size[2:0] == 3'h1)}} & {4{sb_axi_wrdata[15:0]}}) |\n                                ({64{(sb_axi_size[2:0] == 3'h2)}} & {2{sb_axi_wrdata[31:0]}}) |\n                                ({64{(sb_axi_size[2:0] == 3'h3)}} & {sb_axi_wrdata[63:0]});\n   assign sb_axi_wstrb[7:0]   = ({8{(sb_axi_size[2:0] == 3'h0)}} & (8'h1 << sb_axi_addr[2:0])) |\n                                ({8{(sb_axi_size[2:0] == 3'h1)}} & (8'h3 << {sb_axi_addr[2:1],1'b0})) |\n                                ({8{(sb_axi_size[2:0] == 3'h2)}} & (8'hf << {sb_axi_addr[2],2'b0})) |\n                                ({8{(sb_axi_size[2:0] == 3'h3)}} & 8'hff);\n   assign sb_axi_wlast        = '1;\n\n   assign sb_axi_arvalid              = sb_abmem_cmd_arvalid | sb_cmd_arvalid;\n   assign sb_axi_araddr[31:0]         = sb_axi_addr[31:0];\n   assign sb_axi_arid[pt.SB_BUS_TAG-1:0] = '0;\n   assign sb_axi_arsize[2:0]          = sb_axi_size[2:0];\n   assign sb_axi_arprot[2:0]          = 3'b001;\n   assign sb_axi_arcache[3:0]         = 4'b0;\n   assign sb_axi_arregion[3:0]        = sb_axi_addr[31:28];\n   assign sb_axi_arlen[7:0]           = '0;\n   assign sb_axi_arburst[1:0]         = 2'b01;\n   assign sb_axi_arqos[3:0]           = '0;\n   assign sb_axi_arlock               = '0;\n\n   // AXI Response signals\n   assign sb_axi_bready = 1'b1;\n\n   assign sb_axi_rready = 1'b1;\n   assign sb_bus_rdata[63:0] = ({64{sb_axi_size == 3'h0}} & ((sb_axi_rdata[63:0] >>  8*sb_axi_addr[2:0]) & 64'hff))       |\n                               ({64{sb_axi_size == 3'h1}} & ((sb_axi_rdata[63:0] >> 16*sb_axi_addr[2:1]) & 64'hffff))    |\n                               ({64{sb_axi_size == 3'h2}} & ((sb_axi_rdata[63:0] >> 32*sb_axi_addr[2]) & 64'hffff_ffff)) |\n                               ({64{sb_axi_size == 3'h3}} & sb_axi_rdata[63:0]);\n\n`ifdef RV_ASSERT_ON\n// assertion.\n//  when the resume_ack is asserted then the dec_tlu_dbg_halted should be 0\n   dm_check_resume_and_halted: assert property (@(posedge clk)  disable iff(~rst_l) (~dec_tlu_resume_ack | ~dec_tlu_dbg_halted));\n\n   assert_b2b_haltreq: assert property (@(posedge clk) disable iff (~(rst_l)) (##1 dbg_halt_req |=> ~dbg_halt_req));  // One cycle delay to fix weird issue around reset\n   assert_halt_resume_onehot: assert #0 ($onehot0({dbg_halt_req, dbg_resume_req}));\n`endif\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// dec: decode unit - decode, bypassing, ARF, interrupts\n//\n//********************************************************************************\n// $Id$\n//\n//\n// Function: Decode\n// Comments: Decode, dependency scoreboard, ARF\n//\n//\n// A -> D -> EX1 ... WB\n//\n//********************************************************************************\n\nmodule el2_dec\n  import el2_pkg::*;\n#(\n    `include \"el2_param.vh\"\n) (\n    input logic clk,                          // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n    input logic active_clk,                   // Clock only while core active.  Through two clock headers. For flops without second clock header built in.\n    input logic free_clk,                     // Clock always.                  Through two clock headers. For flops without second clock header built in.\n    input logic free_l2clk,                   // Clock always.                  Through one clock header.  For flops with    second header built in.\n\n    input logic lsu_fastint_stall_any,        // needed by lsu for 2nd pass of dma with ecc correction, stall next cycle\n\n    output logic dec_extint_stall,  // Stall on external interrupt\n\n    output logic dec_i0_decode_d,    // Valid instruction at D-stage and not blocked\n    output logic dec_pause_state_cg, // to top for active state clock gating\n\n    output logic dec_tlu_core_empty,\n\n    input logic        rst_l,   // reset, active low\n    input logic [31:1] rst_vec, // reset vector, from core pins\n\n    input logic        nmi_int,  // NMI pin\n    input logic [31:1] nmi_vec,  // NMI vector, from pins\n\n    input logic i_cpu_halt_req,  // Asynchronous Halt request to CPU\n    input logic i_cpu_run_req,   // Asynchronous Restart request to CPU\n\n    output logic o_cpu_halt_status,  // Halt status of core (pmu/fw)\n    output logic o_cpu_halt_ack,  // Halt request ack\n    output logic o_cpu_run_ack,  // Run request ack\n    output logic o_debug_mode_status,         // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n\n    input logic [31:4] core_id,  // CORE ID\n\n    // external MPC halt/run interface\n    input  logic mpc_debug_halt_req,  // Async halt request\n    input  logic mpc_debug_run_req,   // Async run request\n    input  logic mpc_reset_run_req,   // Run/halt after reset\n    output logic mpc_debug_halt_ack,  // Halt ack\n    output logic mpc_debug_run_ack,   // Run ack\n    output logic debug_brkpt_status,  // debug breakpoint\n\n    input logic exu_pmu_i0_br_misp,    // slot 0 branch misp\n    input logic exu_pmu_i0_br_ataken,  // slot 0 branch actual taken\n    input logic exu_pmu_i0_pc4,        // slot 0 4 byte branch\n\n\n    input logic lsu_nonblock_load_valid_m,  // valid nonblock load at m\n    input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_tag_m,  // -> corresponding tag\n    input logic lsu_nonblock_load_inv_r,  // invalidate request for nonblock load r\n    input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_inv_tag_r,  // -> corresponding tag\n    input logic lsu_nonblock_load_data_valid,  // valid nonblock load data back\n    input logic lsu_nonblock_load_data_error,  // nonblock load bus error\n    input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_data_tag,  // -> corresponding tag\n    input logic [31:0] lsu_nonblock_load_data,  // nonblock load data\n\n    input logic lsu_pmu_bus_trxn,          // D side bus transaction\n    input logic lsu_pmu_bus_misaligned,    // D side bus misaligned\n    input logic lsu_pmu_bus_error,         // D side bus error\n    input logic lsu_pmu_bus_busy,          // D side bus busy\n    input logic lsu_pmu_misaligned_m,      // D side load or store misaligned\n    input logic lsu_pmu_load_external_m,   // D side bus load\n    input logic lsu_pmu_store_external_m,  // D side bus store\n    input logic dma_pmu_dccm_read,         // DMA DCCM read\n    input logic dma_pmu_dccm_write,        // DMA DCCM write\n    input logic dma_pmu_any_read,          // DMA read\n    input logic dma_pmu_any_write,         // DMA write\n\n    input logic [31:1] lsu_fir_addr,  // Fast int address\n    input logic [ 1:0] lsu_fir_error, // Fast int lookup error\n\n    input logic ifu_pmu_instr_aligned,  // aligned instructions\n    input logic ifu_pmu_fetch_stall,    // fetch unit stalled\n    input logic ifu_pmu_ic_miss,        // icache miss\n    input logic ifu_pmu_ic_hit,         // icache hit\n    input logic ifu_pmu_bus_error,      // Instruction side bus error\n    input logic ifu_pmu_bus_busy,       // Instruction side bus busy\n    input logic ifu_pmu_bus_trxn,       // Instruction side bus transaction\n\n    input logic ifu_ic_error_start,         // IC single bit error\n    input logic ifu_iccm_rd_ecc_single_err, // ICCM single bit error\n\n    input logic [ 3:0] lsu_trigger_match_m,\n    input logic        dbg_cmd_valid,        // debugger abstract command valid\n    input logic        dbg_cmd_write,        // command is a write\n    input logic [ 1:0] dbg_cmd_type,         // command type\n    input logic [31:0] dbg_cmd_addr,         // command address\n    input logic [ 1:0] dbg_cmd_wrdata,       // command write data, for fence/fence_i\n\n\n    input logic       ifu_i0_icaf,      // icache access fault\n    input logic [1:0] ifu_i0_icaf_type, // icache access fault type\n\n    input logic ifu_i0_icaf_second,  // i0 has access fault on second 2B of 4B inst\n    input logic ifu_i0_dbecc,        // icache/iccm double-bit error\n\n    input logic lsu_idle_any,  // lsu idle for halting\n\n    input el2_br_pkt_t                                 i0_brp,           // branch packet\n    input logic        [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifu_i0_bp_index,  // BP index\n    input logic        [          pt.BHT_GHR_SIZE-1:0] ifu_i0_bp_fghr,   // BP FGHR\n    input logic        [         pt.BTB_BTAG_SIZE-1:0] ifu_i0_bp_btag,   // BP tag\n    input logic        [      $clog2(pt.BTB_SIZE)-1:0] ifu_i0_fa_index,  // Fully associt btb index\n\n    input el2_lsu_error_pkt_t lsu_error_pkt_r,           // LSU exception/error packet\n    input logic               lsu_single_ecc_error_incr, // LSU inc SB error counter\n\n    input logic        lsu_imprecise_error_load_any,   // LSU imprecise load bus error\n    input logic        lsu_imprecise_error_store_any,  // LSU imprecise store bus error\n    input logic [31:0] lsu_imprecise_error_addr_any,   // LSU imprecise bus error address\n\n    input logic [31:0] exu_div_result,  // final div result\n    input logic        exu_div_wren,    // Divide write enable to GPR\n\n    input logic [31:0] exu_csr_rs1_x,  // rs1 for csr instruction\n\n    input logic [31:0] lsu_result_m,      // load result\n    input logic [31:0] lsu_result_corr_r, // load result - corrected load data\n\n    input logic lsu_load_stall_any,   // This is for blocking loads\n    input logic lsu_store_stall_any,  // This is for blocking stores\n    input logic dma_dccm_stall_any,   // stall any load/store at decode, pmu event\n    input logic dma_iccm_stall_any,   // iccm stalled, pmu event\n\n    input logic iccm_dma_sb_error,  // ICCM DMA single bit error\n\n    input logic exu_flush_final,  // slot0 flush\n\n    input logic [31:1] exu_npc_r,  // next PC\n\n    input logic [31:0] exu_i0_result_x,  // alu result x\n\n\n    input logic        ifu_i0_valid,  // fetch valids to instruction buffer\n    input logic [31:0] ifu_i0_instr,  // fetch inst's to instruction buffer\n    input logic [31:1] ifu_i0_pc,     // pc's for instruction buffer\n    input logic        ifu_i0_pc4,    // indication of 4B or 2B for corresponding inst\n    input logic [31:1] exu_i0_pc_x,   // pc's for e1 from the alu's\n\n    input logic mexintpend,  // External interrupt pending\n    input logic timer_int,   // Timer interrupt pending (from pin)\n    input logic soft_int,    // Software interrupt pending (from pin)\n\n    input logic [7:0] pic_claimid,  // PIC claimid\n    input logic [3:0] pic_pl,       // PIC priv level\n    input logic       mhwakeup,     // High priority wakeup\n\n    output logic [3:0] dec_tlu_meicurpl,  // to PIC, Current priv level\n    output logic [3:0] dec_tlu_meipt,     // to PIC\n\n    input logic [70:0] ifu_ic_debug_rd_data,  // diagnostic icache read data\n    input logic ifu_ic_debug_rd_data_valid,  // diagnostic icache read data valid\n    output el2_cache_debug_pkt_t dec_tlu_ic_diag_pkt, // packet of DICAWICS, DICAD0/1, DICAGO info for icache diagnostics\n\n\n    // Debug start\n    input logic dbg_halt_req,        // DM requests a halt\n    input logic dbg_resume_req,      // DM requests a resume\n    input logic ifu_miss_state_idle, // I-side miss buffer empty\n\n    output logic        dec_tlu_dbg_halted,        // Core is halted and ready for debug command\n    output logic        dec_tlu_debug_mode,        // Core is in debug mode\n    output logic        dec_tlu_resume_ack,        // Resume acknowledge\n    output logic        dec_tlu_flush_noredir_r,   // Tell fetch to idle on this flush\n    output logic        dec_tlu_mpc_halted_only,   // Core is halted only due to MPC\n    output logic        dec_tlu_flush_leak_one_r,  // single step\n    output logic        dec_tlu_flush_err_r,       // iside perr/ecc rfpc\n    output logic [31:2] dec_tlu_meihap,            // Fast ext int base\n\n    output logic dec_debug_wdata_rs1_d,  // insert debug write data into rs1 at decode\n\n    output logic [31:0] dec_dbg_rddata,  // debug command read data\n\n    output logic dec_dbg_cmd_done,  // abstract command is done\n    output logic dec_dbg_cmd_fail,  // abstract command failed (illegal reg address)\n\n    output el2_trigger_pkt_t [3:0] trigger_pkt_any,  // info needed by debug trigger blocks\n\n    output logic       dec_tlu_force_halt,       // halt has been forced\n    // Debug end\n    // branch info from pipe0 for errors or counter updates\n    input  logic [1:0] exu_i0_br_hist_r,         // history\n    input  logic       exu_i0_br_error_r,        // error\n    input  logic       exu_i0_br_start_error_r,  // start error\n    input  logic       exu_i0_br_valid_r,        // valid\n    input  logic       exu_i0_br_mp_r,           // mispredict\n    input  logic       exu_i0_br_middle_r,       // middle of bank\n\n    // branch info from pipe1 for errors or counter updates\n\n    input logic exu_i0_br_way_r,  // way hit or repl\n\n    output logic        dec_i0_rs1_en_d,  // Qualify GPR RS1 data\n    output logic        dec_i0_rs2_en_d,  // Qualify GPR RS2 data\n    output logic [31:0] gpr_i0_rs1_d,     // gpr rs1 data\n    output logic [31:0] gpr_i0_rs2_d,     // gpr rs2 data\n\n    output logic [31:0] dec_i0_immed_d,    // immediate data\n    output logic [12:1] dec_i0_br_immed_d, // br immediate data\n\n    output el2_alu_pkt_t i0_ap,  // alu packet\n\n    output logic dec_i0_alu_decode_d,  // schedule on D-stage alu\n    output logic dec_i0_branch_d,      // Branch in D-stage\n\n    output logic dec_i0_select_pc_d,  // select pc onto rs1 for jal's\n\n    output logic [31:1] dec_i0_pc_d,             // pc's at decode\n    output logic [ 3:0] dec_i0_rs1_bypass_en_d,  // rs1 bypass enable\n    output logic [ 3:0] dec_i0_rs2_bypass_en_d,  // rs2 bypass enable\n\n    output logic [31:0] dec_i0_result_r,  // Result R-stage\n\n    output el2_lsu_pkt_t lsu_p,           // lsu packet\n    output logic         dec_qual_lsu_d,  // LSU instruction at D.  Use to quiet LSU operands\n    output el2_mul_pkt_t mul_p,           // mul packet\n    output el2_div_pkt_t div_p,           // div packet\n    output logic         dec_div_cancel,  // cancel divide operation\n\n    output logic [11:0] dec_lsu_offset_d,  // 12b offset for load/store addresses\n\n    output logic        dec_csr_ren_d,    // CSR read enable\n    output logic [31:0] dec_csr_rddata_d, // CSR read data\n\n    output logic dec_tlu_flush_lower_r,  // tlu flush due to late mp, exception, rfpc, or int\n    output logic dec_tlu_flush_lower_wb,\n    output logic [31:1] dec_tlu_flush_path_r,  // tlu flush target\n    output logic        dec_tlu_i0_kill_writeb_r,    // I0 is flushed, don't writeback any results to arch state\n    output logic dec_tlu_fence_i_r,  // flush is a fence_i rfnpc, flush icache\n\n    output logic [31:1] pred_correct_npc_x,  // npc if prediction is correct at e2 stage\n\n    output el2_br_tlu_pkt_t dec_tlu_br0_r_pkt,  // slot 0 branch predictor update packet\n\n    output logic dec_tlu_perfcnt0,  // toggles when slot0 perf counter 0 has an event inc\n    output logic dec_tlu_perfcnt1,  // toggles when slot0 perf counter 1 has an event inc\n    output logic dec_tlu_perfcnt2,  // toggles when slot0 perf counter 2 has an event inc\n    output logic dec_tlu_perfcnt3,  // toggles when slot0 perf counter 3 has an event inc\n\n    output el2_predict_pkt_t dec_i0_predict_p_d,  // prediction packet to alus\n    output logic [pt.BHT_GHR_SIZE-1:0] i0_predict_fghr_d,  // DEC predict fghr\n    output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i0_predict_index_d,  // DEC predict index\n    output logic [pt.BTB_BTAG_SIZE-1:0] i0_predict_btag_d,  // DEC predict branch tag\n\n    output logic [$clog2(pt.BTB_SIZE)-1:0] dec_fa_error_index,  // Fully associt btb error index\n\n    output logic dec_lsu_valid_raw_d,\n\n    output logic [31:0] dec_tlu_mrac_ff,  // CSR for memory region control\n\n    output logic [1:0] dec_data_en,  // clock-gate control logic\n    output logic [1:0] dec_ctl_en,\n\n    input logic [15:0] ifu_i0_cinst,  // 16b compressed instruction\n\n    output el2_trace_pkt_t trace_rv_trace_pkt,  // trace packet\n\n    // PMP signals\n    output el2_pmp_cfg_pkt_t        pmp_pmpcfg [pt.PMP_ENTRIES],\n    output logic             [31:0] pmp_pmpaddr[pt.PMP_ENTRIES],\n\n    // feature disable from mfdc\n    output logic dec_tlu_external_ldfwd_disable,  // disable external load forwarding\n    output logic dec_tlu_sideeffect_posted_disable,  // disable posted stores to side-effect address\n    output logic dec_tlu_core_ecc_disable,  // disable core ECC\n    output logic dec_tlu_bpred_disable,  // disable branch prediction\n    output logic dec_tlu_wb_coalescing_disable,  // disable writebuffer coalescing\n    output logic [2:0] dec_tlu_dma_qos_prty,  // DMA QoS priority coming from MFDC [18:16]\n\n    // clock gating overrides from mcgc\n    output logic dec_tlu_misc_clk_override,   // override misc clock domain gating\n    output logic dec_tlu_ifu_clk_override,    // override fetch clock domain gating\n    output logic dec_tlu_lsu_clk_override,    // override load/store clock domain gating\n    output logic dec_tlu_bus_clk_override,    // override bus clock domain gating\n    output logic dec_tlu_pic_clk_override,    // override PIC clock domain gating\n    output logic dec_tlu_picio_clk_override,  // override PICIO clock domain gating\n    output logic dec_tlu_dccm_clk_override,   // override DCCM clock domain gating\n    output logic dec_tlu_icm_clk_override,    // override ICCM clock domain gating\n\n    output logic dec_tlu_i0_commit_cmt,  // committed i0 instruction\n    input  logic scan_mode               // Flop scan mode control\n\n);\n\n\n  logic dec_tlu_dec_clk_override;  // to and from dec blocks\n  logic clk_override;\n\n  logic dec_ib0_valid_d;\n\n  logic dec_pmu_instr_decoded;\n  logic dec_pmu_decode_stall;\n  logic dec_pmu_presync_stall;\n  logic dec_pmu_postsync_stall;\n\n  logic dec_tlu_wr_pause_r;  // CSR write to pause reg is at R.\n\n  logic [4:0] dec_i0_rs1_d;\n  logic [4:0] dec_i0_rs2_d;\n\n  logic [31:0] dec_i0_instr_d;\n\n  logic dec_tlu_trace_disable;\n  logic dec_tlu_pipelining_disable;\n\n\n  logic [4:0] dec_i0_waddr_r;\n  logic dec_i0_wen_r;\n  logic [31:0] dec_i0_wdata_r;\n  logic dec_csr_wen_r;  // csr write enable at wb\n  logic [11:0] dec_csr_wraddr_r;  // write address for csryes\n  logic [31:0] dec_csr_wrdata_r;  // csr write data at wb\n\n  logic [11:0] dec_csr_rdaddr_d;  // read address for csr\n  logic dec_csr_legal_d;  // csr indicates legal operation\n\n  logic dec_csr_wen_unq_d;  // valid csr with write - for csr legal\n  logic dec_csr_any_unq_d;  // valid csr - for csr legal\n  logic dec_csr_stall_int_ff;  // csr is mie/mstatus\n\n  el2_trap_pkt_t dec_tlu_packet_r;\n\n  logic dec_i0_pc4_d;\n  logic dec_tlu_presync_d;\n  logic dec_tlu_postsync_d;\n  logic dec_tlu_debug_stall;\n\n  logic [31:0] dec_illegal_inst;\n\n  logic dec_i0_icaf_d;\n\n  logic dec_i0_dbecc_d;\n  logic dec_i0_icaf_second_d;\n  logic [3:0] dec_i0_trigger_match_d;\n  logic dec_debug_fence_d;\n  logic dec_nonblock_load_wen;\n  logic [4:0] dec_nonblock_load_waddr;\n  logic dec_tlu_flush_pause_r;\n  el2_br_pkt_t dec_i0_brp;\n  logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_i0_bp_index;\n  logic [pt.BHT_GHR_SIZE-1:0] dec_i0_bp_fghr;\n  logic [pt.BTB_BTAG_SIZE-1:0] dec_i0_bp_btag;\n  logic [$clog2(pt.BTB_SIZE)-1:0] dec_i0_bp_fa_index;  // Fully associt btb index\n\n  logic [31:1] dec_tlu_i0_pc_r;\n  logic dec_tlu_i0_kill_writeb_wb;\n  logic dec_tlu_i0_valid_r;\n\n  logic dec_pause_state;\n\n  logic [1:0] dec_i0_icaf_type_d;  // i0 instruction access fault type\n\n  logic dec_tlu_flush_extint;  // Fast ext int started\n\n  logic [31:0] dec_i0_inst_wb;\n  logic [31:1] dec_i0_pc_wb;\n  logic dec_tlu_i0_valid_wb1, dec_tlu_int_valid_wb1;\n  logic [ 4:0] dec_tlu_exc_cause_wb1;\n  logic [31:0] dec_tlu_mtval_wb1;\n  logic        dec_tlu_i0_exc_valid_wb1;\n\n  logic [ 4:0] div_waddr_wb;\n  logic        dec_div_active;\n\n  logic        dec_debug_valid_d;\n\n  assign clk_override = dec_tlu_dec_clk_override;\n\n\n  assign dec_dbg_rddata[31:0] = dec_i0_wdata_r[31:0];\n\n\n  el2_dec_ib_ctl #(.pt(pt)) instbuff (.*);\n\n\n  el2_dec_decode_ctl #(.pt(pt)) decode (.*);\n\n\n  el2_dec_tlu_ctl #(.pt(pt)) tlu (.*);\n\n\n  el2_dec_gpr_ctl #(\n      .pt(pt)\n  ) arf (\n      .*,\n      // inputs\n      .raddr0(dec_i0_rs1_d[4:0]),\n      .raddr1(dec_i0_rs2_d[4:0]),\n\n      .wen0(dec_i0_wen_r),\n      .waddr0(dec_i0_waddr_r[4:0]),\n      .wd0(dec_i0_wdata_r[31:0]),\n      .wen1(dec_nonblock_load_wen),\n      .waddr1(dec_nonblock_load_waddr[4:0]),\n      .wd1(lsu_nonblock_load_data[31:0]),\n      .wen2(exu_div_wren),\n      .waddr2(div_waddr_wb),\n      .wd2(exu_div_result[31:0]),\n\n      // outputs\n      .rd0(gpr_i0_rs1_d[31:0]),\n      .rd1(gpr_i0_rs2_d[31:0])\n  );\n\n\n  // Trigger\n\n  el2_dec_trigger #(.pt(pt)) dec_trigger (.*);\n\n\n\n\n  // trace\n  assign trace_rv_trace_pkt.trace_rv_i_insn_ip = dec_i0_inst_wb[31:0];\n  assign trace_rv_trace_pkt.trace_rv_i_address_ip = {dec_i0_pc_wb[31:1], 1'b0};\n\n  assign trace_rv_trace_pkt.trace_rv_i_valid_ip     = dec_tlu_int_valid_wb1 | dec_tlu_i0_valid_wb1 | dec_tlu_i0_exc_valid_wb1;\n  assign trace_rv_trace_pkt.trace_rv_i_exception_ip = dec_tlu_int_valid_wb1 |  dec_tlu_i0_exc_valid_wb1;\n  assign trace_rv_trace_pkt.trace_rv_i_ecause_ip    = dec_tlu_exc_cause_wb1[4:0];     // replicate across ports\n  assign trace_rv_trace_pkt.trace_rv_i_interrupt_ip = dec_tlu_int_valid_wb1;\n  assign trace_rv_trace_pkt.trace_rv_i_tval_ip = dec_tlu_mtval_wb1[31:0];  // replicate across ports\n\n\n\n  // end trace\n\n\nendmodule  // el2_dec\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nmodule el2_dec_decode_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n   input logic dec_tlu_trace_disable,\n   input logic dec_debug_valid_d,\n\n   input logic dec_tlu_flush_extint,         // Flush external interrupt\n\n   input logic dec_tlu_force_halt,           // invalidate nonblock load cam on a force halt event\n\n   output logic dec_extint_stall,            // Stall from external interrupt\n\n   input  logic [15:0] ifu_i0_cinst,         // 16b compressed instruction\n   output logic [31:0] dec_i0_inst_wb,       // 32b instruction at wb+1 for trace encoder\n   output logic [31:1] dec_i0_pc_wb,         // 31b pc at wb+1 for trace encoder\n\n\n   input logic                                lsu_nonblock_load_valid_m,       // valid nonblock load at m\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_tag_m,         // -> corresponding tag\n   input logic                                lsu_nonblock_load_inv_r,         // invalidate request for nonblock load r\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_inv_tag_r,     // -> corresponding tag\n   input logic                                lsu_nonblock_load_data_valid,    // valid nonblock load data back\n   input logic                                lsu_nonblock_load_data_error,    // nonblock load bus error\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_data_tag,      // -> corresponding tag\n\n\n   input logic [3:0] dec_i0_trigger_match_d,          // i0 decode trigger matches\n\n   input logic dec_tlu_wr_pause_r,                    // pause instruction at r\n   input logic dec_tlu_pipelining_disable,            // pipeline disable - presync, i0 decode only\n\n   input logic [3:0]  lsu_trigger_match_m,            // lsu trigger matches\n\n   input logic lsu_pmu_misaligned_m,                  // perf mon: load/store misalign\n   input logic dec_tlu_debug_stall,                   // debug stall decode\n   input logic dec_tlu_flush_leak_one_r,              // leak1 instruction\n\n   input logic dec_debug_fence_d,                     // debug fence instruction\n\n   input logic [1:0] dbg_cmd_wrdata,                  // disambiguate fence, fence_i\n\n   input logic dec_i0_icaf_d,                         // icache access fault\n   input logic dec_i0_icaf_second_d,                  // i0 instruction access fault on second 2B of 4B inst\n   input logic [1:0] dec_i0_icaf_type_d,              // i0 instruction access fault type\n\n   input logic dec_i0_dbecc_d,                        // icache/iccm double-bit error\n\n   input el2_br_pkt_t dec_i0_brp,                    // branch packet\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_i0_bp_index,   // i0 branch index\n   input logic [pt.BHT_GHR_SIZE-1:0] dec_i0_bp_fghr,  // BP FGHR\n   input logic [pt.BTB_BTAG_SIZE-1:0] dec_i0_bp_btag, // BP tag\n   input logic [$clog2(pt.BTB_SIZE)-1:0] dec_i0_bp_fa_index,          // Fully associt btb index\n\n   input logic lsu_idle_any,                          // lsu idle: if fence instr & ~lsu_idle then stall decode\n\n   input logic lsu_load_stall_any,                    // stall any load at decode\n   input logic lsu_store_stall_any,                   // stall any store at decode\n   input logic dma_dccm_stall_any,                    // stall any load/store at decode\n\n   input logic exu_div_wren,                          // nonblocking divide write enable to GPR.\n\n   input logic dec_tlu_i0_kill_writeb_wb,             // I0 is flushed, don't writeback any results to arch state\n   input logic dec_tlu_flush_lower_wb,                // trap lower flush\n   input logic dec_tlu_i0_kill_writeb_r,              // I0 is flushed, don't writeback any results to arch state\n   input logic dec_tlu_flush_lower_r,                 // trap lower flush\n   input logic dec_tlu_flush_pause_r,                 // don't clear pause state on initial lower flush\n   input logic dec_tlu_presync_d,                     // CSR read needs to be presync'd\n   input logic dec_tlu_postsync_d,                    // CSR ops that need to be postsync'd\n\n   input logic dec_i0_pc4_d,                          // inst is 4B inst else 2B\n\n   input logic [31:0] dec_csr_rddata_d,               // csr read data at wb\n   input logic dec_csr_legal_d,                       // csr indicates legal operation\n\n   input logic [31:0] exu_csr_rs1_x,                  // rs1 for csr instr\n\n   input logic [31:0] lsu_result_m,                   // load result\n   input logic [31:0] lsu_result_corr_r,              // load result - corrected data for writing gpr's, not for bypassing\n\n   input logic exu_flush_final,                       // lower flush or i0 flush at X or D\n\n   input logic [31:1] exu_i0_pc_x,                    // pcs at e1\n\n   input logic [31:0] dec_i0_instr_d,                 // inst at decode\n\n   input logic  dec_ib0_valid_d,                      // inst valid at decode\n\n   input logic [31:0] exu_i0_result_x,                // from primary alu's\n\n   input logic  clk,                                  // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n   input logic  active_clk,                           // Clock only while core active.  Through two clock headers. For flops without second clock header built in.\n   input logic  free_l2clk,                           // Clock always.                  Through one clock header.  For flops with    second header built in.\n\n   input logic  clk_override,                         // Override non-functional clock gating\n   input logic  rst_l,                                // Flop reset\n\n\n\n   output logic        dec_i0_rs1_en_d,               // rs1 enable at decode\n   output logic        dec_i0_rs2_en_d,               // rs2 enable at decode\n\n   output logic [4:0]  dec_i0_rs1_d,                  // rs1 logical source\n   output logic [4:0]  dec_i0_rs2_d,                  // rs2 logical source\n\n   output logic [31:0] dec_i0_immed_d,                // 32b immediate data decode\n\n\n   output logic [12:1] dec_i0_br_immed_d,             // 12b branch immediate\n\n   output el2_alu_pkt_t i0_ap,                       // alu packets\n\n   output logic        dec_i0_decode_d,               // i0 decode\n\n   output logic        dec_i0_alu_decode_d,           // decode to D-stage alu\n   output logic        dec_i0_branch_d,               // Branch in D-stage\n\n   output logic [4:0]  dec_i0_waddr_r,                // i0 logical source to write to gpr's\n   output logic        dec_i0_wen_r,                  // i0 write enable\n   output logic [31:0] dec_i0_wdata_r,                // i0 write data\n\n   output logic        dec_i0_select_pc_d,            // i0 select pc for rs1 - branches\n\n   output logic [3:0]    dec_i0_rs1_bypass_en_d,      // i0 rs1 bypass enable\n   output logic [3:0]    dec_i0_rs2_bypass_en_d,      // i0 rs2 bypass enable\n   output logic [31:0]   dec_i0_result_r,             // Result R-stage\n\n   output el2_lsu_pkt_t    lsu_p,                    // load/store packet\n   output logic             dec_qual_lsu_d,           // LSU instruction at D.  Use to quiet LSU operands\n\n   output el2_mul_pkt_t    mul_p,                    // multiply packet\n\n   output el2_div_pkt_t    div_p,                    // divide packet\n   output logic [4:0]       div_waddr_wb,             // DIV write address to GPR\n   output logic             dec_div_cancel,           // cancel the divide operation\n\n   output logic        dec_lsu_valid_raw_d,\n   output logic [11:0] dec_lsu_offset_d,\n\n   output logic        dec_csr_ren_d,                 // valid csr decode\n   output logic        dec_csr_wen_unq_d,             // valid csr with write - for csr legal\n   output logic        dec_csr_any_unq_d,             // valid csr - for csr legal\n   output logic [11:0] dec_csr_rdaddr_d,              // read address for csr\n   output logic        dec_csr_wen_r,                 // csr write enable at r\n   output logic [11:0] dec_csr_wraddr_r,              // write address for csr\n   output logic [31:0] dec_csr_wrdata_r,              // csr write data at r\n   output logic        dec_csr_stall_int_ff,          // csr is mie/mstatus\n\n   output              dec_tlu_i0_valid_r,            // i0 valid inst at c\n\n   output el2_trap_pkt_t   dec_tlu_packet_r,              // trap packet\n\n   output logic [31:1] dec_tlu_i0_pc_r,               // i0 trap pc\n\n   output logic [31:0] dec_illegal_inst,              // illegal inst\n   output logic [31:1] pred_correct_npc_x,            // npc e2 if the prediction is correct\n\n   output el2_predict_pkt_t dec_i0_predict_p_d,      // i0 predict packet decode\n   output logic [pt.BHT_GHR_SIZE-1:0] i0_predict_fghr_d, // i0 predict fghr\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i0_predict_index_d, // i0 predict index\n   output logic [pt.BTB_BTAG_SIZE-1:0] i0_predict_btag_d, // i0_predict branch tag\n\n   output logic [$clog2(pt.BTB_SIZE)-1:0] dec_fa_error_index, // Fully associt btb error index\n\n   output logic [1:0] dec_data_en,                    // clock-gating logic\n   output logic [1:0] dec_ctl_en,\n\n   output logic       dec_pmu_instr_decoded,          // number of instructions decode this cycle encoded\n   output logic       dec_pmu_decode_stall,           // decode is stalled\n   output logic       dec_pmu_presync_stall,          // decode has presync stall\n   output logic       dec_pmu_postsync_stall,         // decode has postsync stall\n\n   output logic       dec_nonblock_load_wen,          // write enable for nonblock load\n   output logic [4:0] dec_nonblock_load_waddr,        // logical write addr for nonblock load\n   output logic       dec_pause_state,                // core in pause state\n   output logic       dec_pause_state_cg,             // pause state for clock-gating\n\n   output logic       dec_div_active,                 // non-block divide is active\n\n   input  logic       scan_mode\n   );\n\n\n\n\n   el2_dec_pkt_t           i0_dp_raw, i0_dp;\n\n   logic [31:0]        i0;\n   logic               i0_valid_d;\n\n   logic [31:0]        i0_result_r;\n\n   logic [2:0]         i0_rs1bypass, i0_rs2bypass;\n\n   logic               i0_jalimm20;\n   logic               i0_uiimm20;\n\n   logic               lsu_decode_d;\n   logic [31:0]        i0_immed_d;\n   logic               i0_presync;\n   logic               i0_postsync;\n\n   logic               postsync_stall;\n   logic               ps_stall;\n\n   logic               prior_inflight, prior_inflight_wb;\n\n   logic               csr_clr_d, csr_set_d, csr_write_d;\n\n   logic               csr_clr_x,csr_set_x,csr_write_x,csr_imm_x;\n   logic [31:0]        csr_mask_x;\n   logic [31:0]        write_csr_data_x;\n   logic [31:0]        write_csr_data_in;\n   logic [31:0]        write_csr_data;\n   logic               csr_data_wen;\n\n   logic [4:0]         csrimm_x;\n\n   logic [31:0]        csr_rddata_x;\n\n   logic               mul_decode_d;\n   logic               div_decode_d;\n   logic               div_e1_to_r;\n   logic               div_flush;\n   logic               div_active_in;\n   logic               div_active;\n   logic               i0_nonblock_div_stall;\n   logic               i0_div_prior_div_stall;\n   logic               nonblock_div_cancel;\n\n   logic               i0_legal;\n   logic               shift_illegal;\n   logic               illegal_inst_en;\n   logic               illegal_lockout_in, illegal_lockout;\n   logic               i0_legal_decode_d;\n   logic               i0_exulegal_decode_d, i0_exudecode_d, i0_exublock_d;\n\n   logic [12:1]        last_br_immed_d;\n   logic               i0_rs1_depend_i0_x, i0_rs1_depend_i0_r;\n   logic               i0_rs2_depend_i0_x, i0_rs2_depend_i0_r;\n\n   logic               i0_div_decode_d;\n   logic               i0_load_block_d;\n   logic [1:0]         i0_rs1_depth_d, i0_rs2_depth_d;\n\n   logic               i0_load_stall_d;\n   logic               i0_store_stall_d;\n\n   logic               i0_predict_nt, i0_predict_t;\n\n   logic               i0_notbr_error, i0_br_toffset_error;\n   logic               i0_ret_error;\n   logic               i0_br_error;\n   logic               i0_br_error_all;\n   logic [11:0]        i0_br_offset;\n\n   logic [20:1]        i0_pcall_imm;                          // predicted jal's\n   logic               i0_pcall_12b_offset;\n   logic               i0_pcall_raw;\n   logic               i0_pcall_case;\n   logic               i0_pcall;\n\n   logic               i0_pja_raw;\n   logic               i0_pja_case;\n   logic               i0_pja;\n\n   logic               i0_pret_case;\n   logic               i0_pret_raw, i0_pret;\n\n   logic               i0_jal;                                // jal's that are not predicted\n\n\n   logic               i0_predict_br;\n\n   logic               store_data_bypass_d, store_data_bypass_m;\n\n   el2_class_pkt_t         i0_rs1_class_d, i0_rs2_class_d;\n\n   el2_class_pkt_t         i0_d_c, i0_x_c, i0_r_c;\n\n\n   logic               i0_ap_pc2, i0_ap_pc4;\n\n   logic               i0_rd_en_d;\n\n   logic               load_ldst_bypass_d;\n\n   logic               leak1_i0_stall_in, leak1_i0_stall;\n   logic               leak1_i1_stall_in, leak1_i1_stall;\n   logic               leak1_mode;\n\n   logic               i0_csr_write_only_d;\n\n   logic               prior_inflight_x, prior_inflight_eff;\n   logic               any_csr_d;\n\n   logic               prior_csr_write;\n\n   logic [3:0]        i0_pipe_en;\n   logic              i0_r_ctl_en,  i0_x_ctl_en,  i0_wb_ctl_en;\n   logic              i0_x_data_en, i0_r_data_en, i0_wb_data_en;\n\n   logic              debug_fence_i;\n   logic              debug_fence;\n\n   logic              i0_csr_write;\n   logic              presync_stall;\n\n   logic              i0_instr_error;\n   logic              i0_icaf_d;\n\n   logic              clear_pause;\n   logic              pause_state_in, pause_state;\n   logic              pause_stall;\n\n   logic              i0_brp_valid;\n   logic              nonblock_load_cancel;\n   logic              lsu_idle;\n   logic              lsu_pmu_misaligned_r;\n   logic              csr_ren_qual_d;\n   logic              csr_read_x;\n   logic              i0_block_d;\n   logic              i0_block_raw_d;  // This is use to create the raw valid\n   logic              ps_stall_in;\n   logic [31:0]       i0_result_x;\n\n   el2_dest_pkt_t         d_d, x_d, r_d, wbd;\n   el2_dest_pkt_t         x_d_in, r_d_in;\n\n   el2_trap_pkt_t         d_t, x_t, x_t_in, r_t_in, r_t;\n\n   logic [3:0]        lsu_trigger_match_r;\n\n   logic [31:1]       dec_i0_pc_r;\n\n   logic csr_read, csr_write;\n   logic i0_br_unpred;\n\n   logic nonblock_load_valid_m_delay;\n   logic i0_wen_r;\n\n   logic tlu_wr_pause_r1;\n   logic tlu_wr_pause_r2;\n\n   logic flush_final_r;\n\n   logic bitmanip_zbb_legal;\n   logic bitmanip_zbs_legal;\n   logic bitmanip_zbe_legal;\n   logic bitmanip_zbc_legal;\n   logic bitmanip_zbp_legal;\n   logic bitmanip_zbr_legal;\n   logic bitmanip_zbf_legal;\n   logic bitmanip_zba_legal;\n   logic bitmanip_zbb_zbp_legal;\n   logic bitmanip_zbp_zbe_zbf_legal;\n   logic bitmanip_zbb_zbp_zbe_zbf_legal;\n   logic bitmanip_legal;\n\n   logic              data_gate_en;\n   logic              data_gate_clk;\n\n\n   localparam NBLOAD_SIZE     = pt.LSU_NUM_NBLOAD;\n   localparam NBLOAD_SIZE_MSB = int'(pt.LSU_NUM_NBLOAD)-1;\n   localparam NBLOAD_TAG_MSB  = pt.LSU_NUM_NBLOAD_WIDTH-1;\n\n\n   logic                     cam_write, cam_inv_reset, cam_data_reset;\n   logic [NBLOAD_TAG_MSB:0]  cam_write_tag, cam_inv_reset_tag, cam_data_reset_tag;\n   logic [NBLOAD_SIZE_MSB:0] cam_wen;\n\n   logic [NBLOAD_TAG_MSB:0]  load_data_tag;\n   logic [NBLOAD_SIZE_MSB:0] nonblock_load_write;\n\n   el2_load_cam_pkt_t [NBLOAD_SIZE_MSB:0] cam;\n   el2_load_cam_pkt_t [NBLOAD_SIZE_MSB:0] cam_in;\n   el2_load_cam_pkt_t [NBLOAD_SIZE_MSB:0] cam_raw;\n\n   logic [4:0] nonblock_load_rd;\n   logic i0_nonblock_load_stall;\n   logic i0_nonblock_boundary_stall;\n\n   logic i0_rs1_nonblock_load_bypass_en_d, i0_rs2_nonblock_load_bypass_en_d;\n\n   logic i0_load_kill_wen_r;\n\n   logic found;\n\n   logic [NBLOAD_SIZE_MSB:0] cam_inv_reset_val, cam_data_reset_val;\n\n   logic debug_fence_raw;\n\n   logic [31:0] i0_result_r_raw;\n   logic [31:0] i0_result_corr_r;\n\n   logic [12:1] last_br_immed_x;\n\n   logic [31:0]        i0_inst_d;\n   logic [31:0]        i0_inst_x;\n   logic [31:0]        i0_inst_r;\n   logic [31:0]        i0_inst_wb_in;\n   logic [31:0]        i0_inst_wb;\n\n   logic [31:1]        i0_pc_wb;\n\n   logic               i0_wb_en;\n\n   logic               trace_enable;\n\n   logic               debug_valid_x;\n\n   el2_inst_pkt_t i0_itype;\n   el2_reg_pkt_t i0r;\n\n\n   rvdffie  #(8) misc1ff (.*,\n                          .clk(free_l2clk),\n                          .din( {leak1_i1_stall_in,leak1_i0_stall_in,dec_tlu_flush_extint,pause_state_in ,dec_tlu_wr_pause_r, tlu_wr_pause_r1,illegal_lockout_in,ps_stall_in}),\n                          .dout({leak1_i1_stall,   leak1_i0_stall,   dec_extint_stall,    pause_state,       tlu_wr_pause_r1,tlu_wr_pause_r2,illegal_lockout,   ps_stall   })\n                          );\n\n   rvdffie  #(8) misc2ff (.*,\n                          .clk(free_l2clk),\n                          .din( {lsu_trigger_match_m[3:0],lsu_pmu_misaligned_m,div_active_in,exu_flush_final,  dec_debug_valid_d}),\n                          .dout({lsu_trigger_match_r[3:0],lsu_pmu_misaligned_r,div_active,       flush_final_r,    debug_valid_x})\n                          );\n\nif(pt.BTB_ENABLE==1) begin\n// branch prediction\n\n\n   // in leak1_mode, ignore any predictions for i0, treat branch as if we haven't seen it before\n   // in leak1 mode, also ignore branch errors for i0\n   assign i0_brp_valid                        =  dec_i0_brp.valid & ~leak1_mode & ~i0_icaf_d;\n\n   assign dec_i0_predict_p_d.misp        =  '0;\n   assign dec_i0_predict_p_d.ataken      =  '0;\n   assign dec_i0_predict_p_d.boffset     =  '0;\n\n   assign dec_i0_predict_p_d.pcall       =  i0_pcall;  // don't mark as pcall if branch error\n   assign dec_i0_predict_p_d.pja         =  i0_pja;\n   assign dec_i0_predict_p_d.pret        =  i0_pret;\n   assign dec_i0_predict_p_d.prett[31:1] =  dec_i0_brp.prett[31:1];\n   assign dec_i0_predict_p_d.pc4         =  dec_i0_pc4_d;\n   assign dec_i0_predict_p_d.hist[1:0]   =  dec_i0_brp.hist[1:0];\n   assign dec_i0_predict_p_d.valid       =  i0_brp_valid & i0_legal_decode_d;\n   assign i0_notbr_error                 =  i0_brp_valid & ~(i0_dp_raw.condbr | i0_pcall_raw | i0_pja_raw | i0_pret_raw);\n\n   // no toffset error for a pret\n   assign i0_br_toffset_error                               =  i0_brp_valid & dec_i0_brp.hist[1] & (dec_i0_brp.toffset[11:0] != i0_br_offset[11:0]) & ~i0_pret_raw;\n   assign i0_ret_error                                      =  i0_brp_valid & (dec_i0_brp.ret ^ i0_pret_raw);\n   assign i0_br_error                                       =  dec_i0_brp.br_error | i0_notbr_error | i0_br_toffset_error | i0_ret_error;\n   assign dec_i0_predict_p_d.br_error                       =  i0_br_error & i0_legal_decode_d & ~leak1_mode;\n   assign dec_i0_predict_p_d.br_start_error                 =  dec_i0_brp.br_start_error & i0_legal_decode_d & ~leak1_mode;\n   assign i0_predict_index_d[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] =  dec_i0_bp_index;\n\n   assign i0_predict_btag_d[pt.BTB_BTAG_SIZE-1:0]           =  dec_i0_bp_btag[pt.BTB_BTAG_SIZE-1:0];\n   assign i0_br_error_all                                   = (i0_br_error | dec_i0_brp.br_start_error) & ~leak1_mode"}
{"text": ";\n   assign dec_i0_predict_p_d.toffset[11:0]                  =  i0_br_offset[11:0];\n   assign i0_predict_fghr_d[pt.BHT_GHR_SIZE-1:0]            =  dec_i0_bp_fghr[pt.BHT_GHR_SIZE-1:0];\n   assign dec_i0_predict_p_d.way                            =  dec_i0_brp.way;\n\n\n   if(pt.BTB_FULLYA) begin\n      logic btb_error_found, btb_error_found_f;\n      logic [$clog2(pt.BTB_SIZE)-1:0] fa_error_index_ns;\n\n      assign btb_error_found = (i0_br_error_all | btb_error_found_f) & ~dec_tlu_flush_lower_r;\n      assign fa_error_index_ns = (i0_br_error_all & ~btb_error_found_f) ? dec_i0_bp_fa_index : dec_fa_error_index;\n\n      rvdff #($clog2(pt.BTB_SIZE)+1) btberrorfa_f   (.*, .clk(active_clk),\n                                                         .din({btb_error_found,    fa_error_index_ns}),\n                                                         .dout({btb_error_found_f, dec_fa_error_index}));\n\n\n   end\n   else\n     assign dec_fa_error_index = 'b0;\n\n\n   //   end\nend // if (pt.BTB_ENABLE==1)\nelse begin\n\n   always_comb begin\n      dec_i0_predict_p_d = '0;\n      dec_i0_predict_p_d.pcall       =  i0_pcall;  // don't mark as pcall if branch error\n      dec_i0_predict_p_d.pja         =  i0_pja;\n      dec_i0_predict_p_d.pret        =  i0_pret;\n      dec_i0_predict_p_d.pc4         =  dec_i0_pc4_d;\n   end\n\n   assign i0_br_error_all = '0;\n   assign i0_predict_index_d = '0;\n   assign i0_predict_btag_d = '0;\n   assign i0_predict_fghr_d = '0;\n   assign i0_brp_valid = '0;\nend // else: !if(pt.BTB_ENABLE==1)\n\n   // on br error turn anything into a nop\n   // on i0 instruction fetch access fault turn anything into a nop\n   // nop =>   alu rs1 imm12 rd lor\n\n   assign i0_icaf_d = dec_i0_icaf_d | dec_i0_dbecc_d;\n\n   assign i0_instr_error = i0_icaf_d;\n\n   always_comb begin\n      i0_dp = i0_dp_raw;\n      if (i0_br_error_all | i0_instr_error) begin\n         i0_dp          =   '0;\n         i0_dp.alu      = 1'b1;\n         i0_dp.rs1      = 1'b1;\n         i0_dp.rs2      = 1'b1;\n         i0_dp.lor      = 1'b1;\n         i0_dp.legal    = 1'b1;\n         i0_dp.postsync = 1'b1;\n      end\n   end\n\n   assign i0[31:0] = dec_i0_instr_d[31:0];\n\n   assign dec_i0_select_pc_d = i0_dp.pc;\n\n   // branches that can be predicted\n\n   assign i0_predict_br =  i0_dp.condbr | i0_pcall | i0_pja | i0_pret;\n\n   assign i0_predict_nt = ~(dec_i0_brp.hist[1] & i0_brp_valid) & i0_predict_br;\n   assign i0_predict_t  =  (dec_i0_brp.hist[1] & i0_brp_valid) & i0_predict_br;\n\n   assign i0_ap.add     =  i0_dp.add;\n   assign i0_ap.sub     =  i0_dp.sub;\n   assign i0_ap.land    =  i0_dp.land;\n   assign i0_ap.lor     =  i0_dp.lor;\n   assign i0_ap.lxor    =  i0_dp.lxor;\n   assign i0_ap.sll     =  i0_dp.sll;\n   assign i0_ap.srl     =  i0_dp.srl;\n   assign i0_ap.sra     =  i0_dp.sra;\n   assign i0_ap.slt     =  i0_dp.slt;\n   assign i0_ap.unsign  =  i0_dp.unsign;\n   assign i0_ap.beq     =  i0_dp.beq;\n   assign i0_ap.bne     =  i0_dp.bne;\n   assign i0_ap.blt     =  i0_dp.blt;\n   assign i0_ap.bge     =  i0_dp.bge;\n\n   assign i0_ap.clz     =  i0_dp.clz;\n   assign i0_ap.ctz     =  i0_dp.ctz;\n   assign i0_ap.cpop    =  i0_dp.cpop;\n   assign i0_ap.sext_b  =  i0_dp.sext_b;\n   assign i0_ap.sext_h  =  i0_dp.sext_h;\n   assign i0_ap.sh1add  =  i0_dp.sh1add;\n   assign i0_ap.sh2add  =  i0_dp.sh2add;\n   assign i0_ap.sh3add  =  i0_dp.sh3add;\n   assign i0_ap.zba     =  i0_dp.zba;\n   assign i0_ap.min     =  i0_dp.min;\n   assign i0_ap.max     =  i0_dp.max;\n   assign i0_ap.pack    =  i0_dp.pack;\n   assign i0_ap.packu   =  i0_dp.packu;\n   assign i0_ap.packh   =  i0_dp.packh;\n   assign i0_ap.rol     =  i0_dp.rol;\n   assign i0_ap.ror     =  i0_dp.ror;\n   assign i0_ap.grev    =  i0_dp.grev;\n   assign i0_ap.gorc    =  i0_dp.gorc;\n   assign i0_ap.zbb     =  i0_dp.zbb;\n   assign i0_ap.bset    =  i0_dp.bset;\n   assign i0_ap.bclr    =  i0_dp.bclr;\n   assign i0_ap.binv    =  i0_dp.binv;\n   assign i0_ap.bext    =  i0_dp.bext;\n\n   assign i0_ap.csr_write =  i0_csr_write_only_d;\n   assign i0_ap.csr_imm   =  i0_dp.csr_imm;\n   assign i0_ap.jal       =  i0_jal;\n\n   assign i0_ap_pc2 = ~dec_i0_pc4_d;\n   assign i0_ap_pc4 =  dec_i0_pc4_d;\n\n   assign i0_ap.predict_nt = i0_predict_nt;\n   assign i0_ap.predict_t  = i0_predict_t;\n\n\n// non block load cam logic\n\n   always_comb begin\n      found = 0;\n      for (int i=0; i<NBLOAD_SIZE; i++) begin\n         if (~found) begin\n            if (~cam[i].valid) begin\n               cam_wen[i] = cam_write;\n               found = 1'b1;\n            end\n            else begin\n               cam_wen[i] = 0;\n            end\n         end\n         else\n            cam_wen[i] = 0;\n      end\n   end\n\n   assign cam_write          = lsu_nonblock_load_valid_m;\n   assign cam_write_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_tag_m[NBLOAD_TAG_MSB:0];\n\n   assign cam_inv_reset          = lsu_nonblock_load_inv_r;\n   assign cam_inv_reset_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_inv_tag_r[NBLOAD_TAG_MSB:0];\n\n   assign cam_data_reset          = lsu_nonblock_load_data_valid | lsu_nonblock_load_data_error;\n   assign cam_data_reset_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_data_tag[NBLOAD_TAG_MSB:0];\n\n   assign nonblock_load_rd[4:0] = (x_d.i0load) ? x_d.i0rd[4:0] : 5'b0;  // rd data\n\n\n   // checks\n\n`ifdef RV_ASSERT_ON\n   assert_dec_data_valid_data_error_onehot:    assert #0 ($onehot0({lsu_nonblock_load_data_valid,lsu_nonblock_load_data_error}));\n   assert_dec_cam_inv_reset_onehot:            assert #0 ($onehot0(cam_inv_reset_val[NBLOAD_SIZE_MSB:0]));\n   assert_dec_cam_data_reset_onehot:           assert #0 ($onehot0(cam_data_reset_val[NBLOAD_SIZE_MSB:0]));\n`endif\n\n\n\n    // case of multiple loads to same dest ie. x1 ... you have to invalidate the older one\n\n   for (genvar i=0; i<NBLOAD_SIZE; i++) begin : cam_array\n\n      assign cam_inv_reset_val[i] = cam_inv_reset   & (cam_inv_reset_tag[NBLOAD_TAG_MSB:0]  == cam[i].tag[NBLOAD_TAG_MSB:0]) & cam[i].valid;\n\n      assign cam_data_reset_val[i] = cam_data_reset & (cam_data_reset_tag[NBLOAD_TAG_MSB:0] == cam_raw[i].tag[NBLOAD_TAG_MSB:0]) & cam_raw[i].valid;\n\n      always_comb begin\n\n         cam[i] = cam_raw[i];\n\n         if (cam_data_reset_val[i])\n           cam[i].valid = 1'b0;\n\n         cam_in[i] = '0;\n\n         if (cam_wen[i]) begin\n            cam_in[i].valid    = 1'b1;\n            cam_in[i].wb       = 1'b0;\n            cam_in[i].tag[NBLOAD_TAG_MSB:0] = cam_write_tag[NBLOAD_TAG_MSB:0];\n            cam_in[i].rd[4:0]  = nonblock_load_rd[4:0];\n         end\n         else if ( (cam_inv_reset_val[i]) |\n                   (i0_wen_r & (r_d_in.i0rd[4:0] == cam[i].rd[4:0]) & cam[i].wb) )\n           cam_in[i].valid = 1'b0;\n         else\n           cam_in[i] = cam[i];\n\n         if (nonblock_load_valid_m_delay & (lsu_nonblock_load_inv_tag_r[NBLOAD_TAG_MSB:0]==cam[i].tag[NBLOAD_TAG_MSB:0]) & cam[i].valid)\n           cam_in[i].wb = 1'b1;\n\n         // force debug halt forces cam valids to 0; highest priority\n         if (dec_tlu_force_halt)\n           cam_in[i].valid = 1'b0;\n      end\n\n\n   rvdffie #( $bits(el2_load_cam_pkt_t) ) cam_ff (.*, .din(cam_in[i]), .dout(cam_raw[i]));\n\n\n   assign nonblock_load_write[i] = (load_data_tag[NBLOAD_TAG_MSB:0] == cam_raw[i].tag[NBLOAD_TAG_MSB:0]) & cam_raw[i].valid;\n\n\nend : cam_array\n\n\n\n   assign load_data_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_data_tag[NBLOAD_TAG_MSB:0];\n\n`ifdef RV_ASSERT_ON\n   assert_dec_cam_nonblock_load_write_onehot:   assert #0 ($onehot0(nonblock_load_write[NBLOAD_SIZE_MSB:0]));\n`endif\n\n\n   assign nonblock_load_cancel = ((r_d_in.i0rd[4:0] == dec_nonblock_load_waddr[4:0]) & i0_wen_r);     // cancel if any younger inst (including another nonblock) committing this cycle\n\n\n   assign dec_nonblock_load_wen = lsu_nonblock_load_data_valid & |nonblock_load_write[NBLOAD_SIZE_MSB:0] & ~nonblock_load_cancel;\n\n   always_comb begin\n\n      dec_nonblock_load_waddr[4:0] = '0;\n      i0_nonblock_load_stall = i0_nonblock_boundary_stall;\n\n      for (int i=0; i<NBLOAD_SIZE; i++) begin\n         dec_nonblock_load_waddr[4:0] |= ({5{nonblock_load_write[i]}} & cam[i].rd[4:0]);\n         i0_nonblock_load_stall |= dec_i0_rs1_en_d & cam[i].valid & (cam[i].rd[4:0] == i0r.rs1[4:0]);\n         i0_nonblock_load_stall |= dec_i0_rs2_en_d & cam[i].valid & (cam[i].rd[4:0] == i0r.rs2[4:0]);\n      end\n\n   end\n\n   assign i0_nonblock_boundary_stall = ((nonblock_load_rd[4:0]==i0r.rs1[4:0]) & lsu_nonblock_load_valid_m & dec_i0_rs1_en_d) |\n                                       ((nonblock_load_rd[4:0]==i0r.rs2[4:0]) & lsu_nonblock_load_valid_m & dec_i0_rs2_en_d);\n\n\n\n// don't writeback a nonblock load\n\n   rvdffs #(1) wbnbloaddelayff (.*, .clk(active_clk), .en(i0_r_ctl_en ), .din(lsu_nonblock_load_valid_m),        .dout(nonblock_load_valid_m_delay) );\n\n   assign i0_load_kill_wen_r = nonblock_load_valid_m_delay &  r_d.i0load;\n\n\n\n// end non block load cam logic\n\n// pmu start\n\n\n\n\n   assign csr_read = csr_ren_qual_d;\n   assign csr_write = dec_csr_wen_unq_d;\n\n   assign i0_br_unpred = i0_dp.jal & ~i0_predict_br;\n\n   // the classes must be mutually exclusive with one another\n\n   always_comb begin\n      i0_itype = NULL;\n\n      if (i0_legal_decode_d) begin\n         if (i0_dp.mul)                  i0_itype = MUL;\n         if (i0_dp.load)                 i0_itype = LOAD;\n         if (i0_dp.store)                i0_itype = STORE;\n         if (i0_dp.pm_alu)               i0_itype = ALU;\n         if (i0_dp.zbb | i0_dp.zbs |\n             i0_dp.zbe | i0_dp.zbc |\n             i0_dp.zbp | i0_dp.zbr |\n             i0_dp.zbf | i0_dp.zba)\n                                         i0_itype = BITMANIPU;\n         if ( csr_read & ~csr_write)     i0_itype = CSRREAD;\n         if (~csr_read &  csr_write)     i0_itype = CSRWRITE;\n         if ( csr_read &  csr_write)     i0_itype = CSRRW;\n         if (i0_dp.ebreak)               i0_itype = EBREAK;\n         if (i0_dp.ecall)                i0_itype = ECALL;\n         if (i0_dp.fence)                i0_itype = FENCE;\n         if (i0_dp.fence_i)              i0_itype = FENCEI;  // fencei will set this even with fence attribute\n         if (i0_dp.mret)                 i0_itype = MRET;\n         if (i0_dp.condbr)               i0_itype = CONDBR;\n         if (i0_dp.jal)                  i0_itype = JAL;\n      end\n   end\n\n\n\n\n\n// end pmu\n\n\n   el2_dec_dec_ctl i0_dec (.inst(i0[31:0]),.out(i0_dp_raw));\n\n\n\n\n   rvdff #(1) lsu_idle_ff (.*, .clk(active_clk), .din(lsu_idle_any), .dout(lsu_idle));\n\n\n\n   assign leak1_i1_stall_in = (dec_tlu_flush_leak_one_r | (leak1_i1_stall & ~dec_tlu_flush_lower_r));\n\n\n   assign leak1_mode = leak1_i1_stall;\n\n   assign leak1_i0_stall_in = ((dec_i0_decode_d & leak1_i1_stall) | (leak1_i0_stall & ~dec_tlu_flush_lower_r));\n\n\n\n\n   // 12b jal's can be predicted - these are calls\n\n   assign i0_pcall_imm[20:1] = {i0[31],i0[19:12],i0[20],i0[30:21]};\n\n   assign i0_pcall_12b_offset = (i0_pcall_imm[12]) ? (i0_pcall_imm[20:13] == 8'hff) : (i0_pcall_imm[20:13] == 8'h0);\n\n   assign i0_pcall_case  = i0_pcall_12b_offset & i0_dp_raw.imm20 &  (i0r.rd[4:0] == 5'd1 | i0r.rd[4:0] == 5'd5);\n   assign i0_pja_case    = i0_pcall_12b_offset & i0_dp_raw.imm20 & ~(i0r.rd[4:0] == 5'd1 | i0r.rd[4:0] == 5'd5);\n\n   assign i0_pcall_raw   = i0_dp_raw.jal &   i0_pcall_case;   // this includes ja\n   assign i0_pcall       = i0_dp.jal     &   i0_pcall_case;\n\n   assign i0_pja_raw     = i0_dp_raw.jal &   i0_pja_case;\n   assign i0_pja         = i0_dp.jal     &   i0_pja_case;\n\n\n   assign i0_br_offset[11:0] = (i0_pcall_raw | i0_pja_raw) ? i0_pcall_imm[12:1] : {i0[31],i0[7],i0[30:25],i0[11:8]};\n\n   assign i0_pret_case = (i0_dp_raw.jal & i0_dp_raw.imm12 & (i0r.rd[4:0] == 5'b0) & (i0r.rs1[4:0] == 5'd1 | i0r.rs1[4:0] == 5'd5));  // jalr with rd==0, rs1==1 or rs1==5 is a ret\n\n   assign i0_pret_raw = i0_dp_raw.jal &   i0_pret_case;\n   assign i0_pret     = i0_dp.jal     &   i0_pret_case;\n\n   assign i0_jal      = i0_dp.jal     &  ~i0_pcall_case & ~i0_pja_case & ~i0_pret_case;\n\n   // lsu stuff\n   // load/store mutually exclusive\n   assign dec_lsu_offset_d[11:0] = ({12{ ~dec_extint_stall & i0_dp.lsu & i0_dp.load}} &               i0[31:20]) |\n                                   ({12{ ~dec_extint_stall & i0_dp.lsu & i0_dp.store}} &             {i0[31:25],i0[11:7]});\n\n\n\n   assign div_p.valid    =  div_decode_d;\n\n   assign div_p.unsign   =  i0_dp.unsign;\n   assign div_p.rem      =  i0_dp.rem;\n\n\n   assign mul_p.valid    =  mul_decode_d;\n\n   assign mul_p.rs1_sign     =  i0_dp.rs1_sign;\n   assign mul_p.rs2_sign     =  i0_dp.rs2_sign;\n   assign mul_p.low          =  i0_dp.low;\n   assign mul_p.bcompress    =  i0_dp.bcompress;\n   assign mul_p.bdecompress  =  i0_dp.bdecompress;\n   assign mul_p.clmul        =  i0_dp.clmul;\n   assign mul_p.clmulh       =  i0_dp.clmulh;\n   assign mul_p.clmulr       =  i0_dp.clmulr;\n   assign mul_p.grev         =  i0_dp.grev;\n   assign mul_p.gorc         =  i0_dp.gorc;\n   assign mul_p.shfl         =  i0_dp.shfl;\n   assign mul_p.unshfl       =  i0_dp.unshfl;\n   assign mul_p.xperm_n      =  i0_dp.xperm_n;\n   assign mul_p.xperm_b      =  i0_dp.xperm_b;\n   assign mul_p.xperm_h      =  i0_dp.xperm_h;\n   assign mul_p.crc32_b      =  i0_dp.crc32_b;\n   assign mul_p.crc32_h      =  i0_dp.crc32_h;\n   assign mul_p.crc32_w      =  i0_dp.crc32_w;\n   assign mul_p.crc32c_b     =  i0_dp.crc32c_b;\n   assign mul_p.crc32c_h     =  i0_dp.crc32c_h;\n   assign mul_p.crc32c_w     =  i0_dp.crc32c_w;\n   assign mul_p.bfp          =  i0_dp.bfp;\n\n\n   always_comb  begin\n      lsu_p = '0;\n\n      if (dec_extint_stall) begin\n         lsu_p.load = 1'b1;\n         lsu_p.word = 1'b1;\n         lsu_p.fast_int = 1'b1;\n         lsu_p.valid = 1'b1;\n      end\n      else begin\n         lsu_p.valid = lsu_decode_d;\n\n         lsu_p.load                         =  i0_dp.load ;\n         lsu_p.store                        =  i0_dp.store;\n         lsu_p.by                           =  i0_dp.by   ;\n         lsu_p.half                         =  i0_dp.half ;\n         lsu_p.word                         =  i0_dp.word ;\n         lsu_p.stack                        = (i0r.rs1[4:0]==5'd2);   // stack reference\n\n         lsu_p.load_ldst_bypass_d          =  load_ldst_bypass_d ;\n         lsu_p.store_data_bypass_d         =  store_data_bypass_d;\n         lsu_p.store_data_bypass_m         =  store_data_bypass_m;\n\n         lsu_p.unsign  =  i0_dp.unsign;\n      end\n   end\n\n\n   assign  dec_lsu_valid_raw_d    = (i0_valid_d & (i0_dp_raw.load | i0_dp_raw.store) & ~dma_dccm_stall_any & ~i0_block_raw_d) | dec_extint_stall;\n\n\n\n   assign i0r.rs1[4:0] = i0[19:15];\n   assign i0r.rs2[4:0] = i0[24:20];\n   assign i0r.rd[4:0]  = i0[11:7];\n\n\n   assign dec_i0_rs1_en_d   =  i0_dp.rs1 & (i0r.rs1[4:0] != 5'd0);  // if rs1_en=0 then read will be all 0's\n   assign dec_i0_rs2_en_d   =  i0_dp.rs2 & (i0r.rs2[4:0] != 5'd0);\n   assign i0_rd_en_d        =  i0_dp.rd  & (i0r.rd[4:0]  != 5'd0);\n\n   assign dec_i0_rs1_d[4:0] =  i0r.rs1[4:0];\n   assign dec_i0_rs2_d[4:0] =  i0r.rs2[4:0];\n\n\n   assign i0_jalimm20       =  i0_dp.jal & i0_dp.imm20;   // jal\n   assign i0_uiimm20        = ~i0_dp.jal & i0_dp.imm20;\n\n\n   // csr logic\n\n   assign dec_csr_ren_d  = i0_dp.csr_read & i0_valid_d;\n   assign csr_ren_qual_d = i0_dp.csr_read & i0_legal_decode_d;\n\n   assign csr_clr_d =   i0_dp.csr_clr   & i0_legal_decode_d;\n   assign csr_set_d   = i0_dp.csr_set   & i0_legal_decode_d;\n   assign csr_write_d = i0_csr_write    & i0_legal_decode_d;\n\n   assign i0_csr_write_only_d = i0_csr_write & ~i0_dp.csr_read;\n\n   assign dec_csr_wen_unq_d = (i0_dp.csr_clr | i0_dp.csr_set | i0_csr_write) & i0_valid_d;   // for csr legal, can't write read-only csr\n\n   assign dec_csr_any_unq_d = any_csr_d & i0_valid_d;\n\n\n   assign dec_csr_rdaddr_d[11:0] =  {12{dec_csr_any_unq_d}} & i0[31:20];\n   assign dec_csr_wraddr_r[11:0] =  {12{r_d.csrwen & r_d.i0valid}} & r_d.csrwaddr[11:0];\n\n\n   // make sure csr doesn't write same cycle as dec_tlu_flush_lower_wb\n   // also use valid so it's flushable\n   assign dec_csr_wen_r = r_d.csrwen & r_d.i0valid & ~dec_tlu_i0_kill_writeb_r;\n\n   // If we are writing MIE or MSTATUS, hold off the external interrupt for a cycle on the write.\n   assign dec_csr_stall_int_ff = ((r_d.csrwaddr[11:0] == 12'h300) | (r_d.csrwaddr[11:0] == 12'h304)) & r_d.csrwen & r_d.i0valid & ~dec_tlu_i0_kill_writeb_wb;\n\n\n   rvdff #(5) csrmiscff (.*,\n                        .clk (active_clk),\n                        .din ({csr_ren_qual_d, csr_clr_d, csr_set_d, csr_write_d, i0_dp.csr_imm}),\n                        .dout({csr_read_x,     csr_clr_x, csr_set_x, csr_write_x, csr_imm_x})\n                       );\n\n\n\n\n   // perform the update operation if any\n\n   rvdffe #(37) csr_rddata_x_ff (.*, .en(i0_x_data_en & any_csr_d), .din( {i0[19:15],dec_csr_rddata_d[31:0]}), .dout({csrimm_x[4:0],csr_rddata_x[31:0]}));\n\n\n   assign csr_mask_x[31:0]       = ({32{ csr_imm_x}} & {27'b0,csrimm_x[4:0]}) |\n                                   ({32{~csr_imm_x}} &  exu_csr_rs1_x[31:0] );\n\n\n   assign write_csr_data_x[31:0] = ({32{csr_clr_x}}   & (csr_rddata_x[31:0] & ~csr_mask_x[31:0])) |\n                                   ({32{csr_set_x}}   & (csr_rddata_x[31:0] |  csr_mask_x[31:0])) |\n                                   ({32{csr_write_x}} & (                      csr_mask_x[31:0]));\n\n\n// pause instruction\n\n\n\n\n   assign clear_pause = (dec_tlu_flush_lower_r & ~dec_tlu_flush_pause_r) |\n                        (pause_state & (write_csr_data[31:1] == 31'b0));        // if 0 or 1 then exit pause state - 1 cycle pause\n\n   assign pause_state_in = (dec_tlu_wr_pause_r | pause_state) & ~clear_pause;\n\n\n\n   assign dec_pause_state = pause_state;\n\n\n\n      assign dec_pause_state_cg = pause_state & ~tlu_wr_pause_r1 & ~tlu_wr_pause_r2;\n\n// end pause\n\n\n   assign csr_data_wen = ((csr_clr_x | csr_set_x | csr_write_x) & csr_read_x) | dec_tlu_wr_pause_r | pause_state;\n\n   assign write_csr_data_in[31:0] = (pause_state)         ? (write_csr_data[31:0] - 32'b1) :\n                                    (dec_tlu_wr_pause_r) ? dec_csr_wrdata_r[31:0] : write_csr_data_x[31:0];\n\n   // will hold until write-back at which time the CSR will be updated while GPR is possibly written with prior CSR\n   rvdffe #(32) write_csr_ff (.*, .clk(free_l2clk), .en(csr_data_wen), .din(write_csr_data_in[31:0]), .dout(write_csr_data[31:0]));\n\n   assign pause_stall = pause_state;\n\n   // for csr write only data is produced by the alu\n   assign dec_csr_wrdata_r[31:0]  = (r_d.csrwonly & r_d.i0valid) ? i0_result_corr_r[31:0] : write_csr_data[31:0];\n\n\n\n   assign dec_i0_immed_d[31:0] =  i0_immed_d[31:0];\n\n   assign     i0_immed_d[31:0] = ({32{i0_dp.imm12}}                         & { {20{i0[31]}},i0[31:20] }) |  // jalr\n                                 ({32{i0_dp.shimm5}}                        & {  27'b0,      i0[24:20] }) |\n                                 ({32{i0_jalimm20}}                         & { {12{i0[31]}},i0[19:12],i0[20],i0[30:21],1'b0}) |\n                                 ({32{i0_uiimm20}}                          & { i0[31:12],12'b0 }) |\n                                 ({32{i0_csr_write_only_d & i0_dp.csr_imm}} & {  27'b0,      i0[19:15]});  // for csr's that only write csr, dont read csr\n\n\n   // all conditional branches are currently predict_nt\n   // change this to generate the sequential address for all other cases for NPC requirements at commit\n   assign dec_i0_br_immed_d[12:1] = (i0_ap.predict_nt & ~i0_dp.jal) ? i0_br_offset[11:0] : {10'b0,i0_ap_pc4,i0_ap_pc2};\n\n\n   assign last_br_immed_d[12:1] = ((i0_ap.predict_nt) ? {10'b0,i0_ap_pc4,i0_ap_pc2} : i0_br_offset[11:0] );\n\n   assign i0_valid_d = dec_ib0_valid_d;\n\n   // load_stall includes bus_barrier\n\n   assign i0_load_stall_d = (i0_dp.load ) & (lsu_load_stall_any | dma_dccm_stall_any);\n\n   assign i0_store_stall_d =  i0_dp.store & (lsu_store_stall_any | dma_dccm_stall_any);\n\n\n\n// some CSR reads need to be presync'd\n   assign i0_presync = i0_dp.presync | dec_tlu_presync_d | debug_fence_i | debug_fence_raw | dec_tlu_pipelining_disable;  // both fence's presync\n\n// some CSR writes need to be postsync'd\n   assign i0_postsync = i0_dp.postsync | dec_tlu_postsync_d | debug_fence_i | // only fence_i postsync\n                        (i0_csr_write_only_d & (i0[3"}
{"text": "1:20] == 12'h7c2));   // wr_pause must postsync\n\n\n// debug fence csr\n   assign debug_fence_i     = dec_debug_fence_d & dbg_cmd_wrdata[0];\n   assign debug_fence_raw   = dec_debug_fence_d & dbg_cmd_wrdata[1];\n\n   assign debug_fence       = debug_fence_raw | debug_fence_i;    // fence_i causes a fence\n\n   assign i0_csr_write = i0_dp.csr_write & ~dec_debug_fence_d;\n// end debug\n\n\n   // lets make ebreak, ecall, mret postsync, so break sync into pre and post\n\n   assign presync_stall      = (i0_presync & prior_inflight_eff);\n\n   assign prior_inflight_eff = (i0_dp.div)  ?  prior_inflight_x  :  prior_inflight;\n\n   assign i0_div_prior_div_stall = i0_dp.div & div_active;\n\n   // Raw block has everything excepts the stalls coming from the lsu\n   assign i0_block_raw_d = (i0_dp.csr_read & prior_csr_write) |\n                            dec_extint_stall |\n                            pause_stall |\n                            leak1_i0_stall |\n                            dec_tlu_debug_stall |\n                            postsync_stall |\n                            presync_stall  |\n                            ((i0_dp.fence | debug_fence) & ~lsu_idle) |\n                            i0_nonblock_load_stall |\n                            i0_load_block_d |\n                            i0_nonblock_div_stall |\n                            i0_div_prior_div_stall;\n\n   assign i0_block_d    = i0_block_raw_d | i0_store_stall_d | i0_load_stall_d;\n   assign i0_exublock_d = i0_block_raw_d;\n\n\n   // block reads if there is a prior csr write in the pipeline\n   assign prior_csr_write = x_d.csrwonly |\n                            r_d.csrwonly |\n                            wbd.csrwonly;\n\n\n\n   if       (pt.BITMANIP_ZBB == 1)\n     assign bitmanip_zbb_legal              =  1'b1;\n   else\n     assign bitmanip_zbb_legal              = ~(i0_dp.zbb & ~i0_dp.zbp);\n\n   if       (pt.BITMANIP_ZBS == 1)\n     assign bitmanip_zbs_legal              =  1'b1;\n   else\n     assign bitmanip_zbs_legal              = ~i0_dp.zbs;\n\n   if       (pt.BITMANIP_ZBE == 1)\n     assign bitmanip_zbe_legal              =  1'b1;\n   else\n     assign bitmanip_zbe_legal              = ~(i0_dp.zbe & ~i0_dp.zbp & ~i0_dp.zbf);\n\n   if       (pt.BITMANIP_ZBC == 1)\n     assign bitmanip_zbc_legal              =  1'b1;\n   else\n     assign bitmanip_zbc_legal              = ~i0_dp.zbc;\n\n   if       (pt.BITMANIP_ZBP == 1)\n     assign bitmanip_zbp_legal              =  1'b1;\n   else\n     assign bitmanip_zbp_legal              = ~(i0_dp.zbp & ~i0_dp.zbb & ~i0_dp.zbe & ~i0_dp.zbf);\n\n   if       (pt.BITMANIP_ZBR == 1)\n     assign bitmanip_zbr_legal              =  1'b1;\n   else\n     assign bitmanip_zbr_legal              = ~i0_dp.zbr;\n\n   if       (pt.BITMANIP_ZBF == 1)\n     assign bitmanip_zbf_legal              =  1'b1;\n   else\n     assign bitmanip_zbf_legal              = ~(i0_dp.zbf & ~i0_dp.zbp & ~i0_dp.zbe);\n\n   if (pt.BITMANIP_ZBA == 1)\n     assign bitmanip_zba_legal              =  1'b1;\n   else\n     assign bitmanip_zba_legal              = ~i0_dp.zba;\n\n   if     ( (pt.BITMANIP_ZBB == 1) | (pt.BITMANIP_ZBP == 1) )\n     assign bitmanip_zbb_zbp_legal          =  1'b1;\n   else\n     assign bitmanip_zbb_zbp_legal          = ~(i0_dp.zbb & i0_dp.zbp & ~i0_dp.zbf);                                  // added ~ZBF to exclude ZEXT.H\n\n   if     ( (pt.BITMANIP_ZBP == 1) | (pt.BITMANIP_ZBE == 1)  | (pt.BITMANIP_ZBF == 1))\n     assign bitmanip_zbp_zbe_zbf_legal      =  1'b1;\n   else\n     assign bitmanip_zbp_zbe_zbf_legal      = ~(i0_dp.zbp & i0_dp.zbe &  i0_dp.zbf & ~i0_dp.zbb);                     // added ~ZBB to exclude ZEXT.H\n\n   if     ( (pt.BITMANIP_ZBB == 1) | (pt.BITMANIP_ZBP == 1) | (pt.BITMANIP_ZBE == 1)  | (pt.BITMANIP_ZBF == 1))\n     assign bitmanip_zbb_zbp_zbe_zbf_legal  =  1'b1;\n   else\n     assign bitmanip_zbb_zbp_zbe_zbf_legal  = ~(i0_dp.zbp & i0_dp.zbe &  i0_dp.zbf &  i0_dp.zbb);                     // added only for ZEXT.H\n\n\n   assign any_csr_d      =  i0_dp.csr_read | i0_csr_write;\n   assign bitmanip_legal =  bitmanip_zbb_legal & bitmanip_zbs_legal & bitmanip_zbe_legal & bitmanip_zbc_legal & bitmanip_zbp_legal & bitmanip_zbr_legal & bitmanip_zbf_legal & bitmanip_zba_legal & bitmanip_zbb_zbp_legal & bitmanip_zbp_zbe_zbf_legal &  bitmanip_zbb_zbp_zbe_zbf_legal;\n\n   assign i0_legal       =  i0_dp.legal & (~any_csr_d | dec_csr_legal_d) & bitmanip_legal;\n\n\n\n   // illegal inst handling\n\n\n   assign shift_illegal      = dec_i0_decode_d & ~i0_legal;\n\n   assign illegal_inst_en    = shift_illegal & ~illegal_lockout;\n\n   rvdffe #(32) illegal_any_ff (.*, .en(illegal_inst_en), .din(i0_inst_d[31:0]), .dout(dec_illegal_inst[31:0]));\n\n   assign illegal_lockout_in = (shift_illegal | illegal_lockout) & ~flush_final_r;\n\n\n\n   // allow illegals to flow down the pipe\n   assign dec_i0_decode_d = i0_valid_d & ~i0_block_d    & ~dec_tlu_flush_lower_r & ~flush_final_r;\n   assign i0_exudecode_d  = i0_valid_d & ~i0_exublock_d & ~dec_tlu_flush_lower_r & ~flush_final_r;\n\n   // define i0 legal decode\n   assign i0_legal_decode_d    = dec_i0_decode_d & i0_legal;\n   assign i0_exulegal_decode_d = i0_exudecode_d  & i0_legal;\n\n\n   // performance monitor signals\n   assign dec_pmu_instr_decoded = dec_i0_decode_d;\n\n   assign dec_pmu_decode_stall = i0_valid_d & ~dec_i0_decode_d;\n\n   assign dec_pmu_postsync_stall = postsync_stall & i0_valid_d;\n   assign dec_pmu_presync_stall  = presync_stall & i0_valid_d;\n\n\n\n   // illegals will postsync\n   assign ps_stall_in =  ( dec_i0_decode_d & (i0_postsync | ~i0_legal) ) |\n                         ( ps_stall & prior_inflight_x                 );\n\n\n\n   assign postsync_stall =  ps_stall;\n\n\n   assign prior_inflight_x    =  x_d.i0valid;\n   assign prior_inflight_wb   =  r_d.i0valid;\n\n   assign prior_inflight = prior_inflight_x | prior_inflight_wb;\n\n   assign dec_i0_alu_decode_d = i0_exulegal_decode_d & i0_dp.alu;\n   assign dec_i0_branch_d     = i0_dp.condbr | i0_dp.jal | i0_br_error_all;\n\n   assign lsu_decode_d = i0_legal_decode_d    & i0_dp.lsu;\n   assign mul_decode_d = i0_exulegal_decode_d & i0_dp.mul;\n   assign div_decode_d = i0_exulegal_decode_d & i0_dp.div;\n\n   assign dec_qual_lsu_d = i0_dp.lsu;\n\n\n\n\n\n// scheduling logic for alu\n\n   assign i0_rs1_depend_i0_x  = dec_i0_rs1_en_d & x_d.i0v & (x_d.i0rd[4:0] == i0r.rs1[4:0]);\n   assign i0_rs1_depend_i0_r  = dec_i0_rs1_en_d & r_d.i0v & (r_d.i0rd[4:0] == i0r.rs1[4:0]);\n\n   assign i0_rs2_depend_i0_x  = dec_i0_rs2_en_d & x_d.i0v & (x_d.i0rd[4:0] == i0r.rs2[4:0]);\n   assign i0_rs2_depend_i0_r  = dec_i0_rs2_en_d & r_d.i0v & (r_d.i0rd[4:0] == i0r.rs2[4:0]);\n\n\n// order the producers as follows:  , i0_x, i0_r, i0_wb\n\n   assign {i0_rs1_class_d, i0_rs1_depth_d[1:0]} = (i0_rs1_depend_i0_x ) ? { i0_x_c,  2'd1  } :\n                                                  (i0_rs1_depend_i0_r ) ? { i0_r_c,  2'd2  } : '0;\n\n   assign {i0_rs2_class_d, i0_rs2_depth_d[1:0]} = (i0_rs2_depend_i0_x ) ? { i0_x_c,  2'd1  } :\n                                                  (i0_rs2_depend_i0_r ) ? { i0_r_c,  2'd2  } : '0;\n\n\n// stores will bypass load data in the lsu pipe\n\n   if (pt.LOAD_TO_USE_PLUS1 == 1) begin : genblock\n      assign i0_load_block_d = (i0_rs1_class_d.load & i0_rs1_depth_d[0]) |\n                               (i0_rs2_class_d.load & i0_rs2_depth_d[0] & ~i0_dp.store);\n\n      assign load_ldst_bypass_d    =  (i0_dp.load | i0_dp.store) & i0_rs1_depth_d[1] & i0_rs1_class_d.load;\n\n      assign store_data_bypass_d =                  i0_dp.store  & i0_rs2_depth_d[1] & i0_rs2_class_d.load;\n\n      assign store_data_bypass_m =                  i0_dp.store  & i0_rs2_depth_d[0] & i0_rs2_class_d.load;\n   end\n   else begin : genblock\n\n      assign i0_load_block_d = 1'b0;\n\n      assign load_ldst_bypass_d    =  (i0_dp.load | i0_dp.store) & i0_rs1_depth_d[0] & i0_rs1_class_d.load;\n\n      assign store_data_bypass_d =                  i0_dp.store  & i0_rs2_depth_d[0] & i0_rs2_class_d.load;\n\n      assign store_data_bypass_m = 1'b0;\n   end\n\n\n\n\n\n\n   assign dec_tlu_i0_valid_r     =  r_d.i0valid & ~dec_tlu_flush_lower_wb;\n\n\n   assign d_t.legal              =  i0_legal_decode_d;\n   assign d_t.icaf               =  i0_icaf_d & i0_legal_decode_d;                // dbecc is icaf exception\n   assign d_t.icaf_second        =  dec_i0_icaf_second_d & i0_legal_decode_d;     // this includes icaf and dbecc\n   assign d_t.icaf_type[1:0]     =  dec_i0_icaf_type_d[1:0];\n\n   assign d_t.fence_i            = (i0_dp.fence_i | debug_fence_i) & i0_legal_decode_d;\n\n// put pmu info into the trap packet\n   assign d_t.pmu_i0_itype       =  i0_itype;\n   assign d_t.pmu_i0_br_unpred   =  i0_br_unpred;\n   assign d_t.pmu_divide         =  1'b0;\n   assign d_t.pmu_lsu_misaligned =  1'b0;\n\n   assign d_t.i0trigger[3:0]     =  dec_i0_trigger_match_d[3:0] & {4{dec_i0_decode_d}};\n\n\n\n   rvdfflie #( .WIDTH($bits(el2_trap_pkt_t)),.LEFT(9) ) trap_xff (.*, .en(i0_x_ctl_en), .din(d_t),  .dout(x_t));\n\n   always_comb begin\n      x_t_in = x_t;\n      x_t_in.i0trigger[3:0] = x_t.i0trigger & ~{4{dec_tlu_flush_lower_wb}};\n   end\n\n\n   rvdfflie  #( .WIDTH($bits(el2_trap_pkt_t)),.LEFT(9) ) trap_r_ff (.*, .en(i0_x_ctl_en), .din(x_t_in),  .dout(r_t));\n\n\n    always_comb begin\n\n      r_t_in                             =  r_t;\n\n      r_t_in.i0trigger[3:0]              = ({4{(r_d.i0load | r_d.i0store)}} & lsu_trigger_match_r[3:0]) | r_t.i0trigger[3:0];\n      r_t_in.pmu_lsu_misaligned          = lsu_pmu_misaligned_r;   // only valid if a load/store is valid in DC3 stage\n\n      if (dec_tlu_flush_lower_wb) r_t_in = '0 ;\n\n   end\n\n\n   always_comb begin\n\n      dec_tlu_packet_r                 =  r_t_in;\n      dec_tlu_packet_r.pmu_divide      =  r_d.i0div & r_d.i0valid;\n\n   end\n\n\n// end tlu stuff\n\n\n   assign i0_d_c.mul                =  i0_dp.mul  & i0_legal_decode_d;\n   assign i0_d_c.load               =  i0_dp.load & i0_legal_decode_d;\n   assign i0_d_c.alu                =  i0_dp.alu  & i0_legal_decode_d;\n\n   rvdffs #( $bits(el2_class_pkt_t) ) i0_x_c_ff   (.*, .en(i0_x_ctl_en),  .clk(active_clk), .din(i0_d_c),  .dout(i0_x_c));\n   rvdffs #( $bits(el2_class_pkt_t) ) i0_r_c_ff   (.*, .en(i0_r_ctl_en),  .clk(active_clk), .din(i0_x_c),  .dout(i0_r_c));\n\n\n   assign d_d.i0rd[4:0]             =  i0r.rd[4:0];\n   assign d_d.i0v                   =  i0_rd_en_d  & i0_legal_decode_d;\n   assign d_d.i0valid               =  dec_i0_decode_d;  // has flush_final_r\n\n   assign d_d.i0load                =  i0_dp.load  & i0_legal_decode_d;\n   assign d_d.i0store               =  i0_dp.store & i0_legal_decode_d;\n   assign d_d.i0div                 =  i0_dp.div   & i0_legal_decode_d;\n\n\n   assign d_d.csrwen                =  dec_csr_wen_unq_d   & i0_legal_decode_d;\n   assign d_d.csrwonly              =  i0_csr_write_only_d & dec_i0_decode_d;\n   assign d_d.csrwaddr[11:0]        =  (d_d.csrwen) ? i0[31:20] : '0;    // csr write address for rd==0 case\n\n\n   rvdff  #(3) i0cgff               (.*, .clk(active_clk),            .din(i0_pipe_en[3:1]), .dout(i0_pipe_en[2:0]));\n\n   assign i0_pipe_en[3]             =  dec_i0_decode_d;\n\n   assign i0_x_ctl_en               = (|i0_pipe_en[3:2] | clk_override);\n   assign i0_r_ctl_en               = (|i0_pipe_en[2:1] | clk_override);\n   assign i0_wb_ctl_en              = (|i0_pipe_en[1:0] | clk_override);\n   assign i0_x_data_en              = ( i0_pipe_en[3]   | clk_override);\n   assign i0_r_data_en              = ( i0_pipe_en[2]   | clk_override);\n   assign i0_wb_data_en             = ( i0_pipe_en[1]   | clk_override);\n\n   assign dec_data_en[1:0]          = {i0_x_data_en, i0_r_data_en};\n   assign dec_ctl_en[1:0]           = {i0_x_ctl_en,  i0_r_ctl_en};\n\n\n\n   rvdfflie #( .WIDTH($bits(el2_dest_pkt_t)),.LEFT(15) ) e1ff (.*, .en(i0_x_ctl_en), .din(d_d),  .dout(x_d));\n\n   always_comb begin\n      x_d_in = x_d;\n\n      x_d_in.i0v         = x_d.i0v     & ~dec_tlu_flush_lower_wb & ~dec_tlu_flush_lower_r;\n      x_d_in.i0valid     = x_d.i0valid & ~dec_tlu_flush_lower_wb & ~dec_tlu_flush_lower_r;\n   end\n\n   rvdfflie #( .WIDTH($bits(el2_dest_pkt_t)), .LEFT(15) ) r_d_ff (.*, .en(i0_r_ctl_en), .din(x_d_in), .dout(r_d));\n\n\n   always_comb begin\n\n        r_d_in = r_d;\n\n\n      // for the bench\n      r_d_in.i0rd[4:0]   =  r_d.i0rd[4:0];\n\n      r_d_in.i0v         = (r_d.i0v      & ~dec_tlu_flush_lower_wb);\n      r_d_in.i0valid     = (r_d.i0valid  & ~dec_tlu_flush_lower_wb);\n\n      r_d_in.i0load      =  r_d.i0load   & ~dec_tlu_flush_lower_wb;\n      r_d_in.i0store     =  r_d.i0store  & ~dec_tlu_flush_lower_wb;\n\n   end\n\n\n   rvdfflie #(.WIDTH($bits(el2_dest_pkt_t)), .LEFT(15)) wbff (.*, .en(i0_wb_ctl_en), .din(r_d_in), .dout(wbd));\n\n   assign dec_i0_waddr_r[4:0]       =  r_d_in.i0rd[4:0];\n\n   assign     i0_wen_r              =  r_d_in.i0v & ~dec_tlu_i0_kill_writeb_r;\n   assign dec_i0_wen_r              =  i0_wen_r   & ~r_d_in.i0div & ~i0_load_kill_wen_r;  // don't write a nonblock load 1st time down the pipe\n   assign dec_i0_wdata_r[31:0]      =  i0_result_corr_r[31:0];\n\n\n   // divide stuff\n   assign div_e1_to_r         = (x_d.i0div & x_d.i0valid) |\n                                (r_d.i0div & r_d.i0valid);\n\n   assign div_active_in = i0_div_decode_d | (div_active & ~exu_div_wren & ~nonblock_div_cancel);\n\n\n   assign dec_div_active = div_active;\n\n   // nonblocking div scheme\n\n   assign i0_nonblock_div_stall  = (dec_i0_rs1_en_d & div_active & (div_waddr_wb[4:0] == i0r.rs1[4:0])) |\n                                   (dec_i0_rs2_en_d & div_active & (div_waddr_wb[4:0] == i0r.rs2[4:0]));\n\n\n   assign div_flush              = (x_d.i0div & x_d.i0valid & (x_d.i0rd[4:0]==5'b0)                           ) |\n                                   (x_d.i0div & x_d.i0valid & dec_tlu_flush_lower_r                           ) |\n                                   (r_d.i0div & r_d.i0valid & dec_tlu_flush_lower_r & dec_tlu_i0_kill_writeb_r);\n\n\n   // cancel if any younger inst committing this cycle to same dest as nonblock divide\n   assign nonblock_div_cancel    = (div_active &  div_flush) |\n                                   (div_active & ~div_e1_to_r & (r_d.i0rd[4:0] == div_waddr_wb[4:0]) & i0_wen_r);\n\n   assign dec_div_cancel         =  nonblock_div_cancel;\n\n\n\n   assign i0_div_decode_d            =  i0_legal_decode_d & i0_dp.div;\n\n// for load_to_use_plus1, the load result data is merged in R stage instead of D\n\n   if ( pt.LOAD_TO_USE_PLUS1 == 1 ) begin : genblock1\n      assign i0_result_x[31:0]          = exu_i0_result_x[31:0];\n      assign i0_result_r[31:0]          = (r_d.i0v & r_d.i0load) ? lsu_result_m[31:0] : i0_result_r_raw[31:0];\n   end\n   else begin : genblock1\n      assign i0_result_x[31:0]          = (x_d.i0v & x_d.i0load) ? lsu_result_m[31:0] : exu_i0_result_x[31:0];\n      assign i0_result_r[31:0]          = i0_result_r_raw[31:0];\n   end\n\n\n   rvdffe #(32) i0_result_r_ff       (.*, .en(i0_r_data_en & (x_d.i0v | x_d.csrwen | debug_valid_x)),  .din(i0_result_x[31:0]),       .dout(i0_result_r_raw[31:0]));\n\n   // correct lsu load data - don't use for bypass, do pass down the pipe\n   assign i0_result_corr_r[31:0]     = (r_d.i0v & r_d.i0load) ? lsu_result_corr_r[31:0] : i0_result_r_raw[31:0];\n\n\n   rvdffe #(12) e1brpcff             (.*, .en(i0_x_data_en), .din(last_br_immed_d[12:1] ), .dout(last_br_immed_x[12:1]));\n\n\n\n   assign i0_wb_en                   =  i0_wb_data_en;\n\n   assign i0_inst_wb_in[31:0]        =  i0_inst_r[31:0];\n   assign i0_inst_d[31:0]            = (dec_i0_pc4_d)    ?  i0[31:0]                                  :  {16'b0, ifu_i0_cinst[15:0]};\n\n\n   assign trace_enable = ~dec_tlu_trace_disable;\n\n\n   rvdffe #(.WIDTH(5),.OVERRIDE(1))  i0rdff  (.*, .en(i0_div_decode_d),        .din(i0r.rd[4:0]),             .dout(div_waddr_wb[4:0]));\n\n   rvdffe #(32) i0xinstff            (.*, .en(i0_x_data_en & trace_enable),    .din(i0_inst_d[31:0]),         .dout(i0_inst_x[31:0]));\n   rvdffe #(32) i0cinstff            (.*, .en(i0_r_data_en & trace_enable),    .din(i0_inst_x[31:0]),         .dout(i0_inst_r[31:0]));\n\n   rvdffe #(32) i0wbinstff           (.*, .en(i0_wb_en & trace_enable),        .din(i0_inst_wb_in[31:0]),     .dout(i0_inst_wb[31:0]));\n   rvdffe #(31) i0wbpcff             (.*, .en(i0_wb_en & trace_enable),        .din(dec_tlu_i0_pc_r[31:1]),   .dout(  i0_pc_wb[31:1]));\n\n   assign dec_i0_inst_wb[31:0] = i0_inst_wb[31:0];\n   assign dec_i0_pc_wb[31:1] = i0_pc_wb[31:1];\n\n\n\n   rvdffpcie #(31) i0_pc_r_ff           (.*, .en(i0_r_data_en), .din(exu_i0_pc_x[31:1]), .dout(dec_i0_pc_r[31:1]));\n\n   assign dec_tlu_i0_pc_r[31:1]      = dec_i0_pc_r[31:1];\n\n\n   rvbradder ibradder_correct (\n                     .pc(exu_i0_pc_x[31:1]),\n                     .offset(last_br_immed_x[12:1]),\n                     .dout(pred_correct_npc_x[31:1]));\n\n\n\n   // add nonblock load rs1/rs2 bypass cases\n\n   assign i0_rs1_nonblock_load_bypass_en_d  = dec_i0_rs1_en_d & dec_nonblock_load_wen & (dec_nonblock_load_waddr[4:0] == i0r.rs1[4:0]);\n\n   assign i0_rs2_nonblock_load_bypass_en_d  = dec_i0_rs2_en_d & dec_nonblock_load_wen & (dec_nonblock_load_waddr[4:0] == i0r.rs2[4:0]);\n\n\n\n   // bit 2 is priority match, bit 0 lowest priority, i0_x, i0_r\n\n   assign i0_rs1bypass[2]                =  i0_rs1_depth_d[0] & (i0_rs1_class_d.alu | i0_rs1_class_d.mul                      );\n   assign i0_rs1bypass[1]                =  i0_rs1_depth_d[0] & (                                          i0_rs1_class_d.load);\n   assign i0_rs1bypass[0]                =  i0_rs1_depth_d[1] & (i0_rs1_class_d.alu | i0_rs1_class_d.mul | i0_rs1_class_d.load);\n\n   assign i0_rs2bypass[2]                =  i0_rs2_depth_d[0] & (i0_rs2_class_d.alu | i0_rs2_class_d.mul                      );\n   assign i0_rs2bypass[1]                =  i0_rs2_depth_d[0] & (                                          i0_rs2_class_d.load);\n   assign i0_rs2bypass[0]                =  i0_rs2_depth_d[1] & (i0_rs2_class_d.alu | i0_rs2_class_d.mul | i0_rs2_class_d.load);\n\n\n   assign dec_i0_rs1_bypass_en_d[3]      =  i0_rs1_nonblock_load_bypass_en_d & ~i0_rs1bypass[0] & ~i0_rs1bypass[1] & ~i0_rs1bypass[2];\n   assign dec_i0_rs1_bypass_en_d[2]      =  i0_rs1bypass[2];\n   assign dec_i0_rs1_bypass_en_d[1]      =  i0_rs1bypass[1];\n   assign dec_i0_rs1_bypass_en_d[0]      =  i0_rs1bypass[0];\n\n   assign dec_i0_rs2_bypass_en_d[3]      =  i0_rs2_nonblock_load_bypass_en_d & ~i0_rs2bypass[0] & ~i0_rs2bypass[1] & ~i0_rs2bypass[2];\n   assign dec_i0_rs2_bypass_en_d[2]      =  i0_rs2bypass[2];\n   assign dec_i0_rs2_bypass_en_d[1]      =  i0_rs2bypass[1];\n   assign dec_i0_rs2_bypass_en_d[0]      =  i0_rs2bypass[0];\n\n\n   assign dec_i0_result_r[31:0]          =  i0_result_r[31:0];\n\n\nendmodule // el2_dec_decode_ctl\n\n// file \"decode\" is human readable file that has all of the instruction decodes\n// defined and is part of git repo. Modify this file as needed.\n//\n// The tools needed are \"coredecode\", \"addasign\" and \"espresso\". The first two\n// can be found in this repo under /tools. Espresso can be found in another\n// repo (https://github.com/chipsalliance/espresso).\n//  IMPORTANT: use Espresso v2.4 (git tag v2.4)\n//\n// To generate instruction decoding equations do:\n//  1) coredecode -in decode > coredecode.e\n//  2) espresso -Dso -oeqntott < coredecode.e | addassign -pre out. > equations\n//  3) copy-paste assignments from the file \"equations\" and replace ones below.\n//\n// To generate instruction legality check equation do:\n//  1) coredecode -in decode -legal > legal.e\n//  2) espresso -Dso -oeqntott < legal.e | addassign -pre out. > legal\n//  3) copy-paste assignment from the file \"legal\" and replace the one below.\n\nmodule el2_dec_dec_ctl\n  import el2_pkg::*;\n(\n    input logic [31:0] inst,\n    output el2_dec_pkt_t out\n);\n\n  logic [31:0] i;\n\n  assign i[31:0] = inst[31:0];\n\n  assign out.alu = (i[30]&i[24]&i[23]&!i[22]&!i[21]&!i[20]&i[14]&!i[5]&i[4]) | (i[30]\n    &!i[27]&!i[24]&i[4]) | (!i[30]&!i[25]&i[13]&i[12]) | (!i[29]&!i[27]\n    &!i[5]&i[4]) | (i[27]&i[25]&i[14]&i[4]) | (!i[29]&!i[25]&!i[13]&!i[12]\n    &i[4]) | (i[29]&i[27]&!i[14]&i[12]&i[4]) | (!i[27]&i[14]&!i[5]&i[4]) | (\n    i[30]&!i[29]&!i[13]&i[4]) | (!i[27]&!i[25]&i[5]&i[4]) | (i[13]&!i[5]\n    &i[4]) | (i[6]) | (!i[30]&i[29]&!i[24]&!i[23]&i[22]&i[21]&i[20]&!i[5"}
{"text": "]\n    &i[4]) | (i[2]) | (!i[12]&!i[5]&i[4]);\n\n  assign out.rs1 = (!i[13]&i[11]&!i[2]) | (!i[13]&i[10]&!i[2]) | (i[19]&i[13]&!i[2]) | (\n    !i[13]&i[9]&!i[2]) | (i[18]&i[13]&!i[2]) | (!i[13]&i[8]&!i[2]) | (\n    i[17]&i[13]&!i[2]) | (!i[13]&i[7]&!i[2]) | (i[16]&i[13]&!i[2]) | (\n    i[15]&i[13]&!i[2]) | (!i[4]&!i[2]) | (!i[14]&!i[13]&i[6]&!i[3]) | (\n    !i[6]&!i[2]);\n\n  assign out.rs2 = (i[5] & !i[4] & !i[2]) | (!i[6] & i[5] & !i[2]);\n\n  assign out.imm12 = (!i[4]&!i[3]&i[2]) | (i[13]&!i[5]&i[4]&!i[2]) | (!i[13]&!i[12]\n    &i[6]&i[4]) | (!i[12]&!i[5]&i[4]&!i[2]);\n\n  assign out.rd = (!i[5] & !i[2]) | (i[5] & i[2]) | (i[4]);\n\n  assign out.shimm5 = (!i[29]&!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (i[27]&!i[13]&i[12]\n    &!i[5]&i[4]&!i[2]) | (i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\n  assign out.imm20 = (i[5] & i[3]) | (i[4] & i[2]);\n\n  assign out.pc = (!i[5] & !i[3] & i[2]) | (i[5] & i[3]);\n\n  assign out.load = (!i[5] & !i[4] & !i[2]);\n\n  assign out.store = (!i[6] & i[5] & !i[4]);\n\n  assign out.lsu = (!i[6] & !i[4] & !i[2]);\n\n  assign out.add = (!i[14]&!i[13]&!i[12]&!i[5]&i[4]) | (!i[5]&!i[3]&i[2]) | (!i[30]\n    &!i[25]&!i[14]&!i[13]&!i[12]&!i[6]&i[4]&!i[2]);\n\n  assign out.sub = (i[30]&!i[14]&!i[12]&!i[6]&i[5]&i[4]&!i[2]) | (!i[29]&!i[25]&!i[14]\n    &i[13]&!i[6]&i[4]&!i[2]) | (i[27]&i[25]&i[14]&!i[6]&i[5]&!i[2]) | (\n    !i[14]&i[13]&!i[5]&i[4]&!i[2]) | (i[6]&!i[4]&!i[2]);\n\n  assign out.land = (!i[27]&!i[25]&i[14]&i[13]&i[12]&!i[6]&!i[2]) | (i[14]&i[13]&i[12]\n    &!i[5]&!i[2]);\n\n  assign out.lor = (!i[29]&!i[27]&!i[25]&i[14]&i[13]&!i[12]&!i[6]&!i[2]) | (!i[6]&i[3]) | (\n    i[5]&i[4]&i[2]) | (!i[13]&!i[12]&i[6]&i[4]) | (i[14]&i[13]&!i[12]\n    &!i[5]&!i[2]);\n\n  assign out.lxor = (!i[29]&!i[27]&!i[25]&i[14]&!i[13]&!i[12]&i[4]&!i[2]) | (i[14]\n    &!i[13]&!i[12]&!i[5]&i[4]&!i[2]);\n\n  assign out.sll = (!i[29] & !i[27] & !i[25] & !i[14] & !i[13] & i[12] & !i[6] & i[4] & !i[2]);\n\n  assign out.sra = (i[30] & !i[29] & !i[27] & !i[13] & i[12] & !i[6] & i[4] & !i[2]);\n\n  assign out.srl = (!i[30] & !i[27] & !i[25] & i[14] & !i[13] & i[12] & !i[6] & i[4] & !i[2]);\n\n  assign out.slt = (!i[29]&!i[25]&!i[14]&i[13]&!i[6]&i[4]&!i[2]) | (!i[14]&i[13]&!i[5]\n    &i[4]&!i[2]);\n\n  assign out.unsign = (!i[14]&i[13]&i[12]&!i[5]&!i[2]) | (i[13]&i[6]&!i[4]&!i[2]) | (\n    i[14]&!i[5]&!i[4]) | (!i[25]&!i[14]&i[13]&i[12]&!i[6]&!i[2]) | (\n    i[25]&i[14]&i[12]&!i[6]&i[5]&!i[2]);\n\n  assign out.condbr = (i[6] & !i[4] & !i[2]);\n\n  assign out.beq = (!i[14] & !i[12] & i[6] & !i[4] & !i[2]);\n\n  assign out.bne = (!i[14] & i[12] & i[6] & !i[4] & !i[2]);\n\n  assign out.bge = (i[14] & i[12] & i[5] & !i[4] & !i[2]);\n\n  assign out.blt = (i[14] & !i[12] & i[5] & !i[4] & !i[2]);\n\n  assign out.jal = (i[6] & i[2]);\n\n  assign out.by = (!i[13] & !i[12] & !i[6] & !i[4] & !i[2]);\n\n  assign out.half = (i[12] & !i[6] & !i[4] & !i[2]);\n\n  assign out.word = (i[13] & !i[6] & !i[4]);\n\n  assign out.csr_read = (i[13]&i[6]&i[4]) | (i[7]&i[6]&i[4]) | (i[8]&i[6]&i[4]) | (\n    i[9]&i[6]&i[4]) | (i[10]&i[6]&i[4]) | (i[11]&i[6]&i[4]);\n\n  assign out.csr_clr = (i[15]&i[13]&i[12]&i[6]&i[4]) | (i[16]&i[13]&i[12]&i[6]&i[4]) | (\n    i[17]&i[13]&i[12]&i[6]&i[4]) | (i[18]&i[13]&i[12]&i[6]&i[4]) | (\n    i[19]&i[13]&i[12]&i[6]&i[4]);\n\n  assign out.csr_set = (i[15]&!i[12]&i[6]&i[4]) | (i[16]&!i[12]&i[6]&i[4]) | (i[17]\n    &!i[12]&i[6]&i[4]) | (i[18]&!i[12]&i[6]&i[4]) | (i[19]&!i[12]&i[6]\n    &i[4]);\n\n  assign out.csr_write = (!i[13] & i[12] & i[6] & i[4]);\n\n  assign out.csr_imm = (i[14]&!i[13]&i[6]&i[4]) | (i[15]&i[14]&i[6]&i[4]) | (i[16]\n    &i[14]&i[6]&i[4]) | (i[17]&i[14]&i[6]&i[4]) | (i[18]&i[14]&i[6]&i[4]) | (\n    i[19]&i[14]&i[6]&i[4]);\n\n  assign out.presync = (!i[5]&i[3]) | (!i[13]&i[7]&i[6]&i[4]) | (!i[13]&i[8]&i[6]&i[4]) | (\n    !i[13]&i[9]&i[6]&i[4]) | (!i[13]&i[10]&i[6]&i[4]) | (!i[13]&i[11]\n    &i[6]&i[4]) | (i[15]&i[13]&i[6]&i[4]) | (i[16]&i[13]&i[6]&i[4]) | (\n    i[17]&i[13]&i[6]&i[4]) | (i[18]&i[13]&i[6]&i[4]) | (i[19]&i[13]&i[6]\n    &i[4]);\n\n  assign out.postsync = (!i[22]&!i[13]&!i[12]&i[6]&i[4]) | (i[12]&!i[5]&i[3]) | (\n    !i[13]&i[7]&i[6]&i[4]) | (!i[13]&i[8]&i[6]&i[4]) | (!i[13]&i[9]&i[6]\n    &i[4]) | (!i[13]&i[10]&i[6]&i[4]) | (!i[13]&i[11]&i[6]&i[4]) | (\n    i[15]&i[13]&i[6]&i[4]) | (i[16]&i[13]&i[6]&i[4]) | (i[17]&i[13]&i[6]\n    &i[4]) | (i[18]&i[13]&i[6]&i[4]) | (i[19]&i[13]&i[6]&i[4]);\n\n  assign out.ebreak = (!i[22] & i[20] & !i[13] & !i[12] & i[6] & i[4]);\n\n  assign out.ecall = (!i[21] & !i[20] & !i[13] & !i[12] & i[6] & i[4]);\n\n  assign out.mret = (i[29] & !i[13] & !i[12] & i[6] & i[4]);\n\n  assign out.mul = (i[29]&!i[27]&i[24]&!i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (i[30]\n    &i[27]&i[13]&!i[6]&i[5]&i[4]&!i[2]) | (i[29]&i[27]&!i[23]&!i[20]\n    &i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (i[29]&i[27]&!i[21]&i[20]\n    &i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (i[29]&i[27]&i[24]&i[21]\n    &i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (i[29]&i[27]&!i[24]&!i[22]\n    &i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (!i[30]&i[29]&i[23]&i[14]\n    &!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (i[30]&i[29]&i[27]&i[22]&i[14]\n    &!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (i[27]&!i[25]&i[13]&!i[12]&!i[6]\n    &i[5]&i[4]&!i[2]) | (!i[30]&!i[29]&i[27]&!i[25]&!i[13]&i[12]&!i[6]\n    &i[4]&!i[2]) | (i[25]&!i[14]&!i[6]&i[5]&i[4]&!i[2]) | (i[29]&i[27]\n    &i[14]&!i[6]&i[5]&!i[2]);\n\n  assign out.rs1_sign = (!i[27]&i[25]&!i[14]&i[13]&!i[12]&!i[6]&i[5]&i[4]&!i[2]) | (\n    !i[27]&i[25]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\n  assign out.rs2_sign = (!i[27] & i[25] & !i[14] & !i[13] & i[12] & !i[6] & i[4] & !i[2]);\n\n  assign out.low = (i[25] & !i[14] & !i[13] & !i[12] & i[5] & i[4] & !i[2]);\n\n  assign out.div = (!i[27] & i[25] & i[14] & !i[6] & i[5] & !i[2]);\n\n  assign out.rem = (!i[27] & i[25] & i[14] & i[13] & !i[6] & i[5] & !i[2]);\n\n  assign out.fence = (!i[5] & i[3]);\n\n  assign out.fence_i = (i[12] & !i[5] & i[3]);\n\n  assign out.clz = (i[29]&!i[27]&!i[24]&!i[22]&!i[21]&!i[20]&!i[14]&!i[13]&i[12]&!i[5]\n    &i[4]&!i[2]);\n\n  assign out.ctz = (i[29]&!i[27]&!i[24]&!i[22]&i[20]&!i[14]&!i[13]&i[12]&!i[5]&i[4]\n    &!i[2]);\n\n  assign out.cpop = (i[29]&!i[27]&!i[24]&i[21]&!i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\n  assign out.sext_b = (i[29]&!i[27]&i[22]&!i[20]&!i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\n  assign out.sext_h = (i[29]&!i[27]&i[22]&i[20]&!i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\n  assign out.min = (i[27] & i[25] & i[14] & !i[13] & !i[6] & i[5] & !i[2]);\n\n  assign out.max = (i[27] & i[25] & i[14] & i[13] & !i[6] & i[5] & !i[2]);\n\n  assign out.pack = (!i[30] & !i[29] & i[27] & !i[25] & !i[13] & !i[12] & i[5] & i[4] & !i[2]);\n\n  assign out.packu = (i[30] & i[27] & !i[13] & !i[12] & i[5] & i[4] & !i[2]);\n\n  assign out.packh = (!i[30] & i[27] & !i[25] & i[13] & i[12] & !i[6] & i[5] & !i[2]);\n\n  assign out.rol = (i[29] & !i[27] & !i[14] & i[12] & !i[6] & i[5] & i[4] & !i[2]);\n\n  assign out.ror = (i[29] & !i[27] & i[14] & !i[13] & i[12] & !i[6] & i[4] & !i[2]);\n\n  assign out.zbb = (!i[30]&!i[29]&i[27]&!i[24]&!i[23]&!i[22]&!i[21]&!i[20]&!i[13]\n    &!i[12]&i[5]&i[4]&!i[2]) | (i[29]&!i[27]&!i[24]&!i[13]&i[12]&!i[5]\n    &i[4]&!i[2]) | (i[29]&!i[27]&i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (\n    i[30]&!i[27]&i[14]&!i[12]&!i[6]&i[5]&!i[2]) | (i[30]&!i[27]&i[13]\n    &!i[6]&i[5]&i[4]&!i[2]) | (i[29]&!i[27]&i[12]&!i[6]&i[5]&i[4]&!i[2]) | (\n    !i[30]&i[29]&!i[24]&!i[23]&i[22]&i[21]&i[20]&i[14]&!i[13]&i[12]&!i[5]\n    &i[4]&!i[2]) | (i[30]&i[29]&i[24]&i[23]&!i[22]&!i[21]&!i[20]&i[14]\n    &!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (i[27]&i[25]&i[14]&!i[6]&i[5]&!i[2]);\n\n  assign out.bset = (!i[30] & i[29] & !i[14] & !i[13] & i[12] & !i[6] & i[4] & !i[2]);\n\n  assign out.bclr = (i[30] & !i[29] & !i[14] & !i[13] & i[12] & !i[6] & i[4] & !i[2]);\n\n  assign out.binv = (i[30] & i[29] & i[27] & !i[14] & !i[13] & i[12] & !i[6] & i[4] & !i[2]);\n\n  assign out.bext = (i[30] & !i[29] & i[27] & i[14] & !i[13] & i[12] & !i[6] & i[4] & !i[2]);\n\n  assign out.zbs = (i[29]&i[27]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]) | (i[30]&!i[29]\n    &i[27]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\n  assign out.bcompress = (!i[30]&!i[29]&i[27]&!i[25]&i[13]&!i[12]&!i[6]&i[5]&i[4]&!i[2]);\n\n  assign out.bdecompress = (i[30] & i[27] & i[13] & !i[12] & !i[6] & i[5] & i[4] & !i[2]);\n\n  assign out.zbe = (i[30]&i[27]&i[14]&i[13]&!i[12]&!i[6]&i[5]&!i[2]) | (!i[30]&i[27]\n    &!i[25]&i[13]&i[12]&!i[6]&i[5]&!i[2]) | (!i[30]&!i[29]&i[27]&!i[25]\n    &!i[12]&!i[6]&i[5]&i[4]&!i[2]);\n\n  assign out.clmul = (i[27] & i[25] & !i[14] & !i[13] & !i[6] & i[5] & i[4] & !i[2]);\n\n  assign out.clmulh = (i[27] & !i[14] & i[13] & i[12] & !i[6] & i[5] & !i[2]);\n\n  assign out.clmulr = (i[27] & i[25] & !i[14] & !i[12] & !i[6] & i[5] & i[4] & !i[2]);\n\n  assign out.zbc = (i[27] & i[25] & !i[14] & !i[6] & i[5] & i[4] & !i[2]);\n\n  assign out.grev = (i[30] & i[29] & i[27] & i[14] & !i[13] & i[12] & !i[6] & i[4] & !i[2]);\n\n  assign out.gorc = (!i[30] & i[29] & i[14] & !i[13] & i[12] & !i[6] & i[4] & !i[2]);\n\n  assign out.shfl = (!i[30]&!i[29]&i[27]&!i[25]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\n  assign out.unshfl = (!i[30]&!i[29]&i[27]&!i[25]&i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\n  assign out.xperm_n = (i[29] & i[27] & !i[14] & !i[12] & !i[6] & i[5] & i[4] & !i[2]);\n\n  assign out.xperm_b = (i[29] & i[27] & !i[13] & !i[12] & i[5] & i[4] & !i[2]);\n\n  assign out.xperm_h = (i[29] & i[27] & i[14] & i[13] & !i[6] & i[5] & !i[2]);\n\n  assign out.zbp = (i[30]&!i[27]&!i[14]&i[12]&!i[6]&i[5]&i[4]&!i[2]) | (!i[30]&i[27]\n    &!i[25]&i[13]&i[12]&!i[6]&i[5]&!i[2]) | (i[30]&!i[27]&i[13]&!i[6]\n    &i[5]&i[4]&!i[2]) | (i[27]&!i[25]&!i[13]&!i[12]&i[5]&i[4]&!i[2]) | (\n    i[30]&i[14]&!i[13]&!i[12]&i[5]&i[4]&!i[2]) | (i[29]&i[27]&!i[12]&!i[6]\n    &i[5]&i[4]&!i[2]) | (!i[30]&!i[29]&i[27]&!i[25]&!i[13]&i[12]&!i[6]\n    &i[4]&!i[2]) | (i[29]&i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\n  assign out.crc32_b = (i[29]&!i[27]&i[24]&!i[23]&!i[21]&!i[20]&!i[14]&!i[13]&i[12]\n    &!i[5]&i[4]&!i[2]);\n\n  assign out.crc32_h = (i[29]&!i[27]&i[24]&!i[23]&i[20]&!i[14]&!i[13]&i[12]&!i[5]&i[4]\n    &!i[2]);\n\n  assign out.crc32_w = (i[29]&!i[27]&i[24]&!i[23]&i[21]&!i[14]&!i[13]&i[12]&!i[5]&i[4]\n    &!i[2]);\n\n  assign out.crc32c_b = (i[29]&!i[27]&i[23]&!i[21]&!i[20]&!i[14]&!i[13]&i[12]&!i[5]\n    &i[4]&!i[2]);\n\n  assign out.crc32c_h = (i[29]&!i[27]&i[23]&i[20]&!i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\n  assign out.crc32c_w = (i[29]&!i[27]&i[23]&i[21]&!i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\n  assign out.zbr = (i[29] & !i[27] & i[24] & !i[14] & !i[13] & i[12] & !i[5] & i[4] & !i[2]);\n\n  assign out.bfp = (i[30] & i[27] & i[13] & i[12] & !i[6] & i[5] & !i[2]);\n\n  assign out.zbf = (!i[30]&!i[29]&i[27]&!i[25]&!i[13]&!i[12]&i[5]&i[4]&!i[2]) | (\n    i[27]&!i[25]&i[13]&i[12]&!i[6]&i[5]&!i[2]);\n\n  assign out.sh1add = (i[29] & !i[27] & !i[14] & !i[12] & !i[6] & i[5] & i[4] & !i[2]);\n\n  assign out.sh2add = (i[29] & !i[27] & i[14] & !i[13] & !i[12] & i[5] & i[4] & !i[2]);\n\n  assign out.sh3add = (i[29] & !i[27] & i[14] & i[13] & !i[6] & i[5] & !i[2]);\n\n  assign out.zba = (i[29] & !i[27] & !i[12] & !i[6] & i[5] & i[4] & !i[2]);\n\n  assign out.pm_alu = (i[28]&i[20]&!i[13]&!i[12]&i[4]) | (!i[30]&!i[29]&!i[27]&!i[25]\n    &!i[6]&i[4]) | (!i[29]&!i[27]&!i[25]&!i[13]&i[12]&!i[6]&i[4]) | (\n    !i[29]&!i[27]&!i[25]&!i[14]&!i[6]&i[4]) | (i[13]&!i[5]&i[4]) | (i[4]\n    &i[2]) | (!i[12]&!i[5]&i[4]);\n\n\n  assign out.legal = (!i[31]&!i[30]&i[29]&i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]\n    &!i[22]&i[21]&!i[20]&!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[11]\n    &!i[10]&!i[9]&!i[8]&!i[7]&i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n    !i[31]&!i[30]&!i[29]&i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]&i[22]\n    &!i[21]&i[20]&!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[11]&!i[10]\n    &!i[9]&!i[8]&!i[7]&i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]\n    &!i[30]&!i[29]&!i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]&!i[22]&!i[21]\n    &!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[11]&!i[10]&!i[9]&!i[8]\n    &!i[7]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&i[30]&i[29]&!i[28]\n    &!i[26]&!i[25]&i[24]&!i[22]&!i[20]&!i[6]&!i[5]&i[4]&!i[3]&i[1]&i[0]) | (\n    !i[31]&i[30]&i[29]&!i[28]&!i[26]&!i[25]&i[24]&!i[22]&!i[21]&!i[6]\n    &!i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&i[30]&i[29]&!i[28]&!i[26]\n    &!i[25]&!i[23]&!i[22]&!i[20]&!i[6]&!i[5]&i[4]&!i[3]&i[1]&i[0]) | (\n    !i[31]&i[30]&i[29]&!i[28]&!i[26]&!i[25]&!i[24]&!i[23]&!i[21]&!i[6]\n    &!i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&!i[28]&!i[26]\n    &i[25]&i[13]&!i[6]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&!i[28]&i[27]&!i[26]\n    &!i[25]&!i[24]&!i[6]&!i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&!i[30]\n    &i[29]&!i[28]&!i[26]&!i[25]&i[13]&!i[12]&!i[6]&i[4]&!i[3]&i[1]&i[0]) | (\n    !i[31]&!i[29]&!i[28]&!i[27]&!i[26]&!i[25]&!i[13]&!i[12]&!i[6]&i[4]\n    &!i[3]&i[1]&i[0]) | (!i[31]&i[30]&!i[28]&!i[26]&!i[25]&i[14]&!i[6]\n    &!i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&!i[28]&!i[26]\n    &!i[13]&i[12]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]\n    &!i[28]&!i[27]&!i[26]&!i[25]&!i[6]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]\n    &i[30]&i[29]&!i[28]&!i[26]&!i[25]&!i[13]&i[12]&i[5]&i[4]&!i[3]&!i[2]\n    &i[1]&i[0]) | (!i[31]&i[30]&!i[28]&i[27]&!i[26]&!i[25]&!i[13]&i[12]\n    &!i[6]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&!i[29]&!i[28]&!i[26]&!i[25]\n    &i[14]&!i[6]&i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&i[29]&!i[28]&i[27]\n    &!i[26]&!i[25]&!i[13]&i[12]&!i[6]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]\n    &!i[30]&!i[29]&!i[28]&!i[27]&!i[26]&!i[6]&i[5]&i[4]&!i[3]&i[1]&i[0]) | (\n    !i[31]&!i[30]&!i[29]&!i[28]&!i[26]&i[14]&!i[6]&i[5]&i[4]&!i[3]&i[1]\n    &i[0]) | (!i[14]&!i[13]&!i[12]&i[6]&i[5]&!i[4]&!i[3]&i[1]&i[0]) | (\n    i[14]&i[6]&i[5]&!i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[14]&!i[13]&i[5]\n    &!i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[12]&!i[6]&!i[5]&i[4]&!i[3]&i[1]\n    &i[0]) | (!i[13]&i[12]&i[6]&i[5]&!i[3]&!i[2]&i[1]&i[0]) | (i[13]&i[6]\n    &i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[30]&!i[29]&!i[28]&!i[14]\n    &!i[13]&!i[6]&!i[5]&!i[4]&i[3]&i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[28]\n    &!i[26]&!i[25]&i[14]&!i[12]&!i[6]&i[4]&!i[3]&i[1]&i[0]) | (!i[14]\n    &!i[13]&i[12]&!i[6]&!i[5]&!i[4]&i[3]&i[2]&i[1]&i[0]) | (i[6]&i[5]\n    &!i[4]&i[3]&i[2]&i[1]&i[0]) | (!i[14]&!i[12]&!i[6]&!i[4]&!i[3]&!i[2]\n    &i[1]&i[0]) | (!i[13]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n    i[13]&!i[6]&!i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[6]&i[4]&!i[3]&i[2]&i[1]\n    &i[0]);\n\nendmodule  // el2_dec_dec_ctl\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmodule el2_dec_gpr_ctl\nimport el2_pkg::*;\n#(\n   `include \"el2_param.vh\"\n )  (\n    input logic [4:0]  raddr0,       // logical read addresses\n    input logic [4:0]  raddr1,\n\n    input logic        wen0,         // write enable\n    input logic [4:0]  waddr0,       // write address\n    input logic [31:0] wd0,          // write data\n\n    input logic        wen1,         // write enable\n    input logic [4:0]  waddr1,       // write address\n    input logic [31:0] wd1,          // write data\n\n    input logic        wen2,         // write enable\n    input logic [4:0]  waddr2,       // write address\n    input logic [31:0] wd2,          // write data\n\n    input logic        clk,\n    input logic        rst_l,\n\n    output logic [31:0] rd0,         // read data\n    output logic [31:0] rd1,\n\n    input  logic        scan_mode\n);\n\n   logic [31:1] [31:0] gpr_out;      // 31 x 32 bit GPRs\n   logic [31:1] [31:0] gpr_in;\n   logic [31:1] w0v,w1v,w2v;\n   logic [31:1] gpr_wr_en;\n\n   // GPR Write Enables\n   assign gpr_wr_en[31:1] = (w0v[31:1] | w1v[31:1] | w2v[31:1]);\n   for ( genvar j=1; j<32; j++ )  begin : gpr\n      rvdffe #(32) gprff (.*, .en(gpr_wr_en[j]), .din(gpr_in[j][31:0]), .dout(gpr_out[j][31:0]));\n   end : gpr\n\n   // the read out\n   always_comb begin\n      rd0[31:0] = 32'b0;\n      rd1[31:0] = 32'b0;\n      w0v[31:1] = 31'b0;\n      w1v[31:1] = 31'b0;\n      w2v[31:1] = 31'b0;\n      gpr_in[31:1] = '0;\n\n      // GPR Read logic\n      for (int j=1; j<32; j++ )  begin\n         rd0[31:0] |= ({32{(raddr0[4:0]== 5'(j))}} & gpr_out[j][31:0]);\n         rd1[31:0] |= ({32{(raddr1[4:0]== 5'(j))}} & gpr_out[j][31:0]);\n      end\n\n     // GPR Write logic\n     for (int j=1; j<32; j++ )  begin\n         w0v[j]     = wen0  & (waddr0[4:0]== 5'(j) );\n         w1v[j]     = wen1  & (waddr1[4:0]== 5'(j) );\n         w2v[j]     = wen2  & (waddr2[4:0]== 5'(j) );\n         gpr_in[j]  =    ({32{w0v[j]}} & wd0[31:0]) |\n                         ({32{w1v[j]}} & wd1[31:0]) |\n                         ({32{w2v[j]}} & wd2[31:0]);\n     end\n   end // always_comb begin\n\n`ifdef RV_ASSERT_ON\n\n   logic  write_collision_unused;\n   assign write_collision_unused = ( (w0v[31:1] == w1v[31:1]) & wen0 & wen1 ) |\n                                   ( (w0v[31:1] == w2v[31:1]) & wen0 & wen2 ) |\n                                   ( (w1v[31:1] == w2v[31:1]) & wen1 & wen2 );\n\n\n   // asserting that no 2 ports will write to the same gpr simultaneously\n   assert_multiple_wen_to_same_gpr: assert #0 (~( write_collision_unused ) );\n\n`endif\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmodule el2_dec_ib_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n   input logic                 dbg_cmd_valid,                      // valid dbg cmd\n\n   input logic                 dbg_cmd_write,                      // dbg cmd is write\n   input logic [1:0]           dbg_cmd_type,                       // dbg type\n   input logic [31:0]          dbg_cmd_addr,                       // expand to 31:0\n\n   input el2_br_pkt_t i0_brp,                                     // i0 branch packet from aligner\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifu_i0_bp_index,    // BP index\n   input logic [pt.BHT_GHR_SIZE-1:0] ifu_i0_bp_fghr,               // BP FGHR\n   input logic [pt.BTB_BTAG_SIZE-1:0] ifu_i0_bp_btag,              // BP tag\n   input logic [$clog2(pt.BTB_SIZE)-1:0] ifu_i0_fa_index,          // Fully associt btb index\n\n   input logic       ifu_i0_pc4,                                   // i0 is 4B inst else 2B\n   input logic       ifu_i0_valid,                                 // i0 valid from ifu\n   input logic       ifu_i0_icaf,                                  // i0 instruction access fault\n   input logic [1:0] ifu_i0_icaf_type,                             // i0 instruction access fault type\n\n   input logic   ifu_i0_icaf_second,                               // i0 has access fault on second 2B of 4B inst\n   input logic   ifu_i0_dbecc,                                     // i0 double-bit error\n   input logic [31:0]  ifu_i0_instr,                               // i0 instruction from the aligner\n   input logic [31:1]  ifu_i0_pc,                                  // i0 pc from the aligner\n\n\n   output logic dec_ib0_valid_d,                                   // ib0 valid\n   output logic dec_debug_valid_d,                                 // Debug read or write at D-stage\n\n\n   output logic [31:0] dec_i0_instr_d,                             // i0 inst at decode\n\n   output logic [31:1] dec_i0_pc_d,                                // i0 pc at decode\n\n   output logic dec_i0_pc4_d,                                      // i0 is 4B inst else 2B\n\n   output el2_br_pkt_t dec_i0_brp,                                // i0 branch packet at decode\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_i0_bp_index,   // i0 branch index\n   output logic [pt.BHT_GHR_SIZE-1:0] dec_i0_bp_fghr,              // BP FGHR\n   output logic [pt.BTB_BTAG_SIZE-1:0] dec_i0_bp_btag,             // BP tag\n   output logic [$clog2(pt.BTB_SIZE)-1:0] dec_i0_bp_fa_index,          // Fully associt btb index\n\n   output logic dec_i0_icaf_d,                                     // i0 instruction access fault at decode\n   output logic dec_i0_icaf_second_d,                              // i0 instruction access fault on second 2B of 4B inst\n   output logic [1:0] dec_i0_icaf_type_d,                          // i0 instruction access fault type\n   output logic dec_i0_dbecc_d,                                    // i0 double-bit error at decode\n   output logic dec_debug_wdata_rs1_d,                             // put debug write data onto rs1 source: machine is halted\n\n   output logic dec_debug_fence_d                                  // debug fence inst\n\n   );\n\n\n   logic         debug_valid;\n   logic [4:0]   dreg;\n   logic [11:0]  dcsr;\n   logic [31:0]  ib0, ib0_debug_in;\n\n   logic         debug_read;\n   logic         debug_write;\n   logic         debug_read_gpr;\n   logic         debug_write_gpr;\n   logic         debug_read_csr;\n   logic         debug_write_csr;\n\n   logic [34:0]  ifu_i0_pcdata, pc0;\n\n   assign ifu_i0_pcdata[34:0] = { ifu_i0_icaf_second, ifu_i0_dbecc, ifu_i0_icaf,\n                                  ifu_i0_pc[31:1], ifu_i0_pc4 };\n\n   assign pc0[34:0] = ifu_i0_pcdata[34:0];\n\n   assign dec_i0_icaf_second_d = pc0[34];   // icaf's can only decode as i0\n\n   assign dec_i0_dbecc_d = pc0[33];\n\n   assign dec_i0_icaf_d = pc0[32];\n   assign dec_i0_pc_d[31:1] = pc0[31:1];\n   assign dec_i0_pc4_d = pc0[0];\n\n   assign dec_i0_icaf_type_d[1:0] = ifu_i0_icaf_type[1:0];\n\n// GPR accesses\n\n// put reg to read on rs1\n// read ->   or %x0,  %reg,%x0      {000000000000,reg[4:0],110000000110011}\n\n// put write date on rs1\n// write ->  or %reg, %x0, %x0      {00000000000000000110,reg[4:0],0110011}\n\n\n// CSR accesses\n// csr is of form rd, csr, rs1\n\n// read  -> csrrs %x0, %csr, %x0     {csr[11:0],00000010000001110011}\n\n// put write data on rs1\n// write -> csrrw %x0, %csr, %x0     {csr[11:0],00000001000001110011}\n\n// abstract memory command not done here\n   assign debug_valid = dbg_cmd_valid & (dbg_cmd_type[1:0] != 2'h2);\n\n\n   assign debug_read  = debug_valid & ~dbg_cmd_write;\n   assign debug_write = debug_valid &  dbg_cmd_write;\n\n   assign debug_read_gpr  = debug_read  & (dbg_cmd_type[1:0]==2'h0);\n   assign debug_write_gpr = debug_write & (dbg_cmd_type[1:0]==2'h0);\n   assign debug_read_csr  = debug_read  & (dbg_cmd_type[1:0]==2'h1);\n   assign debug_write_csr = debug_write & (dbg_cmd_type[1:0]==2'h1);\n\n   assign dreg[4:0]  = dbg_cmd_addr[4:0];\n   assign dcsr[11:0] = dbg_cmd_addr[11:0];\n\n\n   assign ib0_debug_in[31:0] = ({32{debug_read_gpr}}  & {12'b000000000000,dreg[4:0],15'b110000000110011}) |\n                               ({32{debug_write_gpr}} & {20'b00000000000000000110,dreg[4:0],7'b0110011}) |\n                               ({32{debug_read_csr}}  & {dcsr[11:0],20'b00000010000001110011}) |\n                               ({32{debug_write_csr}} & {dcsr[11:0],20'b00000001000001110011});\n\n\n\n   // machine is in halted state, pipe empty, write will always happen next cycle\n\n   assign dec_debug_wdata_rs1_d = debug_write_gpr | debug_write_csr;\n\n\n   // special fence csr for use only in debug mode\n\n   assign dec_debug_fence_d = debug_write_csr & (dcsr[11:0] == 12'h7c4);\n\n   assign ib0[31:0] = (debug_valid) ? ib0_debug_in[31:0] : ifu_i0_instr[31:0];\n\n   assign dec_ib0_valid_d = ifu_i0_valid | debug_valid;\n\n   assign dec_debug_valid_d = debug_valid;\n\n   assign dec_i0_instr_d[31:0] = ib0[31:0];\n\n   assign dec_i0_brp = i0_brp;\n   assign dec_i0_bp_index = ifu_i0_bp_index;\n   assign dec_i0_bp_fghr = ifu_i0_bp_fghr;\n   assign dec_i0_bp_btag = ifu_i0_bp_btag;\n   assign dec_i0_bp_fa_index = ifu_i0_fa_index;\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2023 Antmicro <www.antmicro.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n//********************************************************************************\n// el2_dec_pmp_ctl.sv\n//\n//\n// Function: Physical Memory Protection CSRs\n// Comments:\n//\n//********************************************************************************\n\n\nmodule el2_dec_pmp_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n   input logic clk,\n   input logic free_l2clk,\n   input logic csr_wr_clk,\n   input logic rst_l,\n   input logic        dec_csr_wen_r_mod,  // csr write enable at wb\n   input logic [11:0] dec_csr_wraddr_r,   // write address for csr\n   input logic [31:0] dec_csr_wrdata_r,   // csr write data at wb\n   input logic [11:0] dec_csr_rdaddr_d,   // read address for csr\n\n   input logic csr_pmpcfg,\n   input logic csr_pmpaddr0,\n   input logic csr_pmpaddr16,\n   input logic csr_pmpaddr32,\n   input logic csr_pmpaddr48,\n\n   input logic dec_pause_state, // Paused\n   input logic dec_tlu_pmu_fw_halted, // pmu/fw halted\n   input logic internal_dbg_halt_timers, // debug halted\n\n   output logic [31:0] dec_pmp_rddata_d, // pmp CSR read data\n   output logic        dec_pmp_read_d, // pmp CSR address match\n\n   output el2_pmp_cfg_pkt_t pmp_pmpcfg  [pt.PMP_ENTRIES],\n   output logic [31:0]      pmp_pmpaddr [pt.PMP_ENTRIES],\n\n   input  logic        scan_mode\n   );\n\n   logic wr_pmpcfg_r;\n   logic [3:0] wr_pmpcfg_group;\n\n   logic wr_pmpaddr0_sel;\n   logic wr_pmpaddr16_sel;\n   logic wr_pmpaddr32_sel;\n   logic wr_pmpaddr48_sel;\n   logic wr_pmpaddr_r;\n   logic [1:0] wr_pmpaddr_quarter;\n   logic [5:0] wr_pmpaddr_address;\n\n   logic  [3:0] pmp_quarter_rdaddr;\n   logic [31:0] pmp_pmpcfg_rddata;\n\n   // ----------------------------------------------------------------------\n   // PMPCFGx (RW)\n   // [31:24] : PMP entry (x*4 + 3) configuration\n   // [23:16] : PMP entry (x*4 + 2) configuration\n   // [15:8] : PMP entry (x*4 + 1) configuration\n   //  [7:0] : PMP entry (x*4 + 0) configuration\n\n   localparam PMPCFG       = 12'h3a0;\n\n   assign wr_pmpcfg_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:4] == PMPCFG[11:4]);\n   assign wr_pmpcfg_group = dec_csr_wraddr_r[3:0]; // selects group of 4 pmpcfg entries (group 1 -> entries 4-7; up to 16 groups)\n\n   for (genvar entry_idx = 0; entry_idx < pt.PMP_ENTRIES; entry_idx++) begin : gen_pmpcfg_ff\n      rvdffe #(8) pmpcfg_ff (.*, .clk(free_l2clk),\n                          .en(wr_pmpcfg_r & (wr_pmpcfg_group == entry_idx[5:2]) & (~pmp_pmpcfg[entry_idx].lock)),\n                          .din(dec_csr_wrdata_r[(entry_idx[1:0]*8)+7:(entry_idx[1:0]*8)+0] & 8'b10011111),\n                          .dout(pmp_pmpcfg[entry_idx]));\n   end\n\n   // ----------------------------------------------------------------------\n   // PMPADDRx (RW)\n   // [31:0] : PMP entry (x) address selector (word addressing)\n   //\n   // NOTE: VeeR-EL2 uses 32-bit physical addressing, register bits 31:30 mapping\n   //       to bits 33:32 of the physical address are always set to 0. (WARL)\n\n   localparam  PMPADDR0      = 12'h3b0;\n   localparam PMPADDR16      = 12'h3c0;\n   localparam PMPADDR32      = 12'h3d0;\n   localparam PMPADDR48      = 12'h3e0;\n\n   assign wr_pmpaddr0_sel  = dec_csr_wraddr_r[11:4] ==  PMPADDR0[11:4];\n   assign wr_pmpaddr16_sel = dec_csr_wraddr_r[11:4] == PMPADDR16[11:4];\n   assign wr_pmpaddr32_sel = dec_csr_wraddr_r[11:4] == PMPADDR32[11:4];\n   assign wr_pmpaddr48_sel = dec_csr_wraddr_r[11:4] == PMPADDR48[11:4];\n   assign wr_pmpaddr_r = dec_csr_wen_r_mod & (wr_pmpaddr0_sel | wr_pmpaddr16_sel | wr_pmpaddr32_sel | wr_pmpaddr48_sel);\n\n   assign wr_pmpaddr_quarter[0] = wr_pmpaddr16_sel | wr_pmpaddr48_sel;\n   assign wr_pmpaddr_quarter[1] = wr_pmpaddr32_sel | wr_pmpaddr48_sel;\n   assign wr_pmpaddr_address = {wr_pmpaddr_quarter, dec_csr_wraddr_r[3:0]}; // entry address\n\n   for (genvar entry_idx = 0; entry_idx < pt.PMP_ENTRIES; entry_idx++) begin : gen_pmpaddr_ff\n      logic pmpaddr_lock;\n      logic pmpaddr_lock_next;\n      assign pmpaddr_lock_next = ((entry_idx+1 < pt.PMP_ENTRIES)\n                                  ? (pmp_pmpcfg[entry_idx+1].lock\n                                     & pmp_pmpcfg[entry_idx+1].mode == TOR)\n                                  : 1'b0);\n      assign pmpaddr_lock = pmp_pmpcfg[entry_idx].lock | pmpaddr_lock_next;\n      assign pmp_pmpaddr[entry_idx][31:30] = 2'b00;\n      rvdffe #(30) pmpaddr_ff (.*, .clk(free_l2clk),\n                          .en(wr_pmpaddr_r & (wr_pmpaddr_address == entry_idx)\n                              & (~pmpaddr_lock)),\n                          .din(dec_csr_wrdata_r[29:0]),\n                          .dout(pmp_pmpaddr[entry_idx][29:0]));\n   end\n\n   // CSR read mux\n\n   assign pmp_quarter_rdaddr     = dec_csr_rdaddr_d[3:0];\n   assign pmp_pmpcfg_rddata      = { pmp_pmpcfg[{pmp_quarter_rdaddr, 2'h3}],\n                                     pmp_pmpcfg[{pmp_quarter_rdaddr, 2'h2}],\n                                     pmp_pmpcfg[{pmp_quarter_rdaddr, 2'h1}],\n                                     pmp_pmpcfg[{pmp_quarter_rdaddr, 2'h0}]\n                                     };\n   assign dec_pmp_read_d         = csr_pmpcfg | csr_pmpaddr0 | csr_pmpaddr16 | csr_pmpaddr32 | csr_pmpaddr48;\n   assign dec_pmp_rddata_d[31:0] = ( ({32{csr_pmpcfg}}    & pmp_pmpcfg_rddata) |\n                                     ({32{csr_pmpaddr0}}  & pmp_pmpaddr[{2'h0, pmp_quarter_rdaddr}]) |\n                                     ({32{csr_pmpaddr16}} & pmp_pmpaddr[{2'h1, pmp_quarter_rdaddr}]) |\n                                     ({32{csr_pmpaddr32}} & pmp_pmpaddr[{2'h2, pmp_quarter_rdaddr}]) |\n                                     ({32{csr_pmpaddr48}} & pmp_pmpaddr[{2'h3, pmp_quarter_rdaddr}])\n                                     );\n\nendmodule // dec_pmp_ctl\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or it's affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n//********************************************************************************\n// el2_dec_tlu_ctl.sv\n//\n//\n// Function: CSRs, Commit/WB, flushing, exceptions, interrupts\n// Comments:\n//\n//********************************************************************************\n\nmodule el2_dec_tlu_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n   input logic clk,\n   input logic free_clk,\n   input logic free_l2clk,\n   input logic rst_l,\n   input logic scan_mode,\n\n   input logic [31:1] rst_vec, // reset vector, from core pins\n   input logic        nmi_int, // nmi pin\n   input logic [31:1] nmi_vec, // nmi vector\n   input logic  i_cpu_halt_req,    // Asynchronous Halt request to CPU\n   input logic  i_cpu_run_req,     // Asynchronous Restart request to CPU\n\n   input logic lsu_fastint_stall_any,   // needed by lsu for 2nd pass of dma with ecc correction, stall next cycle\n\n\n   // perf counter inputs\n   input logic       ifu_pmu_instr_aligned,   // aligned instructions\n   input logic       ifu_pmu_fetch_stall, // fetch unit stalled\n   input logic       ifu_pmu_ic_miss, // icache miss\n   input logic       ifu_pmu_ic_hit, // icache hit\n   input logic       ifu_pmu_bus_error, // Instruction side bus error\n   input logic       ifu_pmu_bus_busy, // Instruction side bus busy\n   input logic       ifu_pmu_bus_trxn, // Instruction side bus transaction\n   input logic       dec_pmu_instr_decoded, // decoded instructions\n   input logic       dec_pmu_decode_stall, // decode stall\n   input logic       dec_pmu_presync_stall, // decode stall due to presync'd inst\n   input logic       dec_pmu_postsync_stall,// decode stall due to postsync'd inst\n   input logic       lsu_store_stall_any,    // SB or WB is full, stall decode\n   input logic       dma_dccm_stall_any,     // DMA stall of lsu\n   input logic       dma_iccm_stall_any,     // DMA stall of ifu\n   input logic       exu_pmu_i0_br_misp,     // pipe 0 branch misp\n   input logic       exu_pmu_i0_br_ataken,   // pipe 0 branch actual taken\n   input logic       exu_pmu_i0_pc4,         // pipe 0 4 byte branch\n   input logic       lsu_pmu_bus_trxn,       // D side bus transaction\n   input logic       lsu_pmu_bus_misaligned, // D side bus misaligned\n   input logic       lsu_pmu_bus_error,      // D side bus error\n   input logic       lsu_pmu_bus_busy,       // D side bus busy\n   input logic       lsu_pmu_load_external_m, // D side bus load\n   input logic       lsu_pmu_store_external_m, // D side bus store\n   input logic       dma_pmu_dccm_read,          // DMA DCCM read\n   input logic       dma_pmu_dccm_write,         // DMA DCCM write\n   input logic       dma_pmu_any_read,           // DMA read\n   input logic       dma_pmu_any_write,          // DMA write\n\n   input logic [31:1] lsu_fir_addr, // Fast int address\n   input logic [1:0] lsu_fir_error, // Fast int lookup error\n\n   input logic       iccm_dma_sb_error,      // I side dma single bit error\n\n   input    el2_lsu_error_pkt_t lsu_error_pkt_r, // lsu precise exception/error packet\n   input logic         lsu_single_ecc_error_incr, // LSU inc SB error counter\n\n   input logic dec_pause_state, // Pause counter not zero\n   input logic         lsu_imprecise_error_store_any,      // store bus error\n   input logic         lsu_imprecise_error_load_any,      // store bus error\n   input logic [31:0]  lsu_imprecise_error_addr_any, // store bus error address\n\n   input logic        dec_csr_wen_unq_d,       // valid csr with write - for csr legal\n   input logic        dec_csr_any_unq_d,       // valid csr - for csr legal\n   input logic [11:0] dec_csr_rdaddr_d,      // read address for csr\n\n   input logic        dec_csr_wen_r,      // csr write enable at wb\n   input logic [11:0] dec_csr_wraddr_r,      // write address for csr\n   input logic [31:0] dec_csr_wrdata_r,   // csr write data at wb\n\n   input logic        dec_csr_stall_int_ff, // csr is mie/mstatus\n\n   input logic dec_tlu_i0_valid_r, // pipe 0 op at e4 is valid\n\n   input logic [31:1] exu_npc_r, // for NPC tracking\n\n   input logic [31:1] dec_tlu_i0_pc_r, // for PC/NPC tracking\n\n   input el2_trap_pkt_t dec_tlu_packet_r, // exceptions known at decode\n\n   input logic [31:0] dec_illegal_inst, // For mtval\n   input logic        dec_i0_decode_d,  // decode valid, used for clean icache diagnostics\n\n   // branch info from pipe0 for errors or counter updates\n   input logic [1:0]  exu_i0_br_hist_r, // history\n   input logic        exu_i0_br_error_r, // error\n   input logic        exu_i0_br_start_error_r, // start error\n   input logic        exu_i0_br_valid_r, // valid\n   input logic        exu_i0_br_mp_r, // mispredict\n   input logic        exu_i0_br_middle_r, // middle of bank\n\n   // branch info from pipe1 for errors or counter updates\n\n   input logic             exu_i0_br_way_r, // way hit or repl\n\n   output logic dec_tlu_core_empty,  // core is empty\n   // Debug start\n   output logic dec_dbg_cmd_done, // abstract command done\n   output logic dec_dbg_cmd_fail, // abstract command failed\n   output logic dec_tlu_dbg_halted, // Core is halted and ready for debug command\n   output logic dec_tlu_debug_mode, // Core is in debug mode\n   output logic dec_tlu_resume_ack, // Resume acknowledge\n   output logic dec_tlu_debug_stall, // stall decode while waiting on core to empty\n\n   output logic dec_tlu_flush_noredir_r , // Tell fetch to idle on this flush\n   output logic dec_tlu_mpc_halted_only, // Core is halted only due to MPC\n   output logic dec_tlu_flush_leak_one_r, // single step\n   output logic dec_tlu_flush_err_r, // iside perr/ecc rfpc. This is the D stage of the error\n\n   output logic dec_tlu_flush_extint, // fast ext int started\n   output logic [31:2] dec_tlu_meihap, // meihap for fast int\n\n   input  logic dbg_halt_req, // DM requests a halt\n   input  logic dbg_resume_req, // DM requests a resume\n   input  logic ifu_miss_state_idle, // I-side miss buffer empty\n   input  logic lsu_idle_any, // lsu is idle\n   input  logic dec_div_active, // oop div is active\n   output el2_trigger_pkt_t  [3:0] trigger_pkt_any, // trigger info for trigger blocks\n\n   input logic  ifu_ic_error_start,     // IC single bit error\n   input logic  ifu_iccm_rd_ecc_single_err, // ICCM single bit error\n\n\n   input logic [70:0] ifu_ic_debug_rd_data, // diagnostic icache read data\n   input logic ifu_ic_debug_rd_data_valid, // diagnostic icache read data valid\n   output el2_cache_debug_pkt_t dec_tlu_ic_diag_pkt, // packet of DICAWICS, DICAD0/1, DICAGO info for icache diagnostics\n   // Debug end\n\n   input logic [7:0] pic_claimid, // pic claimid for csr\n   input logic [3:0] pic_pl, // pic priv level for csr\n   input logic       mhwakeup, // high priority external int, wakeup if halted\n\n   input logic mexintpend, // external interrupt pending\n   input logic timer_int, // timer interrupt pending\n   input logic soft_int, // software interrupt pending\n\n   output logic o_cpu_halt_status, // PMU interface, halted\n   output logic o_cpu_halt_ack, // halt req ack\n   output logic o_cpu_run_ack, // run req ack\n   output logic o_debug_mode_status, // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n\n   input logic [31:4] core_id, // Core ID\n\n   // external MPC halt/run interface\n   input logic mpc_debug_halt_req, // Async halt request\n   input logic mpc_debug_run_req, // Async run request\n   input logic mpc_reset_run_req, // Run/halt after reset\n   output logic mpc_debug_halt_ack, // Halt ack\n   output logic mpc_debug_run_ack, // Run ack\n   output logic debug_brkpt_status, // debug breakpoint\n\n   output logic [3:0] dec_tlu_meicurpl, // to PIC\n   output logic [3:0] dec_tlu_meipt, // to PIC\n\n\n   output logic [31:0] dec_csr_rddata_d,      // csr read data at wb\n   output logic dec_csr_legal_d,              // csr indicates legal operation\n\n   output el2_br_tlu_pkt_t dec_tlu_br0_r_pkt, // branch pkt to bp\n\n   output logic dec_tlu_i0_kill_writeb_wb,    // I0 is flushed, don't writeback any results to arch state\n   output logic dec_tlu_flush_lower_wb,       // commit has a flush (exception, int, mispredict at e4)\n   output logic dec_tlu_i0_commit_cmt,        // committed an instruction\n\n   output logic dec_tlu_i0_kill_writeb_r,    // I0 is flushed, don't writeback any results to arch state\n   output logic dec_tlu_flush_lower_r,       // commit has a flush (exception, int)\n   output logic [31:1] dec_tlu_flush_path_r, // flush pc\n   output logic dec_tlu_fence_i_r,           // flush is a fence_i rfnpc, flush icache\n   output logic dec_tlu_wr_pause_r,           // CSR write to pause reg is at R.\n   output logic dec_tlu_flush_pause_r,        // Flush is due to pause\n\n   output logic dec_tlu_presync_d,            // CSR read needs to be presync'd\n   output logic dec_tlu_postsync_d,           // CSR needs to be presync'd\n\n\n   output logic [31:0] dec_tlu_mrac_ff,        // CSR for memory region control\n\n   output logic dec_tlu_force_halt, // halt has been forced\n\n   output logic dec_tlu_perfcnt0, // toggles when pipe0 perf counter 0 has an event inc\n   output logic dec_tlu_perfcnt1, // toggles when pipe0 perf counter 1 has an event inc\n   output logic dec_tlu_perfcnt2, // toggles when pipe0 perf counter 2 has an event inc\n   output logic dec_tlu_perfcnt3, // toggles when pipe0 perf counter 3 has an event inc\n\n   output logic dec_tlu_i0_exc_valid_wb1, // pipe 0 exception valid\n   output logic dec_tlu_i0_valid_wb1,  // pipe 0 valid\n   output logic dec_tlu_int_valid_wb1, // pipe 2 int valid\n   output logic [4:0] dec_tlu_exc_cause_wb1, // exception or int cause\n   output logic [31:0] dec_tlu_mtval_wb1, // MTVAL value\n\n   // feature disable from mfdc\n   output logic  dec_tlu_external_ldfwd_disable, // disable external load forwarding\n   output logic  dec_tlu_sideeffect_posted_disable,  // disable posted stores to side-effect address\n   output logic  dec_tlu_core_ecc_disable, // disable core ECC\n   output logic  dec_tlu_bpred_disable,           // disable branch prediction\n   output logic  dec_tlu_wb_coalescing_disable,   // disable writebuffer coalescing\n   output logic  dec_tlu_pipelining_disable,      // disable pipelining\n   output logic  dec_tlu_trace_disable,           // disable trace\n   output logic [2:0]  dec_tlu_dma_qos_prty,    // DMA QoS priority coming from MFDC [18:16]\n\n   // clock gating overrides from mcgc\n   output logic  dec_tlu_misc_clk_override, // override misc clock domain gating\n   output logic  dec_tlu_dec_clk_override,  // override decode clock domain gating\n   output logic  dec_tlu_ifu_clk_override,  // override fetch clock domain gating\n   output logic  dec_tlu_lsu_clk_override,  // override load/store clock domain gating\n   output logic  dec_tlu_bus_clk_override,  // override bus clock domain gating\n   output logic  dec_tlu_pic_clk_override,  // override PIC clock domain gating\n   output logic  dec_tlu_picio_clk_override,// override PICIO clock domain gating\n   output logic  dec_tlu_dccm_clk_override, // override DCCM clock domain gating\n   output logic  dec_tlu_icm_clk_override,  // override ICCM clock domain gating\n\n   // pmp\n   output el2_pmp_cfg_pkt_t pmp_pmpcfg  [pt.PMP_ENTRIES],\n   output logic [31:0]      pmp_pmpaddr [pt.PMP_ENTRIES]\n\n   );\n\n   logic         clk_override, e4e5_int_clk, nmi_fir_type, nmi_lsu_load_type, nmi_lsu_store_type, nmi_int_detected_f, nmi_lsu_load_type_f,\n                 nmi_lsu_store_type_f, allow_dbg_halt_csr_write, dbg_cmd_done_ns, i_cpu_run_req_d1_raw, debug_mode_status, lsu_single_ecc_error_r_d1,\n                 sel_npc_r, sel_npc_resume, ce_int,\n                 nmi_in_debug_mode, dpc_capture_npc, dpc_capture_pc, tdata_load, tdata_opcode, tdata_action, perfcnt_halted, tdata_chain,\n                 tdata_kill_write;\n\n\n   logic reset_delayed, reset_detect, reset_detected;\n   logic wr_mstatus_r, wr_mtvec_r, wr_mcyclel_r, wr_mcycleh_r,\n         wr_minstretl_r, wr_minstreth_r, wr_mscratch_r, wr_mepc_r, wr_mcause_r, wr_mscause_r, wr_mtval_r,\n         wr_mrac_r, wr_meihap_r, wr_meicurpl_r, wr_meipt_r, wr_dcsr_r,\n         wr_dpc_r, wr_meicidpl_r, wr_meivt_r, wr_meicpct_r, wr_micect_r, wr_miccmect_r, wr_mfdht_r, wr_mfdhs_r,\n         wr_mdccmect_r,wr_mhpme3_r, wr_mhpme4_r, wr_mhpme5_r, wr_mhpme6_r;\n   logic wr_mpmc_r;\n   logic [1:1] mpmc_b_ns, mpmc, mpmc_b;\n   logic set_mie_pmu_fw_halt, fw_halted_ns, fw_halted;\n   logic wr_mcountinhibit_r;\n   logic [6:0] mcountinhibit;\n   logic wr_mtsel_r, wr_mtdata1_t0_r, wr_mtdata1_t1_r, wr_mtdata1_t2_r, wr_mtdata1_t3_r, wr_mtdata2_t0_r, wr_mtdata2_t1_r, wr_mtdata2_t2_r, wr_mtdata2_t3_r;\n   logic [31:0] mtdata2_t0, mtdata2_t1, mtdata2_t2, mtdata2_t3, mtdata2_tsel_out, mtdata1_tsel_out;\n   logic [9:0]  mtdata1_t0_ns, mtdata1_t0, mtdata1_t1_ns, mtdata1_t1, mtdata1_t2_ns, mtdata1_t2, mtdata1_t3_ns, mtdata1_t3;\n   logic [9:0] tdata_wrdata_r;\n   logic [1:0] mtsel_ns, mtsel;\n   logic tlu_i0_kill_writeb_r;\n   logic [1:0]  mstatus_ns, mstatus;\n   logic [1:0] mfdhs_ns, mfdhs;\n   logic [31:0] force_halt_ctr, force_halt_ctr_f;\n   logic        force_halt;\n   logic [5:0]  mfdht, mfdht_ns;\n   logic mstatus_mie_ns;\n   logic [30:0] mtvec_ns, mtvec;\n   logic [15:2] dcsr_ns, dcsr;\n   logic [5:0] mip_ns, mip;\n   logic [5:0] mie_ns, mie;\n   logic [31:0] mcyclel_ns, mcyclel;\n   logic [31:0] mcycleh_ns, mcycleh;\n   logic [31:0] minstretl_ns, minstretl;\n   logic [31:0] minstreth_ns, minstreth;\n   logic [31:0] micect_ns, micect, miccmect_ns, miccmect, mdccmect_ns, mdccmect;\n   logic [26:0] micect_inc, miccmect_inc, mdccmect_inc;\n   logic [31:0] mscratch;\n   logic [31:0] mhpmc3, mhpmc3_ns, mhpmc4, mhpmc4_ns, mhpmc5, mhpmc5_ns, mhpmc6, mhpmc6_ns;\n   logic [31:0] mhpmc3h, mhpmc3h_ns, mhpmc4h, mhpmc4h_ns, mhpmc5h, mhpmc5h_ns, mhpmc6h, mhpmc6h_ns;\n   logic [9:0]  mhpme3, mhpme4, mhpme5, mhpme6;\n   logic [31:0] mrac;\n   logic [9:2] meihap;\n   logic [31:10] meivt;\n   logic [3:0] meicurpl_ns, meicurpl;\n   logic [3:0] meicidpl_ns, meicidpl;\n   logic [3:0] meipt_ns, meipt;\n   logic [31:0] mdseac;\n   logic mdseac_locked_ns, mdseac_locked_f, mdseac_en, nmi_lsu_detected;\n   logic [31:1] mepc_ns, mepc;\n   logic [31:1] dpc_ns, dpc;\n   logic [31:0] mcause_ns, mcause;\n   logic [3:0] mscause_ns, mscause, mscause_type;\n   logic [31:0] mtval_ns, mtval;\n   logic dec_pause_state_f, dec_tlu_wr_pause_r_d1, pause_expired_r, pause_expired_wb;\n   logic        tlu_flush_lower_r, tlu_flush_lower_r_d1;\n   logic [31:1] tlu_flush_path_r,  tlu_flush_path_r_d1;\n   logic i0_valid_wb;\n   logic tlu_i0_commit_cmt;\n   logic [31:1] vectored_path, interrupt_path;\n   logic [16:0] dicawics_ns, dicawics;\n   logic        wr_dicawics_r, wr_dicad0_r, wr_dicad1_r, wr_dicad0h_r;\n   logic [31:0] dicad0_ns, dicad0, dicad0h_ns, dicad0h;\n\n   logic [6:0]  dicad1_ns, dicad1_raw;\n   logic [31:0] dicad1;\n   logic        ebreak_r, ebreak_to_debug_mode_r, ecall_r, illegal_r, mret_r, inst_acc_r, fence_i_r,\n                ic_perr_r, iccm_sbecc_r, ebreak_to_debug_mode_r_d1, kill_ebreak_count_r, inst_acc_second_r;\n   logic ce_int_ready, ext_int_ready, timer_int_ready, soft_int_ready, int_timer0_int_ready, int_timer1_int_ready, mhwakeup_ready,\n         take_ext_int, take_ce_int, take_timer_int, take_soft_int, take_int_timer0_int, take_int_timer1_int, take_nmi, take_nmi_r_d1, int_timer0_int_possible, int_timer1_int_possible;\n   logic i0_exception_valid_r, interrupt_valid_r, i0_exception_valid_r_d1, interrupt_valid_r_d1, exc_or_int_valid_r, exc_or_int_valid_r_d1, mdccme_ce_req, miccme_ce_req, mice_ce_req;\n   logic synchronous_flush_r;\n   logic [4:0]  exc_cause_r, exc_cause_wb;\n   logic        mcyclel_cout, mcyclel_cout_f, mcyclela_cout;\n   logic [31:0] mcyclel_inc;\n   logic [31:0] mcycleh_inc;\n\n   logic        minstretl_cout, minstretl_cout_f, minstret_enable, minstretl_cout_ns, minstretl_couta;\n\n   logic [31:0] minstretl_inc, minstretl_read;\n   logic [31:0] minstreth_inc, minstreth_read;\n   logic [31:1] pc_r, pc_r_d1, npc_r, npc_r_d1;\n   logic valid_csr;\n   logic rfpc_i0_r;\n   logic lsu_i0_rfnpc_r;\n   logic dec_tlu_br0_error_r, dec_tlu_br0_start_error_r, dec_tlu_br0_v_r;\n   logic lsu_i0_exc_r, lsu_i0_exc_r_raw, lsu_exc_ma_r, lsu_exc_acc_r, lsu_exc_st_r,\n         lsu_exc_valid_r, lsu_exc_valid_r_raw, lsu_exc_valid_r_d1, lsu_i0_exc_r_d1, block_interrupts;\n   logic i0_trigger_eval_r;\n\n   logic request_debug_mode_r, request_debug_mode_r_d1, request_debug_mode_done, request_debug_mode_done_f;\n   logic take_halt, halt_taken, halt_taken_f, internal_dbg_halt_mode, dbg_tlu_halted_f, take_reset,\n         dbg_tlu_halted, core_empty, lsu_idle_any_f, ifu_miss_state_idle_f, resume_ack_ns,\n         debug_halt_req_f, debug_resume_req_f_raw, debug_resume_req_f, enter_debug_halt_req, dcsr_single_step_done, dcsr_single_step_done_f,\n         debug_halt_req_d1, debug_halt_req_ns, dcsr_single_step_running, dcsr_single_step_running_f, internal_dbg_halt_timers;\n\n   logic [3:0] i0_trigger_r, trigger_action, trigger_enabled,\n               i0_trigger_chain_masked_r;\n   logic       i0_trigger_hit_r, i0_trigger_hit_raw_r, i0_trigger_action_r,\n               trigger_hit_r_d1,\n               mepc_trigger_hit_sel_pc_r;\n   logic [3:0] update_hit_bit_r, i0_iside_trigger_has_pri_r,i0trigger_qual_r, i0_lsu_trigger_has_pri_r;\n   logic cpu_halt_status, cpu_halt_ack, cpu_run_ack, ext_halt_pulse, i_cpu_halt_req_d1, i_cpu_run_req_d1;\n\n   logic inst_acc_r_raw, trigger_hit_dmode_r, trigger_hit_dmode_r_d1;\n   logic [9:0] mcgc, mcgc_ns, mcgc_int;\n   logic [18:0] mfdc;\n   logic i_cpu_halt_req_sync_qual, i_cpu_run_req_sync_qual, pmu_fw_halt_req_ns, pmu_fw_halt_req_f, int_timer_stalled,\n         fw_halt_req, enter_pmu_fw_halt_req, pmu_fw_tlu_halted, pmu_fw_tlu_halted_f, internal_pmu_fw_halt_mode,\n         internal_pmu_fw_halt_mode_f, int_timer0_int_hold, int_timer1_int_hold, int_timer0_int_hold_f, int_timer1_int_hold_f;\n   logic nmi_int_delayed, nmi_int_detected;\n   logic [3:0] trigger_execute, trigger_data, trigger_store;\n   logic dec_tlu_pmu_fw_halted;\n\n   logic mpc_run_state_ns, debug_brkpt_status_ns, mpc_debug_halt_ack_ns, mpc_debug_run_ack_ns, dbg_halt_state_ns, dbg_run_state_ns,\n         dbg_halt_state_f, mpc_debug_halt_req_sync_f, mpc_debug_run_req_sync_f, mpc_halt_state_f, mpc_halt_state_ns, mpc_run_state_f, debug_brkpt_status_f,\n         mpc_debug_halt_ack_f, mpc_debug_run_ack_f, dbg_run_state_f, mpc_debug_halt_req_sync_pulse,\n         mpc_debug_run_req_sync_pulse, debug_brkpt_valid, debug_halt_req, debug_resume_req, dec_tlu_mpc_halted_only_ns;\n   logic take_ext_int_start, ext_int_freeze, take_ext_int_start_d1, take_ext_int_start_d2,\n         take_ext_int_start_d3, ext_int_freeze_d1, csr_meicpct, ignore_ext_int_due_to_lsu_stall;\n   logic mcause_sel_nmi_store, mcause_sel_nmi_load, mcause_sel_nmi_ext, fast_int_meicpct;\n   logic [1:0] mcause_fir_error_type;\n   logic dbg_halt_req_held_ns, dbg_halt_req_held, dbg_halt_req_final;\n   logic iccm_repair_state_ns, iccm_repair_state_d1, iccm_repair_state_rfnpc;\n\n\n   // internal timer, isolated for size reasons\n   logic [31:0] dec_timer_rddata_d;\n   logic dec_timer_read_d, dec_timer_t0_pulse, dec_timer_t1_pulse;\n   logic csr_mitctl0;\n   logic csr_mitctl1;\n   logic csr_mitb0;\n   logic csr_mitb1;\n   logic csr_mitcnt0;\n   logic csr_mitcnt1;\n\n   // PMP unit, isolated for size reasons\n   logic [31:0] dec_pmp_rddata_d;\n   logic dec_pmp_read_d;\n   logic csr_pmpcfg;\n   logic csr_pmpaddr0;\n   logic csr_pmpaddr16;\n   logic csr_pmpaddr32;\n   logic cs"}
{"text": "r_pmpaddr48;\n\n   logic nmi_int_sync, timer_int_sync, soft_int_sync, i_cpu_halt_req_sync, i_cpu_run_req_sync, mpc_debug_halt_req_sync, mpc_debug_run_req_sync, mpc_debug_halt_req_sync_raw;\n   logic csr_wr_clk;\n   logic e4e5_clk, e4_valid, e5_valid, e4e5_valid, internal_dbg_halt_mode_f, internal_dbg_halt_mode_f2;\n   logic lsu_pmu_load_external_r, lsu_pmu_store_external_r;\n   logic dec_tlu_flush_noredir_r_d1, dec_tlu_flush_pause_r_d1;\n   logic lsu_single_ecc_error_r;\n   logic [31:0] lsu_error_pkt_addr_r;\n   logic mcyclel_cout_in;\n   logic i0_valid_no_ebreak_ecall_r;\n   logic minstret_enable_f;\n   logic sel_exu_npc_r, sel_flush_npc_r, sel_hold_npc_r;\n   logic pc0_valid_r;\n   logic [15:0] mfdc_int, mfdc_ns;\n   logic [31:0] mrac_in;\n   logic [31:27] csr_sat;\n   logic [8:6] dcsr_cause;\n   logic enter_debug_halt_req_le, dcsr_cause_upgradeable;\n   logic icache_rd_valid, icache_wr_valid, icache_rd_valid_f, icache_wr_valid_f;\n   logic [3:0]      mhpmc_inc_r, mhpmc_inc_r_d1;\n\n   logic [3:0][9:0] mhpme_vec;\n   logic            mhpmc3_wr_en0, mhpmc3_wr_en1, mhpmc3_wr_en;\n   logic            mhpmc4_wr_en0, mhpmc4_wr_en1, mhpmc4_wr_en;\n   logic            mhpmc5_wr_en0, mhpmc5_wr_en1, mhpmc5_wr_en;\n   logic            mhpmc6_wr_en0, mhpmc6_wr_en1, mhpmc6_wr_en;\n   logic            mhpmc3h_wr_en0, mhpmc3h_wr_en;\n   logic            mhpmc4h_wr_en0, mhpmc4h_wr_en;\n   logic            mhpmc5h_wr_en0, mhpmc5h_wr_en;\n   logic            mhpmc6h_wr_en0, mhpmc6h_wr_en;\n   logic [63:0]     mhpmc3_incr, mhpmc4_incr, mhpmc5_incr, mhpmc6_incr;\n   logic perfcnt_halted_d1, zero_event_r;\n   logic [3:0] perfcnt_during_sleep;\n   logic [9:0] event_r;\n\n   el2_inst_pkt_t pmu_i0_itype_qual;\n\n   logic csr_misa;\n   logic csr_mvendorid;\n   logic csr_marchid;\n   logic csr_mimpid;\n   logic csr_mhartid;\n   logic csr_mstatus;\n   logic csr_mtvec;\n   logic csr_mip;\n   logic csr_mie;\n   logic csr_mcyclel;\n   logic csr_mcycleh;\n   logic csr_minstretl;\n   logic csr_minstreth;\n   logic csr_mscratch;\n   logic csr_mepc;\n   logic csr_mcause;\n   logic csr_mscause;\n   logic csr_mtval;\n   logic csr_mrac;\n   logic csr_dmst;\n   logic csr_mdseac;\n   logic csr_meihap;\n   logic csr_meivt;\n   logic csr_meipt;\n   logic csr_meicurpl;\n   logic csr_meicidpl;\n   logic csr_dcsr;\n   logic csr_mcgc;\n   logic csr_mfdc;\n   logic csr_dpc;\n   logic csr_mtsel;\n   logic csr_mtdata1;\n   logic csr_mtdata2;\n   logic csr_mhpmc3;\n   logic csr_mhpmc4;\n   logic csr_mhpmc5;\n   logic csr_mhpmc6;\n   logic csr_mhpmc3h;\n   logic csr_mhpmc4h;\n   logic csr_mhpmc5h;\n   logic csr_mhpmc6h;\n   logic csr_mhpme3;\n   logic csr_mhpme4;\n   logic csr_mhpme5;\n   logic csr_mhpme6;\n   logic csr_mcountinhibit;\n   logic csr_mpmc;\n   logic csr_mcpc;\n   logic csr_mdeau;\n   logic csr_micect;\n   logic csr_miccmect;\n   logic csr_mdccmect;\n   logic csr_mfdht;\n   logic csr_mfdhs;\n   logic csr_dicawics;\n   logic csr_dicad0h;\n   logic csr_dicad0;\n   logic csr_dicad1;\n   logic csr_dicago;\n   logic valid_only;\n   logic presync;\n   logic postsync;\n   logic legal;\n   logic dec_csr_wen_r_mod;\n\n   logic flush_clkvalid;\n   logic sel_fir_addr;\n   logic wr_mie_r;\n   logic mtval_capture_pc_r;\n   logic mtval_capture_pc_plus2_r;\n   logic mtval_capture_inst_r;\n   logic mtval_capture_lsu_r;\n   logic mtval_clear_r;\n   logic wr_mcgc_r;\n   logic wr_mfdc_r;\n   logic wr_mdeau_r;\n   logic trigger_hit_for_dscr_cause_r_d1;\n   logic conditionally_illegal;\n\n   logic  [3:0] ifu_mscause ;\n   logic        ifu_ic_error_start_f, ifu_iccm_rd_ecc_single_err_f;\n\n   el2_dec_timer_ctl  #(.pt(pt)) int_timers(.*);\n   // end of internal timers\n\n   el2_dec_pmp_ctl  #(.pt(pt)) pmp(.*);\n   // end of pmp\n\n   assign clk_override = dec_tlu_dec_clk_override;\n\n   // Async inputs to the core have to be sync'd to the core clock.\n   rvsyncss #(7) syncro_ff(.*,\n                           .clk(free_clk),\n                           .din ({nmi_int,      timer_int,      soft_int,      i_cpu_halt_req,      i_cpu_run_req,      mpc_debug_halt_req,          mpc_debug_run_req}),\n                           .dout({nmi_int_sync, timer_int_sync, soft_int_sync, i_cpu_halt_req_sync, i_cpu_run_req_sync, mpc_debug_halt_req_sync_raw, mpc_debug_run_req_sync}));\n\n   // for CSRs that have inpipe writes only\n\n   rvoclkhdr csrwr_r_cgc   ( .en(dec_csr_wen_r_mod | clk_override), .l1clk(csr_wr_clk), .* );\n\n   assign e4_valid = dec_tlu_i0_valid_r;\n   assign e4e5_valid = e4_valid | e5_valid;\n   assign flush_clkvalid = internal_dbg_halt_mode_f | i_cpu_run_req_d1 | interrupt_valid_r | interrupt_valid_r_d1 |\n                           reset_delayed | pause_expired_r | pause_expired_wb | ic_perr_r | iccm_sbecc_r |\n                           clk_override;\n   rvoclkhdr e4e5_cgc     ( .en(e4e5_valid | clk_override), .l1clk(e4e5_clk), .* );\n   rvoclkhdr e4e5_int_cgc ( .en(e4e5_valid | flush_clkvalid), .l1clk(e4e5_int_clk), .* );\n\n   rvdffie #(11)  freeff (.*, .clk(free_l2clk),\n                          .din ({ifu_ic_error_start, ifu_iccm_rd_ecc_single_err, iccm_repair_state_ns, e4_valid, internal_dbg_halt_mode,\n                                 lsu_pmu_load_external_m, lsu_pmu_store_external_m, tlu_flush_lower_r,  tlu_i0_kill_writeb_r,\n                                 internal_dbg_halt_mode_f, force_halt}),\n                          .dout({ifu_ic_error_start_f, ifu_iccm_rd_ecc_single_err_f, iccm_repair_state_d1, e5_valid, internal_dbg_halt_mode_f,\n                                 lsu_pmu_load_external_r, lsu_pmu_store_external_r, tlu_flush_lower_r_d1, dec_tlu_i0_kill_writeb_wb,\n                                 internal_dbg_halt_mode_f2, dec_tlu_force_halt}));\n\n   assign dec_tlu_i0_kill_writeb_r = tlu_i0_kill_writeb_r;\n\n   assign nmi_int_detected = (nmi_int_sync & ~nmi_int_delayed) | nmi_lsu_detected | (nmi_int_detected_f & ~take_nmi_r_d1) | nmi_fir_type;\n   // if the first nmi is a lsu type, note it. If there's already an nmi pending, ignore. Simultaneous with FIR, drop.\n   assign nmi_lsu_load_type  = (nmi_lsu_detected & lsu_imprecise_error_load_any &  ~(nmi_int_detected_f & ~take_nmi_r_d1)) |\n                               (nmi_lsu_load_type_f  & ~take_nmi_r_d1);\n   assign nmi_lsu_store_type = (nmi_lsu_detected & lsu_imprecise_error_store_any & ~(nmi_int_detected_f & ~take_nmi_r_d1)) |\n                               (nmi_lsu_store_type_f & ~take_nmi_r_d1);\n\n   assign nmi_fir_type = ~nmi_int_detected_f & take_ext_int_start_d3 & |lsu_fir_error[1:0];\n\n   // Filter subsequent bus errors after the first, until the lock on MDSEAC is cleared\n   assign nmi_lsu_detected = ~mdseac_locked_f & (lsu_imprecise_error_load_any | lsu_imprecise_error_store_any) & ~nmi_fir_type;\n\n\nlocalparam MSTATUS_MIE   = 0;\nlocalparam MIP_MCEIP     = 5;\nlocalparam MIP_MITIP0    = 4;\nlocalparam MIP_MITIP1    = 3;\nlocalparam MIP_MEIP      = 2;\nlocalparam MIP_MTIP      = 1;\nlocalparam MIP_MSIP      = 0;\n\nlocalparam MIE_MCEIE     = 5;\nlocalparam MIE_MITIE0    = 4;\nlocalparam MIE_MITIE1    = 3;\nlocalparam MIE_MEIE      = 2;\nlocalparam MIE_MTIE      = 1;\nlocalparam MIE_MSIE      = 0;\n\nlocalparam DCSR_EBREAKM  = 15;\nlocalparam DCSR_STEPIE   = 11;\nlocalparam DCSR_STOPC    = 10;\nlocalparam DCSR_STEP     = 2;\n\n\n   assign reset_delayed = reset_detect ^ reset_detected;\n\n   // ----------------------------------------------------------------------\n   // MPC halt\n   // - can interact with debugger halt and v-v\n\n   // fast ints in progress have priority\n   assign mpc_debug_halt_req_sync = mpc_debug_halt_req_sync_raw & ~ext_int_freeze_d1;\n\n    rvdffie #(16)  mpvhalt_ff (.*, .clk(free_l2clk),\n                                 .din({1'b1, reset_detect,\n                                       nmi_int_sync, nmi_int_detected, nmi_lsu_load_type, nmi_lsu_store_type,\n                                       mpc_debug_halt_req_sync, mpc_debug_run_req_sync,\n                                       mpc_halt_state_ns, mpc_run_state_ns, debug_brkpt_status_ns,\n                                       mpc_debug_halt_ack_ns, mpc_debug_run_ack_ns,\n                                       dbg_halt_state_ns, dbg_run_state_ns,\n                                       dec_tlu_mpc_halted_only_ns}),\n                                .dout({reset_detect, reset_detected,\n                                       nmi_int_delayed, nmi_int_detected_f, nmi_lsu_load_type_f, nmi_lsu_store_type_f,\n                                       mpc_debug_halt_req_sync_f, mpc_debug_run_req_sync_f,\n                                       mpc_halt_state_f, mpc_run_state_f, debug_brkpt_status_f,\n                                       mpc_debug_halt_ack_f, mpc_debug_run_ack_f,\n                                       dbg_halt_state_f, dbg_run_state_f,\n                                       dec_tlu_mpc_halted_only}));\n\n   // turn level sensitive requests into pulses\n   assign mpc_debug_halt_req_sync_pulse = mpc_debug_halt_req_sync & ~mpc_debug_halt_req_sync_f;\n   assign mpc_debug_run_req_sync_pulse = mpc_debug_run_req_sync & ~mpc_debug_run_req_sync_f;\n\n   // states\n   assign mpc_halt_state_ns = (mpc_halt_state_f | mpc_debug_halt_req_sync_pulse | (reset_delayed & ~mpc_reset_run_req)) & ~mpc_debug_run_req_sync;\n   assign mpc_run_state_ns = (mpc_run_state_f | (mpc_debug_run_req_sync_pulse & ~mpc_debug_run_ack_f)) & (internal_dbg_halt_mode_f & ~dcsr_single_step_running_f);\n\n   // note, MPC halt can allow the jtag debugger to just start sending commands. When that happens, set the interal debugger halt state to prevent\n   // MPC run from starting the core.\n   assign dbg_halt_state_ns = (dbg_halt_state_f | (dbg_halt_req_final | dcsr_single_step_done_f | trigger_hit_dmode_r_d1 | ebreak_to_debug_mode_r_d1)) & ~dbg_resume_req;\n   assign dbg_run_state_ns = (dbg_run_state_f | dbg_resume_req) & (internal_dbg_halt_mode_f & ~dcsr_single_step_running_f);\n\n   // tell dbg we are only MPC halted\n   assign dec_tlu_mpc_halted_only_ns = ~dbg_halt_state_f & mpc_halt_state_f;\n\n   // this asserts from detection of bkpt until after we leave debug mode\n   assign debug_brkpt_valid = ebreak_to_debug_mode_r_d1 | trigger_hit_dmode_r_d1;\n   assign debug_brkpt_status_ns = (debug_brkpt_valid | debug_brkpt_status_f) & (internal_dbg_halt_mode & ~dcsr_single_step_running_f);\n\n   // acks back to interface\n   assign mpc_debug_halt_ack_ns = (mpc_halt_state_f & internal_dbg_halt_mode_f & mpc_debug_halt_req_sync & core_empty) | (mpc_debug_halt_ack_f & mpc_debug_halt_req_sync);\n   assign mpc_debug_run_ack_ns = (mpc_debug_run_req_sync & ~internal_dbg_halt_mode & ~mpc_debug_halt_req_sync) | (mpc_debug_run_ack_f & mpc_debug_run_req_sync) ;\n\n   // Pins\n   assign mpc_debug_halt_ack = mpc_debug_halt_ack_f;\n   assign mpc_debug_run_ack = mpc_debug_run_ack_f;\n   assign debug_brkpt_status = debug_brkpt_status_f;\n\n   // DBG halt req is a pulse, fast ext int in progress has priority\n   assign dbg_halt_req_held_ns = (dbg_halt_req | dbg_halt_req_held) & ext_int_freeze_d1;\n   assign dbg_halt_req_final = (dbg_halt_req | dbg_halt_req_held) & ~ext_int_freeze_d1;\n\n   // combine MPC and DBG halt requests\n   assign debug_halt_req = (dbg_halt_req_final | mpc_debug_halt_req_sync | (reset_delayed & ~mpc_reset_run_req)) & ~internal_dbg_halt_mode_f & ~ext_int_freeze_d1;\n\n   assign debug_resume_req = ~debug_resume_req_f &  // squash back to back resumes\n                             ((mpc_run_state_ns & ~dbg_halt_state_ns) |  // MPC run req\n                              (dbg_run_state_ns & ~mpc_halt_state_ns)); // dbg request is a pulse\n\n\n   // HALT\n   // dbg/pmu/fw requests halt, service as soon as lsu is not blocking interrupts\n   assign take_halt = (debug_halt_req_f | pmu_fw_halt_req_f) & ~synchronous_flush_r & ~mret_r & ~halt_taken_f & ~dec_tlu_flush_noredir_r_d1 & ~take_reset;\n\n   // hold after we take a halt, so we don't keep taking halts\n   assign halt_taken = (dec_tlu_flush_noredir_r_d1 & ~dec_tlu_flush_pause_r_d1 & ~take_ext_int_start_d1) | (halt_taken_f & ~dbg_tlu_halted_f & ~pmu_fw_tlu_halted_f & ~interrupt_valid_r_d1);\n\n   // After doing halt flush (RFNPC) wait until core is idle before asserting a particular halt mode\n   // It takes a cycle for mb_empty to assert after a fetch, take_halt covers that cycle\n   assign core_empty = force_halt |\n                       (lsu_idle_any & lsu_idle_any_f & ifu_miss_state_idle & ifu_miss_state_idle_f & ~debug_halt_req & ~debug_halt_req_d1 & ~dec_div_active);\n\n   assign dec_tlu_core_empty = core_empty;\n\n//--------------------------------------------------------------------------------\n// Debug start\n//\n\n   assign enter_debug_halt_req = (~internal_dbg_halt_mode_f & debug_halt_req) | dcsr_single_step_done_f | trigger_hit_dmode_r_d1 | ebreak_to_debug_mode_r_d1;\n\n   // dbg halt state active from request until non-step resume\n   assign internal_dbg_halt_mode = debug_halt_req_ns | (internal_dbg_halt_mode_f & ~(debug_resume_req_f & ~dcsr[DCSR_STEP]));\n   // dbg halt can access csrs as long as we are not stepping\n   assign allow_dbg_halt_csr_write = internal_dbg_halt_mode_f & ~dcsr_single_step_running_f;\n\n\n   // hold debug_halt_req_ns high until we enter debug halt\n   assign debug_halt_req_ns = enter_debug_halt_req | (debug_halt_req_f & ~dbg_tlu_halted);\n\n   assign dbg_tlu_halted = (debug_halt_req_f & core_empty & halt_taken) | (dbg_tlu_halted_f & ~debug_resume_req_f);\n\n   assign resume_ack_ns = (debug_resume_req_f & dbg_tlu_halted_f & dbg_run_state_ns);\n\n   assign dcsr_single_step_done = dec_tlu_i0_valid_r & ~dec_tlu_dbg_halted & dcsr[DCSR_STEP] & ~rfpc_i0_r;\n\n   assign dcsr_single_step_running = (debug_resume_req_f & dcsr[DCSR_STEP]) | (dcsr_single_step_running_f & ~dcsr_single_step_done_f);\n\n   assign dbg_cmd_done_ns = dec_tlu_i0_valid_r & dec_tlu_dbg_halted;\n\n   // used to hold off commits after an in-pipe debug mode request (triggers, DCSR)\n   assign request_debug_mode_r = (trigger_hit_dmode_r | ebreak_to_debug_mode_r) | (request_debug_mode_r_d1 & ~dec_tlu_flush_lower_wb);\n\n   assign request_debug_mode_done = (request_debug_mode_r_d1 | request_debug_mode_done_f) & ~dbg_tlu_halted_f;\n\n    rvdffie #(18)  halt_ff (.*, .clk(free_l2clk),\n                          .din({dec_tlu_flush_noredir_r, halt_taken, lsu_idle_any, ifu_miss_state_idle, dbg_tlu_halted,\n                                resume_ack_ns, debug_halt_req_ns, debug_resume_req, trigger_hit_dmode_r,\n                                dcsr_single_step_done, debug_halt_req, dec_tlu_wr_pause_r, dec_pause_state,\n                                request_debug_mode_r, request_debug_mode_done, dcsr_single_step_running, dec_tlu_flush_pause_r,\n                                dbg_halt_req_held_ns}),\n                          .dout({dec_tlu_flush_noredir_r_d1, halt_taken_f, lsu_idle_any_f, ifu_miss_state_idle_f, dbg_tlu_halted_f,\n                                 dec_tlu_resume_ack , debug_halt_req_f, debug_resume_req_f_raw, trigger_hit_dmode_r_d1,\n                                 dcsr_single_step_done_f, debug_halt_req_d1, dec_tlu_wr_pause_r_d1, dec_pause_state_f,\n                                 request_debug_mode_r_d1, request_debug_mode_done_f, dcsr_single_step_running_f, dec_tlu_flush_pause_r_d1,\n                                 dbg_halt_req_held}));\n\n   // MPC run collides with DBG halt, fix it here\n   assign debug_resume_req_f = debug_resume_req_f_raw & ~dbg_halt_req;\n\n   assign dec_tlu_debug_stall = debug_halt_req_f;\n   assign dec_tlu_dbg_halted = dbg_tlu_halted_f;\n   assign dec_tlu_debug_mode = internal_dbg_halt_mode_f;\n   assign dec_tlu_pmu_fw_halted = pmu_fw_tlu_halted_f;\n\n   // kill fetch redirection on flush if going to halt, or if there's a fence during db-halt\n   assign dec_tlu_flush_noredir_r = take_halt | (fence_i_r & internal_dbg_halt_mode) | dec_tlu_flush_pause_r | (i0_trigger_hit_r & trigger_hit_dmode_r) | take_ext_int_start;\n\n   assign dec_tlu_flush_extint = take_ext_int_start;\n\n   // 1 cycle after writing the PAUSE counter, flush with noredir to idle F1-D.\n   assign dec_tlu_flush_pause_r = dec_tlu_wr_pause_r_d1 & ~interrupt_valid_r & ~take_ext_int_start;\n\n   // detect end of pause counter and rfpc\n   assign pause_expired_r = ~dec_pause_state & dec_pause_state_f & ~(ext_int_ready | ce_int_ready | timer_int_ready | soft_int_ready | int_timer0_int_hold_f | int_timer1_int_hold_f | nmi_int_detected | ext_int_freeze_d1) & ~interrupt_valid_r_d1 & ~debug_halt_req_f & ~pmu_fw_halt_req_f & ~halt_taken_f;\n\n   assign dec_tlu_flush_leak_one_r = dec_tlu_flush_lower_r  & dcsr[DCSR_STEP] & (dec_tlu_resume_ack | dcsr_single_step_running) & ~dec_tlu_flush_noredir_r;\n   assign dec_tlu_flush_err_r = dec_tlu_flush_lower_r & (ic_perr_r | iccm_sbecc_r);\n\n   // If DM attempts to access an illegal CSR, send cmd_fail back\n   assign dec_dbg_cmd_done = dbg_cmd_done_ns;\n   assign dec_dbg_cmd_fail = illegal_r & dec_dbg_cmd_done;\n\n\n   //--------------------------------------------------------------------------------\n   //--------------------------------------------------------------------------------\n   // Triggers\n   //\nlocalparam MTDATA1_DMODE             = 9;\nlocalparam MTDATA1_SEL   = 7;\nlocalparam MTDATA1_ACTION            = 6;\nlocalparam MTDATA1_CHAIN             = 5;\nlocalparam MTDATA1_MATCH             = 4;\nlocalparam MTDATA1_M_ENABLED         = 3;\nlocalparam MTDATA1_EXE   = 2;\nlocalparam MTDATA1_ST    = 1;\nlocalparam MTDATA1_LD    = 0;\n\n   // Prioritize trigger hits with other exceptions.\n   //\n   // Trigger should have highest priority except:\n   // - trigger is an execute-data and there is an inst_access exception (lsu triggers won't fire, inst. is nop'd by decode)\n   // - trigger is a store-data and there is a lsu_acc_exc or lsu_ma_exc.\n   assign trigger_execute[3:0] = {mtdata1_t3[MTDATA1_EXE], mtdata1_t2[MTDATA1_EXE], mtdata1_t1[MTDATA1_EXE], mtdata1_t0[MTDATA1_EXE]};\n   assign trigger_data[3:0] = {mtdata1_t3[MTDATA1_SEL], mtdata1_t2[MTDATA1_SEL], mtdata1_t1[MTDATA1_SEL], mtdata1_t0[MTDATA1_SEL]};\n   assign trigger_store[3:0] = {mtdata1_t3[MTDATA1_ST], mtdata1_t2[MTDATA1_ST], mtdata1_t1[MTDATA1_ST], mtdata1_t0[MTDATA1_ST]};\n\n   // MSTATUS[MIE] needs to be on to take triggers unless the action is trigger to debug mode.\n   assign trigger_enabled[3:0] = {(mtdata1_t3[MTDATA1_ACTION] | mstatus[MSTATUS_MIE]) & mtdata1_t3[MTDATA1_M_ENABLED],\n                                  (mtdata1_t2[MTDATA1_ACTION] | mstatus[MSTATUS_MIE]) & mtdata1_t2[MTDATA1_M_ENABLED],\n                                  (mtdata1_t1[MTDATA1_ACTION] | mstatus[MSTATUS_MIE]) & mtdata1_t1[MTDATA1_M_ENABLED],\n                                  (mtdata1_t0[MTDATA1_ACTION] | mstatus[MSTATUS_MIE]) & mtdata1_t0[MTDATA1_M_ENABLED]};\n\n   // iside exceptions are always in i0\n   assign i0_iside_trigger_has_pri_r[3:0]  = ~( (trigger_execute[3:0] & trigger_data[3:0] & {4{inst_acc_r_raw}}) | // exe-data with inst_acc\n                                                ({4{exu_i0_br_error_r | exu_i0_br_start_error_r}}));               // branch error in i0\n\n   // lsu excs have to line up with their respective triggers since the lsu op can be i0\n   assign i0_lsu_trigger_has_pri_r[3:0] = ~(trigger_store[3:0] & trigger_data[3:0] & {4{lsu_i0_exc_r_raw}});\n\n   // trigger hits have to be eval'd to cancel side effect lsu ops even though the pipe is already frozen\n   assign i0_trigger_eval_r = dec_tlu_i0_valid_r;\n\n   assign i0trigger_qual_r[3:0] = {4{i0_trigger_eval_r}} & dec_tlu_packet_r.i0trigger[3:0] & i0_iside_trigger_has_pri_r[3:0] & i0_lsu_trigger_has_pri_r[3:0] & trigger_enabled[3:0];\n\n   // Qual trigger hits\n   assign i0_trigger_r[3:0] = ~{4{dec_tlu_flush_lower_wb | dec_tlu_dbg_halted}} & i0trigger_qual_r[3:0];\n\n   // chaining can mask raw trigger info\n   assign i0_trigger_chain_masked_r[3:0]  = {i0_trigger_r[3] & (~mtdata1_t2[MTDATA1_CHAIN] | i0_trigger_r[2]),\n                                             i0_trigger_r[2] & (~mtdata1_t2[MTDATA1_CHAIN] | i0_trigger_r[3]),\n                                             i0_trigger_r[1] & (~mtdata1_t0[MTDATA1_CHAIN] | i0_trigger_r[0]),\n                                             i0_trigger_r[0] & (~mtdata1_t0[MTDATA1_CHAIN] | i0_trigger_r[1])};\n\n   // This is the highest priority by this point.\n   assign i0_trigger_h"}
{"text": "it_raw_r = |i0_trigger_chain_masked_r[3:0];\n\n   assign i0_trigger_hit_r = i0_trigger_hit_raw_r;\n\n   // Actions include breakpoint, or dmode. Dmode is only possible if the DMODE bit is set.\n   // Otherwise, take a breakpoint.\n   assign trigger_action[3:0] = {mtdata1_t3[MTDATA1_ACTION] & mtdata1_t3[MTDATA1_DMODE],\n                                 mtdata1_t2[MTDATA1_ACTION] & mtdata1_t2[MTDATA1_DMODE] & ~mtdata1_t2[MTDATA1_CHAIN],\n                                 mtdata1_t1[MTDATA1_ACTION] & mtdata1_t1[MTDATA1_DMODE],\n                                 mtdata1_t0[MTDATA1_ACTION] & mtdata1_t0[MTDATA1_DMODE] & ~mtdata1_t0[MTDATA1_CHAIN]};\n\n   // this is needed to set the HIT bit in the triggers\n   assign update_hit_bit_r[3:0] = ({4{|i0_trigger_r[3:0] & ~rfpc_i0_r}} & {i0_trigger_chain_masked_r[3], i0_trigger_r[2], i0_trigger_chain_masked_r[1], i0_trigger_r[0]});\n\n   // action, 1 means dmode. Simultaneous triggers with at least 1 set for dmode force entire action to dmode.\n   assign i0_trigger_action_r = |(i0_trigger_chain_masked_r[3:0] & trigger_action[3:0]);\n\n   assign trigger_hit_dmode_r = (i0_trigger_hit_r & i0_trigger_action_r);\n\n   assign mepc_trigger_hit_sel_pc_r = i0_trigger_hit_r & ~trigger_hit_dmode_r;\n\n\n//\n// Debug end\n//--------------------------------------------------------------------------------\n\n   //----------------------------------------------------------------------\n   //\n   // Commit\n   //\n   //----------------------------------------------------------------------\n\n\n\n   //--------------------------------------------------------------------------------\n   // External halt (not debug halt)\n   // - Fully interlocked handshake\n   // i_cpu_halt_req  ____|--------------|_______________\n   // core_empty      ---------------|___________\n   // o_cpu_halt_ack  _________________|----|__________\n   // o_cpu_halt_status _______________|---------------------|_________\n   // i_cpu_run_req                              ______|----------|____\n   // o_cpu_run_ack                              ____________|------|________\n   //\n\n\n   // debug mode has priority, ignore PMU/FW halt/run while in debug mode\n   assign i_cpu_halt_req_sync_qual = i_cpu_halt_req_sync & ~dec_tlu_debug_mode & ~ext_int_freeze_d1;\n   assign i_cpu_run_req_sync_qual = i_cpu_run_req_sync & ~dec_tlu_debug_mode & pmu_fw_tlu_halted_f & ~ext_int_freeze_d1;\n\n   rvdffie #(10) exthaltff (.*, .clk(free_l2clk), .din({i_cpu_halt_req_sync_qual, i_cpu_run_req_sync_qual,   cpu_halt_status,\n                                                   cpu_halt_ack,   cpu_run_ack, internal_pmu_fw_halt_mode,\n                                                   pmu_fw_halt_req_ns, pmu_fw_tlu_halted,\n                                                   int_timer0_int_hold, int_timer1_int_hold}),\n                                            .dout({i_cpu_halt_req_d1,        i_cpu_run_req_d1_raw,      o_cpu_halt_status,\n                                                   o_cpu_halt_ack, o_cpu_run_ack, internal_pmu_fw_halt_mode_f,\n                                                   pmu_fw_halt_req_f, pmu_fw_tlu_halted_f,\n                                                   int_timer0_int_hold_f, int_timer1_int_hold_f}));\n\n   // only happens if we aren't in dgb_halt\n   assign ext_halt_pulse = i_cpu_halt_req_sync_qual & ~i_cpu_halt_req_d1;\n\n   assign enter_pmu_fw_halt_req =  ext_halt_pulse | fw_halt_req;\n\n   assign pmu_fw_halt_req_ns = (enter_pmu_fw_halt_req | (pmu_fw_halt_req_f & ~pmu_fw_tlu_halted)) & ~debug_halt_req_f;\n\n   assign internal_pmu_fw_halt_mode = pmu_fw_halt_req_ns | (internal_pmu_fw_halt_mode_f & ~i_cpu_run_req_d1 & ~debug_halt_req_f);\n\n   // debug halt has priority\n   assign pmu_fw_tlu_halted = ((pmu_fw_halt_req_f & core_empty & halt_taken & ~enter_debug_halt_req) | (pmu_fw_tlu_halted_f & ~i_cpu_run_req_d1)) & ~debug_halt_req_f;\n\n   assign cpu_halt_ack = (i_cpu_halt_req_d1 & pmu_fw_tlu_halted_f) | (o_cpu_halt_ack & i_cpu_halt_req_sync);\n   assign cpu_halt_status = (pmu_fw_tlu_halted_f & ~i_cpu_run_req_d1) | (o_cpu_halt_status & ~i_cpu_run_req_d1 & ~internal_dbg_halt_mode_f);\n   assign cpu_run_ack = (~pmu_fw_tlu_halted_f & i_cpu_run_req_sync) | (o_cpu_halt_status & i_cpu_run_req_d1_raw) | (o_cpu_run_ack & i_cpu_run_req_sync);\n   assign debug_mode_status = internal_dbg_halt_mode_f;\n   assign o_debug_mode_status = debug_mode_status;\n\n`ifdef RV_ASSERT_ON\n  assert_commit_while_halted: assert #0 (~(tlu_i0_commit_cmt  & o_cpu_halt_status)) else $display(\"ERROR: Commiting while cpu_halt_status asserted!\");\n  assert_flush_while_fastint: assert #0 (~((take_ext_int_start_d1 | take_ext_int_start_d2) & dec_tlu_flush_lower_r)) else $display(\"ERROR: TLU Flushing inside fast interrupt procedure!\");\n`endif\n\n   // high priority interrupts can wakeup from external halt, so can unmasked timer interrupts\n   assign i_cpu_run_req_d1 = i_cpu_run_req_d1_raw | ((nmi_int_detected | timer_int_ready | soft_int_ready | int_timer0_int_hold_f | int_timer1_int_hold_f | (mhwakeup & mhwakeup_ready)) & o_cpu_halt_status & ~i_cpu_halt_req_d1);\n\n   //--------------------------------------------------------------------------------\n   //--------------------------------------------------------------------------------\n\n   assign lsu_single_ecc_error_r = lsu_single_ecc_error_incr;\n\n   assign lsu_error_pkt_addr_r[31:0] = lsu_error_pkt_r.addr[31:0];\n\n\n   assign lsu_exc_valid_r_raw = lsu_error_pkt_r.exc_valid & ~dec_tlu_flush_lower_wb;\n\n   assign lsu_i0_exc_r_raw =  lsu_error_pkt_r.exc_valid;\n\n   assign lsu_i0_exc_r = lsu_i0_exc_r_raw & lsu_exc_valid_r_raw & ~i0_trigger_hit_r & ~rfpc_i0_r;\n\n   assign lsu_exc_valid_r = lsu_i0_exc_r;\n\n   assign lsu_exc_ma_r  =  lsu_i0_exc_r & ~lsu_error_pkt_r.exc_type;\n   assign lsu_exc_acc_r =  lsu_i0_exc_r & lsu_error_pkt_r.exc_type;\n   assign lsu_exc_st_r  =  lsu_i0_exc_r & lsu_error_pkt_r.inst_type;\n\n   // Single bit ECC errors on loads are RFNPC corrected, with the corrected data written to the GPR.\n   // LSU turns the load into a store and patches the data in the DCCM\n   assign lsu_i0_rfnpc_r = dec_tlu_i0_valid_r & ~i0_trigger_hit_r &\n                           (~lsu_error_pkt_r.inst_type & lsu_error_pkt_r.single_ecc_error);\n\n   //  Final commit valids\n   assign tlu_i0_commit_cmt = dec_tlu_i0_valid_r &\n                              ~rfpc_i0_r &\n                              ~lsu_i0_exc_r &\n                              ~inst_acc_r &\n                              ~dec_tlu_dbg_halted &\n                              ~request_debug_mode_r_d1 &\n                              ~i0_trigger_hit_r;\n\n   // unified place to manage the killing of arch state writebacks\n   assign tlu_i0_kill_writeb_r = rfpc_i0_r | lsu_i0_exc_r | inst_acc_r | (illegal_r & dec_tlu_dbg_halted) | i0_trigger_hit_r;\n   assign dec_tlu_i0_commit_cmt = tlu_i0_commit_cmt;\n\n\n   // refetch PC, microarch flush\n   // ic errors only in pipe0\n   assign rfpc_i0_r =  ((dec_tlu_i0_valid_r & ~tlu_flush_lower_r_d1 & (exu_i0_br_error_r | exu_i0_br_start_error_r)) | // inst commit with rfpc\n                        ((ic_perr_r | iccm_sbecc_r) & ~ext_int_freeze_d1)) & // ic/iccm without inst commit\n                       ~i0_trigger_hit_r & // unless there's a trigger. Err signal to ic/iccm will assert anyway to clear the error.\n                       ~lsu_i0_rfnpc_r;\n\n   // From the indication of a iccm single bit error until the first commit or flush, maintain a repair state. In the repair state, rfnpc i0 commits.\n   assign iccm_repair_state_ns = iccm_sbecc_r | (iccm_repair_state_d1 & ~dec_tlu_flush_lower_r);\n\n\n   localparam MCPC          = 12'h7c2;\n\n   // this is a flush of last resort, meaning only assert it if there is no other flush happening.\n   assign iccm_repair_state_rfnpc = tlu_i0_commit_cmt & iccm_repair_state_d1 &\n                                    ~(ebreak_r | ecall_r | mret_r | take_reset | illegal_r | (dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MCPC)));\n\nif(pt.BTB_ENABLE==1) begin\n   // go ahead and repair the branch error on other flushes, doesn't have to be the rfpc flush\n   assign dec_tlu_br0_error_r = exu_i0_br_error_r & dec_tlu_i0_valid_r & ~tlu_flush_lower_r_d1;\n   assign dec_tlu_br0_start_error_r = exu_i0_br_start_error_r & dec_tlu_i0_valid_r & ~tlu_flush_lower_r_d1;\n   assign dec_tlu_br0_v_r = exu_i0_br_valid_r & dec_tlu_i0_valid_r & ~tlu_flush_lower_r_d1 & (~exu_i0_br_mp_r | ~exu_pmu_i0_br_ataken);\n\n\n   assign dec_tlu_br0_r_pkt.hist[1:0] = exu_i0_br_hist_r[1:0];\n   assign dec_tlu_br0_r_pkt.br_error = dec_tlu_br0_error_r;\n   assign dec_tlu_br0_r_pkt.br_start_error = dec_tlu_br0_start_error_r;\n   assign dec_tlu_br0_r_pkt.valid = dec_tlu_br0_v_r;\n   assign dec_tlu_br0_r_pkt.way = exu_i0_br_way_r;\n   assign dec_tlu_br0_r_pkt.middle = exu_i0_br_middle_r;\nend // if (pt.BTB_ENABLE==1)\nelse begin\n   assign dec_tlu_br0_error_r = '0;\n   assign dec_tlu_br0_start_error_r = '0;\n   assign dec_tlu_br0_v_r = '0;\n   assign dec_tlu_br0_r_pkt  = '0;\nend // else: !if(pt.BTB_ENABLE==1)\n\n\n   // only expect these in pipe 0\n   assign       ebreak_r     =  (dec_tlu_packet_r.pmu_i0_itype == EBREAK)  & dec_tlu_i0_valid_r & ~i0_trigger_hit_r & ~dcsr[DCSR_EBREAKM] & ~rfpc_i0_r;\n   assign       ecall_r      =  (dec_tlu_packet_r.pmu_i0_itype == ECALL)   & dec_tlu_i0_valid_r & ~i0_trigger_hit_r & ~rfpc_i0_r;\n   assign       illegal_r    =  ~dec_tlu_packet_r.legal   & dec_tlu_i0_valid_r & ~i0_trigger_hit_r & ~rfpc_i0_r;\n   assign       mret_r       =  (dec_tlu_packet_r.pmu_i0_itype == MRET)    & dec_tlu_i0_valid_r & ~i0_trigger_hit_r & ~rfpc_i0_r;\n   // fence_i includes debug only fence_i's\n   assign       fence_i_r    =  (dec_tlu_packet_r.fence_i & dec_tlu_i0_valid_r & ~i0_trigger_hit_r) & ~rfpc_i0_r;\n   assign       ic_perr_r    =  ifu_ic_error_start_f & ~ext_int_freeze_d1 & (~internal_dbg_halt_mode_f | dcsr_single_step_running) & ~internal_pmu_fw_halt_mode_f;\n   assign       iccm_sbecc_r =  ifu_iccm_rd_ecc_single_err_f & ~ext_int_freeze_d1 & (~internal_dbg_halt_mode_f | dcsr_single_step_running) & ~internal_pmu_fw_halt_mode_f;\n   assign       inst_acc_r_raw  =  dec_tlu_packet_r.icaf & dec_tlu_i0_valid_r;\n   assign       inst_acc_r = inst_acc_r_raw & ~rfpc_i0_r & ~i0_trigger_hit_r;\n   assign       inst_acc_second_r = dec_tlu_packet_r.icaf_second;\n\n   assign       ebreak_to_debug_mode_r = (dec_tlu_packet_r.pmu_i0_itype == EBREAK)  & dec_tlu_i0_valid_r & ~i0_trigger_hit_r & dcsr[DCSR_EBREAKM] & ~rfpc_i0_r;\n\n   rvdff #(1)  exctype_wb_ff (.*, .clk(e4e5_clk),\n                                .din (ebreak_to_debug_mode_r   ),\n                                .dout(ebreak_to_debug_mode_r_d1));\n\n   assign dec_tlu_fence_i_r = fence_i_r;\n   //\n   // Exceptions\n   //\n   // - MEPC <- PC\n   // - PC <- MTVEC, assert flush_lower\n   // - MCAUSE <- cause\n   // - MSCAUSE <- secondary cause\n   // - MTVAL <-\n   // - MPIE <- MIE\n   // - MIE <- 0\n   //\n   assign i0_exception_valid_r = (ebreak_r | ecall_r | illegal_r | inst_acc_r) & ~rfpc_i0_r & ~dec_tlu_dbg_halted;\n\n   // Cause:\n   //\n   // 0x2 : illegal\n   // 0x3 : breakpoint\n   // 0xb : Environment call M-mode\n\n\n   assign exc_cause_r[4:0] =  ( ({5{take_ext_int}}        & 5'h0b) |\n                                ({5{take_timer_int}}      & 5'h07) |\n                                ({5{take_soft_int}}       & 5'h03) |\n                                ({5{take_int_timer0_int}} & 5'h1d) |\n                                ({5{take_int_timer1_int}} & 5'h1c) |\n                                ({5{take_ce_int}}         & 5'h1e) |\n                                ({5{illegal_r}}           & 5'h02) |\n                                ({5{ecall_r}}             & 5'h0b) |\n                                ({5{inst_acc_r}}          & 5'h01) |\n                                ({5{ebreak_r | i0_trigger_hit_r}}   & 5'h03) |\n                                ({5{lsu_exc_ma_r & ~lsu_exc_st_r}}  & 5'h04) |\n                                ({5{lsu_exc_acc_r & ~lsu_exc_st_r}} & 5'h05) |\n                                ({5{lsu_exc_ma_r & lsu_exc_st_r}}   & 5'h06) |\n                                ({5{lsu_exc_acc_r & lsu_exc_st_r}}  & 5'h07)\n                                ) & ~{5{take_nmi}};\n\n   //\n   // Interrupts\n   //\n   // exceptions that are committed have already happened and will cause an int at E4 to wait a cycle\n   // or more if MSTATUS[MIE] is cleared.\n   //\n   // -in priority order, highest to lowest\n   // -single cycle window where a csr write to MIE/MSTATUS is at E4 when the other conditions for externals are met.\n   //  Hold off externals for a cycle to make sure we are consistent with what was just written\n   assign mhwakeup_ready =  ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[MIP_MEIP]   & mie_ns[MIE_MEIE];\n   assign ext_int_ready   = ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[MIP_MEIP]   & mie_ns[MIE_MEIE] & ~ignore_ext_int_due_to_lsu_stall;\n   assign ce_int_ready    = ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[MIP_MCEIP]  & mie_ns[MIE_MCEIE];\n   assign soft_int_ready  = ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[MIP_MSIP]   & mie_ns[MIE_MSIE];\n   assign timer_int_ready = ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[MIP_MTIP]   & mie_ns[MIE_MTIE];\n\n   // MIP for internal timers pulses for 1 clock, resets the timer counter. Mip won't hold past the various stall conditions.\n   assign int_timer0_int_possible = mstatus_mie_ns & mie_ns[MIE_MITIE0];\n   assign int_timer0_int_ready = mip[MIP_MITIP0] & int_timer0_int_possible;\n   assign int_timer1_int_possible = mstatus_mie_ns & mie_ns[MIE_MITIE1];\n   assign int_timer1_int_ready = mip[MIP_MITIP1] & int_timer1_int_possible;\n\n   // Internal timers pulse and reset. If core is PMU/FW halted, the pulse will cause an exit from halt, but won't stick around\n   // Make it sticky, also for 1 cycle stall conditions.\n   assign int_timer_stalled = dec_csr_stall_int_ff | synchronous_flush_r | exc_or_int_valid_r_d1 | mret_r;\n\n   assign int_timer0_int_hold = (int_timer0_int_ready & (pmu_fw_tlu_halted_f | int_timer_stalled)) | (int_timer0_int_possible & int_timer0_int_hold_f & ~interrupt_valid_r & ~take_ext_int_start & ~internal_dbg_halt_mode_f);\n   assign int_timer1_int_hold = (int_timer1_int_ready & (pmu_fw_tlu_halted_f | int_timer_stalled)) | (int_timer1_int_possible & int_timer1_int_hold_f & ~interrupt_valid_r & ~take_ext_int_start & ~internal_dbg_halt_mode_f);\n\n\n   assign internal_dbg_halt_timers = internal_dbg_halt_mode_f & ~dcsr_single_step_running;\n\n\n   assign block_interrupts = ( (internal_dbg_halt_mode & (~dcsr_single_step_running | dec_tlu_i0_valid_r)) | // No ints in db-halt unless we are single stepping\n                               internal_pmu_fw_halt_mode | i_cpu_halt_req_d1 |// No ints in PMU/FW halt. First we exit halt\n                               take_nmi | // NMI is top priority\n                               ebreak_to_debug_mode_r | // Heading to debug mode, hold off ints\n                               synchronous_flush_r | // exception flush this cycle\n                               exc_or_int_valid_r_d1 | // ext/int past cycle (need time for MIE to update)\n                               mret_r |    // mret in progress, for cases were ISR enables ints before mret\n                               ext_int_freeze_d1 // Fast interrupt in progress (optional)\n                               );\n\n\nif (pt.FAST_INTERRUPT_REDIRECT) begin\n\n\n   assign take_ext_int_start = ext_int_ready & ~block_interrupts;\n\n   assign ext_int_freeze = take_ext_int_start | take_ext_int_start_d1 | take_ext_int_start_d2 | take_ext_int_start_d3;\n   assign take_ext_int = take_ext_int_start_d3 & ~|lsu_fir_error[1:0];\n   assign fast_int_meicpct = csr_meicpct & dec_csr_any_unq_d;  // MEICPCT becomes illegal if fast ints are enabled\n\n   assign ignore_ext_int_due_to_lsu_stall = lsu_fastint_stall_any;\nend\nelse begin\n   assign take_ext_int_start = 1'b0;\n   assign ext_int_freeze = 1'b0;\n   assign ext_int_freeze_d1 = 1'b0;\n   assign take_ext_int_start_d1 = 1'b0;\n   assign take_ext_int_start_d2 = 1'b0;\n   assign take_ext_int_start_d3 = 1'b0;\n   assign fast_int_meicpct = 1'b0;\n   assign ignore_ext_int_due_to_lsu_stall = 1'b0;\n\n   assign take_ext_int = ext_int_ready & ~block_interrupts;\nend\n\n   assign take_ce_int  = ce_int_ready & ~ext_int_ready & ~block_interrupts;\n   assign take_soft_int = soft_int_ready & ~ext_int_ready & ~ce_int_ready & ~block_interrupts;\n   assign take_timer_int = timer_int_ready & ~soft_int_ready & ~ext_int_ready & ~ce_int_ready & ~block_interrupts;\n   assign take_int_timer0_int = (int_timer0_int_ready | int_timer0_int_hold_f) & int_timer0_int_possible & ~dec_csr_stall_int_ff &\n                                ~timer_int_ready & ~soft_int_ready & ~ext_int_ready & ~ce_int_ready & ~block_interrupts;\n   assign take_int_timer1_int = (int_timer1_int_ready | int_timer1_int_hold_f) & int_timer1_int_possible & ~dec_csr_stall_int_ff &\n                                ~(int_timer0_int_ready | int_timer0_int_hold_f) & ~timer_int_ready & ~soft_int_ready & ~ext_int_ready & ~ce_int_ready & ~block_interrupts;\n\n   assign take_reset = reset_delayed & mpc_reset_run_req;\n   assign take_nmi = nmi_int_detected & ~internal_pmu_fw_halt_mode & (~internal_dbg_halt_mode | (dcsr_single_step_running_f & dcsr[DCSR_STEPIE] & ~dec_tlu_i0_valid_r & ~dcsr_single_step_done_f)) &\n                     ~synchronous_flush_r & ~mret_r & ~take_reset & ~ebreak_to_debug_mode_r & (~ext_int_freeze_d1 | (take_ext_int_start_d3 & |lsu_fir_error[1:0]));\n\n   assign interrupt_valid_r = take_ext_int | take_timer_int | take_soft_int | take_nmi | take_ce_int | take_int_timer0_int | take_int_timer1_int;\n\n\n   // Compute interrupt path:\n   // If vectored async is set in mtvec, flush path for interrupts is MTVEC + (4 * CAUSE);\n   assign vectored_path[31:1]  = {mtvec[30:1], 1'b0} + {25'b0, exc_cause_r[4:0], 1'b0};\n   assign interrupt_path[31:1] = take_nmi ? nmi_vec[31:1] : ((mtvec[0] == 1'b1) ? vectored_path[31:1] : {mtvec[30:1], 1'b0});\n\n   assign sel_npc_r  = lsu_i0_rfnpc_r | fence_i_r | iccm_repair_state_rfnpc | (i_cpu_run_req_d1 & ~interrupt_valid_r) | (rfpc_i0_r & ~dec_tlu_i0_valid_r);\n   assign sel_npc_resume = (i_cpu_run_req_d1 & pmu_fw_tlu_halted_f) | pause_expired_r;\n\n   assign sel_fir_addr = take_ext_int_start_d3 & ~|lsu_fir_error[1:0];\n\n   assign synchronous_flush_r  = i0_exception_valid_r | // exception\n                                 rfpc_i0_r | // rfpc\n                                 lsu_exc_valid_r |  // lsu exception in either pipe 0 or pipe 1\n                                 fence_i_r |  // fence, a rfnpc\n                                 lsu_i0_rfnpc_r | // lsu dccm sb ecc\n                                 iccm_repair_state_rfnpc | // Iccm sb ecc\n                                 debug_resume_req_f | // resume from debug halt, fetch the dpc\n                                 sel_npc_resume |  // resume from pmu/fw halt, or from pause and fetch the NPC\n                                 dec_tlu_wr_pause_r_d1 | // flush at start of pause\n                                 i0_trigger_hit_r; // trigger hit, ebreak or goto debug mode\n\n   assign tlu_flush_lower_r = interrupt_valid_r | mret_r | synchronous_flush_r | take_halt | take_reset | take_ext_int_start;\n\n   assign tlu_flush_path_r[31:1] = take_reset ? rst_vec[31:1] :\n\n                                    ( ({31{sel_fir_addr}} & lsu_fir_addr[31:1]) |\n                                      ({31{~take_nmi & sel_npc_r}} & npc_r[31:1]) |\n                                      ({31{~take_nmi & rfpc_i0_r & dec_tlu_i0_valid_r & ~sel_npc_r}} & dec_tlu_i0_pc_r[31:1]) |\n                                      ({31{interrupt_valid_r & ~sel_fir_addr}} & interrupt_path[31:1]) |\n                                      ({31{(i0_exception_valid_r | lsu_exc_valid_r |\n                                            (i0_trigger_hit_r & ~trigger_hit_dmode_r)) & ~interrupt_valid_r & ~sel_fir_addr}} & {mtvec[30:1],1'b0}) |\n                                      ({31{~take_nmi & mret_r}} & mepc[31:1]) |\n                                      ({31{~take_nmi & debug_resume_req_f}} & dpc[31:1]) |\n                                      ({31{~tak"}
{"text": "e_nmi & sel_npc_resume}} & npc_r_d1[31:1]) );\n\n   rvdffpcie #(31)  flush_lower_ff (.*, .en(tlu_flush_lower_r),\n                                 .din({tlu_flush_path_r[31:1]}),\n                                 .dout({tlu_flush_path_r_d1[31:1]}));\n\n   assign dec_tlu_flush_lower_wb = tlu_flush_lower_r_d1;\n   assign dec_tlu_flush_lower_r = tlu_flush_lower_r;\n   assign dec_tlu_flush_path_r[31:1] = tlu_flush_path_r[31:1];\n\n\n   // this is used to capture mepc, etc.\n   assign exc_or_int_valid_r = lsu_exc_valid_r | i0_exception_valid_r | interrupt_valid_r | (i0_trigger_hit_r & ~trigger_hit_dmode_r);\n\n\n   rvdffie #(12)  excinfo_wb_ff (.*,\n                                 .din({interrupt_valid_r, i0_exception_valid_r, exc_or_int_valid_r,\n                                       exc_cause_r[4:0], tlu_i0_commit_cmt & ~illegal_r, i0_trigger_hit_r,\n                                       take_nmi, pause_expired_r }),\n                                 .dout({interrupt_valid_r_d1, i0_exception_valid_r_d1, exc_or_int_valid_r_d1,\n                                        exc_cause_wb[4:0], i0_valid_wb, trigger_hit_r_d1,\n                                        take_nmi_r_d1, pause_expired_wb}));\n\n   //----------------------------------------------------------------------\n   //\n   // CSRs\n   //\n   //----------------------------------------------------------------------\n\n\n   // ----------------------------------------------------------------------\n   // MISA (RO)\n   //  [31:30] XLEN - implementation width, 2'b01 - 32 bits\n   //  [12]    M    - integer mul/div\n   //  [8]     I    - RV32I\n   //  [2]     C    - Compressed extension\n   localparam MISA          = 12'h301;\n\n   // MVENDORID, MARCHID, MIMPID, MHARTID\n   localparam MVENDORID     = 12'hf11;\n   localparam MARCHID       = 12'hf12;\n   localparam MIMPID        = 12'hf13;\n   localparam MHARTID       = 12'hf14;\n\n\n   // ----------------------------------------------------------------------\n   // MSTATUS (RW)\n   // [12:11] MPP  : Prior priv level, always 2'b11, not flopped\n   // [7]     MPIE : Int enable previous [1]\n   // [3]     MIE  : Int enable          [0]\n   localparam MSTATUS       = 12'h300;\n\n\n   //When executing a MRET instruction, supposing MPP holds the value 3, MIE\n   //is set to MPIE; the privilege mode is changed to 3; MPIE is set to 1; and MPP is set to 3\n\n   assign dec_csr_wen_r_mod = dec_csr_wen_r & ~i0_trigger_hit_r & ~rfpc_i0_r;\n   assign wr_mstatus_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MSTATUS);\n\n   // set this even if we don't go to fwhalt due to debug halt. We committed the inst, so ...\n   assign set_mie_pmu_fw_halt = ~mpmc_b_ns[1] & fw_halt_req;\n\n   assign mstatus_ns[1:0] = ( ({2{~wr_mstatus_r & exc_or_int_valid_r}} & {mstatus[MSTATUS_MIE], 1'b0}) |\n                              ({2{ wr_mstatus_r & exc_or_int_valid_r}} & {dec_csr_wrdata_r[3], 1'b0}) |\n                              ({2{mret_r & ~exc_or_int_valid_r}} & {1'b1, mstatus[1]}) |\n                              ({2{set_mie_pmu_fw_halt}} & {mstatus[1], 1'b1}) |\n                              ({2{wr_mstatus_r & ~exc_or_int_valid_r}} & {dec_csr_wrdata_r[7], dec_csr_wrdata_r[3]}) |\n                              ({2{~wr_mstatus_r & ~exc_or_int_valid_r & ~mret_r & ~set_mie_pmu_fw_halt}} & mstatus[1:0]) );\n\n   // gate MIE if we are single stepping and DCSR[STEPIE] is off\n   assign mstatus_mie_ns = mstatus[MSTATUS_MIE] & (~dcsr_single_step_running_f | dcsr[DCSR_STEPIE]);\n\n   // ----------------------------------------------------------------------\n   // MTVEC (RW)\n   // [31:2] BASE : Trap vector base address\n   // [1] - Reserved, not implemented, reads zero\n   // [0]  MODE : 0 = Direct, 1 = Asyncs are vectored to BASE + (4 * CAUSE)\n   localparam MTVEC         = 12'h305;\n\n   assign wr_mtvec_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MTVEC);\n   assign mtvec_ns[30:0] = {dec_csr_wrdata_r[31:2], dec_csr_wrdata_r[0]} ;\n   rvdffe #(31)  mtvec_ff (.*, .en(wr_mtvec_r), .din(mtvec_ns[30:0]), .dout(mtvec[30:0]));\n\n   // ----------------------------------------------------------------------\n   // MIP (RW)\n   //\n   // [30] MCEIP  : (RO) M-Mode Correctable Error interrupt pending\n   // [29] MITIP0 : (RO) M-Mode Internal Timer0 interrupt pending\n   // [28] MITIP1 : (RO) M-Mode Internal Timer1 interrupt pending\n   // [11] MEIP   : (RO) M-Mode external interrupt pending\n   // [7]  MTIP   : (RO) M-Mode timer interrupt pending\n   // [3]  MSIP   : (RO) M-Mode software interrupt pending\n   localparam MIP           = 12'h344;\n\n   assign ce_int = (mdccme_ce_req | miccme_ce_req | mice_ce_req);\n\n   assign mip_ns[5:0] = {ce_int, dec_timer_t0_pulse, dec_timer_t1_pulse, mexintpend, timer_int_sync, soft_int_sync};\n\n   // ----------------------------------------------------------------------\n   // MIE (RW)\n   // [30] MCEIE  : (RO) M-Mode Correctable Error interrupt enable\n   // [29] MITIE0 : (RO) M-Mode Internal Timer0 interrupt enable\n   // [28] MITIE1 : (RO) M-Mode Internal Timer1 interrupt enable\n   // [11] MEIE   : (RW) M-Mode external interrupt enable\n   // [7]  MTIE   : (RW) M-Mode timer interrupt enable\n   // [3]  MSIE   : (RW) M-Mode software interrupt enable\n   localparam MIE           = 12'h304;\n\n   assign wr_mie_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MIE);\n   assign mie_ns[5:0] = wr_mie_r ? {dec_csr_wrdata_r[30:28], dec_csr_wrdata_r[11], dec_csr_wrdata_r[7], dec_csr_wrdata_r[3]} : mie[5:0];\n   rvdff #(6)  mie_ff (.*, .clk(csr_wr_clk), .din(mie_ns[5:0]), .dout(mie[5:0]));\n\n\n   // ----------------------------------------------------------------------\n   // MCYCLEL (RW)\n   // [31:0] : Lower Cycle count\n\n   localparam MCYCLEL       = 12'hb00;\n\n   assign kill_ebreak_count_r = ebreak_to_debug_mode_r & dcsr[DCSR_STOPC];\n\n   assign wr_mcyclel_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MCYCLEL);\n\n   assign mcyclel_cout_in = ~(kill_ebreak_count_r | (dec_tlu_dbg_halted & dcsr[DCSR_STOPC]) | dec_tlu_pmu_fw_halted | mcountinhibit[0]);\n\n   // split for power\n   assign {mcyclela_cout, mcyclel_inc[7:0]}  = mcyclel[7:0] +  {7'b0, 1'b1};\n   assign {mcyclel_cout,  mcyclel_inc[31:8]} = mcyclel[31:8] + {23'b0, mcyclela_cout};\n\n   assign mcyclel_ns[31:0] = wr_mcyclel_r ? dec_csr_wrdata_r[31:0] : mcyclel_inc[31:0];\n\n   rvdffe #(24) mcyclel_bff      (.*, .clk(free_l2clk), .en(wr_mcyclel_r | (mcyclela_cout & mcyclel_cout_in)),    .din(mcyclel_ns[31:8]), .dout(mcyclel[31:8]));\n   rvdffe #(8)  mcyclel_aff      (.*, .clk(free_l2clk), .en(wr_mcyclel_r | mcyclel_cout_in),  .din(mcyclel_ns[7:0]),  .dout(mcyclel[7:0]));\n\n   // ----------------------------------------------------------------------\n   // MCYCLEH (RW)\n   // [63:32] : Higher Cycle count\n   // Chained with mcyclel. Note: mcyclel overflow due to a mcycleh write gets ignored.\n\n   localparam MCYCLEH       = 12'hb80;\n\n   assign wr_mcycleh_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MCYCLEH);\n\n   assign mcycleh_inc[31:0] = mcycleh[31:0] + {31'b0, mcyclel_cout_f};\n   assign mcycleh_ns[31:0]  = wr_mcycleh_r ? dec_csr_wrdata_r[31:0] : mcycleh_inc[31:0];\n\n   rvdffe #(32)  mcycleh_ff (.*, .clk(free_l2clk), .en(wr_mcycleh_r | mcyclel_cout_f), .din(mcycleh_ns[31:0]), .dout(mcycleh[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MINSTRETL (RW)\n   // [31:0] : Lower Instruction retired count\n   // From the spec \"Some CSRs, such as the instructions retired counter, instret, may be modified as side effects\n   // of instruction execution. In these cases, if a CSR access instruction reads a CSR, it reads the\n   // value prior to the execution of the instruction. If a CSR access instruction writes a CSR, the\n   // update occurs after the execution of the instruction. In particular, a value written to instret by\n   // one instruction will be the value read by the following instruction (i.e., the increment of instret\n   // caused by the first instruction retiring happens before the write of the new value).\"\n   localparam MINSTRETL     = 12'hb02;\n\n   assign i0_valid_no_ebreak_ecall_r = dec_tlu_i0_valid_r & ~(ebreak_r | ecall_r | ebreak_to_debug_mode_r | illegal_r | mcountinhibit[2]);\n\n   assign wr_minstretl_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MINSTRETL);\n\n   assign {minstretl_couta, minstretl_inc[7:0]} = minstretl[7:0] + {7'b0,1'b1};\n   assign {minstretl_cout, minstretl_inc[31:8]} = minstretl[31:8] + {23'b0, minstretl_couta};\n\n   assign minstret_enable = (i0_valid_no_ebreak_ecall_r & tlu_i0_commit_cmt) | wr_minstretl_r;\n\n   assign minstretl_cout_ns = minstretl_cout & ~wr_minstreth_r & i0_valid_no_ebreak_ecall_r & ~dec_tlu_dbg_halted;\n\n   assign minstretl_ns[31:0] = wr_minstretl_r ? dec_csr_wrdata_r[31:0] : minstretl_inc[31:0];\n   rvdffe #(24)  minstretl_bff (.*, .en(wr_minstretl_r | (minstretl_couta & minstret_enable)),\n                                .din(minstretl_ns[31:8]), .dout(minstretl[31:8]));\n   rvdffe #(8)   minstretl_aff (.*, .en(minstret_enable),\n                                .din(minstretl_ns[7:0]),  .dout(minstretl[7:0]));\n\n\n   assign minstretl_read[31:0] = minstretl[31:0];\n   // ----------------------------------------------------------------------\n   // MINSTRETH (RW)\n   // [63:32] : Higher Instret count\n   // Chained with minstretl. Note: minstretl overflow due to a minstreth write gets ignored.\n\n   localparam MINSTRETH     = 12'hb82;\n\n   assign wr_minstreth_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MINSTRETH);\n\n   assign minstreth_inc[31:0] = minstreth[31:0] + {31'b0, minstretl_cout_f};\n   assign minstreth_ns[31:0]  = wr_minstreth_r ? dec_csr_wrdata_r[31:0] : minstreth_inc[31:0];\n   rvdffe #(32)  minstreth_ff (.*, .en((minstret_enable_f & minstretl_cout_f) | wr_minstreth_r), .din(minstreth_ns[31:0]), .dout(minstreth[31:0]));\n\n   assign minstreth_read[31:0] = minstreth_inc[31:0];\n\n   // ----------------------------------------------------------------------\n   // MSCRATCH (RW)\n   // [31:0] : Scratch register\n   localparam MSCRATCH      = 12'h340;\n\n   assign wr_mscratch_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MSCRATCH);\n\n   rvdffe #(32)  mscratch_ff (.*, .en(wr_mscratch_r), .din(dec_csr_wrdata_r[31:0]), .dout(mscratch[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MEPC (RW)\n   // [31:1] : Exception PC\n   localparam MEPC          = 12'h341;\n\n   // NPC\n\n   assign sel_exu_npc_r = ~dec_tlu_dbg_halted & ~tlu_flush_lower_r_d1 & dec_tlu_i0_valid_r;\n   assign sel_flush_npc_r = ~dec_tlu_dbg_halted & tlu_flush_lower_r_d1 & ~dec_tlu_flush_noredir_r_d1;\n   assign sel_hold_npc_r = ~sel_exu_npc_r & ~sel_flush_npc_r;\n\n   assign npc_r[31:1] =  ( ({31{sel_exu_npc_r}} & exu_npc_r[31:1]) |\n                           ({31{~mpc_reset_run_req & reset_delayed}} & rst_vec[31:1]) | // init to reset vector for mpc halt on reset case\n                           ({31{(sel_flush_npc_r)}} & tlu_flush_path_r_d1[31:1]) |\n                           ({31{(sel_hold_npc_r)}} & npc_r_d1[31:1]) );\n\n   rvdffpcie #(31)  npwbc_ff (.*, .en(sel_exu_npc_r | sel_flush_npc_r | reset_delayed), .din(npc_r[31:1]), .dout(npc_r_d1[31:1]));\n\n   // PC has to be captured for exceptions and interrupts. For MRET, we could execute it and then take an\n   // interrupt before the next instruction.\n   assign pc0_valid_r = ~dec_tlu_dbg_halted & dec_tlu_i0_valid_r;\n\n   assign pc_r[31:1]  = ( ({31{ pc0_valid_r}} & dec_tlu_i0_pc_r[31:1]) |\n                          ({31{~pc0_valid_r}} & pc_r_d1[31:1]));\n\n   rvdffpcie #(31)  pwbc_ff (.*, .en(pc0_valid_r), .din(pc_r[31:1]), .dout(pc_r_d1[31:1]));\n\n   assign wr_mepc_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MEPC);\n\n   assign mepc_ns[31:1] = ( ({31{i0_exception_valid_r | lsu_exc_valid_r | mepc_trigger_hit_sel_pc_r}} & pc_r[31:1]) |\n                            ({31{interrupt_valid_r}} & npc_r[31:1]) |\n                            ({31{wr_mepc_r & ~exc_or_int_valid_r}} & dec_csr_wrdata_r[31:1]) |\n                            ({31{~wr_mepc_r & ~exc_or_int_valid_r}} & mepc[31:1]) );\n\n\n   rvdffe #(31)  mepc_ff (.*, .en(i0_exception_valid_r | lsu_exc_valid_r | mepc_trigger_hit_sel_pc_r | interrupt_valid_r | wr_mepc_r), .din(mepc_ns[31:1]), .dout(mepc[31:1]));\n\n   // ----------------------------------------------------------------------\n   // MCAUSE (RW)\n   // [31:0] : Exception Cause\n   localparam MCAUSE        = 12'h342;\n\n   assign wr_mcause_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MCAUSE);\n   assign mcause_sel_nmi_store = exc_or_int_valid_r & take_nmi & nmi_lsu_store_type;\n   assign mcause_sel_nmi_load = exc_or_int_valid_r & take_nmi & nmi_lsu_load_type;\n   assign mcause_sel_nmi_ext = exc_or_int_valid_r & take_nmi & take_ext_int_start_d3 & |lsu_fir_error[1:0] & ~nmi_int_detected_f;\n   // FIR value decoder\n   // 0 \u2013no error\n   // 1 \u2013uncorrectable ecc  => f000_1000\n   // 2 \u2013dccm region access error => f000_1001\n   // 3 \u2013non dccm region access error => f000_1002\n   assign mcause_fir_error_type[1:0] = {&lsu_fir_error[1:0], lsu_fir_error[1] & ~lsu_fir_error[0]};\n\n   assign mcause_ns[31:0] = ( ({32{mcause_sel_nmi_store}} & {32'hf000_0000}) |\n                              ({32{mcause_sel_nmi_load}} & {32'hf000_0001}) |\n                              ({32{mcause_sel_nmi_ext}} & {28'hf000_100, 2'b0, mcause_fir_error_type[1:0]}) |\n                              ({32{exc_or_int_valid_r & ~take_nmi}} & {interrupt_valid_r, 26'b0, exc_cause_r[4:0]}) |\n                              ({32{wr_mcause_r & ~exc_or_int_valid_r}} & dec_csr_wrdata_r[31:0]) |\n                              ({32{~wr_mcause_r & ~exc_or_int_valid_r}} & mcause[31:0]) );\n\n   rvdffe #(32)  mcause_ff (.*, .en(exc_or_int_valid_r | wr_mcause_r), .din(mcause_ns[31:0]), .dout(mcause[31:0]));\n   // ----------------------------------------------------------------------\n   // MSCAUSE (RW)\n   // [2:0] : Secondary exception Cause\n   localparam MSCAUSE       = 12'h7ff;\n\n   assign wr_mscause_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MSCAUSE);\n\n   assign ifu_mscause[3:0]  =  (dec_tlu_packet_r.icaf_type[1:0] == 2'b00) ? 4'b1001 :\n                               {2'b00 , dec_tlu_packet_r.icaf_type[1:0]} ;\n\n   assign mscause_type[3:0] = ( ({4{lsu_i0_exc_r}} & lsu_error_pkt_r.mscause[3:0]) |\n                                ({4{i0_trigger_hit_r}} & 4'b0001) |\n                                ({4{ebreak_r}} & 4'b0010) |\n                                ({4{inst_acc_r}} & ifu_mscause[3:0])\n                                );\n\n   assign mscause_ns[3:0] = ( ({4{exc_or_int_valid_r}} & mscause_type[3:0]) |\n                              ({4{ wr_mscause_r & ~exc_or_int_valid_r}} & dec_csr_wrdata_r[3:0]) |\n                              ({4{~wr_mscause_r & ~exc_or_int_valid_r}} & mscause[3:0])\n                             );\n\n   rvdff #(4)  mscause_ff (.*, .clk(e4e5_int_clk), .din(mscause_ns[3:0]), .dout(mscause[3:0]));\n   // ----------------------------------------------------------------------\n   // MTVAL (RW)\n   // [31:0] : Exception address if relevant\n   localparam MTVAL         = 12'h343;\n\n   assign wr_mtval_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MTVAL);\n   assign mtval_capture_pc_r = exc_or_int_valid_r & (ebreak_r | (inst_acc_r & ~inst_acc_second_r) | mepc_trigger_hit_sel_pc_r) & ~take_nmi;\n   assign mtval_capture_pc_plus2_r = exc_or_int_valid_r & (inst_acc_r & inst_acc_second_r) & ~take_nmi;\n   assign mtval_capture_inst_r = exc_or_int_valid_r & illegal_r & ~take_nmi;\n   assign mtval_capture_lsu_r = exc_or_int_valid_r & lsu_exc_valid_r & ~take_nmi;\n   assign mtval_clear_r = exc_or_int_valid_r & ~mtval_capture_pc_r & ~mtval_capture_inst_r & ~mtval_capture_lsu_r & ~mepc_trigger_hit_sel_pc_r;\n\n\n   assign mtval_ns[31:0] = (({32{mtval_capture_pc_r}} & {pc_r[31:1], 1'b0}) |\n                            ({32{mtval_capture_pc_plus2_r}} & {pc_r[31:1] + 31'b1, 1'b0}) |\n                            ({32{mtval_capture_inst_r}} & dec_illegal_inst[31:0]) |\n                            ({32{mtval_capture_lsu_r}} & lsu_error_pkt_addr_r[31:0]) |\n                            ({32{wr_mtval_r & ~interrupt_valid_r}} & dec_csr_wrdata_r[31:0]) |\n                            ({32{~take_nmi & ~wr_mtval_r & ~mtval_capture_pc_r & ~mtval_capture_inst_r & ~mtval_clear_r & ~mtval_capture_lsu_r}} & mtval[31:0]) );\n\n\n   rvdffe #(32)  mtval_ff (.*, .en(tlu_flush_lower_r | wr_mtval_r), .din(mtval_ns[31:0]), .dout(mtval[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MCGC (RW) Clock gating control\n   // [31:10]: Reserved, reads 0x0\n   // [9]    : picio_clk_override\n   // [7]    : dec_clk_override\n   // [6]    : Unused\n   // [5]    : ifu_clk_override\n   // [4]    : lsu_clk_override\n   // [3]    : bus_clk_override\n   // [2]    : pic_clk_override\n   // [1]    : dccm_clk_override\n   // [0]    : icm_clk_override\n   //\n   localparam MCGC          = 12'h7f8;\n   assign wr_mcgc_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MCGC);\n\n   assign mcgc_ns[9:0] = wr_mcgc_r ? {~dec_csr_wrdata_r[9], dec_csr_wrdata_r[8:0]} : mcgc_int[9:0];\n   rvdffe #(10)  mcgc_ff (.*, .en(wr_mcgc_r), .din(mcgc_ns[9:0]), .dout(mcgc_int[9:0]));\n\n   assign mcgc[9:0] = {~mcgc_int[9], mcgc_int[8:0]};\n\n   assign dec_tlu_picio_clk_override= mcgc[9];\n   assign dec_tlu_misc_clk_override = mcgc[8];\n   assign dec_tlu_dec_clk_override  = mcgc[7];\n   //sign dec_tlu_exu_clk_override  = mcgc[6];\n   assign dec_tlu_ifu_clk_override  = mcgc[5];\n   assign dec_tlu_lsu_clk_override  = mcgc[4];\n   assign dec_tlu_bus_clk_override  = mcgc[3];\n   assign dec_tlu_pic_clk_override  = mcgc[2];\n   assign dec_tlu_dccm_clk_override = mcgc[1];\n   assign dec_tlu_icm_clk_override  = mcgc[0];\n\n   // ----------------------------------------------------------------------\n   // MFDC (RW) Feature Disable Control\n   // [31:19] : Reserved, reads 0x0\n   // [18:16] : DMA QoS Prty\n   // [15:13] : Reserved, reads 0x0\n   // [12]   : Disable trace\n   // [11]   : Disable external load forwarding\n   // [10]   : Disable dual issue\n   // [9]    : Disable pic multiple ints\n   // [8]    : Disable core ecc\n   // [7]    : Disable secondary alu?s\n   // [6]    : Unused, 0x0\n   // [5]    : Disable non-blocking loads/divides\n   // [4]    : Disable fast divide\n   // [3]    : Disable branch prediction and return stack\n   // [2]    : Disable write buffer coalescing\n   // [1]    : Disable load misses that bypass the write buffer\n   // [0]    : Disable pipelining - Enable single instruction execution\n   //\n   localparam MFDC          = 12'h7f9;\n\n   assign wr_mfdc_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MFDC);\n\n   rvdffe #(16)  mfdc_ff (.*, .en(wr_mfdc_r), .din({mfdc_ns[15:0]}), .dout(mfdc_int[15:0]));\n\n   // flip poweron value of bit 6 for AXI build\n   if(pt.BUILD_AXI4==1) begin : axi4\n      // flip poweron valid of bit 12\n         assign mfdc_ns[15:0] = {~dec_csr_wrdata_r[18:16], dec_csr_wrdata_r[12], dec_csr_wrdata_r[11:7], ~dec_csr_wrdata_r[6], dec_csr_wrdata_r[5:0]};\n         assign mfdc[18:0] = {~mfdc_int[15:13], 3'b0, mfdc_int[12], mfdc_int[11:7], ~mfdc_int[6], mfdc_int[5:0]};\n   end\n   else begin\n      // flip poweron valid of bit 12\n         assign mfdc_ns[15:0] = {~dec_csr_wrdata_r[18:16],dec_csr_wrdata_r[12:0]};\n         assign mfdc[18:0] = {~mfdc_int[15:13], 3'b0, mfdc_int[12:0]};\n   end\n\n\n   assign dec_tlu_dma_qos_prty[2:0] = mfdc[18:16];\n   assign dec_tlu_trace_disable = mfdc[12];\n   assign dec_tlu_external_ldfwd_disable = mfdc[11];\n   assign dec_tlu_core_ecc_disable = mfdc[8];\n   assign dec_tlu_sideeffect_posted_disable = mfdc[6];\n   assign dec_tlu_bpred_disable = mfdc[3];\n   assign dec_tlu_wb_coalescing_disable = mfdc[2];\n   assign dec_tlu_pipelining_disable = mfdc[0];\n\n   // ----------------------------------------------------------------------\n   // MCPC (RW) Pause counter\n   // [31:0] : Reads 0x0, decs in the wb register in decode_ctl\n\n   assign dec_tlu_wr_pause_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MCPC) & ~interrupt_valid_r & ~take_ext_int_start;\n\n   // ----------------------------------------------------------------------\n   // MRAC (RW)\n   // [31:0"}
{"text": "] : Region Access Control Register, 16 regions, {side_effect, cachable} pairs\n   localparam MRAC          = 12'h7c0;\n\n   assign wr_mrac_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MRAC);\n\n   // prevent pairs of 0x11, side_effect and cacheable\n   assign mrac_in[31:0] = {dec_csr_wrdata_r[31], dec_csr_wrdata_r[30] & ~dec_csr_wrdata_r[31],\n                           dec_csr_wrdata_r[29], dec_csr_wrdata_r[28] & ~dec_csr_wrdata_r[29],\n                           dec_csr_wrdata_r[27], dec_csr_wrdata_r[26] & ~dec_csr_wrdata_r[27],\n                           dec_csr_wrdata_r[25], dec_csr_wrdata_r[24] & ~dec_csr_wrdata_r[25],\n                           dec_csr_wrdata_r[23], dec_csr_wrdata_r[22] & ~dec_csr_wrdata_r[23],\n                           dec_csr_wrdata_r[21], dec_csr_wrdata_r[20] & ~dec_csr_wrdata_r[21],\n                           dec_csr_wrdata_r[19], dec_csr_wrdata_r[18] & ~dec_csr_wrdata_r[19],\n                           dec_csr_wrdata_r[17], dec_csr_wrdata_r[16] & ~dec_csr_wrdata_r[17],\n                           dec_csr_wrdata_r[15], dec_csr_wrdata_r[14] & ~dec_csr_wrdata_r[15],\n                           dec_csr_wrdata_r[13], dec_csr_wrdata_r[12] & ~dec_csr_wrdata_r[13],\n                           dec_csr_wrdata_r[11], dec_csr_wrdata_r[10] & ~dec_csr_wrdata_r[11],\n                           dec_csr_wrdata_r[9], dec_csr_wrdata_r[8] & ~dec_csr_wrdata_r[9],\n                           dec_csr_wrdata_r[7], dec_csr_wrdata_r[6] & ~dec_csr_wrdata_r[7],\n                           dec_csr_wrdata_r[5], dec_csr_wrdata_r[4] & ~dec_csr_wrdata_r[5],\n                           dec_csr_wrdata_r[3], dec_csr_wrdata_r[2] & ~dec_csr_wrdata_r[3],\n                           dec_csr_wrdata_r[1], dec_csr_wrdata_r[0] & ~dec_csr_wrdata_r[1]};\n\n   rvdffe #(32)  mrac_ff (.*, .en(wr_mrac_r), .din(mrac_in[31:0]), .dout(mrac[31:0]));\n\n   // drive to LSU/IFU\n   assign dec_tlu_mrac_ff[31:0] = mrac[31:0];\n\n   // ----------------------------------------------------------------------\n   // MDEAU (WAR0)\n   // [31:0] : Dbus Error Address Unlock register\n   //\n   localparam MDEAU         = 12'hbc0;\n\n   assign wr_mdeau_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MDEAU);\n\n\n   // ----------------------------------------------------------------------\n   // MDSEAC (R)\n   // [31:0] : Dbus Store Error Address Capture register\n   //\n   localparam MDSEAC        = 12'hfc0;\n\n   // only capture error bus if the MDSEAC reg is not locked\n   assign mdseac_locked_ns = mdseac_en | (mdseac_locked_f & ~wr_mdeau_r);\n\n   assign mdseac_en = (lsu_imprecise_error_store_any | lsu_imprecise_error_load_any) & ~nmi_int_detected_f & ~mdseac_locked_f;\n\n   rvdffe #(32)  mdseac_ff (.*, .en(mdseac_en), .din(lsu_imprecise_error_addr_any[31:0]), .dout(mdseac[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MPMC (R0W1)\n   // [0] : FW halt\n   // [1] : Set MSTATUS[MIE] on halt\n\n   localparam MPMC          = 12'h7c6;\n\n   assign wr_mpmc_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MPMC);\n\n   // allow the cycle of the dbg halt flush that contains the wr_mpmc_r to\n   // set the mstatus bit potentially, use delayed version of internal dbg halt.\n   assign fw_halt_req = wr_mpmc_r & dec_csr_wrdata_r[0] & ~internal_dbg_halt_mode_f2 & ~ext_int_freeze_d1;\n\n   assign fw_halted_ns = (fw_halt_req | fw_halted) & ~set_mie_pmu_fw_halt;\n   assign mpmc_b_ns[1] = wr_mpmc_r ? ~dec_csr_wrdata_r[1] : ~mpmc[1];\n   rvdff #(1)  mpmc_ff (.*, .clk(csr_wr_clk), .din(mpmc_b_ns[1]), .dout(mpmc_b[1]));\n   assign mpmc[1] = ~mpmc_b[1];\n\n   // ----------------------------------------------------------------------\n   // MICECT (I-Cache error counter/threshold)\n   // [31:27] : Icache parity error threshold\n   // [26:0]  : Icache parity error count\n   localparam MICECT        = 12'h7f0;\n\n   assign csr_sat[31:27] = (dec_csr_wrdata_r[31:27] > 5'd26) ? 5'd26 : dec_csr_wrdata_r[31:27];\n\n   assign wr_micect_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MICECT);\n   assign micect_inc[26:0] = micect[26:0] + {26'b0, ic_perr_r};\n   assign micect_ns =  wr_micect_r ? {csr_sat[31:27], dec_csr_wrdata_r[26:0]} : {micect[31:27], micect_inc[26:0]};\n\n   rvdffe #(32)  micect_ff (.*, .en(wr_micect_r | ic_perr_r), .din(micect_ns[31:0]), .dout(micect[31:0]));\n\n   assign mice_ce_req = |({32'hffffffff << micect[31:27]} & {5'b0, micect[26:0]});\n\n   // ----------------------------------------------------------------------\n   // MICCMECT (ICCM error counter/threshold)\n   // [31:27] : ICCM parity error threshold\n   // [26:0]  : ICCM parity error count\n   localparam MICCMECT      = 12'h7f1;\n\n   assign wr_miccmect_r     = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MICCMECT);\n   assign miccmect_inc[26:0] = miccmect[26:0] + {26'b0, iccm_sbecc_r | iccm_dma_sb_error};\n   assign miccmect_ns        = wr_miccmect_r ? {csr_sat[31:27], dec_csr_wrdata_r[26:0]} : {miccmect[31:27], miccmect_inc[26:0]};\n\n   rvdffe #(32)  miccmect_ff (.*, .clk(free_l2clk), .en(wr_miccmect_r | iccm_sbecc_r | iccm_dma_sb_error), .din(miccmect_ns[31:0]), .dout(miccmect[31:0]));\n\n   assign miccme_ce_req = |({32'hffffffff << miccmect[31:27]} & {5'b0, miccmect[26:0]});\n\n   // ----------------------------------------------------------------------\n   // MDCCMECT (DCCM error counter/threshold)\n   // [31:27] : DCCM parity error threshold\n   // [26:0]  : DCCM parity error count\n   localparam MDCCMECT      = 12'h7f2;\n\n   assign wr_mdccmect_r     = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MDCCMECT);\n   assign mdccmect_inc[26:0] = mdccmect[26:0] + {26'b0, lsu_single_ecc_error_r_d1};\n   assign mdccmect_ns        = wr_mdccmect_r ? {csr_sat[31:27], dec_csr_wrdata_r[26:0]} : {mdccmect[31:27], mdccmect_inc[26:0]};\n\n   rvdffe #(32)  mdccmect_ff (.*, .clk(free_l2clk), .en(wr_mdccmect_r | lsu_single_ecc_error_r_d1), .din(mdccmect_ns[31:0]), .dout(mdccmect[31:0]));\n\n   assign mdccme_ce_req = |({32'hffffffff << mdccmect[31:27]} & {5'b0, mdccmect[26:0]});\n\n\n   // ----------------------------------------------------------------------\n   // MFDHT (Force Debug Halt Threshold)\n   // [5:1] : Halt timeout threshold (power of 2)\n   //   [0] : Halt timeout enabled\n   localparam MFDHT         = 12'h7ce;\n\n   assign wr_mfdht_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MFDHT);\n\n   assign mfdht_ns[5:0] = wr_mfdht_r ? dec_csr_wrdata_r[5:0] : mfdht[5:0];\n\n   rvdffs #(6)  mfdht_ff (.*, .clk(csr_wr_clk), .en(wr_mfdht_r), .din(mfdht_ns[5:0]), .dout(mfdht[5:0]));\n\n    // ----------------------------------------------------------------------\n   // MFDHS(RW)\n   // [1] : LSU operation pending when debug halt threshold reached\n   // [0] : IFU operation pending when debug halt threshold reached\n\n   localparam MFDHS         = 12'h7cf;\n\n   assign wr_mfdhs_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MFDHS);\n\n   assign mfdhs_ns[1:0] = wr_mfdhs_r ? dec_csr_wrdata_r[1:0] : ((dbg_tlu_halted & ~dbg_tlu_halted_f) ? {~lsu_idle_any_f, ~ifu_miss_state_idle_f} : mfdhs[1:0]);\n\n   rvdffs #(2)  mfdhs_ff (.*, .clk(free_clk), .en(wr_mfdhs_r | dbg_tlu_halted), .din(mfdhs_ns[1:0]), .dout(mfdhs[1:0]));\n\n   assign force_halt_ctr[31:0] = debug_halt_req_f ? (force_halt_ctr_f[31:0] + 32'b1) : (dbg_tlu_halted_f ? 32'b0 : force_halt_ctr_f[31:0]);\n\n   rvdffe #(32)  forcehaltctr_ff (.*, .en(mfdht[0]), .din(force_halt_ctr[31:0]), .dout(force_halt_ctr_f[31:0]));\n\n   assign force_halt = mfdht[0] & |(force_halt_ctr_f[31:0] & (32'hffffffff << mfdht[5:1]));\n\n\n   // ----------------------------------------------------------------------\n   // MEIVT (External Interrupt Vector Table (R/W))\n   // [31:10]: Base address (R/W)\n   // [9:0]  : Reserved, reads 0x0\n   localparam MEIVT         = 12'hbc8;\n\n   assign wr_meivt_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MEIVT);\n\n   rvdffe #(22)  meivt_ff (.*, .en(wr_meivt_r), .din(dec_csr_wrdata_r[31:10]), .dout(meivt[31:10]));\n\n\n   // ----------------------------------------------------------------------\n   // MEIHAP (External Interrupt Handler Access Pointer (R))\n   // [31:10]: Base address (R/W)\n   // [9:2]  : ClaimID (R)\n   // [1:0]  : Reserved, 0x0\n   localparam MEIHAP        = 12'hfc8;\n\n   assign wr_meihap_r = wr_meicpct_r;\n\n   rvdffe #(8)  meihap_ff (.*, .en(wr_meihap_r), .din(pic_claimid[7:0]), .dout(meihap[9:2]));\n\n   assign dec_tlu_meihap[31:2] = {meivt[31:10], meihap[9:2]};\n   // ----------------------------------------------------------------------\n   // MEICURPL (R/W)\n   // [31:4] : Reserved (read 0x0)\n   // [3:0]  : CURRPRI - Priority level of current interrupt service routine (R/W)\n   localparam MEICURPL      = 12'hbcc;\n\n   assign wr_meicurpl_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MEICURPL);\n   assign meicurpl_ns[3:0] = wr_meicurpl_r ? dec_csr_wrdata_r[3:0] : meicurpl[3:0];\n\n   rvdff #(4)  meicurpl_ff (.*, .clk(csr_wr_clk), .din(meicurpl_ns[3:0]), .dout(meicurpl[3:0]));\n\n   // PIC needs this reg\n   assign dec_tlu_meicurpl[3:0] = meicurpl[3:0];\n\n\n   // ----------------------------------------------------------------------\n   // MEICIDPL (R/W)\n   // [31:4] : Reserved (read 0x0)\n   // [3:0]  : External Interrupt Claim ID's Priority Level Register\n   localparam MEICIDPL      = 12'hbcb;\n\n   assign wr_meicidpl_r = (dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MEICIDPL)) | take_ext_int_start;\n\n   assign meicidpl_ns[3:0] = wr_meicpct_r ? pic_pl[3:0] : (wr_meicidpl_r ? dec_csr_wrdata_r[3:0] : meicidpl[3:0]);\n\n\n   // ----------------------------------------------------------------------\n   // MEICPCT (Capture CLAIMID in MEIHAP and PL in MEICIDPL\n   // [31:1] : Reserved (read 0x0)\n   // [0]    : Capture (W1, Read 0)\n   localparam MEICPCT       = 12'hbca;\n\n   assign wr_meicpct_r = (dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MEICPCT)) | take_ext_int_start;\n\n   // ----------------------------------------------------------------------\n   // MEIPT (External Interrupt Priority Threshold)\n   // [31:4] : Reserved (read 0x0)\n   // [3:0]  : PRITHRESH\n   localparam MEIPT         = 12'hbc9;\n\n   assign wr_meipt_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MEIPT);\n   assign meipt_ns[3:0] = wr_meipt_r ? dec_csr_wrdata_r[3:0] : meipt[3:0];\n\n   rvdff #(4)  meipt_ff (.*, .clk(csr_wr_clk), .din(meipt_ns[3:0]), .dout(meipt[3:0]));\n\n   // to PIC\n   assign dec_tlu_meipt[3:0] = meipt[3:0];\n   // ----------------------------------------------------------------------\n   // DCSR (R/W) (Only accessible in debug mode)\n   // [31:28] : xdebugver (hard coded to 0x4) RO\n   // [27:16] : 0x0, reserved\n   // [15]    : ebreakm\n   // [14]    : 0x0, reserved\n   // [13]    : ebreaks (0x0 for this core)\n   // [12]    : ebreaku (0x0 for this core)\n   // [11]    : stepie\n   // [10]    : stopcount\n   // [9]     : 0x0 //stoptime\n   // [8:6]   : cause (RO)\n   // [5:4]   : 0x0, reserved\n   // [3]     : nmip\n   // [2]     : step\n   // [1:0]   : prv (0x3 for this core)\n   //\n   localparam DCSR          = 12'h7b0;\n\n   // RV has clarified that 'priority 4' in the spec means top priority.\n   // 4. single step. 3. Debugger request. 2. Ebreak. 1. Trigger.\n\n   // RV debug spec indicates a cause priority change for trigger hits during single step.\n   assign trigger_hit_for_dscr_cause_r_d1 = trigger_hit_dmode_r_d1 | (trigger_hit_r_d1 & dcsr_single_step_done_f);\n\n   assign dcsr_cause[8:6] = ( ({3{dcsr_single_step_done_f & ~ebreak_to_debug_mode_r_d1 & ~trigger_hit_for_dscr_cause_r_d1 & ~debug_halt_req}} & 3'b100) |\n                              ({3{debug_halt_req & ~ebreak_to_debug_mode_r_d1 & ~trigger_hit_for_dscr_cause_r_d1}} &  3'b011) |\n                              ({3{ebreak_to_debug_mode_r_d1 & ~trigger_hit_for_dscr_cause_r_d1}} &  3'b001) |\n                              ({3{trigger_hit_for_dscr_cause_r_d1}} & 3'b010));\n\n   assign wr_dcsr_r = allow_dbg_halt_csr_write & dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == DCSR);\n\n\n\n  // Multiple halt enter requests can happen before we are halted.\n  // We have to continue to upgrade based on dcsr_cause priority but we can't downgrade.\n   assign dcsr_cause_upgradeable = internal_dbg_halt_mode_f & (dcsr[8:6] == 3'b011);\n   assign enter_debug_halt_req_le = enter_debug_halt_req & (~dbg_tlu_halted | dcsr_cause_upgradeable);\n\n   assign nmi_in_debug_mode = nmi_int_detected_f & internal_dbg_halt_mode_f;\n   assign dcsr_ns[15:2] = enter_debug_halt_req_le ? {dcsr[15:9], dcsr_cause[8:6], dcsr[5:2]} :\n                          (wr_dcsr_r ? {dec_csr_wrdata_r[15], 3'b0, dec_csr_wrdata_r[11:10], 1'b0, dcsr[8:6], 2'b00, nmi_in_debug_mode | dcsr[3], dec_csr_wrdata_r[2]} :\n                           {dcsr[15:4], nmi_in_debug_mode, dcsr[2]});\n\n   rvdffe #(14)  dcsr_ff (.*, .clk(free_l2clk), .en(enter_debug_halt_req_le | wr_dcsr_r | internal_dbg_halt_mode | take_nmi), .din(dcsr_ns[15:2]), .dout(dcsr[15:2]));\n\n   // ----------------------------------------------------------------------\n   // DPC (R/W) (Only accessible in debug mode)\n   // [31:0] : Debug PC\n   localparam DPC           = 12'h7b1;\n\n   assign wr_dpc_r = allow_dbg_halt_csr_write & dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == DPC);\n   assign dpc_capture_npc = dbg_tlu_halted & ~dbg_tlu_halted_f & ~request_debug_mode_done;\n   assign dpc_capture_pc = request_debug_mode_r;\n\n   assign dpc_ns[31:1] = ( ({31{~dpc_capture_pc & ~dpc_capture_npc & wr_dpc_r}} & dec_csr_wrdata_r[31:1]) |\n                           ({31{dpc_capture_pc}} & pc_r[31:1]) |\n                           ({31{~dpc_capture_pc & dpc_capture_npc}} & npc_r[31:1]) );\n\n   rvdffe #(31)  dpc_ff (.*, .en(wr_dpc_r | dpc_capture_pc | dpc_capture_npc), .din(dpc_ns[31:1]), .dout(dpc[31:1]));\n\n   // ----------------------------------------------------------------------\n   // DICAWICS (R/W) (Only accessible in debug mode)\n   // [31:25] : Reserved\n   // [24]    : Array select, 0 is data, 1 is tag\n   // [23:22] : Reserved\n   // [21:20] : Way select\n   // [19:17] : Reserved\n   // [16:3]  : Index\n   // [2:0]   : Reserved\n   localparam DICAWICS      = 12'h7c8;\n\n   assign dicawics_ns[16:0] = {dec_csr_wrdata_r[24], dec_csr_wrdata_r[21:20], dec_csr_wrdata_r[16:3]};\n   assign wr_dicawics_r = allow_dbg_halt_csr_write & dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == DICAWICS);\n\n   rvdffe #(17)  dicawics_ff (.*, .en(wr_dicawics_r), .din(dicawics_ns[16:0]), .dout(dicawics[16:0]));\n\n   // ----------------------------------------------------------------------\n   // DICAD0 (R/W) (Only accessible in debug mode)\n   //\n   // If dicawics[array] is 0\n   // [31:0]  : inst data\n   //\n   // If dicawics[array] is 1\n   // [31:16] : Tag\n   // [15:7]  : Reserved\n   // [6:4]   : LRU\n   // [3:1]   : Reserved\n   // [0]     : Valid\n   localparam DICAD0        = 12'h7c9;\n\n   assign dicad0_ns[31:0] = wr_dicad0_r ? dec_csr_wrdata_r[31:0] : ifu_ic_debug_rd_data[31:0];\n\n   assign wr_dicad0_r = allow_dbg_halt_csr_write & dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == DICAD0);\n\n   rvdffe #(32)  dicad0_ff (.*, .en(wr_dicad0_r | ifu_ic_debug_rd_data_valid), .din(dicad0_ns[31:0]), .dout(dicad0[31:0]));\n\n   // ----------------------------------------------------------------------\n   // DICAD0H (R/W) (Only accessible in debug mode)\n   //\n   // If dicawics[array] is 0\n   // [63:32]  : inst data\n   //\n   localparam DICAD0H       = 12'h7cc;\n\n   assign dicad0h_ns[31:0] = wr_dicad0h_r ? dec_csr_wrdata_r[31:0] : ifu_ic_debug_rd_data[63:32];\n\n   assign wr_dicad0h_r = allow_dbg_halt_csr_write & dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == DICAD0H);\n\n   rvdffe #(32)  dicad0h_ff (.*, .en(wr_dicad0h_r | ifu_ic_debug_rd_data_valid), .din(dicad0h_ns[31:0]), .dout(dicad0h[31:0]));\n\n\nif (pt.ICACHE_ECC == 1) begin\n   // ----------------------------------------------------------------------\n   // DICAD1 (R/W) (Only accessible in debug mode)\n   // [6:0]     : ECC\n   localparam DICAD1        = 12'h7ca;\n\n   assign dicad1_ns[6:0] = wr_dicad1_r ? dec_csr_wrdata_r[6:0] : ifu_ic_debug_rd_data[70:64];\n\n   assign wr_dicad1_r = allow_dbg_halt_csr_write & dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == DICAD1);\n\n   rvdffe #(.WIDTH(7), .OVERRIDE(1))  dicad1_ff (.*, .en(wr_dicad1_r | ifu_ic_debug_rd_data_valid), .din(dicad1_ns[6:0]), .dout(dicad1_raw[6:0]));\n\n   assign dicad1[31:0] = {25'b0, dicad1_raw[6:0]};\n\nend\nelse begin\n   // ----------------------------------------------------------------------\n   // DICAD1 (R/W) (Only accessible in debug mode)\n   // [3:0]     : Parity\n   localparam DICAD1        = 12'h7ca;\n\n   assign dicad1_ns[3:0] = wr_dicad1_r ? dec_csr_wrdata_r[3:0] : ifu_ic_debug_rd_data[67:64];\n\n   assign wr_dicad1_r = allow_dbg_halt_csr_write & dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == DICAD1);\n\n   rvdffs #(4)  dicad1_ff (.*, .clk(free_clk), .en(wr_dicad1_r | ifu_ic_debug_rd_data_valid), .din(dicad1_ns[3:0]), .dout(dicad1_raw[3:0]));\n\n   assign dicad1[31:0] = {28'b0, dicad1_raw[3:0]};\nend\n   // ----------------------------------------------------------------------\n   // DICAGO (R/W) (Only accessible in debug mode)\n   // [0]     : Go\n   localparam DICAGO        = 12'h7cb;\n\nif (pt.ICACHE_ECC == 1)\n   assign dec_tlu_ic_diag_pkt.icache_wrdata[70:0] = {      dicad1[6:0], dicad0h[31:0], dicad0[31:0]};\nelse\n   assign dec_tlu_ic_diag_pkt.icache_wrdata[70:0] = {3'b0, dicad1[3:0], dicad0h[31:0], dicad0[31:0]};\n\n\n   assign dec_tlu_ic_diag_pkt.icache_dicawics[16:0] = dicawics[16:0];\n\n   assign icache_rd_valid = allow_dbg_halt_csr_write & dec_csr_any_unq_d & dec_i0_decode_d & ~dec_csr_wen_unq_d & (dec_csr_rdaddr_d[11:0] == DICAGO);\n   assign icache_wr_valid = allow_dbg_halt_csr_write & dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == DICAGO);\n\n\n   assign dec_tlu_ic_diag_pkt.icache_rd_valid = icache_rd_valid_f;\n   assign dec_tlu_ic_diag_pkt.icache_wr_valid = icache_wr_valid_f;\n\n   // ----------------------------------------------------------------------\n   // MTSEL (R/W)\n   // [1:0] : Trigger select : 00, 01, 10 are data/address triggers. 11 is inst count\n   localparam MTSEL         = 12'h7a0;\n\n   assign wr_mtsel_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MTSEL);\n   assign mtsel_ns[1:0] = wr_mtsel_r ? {dec_csr_wrdata_r[1:0]} : mtsel[1:0];\n\n   rvdff #(2)  mtsel_ff (.*, .clk(csr_wr_clk), .din(mtsel_ns[1:0]), .dout(mtsel[1:0]));\n\n   // ----------------------------------------------------------------------\n   // MTDATA1 (R/W)\n   // [31:0] : Trigger Data 1\n   localparam MTDATA1       = 12'h7a1;\n\n   // for triggers 0, 1, 2 and 3 aka Match Control\n   // [31:28] : type, hard coded to 0x2\n   // [27]    : dmode\n   // [26:21] : hard coded to 0x1f\n   // [20]    : hit\n   // [19]    : select (0 - address, 1 - data)\n   // [18]    : timing, always 'before', reads 0x0\n   // [17:12] : action, bits  [17:13] not implemented and reads 0x0\n   // [11]    : chain\n   // [10:7]  : match, bits [10:8] not implemented and reads 0x0\n   // [6]     : M\n   // [5:3]   : not implemented, reads 0x0\n   // [2]     : execute\n   // [1]     : store\n   // [0]     : load\n   //\n   // decoder ring\n   // [27]    : => 9\n   // [20]    : => 8\n   // [19]    : => 7\n   // [12]    : => 6\n   // [11]    : => 5\n   // [7]     : => 4\n   // [6]     : => 3\n   // [2]     : => 2\n   // [1]     : => 1\n   // [0]     : => 0\n\n\n   // don't allow setting load-data.\n   assign tdata_load = dec_csr_wrdata_r[0] & ~dec_csr_wrdata_r[19];\n   // don't allow setting execute-data.\n   assign tdata_opcode = dec_csr_wrdata_r[2] & ~dec_csr_wrdata_r[19];\n   // don't allow clearing DMODE and action=1\n   assign tdata_action = (dec_csr_wrdata_r[27] & dbg_tlu_halted_f) & dec_csr_wrdata_r[12];\n\n   // Chain bit has conditions: WARL for triggers without chains. Force to zero if dmode is 0 but next trigger dmode is 1.\n   assign tdata_chain = mtsel[0] ? 1'b0 : // triggers 1 and 3 chain bit is always zero\n                        mtsel[1] ?  dec_csr_wrdata_r[11] & ~(mtdata1_t3[MTDATA1_DMODE] & ~dec_csr_wrdata_r[27]) : // trigger 2\n                                    dec_csr_wrdata_r[11] & ~(mtdata1_t1[MTDATA1_DMODE] & ~dec_csr_wrdata_r[27]);  // trigger 0\n\n   // Kill mtdata1 write if dmode=1 but prior trigger has dmode=0/chain=1. Only applies to T1 and T3\n   assign tdata_kill_wri"}
{"text": "te = mtsel[1] ? dec_csr_wrdata_r[27] & (~mtdata1_t2[MTDATA1_DMODE] & mtdata1_t2[MTDATA1_CHAIN]) : // trigger 3\n                                        dec_csr_wrdata_r[27] & (~mtdata1_t0[MTDATA1_DMODE] & mtdata1_t0[MTDATA1_CHAIN]) ; // trigger 1\n\n\n   assign tdata_wrdata_r[9:0]  = {dec_csr_wrdata_r[27] & dbg_tlu_halted_f,\n                                   dec_csr_wrdata_r[20:19],\n                                   tdata_action,\n                                   tdata_chain,\n                                   dec_csr_wrdata_r[7:6],\n                                   tdata_opcode,\n                                   dec_csr_wrdata_r[1],\n                                   tdata_load};\n\n   // If the DMODE bit is set, tdata1 can only be updated in debug_mode\n   assign wr_mtdata1_t0_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MTDATA1) & (mtsel[1:0] == 2'b0) & (~mtdata1_t0[MTDATA1_DMODE] | dbg_tlu_halted_f);\n   assign mtdata1_t0_ns[9:0] = wr_mtdata1_t0_r ? tdata_wrdata_r[9:0] :\n                                {mtdata1_t0[9], update_hit_bit_r[0] | mtdata1_t0[8], mtdata1_t0[7:0]};\n\n   assign wr_mtdata1_t1_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MTDATA1) & (mtsel[1:0] == 2'b01) & (~mtdata1_t1[MTDATA1_DMODE] | dbg_tlu_halted_f) & ~tdata_kill_write;\n   assign mtdata1_t1_ns[9:0] = wr_mtdata1_t1_r ? tdata_wrdata_r[9:0] :\n                                {mtdata1_t1[9], update_hit_bit_r[1] | mtdata1_t1[8], mtdata1_t1[7:0]};\n\n   assign wr_mtdata1_t2_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MTDATA1) & (mtsel[1:0] == 2'b10) & (~mtdata1_t2[MTDATA1_DMODE] | dbg_tlu_halted_f);\n   assign mtdata1_t2_ns[9:0] = wr_mtdata1_t2_r ? tdata_wrdata_r[9:0] :\n                                {mtdata1_t2[9], update_hit_bit_r[2] | mtdata1_t2[8], mtdata1_t2[7:0]};\n\n   assign wr_mtdata1_t3_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MTDATA1) & (mtsel[1:0] == 2'b11) & (~mtdata1_t3[MTDATA1_DMODE] | dbg_tlu_halted_f) & ~tdata_kill_write;\n   assign mtdata1_t3_ns[9:0] = wr_mtdata1_t3_r ? tdata_wrdata_r[9:0] :\n                                {mtdata1_t3[9], update_hit_bit_r[3] | mtdata1_t3[8], mtdata1_t3[7:0]};\n\n\n   rvdffe #(10)  mtdata1_t0_ff (.*, .en(trigger_enabled[0] | wr_mtdata1_t0_r), .din(mtdata1_t0_ns[9:0]), .dout(mtdata1_t0[9:0]));\n   rvdffe #(10)  mtdata1_t1_ff (.*, .en(trigger_enabled[1] | wr_mtdata1_t1_r), .din(mtdata1_t1_ns[9:0]), .dout(mtdata1_t1[9:0]));\n   rvdffe #(10)  mtdata1_t2_ff (.*, .en(trigger_enabled[2] | wr_mtdata1_t2_r), .din(mtdata1_t2_ns[9:0]), .dout(mtdata1_t2[9:0]));\n   rvdffe #(10)  mtdata1_t3_ff (.*, .en(trigger_enabled[3] | wr_mtdata1_t3_r), .din(mtdata1_t3_ns[9:0]), .dout(mtdata1_t3[9:0]));\n\n   assign mtdata1_tsel_out[31:0] = ( ({32{(mtsel[1:0] == 2'b00)}} & {4'h2, mtdata1_t0[9], 6'b011111, mtdata1_t0[8:7], 6'b0, mtdata1_t0[6:5], 3'b0, mtdata1_t0[4:3], 3'b0, mtdata1_t0[2:0]}) |\n                                     ({32{(mtsel[1:0] == 2'b01)}} & {4'h2, mtdata1_t1[9], 6'b011111, mtdata1_t1[8:7], 6'b0, mtdata1_t1[6:5], 3'b0, mtdata1_t1[4:3], 3'b0, mtdata1_t1[2:0]}) |\n                                     ({32{(mtsel[1:0] == 2'b10)}} & {4'h2, mtdata1_t2[9], 6'b011111, mtdata1_t2[8:7], 6'b0, mtdata1_t2[6:5], 3'b0, mtdata1_t2[4:3], 3'b0, mtdata1_t2[2:0]}) |\n                                     ({32{(mtsel[1:0] == 2'b11)}} & {4'h2, mtdata1_t3[9], 6'b011111, mtdata1_t3[8:7], 6'b0, mtdata1_t3[6:5], 3'b0, mtdata1_t3[4:3], 3'b0, mtdata1_t3[2:0]}));\n\n   assign trigger_pkt_any[0].select = mtdata1_t0[MTDATA1_SEL];\n   assign trigger_pkt_any[0].match = mtdata1_t0[MTDATA1_MATCH];\n   assign trigger_pkt_any[0].store = mtdata1_t0[MTDATA1_ST];\n   assign trigger_pkt_any[0].load = mtdata1_t0[MTDATA1_LD];\n   assign trigger_pkt_any[0].execute = mtdata1_t0[MTDATA1_EXE];\n   assign trigger_pkt_any[0].m = mtdata1_t0[MTDATA1_M_ENABLED];\n\n   assign trigger_pkt_any[1].select = mtdata1_t1[MTDATA1_SEL];\n   assign trigger_pkt_any[1].match = mtdata1_t1[MTDATA1_MATCH];\n   assign trigger_pkt_any[1].store = mtdata1_t1[MTDATA1_ST];\n   assign trigger_pkt_any[1].load = mtdata1_t1[MTDATA1_LD];\n   assign trigger_pkt_any[1].execute = mtdata1_t1[MTDATA1_EXE];\n   assign trigger_pkt_any[1].m = mtdata1_t1[MTDATA1_M_ENABLED];\n\n   assign trigger_pkt_any[2].select = mtdata1_t2[MTDATA1_SEL];\n   assign trigger_pkt_any[2].match = mtdata1_t2[MTDATA1_MATCH];\n   assign trigger_pkt_any[2].store = mtdata1_t2[MTDATA1_ST];\n   assign trigger_pkt_any[2].load = mtdata1_t2[MTDATA1_LD];\n   assign trigger_pkt_any[2].execute = mtdata1_t2[MTDATA1_EXE];\n   assign trigger_pkt_any[2].m = mtdata1_t2[MTDATA1_M_ENABLED];\n\n   assign trigger_pkt_any[3].select = mtdata1_t3[MTDATA1_SEL];\n   assign trigger_pkt_any[3].match = mtdata1_t3[MTDATA1_MATCH];\n   assign trigger_pkt_any[3].store = mtdata1_t3[MTDATA1_ST];\n   assign trigger_pkt_any[3].load = mtdata1_t3[MTDATA1_LD];\n   assign trigger_pkt_any[3].execute = mtdata1_t3[MTDATA1_EXE];\n   assign trigger_pkt_any[3].m = mtdata1_t3[MTDATA1_M_ENABLED];\n\n\n\n\n\n   // ----------------------------------------------------------------------\n   // MTDATA2 (R/W)\n   // [31:0] : Trigger Data 2\n   localparam MTDATA2       = 12'h7a2;\n\n   // If the DMODE bit is set, tdata2 can only be updated in debug_mode\n   assign wr_mtdata2_t0_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MTDATA2) & (mtsel[1:0] == 2'b0)  & (~mtdata1_t0[MTDATA1_DMODE] | dbg_tlu_halted_f);\n   assign wr_mtdata2_t1_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MTDATA2) & (mtsel[1:0] == 2'b01) & (~mtdata1_t1[MTDATA1_DMODE] | dbg_tlu_halted_f);\n   assign wr_mtdata2_t2_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MTDATA2) & (mtsel[1:0] == 2'b10) & (~mtdata1_t2[MTDATA1_DMODE] | dbg_tlu_halted_f);\n   assign wr_mtdata2_t3_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MTDATA2) & (mtsel[1:0] == 2'b11) & (~mtdata1_t3[MTDATA1_DMODE] | dbg_tlu_halted_f);\n\n   rvdffe #(32)  mtdata2_t0_ff (.*, .en(wr_mtdata2_t0_r), .din(dec_csr_wrdata_r[31:0]), .dout(mtdata2_t0[31:0]));\n   rvdffe #(32)  mtdata2_t1_ff (.*, .en(wr_mtdata2_t1_r), .din(dec_csr_wrdata_r[31:0]), .dout(mtdata2_t1[31:0]));\n   rvdffe #(32)  mtdata2_t2_ff (.*, .en(wr_mtdata2_t2_r), .din(dec_csr_wrdata_r[31:0]), .dout(mtdata2_t2[31:0]));\n   rvdffe #(32)  mtdata2_t3_ff (.*, .en(wr_mtdata2_t3_r), .din(dec_csr_wrdata_r[31:0]), .dout(mtdata2_t3[31:0]));\n\n   assign mtdata2_tsel_out[31:0] = ( ({32{(mtsel[1:0] == 2'b00)}} & mtdata2_t0[31:0]) |\n                                     ({32{(mtsel[1:0] == 2'b01)}} & mtdata2_t1[31:0]) |\n                                     ({32{(mtsel[1:0] == 2'b10)}} & mtdata2_t2[31:0]) |\n                                     ({32{(mtsel[1:0] == 2'b11)}} & mtdata2_t3[31:0]));\n\n   assign trigger_pkt_any[0].tdata2[31:0] = mtdata2_t0[31:0];\n   assign trigger_pkt_any[1].tdata2[31:0] = mtdata2_t1[31:0];\n   assign trigger_pkt_any[2].tdata2[31:0] = mtdata2_t2[31:0];\n   assign trigger_pkt_any[3].tdata2[31:0] = mtdata2_t3[31:0];\n\n\n   //----------------------------------------------------------------------\n   // Performance Monitor Counters section starts\n   //----------------------------------------------------------------------\n   localparam MHPME_NOEVENT             = 10'd0;\n   localparam MHPME_CLK_ACTIVE          = 10'd1; // OOP - out of pipe\n   localparam MHPME_ICACHE_HIT          = 10'd2; // OOP\n   localparam MHPME_ICACHE_MISS         = 10'd3; // OOP\n   localparam MHPME_INST_COMMIT         = 10'd4;\n   localparam MHPME_INST_COMMIT_16B     = 10'd5;\n   localparam MHPME_INST_COMMIT_32B     = 10'd6;\n   localparam MHPME_INST_ALIGNED        = 10'd7; // OOP\n   localparam MHPME_INST_DECODED        = 10'd8; // OOP\n   localparam MHPME_INST_MUL            = 10'd9;\n   localparam MHPME_INST_DIV            = 10'd10;\n   localparam MHPME_INST_LOAD           = 10'd11;\n   localparam MHPME_INST_STORE          = 10'd12;\n   localparam MHPME_INST_MALOAD         = 10'd13;\n   localparam MHPME_INST_MASTORE        = 10'd14;\n   localparam MHPME_INST_ALU            = 10'd15;\n   localparam MHPME_INST_CSRREAD        = 10'd16;\n   localparam MHPME_INST_CSRRW          = 10'd17;\n   localparam MHPME_INST_CSRWRITE       = 10'd18;\n   localparam MHPME_INST_EBREAK         = 10'd19;\n   localparam MHPME_INST_ECALL          = 10'd20;\n   localparam MHPME_INST_FENCE          = 10'd21;\n   localparam MHPME_INST_FENCEI         = 10'd22;\n   localparam MHPME_INST_MRET           = 10'd23;\n   localparam MHPME_INST_BRANCH         = 10'd24;\n   localparam MHPME_BRANCH_MP           = 10'd25;\n   localparam MHPME_BRANCH_TAKEN        = 10'd26;\n   localparam MHPME_BRANCH_NOTP         = 10'd27;\n   localparam MHPME_FETCH_STALL         = 10'd28; // OOP\n   localparam MHPME_DECODE_STALL        = 10'd30; // OOP\n   localparam MHPME_POSTSYNC_STALL      = 10'd31; // OOP\n   localparam MHPME_PRESYNC_STALL       = 10'd32; // OOP\n   localparam MHPME_LSU_SB_WB_STALL     = 10'd34; // OOP\n   localparam MHPME_DMA_DCCM_STALL      = 10'd35; // OOP\n   localparam MHPME_DMA_ICCM_STALL      = 10'd36; // OOP\n   localparam MHPME_EXC_TAKEN           = 10'd37;\n   localparam MHPME_TIMER_INT_TAKEN     = 10'd38;\n   localparam MHPME_EXT_INT_TAKEN       = 10'd39;\n   localparam MHPME_FLUSH_LOWER         = 10'd40;\n   localparam MHPME_BR_ERROR            = 10'd41;\n   localparam MHPME_IBUS_TRANS          = 10'd42; // OOP\n   localparam MHPME_DBUS_TRANS          = 10'd43; // OOP\n   localparam MHPME_DBUS_MA_TRANS       = 10'd44; // OOP\n   localparam MHPME_IBUS_ERROR          = 10'd45; // OOP\n   localparam MHPME_DBUS_ERROR          = 10'd46; // OOP\n   localparam MHPME_IBUS_STALL          = 10'd47; // OOP\n   localparam MHPME_DBUS_STALL          = 10'd48; // OOP\n   localparam MHPME_INT_DISABLED        = 10'd49; // OOP\n   localparam MHPME_INT_STALLED         = 10'd50; // OOP\n   localparam MHPME_INST_BITMANIP       = 10'd54;\n   localparam MHPME_DBUS_LOAD           = 10'd55;\n   localparam MHPME_DBUS_STORE          = 10'd56;\n   // Counts even during sleep state\n   localparam MHPME_SLEEP_CYC           = 10'd512; // OOP\n   localparam MHPME_DMA_READ_ALL        = 10'd513; // OOP\n   localparam MHPME_DMA_WRITE_ALL       = 10'd514; // OOP\n   localparam MHPME_DMA_READ_DCCM       = 10'd515; // OOP\n   localparam MHPME_DMA_WRITE_DCCM      = 10'd516; // OOP\n\n   // Pack the event selects into a vector for genvar\n   assign mhpme_vec[0][9:0] = mhpme3[9:0];\n   assign mhpme_vec[1][9:0] = mhpme4[9:0];\n   assign mhpme_vec[2][9:0] = mhpme5[9:0];\n   assign mhpme_vec[3][9:0] = mhpme6[9:0];\n\n   // only consider committed itypes\n   //logic [3:0] pmu_i0_itype_qual;\n   assign pmu_i0_itype_qual[3:0] = dec_tlu_packet_r.pmu_i0_itype[3:0] & {4{tlu_i0_commit_cmt}};\n\n   // Generate the muxed incs for all counters based on event type\n   for (genvar i=0 ; i < 4; i++) begin\n      assign mhpmc_inc_r[i] =  {{~mcountinhibit[i+3]}} &\n           (\n             ({1{(mhpme_vec[i][9:0] == MHPME_CLK_ACTIVE      )}} & 1'b1) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_ICACHE_HIT      )}} & {ifu_pmu_ic_hit}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_ICACHE_MISS     )}} & {ifu_pmu_ic_miss}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_COMMIT     )}} & {tlu_i0_commit_cmt & ~illegal_r}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_COMMIT_16B )}} & {tlu_i0_commit_cmt & ~exu_pmu_i0_pc4 & ~illegal_r}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_COMMIT_32B )}} & {tlu_i0_commit_cmt &  exu_pmu_i0_pc4 & ~illegal_r}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_ALIGNED    )}} & ifu_pmu_instr_aligned)  |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_DECODED    )}} & dec_pmu_instr_decoded)  |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DECODE_STALL    )}} & {dec_pmu_decode_stall}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_MUL        )}} & {(pmu_i0_itype_qual == MUL)})     |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_DIV        )}} & {dec_tlu_packet_r.pmu_divide  & tlu_i0_commit_cmt & ~illegal_r})     |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_LOAD       )}} & {(pmu_i0_itype_qual == LOAD)})    |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_STORE      )}} & {(pmu_i0_itype_qual == STORE)})   |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_MALOAD     )}} & {(pmu_i0_itype_qual == LOAD)} &\n                                                                      {1{dec_tlu_packet_r.pmu_lsu_misaligned}})    |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_MASTORE    )}} & {(pmu_i0_itype_qual == STORE)} &\n                                                                      {1{dec_tlu_packet_r.pmu_lsu_misaligned}})    |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_ALU        )}} & {(pmu_i0_itype_qual == ALU)})     |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_CSRREAD    )}} & {(pmu_i0_itype_qual == CSRREAD)}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_CSRWRITE   )}} & {(pmu_i0_itype_qual == CSRWRITE)})|\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_CSRRW      )}} & {(pmu_i0_itype_qual == CSRRW)})   |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_EBREAK     )}} & {(pmu_i0_itype_qual == EBREAK)})  |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_ECALL      )}} & {(pmu_i0_itype_qual == ECALL)})   |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_FENCE      )}} & {(pmu_i0_itype_qual == FENCE)})   |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_FENCEI     )}} & {(pmu_i0_itype_qual == FENCEI)})  |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_MRET       )}} & {(pmu_i0_itype_qual == MRET)})    |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_BRANCH     )}} & {\n                                                                     ((pmu_i0_itype_qual == CONDBR) | (pmu_i0_itype_qual == JAL))})   |\n             ({1{(mhpme_vec[i][9:0] == MHPME_BRANCH_MP       )}} & {exu_pmu_i0_br_misp & tlu_i0_commit_cmt & ~illegal_r}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_BRANCH_TAKEN    )}} & {exu_pmu_i0_br_ataken & tlu_i0_commit_cmt & ~illegal_r}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_BRANCH_NOTP     )}} & {dec_tlu_packet_r.pmu_i0_br_unpred & tlu_i0_commit_cmt & ~illegal_r}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_FETCH_STALL     )}} & { ifu_pmu_fetch_stall}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DECODE_STALL    )}} & { dec_pmu_decode_stall}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_POSTSYNC_STALL  )}} & {dec_pmu_postsync_stall}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_PRESYNC_STALL   )}} & {dec_pmu_presync_stall}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_LSU_SB_WB_STALL )}} & { lsu_store_stall_any}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DMA_DCCM_STALL  )}} & { dma_dccm_stall_any}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DMA_ICCM_STALL  )}} & { dma_iccm_stall_any}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_EXC_TAKEN       )}} & { (i0_exception_valid_r | i0_trigger_hit_r | lsu_exc_valid_r)}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_TIMER_INT_TAKEN )}} & { take_timer_int | take_int_timer0_int | take_int_timer1_int}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_EXT_INT_TAKEN   )}} & { take_ext_int}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_FLUSH_LOWER     )}} & { tlu_flush_lower_r}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_BR_ERROR        )}} & {(dec_tlu_br0_error_r | dec_tlu_br0_start_error_r) & rfpc_i0_r}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_IBUS_TRANS      )}} & {ifu_pmu_bus_trxn}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DBUS_TRANS      )}} & {lsu_pmu_bus_trxn}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DBUS_MA_TRANS   )}} & {lsu_pmu_bus_misaligned}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_IBUS_ERROR      )}} & {ifu_pmu_bus_error}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DBUS_ERROR      )}} & {lsu_pmu_bus_error}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_IBUS_STALL      )}} & {ifu_pmu_bus_busy}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DBUS_STALL      )}} & {lsu_pmu_bus_busy}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INT_DISABLED    )}} & {~mstatus[MSTATUS_MIE]}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INT_STALLED     )}} & {~mstatus[MSTATUS_MIE] & |(mip[5:0] & mie[5:0])}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_INST_BITMANIP     )}} & {(pmu_i0_itype_qual == BITMANIPU)}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DBUS_LOAD       )}} & {tlu_i0_commit_cmt & lsu_pmu_load_external_r & ~illegal_r}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DBUS_STORE      )}} & {tlu_i0_commit_cmt & lsu_pmu_store_external_r & ~illegal_r}) |\n             // These count even during sleep\n             ({1{(mhpme_vec[i][9:0] == MHPME_SLEEP_CYC       )}} & {dec_tlu_pmu_fw_halted}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DMA_READ_ALL    )}} & {dma_pmu_any_read}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DMA_WRITE_ALL   )}} & {dma_pmu_any_write}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DMA_READ_DCCM   )}} & {dma_pmu_dccm_read}) |\n             ({1{(mhpme_vec[i][9:0] == MHPME_DMA_WRITE_DCCM  )}} & {dma_pmu_dccm_write})\n             );\n   end\n\n\n   if(pt.FAST_INTERRUPT_REDIRECT)\n   rvdffie #(31)  mstatus_ff (.*, .clk(free_l2clk),\n                             .din({mdseac_locked_ns, lsu_single_ecc_error_r, lsu_exc_valid_r, lsu_i0_exc_r,\n                                   take_ext_int_start,    take_ext_int_start_d1, take_ext_int_start_d2, ext_int_freeze,\n                                   mip_ns[5:0], mcyclel_cout & ~wr_mcycleh_r & mcyclel_cout_in,\n                                   minstret_enable, minstretl_cout_ns, fw_halted_ns,\n                                   meicidpl_ns[3:0], icache_rd_valid, icache_wr_valid, mhpmc_inc_r[3:0], perfcnt_halted,\n                                   mstatus_ns[1:0]}),\n                             .dout({mdseac_locked_f, lsu_single_ecc_error_r_d1, lsu_exc_valid_r_d1, lsu_i0_exc_r_d1,\n                                    take_ext_int_start_d1, take_ext_int_start_d2, take_ext_int_start_d3, ext_int_freeze_d1,\n                                    mip[5:0], mcyclel_cout_f, minstret_enable_f, minstretl_cout_f,\n                                    fw_halted, meicidpl[3:0], icache_rd_valid_f, icache_wr_valid_f,\n                                    mhpmc_inc_r_d1[3:0], perfcnt_halted_d1,\n                                    mstatus[1:0]}));\n\n   else\n   rvdffie #(27)  mstatus_ff (.*, .clk(free_l2clk),\n                             .din({mdseac_locked_ns, lsu_single_ecc_error_r, lsu_exc_valid_r, lsu_i0_exc_r,\n                                   mip_ns[5:0], mcyclel_cout & ~wr_mcycleh_r & mcyclel_cout_in,\n                                   minstret_enable, minstretl_cout_ns, fw_halted_ns,\n                                   meicidpl_ns[3:0], icache_rd_valid, icache_wr_valid, mhpmc_inc_r[3:0], perfcnt_halted,\n                                   mstatus_ns[1:0]}),\n                             .dout({mdseac_locked_f, lsu_single_ecc_error_r_d1, lsu_exc_valid_r_d1, lsu_i0_exc_r_d1,\n                                    mip[5:0], mcyclel_cout_f, minstret_enable_f, minstretl_cout_f,\n                                    fw_halted, meicidpl[3:0], icache_rd_valid_f, icache_wr_valid_f,\n                                    mhpmc_inc_r_d1[3:0], perfcnt_halted_d1,\n                                    mstatus[1:0]}));\n\n   assign perfcnt_halted = ((dec_tlu_dbg_halted & dcsr[DCSR_STOPC]) | dec_tlu_pmu_fw_halted);\n   assign perfcnt_during_sleep[3:0] = {4{~(dec_tlu_dbg_halted & dcsr[DCSR_STOPC])}} & {mhpme_vec[3][9],mhpme_vec[2][9],mhpme_vec[1][9],mhpme_vec[0][9]};\n\n   assign dec_tlu_perfcnt0 = mhpmc_inc_r_d1[0] & ~(perfcnt_halted_d1 & ~perfcnt_during_sleep[0]);\n   assign dec_tlu_perfcnt1 = mhpmc_inc_r_d1[1] & ~(perfcnt_halted_d1 & ~perfcnt_during_sleep[1]);\n   assign dec_tlu_perfcnt2 = mhpmc_inc_r_d1[2] & ~(perfcnt_halted_d1 & ~perfcnt_during_sleep[2]);\n   assign dec_tlu_perfcnt3 = mhpmc_inc_r_d1[3] & ~(perfcnt_halted_d1 & ~perfcnt_during_sleep[3]);\n\n   // ----------------------------------------------------------------------\n   // MHPMC3H(RW), MHPMC3(RW)\n   // [63:32][31:0] : Hardware Performance Monitor Counter 3\n   localparam MHPMC3"}
{"text": "        = 12'hB03;\n   localparam MHPMC3H       = 12'hB83;\n\n   assign mhpmc3_wr_en0 = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MHPMC3);\n   assign mhpmc3_wr_en1 = (~perfcnt_halted | perfcnt_during_sleep[0]) & (|(mhpmc_inc_r[0]));\n   assign mhpmc3_wr_en  = mhpmc3_wr_en0 | mhpmc3_wr_en1;\n   assign mhpmc3_incr[63:0] = {mhpmc3h[31:0],mhpmc3[31:0]} + {63'b0, 1'b1};\n   assign mhpmc3_ns[31:0] = mhpmc3_wr_en0 ? dec_csr_wrdata_r[31:0] : mhpmc3_incr[31:0];\n   rvdffe #(32)  mhpmc3_ff (.*, .clk(free_l2clk), .en(mhpmc3_wr_en), .din(mhpmc3_ns[31:0]), .dout(mhpmc3[31:0]));\n\n   assign mhpmc3h_wr_en0 = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MHPMC3H);\n   assign mhpmc3h_wr_en  = mhpmc3h_wr_en0 | mhpmc3_wr_en1;\n   assign mhpmc3h_ns[31:0] = mhpmc3h_wr_en0 ? dec_csr_wrdata_r[31:0] : mhpmc3_incr[63:32];\n   rvdffe #(32)  mhpmc3h_ff (.*, .clk(free_l2clk), .en(mhpmc3h_wr_en), .din(mhpmc3h_ns[31:0]), .dout(mhpmc3h[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MHPMC4H(RW), MHPMC4(RW)\n   // [63:32][31:0] : Hardware Performance Monitor Counter 4\n   localparam MHPMC4        = 12'hB04;\n   localparam MHPMC4H       = 12'hB84;\n\n   assign mhpmc4_wr_en0 = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MHPMC4);\n   assign mhpmc4_wr_en1 = (~perfcnt_halted | perfcnt_during_sleep[1]) & (|(mhpmc_inc_r[1]));\n   assign mhpmc4_wr_en  = mhpmc4_wr_en0 | mhpmc4_wr_en1;\n   assign mhpmc4_incr[63:0] = {mhpmc4h[31:0],mhpmc4[31:0]} + {63'b0,1'b1};\n   assign mhpmc4_ns[31:0] = mhpmc4_wr_en0 ? dec_csr_wrdata_r[31:0] : mhpmc4_incr[31:0];\n   rvdffe #(32)  mhpmc4_ff (.*, .clk(free_l2clk), .en(mhpmc4_wr_en), .din(mhpmc4_ns[31:0]), .dout(mhpmc4[31:0]));\n\n   assign mhpmc4h_wr_en0 = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MHPMC4H);\n   assign mhpmc4h_wr_en  = mhpmc4h_wr_en0 | mhpmc4_wr_en1;\n   assign mhpmc4h_ns[31:0] = mhpmc4h_wr_en0 ? dec_csr_wrdata_r[31:0] : mhpmc4_incr[63:32];\n   rvdffe #(32)  mhpmc4h_ff (.*, .clk(free_l2clk), .en(mhpmc4h_wr_en), .din(mhpmc4h_ns[31:0]), .dout(mhpmc4h[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MHPMC5H(RW), MHPMC5(RW)\n   // [63:32][31:0] : Hardware Performance Monitor Counter 5\n   localparam MHPMC5        = 12'hB05;\n   localparam MHPMC5H       = 12'hB85;\n\n   assign mhpmc5_wr_en0 = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MHPMC5);\n   assign mhpmc5_wr_en1 = (~perfcnt_halted | perfcnt_during_sleep[2]) & (|(mhpmc_inc_r[2]));\n   assign mhpmc5_wr_en  = mhpmc5_wr_en0 | mhpmc5_wr_en1;\n   assign mhpmc5_incr[63:0] = {mhpmc5h[31:0],mhpmc5[31:0]} + {63'b0,1'b1};\n   assign mhpmc5_ns[31:0] = mhpmc5_wr_en0 ? dec_csr_wrdata_r[31:0] : mhpmc5_incr[31:0];\n   rvdffe #(32)  mhpmc5_ff (.*, .clk(free_l2clk), .en(mhpmc5_wr_en), .din(mhpmc5_ns[31:0]), .dout(mhpmc5[31:0]));\n\n   assign mhpmc5h_wr_en0 = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MHPMC5H);\n   assign mhpmc5h_wr_en  = mhpmc5h_wr_en0 | mhpmc5_wr_en1;\n   assign mhpmc5h_ns[31:0] = mhpmc5h_wr_en0 ? dec_csr_wrdata_r[31:0] : mhpmc5_incr[63:32];\n   rvdffe #(32)  mhpmc5h_ff (.*, .clk(free_l2clk), .en(mhpmc5h_wr_en), .din(mhpmc5h_ns[31:0]), .dout(mhpmc5h[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MHPMC6H(RW), MHPMC6(RW)\n   // [63:32][31:0] : Hardware Performance Monitor Counter 6\n   localparam MHPMC6        = 12'hB06;\n   localparam MHPMC6H       = 12'hB86;\n\n   assign mhpmc6_wr_en0 = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MHPMC6);\n   assign mhpmc6_wr_en1 = (~perfcnt_halted | perfcnt_during_sleep[3]) & (|(mhpmc_inc_r[3]));\n   assign mhpmc6_wr_en  = mhpmc6_wr_en0 | mhpmc6_wr_en1;\n   assign mhpmc6_incr[63:0] = {mhpmc6h[31:0],mhpmc6[31:0]} + {63'b0,1'b1};\n   assign mhpmc6_ns[31:0] = mhpmc6_wr_en0 ? dec_csr_wrdata_r[31:0] : mhpmc6_incr[31:0];\n   rvdffe #(32)  mhpmc6_ff (.*, .clk(free_l2clk), .en(mhpmc6_wr_en), .din(mhpmc6_ns[31:0]), .dout(mhpmc6[31:0]));\n\n   assign mhpmc6h_wr_en0 = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MHPMC6H);\n   assign mhpmc6h_wr_en  = mhpmc6h_wr_en0 | mhpmc6_wr_en1;\n   assign mhpmc6h_ns[31:0] = mhpmc6h_wr_en0 ? dec_csr_wrdata_r[31:0] : mhpmc6_incr[63:32];\n   rvdffe #(32)  mhpmc6h_ff (.*, .clk(free_l2clk), .en(mhpmc6h_wr_en), .din(mhpmc6h_ns[31:0]), .dout(mhpmc6h[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MHPME3(RW)\n   // [9:0] : Hardware Performance Monitor Event 3\n   localparam MHPME3        = 12'h323;\n\n   // we only have events 0-56 with holes, 512-516, HPME* are WARL so zero otherwise.\n   assign zero_event_r = ( (dec_csr_wrdata_r[9:0] > 10'd516) |\n                           (|dec_csr_wrdata_r[31:10]) |\n                           ((dec_csr_wrdata_r[9:0] < 10'd512) & (dec_csr_wrdata_r[9:0] > 10'd56)) |\n                           ((dec_csr_wrdata_r[9:0] < 10'd54) & (dec_csr_wrdata_r[9:0] > 10'd50)) |\n                           (dec_csr_wrdata_r[9:0] == 10'd29) |\n                           (dec_csr_wrdata_r[9:0] == 10'd33)\n                           );\n\n   assign event_r[9:0] = zero_event_r ? '0 : dec_csr_wrdata_r[9:0];\n\n   assign wr_mhpme3_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MHPME3);\n   rvdffe #(10)  mhpme3_ff (.*, .en(wr_mhpme3_r), .din(event_r[9:0]), .dout(mhpme3[9:0]));\n   // ----------------------------------------------------------------------\n   // MHPME4(RW)\n   // [9:0] : Hardware Performance Monitor Event 4\n   localparam MHPME4        = 12'h324;\n\n   assign wr_mhpme4_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MHPME4);\n   rvdffe #(10)  mhpme4_ff (.*, .en(wr_mhpme4_r), .din(event_r[9:0]), .dout(mhpme4[9:0]));\n   // ----------------------------------------------------------------------\n   // MHPME5(RW)\n   // [9:0] : Hardware Performance Monitor Event 5\n   localparam MHPME5        = 12'h325;\n\n   assign wr_mhpme5_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MHPME5);\n   rvdffe #(10)  mhpme5_ff (.*, .en(wr_mhpme5_r), .din(event_r[9:0]), .dout(mhpme5[9:0]));\n   // ----------------------------------------------------------------------\n   // MHPME6(RW)\n   // [9:0] : Hardware Performance Monitor Event 6\n   localparam MHPME6        = 12'h326;\n\n   assign wr_mhpme6_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MHPME6);\n   rvdffe #(10)  mhpme6_ff (.*, .en(wr_mhpme6_r), .din(event_r[9:0]), .dout(mhpme6[9:0]));\n\n   //----------------------------------------------------------------------\n   // Performance Monitor Counters section ends\n   //----------------------------------------------------------------------\n   // ----------------------------------------------------------------------\n\n   // MCOUNTINHIBIT(RW)\n   // [31:7] : Reserved, read 0x0\n   // [6]    : HPM6 disable\n   // [5]    : HPM5 disable\n   // [4]    : HPM4 disable\n   // [3]    : HPM3 disable\n   // [2]    : MINSTRET disable\n   // [1]    : reserved, read 0x0\n   // [0]    : MCYCLE disable\n\n   localparam MCOUNTINHIBIT             = 12'h320;\n\n   assign wr_mcountinhibit_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MCOUNTINHIBIT);\n   rvdffs #(6)  mcountinhibit_ff (.*, .clk(csr_wr_clk), .en(wr_mcountinhibit_r), .din({dec_csr_wrdata_r[6:2], dec_csr_wrdata_r[0]}), .dout({mcountinhibit[6:2], mcountinhibit[0]}));\n   assign mcountinhibit[1] = 1'b0;\n\n   //--------------------------------------------------------------------------------\n   // trace\n   //--------------------------------------------------------------------------------\n   logic [4:0] dec_tlu_exc_cause_wb1_raw, dec_tlu_exc_cause_wb2;\n   logic       dec_tlu_int_valid_wb1_raw, dec_tlu_int_valid_wb2;\n\n   assign {dec_tlu_i0_valid_wb1,\n           dec_tlu_i0_exc_valid_wb1,\n           dec_tlu_exc_cause_wb1_raw[4:0],\n           dec_tlu_int_valid_wb1_raw}  =   {8{~dec_tlu_trace_disable}} & {i0_valid_wb,\n                                                                          i0_exception_valid_r_d1 | lsu_i0_exc_r_d1 | (trigger_hit_r_d1 & ~trigger_hit_dmode_r_d1),\n                                                                          exc_cause_wb[4:0],\n                                                                          interrupt_valid_r_d1};\n\n\n\n  // skid buffer for ints, reduces trace port count by 1\n   rvdffie #(.WIDTH(6), .OVERRIDE(1))  traceskidff (.*,  .clk(clk),\n                        .din ({dec_tlu_exc_cause_wb1_raw[4:0],\n                               dec_tlu_int_valid_wb1_raw}),\n                        .dout({dec_tlu_exc_cause_wb2[4:0],\n                               dec_tlu_int_valid_wb2}));\n   //skid for ints\n   assign dec_tlu_exc_cause_wb1[4:0] =  dec_tlu_int_valid_wb2 ? dec_tlu_exc_cause_wb2[4:0] : dec_tlu_exc_cause_wb1_raw[4:0];\n   assign dec_tlu_int_valid_wb1 = dec_tlu_int_valid_wb2;\n\n   assign dec_tlu_mtval_wb1  = mtval[31:0];\n\n   // end trace\n   //--------------------------------------------------------------------------------\n\n\n   // ----------------------------------------------------------------------\n   // CSR read mux\n   // ----------------------------------------------------------------------\n\n// file \"csrdecode\" is human readable file that has all of the CSR decodes defined and is part of git repo\n// modify this file as needed\n\n// to generate all the equations below from \"csrdecode\" except legal equation:\n\n// 1) coredecode -in csrdecode > corecsrdecode.e\n\n// 2) espresso -Dso -oeqntott < corecsrdecode.e | addassign > csrequations\n\n// to generate the legal CSR equation below:\n\n// 1) coredecode -in csrdecode -legal > csrlegal.e\n\n// 2) espresso -Dso -oeqntott < csrlegal.e | addassign > csrlegal_equation\n// coredecode -in csrdecode > corecsrdecode.e; espresso -Dso -oeqntott < corecsrdecode.e | addassign > csrequations; coredecode -in csrdecode -legal > csrlegal.e; espresso -Dso -oeqntott csrlegal.e | addassign > csrlegal_equation\n\nassign csr_misa = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]);\n\nassign csr_mvendorid = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_marchid = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mimpid = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_mhartid = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[2]);\n\nassign csr_mstatus = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mtvec = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]);\n\nassign csr_mip = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[2]);\n\nassign csr_mie = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mcyclel = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]);\n\nassign csr_mcycleh = (dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]);\n\nassign csr_minstretl = (!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_minstreth = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mscratch = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mepc = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mcause = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mscause = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[2]);\n\nassign csr_mtval = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mrac = (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]);\n\nassign csr_dmst = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]);\n\nassign csr_mdseac = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]);\n\nassign csr_meihap = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[3]);\n\nassign csr_meivt = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_meipt = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_meicurpl = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[2]);\n\nassign csr_meicidpl = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_dcsr = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mcgc = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[0]);\n\nassign csr_mfdc = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_dpc = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[0]);\n\nassign csr_mtsel = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mtdata1 = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[0]);\n\nassign csr_mtdata2 = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[1]);\n\nassign csr_mhpmc3 = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc4 = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc5 = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc6 = (!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc3h = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc4h = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc5h = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc6h = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mhpme3 = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mhpme4 = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mhpme5 = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mhpme6 = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]);\n\nassign csr_mcountinhibit = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[0]);\n\nassign csr_mitctl0 = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]);\n\nassign csr_mitctl1 = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[3]\n    &dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_mitb0 = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_mitb1 = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mitcnt0 = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[0]);\n\nassign csr_mitcnt1 = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_mpmc = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]);\n\nassign csr_mcpc = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]);\n\nassign csr_meicpct = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mdeau = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[3]);\n\nassign csr_micect = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_miccmect = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[0]);\n\nassign csr_mdccmect = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mfdht = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mfdhs = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]\n    &dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]);\n\nassign csr_dicawics = (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n    &!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_dicad0h = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[3]\n    &dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]);\n\nassign csr_dicad0 = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]\n    &dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_dicad1 = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_dicago = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_pmpcfg = (!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]);\n\nassign csr_pmpaddr0 = (!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]);\n\nassign csr_pmpaddr16 = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]);\n\nassign csr_pmpaddr32 = (!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[4]);\n\nassign csr_pmpaddr48 = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]);\n\nassign valid_only = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]) | (\n    !dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[4]) | (\n    !dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[3]) | (\n    !dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[3]);\n\nassign presync = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[10]\n    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_r"}
{"text": "daddr_d[3]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]) | (!dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[10]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[0]) | (\n    dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign postsync = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[10]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[0]) | (\n    !dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]) | (\n    dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]) | (!dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign legal = (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]) | (\n    !dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]) | (dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[0]) | (\n    !dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]) | (\n    !dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]) | (\n    dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]) | (\n    dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]) | (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[2]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[1]) | (!dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[2]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[1]) | (dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[1]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]) | (\n    !dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]) | (\n    !dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[3]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[3]) | (!dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]) | (\n    dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]);\n\n\nassign dec_tlu_presync_d = presync & dec_csr_any_unq_d & ~dec_csr_wen_unq_d;\nassign dec_tlu_postsync_d = postsync & dec_csr_any_unq_d;\n\n   // allow individual configuration of these features\nassign conditionally_illegal = ((csr_mitcnt0 | csr_mitcnt1 | csr_mitb0 | csr_mitb1 | csr_mitctl0 | csr_mitctl1) & !pt.TIMER_LEGAL_EN);\n\nassign valid_csr = ( legal & (~(csr_dcsr | csr_dpc | csr_dmst | csr_dicawics | csr_dicad0 | csr_dicad0h | csr_dicad1 | csr_dicago) | dbg_tlu_halted_f)\n                     & ~fast_int_meicpct & ~conditionally_illegal);\n\nassign dec_csr_legal_d = ( dec_csr_any_unq_d &\n                           valid_csr &          // of a valid CSR\n                           ~(dec_csr_wen_unq_d & (csr_mvendorid | csr_marchid | csr_mimpid | csr_mhartid | csr_mdseac | csr_meihap)) // that's not a write to a RO CSR\n                           );\n   // CSR read mux\nassign dec_csr_rddata_d[31:0] = ( ({32{csr_misa}}      & 32'h40001104) |\n                                  ({32{csr_mvendorid}} & 32'h00000045) |\n                                  ({32{csr_marchid}}   & 32'h00000010) |\n                                  ({32{csr_mimpid}}    & 32'h4) |\n                                  ({32{csr_mhartid}}   & {core_id[31:4], 4'b0}) |\n                                  ({32{csr_mstatus}}   & {19'b0, 2'b11, 3'b0, mstatus[1], 3'b0, mstatus[0], 3'b0}) |\n                                  ({32{csr_mtvec}}     & {mtvec[30:1], 1'b0, mtvec[0]}) |\n                                  ({32{csr_mip}}       & {1'b0, mip[5:3], 16'b0, mip[2], 3'b0, mip[1], 3'b0, mip[0], 3'b0}) |\n                                  ({32{csr_mie}}       & {1'b0, mie[5:3], 16'b0, mie[2], 3'b0, mie[1], 3'b0, mie[0], 3'b0}) |\n                                  ({32{csr_mcyclel}}   & mcyclel[31:0]) |\n                                  ({32{csr_mcycleh}}   & mcycleh_inc[31:0]) |\n                                  ({32{csr_minstretl}} & minstretl_read[31:0]) |\n                                  ({32{csr_minstreth}} & minstreth_read[31:0]) |\n                                  ({32{csr_mscratch}}  & mscratch[31:0]) |\n                                  ({32{csr_mepc}}      & {mepc[31:1], 1'b0}) |\n                                  ({32{csr_mcause}}    & mcause[31:0]) |\n                                  ({32{csr_mscause}}   & {28'b0, mscause[3:0]}) |\n                                  ({32{csr_mtval}}     & mtval[31:0]) |\n                                  ({32{csr_mrac}}      & mrac[31:0]) |\n                                  ({32{csr_mdseac}}    & mdseac[31:0]) |\n                                  ({32{csr_meivt}}     & {meivt[31:10], 10'b0}) |\n                                  ({32{csr_meihap}}    & {meivt[31:10], meihap[9:2], 2'b0}) |\n                                  ({32{csr_meicurpl}}  & {28'b0, meicurpl[3:0]}) |\n                                  ({32{csr_meicidpl}}  & {28'b0, meicidpl[3:0]}) |\n                                  ({32{csr_meipt}}     & {28'b0, meipt[3:0]}) |\n                                  ({32{csr_mcgc}}      & {22'b0, mcgc[9:0]}) |\n                                  ({32{csr_mfdc}}      & {13'b0, mfdc[18:0]}) |\n                                  ({32{csr_dcsr}}      & {16'h4000, dcsr[15:2], 2'b11}) |\n                                  ({32{csr_dpc}}       & {dpc[31:1], 1'b0}) |\n                                  ({32{csr_dicad0}}    & dicad0[31:0]) |\n                                  ({32{csr_dicad0h}}   & dicad0h[31:0]) |\n                                  ({32{csr_dicad1}}    & dicad1[31:0]) |\n                                  ({32{csr_dicawics}}  & {7'b0, dicawics[16], 2'b0, dicawics[15:14], 3'b0, dicawics[13:0], 3'b0}) |\n                                  ({32{csr_mtsel}}     & {30'b0, mtsel[1:0]}) |\n                                  ({32{csr_mtdata1}}   & {mtdata1_tsel_out[31:0]}) |\n                                  ({32{csr_mtdata2}}   & {mtdata2_tsel_out[31:0]}) |\n                                  ({32{csr_micect}}    & {micect[31:0]}) |\n                                  ({32{csr_miccmect}}  & {miccmect[31:0]}) |\n                                  ({32{csr_mdccmect}}  & {mdccmect[31:0]}) |\n                                  ({32{csr_mhpmc3}}    & mhpmc3[31:0]) |\n                                  ({32{csr_mhpmc4}}    & mhpmc4[31:0]) |\n                                  ({32{csr_mhpmc5}}    & mhpmc5[31:0]) |\n                                  ({32{csr_mhpmc6}}    & mhpmc6[31:0]) |\n                                  ({32{csr_mhpmc3h}}   & mhpmc3h[31:0]) |\n                                  ({32{csr_mhpmc4h}}   & mhpmc4h[31:0]) |\n                                  ({32{csr_mhpmc5h}}   & mhpmc5h[31:0]) |\n                                  ({32{csr_mhpmc6h}}   & mhpmc6h[31:0]) |\n                                  ({32{csr_mfdht}}     & {26'b0, mfdht[5:0]}) |\n                                  ({32{csr_mfdhs}}     & {30'b0, mfdhs[1:0]}) |\n                                  ({32{csr_mhpme3}}    & {22'b0,mhpme3[9:0]}) |\n                                  ({32{csr_mhpme4}}    & {22'b0,mhpme4[9:0]}) |\n                                  ({32{csr_mhpme5}}    & {22'b0,mhpme5[9:0]}) |\n                                  ({32{csr_mhpme6}}    & {22'b0,mhpme6[9:0]}) |\n                                  ({32{csr_mcountinhibit}} & {25'b0, mcountinhibit[6:0]}) |\n                                  ({32{csr_mpmc}}      & {30'b0, mpmc[1], 1'b0}) |\n                                  ({32{dec_timer_read_d}} & dec_timer_rddata_d[31:0]) |\n                                  ({32{dec_pmp_read_d}} & dec_pmp_rddata_d[31:0])\n                                  );\n\n\n\nendmodule // el2_dec_tlu_ctl\n\nmodule el2_dec_timer_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n   input logic clk,\n   input logic free_l2clk,\n   input logic csr_wr_clk,\n   input logic rst_l,\n   input logic        dec_csr_wen_r_mod,      // csr write enable at wb\n   input logic [11:0] dec_csr_wraddr_r,      // write address for csr\n   input logic [31:0] dec_csr_wrdata_r,   // csr write data at wb\n\n   input logic csr_mitctl0,\n   input logic csr_mitctl1,\n   input logic csr_mitb0,\n   input logic csr_mitb1,\n   input logic csr_mitcnt0,\n   input logic csr_mitcnt1,\n\n\n   input logic dec_pause_state, // Paused\n   input logic dec_tlu_pmu_fw_halted, // pmu/fw halted\n   input logic internal_dbg_halt_timers, // debug halted\n\n   output logic [31:0] dec_timer_rddata_d, // timer CSR read data\n   output logic        dec_timer_read_d, // timer CSR address match\n   output logic        dec_timer_t0_pulse, // timer0 int\n   output logic        dec_timer_t1_pulse, // timer1 int\n\n   input  logic        scan_mode\n   );\n   localparam MITCTL_ENABLE             = 0;\n   localparam MITCTL_ENABLE_HALTED      = 1;\n   localparam MITCTL_ENABLE_PAUSED      = 2;\n\n   logic [31:0] mitcnt0_ns, mitcnt0, mitcnt1_ns, mitcnt1, mitb0, mitb1, mitb0_b, mitb1_b, mitcnt0_inc, mitcnt1_inc;\n   logic [2:0] mitctl0_ns, mitctl0;\n   logic [3:0] mitctl1_ns, mitctl1;\n   logic wr_mitcnt0_r, wr_mitcnt1_r, wr_mitb0_r, wr_mitb1_r, wr_mitctl0_r, wr_mitctl1_r;\n   logic mitcnt0_inc_ok, mitcnt1_inc_ok;\n   logic mitcnt0_inc_cout, mitcnt1_inc_cout;\n logic mit0_match_ns;\n logic mit1_match_ns;\n logic mitctl0_0_b_ns;\n logic mitctl0_0_b;\n logic mitctl1_0_b_ns;\n logic mitctl1_0_b;\n\n   assign mit0_match_ns = (mitcnt0[31:0] >= mitb0[31:0]);\n   assign mit1_match_ns = (mitcnt1[31:0] >= mitb1[31:0]);\n\n   assign dec_timer_t0_pulse = mit0_match_ns;\n   assign dec_timer_t1_pulse = mit1_match_ns;\n   // ----------------------------------------------------------------------\n   // MITCNT0 (RW)\n   // [31:0] : Internal Timer Counter 0\n\n   localparam MITCNT0       = 12'h7d2;\n\n   assign wr_mitcnt0_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MITCNT0);\n\n   assign mitcnt0_inc_ok = mitctl0[MITCTL_ENABLE] & (~dec_pause_state | mitctl0[MITCTL_ENABLE_PAUSED]) & (~dec_tlu_pmu_fw_halted | mitctl0[MITCTL_ENABLE_HALTED]) & ~internal_dbg_halt_timers;\n\n   assign {mitcnt0_inc_cout, mitcnt0_inc[7:0]} = mitcnt0[7:0] + {7'b0, 1'b1};\n   assign mitcnt0_inc[31:8] = mitcnt0[31:8] + {23'b0, mitcnt0_inc_cout};\n\n   assign mitcnt0_ns[31:0]  = wr_mitcnt0_r ? dec_csr_wrdata_r[31:0] : mit0_match_ns ? 'b0 : mitcnt0_inc[31:0];\n\n   rvdffe #(24) mitcnt0_ffb      (.*, .clk(free_l2clk), .en(wr_mitcnt0_r | (mitcnt0_inc_ok & mitcnt0_inc_cout) | mit0_match_ns), .din(mitcnt0_ns[31:8]), .dout(mitcnt0[31:8]));\n   rvdffe #(8)  mitcnt0_ffa      (.*, .clk(free_l2clk), .en(wr_mitcnt0_r | mitcnt0_inc_ok | mit0_match_ns),                       .din(mitcnt0_ns[7:0]), .dout(mitcnt0[7:0]));\n\n   // ----------------------------------------------------------------------\n   // MITCNT1 (RW)\n   // [31:0] : Internal Timer Counter 0\n\n   localparam MITCNT1       = 12'h7d5;\n\n   assign wr_mitcnt1_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MITCNT1);\n\n   assign mitcnt1_inc_ok = mitctl1[MITCTL_ENABLE] &\n                           (~dec_pause_state | mitctl1[MITCTL_ENABLE_PAUSED]) &\n                           (~dec_tlu_pmu_fw_halted | mitctl1[MITCTL_ENABLE_HALTED]) &\n                           ~internal_dbg_halt_timers &\n                           (~mitctl1[3] | mit0_match_ns);\n\n   // only inc MITCNT1 if not cascaded with 0, or if 0 overflows\n   assign {mitcnt1_inc_cout, mitcnt1_inc[7:0]} = mitcnt1[7:0] + {7'b0, 1'b1};\n   assign mitcnt1_inc[31:8] = mitcnt1[31:8] + {23'b0, mitcnt1_inc_cout};\n\n   assign mitcnt1_ns[31:0]  = wr_mitcnt1_r ? dec_csr_wrdata_r[31:0] : mit1_match_ns ? 'b0 : mitcnt1_inc[31:0];\n\n   rvdffe #(24) mitcnt1_ffb      (.*, .clk(free_l2clk), .en(wr_mitcnt1_r | (mitcnt1_inc_ok & mitcnt1_inc_cout) | mit1_match_ns), .din(mitcnt1_ns[31:8]), .dout(mitcnt1[31:8]));\n   rvdffe #(8)  mitcnt1_ffa      (.*, .clk(free_l2clk), .en(wr_mitcnt1_r | mitcnt1_inc_ok | mit1_match_ns),                       .din(mitcnt1_ns[7:0]), .dout(mitcnt1[7:0]));\n\n\n   // ----------------------------------------------------------------------\n   // MITB0 (RW)\n   // [31:0] : Internal Timer Bound 0\n\n   localparam MITB0         = 12'h7d3;\n\n   assign wr_mitb0_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MITB0);\n\n   rvdffe #(32) mitb0_ff      (.*, .en(wr_mitb0_r), .din(~dec_csr_wrdata_r[31:0]), .dout(mitb0_b[31:0]));\n   assign mitb0[31:0] = ~mitb0_b[31:0];\n\n   // ----------------------------------------------------------------------\n   // MITB1 (RW)\n   // [31:0] : Internal Timer Bound 1\n\n   localparam MITB1         = 12'h7d6;\n\n   assign wr_mitb1_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MITB1);\n\n   rvdffe #(32) mitb1_ff      (.*, .en(wr_mitb1_r), .din(~dec_csr_wrdata_r[31:0]), .dout(mitb1_b[31:0]));\n   assign mitb1[31:0] = ~mitb1_b[31:0];\n\n   // ----------------------------------------------------------------------\n   // MITCTL0 (RW) Internal Timer Ctl 0\n   // [31:3] : Reserved, reads 0x0\n   // [2]    : Enable while PAUSEd\n   // [1]    : Enable while HALTed\n   // [0]    : Enable (resets to 0x1)\n\n   localparam MITCTL0       = 12'h7d4;\n\n   assign wr_mitctl0_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MITCTL0);\n   assign mitctl0_ns[2:0] = wr_mitctl0_r ? {dec_csr_wrdata_r[2:0]} : {mitctl0[2:0]};\n\n   assign mitctl0_0_b_ns = ~mitctl0_ns[0];\n   rvdffs #(3) mitctl0_ff      (.*, .clk(csr_wr_clk), .en(wr_mitctl0_r), .din({mitctl0_ns[2:1], mitctl0_0_b_ns}), .dout({mitctl0[2:1], mitctl0_0_b}));\n   assign mitctl0[0] = ~mitctl0_0_b;\n\n   // ----------------------------------------------------------------------\n   // MITCTL1 (RW) Internal Timer Ctl 1\n   // [31:4] : Reserved, reads 0x0\n   // [3]    : Cascade\n   // [2]    : Enable while PAUSEd\n   // [1]    : Enable while HALTed\n   // [0]    : Enable (resets to 0x1)\n\n   localparam MITCTL1       = 12'h7d7;\n\n   assign wr_mitctl1_r = dec_csr_wen_r_mod & (dec_csr_wraddr_r[11:0] == MITCTL1);\n   assign mitctl1_ns[3:0] = wr_mitctl1_r ? {dec_csr_wrdata_r[3:0]} : {mitctl1[3:0]};\n\n   assign mitctl1_0_b_ns = ~mitctl1_ns[0];\n   rvdffs #(4) mitctl1_ff      (.*, .clk(csr_wr_clk), .en(wr_mitctl1_r), .din({mitctl1_ns[3:1], mitctl1_0_b_ns}), .dout({mitctl1[3:1], mitctl1_0_b}));\n   assign mitctl1[0] = ~mitctl1_0_b;\n   assign dec_timer_read_d = csr_mitcnt1 | csr_mitcnt0 | csr_mitb1 | csr_mitb0 | csr_mitctl0 | csr_mitctl1;\n   assign dec_timer_rddata_d[31:0] = ( ({32{csr_mitcnt0}}      & mitcnt0[31:0]) |\n                                       ({32{csr_mitcnt1}}      & mitcnt1[31:0]) |\n                               "}
{"text": "        ({32{csr_mitb0}}        & mitb0[31:0]) |\n                                       ({32{csr_mitb1}}        & mitb1[31:0]) |\n                                       ({32{csr_mitctl0}}      & {29'b0, mitctl0[2:0]}) |\n                                       ({32{csr_mitctl1}}      & {28'b0, mitctl1[3:0]})\n                                       );\n\n\nendmodule // dec_timer_ctl\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: DEC Trigger Logic\n// Comments:\n//\n//********************************************************************************\nmodule el2_dec_trigger\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n\n   input el2_trigger_pkt_t [3:0] trigger_pkt_any,           // Packet from tlu. 'select':0-pc,1-Opcode  'Execute' needs to be set for dec triggers to fire. 'match'-1 do mask, 0: full match\n   input logic [31:1]  dec_i0_pc_d,                          // i0 pc\n\n   output logic [3:0] dec_i0_trigger_match_d                 // Trigger match\n);\n\n   logic [3:0][31:0]  dec_i0_match_data;\n   logic [3:0]        dec_i0_trigger_data_match;\n\n   for (genvar i=0; i<4; i++) begin\n      assign dec_i0_match_data[i][31:0] = ({32{~trigger_pkt_any[i].select & trigger_pkt_any[i].execute}} & {dec_i0_pc_d[31:1], trigger_pkt_any[i].tdata2[0]});      // select=0; do a PC match\n\n      rvmaskandmatch trigger_i0_match (.mask(trigger_pkt_any[i].tdata2[31:0]), .data(dec_i0_match_data[i][31:0]), .masken(trigger_pkt_any[i].match), .match(dec_i0_trigger_data_match[i]));\n\n      assign dec_i0_trigger_match_d[i] = trigger_pkt_any[i].execute & trigger_pkt_any[i].m & dec_i0_trigger_data_match[i];\n   end\n\nendmodule // el2_dec_trigger\n\n"}
{"text": "// performance monitor stuff\n//`ifndef EL2_DEF_SV\n//`define EL2_DEF_SV\npackage el2_pkg;\n\n`include \"el2_pdef.vh\"\n\ntypedef struct packed {\n                       logic  trace_rv_i_valid_ip;\n                       logic [31:0] trace_rv_i_insn_ip;\n                       logic [31:0] trace_rv_i_address_ip;\n                       logic  trace_rv_i_exception_ip;\n                       logic [4:0] trace_rv_i_ecause_ip;\n                       logic  trace_rv_i_interrupt_ip;\n                       logic [31:0] trace_rv_i_tval_ip;\n                       } el2_trace_pkt_t;\n\n\ntypedef enum logic [3:0] {\n                          NULL     = 4'b0000,\n                          MUL      = 4'b0001,\n                          LOAD     = 4'b0010,\n                          STORE    = 4'b0011,\n                          ALU      = 4'b0100,\n                          CSRREAD  = 4'b0101,\n                          CSRWRITE = 4'b0110,\n                          CSRRW    = 4'b0111,\n                          EBREAK   = 4'b1000,\n                          ECALL    = 4'b1001,\n                          FENCE    = 4'b1010,\n                          FENCEI   = 4'b1011,\n                          MRET     = 4'b1100,\n                          CONDBR   = 4'b1101,\n                          JAL      = 4'b1110,\n                          BITMANIPU = 4'b1111\n                          } el2_inst_pkt_t;\n\ntypedef struct packed {\n                       logic valid;\n                       logic wb;\n                       logic [2:0] tag;\n                       logic [4:0] rd;\n                       } el2_load_cam_pkt_t;\n\ntypedef struct packed {\n                       logic pc0_call;\n                       logic pc0_ret;\n                       logic pc0_pc4;\n                       } el2_rets_pkt_t;\ntypedef struct packed {\n                       logic valid;\n                       logic [11:0] toffset;\n                       logic [1:0] hist;\n                       logic br_error;\n                       logic br_start_error;\n                       logic  bank;\n                       logic [31:1] prett;  // predicted ret target\n                       logic way;\n                       logic ret;\n                       } el2_br_pkt_t;\n\ntypedef struct packed {\n                       logic valid;\n                       logic [1:0] hist;\n                       logic br_error;\n                       logic br_start_error;\n                       logic way;\n                       logic middle;\n                       } el2_br_tlu_pkt_t;\n\ntypedef struct packed {\n                       logic misp;\n                       logic ataken;\n                       logic boffset;\n                       logic pc4;\n                       logic [1:0] hist;\n                       logic [11:0] toffset;\n                       logic valid;\n                       logic br_error;\n                       logic br_start_error;\n                       logic pcall;\n                       logic pja;\n                       logic way;\n                       logic pret;\n                       // for power use the pret bit to clock the prett field\n                       logic [31:1] prett;\n                       } el2_predict_pkt_t;\n\ntypedef struct packed {\n                       // unlikely to change\n                       logic icaf;\n                       logic icaf_second;\n                       logic [1:0] icaf_type;\n                       logic fence_i;\n                       logic [3:0] i0trigger;\n                       logic pmu_i0_br_unpred;     // pmu\n                       logic pmu_divide;\n                       // likely to change\n                       logic legal;\n                       logic pmu_lsu_misaligned;\n                       el2_inst_pkt_t pmu_i0_itype;        // pmu - instruction type\n                       } el2_trap_pkt_t;\n\ntypedef struct packed {\n                       // unlikely to change\n                       logic i0div;\n                       logic csrwen;\n                       logic csrwonly;\n                       logic [11:0] csrwaddr;\n                       // likely to change\n                       logic [4:0] i0rd;\n                       logic i0load;\n                       logic i0store;\n                       logic i0v;\n                       logic i0valid;\n                       } el2_dest_pkt_t;\n\ntypedef struct packed {\n                       logic mul;\n                       logic load;\n                       logic alu;\n                       } el2_class_pkt_t;\n\ntypedef struct packed {\n                       logic [4:0] rs1;\n                       logic [4:0] rs2;\n                       logic [4:0] rd;\n                       } el2_reg_pkt_t;\n\n\ntypedef struct packed {\n                       logic clz;\n                       logic ctz;\n                       logic cpop;\n                       logic sext_b;\n                       logic sext_h;\n                       logic min;\n                       logic max;\n                       logic pack;\n                       logic packu;\n                       logic packh;\n                       logic rol;\n                       logic ror;\n                       logic grev;\n                       logic gorc;\n                       logic zbb;\n                       logic bset;\n                       logic bclr;\n                       logic binv;\n                       logic bext;\n                       logic sh1add;\n                       logic sh2add;\n                       logic sh3add;\n                       logic zba;\n                       logic land;\n                       logic lor;\n                       logic lxor;\n                       logic sll;\n                       logic srl;\n                       logic sra;\n                       logic beq;\n                       logic bne;\n                       logic blt;\n                       logic bge;\n                       logic add;\n                       logic sub;\n                       logic slt;\n                       logic unsign;\n                       logic jal;\n                       logic predict_t;\n                       logic predict_nt;\n                       logic csr_write;\n                       logic csr_imm;\n                       } el2_alu_pkt_t;\n\ntypedef struct packed {\n                       logic fast_int;\n/* verilator lint_off SYMRSVDWORD */\n                       logic stack;\n/* verilator lint_on SYMRSVDWORD */\n                       logic by;\n                       logic half;\n                       logic word;\n                       logic dword;  // for dma\n                       logic load;\n                       logic store;\n                       logic unsign;\n                       logic dma;    // dma pkt\n                       logic store_data_bypass_d;\n                       logic load_ldst_bypass_d;\n                       logic store_data_bypass_m;\n                       logic valid;\n                       } el2_lsu_pkt_t;\n\ntypedef struct packed {\n                      logic inst_type;   //0: Load, 1: Store\n                      //logic dma_valid;\n                      logic exc_type;    //0: MisAligned, 1: Access Fault\n                      logic [3:0] mscause;\n                      logic [31:0] addr;\n                      logic single_ecc_error;\n                      logic exc_valid;\n                      } el2_lsu_error_pkt_t;\n\ntypedef struct packed {\n                       logic clz;\n                       logic ctz;\n                       logic cpop;\n                       logic sext_b;\n                       logic sext_h;\n                       logic min;\n                       logic max;\n                       logic pack;\n                       logic packu;\n                       logic packh;\n                       logic rol;\n                       logic ror;\n                       logic grev;\n                       logic gorc;\n                       logic zbb;\n                       logic bset;\n                       logic bclr;\n                       logic binv;\n                       logic bext;\n                       logic zbs;\n                       logic bcompress;\n                       logic bdecompress;\n                       logic zbe;\n                       logic clmul;\n                       logic clmulh;\n                       logic clmulr;\n                       logic zbc;\n                       logic shfl;\n                       logic unshfl;\n                       logic xperm_n;\n                       logic xperm_b;\n                       logic xperm_h;\n                       logic zbp;\n                       logic crc32_b;\n                       logic crc32_h;\n                       logic crc32_w;\n                       logic crc32c_b;\n                       logic crc32c_h;\n                       logic crc32c_w;\n                       logic zbr;\n                       logic bfp;\n                       logic zbf;\n                       logic sh1add;\n                       logic sh2add;\n                       logic sh3add;\n                       logic zba;\n                       logic alu;\n                       logic rs1;\n                       logic rs2;\n                       logic imm12;\n                       logic rd;\n                       logic shimm5;\n                       logic imm20;\n                       logic pc;\n                       logic load;\n                       logic store;\n                       logic lsu;\n                       logic add;\n                       logic sub;\n                       logic land;\n                       logic lor;\n                       logic lxor;\n                       logic sll;\n                       logic sra;\n                       logic srl;\n                       logic slt;\n                       logic unsign;\n                       logic condbr;\n                       logic beq;\n                       logic bne;\n                       logic bge;\n                       logic blt;\n                       logic jal;\n                       logic by;\n                       logic half;\n                       logic word;\n                       logic csr_read;\n                       logic csr_clr;\n                       logic csr_set;\n                       logic csr_write;\n                       logic csr_imm;\n                       logic presync;\n                       logic postsync;\n                       logic ebreak;\n                       logic ecall;\n                       logic mret;\n                       logic mul;\n                       logic rs1_sign;\n                       logic rs2_sign;\n                       logic low;\n                       logic div;\n                       logic rem;\n                       logic fence;\n                       logic fence_i;\n                       logic pm_alu;\n                       logic legal;\n                       } el2_dec_pkt_t;\n\n\ntypedef struct packed {\n                       logic valid;\n                       logic rs1_sign;\n                       logic rs2_sign;\n                       logic low;\n                       logic bcompress;\n                       logic bdecompress;\n                       logic clmul;\n                       logic clmulh;\n                       logic clmulr;\n                       logic grev;\n                       logic gorc;\n                       logic shfl;\n                       logic unshfl;\n                       logic crc32_b;\n                       logic crc32_h;\n                       logic crc32_w;\n                       logic crc32c_b;\n                       logic crc32c_h;\n                       logic crc32c_w;\n                       logic bfp;\n                       logic xperm_n;\n                       logic xperm_b;\n                       logic xperm_h;\n                       } el2_mul_pkt_t;\n\ntypedef struct packed {\n                       logic valid;\n                       logic unsign;\n                       logic rem;\n                       } el2_div_pkt_t;\n\ntypedef struct packed {\n                       logic        TEST1;\n                       logic        RME;\n                       logic [3:0]  RM;\n\n                       logic        LS;\n                       logic        DS;\n                       logic        SD;\n                       logic        TEST_RNM;\n                       logic        BC1;\n                       logic        BC2;\n                      } el2_ccm_ext_in_pkt_t;\n\ntypedef struct packed {\n                       logic        TEST1;\n                       logic        RME;\n                       logic [3:0]  RM;\n                       logic        LS;\n                       logic        DS;\n                       logic        SD;\n                       logic        TEST_RNM;\n                       logic        BC1;\n                       logic        BC2;\n                      } el2_dccm_ext_in_pkt_t;\n\n\ntypedef struct packed {\n                       logic        TEST1;\n                       logic        RME;\n                       logic [3:0]  RM;\n                       logic        LS;\n                       logic        DS;\n                       logic        SD;\n                       logic        TEST_RNM;\n                       logic        BC1;\n                       logic        BC2;\n                      } el2_ic_data_ext_in_pkt_t;\n\n\ntypedef struct packed {\n                       logic        TEST1;\n                       logic        RME;\n                       logic [3:0]  RM;\n                       logic        LS;\n                       logic        DS;\n                       logic        SD;\n                       logic        TEST_RNM;\n                       logic        BC1;\n                       logic        BC2;\n                      } el2_ic_tag_ext_in_pkt_t;\n\n\n\ntypedef struct packed {\n                        logic        select;\n                        logic        match;\n                        logic        store;\n                        logic        load;\n                        logic        execute;\n                        logic        m;\n                        logic [31:0] tdata2;\n            } el2_trigger_pkt_t;\n\n\ntypedef struct packed {\n                        logic [70:0]  icache_wrdata; // {dicad1[1:0], dicad0h[31:0], dicad0[31:0]}\n                        logic [16:0]  icache_dicawics; // Arraysel:24, Waysel:21:20, Index:16:3\n                        logic         icache_rd_valid;\n                        logic         icache_wr_valid;\n            } el2_cache_debug_pkt_t;\n\n\n  typedef enum logic [2:0] {\n    NONE  = 3'b000,\n    READ  = 3'b001,\n    WRITE = 3'b010,\n    EXEC  = 3'b100\n  } el2_pmp_type_pkt_t;\n\n\n  typedef enum logic [1:0] {\n    OFF   = 2'b00,\n    TOR   = 2'b01,\n    NA4   = 2'b10,\n    NAPOT = 2'b11\n  } el2_pmp_mode_pkt_t;\n\n\n  typedef struct packed {\n    logic lock;\n    logic [1:0] reserved;\n    el2_pmp_mode_pkt_t mode;\n    logic execute;\n    logic write;\n    logic read;\n  } el2_pmp_cfg_pkt_t;\n//`endif\n\nendpackage // el2_pkg\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n// Function: Top level VeeR core file\n// Comments:\n//\n//********************************************************************************\n\nmodule el2_dma_ctrl \nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n   input logic         clk,\n   input logic         free_clk,\n   input logic         rst_l,\n   input logic         dma_bus_clk_en, // slave bus clock enable\n   input logic         clk_override,\n   input logic         scan_mode,\n\n   // Debug signals\n   input logic [31:0]  dbg_cmd_addr,\n   input logic [31:0]  dbg_cmd_wrdata,\n   input logic         dbg_cmd_valid,\n   input logic         dbg_cmd_write, // 1: write command, 0: read_command\n   input logic [1:0]   dbg_cmd_type, // 0:gpr 1:csr 2: memory\n   input logic [1:0]   dbg_cmd_size, // size of the abstract mem access debug command\n\n   input  logic        dbg_dma_bubble,   // Debug needs a bubble to send a valid\n   output logic        dma_dbg_ready,    // DMA is ready to accept debug request\n\n   output logic        dma_dbg_cmd_done,\n   output logic        dma_dbg_cmd_fail,\n   output logic [31:0] dma_dbg_rddata,\n\n   // Core side signals\n   output logic        dma_dccm_req,  // DMA dccm request (only one of dccm/iccm will be set)\n   output logic        dma_iccm_req,  // DMA iccm request\n   output logic [2:0]  dma_mem_tag,   // DMA Buffer entry number\n   output logic [31:0] dma_mem_addr,  // DMA request address\n   output logic [2:0]  dma_mem_sz,    // DMA request size\n   output logic        dma_mem_write, // DMA write to dccm/iccm\n   output logic [63:0] dma_mem_wdata, // DMA write data\n\n   input logic         dccm_dma_rvalid,    // dccm data valid for DMA read\n   input logic         dccm_dma_ecc_error, // ECC error on DMA read\n   input logic [2:0]   dccm_dma_rtag,      // Tag of the DMA req\n   input logic [63:0]  dccm_dma_rdata,     // dccm data for DMA read\n   input logic         iccm_dma_rvalid,    // iccm data valid for DMA read\n   input logic         iccm_dma_ecc_error, // ECC error on DMA read\n   input logic [2:0]   iccm_dma_rtag,      // Tag of the DMA req\n   input logic [63:0]  iccm_dma_rdata,     // iccm data for DMA read\n\n   output logic        dma_active,         // DMA is busy\n   output logic        dma_dccm_stall_any, // stall dccm pipe (bubble) so that DMA can proceed\n   output logic        dma_iccm_stall_any, // stall iccm pipe (bubble) so that DMA can proceed\n   input logic         dccm_ready, // dccm ready to accept DMA request\n   input logic         iccm_ready, // iccm ready to accept DMA request\n   input logic [2:0]   dec_tlu_dma_qos_prty,    // DMA QoS priority coming from MFDC [18:15]\n\n   // PMU signals\n   output logic        dma_pmu_dccm_read,\n   output logic        dma_pmu_dccm_write,\n   output logic        dma_pmu_any_read,\n   output logic        dma_pmu_any_write,\n\n   // AXI Write Channels\n   input  logic                        dma_axi_awvalid,\n   output logic                        dma_axi_awready,\n   input  logic [pt.DMA_BUS_TAG-1:0]   dma_axi_awid,\n   input  logic [31:0]                 dma_axi_awaddr,\n   input  logic [2:0]                  dma_axi_awsize,\n\n\n   input  logic                        dma_axi_wvalid,\n   output logic                        dma_axi_wready,\n   input  logic [63:0]                 dma_axi_wdata,\n   input  logic [7:0]                  dma_axi_wstrb,\n\n   output logic                        dma_axi_bvalid,\n   input  logic                        dma_axi_bready,\n   output logic [1:0]                  dma_axi_bresp,\n   output logic [pt.DMA_BUS_TAG-1:0]   dma_axi_bid,\n\n   // AXI Read Channels\n   input  logic                        dma_axi_arvalid,\n   output logic                        dma_axi_arready,\n   input  logic [pt.DMA_BUS_TAG-1:0]   dma_axi_arid,\n   input  logic [31:0]                 dma_axi_araddr,\n   input  logic [2:0]                  dma_axi_arsize,\n\n   output logic                        dma_axi_rvalid,\n   input  logic                        dma_axi_rready,\n   output logic [pt.DMA_BUS_TAG-1:0]   dma_axi_rid,\n   output logic [63:0]                 dma_axi_rdata,\n   output logic [1:0]                  dma_axi_rresp,\n   output logic                        dma_axi_rlast\n);\n\n\n   localparam DEPTH = pt.DMA_BUF_DEPTH;\n   localparam DEPTH_PTR = $clog2(DEPTH);\n   localparam NACK_COUNT = 7;\n\n   logic [DEPTH-1:0]        fifo_valid;\n   logic [DEPTH-1:0][1:0]   fifo_error;\n   logic [DEPTH-1:0]        fifo_error_bus;\n   logic [DEPTH-1:0]        fifo_rpend;\n   logic [DEPTH-1:0]        fifo_done;      // DMA trxn is done in core\n   logic [DEPTH-1:0]        fifo_done_bus;  // DMA trxn is done in core but synced to bus clock\n   logic [DEPTH-1:0][31:0]  fifo_addr;\n   logic [DEPTH-1:0][2:0]   fifo_sz;\n   logic [DEPTH-1:0][7:0]   fifo_byteen;\n   logic [DEPTH-1:0]        fifo_write;\n   logic [DEPTH-1:0]        fifo_posted_write;\n   logic [DEPTH-1:0]        fifo_dbg;\n   logic [DEPTH-1:0][63:0]  fifo_data;\n   logic [DEPTH-1:0][pt.DMA_BUS_TAG-1:0]  fifo_tag;\n   logic [DEPTH-1:0][pt.DMA_BUS_ID-1:0]   fifo_mid;\n   logic [DEPTH-1:0][pt.DMA_BUS_PRTY-1:0] fifo_prty;\n\n   logic [DEPTH-1:0]        fifo_cmd_en;\n   logic [DEPTH-1:0]        fifo_data_en;\n   logic [DEPTH-1:0]        fifo_pend_en;\n   logic [DEPTH-1:0]        fifo_done_en;\n   logic [DEPTH-1:0]        fifo_done_bus_en;\n   logic [DEPTH-1:0]        fifo_error_en;\n   logic [DEPTH-1:0]        fifo_error_bus_en;\n   logic [DEPTH-1:0]        fifo_reset;\n   logic [DEPTH-1:0][1:0]   fifo_error_in;\n   logic [DEPTH-1:0][63:0]  fifo_data_in;\n\n   logic                    fifo_write_in;\n   logic                    fifo_posted_write_in;\n   logic                    fifo_dbg_in;\n   logic [31:0]             fifo_addr_in;\n   logic [2:0]              fifo_sz_in;\n   logic [7:0]              fifo_byteen_in;\n\n   logic [DEPTH_PTR-1:0]    RspPtr, NxtRspPtr;\n   logic [DEPTH_PTR-1:0]    WrPtr, NxtWrPtr;\n   logic [DEPTH_PTR-1:0]    RdPtr, NxtRdPtr;\n   logic                    WrPtrEn, RdPtrEn, RspPtrEn;\n\n   logic [1:0]              dma_dbg_sz;\n   logic [1:0]              dma_dbg_addr;\n   logic [31:0]             dma_dbg_mem_rddata;\n   logic [31:0]             dma_dbg_mem_wrdata;\n   logic                    dma_dbg_cmd_error;\n   logic                    dma_dbg_cmd_done_q;\n\n   logic                    fifo_full, fifo_full_spec, fifo_empty;\n   logic                    dma_address_error, dma_alignment_error;\n   logic [3:0]              num_fifo_vld;\n   logic                    dma_mem_req;\n   logic [31:0]             dma_mem_addr_int;\n   logic [2:0]              dma_mem_sz_int;\n   logic [7:0]              dma_mem_byteen;\n   logic                    dma_mem_addr_in_dccm;\n   logic                    dma_mem_addr_in_iccm;\n   logic                    dma_mem_addr_in_pic;\n   logic                    dma_mem_addr_in_pic_region_nc;\n   logic                    dma_mem_addr_in_dccm_region_nc;\n   logic                    dma_mem_addr_in_iccm_region_nc;\n\n   logic [2:0]              dma_nack_count, dma_nack_count_d, dma_nack_count_csr;\n\n   logic                    dma_buffer_c1_clken;\n   logic                    dma_free_clken;\n   logic                    dma_buffer_c1_clk;\n   logic                    dma_free_clk;\n   logic                    dma_bus_clk;\n\n   logic                    bus_rsp_valid, bus_rsp_sent;\n   logic                    bus_cmd_valid, bus_cmd_sent;\n   logic                    bus_cmd_write, bus_cmd_posted_write;\n   logic [7:0]              bus_cmd_byteen;\n   logic [2:0]              bus_cmd_sz;\n   logic [31:0]             bus_cmd_addr;\n   logic [63:0]             bus_cmd_wdata;\n   logic [pt.DMA_BUS_TAG-1:0]  bus_cmd_tag;\n   logic [pt.DMA_BUS_ID-1:0]   bus_cmd_mid;\n   logic [pt.DMA_BUS_PRTY-1:0] bus_cmd_prty;\n   logic                    bus_posted_write_done;\n\n   logic                    fifo_full_spec_bus;\n   logic                    dbg_dma_bubble_bus;\n   logic                    stall_dma_in;\n   logic                    dma_fifo_ready;\n\n   logic                       wrbuf_en, wrbuf_data_en;\n   logic                       wrbuf_cmd_sent, wrbuf_rst, wrbuf_data_rst;\n   logic                       wrbuf_vld, wrbuf_data_vld;\n   logic [pt.DMA_BUS_TAG-1:0]  wrbuf_tag;\n   logic [2:0]                 wrbuf_sz;\n   logic [31:0]                wrbuf_addr;\n   logic [63:0]                wrbuf_data;\n   logic [7:0]                 wrbuf_byteen;\n\n   logic                       rdbuf_en;\n   logic                       rdbuf_cmd_sent, rdbuf_rst;\n   logic                       rdbuf_vld;\n   logic [pt.DMA_BUS_TAG-1:0]  rdbuf_tag;\n   logic [2:0]                 rdbuf_sz;\n   logic [31:0]                rdbuf_addr;\n\n   logic                       axi_mstr_prty_in, axi_mstr_prty_en;\n   logic                       axi_mstr_priority;\n   logic                       axi_mstr_sel;\n\n   logic                       axi_rsp_valid, axi_rsp_sent;\n   logic                       axi_rsp_write;\n   logic [pt.DMA_BUS_TAG-1:0]  axi_rsp_tag;\n   logic [1:0]                 axi_rsp_error;\n   logic [63:0]                axi_rsp_rdata;\n\n   //------------------------LOGIC STARTS HERE---------------------------------\n\n   // FIFO inputs\n   assign fifo_addr_in[31:0]    = dbg_cmd_valid ? dbg_cmd_addr[31:0] : bus_cmd_addr[31:0];\n   assign fifo_byteen_in[7:0]   = {8{~dbg_cmd_valid}} & bus_cmd_byteen[7:0];    // Byte enable is used only for bus requests\n   assign fifo_sz_in[2:0]       = dbg_cmd_valid ? {1'b0,dbg_cmd_size[1:0]} : bus_cmd_sz[2:0];\n   assign fifo_write_in         = dbg_cmd_valid ? dbg_cmd_write : bus_cmd_write;\n   assign fifo_posted_write_in  = ~dbg_cmd_valid & bus_cmd_posted_write;\n   assign fifo_dbg_in           = dbg_cmd_valid;\n\n   for (genvar i=0 ;i<DEPTH; i++) begin: GenFifo\n      assign fifo_cmd_en[i]   = ((bus_cmd_sent & dma_bus_clk_en) | (dbg_cmd_valid & dbg_cmd_type[1])) & (i == WrPtr[DEPTH_PTR-1:0]);\n      assign fifo_data_en[i] = (((bus_cmd_sent & fifo_write_in & dma_bus_clk_en) | (dbg_cmd_valid & dbg_cmd_type[1] & dbg_cmd_write))  & (i == WrPtr[DEPTH_PTR-1:0])) |\n                               ((dma_address_error | dma_alignment_error) & (i == RdPtr[DEPTH_PTR-1:0])) |\n                               (dccm_dma_rvalid & (i == DEPTH_PTR'(dccm_dma_rtag[2:0]))) |\n                               (iccm_dma_rvalid & (i == DEPTH_PTR'(iccm_dma_rtag[2:0])));\n      assign fifo_pend_en[i] = (dma_dccm_req | dma_iccm_req) & ~dma_mem_write & (i == RdPtr[DEPTH_PTR-1:0]);\n      assign fifo_error_en[i] = ((dma_address_error | dma_alignment_error | dma_dbg_cmd_error) & (i == RdPtr[DEPTH_PTR-1:0])) |\n                                ((dccm_dma_rvalid & dccm_dma_ecc_error) & (i == DEPTH_PTR'(dccm_dma_rtag[2:0]))) |\n                                ((iccm_dma_rvalid & iccm_dma_ecc_error) & (i == DEPTH_PTR'(iccm_dma_rtag[2:0])));\n      assign fifo_error_bus_en[i] = (((|fifo_error_in[i][1:0]) & fifo_error_en[i]) | (|fifo_error[i])) & dma_bus_clk_en;\n      assign fifo_done_en[i] = ((|fifo_error[i] | fifo_error_en[i] | ((dma_dccm_req | dma_iccm_req) & dma_mem_write)) & (i == RdPtr[DEPTH_PTR-1:0])) |\n                               (dccm_dma_rvalid & (i == DEPTH_PTR'(dccm_dma_rtag[2:0]))) |\n                               (iccm_dma_rvalid & (i == DEPTH_PTR'(iccm_dma_rtag[2:0])));\n      assign fifo_done_bus_en[i] = (fifo_done_en[i] | fifo_done[i]) & dma_bus_clk_en;\n      assign fifo_reset[i] = (((bus_rsp_sent | bus_posted_write_done) & dma_bus_clk_en) | dma_dbg_cmd_done) & (i == RspPtr[DEPTH_PTR-1:0]);\n      assign fifo_error_in[i]   = (dccm_dma_rvalid & (i == DEPTH_PTR'(dccm_dma_rtag[2:0]))) ? {1'b0,dccm_dma_ecc_error} : (iccm_dma_rvalid & (i == DEPTH_PTR'(iccm_dma_rtag[2:0]))) ? {1'b0,iccm_dma_ecc_error}  :\n                                                                                                                {(dma_address_error | dma_alignment_error | dma_dbg_cmd_error), dma_alignment_error};\n      assign fifo_data_in[i]   = (fifo_error_en[i] & (|fifo_error_in[i])) ? {32'b0,fifo_addr[i]} :\n                                                        ((dccm_dma_rvalid & (i == DEPTH_PTR'(dccm_dma_rtag[2:0])))  ? dccm_dma_rdata[63:0] : (iccm_dma_rvalid & (i == DEPTH_PTR'(iccm_dma_rtag[2:0]))) ? iccm_dma_rdata[63:0] :\n                                                                                                                                                       (dbg_cmd_valid ? {2{dma_dbg_mem_wrdata[31:0]}} : bus_cmd_wdata[63:0]));\n\n      rvdffsc #(1) fifo_valid_dff (.din(1'b1), .dout(fifo_valid[i]), .en(fifo_cmd_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n      rvdffsc #(2) fifo_error_dff (.din(fifo_error_in[i]), .dout(fifo_error[i]), .en(fifo_error_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n      rvdffsc #(1) fifo_error_bus_dff (.din(1'b1), .dout(fifo_error_bus[i]), .en(fifo_error_bus_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n      rvdffsc #(1) fifo_rpend_dff (.din(1'b1), .dout(fifo_rpend[i]), .en(fifo_pend_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n      rvdffsc #(1) fifo_done_dff (.din(1'b1), .dout(fifo_done[i]), .en(fifo_done_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n      rvdffsc #(1) fifo_done_bus_dff (.din(1'b1), .dout(fifo_done_bus[i]), .en(fifo_done_bus_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n      rvdffe  #(32) fifo_addr_dff (.din(fifo_addr_in[31:0]), .dout(fifo_addr[i]), .en(fifo_cmd_en[i]), .*);\n      rvdffs  #(3) fifo_sz_dff (.din(fifo_sz_in[2:0]), .dout(fifo_sz[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffs  #(8) fifo_byteen_dff (.din(fifo_byteen_in[7:0]), .dout(fifo_byteen[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffs  #(1) fifo_write_dff (.din(fifo_write_in), .dout(fifo_write[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffs  #(1) fifo_posted_write_dff (.din(fifo_posted_write_in), .dout(fifo_posted_write[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffs  #(1) fifo_dbg_dff (.din(fifo_dbg_in), .dout(fifo_dbg[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffe  #(64) fifo_data_dff (.din(fifo_data_in[i]), .dout(fifo_data[i]), .en(fifo_data_en[i]), .*);\n      rvdffs  #(pt.DMA_BUS_TAG) fifo_tag_dff(.din(bus_cmd_tag[pt.DMA_BUS_TAG-1:0]), .dout(fifo_tag[i][pt.DMA_BUS_TAG-1:0]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffs  #(pt.DMA_BUS_ID) fifo_mid_dff(.din(bus_cmd_mid[pt.DMA_BUS_ID-1:0]), .dout(fifo_mid[i][pt.DMA_BUS_ID-1:0]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffs  #(pt.DMA_BUS_PRTY) fifo_prty_dff(.din(bus_cmd_prty[pt.DMA_BUS_PRTY-1:0]), .dout(fifo_prty[i][pt.DMA_BUS_PRTY-1:0]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n   end\n\n   // Pointer logic\n   assign NxtWrPtr[DEPTH_PTR-1:0] = (WrPtr[DEPTH_PTR-1:0] == (DEPTH-1)) ? '0 : WrPtr[DEPTH_PTR-1:0] + 1'b1;\n   assign NxtRdPtr[DEPTH_PTR-1:0] = (RdPtr[DEPTH_PTR-1:0] == (DEPTH-1)) ? '0 : RdPtr[DEPTH_PTR-1:0] + 1'b1;\n   assign NxtRspPtr[DEPTH_PTR-1:0] = (RspPtr[DEPTH_PTR-1:0] == (DEPTH-1)) ? '0 : RspPtr[DEPTH_PTR-1:0] + 1'b1;\n\n   assign WrPtrEn = |fifo_cmd_en[DEPTH-1:0];\n   assign RdPtrEn = dma_dccm_req | dma_iccm_req | (dma_address_error | dma_alignment_error | dma_dbg_cmd_error);\n   assign RspPtrEn = (dma_dbg_cmd_done | (bus_rsp_sent | bus_posted_write_done) & dma_bus_clk_en);\n\n   rvdffs #(DEPTH_PTR) WrPtr_dff(.din(NxtWrPtr[DEPTH_PTR-1:0]), .dout(WrPtr[DEPTH_PTR-1:0]), .en(WrPtrEn), .clk(dma_free_clk), .*);\n   rvdffs #(DEPTH_PTR) RdPtr_dff(.din(NxtRdPtr[DEPTH_PTR-1:0]), .dout(RdPtr[DEPTH_PTR-1:0]), .en(RdPtrEn), .clk(dma_free_clk), .*);\n   rvdffs #(DEPTH_PTR) RspPtr_dff(.din(NxtRspPtr[DEPTH_PTR-1:0]), .dout(RspPtr[DEPTH_PTR-1:0]), .en(RspPtrEn), .clk(dma_free_clk), .*);\n\n   // Miscellaneous signals\n   assign fifo_full = fifo_full_spec_bus;\n\n   always_comb begin\n      num_fifo_vld[3:0] = {3'b0,bus_cmd_sent} - {3'b0,bus_rsp_sent};\n      for (int i=0; i<DEPTH; i++) begin\n         num_fifo_vld[3:0] += {3'b0,fifo_valid[i]};\n      end\n   end\n   assign fifo_full_spec          = (num_fifo_vld[3:0] >= DEPTH);\n\n   assign dma_fifo_ready = ~(fifo_full | dbg_dma_bubble_bus);\n\n   // Error logic\n   assign dma_address_error = fifo_valid[RdPtr] & ~fifo_done[RdPtr] & ~fifo_dbg[RdPtr] & (~(dma_mem_addr_in_dccm | dma_mem_addr_in_iccm));    // request not for ICCM or DCCM\n   assign dma_alignment_error = fifo_valid[RdPtr] & ~fifo_done[RdPtr] & ~fifo_dbg[RdPtr] & ~dma_address_error &\n                                (((dma_mem_sz_int[2:0] == 3'h1) & dma_mem_addr_int[0])                                                       |    // HW size but unaligned\n                                 ((dma_mem_sz_int[2:0] == 3'h2) & (|dma_mem_addr_int[1:0]))                                                  |    // W size but unaligned\n                                 ((dma_mem_sz_int[2:0] == 3'h3) & (|dma_mem_addr_int[2:0]))                                                  |    // DW size but unaligned\n                                 (dma_mem_addr_in_iccm & ~((dma_mem_sz_int[1:0] == 2'b10) | (dma_mem_sz_int[1:0] == 2'b11)))                 |    // ICCM access not word size\n                                 (dma_mem_addr_in_dccm & dma_mem_write & ~((dma_mem_sz_int[1:0] == 2'b10) | (dma_mem_sz_int[1:0] == 2'b11))) |    // DCCM write not word size\n                                 (dma_mem_write & (dma_mem_sz_int[2:0] == 3'h2) & (dma_mem_byteen[dma_mem_addr_int[2:0]+:4] != 4'hf))        |    // Write byte enables not aligned for word store\n                                 (dma_mem_write & (dma_mem_sz_int[2:0] == 3'h3) & ~((dma_mem_byteen[7:0] == 8'h0f) | (dma_mem_byteen[7:0] == 8'hf0) | (dma_mem_byteen[7:0] == 8'hff)))); // Write byte enables not aligned for dword store\n\n\n   //Dbg outputs\n   assign dma_dbg_ready    = fifo_empty & dbg_dma_bubble;\n   assign dma_dbg_cmd_done = (fifo_valid[RspPtr] & fifo_dbg[RspPtr] & fifo_done[RspPtr]);\n   assign dma_dbg_cmd_fail     = (|fifo_error[RspPtr] & dma_dbg_cmd_done) ;\n\n   assign dma_dbg_sz[1:0]          = fifo_sz[RspPtr][1:0];\n   assign dma_dbg_addr[1:0]        = fifo_addr[RspPtr][1:0];\n   assign dma_dbg_mem_rddata[31:0] = fifo_addr[RspPtr][2] ? fifo_data[RspPtr][63:32] : fifo_data[RspPtr][31:0];\n   assign dma_dbg_rddata[31:0]     = ({32{(dma_dbg_sz[1:0] == 2'h0)}} & ((dma_dbg_mem_rddata[31:0] >> 8*dma_dbg_addr[1:0]) & 32'hff)) |\n                                     ({32{(dma_dbg_sz[1:0] == 2'h1)}} & ((dma_dbg_mem_rddata[31:0] >> 16*dma_dbg_addr[1]) & 32'hffff)) |\n                                     ({32{(dma_dbg_sz[1:0] == 2'h2)}} & dma_dbg_mem_rddata[31:0]);\n\n   assign dma_dbg_cmd_error = fifo_valid[RdPtr] & ~fifo_done[RdPtr] & fifo_dbg[RdPtr] &\n                                 ((~(dma_mem_addr_in_dccm | dma_mem_addr_in_iccm | dma_mem_addr_in_pic)) |             // Address outside of ICCM/DCCM/PIC\n                                  ((dma_mem_addr_in_iccm | dma_mem_addr_in_pic) & (dma_mem_sz_int[1:0] != 2'b10)));    // Only word accesses allowed for ICCM/PIC\n\n   assign dma_dbg_mem_wrdata[31:0] = ({32{dbg_cmd_size[1:0] == 2'h0}} & {4{dbg_cmd_wrdata[7:0]}}) |\n                                     ({32{dbg_cmd_size[1:0] == 2'h1}} & {2{dbg_cmd_wrdata[15:0]}}) |\n                                     ({32{dbg_cmd_size[1:0] == 2'h2}} & dbg_cmd_wrdata[31:0]);\n\n   // Block the decode if fifo full\n   assign dma_dccm_stall_any = dma_mem_req & (dma"}
{"text": "_mem_addr_in_dccm | dma_mem_addr_in_pic) & (dma_nack_count >= dma_nack_count_csr);\n   assign dma_iccm_stall_any = dma_mem_req & dma_mem_addr_in_iccm & (dma_nack_count >= dma_nack_count_csr);\n\n   // Used to indicate ready to debug\n   assign fifo_empty     = ~((|(fifo_valid[DEPTH-1:0])) | bus_cmd_sent);\n\n   // Nack counter, stall the lsu pipe if 7 nacks\n   assign dma_nack_count_csr[2:0] = dec_tlu_dma_qos_prty[2:0];\n   assign dma_nack_count_d[2:0] = (dma_nack_count[2:0] >= dma_nack_count_csr[2:0]) ? ({3{~(dma_dccm_req | dma_iccm_req)}} & dma_nack_count[2:0]) :\n                                                                                    (dma_mem_req & ~(dma_dccm_req | dma_iccm_req)) ? (dma_nack_count[2:0] + 1'b1) : 3'b0;\n\n   rvdffs #(3) nack_count_dff(.din(dma_nack_count_d[2:0]), .dout(dma_nack_count[2:0]), .en(dma_mem_req), .clk(dma_free_clk), .*);\n\n   // Core outputs\n   assign dma_mem_req         = fifo_valid[RdPtr] & ~fifo_rpend[RdPtr] & ~fifo_done[RdPtr] & ~(dma_address_error | dma_alignment_error | dma_dbg_cmd_error);\n   assign dma_dccm_req        = dma_mem_req & (dma_mem_addr_in_dccm | dma_mem_addr_in_pic) & dccm_ready;\n   assign dma_iccm_req        = dma_mem_req & dma_mem_addr_in_iccm & iccm_ready;\n   assign dma_mem_tag[2:0]    = 3'(RdPtr);\n   assign dma_mem_addr_int[31:0] = fifo_addr[RdPtr];\n   assign dma_mem_sz_int[2:0] = fifo_sz[RdPtr];\n   assign dma_mem_addr[31:0]  = (dma_mem_write & ~fifo_dbg[RdPtr] & (dma_mem_byteen[7:0] == 8'hf0)) ? {dma_mem_addr_int[31:3],1'b1,dma_mem_addr_int[1:0]} : dma_mem_addr_int[31:0];\n   assign dma_mem_sz[2:0]     = (dma_mem_write & ~fifo_dbg[RdPtr] & ((dma_mem_byteen[7:0] == 8'h0f) | (dma_mem_byteen[7:0] == 8'hf0))) ? 3'h2 : dma_mem_sz_int[2:0];\n   assign dma_mem_byteen[7:0] = fifo_byteen[RdPtr];\n   assign dma_mem_write       = fifo_write[RdPtr];\n   assign dma_mem_wdata[63:0] = fifo_data[RdPtr];\n\n   // PMU outputs\n   assign dma_pmu_dccm_read   = dma_dccm_req & ~dma_mem_write;\n   assign dma_pmu_dccm_write  = dma_dccm_req & dma_mem_write;\n   assign dma_pmu_any_read    = (dma_dccm_req | dma_iccm_req) & ~dma_mem_write;\n   assign dma_pmu_any_write   = (dma_dccm_req | dma_iccm_req) & dma_mem_write;\n\n   // Address check  dccm\n   if (pt.DCCM_ENABLE) begin: Gen_dccm_enable\n      rvrangecheck #(.CCM_SADR(pt.DCCM_SADR),\n                     .CCM_SIZE(pt.DCCM_SIZE)) addr_dccm_rangecheck (\n         .addr(dma_mem_addr_int[31:0]),\n         .in_range(dma_mem_addr_in_dccm),\n         .in_region(dma_mem_addr_in_dccm_region_nc)\n      );\n   end else begin: Gen_dccm_disable\n      assign dma_mem_addr_in_dccm = '0;\n      assign dma_mem_addr_in_dccm_region_nc = '0;\n   end // else: !if(pt.ICCM_ENABLE)\n\n   // Address check  iccm\n   if (pt.ICCM_ENABLE) begin: Gen_iccm_enable\n      rvrangecheck #(.CCM_SADR(pt.ICCM_SADR),\n                     .CCM_SIZE(pt.ICCM_SIZE)) addr_iccm_rangecheck (\n         .addr(dma_mem_addr_int[31:0]),\n         .in_range(dma_mem_addr_in_iccm),\n         .in_region(dma_mem_addr_in_iccm_region_nc)\n      );\n   end else begin: Gen_iccm_disable\n      assign dma_mem_addr_in_iccm = '0;\n      assign dma_mem_addr_in_iccm_region_nc = '0;\n   end // else: !if(pt.ICCM_ENABLE)\n\n\n   // PIC memory address check\n   rvrangecheck #(.CCM_SADR(pt.PIC_BASE_ADDR),\n                  .CCM_SIZE(pt.PIC_SIZE)) addr_pic_rangecheck (\n      .addr(dma_mem_addr_int[31:0]),\n      .in_range(dma_mem_addr_in_pic),\n      .in_region(dma_mem_addr_in_pic_region_nc)\n    );\n\n   // Inputs\n   rvdff_fpga #(1) fifo_full_bus_ff     (.din(fifo_full_spec),   .dout(fifo_full_spec_bus), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdff_fpga #(1) dbg_dma_bubble_ff    (.din(dbg_dma_bubble),   .dout(dbg_dma_bubble_bus), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdff      #(1) dma_dbg_cmd_doneff   (.din(dma_dbg_cmd_done), .dout(dma_dbg_cmd_done_q), .clk(free_clk), .*);\n\n   // Clock Gating logic\n   assign dma_buffer_c1_clken = (bus_cmd_valid & dma_bus_clk_en) | dbg_cmd_valid | clk_override;\n   assign dma_free_clken = (bus_cmd_valid | bus_rsp_valid | dbg_cmd_valid | dma_dbg_cmd_done | dma_dbg_cmd_done_q | (|fifo_valid[DEPTH-1:0]) | clk_override);\n\n   rvoclkhdr dma_buffer_c1cgc ( .en(dma_buffer_c1_clken), .l1clk(dma_buffer_c1_clk), .* );\n   rvoclkhdr dma_free_cgc (.en(dma_free_clken), .l1clk(dma_free_clk), .*);\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign dma_bus_clk = 1'b0;\n`else\n   rvclkhdr  dma_bus_cgc (.en(dma_bus_clk_en), .l1clk(dma_bus_clk), .*);\n`endif\n\n   // Write channel buffer\n   assign wrbuf_en       = dma_axi_awvalid & dma_axi_awready;\n   assign wrbuf_data_en  = dma_axi_wvalid & dma_axi_wready;\n   assign wrbuf_cmd_sent = bus_cmd_sent & bus_cmd_write;\n   assign wrbuf_rst      = wrbuf_cmd_sent & ~wrbuf_en;\n   assign wrbuf_data_rst = wrbuf_cmd_sent & ~wrbuf_data_en;\n\n   rvdffsc_fpga  #(.WIDTH(1))              wrbuf_vldff       (.din(1'b1), .dout(wrbuf_vld),      .en(wrbuf_en),      .clear(wrbuf_rst),      .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffsc_fpga  #(.WIDTH(1))              wrbuf_data_vldff  (.din(1'b1), .dout(wrbuf_data_vld), .en(wrbuf_data_en), .clear(wrbuf_data_rst), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga   #(.WIDTH(pt.DMA_BUS_TAG)) wrbuf_tagff       (.din(dma_axi_awid[pt.DMA_BUS_TAG-1:0]), .dout(wrbuf_tag[pt.DMA_BUS_TAG-1:0]), .en(wrbuf_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga   #(.WIDTH(3))              wrbuf_szff        (.din(dma_axi_awsize[2:0]),  .dout(wrbuf_sz[2:0]),     .en(wrbuf_en),                  .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffe        #(.WIDTH(32))             wrbuf_addrff      (.din(dma_axi_awaddr[31:0]), .dout(wrbuf_addr[31:0]),  .en(wrbuf_en & dma_bus_clk_en), .*);\n   rvdffe        #(.WIDTH(64))             wrbuf_dataff      (.din(dma_axi_wdata[63:0]),  .dout(wrbuf_data[63:0]),  .en(wrbuf_data_en & dma_bus_clk_en), .*);\n   rvdffs_fpga   #(.WIDTH(8))              wrbuf_byteenff    (.din(dma_axi_wstrb[7:0]),   .dout(wrbuf_byteen[7:0]), .en(wrbuf_data_en),             .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n\n   // Read channel buffer\n   assign rdbuf_en    = dma_axi_arvalid & dma_axi_arready;\n   assign rdbuf_cmd_sent = bus_cmd_sent & ~bus_cmd_write;\n   assign rdbuf_rst   = rdbuf_cmd_sent & ~rdbuf_en;\n\n   rvdffsc_fpga  #(.WIDTH(1))              rdbuf_vldff  (.din(1'b1), .dout(rdbuf_vld), .en(rdbuf_en), .clear(rdbuf_rst), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga   #(.WIDTH(pt.DMA_BUS_TAG)) rdbuf_tagff  (.din(dma_axi_arid[pt.DMA_BUS_TAG-1:0]), .dout(rdbuf_tag[pt.DMA_BUS_TAG-1:0]), .en(rdbuf_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga   #(.WIDTH(3))              rdbuf_szff   (.din(dma_axi_arsize[2:0]),  .dout(rdbuf_sz[2:0]),    .en(rdbuf_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffe       #(.WIDTH(32))              rdbuf_addrff (.din(dma_axi_araddr[31:0]), .dout(rdbuf_addr[31:0]), .en(rdbuf_en & dma_bus_clk_en), .*);\n\n   assign dma_axi_awready = ~(wrbuf_vld & ~wrbuf_cmd_sent);\n   assign dma_axi_wready  = ~(wrbuf_data_vld & ~wrbuf_cmd_sent);\n   assign dma_axi_arready = ~(rdbuf_vld & ~rdbuf_cmd_sent);\n\n   //Generate a single request from read/write channel\n   assign bus_cmd_valid                     = (wrbuf_vld & wrbuf_data_vld) | rdbuf_vld;\n   assign bus_cmd_sent                      = bus_cmd_valid & dma_fifo_ready;\n   assign bus_cmd_write                     = axi_mstr_sel;\n   assign bus_cmd_posted_write              = '0;\n   assign bus_cmd_addr[31:0]                = axi_mstr_sel ? wrbuf_addr[31:0] : rdbuf_addr[31:0];\n   assign bus_cmd_sz[2:0]                   = axi_mstr_sel ? wrbuf_sz[2:0] : rdbuf_sz[2:0];\n   assign bus_cmd_wdata[63:0]               = wrbuf_data[63:0];\n   assign bus_cmd_byteen[7:0]               = wrbuf_byteen[7:0];\n   assign bus_cmd_tag[pt.DMA_BUS_TAG-1:0]   = axi_mstr_sel ? wrbuf_tag[pt.DMA_BUS_TAG-1:0] : rdbuf_tag[pt.DMA_BUS_TAG-1:0];\n   assign bus_cmd_mid[pt.DMA_BUS_ID-1:0]    = '0;\n   assign bus_cmd_prty[pt.DMA_BUS_PRTY-1:0] = '0;\n\n   // Sel=1 -> write has higher priority\n   assign axi_mstr_sel     = (wrbuf_vld & wrbuf_data_vld & rdbuf_vld) ? axi_mstr_priority : (wrbuf_vld & wrbuf_data_vld);\n   assign axi_mstr_prty_in = ~axi_mstr_priority;\n   assign axi_mstr_prty_en = bus_cmd_sent;\n   rvdffs_fpga #(.WIDTH(1)) mstr_prtyff(.din(axi_mstr_prty_in), .dout(axi_mstr_priority), .en(axi_mstr_prty_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n\n   assign axi_rsp_valid                   = fifo_valid[RspPtr] & ~fifo_dbg[RspPtr] & fifo_done_bus[RspPtr];\n   assign axi_rsp_rdata[63:0]             = fifo_data[RspPtr];\n   assign axi_rsp_write                   = fifo_write[RspPtr];\n   assign axi_rsp_error[1:0]              = fifo_error[RspPtr][0] ? 2'b10 : (fifo_error[RspPtr][1] ? 2'b11 : 2'b0);\n   assign axi_rsp_tag[pt.DMA_BUS_TAG-1:0] = fifo_tag[RspPtr];\n\n   // AXI response channel signals\n   assign dma_axi_bvalid                  = axi_rsp_valid & axi_rsp_write;\n   assign dma_axi_bresp[1:0]              = axi_rsp_error[1:0];\n   assign dma_axi_bid[pt.DMA_BUS_TAG-1:0] = axi_rsp_tag[pt.DMA_BUS_TAG-1:0];\n\n   assign dma_axi_rvalid                  = axi_rsp_valid & ~axi_rsp_write;\n   assign dma_axi_rresp[1:0]              = axi_rsp_error;\n   assign dma_axi_rdata[63:0]             = axi_rsp_rdata[63:0];\n   assign dma_axi_rlast                   = 1'b1;\n   assign dma_axi_rid[pt.DMA_BUS_TAG-1:0] = axi_rsp_tag[pt.DMA_BUS_TAG-1:0];\n\n   assign bus_posted_write_done = 1'b0;\n   assign bus_rsp_valid      = (dma_axi_bvalid | dma_axi_rvalid);\n   assign bus_rsp_sent       = (dma_axi_bvalid & dma_axi_bready) | (dma_axi_rvalid & dma_axi_rready);\n\n   assign dma_active  = wrbuf_vld | rdbuf_vld | (|fifo_valid[DEPTH-1:0]);\n\n\n`ifdef RV_ASSERT_ON\n\n   for (genvar i=0; i<DEPTH; i++) begin\n      assert_fifo_done_and_novalid: assert #0 (~fifo_done[i] | fifo_valid[i]);\n   end\n\n   // Assertion to check awvalid stays stable during entire bus clock\n   property dma_axi_awvalid_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_awvalid != $past(dma_axi_awvalid)) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_awvalid_stable: assert property (dma_axi_awvalid_stable) else\n      $display(\"DMA AXI awvalid changed in middle of bus clock\");\n\n   // Assertion to check awid stays stable during entire bus clock\n   property dma_axi_awid_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_awvalid & (dma_axi_awid[pt.DMA_BUS_TAG-1:0] != $past(dma_axi_awid[pt.DMA_BUS_TAG-1:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_awid_stable: assert property (dma_axi_awid_stable) else\n      $display(\"DMA AXI awid changed in middle of bus clock\");\n\n   // Assertion to check awaddr stays stable during entire bus clock\n   property dma_axi_awaddr_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_awvalid & (dma_axi_awaddr[31:0] != $past(dma_axi_awaddr[31:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_awaddr_stable: assert property (dma_axi_awaddr_stable) else\n      $display(\"DMA AXI awaddr changed in middle of bus clock\");\n\n   // Assertion to check awsize stays stable during entire bus clock\n   property dma_axi_awsize_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_awvalid & (dma_axi_awsize[2:0] != $past(dma_axi_awsize[2:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_awsize_stable: assert property (dma_axi_awsize_stable) else\n      $display(\"DMA AXI awsize changed in middle of bus clock\");\n\n   // Assertion to check wstrb stays stable during entire bus clock\n   property dma_axi_wstrb_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_wvalid & (dma_axi_wstrb[7:0] != $past(dma_axi_wstrb[7:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_wstrb_stable: assert property (dma_axi_wstrb_stable) else\n      $display(\"DMA AXI wstrb changed in middle of bus clock\");\n\n   // Assertion to check wdata stays stable during entire bus clock\n   property dma_axi_wdata_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_wvalid & (dma_axi_wdata[63:0] != $past(dma_axi_wdata[63:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_wdata_stable: assert property (dma_axi_wdata_stable) else\n      $display(\"DMA AXI wdata changed in middle of bus clock\");\n\n   // Assertion to check awvalid stays stable during entire bus clock\n   property dma_axi_arvalid_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_arvalid != $past(dma_axi_arvalid)) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_arvalid_stable: assert property (dma_axi_arvalid_stable) else\n      $display(\"DMA AXI awvalid changed in middle of bus clock\");\n\n   // Assertion to check awid stays stable during entire bus clock\n   property dma_axi_arid_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_arvalid & (dma_axi_arid[pt.DMA_BUS_TAG-1:0] != $past(dma_axi_arid[pt.DMA_BUS_TAG-1:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_arid_stable: assert property (dma_axi_arid_stable) else\n      $display(\"DMA AXI awid changed in middle of bus clock\");\n\n   // Assertion to check awaddr stays stable during entire bus clock\n   property dma_axi_araddr_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_arvalid & (dma_axi_araddr[31:0] != $past(dma_axi_araddr[31:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_araddr_stable: assert property (dma_axi_araddr_stable) else\n      $display(\"DMA AXI awaddr changed in middle of bus clock\");\n\n   // Assertion to check awsize stays stable during entire bus clock\n   property dma_axi_arsize_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_awvalid & (dma_axi_arsize[2:0] != $past(dma_axi_arsize[2:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_arsize_stable: assert property (dma_axi_arsize_stable) else\n      $display(\"DMA AXI awsize changed in middle of bus clock\");\n\n   // Assertion to check bvalid stays stable during entire bus clock\n   property dma_axi_bvalid_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_bvalid != $past(dma_axi_bvalid)) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_bvalid_stable: assert property (dma_axi_bvalid_stable) else\n      $display(\"DMA AXI bvalid changed in middle of bus clock\");\n\n   // Assertion to check bvalid stays stable if bready is low\n   property dma_axi_bvalid_stable_till_bready;\n      @(posedge clk) disable iff(~rst_l)  (~dma_axi_bvalid && $past(dma_axi_bvalid)) |-> $past(dma_axi_bready);\n   endproperty\n   assert_dma_axi_bvalid_stable_till_bready: assert property (dma_axi_bvalid_stable_till_bready) else\n      $display(\"DMA AXI bvalid deasserted without bready\");\n\n   // Assertion to check bresp stays stable during entire bus clock\n   property dma_axi_bresp_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_bvalid & (dma_axi_bresp[1:0] != $past(dma_axi_bresp[1:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_bresp_stable: assert property (dma_axi_bresp_stable) else\n      $display(\"DMA AXI bresp changed in middle of bus clock\");\n\n   // Assertion to check bid stays stable during entire bus clock\n   property dma_axi_bid_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_bvalid & (dma_axi_bid[pt.DMA_BUS_TAG-1:0] != $past(dma_axi_bid[pt.DMA_BUS_TAG-1:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_bid_stable: assert property (dma_axi_bid_stable) else\n      $display(\"DMA AXI bid changed in middle of bus clock\");\n\n   // Assertion to check rvalid stays stable during entire bus clock\n   property dma_axi_rvalid_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_rvalid != $past(dma_axi_rvalid)) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_rvalid_stable: assert property (dma_axi_rvalid_stable) else\n      $display(\"DMA AXI bvalid changed in middle of bus clock\");\n\n   // Assertion to check rvalid stays stable if bready is low\n   property dma_axi_rvalid_stable_till_ready;\n      @(posedge clk) disable iff(~rst_l)  (~dma_axi_rvalid && $past(dma_axi_rvalid)) |-> $past(dma_axi_rready);\n   endproperty\n   assert_dma_axi_rvalid_stable_till_ready: assert property (dma_axi_rvalid_stable_till_ready) else\n      $display(\"DMA AXI bvalid changed in middle of bus clock\");\n\n   // Assertion to check rresp stays stable during entire bus clock\n   property dma_axi_rresp_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_rvalid & (dma_axi_rresp[1:0] != $past(dma_axi_rresp[1:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_rresp_stable: assert property (dma_axi_rresp_stable) else\n      $display(\"DMA AXI bresp changed in middle of bus clock\");\n\n   // Assertion to check rid stays stable during entire bus clock\n   property dma_axi_rid_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_rvalid & (dma_axi_rid[pt.DMA_BUS_TAG-1:0] != $past(dma_axi_rid[pt.DMA_BUS_TAG-1:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_rid_stable: assert property (dma_axi_rid_stable) else\n      $display(\"DMA AXI bid changed in middle of bus clock\");\n\n   // Assertion to check rdata stays stable during entire bus clock\n   property dma_axi_rdata_stable;\n      @(posedge clk) disable iff(~rst_l)  (dma_axi_rvalid & (dma_axi_rdata[63:0] != $past(dma_axi_rdata[63:0]))) |-> $past(dma_bus_clk_en);\n   endproperty\n   assert_dma_axi_rdata_stable: assert property (dma_axi_rdata_stable) else\n      $display(\"DMA AXI bid changed in middle of bus clock\");\n\n`endif\n\nendmodule // el2_dma_ctrl\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nmodule el2_exu\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n)\n  (\n   input logic          clk,                                           // Top level clock\n   input logic          rst_l,                                         // Reset\n   input logic          scan_mode,                                     // Scan control\n\n   input logic  [1:0]   dec_data_en,                                   // Clock enable {x,r}, one cycle pulse\n   input logic  [1:0]   dec_ctl_en,                                    // Clock enable {x,r}, two cycle pulse\n   input logic  [31:0]  dbg_cmd_wrdata,                                // Debug data   to primary I0 RS1\n   input el2_alu_pkt_t i0_ap,                                         // DEC alu {valid,predecodes}\n\n   input logic          dec_debug_wdata_rs1_d,                         // Debug select to primary I0 RS1\n\n   input el2_predict_pkt_t dec_i0_predict_p_d,                        // DEC branch predict packet\n   input logic [pt.BHT_GHR_SIZE-1:0] i0_predict_fghr_d,                // DEC predict fghr\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i0_predict_index_d,     // DEC predict index\n   input logic [pt.BTB_BTAG_SIZE-1:0] i0_predict_btag_d,               // DEC predict branch tag\n\n   input logic  [31:0]  lsu_result_m,                                  // Load result M-stage\n   input logic  [31:0]  lsu_nonblock_load_data,                        // nonblock load data\n   input logic          dec_i0_rs1_en_d,                               // Qualify GPR RS1 data\n   input logic          dec_i0_rs2_en_d,                               // Qualify GPR RS2 data\n   input logic  [31:0]  gpr_i0_rs1_d,                                  // DEC data gpr\n   input logic  [31:0]  gpr_i0_rs2_d,                                  // DEC data gpr\n   input logic  [31:0]  dec_i0_immed_d,                                // DEC data immediate\n   input logic  [31:0]  dec_i0_result_r,                               // DEC result in R-stage\n   input logic  [12:1]  dec_i0_br_immed_d,                             // Branch immediate\n   input logic          dec_i0_alu_decode_d,                           // Valid to X-stage ALU\n   input logic          dec_i0_branch_d,                               // Branch in D-stage\n   input logic          dec_i0_select_pc_d,                            // PC select to RS1\n   input logic  [31:1]  dec_i0_pc_d,                                   // Instruction PC\n   input logic  [3:0]   dec_i0_rs1_bypass_en_d,                        // DEC bypass select  1 - X-stage, 0 - dec bypass data\n   input logic  [3:0]   dec_i0_rs2_bypass_en_d,                        // DEC bypass select  1 - X-stage, 0 - dec bypass data\n   input logic          dec_csr_ren_d,                                 // CSR read select\n   input logic  [31:0]  dec_csr_rddata_d,                              // CSR read data\n\n   input logic          dec_qual_lsu_d,                                // LSU instruction at D.  Use to quiet LSU operands\n   input el2_mul_pkt_t mul_p,                                         // DEC {valid, operand signs, low, operand bypass}\n   input el2_div_pkt_t div_p,                                         // DEC {valid, unsigned, rem}\n   input logic          dec_div_cancel,                                // Cancel the divide operation\n\n   input logic  [31:1]  pred_correct_npc_x,                            // DEC NPC for correctly predicted branch\n\n   input logic          dec_tlu_flush_lower_r,                         // Flush divide and secondary ALUs\n   input logic  [31:1]  dec_tlu_flush_path_r,                          // Redirect target\n\n\n   input logic         dec_extint_stall,                               // External stall mux select\n   input logic [31:2]  dec_tlu_meihap,                                 // External stall mux data\n\n\n   output logic [31:0]  exu_lsu_rs1_d,                                 // LSU operand\n   output logic [31:0]  exu_lsu_rs2_d,                                 // LSU operand\n\n   output logic         exu_flush_final,                               // Pipe is being flushed this cycle\n   output logic [31:1]  exu_flush_path_final,                          // Target for the oldest flush source\n\n   output logic [31:0]  exu_i0_result_x,                               // Primary ALU result to DEC\n   output logic [31:1]  exu_i0_pc_x,                                   // Primary PC  result to DEC\n   output logic [31:0]  exu_csr_rs1_x,                                 // RS1 source for a CSR instruction\n\n   output logic [31:1]  exu_npc_r,                                     // Divide NPC\n   output logic [1:0]   exu_i0_br_hist_r,                              // to DEC  I0 branch history\n   output logic         exu_i0_br_error_r,                             // to DEC  I0 branch error\n   output logic         exu_i0_br_start_error_r,                       // to DEC  I0 branch start error\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_i0_br_index_r,     // to DEC  I0 branch index\n   output logic         exu_i0_br_valid_r,                             // to DEC  I0 branch valid\n   output logic         exu_i0_br_mp_r,                                // to DEC  I0 branch mispredict\n   output logic         exu_i0_br_middle_r,                            // to DEC  I0 branch middle\n   output logic [pt.BHT_GHR_SIZE-1:0]  exu_i0_br_fghr_r,               // to DEC  I0 branch fghr\n   output logic         exu_i0_br_way_r,                               // to DEC  I0 branch way\n\n   output el2_predict_pkt_t exu_mp_pkt,                               // Mispredict branch packet\n   output logic [pt.BHT_GHR_SIZE-1:0]  exu_mp_eghr,                    // Mispredict global history\n   output logic [pt.BHT_GHR_SIZE-1:0]  exu_mp_fghr,                    // Mispredict fghr\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  exu_mp_index,         // Mispredict index\n   output logic [pt.BTB_BTAG_SIZE-1:0]  exu_mp_btag,                   // Mispredict btag\n\n\n   output logic         exu_pmu_i0_br_misp,                            // to PMU - I0 E4 branch mispredict\n   output logic         exu_pmu_i0_br_ataken,                          // to PMU - I0 E4 taken\n   output logic         exu_pmu_i0_pc4,                                // to PMU - I0 E4 PC\n\n\n   output logic [31:0]  exu_div_result,                                // Divide result\n   output logic         exu_div_wren                                   // Divide write enable to GPR\n  );\n\n\n\n\n   logic [31:0]                i0_rs1_bypass_data_d;\n   logic [31:0]                i0_rs2_bypass_data_d;\n   logic                       i0_rs1_bypass_en_d;\n   logic                       i0_rs2_bypass_en_d;\n   logic [31:0]                i0_rs1_d,  i0_rs2_d;\n   logic [31:0]                muldiv_rs1_d;\n   logic [31:1]                pred_correct_npc_r;\n   logic                       i0_pred_correct_upper_r;\n   logic [31:1]                i0_flush_path_upper_r;\n   logic                       x_data_en, x_data_en_q1, x_data_en_q2, r_data_en, r_data_en_q2;\n   logic                       x_ctl_en,  r_ctl_en;\n\n   logic [pt.BHT_GHR_SIZE-1:0] ghr_d_ns, ghr_d;\n   logic [pt.BHT_GHR_SIZE-1:0] ghr_x_ns, ghr_x;\n   logic                       i0_taken_d;\n   logic                       i0_taken_x;\n   logic                       i0_valid_d;\n   logic                       i0_valid_x;\n   logic [pt.BHT_GHR_SIZE-1:0] after_flush_eghr;\n\n   el2_predict_pkt_t          final_predict_mp;\n   el2_predict_pkt_t          i0_predict_newp_d;\n\n   logic                       flush_in_d;\n   logic [31:0]                alu_result_x;\n\n   logic                       mul_valid_x;\n   logic [31:0]                mul_result_x;\n\n   el2_predict_pkt_t          i0_pp_r;\n\n   logic                       i0_flush_upper_d;\n   logic [31:1]                i0_flush_path_d;\n   el2_predict_pkt_t          i0_predict_p_d;\n   logic                       i0_pred_correct_upper_d;\n\n   logic                       i0_flush_upper_x;\n   logic [31:1]                i0_flush_path_x;\n   el2_predict_pkt_t          i0_predict_p_x;\n   logic                       i0_pred_correct_upper_x;\n   logic                       i0_branch_x;\n\n   localparam PREDPIPESIZE = pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1+pt.BHT_GHR_SIZE+pt.BTB_BTAG_SIZE;\n   logic [PREDPIPESIZE-1:0]    predpipe_d, predpipe_x, predpipe_r, final_predpipe_mp;\n\n\n\n\n   rvdffpcie #(31)                       i_flush_path_x_ff    (.*, .clk(clk),        .en ( x_data_en     ),  .din ( i0_flush_path_d[31:1]         ),  .dout( i0_flush_path_x[31:1]      ) );\n   rvdffe #(32)                          i_csr_rs1_x_ff       (.*, .clk(clk),        .en ( x_data_en_q1  ),  .din ( i0_rs1_d[31:0]                ),  .dout( exu_csr_rs1_x[31:0]        ) );\n   rvdffppe #($bits(el2_predict_pkt_t)) i_predictpacket_x_ff (.*, .clk(clk),        .en ( x_data_en     ),  .din ( i0_predict_p_d                ),  .dout( i0_predict_p_x             ) );\n   rvdffe #(PREDPIPESIZE)                i_predpipe_x_ff      (.*, .clk(clk),        .en ( x_data_en_q2  ),  .din ( predpipe_d                    ),  .dout( predpipe_x                 ) );\n   rvdffe #(PREDPIPESIZE)                i_predpipe_r_ff      (.*, .clk(clk),        .en ( r_data_en_q2  ),  .din ( predpipe_x                    ),  .dout( predpipe_r                 ) );\n\n   rvdffe #(4+pt.BHT_GHR_SIZE)          i_x_ff               (.*, .clk(clk),        .en ( x_ctl_en      ),  .din ({i0_valid_d,i0_taken_d,i0_flush_upper_d,i0_pred_correct_upper_d,ghr_x_ns[pt.BHT_GHR_SIZE-1:0]} ),\n                                                                                                            .dout({i0_valid_x,i0_taken_x,i0_flush_upper_x,i0_pred_correct_upper_x,ghr_x[pt.BHT_GHR_SIZE-1:0]}    ) );\n\n   rvdffppe #($bits(el2_predict_pkt_t)+1) i_r_ff0         (.*, .clk(clk),        .en ( r_ctl_en      ),  .din ({i0_pred_correct_upper_x, i0_predict_p_x}),\n                                                                                                          .dout({i0_pred_correct_upper_r, i0_pp_r       }) );\n\n   rvdffpcie #(31)                      i_flush_r_ff         (.*, .clk(clk),        .en ( r_data_en     ),  .din ( i0_flush_path_x[31:1]         ),  .dout( i0_flush_path_upper_r[31:1]) );\n   rvdffpcie #(31)                      i_npc_r_ff           (.*, .clk(clk),        .en ( r_data_en     ),  .din ( pred_correct_npc_x[31:1]      ),  .dout( pred_correct_npc_r[31:1]   ) );\n\n   rvdffie #(pt.BHT_GHR_SIZE+2,1)       i_misc_ff            (.*, .clk(clk),                                .din ({ghr_d_ns[pt.BHT_GHR_SIZE-1:0], mul_p.valid, dec_i0_branch_d}),\n                                                                                                            .dout({ghr_d[pt.BHT_GHR_SIZE-1:0]   , mul_valid_x, i0_branch_x}) );\n\n\n\n\n\n   assign predpipe_d[PREDPIPESIZE-1:0]\n                                   = {i0_predict_fghr_d, i0_predict_index_d, i0_predict_btag_d};\n\n\n   assign i0_rs1_bypass_en_d       = dec_i0_rs1_bypass_en_d[0] | dec_i0_rs1_bypass_en_d[1] | dec_i0_rs1_bypass_en_d[2] | dec_i0_rs1_bypass_en_d[3];\n   assign i0_rs2_bypass_en_d       = dec_i0_rs2_bypass_en_d[0] | dec_i0_rs2_bypass_en_d[1] | dec_i0_rs2_bypass_en_d[2] | dec_i0_rs2_bypass_en_d[3];\n\n   assign i0_rs1_bypass_data_d[31:0]=({32{dec_i0_rs1_bypass_en_d[0]}} & dec_i0_result_r[31:0]       ) |\n                                     ({32{dec_i0_rs1_bypass_en_d[1]}} & lsu_result_m[31:0]          ) |\n                                     ({32{dec_i0_rs1_bypass_en_d[2]}} & exu_i0_result_x[31:0]       ) |\n                                     ({32{dec_i0_rs1_bypass_en_d[3]}} & lsu_nonblock_load_data[31:0]);\n\n   assign i0_rs2_bypass_data_d[31:0]=({32{dec_i0_rs2_bypass_en_d[0]}} & dec_i0_result_r[31:0]       ) |\n                                     ({32{dec_i0_rs2_bypass_en_d[1]}} & lsu_result_m[31:0]          ) |\n                                     ({32{dec_i0_rs2_bypass_en_d[2]}} & exu_i0_result_x[31:0]       ) |\n                                     ({32{dec_i0_rs2_bypass_en_d[3]}} & lsu_nonblock_load_data[31:0]);\n\n\n   assign i0_rs1_d[31:0]           = ({32{ i0_rs1_bypass_en_d                                           }}             & i0_rs1_bypass_data_d[31:0]) |\n                                     ({32{~i0_rs1_bypass_en_d &  dec_i0_select_pc_d                     }}             & {dec_i0_pc_d[31:1],1'b0}  ) |    // for jal's\n                                     ({32{~i0_rs1_bypass_en_d &  dec_debug_wdata_rs1_d                  }}             & dbg_cmd_wrdata[31:0]      ) |\n                                     ({32{~i0_rs1_bypass_en_d & ~dec_debug_wdata_rs1_d & dec_i0_rs1_en_d}}             & gpr_i0_rs1_d[31:0]        );\n\n   assign i0_rs2_d[31:0]           = ({32{~i0_rs2_bypass_en_d & dec_i0_rs2_en_d}}                                      & gpr_i0_rs2_d[31:0]        ) |\n                                     ({32{~i0_rs2_bypass_en_d                  }}                                      & dec_i0_immed_d[31:0]      ) |\n                                     ({32{ i0_rs2_bypass_en_d                  }}                                      & i0_rs2_bypass_data_d[31:0]);\n\n\n   assign exu_lsu_rs1_d[31:0]      = ({32{~i0_rs1_bypass_en_d & ~dec_extint_stall & dec_i0_rs1_en_d & dec_qual_lsu_d}} & gpr_i0_rs1_d[31:0]        ) |\n                                     ({32{ i0_rs1_bypass_en_d & ~dec_extint_stall                   & dec_qual_lsu_d}} & i0_rs1_bypass_data_d[31:0]) |\n                                     ({32{                       dec_extint_stall                   & dec_qual_lsu_d}} & {dec_tlu_meihap[31:2],2'b0});\n\n   assign exu_lsu_rs2_d[31:0]      = ({32{~i0_rs2_bypass_en_d & ~dec_extint_stall & dec_i0_rs2_en_d & dec_qual_lsu_d}} & gpr_i0_rs2_d[31:0]        ) |\n                                     ({32{ i0_rs2_bypass_en_d & ~dec_extint_stall                   & dec_qual_lsu_d}} & i0_rs2_bypass_data_d[31:0]);\n\n\n   assign muldiv_rs1_d[31:0]       = ({32{~i0_rs1_bypass_en_d & dec_i0_rs1_en_d}}                                      & gpr_i0_rs1_d[31:0]        ) |\n                                     ({32{ i0_rs1_bypass_en_d                  }}                                      & i0_rs1_bypass_data_d[31:0]);\n\n\n   assign x_data_en                =  dec_data_en[1];\n   assign x_data_en_q1             =  dec_data_en[1] & dec_csr_ren_d;\n   assign x_data_en_q2             =  dec_data_en[1] & dec_i0_branch_d;\n   assign r_data_en                =  dec_data_en[0];\n   assign r_data_en_q2             =  dec_data_en[0] & i0_branch_x;\n   assign x_ctl_en                 =  dec_ctl_en[1];\n   assign r_ctl_en                 =  dec_ctl_en[0];\n\n\n\n\n   el2_exu_alu_ctl #(.pt(pt)) i_alu  (.*,\n                          .enable            ( x_data_en                   ),   // I\n                          .pp_in             ( i0_predict_newp_d           ),   // I\n                          .valid_in          ( dec_i0_alu_decode_d         ),   // I\n                          .flush_upper_x     ( i0_flush_upper_x            ),   // I\n                          .flush_lower_r     ( dec_tlu_flush_lower_r       ),   // I\n                          .a_in              ( i0_rs1_d[31:0]              ),   // I\n                          .b_in              ( i0_rs2_d[31:0]              ),   // I\n                          .pc_in             ( dec_i0_pc_d[31:1]           ),   // I\n                          .brimm_in          ( dec_i0_br_immed_d[12:1]     ),   // I\n                          .ap                ( i0_ap                       ),   // I\n                          .csr_ren_in        ( dec_csr_ren_d               ),   // I\n                          .csr_rddata_in     ( dec_csr_rddata_d[31:0]      ),   // I\n                          .result_ff         ( alu_result_x[31:0]          ),   // O\n                          .flush_upper_out   ( i0_flush_upper_d            ),   // O\n                          .flush_final_out   ( exu_flush_final             ),   // O\n                          .flush_path_out    ( i0_flush_path_d[31:1]       ),   // O\n                          .predict_p_out     ( i0_predict_p_d              ),   // O\n                          .pred_correct_out  ( i0_pred_correct_upper_d     ),   // O\n                          .pc_ff             ( exu_i0_pc_x[31:1]           ));  // O\n\n\n\n   el2_exu_mul_ctl #(.pt(pt)) i_mul   (.*,\n                          .mul_p             ( mul_p              & {$bits(el2_mul_pkt_t){mul_p.valid}} ),   // I\n                          .rs1_in            ( muldiv_rs1_d[31:0] & {32{mul_p.valid}}                    ),   // I\n                          .rs2_in            ( i0_rs2_d[31:0]     & {32{mul_p.valid}}                    ),   // I\n                          .result_x          ( mul_result_x[31:0]                                        ));  // O\n\n\n\n   el2_exu_div_ctl #(.pt(pt)) i_div   (.*,\n                          .cancel            ( dec_div_cancel              ),   // I\n                          .dp                ( div_p                       ),   // I\n                          .dividend          ( muldiv_rs1_d[31:0]          ),   // I\n                          .divisor           ( i0_rs2_d[31:0]              ),   // I\n                          .finish_dly        ( exu_div_wren                ),   // O\n                          .out               ( exu_div_result[31:0]        ));  // O\n\n\n\n   assign exu_i0_result_x[31:0]    =  (mul_valid_x)  ?  mul_result_x[31:0]  :  alu_result_x[31:0];\n\n\n\n\n   always_comb begin\n      i0_predict_newp_d            =  dec_i0_predict_p_d;\n      i0_predict_newp_d.boffset    =  dec_i0_pc_d[1];  // from the start of inst\n   end\n\n\n   assign exu_pmu_i0_br_misp       =  i0_pp_r.misp;\n   assign exu_pmu_i0_br_ataken     =  i0_pp_r.ataken;\n   assign exu_pmu_i0_pc4           =  i0_pp_r.pc4;\n\n\n   assign i0_valid_d               =  i0_predict_p_d.valid  & dec_i0_alu_decode_d & ~dec_tlu_flush_lower_r;\n   assign i0_taken_d               = (i0_predict_p_d.ataken & dec_i0_alu_decode_d);\n\nif(pt.BTB_ENABLE==1) begin\n   // maintain GHR at D\n   assign ghr_d_ns[pt.BHT_GHR_SIZE-1:0]\n                                   = ({pt.BHT_GHR_SIZE{~dec_tlu_flush_lower_r &  i0_valid_d}} & {ghr_d[pt.BHT_GHR_SIZE-2:0], i0_taken_d}) |\n                                     ({pt.BHT_GHR_SIZE{~dec_tlu_flush_lower_r & ~i0_valid_d}} &  ghr_d[pt.BHT_GHR_SIZE-1:0]             ) |\n                                     ({pt.BHT_GHR_SIZE{ dec_tlu_flush_lower_r              }} &  ghr_x[pt.BHT_GHR_SIZE-1:0]             );\n\n   // maintain GHR at X\n   assign ghr_x_ns[pt.BHT_GHR_SIZE-1:0]\n                                   = ({pt.BHT_GHR_SIZE{ i0_valid_x}} & {ghr_x[pt.BHT_GHR_SIZE-2:0], i0_taken_x}) |\n                                     ({pt.BHT_GHR_SIZE{~i0_valid_x}} &  ghr_x[pt.BHT_GHR_SIZE-1:0]             ) ;\n\n\n   assign exu_i0_br_valid_r                                 =  i0_pp_r.valid;\n   assign exu_i0_br_mp_r                                    =  i0_pp_r.misp;\n   assign exu_i0_br_way_r                                   =  i0_pp_r.way;\n   assign exu_i0_br_hist_r[1:0]                             =  {2{i0_pp_r.valid}} & i0_pp_r.hist[1:0];\n   assign exu_i0_br_error_r                                 =  i0_pp_r.br_error;\n   assign exu_i0_br_middle_r                                =  i0_pp_r.pc4 ^ i0_pp_r.boffset;\n   assign exu_i0_br_start_error_r                           =  i0_pp_r.br_start_er"}
{"text": "ror;\n\n   assign {exu_i0_br_fghr_r[pt.BHT_GHR_SIZE-1:0],\n           exu_i0_br_index_r[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]}=  predpipe_r[PREDPIPESIZE-1:pt.BTB_BTAG_SIZE];\n\n\n   assign final_predict_mp                                  = (i0_flush_upper_x)  ?  i0_predict_p_x  :  '0;\n\n   assign final_predpipe_mp[PREDPIPESIZE-1:0]               = (i0_flush_upper_x)  ?  predpipe_x      :  '0;\n\n   assign after_flush_eghr[pt.BHT_GHR_SIZE-1:0]             = (i0_flush_upper_x & ~dec_tlu_flush_lower_r)  ?  ghr_d[pt.BHT_GHR_SIZE-1:0]  :  ghr_x[pt.BHT_GHR_SIZE-1:0];\n\n\n   assign exu_mp_pkt.valid                                  =  final_predict_mp.valid;\n   assign exu_mp_pkt.way                                    =  final_predict_mp.way;\n   assign exu_mp_pkt.misp                                   =  final_predict_mp.misp;\n   assign exu_mp_pkt.pcall                                  =  final_predict_mp.pcall;\n   assign exu_mp_pkt.pja                                    =  final_predict_mp.pja;\n   assign exu_mp_pkt.pret                                   =  final_predict_mp.pret;\n   assign exu_mp_pkt.ataken                                 =  final_predict_mp.ataken;\n   assign exu_mp_pkt.boffset                                =  final_predict_mp.boffset;\n   assign exu_mp_pkt.pc4                                    =  final_predict_mp.pc4;\n   assign exu_mp_pkt.hist[1:0]                              =  final_predict_mp.hist[1:0];\n   assign exu_mp_pkt.toffset[11:0]                          =  final_predict_mp.toffset[11:0];\n\n   assign exu_mp_fghr[pt.BHT_GHR_SIZE-1:0]                  =  after_flush_eghr[pt.BHT_GHR_SIZE-1:0];\n\n   assign {exu_mp_index[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],\n           exu_mp_btag[pt.BTB_BTAG_SIZE-1:0]}               =  final_predpipe_mp[PREDPIPESIZE-pt.BHT_GHR_SIZE-1:0];\n\n   assign exu_mp_eghr[pt.BHT_GHR_SIZE-1:0]                  =  final_predpipe_mp[PREDPIPESIZE-1:pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+pt.BTB_BTAG_SIZE+1]; // mp ghr for bht write\nend // if (pt.BTB_ENABLE==1)\nelse begin\n   assign ghr_d_ns = '0;\n   assign ghr_x_ns = '0;\n   assign exu_mp_pkt = '0;\n   assign exu_mp_eghr = '0;\n   assign exu_mp_fghr = '0;\n   assign exu_mp_index = '0;\n   assign exu_mp_btag = '0;\n   assign exu_i0_br_hist_r = '0;\n   assign exu_i0_br_error_r = '0;\n   assign exu_i0_br_start_error_r = '0;\n   assign exu_i0_br_index_r = '0;\n   assign exu_i0_br_valid_r = '0;\n   assign exu_i0_br_mp_r = '0;\n   assign exu_i0_br_middle_r = '0;\n   assign exu_i0_br_fghr_r = '0;\n   assign exu_i0_br_way_r = '0;\nend // else: !if(pt.BTB_ENABLE==1)\n\n   assign exu_flush_path_final[31:1] = ( {31{ dec_tlu_flush_lower_r                   }} & dec_tlu_flush_path_r[31:1] ) |\n                                       ( {31{~dec_tlu_flush_lower_r & i0_flush_upper_d}} & i0_flush_path_d[31:1]      );\n\n   assign exu_npc_r[31:1]            = (i0_pred_correct_upper_r)  ?  pred_correct_npc_r[31:1]    :  i0_flush_path_upper_r[31:1];\n\n\nendmodule // el2_exu\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nmodule el2_exu_alu_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n)\n  (\n   input  logic                  clk,                // Top level clock\n   input  logic                  rst_l,              // Reset\n   input  logic                  scan_mode,          // Scan control\n\n   input  logic                  flush_upper_x,      // Branch flush from previous cycle\n   input  logic                  flush_lower_r,      // Master flush of entire pipeline\n   input  logic                  enable,             // Clock enable\n   input  logic                  valid_in,           // Valid\n   input  el2_alu_pkt_t         ap,                 // predecodes\n   input  logic                  csr_ren_in,         // CSR select\n   input  logic        [31:0]    csr_rddata_in,      // CSR data\n   input  logic signed [31:0]    a_in,               // A operand\n   input  logic        [31:0]    b_in,               // B operand\n   input  logic        [31:1]    pc_in,              // for pc=pc+2,4 calculations\n   input  el2_predict_pkt_t     pp_in,              // Predicted branch structure\n   input  logic        [12:1]    brimm_in,           // Branch offset\n\n\n   output logic        [31:0]    result_ff,          // final result\n   output logic                  flush_upper_out,    // Branch flush\n   output logic                  flush_final_out,    // Branch flush or flush entire pipeline\n   output logic        [31:1]    flush_path_out,     // Branch flush PC\n   output logic        [31:1]    pc_ff,              // flopped PC\n   output logic                  pred_correct_out,   // NPC control\n   output el2_predict_pkt_t     predict_p_out       // Predicted branch structure\n  );\n\n\n   logic               [31:0]    zba_a_in;\n   logic               [31:0]    aout;\n   logic                         cout,ov,neg;\n   logic               [31:0]    lout;\n   logic               [31:0]    sout;\n   logic                         sel_shift;\n   logic                         sel_adder;\n   logic                         slt_one;\n   logic                         actual_taken;\n   logic               [31:1]    pcout;\n   logic                         cond_mispredict;\n   logic                         target_mispredict;\n   logic                         eq, ne, lt, ge;\n   logic                         any_jal;\n   logic               [1:0]     newhist;\n   logic                         sel_pc;\n   logic               [31:0]    csr_write_data;\n   logic               [31:0]    result;\n\n\n\n\n   // *** Start - BitManip ***\n\n   // Zbb\n   logic                  ap_clz;\n   logic                  ap_ctz;\n   logic                  ap_cpop;\n   logic                  ap_sext_b;\n   logic                  ap_sext_h;\n   logic                  ap_min;\n   logic                  ap_max;\n   logic                  ap_rol;\n   logic                  ap_ror;\n   logic                  ap_rev8;\n   logic                  ap_orc_b;\n   logic                  ap_zbb;\n\n   // Zbs\n   logic                  ap_bset;\n   logic                  ap_bclr;\n   logic                  ap_binv;\n   logic                  ap_bext;\n\n   // Zbp\n   logic                  ap_pack;\n   logic                  ap_packu;\n   logic                  ap_packh;\n\n   // Zba\n   logic                  ap_sh1add;\n   logic                  ap_sh2add;\n   logic                  ap_sh3add;\n   logic                  ap_zba;\n\n\n\n   if (pt.BITMANIP_ZBB == 1)\n     begin\n       assign ap_clz          =  ap.clz;\n       assign ap_ctz          =  ap.ctz;\n       assign ap_cpop         =  ap.cpop;\n       assign ap_sext_b       =  ap.sext_b;\n       assign ap_sext_h       =  ap.sext_h;\n       assign ap_min          =  ap.min;\n       assign ap_max          =  ap.max;\n     end\n   else\n     begin\n       assign ap_clz          =  1'b0;\n       assign ap_ctz          =  1'b0;\n       assign ap_cpop         =  1'b0;\n       assign ap_sext_b       =  1'b0;\n       assign ap_sext_h       =  1'b0;\n       assign ap_min          =  1'b0;\n       assign ap_max          =  1'b0;\n     end\n\n\n   if ( (pt.BITMANIP_ZBB == 1) | (pt.BITMANIP_ZBP == 1) )\n     begin\n       assign ap_rol          =  ap.rol;\n       assign ap_ror          =  ap.ror;\n       assign ap_rev8         =  ap.grev & (b_in[4:0] == 5'b11000);\n       assign ap_orc_b        =  ap.gorc & (b_in[4:0] == 5'b00111);\n       assign ap_zbb          =  ap.zbb;\n     end\n   else\n     begin\n       assign ap_rol          =  1'b0;\n       assign ap_ror          =  1'b0;\n       assign ap_rev8         =  1'b0;\n       assign ap_orc_b        =  1'b0;\n       assign ap_zbb          =  1'b0;\n     end\n\n\n   if (pt.BITMANIP_ZBS == 1)\n     begin\n       assign ap_bset         =  ap.bset;\n       assign ap_bclr         =  ap.bclr;\n       assign ap_binv         =  ap.binv;\n       assign ap_bext         =  ap.bext;\n     end\n   else\n     begin\n       assign ap_bset         =  1'b0;\n       assign ap_bclr         =  1'b0;\n       assign ap_binv         =  1'b0;\n       assign ap_bext         =  1'b0;\n     end\n\n\n   if (pt.BITMANIP_ZBP == 1)\n     begin\n       assign ap_packu        =  ap.packu;\n     end\n   else\n     begin\n       assign ap_packu        =  1'b0;\n     end\n\n\n   if ( (pt.BITMANIP_ZBB == 1) | (pt.BITMANIP_ZBP == 1) | (pt.BITMANIP_ZBE == 1) | (pt.BITMANIP_ZBF == 1) )\n     begin\n       assign ap_pack         =  ap.pack;\n       assign ap_packh        =  ap.packh;\n     end\n   else\n     begin\n       assign ap_pack         =  1'b0;\n       assign ap_packh        =  1'b0;\n     end\n\n\n   if (pt.BITMANIP_ZBA == 1)\n     begin\n       assign ap_sh1add       =  ap.sh1add;\n       assign ap_sh2add       =  ap.sh2add;\n       assign ap_sh3add       =  ap.sh3add;\n       assign ap_zba          =  ap.zba;\n     end\n   else\n     begin\n       assign ap_sh1add       =  1'b0;\n       assign ap_sh2add       =  1'b0;\n       assign ap_sh3add       =  1'b0;\n       assign ap_zba          =  1'b0;\n     end\n\n\n\n\n   // *** End   - BitManip ***\n\n\n\n\n   rvdffpcie #(31) i_pc_ff      (.*, .clk(clk), .en(enable),              .din(pc_in[31:1]),    .dout(pc_ff[31:1]));   // any PC is run through here - doesn't have to be alu\n   rvdffe    #(32) i_result_ff  (.*, .clk(clk), .en(enable & valid_in),   .din(result[31:0]),   .dout(result_ff[31:0]));\n\n\n\n   // immediates are just muxed into rs2\n\n   // add    =>  add=1;\n   // sub    =>  add=1; sub=1;\n\n   // and    =>  lctl=3\n   // or     =>  lctl=2\n   // xor    =>  lctl=1\n\n   // sll    =>  sctl=3\n   // srl    =>  sctl=2\n   // sra    =>  sctl=1\n\n   // slt    =>  slt\n\n   // lui    =>  lctl=2; or x0, imm20 previously << 12\n   // auipc  =>  add;   add pc, imm20 previously << 12\n\n   // beq    =>  bctl=4; add; add x0, pc, sext(offset[12:1])\n   // bne    =>  bctl=3; add; add x0, pc, sext(offset[12:1])\n   // blt    =>  bctl=2; add; add x0, pc, sext(offset[12:1])\n   // bge    =>  bctl=1; add; add x0, pc, sext(offset[12:1])\n\n   // jal    =>  rs1=pc {pc[31:1],1'b0},  rs2=sext(offset20:1]);   rd=pc+[2,4]\n   // jalr   =>  rs1=rs1,                 rs2=sext(offset20:1]);   rd=pc+[2,4]\n\n\n\n   assign zba_a_in[31:0]      = ( {32{ ap_sh1add}} & {a_in[30:0],1'b0} ) |\n                                ( {32{ ap_sh2add}} & {a_in[29:0],2'b0} ) |\n                                ( {32{ ap_sh3add}} & {a_in[28:0],3'b0} ) |\n                                ( {32{~ap_zba   }} &  a_in[31:0]       );\n\n   logic        [31:0]    bm;\n\n   assign bm[31:0]            = ( ap.sub )  ?  ~b_in[31:0]  :  b_in[31:0];\n\n   assign {cout, aout[31:0]}  = {1'b0, zba_a_in[31:0]} + {1'b0, bm[31:0]} + {32'b0, ap.sub};\n\n   assign ov                  = (~a_in[31] & ~bm[31] &  aout[31]) |\n                                ( a_in[31] &  bm[31] & ~aout[31] );\n\n   assign lt                  = (~ap.unsign & (neg ^ ov)) |\n                                ( ap.unsign & ~cout);\n\n   assign eq                  = (a_in[31:0] == b_in[31:0]);\n   assign ne                  = ~eq;\n   assign neg                 =  aout[31];\n   assign ge                  = ~lt;\n\n\n\n   assign lout[31:0]          =  ( {32{csr_ren_in       }} &  csr_rddata_in[31:0]       ) |\n                                 ( {32{ap.land & ~ap_zbb}} &  a_in[31:0] &  b_in[31:0]  ) |\n                                 ( {32{ap.lor  & ~ap_zbb}} & (a_in[31:0] |  b_in[31:0]) ) |\n                                 ( {32{ap.lxor & ~ap_zbb}} & (a_in[31:0] ^  b_in[31:0]) ) |\n                                 ( {32{ap.land &  ap_zbb}} &  a_in[31:0] & ~b_in[31:0]  ) |\n                                 ( {32{ap.lor  &  ap_zbb}} & (a_in[31:0] | ~b_in[31:0]) ) |\n                                 ( {32{ap.lxor &  ap_zbb}} & (a_in[31:0] ^ ~b_in[31:0]) );\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  ROL,ROR      * * * * * * * * * * * * * * * * * *\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  ZBEXT        * * * * * * * * * * * * * * * * * *\n\n   logic        [5:0]     shift_amount;\n   logic        [31:0]    shift_mask;\n   logic        [62:0]    shift_extend;\n   logic        [62:0]    shift_long;\n\n\n   assign shift_amount[5:0]            = ( { 6{ap.sll}}   & (6'd32 - {1'b0,b_in[4:0]}) ) |   // [5] unused\n                                         ( { 6{ap.srl}}   &          {1'b0,b_in[4:0]}  ) |\n                                         ( { 6{ap.sra}}   &          {1'b0,b_in[4:0]}  ) |\n                                         ( { 6{ap_rol}}   & (6'd32 - {1'b0,b_in[4:0]}) ) |\n                                         ( { 6{ap_ror}}   &          {1'b0,b_in[4:0]}  ) |\n                                         ( { 6{ap_bext}}  &          {1'b0,b_in[4:0]}  );\n\n\n   assign shift_mask[31:0]             = ( 32'hffffffff << ({5{ap.sll}} & b_in[4:0]) );\n\n\n   assign shift_extend[31:0]           =  a_in[31:0];\n\n   assign shift_extend[62:32]          = ( {31{ap.sra}} & {31{a_in[31]}} ) |\n                                         ( {31{ap.sll}} &     a_in[30:0] ) |\n                                         ( {31{ap_rol}} &     a_in[30:0] ) |\n                                         ( {31{ap_ror}} &     a_in[30:0] );\n\n\n   assign shift_long[62:0]    = ( shift_extend[62:0] >> shift_amount[4:0] );   // 62-32 unused\n\n   assign sout[31:0]          =   shift_long[31:0] & shift_mask[31:0];\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  CLZ,CTZ      * * * * * * * * * * * * * * * * * *\n\n   logic                  bitmanip_clz_ctz_sel;\n   logic        [31:0]    bitmanip_a_reverse_ff;\n   logic        [31:0]    bitmanip_lzd_in;\n   logic        [5:0]     bitmanip_dw_lzd_enc;\n   logic        [5:0]     bitmanip_clz_ctz_result;\n\n   assign bitmanip_clz_ctz_sel         =  ap_clz | ap_ctz;\n\n   assign bitmanip_a_reverse_ff[31:0]  = {a_in[0],  a_in[1],  a_in[2],  a_in[3],  a_in[4],  a_in[5],  a_in[6],  a_in[7],\n                                          a_in[8],  a_in[9],  a_in[10], a_in[11], a_in[12], a_in[13], a_in[14], a_in[15],\n                                          a_in[16], a_in[17], a_in[18], a_in[19], a_in[20], a_in[21], a_in[22], a_in[23],\n                                          a_in[24], a_in[25], a_in[26], a_in[27], a_in[28], a_in[29], a_in[30], a_in[31]};\n\n   assign bitmanip_lzd_in[31:0]        = ( {32{ap_clz}} & a_in[31:0]                 ) |\n                                         ( {32{ap_ctz}} & bitmanip_a_reverse_ff[31:0]);\n\n   logic        [31:0]    bitmanip_lzd_os;\n   integer                i;\n   logic                  found;\n\n   always_comb\n     begin\n        bitmanip_lzd_os[31:0]   =  bitmanip_lzd_in[31:0];\n        bitmanip_dw_lzd_enc[5:0]=  6'b0;\n        found = 1'b0;\n\n        for (int i=0; i<32; i++) begin\n          if (bitmanip_lzd_os[31] == 1'b0 && found == 0) begin\n              bitmanip_dw_lzd_enc[5:0]=  bitmanip_dw_lzd_enc[5:0] + 6'b00_0001;\n              bitmanip_lzd_os[31:0]   =  bitmanip_lzd_os[31:0] << 1;\n           end\n           else\n              found=1'b1;\n        end\n     end\n\n\n\n   assign bitmanip_clz_ctz_result[5:0] = {6{bitmanip_clz_ctz_sel}} & {bitmanip_dw_lzd_enc[5],( {5{~bitmanip_dw_lzd_enc[5]}} & bitmanip_dw_lzd_enc[4:0] )};\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  CPOP         * * * * * * * * * * * * * * * * * *\n\n   logic        [5:0]     bitmanip_cpop;\n   logic        [5:0]     bitmanip_cpop_result;\n\n\n   integer                bitmanip_cpop_i;\n\n   always_comb\n     begin\n       bitmanip_cpop[5:0]               =  6'b0;\n\n       for (bitmanip_cpop_i=0; bitmanip_cpop_i<32; bitmanip_cpop_i++)\n         begin\n            bitmanip_cpop[5:0]          =  bitmanip_cpop[5:0] + {5'b0,a_in[bitmanip_cpop_i]};\n         end      // FOR    bitmanip_cpop_i\n     end          // ALWAYS_COMB\n\n\n   assign bitmanip_cpop_result[5:0]    =  {6{ap_cpop}} & bitmanip_cpop[5:0];\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  SEXT_B,SEXT_H  * * * * * * * * * * * * * * * * *\n\n   logic       [31:0]     bitmanip_sext_result;\n\n   assign bitmanip_sext_result[31:0]   = ( {32{ap_sext_b}} & { {24{a_in[7]}} ,a_in[7:0]  } ) |\n                                         ( {32{ap_sext_h}} & { {16{a_in[15]}},a_in[15:0] } );\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  MIN,MAX,MINU,MAXU  * * * * * * * * * * * * * * *\n\n   logic                  bitmanip_minmax_sel;\n   logic        [31:0]    bitmanip_minmax_result;\n\n   assign bitmanip_minmax_sel          =  ap_min | ap_max;\n\n   logic                  bitmanip_minmax_sel_a;\n\n   assign bitmanip_minmax_sel_a        =  ge  ^ ap_min;\n\n   assign bitmanip_minmax_result[31:0] = ({32{bitmanip_minmax_sel &  bitmanip_minmax_sel_a}}  &  a_in[31:0]) |\n                                         ({32{bitmanip_minmax_sel & ~bitmanip_minmax_sel_a}}  &  b_in[31:0]);\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  PACK, PACKU, PACKH * * * * * * * * * * * * * * *\n\n   logic        [31:0]    bitmanip_pack_result;\n   logic        [31:0]    bitmanip_packu_result;\n   logic        [31:0]    bitmanip_packh_result;\n\n   assign bitmanip_pack_result[31:0]   = {32{ap_pack}}  & {b_in[15:0], a_in[15:0]};\n   assign bitmanip_packu_result[31:0]  = {32{ap_packu}} & {b_in[31:16],a_in[31:16]};\n   assign bitmanip_packh_result[31:0]  = {32{ap_packh}} & {16'b0,b_in[7:0],a_in[7:0]};\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  REV, ORC_B   * * * * * * * * * * * * * * * * * *\n\n   logic        [31:0]    bitmanip_rev8_result;\n   logic        [31:0]    bitmanip_orc_b_result;\n\n   assign bitmanip_rev8_result[31:0]   = {32{ap_rev8}}  & {a_in[7:0],a_in[15:8],a_in[23:16],a_in[31:24]};\n\n\n// uint32_t gorc32(uint32_t rs1, uint32_t rs2)\n// {\n//      uint32_t x = rs1;\n//      int shamt = rs2 & 31;                                                        ORC.B  ORC16\n//      if (shamt &  1) x |= ((x & 0x55555555) <<  1) | ((x & 0xAAAAAAAA) >>  1);      1      0\n//      if (shamt &  2) x |= ((x & 0x33333333) <<  2) | ((x & 0xCCCCCCCC) >>  2);      1      0\n//      if (shamt &  4) x |= ((x & 0x0F0F0F0F) <<  4) | ((x & 0xF0F0F0F0) >>  4);      1      0\n//      if (shamt &  8) x |= ((x & 0x00FF00FF) <<  8) | ((x & 0xFF00FF00) >>  8);      0      0\n//      if (shamt & 16) x |= ((x & 0x0000FFFF) << 16) | ((x & 0xFFFF0000) >> 16);      0      1\n//      return x;\n// }\n\n\n// BEFORE              31  ,   30  ,   29  ,   28  ,    27  ,   26,     25,     24\n// shamt[0]  b =    a31|a30,a31|a30,a29|a28,a29|a28, a27|a26,a27|a26,a25|a24,a25|a24\n// shamt[1]  c =    b31|b29,b30|b28,b31|b29,b30|b28, b27|b25,b26|b24,b27|b25,b26|b24\n// shamt[2]  d =    c31|c27,c30|c26,c29|c25,c28|c24, c31|c27,c30|c26,c29|c25,c28|c24\n//\n// Expand d31 =        c31         |         c27;\n//            =   b31   |   b29    |    b27   |   b25;\n//            = a31|a30 | a29|a28  |  a27|a26 | a25|a24\n\n   assign bitmanip_orc_b_result[31:0]  = {32{ap_orc_b}} & { {8{| a_in[31:24]}}, {8{| a_in[23:16]}}, {8{| a_in[15:8]}}, {8{| a_in[7:0]}} };\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  ZBSET, ZBCLR, ZBINV  * * * * * * * * * * * * * *\n\n   logic        [31:0]    bitmanip_sb_1hot;\n   logic        [31:0]    bitmanip_sb_data;\n\n   assign bitmanip_sb_1hot[31:0]       = ( 32'h00000001 << b_in[4:0] );\n\n   assign bitmanip_sb_data[31:0]       = ( {32{ap_bset}} & ( a_in[31:0] |  bitmanip_sb_1hot[31:0]) ) |\n                                         ( {32{ap_bclr}} & ( a_in[31:0] & ~bitmanip_sb_1hot[31:0]) ) |\n                                         ( {32{ap_binv}} & ( a_in[31:0] ^  bitmanip_sb_1hot[31:0]) );\n\n\n\n\n\n\n   assign sel_shift           =  ap.sll  | ap.srl | ap.sra | ap_rol | ap_ror;\n   assign sel_adder           = (ap.add  | ap.sub | ap_zba) & ~ap.slt & ~ap_min & ~ap_max;\n   assign sel_pc              =  ap.jal  | pp_in.pcall | pp_in.pja | pp_in.pret;\n   assign csr_write_data[31:0]= (ap.csr_imm)  ?  b_in[31:0]  :  a_in[31:0];\n\n   assign slt_one             =  ap.slt & lt;\n\n\n\n   assign result[31:0]        =                        lout[31:0]             |\n                                ({32{sel_shift}}    &  sout[31:0]           ) |\n                                ({32{sel_adder}}    &  aout[31:0]           ) |\n                                ({32{sel_pc}}       & {pcout[31:1],1'b0}    ) |\n                                ({32{ap.csr_write}} &  csr_write_data[31:0] ) |\n                                                      {31'b0, slt_one}        |\n                                ({32{ap_bext}}      & {31'b0, sout[0]}      ) |\n                                                      {26'b0, bitmanip_clz_ctz_result[5:0]} |\n                                                      {26'b0, bitmanip_cpop_result[5:0]}    |\n                                                       bitmanip_sext_result[31:0]    |\n                                                       bitmanip_minmax_result[31:0]  |\n                                                       bitmanip_pack_result[31:0]    |\n                                                       bitmanip_packu_result[31:0]   |\n                                                       bitmanip_packh_result[31:0]   |\n                                                       bitmanip_rev8_result[31:0]    |\n                                                       bitmanip_orc_b_result[31:0]   |\n                                                       bitmanip_sb_data[31:0];\n\n\n\n   // *** branch handling ***\n\n   assign any_jal             =  ap.jal      |\n                                 pp_in.pcall |\n                                 pp_in.pja   |\n                                 pp_in.pret;\n\n   assign actual_taken        = (ap.beq & eq) |\n                                (ap.bne & ne) |\n                                (ap.blt & lt) |\n                                (ap.bge & ge) |\n                                 any_jal;\n\n   // for a conditional br pcout[] will be the opposite of the branch prediction\n   // for jal or pcall, it will be the link address pc+2 or pc+4\n\n   rvbradder ibradder (\n                     .pc     ( pc_in[31:1]    ),\n                     .offset ( brimm_in[12:1] ),\n                     .dout   ( pcout[31:1]    ));\n\n\n   // pred_correct is for the npc logic\n   // pred_correct indicates not to use the flush_path\n   // for any_jal pred_correct==0\n\n   assign pred_correct_out    = (valid_in & ap.predict_nt & ~actual_taken & ~any_jal) |\n                                (valid_in & ap.predict_t  &  actual_taken & ~any_jal);\n\n\n   // for any_jal adder output is the flush path\n   assign flush_path_out[31:1]= (any_jal) ? aout[31:1] : pcout[31:1];\n\n\n   // pcall and pret are included here\n   assign cond_m"}
{"text": "ispredict     = (ap.predict_t  & ~actual_taken) |\n                                (ap.predict_nt &  actual_taken);\n\n\n   // target mispredicts on ret's\n\n   assign target_mispredict   =  pp_in.pret & (pp_in.prett[31:1] != aout[31:1]);\n\n   assign flush_upper_out     =   (ap.jal | cond_mispredict | target_mispredict) & valid_in & ~flush_upper_x   & ~flush_lower_r;\n   assign flush_final_out     = ( (ap.jal | cond_mispredict | target_mispredict) & valid_in & ~flush_upper_x ) |  flush_lower_r;\n\n\n   // .i 3\n   // .o 2\n   // .ilb hist[1] hist[0] taken\n   // .ob newhist[1] newhist[0]\n   // .type fd\n   //\n   // 00 0 01\n   // 01 0 01\n   // 10 0 00\n   // 11 0 10\n   // 00 1 10\n   // 01 1 00\n   // 10 1 11\n   // 11 1 11\n\n   assign newhist[1]          = ( pp_in.hist[1] &  pp_in.hist[0]) | (~pp_in.hist[0] & actual_taken);\n   assign newhist[0]          = (~pp_in.hist[1] & ~actual_taken)  | ( pp_in.hist[1] & actual_taken);\n\n   always_comb begin\n      predict_p_out           =  pp_in;\n\n      predict_p_out.misp      = ~flush_upper_x & ~flush_lower_r & (cond_mispredict | target_mispredict);\n      predict_p_out.ataken    =  actual_taken;\n      predict_p_out.hist[1]   =  newhist[1];\n      predict_p_out.hist[0]   =  newhist[0];\n\n   end\n\n\n\nendmodule // el2_exu_alu_ctl\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nmodule el2_exu_div_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n)\n  (\n   input logic           clk,                       // Top level clock\n   input logic           rst_l,                     // Reset\n   input logic           scan_mode,                 // Scan mode\n\n   input el2_div_pkt_t  dp,                        // valid, sign, rem\n   input logic  [31:0]   dividend,                  // Numerator\n   input logic  [31:0]   divisor,                   // Denominator\n\n   input logic           cancel,                    // Cancel divide\n\n\n   output logic          finish_dly,                // Finish to match data\n   output logic [31:0]   out                        // Result\n  );\n\n\n   logic [31:0]          out_raw;\n\n   assign out[31:0] = {32{finish_dly}} & out_raw[31:0];     // Qualification added to quiet result bus while divide is iterating\n\n\n\n   if (pt.DIV_NEW == 0)\n      begin\n        el2_exu_div_existing_1bit_cheapshortq   i_existing_1bit_div_cheapshortq (\n            .clk              ( clk                      ),   // I\n            .rst_l            ( rst_l                    ),   // I\n            .scan_mode        ( scan_mode                ),   // I\n            .cancel           ( cancel                   ),   // I\n            .valid_in         ( dp.valid                 ),   // I\n            .signed_in        (~dp.unsign                ),   // I\n            .rem_in           ( dp.rem                   ),   // I\n            .dividend_in      ( dividend[31:0]           ),   // I\n            .divisor_in       ( divisor[31:0]            ),   // I\n            .valid_out        ( finish_dly               ),   // O\n            .data_out         ( out_raw[31:0]            ));  // O\n      end\n\n\n   if ( (pt.DIV_NEW == 1) & (pt.DIV_BIT == 1) )\n      begin\n        el2_exu_div_new_1bit_fullshortq         i_new_1bit_div_fullshortq       (\n            .clk              ( clk                      ),   // I\n            .rst_l            ( rst_l                    ),   // I\n            .scan_mode        ( scan_mode                ),   // I\n            .cancel           ( cancel                   ),   // I\n            .valid_in         ( dp.valid                 ),   // I\n            .signed_in        (~dp.unsign                ),   // I\n            .rem_in           ( dp.rem                   ),   // I\n            .dividend_in      ( dividend[31:0]           ),   // I\n            .divisor_in       ( divisor[31:0]            ),   // I\n            .valid_out        ( finish_dly               ),   // O\n            .data_out         ( out_raw[31:0]            ));  // O\n      end\n\n\n   if ( (pt.DIV_NEW == 1) & (pt.DIV_BIT == 2) )\n      begin\n        el2_exu_div_new_2bit_fullshortq         i_new_2bit_div_fullshortq       (\n            .clk              ( clk                      ),   // I\n            .rst_l            ( rst_l                    ),   // I\n            .scan_mode        ( scan_mode                ),   // I\n            .cancel           ( cancel                   ),   // I\n            .valid_in         ( dp.valid                 ),   // I\n            .signed_in        (~dp.unsign                ),   // I\n            .rem_in           ( dp.rem                   ),   // I\n            .dividend_in      ( dividend[31:0]           ),   // I\n            .divisor_in       ( divisor[31:0]            ),   // I\n            .valid_out        ( finish_dly               ),   // O\n            .data_out         ( out_raw[31:0]            ));  // O\n      end\n\n\n   if ( (pt.DIV_NEW == 1) & (pt.DIV_BIT == 3) )\n      begin\n        el2_exu_div_new_3bit_fullshortq         i_new_3bit_div_fullshortq       (\n            .clk              ( clk                      ),   // I\n            .rst_l            ( rst_l                    ),   // I\n            .scan_mode        ( scan_mode                ),   // I\n            .cancel           ( cancel                   ),   // I\n            .valid_in         ( dp.valid                 ),   // I\n            .signed_in        (~dp.unsign                ),   // I\n            .rem_in           ( dp.rem                   ),   // I\n            .dividend_in      ( dividend[31:0]           ),   // I\n            .divisor_in       ( divisor[31:0]            ),   // I\n            .valid_out        ( finish_dly               ),   // O\n            .data_out         ( out_raw[31:0]            ));  // O\n      end\n\n\n   if ( (pt.DIV_NEW == 1) & (pt.DIV_BIT == 4) )\n      begin\n        el2_exu_div_new_4bit_fullshortq         i_new_4bit_div_fullshortq       (\n            .clk              ( clk                      ),   // I\n            .rst_l            ( rst_l                    ),   // I\n            .scan_mode        ( scan_mode                ),   // I\n            .cancel           ( cancel                   ),   // I\n            .valid_in         ( dp.valid                 ),   // I\n            .signed_in        (~dp.unsign                ),   // I\n            .rem_in           ( dp.rem                   ),   // I\n            .dividend_in      ( dividend[31:0]           ),   // I\n            .divisor_in       ( divisor[31:0]            ),   // I\n            .valid_out        ( finish_dly               ),   // O\n            .data_out         ( out_raw[31:0]            ));  // O\n      end\n\n\n\nendmodule // el2_exu_div_ctl\n\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nmodule el2_exu_div_existing_1bit_cheapshortq\n  (\n   input  logic            clk,                       // Top level clock\n   input  logic            rst_l,                     // Reset\n   input  logic            scan_mode,                 // Scan mode\n\n   input  logic            cancel,                    // Flush pipeline\n   input  logic            valid_in,\n   input  logic            signed_in,\n   input  logic            rem_in,\n   input  logic [31:0]     dividend_in,\n   input  logic [31:0]     divisor_in,\n\n   output logic            valid_out,\n   output logic [31:0]     data_out\n  );\n\n\n   logic         div_clken;\n   logic         run_in, run_state;\n   logic  [5:0]  count_in, count;\n   logic [32:0]  m_ff;\n   logic         qff_enable;\n   logic         aff_enable;\n   logic [32:0]  q_in, q_ff;\n   logic [32:0]  a_in, a_ff;\n   logic [32:0]  m_eff;\n   logic [32:0]  a_shift;\n   logic         dividend_neg_ff, divisor_neg_ff;\n   logic [31:0]  dividend_comp;\n   logic [31:0]  dividend_eff;\n   logic [31:0]  q_ff_comp;\n   logic [31:0]  q_ff_eff;\n   logic [31:0]  a_ff_comp;\n   logic [31:0]  a_ff_eff;\n   logic         sign_ff, sign_eff;\n   logic         rem_ff;\n   logic         add;\n   logic [32:0]  a_eff;\n   logic [64:0]  a_eff_shift;\n   logic         rem_correct;\n   logic         valid_ff_x;\n   logic         valid_x;\n   logic         finish;\n   logic         finish_ff;\n\n   logic         smallnum_case, smallnum_case_ff;\n   logic  [3:0]  smallnum, smallnum_ff;\n   logic         m_already_comp;\n\n   logic [4:0]   a_cls;\n   logic [4:0]   b_cls;\n   logic [5:0]   shortq_shift;\n   logic [5:0]   shortq_shift_ff;\n   logic [5:0]   shortq;\n   logic         shortq_enable;\n   logic         shortq_enable_ff;\n   logic [32:0]  short_dividend;\n   logic [3:0]   shortq_raw;\n   logic [3:0]   shortq_shift_xx;\n\n\n\n   rvdffe #(23) i_misc_ff        (.*, .clk(clk), .en(div_clken),   .din ({valid_in & ~cancel,\n                                                                          finish   & ~cancel,\n                                                                          run_in,\n                                                                          count_in[5:0],\n                                                                          (valid_in & dividend_in[31]) | (~valid_in & dividend_neg_ff),\n                                                                          (valid_in & divisor_in[31] ) | (~valid_in & divisor_neg_ff ),\n                                                                          (valid_in & sign_eff       ) | (~valid_in & sign_ff        ),\n                                                                          (valid_in & rem_in         ) | (~valid_in & rem_ff         ),\n                                                                          smallnum_case,\n                                                                          smallnum[3:0],\n                                                                          shortq_enable,\n                                                                          shortq_shift[3:0]}),\n\n                                                                   .dout({valid_ff_x,\n                                                                          finish_ff,\n                                                                          run_state,\n                                                                          count[5:0],\n                                                                          dividend_neg_ff,\n                                                                          divisor_neg_ff,\n                                                                          sign_ff,\n                                                                          rem_ff,\n                                                                          smallnum_case_ff,\n                                                                          smallnum_ff[3:0],\n                                                                          shortq_enable_ff,\n                                                                          shortq_shift_xx[3:0]}));\n\n\n   rvdffe #(33) mff              (.*, .clk(clk), .en(valid_in),    .din({signed_in & divisor_in[31], divisor_in[31:0]}),   .dout(m_ff[32:0]));\n   rvdffe #(33) qff              (.*, .clk(clk), .en(qff_enable),  .din(q_in[32:0]),                                       .dout(q_ff[32:0]));\n   rvdffe #(33) aff              (.*, .clk(clk), .en(aff_enable),  .din(a_in[32:0]),                                       .dout(a_ff[32:0]));\n\n   rvtwoscomp #(32) i_dividend_comp (.din(q_ff[31:0]),    .dout(dividend_comp[31:0]));\n   rvtwoscomp #(32) i_q_ff_comp     (.din(q_ff[31:0]),    .dout(q_ff_comp[31:0]));\n   rvtwoscomp #(32) i_a_ff_comp     (.din(a_ff[31:0]),    .dout(a_ff_comp[31:0]));\n\n\n   assign valid_x                 = valid_ff_x & ~cancel;\n\n\n   // START - short circuit logic for small numbers {{\n\n   // small number divides - any 4b / 4b is done in 1 cycle (divisor != 0)\n   // to generate espresso equations:\n   // 1.  smalldiv > smalldiv.e\n   // 2.  espresso -Dso -oeqntott smalldiv.e | addassign > smalldiv\n\n   // smallnum case does not cover divide by 0\n   assign smallnum_case           = ((q_ff[31:4] == 28'b0) & (m_ff[31:4] == 28'b0) & (m_ff[31:0] != 32'b0) & ~rem_ff & valid_x) |\n                                    ((q_ff[31:0] == 32'b0) &                         (m_ff[31:0] != 32'b0) & ~rem_ff & valid_x);\n\n\n   assign smallnum[3]             = ( q_ff[3] &                                  ~m_ff[3] & ~m_ff[2] & ~m_ff[1]           );\n\n\n   assign smallnum[2]             = ( q_ff[3] &                                  ~m_ff[3] & ~m_ff[2] &            ~m_ff[0]) |\n                                    ( q_ff[2] &                                  ~m_ff[3] & ~m_ff[2] & ~m_ff[1]           ) |\n                                    ( q_ff[3] &  q_ff[2] &                       ~m_ff[3] & ~m_ff[2]                      );\n\n\n   assign smallnum[1]             = ( q_ff[2] &                                  ~m_ff[3] & ~m_ff[2] &            ~m_ff[0]) |\n                                    (                       q_ff[1] &            ~m_ff[3] & ~m_ff[2] & ~m_ff[1]           ) |\n                                    ( q_ff[3] &                                  ~m_ff[3] &            ~m_ff[1] & ~m_ff[0]) |\n                                    ( q_ff[3] & ~q_ff[2] &                       ~m_ff[3] & ~m_ff[2] &  m_ff[1] &  m_ff[0]) |\n                                    (~q_ff[3] &  q_ff[2] &  q_ff[1] &            ~m_ff[3] & ~m_ff[2]                      ) |\n                                    ( q_ff[3] &  q_ff[2] &                       ~m_ff[3] &                       ~m_ff[0]) |\n                                    ( q_ff[3] &  q_ff[2] &                       ~m_ff[3] &  m_ff[2] & ~m_ff[1]           ) |\n                                    ( q_ff[3] &             q_ff[1] & ~m_ff[3] &                       ~m_ff[1]           ) |\n                                    ( q_ff[3] &  q_ff[2] &  q_ff[1] &            ~m_ff[3] &  m_ff[2]                      );\n\n\n   assign smallnum[0]             = (            q_ff[2] &  q_ff[1] &  q_ff[0] & ~m_ff[3] &            ~m_ff[1]           ) |\n                                    ( q_ff[3] & ~q_ff[2] &  q_ff[0] &            ~m_ff[3] &             m_ff[1] &  m_ff[0]) |\n                                    (            q_ff[2] &                       ~m_ff[3] &            ~m_ff[1] & ~m_ff[0]) |\n                                    (                       q_ff[1] &            ~m_ff[3] & ~m_ff[2] &            ~m_ff[0]) |\n                                    (                                  q_ff[0] & ~m_ff[3] & ~m_ff[2] & ~m_ff[1]           ) |\n                                    (~q_ff[3] &  q_ff[2] & ~q_ff[1] &            ~m_ff[3] & ~m_ff[2] &  m_ff[1] &  m_ff[0]) |\n                                    (~q_ff[3] &  q_ff[2] &  q_ff[1] &            ~m_ff[3] &                       ~m_ff[0]) |\n                                    ( q_ff[3] &                                             ~m_ff[2] & ~m_ff[1] & ~m_ff[0]) |\n                                    ( q_ff[3] & ~q_ff[2] &                       ~m_ff[3] &  m_ff[2] &  m_ff[1]           ) |\n                                    (~q_ff[3] &  q_ff[2] &  q_ff[1] &            ~m_ff[3] &  m_ff[2] & ~m_ff[1]           ) |\n                                    (~q_ff[3] &  q_ff[2] &             q_ff[0] & ~m_ff[3] &            ~m_ff[1]           ) |\n                                    ( q_ff[3] & ~q_ff[2] & ~q_ff[1] &            ~m_ff[3] &  m_ff[2] &             m_ff[0]) |\n                                    (           ~q_ff[2] &  q_ff[1] &  q_ff[0] & ~m_ff[3] & ~m_ff[2]                      ) |\n                                    ( q_ff[3] &  q_ff[2] &                                             ~m_ff[1] & ~m_ff[0]) |\n                                    ( q_ff[3] &             q_ff[1] &                       ~m_ff[2] &            ~m_ff[0]) |\n                                    (~q_ff[3] &  q_ff[2] &  q_ff[1] &  q_ff[0] & ~m_ff[3] &  m_ff[2]                      ) |\n                                    ( q_ff[3] &  q_ff[2] &                        m_ff[3] & ~m_ff[2]                      ) |\n                                    ( q_ff[3] &             q_ff[1] &             m_ff[3] & ~m_ff[2] & ~m_ff[1]           ) |\n                                    ( q_ff[3] &                        q_ff[0] &            ~m_ff[2] & ~m_ff[1]           ) |\n                                    ( q_ff[3] &            ~q_ff[1] &            ~m_ff[3] &  m_ff[2] &  m_ff[1] &  m_ff[0]) |\n                                    ( q_ff[3] &  q_ff[2] &  q_ff[1] &             m_ff[3] &                       ~m_ff[0]) |\n                                    ( q_ff[3] &  q_ff[2] &  q_ff[1] &             m_ff[3] &            ~m_ff[1]           ) |\n                                    ( q_ff[3] &  q_ff[2] &             q_ff[0] &  m_ff[3] &            ~m_ff[1]           ) |\n                                    ( q_ff[3] & ~q_ff[2] &  q_ff[1] &            ~m_ff[3] &             m_ff[1]           ) |\n                                    ( q_ff[3] &             q_ff[1] &  q_ff[0] &            ~m_ff[2]                      ) |\n                                    ( q_ff[3] &  q_ff[2] &  q_ff[1] &  q_ff[0] &  m_ff[3]                                 );\n\n\n   // END   - short circuit logic for small numbers }}\n\n\n   // *** Start Short Q *** {{\n\n   assign short_dividend[31:0]    =  q_ff[31:0];\n   assign short_dividend[32]      =  sign_ff & q_ff[31];\n\n\n   //    A       B\n   //   210     210    SH\n   //   ---     ---    --\n   //   1xx     000     0\n   //   1xx     001     8\n   //   1xx     01x    16\n   //   1xx     1xx    24\n   //   01x     000     8\n   //   01x     001    16\n   //   01x     01x    24\n   //   01x     1xx    32\n   //   001     000    16\n   //   001     001    24\n   //   001     01x    32\n   //   001     1xx    32\n   //   000     000    24\n   //   000     001    32\n   //   000     01x    32\n   //   000     1xx    32\n\n   assign a_cls[4:3]              =  2'b0;\n   assign a_cls[2]                =  (~short_dividend[32] & (short_dividend[31:24] != {8{1'b0}})) | ( short_dividend[32] & (short_dividend[31:23] != {9{1'b1}}));\n   assign a_cls[1]                =  (~short_dividend[32] & (short_dividend[23:16] != {8{1'b0}})) | ( short_dividend[32] & (short_dividend[22:15] != {8{1'b1}}));\n   assign a_cls[0]                =  (~short_dividend[32] & (short_dividend[15:08] != {8{1'b0}})) | ( short_dividend[32] & (short_dividend[14:07] != {8{1'b1}}));\n\n   assign b_cls[4:3]              =  2'b0;\n   assign b_cls[2]                =  (~m_ff[32]           & (          m_ff[31:24] != {8{1'b0}})) | ( m_ff[32]           & (          m_ff[31:24] != {8{1'b1}}));\n   assign b_cls[1]                =  (~m_ff[32]           & (          m_ff[23:16] != {8{1'b0}})) | ( m_ff[32]           & (          m_ff[23:16] != {8{1'b1}}));\n   assign b_cls[0]                =  (~m_ff[32]           & (          m_ff[15:08] != {8{1'b0}})) | ( m_ff[32]           & (          m_ff[15:08] != {8{1'b1}}));\n\n   assign shortq_raw[3]           = ( (a_cls[2:1] == 2'b01 ) & (b_cls[2]   == 1'b1  ) ) |   // Shift by 32\n                                    ( (a_cls[2:0] == 3'b001) & (b_cls[2]   == 1'b1  ) ) |\n                                    ( (a_cls[2:0] == 3'b000) & (b_cls[2]   == 1'b1  ) ) |\n                                    ( (a_cls[2:0] == 3'b001) & (b_cls[2:1] == 2'b01 ) ) |\n                                    ( (a_cls[2:0] == 3'b000) & (b_cls[2:1] == 2'b01 ) ) |\n                                    ( (a_cls[2:0] == 3'b000) & (b_cls[2:0] == 3'b001) );\n\n   assign shortq_raw[2]           = ( (a_cls[2]   == 1'b1  ) & (b_cls[2]   == 1'b1  ) ) |   // Shift by 24\n                                    ( (a_cls[2:1] == 2'b01 ) & (b_cls[2:1] == 2'b01 ) ) |\n                                    ( (a_cls[2:0] == 3'b001) & (b_cls[2:0] == 3'b001) ) |\n                                    ( (a_cls[2:0] == 3'b000) & (b_cls[2:0] == 3'b000) );\n\n   assign shortq_raw[1]           = ( (a_cls[2]   == 1'b1  ) & (b_cls[2:1] == 2'b01 ) ) |   // Shift by 16\n                                    ( (a_cls[2:1] == 2'b01 ) & (b_cls[2:0] == 3'b001) ) |\n                                    ( (a_cls[2:0] == 3'b001) & (b_cls[2:0] == 3'b000) );\n\n   assign shortq_raw[0]           = ( (a_cls[2]   == 1'b1  ) & (b_cls[2:0] == 3'b001) ) |   // Shift by  8\n                                    ( (a_cls[2:1] == 2'b01 ) & (b_cls[2:0] == 3'b000) );\n\n\n   assign shortq_enable           =  valid_ff_x & (m_ff[31:0] != 32'b0) & (shortq_raw[3:0] != 4'b0);\n\n   assign shortq_shift[3:0]       = ({4{shortq_enable}} & shortq_raw[3:0]);\n\n   assign shortq[5:0]             =  6'b0;\n   assign shortq_shift[5:4]       =  2'b0;\n   assign shortq_shift_ff[5]      =  1'b0;\n\n   assign shortq_shift_ff[4:0]    = ({5{shortq_shift_xx[3]}} & 5'b1_1111) |   /"}
{"text": "/ 31\n                                    ({5{shortq_shift_xx[2]}} & 5'b1_1000) |   // 24\n                                    ({5{shortq_shift_xx[1]}} & 5'b1_0000) |   // 16\n                                    ({5{shortq_shift_xx[0]}} & 5'b0_1000);    //  8\n\n   // *** End   Short *** }}\n\n\n\n\n\n   assign div_clken               =  valid_in | run_state | finish | finish_ff;\n\n   assign run_in                  = (valid_in | run_state) & ~finish & ~cancel;\n\n   assign count_in[5:0]           = {6{run_state & ~finish & ~cancel & ~shortq_enable}} & (count[5:0] + {1'b0,shortq_shift_ff[4:0]} + 6'd1);\n\n\n   assign finish                  = (smallnum_case | ((~rem_ff) ? (count[5:0] == 6'd32) : (count[5:0] == 6'd33)));\n\n   assign valid_out               =  finish_ff & ~cancel;\n\n   assign sign_eff                =  signed_in & (divisor_in[31:0] != 32'b0);\n\n\n   assign q_in[32:0]              = ({33{~run_state                                   }} &  {1'b0,dividend_in[31:0]}) |\n                                    ({33{ run_state &  (valid_ff_x | shortq_enable_ff)}} &  ({dividend_eff[31:0], ~a_in[32]} << shortq_shift_ff[4:0])) |\n                                    ({33{ run_state & ~(valid_ff_x | shortq_enable_ff)}} &  {q_ff[31:0], ~a_in[32]});\n\n   assign qff_enable              =  valid_in | (run_state & ~shortq_enable);\n\n\n\n\n   assign dividend_eff[31:0]      = (sign_ff & dividend_neg_ff) ? dividend_comp[31:0] : q_ff[31:0];\n\n\n   assign m_eff[32:0]             = ( add ) ? m_ff[32:0] : ~m_ff[32:0];\n\n   assign a_eff_shift[64:0]       = {33'b0, dividend_eff[31:0]} << shortq_shift_ff[4:0];\n\n   assign a_eff[32:0]             = ({33{ rem_correct                    }} &  a_ff[32:0]            ) |\n                                    ({33{~rem_correct & ~shortq_enable_ff}} & {a_ff[31:0], q_ff[32]} ) |\n                                    ({33{~rem_correct &  shortq_enable_ff}} &  a_eff_shift[64:32]    );\n\n   assign a_shift[32:0]           = {33{run_state}} & a_eff[32:0];\n\n   assign a_in[32:0]              = {33{run_state}} & (a_shift[32:0] + m_eff[32:0] + {32'b0,~add});\n\n   assign aff_enable              =  valid_in | (run_state & ~shortq_enable & (count[5:0]!=6'd33)) | rem_correct;\n\n\n   assign m_already_comp          = (divisor_neg_ff & sign_ff);\n\n   // if m already complemented, then invert operation add->sub, sub->add\n   assign add                     = (a_ff[32] | rem_correct) ^ m_already_comp;\n\n   assign rem_correct             = (count[5:0] == 6'd33) & rem_ff & a_ff[32];\n\n\n\n   assign q_ff_eff[31:0]          = (sign_ff & (dividend_neg_ff ^ divisor_neg_ff)) ? q_ff_comp[31:0] : q_ff[31:0];\n\n   assign a_ff_eff[31:0]          = (sign_ff &  dividend_neg_ff) ? a_ff_comp[31:0] : a_ff[31:0];\n\n   assign data_out[31:0]          = ({32{ smallnum_case_ff          }} & {28'b0, smallnum_ff[3:0]}) |\n                                    ({32{                     rem_ff}} &  a_ff_eff[31:0]          ) |\n                                    ({32{~smallnum_case_ff & ~rem_ff}} &  q_ff_eff[31:0]          );\n\n\n\n\nendmodule // el2_exu_div_existing_1bit_cheapshortq\n\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nmodule el2_exu_div_new_1bit_fullshortq\n  (\n   input  logic            clk,                       // Top level clock\n   input  logic            rst_l,                     // Reset\n   input  logic            scan_mode,                 // Scan mode\n\n   input  logic            cancel,                    // Flush pipeline\n   input  logic            valid_in,\n   input  logic            signed_in,\n   input  logic            rem_in,\n   input  logic [31:0]     dividend_in,\n   input  logic [31:0]     divisor_in,\n\n   output logic            valid_out,\n   output logic [31:0]     data_out\n  );\n\n\n   logic                   valid_ff_in, valid_ff;\n   logic                   finish_raw, finish, finish_ff;\n   logic                   running_state;\n   logic                   misc_enable;\n   logic         [2:0]     control_in, control_ff;\n   logic                   dividend_sign_ff, divisor_sign_ff, rem_ff;\n   logic                   count_enable;\n   logic         [6:0]     count_in, count_ff;\n\n   logic                   smallnum_case;\n   logic         [3:0]     smallnum;\n\n   logic                   a_enable, a_shift;\n   logic        [31:0]     a_in, a_ff;\n\n   logic                   b_enable, b_twos_comp;\n   logic        [32:0]     b_in, b_ff;\n\n   logic        [31:0]     q_in, q_ff;\n\n   logic                   rq_enable, r_sign_sel, r_restore_sel, r_adder_sel;\n   logic        [31:0]     r_in, r_ff;\n\n   logic                   twos_comp_q_sel, twos_comp_b_sel;\n   logic        [31:0]     twos_comp_in, twos_comp_out;\n\n   logic                   quotient_set;\n   logic        [32:0]     adder_out;\n\n   logic        [63:0]     ar_shifted;\n   logic         [5:0]     shortq;\n   logic         [4:0]     shortq_shift;\n   logic         [4:0]     shortq_shift_ff;\n   logic                   shortq_enable;\n   logic                   shortq_enable_ff;\n   logic        [32:0]     shortq_dividend;\n\n   logic                   by_zero_case;\n   logic                   by_zero_case_ff;\n\n\n\n   rvdffe #(19) i_misc_ff        (.*, .clk(clk), .en(misc_enable),    .din ({valid_ff_in, control_in[2:0], by_zero_case,    shortq_enable,    shortq_shift[4:0],    finish,    count_in[6:0]}),\n                                                                      .dout({valid_ff,    control_ff[2:0], by_zero_case_ff, shortq_enable_ff, shortq_shift_ff[4:0], finish_ff, count_ff[6:0]}));\n\n   rvdffe #(32) i_a_ff           (.*, .clk(clk), .en(a_enable),       .din(a_in[31:0]),           .dout(a_ff[31:0]));\n   rvdffe #(33) i_b_ff           (.*, .clk(clk), .en(b_enable),       .din(b_in[32:0]),           .dout(b_ff[32:0]));\n   rvdffe #(32) i_r_ff           (.*, .clk(clk), .en(rq_enable),      .din(r_in[31:0]),           .dout(r_ff[31:0]));\n   rvdffe #(32) i_q_ff           (.*, .clk(clk), .en(rq_enable),      .din(q_in[31:0]),           .dout(q_ff[31:0]));\n\n\n\n\n   assign valid_ff_in            =  valid_in  & ~cancel;\n\n   assign control_in[2]          = (~valid_in & control_ff[2]) | (valid_in & signed_in  & dividend_in[31]);\n   assign control_in[1]          = (~valid_in & control_ff[1]) | (valid_in & signed_in  &  divisor_in[31]);\n   assign control_in[0]          = (~valid_in & control_ff[0]) | (valid_in & rem_in);\n\n   assign dividend_sign_ff       =  control_ff[2];\n   assign divisor_sign_ff        =  control_ff[1];\n   assign rem_ff                 =  control_ff[0];\n\n\n   assign by_zero_case           =  valid_ff & (b_ff[31:0] == 32'b0);\n\n   assign misc_enable            =  valid_in | valid_ff | cancel | running_state | finish_ff;\n   assign running_state          = (| count_ff[6:0]) | shortq_enable_ff;\n   assign finish_raw             =   smallnum_case      |\n                                     by_zero_case       |\n                                    (count_ff[6:0] == 7'd32);\n\n\n   assign finish                 =  finish_raw & ~cancel;\n   assign count_enable           = (valid_ff | running_state) & ~finish & ~finish_ff & ~cancel & ~shortq_enable;\n   assign count_in[6:0]          = {7{count_enable}} & (count_ff[6:0] + {6'b0,1'b1} + {2'b0,shortq_shift_ff[4:0]});\n\n\n   assign a_enable               =  valid_in | running_state;\n   assign a_shift                =  running_state & ~shortq_enable_ff;\n\n   assign ar_shifted[63:0]       = { {32{dividend_sign_ff}} , a_ff[31:0]} << shortq_shift_ff[4:0];\n\n   assign a_in[31:0]             = ( {32{~a_shift & ~shortq_enable_ff}} &  dividend_in[31:0] ) |\n                                   ( {32{ a_shift                    }} & {a_ff[30:0],1'b0}  ) |\n                                   ( {32{            shortq_enable_ff}} &  ar_shifted[31:0]  );\n\n\n\n   assign b_enable               =    valid_in | b_twos_comp;\n   assign b_twos_comp            =    valid_ff & ~(dividend_sign_ff ^ divisor_sign_ff);\n\n   assign b_in[32:0]             = ( {33{~b_twos_comp}} & { (signed_in & divisor_in[31]),divisor_in[31:0] } ) |\n                                   ( {33{ b_twos_comp}} & {~divisor_sign_ff,twos_comp_out[31:0] } );\n\n\n   assign rq_enable              =  valid_in | valid_ff | running_state;\n   assign r_sign_sel             =  valid_ff      &  dividend_sign_ff & ~by_zero_case;\n   assign r_restore_sel          =  running_state & ~quotient_set & ~shortq_enable_ff;\n   assign r_adder_sel            =  running_state &  quotient_set & ~shortq_enable_ff;\n\n\n   assign r_in[31:0]             = ( {32{r_sign_sel      }} &  32'hffffffff          ) |\n                                   ( {32{r_restore_sel   }} & {r_ff[30:0] ,a_ff[31]} ) |\n                                   ( {32{r_adder_sel     }} &  adder_out[31:0]       ) |\n                                   ( {32{shortq_enable_ff}} &  ar_shifted[63:32]     ) |\n                                   ( {32{by_zero_case    }} &  a_ff[31:0]            );\n\n\n   assign q_in[31:0]             = ( {32{~valid_ff       }} & {q_ff[30:0], quotient_set}  ) |\n                                   ( {32{ smallnum_case  }} & {28'b0     , smallnum[3:0]} ) |\n                                   ( {32{ by_zero_case   }} & {32{1'b1}}                  );\n\n\n\n   assign adder_out[32:0]        = {r_ff[31:0],a_ff[31]} + {b_ff[32:0] };\n\n\n   assign quotient_set           = (~adder_out[32] ^ dividend_sign_ff) | ( (a_ff[30:0] == 31'b0) & (adder_out[32:0] == 33'b0) );\n\n\n\n   assign twos_comp_b_sel        =  valid_ff           & ~(dividend_sign_ff ^ divisor_sign_ff);\n   assign twos_comp_q_sel        = ~valid_ff & ~rem_ff &  (dividend_sign_ff ^ divisor_sign_ff) & ~by_zero_case_ff;\n\n   assign twos_comp_in[31:0]     = ( {32{twos_comp_q_sel}} & q_ff[31:0] ) |\n                                   ( {32{twos_comp_b_sel}} & b_ff[31:0] );\n\n   rvtwoscomp #(32) i_twos_comp  (.din(twos_comp_in[31:0]), .dout(twos_comp_out[31:0]));\n\n\n\n   assign valid_out              =  finish_ff & ~cancel;\n\n   assign data_out[31:0]         = ( {32{~rem_ff & ~twos_comp_q_sel}} & q_ff[31:0]          ) |\n                                   ( {32{ rem_ff                   }} & r_ff[31:0]          ) |\n                                   ( {32{           twos_comp_q_sel}} & twos_comp_out[31:0] );\n\n\n\n\n   // *** *** *** START : SMALLNUM {{\n\n   assign smallnum_case          = ( (a_ff[31:4]  == 28'b0) & (b_ff[31:4] == 28'b0) & ~by_zero_case & ~rem_ff & valid_ff & ~cancel) |\n                                   ( (a_ff[31:0]  == 32'b0) &                         ~by_zero_case & ~rem_ff & valid_ff & ~cancel);\n\n   assign smallnum[3]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           );\n\n   assign smallnum[2]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] & ~b_ff[2]                      );\n\n   assign smallnum[1]            = (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                                  ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &            ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2]                      );\n\n   assign smallnum[0]            = (            a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &             a_ff[0] & ~b_ff[3] &             b_ff[1] &  b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                                  a_ff[0] & ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] & ~a_ff[1] &            ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &                                             ~b_ff[2] & ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] &  b_ff[2] &  b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &             a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] & ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &             b_ff[0]) |\n                                   (           ~a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                                             ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] &             a_ff[1] &                       ~b_ff[2] &            ~b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &  b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                        b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &             a_ff[1] &             b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                        a_ff[0] &            ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &            ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &             a_ff[0] &  b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &  a_ff[1] &            ~b_ff[3] &             b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &  a_ff[0] &            ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] &  b_ff[3]                                 );\n\n   // *** *** *** END   : SMALLNUM }}\n\n\n\n\n   // *** *** *** Start : Short Q {{\n\n   assign shortq_dividend[32:0]   = {dividend_sign_ff,a_ff[31:0]};\n\n\n   logic [5:0]  dw_a_enc;\n   logic [5:0]  dw_b_enc;\n   logic [6:0]  dw_shortq_raw;\n\n\n\n   el2_exu_div_cls i_a_cls  (\n       .operand  ( shortq_dividend[32:0]  ),\n       .cls      ( dw_a_enc[4:0]          ));\n\n   el2_exu_div_cls i_b_cls  (\n       .operand  ( b_ff[32:0]             ),\n       .cls      ( dw_b_enc[4:0]          ));\n\n   assign dw_a_enc[5]             =  1'b0;\n   assign dw_b_enc[5]             =  1'b0;\n\n\n\n   assign dw_shortq_raw[6:0]      =  {1'b0,dw_b_enc[5:0]} - {1'b0,dw_a_enc[5:0]} + 7'd1;\n   assign shortq[5:0]             =  dw_shortq_raw[6]  ?  6'd0  :  dw_shortq_raw[5:0];\n\n   assign shortq_enable           =  valid_ff & ~shortq[5] & ~(shortq[4:1] ==  4'b1111) & ~cancel;\n\n   assign shortq_shift[4:0]       = ~shortq_enable     ?  5'd0  :  (5'b11111 - shortq[4:0]);\n\n\n   // *** *** *** End   : Short Q }}\n\n\n\n\n\nendmodule // el2_exu_div_new_1bit_fullshortq\n\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nmodule el2_exu_div_new_2bit_fullshortq\n  (\n   input  logic            clk,                       // Top level clock\n   input  logic            rst_l,                     // Reset\n   input  logic            scan_mode,                 // Scan mode\n\n   input  logic            cancel,                    // Flush pipeline\n   input  logic            valid_in,\n   input  logic            signed_in,\n   input  logic            rem_in,\n   input  logic [31:0]     dividend_in,\n   input  logic [31:0]     divisor_in,\n\n   output logic            valid_out,\n   output logic [31:0]     data_out\n  );\n\n\n   logic                   valid_ff_in, valid_ff;\n   logic                   finish_raw, finish, finish_ff;\n   logic                   running_state;\n   logic                   misc_enable;\n   logic         [2:0]     control_in, control_ff;\n   logic                   dividend_sign_ff, divisor_sign_ff, rem_ff;\n   logic                   count_enable;\n   logic         [6:0]     count_in, count_ff;\n\n   logic                   smallnum_case;\n   logic         [3:0]     smallnum;\n\n   logic                   a_enable, a_shift;\n   logic        [31:0]     a_in, a_ff;\n\n   logic                   b_enable, b_twos_comp;\n   logic        [32:0]     b_in;\n   logic        [34:0]     b_ff;\n\n   logic        [31:0]     q_in, q_ff;\n\n   logic                   rq_enable, r_sign_sel, r_restore_sel, r_adder1_sel, r_adder2_sel, r_adder3_sel;\n   logic        [31:0]     r_in, r_ff;\n\n   logic                   twos_comp_q_sel, twos_comp_b_sel;\n   logic        [31:0]     twos_comp_in, twos_comp_out;\n\n   logic         [3:1]     quotient_raw;\n   logic         [1:0]     quotient_new;\n   logic        [32:0]     adder1_out;\n   logic        [33:0]     adder2_out;\n   logic        [34:0]     adder3_out;\n\n   logic        [63:0]     ar_shifted;\n   logic         [5:0]     shortq;\n   logic         [4:0]     shortq_shift;\n   logic         [4:1]     shortq_shift_ff;\n   logic                   shortq_enable;\n   logic                   shortq_enable_ff;\n   logic        [32:0]     shortq_dividend;\n\n   logic                   by_zero_case;\n   logic                   by_zero_case_ff;\n\n\n\n   rvdffe #(18) i_misc_ff        (.*, .clk(clk), .en(misc_enable),    .din ({valid_ff_in, control_in[2:0], by_zero_case,    shortq_enable,    shortq_shift[4:1],    finish,    count_in[6:0]}),\n                                                                      .dout({valid_ff,    control_ff[2:0], by_zero_case_ff, shortq_enable_ff, shortq_shift_ff[4:1], finish_ff, count_ff[6:0]}));\n\n   rvdffe #(32) i_a_ff           (.*, .clk(clk), .en(a_enable),       .din(a_in[31:0]),           .dout(a_ff[31:0]));\n   rvdffe #(33) i_b_ff           (.*, .clk(clk), .en(b_enable),       .din(b_in[32:0]),           .dout(b_ff[32:0]));\n   rvdffe #(32) i_r_ff           (.*, .clk(clk), .en(rq_enable),      .din(r_in[31:0]),           .dout(r_ff[31:0]));\n   rvdffe #(32) i_q_ff           (.*, .clk(clk), .en(rq_enable),      .din(q_in[31:0]),           .dout(q_ff[31:0]));\n\n\n\n\n   assign valid_ff_in            =  valid_in  & ~cancel;\n\n   assign control_in[2]          = (~valid_in & control_ff[2]) | (valid_in & signed_in  & dividend_in[31]);\n   assign control_in[1]          = (~valid_in & control_ff[1]) | (valid_in & signed_in  &  divisor_in[31]);\n   assign control_in[0]          = (~valid_in & control_ff[0]) | (valid_in & rem_in);\n\n   assign dividend_sign_ff       =  control_ff[2];\n   assign divisor_sign_ff        =  control_ff[1];\n   assign rem_ff                 = "}
{"text": " control_ff[0];\n\n\n   assign by_zero_case           =  valid_ff & (b_ff[31:0] == 32'b0);\n\n   assign misc_enable            =  valid_in | valid_ff | cancel | running_state | finish_ff;\n   assign running_state          = (| count_ff[6:0]) | shortq_enable_ff;\n   assign finish_raw             =   smallnum_case      |\n                                     by_zero_case       |\n                                    (count_ff[6:0] == 7'd32);\n\n\n   assign finish                 =  finish_raw & ~cancel;\n   assign count_enable           = (valid_ff | running_state) & ~finish & ~finish_ff & ~cancel & ~shortq_enable;\n   assign count_in[6:0]          = {7{count_enable}} & (count_ff[6:0] + {5'b0,2'b10} + {2'b0,shortq_shift_ff[4:1],1'b0});\n\n\n   assign a_enable               =  valid_in | running_state;\n   assign a_shift                =  running_state & ~shortq_enable_ff;\n\n   assign ar_shifted[63:0]       = { {32{dividend_sign_ff}} , a_ff[31:0]} << {shortq_shift_ff[4:1],1'b0};\n\n   assign a_in[31:0]             = ( {32{~a_shift & ~shortq_enable_ff}} &  dividend_in[31:0] ) |\n                                   ( {32{ a_shift                    }} & {a_ff[29:0],2'b0}  ) |\n                                   ( {32{            shortq_enable_ff}} &  ar_shifted[31:0]  );\n\n\n\n   assign b_enable               =    valid_in | b_twos_comp;\n   assign b_twos_comp            =    valid_ff & ~(dividend_sign_ff ^ divisor_sign_ff);\n\n   assign b_in[32:0]             = ( {33{~b_twos_comp}} & { (signed_in & divisor_in[31]),divisor_in[31:0] } ) |\n                                   ( {33{ b_twos_comp}} & {~divisor_sign_ff,twos_comp_out[31:0] } );\n\n\n   assign rq_enable              =  valid_in | valid_ff | running_state;\n   assign r_sign_sel             =  valid_ff      &  dividend_sign_ff & ~by_zero_case;\n   assign r_restore_sel          =  running_state & (quotient_new[1:0] == 2'b00) & ~shortq_enable_ff;\n   assign r_adder1_sel           =  running_state & (quotient_new[1:0] == 2'b01) & ~shortq_enable_ff;\n   assign r_adder2_sel           =  running_state & (quotient_new[1:0] == 2'b10) & ~shortq_enable_ff;\n   assign r_adder3_sel           =  running_state & (quotient_new[1:0] == 2'b11) & ~shortq_enable_ff;\n\n\n   assign r_in[31:0]             = ( {32{r_sign_sel      }} &  32'hffffffff             ) |\n                                   ( {32{r_restore_sel   }} & {r_ff[29:0] ,a_ff[31:30]} ) |\n                                   ( {32{r_adder1_sel    }} &  adder1_out[31:0]         ) |\n                                   ( {32{r_adder2_sel    }} &  adder2_out[31:0]         ) |\n                                   ( {32{r_adder3_sel    }} &  adder3_out[31:0]         ) |\n                                   ( {32{shortq_enable_ff}} &  ar_shifted[63:32]        ) |\n                                   ( {32{by_zero_case    }} &  a_ff[31:0]               );\n\n\n   assign q_in[31:0]             = ( {32{~valid_ff       }} & {q_ff[29:0], quotient_new[1:0]} ) |\n                                   ( {32{ smallnum_case  }} & {28'b0     , smallnum[3:0]}     ) |\n                                   ( {32{ by_zero_case   }} & {32{1'b1}}                      );\n\n\n   assign b_ff[34:33]            = {b_ff[32],b_ff[32]};\n\n\n   assign adder1_out[32:0]       = {         r_ff[30:0],a_ff[31:30]}  +                       b_ff[32:0];\n   assign adder2_out[33:0]       = {         r_ff[31:0],a_ff[31:30]}  + {b_ff[32:0],1'b0};\n   assign adder3_out[34:0]       = {r_ff[31],r_ff[31:0],a_ff[31:30]}  + {b_ff[33:0],1'b0}  +  b_ff[34:0];\n\n\n   assign quotient_raw[1]        = (~adder1_out[32] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder1_out[32:0] == 33'b0) );\n   assign quotient_raw[2]        = (~adder2_out[33] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder2_out[33:0] == 34'b0) );\n   assign quotient_raw[3]        = (~adder3_out[34] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder3_out[34:0] == 35'b0) );\n\n   assign quotient_new[1]        = quotient_raw[3] |  quotient_raw[2];\n   assign quotient_new[0]        = quotient_raw[3] |(~quotient_raw[2] & quotient_raw[1]);\n\n\n   assign twos_comp_b_sel        =  valid_ff           & ~(dividend_sign_ff ^ divisor_sign_ff);\n   assign twos_comp_q_sel        = ~valid_ff & ~rem_ff &  (dividend_sign_ff ^ divisor_sign_ff) & ~by_zero_case_ff;\n\n   assign twos_comp_in[31:0]     = ( {32{twos_comp_q_sel}} & q_ff[31:0] ) |\n                                   ( {32{twos_comp_b_sel}} & b_ff[31:0] );\n\n   rvtwoscomp #(32) i_twos_comp  (.din(twos_comp_in[31:0]), .dout(twos_comp_out[31:0]));\n\n\n\n   assign valid_out              =  finish_ff & ~cancel;\n\n   assign data_out[31:0]         = ( {32{~rem_ff & ~twos_comp_q_sel}} & q_ff[31:0]          ) |\n                                   ( {32{ rem_ff                   }} & r_ff[31:0]          ) |\n                                   ( {32{           twos_comp_q_sel}} & twos_comp_out[31:0] );\n\n\n\n\n   // *** *** *** START : SMALLNUM {{\n\n   assign smallnum_case          = ( (a_ff[31:4]  == 28'b0) & (b_ff[31:4] == 28'b0) & ~by_zero_case & ~rem_ff & valid_ff & ~cancel) |\n                                   ( (a_ff[31:0]  == 32'b0) &                         ~by_zero_case & ~rem_ff & valid_ff & ~cancel);\n\n   assign smallnum[3]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           );\n\n   assign smallnum[2]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] & ~b_ff[2]                      );\n\n   assign smallnum[1]            = (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                                  ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &            ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2]                      );\n\n   assign smallnum[0]            = (            a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &             a_ff[0] & ~b_ff[3] &             b_ff[1] &  b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                                  a_ff[0] & ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] & ~a_ff[1] &            ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &                                             ~b_ff[2] & ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] &  b_ff[2] &  b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &             a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] & ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &             b_ff[0]) |\n                                   (           ~a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                                             ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] &             a_ff[1] &                       ~b_ff[2] &            ~b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &  b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                        b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &             a_ff[1] &             b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                        a_ff[0] &            ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &            ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &             a_ff[0] &  b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &  a_ff[1] &            ~b_ff[3] &             b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &  a_ff[0] &            ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] &  b_ff[3]                                 );\n\n   // *** *** *** END   : SMALLNUM }}\n\n\n\n\n   // *** *** *** Start : Short Q {{\n\n   assign shortq_dividend[32:0]   = {dividend_sign_ff,a_ff[31:0]};\n\n\n   logic [5:0]  dw_a_enc;\n   logic [5:0]  dw_b_enc;\n   logic [6:0]  dw_shortq_raw;\n\n\n\n   el2_exu_div_cls i_a_cls  (\n       .operand  ( shortq_dividend[32:0]  ),\n       .cls      ( dw_a_enc[4:0]          ));\n\n   el2_exu_div_cls i_b_cls  (\n       .operand  ( b_ff[32:0]             ),\n       .cls      ( dw_b_enc[4:0]          ));\n\n   assign dw_a_enc[5]             =  1'b0;\n   assign dw_b_enc[5]             =  1'b0;\n\n\n\n   assign dw_shortq_raw[6:0]      =  {1'b0,dw_b_enc[5:0]} - {1'b0,dw_a_enc[5:0]} + 7'd1;\n   assign shortq[5:0]             =  dw_shortq_raw[6]  ?  6'd0  :  dw_shortq_raw[5:0];\n\n   assign shortq_enable           =  valid_ff & ~shortq[5] & ~(shortq[4:1] ==  4'b1111) & ~cancel;\n\n   assign shortq_shift[4:0]       = ~shortq_enable     ?  5'd0  :  (5'b11111 - shortq[4:0]);   // [0] is unused\n\n\n   // *** *** *** End   : Short Q }}\n\n\n\n\n\nendmodule // el2_exu_div_new_2bit_fullshortq\n\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nmodule el2_exu_div_new_3bit_fullshortq\n  (\n   input  logic            clk,                       // Top level clock\n   input  logic            rst_l,                     // Reset\n   input  logic            scan_mode,                 // Scan mode\n\n   input  logic            cancel,                    // Flush pipeline\n   input  logic            valid_in,\n   input  logic            signed_in,\n   input  logic            rem_in,\n   input  logic [31:0]     dividend_in,\n   input  logic [31:0]     divisor_in,\n\n   output logic            valid_out,\n   output logic [31:0]     data_out\n  );\n\n\n   logic                   valid_ff_in, valid_ff;\n   logic                   finish_raw, finish, finish_ff;\n   logic                   running_state;\n   logic                   misc_enable;\n   logic         [2:0]     control_in, control_ff;\n   logic                   dividend_sign_ff, divisor_sign_ff, rem_ff;\n   logic                   count_enable;\n   logic         [6:0]     count_in, count_ff;\n\n   logic                   smallnum_case;\n   logic         [3:0]     smallnum;\n\n   logic                   a_enable, a_shift;\n   logic        [32:0]     a_in, a_ff;\n\n   logic                   b_enable, b_twos_comp;\n   logic        [32:0]     b_in;\n   logic        [36:0]     b_ff;\n\n   logic        [31:0]     q_in, q_ff;\n\n   logic                   rq_enable;\n   logic                   r_sign_sel;\n   logic                   r_restore_sel;\n   logic                   r_adder1_sel, r_adder2_sel, r_adder3_sel, r_adder4_sel, r_adder5_sel, r_adder6_sel, r_adder7_sel;\n   logic        [32:0]     r_in, r_ff;\n\n   logic                   twos_comp_q_sel, twos_comp_b_sel;\n   logic        [31:0]     twos_comp_in, twos_comp_out;\n\n   logic         [7:1]     quotient_raw;\n   logic         [2:0]     quotient_new;\n   logic        [33:0]     adder1_out;\n   logic        [34:0]     adder2_out;\n   logic        [35:0]     adder3_out;\n   logic        [36:0]     adder4_out;\n   logic        [36:0]     adder5_out;\n   logic        [36:0]     adder6_out;\n   logic        [36:0]     adder7_out;\n\n   logic        [65:0]     ar_shifted;\n   logic         [5:0]     shortq;\n   logic         [4:0]     shortq_shift;\n   logic         [4:0]     shortq_decode;\n   logic         [4:0]     shortq_shift_ff;\n   logic                   shortq_enable;\n   logic                   shortq_enable_ff;\n   logic        [32:0]     shortq_dividend;\n\n   logic                   by_zero_case;\n   logic                   by_zero_case_ff;\n\n\n\n   rvdffe #(19) i_misc_ff        (.*, .clk(clk), .en(misc_enable),    .din ({valid_ff_in, control_in[2:0], by_zero_case,    shortq_enable,    shortq_shift[4:0],    finish,    count_in[6:0]}),\n                                                                      .dout({valid_ff,    control_ff[2:0], by_zero_case_ff, shortq_enable_ff, shortq_shift_ff[4:0], finish_ff, count_ff[6:0]}));\n\n   rvdffe #(33) i_a_ff           (.*, .clk(clk), .en(a_enable),       .din(a_in[32:0]),           .dout(a_ff[32:0]));\n   rvdffe #(33) i_b_ff           (.*, .clk(clk), .en(b_enable),       .din(b_in[32:0]),           .dout(b_ff[32:0]));\n   rvdffe #(33) i_r_ff           (.*, .clk(clk), .en(rq_enable),      .din(r_in[32:0]),           .dout(r_ff[32:0]));\n   rvdffe #(32) i_q_ff           (.*, .clk(clk), .en(rq_enable),      .din(q_in[31:0]),           .dout(q_ff[31:0]));\n\n\n\n\n   assign valid_ff_in            =  valid_in  & ~cancel;\n\n   assign control_in[2]          = (~valid_in & control_ff[2]) | (valid_in & signed_in  & dividend_in[31]);\n   assign control_in[1]          = (~valid_in & control_ff[1]) | (valid_in & signed_in  &  divisor_in[31]);\n   assign control_in[0]          = (~valid_in & control_ff[0]) | (valid_in & rem_in);\n\n   assign dividend_sign_ff       =  control_ff[2];\n   assign divisor_sign_ff        =  control_ff[1];\n   assign rem_ff                 =  control_ff[0];\n\n\n   assign by_zero_case           =  valid_ff & (b_ff[31:0] == 32'b0);\n\n   assign misc_enable            =  valid_in | valid_ff | cancel | running_state | finish_ff;\n   assign running_state          = (| count_ff[6:0]) | shortq_enable_ff;\n   assign finish_raw             =   smallnum_case      |\n                                     by_zero_case       |\n                                    (count_ff[6:0] == 7'd33);\n\n\n   assign finish                 =  finish_raw & ~cancel;\n   assign count_enable           = (valid_ff | running_state) & ~finish & ~finish_ff & ~cancel & ~shortq_enable;\n   assign count_in[6:0]          = {7{count_enable}} & (count_ff[6:0] + {5'b0,2'b11} + {2'b0,shortq_shift_ff[4:0]});\n\n\n   assign a_enable               =  valid_in | running_state;\n   assign a_shift                =  running_state & ~shortq_enable_ff;\n\n   assign ar_shifted[65:0]       = { {33{dividend_sign_ff}} , a_ff[32:0]} << {shortq_shift_ff[4:0]};\n\n   assign a_in[32:0]             = ( {33{~a_shift & ~shortq_enable_ff}} & {signed_in & dividend_in[31],dividend_in[31:0]} ) |\n                                   ( {33{ a_shift                    }} & {a_ff[29:0],3'b0}  ) |\n                                   ( {33{            shortq_enable_ff}} &  ar_shifted[32:0]  );\n\n\n\n   assign b_enable               =    valid_in | b_twos_comp;\n   assign b_twos_comp            =    valid_ff & ~(dividend_sign_ff ^ divisor_sign_ff);\n\n   assign b_in[32:0]             = ( {33{~b_twos_comp}} & { (signed_in & divisor_in[31]),divisor_in[31:0] } ) |\n                                   ( {33{ b_twos_comp}} & {~divisor_sign_ff,twos_comp_out[31:0] } );\n\n\n   assign rq_enable              =  valid_in | valid_ff | running_state;\n   assign r_sign_sel             =  valid_ff      &  dividend_sign_ff & ~by_zero_case;\n   assign r_restore_sel          =  running_state & (quotient_new[2:0] == 3'b000) & ~shortq_enable_ff;\n   assign r_adder1_sel           =  running_state & (quotient_new[2:0] == 3'b001) & ~shortq_enable_ff;\n   assign r_adder2_sel           =  running_state & (quotient_new[2:0] == 3'b010) & ~shortq_enable_ff;\n   assign r_adder3_sel           =  running_state & (quotient_new[2:0] == 3'b011) & ~shortq_enable_ff;\n   assign r_adder4_sel           =  running_state & (quotient_new[2:0] == 3'b100) & ~shortq_enable_ff;\n   assign r_adder5_sel           =  running_state & (quotient_new[2:0] == 3'b101) & ~shortq_enable_ff;\n   assign r_adder6_sel           =  running_state & (quotient_new[2:0] == 3'b110) & ~shortq_enable_ff;\n   assign r_adder7_sel           =  running_state & (quotient_new[2:0] == 3'b111) & ~shortq_enable_ff;\n\n\n   assign r_in[32:0]             = ( {33{r_sign_sel      }} & {33{1'b1}}               ) |\n                                   ( {33{r_restore_sel   }} & {r_ff[29:0] ,a_ff[32:30]} ) |\n                                   ( {33{r_adder1_sel    }} &  adder1_out[32:0]         ) |\n                                   ( {33{r_adder2_sel    }} &  adder2_out[32:0]         ) |\n                                   ( {33{r_adder3_sel    }} &  adder3_out[32:0]         ) |\n                                   ( {33{r_adder4_sel    }} &  adder4_out[32:0]         ) |\n                                   ( {33{r_adder5_sel    }} &  adder5_out[32:0]         ) |\n                                   ( {33{r_adder6_sel    }} &  adder6_out[32:0]         ) |\n                                   ( {33{r_adder7_sel    }} &  adder7_out[32:0]         ) |\n                                   ( {33{shortq_enable_ff}} &  ar_shifted[65:33]        ) |\n                                   ( {33{by_zero_case    }} & {1'b0,a_ff[31:0]}         );\n\n\n   assign q_in[31:0]             = ( {32{~valid_ff     }} & {q_ff[28:0], quotient_new[2:0]} ) |\n                                   ( {32{ smallnum_case}} & {28'b0     , smallnum[3:0]}     ) |\n                                   ( {32{ by_zero_case }} & {32{1'b1}}                      );\n\n\n   assign b_ff[36:33]            = {b_ff[32],b_ff[32],b_ff[32],b_ff[32]};\n\n\n   assign adder1_out[33:0]       = {         r_ff[30:0],a_ff[32:30]}  +                                              b_ff[33:0];\n   assign adder2_out[34:0]       = {         r_ff[31:0],a_ff[32:30]}  +                        {b_ff[33:0],1'b0};\n   assign adder3_out[35:0]       = {         r_ff[32:0],a_ff[32:30]}  +                        {b_ff[34:0],1'b0}  +  b_ff[35:0];\n   assign adder4_out[36:0]       = {r_ff[32],r_ff[32:0],a_ff[32:30]}  +  {b_ff[34:0],2'b0};\n   assign adder5_out[36:0]       = {r_ff[32],r_ff[32:0],a_ff[32:30]}  +  {b_ff[34:0],2'b0}  +                        b_ff[36:0];\n   assign adder6_out[36:0]       = {r_ff[32],r_ff[32:0],a_ff[32:30]}  +  {b_ff[34:0],2'b0}  +  {b_ff[35:0],1'b0};\n   assign adder7_out[36:0]       = {r_ff[32],r_ff[32:0],a_ff[32:30]}  +  {b_ff[34:0],2'b0}  +  {b_ff[35:0],1'b0}  +  b_ff[36:0];\n\n   assign quotient_raw[1]        = (~adder1_out[33] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder1_out[33:0] ="}
{"text": "= 34'b0) );\n   assign quotient_raw[2]        = (~adder2_out[34] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder2_out[34:0] == 35'b0) );\n   assign quotient_raw[3]        = (~adder3_out[35] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder3_out[35:0] == 36'b0) );\n   assign quotient_raw[4]        = (~adder4_out[36] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder4_out[36:0] == 37'b0) );\n   assign quotient_raw[5]        = (~adder5_out[36] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder5_out[36:0] == 37'b0) );\n   assign quotient_raw[6]        = (~adder6_out[36] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder6_out[36:0] == 37'b0) );\n   assign quotient_raw[7]        = (~adder7_out[36] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder7_out[36:0] == 37'b0) );\n\n   assign quotient_new[2]        = quotient_raw[7] |   quotient_raw[6] | quotient_raw[5]  |   quotient_raw[4];\n   assign quotient_new[1]        = quotient_raw[7] |   quotient_raw[6] |                    (~quotient_raw[4] & quotient_raw[3]) | (~quotient_raw[3] & quotient_raw[2]);\n   assign quotient_new[0]        = quotient_raw[7] | (~quotient_raw[6] & quotient_raw[5]) | (~quotient_raw[4] & quotient_raw[3]) | (~quotient_raw[2] & quotient_raw[1]);\n\n\n   assign twos_comp_b_sel        =  valid_ff           & ~(dividend_sign_ff ^ divisor_sign_ff);\n   assign twos_comp_q_sel        = ~valid_ff & ~rem_ff &  (dividend_sign_ff ^ divisor_sign_ff) & ~by_zero_case_ff;\n\n   assign twos_comp_in[31:0]     = ( {32{twos_comp_q_sel}} & q_ff[31:0] ) |\n                                   ( {32{twos_comp_b_sel}} & b_ff[31:0] );\n\n   rvtwoscomp #(32) i_twos_comp  (.din(twos_comp_in[31:0]), .dout(twos_comp_out[31:0]));\n\n\n\n   assign valid_out              =  finish_ff & ~cancel;\n\n   assign data_out[31:0]         = ( {32{~rem_ff & ~twos_comp_q_sel}} & q_ff[31:0]          ) |\n                                   ( {32{ rem_ff                   }} & r_ff[31:0]          ) |\n                                   ( {32{           twos_comp_q_sel}} & twos_comp_out[31:0] );\n\n\n\n\n   // *** *** *** START : SMALLNUM {{\n\n   assign smallnum_case          = ( (a_ff[31:4]  == 28'b0) & (b_ff[31:4] == 28'b0) & ~by_zero_case & ~rem_ff & valid_ff & ~cancel) |\n                                   ( (a_ff[31:0]  == 32'b0) &                         ~by_zero_case & ~rem_ff & valid_ff & ~cancel);\n\n   assign smallnum[3]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           );\n\n   assign smallnum[2]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] & ~b_ff[2]                      );\n\n   assign smallnum[1]            = (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                                  ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &            ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2]                      );\n\n   assign smallnum[0]            = (            a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &             a_ff[0] & ~b_ff[3] &             b_ff[1] &  b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                                  a_ff[0] & ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] & ~a_ff[1] &            ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &                                             ~b_ff[2] & ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] &  b_ff[2] &  b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &             a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] & ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &             b_ff[0]) |\n                                   (           ~a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                                             ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] &             a_ff[1] &                       ~b_ff[2] &            ~b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &  b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                        b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &             a_ff[1] &             b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                        a_ff[0] &            ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &            ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &             a_ff[0] &  b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &  a_ff[1] &            ~b_ff[3] &             b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &  a_ff[0] &            ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] &  b_ff[3]                                 );\n\n   // *** *** *** END   : SMALLNUM }}\n\n\n\n\n   // *** *** *** Start : Short Q {{\n\n   assign shortq_dividend[32:0]   = {dividend_sign_ff,a_ff[31:0]};\n\n\n   logic [5:0]  dw_a_enc;\n   logic [5:0]  dw_b_enc;\n   logic [6:0]  dw_shortq_raw;\n\n\n\n   el2_exu_div_cls i_a_cls  (\n       .operand  ( shortq_dividend[32:0]  ),\n       .cls      ( dw_a_enc[4:0]          ));\n\n   el2_exu_div_cls i_b_cls  (\n       .operand  ( b_ff[32:0]             ),\n       .cls      ( dw_b_enc[4:0]          ));\n\n   assign dw_a_enc[5]             =  1'b0;\n   assign dw_b_enc[5]             =  1'b0;\n\n\n\n   assign dw_shortq_raw[6:0]      =  {1'b0,dw_b_enc[5:0]} - {1'b0,dw_a_enc[5:0]} + 7'd1;\n   assign shortq[5:0]             =  dw_shortq_raw[6]  ?  6'd0  :  dw_shortq_raw[5:0];\n\n   assign shortq_enable           =  valid_ff & ~shortq[5] & ~(shortq[4:2] ==  3'b111) & ~cancel;\n\n   assign shortq_decode[4:0]      = ( {5{shortq[4:0] == 5'd31}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd30}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd29}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd28}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd27}} & 5'd03) |\n                                    ( {5{shortq[4:0] == 5'd26}} & 5'd06) |\n                                    ( {5{shortq[4:0] == 5'd25}} & 5'd06) |\n                                    ( {5{shortq[4:0] == 5'd24}} & 5'd06) |\n                                    ( {5{shortq[4:0] == 5'd23}} & 5'd09) |\n                                    ( {5{shortq[4:0] == 5'd22}} & 5'd09) |\n                                    ( {5{shortq[4:0] == 5'd21}} & 5'd09) |\n                                    ( {5{shortq[4:0] == 5'd20}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd19}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd18}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd17}} & 5'd15) |\n                                    ( {5{shortq[4:0] == 5'd16}} & 5'd15) |\n                                    ( {5{shortq[4:0] == 5'd15}} & 5'd15) |\n                                    ( {5{shortq[4:0] == 5'd14}} & 5'd18) |\n                                    ( {5{shortq[4:0] == 5'd13}} & 5'd18) |\n                                    ( {5{shortq[4:0] == 5'd12}} & 5'd18) |\n                                    ( {5{shortq[4:0] == 5'd11}} & 5'd21) |\n                                    ( {5{shortq[4:0] == 5'd10}} & 5'd21) |\n                                    ( {5{shortq[4:0] == 5'd09}} & 5'd21) |\n                                    ( {5{shortq[4:0] == 5'd08}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd07}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd06}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd05}} & 5'd27) |\n                                    ( {5{shortq[4:0] == 5'd04}} & 5'd27) |\n                                    ( {5{shortq[4:0] == 5'd03}} & 5'd27) |\n                                    ( {5{shortq[4:0] == 5'd02}} & 5'd27) |\n                                    ( {5{shortq[4:0] == 5'd01}} & 5'd27) |\n                                    ( {5{shortq[4:0] == 5'd00}} & 5'd27);\n\n\n   assign shortq_shift[4:0]       = ~shortq_enable     ?  5'd0  :  shortq_decode[4:0];\n\n\n   // *** *** *** End   : Short Q }}\n\n\n\n\n\nendmodule // el2_exu_div_new_3bit_fullshortq\n\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nmodule el2_exu_div_new_4bit_fullshortq\n  (\n   input  logic            clk,                       // Top level clock\n   input  logic            rst_l,                     // Reset\n   input  logic            scan_mode,                 // Scan mode\n\n   input  logic            cancel,                    // Flush pipeline\n   input  logic            valid_in,\n   input  logic            signed_in,\n   input  logic            rem_in,\n   input  logic [31:0]     dividend_in,\n   input  logic [31:0]     divisor_in,\n\n   output logic            valid_out,\n   output logic [31:0]     data_out\n  );\n\n\n   logic                   valid_ff_in, valid_ff;\n   logic                   finish_raw, finish, finish_ff;\n   logic                   running_state;\n   logic                   misc_enable;\n   logic         [2:0]     control_in, control_ff;\n   logic                   dividend_sign_ff, divisor_sign_ff, rem_ff;\n   logic                   count_enable;\n   logic         [6:0]     count_in, count_ff;\n\n   logic                   smallnum_case;\n   logic         [3:0]     smallnum;\n\n   logic                   a_enable, a_shift;\n   logic        [31:0]     a_in, a_ff;\n\n   logic                   b_enable, b_twos_comp;\n   logic        [32:0]     b_in;\n   logic        [37:0]     b_ff;\n\n   logic        [31:0]     q_in, q_ff;\n\n   logic                   rq_enable;\n   logic                   r_sign_sel;\n   logic                   r_restore_sel;\n   logic                   r_adder01_sel, r_adder02_sel, r_adder03_sel;\n   logic                   r_adder04_sel, r_adder05_sel, r_adder06_sel, r_adder07_sel;\n   logic                   r_adder08_sel, r_adder09_sel, r_adder10_sel, r_adder11_sel;\n   logic                   r_adder12_sel, r_adder13_sel, r_adder14_sel, r_adder15_sel;\n   logic        [32:0]     r_in, r_ff;\n\n   logic                   twos_comp_q_sel, twos_comp_b_sel;\n   logic        [31:0]     twos_comp_in, twos_comp_out;\n\n   logic        [15:1]     quotient_raw;\n   logic         [3:0]     quotient_new;\n   logic        [34:0]     adder01_out;\n   logic        [35:0]     adder02_out;\n   logic        [36:0]     adder03_out;\n   logic        [37:0]     adder04_out;\n   logic        [37:0]     adder05_out;\n   logic        [37:0]     adder06_out;\n   logic        [37:0]     adder07_out;\n   logic        [37:0]     adder08_out;\n   logic        [37:0]     adder09_out;\n   logic        [37:0]     adder10_out;\n   logic        [37:0]     adder11_out;\n   logic        [37:0]     adder12_out;\n   logic        [37:0]     adder13_out;\n   logic        [37:0]     adder14_out;\n   logic        [37:0]     adder15_out;\n\n   logic        [64:0]     ar_shifted;\n   logic         [5:0]     shortq;\n   logic         [4:0]     shortq_shift;\n   logic         [4:0]     shortq_decode;\n   logic         [4:0]     shortq_shift_ff;\n   logic                   shortq_enable;\n   logic                   shortq_enable_ff;\n   logic        [32:0]     shortq_dividend;\n\n   logic                   by_zero_case;\n   logic                   by_zero_case_ff;\n\n\n\n   rvdffe #(19) i_misc_ff        (.*, .clk(clk), .en(misc_enable),     .din ({valid_ff_in, control_in[2:0], by_zero_case,    shortq_enable,    shortq_shift[4:0],    finish,    count_in[6:0]}),\n                                                                       .dout({valid_ff,    control_ff[2:0], by_zero_case_ff, shortq_enable_ff, shortq_shift_ff[4:0], finish_ff, count_ff[6:0]}));\n\n   rvdffe #(32) i_a_ff           (.*, .clk(clk), .en(a_enable),        .din(a_in[31:0]),           .dout(a_ff[31:0]));\n   rvdffe #(33) i_b_ff           (.*, .clk(clk), .en(b_enable),        .din(b_in[32:0]),           .dout(b_ff[32:0]));\n   rvdffe #(33) i_r_ff           (.*, .clk(clk), .en(rq_enable),       .din(r_in[32:0]),           .dout(r_ff[32:0]));\n   rvdffe #(32) i_q_ff           (.*, .clk(clk), .en(rq_enable),       .din(q_in[31:0]),           .dout(q_ff[31:0]));\n\n\n\n\n   assign valid_ff_in            =  valid_in  & ~cancel;\n\n   assign control_in[2]          = (~valid_in & control_ff[2]) | (valid_in & signed_in  & dividend_in[31]);\n   assign control_in[1]          = (~valid_in & control_ff[1]) | (valid_in & signed_in  &  divisor_in[31]);\n   assign control_in[0]          = (~valid_in & control_ff[0]) | (valid_in & rem_in);\n\n   assign dividend_sign_ff       =  control_ff[2];\n   assign divisor_sign_ff        =  control_ff[1];\n   assign rem_ff                 =  control_ff[0];\n\n\n   assign by_zero_case           =  valid_ff & (b_ff[31:0] == 32'b0);\n\n   assign misc_enable            =  valid_in | valid_ff | cancel | running_state | finish_ff;\n   assign running_state          = (| count_ff[6:0]) | shortq_enable_ff;\n   assign finish_raw             =   smallnum_case      |\n                                     by_zero_case       |\n                                    (count_ff[6:0] == 7'd32);\n\n\n   assign finish                 =  finish_raw & ~cancel;\n   assign count_enable           = (valid_ff | running_state) & ~finish & ~finish_ff & ~cancel & ~shortq_enable;\n   assign count_in[6:0]          = {7{count_enable}} & (count_ff[6:0] + 7'd4 + {2'b0,shortq_shift_ff[4:0]});\n\n\n   assign a_enable               =  valid_in | running_state;\n   assign a_shift                =  running_state & ~shortq_enable_ff;\n\n   assign ar_shifted[64:0]       = { {33{dividend_sign_ff}} , a_ff[31:0]} << {shortq_shift_ff[4:0]};\n\n   assign a_in[31:0]             = ( {32{~a_shift & ~shortq_enable_ff}} &  dividend_in[31:0] ) |\n                                   ( {32{ a_shift                    }} & {a_ff[27:0],4'b0}  ) |\n                                   ( {32{            shortq_enable_ff}} &  ar_shifted[31:0]  );\n\n\n\n   assign b_enable               =    valid_in | b_twos_comp;\n   assign b_twos_comp            =    valid_ff & ~(dividend_sign_ff ^ divisor_sign_ff);\n\n   assign b_in[32:0]             = ( {33{~b_twos_comp}} & { (signed_in & divisor_in[31]),divisor_in[31:0] } ) |\n                                   ( {33{ b_twos_comp}} & {~divisor_sign_ff,twos_comp_out[31:0] } );\n\n\n   assign rq_enable              =  valid_in | valid_ff | running_state;\n   assign r_sign_sel             =  valid_ff      &  dividend_sign_ff & ~by_zero_case;\n   assign r_restore_sel          =  running_state & (quotient_new[3:0] == 4'd00) & ~shortq_enable_ff;\n   assign r_adder01_sel          =  running_state & (quotient_new[3:0] == 4'd01) & ~shortq_enable_ff;\n   assign r_adder02_sel          =  running_state & (quotient_new[3:0] == 4'd02) & ~shortq_enable_ff;\n   assign r_adder03_sel          =  running_state & (quotient_new[3:0] == 4'd03) & ~shortq_enable_ff;\n   assign r_adder04_sel          =  running_state & (quotient_new[3:0] == 4'd04) & ~shortq_enable_ff;\n   assign r_adder05_sel          =  running_state & (quotient_new[3:0] == 4'd05) & ~shortq_enable_ff;\n   assign r_adder06_sel          =  running_state & (quotient_new[3:0] == 4'd06) & ~shortq_enable_ff;\n   assign r_adder07_sel          =  running_state & (quotient_new[3:0] == 4'd07) & ~shortq_enable_ff;\n   assign r_adder08_sel          =  running_state & (quotient_new[3:0] == 4'd08) & ~shortq_enable_ff;\n   assign r_adder09_sel          =  running_state & (quotient_new[3:0] == 4'd09) & ~shortq_enable_ff;\n   assign r_adder10_sel          =  running_state & (quotient_new[3:0] == 4'd10) & ~shortq_enable_ff;\n   assign r_adder11_sel          =  running_state & (quotient_new[3:0] == 4'd11) & ~shortq_enable_ff;\n   assign r_adder12_sel          =  running_state & (quotient_new[3:0] == 4'd12) & ~shortq_enable_ff;\n   assign r_adder13_sel          =  running_state & (quotient_new[3:0] == 4'd13) & ~shortq_enable_ff;\n   assign r_adder14_sel          =  running_state & (quotient_new[3:0] == 4'd14) & ~shortq_enable_ff;\n   assign r_adder15_sel          =  running_state & (quotient_new[3:0] == 4'd15) & ~shortq_enable_ff;\n\n   assign r_in[32:0]             = ( {33{r_sign_sel      }} & {33{1'b1}}               ) |\n                                   ( {33{r_restore_sel   }} & {r_ff[28:0],a_ff[31:28]} ) |\n                                   ( {33{r_adder01_sel   }} &  adder01_out[32:0]       ) |\n                                   ( {33{r_adder02_sel   }} &  adder02_out[32:0]       ) |\n                                   ( {33{r_adder03_sel   }} &  adder03_out[32:0]       ) |\n                                   ( {33{r_adder04_sel   }} &  adder04_out[32:0]       ) |\n                                   ( {33{r_adder05_sel   }} &  adder05_out[32:0]       ) |\n                                   ( {33{r_adder06_sel   }} &  adder06_out[32:0]       ) |\n                                   ( {33{r_adder07_sel   }} &  adder07_out[32:0]       ) |\n                                   ( {33{r_adder08_sel   }} &  adder08_out[32:0]       ) |\n                                   ( {33{r_adder09_sel   }} &  adder09_out[32:0]       ) |\n                                   ( {33{r_adder10_sel   }} &  adder10_out[32:0]       ) |\n                                   ( {33{r_adder11_sel   }} &  adder11_out[32:0]       ) |\n                                   ( {33{r_adder12_sel   }} &  adder12_out[32:0]       ) |\n                                   ( {33{r_adder13_sel   }} &  adder13_out[32:0]       ) |\n                                   ( {33{r_adder14_sel   }} &  adder14_out[32:0]       ) |\n  "}
{"text": "                                 ( {33{r_adder15_sel   }} &  adder15_out[32:0]       ) |\n                                   ( {33{shortq_enable_ff}} &  ar_shifted[64:32]       ) |\n                                   ( {33{by_zero_case    }} & {1'b0,a_ff[31:0]}        );\n\n\n   assign q_in[31:0]             = ( {32{~valid_ff     }} & {q_ff[27:0], quotient_new[3:0]} ) |\n                                   ( {32{ smallnum_case}} & {28'b0     , smallnum[3:0]}     ) |\n                                   ( {32{ by_zero_case }} & {32{1'b1}}                      );\n\n\n   assign b_ff[37:33]            = {b_ff[32],b_ff[32],b_ff[32],b_ff[32],b_ff[32]};\n\n\n   assign adder01_out[34:0]      = {         r_ff[30:0],a_ff[31:28]}  +                                                                   b_ff[34:0];\n   assign adder02_out[35:0]      = {         r_ff[31:0],a_ff[31:28]}  +                                             {b_ff[34:0],1'b0};\n   assign adder03_out[36:0]      = {         r_ff[32:0],a_ff[31:28]}  +                                             {b_ff[35:0],1'b0}  +  b_ff[36:0];\n   assign adder04_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +                       {b_ff[35:0],2'b0};\n   assign adder05_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +                       {b_ff[35:0],2'b0}  +                        b_ff[37:0];\n   assign adder06_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +                       {b_ff[35:0],2'b0}  +  {b_ff[36:0],1'b0};\n   assign adder07_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +                       {b_ff[35:0],2'b0}  +  {b_ff[36:0],1'b0}  +  b_ff[37:0];\n   assign adder08_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0};\n   assign adder09_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +                                              b_ff[37:0];\n   assign adder10_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +                        {b_ff[36:0],1'b0};\n   assign adder11_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +                        {b_ff[36:0],1'b0}  +  b_ff[37:0];\n   assign adder12_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +  {b_ff[35:0],2'b0};\n   assign adder13_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +  {b_ff[35:0],2'b0}  +                        b_ff[37:0];\n   assign adder14_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +  {b_ff[35:0],2'b0}  +  {b_ff[36:0],1'b0};\n   assign adder15_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +  {b_ff[35:0],2'b0}  +  {b_ff[36:0],1'b0}  +  b_ff[37:0];\n\n   assign quotient_raw[01]       = (~adder01_out[34] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder01_out[34:0] == 35'b0) );\n   assign quotient_raw[02]       = (~adder02_out[35] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder02_out[35:0] == 36'b0) );\n   assign quotient_raw[03]       = (~adder03_out[36] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder03_out[36:0] == 37'b0) );\n   assign quotient_raw[04]       = (~adder04_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder04_out[37:0] == 38'b0) );\n   assign quotient_raw[05]       = (~adder05_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder05_out[37:0] == 38'b0) );\n   assign quotient_raw[06]       = (~adder06_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder06_out[37:0] == 38'b0) );\n   assign quotient_raw[07]       = (~adder07_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder07_out[37:0] == 38'b0) );\n   assign quotient_raw[08]       = (~adder08_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder08_out[37:0] == 38'b0) );\n   assign quotient_raw[09]       = (~adder09_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder09_out[37:0] == 38'b0) );\n   assign quotient_raw[10]       = (~adder10_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder10_out[37:0] == 38'b0) );\n   assign quotient_raw[11]       = (~adder11_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder11_out[37:0] == 38'b0) );\n   assign quotient_raw[12]       = (~adder12_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder12_out[37:0] == 38'b0) );\n   assign quotient_raw[13]       = (~adder13_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder13_out[37:0] == 38'b0) );\n   assign quotient_raw[14]       = (~adder14_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder14_out[37:0] == 38'b0) );\n   assign quotient_raw[15]       = (~adder15_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder15_out[37:0] == 38'b0) );\n\n\n   assign quotient_new[0]        = ( quotient_raw[15:01] == 15'b000_0000_0000_0001 ) |  //  1\n                                   ( quotient_raw[15:03] == 13'b000_0000_0000_01   ) |  //  3\n                                   ( quotient_raw[15:05] == 11'b000_0000_0001      ) |  //  5\n                                   ( quotient_raw[15:07] ==  9'b000_0000_01        ) |  //  7\n                                   ( quotient_raw[15:09] ==  7'b000_0001           ) |  //  9\n                                   ( quotient_raw[15:11] ==  5'b000_01             ) |  // 11\n                                   ( quotient_raw[15:13] ==  3'b001                ) |  // 13\n                                   ( quotient_raw[   15] ==  1'b1                  );   // 15\n\n   assign quotient_new[1]        = ( quotient_raw[15:02] == 14'b000_0000_0000_001  ) |  //  2\n                                   ( quotient_raw[15:03] == 13'b000_0000_0000_01   ) |  //  3\n                                   ( quotient_raw[15:06] == 10'b000_0000_001       ) |  //  6\n                                   ( quotient_raw[15:07] ==  9'b000_0000_01        ) |  //  7\n                                   ( quotient_raw[15:10] ==  6'b000_001            ) |  // 10\n                                   ( quotient_raw[15:11] ==  5'b000_01             ) |  // 11\n                                   ( quotient_raw[15:14] ==  2'b01                 ) |  // 14\n                                   ( quotient_raw[   15] ==  1'b1                  );   // 15\n\n   assign quotient_new[2]        = ( quotient_raw[15:04] == 12'b000_0000_0000_1    ) |  //  4\n                                   ( quotient_raw[15:05] == 11'b000_0000_0001      ) |  //  5\n                                   ( quotient_raw[15:06] == 10'b000_0000_001       ) |  //  6\n                                   ( quotient_raw[15:07] ==  9'b000_0000_01        ) |  //  7\n                                   ( quotient_raw[15:12] ==  4'b000_1              ) |  // 12\n                                   ( quotient_raw[15:13] ==  3'b001                ) |  // 13\n                                   ( quotient_raw[15:14] ==  2'b01                 ) |  // 14\n                                   ( quotient_raw[   15] ==  1'b1                  );   // 15\n\n   assign quotient_new[3]        = ( quotient_raw[15:08] ==  8'b000_0000_1         ) |  //  8\n                                   ( quotient_raw[15:09] ==  7'b000_0001           ) |  //  9\n                                   ( quotient_raw[15:10] ==  6'b000_001            ) |  // 10\n                                   ( quotient_raw[15:11] ==  5'b000_01             ) |  // 11\n                                   ( quotient_raw[15:12] ==  4'b000_1              ) |  // 12\n                                   ( quotient_raw[15:13] ==  3'b001                ) |  // 13\n                                   ( quotient_raw[15:14] ==  2'b01                 ) |  // 14\n                                   ( quotient_raw[   15] ==  1'b1                  );   // 15\n\n\n   assign twos_comp_b_sel        =  valid_ff           & ~(dividend_sign_ff ^ divisor_sign_ff);\n   assign twos_comp_q_sel        = ~valid_ff & ~rem_ff &  (dividend_sign_ff ^ divisor_sign_ff) & ~by_zero_case_ff;\n\n   assign twos_comp_in[31:0]     = ( {32{twos_comp_q_sel}} & q_ff[31:0] ) |\n                                   ( {32{twos_comp_b_sel}} & b_ff[31:0] );\n\n   rvtwoscomp #(32) i_twos_comp  (.din(twos_comp_in[31:0]), .dout(twos_comp_out[31:0]));\n\n\n\n   assign valid_out              =  finish_ff & ~cancel;\n\n   assign data_out[31:0]         = ( {32{~rem_ff & ~twos_comp_q_sel}} & q_ff[31:0]          ) |\n                                   ( {32{ rem_ff                   }} & r_ff[31:0]          ) |\n                                   ( {32{           twos_comp_q_sel}} & twos_comp_out[31:0] );\n\n\n\n\n   // *** *** *** START : SMALLNUM {{\n\n   assign smallnum_case          = ( (a_ff[31:4]  == 28'b0) & (b_ff[31:4] == 28'b0) & ~by_zero_case & ~rem_ff & valid_ff & ~cancel) |\n                                   ( (a_ff[31:0]  == 32'b0) &                         ~by_zero_case & ~rem_ff & valid_ff & ~cancel);\n\n   assign smallnum[3]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           );\n\n   assign smallnum[2]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] & ~b_ff[2]                      );\n\n   assign smallnum[1]            = (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                                  ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &            ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2]                      );\n\n   assign smallnum[0]            = (            a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &             a_ff[0] & ~b_ff[3] &             b_ff[1] &  b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                                  a_ff[0] & ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] & ~a_ff[1] &            ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &                                             ~b_ff[2] & ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] &  b_ff[2] &  b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &             a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] & ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &             b_ff[0]) |\n                                   (           ~a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                                             ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] &             a_ff[1] &                       ~b_ff[2] &            ~b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &  b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                        b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &             a_ff[1] &             b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                        a_ff[0] &            ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &            ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &             a_ff[0] &  b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &  a_ff[1] &            ~b_ff[3] &             b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &  a_ff[0] &            ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] &  b_ff[3]                                 );\n\n   // *** *** *** END   : SMALLNUM }}\n\n\n\n\n   // *** *** *** Start : Short Q {{\n\n   assign shortq_dividend[32:0]   = {dividend_sign_ff,a_ff[31:0]};\n\n\n   logic [5:0]  dw_a_enc;\n   logic [5:0]  dw_b_enc;\n   logic [6:0]  dw_shortq_raw;\n\n\n\n   el2_exu_div_cls i_a_cls  (\n       .operand  ( shortq_dividend[32:0]  ),\n       .cls      ( dw_a_enc[4:0]          ));\n\n   el2_exu_div_cls i_b_cls  (\n       .operand  ( b_ff[32:0]             ),\n       .cls      ( dw_b_enc[4:0]          ));\n\n   assign dw_a_enc[5]             =  1'b0;\n   assign dw_b_enc[5]             =  1'b0;\n\n\n   assign dw_shortq_raw[6:0]      =  {1'b0,dw_b_enc[5:0]} - {1'b0,dw_a_enc[5:0]} + 7'd1;\n   assign shortq[5:0]             =  dw_shortq_raw[6]  ?  6'd0  :  dw_shortq_raw[5:0];\n\n   assign shortq_enable           =  valid_ff & ~shortq[5] & ~(shortq[4:2] ==  3'b111) & ~cancel;\n\n   assign shortq_decode[4:0]      = ( {5{shortq[4:0] == 5'd31}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd30}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd29}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd28}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd27}} & 5'd04) |\n                                    ( {5{shortq[4:0] == 5'd26}} & 5'd04) |\n                                    ( {5{shortq[4:0] == 5'd25}} & 5'd04) |\n                                    ( {5{shortq[4:0] == 5'd24}} & 5'd04) |\n                                    ( {5{shortq[4:0] == 5'd23}} & 5'd08) |\n                                    ( {5{shortq[4:0] == 5'd22}} & 5'd08) |\n                                    ( {5{shortq[4:0] == 5'd21}} & 5'd08) |\n                                    ( {5{shortq[4:0] == 5'd20}} & 5'd08) |\n                                    ( {5{shortq[4:0] == 5'd19}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd18}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd17}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd16}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd15}} & 5'd16) |\n                                    ( {5{shortq[4:0] == 5'd14}} & 5'd16) |\n                                    ( {5{shortq[4:0] == 5'd13}} & 5'd16) |\n                                    ( {5{shortq[4:0] == 5'd12}} & 5'd16) |\n                                    ( {5{shortq[4:0] == 5'd11}} & 5'd20) |\n                                    ( {5{shortq[4:0] == 5'd10}} & 5'd20) |\n                                    ( {5{shortq[4:0] == 5'd09}} & 5'd20) |\n                                    ( {5{shortq[4:0] == 5'd08}} & 5'd20) |\n                                    ( {5{shortq[4:0] == 5'd07}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd06}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd05}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd04}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd03}} & 5'd28) |\n                                    ( {5{shortq[4:0] == 5'd02}} & 5'd28) |\n                                    ( {5{shortq[4:0] == 5'd01}} & 5'd28) |\n                                    ( {5{shortq[4:0] == 5'd00}} & 5'd28);\n\n\n   assign shortq_shift[4:0]       = ~shortq_enable     ?  5'd0  :  shortq_decode[4:0];\n\n\n   // *** *** *** End   : Short Q }}\n\n\n\n\n\nendmodule // el2_exu_div_new_4bit_fullshortq\n\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\n\nmodule el2_exu_div_cls\n  (\n   input  logic [32:0] operand,\n\n   output logic [4:0]  cls                  // Count leading sign bits - \"n\" format ignoring [32]\n   );\n\n\n   logic [4:0]   cls_zeros;\n   logic [4:0]   cls_ones;\n\n\nassign cls_zeros[4:0]             = ({5{operand[31]    ==  {           1'b1} }} & 5'd00) |\n                                    ({5{operand[31:30] ==  {{ 1{1'b0}},1'b1} }} & 5'd01) |\n                                    ({5{operand[31:29] ==  {{ 2{1'b0}},1'b1} }} & 5'd02) |\n                                    ({5{operand[31:28] ==  {{ 3{1'b0}},1'b1} }} & 5'd03) |\n                                    ({5{operand[31:27] ==  {{ 4{1'b0}},1'b1} }} & 5'd04) |\n                                    ({5{operand[31:26] ==  {{ 5{1'b0}},1'b1} }} & 5'd05) |\n                                    ({5{operand[31:25] ==  {{ 6{1'b0}},1'b1} }} & 5'd06) |\n                                    ({5{operand[31:24] ==  {{ 7{1'b0}},1'b1} }} & 5'd07) |\n                                    ({5{operand[31:23] ==  {{ 8{1'b0}},1'b1} }} & 5'd08) |\n                                    ({5{operand[31:22] ==  {{ 9{1'b0}},1'b1} }} & 5'd09) |\n                                    ({5{operand[31:21] ==  {{10{1'b0}},1'b1} }} & 5'd10) |\n                                    ({5{operand[31:20] ==  {{11{1'b0}},1'b1} }} & 5'd11) |\n                                    ({5{operand[31:19] ==  {{12{1'b0}},1'b1} }} & 5'd12) |\n                                    ({5{operand[31:18] ==  {{13{1'b0}},1'b1} }} & 5'd13) |\n                                    ({5{operand[31:17] ==  {{14{1'b0}},1'b1} }} & 5'd14) |\n                                    ({5{operand[31:16] ==  {{15{1'b0}},1'b1} }} & 5'd15) |\n                                    ({5{operand[31:15] ==  {{16{1'b0}},1'b1} }} & 5'd16) |\n                                    ({5{operand[31:14] ==  {{17{1'b0}},1'b1} }} & 5'd17) |\n                                    ({5{operand[31:13] ==  {{18{1'b0}},1'b1} }} & 5'd18) |\n                                    ({5{operand[31:12] ==  {{19{1'b0}},1'b1} }} & 5'd19) |\n                                    ({5{operand[31:11] ==  {{20{1'b0}},1'b1} }} & 5'd20) |\n                                    ({5{operand[31:10] ==  {{21{1'b0}},1'b1} }} & 5'd21) |\n                                    ({5{operand[31:09] ==  {{22{1'b0}},1'b1} }} & 5'd22) |\n                                    ({5{operand[31:08] ==  {{23{1'b0}},1'b1} }} & 5'd23) |\n                                    ({5{operand[31:07] ==  {{24{1'b0}},1'b1} }} & 5'd24) |\n                                    ({5{operand[31:06] ==  {{25{1'b0}},1'b1} }} & 5'd25) |\n                                    ({5{operand[31:05] ==  {{26{1'b0}},1'b1} }} & 5'd26) |\n                                    ({5{operand[31:04] ==  {{27{1'b0}},1'b1} }} & 5'd27) |\n "}
{"text": "                                   ({5{operand[31:03] ==  {{28{1'b0}},1'b1} }} & 5'd28) |\n                                    ({5{operand[31:02] ==  {{29{1'b0}},1'b1} }} & 5'd29) |\n                                    ({5{operand[31:01] ==  {{30{1'b0}},1'b1} }} & 5'd30) |\n                                    ({5{operand[31:00] ==  {{31{1'b0}},1'b1} }} & 5'd31) |\n                                    ({5{operand[31:00] ==  {{32{1'b0}}     } }} & 5'd00);    // Don't care case as it will be handled as special case\n\n\nassign cls_ones[4:0]              = ({5{operand[31:30] ==  {{ 1{1'b1}},1'b0} }} & 5'd00) |\n                                    ({5{operand[31:29] ==  {{ 2{1'b1}},1'b0} }} & 5'd01) |\n                                    ({5{operand[31:28] ==  {{ 3{1'b1}},1'b0} }} & 5'd02) |\n                                    ({5{operand[31:27] ==  {{ 4{1'b1}},1'b0} }} & 5'd03) |\n                                    ({5{operand[31:26] ==  {{ 5{1'b1}},1'b0} }} & 5'd04) |\n                                    ({5{operand[31:25] ==  {{ 6{1'b1}},1'b0} }} & 5'd05) |\n                                    ({5{operand[31:24] ==  {{ 7{1'b1}},1'b0} }} & 5'd06) |\n                                    ({5{operand[31:23] ==  {{ 8{1'b1}},1'b0} }} & 5'd07) |\n                                    ({5{operand[31:22] ==  {{ 9{1'b1}},1'b0} }} & 5'd08) |\n                                    ({5{operand[31:21] ==  {{10{1'b1}},1'b0} }} & 5'd09) |\n                                    ({5{operand[31:20] ==  {{11{1'b1}},1'b0} }} & 5'd10) |\n                                    ({5{operand[31:19] ==  {{12{1'b1}},1'b0} }} & 5'd11) |\n                                    ({5{operand[31:18] ==  {{13{1'b1}},1'b0} }} & 5'd12) |\n                                    ({5{operand[31:17] ==  {{14{1'b1}},1'b0} }} & 5'd13) |\n                                    ({5{operand[31:16] ==  {{15{1'b1}},1'b0} }} & 5'd14) |\n                                    ({5{operand[31:15] ==  {{16{1'b1}},1'b0} }} & 5'd15) |\n                                    ({5{operand[31:14] ==  {{17{1'b1}},1'b0} }} & 5'd16) |\n                                    ({5{operand[31:13] ==  {{18{1'b1}},1'b0} }} & 5'd17) |\n                                    ({5{operand[31:12] ==  {{19{1'b1}},1'b0} }} & 5'd18) |\n                                    ({5{operand[31:11] ==  {{20{1'b1}},1'b0} }} & 5'd19) |\n                                    ({5{operand[31:10] ==  {{21{1'b1}},1'b0} }} & 5'd20) |\n                                    ({5{operand[31:09] ==  {{22{1'b1}},1'b0} }} & 5'd21) |\n                                    ({5{operand[31:08] ==  {{23{1'b1}},1'b0} }} & 5'd22) |\n                                    ({5{operand[31:07] ==  {{24{1'b1}},1'b0} }} & 5'd23) |\n                                    ({5{operand[31:06] ==  {{25{1'b1}},1'b0} }} & 5'd24) |\n                                    ({5{operand[31:05] ==  {{26{1'b1}},1'b0} }} & 5'd25) |\n                                    ({5{operand[31:04] ==  {{27{1'b1}},1'b0} }} & 5'd26) |\n                                    ({5{operand[31:03] ==  {{28{1'b1}},1'b0} }} & 5'd27) |\n                                    ({5{operand[31:02] ==  {{29{1'b1}},1'b0} }} & 5'd28) |\n                                    ({5{operand[31:01] ==  {{30{1'b1}},1'b0} }} & 5'd29) |\n                                    ({5{operand[31:00] ==  {{31{1'b1}},1'b0} }} & 5'd30) |\n                                    ({5{operand[31:00] ==  {{32{1'b1}}     } }} & 5'd31);\n\n\nassign cls[4:0]                   =  operand[32]  ?  cls_ones[4:0]  :  cls_zeros[4:0];\n\nendmodule // el2_exu_div_cls\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nmodule el2_exu_mul_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n   input logic          clk,              // Top level clock\n   input logic          rst_l,            // Reset\n   input logic          scan_mode,        // Scan mode\n\n   input el2_mul_pkt_t mul_p,            // {Valid, RS1 signed operand, RS2 signed operand, Select low 32-bits of result}\n\n   input logic [31:0]   rs1_in,           // A operand\n   input logic [31:0]   rs2_in,           // B operand\n\n\n   output logic [31:0]  result_x          // Result\n  );\n\n\n   logic                mul_x_enable;\n   logic                bit_x_enable;\n   logic signed [32:0]  rs1_ext_in;\n   logic signed [32:0]  rs2_ext_in;\n   logic        [65:0]  prod_x;\n   logic                low_x;\n\n\n\n   // *** Start - BitManip ***\n\n   logic                bitmanip_sel_d;\n   logic                bitmanip_sel_x;\n   logic        [31:0]  bitmanip_d;\n   logic        [31:0]  bitmanip_x;\n\n\n\n   // ZBE\n   logic                ap_bcompress;\n   logic                ap_bdecompress;\n\n   // ZBC\n   logic                ap_clmul;\n   logic                ap_clmulh;\n   logic                ap_clmulr;\n\n   // ZBP\n   logic                ap_grev;\n   logic                ap_gorc;\n   logic                ap_shfl;\n   logic                ap_unshfl;\n   logic                ap_xperm_n;\n   logic                ap_xperm_b;\n   logic                ap_xperm_h;\n\n   // ZBR\n   logic                ap_crc32_b;\n   logic                ap_crc32_h;\n   logic                ap_crc32_w;\n   logic                ap_crc32c_b;\n   logic                ap_crc32c_h;\n   logic                ap_crc32c_w;\n\n   // ZBF\n   logic                ap_bfp;\n\n\n   if (pt.BITMANIP_ZBE == 1)\n     begin\n       assign ap_bcompress    =  mul_p.bcompress;\n       assign ap_bdecompress  =  mul_p.bdecompress;\n     end\n   else\n     begin\n       assign ap_bcompress    =  1'b0;\n       assign ap_bdecompress  =  1'b0;\n     end\n\n   if (pt.BITMANIP_ZBC == 1)\n     begin\n       assign ap_clmul        =  mul_p.clmul;\n       assign ap_clmulh       =  mul_p.clmulh;\n       assign ap_clmulr       =  mul_p.clmulr;\n     end\n   else\n     begin\n       assign ap_clmul        =  1'b0;\n       assign ap_clmulh       =  1'b0;\n       assign ap_clmulr       =  1'b0;\n     end\n\n   if (pt.BITMANIP_ZBP == 1)\n     begin\n       assign ap_grev         =  mul_p.grev;\n       assign ap_gorc         =  mul_p.gorc;\n       assign ap_shfl         =  mul_p.shfl;\n       assign ap_unshfl       =  mul_p.unshfl;\n       assign ap_xperm_n      =  mul_p.xperm_n;\n       assign ap_xperm_b      =  mul_p.xperm_b;\n       assign ap_xperm_h      =  mul_p.xperm_h;\n     end\n   else\n     begin\n       assign ap_grev         =  1'b0;\n       assign ap_gorc         =  1'b0;\n       assign ap_shfl         =  1'b0;\n       assign ap_unshfl       =  1'b0;\n       assign ap_xperm_n      =  1'b0;\n       assign ap_xperm_b      =  1'b0;\n       assign ap_xperm_h      =  1'b0;\n     end\n\n   if (pt.BITMANIP_ZBR == 1)\n     begin\n       assign ap_crc32_b      =  mul_p.crc32_b;\n       assign ap_crc32_h      =  mul_p.crc32_h;\n       assign ap_crc32_w      =  mul_p.crc32_w;\n       assign ap_crc32c_b     =  mul_p.crc32c_b;\n       assign ap_crc32c_h     =  mul_p.crc32c_h;\n       assign ap_crc32c_w     =  mul_p.crc32c_w;\n     end\n   else\n     begin\n       assign ap_crc32_b      =  1'b0;\n       assign ap_crc32_h      =  1'b0;\n       assign ap_crc32_w      =  1'b0;\n       assign ap_crc32c_b     =  1'b0;\n       assign ap_crc32c_h     =  1'b0;\n       assign ap_crc32c_w     =  1'b0;\n     end\n\n   if (pt.BITMANIP_ZBF == 1)\n     begin\n       assign ap_bfp          =  mul_p.bfp;\n     end\n   else\n     begin\n       assign ap_bfp          =  1'b0;\n     end\n\n\n   // *** End   - BitManip ***\n\n\n\n   assign mul_x_enable           =  mul_p.valid;\n   assign bit_x_enable           =  mul_p.valid;\n\n   assign rs1_ext_in[32]         =  mul_p.rs1_sign & rs1_in[31];\n   assign rs2_ext_in[32]         =  mul_p.rs2_sign & rs2_in[31];\n\n   assign rs1_ext_in[31:0]       =  rs1_in[31:0];\n   assign rs2_ext_in[31:0]       =  rs2_in[31:0];\n\n\n\n   // --------------------------- Multiply       ----------------------------------\n\n\n   logic signed [32:0]  rs1_x;\n   logic signed [32:0]  rs2_x;\n\n   rvdffe #(34) i_a_x_ff         (.*, .clk(clk),  .din({mul_p.low,rs1_ext_in[32:0]}),        .dout({low_x,rs1_x[32:0]}),                 .en(mul_x_enable));\n   rvdffe #(33) i_b_x_ff         (.*, .clk(clk),  .din(           rs2_ext_in[32:0] ),        .dout(       rs2_x[32:0] ),                 .en(mul_x_enable));\n\n\n   assign prod_x[65:0]           =  rs1_x  *  rs2_x;\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  BCOMPRESS, BDECOMPRESS * * * * * * * * * * * * *\n\n\n   // *** BCOMPRESS == \"gather\"  ***\n\n   logic        [31:0]    bcompress_d;\n   logic                  bcompress_test_bit_d;\n   integer                bcompress_i, bcompress_j;\n\n\n   always_comb\n     begin\n\n       bcompress_j                             =      0;\n       bcompress_test_bit_d                    =   1'b0;\n       bcompress_d[31:0]                       =  32'b0;\n\n       for (bcompress_i=0; bcompress_i<32; bcompress_i++)\n         begin\n             bcompress_test_bit_d              =  rs2_in[bcompress_i];\n             if (bcompress_test_bit_d)\n               begin\n                  bcompress_d[bcompress_j]     =  rs1_in[bcompress_i];\n                  bcompress_j                  =  bcompress_j + 1;\n               end  // IF  bcompress_test_bit\n         end        // FOR bcompress_i\n     end            // ALWAYS_COMB\n\n\n\n   // *** BDECOMPRESS == \"scatter\" ***\n\n   logic        [31:0]    bdecompress_d;\n   logic                  bdecompress_test_bit_d;\n   integer                bdecompress_i, bdecompress_j;\n\n\n   always_comb\n     begin\n\n       bdecompress_j                           =      0;\n       bdecompress_test_bit_d                  =   1'b0;\n       bdecompress_d[31:0]                     =  32'b0;\n\n       for (bdecompress_i=0; bdecompress_i<32; bdecompress_i++)\n         begin\n             bdecompress_test_bit_d            =  rs2_in[bdecompress_i];\n             if (bdecompress_test_bit_d)\n               begin\n                  bdecompress_d[bdecompress_i] =  rs1_in[bdecompress_j];\n                  bdecompress_j                =  bdecompress_j + 1;\n               end  // IF  bdecompress_test_bit\n         end        // FOR bdecompress_i\n     end            // ALWAYS_COMB\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  CLMUL, CLMULH, CLMULR  * * * * * * * * * * * * *\n\n   logic        [62:0]    clmul_raw_d;\n\n\n   assign clmul_raw_d[62:0]      = ( {63{rs2_in[00]}} & {31'b0,rs1_in[31:0]      } ) ^\n                                   ( {63{rs2_in[01]}} & {30'b0,rs1_in[31:0], 1'b0} ) ^\n                                   ( {63{rs2_in[02]}} & {29'b0,rs1_in[31:0], 2'b0} ) ^\n                                   ( {63{rs2_in[03]}} & {28'b0,rs1_in[31:0], 3'b0} ) ^\n                                   ( {63{rs2_in[04]}} & {27'b0,rs1_in[31:0], 4'b0} ) ^\n                                   ( {63{rs2_in[05]}} & {26'b0,rs1_in[31:0], 5'b0} ) ^\n                                   ( {63{rs2_in[06]}} & {25'b0,rs1_in[31:0], 6'b0} ) ^\n                                   ( {63{rs2_in[07]}} & {24'b0,rs1_in[31:0], 7'b0} ) ^\n                                   ( {63{rs2_in[08]}} & {23'b0,rs1_in[31:0], 8'b0} ) ^\n                                   ( {63{rs2_in[09]}} & {22'b0,rs1_in[31:0], 9'b0} ) ^\n                                   ( {63{rs2_in[10]}} & {21'b0,rs1_in[31:0],10'b0} ) ^\n                                   ( {63{rs2_in[11]}} & {20'b0,rs1_in[31:0],11'b0} ) ^\n                                   ( {63{rs2_in[12]}} & {19'b0,rs1_in[31:0],12'b0} ) ^\n                                   ( {63{rs2_in[13]}} & {18'b0,rs1_in[31:0],13'b0} ) ^\n                                   ( {63{rs2_in[14]}} & {17'b0,rs1_in[31:0],14'b0} ) ^\n                                   ( {63{rs2_in[15]}} & {16'b0,rs1_in[31:0],15'b0} ) ^\n                                   ( {63{rs2_in[16]}} & {15'b0,rs1_in[31:0],16'b0} ) ^\n                                   ( {63{rs2_in[17]}} & {14'b0,rs1_in[31:0],17'b0} ) ^\n                                   ( {63{rs2_in[18]}} & {13'b0,rs1_in[31:0],18'b0} ) ^\n                                   ( {63{rs2_in[19]}} & {12'b0,rs1_in[31:0],19'b0} ) ^\n                                   ( {63{rs2_in[20]}} & {11'b0,rs1_in[31:0],20'b0} ) ^\n                                   ( {63{rs2_in[21]}} & {10'b0,rs1_in[31:0],21'b0} ) ^\n                                   ( {63{rs2_in[22]}} & { 9'b0,rs1_in[31:0],22'b0} ) ^\n                                   ( {63{rs2_in[23]}} & { 8'b0,rs1_in[31:0],23'b0} ) ^\n                                   ( {63{rs2_in[24]}} & { 7'b0,rs1_in[31:0],24'b0} ) ^\n                                   ( {63{rs2_in[25]}} & { 6'b0,rs1_in[31:0],25'b0} ) ^\n                                   ( {63{rs2_in[26]}} & { 5'b0,rs1_in[31:0],26'b0} ) ^\n                                   ( {63{rs2_in[27]}} & { 4'b0,rs1_in[31:0],27'b0} ) ^\n                                   ( {63{rs2_in[28]}} & { 3'b0,rs1_in[31:0],28'b0} ) ^\n                                   ( {63{rs2_in[29]}} & { 2'b0,rs1_in[31:0],29'b0} ) ^\n                                   ( {63{rs2_in[30]}} & { 1'b0,rs1_in[31:0],30'b0} ) ^\n                                   ( {63{rs2_in[31]}} & {      rs1_in[31:0],31'b0} );\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  GREV         * * * * * * * * * * * * * * * * * *\n\n   // uint32_t grev32(uint32_t rs1, uint32_t rs2)\n   // {\n   //     uint32_t x = rs1;\n   //     int shamt = rs2 & 31;\n   //\n   //     if (shamt &  1)  x = ( (x & 0x55555555) <<  1) | ( (x & 0xAAAAAAAA) >>  1);\n   //     if (shamt &  2)  x = ( (x & 0x33333333) <<  2) | ( (x & 0xCCCCCCCC) >>  2);\n   //     if (shamt &  4)  x = ( (x & 0x0F0F0F0F) <<  4) | ( (x & 0xF0F0F0F0) >>  4);\n   //     if (shamt &  8)  x = ( (x & 0x00FF00FF) <<  8) | ( (x & 0xFF00FF00) >>  8);\n   //     if (shamt & 16)  x = ( (x & 0x0000FFFF) << 16) | ( (x & 0xFFFF0000) >> 16);\n   //\n   //     return x;\n   //  }\n\n\n   logic        [31:0]    grev1_d;\n   logic        [31:0]    grev2_d;\n   logic        [31:0]    grev4_d;\n   logic        [31:0]    grev8_d;\n   logic        [31:0]    grev_d;\n\n\n   assign grev1_d[31:0]       = (rs2_in[0])  ?  {rs1_in[30],rs1_in[31],rs1_in[28],rs1_in[29],rs1_in[26],rs1_in[27],rs1_in[24],rs1_in[25],\n                                                 rs1_in[22],rs1_in[23],rs1_in[20],rs1_in[21],rs1_in[18],rs1_in[19],rs1_in[16],rs1_in[17],\n                                                 rs1_in[14],rs1_in[15],rs1_in[12],rs1_in[13],rs1_in[10],rs1_in[11],rs1_in[08],rs1_in[09],\n                                                 rs1_in[06],rs1_in[07],rs1_in[04],rs1_in[05],rs1_in[02],rs1_in[03],rs1_in[00],rs1_in[01]}  :  rs1_in[31:0];\n\n   assign grev2_d[31:0]       = (rs2_in[1])  ?  {grev1_d[29:28],grev1_d[31:30],grev1_d[25:24],grev1_d[27:26],\n                                                 grev1_d[21:20],grev1_d[23:22],grev1_d[17:16],grev1_d[19:18],\n                                                 grev1_d[13:12],grev1_d[15:14],grev1_d[09:08],grev1_d[11:10],\n                                                 grev1_d[05:04],grev1_d[07:06],grev1_d[01:00],grev1_d[03:02]}  :  grev1_d[31:0];\n\n   assign grev4_d[31:0]       = (rs2_in[2])  ?  {grev2_d[27:24],grev2_d[31:28],grev2_d[19:16],grev2_d[23:20],\n                                                 grev2_d[11:08],grev2_d[15:12],grev2_d[03:00],grev2_d[07:04]}  :  grev2_d[31:0];\n\n   assign grev8_d[31:0]       = (rs2_in[3])  ?  {grev4_d[23:16],grev4_d[31:24],grev4_d[07:00],grev4_d[15:08]}  :  grev4_d[31:0];\n\n   assign grev_d[31:0]        = (rs2_in[4])  ?  {grev8_d[15:00],grev8_d[31:16]}  :  grev8_d[31:0];\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  GORC         * * * * * * * * * * * * * * * * * *\n\n   // uint32_t gorc32(uint32_t rs1, uint32_t rs2)\n   // {\n   //     uint32_t x = rs1;\n   //     int shamt = rs2 & 31;\n   //\n   //     if (shamt &  1)  x |= ( (x & 0x55555555) <<  1) | ( (x & 0xAAAAAAAA) >>  1);\n   //     if (shamt &  2)  x |= ( (x & 0x33333333) <<  2) | ( (x & 0xCCCCCCCC) >>  2);\n   //     if (shamt &  4)  x |= ( (x & 0x0F0F0F0F) <<  4) | ( (x & 0xF0F0F0F0) >>  4);\n   //     if (shamt &  8)  x |= ( (x & 0x00FF00FF) <<  8) | ( (x & 0xFF00FF00) >>  8);\n   //     if (shamt & 16)  x |= ( (x & 0x0000FFFF) << 16) | ( (x & 0xFFFF0000) >> 16);\n   //\n   //     return x;\n   //  }\n\n\n   logic        [31:0]    gorc1_d;\n   logic        [31:0]    gorc2_d;\n   logic        [31:0]    gorc4_d;\n   logic        [31:0]    gorc8_d;\n   logic        [31:0]    gorc_d;\n\n\n   assign gorc1_d[31:0]       = ( {32{rs2_in[0]}} & {rs1_in[30],rs1_in[31],rs1_in[28],rs1_in[29],rs1_in[26],rs1_in[27],rs1_in[24],rs1_in[25],\n                                                     rs1_in[22],rs1_in[23],rs1_in[20],rs1_in[21],rs1_in[18],rs1_in[19],rs1_in[16],rs1_in[17],\n                                                     rs1_in[14],rs1_in[15],rs1_in[12],rs1_in[13],rs1_in[10],rs1_in[11],rs1_in[08],rs1_in[09],\n                                                     rs1_in[06],rs1_in[07],rs1_in[04],rs1_in[05],rs1_in[02],rs1_in[03],rs1_in[00],rs1_in[01]} ) | rs1_in[31:0];\n\n   assign gorc2_d[31:0]       = ( {32{rs2_in[1]}} & {gorc1_d[29:28],gorc1_d[31:30],gorc1_d[25:24],gorc1_d[27:26],\n                                                     gorc1_d[21:20],gorc1_d[23:22],gorc1_d[17:16],gorc1_d[19:18],\n                                                     gorc1_d[13:12],gorc1_d[15:14],gorc1_d[09:08],gorc1_d[11:10],\n                                                     gorc1_d[05:04],gorc1_d[07:06],gorc1_d[01:00],gorc1_d[03:02]} ) | gorc1_d[31:0];\n\n   assign gorc4_d[31:0]       = ( {32{rs2_in[2]}} & {gorc2_d[27:24],gorc2_d[31:28],gorc2_d[19:16],gorc2_d[23:20],\n                                                     gorc2_d[11:08],gorc2_d[15:12],gorc2_d[03:00],gorc2_d[07:04]} ) | gorc2_d[31:0];\n\n   assign gorc8_d[31:0]       = ( {32{rs2_in[3]}} & {gorc4_d[23:16],gorc4_d[31:24],gorc4_d[07:00],gorc4_d[15:08]} ) | gorc4_d[31:0];\n\n   assign gorc_d[31:0]        = ( {32{rs2_in[4]}} & {gorc8_d[15:00],gorc8_d[31:16]} ) | gorc8_d[31:0];\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  SHFL, UNSHLF * * * * * * * * * * * * * * * * * *\n\n   // uint32_t shuffle32_stage (uint32_t src, uint32_t maskL, uint32_t maskR, int N)\n   // {\n   //     uint32_t x  = src & ~(maskL | maskR);\n   //     x          |= ((src << N) & maskL) | ((src >> N) & maskR);\n   //     return x;\n   // }\n   //\n   //\n   //\n   // uint32_t shfl32(uint32_t rs1, uint32_t rs2)\n   // {\n   //     uint32_t x = rs1;\n   //     int shamt = rs2 & 15\n   //\n   //     if (shamt & 8)  x = shuffle32_stage(x, 0x00ff0000, 0x0000ff00, 8);\n   //     if (shamt & 4)  x = shuffle32_stage(x, 0x0f000f00, 0x00f000f0, 4);\n   //     if (shamt & 2)  x = shuffle32_stage(x, 0x30303030, 0xc0c0c0c0, 2);\n   //     if (shamt & 1)  x = shuffle32_stage(x, 0x44444444, 0x22222222, 1);\n   //\n   //     return x;\n   // }\n\n\n   logic        [31:0]    shfl8_d;\n   logic        [31:0]    shfl4_d;\n   logic        [31:0]    shfl2_d;\n   logic        [31:0]    shfl_d;\n\n\n\n   assign shfl8_d[31:0]       = (rs2_in[3])  ?  {rs1_in[31:24],rs1_in[15:08],rs1_in[23:16],rs1_in[07:00]}      :  rs1_in[31:0];\n\n   assign shfl4_d[31:0]       = (rs2_in[2])  ?  {shfl8_d[31:28],shfl8_d[23:20],shfl8_d[27:24],shfl8_d[19:16],\n                                                 shfl8_d[15:12],shfl8_d[07:04],shfl8_d[11:08],shfl8_d[03:00]}  :  shfl8_d[31:0];\n\n   assign shfl2_d[31:0]       = (rs2_in[1])  ?  {shfl4_d[31:30],shfl4_d[27:26],shfl4_d[29:28],shfl4_d[25:24],\n                                                 shfl4_d[23:22],shfl4_d[19:18],shfl4_d[21:20],shfl4_d[17:16],\n                                                 shfl4_d[15:14],shfl4_d[11:10],shfl4_d[13:12],shfl4_d[09:08],\n                                                 shfl4_d[07:06],shfl4_d[03:02],shfl4_d[05:04],shfl4_d[01:00]}  :  shfl4_d[31:0];\n\n   assign shfl_d[31:0]        = (rs2_in[0])  ?  {shfl2_d[31],shfl2_d[29],shfl2_d[30],shfl2_d[28],shfl2_d[27],shfl2_d[25],shfl2_d[26],shfl2_d[24],\n                                                 shfl2_d[23],shfl2_d[21],shfl2_d[22],shfl2_d[20],shfl2_d[19],shfl2_d[17],shfl2_d[18],shfl2_d[16],\n                                                 shfl2_d[15],shfl2_d[13],shfl2_d[14],shfl2_d[12],shfl2_d[11],shfl2_d[09],shfl2_d[10],shfl2_d[08],\n                                                 shfl2_d[07],shfl2_d[05],shfl2_d[06],shfl2_d[04],shfl2_d[03],shfl2_d[01],shfl2_d[02],shfl2_d[00]}  :  shfl2_d[31:0];\n\n\n\n\n   // uint32_t unshfl32(uint32_t rs1, uint32_t rs2)\n   // {\n   //     uint32_t x = rs1;\n   //     int shamt = rs2 & 15\n   //\n   //     if (shamt & 1)  x = shuffle32_stage(x, 0x44444444, 0x22222222, 1);\n   //     if (shamt & 2)  x = shuffle32_stage(x, 0x30303030, 0xc0c0c0c0, 2);\n   //     if (shamt & 4)  x = shuffle32_stage(x, 0x0f000f00, 0x00f000f0, 4);\n   //     if (shamt & 8)  x = shuffle32_stage(x, 0x00ff0000, 0x0000ff00, 8);\n   //\n   //     return x;\n   // }\n\n\n   logic        [31:0]    unshfl1_d;\n   logic        [31:0]    unshfl2_d;\n   logic        [31:0]    unshfl4_d;\n   logic        [31:0]    unshfl_d;\n\n\n   assign unshfl1_d[31:0]     = (rs2_in[0])  ?  {rs1_in[31],rs1_in[29],rs1_in[30],rs1_in[28],rs1_in[27],rs1_in[25],rs1_in[26],rs1_in[24],\n                                                 rs1_in[23],rs1_in[21],rs1_in[22],rs1_in[20],rs1_in[19],rs1_in[17],rs1_in[18],rs1_in[16],\n                                                 rs1_in[15],rs1_in[13],rs1_in[14],rs1_in[12],rs1_in[11],rs1_in[09],rs1_in[10],rs1_in[08],\n                                                 rs1_in[07],rs1_in[05],rs1_in[06],rs1_in[04],rs1_in[03],rs1_in[01],rs1_in[02],rs1_in[00]}  :  rs1_in[31:0];\n\n   assign unshfl2_d[31:0]     = (rs2_in[1])  ?  {unshfl1_d[31:30],unshfl1_d[27:26],unshfl1_d[29:28],unshfl1_d[25:24],\n                                                 unshfl1_d[23:22],unshfl1_d[19:18],unshfl1_d[21:20],unshfl1_d[17:16],\n                                                 unshfl1_d[15:14],unshfl1_d[11:10],unshfl1_d[13:12],unshfl1_d[09:08],\n                                                 unshfl1_d[07:06],unshfl1_d[03:02],unshfl1_d[05:04],unshfl1_d[01:00]}  :  unshfl1_d[31:0];\n\n   assign unshfl4_d[31:0]     = (rs2_in[2])  ?  {unshfl2_d[31:28],unshfl2_d[23:20],unshfl2_d[27:24],unshfl2_d[19:16],\n                                                 unshfl2_d[15:12],unshfl2_d[07:04],unshfl2_d[11:08],unshfl2_d[03:00]}  :  unshfl2_d[31:0];\n\n   assign unshfl_d[31:0]      = (rs2_in[3])  ?  {unshfl4_d[31:24],unshfl4_d[15:08],unshfl4_d[23:16],unshfl4_d[07:00]}  :  unshfl4_d[31:0];\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  XPERM          * * * * * * * * * * * * * * * * *\n\n//\n// These instructions operate on nibbles/bytes/half-words/words.\n// rs1 is a vector of data words and rs2 is a vector of indices into rs1.\n// The result of the instruction is the vector rs2 with each element replaced by the corresponding data word from rs1,\n// or zero then the index in rs2 is out of bounds.\n//\n//   uint_xlen_t xperm(uint_xlen_t rs1, uint_xlen_t rs2, int sz_log2)\n//   {\n//       uint_xlen_t r = 0;\n//       uint_xlen_t sz = 1LL << sz_log2;\n//       uint_xlen_t mask = (1LL << sz) - 1;\n//       for (int i = 0; i < XLEN; i += sz)\n//           { uint_xlen_t pos = (("}
{"text": "rs2 >> i) & mask) << sz_log2;\n//             if (pos < XLEN)\n//                 r |= ((rs1 >> pos) & mask) << i;\n//           }\n//       return r;\n//   }\n//\n// uint_xlen_t xperm_n (uint_xlen_t rs1, uint_xlen_t rs2) { return xperm(rs1, rs2, 2); }\n// uint_xlen_t xperm_b (uint_xlen_t rs1, uint_xlen_t rs2) { return xperm(rs1, rs2, 3); }\n// uint_xlen_t xperm_h (uint_xlen_t rs1, uint_xlen_t rs2) { return xperm(rs1, rs2, 4); }\n// uint_xlen_t xperm_w (uint_xlen_t rs1, uint_xlen_t rs2) { return xperm(rs1, rs2, 5); }   Not part of RV32\n//\n// The xperm.[nbhw] instructions can be implemented with an XLEN/4-lane nibble-wide crossbarswitch.\n\n// *** XPERM_B ***\n\n   // XLEN    = 32\n   // SZ_LOG2 =  3\n   // SZ      = 4'd8;\n   // MASK    = ( 1 << 8 ) - 1\n   //         = 8'hFF\n\n   // integer                xperm_b_i;\n   // logic        [31:0]    xperm_b_r;\n   // logic        [3:0]     xperm_b_sz;\n   // logic        [7:0]     xperm_b_mask;\n   // logic        [31:0]    xperm_b_pos;\n   //\n   //\n   // assign xperm_b_sz[3:0]        =  4'd8;\n   // assign xperm_b_mask[7:0]      =  8'hff;\n   //\n   // always_comb\n   //   begin\n   //     xperm_b_r[31:0] = 32'b0;\n   //\n   //     for (xperm_b_i=0; xperm_b_i<32; xperm_b_i = xperm_b_i + xperm_b_sz)     // This code did not work...\n   //       begin\n   //         xperm_b_pos[31:0] = ( (rs2_in[31:0] >> xperm_b_i) & {24'h0,xperm_b_mask[7:0]} ) << 3;\n   //         if (xperm_b_pos[31:0] < 32'd32)\n   //            xperm_b_r[31:0] = xperm_b_r[31:0] | ( ((rs1_in[31:0] >> xperm_b_pos[4:0]) & {24'h0,xperm_b_mask[7:0]}) << xperm_b_i );\n   //       end\n   //   end\n\n   logic        [31:0]    xperm_n;\n   logic        [31:0]    xperm_b;\n   logic        [31:0]    xperm_h;\n\n   assign xperm_n[03:00]         =  { 4{    ~rs2_in[03]     }} & ( (rs1_in[31:0] >> {rs2_in[02:00],2'b0}) &     4'hf );   // This is a 8:1 mux with qualified selects\n   assign xperm_n[07:04]         =  { 4{    ~rs2_in[07]     }} & ( (rs1_in[31:0] >> {rs2_in[06:04],2'b0}) &     4'hf );\n   assign xperm_n[11:08]         =  { 4{    ~rs2_in[11]     }} & ( (rs1_in[31:0] >> {rs2_in[10:08],2'b0}) &     4'hf );\n   assign xperm_n[15:12]         =  { 4{    ~rs2_in[15]     }} & ( (rs1_in[31:0] >> {rs2_in[14:12],2'b0}) &     4'hf );\n   assign xperm_n[19:16]         =  { 4{    ~rs2_in[19]     }} & ( (rs1_in[31:0] >> {rs2_in[18:16],2'b0}) &     4'hf );\n   assign xperm_n[23:20]         =  { 4{    ~rs2_in[23]     }} & ( (rs1_in[31:0] >> {rs2_in[22:20],2'b0}) &     4'hf );\n   assign xperm_n[27:24]         =  { 4{    ~rs2_in[27]     }} & ( (rs1_in[31:0] >> {rs2_in[26:24],2'b0}) &     4'hf );\n   assign xperm_n[31:28]         =  { 4{    ~rs2_in[31]     }} & ( (rs1_in[31:0] >> {rs2_in[30:28],2'b0}) &     4'hf );\n\n   assign xperm_b[07:00]         =  { 8{ ~(| rs2_in[07:02]) }} & ( (rs1_in[31:0] >> {rs2_in[01:00],3'b0}) &    8'hff );   // This is a 4:1 mux with qualified selects\n   assign xperm_b[15:08]         =  { 8{ ~(| rs2_in[15:10]) }} & ( (rs1_in[31:0] >> {rs2_in[09:08],3'b0}) &    8'hff );\n   assign xperm_b[23:16]         =  { 8{ ~(| rs2_in[23:18]) }} & ( (rs1_in[31:0] >> {rs2_in[17:16],3'b0}) &    8'hff );\n   assign xperm_b[31:24]         =  { 8{ ~(| rs2_in[31:26]) }} & ( (rs1_in[31:0] >> {rs2_in[25:24],3'b0}) &    8'hff );\n\n   assign xperm_h[15:00]         =  {16{ ~(| rs2_in[15:01]) }} & ( (rs1_in[31:0] >> {rs2_in[00]   ,4'b0}) & 16'hffff );   // This is a 2:1 mux with qualified selects\n   assign xperm_h[31:16]         =  {16{ ~(| rs2_in[31:17]) }} & ( (rs1_in[31:0] >> {rs2_in[16]   ,4'b0}) & 16'hffff );\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  CRC32, CRC32c  * * * * * * * * * * * * * * * * *\n\n   // ***  computed from   https: //crccalc.com  ***\n   //\n   // \"a\" is 8'h61 = 8'b0110_0001    (8'h61 ^ 8'hff = 8'h9e)\n   //\n   // Input must first be XORed with 32'hffff_ffff\n   //\n   //\n   // CRC32\n   //\n   // Input    Output        Input      Output\n   // -----   --------      --------   --------\n   // \"a\"     e8b7be43      ffffff9e   174841bc\n   // \"aa\"    078a19d7      ffff9e9e   f875e628\n   // \"aaaa\"  ad98e545      9e9e9e9e   5267a1ba\n   //\n   //\n   //\n   // CRC32c\n   //\n   // Input    Output        Input      Output\n   // -----   --------      --------   --------\n   // \"a\"     c1d04330      ffffff9e   3e2fbccf\n   // \"aa\"    f1f2dac2      ffff9e9e   0e0d253d\n   // \"aaaa\"  6a52eeb0      9e9e9e9e   95ad114f\n\n\n   logic                  crc32_all;\n   logic        [31:0]    crc32_poly_rev;\n   logic        [31:0]    crc32c_poly_rev;\n   integer                crc32_bi, crc32_hi, crc32_wi, crc32c_bi, crc32c_hi, crc32c_wi;\n   logic        [31:0]    crc32_bd, crc32_hd, crc32_wd, crc32c_bd, crc32c_hd, crc32c_wd;\n\n\n   assign crc32_all              =  ap_crc32_b  | ap_crc32_h  | ap_crc32_w | ap_crc32c_b | ap_crc32c_h | ap_crc32c_w;\n\n   assign crc32_poly_rev[31:0]   =  32'hEDB88320;    // bit reverse of 32'h04C11DB7\n   assign crc32c_poly_rev[31:0]  =  32'h82F63B78;    // bit reverse of 32'h1EDC6F41\n\n\n   always_comb\n     begin\n       crc32_bd[31:0]            =  rs1_in[31:0];\n\n       for (crc32_bi=0; crc32_bi<8; crc32_bi++)\n         begin\n            crc32_bd[31:0] = (crc32_bd[31:0] >> 1) ^ (crc32_poly_rev[31:0] & {32{crc32_bd[0]}});\n         end      // FOR    crc32_bi\n     end          // ALWAYS_COMB\n\n\n   always_comb\n     begin\n       crc32_hd[31:0]            =  rs1_in[31:0];\n\n       for (crc32_hi=0; crc32_hi<16; crc32_hi++)\n         begin\n            crc32_hd[31:0] = (crc32_hd[31:0] >> 1) ^ (crc32_poly_rev[31:0] & {32{crc32_hd[0]}});\n         end      // FOR    crc32_hi\n     end          // ALWAYS_COMB\n\n\n   always_comb\n     begin\n       crc32_wd[31:0]            =  rs1_in[31:0];\n\n       for (crc32_wi=0; crc32_wi<32; crc32_wi++)\n         begin\n            crc32_wd[31:0] = (crc32_wd[31:0] >> 1) ^ (crc32_poly_rev[31:0] & {32{crc32_wd[0]}});\n         end      // FOR    crc32_wi\n     end          // ALWAYS_COMB\n\n\n\n\n   always_comb\n     begin\n       crc32c_bd[31:0]           =  rs1_in[31:0];\n\n       for (crc32c_bi=0; crc32c_bi<8; crc32c_bi++)\n         begin\n            crc32c_bd[31:0] = (crc32c_bd[31:0] >> 1) ^ (crc32c_poly_rev[31:0] & {32{crc32c_bd[0]}});\n         end      // FOR    crc32c_bi\n     end          // ALWAYS_COMB\n\n\n   always_comb\n     begin\n       crc32c_hd[31:0]           =  rs1_in[31:0];\n\n       for (crc32c_hi=0; crc32c_hi<16; crc32c_hi++)\n         begin\n            crc32c_hd[31:0] = (crc32c_hd[31:0] >> 1) ^ (crc32c_poly_rev[31:0] & {32{crc32c_hd[0]}});\n         end      // FOR    crc32c_hi\n     end          // ALWAYS_COMB\n\n\n   always_comb\n     begin\n       crc32c_wd[31:0]           =  rs1_in[31:0];\n\n       for (crc32c_wi=0; crc32c_wi<32; crc32c_wi++)\n         begin\n            crc32c_wd[31:0] = (crc32c_wd[31:0] >> 1) ^ (crc32c_poly_rev[31:0] & {32{crc32c_wd[0]}});\n         end      // FOR    crc32c_wi\n     end          // ALWAYS_COMB\n\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  BFP          * * * * * * * * * * * * * * * * * *\n\n\n   // uint_xlen_t bfp(uint_xlen_t rs1, uint_xlen_t rs2)\n   // {\n   //    uint_xlen_t cfg = rs2 >> (XLEN/2);\n   //    if ((cfg >> 30) == 2) cfg = cfg >> 16;\n   //    int len          = (cfg >> 8) & (XLEN/2-1);\n   //    int off          = cfg & (XLEN-1);\n   //    len              = len ? len : XLEN/2;\n   //    uint_xlen_t mask = slo(0, len) << off;\n   //    uint_xlen_t data = rs2 << off;\n   //    return (data & mask) | (rs1 & ~mask);\n\n\n   logic        [4:0]     bfp_len;\n   logic        [4:0]     bfp_off;\n   logic        [31:0]    bfp_len_mask_;\n   logic        [31:0]    bfp_off_mask_;\n   logic        [15:0]    bfp_preshift_data;\n   logic        [31:0]    bfp_shift_data;\n   logic        [31:0]    bfp_shift_mask;\n   logic        [31:0]    bfp_result_d;\n\n\n   assign bfp_len[3:0]           =  rs2_in[27:24];\n   assign bfp_len[4]             = (bfp_len[3:0] == 4'b0);   // If LEN field is zero, then LEN=16\n   assign bfp_off[4:0]           =  rs2_in[20:16];\n\n   assign bfp_len_mask_[31:0]    =  32'hffff_ffff  <<  bfp_len[4:0];\n   assign bfp_off_mask_[31:0]    =  32'hffff_ffff  <<  bfp_off[4:0];\n   assign bfp_preshift_data[15:0]=  rs2_in[15:0] & ~bfp_len_mask_[15:0];\n\n   assign bfp_shift_data[31:0]   = {16'b0,bfp_preshift_data[15:0]}  <<  bfp_off[4:0];\n   assign bfp_shift_mask[31:0]   = (bfp_len_mask_[31:0]             <<  bfp_off[4:0]) | ~bfp_off_mask_[31:0];\n\n   assign bfp_result_d[31:0]     = bfp_shift_data[31:0] | (rs1_in[31:0] & bfp_shift_mask[31:0]);\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  Common logic * * * * * * * * * * * * * * * * * *\n\n\n   assign bitmanip_sel_d         =  ap_bcompress | ap_bdecompress | ap_clmul | ap_clmulh | ap_clmulr | ap_grev | ap_gorc | ap_shfl | ap_unshfl | crc32_all | ap_bfp | ap_xperm_n | ap_xperm_b | ap_xperm_h;\n\n   assign bitmanip_d[31:0]       = ( {32{ap_bcompress}}    &       bcompress_d[31:0]   ) |\n                                   ( {32{ap_bdecompress}}  &       bdecompress_d[31:0] ) |\n                                   ( {32{ap_clmul}}        &       clmul_raw_d[31:0]   ) |\n                                   ( {32{ap_clmulh}}       & {1'b0,clmul_raw_d[62:32]} ) |\n                                   ( {32{ap_clmulr}}       &       clmul_raw_d[62:31]  ) |\n                                   ( {32{ap_grev}}         &       grev_d[31:0]        ) |\n                                   ( {32{ap_gorc}}         &       gorc_d[31:0]        ) |\n                                   ( {32{ap_shfl}}         &       shfl_d[31:0]        ) |\n                                   ( {32{ap_unshfl}}       &       unshfl_d[31:0]      ) |\n                                   ( {32{ap_crc32_b}}      &       crc32_bd[31:0]      ) |\n                                   ( {32{ap_crc32_h}}      &       crc32_hd[31:0]      ) |\n                                   ( {32{ap_crc32_w}}      &       crc32_wd[31:0]      ) |\n                                   ( {32{ap_crc32c_b}}     &       crc32c_bd[31:0]     ) |\n                                   ( {32{ap_crc32c_h}}     &       crc32c_hd[31:0]     ) |\n                                   ( {32{ap_crc32c_w}}     &       crc32c_wd[31:0]     ) |\n                                   ( {32{ap_bfp}}          &       bfp_result_d[31:0]  ) |\n                                   ( {32{ap_xperm_n}}      &       xperm_n[31:0]       ) |\n                                   ( {32{ap_xperm_b}}      &       xperm_b[31:0]       ) |\n                                   ( {32{ap_xperm_h}}      &       xperm_h[31:0]       );\n\n\n\n   rvdffe #(33) i_bitmanip_ff    (.*, .clk(clk),  .din({bitmanip_sel_d,bitmanip_d[31:0]}),   .dout({bitmanip_sel_x,bitmanip_x[31:0]}),   .en(bit_x_enable));\n\n\n\n\n   assign result_x[31:0]         =  ( {32{~bitmanip_sel_x & ~low_x}} & prod_x[63:32]    ) |\n                                    ( {32{~bitmanip_sel_x &  low_x}} & prod_x[31:0]     ) |\n                                                                       bitmanip_x[31:0];\n\n\n\nendmodule  // el2_exu_mul_ctl\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n//********************************************************************************\n// Function: Top level file for Icache, Fetch, Branch prediction & Aligner\n// BFF -> F1 -> F2 -> A\n//********************************************************************************\n\nmodule el2_ifu\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n   input logic free_l2clk,                   // Clock always.                  Through one clock header.  For flops with    second header built in.\n   input logic active_clk,                   // Clock only while core active.  Through two clock headers. For flops without second clock header built in.\n   input logic clk,                          // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n   input logic rst_l,                        // reset, active low\n\n   input logic dec_i0_decode_d,              // Valid instruction at D and not blocked\n\n   input logic exu_flush_final, // flush, includes upper and lower\n   input logic dec_tlu_i0_commit_cmt , // committed i0\n   input logic dec_tlu_flush_err_wb , // flush due to parity error.\n   input logic dec_tlu_flush_noredir_wb, // don't fetch, validated with exu_flush_final\n   input logic [31:1] exu_flush_path_final, // flush fetch address\n\n   input logic [31:0]  dec_tlu_mrac_ff ,// Side_effect , cacheable for each region\n   input logic         dec_tlu_fence_i_wb, // fence.i, invalidate icache, validated with exu_flush_final\n   input logic         dec_tlu_flush_leak_one_wb, // ignore bp for leak one fetches\n\n   input logic                       dec_tlu_bpred_disable,     // disable all branch prediction\n   input logic                       dec_tlu_core_ecc_disable,  // disable ecc checking and flagging\n   input logic                       dec_tlu_force_halt,        // force halt\n\n  //-------------------------- IFU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            ifu_axi_awvalid,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_awid,\n   output logic [31:0]                     ifu_axi_awaddr,\n   output logic [3:0]                      ifu_axi_awregion,\n   output logic [7:0]                      ifu_axi_awlen,\n   output logic [2:0]                      ifu_axi_awsize,\n   output logic [1:0]                      ifu_axi_awburst,\n   output logic                            ifu_axi_awlock,\n   output logic [3:0]                      ifu_axi_awcache,\n   output logic [2:0]                      ifu_axi_awprot,\n   output logic [3:0]                      ifu_axi_awqos,\n\n   output logic                            ifu_axi_wvalid,\n   output logic [63:0]                     ifu_axi_wdata,\n   output logic [7:0]                      ifu_axi_wstrb,\n   output logic                            ifu_axi_wlast,\n\n   output logic                            ifu_axi_bready,\n\n   // AXI Read Channels\n   output logic                            ifu_axi_arvalid,\n   input  logic                            ifu_axi_arready,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_arid,\n   output logic [31:0]                     ifu_axi_araddr,\n   output logic [3:0]                      ifu_axi_arregion,\n   output logic [7:0]                      ifu_axi_arlen,\n   output logic [2:0]                      ifu_axi_arsize,\n   output logic [1:0]                      ifu_axi_arburst,\n   output logic                            ifu_axi_arlock,\n   output logic [3:0]                      ifu_axi_arcache,\n   output logic [2:0]                      ifu_axi_arprot,\n   output logic [3:0]                      ifu_axi_arqos,\n\n   input  logic                            ifu_axi_rvalid,\n   output logic                            ifu_axi_rready,\n   input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_rid,\n   input  logic [63:0]                     ifu_axi_rdata,\n   input  logic [1:0]                      ifu_axi_rresp,\n\n   input  logic                      ifu_bus_clk_en,\n\n   input  logic                      dma_iccm_req,\n   input  logic [31:0]               dma_mem_addr,\n   input  logic [2:0]                dma_mem_sz,\n   input  logic                      dma_mem_write,\n   input  logic [63:0]               dma_mem_wdata,\n   input  logic [2:0]                dma_mem_tag,       //  DMA Buffer entry number\n\n\n   input  logic                      dma_iccm_stall_any,\n   output logic                      iccm_dma_ecc_error,\n   output logic                      iccm_dma_rvalid,\n   output logic [63:0]               iccm_dma_rdata,\n   output logic [2:0]                iccm_dma_rtag,     //   Tag of the DMA req\n   output logic                      iccm_ready,\n\n   output logic       ifu_pmu_instr_aligned,\n   output logic       ifu_pmu_fetch_stall,\n   output logic       ifu_ic_error_start,     // has all of the I$ ecc/parity for data/tag\n\n//   I$ & ITAG Ports\n   output logic [31:1]               ic_rw_addr,         // Read/Write addresss to the Icache.\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_wr_en,           // Icache write enable, when filling the Icache.\n   output logic                      ic_rd_en,           // Icache read  enable.\n\n   output logic [pt.ICACHE_BANKS_WAY-1:0][70:0]               ic_wr_data,         // Data to fill to the Icache. With ECC\n   input  logic [63:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [70:0]              ic_debug_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [25:0]                     ictag_debug_rd_data,// Debug icache tag.\n   output logic [70:0]               ic_debug_wr_data,   // Debug wr cache.\n\n   output logic [70:0]               ifu_ic_debug_rd_data,\n\n   input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_eccerr,    //\n   input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_parerr,\n   output logic [63:0]               ic_premux_data,     // Premux data to be muxed with each way of the Icache.\n   output logic                      ic_sel_premux_data, // Select the premux data.\n\n   output logic [pt.ICACHE_INDEX_HI:3]               ic_debug_addr,      // Read/Write addresss to the Icache.\n   output logic                      ic_debug_rd_en,     // Icache debug rd\n   output logic                      ic_debug_wr_en,     // Icache debug wr\n   output logic                      ic_debug_tag_array, // Debug tag array\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_debug_way,       // Debug way. Rd or Wr.\n\n\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_tag_valid,       // Valid bits when accessing the Icache. One valid bit per way. F2 stage\n\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]                ic_rd_hit,          // Compare hits from Icache tags. Per way.  F2 stage\n   input  logic                      ic_tag_perr,        // Icache Tag parity error\n\n\n   // ICCM ports\n   output logic [pt.ICCM_BITS-1:1]               iccm_rw_addr,       // ICCM read/write address.\n   output logic                      iccm_wren,          // ICCM write enable (through the DMA)\n   output logic                      iccm_rden,          // ICCM read enable.\n   output logic [77:0]               iccm_wr_data,       // ICCM write data.\n   output logic [2:0]                iccm_wr_size,       // ICCM write location within DW.\n\n   input  logic [63:0]               iccm_rd_data,       // Data read from ICCM.\n   input  logic [77:0]               iccm_rd_data_ecc,   // Data + ECC read from ICCM.\n\n   // ICCM ECC status\n   output logic                      ifu_iccm_dma_rd_ecc_single_err, // This fetch has a single ICCM DMA ECC error.\n   output logic                      ifu_iccm_rd_ecc_single_err,     // This fetch has a single ICCM ECC error.\n   output logic                      ifu_iccm_rd_ecc_double_err,     // This fetch has a double ICCM ECC error.\n\n// Perf counter sigs\n   output logic       ifu_pmu_ic_miss, // ic miss\n   output logic       ifu_pmu_ic_hit, // ic hit\n   output logic       ifu_pmu_bus_error, // iside bus error\n   output logic       ifu_pmu_bus_busy,  // iside bus busy\n   output logic       ifu_pmu_bus_trxn, // iside bus transactions\n\n\n   output logic       ifu_i0_icaf,         // Instruction 0 access fault. From Aligner to Decode\n   output logic [1:0] ifu_i0_icaf_type, // Instruction 0 access fault type\n\n   output logic  ifu_i0_valid,        // Instruction 0 valid. From Aligner to Decode\n   output logic  ifu_i0_icaf_second,  // Instruction 0 has access fault on second 2B of 4B inst\n   output logic  ifu_i0_dbecc,        // Instruction 0 has double bit ecc error\n   output logic  iccm_dma_sb_error,   // Single Bit ECC error from a DMA access\n   output logic[31:0] ifu_i0_instr,   // Instruction 0 . From Aligner to Decode\n   output logic[31:1] ifu_i0_pc,      // Instruction 0 pc. From Aligner to Decode\n   output logic ifu_i0_pc4,           // Instruction 0 is 4 byte. From Aligner to Decode\n\n   output logic ifu_miss_state_idle,   // There is no outstanding miss. Cache miss state is idle.\n\n   output el2_br_pkt_t i0_brp,           // Instruction 0 branch packet. From Aligner to Decode\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifu_i0_bp_index, // BP index\n   output logic [pt.BHT_GHR_SIZE-1:0] ifu_i0_bp_fghr, // BP FGHR\n   output logic [pt.BTB_BTAG_SIZE-1:0] ifu_i0_bp_btag, // BP tag\n   output logic [$clog2(pt.BTB_SIZE)-1:0]         ifu_i0_fa_index,          // Fully associt btb index\n\n   input el2_predict_pkt_t  exu_mp_pkt, // mispredict packet\n   input logic [pt.BHT_GHR_SIZE-1:0] exu_mp_eghr, // execute ghr\n   input logic [pt.BHT_GHR_SIZE-1:0]  exu_mp_fghr,                    // Mispredict fghr\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  exu_mp_index,         // Mispredict index\n   input logic [pt.BTB_BTAG_SIZE-1:0]  exu_mp_btag,                   // Mispredict btag\n\n   input el2_br_tlu_pkt_t dec_tlu_br0_r_pkt, // slot0 update/error pkt\n   input logic [pt.BHT_GHR_SIZE-1:0] exu_i0_br_fghr_r, // fghr to bp\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_i0_br_index_r, // bp index\n   input logic [$clog2(pt.BTB_SIZE)-1:0] dec_fa_error_index, // Fully associt btb error index\n\n   input dec_tlu_flush_lower_wb,\n\n   output logic [15:0] ifu_i0_cinst,\n\n    output logic [31:1] ifu_pmp_addr,\n    input  logic        ifu_pmp_error,\n\n/// Icache debug\n   input  el2_cache_debug_pkt_t        dec_tlu_ic_diag_pkt ,\n   output logic                    ifu_ic_debug_rd_data_valid,\n   output logic                                iccm_buf_correct_ecc,\n   output logic                                iccm_correction_state,\n\n   input logic scan_mode\n   );\n\n   localparam TAGWIDTH = 2 ;\n   localparam IDWIDTH  = 2 ;\n\n   logic                   ifu_fb_consume1, ifu_fb_consume2;\n   logic [31:1]            ifc_fetch_addr_f;\n   logic [31:1]            ifc_fetch_addr_bf;\n  assign ifu_pmp_addr = ifc_fetch_addr_bf;\n\n   logic [1:0]   ifu_fetch_val;  // valids on a 2B boundary, left justified [7] implies valid fetch\n   logic [31:1]  ifu_fetch_pc;   // starting pc of fetch\n\n   logic iccm_rd_ecc_single_err, iccm_dma_rd_ecc_single_err, ic_error_start;\n   assign ifu_iccm_dma_rd_ecc_single_err = iccm_dma_rd_ecc_single_err;\n   assign ifu_iccm_rd_ecc_single_err = iccm_rd_ecc_single_err;\n   assign ifu_ic_error_start = ic_error_start;\n\n\n   logic        ic_write_stall;\n   logic        ic_dma_active;\n   logic        ifc_dma_access_ok;\n   logic [1:0]  ic_access_fault_f;\n   logic [1:0]  ic_access_fault_type_f;\n   logic        ifu_ic_mb_empty;\n\n   logic ic_hit_f;\n\n   logic [1:0] ifu_bp_way_f; // way indication; right justified\n   logic       ifu_bp_hit_taken_f; // kill next fetch; taken target found\n   logic [31:1] ifu_bp_btb_target_f; //  predicted target PC\n   logic        ifu_bp_inst_mask_f; // tell ic which valids to kill because of a taken branch; right justified\n   logic [1:0]  ifu_bp_hist1_f; // history counters for all 4 potential branches; right justified\n   logic [1:0]  ifu_bp_hist0_f; // history counters for all 4 potential branches; right justified\n   logic [11:0] ifu_bp_poffset_f; // predicted target\n   logic [1:0]  ifu_bp_ret_f; // predicted ret ; right justified\n   logic [1:0]  ifu_bp_pc4_f; // pc4 indication; right justified\n   logic [1:0]  ifu_bp_valid_f; // branch valid, right justified\n   logic [pt.BHT_GHR_SIZE-1:0] ifu_bp_fghr_f;\n   logic [1:0] [$clog2(pt.BTB_SIZE)-1:0] ifu_bp_fa_index_f;\n\n\n   logic [1:0]   ic_fetch_val_f;\n   logic [31:0] ic_data_f;\n   logic [31:0] ifu_fetch_data_f;\n   logic ifc_fetch_req_f;\n   logic ifc_fetch_req_f_raw;\n   logic iccm_dma_rd_ecc_double_err;\n   logic [1:0] iccm_rd_ecc_double_err;  // This fetch has an iccm double error.\n   assign ifu_iccm_rd_ecc_double_err = |iccm_rd_ecc_double_err || |iccm_dma_rd_ecc_double_err;\n\n   logic ifu_async_error_start;\n\n\n   assign ifu_fetch_data_f[31:0] = ic_data_f[31:0];\n   assign ifu_fetch_val[1:0] = ic_fetch_val_f[1:0];\n   assign ifu_fetch_pc[31:1] = ifc_fetch_addr_f[31:1];\n\n logic                       ifc_fetch_uncacheable_bf;      // The fetch request is uncacheable space. BF stage\n logic                       ifc_fetch_req_bf;              // Fetch request. Comes with the address.  BF stage\n logic                       ifc_fetch_req_bf_raw;          // Fetch request without some qualifications. Used for clock-gating. BF stage\n logic                       ifc_iccm_access_bf;            // This request is to the ICCM. Do not generate misses to the bus.\n logic                       ifc_region_acc_fault_bf;       // Access fault. in ICCM region but offset is outside defined ICCM.\n\n   // fetch control\n   el2_ifu_ifc_ctl #(.pt(pt)) ifc (.*\n                    );\n\n   // branch predictor\n   if (pt.BTB_ENABLE==1) begin  : bpred\n      el2_ifu_bp_ctl #(.pt(pt)) bp (.*);\n   end\n   else begin : bpred\n      assign ifu_bp_hit_taken_f = '0;\n      // verif wires\n      logic btb_wr_en_way0, btb_wr_en_way1,dec_tlu_error_wb;\n      logic [16+pt.BTB_BTAG_SIZE:0] btb_wr_data;\n      assign btb_wr_en_way0 = '0;\n      assign btb_wr_en_way1 = '0;\n      assign btb_wr_data = '0;\n      assign dec_tlu_error_wb ='0;\n      assign ifu_bp_inst_mask_f = 1'b1;\n   end\n\n\n\n   // aligner\n\n   el2_ifu_aln_ctl #(.pt(pt)) aln (\n                                    .*\n                                    );\n\n\n   // icache\n   el2_ifu_mem_ctl #(.pt(pt)) mem_ctl\n     (.*,\n      .ic_data_f(ic_data_f[31:0])\n      );\n\n\n\n   // Performance debug info\n   //\n   //\n`ifdef DUMP_BTB_ON\n   logic              exu_mp_valid; // conditional branch mispredict\n   logic exu_mp_way; // conditional branch mispredict\n   logic exu_mp_ataken; // direction is actual taken\n   logic exu_mp_boffset; // branch offsett\n   logic exu_mp_pc4; // branch is a 4B inst\n   logic exu_mp_call; // branch is a call inst\n   logic exu_mp_ret; // branch is a ret inst\n   logic exu_mp_ja; // branch is a jump always\n   logic [1:0] exu_mp_hist; // new history\n   logic [11:0] exu_mp_tgt; // target offset\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_mp_addr; // BTB/BHT address\n\n   assign exu_mp_valid = exu_mp_pkt.misp; // conditional branch mispredict\n   assign exu_mp_ataken = exu_mp_pkt.ataken;  // direction is actual taken\n   assign exu_mp_boffset = exu_mp_pkt.boffset;  // branch offset\n   assign exu_mp_pc4 = exu_mp_pkt.pc4;  // branch is a 4B inst\n   assign exu_mp_call = exu_mp_pkt.pcall;  // branch is a call inst\n   assign exu_mp_ret = exu_mp_pkt.pret;  // branch is a ret inst\n   assign exu_mp_ja = exu_mp_pkt.pja;  // branch is a jump always\n   assign exu_mp_way = exu_mp_pkt.way;  // branch is a jump always\n   assign exu_mp_hist[1:0] = exu_mp_pkt.hist[1:0];  // new history\n   assign exu_mp_tgt[11:0]  = exu_mp_pkt.toffset[11:0] ;  // target offset\n   assign exu_mp_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  = exu_mp_index[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ;  // BTB/BHT address\n\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] btb_rd_addr_f;\n `define DEC `CPU_TOP.dec\n `define EXU `CPU_TOP.exu\n   el2_btb_addr_hash f2hash(.pc(ifc_fetch_addr_f[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(btb_rd_addr_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n   logic [31:0] mppc_ns, mppc;\n   logic        exu_flush_final_d1;\n   assign mppc_ns[31:1] = `EXU.i0_flush_upper_x ? `EXU.exu_i0_pc_x : `EXU.dec_i0_pc_d;\n   assign mppc_ns[0] = 1'b0;\n   rvdff #(33)  junk_ff (.*, .clk(active_clk), .din({mppc_ns[31:0], exu_flush_final}), .dout({mppc[31:0], exu_flush_final_d1}));\n   logic  tmp_bnk;\n   assign tmp_bnk = bpred.bp.btb_sel_f[1];\n\n   always @(negedge clk) begin\n      if(`DEC.tlu.mcyclel[31:0] == 32'h0000_0010) begin\n         $display(\"BTB_CONFIG: %d\",pt.BTB_SIZE);\n         `ifndef BP_NOGSHARE\n         $display(\"BHT_CONFIG: %d gshare: 1\",pt.BHT_SIZE);\n         `else\n         $display(\"BHT_CONFIG: %d gshare: 0\",pt.BHT_SIZE);\n         `endif\n         $display(\"RS_CONFIG: %d\", pt.RET_STACK_SIZE);\n      end\n       if(exu_flush_final_d1 & ~(dec_tlu_br0_r_pkt.br_error | dec_tlu_br0_r_pkt.br_start_error) & (exu_mp_pkt.misp | exu_mp_pkt.ataken))\n         $display(\"%7d BTB_MP  : index: %0h bank: %0h call: %b ret: %b ataken: %b hist: %h valid: %b tag: %h targ: %h eghr: %b pred: %b ghr_index: %h brpc: %h way: %h\", `DEC.tlu.mcyclel[31:0]+32'ha, exu_mp_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO], 1'b0, exu_mp_call, exu_mp_ret, exu_mp_ataken, exu_mp_hist[1:0], exu_mp_valid, exu_mp_btag[pt.BTB_BTAG_SIZE-1:0], {exu_flush_path_final[31:1], 1'b0}, exu_mp_eghr[pt.BHT_GHR_SIZE-1:0], exu_mp_valid, bpred.bp.bht_wr_addr0, mppc[31:0], exu_mp_pkt.way);\n\n     for(int i = 0; i < 8; i++) begin\n      if(ifu_bp_valid_f[i] & ifc_fetch_req_f)\n        $display(\"%7d BTB_HIT : index: %0h bank: %0h call: %b ret: %b taken: %b strength: %b tag: %h targ: %0h ghr: %4b ghr_index: %h way: %h\", `DEC.tlu.mcyclel[31:0]+32'ha,btb_rd_addr_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],bpred.bp.btb_sel_f[1], bpred.bp.btb_rd_call_f, bpred.bp.btb_rd_ret_f, ifu_bp_hist1_f[tmp_bnk], ifu_bp_hist0_f[tmp_bnk], bpred.bp.fetch_rd_tag_f[pt.BTB_BTAG_SIZE-1:0], {ifu_bp_btb_target_f[31:1], 1'b0}, bpred.bp.fghr[pt.BHT_GHR_SIZE-1:0], bpred.bp.bht_rd_addr_f, ifu_bp_way_f[tmp_bnk]);\n     end\n      if(dec_tlu_br0_r_pkt.valid & ~(dec_tlu_br0_r_pkt.br_error | dec_tlu_br0_r_pkt.br_start_error))\n        $display(\"%7d BTB_UPD0: ghr_index: %0h bank: %0h hist: %h  way: %h\", `DEC.tlu.mcyclel[31:0]+32'ha,bpred.bp.br0_hashed_wb[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO],{dec_tlu_br0_r_pkt.middle}, dec_tlu_br0_r_pkt.hist, dec_tlu_br0_r_pkt.way);\n\n      if(dec_tlu_br0_r_pkt.br_error | dec_tlu_br0_r_pkt.br_start_error)\n        $display(\"%7d BTB_ERR0: index: %0h bank: %0h start: %b rfpc: %h way: %h\", `DEC.tlu.mcyclel[31:0]+32'ha,exu_i0_br_index_r[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],1'b0, dec_tlu_br0_r_pkt.br_start_error, {exu_flush_path_final[31:1], 1'b0}, dec_tlu_br0_r_pkt.way);\n   end // always @ (negedge clk)\n      function [1:0] encode4_2;\n      input [3:0] in;\n\n      encode4_2[1] = in[3] | in[2];\n      encode4_2[0] = in[3] | in[1];\n\n   endfunction\n`endif\nendmodule // el2_ifu\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n//********************************************************************************\n// Function: Instruction aligner\n//********************************************************************************\nmodule el2_ifu_aln_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n\n   input logic                                    scan_mode,                // Flop scan mode control\n   input logic                                    rst_l,                    // reset, active low\n   input logic                                    clk,                      // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n   input logic                                    active_clk,               // Clock only while core active.  Through two clock headers. For flops without second clock header built in.\n\n   input logic                                    ifu_async_error_start,    // ecc/parity related errors with current fetch - not sent down the pipe\n\n   input logic [1:0]                              iccm_rd_ecc_double_err,   // This fetch has a double ICCM ecc  error.\n\n   input logic [1:0]                              ic_access_fault_f,        // Instruction access fault for the current fetch.\n   input logic [1:0]                              ic_access_fault_type_f,   // Instruction access fault types\n\n   input logic                                    exu_flush_final,          // Flush from the pipeline.\n\n   input logic                                    dec_i0_decode_d,          // Valid instruction at D-stage and not blocked\n\n   input logic [31:0]                             ifu_fetch_data_f,         // fetch data in memory format - not right justified\n\n   input logic [1:0]                              ifu_fetch_val,            // valids on a 2B boundary, right justified\n   input logic [31:1]                             ifu_fetch_pc,             // starting pc of fetch\n\n\n\n   output logic                                   ifu_i0_valid,             // Instruction 0 is valid\n   output logic                                   ifu_i0_icaf,              // Instruction 0 has access fault\n   output logic [1:0]                             ifu_i0_icaf_type,         // Instruction 0 access fault type\n   output logic                                   ifu_i0_icaf_second,       // Instruction 0 has access fault on second 2B of 4B inst\n\n   output logic                                   ifu_i0_dbecc,             // Instruction 0 has double bit ecc error\n   output logic [31:0]                            ifu_i0_instr,             // Instruction 0\n   output logic [31:1]                            ifu_i0_pc,                // Instruction 0 PC\n   output logic                                   ifu_i0_pc4,\n\n   output logic                                   ifu_fb_consume1,          // Consumed one buffer. To fetch control fetch for buffer mass balance\n   output logic                                   ifu_fb_consume2,          // Consumed two buffers.To fetch control fetch for buffer mass balance\n\n\n   input logic [pt.BHT_GHR_SIZE-1:0]              ifu_bp_fghr_f,            // fetch GHR\n   input logic [31:1]                             ifu_bp_btb_target_f,      // predicted RET target\n   input logic [11:0]                             ifu_bp_poffset_f,         // predicted target offset\n   input logic [1:0] [$clog2(pt.BTB_SIZE)-1:0]    ifu_bp_fa_index_f,        // predicted branch index (fully associative option)\n\n   input logic [1:0]                              ifu_bp_hist0_f,           // history counters for all 4 potential branches, bit 1, right justified\n   input logic [1:0]                              ifu_bp_hist1_f,           // history counters for all 4 potential branches, bit 1, right justified\n   input logic [1:0]                              ifu_bp_pc4_f,             // pc4 indication, right justified\n   input logic [1:0]                              ifu_bp_way_f,             // way indication, right justified\n   input logic [1:0]                              ifu_bp_valid_f,           // branch valid, right justified\n   input logic [1:0]                              ifu_bp_ret_f,             // predicted ret indication, right justified\n\n\n   output el2_br_pkt_t                           i0_brp,                   // Branch packet for I0.\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]   ifu_i0_bp_index,          // BP index\n   output logic [pt.BHT_GHR_SIZE-1:0]             ifu_i0_bp_fghr,           // BP FGHR\n   output logic [pt.BTB_BTAG_SIZE-1:0]            ifu_i0_bp_btag,           // BP tag\n\n   output logic [$clog2(pt.BTB_SIZE)-1:0]         ifu_i0_fa_index,          // Fully associt btb index\n\n   output logic                                   ifu_pmu_instr_aligned,    // number of inst aligned this cycle\n\n   output logic [15:0]                            ifu_i0_cinst              // 16b compress inst for i0\n   );\n\n\n\n   logic                                          ifvalid;\n   logic                                          shift_f1_f0, shift_f2_f0, shift_f2_f1;\n   logic                                          fetch_to_f0, fetch_to_f1, fetch_to_f2;\n\n   logic [1:0]                                    f2val_in, f2val;\n   logic [1:0]                                    f1val_in, f1val;\n   logic [1:0]                                    f0val_in, f0val;\n   logic [1:0]                                    sf1val, sf0val;\n\n   logic [31:0]                                   aligndata;\n   logic                                          first4B, first2B;\n\n   logic [31:0]                                   uncompress0;\n   logic                                          i0_shift;\n   logic                                          shift_2B, shift_4B;\n   logic                                          f1_shift_2B;\n   logic                                          f2_valid, sf1_valid, sf0_valid;\n\n   logic [31:0]                                   ifirst;\n   logic [1:0]                                    alignval;\n   logic [31:1]                                   firstpc, secondpc;\n\n   logic [11:0]                                   f1poffset;\n   logic [11:0]                                   f0poffset;\n   logic [pt.BHT_GHR_SIZE-1:0]                    f1fghr;\n   logic [pt.BHT_GHR_SIZE-1:0]                    f0fghr;\n   logic [1:0]                                    f1hist1;\n   logic [1:0]                                    f0hist1;\n   logic [1:0]                                    f1hist0;\n   logic [1:0]                                    f0hist0;\n\n   logic [1:0][$clog2(pt.BTB_SIZE)-1:0]           f0index, f1index, alignindex;\n\n   logic [1:0]                                    f1ictype;\n   logic [1:0]                                    f0ictype;\n\n   logic [1:0]                                    f1pc4;\n   logic [1:0]                                    f0pc4;\n\n   logic [1:0]                                    f1ret;\n   logic [1:0]                                    f0ret;\n   logic [1:0]                                    f1way;\n   logic [1:0]                                    f0way;\n\n   logic [1:0]                                    f1brend;\n   logic [1:0]                                    f0brend;\n\n   logic [1:0]                                    alignbrend;\n   logic [1:0]                                    alignpc4;\n\n   logic [1:0]                                    alignret;\n   logic [1:0]                                    alignway;\n   logic [1:0]                                    alignhist1;\n   logic [1:0]                                    alignhist0;\n   logic [1:1]                                    alignfromf1;\n   logic                                          i0_ends_f1;\n   logic                                          i0_br_start_error;\n\n   logic [31:1]                                   f1prett;\n   logic [31:1]                                   f0prett;\n   logic [1:0]                                    f1dbecc;\n   logic [1:0]                                    f0dbecc;\n   logic [1:0]                                    f1icaf;\n   logic [1:0]                                    f0icaf;\n\n   logic [1:0]                                    aligndbecc;\n   logic [1:0]                                    alignicaf;\n   logic                                          i0_brp_pc4;\n\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]          firstpc_hash, secondpc_hash;\n\n   logic                                          first_legal;\n\n   logic [1:0]                                    wrptr, wrptr_in;\n   logic [1:0]                                    rdptr, rdptr_in;\n   logic [2:0]                                    qwen;\n   logic [31:0]                                   q2,q1,q0;\n   logic                                          q2off_in, q2off;\n   logic                                          q1off_in, q1off;\n   logic                                          q0off_in, q0off;\n   logic                                          f0_shift_2B;\n\n   logic [31:0]                                   q0eff;\n   logic [31:0]                                   q0final;\n   logic                                          q0ptr;\n   logic [1:0]                                    q0sel;\n\n   logic [31:0]                                   q1eff;\n   logic [15:0]                                   q1final;\n   logic                                          q1ptr;\n   logic [1:0]                                    q1sel;\n\n   logic [2:0]                                    qren;\n\n   logic                                          consume_fb1, consume_fb0;\n   logic [1:0]                                    icaf_eff;\n\n   localparam                                     BRDATA_SIZE  = pt.BTB_ENABLE ? 16+($clog2(pt.BTB_SIZE)*2*pt.BTB_FULLYA) : 4;\n   localparam                                     BRDATA_WIDTH = pt.BTB_ENABLE ? 8+($clog2(pt.BTB_SIZE)*pt.BTB_FULLYA) : 2;\n   logic [BRDATA_SIZE-1:0]                        brdata_in, brdata2, brdata1, brdata0;\n   logic [BRDATA_SIZE-1:0]                        brdata1eff, brdata0eff;\n   logic [BRDATA_SIZE-1:0]                        brdata1final, brdata0final;\n\n   localparam                                     MHI   = 1+(pt.BTB_ENABLE * (43+pt.BHT_GHR_SIZE));\n   localparam                                     MSIZE = 2+(pt.BTB_ENABLE * (43+pt.BHT_GHR_SIZE));\n\n   logic [MHI:0]                                  misc_data_in, misc2, misc1, misc0;\n   logic [MHI:0]                                  misc1eff, misc0eff;\n\n   logic [pt.BTB_BTAG_SIZE-1:0]                  firstbrtag_hash, secondbrtag_hash;\n\n   logic                                         error_stall_in, error_stall;\n\n   assign error_stall_in = (error_stall | ifu_async_error_start) & ~exu_flush_final;\n\n   rvdff #(.WIDTH(7))  bundle1ff (.*,\n                                  .clk(active_clk),\n                                  .din ({wrptr_in[1:0],rdptr_in[1:0],q2off_in,q1off_in,q0off_in}),\n                                  .dout({wrptr[1:0],   rdptr[1:0],   q2off,   q1off,   q0off})\n                                  );\n\n   rvdffie #(.WIDTH(7),.OVERRIDE(1))  bundle2ff (.*,\n                                                 .din ({error_stall_in,f2val_in[1:0],f1val_in[1:0],f0val_in[1:0]}),\n                                                 .dout({error_stall,   f2val[1:0],   f1val[1:0],   f0val[1:0]   })\n                                                 );\n\nif(pt.BTB_ENABLE==1) begin\n   rvdffe #(BRDATA_SIZE)  brdata2ff   (.*, .clk(clk), .en(qwen[2]),        .din(brdata_in[BRDATA_SIZE-1:0]), .dout(brdata2[BRDATA_SIZE-1:0]));\n   rvdffe #(BRDATA_SIZE)  brdata1ff   (.*, .clk(clk), .en(qwen[1]),        .din(brdata_in[BRDATA_SIZE-1:0]), .dout(brdata1[BRDATA_SIZE-1:0]));\n   rvdffe #(BRDATA_SIZE)  brdata0ff   (.*, .clk(clk), .en(qwen[0]),        .din(brdata_in[BRDATA_SIZE-1:0]), .dout(brdata0[BRDATA_SIZE-1:0]));\n   rvdffe #(MSIZE)        misc2ff     (.*, .clk(clk), .en(qwen[2]),        .din(misc_data_in[MHI:0]),        .dout(misc2[MHI:0]));\n   rvdffe #(MSIZE)        misc1ff     (.*, .clk(clk), .en(qwen[1]),        .din(misc_data_in[MHI:0]),        .dout(misc1[MHI:0]));\n   rvdffe #(MSIZE)        misc0ff     (.*, .clk(clk), .en(qwen[0]),        .din(misc_data_in[MHI:0]),        .dout(misc0[MHI:0]));\nend\nelse begin\n\n   rvdffie #((MSIZE*3)+(BRDATA_SIZE*3))    miscff      (.*,\n                                                        .din({qwen[2] ? {misc_data_in[MHI:0], brdata_in[BRDATA_SIZE-1:0]} : {misc2[MHI:0], brdata2[BRDATA_SIZE-1:0]},\n                                                              qwen[1] ? {misc_data_in[MHI:0], brdata_in[BRDATA_SIZE-1:0]} : {misc1[MHI:0], brdata1[BRDATA_SIZE-1:0]},\n                                                              qwen[0] ? {misc_data_in[MHI:0], brdata_in[BRDATA_SIZE-1:0]} : {misc0[MHI:0], brdata0[BRDATA_SIZE-1:0]}}),\n                                                        .dout({misc2[MHI:0], brdata2[BRDATA_SIZE-1:0],\n                                                               misc1[MHI:0], brdata1[BRDATA_SIZE-1:0],\n                                                               misc0[MHI:0], brdata0[BRDATA_SIZE-1:0]})\n                                                        );\nend\n\n  logic [31:1] q2pc, q1pc, q0pc;\n\n   rvdffe #(31)           q2pcff        (.*, .clk(clk), .en(qwen[2]),        .din(ifu_fetch_pc[31:1]),     .dout(q2pc[31:1]));\n   rvdffe #(31)           q1pcff        (.*, .clk(clk), .en(qwen[1]),        .din(ifu_fetch_pc[31:1]),     .dout(q1pc[31:1]));\n   rvdffe #(31)           q0pcff        (.*, .clk(clk), .en(qwen[0]),        .din(ifu_fetch_pc[31:1]),     .dout(q0pc[31:1]));\n\n   rvdffe #(32)           q2ff        (.*, .clk(clk), .en(qwen[2]),        .din(ifu_fetch_data_f[31:0]),     .dout(q2[31:0]));\n   rvdffe #(32)           q1ff        (.*, .clk(clk), .en(qwen[1]),        .din(ifu_fetch_data_f[31:0]),     .dout(q1[31:0]));\n   rvdffe #(32)           q0ff        (.*, .clk(clk), .en(qwen[0]),        .din(ifu_fetch_data_f[31:0]),     .dout(q0[31:0]));\n\n\n   // new queue control logic\n\n   assign qren[2:0]          = {  rdptr[1:0] == 2'b10,\n                                  rdptr[1:0] == 2'b01,\n                                  rdptr[1:0] == 2'b00 };\n\n   assign qwen[2:0]          = { (wrptr[1:0] == 2'b10) & ifvalid,\n                                 (wrptr[1:0] == 2'b01) & ifvalid,\n                                 (wrptr[1:0] == 2'b00) & ifvalid };\n\n\n   assign rdptr_in[1:0]      = ({2{ qren[0]         &  ifu_fb_consume1 & ~exu_flush_final}} & 2'b01     ) |\n                               ({2{ qren[1]         &  ifu_fb_consume1 & ~exu_flush_final}} & 2'b10     ) |\n                               ({2{ qren[2]         &  ifu_fb_consume1 & ~exu_flush_final}} & 2'b00     ) |\n                               ({2{ qren[0]         &  ifu_fb_consume2 & ~exu_flush_final}} & 2'b10     ) |\n                               ({2{ qren[1]         &  ifu_fb_consume2 & ~exu_flush_final}} & 2'b00     ) |\n                               ({2{ qren[2]         &  ifu_fb_consume2 & ~exu_flush_final}} & 2'b01     ) |\n                               ({2{~ifu_fb_consume1 & ~ifu_fb_consume2 & ~exu_flush_final}} & rdptr[1:0]);\n\n   assign wrptr_in[1:0]      = ({2{ qwen[0] & ~exu_flush_final}} & 2'b01     ) |\n                               ({2{ qwen[1] & ~exu_flush_final}} & 2'b10     ) |\n                               ({2{ qwen[2] & ~exu_flush_final}} & 2'b00     ) |\n                               ({2{~ifvalid & ~exu_flush_final}} & wrptr[1:0]);\n\n\n\n   assign q2off_in          = ( ~qwen[2] & (rdptr[1:0]==2'd2)  &  (q2off | f0_shift_2B) ) |\n                              ( ~qwen[2] & (rdptr[1:0]==2'd1)  &  (q2off | f1_shift_2B) ) |\n                              ( ~qwen[2] & (rdptr[1:0]==2'd0)  &   q2off                );\n\n   assign q1off_in          = ( ~qwen[1] & (rdptr[1:0]==2'd1)  &  (q1off | f0_shift_2B) ) |\n                              ( ~qwen[1] & (rdptr[1:0]==2'd0)  &  (q1off | f1_shift_2B) ) |\n                              ( ~qwen[1] & (rdptr[1:0]==2'd2)  &   q1off                );\n\n   assign q0off_in          = ( ~qwen[0] & (rdptr[1:0]==2'd0)  &  (q0off | f0_shift_2B) ) |\n                              ( ~qwen[0] & (rdptr[1:0]==2'd2)  &  (q0off | f1_shift_2B) ) |\n                              ( ~qwen[0] & (rdptr[1:0]==2'd1)  &   q0off                );\n\n\n\n   assign q0ptr              = ( (rdptr[1:0]==2'b00) & q0off ) |\n                               ( (rdptr[1:0]==2'b01) & q1off ) |\n                               ( (rdptr[1:0]==2'b10) & q2off );\n\n   assign q1ptr              = ( (rdptr[1:0]==2'b00) & q1off ) |\n                               ( (rdptr[1:0]==2'b01) & q2off ) |\n                               ( (rdptr[1:0]==2'b10) & q0off );\n\n   assign q0sel[1:0]         = {q0ptr,~q0ptr};\n\n   assign q1sel[1:0]         = {q1ptr,~q1ptr};\n\n   // end new queue control logic\n\n\n   // misc data that is associated with each fetch buffer\n\n   if(pt.BTB_ENABLE==1)\n     assign misc_data_in[MHI:0] = {\n\n                                    ic_access_fault_type_f[1:0],\n                                    ifu_bp_btb_target_f[31:1],\n                                    ifu_bp_poffset_f[11:0],\n                                    ifu_bp_fghr_f[pt.BHT_GHR_SIZE-1:0]\n                                    };\n   else\n     assign misc_data_in[MHI:0] = {\n                                    ic_access_fault_type_f[1:0]\n                                    };\n\n\n   assign {misc1eff[MHI:0],misc0eff[MHI:0]} = (({MSIZE*2{qren[0]}} & {misc1[MHI:0],misc0[MHI:0]}) |\n                                               ({MSIZE*2{qren[1]}} & {misc2[MHI:0],misc1[MHI:0]}) |\n                                               ({MSIZE*2{qren[2]}} & {misc0[MHI:0],misc2[MHI:0]}));\n\n   if(pt.BTB_ENABLE==1) begin\n   assign {\n            f1ictype[1:0],\n            f1prett[31:1],\n            f1poffset[11:0],\n            f1fghr[pt.BHT_GHR_SIZE-1:0]\n            } = misc1eff[MHI:0];\n\n   assign {\n            f0ictype[1:0],\n            f0prett[31:1],\n            f0poffset[11:0],\n            f0fghr[pt.BHT_GHR_SIZE-1:0]\n            } = misc0eff[MHI:0];\n\n      if(pt.BTB_FULLYA) begin\n         assign brdata_in[BRDATA_SIZE-1:0] = {\n                                               ifu_bp_fa_index_f[1], iccm_rd_ecc_double_err[1],ic_access_fault_f[1],ifu_bp_hist1_f[1],ifu_bp_hist0_f[1],ifu_bp_pc4_f[1],ifu_bp_way_f[1],ifu_bp_valid_f[1],ifu_bp_ret_f[1],\n                                               ifu_bp_fa_index_f[0], iccm_rd_ecc_double_err[0],ic_access_fault_f[0],ifu_bp_hist1_f[0],ifu_bp_hist0_f[0],ifu_bp_pc4_f[0],ifu_bp_way_f[0],ifu_bp_valid_f[0],ifu_bp_ret_f[0]\n                                               };\n         assign {f0index[1],f0dbecc[1],f0icaf[1],f0hist1[1],f0hist0[1],f0pc4[1],f0way[1],f0brend[1],f0ret[1],\n                 f0index[0],f0dbecc[0],f0icaf[0],f0hist1[0],f0hist0[0],f0pc4[0],f0way[0],f0brend[0],f0ret[0]} = brdata0final[BRDATA_SIZE-1:0];\n\n         assign {f1index[1],f1dbecc[1],f1icaf[1],f1hist1[1],f1hist0[1],f1pc4[1],f1way[1],f1brend[1],f1ret[1],\n                 f1index[0],f1dbecc[0],f1icaf[0],f1hist1[0],f1hist0[0],f1pc4[0],f1way[0],f1brend[0],f1ret[0]} = brdata1final[BRDATA_SIZE-1:0];\n\n"}
{"text": "      end\n      else begin\n         assign brdata_in[BRDATA_SIZE-1:0] = {\n                                               iccm_rd_ecc_double_err[1],ic_access_fault_f[1],ifu_bp_hist1_f[1],ifu_bp_hist0_f[1],ifu_bp_pc4_f[1],ifu_bp_way_f[1],ifu_bp_valid_f[1],ifu_bp_ret_f[1],\n                                               iccm_rd_ecc_double_err[0],ic_access_fault_f[0],ifu_bp_hist1_f[0],ifu_bp_hist0_f[0],ifu_bp_pc4_f[0],ifu_bp_way_f[0],ifu_bp_valid_f[0],ifu_bp_ret_f[0]\n                                               };\n         assign {f0dbecc[1],f0icaf[1],f0hist1[1],f0hist0[1],f0pc4[1],f0way[1],f0brend[1],f0ret[1],\n                 f0dbecc[0],f0icaf[0],f0hist1[0],f0hist0[0],f0pc4[0],f0way[0],f0brend[0],f0ret[0]} = brdata0final[BRDATA_SIZE-1:0];\n\n         assign {f1dbecc[1],f1icaf[1],f1hist1[1],f1hist0[1],f1pc4[1],f1way[1],f1brend[1],f1ret[1],\n                 f1dbecc[0],f1icaf[0],f1hist1[0],f1hist0[0],f1pc4[0],f1way[0],f1brend[0],f1ret[0]} = brdata1final[BRDATA_SIZE-1:0];\n\n      end\n\n\n\n\n   assign {brdata1eff[BRDATA_SIZE-1:0],brdata0eff[BRDATA_SIZE-1:0]} = (({BRDATA_SIZE*2{qren[0]}} & {brdata1[BRDATA_SIZE-1:0],brdata0[BRDATA_SIZE-1:0]}) |\n                                                                       ({BRDATA_SIZE*2{qren[1]}} & {brdata2[BRDATA_SIZE-1:0],brdata1[BRDATA_SIZE-1:0]}) |\n                                                                       ({BRDATA_SIZE*2{qren[2]}} & {brdata0[BRDATA_SIZE-1:0],brdata2[BRDATA_SIZE-1:0]}));\n\n   assign brdata0final[BRDATA_SIZE-1:0] = (({BRDATA_SIZE{q0sel[0]}} & {                     brdata0eff[2*BRDATA_WIDTH-1:0]}) |\n                                           ({BRDATA_SIZE{q0sel[1]}} & {{BRDATA_WIDTH{1'b0}},brdata0eff[BRDATA_SIZE-1:BRDATA_WIDTH]}));\n\n   assign brdata1final[BRDATA_SIZE-1:0] = (({BRDATA_SIZE{q1sel[0]}} & {                     brdata1eff[2*BRDATA_WIDTH-1:0]}) |\n                                           ({BRDATA_SIZE{q1sel[1]}} & {{BRDATA_WIDTH{1'b0}},brdata1eff[BRDATA_SIZE-1:BRDATA_WIDTH]}));\n\n   end // if (pt.BTB_ENABLE==1)\n   else begin\n      assign {\n               f1ictype[1:0]\n               } = misc1eff[MHI:0];\n\n      assign {\n               f0ictype[1:0]\n               } = misc0eff[MHI:0];\n\n      assign brdata_in[BRDATA_SIZE-1:0] = {\n                                            iccm_rd_ecc_double_err[1],ic_access_fault_f[1],\n                                            iccm_rd_ecc_double_err[0],ic_access_fault_f[0]\n                                            };\n      assign {f0dbecc[1],f0icaf[1],\n              f0dbecc[0],f0icaf[0]} = brdata0final[BRDATA_SIZE-1:0];\n\n      assign {f1dbecc[1],f1icaf[1],\n              f1dbecc[0],f1icaf[0]} = brdata1final[BRDATA_SIZE-1:0];\n\n      assign {brdata1eff[BRDATA_SIZE-1:0],brdata0eff[BRDATA_SIZE-1:0]} = (({BRDATA_SIZE*2{qren[0]}} & {brdata1[BRDATA_SIZE-1:0],brdata0[BRDATA_SIZE-1:0]}) |\n                                                                          ({BRDATA_SIZE*2{qren[1]}} & {brdata2[BRDATA_SIZE-1:0],brdata1[BRDATA_SIZE-1:0]}) |\n                                                                          ({BRDATA_SIZE*2{qren[2]}} & {brdata0[BRDATA_SIZE-1:0],brdata2[BRDATA_SIZE-1:0]}));\n\n      assign brdata0final[BRDATA_SIZE-1:0] = (({BRDATA_SIZE{q0sel[0]}} & {                     brdata0eff[2*BRDATA_WIDTH-1:0]}) |\n                                              ({BRDATA_SIZE{q0sel[1]}} & {{BRDATA_WIDTH{1'b0}},brdata0eff[BRDATA_SIZE-1:BRDATA_WIDTH]}));\n\n      assign brdata1final[BRDATA_SIZE-1:0] = (({BRDATA_SIZE{q1sel[0]}} & {                     brdata1eff[2*BRDATA_WIDTH-1:0]}) |\n                                              ({BRDATA_SIZE{q1sel[1]}} & {{BRDATA_WIDTH{1'b0}},brdata1eff[BRDATA_SIZE-1:BRDATA_WIDTH]}));\n\n   end // else: !if(pt.BTB_ENABLE==1)\n\n\n   // possible states of { sf0_valid, sf1_valid, f2_valid }\n   //\n   // 000    if->f0\n   // 100    if->f1\n   // 101    illegal\n   // 010    if->f1, f1->f0\n   // 110    if->f2\n   // 001    if->f1, f2->f0\n   // 011    if->f2, f2->f1, f1->f0\n   // 111   !if,     no shift\n\n   assign f2_valid           =  f2val[0];\n   assign sf1_valid          =  sf1val[0];\n   assign sf0_valid          =  sf0val[0];\n\n   // interface to fetch\n\n   assign consume_fb0        = ~sf0val[0] & f0val[0];\n\n   assign consume_fb1        = ~sf1val[0] & f1val[0];\n\n   assign ifu_fb_consume1    =  consume_fb0 & ~consume_fb1 & ~exu_flush_final;\n   assign ifu_fb_consume2    =  consume_fb0 &  consume_fb1 & ~exu_flush_final;\n\n   assign ifvalid            =  ifu_fetch_val[0];\n\n   assign shift_f1_f0        =  ~sf0_valid &  sf1_valid;\n   assign shift_f2_f0        =  ~sf0_valid & ~sf1_valid &  f2_valid;\n   assign shift_f2_f1        =  ~sf0_valid &  sf1_valid &  f2_valid;\n\n   assign fetch_to_f0        =  ~sf0_valid & ~sf1_valid & ~f2_valid & ifvalid;\n\n   assign fetch_to_f1        = (~sf0_valid & ~sf1_valid &  f2_valid & ifvalid)  |\n                               (~sf0_valid &  sf1_valid & ~f2_valid & ifvalid)  |\n                               ( sf0_valid & ~sf1_valid & ~f2_valid & ifvalid);\n\n   assign fetch_to_f2        = (~sf0_valid &  sf1_valid &  f2_valid & ifvalid)  |\n                               ( sf0_valid &  sf1_valid & ~f2_valid & ifvalid);\n\n\n   assign f2val_in[1:0]      = ({2{ fetch_to_f2 &                               ~exu_flush_final}} & ifu_fetch_val[1:0]) |\n                               ({2{~fetch_to_f2 & ~shift_f2_f1 & ~shift_f2_f0 & ~exu_flush_final}} & f2val[1:0]        );\n\n\n   assign sf1val[1:0]        = ({2{ f1_shift_2B}} & {1'b0,f1val[1]}) |\n                               ({2{~f1_shift_2B}} & f1val[1:0]     );\n\n   assign f1val_in[1:0]      = ({2{ fetch_to_f1                               & ~exu_flush_final}} & ifu_fetch_val[1:0]) |\n                               ({2{                shift_f2_f1                & ~exu_flush_final}} & f2val[1:0]        ) |\n                               ({2{~fetch_to_f1 & ~shift_f2_f1 & ~shift_f1_f0 & ~exu_flush_final}} & sf1val[1:0]       );\n\n\n\n   assign sf0val[1:0]        = ({2{ shift_2B            }} & {1'b0,f0val[1]}) |\n                               ({2{~shift_2B & ~shift_4B}} & f0val[1:0]);\n\n   assign f0val_in[1:0]      = ({2{fetch_to_f0                                & ~exu_flush_final}} & ifu_fetch_val[1:0]) |\n                               ({2{                shift_f2_f0                & ~exu_flush_final}} & f2val[1:0]        ) |\n                               ({2{                               shift_f1_f0 & ~exu_flush_final}} & sf1val[1:0]       ) |\n                               ({2{~fetch_to_f0 & ~shift_f2_f0 & ~shift_f1_f0 & ~exu_flush_final}} & sf0val[1:0]       );\n\n   assign {q1eff[31:0],q0eff[31:0]} = (({64{qren[0]}} & {q1[31:0],q0[31:0]}) |\n                                       ({64{qren[1]}} & {q2[31:0],q1[31:0]}) |\n                                       ({64{qren[2]}} & {q0[31:0],q2[31:0]}));\n\n   assign q0final[31:0]      = ({32{q0sel[0]}} & {      q0eff[31:0]}) |\n                               ({32{q0sel[1]}} & {16'b0,q0eff[31:16]});\n\n   assign q1final[15:0]      = ({16{q1sel[0]}} & q1eff[15:0] ) |\n                               ({16{q1sel[1]}} & q1eff[31:16]);\n   logic [31:1] q0pceff, q0pcfinal;\n   logic [31:1] q1pceff;\n\n   assign {q1pceff[31:1],q0pceff[31:1]} = (({62{qren[0]}} & {q1pc[31:1],q0pc[31:1]}) |\n                                           ({62{qren[1]}} & {q2pc[31:1],q1pc[31:1]}) |\n                                           ({62{qren[2]}} & {q0pc[31:1],q2pc[31:1]}));\n\n\n   assign q0pcfinal[31:1]      = ({31{q0sel[0]}} & ( q0pceff[31:1])) |\n                                 ({31{q0sel[1]}} & ( q0pceff[31:1] + 31'd1));\n\n   assign aligndata[31:0]    = ({32{ f0val[1]           }} & {q0final[31:0]}) |\n                               ({32{~f0val[1] & f0val[0]}} & {q1final[15:0],q0final[15:0]});\n\n   assign alignval[1:0]      = ({ 2{ f0val[1]           }} & {2'b11}) |\n                               ({ 2{~f0val[1] & f0val[0]}} & {f1val[0],1'b1});\n\n   assign alignicaf[1:0]    = ({ 2{ f0val[1]           }} &  f0icaf[1:0]          ) |\n                              ({ 2{~f0val[1] & f0val[0]}} & {f1icaf[0],f0icaf[0]});\n\n   assign aligndbecc[1:0]    = ({ 2{ f0val[1]           }} &  f0dbecc[1:0]          ) |\n                              ({ 2{~f0val[1] & f0val[0]}} & {f1dbecc[0],f0dbecc[0]});\n\n   if (pt.BTB_ENABLE==1) begin\n\n   // for branch prediction\n\n   assign alignbrend[1:0]    = ({ 2{ f0val[1]           }} &  f0brend[1:0]          ) |\n                               ({ 2{~f0val[1] & f0val[0]}} & {f1brend[0],f0brend[0]});\n\n   assign alignpc4[1:0]      = ({ 2{ f0val[1]           }} &  f0pc4[1:0]        ) |\n                               ({ 2{~f0val[1] & f0val[0]}} & {f1pc4[0],f0pc4[0]});\n\n      if(pt.BTB_FULLYA) begin\n         assign alignindex[0]      = f0index[0];\n         assign alignindex[1]      = f0val[1] ? f0index[1] : f1index[0];\n      end\n\n   assign alignret[1:0]      = ({ 2{ f0val[1]           }} &  f0ret[1:0]        ) |\n                               ({ 2{~f0val[1] & f0val[0]}} & {f1ret[0],f0ret[0]});\n\n   assign alignway[1:0]      = ({ 2{ f0val[1]           }} &  f0way[1:0]        ) |\n                               ({ 2{~f0val[1] & f0val[0]}} & {f1way[0],f0way[0]});\n\n   assign alignhist1[1:0]    = ({ 2{ f0val[1]           }} &  f0hist1[1:0]          ) |\n                               ({ 2{~f0val[1] & f0val[0]}} & {f1hist1[0],f0hist1[0]});\n\n   assign alignhist0[1:0]    = ({ 2{ f0val[1]           }} &  f0hist0[1:0]          ) |\n                               ({ 2{~f0val[1] & f0val[0]}} & {f1hist0[0],f0hist0[0]});\n\n   assign secondpc[31:1]     = ({31{ f0val[1]           }} &  (q0pceff[31:1] + 31'd1)) |\n                               // you need the base pc for 2nd one only (4B max, 2B for the 1st and 2B for the 2nd)\n                               ({31{~f0val[1] & f0val[0]}} &   q1pceff[31:1]      );\n\n\n   assign firstpc[31:1]      =  q0pcfinal[31:1];\n      end // if (pt.BTB_ENABLE==1)\n\n   assign alignfromf1[1]     =      ~f0val[1] & f0val[0];\n\n\n   assign ifu_i0_pc[31:1]    =  q0pcfinal[31:1];\n\n\n   assign ifu_i0_pc4         =  first4B;\n\n\n   assign ifu_i0_cinst[15:0] = aligndata[15:0];\n\n   assign first4B            = (aligndata[1:0] == 2'b11);\n   assign first2B            = ~first4B;\n\n   assign ifu_i0_valid       = (first4B & alignval[1]) |\n                               (first2B & alignval[0]);\n\n   // inst access fault on any byte of inst results in access fault for the inst\n   assign ifu_i0_icaf        = (first4B & (|alignicaf[1:0])) |\n                               (first2B &   alignicaf[0]   );\n\n   assign ifu_i0_icaf_type[1:0] = (first4B & ~f0val[1] & f0val[0] & ~alignicaf[0] & ~aligndbecc[0]) ? f1ictype[1:0] : f0ictype[1:0];\n\n\n   assign icaf_eff[1:0] = alignicaf[1:0] | aligndbecc[1:0];\n\n   assign ifu_i0_icaf_second = first4B & ~icaf_eff[0] & icaf_eff[1];\n\n   assign ifu_i0_dbecc       = (first4B & (|aligndbecc[1:0])) |\n                               (first2B &   aligndbecc[0]   );\n\n\n   assign ifirst[31:0]       =  aligndata[31:0];\n\n\n   assign ifu_i0_instr[31:0] = ({32{first4B & alignval[1]}} & ifirst[31:0]) |\n                               ({32{first2B & alignval[0]}} & uncompress0[31:0]);\n\nif(pt.BTB_ENABLE==1) begin\n\n   // if you detect br does not start on instruction boundary\n\n   el2_btb_addr_hash #(.pt(pt)) firsthash (.pc(firstpc [pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]),\n                                            .hash(firstpc_hash [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n   el2_btb_addr_hash #(.pt(pt)) secondhash(.pc(secondpc[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]),\n                                            .hash(secondpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n\n   if(pt.BTB_FULLYA) begin\n      assign firstbrtag_hash = firstpc;\n      assign secondbrtag_hash = secondpc;\n   end\n   else begin\n      if(pt.BTB_BTAG_FOLD) begin : btbfold\n         el2_btb_tag_hash_fold #(.pt(pt)) first_brhash (.pc(firstpc [pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]),\n                                                         .hash(firstbrtag_hash [pt.BTB_BTAG_SIZE-1:0]));\n         el2_btb_tag_hash_fold #(.pt(pt)) second_brhash(.pc(secondpc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]),\n                                                         .hash(secondbrtag_hash[pt.BTB_BTAG_SIZE-1:0]));\n      end\n      else begin\n         el2_btb_tag_hash #(.pt(pt)) first_brhash (.pc(firstpc [pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]),\n                                                    .hash(firstbrtag_hash [pt.BTB_BTAG_SIZE-1:0]));\n         el2_btb_tag_hash #(.pt(pt)) second_brhash(.pc(secondpc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]),\n                                                    .hash(secondbrtag_hash[pt.BTB_BTAG_SIZE-1:0]));\n      end\n   end // else: !if(pt.BTB_FULLYA)\n\n\n   // start_indexing - you want pc to be based on where the end of branch is prediction\n   // normal indexing pc based that's incorrect now for pc4 cases it's pc4 + 2\n\n   always_comb begin\n\n      i0_brp                 = '0;\n\n      i0_br_start_error      = (first4B & alignval[1] & alignbrend[0]);\n\n      i0_brp.valid           = (first2B & alignbrend[0]) |\n                               (first4B & alignbrend[1]) |\n                                i0_br_start_error;\n\n      i0_brp_pc4             = (first2B & alignpc4[0]) |\n                               (first4B & alignpc4[1]);\n\n      i0_brp.ret             = (first2B & alignret[0]) |\n                               (first4B & alignret[1]);\n\n      i0_brp.way             = (first2B | alignbrend[0])  ?  alignway[0]  :  alignway[1];\n\n      i0_brp.hist[1]         = (first2B & alignhist1[0]) |\n                               (first4B & alignhist1[1]);\n\n      i0_brp.hist[0]         = (first2B & alignhist0[0]) |\n                               (first4B & alignhist0[1]);\n\n      i0_ends_f1             =  first4B & alignfromf1[1];\n\n      i0_brp.toffset[11:0]   = (i0_ends_f1)  ?  f1poffset[11:0]  :  f0poffset[11:0];\n\n      i0_brp.prett[31:1]     = (i0_ends_f1)  ?  f1prett[31:1]    :  f0prett[31:1];\n\n      i0_brp.br_start_error  = i0_br_start_error;\n\n      i0_brp.bank            = (first2B | alignbrend[0])  ?  firstpc[1]  :  secondpc[1];\n\n      i0_brp.br_error        = (i0_brp.valid &  i0_brp_pc4 &  first2B) |\n                               (i0_brp.valid & ~i0_brp_pc4 &  first4B);\n\n      if(pt.BTB_FULLYA)\n        ifu_i0_fa_index = (first2B | alignbrend[0])  ?  alignindex[0]  :  alignindex[1];\n      else\n        ifu_i0_fa_index = '0;\n\n end\n\n\n   assign ifu_i0_bp_index[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = (first2B | alignbrend[0])  ?  firstpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  :\n                                                                                         secondpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n   assign ifu_i0_bp_fghr[pt.BHT_GHR_SIZE-1:0]            = (i0_ends_f1)               ?  f1fghr[pt.BHT_GHR_SIZE-1:0]  :\n                                                                                         f0fghr[pt.BHT_GHR_SIZE-1:0];\n\n   assign ifu_i0_bp_btag[pt.BTB_BTAG_SIZE-1:0]           = (first2B | alignbrend[0])  ?  firstbrtag_hash[pt.BTB_BTAG_SIZE-1:0]  :\n                                                                                         secondbrtag_hash[pt.BTB_BTAG_SIZE-1:0];\nend\nelse begin\n   assign i0_brp = '0;\n   assign ifu_i0_bp_index = '0;\n   assign ifu_i0_bp_fghr = '0;\n   assign ifu_i0_bp_btag = '0;\nend // else: !if(pt.BTB_ENABLE==1)\n\n   // decompress\n\n   // quiet inputs for 4B inst\n   el2_ifu_compress_ctl compress0 (.din((first2B) ? aligndata[15:0] : '0), .dout(uncompress0[31:0]));\n\n\n\n   assign i0_shift           =  dec_i0_decode_d & ~error_stall;\n\n   assign ifu_pmu_instr_aligned = i0_shift;\n\n\n   // compute how many bytes are being shifted from f0\n\n   assign shift_2B           =  i0_shift & first2B;\n\n   assign shift_4B           =  i0_shift & first4B;\n\n   // exact equations for the queue logic\n   assign f0_shift_2B        = (shift_2B & f0val[0]            ) |\n                               (shift_4B & f0val[0] & ~f0val[1]);\n\n\n   // f0 valid states\n   //     11\n   //     10\n   //     00\n\n   assign f1_shift_2B        =  f0val[0] & ~f0val[1] & shift_4B;\n\n\n\nendmodule\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n//********************************************************************************\n// Function: Branch predictor\n// Comments:\n//\n//\n//  Bank3 : Bank2 : Bank1 : Bank0\n//  FA  C       8       4       0\n//********************************************************************************\n\nmodule el2_ifu_bp_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n\n   input logic clk,\n   input logic rst_l,\n\n   input logic ic_hit_f,      // Icache hit, enables F address capture\n\n   input logic [31:1] ifc_fetch_addr_f, // look up btb address\n   input logic ifc_fetch_req_f,  // F1 valid\n\n   input el2_br_tlu_pkt_t dec_tlu_br0_r_pkt, // BP commit update packet, includes errors\n   input logic [pt.BHT_GHR_SIZE-1:0] exu_i0_br_fghr_r, // fghr to bp\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_i0_br_index_r, // bp index\n\n   input logic [$clog2(pt.BTB_SIZE)-1:0] dec_fa_error_index, // Fully associative btb error index\n\n   input logic dec_tlu_flush_lower_wb, // used to move EX4 RS to EX1 and F\n   input logic dec_tlu_flush_leak_one_wb, // don't hit for leak one fetches\n\n   input logic dec_tlu_bpred_disable, // disable all branch prediction\n\n   input el2_predict_pkt_t  exu_mp_pkt, // mispredict packet\n\n   input logic [pt.BHT_GHR_SIZE-1:0] exu_mp_eghr, // execute ghr (for patching fghr)\n   input logic [pt.BHT_GHR_SIZE-1:0]  exu_mp_fghr,                    // Mispredict fghr\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  exu_mp_index,         // Mispredict index\n   input logic [pt.BTB_BTAG_SIZE-1:0]  exu_mp_btag,                   // Mispredict btag\n\n   input logic exu_flush_final, // all flushes\n\n   output logic ifu_bp_hit_taken_f, // btb hit, select target\n   output logic [31:1] ifu_bp_btb_target_f, //  predicted target PC\n   output logic ifu_bp_inst_mask_f, // tell ic which valids to kill because of a taken branch, right justified\n\n   output logic [pt.BHT_GHR_SIZE-1:0] ifu_bp_fghr_f, // fetch ghr\n\n   output logic [1:0] ifu_bp_way_f, // way\n   output logic [1:0] ifu_bp_ret_f, // predicted ret\n   output logic [1:0] ifu_bp_hist1_f, // history counters for all 4 potential branches, bit 1, right justified\n   output logic [1:0] ifu_bp_hist0_f, // history counters for all 4 potential branches, bit 0, right justified\n   output logic [1:0] ifu_bp_pc4_f, // pc4 indication, right justified\n   output logic [1:0] ifu_bp_valid_f, // branch valid, right justified\n   output logic [11:0] ifu_bp_poffset_f, // predicted target\n\n   output logic [1:0] [$clog2(pt.BTB_SIZE)-1:0]    ifu_bp_fa_index_f, // predicted branch index (fully associative option)\n\n   input  logic       scan_mode\n   );\n\n\n   localparam BTB_DWIDTH =  pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5;\n   localparam BTB_DWIDTH_TOP =  int'(pt.BTB_TOFFSET_SIZE)+int'(pt.BTB_BTAG_SIZE)+4;\n   localparam BTB_FA_INDEX = $clog2(pt.BTB_SIZE)-1;\n   localparam FA_CMP_LOWER = $clog2(pt.ICACHE_LN_SZ);\n   localparam FA_TAG_END_UPPER= 5+int'(pt.BTB_TOFFSET_SIZE)+int'(FA_CMP_LOWER)-1; // must cast to int or vcs build fails\n   localparam FA_TAG_START_LOWER = 3+int'(pt.BTB_TOFFSET_SIZE)+int'(FA_CMP_LOWER);\n   localparam FA_TAG_END_LOWER = 5+int'(pt.BTB_TOFFSET_SIZE);\n\n   localparam TAG_START=BTB_DWIDTH-1;\n   localparam PC4=4;\n   localparam BOFF=3;\n   localparam CALL=2;\n   localparam RET=1;\n   localparam BV=0;\n\n   localparam LRU_SIZE=pt.BTB_ARRAY_DEPTH;\n   localparam NUM_BHT_LOOP = (pt.BHT_ARRAY_DEPTH > 16 ) ? 16 : pt.BHT_ARRAY_DEPTH;\n   localparam NUM_BHT_LOOP_INNER_HI =  (pt.BHT_ARRAY_DEPTH > 16 ) ?pt.BHT_ADDR_LO+3 : pt.BHT_ADDR_HI;\n   localparam NUM_BHT_LOOP_OUTER_LO =  (pt.BHT_ARRAY_DEPTH > 16 ) ?pt.BHT_ADDR_LO+4 : pt.BHT_ADDR_LO;\n   localparam BHT_NO_ADDR_MATCH  = ( pt.BHT_ARRAY_DEPTH <= 16 );\n\n\n   logic exu_mp_valid_write;\n   logic exu_mp_ataken;\n   logic exu_mp_valid; // conditional branch mispredict\n   logic exu_mp_boffset; // branch offsett\n   logic exu_mp_pc4; // branch is a 4B inst\n   logic exu_mp_call; // branch is a call inst\n   logic exu_mp_ret; // branch is a ret inst\n   logic exu_mp_ja; // branch is a jump always\n   logic [1:0] exu_mp_hist; // new history\n   logic [11:0] exu_mp_tgt; // target offset\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_mp_addr; // BTB/BHT address\n   logic                                   dec_tlu_br0_v_wb; // WB stage history update\n   logic [1:0]                             dec_tlu_br0_hist_wb; // new history\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br0_addr_wb; // addr\n   logic                                   dec_tlu_br0_error_wb; // error; invalidate bank\n   logic                                   dec_tlu_br0_start_error_wb; // error; invalidate all 4 banks in fg\n   logic [pt.BHT_GHR_SIZE-1:0]             exu_i0_br_fghr_wb;\n\n   logic use_mp_way, use_mp_way_p1;\n   logic [pt.RET_STACK_SIZE-1:0][31:0] rets_out, rets_in;\n   logic [pt.RET_STACK_SIZE-1:0]        rsenable;\n\n\n   logic [11:0]       btb_rd_tgt_f;\n   logic              btb_rd_pc4_f, btb_rd_call_f, btb_rd_ret_f;\n   logic [1:1]        bp_total_branch_offset_f;\n\n   logic [31:1]       bp_btb_target_adder_f;\n   logic [31:1]       bp_rs_call_target_f;\n   logic              rs_push, rs_pop, rs_hold;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] btb_rd_addr_p1_f, btb_wr_addr, btb_rd_addr_f;\n   logic [pt.BTB_BTAG_SIZE-1:0] btb_wr_tag, fetch_rd_tag_f, fetch_rd_tag_p1_f;\n   logic [BTB_DWIDTH-1:0]        btb_wr_data;\n   logic               btb_wr_en_way0, btb_wr_en_way1;\n\n\n   logic               dec_tlu_error_wb, btb_valid, dec_tlu_br0_middle_wb;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]        btb_error_addr_wb;\n   logic branch_error_collision_f, fetch_mp_collision_f, branch_error_collision_p1_f, fetch_mp_collision_p1_f;\n\n   logic  branch_error_bank_conflict_f;\n   logic [pt.BHT_GHR_SIZE-1:0] merged_ghr, fghr_ns, fghr;\n   logic [1:0] num_valids;\n   logic [LRU_SIZE-1:0] btb_lru_b0_f, btb_lru_b0_hold, btb_lru_b0_ns,\n                        fetch_wrindex_dec, fetch_wrindex_p1_dec, fetch_wrlru_b0, fetch_wrlru_p1_b0,\n                        mp_wrindex_dec, mp_wrlru_b0;\n   logic                btb_lru_rd_f, btb_lru_rd_p1_f, lru_update_valid_f;\n   logic  tag_match_way0_f, tag_match_way1_f;\n   logic [1:0] way_raw, bht_dir_f, btb_sel_f, wayhit_f, vwayhit_f, wayhit_p1_f;\n   logic [1:0] bht_valid_f, bht_force_taken_f;\n\n   logic leak_one_f, leak_one_f_d1;\n\n   logic [LRU_SIZE-1:0][BTB_DWIDTH-1:0]  btb_bank0_rd_data_way0_out ;\n\n   logic [LRU_SIZE-1:0][BTB_DWIDTH-1:0]  btb_bank0_rd_data_way1_out ;\n\n   logic                [BTB_DWIDTH-1:0] btb_bank0_rd_data_way0_f ;\n   logic                [BTB_DWIDTH-1:0] btb_bank0_rd_data_way1_f ;\n\n   logic                [BTB_DWIDTH-1:0] btb_bank0_rd_data_way0_p1_f ;\n   logic                [BTB_DWIDTH-1:0] btb_bank0_rd_data_way1_p1_f ;\n\n   logic                [BTB_DWIDTH-1:0] btb_vbank0_rd_data_f, btb_vbank1_rd_data_f;\n\n   logic                                         final_h;\n   logic                                         btb_fg_crossing_f;\n   logic                                         middle_of_bank;\n\n\n   logic [1:0]                                   bht_vbank0_rd_data_f, bht_vbank1_rd_data_f;\n   logic                                         branch_error_bank_conflict_p1_f;\n   logic                                         tag_match_way0_p1_f, tag_match_way1_p1_f;\n\n   logic [1:0]                                   btb_vlru_rd_f, fetch_start_f, tag_match_vway1_expanded_f, tag_match_way0_expanded_p1_f, tag_match_way1_expanded_p1_f;\n   logic [31:2] fetch_addr_p1_f;\n\n\n   logic exu_mp_way, exu_mp_way_f, dec_tlu_br0_way_wb, dec_tlu_way_wb;\n   logic                [BTB_DWIDTH-1:0] btb_bank0e_rd_data_f, btb_bank0e_rd_data_p1_f;\n\n   logic                [BTB_DWIDTH-1:0] btb_bank0o_rd_data_f;\n\n   logic [1:0] tag_match_way0_expanded_f, tag_match_way1_expanded_f;\n\n\n    logic [1:0]                                  bht_bank0_rd_data_f;\n    logic [1:0]                                  bht_bank1_rd_data_f;\n    logic [1:0]                                  bht_bank0_rd_data_p1_f;\n   genvar                                        j, i;\n\n   assign exu_mp_valid = exu_mp_pkt.misp & ~leak_one_f; // conditional branch mispredict\n   assign exu_mp_boffset = exu_mp_pkt.boffset;  // branch offset\n   assign exu_mp_pc4 = exu_mp_pkt.pc4;  // branch is a 4B inst\n   assign exu_mp_call = exu_mp_pkt.pcall;  // branch is a call inst\n   assign exu_mp_ret = exu_mp_pkt.pret;  // branch is a ret inst\n   assign exu_mp_ja = exu_mp_pkt.pja;  // branch is a jump always\n   assign exu_mp_way = exu_mp_pkt.way;  // repl way\n   assign exu_mp_hist[1:0] = exu_mp_pkt.hist[1:0];  // new history\n   assign exu_mp_tgt[11:0]  = exu_mp_pkt.toffset[11:0] ;  // target offset\n   assign exu_mp_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  = exu_mp_index[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ;  // BTB/BHT address\n   assign exu_mp_ataken = exu_mp_pkt.ataken;\n\n\n   assign dec_tlu_br0_v_wb = dec_tlu_br0_r_pkt.valid;\n   assign dec_tlu_br0_hist_wb[1:0]  = dec_tlu_br0_r_pkt.hist[1:0];\n   assign dec_tlu_br0_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = exu_i0_br_index_r[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n   assign dec_tlu_br0_error_wb = dec_tlu_br0_r_pkt.br_error;\n   assign dec_tlu_br0_middle_wb = dec_tlu_br0_r_pkt.middle;\n   assign dec_tlu_br0_way_wb = dec_tlu_br0_r_pkt.way;\n   assign dec_tlu_br0_start_error_wb = dec_tlu_br0_r_pkt.br_start_error;\n   assign exu_i0_br_fghr_wb[pt.BHT_GHR_SIZE-1:0] = exu_i0_br_fghr_r[pt.BHT_GHR_SIZE-1:0];\n\n\n\n\n   // ----------------------------------------------------------------------\n   // READ\n   // ----------------------------------------------------------------------\n\n   // hash the incoming fetch PC, first guess at hashing algorithm\n   el2_btb_addr_hash #(.pt(pt)) f1hash(.pc(ifc_fetch_addr_f[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(btb_rd_addr_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n\n\n   assign fetch_addr_p1_f[31:2] = ifc_fetch_addr_f[31:2] + 30'b1;\n   el2_btb_addr_hash #(.pt(pt)) f1hash_p1(.pc(fetch_addr_p1_f[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(btb_rd_addr_p1_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n\n   assign btb_sel_f[1] = ~bht_dir_f[0];\n   assign btb_sel_f[0] =  bht_dir_f[0];\n\n   assign fetch_start_f[1:0] = {ifc_fetch_addr_f[1], ~ifc_fetch_addr_f[1]};\n\n   // Errors colliding with fetches must kill the btb/bht hit.\n\n   assign branch_error_collision_f = dec_tlu_error_wb & (btb_error_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == btb_rd_addr_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]);\n   assign branch_error_collision_p1_f = dec_tlu_error_wb & (btb_error_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == btb_rd_addr_p1_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]);\n\n   assign branch_error_bank_conflict_f = branch_error_collision_f & dec_tlu_error_wb;\n   assign branch_error_bank_conflict_p1_f = branch_error_collision_p1_f & dec_tlu_error_wb;\n\n   // set on leak one, hold until next flush without leak one\n   assign leak_one_f = (dec_tlu_flush_leak_one_wb & dec_tlu_flush_lower_wb) | (leak_one_f_d1 & ~dec_tlu_flush_lower_wb);\n\nlogic exu_flush_final_d1;\n\n if(!pt.BTB_FULLYA) begin\n   assign fetch_mp_collision_f = ( (exu_mp_btag[pt.BTB_BTAG_SIZE-1:0] == fetch_rd_tag_f[pt.BTB_BTAG_SIZE-1:0]) &\n                                    exu_mp_valid & ifc_fetch_req_f &\n                                    (exu_mp_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == btb_rd_addr_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO])\n                                    );\n   assign fetch_mp_collision_p1_f = ( (exu_mp_btag[pt.BTB_BTAG_SIZE-1:0] == fetch_rd_tag_p1_f[pt.BTB_BTAG_SIZE-1:0]) &\n                                       exu_mp_valid & ifc_fetch_req_f &\n                                       (exu_mp_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == btb_rd_addr_p1_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO])\n                                       );\n   // 2 -way SA, figure out the way hit and mux accordingly\n   assign tag_match_way0_f = btb_bank0_rd_data_way0_f[BV] & (btb_bank0_rd_data_way0_f[TAG_START:17] == fetch_rd_tag_f[pt.BTB_BTAG_SIZE-1:0]) &\n                              ~(dec_tlu_way_wb & branch_error_bank_conflict_f) & ifc_fetch_req_f & ~leak_one_f;\n\n   assign tag_match_way1_f = btb_bank0_rd_data_way1_f[BV] & (btb_bank0_rd_data_way1_f[TAG_START:17] == fetch_rd_tag_f[pt.BTB_BTAG_SIZE-1:0]) &\n                              ~(dec_tlu_way_wb & branch_error_bank_conflict_f) & ifc_fetch_req_f & ~leak_one_f;\n\n   assign tag_match_way0_p1_f = btb_bank0_rd_data_way0_p1_f[BV] & (btb_bank0_rd_data_way0_p1_f[TAG_START:17] == fetch_rd_tag_p1_f[pt.BTB_BTAG_SIZE-1:0]) &\n                              ~(dec_tlu_way_wb & branch_error_bank_conflict_p1_f) & ifc_fetch_req_f & ~leak_one_f;\n\n   assign tag_match_way1_p1_f = btb_bank0_rd_data_way1_p1_f[BV] & (btb_bank0_rd_data_way1_p1_f[TAG_START:17] == fetch_rd_tag_p1_f[pt.BTB_BTAG_SIZE-1:0]) &\n                              ~(dec_tlu_way_wb & branch_error_bank_conflict_p1_f) & ifc_fetch_req_f & ~leak_one_f;\n\n\n   // Both ways could hit, use the offset bit to reorder\n\n   assign tag_match_way0_expanded_f[1:0] = {tag_match_way0_f &  (btb_bank0_rd_data_way0_f[BOFF] ^ btb_bank0_rd_data_way0_f[PC4]),\n                                             tag_match_way0_f & ~(btb_bank0_rd_data_way0_f[BOFF] ^ btb_bank0_rd_data_way0_f[PC4])};\n\n   assign tag_match_way1_expanded_f[1:0] = {tag_match_way1_f &  (btb_bank0_rd_data_way1_f[BOFF] ^ btb_bank0_rd_data_way1_f[PC4]),\n                                             tag_match_way1_f & ~(btb_bank0_rd_data_way1_f[BOFF] ^ btb_bank0_rd_data_way1_f[PC4])};\n\n   assign tag_match_way0_expanded_p1_f[1:0] = {tag_match_way0_p1_f &  (btb_bank0_rd_data_way0_p1_f[BOFF] ^ btb_bank0_rd_data_way0_p1_f[PC4]),\n                                                tag_match_way0_p1_f & ~(btb_bank0_rd_data_way0_p1_f[BOFF] ^ btb_bank0_rd_data_way0_p1_f[PC4])};\n\n   assign tag_match_way1_expanded_p1_f[1:0] = {tag_match_way1_p1_f &  (btb_bank0_rd_data_way1_p1_f[BOFF] ^ btb_bank0_rd_data_way1_p1_f[PC4]),\n                                                tag_match_way1_p1_f & ~(btb_bank0_rd_data_way1_p1_f[BOFF] ^ btb_bank0_rd_data_way1_p1_f[PC4])};\n\n   assign wayhit_f[1:0] = tag_match_way0_expanded_f[1:0] | tag_match_way1_expanded_f[1:0];\n   assign wayhit_p1_f[1:0] = tag_match_way0_expanded_p1_f[1:0] | tag_match_way1_expanded_p1_f[1:0];\n\n   assign btb_bank0o_rd_data_f[BTB_DWIDTH-1:0] = ( ({17+pt.BTB_BTAG_SIZE{tag_match_way0_expanded_f[1]}} & btb_bank0_rd_data_way0_f[BTB_DWIDTH-1:0]) |\n                                                            ({17+pt.BTB_BTAG_SIZE{tag_match_way1_expanded_f[1]}} & btb_bank0_rd_data_way1_f[BTB_DWIDTH-1:0]) );\n   assign btb_bank0e_rd_data_f[BTB_DWIDTH-1:0] = ( ({17+pt.BTB_BTAG_SIZE{tag_match_way0_expanded_f[0]}} & btb_bank0_rd_data_way0_f[BTB_DWIDTH-1:0]) |\n                                                            ({17+pt.BTB_BTAG_SIZE{tag_match_way1_expanded_f[0]}} & btb_bank0_rd_data_way1_f[BTB_DWIDTH-1:0]) );\n\n   assign btb_bank0e_rd_data_p1_f[BTB_DWIDTH-1:0] = ( ({17+pt.BTB_BTAG_SIZE{tag_match_way0_expanded_p1_f[0]}} & btb_bank0_rd_data_way0_p1_f[BTB_DWIDTH-1:0]) |\n                                                               ({17+pt.BTB_BTAG_SIZE{tag_match_way1_expanded_p1_f[0]}} & btb_bank0_rd_data_way1_p1_f[BTB_DWIDTH-1:0]) );\n\n   // virtual bank order\n\n   assign btb_vbank0_rd_data_f[BTB_DWIDTH-1:0] = ( ({17+pt.BTB_BTAG_SIZE{fetch_start_f[0]}} &  btb_bank0e_rd_data_f[BTB_DWIDTH-1:0]) |\n                                                            ({17+pt.BTB_BTAG_SIZE{fetch_start_f[1]}} &  btb_bank0o_rd_data_f[BTB_DWIDTH-1:0]) );\n   assign btb_vbank1_rd_data_f[BTB_DWIDTH-1:0] = ( ({17+pt.BTB_BTAG_SIZE{fetch_start_f[0]}} &  btb_bank0o_rd_data_f[BTB_DWIDTH-1:0]) |\n                                                            ({17+pt.BTB_BTAG_SIZE{fetch_start_f[1]}} &  btb_bank0e_rd_data_p1_f[BTB_DWIDTH-1:0]) );\n\n   assign way_raw[1:0] =  tag_match_vway1_expanded_f[1:0] | (~vwayhit_f[1:0] & btb_vlru_rd_f[1:0]);\n\n   // --------------------------------------------------------------------------------\n   // --------------------------------------------------------------------------------\n   // update lru\n   // mp\n\n   // create a onehot lru write vector\n   assign mp_wrindex_dec[LRU_SIZE-1:0] = {{LRU_SIZE-1{1'b0}},1'b1} <<  exu_mp_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n   // fetch\n   assign fetch_wrindex_dec[LRU_SIZE-1:0] = {{LRU_SIZE-1{1'b0}},1'b1} <<  btb_rd_addr_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n   assign fetch_wrindex_p1_dec[LRU_SIZE-1:0] = {{LRU_SIZE-1{1'b0}},1'b1} <<  btb_rd_addr_p1_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n   assign mp_wrlru_b0[LRU_SIZE-1:0] = mp_wrindex_dec[LRU_SIZE-1:0] & {LRU_SIZE{exu_mp_valid}};\n\n\n   assign btb_lru_b0_hold[LRU_SIZE-1:0] = ~mp_wrlru_b0[LRU_SIZE-1:0] & ~fetch_wrlru_b0[LRU_SIZE-1:0];\n\n   // Forward the mp lru information to the fetch, avoids multiple way hits later\n   assign use_mp_way = fetch_mp_collision_f;\n   assign use_mp_way_p1 = fetch_mp_collision_p1_f;\n\n   assign lru_update_valid_f = (vwayhit_f[0] | vwayhit_f[1]) & ifc_fetch_req_f & ~leak_one_f;\n\n\n   assign fetch_wrlru_b0[LRU_SIZE-1:0] = fetch_wrindex_dec[LRU_SIZE-1:0] &\n                                         {LRU_SIZE{lru_update_valid_f}};\n   assign fetch_wrlru_p1_b0[LRU_SIZE-1:0] = fetch_wrindex_p1_dec[LRU_SIZE-1:0] &\n                                         {LRU_SIZE{lru_update_valid_f}};\n\n   assign btb_lru_b0_ns[LRU_SIZE-1:0] = ( (btb_lru_b0_hold[LRU_SIZE-1:0] & btb_lru_b0_f[LRU_SIZE-1:0]) |\n                                          (mp_wrlru_b0[LRU_SIZE-1:0] & {LRU_SIZE{~exu_mp_way}}) |\n                                          (fetch_wrlru_b0[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_f}}) |\n                                          (fetch_wrlru_p1_b0[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_p1_f}}) );\n\n\n\n   assign btb_lru_rd_f = use_mp_way ? exu_mp_way_f : |(fetch_wrindex_dec[LRU_SIZE-1:0] & btb_lru_b0_f[LRU_SIZE-1:0]);\n\n   assign btb_lru_rd_p1_f = use_mp_way_p1 ? exu_mp_way_f : |(fetch_wrindex_p1_dec[LRU_SIZE-1:0] & btb_lru_b0_f[LRU_SIZE-1:0]);\n\n   // rotated\n   assign btb_vlru_rd_f[1:0] = ( ({2{fetch_start_f[0]}} & {btb_lru_rd_f, btb_lru_rd_f}) |\n                                  ({2{fetch_start_f[1]}} & {btb_lru_rd_p1_f, btb_lru_rd_f}));\n\n   assign tag_match_vway1_expanded_f[1:0] = ( ({2{fetch_start_f[0]}} & {tag_match_way1_expanded_f[1:0]}) |\n                                               ({2{fetch_start_f[1]}} & {tag_match_way1_expanded_p1_f[0], tag_match_way1_expanded_f[1]}) );\n\n\n   rvdffe #(LRU_SIZE) btb_lru_ff (.*, .en(ifc_fetch_req_f | exu_mp_valid),\n                                    .din(btb_lru_b0_ns[(LRU_SIZE)-1:0]),\n                                   .dout(btb_lru_b0_f[(LRU_SIZE)-1:0]));\n\n end // if (!pt.BTB_FULLYA)\n   // Detect end of cache line and mask as needed\n   logic eoc_near;\n   logic eoc_mask;\n   assign eoc_near = &ifc_fetch_addr_f[pt.ICACHE_BEAT_ADDR_HI:3];\n   assign eoc_mask = ~eoc_near| (|(~ifc_fetch_addr_f[2:1]));\n\n\n\n   // --------------------------------------------------------------------------------\n   // --------------------------------------------------------------------------------\n\n   // mux out critical hit bank for pc computation\n   // This is only useful for the first taken branch in the fetch group\n   logic [16:1] btb_sel_data_f;\n\n   assign btb_rd_tgt_f[11:0] = btb_sel_data_f[16:5];\n   assign btb_rd_pc4_f       = btb_sel_data_f[4];\n   assign btb_rd_call_f  "}
{"text": "    = btb_sel_data_f[2];\n   assign btb_rd_ret_f       = btb_sel_data_f[1];\n\n   assign btb_sel_data_f[16:1] = ( ({16{btb_sel_f[1]}} & btb_vbank1_rd_data_f[16:1]) |\n                                    ({16{btb_sel_f[0]}} & btb_vbank0_rd_data_f[16:1]) );\n\n\n   logic [1:0] hist0_raw, hist1_raw, pc4_raw, pret_raw;\n\n   // a valid taken target needs to kill the next fetch as we compute the target address\n   assign ifu_bp_hit_taken_f = |(vwayhit_f[1:0] & hist1_raw[1:0]) & ifc_fetch_req_f & ~leak_one_f_d1 & ~dec_tlu_bpred_disable;\n\n\n   // Don't put calls/rets/ja in the predictor, force the bht taken instead\n   assign bht_force_taken_f[1:0] = {(btb_vbank1_rd_data_f[CALL] | btb_vbank1_rd_data_f[RET]),\n                                     (btb_vbank0_rd_data_f[CALL] | btb_vbank0_rd_data_f[RET])};\n\n\n   // taken and valid, otherwise, branch errors must clear the bht\n   assign bht_valid_f[1:0] = vwayhit_f[1:0];\n\n   assign bht_vbank0_rd_data_f[1:0] = ( ({2{fetch_start_f[0]}} & bht_bank0_rd_data_f[1:0]) |\n                                         ({2{fetch_start_f[1]}} & bht_bank1_rd_data_f[1:0]) );\n\n   assign bht_vbank1_rd_data_f[1:0] = ( ({2{fetch_start_f[0]}} & bht_bank1_rd_data_f[1:0]) |\n                                         ({2{fetch_start_f[1]}} & bht_bank0_rd_data_p1_f[1:0]) );\n\n\n   assign bht_dir_f[1:0] = {(bht_force_taken_f[1] | bht_vbank1_rd_data_f[1]) & bht_valid_f[1],\n                             (bht_force_taken_f[0] | bht_vbank0_rd_data_f[1]) & bht_valid_f[0]};\n\n   assign ifu_bp_inst_mask_f = (ifu_bp_hit_taken_f & btb_sel_f[1]) | ~ifu_bp_hit_taken_f;\n\n\n\n\n   // Branch prediction info is sent with the 2byte lane associated with the end of the branch.\n   // Cases\n   //       BANK1         BANK0\n   // -------------------------------\n   // |      :       |      :       |\n   // -------------------------------\n   //         <------------>                   : PC4 branch, offset, should be in B1 (indicated on [2])\n   //                <------------>            : PC4 branch, no offset, indicate PC4, VALID, HIST on [1]\n   //                       <------------>     : PC4 branch, offset, indicate PC4, VALID, HIST on [0]\n   //                <------>                  : PC2 branch, offset, indicate VALID, HIST on [1]\n   //                       <------>           : PC2 branch, no offset, indicate VALID, HIST on [0]\n   //\n\n\n\n   assign hist1_raw[1:0] = bht_force_taken_f[1:0] | {bht_vbank1_rd_data_f[1],\n                                                      bht_vbank0_rd_data_f[1]};\n\n   assign hist0_raw[1:0] = {bht_vbank1_rd_data_f[0],\n                            bht_vbank0_rd_data_f[0]};\n\n\n   assign pc4_raw[1:0] = {vwayhit_f[1] & btb_vbank1_rd_data_f[PC4],\n                          vwayhit_f[0] & btb_vbank0_rd_data_f[PC4]};\n\n   assign pret_raw[1:0] = {vwayhit_f[1] & ~btb_vbank1_rd_data_f[CALL] & btb_vbank1_rd_data_f[RET],\n                           vwayhit_f[0] & ~btb_vbank0_rd_data_f[CALL] & btb_vbank0_rd_data_f[RET]};\n\n   // GHR\n\n\n  // count the valids with masking based on first taken\n   assign num_valids[1:0] = countones(bht_valid_f[1:0]);\n\n   // Note that the following property holds\n   // P: prior ghr, H: history bit of last valid branch in line (could be 1 or 0)\n   // Num valid branches   What new GHR must be\n   // 2                    0H\n   // 1                    PH\n   // 0                    PP\n\n   assign final_h = |(btb_sel_f[1:0] & bht_dir_f[1:0]);\n\n   assign merged_ghr[pt.BHT_GHR_SIZE-1:0] = (\n                                            ({pt.BHT_GHR_SIZE{num_valids[1:0] == 2'h2}} & {fghr[pt.BHT_GHR_SIZE-3:0], 1'b0, final_h}) | // 0H\n                                            ({pt.BHT_GHR_SIZE{num_valids[1:0] == 2'h1}} & {fghr[pt.BHT_GHR_SIZE-2:0], final_h}) | // PH\n                                            ({pt.BHT_GHR_SIZE{num_valids[1:0] == 2'h0}} & {fghr[pt.BHT_GHR_SIZE-1:0]}) ); // PP\n\n   logic [pt.BHT_GHR_SIZE-1:0] exu_flush_ghr;\n   assign exu_flush_ghr[pt.BHT_GHR_SIZE-1:0] = exu_mp_fghr[pt.BHT_GHR_SIZE-1:0];\n\n   assign fghr_ns[pt.BHT_GHR_SIZE-1:0] = ( ({pt.BHT_GHR_SIZE{exu_flush_final_d1}} & exu_flush_ghr[pt.BHT_GHR_SIZE-1:0]) |\n                                         ({pt.BHT_GHR_SIZE{~exu_flush_final_d1 & ifc_fetch_req_f & ic_hit_f & ~leak_one_f_d1}} & merged_ghr[pt.BHT_GHR_SIZE-1:0]) |\n                                         ({pt.BHT_GHR_SIZE{~exu_flush_final_d1 & ~(ifc_fetch_req_f & ic_hit_f & ~leak_one_f_d1)}} & fghr[pt.BHT_GHR_SIZE-1:0]));\n\n   rvdffie #(.WIDTH(pt.BHT_GHR_SIZE+3),.OVERRIDE(1)) fetchghr (.*,\n                                          .din ({exu_flush_final, exu_mp_way, leak_one_f, fghr_ns[pt.BHT_GHR_SIZE-1:0]}),\n                                          .dout({exu_flush_final_d1, exu_mp_way_f, leak_one_f_d1, fghr[pt.BHT_GHR_SIZE-1:0]}));\n\n   assign ifu_bp_fghr_f[pt.BHT_GHR_SIZE-1:0] = fghr[pt.BHT_GHR_SIZE-1:0];\n\n\n   assign ifu_bp_way_f[1:0] = way_raw[1:0];\n   assign ifu_bp_hist1_f[1:0]    = hist1_raw[1:0];\n   assign ifu_bp_hist0_f[1:0]    = hist0_raw[1:0];\n   assign ifu_bp_pc4_f[1:0]     = pc4_raw[1:0];\n\n   assign ifu_bp_valid_f[1:0]   = vwayhit_f[1:0] & ~{2{dec_tlu_bpred_disable}};\n   assign ifu_bp_ret_f[1:0]     = pret_raw[1:0];\n\n\n   // compute target\n   // Form the fetch group offset based on the btb hit location and the location of the branch within the 4 byte chunk\n\n//  .i 5\n//  .o 3\n//  .ilb bht_dir_f[1] bht_dir_f[0] fetch_start_f[1] fetch_start_f[0] btb_rd_pc4_f\n//  .ob bloc_f[1] bloc_f[0] use_fa_plus\n//  .type fr\n//\n//\n//  ## rotdir[1:0]  fs   pc4  off fapl\n//    -1            01 -  01  0\n//    10            01 -  10  0\n//\n//    -1            10 -  10  0\n//    10            10 0  01  1\n//    10            10 1  01  0\nlogic [1:0] bloc_f;\nlogic use_fa_plus;\nassign bloc_f[1] = (bht_dir_f[0] & ~fetch_start_f[0]) | (~bht_dir_f[0]\n     & fetch_start_f[0]);\nassign bloc_f[0] = (bht_dir_f[0] & fetch_start_f[0]) | (~bht_dir_f[0]\n     & ~fetch_start_f[0]);\nassign use_fa_plus = (~bht_dir_f[0] & ~fetch_start_f[0] & ~btb_rd_pc4_f);\n\n\n\n\n    assign btb_fg_crossing_f = fetch_start_f[0] & btb_sel_f[0] & btb_rd_pc4_f;\n\n   assign bp_total_branch_offset_f =  bloc_f[1] ^ btb_rd_pc4_f;\n\n   logic [31:2] adder_pc_in_f, ifc_fetch_adder_prior;\n   rvdfflie #(.WIDTH(30), .LEFT(19)) faddrf_ff (.*, .en(ifc_fetch_req_f & ~ifu_bp_hit_taken_f & ic_hit_f), .din(ifc_fetch_addr_f[31:2]), .dout(ifc_fetch_adder_prior[31:2]));\n\n\n   assign ifu_bp_poffset_f[11:0] = btb_rd_tgt_f[11:0];\n\n   assign adder_pc_in_f[31:2] = ( ({30{ use_fa_plus}} & fetch_addr_p1_f[31:2]) |\n                                   ({30{ btb_fg_crossing_f}} & ifc_fetch_adder_prior[31:2]) |\n                                   ({30{~btb_fg_crossing_f & ~use_fa_plus}} & ifc_fetch_addr_f[31:2]));\n\n   rvbradder predtgt_addr (.pc({adder_pc_in_f[31:2], bp_total_branch_offset_f}),\n                         .offset(btb_rd_tgt_f[11:0]),\n                         .dout(bp_btb_target_adder_f[31:1])\n                         );\n   // mux in the return stack address here for a predicted return assuming the RS is valid, quite if no prediction\n   assign ifu_bp_btb_target_f[31:1] = (({31{btb_rd_ret_f & ~btb_rd_call_f & rets_out[0][0] & ifu_bp_hit_taken_f}} & rets_out[0][31:1]) |\n                                       ({31{~(btb_rd_ret_f & ~btb_rd_call_f & rets_out[0][0]) & ifu_bp_hit_taken_f}} & bp_btb_target_adder_f[31:1]) );\n\n\n   // ----------------------------------------------------------------------\n   // Return Stack\n   // ----------------------------------------------------------------------\n\n   rvbradder rs_addr (.pc({adder_pc_in_f[31:2], bp_total_branch_offset_f}),\n                    .offset({11'b0,  ~btb_rd_pc4_f}),\n                    .dout(bp_rs_call_target_f[31:1])\n                         );\n\n   assign rs_push = (btb_rd_call_f & ~btb_rd_ret_f & ifu_bp_hit_taken_f);\n   assign rs_pop = (btb_rd_ret_f & ~btb_rd_call_f & ifu_bp_hit_taken_f);\n   assign rs_hold = ~rs_push & ~rs_pop;\n\n\n\n   // Fetch based (bit 0 is a valid)\n   assign rets_in[0][31:0] = ( ({32{rs_push}} & {bp_rs_call_target_f[31:1], 1'b1}) | // target[31:1], valid\n                               ({32{rs_pop}}  & rets_out[1][31:0]) );\n\n   assign rsenable[0] = ~rs_hold;\n\n   for (i=0; i<pt.RET_STACK_SIZE; i++) begin : retstack\n\n      // for the last entry in the stack, we don't have a pop position\n      if(i==pt.RET_STACK_SIZE-1) begin\n         assign rets_in[i][31:0] = rets_out[i-1][31:0];\n         assign rsenable[i] = rs_push;\n      end\n      else if(i>0) begin\n        assign rets_in[i][31:0] = ( ({32{rs_push}} & rets_out[i-1][31:0]) |\n                                    ({32{rs_pop}}  & rets_out[i+1][31:0]) );\n         assign rsenable[i] = rs_push | rs_pop;\n      end\n      rvdffe #(32) rets_ff (.*, .en(rsenable[i]), .din(rets_in[i][31:0]), .dout(rets_out[i][31:0]));\n\n   end : retstack\n\n   // ----------------------------------------------------------------------\n   // WRITE\n   // ----------------------------------------------------------------------\n\n\n   assign dec_tlu_error_wb = dec_tlu_br0_start_error_wb | dec_tlu_br0_error_wb;\n\n   assign btb_error_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = dec_tlu_br0_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n   assign dec_tlu_way_wb = dec_tlu_br0_way_wb;\n\n   assign btb_valid = exu_mp_valid & ~dec_tlu_error_wb;\n\n   assign btb_wr_tag[pt.BTB_BTAG_SIZE-1:0] = exu_mp_btag[pt.BTB_BTAG_SIZE-1:0];\n\n   if(!pt.BTB_FULLYA) begin\n\n      if(pt.BTB_BTAG_FOLD) begin : btbfold\n         el2_btb_tag_hash_fold #(.pt(pt)) rdtagf  (.hash(fetch_rd_tag_f[pt.BTB_BTAG_SIZE-1:0]),\n                                                    .pc({ifc_fetch_addr_f[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]}));\n         el2_btb_tag_hash_fold #(.pt(pt)) rdtagp1f(.hash(fetch_rd_tag_p1_f[pt.BTB_BTAG_SIZE-1:0]),\n                                                    .pc({fetch_addr_p1_f[ pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]}));\n      end\n      else begin\n         el2_btb_tag_hash #(.pt(pt)) rdtagf(.hash(fetch_rd_tag_f[pt.BTB_BTAG_SIZE-1:0]),\n                                             .pc({ifc_fetch_addr_f[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]}));\n         el2_btb_tag_hash #(.pt(pt)) rdtagp1f(.hash(fetch_rd_tag_p1_f[pt.BTB_BTAG_SIZE-1:0]),\n                                               .pc({fetch_addr_p1_f[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]}));\n      end\n\n      assign btb_wr_en_way0 = ( ({{~exu_mp_way & exu_mp_valid_write & ~dec_tlu_error_wb}}) |\n                                ({{~dec_tlu_way_wb & dec_tlu_error_wb}}));\n\n      assign btb_wr_en_way1 = ( ({{exu_mp_way & exu_mp_valid_write & ~dec_tlu_error_wb}}) |\n                                ({{dec_tlu_way_wb & dec_tlu_error_wb}}));\n      assign btb_wr_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = dec_tlu_error_wb ? btb_error_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] : exu_mp_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n\n      assign vwayhit_f[1:0] = ( ({2{fetch_start_f[0]}} & {wayhit_f[1:0]}) |\n                                ({2{fetch_start_f[1]}} & {wayhit_p1_f[0], wayhit_f[1]})) & {eoc_mask, 1'b1};\n\n   end // if (!pt.BTB_FULLYA)\n\n   assign btb_wr_data[BTB_DWIDTH-1:0] = {btb_wr_tag[pt.BTB_BTAG_SIZE-1:0], exu_mp_tgt[pt.BTB_TOFFSET_SIZE-1:0], exu_mp_pc4, exu_mp_boffset,\n                                                exu_mp_call | exu_mp_ja, exu_mp_ret | exu_mp_ja, btb_valid} ;\n\n   assign exu_mp_valid_write = exu_mp_valid & exu_mp_ataken & ~exu_mp_pkt.valid;\n   logic [1:0] bht_wr_data0, bht_wr_data2;\n   logic [1:0] bht_wr_en0, bht_wr_en2;\n\n   assign middle_of_bank = exu_mp_pc4 ^ exu_mp_boffset;\n   assign bht_wr_en0[1:0] = {2{exu_mp_valid & ~exu_mp_call & ~exu_mp_ret & ~exu_mp_ja}} & {middle_of_bank, ~middle_of_bank};\n   assign bht_wr_en2[1:0] = {2{dec_tlu_br0_v_wb}} & {dec_tlu_br0_middle_wb, ~dec_tlu_br0_middle_wb} ;\n\n   // Experiments show this is the best priority scheme for same bank/index writes at the same time.\n   assign bht_wr_data0[1:0] = exu_mp_hist[1:0]; // lowest priority\n   assign bht_wr_data2[1:0] = dec_tlu_br0_hist_wb[1:0]; // highest priority\n\n\n\n   logic [pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] bht_rd_addr_f, bht_rd_addr_p1_f, bht_wr_addr0, bht_wr_addr2;\n\n   logic [pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] mp_hashed, br0_hashed_wb, bht_rd_addr_hashed_f, bht_rd_addr_hashed_p1_f;\n   el2_btb_ghr_hash #(.pt(pt)) mpghrhs  (.hashin(exu_mp_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]), .ghr(exu_mp_eghr[pt.BHT_GHR_SIZE-1:0]), .hash(mp_hashed[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO]));\n   el2_btb_ghr_hash #(.pt(pt)) br0ghrhs (.hashin(dec_tlu_br0_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]), .ghr(exu_i0_br_fghr_wb[pt.BHT_GHR_SIZE-1:0]), .hash(br0_hashed_wb[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO]));\n   el2_btb_ghr_hash #(.pt(pt)) fghrhs (.hashin(btb_rd_addr_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]), .ghr(fghr[pt.BHT_GHR_SIZE-1:0]), .hash(bht_rd_addr_hashed_f[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO]));\n   el2_btb_ghr_hash #(.pt(pt)) fghrhs_p1 (.hashin(btb_rd_addr_p1_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]), .ghr(fghr[pt.BHT_GHR_SIZE-1:0]), .hash(bht_rd_addr_hashed_p1_f[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO]));\n\n   assign bht_wr_addr0[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = mp_hashed[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO];\n   assign bht_wr_addr2[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = br0_hashed_wb[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO];\n   assign bht_rd_addr_f[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = bht_rd_addr_hashed_f[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO];\n   assign bht_rd_addr_p1_f[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = bht_rd_addr_hashed_p1_f[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO];\n\n\n   // ----------------------------------------------------------------------\n   // Structures. Using FLOPS\n   // ----------------------------------------------------------------------\n   // BTB\n   // Entry -> tag[pt.BTB_BTAG_SIZE-1:0], toffset[11:0], pc4, boffset, call, ret, valid\n\n   if(!pt.BTB_FULLYA) begin\n\n      for (j=0 ; j<LRU_SIZE ; j++) begin : BTB_FLOPS\n         // Way 0\n         rvdffe #(17+pt.BTB_BTAG_SIZE) btb_bank0_way0 (.*,\n                    .en(((btb_wr_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == j) & btb_wr_en_way0)),\n                    .din        (btb_wr_data[BTB_DWIDTH-1:0]),\n                    .dout       (btb_bank0_rd_data_way0_out[j]));\n\n         // Way 1\n         rvdffe #(17+pt.BTB_BTAG_SIZE) btb_bank0_way1 (.*,\n                    .en(((btb_wr_addr[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == j) & btb_wr_en_way1)),\n                    .din        (btb_wr_data[BTB_DWIDTH-1:0]),\n                    .dout       (btb_bank0_rd_data_way1_out[j]));\n\n      end\n\n\n    always_comb begin : BTB_rd_mux\n        btb_bank0_rd_data_way0_f[BTB_DWIDTH-1:0] = '0 ;\n        btb_bank0_rd_data_way1_f[BTB_DWIDTH-1:0] = '0 ;\n        btb_bank0_rd_data_way0_p1_f[BTB_DWIDTH-1:0] = '0 ;\n        btb_bank0_rd_data_way1_p1_f[BTB_DWIDTH-1:0] = '0 ;\n\n        for (int j=0; j< LRU_SIZE; j++) begin\n          if (btb_rd_addr_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == (pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1)'(j)) begin\n\n           btb_bank0_rd_data_way0_f[BTB_DWIDTH-1:0] =  btb_bank0_rd_data_way0_out[j];\n           btb_bank0_rd_data_way1_f[BTB_DWIDTH-1:0] =  btb_bank0_rd_data_way1_out[j];\n\n          end\n        end\n        for (int j=0; j< LRU_SIZE; j++) begin\n          if (btb_rd_addr_p1_f[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == (pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1)'(j)) begin\n\n           btb_bank0_rd_data_way0_p1_f[BTB_DWIDTH-1:0] =  btb_bank0_rd_data_way0_out[j];\n           btb_bank0_rd_data_way1_p1_f[BTB_DWIDTH-1:0] =  btb_bank0_rd_data_way1_out[j];\n\n          end\n        end\n    end\nend // if (!pt.BTB_FULLYA)\n\n\n\n\n\n      if(pt.BTB_FULLYA) begin : fa\n\n         logic found1, hit0, hit1;\n         logic btb_used_reset, write_used;\n         logic [$clog2(pt.BTB_SIZE)-1:0] btb_fa_wr_addr0, hit0_index, hit1_index;\n\n         logic [pt.BTB_SIZE-1:0]         btb_tag_hit, btb_offset_0, btb_offset_1, btb_used_ns, btb_used,\n                                         wr0_en, btb_upper_hit;\n         logic [pt.BTB_SIZE-1:0][BTB_DWIDTH-1:0] btbdata;\n\n         // Fully Associative tag hash uses bits 31:3. Bits 2:1 are the offset bits used for the 4 tag comp banks\n         // Full tag used to speed up lookup. There is one 31:3 cmp per entry, and 4 2:1 cmps per entry.\n\n         logic [FA_CMP_LOWER-1:1]  ifc_fetch_addr_p1_f;\n\n\n         assign ifc_fetch_addr_p1_f[FA_CMP_LOWER-1:1] = ifc_fetch_addr_f[FA_CMP_LOWER-1:1] + 1'b1;\n\n         assign fetch_mp_collision_f = ( (exu_mp_btag[pt.BTB_BTAG_SIZE-1:0] == ifc_fetch_addr_f[31:1]) &\n                                      exu_mp_valid & ifc_fetch_req_f & ~exu_mp_pkt.way);\n         assign fetch_mp_collision_p1_f = ( (exu_mp_btag[pt.BTB_BTAG_SIZE-1:0] == {ifc_fetch_addr_f[31:FA_CMP_LOWER], ifc_fetch_addr_p1_f[FA_CMP_LOWER-1:1]}) &\n                                      exu_mp_valid & ifc_fetch_req_f & ~exu_mp_pkt.way);\n\n      always_comb begin\n         btb_vbank0_rd_data_f = '0;\n         btb_vbank1_rd_data_f = '0;\n//       btb_tag_hit = '0;\n//       btb_upper_hit = '0;\n//       btb_offset_0 = '0;\n//       btb_offset_1 = '0;\n\n         found1 = 1'b0;\n         hit0 = 1'b0;\n         hit1 = 1'b0;\n         hit0_index = '0;\n         hit1_index = '0;\n         btb_fa_wr_addr0 = '0;\n\n         for(int i=0; i<pt.BTB_SIZE; i++) begin\n            logic upper_hit, offset_0, offset_1;\n\n            // Break the cmp into chunks for lower area.\n            // Chunk1: FA 31:6 or 31:5 depending on icache line size\n            // Chunk2: FA 5:1 or 4:1 depending on icache line size\n//          btb_upper_hit[i] = (btbdata[i][BTB_DWIDTH_TOP:FA_TAG_END_UPPER] == ifc_fetch_addr_f[31:FA_CMP_LOWER]) & btbdata[i][0] & ~wr0_en[i];\n//          btb_offset_0[i] = (btbdata[i][FA_TAG_START_LOWER:FA_TAG_END_LOWER] == ifc_fetch_addr_f[FA_CMP_LOWER-1:1]) & btb_upper_hit[i];\n//          btb_offset_1[i] = (btbdata[i][FA_TAG_START_LOWER:FA_TAG_END_LOWER] == ifc_fetch_addr_p1_f[FA_CMP_LOWER-1:1]) & btb_upper_hit[i];\n\n            upper_hit = (btbdata[i][BTB_DWIDTH_TOP:FA_TAG_END_UPPER] == ifc_fetch_addr_f[31:FA_CMP_LOWER]) & btbdata[i][0] & ~wr0_en[i];\n            offset_0 = (btbdata[i][FA_TAG_START_LOWER:FA_TAG_END_LOWER] == ifc_fetch_addr_f[FA_CMP_LOWER-1:1]) & upper_hit;\n            offset_1 = (btbdata[i][FA_TAG_START_LOWER:FA_TAG_END_LOWER] == ifc_fetch_addr_p1_f[FA_CMP_LOWER-1:1]) & upper_hit;\n\n            if(~hit0) begin\n               if(offset_0) begin\n                  hit0_index[BTB_FA_INDEX:0] = (BTB_FA_INDEX+1)'(i);\n                  // hit unless we are also writing this entry at the same time\n                  hit0 = 1'b1;\n               end\n            end\n            if(~hit1) begin\n               if(offset_1) begin\n                  hit1_index[BTB_FA_INDEX:0] = (BTB_FA_INDEX+1)'(i);\n                  hit1 = 1'b1;\n               end\n            end\n\n\n            // Mux out the 2 potential branches\n            if(offset_0)\n              btb_vbank0_rd_data_f[BTB_DWIDTH-1:0] = fetch_mp_collision_f ? btb_wr_data : btbdata[i];\n            if(offset_1)\n              btb_vbank1_rd_data_f[BTB_DWIDTH-1:0] = fetch_mp_collision_p1_f ? btb_wr_data : btbdata[i];\n\n            // find the first zero from bit zero in the used vector, this is the write address\n            if(~found1 & ((exu_mp_valid_write & ~exu_mp_pkt.way) | dec_tlu_error_wb)) begin\n               if(~btb_used[i]) begin\n                  btb_fa_wr_addr0[BTB_FA_INDEX:0] = i[BTB_FA_INDEX:0];\n                  found1 = 1'b1;\n               end\n            end\n         end\n      end // always_comb begin\n\n//`ifdef RV_ASSERT_ON\n//   btbhitonehot0: assert #0 ($onehot0(btb_offset_0));\n//   btbhitonehot1: assert #0 ($onehot0(btb_offset_1));\n//`endif\n\n   assign vwayhit_f[1:0] = {hit1, hit0} & {eoc_mask, 1'b1};\n\n   // way bit is reused as the predicted bit\n   assign way_raw[1:0] =  vwayhit_f[1:0] | {fetch_mp_collision_p1_f, fetch_mp_collision_f};\n\n   for (j=0 ; j<pt.BTB_SIZE ; j++) begin : BTB_FAFLOPS\n\n      assign wr0_en[j] = ((btb_fa_wr_addr0[BTB_FA_INDEX:0] == j) & (exu_mp_valid_write & ~exu_mp_pkt.way)) |\n                         ((dec_fa_error_index == j) & dec_tlu_error_wb);\n\n      rvdffe #(BTB_DWIDT"}
{"text": "H) btb_fa (.*, .clk(clk),\n                                   .en  (wr0_en[j]),\n                                   .din (btb_wr_data[BTB_DWIDTH-1:0]),\n                                   .dout(btbdata[j]));\n   end // block: BTB_FAFLOPS\n\n   assign ifu_bp_fa_index_f[1] = hit1 ? hit1_index : '0;\n   assign ifu_bp_fa_index_f[0] = hit0 ? hit0_index : '0;\n\n   assign btb_used_reset = &btb_used[pt.BTB_SIZE-1:0];\n   assign btb_used_ns[pt.BTB_SIZE-1:0] = ({pt.BTB_SIZE{vwayhit_f[1]}} & (32'b1 << hit1_index[BTB_FA_INDEX:0])) |\n                                         ({pt.BTB_SIZE{vwayhit_f[0]}} & (32'b1 << hit0_index[BTB_FA_INDEX:0])) |\n                                         ({pt.BTB_SIZE{exu_mp_valid_write & ~exu_mp_pkt.way & ~dec_tlu_error_wb}} & (32'b1 << btb_fa_wr_addr0[BTB_FA_INDEX:0])) |\n                                         ({pt.BTB_SIZE{btb_used_reset}} & {pt.BTB_SIZE{1'b0}}) |\n                                         ({pt.BTB_SIZE{~btb_used_reset & dec_tlu_error_wb}} & (btb_used[pt.BTB_SIZE-1:0] & ~(32'b1 << dec_fa_error_index[BTB_FA_INDEX:0]))) |\n                                         (~{pt.BTB_SIZE{btb_used_reset | dec_tlu_error_wb}} & btb_used[pt.BTB_SIZE-1:0]);\n\n   assign write_used = btb_used_reset | ifu_bp_hit_taken_f | exu_mp_valid_write | dec_tlu_error_wb;\n\n\n   rvdffe #(pt.BTB_SIZE) btb_usedf (.*, .clk(clk),\n                    .en  (write_used),\n                    .din (btb_used_ns[pt.BTB_SIZE-1:0]),\n                    .dout(btb_used[pt.BTB_SIZE-1:0]));\n\nend // block: fa\n\n\n   //-----------------------------------------------------------------------------\n   // BHT\n   // 2 bit Entry -> direction, strength\n   //\n   //-----------------------------------------------------------------------------\n\n//   logic [1:0] [(pt.BHT_ARRAY_DEPTH/NUM_BHT_LOOP)-1:0][NUM_BHT_LOOP-1:0][1:0]      bht_bank_wr_data ;\n   logic [1:0] [pt.BHT_ARRAY_DEPTH-1:0] [1:0]                bht_bank_rd_data_out ;\n   logic [1:0] [(pt.BHT_ARRAY_DEPTH/NUM_BHT_LOOP)-1:0]                 bht_bank_clken ;\n   logic [1:0] [(pt.BHT_ARRAY_DEPTH/NUM_BHT_LOOP)-1:0]                 bht_bank_clk   ;\n//   logic [1:0] [(pt.BHT_ARRAY_DEPTH/NUM_BHT_LOOP)-1:0][NUM_BHT_LOOP-1:0]           bht_bank_sel   ;\n\n   for ( i=0; i<2; i++) begin : BANKS\n     wire[pt.BHT_ARRAY_DEPTH-1:0] wr0, wr1;\n     assign wr0 = bht_wr_en0[i] << bht_wr_addr0;\n     assign wr1 = bht_wr_en2[i] << bht_wr_addr2;\n     for (genvar k=0 ; k < (pt.BHT_ARRAY_DEPTH)/NUM_BHT_LOOP ; k++) begin : BHT_CLK_GROUP\n     assign bht_bank_clken[i][k]  = (bht_wr_en0[i] & ((bht_wr_addr0[pt.BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) |  BHT_NO_ADDR_MATCH)) |\n                                    (bht_wr_en2[i] & ((bht_wr_addr2[pt.BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) |  BHT_NO_ADDR_MATCH));\n`ifndef RV_FPGA_OPTIMIZE\n     rvclkhdr bht_bank_grp_cgc ( .en(bht_bank_clken[i][k]), .l1clk(bht_bank_clk[i][k]), .* ); // ifndef RV_FPGA_OPTIMIZE\n`endif\n\n     for (j=0 ; j<NUM_BHT_LOOP ; j++) begin : BHT_FLOPS\n     wire[1:0] wdata;\n     wire  bank_sel = wr1[NUM_BHT_LOOP*k+j] | wr0[NUM_BHT_LOOP*k+j];\n\n//       assign   bht_bank_sel[i][k][j]    = (bht_wr_en0[i] & (bht_wr_addr0[NUM_BHT_LOOP_INNER_HI :pt.BHT_ADDR_LO] == j) & ((bht_wr_addr0[pt.BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) | BHT_NO_ADDR_MATCH)) |\n//                                           (bht_wr_en2[i] & (bht_wr_addr2[NUM_BHT_LOOP_INNER_HI :pt.BHT_ADDR_LO] == j) & ((bht_wr_addr2[pt.BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) | BHT_NO_ADDR_MATCH)) ;\n\n//       assign bht_bank_wr_data[i][k][j]  = (bht_wr_en2[i] & (bht_wr_addr2[NUM_BHT_LOOP_INNER_HI:pt.BHT_ADDR_LO] == j) & ((bht_wr_addr2[pt.BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) | BHT_NO_ADDR_MATCH)) ? bht_wr_data2[1:0] :\n//                                                                                                                      bht_wr_data0[1:0]   ;\n       assign wdata  = wr1[NUM_BHT_LOOP*k+j] ? bht_wr_data2[1:0] :bht_wr_data0;\n\n\n\n          rvdffs_fpga #(2) bht_bank (.*,\n                    .clk        (bht_bank_clk[i][k]),\n                    .en         (bank_sel),\n                    .rawclk     (clk),\n                    .clken      (bank_sel),\n                    .din        (wdata),\n                    .dout       (bht_bank_rd_data_out[i][(16*k)+j]));\n\n      end // block: BHT_FLOPS\n   end // block: BHT_CLK_GROUP\n end // block: BANKS\n\n    always_comb begin : BHT_rd_mux\n     bht_bank0_rd_data_f[1:0] = '0 ;\n     bht_bank1_rd_data_f[1:0] = '0 ;\n     bht_bank0_rd_data_p1_f[1:0] = '0 ;\n     for (int j=0; j< pt.BHT_ARRAY_DEPTH; j++) begin\n       if (bht_rd_addr_f[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] == (pt.BHT_ADDR_HI-pt.BHT_ADDR_LO+1)'(j)) begin\n         bht_bank0_rd_data_f[1:0] = bht_bank_rd_data_out[0][j];\n         bht_bank1_rd_data_f[1:0] = bht_bank_rd_data_out[1][j];\n       end\n       if (bht_rd_addr_p1_f[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] == (pt.BHT_ADDR_HI-pt.BHT_ADDR_LO+1)'(j)) begin\n         bht_bank0_rd_data_p1_f[1:0] = bht_bank_rd_data_out[0][j];\n       end\n      end\n    end // block: BHT_rd_mux\n\n\nfunction [1:0] countones;\n      input [1:0] valid;\n\n      begin\n\ncountones[1:0] = {2'b0, valid[1]} +\n                 {2'b0, valid[0]};\n      end\n   endfunction\nendmodule // el2_ifu_bp_ctl\n\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n// purpose of this file is to convert 16b RISCV compressed instruction into 32b equivalent\n\nmodule el2_ifu_compress_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n   input  logic [15:0] din,        // 16-bit   compressed instruction\n   output logic [31:0] dout        // 32-bit uncompressed instruction\n   );\n\n\n   logic               legal;\n\n   logic [15:0]  i;\n\n   logic [31:0]  o,l1,l2,l3;\n\n\n   assign i[15:0] = din[15:0];\n\n\n   logic [4:0]   rs2d,rdd,rdpd,rs2pd;\n\n   logic rdrd;\n   logic rdrs1;\n   logic rs2rs2;\n   logic rdprd;\n   logic rdprs1;\n   logic rs2prs2;\n   logic rs2prd;\n   logic uimm9_2;\n   logic ulwimm6_2;\n   logic ulwspimm7_2;\n   logic rdeq2;\n   logic rdeq1;\n   logic rs1eq2;\n   logic sbroffset8_1;\n   logic simm9_4;\n   logic simm5_0;\n   logic sjaloffset11_1;\n   logic sluimm17_12;\n   logic uimm5_0;\n   logic uswimm6_2;\n   logic uswspimm7_2;\n\n\n\n   // form the opcodes\n\n   // formats\n   //\n   // c.add rd 11:7 rs2  6:2\n   // c.and rdp 9:7 rs2p 4:2\n   //\n   // add rs2 24:20 rs1 19:15  rd 11:7\n\n   assign rs2d[4:0] = i[6:2];\n\n   assign rdd[4:0] = i[11:7];\n\n   assign rdpd[4:0] = {2'b01, i[9:7]};\n\n   assign rs2pd[4:0] = {2'b01, i[4:2]};\n\n\n\n   // merge in rd, rs1, rs2\n\n\n   // rd\n   assign l1[6:0] = o[6:0];\n\n   assign l1[11:7] = o[11:7] |\n                     ({5{rdrd}} & rdd[4:0]) |\n                     ({5{rdprd}} & rdpd[4:0]) |\n                     ({5{rs2prd}} & rs2pd[4:0]) |\n                     ({5{rdeq1}} & 5'd1) |\n                     ({5{rdeq2}} & 5'd2);\n\n\n   // rs1\n   assign l1[14:12] = o[14:12];\n   assign l1[19:15] = o[19:15] |\n                      ({5{rdrs1}} & rdd[4:0]) |\n                      ({5{rdprs1}} & rdpd[4:0]) |\n                      ({5{rs1eq2}} & 5'd2);\n\n\n   // rs2\n   assign l1[24:20] = o[24:20] |\n                      ({5{rs2rs2}} & rs2d[4:0]) |\n                      ({5{rs2prs2}} & rs2pd[4:0]);\n\n   assign l1[31:25] = o[31:25];\n\n   logic [5:0] simm5d;\n   logic [9:2] uimm9d;\n\n   logic [9:4] simm9d;\n   logic [6:2] ulwimm6d;\n   logic [7:2] ulwspimm7d;\n   logic [5:0] uimm5d;\n   logic [20:1] sjald;\n\n   logic [31:12] sluimmd;\n\n   // merge in immediates + jal offset\n\n   assign simm5d[5:0] = { i[12], i[6:2] };\n\n   assign uimm9d[9:2] = { i[10:7], i[12:11], i[5], i[6] };\n\n   assign simm9d[9:4] = { i[12], i[4:3], i[5], i[2], i[6] };\n\n   assign ulwimm6d[6:2] = { i[5], i[12:10], i[6] };\n\n   assign ulwspimm7d[7:2] = { i[3:2], i[12], i[6:4] };\n\n   assign uimm5d[5:0] = { i[12], i[6:2] };\n\n   assign sjald[11:1] = { i[12], i[8], i[10:9], i[6], i[7], i[2], i[11], i[5:4], i[3] };\n\n   assign sjald[20:12] =  {9{i[12]}};\n\n\n\n   assign sluimmd[31:12] = { {15{i[12]}}, i[6:2] };\n\n\n   assign l2[31:20] = ( l1[31:20] ) |\n                      ( {12{simm5_0}}   &  {{7{simm5d[5]}},simm5d[4:0]} ) |\n                      ( {12{uimm9_2}}   &  {2'b0,uimm9d[9:2],2'b0} ) |\n                      ( {12{simm9_4}}   &   {{3{simm9d[9]}},simm9d[8:4],4'b0} ) |\n                      ( {12{ulwimm6_2}} &   {5'b0,ulwimm6d[6:2],2'b0} ) |\n                      ( {12{ulwspimm7_2}}  & {4'b0,ulwspimm7d[7:2],2'b0} ) |\n                      ( {12{uimm5_0}}      &    {6'b0,uimm5d[5:0]} ) |\n                      ( {12{sjaloffset11_1}} &  {sjald[20],sjald[10:1],sjald[11]} ) |\n                      ( {12{sluimm17_12}}    &  sluimmd[31:20] );\n\n\n\n   assign l2[19:12] = ( l1[19:12] ) |\n                      ( {8{sjaloffset11_1}} & sjald[19:12] ) |\n                      ( {8{sluimm17_12}} & sluimmd[19:12] );\n\n\n   assign l2[11:0] = l1[11:0];\n\n\n   // merge in branch offset and store immediates\n\n   logic [8:1]   sbr8d;\n   logic [6:2]   uswimm6d;\n   logic [7:2]   uswspimm7d;\n\n\n   assign sbr8d[8:1] =   { i[12], i[6], i[5], i[2], i[11], i[10], i[4], i[3] };\n\n   assign uswimm6d[6:2] = { i[5], i[12:10], i[6] };\n\n   assign uswspimm7d[7:2] = { i[8:7], i[12:9] };\n\n   assign l3[31:25] = ( l2[31:25] ) |\n                      ( {7{sbroffset8_1}} & { {4{sbr8d[8]}},sbr8d[7:5] } ) |\n                      ( {7{uswimm6_2}}    & { 5'b0, uswimm6d[6:5] } ) |\n                      ( {7{uswspimm7_2}} & { 4'b0, uswspimm7d[7:5] } );\n\n\n   assign l3[24:12] = l2[24:12];\n\n   assign l3[11:7] = ( l2[11:7] ) |\n                     ( {5{sbroffset8_1}} & { sbr8d[4:1], sbr8d[8] } ) |\n                     ( {5{uswimm6_2}} & { uswimm6d[4:2], 2'b0 } ) |\n                     ( {5{uswspimm7_2}} & { uswspimm7d[4:2], 2'b0 } );\n\n   assign l3[6:0] = l2[6:0];\n\n\n   assign dout[31:0] = l3[31:0] & {32{legal}};\n\n\n// file \"cdecode\" is human readable file that has all of the compressed instruction decodes defined and is part of git repo\n// modify this file as needed\n\n// to generate all the equations below from \"cdecode\" except legal equation:\n\n// 1) coredecode -in cdecode > cdecode.e\n\n// 2) espresso -Dso -oeqntott cdecode.e | addassign > compress_equations\n\n// to generate the legal (16b compressed instruction is legal)  equation below:\n\n// 1) coredecode -in cdecode -legal > clegal.e\n\n// 2) espresso -Dso -oeqntott clegal.e | addassign > clegal_equation\n\n\n\n\n\n// espresso decodes\nassign rdrd = (!i[14]&i[6]&i[1]) | (!i[15]&i[14]&i[11]&i[0]) | (!i[14]&i[5]&i[1]) | (\n    !i[15]&i[14]&i[10]&i[0]) | (!i[14]&i[4]&i[1]) | (!i[15]&i[14]&i[9]\n    &i[0]) | (!i[14]&i[3]&i[1]) | (!i[15]&i[14]&!i[8]&i[0]) | (!i[14]\n    &i[2]&i[1]) | (!i[15]&i[14]&i[7]&i[0]) | (!i[15]&i[1]) | (!i[15]\n    &!i[13]&i[0]);\n\nassign rdrs1 = (!i[14]&i[12]&i[11]&i[1]) | (!i[14]&i[12]&i[10]&i[1]) | (!i[14]\n    &i[12]&i[9]&i[1]) | (!i[14]&i[12]&i[8]&i[1]) | (!i[14]&i[12]&i[7]\n    &i[1]) | (!i[14]&!i[12]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]\n    &i[12]&i[6]&i[1]) | (!i[14]&i[12]&i[5]&i[1]) | (!i[14]&i[12]&i[4]\n    &i[1]) | (!i[14]&i[12]&i[3]&i[1]) | (!i[14]&i[12]&i[2]&i[1]) | (\n    !i[15]&!i[14]&!i[13]&i[0]) | (!i[15]&!i[14]&i[1]);\n\nassign rs2rs2 = (i[15]&i[6]&i[1]) | (i[15]&i[5]&i[1]) | (i[15]&i[4]&i[1]) | (\n    i[15]&i[3]&i[1]) | (i[15]&i[2]&i[1]) | (i[15]&i[14]&i[1]);\n\nassign rdprd = (i[15]&!i[14]&!i[13]&i[0]);\n\nassign rdprs1 = (i[15]&!i[13]&i[0]) | (i[15]&i[14]&i[0]) | (i[14]&!i[1]&!i[0]);\n\nassign rs2prs2 = (i[15]&!i[14]&!i[13]&i[11]&i[10]&i[0]) | (i[15]&!i[1]&!i[0]);\n\nassign rs2prd = (!i[15]&!i[1]&!i[0]);\n\nassign uimm9_2 = (!i[14]&!i[1]&!i[0]);\n\nassign ulwimm6_2 = (!i[15]&i[14]&!i[1]&!i[0]);\n\nassign ulwspimm7_2 = (!i[15]&i[14]&i[1]);\n\nassign rdeq2 = (!i[15]&i[14]&i[13]&!i[11]&!i[10]&!i[9]&i[8]&!i[7]);\n\nassign rdeq1 = (!i[14]&i[12]&i[11]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]\n    &i[12]&i[10]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[9]\n    &!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[8]&!i[6]&!i[5]\n    &!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[7]&!i[6]&!i[5]&!i[4]&!i[3]\n    &!i[2]&i[1]) | (!i[15]&!i[14]&i[13]);\n\nassign rs1eq2 = (!i[15]&i[14]&i[13]&!i[11]&!i[10]&!i[9]&i[8]&!i[7]) | (i[14]\n    &i[1]) | (!i[14]&!i[1]&!i[0]);\n\nassign sbroffset8_1 = (i[15]&i[14]&i[0]);\n\nassign simm9_4 = (!i[15]&i[14]&i[13]&!i[11]&!i[10]&!i[9]&i[8]&!i[7]);\n\nassign simm5_0 = (!i[14]&!i[13]&i[11]&!i[10]&i[0]) | (!i[15]&!i[13]&i[0]);\n\nassign sjaloffset11_1 = (!i[14]&i[13]);\n\nassign sluimm17_12 = (!i[15]&i[14]&i[13]&i[7]) | (!i[15]&i[14]&i[13]&!i[8]) | (\n    !i[15]&i[14]&i[13]&i[9]) | (!i[15]&i[14]&i[13]&i[10]) | (!i[15]&i[14]\n    &i[13]&i[11]);\n\nassign uimm5_0 = (i[15]&!i[14]&!i[13]&!i[11]&i[0]) | (!i[15]&!i[14]&i[1]);\n\nassign uswimm6_2 = (i[15]&!i[1]&!i[0]);\n\nassign uswspimm7_2 = (i[15]&i[14]&i[1]);\n\nassign o[31]  = 1'b0;\n\nassign o[30] = (i[15]&!i[14]&!i[13]&i[10]&!i[6]&!i[5]&i[0]) | (i[15]&!i[14]\n    &!i[13]&!i[11]&i[10]&i[0]);\n\nassign o[29]  = 1'b0;\n\nassign o[28]  = 1'b0;\n\nassign o[27]  = 1'b0;\n\nassign o[26]  = 1'b0;\n\nassign o[25]  = 1'b0;\n\nassign o[24]  = 1'b0;\n\nassign o[23]  = 1'b0;\n\nassign o[22]  = 1'b0;\n\nassign o[21]  = 1'b0;\n\nassign o[20] = (!i[14]&i[12]&!i[11]&!i[10]&!i[9]&!i[8]&!i[7]&!i[6]&!i[5]&!i[4]\n    &!i[3]&!i[2]&i[1]);\n\nassign o[19]  = 1'b0;\n\nassign o[18]  = 1'b0;\n\nassign o[17]  = 1'b0;\n\nassign o[16]  = 1'b0;\n\nassign o[15]  = 1'b0;\n\nassign o[14] = (i[15]&!i[14]&!i[13]&!i[11]&i[0]) | (i[15]&!i[14]&!i[13]&!i[10]\n    &i[0]) | (i[15]&!i[14]&!i[13]&i[6]&i[0]) | (i[15]&!i[14]&!i[13]&i[5]\n    &i[0]);\n\nassign o[13] = (i[15]&!i[14]&!i[13]&i[11]&!i[10]&i[0]) | (i[15]&!i[14]&!i[13]\n    &i[11]&i[6]&i[0]) | (i[14]&!i[0]);\n\nassign o[12] = (i[15]&!i[14]&!i[13]&i[6]&i[5]&i[0]) | (i[15]&!i[14]&!i[13]&!i[11]\n    &i[0]) | (i[15]&!i[14]&!i[13]&!i[10]&i[0]) | (!i[15]&!i[14]&i[1]) | (\n    i[15]&i[14]&i[13]);\n\nassign o[11]  = 1'b0;\n\nassign o[10]  = 1'b0;\n\nassign o[9]  = 1'b0;\n\nassign o[8]  = 1'b0;\n\nassign o[7]  = 1'b0;\n\nassign o[6] = (i[15]&!i[14]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&!i[0]) | (!i[14]&i[13]) | (\n    i[15]&i[14]&i[0]);\n\nassign o[5] = (i[15]&!i[0]) | (i[15]&i[11]&i[10]) | (i[13]&!i[8]) | (i[13]&i[7]) | (\n    i[13]&i[9]) | (i[13]&i[10]) | (i[13]&i[11]) | (!i[14]&i[13]) | (\n    i[15]&i[14]);\n\nassign o[4] = (!i[14]&!i[11]&!i[10]&!i[9]&!i[8]&!i[7]&!i[0]) | (!i[15]&!i[14]\n    &!i[0]) | (!i[14]&i[6]&!i[0]) | (!i[15]&i[14]&i[0]) | (!i[14]&i[5]\n    &!i[0]) | (!i[14]&i[4]&!i[0]) | (!i[14]&!i[13]&i[0]) | (!i[14]&i[3]\n    &!i[0]) | (!i[14]&i[2]&!i[0]);\n\nassign o[3] = (!i[14]&i[13]);\n\nassign o[2] = (!i[14]&i[12]&i[11]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]\n    &i[12]&i[10]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[9]\n    &!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[8]&!i[6]&!i[5]\n    &!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[7]&!i[6]&!i[5]&!i[4]&!i[3]\n    &!i[2]&i[1]) | (i[15]&!i[14]&!i[12]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]\n    &!i[0]) | (!i[15]&i[13]&!i[8]) | (!i[15]&i[13]&i[7]) | (!i[15]&i[13]\n    &i[9]) | (!i[15]&i[13]&i[10]) | (!i[15]&i[13]&i[11]) | (!i[14]&i[13]);\n\n// 32b instruction has lower two bits 2'b11\n\nassign o[1]  = 1'b1;\n\nassign o[0]  = 1'b1;\n\nassign legal = (!i[13]&!i[12]&i[11]&i[1]&!i[0]) | (!i[13]&!i[12]&i[6]&i[1]&!i[0]) | (\n    !i[15]&!i[13]&i[11]&!i[1]) | (!i[13]&!i[12]&i[5]&i[1]&!i[0]) | (\n    !i[13]&!i[12]&i[10]&i[1]&!i[0]) | (!i[15]&!i[13]&i[6]&!i[1]) | (\n    i[15]&!i[12]&!i[1]&i[0]) | (!i[13]&!i[12]&i[9]&i[1]&!i[0]) | (!i[12]\n    &i[6]&!i[1]&i[0]) | (!i[15]&!i[13]&i[5]&!i[1]) | (!i[13]&!i[12]&i[8]\n    &i[1]&!i[0]) | (!i[12]&i[5]&!i[1]&i[0]) | (!i[15]&!i[13]&i[10]&!i[1]) | (\n    !i[13]&!i[12]&i[7]&i[1]&!i[0]) | (i[12]&i[11]&!i[10]&!i[1]&i[0]) | (\n    !i[15]&!i[13]&i[9]&!i[1]) | (!i[13]&!i[12]&i[4]&i[1]&!i[0]) | (i[13]\n    &i[12]&!i[1]&i[0]) | (!i[15]&!i[13]&i[8]&!i[1]) | (!i[13]&!i[12]&i[3]\n    &i[1]&!i[0]) | (i[13]&i[4]&!i[1]&i[0]) | (!i[13]&!i[12]&i[2]&i[1]\n    &!i[0]) | (!i[15]&!i[13]&i[7]&!i[1]) | (i[13]&i[3]&!i[1]&i[0]) | (\n    i[13]&i[2]&!i[1]&i[0]) | (i[14]&!i[13]&!i[1]) | (!i[14]&!i[12]&!i[1]\n    &i[0]) | (i[15]&!i[13]&i[12]&i[1]&!i[0]) | (!i[15]&!i[13]&!i[12]&i[1]\n    &!i[0]) | (!i[15]&!i[13]&i[12]&!i[1]) | (i[14]&!i[13]&!i[0]);\n\n\n\n\nendmodule\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n// Copyright (c) 2023 Antmicro <www.antmicro.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n//********************************************************************************\n// Icache closely coupled memory --- ICCM\n//********************************************************************************\n\nmodule el2_ifu_iccm_mem\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n   input logic                                        clk,                                 // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n   input logic                                        active_clk,                          // Clock only while core active.  Through two clock headers. For flops without second clock header built in.\n   input logic                                        rst_l,                               // reset, active low\n   input logic                                        clk_override,                        // Override non-functional clock gating\n\n   input logic                                        iccm_wren,                           // ICCM write enable\n   input logic                                        iccm_rden,                           // ICCM read enable\n   input logic [pt.ICCM_BITS-1:1]                     iccm_rw_addr,                        // ICCM read/write address\n   input logic                                        iccm_buf_correct_ecc,                // ICCM is doing a single bit error correct cycle\n   input logic                                        iccm_correction_state,               // ICCM under a correction - This is needed to guard replacements when hit\n   input logic [2:0]                                  iccm_wr_size,                        // ICCM write size\n   input logic [77:0]                                 iccm_wr_data,                        // ICCM write data\n\n   el2_mem_if.veer_iccm                               iccm_mem_export,                     // RAM repositioned in testbench and connected by this interface\n\n   output logic [63:0]                                iccm_rd_data,                        // ICCM read data\n   output logic [77:0]                                iccm_rd_data_ecc,                    // ICCM read ecc\n   input  logic                                       scan_mode                            // Scan mode control\n\n);\n\n\n   logic [pt.ICCM_NUM_BANKS-1:0]                                                wren_bank;\n   logic [pt.ICCM_NUM_BANKS-1:0]                                                rden_bank;\n   logic [pt.ICCM_NUM_BANKS-1:0]                                                iccm_clken;\n   logic [pt.ICCM_NUM_BANKS-1:0] [pt.ICCM_BITS-1:pt.ICCM_BANK_INDEX_LO] addr_bank;\n\n   logic [pt.ICCM_NUM_BANKS-1:0] [38:0]  iccm_bank_dout, iccm_bank_dout_fn;\n   logic [pt.ICCM_NUM_BANKS-1:0] [38:0]  iccm_bank_wr_data;\n   logic [pt.ICCM_BITS-1:1]              addr_bank_inc;\n   logic [pt.ICCM_BANK_HI : 2]           iccm_rd_addr_hi_q;\n   logic [pt.ICCM_BANK_HI : 1]           iccm_rd_addr_lo_q;\n   logic             [63:0]              iccm_rd_data_pre;\n   logic             [63:0]              iccm_data;\n   logic [1:0]                           addr_incr;\n   logic [pt.ICCM_NUM_BANKS-1:0] [38:0]  iccm_bank_wr_data_vec;\n\n   // logic to handle hard persisten faults\n   logic [1:0] [pt.ICCM_BITS-1:2]        redundant_address;\n   logic [1:0] [38:0]                    redundant_data;\n   logic [1:0]                           redundant_valid;\n   logic [pt.ICCM_NUM_BANKS-1:0]         sel_red1, sel_red0, sel_red1_q, sel_red0_q;\n\n\n   logic [38:0]                          redundant_data0_in, redundant_data1_in;\n   logic                                 redundant_lru, redundant_lru_in, redundant_lru_en;\n   logic                                 redundant_data0_en;\n   logic                                 redundant_data1_en;\n   logic                                 r0_addr_en, r1_addr_en;\n\n   // Testing persistent flip\n   //   logic [3:0]                              not_iccm_bank_dout;\n   //   logic [15:3]                     ecc_insert_flip_in, ecc_insert_flip;\n   //   logic                                 flip_en, flip_match, flip_match_q;\n   //\n   //   assign      flip_in = (iccm_rw_addr[3:2] != 2'b00);    // dont flip when bank0 - this is to make some progress in DMA streaming cases\n   //   assign      flip_en = iccm_rden;\n   //\n   //   rvdffs #(1) flipmatch  (.*,\n   //                   .clk(clk),\n   //                   .din(flip_in),\n   //                   .en(flip_en),\n   //                   .dout(flip_match_q));\n   //\n   // end of testing flip\n\n\n   assign addr_incr[1:0]                    = (iccm_wr_size[1:0] == 2'b11) ?  2'b10: 2'b01;\n   assign addr_bank_inc[pt.ICCM_BITS-1 : 1] = iccm_rw_addr[pt.ICCM_BITS-1 : 1] + addr_incr[1:0];\n\n   for (genvar i=0; i<pt.ICCM_NUM_BANKS/2; i++) begin: mem_bank_data\n      assign iccm_bank_wr_data_vec[(2*i)]   = iccm_wr_data[38:0];\n      assign iccm_bank_wr_data_vec[(2*i)+1] = iccm_wr_data[77:39];\n   end\n\n   for (genvar i=0; i<pt.ICCM_NUM_BANKS; i++) begin: mem_bank\n      assign wren_bank[i]         = iccm_wren & ((iccm_rw_addr[pt.ICCM_BANK_HI:2] == i) | (addr_bank_inc[pt.ICCM_BANK_HI:2] == i));\n      assign iccm_bank_wr_data[i] = iccm_bank_wr_data_vec[i];\n      assign rden_bank[i]         = iccm_rden & ( (iccm_rw_addr[pt.ICCM_BANK_HI:2] == i) | (addr_bank_inc[pt.ICCM_BANK_HI:2] == i));\n      assign iccm_clken[i]        =  wren_bank[i] | rden_bank[i] | clk_override;\n      assign addr_bank[i][pt.ICCM_BITS-1 : pt.ICCM_BANK_INDEX_LO] = wren_bank[i] ? iccm_rw_addr[pt.ICCM_BITS-1 : pt.ICCM_BANK_INDEX_LO] :\n                                                                                      ((addr_bank_inc[pt.ICCM_BANK_HI:2] == i) ?\n                                                                                                    addr_bank_inc[pt.ICCM_BITS-1 : pt.ICCM_BANK_INDEX_LO] :\n                                                                                                    iccm_rw_addr[pt.ICCM_BITS-1 : pt.ICCM_BANK_INDEX_LO]);\n\n    always_comb begin\n      iccm_mem_export.iccm_clken[i]        = iccm_clken[i];\n      iccm_mem_export.iccm_wren_bank[i]    = wren_bank[i];\n      iccm_mem_export.iccm_addr_bank[i]    = addr_bank[i];\n      iccm_mem_export.iccm_bank_wr_data[i] = iccm_bank_wr_data[i][31:0];\n      iccm_mem_export.iccm_bank_wr_ecc[i]  = iccm_bank_wr_data[i][38:32];\n      iccm_bank_dout[i][31:0]              = iccm_mem_export.iccm_bank_dout[i];\n      iccm_bank_dout[i][38:32]             = iccm_mem_export.iccm_bank_ecc[i];\n    end\n\n    // match the redundant rows\n    assign sel_red1[i]  = (redundant_valid[1]  & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[1][pt.ICCM_BITS-1:2]) & (iccm_rw_addr[3:2] == i)) |\n                                                 ((addr_bank_inc[pt.ICCM_BITS-1:2]== redundant_address[1][pt.ICCM_BITS-1:2]) & (addr_bank_inc[3:2] == i))));\n\n    assign sel_red0[i]  = (redundant_valid[0]  & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[0][pt.ICCM_BITS-1:2]) & (iccm_rw_addr[3:2] == i)) |\n                                                 ((addr_bank_inc[pt.ICCM_BITS-1:2]== redundant_address[0][pt.ICCM_BITS-1:2]) & (addr_bank_inc[3:2] == i))));\n\n   rvdff #(1) selred0  (.*,\n                   .clk(active_clk),\n                   .din(sel_red0[i]),\n                   .dout(sel_red0_q[i]));\n\n   rvdff #(1) selred1  (.*,\n                   .clk(active_clk),\n                   .din(sel_red1[i]),\n                   .dout(sel_red1_q[i]));\n\n\n  // muxing out the memory data with the redundant data if the address matches\n   assign iccm_bank_dout_fn[i][38:0] = ({39{sel_red1_q[i]}}                         & redundant_data[1][38:0]) |\n                                       ({39{sel_red0_q[i]}}                         & redundant_data[0][38:0]) |\n                                       ({39{~sel_red0_q[i] & ~sel_red1_q[i]}}       & iccm_bank_dout[i][38:0]);\n\n  end : mem_bank\n// This section does the redundancy for tolerating single bit errors\n// 2x 39 bit data values with address[hi:2] and a valid bit is needed to CAM and sub out the reads/writes to the particular locations\n// Also a LRU flop is kept to decide which of the redundant element to replace.\n   assign r0_addr_en              = ~redundant_lru & iccm_buf_correct_ecc;\n   assign r1_addr_en              = redundant_lru  & iccm_buf_correct_ecc;\n   assign redundant_lru_en         = iccm_buf_correct_ecc | (((|sel_red0[pt.ICCM_NUM_BANKS-1:0]) | (|sel_red1[pt.ICCM_NUM_BANKS-1:0])) & iccm_rden & iccm_correction_state);\n   assign redundant_lru_in        = iccm_buf_correct_ecc ? ~redundant_lru : (|sel_red0[pt.ICCM_NUM_BANKS-1:0]) ? 1'b1 : 1'b0;\n\n   rvdffs #() red_lru  (.*,                               // LRU flop for the redundant replacements\n                   .clk(active_clk),\n                   .en(redundant_lru_en),\n                   .din(redundant_lru_in),\n                   .dout(redundant_lru));\n\n    rvdffs #(pt.ICCM_BITS-2) r0_address  (.*,                 // Redundant Row 0 address\n                   .clk(active_clk),\n                   .en(r0_addr_en),\n                   .din(iccm_rw_addr[pt.ICCM_BITS-1:2]),\n                   .dout(redundant_address[0][pt.ICCM_BITS-1:2]));\n\n   rvdffs #(pt.ICCM_BITS-2) r1_address  (.*,                   // Redundant Row 0 address\n                   .clk(active_clk),\n                   .en(r1_addr_en),\n                   .din(iccm_rw_addr[pt.ICCM_BITS-1:2]),\n                   .dout(redundant_address[1][pt.ICCM_BITS-1:2]));\n\n    rvdffs #(1) r0_valid  (.*,\n                   .clk(active_clk),                                  // Redundant Row 0 Valid\n                   .en(r0_addr_en),\n                   .din(1'b1),\n                   .dout(redundant_valid[0]));\n\n   rvdffs #(1) r1_valid  (.*,                                   // Redundant Row 1 Valid\n                   .clk(active_clk),\n                   .en(r1_addr_en),\n                   .din(1'b1),\n                   .dout(redundant_valid[1]));\n\n\n\n   // We will have to update the Redundant copies in addition to the memory on subsequent writes to this memory location.\n   // The data gets updated on : 1) correction cycle, 2) Future writes - this could be W writes from DMA ( match up till addr[2]) or DW writes ( match till address[3])\n   // The data to pick also depends on the current address[2], size and the addr[2] stored in the address field of the redundant flop. Correction cycle is always W write and the data is splat on both legs, so choosing lower Word\n\n    assign redundant_data0_en      = ((iccm_rw_addr[pt.ICCM_BITS-1:3] == redundant_address[0][pt.ICCM_BITS-1:3]) & ((iccm_rw_addr[2] == redundant_address[0][2]) | (iccm_wr_size[1:0] == 2'b11)) & redundant_valid[0] & iccm_wren) |\n                                      (~redundant_lru & iccm_buf_correct_ecc);\n\n    assign redundant_data0_in[38:0] = (((iccm_rw_addr[2] == redundant_address[0][2]) & iccm_rw_addr[2]) | (redundant_address[0][2] & (iccm_wr_size[1:0] == 2'b11))) ? iccm_wr_data[77:39]  : iccm_wr_data[38:0];\n\n    rvdffs #(39) r0_data  (.*,                                 // Redundant Row 1 data\n                   .clk(active_clk),\n                   .en(redundant_data0_en),\n                   .din(redundant_data0_in[38:0]),\n                   .dout(redundant_data[0][38:0]));\n\n   assign redundant_data1_en      =  ((iccm_rw_addr[pt.ICCM_BITS-1:3] == redundant_address[1][pt.ICCM_BITS-1:3]) & ((iccm_rw_addr[2] == redundant_address[1][2]) | (iccm_wr_size[1:0] == 2'b11)) & redundant_valid[1] & iccm_wren) |\n                                     (redundant_lru & iccm_buf_correct_ecc);\n\n   assign redundant_data1_in[38:0] = (((iccm_rw_addr[2] == redundant_address[1][2]) & iccm_rw_addr[2]) | (redundant_address[1][2] & (iccm_wr_size[1:0] == 2'b11))) ? iccm_wr_data[77:39]  : iccm_wr_data[38:0];\n\n    rvdffs #(39) r1_data  (.*,                                  // Redundant Row 1 data\n                   .clk(active_clk),\n                   .en(redundant_data1_en),\n                   .din(redundant_data1_in[38:0]),\n                   .dout(redundant_data[1][38:0]));\n\n\n   rvdffs  #(pt.ICCM_BANK_HI)   rd_addr_lo_ff (.*, .clk(active_clk), .din(iccm_rw_addr [pt.ICCM_BANK_HI:1]), .dout(iccm_rd_addr_lo_q[pt.ICCM_BANK_HI:1]), .en(1'b1));   // bit 0 of address is always 0\n   rvdffs  #(pt.ICCM_BANK_BITS) rd_addr_hi_ff (.*, .clk(active_clk), .din(addr_bank_inc[pt.ICCM_BANK_HI:2]), .dout(iccm_rd_addr_hi_q[pt.ICCM_BANK_HI:2]), .en(1'b1));\n\n   assign iccm_rd_data_pre[63:0] = {iccm_bank_dout_fn[iccm_rd_addr_hi_q][31:0], iccm_bank_dout_fn[iccm_rd_addr_lo_q[pt.ICCM_BANK_HI:2]][31:0]};\n   assign iccm_data[63:0]        = 64'({16'b0, (iccm_rd_data_pre[63:0] >> (16*iccm_rd_addr_lo_q[1]))});\n   assign iccm_rd_data[63:0]     = {iccm_data[63:0]};\n   assign iccm_rd_data_ecc[77:0] = {iccm_bank_dout_fn[iccm_rd_addr_hi_q][38:0], iccm_bank_dout_fn[iccm_rd_addr_lo_q[pt.ICCM_BANK_HI:2]][38:0]};\n\nendmodule // el2_ifu_iccm_mem\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n////////////////////////////////////////////////////\n//   ICACHE DATA & TAG MODULE WRAPPER              //\n/////////////////////////////////////////////////////\nmodule el2_ifu_ic_mem\nimport el2_pkg::*;\n #(\n`include \"el2_param.vh\"\n )\n  (\n      input logic                                   clk,                // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n      input logic                                   active_clk,         // Clock only while core active.  Through two clock headers. For flops without second clock header built in.\n      input logic                                   rst_l,              // reset, active low\n      input logic                                   clk_override,       // Override non-functional clock gating\n      input logic                                   dec_tlu_core_ecc_disable,  // Disable ECC checking\n\n      input logic [31:1]                            ic_rw_addr,\n      input logic [pt.ICACHE_NUM_WAYS-1:0]          ic_wr_en  ,         // Which way to write\n      input logic                                   ic_rd_en  ,         // Read enable\n      input logic [pt.ICACHE_INDEX_HI:3]            ic_debug_addr,      // Read/Write addresss to the Icache.\n      input logic                                   ic_debug_rd_en,     // Icache debug rd\n      input logic                                   ic_debug_wr_en,     // Icache debug wr\n      input logic                                   ic_debug_tag_array, // Debug tag array\n      input logic [pt.ICACHE_NUM_WAYS-1:0]          ic_debug_way,       // Debug way. Rd or Wr.\n      input logic [63:0]                            ic_premux_data,     // Premux data to be muxed with each way of the Icache.\n      input logic                                   ic_sel_premux_data, // Select the pre_muxed data\n\n      input  logic [pt.ICACHE_BANKS_WAY-1:0][70:0]  ic_wr_data,         // Data to fill to the Icache. With ECC\n      output logic [63:0]                           ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n      output logic [70:0]                           ic_debug_rd_data ,  // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n      output logic [25:0]                           ictag_debug_rd_data,// Debug icache tag.\n      input logic  [70:0]                           ic_debug_wr_data,   // Debug wr cache.\n\n      output logic [pt.ICACHE_BANKS_WAY-1:0]        ic_eccerr,          // ecc error per bank\n      output logic [pt.ICACHE_BANKS_WAY-1:0]        ic_parerr,          // ecc error per bank\n      input logic [pt.ICACHE_NUM_WAYS-1:0]          ic_tag_valid,       // Valid from the I$ tag valid outside (in flops).\n      input el2_ic_data_ext_in_pkt_t [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] ic_data_ext_in_pkt,   // this is being driven by the top level for soc testing/etc\n      input el2_ic_tag_ext_in_pkt_t  [pt.ICACHE_NUM_WAYS-1:0]                          ic_tag_ext_in_pkt,    // this is being driven by the top level for soc testing/etc\n\n      output logic [pt.ICACHE_NUM_WAYS-1:0]         ic_rd_hit,          // ic_rd_hit[3:0]\n      output logic                                  ic_tag_perr,        // Tag Parity error\n      input  logic                                  scan_mode           // Flop scan mode control\n      ) ;\n\n\n\n\n   EL2_IC_TAG #(.pt(pt)) ic_tag_inst\n          (\n           .*,\n           .ic_wr_en     (ic_wr_en[pt.ICACHE_NUM_WAYS-1:0]),\n           .ic_debug_addr(ic_debug_addr[pt.ICACHE_INDEX_HI:3]),\n           .ic_rw_addr   (ic_rw_addr[31:3])\n           ) ;\n\n   EL2_IC_DATA #(.pt(pt)) ic_data_inst\n          (\n           .*,\n           .ic_wr_en     (ic_wr_en[pt.ICACHE_NUM_WAYS-1:0]),\n           .ic_debug_addr(ic_debug_addr[pt.ICACHE_INDEX_HI:3]),\n           .ic_rw_addr   (ic_rw_addr[31:1])\n           ) ;\n\n endmodule\n\n\n/////////////////////////////////////////////////\n////// ICACHE DATA MODULE    ////////////////////\n/////////////////////////////////////////////////\nmodule EL2_IC_DATA\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n     (\n      input logic clk,\n      input logic active_clk,\n      input logic rst_l,\n      input logic clk_override,\n\n      input logic [31:1]                  ic_rw_addr,\n      input logic [pt.ICACHE_NUM_WAYS-1:0]ic_wr_en,\n      input logic                          ic_rd_en,           // Read enable\n\n      input  logic [pt.ICACHE_BANKS_WAY-1:0][70:0]    ic_wr_data,         // Data to fill to the Icache. With ECC\n      output logic [63:0]                             ic_rd_data ,                                 // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n      input  logic [70:0]                             ic_debug_wr_data,   // Debug wr cache.\n      output logic [70:0]                             ic_debug_rd_data ,  // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n      output logic [pt.ICACHE_BANKS_WAY-1:0] ic_parerr,\n      output logic [pt.ICACHE_BANKS_WAY-1:0] ic_eccerr,    // ecc error per bank\n      input logic [pt.ICACHE_INDEX_HI:3]     ic_debug_addr,     // Read/Write addresss to the Icache.\n      input logic                            ic_debug_rd_en,      // Icache debug rd\n      input logic                            ic_debug_wr_en,      // Icache debug wr\n      input logic                            ic_debug_tag_array,  // Debug tag array\n      input logic [pt.ICACHE_NUM_WAYS-1:0]   ic_debug_way,        // Debug way. Rd or Wr.\n      input logic [63:0]                     ic_premux_data,      // Premux data to be muxed with each way of the Icache.\n      input logic                            ic_sel_premux_data,  // Select the pre_muxed data\n\n      input logic [pt.ICACHE_NUM_WAYS-1:0]ic_rd_hit,\n      input el2_ic_data_ext_in_pkt_t  [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] ic_data_ext_in_pkt,   // this is being driven by the top level for soc testing/etc\n      input  logic                         scan_mode\n\n      ) ;\n\n   logic [pt.ICACHE_TAG_INDEX_LO-1:1]                                             ic_rw_addr_ff;\n   logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_WAYS-1:0]                        ic_b_sb_wren;    //bank x ways\n   logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_WAYS-1:0]                        ic_b_sb_rden;    //bank x ways\n\n\n   logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_rden;       //bank\n   logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_rden_ff;    //bank\n   logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_debug_sel_sb;\n\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][70:0]                  wb_dout ;       //  ways x bank\n   logic [pt.ICACHE_BANKS_WAY-1:0][70:0]                                          ic_sb_wr_data, ic_bank_wr_data, wb_dout_ecc_bank;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [141:0]                                         wb_dout_way_pre;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [63:0]                                          wb_dout_way, wb_dout_way_with_premux;\n   logic [141:0]                                                                  wb_dout_ecc;\n\n   logic [pt.ICACHE_BANKS_WAY-1:0]                                                bank_check_en;\n\n   logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_WAYS-1:0]                        ic_bank_way_clken;\n   logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_bank_way_clken_final;\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                        ic_bank_way_clken_final_up;\n\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                                 ic_debug_rd_way_en;    // debug wr_way\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                                 ic_debug_rd_way_en_ff; // debug wr_way\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                                 ic_debug_wr_way_en;    // debug wr_way\n   logic [pt.ICACHE_INDEX_HI:1]                                                   ic_rw_addr_q;\n\n   logic [pt.ICACHE_BANKS_WAY-1:0]       [pt.ICACHE_INDEX_HI : pt.ICACHE_DATA_INDEX_LO] ic_rw_addr_bank_q;\n\n   logic [pt.ICACHE_TAG_LO-1 : pt.ICACHE_DATA_INDEX_LO]                           ic_rw_addr_q_inc;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                                 ic_rd_hit_q;\n\n\n\n      logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_sram_en;\n      logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_read_en;\n      logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_write_en;\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0] [31 : pt.ICACHE_DATA_INDEX_LO]  wb_index_hold;\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 write_bypass_en;     //bank\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 write_bypass_en_ff;  //bank\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 index_valid;  //bank\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 ic_b_clear_en;\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 ic_b_addr_match;\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 ic_b_addr_match_index_only;\n\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_sram_en_up;\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_read_en_up;\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_write_en_up;\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0] [31 : pt.ICACHE_DATA_INDEX_LO]  wb_index_hold_up;\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 write_bypass_en_up;     //bank\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 write_bypass_en_ff_up;  //bank\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 index_valid_up;  //bank\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 ic_b_clear_en_up;\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 ic_b_addr_match_up;\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 ic_b_addr_match_index_only_up;\n\n\n   logic [pt.ICACHE_BANKS_WAY-1:0]                 [31 : pt.ICACHE_DATA_INDEX_LO] ic_b_rw_addr;\n   logic [pt.ICACHE_BANKS_WAY-1:0]                 [31 : pt.ICACHE_DATA_INDEX_LO] ic_b_rw_addr_index_only;\n\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                 [31 : pt.ICACHE_DATA_INDEX_LO] ic_b_rw_addr_up;\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                 [31 : pt.ICACHE_DATA_INDEX_LO] ic_b_rw_addr_index_only_up;\n\n\n\n   logic                                                                          ic_rd_en_with_debug;\n   logic                                                                          ic_rw_addr_wrap, ic_cacheline_wrap_ff;\n   logic                                                                          ic_debug_rd_en_ff;\n\n\n//-----------------------------------------------------------\n// ----------- Logic section starts here --------------------\n//-----------------------------------------------------------\n   assign  ic_debug_rd_way_en[pt.ICACHE_NUM_WAYS-1:0] =  {pt.ICACHE_NUM_WAYS{ic_debug_rd_en & ~ic_debug_tag_array}} & ic_debug_way[pt.ICACHE_NUM_WAYS-1:0] ;\n   assign  ic_debug_wr_way_en[pt.ICACHE_NUM_WAYS-1:0] =  {pt.ICACHE_NUM_WAYS{ic_debug_wr_en & ~ic_debug_tag_array}} & ic_debug_way[pt.ICACHE_NUM_WAYS-1:0] ;\n\n   logic end_of_cache_line;\n   assign end_of_cache_line = (pt.ICACHE_LN_SZ==7'h40) ? (&ic_rw_addr_q[5:4]) : ic_rw_addr_q[4];\n   always_comb begin : clkens\n      ic_bank_way_clken  = '0;\n\n      for ( int i=0; i<pt.ICACHE_BANKS_WAY; i++) begin: wr_ens\n       ic_b_sb_wren[i]        =  ic_wr_en[pt.ICACHE_NUM_WAYS-1:0]  |\n                                       (ic_debug_wr_way_en[pt.ICACHE_NUM_WAYS-1:0] & {pt.ICACHE_NUM_WAYS{ic_debug_addr[pt.ICACHE_BANK_HI : pt.ICACHE_BANK_LO] == i}}) ;\n       ic_debug_sel_sb[i]     = (ic_debug_addr[pt.ICACHE_BANK_HI : pt.ICACHE_BANK_LO] == i );\n       ic_sb_wr_data[i]       = (ic_debug_sel_sb[i] & ic_debug_wr_en) ? ic_debug_wr_data : ic_bank_wr_data[i] ;\n       ic_b_rden[i]           =  ic_rd_en_with_debug & ( ( ~ic_rw_addr_q[pt.ICACHE_BANK_HI] & (i==0)) |\n                                                        (( ic_rw_addr_q[pt.ICACHE_BANK_HI] & ic_rw_addr_q[2:1] == 2'b11) & (i==0) & ~end_of_cache_line) |\n                                                         (  ic_rw_addr_q[pt.ICACHE_BANK_HI] & (i==1)) |\n                                                         ((~ic_rw_addr_q[pt.ICACHE_BANK_HI] & ic_rw_addr_q[2:1] == 2'b11) & (i==1)) ) ;\n\n\n\n       ic_b_sb_rden[i]        =  {pt.ICACHE_NUM_WAYS{ic_b_rden[i]}}   ;\n\n       for ( int j=0; j<pt.ICACHE_NUM_WAYS; j++) begin: way_clkens\n         ic_bank_way_clken[i][j] |= ic_b_sb_rden[i][j] | clk_override | ic_b_sb_wren[i][j];\n       end\n     end // block: wr_ens\n   end // block: clkens\n\n// bank read enables\n  assign ic_rd_en_with_debug                          = (ic_rd_en   | ic_debug_rd_en ) & ~(|ic_wr_en);\n  assign ic_rw_addr_q[pt.ICACHE_INDEX_HI:1] = (ic_debug_rd_en | ic_debug_wr_en) ?\n                                              {ic_debug_addr[pt.ICACHE_INDEX_HI:3],2'b0} :\n                                              ic_rw_addr[pt.ICACHE_INDEX_HI:1] ;\n\n   assign ic_rw_addr_q_inc[pt.ICACHE_TAG_LO-1:pt.ICACHE_DATA_INDEX_LO] = ic_rw_addr_q[pt.ICACHE_TAG_LO-1 : pt.ICACHE_DATA_INDEX_LO] + 1 ;\n   assign ic_rw_addr_wrap                                        = ic_rw_addr_q[pt.ICACHE_BANK_HI] & (ic_rw_addr_q[2:1] == 2'b11) & ic_rd_en_with_debug & ~(|ic_wr_en[pt.ICACHE_NUM_WAYS-1:0]);\n   assign ic_cacheline_wrap_ff                                   = ic_rw_addr_ff[pt.ICACHE_TAG_INDEX_LO-1:pt.ICACHE_BANK_LO] == {(pt.ICACHE_TAG_INDEX_LO - pt.ICACHE_BANK_LO){1'b1}};\n\n\n   assign ic_rw_addr_bank_q[0] = ~ic_rw_addr_wrap ? ic_rw_addr_q[pt.ICACHE_INDEX_HI:pt.ICACHE_DATA_INDEX_LO] : {ic_rw_addr_q[pt.ICACHE_INDEX_HI: pt.ICACHE_TAG_INDEX_LO] , ic_rw_addr_q_inc[pt.ICACHE_TAG_INDEX_LO-1: pt.ICACHE_DATA_INDEX_LO] } ;\n   assign ic_rw_addr_bank_q[1] = ic_rw_addr_q[pt.ICACHE_INDEX_HI:pt.ICACHE_DATA_INDEX_LO];\n\n\n   rvdffie #(.WIDTH(int'(pt.ICACHE_TAG_INDEX_LO+pt.ICACHE_BANKS_WAY+pt.ICACHE_NUM_WAYS)),.OVERRIDE(1)) miscff\n            (.*,\n             .din({ ic_b_rden[pt.ICACHE_BANKS_WAY-1:0],   ic_rw_addr_q[pt.ICACHE_TAG_INDEX_LO-1:1], ic_debug_rd_way_en[pt.ICACHE_NUM_WAYS-1:0],   ic_debug_rd_en}),\n             .dout({ic_b_rden_ff[pt.ICACHE_BANKS_WAY-1:0],ic_rw_addr_ff[pt.ICACHE_TAG_INDEX_LO-1:1],ic_debug_rd_way_en_ff[pt.ICACHE_NUM_WAYS-1:0],ic_debug_rd_en_ff})\n             );\n\n if (pt.ICACHE_WAYPACK == 0 ) begin : PACKED_0\n\n\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS_WIDTH-1:0] wrptr_up;\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS_WIDTH-1:0] wrptr_in_up;\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]       sel_bypass_up;\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]       sel_bypass_ff_up;\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][(71*pt.ICACHE_NUM_WAYS)-1:0]    sel_bypass_data_up;\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                                 any_bypass_up;\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                                 any_addr_match_up;\n\n`define EL2_IC_DATA_SRAM(depth,width)                                                                               \\\n           ram_``depth``x``width ic_bank_sb_way_data (                                                               \\\n                                     .ME(ic_bank_way_clken_final_up[i][k]),                                          \\\n                                     .WE (ic_b_sb_wren[k][i]),                                                       \\\n                                     .D  (ic_sb_wr_data[k][``width-1:0]),                                            \\\n                                     .ADR(ic_rw_addr_bank_q[k][pt.ICACHE_INDEX_HI:pt.ICACHE_DATA_INDEX_LO]),         \\\n                                     .Q  (wb_dout_pre_up[i][k]),                                                     \\\n                                     .CLK (clk),                                                                     \\\n                                     .ROP ( ),                                                                       \\\n                                     .TEST1(ic_data_ext_in_pkt[i][k].TEST1),                                         \\\n                                     .RME(ic_data_ext_in_pkt[i][k].RME),                                             \\\n                                     .RM(ic_data_ext_in_pkt[i][k].RM),                                               \\\n                                                                                                                     \\\n                                     .LS(ic_data_ext_in_pkt[i][k].LS),                                               \\\n                                     .DS(ic_data_ext_in_pkt[i][k].DS),                                               \\\n                                     .SD(ic_data_ext_in_pkt[i][k].SD),                                               \\\n                                                                                                                     \\\n                                     .TEST_RNM(ic_data_ext_in_pkt[i][k].TEST_RNM),                                   \\\n                                     .BC1(ic_data_ext_in_pkt[i][k].BC1),                                             \\\n                                     .BC2(ic_data_ext_in_pkt[i][k].BC2)                                              \\\n                                    );  \\\nif (pt.ICACHE_BYPASS_ENABLE == 1) begin \\\n                 assign wrptr_in_up[i][k] = (wrptr_up[i][k] == (pt.ICACHE_NUM_BYPASS-1)) ? '0 : (wrptr_up[i][k] + 1'd1);                                    \\\n                 rvdffs  #(pt.ICACHE_NUM_BYPASS_WIDTH)  wrptr_ff(.*, .clk(active_clk),  .en(|write_bypass_en_up[i][k]), .din (wrptr_in_up[i][k]), .dout(wrptr_up[i][k])) ;     \\\n                 assign ic_b_sram_en_up[i][k]              = ic_bank_way_clken[k][i];                             \\\n                 as"}
{"text": "sign ic_b_read_en_up[i][k]              =  ic_b_sram_en_up[i][k] &   ic_b_sb_rden[k][i];       \\\n                 assign ic_b_write_en_up[i][k]             =  ic_b_sram_en_up[i][k] &   ic_b_sb_wren[k][i];       \\\n                 assign ic_bank_way_clken_final_up[i][k]   =  ic_b_sram_en_up[i][k] &    ~(|sel_bypass_up[i][k]); \\\n                 assign ic_b_rw_addr_up[i][k] = {ic_rw_addr[31:pt.ICACHE_INDEX_HI+1],ic_rw_addr_bank_q[k]};       \\\n                 assign ic_b_rw_addr_index_only_up[i][k] = ic_rw_addr_bank_q[k];                                  \\\n                 always_comb begin                                                                                \\\n                    any_addr_match_up[i][k] = '0;                                                                 \\\n                    for (int l=0; l<pt.ICACHE_NUM_BYPASS; l++) begin                                              \\\n                       any_addr_match_up[i][k] |= ic_b_addr_match_up[i][k][l];                                    \\\n                    end                                                                                           \\\n                 end                                                                                              \\\n                // it is an error to ever have 2 entries with the same index and both valid                       \\\n                for (genvar l=0; l<pt.ICACHE_NUM_BYPASS; l++) begin: BYPASS                                       \\\n                   // full match up to bit 31                                                                     \\\n                   assign ic_b_addr_match_up[i][k][l] = (wb_index_hold_up[i][k][l] ==  ic_b_rw_addr_up[i][k]) & index_valid_up[i][k][l];            \\\n                   assign ic_b_addr_match_index_only_up[i][k][l] = (wb_index_hold_up[i][k][l][pt.ICACHE_INDEX_HI:pt.ICACHE_DATA_INDEX_LO] ==  ic_b_rw_addr_index_only_up[i][k]) & index_valid_up[i][k][l];            \\\n                                                                                                                                                    \\\n                   assign ic_b_clear_en_up[i][k][l]   = ic_b_write_en_up[i][k] &   ic_b_addr_match_index_only_up[i][k][l];                                     \\\n                                                                                                                                                    \\\n                   assign sel_bypass_up[i][k][l]      = ic_b_read_en_up[i][k]  &   ic_b_addr_match_up[i][k][l] ;                                    \\\n                                                                                                                                                    \\\n                   assign write_bypass_en_up[i][k][l] = ic_b_read_en_up[i][k]  &  ~any_addr_match_up[i][k] & (wrptr_up[i][k] == l);                 \\\n                                                                                                                                                    \\\n                   rvdff  #(1)  write_bypass_ff (.*, .clk(active_clk),                                                                 .din(write_bypass_en_up[i][k][l]), .dout(write_bypass_en_ff_up[i][k][l])) ; \\\n                   rvdffs #(1)  index_val_ff    (.*, .clk(active_clk), .en(write_bypass_en_up[i][k][l] | ic_b_clear_en_up[i][k][l]),   .din(~ic_b_clear_en_up[i][k][l]),  .dout(index_valid_up[i][k][l])) ;       \\\n                   rvdff  #(1)  sel_hold_ff     (.*, .clk(active_clk),                                                                 .din(sel_bypass_up[i][k][l]),      .dout(sel_bypass_ff_up[i][k][l])) ;     \\\n                   rvdffe #((31-pt.ICACHE_DATA_INDEX_LO+1)) ic_addr_index    (.*, .en(write_bypass_en_up[i][k][l]),    .din (ic_b_rw_addr_up[i][k]), .dout(wb_index_hold_up[i][k][l]));         \\\n                   rvdffe #(``width)                             rd_data_hold_ff  (.*, .en(write_bypass_en_ff_up[i][k][l]), .din (wb_dout_pre_up[i][k]),  .dout(wb_dout_hold_up[i][k][l]));     \\\n                end                                                                                                                       \\\n                always_comb begin                                                                                                         \\\n                 any_bypass_up[i][k] = '0;                                                                                                \\\n                 sel_bypass_data_up[i][k] = '0;                                                                                           \\\n                 for (int l=0; l<pt.ICACHE_NUM_BYPASS; l++) begin                                                                         \\\n                    any_bypass_up[i][k]      |=  sel_bypass_ff_up[i][k][l];                                                               \\\n                    sel_bypass_data_up[i][k] |= (sel_bypass_ff_up[i][k][l]) ? wb_dout_hold_up[i][k][l] : '0;                              \\\n                 end                                                                                                                      \\\n                 wb_dout[i][k]   =   any_bypass_up[i][k] ?  sel_bypass_data_up[i][k] :  wb_dout_pre_up[i][k] ;                            \\\n                 end                                                                                                                      \\\n             end                                                                                                                          \\\n             else begin                                                                                                                   \\\n                 assign wb_dout[i][k]                      =   wb_dout_pre_up[i][k] ;                                                     \\\n                 assign ic_bank_way_clken_final_up[i][k]   =  ic_bank_way_clken[k][i];                                                    \\\n             end\n\n\n   for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: WAYS\n      for (genvar k=0; k<pt.ICACHE_BANKS_WAY; k++) begin: BANKS_WAY   // 16B subbank\n      if (pt.ICACHE_ECC) begin : ECC1\n        logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] [71-1:0]        wb_dout_pre_up;           // data and its bit enables\n        logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] [pt.ICACHE_NUM_BYPASS-1:0] [71-1:0]  wb_dout_hold_up;\n\n        if ($clog2(pt.ICACHE_DATA_DEPTH) == 13 )   begin : size_8192\n           `EL2_IC_DATA_SRAM(8192,71)\n        end\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 12 )   begin : size_4096\n           `EL2_IC_DATA_SRAM(4096,71)\n        end\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 11 ) begin : size_2048\n           `EL2_IC_DATA_SRAM(2048,71)\n        end\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 10 ) begin : size_1024\n           `EL2_IC_DATA_SRAM(1024,71)\n        end\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 9 ) begin : size_512\n           `EL2_IC_DATA_SRAM(512,71)\n        end\n         else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 8 ) begin : size_256\n           `EL2_IC_DATA_SRAM(256,71)\n         end\n         else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 7 ) begin : size_128\n           `EL2_IC_DATA_SRAM(128,71)\n         end\n         else  begin : size_64\n           `EL2_IC_DATA_SRAM(64,71)\n         end\n      end // if (pt.ICACHE_ECC)\n\n     else  begin  : ECC0\n        logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] [68-1:0]        wb_dout_pre_up;           // data and its bit enables\n        logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] [pt.ICACHE_NUM_BYPASS-1:0] [68-1:0]  wb_dout_hold_up;\n        if ($clog2(pt.ICACHE_DATA_DEPTH) == 13 )   begin : size_8192\n           `EL2_IC_DATA_SRAM(8192,68)\n        end\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 12 )   begin : size_4096\n           `EL2_IC_DATA_SRAM(4096,68)\n        end\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 11 ) begin : size_2048\n           `EL2_IC_DATA_SRAM(2048,68)\n        end\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 10 ) begin : size_1024\n           `EL2_IC_DATA_SRAM(1024,68)\n        end\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 9 ) begin : size_512\n           `EL2_IC_DATA_SRAM(512,68)\n        end\n         else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 8 ) begin : size_256\n           `EL2_IC_DATA_SRAM(256,68)\n         end\n         else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 7 ) begin : size_128\n           `EL2_IC_DATA_SRAM(128,68)\n         end\n         else  begin : size_64\n           `EL2_IC_DATA_SRAM(64,68)\n         end\n      end // else: !if(pt.ICACHE_ECC)\n      end // block: BANKS_WAY\n   end // block: WAYS\n\n end // block: PACKED_0\n\n // WAY PACKED\n else begin : PACKED_1\n\n    logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS_WIDTH-1:0] wrptr;\n    logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS_WIDTH-1:0] wrptr_in;\n    logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                       sel_bypass;\n    logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                       sel_bypass_ff;\n\n\n    logic [pt.ICACHE_BANKS_WAY-1:0][(71*pt.ICACHE_NUM_WAYS)-1:0]  sel_bypass_data;\n    logic [pt.ICACHE_BANKS_WAY-1:0]                               any_bypass;\n    logic [pt.ICACHE_BANKS_WAY-1:0]                               any_addr_match;\n\n\n// SRAM macros\n\n`define EL2_PACKED_IC_DATA_SRAM(depth,width,waywidth)                                                                                                 \\\n            ram_be_``depth``x``width  ic_bank_sb_way_data (                                                                                           \\\n                            .CLK   (clk),                                                                                                             \\\n                            .WE    (|ic_b_sb_wren[k]),                                                    // OR of all the ways in the bank           \\\n                            .WEM   (ic_b_sb_bit_en_vec[k]),                                               // 284 bits of bit enables                  \\\n                            .D     ({pt.ICACHE_NUM_WAYS{ic_sb_wr_data[k][``waywidth-1:0]}}),                                                          \\\n                            .ADR   (ic_rw_addr_bank_q[k][pt.ICACHE_INDEX_HI:pt.ICACHE_DATA_INDEX_LO]),                                                \\\n                            .Q     (wb_packeddout_pre[k]),                                                                                            \\\n                            .ME    (|ic_bank_way_clken_final[k]),                                                                                     \\\n                            .ROP   ( ),                                                                                                               \\\n                            .TEST1  (ic_data_ext_in_pkt[0][k].TEST1),                                                                                 \\\n                            .RME   (ic_data_ext_in_pkt[0][k].RME),                                                                                    \\\n                            .RM    (ic_data_ext_in_pkt[0][k].RM),                                                                                     \\\n                                                                                                                                                      \\\n                            .LS    (ic_data_ext_in_pkt[0][k].LS),                                                                                     \\\n                            .DS    (ic_data_ext_in_pkt[0][k].DS),                                                                                     \\\n                            .SD    (ic_data_ext_in_pkt[0][k].SD),                                                                                     \\\n                                                                                                                                                      \\\n                            .TEST_RNM (ic_data_ext_in_pkt[0][k].TEST_RNM),                                                                            \\\n                            .BC1      (ic_data_ext_in_pkt[0][k].BC1),                                                                                 \\\n                            .BC2      (ic_data_ext_in_pkt[0][k].BC2)                                                                                  \\\n                           );                                                                                                                         \\\n                                                                                                                                                      \\\n              if (pt.ICACHE_BYPASS_ENABLE == 1) begin                                                                                                                                                 \\\n                                                                                                                                                                                                      \\\n                 assign wrptr_in[k] = (wrptr[k] == (pt.ICACHE_NUM_BYPASS-1)) ? '0 : (wrptr[k] + 1'd1);                                                                                                \\\n                                                                                                                                                                                                      \\\n                 rvdffs  #(pt.ICACHE_NUM_BYPASS_WIDTH)  wrptr_ff(.*, .clk(active_clk), .en(|write_bypass_en[k]), .din (wrptr_in[k]), .dout(wrptr[k])) ;                                                                       \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_sram_en[k]              = |ic_bank_way_clken[k];                                                                                                                         \\\n                                                                                                                                                                                                      \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_read_en[k]              =  ic_b_sram_en[k]  &  (|ic_b_sb_rden[k]) ;                                                                                                              \\\n                 assign ic_b_write_en[k]             =  ic_b_sram_en[k] &   (|ic_b_sb_wren[k]);                                                                                                       \\\n                 assign ic_bank_way_clken_final[k]   =  ic_b_sram_en[k] &    ~(|sel_bypass[k]);                                                                                                       \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_rw_addr[k] = {ic_rw_addr[31:pt.ICACHE_INDEX_HI+1],ic_rw_addr_bank_q[k]};                                                                                                 \\\n                 assign ic_b_rw_addr_index_only[k] = ic_rw_addr_bank_q[k];                                                                                                    \\\n                                                                                                                                                                                                      \\\n                 always_comb begin                                                                                                                                                                    \\\n                    any_addr_match[k] = '0;                                                                                                                                                           \\\n                                                                                                                                                                                                      \\\n                    for (int l=0; l<pt.ICACHE_NUM_BYPASS; l++) begin                                                                                                                                  \\\n                       any_addr_match[k] |= ic_b_addr_match[k][l];                                                                                                                                    \\\n                    end                                                                                                                                                                               \\\n                 end                                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                // it is an error to ever have 2 entries with the same index and both valid                                                                                                           \\\n                for (genvar l=0; l<pt.ICACHE_NUM_BYPASS; l++) begin: BYPASS                                                                                                                           \\\n                                                                                                                                                                                                      \\\n                   // full match up to bit 31                                                                                                                                                         \\\n                   assign ic_b_addr_match[k][l] = (wb_index_hold[k][l] ==  ic_b_rw_addr[k]) & index_valid[k][l];                                                                                      \\\n                   assign ic_b_addr_match_index_only[k][l] = (wb_index_hold[k][l][pt.ICACHE_INDEX_HI:pt.ICACHE_DATA_INDEX_LO] ==  ic_b_rw_addr_index_only[k]) & index_valid[k][l];                    \\\n                                                                                                                                                                                                      \\\n                   assign ic_b_clear_en[k][l]   = ic_b_write_en[k] &   ic_b_addr_match_index_only[k][l];                                                                                                              \\\n                                                                                                                                                                                                      \\\n                   assign sel_bypass[k][l]      = ic_b_read_en[k]  &   ic_b_addr_match[k][l] ;                                                                                                        \\\n                                                                                                                                                                                                      \\\n                   assign write_bypass_en[k][l] = ic_b_read_en[k]  & "}
{"text": " ~any_addr_match[k] & (wrptr[k] == l);                                                                                           \\\n                                                                                                                                                                                                      \\\n                   rvdff  #(1)  write_bypass_ff (.*, .clk(active_clk),                                                     .din(write_bypass_en[k][l]), .dout(write_bypass_en_ff[k][l])) ;                            \\\n                   rvdffs #(1)  index_val_ff    (.*, .clk(active_clk), .en(write_bypass_en[k][l] | ic_b_clear_en[k][l]),   .din(~ic_b_clear_en[k][l]),  .dout(index_valid[k][l])) ;                                   \\\n                   rvdff  #(1)  sel_hold_ff     (.*, .clk(active_clk),                                                     .din(sel_bypass[k][l]),      .dout(sel_bypass_ff[k][l])) ;                                 \\\n                                                                                                                                                                                                      \\\n                   rvdffe #((31-pt.ICACHE_DATA_INDEX_LO+1)) ic_addr_index    (.*, .en(write_bypass_en[k][l]),    .din (ic_b_rw_addr[k]),      .dout(wb_index_hold[k][l]));                            \\\n                   rvdffe #((``waywidth*pt.ICACHE_NUM_WAYS))        rd_data_hold_ff  (.*, .en(write_bypass_en_ff[k][l]), .din (wb_packeddout_pre[k]), .dout(wb_packeddout_hold[k][l]));                       \\\n                                                                                                                                                                                                      \\\n                end // block: BYPASS                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                always_comb begin                                                                                                                                                                     \\\n                 any_bypass[k] = '0;                                                                                                                                                                  \\\n                 sel_bypass_data[k] = '0;                                                                                                                                                             \\\n                                                                                                                                                                                                      \\\n                 for (int l=0; l<pt.ICACHE_NUM_BYPASS; l++) begin                                                                                                                                     \\\n                    any_bypass[k]      |=  sel_bypass_ff[k][l];                                                                                                                                       \\\n                      sel_bypass_data[k] |= (sel_bypass_ff[k][l]) ? wb_packeddout_hold[k][l] : '0;                                                                                                    \\\n                 end                                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                   wb_packeddout[k]   =   any_bypass[k] ?  sel_bypass_data[k] :  wb_packeddout_pre[k] ;                                                                                               \\\n                end // always_comb begin                                                                                                                                                              \\\n                                                                                                                                                                                                      \\\n             end // if (pt.ICACHE_BYPASS_ENABLE == 1)                                                                                                                                                 \\\n             else begin                                                                                                                                                                               \\\n                 assign wb_packeddout[k]   =   wb_packeddout_pre[k] ;                                                                                                                                 \\\n                 assign ic_bank_way_clken_final[k]   =  |ic_bank_way_clken[k] ;                                                                                                                       \\\n             end\n\n // generate IC DATA PACKED SRAMS for 2/4 ways\n  for (genvar k=0; k<pt.ICACHE_BANKS_WAY; k++) begin: BANKS_WAY   // 16B subbank\n     if (pt.ICACHE_ECC) begin : ECC1\n        logic [pt.ICACHE_BANKS_WAY-1:0] [(71*pt.ICACHE_NUM_WAYS)-1:0]        wb_packeddout, ic_b_sb_bit_en_vec, wb_packeddout_pre;           // data and its bit enables\n\n        logic [pt.ICACHE_BANKS_WAY-1:0] [pt.ICACHE_NUM_BYPASS-1:0] [(71*pt.ICACHE_NUM_WAYS)-1:0]  wb_packeddout_hold;\n\n        for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: BITEN\n           assign ic_b_sb_bit_en_vec[k][(71*i)+70:71*i] = {71{ic_b_sb_wren[k][i]}};\n        end\n\n        // SRAMS with ECC (single/double detect; no correct)\n        if ($clog2(pt.ICACHE_DATA_DEPTH) == 13 )   begin : size_8192\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(8192,284,71)    // 64b data + 7b ecc\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(8192,142,71)\n           end // block: WAYS\n        end // block: size_8192\n\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 12 )   begin : size_4096\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(4096,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(4096,142,71)\n           end // block: WAYS\n        end // block: size_4096\n\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 11 ) begin : size_2048\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(2048,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(2048,142,71)\n           end // block: WAYS\n        end // block: size_2048\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 10 ) begin : size_1024\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(1024,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(1024,142,71)\n           end // block: WAYS\n        end // block: size_1024\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 9 ) begin : size_512\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(512,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(512,142,71)\n           end // block: WAYS\n        end // block: size_512\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 8 ) begin : size_256\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(256,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(256,142,71)\n           end // block: WAYS\n        end // block: size_256\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 7 ) begin : size_128\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(128,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(128,142,71)\n           end // block: WAYS\n        end // block: size_128\n\n        else  begin : size_64\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(64,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(64,142,71)\n           end // block: WAYS\n        end // block: size_64\n\n\n       for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: WAYS\n          assign wb_dout[i][k][70:0]  = wb_packeddout[k][(71*i)+70:71*i];\n       end : WAYS\n\n       end // if (pt.ICACHE_ECC)\n\n\n     else  begin  : ECC0\n        logic [pt.ICACHE_BANKS_WAY-1:0] [(68*pt.ICACHE_NUM_WAYS)-1:0]        wb_packeddout, ic_b_sb_bit_en_vec, wb_packeddout_pre;           // data and its bit enables\n\n        logic [pt.ICACHE_BANKS_WAY-1:0] [pt.ICACHE_NUM_BYPASS-1:0] [(68*pt.ICACHE_NUM_WAYS)-1:0]  wb_packeddout_hold;\n\n        for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: BITEN\n           assign ic_b_sb_bit_en_vec[k][(68*i)+67:68*i] = {68{ic_b_sb_wren[k][i]}};\n        end\n\n        // SRAMs with parity\n        if ($clog2(pt.ICACHE_DATA_DEPTH) == 13 )   begin : size_8192\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(8192,272,68)    // 64b data + 4b parity\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(8192,136,68)\n           end // block: WAYS\n        end // block: size_8192\n\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 12 )   begin : size_4096\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(4096,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(4096,136,68)\n           end // block: WAYS\n        end // block: size_4096\n\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 11 ) begin : size_2048\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(2048,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(2048,136,68)\n           end // block: WAYS\n        end // block: size_2048\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 10 ) begin : size_1024\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(1024,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(1024,136,68)\n           end // block: WAYS\n        end // block: size_1024\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 9 ) begin : size_512\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(512,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(512,136,68)\n           end // block: WAYS\n        end // block: size_512\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 8 ) begin : size_256\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(256,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(256,136,68)\n           end // block: WAYS\n        end // block: size_256\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 7 ) begin : size_128\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(128,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(128,136,68)\n           end // block: WAYS\n        end // block: size_128\n\n        else  begin : size_64\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(64,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EL2_PACKED_IC_DATA_SRAM(64,136,68)\n           end // block: WAYS\n        end // block: size_64\n\n       for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: WAYS\n          assign wb_dout[i][k][67:0]  = wb_packeddout[k][(68*i)+67:68*i];\n       end\n     end // block: ECC0\n     end // block: BANKS_WAY\n end // block: PACKED_1\n\n\n   assign ic_rd_hit_q[pt.ICACHE_NUM_WAYS-1:0] = ic_debug_rd_en_ff ? ic_debug_rd_way_en_ff[pt.ICACHE_NUM_WAYS-1:0] : ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0] ;\n\n\n if ( pt.ICACHE_ECC ) begin : ECC1_MUX\n\n   assign ic_bank_wr_data[1] = ic_wr_data[1][70:0];\n   assign ic_bank_wr_data[0] = ic_wr_data[0][70:0];\n\n    always_comb begin : rd_mux\n      wb_dout_way_pre[pt.ICACHE_NUM_WAYS-1:0] = '0;\n\n      for ( int i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : num_ways\n        for ( int j=0; j<pt.ICACHE_BANKS_WAY; j++) begin : banks\n         wb_dout_way_pre[i][70:0]      |=  ({71{(ic_rw_addr_ff[pt.ICACHE_BANK_HI : pt.ICACHE_BANK_LO] == (pt.ICACHE_BANK_BITS)'(j))}}   &  wb_dout[i][j]);\n         wb_dout_way_pre[i][141 : 71]  |=  ({71{(ic_rw_addr_ff[pt.ICACHE_BANK_HI : pt.ICACHE_BANK_LO] == (pt.ICACHE_BANK_BITS)'(j-1))}} &  wb_dout[i][j]);\n        end\n      end\n    end\n\n    for ( genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : num_ways_mux1\n      assign wb_dout_way[i][63:0] = (ic_rw_addr_ff[2:1] == 2'b00) ? wb_dout_way_pre[i][63:0]   :\n                                    (ic_rw_addr_ff[2:1] == 2'b01) ?{wb_dout_way_pre[i][86:71], wb_dout_way_pre[i][63:16]} :\n                                    (ic_rw_addr_ff[2:1] == 2'b10) ?{wb_dout_way_pre[i][102:71],wb_dout_way_pre[i][63:32]} :\n                                                                   {wb_dout_way_pre[i][119:71],wb_dout_way_pre[i][63:48]};\n\n      assign wb_dout_way_with_premux[i][63:0]  =  ic_sel_premux_data ? ic_premux_data[63:0] : wb_dout_way[i][63:0] ;\n   end\n\n   always_comb begin : rd_out\n      ic_debug_rd_data[70:0]     = '0;\n      ic_rd_data[63:0]           = '0;\n      wb_dout_ecc[141:0]         = '0;\n      for ( int i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : num_ways_mux2\n         ic_rd_data[63:0]       |= ({64{ic_rd_hit_q[i] | ic_sel_premux_data}}) &  wb_dout_way_with_premux[i][63:0];\n         ic_debug_rd_data[70:0] |= ({71{ic_rd_hit_q[i]}}) & wb_dout_way_pre[i][70:0];\n         wb_dout_ecc[141:0]     |= {142{ic_rd_hit_q[i]}}  & wb_dout_way_pre[i];\n      end\n   end\n\n\n for (genvar i=0; i < pt.ICACHE_BANKS_WAY ; i++) begin : ic_ecc_error\n    assign bank_check_en[i]    = |ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0] & ((i==0) | (~ic_cacheline_wrap_ff & (ic_b_rden_ff[pt.ICACHE_BANKS_WAY-1:0] == {pt.ICACHE_BANKS_WAY{1'b1}})));  // always check the lower address bank, and drop the upper address bank on a CL wrap\n    assign wb_dout_ecc_bank[i] = wb_dout_ecc[(71*i)+70:(71*i)];\n\n   rvecc_decode_64  ecc_decode_64 (\n                           .en               (bank_check_en[i]),\n                           .din              (wb_dout_ecc_bank[i][63 : 0]),                // [134:71],  [63:0]\n                           .ecc_in           (wb_dout_ecc_bank[i][70 : 64]),               // [141:135] [70:64]\n                           .ecc_error        (ic_eccerr[i]));\n\n   // or the sb and db error detects into 1 signal called aligndataperr[i] where i corresponds to 2B position\n  assign  ic_parerr[i]  = '0 ;\n  end // block: ic_ecc_error\n\nend // if ( pt.ICACHE_ECC )\n\nelse  begin : ECC0_MUX\n   assign ic_bank_wr_data[1] = ic_wr_data[1][70:0];\n   assign ic_bank_wr_data[0] = ic_wr_data[0][70:0];\n\n   always_comb begin : rd_mux\n      wb_dout_way_pre[pt.ICACHE_NUM_WAYS-1:0] = '0;\n\n   for ( int i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : num_ways\n     for ( int j=0; j<pt.ICACHE_BANKS_WAY; j++) begin : banks\n         wb_dout_way_pre[i][67:0]         |=  ({68{(ic_rw_addr_ff[pt.ICACHE_BANK_HI : pt.ICACHE_BANK_LO] == (pt.ICACHE_BANK_BITS)'(j))}}   &  wb_dout[i][j][67:0]);\n         wb_dout_way_pre[i][135 : 68]     |=  ({68{(ic_rw_addr_ff[pt.ICACHE_BANK_HI : pt.ICACHE_BANK_LO] == (pt.ICACHE_BANK_BITS)'(j-1))}} &  wb_dout[i][j][67:0]);\n      end\n     end\n   end\n   // When we straddle the banks like this - the ECC we capture is not correct ??\n   for ( genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : num_ways_mux1\n      assign wb_dout_way[i][63:0] = (ic_rw_addr_ff[2:1] == 2'b00) ? wb_dout_way_pre[i][63:0]   :\n                                    (ic_rw_addr_ff[2:1] == 2'b01) ?{wb_dout_way_pre[i][83:68],  wb_dout_way_pre[i][63:16]} :\n                                    (ic_rw_addr_ff[2:1] == 2'b10) ?{wb_dout_way_pre[i][99:68],  wb_dout_way_pre[i][63:32]} :\n                                                                   {wb_dout_way_pre[i][115:68], wb_dout_way_pre[i][63:48]};\n\n      assign wb_dout_way_with_premux[i][63:0]      =  ic_sel_premux_data ? ic_premux_data[63:0]  : wb_dout_way[i][63:0] ;\n   end\n\n   always_comb begin : rd_out\n      ic_rd_data[63:0]   = '0;\n      ic_debug_rd_data[70:0]   = '0;\n      wb_dout_ecc[135:0] = '0;\n\n      for ( int i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : num_ways_mux2\n         ic_rd_data[63:0]   |= ({64{ic_rd_hit_q[i] | ic_sel_premux_data}} &  wb_dout_way_with_premux[i][63:0]);\n         ic_debug_rd_data[70:0] |= ({71{ic_rd_hit_q[i]}}) & {3'b0,wb_dout_way_pre[i][67:0]};\n         wb_dout_ecc[135:0] |= {136{ic_rd_hit_q[i]}}  & wb_dout_way_pre[i][135:0];\n      end\n   end\n\n   assign wb_dout_ecc_bank[0] =  wb_dout_ecc[67:0];\n   assign wb_dout_ecc_bank[1] =  wb_dout_ecc[135:68];\n\n   logic [pt.ICACHE_BANKS_WAY-1:0][3:0] ic_parerr_bank;\n\n  for (genvar i=0; i < pt.ICACHE_BANKS_WAY ; i++) begin : ic_par_error\n    assign bank_check_en[i]    = |ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0] & ((i==0) | (~ic_cacheline_wrap_ff & (ic_b_rden_ff[pt.ICACHE_BANKS_WAY-1:0] == {pt.ICACHE_BANKS_WAY{1'b1}})));  // always check the lower address bank, and drop the upper address bank on a CL wrap\n     for (genvar j=0; j<4; j++)  begin : parity\n      rveven_paritycheck pchk (\n                           .data_in   (wb_dout_ecc_bank[i][16*(j+1)-1: 16*j]),\n                           .parity_in (wb_dout_ecc_bank[i][64+j]),\n                           .parity_err(ic_parerr_bank[i][j] )\n                           );\n        end\n     assign ic_eccerr [i] = '0 ;\n  end\n\n     assign ic_parerr[1] = (|ic_parerr_bank[1][3:0]) & bank_check_en[1];\n     assign ic_parerr[0] = (|ic_parerr_bank[0][3:0]) & bank_check_en[0];\n\nend // else: !if( pt.ICACHE_ECC )\n\n\nendmodule // EL2_IC_DATA\n\n//=============================================================================================================================================================\n///\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\ END OF IC DATA MODULE \\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\n//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n//=============================================================================================================================================================\n\n/////////////////////////////////////////////////\n////// ICACHE TAG MODULE     ////////////////////\n/////////////////////////////////////////////////\nmodule EL2_IC_TAG\nimport el2_pkg::*;\n #(\n`include \"el2_param.vh\"\n )\n     (\n      input logic                                                   clk,\n      input logic                                                   active_clk,\n      input logic                                                   rst_l,\n      input logic                                                   clk_override,\n      input logic                                                   dec_tlu_core_ecc_disable,\n\n      input logic [31:3]                                            ic_rw_addr,\n\n      inpu"}
{"text": "t logic [pt.ICACHE_NUM_WAYS-1:0]                         ic_wr_en,             // way\n      input logic [pt.ICACHE_NUM_WAYS-1:0]                         ic_tag_valid,\n      input logic                                                  ic_rd_en,\n\n      input logic [pt.ICACHE_INDEX_HI:3]                           ic_debug_addr,        // Read/Write addresss to the Icache.\n      input logic                                                  ic_debug_rd_en,       // Icache debug rd\n      input logic                                                  ic_debug_wr_en,       // Icache debug wr\n      input logic                                                  ic_debug_tag_array,   // Debug tag array\n      input logic [pt.ICACHE_NUM_WAYS-1:0]                         ic_debug_way,         // Debug way. Rd or Wr.\n      input el2_ic_tag_ext_in_pkt_t   [pt.ICACHE_NUM_WAYS-1:0]    ic_tag_ext_in_pkt,\n\n      output logic [25:0]                                          ictag_debug_rd_data,\n      input  logic [70:0]                                          ic_debug_wr_data,     // Debug wr cache.\n\n      output logic [pt.ICACHE_NUM_WAYS-1:0]                        ic_rd_hit,\n      output logic                                                 ic_tag_perr,\n      input  logic                                                 scan_mode\n   ) ;\n\n   logic [pt.ICACHE_NUM_WAYS-1:0] [25:0]                           ic_tag_data_raw;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [25:0]                           ic_tag_data_raw_pre;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [36:pt.ICACHE_TAG_LO]            w_tout;\n   logic [25:0]                                                    ic_tag_wr_data ;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [31:0]                           ic_tag_corrected_data_unc;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [06:0]                           ic_tag_corrected_ecc_unc;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_single_ecc_error;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_double_ecc_error;\n   logic [6:0]                                                     ic_tag_ecc;\n\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_way_perr ;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_debug_rd_way_en ;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_debug_rd_way_en_ff ;\n\n   logic [pt.ICACHE_INDEX_HI: pt.ICACHE_TAG_INDEX_LO]              ic_rw_addr_q;\n   logic [31:pt.ICACHE_TAG_LO]                                     ic_rw_addr_ff;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_rden_q;          // way\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_wren;          // way\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_wren_q;        // way\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_clken;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_debug_wr_way_en;   // debug wr_way\n   logic                                                           ic_rd_en_ff;\n   logic                                                           ic_tag_parity;\n\n\n   assign  ic_tag_wren [pt.ICACHE_NUM_WAYS-1:0]  = ic_wr_en[pt.ICACHE_NUM_WAYS-1:0] & {pt.ICACHE_NUM_WAYS{(ic_rw_addr[pt.ICACHE_BEAT_ADDR_HI:4] == {pt.ICACHE_BEAT_BITS-1{1'b1}})}} ;\n   assign  ic_tag_clken[pt.ICACHE_NUM_WAYS-1:0]  = {pt.ICACHE_NUM_WAYS{ic_rd_en | clk_override}} | ic_wr_en[pt.ICACHE_NUM_WAYS-1:0] | ic_debug_wr_way_en[pt.ICACHE_NUM_WAYS-1:0] | ic_debug_rd_way_en[pt.ICACHE_NUM_WAYS-1:0];\n\n   rvdff #(1) rd_en_ff (.*, .clk(active_clk),\n                    .din (ic_rd_en),\n                    .dout(ic_rd_en_ff)) ;\n\n\n   rvdffie #(32-pt.ICACHE_TAG_LO) adr_ff (.*,\n                                          .din ({ic_rw_addr[31:pt.ICACHE_TAG_LO]}),\n                                          .dout({ic_rw_addr_ff[31:pt.ICACHE_TAG_LO]})\n                                          );\n\n   localparam PAD_BITS = 21 - (32 - pt.ICACHE_TAG_LO);  // sizing for a max tag width.\n\n   // tags\n   assign  ic_debug_rd_way_en[pt.ICACHE_NUM_WAYS-1:0] =  {pt.ICACHE_NUM_WAYS{ic_debug_rd_en & ic_debug_tag_array}} & ic_debug_way[pt.ICACHE_NUM_WAYS-1:0] ;\n   assign  ic_debug_wr_way_en[pt.ICACHE_NUM_WAYS-1:0] =  {pt.ICACHE_NUM_WAYS{ic_debug_wr_en & ic_debug_tag_array}} & ic_debug_way[pt.ICACHE_NUM_WAYS-1:0] ;\n\n   assign  ic_tag_wren_q[pt.ICACHE_NUM_WAYS-1:0]  =  ic_tag_wren[pt.ICACHE_NUM_WAYS-1:0]          |\n                                  ic_debug_wr_way_en[pt.ICACHE_NUM_WAYS-1:0]   ;\n\n   assign  ic_tag_rden_q[pt.ICACHE_NUM_WAYS-1:0]  =  ({pt.ICACHE_NUM_WAYS{ic_rd_en }}  | ic_debug_rd_way_en[pt.ICACHE_NUM_WAYS-1:0] ) &  {pt.ICACHE_NUM_WAYS{~(|ic_wr_en)  & ~ic_debug_wr_en}};\n\nif (pt.ICACHE_TAG_LO == 11) begin: SMALLEST\n if (pt.ICACHE_ECC) begin : ECC1_W\n           rvecc_encode  tag_ecc_encode (\n                                  .din    ({{pt.ICACHE_TAG_LO{1'b0}}, ic_rw_addr[31:pt.ICACHE_TAG_LO]}),\n                                  .ecc_out({ ic_tag_ecc[6:0]}));\n\n   assign  ic_tag_wr_data[25:0] = (ic_debug_wr_en & ic_debug_tag_array) ?\n                                  {ic_debug_wr_data[68:64], ic_debug_wr_data[31:11]} :\n                                  {ic_tag_ecc[4:0], ic_rw_addr[31:pt.ICACHE_TAG_LO]} ;\n end\n\n else begin : ECC0_W\n           rveven_paritygen #(32-pt.ICACHE_TAG_LO) pargen  (.data_in   (ic_rw_addr[31:pt.ICACHE_TAG_LO]),\n                                                 .parity_out(ic_tag_parity));\n\n   assign  ic_tag_wr_data[21:0] = (ic_debug_wr_en & ic_debug_tag_array) ?\n                                  {ic_debug_wr_data[64], ic_debug_wr_data[31:11]} :\n                                  {ic_tag_parity, ic_rw_addr[31:pt.ICACHE_TAG_LO]} ;\n end // else: !if(pt.ICACHE_ECC)\n\nend // block: SMALLEST\n\n\nelse begin: OTHERS\n  if(pt.ICACHE_ECC) begin :ECC1_W\n           rvecc_encode  tag_ecc_encode (\n                                  .din    ({{pt.ICACHE_TAG_LO{1'b0}}, ic_rw_addr[31:pt.ICACHE_TAG_LO]}),\n                                  .ecc_out({ ic_tag_ecc[6:0]}));\n\n   assign  ic_tag_wr_data[25:0] = (ic_debug_wr_en & ic_debug_tag_array) ?\n                                  {ic_debug_wr_data[68:64],ic_debug_wr_data[31:11]} :\n                                  {ic_tag_ecc[4:0], {PAD_BITS{1'b0}},ic_rw_addr[31:pt.ICACHE_TAG_LO]} ;\n\n  end\n  else  begin :ECC0_W\n   logic   ic_tag_parity ;\n           rveven_paritygen #(32-pt.ICACHE_TAG_LO) pargen  (.data_in   (ic_rw_addr[31:pt.ICACHE_TAG_LO]),\n                                                 .parity_out(ic_tag_parity));\n   assign  ic_tag_wr_data[21:0] = (ic_debug_wr_en & ic_debug_tag_array) ?\n                                  {ic_debug_wr_data[64], ic_debug_wr_data[31:11]} :\n                                  {ic_tag_parity, {PAD_BITS{1'b0}},ic_rw_addr[31:pt.ICACHE_TAG_LO]} ;\n  end // else: !if(pt.ICACHE_ECC)\n\nend // block: OTHERS\n\n\n    assign ic_rw_addr_q[pt.ICACHE_INDEX_HI: pt.ICACHE_TAG_INDEX_LO] = (ic_debug_rd_en | ic_debug_wr_en) ?\n                                                ic_debug_addr[pt.ICACHE_INDEX_HI: pt.ICACHE_TAG_INDEX_LO] :\n                                                ic_rw_addr[pt.ICACHE_INDEX_HI: pt.ICACHE_TAG_INDEX_LO] ;\n\n   rvdff #(pt.ICACHE_NUM_WAYS) tag_rd_wy_ff (.*, .clk(active_clk),\n                    .din ({ic_debug_rd_way_en[pt.ICACHE_NUM_WAYS-1:0]}),\n                    .dout({ic_debug_rd_way_en_ff[pt.ICACHE_NUM_WAYS-1:0]}));\n\n if (pt.ICACHE_WAYPACK == 0 ) begin : PACKED_0\n\n   logic [pt.ICACHE_NUM_WAYS-1:0] ic_b_sram_en;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                                                               ic_b_read_en;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                                                               ic_b_write_en;\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_TAG_NUM_BYPASS-1:0] [pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO]   wb_index_hold;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                               [pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO]   ic_b_rw_addr;\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 write_bypass_en;     //bank\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 write_bypass_en_ff;  //bank\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 index_valid;  //bank\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 ic_b_clear_en;\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 ic_b_addr_match;\n\n\n\n\n    logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_NUM_BYPASS_WIDTH-1:0] wrptr;\n    logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_NUM_BYPASS_WIDTH-1:0] wrptr_in;\n    logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_NUM_BYPASS-1:0]       sel_bypass;\n    logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_NUM_BYPASS-1:0]       sel_bypass_ff;\n\n\n\n    logic [pt.ICACHE_NUM_WAYS-1:0][25:0]  sel_bypass_data;\n    logic [pt.ICACHE_NUM_WAYS-1:0]        any_bypass;\n    logic [pt.ICACHE_NUM_WAYS-1:0]        any_addr_match;\n    logic [pt.ICACHE_NUM_WAYS-1:0]        ic_tag_clken_final;\n\n      `define EL2_IC_TAG_SRAM(depth,width)                                                                                                      \\\n                                  ram_``depth``x``width  ic_way_tag (                                                                           \\\n                                .ME(ic_tag_clken_final[i]),                                                                                     \\\n                                .WE (ic_tag_wren_q[i]),                                                                                         \\\n                                .D  (ic_tag_wr_data[``width-1:0]),                                                                              \\\n                                .ADR(ic_rw_addr_q[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]),                                                  \\\n                                .Q  (ic_tag_data_raw_pre[i][``width-1:0]),                                                                      \\\n                                .CLK (clk),                                                                                                     \\\n                                .ROP ( ),                                                                                                       \\\n                                                                                                                                                \\\n                                .TEST1(ic_tag_ext_in_pkt[i].TEST1),                                                                             \\\n                                .RME(ic_tag_ext_in_pkt[i].RME),                                                                                 \\\n                                .RM(ic_tag_ext_in_pkt[i].RM),                                                                                   \\\n                                                                                                                                                \\\n                                .LS(ic_tag_ext_in_pkt[i].LS),                                                                                   \\\n                                .DS(ic_tag_ext_in_pkt[i].DS),                                                                                   \\\n                                .SD(ic_tag_ext_in_pkt[i].SD),                                                                                   \\\n                                                                                                                                                \\\n                                .TEST_RNM(ic_tag_ext_in_pkt[i].TEST_RNM),                                                                       \\\n                                .BC1(ic_tag_ext_in_pkt[i].BC1),                                                                                 \\\n                                .BC2(ic_tag_ext_in_pkt[i].BC2)                                                                                  \\\n                                                                                                                                                \\\n                               );                                                                                                               \\\n                                                                                                                                                \\\n                                                                                                                                                \\\n                                                                                                                                                \\\n                                                                                                                                                \\\n              if (pt.ICACHE_TAG_BYPASS_ENABLE == 1) begin                                                                                                                                             \\\n                                                                                                                                                                                                      \\\n                 assign wrptr_in[i] = (wrptr[i] == (pt.ICACHE_TAG_NUM_BYPASS-1)) ? '0 : (wrptr[i] + 1'd1);                                                                                            \\\n                                                                                                                                                                                                      \\\n                 rvdffs  #(pt.ICACHE_TAG_NUM_BYPASS_WIDTH)  wrptr_ff(.*, .clk(active_clk), .en(|write_bypass_en[i]), .din (wrptr_in[i]), .dout(wrptr[i])) ;                                           \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_sram_en[i]              = ic_tag_clken[i];                                                                                                                               \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_read_en[i]              =  ic_b_sram_en[i] &   (ic_tag_rden_q[i]);                                                                                                       \\\n                 assign ic_b_write_en[i]             =  ic_b_sram_en[i] &   (ic_tag_wren_q[i]);                                                                                                       \\\n                 assign ic_tag_clken_final[i]        =  ic_b_sram_en[i] &    ~(|sel_bypass[i]);                                                                                                       \\\n                                                                                                                                                                                                      \\\n                 // LSB is pt.ICACHE_TAG_INDEX_LO]                                                                                                                                                    \\\n                 assign ic_b_rw_addr[i] = {ic_rw_addr_q};                                                                                                                                             \\\n                                                                                                                                                                                                      \\\n                 always_comb begin                                                                                                                                                                    \\\n                    any_addr_match[i] = '0;                                                                                                                                                           \\\n                                                                                                                                                                                                      \\\n                    for (int l=0; l<pt.ICACHE_TAG_NUM_BYPASS; l++) begin                                                                                                                              \\\n                       any_addr_match[i] |= (ic_b_addr_match[i][l] & index_valid[i][l]);                                                                                                              \\\n                    end                                                                                                                                                                               \\\n                 end                                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                // it is an error to ever have 2 entries with the same index and both valid                                                                                                           \\\n                for (genvar l=0; l<pt.ICACHE_TAG_NUM_BYPASS; l++) begin: BYPASS                                                                                                                       \\\n                                                                                                                                                                                                      \\\n                   assign ic_b_addr_match[i][l] = (wb_index_hold[i][l] ==  ic_b_rw_addr[i]) & index_valid[i][l];                                                                                      \\\n                                                                                                                                                                                                      \\\n                   assign ic_b_clear_en[i][l]   = ic_b_write_en[i] &   ic_b_addr_match[i][l];                                                                                                         \\\n                                                                                                                                                                                                      \\\n                   assign sel_bypass[i][l]      = ic_b_read_en[i]  &   ic_b_addr_match[i][l] ;                                                                                                        \\\n                                                                                                                                                                                                      \\\n                   assign write_bypass_en[i][l] = ic_b_read_en[i]  &  ~any_addr_match[i] & (wrptr[i] == l);                                                                                           \\\n                                                                                                                                                                       "}
{"text": "                               \\\n                   rvdff  #(1)  write_bypass_ff (.*, .clk(active_clk),                                                     .din(write_bypass_en[i][l]), .dout(write_bypass_en_ff[i][l])) ;                            \\\n                   rvdffs #(1)  index_val_ff    (.*, .clk(active_clk), .en(write_bypass_en[i][l] | ic_b_clear_en[i][l]),         .din(~ic_b_clear_en[i][l]),  .dout(index_valid[i][l])) ;                             \\\n                   rvdff  #(1)  sel_hold_ff     (.*, .clk(active_clk),                                                     .din(sel_bypass[i][l]),      .dout(sel_bypass_ff[i][l])) ;                                 \\\n                                                                                                                                                                                                      \\\n                   rvdffe #(.WIDTH(pt.ICACHE_INDEX_HI-pt.ICACHE_TAG_INDEX_LO+1),.OVERRIDE(1))  ic_addr_index   (.*, .en(write_bypass_en[i][l]),    .din (ic_b_rw_addr[i]),        .dout(wb_index_hold[i][l]));   \\\n                   rvdffe #(``width)                                                           rd_data_hold_ff (.*, .en(write_bypass_en_ff[i][l]), .din (ic_tag_data_raw_pre[i][``width-1:0]), .dout(wb_dout_hold[i][l]));            \\\n                                                                                                                                                                                                      \\\n                end // block: BYPASS                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                always_comb begin                                                                                                                                                                     \\\n                 any_bypass[i] = '0;                                                                                                                                                                  \\\n                 sel_bypass_data[i] = '0;                                                                                                                                                             \\\n                                                                                                                                                                                                      \\\n                 for (int l=0; l<pt.ICACHE_TAG_NUM_BYPASS; l++) begin                                                                                                                                 \\\n                    any_bypass[i]      |=  sel_bypass_ff[i][l];                                                                                                                                       \\\n                    sel_bypass_data[i] |= (sel_bypass_ff[i][l]) ? wb_dout_hold[i][l] : '0;                                                                                                            \\\n                 end                                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                   ic_tag_data_raw[i]   =   any_bypass[i] ?  sel_bypass_data[i] :  ic_tag_data_raw_pre[i] ;                                                                                           \\\n                end // always_comb begin                                                                                                                                                              \\\n                                                                                                                                                                                                      \\\n             end // if (pt.ICACHE_BYPASS_ENABLE == 1)                                                                                                                                                 \\\n             else begin                                                                                                                                                                               \\\n                 assign ic_tag_data_raw[i]   =   ic_tag_data_raw_pre[i] ;                                                                                                                             \\\n                 assign ic_tag_clken_final[i]       =   ic_tag_clken[i];                                                                                                                              \\\n             end\n   for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: WAYS\n\n   if (pt.ICACHE_ECC) begin  : ECC1\n      logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_NUM_BYPASS-1:0][25 :0] wb_dout_hold;\n\n      if (pt.ICACHE_TAG_DEPTH == 32)   begin : size_32\n                 `EL2_IC_TAG_SRAM(32,26)\n      end // if (pt.ICACHE_TAG_DEPTH == 32)\n      if (pt.ICACHE_TAG_DEPTH == 64)   begin : size_64\n                 `EL2_IC_TAG_SRAM(64,26)\n      end // if (pt.ICACHE_TAG_DEPTH == 64)\n      if (pt.ICACHE_TAG_DEPTH == 128)   begin : size_128\n                 `EL2_IC_TAG_SRAM(128,26)\n      end // if (pt.ICACHE_TAG_DEPTH == 128)\n       if (pt.ICACHE_TAG_DEPTH == 256)   begin : size_256\n                 `EL2_IC_TAG_SRAM(256,26)\n       end // if (pt.ICACHE_TAG_DEPTH == 256)\n       if (pt.ICACHE_TAG_DEPTH == 512)   begin : size_512\n                 `EL2_IC_TAG_SRAM(512,26)\n       end // if (pt.ICACHE_TAG_DEPTH == 512)\n       if (pt.ICACHE_TAG_DEPTH == 1024)   begin : size_1024\n                 `EL2_IC_TAG_SRAM(1024,26)\n       end // if (pt.ICACHE_TAG_DEPTH == 1024)\n       if (pt.ICACHE_TAG_DEPTH == 2048)   begin : size_2048\n                 `EL2_IC_TAG_SRAM(2048,26)\n       end // if (pt.ICACHE_TAG_DEPTH == 2048)\n       if (pt.ICACHE_TAG_DEPTH == 4096)   begin  : size_4096\n                 `EL2_IC_TAG_SRAM(4096,26)\n       end // if (pt.ICACHE_TAG_DEPTH == 4096)\n\n         assign w_tout[i][31:pt.ICACHE_TAG_LO] = ic_tag_data_raw[i][31-pt.ICACHE_TAG_LO:0] ;\n         assign w_tout[i][36:32]              = ic_tag_data_raw[i][25:21] ;\n\n         rvecc_decode  ecc_decode (\n                           .en(~dec_tlu_core_ecc_disable & ic_rd_en_ff),\n                           .sed_ded ( 1'b1 ),    // 1 : means only detection\n                           .din({11'b0,ic_tag_data_raw[i][20:0]}),\n                           .ecc_in({2'b0, ic_tag_data_raw[i][25:21]}),\n                           .dout(ic_tag_corrected_data_unc[i][31:0]),\n                           .ecc_out(ic_tag_corrected_ecc_unc[i][6:0]),\n                           .single_ecc_error(ic_tag_single_ecc_error[i]),\n                           .double_ecc_error(ic_tag_double_ecc_error[i]));\n\n          assign ic_tag_way_perr[i]= ic_tag_single_ecc_error[i] | ic_tag_double_ecc_error[i]  ;\n      end\n      else  begin : ECC0\n      logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_NUM_BYPASS-1:0][21 :0] wb_dout_hold;\n      assign ic_tag_data_raw_pre[i][25:22] = '0 ;\n\n      if (pt.ICACHE_TAG_DEPTH == 32)   begin : size_32\n                 `EL2_IC_TAG_SRAM(32,22)\n      end // if (pt.ICACHE_TAG_DEPTH == 32)\n      if (pt.ICACHE_TAG_DEPTH == 64)   begin : size_64\n                 `EL2_IC_TAG_SRAM(64,22)\n      end // if (pt.ICACHE_TAG_DEPTH == 64)\n      if (pt.ICACHE_TAG_DEPTH == 128)   begin : size_128\n                 `EL2_IC_TAG_SRAM(128,22)\n      end // if (pt.ICACHE_TAG_DEPTH == 128)\n       if (pt.ICACHE_TAG_DEPTH == 256)   begin : size_256\n                 `EL2_IC_TAG_SRAM(256,22)\n       end // if (pt.ICACHE_TAG_DEPTH == 256)\n       if (pt.ICACHE_TAG_DEPTH == 512)   begin : size_512\n                 `EL2_IC_TAG_SRAM(512,22)\n       end // if (pt.ICACHE_TAG_DEPTH == 512)\n       if (pt.ICACHE_TAG_DEPTH == 1024)   begin : size_1024\n                 `EL2_IC_TAG_SRAM(1024,22)\n       end // if (pt.ICACHE_TAG_DEPTH == 1024)\n       if (pt.ICACHE_TAG_DEPTH == 2048)   begin : size_2048\n                 `EL2_IC_TAG_SRAM(2048,22)\n       end // if (pt.ICACHE_TAG_DEPTH == 2048)\n       if (pt.ICACHE_TAG_DEPTH == 4096)   begin  : size_4096\n                 `EL2_IC_TAG_SRAM(4096,22)\n       end // if (pt.ICACHE_TAG_DEPTH == 4096)\n\n         assign w_tout[i][31:pt.ICACHE_TAG_LO] = ic_tag_data_raw[i][31-pt.ICACHE_TAG_LO:0] ;\n         assign w_tout[i][32]                 = ic_tag_data_raw[i][21] ;\n\n         rveven_paritycheck #(32-pt.ICACHE_TAG_LO) parcheck(.data_in   (w_tout[i][31:pt.ICACHE_TAG_LO]),\n                                                   .parity_in (w_tout[i][32]),\n                                                   .parity_err(ic_tag_way_perr[i]));\n      end // else: !if(pt.ICACHE_ECC)\n\n   end // block: WAYS\n end // block: PACKED_0\n\n\n else begin : PACKED_1\n\n\n   logic                                                                                ic_b_sram_en;\n   logic                                                                                ic_b_read_en;\n   logic                                                                                ic_b_write_en;\n   logic [pt.ICACHE_TAG_NUM_BYPASS-1:0] [pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO]   wb_index_hold;\n   logic                                [pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO]   ic_b_rw_addr;\n   logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 write_bypass_en;     //bank\n   logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 write_bypass_en_ff;  //bank\n   logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 index_valid;  //bank\n   logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 ic_b_clear_en;\n   logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 ic_b_addr_match;\n\n\n\n\n    logic [pt.ICACHE_TAG_NUM_BYPASS_WIDTH-1:0]  wrptr;\n    logic [pt.ICACHE_TAG_NUM_BYPASS_WIDTH-1:0]  wrptr_in;\n    logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]        sel_bypass;\n    logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]        sel_bypass_ff;\n\n\n\n    logic [(26*pt.ICACHE_NUM_WAYS)-1:0]  sel_bypass_data;\n    logic                                any_bypass;\n    logic                                any_addr_match;\n    logic                                ic_tag_clken_final;\n\n`define EL2_IC_TAG_PACKED_SRAM(depth,width)                                                               \\\n                  ram_be_``depth``x``width  ic_way_tag (                                                   \\\n                                .ME  ( ic_tag_clken_final),                                                \\\n                                .WE  (|ic_tag_wren_q[pt.ICACHE_NUM_WAYS-1:0]),                             \\\n                                .WEM (ic_tag_wren_biten_vec[``width-1:0]),                                 \\\n                                                                                                           \\\n                                .D   ({pt.ICACHE_NUM_WAYS{ic_tag_wr_data[``width/pt.ICACHE_NUM_WAYS-1:0]}}), \\\n                                .ADR (ic_rw_addr_q[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]),            \\\n                                .Q   (ic_tag_data_raw_packed_pre[``width-1:0]),                            \\\n                                .CLK (clk),                                                                \\\n                                .ROP ( ),                                                                  \\\n                                                                                                           \\\n                                .TEST1     (ic_tag_ext_in_pkt[0].TEST1),                                   \\\n                                .RME      (ic_tag_ext_in_pkt[0].RME),                                      \\\n                                .RM       (ic_tag_ext_in_pkt[0].RM),                                       \\\n                                                                                                           \\\n                                .LS       (ic_tag_ext_in_pkt[0].LS),                                       \\\n                                .DS       (ic_tag_ext_in_pkt[0].DS),                                       \\\n                                .SD       (ic_tag_ext_in_pkt[0].SD),                                       \\\n                                                                                                           \\\n                                .TEST_RNM (ic_tag_ext_in_pkt[0].TEST_RNM),                                 \\\n                                .BC1      (ic_tag_ext_in_pkt[0].BC1),                                      \\\n                                .BC2      (ic_tag_ext_in_pkt[0].BC2)                                       \\\n                                                                                                           \\\n                               );                                                                          \\\n                                                                                                           \\\n              if (pt.ICACHE_TAG_BYPASS_ENABLE == 1) begin                                                                                                                                             \\\n                                                                                                                                                                                                      \\\n                 assign wrptr_in = (wrptr == (pt.ICACHE_TAG_NUM_BYPASS-1)) ? '0 : (wrptr + 1'd1);                                                                                                     \\\n                                                                                                                                                                                                      \\\n                 rvdffs  #(pt.ICACHE_TAG_NUM_BYPASS_WIDTH)  wrptr_ff(.*, .clk(active_clk), .en(|write_bypass_en), .din (wrptr_in), .dout(wrptr)) ;                                                    \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_sram_en              = |ic_tag_clken;                                                                                                                                    \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_read_en              =  ic_b_sram_en &   (|ic_tag_rden_q);                                                                                                               \\\n                 assign ic_b_write_en             =  ic_b_sram_en &   (|ic_tag_wren_q);                                                                                                               \\\n                 assign ic_tag_clken_final        =  ic_b_sram_en &    ~(|sel_bypass);                                                                                                                \\\n                                                                                                                                                                                                      \\\n                 // LSB is pt.ICACHE_TAG_INDEX_LO]                                                                                                                                                    \\\n                 assign ic_b_rw_addr = {ic_rw_addr_q};                                                                                                                                                \\\n                                                                                                                                                                                                      \\\n                 always_comb begin                                                                                                                                                                    \\\n                    any_addr_match = '0;                                                                                                                                                              \\\n                                                                                                                                                                                                      \\\n                    for (int l=0; l<pt.ICACHE_TAG_NUM_BYPASS; l++) begin                                                                                                                              \\\n                       any_addr_match |= ic_b_addr_match[l];                                                                                                                                          \\\n                    end                                                                                                                                                                               \\\n                 end                                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                // it is an error to ever have 2 entries with the same index and both valid                                                                                                           \\\n                for (genvar l=0; l<pt.ICACHE_TAG_NUM_BYPASS; l++) begin: BYPASS                                                                                                                       \\\n                                                                                                                                                                                                      \\\n                   assign ic_b_addr_match[l] = (wb_index_hold[l] ==  ic_b_rw_addr) & index_valid[l];                                                                                                  \\\n                                                                                                                                                                                                      \\\n                   assign ic_b_clear_en[l]   = ic_b_write_en &   ic_b_addr_match[l];                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                   assign sel_bypass[l]      = ic_b_read_en  &   ic_b_addr_match[l] ;                                                                                                                 \\\n                                                                                                                                                                    "}
{"text": "                                  \\\n                   assign write_bypass_en[l] = ic_b_read_en  &  ~any_addr_match & (wrptr == l);                                                                                                       \\\n                                                                                                                                                                                                      \\\n                   rvdff  #(1)  write_bypass_ff (.*, .clk(active_clk),                                                     .din(write_bypass_en[l]), .dout(write_bypass_en_ff[l])) ;                                  \\\n                   rvdffs #(1)  index_val_ff    (.*, .clk(active_clk), .en(write_bypass_en[l] | ic_b_clear_en[l]),         .din(~ic_b_clear_en[l]),  .dout(index_valid[l])) ;                                         \\\n                   rvdff  #(1)  sel_hold_ff     (.*, .clk(active_clk),                                                     .din(sel_bypass[l]),      .dout(sel_bypass_ff[l])) ;                                               \\\n                                                                                                                                                                                                      \\\n                   rvdffe #(.WIDTH(pt.ICACHE_INDEX_HI-pt.ICACHE_TAG_INDEX_LO+1),.OVERRIDE(1)) ic_addr_index    (.*, .en(write_bypass_en[l]),    .din (ic_b_rw_addr),               .dout(wb_index_hold[l]));          \\\n                   rvdffe #(``width)                                                          rd_data_hold_ff  (.*, .en(write_bypass_en_ff[l]), .din (ic_tag_data_raw_packed_pre[``width-1:0]), .dout(wb_packeddout_hold[l]));        \\\n                                                                                                                                                                                                      \\\n                end // block: BYPASS                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                always_comb begin                                                                                                                                                                     \\\n                 any_bypass = '0;                                                                                                                                                                     \\\n                 sel_bypass_data = '0;                                                                                                                                                                \\\n                                                                                                                                                                                                      \\\n                 for (int l=0; l<pt.ICACHE_TAG_NUM_BYPASS; l++) begin                                                                                                                                 \\\n                    any_bypass      |=  sel_bypass_ff[l];                                                                                                                                             \\\n                    sel_bypass_data |= (sel_bypass_ff[l]) ? wb_packeddout_hold[l] : '0;                                                                                                               \\\n                 end                                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                   ic_tag_data_raw_packed   =   any_bypass ?  sel_bypass_data :  ic_tag_data_raw_packed_pre ;                                                                                         \\\n                end // always_comb begin                                                                                                                                                              \\\n                                                                                                                                                                                                      \\\n             end // if (pt.ICACHE_BYPASS_ENABLE == 1)                                                                                                                                                 \\\n             else begin                                                                                                                                                                               \\\n                 assign ic_tag_data_raw_packed   =   ic_tag_data_raw_packed_pre ;                                                                                                                     \\\n                 assign ic_tag_clken_final       =   |ic_tag_clken;                                                                                                                                   \\\n             end\n\n   if (pt.ICACHE_ECC) begin  : ECC1\n    logic [(26*pt.ICACHE_NUM_WAYS)-1 :0]  ic_tag_data_raw_packed, ic_tag_wren_biten_vec, ic_tag_data_raw_packed_pre;           // data and its bit enables\n    logic [pt.ICACHE_TAG_NUM_BYPASS-1:0][(26*pt.ICACHE_NUM_WAYS)-1 :0] wb_packeddout_hold;\n    for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: BITEN\n        assign ic_tag_wren_biten_vec[(26*i)+25:26*i] = {26{ic_tag_wren_q[i]}};\n     end\n      if (pt.ICACHE_TAG_DEPTH == 32)   begin : size_32\n        if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(32,104)\n        end // block: WAYS\n      else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(32,52)\n        end // block: WAYS\n      end // if (pt.ICACHE_TAG_DEPTH == 32\n\n      if (pt.ICACHE_TAG_DEPTH == 64)   begin : size_64\n        if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(64,104)\n        end // block: WAYS\n      else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(64,52)\n        end // block: WAYS\n      end // block: size_64\n\n      if (pt.ICACHE_TAG_DEPTH == 128)   begin : size_128\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(128,104)\n      end // block: WAYS\n      else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(128,52)\n      end // block: WAYS\n\n      end // block: size_128\n\n      if (pt.ICACHE_TAG_DEPTH == 256)   begin : size_256\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(256,104)\n        end // block: WAYS\n       else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(256,52)\n        end // block: WAYS\n      end // block: size_256\n\n      if (pt.ICACHE_TAG_DEPTH == 512)   begin : size_512\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(512,104)\n        end // block: WAYS\n       else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(512,52)\n        end // block: WAYS\n      end // block: size_512\n\n      if (pt.ICACHE_TAG_DEPTH == 1024)   begin : size_1024\n         if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(1024,104)\n        end // block: WAYS\n       else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(1024,52)\n        end // block: WAYS\n      end // block: size_1024\n\n      if (pt.ICACHE_TAG_DEPTH == 2048)   begin : size_2048\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(2048,104)\n        end // block: WAYS\n       else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(2048,52)\n        end // block: WAYS\n      end // block: size_2048\n\n      if (pt.ICACHE_TAG_DEPTH == 4096)   begin  : size_4096\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(4096,104)\n        end // block: WAYS\n       else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(4096,52)\n        end // block: WAYS\n      end // block: size_4096\n\n        for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin\n          assign ic_tag_data_raw[i]  = ic_tag_data_raw_packed[(26*i)+25:26*i];\n          assign w_tout[i][31:pt.ICACHE_TAG_LO] = ic_tag_data_raw[i][31-pt.ICACHE_TAG_LO:0] ;\n          assign w_tout[i][36:32]              = ic_tag_data_raw[i][25:21] ;\n          rvecc_decode  ecc_decode (\n                           .en(~dec_tlu_core_ecc_disable & ic_rd_en_ff),\n                           .sed_ded ( 1'b1 ),    // 1 : means only detection\n                           .din({11'b0,ic_tag_data_raw[i][20:0]}),\n                           .ecc_in({2'b0, ic_tag_data_raw[i][25:21]}),\n                           .dout(ic_tag_corrected_data_unc[i][31:0]),\n                           .ecc_out(ic_tag_corrected_ecc_unc[i][6:0]),\n                           .single_ecc_error(ic_tag_single_ecc_error[i]),\n                           .double_ecc_error(ic_tag_double_ecc_error[i]));\n\n          assign ic_tag_way_perr[i]= ic_tag_single_ecc_error[i] | ic_tag_double_ecc_error[i]  ;\n     end // for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++)\n\n   end // block: ECC1\n\n\n   else  begin : ECC0\n    logic [(22*pt.ICACHE_NUM_WAYS)-1 :0]  ic_tag_data_raw_packed, ic_tag_wren_biten_vec, ic_tag_data_raw_packed_pre;           // data and its bit enables\n    logic [pt.ICACHE_TAG_NUM_BYPASS-1:0][(22*pt.ICACHE_NUM_WAYS)-1 :0] wb_packeddout_hold;\n    for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: BITEN\n        assign ic_tag_wren_biten_vec[(22*i)+21:22*i] = {22{ic_tag_wren_q[i]}};\n     end\n      if (pt.ICACHE_TAG_DEPTH == 32)   begin : size_32\n        if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(32,88)\n        end // block: WAYS\n      else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(32,44)\n        end // block: WAYS\n      end // if (pt.ICACHE_TAG_DEPTH == 32\n\n      if (pt.ICACHE_TAG_DEPTH == 64)   begin : size_64\n        if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(64,88)\n        end // block: WAYS\n      else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(64,44)\n        end // block: WAYS\n      end // block: size_64\n\n      if (pt.ICACHE_TAG_DEPTH == 128)   begin : size_128\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(128,88)\n      end // block: WAYS\n      else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(128,44)\n      end // block: WAYS\n\n      end // block: size_128\n\n      if (pt.ICACHE_TAG_DEPTH == 256)   begin : size_256\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(256,88)\n        end // block: WAYS\n       else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(256,44)\n        end // block: WAYS\n      end // block: size_256\n\n      if (pt.ICACHE_TAG_DEPTH == 512)   begin : size_512\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(512,88)\n        end // block: WAYS\n       else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(512,44)\n        end // block: WAYS\n      end // block: size_512\n\n      if (pt.ICACHE_TAG_DEPTH == 1024)   begin : size_1024\n         if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(1024,88)\n        end // block: WAYS\n       else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(1024,44)\n        end // block: WAYS\n      end // block: size_1024\n\n      if (pt.ICACHE_TAG_DEPTH == 2048)   begin : size_2048\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(2048,88)\n        end // block: WAYS\n       else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(2048,44)\n        end // block: WAYS\n      end // block: size_2048\n\n      if (pt.ICACHE_TAG_DEPTH == 4096)   begin  : size_4096\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(4096,88)\n        end // block: WAYS\n       else begin : WAYS\n                 `EL2_IC_TAG_PACKED_SRAM(4096,44)\n        end // block: WAYS\n      end // block: size_4096\n\n      for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin\n          assign ic_tag_data_raw[i]  = ic_tag_data_raw_packed[(22*i)+21:22*i];\n          assign w_tout[i][31:pt.ICACHE_TAG_LO] = ic_tag_data_raw[i][31-pt.ICACHE_TAG_LO:0] ;\n          assign w_tout[i][32]                 = ic_tag_data_raw[i][21] ;\n          assign w_tout[i][36:33]              = '0 ;\n\n\n          rveven_paritycheck #(32-pt.ICACHE_TAG_LO) parcheck(.data_in   (w_tout[i][31:pt.ICACHE_TAG_LO]),\n                                                   .parity_in (w_tout[i][32]),\n                                                   .parity_err(ic_tag_way_perr[i]));\n      end\n\n\n   end // block: ECC0\n end // block: PACKED_1\n\n\n   always_comb begin : tag_rd_out\n      ictag_debug_rd_data[25:0] = '0;\n      for ( int j=0; j<pt.ICACHE_NUM_WAYS; j++) begin: debug_rd_out\n         ictag_debug_rd_data[25:0] |=  pt.ICACHE_ECC ? ({26{ic_debug_rd_way_en_ff[j]}} & ic_tag_data_raw[j] ) : {4'b0, ({22{ic_debug_rd_way_en_ff[j]}} & ic_tag_data_raw[j][21:0])};\n      end\n   end\n\n\n   for ( genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : ic_rd_hit_loop\n      assign ic_rd_hit[i] = (w_tout[i][31:pt.ICACHE_TAG_LO] == ic_rw_addr_ff[31:pt.ICACHE_TAG_LO]) & ic_tag_valid[i];\n   end\n\n   assign  ic_tag_perr  = | (ic_tag_way_perr[pt.ICACHE_NUM_WAYS-1:0] & ic_tag_valid[pt.ICACHE_NUM_WAYS-1:0] ) ;\nendmodule // EL2_IC_TAG\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// el2_ifu_ifc_ctl.sv\n// Function: Fetch pipe control\n//\n// Comments:\n//********************************************************************************\n\nmodule el2_ifu_ifc_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n   input logic clk,                         // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n   input logic free_l2clk,                  // Clock always.                  Through one clock header.  For flops with    second header built in.\n\n   input logic rst_l, // reset enable, from core pin\n   input logic scan_mode, // scan\n\n   input logic ic_hit_f,      // Icache hit\n   input logic ifu_ic_mb_empty, // Miss buffer empty\n\n   input logic ifu_fb_consume1,  // Aligner consumed 1 fetch buffer\n   input logic ifu_fb_consume2,  // Aligner consumed 2 fetch buffers\n\n   input logic dec_tlu_flush_noredir_wb, // Don't fetch on flush\n   input logic exu_flush_final, // FLush\n   input logic [31:1] exu_flush_path_final, // Flush path\n\n   input logic ifu_bp_hit_taken_f, // btb hit, select the target path\n   input logic [31:1] ifu_bp_btb_target_f, //  predicted target PC\n\n   input logic ic_dma_active, // IC DMA active, stop fetching\n   input logic ic_write_stall, // IC is writing, stop fetching\n   input logic dma_iccm_stall_any, // force a stall in the fetch pipe for DMA ICCM access\n\n   input logic [31:0]  dec_tlu_mrac_ff ,   // side_effect and cacheable for each region\n\n   output logic [31:1] ifc_fetch_addr_f, // fetch addr F\n   output logic [31:1] ifc_fetch_addr_bf, // fetch addr BF\n\n   output logic  ifc_fetch_req_f,  // fetch request valid F\n\n   output logic  ifu_pmu_fetch_stall, // pmu event measuring fetch stall\n\n   output logic                       ifc_fetch_uncacheable_bf,      // The fetch request is uncacheable space. BF stage\n   output logic                      ifc_fetch_req_bf,              // Fetch request. Comes with the address.  BF stage\n   output logic                       ifc_fetch_req_bf_raw,          // Fetch request without some qualifications. Used for clock-gating. BF stage\n   output logic                       ifc_iccm_access_bf,            // This request is to the ICCM. Do not generate misses to the bus.\n   output logic                       ifc_region_acc_fault_bf,       // Access fault. in ICCM region but offset is outside defined ICCM.\n\n   output logic  ifc_dma_access_ok // fetch is not accessing the ICCM, DMA can proceed\n\n\n   );\n\n   logic [31:1]  fetch_addr_bf;\n   logic [31:1]  fetch_addr_next;\n   logic [3:0]   fb_write_f, fb_write_ns;\n\n   logic     fb_full_f_ns, fb_full_f;\n   logic     fb_right, fb_right2, fb_left, wfm, idle;\n   logic     sel_last_addr_bf, sel_next_addr_bf;\n   logic     miss_f, miss_a;\n   logic     flush_fb, dma_iccm_stall_any_f;\n   logic     mb_empty_mod, goto_idle, leave_idle;\n   logic     fetch_bf_en;\n   logic         line_wrap;\n   logic         fetch_addr_next_1;\n\n   // FSM assignment\n    typedef enum logic [1:0] { IDLE  = 2'b00 ,\n                               FETCH = 2'b01 ,\n                               STALL = 2'b10 ,\n                               WFM   = 2'b11   } state_t ;\n   state_t state      ;\n   state_t next_state ;\n\n   logic     dma_stall;\n   assign dma_stall = ic_dma_active | dma_iccm_stall_any_f;\n\n\n\n   // Fetch address mux\n   // - flush\n   // - Miss *or* flush during WFM (icache miss buffer is blocking)\n   // - Sequential\n\nif(pt.BTB_ENABLE==1) begin\n   logic sel_btb_addr_bf;\n\n   assign sel_last_addr_bf = ~exu_flush_final & (~ifc_fetch_req_f | ~ic_hit_f);\n   assign sel_btb_addr_bf  = ~exu_flush_final & ifc_fetch_req_f & ifu_bp_hit_taken_f & ic_hit_f;\n   assign sel_next_addr_bf = ~exu_flush_final & ifc_fetch_req_f & ~ifu_bp_hit_taken_f & ic_hit_f;\n\n\n   assign fetch_addr_bf[31:1] = ( ({31{exu_flush_final}} &  exu_flush_path_final[31:1]) | // FLUSH path\n                  ({31{sel_last_addr_bf}} & ifc_fetch_addr_f[31:1]) | // MISS path\n                  ({31{sel_btb_addr_bf}} & {ifu_bp_btb_target_f[31:1]})| // BTB target\n                  ({31{sel_next_addr_bf}} & {fetch_addr_next[31:1]})); // SEQ path\n\n\nend // if (pt.BTB_ENABLE=1)\n   else begin\n   assign sel_last_addr_bf = ~exu_flush_final & (~ifc_fetch_req_f | ~ic_hit_f);\n   assign sel_next_addr_bf = ~exu_flush_final & ifc_fetch_req_f & ic_hit_f;\n\n\n   assign fetch_addr_bf[31:1] = ( ({31{exu_flush_final}} &  exu_flush_path_final[31:1]) | // FLUSH path\n                  ({31{sel_last_addr_bf}} & ifc_fetch_addr_f[31:1]) | // MISS path\n                  ({31{sel_next_addr_bf}} & {fetch_addr_next[31:1]})); // SEQ path\n\nend\n   assign fetch_addr_next[31:1] = {({ifc_fetch_addr_f[31:2]} + 31'b1), fetch_addr_next_1 };\n   assign line_wrap = (fetch_addr_next[pt.ICACHE_TAG_INDEX_LO] ^ ifc_fetch_addr_f[pt.ICACHE_TAG_INDEX_LO]);\n\n   assign fetch_addr_next_1 = line_wrap ? 1'b0 : ifc_fetch_addr_f[1];\n\n   assign ifc_fetch_req_bf_raw = ~idle;\n   assign ifc_fetch_req_bf =  ifc_fetch_req_bf_raw &\n\n                 ~(fb_full_f_ns & ~(ifu_fb_consume2 | ifu_fb_consume1)) &\n                 ~dma_stall &\n                 ~ic_write_stall &\n                 ~dec_tlu_flush_noredir_wb;\n\n\n   assign fetch_bf_en = exu_flush_final | ifc_fetch_req_f;\n\n   assign miss_f = ifc_fetch_req_f & ~ic_hit_f & ~exu_flush_final;\n\n   assign mb_empty_mod = (ifu_ic_mb_empty | exu_flush_final) & ~dma_stall & ~miss_f & ~miss_a;\n\n   // Halt flushes and takes us to IDLE\n   assign goto_idle = exu_flush_final & dec_tlu_flush_noredir_wb;\n   // If we're in IDLE, and we get a flush, goto FETCH\n   assign leave_idle = exu_flush_final & ~dec_tlu_flush_noredir_wb & idle;\n\n//.i 7\n//.o 2\n//.ilb state[1] state[0] reset_delayed miss_f mb_empty_mod  goto_idle leave_idle\n//.ob next_state[1] next_state[0]\n//.type fr\n//\n//# fetch 01, stall 10, wfm 11, idle 00\n//-- 1---- 01\n//-- 0--1- 00\n//00 0--00 00\n//00 0--01 01\n//\n//01 01-0- 11\n//01 00-0- 01\n//\n//11 0-10- 01\n//11 0-00- 11\n\n   assign next_state[1] = (~state[1] & state[0] & miss_f & ~goto_idle) |\n              (state[1] & ~mb_empty_mod & ~goto_idle);\n\n   assign next_state[0] = (~goto_idle & leave_idle) | (state[0] & ~goto_idle);\n\n   assign flush_fb = exu_flush_final;\n\n   // model fb write logic to mass balance the fetch buffers\n   assign fb_right = ( ifu_fb_consume1 & ~ifu_fb_consume2 & (~ifc_fetch_req_f | miss_f)) | // Consumed and no new fetch\n              (ifu_fb_consume2 &  ifc_fetch_req_f); // Consumed 2 and new fetch\n\n\n   assign fb_right2 = (ifu_fb_consume2 & (~ifc_fetch_req_f | miss_f)); // Consumed 2 and no new fetch\n\n   assign fb_left = ifc_fetch_req_f & ~(ifu_fb_consume1 | ifu_fb_consume2) & ~miss_f;\n\n// CBH\n   assign fb_write_ns[3:0] = ( ({4{(flush_fb)}} & 4'b0001) |\n                   ({4{~flush_fb & fb_right }} & {1'b0, fb_write_f[3:1]}) |\n                   ({4{~flush_fb & fb_right2}} & {2'b0, fb_write_f[3:2]}) |\n                   ({4{~flush_fb & fb_left  }} & {fb_write_f[2:0], 1'b0}) |\n                   ({4{~flush_fb & ~fb_right & ~fb_right2 & ~fb_left}}  & fb_write_f[3:0]));\n\n\n   assign fb_full_f_ns = fb_write_ns[3];\n\n   assign idle     = state      == IDLE  ;\n   assign wfm      = state      == WFM   ;\n\n   rvdffie #(10) fbwrite_ff (.*, .clk(free_l2clk),\n                          .din( {dma_iccm_stall_any, miss_f, ifc_fetch_req_bf, next_state[1:0], fb_full_f_ns, fb_write_ns[3:0]}),\n                          .dout({dma_iccm_stall_any_f, miss_a, ifc_fetch_req_f, state[1:0], fb_full_f, fb_write_f[3:0]}));\n\n   assign ifu_pmu_fetch_stall = wfm |\n                (ifc_fetch_req_bf_raw &\n                ( (fb_full_f & ~(ifu_fb_consume2 | ifu_fb_consume1 | exu_flush_final)) |\n                  dma_stall));\n\n\n\n   assign ifc_fetch_addr_bf[31:1] = fetch_addr_bf[31:1];\n\n   rvdffpcie #(31) faddrf1_ff  (.*, .en(fetch_bf_en), .din(fetch_addr_bf[31:1]), .dout(ifc_fetch_addr_f[31:1]));\n\n\n if (pt.ICCM_ENABLE)  begin\n   logic iccm_acc_in_region_bf;\n   logic iccm_acc_in_range_bf;\n   rvrangecheck #( .CCM_SADR    (pt.ICCM_SADR),\n                   .CCM_SIZE    (pt.ICCM_SIZE) ) iccm_rangecheck (\n                                     .addr     ({ifc_fetch_addr_bf[31:1],1'b0}) ,\n                                     .in_range (iccm_acc_in_range_bf) ,\n                                     .in_region(iccm_acc_in_region_bf)\n                                     );\n\n   assign ifc_iccm_access_bf = iccm_acc_in_range_bf ;\n\n  assign ifc_dma_access_ok = ( (~ifc_iccm_access_bf |\n                 (fb_full_f & ~(ifu_fb_consume2 | ifu_fb_consume1)) |\n                 (wfm  & ~ifc_fetch_req_bf) |\n                 idle ) & ~exu_flush_final) |\n                  dma_iccm_stall_any_f;\n\n  assign ifc_region_acc_fault_bf = ~iccm_acc_in_range_bf & iccm_acc_in_region_bf ;\n end\n else  begin\n   assign ifc_iccm_access_bf = 1'b0 ;\n   assign ifc_dma_access_ok  = 1'b0 ;\n   assign ifc_region_acc_fault_bf  = 1'b0 ;\n end\n\n   assign ifc_fetch_uncacheable_bf =  ~dec_tlu_mrac_ff[{ifc_fetch_addr_bf[31:28] , 1'b0 }]  ; // bit 0 of each region description is the cacheable bit\n\nendmodule // el2_ifu_ifc_ctl\n\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n\n//********************************************************************************\n// Function: Icache , iccm  control\n// BFF -> F1 -> F2 -> A\n//********************************************************************************\n\nmodule el2_ifu_mem_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n   input logic clk,                                                 // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n   input logic active_clk,                                          // Clock only while core active.  Through two clock headers. For flops without second clock header built in.\n   input logic free_l2clk,                                          // Clock always.                  Through one clock header.  For flops with    second header built in.\n   input logic rst_l,                                               // reset, active low\n\n   input logic                       exu_flush_final,               // Flush from the pipeline., includes flush lower\n   input logic                       dec_tlu_flush_lower_wb,        // Flush lower from the pipeline.\n   input logic                       dec_tlu_flush_err_wb,          // Flush from the pipeline due to perr.\n   input logic                       dec_tlu_i0_commit_cmt,         // committed i0 instruction\n   input logic                       dec_tlu_force_halt,            // force halt.\n\n   input logic [31:1]                ifc_fetch_addr_bf,             // Fetch Address byte aligned always.      F1 stage.\n   input logic                       ifc_fetch_uncacheable_bf,      // The fetch request is uncacheable space. F1 stage\n   input logic                       ifc_fetch_req_bf,              // Fetch request. Comes with the address.  F1 stage\n   input logic                       ifc_fetch_req_bf_raw,          // Fetch request without some qualifications. Used for clock-gating. F1 stage\n   input logic                       ifc_iccm_access_bf,            // This request is to the ICCM. Do not generate misses to the bus.\n   input logic                       ifc_region_acc_fault_bf,       // Access fault. in ICCM region but offset is outside defined ICCM.\n   input logic                       ifc_dma_access_ok,             // It is OK to give dma access to the ICCM. (ICCM is not busy this cycle).\n   input logic                       dec_tlu_fence_i_wb,            // Fence.i instruction is committing. Clear all Icache valids.\n   input logic                       ifu_bp_hit_taken_f,            // Branch is predicted taken. Kill the fetch next cycle.\n\n   input logic                       ifu_bp_inst_mask_f,            // tell ic which valids to kill because of a taken branch, right justified\n\n   output logic                      ifu_miss_state_idle,           // No icache misses are outstanding.\n   output logic                      ifu_ic_mb_empty,               // Continue with normal fetching. This does not mean that miss is finished.\n   output logic                      ic_dma_active  ,               // In the middle of servicing dma request to ICCM. Do not make any new requests.\n   output logic                      ic_write_stall,                // Stall fetch the cycle we are writing the cache.\n\n/// PMU signals\n   output logic                      ifu_pmu_ic_miss,               // IC miss event\n   output logic                      ifu_pmu_ic_hit,                // IC hit event\n   output logic                      ifu_pmu_bus_error,             // Bus error event\n   output logic                      ifu_pmu_bus_busy,              // Bus busy event\n   output logic                      ifu_pmu_bus_trxn,              // Bus transaction\n\n  //-------------------------- IFU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            ifu_axi_awvalid,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_awid,\n   output logic [31:0]                     ifu_axi_awaddr,\n   output logic [3:0]                      ifu_axi_awregion,\n   output logic [7:0]                      ifu_axi_awlen,\n   output logic [2:0]                      ifu_axi_awsize,\n   output logic [1:0]                      ifu_axi_awburst,\n   output logic                            ifu_axi_awlock,\n   output logic [3:0]                      ifu_axi_awcache,\n   output logic [2:0]                      ifu_axi_awprot,\n   output logic [3:0]                      ifu_axi_awqos,\n\n   output logic                            ifu_axi_wvalid,\n   output logic [63:0]                     ifu_axi_wdata,\n   output logic [7:0]                      ifu_axi_wstrb,\n   output logic                            ifu_axi_wlast,\n\n   output logic                            ifu_axi_bready,\n\n   // AXI Read Channels\n   output logic                            ifu_axi_arvalid,\n   input  logic                            ifu_axi_arready,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_arid,\n   output logic [31:0]                     ifu_axi_araddr,\n   output logic [3:0]                      ifu_axi_arregion,\n   output logic [7:0]                      ifu_axi_arlen,\n   output logic [2:0]                      ifu_axi_arsize,\n   output logic [1:0]                      ifu_axi_arburst,\n   output logic                            ifu_axi_arlock,\n   output logic [3:0]                      ifu_axi_arcache,\n   output logic [2:0]                      ifu_axi_arprot,\n   output logic [3:0]                      ifu_axi_arqos,\n\n   input  logic                            ifu_axi_rvalid,\n   output logic                            ifu_axi_rready,\n   input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_rid,\n   input  logic [63:0]                     ifu_axi_rdata,\n   input  logic [1:0]                      ifu_axi_rresp,\n\n    input  logic                     ifu_bus_clk_en,\n\n\n   input  logic                      dma_iccm_req,      //  dma iccm command (read or write)\n   input  logic [31:0]               dma_mem_addr,      //  dma address\n   input  logic [2:0]                dma_mem_sz,        //  size\n   input  logic                      dma_mem_write,     //  write\n   input  logic [63:0]               dma_mem_wdata,     //  write data\n   input  logic [2:0]                dma_mem_tag,       //  DMA Buffer entry number\n\n   output logic                      iccm_dma_ecc_error,//   Data read from iccm has an ecc error\n   output logic                      iccm_dma_rvalid,   //   Data read from iccm is valid\n   output logic [63:0]               iccm_dma_rdata,    //   dma data read from iccm\n   output logic [2:0]                iccm_dma_rtag,     //   Tag of the DMA req\n   output logic                      iccm_ready,        //   iccm ready to accept new command.\n\n\n//   I$ & ITAG Ports\n   output logic [31:1]               ic_rw_addr,         // Read/Write addresss to the Icache.\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_wr_en,           // Icache write enable, when filling the Icache.\n   output logic                      ic_rd_en,           // Icache read  enable.\n\n   output logic [pt.ICACHE_BANKS_WAY-1:0] [70:0]               ic_wr_data,           // Data to fill to the Icache. With ECC\n   input  logic [63:0]               ic_rd_data ,          // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [70:0]               ic_debug_rd_data ,          // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [25:0]               ictag_debug_rd_data,  // Debug icache tag.\n   output logic [70:0]               ic_debug_wr_data,     // Debug wr cache.\n   output logic [70:0]               ifu_ic_debug_rd_data, // debug data read\n\n\n   input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_eccerr,    //\n   input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_parerr,\n\n   output logic [pt.ICACHE_INDEX_HI:3]               ic_debug_addr,      // Read/Write addresss to the Icache.\n   output logic                      ic_debug_rd_en,     // Icache debug rd\n   output logic                      ic_debug_wr_en,     // Icache debug wr\n   output logic                      ic_debug_tag_array, // Debug tag array\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_debug_way,       // Debug way. Rd or Wr.\n\n\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_tag_valid,       // Valid bits when accessing the Icache. One valid bit per way. F2 stage\n\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]                ic_rd_hit,          // Compare hits from Icache tags. Per way.  F2 stage\n   input  logic                      ic_tag_perr,        // Icache Tag parity error\n\n   // ICCM ports\n   output logic [pt.ICCM_BITS-1:1]  iccm_rw_addr,       // ICCM read/write address.\n   output logic                      iccm_wren,          // ICCM write enable (through the DMA)\n   output logic                      iccm_rden,          // ICCM read enable.\n   output logic [77:0]               iccm_wr_data,       // ICCM write data.\n   output logic [2:0]                iccm_wr_size,       // ICCM write location within DW.\n\n   input  logic [63:0]               iccm_rd_data,       // Data read from ICCM.\n   input  logic [77:0]               iccm_rd_data_ecc,   // Data + ECC read from ICCM.\n   input  logic [1:0]                ifu_fetch_val,\n   // IFU control signals\n   output logic                      ic_hit_f,               // Hit in Icache(if Icache access) or ICCM access( ICCM always has ic_hit_f)\n   output logic [1:0]                ic_access_fault_f,      // Access fault (bus error or ICCM access in region but out of offset range).\n   output logic [1:0]                ic_access_fault_type_f, // Access fault types\n   output logic                      iccm_rd_ecc_single_err, // This fetch has a single ICCM ECC error.\n   output logic [1:0]                iccm_rd_ecc_double_err, // This fetch has a double ICCM ECC error.\n   output logic                      iccm_dma_rd_ecc_single_err, // This fetch has a single ICCM DMA ECC error.\n   output logic                      iccm_dma_rd_ecc_double_err, // This fetch has a double ICCM DMA ECC error.\n   output logic                      ic_error_start,         // This has any I$ errors ( data/tag/ecc/parity )\n\n   output logic                      ifu_async_error_start,  // Or of the sb iccm, and all the icache errors sent to aligner to stop\n   output logic                      iccm_dma_sb_error,      // Single Bit ECC error from a DMA access\n   output logic [1:0]                ic_fetch_val_f,         // valid bytes for fetch. To the Aligner.\n   output logic [31:0]               ic_data_f,              // Data read from Icache or ICCM. To the Aligner.\n   output logic [63:0]               ic_premux_data,         // Premuxed data to be muxed with Icache data\n   output logic                      ic_sel_premux_data,     // Select premux data.\n\n/////  Debug\n   input  el2_cache_debug_pkt_t     dec_tlu_ic_diag_pkt ,       // Icache/tag debug read/write packet\n   input  logic                      dec_tlu_core_ecc_disable,   // disable the ecc checking and flagging\n   output logic                      ifu_ic_debug_rd_data_valid, // debug data valid.\n   output logic                      iccm_buf_correct_ecc,\n   output logic                      iccm_correction_state,\n\n   input  logic                      ifu_pmp_error,\n\n\n   input  logic         scan_mode\n   );\n\n//  Create different defines for ICACHE and ICCM enable combinations\n\n localparam   NUM_OF_BEATS = 8 ;\n\n\n\n   logic [31:3]    ifu_ic_req_addr_f;\n   logic           uncacheable_miss_in ;\n   logic           uncacheable_miss_ff;\n\n\n\n   logic           bus_ifu_wr_en     ;\n   logic           bus_ifu_wr_en_ff  ;\n   logic           bus_ifu_wr_en_ff_q  ;\n   logic           bus_ifu_wr_en_ff_wo_err  ;\n   logic [pt.ICACHE_NUM_WAYS-1:0]     bus_ic_wr_en ;\n\n   logic           reset_tag_valid_for_miss  ;\n\n\n   logic [pt.ICACHE_STATUS_BITS-1:0]     way_status;\n   logic [pt.ICACHE_STATUS_BITS-1:0]     way_status_mb_in;\n   logic [pt.ICACHE_STATUS_BITS-1:0]     way_status_rep_new;\n   logic [pt.ICACHE_STATUS_BITS-1:0]     way_status_mb_ff;\n   logic [pt.ICACHE_STATUS_BITS-1:0]     way_status_new;\n   logic [pt.ICACHE_STATUS_BITS-1:0]     way_status_hit_new;\n   logic [pt.ICACHE_STATUS_BITS-1:0]     way_status_new_w_debug;\n   logic [pt.ICACHE_NUM_WAYS-1:0]     tagv_mb_in;\n   logic [pt.ICACHE_NUM_WAYS-1:0]     tagv_mb_ff;\n\n\n   logic           ifu_wr_data_comb_err ;\n   logic           ifu_byp_data_err_new;\n   logic  [1:0]    ifu_byp_data_err_f;\n   logic           ifu_wr_cumulative_err_data;\n   logic           ifu_wr_cumulative_err;\n   logic           ifu_wr_data_comb_err_ff;\n   logic           scnd_miss_index_match ;\n\n\n   logic           ifc_dma_access_q_ok;\n   logic           ifc_iccm_access_f ;\n   logic           ifc_region_acc_fault_f;\n   logic           ifc_region_acc_fault_final_f;\n   logic  [1:0]    ifc_bus_acc_fault_f;\n   logic           ic_act_miss_f;\n   logic           ic_miss_under_miss_f;\n   logic           ic_ignore_2nd_miss_f;\n   logic           ic_act_hit_f;\n   logic           miss_pending;\n   logic [31:1]    imb_in , imb_ff  ;\n   logic [31:pt.ICACHE_BEAT_ADDR_HI+1]    miss_addr_in , miss_addr  ;\n   logic           miss_wrap_f ;\n   logic           flush_final_f;\n   logic           ifc_fetch_req_f;\n   logic           ifc_fetch_req_f_raw;\n   logic           fetch_req_f_qual   ;\n   logic           ifc_fetch_req_qual_bf ;\n   logic [pt.ICACHE_NUM_WAYS-1:0]     replace_way_mb_any;\n   logic           last_beat;\n   logic           reset_beat_cnt  ;\n   logic [pt.ICACHE_BEAT_ADDR_HI:3]     ic_req_addr_bits_hi_3 ;\n   logic [pt.ICACHE_BEAT_ADDR_HI:3]     ic_wr_addr_bits_hi_3 ;\n   logic [31:1]    ifu_fetch_addr_int_f ;\n   logic [31:1]    ifu_ic_rw_int_addr ;\n   logic           crit_wd_byp_ok_ff ;\n   logic           ic_crit_wd_rdy_new_ff;\n   logic   [79:0]  ic_byp_data_only_pre_new;\n   logic   [79:0]  ic_byp_data_only_new;\n   logic           ic_byp_hit_f ;\n   logic           ic_valid ;\n   logic           ic_valid_ff;\n   logic           reset_all_tags;\n   logic           ic_valid_w_debug;\n\n   logic [pt.ICACHE_NUM_WAYS-1:0]     ifu_tag_wren,ifu_tag_wren_ff;\n   logic [pt.ICACHE_NUM_WAYS-1:0]     ic_debug_tag_wr_en;\n   logic [pt.ICACHE_NUM_WAYS-1:0]     ifu_tag_wren_w_debug;\n   logic [pt.ICACHE_NUM_WAYS-1:0]     ic_debug_way_ff;\n   logic           ic_debug_rd_en_ff   ;\n   logic           fetch_bf_f_c1_clken ;\n   logic           fetch_bf_f_c1_clk;\n   logic           debug_c1_clken;\n   logic           debug_c1_clk;\n\n   logic           reset_ic_in ;\n   logic           reset_ic_ff ;\n   logic [pt.ICACHE_BEAT_ADDR_HI:1]     vaddr_f ;\n   logic [31:1]    ifu_status_wr_addr;\n   logic           sel_mb_addr ;\n   logic           sel_mb_addr_ff ;\n   logic           sel_mb_status_addr ;\n   logic [63:0]    ic_final_data;\n\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] ifu_ic_rw_int_addr_ff ;\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] ifu_status_wr_addr_ff ;\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] ifu_ic_rw_int_addr_w_debug ;\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] ifu_status_wr_addr_w_debug ;\n\n   logic [pt.ICACHE_STATUS_BITS-1:0]                              way_status_new_ff ;\n   logic                                    way_status_wr_en_ff ;\n   logic [pt.ICACHE_TAG_DEPTH-1:0][pt.ICACHE_STATUS_BITS-1:0]        way_status_out ;\n   logic [1:0]                              ic_debug_way_enc;\n\n   logic [pt.IFU_BUS_TAG-1:0]             ifu_bus_rid_ff;\n\n   logic         fetch_req_icache_f;\n   logic         fetch_req_iccm_f;\n   logic         ic_iccm_hit_f;\n   logic         fetch_uncacheable_ff;\n   logic         way_status_wr_en;\n   logic         sel_byp_data;\n   logic         sel_ic_data;\n   logic         sel_iccm_data;\n   logic         ic_rd_parity_final_err;\n   logic         ic_act_miss_f_delayed;\n   logic         bus_ifu_wr_data_error;\n   logic         bus_ifu_wr_data_error_ff;\n   logic         way_status_wr_en_w_debug;\n   logic         ic_debug_tag_val_rd_out;\n   logic         ifu_pmu_ic_miss_in;\n   logic         ifu_pmu_ic_hit_in;\n   logic         ifu_pmu_bus_error_in;\n   logic         ifu_pmu_bus_trxn_in;\n   logic         ifu_pmu_bus_busy_in;\n   logic         ic_debug_ict_array_sel_in;\n   logic         ic_debug_ict_array_sel_ff;\n   logic         debug_data_clken;\n   logic         last_data_recieved_in ;\n   logic         last_data_recieved_ff ;\n\n   logic                          ifu_bus_rvalid           ;\n   logic                          ifu_bus_rvalid_ff        ;\n   logic                          ifu_bus_rvalid_unq_ff    ;\n   logic                          ifu_bus_arready_unq       ;\n   logic                          ifu_bus_arready_unq_ff    ;\n   logic                          ifu_bus_arvalid           ;\n   logic                          ifu_bus_arvalid_ff        ;\n   logic                          ifu_bus_arready           ;\n   logic                          ifu_bus_arready_ff        ;\n   logic [63:0]                   ifu_bus_rdata_ff        ;\n   logic [1:0]                    ifu_bus_rresp_ff          ;\n   logic                          ifu_bus_rsp_valid ;\n   logic                          ifu_bus_rsp_ready ;\n   logic [pt.IFU_BUS_TAG-1:0]     ifu_bus_rsp_tag;\n   logic [63:0]                   ifu_bus_rsp_rdata;\n   logic [1:0]                    ifu_bus_rsp_opc;\n\n   logic [pt.ICACHE_NUM_BEATS-1:0]    write_fill_data;\n   logic [pt.ICACHE_NUM_BEATS-1:0]    wr_data_c1_clk;\n   logic [pt.ICACHE_NUM_BEATS-1:0]    ic_miss_buff_data_valid_in;\n   logic [pt.ICACHE_NUM_BEATS-1:0]    ic_miss_buff_data_valid;\n   logic [pt.ICACHE_NUM_BEATS-1:0]    ic_miss_buff_data_error_in;\n   logic [pt.ICACHE_NUM_BEATS-1:0]    ic_miss_buff_data_error;\n   logic [pt.ICACHE_BEAT_ADDR_HI:1]    byp_fetch_index;\n   logic [pt.ICACHE_BEAT_ADDR_HI:2]    byp_fetch_index_0;\n   logic [pt.ICACHE_BEAT_ADDR_HI:2]    byp_fetch_index_1;\n   logic [pt.ICACHE_BEAT_ADDR_HI:3]    byp_fetch_index_inc;\n   logic [pt.ICACHE_BEAT_ADDR_HI:2]    byp_fetch_index_inc_0;\n   logic [pt.ICACHE_BEAT_ADDR_HI:2]    byp_fetch_index_inc_1;\n   logic          miss_buff_hit_unq_f ;\n   logic          stream_hit_f ;\n   logic          stream_miss_f ;\n   logic          stream_eol_f ;\n   logic          crit_byp_hit_f ;\n   logic [pt.IFU_BUS_TAG-1:0] other_tag ;\n   logic [(2*pt.ICACHE_NUM_BEATS)-1:0] [31:0] ic_miss_buff_data;\n   logic [63:0] ic_miss_buff_half;\n   logic        scnd_miss_req, scnd_miss_req_q;\n   logic        scnd_miss_req_in;\n\n\n   logic [pt.ICCM_BITS-1:2]                iccm_ecc_corr_index_ff;\n   logic [pt.ICCM_BITS-1:2]                iccm_ecc_corr_index_in;\n   logic [38:0]                         iccm_ecc_corr_data_ff;\n   logic                                iccm_ecc_write_status     ;\n   logic                                iccm_rd_ecc_single_err_ff   ;\n   logic                                iccm_error_start;     // start the error fsm\n   logic                                perr_state_en;\n   logic                                miss_state_en;\n\n   logic        busclk;\n   logic        busclk_force;\n   logic        busclk_reset;\n   logic        bus_ifu_bus_clk_en_ff;\n   logic        bus_ifu_bus_clk_e"}
{"text": "n ;\n\n   logic        ifc_bus_ic_req_ff_in;\n   logic        ifu_bus_cmd_valid ;\n   logic        ifu_bus_cmd_ready ;\n\n   logic        bus_inc_data_beat_cnt     ;\n   logic        bus_reset_data_beat_cnt   ;\n   logic        bus_hold_data_beat_cnt    ;\n\n   logic        bus_inc_cmd_beat_cnt     ;\n   logic        bus_reset_cmd_beat_cnt_0   ;\n   logic        bus_reset_cmd_beat_cnt_secondlast   ;\n   logic        bus_hold_cmd_beat_cnt    ;\n\n   logic [pt.ICACHE_BEAT_BITS-1:0]  bus_new_data_beat_count  ;\n   logic [pt.ICACHE_BEAT_BITS-1:0]  bus_data_beat_count      ;\n\n   logic [pt.ICACHE_BEAT_BITS-1:0]  bus_new_cmd_beat_count  ;\n   logic [pt.ICACHE_BEAT_BITS-1:0]  bus_cmd_beat_count      ;\n\n\n   logic [pt.ICACHE_BEAT_BITS-1:0]  bus_new_rd_addr_count;\n   logic [pt.ICACHE_BEAT_BITS-1:0]  bus_rd_addr_count;\n\n\n   logic        bus_cmd_sent           ;\n   logic        bus_last_data_beat     ;\n\n\n   logic [pt.ICACHE_NUM_WAYS-1:0]       bus_wren            ;\n\n   logic [pt.ICACHE_NUM_WAYS-1:0]       bus_wren_last       ;\n   logic [pt.ICACHE_NUM_WAYS-1:0]       wren_reset_miss      ;\n   logic        ifc_dma_access_ok_d;\n   logic        ifc_dma_access_ok_prev;\n\n   logic   bus_cmd_req_in ;\n   logic   bus_cmd_req_hold ;\n\n   logic   second_half_available ;\n   logic   write_ic_16_bytes ;\n\n   logic   ifc_region_acc_fault_final_bf;\n   logic   ifc_region_acc_fault_memory_bf;\n   logic   ifc_region_acc_fault_memory_f;\n   logic   ifc_region_acc_okay;\n\n   logic   iccm_correct_ecc;\n   logic   dma_sb_err_state, dma_sb_err_state_ff;\n   logic   two_byte_instr;\n\n   typedef enum logic [2:0] {IDLE=3'b000, CRIT_BYP_OK=3'b001, HIT_U_MISS=3'b010, MISS_WAIT=3'b011,CRIT_WRD_RDY=3'b100,SCND_MISS=3'b101,STREAM=3'b110 , STALL_SCND_MISS=3'b111} miss_state_t;\n   miss_state_t miss_state, miss_nxtstate;\n\n   typedef enum logic [1:0] {ERR_STOP_IDLE=2'b00, ERR_FETCH1=2'b01 , ERR_FETCH2=2'b10 , ERR_STOP_FETCH=2'b11} err_stop_state_t;\n   err_stop_state_t err_stop_state, err_stop_nxtstate;\n   logic   err_stop_state_en ;\n   logic   err_stop_fetch ;\n\n   logic   ic_crit_wd_rdy;         // Critical fetch is ready to be bypassed.\n\n   logic   ifu_bp_hit_taken_q_f;\n   logic   ifu_bus_rvalid_unq;\n   logic   bus_cmd_beat_en;\n\n\n// ---- Clock gating section -----\n// c1 clock enables\n\n\n   assign fetch_bf_f_c1_clken  = ifc_fetch_req_bf_raw | ifc_fetch_req_f | miss_pending | exu_flush_final | scnd_miss_req;\n   assign debug_c1_clken       = ic_debug_rd_en | ic_debug_wr_en ;\n   // C1 - 1 clock pulse for data\n`ifdef RV_FPGA_OPTIMIZE\n   assign fetch_bf_f_c1_clk = 1'b0;\n   assign debug_c1_clk      = 1'b0;\n`else\n   rvclkhdr fetch_bf_f_c1_cgc    ( .en(fetch_bf_f_c1_clken),     .l1clk(fetch_bf_f_c1_clk), .* );\n   rvclkhdr debug_c1_cgc         ( .en(debug_c1_clken),          .l1clk(debug_c1_clk), .* );\n`endif\n\n\n// ------ end clock gating section ------------------------\n\n   logic [1:0]    iccm_single_ecc_error;\n   logic          dma_iccm_req_f ;\n   assign iccm_dma_sb_error     = (|iccm_single_ecc_error[1:0] )  & dma_iccm_req_f ;\n   assign ifu_async_error_start = iccm_rd_ecc_single_err | ic_error_start;\n\n\n   typedef enum logic [2:0] {ERR_IDLE=3'b000, IC_WFF=3'b001 , ECC_WFF=3'b010 , ECC_CORR=3'b011, DMA_SB_ERR=3'b100} perr_state_t;\n   perr_state_t perr_state, perr_nxtstate;\n\n\n   assign ic_dma_active = iccm_correct_ecc | (perr_state == DMA_SB_ERR) | (err_stop_state == ERR_STOP_FETCH) | err_stop_fetch |\n                          dec_tlu_flush_err_wb; // The last term is to give a error-correction a chance to finish before refetch starts\n\n   assign scnd_miss_req_in     = ifu_bus_rsp_valid & bus_ifu_bus_clk_en & ifu_bus_rsp_ready &\n                                 (&bus_new_data_beat_count[pt.ICACHE_BEAT_BITS-1:0]) &\n                                 ~uncacheable_miss_ff &  ((miss_state == SCND_MISS) | (miss_nxtstate == SCND_MISS)) & ~exu_flush_final;\n\n   assign ifu_bp_hit_taken_q_f = ifu_bp_hit_taken_f & ic_hit_f ;\n\n   //////////////////////////////////// Create Miss State Machine ///////////////////////\n   //                                   Create Miss State Machine                      //\n   //                                   Create Miss State Machine                      //\n   //                                   Create Miss State Machine                      //\n   //////////////////////////////////// Create Miss State Machine ///////////////////////\n   // FIFO state machine\n   always_comb begin : MISS_SM\n      miss_nxtstate   = IDLE;\n      miss_state_en   = 1'b0;\n      case (miss_state)\n         IDLE: begin : idle\n                  miss_nxtstate = (ic_act_miss_f & ~exu_flush_final) ? CRIT_BYP_OK : HIT_U_MISS ;\n                  miss_state_en = ic_act_miss_f & ~dec_tlu_force_halt ;\n         end\n         CRIT_BYP_OK: begin : crit_byp_ok\n                  miss_nxtstate =  (dec_tlu_force_halt ) ?                                                                             IDLE :\n                                  ( ic_byp_hit_f &  (last_data_recieved_ff | (bus_ifu_wr_en_ff & last_beat)) &  uncacheable_miss_ff) ? IDLE :\n                                  ( ic_byp_hit_f &  ~last_data_recieved_ff                                &  uncacheable_miss_ff) ? MISS_WAIT :\n                                  (~ic_byp_hit_f &  ~exu_flush_final &  (bus_ifu_wr_en_ff & last_beat)       &  uncacheable_miss_ff) ? CRIT_WRD_RDY :\n                                  (                                      (bus_ifu_wr_en_ff & last_beat)       & ~uncacheable_miss_ff) ? IDLE :\n                                  ( ic_byp_hit_f  &  ~exu_flush_final & ~(bus_ifu_wr_en_ff & last_beat)       & ~ifu_bp_hit_taken_q_f   & ~uncacheable_miss_ff) ? STREAM :\n                                  ( bus_ifu_wr_en_ff &  ~exu_flush_final & ~(bus_ifu_wr_en_ff & last_beat)       & ~ifu_bp_hit_taken_q_f   & ~uncacheable_miss_ff) ? STREAM :\n                                  (~ic_byp_hit_f  &  ~exu_flush_final &  (bus_ifu_wr_en_ff & last_beat)       & ~uncacheable_miss_ff) ? IDLE :\n                                  ( (exu_flush_final | ifu_bp_hit_taken_q_f)  & ~(bus_ifu_wr_en_ff & last_beat)                      ) ? HIT_U_MISS : IDLE;\n                  miss_state_en =  dec_tlu_force_halt | exu_flush_final | ic_byp_hit_f | ifu_bp_hit_taken_q_f | (bus_ifu_wr_en_ff & last_beat) | (bus_ifu_wr_en_ff & ~uncacheable_miss_ff)  ;\n         end\n         CRIT_WRD_RDY: begin : crit_wrd_rdy\n                  miss_nxtstate =  IDLE ;\n                  miss_state_en =  exu_flush_final | flush_final_f | ic_byp_hit_f | dec_tlu_force_halt  ;\n         end\n         STREAM: begin : stream\n                  miss_nxtstate =  ((exu_flush_final | ifu_bp_hit_taken_q_f  | stream_eol_f ) & ~(bus_ifu_wr_en_ff & last_beat) & ~dec_tlu_force_halt) ? HIT_U_MISS  : IDLE ;\n                  miss_state_en =    exu_flush_final | ifu_bp_hit_taken_q_f  | stream_eol_f   |  (bus_ifu_wr_en_ff & last_beat) | dec_tlu_force_halt ;\n         end\n         MISS_WAIT: begin : miss_wait\n                  miss_nxtstate =  (exu_flush_final & ~(bus_ifu_wr_en_ff & last_beat) & ~dec_tlu_force_halt) ? HIT_U_MISS  : IDLE ;\n                  miss_state_en =   exu_flush_final | (bus_ifu_wr_en_ff & last_beat) | dec_tlu_force_halt ;\n         end\n         HIT_U_MISS: begin : hit_u_miss\n                  miss_nxtstate =  ic_miss_under_miss_f & ~(bus_ifu_wr_en_ff & last_beat) & ~dec_tlu_force_halt ? SCND_MISS :\n                                   ic_ignore_2nd_miss_f & ~(bus_ifu_wr_en_ff & last_beat) & ~dec_tlu_force_halt ? STALL_SCND_MISS : IDLE  ;\n                  miss_state_en = (bus_ifu_wr_en_ff & last_beat) | ic_miss_under_miss_f | ic_ignore_2nd_miss_f | dec_tlu_force_halt;\n         end\n         SCND_MISS: begin : scnd_miss\n                  miss_nxtstate   = dec_tlu_force_halt ? IDLE  :\n                                    exu_flush_final ?  ((bus_ifu_wr_en_ff & last_beat) ? IDLE : HIT_U_MISS) : CRIT_BYP_OK;\n                  miss_state_en   = (bus_ifu_wr_en_ff & last_beat) | exu_flush_final | dec_tlu_force_halt;\n         end\n         STALL_SCND_MISS: begin : stall_scnd_miss\n                  miss_nxtstate   =  dec_tlu_force_halt ? IDLE  :\n                                     exu_flush_final ?  ((bus_ifu_wr_en_ff & last_beat) ? IDLE : HIT_U_MISS) : IDLE;\n                  miss_state_en   = (bus_ifu_wr_en_ff & last_beat) | exu_flush_final | dec_tlu_force_halt;\n         end\n         default: begin : def_case\n                  miss_nxtstate   = IDLE;\n                  miss_state_en   = 1'b0;\n         end\n      endcase\n   end\n   rvdffs #(($bits(miss_state_t))) miss_state_ff (.clk(active_clk), .din(miss_nxtstate), .dout({miss_state}), .en(miss_state_en),   .*);\n\n  logic    sel_hold_imb     ;\n\n   assign miss_pending       =  (miss_state != IDLE) ;\n   assign crit_wd_byp_ok_ff  =  (miss_state == CRIT_BYP_OK) | ((miss_state == CRIT_WRD_RDY) & ~flush_final_f);\n   assign sel_hold_imb       =  (miss_pending & ~(bus_ifu_wr_en_ff & last_beat) & ~((miss_state == CRIT_WRD_RDY) & exu_flush_final) &\n                              ~((miss_state == CRIT_WRD_RDY) & crit_byp_hit_f) ) | ic_act_miss_f |\n                                (miss_pending & (miss_nxtstate == CRIT_WRD_RDY)) ;\n\n\n   logic         sel_hold_imb_scnd;\n   logic  [31:1] imb_scnd_in;\n   logic  [31:1] imb_scnd_ff;\n   logic         uncacheable_miss_scnd_in ;\n   logic         uncacheable_miss_scnd_ff ;\n\n   logic  [pt.ICACHE_NUM_WAYS-1:0] tagv_mb_scnd_in;\n   logic  [pt.ICACHE_NUM_WAYS-1:0] tagv_mb_scnd_ff;\n\n   logic  [pt.ICACHE_STATUS_BITS-1:0] way_status_mb_scnd_in;\n   logic  [pt.ICACHE_STATUS_BITS-1:0] way_status_mb_scnd_ff;\n\n   assign sel_hold_imb_scnd                                =((miss_state == SCND_MISS) | ic_miss_under_miss_f) & ~flush_final_f ;\n   assign way_status_mb_scnd_in[pt.ICACHE_STATUS_BITS-1:0] = (miss_state == SCND_MISS) ? way_status_mb_scnd_ff[pt.ICACHE_STATUS_BITS-1:0] : {way_status[pt.ICACHE_STATUS_BITS-1:0]} ;\n   assign tagv_mb_scnd_in[pt.ICACHE_NUM_WAYS-1:0]          = (miss_state == SCND_MISS) ? tagv_mb_scnd_ff[pt.ICACHE_NUM_WAYS-1:0]          : ({ic_tag_valid[pt.ICACHE_NUM_WAYS-1:0]} & {pt.ICACHE_NUM_WAYS{~reset_all_tags & ~exu_flush_final}});\n   assign uncacheable_miss_scnd_in   = sel_hold_imb_scnd ? uncacheable_miss_scnd_ff : ifc_fetch_uncacheable_bf ;\n\n\n   rvdff_fpga #(1)  unc_miss_scnd_ff    (.*, .clk(fetch_bf_f_c1_clk), .clken(fetch_bf_f_c1_clken), .rawclk(clk), .din (uncacheable_miss_scnd_in), .dout(uncacheable_miss_scnd_ff));\n   rvdffpcie #(31) imb_f_scnd_ff       (.*, .en(fetch_bf_f_c1_clken),  .din ({imb_scnd_in[31:1]}), .dout({imb_scnd_ff[31:1]}));\n   rvdff_fpga #(pt.ICACHE_STATUS_BITS)  mb_rep_wayf2_scnd_ff (.*, .clk(fetch_bf_f_c1_clk), .clken(fetch_bf_f_c1_clken), .rawclk(clk), .din ({way_status_mb_scnd_in[pt.ICACHE_STATUS_BITS-1:0]}), .dout({way_status_mb_scnd_ff[pt.ICACHE_STATUS_BITS-1:0]}));\n   rvdff_fpga #(pt.ICACHE_NUM_WAYS)     mb_tagv_scnd_ff      (.*, .clk(fetch_bf_f_c1_clk), .clken(fetch_bf_f_c1_clken), .rawclk(clk), .din ({tagv_mb_scnd_in[pt.ICACHE_NUM_WAYS-1:0]}), .dout({tagv_mb_scnd_ff[pt.ICACHE_NUM_WAYS-1:0]}));\n\n\n\n\n   assign ic_req_addr_bits_hi_3[pt.ICACHE_BEAT_ADDR_HI:3] = bus_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0] ;\n   assign ic_wr_addr_bits_hi_3[pt.ICACHE_BEAT_ADDR_HI:3]  = ifu_bus_rid_ff[pt.ICACHE_BEAT_BITS-1:0] & {pt.ICACHE_BEAT_BITS{bus_ifu_wr_en_ff}};\n   // NOTE: Cacheline size is 16 bytes in this example.\n   // Tag     Index  Bank Offset\n   // [31:16] [15:5] [4]  [3:0]\n\n\n   assign fetch_req_icache_f   = ifc_fetch_req_f & ~ifc_iccm_access_f & ~ifc_region_acc_fault_final_f;\n   assign fetch_req_iccm_f     = ifc_fetch_req_f &  ifc_iccm_access_f;\n\n   assign ic_iccm_hit_f        = fetch_req_iccm_f  &  (~miss_pending | (miss_state==HIT_U_MISS) | (miss_state==STREAM));\n   assign ic_byp_hit_f         = (crit_byp_hit_f | stream_hit_f)  & fetch_req_icache_f &  miss_pending ;\n   assign ic_act_hit_f         = (|ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0]) & fetch_req_icache_f & ~reset_all_tags & (~miss_pending | (miss_state==HIT_U_MISS)) & ~sel_mb_addr_ff;\n   assign ic_act_miss_f        = (((~(|ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0]) | reset_all_tags) & fetch_req_icache_f & ~miss_pending) | scnd_miss_req) & ~ifc_region_acc_fault_final_f;\n   assign ic_miss_under_miss_f = (~(|ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0]) | reset_all_tags) & fetch_req_icache_f & (miss_state == HIT_U_MISS) &\n                                   (imb_ff[31:pt.ICACHE_TAG_INDEX_LO] != ifu_fetch_addr_int_f[31:pt.ICACHE_TAG_INDEX_LO]) & ~uncacheable_miss_ff & ~sel_mb_addr_ff & ~ifc_region_acc_fault_final_f;\n   assign ic_ignore_2nd_miss_f = (~(|ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0]) | reset_all_tags) & fetch_req_icache_f & (miss_state == HIT_U_MISS) &\n                                   ((imb_ff[31:pt.ICACHE_TAG_INDEX_LO] == ifu_fetch_addr_int_f[31:pt.ICACHE_TAG_INDEX_LO])  |   uncacheable_miss_ff) ;\n   assign ic_hit_f             =  ic_act_hit_f | ic_byp_hit_f | ic_iccm_hit_f | (ifc_region_acc_fault_final_f & ifc_fetch_req_f);\n\n   assign uncacheable_miss_in   = scnd_miss_req ? uncacheable_miss_scnd_ff : sel_hold_imb ? uncacheable_miss_ff : ifc_fetch_uncacheable_bf ;\n   assign imb_in[31:1]          = scnd_miss_req ? imb_scnd_ff[31:1]        : sel_hold_imb ? imb_ff[31:1] : {ifc_fetch_addr_bf[31:1]} ;\n\n   assign imb_scnd_in[31:1]     = sel_hold_imb_scnd ? imb_scnd_ff[31:1] : {ifc_fetch_addr_bf[31:1]} ;\n\n   assign scnd_miss_index_match  =  (imb_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] == imb_scnd_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]) & scnd_miss_req & ~ifu_wr_cumulative_err_data;\n   assign way_status_mb_in[pt.ICACHE_STATUS_BITS-1:0] = (scnd_miss_req & ~scnd_miss_index_match) ? way_status_mb_scnd_ff[pt.ICACHE_STATUS_BITS-1:0] :\n                                                        (scnd_miss_req &  scnd_miss_index_match) ? way_status_rep_new[pt.ICACHE_STATUS_BITS-1:0] :\n                                                         miss_pending                            ? way_status_mb_ff[pt.ICACHE_STATUS_BITS-1:0] :\n                                                                                                  {way_status[pt.ICACHE_STATUS_BITS-1:0]} ;\n   assign tagv_mb_in[pt.ICACHE_NUM_WAYS-1:0]          = scnd_miss_req ? (tagv_mb_scnd_ff[pt.ICACHE_NUM_WAYS-1:0] | ({pt.ICACHE_NUM_WAYS {scnd_miss_index_match}} & replace_way_mb_any[pt.ICACHE_NUM_WAYS-1:0])) :\n                                                         miss_pending ? tagv_mb_ff[pt.ICACHE_NUM_WAYS-1:0]  : ({ic_tag_valid[pt.ICACHE_NUM_WAYS-1:0]} & {pt.ICACHE_NUM_WAYS{~reset_all_tags & ~exu_flush_final}}) ;\n\n   assign reset_ic_in           = miss_pending & ~scnd_miss_req_q &  (reset_all_tags |  reset_ic_ff) ;\n\n\n\n   rvdffpcie #(31) ifu_fetch_addr_f_ff (.*, .en(fetch_bf_f_c1_clken), .din ({ifc_fetch_addr_bf[31:1]}), .dout({ifu_fetch_addr_int_f[31:1]}));\n\n   assign vaddr_f[pt.ICACHE_BEAT_ADDR_HI:1] = ifu_fetch_addr_int_f[pt.ICACHE_BEAT_ADDR_HI:1] ;\n\n   rvdffpcie #(31) imb_f_ff        (.*, .en(fetch_bf_f_c1_clken), .din (imb_in[31:1]), .dout(imb_ff[31:1]));\n   rvdff_fpga #(1) unc_miss_ff     (.*, .clk(fetch_bf_f_c1_clk), .clken(fetch_bf_f_c1_clken), .rawclk(clk),  .din ( uncacheable_miss_in),               .dout( uncacheable_miss_ff));\n\n\n   assign miss_addr_in[31:pt.ICACHE_BEAT_ADDR_HI+1]      = (~miss_pending                    ) ? imb_ff[31:pt.ICACHE_BEAT_ADDR_HI+1] :\n                                                           (                scnd_miss_req_q  ) ? imb_scnd_ff[31:pt.ICACHE_BEAT_ADDR_HI+1] : miss_addr[31:pt.ICACHE_BEAT_ADDR_HI+1] ;\n\n\n   rvdfflie #(.WIDTH(31-pt.ICACHE_BEAT_ADDR_HI),.LEFT(31-pt.ICACHE_BEAT_ADDR_HI-8)) miss_f_ff       (.*, .en(bus_ifu_bus_clk_en | ic_act_miss_f | dec_tlu_force_halt), .din ({miss_addr_in[31:pt.ICACHE_BEAT_ADDR_HI+1]}), .dout({miss_addr[31:pt.ICACHE_BEAT_ADDR_HI+1]}));\n\n\n\n\n\n   rvdff_fpga #(pt.ICACHE_STATUS_BITS)  mb_rep_wayf2_ff (.*, .clk(fetch_bf_f_c1_clk),  .clken(fetch_bf_f_c1_clken), .rawclk(clk),  .din ({way_status_mb_in[pt.ICACHE_STATUS_BITS-1:0]}), .dout({way_status_mb_ff[pt.ICACHE_STATUS_BITS-1:0]}));\n   rvdff_fpga #(pt.ICACHE_NUM_WAYS)     mb_tagv_ff      (.*, .clk(fetch_bf_f_c1_clk),  .clken(fetch_bf_f_c1_clken), .rawclk(clk),  .din ({tagv_mb_in[pt.ICACHE_NUM_WAYS-1:0]}), .dout({tagv_mb_ff[pt.ICACHE_NUM_WAYS-1:0]}));\n\n   assign ifc_fetch_req_qual_bf  = ifc_fetch_req_bf  & ~((miss_state == CRIT_WRD_RDY) & flush_final_f) & ~stream_miss_f ;// & ~exu_flush_final ;\n\n   assign ifc_fetch_req_f       = ifc_fetch_req_f_raw & ~exu_flush_final ;\n\n   rvdff_fpga #(1) ifu_iccm_acc_ff     (.*, .clk(fetch_bf_f_c1_clk), .clken(fetch_bf_f_c1_clken), .rawclk(clk),   .din(ifc_iccm_access_bf),      .dout(ifc_iccm_access_f));\n   rvdff_fpga #(1) ifu_iccm_reg_acc_ff (.*, .clk(fetch_bf_f_c1_clk), .clken(fetch_bf_f_c1_clken), .rawclk(clk),   .din(ifc_region_acc_fault_final_bf), .dout(ifc_region_acc_fault_final_f));\n   rvdff_fpga #(1) rgn_acc_ff          (.*, .clk(fetch_bf_f_c1_clk), .clken(fetch_bf_f_c1_clken), .rawclk(clk),   .din(ifc_region_acc_fault_bf),       .dout(ifc_region_acc_fault_f));\n\n\n   assign ifu_ic_req_addr_f[31:3]  = {miss_addr[31:pt.ICACHE_BEAT_ADDR_HI+1] , ic_req_addr_bits_hi_3[pt.ICACHE_BEAT_ADDR_HI:3] };\n   assign ifu_ic_mb_empty          = (((miss_state == HIT_U_MISS) | (miss_state == STREAM)) & ~(bus_ifu_wr_en_ff & last_beat)) |  ~miss_pending ;\n   assign ifu_miss_state_idle      = (miss_state == IDLE) ;\n\n\n   assign sel_mb_addr  = ((miss_pending & write_ic_16_bytes & ~uncacheable_miss_ff) | reset_tag_valid_for_miss) ;\n   assign ifu_ic_rw_int_addr[31:1] = ({31{ sel_mb_addr}}  &  {imb_ff[31:pt.ICACHE_BEAT_ADDR_HI+1] , ic_wr_addr_bits_hi_3[pt.ICACHE_BEAT_ADDR_HI:3] , imb_ff[2:1]})  |\n                                     ({31{~sel_mb_addr}}  &  ifc_fetch_addr_bf[31:1] )   ;\n\n   assign sel_mb_status_addr  = ((miss_pending & write_ic_16_bytes & ~uncacheable_miss_ff & last_beat & bus_ifu_wr_en_ff_q) | reset_tag_valid_for_miss) ;\n   assign ifu_status_wr_addr[31:1] = ({31{ sel_mb_status_addr}}  &  {imb_ff[31:pt.ICACHE_BEAT_ADDR_HI+1] , ic_wr_addr_bits_hi_3[pt.ICACHE_BEAT_ADDR_HI:3] , imb_ff[2:1]})  |\n                                     ({31{~sel_mb_status_addr}}  &  ifu_fetch_addr_int_f[31:1] )   ;\n\n\n  assign ic_rw_addr[31:1]      = ifu_ic_rw_int_addr[31:1] ;\n\n\nif (pt.ICACHE_ECC == 1) begin: icache_ecc_1\n   logic [6:0]       ic_wr_ecc;\n   logic [6:0]       ic_miss_buff_ecc;\n   logic [141:0]     ic_wr_16bytes_data ;\n   logic [70:0]      ifu_ic_debug_rd_data_in   ;\n\n                rvecc_encode_64  ic_ecc_encode_64_bus (\n                           .din    (ifu_bus_rdata_ff[63:0]),\n                           .ecc_out(ic_wr_ecc[6:0]));\n                rvecc_encode_64  ic_ecc_encode_64_buff (\n                           .din    (ic_miss_buff_half[63:0]),\n                           .ecc_out(ic_miss_buff_ecc[6:0]));\n\n   for (genvar i=0; i < pt.ICACHE_BANKS_WAY ; i++) begin : ic_wr_data_loop\n      assign ic_wr_data[i][70:0]  =  ic_wr_16bytes_data[((71*i)+70): (71*i)];\n   end\n\n\n   assign ic_debug_wr_data[70:0]   = {dec_tlu_ic_diag_pkt.icache_wrdata[70:0]} ;\n   assign ic_error_start           = ((|ic_eccerr[pt.ICACHE_BANKS_WAY-1:0]) & ic_act_hit_f)  | ic_rd_parity_final_err;\n\n\n\n  assign ifu_ic_debug_rd_data_in[70:0] = ic_debug_ict_array_sel_ff ? {2'b0,ictag_debug_rd_data[25:21],32'b0,ictag_debug_rd_data[20:0],{7-pt.ICACHE_STATUS_BITS{1'b0}}, way_status[pt.ICACHE_STATUS_BITS-1:0],3'b0,ic_debug_tag_val_rd_out} :\n                                                                     ic_debug_rd_data[70:0];\n\n  rvdffe #(71) ifu_debug_data_ff (.*,\n                                  .en (debug_data_clken),\n                                  .din ({\n                                         ifu_ic_debug_rd_data_in[70:0]\n                                         }),\n                                  .dout({\n                                         ifu_ic_debug_rd_data[70:0]\n                                         })\n                                  );\n\n  assign ic_wr_16bytes_data[141:0] =  ifu_bus_rid_ff[0] ? {ic_wr_ecc[6:0] , ifu_bus_rdata_ff[63:0] ,  ic_miss_buff_ecc[6:0] , ic_miss_buff_half[63:0] } :\n  "}
{"text": "                                                      {ic_miss_buff_ecc[6:0] ,  ic_miss_buff_half[63:0] , ic_wr_ecc[6:0] , ifu_bus_rdata_ff[63:0] } ;\n\n\nend\nelse begin : icache_parity_1\n   logic [3:0]   ic_wr_parity;\n   logic [3:0]   ic_miss_buff_parity;\n   logic [135:0] ic_wr_16bytes_data ;\n   logic [70:0]  ifu_ic_debug_rd_data_in   ;\n    for (genvar i=0 ; i < 4 ; i++) begin : DATA_PGEN\n       rveven_paritygen #(16) par_bus  (.data_in   (ifu_bus_rdata_ff[((16*i)+15):(16*i)]),\n                                      .parity_out(ic_wr_parity[i]));\n       rveven_paritygen #(16) par_buff  (.data_in   (ic_miss_buff_half[((16*i)+15):(16*i)]),\n                                      .parity_out(ic_miss_buff_parity[i]));\n    end\n\n\n   for (genvar i=0; i < pt.ICACHE_BANKS_WAY ; i++) begin : ic_wr_data_loop\n      assign ic_wr_data[i][70:0]  =  {3'b0, ic_wr_16bytes_data[((68*i)+67): (68*i)]};\n   end\n\n\n\n\n\n   assign ic_debug_wr_data[70:0]   = {dec_tlu_ic_diag_pkt.icache_wrdata[70:0]} ;\n   assign ic_error_start           = ((|ic_parerr[pt.ICACHE_BANKS_WAY-1:0]) & ic_act_hit_f) | ic_rd_parity_final_err;\n\n   assign ifu_ic_debug_rd_data_in[70:0] = ic_debug_ict_array_sel_ff ? {6'b0,ictag_debug_rd_data[21],32'b0,ictag_debug_rd_data[20:0],{7-pt.ICACHE_STATUS_BITS{1'b0}},way_status[pt.ICACHE_STATUS_BITS-1:0],3'b0,ic_debug_tag_val_rd_out} :\n                                                                      ic_debug_rd_data[70:0] ;\n\n   rvdffe #(71) ifu_debug_data_ff (.*,\n                                   .en (debug_data_clken),\n                                   .din ({\n                                          ifu_ic_debug_rd_data_in[70:0]\n                                          }),\n                                   .dout({\n                                          ifu_ic_debug_rd_data[70:0]\n                                          })\n                                   );\n\n   assign ic_wr_16bytes_data[135:0] =  ifu_bus_rid_ff[0] ? {ic_wr_parity[3:0] , ifu_bus_rdata_ff[63:0] ,  ic_miss_buff_parity[3:0] , ic_miss_buff_half[63:0] } :\n                                                        {ic_miss_buff_parity[3:0] ,  ic_miss_buff_half[63:0] , ic_wr_parity[3:0] , ifu_bus_rdata_ff[63:0] } ;\n\nend\n\n\n  assign ifu_wr_data_comb_err       =  bus_ifu_wr_data_error_ff ;\n  assign ifu_wr_cumulative_err      = (ifu_wr_data_comb_err | ifu_wr_data_comb_err_ff) & ~reset_beat_cnt;\n  assign ifu_wr_cumulative_err_data =  ifu_wr_data_comb_err | ifu_wr_data_comb_err_ff ;\n\n\n  assign sel_byp_data     =  (ic_crit_wd_rdy | (miss_state == STREAM) | (miss_state == CRIT_BYP_OK));\n  assign sel_ic_data      = ~(ic_crit_wd_rdy | (miss_state == STREAM) | (miss_state == CRIT_BYP_OK) | (miss_state == MISS_WAIT)) & ~fetch_req_iccm_f & ~ifc_region_acc_fault_final_f;\n\n if (pt.ICCM_ICACHE==1) begin: iccm_icache\n  assign sel_iccm_data    =  fetch_req_iccm_f  ;\n\n  assign ic_final_data[63:0]  = ({64{sel_byp_data | sel_iccm_data | sel_ic_data}} & {ic_rd_data[63:0]} ) ;\n\n  assign ic_premux_data[63:0] = ({64{sel_byp_data }} & {ic_byp_data_only_new[63:0]} ) |\n                          ({64{sel_iccm_data}} & {iccm_rd_data[63:0]});\n\n  assign ic_sel_premux_data = sel_iccm_data | sel_byp_data ;\n end\n\nif (pt.ICCM_ONLY == 1 ) begin: iccm_only\n  assign sel_iccm_data    =  fetch_req_iccm_f  ;\n  assign ic_final_data[63:0]  = ({64{sel_byp_data }} & {ic_byp_data_only_new[63:0]} ) |\n                          ({64{sel_iccm_data}} & {iccm_rd_data[63:0]});\n  assign ic_premux_data = '0 ;\n  assign ic_sel_premux_data = '0 ;\nend\n\nif (pt.ICACHE_ONLY == 1 ) begin: icache_only\n  assign ic_final_data[63:0]  = ({64{sel_byp_data | sel_ic_data}} & {ic_rd_data[63:0]} ) ;\n  assign ic_premux_data[63:0] = ({64{sel_byp_data }} & {ic_byp_data_only_new[63:0]} ) ;\n  assign ic_sel_premux_data =  sel_byp_data ;\nend\n\n\nif (pt.NO_ICCM_NO_ICACHE == 1 ) begin: no_iccm_no_icache\n  assign ic_final_data[63:0]  = ({64{sel_byp_data }} & {ic_byp_data_only_new[63:0]} ) ;\n  assign ic_premux_data = 0 ;\n  assign ic_sel_premux_data = '0 ;\nend\n\n\n  assign ifc_bus_acc_fault_f[1:0]   =  {2{ic_byp_hit_f}} & ifu_byp_data_err_f[1:0] ;\n  assign ic_data_f[31:0]      = ic_final_data[31:0];\n\n\n\nassign fetch_req_f_qual       = ic_hit_f & ~exu_flush_final;\nassign ic_access_fault_f[1:0]  = ({2{ifc_region_acc_fault_final_f}} | ifc_bus_acc_fault_f[1:0])  & {2{~exu_flush_final}};\nassign ic_access_fault_type_f[1:0] = |iccm_rd_ecc_double_err       ? 2'b01 :\n                                     ifc_region_acc_fault_f        ? 2'b10 :\n                                     ifc_region_acc_fault_memory_f ? 2'b11 :  2'b00 ;\n\n  // right justified\n\nassign ic_fetch_val_f[1] = fetch_req_f_qual & ifu_bp_inst_mask_f & ~(vaddr_f[pt.ICACHE_BEAT_ADDR_HI:1] == {pt.ICACHE_BEAT_ADDR_HI{1'b1}}) & (err_stop_state != ERR_FETCH2);\nassign ic_fetch_val_f[0] = fetch_req_f_qual ;\nassign two_byte_instr    =  (ic_data_f[1:0] != 2'b11 )  ;\n\n/////////////////////////////////////////////////////////////////////////////////////\n//  Create full buffer...                                                          //\n/////////////////////////////////////////////////////////////////////////////////////\n     logic [63:0]       ic_miss_buff_data_in;\n     assign ic_miss_buff_data_in[63:0] = ifu_bus_rsp_rdata[63:0];\n\n     for (genvar i=0; i<pt.ICACHE_NUM_BEATS; i++) begin :  wr_flop\n\n        assign write_fill_data[i]        =   bus_ifu_wr_en & (  (pt.IFU_BUS_TAG)'(i)  == ifu_bus_rsp_tag[pt.IFU_BUS_TAG-1:0]);\n\n        rvdffe #(32) byp_data_0_ff (.*,\n                                    .en (write_fill_data[i]),\n                                    .din (ic_miss_buff_data_in[31:0]),\n                                    .dout(ic_miss_buff_data[i*2][31:0])\n                                    );\n\n        rvdffe #(32) byp_data_1_ff (.*,\n                                    .en (write_fill_data[i]),\n                                    .din (ic_miss_buff_data_in[63:32]),\n                                    .dout(ic_miss_buff_data[i*2+1][31:0])\n                                    );\n\n        assign ic_miss_buff_data_valid_in[i]  = write_fill_data[i] ? 1'b1  : (ic_miss_buff_data_valid[i]  & ~ic_act_miss_f) ;\n\n        rvdff #(1) byp_data_valid_ff (.*,\n                  .clk (active_clk),\n                  .din (ic_miss_buff_data_valid_in[i]),\n                  .dout(ic_miss_buff_data_valid[i]));\n\n        assign ic_miss_buff_data_error_in[i]  = write_fill_data[i] ? bus_ifu_wr_data_error  : (ic_miss_buff_data_error[i]  & ~ic_act_miss_f) ;\n\n        rvdff #(1) byp_data_error_ff (.*,\n                  .clk (active_clk),\n                  .din (ic_miss_buff_data_error_in[i] ),\n                  .dout(ic_miss_buff_data_error[i]));\n     end\n\n/////////////////////////////////////////////////////////////////////////////////////\n// New bypass ready                                                                //\n/////////////////////////////////////////////////////////////////////////////////////\n   logic   [pt.ICACHE_BEAT_ADDR_HI:1]  bypass_index;\n   logic   [pt.ICACHE_BEAT_ADDR_HI:3]  bypass_index_5_3_inc;\n   logic   bypass_data_ready_in;\n   logic   ic_crit_wd_rdy_new_in;\n\n   assign bypass_index[pt.ICACHE_BEAT_ADDR_HI:1] = imb_ff[pt.ICACHE_BEAT_ADDR_HI:1] ;\n   assign bypass_index_5_3_inc[pt.ICACHE_BEAT_ADDR_HI:3] = bypass_index[pt.ICACHE_BEAT_ADDR_HI:3] + 1 ;\n\n\n   assign bypass_data_ready_in = ((ic_miss_buff_data_valid_in[bypass_index[pt.ICACHE_BEAT_ADDR_HI:3]]                                                      & ~bypass_index[2] & ~bypass_index[1])) |\n                                 ((ic_miss_buff_data_valid_in[bypass_index[pt.ICACHE_BEAT_ADDR_HI:3]]                                                      & ~bypass_index[2] &  bypass_index[1])) |\n                                 ((ic_miss_buff_data_valid_in[bypass_index[pt.ICACHE_BEAT_ADDR_HI:3]]                                                      &  bypass_index[2] & ~bypass_index[1])) |\n                                 ((ic_miss_buff_data_valid_in[bypass_index[pt.ICACHE_BEAT_ADDR_HI:3]] & ic_miss_buff_data_valid_in[bypass_index_5_3_inc[pt.ICACHE_BEAT_ADDR_HI:3]] &  bypass_index[2] & bypass_index[1])) |\n                                 ((ic_miss_buff_data_valid_in[bypass_index[pt.ICACHE_BEAT_ADDR_HI:3]] & (bypass_index[pt.ICACHE_BEAT_ADDR_HI:3] == {pt.ICACHE_BEAT_ADDR_HI{1'b1}})))   ;\n\n\n\n   assign    ic_crit_wd_rdy_new_in = ( bypass_data_ready_in & crit_wd_byp_ok_ff   &  uncacheable_miss_ff &  ~exu_flush_final & ~ifu_bp_hit_taken_q_f) |\n                                     (                        crit_wd_byp_ok_ff   & ~uncacheable_miss_ff &  ~exu_flush_final & ~ifu_bp_hit_taken_q_f) |\n                                     (ic_crit_wd_rdy_new_ff & ~fetch_req_icache_f & crit_wd_byp_ok_ff    &  ~exu_flush_final) ;\n\n\n  assign byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:1]          =    ifu_fetch_addr_int_f[pt.ICACHE_BEAT_ADDR_HI:1]       ;\n  assign byp_fetch_index_0[pt.ICACHE_BEAT_ADDR_HI:2]        =   {ifu_fetch_addr_int_f[pt.ICACHE_BEAT_ADDR_HI:3],1'b0} ;\n  assign byp_fetch_index_1[pt.ICACHE_BEAT_ADDR_HI:2]        =   {ifu_fetch_addr_int_f[pt.ICACHE_BEAT_ADDR_HI:3],1'b1} ;\n  assign byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]      =    ifu_fetch_addr_int_f[pt.ICACHE_BEAT_ADDR_HI:3]+1'b1 ;\n  assign byp_fetch_index_inc_0[pt.ICACHE_BEAT_ADDR_HI:2]    =   {byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3], 1'b0} ;\n  assign byp_fetch_index_inc_1[pt.ICACHE_BEAT_ADDR_HI:2]    =   {byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3], 1'b1} ;\n\n  assign  ifu_byp_data_err_new = (~ifu_fetch_addr_int_f[2] &  ~ifu_fetch_addr_int_f[1] &                                                                           ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] )  |\n                                 (~ifu_fetch_addr_int_f[2] &   ifu_fetch_addr_int_f[1] &                                                                           ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] )  |\n                                 ( ifu_fetch_addr_int_f[2] &  ~ifu_fetch_addr_int_f[1] &                                                                           ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] )  |\n                                 ( ifu_fetch_addr_int_f[2] &   ifu_fetch_addr_int_f[1] & (ic_miss_buff_data_error[byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]] | ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] )) ;\n\n  assign  ifu_byp_data_err_f[1:0]  =   (ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] )  ? 2'b11 :\n                                      ( ifu_fetch_addr_int_f[2] &  ifu_fetch_addr_int_f[1] &   ~(ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] ) & (~miss_wrap_f & ic_miss_buff_data_error[byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]])) ? 2'b10 : 2'b00;\n\n\n\n\n\n  assign ic_byp_data_only_pre_new[79:0] =  ({80{~ifu_fetch_addr_int_f[2]}} &   {ic_miss_buff_data[byp_fetch_index_inc_0][15:0],ic_miss_buff_data[byp_fetch_index_1][31:0]     , ic_miss_buff_data[byp_fetch_index_0][31:0]}) |\n                                           ({80{ ifu_fetch_addr_int_f[2]}} &   {ic_miss_buff_data[byp_fetch_index_inc_1][15:0],ic_miss_buff_data[byp_fetch_index_inc_0][31:0] , ic_miss_buff_data[byp_fetch_index_1][31:0]}) ;\n\n  assign ic_byp_data_only_new[79:0]      = ~ifu_fetch_addr_int_f[1] ? {ic_byp_data_only_pre_new[79:0]} :\n                                                                      {16'b0,ic_byp_data_only_pre_new[79:16]} ;\n\n  assign miss_wrap_f      =  (imb_ff[pt.ICACHE_TAG_INDEX_LO] != ifu_fetch_addr_int_f[pt.ICACHE_TAG_INDEX_LO] ) ;\n\n  assign miss_buff_hit_unq_f  = ((ic_miss_buff_data_valid[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]]                                                     & ~byp_fetch_index[2] & ~byp_fetch_index[1])) |\n                             ((ic_miss_buff_data_valid[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]]                                                     & ~byp_fetch_index[2] &  byp_fetch_index[1])) |\n                             ((ic_miss_buff_data_valid[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]]                                                     &  byp_fetch_index[2] & ~byp_fetch_index[1])) |\n                             ((ic_miss_buff_data_valid[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] & ic_miss_buff_data_valid[byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]] &  byp_fetch_index[2] &  byp_fetch_index[1])) |\n                             ((ic_miss_buff_data_valid[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] &  (byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3] == {pt.ICACHE_BEAT_BITS{1'b1}})))   ;\n\n  assign stream_hit_f     =  (miss_buff_hit_unq_f & ~miss_wrap_f ) & (miss_state==STREAM) ;\n  assign stream_miss_f    = ~(miss_buff_hit_unq_f & ~miss_wrap_f ) & (miss_state==STREAM) & ifc_fetch_req_f;\n  assign stream_eol_f     =  (byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:2] == {pt.ICACHE_BEAT_BITS+1{1'b1}}) & ifc_fetch_req_f & stream_hit_f;\n\n  assign crit_byp_hit_f   =  (miss_buff_hit_unq_f ) & ((miss_state == CRIT_WRD_RDY) | (miss_state==CRIT_BYP_OK)) ;\n\n/////////////////////////////////////////////////////////////////////////////////////\n// Figure out if you have the data to write.                                       //\n/////////////////////////////////////////////////////////////////////////////////////\n\nassign other_tag[pt.IFU_BUS_TAG-1:0] = {ifu_bus_rid_ff[pt.IFU_BUS_TAG-1:1] , ~ifu_bus_rid_ff[0] } ;\nassign second_half_available      = ic_miss_buff_data_valid[other_tag] ;\nassign write_ic_16_bytes          = second_half_available & bus_ifu_wr_en_ff ;\nassign ic_miss_buff_half[63:0]    = {ic_miss_buff_data[{other_tag,1'b1}],ic_miss_buff_data[{other_tag,1'b0}] } ;\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n// Parity checking logic for Icache logic.                                         //\n/////////////////////////////////////////////////////////////////////////////////////\n\n\nassign ic_rd_parity_final_err = ic_tag_perr & ~exu_flush_final & sel_ic_data & ~(ifc_region_acc_fault_final_f | (|ifc_bus_acc_fault_f)) &\n                                      (fetch_req_icache_f & ~reset_all_tags & (~miss_pending | (miss_state==HIT_U_MISS)) & ~sel_mb_addr_ff);\n\nlogic [pt.ICACHE_NUM_WAYS-1:0]                   perr_err_inv_way;\nlogic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]   perr_ic_index_ff;\nlogic                                         perr_sel_invalidate;\nlogic                                         perr_sb_write_status   ;\n\n\n\n   rvdffe #(.WIDTH(pt.ICACHE_INDEX_HI-pt.ICACHE_TAG_INDEX_LO+1),.OVERRIDE(1)) perr_dat_ff    (.din(ifu_ic_rw_int_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]), .dout(perr_ic_index_ff[pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO]), .en(perr_sb_write_status),  .*);\n\n   assign perr_err_inv_way[pt.ICACHE_NUM_WAYS-1:0]   =  {pt.ICACHE_NUM_WAYS{perr_sel_invalidate}} ;\n   assign iccm_correct_ecc     = (perr_state == ECC_CORR);\n   assign dma_sb_err_state     = (perr_state == DMA_SB_ERR);\n   assign iccm_buf_correct_ecc = iccm_correct_ecc & ~dma_sb_err_state_ff;\n\n\n\n   //////////////////////////////////// Create Parity Error State Machine ///////////////////////\n   //                                   Create Parity Error State Machine                      //\n   //                                   Create Parity Error State Machine                      //\n   //                                   Create Parity Error State Machine                      //\n   //////////////////////////////////// Create Parity Error State Machine ///////////////////////\n\n\n   // FIFO state machine\n   always_comb begin  : ERROR_SM\n      perr_nxtstate            = ERR_IDLE;\n      perr_state_en            = 1'b0;\n      perr_sb_write_status     = 1'b0;\n      perr_sel_invalidate      = 1'b0;\n\n      case (perr_state)\n         ERR_IDLE: begin : err_idle\n                  perr_nxtstate         =  iccm_dma_sb_error ? DMA_SB_ERR : (ic_error_start & ~exu_flush_final) ? IC_WFF : ECC_WFF;\n                  perr_state_en         =  (((iccm_error_start | ic_error_start) & ~dec_tlu_flush_lower_wb) | iccm_dma_sb_error) & ~dec_tlu_force_halt;\n                  perr_sb_write_status  =  perr_state_en;\n         end\n         IC_WFF: begin : icache_wff    // All the I$ data and/or Tag errors ( parity/ECC ) will come to this state\n                  perr_nxtstate       =  ERR_IDLE ;\n                  perr_state_en       =   dec_tlu_flush_lower_wb | dec_tlu_force_halt ;\n                  perr_sel_invalidate =  (dec_tlu_flush_err_wb &  dec_tlu_flush_lower_wb);\n         end\n         ECC_WFF: begin : ecc_wff\n                  perr_nxtstate       =  ((~dec_tlu_flush_err_wb &  dec_tlu_flush_lower_wb ) | dec_tlu_force_halt) ? ERR_IDLE : ECC_CORR ;\n                  perr_state_en       =   dec_tlu_flush_lower_wb | dec_tlu_force_halt  ;\n         end\n         DMA_SB_ERR : begin : dma_sb_ecc\n                 perr_nxtstate       = dec_tlu_force_halt ? ERR_IDLE : ECC_CORR;\n                 perr_state_en       = 1'b1;\n         end\n         ECC_CORR: begin : ecc_corr\n                  perr_nxtstate       =  ERR_IDLE  ;\n                  perr_state_en       =   1'b1   ;\n         end\n         default: begin : def_case\n                  perr_nxtstate            = ERR_IDLE;\n                  perr_state_en            = 1'b0;\n                  perr_sb_write_status     = 1'b0;\n                  perr_sel_invalidate      = 1'b0;\n         end\n      endcase\n   end\n\n   rvdffs #(($bits(perr_state_t))) perr_state_ff (.clk(active_clk), .din(perr_nxtstate), .dout({perr_state}), .en(perr_state_en),   .*);\n\n   //////////////////////////////////// Create stop fetch State Machine /////////////////////////\n   //////////////////////////////////// Create stop fetch State Machine /////////////////////////\n   //////////////////////////////////// Create stop fetch State Machine /////////////////////////\n   //////////////////////////////////// Create stop fetch State Machine /////////////////////////\n   //////////////////////////////////// Create stop fetch State Machine /////////////////////////\n   always_comb begin  : ERROR_STOP_FETCH\n      err_stop_nxtstate            = ERR_STOP_IDLE;\n      err_stop_state_en            = 1'b0;\n      err_stop_fetch               = 1'b0;\n      iccm_correction_state        = 1'b0;\n\n      case (err_stop_state)\n         ERR_STOP_IDLE: begin : err_stop_idle\n                  err_stop_nxtstate         =  ERR_FETCH1;\n                  err_stop_state_en         =  dec_tlu_flush_err_wb & (perr_state  == ECC_WFF) & ~dec_tlu_force_halt;\n         end\n         ERR_FETCH1: begin : err_fetch1    // All the I$ data and/or Tag errors ( parity/ECC ) will come to this state\n                  err_stop_nxtstate       =  (dec_tlu_flush_lower_wb | dec_tlu_i0_commit_cmt | dec_tlu_force_halt) ? ERR_STOP_IDLE : ((ifu_fetch_val[1:0] == 2'b11) | (ifu_fetch_val[0] & two_byte_instr))   ?  ERR_STOP_FETCH : ifu_fetch_val[0] ? ERR_FETCH2 :  ERR_FETCH1;\n                  err_stop_state_en       =   dec_tlu_flush_lower_wb | dec_tlu_i0_commit_cmt | ifu_fetch_val[0] | ifu_bp_hit_taken_q_f | dec_tlu_force_halt;\n                  err_stop_fetch          =   ((ifu_fetch_val[1:0] == 2'b11) | (ifu_fetch_val[0] & two_byte_instr))  & ~(exu_flush_final | dec_tlu_i0_commit_cmt);\n                  iccm_correction_state   = 1'b1;\n\n        end\n         ERR_FETCH2: begin : err_fetch2    // All the I$ data and/or Tag errors ( parity/ECC ) will come to this state\n                  err_stop_nxtstate       =  (dec_tlu_flush_lower_wb | dec_tlu_i0_commit_cmt | dec_tlu_force_halt) ? ERR_STOP_IDLE : ifu_fetch_val[0] ?  ERR_STOP_FETCH : ERR_FETCH2;\n                  err_stop_state_en       =   dec_tlu_flush_lower_wb | dec_tlu_i0_commit_cmt | ifu_fetch_val[0] | dec_tlu_force_halt ;\n                  err_stop_fetch          =   ifu_fetch_val[0] & ~exu_flush_final & ~dec_tlu_i0_commit_cmt ;\n                  iccm_correction_state   = 1'b1;\n\n         end\n         ERR_STOP_FETCH: begin : ecc_wff\n                  err_stop_nxtstate       =  ( (dec_t"}
{"text": "lu_flush_lower_wb & ~dec_tlu_flush_err_wb) | dec_tlu_i0_commit_cmt | dec_tlu_force_halt) ? ERR_STOP_IDLE : dec_tlu_flush_err_wb ? ERR_FETCH1 : ERR_STOP_FETCH ;\n                  err_stop_state_en       =   dec_tlu_flush_lower_wb |  dec_tlu_i0_commit_cmt | dec_tlu_force_halt   ;\n                  err_stop_fetch          =  1'b1;\n                  iccm_correction_state   = 1'b1;\n\n         end\n         default: begin : def_case\n                  err_stop_nxtstate            = ERR_STOP_IDLE;\n                  err_stop_state_en            = 1'b0;\n                  err_stop_fetch               = 1'b0 ;\n                  iccm_correction_state   = 1'b1;\n\n         end\n      endcase\n   end\n   rvdffs #(($bits(err_stop_state_t))) err_stop_state_ff (.clk(active_clk), .din(err_stop_nxtstate), .dout({err_stop_state}), .en(err_stop_state_en),   .*);\n\n\n\n   assign bus_ifu_bus_clk_en =  ifu_bus_clk_en ;\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign busclk = 1'b0;\n   assign busclk_force = 1'b0;\n`else\n   rvclkhdr bus_clk_f(.en(bus_ifu_bus_clk_en), .l1clk(busclk), .*);\n   rvclkhdr bus_clk(.en(bus_ifu_bus_clk_en | dec_tlu_force_halt), .l1clk(busclk_force), .*);\n`endif\n\n\n\n   assign  scnd_miss_req = scnd_miss_req_q & ~exu_flush_final;\n\n   assign  ifc_bus_ic_req_ff_in  = (ic_act_miss_f | bus_cmd_req_hold | ifu_bus_cmd_valid) & ~dec_tlu_force_halt & ~((bus_cmd_beat_count== {pt.ICACHE_BEAT_BITS{1'b1}}) & ifu_bus_cmd_valid & ifu_bus_cmd_ready & miss_pending);\n\n   rvdff_fpga #(1) bus_ic_req_ff2(.*, .clk(busclk_force), .clken(bus_ifu_bus_clk_en | dec_tlu_force_halt), .rawclk(clk), .din(ifc_bus_ic_req_ff_in), .dout(ifu_bus_cmd_valid));\n\n   assign    bus_cmd_req_in  = (ic_act_miss_f | bus_cmd_req_hold) & ~bus_cmd_sent & ~dec_tlu_force_halt ; // hold until first command sent\n\n\n\n    // AXI command signals\n    //  Read Channel\n    assign ifu_axi_arvalid               =  ifu_bus_cmd_valid ;\n    assign ifu_axi_arid[pt.IFU_BUS_TAG-1:0] = ((pt.IFU_BUS_TAG)'(bus_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0])) & {pt.IFU_BUS_TAG{ifu_bus_cmd_valid}};\n    assign ifu_axi_araddr[31:0]          =   {ifu_ic_req_addr_f[31:3],3'b0}  & {32{ifu_bus_cmd_valid}};\n    assign ifu_axi_arsize[2:0]           =  3'b011;\n    assign ifu_axi_arprot[2:0]           = 3'b101;\n    assign ifu_axi_arcache[3:0]          = 4'b1111;\n    assign ifu_axi_arregion[3:0]         = ifu_ic_req_addr_f[31:28];\n    assign ifu_axi_arlen[7:0]            = '0;\n    assign ifu_axi_arburst[1:0]          = 2'b01;\n    assign ifu_axi_arqos[3:0]            = '0;\n    assign ifu_axi_arlock                = '0;\n    assign ifu_axi_rready                = 1'b1;\n\n    //  Write Channel\n    assign ifu_axi_awvalid                  = '0 ;\n    assign ifu_axi_awid[pt.IFU_BUS_TAG-1:0] = '0 ;\n    assign ifu_axi_awaddr[31:0]             = '0 ;\n    assign ifu_axi_awsize[2:0]              = '0 ;\n    assign ifu_axi_awprot[2:0]              = '0;\n    assign ifu_axi_awcache[3:0]             = '0 ;\n    assign ifu_axi_awregion[3:0]            = '0 ;\n    assign ifu_axi_awlen[7:0]               = '0;\n    assign ifu_axi_awburst[1:0]             = '0 ;\n    assign ifu_axi_awqos[3:0]               = '0;\n    assign ifu_axi_awlock                   = '0;\n\n    assign ifu_axi_wvalid                =  '0;\n    assign ifu_axi_wstrb[7:0]            =  '0;\n    assign ifu_axi_wdata[63:0]           =  '0;\n    assign ifu_axi_wlast                 =  '0;\n    assign ifu_axi_bready                =  '0;\n\n\n   assign ifu_bus_arready_unq     =  ifu_axi_arready ;\n   assign ifu_bus_rvalid_unq      =  ifu_axi_rvalid ;\n   assign ifu_bus_arvalid         =  ifu_axi_arvalid ;\n\n   rvdff_fpga #(1)               bus_rdy_ff      (.*, .clk(busclk),  .clken(bus_ifu_bus_clk_en), .rawclk(clk), .din(ifu_bus_arready_unq),            .dout(ifu_bus_arready_unq_ff));\n   rvdff_fpga #(1)               bus_rsp_vld_ff  (.*, .clk(busclk),  .clken(bus_ifu_bus_clk_en), .rawclk(clk), .din(ifu_bus_rvalid_unq),             .dout(ifu_bus_rvalid_unq_ff));\n   rvdff_fpga #(1)               bus_cmd_ff      (.*, .clk(busclk),  .clken(bus_ifu_bus_clk_en), .rawclk(clk), .din(ifu_bus_arvalid),                .dout(ifu_bus_arvalid_ff));\n   rvdff_fpga #(2)               bus_rsp_cmd_ff  (.*, .clk(busclk),  .clken(bus_ifu_bus_clk_en), .rawclk(clk), .din(ifu_axi_rresp[1:0]),             .dout(ifu_bus_rresp_ff[1:0]));\n   rvdff_fpga #(pt.IFU_BUS_TAG)  bus_rsp_tag_ff  (.*, .clk(busclk),  .clken(bus_ifu_bus_clk_en), .rawclk(clk), .din(ifu_axi_rid[pt.IFU_BUS_TAG-1:0]),.dout(ifu_bus_rid_ff[pt.IFU_BUS_TAG-1:0]));\n   rvdffe #(64)                  bus_data_ff     (.*, .clk(clk),     .din(ifu_axi_rdata[63:0]),            .dout(ifu_bus_rdata_ff[63:0]), .en(ifu_bus_clk_en & ifu_axi_rvalid));\n\n   assign ifu_bus_cmd_ready = ifu_axi_arready ;\n   assign ifu_bus_rsp_valid = ifu_axi_rvalid ;\n   assign ifu_bus_rsp_ready = ifu_axi_rready ;\n   assign ifu_bus_rsp_tag[pt.IFU_BUS_TAG-1:0] = ifu_axi_rid[pt.IFU_BUS_TAG-1:0] ;\n   assign ifu_bus_rsp_rdata[63:0] = ifu_axi_rdata[63:0] ;\n   assign ifu_bus_rsp_opc[1:0] = {ifu_axi_rresp[1:0]} ;\n\n\n\n\n\n\n\n\n\n   // Create write signals so we can write to the miss-buffer directly from the bus.\n\n   assign ifu_bus_rvalid            =  ifu_bus_rsp_valid & bus_ifu_bus_clk_en ;\n\n\n\n   assign ifu_bus_arready            =  ifu_bus_arready_unq    & bus_ifu_bus_clk_en    ;\n   assign ifu_bus_arready_ff         =  ifu_bus_arready_unq_ff & bus_ifu_bus_clk_en_ff ;\n\n   assign ifu_bus_rvalid_ff          =  ifu_bus_rvalid_unq_ff & bus_ifu_bus_clk_en_ff ;\n   assign bus_cmd_sent               =  ifu_bus_arvalid & ifu_bus_arready & miss_pending & ~dec_tlu_force_halt;\n   assign bus_inc_data_beat_cnt      = (bus_ifu_wr_en_ff & ~bus_last_data_beat & ~dec_tlu_force_halt) ;\n   assign bus_reset_data_beat_cnt    =  ic_act_miss_f | (bus_ifu_wr_en_ff &  bus_last_data_beat) | dec_tlu_force_halt;\n   assign bus_hold_data_beat_cnt     = ~bus_inc_data_beat_cnt & ~bus_reset_data_beat_cnt ;\n\n   assign bus_new_data_beat_count[pt.ICACHE_BEAT_BITS-1:0] = ({pt.ICACHE_BEAT_BITS{bus_reset_data_beat_cnt}} & (pt.ICACHE_BEAT_BITS)'(0)) |\n                                                          ({pt.ICACHE_BEAT_BITS{bus_inc_data_beat_cnt}}   & (bus_data_beat_count[pt.ICACHE_BEAT_BITS-1:0] + {{pt.ICACHE_BEAT_BITS-1{1'b0}},1'b1})) |\n                                                          ({pt.ICACHE_BEAT_BITS{bus_hold_data_beat_cnt}}  &  bus_data_beat_count[pt.ICACHE_BEAT_BITS-1:0]);\n\n\n   assign last_data_recieved_in =  (bus_ifu_wr_en_ff &  bus_last_data_beat & ~scnd_miss_req) | (last_data_recieved_ff & ~ic_act_miss_f) ;\n\n\n\n// Request Address Count\n   assign bus_new_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0] = (~miss_pending                    ) ? imb_ff[pt.ICACHE_BEAT_ADDR_HI:3] :\n                                                           (                scnd_miss_req_q  ) ? imb_scnd_ff[pt.ICACHE_BEAT_ADDR_HI:3] :\n                                                           ( bus_cmd_sent                    ) ? (bus_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0] + 3'b001) :\n                                                                                                  bus_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0];\n\n   rvdff_fpga #(pt.ICACHE_BEAT_BITS)  bus_rd_addr_ff (.*,  .clk(busclk_reset),  .clken (bus_ifu_bus_clk_en | ic_act_miss_f | dec_tlu_force_halt), .rawclk(clk), .din ({bus_new_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0]}), .dout({bus_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0]}));\n\n\n\n// command beat Count\n   assign bus_inc_cmd_beat_cnt              =  ifu_bus_cmd_valid    &  ifu_bus_cmd_ready & miss_pending & ~dec_tlu_force_halt;\n   assign bus_reset_cmd_beat_cnt_0          =  (ic_act_miss_f        & ~uncacheable_miss_in) | dec_tlu_force_halt ;\n   assign bus_reset_cmd_beat_cnt_secondlast =  ic_act_miss_f        &  uncacheable_miss_in ;\n   assign bus_hold_cmd_beat_cnt             = ~bus_inc_cmd_beat_cnt & ~(ic_act_miss_f | scnd_miss_req | dec_tlu_force_halt) ;\n   assign bus_cmd_beat_en                   =  bus_inc_cmd_beat_cnt | ic_act_miss_f | dec_tlu_force_halt;\n\n   assign bus_new_cmd_beat_count[pt.ICACHE_BEAT_BITS-1:0] =  ({pt.ICACHE_BEAT_BITS{bus_reset_cmd_beat_cnt_0}}       & (pt.ICACHE_BEAT_BITS)'(0) ) |\n                                                          ({pt.ICACHE_BEAT_BITS{bus_reset_cmd_beat_cnt_secondlast}} & (pt.ICACHE_BEAT_BITS)'(pt.ICACHE_SCND_LAST)) |\n                                                          ({pt.ICACHE_BEAT_BITS{bus_inc_cmd_beat_cnt}}              & (bus_cmd_beat_count[pt.ICACHE_BEAT_BITS-1:0] + {{pt.ICACHE_BEAT_BITS-1{1'b0}}, 1'b1})) |\n                                                          ({pt.ICACHE_BEAT_BITS{bus_hold_cmd_beat_cnt}}             &  bus_cmd_beat_count[pt.ICACHE_BEAT_BITS-1:0]) ;\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign busclk_reset = 1'b0;\n`else\n   rvclkhdr bus_clk_reset(.en(bus_ifu_bus_clk_en | ic_act_miss_f | dec_tlu_force_halt), .l1clk(busclk_reset), .*);\n`endif\n\n\n\n   rvdffs_fpga #(pt.ICACHE_BEAT_BITS)  bus_cmd_beat_ff (.*, .clk(busclk_reset), .clken (bus_ifu_bus_clk_en | ic_act_miss_f | dec_tlu_force_halt), .rawclk(clk), .en (bus_cmd_beat_en), .din ({bus_new_cmd_beat_count[pt.ICACHE_BEAT_BITS-1:0]}),\n                    .dout({bus_cmd_beat_count[pt.ICACHE_BEAT_BITS-1:0]}));\n\n\n    assign bus_last_data_beat     =  uncacheable_miss_ff ? (bus_data_beat_count[pt.ICACHE_BEAT_BITS-1:0] == {{pt.ICACHE_BEAT_BITS-1{1'b0}},1'b1}) : (&bus_data_beat_count[pt.ICACHE_BEAT_BITS-1:0]);\n\n   assign  bus_ifu_wr_en            =  ifu_bus_rvalid     & miss_pending ;\n   assign  bus_ifu_wr_en_ff         =  ifu_bus_rvalid_ff  & miss_pending ;\n   assign  bus_ifu_wr_en_ff_q       =  ifu_bus_rvalid_ff  & miss_pending & ~uncacheable_miss_ff & ~(|ifu_bus_rresp_ff[1:0]) & write_ic_16_bytes; // qualify with no-error conditions ;\n   assign  bus_ifu_wr_en_ff_wo_err  =  ifu_bus_rvalid_ff & miss_pending &  ~uncacheable_miss_ff;\n\n\n   rvdffie #(10) misc_ff\n       ( .*,\n         .clk(free_l2clk),\n         .din( {ic_act_miss_f,        ifu_wr_cumulative_err,exu_flush_final,  ic_crit_wd_rdy_new_in,bus_ifu_bus_clk_en,   scnd_miss_req_in,bus_cmd_req_in,  last_data_recieved_in,\nifc_dma_access_ok_d,   dma_iccm_req}),\n         .dout({ic_act_miss_f_delayed,ifu_wr_data_comb_err_ff,  flush_final_f,ic_crit_wd_rdy_new_ff,bus_ifu_bus_clk_en_ff,scnd_miss_req_q, bus_cmd_req_hold,last_data_recieved_ff,\nifc_dma_access_ok_prev,dma_iccm_req_f})\n         );\n\n   rvdffie #(.WIDTH(pt.ICACHE_BEAT_BITS+5),.OVERRIDE(1)) misc1_ff\n       ( .*,\n         .clk(free_l2clk),\n         .din( {reset_ic_in,sel_mb_addr,   bus_new_data_beat_count[pt.ICACHE_BEAT_BITS-1:0],ifc_region_acc_fault_memory_bf,ic_debug_rd_en,       ic_debug_rd_en_ff}),\n         .dout({reset_ic_ff,sel_mb_addr_ff,bus_data_beat_count[pt.ICACHE_BEAT_BITS-1:0],    ifc_region_acc_fault_memory_f, ic_debug_rd_en_ff,ifu_ic_debug_rd_data_valid})\n         );\n\n   assign    reset_tag_valid_for_miss = ic_act_miss_f_delayed & (miss_state == CRIT_BYP_OK) & ~uncacheable_miss_ff;\n   assign    bus_ifu_wr_data_error    = |ifu_bus_rsp_opc[1:0] &  ifu_bus_rvalid  & miss_pending;\n   assign    bus_ifu_wr_data_error_ff = |ifu_bus_rresp_ff[1:0] &  ifu_bus_rvalid_ff  & miss_pending;\n\n\n   assign ic_crit_wd_rdy   =  ic_crit_wd_rdy_new_in | ic_crit_wd_rdy_new_ff ;\n   assign last_beat        =  bus_last_data_beat & bus_ifu_wr_en_ff;\n   assign reset_beat_cnt    = bus_reset_data_beat_cnt ;\n\n// DMA\n   // Making sure that the dma_access is allowed when we have 2 back to back dma_access_ok. Also gating with current state == idle\n   assign ifc_dma_access_ok_d  = ifc_dma_access_ok &  ~iccm_correct_ecc & ~iccm_dma_sb_error;\n   assign ifc_dma_access_q_ok  = ifc_dma_access_ok &  ~iccm_correct_ecc & ifc_dma_access_ok_prev &  (perr_state == ERR_IDLE)  & ~iccm_dma_sb_error;\n   assign iccm_ready           = ifc_dma_access_q_ok ;\n\n   logic [1:0]        iccm_ecc_word_enable;\n\n    if (pt.ICCM_ENABLE == 1 ) begin: iccm_enabled\n         logic  [3:2] dma_mem_addr_ff  ;\n         logic  iccm_dma_rden    ;\n\n         logic  iccm_dma_ecc_error_in;\n         logic  [13:0] dma_mem_ecc;\n         logic  [63:0] iccm_dma_rdata_in;\n         logic  [31:0] iccm_dma_rdata_1_muxed;\n         logic [1:0] [31:0] iccm_corrected_data;\n         logic [1:0] [06:0] iccm_corrected_ecc;\n\n\n         logic [1:0]        iccm_double_ecc_error;\n\n\n         logic [pt.ICCM_BITS-1:2]       iccm_rw_addr_f;\n\n         logic [31:0]       iccm_corrected_data_f_mux;\n         logic [06:0]       iccm_corrected_ecc_f_mux;\n         logic              iccm_dma_rvalid_in;\n         logic [77:0]       iccm_rdmux_data;\n         logic              iccm_rd_ecc_single_err_hold_in ;\n         logic [2:0]        dma_mem_tag_ff;\n\n\n\n\n         assign iccm_wren          =  (ifc_dma_access_q_ok & dma_iccm_req &  dma_mem_write) | iccm_correct_ecc;\n         assign iccm_rden          =  (ifc_dma_access_q_ok & dma_iccm_req & ~dma_mem_write) | (ifc_iccm_access_bf & ifc_fetch_req_bf);\n         assign iccm_dma_rden      =  (ifc_dma_access_q_ok & dma_iccm_req & ~dma_mem_write)                     ;\n         assign iccm_wr_size[2:0]  =  {3{dma_iccm_req}}    & dma_mem_sz[2:0] ;\n\n         rvecc_encode  iccm_ecc_encode0 (\n                           .din(dma_mem_wdata[31:0]),\n                           .ecc_out(dma_mem_ecc[6:0]));\n\n         rvecc_encode  iccm_ecc_encode1 (\n                           .din(dma_mem_wdata[63:32]),\n                           .ecc_out(dma_mem_ecc[13:7]));\n\n        assign iccm_wr_data[77:0]   =  (iccm_correct_ecc & ~(ifc_dma_access_q_ok & dma_iccm_req)) ?  {iccm_ecc_corr_data_ff[38:0], iccm_ecc_corr_data_ff[38:0]} :\n                                       {dma_mem_ecc[13:7],dma_mem_wdata[63:32], dma_mem_ecc[6:0],dma_mem_wdata[31:0]};\n\n         assign iccm_dma_rdata_1_muxed[31:0] = dma_mem_addr_ff[2] ?  iccm_corrected_data[0][31:0] : iccm_corrected_data[1][31:0] ;\n         assign iccm_dma_rdata_in[63:0]      = iccm_dma_ecc_error_in ? {2{dma_mem_addr[31:0]}} : {iccm_dma_rdata_1_muxed[31:0], iccm_corrected_data[0]};\n         assign iccm_dma_ecc_error_in   =   |(iccm_double_ecc_error[1:0]);\n\n         rvdffe    #(64) dma_data_ff      (.*, .clk(clk), .en(iccm_dma_rvalid_in),  .din(iccm_dma_rdata_in[63:0]), .dout(iccm_dma_rdata[63:0]));\n         rvdffie   #(11) dma_misc_bits    (.*, .clk(free_l2clk), .din({dma_mem_tag[2:0],\n                                                                       dma_mem_tag_ff[2:0],\n                                                                       dma_mem_addr[3:2],\n                                                                       iccm_dma_rden,\n                                                                       iccm_dma_rvalid_in,\n                                                                       iccm_dma_ecc_error_in }),\n                                                                .dout({dma_mem_tag_ff[2:0],\n                                                                       iccm_dma_rtag[2:0],\n                                                                       dma_mem_addr_ff[3:2],\n                                                                       iccm_dma_rvalid_in,\n                                                                       iccm_dma_rvalid,\n                                                                       iccm_dma_ecc_error }));\n\n         assign iccm_rw_addr[pt.ICCM_BITS-1:1]    = (  ifc_dma_access_q_ok & dma_iccm_req  & ~iccm_correct_ecc) ? dma_mem_addr[pt.ICCM_BITS-1:1] :\n                                                 (~(ifc_dma_access_q_ok & dma_iccm_req) &  iccm_correct_ecc) ? {iccm_ecc_corr_index_ff[pt.ICCM_BITS-1:2],1'b0} : ifc_fetch_addr_bf[pt.ICCM_BITS-1:1] ;\n\n\n    assign iccm_dma_rd_ecc_single_err = iccm_dma_sb_error;\n    assign iccm_dma_rd_ecc_double_err = iccm_dma_rvalid && iccm_dma_ecc_error;\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n// ECC checking logic for ICCM data.                                               //\n/////////////////////////////////////////////////////////////////////////////////////\n\n  logic [3:0] ic_fetch_val_int_f;\n  logic [3:0] ic_fetch_val_shift_right;\n  assign ic_fetch_val_int_f[3:0] = {2'b00 , ic_fetch_val_f[1:0] } ;\n  assign ic_fetch_val_shift_right[3:0] = {ic_fetch_val_int_f << ifu_fetch_addr_int_f[1] } ;\n\n   assign iccm_rdmux_data[77:0] = iccm_rd_data_ecc[77:0];\n   for (genvar i=0; i < 2 ; i++) begin : ICCM_ECC_CHECK\n      assign iccm_ecc_word_enable[i] = ((|ic_fetch_val_shift_right[(2*i+1):(2*i)] & ~exu_flush_final & sel_iccm_data) | iccm_dma_rvalid_in) & ~dec_tlu_core_ecc_disable;\n   rvecc_decode  ecc_decode (\n                           .en(iccm_ecc_word_enable[i]),\n                           .sed_ded ( 1'b0 ),    // 1 : means only detection\n                           .din(iccm_rdmux_data[(39*i+31):(39*i)]),\n                           .ecc_in(iccm_rdmux_data[(39*i+38):(39*i+32)]),\n                           .dout(iccm_corrected_data[i][31:0]),\n                           .ecc_out(iccm_corrected_ecc[i][6:0]),\n                           .single_ecc_error(iccm_single_ecc_error[i]),\n                           .double_ecc_error(iccm_double_ecc_error[i]));\nend\n\n  assign iccm_rd_ecc_single_err  = (|iccm_single_ecc_error[1:0] ) & ifc_iccm_access_f & ifc_fetch_req_f;\n  assign iccm_rd_ecc_double_err[1:0]  = ~ifu_fetch_addr_int_f[1] ? ({iccm_double_ecc_error[0], iccm_double_ecc_error[0]} ) & {2{ifc_iccm_access_f}} :\n                                                                   ({iccm_double_ecc_error[1], iccm_double_ecc_error[0]} ) & {2{ifc_iccm_access_f}} ;\n\n  assign iccm_corrected_data_f_mux[31:0] = iccm_single_ecc_error[0] ? iccm_corrected_data[0] : iccm_corrected_data[1];\n  assign iccm_corrected_ecc_f_mux[6:0]   = iccm_single_ecc_error[0] ? iccm_corrected_ecc[0]  : iccm_corrected_ecc[1];\n\n  assign iccm_ecc_write_status           = ((iccm_rd_ecc_single_err & ~iccm_rd_ecc_single_err_ff)  & ~exu_flush_final) | iccm_dma_sb_error;\n  assign iccm_rd_ecc_single_err_hold_in  = (iccm_rd_ecc_single_err | iccm_rd_ecc_single_err_ff) & ~exu_flush_final ;\n  assign iccm_error_start                =  iccm_rd_ecc_single_err;\n  assign iccm_ecc_corr_index_in[pt.ICCM_BITS-1:2] = iccm_single_ecc_error[0] ? iccm_rw_addr_f[pt.ICCM_BITS-1:2] : iccm_rw_addr_f[pt.ICCM_BITS-1:2] + 1'b1 ;\n\n   rvdffie #(pt.ICCM_BITS-1) iccm_index_f   (.*, .clk(free_l2clk), .din({iccm_rw_addr[pt.ICCM_BITS-1:2],\n                                                                         iccm_rd_ecc_single_err_hold_in\n                                                                                                       }),\n                                                                  .dout({iccm_rw_addr_f[pt.ICCM_BITS-1:2],\n                                                                         iccm_rd_ecc_single_err_ff}));\n\n   rvdffe #((39+(pt.ICCM_BITS-2)))      ecc_dat0_ff  (\n                                                      .clk(clk),\n                                                      .din({iccm_corrected_ecc_f_mux[6:0],  iccm_corrected_data_f_mux[31:0],iccm_ecc_corr_index_in[pt.ICCM_BITS-1:2]}),\n                                                      .dout({iccm_ecc_corr_data_ff[38:0]   ,iccm_ecc_corr_index_ff[pt.ICCM_BITS-1:2]}),\n                                                      .en(iccm_ecc_write_status),\n                                                      .*\n                                                      );\n\n     end else begin : iccm_disabled\n         assign iccm_dma_rvalid = 1'b0 ;\n         assign iccm_dma_ecc_error = 1'b0 ;\n         assign iccm_dma_rdata[63:0] = '0 ;\n         assign iccm_single_ecc_error = '0 ;\n         assign iccm_dma_rtag         = '0 ;\n\n\n\n\n\n\n         assign iccm_rd_ecc_single_err                 = 1'b0 ;\n         assign iccm_rd_ecc_double_err                 = '0 ;\n         assign iccm_rd_ecc_single_err_ff              = 1'b0 ;\n         assign iccm_error_start                         = 1'b0;\n         assign iccm_ecc_corr_index_ff[pt.ICCM_BITS-1:2]  =  '0;\n         assign iccm_ecc_corr_data_ff[38:0]            =  '0;\n         assign iccm_ecc_w"}
{"text": "rite_status                  =  '0;\n\n\n\n\n\n\n    end\n\n\n////// ICCM signals\n\n\n assign   ic_rd_en    =  (ifc_fetch_req_bf & ~ifc_fetch_uncacheable_bf & ~ifc_iccm_access_bf  &\n                            ~(((miss_state == STREAM) & ~miss_state_en)                                       |\n                              ((miss_state == CRIT_BYP_OK) & ~miss_state_en)                                  |\n                              ((miss_state == STALL_SCND_MISS) & ~miss_state_en)                              |\n                              ((miss_state == MISS_WAIT) & ~miss_state_en)                                    |\n                              ((miss_state == CRIT_WRD_RDY) & ~miss_state_en)  |\n                              ((miss_state == CRIT_BYP_OK) &  miss_state_en &  (miss_nxtstate == MISS_WAIT))  ))  |\n                             ( ifc_fetch_req_bf & exu_flush_final  & ~ifc_fetch_uncacheable_bf & ~ifc_iccm_access_bf )     ;\n\nlogic   ic_real_rd_wp_unused;\nassign  ic_real_rd_wp_unused  =  (ifc_fetch_req_bf &  ~ifc_iccm_access_bf  &  ~ifc_region_acc_fault_final_bf & ~dec_tlu_fence_i_wb & ~stream_miss_f & ~ic_act_miss_f &\n                            ~(((miss_state == STREAM) & ~miss_state_en) |\n                              ((miss_state == CRIT_BYP_OK) & ~miss_state_en & ~(miss_nxtstate == MISS_WAIT)) |\n                              ((miss_state == CRIT_BYP_OK) &  miss_state_en &  (miss_nxtstate == MISS_WAIT)) |\n                              ((miss_state == MISS_WAIT) & ~miss_state_en) |\n                              ((miss_state == STALL_SCND_MISS) & ~miss_state_en)  |\n                              ((miss_state == CRIT_WRD_RDY) & ~miss_state_en)  |\n                              ((miss_nxtstate == STREAM) &  miss_state_en)  |\n                              ((miss_state == SCND_MISS) & ~miss_state_en))) |\n                          (ifc_fetch_req_bf &  ~ifc_iccm_access_bf  &  ~ifc_region_acc_fault_final_bf & ~dec_tlu_fence_i_wb & ~stream_miss_f & exu_flush_final)  ;\n\n\nassign ic_wr_en[pt.ICACHE_NUM_WAYS-1:0] = bus_ic_wr_en[pt.ICACHE_NUM_WAYS-1:0] & {pt.ICACHE_NUM_WAYS{write_ic_16_bytes}};\nassign ic_write_stall                =  write_ic_16_bytes &  ~((((miss_state== CRIT_BYP_OK) | ((miss_state==STREAM) & ~(exu_flush_final | ifu_bp_hit_taken_q_f  | stream_eol_f ))) & ~(bus_ifu_wr_en_ff & last_beat & ~uncacheable_miss_ff)));\n\n\n\n\n///////////////////////////////////////////////////////////////\n// Icache status and LRU\n///////////////////////////////////////////////////////////////\nlogic [pt.ICACHE_NUM_WAYS-1:0] ic_tag_valid_unq;\nif (pt.ICACHE_ENABLE == 1 ) begin: icache_enabled\n   assign  ic_valid  = ~ifu_wr_cumulative_err_data & ~(reset_ic_in | reset_ic_ff) & ~reset_tag_valid_for_miss;\n\n   assign ifu_status_wr_addr_w_debug[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] = ((ic_debug_rd_en | ic_debug_wr_en ) & ic_debug_tag_array) ?\n                                                                           ic_debug_addr[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] :\n                                                                           ifu_status_wr_addr[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO];\n\n   // status\n\n         assign way_status_wr_en_w_debug = way_status_wr_en | (ic_debug_wr_en  & ic_debug_tag_array);\n\n         assign way_status_new_w_debug[pt.ICACHE_STATUS_BITS-1:0]  = (ic_debug_wr_en  & ic_debug_tag_array) ? (pt.ICACHE_STATUS_BITS == 1) ? ic_debug_wr_data[4] : ic_debug_wr_data[6:4] :\n                                                way_status_new[pt.ICACHE_STATUS_BITS-1:0] ;\n\n   rvdffie #(.WIDTH(pt.ICACHE_TAG_LO-pt.ICACHE_TAG_INDEX_LO+1+pt.ICACHE_STATUS_BITS),.OVERRIDE(1))  status_misc_ff\n     (.*,\n      .clk(free_l2clk),\n      .din({ ifu_status_wr_addr_w_debug[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO], way_status_wr_en_w_debug, way_status_new_w_debug[pt.ICACHE_STATUS_BITS-1:0]}),\n      .dout({ifu_status_wr_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO],      way_status_wr_en_ff,      way_status_new_ff[pt.ICACHE_STATUS_BITS-1:0]} )\n      );\n\n   logic [(pt.ICACHE_TAG_DEPTH/8)-1 : 0] way_status_clken;\n   logic [(pt.ICACHE_TAG_DEPTH/8)-1 : 0] way_status_clk;\n\n   for (genvar i=0 ; i<pt.ICACHE_TAG_DEPTH/8 ; i++) begin : CLK_GRP_WAY_STATUS\n      assign way_status_clken[i] = (ifu_status_wr_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO+3] == i );\n     `ifdef RV_FPGA_OPTIMIZE\n        assign way_status_clk[i] = 1'b0;\n     `else\n           rvclkhdr way_status_cgc ( .en(way_status_clken[i]),   .l1clk(way_status_clk[i]), .* );\n     `endif\n\n\n      for (genvar j=0 ; j<8 ; j++) begin : WAY_STATUS\n         rvdffs_fpga #(pt.ICACHE_STATUS_BITS) ic_way_status (.*,\n                   .clk(way_status_clk[i]),\n                   .clken(way_status_clken[i]),\n                   .rawclk(clk),\n                   .en(((ifu_status_wr_addr_ff[pt.ICACHE_TAG_INDEX_LO+2:pt.ICACHE_TAG_INDEX_LO] == j) & way_status_wr_en_ff)),\n                   .din(way_status_new_ff[pt.ICACHE_STATUS_BITS-1:0]),\n                   .dout(way_status_out[8*i+j]));\n      end  // WAY_STATUS\n   end  // CLK_GRP_WAY_STATUS\n\n  always_comb begin : way_status_out_mux\n      way_status[pt.ICACHE_STATUS_BITS-1:0] = '0 ;\n      for (int j=0; j< pt.ICACHE_TAG_DEPTH; j++) begin : status_mux_loop\n        if (ifu_ic_rw_int_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] == (pt.ICACHE_TAG_LO-pt.ICACHE_TAG_INDEX_LO)'(j)) begin : mux_out\n         way_status[pt.ICACHE_STATUS_BITS-1:0] =  way_status_out[j];\n        end\n      end\n  end\n\n         assign ifu_ic_rw_int_addr_w_debug[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] = ((ic_debug_rd_en | ic_debug_wr_en ) & ic_debug_tag_array) ?\n                                                                        ic_debug_addr[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] :\n                                                                        ifu_ic_rw_int_addr[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO];\n         assign ifu_tag_wren_w_debug[pt.ICACHE_NUM_WAYS-1:0] = ifu_tag_wren[pt.ICACHE_NUM_WAYS-1:0] | ic_debug_tag_wr_en[pt.ICACHE_NUM_WAYS-1:0] ;\n\n         assign ic_valid_w_debug = (ic_debug_wr_en & ic_debug_tag_array) ? ic_debug_wr_data[0] : ic_valid;\n\n         rvdffie #(pt.ICACHE_TAG_LO-pt.ICACHE_TAG_INDEX_LO+pt.ICACHE_NUM_WAYS+1) tag_addr_ff (.*,\n                                                                                              .clk(free_l2clk),\n                                                                                              .din({ifu_ic_rw_int_addr_w_debug[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO],\n                                                                                                    ifu_tag_wren_w_debug[pt.ICACHE_NUM_WAYS-1:0],\n                                                                                                    ic_valid_w_debug}),\n                                                                                              .dout({ifu_ic_rw_int_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO],\n                                                                                                     ifu_tag_wren_ff[pt.ICACHE_NUM_WAYS-1:0],\n                                                                                                     ic_valid_ff})\n                                                                                              );\n\n\n   logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_DEPTH-1:0] ic_tag_valid_out ;\n\n   logic [(pt.ICACHE_TAG_DEPTH/32)-1:0] [pt.ICACHE_NUM_WAYS-1:0] tag_valid_clken ;\n   logic [(pt.ICACHE_TAG_DEPTH/32)-1:0] [pt.ICACHE_NUM_WAYS-1:0] tag_valid_clk   ;\n\n   for (genvar i=0 ; i<pt.ICACHE_TAG_DEPTH/32 ; i++) begin : CLK_GRP_TAG_VALID\n      for (genvar j=0; j<pt.ICACHE_NUM_WAYS; j++) begin : way_clken\n      if (pt.ICACHE_TAG_DEPTH == 32 ) begin\n        assign tag_valid_clken[i][j] =  ifu_tag_wren_ff[j] | perr_err_inv_way[j] | reset_all_tags;\n      end else begin\n         assign tag_valid_clken[i][j] = (((ifu_ic_rw_int_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO+5] == i ) &  ifu_tag_wren_ff[j] ) |\n                                        ((perr_ic_index_ff     [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO+5] == i ) &  perr_err_inv_way[j]) | reset_all_tags);\n      end\n\n     `ifdef RV_FPGA_OPTIMIZE\n        assign tag_valid_clk[i][j]  = 1'b0;\n     `else\n           rvclkhdr way_status_cgc ( .en(tag_valid_clken[i][j]),   .l1clk(tag_valid_clk[i][j]), .* );\n     `endif\n\n\n\n      for (genvar k=0 ; k<32 ; k++) begin : TAG_VALID\n         rvdffs_fpga #(1) ic_way_tagvalid_dup (.*,\n                   .clk(tag_valid_clk[i][j]),\n                   .clken(tag_valid_clken[i][j]),\n                   .rawclk(clk),\n                   .en(((ifu_ic_rw_int_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] == (k + 32*i)) & ifu_tag_wren_ff[j] ) |\n                       ((perr_ic_index_ff     [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] == (k + 32*i)) & perr_err_inv_way[j]) | reset_all_tags),\n                   .din(ic_valid_ff & ~reset_all_tags & ~perr_sel_invalidate),\n                   .dout(ic_tag_valid_out[j][32*i+k]));\n      end\n      end\n   end\n\n\n  always_comb begin : tag_valid_out_mux\n      ic_tag_valid_unq[pt.ICACHE_NUM_WAYS-1:0] = '0;\n      for (int j=0; j< pt.ICACHE_TAG_DEPTH; j++) begin : tag_valid_loop\n        if (ifu_ic_rw_int_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] == (pt.ICACHE_TAG_LO-pt.ICACHE_TAG_INDEX_LO)'(j)) begin : valid_out\n           for ( int k=0; k<pt.ICACHE_NUM_WAYS; k++) begin\n             ic_tag_valid_unq[k] |= ic_tag_valid_out[k][j];\n        end\n      end\n      end\n  end\n   //   four-way set associative - three bits\n//   each bit represents one branch point in a binary decision tree; let 1\n//   represent that the left side has been referenced more recently than the\n//   right side, and 0 vice-versa\n//\n//              are all 4 ways valid?\n//                   /       \\\n//                  |        no, use an invalid way.\n//                  |\n//                  |\n//             bit_0 == 0?             state | replace      ref to | next state\n//               /       \\             ------+--------      -------+-----------\n//              y         n             x00  |  way_0      way_0 |    _11\n//             /           \\            x10  |  way_1      way_1 |    _01\n//      bit_1 == 0?    bit_2 == 0?      0x1  |  way_2      way_2 |    1_0\n//        /    \\          /    \\        1x1  |  way_3      way_3 |    0_0\n//       y      n        y      n\n//      /        \\      /        \\        ('x' means don't care       ('_' means unchanged)\n//    way_0    way_1  way_2     way_3      don't care)\n\n   if (pt.ICACHE_NUM_WAYS == 4) begin: four_way_plru\n   assign replace_way_mb_any[3] = ( way_status_mb_ff[2]  & way_status_mb_ff[0] & (&tagv_mb_ff[3:0])) |\n                                  (~tagv_mb_ff[3]& tagv_mb_ff[2] &  tagv_mb_ff[1] &  tagv_mb_ff[0]) ;\n   assign replace_way_mb_any[2] = (~way_status_mb_ff[2]  & way_status_mb_ff[0] & (&tagv_mb_ff[3:0])) |\n                                  (~tagv_mb_ff[2]& tagv_mb_ff[1] &  tagv_mb_ff[0]) ;\n   assign replace_way_mb_any[1] = ( way_status_mb_ff[1] & ~way_status_mb_ff[0] & (&tagv_mb_ff[3:0])) |\n                                  (~tagv_mb_ff[1]& tagv_mb_ff[0] ) ;\n   assign replace_way_mb_any[0] = (~way_status_mb_ff[1] & ~way_status_mb_ff[0] & (&tagv_mb_ff[3:0])) |\n                                  (~tagv_mb_ff[0] ) ;\n\n   assign way_status_hit_new[pt.ICACHE_STATUS_BITS-1:0] = ({3{~exu_flush_final & ic_rd_hit[0]}} & {way_status[2] , 1'b1 , 1'b1}) |\n                                                          ({3{~exu_flush_final & ic_rd_hit[1]}} & {way_status[2] , 1'b0 , 1'b1}) |\n                                                          ({3{~exu_flush_final & ic_rd_hit[2]}} & {1'b1 ,way_status[1]  , 1'b0}) |\n                                                          ({3{~exu_flush_final & ic_rd_hit[3]}} & {1'b0 ,way_status[1]  , 1'b0}) ;\n\n  assign way_status_rep_new[pt.ICACHE_STATUS_BITS-1:0] = ({3{replace_way_mb_any[0]}} & {way_status_mb_ff[2] , 1'b1 , 1'b1}) |\n                                   ({3{replace_way_mb_any[1]}} & {way_status_mb_ff[2] , 1'b0 , 1'b1}) |\n                                   ({3{replace_way_mb_any[2]}} & {1'b1 ,way_status_mb_ff[1]  , 1'b0}) |\n                                   ({3{replace_way_mb_any[3]}} & {1'b0 ,way_status_mb_ff[1]  , 1'b0}) ;\n  end\n   else begin : two_ways_plru\n      assign replace_way_mb_any[0]                      = (~way_status_mb_ff  & tagv_mb_ff[0] & tagv_mb_ff[1]) | ~tagv_mb_ff[0];\n      assign replace_way_mb_any[1]                      = ( way_status_mb_ff  & tagv_mb_ff[0] & tagv_mb_ff[1]) | ~tagv_mb_ff[1] & tagv_mb_ff[0];\n      assign way_status_hit_new[pt.ICACHE_STATUS_BITS-1:0] = ic_rd_hit[0];\n      assign way_status_rep_new[pt.ICACHE_STATUS_BITS-1:0] = replace_way_mb_any[0];\n\n   end\n  // Make sure to select the way_status_hit_new even when in hit_under_miss.\n  assign way_status_new[pt.ICACHE_STATUS_BITS-1:0]     = (bus_ifu_wr_en_ff_q  & last_beat )  ? way_status_rep_new[pt.ICACHE_STATUS_BITS-1:0] :\n                                                          way_status_hit_new[pt.ICACHE_STATUS_BITS-1:0] ;\n\n\n  assign way_status_wr_en  = (bus_ifu_wr_en_ff_q  & last_beat) | ic_act_hit_f;\n\n   for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin  : bus_wren_loop\n      assign bus_wren[i]           = bus_ifu_wr_en_ff_q & replace_way_mb_any[i] & miss_pending ;\n      assign bus_wren_last[i]      = bus_ifu_wr_en_ff_wo_err & replace_way_mb_any[i] & miss_pending & bus_last_data_beat;\n      assign ifu_tag_wren[i]       = bus_wren_last[i] | wren_reset_miss[i];\n      assign wren_reset_miss[i]    = replace_way_mb_any[i] & reset_tag_valid_for_miss ;\n\n   end\n   assign bus_ic_wr_en[pt.ICACHE_NUM_WAYS-1:0] = bus_wren[pt.ICACHE_NUM_WAYS-1:0];\n\n\nend else begin: icache_disabled\n   assign ic_tag_valid_unq[pt.ICACHE_NUM_WAYS-1:0]      = '0;\n   assign way_status[pt.ICACHE_STATUS_BITS-1:0]         = '0;\n   assign replace_way_mb_any[pt.ICACHE_NUM_WAYS-1:0]    = '0;\n   assign way_status_hit_new[pt.ICACHE_STATUS_BITS-1:0] = '0;\n   assign way_status_rep_new[pt.ICACHE_STATUS_BITS-1:0] = '0;\n   assign way_status_new[pt.ICACHE_STATUS_BITS-1:0]     = '0;\n   assign way_status_wr_en                           = '0;\n   assign bus_wren[pt.ICACHE_NUM_WAYS-1:0]              = '0;\n\nend\n\n   assign ic_tag_valid[pt.ICACHE_NUM_WAYS-1:0] = ic_tag_valid_unq[pt.ICACHE_NUM_WAYS-1:0]   & {pt.ICACHE_NUM_WAYS{(~fetch_uncacheable_ff & ifc_fetch_req_f_raw) }} ;\n   assign ic_debug_tag_val_rd_out           = |(ic_tag_valid_unq[pt.ICACHE_NUM_WAYS-1:0] &  ic_debug_way_ff[pt.ICACHE_NUM_WAYS-1:0]   & {pt.ICACHE_NUM_WAYS{ic_debug_rd_en_ff}}) ;\n///////////////////////////////////////////\n// PMU signals\n///////////////////////////////////////////\n\n assign ifu_pmu_ic_miss_in   = ic_act_miss_f ;\n assign ifu_pmu_ic_hit_in    = ic_act_hit_f  ;\n assign ifu_pmu_bus_error_in = |ifc_bus_acc_fault_f;\n assign ifu_pmu_bus_trxn_in  = bus_cmd_sent ;\n assign ifu_pmu_bus_busy_in  = ifu_bus_arvalid_ff & ~ifu_bus_arready_ff & miss_pending ;\n\n   rvdffie #(9) ifu_pmu_sigs_ff (.*,\n                    .clk (free_l2clk),\n                    .din ({ifc_fetch_uncacheable_bf, ifc_fetch_req_qual_bf, dma_sb_err_state, dec_tlu_fence_i_wb,\n                           ifu_pmu_ic_miss_in,\n                           ifu_pmu_ic_hit_in,\n                           ifu_pmu_bus_error_in,\n                           ifu_pmu_bus_busy_in,\n                           ifu_pmu_bus_trxn_in\n                          }),\n                    .dout({fetch_uncacheable_ff, ifc_fetch_req_f_raw, dma_sb_err_state_ff, reset_all_tags,\n                           ifu_pmu_ic_miss,\n                           ifu_pmu_ic_hit,\n                           ifu_pmu_bus_error,\n                           ifu_pmu_bus_busy,\n                           ifu_pmu_bus_trxn\n                           }));\n\n\n///////////////////////////////////////////////////////\n// Cache debug logic                                 //\n///////////////////////////////////////////////////////\nassign ic_debug_addr[pt.ICACHE_INDEX_HI:3] = dec_tlu_ic_diag_pkt.icache_dicawics[pt.ICACHE_INDEX_HI-3:0] ;\nassign ic_debug_way_enc[01:00]             = dec_tlu_ic_diag_pkt.icache_dicawics[15:14] ;\n\n\nassign ic_debug_tag_array       = dec_tlu_ic_diag_pkt.icache_dicawics[16] ;\nassign ic_debug_rd_en           = dec_tlu_ic_diag_pkt.icache_rd_valid ;\nassign ic_debug_wr_en           = dec_tlu_ic_diag_pkt.icache_wr_valid ;\n\n\nassign ic_debug_way[pt.ICACHE_NUM_WAYS-1:0]        = {(ic_debug_way_enc[1:0] == 2'b11),\n                                                      (ic_debug_way_enc[1:0] == 2'b10),\n                                                      (ic_debug_way_enc[1:0] == 2'b01),\n                                                      (ic_debug_way_enc[1:0] == 2'b00) };\n\nassign ic_debug_tag_wr_en[pt.ICACHE_NUM_WAYS-1:0] = {pt.ICACHE_NUM_WAYS{ic_debug_wr_en & ic_debug_tag_array}} & ic_debug_way[pt.ICACHE_NUM_WAYS-1:0] ;\n\nassign ic_debug_ict_array_sel_in      =  ic_debug_rd_en & ic_debug_tag_array ;\n\nrvdff_fpga #(01+pt.ICACHE_NUM_WAYS) ifu_debug_sel_ff (.*, .clk (debug_c1_clk),\n                    .clken(debug_c1_clken), .rawclk(clk),\n                    .din ({ic_debug_ict_array_sel_in,\n                           ic_debug_way[pt.ICACHE_NUM_WAYS-1:0]\n                          }),\n                    .dout({ic_debug_ict_array_sel_ff,\n                           ic_debug_way_ff[pt.ICACHE_NUM_WAYS-1:0]\n                           }));\n\n\n\n\nassign debug_data_clken  =  ic_debug_rd_en_ff;\n\n\n\n\n// memory protection  - equation to look identical to the LSU equation\n   if (pt.PMP_ENTRIES != 0) begin : g_ifc_access_check_pmp\n      assign ifc_region_acc_okay = ~ifu_pmp_error;\n      assign ifc_region_acc_fault_memory_bf = ~ifc_region_acc_okay & ifc_fetch_req_bf;\n   end\n   else begin : g_ifc_access_check\n      assign ifc_region_acc_okay = (~(|{pt.INST_ACCESS_ENABLE0,pt.INST_ACCESS_ENABLE1,pt.INST_ACCESS_ENABLE2,pt.INST_ACCESS_ENABLE3,pt.INST_ACCESS_ENABLE4,pt.INST_ACCESS_ENABLE5,pt.INST_ACCESS_ENABLE6,pt.INST_ACCESS_ENABLE7})) |\n                                 (pt.INST_ACCESS_ENABLE0 & (({ifc_fetch_addr_bf[31:1],1'b0} | pt.INST_ACCESS_MASK0)) == (pt.INST_ACCESS_ADDR0 | pt.INST_ACCESS_MASK0)) |\n                                 (pt.INST_ACCESS_ENABLE1 & (({ifc_fetch_addr_bf[31:1],1'b0} | pt.INST_ACCESS_MASK1)) == (pt.INST_ACCESS_ADDR1 | pt.INST_ACCESS_MASK1)) |\n                                 (pt.INST_ACCESS_ENABLE2 & (({ifc_fetch_addr_bf[31:1],1'b0} | pt.INST_ACCESS_MASK2)) == (pt.INST_ACCESS_ADDR2 | pt.INST_ACCESS_MASK2)) |\n                                 (pt.INST_ACCESS_ENABLE3 & (({ifc_fetch_addr_bf[31:1],1'b0} | pt.INST_ACCESS_MASK3)) == (pt.INST_ACCESS_ADDR3 | pt.INST_ACCESS_MASK3)) |\n                                 (pt.INST_ACCESS_ENABLE4 & (({ifc_fetch_addr_bf[31:1],1'b0} | pt.INST_ACCESS_MASK4)) == (pt.INST_ACCESS_ADDR4 | pt.INST_ACCESS_MASK4)) |\n                                 (pt.INST_ACCESS_ENABLE5 & (({ifc_fetch_addr_bf[31:1],1'b0} | pt.INST_ACCESS_MASK5)) == (pt.INST_ACCESS_ADDR5 | pt.INST_ACCESS_MASK5)) |\n                                 (pt.INST_ACCESS_ENABLE6 & (({ifc_fetch_addr_bf[31:1],1'b0} | pt.INST_ACCESS_MASK6)) == (pt.INST_ACCESS_ADDR6 | pt.INST_ACCESS_MASK6)) |\n                                 (pt.INST_ACCESS_ENABLE7 & (({ifc_fetch_addr_bf[31:1],1'b0} | pt.INST_ACCESS_MASK7)) == (pt.INST_ACCESS_ADDR7 | pt.INST_ACCESS_MASK7));\n      assign ifc_region_acc_fault_memory_bf = ~ifc_iccm_access_bf & ~ifc_region_acc_okay & ifc_fetch_req_bf;\n   end\n\n   assign ifc_region_acc_fault_final_bf = ifc_region_acc_fault_bf | ifc_region_acc_fault_memory_bf;\n\n\n\n\nendmodule  // el2_ifu_mem_ctl\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\nmodule el2_ifu_tb_memread;\n\n   logic [15:0] compressed [0:128000]; // vector of compressed instructions\n   logic [31:0] expected [0:128000];   // vector of correspoding expected instruction\n\n\n   logic        rst_l;\n   logic        clk;\n\n   int          clk_count;\n\n\n\n   logic [31:0] expected_val;\n   logic [15:0] compressed_din;\n\n   logic [31:0] actual;\n\n   logic        error;\n\n   integer      i;\n   initial begin\n\n      clk=0;\n      rst_l=0;\n\n      // initialize the reads and populate the instruction arrays\n      $readmemh (\"left64k\", compressed );\n      $readmemh (\"right64k\", expected );\n\n      $dumpfile (\"top.vcd\");\n      $dumpvars;\n      $dumpon;\n\n   end\n\n   always #50 clk =~clk;\n\n   always @(posedge clk) begin\n      clk_count = clk_count +1;\n      if (clk_count>=1 & clk_count<=3) rst_l <= 1'b0;\n      else rst_l <= 1'b1;\n\n      if (clk_count > 3) begin\n\n         compressed_din[15:0] <= compressed[clk_count-3]; // c.mv\n         expected_val[31:0] <= expected[clk_count-3];\n\n      end\n\n      if (clk_count == 65000) begin\n         $dumpoff;\n         $finish;\n      end\n   end // always @ (posedge clk)\n\n   always @(negedge clk) begin\n      if (clk_count > 3 & error) begin\n         $display(\"clock: %d compressed %h error actual %h expected %h\",clk_count,compressed_din,actual,expected_val);\n      end\n   end\n\n\n   el2_ifu_compress_ctl align (.*,.din(compressed_din[15:0]),.dout(actual[31:0]));\n\n   assign error = actual[31:0] != expected_val[31:0];\n\n\n\nendmodule // el2_ifu_tb_memread\n\n\n"}
{"text": "module el2_btb_tag_hash\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n ) (\n                       input logic [pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1] pc,\n                       output logic [pt.BTB_BTAG_SIZE-1:0] hash\n                       );\n\n    assign hash = {(pc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+1] ^\n                   pc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+1] ^\n                   pc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1])};\nendmodule\n\nmodule el2_btb_tag_hash_fold\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n                       input logic [pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1] pc,\n                       output logic [pt.BTB_BTAG_SIZE-1:0] hash\n                       );\n\n    assign hash = {(\n                   pc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+1] ^\n                   pc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1])};\n\nendmodule\n\nmodule el2_btb_addr_hash\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n                        input logic [pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO] pc,\n                        output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] hash\n                        );\n\n\nif(pt.BTB_FOLD2_INDEX_HASH) begin : fold2\n   assign hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = pc[pt.BTB_INDEX1_HI:pt.BTB_INDEX1_LO] ^\n                                                pc[pt.BTB_INDEX3_HI:pt.BTB_INDEX3_LO];\nend\n   else begin\n   assign hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = pc[pt.BTB_INDEX1_HI:pt.BTB_INDEX1_LO] ^\n                                                pc[pt.BTB_INDEX2_HI:pt.BTB_INDEX2_LO] ^\n                                                pc[pt.BTB_INDEX3_HI:pt.BTB_INDEX3_LO];\nend\n\nendmodule\n\nmodule el2_btb_ghr_hash\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n                       input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] hashin,\n                       input logic [pt.BHT_GHR_SIZE-1:0] ghr,\n                       output logic [pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] hash\n                       );\n\n   // The hash function is too complex to write in verilog for all cases.\n   // The config script generates the logic string based on the bp config.\n   if(pt.BHT_GHR_HASH_1) begin : ghrhash_cfg1\n     assign hash[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = { ghr[pt.BHT_GHR_SIZE-1:pt.BTB_INDEX1_HI-1], hashin[pt.BTB_INDEX1_HI:2]^ghr[pt.BTB_INDEX1_HI-2:0]};\n   end\n   else begin : ghrhash_cfg2\n     assign hash[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = { hashin[pt.BHT_GHR_SIZE+1:2]^ghr[pt.BHT_GHR_SIZE-1:0]};\n   end\n\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Function: Top level file for load store unit\n// Comments:\n//\n//\n// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n//\n//********************************************************************************\n\nmodule el2_lsu\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n(\n\n   input logic                             clk_override,             // Override non-functional clock gating\n   input logic                             dec_tlu_flush_lower_r,    // I0/I1 writeback flush. This is used to flush the old packets only\n   input logic                             dec_tlu_i0_kill_writeb_r, // I0 is flushed, don't writeback any results to arch state\n   input logic                             dec_tlu_force_halt,       // This will be high till TLU goes to debug halt\n\n   // chicken signals\n   input logic                             dec_tlu_external_ldfwd_disable,     // disable load to load forwarding for externals\n   input logic                             dec_tlu_wb_coalescing_disable,     // disable the write buffer coalesce\n   input logic                             dec_tlu_sideeffect_posted_disable, // disable the posted sideeffect load store to the bus\n   input logic                             dec_tlu_core_ecc_disable,          // disable the generation of the ecc\n\n   input logic [31:0]                      exu_lsu_rs1_d,        // address rs operand\n   input logic [31:0]                      exu_lsu_rs2_d,        // store data\n   input logic [11:0]                      dec_lsu_offset_d,     // address offset operand\n\n   input                                   el2_lsu_pkt_t lsu_p,  // lsu control packet\n   input logic                             dec_lsu_valid_raw_d,   // Raw valid for address computation\n   input logic [31:0]                      dec_tlu_mrac_ff,       // CSR for memory region control\n\n   output logic [31:0]                     lsu_result_m,          // lsu load data\n   output logic [31:0]                     lsu_result_corr_r,     // This is the ECC corrected data going to RF\n   output logic                            lsu_load_stall_any,    // This is for blocking loads in the decode\n   output logic                            lsu_store_stall_any,   // This is for blocking stores in the decode\n   output logic                            lsu_fastint_stall_any, // Stall the fastint in decode-1 stage\n   output logic                            lsu_idle_any,          // lsu buffers are empty and no instruction in the pipeline. Doesn't include DMA\n   output logic                            lsu_active,            // Used to turn off top level clk\n\n   output logic [31:1]                     lsu_fir_addr,        // fast interrupt address\n   output logic [1:0]                      lsu_fir_error,       // Error during fast interrupt lookup\n\n   output logic                            lsu_single_ecc_error_incr,     // Increment the ecc counter\n   output el2_lsu_error_pkt_t             lsu_error_pkt_r,               // lsu exception packet\n   output logic                            lsu_imprecise_error_load_any,  // bus load imprecise error\n   output logic                            lsu_imprecise_error_store_any, // bus store imprecise error\n   output logic [31:0]                     lsu_imprecise_error_addr_any,  // bus store imprecise error address\n\n   // Non-blocking loads\n   output logic                               lsu_nonblock_load_valid_m,      // there is an external load -> put in the cam\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_tag_m,        // the tag of the external non block load\n   output logic                               lsu_nonblock_load_inv_r,        // invalidate signal for the cam entry for non block loads\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_inv_tag_r,    // tag of the enrty which needs to be invalidated\n   output logic                               lsu_nonblock_load_data_valid,   // the non block is valid - sending information back to the cam\n   output logic                               lsu_nonblock_load_data_error,   // non block load has an error\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_data_tag,     // the tag of the non block load sending the data/error\n   output logic [31:0]                        lsu_nonblock_load_data,         // Data of the non block load\n\n   output logic                            lsu_pmu_load_external_m,        // PMU : Bus loads\n   output logic                            lsu_pmu_store_external_m,       // PMU : Bus loads\n   output logic                            lsu_pmu_misaligned_m,           // PMU : misaligned\n   output logic                            lsu_pmu_bus_trxn,               // PMU : bus transaction\n   output logic                            lsu_pmu_bus_misaligned,         // PMU : misaligned access going to the bus\n   output logic                            lsu_pmu_bus_error,              // PMU : bus sending error back\n   output logic                            lsu_pmu_bus_busy,               // PMU : bus is not ready\n\n   // Trigger signals\n   input                                   el2_trigger_pkt_t [3:0] trigger_pkt_any, // Trigger info from the decode\n   output logic [3:0]                      lsu_trigger_match_m,                      // lsu trigger hit (one bit per trigger)\n\n   // DCCM ports\n   output logic                            dccm_wren,       // DCCM write enable\n   output logic                            dccm_rden,       // DCCM read enable\n   output logic [pt.DCCM_BITS-1:0]         dccm_wr_addr_lo, // DCCM write address low bank\n   output logic [pt.DCCM_BITS-1:0]         dccm_wr_addr_hi, // DCCM write address hi bank\n   output logic [pt.DCCM_BITS-1:0]         dccm_rd_addr_lo, // DCCM read address low bank\n   output logic [pt.DCCM_BITS-1:0]         dccm_rd_addr_hi, // DCCM read address hi bank (hi and low same if aligned read)\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_lo, // DCCM write data for lo bank\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_hi, // DCCM write data for hi bank\n\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]   dccm_rd_data_lo, // DCCM read data low bank\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]   dccm_rd_data_hi, // DCCM read data hi bank\n\n   // PIC ports\n   output logic                            picm_wren,    // PIC memory write enable\n   output logic                            picm_rden,    // PIC memory read enable\n   output logic                            picm_mken,    // Need to read the mask for stores to determine which bits to write/forward\n   output logic [31:0]                     picm_rdaddr,  // address for pic read access\n   output logic [31:0]                     picm_wraddr,  // address for pic write access\n   output logic [31:0]                     picm_wr_data, // PIC memory write data\n   input logic [31:0]                      picm_rd_data, // PIC memory read/mask data\n\n   // AXI Write Channels\n   output logic                            lsu_axi_awvalid,\n   input  logic                            lsu_axi_awready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_awid,\n   output logic [31:0]                     lsu_axi_awaddr,\n   output logic [3:0]                      lsu_axi_awregion,\n   output logic [7:0]                      lsu_axi_awlen,\n   output logic [2:0]                      lsu_axi_awsize,\n   output logic [1:0]                      lsu_axi_awburst,\n   output logic                            lsu_axi_awlock,\n   output logic [3:0]                      lsu_axi_awcache,\n   output logic [2:0]                      lsu_axi_awprot,\n   output logic [3:0]                      lsu_axi_awqos,\n\n   output logic                            lsu_axi_wvalid,\n   input  logic                            lsu_axi_wready,\n   output logic [63:0]                     lsu_axi_wdata,\n   output logic [7:0]                      lsu_axi_wstrb,\n   output logic                            lsu_axi_wlast,\n\n   input  logic                            lsu_axi_bvalid,\n   output logic                            lsu_axi_bready,\n   input  logic [1:0]                      lsu_axi_bresp,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_bid,\n\n   // AXI Read Channels\n   output logic                            lsu_axi_arvalid,\n   input  logic                            lsu_axi_arready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_arid,\n   output logic [31:0]                     lsu_axi_araddr,\n   output logic [3:0]                      lsu_axi_arregion,\n   output logic [7:0]                      lsu_axi_arlen,\n   output logic [2:0]                      lsu_axi_arsize,\n   output logic [1:0]                      lsu_axi_arburst,\n   output logic                            lsu_axi_arlock,\n   output logic [3:0]                      lsu_axi_arcache,\n   output logic [2:0]                      lsu_axi_arprot,\n   output logic [3:0]                      lsu_axi_arqos,\n\n   input  logic                            lsu_axi_rvalid,\n   output logic                            lsu_axi_rready,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_rid,\n   input  logic [63:0]                     lsu_axi_rdata,\n   input  logic [1:0]                      lsu_axi_rresp,\n   input  logic                            lsu_axi_rlast,\n\n   input logic                             lsu_bus_clk_en,    // external drives a clock_en to control bus ratio\n\n   // DMA slave\n   input logic                             dma_dccm_req,       // DMA read/write to dccm\n   input logic [2:0]                       dma_mem_tag,        // DMA request tag\n   input logic [31:0]                      dma_mem_addr,       // DMA address\n   input logic [2:0]                       dma_mem_sz,         // DMA access size\n   input logic                             dma_mem_write,      // DMA access is a write\n   input logic [63:0]                      dma_mem_wdata,      // DMA write data\n\n   output logic                            dccm_dma_rvalid,     // lsu data valid for DMA dccm read\n   output logic                            dccm_dma_ecc_error,  // DMA load had ecc error\n   output logic [2:0]                      dccm_dma_rtag,       // DMA request tag\n   output logic [63:0]                     dccm_dma_rdata,      // lsu data for DMA dccm read\n   output logic                            dccm_ready,          // lsu ready for DMA access\n\n   // DCCM ECC status\n   output logic                            lsu_dccm_rd_ecc_single_err,\n   output logic                            lsu_dccm_rd_ecc_double_err,\n\n   input logic                             scan_mode,           // scan mode\n   input logic                             clk,                 // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n   input logic                             active_clk,          // Clock only while core active.  Through two clock headers. For flops without second clock header built in.\n    input logic                             rst_l,               // reset, active low\n\n    output logic [31:0] lsu_pmp_addr_start,\n    output logic [31:0] lsu_pmp_addr_end,\n    input  logic        lsu_pmp_error_start,\n    input  logic        lsu_pmp_error_end,\n    output logic        lsu_pmp_we,\n    output logic        lsu_pmp_re\n\n   );\n\n   logic        lsu_dccm_rden_m;\n   logic        lsu_dccm_rden_r;\n   logic [31:0] store_data_m;\n   logic [31:0] store_data_r;\n   logic [31:0] store_data_hi_r, store_data_lo_r;\n   logic [31:0] store_datafn_hi_r, store_datafn_lo_r;\n   logic [31:0] sec_data_lo_m, sec_data_hi_m;\n   logic [31:0] sec_data_lo_r, sec_data_hi_r;\n\n   logic [31:0] lsu_ld_data_m;\n   logic [31:0] dccm_rdata_hi_m, dccm_rdata_lo_m;\n   logic [6:0]  dccm_data_ecc_hi_m, dccm_data_ecc_lo_m;\n   logic        lsu_single_ecc_error_m;\n   logic        lsu_double_ecc_error_m;\n\n   logic [31:0] lsu_ld_data_r;\n   logic [31:0] lsu_ld_data_corr_r;\n   logic [31:0] dccm_rdata_hi_r, dccm_rdata_lo_r;\n   logic [6:0]  dccm_data_ecc_hi_r, dccm_data_ecc_lo_r;\n   logic        single_ecc_error_hi_r, single_ecc_error_lo_r;\n   logic        lsu_single_ecc_error_r;\n   logic        lsu_double_ecc_error_r;\n   logic        ld_single_ecc_error_r, ld_single_ecc_error_r_ff;\n   assign lsu_dccm_rd_ecc_single_err = lsu_single_ecc_error_r;\n   assign lsu_dccm_rd_ecc_double_err = lsu_double_ecc_error_r;\n\n   logic [31:0] picm_mask_data_m;\n\n   logic [31:0] lsu_addr_d, lsu_addr_m, lsu_addr_r;\n   logic [31:0] end_addr_d, end_addr_m, end_addr_r;\n  assign lsu_pmp_addr_start = lsu_addr_d;\n  assign lsu_pmp_addr_end   = end_addr_d;\n\n   el2_lsu_pkt_t    lsu_pkt_d, lsu_pkt_m, lsu_pkt_r;\n   logic        lsu_i0_valid_d, lsu_i0_valid_m, lsu_i0_valid_r;\n  assign lsu_pmp_we = lsu_pkt_d.store & lsu_pkt_d.valid;\n  assign lsu_pmp_re = lsu_pkt_d.load & lsu_pkt_d.valid;\n\n   // Store Buffer signals\n   logic        store_stbuf_reqvld_r;\n   logic        ldst_stbuf_reqvld_r;\n\n   logic        lsu_commit_r;\n   logic        lsu_exc_m;\n\n   logic        addr_in_dccm_d, addr_in_dccm_m, addr_in_dccm_r;\n   logic        addr_in_pic_d, addr_in_pic_m, addr_in_pic_r;\n   logic        ldst_dual_d, ldst_dual_m, ldst_dual_r;\n   logic        addr_external_m;\n\n   logic                          stbuf_reqvld_any;\n   logic                          stbuf_reqvld_flushed_any;\n   logic [pt.LSU_SB_BITS-1:0]     stbuf_addr_any;\n   logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_data_any;\n   logic [pt.DCCM_ECC_WIDTH-1:0]  stbuf_ecc_any;\n   logic [pt.DCCM_DATA_WIDTH-1:0] sec_data_lo_r_ff, sec_data_hi_r_ff;\n   logic [pt.DCCM_ECC_WIDTH-1:0]  sec_data_ecc_hi_r_ff, sec_data_ecc_lo_r_ff;\n\n   logic                          lsu_cmpen_m;\n   logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_fwddata_hi_m;\n   logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_fwddata_lo_m;\n   logic [pt.DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_hi_m;\n   logic [pt.DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_lo_m;\n\n   logic        lsu_stbuf_commit_any;\n   logic        lsu_stbuf_empty_any;   // This is for blocking loads\n   logic        lsu_stbuf_full_any;\n\n    // Bus signals\n   logic        lsu_busreq_r;\n   logic        lsu_bus_buffer_pend_any;\n   logic        lsu_bus_buffer_empty_any;\n   logic        lsu_bus_buffer_full_any;\n   logic        lsu_busreq_m;\n   logic [31:0] bus_read_data_m;\n\n   logic        flush_m_up, flush_r;\n   logic        is_sideeffects_m;\n   logic [2:0]  dma_mem_tag_d, dma_mem_tag_m;\n   logic        ldst_nodma_mtor;\n   logic        dma_dccm_wen, dma_pic_wen;\n   logic [31:0] dma_dccm_wdata_lo, dma_dccm_wdata_hi;\n   logic [pt.DCCM_ECC_WIDTH-1:0] dma_dccm_wdata_ecc_lo, dma_dccm_wdata_ecc_hi;\n\n   // Clocks\n   logic        lsu_busm_clken;\n   logic        lsu_bus_obuf_c1_clken;\n   logic        lsu_c1_m_clk, lsu_c1_r_clk;\n   logic        lsu_c2_m_clk, lsu_c2_r_clk;\n   logic        lsu_store_c1_m_clk, lsu_store_c1_r_clk;\n\n   logic        lsu_stbuf_c1_clk;\n   logic        lsu_bus_ibuf_c1_clk, lsu_bus_obuf_c1_clk, lsu_bus_buf_c1_clk;\n   logic        lsu_busm_clk;\n   logic        lsu_free_c2_clk;\n\n   logic        lsu_raw_fwd_lo_m, lsu_raw_fwd_hi_m;\n   logic        lsu_raw_fwd_lo_r, lsu_raw_fwd_hi_r;\n\n   assign       lsu_raw_fwd_lo_m = (|stbuf_fwdbyteen_lo_m[pt.DCCM_BYTE_WIDTH-1:0]);\n   assign       lsu_raw_fwd_hi_m = (|stbuf_fwdbyteen_hi_m[pt.DCCM_BYTE_WIDTH-1:0]);\n\n   el2_lsu_lsc_ctl #(.pt(pt)) lsu_lsc_ctl (.*);\n\n   // block stores in decode  - for either bus or stbuf reasons\n   assign lsu_store_stall_any = lsu_stbuf_full_any | lsu_bus_buffer_full_any | ld_single_ecc_error_r_ff;\n   assign lsu_load_stall_any = lsu_bus_buffer_full_any | ld_single_ecc_error_r_ff;\n   assign lsu_fastint_stall_any = ld_single_ecc_error_r;    // Stall the fastint in decode-1 stage\n\n   // Ready to accept dma trxns\n   // There can't be any inpipe forwarding from non-dma packet to dma packet since they can be flushed so we can't have st in r when dma is in m\n   assign dma_mem_tag_d[2:0]   = dma_mem_tag[2:0];\n   assign ldst_nodma_mtor = (lsu_pkt_m.valid & ~lsu_pkt_m.dma & (addr_in_dccm_m | addr_in_pic_m) & lsu_pkt_m.store);\n\n   assign dccm_ready = ~(dec_lsu_valid_raw_d | ldst_nodma_mtor | ld_single_ecc_error_r_ff);\n\n   assign dma_dccm_wen = dma_dccm_req & dma_mem_write & addr_in_dccm_d & dma_mem_sz[1];   // Perform DMA writes only for word/dword\n   assign dma_pic_wen  = dma_dccm_req & dma_mem_write & addr_in_pic_d;\n   assign {dma_dccm_wdata_hi[31:0], dma_dccm_wdata_lo[31:0]} = dma_mem_wdata[63:0] >> {dma_mem_addr[2:0], 3'b000};   // Shift the dma data to lower bits to make it consistent to lsu stores\n\n\n   // Generate per cycle flush signals\n   assign flush_m_up = dec_tlu_flush_lower_r;\n   assign flush_r    = dec_tlu_i0_kill_writeb_r;\n\n   // lsu idle\n   // lsu halt idle. This is used for entering the halt mode. Also, DMA accesses are allowed during fence.\n   // Indicates non-idle if there is a instruction valid in d-r or read/write buffers are non-empty since they can come with error\n   // Store buffer now have only non-dma dccm stores\n   // stbuf_empty not needed since it has only dccm stores\n   assign lsu_idle_any = ~((lsu_pkt_m.valid & ~lsu_pkt_m.dma) |\n                                                      (lsu_pkt_r.valid & ~lsu_pkt_r.dma)) &\n                                                      lsu_bus_buffer_empty_any;\n\n   assign lsu_active = (lsu_pkt_m.valid | lsu_pkt_r.valid | ld_single_ecc_error_r_ff) | ~lsu_bus_buffer_empty_any;  // This includes DMA. Used for gating top clock\n\n   // Instantiate the store buffer\n   assign store_stbuf_reqvld_r = lsu_pkt_r.valid & lsu_pkt_r.store & addr_in_dccm_r & ~flush_r & (~lsu_pkt_r.dma | ((lsu_pkt_r.by | lsu_pkt_r.half) & ~lsu_double_ecc_error_r));\n\n   // Disable Forwarding for now\n   assign lsu_cmpen_m = lsu_pkt_m.valid & (lsu_pkt_m.load | lsu_pkt_m.store) & (addr_in_dccm_m | addr_in_pic_m);\n\n   // Bus signals\n   assign lsu_busreq_m = lsu_pkt_m.valid & ((lsu_pkt_m.load | lsu_pkt_m.store) & addr_external_m) & ~flush_m_up & ~lsu_exc_m & ~lsu_pkt_m.fast_int;\n\n   // Dual signals\n   assign ldst_dual_d  = (lsu_addr_d[2] != end_addr_d[2]);\n   assign ldst_dual_m  = (lsu_addr_m[2] != end_addr_m[2]);\n   assign ldst_dual_r  = (lsu_addr_r[2] != end_addr_r[2]);\n\n   // PMU signals\n   assign lsu_pmu_misaligned_m     = lsu_pkt_m.valid & ((lsu_pkt_m.half & lsu_addr_m[0]) | (lsu_pkt_m.word & (|lsu_addr_m[1:0])));\n   assign lsu_pmu_load_external_m  = lsu_pkt_m.valid & lsu_pkt_m.load & addr_external_m;\n   assign lsu_pmu_store_external_m = lsu_pkt_m.valid & lsu_pkt_m.store & addr_external_m;\n\n   el2_lsu_dccm_ctl #(.pt(pt)) dccm_ctl (\n      .lsu_addr_d(lsu_addr_d[31:0]),\n      .end_addr_d(end_addr_d[pt.DCCM_BITS-1:0]),\n      .lsu_addr_m(lsu_addr_m[pt.DCCM_BITS-1:0]),\n      .lsu_addr_r(lsu_addr_r[31:0]),\n\n      .end_addr_m(end_addr_m[pt.DCCM_BITS-1:0]),\n      .end_addr_r(end_addr_r[pt.DCCM_BITS-1:0]),\n      .*\n   );\n\n   el2_lsu_stbuf #(.pt(pt)) stbuf (\n      .lsu_addr_d(lsu_addr_d[pt.LSU_SB_BITS-1:0]),\n      .end_addr_d(end_addr_d[pt.LSU_SB_BITS-1:0]),\n\n      .*\n\n   );\n\n   el2_lsu_ecc #(.pt(pt)) ecc (\n      .lsu_addr_r(lsu_addr_r[pt.DCCM_BITS-1:0]),\n      .end_addr_r(end_addr_r[pt.DCCM_BITS-1:0]),\n      .lsu_addr_m(lsu_addr_m[pt.DCCM_BITS-1:0]),\n      .end_addr_m(end_addr_m[pt.DCCM_BITS-1:0]),\n      .*\n   );\n\n   el2_lsu_trigger #(.pt(pt)) trigger (\n      .store_data_m(store_data_m[31:0]),\n      .*\n   );\n\n  "}
{"text": " // Clk domain\n   el2_lsu_clkdomain #(.pt(pt)) clkdomain (.*);\n\n   // Bus interface\n   el2_lsu_bus_intf #(.pt(pt)) bus_intf (\n      .lsu_addr_m(lsu_addr_m[31:0] & {32{addr_external_m & lsu_pkt_m.valid}}),\n      .lsu_addr_r(lsu_addr_r[31:0] & {32{lsu_busreq_r}}),\n\n      .end_addr_m(end_addr_m[31:0] & {32{addr_external_m & lsu_pkt_m.valid}}),\n      .end_addr_r(end_addr_r[31:0] & {32{lsu_busreq_r}}),\n\n      .store_data_r(store_data_r[31:0] & {32{lsu_busreq_r}}),\n      .*\n   );\n\n   //Flops\n   rvdff #(3) dma_mem_tag_mff     (.*, .din(dma_mem_tag_d[2:0]), .dout(dma_mem_tag_m[2:0]), .clk(lsu_c1_m_clk));\n   rvdff #(2) lsu_raw_fwd_r_ff    (.*, .din({lsu_raw_fwd_hi_m, lsu_raw_fwd_lo_m}),     .dout({lsu_raw_fwd_hi_r, lsu_raw_fwd_lo_r}),     .clk(lsu_c2_r_clk));\n\n`ifdef RV_ASSERT_ON\n   logic [1:0] store_data_bypass_sel;\n   assign store_data_bypass_sel[1:0] =  {lsu_p.store_data_bypass_d, lsu_p.store_data_bypass_m};\n\n   property exception_no_lsu_flush;\n      @(posedge clk)  disable iff(~rst_l) lsu_lsc_ctl.lsu_error_pkt_m.exc_valid |-> ##[1:2] (flush_r );\n   endproperty\n   assert_exception_no_lsu_flush: assert property (exception_no_lsu_flush) else\n      $display(\"No flush within 2 cycles of exception\");\n\n   // offset should be zero for fast interrupt\n   property offset_0_fastint;\n      @(posedge clk) disable iff(~rst_l) (lsu_p.valid & lsu_p.fast_int) |-> (dec_lsu_offset_d[11:0] == 12'b0);\n   endproperty\n   assert_offset_0_fastint: assert property (offset_0_fastint) else\n      $display(\"dec_tlu_offset_d not zero for fast interrupt redirect\");\n\n   // DMA req should assert dccm rden/wren\n   property dmareq_dccm_wren_or_rden;\n      @(posedge clk) disable iff(~rst_l) dma_dccm_req |-> (dccm_rden | dccm_wren | addr_in_pic_d);\n   endproperty\n   assert_dmareq_dccm_wren_or_rden: assert property(dmareq_dccm_wren_or_rden) else\n      $display(\"dccm rden or wren not asserted during DMA request\");\n\n   // fastint_stall should cause load/store stall next cycle\n   property fastint_stall_imply_loadstore_stall;\n      @(posedge clk) disable iff(~rst_l) (lsu_fastint_stall_any & (lsu_commit_r | lsu_pkt_r.dma)) |-> ##1 ((lsu_load_stall_any | lsu_store_stall_any) | ~ld_single_ecc_error_r_ff);\n   endproperty\n   assert_fastint_stall_imply_loadstore_stall: assert property (fastint_stall_imply_loadstore_stall) else\n      $display(\"fastint_stall should be followed by lsu_load/store_stall_any\");\n\n   // Single ECC error implies rfnpc flush\n   property single_ecc_error_rfnpc_flush;\n      @(posedge clk) disable iff(~rst_l) (lsu_error_pkt_r.single_ecc_error & lsu_pkt_r.load) |=> ~lsu_commit_r;\n   endproperty\n   assert_single_ecc_error_rfnpc_flush: assert property (single_ecc_error_rfnpc_flush) else\n     $display(\"LSU commit next cycle after single ecc error\");\n\n`endif\n\nendmodule // el2_lsu\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: Checks the memory map for the address\n// Comments:\n//\n//********************************************************************************\nmodule el2_lsu_addrcheck\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n   input logic          lsu_c2_m_clk,              // clock\n   input logic          rst_l,                     // reset\n\n   input logic [31:0]   start_addr_d,              // start address for lsu\n   input logic [31:0]   end_addr_d,                // end address for lsu\n   input el2_lsu_pkt_t lsu_pkt_d,                 // packet in d\n   input logic [31:0]   dec_tlu_mrac_ff,           // CSR read\n   input logic [3:0]    rs1_region_d,              // address rs operand [31:28]\n\n   input logic [31:0]   rs1_d,                     // address rs operand\n\n   output logic         is_sideeffects_m,          // is sideffects space\n   output logic         addr_in_dccm_d,            // address in dccm\n   output logic         addr_in_pic_d,             // address in pic\n   output logic         addr_external_d,           // address in external\n\n   output logic         access_fault_d,            // access fault\n   output logic         misaligned_fault_d,        // misaligned\n   output logic [3:0]   exc_mscause_d,             // mscause for access/misaligned faults\n\n   output logic         fir_dccm_access_error_d,   // Fast interrupt dccm access error\n   output logic         fir_nondccm_access_error_d,// Fast interrupt dccm access error\n\n    input logic lsu_pmp_error_start,\n    input logic lsu_pmp_error_end,\n\n   input  logic         scan_mode                  // Scan mode\n);\n\n\n   logic        non_dccm_access_ok;\n   logic        is_sideeffects_d, is_aligned_d;\n   logic        start_addr_in_dccm_d, end_addr_in_dccm_d;\n   logic        start_addr_in_dccm_region_d, end_addr_in_dccm_region_d;\n   logic        start_addr_in_pic_d, end_addr_in_pic_d;\n   logic        start_addr_in_pic_region_d, end_addr_in_pic_region_d;\n   logic [4:0]  csr_idx;\n   logic        addr_in_iccm;\n   logic        start_addr_dccm_or_pic;\n   logic        base_reg_dccm_or_pic;\n   logic        unmapped_access_fault_d, mpu_access_fault_d, picm_access_fault_d, regpred_access_fault_d;\n   logic        regcross_misaligned_fault_d, sideeffect_misaligned_fault_d;\n   logic [3:0]  access_fault_mscause_d;\n   logic [3:0]  misaligned_fault_mscause_d;\n\n   if (pt.DCCM_ENABLE == 1) begin: Gen_dccm_enable\n      // Start address check\n      rvrangecheck #(.CCM_SADR(pt.DCCM_SADR),\n                     .CCM_SIZE(pt.DCCM_SIZE)) start_addr_dccm_rangecheck (\n         .addr(start_addr_d[31:0]),\n         .in_range(start_addr_in_dccm_d),\n         .in_region(start_addr_in_dccm_region_d)\n      );\n\n      // End address check\n      rvrangecheck #(.CCM_SADR(pt.DCCM_SADR),\n                     .CCM_SIZE(pt.DCCM_SIZE)) end_addr_dccm_rangecheck (\n         .addr(end_addr_d[31:0]),\n         .in_range(end_addr_in_dccm_d),\n         .in_region(end_addr_in_dccm_region_d)\n      );\n   end else begin: Gen_dccm_disable // block: Gen_dccm_enable\n      assign start_addr_in_dccm_d = '0;\n      assign start_addr_in_dccm_region_d = '0;\n      assign end_addr_in_dccm_d = '0;\n      assign end_addr_in_dccm_region_d = '0;\n   end\n\n   if (pt.ICCM_ENABLE == 1) begin : check_iccm\n      assign addr_in_iccm =  (start_addr_d[31:28] == pt.ICCM_REGION);\n   end else begin\n     assign addr_in_iccm = 1'b0;\n   end\n\n   // PIC memory check\n   // Start address check\n   rvrangecheck #(.CCM_SADR(pt.PIC_BASE_ADDR),\n                  .CCM_SIZE(pt.PIC_SIZE)) start_addr_pic_rangecheck (\n      .addr(start_addr_d[31:0]),\n      .in_range(start_addr_in_pic_d),\n      .in_region(start_addr_in_pic_region_d)\n   );\n\n   // End address check\n   rvrangecheck #(.CCM_SADR(pt.PIC_BASE_ADDR),\n                  .CCM_SIZE(pt.PIC_SIZE)) end_addr_pic_rangecheck (\n      .addr(end_addr_d[31:0]),\n      .in_range(end_addr_in_pic_d),\n      .in_region(end_addr_in_pic_region_d)\n   );\n\n   assign start_addr_dccm_or_pic  = start_addr_in_dccm_region_d | start_addr_in_pic_region_d;\n   assign base_reg_dccm_or_pic    = ((rs1_region_d[3:0] == pt.DCCM_REGION) & pt.DCCM_ENABLE) | (rs1_region_d[3:0] == pt.PIC_REGION);\n   assign addr_in_dccm_d          = (start_addr_in_dccm_d & end_addr_in_dccm_d);\n   assign addr_in_pic_d           = (start_addr_in_pic_d & end_addr_in_pic_d);\n\n   assign addr_external_d   = ~(start_addr_in_dccm_region_d | start_addr_in_pic_region_d);\n   assign csr_idx[4:0]       = {start_addr_d[31:28], 1'b1};\n   assign is_sideeffects_d = dec_tlu_mrac_ff[csr_idx] & ~(start_addr_in_dccm_region_d | start_addr_in_pic_region_d | addr_in_iccm) & lsu_pkt_d.valid & (lsu_pkt_d.store | lsu_pkt_d.load);  //every region has the 2 LSB indicating ( 1: sideeffects/no_side effects, and 0: cacheable ). Ignored in internal regions\n   assign is_aligned_d    = (lsu_pkt_d.word & (start_addr_d[1:0] == 2'b0)) |\n                                                            (lsu_pkt_d.half & (start_addr_d[0] == 1'b0)) |\n                                                            lsu_pkt_d.by;\n\n  if (pt.PMP_ENTRIES == 0) begin\n   assign non_dccm_access_ok = (~(|{pt.DATA_ACCESS_ENABLE0,pt.DATA_ACCESS_ENABLE1,pt.DATA_ACCESS_ENABLE2,pt.DATA_ACCESS_ENABLE3,pt.DATA_ACCESS_ENABLE4,pt.DATA_ACCESS_ENABLE5,pt.DATA_ACCESS_ENABLE6,pt.DATA_ACCESS_ENABLE7})) |\n                               (((pt.DATA_ACCESS_ENABLE0 & ((start_addr_d[31:0] | pt.DATA_ACCESS_MASK0)) == (pt.DATA_ACCESS_ADDR0 | pt.DATA_ACCESS_MASK0)) |\n                                 (pt.DATA_ACCESS_ENABLE1 & ((start_addr_d[31:0] | pt.DATA_ACCESS_MASK1)) == (pt.DATA_ACCESS_ADDR1 | pt.DATA_ACCESS_MASK1)) |\n                                 (pt.DATA_ACCESS_ENABLE2 & ((start_addr_d[31:0] | pt.DATA_ACCESS_MASK2)) == (pt.DATA_ACCESS_ADDR2 | pt.DATA_ACCESS_MASK2)) |\n                                 (pt.DATA_ACCESS_ENABLE3 & ((start_addr_d[31:0] | pt.DATA_ACCESS_MASK3)) == (pt.DATA_ACCESS_ADDR3 | pt.DATA_ACCESS_MASK3)) |\n                                 (pt.DATA_ACCESS_ENABLE4 & ((start_addr_d[31:0] | pt.DATA_ACCESS_MASK4)) == (pt.DATA_ACCESS_ADDR4 | pt.DATA_ACCESS_MASK4)) |\n                                 (pt.DATA_ACCESS_ENABLE5 & ((start_addr_d[31:0] | pt.DATA_ACCESS_MASK5)) == (pt.DATA_ACCESS_ADDR5 | pt.DATA_ACCESS_MASK5)) |\n                                 (pt.DATA_ACCESS_ENABLE6 & ((start_addr_d[31:0] | pt.DATA_ACCESS_MASK6)) == (pt.DATA_ACCESS_ADDR6 | pt.DATA_ACCESS_MASK6)) |\n                                 (pt.DATA_ACCESS_ENABLE7 & ((start_addr_d[31:0] | pt.DATA_ACCESS_MASK7)) == (pt.DATA_ACCESS_ADDR7 | pt.DATA_ACCESS_MASK7)))   &\n                                ((pt.DATA_ACCESS_ENABLE0 & ((end_addr_d[31:0]   | pt.DATA_ACCESS_MASK0)) == (pt.DATA_ACCESS_ADDR0 | pt.DATA_ACCESS_MASK0)) |\n                                 (pt.DATA_ACCESS_ENABLE1 & ((end_addr_d[31:0]   | pt.DATA_ACCESS_MASK1)) == (pt.DATA_ACCESS_ADDR1 | pt.DATA_ACCESS_MASK1)) |\n                                 (pt.DATA_ACCESS_ENABLE2 & ((end_addr_d[31:0]   | pt.DATA_ACCESS_MASK2)) == (pt.DATA_ACCESS_ADDR2 | pt.DATA_ACCESS_MASK2)) |\n                                 (pt.DATA_ACCESS_ENABLE3 & ((end_addr_d[31:0]   | pt.DATA_ACCESS_MASK3)) == (pt.DATA_ACCESS_ADDR3 | pt.DATA_ACCESS_MASK3)) |\n                                 (pt.DATA_ACCESS_ENABLE4 & ((end_addr_d[31:0]   | pt.DATA_ACCESS_MASK4)) == (pt.DATA_ACCESS_ADDR4 | pt.DATA_ACCESS_MASK4)) |\n                                 (pt.DATA_ACCESS_ENABLE5 & ((end_addr_d[31:0]   | pt.DATA_ACCESS_MASK5)) == (pt.DATA_ACCESS_ADDR5 | pt.DATA_ACCESS_MASK5)) |\n                                 (pt.DATA_ACCESS_ENABLE6 & ((end_addr_d[31:0]   | pt.DATA_ACCESS_MASK6)) == (pt.DATA_ACCESS_ADDR6 | pt.DATA_ACCESS_MASK6)) |\n                                 (pt.DATA_ACCESS_ENABLE7 & ((end_addr_d[31:0]   | pt.DATA_ACCESS_MASK7)) == (pt.DATA_ACCESS_ADDR7 | pt.DATA_ACCESS_MASK7))));\n  end\n\n   // Access fault logic\n   // 0. Unmapped local memory : Addr in dccm region but not in dccm offset OR Addr in picm region but not in picm offset OR DCCM -> PIC cross when DCCM/PIC in same region\n   // 1. Uncorrectable (double bit) ECC error\n   // 3. Address is not in a populated non-dccm region\n   // 5. Region predication access fault: Base Address in DCCM/PIC and Final address in non-DCCM/non-PIC region or vice versa\n   // 6. Ld/St access to picm are not word aligned or word size\n   assign regpred_access_fault_d  = (start_addr_dccm_or_pic ^ base_reg_dccm_or_pic);                   // 5. Region predication access fault: Base Address in DCCM/PIC and Final address in non-DCCM/non-PIC region or vice versa\n   assign picm_access_fault_d     = (addr_in_pic_d & ((start_addr_d[1:0] != 2'b0) | ~lsu_pkt_d.word));                                               // 6. Ld/St access to picm are not word aligned or word size\n\n   if (pt.DCCM_ENABLE & (pt.DCCM_REGION == pt.PIC_REGION)) begin\n      assign unmapped_access_fault_d = ((start_addr_in_dccm_region_d & ~(start_addr_in_dccm_d | start_addr_in_pic_d)) |   // 0. Addr in dccm/pic region but not in dccm/pic offset\n                                        (end_addr_in_dccm_region_d & ~(end_addr_in_dccm_d | end_addr_in_pic_d))       |   // 0. Addr in dccm/pic region but not in dccm/pic offset\n                                        (start_addr_in_dccm_d & end_addr_in_pic_d)                                    |   // 0. DCCM -> PIC cross when DCCM/PIC in same region\n                                        (start_addr_in_pic_d  & end_addr_in_dccm_d));                                     // 0. DCCM -> PIC cross when DCCM/PIC in same region\n    if (pt.PMP_ENTRIES > 0) begin\n      assign mpu_access_fault_d   = (lsu_pmp_error_start | lsu_pmp_error_end);                                         // X. Address is in blocked region\n    end else begin\n      assign mpu_access_fault_d   = (~start_addr_in_dccm_region_d & ~non_dccm_access_ok);                              // 3. Address is not in a populated non-dccm region\n    end\n   end else begin\n      assign unmapped_access_fault_d = ((start_addr_in_dccm_region_d & ~start_addr_in_dccm_d)                              |   // 0. Addr in dccm region but not in dccm offset\n                                        (end_addr_in_dccm_region_d & ~end_addr_in_dccm_d)                                  |   // 0. Addr in dccm region but not in dccm offset\n                                        (start_addr_in_pic_region_d & ~start_addr_in_pic_d)                                |   // 0. Addr in picm region but not in picm offset\n                                        (end_addr_in_pic_region_d & ~end_addr_in_pic_d));                                      // 0. Addr in picm region but not in picm offset\n    if (pt.PMP_ENTRIES > 0) begin\n      assign mpu_access_fault_d   = (lsu_pmp_error_start | lsu_pmp_error_end);                                              // X. Address is in blocked region\n    end else begin\n      assign mpu_access_fault_d   = (~start_addr_in_pic_region_d & ~start_addr_in_dccm_region_d & ~non_dccm_access_ok);     // 3. Address is not in a populated non-dccm region\n    end\n   end\n\n   assign access_fault_d = (unmapped_access_fault_d | mpu_access_fault_d | picm_access_fault_d | regpred_access_fault_d) & lsu_pkt_d.valid & ~lsu_pkt_d.dma;\n   assign access_fault_mscause_d[3:0] = unmapped_access_fault_d ? 4'h2 : mpu_access_fault_d ? 4'h3 : regpred_access_fault_d ? 4'h5 : picm_access_fault_d ? 4'h6 : 4'h0;\n\n   // Misaligned happens due to 2 reasons\n   // 0. Region cross\n   // 1. sideeffects access which are not aligned\n   assign regcross_misaligned_fault_d = (start_addr_d[31:28] != end_addr_d[31:28]);\n   assign sideeffect_misaligned_fault_d = (is_sideeffects_d & ~is_aligned_d);\n   assign misaligned_fault_d = (regcross_misaligned_fault_d | (sideeffect_misaligned_fault_d & addr_external_d)) & lsu_pkt_d.valid & ~lsu_pkt_d.dma;\n   assign misaligned_fault_mscause_d[3:0] = regcross_misaligned_fault_d ? 4'h2 : sideeffect_misaligned_fault_d ? 4'h1 : 4'h0;\n\n   assign exc_mscause_d[3:0] = misaligned_fault_d ? misaligned_fault_mscause_d[3:0] : access_fault_mscause_d[3:0];\n\n   // Fast interrupt error logic\n   assign fir_dccm_access_error_d    = ((start_addr_in_dccm_region_d & ~start_addr_in_dccm_d) |\n                                                                                (end_addr_in_dccm_region_d   & ~end_addr_in_dccm_d)) & lsu_pkt_d.valid & lsu_pkt_d.fast_int;\n   assign fir_nondccm_access_error_d = ~(start_addr_in_dccm_region_d & end_addr_in_dccm_region_d) & lsu_pkt_d.valid & lsu_pkt_d.fast_int;\n\n   rvdff #(.WIDTH(1))   is_sideeffects_mff (.din(is_sideeffects_d), .dout(is_sideeffects_m), .clk(lsu_c2_m_clk), .*);\n\nendmodule // el2_lsu_addrcheck\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: lsu interface with interface queue\n// Comments:\n//\n//********************************************************************************\n\nmodule el2_lsu_bus_buffer\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n   input logic                          clk,                                // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n   input logic                          clk_override,                       // Override non-functional clock gating\n   input logic                          rst_l,                              // reset, active low\n   input logic                          scan_mode,                          // scan mode\n   input logic                          dec_tlu_external_ldfwd_disable,     // disable load to load forwarding for externals\n   input logic                          dec_tlu_wb_coalescing_disable,      // disable write buffer coalescing\n   input logic                          dec_tlu_sideeffect_posted_disable,  // Don't block the sideeffect load store to the bus\n   input logic                          dec_tlu_force_halt,\n\n   // various clocks needed for the bus reads and writes\n   input logic                          lsu_bus_obuf_c1_clken,\n   input logic                          lsu_busm_clken,\n   input logic                          lsu_c2_r_clk,\n   input logic                          lsu_bus_ibuf_c1_clk,\n   input logic                          lsu_bus_obuf_c1_clk,\n   input logic                          lsu_bus_buf_c1_clk,\n   input logic                          lsu_free_c2_clk,\n   input logic                          lsu_busm_clk,\n\n\n   input logic                          dec_lsu_valid_raw_d,            // Raw valid for address computation\n   input el2_lsu_pkt_t                 lsu_pkt_m,                      // lsu packet flowing down the pipe\n   input el2_lsu_pkt_t                 lsu_pkt_r,                      // lsu packet flowing down the pipe\n\n   input logic [31:0]                   lsu_addr_m,                     // lsu address flowing down the pipe\n   input logic [31:0]                   end_addr_m,                     // lsu address flowing down the pipe\n   input logic [31:0]                   lsu_addr_r,                     // lsu address flowing down the pipe\n   input logic [31:0]                   end_addr_r,                     // lsu address flowing down the pipe\n   input logic [31:0]                   store_data_r,                   // store data flowing down the pipe\n\n   input logic                          no_word_merge_r,                // r store doesn't need to wait in ibuf since it will not coalesce\n   input logic                          no_dword_merge_r,               // r store doesn't need to wait in ibuf since it will not coalesce\n   input logic                          lsu_busreq_m,                   // bus request is in m\n   output logic                         lsu_busreq_r,                   // bus request is in r\n   input logic                          ld_full_hit_m,                  // load can get all its byte from a write buffer entry\n   input logic                          flush_m_up,                     // flush\n   input logic                          flush_r,                        // flush\n   input logic                          lsu_commit_r,                   // lsu instruction in r commits\n   input logic                          is_sideeffects_r,               // lsu attribute is side_effects\n   input logic                          ldst_dual_d,                    // load/store is unaligned at 32 bit boundary\n   input logic                          ldst_dual_m,                    // load/store is unaligned at 32 bit boundary\n   input logic                          ldst_dual_r,                    // load/store is unaligned at 32 bit boundary\n\n   input logic [7:0]                    ldst_byteen_ext_m,              // HI and LO signals\n\n   output logic                         lsu_bus_buffer_pend_any,          // bus buffer has a pending bus entry\n   output logic                         lsu_bus_buffer_full_any,          // bus buffer is full\n   output logic                         lsu_bus_buffer_empty_any,         // bus buffer is empty\n\n   output logic [3:0]                   ld_byte_hit_buf_lo, ld_byte_hit_buf_hi,    // Byte enables for forwarding data\n   output logic [31:0]                  ld_fwddata_buf_lo, ld_fwddata_buf_hi,      // load forwarding data\n\n   output logic                         lsu_imprecise_error_load_any,     // imprecise load bus error\n   output logic                         lsu_imprecise_error_store_any,    // imprecise store bus error\n   output logic [31:0]                  lsu_imprecise_error_addr_any,     // address of the imprecise error\n\n   // Non-blocking loads\n   output logic                               lsu_nonblock_load_valid_m,     // there is an external load -> put in the cam\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_tag_m,       // the tag of the external non block load\n   output logic                               lsu_nonblock_load_inv_r,       // invalidate signal for the cam entry for non block loads\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_inv_tag_r,   // tag of the enrty which needs to be invalidated\n   output logic                               lsu_nonblock_load_data_valid,  // the non block is valid - sending information back to the cam\n   output logic                               lsu_nonblock_load_data_error,  // non block load has an error\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_data_tag,    // the tag of the non block load sending the data/error\n   output logic [31:0]                        lsu_nonblock_load_data,        // Data of the non block load\n\n   // PMU events\n   output logic                         lsu_pmu_bus_trxn,\n   output logic                         lsu_pmu_bus_misaligned,\n   output logic                         lsu_pmu_bus_error,\n   output logic                         lsu_pmu_bus_busy,\n\n   // AXI Write Channels\n   output logic                            lsu_axi_awvalid,\n   input  logic                            lsu_axi_awready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_awid,\n   output logic [31:0]                     lsu_axi_awaddr,\n   output logic [3:0]                      lsu_axi_awregion,\n   output logic [7:0]                      lsu_axi_awlen,\n   output logic [2:0]                      lsu_axi_awsize,\n   output logic [1:0]                      lsu_axi_awburst,\n   output logic                            lsu_axi_awlock,\n   output logic [3:0]                      lsu_axi_awcache,\n   output logic [2:0]                      lsu_axi_awprot,\n   output logic [3:0]                      lsu_axi_awqos,\n\n   output logic                            lsu_axi_wvalid,\n   input  logic                            lsu_axi_wready,\n   output logic [63:0]                     lsu_axi_wdata,\n   output logic [7:0]                      lsu_axi_wstrb,\n   output logic                            lsu_axi_wlast,\n\n   input  logic                            lsu_axi_bvalid,\n   output logic                            lsu_axi_bready,\n   input  logic [1:0]                      lsu_axi_bresp,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_bid,\n\n   // AXI Read Channels\n   output logic                            lsu_axi_arvalid,\n   input  logic                            lsu_axi_arready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_arid,\n   output logic [31:0]                     lsu_axi_araddr,\n   output logic [3:0]                      lsu_axi_arregion,\n   output logic [7:0]                      lsu_axi_arlen,\n   output logic [2:0]                      lsu_axi_arsize,\n   output logic [1:0]                      lsu_axi_arburst,\n   output logic                            lsu_axi_arlock,\n   output logic [3:0]                      lsu_axi_arcache,\n   output logic [2:0]                      lsu_axi_arprot,\n   output logic [3:0]                      lsu_axi_arqos,\n\n   input  logic                            lsu_axi_rvalid,\n   output logic                            lsu_axi_rready,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_rid,\n   input  logic [63:0]                     lsu_axi_rdata,\n   input  logic [1:0]                      lsu_axi_rresp,\n\n   input logic                             lsu_bus_clk_en,\n   input logic                             lsu_bus_clk_en_q\n\n);\n\n   // For Ld: IDLE -> WAIT -> CMD -> RESP -> DONE_PARTIAL(?) -> DONE_WAIT(?) -> DONE -> IDLE\n   // For St: IDLE -> WAIT -> CMD -> RESP(?) -> IDLE\n   typedef enum logic [2:0] {IDLE=3'b000, WAIT=3'b001, CMD=3'b010, RESP=3'b011, DONE_PARTIAL=3'b100, DONE_WAIT=3'b101, DONE=3'b110} state_t;\n\n   localparam DEPTH     = pt.LSU_NUM_NBLOAD;\n   localparam DEPTH_LOG2 = pt.LSU_NUM_NBLOAD_WIDTH;\n   localparam TIMER     = 8;   // This can be only power of 2\n   localparam TIMER_MAX = TIMER - 1;  // Maximum value of timer\n   localparam TIMER_LOG2 = (TIMER < 2) ? 1 : $clog2(TIMER);\n\n   logic [3:0]                          ldst_byteen_hi_m, ldst_byteen_lo_m;\n   logic [DEPTH-1:0]                    ld_addr_hitvec_lo, ld_addr_hitvec_hi;\n   logic [3:0][DEPTH-1:0]               ld_byte_hitvec_lo, ld_byte_hitvec_hi;\n   logic [3:0][DEPTH-1:0]               ld_byte_hitvecfn_lo, ld_byte_hitvecfn_hi;\n\n   logic                                ld_addr_ibuf_hit_lo, ld_addr_ibuf_hit_hi;\n   logic [3:0]                          ld_byte_ibuf_hit_lo, ld_byte_ibuf_hit_hi;\n\n   logic [3:0]                          ldst_byteen_r;\n   logic [3:0]                          ldst_byteen_hi_r, ldst_byteen_lo_r;\n   logic [31:0]                         store_data_hi_r, store_data_lo_r;\n   logic                                is_aligned_r;                   // Aligned load/store\n   logic                                ldst_samedw_r;\n\n   logic                                lsu_nonblock_load_valid_r;\n   logic [31:0]                         lsu_nonblock_load_data_hi, lsu_nonblock_load_data_lo, lsu_nonblock_data_unalgn;\n   logic [1:0]                          lsu_nonblock_addr_offset;\n   logic [1:0]                          lsu_nonblock_sz;\n   logic                                lsu_nonblock_unsign;\n   logic                                lsu_nonblock_load_data_ready;\n\n   logic [DEPTH-1:0]                    CmdPtr0Dec, CmdPtr1Dec;\n   logic [DEPTH-1:0]                    RspPtrDec;\n   logic [DEPTH_LOG2-1:0]               CmdPtr0, CmdPtr1;\n   logic [DEPTH_LOG2-1:0]               RspPtr;\n   logic [DEPTH_LOG2-1:0]               WrPtr0_m, WrPtr0_r;\n   logic [DEPTH_LOG2-1:0]               WrPtr1_m, WrPtr1_r;\n   logic                                found_wrptr0, found_wrptr1, found_cmdptr0, found_cmdptr1;\n   logic [3:0]                          buf_numvld_any, buf_numvld_wrcmd_any, buf_numvld_cmd_any, buf_numvld_pend_any;\n   logic                                any_done_wait_state;\n   logic                                bus_sideeffect_pend;\n   logic                                bus_coalescing_disable;\n\n   logic                                bus_addr_match_pending;\n   logic                                bus_cmd_sent, bus_cmd_ready;\n   logic                                bus_wcmd_sent, bus_wdata_sent;\n   logic                                bus_rsp_read, bus_rsp_write;\n   logic [pt.LSU_BUS_TAG-1:0]           bus_rsp_read_tag, bus_rsp_write_tag;\n   logic                                bus_rsp_read_error, bus_rsp_write_error;\n   logic [63:0]                         bus_rsp_rdata;\n\n   // Bus buffer signals\n   state_t [DEPTH-1:0]                  buf_state;\n   logic   [DEPTH-1:0][1:0]             buf_sz;\n   logic   [DEPTH-1:0][31:0]            buf_addr;\n   logic   [DEPTH-1:0][3:0]             buf_byteen;\n   logic   [DEPTH-1:0]                  buf_sideeffect;\n   logic   [DEPTH-1:0]                  buf_write;\n   logic   [DEPTH-1:0]                  buf_unsign;\n   logic   [DEPTH-1:0]                  buf_dual;\n   logic   [DEPTH-1:0]                  buf_samedw;\n   logic   [DEPTH-1:0]                  buf_nomerge;\n   logic   [DEPTH-1:0]                  buf_dualhi;\n   logic   [DEPTH-1:0][DEPTH_LOG2-1:0]  buf_dualtag;\n   logic   [DEPTH-1:0]                  buf_ldfwd;\n   logic   [DEPTH-1:0][DEPTH_LOG2-1:0]  buf_ldfwdtag;\n   logic   [DEPTH-1:0]                  buf_error;\n   logic   [DEPTH-1:0][31:0]            buf_data;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_age, buf_age_younger;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_rspage, buf_rsp_pickage;\n\n   state_t [DEPTH-1:0]                  buf_nxtstate;\n   logic   [DEPTH-1:0]                  buf_rst;\n   logic   [DEPTH-1:0]                  buf_state_en;\n   logic   [DEPTH-1:0]                  buf_cmd_state_bus_en;\n   logic   [DEPTH-1:0]                  buf_resp_state_bus_en;\n   logic   [DEPTH-1:0]                  buf_state_bus_en;\n   logic   [DEPTH-1:0]                  buf_dual_in;\n   logic   [DEPTH-1:0]                  buf_samedw_in;\n   logic   [DEPTH-1:0]                  buf_nomerge_in;\n   logic   [DEPTH-1:0]                  buf_sideeffect_in;\n   logic   [DEPTH-1:0]                  buf_unsign_in;\n   logic   [DEPTH-1:0][1:0]             buf_sz_in;\n   logic   [DEPTH-1:0]                  buf_write_in;\n   logic   [DEPTH-1:0]                  buf_wr_en;\n   logic   [DEPTH-1:0]                  buf_dualhi_in;\n   logic   [DEPTH-1:0][DEPTH_LOG2-1:0]  buf_dualtag_in;\n   logic   [DEPTH-1:0]                  buf_ldfwd_en;\n   logic   [DEPTH-1:0]                  buf_ldfwd_in;\n   logic   [DEPTH-1:0][DEPTH_LOG2-1:0]  buf_ldfwdtag_in;\n   logic   [DEPTH-1:0][3:0]             buf_byteen_in;\n   logic   [DEPTH-1:0][31:0]            buf_addr_in;\n   logic   [DEPTH-1:0][31:0]            buf_data_in;\n   logic   [DEPTH-1:0]                  buf_error_en;\n   logic   [DEPTH-1:0]                  buf_data_en;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_age_in;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_ageQ;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_rspage_set;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_rspage_in;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_rspageQ;\n\n   // Input buffer signals\n   logic                               ibuf_valid;\n   logic                               ibuf_dual;\n   logic                               ibuf_samedw;\n   logic                               ibuf_nomerge;\n   logic [DEPTH_LOG2-1:0]              ibuf_tag;\n   logic [DEPTH_LOG2-1:0]              ibuf_dualtag;\n   logic                               ibuf_sideeffect;\n   logic                               ibuf_unsign;\n   logic                               ibuf_write;\n   logic [1:0]                         ibuf_sz;\n   logic [3:0]                         ibuf_byteen;\n   logic [31:0]                        ibuf_addr;\n   logic [31:0]                        ibuf_data;\n   logic [TIMER_LOG2-1:0]              ibuf_timer;\n\n   logic                               ibuf_byp;\n   logic                               ibuf_wr_en;\n   logic                               ibuf_rst;\n   logic                               ibuf_force_drain;\n   logic                               ibuf_drain_vld;\n   logic [DEPTH-1:0]                   ibuf_drainvec_vld;\n   logic [DEPTH_LOG2-1:0]              ibuf_tag_in;\n   logic [DEPTH_LOG2-1:0]              ibuf_dualtag_in;\n   logic [1:0]                         ibuf_sz_in;\n   logic [31:0]                        ibuf_addr_in;\n   logic [3:0]                         ibuf_byteen_in;\n   logic [31:0]                        ibuf_data_in;\n   logic [TIMER_LOG2-1:0]              ibuf_timer_in;\n   logic [3:0]                         ibuf_byteen_out;\n   logic [31:0]                        ibuf_data_out;\n   logic                               ibuf_merge_en, ibuf_merge_in;\n\n   // Output buffer signals\n   logic                               obuf_valid;\n   logic                               obuf_write;\n   logic                               obuf_nosend;\n   logic                               obuf_rdrsp_pend;\n   logic                               obuf_sideeffect;\n   logic [31:0]                        obuf_addr;\n   logic [63:0]                        obuf_data;\n   logic [1:0]                         obuf_sz;\n   logic [7:0]                         obuf_byteen;\n   logic                               obuf_merge;\n   logic                               obuf_cmd_done, obuf_data_done;\n   logic [pt.LSU_BUS_TAG-1:0]          obuf_tag0;\n   logic [pt.LSU_BUS_TAG-1:0]          obuf_tag1;\n   logic [pt.LSU_BUS_TAG-1:0]          obuf_rdrsp_tag;\n\n   logic                               ibuf_buf_byp;\n   logic                               obuf_force_wr_en;\n   logic                               obuf_wr_wait;\n   logic                               obuf_wr_en, obuf_wr_enQ;\n   logic                               obuf_rst;\n   logic                               obuf_write_in;\n   logic                               obuf_nosend_in;\n   logic                               obuf_rdrsp_pend_en;\n   logic                               obuf_rdrsp_pend_in;\n   logic                               obuf_sideeffect_in;\n   logic                               obuf_aligned_in;\n   logic [31:0]                        obuf_addr_in;\n   logic [63:0]                        obuf_data_in;\n   logic [1:0]                         obuf_sz_in;\n   logic [7:0]                         obuf_byteen_in;\n   logic                               obuf_merge_in;\n   logic                               obuf_cmd_done_in, obuf_data_done_in;\n   logic [pt.LSU_BUS_TAG-1:0]          obuf_tag0_in;\n   logic [pt.LSU_BUS_TAG-1:0]          obuf_tag1_in;\n   logic [pt.LSU_BUS_TAG-1:0]          obuf_rdrsp_tag_in;\n\n   logic                               obuf_merge_en;\n   logic [TIMER_LOG2-1:0]              obuf_wr_timer, obuf_wr_timer_in;\n   logic [7:0]                         obuf_byteen0_in, obuf_byteen1_in;\n   logic [63:0]                        obuf_data0_in, obuf_data1_in;\n\n   logic                               lsu_axi_awvalid_q, lsu_axi_awready_q;\n   logic                               lsu_axi_wvalid_q, lsu_axi_wready_q;\n   logic                               lsu_axi_arvalid_q, lsu_axi_arready_q;\n   logic                               lsu_axi_bvalid_q, lsu_axi_bready_q;\n   logic                               lsu_axi_rvalid_q, lsu_axi_rready_q;\n   logic [pt.LSU_BUS_TAG-1:0]          lsu_axi_bid_q, lsu_axi_rid_q;\n   logic [1:0]                         lsu_axi_bresp_q, lsu_axi_rresp_q;\n   logic [pt.LSU_BUS_TAG-1:0]          lsu_imprecise_error_store_tag;\n   logic [63:0]                        lsu_axi_rdata_q;\n\n   //------------------------------------------------------------------------------\n   // Load forwarding logic start\n   //------------------------------------------------------------------------------\n\n   // Function to do 8 to 3 bit encoding\n   function automatic logic [2:0] f_Enc8to3;\n      input logic [7:0] Dec_value;\n\n      logic [2:0]       Enc_value;\n      Enc_value[0] = Dec_value[1] | Dec_value[3] | Dec_value[5] | Dec_value[7];\n      Enc_value[1] = Dec_value[2] | Dec_value[3] | Dec_value[6] | Dec_value[7];\n      Enc_value[2] = Dec_value[4] | Dec_value[5] | Dec_value[6] | Dec_value[7];\n\n      return Enc_value[2:0];\n   endfun"}
{"text": "ction // f_Enc8to3\n\n   // Buffer hit logic for bus load forwarding\n   assign ldst_byteen_hi_m[3:0]   = ldst_byteen_ext_m[7:4];\n   assign ldst_byteen_lo_m[3:0]   = ldst_byteen_ext_m[3:0];\n   for (genvar i=0; i<DEPTH; i++) begin\n      assign ld_addr_hitvec_lo[i] = (lsu_addr_m[31:2] == buf_addr[i][31:2]) & buf_write[i] & (buf_state[i] != IDLE) & lsu_busreq_m;\n      assign ld_addr_hitvec_hi[i] = (end_addr_m[31:2] == buf_addr[i][31:2]) & buf_write[i] & (buf_state[i] != IDLE) & lsu_busreq_m;\n   end\n\n   for (genvar j=0; j<4; j++) begin\n     assign ld_byte_hit_buf_lo[j] = |(ld_byte_hitvecfn_lo[j]) | ld_byte_ibuf_hit_lo[j];\n     assign ld_byte_hit_buf_hi[j] = |(ld_byte_hitvecfn_hi[j]) | ld_byte_ibuf_hit_hi[j];\n     for (genvar i=0; i<DEPTH; i++) begin\n         assign ld_byte_hitvec_lo[j][i] = ld_addr_hitvec_lo[i] & buf_byteen[i][j] & ldst_byteen_lo_m[j];\n         assign ld_byte_hitvec_hi[j][i] = ld_addr_hitvec_hi[i] & buf_byteen[i][j] & ldst_byteen_hi_m[j];\n\n         assign ld_byte_hitvecfn_lo[j][i] = ld_byte_hitvec_lo[j][i] & ~(|(ld_byte_hitvec_lo[j] & buf_age_younger[i])) & ~ld_byte_ibuf_hit_lo[j];  // Kill the byte enable if younger entry exists or byte exists in ibuf\n         assign ld_byte_hitvecfn_hi[j][i] = ld_byte_hitvec_hi[j][i] & ~(|(ld_byte_hitvec_hi[j] & buf_age_younger[i])) & ~ld_byte_ibuf_hit_hi[j];  // Kill the byte enable if younger entry exists or byte exists in ibuf\n      end\n   end\n\n   // Hit in the ibuf\n   assign ld_addr_ibuf_hit_lo = (lsu_addr_m[31:2] == ibuf_addr[31:2]) & ibuf_write & ibuf_valid & lsu_busreq_m;\n   assign ld_addr_ibuf_hit_hi = (end_addr_m[31:2] == ibuf_addr[31:2]) & ibuf_write & ibuf_valid & lsu_busreq_m;\n\n   for (genvar i=0; i<4; i++) begin\n      assign ld_byte_ibuf_hit_lo[i] = ld_addr_ibuf_hit_lo & ibuf_byteen[i] & ldst_byteen_lo_m[i];\n      assign ld_byte_ibuf_hit_hi[i] = ld_addr_ibuf_hit_hi & ibuf_byteen[i] & ldst_byteen_hi_m[i];\n   end\n\n   always_comb begin\n      ld_fwddata_buf_lo[31:0] = {{8{ld_byte_ibuf_hit_lo[3]}},{8{ld_byte_ibuf_hit_lo[2]}},{8{ld_byte_ibuf_hit_lo[1]}},{8{ld_byte_ibuf_hit_lo[0]}}} & ibuf_data[31:0];\n      ld_fwddata_buf_hi[31:0] = {{8{ld_byte_ibuf_hit_hi[3]}},{8{ld_byte_ibuf_hit_hi[2]}},{8{ld_byte_ibuf_hit_hi[1]}},{8{ld_byte_ibuf_hit_hi[0]}}} & ibuf_data[31:0];\n      for (int i=0; i<DEPTH; i++) begin\n         ld_fwddata_buf_lo[7:0]   |= {8{ld_byte_hitvecfn_lo[0][i]}} & buf_data[i][7:0];\n         ld_fwddata_buf_lo[15:8]  |= {8{ld_byte_hitvecfn_lo[1][i]}} & buf_data[i][15:8];\n         ld_fwddata_buf_lo[23:16] |= {8{ld_byte_hitvecfn_lo[2][i]}} & buf_data[i][23:16];\n         ld_fwddata_buf_lo[31:24] |= {8{ld_byte_hitvecfn_lo[3][i]}} & buf_data[i][31:24];\n\n         ld_fwddata_buf_hi[7:0]   |= {8{ld_byte_hitvecfn_hi[0][i]}} & buf_data[i][7:0];\n         ld_fwddata_buf_hi[15:8]  |= {8{ld_byte_hitvecfn_hi[1][i]}} & buf_data[i][15:8];\n         ld_fwddata_buf_hi[23:16] |= {8{ld_byte_hitvecfn_hi[2][i]}} & buf_data[i][23:16];\n         ld_fwddata_buf_hi[31:24] |= {8{ld_byte_hitvecfn_hi[3][i]}} & buf_data[i][31:24];\n      end\n   end\n\n   //------------------------------------------------------------------------------\n   // Load forwarding logic end\n   //------------------------------------------------------------------------------\n\n   assign bus_coalescing_disable = dec_tlu_wb_coalescing_disable | pt.BUILD_AHB_LITE;\n\n   // Get the hi/lo byte enable\n   assign ldst_byteen_r[3:0] = ({4{lsu_pkt_r.by}}   & 4'b0001) |\n                                 ({4{lsu_pkt_r.half}} & 4'b0011) |\n                                 ({4{lsu_pkt_r.word}} & 4'b1111);\n\n   assign {ldst_byteen_hi_r[3:0], ldst_byteen_lo_r[3:0]} = {4'b0,ldst_byteen_r[3:0]} << lsu_addr_r[1:0];\n   assign {store_data_hi_r[31:0], store_data_lo_r[31:0]} = {32'b0,store_data_r[31:0]} << 8*lsu_addr_r[1:0];\n   assign ldst_samedw_r    = (lsu_addr_r[3] == end_addr_r[3]);\n   assign is_aligned_r    = (lsu_pkt_r.word & (lsu_addr_r[1:0] == 2'b0)) |\n                            (lsu_pkt_r.half & (lsu_addr_r[0] == 1'b0))   |\n                            lsu_pkt_r.by;\n\n   //------------------------------------------------------------------------------\n   // Input buffer logic starts here\n   //------------------------------------------------------------------------------\n\n   assign ibuf_byp = lsu_busreq_r & (lsu_pkt_r.load | no_word_merge_r) & ~ibuf_valid;\n   assign ibuf_wr_en = lsu_busreq_r & lsu_commit_r & ~ibuf_byp;\n   assign ibuf_rst   = (ibuf_drain_vld & ~ibuf_wr_en) | dec_tlu_force_halt;\n   assign ibuf_force_drain = lsu_busreq_m & ~lsu_busreq_r & ibuf_valid & (lsu_pkt_m.load | (ibuf_addr[31:2] != lsu_addr_m[31:2]));  // Move the ibuf to buf if there is a non-colaescable ld/st in m but nothing in r\n   assign ibuf_drain_vld = ibuf_valid & (((ibuf_wr_en | (ibuf_timer == TIMER_MAX)) & ~(ibuf_merge_en & ibuf_merge_in)) | ibuf_byp | ibuf_force_drain | ibuf_sideeffect | ~ibuf_write | bus_coalescing_disable);\n   assign ibuf_tag_in[DEPTH_LOG2-1:0] = (ibuf_merge_en & ibuf_merge_in) ? ibuf_tag[DEPTH_LOG2-1:0] : (ldst_dual_r ? WrPtr1_r : WrPtr0_r);\n   assign ibuf_dualtag_in[DEPTH_LOG2-1:0] = WrPtr0_r;\n   assign ibuf_sz_in[1:0]   = {lsu_pkt_r.word, lsu_pkt_r.half};\n   assign ibuf_addr_in[31:0] = ldst_dual_r ? end_addr_r[31:0] : lsu_addr_r[31:0];\n   assign ibuf_byteen_in[3:0] = (ibuf_merge_en & ibuf_merge_in) ? (ibuf_byteen[3:0] | ldst_byteen_lo_r[3:0]) : (ldst_dual_r ? ldst_byteen_hi_r[3:0] : ldst_byteen_lo_r[3:0]);\n   for (genvar i=0; i<4; i++) begin\n      assign ibuf_data_in[(8*i)+7:(8*i)] = (ibuf_merge_en & ibuf_merge_in) ? (ldst_byteen_lo_r[i] ? store_data_lo_r[(8*i)+7:(8*i)] : ibuf_data[(8*i)+7:(8*i)]) :\n                                                                             (ldst_dual_r ? store_data_hi_r[(8*i)+7:(8*i)] : store_data_lo_r[(8*i)+7:(8*i)]);\n   end\n   assign ibuf_timer_in = ibuf_wr_en ? '0 : (ibuf_timer < TIMER_MAX) ? (ibuf_timer + 1'b1) : ibuf_timer;\n\n\n   assign ibuf_merge_en = lsu_busreq_r & lsu_commit_r & lsu_pkt_r.store & ibuf_valid & ibuf_write & (lsu_addr_r[31:2] == ibuf_addr[31:2]) & ~is_sideeffects_r & ~bus_coalescing_disable;\n   assign ibuf_merge_in = ~ldst_dual_r;   // If it's a unaligned store, merge needs to happen on the way out of ibuf\n\n   // ibuf signals going to bus buffer after merging\n   for (genvar i=0; i<4; i++) begin\n      assign ibuf_byteen_out[i] = (ibuf_merge_en & ~ibuf_merge_in) ? (ibuf_byteen[i] | ldst_byteen_lo_r[i]) : ibuf_byteen[i];\n      assign ibuf_data_out[(8*i)+7:(8*i)] = (ibuf_merge_en & ~ibuf_merge_in) ? (ldst_byteen_lo_r[i] ? store_data_lo_r[(8*i)+7:(8*i)] : ibuf_data[(8*i)+7:(8*i)]) :\n                                                                                                        ibuf_data[(8*i)+7:(8*i)];\n   end\n\n   rvdffsc #(.WIDTH(1))              ibuf_valid_ff     (.din(1'b1),                      .dout(ibuf_valid),      .en(ibuf_wr_en), .clear(ibuf_rst), .clk(lsu_free_c2_clk), .*);\n   rvdffs  #(.WIDTH(DEPTH_LOG2))     ibuf_tagff        (.din(ibuf_tag_in),               .dout(ibuf_tag),        .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(DEPTH_LOG2))     ibuf_dualtagff    (.din(ibuf_dualtag_in),           .dout(ibuf_dualtag),    .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(1))              ibuf_dualff       (.din(ldst_dual_r),               .dout(ibuf_dual),       .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(1))              ibuf_samedwff     (.din(ldst_samedw_r),             .dout(ibuf_samedw),     .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(1))              ibuf_nomergeff    (.din(no_dword_merge_r),          .dout(ibuf_nomerge),    .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(1))              ibuf_sideeffectff (.din(is_sideeffects_r),          .dout(ibuf_sideeffect), .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(1))              ibuf_unsignff     (.din(lsu_pkt_r.unsign),          .dout(ibuf_unsign),     .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(1))              ibuf_writeff      (.din(lsu_pkt_r.store),           .dout(ibuf_write),      .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(2))              ibuf_szff         (.din(ibuf_sz_in[1:0]),           .dout(ibuf_sz),         .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffe  #(.WIDTH(32))             ibuf_addrff       (.din(ibuf_addr_in[31:0]),        .dout(ibuf_addr),       .en(ibuf_wr_en),                                              .*);\n   rvdffs  #(.WIDTH(4))              ibuf_byteenff     (.din(ibuf_byteen_in[3:0]),       .dout(ibuf_byteen),     .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffe  #(.WIDTH(32))             ibuf_dataff       (.din(ibuf_data_in[31:0]),        .dout(ibuf_data),       .en(ibuf_wr_en),                                              .*);\n   rvdff   #(.WIDTH(TIMER_LOG2))     ibuf_timerff      (.din(ibuf_timer_in),             .dout(ibuf_timer),                                         .clk(lsu_free_c2_clk),     .*);\n\n\n   //------------------------------------------------------------------------------\n   // Input buffer logic ends here\n   //------------------------------------------------------------------------------\n\n\n   //------------------------------------------------------------------------------\n   // Output buffer logic starts here\n   //------------------------------------------------------------------------------\n\n   assign obuf_wr_wait = (buf_numvld_wrcmd_any[3:0] == 4'b1) & (buf_numvld_cmd_any[3:0] == 4'b1) & (obuf_wr_timer != TIMER_MAX) &\n                         ~bus_coalescing_disable & ~buf_nomerge[CmdPtr0] & ~buf_sideeffect[CmdPtr0] & ~obuf_force_wr_en;\n   assign obuf_wr_timer_in = obuf_wr_en ? 3'b0: (((buf_numvld_cmd_any > 4'b0) & (obuf_wr_timer < TIMER_MAX)) ? (obuf_wr_timer + 1'b1) : obuf_wr_timer);\n   assign obuf_force_wr_en = lsu_busreq_m & ~lsu_busreq_r & ~ibuf_valid & (buf_numvld_cmd_any[3:0] == 4'b1) & (lsu_addr_m[31:2] != buf_addr[CmdPtr0][31:2]);   // Entry in m can't merge with entry going to obuf and there is no entry in between\n   assign ibuf_buf_byp = ibuf_byp & (buf_numvld_pend_any[3:0] == 4'b0) & (~lsu_pkt_r.store | no_dword_merge_r);\n\n   assign obuf_wr_en = ((ibuf_buf_byp & lsu_commit_r & ~(is_sideeffects_r & bus_sideeffect_pend)) |\n                        ((buf_state[CmdPtr0] == CMD) & found_cmdptr0 & ~buf_cmd_state_bus_en[CmdPtr0] & ~(buf_sideeffect[CmdPtr0] & bus_sideeffect_pend) &\n                         (~(buf_dual[CmdPtr0] & buf_samedw[CmdPtr0] & ~buf_write[CmdPtr0]) | found_cmdptr1 | buf_nomerge[CmdPtr0] | obuf_force_wr_en))) &\n                       (bus_cmd_ready | ~obuf_valid | obuf_nosend) & ~obuf_wr_wait  & ~bus_addr_match_pending & lsu_bus_clk_en;\n\n   assign obuf_rst   = ((bus_cmd_sent | (obuf_valid & obuf_nosend)) & ~obuf_wr_en & lsu_bus_clk_en) | dec_tlu_force_halt;\n\n   assign obuf_write_in      = ibuf_buf_byp ? lsu_pkt_r.store : buf_write[CmdPtr0];\n   assign obuf_sideeffect_in = ibuf_buf_byp ? is_sideeffects_r : buf_sideeffect[CmdPtr0];\n   assign obuf_addr_in[31:0] = ibuf_buf_byp ? lsu_addr_r[31:0] : buf_addr[CmdPtr0];\n   assign obuf_sz_in[1:0]    = ibuf_buf_byp ? {lsu_pkt_r.word, lsu_pkt_r.half} : buf_sz[CmdPtr0];\n   assign obuf_merge_in      = obuf_merge_en;\n   assign obuf_tag0_in[pt.LSU_BUS_TAG-1:0] = ibuf_buf_byp ? (pt.LSU_BUS_TAG)'(WrPtr0_r) : (pt.LSU_BUS_TAG)'(CmdPtr0);\n   assign obuf_tag1_in[pt.LSU_BUS_TAG-1:0] = ibuf_buf_byp ? (pt.LSU_BUS_TAG)'(WrPtr1_r) : (pt.LSU_BUS_TAG)'(CmdPtr1);\n\n   assign obuf_cmd_done_in    = ~(obuf_wr_en | obuf_rst) & (obuf_cmd_done | bus_wcmd_sent);\n   assign obuf_data_done_in   = ~(obuf_wr_en | obuf_rst) & (obuf_data_done | bus_wdata_sent);\n\n   assign obuf_aligned_in    = ibuf_buf_byp ? is_aligned_r : ((obuf_sz_in[1:0] == 2'b0) |\n                                                              (obuf_sz_in[0] & ~obuf_addr_in[0]) |\n                                                              (obuf_sz_in[1] & ~(|obuf_addr_in[1:0])));\n\n   assign obuf_rdrsp_pend_in  = ((~(obuf_wr_en & ~obuf_nosend_in) & obuf_rdrsp_pend & ~(bus_rsp_read & (bus_rsp_read_tag == obuf_rdrsp_tag))) | (bus_cmd_sent & ~obuf_write)) & ~dec_tlu_force_halt;\n   assign obuf_rdrsp_pend_en  = lsu_bus_clk_en | dec_tlu_force_halt;\n   assign obuf_rdrsp_tag_in[pt.LSU_BUS_TAG-1:0] = (bus_cmd_sent & ~obuf_write) ? obuf_tag0[pt.LSU_BUS_TAG-1:0] : obuf_rdrsp_tag[pt.LSU_BUS_TAG-1:0];\n   // No ld to ld fwd for aligned\n   assign obuf_nosend_in      = (obuf_addr_in[31:3] == obuf_addr[31:3]) & obuf_aligned_in & ~obuf_sideeffect & ~obuf_write & ~obuf_write_in & ~dec_tlu_external_ldfwd_disable &\n                                ((obuf_valid & ~obuf_nosend) | (obuf_rdrsp_pend & ~(bus_rsp_read & (bus_rsp_read_tag == obuf_rdrsp_tag))));\n\n   assign obuf_byteen0_in[7:0] = ibuf_buf_byp ? (lsu_addr_r[2] ? {ldst_byteen_lo_r[3:0],4'b0} : {4'b0,ldst_byteen_lo_r[3:0]}) :\n                                                (buf_addr[CmdPtr0][2] ? {buf_byteen[CmdPtr0],4'b0} : {4'b0,buf_byteen[CmdPtr0]});\n   assign obuf_byteen1_in[7:0] = ibuf_buf_byp ? (end_addr_r[2] ? {ldst_byteen_hi_r[3:0],4'b0} : {4'b0,ldst_byteen_hi_r[3:0]}) :\n                                                (buf_addr[CmdPtr1][2] ? {buf_byteen[CmdPtr1],4'b0} : {4'b0,buf_byteen[CmdPtr1]});\n   assign obuf_data0_in[63:0]  = ibuf_buf_byp ? (lsu_addr_r[2] ? {store_data_lo_r[31:0],32'b0} : {32'b0,store_data_lo_r[31:0]}) :\n                                                (buf_addr[CmdPtr0][2] ? {buf_data[CmdPtr0],32'b0} : {32'b0,buf_data[CmdPtr0]});\n   assign obuf_data1_in[63:0]  = ibuf_buf_byp ? (end_addr_r[2] ? {store_data_hi_r[31:0],32'b0} :{32'b0,store_data_hi_r[31:0]}) :\n                                                (buf_addr[CmdPtr1][2] ? {buf_data[CmdPtr1],32'b0} : {32'b0,buf_data[CmdPtr1]});\n\n   for (genvar i=0 ;i<8; i++) begin\n      assign obuf_byteen_in[i] = obuf_byteen0_in[i] | (obuf_merge_en & obuf_byteen1_in[i]);\n      assign obuf_data_in[(8*i)+7:(8*i)] = (obuf_merge_en & obuf_byteen1_in[i]) ? obuf_data1_in[(8*i)+7:(8*i)] : obuf_data0_in[(8*i)+7:(8*i)];\n   end\n\n   // No store obuf merging for AXI since all stores are sent non-posted. Can't track the second id right now\n   assign obuf_merge_en = ((CmdPtr0 != CmdPtr1) & found_cmdptr0 & found_cmdptr1 & (buf_state[CmdPtr0] == CMD) & (buf_state[CmdPtr1] == CMD) &\n                           ~buf_cmd_state_bus_en[CmdPtr0] & ~buf_sideeffect[CmdPtr0] &\n                           (~buf_write[CmdPtr0] & buf_dual[CmdPtr0] & ~buf_dualhi[CmdPtr0] & buf_samedw[CmdPtr0])) |  // CmdPtr0/CmdPtr1 are for same load which is within a DW\n                          (ibuf_buf_byp & ldst_samedw_r & ldst_dual_r);\n\n\n   rvdff_fpga  #(.WIDTH(1))              obuf_wren_ff      (.din(obuf_wr_en),                  .dout(obuf_wr_enQ),                                        .clk(lsu_busm_clk),        .clken(lsu_busm_clken), .rawclk(clk),        .*);\n   rvdffsc     #(.WIDTH(1))              obuf_valid_ff     (.din(1'b1),                        .dout(obuf_valid),      .en(obuf_wr_en), .clear(obuf_rst), .clk(lsu_free_c2_clk),                                                  .*);\n   rvdffs      #(.WIDTH(1))              obuf_nosend_ff    (.din(obuf_nosend_in),              .dout(obuf_nosend),     .en(obuf_wr_en),                   .clk(lsu_free_c2_clk),                                                  .*);\n   rvdffs      #(.WIDTH(1))              obuf_rdrsp_pend_ff(.din(obuf_rdrsp_pend_in),          .dout(obuf_rdrsp_pend), .en(obuf_rdrsp_pend_en),           .clk(lsu_free_c2_clk),                                                  .*);\n   rvdff_fpga  #(.WIDTH(1))              obuf_cmd_done_ff  (.din(obuf_cmd_done_in),            .dout(obuf_cmd_done),                                      .clk(lsu_busm_clk),        .clken(lsu_busm_clken),        .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(1))              obuf_data_done_ff (.din(obuf_data_done_in),           .dout(obuf_data_done),                                     .clk(lsu_busm_clk),        .clken(lsu_busm_clken),        .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(pt.LSU_BUS_TAG)) obuf_rdrsp_tagff  (.din(obuf_rdrsp_tag_in),           .dout(obuf_rdrsp_tag),                                     .clk(lsu_busm_clk),        .clken(lsu_busm_clken),        .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(pt.LSU_BUS_TAG)) obuf_tag0ff       (.din(obuf_tag0_in),                .dout(obuf_tag0),       .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(pt.LSU_BUS_TAG)) obuf_tag1ff       (.din(obuf_tag1_in),                .dout(obuf_tag1),       .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(1))              obuf_mergeff      (.din(obuf_merge_in),               .dout(obuf_merge),      .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(1))              obuf_writeff      (.din(obuf_write_in),               .dout(obuf_write),      .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(1))              obuf_sideeffectff (.din(obuf_sideeffect_in),          .dout(obuf_sideeffect), .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(2))              obuf_szff         (.din(obuf_sz_in[1:0]),             .dout(obuf_sz),         .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(8))              obuf_byteenff     (.din(obuf_byteen_in[7:0]),         .dout(obuf_byteen),     .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffe     #(.WIDTH(32))              obuf_addrff       (.din(obuf_addr_in[31:0]),          .dout(obuf_addr),       .en(obuf_wr_en),                                                                                           .*);\n   rvdffe     #(.WIDTH(64))              obuf_dataff       (.din(obuf_data_in[63:0]),          .dout(obuf_data),       .en(obuf_wr_en),                                                                                           .*);\n   rvdff_fpga #(.WIDTH(TIMER_LOG2))      obuf_timerff      (.din(obuf_wr_timer_in),            .dout(obuf_wr_timer),                                      .clk(lsu_busm_clk),        .clken(lsu_busm_clken), .rawclk(clk),        .*);\n\n\n   //------------------------------------------------------------------------------\n   // Output buffer logic ends here\n   //------------------------------------------------------------------------------\n\n   // Find the entry to allocate and entry to send\n   always_comb begin\n      WrPtr0_m[DEPTH_LOG2-1:0] = '0;\n      WrPtr1_m[DEPTH_LOG2-1:0] = '0;\n      found_wrptr0  = '0;\n      found_wrptr1  = '0;\n\n      // Find first write pointer\n      for (int i=0; i<DEPTH; i++) begin\n         if (~found_wrptr0) begin\n            WrPtr0_m[DEPTH_LOG2-1:0] = DEPTH_LOG2'(i);\n            found_wrptr0 = (buf_state[i] == IDLE) & ~((ibuf_valid & (ibuf_tag == i))                                               |\n                                                      (lsu_busreq_r & ((WrPtr0_r == i) | (ldst_dual_r & (WrPtr1_r == i)))));\n         end\n      end\n\n      // Find second write pointer\n      for (int i=0; i<DEPTH; i++) begin\n         if (~found_wrptr1) begin\n            WrPtr1_m[DEPTH_LOG2-1:0] = DEPTH_LOG2'(i);\n            found_wrptr1 = (buf_state[i] == IDLE) & ~((ibuf_valid & (ibuf_tag == i))                                               |\n                                                      (lsu_busreq_m & (WrPtr0_m == i))                                  "}
{"text": "       |\n                                                      (lsu_busreq_r & ((WrPtr0_r == i) | (ldst_dual_r & (WrPtr1_r == i)))));\n         end\n      end\n   end\n\n   // Get the command ptr\n   for (genvar i=0; i<DEPTH; i++) begin\n      // These should be one-hot\n      assign CmdPtr0Dec[i] = ~(|buf_age[i]) & (buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i];\n      assign CmdPtr1Dec[i] = ~(|(buf_age[i] & ~CmdPtr0Dec)) & ~CmdPtr0Dec[i] & (buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i];\n      assign RspPtrDec[i]  = ~(|buf_rsp_pickage[i]) & (buf_state[i] == DONE_WAIT);\n   end\n\n   assign found_cmdptr0 = |CmdPtr0Dec;\n   assign found_cmdptr1 = |CmdPtr1Dec;\n   assign CmdPtr0 = f_Enc8to3(8'(CmdPtr0Dec[DEPTH-1:0]));\n   assign CmdPtr1 = f_Enc8to3(8'(CmdPtr1Dec[DEPTH-1:0]));\n   assign RspPtr  = f_Enc8to3(8'(RspPtrDec[DEPTH-1:0]));\n\n   // Age vector\n   for (genvar i=0; i<DEPTH; i++) begin: GenAgeVec\n      for (genvar j=0; j<DEPTH; j++) begin\n         assign buf_age_in[i][j] = (((buf_state[i] == IDLE) & buf_state_en[i]) &\n                                    (((buf_state[j] == WAIT) | ((buf_state[j] == CMD) & ~buf_cmd_state_bus_en[j]))                   |       // Set age bit for older entries\n                                     (ibuf_drain_vld & lsu_busreq_r & (ibuf_byp | ldst_dual_r) & (i == WrPtr0_r) & (j == ibuf_tag))  |       // Set case for dual lo\n                                     (ibuf_byp & lsu_busreq_r & ldst_dual_r & (i == WrPtr1_r) & (j == WrPtr0_r))))                      |     // ibuf bypass case\n                                   buf_age[i][j];\n\n\n         assign buf_age[i][j]    = buf_ageQ[i][j] & ~((buf_state[j] == CMD) & buf_cmd_state_bus_en[j]) & ~dec_tlu_force_halt;  // Reset case\n\n         assign buf_age_younger[i][j] = (i == j) ? 1'b0: (~buf_age[i][j] & (buf_state[j] != IDLE));   // Younger entries\n      end\n   end\n\n   // Age vector for responses\n   for (genvar i=0; i<DEPTH; i++) begin: GenRspAgeVec\n      for (genvar j=0; j<DEPTH; j++) begin\n         assign buf_rspage_set[i][j] = ((buf_state[i] == IDLE) & buf_state_en[i]) &\n                                           (~((buf_state[j] == IDLE) | (buf_state[j] == DONE))                                         |       // Set age bit for older entries\n                                            (ibuf_drain_vld & lsu_busreq_r & (ibuf_byp | ldst_dual_r) & (DEPTH_LOG2'(i) == WrPtr0_r) & (DEPTH_LOG2'(j) == ibuf_tag))  |       // Set case for dual lo\n                                            (ibuf_byp & lsu_busreq_r & ldst_dual_r & (DEPTH_LOG2'(i) == WrPtr1_r) & (DEPTH_LOG2'(j) == WrPtr0_r)));\n         assign buf_rspage_in[i][j] = buf_rspage_set[i][j] | buf_rspage[i][j];\n         assign buf_rspage[i][j]    = buf_rspageQ[i][j] & ~((buf_state[j] == DONE) | (buf_state[j] == IDLE)) & ~dec_tlu_force_halt;  // Reset case\n         assign buf_rsp_pickage[i][j] = buf_rspageQ[i][j] & (buf_state[j] == DONE_WAIT);\n     end\n   end\n\n   //------------------------------------------------------------------------------\n   // Buffer logic\n   //------------------------------------------------------------------------------\n   for (genvar i=0; i<DEPTH; i++) begin\n\n      assign ibuf_drainvec_vld[i] = (ibuf_drain_vld & (i == ibuf_tag));\n      assign buf_byteen_in[i]     = ibuf_drainvec_vld[i] ? ibuf_byteen_out[3:0] : ((ibuf_byp & ldst_dual_r & (i == WrPtr1_r)) ? ldst_byteen_hi_r[3:0] : ldst_byteen_lo_r[3:0]);\n      assign buf_addr_in[i]       = ibuf_drainvec_vld[i] ? ibuf_addr[31:0] : ((ibuf_byp & ldst_dual_r & (i == WrPtr1_r)) ? end_addr_r[31:0] : lsu_addr_r[31:0]);\n      assign buf_dual_in[i]       = ibuf_drainvec_vld[i] ? ibuf_dual : ldst_dual_r;\n      assign buf_samedw_in[i]     = ibuf_drainvec_vld[i] ? ibuf_samedw : ldst_samedw_r;\n      assign buf_nomerge_in[i]    = ibuf_drainvec_vld[i] ? (ibuf_nomerge | ibuf_force_drain) : no_dword_merge_r;\n      assign buf_dualhi_in[i]     = ibuf_drainvec_vld[i] ? ibuf_dual : (ibuf_byp & ldst_dual_r & (i == WrPtr1_r));   // If it's dual, ibuf will always have the high\n      assign buf_dualtag_in[i]    = ibuf_drainvec_vld[i] ? ibuf_dualtag : ((ibuf_byp & ldst_dual_r & (i == WrPtr1_r)) ? WrPtr0_r : WrPtr1_r);\n      assign buf_sideeffect_in[i] = ibuf_drainvec_vld[i] ? ibuf_sideeffect : is_sideeffects_r;\n      assign buf_unsign_in[i]     = ibuf_drainvec_vld[i] ? ibuf_unsign : lsu_pkt_r.unsign;\n      assign buf_sz_in[i]         = ibuf_drainvec_vld[i] ? ibuf_sz : {lsu_pkt_r.word, lsu_pkt_r.half};\n      assign buf_write_in[i]      = ibuf_drainvec_vld[i] ? ibuf_write : lsu_pkt_r.store;\n\n      // Buffer entry state machine\n      always_comb begin\n         buf_nxtstate[i]          = IDLE;\n         buf_state_en[i]          = '0;\n         buf_resp_state_bus_en[i] = '0;\n         buf_state_bus_en[i]      = '0;\n         buf_wr_en[i]             = '0;\n         buf_data_in[i]           = '0;\n         buf_data_en[i]           = '0;\n         buf_error_en[i]          = '0;\n         buf_rst[i]               = dec_tlu_force_halt;\n         buf_ldfwd_en[i]          = dec_tlu_force_halt;\n         buf_ldfwd_in[i]          = '0;\n         buf_ldfwdtag_in[i]       = '0;\n\n         case (buf_state[i])\n            IDLE: begin\n                     buf_nxtstate[i] = lsu_bus_clk_en ? CMD : WAIT;\n                     buf_state_en[i] = (lsu_busreq_r & lsu_commit_r & (((ibuf_byp | ldst_dual_r) & ~ibuf_merge_en & (i == WrPtr0_r)) | (ibuf_byp & ldst_dual_r & (i == WrPtr1_r)))) |\n                                       (ibuf_drain_vld & (i == ibuf_tag));\n                     buf_wr_en[i]    = buf_state_en[i];\n                     buf_data_en[i]  = buf_state_en[i];\n                     buf_data_in[i]   = (ibuf_drain_vld & (i == ibuf_tag)) ? ibuf_data_out[31:0] : store_data_lo_r[31:0];\n                     buf_cmd_state_bus_en[i]  = '0;\n            end\n            WAIT: begin\n                     buf_nxtstate[i] = dec_tlu_force_halt ? IDLE : CMD;\n                     buf_state_en[i] = lsu_bus_clk_en | dec_tlu_force_halt;\n                     buf_cmd_state_bus_en[i]  = '0;\n            end\n            CMD: begin\n                     buf_nxtstate[i]          = dec_tlu_force_halt ? IDLE : (obuf_nosend & bus_rsp_read & (bus_rsp_read_tag == obuf_rdrsp_tag)) ? DONE_WAIT : RESP;\n                     buf_cmd_state_bus_en[i]  = ((obuf_tag0 == i) | (obuf_merge & (obuf_tag1 == i))) & obuf_valid & obuf_wr_enQ;  // Just use the recently written obuf_valid\n                     buf_state_bus_en[i]      = buf_cmd_state_bus_en[i];\n                     buf_state_en[i]          = (buf_state_bus_en[i] & lsu_bus_clk_en) | dec_tlu_force_halt;\n                     buf_ldfwd_in[i]          = 1'b1;\n                     buf_ldfwd_en[i]          = buf_state_en[i] & ~buf_write[i] & obuf_nosend & ~dec_tlu_force_halt;\n                     buf_ldfwdtag_in[i]       = DEPTH_LOG2'(obuf_rdrsp_tag[pt.LSU_BUS_TAG-2:0]);\n                     buf_data_en[i]           = buf_state_bus_en[i] & lsu_bus_clk_en & obuf_nosend & bus_rsp_read;\n                     buf_error_en[i]          = buf_state_bus_en[i] & lsu_bus_clk_en & obuf_nosend & bus_rsp_read_error;\n                     buf_data_in[i]           = buf_error_en[i] ? bus_rsp_rdata[31:0] : (buf_addr[i][2] ? bus_rsp_rdata[63:32] : bus_rsp_rdata[31:0]);\n            end\n            RESP: begin\n                     buf_nxtstate[i]           = (dec_tlu_force_halt | (buf_write[i] & ~bus_rsp_write_error)) ? IDLE :    // Side-effect writes will be non-posted\n                                                      (buf_dual[i] & ~buf_samedw[i] & ~buf_write[i] & (buf_state[buf_dualtag[i]] != DONE_PARTIAL)) ? DONE_PARTIAL : // Goto DONE_PARTIAL if this is the first return of dual\n                                                           (buf_ldfwd[i] | any_done_wait_state |\n                                                            (buf_dual[i] & ~buf_samedw[i] & ~buf_write[i] & buf_ldfwd[buf_dualtag[i]] &\n                                                             (buf_state[buf_dualtag[i]] == DONE_PARTIAL) & any_done_wait_state)) ? DONE_WAIT : DONE;\n                     buf_resp_state_bus_en[i]  = (bus_rsp_write & (bus_rsp_write_tag == (pt.LSU_BUS_TAG)'(i))) |\n                                                 (bus_rsp_read  & ((bus_rsp_read_tag == (pt.LSU_BUS_TAG)'(i)) |\n                                                                   (buf_ldfwd[i] & (bus_rsp_read_tag == (pt.LSU_BUS_TAG)'(buf_ldfwdtag[i]))) |\n                                                                   (buf_dual[i] & buf_dualhi[i] & ~buf_write[i] & buf_samedw[i] & (bus_rsp_read_tag == (pt.LSU_BUS_TAG)'(buf_dualtag[i])))));\n                     buf_state_bus_en[i]       = buf_resp_state_bus_en[i];\n                     buf_state_en[i]           = (buf_state_bus_en[i] & lsu_bus_clk_en) | dec_tlu_force_halt;\n                     buf_data_en[i]            = buf_state_bus_en[i] & bus_rsp_read & lsu_bus_clk_en;\n                      // Need to capture the error for stores as well for AXI\n                     buf_error_en[i]           = buf_state_bus_en[i] & lsu_bus_clk_en & ((bus_rsp_read_error  & (bus_rsp_read_tag  == (pt.LSU_BUS_TAG)'(i))) |\n                                                                                         (bus_rsp_read_error  & buf_ldfwd[i] & (bus_rsp_read_tag == (pt.LSU_BUS_TAG)'(buf_ldfwdtag[i]))) |\n                                                                                         (bus_rsp_write_error & (bus_rsp_write_tag == (pt.LSU_BUS_TAG)'(i))));\n                     buf_data_in[i][31:0]      = (buf_state_en[i] & ~buf_error_en[i]) ? (buf_addr[i][2] ? bus_rsp_rdata[63:32] : bus_rsp_rdata[31:0]) : bus_rsp_rdata[31:0];\n                     buf_cmd_state_bus_en[i]  = '0;\n            end\n            DONE_PARTIAL: begin   // Other part of dual load hasn't returned\n                     buf_nxtstate[i]           = dec_tlu_force_halt ? IDLE : (buf_ldfwd[i] | buf_ldfwd[buf_dualtag[i]] | any_done_wait_state) ? DONE_WAIT : DONE;\n                     buf_state_bus_en[i]       = bus_rsp_read & ((bus_rsp_read_tag == (pt.LSU_BUS_TAG)'(buf_dualtag[i])) |\n                                                                 (buf_ldfwd[buf_dualtag[i]] & (bus_rsp_read_tag == (pt.LSU_BUS_TAG)'(buf_ldfwdtag[buf_dualtag[i]]))));\n                     buf_state_en[i]           = (buf_state_bus_en[i] & lsu_bus_clk_en) | dec_tlu_force_halt;\n                     buf_cmd_state_bus_en[i]  = '0;\n            end\n            DONE_WAIT: begin  // WAIT state if there are multiple outstanding nb returns\n                      buf_nxtstate[i]           = dec_tlu_force_halt ? IDLE : DONE;\n                      buf_state_en[i]           = ((RspPtr == DEPTH_LOG2'(i)) | (buf_dual[i] & (buf_dualtag[i] == RspPtr))) | dec_tlu_force_halt;\n                      buf_cmd_state_bus_en[i]  = '0;\n            end\n            DONE: begin\n                     buf_nxtstate[i]           = IDLE;\n                     buf_rst[i]                = 1'b1;\n                     buf_state_en[i]           = 1'b1;\n                     buf_ldfwd_in[i]           = 1'b0;\n                     buf_ldfwd_en[i]           = buf_state_en[i];\n                     buf_cmd_state_bus_en[i]  = '0;\n            end\n            default : begin\n                     buf_nxtstate[i]          = IDLE;\n                     buf_state_en[i]          = '0;\n                     buf_resp_state_bus_en[i] = '0;\n                     buf_state_bus_en[i]      = '0;\n                     buf_wr_en[i]             = '0;\n                     buf_data_in[i]           = '0;\n                     buf_data_en[i]           = '0;\n                     buf_error_en[i]          = '0;\n                     buf_rst[i]               = '0;\n                     buf_cmd_state_bus_en[i]  = '0;\n            end\n         endcase\n      end\n\n      rvdffs  #(.WIDTH($bits(state_t))) buf_state_ff     (.din(buf_nxtstate[i]),             .dout({buf_state[i]}),    .en(buf_state_en[i]),                                        .clk(lsu_bus_buf_c1_clk), .*);\n      rvdff   #(.WIDTH(DEPTH))          buf_ageff        (.din(buf_age_in[i]),               .dout(buf_ageQ[i]),                                                                    .clk(lsu_bus_buf_c1_clk), .*);\n      rvdff   #(.WIDTH(DEPTH))          buf_rspageff     (.din(buf_rspage_in[i]),            .dout(buf_rspageQ[i]),                                                                 .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(DEPTH_LOG2))     buf_dualtagff    (.din(buf_dualtag_in[i]),           .dout(buf_dualtag[i]),    .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_dualff       (.din(buf_dual_in[i]),              .dout(buf_dual[i]),       .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_samedwff     (.din(buf_samedw_in[i]),            .dout(buf_samedw[i]),     .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_nomergeff    (.din(buf_nomerge_in[i]),           .dout(buf_nomerge[i]),    .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_dualhiff     (.din(buf_dualhi_in[i]),            .dout(buf_dualhi[i]),     .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_ldfwdff      (.din(buf_ldfwd_in[i]),             .dout(buf_ldfwd[i]),      .en(buf_ldfwd_en[i]),                                        .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(DEPTH_LOG2))     buf_ldfwdtagff   (.din(buf_ldfwdtag_in[i]),          .dout(buf_ldfwdtag[i]),   .en(buf_ldfwd_en[i]),                                        .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_sideeffectff (.din(buf_sideeffect_in[i]),        .dout(buf_sideeffect[i]), .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_unsignff     (.din(buf_unsign_in[i]),            .dout(buf_unsign[i]),     .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_writeff      (.din(buf_write_in[i]),             .dout(buf_write[i]),      .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(2))              buf_szff         (.din(buf_sz_in[i]),                .dout(buf_sz[i]),         .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffe  #(.WIDTH(32))             buf_addrff       (.din(buf_addr_in[i][31:0]),        .dout(buf_addr[i]),       .en(buf_wr_en[i]),                                                                     .*);\n      rvdffs  #(.WIDTH(4))              buf_byteenff     (.din(buf_byteen_in[i][3:0]),       .dout(buf_byteen[i]),     .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffe  #(.WIDTH(32))             buf_dataff       (.din(buf_data_in[i][31:0]),        .dout(buf_data[i]),       .en(buf_data_en[i]),                                                                   .*);\n      rvdffsc #(.WIDTH(1))              buf_errorff      (.din(1'b1),                        .dout(buf_error[i]),      .en(buf_error_en[i]),                    .clear(buf_rst[i]), .clk(lsu_bus_buf_c1_clk), .*);\n\n   end\n\n   // buffer full logic\n   always_comb begin\n      buf_numvld_any[3:0] =  ({1'b0,lsu_busreq_m} << ldst_dual_m) +\n                             ({1'b0,lsu_busreq_r} << ldst_dual_r) +\n                             ibuf_valid;\n      buf_numvld_wrcmd_any[3:0] = 4'b0;\n      buf_numvld_cmd_any[3:0] = 4'b0;\n      buf_numvld_pend_any[3:0] = 4'b0;\n      any_done_wait_state = 1'b0;\n      for (int i=0; i<DEPTH; i++) begin\n         buf_numvld_any[3:0] += {3'b0, (buf_state[i] != IDLE)};\n         buf_numvld_wrcmd_any[3:0] += {3'b0, (buf_write[i] & (buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i])};\n         buf_numvld_cmd_any[3:0]   += {3'b0, ((buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i])};\n         buf_numvld_pend_any[3:0]   += {3'b0, ((buf_state[i] == WAIT) | ((buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i]))};\n         any_done_wait_state |= (buf_state[i] == DONE_WAIT);\n      end\n   end\n\n   assign lsu_bus_buffer_pend_any = (buf_numvld_pend_any != 0);\n   assign lsu_bus_buffer_full_any = (ldst_dual_d & dec_lsu_valid_raw_d) ? (buf_numvld_any[3:0] >= (DEPTH-1)) : (buf_numvld_any[3:0] == DEPTH);\n   assign lsu_bus_buffer_empty_any = ~(|buf_state[DEPTH-1:0]) & ~ibuf_valid & ~obuf_valid;\n\n\n   // Non blocking ports\n   assign lsu_nonblock_load_valid_m = lsu_busreq_m & lsu_pkt_m.valid & lsu_pkt_m.load & ~flush_m_up & ~ld_full_hit_m;\n   assign lsu_nonblock_load_tag_m[DEPTH_LOG2-1:0] = WrPtr0_m[DEPTH_LOG2-1:0];\n   assign lsu_nonblock_load_inv_r = lsu_nonblock_load_valid_r & ~lsu_commit_r;\n   assign lsu_nonblock_load_inv_tag_r[DEPTH_LOG2-1:0] = WrPtr0_r[DEPTH_LOG2-1:0];      // r tag needs to be accurate even if there is no invalidate\n\n   always_comb begin\n      lsu_nonblock_load_data_ready = '0;\n      lsu_nonblock_load_data_error = '0;\n      lsu_nonblock_load_data_tag[DEPTH_LOG2-1:0] = '0;\n      lsu_nonblock_load_data_lo[31:0] = '0;\n      lsu_nonblock_load_data_hi[31:0] = '0;\n      for (int i=0; i<DEPTH; i++) begin\n          // Use buf_rst[i] instead of buf_state_en[i] for timing\n          lsu_nonblock_load_data_ready      |= (buf_state[i] == DONE) & ~buf_write[i];\n          lsu_nonblock_load_data_error      |= (buf_state[i] == DONE) & buf_error[i] & ~buf_write[i];\n          lsu_nonblock_load_data_tag[DEPTH_LOG2-1:0]   |= DEPTH_LOG2'(i) & {DEPTH_LOG2{((buf_state[i] == DONE) & ~buf_write[i] & (~buf_dual[i] | ~buf_dualhi[i]))}};\n          lsu_nonblock_load_data_lo[31:0]     |= buf_data[i][31:0] & {32{((buf_state[i] == DONE) & ~buf_write[i] & (~buf_dual[i] | ~buf_dualhi[i]))}};\n          lsu_nonblock_load_data_hi[31:0]     |= buf_data[i][31:0] & {32{((buf_state[i] == DONE) & ~buf_write[i] & (buf_dual[i] & buf_dualhi[i]))}};\n      end\n   end\n\n   assign lsu_nonblock_addr_offset[1:0] = buf_addr[lsu_nonblock_load_data_tag][1:0];\n   assign lsu_nonblock_sz[1:0]          = buf_sz[lsu_nonblock_load_data_tag][1:0];\n   assign lsu_nonblock_unsign           = buf_unsign[lsu_nonblock_load_data_tag];\n   assign lsu_nonblock_data_unalgn[31:0] = 32'({lsu_nonblock_load_data_hi[31:0], lsu_nonblock_load_data_lo[31:0]} >> 8*lsu_nonblock_addr_offset[1:0]);\n\n   assign lsu_nonblock_load_data_valid = lsu_nonblock_load_data_ready & ~lsu_nonblock_load_data_error;\n   assign lsu_nonblock_load_data[31:0] = ({32{ lsu_nonblock_unsign & (lsu_nonblock_sz[1:0] == 2'b00)}} & {24'b0,lsu_nonblock_data_unalgn[7:0]}) |\n                                         ({32{ lsu_nonblock_unsign & (lsu_nonblock_sz[1:0] == 2'b01)}} & {16'b0,lsu_nonblock_data_unalgn[15:0]}) |\n                                         ({32{~lsu_nonblock_unsign & (lsu_nonblock_sz[1:0] == 2'b00)}} & {{24{lsu_nonblock_data_unalgn[7]}}, lsu_nonblock_data_unalgn[7:0]}) |\n                                         ({32{~lsu_nonblock_unsign & (lsu_nonblock_sz[1:0] == 2'b01)}} & {{16{lsu_nonblock_data_unalgn[15]}},lsu_nonblock_data_unalgn[15:0]}) |\n                                         ({32{(lsu_nonblock_sz[1:0] == 2'b10)}} & lsu_nonblock_data_unalgn[31:0]);\n\n   // Determine if there is a pending return to sideeffect load/store\n   always_comb begin\n      bus_sideeffect_pend = obuf_valid & obuf_sideeffect & dec_tlu_sideeffect_posted_disable;\n      for (int i=0; i<DEPTH; i++) begin\n         bus_sideeffect_pend |= ((buf_state[i] == RESP) & buf_sideeffect[i] & dec_tlu_sideeffect_posted_disable);\n      end\n   end\n\n   // We have no ordering rules for AXI. Need to check outstanding trxns to same address for AXI\n   always_comb begin\n      bus_addr_match"}
{"text": "_pending = '0;\n      for (int i=0; i<DEPTH; i++) begin\n         bus_addr_match_pending |= (obuf_valid & (obuf_addr[31:3] == buf_addr[i][31:3]) & (buf_state[i] == RESP) & ~((obuf_tag0 == (pt.LSU_BUS_TAG)'(i)) | (obuf_merge & (obuf_tag1 == (pt.LSU_BUS_TAG)'(i)))));\n      end\n   end\n\n   // Generic bus signals\n   assign bus_cmd_ready                      = obuf_write ? ((obuf_cmd_done | obuf_data_done) ? (obuf_cmd_done ? lsu_axi_wready : lsu_axi_awready) : (lsu_axi_awready & lsu_axi_wready)) : lsu_axi_arready;\n   assign bus_wcmd_sent                      = lsu_axi_awvalid & lsu_axi_awready;\n   assign bus_wdata_sent                     = lsu_axi_wvalid & lsu_axi_wready;\n   assign bus_cmd_sent                       = ((obuf_cmd_done | bus_wcmd_sent) & (obuf_data_done | bus_wdata_sent)) | (lsu_axi_arvalid & lsu_axi_arready);\n\n   assign bus_rsp_read                       = lsu_axi_rvalid & lsu_axi_rready;\n   assign bus_rsp_write                      = lsu_axi_bvalid & lsu_axi_bready;\n   assign bus_rsp_read_tag[pt.LSU_BUS_TAG-1:0]  = lsu_axi_rid[pt.LSU_BUS_TAG-1:0];\n   assign bus_rsp_write_tag[pt.LSU_BUS_TAG-1:0] = lsu_axi_bid[pt.LSU_BUS_TAG-1:0];\n   assign bus_rsp_write_error                = bus_rsp_write & (lsu_axi_bresp[1:0] != 2'b0);\n   assign bus_rsp_read_error                 = bus_rsp_read  & (lsu_axi_rresp[1:0] != 2'b0);\n   assign bus_rsp_rdata[63:0]                = lsu_axi_rdata[63:0];\n\n   // AXI command signals\n   assign lsu_axi_awvalid               = obuf_valid & obuf_write & ~obuf_cmd_done & ~bus_addr_match_pending;\n   assign lsu_axi_awid[pt.LSU_BUS_TAG-1:0] = (pt.LSU_BUS_TAG)'(obuf_tag0);\n   assign lsu_axi_awaddr[31:0]          = obuf_sideeffect ? obuf_addr[31:0] : {obuf_addr[31:3],3'b0};\n   assign lsu_axi_awsize[2:0]           = obuf_sideeffect ? {1'b0, obuf_sz[1:0]} : 3'b011;\n   assign lsu_axi_awprot[2:0]           = 3'b001;\n   assign lsu_axi_awcache[3:0]          = obuf_sideeffect ? 4'b0 : 4'b1111;\n   assign lsu_axi_awregion[3:0]         = obuf_addr[31:28];\n   assign lsu_axi_awlen[7:0]            = '0;\n   assign lsu_axi_awburst[1:0]          = 2'b01;\n   assign lsu_axi_awqos[3:0]            = '0;\n   assign lsu_axi_awlock                = '0;\n\n   assign lsu_axi_wvalid                = obuf_valid & obuf_write & ~obuf_data_done & ~bus_addr_match_pending;\n   assign lsu_axi_wstrb[7:0]            = obuf_byteen[7:0] & {8{obuf_write}};\n   assign lsu_axi_wdata[63:0]           = obuf_data[63:0];\n   assign lsu_axi_wlast                 = '1;\n\n   assign lsu_axi_arvalid               = obuf_valid & ~obuf_write & ~obuf_nosend & ~bus_addr_match_pending;\n   assign lsu_axi_arid[pt.LSU_BUS_TAG-1:0] = (pt.LSU_BUS_TAG)'(obuf_tag0);\n   assign lsu_axi_araddr[31:0]          = obuf_sideeffect ? obuf_addr[31:0] : {obuf_addr[31:3],3'b0};\n   assign lsu_axi_arsize[2:0]           = obuf_sideeffect ? {1'b0, obuf_sz[1:0]} : 3'b011;\n   assign lsu_axi_arprot[2:0]           = 3'b001;\n   assign lsu_axi_arcache[3:0]          = obuf_sideeffect ? 4'b0 : 4'b1111;\n   assign lsu_axi_arregion[3:0]         = obuf_addr[31:28];\n   assign lsu_axi_arlen[7:0]            = '0;\n   assign lsu_axi_arburst[1:0]          = 2'b01;\n   assign lsu_axi_arqos[3:0]            = '0;\n   assign lsu_axi_arlock                = '0;\n\n   assign lsu_axi_bready = 1;\n   assign lsu_axi_rready = 1;\n\n   always_comb begin\n      lsu_imprecise_error_store_any = '0;\n      lsu_imprecise_error_store_tag = '0;\n      for (int i=0; i<DEPTH; i++) begin\n         lsu_imprecise_error_store_any |= lsu_bus_clk_en_q & (buf_state[i] == DONE) & buf_error[i] & buf_write[i];\n         lsu_imprecise_error_store_tag |= DEPTH_LOG2'(i) & {DEPTH_LOG2{((buf_state[i] == DONE) & buf_error[i] & buf_write[i])}};\n      end\n   end\n   assign lsu_imprecise_error_load_any       = lsu_nonblock_load_data_error & ~lsu_imprecise_error_store_any;   // This is to make sure we send only one imprecise error for load/store\n   assign lsu_imprecise_error_addr_any[31:0] = lsu_imprecise_error_store_any ? buf_addr[lsu_imprecise_error_store_tag] : buf_addr[lsu_nonblock_load_data_tag];\n\n   // PMU signals\n   assign lsu_pmu_bus_trxn  = (lsu_axi_awvalid & lsu_axi_awready) | (lsu_axi_wvalid & lsu_axi_wready) | (lsu_axi_arvalid & lsu_axi_arready);\n   assign lsu_pmu_bus_misaligned = lsu_busreq_r & ldst_dual_r & lsu_commit_r;\n   assign lsu_pmu_bus_error = lsu_imprecise_error_load_any | lsu_imprecise_error_store_any;\n   assign lsu_pmu_bus_busy  = (lsu_axi_awvalid & ~lsu_axi_awready) | (lsu_axi_wvalid & ~lsu_axi_wready) | (lsu_axi_arvalid & ~lsu_axi_arready);\n\n   rvdff_fpga #(.WIDTH(1))               lsu_axi_awvalid_ff (.din(lsu_axi_awvalid),                .dout(lsu_axi_awvalid_q),                .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))               lsu_axi_awready_ff (.din(lsu_axi_awready),                .dout(lsu_axi_awready_q),                .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))               lsu_axi_wvalid_ff  (.din(lsu_axi_wvalid),                 .dout(lsu_axi_wvalid_q),                 .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))               lsu_axi_wready_ff  (.din(lsu_axi_wready),                 .dout(lsu_axi_wready_q),                 .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))               lsu_axi_arvalid_ff (.din(lsu_axi_arvalid),                .dout(lsu_axi_arvalid_q),                .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))               lsu_axi_arready_ff (.din(lsu_axi_arready),                .dout(lsu_axi_arready_q),                .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n\n   rvdff_fpga  #(.WIDTH(1))              lsu_axi_bvalid_ff  (.din(lsu_axi_bvalid),                 .dout(lsu_axi_bvalid_q),                 .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(1))              lsu_axi_bready_ff  (.din(lsu_axi_bready),                 .dout(lsu_axi_bready_q),                 .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(2))              lsu_axi_bresp_ff   (.din(lsu_axi_bresp[1:0]),             .dout(lsu_axi_bresp_q[1:0]),             .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(pt.LSU_BUS_TAG)) lsu_axi_bid_ff     (.din(lsu_axi_bid[pt.LSU_BUS_TAG-1:0]),.dout(lsu_axi_bid_q[pt.LSU_BUS_TAG-1:0]),.clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdffe      #(.WIDTH(64))             lsu_axi_rdata_ff   (.din(lsu_axi_rdata[63:0]),            .dout(lsu_axi_rdata_q[63:0]),            .en((lsu_axi_rvalid | clk_override) & lsu_bus_clk_en), .*);\n\n   rvdff_fpga  #(.WIDTH(1))              lsu_axi_rvalid_ff  (.din(lsu_axi_rvalid),                 .dout(lsu_axi_rvalid_q),                 .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(1))              lsu_axi_rready_ff  (.din(lsu_axi_rready),                 .dout(lsu_axi_rready_q),                 .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(2))              lsu_axi_rresp_ff   (.din(lsu_axi_rresp[1:0]),             .dout(lsu_axi_rresp_q[1:0]),             .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(pt.LSU_BUS_TAG)) lsu_axi_rid_ff     (.din(lsu_axi_rid[pt.LSU_BUS_TAG-1:0]),.dout(lsu_axi_rid_q[pt.LSU_BUS_TAG-1:0]),.clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n\n   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr0_rff (.din(WrPtr0_m), .dout(WrPtr0_r), .clk(lsu_c2_r_clk), .*);\n   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr1_rff (.din(WrPtr1_m), .dout(WrPtr1_r), .clk(lsu_c2_r_clk), .*);\n\n   rvdff #(.WIDTH(1)) lsu_busreq_rff (.din(lsu_busreq_m & ~flush_r & ~ld_full_hit_m),      .dout(lsu_busreq_r), .clk(lsu_c2_r_clk), .*);\n   rvdff #(.WIDTH(1)) lsu_nonblock_load_valid_rff  (.din(lsu_nonblock_load_valid_m),  .dout(lsu_nonblock_load_valid_r), .clk(lsu_c2_r_clk), .*);\n\n`ifdef RV_ASSERT_ON\n\n   for (genvar i=0; i<4; i++) begin: GenByte\n      assert_ld_byte_hitvecfn_lo_onehot: assert #0 ($onehot0(ld_byte_hitvecfn_lo[i][DEPTH-1:0]));\n      assert_ld_byte_hitvecfn_hi_onehot: assert #0 ($onehot0(ld_byte_hitvecfn_hi[i][DEPTH-1:0]));\n   end\n\n   for (genvar i=0; i<DEPTH; i++) begin: GenAssertAge\n      assert_bufempty_agevec: assert #0 (~(lsu_bus_buffer_empty_any & |(buf_age[i])));\n   end\n\n   assert_CmdPtr0Dec_onehot: assert #0 ($onehot0(CmdPtr0Dec[DEPTH-1:0] & ~{DEPTH{dec_tlu_force_halt}}));\n   assert_CmdPtr1Dec_onehot: assert #0 ($onehot0(CmdPtr1Dec[DEPTH-1:0] & ~{DEPTH{dec_tlu_force_halt}}));\n\n`endif\n\nendmodule // el2_lsu_bus_buffer\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: lsu interface with interface queue\n// Comments:\n//\n//********************************************************************************\nmodule el2_lsu_bus_intf\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n   input logic                          clk,                                // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n   input logic                          clk_override,                       // Override non-functional clock gating\n   input logic                          rst_l,                              // reset, active low\n   input logic                          scan_mode,                          // scan mode\n   input logic                          dec_tlu_external_ldfwd_disable,     // disable load to load forwarding for externals\n   input logic                          dec_tlu_wb_coalescing_disable,      // disable write buffer coalescing\n   input logic                          dec_tlu_sideeffect_posted_disable,  // disable the posted sideeffect load store to the bus\n\n   // various clocks needed for the bus reads and writes\n   input logic                          lsu_bus_obuf_c1_clken,              // obuf clock enable\n   input logic                          lsu_busm_clken,                     // bus clock enable\n\n   input logic                          lsu_c1_r_clk,                       // r pipe single pulse clock\n   input logic                          lsu_c2_r_clk,                       // r pipe double pulse clock\n   input logic                          lsu_bus_ibuf_c1_clk,                // ibuf single pulse clock\n   input logic                          lsu_bus_obuf_c1_clk,                // obuf single pulse clock\n   input logic                          lsu_bus_buf_c1_clk,                 // buf  single pulse clock\n   input logic                          lsu_free_c2_clk,                    // free clock double pulse clock\n   input logic                          active_clk,                         // Clock only while core active.  Through two clock headers. For flops without second clock header built in.\n   input logic                          lsu_busm_clk,                       // bus clock\n\n   input logic                          dec_lsu_valid_raw_d,               // Raw valid for address computation\n   input logic                          lsu_busreq_m,                      // bus request is in m\n\n   input                                el2_lsu_pkt_t lsu_pkt_m,          // lsu packet flowing down the pipe\n   input                                el2_lsu_pkt_t lsu_pkt_r,          // lsu packet flowing down the pipe\n\n   input logic [31:0]                   lsu_addr_m,                        // lsu address flowing down the pipe\n   input logic [31:0]                   lsu_addr_r,                        // lsu address flowing down the pipe\n\n   input logic [31:0]                   end_addr_m,                        // lsu address flowing down the pipe\n   input logic [31:0]                   end_addr_r,                        // lsu address flowing down the pipe\n\n   input logic [31:0]                   store_data_r,                      // store data flowing down the pipe\n   input logic                          dec_tlu_force_halt,\n\n   input logic                          lsu_commit_r,                      // lsu instruction in r commits\n   input logic                          is_sideeffects_m,                  // lsu attribute is side_effects\n   input logic                          flush_m_up,                        // flush\n   input logic                          flush_r,                           // flush\n   input logic                          ldst_dual_d, ldst_dual_m, ldst_dual_r,\n\n   output logic                         lsu_busreq_r,                      // bus request is in r\n   output logic                         lsu_bus_buffer_pend_any,           // bus buffer has a pending bus entry\n   output logic                         lsu_bus_buffer_full_any,           // write buffer is full\n   output logic                         lsu_bus_buffer_empty_any,          // write buffer is empty\n   output logic [31:0]                  bus_read_data_m,                   // the bus return data\n\n\n   output logic                         lsu_imprecise_error_load_any,      // imprecise load bus error\n   output logic                         lsu_imprecise_error_store_any,     // imprecise store bus error\n   output logic [31:0]                  lsu_imprecise_error_addr_any,      // address of the imprecise error\n\n   // Non-blocking loads\n   output logic                               lsu_nonblock_load_valid_m,   // there is an external load -> put in the cam\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_tag_m,     // the tag of the external non block load\n   output logic                               lsu_nonblock_load_inv_r,     // invalidate signal for the cam entry for non block loads\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_inv_tag_r, // tag of the enrty which needs to be invalidated\n   output logic                               lsu_nonblock_load_data_valid,// the non block is valid - sending information back to the cam\n   output logic                               lsu_nonblock_load_data_error,// non block load has an error\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_data_tag,  // the tag of the non block load sending the data/error\n   output logic [31:0]                        lsu_nonblock_load_data,      // Data of the non block load\n\n   // PMU events\n   output logic                         lsu_pmu_bus_trxn,\n   output logic                         lsu_pmu_bus_misaligned,\n   output logic                         lsu_pmu_bus_error,\n   output logic                         lsu_pmu_bus_busy,\n\n   // AXI Write Channels\n   output logic                        lsu_axi_awvalid,\n   input  logic                        lsu_axi_awready,\n   output logic [pt.LSU_BUS_TAG-1:0]   lsu_axi_awid,\n   output logic [31:0]                 lsu_axi_awaddr,\n   output logic [3:0]                  lsu_axi_awregion,\n   output logic [7:0]                  lsu_axi_awlen,\n   output logic [2:0]                  lsu_axi_awsize,\n   output logic [1:0]                  lsu_axi_awburst,\n   output logic                        lsu_axi_awlock,\n   output logic [3:0]                  lsu_axi_awcache,\n   output logic [2:0]                  lsu_axi_awprot,\n   output logic [3:0]                  lsu_axi_awqos,\n\n   output logic                        lsu_axi_wvalid,\n   input  logic                        lsu_axi_wready,\n   output logic [63:0]                 lsu_axi_wdata,\n   output logic [7:0]                  lsu_axi_wstrb,\n   output logic                        lsu_axi_wlast,\n\n   input  logic                        lsu_axi_bvalid,\n   output logic                        lsu_axi_bready,\n   input  logic [1:0]                  lsu_axi_bresp,\n   input  logic [pt.LSU_BUS_TAG-1:0]   lsu_axi_bid,\n\n   // AXI Read Channels\n   output logic                        lsu_axi_arvalid,\n   input  logic                        lsu_axi_arready,\n   output logic [pt.LSU_BUS_TAG-1:0]   lsu_axi_arid,\n   output logic [31:0]                 lsu_axi_araddr,\n   output logic [3:0]                  lsu_axi_arregion,\n   output logic [7:0]                  lsu_axi_arlen,\n   output logic [2:0]                  lsu_axi_arsize,\n   output logic [1:0]                  lsu_axi_arburst,\n   output logic                        lsu_axi_arlock,\n   output logic [3:0]                  lsu_axi_arcache,\n   output logic [2:0]                  lsu_axi_arprot,\n   output logic [3:0]                  lsu_axi_arqos,\n\n   input  logic                        lsu_axi_rvalid,\n   output logic                        lsu_axi_rready,\n   input  logic [pt.LSU_BUS_TAG-1:0]   lsu_axi_rid,\n   input  logic [63:0]                 lsu_axi_rdata,\n   input  logic [1:0]                  lsu_axi_rresp,\n\n   input logic                         lsu_bus_clk_en\n\n);\n\n\n\n   logic              lsu_bus_clk_en_q;\n\n   logic [3:0]        ldst_byteen_m, ldst_byteen_r;\n   logic [7:0]        ldst_byteen_ext_m, ldst_byteen_ext_r;\n   logic [3:0]        ldst_byteen_hi_m, ldst_byteen_hi_r;\n   logic [3:0]        ldst_byteen_lo_m, ldst_byteen_lo_r;\n   logic              is_sideeffects_r;\n\n   logic [63:0]       store_data_ext_r;\n   logic [31:0]       store_data_hi_r;\n   logic [31:0]       store_data_lo_r;\n\n   logic              addr_match_dw_lo_r_m;\n   logic              addr_match_word_lo_r_m;\n   logic              no_word_merge_r, no_dword_merge_r;\n\n   logic              ld_addr_rhit_lo_lo, ld_addr_rhit_hi_lo, ld_addr_rhit_lo_hi, ld_addr_rhit_hi_hi;\n   logic [3:0]        ld_byte_rhit_lo_lo, ld_byte_rhit_hi_lo, ld_byte_rhit_lo_hi, ld_byte_rhit_hi_hi;\n\n   logic [3:0]        ld_byte_hit_lo, ld_byte_rhit_lo;\n   logic [3:0]        ld_byte_hit_hi, ld_byte_rhit_hi;\n\n   logic [31:0]       ld_fwddata_rpipe_lo;\n   logic [31:0]       ld_fwddata_rpipe_hi;\n\n   logic [3:0]        ld_byte_hit_buf_lo, ld_byte_hit_buf_hi;\n   logic [31:0]       ld_fwddata_buf_lo, ld_fwddata_buf_hi;\n\n   logic [63:0]       ld_fwddata_lo, ld_fwddata_hi;\n   logic [63:0]       ld_fwddata_m;\n\n   logic              ld_full_hit_hi_m, ld_full_hit_lo_m;\n   logic              ld_full_hit_m;\n\n   assign ldst_byteen_m[3:0] = ({4{lsu_pkt_m.by}}   & 4'b0001) |\n                                 ({4{lsu_pkt_m.half}} & 4'b0011) |\n                                 ({4{lsu_pkt_m.word}} & 4'b1111);\n\n   // Read/Write Buffer\n   el2_lsu_bus_buffer #(.pt(pt)) bus_buffer (\n      .*\n   );\n\n   // Logic to determine if dc5 store can be coalesced or not with younger stores. Bypass ibuf if cannot colaesced\n   assign addr_match_dw_lo_r_m = (lsu_addr_r[31:3] == lsu_addr_m[31:3]);\n   assign addr_match_word_lo_r_m = addr_match_dw_lo_r_m & ~(lsu_addr_r[2]^lsu_addr_m[2]);\n\n   assign no_word_merge_r  = lsu_busreq_r & ~ldst_dual_r & lsu_busreq_m & (lsu_pkt_m.load | ~addr_match_word_lo_r_m);\n   assign no_dword_merge_r = lsu_busreq_r & ~ldst_dual_r & lsu_busreq_m & (lsu_pkt_m.load | ~addr_match_dw_lo_r_m);\n\n   // Create Hi/Lo signals\n   assign ldst_byteen_ext_m[7:0] = {4'b0,ldst_byteen_m[3:0]} << lsu_addr_m[1:0];\n   assign ldst_byteen_ext_r[7:0] = {4'b0,ldst_byteen_r[3:0]} << lsu_addr_r[1:0];\n\n   assign store_data_ext_r[63:0] = {32'b0,store_data_r[31:0]} << {lsu_addr_r[1:0],3'b0};\n\n   assign ldst_byteen_hi_m[3:0]   = ldst_byteen_ext_m[7:4];\n   assign ldst_byteen_lo_m[3:0]   = ldst_byteen_ext_m[3:0];\n   assign ldst_byteen_hi_r[3:0]   = ldst_byteen_ext_r[7:4];\n   assign ldst_byteen_lo_r[3:0]   = ldst_byteen_ext_r[3:0];\n\n   assign store_data_hi_r[31:0]   = store_data_ext_r[63:32];\n   assign store_data_lo_r[31:0]   = store_data_ext_r[31:0];\n\n   assign ld_addr_rhit_lo_lo = (lsu_addr_m[31:2] == lsu_addr_r[31:2]) & lsu_pkt_r.valid & lsu_pkt_r.store & lsu_busreq_m & lsu_busreq_r;\n   assign ld_addr_rhit_lo_hi = (end_addr_m[31:2] == lsu_addr_r[31:2]) & lsu_pkt_r.valid & lsu_pkt_r.store & lsu_busreq_m & lsu_busreq_r;\n   assign ld_addr_rhit_hi_lo = (lsu_addr_m[31:2] == end_addr_r[31:2]) & lsu_pkt_r.valid & lsu_pkt_r.store & lsu_busreq_m & lsu_busreq_r;\n   assign ld_addr_rhit_hi_hi = (end_addr_m[31:2] == end_addr_r[31:2]) & lsu_pkt_r.valid & lsu_pkt_r.store & lsu_busreq_m & lsu_busreq_r;\n\n   for (genvar i=0; i<4; i++) begin: GenBusBufFwd\n      assign ld_byte_rhit_lo_lo[i] = ld_addr_rhit_lo_lo & ldst_byteen_lo_r[i] & ldst_byteen_lo_m[i];\n      assign ld_byte_rhit_lo_hi[i] = ld_addr_rhit_lo_hi & ldst_byteen_lo_r[i] & ldst_byteen_hi_m[i];\n      assign ld_byte_rhit_hi_lo[i] = ld_addr_rhit_hi_lo & ldst_byteen_hi_r[i] & ldst_byteen_lo_m[i];\n      assign ld_byte_rhit_hi_hi[i] = ld_addr_rhit_hi_hi & ldst_byteen_hi_r[i] & ldst_byteen_hi_m[i];\n\n      assign ld_byte_hit_lo[i] = ld_byte_rhit_lo_lo[i] | ld_byte_rhit_hi_lo[i] |\n                                 ld_byte_hit_buf_lo[i];\n\n      assign ld_byte_hit_hi[i] = ld_byte_rhit_lo_hi[i] | ld_byte_rhit_hi_hi[i] |\n                                 ld_byte_hit_buf_hi[i];\n\n      assign ld_byte_rhit_lo[i] = ld_byte_rhit_lo_lo[i] | ld_byte_rhit_hi_lo[i];\n      assign ld_byte_rhit_hi[i] = ld_byte_rhit_lo_hi[i] | ld_byte_rhit_hi_hi[i];\n\n      assign ld_fwddata_rpipe_lo[(8*i)+7:(8*i)] = ({8{ld_byte_rhit_lo_lo[i]}} & store_data_lo_r[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_rhit_hi_lo[i]}} & store_data_hi_r[(8*i)+7:(8*i)]);\n\n      assign ld_fwddata_rpipe_hi[(8*i)+7:(8*i)] = ({8{ld_byte_rhit_lo_hi[i]}} & store_data_lo_r[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_rhit_hi_hi[i]}} & store_data_hi_r[(8*i)+7:(8*i)]);\n\n      // Final muxing between m/r\n      assign ld_fwddata_lo[(8*i)+7:(8*i)] = ld_byte_rhit_lo[i]    ? ld_fwddata_rpipe_lo[(8*i)+7:(8*i)] : ld_fwddata_buf_lo[(8*i)+7:(8*i)];\n\n      assign ld_fwddata_hi[(8*i)+7:(8*i)] = ld_byte_rhit_hi[i]    ? ld_fwddata_rpipe_hi[(8*i)+7:(8*i)] : ld_fwddata_buf_hi[(8*i)+7:(8*i)];\n\n   end\n\n   always_comb begin\n      ld_full_hit_lo_m = 1'b1;\n      ld_full_hit_hi_m = 1'b1;\n      for (int i=0; i<4; i++) begin\n         ld_full_hit_lo_m &= (ld_byte_hit_lo[i] | ~ldst_byteen_lo_m[i]);\n         ld_full_hit_hi_m &= (ld_byte_hit_hi[i] | ~ldst_byteen_hi_m[i]);\n      end\n   end\n\n   // This will be high if all the bytes of load hit the stores in pipe/write buffer (m/r/wrbuf)\n   assign ld_full_hit_m = ld_full_hit_lo_m & ld_full_hit_hi_m & lsu_busreq_m & lsu_pkt_m.load & ~is_sideeffects_m;\n\n   assign ld_fwddata_m[63:0] = {ld_fwddata_hi[31:0], ld_fwddata_lo[31:0]} >> (8*lsu_addr_m[1:0]);\n   assign bus_read_data_m[31:0]                        = ld_fwddata_m[31:0];\n\n   // Fifo flops\n\n   rvdff #(.WIDTH(1)) clken_ff (.din(lsu_bus_clk_en), .dout(lsu_bus_clk_en_q), .clk(active_clk), .*);\n\n   rvdff #(.WIDTH(1)) is_sideeffects_rff (.din(is_sideeffects_m), .dout(is_sideeffects_r), .clk(lsu_c1_r_clk), .*);\n\n   rvdff #(4) lsu_byten_rff (.*, .din(ldst_byteen_m[3:0]), .dout(ldst_byteen_r[3:0]), .clk(lsu_c1_r_clk));\n\n`ifdef RV_ASSERT_ON\n\n  // Assertion to check AXI write address is aligned to size\n  property lsu_axi_awaddr_aligned;\n    @(posedge lsu_busm_clk) disable iff(~rst_l) lsu_axi_awvalid |-> ((lsu_axi_awsize[2:0] == 3'h0)                                   |\n                                                                     ((lsu_axi_awsize[2:0] == 3'h1) & (lsu_axi_awaddr[0] == 1'b0))   |\n                                                                     ((lsu_axi_awsize[2:0] == 3'h2) & (lsu_axi_awaddr[1:0] == 2'b0)) |\n                                                                     ((lsu_axi_awsize[2:0] == 3'h3) & (lsu_axi_awaddr[2:0] == 3'b0)));\n  endproperty\n  assert_lsu_axi_awaddr_aligned: assert property (lsu_axi_awaddr_aligned) else\n    $display(\"Assertion lsu_axi_awaddr_aligned failed: lsu_axi_awvalid=1'b%b, lsu_axi_awsize=3'h%h, lsu_axi_awaddr=32'h%h\",lsu_axi_awvalid, lsu_axi_awsize[2:0], lsu_axi_awaddr[31:0]);\n  // Assertion to check awvalid stays stable during entire bus clock\n\n  // Assertion to check AXI read address is aligned to size\n  property lsu_axi_araddr_aligned;\n    @(posedge lsu_busm_clk) disable iff(~rst_l) lsu_axi_arvalid |-> ((lsu_axi_arsize[2:0] == 3'h0)                                   |\n                                                                     ((lsu_axi_arsize[2:0] == 3'h1) & (lsu_axi_araddr[0] == 1'b0))   |\n                                                                     ((lsu_axi_arsize[2:0] == 3'h2) & (lsu_axi_araddr[1:0] == 2'b0)) |\n                                                                     ((lsu_axi_arsize[2:0] == 3'h3) & (lsu_axi_araddr[2:0] == 3'b0)));\n  endproperty\n  assert_lsu_axi_araddr_aligned: assert property (lsu_axi_araddr_aligned) else\n    $display(\"Assertion lsu_axi_araddr_aligned failed: lsu_axi_awvalid=1'b%b, lsu_axi_awsize=3'h%h, lsu_axi_araddr=32'h%h\",lsu_axi_awvalid, lsu_axi_awsize[2:0], lsu_axi_araddr[31:0]);\n\n  // Assertion to check awvalid stays stable during entire bus clock\n property lsu_axi_awvalid_stable;\n     @(posedge clk) disable iff(~rst_l)  (lsu_axi_awvalid != $past(lsu_axi_awvalid)) |-> ($past(lsu_bus_clk_en) | dec_tlu_force_halt);\n  endproperty\n  assert_lsu_axi_awvalid_stable: assert property (lsu_axi_awvalid_stable) else\n     $display(\"LSU AXI awvalid changed in middle of bus clock\");\n\n  // Assertion to check awid stays stable during entire bus clock\n  property lsu_axi_awid_stable;\n     @(posedge clk) disable iff(~rst_l)  (lsu_axi_awvalid & (lsu_axi_awid[pt.LSU_BUS_TAG-1:0] != $past(lsu_axi_awid[pt.LSU_BUS_TAG-1:0]))) |-> $past(lsu_bus_clk_en);\n  endproperty\n  assert_lsu_axi_awid_stable: assert property (lsu_axi_awid_stable) else\n     $display(\"LSU AXI awid changed in middle of bus clock\");\n\n  // Assertion to check awaddr stays stable during entire bus clock\n  property lsu_axi_awaddr_stable;\n     @(posedge clk) disable iff(~rst_l)  (lsu_axi_awvalid & (lsu_axi_awaddr[31:0] != $past(lsu_axi_awaddr[31:0]))) |-> $past(lsu_bus_clk_en);\n  endproperty\n  assert_lsu_axi_awaddr_stable: assert property (lsu_axi_awaddr_stable) else\n     $display(\"LSU AXI awaddr changed in middle of bus clock\");\n\n  // Assertion to check awsize stays stable during entire bus clock\n  property lsu_axi_awsize_stable;\n     @(posedge clk) disable iff(~rst_l)  (lsu_axi_awvalid & (lsu_axi_awsize[2:0] != $past(lsu_axi_awsize[2:0]))) |-> $past(lsu_bus_clk_en);\n  endproperty\n  assert_lsu_axi_awsize_stable: assert property (lsu_axi_awsize_stable) else\n     $display(\"LSU AXI awsize changed in middle of bus clock\");\n\n  // Assertion to check wstrb stays stable during entire bus clock\n  property lsu_axi_wstrb_stable;\n     @(posedge clk) disable iff(~rst_l)  (lsu_axi_wvalid & (lsu_axi_wstrb[7:0] != $past(lsu_axi_wstrb[7:0]))) |-> $past(lsu_bus_clk_en);\n  endproperty\n  assert_lsu_axi_wstrb_stable: assert property (lsu_axi_wstrb_stable) else\n     $display(\"LSU AXI wstrb changed in middle of bus clock\");\n\n  // Assertion to check wdata stays stable during entire bus clock\n  property lsu_axi_wdata_stable;\n     @(posedge clk) disable iff(~rst_l)  (lsu_axi_wvalid & (lsu_axi_wdata[63:0] != $past(lsu_axi_wdata[63:0]))) |-> $past(lsu_bus_clk_en);\n  endproperty\n  assert_lsu_axi_wdata_stable: assert property (lsu_axi_wdata_stable) else\n     $display(\"LSU AXI wdata changed in middle of bus clock\");\n\n  // Assertion to check awvalid stays stable during entire bus clock\n  property lsu_axi_arvalid_stable;\n     @(posedge clk) disable iff(~rst_l)  (lsu_axi_arvalid != $past(lsu_axi_arvalid)) |-> ($past(lsu_bus_clk_en) | dec_tlu_force_halt);\n  endproperty\n  assert_lsu_axi_arvalid_stable: assert property (lsu_axi_arvalid_stable) else\n     $display(\"LSU AXI awvalid changed in middle of bus clock\");\n\n  // Assertion to check awid stays stable during entire bus clock\n  property lsu_axi_arid_stable;\n     @(posedge clk) disable iff(~rst_l)  (lsu_axi_arvalid & (lsu_axi_arid[pt.LSU_BUS_TAG-1:0] != $past(lsu_axi_arid[pt.LSU_BUS_TAG-1:0]))) |-> $past(lsu_bus_clk_en);\n  endproperty\n  assert_lsu_axi_arid_stable: assert property (lsu_axi_arid_stable) else\n     $display(\"LSU AXI awid changed in middle of bus clock\");\n\n  // Assertion to check awaddr stays stable during entire bus clock\n  property l"}
{"text": "su_axi_araddr_stable;\n     @(posedge clk) disable iff(~rst_l)  (lsu_axi_arvalid & (lsu_axi_araddr[31:0] != $past(lsu_axi_araddr[31:0]))) |-> $past(lsu_bus_clk_en);\n  endproperty\n  assert_lsu_axi_araddr_stable: assert property (lsu_axi_araddr_stable) else\n     $display(\"LSU AXI awaddr changed in middle of bus clock\");\n\n  // Assertion to check awsize stays stable during entire bus clock\n  property lsu_axi_arsize_stable;\n     @(posedge clk) disable iff(~rst_l)  (lsu_axi_awvalid & (lsu_axi_arsize[2:0] != $past(lsu_axi_arsize[2:0]))) |-> $past(lsu_bus_clk_en);\n  endproperty\n  assert_lsu_axi_arsize_stable: assert property (lsu_axi_arsize_stable) else\n     $display(\"LSU AXI awsize changed in middle of bus clock\");\n\n`endif\n\nendmodule // el2_lsu_bus_intf\n"}
{"text": "// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: Clock Generation Block\n// Comments: All the clocks are generate here\n//\n// //********************************************************************************\n\n\nmodule el2_lsu_clkdomain\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n)(\n   input logic      clk,                               // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n   input logic      active_clk,                        // Clock only while core active.  Through two clock headers. For flops without second clock header built in.\n   input logic      rst_l,                             // reset, active low\n   input logic      dec_tlu_force_halt,                // This will be high till TLU goes to debug halt\n\n   // Inputs\n   input logic      clk_override,                      // chciken bit to turn off clock gating\n   input logic      dma_dccm_req,                      // dma is active\n   input logic      ldst_stbuf_reqvld_r,               // allocating in to the store queue\n\n   input logic      stbuf_reqvld_any,                  // stbuf is draining\n   input logic      stbuf_reqvld_flushed_any,          // instruction going to stbuf is flushed\n   input logic      lsu_busreq_r,                      // busreq in r\n   input logic      lsu_bus_buffer_pend_any,           // bus buffer has a pending bus entry\n   input logic      lsu_bus_buffer_empty_any,          // external bus buffer is empty\n   input logic      lsu_stbuf_empty_any,               // stbuf is empty\n\n   input logic      lsu_bus_clk_en,                    // bus clock enable\n\n   input el2_lsu_pkt_t  lsu_p,                        // lsu packet in decode\n   input el2_lsu_pkt_t  lsu_pkt_d,                    // lsu packet in d\n   input el2_lsu_pkt_t  lsu_pkt_m,                    // lsu packet in m\n   input el2_lsu_pkt_t  lsu_pkt_r,                    // lsu packet in r\n\n   // Outputs\n   output logic     lsu_bus_obuf_c1_clken,             // obuf clock enable\n   output logic     lsu_busm_clken,                    // bus clock enable\n\n   output logic     lsu_c1_m_clk,                      // m pipe single pulse clock\n   output logic     lsu_c1_r_clk,                      // r pipe single pulse clock\n\n   output logic     lsu_c2_m_clk,                      // m pipe double pulse clock\n   output logic     lsu_c2_r_clk,                      // r pipe double pulse clock\n\n   output logic     lsu_store_c1_m_clk,                // store in m\n   output logic     lsu_store_c1_r_clk,                // store in r\n\n   output logic     lsu_stbuf_c1_clk,\n   output logic     lsu_bus_obuf_c1_clk,               // ibuf clock\n   output logic     lsu_bus_ibuf_c1_clk,               // ibuf clock\n   output logic     lsu_bus_buf_c1_clk,                // ibuf clock\n   output logic     lsu_busm_clk,                      // bus clock\n\n   output logic     lsu_free_c2_clk,                   // free double pulse clock\n\n   input  logic     scan_mode                          // Scan mode\n);\n\n   logic lsu_c1_m_clken, lsu_c1_r_clken;\n   logic lsu_c2_m_clken, lsu_c2_r_clken;\n   logic lsu_c1_m_clken_q, lsu_c1_r_clken_q;\n   logic lsu_store_c1_m_clken, lsu_store_c1_r_clken;\n\n\n   logic lsu_stbuf_c1_clken;\n   logic lsu_bus_ibuf_c1_clken, lsu_bus_buf_c1_clken;\n\n   logic lsu_free_c1_clken, lsu_free_c1_clken_q, lsu_free_c2_clken;\n\n   //-------------------------------------------------------------------------------------------\n   // Clock Enable logic\n   //-------------------------------------------------------------------------------------------\n\n   assign lsu_c1_m_clken = lsu_p.valid | dma_dccm_req | clk_override;\n   assign lsu_c1_r_clken = lsu_pkt_m.valid | lsu_c1_m_clken_q | clk_override;\n\n   assign lsu_c2_m_clken = lsu_c1_m_clken | lsu_c1_m_clken_q | clk_override;\n   assign lsu_c2_r_clken = lsu_c1_r_clken | lsu_c1_r_clken_q | clk_override;\n\n   assign lsu_store_c1_m_clken = ((lsu_c1_m_clken & lsu_pkt_d.store) | clk_override) ;\n   assign lsu_store_c1_r_clken = ((lsu_c1_r_clken & lsu_pkt_m.store) | clk_override) ;\n\n   assign lsu_stbuf_c1_clken = ldst_stbuf_reqvld_r | stbuf_reqvld_any | stbuf_reqvld_flushed_any | clk_override;\n   assign lsu_bus_ibuf_c1_clken = lsu_busreq_r | clk_override;\n   assign lsu_bus_obuf_c1_clken = (lsu_bus_buffer_pend_any | lsu_busreq_r | clk_override) & lsu_bus_clk_en;\n   assign lsu_bus_buf_c1_clken  = ~lsu_bus_buffer_empty_any | lsu_busreq_r | dec_tlu_force_halt | clk_override;\n\n   assign lsu_free_c1_clken = (lsu_p.valid | lsu_pkt_d.valid | lsu_pkt_m.valid | lsu_pkt_r.valid) |\n                              ~lsu_bus_buffer_empty_any | ~lsu_stbuf_empty_any | clk_override;\n   assign lsu_free_c2_clken = lsu_free_c1_clken | lsu_free_c1_clken_q | clk_override;\n\n    // Flops\n   rvdff #(1) lsu_free_c1_clkenff (.din(lsu_free_c1_clken), .dout(lsu_free_c1_clken_q), .clk(active_clk), .*);\n\n   rvdff #(1) lsu_c1_m_clkenff (.din(lsu_c1_m_clken), .dout(lsu_c1_m_clken_q), .clk(lsu_free_c2_clk), .*);\n   rvdff #(1) lsu_c1_r_clkenff (.din(lsu_c1_r_clken), .dout(lsu_c1_r_clken_q), .clk(lsu_free_c2_clk), .*);\n\n   // Clock Headers\n   rvoclkhdr lsu_c1m_cgc ( .en(lsu_c1_m_clken), .l1clk(lsu_c1_m_clk), .* );\n   rvoclkhdr lsu_c1r_cgc ( .en(lsu_c1_r_clken), .l1clk(lsu_c1_r_clk), .* );\n\n   rvoclkhdr lsu_c2m_cgc ( .en(lsu_c2_m_clken), .l1clk(lsu_c2_m_clk), .* );\n   rvoclkhdr lsu_c2r_cgc ( .en(lsu_c2_r_clken), .l1clk(lsu_c2_r_clk), .* );\n\n   rvoclkhdr lsu_store_c1m_cgc (.en(lsu_store_c1_m_clken), .l1clk(lsu_store_c1_m_clk), .*);\n   rvoclkhdr lsu_store_c1r_cgc (.en(lsu_store_c1_r_clken), .l1clk(lsu_store_c1_r_clk), .*);\n\n   rvoclkhdr lsu_stbuf_c1_cgc ( .en(lsu_stbuf_c1_clken), .l1clk(lsu_stbuf_c1_clk), .* );\n   rvoclkhdr lsu_bus_ibuf_c1_cgc ( .en(lsu_bus_ibuf_c1_clken), .l1clk(lsu_bus_ibuf_c1_clk), .* );\n   rvoclkhdr lsu_bus_buf_c1_cgc  ( .en(lsu_bus_buf_c1_clken),  .l1clk(lsu_bus_buf_c1_clk), .* );\n\n   assign lsu_busm_clken = (~lsu_bus_buffer_empty_any | lsu_busreq_r | clk_override) & lsu_bus_clk_en;\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign lsu_busm_clk = 1'b0;\n   assign lsu_bus_obuf_c1_clk = 1'b0;\n`else\n   rvclkhdr  lsu_bus_obuf_c1_cgc ( .en(lsu_bus_obuf_c1_clken), .l1clk(lsu_bus_obuf_c1_clk), .* );\n   rvclkhdr  lsu_busm_cgc (.en(lsu_busm_clken), .l1clk(lsu_busm_clk), .*);\n`endif\n\n   rvoclkhdr lsu_free_cgc (.en(lsu_free_c2_clken), .l1clk(lsu_free_c2_clk), .*);\n\nendmodule\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: DCCM for LSU pipe\n// Comments: Single ported memory\n//\n//\n// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n//\n// //********************************************************************************\n\nmodule el2_lsu_dccm_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n   input logic                             lsu_c2_m_clk,            // clocks\n   input logic                             lsu_c2_r_clk,            // clocks\n   input logic                             lsu_c1_r_clk,            // clocks\n   input logic                             lsu_store_c1_r_clk,      // clocks\n   input logic                             lsu_free_c2_clk,         // clocks\n   input logic                             clk_override,            // Override non-functional clock gating\n   input logic                             clk,                     // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n\n   input logic                             rst_l,                   // reset, active low\n\n   input                                   el2_lsu_pkt_t lsu_pkt_r,// lsu packets\n   input                                   el2_lsu_pkt_t lsu_pkt_m,// lsu packets\n   input                                   el2_lsu_pkt_t lsu_pkt_d,// lsu packets\n   input logic                             addr_in_dccm_d,          // address maps to dccm\n   input logic                             addr_in_pic_d,           // address maps to pic\n   input logic                             addr_in_pic_m,           // address maps to pic\n   input logic                             addr_in_dccm_m, addr_in_dccm_r,   // address in dccm per pipe stage\n   input logic                             addr_in_pic_r,                    // address in pic  per pipe stage\n   input logic                             lsu_raw_fwd_lo_r, lsu_raw_fwd_hi_r,\n   input logic                             lsu_commit_r,            // lsu instruction in r commits\n   input logic                             ldst_dual_m, ldst_dual_r,// load/store is unaligned at 32 bit boundary per pipe stage\n\n   // lsu address down the pipe\n   input logic [31:0]                      lsu_addr_d,\n   input logic [pt.DCCM_BITS-1:0]          lsu_addr_m,\n   input logic [31:0]                      lsu_addr_r,\n\n   // lsu address down the pipe - needed to check unaligned\n   input logic [pt.DCCM_BITS-1:0]          end_addr_d,\n   input logic [pt.DCCM_BITS-1:0]          end_addr_m,\n   input logic [pt.DCCM_BITS-1:0]          end_addr_r,\n\n\n   input logic                             stbuf_reqvld_any,        // write enable\n   input logic [pt.LSU_SB_BITS-1:0]        stbuf_addr_any,          // stbuf address (aligned)\n\n   input logic [pt.DCCM_DATA_WIDTH-1:0]    stbuf_data_any,          // the read out from stbuf\n   input logic [pt.DCCM_ECC_WIDTH-1:0]     stbuf_ecc_any,           // the encoded data with ECC bits\n   input logic [pt.DCCM_DATA_WIDTH-1:0]    stbuf_fwddata_hi_m,      // stbuf fowarding to load\n   input logic [pt.DCCM_DATA_WIDTH-1:0]    stbuf_fwddata_lo_m,      // stbuf fowarding to load\n   input logic [pt.DCCM_BYTE_WIDTH-1:0]    stbuf_fwdbyteen_hi_m,    // stbuf fowarding to load\n   input logic [pt.DCCM_BYTE_WIDTH-1:0]    stbuf_fwdbyteen_lo_m,    // stbuf fowarding to load\n\n   output logic [pt.DCCM_DATA_WIDTH-1:0]   dccm_rdata_hi_r,         // data from the dccm\n   output logic [pt.DCCM_DATA_WIDTH-1:0]   dccm_rdata_lo_r,         // data from the dccm\n   output logic [pt.DCCM_ECC_WIDTH-1:0]    dccm_data_ecc_hi_r,      // data from the dccm + ecc\n   output logic [pt.DCCM_ECC_WIDTH-1:0]    dccm_data_ecc_lo_r,\n   output logic [pt.DCCM_DATA_WIDTH-1:0]   lsu_ld_data_r,           // right justified, ie load byte will have data at 7:0\n   output logic [pt.DCCM_DATA_WIDTH-1:0]   lsu_ld_data_corr_r,      // right justified & ECC corrected, ie load byte will have data at 7:0\n\n   input logic                             lsu_double_ecc_error_r,  // lsu has a DED\n   input logic                             single_ecc_error_hi_r,   // sec detected on hi dccm bank\n   input logic                             single_ecc_error_lo_r,   // sec detected on lower dccm bank\n   input logic [pt.DCCM_DATA_WIDTH-1:0]    sec_data_hi_r,           // corrected dccm data\n   input logic [pt.DCCM_DATA_WIDTH-1:0]    sec_data_lo_r,           // corrected dccm data\n   input logic [pt.DCCM_DATA_WIDTH-1:0]    sec_data_hi_r_ff,        // corrected dccm data\n   input logic [pt.DCCM_DATA_WIDTH-1:0]    sec_data_lo_r_ff,        // corrected dccm data\n   input logic [pt.DCCM_ECC_WIDTH-1:0]     sec_data_ecc_hi_r_ff,    // the encoded data with ECC bits\n   input logic [pt.DCCM_ECC_WIDTH-1:0]     sec_data_ecc_lo_r_ff,    // the encoded data with ECC bits\n\n   output logic [pt.DCCM_DATA_WIDTH-1:0]   dccm_rdata_hi_m,         // data from the dccm\n   output logic [pt.DCCM_DATA_WIDTH-1:0]   dccm_rdata_lo_m,         // data from the dccm\n   output logic [pt.DCCM_ECC_WIDTH-1:0]    dccm_data_ecc_hi_m,      // data from the dccm + ecc\n   output logic [pt.DCCM_ECC_WIDTH-1:0]    dccm_data_ecc_lo_m,\n   output logic [pt.DCCM_DATA_WIDTH-1:0]   lsu_ld_data_m,           // right justified, ie load byte will have data at 7:0\n\n   input logic                             lsu_double_ecc_error_m,  // lsu has a DED\n   input logic [pt.DCCM_DATA_WIDTH-1:0]    sec_data_hi_m,           // corrected dccm data\n   input logic [pt.DCCM_DATA_WIDTH-1:0]    sec_data_lo_m,           // corrected dccm data\n\n   input logic [31:0]                      store_data_m,            // Store data M-stage\n   input logic                             dma_dccm_wen,            // Perform DMA writes only for word/dword\n   input logic                             dma_pic_wen,             // Perform PIC writes\n   input logic [2:0]                       dma_mem_tag_m,           // DMA Buffer entry number M-stage\n   input logic [31:0]                      dma_mem_addr,            // DMA request address\n   input logic [63:0]                      dma_mem_wdata,           // DMA write data\n   input logic [31:0]                      dma_dccm_wdata_lo,       // Shift the dma data to lower bits to make it consistent to lsu stores\n   input logic [31:0]                      dma_dccm_wdata_hi,       // Shift the dma data to lower bits to make it consistent to lsu stores\n   input logic [pt.DCCM_ECC_WIDTH-1:0]     dma_dccm_wdata_ecc_hi,   // ECC bits for the DMA wdata\n   input logic [pt.DCCM_ECC_WIDTH-1:0]     dma_dccm_wdata_ecc_lo,   // ECC bits for the DMA wdata\n\n   output logic [pt.DCCM_DATA_WIDTH-1:0]   store_data_hi_r,\n   output logic [pt.DCCM_DATA_WIDTH-1:0]   store_data_lo_r,\n   output logic [pt.DCCM_DATA_WIDTH-1:0]   store_datafn_hi_r,       // data from the dccm\n   output logic [pt.DCCM_DATA_WIDTH-1:0]   store_datafn_lo_r,       // data from the dccm\n   output logic [31:0]                     store_data_r,            // raw store data to be sent to bus\n   output logic                            ld_single_ecc_error_r,\n   output logic                            ld_single_ecc_error_r_ff,\n\n   output logic [31:0]                     picm_mask_data_m,        // pic data to stbuf\n   output logic                            lsu_stbuf_commit_any,    // stbuf wins the dccm port or is to pic\n   output logic                            lsu_dccm_rden_m,         // dccm read\n   output logic                            lsu_dccm_rden_r,         // dccm read\n\n   output logic                            dccm_dma_rvalid,         // dccm serviving the dma load\n   output logic                            dccm_dma_ecc_error,      // DMA load had ecc error\n   output logic [2:0]                      dccm_dma_rtag,           // DMA return tag\n   output logic [63:0]                     dccm_dma_rdata,          // dccm data to dma request\n\n   // DCCM ports\n   output logic                            dccm_wren,               // dccm interface -- write\n   output logic                            dccm_rden,               // dccm interface -- write\n   output logic [pt.DCCM_BITS-1:0]         dccm_wr_addr_lo,         // dccm interface -- wr addr for lo bank\n   output logic [pt.DCCM_BITS-1:0]         dccm_wr_addr_hi,         // dccm interface -- wr addr for hi bank\n   output logic [pt.DCCM_BITS-1:0]         dccm_rd_addr_lo,         // dccm interface -- read address for lo bank\n   output logic [pt.DCCM_BITS-1:0]         dccm_rd_addr_hi,         // dccm interface -- read address for hi bank\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_lo,         // dccm write data for lo bank\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_hi,         // dccm write data for hi bank\n\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]   dccm_rd_data_lo,         // dccm read data back from the dccm\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]   dccm_rd_data_hi,         // dccm read data back from the dccm\n\n   // PIC ports\n   output logic                            picm_wren,               // write to pic\n   output logic                            picm_rden,               // read to pick\n   output logic                            picm_mken,               // write to pic need a mask\n   output logic [31:0]                     picm_rdaddr,             // address for pic read access\n   output logic [31:0]                     picm_wraddr,             // address for pic write access\n   output logic [31:0]                     picm_wr_data,            // write data\n   input logic [31:0]                      picm_rd_data,            // read data\n\n   input logic                             scan_mode                // scan mode\n);\n\n\n   localparam DCCM_WIDTH_BITS = $clog2(pt.DCCM_BYTE_WIDTH);\n\n   logic                           lsu_dccm_rden_d, lsu_dccm_wren_d;\n   logic                           ld_single_ecc_error_lo_r, ld_single_ecc_error_hi_r;\n   logic                           ld_single_ecc_error_lo_r_ns, ld_single_ecc_error_hi_r_ns;\n   logic                           ld_single_ecc_error_lo_r_ff, ld_single_ecc_error_hi_r_ff;\n   logic                           lsu_double_ecc_error_r_ff;\n   logic [pt.DCCM_BITS-1:0]        ld_sec_addr_lo_r_ff, ld_sec_addr_hi_r_ff;\n   logic [pt.DCCM_DATA_WIDTH-1:0]  store_data_lo_r_in, store_data_hi_r_in ;\n   logic [63:0]                    picm_rd_data_m;\n\n   logic                           dccm_wr_bypass_d_m_hi, dccm_wr_bypass_d_r_hi;\n   logic                           dccm_wr_bypass_d_m_lo, dccm_wr_bypass_d_r_lo;\n   logic                           kill_ecc_corr_lo_r, kill_ecc_corr_hi_r;\n\n    // byte_en flowing down\n   logic [3:0]                     store_byteen_m ,store_byteen_r;\n   logic [7:0]                     store_byteen_ext_m, store_byteen_ext_r;\n\n   if (pt.LOAD_TO_USE_PLUS1 == 1) begin: L2U_Plus1_1\n      logic [63:0]  lsu_rdata_r, lsu_rdata_corr_r;\n      logic [63:0]  dccm_rdata_r, dccm_rdata_corr_r;\n      logic [63:0]  stbuf_fwddata_r;\n      logic [7:0]   stbuf_fwdbyteen_r;\n      logic [31:0]  stbuf_fwddata_lo_r, stbuf_fwddata_hi_r;\n      logic [3:0]   stbuf_fwdbyteen_lo_r, stbuf_fwdbyteen_hi_r;\n      logic [31:0]  lsu_rdata_lo_r, lsu_rdata_hi_r;\n      logic [63:0]  picm_rd_data_r;\n      logic [63:32] lsu_ld_data_r_nc, lsu_ld_data_corr_r_nc;\n      logic [2:0]   dma_mem_tag_r;\n      logic         stbuf_fwddata_en;\n\n      assign dccm_dma_rvalid      = lsu_pkt_r.valid & lsu_pkt_r.load & lsu_pkt_r.dma;\n      assign dccm_dma_ecc_error   = lsu_double_ecc_error_r;\n      assign dccm_dma_rtag[2:0]   = dma_mem_tag_r[2:0];\n      assign dccm_dma_rdata[63:0] = ldst_dual_r ? lsu_rdata_corr_r[63:0] : {2{lsu_rdata_corr_r[31:0]}};\n      assign {lsu_ld_data_r_nc[63:32], lsu_ld_data_r[31:0]}           = lsu_rdata_r[63:0] >> 8*lsu_addr_r[1:0];\n      assign {lsu_ld_data_corr_r_nc[63:32], lsu_ld_data_corr_r[31:0]} = lsu_rdata_corr_r[63:0] >> 8*lsu_addr_r[1:0];\n\n      assign picm_rd_data_r[63:32]   = picm_rd_data_r[31:0];\n      assign dccm_rdata_r[63:0]      = {dccm_rdata_hi_r[31:0],dccm_rdata_lo_r[31:0]};\n      assign dccm_rdata_corr_r[63:0] = {sec_data_hi_r[31:0],sec_data_lo_r[31:0]};\n      assign stbuf_fwddata_r[63:0]   = {stbuf_fwddata_hi_r[31:0], stbuf_fwddata_lo_r[31:0]};\n      assign stbuf_fwdbyteen_r[7:0]  = {stbuf_fwdbyteen_hi_r[3:0], stbuf_fwdbyteen_lo_r[3:0]};\n      assign stbuf_fwddata_en        = (|stbuf_fwdbyteen_hi_m[3:0]) | (|stbuf_fwdbyteen_lo_m[3:0]) | clk_override;\n\n      for (genvar i=0; i<8; i++) begin: GenDMAData\n         assign lsu_rdata_corr_r[(8*i)+7:8*i]  = stbuf_fwdbyteen_r[i] ? stbuf_fwddata_r[(8*i)+7:8*i] :\n                                                                        (addr_in_pic_r ? picm_rd_data_r[(8*i)+7:8*i] :  ({8{addr_in_dccm_r}} & dccm_rdata_corr_r[(8*i)+7:8*i]));\n\n         assign lsu_rdata_r[(8*i)+7:8*i]       = stbuf_fwdbyteen_r[i] ? stbuf_fwddata_r[(8*i)+7:8*i] :\n                                                                        (addr_in_pic_r ? picm_rd_data_r[(8*i)+7:8*i] :  ({8{addr_in_dccm_r}} & dccm_rdata_r[(8*i)+7:8*i]));\n      end\n      rvdffe #(pt.DCCM_DATA_WIDTH) dccm_rdata_hi_r_ff    (.*, .din(dccm_rdata_hi_m[pt.DCCM_DATA_WIDTH-1:0]), .dout(dccm_rdata_hi_r[pt.DCCM_DATA_WIDTH-1:0]), .en((lsu_dccm_rden_m & ldst_dual_m) | clk_override));\n      rvdffe #(pt.DCCM_DATA_WIDTH) dccm_rdata_lo_r_ff    (.*, .din(dccm_rdata_lo_m[pt.DCCM_DATA_WIDTH-1:0]), .dout(dccm_rdata_lo_r[pt.DCCM_DATA_WIDTH-1:0]), .en(lsu_dccm_rden_m | clk_override));\n      rvdffe #(2*pt.DCCM_ECC_WIDTH)  dccm_data_ecc_r_ff  (.*, .din({dccm_data_ecc_hi_m[pt.DCCM_ECC_WIDTH-1:0], dccm_data_ecc_lo_m[pt.DCCM_ECC_WIDTH-1:0]}),\n                                                              .dout({dccm_data_ecc_hi_r[pt.DCCM_ECC_WIDTH-1:0], dccm_data_ecc_lo_r[pt.DCCM_ECC_WIDTH-1:0]}),                                  .en(lsu_dccm_rden_m | clk_override));\n      rvdff #(8)                   stbuf_fwdbyteen_ff    (.*, .din({stbuf_fwdbyteen_hi_m[3:0], stbuf_fwdbyteen_lo_m[3:0]}), .dout({stbuf_fwdbyteen_hi_r[3:0], stbuf_fwdbyteen_lo_r[3:0]}), .clk(lsu_c2_r_clk));\n      rvdffe #(64)                 stbuf_fwddata_ff      (.*, .din({stbuf_fwddata_hi_m[31:0], stbuf_fwddata_lo_m[31:0]}),   .dout({stbuf_fwddata_hi_r[31:0], stbuf_fwddata_lo_r[31:0]}),   .en(stbuf_fwddata_en));\n      rvdffe #(32)                 picm_rddata_rff       (.*, .din(picm_rd_data_m[31:0]),                                   .dout(picm_rd_data_r[31:0]),                                   .en(addr_in_pic_m | clk_override));\n      rvdff #(3)                   dma_mem_tag_rff       (.*, .din(dma_mem_tag_m[2:0]),                                     .dout(dma_mem_tag_r[2:0]),                                     .clk(lsu_c1_r_clk));\n\n   end else begin: L2U_Plus1_0\n\n      logic [63:0]  lsu_rdata_m, lsu_rdata_corr_m;\n      logic [63:0]  dccm_rdata_m, dccm_rdata_corr_m;\n      logic [63:0]  stbuf_fwddata_m;\n      logic [7:0]   stbuf_fwdbyteen_m;\n      logic [63:32] lsu_ld_data_m_nc, lsu_ld_data_corr_m_nc;\n      logic [31:0]  lsu_ld_data_corr_m;\n\n      assign dccm_dma_rvalid      = lsu_pkt_m.valid & lsu_pkt_m.load & lsu_pkt_m.dma;\n      assign dccm_dma_ecc_error   = lsu_double_ecc_error_m;\n      assign dccm_dma_rtag[2:0]   = dma_mem_tag_m[2:0];\n      assign dccm_dma_rdata[63:0] = ldst_dual_m ? lsu_rdata_corr_m[63:0] : {2{lsu_rdata_corr_m[31:0]}};\n      assign {lsu_ld_data_m_nc[63:32], lsu_ld_data_m[31:0]} = lsu_rdata_m[63:0] >> 8*lsu_addr_m[1:0];\n      assign {lsu_ld_data_corr_m_nc[63:32], lsu_ld_data_corr_m[31:0]} = lsu_rdata_corr_m[63:0] >> 8*lsu_addr_m[1:0];\n\n      assign dccm_rdata_m[63:0]      = {dccm_rdata_hi_m[31:0],dccm_rdata_lo_m[31:0]};\n      assign dccm_rdata_corr_m[63:0] = {sec_data_hi_m[31:0],sec_data_lo_m[31:0]};\n      assign stbuf_fwddata_m[63:0]   = {stbuf_fwddata_hi_m[31:0], stbuf_fwddata_lo_m[31:0]};\n      assign stbuf_fwdbyteen_m[7:0]  = {stbuf_fwdbyteen_hi_m[3:0], stbuf_fwdbyteen_lo_m[3:0]};\n\n      for (genvar i=0; i<8; i++) begin: GenLoop\n         assign lsu_rdata_corr_m[(8*i)+7:8*i] = stbuf_fwdbyteen_m[i] ? stbuf_fwddata_m[(8*i)+7:8*i] :\n                                                                       (addr_in_pic_m ? picm_rd_data_m[(8*i)+7:8*i] : ({8{addr_in_dccm_m}} & dccm_rdata_corr_m[(8*i)+7:8*i]));\n\n         assign lsu_rdata_m[(8*i)+7:8*i]      = stbuf_fwdbyteen_m[i] ? stbuf_fwddata_m[(8*i)+7:8*i] :\n                                                                       (addr_in_pic_m ? picm_rd_data_m[(8*i)+7:8*i] : ({8{addr_in_dccm_m}} & dccm_rdata_m[(8*i)+7:8*i]));\n      end\n\n      rvdffe #(32) lsu_ld_data_corr_rff(.*, .din(lsu_ld_data_corr_m[31:0]), .dout(lsu_ld_data_corr_r[31:0]), .en((lsu_pkt_m.valid & lsu_pkt_m.load & (addr_in_pic_m | addr_in_dccm_m)) | clk_override));\n   end\n\n   assign kill_ecc_corr_lo_r = (((lsu_addr_d[pt.DCCM_BITS-1:2] == lsu_addr_r[pt.DCCM_BITS-1:2]) | (end_addr_d[pt.DCCM_BITS-1:2] == lsu_addr_r[pt.DCCM_BITS-1:2])) & lsu_pkt_d.valid & lsu_pkt_d.store & lsu_pkt_d.dma & addr_in_dccm_d) |\n                               (((lsu_addr_m[pt.DCCM_BITS-1:2] == lsu_addr_r[pt.DCCM_BITS-1:2]) | (end_addr_m[pt.DCCM_BITS-1:2] == lsu_addr_r[pt.DCCM_BITS-1:2])) & lsu_pkt_m.valid & lsu_pkt_m.store & lsu_pkt_m.dma & addr_in_dccm_m);\n\n   assign kill_ecc_corr_hi_r = (((lsu_addr_d[pt.DCCM_BITS-1:2] == end_addr_r[pt.DCCM_BITS-1:2]) | (end_addr_d[pt.DCCM_BITS-1:2] == end_addr_r[pt.DCCM_BITS-1:2])) & lsu_pkt_d.valid & lsu_pkt_d.store & lsu_pkt_d.dma & addr_in_dccm_d) |\n                               (((lsu_addr_m[pt.DCCM_BITS-1:2] == end_addr_r[pt.DCCM_BITS-1:2]) | (end_addr_m[pt.DCCM_BITS-1:2] == end_addr_r[pt.DCCM_BITS-1:2])) & lsu_pkt_m.valid & lsu_pkt_m.store & lsu_pkt_m.dma & addr_in_dccm_m);\n\n   assign ld_single_ecc_error_lo_r = lsu_pkt_r.load & single_ecc_error_lo_r & ~lsu_raw_fwd_lo_r;\n   assign ld_single_ecc_error_hi_r = lsu_pkt_r.load & single_ecc_error_hi_r & ~lsu_raw_fwd_hi_r;\n   assign ld_single_ecc_error_r    = (ld_single_ecc_error_lo_r | ld_single_ecc_error_hi_r) & ~lsu_double_ecc_error_r;\n\n   assign ld_single_ecc_error_lo_r_ns = ld_single_ecc_error_lo_r & (lsu_commit_r | lsu_pkt_r.dma) & ~kill_ecc_corr_lo_r;\n   assign ld_single_ecc_error_hi_r_ns = ld_single_ecc_error_hi_r & (lsu_commit_r | lsu_pkt_r.dma) & ~kill_ecc_corr_hi_r;\n   assign ld_single_ecc_error_r_ff = (ld_single_ecc_error_lo_r_ff | ld_single_ecc_error_hi_r_ff) & ~lsu_double_ecc_error_r_ff;\n\n   assign lsu_stbuf_commit_any = stbuf_reqvld_any &\n                                 (~(lsu_dccm_rden_d | lsu_dccm_wren_d | ld_single_ecc_error_r_ff) |\n                                  (lsu_dccm_rden_d & ~((stbuf_addr_any[pt.DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS] == lsu_addr_d[pt.DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]) |\n                                                       (stbuf_addr_any[pt.DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS] == end_addr_d[pt.DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]))));\n\n   // No need to read for aligned word/dword stores since ECC will come by new data completely\n   assign lsu_dccm_rden_d = lsu_pkt_d.valid & (lsu_pkt_d.load | (lsu_pkt_d.store & (~(lsu_pkt_d.word | lsu_pkt_d.dword) | (lsu_addr_d[1:0] != 2'b0)))) & addr_in_dccm_d;\n\n   // DMA will read/write in decode stage\n   assign lsu_dccm_wren_d = dma_dccm_wen;\n\n   // DCCM inputs\n   assign dccm_wren                             = lsu_dccm_wren_d | lsu_stbuf_commit_any | ld_single_ecc_error_r_ff;\n   assign dccm_rden              "}
{"text": "               = lsu_dccm_rden_d & addr_in_dccm_d;\n   assign dccm_wr_addr_lo[pt.DCCM_BITS-1:0]     = ld_single_ecc_error_r_ff ? (ld_single_ecc_error_lo_r_ff ? ld_sec_addr_lo_r_ff[pt.DCCM_BITS-1:0] : ld_sec_addr_hi_r_ff[pt.DCCM_BITS-1:0]) :\n                                                                             lsu_dccm_wren_d ? lsu_addr_d[pt.DCCM_BITS-1:0] : stbuf_addr_any[pt.DCCM_BITS-1:0];\n   assign dccm_wr_addr_hi[pt.DCCM_BITS-1:0]     = ld_single_ecc_error_r_ff ? (ld_single_ecc_error_hi_r_ff ? ld_sec_addr_hi_r_ff[pt.DCCM_BITS-1:0] : ld_sec_addr_lo_r_ff[pt.DCCM_BITS-1:0]) :\n                                                                             lsu_dccm_wren_d ? end_addr_d[pt.DCCM_BITS-1:0] : stbuf_addr_any[pt.DCCM_BITS-1:0];\n   assign dccm_rd_addr_lo[pt.DCCM_BITS-1:0]     = lsu_addr_d[pt.DCCM_BITS-1:0];\n   assign dccm_rd_addr_hi[pt.DCCM_BITS-1:0]     = end_addr_d[pt.DCCM_BITS-1:0];\n   assign dccm_wr_data_lo[pt.DCCM_FDATA_WIDTH-1:0] = ld_single_ecc_error_r_ff ? (ld_single_ecc_error_lo_r_ff ? {sec_data_ecc_lo_r_ff[pt.DCCM_ECC_WIDTH-1:0],sec_data_lo_r_ff[pt.DCCM_DATA_WIDTH-1:0]} :\n                                                                                                               {sec_data_ecc_hi_r_ff[pt.DCCM_ECC_WIDTH-1:0],sec_data_hi_r_ff[pt.DCCM_DATA_WIDTH-1:0]}) :\n                                                                                (dma_dccm_wen ? {dma_dccm_wdata_ecc_lo[pt.DCCM_ECC_WIDTH-1:0],dma_dccm_wdata_lo[pt.DCCM_DATA_WIDTH-1:0]} :\n                                                                                                {stbuf_ecc_any[pt.DCCM_ECC_WIDTH-1:0],stbuf_data_any[pt.DCCM_DATA_WIDTH-1:0]});\n   assign dccm_wr_data_hi[pt.DCCM_FDATA_WIDTH-1:0] = ld_single_ecc_error_r_ff ? (ld_single_ecc_error_hi_r_ff ? {sec_data_ecc_hi_r_ff[pt.DCCM_ECC_WIDTH-1:0],sec_data_hi_r_ff[pt.DCCM_DATA_WIDTH-1:0]} :\n                                                                                                               {sec_data_ecc_lo_r_ff[pt.DCCM_ECC_WIDTH-1:0],sec_data_lo_r_ff[pt.DCCM_DATA_WIDTH-1:0]}) :\n                                                                                (dma_dccm_wen ? {dma_dccm_wdata_ecc_hi[pt.DCCM_ECC_WIDTH-1:0],dma_dccm_wdata_hi[pt.DCCM_DATA_WIDTH-1:0]} :\n                                                                                                {stbuf_ecc_any[pt.DCCM_ECC_WIDTH-1:0],stbuf_data_any[pt.DCCM_DATA_WIDTH-1:0]});\n\n   // DCCM outputs\n   assign store_byteen_m[3:0] = {4{lsu_pkt_m.store}} &\n                                (({4{lsu_pkt_m.by}}    & 4'b0001) |\n                                 ({4{lsu_pkt_m.half}}  & 4'b0011) |\n                                 ({4{lsu_pkt_m.word}}  & 4'b1111));\n\n   assign store_byteen_r[3:0] =  {4{lsu_pkt_r.store}} &\n                                 (({4{lsu_pkt_r.by}}    & 4'b0001) |\n                                  ({4{lsu_pkt_r.half}}  & 4'b0011) |\n                                  ({4{lsu_pkt_r.word}}  & 4'b1111));\n\n   assign store_byteen_ext_m[7:0] = {4'b0,store_byteen_m[3:0]} << lsu_addr_m[1:0];      // The packet in m\n   assign store_byteen_ext_r[7:0] = {4'b0,store_byteen_r[3:0]} << lsu_addr_r[1:0];\n\n\n\n   assign dccm_wr_bypass_d_m_lo   = (stbuf_addr_any[pt.DCCM_BITS-1:2] == lsu_addr_m[pt.DCCM_BITS-1:2]) & addr_in_dccm_m;\n   assign dccm_wr_bypass_d_m_hi   = (stbuf_addr_any[pt.DCCM_BITS-1:2] == end_addr_m[pt.DCCM_BITS-1:2]) & addr_in_dccm_m;\n\n   assign dccm_wr_bypass_d_r_lo   = (stbuf_addr_any[pt.DCCM_BITS-1:2] == lsu_addr_r[pt.DCCM_BITS-1:2]) & addr_in_dccm_r;\n   assign dccm_wr_bypass_d_r_hi   = (stbuf_addr_any[pt.DCCM_BITS-1:2] == end_addr_r[pt.DCCM_BITS-1:2]) & addr_in_dccm_r;\n\n\n   if (pt.LOAD_TO_USE_PLUS1 == 1) begin: L2U1_Plus1_1\n      logic        dccm_wren_Q;\n      logic [31:0] dccm_wr_data_Q;\n      logic        dccm_wr_bypass_d_m_lo_Q, dccm_wr_bypass_d_m_hi_Q;\n      logic [31:0] store_data_pre_hi_r, store_data_pre_lo_r;\n\n      assign {store_data_pre_hi_r[31:0], store_data_pre_lo_r[31:0]} = {32'b0,store_data_r[31:0]} << 8*lsu_addr_r[1:0];\n\n      for (genvar i=0; i<4; i++) begin\n          assign store_data_lo_r[(8*i)+7:(8*i)]   = store_byteen_ext_r[i] ? store_data_pre_lo_r[(8*i)+7:(8*i)] : ((dccm_wren_Q & dccm_wr_bypass_d_m_lo_Q) ? dccm_wr_data_Q[(8*i)+7:(8*i)] : sec_data_lo_r[(8*i)+7:(8*i)]);\n          assign store_data_hi_r[(8*i)+7:(8*i)]   = store_byteen_ext_r[i+4] ? store_data_pre_hi_r[(8*i)+7:(8*i)] : ((dccm_wren_Q & dccm_wr_bypass_d_m_hi_Q) ? dccm_wr_data_Q[(8*i)+7:(8*i)] : sec_data_hi_r[(8*i)+7:(8*i)]);\n\n          assign store_datafn_lo_r[(8*i)+7:(8*i)] = store_byteen_ext_r[i] ? store_data_pre_lo_r[(8*i)+7:(8*i)] : ((lsu_stbuf_commit_any & dccm_wr_bypass_d_r_lo) ? stbuf_data_any[(8*i)+7:(8*i)] :\n                                                                                                                    ((dccm_wren_Q & dccm_wr_bypass_d_m_lo_Q) ? dccm_wr_data_Q[(8*i)+7:(8*i)] : sec_data_lo_r[(8*i)+7:(8*i)]));\n          assign store_datafn_hi_r[(8*i)+7:(8*i)] = store_byteen_ext_r[i+4] ? store_data_pre_hi_r[(8*i)+7:(8*i)] : ((lsu_stbuf_commit_any & dccm_wr_bypass_d_r_hi) ? stbuf_data_any[(8*i)+7:(8*i)] :\n                                                                                                                    ((dccm_wren_Q & dccm_wr_bypass_d_m_hi_Q) ? dccm_wr_data_Q[(8*i)+7:(8*i)] : sec_data_hi_r[(8*i)+7:(8*i)]));\n      end\n\n      rvdff #(1)   dccm_wren_ff       (.*, .din(lsu_stbuf_commit_any),  .dout(dccm_wren_Q),             .clk(lsu_free_c2_clk));   // ECC load errors writing to dccm shouldn't fwd to stores in pipe\n      rvdffe #(32) dccm_wrdata_ff     (.*, .din(stbuf_data_any[31:0]),  .dout(dccm_wr_data_Q[31:0]),    .en(lsu_stbuf_commit_any | clk_override), .clk(clk));\n      rvdff #(1)   dccm_wrbyp_dm_loff (.*, .din(dccm_wr_bypass_d_m_lo), .dout(dccm_wr_bypass_d_m_lo_Q), .clk(lsu_free_c2_clk));\n      rvdff #(1)   dccm_wrbyp_dm_hiff (.*, .din(dccm_wr_bypass_d_m_hi), .dout(dccm_wr_bypass_d_m_hi_Q), .clk(lsu_free_c2_clk));\n      rvdff #(32)  store_data_rff     (.*, .din(store_data_m[31:0]),    .dout(store_data_r[31:0]),      .clk(lsu_store_c1_r_clk));\n\n   end else begin: L2U1_Plus1_0\n\n      logic [31:0] store_data_hi_m, store_data_lo_m;\n      logic [63:0] store_data_mask;\n      assign {store_data_hi_m[31:0] , store_data_lo_m[31:0]} = {32'b0,store_data_m[31:0]} << 8*lsu_addr_m[1:0];\n\n      for (genvar i=0; i<4; i++) begin\n         assign store_data_hi_r_in[(8*i)+7:(8*i)]  = store_byteen_ext_m[i+4] ? store_data_hi_m[(8*i)+7:(8*i)] :\n                                                                               ((lsu_stbuf_commit_any &  dccm_wr_bypass_d_m_hi)   ? stbuf_data_any[(8*i)+7:(8*i)] : sec_data_hi_m[(8*i)+7:(8*i)]);\n         assign store_data_lo_r_in[(8*i)+7:(8*i)]  = store_byteen_ext_m[i]   ? store_data_lo_m[(8*i)+7:(8*i)] :\n                                                                               ((lsu_stbuf_commit_any &  dccm_wr_bypass_d_m_lo) ? stbuf_data_any[(8*i)+7:(8*i)] : sec_data_lo_m[(8*i)+7:(8*i)]);\n\n         assign store_datafn_lo_r[(8*i)+7:(8*i)]   = (lsu_stbuf_commit_any & dccm_wr_bypass_d_r_lo & ~store_byteen_ext_r[i])   ? stbuf_data_any[(8*i)+7:(8*i)] : store_data_lo_r[(8*i)+7:(8*i)];\n         assign store_datafn_hi_r[(8*i)+7:(8*i)]   = (lsu_stbuf_commit_any & dccm_wr_bypass_d_r_hi & ~store_byteen_ext_r[i+4]) ? stbuf_data_any[(8*i)+7:(8*i)] : store_data_hi_r[(8*i)+7:(8*i)];\n      end // for (genvar i=0; i<BYTE_WIDTH; i++)\n\n      for (genvar i=0; i<4; i++) begin\n         assign store_data_mask[(8*i)+7:(8*i)] = {8{store_byteen_r[i]}};\n      end\n      assign store_data_r[31:0]      = 32'({store_data_hi_r[31:0],store_data_lo_r[31:0]} >> 8*lsu_addr_r[1:0]) & store_data_mask[31:0];\n\n      rvdffe #(pt.DCCM_DATA_WIDTH) store_data_hi_rff (.*, .din(store_data_hi_r_in[pt.DCCM_DATA_WIDTH-1:0]), .dout(store_data_hi_r[pt.DCCM_DATA_WIDTH-1:0]), .en((ldst_dual_m & lsu_pkt_m.valid & lsu_pkt_m.store) | clk_override), .clk(clk));\n      rvdff  #(pt.DCCM_DATA_WIDTH) store_data_lo_rff (.*, .din(store_data_lo_r_in[pt.DCCM_DATA_WIDTH-1:0]), .dout(store_data_lo_r[pt.DCCM_DATA_WIDTH-1:0]), .clk(lsu_store_c1_r_clk));\n\n   end\n\n   assign dccm_rdata_lo_m[pt.DCCM_DATA_WIDTH-1:0]   = dccm_rd_data_lo[pt.DCCM_DATA_WIDTH-1:0]; // for ld choose dccm_out\n   assign dccm_rdata_hi_m[pt.DCCM_DATA_WIDTH-1:0]   = dccm_rd_data_hi[pt.DCCM_DATA_WIDTH-1:0]; // for ld this is used for ecc\n\n   assign dccm_data_ecc_lo_m[pt.DCCM_ECC_WIDTH-1:0] = dccm_rd_data_lo[pt.DCCM_FDATA_WIDTH-1:pt.DCCM_DATA_WIDTH];\n   assign dccm_data_ecc_hi_m[pt.DCCM_ECC_WIDTH-1:0] = dccm_rd_data_hi[pt.DCCM_FDATA_WIDTH-1:pt.DCCM_DATA_WIDTH];\n\n   // PIC signals. PIC ignores the lower 2 bits of address since PIC memory registers are 32-bits\n   assign picm_wren          = (lsu_pkt_r.valid & lsu_pkt_r.store & addr_in_pic_r & lsu_commit_r) | dma_pic_wen;\n   assign picm_rden          = lsu_pkt_d.valid & lsu_pkt_d.load  & addr_in_pic_d;\n   assign picm_mken          = lsu_pkt_d.valid & lsu_pkt_d.store & addr_in_pic_d;  // Get the mask for stores\n   assign picm_rdaddr[31:0]  = pt.PIC_BASE_ADDR | {{32-pt.PIC_BITS{1'b0}},lsu_addr_d[pt.PIC_BITS-1:0]};\n\n   assign picm_wraddr[31:0]  = pt.PIC_BASE_ADDR | {{32-pt.PIC_BITS{1'b0}},(dma_pic_wen ? dma_mem_addr[pt.PIC_BITS-1:0] : lsu_addr_r[pt.PIC_BITS-1:0])};\n\n   assign picm_wr_data[31:0] = dma_pic_wen ? dma_mem_wdata[31:0] : store_datafn_lo_r[31:0];\n\n   assign picm_mask_data_m[31:0] = picm_rd_data_m[31:0];\n   assign picm_rd_data_m[63:0]   = {picm_rd_data[31:0],picm_rd_data[31:0]};\n\n   if (pt.DCCM_ENABLE == 1) begin: Gen_dccm_enable\n      rvdff #(1) dccm_rden_mff (.*, .din(lsu_dccm_rden_d), .dout(lsu_dccm_rden_m), .clk(lsu_c2_m_clk));\n      rvdff #(1) dccm_rden_rff (.*, .din(lsu_dccm_rden_m), .dout(lsu_dccm_rden_r), .clk(lsu_c2_r_clk));\n\n      // ECC correction flops since dccm write happens next cycle\n      // We are writing to dccm in r+1 for ecc correction since fast_int needs to be blocked in decode - 1. We can probably write in r for plus0 configuration since we know ecc error in M.\n      // In that case these (_ff) flops are needed only in plus1 configuration\n      rvdff #(1) ld_double_ecc_error_rff    (.*, .din(lsu_double_ecc_error_r),   .dout(lsu_double_ecc_error_r_ff),   .clk(lsu_free_c2_clk));\n      rvdff #(1) ld_single_ecc_error_hi_rff (.*, .din(ld_single_ecc_error_hi_r_ns), .dout(ld_single_ecc_error_hi_r_ff), .clk(lsu_free_c2_clk));\n      rvdff #(1) ld_single_ecc_error_lo_rff (.*, .din(ld_single_ecc_error_lo_r_ns), .dout(ld_single_ecc_error_lo_r_ff), .clk(lsu_free_c2_clk));\n      rvdffe #(pt.DCCM_BITS) ld_sec_addr_hi_rff (.*, .din(end_addr_r[pt.DCCM_BITS-1:0]), .dout(ld_sec_addr_hi_r_ff[pt.DCCM_BITS-1:0]), .en(ld_single_ecc_error_r | clk_override), .clk(clk));\n      rvdffe #(pt.DCCM_BITS) ld_sec_addr_lo_rff (.*, .din(lsu_addr_r[pt.DCCM_BITS-1:0]), .dout(ld_sec_addr_lo_r_ff[pt.DCCM_BITS-1:0]), .en(ld_single_ecc_error_r | clk_override), .clk(clk));\n\n   end else begin: Gen_dccm_disable\n      assign lsu_dccm_rden_m = '0;\n      assign lsu_dccm_rden_r = '0;\n\n      assign lsu_double_ecc_error_r_ff = 1'b0;\n      assign ld_single_ecc_error_hi_r_ff = 1'b0;\n      assign ld_single_ecc_error_lo_r_ff = 1'b0;\n      assign ld_sec_addr_hi_r_ff[pt.DCCM_BITS-1:0] = '0;\n      assign ld_sec_addr_lo_r_ff[pt.DCCM_BITS-1:0] = '0;\n   end\n\n`ifdef RV_ASSERT_ON\n\n   // Load single ECC error correction implies commit/dma\n   property ld_single_ecc_error_commit;\n      @(posedge clk) disable iff(~rst_l) (ld_single_ecc_error_r_ff & dccm_wren) |-> ($past(lsu_commit_r | lsu_pkt_r.dma));\n   endproperty\n   assert_ld_single_ecc_error_commit: assert property (ld_single_ecc_error_commit) else\n     $display(\"No commit or DMA but ECC correction happened\");\n\n\n`endif\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n// Copyright (c) 2023 Antmicro <www.antmicro.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: DCCM for LSU pipe\n// Comments: Single ported memory\n//\n//\n// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n//\n// //********************************************************************************\n\nmodule el2_lsu_dccm_mem\n  import el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n   input logic         clk,                                             // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n   input logic         active_clk,                                      // Clock only while core active.  Through two clock headers. For flops without second clock header built in.\n   input logic         rst_l,                                           // reset, active low\n   input logic         clk_override,                                    // Override non-functional clock gating\n\n   input logic         dccm_wren,                                       // write enable\n   input logic         dccm_rden,                                       // read enable\n   input logic [pt.DCCM_BITS-1:0]  dccm_wr_addr_lo,                     // write address\n   input logic [pt.DCCM_BITS-1:0]  dccm_wr_addr_hi,                     // write address\n   input logic [pt.DCCM_BITS-1:0]  dccm_rd_addr_lo,                     // read address\n   input logic [pt.DCCM_BITS-1:0]  dccm_rd_addr_hi,                     // read address for the upper bank in case of a misaligned access\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_lo,              // write data\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_hi,              // write data\n   el2_mem_if.veer_dccm                   dccm_mem_export,              // RAM repositioned in testbench and connected by this interface\n\n   output logic [pt.DCCM_FDATA_WIDTH-1:0] dccm_rd_data_lo,              // read data from the lo bank\n   output logic [pt.DCCM_FDATA_WIDTH-1:0] dccm_rd_data_hi,              // read data from the hi bank\n\n   input  logic         scan_mode\n);\n\n\n   localparam DCCM_WIDTH_BITS = $clog2(pt.DCCM_BYTE_WIDTH);\n   localparam DCCM_INDEX_BITS = (pt.DCCM_BITS - pt.DCCM_BANK_BITS - pt.DCCM_WIDTH_BITS);\n   localparam DCCM_INDEX_DEPTH = ((pt.DCCM_SIZE)*1024)/((pt.DCCM_BYTE_WIDTH)*(pt.DCCM_NUM_BANKS));  // Depth of memory bank\n\n   logic [pt.DCCM_NUM_BANKS-1:0]                                        wren_bank;\n   logic [pt.DCCM_NUM_BANKS-1:0]                                        rden_bank;\n   logic [pt.DCCM_NUM_BANKS-1:0] [pt.DCCM_BITS-1:(pt.DCCM_BANK_BITS+2)] addr_bank;\n   logic [pt.DCCM_BITS-1:(pt.DCCM_BANK_BITS+DCCM_WIDTH_BITS)]           rd_addr_even, rd_addr_odd;\n   logic                                                                rd_unaligned, wr_unaligned;\n   logic [pt.DCCM_NUM_BANKS-1:0] [pt.DCCM_FDATA_WIDTH-1:0]              dccm_bank_dout;\n   logic [pt.DCCM_FDATA_WIDTH-1:0]                                      wrdata;\n\n   logic [pt.DCCM_NUM_BANKS-1:0][pt.DCCM_FDATA_WIDTH-1:0]               wr_data_bank;\n\n   logic [(DCCM_WIDTH_BITS+pt.DCCM_BANK_BITS-1):DCCM_WIDTH_BITS]        dccm_rd_addr_lo_q;\n   logic [(DCCM_WIDTH_BITS+pt.DCCM_BANK_BITS-1):DCCM_WIDTH_BITS]        dccm_rd_addr_hi_q;\n\n   logic [pt.DCCM_NUM_BANKS-1:0]            dccm_clken;\n\n   assign rd_unaligned = (dccm_rd_addr_lo[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS] != dccm_rd_addr_hi[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]);\n   assign wr_unaligned = (dccm_wr_addr_lo[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS] != dccm_wr_addr_hi[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]);\n\n   // Align the read data\n   assign dccm_rd_data_lo[pt.DCCM_FDATA_WIDTH-1:0]  = dccm_bank_dout[dccm_rd_addr_lo_q[pt.DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]][pt.DCCM_FDATA_WIDTH-1:0];\n   assign dccm_rd_data_hi[pt.DCCM_FDATA_WIDTH-1:0]  = dccm_bank_dout[dccm_rd_addr_hi_q[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]][pt.DCCM_FDATA_WIDTH-1:0];\n\n\n   // 8 Banks, 16KB each (2048 x 72)\n   for (genvar i=0; i<pt.DCCM_NUM_BANKS; i++) begin: mem_bank\n      assign  wren_bank[i]        = dccm_wren & ((dccm_wr_addr_hi[2+:pt.DCCM_BANK_BITS] == i) | (dccm_wr_addr_lo[2+:pt.DCCM_BANK_BITS] == i));\n      assign  rden_bank[i]        = dccm_rden & ((dccm_rd_addr_hi[2+:pt.DCCM_BANK_BITS] == i) | (dccm_rd_addr_lo[2+:pt.DCCM_BANK_BITS] == i));\n      assign  addr_bank[i][(pt.DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] = wren_bank[i] ? (((dccm_wr_addr_hi[2+:pt.DCCM_BANK_BITS] == i) & wr_unaligned) ?\n                                                                                                        dccm_wr_addr_hi[(pt.DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] :\n                                                                                                        dccm_wr_addr_lo[(pt.DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS])  :\n                                                                                                  (((dccm_rd_addr_hi[2+:pt.DCCM_BANK_BITS] == i) & rd_unaligned) ?\n                                                                                                        dccm_rd_addr_hi[(pt.DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] :\n                                                                                                        dccm_rd_addr_lo[(pt.DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS]);\n\n      assign wr_data_bank[i]     = ((dccm_wr_addr_hi[2+:pt.DCCM_BANK_BITS] == i) & wr_unaligned) ? dccm_wr_data_hi[pt.DCCM_FDATA_WIDTH-1:0] : dccm_wr_data_lo[pt.DCCM_FDATA_WIDTH-1:0];\n\n      // clock gating section\n      assign  dccm_clken[i] = (wren_bank[i] | rden_bank[i] | clk_override) ;\n      // end clock gating section\n\n      // Connect to exported RAM Banks\n      always_comb begin\n         dccm_mem_export.dccm_clken[i]                               = dccm_clken[i];\n         dccm_mem_export.dccm_wren_bank[i]                           = wren_bank[i];\n         dccm_mem_export.dccm_addr_bank[i]                           = addr_bank[i];\n         dccm_mem_export.dccm_wr_data_bank[i]                        = wr_data_bank[i][pt.DCCM_DATA_WIDTH-1:0];\n         dccm_mem_export.dccm_wr_ecc_bank[i]                         = wr_data_bank[i][pt.DCCM_FDATA_WIDTH-1:pt.DCCM_DATA_WIDTH];\n         dccm_bank_dout[i][pt.DCCM_DATA_WIDTH-1:0]                   = dccm_mem_export.dccm_bank_dout[i];\n         dccm_bank_dout[i][pt.DCCM_FDATA_WIDTH-1:pt.DCCM_DATA_WIDTH] = dccm_mem_export.dccm_bank_ecc[i];\n      end\n\n   end : mem_bank\n\n   // Flops\n   rvdff  #(pt.DCCM_BANK_BITS) rd_addr_lo_ff (.*, .din(dccm_rd_addr_lo[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]), .dout(dccm_rd_addr_lo_q[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]), .clk(active_clk));\n   rvdff  #(pt.DCCM_BANK_BITS) rd_addr_hi_ff (.*, .din(dccm_rd_addr_hi[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]), .dout(dccm_rd_addr_hi_q[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]), .clk(active_clk));\n\nendmodule // el2_lsu_dccm_mem\n\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: Top level file for load store unit\n// Comments:\n//\n//\n// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n//\n//********************************************************************************\nmodule el2_lsu_ecc\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n(\n   input logic                           clk,                // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n   input logic                           lsu_c2_r_clk,       // clock\n   input logic                           clk_override,       // Override non-functional clock gating\n   input logic                           rst_l,              // reset, active low\n   input logic                           scan_mode,          // scan mode\n\n   input el2_lsu_pkt_t                  lsu_pkt_m,          // packet in m\n   input el2_lsu_pkt_t                  lsu_pkt_r,          // packet in r\n   input logic [pt.DCCM_DATA_WIDTH-1:0]  stbuf_data_any,\n\n   input logic                           dec_tlu_core_ecc_disable,  // disables the ecc computation and error flagging\n\n   input logic                           lsu_dccm_rden_r,          // dccm rden\n   input logic                           addr_in_dccm_r,           // address in dccm\n   input logic  [pt.DCCM_BITS-1:0]       lsu_addr_r,               // start address\n   input logic  [pt.DCCM_BITS-1:0]       end_addr_r,               // end address\n   input logic  [pt.DCCM_DATA_WIDTH-1:0] dccm_rdata_hi_r,          // data from the dccm\n   input logic  [pt.DCCM_DATA_WIDTH-1:0] dccm_rdata_lo_r,          // data from the dccm\n   input logic  [pt.DCCM_ECC_WIDTH-1:0]  dccm_data_ecc_hi_r,       // data from the dccm + ecc\n   input logic  [pt.DCCM_ECC_WIDTH-1:0]  dccm_data_ecc_lo_r,       // data from the dccm + ecc\n   output logic [pt.DCCM_DATA_WIDTH-1:0] sec_data_hi_r,            // corrected dccm data R-stage\n   output logic [pt.DCCM_DATA_WIDTH-1:0] sec_data_lo_r,            // corrected dccm data R-stage\n   output logic [pt.DCCM_DATA_WIDTH-1:0] sec_data_hi_r_ff,         // corrected dccm data R+1 stage\n   output logic [pt.DCCM_DATA_WIDTH-1:0] sec_data_lo_r_ff,         // corrected dccm data R+1 stage\n\n   input logic                           ld_single_ecc_error_r,     // ld has a single ecc error\n   input logic                           ld_single_ecc_error_r_ff,  // ld has a single ecc error\n   input logic                           lsu_dccm_rden_m,           // dccm rden\n   input logic                           addr_in_dccm_m,            // address in dccm\n   input logic  [pt.DCCM_BITS-1:0]       lsu_addr_m,                // start address\n   input logic  [pt.DCCM_BITS-1:0]       end_addr_m,                // end address\n   input logic  [pt.DCCM_DATA_WIDTH-1:0] dccm_rdata_hi_m,           // raw data from mem\n   input logic  [pt.DCCM_DATA_WIDTH-1:0] dccm_rdata_lo_m,           // raw data from mem\n   input logic  [pt.DCCM_ECC_WIDTH-1:0]  dccm_data_ecc_hi_m,        // ecc read out from mem\n   input logic  [pt.DCCM_ECC_WIDTH-1:0]  dccm_data_ecc_lo_m,        // ecc read out from mem\n   output logic [pt.DCCM_DATA_WIDTH-1:0] sec_data_hi_m,             // corrected dccm data M-stage\n   output logic [pt.DCCM_DATA_WIDTH-1:0] sec_data_lo_m,             // corrected dccm data M-stage\n\n   input logic                           dma_dccm_wen,              // Perform DMA writes only for word/dword\n   input logic  [31:0]                   dma_dccm_wdata_lo,         // Shifted dma data to lower bits to make it consistent to lsu stores\n   input logic  [31:0]                   dma_dccm_wdata_hi,         // Shifted dma data to lower bits to make it consistent to lsu stores\n   output logic [pt.DCCM_ECC_WIDTH-1:0]  dma_dccm_wdata_ecc_hi,     // ECC bits for the DMA wdata\n   output logic [pt.DCCM_ECC_WIDTH-1:0]  dma_dccm_wdata_ecc_lo,     // ECC bits for the DMA wdata\n\n   output logic [pt.DCCM_ECC_WIDTH-1:0]  stbuf_ecc_any,             // Encoded data with ECC bits\n   output logic [pt.DCCM_ECC_WIDTH-1:0]  sec_data_ecc_hi_r_ff,      // Encoded data with ECC bits\n   output logic [pt.DCCM_ECC_WIDTH-1:0]  sec_data_ecc_lo_r_ff,      // Encoded data with ECC bits\n\n   output logic                          single_ecc_error_hi_r,                   // sec detected\n   output logic                          single_ecc_error_lo_r,                   // sec detected on lower dccm bank\n   output logic                          lsu_single_ecc_error_r,                  // or of the 2\n   output logic                          lsu_double_ecc_error_r,                   // double error detected\n\n   output logic                          lsu_single_ecc_error_m,                  // or of the 2\n   output logic                          lsu_double_ecc_error_m                   // double error detected\n\n );\n\n   logic                           is_ldst_r;\n   logic                           is_ldst_hi_any, is_ldst_lo_any;\n   logic [pt.DCCM_DATA_WIDTH-1:0]  dccm_wdata_hi_any, dccm_wdata_lo_any;\n   logic [pt.DCCM_ECC_WIDTH-1:0]  dccm_wdata_ecc_hi_any, dccm_wdata_ecc_lo_any;\n   logic [pt.DCCM_DATA_WIDTH-1:0]  dccm_rdata_hi_any, dccm_rdata_lo_any;\n   logic [pt.DCCM_ECC_WIDTH-1:0]   dccm_data_ecc_hi_any, dccm_data_ecc_lo_any;\n   logic [pt.DCCM_DATA_WIDTH-1:0]  sec_data_hi_any, sec_data_lo_any;\n   logic                           single_ecc_error_hi_any, single_ecc_error_lo_any;\n   logic                           double_ecc_error_hi_any, double_ecc_error_lo_any;\n\n   logic                           double_ecc_error_hi_m, double_ecc_error_lo_m;\n   logic                           double_ecc_error_hi_r, double_ecc_error_lo_r;\n\n   logic [6:0]                     ecc_out_hi_nc, ecc_out_lo_nc;\n\n\n   if (pt.LOAD_TO_USE_PLUS1 == 1) begin: L2U_Plus1_1\n      logic        ldst_dual_m, ldst_dual_r;\n      logic        is_ldst_m;\n      logic        is_ldst_hi_r, is_ldst_lo_r;\n\n      assign ldst_dual_r                                 = (lsu_addr_r[2] != end_addr_r[2]);\n      assign is_ldst_r                                   = lsu_pkt_r.valid & (lsu_pkt_r.load | lsu_pkt_r.store) & addr_in_dccm_r & lsu_dccm_rden_r;\n      assign is_ldst_lo_r                                = is_ldst_r & ~dec_tlu_core_ecc_disable;\n      assign is_ldst_hi_r                                = is_ldst_r & ldst_dual_r & ~dec_tlu_core_ecc_disable;   // Always check the ECC Hi/Lo for DMA since we don't align for DMA\n\n      assign is_ldst_hi_any                              = is_ldst_hi_r;\n      assign dccm_rdata_hi_any[pt.DCCM_DATA_WIDTH-1:0]   = dccm_rdata_hi_r[pt.DCCM_DATA_WIDTH-1:0];\n      assign dccm_data_ecc_hi_any[pt.DCCM_ECC_WIDTH-1:0] = dccm_data_ecc_hi_r[pt.DCCM_ECC_WIDTH-1:0];\n      assign is_ldst_lo_any                              = is_ldst_lo_r;\n      assign dccm_rdata_lo_any[pt.DCCM_DATA_WIDTH-1:0]   = dccm_rdata_lo_r[pt.DCCM_DATA_WIDTH-1:0];\n      assign dccm_data_ecc_lo_any[pt.DCCM_ECC_WIDTH-1:0] = dccm_data_ecc_lo_r[pt.DCCM_ECC_WIDTH-1:0];\n\n      assign sec_data_hi_r[pt.DCCM_DATA_WIDTH-1:0]       = sec_data_hi_any[pt.DCCM_DATA_WIDTH-1:0];\n      assign single_ecc_error_hi_r                       = single_ecc_error_hi_any;\n      assign double_ecc_error_hi_r                       = double_ecc_error_hi_any;\n      assign sec_data_lo_r[pt.DCCM_DATA_WIDTH-1:0]       = sec_data_lo_any[pt.DCCM_DATA_WIDTH-1:0];\n      assign single_ecc_error_lo_r                       = single_ecc_error_lo_any;\n      assign double_ecc_error_lo_r                       = double_ecc_error_lo_any;\n\n      assign lsu_single_ecc_error_r                      = single_ecc_error_hi_r | single_ecc_error_lo_r;\n      assign lsu_double_ecc_error_r                      = double_ecc_error_hi_r | double_ecc_error_lo_r;\n\n   end else begin: L2U_Plus1_0\n\n      logic        ldst_dual_m;\n      logic        is_ldst_m;\n      logic        is_ldst_hi_m, is_ldst_lo_m;\n\n      assign ldst_dual_m                                 = (lsu_addr_m[2] != end_addr_m[2]);\n      assign is_ldst_m                                   = lsu_pkt_m.valid & (lsu_pkt_m.load | lsu_pkt_m.store) & addr_in_dccm_m & lsu_dccm_rden_m;\n      assign is_ldst_lo_m                                = is_ldst_m & ~dec_tlu_core_ecc_disable;\n      assign is_ldst_hi_m                                = is_ldst_m & (ldst_dual_m | lsu_pkt_m.dma) & ~dec_tlu_core_ecc_disable;   // Always check the ECC Hi/Lo for DMA since we don't align for DMA\n\n      assign is_ldst_hi_any                              = is_ldst_hi_m;\n      assign dccm_rdata_hi_any[pt.DCCM_DATA_WIDTH-1:0]   = dccm_rdata_hi_m[pt.DCCM_DATA_WIDTH-1:0];\n      assign dccm_data_ecc_hi_any[pt.DCCM_ECC_WIDTH-1:0] = dccm_data_ecc_hi_m[pt.DCCM_ECC_WIDTH-1:0];\n      assign is_ldst_lo_any                              = is_ldst_lo_m;\n      assign dccm_rdata_lo_any[pt.DCCM_DATA_WIDTH-1:0]   = dccm_rdata_lo_m[pt.DCCM_DATA_WIDTH-1:0];\n      assign dccm_data_ecc_lo_any[pt.DCCM_ECC_WIDTH-1:0] = dccm_data_ecc_lo_m[pt.DCCM_ECC_WIDTH-1:0];\n\n      assign sec_data_hi_m[pt.DCCM_DATA_WIDTH-1:0]       = sec_data_hi_any[pt.DCCM_DATA_WIDTH-1:0];\n      assign double_ecc_error_hi_m                       = double_ecc_error_hi_any;\n      assign sec_data_lo_m[pt.DCCM_DATA_WIDTH-1:0]       = sec_data_lo_any[pt.DCCM_DATA_WIDTH-1:0];\n      assign double_ecc_error_lo_m                       = double_ecc_error_lo_any;\n\n      assign lsu_single_ecc_error_m                      = single_ecc_error_hi_any | single_ecc_error_lo_any;\n      assign lsu_double_ecc_error_m                      = double_ecc_error_hi_m   | double_ecc_error_lo_m;\n\n      // Flops\n      rvdff  #(1) lsu_single_ecc_err_r    (.din(lsu_single_ecc_error_m), .dout(lsu_single_ecc_error_r), .clk(lsu_c2_r_clk), .*);\n      rvdff  #(1) lsu_double_ecc_err_r    (.din(lsu_double_ecc_error_m), .dout(lsu_double_ecc_error_r), .clk(lsu_c2_r_clk), .*);\n      rvdff  #(.WIDTH(1)) ldst_sec_lo_rff (.din(single_ecc_error_lo_any),  .dout(single_ecc_error_lo_r),  .clk(lsu_c2_r_clk), .*);\n      rvdff  #(.WIDTH(1)) ldst_sec_hi_rff (.din(single_ecc_error_hi_any),  .dout(single_ecc_error_hi_r),  .clk(lsu_c2_r_clk), .*);\n      rvdffe #(.WIDTH(pt.DCCM_DATA_WIDTH)) sec_data_hi_rff (.din(sec_data_hi_m[pt.DCCM_DATA_WIDTH-1:0]), .dout(sec_data_hi_r[pt.DCCM_DATA_WIDTH-1:0]), .en(lsu_single_ecc_error_m | clk_override), .*);\n      rvdffe #(.WIDTH(pt.DCCM_DATA_WIDTH)) sec_data_lo_rff (.din(sec_data_lo_m[pt.DCCM_DATA_WIDTH-1:0]), .dout(sec_data_lo_r[pt.DCCM_DATA_WIDTH-1:0]), .en(lsu_single_ecc_error_m | clk_override), .*);\n\n   end\n\n   // Logic for ECC generation during write\n   assign dccm_wdata_lo_any[pt.DCCM_DATA_WIDTH-1:0] = ld_single_ecc_error_r_ff ? sec_data_lo_r_ff[pt.DCCM_DATA_WIDTH-1:0] : (dma_dccm_wen ? dma_dccm_wdata_lo[pt.DCCM_DATA_WIDTH-1:0] : stbuf_data_any[pt.DCCM_DATA_WIDTH-1:0]);\n   assign dccm_wdata_hi_any[pt.DCCM_DATA_WIDTH-1:0] = ld_single_ecc_error_r_ff ? sec_data_hi_r_ff[pt.DCCM_DATA_WIDTH-1:0] : (dma_dccm_wen ? dma_dccm_wdata_hi[pt.DCCM_DATA_WIDTH-1:0] : 32'h0);\n\n   assign sec_data_ecc_hi_r_ff[pt.DCCM_ECC_WIDTH-1:0]  = dccm_wdata_ecc_hi_any[pt.DCCM_ECC_WIDTH-1:0];\n   assign sec_data_ecc_lo_r_ff[pt.DCCM_ECC_WIDTH-1:0]  = dccm_wdata_ecc_lo_any[pt.DCCM_ECC_WIDTH-1:0];\n   assign stbuf_ecc_any[pt.DCCM_ECC_WIDTH-1:0]         = dccm_wdata_ecc_lo_any[pt.DCCM_ECC_WIDTH-1:0];\n   assign dma_dccm_wdata_ecc_hi[pt.DCCM_ECC_WIDTH-1:0] = dccm_wdata_ecc_hi_any[pt.DCCM_ECC_WIDTH-1:0];\n   assign dma_dccm_wdata_ecc_lo[pt.DCCM_ECC_WIDTH-1:0] = dccm_wdata_ecc_lo_any[pt.DCCM_ECC_WIDTH-1:0];\n\n   // Instantiate ECC blocks\n   if (pt.DCCM_ENABLE == 1) begin: Gen_dccm_enable\n\n      //Detect/Repair for Hi\n      rvecc_decode lsu_ecc_decode_hi (\n         // Inputs\n         .en(is_ldst_hi_any),\n         .sed_ded (1'b0),    // 1 : means only detection\n         .din(dccm_rdata_hi_any[pt.DCCM_DATA_WIDTH-1:0]),\n         .ecc_in(dccm_data_ecc_hi_any[pt.DCCM_ECC_WIDTH-1:0]),\n         // Outputs\n         .dout(sec_data_hi_any[pt.DCCM_DATA_WIDTH-1:0]),\n         .ecc_out (ecc_out_hi_nc[6:0]),\n         .single_ecc_error(single_ecc_error_hi_any),\n         .double_ecc_error(double_ecc_error_hi_any),\n         .*\n      );\n\n      //Detect/Repair for Lo\n      rvecc_decode lsu_ecc_decode_lo (\n         // Inputs\n         .en(is_ldst_lo_any),\n         .sed_ded (1'b0),    // 1 : means only detection\n         .din(dccm_rdata_lo_any[pt.DCCM_DATA_WIDTH-1:0] ),\n         .ecc_in(dccm_data_ecc_lo_any[pt.DCCM_ECC_WIDTH-1:0]),\n         // Outputs\n         .dout(sec_data_lo_any[pt.DCCM_DATA_WIDTH-1:0]),\n         .ecc_out (ecc_out_lo_nc[6:0]),\n         .single_ecc_error(single_ecc_error_lo_any),\n         .double_ecc_error(double_ecc_error_lo_any),\n         .*\n      );\n\n      rvecc_encode lsu_ecc_encode_hi (\n         //Inputs\n         .din(dccm_wdata_hi_any[pt.DCCM_DATA_WIDTH-1:0]),\n         //Outputs\n         .ecc_out(dccm_wdata_ecc_hi_any[pt.DCCM_ECC_WIDTH-1:0]),\n         .*\n      );\n      rvecc_encode lsu_ecc_encode_lo (\n         //Inputs\n         .din(dccm_wdata_lo_any[pt.DCCM_DATA_WIDTH-1:0]),\n         //Outputs\n         .ecc_out(dccm_wdata_ecc_lo_any[pt.DCCM_ECC_WIDTH-1:0]),\n         .*\n      );\n   end else begin: Gen_dccm_disable // block: Gen_dccm_enable\n      assign sec_data_hi_any[pt.DCCM_DATA_WIDTH-1:0] = '0;\n      assign sec_data_lo_any[pt.DCCM_DATA_WIDTH-1:0] = '0;\n      assign single_ecc_error_hi_any = '0;\n      assign double_ecc_error_hi_any = '0;\n      assign single_ecc_error_lo_any = '0;\n      assign double_ecc_error_lo_any = '0;\n   end\n\n   rvdffe #(.WIDTH(pt.DCCM_DATA_WIDTH)) sec_data_hi_rplus1ff (.din(sec_data_hi_r[pt.DCCM_DATA_WIDTH-1:0]), .dout(sec_data_hi_r_ff[pt.DCCM_DATA_WIDTH-1:0]), .en(ld_single_ecc_error_r | clk_override), .clk(clk), .*);\n   rvdffe #(.WIDTH(pt.DCCM_DATA_WIDTH)) sec_data_lo_rplus1ff (.din(sec_data_lo_r[pt.DCCM_DATA_WIDTH-1:0]), .dout(sec_data_lo_r_ff[pt.DCCM_DATA_WIDTH-1:0]), .en(ld_single_ecc_error_r | clk_override), .clk(clk), .*);\n\n\nendmodule // el2_lsu_ecc\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: LSU control\n// Comments:\n//\n//\n// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n//\n//********************************************************************************\nmodule el2_lsu_lsc_ctl\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n   input logic                rst_l,                     // reset, active low\n   input logic                clk_override,              // Override non-functional clock gating\n   input logic                clk,                       // Clock only while core active.  Through one clock header.  For flops with    second clock header built in.  Connected to ACTIVE_L2CLK.\n\n   // clocks per pipe\n   input logic                lsu_c1_m_clk,\n   input logic                lsu_c1_r_clk,\n   input logic                lsu_c2_m_clk,\n   input logic                lsu_c2_r_clk,\n   input logic                lsu_store_c1_m_clk,\n\n   input logic [31:0]         lsu_ld_data_r,             // Load data R-stage\n   input logic [31:0]         lsu_ld_data_corr_r,        // ECC corrected data R-stage\n   input logic                lsu_single_ecc_error_r,    // ECC single bit error R-stage\n   input logic                lsu_double_ecc_error_r,    // ECC double bit error R-stage\n\n   input logic [31:0]         lsu_ld_data_m,             // Load data M-stage\n   input logic                lsu_single_ecc_error_m,    // ECC single bit error M-stage\n   input logic                lsu_double_ecc_error_m,    // ECC double bit error M-stage\n\n   input logic                flush_m_up,                // Flush M and D stage\n   input logic                flush_r,                   // Flush R-stage\n   input logic                ldst_dual_d,               // load/store is unaligned at 32 bit boundary D-stage\n   input logic                ldst_dual_m,               // load/store is unaligned at 32 bit boundary M-stage\n   input logic                ldst_dual_r,               // load/store is unaligned at 32 bit boundary R-stage\n\n   input logic [31:0]         exu_lsu_rs1_d,             // address\n   input logic [31:0]         exu_lsu_rs2_d,             // store data\n\n   input el2_lsu_pkt_t       lsu_p,                     // lsu control packet\n   input logic                dec_lsu_valid_raw_d,       // Raw valid for address computation\n   input logic [11:0]         dec_lsu_offset_d,          // 12b offset for load/store addresses\n\n   input  logic [31:0]        picm_mask_data_m,          // PIC data M-stage\n   input  logic [31:0]        bus_read_data_m,           // the bus return data\n   output logic [31:0]        lsu_result_m,              // lsu load data\n   output logic [31:0]        lsu_result_corr_r,         // This is the ECC corrected data going to RF\n   // lsu address down the pipe\n   output logic [31:0]        lsu_addr_d,\n   output logic [31:0]        lsu_addr_m,\n   output logic [31:0]        lsu_addr_r,\n   // lsu address down the pipe - needed to check unaligned\n   output logic [31:0]        end_addr_d,\n   output logic [31:0]        end_addr_m,\n   output logic [31:0]        end_addr_r,\n   // store data down the pipe\n   output logic [31:0]        store_data_m,\n\n   input  logic [31:0]         dec_tlu_mrac_ff,          // CSR for memory region control\n   output logic                lsu_exc_m,                // Access or misaligned fault\n   output logic                is_sideeffects_m,         // is sideffects space\n   output logic                lsu_commit_r,             // lsu instruction in r commits\n   output logic                lsu_single_ecc_error_incr,// LSU inc SB error counter\n   output el2_lsu_error_pkt_t lsu_error_pkt_r,          // lsu exception packet\n\n   output logic [31:1]         lsu_fir_addr,             // fast interrupt address\n   output logic [1:0]          lsu_fir_error,            // Error during fast interrupt lookup\n\n   // address in dccm/pic/external per pipe stage\n   output logic               addr_in_dccm_d,\n   output logic               addr_in_dccm_m,\n   output logic               addr_in_dccm_r,\n\n   output logic               addr_in_pic_d,\n   output logic               addr_in_pic_m,\n   output logic               addr_in_pic_r,\n\n   output logic               addr_external_m,\n\n   // DMA slave\n   input logic                dma_dccm_req,\n   input logic [31:0]         dma_mem_addr,\n   input logic [2:0]          dma_mem_sz,\n   input logic                dma_mem_write,\n   input logic [63:0]         dma_mem_wdata,\n\n   // Store buffer related signals\n   output el2_lsu_pkt_t      lsu_pkt_d,\n   output el2_lsu_pkt_t      lsu_pkt_m,\n   output el2_lsu_pkt_t      lsu_pkt_r,\n\n    input logic lsu_pmp_error_start,\n    input logic lsu_pmp_error_end,\n\n   input  logic               scan_mode                  // Scan mode\n\n   );\n\n   logic [31:3]        end_addr_pre_m, end_addr_pre_r;\n   logic [31:0]        full_addr_d;\n   logic [31:0]        full_end_addr_d;\n   logic [31:0]        lsu_rs1_d;\n   logic [11:0]        lsu_offset_d;\n   logic [31:0]        rs1_d;\n   logic [11:0]        offset_d;\n   logic [12:0]        end_addr_offset_d;\n   logic [2:0]         addr_offset_d;\n\n   logic [63:0]        dma_mem_wdata_shifted;\n   logic               addr_external_d;\n   logic               addr_external_r;\n   logic               access_fault_d, misaligned_fault_d;\n   logic               access_fault_m, misaligned_fault_m;\n\n   logic               fir_dccm_access_error_d, fir_nondccm_access_error_d;\n   logic               fir_dccm_access_error_m, fir_nondccm_access_error_m;\n\n   logic [3:0]         exc_mscause_d, exc_mscause_m;\n   logic [31:0]        rs1_d_raw;\n   logic [31:0]        store_data_d, store_data_pre_m, store_data_m_in;\n   logic [31:0]        bus_read_data_r;\n\n   el2_lsu_pkt_t           dma_pkt_d;\n   el2_lsu_pkt_t           lsu_pkt_m_in, lsu_pkt_r_in;\n   el2_lsu_error_pkt_t     lsu_error_pkt_m;\n\n\n   // Premux the rs1/offset for dma\n   assign lsu_rs1_d[31:0]    = dec_lsu_valid_raw_d ? exu_lsu_rs1_d[31:0] : dma_mem_addr[31:0];\n   assign lsu_offset_d[11:0] = dec_lsu_offset_d[11:0] & {12{dec_lsu_valid_raw_d}};\n   assign rs1_d_raw[31:0]    = lsu_rs1_d[31:0];\n   assign offset_d[11:0]     = lsu_offset_d[11:0];\n\n   assign rs1_d[31:0] = (lsu_pkt_d.load_ldst_bypass_d) ? lsu_result_m[31:0] : rs1_d_raw[31:0];\n\n   // generate the ls address\n   rvlsadder   lsadder  (.rs1(rs1_d[31:0]),\n                       .offset(offset_d[11:0]),\n                       .dout(full_addr_d[31:0])\n                       );\n\n   // Module to generate the memory map of the address\n   el2_lsu_addrcheck addrcheck (\n              .start_addr_d(full_addr_d[31:0]),\n              .end_addr_d(full_end_addr_d[31:0]),\n              .rs1_region_d(rs1_d[31:28]),\n              .*\n  );\n\n   // Calculate start/end address for load/store\n   assign addr_offset_d[2:0]      = ({3{lsu_pkt_d.half}} & 3'b01) | ({3{lsu_pkt_d.word}} & 3'b11) | ({3{lsu_pkt_d.dword}} & 3'b111);\n   assign end_addr_offset_d[12:0] = {offset_d[11],offset_d[11:0]} + {9'b0,addr_offset_d[2:0]};\n   assign full_end_addr_d[31:0]   = rs1_d[31:0] + {{19{end_addr_offset_d[12]}},end_addr_offset_d[12:0]};\n   assign end_addr_d[31:0]        = full_end_addr_d[31:0];\n   assign lsu_exc_m               = access_fault_m | misaligned_fault_m;\n\n   // Goes to TLU to increment the ECC error counter\n   assign lsu_single_ecc_error_incr = (lsu_single_ecc_error_r & ~lsu_double_ecc_error_r) & (lsu_commit_r | lsu_pkt_r.dma) & lsu_pkt_r.valid;\n\n   if (pt.LOAD_TO_USE_PLUS1 == 1) begin: L2U_Plus1_1\n      logic               access_fault_r, misaligned_fault_r;\n      logic [3:0]         exc_mscause_r;\n      logic               fir_dccm_access_error_r, fir_nondccm_access_error_r;\n\n      // Generate exception packet\n      assign lsu_error_pkt_r.exc_valid = (access_fault_r | misaligned_fault_r | lsu_double_ecc_error_r) & lsu_pkt_r.valid & ~lsu_pkt_r.dma & ~lsu_pkt_r.fast_int;\n      assign lsu_error_pkt_r.single_ecc_error = lsu_single_ecc_error_r & ~lsu_error_pkt_r.exc_valid & ~lsu_pkt_r.dma;\n      assign lsu_error_pkt_r.inst_type = lsu_pkt_r.store;\n      assign lsu_error_pkt_r.exc_type  = ~misaligned_fault_r;\n      assign lsu_error_pkt_r.mscause[3:0] = (lsu_double_ecc_error_r & ~misaligned_fault_r & ~access_fault_r) ? 4'h1 : exc_mscause_r[3:0];\n      assign lsu_error_pkt_r.addr[31:0] = lsu_addr_r[31:0];\n\n      assign lsu_fir_error[1:0] = fir_nondccm_access_error_r ? 2'b11 : (fir_dccm_access_error_r ? 2'b10 : ((lsu_pkt_r.fast_int & lsu_double_ecc_error_r) ? 2'b01 : 2'b00));\n\n      rvdff #(1) access_fault_rff             (.din(access_fault_m),             .dout(access_fault_r),             .clk(lsu_c1_r_clk), .*);\n      rvdff #(1) misaligned_fault_rff         (.din(misaligned_fault_m),         .dout(misaligned_fault_r),         .clk(lsu_c1_r_clk), .*);\n      rvdff #(4) exc_mscause_rff              (.din(exc_mscause_m[3:0]),         .dout(exc_mscause_r[3:0]),         .clk(lsu_c1_r_clk), .*);\n      rvdff #(1) fir_dccm_access_error_mff    (.din(fir_dccm_access_error_m),    .dout(fir_dccm_access_error_r),    .clk(lsu_c1_r_clk), .*);\n      rvdff #(1) fir_nondccm_access_error_mff (.din(fir_nondccm_access_error_m), .dout(fir_nondccm_access_error_r), .clk(lsu_c1_r_clk), .*);\n\n   end else begin: L2U_Plus1_0\n      logic [1:0] lsu_fir_error_m;\n\n      // Generate exception packet\n      assign lsu_error_pkt_m.exc_valid = (access_fault_m | misaligned_fault_m | lsu_double_ecc_error_m) & lsu_pkt_m.valid & ~lsu_pkt_m.dma & ~lsu_pkt_m.fast_int & ~flush_m_up;\n      assign lsu_error_pkt_m.single_ecc_error = lsu_single_ecc_error_m & ~lsu_error_pkt_m.exc_valid & ~lsu_pkt_m.dma;\n      assign lsu_error_pkt_m.inst_type = lsu_pkt_m.store;\n      assign lsu_error_pkt_m.exc_type  = ~misaligned_fault_m;\n      assign lsu_error_pkt_m.mscause[3:0] = (lsu_double_ecc_error_m & ~misaligned_fault_m & ~access_fault_m) ? 4'h1 : exc_mscause_m[3:0];\n      assign lsu_error_pkt_m.addr[31:0] = lsu_addr_m[31:0];\n\n      assign lsu_fir_error_m[1:0] = fir_nondccm_access_error_m ? 2'b11 : (fir_dccm_access_error_m ? 2'b10 : ((lsu_pkt_m.fast_int & lsu_double_ecc_error_m) ? 2'b01 : 2'b00));\n\n      rvdff  #(1)                             lsu_exc_valid_rff       (.*, .din(lsu_error_pkt_m.exc_valid),                        .dout(lsu_error_pkt_r.exc_valid),                        .clk(lsu_c2_r_clk));\n      rvdff  #(1)                             lsu_single_ecc_error_rff(.*, .din(lsu_error_pkt_m.single_ecc_error),                 .dout(lsu_error_pkt_r.single_ecc_error),                 .clk(lsu_c2_r_clk));\n      rvdffe #($bits(el2_lsu_error_pkt_t)-2) lsu_error_pkt_rff       (.*, .din(lsu_error_pkt_m[$bits(el2_lsu_error_pkt_t)-1:2]), .dout(lsu_error_pkt_r[$bits(el2_lsu_error_pkt_t)-1:2]), .en(lsu_error_pkt_m.exc_valid | lsu_error_pkt_m.single_ecc_error | clk_override));\n      rvdff #(2)                              lsu_fir_error_rff       (.*, .din(lsu_fir_error_m[1:0]),                             .dout(lsu_fir_error[1:0]),                               .clk(lsu_c2_r_clk));\n   end\n\n   //Create DMA packet\n   always_comb begin\n      dma_pkt_d = '0;\n      dma_pkt_d.valid   = dma_dccm_req;\n      dma_pkt_d.dma     = 1'b1;\n      dma_pkt_d.store   = dma_mem_write;\n      dma_pkt_d.load    = ~dma_mem_write;\n      dma_pkt_d.by      = (dma_mem_sz[2:0] == 3'b0);\n      dma_pkt_d.half    = (dma_mem_sz[2:0] == 3'b1);\n      dma_pkt_d.word    = (dma_mem_sz[2:0] == 3'b10);\n      dma_pkt_d.dword   = (dma_mem_sz[2:0] == 3'b11);\n   end\n\n   always_comb begin\n      lsu_pkt_d = dec_lsu_valid_raw_d ? lsu_p : dma_pkt_d;\n      lsu_pkt_m_in = lsu_pkt_d;\n      lsu_pkt_r_in = lsu_pkt_m;\n\n      lsu_pkt_d.valid = (lsu_p.valid & ~(flush_m_up & ~lsu_p.fast_int)) | dma_dccm_req;\n      lsu_pkt_m_in.valid = lsu_pkt_d.valid & ~(flush_m_up & ~lsu_pkt_d.dma);\n      lsu_pkt_r_in.valid = lsu_pkt_m.valid & ~(flush_m_up & ~lsu_pkt_m.dma) ;\n   end\n\n   // C2 clock for valid and C1 for other bits of packet\n   rvdff #(1) lsu_pkt_vldmff (.*, .din(lsu_pkt_m_in.valid), .dout(lsu_pkt_m.valid), .clk(lsu_c2_m_clk));\n   rvdff #(1) lsu_pkt_vldrff (.*, .din(lsu_pkt_r_in.valid), .dout(lsu_pkt_r.valid), .clk(lsu_c2_r_clk));\n\n   rvdff #($bits(el2_lsu_pkt_t)-1) lsu_pkt_mff (.*, .din(lsu_pkt_m_in[$bits(el2_lsu_pkt_t)-1:1]), .dout(lsu_pkt_m[$bits(el2_lsu_pkt_t)-1:1]), .clk(lsu_c1_m_clk));\n   rvdff #($bits(el2_lsu_pkt_t)-1) lsu_pkt_rff (.*, .din(lsu_pkt_r_in[$bits(el2_lsu_pkt_t)-1:1]), .dout(lsu_pkt_r[$bits(el2_lsu_pkt_t)-1:1]), .clk(lsu_c1_r_clk));\n\n\n\n   if (pt.LOAD_TO_USE_PLUS1 == 1) begin: L2U1_Plus1_1\n      logic [31:0] lsu_ld_datafn_r, lsu_ld_datafn_corr_r;\n\n      assign lsu_ld_datafn_r[31:0]  = addr_external_r ? bus_read_data_r[31:0] : lsu_ld_data_r[31:0];\n      assign lsu_ld_datafn_corr_r[31:0]  = addr_external_r ? bus_read_data_r[31:0] : lsu_ld_data_corr_r[31:0];\n\n      // this is really R stage signal\n      assign lsu_result_m[31:0] = ({32{ lsu_pkt_r.unsign & lsu_pkt_r.by  }} & {24'b0,lsu_ld_datafn_r[7:0]}) |\n                                                                    ({32{ lsu_pkt_r.unsign & lsu_pkt_r.half}} & {16'b0,lsu_ld_datafn_r[15:0]}) |\n                                                                    ({32{~lsu_pkt_r.unsign & lsu_pkt_r.by  }} & {{24{  lsu_ld_datafn_r[7]}}, lsu_ld_datafn_r[7:0]}) |\n                                                                    ({32{~lsu_pkt_r.unsign & lsu_pkt_r.half}} & {{16{  lsu_ld_datafn_r[15]}},lsu_ld_datafn_r[15:0]}) |\n                                                                    ({32{lsu_pkt_r.word}}                     & lsu_ld_datafn_r[31:0]);\n\n      // this signal is used for gpr update\n      assign lsu_result_corr_r[31:0] = ({32{ lsu_pkt_r.unsign & lsu_pkt_r.by  }} & {24'b0,lsu_ld_datafn_corr_r[7:0]}) |\n                                                                              ({32{ lsu_pkt_r.unsign & lsu_pkt_r.half}} & {16'b0,lsu_ld_datafn_corr_r[15:0]}) |\n                                                                              ({32{~lsu_pkt_r.unsign & lsu_pkt_r.by  }} & {{24{  lsu_ld_datafn_corr_r[7]}}, lsu_ld_datafn_corr_r[7:0]}) |\n                                                                              ({32{~lsu_pkt_r.unsign & lsu_pkt_r.half}} & {{16{  lsu_ld_datafn_corr_r[15]}},lsu_ld_datafn_corr_r[15:0]}) |\n                                                                              ({32{lsu_pkt_r.word}}                     & lsu_ld_datafn_corr_r[31:0]);\n\n   end else begin: L2U1_Plus1_0 // block: L2U1_Plus1_1\n      logic [31:0] lsu_ld_datafn_m, lsu_ld_datafn_corr_r;\n\n      assign lsu_ld_datafn_m[31:0] = addr_external_m ? bus_read_data_m[31:0] : lsu_ld_data_m[31:0];\n      assign lsu_ld_datafn_corr_r[31:0] = addr_external_r ? bus_read_data_r[31:0] : lsu_ld_data_corr_r[31:0];\n\n      // this result must look at prior stores and merge them in\n      assign lsu_result_m[31:0] = ({32{ lsu_pkt_m.unsign & lsu_pkt_m.by  }} & {24'b0,lsu_ld_datafn_m[7:0]}) |\n                                                                    ({32{ lsu_pkt_m.unsign & lsu_pkt_m.half}} & {16'b0,lsu_ld_datafn_m[15:0]}) |\n                                                                    ({32{~lsu_pkt_m.unsign & lsu_pkt_m.by  }} & {{24{  lsu_ld_datafn_m[7]}}, lsu_ld_datafn_m[7:0]}) |\n                                                                    ({32{~lsu_pkt_m.unsign & lsu_pkt_m.half}} & {{16{  lsu_ld_datafn_m[15]}},lsu_ld_datafn_m[15:0]}) |\n                                                                    ({32{lsu_pkt_m.word}}                     & lsu_ld_datafn_m[31:0]);\n\n      // this signal is used for gpr update\n      assign lsu_result_corr_r[31:0] = ({32{ lsu_pkt_r.unsign & lsu_pkt_r.by  }} & {24'b0,lsu_ld_datafn_corr_r[7:0]}) |\n                                                                              ({32{ lsu_pkt_r.unsign & lsu_pkt_r.half}} & {16'b0,lsu_ld_datafn_corr_r[15:0]}) |\n                                                                              ({32{~lsu_pkt_r.unsign & lsu_pkt_r.by  }} & {{24{  lsu_ld_datafn_corr_r[7]}}, lsu_ld_datafn_corr_r[7:0]}) |\n                                                                              ({32{~lsu_pkt_r.unsign & lsu_pkt_r.half}} & {{16{  lsu_ld_datafn_corr_r[15]}},lsu_ld_datafn_corr_r[15:0]}) |\n                                                                              ({32{lsu_pkt_r.word}}                     & lsu_ld_datafn_corr_r[31:0]);\n   end\n\n   // Fast interrupt address\n   assign lsu_fir_addr[31:1]    = lsu_ld_data_corr_r[31:1];\n\n   // absence load/store all 0's\n   assign lsu_addr_d[31:0] = full_addr_d[31:0];\n\n   // Interrupt as a flush source allows the WB to occur\n   assign lsu_commit_r = lsu_pkt_r.valid & (lsu_pkt_r.store | lsu_pkt_r.load) & ~flush_r & ~lsu_pkt_r.dma;\n\n   assign dma_mem_wdata_shifted[63:0] = dma_mem_wdata[63:0] >> {dma_mem_addr[2:0], 3'b000};   // Shift the dma data to lower bits to make it consistent to lsu stores\n   assign store_data_d[31:0] = dma_dccm_req ? dma_mem_wdata_shifted[31:0] : exu_lsu_rs2_d[31:0];  // Write to PIC still happens in r stage\n\n   assign store_data_m_in[31:0] = (lsu_pkt_d.store_data_bypass_d) ? lsu_result_m[31:0] : store_data_d[31:0];\n\n   assign store_data_m[31:0] = (picm_mask_data_m[31:0] | {32{~addr_in_pic_m}}) & ((lsu_pkt_m.store_data_bypass_m) ? lsu_result_m[31:0] : store_data_pre_m[31:0]);\n\n\n   rvdff #(32)  sdmff (.*, .din(store_data_m_in[31:0]), .dout(store_data_pre_m[31:0]),                       .clk(lsu_store_c1_m_clk));\n\n   rvdff #(32) samff (.*, .din(lsu_addr_d[31:0]), .dout(lsu_addr_m[31:0]), .clk(lsu_c1_m_clk));\n   rvdff #(32) sarff (.*, .din(lsu_addr_m[31:0]), .dout(lsu_addr_r[31:0]), .clk(lsu_c1_r_clk));\n\n   assign end_addr_m[31:3] = ldst_dual_m ? end_addr_pre_m[31:3] : lsu_addr_m[31:3];       // This is for power saving\n   assign end_addr_r[31:3] = ldst_dual_r ? end_addr_pre_r[31:3] : lsu_addr_r[31:3];       // This is for power saving\n\n   rvdffe #(29) end_addr_hi_mff (.*, .din(end_addr_d[31:3]), .dout(end_addr_pre_m[31:3]), .en((lsu_pkt_d.valid & ldst_dual_d) | clk_override));\n   rvdffe #(29) end_addr_hi_rff (.*, .din(end_addr_m[31:3]), .dout(end_addr_pre_r[31:3]), .en((lsu_pkt_m.valid & ldst_dual_m) | clk_override));\n\n   rvdff #(3)  end_addr_lo_mff (.*, .din(end_addr_d[2:0]), .dout(end_addr_m[2:0]), .clk(lsu_c1_m_clk));\n   rvdff #(3)  end_addr_lo_rff (.*, .din(end_addr_m[2:0]), .dout(end_addr_r[2:0]), .clk(lsu_c1_r_clk));\n\n   rvdff #(1) addr_in_dccm_mff(.din(addr_in_dccm_d), .dout(addr_in_dccm_m), .clk(lsu_c1_m_clk), .*);\n   rvdff #(1) addr_in_dccm_rff(.din(addr_in_dccm_m), .dout(addr_in_dccm_r), .clk(lsu_c1_r_clk), .*);\n\n   rvdff #(1) addr_in_pic_mff(.din(addr_in_pic_d), .dout(addr_in_pic_m), .clk(lsu_c1_m_clk), .*);\n   rvdff #(1) addr_in_pic_rff(.din(addr_in_pic_m), .dout(addr_in_pic_r), .clk(lsu_c1_r_clk), .*);\n\n   rvdff #(1) addr_external_mff(.din(addr_external_d), .dout(addr_external_m), .clk(lsu_c1_m_clk), .*);\n   rvdff #(1) addr_external_rff(.din(addr_external_m), .dout(addr_external_r), .clk(lsu_c1_r_clk), .*);\n\n   rvdff #(1) access_fault_mff     (.din(access_fault_d),     .dout(access_fault_m),     .clk(lsu_c1_m_clk), .*);\n   rvdff #(1) misaligned_fault_mff (.din(misaligned_fault_d), .dout(misaligned_fault_m), .clk(lsu_c1_m_clk), .*);\n   rvdff #(4) exc_mscause_mff      (.din(exc_mscause_d[3:0]), .dout(exc_mscause_m[3:0]), .clk(lsu_c1_m_clk), .*);\n\n   rvdff #(1) fir_dccm_access_error_mff  "}
{"text": "  (.din(fir_dccm_access_error_d),    .dout(fir_dccm_access_error_m),    .clk(lsu_c1_m_clk), .*);\n   rvdff #(1) fir_nondccm_access_error_mff (.din(fir_nondccm_access_error_d), .dout(fir_nondccm_access_error_m), .clk(lsu_c1_m_clk), .*);\n\n   rvdffe #(32) bus_read_data_r_ff (.*, .din(bus_read_data_m[31:0]), .dout(bus_read_data_r[31:0]), .en(addr_external_m | clk_override));\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: Store Buffer\n// Comments: Dual writes and single drain\n//\n//\n// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n//\n// //********************************************************************************\n\n\nmodule el2_lsu_stbuf\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n(\n   input logic                           clk,                         // core clock\n   input logic                           rst_l,                       // reset\n\n   input logic                           lsu_stbuf_c1_clk,            // stbuf clock\n   input logic                           lsu_free_c2_clk,             // free clk\n\n   // Store Buffer input\n   input logic                           store_stbuf_reqvld_r,        // core instruction goes to stbuf\n   input logic                           lsu_commit_r,                // lsu commits\n   input logic                           dec_lsu_valid_raw_d,         // Speculative decode valid\n   input logic [pt.DCCM_DATA_WIDTH-1:0]  store_data_hi_r,             // merged data from the dccm for stores. This is used for fwding\n   input logic [pt.DCCM_DATA_WIDTH-1:0]  store_data_lo_r,             // merged data from the dccm for stores. This is used for fwding\n   input logic [pt.DCCM_DATA_WIDTH-1:0]  store_datafn_hi_r,           // merged data from the dccm for stores\n   input logic [pt.DCCM_DATA_WIDTH-1:0]  store_datafn_lo_r,           // merged data from the dccm for stores\n\n   // Store Buffer output\n   output logic                          stbuf_reqvld_any,            // stbuf is draining\n   output logic                          stbuf_reqvld_flushed_any,    // Top entry is flushed\n   output logic [pt.LSU_SB_BITS-1:0]     stbuf_addr_any,              // address\n   output logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_data_any,              // stbuf data\n\n   input  logic                          lsu_stbuf_commit_any,        // pop the stbuf as it commite\n   output logic                          lsu_stbuf_full_any,          // stbuf is full\n   output logic                          lsu_stbuf_empty_any,         // stbuf is empty\n   output logic                          ldst_stbuf_reqvld_r,         // needed for clocking\n\n   input logic [pt.LSU_SB_BITS-1:0]      lsu_addr_d,                  // lsu address D-stage\n   input logic [31:0]                    lsu_addr_m,                  // lsu address M-stage\n   input logic [31:0]                    lsu_addr_r,                  // lsu address R-stage\n\n   input logic [pt.LSU_SB_BITS-1:0]      end_addr_d,                  // lsu end address D-stage - needed to check unaligned\n   input logic [31:0]                    end_addr_m,                  // lsu end address M-stage - needed to check unaligned\n   input logic [31:0]                    end_addr_r,                  // lsu end address R-stage - needed to check unaligned\n\n   input logic                           ldst_dual_d, ldst_dual_m, ldst_dual_r,\n   input logic                           addr_in_dccm_m,              // address is in dccm\n   input logic                           addr_in_dccm_r,              // address is in dccm\n\n   // Forwarding signals\n   input logic                           lsu_cmpen_m,                 // needed for forwarding stbuf - load\n   input el2_lsu_pkt_t                  lsu_pkt_m,                   // LSU packet M-stage\n   input el2_lsu_pkt_t                  lsu_pkt_r,                   // LSU packet R-stage\n\n   output logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_fwddata_hi_m,          // stbuf data\n   output logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_fwddata_lo_m,          // stbuf data\n   output logic [pt.DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_hi_m,        // stbuf data\n   output logic [pt.DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_lo_m,        // stbuf data\n\n   input  logic       scan_mode                                       // Scan mode\n\n);\n\n\n   localparam DEPTH      = pt.LSU_STBUF_DEPTH;\n   localparam DATA_WIDTH = pt.DCCM_DATA_WIDTH;\n   localparam BYTE_WIDTH = pt.DCCM_BYTE_WIDTH;\n   localparam DEPTH_LOG2 = $clog2(DEPTH);\n\n   // These are the fields in the store queue\n   logic [DEPTH-1:0]                     stbuf_vld;\n   logic [DEPTH-1:0]                     stbuf_dma_kill;\n   logic [DEPTH-1:0][pt.LSU_SB_BITS-1:0] stbuf_addr;\n   logic [DEPTH-1:0][BYTE_WIDTH-1:0]     stbuf_byteen;\n   logic [DEPTH-1:0][DATA_WIDTH-1:0]     stbuf_data;\n\n   logic [DEPTH-1:0]                     sel_lo;\n   logic [DEPTH-1:0]                     stbuf_wr_en;\n   logic [DEPTH-1:0]                     stbuf_dma_kill_en;\n   logic [DEPTH-1:0]                     stbuf_reset;\n   logic [DEPTH-1:0][pt.LSU_SB_BITS-1:0] stbuf_addrin;\n   logic [DEPTH-1:0][DATA_WIDTH-1:0]     stbuf_datain;\n   logic [DEPTH-1:0][BYTE_WIDTH-1:0]     stbuf_byteenin;\n\n   logic [7:0]             store_byteen_ext_r;\n   logic [BYTE_WIDTH-1:0]  store_byteen_hi_r;\n   logic [BYTE_WIDTH-1:0]  store_byteen_lo_r;\n\n   logic                   WrPtrEn, RdPtrEn;\n   logic [DEPTH_LOG2-1:0]  WrPtr, RdPtr;\n   logic [DEPTH_LOG2-1:0]  NxtWrPtr, NxtRdPtr;\n   logic [DEPTH_LOG2-1:0]  WrPtrPlus1, WrPtrPlus2, RdPtrPlus1;\n\n   logic                   dual_stbuf_write_r;\n\n   logic                   isdccmst_m, isdccmst_r;\n   logic [3:0]             stbuf_numvld_any, stbuf_specvld_any;\n   logic [1:0]             stbuf_specvld_m, stbuf_specvld_r;\n\n   logic [pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] cmpaddr_hi_m, cmpaddr_lo_m;\n\n   // variables to detect matching from the store queue\n   logic [DEPTH-1:0]                 stbuf_match_hi, stbuf_match_lo;\n   logic [DEPTH-1:0][BYTE_WIDTH-1:0] stbuf_fwdbyteenvec_hi, stbuf_fwdbyteenvec_lo;\n   logic [DATA_WIDTH-1:0]            stbuf_fwddata_hi_pre_m, stbuf_fwddata_lo_pre_m;\n   logic [BYTE_WIDTH-1:0]            stbuf_fwdbyteen_hi_pre_m, stbuf_fwdbyteen_lo_pre_m;\n\n   // logic to detect matching from the pipe - needed for store - load forwarding\n   logic [BYTE_WIDTH-1:0]  ld_byte_rhit_lo_lo, ld_byte_rhit_hi_lo, ld_byte_rhit_lo_hi, ld_byte_rhit_hi_hi;\n   logic                   ld_addr_rhit_lo_lo, ld_addr_rhit_hi_lo, ld_addr_rhit_lo_hi, ld_addr_rhit_hi_hi;\n\n   logic [BYTE_WIDTH-1:0]  ld_byte_hit_lo, ld_byte_rhit_lo;\n   logic [BYTE_WIDTH-1:0]  ld_byte_hit_hi, ld_byte_rhit_hi;\n\n   logic [BYTE_WIDTH-1:0]  ldst_byteen_hi_r;\n   logic [BYTE_WIDTH-1:0]  ldst_byteen_lo_r;\n   // byte_en flowing down\n   logic [7:0]             ldst_byteen_r;\n   logic [7:0]             ldst_byteen_ext_r;\n   // fwd data through the pipe\n   logic [31:0]       ld_fwddata_rpipe_lo;\n   logic [31:0]       ld_fwddata_rpipe_hi;\n\n   // coalescing signals\n   logic [DEPTH-1:0]      store_matchvec_lo_r, store_matchvec_hi_r;\n   logic                  store_coalesce_lo_r, store_coalesce_hi_r;\n\n   //----------------------------------------\n   // Logic starts here\n   //----------------------------------------\n   // Create high/low byte enables\n   assign store_byteen_ext_r[7:0]           = ldst_byteen_r[7:0] << lsu_addr_r[1:0];\n   assign store_byteen_hi_r[BYTE_WIDTH-1:0] = store_byteen_ext_r[7:4] & {4{lsu_pkt_r.store}};\n   assign store_byteen_lo_r[BYTE_WIDTH-1:0] = store_byteen_ext_r[3:0] & {4{lsu_pkt_r.store}};\n\n   assign RdPtrPlus1[DEPTH_LOG2-1:0]     = RdPtr[DEPTH_LOG2-1:0] + 1'b1;\n   assign WrPtrPlus1[DEPTH_LOG2-1:0]     = WrPtr[DEPTH_LOG2-1:0] + 1'b1;\n   assign WrPtrPlus2[DEPTH_LOG2-1:0]     = WrPtr[DEPTH_LOG2-1:0] + 2'b10;\n\n   // ecc error on both hi/lo\n   assign dual_stbuf_write_r   = ldst_dual_r & store_stbuf_reqvld_r;\n   assign ldst_stbuf_reqvld_r  = ((lsu_commit_r | lsu_pkt_r.dma) & store_stbuf_reqvld_r);\n\n  // Store Buffer coalescing\n   for (genvar i=0; i<DEPTH; i++) begin: FindMatchEntry\n       assign store_matchvec_lo_r[i] = (stbuf_addr[i][pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == lsu_addr_r[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) & stbuf_vld[i] & ~stbuf_dma_kill[i] & ~stbuf_reset[i];\n       assign store_matchvec_hi_r[i] = (stbuf_addr[i][pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == end_addr_r[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) & stbuf_vld[i] & ~stbuf_dma_kill[i] & dual_stbuf_write_r & ~stbuf_reset[i];\n   end: FindMatchEntry\n\n   assign store_coalesce_lo_r = |store_matchvec_lo_r[DEPTH-1:0];\n   assign store_coalesce_hi_r = |store_matchvec_hi_r[DEPTH-1:0];\n\n\n   if (pt.DCCM_ENABLE == 1) begin: Gen_dccm_enable\n      // Allocate new in this entry if :\n      // 1. wrptr, single allocate, lo did not coalesce\n      // 2. wrptr, double allocate, lo ^ hi coalesced\n      // 3. wrptr + 1, double alloacte, niether lo or hi coalesced\n      // Also update if there is a hi or a lo coalesce to this entry\n      // Store Buffer instantiation\n      for (genvar i=0; i<DEPTH; i++) begin: GenStBuf\n         assign stbuf_wr_en[i] = ldst_stbuf_reqvld_r & (\n                                   ( (i == WrPtr[DEPTH_LOG2-1:0])      &  ~store_coalesce_lo_r)   |                                                    // Allocate : new Lo\n                                   ( (i == WrPtr[DEPTH_LOG2-1:0])      &  dual_stbuf_write_r & ~store_coalesce_hi_r) |                               // Allocate : only 1 new Write Either\n                                   ( (i == WrPtrPlus1[DEPTH_LOG2-1:0]) &  dual_stbuf_write_r & ~(store_coalesce_lo_r | store_coalesce_hi_r)) |     // Allocate2 : 2 new so Write Hi\n                                   store_matchvec_lo_r[i] | store_matchvec_hi_r[i]);                                                                 // Coalesced Write Lo or Hi\n         assign stbuf_reset[i] = (lsu_stbuf_commit_any | stbuf_reqvld_flushed_any) & (i == RdPtr[DEPTH_LOG2-1:0]);\n\n         // Mux select for start/end address\n         assign sel_lo[i]                         = ((~ldst_dual_r | store_stbuf_reqvld_r) & (i == WrPtr[DEPTH_LOG2-1:0]) & ~store_coalesce_lo_r) |   // lo allocated new entry\n                                                    store_matchvec_lo_r[i];                                                                                                           // lo coalesced in to this entry\n         assign stbuf_addrin[i][pt.LSU_SB_BITS-1:0]  = sel_lo[i] ? lsu_addr_r[pt.LSU_SB_BITS-1:0]       : end_addr_r[pt.LSU_SB_BITS-1:0];\n         assign stbuf_byteenin[i][BYTE_WIDTH-1:0] = sel_lo[i] ? (stbuf_byteen[i][BYTE_WIDTH-1:0] | store_byteen_lo_r[BYTE_WIDTH-1:0])          : (stbuf_byteen[i][BYTE_WIDTH-1:0] | store_byteen_hi_r[BYTE_WIDTH-1:0]);\n         assign stbuf_datain[i][7:0]              = sel_lo[i] ? ((~stbuf_byteen[i][0] | store_byteen_lo_r[0]) ? store_datafn_lo_r[7:0]   : stbuf_data[i][7:0])    :\n                                                                ((~stbuf_byteen[i][0] | store_byteen_hi_r[0]) ? store_datafn_hi_r[7:0]   : stbuf_data[i][7:0]);\n         assign stbuf_datain[i][15:8]             = sel_lo[i] ? ((~stbuf_byteen[i][1] | store_byteen_lo_r[1]) ? store_datafn_lo_r[15:8]  : stbuf_data[i][15:8])    :\n                                                                ((~stbuf_byteen[i][1] | store_byteen_hi_r[1]) ? store_datafn_hi_r[15:8]  : stbuf_data[i][15:8]);\n         assign stbuf_datain[i][23:16]            = sel_lo[i] ? ((~stbuf_byteen[i][2] | store_byteen_lo_r[2]) ? store_datafn_lo_r[23:16] : stbuf_data[i][23:16])    :\n                                                                ((~stbuf_byteen[i][2] | store_byteen_hi_r[2]) ? store_datafn_hi_r[23:16] : stbuf_data[i][23:16]);\n         assign stbuf_datain[i][31:24]            = sel_lo[i] ? ((~stbuf_byteen[i][3] | store_byteen_lo_r[3]) ? store_datafn_lo_r[31:24] : stbuf_data[i][31:24])    :\n                                                                ((~stbuf_byteen[i][3] | store_byteen_hi_r[3]) ? store_datafn_hi_r[31:24] : stbuf_data[i][31:24]);\n\n         rvdffsc #(.WIDTH(1))              stbuf_vldff         (.din(1'b1),                                .dout(stbuf_vld[i]),                      .en(stbuf_wr_en[i]), .clear(stbuf_reset[i]), .clk(lsu_free_c2_clk), .*);\n         rvdffsc #(.WIDTH(1))              stbuf_killff        (.din(1'b1),                                .dout(stbuf_dma_kill[i]),                 .en(stbuf_dma_kill_en[i]), .clear(stbuf_reset[i]), .clk(lsu_free_c2_clk), .*);\n         rvdffe  #(.WIDTH(pt.LSU_SB_BITS)) stbuf_addrff        (.din(stbuf_addrin[i][pt.LSU_SB_BITS-1:0]), .dout(stbuf_addr[i][pt.LSU_SB_BITS-1:0]), .en(stbuf_wr_en[i]), .*);\n         rvdffsc #(.WIDTH(BYTE_WIDTH))     stbuf_byteenff      (.din(stbuf_byteenin[i][BYTE_WIDTH-1:0]),   .dout(stbuf_byteen[i][BYTE_WIDTH-1:0]),   .en(stbuf_wr_en[i]), .clear(stbuf_reset[i]), .clk(lsu_stbuf_c1_clk), .*);\n         rvdffe  #(.WIDTH(DATA_WIDTH))     stbuf_dataff        (.din(stbuf_datain[i][DATA_WIDTH-1:0]),     .dout(stbuf_data[i][DATA_WIDTH-1:0]),     .en(stbuf_wr_en[i]), .*);\n      end\n   end else begin: Gen_dccm_disable\n      assign stbuf_wr_en[DEPTH-1:0] = '0;\n      assign stbuf_reset[DEPTH-1:0] = '0;\n      assign stbuf_vld[DEPTH-1:0]   = '0;\n      assign stbuf_dma_kill[DEPTH-1:0] = '0;\n      assign stbuf_addr[DEPTH-1:0]  = '0;\n      assign stbuf_byteen[DEPTH-1:0] = '0;\n      assign stbuf_data[DEPTH-1:0]   = '0;\n   end\n\n   // Store Buffer drain logic\n   assign stbuf_reqvld_flushed_any            = stbuf_vld[RdPtr] & stbuf_dma_kill[RdPtr];\n   assign stbuf_reqvld_any                    = stbuf_vld[RdPtr] & ~stbuf_dma_kill[RdPtr] & ~(|stbuf_dma_kill_en[DEPTH-1:0]);  // Don't drain if some kill bit is being set this cycle\n   assign stbuf_addr_any[pt.LSU_SB_BITS-1:0]  = stbuf_addr[RdPtr][pt.LSU_SB_BITS-1:0];\n   assign stbuf_data_any[DATA_WIDTH-1:0]      = stbuf_data[RdPtr][DATA_WIDTH-1:0];\n\n   // Update the RdPtr/WrPtr logic\n   // Need to revert the WrPtr for flush cases. Also revert the pipe WrPtrs\n   assign WrPtrEn                  = (ldst_stbuf_reqvld_r  & ~dual_stbuf_write_r & ~(store_coalesce_hi_r | store_coalesce_lo_r))  |  // writing 1 and did not coalesce\n                                     (ldst_stbuf_reqvld_r  &  dual_stbuf_write_r & ~(store_coalesce_hi_r & store_coalesce_lo_r));    // writing 2 and atleast 1 did not coalesce\n   assign NxtWrPtr[DEPTH_LOG2-1:0] = (ldst_stbuf_reqvld_r & dual_stbuf_write_r & ~(store_coalesce_hi_r | store_coalesce_lo_r)) ? WrPtrPlus2[DEPTH_LOG2-1:0] : WrPtrPlus1[DEPTH_LOG2-1:0];\n   assign RdPtrEn                  = lsu_stbuf_commit_any | stbuf_reqvld_flushed_any;\n   assign NxtRdPtr[DEPTH_LOG2-1:0] = RdPtrPlus1[DEPTH_LOG2-1:0];\n\n   always_comb begin\n      stbuf_numvld_any[3:0] = '0;\n      for (int i=0; i<DEPTH; i++) begin\n         stbuf_numvld_any[3:0] += {3'b0, stbuf_vld[i]};\n      end\n   end\n\n    // These go to store buffer to detect full\n   assign isdccmst_m = lsu_pkt_m.valid & lsu_pkt_m.store & addr_in_dccm_m & ~lsu_pkt_m.dma;\n   assign isdccmst_r = lsu_pkt_r.valid & lsu_pkt_r.store & addr_in_dccm_r & ~lsu_pkt_r.dma;\n\n   assign stbuf_specvld_m[1:0] = {1'b0,isdccmst_m} << (isdccmst_m & ldst_dual_m);\n   assign stbuf_specvld_r[1:0] = {1'b0,isdccmst_r} << (isdccmst_r & ldst_dual_r);\n   assign stbuf_specvld_any[3:0] = stbuf_numvld_any[3:0] +  {2'b0, stbuf_specvld_m[1:0]} + {2'b0, stbuf_specvld_r[1:0]};\n\n   assign lsu_stbuf_full_any  = (~ldst_dual_d & dec_lsu_valid_raw_d) ? (stbuf_specvld_any[3:0] >= DEPTH) : (stbuf_specvld_any[3:0] >= (DEPTH-1));\n   assign lsu_stbuf_empty_any = (stbuf_numvld_any[3:0] == 4'b0);\n\n   // Load forwarding logic from the store queue\n   assign cmpaddr_hi_m[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] = end_addr_m[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)];\n\n   assign cmpaddr_lo_m[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] = lsu_addr_m[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)];\n\n   always_comb begin: GenLdFwd\n      stbuf_fwdbyteen_hi_pre_m[BYTE_WIDTH-1:0]   = '0;\n      stbuf_fwdbyteen_lo_pre_m[BYTE_WIDTH-1:0]   = '0;\n\n      for (int i=0; i<DEPTH; i++) begin\n         stbuf_match_hi[i] = (stbuf_addr[i][pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == cmpaddr_hi_m[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) & stbuf_vld[i] & ~stbuf_dma_kill[i] & addr_in_dccm_m;\n         stbuf_match_lo[i] = (stbuf_addr[i][pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == cmpaddr_lo_m[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) & stbuf_vld[i] & ~stbuf_dma_kill[i] & addr_in_dccm_m;\n\n         // Kill the store buffer entry if there is a dma store since it already updated the dccm\n         stbuf_dma_kill_en[i] = (stbuf_match_hi[i] | stbuf_match_lo[i]) & lsu_pkt_m.valid & lsu_pkt_m.dma & lsu_pkt_m.store;\n\n         for (int j=0; j<BYTE_WIDTH; j++) begin\n            stbuf_fwdbyteenvec_hi[i][j] = stbuf_match_hi[i] & stbuf_byteen[i][j] & stbuf_vld[i];\n            stbuf_fwdbyteen_hi_pre_m[j]  |= stbuf_fwdbyteenvec_hi[i][j];\n\n            stbuf_fwdbyteenvec_lo[i][j] = stbuf_match_lo[i] & stbuf_byteen[i][j] & stbuf_vld[i];\n            stbuf_fwdbyteen_lo_pre_m[j]  |= stbuf_fwdbyteenvec_lo[i][j];\n         end\n      end\n   end // block: GenLdFwd\n\n   always_comb begin: GenLdData\n      stbuf_fwddata_hi_pre_m[31:0]   = '0;\n      stbuf_fwddata_lo_pre_m[31:0]   = '0;\n\n      for (int i=0; i<DEPTH; i++) begin\n         stbuf_fwddata_hi_pre_m[31:0] |= {32{stbuf_match_hi[i]}} & stbuf_data[i][31:0];\n         stbuf_fwddata_lo_pre_m[31:0] |= {32{stbuf_match_lo[i]}} & stbuf_data[i][31:0];\n\n      end\n\n   end // block: GenLdData\n\n   // Create Hi/Lo signals - needed for the pipe forwarding\n   assign ldst_byteen_r[7:0] =  ({8{lsu_pkt_r.by}}    & 8'b0000_0001) |\n                                 ({8{lsu_pkt_r.half}}  & 8'b0000_0011) |\n                                 ({8{lsu_pkt_r.word}}  & 8'b0000_1111) |\n                                 ({8{lsu_pkt_r.dword}} & 8'b1111_1111);\n\n   assign ldst_byteen_ext_r[7:0] = ldst_byteen_r[7:0] << lsu_addr_r[1:0];\n\n   assign ldst_byteen_hi_r[3:0]   = ldst_byteen_ext_r[7:4];\n   assign ldst_byteen_lo_r[3:0]   = ldst_byteen_ext_r[3:0];\n\n   assign ld_addr_rhit_lo_lo = (lsu_addr_m[31:2] == lsu_addr_r[31:2]) & lsu_pkt_r.valid & lsu_pkt_r.store & ~lsu_pkt_r.dma;\n   assign ld_addr_rhit_lo_hi = (end_addr_m[31:2] == lsu_addr_r[31:2]) & lsu_pkt_r.valid & lsu_pkt_r.store & ~lsu_pkt_r.dma;\n   assign ld_addr_rhit_hi_lo = (lsu_addr_m[31:2] == end_addr_r[31:2]) & lsu_pkt_r.valid & lsu_pkt_r.store & ~lsu_pkt_r.dma & dual_stbuf_write_r;\n   assign ld_addr_rhit_hi_hi = (end_addr_m[31:2] == end_addr_r[31:2]) & lsu_pkt_r.valid & lsu_pkt_r.store & ~lsu_pkt_r.dma & dual_stbuf_write_r;\n\n   for (genvar i=0; i<BYTE_WIDTH; i++) begin\n      assign ld_byte_rhit_lo_lo[i] = ld_addr_rhit_lo_lo & ldst_byteen_lo_r[i];\n      assign ld_byte_rhit_lo_hi[i] = ld_addr_rhit_lo_hi & ldst_byteen_lo_r[i];\n      assign ld_byte_rhit_hi_lo[i] = ld_addr_rhit_hi_lo & ldst_byteen_hi_r[i];\n      assign ld_byte_rhit_hi_hi[i] = ld_addr_rhit_hi_hi & ldst_byteen_hi_r[i];\n\n      assign ld_byte_rhit_lo[i] = ld_byte_rhit_lo_lo[i] | ld_byte_rhit_hi_lo[i];\n      assign ld_byte_rhit_hi[i] = ld_byte_rhit_lo_hi[i] | ld_byte_rhit_hi_hi[i];\n\n       assign ld_fwddata_rpipe_lo[(8*i)+7:(8*i)] = ({8{ld_byte_rhit_lo_lo[i]}} & store_data_lo_r[(8*i)+7:(8*i)]) |\n                                                     ({8{ld_byte_rhit_hi_lo[i]}} & store_data_hi_r[(8*i)+7:(8*i)]);\n\n       assign ld_fwddata_rpipe_hi[(8*i)+7:(8*i)] = ({8{ld_byte_rhit_lo_hi[i]}} & store_data_lo_r[(8*i)+7:(8*i)]) |\n                                                     ({8{ld_byte_rhit_hi_hi[i]}} & store_data_hi_r[(8*i)+7:(8*i)]);\n\n      assign ld_byte_hit_lo[i] = ld_byte_rhit_lo_lo[i] | ld_byte_rhit_hi_lo[i];\n      assign ld_byte_hit_hi[i] = ld_byte_rhit_lo_hi[i] | ld_byte_rhit_hi_hi[i];\n\n      assign stbuf_fwdbyteen_hi_m[i] = ld_byte"}
{"text": "_hit_hi[i] | stbuf_fwdbyteen_hi_pre_m[i];\n      assign stbuf_fwdbyteen_lo_m[i] = ld_byte_hit_lo[i] | stbuf_fwdbyteen_lo_pre_m[i];\n      // // Pipe vs Store Queue priority\n      assign stbuf_fwddata_lo_m[(8*i)+7:(8*i)] = ld_byte_rhit_lo[i]    ? ld_fwddata_rpipe_lo[(8*i)+7:(8*i)] : stbuf_fwddata_lo_pre_m[(8*i)+7:(8*i)];\n      // // Pipe vs Store Queue priority\n      assign stbuf_fwddata_hi_m[(8*i)+7:(8*i)] = ld_byte_rhit_hi[i]    ? ld_fwddata_rpipe_hi[(8*i)+7:(8*i)] : stbuf_fwddata_hi_pre_m[(8*i)+7:(8*i)];\n   end\n\n   // Flops\n   rvdffs #(.WIDTH(DEPTH_LOG2)) WrPtrff (.din(NxtWrPtr[DEPTH_LOG2-1:0]), .dout(WrPtr[DEPTH_LOG2-1:0]), .en(WrPtrEn), .clk(lsu_stbuf_c1_clk), .*);\n   rvdffs #(.WIDTH(DEPTH_LOG2)) RdPtrff (.din(NxtRdPtr[DEPTH_LOG2-1:0]), .dout(RdPtr[DEPTH_LOG2-1:0]), .en(RdPtrEn), .clk(lsu_stbuf_c1_clk), .*);\n\n`ifdef RV_ASSERT_ON\n\n   assert_stbuf_overflow: assert #0 (stbuf_specvld_any[2:0] <= DEPTH);\n   property stbuf_wren_store_dccm;\n      @(posedge clk)  disable iff(~rst_l) (|stbuf_wr_en[DEPTH-1:0]) |-> (lsu_pkt_r.valid & lsu_pkt_r.store & addr_in_dccm_r);\n   endproperty\n   assert_stbuf_wren_store_dccm: assert property (stbuf_wren_store_dccm) else\n      $display(\"Illegal store buffer write\");\n\n`endif\n\nendmodule\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: LSU Trigger logic\n// Comments:\n//\n//********************************************************************************\nmodule el2_lsu_trigger\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )(\n   input el2_trigger_pkt_t [3:0] trigger_pkt_any,            // trigger packet from dec\n   input el2_lsu_pkt_t           lsu_pkt_m,                  // lsu packet\n   input logic [31:0]             lsu_addr_m,                 // address\n   input logic [31:0]             store_data_m,               // store data\n\n   output logic [3:0]             lsu_trigger_match_m         // match result\n);\n\n   logic               trigger_enable;\n   logic [3:0][31:0]  lsu_match_data;\n   logic [3:0]        lsu_trigger_data_match;\n   logic [31:0]       store_data_trigger_m;\n   logic [31:0]       ldst_addr_trigger_m;\n\n   // Generate the trigger enable (This is for power)\n   always_comb begin\n      trigger_enable = 1'b0;\n      for (int i=0; i<4; i++) begin\n         trigger_enable |= trigger_pkt_any[i].m;\n      end\n   end\n\n   assign store_data_trigger_m[31:0] = {({16{lsu_pkt_m.word}} & store_data_m[31:16]),({8{(lsu_pkt_m.half | lsu_pkt_m.word)}} & store_data_m[15:8]), store_data_m[7:0]} & {32{trigger_enable}};\n   assign ldst_addr_trigger_m[31:0]  = lsu_addr_m[31:0] & {32{trigger_enable}};\n\n\n   for (genvar i=0; i<4; i++) begin\n      assign lsu_match_data[i][31:0] = ({32{~trigger_pkt_any[i].select}} & ldst_addr_trigger_m[31:0]) |\n                                       ({32{trigger_pkt_any[i].select & trigger_pkt_any[i].store}} & store_data_trigger_m[31:0]);\n\n      rvmaskandmatch trigger_match (.mask(trigger_pkt_any[i].tdata2[31:0]), .data(lsu_match_data[i][31:0]), .masken(trigger_pkt_any[i].match), .match(lsu_trigger_data_match[i]));\n\n      assign lsu_trigger_match_m[i] = lsu_pkt_m.valid & ~lsu_pkt_m.dma & trigger_enable &\n                                        ((trigger_pkt_any[i].store & lsu_pkt_m.store) | (trigger_pkt_any[i].load & lsu_pkt_m.load & ~trigger_pkt_any[i].select)) &\n                                        lsu_trigger_data_match[i];\n   end\n\n\nendmodule // el2_lsu_trigger\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n// Copyright (c) 2023 Antmicro <www.antmicro.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\nmodule el2_mem\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n(\n   input logic         clk,\n   input logic         rst_l,\n   input logic         dccm_clk_override,\n   input logic         icm_clk_override,\n   input logic         dec_tlu_core_ecc_disable,\n\n   //DCCM ports\n   input logic         dccm_wren,\n   input logic         dccm_rden,\n   input logic [pt.DCCM_BITS-1:0]  dccm_wr_addr_lo,\n   input logic [pt.DCCM_BITS-1:0]  dccm_wr_addr_hi,\n   input logic [pt.DCCM_BITS-1:0]  dccm_rd_addr_lo,\n   input logic [pt.DCCM_BITS-1:0]  dccm_rd_addr_hi,\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_lo,\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_hi,\n\n\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_lo,\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_hi,\n\n   //ICCM ports\n   input logic [pt.ICCM_BITS-1:1]  iccm_rw_addr,\n   input logic                                        iccm_buf_correct_ecc,                    // ICCM is doing a single bit error correct cycle\n   input logic                                        iccm_correction_state,               // ICCM is doing a single bit error correct cycle\n   input logic         iccm_wren,\n   input logic         iccm_rden,\n   input logic [2:0]   iccm_wr_size,\n   input logic [77:0]  iccm_wr_data,\n\n   output logic [63:0] iccm_rd_data,\n   output logic [77:0] iccm_rd_data_ecc,\n\n   // Icache and Itag Ports\n\n   input  logic [31:1]  ic_rw_addr,\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]   ic_tag_valid,\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]   ic_wr_en,\n   input  logic         ic_rd_en,\n   input  logic [63:0] ic_premux_data,      // Premux data to be muxed with each way of the Icache.\n   input  logic         ic_sel_premux_data, // Premux data sel\n   input el2_ic_data_ext_in_pkt_t   [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]         ic_data_ext_in_pkt,\n   input el2_ic_tag_ext_in_pkt_t    [pt.ICACHE_NUM_WAYS-1:0]           ic_tag_ext_in_pkt,\n\n   input  logic [pt.ICACHE_BANKS_WAY-1:0][70:0]               ic_wr_data,         // Data to fill to the Icache. With ECC\n   input  logic [70:0]               ic_debug_wr_data,   // Debug wr cache.\n   output logic [70:0]               ic_debug_rd_data ,  // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [pt.ICACHE_INDEX_HI:3]               ic_debug_addr,      // Read/Write addresss to the Icache.\n   input  logic                      ic_debug_rd_en,     // Icache debug rd\n   input  logic                      ic_debug_wr_en,     // Icache debug wr\n   input  logic                      ic_debug_tag_array, // Debug tag array\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]                ic_debug_way,       // Debug way. Rd or Wr.\n\n   output logic [63:0]              ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   output logic [25:0]               ictag_debug_rd_data,// Debug icache tag.\n\n\n   output logic [pt.ICACHE_BANKS_WAY-1:0] ic_eccerr,    // ecc error per bank\n   output logic [pt.ICACHE_BANKS_WAY-1:0] ic_parerr,          // parity error per bank\n   output logic [pt.ICACHE_NUM_WAYS-1:0]   ic_rd_hit,\n   output logic         ic_tag_perr,        // Icache Tag parity error\n\n   el2_mem_if.veer_sram_src mem_export,\n\n   input  logic         scan_mode\n\n);\n\n   logic active_clk;\n   rvoclkhdr active_cg   ( .en(1'b1),         .l1clk(active_clk), .* );\n\n   el2_mem_if mem_export_local ();\n\n   assign mem_export      .clk = clk;\n   assign mem_export_local.clk = clk;\n\n   assign mem_export      .iccm_clken         = mem_export_local.iccm_clken;\n   assign mem_export      .iccm_wren_bank     = mem_export_local.iccm_wren_bank;\n   assign mem_export      .iccm_addr_bank     = mem_export_local.iccm_addr_bank;\n   assign mem_export      .iccm_bank_wr_data  = mem_export_local.iccm_bank_wr_data;\n   assign mem_export      .iccm_bank_wr_ecc   = mem_export_local.iccm_bank_wr_ecc;\n   assign mem_export_local.iccm_bank_dout     = mem_export.      iccm_bank_dout;\n   assign mem_export_local.iccm_bank_ecc      = mem_export.      iccm_bank_ecc;\n\n   assign mem_export      .dccm_clken         = mem_export_local.dccm_clken;\n   assign mem_export      .dccm_wren_bank     = mem_export_local.dccm_wren_bank;\n   assign mem_export      .dccm_addr_bank     = mem_export_local.dccm_addr_bank;\n   assign mem_export      .dccm_wr_data_bank  = mem_export_local.dccm_wr_data_bank;\n   assign mem_export      .dccm_wr_ecc_bank   = mem_export_local.dccm_wr_ecc_bank;\n   assign mem_export_local.dccm_bank_dout     = mem_export      .dccm_bank_dout;\n   assign mem_export_local.dccm_bank_ecc      = mem_export      .dccm_bank_ecc;\n\n   // DCCM Instantiation\n   if (pt.DCCM_ENABLE == 1) begin: Gen_dccm_enable\n      el2_lsu_dccm_mem #(.pt(pt)) dccm (\n         .clk_override(dccm_clk_override),\n         .dccm_mem_export(mem_export_local.veer_dccm),\n         .*\n      );\n   end else begin: Gen_dccm_disable\n      assign dccm_rd_data_lo = '0;\n      assign dccm_rd_data_hi = '0;\n   end\n\nif ( pt.ICACHE_ENABLE ) begin: icache\n   el2_ifu_ic_mem #(.pt(pt)) icm  (\n      .clk_override(icm_clk_override),\n      .*\n   );\nend\nelse  begin\n   assign   ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0] = '0;\n   assign   ic_tag_perr    = '0 ;\n   assign   ic_rd_data  = '0 ;\n   assign   ictag_debug_rd_data  = '0 ;\nend // else: !if( pt.ICACHE_ENABLE )\n\n\n\nif (pt.ICCM_ENABLE) begin : iccm\n   el2_ifu_iccm_mem  #(.pt(pt)) iccm (.*,\n                  .clk_override(icm_clk_override),\n                  .iccm_rw_addr(iccm_rw_addr[pt.ICCM_BITS-1:1]),\n                  .iccm_rd_data(iccm_rd_data[63:0]),\n                  .iccm_mem_export(mem_export_local.veer_iccm)\n                   );\nend\nelse  begin\n   assign  iccm_rd_data    = '0 ;\n   assign iccm_rd_data_ecc = '0 ;\nend\n\n\nendmodule\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n// Copyright 2022 Microsoft Corporation\n// Copyright (c) 2023 Antmicro <www.antmicro.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n\nimport el2_pkg::*;\ninterface el2_mem_if #(\n    `include \"el2_param.vh\"\n) ();\n  localparam DCCM_ECC_WIDTH = pt.DCCM_FDATA_WIDTH - pt.DCCM_DATA_WIDTH;\n\n  //////////////////////////////////////////\n  // Clock\n  logic                                                               clk;\n\n\n  //////////////////////////////////////////\n  // ICCM\n  logic [pt.ICCM_NUM_BANKS-1:0]                                       iccm_clken;\n  logic [pt.ICCM_NUM_BANKS-1:0]                                       iccm_wren_bank;\n  logic [pt.ICCM_NUM_BANKS-1:0][pt.ICCM_BITS-1:pt.ICCM_BANK_INDEX_LO] iccm_addr_bank;\n\n  logic [pt.ICCM_NUM_BANKS-1:0][                                31:0] iccm_bank_wr_data;\n  logic [pt.ICCM_NUM_BANKS-1:0][                                 6:0] iccm_bank_wr_ecc;\n  logic [pt.ICCM_NUM_BANKS-1:0][                                31:0] iccm_bank_dout;\n  logic [pt.ICCM_NUM_BANKS-1:0][                                 6:0] iccm_bank_ecc;\n\n\n  //////////////////////////////////////////\n  // DCCM\n  logic [pt.DCCM_NUM_BANKS-1:0]                                       dccm_clken;\n  logic [pt.DCCM_NUM_BANKS-1:0]                                       dccm_wren_bank;\n  logic [pt.DCCM_NUM_BANKS-1:0][pt.DCCM_BITS-1:(pt.DCCM_BANK_BITS+2)] dccm_addr_bank;\n  logic [pt.DCCM_NUM_BANKS-1:0][              pt.DCCM_DATA_WIDTH-1:0] dccm_wr_data_bank;\n  logic [pt.DCCM_NUM_BANKS-1:0][                  DCCM_ECC_WIDTH-1:0] dccm_wr_ecc_bank;\n  logic [pt.DCCM_NUM_BANKS-1:0][              pt.DCCM_DATA_WIDTH-1:0] dccm_bank_dout;\n  logic [pt.DCCM_NUM_BANKS-1:0][                  DCCM_ECC_WIDTH-1:0] dccm_bank_ecc;\n\n\n  //////////////////////////////////////////\n  // MODPORTS\n  modport veer_iccm(\n      input clk,\n      // ICCM\n      output iccm_clken, iccm_wren_bank, iccm_addr_bank, iccm_bank_wr_data, iccm_bank_wr_ecc,\n      input iccm_bank_dout, iccm_bank_ecc\n  );\n\n  modport veer_dccm(\n      input clk,\n      // DCCM\n      output dccm_clken, dccm_wren_bank, dccm_addr_bank, dccm_wr_data_bank, dccm_wr_ecc_bank,\n      input dccm_bank_dout, dccm_bank_ecc\n  );\n\n  modport veer_sram_src(\n      output clk,\n      // ICCM\n      output iccm_clken, iccm_wren_bank, iccm_addr_bank, iccm_bank_wr_data, iccm_bank_wr_ecc,\n      input iccm_bank_dout, iccm_bank_ecc,\n      // DCCM\n      output dccm_clken, dccm_wren_bank, dccm_addr_bank, dccm_wr_data_bank, dccm_wr_ecc_bank,\n      input dccm_bank_dout, dccm_bank_ecc\n  );\n\n  modport veer_sram_sink(\n      input clk,\n      // ICCM\n      input iccm_clken, iccm_wren_bank, iccm_addr_bank, iccm_bank_wr_data, iccm_bank_wr_ecc,\n      output iccm_bank_dout, iccm_bank_ecc,\n      // DCCM\n      input dccm_clken, dccm_wren_bank, dccm_addr_bank, dccm_wr_data_bank, dccm_wr_ecc_bank,\n      output dccm_bank_dout, dccm_bank_ecc\n  );\n\nendinterface\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n//********************************************************************************\n// Function: Programmable Interrupt Controller\n// Comments:\n//********************************************************************************\n\nmodule el2_pic_ctrl \nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n                  (\n\n                     input  logic                   clk,                  // Core clock\n                     input  logic                   free_clk,             // free clock\n                     input  logic                   rst_l,                // Reset for all flops\n                     input  logic                   clk_override,         // Clock over-ride for gating\n                     input  logic                   io_clk_override,      // PIC IO  Clock over-ride for gating\n                     input  logic [pt.PIC_TOTAL_INT_PLUS1-1:0]   extintsrc_req,  // Interrupt requests\n                     input  logic [31:0]            picm_rdaddr,          // Address of the register\n                     input  logic [31:0]            picm_wraddr,          // Address of the register\n                     input  logic [31:0]            picm_wr_data,         // Data to be written to the register\n                     input  logic                   picm_wren,            // Write enable to the register\n                     input  logic                   picm_rden,            // Read enable for the register\n                     input  logic                   picm_mken,            // Read the Mask for the register\n                     input  logic [3:0]             meicurpl,             // Current Priority Level\n                     input  logic [3:0]             meipt,                // Current Priority Threshold\n\n                     output logic                   mexintpend,           // External Inerrupt request to the core\n                     output logic [7:0]             claimid,              // Claim Id of the requested interrupt\n                     output logic [3:0]             pl,                   // Priority level of the requested interrupt\n                     output logic [31:0]            picm_rd_data,         // Read data of the register\n                     output logic                   mhwakeup,             // Wake-up interrupt request\n                     input  logic                   scan_mode             // scan mode\n\n);\n\nlocalparam NUM_LEVELS            = $clog2(pt.PIC_TOTAL_INT_PLUS1);\nlocalparam INTPRIORITY_BASE_ADDR = pt.PIC_BASE_ADDR ;\nlocalparam INTPEND_BASE_ADDR     = pt.PIC_BASE_ADDR + 32'h00001000 ;\nlocalparam INTENABLE_BASE_ADDR   = pt.PIC_BASE_ADDR + 32'h00002000 ;\nlocalparam EXT_INTR_PIC_CONFIG   = pt.PIC_BASE_ADDR + 32'h00003000 ;\nlocalparam EXT_INTR_GW_CONFIG    = pt.PIC_BASE_ADDR + 32'h00004000 ;\nlocalparam EXT_INTR_GW_CLEAR     = pt.PIC_BASE_ADDR + 32'h00005000 ;\n\n\nlocalparam INTPEND_SIZE          = (pt.PIC_TOTAL_INT_PLUS1 < 32)  ? 32  :\n                                   (pt.PIC_TOTAL_INT_PLUS1 < 64)  ? 64  :\n                                   (pt.PIC_TOTAL_INT_PLUS1 < 128) ? 128 :\n                                   (pt.PIC_TOTAL_INT_PLUS1 < 256) ? 256 :\n                                   (pt.PIC_TOTAL_INT_PLUS1 < 512) ? 512 :  1024 ;\n\nlocalparam INT_GRPS              =   INTPEND_SIZE / 32 ;\nlocalparam INTPRIORITY_BITS      =  4 ;\nlocalparam ID_BITS               =  8 ;\nlocalparam int GW_CONFIG[pt.PIC_TOTAL_INT_PLUS1-1:0] = '{default:0} ;\n\nlocalparam INT_ENABLE_GRPS       =   (pt.PIC_TOTAL_INT_PLUS1 - 1)  / 4 ;\n\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]           intenable_clk_enable ;\nlogic [INT_ENABLE_GRPS:0]                    intenable_clk_enable_grp ;\nlogic [INT_ENABLE_GRPS:0]                    gw_clk ;\n\nlogic  addr_intpend_base_match;\n\nlogic  raddr_config_pic_match ;\nlogic  raddr_intenable_base_match;\nlogic  raddr_intpriority_base_match;\nlogic  raddr_config_gw_base_match ;\n\nlogic  waddr_config_pic_match ;\nlogic  waddr_intpriority_base_match;\nlogic  waddr_intenable_base_match;\nlogic  waddr_config_gw_base_match ;\nlogic  addr_clear_gw_base_match ;\n\nlogic  mexintpend_in;\nlogic  mhwakeup_in ;\nlogic  intpend_reg_read ;\n\nlogic [31:0]                                 picm_rd_data_in, intpend_rd_out;\nlogic                                        intenable_rd_out ;\nlogic [INTPRIORITY_BITS-1:0]                 intpriority_rd_out;\nlogic [1:0]                                  gw_config_rd_out;\n\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0] [INTPRIORITY_BITS-1:0] intpriority_reg;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0] [INTPRIORITY_BITS-1:0] intpriority_reg_inv;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        intpriority_reg_we;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        intpriority_reg_re;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0] [1:0]                  gw_config_reg;\n\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        intenable_reg;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        intenable_reg_we;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        intenable_reg_re;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        gw_config_reg_we;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        gw_config_reg_re;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        gw_clear_reg_we;\n\nlogic [INTPEND_SIZE-1:0]                     intpend_reg_extended;\n\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0] [INTPRIORITY_BITS-1:0] intpend_w_prior_en;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0] [ID_BITS-1:0]          intpend_id;\nlogic [INTPRIORITY_BITS-1:0]                 maxint;\nlogic [INTPRIORITY_BITS-1:0]                 selected_int_priority;\nlogic [INT_GRPS-1:0] [31:0]                  intpend_rd_part_out ;\n\nlogic                                        config_reg;\nlogic                                        intpriord;\nlogic                                        config_reg_we ;\nlogic                                        config_reg_re ;\nlogic                                        config_reg_in ;\nlogic                                        prithresh_reg_write , prithresh_reg_read;\nlogic                                        intpriority_reg_read ;\nlogic                                        intenable_reg_read   ;\nlogic                                        gw_config_reg_read   ;\nlogic                                        picm_wren_ff , picm_rden_ff ;\nlogic [31:0]                                 picm_raddr_ff;\nlogic [31:0]                                 picm_waddr_ff;\nlogic [31:0]                                 picm_wr_data_ff;\nlogic [3:0]                                  mask;\nlogic                                        picm_mken_ff;\nlogic [ID_BITS-1:0]                          claimid_in ;\nlogic [INTPRIORITY_BITS-1:0]                 pl_in ;\nlogic [INTPRIORITY_BITS-1:0]                 pl_in_q ;\n\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        extintsrc_req_sync;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        extintsrc_req_gw;\n   logic                                                  picm_bypass_ff;\n\n// clkens\n   logic                                     pic_raddr_c1_clken;\n   logic                                     pic_waddr_c1_clken;\n   logic                                     pic_data_c1_clken;\n   logic                                     pic_pri_c1_clken;\n   logic                                     pic_int_c1_clken;\n   logic                                     gw_config_c1_clken;\n\n// clocks\n   logic                                     pic_raddr_c1_clk;\n   logic                                     pic_data_c1_clk;\n   logic                                     pic_pri_c1_clk;\n   logic                                     pic_int_c1_clk;\n   logic                                     gw_config_c1_clk;\n\n// ---- Clock gating section ------\n// c1 clock enables\n   assign pic_raddr_c1_clken  = picm_mken | picm_rden | clk_override;\n   assign pic_data_c1_clken   = picm_wren | clk_override;\n   assign pic_pri_c1_clken    = (waddr_intpriority_base_match & picm_wren_ff)  | (raddr_intpriority_base_match & picm_rden_ff) | clk_override;\n   assign pic_int_c1_clken    = (waddr_intenable_base_match   & picm_wren_ff)  | (raddr_intenable_base_match   & picm_rden_ff) | clk_override;\n   assign gw_config_c1_clken  = (waddr_config_gw_base_match   & picm_wren_ff)  | (raddr_config_gw_base_match   & picm_rden_ff) | clk_override;\n\n   // C1 - 1 clock pulse for data\n   rvoclkhdr pic_addr_c1_cgc   ( .en(pic_raddr_c1_clken),  .l1clk(pic_raddr_c1_clk), .* );\n   rvoclkhdr pic_data_c1_cgc   ( .en(pic_data_c1_clken),   .l1clk(pic_data_c1_clk), .* );\n   rvoclkhdr pic_pri_c1_cgc    ( .en(pic_pri_c1_clken),    .l1clk(pic_pri_c1_clk),  .* );\n   rvoclkhdr pic_int_c1_cgc    ( .en(pic_int_c1_clken),    .l1clk(pic_int_c1_clk),  .* );\n   rvoclkhdr gw_config_c1_cgc  ( .en(gw_config_c1_clken),  .l1clk(gw_config_c1_clk),  .* );\n\n// ------ end clock gating section ------------------------\n\nassign raddr_intenable_base_match   = (picm_raddr_ff[31:NUM_LEVELS+2] == INTENABLE_BASE_ADDR[31:NUM_LEVELS+2]) ;\nassign raddr_intpriority_base_match = (picm_raddr_ff[31:NUM_LEVELS+2] == INTPRIORITY_BASE_ADDR[31:NUM_LEVELS+2]) ;\nassign raddr_config_gw_base_match   = (picm_raddr_ff[31:NUM_LEVELS+2] == EXT_INTR_GW_CONFIG[31:NUM_LEVELS+2]) ;\nassign raddr_config_pic_match       = (picm_raddr_ff[31:0]            == EXT_INTR_PIC_CONFIG[31:0]) ;\n\nassign addr_intpend_base_match      = (picm_raddr_ff[31:6]            == INTPEND_BASE_ADDR[31:6]) ;\n\nassign waddr_config_pic_match       = (picm_waddr_ff[31:0]            == EXT_INTR_PIC_CONFIG[31:0]) ;\nassign addr_clear_gw_base_match     = (picm_waddr_ff[31:NUM_LEVELS+2] == EXT_INTR_GW_CLEAR[31:NUM_LEVELS+2]) ;\nassign waddr_intpriority_base_match = (picm_waddr_ff[31:NUM_LEVELS+2] == INTPRIORITY_BASE_ADDR[31:NUM_LEVELS+2]) ;\nassign waddr_intenable_base_match   = (picm_waddr_ff[31:NUM_LEVELS+2] == INTENABLE_BASE_ADDR[31:NUM_LEVELS+2]) ;\nassign waddr_config_gw_base_match   = (picm_waddr_ff[31:NUM_LEVELS+2] == EXT_INTR_GW_CONFIG[31:NUM_LEVELS+2]) ;\n\n   assign picm_bypass_ff = picm_rden_ff & picm_wren_ff & ( picm_raddr_ff[31:0] == picm_waddr_ff[31:0] );    // pic writes and reads to same address together\n\n\nrvdff #(32) picm_radd_flop  (.*, .din (picm_rdaddr),        .dout(picm_raddr_ff),         .clk(pic_raddr_c1_clk));\nrvdff #(32) picm_wadd_flop  (.*, .din (picm_wraddr),        .dout(picm_waddr_ff),         .clk(pic_data_c1_clk));\nrvdff  #(1) picm_wre_flop   (.*, .din (picm_wren),          .dout(picm_wren_ff),          .clk(free_clk));\nrvdff  #(1) picm_rde_flop   (.*, .din (picm_rden),          .dout(picm_rden_ff),          .clk(free_clk));\nrvdff  #(1) picm_mke_flop   (.*, .din (picm_mken),          .dout(picm_mken_ff),          .clk(free_clk));\nrvdff #(32) picm_dat_flop   (.*, .din (picm_wr_data[31:0]), .dout(picm_wr_data_ff[31:0]), .clk(pic_data_c1_clk));\n\n//rvsyncss  #(pt.PIC_TOTAL_INT_PLUS1-1) sync_inst\n//(\n// .clk (free_clk),\n// .dout(extintsrc_req_sync[pt.PIC_TOTAL_INT_PLUS1-1:1]),\n// .din (extintsrc_req[pt.PIC_TOTAL_INT_PLUS1-1:1]),\n// .*) ;\n//\n//assign extintsrc_req_sync[0] = extintsrc_req[0];\n/*\ngenvar p ;\nfor (p=0; p<=INT_ENABLE_GRPS ; p++) begin  : IO_CLK_GRP\n   if (p==INT_ENABLE_GRPS) begin : LAST_GRP\n       assign intenable_clk_enable_grp[p] = |intenable_clk_enable[pt.PIC_TOTAL_INT_PLUS1-1 : p*4] | io_clk_override;\n       rvoclkhdr intenable_c1_cgc   ( .en(intenable_clk_enable_grp[p]),  .l1clk(gw_clk[p]), .* );\n   end else begin :  CLK_GRPS\n       assign intenable_clk_enable_grp[p] = |intenable_clk_enable[p*4+3 : p*4] | io_clk_override;\n       rvoclkhdr intenable_c1_cgc   ( .en(intenable_clk_enable_grp[p]),  .l1clk(gw_clk[p]), .* );\n   end\nend\n*/\n\n\n\ngenvar i ;\ngenvar p ;\nfor (p=0; p<=INT_ENABLE_GRPS ; p++) begin  : IO_CLK_GRP\nwire grp_clk, grp_clken;\n\n    assign grp_clken = |intenable_clk_enable[(p==INT_ENABLE_GRPS?pt.PIC_TOTAL_INT_PLUS1-1:p*4+3) : p*4] | io_clk_override;\n\n  `ifndef RV_FPGA_OPTIMIZE\n    rvclkhdr intenable_c1_cgc( .en(grp_clken),  .l1clk(grp_clk), .* );\n  `else\n    assign gw_clk[p] = 1'b0 ;\n  `endif\n\n    for(genvar i= (p==0 ? 1: 0); i< (p==INT_ENABLE_GRPS ? pt.PIC_TOTAL_INT_PLUS1-p*4 :4); i++) begin : GW\n        el2_configurable_gw gw_inst(\n             .*,\n            .gw_clk(grp_clk),\n            .rawclk(clk),\n            .clken (grp_clken),\n            .extintsrc_req(extintsrc_req[i+p*4]) ,\n            .meigwctrl_polarity(gw_config_reg[i+p*4][0]) ,\n            .meigwctrl_type(gw_config_reg[i+p*4][1]) ,\n            .meigwclr(gw_clear_reg_we[i+p*4]) ,\n            .extintsrc_req_config(extintsrc_req_gw[i+p*4])\n        );\n    end\nend\n\n\n\n\n\n\n\n\nfor (i=0; i<pt.PIC_TOTAL_INT_PLUS1 ; i++) begin  : SETREG\n\n if (i > 0 ) begin : NON_ZERO_INT\n     assign intpriority_reg_we[i] =  waddr_intpriority_base_match & (picm_waddr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff;\n     assign intpriority_reg_re[i] =  raddr_intpriority_base_match & (picm_raddr_ff[NUM_LEVELS+1:2] == i) & picm_rden_ff;\n\n     assign intenable_reg_we[i]   =  waddr_intenable_base_match   & (picm_waddr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff;\n     assign intenable_reg_re[i]   =  raddr_intenable_base_match   & (picm_raddr_ff[NUM_LEVELS+1:2] == i) & picm_rden_ff;\n\n     assign gw_config_reg_we[i]   =  waddr_config_gw_base_match   & (picm_waddr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff;\n     assign gw_config_reg_re[i]   =  raddr_config_gw_base_match   & (picm_raddr_ff[NUM_LEVELS+1:2] == i) & picm_rden_ff;\n\n     assign gw_clear_reg_we[i]    =  addr_clear_gw_base_match     & (picm_waddr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff ;\n\n     rvdffs #(INTPRIORITY_BITS) intpriority_ff  (.*, .en( intpriority_reg_we[i]), .din (picm_wr_data_ff[INTPRIORITY_BITS-1:0]), .dout(intpriority_reg[i]), .clk(pic_pri_c1_clk));\n     rvdffs #(1)                 intenable_ff   (.*, .en( intenable_reg_we[i]),   .din (picm_wr_data_ff[0]),                    .dout(intenable_reg[i]),   .clk(pic_int_c1_clk));\n     rvdffs #(2)                 gw_config_ff   (.*, .en( gw_config_reg_we[i]),   .din (picm_wr_data_ff[1:0]),                  .dout(gw_config_reg[i]),   .clk(gw_config_c1_clk));\n\n     assign intenable_clk_enable[i]  =  gw_config_reg[i][1] | intenable_reg_we[i] | intenable_reg[i] | gw_clear_reg_we[i] ;\n\n/*\n     rvsyncss_fpga  #(1) sync_inst\n     (\n      .gw_clk      (gw_clk[i/4]),\n      .rawclk      (clk),\n      .clken       (intenable_clk_enable_grp[i/4]),\n      .dout        (extintsrc_req_sync[i]),\n      .din         (extintsrc_req[i]),\n      .*) ;\n\n\n\n\n\n        el2_configurable_gw config_gw_inst(.*,\n                                            .gw_clk(gw_clk[i/4]),\n                                            .rawclk(clk),\n                                            .clken (intenable_clk_enable_grp[i/4]),\n                                            .extintsrc_req_sync(extintsrc_req_sync[i]) ,\n                                            .meigwctrl_polarity(gw_config_reg[i][0]) ,\n                                            .meigwctrl_type(gw_config_reg[i][1]) ,\n                                            .meigwclr(gw_clear_reg_we[i]) ,\n                                            .extintsrc_req_config(extintsrc_req_gw[i])\n                                            );\n             */\n\n end else begin : INT_ZERO\n     assign intpriority_reg_we[i] =  1'b0 ;\n     assign intpriority_reg_re[i] =  1'b0 ;\n     assign intenable_reg_we[i]   =  1'b0 ;\n     assign intenable_reg_re[i]   =  1'b0 ;\n\n     assign gw_config_reg_we[i]   =  1'b0 ;\n     assign gw_config_reg_re[i]   =  1'b0 ;\n     assign gw_clear_reg_we[i]    =  1'b0 ;\n\n     assign gw_config_reg[i]    = '0 ;\n\n     assign intpriority_reg[i] = {INTPRIORITY_BITS{1'b0}} ;\n     assign intenable_reg[i]   = 1'b0 ;\n     assign extintsrc_req_gw[i] = 1'b0 ;\n     assign extintsrc_req_sync[i]    = 1'b0 ;\n     assign intenable_clk_enable[i] = 1'b0;\n end\n\n\n    assign intpriority_reg_inv[i] =  intpriord ? ~intpriority_reg[i] : intpriority_reg[i] ;\n\n    assign intpend_w_prior_en[i]  =  {INTPRIORITY_BITS{(extintsrc_req_gw[i] & intenable_reg[i])}} & intpriority_reg_inv[i] ;\n    assign intpend_id[i]          =  i ;\nend\n\n\n        assign pl_in[INTPRIORITY_BITS-1:0]                  =      selected_int_priority[INTPRIORITY_BITS-1:0] ;\n\n//if (pt.PIC_2CYCLE == 1) begin : genblock\n//end\n//else begin : genblock\n//end\n\n genvar l, m , j, k;\n\nif (pt.PIC_2CYCLE == 1) begin : genblock\n        logic [NUM_LEVELS/2:0] [pt.PIC_TOTAL_INT_PLUS1+2:0] [INTPRIORITY_BITS-1:0] level_intpend_w_prior_en;\n        logic [NUM_LEVELS/2:0] [pt.PIC_TOTAL_INT_PLUS1+2:0] [ID_BITS-1:0]          level_intpend_id;\n        logic [NUM_LEVELS:NUM_LEVELS/2] [(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2))+1:0] [INTPRIORITY_BITS-1:0] levelx_intpend_w_prior_en;\n        logic [NUM_LEVELS:NUM_LEVELS/2] [(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2))+1:0] [ID_BITS-1:0]          levelx_intpend_id;\n\n        assign level_intpend_w_prior_en[0][pt.PIC_TOTAL_INT_PLUS1+2:0] = {4'b0,4'b0,4'b0,intpend_w_prior_en[pt.PIC_TOTAL_INT_PLUS1-1:0]} ;\n        assign level_intpend_id[0][pt.PIC_TOTAL_INT_PLUS1+2:0]         = {8'b0,8'b0,8'b0,intpend_id[pt.PIC_TOTAL_INT_PLUS1-1:0]} ;\n\n        logic [(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2)):0] [INTPRIORITY_BITS-1:0] l2_intpend_w_prior_en_ff;\n        logic [(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2)):0] [ID_BITS-1:0]          l2_intpend_id_ff;\n\n        assign levelx_intpend_w_prior_en[NUM_LEVELS/2][(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2))+1:0] = {{1*INTPRIORITY_BITS{1'b0}},l2_intpend_w_prior_en_ff[(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2)):0]} ;\n        assign levelx_intpend_id[NUM_LEVELS/2][(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2))+1:0]         = {{1*ID_BITS{1'b1}},l2_intpend_id_ff[(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2)):0]} ;\n///  Do the prioritization of the interrupts here  ////////////\n for (l=0; l<NUM_LEVELS/2 ; l++) begin : TOP_LEVEL\n    for (m=0; m<=(pt.PIC_TOTAL_INT_PLUS1)/(2**(l+1)) ; m++) begin : COMPARE\n       if ( m == (pt.PIC_TOTAL_INT_PLUS1)/(2**(l+1))) begin\n            assign level_intpend_w_prior_en[l+1][m+1] = '0 ;\n            assign level_intpend_id[l+1][m+1]         = '0 ;\n       end\n       el2_cmp_and_mux  #(.ID_BITS(ID_BITS),\n                      .INTPRIORITY_BITS(INTPRIORITY_BITS)) cmp_l1 (\n                      .a_id(level_intpend_id[l][2*m]),\n                      .a_priority(level_intpend_w_prior_en[l][2*m]),\n                      .b_id(level_intpend_id[l][2*m+1]),\n                      .b_priority(level_intpend_w_prior_en[l][2*m+1]),\n                      .out_id(level_intpend_id[l+1][m]),\n                      .out_priority(level_intpend_w_prior_en[l+1][m])) ;\n\n    end\n end\n\n        for (i=0; i<=pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2) ; i++) begin : MIDDLE_FLOPS\n          rvdff #(INTPRIORITY_BITS) level2_intpend_prior_reg  (.*, .din (level_intpend_w_prior_en[NUM_LEVELS/2][i]), .dout(l2_intpend_w_prior_en_ff[i]),  .clk(free_clk));\n          rvdff #(ID_BITS)          level2_intpend_id_reg     (.*, .din (level_intpend_id[NUM_LEVELS/2][i]),         .dout(l2_intpend_id_ff[i]),          .clk(free_clk));\n        end\n\n for (j=NUM_LEVELS/2; j<NUM_LEVELS ; j++) begin : BOT_LEVELS\n    for (k=0; k<=(pt.PIC_TOTAL_INT_PLUS1)/(2**(j+1)) ; k++) begin : COMPARE\n       if ( k == (pt.PIC_TOTAL_INT_PLUS1)/(2**(j"}
{"text": "+1))) begin\n            assign levelx_intpend_w_prior_en[j+1][k+1] = '0 ;\n            assign levelx_intpend_id[j+1][k+1]         = '0 ;\n       end\n            el2_cmp_and_mux  #(.ID_BITS(ID_BITS),\n                        .INTPRIORITY_BITS(INTPRIORITY_BITS))\n                 cmp_l1 (\n                        .a_id(levelx_intpend_id[j][2*k]),\n                        .a_priority(levelx_intpend_w_prior_en[j][2*k]),\n                        .b_id(levelx_intpend_id[j][2*k+1]),\n                        .b_priority(levelx_intpend_w_prior_en[j][2*k+1]),\n                        .out_id(levelx_intpend_id[j+1][k]),\n                        .out_priority(levelx_intpend_w_prior_en[j+1][k])) ;\n    end\n  end\n        assign claimid_in[ID_BITS-1:0]                      =      levelx_intpend_id[NUM_LEVELS][0] ;   // This is the last level output\n        assign selected_int_priority[INTPRIORITY_BITS-1:0]  =      levelx_intpend_w_prior_en[NUM_LEVELS][0] ;\nend\nelse begin : genblock\n\n        logic [NUM_LEVELS:0] [pt.PIC_TOTAL_INT_PLUS1+1:0] [INTPRIORITY_BITS-1:0] level_intpend_w_prior_en;\n        logic [NUM_LEVELS:0] [pt.PIC_TOTAL_INT_PLUS1+1:0] [ID_BITS-1:0]          level_intpend_id;\n\n        assign level_intpend_w_prior_en[0][pt.PIC_TOTAL_INT_PLUS1+1:0] = {{2*INTPRIORITY_BITS{1'b0}},intpend_w_prior_en[pt.PIC_TOTAL_INT_PLUS1-1:0]} ;\n        assign level_intpend_id[0][pt.PIC_TOTAL_INT_PLUS1+1:0] = {{2*ID_BITS{1'b1}},intpend_id[pt.PIC_TOTAL_INT_PLUS1-1:0]} ;\n\n///  Do the prioritization of the interrupts here  ////////////\n// genvar l, m , j, k;  already declared outside ifdef\n for (l=0; l<NUM_LEVELS ; l++) begin : LEVEL\n    for (m=0; m<=(pt.PIC_TOTAL_INT_PLUS1)/(2**(l+1)) ; m++) begin : COMPARE\n       if ( m == (pt.PIC_TOTAL_INT_PLUS1)/(2**(l+1))) begin\n            assign level_intpend_w_prior_en[l+1][m+1] = '0 ;\n            assign level_intpend_id[l+1][m+1]         = '0 ;\n       end\n       el2_cmp_and_mux  #(.ID_BITS(ID_BITS),\n                      .INTPRIORITY_BITS(INTPRIORITY_BITS)) cmp_l1 (\n                      .a_id(level_intpend_id[l][2*m]),\n                      .a_priority(level_intpend_w_prior_en[l][2*m]),\n                      .b_id(level_intpend_id[l][2*m+1]),\n                      .b_priority(level_intpend_w_prior_en[l][2*m+1]),\n                      .out_id(level_intpend_id[l+1][m]),\n                      .out_priority(level_intpend_w_prior_en[l+1][m])) ;\n\n    end\n end\n        assign claimid_in[ID_BITS-1:0]                      =      level_intpend_id[NUM_LEVELS][0] ;   // This is the last level output\n        assign selected_int_priority[INTPRIORITY_BITS-1:0]  =      level_intpend_w_prior_en[NUM_LEVELS][0] ;\n\nend\n\n\n\n///////////////////////////////////////////////////////////////////////\n// Config Reg`\n///////////////////////////////////////////////////////////////////////\nassign config_reg_we               =  waddr_config_pic_match & picm_wren_ff;\nassign config_reg_re               =  raddr_config_pic_match & picm_rden_ff;\n\nassign config_reg_in  =  picm_wr_data_ff[0] ;   //\nrvdffs #(1) config_reg_ff  (.*, .clk(free_clk), .en(config_reg_we), .din (config_reg_in), .dout(config_reg));\n\nassign intpriord  = config_reg ;\n\n\n\n//////////////////////////////////////////////////////////////////////////\n// Send the interrupt to the core if it is above the thresh-hold\n//////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n/// ClaimId  Reg and Corresponding PL\n///////////////////////////////////////////////////////////\n//\nassign pl_in_q[INTPRIORITY_BITS-1:0] = intpriord ? ~pl_in : pl_in ;\nrvdff #(ID_BITS)          claimid_ff  (.*,  .din (claimid_in[ID_BITS-1:00]),     .dout(claimid[ID_BITS-1:00]),    .clk(free_clk));\nrvdff  #(INTPRIORITY_BITS) pl_ff      (.*, .din (pl_in_q[INTPRIORITY_BITS-1:0]), .dout(pl[INTPRIORITY_BITS-1:0]), .clk(free_clk));\n\nlogic [INTPRIORITY_BITS-1:0] meipt_inv , meicurpl_inv ;\nassign meipt_inv[INTPRIORITY_BITS-1:0]    = intpriord ? ~meipt[INTPRIORITY_BITS-1:0]    : meipt[INTPRIORITY_BITS-1:0] ;\nassign meicurpl_inv[INTPRIORITY_BITS-1:0] = intpriord ? ~meicurpl[INTPRIORITY_BITS-1:0] : meicurpl[INTPRIORITY_BITS-1:0] ;\nassign mexintpend_in = (( selected_int_priority[INTPRIORITY_BITS-1:0] > meipt_inv[INTPRIORITY_BITS-1:0]) &\n                        ( selected_int_priority[INTPRIORITY_BITS-1:0] > meicurpl_inv[INTPRIORITY_BITS-1:0]) );\nrvdff #(1) mexintpend_ff  (.*, .clk(free_clk), .din (mexintpend_in), .dout(mexintpend));\n\nassign maxint[INTPRIORITY_BITS-1:0]      =  intpriord ? 0 : 15 ;\nassign mhwakeup_in = ( pl_in_q[INTPRIORITY_BITS-1:0] == maxint) ;\nrvdff #(1) wake_up_ff  (.*, .clk(free_clk), .din (mhwakeup_in), .dout(mhwakeup));\n\n\n\n\n\n//////////////////////////////////////////////////////////////////////////\n//  Reads of register.\n//  1- intpending\n//////////////////////////////////////////////////////////////////////////\n\nassign intpend_reg_read     =  addr_intpend_base_match      & picm_rden_ff ;\nassign intpriority_reg_read =  raddr_intpriority_base_match & picm_rden_ff;\nassign intenable_reg_read   =  raddr_intenable_base_match   & picm_rden_ff;\nassign gw_config_reg_read   =  raddr_config_gw_base_match   & picm_rden_ff;\n\nassign intpend_reg_extended[INTPEND_SIZE-1:0]  = {{INTPEND_SIZE-pt.PIC_TOTAL_INT_PLUS1{1'b0}},extintsrc_req_gw[pt.PIC_TOTAL_INT_PLUS1-1:0]} ;\n\n   for (i=0; i<(INT_GRPS); i++) begin\n            assign intpend_rd_part_out[i] =  (({32{intpend_reg_read & picm_raddr_ff[5:2] == i}}) & intpend_reg_extended[((32*i)+31):(32*i)]) ;\n   end\n\n   always_comb begin : INTPEND_RD\n         intpend_rd_out =  '0 ;\n         for (int i=0; i<INT_GRPS; i++) begin\n               intpend_rd_out |=  intpend_rd_part_out[i] ;\n         end\n   end\n\n   always_comb begin : INTEN_RD\n         intenable_rd_out =  '0 ;\n         intpriority_rd_out =  '0 ;\n         gw_config_rd_out =  '0 ;\n         for (int i=0; i<pt.PIC_TOTAL_INT_PLUS1; i++) begin\n              if (intenable_reg_re[i]) begin\n               intenable_rd_out    =  intenable_reg[i]  ;\n              end\n              if (intpriority_reg_re[i]) begin\n               intpriority_rd_out  =  intpriority_reg[i] ;\n              end\n              if (gw_config_reg_re[i]) begin\n               gw_config_rd_out  =  gw_config_reg[i] ;\n              end\n         end\n   end\n\n\n assign picm_rd_data_in[31:0] = ({32{intpend_reg_read      }} &   intpend_rd_out                                                    ) |\n                                ({32{intpriority_reg_read  }} &  {{32-INTPRIORITY_BITS{1'b0}}, intpriority_rd_out                 } ) |\n                                ({32{intenable_reg_read    }} &  {31'b0 , intenable_rd_out                                        } ) |\n                                ({32{gw_config_reg_read    }} &  {30'b0 , gw_config_rd_out                                        } ) |\n                                ({32{config_reg_re         }} &  {31'b0 , config_reg                                              } ) |\n                                ({32{picm_mken_ff & mask[3]}} &  {30'b0 , 2'b11                                                   } ) |\n                                ({32{picm_mken_ff & mask[2]}} &  {31'b0 , 1'b1                                                    } ) |\n                                ({32{picm_mken_ff & mask[1]}} &  {28'b0 , 4'b1111                                                 } ) |\n                                ({32{picm_mken_ff & mask[0]}} &   32'b0                                                             ) ;\n\n\nassign picm_rd_data[31:0] = picm_bypass_ff ? picm_wr_data_ff[31:0] : picm_rd_data_in[31:0] ;\n\nlogic [14:0] address;\n\nassign address[14:0] = picm_raddr_ff[14:0];\n\n`include \"pic_map_auto.h\"\n\nendmodule\n\n\nmodule el2_cmp_and_mux #(parameter ID_BITS=8,\n                               INTPRIORITY_BITS = 4)\n                    (\n                        input  logic [ID_BITS-1:0]       a_id,\n                        input  logic [INTPRIORITY_BITS-1:0] a_priority,\n\n                        input  logic [ID_BITS-1:0]       b_id,\n                        input  logic [INTPRIORITY_BITS-1:0] b_priority,\n\n                        output logic [ID_BITS-1:0]       out_id,\n                        output logic [INTPRIORITY_BITS-1:0] out_priority\n\n                    );\n\nlogic   a_is_lt_b ;\n\nassign  a_is_lt_b  = ( a_priority[INTPRIORITY_BITS-1:0] < b_priority[INTPRIORITY_BITS-1:0] ) ;\n\nassign  out_id[ID_BITS-1:0]                = a_is_lt_b ? b_id[ID_BITS-1:0] :\n                                                         a_id[ID_BITS-1:0] ;\nassign  out_priority[INTPRIORITY_BITS-1:0] = a_is_lt_b ? b_priority[INTPRIORITY_BITS-1:0] :\n                                                         a_priority[INTPRIORITY_BITS-1:0] ;\nendmodule // cmp_and_mux\n\n\nmodule el2_configurable_gw (\n                             input logic gw_clk,\n                             input logic rawclk,\n                             input logic clken,\n                             input logic rst_l,\n                             input logic extintsrc_req ,\n                             input logic meigwctrl_polarity ,\n                             input logic meigwctrl_type ,\n                             input logic meigwclr ,\n\n                             output logic extintsrc_req_config\n                            );\n\n\n  logic  gw_int_pending_in, gw_int_pending, extintsrc_req_sync;\n\n  rvsyncss_fpga  #(1) sync_inst (\n      .dout        (extintsrc_req_sync),\n      .din         (extintsrc_req),\n      .*) ;\n\n\n  assign gw_int_pending_in =  (extintsrc_req_sync ^ meigwctrl_polarity) | (gw_int_pending & ~meigwclr) ;\n  rvdff_fpga #(1) int_pend_ff        (.*, .clk(gw_clk), .rawclk(rawclk), .clken(clken), .din (gw_int_pending_in),     .dout(gw_int_pending));\n\n\n  assign extintsrc_req_config =  meigwctrl_type ? ((extintsrc_req_sync ^  meigwctrl_polarity) | gw_int_pending) : (extintsrc_req_sync ^  meigwctrl_polarity) ;\n\nendmodule // configurable_gw\n\n\n\n\n\n\n\n\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright lowRISC contributors.\n// Copyright 2023 Antmicro, Ltd. <www.antmicro.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmodule el2_pmp\n  import el2_pkg::*;\n#(\n    parameter PMP_CHANNELS = 3,\n    // Granularity of NAPOT access,\n    // 0 = No restriction, 1 = 8 byte, 2 = 16 byte, 3 = 32 byte, etc.\n    parameter PMP_GRANULARITY = 0,  // TODO: Move to veer.config\n    `include \"el2_param.vh\"\n) (\n    input logic clk,       // Top level clock\n    input logic rst_l,     // Reset\n    input logic scan_mode, // Scan mode\n\n    input el2_pmp_cfg_pkt_t        pmp_pmpcfg [pt.PMP_ENTRIES],\n    input logic             [31:0] pmp_pmpaddr[pt.PMP_ENTRIES],\n\n    input  logic              [31:0] pmp_chan_addr[PMP_CHANNELS],\n    input  el2_pmp_type_pkt_t        pmp_chan_type[PMP_CHANNELS],\n    output logic                     pmp_chan_err [PMP_CHANNELS]\n);\n\n  logic [                33:0]                     csr_pmp_addr_i          [pt.PMP_ENTRIES];\n  logic [                33:0]                     pmp_req_addr_i          [  PMP_CHANNELS];\n\n  logic [                33:0]                     region_start_addr       [pt.PMP_ENTRIES];\n  logic [33:PMP_GRANULARITY+2]                     region_addr_mask        [pt.PMP_ENTRIES];\n  logic [    PMP_CHANNELS-1:0][pt.PMP_ENTRIES-1:0] region_match_gt;\n  logic [    PMP_CHANNELS-1:0][pt.PMP_ENTRIES-1:0] region_match_lt;\n  logic [    PMP_CHANNELS-1:0][pt.PMP_ENTRIES-1:0] region_match_eq;\n  logic [    PMP_CHANNELS-1:0][pt.PMP_ENTRIES-1:0] region_match_all;\n  logic [    PMP_CHANNELS-1:0][pt.PMP_ENTRIES-1:0] region_basic_perm_check;\n  logic [    PMP_CHANNELS-1:0][pt.PMP_ENTRIES-1:0] region_perm_check;\n\n  ///////////////////////\n  // Functions for PMP //\n  ///////////////////////\n\n  // Flow of the PMP checking operation follows as below\n  //\n  // basic_perm_check ---> perm_check_wrapper ---> orig_perm_check ---/\n  //                                                                  |\n  // region_match_all -----------------> access_fault_check <----------\n  //                                             |\n  //                                             \\--> pmp_chan_err\n\n  // A wrapper function in which it is decided which form of permission check function gets called\n  function automatic logic perm_check_wrapper(el2_pmp_cfg_pkt_t csr_pmp_cfg,\n                                              logic permission_check);\n    return orig_perm_check(csr_pmp_cfg.lock, permission_check);\n  endfunction\n\n  // Compute permissions checks that apply when MSECCFG.MML is unset. This is the original PMP\n  // behaviour before Smepmp was added.\n  function automatic logic orig_perm_check(logic pmp_cfg_lock, logic permission_check);\n    return (~pmp_cfg_lock | permission_check);\n    // For M-mode, any region which matches with the L-bit clear, or with sufficient\n    // access permissions will be allowed\n  endfunction\n\n  // Access fault determination / prioritization\n  function automatic logic access_fault_check(logic [pt.PMP_ENTRIES-1:0] match_all,\n                                              logic [pt.PMP_ENTRIES-1:0] final_perm_check);\n\n\n    // When MSECCFG.MMWP is set default deny always, otherwise allow for M-mode, deny for other\n    // modes. Also deny unmatched for M-mode whe MSECCFG.MML is set and request type is EXEC.\n    logic access_fail = 1'b0;\n    logic matched = 1'b0;\n\n    // PMP entries are statically prioritized, from 0 to N-1\n    // The lowest-numbered PMP entry which matches an address determines accessibility\n    for (int r = 0; r < pt.PMP_ENTRIES; r++) begin\n      if (!matched && match_all[r]) begin\n        access_fail = ~final_perm_check[r];\n        matched = 1'b1;\n      end\n    end\n    return access_fail;\n  endfunction\n\n  // ---------------\n  // Access checking\n  // ---------------\n\n  for (genvar r = 0; r < pt.PMP_ENTRIES; r++) begin : g_addr_exp\n    assign csr_pmp_addr_i[r] = {\n      pmp_pmpaddr[r], 2'b00\n    };  // addr conv.: word @ 32-bit -> byte @ 34-bit\n    // Start address for TOR matching\n    if (r == 0) begin : g_entry0\n      assign region_start_addr[r] = (pmp_pmpcfg[r].mode == TOR) ? 34'h000000000 : csr_pmp_addr_i[r];\n    end else begin : g_oth\n      assign region_start_addr[r] = (pmp_pmpcfg[r].mode == TOR) ? csr_pmp_addr_i[r-1] :\n                                                                  csr_pmp_addr_i[r];\n    end\n    // Address mask for NA matching\n    for (genvar b = PMP_GRANULARITY + 2; b < 34; b++) begin : g_bitmask\n      if (b == 2) begin : g_bit0\n        // Always mask bit 2 for NAPOT\n        assign region_addr_mask[r][b] = (pmp_pmpcfg[r].mode != NAPOT);\n      end else begin : g_others\n        // We will mask this bit if it is within the programmed granule\n        // i.e. addr = yyyy 0111\n        //                  ^\n        //                  | This bit pos is the top of the mask, all lower bits set\n        // thus mask = 1111 0000\n        if (PMP_GRANULARITY == 0) begin : g_region_addr_mask_zero_granularity\n          assign region_addr_mask[r][b] = (pmp_pmpcfg[r].mode != NAPOT) |\n                                          ~&csr_pmp_addr_i[r][b-1:2];\n        end else begin : g_region_addr_mask_other_granularity\n          assign region_addr_mask[r][b] = (pmp_pmpcfg[r].mode != NAPOT) |\n                                          ~&csr_pmp_addr_i[r][b-1:PMP_GRANULARITY+1];\n        end\n      end\n    end\n  end\n\n  for (genvar c = 0; c < PMP_CHANNELS; c++) begin : g_access_check\n    assign pmp_req_addr_i[c] = {2'b00, pmp_chan_addr[c]};  // addr. widening: 32-bit -> 34-bit\n    for (genvar r = 0; r < pt.PMP_ENTRIES; r++) begin : g_regions\n      // Comparators are sized according to granularity\n      assign region_match_eq[c][r] = (pmp_req_addr_i[c][33:PMP_GRANULARITY+2] &\n                                      region_addr_mask[r]) ==\n                                     (region_start_addr[r][33:PMP_GRANULARITY+2] &\n                                      region_addr_mask[r]);\n      assign region_match_gt[c][r] = pmp_req_addr_i[c][33:PMP_GRANULARITY+2] >\n                                     region_start_addr[r][33:PMP_GRANULARITY+2];\n      assign region_match_lt[c][r] = pmp_req_addr_i[c][33:PMP_GRANULARITY+2] <\n                                     csr_pmp_addr_i[r][33:PMP_GRANULARITY+2];\n\n      always_comb begin\n        region_match_all[c][r] = 1'b0;\n        unique case (pmp_pmpcfg[r].mode)\n          OFF:     region_match_all[c][r] = 1'b0;\n          NA4:     region_match_all[c][r] = region_match_eq[c][r];\n          NAPOT:   region_match_all[c][r] = region_match_eq[c][r];\n          TOR: begin\n            region_match_all[c][r] = (region_match_eq[c][r] | region_match_gt[c][r]) &\n                                     region_match_lt[c][r];\n          end\n          default: region_match_all[c][r] = 1'b0;\n        endcase\n      end\n\n      // Basic permission check compares cfg register only.\n      assign region_basic_perm_check[c][r] =\n          ((pmp_chan_type[c] == EXEC)  & pmp_pmpcfg[r].execute) |\n          ((pmp_chan_type[c] == WRITE) & pmp_pmpcfg[r].write) |\n          ((pmp_chan_type[c] == READ)  & pmp_pmpcfg[r].read);\n\n      // Check specific required permissions since the behaviour is different\n      // between Smepmp implementation and original PMP.\n      assign region_perm_check[c][r] = perm_check_wrapper(\n          pmp_pmpcfg[r], region_basic_perm_check[c][r]\n      );\n\n      // Address bits below PMP granularity (which starts at 4 byte) are deliberately unused.\n      logic unused_sigs;\n      assign unused_sigs = ^{region_start_addr[r][PMP_GRANULARITY+2-1:0],\n                             pmp_req_addr_i[c][PMP_GRANULARITY+2-1:0]};\n    end\n\n    // Once the permission checks of the regions are done, decide if the access is\n    // denied by figuring out the matching region and its permission check.\n    assign pmp_chan_err[c] = access_fault_check(region_match_all[c], region_perm_check[c]);\n  end\n\nendmodule  // el2_pmp\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n// Function: Top level VeeR core file\n// Comments:\n//\n//********************************************************************************\nmodule el2_veer\nimport el2_pkg::*;\n#(\n`include \"el2_param.vh\"\n )\n  (\n   input logic                  clk,\n   input logic                  rst_l,\n   input logic                  dbg_rst_l,\n   input logic [31:1]           rst_vec,\n   input logic                  nmi_int,\n   input logic [31:1]           nmi_vec,\n   output logic                 core_rst_l,   // This is \"rst_l | dbg_rst_l\"\n\n   output logic                 active_l2clk,\n   output logic                 free_l2clk,\n\n   output logic [31:0] trace_rv_i_insn_ip,\n   output logic [31:0] trace_rv_i_address_ip,\n   output logic   trace_rv_i_valid_ip,\n   output logic   trace_rv_i_exception_ip,\n   output logic [4:0]  trace_rv_i_ecause_ip,\n   output logic   trace_rv_i_interrupt_ip,\n   output logic [31:0] trace_rv_i_tval_ip,\n\n\n   output logic                 dccm_clk_override,\n   output logic                 icm_clk_override,\n   output logic                 dec_tlu_core_ecc_disable,\n\n   // external halt/run interface\n   input logic  i_cpu_halt_req,    // Asynchronous Halt request to CPU\n   input logic  i_cpu_run_req,     // Asynchronous Restart request to CPU\n   output logic o_cpu_halt_ack,    // Core Acknowledge to Halt request\n   output logic o_cpu_halt_status, // 1'b1 indicates processor is halted\n   output logic o_cpu_run_ack,     // Core Acknowledge to run request\n   output logic o_debug_mode_status, // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n\n   input logic [31:4] core_id, // CORE ID\n\n   // external MPC halt/run interface\n   input logic mpc_debug_halt_req, // Async halt request\n   input logic mpc_debug_run_req, // Async run request\n   input logic mpc_reset_run_req, // Run/halt after reset\n   output logic mpc_debug_halt_ack, // Halt ack\n   output logic mpc_debug_run_ack, // Run ack\n   output logic debug_brkpt_status, // debug breakpoint\n\n   output logic dec_tlu_perfcnt0, // toggles when slot0 perf counter 0 has an event inc\n   output logic dec_tlu_perfcnt1,\n   output logic dec_tlu_perfcnt2,\n   output logic dec_tlu_perfcnt3,\n\n   // DCCM ports\n   output logic                          dccm_wren,\n   output logic                          dccm_rden,\n   output logic [pt.DCCM_BITS-1:0]          dccm_wr_addr_lo,\n   output logic [pt.DCCM_BITS-1:0]          dccm_wr_addr_hi,\n   output logic [pt.DCCM_BITS-1:0]          dccm_rd_addr_lo,\n   output logic [pt.DCCM_BITS-1:0]          dccm_rd_addr_hi,\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]   dccm_wr_data_lo,\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]   dccm_wr_data_hi,\n\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]    dccm_rd_data_lo,\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]    dccm_rd_data_hi,\n\n   // ICCM ports\n   output logic [pt.ICCM_BITS-1:1]           iccm_rw_addr,\n   output logic                  iccm_wren,\n   output logic                  iccm_rden,\n   output logic [2:0]            iccm_wr_size,\n   output logic [77:0]           iccm_wr_data,\n   output logic                  iccm_buf_correct_ecc,\n   output logic                  iccm_correction_state,\n\n   input  logic [63:0]          iccm_rd_data,\n   input  logic [77:0]           iccm_rd_data_ecc,\n\n   // ICache , ITAG  ports\n   output logic [31:1]           ic_rw_addr,\n   output logic [pt.ICACHE_NUM_WAYS-1:0]            ic_tag_valid,\n   output logic [pt.ICACHE_NUM_WAYS-1:0]            ic_wr_en,\n   output logic                  ic_rd_en,\n\n   output logic [pt.ICACHE_BANKS_WAY-1:0][70:0]               ic_wr_data,         // Data to fill to the Icache. With ECC\n   input  logic [63:0]               ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [70:0]               ic_debug_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [25:0]               ictag_debug_rd_data,// Debug icache tag.\n   output logic [70:0]               ic_debug_wr_data,   // Debug wr cache.\n\n   input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_eccerr,\n   input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_parerr,\n   output logic [63:0]               ic_premux_data,     // Premux data to be muxed with each way of the Icache.\n   output logic                      ic_sel_premux_data, // Select premux data\n\n\n   output logic [pt.ICACHE_INDEX_HI:3]               ic_debug_addr,      // Read/Write addresss to the Icache.\n   output logic                      ic_debug_rd_en,     // Icache debug rd\n   output logic                      ic_debug_wr_en,     // Icache debug wr\n   output logic                      ic_debug_tag_array, // Debug tag array\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_debug_way,       // Debug way. Rd or Wr.\n\n\n\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]            ic_rd_hit,\n   input  logic                  ic_tag_perr,        // Icache Tag parity error\n\n   //-------------------------- LSU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            lsu_axi_awvalid,\n   input  logic                            lsu_axi_awready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_awid,\n   output logic [31:0]                     lsu_axi_awaddr,\n   output logic [3:0]                      lsu_axi_awregion,\n   output logic [7:0]                      lsu_axi_awlen,\n   output logic [2:0]                      lsu_axi_awsize,\n   output logic [1:0]                      lsu_axi_awburst,\n   output logic                            lsu_axi_awlock,\n   output logic [3:0]                      lsu_axi_awcache,\n   output logic [2:0]                      lsu_axi_awprot,\n   output logic [3:0]                      lsu_axi_awqos,\n\n   output logic                            lsu_axi_wvalid,\n   input  logic                            lsu_axi_wready,\n   output logic [63:0]                     lsu_axi_wdata,\n   output logic [7:0]                      lsu_axi_wstrb,\n   output logic                            lsu_axi_wlast,\n\n   input  logic                            lsu_axi_bvalid,\n   output logic                            lsu_axi_bready,\n   input  logic [1:0]                      lsu_axi_bresp,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_bid,\n\n   // AXI Read Channels\n   output logic                            lsu_axi_arvalid,\n   input  logic                            lsu_axi_arready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_arid,\n   output logic [31:0]                     lsu_axi_araddr,\n   output logic [3:0]                      lsu_axi_arregion,\n   output logic [7:0]                      lsu_axi_arlen,\n   output logic [2:0]                      lsu_axi_arsize,\n   output logic [1:0]                      lsu_axi_arburst,\n   output logic                            lsu_axi_arlock,\n   output logic [3:0]                      lsu_axi_arcache,\n   output logic [2:0]                      lsu_axi_arprot,\n   output logic [3:0]                      lsu_axi_arqos,\n\n   input  logic                            lsu_axi_rvalid,\n   output logic                            lsu_axi_rready,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_rid,\n   input  logic [63:0]                     lsu_axi_rdata,\n   input  logic [1:0]                      lsu_axi_rresp,\n   input  logic                            lsu_axi_rlast,\n\n   //-------------------------- IFU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            ifu_axi_awvalid,\n   input  logic                            ifu_axi_awready,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_awid,\n   output logic [31:0]                     ifu_axi_awaddr,\n   output logic [3:0]                      ifu_axi_awregion,\n   output logic [7:0]                      ifu_axi_awlen,\n   output logic [2:0]                      ifu_axi_awsize,\n   output logic [1:0]                      ifu_axi_awburst,\n   output logic                            ifu_axi_awlock,\n   output logic [3:0]                      ifu_axi_awcache,\n   output logic [2:0]                      ifu_axi_awprot,\n   output logic [3:0]                      ifu_axi_awqos,\n\n   output logic                            ifu_axi_wvalid,\n   input  logic                            ifu_axi_wready,\n   output logic [63:0]                     ifu_axi_wdata,\n   output logic [7:0]                      ifu_axi_wstrb,\n   output logic                            ifu_axi_wlast,\n\n   input  logic                            ifu_axi_bvalid,\n   output logic                            ifu_axi_bready,\n   input  logic [1:0]                      ifu_axi_bresp,\n   input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_bid,\n\n   // AXI Read Channels\n   output logic                            ifu_axi_arvalid,\n   input  logic                            ifu_axi_arready,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_arid,\n   output logic [31:0]                     ifu_axi_araddr,\n   output logic [3:0]                      ifu_axi_arregion,\n   output logic [7:0]                      ifu_axi_arlen,\n   output logic [2:0]                      ifu_axi_arsize,\n   output logic [1:0]                      ifu_axi_arburst,\n   output logic                            ifu_axi_arlock,\n   output logic [3:0]                      ifu_axi_arcache,\n   output logic [2:0]                      ifu_axi_arprot,\n   output logic [3:0]                      ifu_axi_arqos,\n\n   input  logic                            ifu_axi_rvalid,\n   output logic                            ifu_axi_rready,\n   input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_rid,\n   input  logic [63:0]                     ifu_axi_rdata,\n   input  logic [1:0]                      ifu_axi_rresp,\n   input  logic                            ifu_axi_rlast,\n\n   //-------------------------- SB AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            sb_axi_awvalid,\n   input  logic                            sb_axi_awready,\n   output logic [pt.SB_BUS_TAG-1:0]        sb_axi_awid,\n   output logic [31:0]                     sb_axi_awaddr,\n   output logic [3:0]                      sb_axi_awregion,\n   output logic [7:0]                      sb_axi_awlen,\n   output logic [2:0]                      sb_axi_awsize,\n   output logic [1:0]                      sb_axi_awburst,\n   output logic                            sb_axi_awlock,\n   output logic [3:0]                      sb_axi_awcache,\n   output logic [2:0]                      sb_axi_awprot,\n   output logic [3:0]                      sb_axi_awqos,\n\n   output logic                            sb_axi_wvalid,\n   input  logic                            sb_axi_wready,\n   output logic [63:0]                     sb_axi_wdata,\n   output logic [7:0]                      sb_axi_wstrb,\n   output logic                            sb_axi_wlast,\n\n   input  logic                            sb_axi_bvalid,\n   output logic                            sb_axi_bready,\n   input  logic [1:0]                      sb_axi_bresp,\n   input  logic [pt.SB_BUS_TAG-1:0]        sb_axi_bid,\n\n   // AXI Read Channels\n   output logic                            sb_axi_arvalid,\n   input  logic                            sb_axi_arready,\n   output logic [pt.SB_BUS_TAG-1:0]        sb_axi_arid,\n   output logic [31:0]                     sb_axi_araddr,\n   output logic [3:0]                      sb_axi_arregion,\n   output logic [7:0]                      sb_axi_arlen,\n   output logic [2:0]                      sb_axi_arsize,\n   output logic [1:0]                      sb_axi_arburst,\n   output logic                            sb_axi_arlock,\n   output logic [3:0]                      sb_axi_arcache,\n   output logic [2:0]                      sb_axi_arprot,\n   output logic [3:0]                      sb_axi_arqos,\n\n   input  logic                            sb_axi_rvalid,\n   output logic                            sb_axi_rready,\n   input  logic [pt.SB_BUS_TAG-1:0]        sb_axi_rid,\n   input  logic [63:0]                     sb_axi_rdata,\n   input  logic [1:0]                      sb_axi_rresp,\n   input  logic                            sb_axi_rlast,\n\n   //-------------------------- DMA AXI signals--------------------------\n   // AXI Write Channels\n   input  logic                         dma_axi_awvalid,\n   output logic                         dma_axi_awready,\n   input  logic [pt.DMA_BUS_TAG-1:0]    dma_axi_awid,\n   input  logic [31:0]                  dma_axi_awaddr,\n   input  logic [2:0]                   dma_axi_awsize,\n   input  logic [2:0]                   dma_axi_awprot,\n   input  logic [7:0]                   dma_axi_awlen,\n   input  logic [1:0]                   dma_axi_awburst,\n\n\n   input  logic                         dma_axi_wvalid,\n   output logic                         dma_axi_wready,\n   input  logic [63:0]                  dma_axi_wdata,\n   input  logic [7:0]                   dma_axi_wstrb,\n   input  logic                         dma_axi_wlast,\n\n   output logic                         dma_axi_bvalid,\n   input  logic                         dma_axi_bready,\n   output logic [1:0]                   dma_axi_bresp,\n   output logic [pt.DMA_BUS_TAG-1:0]    dma_axi_bid,\n\n   // AXI Read Channels\n   input  logic                         dma_axi_arvalid,\n   output logic                         dma_axi_arready,\n   input  logic [pt.DMA_BUS_TAG-1:0]    dma_axi_arid,\n   input  logic [31:0]                  dma_axi_araddr,\n   input  logic [2:0]                   dma_axi_arsize,\n   input  logic [2:0]                   dma_axi_arprot,\n   input  logic [7:0]                   dma_axi_arlen,\n   input  logic [1:0]                   dma_axi_arburst,\n\n   output logic                         dma_axi_rvalid,\n   input  logic                         dma_axi_rready,\n   output logic [pt.DMA_BUS_TAG-1:0]    dma_axi_rid,\n   output logic [63:0]                  dma_axi_rdata,\n   output logic [1:0]                   dma_axi_rresp,\n   output logic                         dma_axi_rlast,\n\n\n //// AHB LITE BUS\n   output logic [31:0]           haddr,\n   output logic [2:0]            hburst,\n   output logic                  hmastlock,\n   output logic [3:0]            hprot,\n   output logic [2:0]            hsize,\n   output logic [1:0]            htrans,\n   output logic                  hwrite,\n\n   input  logic [63:0]           hrdata,\n   input  logic                  hready,\n   input  logic                  hresp,\n\n   // LSU AHB Master\n   output logic [31:0]          lsu_haddr,\n   output logic [2:0]           lsu_hburst,\n   output logic                 lsu_hmastlock,\n   output logic [3:0]           lsu_hprot,\n   output logic [2:0]           lsu_hsize,\n   output logic [1:0]           lsu_htrans,\n   output logic                 lsu_hwrite,\n   output logic [63:0]          lsu_hwdata,\n\n   input  logic [63:0]          lsu_hrdata,\n   input  logic                 lsu_hready,\n   input  logic                 lsu_hresp,\n\n   //System Bus Debug Master\n   output logic [31:0]          sb_haddr,\n   output logic [2:0]           sb_hburst,\n   output logic                 sb_hmastlock,\n   output logic [3:0]           sb_hprot,\n   output logic [2:0]           sb_hsize,\n   output logic [1:0]           sb_htrans,\n   output logic                 sb_hwrite,\n   output logic [63:0]          sb_hwdata,\n\n   input  logic [63:0]          sb_hrdata,\n   input  logic                 sb_hready,\n   input  logic                 sb_hresp,\n\n   // DMA Slave\n   input logic                   dma_hsel,\n   input logic [31:0]            dma_haddr,\n   input logic [2:0]             dma_hburst,\n   input logic                   dma_hmastlock,\n   input logic [3:0]             dma_hprot,\n   input logic [2:0]             dma_hsize,\n   input logic [1:0]             dma_htrans,\n   input logic                   dma_hwrite,\n   input logic [63:0]            dma_hwdata,\n   input logic                   dma_hreadyin,\n\n   output  logic [63:0]          dma_hrdata,\n   output  logic                 dma_hreadyout,\n   output  logic                 dma_hresp,\n\n   input   logic                 lsu_bus_clk_en,\n   input   logic                 ifu_bus_clk_en,\n   input   logic                 dbg_bus_clk_en,\n   input   logic                 dma_bus_clk_en,\n\n   input logic                  dmi_reg_en,                // read or write\n   input logic [6:0]            dmi_reg_addr,              // address of DM register\n   input logic                  dmi_reg_wr_en,             // write instruction\n   input logic [31:0]           dmi_reg_wdata,             // write data\n   output logic [31:0]          dmi_reg_rdata,\n\n   // ICCM/DCCM ECC status\n   output logic                 iccm_ecc_single_error,\n   output logic                 iccm_ecc_double_error,\n   output logic                 dccm_ecc_single_error,\n   output logic                 dccm_ecc_double_error,\n\n   input logic [pt.PIC_TOTAL_INT:1]           extintsrc_req,\n   input logic                   timer_int,\n   input logic                   soft_int,\n   input logic                   scan_mode\n);\n\n\n\n\n   logic [63:0]                  hwdata_nc;\n   //----------------------------------------------------------------------\n   //\n   //----------------------------------------------------------------------\n\n   logic                         ifu_pmu_instr_aligned;\n   logic                         ifu_ic_error_start;\n   logic                         ifu_iccm_dma_rd_ecc_single_err;\n   logic                         ifu_iccm_rd_ecc_single_err;\n   logic                         ifu_iccm_rd_ecc_double_err;\n   logic                         lsu_dccm_rd_ecc_single_err;\n   logic                         lsu_dccm_rd_ecc_double_err;\n\n   logic                         lsu_axi_awready_ahb;\n   logic                         lsu_axi_wready_ahb;\n   logic                         lsu_axi_bvalid_ahb;\n   logic                         lsu_axi_bready_ahb;\n   logic [1:0]                   lsu_axi_bresp_ahb;\n   logic [pt.LSU_BUS_TAG-1:0]    lsu_axi_bid_ahb;\n   logic                         lsu_axi_arready_ahb;\n   logic                         lsu_axi_rvalid_ahb;\n   logic [pt.LSU_BUS_TAG-1:0]    lsu_axi_rid_ahb;\n   logic [63:0]                  lsu_axi_rdata_ahb;\n   logic [1:0]                   lsu_axi_rresp_ahb;\n   logic                         lsu_axi_rlast_ahb;\n\n   logic                         lsu_axi_awready_int;\n   logic                         lsu_axi_wready_int;\n   logic                         lsu_axi_bvalid_int;\n   logic                         lsu_axi_bready_int;\n   logic [1:0]                   lsu_axi_bresp_int;\n   logic [pt.LSU_BUS_TAG-1:0]    lsu_axi_bid_int;\n   logic                         lsu_axi_arready_int;\n   logic                         lsu_axi_rvalid_int;\n   logic [pt.LSU_BUS_TAG-1:0]    lsu_axi_rid_int;\n   logic [63:0]                  lsu_axi_rdata_int;\n   logic [1:0]                   lsu_axi_rresp_int;\n   logic                         lsu_axi_rlast_int;\n\n   logic                         ifu_axi_awready_ahb;\n   logic                         ifu_axi_wready_ahb;\n   logic                         ifu_axi_bvalid_ahb;\n   logic                         ifu_axi_bready_ahb;\n   logic [1:0]                   ifu_axi_bresp_ahb;"}
{"text": "\n   logic [pt.IFU_BUS_TAG-1:0]    ifu_axi_bid_ahb;\n   logic                         ifu_axi_arready_ahb;\n   logic                         ifu_axi_rvalid_ahb;\n   logic [pt.IFU_BUS_TAG-1:0]    ifu_axi_rid_ahb;\n   logic [63:0]                  ifu_axi_rdata_ahb;\n   logic [1:0]                   ifu_axi_rresp_ahb;\n   logic                         ifu_axi_rlast_ahb;\n\n   logic                         ifu_axi_awready_int;\n   logic                         ifu_axi_wready_int;\n   logic                         ifu_axi_bvalid_int;\n   logic                         ifu_axi_bready_int;\n   logic [1:0]                   ifu_axi_bresp_int;\n   logic [pt.IFU_BUS_TAG-1:0]    ifu_axi_bid_int;\n   logic                         ifu_axi_arready_int;\n   logic                         ifu_axi_rvalid_int;\n   logic [pt.IFU_BUS_TAG-1:0]    ifu_axi_rid_int;\n   logic [63:0]                  ifu_axi_rdata_int;\n   logic [1:0]                   ifu_axi_rresp_int;\n   logic                         ifu_axi_rlast_int;\n\n   logic                         sb_axi_awready_ahb;\n   logic                         sb_axi_wready_ahb;\n   logic                         sb_axi_bvalid_ahb;\n   logic                         sb_axi_bready_ahb;\n   logic [1:0]                   sb_axi_bresp_ahb;\n   logic [pt.SB_BUS_TAG-1:0]     sb_axi_bid_ahb;\n   logic                         sb_axi_arready_ahb;\n   logic                         sb_axi_rvalid_ahb;\n   logic [pt.SB_BUS_TAG-1:0]     sb_axi_rid_ahb;\n   logic [63:0]                  sb_axi_rdata_ahb;\n   logic [1:0]                   sb_axi_rresp_ahb;\n   logic                         sb_axi_rlast_ahb;\n\n   logic                         sb_axi_awready_int;\n   logic                         sb_axi_wready_int;\n   logic                         sb_axi_bvalid_int;\n   logic                         sb_axi_bready_int;\n   logic [1:0]                   sb_axi_bresp_int;\n   logic [pt.SB_BUS_TAG-1:0]     sb_axi_bid_int;\n   logic                         sb_axi_arready_int;\n   logic                         sb_axi_rvalid_int;\n   logic [pt.SB_BUS_TAG-1:0]     sb_axi_rid_int;\n   logic [63:0]                  sb_axi_rdata_int;\n   logic [1:0]                   sb_axi_rresp_int;\n   logic                         sb_axi_rlast_int;\n\n   logic                         dma_axi_awvalid_ahb;\n   logic [pt.DMA_BUS_TAG-1:0]    dma_axi_awid_ahb;\n   logic [31:0]                  dma_axi_awaddr_ahb;\n   logic [2:0]                   dma_axi_awsize_ahb;\n   logic [2:0]                   dma_axi_awprot_ahb;\n   logic [7:0]                   dma_axi_awlen_ahb;\n   logic [1:0]                   dma_axi_awburst_ahb;\n   logic                         dma_axi_wvalid_ahb;\n   logic [63:0]                  dma_axi_wdata_ahb;\n   logic [7:0]                   dma_axi_wstrb_ahb;\n   logic                         dma_axi_wlast_ahb;\n   logic                         dma_axi_bready_ahb;\n   logic                         dma_axi_arvalid_ahb;\n   logic [pt.DMA_BUS_TAG-1:0]    dma_axi_arid_ahb;\n   logic [31:0]                  dma_axi_araddr_ahb;\n   logic [2:0]                   dma_axi_arsize_ahb;\n   logic [2:0]                   dma_axi_arprot_ahb;\n   logic [7:0]                   dma_axi_arlen_ahb;\n   logic [1:0]                   dma_axi_arburst_ahb;\n   logic                         dma_axi_rready_ahb;\n\n   logic                         dma_axi_awvalid_int;\n   logic [pt.DMA_BUS_TAG-1:0]    dma_axi_awid_int;\n   logic [31:0]                  dma_axi_awaddr_int;\n   logic [2:0]                   dma_axi_awsize_int;\n   logic [2:0]                   dma_axi_awprot_int;\n   logic [7:0]                   dma_axi_awlen_int;\n   logic [1:0]                   dma_axi_awburst_int;\n   logic                         dma_axi_wvalid_int;\n   logic [63:0]                  dma_axi_wdata_int;\n   logic [7:0]                   dma_axi_wstrb_int;\n   logic                         dma_axi_wlast_int;\n   logic                         dma_axi_bready_int;\n   logic                         dma_axi_arvalid_int;\n   logic [pt.DMA_BUS_TAG-1:0]    dma_axi_arid_int;\n   logic [31:0]                  dma_axi_araddr_int;\n   logic [2:0]                   dma_axi_arsize_int;\n   logic [2:0]                   dma_axi_arprot_int;\n   logic [7:0]                   dma_axi_arlen_int;\n   logic [1:0]                   dma_axi_arburst_int;\n   logic                         dma_axi_rready_int;\n\n\n// Icache debug\n   logic [70:0] ifu_ic_debug_rd_data; // diagnostic icache read data\n   logic ifu_ic_debug_rd_data_valid; // diagnostic icache read data valid\n   el2_cache_debug_pkt_t dec_tlu_ic_diag_pkt; // packet of DICAWICS, DICAD0/1, DICAGO info for icache diagnostics\n\n\n   logic         dec_i0_rs1_en_d;\n   logic         dec_i0_rs2_en_d;\n   logic  [31:0] gpr_i0_rs1_d;\n   logic  [31:0] gpr_i0_rs2_d;\n\n   logic [31:0] dec_i0_result_r;\n   logic [31:0] exu_i0_result_x;\n   logic [31:1] exu_i0_pc_x;\n   logic [31:1] exu_npc_r;\n\n   el2_alu_pkt_t  i0_ap;\n\n   // Trigger signals\n   el2_trigger_pkt_t [3:0]     trigger_pkt_any;\n   logic [3:0]             lsu_trigger_match_m;\n\n\n   logic [31:0] dec_i0_immed_d;\n   logic [12:1] dec_i0_br_immed_d;\n   logic         dec_i0_select_pc_d;\n\n   logic [31:1] dec_i0_pc_d;\n   logic [3:0]  dec_i0_rs1_bypass_en_d;\n   logic [3:0]  dec_i0_rs2_bypass_en_d;\n\n   logic         dec_i0_alu_decode_d;\n   logic         dec_i0_branch_d;\n\n   logic         ifu_miss_state_idle;\n   logic         dec_tlu_flush_noredir_r;\n   logic         dec_tlu_flush_leak_one_r;\n   logic         dec_tlu_flush_err_r;\n   logic         ifu_i0_valid;\n   logic [31:0]  ifu_i0_instr;\n   logic [31:1]  ifu_i0_pc;\n\n   logic        exu_flush_final;\n\n   logic [31:1] exu_flush_path_final;\n\n   logic [31:0] exu_lsu_rs1_d;\n   logic [31:0] exu_lsu_rs2_d;\n\n\n   el2_lsu_pkt_t    lsu_p;\n   logic             dec_qual_lsu_d;\n\n   logic        dec_lsu_valid_raw_d;\n   logic [11:0] dec_lsu_offset_d;\n\n   logic [31:0]  lsu_result_m;\n   logic [31:0]  lsu_result_corr_r;     // This is the ECC corrected data going to RF\n   logic         lsu_single_ecc_error_incr;     // Increment the ecc counter\n   el2_lsu_error_pkt_t lsu_error_pkt_r;\n   logic         lsu_imprecise_error_load_any;\n   logic         lsu_imprecise_error_store_any;\n   logic [31:0]  lsu_imprecise_error_addr_any;\n   logic         lsu_load_stall_any;       // This is for blocking loads\n   logic         lsu_store_stall_any;      // This is for blocking stores\n   logic         lsu_idle_any;             // doesn't include DMA\n   logic         lsu_active;               // lsu is active. used for clock\n\n\n   logic [31:1]  lsu_fir_addr;        // fast interrupt address\n   logic [1:0]   lsu_fir_error;       // Error during fast interrupt lookup\n\n   // Non-blocking loads\n   logic                                 lsu_nonblock_load_valid_m;\n   logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]   lsu_nonblock_load_tag_m;\n   logic                                 lsu_nonblock_load_inv_r;\n   logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]   lsu_nonblock_load_inv_tag_r;\n   logic                                 lsu_nonblock_load_data_valid;\n   logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]   lsu_nonblock_load_data_tag;\n   logic [31:0]                          lsu_nonblock_load_data;\n\n   logic        dec_csr_ren_d;\n   logic [31:0] dec_csr_rddata_d;\n\n   logic [31:0] exu_csr_rs1_x;\n\n   logic        dec_tlu_i0_commit_cmt;\n   logic        dec_tlu_flush_lower_r;\n   logic        dec_tlu_flush_lower_wb;\n   logic        dec_tlu_i0_kill_writeb_r;     // I0 is flushed, don't writeback any results to arch state\n   logic        dec_tlu_fence_i_r;            // flush is a fence_i rfnpc, flush icache\n\n   logic [31:1] dec_tlu_flush_path_r;\n   logic [31:0] dec_tlu_mrac_ff;        // CSR for memory region control\n\n   logic        ifu_i0_pc4;\n\n   el2_mul_pkt_t  mul_p;\n\n   el2_div_pkt_t  div_p;\n   logic           dec_div_cancel;\n\n   logic [31:0] exu_div_result;\n   logic exu_div_wren;\n\n   logic dec_i0_decode_d;\n\n\n   logic [31:1] pred_correct_npc_x;\n\n   el2_br_tlu_pkt_t dec_tlu_br0_r_pkt;\n\n   el2_predict_pkt_t  exu_mp_pkt;\n   logic [pt.BHT_GHR_SIZE-1:0]  exu_mp_eghr;\n   logic [pt.BHT_GHR_SIZE-1:0]  exu_mp_fghr;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_mp_index;\n   logic [pt.BTB_BTAG_SIZE-1:0]          exu_mp_btag;\n\n   logic [pt.BHT_GHR_SIZE-1:0]  exu_i0_br_fghr_r;\n   logic [1:0]  exu_i0_br_hist_r;\n   logic        exu_i0_br_error_r;\n   logic        exu_i0_br_start_error_r;\n   logic        exu_i0_br_valid_r;\n   logic        exu_i0_br_mp_r;\n   logic        exu_i0_br_middle_r;\n\n   logic        exu_i0_br_way_r;\n\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_i0_br_index_r;\n\n   logic        dma_dccm_req;\n   logic        dma_iccm_req;\n   logic [2:0]  dma_mem_tag;\n   logic [31:0] dma_mem_addr;\n   logic [2:0]  dma_mem_sz;\n   logic        dma_mem_write;\n   logic [63:0] dma_mem_wdata;\n\n   logic        dccm_dma_rvalid;\n   logic        dccm_dma_ecc_error;\n   logic [2:0]  dccm_dma_rtag;\n   logic [63:0] dccm_dma_rdata;\n   logic        iccm_dma_rvalid;\n   logic        iccm_dma_ecc_error;\n   logic [2:0]  iccm_dma_rtag;\n   logic [63:0] iccm_dma_rdata;\n\n   logic        dma_dccm_stall_any;       // Stall the ld/st in decode if asserted\n   logic        dma_iccm_stall_any;       // Stall the fetch\n   logic        dccm_ready;\n   logic        iccm_ready;\n\n   logic        dma_pmu_dccm_read;\n   logic        dma_pmu_dccm_write;\n   logic        dma_pmu_any_read;\n   logic        dma_pmu_any_write;\n\n   logic        ifu_i0_icaf;\n   logic [1:0]  ifu_i0_icaf_type;\n\n\n   logic        ifu_i0_icaf_second;\n   logic        ifu_i0_dbecc;\n   logic        iccm_dma_sb_error;\n\n   el2_br_pkt_t i0_brp;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifu_i0_bp_index;\n   logic [pt.BHT_GHR_SIZE-1:0] ifu_i0_bp_fghr;\n   logic [pt.BTB_BTAG_SIZE-1:0] ifu_i0_bp_btag;\n\n   logic [$clog2(pt.BTB_SIZE)-1:0] ifu_i0_fa_index;\n   logic [$clog2(pt.BTB_SIZE)-1:0] dec_fa_error_index; // Fully associative btb error index\n\n\n   el2_predict_pkt_t dec_i0_predict_p_d;\n\n   logic [pt.BHT_GHR_SIZE-1:0] i0_predict_fghr_d;                // DEC predict fghr\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i0_predict_index_d;     // DEC predict index\n   logic [pt.BTB_BTAG_SIZE-1:0] i0_predict_btag_d;               // DEC predict branch tag\n\n   // PIC ports\n   logic                  picm_wren;\n   logic                  picm_rden;\n   logic                  picm_mken;\n   logic [31:0]           picm_rdaddr;\n   logic [31:0]           picm_wraddr;\n   logic [31:0]           picm_wr_data;\n   logic [31:0]           picm_rd_data;\n\n   // feature disable from mfdc\n   logic  dec_tlu_external_ldfwd_disable; // disable external load forwarding\n   logic  dec_tlu_bpred_disable;\n   logic  dec_tlu_wb_coalescing_disable;\n   logic  dec_tlu_sideeffect_posted_disable;\n   logic [2:0] dec_tlu_dma_qos_prty;         // DMA QoS priority coming from MFDC [18:16]\n\n   // clock gating overrides from mcgc\n   logic  dec_tlu_misc_clk_override;\n   logic  dec_tlu_ifu_clk_override;\n   logic  dec_tlu_lsu_clk_override;\n   logic  dec_tlu_bus_clk_override;\n   logic  dec_tlu_pic_clk_override;\n   logic  dec_tlu_dccm_clk_override;\n   logic  dec_tlu_icm_clk_override;\n\n   logic  dec_tlu_picio_clk_override;\n\n   assign        dccm_clk_override = dec_tlu_dccm_clk_override;   // dccm memory\n   assign        icm_clk_override = dec_tlu_icm_clk_override;    // icache/iccm memory\n\n  // PMP Signals\n  el2_pmp_cfg_pkt_t       pmp_pmpcfg  [pt.PMP_ENTRIES];\n  logic [31:0]            pmp_pmpaddr [pt.PMP_ENTRIES];\n  logic [31:0]            pmp_chan_addr [3];\n  el2_pmp_type_pkt_t      pmp_chan_type [3];\n  logic                   pmp_chan_err  [3];\n\n  logic [31:1] ifu_pmp_addr;\n  logic        ifu_pmp_error;\n  logic [31:0] lsu_pmp_addr_start;\n  logic        lsu_pmp_error_start;\n  logic [31:0] lsu_pmp_addr_end;\n  logic        lsu_pmp_error_end;\n  logic        lsu_pmp_we;\n  logic        lsu_pmp_re;\n\n   // -----------------------DEBUG  START -------------------------------\n\n   logic [31:0]            dbg_cmd_addr;              // the address of the debug command to used by the core\n   logic [31:0]            dbg_cmd_wrdata;            // If the debug command is a write command, this has the data to be written to the CSR/GPR\n   logic                   dbg_cmd_valid;             // commad is being driven by the dbg module. One pulse. Only dirven when core_halted has been seen\n   logic                   dbg_cmd_write;             // 1: write command; 0: read_command\n   logic [1:0]             dbg_cmd_type;              // 0:gpr 1:csr 2: memory\n   logic [1:0]             dbg_cmd_size;              // size of the abstract mem access debug command\n   logic                   dbg_halt_req;              // Sticky signal indicating that the debug module wants to start the entering of debug mode ( start the halting sequence )\n   logic                   dbg_resume_req;            // Sticky signal indicating that the debug module wants to resume from debug mode\n   logic                   dbg_core_rst_l;            // Core reset from DM\n\n   logic                   core_dbg_cmd_done;         // Final muxed cmd done to debug\n   logic                   core_dbg_cmd_fail;         // Final muxed cmd done to debug\n   logic [31:0]            core_dbg_rddata;           // Final muxed cmd done to debug\n\n   logic                   dma_dbg_cmd_done;          // Abstarct memory command sent to dma is done\n   logic                   dma_dbg_cmd_fail;          // Abstarct memory command sent to dma failed\n   logic [31:0]            dma_dbg_rddata;            // Read data for abstract memory access\n\n   logic                   dbg_dma_bubble;            // Debug needs a bubble to send a valid\n   logic                   dma_dbg_ready;             // DMA is ready to accept debug request\n\n   logic [31:0]            dec_dbg_rddata;            // The core drives this data ( intercepts the pipe and sends it here )\n   logic                   dec_dbg_cmd_done;          // This will be treated like a valid signal\n   logic                   dec_dbg_cmd_fail;          // Abstract command failed\n   logic                   dec_tlu_mpc_halted_only;   // Only halted due to MPC\n   logic                   dec_tlu_dbg_halted;        // The core has finished the queiscing sequence. Sticks this signal high\n   logic                   dec_tlu_resume_ack;\n   logic                   dec_tlu_debug_mode;        // Core is in debug mode\n   logic                   dec_debug_wdata_rs1_d;\n   logic                   dec_tlu_force_halt;        // halt has been forced\n\n   logic [1:0]             dec_data_en;\n   logic [1:0]             dec_ctl_en;\n\n   // PMU Signals\n   logic                   exu_pmu_i0_br_misp;\n   logic                   exu_pmu_i0_br_ataken;\n   logic                   exu_pmu_i0_pc4;\n\n   logic                   lsu_pmu_load_external_m;\n   logic                   lsu_pmu_store_external_m;\n   logic                   lsu_pmu_misaligned_m;\n   logic                   lsu_pmu_bus_trxn;\n   logic                   lsu_pmu_bus_misaligned;\n   logic                   lsu_pmu_bus_error;\n   logic                   lsu_pmu_bus_busy;\n\n   logic                   ifu_pmu_fetch_stall;\n   logic                   ifu_pmu_ic_miss;\n   logic                   ifu_pmu_ic_hit;\n   logic                   ifu_pmu_bus_error;\n   logic                   ifu_pmu_bus_busy;\n   logic                   ifu_pmu_bus_trxn;\n\n   logic                   active_state;\n   logic                   free_clk;\n   logic                   active_clk;\n   logic                   dec_pause_state_cg;\n\n   logic                   lsu_nonblock_load_data_error;\n\n   logic [15:0]            ifu_i0_cinst;\n\n// fast interrupt\n   logic [31:2]            dec_tlu_meihap;\n   logic                   dec_extint_stall;\n\n   el2_trace_pkt_t  trace_rv_trace_pkt;\n\n\n   logic                   lsu_fastint_stall_any;\n\n   logic [7:0]  pic_claimid;\n   logic [3:0]  pic_pl, dec_tlu_meicurpl, dec_tlu_meipt;\n   logic        mexintpend;\n   logic        mhwakeup;\n\n   logic        dma_active;\n\n\n   logic        pause_state;\n   logic        halt_state;\n\n   logic        dec_tlu_core_empty;\n\n   assign pause_state = dec_pause_state_cg & ~(dma_active | lsu_active) & dec_tlu_core_empty;\n\n   assign halt_state = o_cpu_halt_status & ~(dma_active | lsu_active);\n\n\n   assign active_state = (~(halt_state | pause_state) | dec_tlu_flush_lower_r | dec_tlu_flush_lower_wb)  | dec_tlu_misc_clk_override;\n\n   rvoclkhdr free_cg2   ( .clk(clk), .en(1'b1),         .l1clk(free_l2clk), .* );\n   rvoclkhdr active_cg2 ( .clk(clk), .en(active_state), .l1clk(active_l2clk), .* );\n\n// all other clock headers are 1st level\n   rvoclkhdr free_cg1   ( .clk(free_l2clk),     .en(1'b1), .l1clk(free_clk), .* );\n   rvoclkhdr active_cg1 ( .clk(active_l2clk),   .en(1'b1), .l1clk(active_clk), .* );\n\n\n   assign core_dbg_cmd_done = dma_dbg_cmd_done | dec_dbg_cmd_done;\n   assign core_dbg_cmd_fail = dma_dbg_cmd_fail | dec_dbg_cmd_fail;\n   assign core_dbg_rddata[31:0] = dma_dbg_cmd_done ? dma_dbg_rddata[31:0] : dec_dbg_rddata[31:0];\n\n   el2_dbg #(.pt(pt)) dbg (\n      .rst_l(core_rst_l),\n      .clk(free_l2clk),\n      .clk_override(dec_tlu_misc_clk_override),\n\n      // AXI signals\n      .sb_axi_awready(sb_axi_awready_int),\n      .sb_axi_wready(sb_axi_wready_int),\n      .sb_axi_bvalid(sb_axi_bvalid_int),\n      .sb_axi_bresp(sb_axi_bresp_int[1:0]),\n\n      .sb_axi_arready(sb_axi_arready_int),\n      .sb_axi_rvalid(sb_axi_rvalid_int),\n      .sb_axi_rdata(sb_axi_rdata_int[63:0]),\n      .sb_axi_rresp(sb_axi_rresp_int[1:0]),\n      .*\n   );\n\n`ifdef RV_ASSERT_ON\n      assert_fetch_indbghalt: assert #0 (~(ifu.ifc_fetch_req_f & dec.tlu.dbg_tlu_halted_f & ~dec.tlu.dcsr_single_step_running)) else $display(\"ERROR: Fetching in dBG halt!\");\n`endif\n\n   // -----------------   DEBUG END -----------------------------\n\n   assign core_rst_l = rst_l & (dbg_core_rst_l | scan_mode);\n\n   // fetch\n   el2_ifu #(.pt(pt)) ifu (\n                            .clk(active_l2clk),\n                            .rst_l(core_rst_l),\n                            .dec_tlu_flush_err_wb       (dec_tlu_flush_err_r      ),\n                            .dec_tlu_flush_noredir_wb   (dec_tlu_flush_noredir_r  ),\n                            .dec_tlu_fence_i_wb         (dec_tlu_fence_i_r        ),\n                            .dec_tlu_flush_leak_one_wb  (dec_tlu_flush_leak_one_r ),\n                            .dec_tlu_flush_lower_wb     (dec_tlu_flush_lower_r    ),\n\n                            // AXI signals\n                            .ifu_axi_arready(ifu_axi_arready_int),\n                            .ifu_axi_rvalid(ifu_axi_rvalid_int),\n                            .ifu_axi_rid(ifu_axi_rid_int[pt.IFU_BUS_TAG-1:0]),\n                            .ifu_axi_rdata(ifu_axi_rdata_int[63:0]),\n                            .ifu_axi_rresp(ifu_axi_rresp_int[1:0]),\n\n                            .*\n                            );\n\n\n   assign iccm_ecc_single_error = ifu_iccm_rd_ecc_single_err || ifu_iccm_dma_rd_ecc_single_err;\n   assign iccm_ecc_double_error = ifu_iccm_rd_ecc_double_err;\n\n   el2_dec #(.pt(pt)) dec (\n                            .clk(active_l2clk),\n                            .dbg_cmd_wrdata(dbg_cmd_wrdata[1:0]),\n                            .rst_l(core_rst_l),\n                            .*\n                            );\n\n   el2_exu #(.pt(pt)) exu (\n                            .clk(active_l2clk),\n                            .rst_l(core_rst_l),\n                            .*\n                            );\n\n   el2_lsu #(.pt(pt)) lsu (\n                            .clk(active_l2clk),\n                            .rst_l(core_rst_l),\n                            .clk_override(dec_tlu_lsu_clk_override),\n                            .dec_tlu_i0_kill_writeb_r(dec_tlu_i0_kill_writeb_r),\n\n                            // AXI signals\n                            .lsu_axi_awready(lsu_axi_awready_int),\n                            .lsu_axi_wready(lsu_axi_wready_int),\n                            .lsu_axi_bvalid(lsu_axi_bvalid_int),\n                            .lsu_axi_bid(lsu_axi_bid_int[pt.LSU_BUS_TAG-1:0]),\n                        "}
{"text": "    .lsu_axi_bresp(lsu_axi_bresp_int[1:0]),\n\n                            .lsu_axi_arready(lsu_axi_arready_int),\n                            .lsu_axi_rvalid(lsu_axi_rvalid_int),\n                            .lsu_axi_rid(lsu_axi_rid_int[pt.LSU_BUS_TAG-1:0]),\n                            .lsu_axi_rdata(lsu_axi_rdata_int[63:0]),\n                            .lsu_axi_rresp(lsu_axi_rresp_int[1:0]),\n                            .lsu_axi_rlast(lsu_axi_rlast_int),\n\n                            .*\n\n                            );\n\n   assign dccm_ecc_single_error = lsu_dccm_rd_ecc_single_err;\n   assign dccm_ecc_double_error = lsu_dccm_rd_ecc_double_err;\n\n   el2_pic_ctrl  #(.pt(pt)) pic_ctrl_inst (\n                                            .clk(free_l2clk),\n                                            .clk_override(dec_tlu_pic_clk_override),\n                                            .io_clk_override(dec_tlu_picio_clk_override),\n                                            .picm_mken (picm_mken),\n                                            .extintsrc_req({extintsrc_req[pt.PIC_TOTAL_INT:1],1'b0}),\n                                            .pl(pic_pl[3:0]),\n                                            .claimid(pic_claimid[7:0]),\n                                            .meicurpl(dec_tlu_meicurpl[3:0]),\n                                            .meipt(dec_tlu_meipt[3:0]),\n                                            .rst_l(core_rst_l),\n                                            .*);\n\n   el2_dma_ctrl #(.pt(pt)) dma_ctrl (\n                                      .clk(free_l2clk),\n                                      .rst_l(core_rst_l),\n                                      .clk_override(dec_tlu_misc_clk_override),\n\n                                      // AXI signals\n                                      .dma_axi_awvalid(dma_axi_awvalid_int),\n                                      .dma_axi_awid(dma_axi_awid_int[pt.DMA_BUS_TAG-1:0]),\n                                      .dma_axi_awaddr(dma_axi_awaddr_int[31:0]),\n                                      .dma_axi_awsize(dma_axi_awsize_int[2:0]),\n                                      .dma_axi_wvalid(dma_axi_wvalid_int),\n                                      .dma_axi_wdata(dma_axi_wdata_int[63:0]),\n                                      .dma_axi_wstrb(dma_axi_wstrb_int[7:0]),\n                                      .dma_axi_bready(dma_axi_bready_int),\n\n                                      .dma_axi_arvalid(dma_axi_arvalid_int),\n                                      .dma_axi_arid(dma_axi_arid_int[pt.DMA_BUS_TAG-1:0]),\n                                      .dma_axi_araddr(dma_axi_araddr_int[31:0]),\n                                      .dma_axi_arsize(dma_axi_arsize_int[2:0]),\n                                      .dma_axi_rready(dma_axi_rready_int),\n\n                                      .*\n                                      );\n\n  assign pmp_chan_addr[0] = {ifu_pmp_addr, 1'b0};\n  assign pmp_chan_type[0] = EXEC;\n  assign ifu_pmp_error    = pmp_chan_err[0];\n  assign pmp_chan_addr[1] = lsu_pmp_addr_start;\n  assign pmp_chan_type[1] = lsu_pmp_we ? WRITE : (lsu_pmp_re ? READ : NONE);\n  assign lsu_pmp_error_start = pmp_chan_err[1];\n  assign pmp_chan_addr[2] = lsu_pmp_addr_end;\n  assign pmp_chan_type[2] = lsu_pmp_we ? WRITE : (lsu_pmp_re ? READ : NONE);\n  assign lsu_pmp_error_end = pmp_chan_err[2];\n\n  el2_pmp #(\n      .PMP_CHANNELS(3),\n      .pt(pt)\n  ) pmp (\n      .clk  (active_l2clk),\n      .rst_l(core_rst_l),\n      .*\n  );\n\n   if (pt.BUILD_AHB_LITE == 1) begin: Gen_AXI_To_AHB\n\n      // AXI4 -> AHB Gasket for LSU\n      axi4_to_ahb #(.pt(pt),\n                    .TAG(pt.LSU_BUS_TAG)) lsu_axi4_to_ahb (\n\n         .clk(free_l2clk),\n         .free_clk(free_clk),\n         .rst_l(core_rst_l),\n         .clk_override(dec_tlu_bus_clk_override),\n         .bus_clk_en(lsu_bus_clk_en),\n         .dec_tlu_force_halt(dec_tlu_force_halt),\n\n         // AXI Write Channels\n         .axi_awvalid(lsu_axi_awvalid),\n         .axi_awready(lsu_axi_awready_ahb),\n         .axi_awid(lsu_axi_awid[pt.LSU_BUS_TAG-1:0]),\n         .axi_awaddr(lsu_axi_awaddr[31:0]),\n         .axi_awsize(lsu_axi_awsize[2:0]),\n         .axi_awprot(lsu_axi_awprot[2:0]),\n\n         .axi_wvalid(lsu_axi_wvalid),\n         .axi_wready(lsu_axi_wready_ahb),\n         .axi_wdata(lsu_axi_wdata[63:0]),\n         .axi_wstrb(lsu_axi_wstrb[7:0]),\n         .axi_wlast(lsu_axi_wlast),\n\n         .axi_bvalid(lsu_axi_bvalid_ahb),\n         .axi_bready(lsu_axi_bready),\n         .axi_bresp(lsu_axi_bresp_ahb[1:0]),\n         .axi_bid(lsu_axi_bid_ahb[pt.LSU_BUS_TAG-1:0]),\n\n         // AXI Read Channels\n         .axi_arvalid(lsu_axi_arvalid),\n         .axi_arready(lsu_axi_arready_ahb),\n         .axi_arid(lsu_axi_arid[pt.LSU_BUS_TAG-1:0]),\n         .axi_araddr(lsu_axi_araddr[31:0]),\n         .axi_arsize(lsu_axi_arsize[2:0]),\n         .axi_arprot(lsu_axi_arprot[2:0]),\n\n         .axi_rvalid(lsu_axi_rvalid_ahb),\n         .axi_rready(lsu_axi_rready),\n         .axi_rid(lsu_axi_rid_ahb[pt.LSU_BUS_TAG-1:0]),\n         .axi_rdata(lsu_axi_rdata_ahb[63:0]),\n         .axi_rresp(lsu_axi_rresp_ahb[1:0]),\n         .axi_rlast(lsu_axi_rlast_ahb),\n\n         // AHB-LITE signals\n         .ahb_haddr(lsu_haddr[31:0]),\n         .ahb_hburst(lsu_hburst),\n         .ahb_hmastlock(lsu_hmastlock),\n         .ahb_hprot(lsu_hprot[3:0]),\n         .ahb_hsize(lsu_hsize[2:0]),\n         .ahb_htrans(lsu_htrans[1:0]),\n         .ahb_hwrite(lsu_hwrite),\n         .ahb_hwdata(lsu_hwdata[63:0]),\n\n         .ahb_hrdata(lsu_hrdata[63:0]),\n         .ahb_hready(lsu_hready),\n         .ahb_hresp(lsu_hresp),\n\n         .*\n      );\n\n      axi4_to_ahb #(.pt(pt),\n                    .TAG(pt.IFU_BUS_TAG)) ifu_axi4_to_ahb (\n         .clk(free_l2clk),\n         .free_clk(free_clk),\n         .rst_l(core_rst_l),\n         .clk_override(dec_tlu_bus_clk_override),\n         .bus_clk_en(ifu_bus_clk_en),\n         .dec_tlu_force_halt(dec_tlu_force_halt),\n\n          // AHB-Lite signals\n         .ahb_haddr(haddr[31:0]),\n         .ahb_hburst(hburst),\n         .ahb_hmastlock(hmastlock),\n         .ahb_hprot(hprot[3:0]),\n         .ahb_hsize(hsize[2:0]),\n         .ahb_htrans(htrans[1:0]),\n         .ahb_hwrite(hwrite),\n         .ahb_hwdata(hwdata_nc[63:0]),\n\n         .ahb_hrdata(hrdata[63:0]),\n         .ahb_hready(hready),\n         .ahb_hresp(hresp),\n\n         // AXI Write Channels\n         .axi_awvalid(ifu_axi_awvalid),\n         .axi_awready(ifu_axi_awready_ahb),\n         .axi_awid(ifu_axi_awid[pt.IFU_BUS_TAG-1:0]),\n         .axi_awaddr(ifu_axi_awaddr[31:0]),\n         .axi_awsize(ifu_axi_awsize[2:0]),\n         .axi_awprot(ifu_axi_awprot[2:0]),\n\n         .axi_wvalid(ifu_axi_wvalid),\n         .axi_wready(ifu_axi_wready_ahb),\n         .axi_wdata(ifu_axi_wdata[63:0]),\n         .axi_wstrb(ifu_axi_wstrb[7:0]),\n         .axi_wlast(ifu_axi_wlast),\n\n         .axi_bvalid(ifu_axi_bvalid_ahb),\n         .axi_bready(1'b1),\n         .axi_bresp(ifu_axi_bresp_ahb[1:0]),\n         .axi_bid(ifu_axi_bid_ahb[pt.IFU_BUS_TAG-1:0]),\n\n         // AXI Read Channels\n         .axi_arvalid(ifu_axi_arvalid),\n         .axi_arready(ifu_axi_arready_ahb),\n         .axi_arid(ifu_axi_arid[pt.IFU_BUS_TAG-1:0]),\n         .axi_araddr(ifu_axi_araddr[31:0]),\n         .axi_arsize(ifu_axi_arsize[2:0]),\n         .axi_arprot(ifu_axi_arprot[2:0]),\n\n         .axi_rvalid(ifu_axi_rvalid_ahb),\n         .axi_rready(ifu_axi_rready),\n         .axi_rid(ifu_axi_rid_ahb[pt.IFU_BUS_TAG-1:0]),\n         .axi_rdata(ifu_axi_rdata_ahb[63:0]),\n         .axi_rresp(ifu_axi_rresp_ahb[1:0]),\n         .axi_rlast(ifu_axi_rlast_ahb),\n         .*\n      );\n\n      // AXI4 -> AHB Gasket for System Bus\n      axi4_to_ahb #(.pt(pt),\n                    .TAG(pt.SB_BUS_TAG)) sb_axi4_to_ahb (\n         .clk(free_l2clk),\n         .free_clk(free_clk),\n         .rst_l(dbg_rst_l),\n         .clk_override(dec_tlu_bus_clk_override),\n         .bus_clk_en(dbg_bus_clk_en),\n         .dec_tlu_force_halt(1'b0),\n\n         // AXI Write Channels\n         .axi_awvalid(sb_axi_awvalid),\n         .axi_awready(sb_axi_awready_ahb),\n         .axi_awid(sb_axi_awid[pt.SB_BUS_TAG-1:0]),\n         .axi_awaddr(sb_axi_awaddr[31:0]),\n         .axi_awsize(sb_axi_awsize[2:0]),\n         .axi_awprot(sb_axi_awprot[2:0]),\n\n         .axi_wvalid(sb_axi_wvalid),\n         .axi_wready(sb_axi_wready_ahb),\n         .axi_wdata(sb_axi_wdata[63:0]),\n         .axi_wstrb(sb_axi_wstrb[7:0]),\n         .axi_wlast(sb_axi_wlast),\n\n         .axi_bvalid(sb_axi_bvalid_ahb),\n         .axi_bready(sb_axi_bready),\n         .axi_bresp(sb_axi_bresp_ahb[1:0]),\n         .axi_bid(sb_axi_bid_ahb[pt.SB_BUS_TAG-1:0]),\n\n         // AXI Read Channels\n         .axi_arvalid(sb_axi_arvalid),\n         .axi_arready(sb_axi_arready_ahb),\n         .axi_arid(sb_axi_arid[pt.SB_BUS_TAG-1:0]),\n         .axi_araddr(sb_axi_araddr[31:0]),\n         .axi_arsize(sb_axi_arsize[2:0]),\n         .axi_arprot(sb_axi_arprot[2:0]),\n\n         .axi_rvalid(sb_axi_rvalid_ahb),\n         .axi_rready(sb_axi_rready),\n         .axi_rid(sb_axi_rid_ahb[pt.SB_BUS_TAG-1:0]),\n         .axi_rdata(sb_axi_rdata_ahb[63:0]),\n         .axi_rresp(sb_axi_rresp_ahb[1:0]),\n         .axi_rlast(sb_axi_rlast_ahb),\n         // AHB-LITE signals\n         .ahb_haddr(sb_haddr[31:0]),\n         .ahb_hburst(sb_hburst),\n         .ahb_hmastlock(sb_hmastlock),\n         .ahb_hprot(sb_hprot[3:0]),\n         .ahb_hsize(sb_hsize[2:0]),\n         .ahb_htrans(sb_htrans[1:0]),\n         .ahb_hwrite(sb_hwrite),\n         .ahb_hwdata(sb_hwdata[63:0]),\n\n         .ahb_hrdata(sb_hrdata[63:0]),\n         .ahb_hready(sb_hready),\n         .ahb_hresp(sb_hresp),\n\n         .*\n      );\n\n      //AHB -> AXI4 Gasket for DMA\n      ahb_to_axi4 #(.pt(pt),\n                    .TAG(pt.DMA_BUS_TAG)) dma_ahb_to_axi4 (\n         .clk(free_l2clk),\n         .rst_l(core_rst_l),\n         .clk_override(dec_tlu_bus_clk_override),\n         .bus_clk_en(dma_bus_clk_en),\n\n         // AXI Write Channels\n         .axi_awvalid(dma_axi_awvalid_ahb),\n         .axi_awready(dma_axi_awready),\n         .axi_awid(dma_axi_awid_ahb[pt.DMA_BUS_TAG-1:0]),\n         .axi_awaddr(dma_axi_awaddr_ahb[31:0]),\n         .axi_awsize(dma_axi_awsize_ahb[2:0]),\n         .axi_awprot(dma_axi_awprot_ahb[2:0]),\n         .axi_awlen(dma_axi_awlen_ahb[7:0]),\n         .axi_awburst(dma_axi_awburst_ahb[1:0]),\n\n         .axi_wvalid(dma_axi_wvalid_ahb),\n         .axi_wready(dma_axi_wready),\n         .axi_wdata(dma_axi_wdata_ahb[63:0]),\n         .axi_wstrb(dma_axi_wstrb_ahb[7:0]),\n         .axi_wlast(dma_axi_wlast_ahb),\n\n         .axi_bvalid(dma_axi_bvalid),\n         .axi_bready(dma_axi_bready_ahb),\n         .axi_bresp(dma_axi_bresp[1:0]),\n         .axi_bid(dma_axi_bid[pt.DMA_BUS_TAG-1:0]),\n\n         // AXI Read Channels\n         .axi_arvalid(dma_axi_arvalid_ahb),\n         .axi_arready(dma_axi_arready),\n         .axi_arid(dma_axi_arid_ahb[pt.DMA_BUS_TAG-1:0]),\n         .axi_araddr(dma_axi_araddr_ahb[31:0]),\n         .axi_arsize(dma_axi_arsize_ahb[2:0]),\n         .axi_arprot(dma_axi_arprot_ahb[2:0]),\n         .axi_arlen(dma_axi_arlen_ahb[7:0]),\n         .axi_arburst(dma_axi_arburst_ahb[1:0]),\n\n         .axi_rvalid(dma_axi_rvalid),\n         .axi_rready(dma_axi_rready_ahb),\n         .axi_rid(dma_axi_rid[pt.DMA_BUS_TAG-1:0]),\n         .axi_rdata(dma_axi_rdata[63:0]),\n         .axi_rresp(dma_axi_rresp[1:0]),\n\n          // AHB signals\n         .ahb_haddr(dma_haddr[31:0]),\n         .ahb_hburst(dma_hburst),\n         .ahb_hmastlock(dma_hmastlock),\n         .ahb_hprot(dma_hprot[3:0]),\n         .ahb_hsize(dma_hsize[2:0]),\n         .ahb_htrans(dma_htrans[1:0]),\n         .ahb_hwrite(dma_hwrite),\n         .ahb_hwdata(dma_hwdata[63:0]),\n\n         .ahb_hrdata(dma_hrdata[63:0]),\n         .ahb_hreadyout(dma_hreadyout),\n         .ahb_hresp(dma_hresp),\n         .ahb_hreadyin(dma_hreadyin),\n         .ahb_hsel(dma_hsel),\n         .*\n      );\n\n   end\n\n   // Drive the final AXI inputs\n   assign lsu_axi_awready_int                 = pt.BUILD_AHB_LITE ? lsu_axi_awready_ahb : lsu_axi_awready;\n   assign lsu_axi_wready_int                  = pt.BUILD_AHB_LITE ? lsu_axi_wready_ahb : lsu_axi_wready;\n   assign lsu_axi_bvalid_int                  = pt.BUILD_AHB_LITE ? lsu_axi_bvalid_ahb : lsu_axi_bvalid;\n   assign lsu_axi_bready_int                  = pt.BUILD_AHB_LITE ? lsu_axi_bready_ahb : lsu_axi_bready;\n   assign lsu_axi_bresp_int[1:0]              = pt.BUILD_AHB_LITE ? lsu_axi_bresp_ahb[1:0] : lsu_axi_bresp[1:0];\n   assign lsu_axi_bid_int[pt.LSU_BUS_TAG-1:0] = pt.BUILD_AHB_LITE ? lsu_axi_bid_ahb[pt.LSU_BUS_TAG-1:0] : lsu_axi_bid[pt.LSU_BUS_TAG-1:0];\n   assign lsu_axi_arready_int                 = pt.BUILD_AHB_LITE ? lsu_axi_arready_ahb : lsu_axi_arready;\n   assign lsu_axi_rvalid_int                  = pt.BUILD_AHB_LITE ? lsu_axi_rvalid_ahb : lsu_axi_rvalid;\n   assign lsu_axi_rid_int[pt.LSU_BUS_TAG-1:0] = pt.BUILD_AHB_LITE ? lsu_axi_rid_ahb[pt.LSU_BUS_TAG-1:0] : lsu_axi_rid[pt.LSU_BUS_TAG-1:0];\n   assign lsu_axi_rdata_int[63:0]             = pt.BUILD_AHB_LITE ? lsu_axi_rdata_ahb[63:0] : lsu_axi_rdata[63:0];\n   assign lsu_axi_rresp_int[1:0]              = pt.BUILD_AHB_LITE ? lsu_axi_rresp_ahb[1:0] : lsu_axi_rresp[1:0];\n   assign lsu_axi_rlast_int                   = pt.BUILD_AHB_LITE ? lsu_axi_rlast_ahb : lsu_axi_rlast;\n\n   assign ifu_axi_awready_int                 = pt.BUILD_AHB_LITE ? ifu_axi_awready_ahb : ifu_axi_awready;\n   assign ifu_axi_wready_int                  = pt.BUILD_AHB_LITE ? ifu_axi_wready_ahb : ifu_axi_wready;\n   assign ifu_axi_bvalid_int                  = pt.BUILD_AHB_LITE ? ifu_axi_bvalid_ahb : ifu_axi_bvalid;\n   assign ifu_axi_bready_int                  = pt.BUILD_AHB_LITE ? ifu_axi_bready_ahb : ifu_axi_bready;\n   assign ifu_axi_bresp_int[1:0]              = pt.BUILD_AHB_LITE ? ifu_axi_bresp_ahb[1:0] : ifu_axi_bresp[1:0];\n   assign ifu_axi_bid_int[pt.IFU_BUS_TAG-1:0] = pt.BUILD_AHB_LITE ? ifu_axi_bid_ahb[pt.IFU_BUS_TAG-1:0] : ifu_axi_bid[pt.IFU_BUS_TAG-1:0];\n   assign ifu_axi_arready_int                 = pt.BUILD_AHB_LITE ? ifu_axi_arready_ahb : ifu_axi_arready;\n   assign ifu_axi_rvalid_int                  = pt.BUILD_AHB_LITE ? ifu_axi_rvalid_ahb : ifu_axi_rvalid;\n   assign ifu_axi_rid_int[pt.IFU_BUS_TAG-1:0] = pt.BUILD_AHB_LITE ? ifu_axi_rid_ahb[pt.IFU_BUS_TAG-1:0] : ifu_axi_rid[pt.IFU_BUS_TAG-1:0];\n   assign ifu_axi_rdata_int[63:0]             = pt.BUILD_AHB_LITE ? ifu_axi_rdata_ahb[63:0] : ifu_axi_rdata[63:0];\n   assign ifu_axi_rresp_int[1:0]              = pt.BUILD_AHB_LITE ? ifu_axi_rresp_ahb[1:0] : ifu_axi_rresp[1:0];\n   assign ifu_axi_rlast_int                   = pt.BUILD_AHB_LITE ? ifu_axi_rlast_ahb : ifu_axi_rlast;\n\n   assign sb_axi_awready_int                  = pt.BUILD_AHB_LITE ? sb_axi_awready_ahb : sb_axi_awready;\n   assign sb_axi_wready_int                   = pt.BUILD_AHB_LITE ? sb_axi_wready_ahb : sb_axi_wready;\n   assign sb_axi_bvalid_int                   = pt.BUILD_AHB_LITE ? sb_axi_bvalid_ahb : sb_axi_bvalid;\n   assign sb_axi_bready_int                   = pt.BUILD_AHB_LITE ? sb_axi_bready_ahb : sb_axi_bready;\n   assign sb_axi_bresp_int[1:0]               = pt.BUILD_AHB_LITE ? sb_axi_bresp_ahb[1:0] : sb_axi_bresp[1:0];\n   assign sb_axi_bid_int[pt.SB_BUS_TAG-1:0]   = pt.BUILD_AHB_LITE ? sb_axi_bid_ahb[pt.SB_BUS_TAG-1:0] : sb_axi_bid[pt.SB_BUS_TAG-1:0];\n   assign sb_axi_arready_int                  = pt.BUILD_AHB_LITE ? sb_axi_arready_ahb : sb_axi_arready;\n   assign sb_axi_rvalid_int                   = pt.BUILD_AHB_LITE ? sb_axi_rvalid_ahb : sb_axi_rvalid;\n   assign sb_axi_rid_int[pt.SB_BUS_TAG-1:0]   = pt.BUILD_AHB_LITE ? sb_axi_rid_ahb[pt.SB_BUS_TAG-1:0] : sb_axi_rid[pt.SB_BUS_TAG-1:0];\n   assign sb_axi_rdata_int[63:0]              = pt.BUILD_AHB_LITE ? sb_axi_rdata_ahb[63:0] : sb_axi_rdata[63:0];\n   assign sb_axi_rresp_int[1:0]               = pt.BUILD_AHB_LITE ? sb_axi_rresp_ahb[1:0] : sb_axi_rresp[1:0];\n   assign sb_axi_rlast_int                    = pt.BUILD_AHB_LITE ? sb_axi_rlast_ahb : sb_axi_rlast;\n\n   assign dma_axi_awvalid_int                  = pt.BUILD_AHB_LITE ? dma_axi_awvalid_ahb : dma_axi_awvalid;\n   assign dma_axi_awid_int[pt.DMA_BUS_TAG-1:0] = pt.BUILD_AHB_LITE ? dma_axi_awid_ahb[pt.DMA_BUS_TAG-1:0] : dma_axi_awid[pt.DMA_BUS_TAG-1:0];\n   assign dma_axi_awaddr_int[31:0]             = pt.BUILD_AHB_LITE ? dma_axi_awaddr_ahb[31:0] : dma_axi_awaddr[31:0];\n   assign dma_axi_awsize_int[2:0]              = pt.BUILD_AHB_LITE ? dma_axi_awsize_ahb[2:0] : dma_axi_awsize[2:0];\n   assign dma_axi_awprot_int[2:0]              = pt.BUILD_AHB_LITE ? dma_axi_awprot_ahb[2:0] : dma_axi_awprot[2:0];\n   assign dma_axi_awlen_int[7:0]               = pt.BUILD_AHB_LITE ? dma_axi_awlen_ahb[7:0] : dma_axi_awlen[7:0];\n   assign dma_axi_awburst_int[1:0]             = pt.BUILD_AHB_LITE ? dma_axi_awburst_ahb[1:0] : dma_axi_awburst[1:0];\n   assign dma_axi_wvalid_int                   = pt.BUILD_AHB_LITE ? dma_axi_wvalid_ahb : dma_axi_wvalid;\n   assign dma_axi_wdata_int[63:0]              = pt.BUILD_AHB_LITE ? dma_axi_wdata_ahb[63:0] : dma_axi_wdata;\n   assign dma_axi_wstrb_int[7:0]               = pt.BUILD_AHB_LITE ? dma_axi_wstrb_ahb[7:0] : dma_axi_wstrb[7:0];\n   assign dma_axi_wlast_int                    = pt.BUILD_AHB_LITE ? dma_axi_wlast_ahb : dma_axi_wlast;\n   assign dma_axi_bready_int                   = pt.BUILD_AHB_LITE ? dma_axi_bready_ahb : dma_axi_bready;\n   assign dma_axi_arvalid_int                  = pt.BUILD_AHB_LITE ? dma_axi_arvalid_ahb : dma_axi_arvalid;\n   assign dma_axi_arid_int[pt.DMA_BUS_TAG-1:0] = pt.BUILD_AHB_LITE ? dma_axi_arid_ahb[pt.DMA_BUS_TAG-1:0] : dma_axi_arid[pt.DMA_BUS_TAG-1:0];\n   assign dma_axi_araddr_int[31:0]             = pt.BUILD_AHB_LITE ? dma_axi_araddr_ahb[31:0] : dma_axi_araddr[31:0];\n   assign dma_axi_arsize_int[2:0]              = pt.BUILD_AHB_LITE ? dma_axi_arsize_ahb[2:0] : dma_axi_arsize[2:0];\n   assign dma_axi_arprot_int[2:0]              = pt.BUILD_AHB_LITE ? dma_axi_arprot_ahb[2:0] : dma_axi_arprot[2:0];\n   assign dma_axi_arlen_int[7:0]               = pt.BUILD_AHB_LITE ? dma_axi_arlen_ahb[7:0] : dma_axi_arlen[7:0];\n   assign dma_axi_arburst_int[1:0]             = pt.BUILD_AHB_LITE ? dma_axi_arburst_ahb[1:0] : dma_axi_arburst[1:0];\n   assign dma_axi_rready_int                   = pt.BUILD_AHB_LITE ? dma_axi_rready_ahb : dma_axi_rready;\n\n\nif  (pt.BUILD_AHB_LITE == 1) begin\n`ifdef RV_ASSERT_ON\n   property ahb_trxn_aligned;\n     @(posedge clk) disable iff(~rst_l) (lsu_htrans[1:0] != 2'b0)  |-> ((lsu_hsize[2:0] == 3'h0)                              |\n                                                                        ((lsu_hsize[2:0] == 3'h1) & (lsu_haddr[0] == 1'b0))   |\n                                                                        ((lsu_hsize[2:0] == 3'h2) & (lsu_haddr[1:0] == 2'b0)) |\n                                                                        ((lsu_hsize[2:0] == 3'h3) & (lsu_haddr[2:0] == 3'b0)));\n   endproperty\n   assert_ahb_trxn_aligned: assert property (ahb_trxn_aligned) else\n     $display(\"Assertion ahb_trxn_aligned failed: lsu_htrans=2'h%h, lsu_hsize=3'h%h, lsu_haddr=32'h%h\",lsu_htrans[1:0], lsu_hsize[2:0], lsu_haddr[31:0]);\n\n   property dma_trxn_aligned;\n     @(posedge clk) disable iff(~rst_l) (dma_htrans[1:0] != 2'b0)  |-> ((dma_hsize[2:0] == 3'h0)                              |\n                                                                        ((dma_hsize[2:0] == 3'h1) & (dma_haddr[0] == 1'b0))   |\n                                                                        ((dma_hsize[2:0] == 3'h2) & (dma_haddr[1:0] == 2'b0)) |\n                                                                        ((dma_hsize[2:0] == 3'h3) & (dma_haddr[2:0] == 3'b0)));\n   endproperty\n\n\n`endif\n   end // if (pt.BUILD_AHB_LITE == 1)\n\n\n      // unpack packet\n      // also need retires_p==3\n\n      assign trace_rv_i_insn_ip[31:0]     = trace_rv_trace_pkt.trace_rv_i_insn_ip[31:0];\n\n      assign trace_rv_i_address_ip[31:0]  = trace_rv_trace_pkt.trace_rv_i_address_ip[31:0];\n\n      assign trace_rv_i_valid_ip     = trace_rv_trace_pkt.trace_rv_i_valid_ip;\n\n      assign trace_rv_i_exception"}
{"text": "_ip = trace_rv_trace_pkt.trace_rv_i_exception_ip;\n\n      assign trace_rv_i_ecause_ip[4:0]    = trace_rv_trace_pkt.trace_rv_i_ecause_ip[4:0];\n\n      assign trace_rv_i_interrupt_ip = trace_rv_trace_pkt.trace_rv_i_interrupt_ip;\n\n      assign trace_rv_i_tval_ip[31:0]     = trace_rv_trace_pkt.trace_rv_i_tval_ip[31:0];\n\n\n\nendmodule // el2_veer\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n// Copyright (c) 2023 Antmicro <www.antmicro.com>\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n// Function: Top wrapper file with el2_veer/mem instantiated inside\n// Comments:\n//\n//********************************************************************************\nmodule el2_veer_wrapper\nimport el2_pkg::*;\n #(\n`include \"el2_param.vh\"\n)\n(\n   input logic                             clk,\n   input logic                             rst_l,\n   input logic                             dbg_rst_l,\n   input logic [31:1]                      rst_vec,\n   input logic                             nmi_int,\n   input logic [31:1]                      nmi_vec,\n   input logic [31:1]                      jtag_id,\n\n\n   output logic [31:0]                     trace_rv_i_insn_ip,\n   output logic [31:0]                     trace_rv_i_address_ip,\n   output logic                            trace_rv_i_valid_ip,\n   output logic                            trace_rv_i_exception_ip,\n   output logic [4:0]                      trace_rv_i_ecause_ip,\n   output logic                            trace_rv_i_interrupt_ip,\n   output logic [31:0]                     trace_rv_i_tval_ip,\n\n   // Bus signals\n`ifdef RV_BUILD_AXI4\n   //-------------------------- LSU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            lsu_axi_awvalid,\n   input  logic                            lsu_axi_awready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_awid,\n   output logic [31:0]                     lsu_axi_awaddr,\n   output logic [3:0]                      lsu_axi_awregion,\n   output logic [7:0]                      lsu_axi_awlen,\n   output logic [2:0]                      lsu_axi_awsize,\n   output logic [1:0]                      lsu_axi_awburst,\n   output logic                            lsu_axi_awlock,\n   output logic [3:0]                      lsu_axi_awcache,\n   output logic [2:0]                      lsu_axi_awprot,\n   output logic [3:0]                      lsu_axi_awqos,\n\n   output logic                            lsu_axi_wvalid,\n   input  logic                            lsu_axi_wready,\n   output logic [63:0]                     lsu_axi_wdata,\n   output logic [7:0]                      lsu_axi_wstrb,\n   output logic                            lsu_axi_wlast,\n\n   input  logic                            lsu_axi_bvalid,\n   output logic                            lsu_axi_bready,\n   input  logic [1:0]                      lsu_axi_bresp,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_bid,\n\n   // AXI Read Channels\n   output logic                            lsu_axi_arvalid,\n   input  logic                            lsu_axi_arready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_arid,\n   output logic [31:0]                     lsu_axi_araddr,\n   output logic [3:0]                      lsu_axi_arregion,\n   output logic [7:0]                      lsu_axi_arlen,\n   output logic [2:0]                      lsu_axi_arsize,\n   output logic [1:0]                      lsu_axi_arburst,\n   output logic                            lsu_axi_arlock,\n   output logic [3:0]                      lsu_axi_arcache,\n   output logic [2:0]                      lsu_axi_arprot,\n   output logic [3:0]                      lsu_axi_arqos,\n\n   input  logic                            lsu_axi_rvalid,\n   output logic                            lsu_axi_rready,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_rid,\n   input  logic [63:0]                     lsu_axi_rdata,\n   input  logic [1:0]                      lsu_axi_rresp,\n   input  logic                            lsu_axi_rlast,\n\n   //-------------------------- IFU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            ifu_axi_awvalid,\n   input  logic                            ifu_axi_awready,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_awid,\n   output logic [31:0]                     ifu_axi_awaddr,\n   output logic [3:0]                      ifu_axi_awregion,\n   output logic [7:0]                      ifu_axi_awlen,\n   output logic [2:0]                      ifu_axi_awsize,\n   output logic [1:0]                      ifu_axi_awburst,\n   output logic                            ifu_axi_awlock,\n   output logic [3:0]                      ifu_axi_awcache,\n   output logic [2:0]                      ifu_axi_awprot,\n   output logic [3:0]                      ifu_axi_awqos,\n\n   output logic                            ifu_axi_wvalid,\n   input  logic                            ifu_axi_wready,\n   output logic [63:0]                     ifu_axi_wdata,\n   output logic [7:0]                      ifu_axi_wstrb,\n   output logic                            ifu_axi_wlast,\n\n   input  logic                            ifu_axi_bvalid,\n   output logic                            ifu_axi_bready,\n   input  logic [1:0]                      ifu_axi_bresp,\n   input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_bid,\n\n   // AXI Read Channels\n   output logic                            ifu_axi_arvalid,\n   input  logic                            ifu_axi_arready,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_arid,\n   output logic [31:0]                     ifu_axi_araddr,\n   output logic [3:0]                      ifu_axi_arregion,\n   output logic [7:0]                      ifu_axi_arlen,\n   output logic [2:0]                      ifu_axi_arsize,\n   output logic [1:0]                      ifu_axi_arburst,\n   output logic                            ifu_axi_arlock,\n   output logic [3:0]                      ifu_axi_arcache,\n   output logic [2:0]                      ifu_axi_arprot,\n   output logic [3:0]                      ifu_axi_arqos,\n\n   input  logic                            ifu_axi_rvalid,\n   output logic                            ifu_axi_rready,\n   input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_rid,\n   input  logic [63:0]                     ifu_axi_rdata,\n   input  logic [1:0]                      ifu_axi_rresp,\n   input  logic                            ifu_axi_rlast,\n\n   //-------------------------- SB AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            sb_axi_awvalid,\n   input  logic                            sb_axi_awready,\n   output logic [pt.SB_BUS_TAG-1:0]        sb_axi_awid,\n   output logic [31:0]                     sb_axi_awaddr,\n   output logic [3:0]                      sb_axi_awregion,\n   output logic [7:0]                      sb_axi_awlen,\n   output logic [2:0]                      sb_axi_awsize,\n   output logic [1:0]                      sb_axi_awburst,\n   output logic                            sb_axi_awlock,\n   output logic [3:0]                      sb_axi_awcache,\n   output logic [2:0]                      sb_axi_awprot,\n   output logic [3:0]                      sb_axi_awqos,\n\n   output logic                            sb_axi_wvalid,\n   input  logic                            sb_axi_wready,\n   output logic [63:0]                     sb_axi_wdata,\n   output logic [7:0]                      sb_axi_wstrb,\n   output logic                            sb_axi_wlast,\n\n   input  logic                            sb_axi_bvalid,\n   output logic                            sb_axi_bready,\n   input  logic [1:0]                      sb_axi_bresp,\n   input  logic [pt.SB_BUS_TAG-1:0]        sb_axi_bid,\n\n   // AXI Read Channels\n   output logic                            sb_axi_arvalid,\n   input  logic                            sb_axi_arready,\n   output logic [pt.SB_BUS_TAG-1:0]        sb_axi_arid,\n   output logic [31:0]                     sb_axi_araddr,\n   output logic [3:0]                      sb_axi_arregion,\n   output logic [7:0]                      sb_axi_arlen,\n   output logic [2:0]                      sb_axi_arsize,\n   output logic [1:0]                      sb_axi_arburst,\n   output logic                            sb_axi_arlock,\n   output logic [3:0]                      sb_axi_arcache,\n   output logic [2:0]                      sb_axi_arprot,\n   output logic [3:0]                      sb_axi_arqos,\n\n   input  logic                            sb_axi_rvalid,\n   output logic                            sb_axi_rready,\n   input  logic [pt.SB_BUS_TAG-1:0]        sb_axi_rid,\n   input  logic [63:0]                     sb_axi_rdata,\n   input  logic [1:0]                      sb_axi_rresp,\n   input  logic                            sb_axi_rlast,\n\n   //-------------------------- DMA AXI signals--------------------------\n   // AXI Write Channels\n   input  logic                            dma_axi_awvalid,\n   output logic                            dma_axi_awready,\n   input  logic [pt.DMA_BUS_TAG-1:0]       dma_axi_awid,\n   input  logic [31:0]                     dma_axi_awaddr,\n   input  logic [2:0]                      dma_axi_awsize,\n   input  logic [2:0]                      dma_axi_awprot,\n   input  logic [7:0]                      dma_axi_awlen,\n   input  logic [1:0]                      dma_axi_awburst,\n\n\n   input  logic                            dma_axi_wvalid,\n   output logic                            dma_axi_wready,\n   input  logic [63:0]                     dma_axi_wdata,\n   input  logic [7:0]                      dma_axi_wstrb,\n   input  logic                            dma_axi_wlast,\n\n   output logic                            dma_axi_bvalid,\n   input  logic                            dma_axi_bready,\n   output logic [1:0]                      dma_axi_bresp,\n   output logic [pt.DMA_BUS_TAG-1:0]       dma_axi_bid,\n\n   // AXI Read Channels\n   input  logic                            dma_axi_arvalid,\n   output logic                            dma_axi_arready,\n   input  logic [pt.DMA_BUS_TAG-1:0]       dma_axi_arid,\n   input  logic [31:0]                     dma_axi_araddr,\n   input  logic [2:0]                      dma_axi_arsize,\n   input  logic [2:0]                      dma_axi_arprot,\n   input  logic [7:0]                      dma_axi_arlen,\n   input  logic [1:0]                      dma_axi_arburst,\n\n   output logic                            dma_axi_rvalid,\n   input  logic                            dma_axi_rready,\n   output logic [pt.DMA_BUS_TAG-1:0]       dma_axi_rid,\n   output logic [63:0]                     dma_axi_rdata,\n   output logic [1:0]                      dma_axi_rresp,\n   output logic                            dma_axi_rlast,\n`endif\n\n`ifdef RV_BUILD_AHB_LITE\n //// AHB LITE BUS\n   output logic [31:0]                     haddr,\n   output logic [2:0]                      hburst,\n   output logic                            hmastlock,\n   output logic [3:0]                      hprot,\n   output logic [2:0]                      hsize,\n   output logic [1:0]                      htrans,\n   output logic                            hwrite,\n\n   input logic [63:0]                      hrdata,\n   input logic                             hready,\n   input logic                             hresp,\n\n   // LSU AHB Master\n   output logic [31:0]                     lsu_haddr,\n   output logic [2:0]                      lsu_hburst,\n   output logic                            lsu_hmastlock,\n   output logic [3:0]                      lsu_hprot,\n   output logic [2:0]                      lsu_hsize,\n   output logic [1:0]                      lsu_htrans,\n   output logic                            lsu_hwrite,\n   output logic [63:0]                     lsu_hwdata,\n\n   input logic [63:0]                      lsu_hrdata,\n   input logic                             lsu_hready,\n   input logic                             lsu_hresp,\n   // Debug Syster Bus AHB\n   output logic [31:0]                     sb_haddr,\n   output logic [2:0]                      sb_hburst,\n   output logic                            sb_hmastlock,\n   output logic [3:0]                      sb_hprot,\n   output logic [2:0]                      sb_hsize,\n   output logic [1:0]                      sb_htrans,\n   output logic                            sb_hwrite,\n   output logic [63:0]                     sb_hwdata,\n\n   input  logic [63:0]                     sb_hrdata,\n   input  logic                            sb_hready,\n   input  logic                            sb_hresp,\n\n   // DMA Slave\n   input logic                             dma_hsel,\n   input logic [31:0]                      dma_haddr,\n   input logic [2:0]                       dma_hburst,\n   input logic                             dma_hmastlock,\n   input logic [3:0]                       dma_hprot,\n   input logic [2:0]                       dma_hsize,\n   input logic [1:0]                       dma_htrans,\n   input logic                             dma_hwrite,\n   input logic [63:0]                      dma_hwdata,\n   input logic                             dma_hreadyin,\n\n   output logic [63:0]                     dma_hrdata,\n   output logic                            dma_hreadyout,\n   output logic                            dma_hresp,\n`endif\n   // clk ratio signals\n   input logic                             lsu_bus_clk_en, // Clock ratio b/w cpu core clk & AHB master interface\n   input logic                             ifu_bus_clk_en, // Clock ratio b/w cpu core clk & AHB master interface\n   input logic                             dbg_bus_clk_en, // Clock ratio b/w cpu core clk & AHB master interface\n   input logic                             dma_bus_clk_en, // Clock ratio b/w cpu core clk & AHB slave interface\n\n   // ICCM/DCCM ECC status\n   output logic                            iccm_ecc_single_error,\n   output logic                            iccm_ecc_double_error,\n   output logic                            dccm_ecc_single_error,\n   output logic                            dccm_ecc_double_error,\n\n // all of these test inputs are brought to top-level; must be tied off based on usage by physical design (ie. icache or not, iccm or not, dccm or not)\n\n   input                                   el2_ic_data_ext_in_pkt_t  [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] ic_data_ext_in_pkt,\n   input                                   el2_ic_tag_ext_in_pkt_t  [pt.ICACHE_NUM_WAYS-1:0] ic_tag_ext_in_pkt,\n\n   input logic                             timer_int,\n   input logic                             soft_int,\n   input logic [pt.PIC_TOTAL_INT:1]        extintsrc_req,\n\n   output logic                            dec_tlu_perfcnt0, // toggles when slot0 perf counter 0 has an event inc\n   output logic                            dec_tlu_perfcnt1,\n   output logic                            dec_tlu_perfcnt2,\n   output logic                            dec_tlu_perfcnt3,\n\n   // ports added by the soc team\n   input logic                             jtag_tck,    // JTAG clk\n   input logic                             jtag_tms,    // JTAG TMS\n   input logic                             jtag_tdi,    // JTAG tdi\n   input logic                             jtag_trst_n, // JTAG Reset\n   output logic                            jtag_tdo,    // JTAG TDO\n\n   input logic [31:4] core_id,\n\n   // Memory Export Interface\n   el2_mem_if.veer_sram_src                el2_mem_export,\n\n   // external MPC halt/run interface\n   input logic                             mpc_debug_halt_req, // Async halt request\n   input logic                             mpc_debug_run_req,  // Async run request\n   input logic                             mpc_reset_run_req,  // Run/halt after reset\n   output logic                            mpc_debug_halt_ack, // Halt ack\n   output logic                            mpc_debug_run_ack,  // Run ack\n   output logic                            debug_brkpt_status, // debug breakpoint\n\n   input logic                             i_cpu_halt_req,      // Async halt req to CPU\n   output logic                            o_cpu_halt_ack,      // core response to halt\n   output logic                            o_cpu_halt_status,   // 1'b1 indicates core is halted\n   output logic                            o_debug_mode_status, // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n   input logic                             i_cpu_run_req, // Async restart req to CPU\n   output logic                            o_cpu_run_ack, // Core response to run req\n   input logic                             scan_mode,     // To enable scan mode\n   input logic                             mbist_mode,    // to enable mbist\n\n   // DMI port for uncore\n   input logic                             dmi_uncore_enable,\n   output logic                            dmi_uncore_en,\n   output logic                            dmi_uncore_wr_en,\n   output logic                     [ 6:0] dmi_uncore_addr,\n   output logic                     [31:0] dmi_uncore_wdata,\n   input logic                      [31:0] dmi_uncore_rdata\n);\n\n   logic                             active_l2clk;\n   logic                             free_l2clk;\n\n   // DCCM ports\n   logic         dccm_wren;\n   logic         dccm_rden;\n   logic [pt.DCCM_BITS-1:0]         dccm_wr_addr_lo;\n   logic [pt.DCCM_BITS-1:0]         dccm_wr_addr_hi;\n   logic [pt.DCCM_BITS-1:0]         dccm_rd_addr_lo;\n   logic [pt.DCCM_BITS-1:0]         dccm_rd_addr_hi;\n   logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_lo;\n   logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_hi;\n\n   logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_lo;\n   logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_hi;\n\n   // PIC ports\n\n   // Icache & Itag ports\n   logic [31:1]  ic_rw_addr;\n   logic [pt.ICACHE_NUM_WAYS-1:0]   ic_wr_en  ;     // Which way to write\n   logic         ic_rd_en ;\n\n\n   logic [pt.ICACHE_NUM_WAYS-1:0]   ic_tag_valid;   // Valid from the I$ tag valid outside (in flops).\n\n   logic [pt.ICACHE_NUM_WAYS-1:0]   ic_rd_hit;      // ic_rd_hit[3:0]\n   logic         ic_tag_perr;                       // Ic tag parity error\n\n   logic [pt.ICACHE_INDEX_HI:3]  ic_debug_addr;     // Read/Write addresss to the Icache.\n   logic         ic_debug_rd_en;                    // Icache debug rd\n   logic         ic_debug_wr_en;                    // Icache debug wr\n   logic         ic_debug_tag_array;                // Debug tag array\n   logic [pt.ICACHE_NUM_WAYS-1:0]   ic_debug_way;   // Debug way. Rd or Wr.\n\n   logic [25:0]  ictag_debug_rd_data;               // Debug icache tag.\n   logic [pt.ICACHE_BANKS_WAY-1:0][70:0]  ic_wr_data;\n   logic [63:0]  ic_rd_data;\n   logic [70:0]  ic_debug_rd_data;                  // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   logic [70:0]  ic_debug_wr_data;                  // Debug wr cache.\n\n   logic [pt.ICACHE_BANKS_WAY-1:0] ic_eccerr;       // ecc error per bank\n   logic [pt.ICACHE_BANKS_WAY-1:0] ic_parerr;       // parity error per bank\n\n   logic [63:0]  ic_premux_data;\n   logic         ic_sel_premux_data;\n\n   // ICCM ports\n   logic [pt.ICCM_BITS-1:1]    iccm_rw_addr;\n   logic           iccm_wren;\n   logic           iccm_rden;\n   logic [2:0]     iccm_wr_size;\n   logic [77:0]    iccm_wr_data;\n   logic           iccm_buf_correct_ecc;\n   logic           iccm_correction_state;\n\n   logic [63:0]    iccm_rd_data;\n   logic [77:0]    iccm_rd_data_ecc;\n\n   logic        core_rst_l;                         // Core reset including rst_l and dbg_rst_l\n   logic        jtag_tdoEn;\n\n   logic        dccm_clk_override;\n   logic        icm_clk_override;\n   "}
{"text": "logic        dec_tlu_core_ecc_disable;\n\n\n   // zero out the signals not presented at the wrapper instantiation level\n`ifdef RV_BUILD_AXI4\n\n //// AHB LITE BUS\n   logic [31:0]              haddr;\n   logic [2:0]               hburst;\n   logic                     hmastlock;\n   logic [3:0]               hprot;\n   logic [2:0]               hsize;\n   logic [1:0]               htrans;\n   logic                     hwrite;\n\n   logic [63:0]              hrdata;\n   logic                     hready;\n   logic                     hresp;\n\n   // LSU AHB Master\n   logic [31:0]              lsu_haddr;\n   logic [2:0]               lsu_hburst;\n   logic                     lsu_hmastlock;\n   logic [3:0]               lsu_hprot;\n   logic [2:0]               lsu_hsize;\n   logic [1:0]               lsu_htrans;\n   logic                     lsu_hwrite;\n   logic [63:0]              lsu_hwdata;\n\n   logic [63:0]              lsu_hrdata;\n   logic                     lsu_hready;\n   logic                     lsu_hresp;\n   // Debug Syster Bus AHB\n   logic [31:0]              sb_haddr;\n   logic [2:0]               sb_hburst;\n   logic                     sb_hmastlock;\n   logic [3:0]               sb_hprot;\n   logic [2:0]               sb_hsize;\n   logic [1:0]               sb_htrans;\n   logic                     sb_hwrite;\n   logic [63:0]              sb_hwdata;\n\n    logic [63:0]             sb_hrdata;\n    logic                    sb_hready;\n    logic                    sb_hresp;\n\n   // DMA Slave\n   logic                     dma_hsel;\n   logic [31:0]              dma_haddr;\n   logic [2:0]               dma_hburst;\n   logic                     dma_hmastlock;\n   logic [3:0]               dma_hprot;\n   logic [2:0]               dma_hsize;\n   logic [1:0]               dma_htrans;\n   logic                     dma_hwrite;\n   logic [63:0]              dma_hwdata;\n   logic                     dma_hreadyin;\n\n   logic [63:0]              dma_hrdata;\n   logic                     dma_hreadyout;\n   logic                     dma_hresp;\n\n\n\n   // AHB\n   assign  hrdata[63:0]                           = '0;\n   assign  hready                                 = '0;\n   assign  hresp                                  = '0;\n   // LSU\n   assign  lsu_hrdata[63:0]                       = '0;\n   assign  lsu_hready                             = '0;\n   assign  lsu_hresp                              = '0;\n   // Debu\n   assign  sb_hrdata[63:0]                        = '0;\n   assign  sb_hready                              = '0;\n   assign  sb_hresp                               = '0;\n\n   // DMA\n   assign  dma_hsel                               = '0;\n   assign  dma_haddr[31:0]                        = '0;\n   assign  dma_hburst[2:0]                        = '0;\n   assign  dma_hmastlock                          = '0;\n   assign  dma_hprot[3:0]                         = '0;\n   assign  dma_hsize[2:0]                         = '0;\n   assign  dma_htrans[1:0]                        = '0;\n   assign  dma_hwrite                             = '0;\n   assign  dma_hwdata[63:0]                       = '0;\n   assign  dma_hreadyin                           = '0;\n\n`endif //  `ifdef RV_BUILD_AXI4\n\n\n`ifdef RV_BUILD_AHB_LITE\n   wire                            lsu_axi_awvalid;\n   wire                            lsu_axi_awready;\n   wire [pt.LSU_BUS_TAG-1:0]       lsu_axi_awid;\n   wire [31:0]                     lsu_axi_awaddr;\n   wire [3:0]                      lsu_axi_awregion;\n   wire [7:0]                      lsu_axi_awlen;\n   wire [2:0]                      lsu_axi_awsize;\n   wire [1:0]                      lsu_axi_awburst;\n   wire                            lsu_axi_awlock;\n   wire [3:0]                      lsu_axi_awcache;\n   wire [2:0]                      lsu_axi_awprot;\n   wire [3:0]                      lsu_axi_awqos;\n\n   wire                            lsu_axi_wvalid;\n   wire                            lsu_axi_wready;\n   wire [63:0]                     lsu_axi_wdata;\n   wire [7:0]                      lsu_axi_wstrb;\n   wire                            lsu_axi_wlast;\n\n   wire                            lsu_axi_bvalid;\n   wire                            lsu_axi_bready;\n   wire [1:0]                      lsu_axi_bresp;\n   wire [pt.LSU_BUS_TAG-1:0]       lsu_axi_bid;\n\n   // AXI Read Channels\n   wire                            lsu_axi_arvalid;\n   wire                            lsu_axi_arready;\n   wire [pt.LSU_BUS_TAG-1:0]       lsu_axi_arid;\n   wire [31:0]                     lsu_axi_araddr;\n   wire [3:0]                      lsu_axi_arregion;\n   wire [7:0]                      lsu_axi_arlen;\n   wire [2:0]                      lsu_axi_arsize;\n   wire [1:0]                      lsu_axi_arburst;\n   wire                            lsu_axi_arlock;\n   wire [3:0]                      lsu_axi_arcache;\n   wire [2:0]                      lsu_axi_arprot;\n   wire [3:0]                      lsu_axi_arqos;\n\n   wire                            lsu_axi_rvalid;\n   wire                            lsu_axi_rready;\n   wire [pt.LSU_BUS_TAG-1:0]       lsu_axi_rid;\n   wire [63:0]                     lsu_axi_rdata;\n   wire [1:0]                      lsu_axi_rresp;\n   wire                            lsu_axi_rlast;\n\n   //-------------------------- IFU AXI signals--------------------------\n   // AXI Write Channels\n   wire                            ifu_axi_awvalid;\n   wire                            ifu_axi_awready;\n   wire [pt.IFU_BUS_TAG-1:0]       ifu_axi_awid;\n   wire [31:0]                     ifu_axi_awaddr;\n   wire [3:0]                      ifu_axi_awregion;\n   wire [7:0]                      ifu_axi_awlen;\n   wire [2:0]                      ifu_axi_awsize;\n   wire [1:0]                      ifu_axi_awburst;\n   wire                            ifu_axi_awlock;\n   wire [3:0]                      ifu_axi_awcache;\n   wire [2:0]                      ifu_axi_awprot;\n   wire [3:0]                      ifu_axi_awqos;\n\n   wire                            ifu_axi_wvalid;\n   wire                            ifu_axi_wready;\n   wire [63:0]                     ifu_axi_wdata;\n   wire [7:0]                      ifu_axi_wstrb;\n   wire                            ifu_axi_wlast;\n\n   wire                            ifu_axi_bvalid;\n   wire                            ifu_axi_bready;\n   wire [1:0]                      ifu_axi_bresp;\n   wire [pt.IFU_BUS_TAG-1:0]      ifu_axi_bid;\n\n   // AXI Read Channels\n   wire                            ifu_axi_arvalid;\n   wire                            ifu_axi_arready;\n   wire [pt.IFU_BUS_TAG-1:0]       ifu_axi_arid;\n   wire [31:0]                     ifu_axi_araddr;\n   wire [3:0]                      ifu_axi_arregion;\n   wire [7:0]                      ifu_axi_arlen;\n   wire [2:0]                      ifu_axi_arsize;\n   wire [1:0]                      ifu_axi_arburst;\n   wire                            ifu_axi_arlock;\n   wire [3:0]                      ifu_axi_arcache;\n   wire [2:0]                      ifu_axi_arprot;\n   wire [3:0]                      ifu_axi_arqos;\n\n   wire                            ifu_axi_rvalid;\n   wire                            ifu_axi_rready;\n   wire [pt.IFU_BUS_TAG-1:0]       ifu_axi_rid;\n   wire [63:0]                     ifu_axi_rdata;\n   wire [1:0]                      ifu_axi_rresp;\n   wire                            ifu_axi_rlast;\n\n   //-------------------------- SB AXI signals--------------------------\n   // AXI Write Channels\n   wire                            sb_axi_awvalid;\n   wire                            sb_axi_awready;\n   wire [pt.SB_BUS_TAG-1:0]        sb_axi_awid;\n   wire [31:0]                     sb_axi_awaddr;\n   wire [3:0]                      sb_axi_awregion;\n   wire [7:0]                      sb_axi_awlen;\n   wire [2:0]                      sb_axi_awsize;\n   wire [1:0]                      sb_axi_awburst;\n   wire                            sb_axi_awlock;\n   wire [3:0]                      sb_axi_awcache;\n   wire [2:0]                      sb_axi_awprot;\n   wire [3:0]                      sb_axi_awqos;\n\n   wire                            sb_axi_wvalid;\n   wire                            sb_axi_wready;\n   wire [63:0]                     sb_axi_wdata;\n   wire [7:0]                      sb_axi_wstrb;\n   wire                            sb_axi_wlast;\n\n   wire                            sb_axi_bvalid;\n   wire                            sb_axi_bready;\n   wire [1:0]                      sb_axi_bresp;\n   wire [pt.SB_BUS_TAG-1:0]        sb_axi_bid;\n\n   // AXI Read Channels\n   wire                            sb_axi_arvalid;\n   wire                            sb_axi_arready;\n   wire [pt.SB_BUS_TAG-1:0]        sb_axi_arid;\n   wire [31:0]                     sb_axi_araddr;\n   wire [3:0]                      sb_axi_arregion;\n   wire [7:0]                      sb_axi_arlen;\n   wire [2:0]                      sb_axi_arsize;\n   wire [1:0]                      sb_axi_arburst;\n   wire                            sb_axi_arlock;\n   wire [3:0]                      sb_axi_arcache;\n   wire [2:0]                      sb_axi_arprot;\n   wire [3:0]                      sb_axi_arqos;\n\n   wire                            sb_axi_rvalid;\n   wire                            sb_axi_rready;\n   wire [pt.SB_BUS_TAG-1:0]        sb_axi_rid;\n   wire [63:0]                     sb_axi_rdata;\n   wire [1:0]                      sb_axi_rresp;\n   wire                            sb_axi_rlast;\n\n   //-------------------------- DMA AXI signals--------------------------\n   // AXI Write Channels\n   wire                         dma_axi_awvalid;\n   wire                         dma_axi_awready;\n   wire [pt.DMA_BUS_TAG-1:0]    dma_axi_awid;\n   wire [31:0]                  dma_axi_awaddr;\n   wire [2:0]                   dma_axi_awsize;\n   wire [2:0]                   dma_axi_awprot;\n   wire [7:0]                   dma_axi_awlen;\n   wire [1:0]                   dma_axi_awburst;\n\n\n   wire                         dma_axi_wvalid;\n   wire                         dma_axi_wready;\n   wire [63:0]                  dma_axi_wdata;\n   wire [7:0]                   dma_axi_wstrb;\n   wire                         dma_axi_wlast;\n\n   wire                         dma_axi_bvalid;\n   wire                         dma_axi_bready;\n   wire [1:0]                   dma_axi_bresp;\n   wire [pt.DMA_BUS_TAG-1:0]    dma_axi_bid;\n\n   // AXI Read Channels\n   wire                         dma_axi_arvalid;\n   wire                         dma_axi_arready;\n   wire [pt.DMA_BUS_TAG-1:0]    dma_axi_arid;\n   wire [31:0]                  dma_axi_araddr;\n   wire [2:0]                   dma_axi_arsize;\n   wire [2:0]                   dma_axi_arprot;\n   wire [7:0]                   dma_axi_arlen;\n   wire [1:0]                   dma_axi_arburst;\n\n   wire                         dma_axi_rvalid;\n   wire                         dma_axi_rready;\n   wire [pt.DMA_BUS_TAG-1:0]    dma_axi_rid;\n   wire [63:0]                  dma_axi_rdata;\n   wire [1:0]                   dma_axi_rresp;\n   wire                         dma_axi_rlast;\n\n   // AXI\n   assign ifu_axi_awready = 1'b1;\n   assign ifu_axi_wready = 1'b1;\n   assign ifu_axi_bvalid = '0;\n   assign ifu_axi_bresp[1:0] = '0;\n   assign ifu_axi_bid[pt.IFU_BUS_TAG-1:0] = '0;\n\n`endif //  `ifdef RV_BUILD_AHB_LITE\n\n   // DMI (core)\n   logic                   dmi_en;\n   logic [6:0]             dmi_addr;\n   logic                   dmi_wr_en;\n   logic [31:0]            dmi_wdata;\n   logic [31:0]            dmi_rdata;\n\n   // DMI (core)\n   logic                   dmi_reg_en;\n   logic [6:0]             dmi_reg_addr;\n   logic                   dmi_reg_wr_en;\n   logic [31:0]            dmi_reg_wdata;\n   logic [31:0]            dmi_reg_rdata;\n\n   // Instantiate the el2_veer core\n   el2_veer #(.pt(pt)) veer (\n                                .clk(clk),\n                                .*\n                                );\n\n   // Instantiate the mem\n   el2_mem  #(.pt(pt)) mem (\n                             .clk(active_l2clk),\n                             .rst_l(core_rst_l),\n                             .mem_export(el2_mem_export),\n                             .*\n                             );\n\n\n   //  JTAG/DMI instance\n   dmi_wrapper  dmi_wrapper (\n    // JTAG signals\n    .trst_n      (jtag_trst_n),     // JTAG reset\n    .tck         (jtag_tck),        // JTAG clock\n    .tms         (jtag_tms),        // Test mode select\n    .tdi         (jtag_tdi),        // Test Data Input\n    .tdo         (jtag_tdo),        // Test Data Output\n    .tdoEnable   (),\n    // Processor Signals\n    .core_rst_n  (dbg_rst_l),       // Debug reset, active low\n    .core_clk    (clk),             // Core clock\n    .jtag_id     (jtag_id),         // JTAG ID\n    .rd_data     (dmi_rdata),       // Read data from  Processor\n    .reg_wr_data (dmi_wdata),       // Write data to Processor\n    .reg_wr_addr (dmi_addr),        // Write address to Processor\n    .reg_en      (dmi_en),          // Write interface bit to Processor\n    .reg_wr_en   (dmi_wr_en),       // Write enable to Processor\n    .dmi_hard_reset   ()\n   );\n\n   // DMI core/uncore mux\n   dmi_mux dmi_mux (\n    .uncore_enable      (dmi_uncore_enable),\n\n    .dmi_en             (dmi_en),\n    .dmi_wr_en          (dmi_wr_en),\n    .dmi_addr           (dmi_addr),\n    .dmi_wdata          (dmi_wdata),\n    .dmi_rdata          (dmi_rdata),\n\n    .dmi_core_en        (dmi_reg_en),\n    .dmi_core_wr_en     (dmi_reg_wr_en),\n    .dmi_core_addr      (dmi_reg_addr),\n    .dmi_core_wdata     (dmi_reg_wdata),\n    .dmi_core_rdata     (dmi_reg_rdata),\n\n    .dmi_uncore_en      (dmi_uncore_en),\n    .dmi_uncore_wr_en   (dmi_uncore_wr_en),\n    .dmi_uncore_addr    (dmi_uncore_addr),\n    .dmi_uncore_wdata   (dmi_uncore_wdata),\n    .dmi_uncore_rdata   (dmi_uncore_rdata)\n   );\n\n`ifdef RV_ASSERT_ON\n  // to avoid internal assertions failure at time 0\n  initial begin\n    $assertoff(0, veer);\n    @(negedge clk) $asserton(0, veer);\n  end\n`endif\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or it's affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n`define EL2_LOCAL_RAM_TEST_IO          \\\ninput logic WE,              \\\ninput logic ME,              \\\ninput logic CLK,             \\\ninput logic TEST1,           \\\ninput logic RME,             \\\ninput logic  [3:0] RM,       \\\ninput logic LS,              \\\ninput logic DS,              \\\ninput logic SD,              \\\ninput logic TEST_RNM,        \\\ninput logic BC1,             \\\ninput logic BC2,             \\\noutput logic ROP\n\n`define EL2_RAM(depth, width)              \\\nmodule ram_``depth``x``width(               \\\n   input logic [$clog2(depth)-1:0] ADR,     \\\n   input logic [(width-1):0] D,             \\\n   output logic [(width-1):0] Q,            \\\n    `EL2_LOCAL_RAM_TEST_IO                 \\\n);                                          \\\nreg [(width-1):0] ram_core [(depth-1):0];   \\\n`ifdef GTLSIM                               \\\ninteger i;                                  \\\ninitial begin                               \\\n   for (i=0; i<depth; i=i+1)                \\\n     ram_core[i] = '0;                      \\\nend                                         \\\n`endif                                      \\\nalways @(posedge CLK) begin                 \\\n`ifdef GTLSIM                               \\\n   if (ME && WE) ram_core[ADR] <= D;        \\\n`else                                       \\\n   if (ME && WE) begin ram_core[ADR] <= D; Q <= 'x; end  \\\n`endif                                      \\\n   if (ME && ~WE) Q <= ram_core[ADR];       \\\nend                                         \\\nassign ROP = ME;                            \\\n                                            \\\nendmodule\n\n`define EL2_RAM_BE(depth, width)           \\\nmodule ram_be_``depth``x``width(            \\\n   input logic [$clog2(depth)-1:0] ADR,     \\\n   input logic [(width-1):0] D, WEM,        \\\n   output logic [(width-1):0] Q,            \\\n    `EL2_LOCAL_RAM_TEST_IO                 \\\n);                                          \\\nreg [(width-1):0] ram_core [(depth-1):0];   \\\n`ifdef GTLSIM                               \\\ninteger i;                                  \\\ninitial begin                               \\\n   for (i=0; i<depth; i=i+1)                \\\n     ram_core[i] = '0;                      \\\nend                                         \\\n`endif                                      \\\nalways @(posedge CLK) begin                 \\\n`ifdef GTLSIM                               \\\n   if (ME && WE)       ram_core[ADR] <= D & WEM | ~WEM & ram_core[ADR];      \\\n`else                                       \\\n   if (ME && WE) begin ram_core[ADR] <= D & WEM | ~WEM & ram_core[ADR]; Q <= 'x; end  \\\n`endif                                      \\\n   if (ME && ~WE) Q <= ram_core[ADR];          \\\nend                                         \\\nassign ROP = ME;                            \\\n                                            \\\nendmodule\n\n// parameterizable RAM for verilator sims\nmodule el2_ram #(depth=4096, width=39) (\ninput logic [$clog2(depth)-1:0] ADR,\ninput logic [(width-1):0] D,\noutput logic [(width-1):0] Q,\n `EL2_LOCAL_RAM_TEST_IO\n);\nreg [(width-1):0] ram_core [(depth-1):0];\n\nalways @(posedge CLK) begin\n`ifdef GTLSIM\n   if (ME && WE)       ram_core[ADR] <= D;\n`else\n   if (ME && WE) begin ram_core[ADR] <= D; Q <= 'x; end\n`endif\n   if (ME && ~WE) Q <= ram_core[ADR];\nend\nendmodule\n\n//=========================================================================================================================\n//=================================== START OF CCM  =======================================================================\n//============= Possible sram sizes for a 39 bit wide memory ( 4 bytes + 7 bits ECC ) =====================================\n//-------------------------------------------------------------------------------------------------------------------------\n`EL2_RAM(32768, 39)\n`EL2_RAM(16384, 39)\n`EL2_RAM(8192, 39)\n`EL2_RAM(4096, 39)\n`EL2_RAM(3072, 39)\n`EL2_RAM(2048, 39)\n`EL2_RAM(1536, 39)     // need this for the 48KB DCCM option)\n`EL2_RAM(1024, 39)\n`EL2_RAM(768, 39)\n`EL2_RAM(512, 39)\n`EL2_RAM(256, 39)\n`EL2_RAM(128, 39)\n`EL2_RAM(1024, 20)\n`EL2_RAM(512, 20)\n`EL2_RAM(256, 20)\n`EL2_RAM(128, 20)\n`EL2_RAM(64, 20)\n`EL2_RAM(4096, 34)\n`EL2_RAM(2048, 34)\n`EL2_RAM(1024, 34)\n`EL2_RAM(512, 34)\n`EL2_RAM(256, 34)\n`EL2_RAM(128, 34)\n`EL2_RAM(64, 34)\n`EL2_RAM(8192, 68)\n`EL2_RAM(4096, 68)\n`EL2_RAM(2048, 68)\n`EL2_RAM(1024, 68)\n`EL2_RAM(512, 68)\n`EL2_RAM(256, 68)\n`EL2_RAM(128, 68)\n`EL2_RAM(64, 68)\n`EL2_RAM(8192, 71)\n`EL2_RAM(4096, 71)\n`EL2_RAM(2048, 71)\n`EL2_RAM(1024, 71)\n`EL2_RAM(512, 71)\n`EL2_RAM(256, 71)\n`EL2_RAM(128, 71)\n`EL2_RAM(64, 71)\n`EL2_RAM(4096, 42)\n`EL2_RAM(2048, 42)\n`EL2_RAM(1024, 42)\n`EL2_RAM(512, 42)\n`EL2_RAM(256, 42)\n`EL2_RAM(128, 42)\n`EL2_RAM(64, 42)\n`EL2_RAM(4096, 22)\n`EL2_RAM(2048, 22)\n`EL2_RAM(1024, 22)\n`EL2_RAM(512, 22)\n`EL2_RAM(256, 22)\n`EL2_RAM(128, 22)\n`EL2_RAM(64, 22)\n`EL2_RAM(1024, 26)\n`EL2_RAM(4096, 26)\n`EL2_RAM(2048, 26)\n`EL2_RAM(512, 26)\n`EL2_RAM(256, 26)\n`EL2_RAM(128, 26)\n`EL2_RAM(64, 26)\n`EL2_RAM(32, 26)\n`EL2_RAM(32, 22)\n`EL2_RAM_BE(8192, 142)\n`EL2_RAM_BE(4096, 142)\n`EL2_RAM_BE(2048, 142)\n`EL2_RAM_BE(1024, 142)\n`EL2_RAM_BE(512, 142)\n`EL2_RAM_BE(256, 142)\n`EL2_RAM_BE(128, 142)\n`EL2_RAM_BE(64, 142)\n`EL2_RAM_BE(8192, 284)\n`EL2_RAM_BE(4096, 284)\n`EL2_RAM_BE(2048, 284)\n`EL2_RAM_BE(1024, 284)\n`EL2_RAM_BE(512, 284)\n`EL2_RAM_BE(256, 284)\n`EL2_RAM_BE(128, 284)\n`EL2_RAM_BE(64, 284)\n`EL2_RAM_BE(8192, 136)\n`EL2_RAM_BE(4096, 136)\n`EL2_RAM_BE(2048, 136)\n`EL2_RAM_BE(1024, 136)\n`EL2_RAM_BE(512, 136)\n`EL2_RAM_BE(256, 136)\n`EL2_RAM_BE(128, 136)\n`EL2_RAM_BE(64, 136)\n`EL2_RAM_BE(8192, 272)\n`EL2_RAM_BE(4096, 272)\n`EL2_RAM_BE(2048, 272)\n`EL2_RAM_BE(1024, 272)\n`EL2_RAM_BE(512, 272)\n`EL2_RAM_BE(256, 272)\n`EL2_RAM_BE(128, 272)\n`EL2_RAM_BE(64, 272)\n`EL2_RAM_BE(4096, 52)\n`EL2_RAM_BE(2048, 52)\n`EL2_RAM_BE(1024, 52)\n`EL2_RAM_BE(512, 52)\n`EL2_RAM_BE(256, 52)\n`EL2_RAM_BE(128, 52)\n`EL2_RAM_BE(64, 52)\n`EL2_RAM_BE(32, 52)\n`EL2_RAM_BE(4096, 104)\n`EL2_RAM_BE(2048, 104)\n`EL2_RAM_BE(1024, 104)\n`EL2_RAM_BE(512, 104)\n`EL2_RAM_BE(256, 104)\n`EL2_RAM_BE(128, 104)\n`EL2_RAM_BE(64, 104)\n`EL2_RAM_BE(32, 104)\n`EL2_RAM_BE(4096, 44)\n`EL2_RAM_BE(2048, 44)\n`EL2_RAM_BE(1024, 44)\n`EL2_RAM_BE(512, 44)\n`EL2_RAM_BE(256, 44)\n`EL2_RAM_BE(128, 44)\n`EL2_RAM_BE(64, 44)\n`EL2_RAM_BE(32, 44)\n`EL2_RAM_BE(4096, 88)\n`EL2_RAM_BE(2048, 88)\n`EL2_RAM_BE(1024, 88)\n`EL2_RAM_BE(512, 88)\n`EL2_RAM_BE(256, 88)\n`EL2_RAM_BE(128, 88)\n`EL2_RAM_BE(64, 88)\n`EL2_RAM_BE(32, 88)\n`EL2_RAM(64, 39)\n\n\n`undef EL2_RAM\n`undef EL2_RAM_BE\n`undef EL2_LOCAL_RAM_TEST_IO\n\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2019 Western Digital Corporation or it's affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License\n\nmodule rvjtag_tap #(\nparameter AWIDTH = 7\n)\n(\ninput               trst,\ninput               tck,\ninput               tms,\ninput               tdi,\noutput   reg        tdo,\noutput              tdoEnable,\n\noutput [31:0]       wr_data,\noutput [AWIDTH-1:0] wr_addr,\noutput              wr_en,\noutput              rd_en,\n\ninput   [31:0]      rd_data,\ninput   [1:0]       rd_status,\n\noutput  reg         dmi_reset,\noutput  reg         dmi_hard_reset,\n\ninput   [2:0]       idle,\ninput   [1:0]       dmi_stat,\n/*\n--  revisionCode        : 4'h0;\n--  manufacturersIdCode : 11'h45;\n--  deviceIdCode        : 16'h0001;\n--  order MSB .. LSB -> [4 bit version or revision] [16 bit part number] [11 bit manufacturer id] [value of 1'b1 in LSB]\n*/\ninput   [31:1]      jtag_id,\ninput   [3:0]       version\n);\n\nlocalparam USER_DR_LENGTH = AWIDTH + 34;\n\n\nreg [USER_DR_LENGTH-1:0] sr, nsr, dr;\n\n///////////////////////////////////////////////////////\n//                      Tap controller\n///////////////////////////////////////////////////////\nlogic[3:0] state, nstate;\nlogic [4:0] ir;\nwire jtag_reset;\nwire shift_dr;\nwire pause_dr;\nwire update_dr;\nwire capture_dr;\nwire shift_ir;\nwire pause_ir ;\nwire update_ir ;\nwire capture_ir;\nwire[1:0] dr_en;\nwire devid_sel;\nwire [5:0] abits;\n\nassign abits = AWIDTH[5:0];\n\n\nlocalparam TEST_LOGIC_RESET_STATE = 0;\nlocalparam RUN_TEST_IDLE_STATE    = 1;\nlocalparam SELECT_DR_SCAN_STATE   = 2;\nlocalparam CAPTURE_DR_STATE       = 3;\nlocalparam SHIFT_DR_STATE         = 4;\nlocalparam EXIT1_DR_STATE         = 5;\nlocalparam PAUSE_DR_STATE         = 6;\nlocalparam EXIT2_DR_STATE         = 7;\nlocalparam UPDATE_DR_STATE        = 8;\nlocalparam SELECT_IR_SCAN_STATE   = 9;\nlocalparam CAPTURE_IR_STATE       = 10;\nlocalparam SHIFT_IR_STATE         = 11;\nlocalparam EXIT1_IR_STATE         = 12;\nlocalparam PAUSE_IR_STATE         = 13;\nlocalparam EXIT2_IR_STATE         = 14;\nlocalparam UPDATE_IR_STATE        = 15;\n\nalways_comb  begin\n    nstate = state;\n    case(state)\n    TEST_LOGIC_RESET_STATE: nstate = tms ? TEST_LOGIC_RESET_STATE : RUN_TEST_IDLE_STATE;\n    RUN_TEST_IDLE_STATE:    nstate = tms ? SELECT_DR_SCAN_STATE   : RUN_TEST_IDLE_STATE;\n    SELECT_DR_SCAN_STATE:   nstate = tms ? SELECT_IR_SCAN_STATE   : CAPTURE_DR_STATE;\n    CAPTURE_DR_STATE:       nstate = tms ? EXIT1_DR_STATE         : SHIFT_DR_STATE;\n    SHIFT_DR_STATE:         nstate = tms ? EXIT1_DR_STATE         : SHIFT_DR_STATE;\n    EXIT1_DR_STATE:         nstate = tms ? UPDATE_DR_STATE        : PAUSE_DR_STATE;\n    PAUSE_DR_STATE:         nstate = tms ? EXIT2_DR_STATE         : PAUSE_DR_STATE;\n    EXIT2_DR_STATE:         nstate = tms ? UPDATE_DR_STATE        : SHIFT_DR_STATE;\n    UPDATE_DR_STATE:        nstate = tms ? SELECT_DR_SCAN_STATE   : RUN_TEST_IDLE_STATE;\n    SELECT_IR_SCAN_STATE:   nstate = tms ? TEST_LOGIC_RESET_STATE : CAPTURE_IR_STATE;\n    CAPTURE_IR_STATE:       nstate = tms ? EXIT1_IR_STATE         : SHIFT_IR_STATE;\n    SHIFT_IR_STATE:         nstate = tms ? EXIT1_IR_STATE         : SHIFT_IR_STATE;\n    EXIT1_IR_STATE:         nstate = tms ? UPDATE_IR_STATE        : PAUSE_IR_STATE;\n    PAUSE_IR_STATE:         nstate = tms ? EXIT2_IR_STATE         : PAUSE_IR_STATE;\n    EXIT2_IR_STATE:         nstate = tms ? UPDATE_IR_STATE        : SHIFT_IR_STATE;\n    UPDATE_IR_STATE:        nstate = tms ? SELECT_DR_SCAN_STATE   : RUN_TEST_IDLE_STATE;\n    default:                nstate = TEST_LOGIC_RESET_STATE;\n    endcase\nend\n\nalways @ (posedge tck or negedge trst) begin\n    if(!trst) state <= TEST_LOGIC_RESET_STATE;\n    else state <= nstate;\nend\n\nassign jtag_reset = state == TEST_LOGIC_RESET_STATE;\nassign shift_dr   = state == SHIFT_DR_STATE;\nassign pause_dr   = state == PAUSE_DR_STATE;\nassign update_dr  = state == UPDATE_DR_STATE;\nassign capture_dr = state == CAPTURE_DR_STATE;\nassign shift_ir   = state == SHIFT_IR_STATE;\nassign pause_ir   = state == PAUSE_IR_STATE;\nassign update_ir  = state == UPDATE_IR_STATE;\nassign capture_ir = state == CAPTURE_IR_STATE;\n\nassign tdoEnable = shift_dr | shift_ir;\n\n///////////////////////////////////////////////////////\n//                      IR register\n///////////////////////////////////////////////////////\n\nalways @ (negedge tck or negedge trst) begin\n   if (!trst) ir <= 5'b1;\n   else begin\n      if (jtag_reset) ir <= 5'b1;\n      else if (update_ir) ir <= (sr[4:0] == '0) ? 5'h1f :sr[4:0];\n   end\nend\n\n\nassign devid_sel  = ir == 5'b00001;\nassign dr_en[0]   = ir == 5'b10000;\nassign dr_en[1]   = ir == 5'b10001;\n\n///////////////////////////////////////////////////////\n//                      Shift register\n///////////////////////////////////////////////////////\nalways @ (posedge tck or negedge trst) begin\n    if(!trst)begin\n        sr <= '0;\n    end\n    else begin\n        sr <= nsr;\n    end\nend\n\n// SR next value\nalways_comb begin\n    nsr = sr;\n    case(1)\n    shift_dr:   begin\n                    case(1)\n                    dr_en[1]:   nsr = {tdi, sr[USER_DR_LENGTH-1:1]};\n\n                    dr_en[0],\n                    devid_sel:  nsr = {{USER_DR_LENGTH-32{1'b0}},tdi, sr[31:1]};\n                    default:    nsr = {{USER_DR_LENGTH-1{1'b0}},tdi}; // bypass\n                    endcase\n                end\n    capture_dr: begin\n                    nsr[0] = 1'b0;\n                    case(1)\n                    dr_en[0]:   nsr = {{USER_DR_LENGTH-15{1'b0}}, idle, dmi_stat, abits, version};\n                    dr_en[1]:   nsr = {{AWIDTH{1'b0}}, rd_data, rd_status};\n                    devid_sel:  nsr = {{USER_DR_LENGTH-32{1'b0}}, jtag_id, 1'b1};\n                    endcase\n                end\n    shift_ir:   nsr = {{USER_DR_LENGTH-5{1'b0}},tdi, sr[4:1]};\n    capture_ir: nsr = {{USER_DR_LENGTH-1{1'b0}},1'b1};\n    endcase\nend\n\n// TDO retiming\nalways @ (negedge tck ) tdo <= sr[0];\n\n// DMI CS register\nalways @ (posedge tck or negedge trst) begin\n    if(!trst) begin\n        dmi_hard_reset <= 1'b0;\n        dmi_reset      <= 1'b0;\n    end\n    else if (update_dr & dr_en[0]) begin\n        dmi_hard_reset <= sr[17];\n        dmi_reset      <= sr[16];\n    end\n    else begin\n        dmi_hard_reset <= 1'b0;\n        dmi_reset      <= 1'b0;\n    end\nend\n\n// DR register\nalways @ (posedge tck or negedge trst) begin\n    if(!trst)\n        dr <=  '0;\n    else begin\n        if (update_dr & dr_en[1])\n            dr <= sr;\n        else\n            dr <= {dr[USER_DR_LENGTH-1:2],2'b0};\n    end\nend\n\nassign {wr_addr, wr_data, wr_en, rd_en} = dr;\n\n\n\n\nendmodule\n"}
