{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Pasquale Davide Schiavone - pschiavo@iis.ee.ethz.ch        //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Igor Loi - igor.loi@greenwaves-technologies.com            //\n//                                                                            //\n// Design Name:    Instrctuon Aligner                                         //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_aligner (\n    input logic clk,\n    input logic rst_n,\n\n    input  logic fetch_valid_i,\n    output logic aligner_ready_o,  //prevents overwriting the fethced instruction\n\n    input logic if_valid_i,\n\n    input  logic [31:0] fetch_rdata_i,\n    output logic [31:0] instr_aligned_o,\n    output logic        instr_valid_o,\n\n    input logic [31:0] branch_addr_i,\n    input logic        branch_i,  // Asserted if we are branching/jumping now\n\n    input logic [31:0] hwlp_addr_i,\n    input logic        hwlp_update_pc_i,\n\n    output logic [31:0] pc_o\n);\n\n  enum logic [2:0] {\n    ALIGNED32,\n    MISALIGNED32,\n    MISALIGNED16,\n    BRANCH_MISALIGNED,\n    WAIT_VALID_BRANCH\n  }\n      state, next_state;\n\n  logic [15:0] r_instr_h;\n  logic [31:0] hwlp_addr_q;\n  logic [31:0] pc_q, pc_n;\n  logic update_state;\n  logic [31:0] pc_plus4, pc_plus2;\n  logic aligner_ready_q, hwlp_update_pc_q;\n\n  assign pc_o     = pc_q;\n\n  assign pc_plus2 = pc_q + 2;\n  assign pc_plus4 = pc_q + 4;\n\n  always_ff @(posedge clk or negedge rst_n) begin : proc_SEQ_FSM\n    if (~rst_n) begin\n      state            <= ALIGNED32;\n      r_instr_h        <= '0;\n      hwlp_addr_q      <= '0;\n      pc_q             <= '0;\n      aligner_ready_q  <= 1'b0;\n      hwlp_update_pc_q <= 1'b0;\n    end else begin\n      if (update_state) begin\n        pc_q             <= pc_n;\n        state            <= next_state;\n        r_instr_h        <= fetch_rdata_i[31:16];\n        aligner_ready_q  <= aligner_ready_o;\n        hwlp_update_pc_q <= 1'b0;\n      end else begin\n        if (hwlp_update_pc_i) begin\n          hwlp_addr_q      <= hwlp_addr_i;  // Save the JUMP target address to keep pc_n up to date during the stall\n          hwlp_update_pc_q <= 1'b1;\n        end\n\n      end\n    end\n  end\n\n  always_comb begin\n\n    //default outputs\n    pc_n            = pc_q;\n    instr_valid_o   = fetch_valid_i;\n    instr_aligned_o = fetch_rdata_i;\n    aligner_ready_o = 1'b1;\n    update_state    = 1'b0;\n    next_state      = state;\n\n\n    case (state)\n      ALIGNED32: begin\n        if (fetch_rdata_i[1:0] == 2'b11) begin\n          /*\n                  Before we fetched a 32bit aligned instruction\n                  Therefore, now the address is aligned too and it is 32bits\n                */\n          next_state      = ALIGNED32;\n          pc_n            = pc_plus4;\n          instr_aligned_o = fetch_rdata_i;\n          //gate id_valid with fetch_valid as the next state should be evaluated only if mem content is valid\n          update_state    = fetch_valid_i & if_valid_i;\n          if (hwlp_update_pc_i || hwlp_update_pc_q)\n            pc_n = hwlp_update_pc_i ? hwlp_addr_i : hwlp_addr_q;\n        end else begin\n          /*\n                  Before we fetched a 32bit aligned instruction\n                  Therefore, now the address is aligned too and it is 16bits\n                */\n          next_state      = MISALIGNED32;\n          pc_n            = pc_plus2;\n          instr_aligned_o = fetch_rdata_i;  //only the first 16b are used\n          //gate id_valid with fetch_valid as the next state should be evaluated only if mem content is valid\n          update_state    = fetch_valid_i & if_valid_i;\n        end\n      end\n\n\n      MISALIGNED32: begin\n        if (r_instr_h[1:0] == 2'b11) begin\n          /*\n                  Before we fetched a 32bit misaligned instruction\n                  So now the beginning of the next instruction is the stored one\n                  The istruction is 32bits so it is misaligned again\n                */\n          next_state      = MISALIGNED32;\n          pc_n            = pc_plus4;\n          instr_aligned_o = {fetch_rdata_i[15:0], r_instr_h[15:0]};\n          //gate id_valid with fetch_valid as the next state should be evaluated only if mem content is valid\n          update_state    = fetch_valid_i & if_valid_i;\n        end else begin\n          /*\n                  Before we fetched a 32bit misaligned instruction\n                  So now the beginning of the next instruction is the stored one\n                  The istruction is 16bits misaligned\n                */\n          instr_aligned_o = {fetch_rdata_i[31:16], r_instr_h[15:0]};  //only the first 16b are used\n          next_state      = MISALIGNED16;\n          instr_valid_o   = 1'b1;\n          pc_n            = pc_plus2;\n          //we cannot overwrite the 32bit instruction just fetched\n          //so tell the IF stage to stall, the coming instruction goes to the FIFO\n          aligner_ready_o = !fetch_valid_i;\n          //not need to gate id_valid with fetch_valid as the next state depends only on r_instr_h\n          update_state    = if_valid_i;\n        end\n      end\n\n\n      MISALIGNED16: begin\n        //this is 1 as we holded the value before with raw_instr_hold_o\n        instr_valid_o = !aligner_ready_q || fetch_valid_i;\n        if (fetch_rdata_i[1:0] == 2'b11) begin\n          /*\n                  Before we fetched a 16bit misaligned instruction\n                  So now the beginning of the next instruction is the new one\n                  The istruction is 32bits so it is aligned\n                */\n          next_state      = ALIGNED32;\n          pc_n            = pc_plus4;\n          instr_aligned_o = fetch_rdata_i;\n          //no gate id_valid with fetch_valid as the next state sdepends only on mem content that has be held the previous cycle with raw_instr_hold_o\n          update_state    = (!aligner_ready_q | fetch_valid_i) & if_valid_i;\n        end else begin\n          /*\n                  Before we fetched a 16bit misaligned  instruction\n                  So now the beginning of the next instruction is the new one\n                  The istruction is 16bit aligned\n                */\n          next_state = MISALIGNED32;\n          pc_n = pc_plus2;\n          instr_aligned_o = fetch_rdata_i;  //only the first 16b are used\n          //no gate id_valid with fetch_valid as the next state sdepends only on mem content that has be held the previous cycle with raw_instr_hold_o\n          update_state = (!aligner_ready_q | fetch_valid_i) & if_valid_i;\n        end\n      end\n\n\n      BRANCH_MISALIGNED: begin\n        //we jumped to a misaligned location, so now we received {TARGET, XXXX}\n        if (fetch_rdata_i[17:16] == 2'b11) begin\n          /*\n                  We jumped to a misaligned location that contains 32bits instruction\n                */\n          next_state      = MISALIGNED32;\n          instr_valid_o   = 1'b0;\n          pc_n            = pc_q;\n          instr_aligned_o = fetch_rdata_i;\n          //gate id_valid with fetch_valid as the next state should be evaluated only if mem content is valid\n          update_state    = fetch_valid_i & if_valid_i;\n        end else begin\n          /*\n                  We jumped to a misaligned location that contains 16bits instruction, as we consumed the whole word, we can preted to start again from ALIGNED32\n                */\n          next_state = ALIGNED32;\n          pc_n = pc_plus2;\n          instr_aligned_o = {\n            fetch_rdata_i[31:16], fetch_rdata_i[31:16]\n          };  //only the first 16b are used\n          //gate id_valid with fetch_valid as the next state should be evaluated only if mem content is valid\n          update_state = fetch_valid_i & if_valid_i;\n        end\n      end\n\n    endcase  // state\n\n\n    // JUMP, BRANCH, SPECIAL JUMP control\n    if (branch_i) begin\n      update_state = 1'b1;\n      pc_n         = branch_addr_i;\n      next_state   = branch_addr_i[1] ? BRANCH_MISALIGNED : ALIGNED32;\n    end\n\n  end\n\n  /*\n  When a branch is taken in EX, if_valid_i is asserted because the BRANCH is resolved also in\n  case of stalls. This is because the branch information is stored in the IF stage (in the prefetcher)\n  when branch_i is asserted. We introduced here an apparently unuseful  special case for\n  the JUMPS for a cleaner and more robust HW: theoretically, we don't need to save the instruction\n  after a taken branch in EX, thus we will not do it.\n*/\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Assertions\n  //////////////////////////////////////////////////////////////////////////////\n\n`ifdef CV32E40P_ASSERT_ON\n\n  // Hardware Loop check\n  property p_hwlp_update_pc;\n    @(posedge clk) disable iff (!rst_n) (1'b1) |-> (!(hwlp_update_pc_i && hwlp_update_pc_q));\n  endproperty\n\n  a_hwlp_update_pc :\n  assert property (p_hwlp_update_pc);\n\n`endif\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Matthias Baer - baermatt@student.ethz.ch                   //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Andreas Traber - atraber@student.ethz.ch                   //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    ALU                                                        //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Arithmetic logic unit of the pipelined processor           //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_alu\n  import cv32e40p_pkg::*;\n(\n    input logic               clk,\n    input logic               rst_n,\n    input logic               enable_i,\n    input alu_opcode_e        operator_i,\n    input logic        [31:0] operand_a_i,\n    input logic        [31:0] operand_b_i,\n    input logic        [31:0] operand_c_i,\n\n    input logic [1:0] vector_mode_i,\n    input logic [4:0] bmask_a_i,\n    input logic [4:0] bmask_b_i,\n    input logic [1:0] imm_vec_ext_i,\n\n    input logic       is_clpx_i,\n    input logic       is_subrot_i,\n    input logic [1:0] clpx_shift_i,\n\n    output logic [31:0] result_o,\n    output logic        comparison_result_o,\n\n    output logic ready_o,\n    input  logic ex_ready_i\n);\n\n  logic [31:0] operand_a_rev;\n  logic [31:0] operand_a_neg;\n  logic [31:0] operand_a_neg_rev;\n\n  assign operand_a_neg = ~operand_a_i;\n\n  // bit reverse operand_a for left shifts and bit counting\n  generate\n    genvar k;\n    for (k = 0; k < 32; k++) begin : gen_operand_a_rev\n      assign operand_a_rev[k] = operand_a_i[31-k];\n    end\n  endgenerate\n\n  // bit reverse operand_a_neg for left shifts and bit counting\n  generate\n    genvar m;\n    for (m = 0; m < 32; m++) begin : gen_operand_a_neg_rev\n      assign operand_a_neg_rev[m] = operand_a_neg[31-m];\n    end\n  endgenerate\n\n  logic [31:0] operand_b_neg;\n\n  assign operand_b_neg = ~operand_b_i;\n\n\n  logic [ 5:0] div_shift;\n  logic        div_valid;\n  logic [31:0] bmask;\n\n  //////////////////////////////////////////////////////////////////////////////////////////\n  //   ____            _   _ _   _                      _      _       _     _            //\n  //  |  _ \\ __ _ _ __| |_(_) |_(_) ___  _ __   ___  __| |    / \\   __| | __| | ___ _ __  //\n  //  | |_) / _` | '__| __| | __| |/ _ \\| '_ \\ / _ \\/ _` |   / _ \\ / _` |/ _` |/ _ \\ '__| //\n  //  |  __/ (_| | |  | |_| | |_| | (_) | | | |  __/ (_| |  / ___ \\ (_| | (_| |  __/ |    //\n  //  |_|   \\__,_|_|   \\__|_|\\__|_|\\___/|_| |_|\\___|\\__,_| /_/   \\_\\__,_|\\__,_|\\___|_|    //\n  //                                                                                      //\n  //////////////////////////////////////////////////////////////////////////////////////////\n\n  logic        adder_op_b_negate;\n  logic [31:0] adder_op_a, adder_op_b;\n  logic [35:0] adder_in_a, adder_in_b;\n  logic [31:0] adder_result;\n  logic [36:0] adder_result_expanded;\n\n\n  assign adder_op_b_negate = (operator_i == ALU_SUB) || (operator_i == ALU_SUBR) ||\n                             (operator_i == ALU_SUBU) || (operator_i == ALU_SUBUR) || is_subrot_i;\n\n  // prepare operand a\n  assign adder_op_a = (operator_i == ALU_ABS) ? operand_a_neg : (is_subrot_i ? {\n    operand_b_i[15:0], operand_a_i[31:16]\n  } : operand_a_i);\n\n  // prepare operand b\n  assign adder_op_b = adder_op_b_negate ? (is_subrot_i ? ~{\n    operand_a_i[15:0], operand_b_i[31:16]\n  } : operand_b_neg) : operand_b_i;\n\n  // prepare carry\n  always_comb begin\n    adder_in_a[0]     = 1'b1;\n    adder_in_a[8:1]   = adder_op_a[7:0];\n    adder_in_a[9]     = 1'b1;\n    adder_in_a[17:10] = adder_op_a[15:8];\n    adder_in_a[18]    = 1'b1;\n    adder_in_a[26:19] = adder_op_a[23:16];\n    adder_in_a[27]    = 1'b1;\n    adder_in_a[35:28] = adder_op_a[31:24];\n\n    adder_in_b[0]     = 1'b0;\n    adder_in_b[8:1]   = adder_op_b[7:0];\n    adder_in_b[9]     = 1'b0;\n    adder_in_b[17:10] = adder_op_b[15:8];\n    adder_in_b[18]    = 1'b0;\n    adder_in_b[26:19] = adder_op_b[23:16];\n    adder_in_b[27]    = 1'b0;\n    adder_in_b[35:28] = adder_op_b[31:24];\n\n    if (adder_op_b_negate || (operator_i == ALU_ABS || operator_i == ALU_CLIP)) begin\n      // special case for subtractions and absolute number calculations\n      adder_in_b[0] = 1'b1;\n\n      case (vector_mode_i)\n        VEC_MODE16: begin\n          adder_in_b[18] = 1'b1;\n        end\n\n        VEC_MODE8: begin\n          adder_in_b[9]  = 1'b1;\n          adder_in_b[18] = 1'b1;\n          adder_in_b[27] = 1'b1;\n        end\n      endcase\n\n    end else begin\n      // take care of partitioning the adder for the addition case\n      case (vector_mode_i)\n        VEC_MODE16: begin\n          adder_in_a[18] = 1'b0;\n        end\n\n        VEC_MODE8: begin\n          adder_in_a[9]  = 1'b0;\n          adder_in_a[18] = 1'b0;\n          adder_in_a[27] = 1'b0;\n        end\n      endcase\n    end\n  end\n\n  // actual adder\n  assign adder_result_expanded = $signed(adder_in_a) + $signed(adder_in_b);\n  assign adder_result = {\n    adder_result_expanded[35:28],\n    adder_result_expanded[26:19],\n    adder_result_expanded[17:10],\n    adder_result_expanded[8:1]\n  };\n\n\n  // normalization stage\n  logic [31:0] adder_round_value;\n  logic [31:0] adder_round_result;\n\n  assign adder_round_value  = ((operator_i == ALU_ADDR) || (operator_i == ALU_SUBR) ||\n                               (operator_i == ALU_ADDUR) || (operator_i == ALU_SUBUR)) ?\n                                {\n    1'b0, bmask[31:1]\n  } : '0;\n  assign adder_round_result = adder_result + adder_round_value;\n\n\n  ////////////////////////////////////////\n  //  ____  _   _ ___ _____ _____       //\n  // / ___|| | | |_ _|  ___|_   _|      //\n  // \\___ \\| |_| || || |_    | |        //\n  //  ___) |  _  || ||  _|   | |        //\n  // |____/|_| |_|___|_|     |_|        //\n  //                                    //\n  ////////////////////////////////////////\n\n  logic        shift_left;  // should we shift left\n  logic        shift_use_round;\n  logic        shift_arithmetic;\n\n  logic [31:0] shift_amt_left;  // amount of shift, if to the left\n  logic [31:0] shift_amt;  // amount of shift, to the right\n  logic [31:0] shift_amt_int;  // amount of shift, used for the actual shifters\n  logic [31:0] shift_amt_norm;  // amount of shift, used for normalization\n  logic [31:0] shift_op_a;  // input of the shifter\n  logic [31:0] shift_result;\n  logic [31:0] shift_right_result;\n  logic [31:0] shift_left_result;\n  logic [15:0] clpx_shift_ex;\n\n  // shifter is also used for preparing operand for division\n  assign shift_amt = div_valid ? div_shift : operand_b_i;\n\n  // by reversing the bits of the input, we also have to reverse the order of shift amounts\n  always_comb begin\n    case (vector_mode_i)\n      VEC_MODE16: begin\n        shift_amt_left[15:0]  = shift_amt[31:16];\n        shift_amt_left[31:16] = shift_amt[15:0];\n      end\n\n      VEC_MODE8: begin\n        shift_amt_left[7:0]   = shift_amt[31:24];\n        shift_amt_left[15:8]  = shift_amt[23:16];\n        shift_amt_left[23:16] = shift_amt[15:8];\n        shift_amt_left[31:24] = shift_amt[7:0];\n      end\n\n      default: // VEC_MODE32\n      begin\n        shift_amt_left[31:0] = shift_amt[31:0];\n      end\n    endcase\n  end\n\n  // ALU_FL1 and ALU_CBL are used for the bit counting ops later\n  assign shift_left = (operator_i == ALU_SLL) || (operator_i == ALU_BINS) ||\n                      (operator_i == ALU_FL1) || (operator_i == ALU_CLB)  ||\n                      (operator_i == ALU_DIV) || (operator_i == ALU_DIVU) ||\n                      (operator_i == ALU_REM) || (operator_i == ALU_REMU) ||\n                      (operator_i == ALU_BREV);\n\n  assign shift_use_round = (operator_i == ALU_ADD)   || (operator_i == ALU_SUB)   ||\n                           (operator_i == ALU_ADDR)  || (operator_i == ALU_SUBR)  ||\n                           (operator_i == ALU_ADDU)  || (operator_i == ALU_SUBU)  ||\n                           (operator_i == ALU_ADDUR) || (operator_i == ALU_SUBUR);\n\n  assign shift_arithmetic = (operator_i == ALU_SRA)  || (operator_i == ALU_BEXT) ||\n                            (operator_i == ALU_ADD)  || (operator_i == ALU_SUB)  ||\n                            (operator_i == ALU_ADDR) || (operator_i == ALU_SUBR);\n\n  // choose the bit reversed or the normal input for shift operand a\n  assign shift_op_a    = shift_left ? operand_a_rev :\n                          (shift_use_round ? adder_round_result : operand_a_i);\n  assign shift_amt_int = shift_use_round ? shift_amt_norm :\n                          (shift_left ? shift_amt_left : shift_amt);\n\n  assign shift_amt_norm = is_clpx_i ? {clpx_shift_ex, clpx_shift_ex} : {4{3'b000, bmask_b_i}};\n\n  assign clpx_shift_ex = $unsigned(clpx_shift_i);\n\n  // right shifts, we let the synthesizer optimize this\n  logic [63:0] shift_op_a_32;\n\n  assign shift_op_a_32 = (operator_i == ALU_ROR) ? {\n        shift_op_a, shift_op_a\n      } : $signed(\n          {{32{shift_arithmetic & shift_op_a[31]}}, shift_op_a}\n      );\n\n  always_comb begin\n    case (vector_mode_i)\n      VEC_MODE16: begin\n        shift_right_result[31:16] = $signed(\n            {shift_arithmetic & shift_op_a[31], shift_op_a[31:16]}\n        ) >>> shift_amt_int[19:16];\n        shift_right_result[15:0] = $signed(\n            {shift_arithmetic & shift_op_a[15], shift_op_a[15:0]}\n        ) >>> shift_amt_int[3:0];\n      end\n\n      VEC_MODE8: begin\n        shift_right_result[31:24] = $signed(\n            {shift_arithmetic & shift_op_a[31], shift_op_a[31:24]}\n        ) >>> shift_amt_int[26:24];\n        shift_right_result[23:16] = $signed(\n            {shift_arithmetic & shift_op_a[23], shift_op_a[23:16]}\n        ) >>> shift_amt_int[18:16];\n        shift_right_result[15:8] = $signed(\n            {shift_arithmetic & shift_op_a[15], shift_op_a[15:8]}\n        ) >>> shift_amt_int[10:8];\n        shift_right_result[7:0] = $signed(\n            {shift_arithmetic & shift_op_a[7], shift_op_a[7:0]}\n        ) >>> shift_amt_int[2:0];\n      end\n\n      default: // VEC_MODE32\n      begin\n        shift_right_result = shift_op_a_32 >> shift_amt_int[4:0];\n      end\n    endcase\n    ;  // case (vec_mode_i)\n  end\n\n  // bit reverse the shift_right_result for left shifts\n  genvar j;\n  generate\n    for (j = 0; j < 32; j++) begin : gen_shift_left_result\n      assign shift_left_result[j] = shift_right_result[31-j];\n    end\n  endgenerate\n\n  assign shift_result = shift_left ? shift_left_result : shift_right_result;\n\n\n  //////////////////////////////////////////////////////////////////\n  //   ____ ___  __  __ ____   _    ____  ___ ____   ___  _   _   //\n  //  / ___/ _ \\|  \\/  |  _ \\ / \\  |  _ \\|_ _/ ___| / _ \\| \\ | |  //\n  // | |  | | | | |\\/| | |_) / _ \\ | |_) || |\\___ \\| | | |  \\| |  //\n  // | |__| |_| | |  | |  __/ ___ \\|  _ < | | ___) | |_| | |\\  |  //\n  //  \\____\\___/|_|  |_|_| /_/   \\_\\_| \\_\\___|____/ \\___/|_| \\_|  //\n  //                                                              //\n  //////////////////////////////////////////////////////////////////\n\n  logic [ 3:0] is_equal;\n  logic [ 3:0] is_greater;  // handles both signed and unsigned forms\n\n  // 8-bit vector comparisons, basic building blocks\n  logic [ 3:0] cmp_signed;\n  logic [ 3:0] is_equal_vec;\n  logic [ 3:0] is_greater_vec;\n  logic [31:0] operand_b_eq;\n  logic        is_equal_clip;\n\n\n  //second == comparator for CLIP instructions\n  always_comb begin\n    operand_b_eq = operand_b_neg;\n    if (operator_i == ALU_CLIPU) operand_b_eq = '0;\n    else operand_b_eq = operand_b_neg;\n  end\n  assign is_equal_clip = operand_a_i == operand_b_eq;\n\n  always_comb begin\n    cmp_signed = 4'b0;\n\n    unique case (operator_i)\n      ALU_GTS,\n      ALU_GES,\n      ALU_LTS,\n      ALU_LES,\n      ALU_SLTS,\n      ALU_SLETS,\n      ALU_MIN,\n      ALU_MAX,\n      ALU_ABS,\n      ALU_CLIP,\n      ALU_CLIPU: begin\n        case (vector_mode_i)\n          VEC_MODE8:  cmp_signed[3:0] = 4'b1111;\n          VEC_MODE16: cmp_signed[3:0] = 4'b1010;\n          default:    cmp_signed[3:0] = 4'b1000;\n        endcase\n      end\n\n      default: ;\n    endcase\n  end\n\n  // generate vector equal and greater than signals, cmp_signed decides if the\n  // comparison is done signed or unsigned\n  genvar i;\n  generate\n    for (i = 0; i < 4; i++) begin : gen_is_vec\n      assign is_equal_vec[i] = (operand_a_i[8*i+7:8*i] == operand_b_i[8*i+7:i*8]);\n      assign is_greater_vec[i] = $signed(\n          {operand_a_i[8*i+7] & cmp_signed[i], operand_a_i[8*i+7:8*i]}\n      ) > $signed(\n          {operand_b_i[8*i+7] & cmp_signed[i], operand_b_i[8*i+7:i*8]}\n      );\n    end\n  endgenerate\n\n  // generate the real equal and greater than signals that take the vector\n  // mode into account\n  always_comb begin\n    // 32-bit mode\n    is_equal[3:0] = {4{is_equal_vec[3] & is_equal_vec[2] & is_equal_vec[1] & is_equal_vec[0]}};\n    is_greater[3:0] = {4{is_greater_vec[3] | (is_equal_vec[3] & (is_greater_vec[2]\n                                            | (is_equal_vec[2] & (is_greater_vec[1]\n                                             | (is_equal_vec[1] & (is_greater_vec[0]))))))}};\n\n    case (vector_mode_i)\n      VEC_MODE16: begin\n        is_equal[1:0]   = {2{is_equal_vec[0] & is_equal_vec[1]}};\n        is_equal[3:2]   = {2{is_equal_vec[2] & is_equal_vec[3]}};\n        is_greater[1:0] = {2{is_greater_vec[1] | (is_equal_vec[1] & is_greater_vec[0])}};\n        is_greater[3:2] = {2{is_greater_vec[3] | (is_equal_vec[3] & is_greater_vec[2])}};\n      end\n\n      VEC_MODE8: begin\n        is_equal[3:0]   = is_equal_vec[3:0];\n        is_greater[3:0] = is_greater_vec[3:0];\n      end\n\n      default: ;  // see default assignment\n    endcase\n  end\n\n  // generate comparison result\n  logic [3:0] cmp_result;\n\n  always_comb begin\n    cmp_result = is_equal;\n    unique case (operator_i)\n      ALU_EQ:                                 cmp_result = is_equal;\n      ALU_NE:                                 cmp_result = ~is_equal;\n      ALU_GTS, ALU_GTU:                       cmp_result = is_greater;\n      ALU_GES, ALU_GEU:                       cmp_result = is_greater | is_equal;\n      ALU_LTS, ALU_SLTS, ALU_LTU, ALU_SLTU:   cmp_result = ~(is_greater | is_equal);\n      ALU_SLETS, ALU_SLETU, ALU_LES, ALU_LEU: cmp_result = ~is_greater;\n      default:                                ;\n    endcase\n  end\n\n  assign comparison_result_o = cmp_result[3];\n\n\n  // min/max/abs handling\n  logic [31:0] result_minmax;\n  logic [ 3:0] sel_minmax;\n  logic        do_min;\n  logic [31:0] minmax_b;\n\n  assign minmax_b = (operator_i == ALU_ABS) ? adder_result : operand_b_i;\n\n  assign do_min   = (operator_i == ALU_MIN)  || (operator_i == ALU_MINU) ||\n                    (operator_i == ALU_CLIP) || (operator_i == ALU_CLIPU);\n\n  assign sel_minmax[3:0] = is_greater ^ {4{do_min}};\n\n  assign result_minmax[31:24] = (sel_minmax[3] == 1'b1) ? operand_a_i[31:24] : minmax_b[31:24];\n  assign result_minmax[23:16] = (sel_minmax[2] == 1'b1) ? operand_a_i[23:16] : minmax_b[23:16];\n  assign result_minmax[15:8] = (sel_minmax[1] == 1'b1) ? operand_a_i[15:8] : minmax_b[15:8];\n  assign result_minmax[7:0] = (sel_minmax[0] == 1'b1) ? operand_a_i[7:0] : minmax_b[7:0];\n\n  //////////////////////////////////////////////////\n  // Clip\n  //////////////////////////////////////////////////\n  logic [31:0] clip_result;  // result of clip and clip\n\n  always_comb begin\n    clip_result = result_minmax;\n    if (operator_i == ALU_CLIPU) begin\n      if (operand_a_i[31] || is_equal_clip) begin\n        clip_result = '0;\n      end else begin\n        clip_result = result_minmax;\n      end\n    end else begin\n      //CLIP\n      if (adder_result_expanded[36] || is_equal_clip) begin\n        clip_result = operand_b_neg;\n      end else begin\n        clip_result = result_minmax;\n      end\n    end\n\n  end\n\n  //////////////////////////////////////////////////\n  //  ____  _   _ _   _ _____ _____ _     _____   //\n  // / ___|| | | | | | |  ___|  ___| |   | ____|  //\n  // \\___ \\| |_| | | | | |_  | |_  | |   |  _|    //\n  //  ___) |  _  | |_| |  _| |  _| | |___| |___   //\n  // |____/|_| |_|\\___/|_|   |_|   |_____|_____|  //\n  //                                              //\n  //////////////////////////////////////////////////\n\n  logic [3:0][1:0] shuffle_byte_sel;  // select byte in register: 31:24, 23:16, 15:8, 7:0\n  logic [3:0]      shuffle_reg_sel;  // select register: rD/rS2 or rS1\n  logic [1:0]      shuffle_reg1_sel;  // select register rD or rS2 for next stage\n  logic [1:0]      shuffle_reg0_sel;\n  logic [3:0]      shuffle_through;\n\n  logic [31:0] shuffle_r1, shuffle_r0;\n  logic [31:0] shuffle_r1_in, shuffle_r0_in;\n  logic [31:0] shuffle_result;\n  logic [31:0] pack_result;\n\n\n  always_comb begin\n    shuffle_reg_sel  = '0;\n    shuffle_reg1_sel = 2'b01;\n    shuffle_reg0_sel = 2'b10;\n    shuffle_through  = '1;\n\n    unique case (operator_i)\n      ALU_EXT, ALU_EXTS: begin\n        if (operator_i == ALU_EXTS) shuffle_reg1_sel = 2'b11;\n\n        if (vector_mode_i == VEC_MODE8) begin\n          shuffle_reg_sel[3:1] = 3'b111;\n          shuffle_reg_sel[0]   = 1'b0;\n        end else begin\n          shuffle_reg_sel[3:2] = 2'b11;\n          shuffle_reg_sel[1:0] = 2'b00;\n        end\n      end\n\n      ALU_PCKLO: begin\n        shuffle_reg1_sel = 2'b00;\n\n        if (vector_mode_i == VEC_MODE8) begin\n          shuffle_through = 4'b0011;\n          shuffle_reg_sel = 4'b0001;\n        end else begin\n          shuffle_reg_sel = 4'b0011;\n        end\n      end\n\n      ALU_PCKHI: begin\n        shuffle_reg1_sel = 2'b00;\n\n        if (vector_mode_i == VEC_MODE8) begin\n          shuffle_through = 4'b1100;\n          shuffle_reg_sel = 4'b0100;\n        end else begin\n          shuffle_reg_sel = 4'b0011;\n        end\n      end\n\n      ALU_SHUF2: begin\n        unique case (vector_mode_i)\n          VEC_MODE8: begin\n            shuffle_reg_sel[3] = ~operand_b_i[26];\n            shuffle_reg_sel[2] = ~operand_b_i[18];\n            shuffle_reg_sel[1] = ~operand_b_i[10];\n            shuffle_reg_sel[0] = ~operand_b_i[2];\n          end\n\n          VEC_MODE16: begin\n            shuffle_reg_sel[3] = ~operand_b_i[17];\n            shuffle_reg_sel[2] = ~operand_b_i[17];\n            shuffle_reg_sel[1] = ~operand_b_i[1];\n            shuffle_reg_sel[0] = ~operand_b_i[1];\n          end\n          default: ;\n        endcase\n      end\n\n      ALU_INS: begin\n        unique case (vector_mode_i)\n          VEC_MODE8: begin\n            shuffle_reg0_sel = 2'b00;\n            unique case (imm_vec_ext_i)\n              2'b00: begin\n                shuffle_reg_sel[3:0] = 4'b1110;\n              end\n              2'b01: begin\n                shuffle_reg_sel[3:0] = 4'b1101;\n              end\n              2'b10: begin\n                shuffle_reg_sel[3:0] = 4'b1011;\n     "}
{"text": "         end\n              2'b11: begin\n                shuffle_reg_sel[3:0] = 4'b0111;\n              end\n            endcase\n          end\n          VEC_MODE16: begin\n            shuffle_reg0_sel   = 2'b01;\n            shuffle_reg_sel[3] = ~imm_vec_ext_i[0];\n            shuffle_reg_sel[2] = ~imm_vec_ext_i[0];\n            shuffle_reg_sel[1] = imm_vec_ext_i[0];\n            shuffle_reg_sel[0] = imm_vec_ext_i[0];\n          end\n          default: ;\n        endcase\n      end\n\n      default: ;\n    endcase\n  end\n\n  always_comb begin\n    shuffle_byte_sel = '0;\n\n    // byte selector\n    unique case (operator_i)\n      ALU_EXTS, ALU_EXT: begin\n        unique case (vector_mode_i)\n          VEC_MODE8: begin\n            shuffle_byte_sel[3] = imm_vec_ext_i[1:0];\n            shuffle_byte_sel[2] = imm_vec_ext_i[1:0];\n            shuffle_byte_sel[1] = imm_vec_ext_i[1:0];\n            shuffle_byte_sel[0] = imm_vec_ext_i[1:0];\n          end\n\n          VEC_MODE16: begin\n            shuffle_byte_sel[3] = {imm_vec_ext_i[0], 1'b1};\n            shuffle_byte_sel[2] = {imm_vec_ext_i[0], 1'b1};\n            shuffle_byte_sel[1] = {imm_vec_ext_i[0], 1'b1};\n            shuffle_byte_sel[0] = {imm_vec_ext_i[0], 1'b0};\n          end\n\n          default: ;\n        endcase\n      end\n\n      ALU_PCKLO: begin\n        unique case (vector_mode_i)\n          VEC_MODE8: begin\n            shuffle_byte_sel[3] = 2'b00;\n            shuffle_byte_sel[2] = 2'b00;\n            shuffle_byte_sel[1] = 2'b00;\n            shuffle_byte_sel[0] = 2'b00;\n          end\n\n          VEC_MODE16: begin\n            shuffle_byte_sel[3] = 2'b01;\n            shuffle_byte_sel[2] = 2'b00;\n            shuffle_byte_sel[1] = 2'b01;\n            shuffle_byte_sel[0] = 2'b00;\n          end\n\n          default: ;\n        endcase\n      end\n\n      ALU_PCKHI: begin\n        unique case (vector_mode_i)\n          VEC_MODE8: begin\n            shuffle_byte_sel[3] = 2'b00;\n            shuffle_byte_sel[2] = 2'b00;\n            shuffle_byte_sel[1] = 2'b00;\n            shuffle_byte_sel[0] = 2'b00;\n          end\n\n          VEC_MODE16: begin\n            shuffle_byte_sel[3] = 2'b11;\n            shuffle_byte_sel[2] = 2'b10;\n            shuffle_byte_sel[1] = 2'b11;\n            shuffle_byte_sel[0] = 2'b10;\n          end\n\n          default: ;\n        endcase\n      end\n\n      ALU_SHUF2, ALU_SHUF: begin\n        unique case (vector_mode_i)\n          VEC_MODE8: begin\n            shuffle_byte_sel[3] = operand_b_i[25:24];\n            shuffle_byte_sel[2] = operand_b_i[17:16];\n            shuffle_byte_sel[1] = operand_b_i[9:8];\n            shuffle_byte_sel[0] = operand_b_i[1:0];\n          end\n\n          VEC_MODE16: begin\n            shuffle_byte_sel[3] = {operand_b_i[16], 1'b1};\n            shuffle_byte_sel[2] = {operand_b_i[16], 1'b0};\n            shuffle_byte_sel[1] = {operand_b_i[0], 1'b1};\n            shuffle_byte_sel[0] = {operand_b_i[0], 1'b0};\n          end\n          default: ;\n        endcase\n      end\n\n      ALU_INS: begin\n        shuffle_byte_sel[3] = 2'b11;\n        shuffle_byte_sel[2] = 2'b10;\n        shuffle_byte_sel[1] = 2'b01;\n        shuffle_byte_sel[0] = 2'b00;\n      end\n\n      default: ;\n    endcase\n  end\n\n  assign shuffle_r0_in = shuffle_reg0_sel[1] ?\n                          operand_a_i :\n                          (shuffle_reg0_sel[0] ? {2{operand_a_i[15:0]}} : {4{operand_a_i[7:0]}});\n\n  assign shuffle_r1_in = shuffle_reg1_sel[1] ? {\n    {8{operand_a_i[31]}}, {8{operand_a_i[23]}}, {8{operand_a_i[15]}}, {8{operand_a_i[7]}}\n  } : (shuffle_reg1_sel[0] ? operand_c_i : operand_b_i);\n\n  assign shuffle_r0[31:24] = shuffle_byte_sel[3][1] ?\n                              (shuffle_byte_sel[3][0] ? shuffle_r0_in[31:24] : shuffle_r0_in[23:16]) :\n                              (shuffle_byte_sel[3][0] ? shuffle_r0_in[15: 8] : shuffle_r0_in[ 7: 0]);\n  assign shuffle_r0[23:16] = shuffle_byte_sel[2][1] ?\n                              (shuffle_byte_sel[2][0] ? shuffle_r0_in[31:24] : shuffle_r0_in[23:16]) :\n                              (shuffle_byte_sel[2][0] ? shuffle_r0_in[15: 8] : shuffle_r0_in[ 7: 0]);\n  assign shuffle_r0[15: 8] = shuffle_byte_sel[1][1] ?\n                              (shuffle_byte_sel[1][0] ? shuffle_r0_in[31:24] : shuffle_r0_in[23:16]) :\n                              (shuffle_byte_sel[1][0] ? shuffle_r0_in[15: 8] : shuffle_r0_in[ 7: 0]);\n  assign shuffle_r0[ 7: 0] = shuffle_byte_sel[0][1] ?\n                              (shuffle_byte_sel[0][0] ? shuffle_r0_in[31:24] : shuffle_r0_in[23:16]) :\n                              (shuffle_byte_sel[0][0] ? shuffle_r0_in[15: 8] : shuffle_r0_in[ 7: 0]);\n\n  assign shuffle_r1[31:24] = shuffle_byte_sel[3][1] ?\n                              (shuffle_byte_sel[3][0] ? shuffle_r1_in[31:24] : shuffle_r1_in[23:16]) :\n                              (shuffle_byte_sel[3][0] ? shuffle_r1_in[15: 8] : shuffle_r1_in[ 7: 0]);\n  assign shuffle_r1[23:16] = shuffle_byte_sel[2][1] ?\n                              (shuffle_byte_sel[2][0] ? shuffle_r1_in[31:24] : shuffle_r1_in[23:16]) :\n                              (shuffle_byte_sel[2][0] ? shuffle_r1_in[15: 8] : shuffle_r1_in[ 7: 0]);\n  assign shuffle_r1[15: 8] = shuffle_byte_sel[1][1] ?\n                              (shuffle_byte_sel[1][0] ? shuffle_r1_in[31:24] : shuffle_r1_in[23:16]) :\n                              (shuffle_byte_sel[1][0] ? shuffle_r1_in[15: 8] : shuffle_r1_in[ 7: 0]);\n  assign shuffle_r1[ 7: 0] = shuffle_byte_sel[0][1] ?\n                              (shuffle_byte_sel[0][0] ? shuffle_r1_in[31:24] : shuffle_r1_in[23:16]) :\n                              (shuffle_byte_sel[0][0] ? shuffle_r1_in[15: 8] : shuffle_r1_in[ 7: 0]);\n\n  assign shuffle_result[31:24] = shuffle_reg_sel[3] ? shuffle_r1[31:24] : shuffle_r0[31:24];\n  assign shuffle_result[23:16] = shuffle_reg_sel[2] ? shuffle_r1[23:16] : shuffle_r0[23:16];\n  assign shuffle_result[15:8] = shuffle_reg_sel[1] ? shuffle_r1[15:8] : shuffle_r0[15:8];\n  assign shuffle_result[7:0] = shuffle_reg_sel[0] ? shuffle_r1[7:0] : shuffle_r0[7:0];\n\n  assign pack_result[31:24] = shuffle_through[3] ? shuffle_result[31:24] : operand_c_i[31:24];\n  assign pack_result[23:16] = shuffle_through[2] ? shuffle_result[23:16] : operand_c_i[23:16];\n  assign pack_result[15:8] = shuffle_through[1] ? shuffle_result[15:8] : operand_c_i[15:8];\n  assign pack_result[7:0] = shuffle_through[0] ? shuffle_result[7:0] : operand_c_i[7:0];\n\n\n  /////////////////////////////////////////////////////////////////////\n  //   ____  _ _      ____                  _      ___               //\n  //  | __ )(_) |_   / ___|___  _   _ _ __ | |_   / _ \\ _ __  ___    //\n  //  |  _ \\| | __| | |   / _ \\| | | | '_ \\| __| | | | | '_ \\/ __|   //\n  //  | |_) | | |_  | |__| (_) | |_| | | | | |_  | |_| | |_) \\__ \\_  //\n  //  |____/|_|\\__|  \\____\\___/ \\__,_|_| |_|\\__|  \\___/| .__/|___(_) //\n  //                                                   |_|           //\n  /////////////////////////////////////////////////////////////////////\n\n  logic [31:0] ff_input;  // either op_a_i or its bit reversed version\n  logic [ 5:0] cnt_result;  // population count\n  logic [ 5:0] clb_result;  // count leading bits\n  logic [ 4:0] ff1_result;  // holds the index of the first '1'\n  logic        ff_no_one;  // if no ones are found\n  logic [ 4:0] fl1_result;  // holds the index of the last '1'\n  logic [ 5:0] bitop_result;  // result of all bitop operations muxed together\n\n  cv32e40p_popcnt popcnt_i (\n      .in_i    (operand_a_i),\n      .result_o(cnt_result)\n  );\n\n  always_comb begin\n    ff_input = '0;\n\n    case (operator_i)\n      ALU_FF1: ff_input = operand_a_i;\n\n      ALU_DIVU, ALU_REMU, ALU_FL1: ff_input = operand_a_rev;\n\n      ALU_DIV, ALU_REM, ALU_CLB: begin\n        if (operand_a_i[31]) ff_input = operand_a_neg_rev;\n        else ff_input = operand_a_rev;\n      end\n    endcase\n  end\n\n  cv32e40p_ff_one ff_one_i (\n      .in_i       (ff_input),\n      .first_one_o(ff1_result),\n      .no_ones_o  (ff_no_one)\n  );\n\n  // special case if ff1_res is 0 (no 1 found), then we keep the 0\n  // this is done in the result mux\n  assign fl1_result = 5'd31 - ff1_result;\n  assign clb_result = ff1_result - 5'd1;\n\n  always_comb begin\n    bitop_result = '0;\n    case (operator_i)\n      ALU_FF1: bitop_result = ff_no_one ? 6'd32 : {1'b0, ff1_result};\n      ALU_FL1: bitop_result = ff_no_one ? 6'd32 : {1'b0, fl1_result};\n      ALU_CNT: bitop_result = cnt_result;\n      ALU_CLB: begin\n        if (ff_no_one) begin\n          if (operand_a_i[31]) bitop_result = 6'd31;\n          else bitop_result = '0;\n        end else begin\n          bitop_result = clb_result;\n        end\n      end\n      default: ;\n    endcase\n  end\n\n\n  ////////////////////////////////////////////////\n  //  ____  _ _     __  __             _        //\n  // | __ )(_) |_  |  \\/  | __ _ _ __ (_)_ __   //\n  // |  _ \\| | __| | |\\/| |/ _` | '_ \\| | '_ \\  //\n  // | |_) | | |_  | |  | | (_| | | | | | |_) | //\n  // |____/|_|\\__| |_|  |_|\\__,_|_| |_|_| .__/  //\n  //                                    |_|     //\n  ////////////////////////////////////////////////\n\n  logic extract_is_signed;\n  logic extract_sign;\n  logic [31:0] bmask_first, bmask_inv;\n  logic [31:0] bextins_and;\n  logic [31:0] bextins_result, bclr_result, bset_result;\n\n\n  // construct bit mask for insert/extract/bclr/bset\n  // bmask looks like this 00..0011..1100..00\n  assign bmask_first       = {32'hFFFFFFFE} << bmask_a_i;\n  assign bmask             = (~bmask_first) << bmask_b_i;\n  assign bmask_inv         = ~bmask;\n\n  assign bextins_and       = (operator_i == ALU_BINS) ? operand_c_i : {32{extract_sign}};\n\n  assign extract_is_signed = (operator_i == ALU_BEXT);\n  assign extract_sign      = extract_is_signed & shift_result[bmask_a_i];\n\n  assign bextins_result    = (bmask & shift_result) | (bextins_and & bmask_inv);\n\n  assign bclr_result       = operand_a_i & bmask_inv;\n  assign bset_result       = operand_a_i | bmask;\n\n  /////////////////////////////////////////////////////////////////////////////////\n  //  ____ _____ _______     _____  ________      ________ _____   _____ ______  //\n  // |  _ \\_   _|__   __|   |  __ \\|  ____\\ \\    / /  ____|  __ \\ / ____|  ____| //\n  // | |_) || |    | |______| |__) | |__   \\ \\  / /| |__  | |__) | (___ | |__    //\n  // |  _ < | |    | |______|  _  /|  __|   \\ \\/ / |  __| |  _  / \\___ \\|  __|   //\n  // | |_) || |_   | |      | | \\ \\| |____   \\  /  | |____| | \\ \\ ____) | |____  //\n  // |____/_____|  |_|      |_|  \\_\\______|   \\/   |______|_|  \\_\\_____/|______| //\n  //                                                                             //\n  /////////////////////////////////////////////////////////////////////////////////\n\n  logic [31:0] radix_2_rev;\n  logic [31:0] radix_4_rev;\n  logic [31:0] radix_8_rev;\n  logic [31:0] reverse_result;\n  logic [ 1:0] radix_mux_sel;\n\n  assign radix_mux_sel = bmask_a_i[1:0];\n\n  generate\n    // radix-2 bit reverse\n    for (j = 0; j < 32; j++) begin : gen_radix_2_rev\n      assign radix_2_rev[j] = shift_result[31-j];\n    end\n    // radix-4 bit reverse\n    for (j = 0; j < 16; j++) begin : gen_radix_4_rev\n      assign radix_4_rev[2*j+1:2*j] = shift_result[31-j*2:31-j*2-1];\n    end\n    // radix-8 bit reverse\n    for (j = 0; j < 10; j++) begin : gen_radix_8_rev\n      assign radix_8_rev[3*j+2:3*j] = shift_result[31-j*3:31-j*3-2];\n    end\n    assign radix_8_rev[31:30] = 2'b0;\n  endgenerate\n\n  always_comb begin\n    reverse_result = '0;\n\n    unique case (radix_mux_sel)\n      2'b00: reverse_result = radix_2_rev;\n      2'b01: reverse_result = radix_4_rev;\n      2'b10: reverse_result = radix_8_rev;\n\n      default: reverse_result = radix_2_rev;\n    endcase\n  end\n\n  ////////////////////////////////////////////////////\n  //  ____ _____     __     __  ____  _____ __  __  //\n  // |  _ \\_ _\\ \\   / /    / / |  _ \\| ____|  \\/  | //\n  // | | | | | \\ \\ / /    / /  | |_) |  _| | |\\/| | //\n  // | |_| | |  \\ V /    / /   |  _ <| |___| |  | | //\n  // |____/___|  \\_/    /_/    |_| \\_\\_____|_|  |_| //\n  //                                                //\n  ////////////////////////////////////////////////////\n\n  logic [31:0] result_div;\n  logic        div_ready;\n  logic        div_signed;\n  logic        div_op_a_signed;\n  logic [ 5:0] div_shift_int;\n\n  assign div_signed = operator_i[0];\n\n  assign div_op_a_signed = operand_a_i[31] & div_signed;\n\n  assign div_shift_int = ff_no_one ? 6'd31 : clb_result;\n  assign div_shift = div_shift_int + (div_op_a_signed ? 6'd0 : 6'd1);\n\n  assign div_valid = enable_i & ((operator_i == ALU_DIV) || (operator_i == ALU_DIVU) ||\n                     (operator_i == ALU_REM) || (operator_i == ALU_REMU));\n\n  // inputs A and B are swapped\n  cv32e40p_alu_div alu_div_i (\n      .Clk_CI (clk),\n      .Rst_RBI(rst_n),\n\n      // input IF\n      .OpA_DI      (operand_b_i),\n      .OpB_DI      (shift_left_result),\n      .OpBShift_DI (div_shift),\n      .OpBIsZero_SI((cnt_result == 0)),\n\n      .OpBSign_SI(div_op_a_signed),\n      .OpCode_SI (operator_i[1:0]),\n\n      .Res_DO(result_div),\n\n      // Hand-Shake\n      .InVld_SI (div_valid),\n      .OutRdy_SI(ex_ready_i),\n      .OutVld_SO(div_ready)\n  );\n\n  ////////////////////////////////////////////////////////\n  //   ____                 _ _     __  __              //\n  //  |  _ \\ ___  ___ _   _| | |_  |  \\/  |_   ___  __  //\n  //  | |_) / _ \\/ __| | | | | __| | |\\/| | | | \\ \\/ /  //\n  //  |  _ <  __/\\__ \\ |_| | | |_  | |  | | |_| |>  <   //\n  //  |_| \\_\\___||___/\\__,_|_|\\__| |_|  |_|\\__,_/_/\\_\\  //\n  //                                                    //\n  ////////////////////////////////////////////////////////\n\n  always_comb begin\n    result_o = '0;\n\n    unique case (operator_i)\n      // Standard Operations\n      ALU_AND: result_o = operand_a_i & operand_b_i;\n      ALU_OR:  result_o = operand_a_i | operand_b_i;\n      ALU_XOR: result_o = operand_a_i ^ operand_b_i;\n\n      // Shift Operations\n      ALU_ADD, ALU_ADDR, ALU_ADDU, ALU_ADDUR,\n      ALU_SUB, ALU_SUBR, ALU_SUBU, ALU_SUBUR,\n      ALU_SLL,\n      ALU_SRL, ALU_SRA,\n      ALU_ROR:\n      result_o = shift_result;\n\n      // bit manipulation instructions\n      ALU_BINS, ALU_BEXT, ALU_BEXTU: result_o = bextins_result;\n\n      ALU_BCLR: result_o = bclr_result;\n      ALU_BSET: result_o = bset_result;\n\n      // Bit reverse instruction\n      ALU_BREV: result_o = reverse_result;\n\n      // pack and shuffle operations\n      ALU_SHUF, ALU_SHUF2, ALU_PCKLO, ALU_PCKHI, ALU_EXT, ALU_EXTS, ALU_INS: result_o = pack_result;\n\n      // Min/Max/Ins\n      ALU_MIN, ALU_MINU, ALU_MAX, ALU_MAXU: result_o = result_minmax;\n\n      //Abs/Cplxconj , ABS is used to do 0 - A for Cplxconj\n      ALU_ABS: result_o = is_clpx_i ? {adder_result[31:16], operand_a_i[15:0]} : result_minmax;\n\n      ALU_CLIP, ALU_CLIPU: result_o = clip_result;\n\n      // Comparison Operations\n      ALU_EQ, ALU_NE, ALU_GTU, ALU_GEU, ALU_LTU, ALU_LEU, ALU_GTS, ALU_GES, ALU_LTS, ALU_LES: begin\n        result_o[31:24] = {8{cmp_result[3]}};\n        result_o[23:16] = {8{cmp_result[2]}};\n        result_o[15:8]  = {8{cmp_result[1]}};\n        result_o[7:0]   = {8{cmp_result[0]}};\n      end\n      // Non-vector comparisons\n      ALU_SLTS, ALU_SLTU, ALU_SLETS, ALU_SLETU: result_o = {31'b0, comparison_result_o};\n\n      ALU_FF1, ALU_FL1, ALU_CLB, ALU_CNT: result_o = {26'h0, bitop_result[5:0]};\n\n      // Division Unit Commands\n      ALU_DIV, ALU_DIVU, ALU_REM, ALU_REMU: result_o = result_div;\n\n      default: ;  // default case to suppress unique warning\n    endcase\n  end\n\n  assign ready_o = div_ready;\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n///////////////////////////////////////////////////////////////////////////////\n// File       : Simple Serial Divider\n// Ver        : 1.0\n// Date       : 15.03.2016\n///////////////////////////////////////////////////////////////////////////////\n//\n// Description: this is a simple serial divider for signed integers (int32).\n//\n///////////////////////////////////////////////////////////////////////////////\n//\n// Authors    : Michael Schaffner (schaffner@iis.ee.ethz.ch)\n//              Andreas Traber    (atraber@iis.ee.ethz.ch)\n//\n///////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_alu_div #(\n    parameter C_WIDTH     = 32,\n    parameter C_LOG_WIDTH = 6\n) (\n    input  logic                   Clk_CI,\n    input  logic                   Rst_RBI,\n    // input IF\n    input  logic [    C_WIDTH-1:0] OpA_DI,\n    input  logic [    C_WIDTH-1:0] OpB_DI,\n    input  logic [C_LOG_WIDTH-1:0] OpBShift_DI,\n    input  logic                   OpBIsZero_SI,\n    //\n    input  logic                   OpBSign_SI,  // gate this to 0 in case of unsigned ops\n    input  logic [            1:0] OpCode_SI,  // 0: udiv, 2: urem, 1: div, 3: rem\n    // handshake\n    input  logic                   InVld_SI,\n    // output IF\n    input  logic                   OutRdy_SI,\n    output logic                   OutVld_SO,\n    output logic [    C_WIDTH-1:0] Res_DO\n);\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // signal declarations\n  ///////////////////////////////////////////////////////////////////////////////\n\n  logic [C_WIDTH-1:0] ResReg_DP, ResReg_DN;\n  logic [C_WIDTH-1:0] ResReg_DP_rev;\n  logic [C_WIDTH-1:0] AReg_DP, AReg_DN;\n  logic [C_WIDTH-1:0] BReg_DP, BReg_DN;\n\n  logic RemSel_SN, RemSel_SP;\n  logic CompInv_SN, CompInv_SP;\n  logic ResInv_SN, ResInv_SP;\n\n  logic [C_WIDTH-1:0] AddMux_D;\n  logic [C_WIDTH-1:0] AddOut_D;\n  logic [C_WIDTH-1:0] AddTmp_D;\n  logic [C_WIDTH-1:0] BMux_D;\n  logic [C_WIDTH-1:0] OutMux_D;\n\n  logic [C_LOG_WIDTH-1:0] Cnt_DP, Cnt_DN;\n  logic CntZero_S;\n\n  logic ARegEn_S, BRegEn_S, ResRegEn_S, ABComp_S, PmSel_S, LoadEn_S;\n\n  enum logic [1:0] {\n    IDLE,\n    DIVIDE,\n    FINISH\n  }\n      State_SN, State_SP;\n\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // datapath\n  ///////////////////////////////////////////////////////////////////////////////\n\n  assign PmSel_S  = LoadEn_S & ~(OpCode_SI[0] & (OpA_DI[$high(OpA_DI)] ^ OpBSign_SI));\n\n  // muxes\n  assign AddMux_D = (LoadEn_S) ? OpA_DI : BReg_DP;\n\n  // attention: logical shift in case of negative operand B!\n  assign BMux_D   = (LoadEn_S) ? OpB_DI : {CompInv_SP, (BReg_DP[$high(BReg_DP):1])};\n\n  genvar index;\n  generate\n    for (index = 0; index < C_WIDTH; index++) begin : gen_bit_swapping\n      assign ResReg_DP_rev[index] = ResReg_DP[C_WIDTH-1-index];\n    end\n  endgenerate\n\n  assign OutMux_D = (RemSel_SP) ? AReg_DP : ResReg_DP_rev;\n\n  // invert if necessary\n  assign Res_DO = (ResInv_SP) ? -$signed(OutMux_D) : OutMux_D;\n\n  // main comparator\n  assign ABComp_S    = ((AReg_DP == BReg_DP) | ((AReg_DP > BReg_DP) ^ CompInv_SP)) & ((|AReg_DP) | OpBIsZero_SI);\n\n  // main adder\n  assign AddTmp_D = (LoadEn_S) ? 0 : AReg_DP;\n  assign AddOut_D = (PmSel_S) ? AddTmp_D + AddMux_D : AddTmp_D - $signed(AddMux_D);\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // counter\n  ///////////////////////////////////////////////////////////////////////////////\n\n  assign Cnt_DN = (LoadEn_S) ? OpBShift_DI : (~CntZero_S) ? Cnt_DP - 1 : Cnt_DP;\n\n  assign CntZero_S = ~(|Cnt_DP);\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // FSM\n  ///////////////////////////////////////////////////////////////////////////////\n\n  always_comb begin : p_fsm\n    // default\n    State_SN   = State_SP;\n\n    OutVld_SO  = 1'b0;\n\n    LoadEn_S   = 1'b0;\n\n    ARegEn_S   = 1'b0;\n    BRegEn_S   = 1'b0;\n    ResRegEn_S = 1'b0;\n\n    case (State_SP)\n      /////////////////////////////////\n      IDLE: begin\n        OutVld_SO = 1'b1;\n\n        if (InVld_SI) begin\n          OutVld_SO = 1'b0;\n          ARegEn_S  = 1'b1;\n          BRegEn_S  = 1'b1;\n          LoadEn_S  = 1'b1;\n          State_SN  = DIVIDE;\n        end\n      end\n      /////////////////////////////////\n      DIVIDE: begin\n\n        ARegEn_S   = ABComp_S;\n        BRegEn_S   = 1'b1;\n        ResRegEn_S = 1'b1;\n\n        // calculation finished\n        // one more divide cycle (32nd divide cycle)\n        if (CntZero_S) begin\n          State_SN = FINISH;\n        end\n      end\n      /////////////////////////////////\n      FINISH: begin\n        OutVld_SO = 1'b1;\n\n        if (OutRdy_SI) begin\n          State_SN = IDLE;\n        end\n      end\n      /////////////////////////////////\n      default:  /* default */;\n      /////////////////////////////////\n    endcase\n  end\n\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // regs\n  ///////////////////////////////////////////////////////////////////////////////\n\n  // get flags\n  assign RemSel_SN = (LoadEn_S) ? OpCode_SI[1] : RemSel_SP;\n  assign CompInv_SN = (LoadEn_S) ? OpBSign_SI : CompInv_SP;\n  assign ResInv_SN = (LoadEn_S) ? (~OpBIsZero_SI | OpCode_SI[1]) & OpCode_SI[0] & (OpA_DI[$high(\n      OpA_DI\n  )] ^ OpBSign_SI) : ResInv_SP;\n\n  assign AReg_DN = (ARegEn_S) ? AddOut_D : AReg_DP;\n  assign BReg_DN = (BRegEn_S) ? BMux_D : BReg_DP;\n  assign ResReg_DN = (LoadEn_S) ? '0 : (ResRegEn_S) ? {\n    ABComp_S, ResReg_DP[$high(ResReg_DP):1]\n  } : ResReg_DP;\n\n  always_ff @(posedge Clk_CI or negedge Rst_RBI) begin : p_regs\n    if (~Rst_RBI) begin\n      State_SP   <= IDLE;\n      AReg_DP    <= '0;\n      BReg_DP    <= '0;\n      ResReg_DP  <= '0;\n      Cnt_DP     <= '0;\n      RemSel_SP  <= 1'b0;\n      CompInv_SP <= 1'b0;\n      ResInv_SP  <= 1'b0;\n    end else begin\n      State_SP   <= State_SN;\n      AReg_DP    <= AReg_DN;\n      BReg_DP    <= BReg_DN;\n      ResReg_DP  <= ResReg_DN;\n      Cnt_DP     <= Cnt_DN;\n      RemSel_SP  <= RemSel_SN;\n      CompInv_SP <= CompInv_SN;\n      ResInv_SP  <= ResInv_SN;\n    end\n  end\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////////////////////////////\n\n`ifdef CV32E40P_ASSERT_ON\n  initial begin : p_assertions\n    assert (C_LOG_WIDTH == $clog2(C_WIDTH + 1))\n    else $error(\"C_LOG_WIDTH must be $clog2(C_WIDTH+1)\");\n  end\n`endif\n\nendmodule  // serDiv\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Lukas Mueller - lukasmue@student.ethz.ch                   //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Simple APU dispatcher                                      //\n// Project Name:   PULP                                                       //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Dispatcher for sending instructions to the Marx            //\n//                 interconnect.                                              //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_apu_disp (\n    input logic clk_i,\n    input logic rst_ni,\n\n    // request input\n    input logic       enable_i,\n    input logic [1:0] apu_lat_i,\n    input logic [5:0] apu_waddr_i,\n\n    // response output\n    output logic [5:0] apu_waddr_o,\n    output logic       apu_multicycle_o,\n    output logic       apu_singlecycle_o,\n\n    // active signal\n    output logic active_o,\n\n    // stall signals\n    output logic stall_o,\n\n    // dependency checks\n    input  logic            is_decoding_i,\n    input  logic [2:0][5:0] read_regs_i,\n    input  logic [2:0]      read_regs_valid_i,\n    output logic            read_dep_o,\n    output logic            read_dep_for_jalr_o,\n\n    input  logic [1:0][5:0] write_regs_i,\n    input  logic [1:0]      write_regs_valid_i,\n    output logic            write_dep_o,\n\n    // perf counter stuff\n    output logic perf_type_o,\n    output logic perf_cont_o,\n\n    // apu-interconnect\n    // handshake signals\n    output logic apu_req_o,\n    input  logic apu_gnt_i,\n    // response channel\n    input  logic apu_rvalid_i\n\n);\n\n  logic [5:0] addr_req, addr_inflight, addr_waiting;\n  logic [5:0] addr_inflight_dn, addr_waiting_dn;\n  logic valid_req, valid_inflight, valid_waiting;\n  logic valid_inflight_dn, valid_waiting_dn;\n  logic returned_req, returned_inflight, returned_waiting;\n\n  logic       req_accepted;\n  logic       active;\n  logic [1:0] apu_lat;\n\n\n  logic [2:0] read_deps_req, read_deps_inflight, read_deps_waiting;\n  logic [1:0] write_deps_req, write_deps_inflight, write_deps_waiting;\n  logic read_dep_req, read_dep_inflight, read_dep_waiting;\n  logic write_dep_req, write_dep_inflight, write_dep_waiting;\n\n  logic stall_full, stall_type, stall_nack;\n\n  // Generate request signal; do not generate request if stalled unless it's a nack stall\n  assign valid_req         = enable_i & !(stall_full | stall_type);\n  assign addr_req          = apu_waddr_i;\n\n  assign req_accepted      = valid_req & apu_gnt_i;\n\n  //\n  // In-flight instructions\n  //\n  // Check whether the instructions have returned\n  assign returned_req      = valid_req & apu_rvalid_i & !valid_inflight & !valid_waiting;\n  assign returned_inflight = valid_inflight & (apu_rvalid_i) & !valid_waiting;\n  assign returned_waiting  = valid_waiting & (apu_rvalid_i);\n\n  // Inflight and waiting registers\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      valid_inflight <= 1'b0;\n      valid_waiting  <= 1'b0;\n      addr_inflight  <= '0;\n      addr_waiting   <= '0;\n    end else begin\n      valid_inflight <= valid_inflight_dn;\n      valid_waiting  <= valid_waiting_dn;\n      addr_inflight  <= addr_inflight_dn;\n      addr_waiting   <= addr_waiting_dn;\n    end\n  end\n\n  always_comb begin\n    valid_inflight_dn = valid_inflight;\n    valid_waiting_dn  = valid_waiting;\n    addr_inflight_dn  = addr_inflight;\n    addr_waiting_dn   = addr_waiting;\n\n    if (req_accepted & !returned_req) begin  // this is a multicycle request\n      valid_inflight_dn = 1'b1;\n      addr_inflight_dn  = addr_req;\n      if (valid_inflight & !(returned_inflight)) begin  // we already have an inflight instruction!\n        valid_waiting_dn = 1'b1;\n        addr_waiting_dn  = addr_inflight;\n      end\n      if (returned_waiting) begin // we have received a new request and waiting goes out of the pipe but will be refilled\n        valid_waiting_dn = 1'b1;\n        addr_waiting_dn  = addr_inflight;\n      end\n    end // no new request\n     else if (returned_inflight) begin // multicycle request has returned\n      valid_inflight_dn = '0;\n      valid_waiting_dn  = '0;\n      addr_inflight_dn  = '0;\n      addr_waiting_dn   = '0;\n    end else if (returned_waiting) begin  // multicycle request has returned\n      valid_waiting_dn = '0;\n      addr_waiting_dn  = '0;\n    end\n  end\n\n  //\n  // Active type\n  //\n  // Dispatcher is active when there is an unreturned instruction\n  assign active = valid_inflight | valid_waiting;\n\n  // Store the latency type whenever there is a request\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      apu_lat <= '0;\n    end else begin\n      if (valid_req) begin\n        apu_lat <= apu_lat_i;\n      end\n    end\n  end\n\n  //\n  // Dependency checks\n  //\n  // There is a dependency if the register is equal to one of the instructions\n  generate\n    for (genvar i = 0; i < 3; i++) begin : gen_read_deps\n      assign read_deps_req[i]      = (read_regs_i[i] == addr_req) & read_regs_valid_i[i];\n      assign read_deps_inflight[i] = (read_regs_i[i] == addr_inflight) & read_regs_valid_i[i];\n      assign read_deps_waiting[i]  = (read_regs_i[i] == addr_waiting) & read_regs_valid_i[i];\n    end\n  endgenerate\n\n  generate\n    for (genvar i = 0; i < 2; i++) begin : gen_write_deps\n      assign write_deps_req[i]      = (write_regs_i[i] == addr_req) & write_regs_valid_i[i];\n      assign write_deps_inflight[i] = (write_regs_i[i] == addr_inflight) & write_regs_valid_i[i];\n      assign write_deps_waiting[i]  = (write_regs_i[i] == addr_waiting) & write_regs_valid_i[i];\n    end\n  endgenerate\n\n  // Reduce the individual dependency signals into one read and one write dependency\n  assign read_dep_req = |read_deps_req & valid_req & !returned_req;\n  assign read_dep_inflight = |read_deps_inflight & valid_inflight & !returned_inflight;\n  assign read_dep_waiting = |read_deps_waiting & valid_waiting & !returned_waiting;\n  assign write_dep_req = |write_deps_req & valid_req & !returned_req;\n  assign write_dep_inflight = |write_deps_inflight & valid_inflight & !returned_inflight;\n  assign write_dep_waiting = |write_deps_waiting & valid_waiting & !returned_waiting;\n\n  assign read_dep_o = (read_dep_req | read_dep_inflight | read_dep_waiting) & is_decoding_i;\n  assign write_dep_o = (write_dep_req | write_dep_inflight | write_dep_waiting) & is_decoding_i;\n\n  assign read_dep_for_jalr_o = is_decoding_i & ((|read_deps_req & enable_i) |\n                                                (|read_deps_inflight & valid_inflight) |\n                                                (|read_deps_waiting & valid_waiting));\n\n  //\n  // Stall signals\n  //\n  // Stall if we cannot store any more outstanding requests\n  assign stall_full = valid_inflight & valid_waiting;\n  // Stall if there is a type conflict. if apu is active we can only issue requests with a larger or equal latency\n  // than the latency of the inflight operation (apu_lat_i>=apu_lat). otherwise operations would overtake each other!\n  // so we stall if: (apu_lat_i = 1 & apu_lat = 2/3) | (apu_lat_i = 2 & apu_lat = 3) | (apu_lat_i = 3 (multicycle))\n  assign stall_type      = enable_i  & active & ((apu_lat_i==2'h1) | ((apu_lat_i==2'h2) & (apu_lat==2'h3)) | (apu_lat_i==2'h3));\n  assign stall_nack = valid_req & !apu_gnt_i;\n  assign stall_o = stall_full | stall_type | stall_nack;\n\n  //\n  // Generate Apu_master request\n  //\n  assign apu_req_o = valid_req;\n\n\n  // Determine write register based on where the instruction returned.\n  always_comb begin\n    apu_waddr_o = '0;\n    if (returned_req) apu_waddr_o = addr_req;\n    if (returned_inflight) apu_waddr_o = addr_inflight;\n    if (returned_waiting) apu_waddr_o = addr_waiting;\n  end\n\n  // Output active signal\n  assign active_o = active;\n\n  // Performance counter signals\n  assign perf_type_o = stall_type;\n  assign perf_cont_o = stall_nack;\n\n  assign apu_multicycle_o = (apu_lat == 2'h3);\n  assign apu_singlecycle_o = ~(valid_inflight | valid_waiting);\n\n  //\n  // Assertions\n  //\n\n`ifdef CV32E40P_ASSERT_ON\n  assert property (@(posedge clk_i) (apu_rvalid_i) |-> (valid_req | valid_inflight | valid_waiting))\n  else $warning(\"[APU Dispatcher] instruction returned while no instruction is in-flight\");\n`endif\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Sven Stucki - svstucki@student.ethz.ch                     //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Compressed instruction decoder                             //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Decodes RISC-V compressed instructions into their RV32     //\n//                 equivalent. This module is fully combinatorial.            //\n//                 Float extensions added                                     //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_compressed_decoder #(\n    parameter FPU   = 0,\n    parameter ZFINX = 0\n) (\n    input  logic [31:0] instr_i,\n    output logic [31:0] instr_o,\n    output logic        is_compressed_o,\n    output logic        illegal_instr_o\n);\n\n  import cv32e40p_pkg::*;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n  //   ____                                                 _   ____                     _            //\n  //  / ___|___  _ __ ___  _ __  _ __ ___  ___ ___  ___  __| | |  _ \\  ___  ___ ___   __| | ___ _ __  //\n  // | |   / _ \\| '_ ` _ \\| '_ \\| '__/ _ \\/ __/ __|/ _ \\/ _` | | | | |/ _ \\/ __/ _ \\ / _` |/ _ \\ '__| //\n  // | |__| (_) | | | | | | |_) | | |  __/\\__ \\__ \\  __/ (_| | | |_| |  __/ (_| (_) | (_| |  __/ |    //\n  //  \\____\\___/|_| |_| |_| .__/|_|  \\___||___/___/\\___|\\__,_| |____/ \\___|\\___\\___/ \\__,_|\\___|_|    //\n  //                      |_|                                                                         //\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  always_comb begin\n    illegal_instr_o = 1'b0;\n    instr_o         = '0;\n\n    unique case (instr_i[1:0])\n      // C0\n      2'b00: begin\n        unique case (instr_i[15:13])\n          3'b000: begin\n            // c.addi4spn -> addi rd', x2, imm\n            instr_o = {\n              2'b0,\n              instr_i[10:7],\n              instr_i[12:11],\n              instr_i[5],\n              instr_i[6],\n              2'b00,\n              5'h02,\n              3'b000,\n              2'b01,\n              instr_i[4:2],\n              OPCODE_OPIMM\n            };\n            if (instr_i[12:5] == 8'b0) illegal_instr_o = 1'b1;\n          end\n\n          3'b001: begin\n            // c.fld -> fld rd', imm(rs1')\n            if (FPU == 1 && ZFINX == 0)\n              // instr_i[12:10]-> offset[5:3],  instr_i[6:5]-> offset[7:6]\n              instr_o = {\n                4'b0,\n                instr_i[6:5],\n                instr_i[12:10],\n                3'b000,\n                2'b01,\n                instr_i[9:7],\n                3'b011,\n                2'b01,\n                instr_i[4:2],\n                OPCODE_LOAD_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n\n          3'b010: begin\n            // c.lw -> lw rd', imm(rs1')\n            instr_o = {\n              5'b0,\n              instr_i[5],\n              instr_i[12:10],\n              instr_i[6],\n              2'b00,\n              2'b01,\n              instr_i[9:7],\n              3'b010,\n              2'b01,\n              instr_i[4:2],\n              OPCODE_LOAD\n            };\n          end\n\n          3'b011: begin\n            // c.flw -> flw rd', imm(rs1')\n            if (FPU == 1 && ZFINX == 0)\n              instr_o = {\n                5'b0,\n                instr_i[5],\n                instr_i[12:10],\n                instr_i[6],\n                2'b00,\n                2'b01,\n                instr_i[9:7],\n                3'b010,\n                2'b01,\n                instr_i[4:2],\n                OPCODE_LOAD_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n\n          3'b101: begin\n            // c.fsd -> fsd rs2', imm(rs1')\n            if (FPU == 1 && ZFINX == 0)\n              // instr_i[12:10] -> offset[5:3], instr_i[6:5] -> offset[7:6]\n              instr_o = {\n                4'b0,\n                instr_i[6:5],\n                instr_i[12],\n                2'b01,\n                instr_i[4:2],\n                2'b01,\n                instr_i[9:7],\n                3'b011,\n                instr_i[11:10],\n                3'b000,\n                OPCODE_STORE_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n\n          3'b110: begin\n            // c.sw -> sw rs2', imm(rs1')\n            instr_o = {\n              5'b0,\n              instr_i[5],\n              instr_i[12],\n              2'b01,\n              instr_i[4:2],\n              2'b01,\n              instr_i[9:7],\n              3'b010,\n              instr_i[11:10],\n              instr_i[6],\n              2'b00,\n              OPCODE_STORE\n            };\n          end\n\n          3'b111: begin\n            // c.fsw -> fsw rs2', imm(rs1')\n            if (FPU == 1 && ZFINX == 0)\n              instr_o = {\n                5'b0,\n                instr_i[5],\n                instr_i[12],\n                2'b01,\n                instr_i[4:2],\n                2'b01,\n                instr_i[9:7],\n                3'b010,\n                instr_i[11:10],\n                instr_i[6],\n                2'b00,\n                OPCODE_STORE_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n          default: begin\n            illegal_instr_o = 1'b1;\n          end\n        endcase\n      end\n\n\n      // C1\n      2'b01: begin\n        unique case (instr_i[15:13])\n          3'b000: begin\n            // c.addi -> addi rd, rd, nzimm\n            // c.nop\n            instr_o = {\n              {6{instr_i[12]}},\n              instr_i[12],\n              instr_i[6:2],\n              instr_i[11:7],\n              3'b0,\n              instr_i[11:7],\n              OPCODE_OPIMM\n            };\n          end\n\n          3'b001, 3'b101: begin\n            // 001: c.jal -> jal x1, imm\n            // 101: c.j   -> jal x0, imm\n            instr_o = {\n              instr_i[12],\n              instr_i[8],\n              instr_i[10:9],\n              instr_i[6],\n              instr_i[7],\n              instr_i[2],\n              instr_i[11],\n              instr_i[5:3],\n              {9{instr_i[12]}},\n              4'b0,\n              ~instr_i[15],\n              OPCODE_JAL\n            };\n          end\n\n          3'b010: begin\n            if (instr_i[11:7] == 5'b0) begin\n              // Hint -> addi x0, x0, nzimm\n              instr_o = {\n                {6{instr_i[12]}}, instr_i[12], instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], OPCODE_OPIMM\n              };\n            end else begin\n              // c.li -> addi rd, x0, nzimm\n              instr_o = {\n                {6{instr_i[12]}}, instr_i[12], instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], OPCODE_OPIMM\n              };\n            end\n          end\n\n          3'b011: begin\n            if ({instr_i[12], instr_i[6:2]} == 6'b0) begin\n              illegal_instr_o = 1'b1;\n            end else begin\n              if (instr_i[11:7] == 5'h02) begin\n                // c.addi16sp -> addi x2, x2, nzimm\n                instr_o = {\n                  {3{instr_i[12]}},\n                  instr_i[4:3],\n                  instr_i[5],\n                  instr_i[2],\n                  instr_i[6],\n                  4'b0,\n                  5'h02,\n                  3'b000,\n                  5'h02,\n                  OPCODE_OPIMM\n                };\n              end else if (instr_i[11:7] == 5'b0) begin\n                // Hint -> lui x0, imm\n                instr_o = {{15{instr_i[12]}}, instr_i[6:2], instr_i[11:7], OPCODE_LUI};\n              end else begin\n                // c.lui -> lui rd, imm\n                instr_o = {{15{instr_i[12]}}, instr_i[6:2], instr_i[11:7], OPCODE_LUI};\n              end\n            end\n          end\n\n          3'b100: begin\n            unique case (instr_i[11:10])\n              2'b00, 2'b01: begin\n                // 00: c.srli -> srli rd, rd, shamt\n                // 01: c.srai -> srai rd, rd, shamt\n                if (instr_i[12] == 1'b1) begin\n                  // Reserved for future custom extensions (instr_o don't care)\n                  instr_o = {\n                    1'b0,\n                    instr_i[10],\n                    5'b0,\n                    instr_i[6:2],\n                    2'b01,\n                    instr_i[9:7],\n                    3'b101,\n                    2'b01,\n                    instr_i[9:7],\n                    OPCODE_OPIMM\n                  };\n                  illegal_instr_o = 1'b1;\n                end else begin\n                  if (instr_i[6:2] == 5'b0) begin\n                    // Hint\n                    instr_o = {\n                      1'b0,\n                      instr_i[10],\n                      5'b0,\n                      instr_i[6:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b101,\n                      2'b01,\n                      instr_i[9:7],\n                      OPCODE_OPIMM\n                    };\n                  end else begin\n                    instr_o = {\n                      1'b0,\n                      instr_i[10],\n                      5'b0,\n                      instr_i[6:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b101,\n                      2'b01,\n                      instr_i[9:7],\n                      OPCODE_OPIMM\n                    };\n                  end\n                end\n              end\n\n              2'b10: begin\n                // c.andi -> andi rd, rd, imm\n                instr_o = {\n                  {6{instr_i[12]}},\n                  instr_i[12],\n                  instr_i[6:2],\n                  2'b01,\n                  instr_i[9:7],\n                  3'b111,\n                  2'b01,\n                  instr_i[9:7],\n                  OPCODE_OPIMM\n                };\n              end\n\n              2'b11: begin\n                unique case ({\n                  instr_i[12], instr_i[6:5]\n                })\n                  3'b000: begin\n                    // c.sub -> sub rd', rd', rs2'\n                    instr_o = {\n                      2'b01,\n                      5'b0,\n                      2'b01,\n                      instr_i[4:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b000,\n                      2'b01,\n                      instr_i[9:7],\n                      OPCODE_OP\n                    };\n                  end\n\n                  3'b001: begin\n                    // c.xor -> xor rd', rd', rs2'\n                    instr_o = {\n                      7'b0,\n                      2'b01,\n                      instr_i[4:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b100,\n                      2'b01,\n                      instr_i[9:7],\n                      OPCODE_OP\n                    };\n                  end\n\n                  3'b010: begin\n                    // c.or  -> or  rd', rd', rs2'\n                    instr_o = {\n                      7'b0,\n                      2'b01,\n                      instr_i[4:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b110,\n                      2'b01,\n                      instr_i[9:7],\n                      OPCODE_OP\n                    };\n                  end\n\n                  3'b011: begin\n                    // c.and -> and rd', rd', rs2'\n                    instr_o = {\n                      7'b0,\n                      2'b01,\n                      instr_i[4:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b111,\n                      2'b01,\n                      instr_i[9:7],\n                      OPCODE_OP\n                    };\n                  end\n\n                  3'b100, 3'b101, 3'b110, 3'b111: begin\n                    // 100: c.subw\n                    // 101: c.addw\n                    illegal_instr_o = 1'b1;\n                  end\n                endcase\n              end\n            endcase\n          end\n\n          3'b110, 3'b111: begin\n            // 0: c.beqz -> beq rs1', x0, imm\n            // 1: c.bnez -> bne rs1', x0, imm\n            instr_o = {\n              {4{instr_i[12]}},\n              instr_i[6:5],\n              instr_i[2],\n              5'b0,\n              2'b01,\n              instr_i[9:7],\n              2'b00,\n              instr_i[13],\n              instr_i[11:10],\n              instr_i[4:3],\n              instr_i[12],\n              OPCODE_BRANCH\n            };\n          end\n        endcase\n      end\n\n      // C2\n      2'b10: begin\n        unique case (instr_i[15:13])\n          3'b000: begin\n            if (instr_i[12] == 1'b1) begin\n              // Reserved for future extensions (instr_o don't care)\n              instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], OPCODE_OPIMM};\n              illegal_instr_o = 1'b1;\n            end else begin\n              if ((instr_i[6:2] == 5'b0) || (instr_i[11:7] == 5'b0)) begin\n                // Hint -> slli rd, rd, shamt \n                instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], OPCODE_OPIMM};\n              end else begin\n                // c.slli -> slli rd, rd, shamt\n                instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b001, instr_i[11:7], OPCODE_OPIMM};\n              end\n            end\n          end\n\n          3'b001: begin\n            // c.fldsp -> fld rd, imm(x2)\n            if (FPU == 1 && ZFINX == 0)\n              // instr_i[6:5] -> offset[4:3], instr_i[4:2] -> offset[8:6], instr_i[12] -> offset[5]\n              instr_o = {\n                3'b0,\n                instr_i[4:2],\n                instr_i[12],\n                instr_i[6:5],\n                3'b000,\n                5'h02,\n                3'b011,\n                instr_i[11:7],\n                OPCODE_LOAD_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n\n          3'b010: begin\n            // c.lwsp -> lw rd, imm(x2)\n            instr_o = {\n              4'b0,\n              instr_i[3:2],\n              instr_i[12],\n              instr_i[6:4],\n              2'b00,\n              5'h02,\n              3'b010,\n              instr_i[11:7],\n              OPCODE_LOAD\n            };\n            if (instr_i[11:7] == 5'b0) illegal_instr_o = 1'b1;\n          end\n\n          3'b011: begin\n            // c.flwsp -> flw rd, imm(x2)\n            if (FPU == 1 && ZFINX == 0)\n              instr_o = {\n                4'b0,\n                instr_i[3:2],\n                instr_i[12],\n                instr_i[6:4],\n                2'b00,\n                5'h02,\n                3'b010,\n                instr_i[11:7],\n                OPCODE_LOAD_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n\n          3'b100: begin\n            if (instr_i[12] == 1'b0) begin\n              if (instr_i[6:2] == 5'b0) begin\n                // c.jr -> jalr x0, rd/rs1, 0\n                instr_o = {12'b0, instr_i[11:7], 3'b0, 5'b0, OPCODE_JALR};\n                // c.jr with rs1 = 0 is reserved\n                if (instr_i[11:7] == 5'b0) illegal_instr_o = 1'b1;\n              end else begin\n                if (instr_i[11:7] == 5'b0) begin\n                  // Hint -> add x0, x0, rs2\n                  instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], OPCODE_OP};\n                end else begin\n                  // c.mv -> add rd, x0, rs2\n                  instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], OPCODE_OP};\n                end\n              end\n            end else begin\n              if (instr_i[6:2] == 5'b0) begin\n                if (instr_i[11:7] == 5'b0) begin\n                  // c.ebreak -> ebreak\n                  instr_o = {32'h00_10_00_73};\n                end else begin\n                  // c.jalr -> jalr x1, rs1, 0\n                  instr_o = {12'b0, instr_i[11:7], 3'b000, 5'b00001, OPCODE_JALR};\n                end\n              end else begin\n                if (instr_i[11:7] == 5'b0) begin\n                  // Hint -> add x0, x0, rs2\n                  instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], OPCODE_OP};\n                end else begin\n                  // c.add -> add rd, rd, rs2\n                  instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], OPCODE_OP};\n                end\n              end\n            end\n          end\n\n          3'b101: begin\n            // c.fsdsp -> fsd rs2, imm(x2)\n            if (FPU == 1 && ZFINX == 0)\n              // instr_i[12:10] -> offset[5:3], instr_i[9:7] -> offset[8:6]\n              instr_o = {\n                3'b0,\n                instr_i[9:7],\n                instr_i[12],\n                instr_i[6:2],\n                5'h02,\n                3'b011,\n                instr_i[11:10],\n                3'b000,\n                OPCODE_STORE_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n          3'b110: begin\n            // c.swsp -> sw rs2, imm(x2)\n            instr_o = {\n              4'b0,\n              instr_i[8:7],\n              instr_i[12],\n              instr_i[6:2],\n              5'h02,\n              3'b010,\n              instr_i[11:9],\n              2'b00,\n              OPCODE_STORE\n            };\n          end\n\n          3'b111: begin\n            // c.fswsp -> fsw rs2, imm(x2)\n            if (FPU == 1 && ZFINX == 0)\n              instr_o = {\n                4'b0,\n                instr_i[8:7],\n                instr_i[12],\n                instr_i[6:2],\n                5'h02,\n                3'b010,\n                instr_i[11:9],\n                2'b00,\n                OPCODE_STORE_FP\n              };\n            else illegal_instr_o = 1'b1;\n          end\n        endcase\n      end\n\n      default: begin\n        // 32 bit (or more) instruction\n        instr_o = instr_i;\n      end\n    endcase\n  end\n\n  assign is_compressed_o = (instr_i[1:0] != 2'b11);\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Matthias Baer - baermatt@student.ethz.ch                   //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Andreas Traber - atraber@student.ethz.ch                   //\n//                 Sven Stucki - svstucki@student.ethz.ch                     //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                 Robert Balas - balasr@iis.ee.ethz.ch                       //\n//                 Andrea Bettati - andrea.bettati@studenti.unipr.it          //\n//                                                                            //\n// Design Name:    Main controller                                            //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Main CPU controller of the processor                       //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_controller import cv32e40p_pkg::*;\n#(\n  parameter COREV_CLUSTER = 0,\n  parameter COREV_PULP    = 0,\n  parameter FPU           = 0\n)\n(\n  input  logic        clk,                        // Gated clock\n  input  logic        clk_ungated_i,              // Ungated clock\n  input  logic        rst_n,\n\n  input  logic        fetch_enable_i,             // Start the decoding\n  output logic        ctrl_busy_o,                // Core is busy processing instructions\n  output logic        is_decoding_o,              // Core is in decoding state\n  input  logic        is_fetch_failed_i,\n\n  // decoder related signals\n  output logic        deassert_we_o,              // deassert write enable for next instruction\n\n  input  logic        illegal_insn_i,             // decoder encountered an invalid instruction\n  input  logic        ecall_insn_i,               // decoder encountered an ecall instruction\n  input  logic        mret_insn_i,                // decoder encountered an mret instruction\n  input  logic        uret_insn_i,                // decoder encountered an uret instruction\n\n  input  logic        dret_insn_i,                // decoder encountered an dret instruction\n\n  input  logic        mret_dec_i,\n  input  logic        uret_dec_i,\n  input  logic        dret_dec_i,\n\n  input  logic        wfi_i,                      // decoder wants to execute a WFI\n  input  logic        ebrk_insn_i,                // decoder encountered an ebreak instruction\n  input  logic        fencei_insn_i,              // decoder encountered an fence.i instruction\n  input  logic        csr_status_i,               // decoder encountered an csr status instruction\n\n  output logic        hwlp_mask_o,                // prevent writes on the hwloop instructions in case interrupt are taken\n\n  // from IF/ID pipeline\n  input  logic        instr_valid_i,              // instruction coming from IF/ID pipeline is valid\n\n  // from prefetcher\n  output logic        instr_req_o,                // Start fetching instructions\n\n  // to prefetcher\n  output logic        pc_set_o,                   // jump to address set by pc_mux\n  output logic [3:0]  pc_mux_o,                   // Selector in the Fetch stage to select the rigth PC (normal, jump ...)\n  output logic [2:0]  exc_pc_mux_o,               // Selects target PC for exception\n  output logic [1:0]  trap_addr_mux_o,            // Selects trap address base\n\n  // HWLoop signls\n  input  logic [31:0]       pc_id_i,\n\n  // from hwloop_regs\n  input  logic [1:0] [31:0] hwlp_start_addr_i,\n  input  logic [1:0] [31:0] hwlp_end_addr_i,\n  input  logic [1:0] [31:0] hwlp_counter_i,\n\n  // to hwloop_regs\n  output logic [1:0]        hwlp_dec_cnt_o,\n\n  output logic              hwlp_jump_o,\n  output logic [31:0]       hwlp_targ_addr_o,\n\n  // LSU\n  input  logic        data_req_ex_i,              // data memory access is currently performed in EX stage\n  input  logic        data_we_ex_i,\n  input  logic        data_misaligned_i,\n  input  logic        data_load_event_i,\n  input  logic        data_err_i,\n  output logic        data_err_ack_o,\n\n  // from ALU\n  input  logic        mult_multicycle_i,          // multiplier is taken multiple cycles and uses op c as storage\n\n  // APU dependency checks\n  input  logic        apu_en_i,\n  input  logic        apu_read_dep_i,\n  input  logic        apu_read_dep_for_jalr_i,\n  input  logic        apu_write_dep_i,\n\n  output logic        apu_stall_o,\n\n  // jump/branch signals\n  input  logic        branch_taken_ex_i,          // branch taken signal from EX ALU\n  input  logic [1:0]  ctrl_transfer_insn_in_id_i,               // jump is being calculated in ALU\n  input  logic [1:0]  ctrl_transfer_insn_in_dec_i,              // jump is being calculated in ALU\n\n  // Interrupt Controller Signals\n  input  logic        irq_req_ctrl_i,\n  input  logic        irq_sec_ctrl_i,\n  input  logic [4:0]  irq_id_ctrl_i,\n  input  logic        irq_wu_ctrl_i,\n  input  PrivLvl_t    current_priv_lvl_i,\n\n  output logic        irq_ack_o,\n  output logic [4:0]  irq_id_o,\n\n  output logic [4:0]  exc_cause_o,\n\n  // Debug Signal\n  output logic         debug_mode_o,\n  output logic [2:0]   debug_cause_o,\n  output logic         debug_csr_save_o,\n  input  logic         debug_req_i,\n  input  logic         debug_single_step_i,\n  input  logic         debug_ebreakm_i,\n  input  logic         debug_ebreaku_i,\n  input  logic         trigger_match_i,\n  output logic         debug_p_elw_no_sleep_o,\n  output logic         debug_wfi_no_sleep_o,\n  output logic         debug_havereset_o,\n  output logic         debug_running_o,\n  output logic         debug_halted_o,\n\n  // Wakeup Signal\n  output logic        wake_from_sleep_o,\n\n  output logic        csr_save_if_o,\n  output logic        csr_save_id_o,\n  output logic        csr_save_ex_o,\n  output logic [5:0]  csr_cause_o,\n  output logic        csr_irq_sec_o,\n  output logic        csr_restore_mret_id_o,\n  output logic        csr_restore_uret_id_o,\n\n  output logic        csr_restore_dret_id_o,\n\n  output logic        csr_save_cause_o,\n\n\n  // Regfile target\n  input  logic        regfile_we_id_i,            // currently decoded we enable\n  input  logic [5:0]  regfile_alu_waddr_id_i,     // currently decoded target address\n\n  // Forwarding signals from regfile\n  input  logic        regfile_we_ex_i,            // FW: write enable from  EX stage\n  input  logic [5:0]  regfile_waddr_ex_i,         // FW: write address from EX stage\n  input  logic        regfile_we_wb_i,            // FW: write enable from  WB stage\n  input  logic        regfile_alu_we_fw_i,        // FW: ALU/MUL write enable from  EX stage\n\n  // forwarding signals\n  output logic [1:0]  operand_a_fw_mux_sel_o,     // regfile ra data selector form ID stage\n  output logic [1:0]  operand_b_fw_mux_sel_o,     // regfile rb data selector form ID stage\n  output logic [1:0]  operand_c_fw_mux_sel_o,     // regfile rc data selector form ID stage\n\n  // forwarding detection signals\n  input logic         reg_d_ex_is_reg_a_i,\n  input logic         reg_d_ex_is_reg_b_i,\n  input logic         reg_d_ex_is_reg_c_i,\n  input logic         reg_d_wb_is_reg_a_i,\n  input logic         reg_d_wb_is_reg_b_i,\n  input logic         reg_d_wb_is_reg_c_i,\n  input logic         reg_d_alu_is_reg_a_i,\n  input logic         reg_d_alu_is_reg_b_i,\n  input logic         reg_d_alu_is_reg_c_i,\n\n  // stall signals\n  output logic        halt_if_o,\n  output logic        halt_id_o,\n\n  output logic        misaligned_stall_o,\n  output logic        jr_stall_o,\n  output logic        load_stall_o,\n\n  input  logic        id_ready_i,                 // ID stage is ready\n  input  logic        id_valid_i,                 // ID stage is valid\n\n  input  logic        ex_valid_i,                 // EX stage is done\n\n  input  logic        wb_ready_i,                 // WB stage is ready\n\n  // Performance Counters\n  output logic        perf_pipeline_stall_o       // stall due to cv.elw extra cycles\n);\n\n  // FSM state encoding\n  ctrl_state_e ctrl_fsm_cs, ctrl_fsm_ns;\n\n  // Debug state\n  debug_state_e debug_fsm_cs, debug_fsm_ns;\n\n  logic jump_done, jump_done_q, jump_in_dec, branch_in_id;\n\n  logic data_err_q;\n\n  logic debug_mode_q, debug_mode_n;\n  logic ebrk_force_debug_mode;\n  logic is_hwlp_body;\n  logic illegal_insn_q, illegal_insn_n;\n  logic debug_req_entry_q, debug_req_entry_n;\n  logic debug_force_wakeup_q, debug_force_wakeup_n;\n\n  logic hwlp_end0_eq_pc;\n  logic hwlp_end1_eq_pc;\n  logic hwlp_counter0_gt_1;\n  logic hwlp_counter1_gt_1;\n  logic hwlp_counter0_eq_1;\n  logic hwlp_counter1_eq_1;\n  logic hwlp_counter0_eq_0;\n  logic hwlp_counter1_eq_0;\n  logic hwlp_end0_eq_pc_plus4;\n  logic hwlp_end1_eq_pc_plus4;\n  logic hwlp_start0_leq_pc;\n  logic hwlp_start1_leq_pc;\n  logic hwlp_end0_geq_pc;\n  logic hwlp_end1_geq_pc;\n  // Auxiliary signals to make hwlp_jump_o last only one cycle (converting it into a pulse)\n  logic hwlp_end_4_id_d, hwlp_end_4_id_q;\n\n  logic debug_req_q;\n  logic debug_req_pending;\n\n  // qualify wfi vs nosleep locally \n  logic wfi_active;\n\n\n  ////////////////////////////////////////////////////////////////////////////////////////////\n  //   ____ ___  ____  _____    ____ ___  _   _ _____ ____   ___  _     _     _____ ____    //\n  //  / ___/ _ \\|  _ \\| ____|  / ___/ _ \\| \\ | |_   _|  _ \\ / _ \\| |   | |   | ____|  _ \\   //\n  // | |  | | | | |_) |  _|   | |  | | | |  \\| | | | | |_) | | | | |   | |   |  _| | |_) |  //\n  // | |__| |_| |  _ <| |___  | |__| |_| | |\\  | | | |  _ <| |_| | |___| |___| |___|  _ <   //\n  //  \\____\\___/|_| \\_\\_____|  \\____\\___/|_| \\_| |_| |_| \\_\\\\___/|_____|_____|_____|_| \\_\\  //\n  //                                                                                        //\n  ////////////////////////////////////////////////////////////////////////////////////////////\n\n  always_comb\n  begin\n    // Default values\n\n    instr_req_o            = 1'b1;\n\n    data_err_ack_o         = 1'b0;\n\n    csr_save_if_o          = 1'b0;\n    csr_save_id_o          = 1'b0;\n    csr_save_ex_o          = 1'b0;\n    csr_restore_mret_id_o  = 1'b0;\n    csr_restore_uret_id_o  = 1'b0;\n\n    csr_restore_dret_id_o  = 1'b0;\n\n    csr_save_cause_o       = 1'b0;\n\n    exc_cause_o            = '0;\n    exc_pc_mux_o           = EXC_PC_IRQ;\n    trap_addr_mux_o        = TRAP_MACHINE;\n\n    csr_cause_o            = '0;\n    csr_irq_sec_o          = 1'b0;\n\n    pc_mux_o               = PC_BOOT;\n    pc_set_o               = 1'b0;\n    jump_done              = jump_done_q;\n\n    ctrl_fsm_ns            = ctrl_fsm_cs;\n\n    ctrl_busy_o            = 1'b1;\n\n    halt_if_o              = 1'b0;\n    halt_id_o              = 1'b0;\n    is_decoding_o          = 1'b0;\n    irq_ack_o              = 1'b0;\n    irq_id_o               = 5'b0;\n\n    jump_in_dec            = ctrl_transfer_insn_in_dec_i == BRANCH_JALR || ctrl_transfer_insn_in_dec_i == BRANCH_JAL;\n\n    branch_in_id           = ctrl_transfer_insn_in_id_i == BRANCH_COND;\n\n    ebrk_force_debug_mode  = (debug_ebreakm_i && current_priv_lvl_i == PRIV_LVL_M) ||\n                             (debug_ebreaku_i && current_priv_lvl_i == PRIV_LVL_U);\n    debug_csr_save_o       = 1'b0;\n    debug_cause_o          = DBG_CAUSE_EBREAK;\n    debug_mode_n           = debug_mode_q;\n\n    illegal_insn_n         = illegal_insn_q;\n    // a trap towards the debug unit is generated when one of the\n    // following conditions are true:\n    // - ebreak instruction encountered\n    // - single-stepping mode enabled\n    // - illegal instruction exception and IIE bit is set\n    // - IRQ and INTE bit is set and no exception is currently running\n    // - Debuger requests halt\n\n    debug_req_entry_n       = debug_req_entry_q;\n\n    debug_force_wakeup_n    = debug_force_wakeup_q;\n\n    perf_pipeline_stall_o   = 1'b0;\n\n    hwlp_mask_o             = 1'b0;\n\n    hwlp_dec_cnt_o          = '0;\n    hwlp_end_4_id_d         = 1'b0;\n\n    // When the controller tells to hwlp-jump, the prefetcher does not always jump immediately,\n    // but the aligner immediately modifies pc_id to HWLP_BEGIN. This condition on hwlp_targ_addr_o\n    // ensures that the target is kept constant even if pc_id is no more HWLP_END\n    hwlp_targ_addr_o        = ((hwlp_start1_leq_pc && hwlp_end1_geq_pc) && !(hwlp_start0_leq_pc && hwlp_end0_geq_pc)) ? hwlp_start_addr_i[1] : hwlp_start_addr_i[0];\n\n    unique case (ctrl_fsm_cs)\n      // We were just reset, wait for fetch_enable\n      RESET:\n      begin\n        is_decoding_o = 1'b0;\n        instr_req_o   = 1'b0;\n        if (fetch_enable_i == 1'b1)\n        begin\n          ctrl_fsm_ns = BOOT_SET;\n        end\n      end\n\n      // copy boot address to instr fetch address\n      BOOT_SET:\n      begin\n        is_decoding_o = 1'b0;\n        instr_req_o   = 1'b1;\n        pc_mux_o      = PC_BOOT;\n        pc_set_o      = 1'b1;\n        if (debug_req_pending) begin\n            ctrl_fsm_ns = DBG_TAKEN_IF;\n            debug_force_wakeup_n = 1'b1;\n        end else begin\n            ctrl_fsm_ns   = FIRST_FETCH;\n        end\n      end\n\n      WAIT_SLEEP:\n      begin\n        is_decoding_o = 1'b0;\n        ctrl_busy_o   = 1'b0;\n        instr_req_o   = 1'b0;\n        halt_if_o     = 1'b1;\n        halt_id_o     = 1'b1;\n        ctrl_fsm_ns   = SLEEP;\n      end\n\n      // instruction in if_stage is already valid\n      SLEEP:\n      begin\n        // we begin execution when an\n        // interrupt has arrived\n        is_decoding_o = 1'b0;\n        instr_req_o   = 1'b0;\n        halt_if_o     = 1'b1;\n        halt_id_o     = 1'b1;\n\n        // normal execution flow\n        // in debug mode or single step mode we leave immediately (wfi=nop)\n        if (wake_from_sleep_o) begin\n          if (debug_req_pending) begin\n              ctrl_fsm_ns = DBG_TAKEN_IF;\n              debug_force_wakeup_n = 1'b1;\n          end else begin\n              ctrl_fsm_ns  = FIRST_FETCH;\n          end\n        end else begin\n          ctrl_busy_o = 1'b0;\n        end\n      end\n\n      FIRST_FETCH:\n      begin\n        is_decoding_o = 1'b0;\n\n        // ID stage is always ready\n        ctrl_fsm_ns = DECODE;\n\n        // handle interrupts\n        if (irq_req_ctrl_i && ~(debug_req_pending || debug_mode_q)) begin\n          // This assumes that the pipeline is always flushed before\n          // going to sleep.\n          // Debug mode takes precedence over irq (see DECODE:)\n\n          // Taken IRQ\n          halt_if_o         = 1'b1;\n          halt_id_o         = 1'b1;\n\n          pc_set_o          = 1'b1;\n          pc_mux_o          = PC_EXCEPTION;\n          exc_pc_mux_o      = EXC_PC_IRQ;\n          exc_cause_o       = irq_id_ctrl_i;\n          csr_irq_sec_o     = irq_sec_ctrl_i;\n\n          // IRQ interface\n          irq_ack_o         = 1'b1;\n          irq_id_o          = irq_id_ctrl_i;\n\n          if (irq_sec_ctrl_i)\n            trap_addr_mux_o  = TRAP_MACHINE;\n          else\n            trap_addr_mux_o  = current_priv_lvl_i == PRIV_LVL_U ? TRAP_USER : TRAP_MACHINE;\n\n          csr_save_cause_o  = 1'b1;\n          csr_cause_o       = {1'b1,irq_id_ctrl_i};\n          csr_save_if_o     = 1'b1;\n        end\n      end\n\n      DECODE:\n      begin\n\n          if (branch_taken_ex_i)\n          begin //taken branch\n            // there is a branch in the EX stage that is taken\n\n            is_decoding_o = 1'b0;\n\n            pc_mux_o      = PC_BRANCH;\n            pc_set_o      = 1'b1;\n\n            // if we want to debug, flush the pipeline\n            // the current_pc_if will take the value of the next instruction to\n            // be executed (NPC)\n\n          end  //taken branch\n\n          else if (data_err_i)\n          begin //data error\n            // the current LW or SW have been blocked by the PMP\n\n            is_decoding_o     = 1'b0;\n            halt_if_o         = 1'b1;\n            halt_id_o         = 1'b1;\n            csr_save_ex_o     = 1'b1;\n            csr_save_cause_o  = 1'b1;\n            data_err_ack_o    = 1'b1;\n            //no jump in this stage as we have to wait one cycle to go to Machine Mode\n\n            csr_cause_o       = {1'b0, data_we_ex_i ? EXC_CAUSE_STORE_FAULT : EXC_CAUSE_LOAD_FAULT};\n            ctrl_fsm_ns       = FLUSH_WB;\n\n          end  //data error\n\n          else if (is_fetch_failed_i)\n          begin\n\n            // the current instruction has been blocked by the PMP\n\n            is_decoding_o     = 1'b0;\n            halt_id_o         = 1'b1;\n            halt_if_o         = 1'b1;\n            csr_save_if_o     = 1'b1;\n            csr_save_cause_o  = !debug_mode_q;\n\n            //no jump in this stage as we have to wait one cycle to go to Machine Mode\n\n            csr_cause_o       = {1'b0, EXC_CAUSE_INSTR_FAULT};\n            ctrl_fsm_ns       = FLUSH_WB;\n\n\n          end\n          // decode and execute instructions only if the current conditional\n          // branch in the EX stage is either not taken, or there is no\n          // conditional branch in the EX stage\n          else if (instr_valid_i) //valid block\n          begin: blk_decode_level1 // now analyze the current instruction in the ID stage\n\n            is_decoding_o = 1'b1;\n            illegal_insn_n = 1'b0;\n\n            if ( (debug_req_pending || trigger_match_i) & ~debug_mode_q )\n              begin\n                //Serving the debug\n                is_decoding_o     = COREV_PULP ? 1'b0 : 1'b1;\n                halt_if_o         = 1'b1;\n                halt_id_o         = 1'b1;\n                ctrl_fsm_ns       = DBG_FLUSH;\n                debug_req_entry_n = 1'b1;\n              end\n            else if (irq_req_ctrl_i && ~debug_mode_q)\n              begin\n                // Taken IRQ\n                hwlp_mask_o       = COREV_PULP ? 1'b1 : 1'b0;\n\n                is_decoding_o     = 1'b0;\n                halt_if_o         = 1'b1;\n                halt_id_o         = 1'b1;\n\n                pc_set_o          = 1'b1;\n                pc_mux_o          = PC_EXCEPTION;\n                exc_pc_mux_o      = EXC_PC_IRQ;\n                exc_cause_o       = irq_id_ctrl_i;\n                csr_irq_sec_o     = irq_sec_ctrl_i;\n\n                // IRQ interface\n                irq_ack_o         = 1'b1;\n                irq_id_o          = irq_id_ctrl_i;\n\n                if (irq_sec_ctrl_i)\n                  trap_addr_mux_o  = TRAP_MACHINE;\n                else\n                  trap_addr_mux_o  = current_priv_lvl_i == PRIV_LVL_U ? TRAP_USER : TRAP_MACHINE;\n\n                csr_save_cause_o  = 1'b1;\n                csr_cause_o       = {1'b1,irq_id_ctrl_i};\n                csr_save_id_o     = 1'b1;\n              end\n            else\n              begin\n\n                if (illegal_insn_i) begin\n\n                  halt_if_o         = 1'b1;\n                  halt_id_o         = 1'b0;\n                  ctrl_fsm_ns       = id_ready_i ? FLUSH_EX : DECODE;\n                  illegal_insn_n    = 1'b1;\n\n                end else begin\n\n                  //decoding block\n  "}
{"text": "                unique case (1'b1)\n\n                    jump_in_dec: begin\n                    // handle unconditional jumps\n                    // we can jump directly since we know the address already\n                    // we don't need to worry about conditional branches here as they\n                    // will be evaluated in the EX stage\n                      pc_mux_o = PC_JUMP;\n                      // if there is a jr stall, wait for it to be gone\n                      if ((~jr_stall_o) && (~jump_done_q)) begin\n                        pc_set_o    = 1'b1;\n                        jump_done   = 1'b1;\n                      end\n                    end\n\n                    ebrk_insn_i: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n\n                      if (debug_mode_q)\n                        // we got back to the park loop in the debug rom\n                        ctrl_fsm_ns = DBG_FLUSH;\n\n                      else if (ebrk_force_debug_mode) begin\n                        // debug module commands us to enter debug mode anyway\n                        ctrl_fsm_ns  = DBG_FLUSH;\n                      end else begin\n                        // otherwise just a normal ebreak exception\n                        ctrl_fsm_ns = id_ready_i ? FLUSH_EX : DECODE;\n                      end\n\n                    end\n\n                    wfi_active: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n                      ctrl_fsm_ns           = id_ready_i ? FLUSH_EX : DECODE;\n                    end\n\n                    ecall_insn_i: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n                      ctrl_fsm_ns           = id_ready_i ? FLUSH_EX : DECODE;\n                    end\n\n                    fencei_insn_i: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n                      ctrl_fsm_ns           = id_ready_i ? FLUSH_EX : DECODE;\n                    end\n\n                    mret_insn_i | uret_insn_i | dret_insn_i: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n                      ctrl_fsm_ns           = id_ready_i ? FLUSH_EX : DECODE;\n                    end\n\n                    csr_status_i: begin\n                      halt_if_o     = 1'b1;\n                      ctrl_fsm_ns   = id_ready_i ? FLUSH_EX : DECODE;\n                    end\n\n                    data_load_event_i: begin\n                      ctrl_fsm_ns   = id_ready_i ? ELW_EXE : DECODE;\n                      halt_if_o     = 1'b1;\n                    end\n\n                    default: begin\n\n                      if(is_hwlp_body) begin\n                        //we are at the inside of an HWloop, thus change state\n\n                        //We stay here in case we returned from the second last instruction, otherwise the next cycle\n                        //in DECODE_HWLOOP we miss to jump, we jump at PC_END.\n                        //This way looses a cycle but it's a corner case of returning from exceptions or interrupts\n\n                        ctrl_fsm_ns  = hwlp_end0_eq_pc_plus4 || hwlp_end1_eq_pc_plus4 ? DECODE : DECODE_HWLOOP;\n\n                        // we can be at the end of HWloop due to a return from interrupt or ecall or ebreak or exceptions\n                        if(hwlp_end0_eq_pc && hwlp_counter0_gt_1) begin\n                          pc_mux_o         = PC_HWLOOP;\n                          if (~jump_done_q) begin\n                            pc_set_o          = 1'b1;\n                            // Keep the instruction and the related address in the Aligner if\n                            // ID is stalled during a jump\n                            jump_done         = 1'b1;\n                            hwlp_dec_cnt_o[0] = 1'b1;\n                          end\n                        end\n                        if (hwlp_end1_eq_pc && hwlp_counter1_gt_1) begin\n                          pc_mux_o         = PC_HWLOOP;\n                          if (~jump_done_q) begin\n                            pc_set_o          = 1'b1;\n                            // Keep the instruction and the related address in the Aligner if\n                            // ID is stalled during a jump\n                            jump_done         = 1'b1;\n                            hwlp_dec_cnt_o[1] = 1'b1;\n                          end\n                        end\n                      end\n\n                      if (hwlp_end0_eq_pc && hwlp_counter0_eq_1) begin\n                        hwlp_dec_cnt_o[0] = 1'b1;\n                      end\n                      if (hwlp_end1_eq_pc && hwlp_counter1_eq_1) begin\n                        hwlp_dec_cnt_o[1] = 1'b1;\n                      end\n\n                    end\n\n                  endcase // unique case (1'b1)\n                end\n\n                if (debug_single_step_i & ~debug_mode_q) begin\n                    // prevent any more instructions from executing\n                    halt_if_o = 1'b1;\n\n                    // we don't handle dret here because its should be illegal\n                    // anyway in this context\n\n                    // illegal, ecall, ebrk and xrettransition to later to a DBG\n                    // state since we need the return address which is\n                    // determined later\n\n                    if (id_ready_i) begin\n                    // make sure the current instruction has been executed\n                        unique case(1'b1)\n\n                        illegal_insn_i | ecall_insn_i:\n                        begin\n                            ctrl_fsm_ns = FLUSH_EX;\n                        end\n\n                        (~ebrk_force_debug_mode & ebrk_insn_i):\n                        begin\n                            ctrl_fsm_ns = FLUSH_EX;\n                        end\n\n                        mret_insn_i | uret_insn_i:\n                        begin\n                            ctrl_fsm_ns = FLUSH_EX;\n                        end\n\n                        branch_in_id:\n                        begin\n                            ctrl_fsm_ns    = DBG_WAIT_BRANCH;\n                        end\n\n                        default:\n                            // regular instruction or ebrk force debug\n                            ctrl_fsm_ns = DBG_FLUSH;\n                        endcase // unique case (1'b1)\n                    end\n                end\n\n              end // else: !if (irq_req_ctrl_i && ~debug_mode_q)\n\n          end  //valid block\n          else begin\n            is_decoding_o         = 1'b0;\n            perf_pipeline_stall_o = data_load_event_i;\n          end\n      end\n\n      DECODE_HWLOOP:\n      begin\n        if (COREV_PULP) begin\n          if (instr_valid_i) // valid block\n          begin // now analyze the current instruction in the ID stage\n\n            is_decoding_o = 1'b1;\n\n            if ( (debug_req_pending || trigger_match_i) & ~debug_mode_q )\n              begin\n                //Serving the debug\n                is_decoding_o     = COREV_PULP ? 1'b0 : 1'b1;\n                halt_if_o         = 1'b1;\n                halt_id_o         = 1'b1;\n                ctrl_fsm_ns       = DBG_FLUSH;\n                debug_req_entry_n = 1'b1;\n             end\n            else if (irq_req_ctrl_i && ~debug_mode_q)\n              begin\n                // Taken IRQ\n                hwlp_mask_o       = COREV_PULP ? 1'b1 : 1'b0;\n\n                is_decoding_o     = 1'b0;\n                halt_if_o         = 1'b1;\n                halt_id_o         = 1'b1;\n\n                pc_set_o          = 1'b1;\n                pc_mux_o          = PC_EXCEPTION;\n                exc_pc_mux_o      = EXC_PC_IRQ;\n                exc_cause_o       = irq_id_ctrl_i;\n                csr_irq_sec_o     = irq_sec_ctrl_i;\n\n                // IRQ interface\n                irq_ack_o         = 1'b1;\n                irq_id_o          = irq_id_ctrl_i;\n\n                if (irq_sec_ctrl_i)\n                  trap_addr_mux_o  = TRAP_MACHINE;\n                else\n                  trap_addr_mux_o  = current_priv_lvl_i == PRIV_LVL_U ? TRAP_USER : TRAP_MACHINE;\n\n                csr_save_cause_o  = 1'b1;\n                csr_cause_o       = {1'b1,irq_id_ctrl_i};\n                csr_save_id_o     = 1'b1;\n\n                ctrl_fsm_ns       = DECODE;\n              end\n            else\n              begin\n\n                if (illegal_insn_i) begin\n\n                  halt_if_o         = 1'b1;\n                  halt_id_o         = 1'b1;\n                  ctrl_fsm_ns       = FLUSH_EX;\n                  illegal_insn_n    = 1'b1;\n\n                end else begin\n\n                  //decoding block\n                  unique case (1'b1)\n\n                    ebrk_insn_i: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n\n                      if (debug_mode_q)\n                        // we got back to the park loop in the debug rom\n                        ctrl_fsm_ns = DBG_FLUSH;\n\n                      else if (ebrk_force_debug_mode)\n                        // debug module commands us to enter debug mode anyway\n                        ctrl_fsm_ns  = DBG_FLUSH;\n\n                      else begin\n                        // otherwise just a normal ebreak exception\n                        ctrl_fsm_ns = id_ready_i ? FLUSH_EX : DECODE_HWLOOP;\n                      end\n\n                    end\n\n                    ecall_insn_i: begin\n                      halt_if_o     = 1'b1;\n                      halt_id_o     = 1'b0;\n                      ctrl_fsm_ns   = id_ready_i ? FLUSH_EX : DECODE_HWLOOP;\n                    end\n\n                    csr_status_i: begin\n                      halt_if_o     = 1'b1;\n                      ctrl_fsm_ns   = id_ready_i ? FLUSH_EX : DECODE_HWLOOP;\n                    end\n\n                    data_load_event_i: begin\n                      ctrl_fsm_ns   = id_ready_i ? ELW_EXE : DECODE_HWLOOP;\n                      halt_if_o     = 1'b1;\n                    end\n\n                    default: begin\n\n                       // we can be at the end of HWloop due to a return from interrupt or ecall or ebreak or exceptions\n                      if(hwlp_end1_eq_pc_plus4) begin\n                          if(hwlp_counter1_gt_1) begin\n                            hwlp_end_4_id_d  = 1'b1;\n                            hwlp_targ_addr_o = hwlp_start_addr_i[1];\n                            ctrl_fsm_ns      = DECODE_HWLOOP;\n                          end else\n                            ctrl_fsm_ns      = is_hwlp_body ? DECODE_HWLOOP : DECODE;\n                      end\n\n                      if(hwlp_end0_eq_pc_plus4) begin\n                          if(hwlp_counter0_gt_1) begin\n                            hwlp_end_4_id_d  = 1'b1;\n                            hwlp_targ_addr_o = hwlp_start_addr_i[0];\n                            ctrl_fsm_ns      = DECODE_HWLOOP;\n                          end else\n                            ctrl_fsm_ns      = is_hwlp_body ? DECODE_HWLOOP : DECODE;\n                      end\n\n                      hwlp_dec_cnt_o[0] = hwlp_end0_eq_pc && !hwlp_counter0_eq_0;\n                      hwlp_dec_cnt_o[1] = hwlp_end1_eq_pc && !hwlp_counter1_eq_0;\n\n                    end\n                  endcase // unique case (1'b1)\n                end // else: !if(illegal_insn_i)\n\n                if (debug_single_step_i & ~debug_mode_q) begin\n                    // prevent any more instructions from executing\n                    halt_if_o = 1'b1;\n\n                    // we don't handle dret here because its should be illegal\n                    // anyway in this context\n\n                    // illegal, ecall, ebrk and xrettransition to later to a DBG\n                    // state since we need the return address which is\n                    // determined later\n\n                    if (id_ready_i) begin\n                    // make sure the current instruction has been executed\n                        unique case(1'b1)\n\n                        illegal_insn_i | ecall_insn_i:\n                        begin\n                            ctrl_fsm_ns = FLUSH_EX;\n                        end\n\n                        (~ebrk_force_debug_mode & ebrk_insn_i):\n                        begin\n                            ctrl_fsm_ns = FLUSH_EX;\n                        end\n\n                        mret_insn_i | uret_insn_i:\n                        begin\n                            ctrl_fsm_ns = FLUSH_EX;\n                        end\n\n                        branch_in_id:\n                        begin\n                            ctrl_fsm_ns = DBG_WAIT_BRANCH;\n                        end\n\n                        default:\n                            // regular instruction or ebrk force debug\n                            ctrl_fsm_ns = DBG_FLUSH;\n                        endcase // unique case (1'b1)\n                    end\n                end // if (debug_single_step_i & ~debug_mode_q)\n\n              end // else: !if (irq_req_ctrl_i && ~debug_mode_q)\n\n          end // block: blk_decode_level1 : valid block\n          else begin\n            is_decoding_o         = 1'b0;\n            perf_pipeline_stall_o = data_load_event_i;\n          end\n        end\n      end\n\n      // flush the pipeline, insert NOP into EX stage\n      FLUSH_EX:\n      begin\n        is_decoding_o = 1'b0;\n\n        halt_if_o = 1'b1;\n        halt_id_o = 1'b1;\n\n        if (data_err_i)\n        begin //data error\n            // the current LW or SW have been blocked by the PMP\n            csr_save_ex_o     = 1'b1;\n            csr_save_cause_o  = 1'b1;\n            data_err_ack_o    = 1'b1;\n            //no jump in this stage as we have to wait one cycle to go to Machine Mode\n            csr_cause_o       = {1'b0, data_we_ex_i ? EXC_CAUSE_STORE_FAULT : EXC_CAUSE_LOAD_FAULT};\n            ctrl_fsm_ns       = FLUSH_WB;\n            //putting illegal to 0 as if it was 1, the core is going to jump to the exception of the EX stage,\n            //so the illegal was never executed\n            illegal_insn_n    = 1'b0;\n        end  //data erro\n        else if (ex_valid_i) begin\n          //check done to prevent data harzard in the CSR registers\n          ctrl_fsm_ns = FLUSH_WB;\n\n          if(illegal_insn_q) begin\n            csr_save_id_o     = 1'b1;\n            csr_save_cause_o  = !debug_mode_q;\n            csr_cause_o       = {1'b0, EXC_CAUSE_ILLEGAL_INSN};\n          end else begin\n            unique case (1'b1)\n              ebrk_insn_i: begin\n                csr_save_id_o     = 1'b1;\n                csr_save_cause_o  = 1'b1;\n                csr_cause_o       = {1'b0, EXC_CAUSE_BREAKPOINT};\n              end\n              ecall_insn_i: begin\n                csr_save_id_o     = 1'b1;\n                csr_save_cause_o  = !debug_mode_q;\n                csr_cause_o       = {1'b0, current_priv_lvl_i == PRIV_LVL_U ? EXC_CAUSE_ECALL_UMODE : EXC_CAUSE_ECALL_MMODE};\n              end\n              default:;\n            endcase // unique case (1'b1)\n          end\n\n        end\n      end\n\n      IRQ_FLUSH_ELW:\n      begin\n        if (COREV_CLUSTER == 1'b1) begin\n          is_decoding_o = 1'b0;\n\n          halt_if_o     = 1'b1;\n          halt_id_o     = 1'b1;\n\n          ctrl_fsm_ns   = DECODE;\n\n          perf_pipeline_stall_o = data_load_event_i;\n\n          if (irq_req_ctrl_i && ~(debug_req_pending || debug_mode_q)) begin\n            // Taken IRQ\n            is_decoding_o     = 1'b0;\n            halt_if_o         = 1'b1;\n            halt_id_o         = 1'b1;\n\n            pc_set_o          = 1'b1;\n            pc_mux_o          = PC_EXCEPTION;\n            exc_pc_mux_o      = EXC_PC_IRQ;\n            exc_cause_o       = irq_id_ctrl_i;\n            csr_irq_sec_o     = irq_sec_ctrl_i;\n\n            // IRQ interface\n            irq_ack_o         = 1'b1;\n            irq_id_o          = irq_id_ctrl_i;\n\n            if (irq_sec_ctrl_i)\n              trap_addr_mux_o  = TRAP_MACHINE;\n            else\n              trap_addr_mux_o  = current_priv_lvl_i == PRIV_LVL_U ? TRAP_USER : TRAP_MACHINE;\n\n            csr_save_cause_o  = 1'b1;\n            csr_cause_o       = {1'b1,irq_id_ctrl_i};\n            csr_save_id_o     = 1'b1;\n          end\n        end\n      end\n\n      ELW_EXE:\n      begin\n        if (COREV_CLUSTER == 1'b1) begin\n          is_decoding_o = 1'b0;\n\n          halt_if_o   = 1'b1;\n          halt_id_o   = 1'b1;\n\n          //if we are here, a cv.elw is executing now in the EX stage\n          //or if an interrupt has been received\n          //the ID stage contains the PC_ID of the cv.elw, therefore halt_id is set to invalid the instruction\n          //If an interrupt occurs, we replay the ELW\n          //No needs to check irq_int_req_i since in the EX stage there is only the cv.elw, no CSR pendings\n          if(id_ready_i)\n            ctrl_fsm_ns = ((debug_req_pending || trigger_match_i) & ~debug_mode_q) ? DBG_FLUSH : IRQ_FLUSH_ELW;\n            // if from the ELW EXE we go to IRQ_FLUSH_ELW, it is assumed that if there was an IRQ req together with the grant and IE was valid, then\n            // there must be no hazard due to xIE\n          else\n            ctrl_fsm_ns = ELW_EXE;\n\n          perf_pipeline_stall_o = data_load_event_i;\n        end\n      end\n\n      // flush the pipeline, insert NOP into EX and WB stage\n      FLUSH_WB:\n      begin\n        is_decoding_o = 1'b0;\n\n        halt_if_o = 1'b1;\n        halt_id_o = 1'b1;\n\n        ctrl_fsm_ns = DECODE;\n\n        if(data_err_q) begin\n            //PMP data_error\n            pc_mux_o              = PC_EXCEPTION;\n            pc_set_o              = 1'b1;\n            trap_addr_mux_o       = TRAP_MACHINE;\n            //little hack during testing\n            exc_pc_mux_o          = EXC_PC_EXCEPTION;\n            exc_cause_o           = data_we_ex_i ? EXC_CAUSE_LOAD_FAULT : EXC_CAUSE_STORE_FAULT;\n\n        end\n        else if (is_fetch_failed_i) begin\n            //instruction fetch error\n            pc_mux_o              = PC_EXCEPTION;\n            pc_set_o              = 1'b1;\n            trap_addr_mux_o       = TRAP_MACHINE;\n            exc_pc_mux_o          = debug_mode_q ? EXC_PC_DBE : EXC_PC_EXCEPTION;\n            exc_cause_o           = EXC_CAUSE_INSTR_FAULT;\n\n        end\n        else begin\n          if(illegal_insn_q) begin\n              //exceptions\n              pc_mux_o              = PC_EXCEPTION;\n              pc_set_o              = 1'b1;\n              trap_addr_mux_o       = TRAP_MACHINE;\n              exc_pc_mux_o          = debug_mode_q ? EXC_PC_DBE : EXC_PC_EXCEPTION;\n              illegal_insn_n        = 1'b0;\n              if (debug_single_step_i && ~debug_mode_q)\n                  ctrl_fsm_ns = DBG_TAKEN_IF;\n          end else begin\n            unique case(1'b1)\n              ebrk_insn_i: begin\n                  //ebreak\n                  pc_mux_o              = PC_EXCEPTION;\n                  pc_set_o              = 1'b1;\n                  trap_addr_mux_o       = TRAP_MACHINE;\n                  exc_pc_mux_o          = EXC_PC_EXCEPTION;\n\n                  if (debug_single_step_i && ~debug_mode_q)\n                      ctrl_fsm_ns = DBG_TAKEN_IF;\n              end\n              ecall_insn_i: begin\n                  //ecall\n                  pc_mux_o              = PC_EXCEPTION;\n                  pc_set_o              = 1'b1;\n                  trap_addr_mux_o       = TRAP_MACHINE;\n                  exc_pc_mux_o          = debug_mode_q ? EXC_PC_DBE : EXC_PC_EXCEPTION;\n\n                  if (debug_single_step_i && ~debug_mode_q)\n                      ctrl_fsm_ns = DBG_TAKEN_IF;\n              end\n\n              mret_insn_i: begin\n                 csr_restore_mret_id_o =  !debug_mode_q;\n                 ctrl_fsm_ns           = XRET_JUMP;\n              end\n              uret_insn_i: begin\n                 csr_restore_uret_id_o =  !debug_mode_q;\n                 ctrl_fsm_ns           = XRET_JUMP;\n              end\n              dret_insn_i: begin\n                  csr_restore_"}
{"text": "dret_id_o = 1'b1;\n                  ctrl_fsm_ns           = XRET_JUMP;\n              end\n\n              csr_status_i: begin\n\n                if(hwlp_end0_eq_pc && hwlp_counter0_gt_1) begin\n                    pc_mux_o         = PC_HWLOOP;\n                    pc_set_o          = 1'b1;\n                    hwlp_dec_cnt_o[0] = 1'b1;\n              end\n                if(hwlp_end1_eq_pc && hwlp_counter1_gt_1) begin\n                    pc_mux_o         = PC_HWLOOP;\n                    pc_set_o          = 1'b1;\n                    hwlp_dec_cnt_o[1] = 1'b1;\n                end\n              end\n\n              wfi_i: begin\n                  if ( debug_req_pending) begin\n                      ctrl_fsm_ns = DBG_TAKEN_IF;\n                      debug_force_wakeup_n = 1'b1;\n                  end else begin\n                    ctrl_fsm_ns = WAIT_SLEEP;\n                  end\n              end\n              fencei_insn_i: begin\n                  // we just jump to instruction after the fence.i since that\n                  // forces the instruction cache to refetch\n                  pc_mux_o              = PC_FENCEI;\n                  pc_set_o              = 1'b1;\n              end\n              default:;\n            endcase\n          end\n        end\n\n      end\n\n      XRET_JUMP:\n      begin\n        is_decoding_o = 1'b0;\n        ctrl_fsm_ns   = DECODE;\n        unique case(1'b1)\n          mret_dec_i: begin\n              //mret\n              pc_mux_o              = debug_mode_q ? PC_EXCEPTION : PC_MRET;\n              pc_set_o              = 1'b1;\n              exc_pc_mux_o          = EXC_PC_DBE; // only used if in debug_mode\n          end\n          uret_dec_i: begin\n              //uret\n              pc_mux_o              = debug_mode_q ? PC_EXCEPTION : PC_URET;\n              pc_set_o              = 1'b1;\n              exc_pc_mux_o          = EXC_PC_DBE; // only used if in debug_mode\n          end\n          dret_dec_i: begin\n              //dret\n              // this case is only reachable while in debug_mode\n              pc_mux_o              = PC_DRET;\n              pc_set_o              = 1'b1;\n              debug_mode_n          = 1'b0;\n          end\n          default:;\n        endcase\n\n        if (debug_single_step_i && ~debug_mode_q) begin\n          ctrl_fsm_ns = DBG_TAKEN_IF;\n        end\n      end\n\n      // a branch was in ID when trying to go to debug rom. Wait until we can\n      // determine branch target address (for saving into dpc) before proceeding\n      DBG_WAIT_BRANCH:\n      begin\n        is_decoding_o = 1'b0;\n        halt_if_o = 1'b1;\n\n        if (branch_taken_ex_i) begin\n          // there is a branch in the EX stage that is taken\n          pc_mux_o = PC_BRANCH;\n          pc_set_o = 1'b1;\n        end\n\n        ctrl_fsm_ns = DBG_FLUSH;\n      end\n\n      // We enter this state when we encounter\n      // 1. ebreak during debug mode\n      // 2. trigger match\n      // 3. ebreak with forced entry into debug mode (ebreakm or ebreaku set).\n      // 4. halt request during decode\n      // Regular ebreak's go through FLUSH_EX and FLUSH_WB.\n      // For 1. we don't update dcsr and dpc while for 2., 3., & 4. we do\n      // dpc is set to the address of ebreak and trigger match\n      // not to the next instruction's (which is why we save the pc in id).\n      DBG_TAKEN_ID:\n      begin\n        is_decoding_o     = 1'b0;\n        pc_set_o          = 1'b1;\n        pc_mux_o          = PC_EXCEPTION;\n        exc_pc_mux_o      = EXC_PC_DBD;\n        // If not in debug mode then save cause and dpc csrs\n        // else it was an ebreak in debug mode, so don't update csrs\n        if (~debug_mode_q) begin\n            csr_save_cause_o = 1'b1;\n            csr_save_id_o    = 1'b1;\n            debug_csr_save_o = 1'b1;\n            if (trigger_match_i)\n                debug_cause_o = DBG_CAUSE_TRIGGER; // pri 4 (highest)\n            else if (ebrk_force_debug_mode & ebrk_insn_i)\n                debug_cause_o = DBG_CAUSE_EBREAK; // pri 3\n            else if (debug_req_entry_q)\n                debug_cause_o = DBG_CAUSE_HALTREQ;// pri 2 and 1\n\n        end\n        debug_req_entry_n  = 1'b0;\n        ctrl_fsm_ns        = DECODE;\n        debug_mode_n       = 1'b1;\n      end\n\n      // We enter this state for single stepping\n      // DPC is set the next instruction to be executed/fetched\n      DBG_TAKEN_IF:\n      begin\n        is_decoding_o     = 1'b0;\n        pc_set_o          = 1'b1;\n        pc_mux_o          = PC_EXCEPTION;\n        exc_pc_mux_o      = EXC_PC_DBD;\n        csr_save_cause_o  = 1'b1;\n        debug_csr_save_o  = 1'b1;\n        if (debug_force_wakeup_q) \n            debug_cause_o = DBG_CAUSE_HALTREQ;\n        else if (debug_single_step_i)\n            debug_cause_o = DBG_CAUSE_STEP; // pri 0\n        csr_save_if_o   = 1'b1;\n        ctrl_fsm_ns     = DECODE;\n        debug_mode_n    = 1'b1;\n        debug_force_wakeup_n = 1'b0;\n      end\n\n\n      DBG_FLUSH:\n      begin\n        is_decoding_o = 1'b0;\n\n        halt_if_o   = 1'b1;\n        halt_id_o   = 1'b1;\n\n        perf_pipeline_stall_o = data_load_event_i;\n\n        if (data_err_i)\n        begin //data error\n            // the current LW or SW have been blocked by the PMP\n            csr_save_ex_o     = 1'b1;\n            csr_save_cause_o  = 1'b1;\n            data_err_ack_o    = 1'b1;\n            //no jump in this stage as we have to wait one cycle to go to Machine Mode\n            csr_cause_o       = {1'b0, data_we_ex_i ? EXC_CAUSE_STORE_FAULT : EXC_CAUSE_LOAD_FAULT};\n            ctrl_fsm_ns       = FLUSH_WB;\n        end  //data error\n        else begin\n          if(debug_mode_q                          |\n             trigger_match_i                       |\n             (ebrk_force_debug_mode & ebrk_insn_i) |\n             data_load_event_i                     |\n             debug_req_entry_q                     )\n            begin\n              ctrl_fsm_ns = DBG_TAKEN_ID;\n            end else\n            begin\n              // else must be debug_single_step_i\n              ctrl_fsm_ns = DBG_TAKEN_IF;\n            end\n        end\n      end\n      // Debug end\n\n      default: begin\n        is_decoding_o = 1'b0;\n        instr_req_o = 1'b0;\n        ctrl_fsm_ns = RESET;\n      end\n    endcase\n  end\n\n\n\ngenerate\n  if(COREV_PULP) begin : gen_hwlp\n    //////////////////////////////////////////////////////////////////////////////\n    // Convert hwlp_jump_o to a pulse\n    //////////////////////////////////////////////////////////////////////////////\n\n    // hwlp_jump_o should last one cycle only, as the prefetcher\n    // reacts immediately. If it last more cycles, the prefetcher\n    // goes on requesting HWLP_BEGIN more than one time (wrong!).\n    // This signal is not controlled by id_ready because otherwise,\n    // in case of stall, the jump would happen at the end of the stall.\n\n    // Make hwlp_jump_o last only one cycle\n    assign hwlp_jump_o = (hwlp_end_4_id_d && !hwlp_end_4_id_q) ? 1'b1 : 1'b0;\n\n    always_ff @(posedge clk or negedge rst_n) begin\n      if(!rst_n) begin\n        hwlp_end_4_id_q <= 1'b0;\n      end else begin\n        hwlp_end_4_id_q <= hwlp_end_4_id_d;\n      end\n    end\n\n    assign hwlp_end0_eq_pc         = hwlp_end_addr_i[0] == pc_id_i + 4;   // Equivalent to hwlp_end_addr_i[0] - 4 == pc_id_i\n    assign hwlp_end1_eq_pc         = hwlp_end_addr_i[1] == pc_id_i + 4;   // Equivalent to hwlp_end_addr_i[1] - 4 == pc_id_i\n    assign hwlp_counter0_gt_1      = hwlp_counter_i[0] > 1;\n    assign hwlp_counter1_gt_1      = hwlp_counter_i[1] > 1;\n    assign hwlp_counter0_eq_1      = hwlp_counter_i[0] == 1;\n    assign hwlp_counter1_eq_1      = hwlp_counter_i[1] == 1;\n    assign hwlp_counter0_eq_0      = hwlp_counter_i[0] == 0;\n    assign hwlp_counter1_eq_0      = hwlp_counter_i[1] == 0;\n    assign hwlp_end0_eq_pc_plus4   = hwlp_end_addr_i[0] == pc_id_i + 8;   // Equivalent to hwlp_end_addr_i[0] - 4 == pc_id_i + 4\n    assign hwlp_end1_eq_pc_plus4   = hwlp_end_addr_i[1] == pc_id_i + 8;   // Equivalent to hwlp_end_addr_i[1] - 4 == pc_id_i + 4\n    assign hwlp_start0_leq_pc      = hwlp_start_addr_i[0] <= pc_id_i;\n    assign hwlp_start1_leq_pc      = hwlp_start_addr_i[1] <= pc_id_i;\n    assign hwlp_end0_geq_pc        = hwlp_end_addr_i[0] >= pc_id_i + 4;   // Equivalent to hwlp_end_addr_i[0] - 4 >= pc_id_i\n    assign hwlp_end1_geq_pc        = hwlp_end_addr_i[1] >= pc_id_i + 4;   // Equivalent to hwlp_end_addr_i[1] - 4 >= pc_id_i;\n    assign is_hwlp_body            = ((hwlp_start0_leq_pc && hwlp_end0_geq_pc) && hwlp_counter0_gt_1) ||  ((hwlp_start1_leq_pc && hwlp_end1_geq_pc) && hwlp_counter1_gt_1);\n\n  end else begin : gen_no_hwlp\n\n    assign hwlp_jump_o             = 1'b0;\n    assign hwlp_end_4_id_q         = 1'b0;\n    assign hwlp_end0_eq_pc         = 1'b0;\n    assign hwlp_end1_eq_pc         = 1'b0;\n    assign hwlp_counter0_gt_1      = 1'b0;\n    assign hwlp_counter1_gt_1      = 1'b0;\n    assign hwlp_counter0_eq_1      = 1'b0;\n    assign hwlp_counter1_eq_1      = 1'b0;\n    assign hwlp_counter0_eq_0      = 1'b0;\n    assign hwlp_counter1_eq_0      = 1'b0;\n    assign hwlp_end0_eq_pc_plus4   = 1'b0;\n    assign hwlp_end1_eq_pc_plus4   = 1'b0;\n    assign hwlp_start0_leq_pc      = 1'b0;\n    assign hwlp_start1_leq_pc      = 1'b0;\n    assign hwlp_end0_geq_pc        = 1'b0;\n    assign hwlp_end1_geq_pc        = 1'b0;\n    assign is_hwlp_body            = 1'b0;\n\n  end\n\nendgenerate\n\n  /////////////////////////////////////////////////////////////\n  //  ____  _        _ _    ____            _             _  //\n  // / ___|| |_ __ _| | |  / ___|___  _ __ | |_ _ __ ___ | | //\n  // \\___ \\| __/ _` | | | | |   / _ \\| '_ \\| __| '__/ _ \\| | //\n  //  ___) | || (_| | | | | |__| (_) | | | | |_| | | (_) | | //\n  // |____/ \\__\\__,_|_|_|  \\____\\___/|_| |_|\\__|_|  \\___/|_| //\n  //                                                         //\n  /////////////////////////////////////////////////////////////\n  always_comb\n  begin\n    load_stall_o   = 1'b0;\n    deassert_we_o  = 1'b0;\n\n    // deassert WE when the core is not decoding instructions\n    if (~is_decoding_o)\n      deassert_we_o = 1'b1;\n\n    // deassert WE in case of illegal instruction\n    if (illegal_insn_i)\n      deassert_we_o = 1'b1;\n\n    // Stall because of load operation\n    if (\n          ( (data_req_ex_i == 1'b1) && (regfile_we_ex_i == 1'b1) ||\n           (wb_ready_i == 1'b0) && (regfile_we_wb_i == 1'b1)\n          ) &&\n          ( (reg_d_ex_is_reg_a_i == 1'b1) || (reg_d_ex_is_reg_b_i == 1'b1) || (reg_d_ex_is_reg_c_i == 1'b1) ||\n            (is_decoding_o && (regfile_we_id_i && !data_misaligned_i) && (regfile_waddr_ex_i == regfile_alu_waddr_id_i)) )\n       )\n    begin\n      deassert_we_o   = 1'b1;\n      load_stall_o    = 1'b1;\n    end\n\n    // Stall because of jr path\n    // - always stall if a result is to be forwarded to the PC\n    // we don't care about in which state the ctrl_fsm is as we deassert_we\n    // anyway when we are not in DECODE\n    if ((ctrl_transfer_insn_in_dec_i == BRANCH_JALR) &&\n        (((regfile_we_wb_i == 1'b1) && (reg_d_wb_is_reg_a_i == 1'b1)) ||\n         ((regfile_we_ex_i == 1'b1) && (reg_d_ex_is_reg_a_i == 1'b1)) ||\n         ((regfile_alu_we_fw_i == 1'b1) && (reg_d_alu_is_reg_a_i == 1'b1)) ||\n         (FPU && (apu_read_dep_for_jalr_i == 1'b1))\n        )\n       )\n    begin\n      jr_stall_o      = 1'b1;\n      deassert_we_o   = 1'b1;\n    end\n    else\n    begin\n      jr_stall_o     = 1'b0;\n    end\n  end\n\n\n  // stall because of misaligned data access\n  assign misaligned_stall_o = data_misaligned_i;\n\n  // APU dependency stalls (data hazards)\n  assign apu_stall_o = apu_read_dep_i | (apu_write_dep_i & ~apu_en_i);\n\n  // Forwarding control unit\n  always_comb\n  begin\n    // default assignements\n    operand_a_fw_mux_sel_o = SEL_REGFILE;\n    operand_b_fw_mux_sel_o = SEL_REGFILE;\n    operand_c_fw_mux_sel_o = SEL_REGFILE;\n\n    // Forwarding WB -> ID\n    if (regfile_we_wb_i == 1'b1)\n    begin\n      if (reg_d_wb_is_reg_a_i == 1'b1)\n        operand_a_fw_mux_sel_o = SEL_FW_WB;\n      if (reg_d_wb_is_reg_b_i == 1'b1)\n        operand_b_fw_mux_sel_o = SEL_FW_WB;\n      if (reg_d_wb_is_reg_c_i == 1'b1)\n        operand_c_fw_mux_sel_o = SEL_FW_WB;\n    end\n\n    // Forwarding EX -> ID\n    if (regfile_alu_we_fw_i == 1'b1)\n    begin\n     if (reg_d_alu_is_reg_a_i == 1'b1)\n       operand_a_fw_mux_sel_o = SEL_FW_EX;\n     if (reg_d_alu_is_reg_b_i == 1'b1)\n       operand_b_fw_mux_sel_o = SEL_FW_EX;\n     if (reg_d_alu_is_reg_c_i == 1'b1)\n       operand_c_fw_mux_sel_o = SEL_FW_EX;\n    end\n\n    // for misaligned memory accesses\n    if (data_misaligned_i)\n    begin\n      operand_a_fw_mux_sel_o  = SEL_FW_EX;\n      operand_b_fw_mux_sel_o  = SEL_REGFILE;\n    end else if (mult_multicycle_i) begin\n      operand_c_fw_mux_sel_o  = SEL_FW_EX;\n    end\n  end\n\n  // update registers\n  always_ff @(posedge clk , negedge rst_n)\n  begin : UPDATE_REGS\n    if ( rst_n == 1'b0 )\n    begin\n      ctrl_fsm_cs        <= RESET;\n      jump_done_q        <= 1'b0;\n      data_err_q         <= 1'b0;\n\n      debug_mode_q       <= 1'b0;\n      illegal_insn_q     <= 1'b0;\n\n      debug_req_entry_q  <= 1'b0;\n      debug_force_wakeup_q <= 1'b0;\n    end\n    else\n    begin\n      ctrl_fsm_cs        <= ctrl_fsm_ns;\n\n      // clear when id is valid (no instruction incoming)\n      jump_done_q        <= jump_done & (~id_ready_i);\n\n      data_err_q         <= data_err_i;\n\n      debug_mode_q       <= debug_mode_n;\n\n      illegal_insn_q     <= illegal_insn_n;\n\n      debug_req_entry_q  <= debug_req_entry_n;\n      debug_force_wakeup_q <= debug_force_wakeup_n;\n    end\n  end\n\n  // wakeup from sleep conditions\n  assign wake_from_sleep_o = irq_wu_ctrl_i || debug_req_pending || debug_mode_q;\n\n  // debug mode\n  assign debug_mode_o = debug_mode_q;\n  assign debug_req_pending = debug_req_i || debug_req_q;\n\n  // Do not let cv.elw cause core_sleep_o during debug\n  assign debug_p_elw_no_sleep_o = debug_mode_q || debug_req_q || debug_single_step_i || trigger_match_i;\n\n  // Do not let WFI cause core_sleep_o (but treat as NOP):\n  //\n  // - During debug\n  // - For PULP Cluster (only cv.elw can trigger sleep)\n\n  assign debug_wfi_no_sleep_o = debug_mode_q || debug_req_pending || debug_single_step_i || trigger_match_i || COREV_CLUSTER;\n\n  // Gate off wfi \n  assign wfi_active = wfi_i & ~debug_wfi_no_sleep_o;\n\n  // sticky version of debug_req (must be on clk_ungated_i such that incoming pulse before core is enabled is not missed)\n  always_ff @(posedge clk_ungated_i, negedge rst_n)\n    if ( !rst_n )\n      debug_req_q <= 1'b0;\n    else\n      if( debug_req_i )\n        debug_req_q <= 1'b1;\n      else if( debug_mode_q )\n        debug_req_q <= 1'b0;\n\n  // Debug state FSM\n  always_ff @(posedge clk , negedge rst_n)\n  begin\n    if ( rst_n == 1'b0 )\n    begin\n      debug_fsm_cs <= HAVERESET;\n    end\n    else\n    begin\n      debug_fsm_cs <= debug_fsm_ns;\n    end\n  end\n\n  always_comb\n  begin\n    debug_fsm_ns = debug_fsm_cs;\n\n    case (debug_fsm_cs)\n      HAVERESET:\n      begin\n        if (debug_mode_n || (ctrl_fsm_ns == FIRST_FETCH)) begin\n          if (debug_mode_n) begin\n            debug_fsm_ns = HALTED;\n          end else begin\n            debug_fsm_ns = RUNNING;\n          end\n        end\n      end\n\n      RUNNING:\n      begin\n        if (debug_mode_n) begin\n          debug_fsm_ns = HALTED;\n        end\n      end\n\n      HALTED:\n      begin\n        if (!debug_mode_n) begin\n          debug_fsm_ns = RUNNING;\n        end\n      end\n\n      default: begin\n        debug_fsm_ns = HAVERESET;\n      end\n    endcase\n  end\n\n  assign debug_havereset_o = debug_fsm_cs[HAVERESET_INDEX];\n  assign debug_running_o = debug_fsm_cs[RUNNING_INDEX];\n  assign debug_halted_o = debug_fsm_cs[HALTED_INDEX];\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n\n`ifdef CV32E40P_ASSERT_ON\n\n  // make sure that taken branches do not happen back-to-back, as this is not\n  // possible without branch prediction in the IF stage\n  assert property (\n    @(posedge clk) (branch_taken_ex_i) |=> (~branch_taken_ex_i) ) else $warning(\"Two branches back-to-back are taken\");\n\n  // ELW_EXE and IRQ_FLUSH_ELW states are only used for COREV_CLUSTER = 1\n  property p_pulp_cluster_only_states;\n     @(posedge clk) (1'b1) |-> ( !((COREV_CLUSTER == 1'b0) && ((ctrl_fsm_cs == ELW_EXE) || (ctrl_fsm_cs == IRQ_FLUSH_ELW))) );\n  endproperty\n\n  a_pulp_cluster_only_states : assert property(p_pulp_cluster_only_states);\n\n  // WAIT_SLEEP and SLEEP states are never used for COREV_CLUSTER = 1\n  property p_pulp_cluster_excluded_states;\n     @(posedge clk) (1'b1) |-> ( !((COREV_CLUSTER == 1'b1) && ((ctrl_fsm_cs == SLEEP) || (ctrl_fsm_cs == WAIT_SLEEP))) );\n  endproperty\n\n  a_pulp_cluster_excluded_states : assert property(p_pulp_cluster_excluded_states);\n\n  generate\n  if (COREV_PULP) begin : gen_pulp_xpulp_assertions\n\n    // HWLoop 0 and 1 having target address constraints\n    property p_hwlp_same_target_address;\n       @(posedge clk) (hwlp_counter_i[1] > 1 && hwlp_counter_i[0] > 1) |-> ( hwlp_end_addr_i[1] - 4 >= hwlp_end_addr_i[0] - 4 + 8 );\n    endproperty\n\n    a_hwlp_same_target_address : assert property(p_hwlp_same_target_address) else $warning(\"%t, HWLoops target address do not respect constraints\", $time);\n\n  end else begin : gen_no_pulp_xpulp_assertions\n\n    property p_no_hwlp;\n       @(posedge clk) (1'b1) |-> ((pc_mux_o != PC_HWLOOP) && (ctrl_fsm_cs != DECODE_HWLOOP) &&\n                                  (hwlp_mask_o == 1'b0) && (is_hwlp_body == 'b0) &&\n                                  (hwlp_start_addr_i == 'b0) && (hwlp_end_addr_i == 'b0) && (hwlp_counter_i[1] == 32'b0) && (hwlp_counter_i[0] == 32'b0) &&\n                                  (hwlp_dec_cnt_o == 2'b0) && (hwlp_jump_o == 1'b0) && (hwlp_targ_addr_o == 32'b0) &&\n                                  (hwlp_end0_eq_pc == 1'b0) && (hwlp_end1_eq_pc == 1'b0) && (hwlp_counter0_gt_1 == 1'b0) && (hwlp_counter1_gt_1 == 1'b0) &&\n                                  (hwlp_counter0_eq_1 == 1'b0) && (hwlp_counter1_eq_1 == 1'b0) &&\n                                  (hwlp_end0_eq_pc_plus4 == 1'b0) && (hwlp_end1_eq_pc_plus4 == 1'b0) && (hwlp_start0_leq_pc == 0) && (hwlp_start1_leq_pc == 0) &&\n                                  (hwlp_end0_geq_pc == 1'b0) && (hwlp_end1_geq_pc == 1'b0) && (hwlp_end_4_id_d == 1'b0) && (hwlp_end_4_id_q == 1'b0));\n    endproperty\n\n    a_no_hwlp : assert property(p_no_hwlp);\n\n  end\n  endgenerate\n\n  // Ensure DBG_TAKEN_IF can only be enterred if in single step mode or woken\n  // up from sleep by debug_req_i\n         \n  a_single_step_dbg_taken_if : assert property (@(posedge clk)  disable iff (!rst_n)  (ctrl_fsm_ns==DBG_TAKEN_IF) |-> ((~debug_mode_q && debug_single_step_i) || debug_force_wakeup_n));\n\n  // Ensure DBG_FLUSH state is only one cycle. This implies that cause is either trigger, debug_req_entry, or ebreak\n  a_dbg_flush : assert property (@(posedge clk)  disable iff (!rst_n)  (ctrl_fsm_cs==DBG_FLUSH) |-> (ctrl_fsm_ns!=DBG_FLUSH) );\n\n  // Ensure that debug state outputs are one-hot\n  a_debug_state_onehot : assert property (@(posedge clk) $onehot({debug_havereset_o, debug_running_o, debug_halted_o}));\n\n  // Ensure that debug_halted_o equals debug_mode_q\n  a_debug_halted_equals_debug_mode : assert property (@(posedge clk) disable iff (!rst_n) (1'b1) |-> (debug_mode_q == debug_halted_o));\n\n  // Ensure ID always ready in FIRST_FETCH state\n  a_first_fetch_id_ready : assert property (@(posedge clk) disable iff (!rst_n) (ctrl_fsm_cs == FIRST_FETCH) |-> (id_ready_i == 1'b1));\n\n  // Ensure that the only way to get to DBG_TAKEN_IF from DBG_FLUSH is if debug_single_step_i is asserted\n  a_dbg_flush_to_taken_if : assert property (@(posedge clk) disable iff (!rst_n) (ctrl_fsm_cs == DBG_FLUSH) && (ctrl_fsm_ns == DBG_TAKEN_IF) |-> debug_single_step_i);\n\n`endif\n\nendmodule // cv32e40p_controller\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Matthias Baer - baermatt@student.ethz.ch                   //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Andreas Traber - atraber@student.ethz.ch                   //\n//                 Sven Stucki - svstucki@student.ethz.ch                     //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Top level module                                           //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Top level module of the RISC-V core.                       //\n//                 added APU, FPU parameter to include the APU_dispatcher     //\n//                 and the FPU                                                //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_core\n  import cv32e40p_apu_core_pkg::*;\n#(\n    parameter COREV_PULP =  0,  // PULP ISA Extension (incl. custom CSRs and hardware loop, excl. cv.elw)\n    parameter COREV_CLUSTER = 0,  // PULP Cluster interface (incl. cv.elw)\n    parameter FPU = 0,  // Floating Point Unit (interfaced via APU interface)\n    parameter FPU_ADDMUL_LAT = 0,  // Floating-Point ADDition/MULtiplication lane pipeline registers number\n    parameter FPU_OTHERS_LAT = 0,  // Floating-Point COMParison/CONVersion lanes pipeline registers number\n    parameter ZFINX = 0,  // Float-in-General Purpose registers\n    parameter NUM_MHPMCOUNTERS = 1\n) (\n    // Clock and Reset\n    input logic clk_i,\n    input logic rst_ni,\n\n    input logic pulp_clock_en_i,  // PULP clock enable (only used if COREV_CLUSTER = 1)\n    input logic scan_cg_en_i,  // Enable all clock gates for testing\n\n    // Core ID, Cluster ID, debug mode halt address and boot address are considered more or less static\n    input logic [31:0] boot_addr_i,\n    input logic [31:0] mtvec_addr_i,\n    input logic [31:0] dm_halt_addr_i,\n    input logic [31:0] hart_id_i,\n    input logic [31:0] dm_exception_addr_i,\n\n    // Instruction memory interface\n    output logic        instr_req_o,\n    input  logic        instr_gnt_i,\n    input  logic        instr_rvalid_i,\n    output logic [31:0] instr_addr_o,\n    input  logic [31:0] instr_rdata_i,\n\n    // Data memory interface\n    output logic        data_req_o,\n    input  logic        data_gnt_i,\n    input  logic        data_rvalid_i,\n    output logic        data_we_o,\n    output logic [ 3:0] data_be_o,\n    output logic [31:0] data_addr_o,\n    output logic [31:0] data_wdata_o,\n    input  logic [31:0] data_rdata_i,\n\n    // apu-interconnect\n    // handshake signals\n    output logic                              apu_req_o,\n    input  logic                              apu_gnt_i,\n    // request channel\n    output logic [   APU_NARGS_CPU-1:0][31:0] apu_operands_o,\n    output logic [     APU_WOP_CPU-1:0]       apu_op_o,\n    output logic [APU_NDSFLAGS_CPU-1:0]       apu_flags_o,\n    // response channel\n    input  logic                              apu_rvalid_i,\n    input  logic [                31:0]       apu_result_i,\n    input  logic [APU_NUSFLAGS_CPU-1:0]       apu_flags_i,\n\n    // Interrupt inputs\n    input  logic [31:0] irq_i,  // CLINT interrupts + CLINT extension interrupts\n    output logic        irq_ack_o,\n    output logic [ 4:0] irq_id_o,\n\n    // Debug Interface\n    input  logic debug_req_i,\n    output logic debug_havereset_o,\n    output logic debug_running_o,\n    output logic debug_halted_o,\n\n    // CPU Control Signals\n    input  logic fetch_enable_i,\n    output logic core_sleep_o\n);\n\n  import cv32e40p_pkg::*;\n\n  // Unused parameters and signals (left in code for future design extensions)\n  localparam PULP_SECURE = 0;\n  localparam N_PMP_ENTRIES = 16;\n  localparam USE_PMP = 0;  // if PULP_SECURE is 1, you can still not use the PMP\n  localparam A_EXTENSION = 0;\n  localparam DEBUG_TRIGGER_EN = 1;\n\n  // PULP bus interface behavior\n  // If enabled will allow non-stable address phase signals during waited instructions requests and\n  // will re-introduce combinatorial paths from instr_rvalid_i to instr_req_o and from from data_rvalid_i\n  // to data_req_o\n  localparam PULP_OBI = 0;\n\n  // Unused signals related to above unused parameters\n  // Left in code (with their original _i, _o postfixes) for future design extensions;\n  // these used to be former inputs/outputs of RI5CY\n\n  logic [5:0] data_atop_o;  // atomic operation, only active if parameter `A_EXTENSION != 0`\n  logic       irq_sec_i;\n  logic       sec_lvl_o;\n\n  localparam N_HWLP = 2;\n  localparam APU = (FPU == 1) ? 1 : 0;\n\n  // IF/ID signals\n  logic        instr_valid_id;\n  logic [31:0] instr_rdata_id;  // Instruction sampled inside IF stage\n  logic        is_compressed_id;\n  logic        illegal_c_insn_id;\n  logic        is_fetch_failed_id;\n\n  logic        clear_instr_valid;\n  logic        pc_set;\n\n  logic [ 3:0] pc_mux_id;  // Mux selector for next PC\n  logic [ 2:0] exc_pc_mux_id;  // Mux selector for exception PC\n  logic [ 4:0] m_exc_vec_pc_mux_id;  // Mux selector for vectored IRQ PC\n  logic [ 4:0] u_exc_vec_pc_mux_id;  // Mux selector for vectored IRQ PC\n  logic [ 4:0] exc_cause;\n\n  logic [ 1:0] trap_addr_mux;\n\n  logic [31:0] pc_if;  // Program counter in IF stage\n  logic [31:0] pc_id;  // Program counter in ID stage\n\n  // ID performance counter signals\n  logic        is_decoding;\n\n  logic        useincr_addr_ex;  // Active when post increment\n  logic        data_misaligned;\n\n  logic        mult_multicycle;\n\n  // Jump and branch target and decision (EX->IF)\n  logic [31:0] jump_target_id, jump_target_ex;\n  logic               branch_in_ex;\n  logic               branch_decision;\n  logic        [ 1:0] ctrl_transfer_insn_in_dec;\n\n  logic               ctrl_busy;\n  logic               if_busy;\n  logic               lsu_busy;\n  logic               apu_busy;\n\n  logic        [31:0] pc_ex;  // PC of last executed branch or cv.elw\n\n  // ALU Control\n  logic               alu_en_ex;\n  alu_opcode_e        alu_operator_ex;\n  logic        [31:0] alu_operand_a_ex;\n  logic        [31:0] alu_operand_b_ex;\n  logic        [31:0] alu_operand_c_ex;\n  logic        [ 4:0] bmask_a_ex;\n  logic        [ 4:0] bmask_b_ex;\n  logic        [ 1:0] imm_vec_ext_ex;\n  logic        [ 1:0] alu_vec_mode_ex;\n  logic alu_is_clpx_ex, alu_is_subrot_ex;\n  logic        [                 1:0]       alu_clpx_shift_ex;\n\n  // Multiplier Control\n  mul_opcode_e                              mult_operator_ex;\n  logic        [                31:0]       mult_operand_a_ex;\n  logic        [                31:0]       mult_operand_b_ex;\n  logic        [                31:0]       mult_operand_c_ex;\n  logic                                     mult_en_ex;\n  logic                                     mult_sel_subword_ex;\n  logic        [                 1:0]       mult_signed_mode_ex;\n  logic        [                 4:0]       mult_imm_ex;\n  logic        [                31:0]       mult_dot_op_a_ex;\n  logic        [                31:0]       mult_dot_op_b_ex;\n  logic        [                31:0]       mult_dot_op_c_ex;\n  logic        [                 1:0]       mult_dot_signed_ex;\n  logic                                     mult_is_clpx_ex;\n  logic        [                 1:0]       mult_clpx_shift_ex;\n  logic                                     mult_clpx_img_ex;\n\n  // FPU\n  logic                                     fs_off;\n  logic        [            C_RM-1:0]       frm_csr;\n  logic        [         C_FFLAG-1:0]       fflags_csr;\n  logic                                     fflags_we;\n  logic                                     fregs_we;\n\n  // APU\n  logic                                     apu_en_ex;\n  logic        [APU_NDSFLAGS_CPU-1:0]       apu_flags_ex;\n  logic        [     APU_WOP_CPU-1:0]       apu_op_ex;\n  logic        [                 1:0]       apu_lat_ex;\n  logic        [   APU_NARGS_CPU-1:0][31:0] apu_operands_ex;\n  logic        [                 5:0]       apu_waddr_ex;\n\n  logic        [                 2:0][ 5:0] apu_read_regs;\n  logic        [                 2:0]       apu_read_regs_valid;\n  logic                                     apu_read_dep;\n  logic                                     apu_read_dep_for_jalr;\n  logic        [                 1:0][ 5:0] apu_write_regs;\n  logic        [                 1:0]       apu_write_regs_valid;\n  logic                                     apu_write_dep;\n\n  logic                                     perf_apu_type;\n  logic                                     perf_apu_cont;\n  logic                                     perf_apu_dep;\n  logic                                     perf_apu_wb;\n\n  // Register Write Control\n  logic        [                 5:0]       regfile_waddr_ex;\n  logic                                     regfile_we_ex;\n  logic        [                 5:0]       regfile_waddr_fw_wb_o;  // From WB to ID\n  logic                                     regfile_we_wb;\n  logic                                     regfile_we_wb_power;\n  logic        [                31:0]       regfile_wdata;\n\n  logic        [                 5:0]       regfile_alu_waddr_ex;\n  logic                                     regfile_alu_we_ex;\n\n  logic        [                 5:0]       regfile_alu_waddr_fw;\n  logic                                     regfile_alu_we_fw;\n  logic                                     regfile_alu_we_fw_power;\n  logic        [                31:0]       regfile_alu_wdata_fw;\n\n  // CSR control\n  logic                                     csr_access_ex;\n  csr_opcode_e                              csr_op_ex;\n  logic [23:0] mtvec, utvec;\n  logic        [ 1:0] mtvec_mode;\n  logic        [ 1:0] utvec_mode;\n\n  csr_opcode_e        csr_op;\n  csr_num_e           csr_addr;\n  csr_num_e           csr_addr_int;\n  logic        [31:0] csr_rdata;\n  logic        [31:0] csr_wdata;\n  PrivLvl_t           current_priv_lvl;\n\n  // Data Memory Control:  From ID stage (id-ex pipe) <--> load store unit\n  logic               data_we_ex;\n  logic        [ 5:0] data_atop_ex;\n  logic        [ 1:0] data_type_ex;\n  logic        [ 1:0] data_sign_ext_ex;\n  logic        [ 1:0] data_reg_offset_ex;\n  logic               data_req_ex;\n  logic               data_load_event_ex;\n  logic               data_misaligned_ex;\n\n  logic               p_elw_start;  // Start of cv.elw load (when data_req_o is sent)\n  logic               p_elw_finish;  // Finish of cv.elw load (when data_rvalid_i is received)\n\n  logic        [31:0] lsu_rdata;\n\n  // stall control\n  logic               halt_if;\n  logic               id_ready;\n  logic               ex_ready;\n\n  logic               id_valid;\n  logic               ex_valid;\n  logic               wb_valid;\n\n  logic               lsu_ready_ex;\n  logic               lsu_ready_wb;\n\n  logic               apu_ready_wb;\n\n  // Signals between instruction core interface and pipe (if and id stages)\n  logic               instr_req_int;  // Id stage asserts a req to instruction core interface\n\n  // Interrupts\n  logic m_irq_enable, u_irq_enable;\n  logic csr_irq_sec;\n  logic [31:0] mepc, uepc, depc;\n  logic [             31:0]       mie_bypass;\n  logic [             31:0]       mip;\n\n  logic                           csr_save_cause;\n  logic                           csr_save_if;\n  logic                           csr_save_id;\n  logic                           csr_save_ex;\n  logic [              5:0]       csr_cause;\n  logic                           csr_restore_mret_id;\n  logic                           csr_restore_uret_id;\n  logic                           csr_restore_dret_id;\n  logic                           csr_mtvec_init;\n\n  // HPM related control signals\n  logic [             31:0]       mcounteren;\n\n  // debug mode and dcsr configuration\n  logic                           debug_mode;\n  logic [              2:0]       debug_cause;\n  logic                           debug_csr_save;\n  logic                           debug_single_step;\n  logic                           debug_ebreakm;\n  logic                           debug_ebreaku;\n  logic                           trigger_match;\n  logic                           debug_p_elw_no_sleep;\n\n  // Hardware loop controller signals\n  logic [       N_HWLP-1:0][31:0] hwlp_start;\n  logic [       N_HWLP-1:0][31:0] hwlp_end;\n  logic [       N_HWLP-1:0][31:0] hwlp_cnt;\n\n  logic [             31:0]       hwlp_target;\n  logic                           hwlp_jump;\n\n  // Performance Counters\n  logic                           mhpmevent_minstret;\n  logic                           mhpmevent_load;\n  logic                           mhpmevent_store;\n  logic                           mhpmevent_jump;\n  logic                           mhpmevent_branch;\n  logic                           mhpmevent_branch_taken;\n  logic                           mhpmevent_compressed;\n  logic                           mhpmevent_jr_stall;\n  logic                           mhpmevent_imiss;\n  logic                           mhpmevent_ld_stall;\n  logic                           mhpmevent_pipe_stall;\n\n  logic                           perf_imiss;\n\n  // Wake signal\n  logic                           wake_from_sleep;\n\n  // PMP signals\n  logic [N_PMP_ENTRIES-1:0][31:0] pmp_addr;\n  logic [N_PMP_ENTRIES-1:0][ 7:0] pmp_cfg;\n\n  logic                           data_req_pmp;\n  logic [             31:0]       data_addr_pmp;\n  logic                           data_gnt_pmp;\n  logic                           data_err_pmp;\n  logic                           data_err_ack;\n  logic                           instr_req_pmp;\n  logic                           instr_gnt_pmp;\n  logic [             31:0]       instr_addr_pmp;\n  logic                           instr_err_pmp;\n\n  // Mux selector for vectored IRQ PC\n  assign m_exc_vec_pc_mux_id = (mtvec_mode == 2'b0) ? 5'h0 : exc_cause;\n  assign u_exc_vec_pc_mux_id = (utvec_mode == 2'b0) ? 5'h0 : exc_cause;\n\n  // PULP_SECURE == 0\n  assign irq_sec_i = 1'b0;\n\n  // APU master signals\n  assign apu_flags_o = apu_flags_ex;\n\n  //////////////////////////////////////////////////////////////////////////////////////////////\n  //   ____ _            _      __  __                                                   _    //\n  //  / ___| | ___   ___| | __ |  \\/  | __ _ _ __   __ _  __ _  ___ _ __ ___   ___ _ __ | |_  //\n  // | |   | |/ _ \\ / __| |/ / | |\\/| |/ _` | '_ \\ / _` |/ _` |/ _ \\ '_ ` _ \\ / _ \\ '_ \\| __| //\n  // | |___| | (_) | (__|   <  | |  | | (_| | | | | (_| | (_| |  __/ | | | | |  __/ | | | |_  //\n  //  \\____|_|\\___/ \\___|_|\\_\\ |_|  |_|\\__,_|_| |_|\\__,_|\\__, |\\___|_| |_| |_|\\___|_| |_|\\__| //\n  //                                                     |___/                                //\n  //////////////////////////////////////////////////////////////////////////////////////////////\n\n  logic clk;\n  logic fetch_enable;\n\n  cv32e40p_sleep_unit #(\n      .COREV_CLUSTER(COREV_CLUSTER)\n  ) sleep_unit_i (\n      // Clock, reset interface\n      .clk_ungated_i(clk_i),  // Ungated clock\n      .rst_n        (rst_ni),\n      .clk_gated_o  (clk),  // Gated clock\n      .scan_cg_en_i (scan_cg_en_i),\n\n      // Core sleep\n      .core_sleep_o(core_sleep_o),\n\n      // Fetch enable\n      .fetch_enable_i(fetch_enable_i),\n      .fetch_enable_o(fetch_enable),\n\n      // Core status\n      .if_busy_i  (if_busy),\n      .ctrl_busy_i(ctrl_busy),\n      .lsu_busy_i (lsu_busy),\n      .apu_busy_i (apu_busy),\n\n      // PULP cluster\n      .pulp_clock_en_i       (pulp_clock_en_i),\n      .p_elw_start_i         (p_elw_start),\n      .p_elw_finish_i        (p_elw_finish),\n      .debug_p_elw_no_sleep_i(debug_p_elw_no_sleep),\n\n      // WFI wake\n      .wake_from_sleep_i(wake_from_sleep)\n  );\n\n\n  //////////////////////////////////////////////////\n  //   ___ _____   ____ _____  _    ____ _____    //\n  //  |_ _|  ___| / ___|_   _|/ \\  / ___| ____|   //\n  //   | || |_    \\___ \\ | | / _ \\| |  _|  _|     //\n  //   | ||  _|    ___) || |/ ___ \\ |_| | |___    //\n  //  |___|_|     |____/ |_/_/   \\_\\____|_____|   //\n  //                                              //\n  //////////////////////////////////////////////////\n  cv32e40p_if_stage #(\n      .COREV_PULP (COREV_PULP),\n      .PULP_OBI   (PULP_OBI),\n      .PULP_SECURE(PULP_SECURE),\n      .FPU        (FPU),\n      .ZFINX      (ZFINX)\n  ) if_stage_i (\n      .clk  (clk),\n      .rst_n(rst_ni),\n\n      // boot address\n      .boot_addr_i        (boot_addr_i[31:0]),\n      .dm_exception_addr_i(dm_exception_addr_i[31:0]),\n\n      // debug mode halt address\n      .dm_halt_addr_i(dm_halt_addr_i[31:0]),\n\n      // trap vector location\n      .m_trap_base_addr_i(mtvec),\n      .u_trap_base_addr_i(utvec),\n      .trap_addr_mux_i   (trap_addr_mux),\n\n      // instruction request control\n      .req_i(instr_req_int),\n\n      // instruction cache interface\n      .instr_req_o    (instr_req_pmp),\n      .instr_addr_o   (instr_addr_pmp),\n      .instr_gnt_i    (instr_gnt_pmp),\n      .instr_rvalid_i (instr_rvalid_i),\n      .instr_rdata_i  (instr_rdata_i),\n      .instr_err_i    (1'b0),  // Bus error (not used yet)\n      .instr_err_pmp_i(instr_err_pmp),  // PMP error\n\n      // outputs to ID stage\n      .instr_valid_id_o (instr_valid_id),\n      .instr_rdata_id_o (instr_rdata_id),\n      .is_fetch_failed_o(is_fetch_failed_id),\n\n      // control signals\n      .clear_instr_valid_i(clear_instr_valid),\n      .pc_set_i           (pc_set),\n\n      .mepc_i(mepc),  // exception return address\n      .uepc_i(uepc),  // exception return address\n\n      .depc_i(depc),  // debug return address\n\n      .pc_mux_i    (pc_mux_id),  // sel for pc multiplexer\n      .exc_pc_mux_i(exc_pc_mux_id),\n\n\n      .pc_id_o(pc_id),\n      .pc_if_o(pc_if),\n\n      .is_compressed_id_o (is_compressed_id),\n      .illegal_c_insn_id_o(illegal_c_insn_id),\n\n      .m_exc_vec_pc_mux_i(m_exc_vec_pc_mux_id),\n      .u_exc_vec_pc_mux_i(u_exc_vec_pc_mux_id),\n\n      .csr_mtvec_init_o(csr_mtvec_init),\n\n      // from hwloop registers\n      .hwlp_jump_i  (hwlp_jump),\n      .hwlp_target_i(hwlp_target),\n\n\n      // Jump targets\n      .jump_target_id_i(jump_target_id),\n      .jump_target_ex_i(jump_target_ex),\n\n      // pipeline stalls\n      .halt_if_i (halt_if),\n      .id_ready_i(id_ready),\n\n      .if_busy_o   (if_busy),\n      .perf_imiss_o(perf_imiss)\n  );\n\n\n  /////////////////////////////////////////////////\n  //   ___ ____    ____ _____  _    ____ _____   //\n  //  |_ _|  _ \\  / ___|_   _|/ \\  / ___| ____|  //\n  //   | || | | | \\___ \\ | | / _ \\| |  _|  _|    //\n  //   | || |_| |  ___) || |/ ___ \\ |_| | |___   //\n  //  |___|____/  |____/ |_/_/   \\_\\____|_____|  //\n  //                                             //\n  /////////////////////////////////////////////////\n  cv32e40p_id_stage #(\n      .COREV_PULP      (COREV_PULP)"}
{"text": ",\n      .COREV_CLUSTER   (COREV_CLUSTER),\n      .N_HWLP          (N_HWLP),\n      .PULP_SECURE     (PULP_SECURE),\n      .USE_PMP         (USE_PMP),\n      .A_EXTENSION     (A_EXTENSION),\n      .APU             (APU),\n      .FPU             (FPU),\n      .FPU_ADDMUL_LAT  (FPU_ADDMUL_LAT),\n      .FPU_OTHERS_LAT  (FPU_OTHERS_LAT),\n      .ZFINX           (ZFINX),\n      .APU_NARGS_CPU   (APU_NARGS_CPU),\n      .APU_WOP_CPU     (APU_WOP_CPU),\n      .APU_NDSFLAGS_CPU(APU_NDSFLAGS_CPU),\n      .APU_NUSFLAGS_CPU(APU_NUSFLAGS_CPU),\n      .DEBUG_TRIGGER_EN(DEBUG_TRIGGER_EN)\n  ) id_stage_i (\n      .clk          (clk),  // Gated clock\n      .clk_ungated_i(clk_i),  // Ungated clock\n      .rst_n        (rst_ni),\n\n      .scan_cg_en_i(scan_cg_en_i),\n\n      // Processor Enable\n      .fetch_enable_i               ( fetch_enable         ),     // Delayed version so that clock can remain gated until fetch enabled\n      .ctrl_busy_o(ctrl_busy),\n      .is_decoding_o(is_decoding),\n\n      // Interface to instruction memory\n      .instr_valid_i(instr_valid_id),\n      .instr_rdata_i(instr_rdata_id),\n      .instr_req_o  (instr_req_int),\n\n      // Jumps and branches\n      .branch_in_ex_o             (branch_in_ex),\n      .branch_decision_i          (branch_decision),\n      .jump_target_o              (jump_target_id),\n      .ctrl_transfer_insn_in_dec_o(ctrl_transfer_insn_in_dec),\n\n      // IF and ID control signals\n      .clear_instr_valid_o(clear_instr_valid),\n      .pc_set_o           (pc_set),\n      .pc_mux_o           (pc_mux_id),\n      .exc_pc_mux_o       (exc_pc_mux_id),\n      .exc_cause_o        (exc_cause),\n      .trap_addr_mux_o    (trap_addr_mux),\n\n      .is_fetch_failed_i(is_fetch_failed_id),\n\n      .pc_id_i(pc_id),\n\n      .is_compressed_i (is_compressed_id),\n      .illegal_c_insn_i(illegal_c_insn_id),\n\n      // Stalls\n      .halt_if_o(halt_if),\n\n      .id_ready_o(id_ready),\n      .ex_ready_i(ex_ready),\n      .wb_ready_i(lsu_ready_wb),\n\n      .id_valid_o(id_valid),\n      .ex_valid_i(ex_valid),\n\n      // From the Pipeline ID/EX\n      .pc_ex_o(pc_ex),\n\n      .alu_en_ex_o        (alu_en_ex),\n      .alu_operator_ex_o  (alu_operator_ex),\n      .alu_operand_a_ex_o (alu_operand_a_ex),\n      .alu_operand_b_ex_o (alu_operand_b_ex),\n      .alu_operand_c_ex_o (alu_operand_c_ex),\n      .bmask_a_ex_o       (bmask_a_ex),\n      .bmask_b_ex_o       (bmask_b_ex),\n      .imm_vec_ext_ex_o   (imm_vec_ext_ex),\n      .alu_vec_mode_ex_o  (alu_vec_mode_ex),\n      .alu_is_clpx_ex_o   (alu_is_clpx_ex),\n      .alu_is_subrot_ex_o (alu_is_subrot_ex),\n      .alu_clpx_shift_ex_o(alu_clpx_shift_ex),\n\n      .regfile_waddr_ex_o(regfile_waddr_ex),\n      .regfile_we_ex_o   (regfile_we_ex),\n\n      .regfile_alu_we_ex_o   (regfile_alu_we_ex),\n      .regfile_alu_waddr_ex_o(regfile_alu_waddr_ex),\n\n      // MUL\n      .mult_operator_ex_o   (mult_operator_ex),  // from ID to EX stage\n      .mult_en_ex_o         (mult_en_ex),  // from ID to EX stage\n      .mult_sel_subword_ex_o(mult_sel_subword_ex),  // from ID to EX stage\n      .mult_signed_mode_ex_o(mult_signed_mode_ex),  // from ID to EX stage\n      .mult_operand_a_ex_o  (mult_operand_a_ex),  // from ID to EX stage\n      .mult_operand_b_ex_o  (mult_operand_b_ex),  // from ID to EX stage\n      .mult_operand_c_ex_o  (mult_operand_c_ex),  // from ID to EX stage\n      .mult_imm_ex_o        (mult_imm_ex),  // from ID to EX stage\n\n      .mult_dot_op_a_ex_o  (mult_dot_op_a_ex),  // from ID to EX stage\n      .mult_dot_op_b_ex_o  (mult_dot_op_b_ex),  // from ID to EX stage\n      .mult_dot_op_c_ex_o  (mult_dot_op_c_ex),  // from ID to EX stage\n      .mult_dot_signed_ex_o(mult_dot_signed_ex),  // from ID to EX stage\n      .mult_is_clpx_ex_o   (mult_is_clpx_ex),  // from ID to EX stage\n      .mult_clpx_shift_ex_o(mult_clpx_shift_ex),  // from ID to EX stage\n      .mult_clpx_img_ex_o  (mult_clpx_img_ex),  // from ID to EX stage\n\n      // FPU\n      .fs_off_i(fs_off),\n      .frm_i   (frm_csr),\n\n      // APU\n      .apu_en_ex_o      (apu_en_ex),\n      .apu_op_ex_o      (apu_op_ex),\n      .apu_lat_ex_o     (apu_lat_ex),\n      .apu_operands_ex_o(apu_operands_ex),\n      .apu_flags_ex_o   (apu_flags_ex),\n      .apu_waddr_ex_o   (apu_waddr_ex),\n\n      .apu_read_regs_o        (apu_read_regs),\n      .apu_read_regs_valid_o  (apu_read_regs_valid),\n      .apu_read_dep_i         (apu_read_dep),\n      .apu_read_dep_for_jalr_i(apu_read_dep_for_jalr),\n      .apu_write_regs_o       (apu_write_regs),\n      .apu_write_regs_valid_o (apu_write_regs_valid),\n      .apu_write_dep_i        (apu_write_dep),\n      .apu_perf_dep_o         (perf_apu_dep),\n      .apu_busy_i             (apu_busy),\n\n      // CSR ID/EX\n      .csr_access_ex_o      (csr_access_ex),\n      .csr_op_ex_o          (csr_op_ex),\n      .current_priv_lvl_i   (current_priv_lvl),\n      .csr_irq_sec_o        (csr_irq_sec),\n      .csr_cause_o          (csr_cause),\n      .csr_save_if_o        (csr_save_if),  // control signal to save pc\n      .csr_save_id_o        (csr_save_id),  // control signal to save pc\n      .csr_save_ex_o        (csr_save_ex),  // control signal to save pc\n      .csr_restore_mret_id_o(csr_restore_mret_id),  // control signal to restore pc\n      .csr_restore_uret_id_o(csr_restore_uret_id),  // control signal to restore pc\n\n      .csr_restore_dret_id_o(csr_restore_dret_id),  // control signal to restore pc\n\n      .csr_save_cause_o(csr_save_cause),\n\n      // hardware loop signals to IF hwlp controller\n      .hwlp_start_o(hwlp_start),\n      .hwlp_end_o  (hwlp_end),\n      .hwlp_cnt_o  (hwlp_cnt),\n\n      .hwlp_jump_o  (hwlp_jump),\n      .hwlp_target_o(hwlp_target),\n\n      // LSU\n      .data_req_ex_o       (data_req_ex),  // to load store unit\n      .data_we_ex_o        (data_we_ex),  // to load store unit\n      .atop_ex_o           (data_atop_ex),\n      .data_type_ex_o      (data_type_ex),  // to load store unit\n      .data_sign_ext_ex_o  (data_sign_ext_ex),  // to load store unit\n      .data_reg_offset_ex_o(data_reg_offset_ex),  // to load store unit\n      .data_load_event_ex_o(data_load_event_ex),  // to load store unit\n\n      .data_misaligned_ex_o(data_misaligned_ex),  // to load store unit\n\n      .prepost_useincr_ex_o(useincr_addr_ex),\n      .data_misaligned_i   (data_misaligned),\n      .data_err_i          (data_err_pmp),\n      .data_err_ack_o      (data_err_ack),\n\n      // Interrupt Signals\n      .irq_i         (irq_i),\n      .irq_sec_i     ((PULP_SECURE) ? irq_sec_i : 1'b0),\n      .mie_bypass_i  (mie_bypass),\n      .mip_o         (mip),\n      .m_irq_enable_i(m_irq_enable),\n      .u_irq_enable_i(u_irq_enable),\n      .irq_ack_o     (irq_ack_o),\n      .irq_id_o      (irq_id_o),\n\n      // Debug Signal\n      .debug_mode_o          (debug_mode),\n      .debug_cause_o         (debug_cause),\n      .debug_csr_save_o      (debug_csr_save),\n      .debug_req_i           (debug_req_i),\n      .debug_havereset_o     (debug_havereset_o),\n      .debug_running_o       (debug_running_o),\n      .debug_halted_o        (debug_halted_o),\n      .debug_single_step_i   (debug_single_step),\n      .debug_ebreakm_i       (debug_ebreakm),\n      .debug_ebreaku_i       (debug_ebreaku),\n      .trigger_match_i       (trigger_match),\n      .debug_p_elw_no_sleep_o(debug_p_elw_no_sleep),\n\n      // Wakeup Signal\n      .wake_from_sleep_o(wake_from_sleep),\n\n      // Forward Signals\n      .regfile_waddr_wb_i   (regfile_waddr_fw_wb_o),  // Write address ex-wb pipeline\n      .regfile_we_wb_i      (regfile_we_wb),  // write enable for the register file\n      .regfile_we_wb_power_i(regfile_we_wb_power),\n      .regfile_wdata_wb_i   (regfile_wdata),  // write data to commit in the register file\n\n      .regfile_alu_waddr_fw_i   (regfile_alu_waddr_fw),\n      .regfile_alu_we_fw_i      (regfile_alu_we_fw),\n      .regfile_alu_we_fw_power_i(regfile_alu_we_fw_power),\n      .regfile_alu_wdata_fw_i   (regfile_alu_wdata_fw),\n\n      // from ALU\n      .mult_multicycle_i(mult_multicycle),\n\n      // Performance Counters\n      .mhpmevent_minstret_o    (mhpmevent_minstret),\n      .mhpmevent_load_o        (mhpmevent_load),\n      .mhpmevent_store_o       (mhpmevent_store),\n      .mhpmevent_jump_o        (mhpmevent_jump),\n      .mhpmevent_branch_o      (mhpmevent_branch),\n      .mhpmevent_branch_taken_o(mhpmevent_branch_taken),\n      .mhpmevent_compressed_o  (mhpmevent_compressed),\n      .mhpmevent_jr_stall_o    (mhpmevent_jr_stall),\n      .mhpmevent_imiss_o       (mhpmevent_imiss),\n      .mhpmevent_ld_stall_o    (mhpmevent_ld_stall),\n      .mhpmevent_pipe_stall_o  (mhpmevent_pipe_stall),\n\n      .perf_imiss_i(perf_imiss),\n      .mcounteren_i(mcounteren)\n  );\n\n\n  /////////////////////////////////////////////////////\n  //   _______  __  ____ _____  _    ____ _____      //\n  //  | ____\\ \\/ / / ___|_   _|/ \\  / ___| ____|     //\n  //  |  _|  \\  /  \\___ \\ | | / _ \\| |  _|  _|       //\n  //  | |___ /  \\   ___) || |/ ___ \\ |_| | |___      //\n  //  |_____/_/\\_\\ |____/ |_/_/   \\_\\____|_____|     //\n  //                                                 //\n  /////////////////////////////////////////////////////\n  cv32e40p_ex_stage #(\n      .COREV_PULP      (COREV_PULP),\n      .FPU             (FPU),\n      .APU_NARGS_CPU   (APU_NARGS_CPU),\n      .APU_WOP_CPU     (APU_WOP_CPU),\n      .APU_NDSFLAGS_CPU(APU_NDSFLAGS_CPU),\n      .APU_NUSFLAGS_CPU(APU_NUSFLAGS_CPU)\n  ) ex_stage_i (\n      // Global signals: Clock and active low asynchronous reset\n      .clk  (clk),\n      .rst_n(rst_ni),\n\n      // Alu signals from ID stage\n      .alu_en_i        (alu_en_ex),\n      .alu_operator_i  (alu_operator_ex),  // from ID/EX pipe registers\n      .alu_operand_a_i (alu_operand_a_ex),  // from ID/EX pipe registers\n      .alu_operand_b_i (alu_operand_b_ex),  // from ID/EX pipe registers\n      .alu_operand_c_i (alu_operand_c_ex),  // from ID/EX pipe registers\n      .bmask_a_i       (bmask_a_ex),  // from ID/EX pipe registers\n      .bmask_b_i       (bmask_b_ex),  // from ID/EX pipe registers\n      .imm_vec_ext_i   (imm_vec_ext_ex),  // from ID/EX pipe registers\n      .alu_vec_mode_i  (alu_vec_mode_ex),  // from ID/EX pipe registers\n      .alu_is_clpx_i   (alu_is_clpx_ex),  // from ID/EX pipe registers\n      .alu_is_subrot_i (alu_is_subrot_ex),  // from ID/Ex pipe registers\n      .alu_clpx_shift_i(alu_clpx_shift_ex),  // from ID/EX pipe registers\n\n      // Multipler\n      .mult_operator_i   (mult_operator_ex),  // from ID/EX pipe registers\n      .mult_operand_a_i  (mult_operand_a_ex),  // from ID/EX pipe registers\n      .mult_operand_b_i  (mult_operand_b_ex),  // from ID/EX pipe registers\n      .mult_operand_c_i  (mult_operand_c_ex),  // from ID/EX pipe registers\n      .mult_en_i         (mult_en_ex),  // from ID/EX pipe registers\n      .mult_sel_subword_i(mult_sel_subword_ex),  // from ID/EX pipe registers\n      .mult_signed_mode_i(mult_signed_mode_ex),  // from ID/EX pipe registers\n      .mult_imm_i        (mult_imm_ex),  // from ID/EX pipe registers\n      .mult_dot_op_a_i   (mult_dot_op_a_ex),  // from ID/EX pipe registers\n      .mult_dot_op_b_i   (mult_dot_op_b_ex),  // from ID/EX pipe registers\n      .mult_dot_op_c_i   (mult_dot_op_c_ex),  // from ID/EX pipe registers\n      .mult_dot_signed_i (mult_dot_signed_ex),  // from ID/EX pipe registers\n      .mult_is_clpx_i    (mult_is_clpx_ex),  // from ID/EX pipe registers\n      .mult_clpx_shift_i (mult_clpx_shift_ex),  // from ID/EX pipe registers\n      .mult_clpx_img_i   (mult_clpx_img_ex),  // from ID/EX pipe registers\n\n      .mult_multicycle_o(mult_multicycle),  // to ID/EX pipe registers\n\n      .data_req_i          (data_req_o),  // from ID/EX pipeline\n      .data_rvalid_i       (data_rvalid_i),  // from ID/EX pipeline\n      .data_misaligned_ex_i(data_misaligned_ex),  // from ID/EX pipeline\n      .data_misaligned_i   (data_misaligned),\n\n      .ctrl_transfer_insn_in_dec_i(ctrl_transfer_insn_in_dec),\n\n      // FPU\n      .fpu_fflags_we_o(fflags_we),\n      .fpu_fflags_o   (fflags_csr),\n\n      // APU\n      .apu_en_i      (apu_en_ex),\n      .apu_op_i      (apu_op_ex),\n      .apu_lat_i     (apu_lat_ex),\n      .apu_operands_i(apu_operands_ex),\n      .apu_waddr_i   (apu_waddr_ex),\n\n      .apu_read_regs_i        (apu_read_regs),\n      .apu_read_regs_valid_i  (apu_read_regs_valid),\n      .apu_read_dep_o         (apu_read_dep),\n      .apu_read_dep_for_jalr_o(apu_read_dep_for_jalr),\n      .apu_write_regs_i       (apu_write_regs),\n      .apu_write_regs_valid_i (apu_write_regs_valid),\n      .apu_write_dep_o        (apu_write_dep),\n\n      .apu_perf_type_o(perf_apu_type),\n      .apu_perf_cont_o(perf_apu_cont),\n      .apu_perf_wb_o  (perf_apu_wb),\n      .apu_ready_wb_o (apu_ready_wb),\n      .apu_busy_o     (apu_busy),\n\n      // apu-interconnect\n      // handshake signals\n      .apu_req_o     (apu_req_o),\n      .apu_gnt_i     (apu_gnt_i),\n      // request channel\n      .apu_operands_o(apu_operands_o),\n      .apu_op_o      (apu_op_o),\n      // response channel\n      .apu_rvalid_i  (apu_rvalid_i),\n      .apu_result_i  (apu_result_i),\n      .apu_flags_i   (apu_flags_i),\n\n      .lsu_en_i   (data_req_ex),\n      .lsu_rdata_i(lsu_rdata),\n\n      // interface with CSRs\n      .csr_access_i(csr_access_ex),\n      .csr_rdata_i (csr_rdata),\n\n      // From ID Stage: Regfile control signals\n      .branch_in_ex_i     (branch_in_ex),\n      .regfile_alu_waddr_i(regfile_alu_waddr_ex),\n      .regfile_alu_we_i   (regfile_alu_we_ex),\n\n      .regfile_waddr_i(regfile_waddr_ex),\n      .regfile_we_i   (regfile_we_ex),\n\n      // Output of ex stage pipeline\n      .regfile_waddr_wb_o   (regfile_waddr_fw_wb_o),\n      .regfile_we_wb_o      (regfile_we_wb),\n      .regfile_we_wb_power_o(regfile_we_wb_power),\n      .regfile_wdata_wb_o   (regfile_wdata),\n\n      // To IF: Jump and branch target and decision\n      .jump_target_o    (jump_target_ex),\n      .branch_decision_o(branch_decision),\n\n      // To ID stage: Forwarding signals\n      .regfile_alu_waddr_fw_o   (regfile_alu_waddr_fw),\n      .regfile_alu_we_fw_o      (regfile_alu_we_fw),\n      .regfile_alu_we_fw_power_o(regfile_alu_we_fw_power),\n      .regfile_alu_wdata_fw_o   (regfile_alu_wdata_fw),\n\n      // stall control\n      .is_decoding_i (is_decoding),\n      .lsu_ready_ex_i(lsu_ready_ex),\n      .lsu_err_i     (data_err_pmp),\n\n      .ex_ready_o(ex_ready),\n      .ex_valid_o(ex_valid),\n      .wb_ready_i(lsu_ready_wb)\n  );\n\n\n  ////////////////////////////////////////////////////////////////////////////////////////\n  //    _     ___    _    ____    ____ _____ ___  ____  _____   _   _ _   _ ___ _____   //\n  //   | |   / _ \\  / \\  |  _ \\  / ___|_   _/ _ \\|  _ \\| ____| | | | | \\ | |_ _|_   _|  //\n  //   | |  | | | |/ _ \\ | | | | \\___ \\ | || | | | |_) |  _|   | | | |  \\| || |  | |    //\n  //   | |__| |_| / ___ \\| |_| |  ___) || || |_| |  _ <| |___  | |_| | |\\  || |  | |    //\n  //   |_____\\___/_/   \\_\\____/  |____/ |_| \\___/|_| \\_\\_____|  \\___/|_| \\_|___| |_|    //\n  //                                                                                    //\n  ////////////////////////////////////////////////////////////////////////////////////////\n\n  cv32e40p_load_store_unit #(\n      .PULP_OBI(PULP_OBI)\n  ) load_store_unit_i (\n      .clk  (clk),\n      .rst_n(rst_ni),\n\n      //output to data memory\n      .data_req_o    (data_req_pmp),\n      .data_gnt_i    (data_gnt_pmp),\n      .data_rvalid_i (data_rvalid_i),\n      .data_err_i    (1'b0),  // Bus error (not used yet)\n      .data_err_pmp_i(data_err_pmp),  // PMP error\n\n      .data_addr_o (data_addr_pmp),\n      .data_we_o   (data_we_o),\n      .data_atop_o (data_atop_o),\n      .data_be_o   (data_be_o),\n      .data_wdata_o(data_wdata_o),\n      .data_rdata_i(data_rdata_i),\n\n      // signal from ex stage\n      .data_we_ex_i        (data_we_ex),\n      .data_atop_ex_i      (data_atop_ex),\n      .data_type_ex_i      (data_type_ex),\n      .data_wdata_ex_i     (alu_operand_c_ex),\n      .data_reg_offset_ex_i(data_reg_offset_ex),\n      .data_load_event_ex_i(data_load_event_ex),\n      .data_sign_ext_ex_i  (data_sign_ext_ex),  // sign extension\n\n      .data_rdata_ex_o  (lsu_rdata),\n      .data_req_ex_i    (data_req_ex),\n      .operand_a_ex_i   (alu_operand_a_ex),\n      .operand_b_ex_i   (alu_operand_b_ex),\n      .addr_useincr_ex_i(useincr_addr_ex),\n\n      .data_misaligned_ex_i(data_misaligned_ex),  // from ID/EX pipeline\n      .data_misaligned_o   (data_misaligned),\n\n      .p_elw_start_o (p_elw_start),\n      .p_elw_finish_o(p_elw_finish),\n\n      // control signals\n      .lsu_ready_ex_o(lsu_ready_ex),\n      .lsu_ready_wb_o(lsu_ready_wb),\n\n      .busy_o(lsu_busy)\n  );\n\n  // Tracer signal\n  assign wb_valid = lsu_ready_wb;\n\n\n  //////////////////////////////////////\n  //        ____ ____  ____           //\n  //       / ___/ ___||  _ \\ ___      //\n  //      | |   \\___ \\| |_) / __|     //\n  //      | |___ ___) |  _ <\\__ \\     //\n  //       \\____|____/|_| \\_\\___/     //\n  //                                  //\n  //   Control and Status Registers   //\n  //////////////////////////////////////\n\n  cv32e40p_cs_registers #(\n      .N_HWLP          (N_HWLP),\n      .A_EXTENSION     (A_EXTENSION),\n      .FPU             (FPU),\n      .ZFINX           (ZFINX),\n      .APU             (APU),\n      .PULP_SECURE     (PULP_SECURE),\n      .USE_PMP         (USE_PMP),\n      .N_PMP_ENTRIES   (N_PMP_ENTRIES),\n      .NUM_MHPMCOUNTERS(NUM_MHPMCOUNTERS),\n      .COREV_PULP      (COREV_PULP),\n      .COREV_CLUSTER   (COREV_CLUSTER),\n      .DEBUG_TRIGGER_EN(DEBUG_TRIGGER_EN)\n  ) cs_registers_i (\n      .clk  (clk),\n      .rst_n(rst_ni),\n\n      // Hart ID from outside\n      .hart_id_i       (hart_id_i),\n      .mtvec_o         (mtvec),\n      .utvec_o         (utvec),\n      .mtvec_mode_o    (mtvec_mode),\n      .utvec_mode_o    (utvec_mode),\n      // mtvec address\n      .mtvec_addr_i    (mtvec_addr_i[31:0]),\n      .csr_mtvec_init_i(csr_mtvec_init),\n      // Interface to CSRs (SRAM like)\n      .csr_addr_i      (csr_addr),\n      .csr_wdata_i     (csr_wdata),\n      .csr_op_i        (csr_op),\n      .csr_rdata_o     (csr_rdata),\n\n      .fs_off_o   (fs_off),\n      .frm_o      (frm_csr),\n      .fflags_i   (fflags_csr),\n      .fflags_we_i(fflags_we),\n      .fregs_we_i (fregs_we),\n\n      // Interrupt related control signals\n      .mie_bypass_o  (mie_bypass),\n      .mip_i         (mip),\n      .m_irq_enable_o(m_irq_enable),\n      .u_irq_enable_o(u_irq_enable),\n      .csr_irq_sec_i (csr_irq_sec),\n      .sec_lvl_o     (sec_lvl_o),\n      .mepc_o        (mepc),\n      .uepc_o        (uepc),\n\n      // HPM related control signals\n      .mcounteren_o(mcounteren),\n\n      // debug\n      .debug_mode_i       (debug_mode),\n      .debug_cause_i      (debug_cause),\n      .debug_csr_save_i   (debug_csr_save),\n      .depc_o             (depc),\n      .debug_single_step_o(debug_single_step),\n      .debug_ebreakm_o    (debug_ebreakm),\n      .debug_ebreaku_o    (debug_ebreaku),\n      .trigger_match_o    (trigger_match),\n\n      .priv_lvl_o(current_priv_lvl),\n\n      .pmp_addr_o(pmp_addr),\n      .pmp_cfg_o (pmp_cfg),\n\n      .pc_if_i(pc_if),\n      .pc_id_i(pc_id),\n      .pc_ex_i(pc_ex),\n\n      .csr_save_if_i     (csr_save_if),\n      .csr_save_id_i     (csr_save_id),\n      .csr_save_ex_i     (csr_save_ex),\n      .csr_restore_mret_i(csr_restore_mret_id),\n      .csr_restore_uret_i(csr_restore_uret_id),\n\n      .csr_restore_dret_i(csr_restore_dret_id),\n\n      .csr_cause_i     (csr_cause),\n      .csr_save_cause_i(csr_save_cause),\n\n      // from hwloop registers\n      .hwlp_start_i(hwlp_start),\n      .hwlp_end_i  (hwlp_end),\n      .hwlp_cnt_i  (hwlp_cnt),\n\n      // performance counter related signals\n      .mhpmevent_minstret_i    (mhpmevent_minstret),\n      .mhpmevent_load_i        (mhpmevent_load),\n      .mhpmevent_store_i       (mhpmevent_store),\n      .mhpmevent_jump_i        (mhpmevent_jump),\n      .mhpmevent_branch_i      (mhpmevent_branch),\n      .mhpmevent_branch_taken_i(mhpmevent_branch_taken),\n      .mhpmevent_compressed_i  (mhpmevent_compressed),\n      .mhpmevent_jr_stall_i    (mhpmevent_jr_stall),\n      .mhpmevent_imiss_i       (mhpmevent_imiss),\n      .mhpmevent_ld_stall_i    (m"}
{"text": "hpmevent_ld_stall),\n      .mhpmevent_pipe_stall_i  (mhpmevent_pipe_stall),\n      .apu_typeconflict_i      (perf_apu_type),\n      .apu_contention_i        (perf_apu_cont),\n      .apu_dep_i               (perf_apu_dep),\n      .apu_wb_i                (perf_apu_wb)\n  );\n\n  //  CSR access\n  assign csr_addr = csr_addr_int;\n  assign csr_wdata = alu_operand_a_ex;\n  assign csr_op = csr_op_ex;\n\n  assign csr_addr_int = csr_num_e'(csr_access_ex ? alu_operand_b_ex[11:0] : '0);\n\n  //  Floating-Point registers write\n  assign fregs_we     = (FPU & !ZFINX) ? ((regfile_alu_we_fw && regfile_alu_waddr_fw[5]) ||\n                                          (regfile_we_wb     && regfile_waddr_fw_wb_o[5]))\n                                       : 1'b0;\n\n  ///////////////////////////\n  //   ____  __  __ ____   //\n  //  |  _ \\|  \\/  |  _ \\  //\n  //  | |_) | |\\/| | |_) | //\n  //  |  __/| |  | |  __/  //\n  //  |_|   |_|  |_|_|     //\n  //                       //\n  ///////////////////////////\n\n  generate\n    if (PULP_SECURE && USE_PMP) begin : gen_pmp\n      cv32e40p_pmp #(\n          .N_PMP_ENTRIES(N_PMP_ENTRIES)\n      ) pmp_unit_i (\n          .clk  (clk),\n          .rst_n(rst_ni),\n\n          .pmp_privil_mode_i(current_priv_lvl),\n\n          .pmp_addr_i(pmp_addr),\n          .pmp_cfg_i (pmp_cfg),\n\n\n          .data_req_i (data_req_pmp),\n          .data_addr_i(data_addr_pmp),\n          .data_we_i  (data_we_o),\n          .data_gnt_o (data_gnt_pmp),\n\n          .data_req_o    (data_req_o),\n          .data_gnt_i    (data_gnt_i),\n          .data_addr_o   (data_addr_o),\n          .data_err_o    (data_err_pmp),\n          .data_err_ack_i(data_err_ack),\n\n          .instr_req_i (instr_req_pmp),\n          .instr_addr_i(instr_addr_pmp),\n          .instr_gnt_o (instr_gnt_pmp),\n\n          .instr_req_o (instr_req_o),\n          .instr_gnt_i (instr_gnt_i),\n          .instr_addr_o(instr_addr_o),\n          .instr_err_o (instr_err_pmp)\n      );\n    end else begin : gen_no_pmp\n      assign instr_req_o   = instr_req_pmp;\n      assign instr_addr_o  = instr_addr_pmp;\n      assign instr_gnt_pmp = instr_gnt_i;\n      assign instr_err_pmp = 1'b0;\n\n      assign data_req_o    = data_req_pmp;\n      assign data_addr_o   = data_addr_pmp;\n      assign data_gnt_pmp  = data_gnt_i;\n      assign data_err_pmp  = 1'b0;\n    end\n  endgenerate\n\n`ifdef CV32E40P_ASSERT_ON\n\n  //----------------------------------------------------------------------------\n  // Assumptions\n  //----------------------------------------------------------------------------\n\n  generate\n    if (COREV_CLUSTER) begin : gen_pulp_cluster_assumptions\n\n      // Assumptions/requirements on the environment when pulp_clock_en_i = 0\n      property p_env_req_0;\n        @(posedge clk_i) disable iff (!rst_ni) (pulp_clock_en_i == 1'b0) |-> (irq_i == 'b0) && (debug_req_i == 1'b0) &&\n                                                                            (instr_rvalid_i == 1'b0) && (instr_gnt_i == 1'b0) &&\n                                                                            (data_rvalid_i == 1'b0) && (data_gnt_i == 1'b0);\n      endproperty\n\n      a_env_req_0 :\n      assume property (p_env_req_0);\n\n      // Assumptions/requirements on the environment when core_sleep_o = 0\n      property p_env_req_1;\n        @(posedge clk_i) disable iff (!rst_ni) (core_sleep_o == 1'b0) |-> (pulp_clock_en_i == 1'b1);\n      endproperty\n\n      a_env_req_1 :\n      assume property (p_env_req_1);\n\n    end\n  endgenerate\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n\n  generate\n    if (!COREV_CLUSTER) begin : gen_no_pulp_cluster_assertions\n      // Check that a taken IRQ is actually enabled (e.g. that we do not react to an IRQ that was just disabled in MIE)\n      property p_irq_enabled_0;\n        @(posedge clk) disable iff (!rst_ni) (pc_set && (pc_mux_id == PC_EXCEPTION) && (exc_pc_mux_id == EXC_PC_IRQ)) |->\n         (cs_registers_i.mie_n[exc_cause] && cs_registers_i.mstatus_q.mie);\n      endproperty\n\n      a_irq_enabled_0 :\n      assert property (p_irq_enabled_0);\n\n      // Check that a taken IRQ was for an enabled cause and that mstatus.mie gets disabled\n      property p_irq_enabled_1;\n        @(posedge clk) disable iff (!rst_ni) (pc_set && (pc_mux_id == PC_EXCEPTION) && (exc_pc_mux_id == EXC_PC_IRQ)) |=>\n         (cs_registers_i.mcause_q[5] && cs_registers_i.mie_q[cs_registers_i.mcause_q[4:0]] && !cs_registers_i.mstatus_q.mie);\n      endproperty\n\n      a_irq_enabled_1 :\n      assert property (p_irq_enabled_1);\n    end\n  endgenerate\n\n  generate\n    if (!COREV_PULP) begin : gen_no_pulp_xpulp_assertions\n\n      // Illegal, ECALL, EBRK checks excluded for PULP due to other definition for for Hardware Loop\n\n      // First illegal instruction decoded\n      logic        first_illegal_found;\n      logic        first_ecall_found;\n      logic        first_ebrk_found;\n      logic [31:0] expected_illegal_mepc;\n      logic [31:0] expected_ecall_mepc;\n      logic [31:0] expected_ebrk_mepc;\n\n      always_ff @(posedge clk, negedge rst_ni) begin\n        if (rst_ni == 1'b0) begin\n          first_illegal_found   <= 1'b0;\n          first_ecall_found     <= 1'b0;\n          first_ebrk_found      <= 1'b0;\n          expected_illegal_mepc <= 32'b0;\n          expected_ecall_mepc   <= 32'b0;\n          expected_ebrk_mepc    <= 32'b0;\n        end else begin\n          if (!first_illegal_found && is_decoding && id_valid && id_stage_i.illegal_insn_dec && !id_stage_i.controller_i.debug_mode_n) begin\n            first_illegal_found   <= 1'b1;\n            expected_illegal_mepc <= pc_id;\n          end\n          if (!first_ecall_found && is_decoding && id_valid && id_stage_i.ecall_insn_dec && !id_stage_i.controller_i.debug_mode_n) begin\n            first_ecall_found   <= 1'b1;\n            expected_ecall_mepc <= pc_id;\n          end\n          if (!first_ebrk_found && is_decoding && id_valid && id_stage_i.ebrk_insn_dec && (id_stage_i.controller_i.ctrl_fsm_ns != DBG_FLUSH)) begin\n            first_ebrk_found   <= 1'b1;\n            expected_ebrk_mepc <= pc_id;\n          end\n        end\n      end\n\n      // First mepc write for illegal instruction exception\n      logic        first_cause_illegal_found;\n      logic        first_cause_ecall_found;\n      logic        first_cause_ebrk_found;\n      logic [31:0] actual_illegal_mepc;\n      logic [31:0] actual_ecall_mepc;\n      logic [31:0] actual_ebrk_mepc;\n\n      always_ff @(posedge clk, negedge rst_ni) begin\n        if (rst_ni == 1'b0) begin\n          first_cause_illegal_found <= 1'b0;\n          first_cause_ecall_found   <= 1'b0;\n          first_cause_ebrk_found    <= 1'b0;\n          actual_illegal_mepc       <= 32'b0;\n          actual_ecall_mepc         <= 32'b0;\n          actual_ebrk_mepc          <= 32'b0;\n        end else begin\n          if (!first_cause_illegal_found && (cs_registers_i.csr_cause_i == {\n                1'b0, EXC_CAUSE_ILLEGAL_INSN\n              }) && csr_save_cause) begin\n            first_cause_illegal_found <= 1'b1;\n            actual_illegal_mepc       <= cs_registers_i.mepc_n;\n          end\n          if (!first_cause_ecall_found && (cs_registers_i.csr_cause_i == {\n                1'b0, EXC_CAUSE_ECALL_MMODE\n              }) && csr_save_cause) begin\n            first_cause_ecall_found <= 1'b1;\n            actual_ecall_mepc       <= cs_registers_i.mepc_n;\n          end\n          if (!first_cause_ebrk_found && (cs_registers_i.csr_cause_i == {\n                1'b0, EXC_CAUSE_BREAKPOINT\n              }) && csr_save_cause) begin\n            first_cause_ebrk_found <= 1'b1;\n            actual_ebrk_mepc       <= cs_registers_i.mepc_n;\n          end\n        end\n      end\n\n      // Check that mepc is updated with PC of illegal instruction\n      property p_illegal_mepc;\n        @(posedge clk) disable iff (!rst_ni) (first_illegal_found && first_cause_illegal_found) |=> (expected_illegal_mepc == actual_illegal_mepc);\n      endproperty\n\n      a_illegal_mepc :\n      assert property (p_illegal_mepc);\n\n      // Check that mepc is updated with PC of the ECALL instruction\n      property p_ecall_mepc;\n        @(posedge clk) disable iff (!rst_ni) (first_ecall_found && first_cause_ecall_found) |=> (expected_ecall_mepc == actual_ecall_mepc);\n      endproperty\n\n      a_ecall_mepc :\n      assert property (p_ecall_mepc);\n\n      // Check that mepc is updated with PC of EBRK instruction\n      property p_ebrk_mepc;\n        @(posedge clk) disable iff (!rst_ni) (first_ebrk_found && first_cause_ebrk_found) |=> (expected_ebrk_mepc == actual_ebrk_mepc);\n      endproperty\n\n      a_ebrk_mepc :\n      assert property (p_ebrk_mepc);\n\n    end\n  endgenerate\n\n  // Single Step only decodes one instruction in non debug mode and next instruction decode is in debug mode\n  logic inst_taken;\n  assign inst_taken = id_valid && is_decoding;\n\n  a_single_step :\n  assert property\n  (\n    @(posedge clk) disable iff (!rst_ni)\n    (inst_taken && debug_single_step && ~debug_mode)\n    ##1 inst_taken [->1]\n    |-> (debug_mode && debug_single_step));\n\n`endif\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Sven Stucki - svstucki@student.ethz.ch                     //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Andreas Traber - atraber@iis.ee.ethz.ch                    //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                 Andrea Bettati - andrea.bettati@studenti.unipr.it          //\n//                                                                            //\n// Design Name:    Control and Status Registers                               //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Control and Status Registers (CSRs) loosely following the  //\n//                 RiscV draft priviledged instruction set spec (v1.9)        //\n//                 Added Floating point support                               //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_cs_registers\n  import cv32e40p_pkg::*;\n#(\n    parameter N_HWLP           = 2,\n    parameter APU              = 0,\n    parameter A_EXTENSION      = 0,\n    parameter FPU              = 0,\n    parameter ZFINX            = 0,\n    parameter PULP_SECURE      = 0,\n    parameter USE_PMP          = 0,\n    parameter N_PMP_ENTRIES    = 16,\n    parameter NUM_MHPMCOUNTERS = 1,\n    parameter COREV_PULP       = 0,\n    parameter COREV_CLUSTER    = 0,\n    parameter DEBUG_TRIGGER_EN = 1\n) (\n    // Clock and Reset\n    input logic clk,\n    input logic rst_n,\n\n    // Hart ID\n    input  logic [31:0] hart_id_i,\n    output logic [23:0] mtvec_o,\n    output logic [23:0] utvec_o,\n    output logic [ 1:0] mtvec_mode_o,\n    output logic [ 1:0] utvec_mode_o,\n\n    // Used for mtvec address\n    input logic [31:0] mtvec_addr_i,\n    input logic        csr_mtvec_init_i,\n\n    // Interface to registers (SRAM like)\n    input  csr_num_e           csr_addr_i,\n    input  logic        [31:0] csr_wdata_i,\n    input  csr_opcode_e        csr_op_i,\n    output logic        [31:0] csr_rdata_o,\n\n    output logic               fs_off_o,\n    output logic [        2:0] frm_o,\n    input  logic [C_FFLAG-1:0] fflags_i,\n    input  logic               fflags_we_i,\n    input  logic               fregs_we_i,\n\n    // Interrupts\n    output logic [31:0] mie_bypass_o,\n    input  logic [31:0] mip_i,\n    output logic        m_irq_enable_o,\n    output logic        u_irq_enable_o,\n\n    //csr_irq_sec_i is always 0 if PULP_SECURE is zero\n    input  logic        csr_irq_sec_i,\n    output logic        sec_lvl_o,\n    output logic [31:0] mepc_o,\n    output logic [31:0] uepc_o,\n    //mcounteren_o is always 0 if PULP_SECURE is zero\n    output logic [31:0] mcounteren_o,\n\n    // debug\n    input  logic        debug_mode_i,\n    input  logic [ 2:0] debug_cause_i,\n    input  logic        debug_csr_save_i,\n    output logic [31:0] depc_o,\n    output logic        debug_single_step_o,\n    output logic        debug_ebreakm_o,\n    output logic        debug_ebreaku_o,\n    output logic        trigger_match_o,\n\n\n    output logic [N_PMP_ENTRIES-1:0][31:0] pmp_addr_o,\n    output logic [N_PMP_ENTRIES-1:0][ 7:0] pmp_cfg_o,\n\n    output PrivLvl_t priv_lvl_o,\n\n    input logic [31:0] pc_if_i,\n    input logic [31:0] pc_id_i,\n    input logic [31:0] pc_ex_i,\n\n    input logic csr_save_if_i,\n    input logic csr_save_id_i,\n    input logic csr_save_ex_i,\n\n    input logic csr_restore_mret_i,\n    input logic csr_restore_uret_i,\n\n    input logic                    csr_restore_dret_i,\n    //coming from controller\n    input logic [       5:0]       csr_cause_i,\n    //coming from controller\n    input logic                    csr_save_cause_i,\n    // Hardware loops\n    input logic [N_HWLP-1:0][31:0] hwlp_start_i,\n    input logic [N_HWLP-1:0][31:0] hwlp_end_i,\n    input logic [N_HWLP-1:0][31:0] hwlp_cnt_i,\n\n    // Performance Counters\n    input logic mhpmevent_minstret_i,\n    input logic mhpmevent_load_i,\n    input logic mhpmevent_store_i,\n    input logic mhpmevent_jump_i,  // Jump instruction retired (j, jr, jal, jalr)\n    input logic mhpmevent_branch_i,  // Branch instruction retired (beq, bne, etc.)\n    input logic mhpmevent_branch_taken_i,  // Branch instruction taken\n    input logic mhpmevent_compressed_i,\n    input logic mhpmevent_jr_stall_i,\n    input logic mhpmevent_imiss_i,\n    input logic mhpmevent_ld_stall_i,\n    input logic mhpmevent_pipe_stall_i,\n    input logic apu_typeconflict_i,\n    input logic apu_contention_i,\n    input logic apu_dep_i,\n    input logic apu_wb_i\n);\n\n  localparam NUM_HPM_EVENTS = 16;\n\n  localparam MTVEC_MODE = 2'b01;\n\n  localparam MAX_N_PMP_ENTRIES = 16;\n  localparam MAX_N_PMP_CFG = 4;\n  localparam N_PMP_CFG = N_PMP_ENTRIES % 4 == 0 ? N_PMP_ENTRIES / 4 : N_PMP_ENTRIES / 4 + 1;\n\n  localparam MSTATUS_UIE_BIT = 0;\n  localparam MSTATUS_SIE_BIT = 1;\n  localparam MSTATUS_MIE_BIT = 3;\n  localparam MSTATUS_UPIE_BIT = 4;\n  localparam MSTATUS_SPIE_BIT = 5;\n  localparam MSTATUS_MPIE_BIT = 7;\n  localparam MSTATUS_SPP_BIT = 8;\n  localparam MSTATUS_MPP_BIT_LOW = 11;\n  localparam MSTATUS_MPP_BIT_HIGH = 12;\n  localparam MSTATUS_FS_BIT_LOW = 13;\n  localparam MSTATUS_FS_BIT_HIGH = 14;\n  localparam MSTATUS_MPRV_BIT = 17;\n  localparam MSTATUS_SD_BIT = 31;\n\n  // misa\n  localparam logic [1:0] MXL = 2'd1;  // M-XLEN: XLEN in M-Mode for RV32\n  localparam logic [31:0] MISA_VALUE = (32'(A_EXTENSION) << 0)  // A - Atomic Instructions extension\n  | (1 << 2)  // C - Compressed extension\n  | (0 << 3)  // D - Double precision floating-point extension\n  | (0 << 4)  // E - RV32E base ISA\n  | (32'(FPU == 1 && ZFINX == 0) << 5)  // F - Single precision floating-point extension\n  | (1 << 8)  // I - RV32I/64I/128I base ISA\n  | (1 << 12)  // M - Integer Multiply/Divide extension\n  | (0 << 13)  // N - User level interrupts supported\n  | (0 << 18)  // S - Supervisor mode implemented\n  | (32'(PULP_SECURE) << 20)  // U - User mode implemented\n  | (32'(COREV_PULP || COREV_CLUSTER) << 23)  // X - Non-standard extensions present\n  | (32'(MXL) << 30);  // M-XLEN\n\n  // This local parameter when set to 1 makes the Perf Counters not compliant with RISC-V\n  // as it does not implement mcycle and minstret\n  // but only HPMCOUNTERs (depending on NUM_MHPMCOUNTERS)\n  localparam PULP_PERF_COUNTERS = 0;\n\n  typedef struct packed {\n    logic [MAX_N_PMP_ENTRIES-1:0][31:0] pmpaddr;\n    logic [MAX_N_PMP_CFG-1:0][31:0] pmpcfg_packed;\n    logic [MAX_N_PMP_ENTRIES-1:0][7:0] pmpcfg;\n  } Pmp_t;\n\n  // CSR update logic\n  logic [31:0] csr_wdata_int;\n  logic [31:0] csr_rdata_int;\n  logic        csr_we_int;\n\n  // FPU \n  logic [C_RM-1:0] frm_q, frm_n;\n  logic [C_FFLAG-1:0] fflags_q, fflags_n;\n  logic fcsr_update;\n\n  // Interrupt control signals\n  logic [31:0] mepc_q, mepc_n;\n  logic [31:0] uepc_q, uepc_n;\n  // Trigger\n  logic [31:0] tmatch_control_rdata;\n  logic [31:0] tmatch_value_rdata;\n  logic [15:0] tinfo_types;\n  // Debug\n  Dcsr_t dcsr_q, dcsr_n;\n  logic [31:0] depc_q, depc_n;\n  logic [31:0] dscratch0_q, dscratch0_n;\n  logic [31:0] dscratch1_q, dscratch1_n;\n  logic [31:0] mscratch_q, mscratch_n;\n\n  logic [31:0] exception_pc;\n  Status_t mstatus_q, mstatus_n;\n  logic mstatus_we_int;\n  FS_t mstatus_fs_q, mstatus_fs_n;\n  logic [5:0] mcause_q, mcause_n;\n  logic [5:0] ucause_q, ucause_n;\n  logic [23:0] mtvec_n, mtvec_q;\n  logic [23:0] utvec_n, utvec_q;\n  logic [1:0] mtvec_mode_n, mtvec_mode_q;\n  logic [1:0] utvec_mode_n, utvec_mode_q;\n\n  logic [31:0] mip;  // Bits are masked according to IRQ_MASK\n  logic [31:0] mie_q, mie_n;  // Bits are masked according to IRQ_MASK\n\n  logic [31:0] csr_mie_wdata;\n  logic        csr_mie_we;\n\n  logic        is_irq;\n  PrivLvl_t priv_lvl_n, priv_lvl_q;\n  Pmp_t pmp_reg_q, pmp_reg_n;\n  //clock gating for pmp regs\n  logic [MAX_N_PMP_ENTRIES-1:0]                        pmpaddr_we;\n  logic [MAX_N_PMP_ENTRIES-1:0]                        pmpcfg_we;\n\n  // Performance Counter Signals\n  logic [                 31:0][MHPMCOUNTER_WIDTH-1:0] mhpmcounter_q;  // performance counters\n  logic [31:0][31:0] mhpmevent_q, mhpmevent_n;  // event enable\n  logic [31:0] mcounteren_q, mcounteren_n;  // user mode counter enable\n  logic [31:0] mcountinhibit_q, mcountinhibit_n;  // performance counter enable\n  logic [NUM_HPM_EVENTS-1:0] hpm_events;  // events for performance counters\n  logic [31:0][MHPMCOUNTER_WIDTH-1:0] mhpmcounter_increment;  // increment of mhpmcounter_q\n  logic [31:0] mhpmcounter_write_lower;  // write 32 lower bits of mhpmcounter_q\n  logic [31:0] mhpmcounter_write_upper;  // write 32 upper bits mhpmcounter_q\n  logic [31:0] mhpmcounter_write_increment;  // write increment of mhpmcounter_q\n\n  assign is_irq = csr_cause_i[5];\n\n  // mip CSR\n  assign mip = mip_i;\n\n  // mie_n is used instead of mie_q such that a CSR write to the MIE register can\n  // affect the instruction immediately following it.\n\n  // MIE CSR operation logic\n  always_comb begin\n    csr_mie_wdata = csr_wdata_i;\n    csr_mie_we    = 1'b1;\n\n    case (csr_op_i)\n      CSR_OP_WRITE: csr_mie_wdata = csr_wdata_i;\n      CSR_OP_SET:   csr_mie_wdata = csr_wdata_i | mie_q;\n      CSR_OP_CLEAR: csr_mie_wdata = (~csr_wdata_i) & mie_q;\n      CSR_OP_READ: begin\n        csr_mie_wdata = csr_wdata_i;\n        csr_mie_we    = 1'b0;\n      end\n    endcase\n  end\n\n  assign mie_bypass_o = ((csr_addr_i == CSR_MIE) && csr_mie_we) ? csr_mie_wdata & IRQ_MASK : mie_q;\n\n  ////////////////////////////////////////////\n  //   ____ ____  ____    ____              //\n  //  / ___/ ___||  _ \\  |  _ \\ ___  __ _   //\n  // | |   \\___ \\| |_) | | |_) / _ \\/ _` |  //\n  // | |___ ___) |  _ <  |  _ <  __/ (_| |  //\n  //  \\____|____/|_| \\_\\ |_| \\_\\___|\\__, |  //\n  //                                |___/   //\n  ////////////////////////////////////////////\n\n  // NOTE!!!: Any new CSR register added in this file must also be\n  //   added to the valid CSR register list cv32e40p_decoder.v\n\n  genvar j;\n\n\n  if (PULP_SECURE == 1) begin : gen_pulp_secure_read_logic\n    // read logic\n    always_comb begin\n      case (csr_addr_i)\n        // fcsr: Floating-Point Control and Status Register (frm + fflags).\n        CSR_FFLAGS: csr_rdata_int = (FPU == 1) ? {27'b0, fflags_q} : '0;\n        CSR_FRM:    csr_rdata_int = (FPU == 1) ? {29'b0, frm_q} : '0;\n        CSR_FCSR:   csr_rdata_int = (FPU == 1) ? {24'b0, frm_q, fflags_q} : '0;\n\n        // mstatus\n        CSR_MSTATUS:\n        csr_rdata_int = {\n          14'b0,\n          mstatus_q.mprv,\n          4'b0,\n          mstatus_q.mpp,\n          3'b0,\n          mstatus_q.mpie,\n          2'h0,\n          mstatus_q.upie,\n          mstatus_q.mie,\n          2'h0,\n          mstatus_q.uie\n        };\n\n        // misa: machine isa register\n        CSR_MISA: csr_rdata_int = MISA_VALUE;\n\n        // mie: machine interrupt enable\n        CSR_MIE: begin\n          csr_rdata_int = mie_q;\n        end\n\n        // mtvec: machine trap-handler base address\n        CSR_MTVEC: csr_rdata_int = {mtvec_q, 6'h0, mtvec_mode_q};\n        // mscratch: machine scratch\n        CSR_MSCRATCH: csr_rdata_int = mscratch_q;\n        // mepc: exception program counter\n        CSR_MEPC: csr_rdata_int = mepc_q;\n        // mcause: exception cause\n        CSR_MCAUSE: csr_rdata_int = {mcause_q[5], 26'b0, mcause_q[4:0]};\n        // mip: interrupt pending\n        CSR_MIP: begin\n          csr_rdata_int = mip;\n        end\n\n        // mhartid: unique hardware thread id\n        CSR_MHARTID: csr_rdata_int = hart_id_i;\n\n        // mvendorid: Machine Vendor ID\n        CSR_MVENDORID: csr_rdata_int = {MVENDORID_BANK, MVENDORID_OFFSET};\n\n        // marchid: Machine Architecture ID\n        CSR_MARCHID: csr_rdata_int = MARCHID;\n\n        // unimplemented, read 0 CSRs\n        CSR_MIMPID, CSR_MTVAL: csr_rdata_int = 'b0;\n\n        // mcounteren: Machine Counter-Enable\n        CSR_MCOUNTEREN: csr_rdata_int = mcounteren_q;\n\n        CSR_TSELECT, CSR_TDATA3, CSR_MCONTEXT, CSR_SCONTEXT: csr_rdata_int = 'b0;  // Always read 0\n        CSR_TDATA1: csr_rdata_int = tmatch_control_rdata;\n        CSR_TDATA2: csr_rdata_int = tmatch_value_rdata;\n        CSR_TINFO: csr_rdata_int = tinfo_types;\n\n        CSR_DCSR: csr_rdata_int = dcsr_q;  //\n        CSR_DPC: csr_rdata_int = depc_q;\n        CSR_DSCRATCH0: csr_rdata_int = dscratch0_q;  //\n        CSR_DSCRATCH1: csr_rdata_int = dscratch1_q;  //\n\n        // Hardware Performance Monitor\n        CSR_MCYCLE,\n      CSR_MINSTRET,\n      CSR_MHPMCOUNTER3,\n      CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,\n      CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,\n      CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,\n      CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,\n      CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,\n      CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,\n      CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31,\n      CSR_CYCLE,\n      CSR_INSTRET,\n      CSR_HPMCOUNTER3,\n      CSR_HPMCOUNTER4,  CSR_HPMCOUNTER5,  CSR_HPMCOUNTER6,  CSR_HPMCOUNTER7,\n      CSR_HPMCOUNTER8,  CSR_HPMCOUNTER9,  CSR_HPMCOUNTER10, CSR_HPMCOUNTER11,\n      CSR_HPMCOUNTER12, CSR_HPMCOUNTER13, CSR_HPMCOUNTER14, CSR_HPMCOUNTER15,\n      CSR_HPMCOUNTER16, CSR_HPMCOUNTER17, CSR_HPMCOUNTER18, CSR_HPMCOUNTER19,\n      CSR_HPMCOUNTER20, CSR_HPMCOUNTER21, CSR_HPMCOUNTER22, CSR_HPMCOUNTER23,\n      CSR_HPMCOUNTER24, CSR_HPMCOUNTER25, CSR_HPMCOUNTER26, CSR_HPMCOUNTER27,\n      CSR_HPMCOUNTER28, CSR_HPMCOUNTER29, CSR_HPMCOUNTER30, CSR_HPMCOUNTER31:\n        csr_rdata_int = mhpmcounter_q[csr_addr_i[4:0]][31:0];\n\n        CSR_MCYCLEH,\n      CSR_MINSTRETH,\n      CSR_MHPMCOUNTER3H,\n      CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,\n      CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,\n      CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,\n      CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,\n      CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,\n      CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,\n      CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H,\n      CSR_CYCLEH,\n      CSR_INSTRETH,\n      CSR_HPMCOUNTER3H,\n      CSR_HPMCOUNTER4H,  CSR_HPMCOUNTER5H,  CSR_HPMCOUNTER6H,  CSR_HPMCOUNTER7H,\n      CSR_HPMCOUNTER8H,  CSR_HPMCOUNTER9H,  CSR_HPMCOUNTER10H, CSR_HPMCOUNTER11H,\n      CSR_HPMCOUNTER12H, CSR_HPMCOUNTER13H, CSR_HPMCOUNTER14H, CSR_HPMCOUNTER15H,\n      CSR_HPMCOUNTER16H, CSR_HPMCOUNTER17H, CSR_HPMCOUNTER18H, CSR_HPMCOUNTER19H,\n      CSR_HPMCOUNTER20H, CSR_HPMCOUNTER21H, CSR_HPMCOUNTER22H, CSR_HPMCOUNTER23H,\n      CSR_HPMCOUNTER24H, CSR_HPMCOUNTER25H, CSR_HPMCOUNTER26H, CSR_HPMCOUNTER27H,\n      CSR_HPMCOUNTER28H, CSR_HPMCOUNTER29H, CSR_HPMCOUNTER30H, CSR_HPMCOUNTER31H:\n        csr_rdata_int = mhpmcounter_q[csr_addr_i[4:0]][63:32];\n\n        CSR_MCOUNTINHIBIT: csr_rdata_int = mcountinhibit_q;\n\n        CSR_MHPMEVENT3,\n      CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,\n      CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,\n      CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,\n      CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,\n      CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,\n      CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,\n      CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31:\n        csr_rdata_int = mhpmevent_q[csr_addr_i[4:0]];\n\n        // hardware loops  (not official)\n        CSR_LPSTART0: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_start_i[0];\n        CSR_LPEND0:   csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_end_i[0];\n        CSR_LPCOUNT0: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_cnt_i[0];\n        CSR_LPSTART1: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_start_i[1];\n        CSR_LPEND1:   csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_end_i[1];\n        CSR_LPCOUNT1: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_cnt_i[1];\n\n        // PMP config registers\n        CSR_PMPCFG0: csr_rdata_int = USE_PMP ? pmp_reg_q.pmpcfg_packed[0] : '0;\n        CSR_PMPCFG1: csr_rdata_int = USE_PMP ? pmp_reg_q.pmpcfg_packed[1] : '0;\n        CSR_PMPCFG2: csr_rdata_int = USE_PMP ? pmp_reg_q.pmpcfg_packed[2] : '0;\n        CSR_PMPCFG3: csr_rdata_int = USE_PMP ? pmp_reg_q.pmpcfg_packed[3] : '0;\n\n        CSR_PMPADDR0, CSR_PMPADDR1, CSR_PMPADDR2, CSR_PMPADDR3,\n      CSR_PMPADDR4, CSR_PMPADDR5, CSR_PMPADDR6, CSR_PMPADDR7,\n      CSR_PMPADDR8, CSR_PMPADDR9, CSR_PMPADDR10, CSR_PMPADDR11,\n      CSR_PMPADDR12, CSR_PMPADDR13, CSR_PMPADDR14, CSR_PMPADDR15 :\n        csr_rdata_int = USE_PMP ? pmp_reg_q.pmpaddr[csr_addr_i[3:0]] : '0;\n\n        /* USER CSR */\n        // ustatus\n        CSR_USTATUS: csr_rdata_int = {27'b0, mstatus_q.upie, 3'h0, mstatus_q.uie};\n        // utvec: user trap-handler base address\n        CSR_UTVEC: csr_rdata_int = {utvec_q, 6'h0, utvec_mode_q};\n        // duplicated mhartid: unique hardware thread id (not official)\n        CSR_UHARTID: csr_rdata_int = !COREV_PULP ? 'b0 : hart_id_i;\n        // uepc: exception program counter\n        CSR_UEPC: csr_rdata_int = uepc_q;\n        // ucause: exception cause\n        CSR_UCAUSE: csr_rdata_int = {ucause_q[5], 26'h0, ucause_q[4:0]};\n\n        // current priv level (not official)\n        CSR_PRIVLV: csr_rdata_int = !COREV_PULP ? 'b0 : {30'h0, priv_lvl_q};\n\n        default: csr_rdata_int = '0;\n      endcase\n    end\n  end else begin : gen_no_pulp_secure_read_logic  // PULP_SECURE == 0\n    // read logic\n    always_comb begin\n\n      case (csr_addr_i)\n        // fcsr: Floating-Point Control and Status Register (frm + fflags).\n        CSR_FFLAGS: csr_rdata_int = (FPU == 1) ? {27'b0, fflags_q} : '0;\n        CSR_FRM: csr_rdata_int = (FPU == 1) ? {29'b0, frm_q} : '0;\n        CSR_FCSR: csr_rdata_int = (FPU == 1) ? {24'b0, frm_q, fflags_q} : '0;\n        // mstatus: always M-mode, contains IE bit\n        CSR_MSTATUS:\n        csr_rdata_int = {\n          (FPU == 1 && ZFINX == 0) ? (mstatus_fs_q == FS_DIRTY ? 1'b1 : 1'b0) : 1'b0,\n          13'b0,\n          mstatus_q.mprv,\n          2'b0,\n          (FPU == 1 && ZFINX == 0) ? mstatus_fs_q : FS_OFF,\n          mstatus_q.mpp,\n          3'b0,\n          mstatus_q.mpie,\n          2'h0,\n          mstatus_q.upie,\n          mstatus_q.mie,\n          2'h0,\n          mstatus_q.uie\n        };\n        // misa: machine isa register\n        CSR_MISA: csr_rdata_int = MISA_VALUE;\n        // mie: machine interrupt enable\n        CSR_MIE: begin\n          csr_rdata_int = mie_q;\n        end\n\n        // mtvec: machine trap-handler base address\n        CSR_MTVEC: csr_rdata_int = {mtvec_q, 6'h0, mtvec_mode_q};\n        // mscratch: machine scratch\n        CSR_MSCRATCH: csr_rdata_int = mscratch_q;\n        /"}
{"text": "/ mepc: exception program counter\n        CSR_MEPC: csr_rdata_int = mepc_q;\n        // mcause: exception cause\n        CSR_MCAUSE: csr_rdata_int = {mcause_q[5], 26'b0, mcause_q[4:0]};\n        // mip: interrupt pending\n        CSR_MIP: begin\n          csr_rdata_int = mip;\n        end\n        // mhartid: unique hardware thread id\n        CSR_MHARTID: csr_rdata_int = hart_id_i;\n\n        // mvendorid: Machine Vendor ID\n        CSR_MVENDORID: csr_rdata_int = {MVENDORID_BANK, MVENDORID_OFFSET};\n\n        // marchid: Machine Architecture ID\n        CSR_MARCHID: csr_rdata_int = MARCHID;\n\n        // mimpid, Machine Implementation ID\n        CSR_MIMPID: begin\n          csr_rdata_int = (FPU || COREV_PULP || COREV_CLUSTER) ? 32'h1 : 'b0;\n        end\n\n        // unimplemented, read 0 CSRs\n        CSR_MTVAL: csr_rdata_int = 'b0;\n\n        CSR_TSELECT, CSR_TDATA3, CSR_MCONTEXT, CSR_SCONTEXT: csr_rdata_int = 'b0;  // Always read 0\n        CSR_TDATA1: csr_rdata_int = tmatch_control_rdata;\n        CSR_TDATA2: csr_rdata_int = tmatch_value_rdata;\n        CSR_TINFO: csr_rdata_int = tinfo_types;\n\n        CSR_DCSR: csr_rdata_int = dcsr_q;  //\n        CSR_DPC: csr_rdata_int = depc_q;\n        CSR_DSCRATCH0: csr_rdata_int = dscratch0_q;  //\n        CSR_DSCRATCH1: csr_rdata_int = dscratch1_q;  //\n\n        // Hardware Performance Monitor\n        CSR_MCYCLE,\n      CSR_MINSTRET,\n      CSR_MHPMCOUNTER3,\n      CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,\n      CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,\n      CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,\n      CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,\n      CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,\n      CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,\n      CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31,\n      CSR_CYCLE,\n      CSR_INSTRET,\n      CSR_HPMCOUNTER3,\n      CSR_HPMCOUNTER4,  CSR_HPMCOUNTER5,  CSR_HPMCOUNTER6,  CSR_HPMCOUNTER7,\n      CSR_HPMCOUNTER8,  CSR_HPMCOUNTER9,  CSR_HPMCOUNTER10, CSR_HPMCOUNTER11,\n      CSR_HPMCOUNTER12, CSR_HPMCOUNTER13, CSR_HPMCOUNTER14, CSR_HPMCOUNTER15,\n      CSR_HPMCOUNTER16, CSR_HPMCOUNTER17, CSR_HPMCOUNTER18, CSR_HPMCOUNTER19,\n      CSR_HPMCOUNTER20, CSR_HPMCOUNTER21, CSR_HPMCOUNTER22, CSR_HPMCOUNTER23,\n      CSR_HPMCOUNTER24, CSR_HPMCOUNTER25, CSR_HPMCOUNTER26, CSR_HPMCOUNTER27,\n      CSR_HPMCOUNTER28, CSR_HPMCOUNTER29, CSR_HPMCOUNTER30, CSR_HPMCOUNTER31:\n        csr_rdata_int = mhpmcounter_q[csr_addr_i[4:0]][31:0];\n\n        CSR_MCYCLEH,\n      CSR_MINSTRETH,\n      CSR_MHPMCOUNTER3H,\n      CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,\n      CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,\n      CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,\n      CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,\n      CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,\n      CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,\n      CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H,\n      CSR_CYCLEH,\n      CSR_INSTRETH,\n      CSR_HPMCOUNTER3H,\n      CSR_HPMCOUNTER4H,  CSR_HPMCOUNTER5H,  CSR_HPMCOUNTER6H,  CSR_HPMCOUNTER7H,\n      CSR_HPMCOUNTER8H,  CSR_HPMCOUNTER9H,  CSR_HPMCOUNTER10H, CSR_HPMCOUNTER11H,\n      CSR_HPMCOUNTER12H, CSR_HPMCOUNTER13H, CSR_HPMCOUNTER14H, CSR_HPMCOUNTER15H,\n      CSR_HPMCOUNTER16H, CSR_HPMCOUNTER17H, CSR_HPMCOUNTER18H, CSR_HPMCOUNTER19H,\n      CSR_HPMCOUNTER20H, CSR_HPMCOUNTER21H, CSR_HPMCOUNTER22H, CSR_HPMCOUNTER23H,\n      CSR_HPMCOUNTER24H, CSR_HPMCOUNTER25H, CSR_HPMCOUNTER26H, CSR_HPMCOUNTER27H,\n      CSR_HPMCOUNTER28H, CSR_HPMCOUNTER29H, CSR_HPMCOUNTER30H, CSR_HPMCOUNTER31H:\n        csr_rdata_int = (MHPMCOUNTER_WIDTH == 64) ? mhpmcounter_q[csr_addr_i[4:0]][63:32] : '0;\n\n        CSR_MCOUNTINHIBIT: csr_rdata_int = mcountinhibit_q;\n\n        CSR_MHPMEVENT3,\n      CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,\n      CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,\n      CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,\n      CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,\n      CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,\n      CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,\n      CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31:\n        csr_rdata_int = mhpmevent_q[csr_addr_i[4:0]];\n\n        // hardware loops  (not official)\n        CSR_LPSTART0: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_start_i[0];\n        CSR_LPEND0:   csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_end_i[0];\n        CSR_LPCOUNT0: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_cnt_i[0];\n        CSR_LPSTART1: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_start_i[1];\n        CSR_LPEND1:   csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_end_i[1];\n        CSR_LPCOUNT1: csr_rdata_int = !COREV_PULP ? 'b0 : hwlp_cnt_i[1];\n\n        /* USER CSR */\n        // dublicated mhartid: unique hardware thread id (not official)\n        CSR_UHARTID: csr_rdata_int = !COREV_PULP ? 'b0 : hart_id_i;\n        // current priv level (not official)\n        CSR_PRIVLV: csr_rdata_int = !COREV_PULP ? 'b0 : {30'h0, priv_lvl_q};\n        // Zfinx (not official)\n        CSR_ZFINX: csr_rdata_int = (FPU == 1 && ZFINX == 1) ? 32'h1 : 32'h0;\n        default: csr_rdata_int = '0;\n      endcase\n    end\n  end  //PULP_SECURE\n\n  if (PULP_SECURE == 1) begin : gen_pulp_secure_write_logic\n    // write logic\n    always_comb begin\n      fflags_n                = fflags_q;\n      frm_n                   = frm_q;\n      mscratch_n              = mscratch_q;\n      mepc_n                  = mepc_q;\n      uepc_n                  = uepc_q;\n      depc_n                  = depc_q;\n      dcsr_n                  = dcsr_q;\n      dscratch0_n             = dscratch0_q;\n      dscratch1_n             = dscratch1_q;\n\n      mstatus_n               = mstatus_q;\n      mcause_n                = mcause_q;\n      ucause_n                = ucause_q;\n      exception_pc            = pc_id_i;\n      priv_lvl_n              = priv_lvl_q;\n      mtvec_n                 = csr_mtvec_init_i ? mtvec_addr_i[31:8] : mtvec_q;\n      utvec_n                 = utvec_q;\n      mtvec_mode_n            = mtvec_mode_q;\n      utvec_mode_n            = utvec_mode_q;\n      pmp_reg_n.pmpaddr       = pmp_reg_q.pmpaddr;\n      pmp_reg_n.pmpcfg_packed = pmp_reg_q.pmpcfg_packed;\n      pmpaddr_we              = '0;\n      pmpcfg_we               = '0;\n\n      mie_n                   = mie_q;\n\n      if (FPU == 1) if (fflags_we_i) fflags_n = fflags_i | fflags_q;\n\n      case (csr_addr_i)\n        // fcsr: Floating-Point Control and Status Register (frm, fflags, fprec).\n        CSR_FFLAGS: if (csr_we_int) fflags_n = (FPU == 1) ? csr_wdata_int[C_FFLAG-1:0] : '0;\n        CSR_FRM:    if (csr_we_int) frm_n = (FPU == 1) ? csr_wdata_int[C_RM-1:0] : '0;\n        CSR_FCSR:\n        if (csr_we_int) begin\n          fflags_n = (FPU == 1) ? csr_wdata_int[C_FFLAG-1:0] : '0;\n          frm_n    = (FPU == 1) ? csr_wdata_int[C_RM+C_FFLAG-1:C_FFLAG] : '0;\n        end\n\n        // mstatus: IE bit\n        CSR_MSTATUS:\n        if (csr_we_int) begin\n          mstatus_n = '{\n              uie: csr_wdata_int[MSTATUS_UIE_BIT],\n              mie: csr_wdata_int[MSTATUS_MIE_BIT],\n              upie: csr_wdata_int[MSTATUS_UPIE_BIT],\n              mpie: csr_wdata_int[MSTATUS_MPIE_BIT],\n              mpp: PrivLvl_t'(csr_wdata_int[MSTATUS_MPP_BIT_HIGH:MSTATUS_MPP_BIT_LOW]),\n              mprv: csr_wdata_int[MSTATUS_MPRV_BIT]\n          };\n        end\n        // mie: machine interrupt enable\n        CSR_MIE:\n        if (csr_we_int) begin\n          mie_n = csr_wdata_int & IRQ_MASK;\n        end\n        // mtvec: machine trap-handler base address\n        CSR_MTVEC:\n        if (csr_we_int) begin\n          mtvec_n      = csr_wdata_int[31:8];\n          mtvec_mode_n = {1'b0, csr_wdata_int[0]};  // Only direct and vectored mode are supported\n        end\n        // mscratch: machine scratch\n        CSR_MSCRATCH:\n        if (csr_we_int) begin\n          mscratch_n = csr_wdata_int;\n        end\n        // mepc: exception program counter\n        CSR_MEPC:\n        if (csr_we_int) begin\n          mepc_n = csr_wdata_int & ~32'b1;  // force 16-bit alignment\n        end\n        // mcause\n        CSR_MCAUSE: if (csr_we_int) mcause_n = {csr_wdata_int[31], csr_wdata_int[4:0]};\n\n        // Debug\n        CSR_DCSR:\n        if (csr_we_int) begin\n          // Following are read-only and never assigned here (dcsr_q value is used):\n          //\n          // - xdebugver\n          // - cause\n          // - nmip\n\n          dcsr_n.ebreakm = csr_wdata_int[15];\n          dcsr_n.ebreaks = 1'b0;  // ebreaks (implemented as WARL)\n          dcsr_n.ebreaku = csr_wdata_int[12];\n          dcsr_n.stepie = csr_wdata_int[11];  // stepie\n          dcsr_n.stopcount = 1'b0;  // stopcount\n          dcsr_n.stoptime = 1'b0;  // stoptime\n          dcsr_n.mprven = 1'b0;  // mprven\n          dcsr_n.step = csr_wdata_int[2];\n          dcsr_n.prv       = (PrivLvl_t'(csr_wdata_int[1:0]) == PRIV_LVL_M) ? PRIV_LVL_M : PRIV_LVL_U; // prv (implemented as WARL)\n        end\n\n        CSR_DPC:\n        if (csr_we_int) begin\n          depc_n = csr_wdata_int & ~32'b1;  // force 16-bit alignment\n        end\n\n        CSR_DSCRATCH0:\n        if (csr_we_int) begin\n          dscratch0_n = csr_wdata_int;\n        end\n\n        CSR_DSCRATCH1:\n        if (csr_we_int) begin\n          dscratch1_n = csr_wdata_int;\n        end\n\n        // PMP config registers\n        CSR_PMPCFG0:\n        if (csr_we_int) begin\n          pmp_reg_n.pmpcfg_packed[0] = csr_wdata_int;\n          pmpcfg_we[3:0] = 4'b1111;\n        end\n        CSR_PMPCFG1:\n        if (csr_we_int) begin\n          pmp_reg_n.pmpcfg_packed[1] = csr_wdata_int;\n          pmpcfg_we[7:4] = 4'b1111;\n        end\n        CSR_PMPCFG2:\n        if (csr_we_int) begin\n          pmp_reg_n.pmpcfg_packed[2] = csr_wdata_int;\n          pmpcfg_we[11:8] = 4'b1111;\n        end\n        CSR_PMPCFG3:\n        if (csr_we_int) begin\n          pmp_reg_n.pmpcfg_packed[3] = csr_wdata_int;\n          pmpcfg_we[15:12] = 4'b1111;\n        end\n\n        CSR_PMPADDR0, CSR_PMPADDR1, CSR_PMPADDR2, CSR_PMPADDR3,\n      CSR_PMPADDR4, CSR_PMPADDR5, CSR_PMPADDR6, CSR_PMPADDR7,\n      CSR_PMPADDR8, CSR_PMPADDR9, CSR_PMPADDR10, CSR_PMPADDR11,\n      CSR_PMPADDR12, CSR_PMPADDR13, CSR_PMPADDR14, CSR_PMPADDR15 :\n        if (csr_we_int) begin\n          pmp_reg_n.pmpaddr[csr_addr_i[3:0]] = csr_wdata_int;\n          pmpaddr_we[csr_addr_i[3:0]] = 1'b1;\n        end\n\n\n        /* USER CSR */\n        // ucause: exception cause\n        CSR_USTATUS:\n        if (csr_we_int) begin\n          mstatus_n = '{\n              uie: csr_wdata_int[MSTATUS_UIE_BIT],\n              mie: mstatus_q.mie,\n              upie: csr_wdata_int[MSTATUS_UPIE_BIT],\n              mpie: mstatus_q.mpie,\n              mpp: mstatus_q.mpp,\n              mprv: mstatus_q.mprv\n          };\n        end\n        // utvec: user trap-handler base address\n        CSR_UTVEC:\n        if (csr_we_int) begin\n          utvec_n      = csr_wdata_int[31:8];\n          utvec_mode_n = {1'b0, csr_wdata_int[0]};  // Only direct and vectored mode are supported\n        end\n        // uepc: exception program counter\n        CSR_UEPC:\n        if (csr_we_int) begin\n          uepc_n = csr_wdata_int;\n        end\n        // ucause: exception cause\n        CSR_UCAUSE: if (csr_we_int) ucause_n = {csr_wdata_int[31], csr_wdata_int[4:0]};\n      endcase\n\n      // exception controller gets priority over other writes\n      unique case (1'b1)\n\n        csr_save_cause_i: begin\n\n          unique case (1'b1)\n            csr_save_if_i: exception_pc = pc_if_i;\n            csr_save_id_i: exception_pc = pc_id_i;\n            csr_save_ex_i: exception_pc = pc_ex_i;\n            default: ;\n          endcase\n\n          unique case (priv_lvl_q)\n\n            PRIV_LVL_U: begin\n              if (~is_irq) begin\n                //Exceptions, Ecall U --> M\n                priv_lvl_n     = PRIV_LVL_M;\n                mstatus_n.mpie = mstatus_q.uie;\n                mstatus_n.mie  = 1'b0;\n                mstatus_n.mpp  = PRIV_LVL_U;\n                if (debug_csr_save_i) depc_n = exception_pc;\n                else mepc_n = exception_pc;\n                mcause_n = csr_cause_i;\n\n              end else begin\n                if (~csr_irq_sec_i) begin\n                  //U --> U\n                  priv_lvl_n     = PRIV_LVL_U;\n                  mstatus_n.upie = mstatus_q.uie;\n                  mstatus_n.uie  = 1'b0;\n                  if (debug_csr_save_i) depc_n = exception_pc;\n                  else uepc_n = exception_pc;\n                  ucause_n = csr_cause_i;\n\n                end else begin\n                  //U --> M\n                  priv_lvl_n     = PRIV_LVL_M;\n                  mstatus_n.mpie = mstatus_q.uie;\n                  mstatus_n.mie  = 1'b0;\n                  mstatus_n.mpp  = PRIV_LVL_U;\n                  if (debug_csr_save_i) depc_n = exception_pc;\n                  else mepc_n = exception_pc;\n                  mcause_n = csr_cause_i;\n                end\n              end\n            end  //PRIV_LVL_U\n\n            PRIV_LVL_M: begin\n              if (debug_csr_save_i) begin\n                // all interrupts are masked, don't update cause, epc, tval dpc\n                // and mpstatus\n                dcsr_n.prv   = PRIV_LVL_M;\n                dcsr_n.cause = debug_cause_i;\n                depc_n       = exception_pc;\n              end else begin\n                //Exceptions or Interrupts from PRIV_LVL_M always do M --> M\n                priv_lvl_n     = PRIV_LVL_M;\n                mstatus_n.mpie = mstatus_q.mie;\n                mstatus_n.mie  = 1'b0;\n                mstatus_n.mpp  = PRIV_LVL_M;\n                mepc_n         = exception_pc;\n                mcause_n       = csr_cause_i;\n              end\n            end  //PRIV_LVL_M\n            default: ;\n\n          endcase\n\n        end  //csr_save_cause_i\n\n        csr_restore_uret_i: begin  //URET\n          //mstatus_q.upp is implicitly 0, i.e PRIV_LVL_U\n          mstatus_n.uie  = mstatus_q.upie;\n          priv_lvl_n     = PRIV_LVL_U;\n          mstatus_n.upie = 1'b1;\n        end  //csr_restore_uret_i\n\n        csr_restore_mret_i: begin  //MRET\n          unique case (mstatus_q.mpp)\n            PRIV_LVL_U: begin\n              mstatus_n.uie  = mstatus_q.mpie;\n              priv_lvl_n     = PRIV_LVL_U;\n              mstatus_n.mpie = 1'b1;\n              mstatus_n.mpp  = PRIV_LVL_U;\n            end\n            PRIV_LVL_M: begin\n              mstatus_n.mie  = mstatus_q.mpie;\n              priv_lvl_n     = PRIV_LVL_M;\n              mstatus_n.mpie = 1'b1;\n              mstatus_n.mpp  = PRIV_LVL_U;\n            end\n            default: ;\n          endcase\n        end  //csr_restore_mret_i\n\n\n        csr_restore_dret_i: begin  //DRET\n          // Restore to the recorded privilege level\n          priv_lvl_n = dcsr_q.prv;\n\n        end  //csr_restore_dret_i\n\n        default: ;\n      endcase\n    end\n  end else begin : gen_no_pulp_secure_write_logic  //PULP_SECURE == 0\n    // write logic\n    always_comb begin\n      if (FPU == 1) begin\n        fflags_n = fflags_q;\n        frm_n = frm_q;\n        if (ZFINX == 0) begin\n          mstatus_fs_n = mstatus_fs_q;\n          fcsr_update  = 1'b0;\n        end\n      end\n      mscratch_n = mscratch_q;\n      mepc_n = mepc_q;\n      uepc_n = 'b0;  // Not used if PULP_SECURE == 0\n      depc_n = depc_q;\n      dcsr_n = dcsr_q;\n      dscratch0_n = dscratch0_q;\n      dscratch1_n = dscratch1_q;\n\n      mstatus_we_int = 1'b0;\n      mstatus_n = mstatus_q;\n      mcause_n = mcause_q;\n      ucause_n = '0;  // Not used if PULP_SECURE == 0\n      exception_pc = pc_id_i;\n      priv_lvl_n = priv_lvl_q;\n      mtvec_n = csr_mtvec_init_i ? mtvec_addr_i[31:8] : mtvec_q;\n      utvec_n = '0;  // Not used if PULP_SECURE == 0\n      pmp_reg_n.pmpaddr = '0;  // Not used if PULP_SECURE == 0\n      pmp_reg_n.pmpcfg_packed = '0;  // Not used if PULP_SECURE == 0\n      pmp_reg_n.pmpcfg = '0;  // Not used if PULP_SECURE == 0\n      pmpaddr_we = '0;\n      pmpcfg_we = '0;\n\n      mie_n = mie_q;\n      mtvec_mode_n = mtvec_mode_q;\n      utvec_mode_n = '0;  // Not used if PULP_SECURE == 0\n\n      case (csr_addr_i)\n        // fcsr: Floating-Point Control and Status Register (frm, fflags, fprec).\n        CSR_FFLAGS:\n        if (FPU == 1) begin\n          if (csr_we_int) begin\n            fflags_n = csr_wdata_int[C_FFLAG-1:0];\n            if (ZFINX == 0) begin\n              fcsr_update = 1'b1;\n            end\n          end\n        end\n        CSR_FRM:\n        if (FPU == 1) begin\n          if (csr_we_int) begin\n            frm_n = csr_wdata_int[C_RM-1:0];\n            if (ZFINX == 0) begin\n              fcsr_update = 1'b1;\n            end\n          end\n        end\n        CSR_FCSR:\n        if (FPU == 1) begin\n          if (csr_we_int) begin\n            fflags_n = csr_wdata_int[C_FFLAG-1:0];\n            frm_n    = csr_wdata_int[C_RM+C_FFLAG-1:C_FFLAG];\n            if (ZFINX == 0) begin\n              fcsr_update = 1'b1;\n            end\n          end\n        end\n\n        // mstatus\n        CSR_MSTATUS:\n        if (csr_we_int) begin\n          mstatus_n = '{\n              uie: csr_wdata_int[MSTATUS_UIE_BIT],\n              mie: csr_wdata_int[MSTATUS_MIE_BIT],\n              upie: csr_wdata_int[MSTATUS_UPIE_BIT],\n              mpie: csr_wdata_int[MSTATUS_MPIE_BIT],\n              mpp: PrivLvl_t'(csr_wdata_int[MSTATUS_MPP_BIT_HIGH:MSTATUS_MPP_BIT_LOW]),\n              mprv: csr_wdata_int[MSTATUS_MPRV_BIT]\n          };\n          if (FPU == 1 && ZFINX == 0) begin\n            mstatus_we_int = 1'b1;\n            mstatus_fs_n   = FS_t'(csr_wdata_int[MSTATUS_FS_BIT_HIGH:MSTATUS_FS_BIT_LOW]);\n          end\n        end\n        // mie: machine interrupt enable\n        CSR_MIE:\n        if (csr_we_int) begin\n          mie_n = csr_wdata_int & IRQ_MASK;\n        end\n        // mtvec: machine trap-handler base address\n        CSR_MTVEC:\n        if (csr_we_int) begin\n          mtvec_n      = csr_wdata_int[31:8];\n          mtvec_mode_n = {1'b0, csr_wdata_int[0]};  // Only direct and vectored mode are supported\n        end\n        // mscratch: machine scratch\n        CSR_MSCRATCH:\n        if (csr_we_int) begin\n          mscratch_n = csr_wdata_int;\n        end\n        // mepc: exception program counter\n        CSR_MEPC:\n        if (csr_we_int) begin\n          mepc_n = csr_wdata_int & ~32'b1;  // force 16-bit alignment\n        end\n        // mcause\n        CSR_MCAUSE: if (csr_we_int) mcause_n = {csr_wdata_int[31], csr_wdata_int[4:0]};\n\n        CSR_DCSR:\n        if (csr_we_int) begin\n          // Following are read-only and never assigned here (dcsr_q value is used):\n          //\n          // - xdebugver\n          // - cause\n          // - nmip\n\n          dcsr_n.ebreakm   = csr_wdata_int[15];\n          dcsr_n.ebreaks   = 1'b0;  // ebreaks (implemented as WARL)\n          dcsr_n.ebreaku   = 1'b0;  // ebreaku (implemented as WARL)\n          dcsr_n.stepie    = csr_wdata_int[11];  // stepie\n          dcsr_n.stopcount = 1'b0;  // stopcount\n          dcsr_n.stoptime  = 1'b0;  // stoptime\n          dcsr_n.mprven    = 1'b0;  // mprven\n          dcsr_n.step      = csr_wdata_int[2];\n          dcsr_n.prv       = PRIV_LVL_M;  // prv (implemendted as WARL)\n        end\n\n        CSR_DPC:\n        if (csr_we_int) begin\n          depc_n = csr_wdata_int & ~32'b1;  // force 16-bit alignment\n        end\n\n        CSR_DSCRATCH0:\n        if (csr_we_int) begin\n          dscratch0_n = csr_wdata_int;\n        end\n\n        CSR_DSCRATCH1:\n        if (csr_we_int) begin\n          dscratch1_n = csr_wdata_int;\n        end\n\n      endcase\n\n      if (FPU == 1) begin\n        if (fflags_we_i) begin\n          fflags_n = fflags_i | ffl"}
{"text": "ags_q;\n        end\n\n        if (ZFINX == 0) begin\n          // FPU Register File/Flags implicit update or modified by CSR instructions\n          if ((fregs_we_i && !(mstatus_we_int && mstatus_fs_n != FS_DIRTY)) || fflags_we_i || fcsr_update) begin\n            mstatus_fs_n = FS_DIRTY;\n          end\n        end\n      end\n\n      // exception controller gets priority over other writes\n      unique case (1'b1)\n\n        csr_save_cause_i: begin\n          unique case (1'b1)\n            csr_save_if_i: exception_pc = pc_if_i;\n            csr_save_id_i: exception_pc = pc_id_i;\n            csr_save_ex_i: exception_pc = pc_ex_i;\n            default: ;\n          endcase\n\n          if (debug_csr_save_i) begin\n            // all interrupts are masked, don't update cause, epc, tval dpc and\n            // mpstatus\n            dcsr_n.prv   = PRIV_LVL_M;\n            dcsr_n.cause = debug_cause_i;\n            depc_n       = exception_pc;\n          end else begin\n            priv_lvl_n     = PRIV_LVL_M;\n            mstatus_n.mpie = mstatus_q.mie;\n            mstatus_n.mie  = 1'b0;\n            mstatus_n.mpp  = PRIV_LVL_M;\n            mepc_n         = exception_pc;\n            mcause_n       = csr_cause_i;\n          end\n        end  //csr_save_cause_i\n\n        csr_restore_mret_i: begin  //MRET\n          mstatus_n.mie  = mstatus_q.mpie;\n          priv_lvl_n     = PRIV_LVL_M;\n          mstatus_n.mpie = 1'b1;\n          mstatus_n.mpp  = PRIV_LVL_M;\n        end  //csr_restore_mret_i\n\n        csr_restore_dret_i: begin  //DRET\n          // Restore to the recorded privilege level\n          priv_lvl_n = dcsr_q.prv;\n        end  //csr_restore_dret_i\n\n        default: ;\n      endcase\n    end\n  end  //PULP_SECURE\n\n  // CSR operation logic\n  always_comb begin\n    csr_wdata_int = csr_wdata_i;\n    csr_we_int    = 1'b1;\n\n    case (csr_op_i)\n      CSR_OP_WRITE: csr_wdata_int = csr_wdata_i;\n      CSR_OP_SET:   csr_wdata_int = csr_wdata_i | csr_rdata_o;\n      CSR_OP_CLEAR: csr_wdata_int = (~csr_wdata_i) & csr_rdata_o;\n\n      CSR_OP_READ: begin\n        csr_wdata_int = csr_wdata_i;\n        csr_we_int    = 1'b0;\n      end\n    endcase\n  end\n\n  assign csr_rdata_o = csr_rdata_int;\n\n  // directly output some registers\n  assign m_irq_enable_o = mstatus_q.mie && !(dcsr_q.step && !dcsr_q.stepie);\n  assign u_irq_enable_o = mstatus_q.uie && !(dcsr_q.step && !dcsr_q.stepie);\n  assign priv_lvl_o = priv_lvl_q;\n  assign sec_lvl_o = priv_lvl_q[0];\n\n  // mstatus_fs_q = FS_OFF, FPU not enabled\n  assign fs_off_o = (FPU == 1 && ZFINX == 0) ? (mstatus_fs_q == FS_OFF ? 1'b1 : 1'b0) : 1'b0;\n  assign frm_o = (FPU == 1) ? frm_q : '0;\n\n  assign mtvec_o = mtvec_q;\n  assign utvec_o = utvec_q;\n  assign mtvec_mode_o = mtvec_mode_q;\n  assign utvec_mode_o = utvec_mode_q;\n\n  assign mepc_o = mepc_q;\n  assign uepc_o = uepc_q;\n\n  assign mcounteren_o = PULP_SECURE ? mcounteren_q : '0;\n\n  assign depc_o = depc_q;\n\n  assign pmp_addr_o = pmp_reg_q.pmpaddr;\n  assign pmp_cfg_o = pmp_reg_q.pmpcfg;\n\n  assign debug_single_step_o = dcsr_q.step;\n  assign debug_ebreakm_o = dcsr_q.ebreakm;\n  assign debug_ebreaku_o = dcsr_q.ebreaku;\n\n  generate\n    if (PULP_SECURE == 1) begin : gen_pmp_user\n\n      for (j = 0; j < N_PMP_ENTRIES; j++) begin : CS_PMP_CFG\n        assign pmp_reg_n.pmpcfg[j] = pmp_reg_n.pmpcfg_packed[j/4][8*((j%4)+1)-1:8*(j%4)];\n        assign pmp_reg_q.pmpcfg_packed[j/4][8*((j%4)+1)-1:8*(j%4)] = pmp_reg_q.pmpcfg[j];\n      end\n\n      for (j = 0; j < N_PMP_ENTRIES; j++) begin : CS_PMP_REGS_FF\n        always_ff @(posedge clk, negedge rst_n) begin\n          if (rst_n == 1'b0) begin\n            pmp_reg_q.pmpcfg[j]  <= '0;\n            pmp_reg_q.pmpaddr[j] <= '0;\n          end else begin\n            if (pmpcfg_we[j]) pmp_reg_q.pmpcfg[j] <= USE_PMP ? pmp_reg_n.pmpcfg[j] : '0;\n            if (pmpaddr_we[j]) pmp_reg_q.pmpaddr[j] <= USE_PMP ? pmp_reg_n.pmpaddr[j] : '0;\n          end\n        end\n      end  //CS_PMP_REGS_FF\n\n      always_ff @(posedge clk, negedge rst_n) begin\n        if (rst_n == 1'b0) begin\n          uepc_q       <= '0;\n          ucause_q     <= '0;\n          utvec_q      <= '0;\n          utvec_mode_q <= MTVEC_MODE;\n          priv_lvl_q   <= PRIV_LVL_M;\n        end else begin\n          uepc_q       <= uepc_n;\n          ucause_q     <= ucause_n;\n          utvec_q      <= utvec_n;\n          utvec_mode_q <= utvec_mode_n;\n          priv_lvl_q   <= priv_lvl_n;\n        end\n      end\n    end else begin : gen_no_pmp_user\n      assign pmp_reg_q    = '0;\n      assign uepc_q       = '0;\n      assign ucause_q     = '0;\n      assign utvec_q      = '0;\n      assign utvec_mode_q = '0;\n      assign priv_lvl_q   = PRIV_LVL_M;\n    end\n  endgenerate\n\n  // actual registers\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      if (FPU == 1) begin\n        frm_q <= '0;\n        fflags_q <= '0;\n        if (ZFINX == 0) begin\n          mstatus_fs_q <= FS_OFF;\n        end\n      end\n      mstatus_q <= '{\n          uie: 1'b0,\n          mie: 1'b0,\n          upie: 1'b0,\n          mpie: 1'b0,\n          mpp: PRIV_LVL_M,\n          mprv: 1'b0\n      };\n      mepc_q <= '0;\n      mcause_q <= '0;\n\n      depc_q <= '0;\n      dcsr_q <= '{\n          xdebugver: XDEBUGVER_STD,\n          cause: DBG_CAUSE_NONE,  // 3'h0\n          prv: PRIV_LVL_M,\n          default: '0\n      };\n      dscratch0_q <= '0;\n      dscratch1_q <= '0;\n      mscratch_q <= '0;\n      mie_q <= '0;\n      mtvec_q <= '0;\n      mtvec_mode_q <= MTVEC_MODE;\n    end else begin\n      // update CSRs\n      if (FPU == 1) begin\n        frm_q    <= frm_n;\n        fflags_q <= fflags_n;\n        if (ZFINX == 0) begin\n          mstatus_fs_q <= mstatus_fs_n;\n        end\n      end\n      if (PULP_SECURE == 1) begin\n        mstatus_q <= mstatus_n;\n      end else begin\n        mstatus_q <= '{\n            uie: 1'b0,\n            mie: mstatus_n.mie,\n            upie: 1'b0,\n            mpie: mstatus_n.mpie,\n            mpp: PRIV_LVL_M,\n            mprv: 1'b0\n        };\n      end\n      mepc_q       <= mepc_n;\n      mcause_q     <= mcause_n;\n      depc_q       <= depc_n;\n      dcsr_q       <= dcsr_n;\n      dscratch0_q  <= dscratch0_n;\n      dscratch1_q  <= dscratch1_n;\n      mscratch_q   <= mscratch_n;\n      mie_q        <= mie_n;\n      mtvec_q      <= mtvec_n;\n      mtvec_mode_q <= mtvec_mode_n;\n    end\n  end\n  ////////////////////////////////////////////////////////////////////////\n  //  ____       _                   _____     _                        //\n  // |  _ \\  ___| |__  _   _  __ _  |_   _| __(_) __ _  __ _  ___ _ __  //\n  // | | | |/ _ \\ '_ \\| | | |/ _` |   | || '__| |/ _` |/ _` |/ _ \\ '__| //\n  // | |_| |  __/ |_) | |_| | (_| |   | || |  | | (_| | (_| |  __/ |    //\n  // |____/ \\___|_.__/ \\__,_|\\__, |   |_||_|  |_|\\__, |\\__, |\\___|_|    //\n  //                         |___/               |___/ |___/            //\n  ////////////////////////////////////////////////////////////////////////\n\n  if (DEBUG_TRIGGER_EN) begin : gen_trigger_regs\n    // Register values\n    logic        tmatch_control_exec_q;\n    logic [31:0] tmatch_value_q;\n    // Write enables\n    logic        tmatch_control_we;\n    logic        tmatch_value_we;\n\n    // Write select\n    assign tmatch_control_we = csr_we_int & debug_mode_i & (csr_addr_i == CSR_TDATA1);\n    assign tmatch_value_we   = csr_we_int & debug_mode_i & (csr_addr_i == CSR_TDATA2);\n\n\n    // Registers\n    always_ff @(posedge clk or negedge rst_n) begin\n      if (!rst_n) begin\n        tmatch_control_exec_q <= 'b0;\n        tmatch_value_q        <= 'b0;\n      end else begin\n        if (tmatch_control_we) tmatch_control_exec_q <= csr_wdata_int[2];\n        if (tmatch_value_we) tmatch_value_q <= csr_wdata_int[31:0];\n      end\n    end\n\n    // All supported trigger types\n    assign tinfo_types = 1 << TTYPE_MCONTROL;\n\n    // Assign read data\n    // TDATA0 - only support simple address matching\n    assign tmatch_control_rdata = {\n      TTYPE_MCONTROL,  // type    : address/data match\n      1'b1,  // dmode   : access from D mode only\n      6'h00,  // maskmax : exact match only\n      1'b0,  // hit     : not supported\n      1'b0,  // select  : address match only\n      1'b0,  // timing  : match before execution\n      2'b00,  // sizelo  : match any access\n      4'h1,  // action  : enter debug mode\n      1'b0,  // chain   : not supported\n      4'h0,  // match   : simple match\n      1'b1,  // m       : match in m-mode\n      1'b0,  // 0       : zero\n      1'b0,  // s       : not supported\n      PULP_SECURE == 1,  // u       : match in u-mode\n      tmatch_control_exec_q,  // execute : match instruction address\n      1'b0,  // store   : not supported\n      1'b0\n    };  // load    : not supported\n\n    // TDATA1 - address match value only\n    assign tmatch_value_rdata = tmatch_value_q;\n\n    // Breakpoint matching\n    // We match against the next address, as the breakpoint must be taken before execution\n    assign trigger_match_o = tmatch_control_exec_q & (pc_id_i[31:0] == tmatch_value_q[31:0]);\n\n  end else begin : gen_no_trigger_regs\n    assign tinfo_types          = 'b0;\n    assign tmatch_control_rdata = 'b0;\n    assign tmatch_value_rdata   = 'b0;\n    assign trigger_match_o      = 'b0;\n  end\n\n  /////////////////////////////////////////////////////////////////\n  //   ____            __     ____                  _            //\n  // |  _ \\ ___ _ __ / _|   / ___|___  _   _ _ __ | |_ ___ _ __  //\n  // | |_) / _ \\ '__| |_   | |   / _ \\| | | | '_ \\| __/ _ \\ '__| //\n  // |  __/  __/ |  |  _|  | |__| (_) | |_| | | | | ||  __/ |    //\n  // |_|   \\___|_|  |_|(_)  \\____\\___/ \\__,_|_| |_|\\__\\___|_|    //\n  //                                                             //\n  /////////////////////////////////////////////////////////////////\n\n  // ------------------------\n  // Events to count\n  assign hpm_events[0] = 1'b1;  // cycle counter\n  assign hpm_events[1] = mhpmevent_minstret_i;  // instruction counter\n  assign hpm_events[2] = mhpmevent_ld_stall_i;  // nr of load use hazards\n  assign hpm_events[3] = mhpmevent_jr_stall_i;  // nr of jump register hazards\n  assign hpm_events[4]  = mhpmevent_imiss_i;                             // cycles waiting for instruction fetches, excluding jumps and branches\n  assign hpm_events[5] = mhpmevent_load_i;  // nr of loads\n  assign hpm_events[6] = mhpmevent_store_i;  // nr of stores\n  assign hpm_events[7] = mhpmevent_jump_i;  // nr of jumps (unconditional)\n  assign hpm_events[8] = mhpmevent_branch_i;  // nr of branches (conditional)\n  assign hpm_events[9] = mhpmevent_branch_taken_i;  // nr of taken branches (conditional)\n  assign hpm_events[10] = mhpmevent_compressed_i;  // compressed instruction counter\n  assign hpm_events[11] = COREV_CLUSTER ? mhpmevent_pipe_stall_i : 1'b0;  // extra cycles from ELW\n  assign hpm_events[12] = !APU ? 1'b0 : apu_typeconflict_i && !apu_dep_i;\n  assign hpm_events[13] = !APU ? 1'b0 : apu_contention_i;\n  assign hpm_events[14] = !APU ? 1'b0 : apu_dep_i && !apu_contention_i;\n  assign hpm_events[15] = !APU ? 1'b0 : apu_wb_i;\n\n  // ------------------------\n  // address decoder for performance counter registers\n  logic mcounteren_we;\n  logic mcountinhibit_we;\n  logic mhpmevent_we;\n\n  assign mcounteren_we = csr_we_int & (csr_addr_i == CSR_MCOUNTEREN);\n  assign mcountinhibit_we = csr_we_int & (csr_addr_i == CSR_MCOUNTINHIBIT);\n  assign mhpmevent_we     = csr_we_int & ( (csr_addr_i == CSR_MHPMEVENT3  )||\n                                           (csr_addr_i == CSR_MHPMEVENT4  ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT5  ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT6  ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT7  ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT8  ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT9  ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT10 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT11 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT12 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT13 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT14 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT15 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT16 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT17 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT18 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT19 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT20 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT21 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT22 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT23 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT24 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT25 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT26 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT27 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT28 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT29 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT30 ) ||\n                                           (csr_addr_i == CSR_MHPMEVENT31 ) );\n\n  // ------------------------\n  // Increment value for performance counters\n  genvar incr_gidx;\n  generate\n    for (incr_gidx = 0; incr_gidx < 32; incr_gidx++) begin : gen_mhpmcounter_increment\n      assign mhpmcounter_increment[incr_gidx] = mhpmcounter_q[incr_gidx] + 1;\n    end\n  endgenerate\n\n  // ------------------------\n  // next value for performance counters and control registers\n  always_comb begin\n    mcounteren_n    = mcounteren_q;\n    mcountinhibit_n = mcountinhibit_q;\n    mhpmevent_n     = mhpmevent_q;\n\n    // User Mode Enable\n    if (PULP_SECURE && mcounteren_we) mcounteren_n = csr_wdata_int;\n\n    // Inhibit Control\n    if (mcountinhibit_we) mcountinhibit_n = csr_wdata_int;\n\n    // Event Control\n    if (mhpmevent_we) mhpmevent_n[csr_addr_i[4:0]] = csr_wdata_int;\n  end\n\n  genvar wcnt_gidx;\n  generate\n    for (wcnt_gidx = 0; wcnt_gidx < 32; wcnt_gidx++) begin : gen_mhpmcounter_write\n\n      // Write lower counter bits\n      assign mhpmcounter_write_lower[wcnt_gidx] = csr_we_int && (csr_addr_i == (CSR_MCYCLE + wcnt_gidx));\n\n      // Write upper counter bits\n      assign mhpmcounter_write_upper[wcnt_gidx] = !mhpmcounter_write_lower[wcnt_gidx] &&\n                                                  csr_we_int && (csr_addr_i == (CSR_MCYCLEH + wcnt_gidx)) && (MHPMCOUNTER_WIDTH == 64);\n\n      // Increment counter\n      if (!PULP_PERF_COUNTERS) begin : gen_no_pulp_perf_counters\n        if (wcnt_gidx == 0) begin : gen_mhpmcounter_mcycle\n          // mcycle = mhpmcounter[0] : count every cycle (if not inhibited)\n          assign mhpmcounter_write_increment[wcnt_gidx] = !mhpmcounter_write_lower[wcnt_gidx] &&\n                                                          !mhpmcounter_write_upper[wcnt_gidx] &&\n                                                          !mcountinhibit_q[wcnt_gidx];\n        end else if (wcnt_gidx == 2) begin : gen_mhpmcounter_minstret\n          // minstret = mhpmcounter[2]  : count every retired instruction (if not inhibited)\n          assign mhpmcounter_write_increment[wcnt_gidx] = !mhpmcounter_write_lower[wcnt_gidx] &&\n                                                          !mhpmcounter_write_upper[wcnt_gidx] &&\n                                                          !mcountinhibit_q[wcnt_gidx] &&\n                                                          hpm_events[1];\n        end else if( (wcnt_gidx>2) && (wcnt_gidx<(NUM_MHPMCOUNTERS+3))) begin : gen_mhpmcounter\n          // add +1 if any event is enabled and active\n          assign mhpmcounter_write_increment[wcnt_gidx] = !mhpmcounter_write_lower[wcnt_gidx] &&\n                                                          !mhpmcounter_write_upper[wcnt_gidx] &&\n                                                          !mcountinhibit_q[wcnt_gidx] &&\n                                                          |(hpm_events & mhpmevent_q[wcnt_gidx][NUM_HPM_EVENTS-1:0]);\n        end else begin : gen_mhpmcounter_not_implemented\n          assign mhpmcounter_write_increment[wcnt_gidx] = 1'b0;\n        end\n      end else begin : gen_pulp_perf_counters\n        // PULP PERF COUNTERS share all events in one register (not compliant with RISC-V)\n        assign mhpmcounter_write_increment[wcnt_gidx] = !mhpmcounter_write_lower[wcnt_gidx] &&\n                                                        !mhpmcounter_write_upper[wcnt_gidx] &&\n                                                        !mcountinhibit_q[wcnt_gidx] &&\n                                                        |(hpm_events & mhpmevent_q[wcnt_gidx][NUM_HPM_EVENTS-1:0]);\n      end\n    end\n  endgenerate\n\n  // ------------------------\n  // HPM Registers\n  //  Counter Registers: mhpcounter_q[]\n  genvar cnt_gidx;\n  generate\n    for (cnt_gidx = 0; cnt_gidx < 32; cnt_gidx++) begin : gen_mhpmcounter\n      // mcyclce  is located at index 0\n      // there is no counter at index 1\n      // minstret is located at index 2\n      // Programable HPM counters start at index 3\n      if ((cnt_gidx == 1) || (cnt_gidx >= (NUM_MHPMCOUNTERS + 3))) begin : gen_non_implemented\n        assign mhpmcounter_q[cnt_gidx] = 'b0;\n      end else begin : gen_implemented\n        always_ff @(posedge clk, negedge rst_n)\n          if (!rst_n) begin\n            mhpmcounter_q[cnt_gidx] <= 'b0;\n          end else begin\n            if (PULP_PERF_COUNTERS && (cnt_gidx == 2 || cnt_gidx == 0)) begin\n              mhpmcounter_q[cnt_gidx] <= 'b0;\n            end else begin\n              if (mhpmcounter_write_lower[cnt_gidx]) begin\n                mhpmcounter_q[cnt_gidx][31:0] <= csr_wdata_int;\n              end else if (mhpmcounter_write_upper[cnt_gidx]) begin\n                mhpmcounter_q[cnt_gidx][63:32] <= csr_wdata_int;\n              end else if (mhpmcounter_write_increment[cnt_gidx]) begin\n                mhpmcounter_q[cnt_gidx] <= mhpmcounter_increment[cnt_gidx];\n              end\n            end\n          end\n      end\n    end\n  endgenerate\n\n  //  Event Register: mhpevent_q[]\n  genvar evt_gidx;\n  generate\n    for (evt_gidx = 0; evt_gidx < 32; evt_gidx++) begin : gen_mhpmevent\n      // programable HPM events start at index3\n      if ((evt_gidx < 3) || (evt_gidx >= (NUM_MHPMCOUNTERS + 3))) begin : gen_non_implemented\n        assign mhpmevent_q[evt_gidx] = 'b0;\n      end else begin : gen_implemented\n        if (NUM_HPM_EVENTS < 32) begin : gen_tie_off\n          assign mhpmevent_q[evt_gidx][31:NUM_HPM_EVENTS] = 'b0;\n        end\n        always_ff @(posedge clk, negedge rst_n)\n          if (!rst_n) mhpmevent_q[evt_gidx][NUM_HPM_EVENTS-1:0] <= 'b0;\n          else\n            mhpmevent_q[evt_gidx][NUM_HPM_EVENTS-1:0] <= mhpmevent_n[evt_gidx][NUM_HPM_EVENTS-1:0];\n      end\n    end\n  endgenerate\n\n  //  Enable Regsiter: mcounteren_q\n  genvar en_gidx;\n  generate\n    for (en_gidx = 0; en_gidx < 32; en_gidx++) begin : gen_mcounteren\n      if( (PULP_SECURE == 0) ||\n          (en_gidx == 1) ||\n          (en_gidx >= (NUM_MHPMCOUNTERS+3) ) )\n        begin : gen_non_implemented\n        assign mcounteren_q[en_gidx] = 'b0;\n      end else begin : gen_implemented\n        always_ff @(posedge clk, negedge rst_n)\n          if (!rst_n) mcounteren_q[en_gidx] <= 'b0;  // default disable\n          else mcounteren_q[en_gidx] <= mcounteren_n[en_gidx];\n      end\n    end\n  endgenerate\n\n  //  Inhibit Regsiter: mcountinhibit_q\n  //  Note: implemented counters are disabled out of reset to save power\n  genvar inh_gidx;\n  generate\n    for (inh_gidx = 0; inh_gidx < 32; inh_gidx++) begin : gen_mcountin"}
{"text": "hibit\n      if ((inh_gidx == 1) || (inh_gidx >= (NUM_MHPMCOUNTERS + 3))) begin : gen_non_implemented\n        assign mcountinhibit_q[inh_gidx] = 'b0;\n      end else begin : gen_implemented\n        always_ff @(posedge clk, negedge rst_n)\n          if (!rst_n) mcountinhibit_q[inh_gidx] <= 'b1;  // default disable\n          else mcountinhibit_q[inh_gidx] <= mcountinhibit_n[inh_gidx];\n      end\n    end\n  endgenerate\n\n`ifdef CV32E40P_ASSERT_ON\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n\n  // Check that mie_bypass_o equals mie_n\n  a_mie_bypass :\n  assert property (@(posedge clk) disable iff (!rst_n) (1'b1) |-> (mie_bypass_o == mie_n));\n\n`endif\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer        Andreas Traber - atraber@iis.ee.ethz.ch                    //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Matthias Baer - baermatt@student.ethz.ch                   //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Sven Stucki - svstucki@student.ethz.ch                     //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Decoder                                                    //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Decoder                                                    //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_decoder\n  import cv32e40p_pkg::*;\n  import cv32e40p_apu_core_pkg::*;\n  import cv32e40p_fpu_pkg::*;\n#(\n  parameter COREV_PULP        = 1,              // PULP ISA Extension (including PULP specific CSRs and hardware loop, excluding cv.elw)\n  parameter COREV_CLUSTER     = 0,              // PULP ISA Extension cv.elw (need COREV_PULP = 1)\n  parameter A_EXTENSION       = 0,\n  parameter FPU               = 0,\n  parameter FPU_ADDMUL_LAT    = 0,\n  parameter FPU_OTHERS_LAT    = 0,\n  parameter ZFINX             = 0,\n  parameter PULP_SECURE       = 0,\n  parameter USE_PMP           = 0,\n  parameter APU_WOP_CPU       = 6,\n  parameter DEBUG_TRIGGER_EN  = 1\n)\n(\n  // signals running to/from controller\n  input  logic        deassert_we_i,           // deassert we, we are stalled or not active\n\n  output logic        illegal_insn_o,          // illegal instruction encountered\n  output logic        ebrk_insn_o,             // trap instruction encountered\n\n  output logic        mret_insn_o,             // return from exception instruction encountered (M)\n  output logic        uret_insn_o,             // return from exception instruction encountered (S)\n  output logic        dret_insn_o,             // return from debug (M)\n\n  output logic        mret_dec_o,              // return from exception instruction encountered (M) without deassert\n  output logic        uret_dec_o,              // return from exception instruction encountered (S) without deassert\n  output logic        dret_dec_o,              // return from debug (M) without deassert\n\n  output logic        ecall_insn_o,            // environment call (syscall) instruction encountered\n  output logic        wfi_o       ,            // pipeline flush is requested\n\n  output logic        fencei_insn_o,           // fence.i instruction\n\n  output logic        rega_used_o,             // rs1 is used by current instruction\n  output logic        regb_used_o,             // rs2 is used by current instruction\n  output logic        regc_used_o,             // rs3 is used by current instruction\n\n  output logic        reg_fp_a_o,              // fp reg a is used\n  output logic        reg_fp_b_o,              // fp reg b is used\n  output logic        reg_fp_c_o,              // fp reg c is used\n  output logic        reg_fp_d_o,              // fp reg d is used\n\n  output logic [ 0:0] bmask_a_mux_o,           // bit manipulation mask a mux\n  output logic [ 1:0] bmask_b_mux_o,           // bit manipulation mask b mux\n  output logic        alu_bmask_a_mux_sel_o,   // bit manipulation mask a mux (reg or imm)\n  output logic        alu_bmask_b_mux_sel_o,   // bit manipulation mask b mux (reg or imm)\n\n  // from IF/ID pipeline\n  input  logic [31:0] instr_rdata_i,           // instruction read from instr memory/cache\n  input  logic        illegal_c_insn_i,        // compressed instruction decode failed\n\n  // ALU signals\n  output logic        alu_en_o,                // ALU enable\n  output alu_opcode_e alu_operator_o, // ALU operation selection\n  output logic [2:0]  alu_op_a_mux_sel_o,      // operand a selection: reg value, PC, immediate or zero\n  output logic [2:0]  alu_op_b_mux_sel_o,      // operand b selection: reg value or immediate\n  output logic [1:0]  alu_op_c_mux_sel_o,      // operand c selection: reg value or jump target\n  output logic        alu_vec_o,               // vectorial instruction\n  output logic [1:0]  alu_vec_mode_o,          // selects between 32 bit, 16 bit and 8 bit vectorial modes\n  output logic        scalar_replication_o,    // scalar replication enable\n  output logic        scalar_replication_c_o,  // scalar replication enable for operand C\n  output logic [0:0]  imm_a_mux_sel_o,         // immediate selection for operand a\n  output logic [3:0]  imm_b_mux_sel_o,         // immediate selection for operand b\n  output logic [1:0]  regc_mux_o,              // register c selection: S3, RD or 0\n  output logic        is_clpx_o,               // whether the instruction is complex (pulpv3) or not\n  output logic        is_subrot_o,\n\n  // MUL related control signals\n  output mul_opcode_e mult_operator_o,         // Multiplication operation selection\n  output logic        mult_int_en_o,           // perform integer multiplication\n  output logic        mult_dot_en_o,           // perform dot multiplication\n  output logic [0:0]  mult_imm_mux_o,          // Multiplication immediate mux selector\n  output logic        mult_sel_subword_o,      // Select subwords for 16x16 bit of multiplier\n  output logic [1:0]  mult_signed_mode_o,      // Multiplication in signed mode\n  output logic [1:0]  mult_dot_signed_o,       // Dot product in signed mode\n\n  // FPU\n  input  logic            fs_off_i, // Floating-Point State field from MSTATUS\n  input  logic [C_RM-1:0] frm_i,    // Rounding mode from float CSR\n\n  output logic [cv32e40p_fpu_pkg::FP_FORMAT_BITS-1:0]  fpu_dst_fmt_o,   // fpu destination format\n  output logic [cv32e40p_fpu_pkg::FP_FORMAT_BITS-1:0]  fpu_src_fmt_o,   // fpu source format\n  output logic [cv32e40p_fpu_pkg::INT_FORMAT_BITS-1:0] fpu_int_fmt_o,   // fpu integer format (for casts)\n\n  // APU\n  output logic                   apu_en_o,\n  output logic [APU_WOP_CPU-1:0] apu_op_o,\n  output logic [1:0]             apu_lat_o,\n  output logic [2:0]             fp_rnd_mode_o,\n\n  // register file related signals\n  output logic        regfile_mem_we_o,        // write enable for regfile\n  output logic        regfile_alu_we_o,        // write enable for 2nd regfile port\n  output logic        regfile_alu_we_dec_o,    // write enable for 2nd regfile port without deassert\n  output logic        regfile_alu_waddr_sel_o, // Select register write address for ALU/MUL operations\n\n  // CSR manipulation\n  output logic        csr_access_o,            // access to CSR\n  output logic        csr_status_o,            // access to xstatus CSR\n  output csr_opcode_e csr_op_o,                // operation to perform on CSR\n  input  PrivLvl_t    current_priv_lvl_i,      // The current privilege level\n\n  // LD/ST unit signals\n  output logic        data_req_o,              // start transaction to data memory\n  output logic        data_we_o,               // data memory write enable\n  output logic        prepost_useincr_o,       // when not active bypass the alu result for address calculation\n  output logic [1:0]  data_type_o,             // data type on data memory: byte, half word or word\n  output logic [1:0]  data_sign_extension_o,   // sign extension on read data from data memory / NaN boxing\n  output logic [1:0]  data_reg_offset_o,       // offset in byte inside register for stores\n  output logic        data_load_event_o,       // data request is in the special event range\n\n  // Atomic memory access\n  output logic [5:0] atop_o,\n\n  // hwloop signals\n  output logic [2:0]  hwlp_we_o,               // write enable for hwloop regs\n  output logic [1:0]  hwlp_target_mux_sel_o,   // selects immediate for hwloop target\n  output logic [1:0]  hwlp_start_mux_sel_o,    // selects hwloop start address input\n  output logic        hwlp_cnt_mux_sel_o,      // selects hwloop counter input\n\n  input  logic        debug_mode_i,            // processor is in debug mode\n  input  logic        debug_wfi_no_sleep_i,    // do not let WFI cause sleep\n\n  // jump/branches\n  output logic [1:0]  ctrl_transfer_insn_in_dec_o,  // control transfer instruction without deassert\n  output logic [1:0]  ctrl_transfer_insn_in_id_o,   // control transfer instructio is decoded\n  output logic [1:0]  ctrl_transfer_target_mux_sel_o,        // jump target selection\n\n  // HPM related control signals\n  input  logic [31:0] mcounteren_i\n);\n\n  // write enable/request control\n  logic       regfile_mem_we;\n  logic       regfile_alu_we;\n  logic       data_req;\n  logic [2:0] hwlp_we;\n  logic       csr_illegal;\n  logic [1:0] ctrl_transfer_insn;\n\n  csr_opcode_e csr_op;\n\n  logic       alu_en;\n  logic       mult_int_en;\n  logic       mult_dot_en;\n  logic       apu_en;\n\n  // this instruction needs floating-point rounding-mode verification\n  logic check_fprm;\n\n  logic [cv32e40p_fpu_pkg::OP_BITS-1:0] fpu_op;     // fpu operation\n  logic                                 fpu_op_mod; // fpu operation modifier\n  logic                                 fpu_vec_op; // fpu vectorial operation\n  // unittypes for latencies to help us decode for APU\n  enum logic[1:0] {ADDMUL, DIVSQRT, NONCOMP, CONV} fp_op_group;\n\n\n  /////////////////////////////////////////////\n  //   ____                     _            //\n  //  |  _ \\  ___  ___ ___   __| | ___ _ __  //\n  //  | | | |/ _ \\/ __/ _ \\ / _` |/ _ \\ '__| //\n  //  | |_| |  __/ (_| (_) | (_| |  __/ |    //\n  //  |____/ \\___|\\___\\___/ \\__,_|\\___|_|    //\n  //                                         //\n  /////////////////////////////////////////////\n\n  always_comb\n  begin: instruction_decoder\n    ctrl_transfer_insn             = BRANCH_NONE;\n    ctrl_transfer_target_mux_sel_o = JT_JAL;\n\n    alu_en                         = 1'b1;\n    alu_operator_o                 = ALU_SLTU;\n    alu_op_a_mux_sel_o             = OP_A_REGA_OR_FWD;\n    alu_op_b_mux_sel_o             = OP_B_REGB_OR_FWD;\n    alu_op_c_mux_sel_o             = OP_C_REGC_OR_FWD;\n    alu_vec_o                      = 1'b0;\n    alu_vec_mode_o                 = VEC_MODE32;\n    scalar_replication_o           = 1'b0;\n    scalar_replication_c_o         = 1'b0;\n    regc_mux_o                     = REGC_ZERO;\n    imm_a_mux_sel_o                = IMMA_ZERO;\n    imm_b_mux_sel_o                = IMMB_I;\n\n    mult_int_en                    = 1'b0;\n    mult_dot_en                    = 1'b0;\n    mult_operator_o                = MUL_I;\n    mult_imm_mux_o                 = MIMM_ZERO;\n    mult_signed_mode_o             = 2'b00;\n    mult_sel_subword_o             = 1'b0;\n    mult_dot_signed_o              = 2'b00;\n\n    apu_en                         = 1'b0;\n    apu_op_o                       = '0;\n    apu_lat_o                      = '0;\n    fp_rnd_mode_o                  = '0;\n    fpu_op                         = cv32e40p_fpu_pkg::SGNJ;\n    fpu_op_mod                     = 1'b0;\n    fpu_vec_op                     = 1'b0;\n    fpu_dst_fmt_o                  = cv32e40p_fpu_pkg::FP32;\n    fpu_src_fmt_o                  = cv32e40p_fpu_pkg::FP32;\n    fpu_int_fmt_o                  = cv32e40p_fpu_pkg::INT32;\n    check_fprm                     = 1'b0;\n    fp_op_group                    = ADDMUL;\n\n    regfile_mem_we                 = 1'b0;\n    regfile_alu_we                 = 1'b0;\n    regfile_alu_waddr_sel_o        = 1'b1;\n\n    prepost_useincr_o              = 1'b1;\n\n    hwlp_we                        = 3'b0;\n    hwlp_target_mux_sel_o          = 2'b0;\n    hwlp_start_mux_sel_o           = 2'b0;\n    hwlp_cnt_mux_sel_o             = 1'b0;\n\n    csr_access_o                   = 1'b0;\n    csr_status_o                   = 1'b0;\n    csr_illegal                    = 1'b0;\n    csr_op                         = CSR_OP_READ;\n    mret_insn_o                    = 1'b0;\n    uret_insn_o                    = 1'b0;\n\n    dret_insn_o                    = 1'b0;\n\n    data_we_o                      = 1'b0;\n    data_type_o                    = 2'b00;\n    data_sign_extension_o          = 2'b00;\n    data_reg_offset_o              = 2'b00;\n    data_req                       = 1'b0;\n    data_load_event_o              = 1'b0;\n\n    atop_o                         = 6'b000000;\n\n    illegal_insn_o                 = 1'b0;\n    ebrk_insn_o                    = 1'b0;\n    ecall_insn_o                   = 1'b0;\n    wfi_o                          = 1'b0;\n\n    fencei_insn_o                  = 1'b0;\n\n    rega_used_o                    = 1'b0;\n    regb_used_o                    = 1'b0;\n    regc_used_o                    = 1'b0;\n    reg_fp_a_o                     = 1'b0;\n    reg_fp_b_o                     = 1'b0;\n    reg_fp_c_o                     = 1'b0;\n    reg_fp_d_o                     = 1'b0;\n\n    bmask_a_mux_o                  = BMASK_A_ZERO;\n    bmask_b_mux_o                  = BMASK_B_ZERO;\n    alu_bmask_a_mux_sel_o          = BMASK_A_IMM;\n    alu_bmask_b_mux_sel_o          = BMASK_B_IMM;\n\n    is_clpx_o                      = 1'b0;\n    is_subrot_o                    = 1'b0;\n\n    mret_dec_o                     = 1'b0;\n    uret_dec_o                     = 1'b0;\n    dret_dec_o                     = 1'b0;\n\n    unique case (instr_rdata_i[6:0])\n\n      //////////////////////////////////////\n      //      _ _   _ __  __ ____  ____   //\n      //     | | | | |  \\/  |  _ \\/ ___|  //\n      //  _  | | | | | |\\/| | |_) \\___ \\  //\n      // | |_| | |_| | |  | |  __/ ___) | //\n      //  \\___/ \\___/|_|  |_|_|   |____/  //\n      //                                  //\n      //////////////////////////////////////\n\n      OPCODE_JAL: begin   // Jump and Link\n        ctrl_transfer_target_mux_sel_o = JT_JAL;\n        ctrl_transfer_insn    = BRANCH_JAL;\n        // Calculate and store PC+4\n        alu_op_a_mux_sel_o  = OP_A_CURRPC;\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_b_mux_sel_o     = IMMB_PCINCR;\n        alu_operator_o      = ALU_ADD;\n        regfile_alu_we      = 1'b1;\n        // Calculate jump target (= PC + UJ imm)\n      end\n\n      OPCODE_JALR: begin  // Jump and Link Register\n        ctrl_transfer_target_mux_sel_o = JT_JALR;\n        ctrl_transfer_insn    = BRANCH_JALR;\n        // Calculate and store PC+4\n        alu_op_a_mux_sel_o  = OP_A_CURRPC;\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_b_mux_sel_o     = IMMB_PCINCR;\n        alu_operator_o      = ALU_ADD;\n        regfile_alu_we      = 1'b1;\n        // Calculate jump target (= RS1 + I imm)\n        rega_used_o         = 1'b1;\n\n        if (instr_rdata_i[14:12] != 3'b0) begin\n          ctrl_transfer_insn = BRANCH_NONE;\n          regfile_alu_we     = 1'b0;\n          illegal_insn_o     = 1'b1;\n        end\n      end\n\n      OPCODE_BRANCH: begin // Branch\n        ctrl_transfer_target_mux_sel_o = JT_COND;\n        ctrl_transfer_insn             = BRANCH_COND;\n        alu_op_c_mux_sel_o             = OP_C_JT;\n        rega_used_o                    = 1'b1;\n        regb_used_o                    = 1'b1;\n\n        unique case (instr_rdata_i[14:12])\n          3'b000 : alu_operator_o = ALU_EQ;\n          3'b001 : alu_operator_o = ALU_NE;\n          3'b100 : alu_operator_o = ALU_LTS;\n          3'b101 : alu_operator_o = ALU_GES;\n          3'b110 : alu_operator_o = ALU_LTU;\n          3'b111 : alu_operator_o = ALU_GEU;\n          default: illegal_insn_o = 1'b1;\n        endcase\n      end\n\n\n      //////////////////////////////////\n      //  _     ____    ______ _____  //\n      // | |   |  _ \\  / / ___|_   _| //\n      // | |   | | | |/ /\\___ \\ | |   //\n      // | |___| |_| / /  ___) || |   //\n      // |_____|____/_/  |____/ |_|   //\n      //                              //\n      //////////////////////////////////\n\n      OPCODE_STORE: begin\n        data_req           = 1'b1;\n        data_we_o          = 1'b1;\n        rega_used_o        = 1'b1;\n        regb_used_o        = 1'b1;\n        alu_operator_o     = ALU_ADD;\n        // pass write data through ALU operand c\n        alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;\n        // offset from immediate\n        imm_b_mux_sel_o    = IMMB_S;\n        alu_op_b_mux_sel_o = OP_B_IMM;\n\n        // store size\n        unique case (instr_rdata_i[14:12])\n          3'b000 : data_type_o = 2'b10; // SB\n          3'b001 : data_type_o = 2'b01; // SH\n          3'b010 : data_type_o = 2'b00; // SW\n          default: begin\n            illegal_insn_o = 1'b1;\n            data_req       = 1'b0;\n            data_we_o      = 1'b0;\n          end\n        endcase\n      end\n\n      OPCODE_LOAD: begin\n        data_req           = 1'b1;\n        regfile_mem_we     = 1'b1;\n        rega_used_o        = 1'b1;\n        alu_operator_o     = ALU_ADD;\n        // offset from immediate\n        alu_op_b_mux_sel_o = OP_B_IMM;\n        imm_b_mux_sel_o    = IMMB_I;\n\n        // sign/zero extension\n        data_sign_extension_o = {1'b0,~instr_rdata_i[14]};\n\n        // load size\n        unique case (instr_rdata_i[14:12])\n          3'b000, 3'b100: data_type_o = 2'b10; // LB/LBU\n          3'b001, 3'b101: data_type_o = 2'b01; // LH/LHU\n          3'b010        : data_type_o = 2'b00; // LW\n          default: begin\n            illegal_insn_o = 1'b1;\n          end\n        endcase\n      end\n\n      OPCODE_AMO: begin\n        if (A_EXTENSION) begin : decode_amo\n          if (instr_rdata_i[14:12] == 3'b010) begin // RV32A Extension (word)\n            data_req          = 1'b1;\n            data_type_o       = 2'b00;\n            rega_used_o       = 1'b1;\n            regb_used_o       = 1'b1;\n            regfile_mem_we    = 1'b1;\n            prepost_useincr_o = 1'b0; // only use alu_operand_a as address (not a+b)\n            alu_op_a_mux_sel_o = OP_A_REGA_OR_FWD;\n\n            data_sign_extension_o = 1'b1;\n\n            // Apply AMO instruction at `atop_o`.\n            atop_o = {1'b1, instr_rdata_i[31:27]};\n\n            unique case (instr_rdata_i[31:27])\n              AMO_LR: begin\n                data_we_o = 1'b0;\n              end\n              AMO_SC,\n              AMO_SWAP,\n              AMO_ADD,\n              AMO_XOR,\n              AMO_AND,\n              AMO_OR,\n              AMO_MIN,\n              AMO_MAX,\n              AMO_MINU,\n              AMO_MAXU: begin\n                data_we_o = 1'b1;\n                alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD; // pass write data through ALU operand c\n              end\n              default : illegal_insn_o = 1'b1;\n            endcase\n          end\n          else begin\n            illegal_insn_o = 1'b1;\n          end\n        end else begin : no_decode_amo\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      //////////////////////////\n      //     _    _    _   _  //\n      //    / \\  | |  | | | | //\n      //   / _ \\ | |  | | | | //\n      //  / ___ \\| |__| |_| | //\n      // /_/   \\_\\_____\\___/  //\n      //                      //\n      //////////////////////////\n\n      OPCODE_LUI: begin  // Load Upper Immediate\n        alu_op_a_mux_sel_o  = OP_A_IMM;\n        alu_op_b_"}
{"text": "mux_sel_o  = OP_B_IMM;\n        imm_a_mux_sel_o     = IMMA_ZERO;\n        imm_b_mux_sel_o     = IMMB_U;\n        alu_operator_o      = ALU_ADD;\n        regfile_alu_we      = 1'b1;\n      end\n\n      OPCODE_AUIPC: begin  // Add Upper Immediate to PC\n        alu_op_a_mux_sel_o  = OP_A_CURRPC;\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_b_mux_sel_o     = IMMB_U;\n        alu_operator_o      = ALU_ADD;\n        regfile_alu_we      = 1'b1;\n      end\n\n      OPCODE_OPIMM: begin // Register-Immediate ALU Operations\n        alu_op_b_mux_sel_o  = OP_B_IMM;\n        imm_b_mux_sel_o     = IMMB_I;\n        regfile_alu_we      = 1'b1;\n        rega_used_o         = 1'b1;\n\n        unique case (instr_rdata_i[14:12])\n          3'b000: alu_operator_o = ALU_ADD;  // Add Immediate\n          3'b010: alu_operator_o = ALU_SLTS; // Set to one if Lower Than Immediate\n          3'b011: alu_operator_o = ALU_SLTU; // Set to one if Lower Than Immediate Unsigned\n          3'b100: alu_operator_o = ALU_XOR;  // Exclusive Or with Immediate\n          3'b110: alu_operator_o = ALU_OR;   // Or with Immediate\n          3'b111: alu_operator_o = ALU_AND;  // And with Immediate\n\n          3'b001: begin\n            alu_operator_o = ALU_SLL;  // Shift Left Logical by Immediate\n            if (instr_rdata_i[31:25] != 7'b0)\n              illegal_insn_o = 1'b1;\n          end\n\n          3'b101: begin\n            if (instr_rdata_i[31:25] == 7'b0)\n              alu_operator_o = ALU_SRL;  // Shift Right Logical by Immediate\n            else if (instr_rdata_i[31:25] == 7'b010_0000)\n              alu_operator_o = ALU_SRA;  // Shift Right Arithmetically by Immediate\n            else\n              illegal_insn_o = 1'b1;\n          end\n\n\n        endcase\n      end\n\n      OPCODE_OP: begin\n\n        // PREFIX 11\n        if (instr_rdata_i[31:30] == 2'b11) begin\n          illegal_insn_o = 1'b1;\n\n        // PREFIX 10\n        end else if (instr_rdata_i[31:30] == 2'b10) begin\n          if (instr_rdata_i[29:25] == 5'b00000) begin\n            illegal_insn_o = 1'b1;\n\n          ///////////////////////\n          // VECTORIAL FLOAT OPS\n          ///////////////////////\n          end else begin\n            // Vectorial FP\n            if (FPU == 1 && C_XFVEC == 1) begin\n\n              // using APU instead of ALU\n              alu_en           = 1'b0;\n              apu_en           = 1'b1;\n              // by default, set all registers to FP registers and use 2\n              rega_used_o      = 1'b1;\n              regb_used_o      = 1'b1;\n              if (ZFINX == 0) begin\n                reg_fp_a_o     = 1'b1;\n                reg_fp_b_o     = 1'b1;\n                reg_fp_d_o     = 1'b1;\n              end else begin\n                reg_fp_a_o     = 1'b0;\n                reg_fp_b_o     = 1'b0;\n                reg_fp_d_o     = 1'b0;\n              end\n              fpu_vec_op       = 1'b1;\n              // replication bit comes from instruction (can change for some ops)\n              scalar_replication_o = instr_rdata_i[14];\n              // by default we need to verify rm is legal but assume it is for now\n              check_fprm       = 1'b1;\n              fp_rnd_mode_o    = frm_i; // all vectorial ops have rm from fcsr\n\n              // Decode Formats\n              unique case (instr_rdata_i[13:12])\n                // FP32\n                2'b00: begin\n                  fpu_dst_fmt_o  = cv32e40p_fpu_pkg::FP32;\n                  alu_vec_mode_o = VEC_MODE32;\n                end\n                // FP16ALT\n                2'b01: begin\n                  fpu_dst_fmt_o  = cv32e40p_fpu_pkg::FP16ALT;\n                  alu_vec_mode_o = VEC_MODE16;\n                end\n                // FP16\n                2'b10: begin\n                  fpu_dst_fmt_o  = cv32e40p_fpu_pkg::FP16;\n                  alu_vec_mode_o = VEC_MODE16;\n                end\n                // FP8\n                2'b11: begin\n                  fpu_dst_fmt_o  = cv32e40p_fpu_pkg::FP8;\n                  alu_vec_mode_o = VEC_MODE8;\n                end\n              endcase\n\n              // By default, src=dst\n              fpu_src_fmt_o = fpu_dst_fmt_o;\n\n              // decode vectorial FP instruction\n              unique case (instr_rdata_i[29:25]) inside\n                // vfadd.vfmt - Vectorial FP Addition\n                5'b00001: begin\n                  fpu_op      = cv32e40p_fpu_pkg::ADD;\n                  fp_op_group = ADDMUL;\n                  // FPnew needs addition operands as operand B and C\n                  alu_op_b_mux_sel_o     = OP_B_REGA_OR_FWD;\n                  alu_op_c_mux_sel_o     = OP_C_REGB_OR_FWD;\n                  scalar_replication_o   = 1'b0;\n                  scalar_replication_c_o = instr_rdata_i[14];\n                end\n                // vfsub.vfmt - Vectorial FP Subtraction\n                5'b00010: begin\n                  fpu_op      = cv32e40p_fpu_pkg::ADD;\n                  fpu_op_mod  = 1'b1;\n                  fp_op_group = ADDMUL;\n                  // FPnew needs addition operands as operand B and C\n                  alu_op_b_mux_sel_o     = OP_B_REGA_OR_FWD;\n                  alu_op_c_mux_sel_o     = OP_C_REGB_OR_FWD;\n                  scalar_replication_o   = 1'b0;\n                  scalar_replication_c_o = instr_rdata_i[14];\n                end\n                // vfmul.vfmt - Vectorial FP Multiplication\n                5'b00011: begin\n                  fpu_op      = cv32e40p_fpu_pkg::MUL;\n                  fp_op_group = ADDMUL;\n                end\n                // vfdiv.vfmt - Vectorial FP Division\n                5'b00100: begin\n                  fpu_op      = cv32e40p_fpu_pkg::DIV;\n                  fp_op_group = DIVSQRT;\n                end\n                // vfmin.vfmt - Vectorial FP Minimum\n                5'b00101: begin\n                  fpu_op        = cv32e40p_fpu_pkg::MINMAX;\n                  fp_rnd_mode_o = 3'b000; // min\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0; // instruction encoded in rm\n                end\n                // vfmax.vfmt - Vectorial FP Maximum\n                5'b00110: begin\n                  fpu_op        = cv32e40p_fpu_pkg::MINMAX;\n                  fp_rnd_mode_o = 3'b001; // max\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0; // instruction encoded in rm\n                end\n                // vfsqrt.vfmt - Vectorial FP Square Root\n                5'b00111: begin\n                  regb_used_o = 1'b0;\n                  fpu_op      = cv32e40p_fpu_pkg::SQRT;\n                  fp_op_group = DIVSQRT;\n                  // rs2 and R must be zero\n                  if ((instr_rdata_i[24:20] != 5'b00000) || instr_rdata_i[14]) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                // vfmac.vfmt - Vectorial FP Multiply-Accumulate\n                5'b01000: begin\n                  regc_used_o = 1'b1;\n                  regc_mux_o  = REGC_RD; // third operand is rd\n                  if (ZFINX == 0) begin\n                    reg_fp_c_o = 1'b1;\n                  end else begin\n                    reg_fp_c_o = 1'b0;\n                  end\n                  fpu_op      = cv32e40p_fpu_pkg::FMADD;\n                  fp_op_group = ADDMUL;\n                end\n                // vfmre.vfmt - Vectorial FP Multiply-Reduce\n                5'b01001: begin\n                  regc_used_o = 1'b1;\n                  regc_mux_o  = REGC_RD; // third operand is rd\n                  if (ZFINX == 0) begin\n                    reg_fp_c_o = 1'b1;\n                  end else begin\n                    reg_fp_c_o = 1'b0;\n                  end\n                  fpu_op      = cv32e40p_fpu_pkg::FMADD;\n                  fpu_op_mod  = 1'b1;\n                  fp_op_group = ADDMUL;\n                end\n                // Moves, Conversions, Classifications\n                5'b01100: begin\n                  regb_used_o          = 1'b0;\n                  scalar_replication_o = 1'b0;\n                  // Decode Operation in rs2\n                  unique case (instr_rdata_i[24:20]) inside\n                    // vfmv.{x.vfmt/vfmt.x} - Vectorial FP Reg <-> GP Reg Moves\n                    5'b00000: begin\n                      alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD; // set rs2 = rs1 so we can map FMV to SGNJ in the unit\n                      fpu_op             = cv32e40p_fpu_pkg::SGNJ;\n                      fp_rnd_mode_o      = 3'b011;  // passthrough without checking nan-box\n                      fp_op_group        = NONCOMP;\n                      check_fprm         = 1'b0;\n                      // GP reg to FP reg\n                      if (instr_rdata_i[14]) begin\n                        reg_fp_a_o       = 1'b0; // go from integer regfile\n                        fpu_op_mod       = 1'b0; // nan-box result\n                      end\n                      // FP reg to GP reg\n                      else begin\n                        reg_fp_d_o       = 1'b0; // go to integer regfile\n                        fpu_op_mod       = 1'b1; // sign-extend result\n                      end\n                    end\n                    // vfclass.vfmt - Vectorial FP Classifications\n                    5'b00001: begin\n                      reg_fp_d_o    = 1'b0; // go to integer regfile\n                      fpu_op        = cv32e40p_fpu_pkg::CLASSIFY;\n                      fp_rnd_mode_o = 3'b000;\n                      fp_op_group   = NONCOMP;\n                      check_fprm    = 1'b0;\n                      // R must not be set\n                      if (instr_rdata_i[14]) illegal_insn_o = 1'b1;\n                    end\n                    // vfcvt.{x.vfmt/vfmt.x} - Vectorial FP <-> Int Conversions\n                    5'b0001?: begin\n                      fp_op_group = CONV;\n                      fpu_op_mod  = instr_rdata_i[14]; // signed/unsigned switch\n                      // Integer width matches FP width\n                      unique case (instr_rdata_i[13:12])\n                        // FP32\n                        2'b00 : fpu_int_fmt_o = cv32e40p_fpu_pkg::INT32;\n                        // FP16[ALT]\n                        2'b01,\n                        2'b10: fpu_int_fmt_o = cv32e40p_fpu_pkg::INT16;\n                        // FP8\n                        2'b11: fpu_int_fmt_o = cv32e40p_fpu_pkg::INT8;\n                      endcase\n                      // Int to FP conversion\n                      if (instr_rdata_i[20]) begin\n                        reg_fp_a_o = 1'b0; // go from integer regfile\n                        fpu_op     = cv32e40p_fpu_pkg::I2F;\n                      end\n                      // FP to Int conversion\n                      else begin\n                        reg_fp_d_o = 1'b0; // go to integer regfile\n                        fpu_op     = cv32e40p_fpu_pkg::F2I;\n                      end\n                    end\n                    // vfcvt.vfmt.vfmt - Vectorial FP <-> FP Conversions\n                    5'b001??: begin\n                      fpu_op      = cv32e40p_fpu_pkg::F2F;\n                      fp_op_group = CONV;\n                      // check source format\n                      unique case (instr_rdata_i[21:20])\n                        // Only process instruction if corresponding extension is active (static)\n                        2'b00: begin\n                          fpu_src_fmt_o = cv32e40p_fpu_pkg::FP32;\n                          if (~C_RVF) illegal_insn_o = 1'b1;\n                        end\n                        2'b01: begin\n                          fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                          if (~C_XF16ALT) illegal_insn_o = 1'b1;\n                        end\n                        2'b10: begin\n                          fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16;\n                          if (~C_XF16) illegal_insn_o = 1'b1;\n                        end\n                        2'b11: begin\n                          fpu_src_fmt_o = cv32e40p_fpu_pkg::FP8;\n                          if (~C_XF8) illegal_insn_o = 1'b1;\n                        end\n                      endcase\n                      // R must not be set\n                      if (instr_rdata_i[14]) illegal_insn_o = 1'b1;\n                    end\n                    // others\n                    default : illegal_insn_o = 1'b1;\n                  endcase\n                end\n                // vfsgnj.vfmt - Vectorial FP Sign Injection\n                5'b01101: begin\n                  fpu_op        = cv32e40p_fpu_pkg::SGNJ;\n                  fp_rnd_mode_o = 3'b000; // sgnj\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfsgnjn.vfmt - Vectorial FP Negated Sign Injection\n                5'b01110: begin\n                  fpu_op        = cv32e40p_fpu_pkg::SGNJ;\n                  fp_rnd_mode_o = 3'b001; // sgnjn\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfsgnjx.vfmt - Vectorial FP Xored Sign Injection\n                5'b01111: begin\n                  fpu_op        = cv32e40p_fpu_pkg::SGNJ;\n                  fp_rnd_mode_o = 3'b010; // sgnjx\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfeq.vfmt - Vectorial FP Equals\n                5'b10000: begin\n                  reg_fp_d_o    = 1'b0; // go to integer regfile\n                  fpu_op        = cv32e40p_fpu_pkg::CMP;\n                  fp_rnd_mode_o = 3'b010; // eq\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfne.vfmt - Vectorial FP Not Equals\n                5'b10001: begin\n                  reg_fp_d_o    = 1'b0; // go to integer regfile\n                  fpu_op        = cv32e40p_fpu_pkg::CMP;\n                  fpu_op_mod    = 1'b1; // invert output\n                  fp_rnd_mode_o = 3'b010; // eq\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vflt.vfmt - Vectorial FP Less Than\n                5'b10010: begin\n                  reg_fp_d_o    = 1'b0; // go to integer regfile\n                  fpu_op        = cv32e40p_fpu_pkg::CMP;\n                  fp_rnd_mode_o = 3'b001; // lt\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfge.vfmt - Vectorial FP Greater Than or Equals\n                5'b10011: begin\n                  reg_fp_d_o    = 1'b0; // go to integer regfile\n                  fpu_op        = cv32e40p_fpu_pkg::CMP;\n                  fpu_op_mod    = 1'b1; // invert output\n                  fp_rnd_mode_o = 3'b001; // lt\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfle.vfmt - Vectorial FP Less Than or Equals\n                5'b10100: begin\n                  reg_fp_d_o    = 1'b0; // go to integer regfile\n                  fpu_op        = cv32e40p_fpu_pkg::CMP;\n                  fp_rnd_mode_o = 3'b000; // le\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfgt.vfmt - Vectorial FP Greater Than\n                5'b10101: begin\n                  reg_fp_d_o    = 1'b0; // go to integer regfile\n                  fpu_op        = cv32e40p_fpu_pkg::CMP;\n                  fpu_op_mod    = 1'b1; // invert output\n                  fp_rnd_mode_o = 3'b000; // le\n                  fp_op_group   = NONCOMP;\n                  check_fprm    = 1'b0;\n                end\n                // vfcpk{a-d}.vfmt.s/d\n                5'b110??: begin\n                  // vfcpk{{a/c}/{b/d}} selection in R bit\n                  fpu_op_mod           = instr_rdata_i[14];\n                  fp_op_group          = CONV;\n                  scalar_replication_o = 1'b0;\n\n                  if (instr_rdata_i[25]) fpu_op = cv32e40p_fpu_pkg::CPKCD; // vfcpk{c/d}\n                  else fpu_op = cv32e40p_fpu_pkg::CPKAB; // vfcpk{a/b}\n\n                  // vfcpk{a-d}.vfmt.d - from double\n                  if (instr_rdata_i[26]) begin\n                    fpu_src_fmt_o  = cv32e40p_fpu_pkg::FP64;\n                    if (~C_RVD) illegal_insn_o = 1'b1;\n                  end\n                  // vfcpk{a-d}.vfmt.s\n                  else begin\n                    fpu_src_fmt_o  = cv32e40p_fpu_pkg::FP32;\n                    if (~C_RVF) illegal_insn_o = 1'b1;\n                  end\n                  // Resolve legal vfcpk / format combinations (mostly static)\n                  if (fpu_op == cv32e40p_fpu_pkg::CPKCD) begin // vfcpk{c/d} not possible unless FP8 and FLEN>=64\n                    if (~C_XF8 || ~C_RVD) illegal_insn_o = 1'b1;\n                  end else begin\n                    if (instr_rdata_i[14]) begin // vfcpkb\n                      // vfcpkb not possible for FP32\n                      if (fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP32) illegal_insn_o = 1'b1;\n                      // vfcpkb not possible for FP16[ALT] if not RVD\n                      if (~C_RVD && (fpu_dst_fmt_o != cv32e40p_fpu_pkg::FP8)) illegal_insn_o = 1'b1;\n                    end\n                  end\n                end\n                // Rest are illegal instructions\n                default: begin\n                  illegal_insn_o = 1'b1;\n                end\n              endcase\n\n              // check enabled formats (static)\n              // need RVD for F vectors\n              if ((~C_RVF || ~C_RVD) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP32) illegal_insn_o = 1'b1;\n              // need RVF for F16 vectors\n              if ((~C_XF16 || ~C_RVF) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP16) illegal_insn_o = 1'b1;\n              // need RVF for F16 vectors\n              if ((~C_XF16ALT || ~C_RVF) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP16ALT) begin\n                illegal_insn_o = 1'b1;\n              end\n              // need F16 for F8 vectors\n              if ((~C_XF8 || (~C_XF16 && ~C_XF16ALT)) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP8) begin\n                illegal_insn_o = 1'b1;\n              end\n\n              // check rounding mode\n              if (check_fprm) begin\n                unique case (frm_i) inside\n                  [3'b000:3'b100] : ; //legal rounding modes\n                  default         : illegal_insn_o = 1'b1;\n                endcase\n              end\n\n              // Set latencies for FPnew from config. The C_LAT constants contain the number\n              // of pipeline registers. the APU takes the following values:\n              // 1 = single cycle (no latency), 2 = one pipestage, 3 = two or more pipestages\n              case (fp_op_group)\n                // ADDMUL has format dependent latency\n                ADDMUL : begin\n                  unique case (fpu_dst_fmt_o)\n                    cv32e40p_fpu_pkg::FP32    : apu_lat_o = (FPU_ADDMUL_LAT<2)? FPU_ADDMUL_LAT+1: 2'h3;\n                    cv32e40p_fpu_pkg::FP16    : apu_lat_o = (C_LAT_FP16<2)    ? C_LAT_FP16+1    : 2'h3;\n                    cv32e40p_fpu_pkg::FP16ALT : apu_lat_o = (C_LAT_FP16ALT<2) ? C_LAT_FP16ALT+1 : 2'h3;\n                    cv32e40p_fpu_pkg::FP8     : apu_lat_o = (C_LAT_FP8<2)     ? C_LAT_FP8+1     : 2'h3;\n                    default : ;\n                  endcase\n                end\n                // DIVSQRT is iterative and takes more than 2 cycles\n                DIVSQRT : apu_lat_o = 2'h3;\n                // NONCOMP uses the same latency for all formats\n                NONCOMP : apu_lat_o = (FPU_OTHERS_LAT<2) ? FPU_OTHERS_LAT+1 : 2'h3;\n                // CONV uses the same latency for all formats\n                CONV    : apu_lat_o = (FPU_OTHERS_LAT<2) ? FPU_OTHERS_LAT+1 : 2'h3;\n              endcase\n\n              // Set FPnew OP and OPMOD as the APU op\n              apu_op_o = {fpu_vec_op, fpu_op_mod, fpu_op};\n\n            // no FPU or FPU and no Vectors\n            end else begin\n              illegal_insn_o = 1'b1;\n            end\n          end // V"}
{"text": "ectorial Float Ops\n\n        end  // PREFIX 10\n\n        // PREFIX 00/01\n        else begin\n          regfile_alu_we = 1'b1;\n          rega_used_o    = 1'b1;\n\n          if (~instr_rdata_i[28]) regb_used_o = 1'b1;\n\n          unique case ({instr_rdata_i[30:25], instr_rdata_i[14:12]})\n            // RV32I ALU operations\n            {6'b00_0000, 3'b000}: alu_operator_o = ALU_ADD;   // Add\n            {6'b10_0000, 3'b000}: alu_operator_o = ALU_SUB;   // Sub\n            {6'b00_0000, 3'b010}: alu_operator_o = ALU_SLTS;  // Set Lower Than\n            {6'b00_0000, 3'b011}: alu_operator_o = ALU_SLTU;  // Set Lower Than Unsigned\n            {6'b00_0000, 3'b100}: alu_operator_o = ALU_XOR;   // Xor\n            {6'b00_0000, 3'b110}: alu_operator_o = ALU_OR;    // Or\n            {6'b00_0000, 3'b111}: alu_operator_o = ALU_AND;   // And\n            {6'b00_0000, 3'b001}: alu_operator_o = ALU_SLL;   // Shift Left Logical\n            {6'b00_0000, 3'b101}: alu_operator_o = ALU_SRL;   // Shift Right Logical\n            {6'b10_0000, 3'b101}: alu_operator_o = ALU_SRA;   // Shift Right Arithmetic\n\n            // supported RV32M instructions\n            {6'b00_0001, 3'b000}: begin // mul\n              alu_en          = 1'b0;\n              mult_int_en     = 1'b1;\n              mult_operator_o = MUL_MAC32;\n              regc_mux_o      = REGC_ZERO;\n            end\n            {6'b00_0001, 3'b001}: begin // mulh\n              alu_en             = 1'b0;\n              mult_int_en        = 1'b1;\n              regc_used_o        = 1'b1;\n              regc_mux_o         = REGC_ZERO;\n              mult_signed_mode_o = 2'b11;\n              mult_operator_o    = MUL_H;\n            end\n            {6'b00_0001, 3'b010}: begin // mulhsu\n              alu_en             = 1'b0;\n              mult_int_en        = 1'b1;\n              regc_used_o        = 1'b1;\n              regc_mux_o         = REGC_ZERO;\n              mult_signed_mode_o = 2'b01;\n              mult_operator_o    = MUL_H;\n            end\n            {6'b00_0001, 3'b011}: begin // mulhu\n              alu_en             = 1'b0;\n              mult_int_en        = 1'b1;\n              regc_used_o        = 1'b1;\n              regc_mux_o         = REGC_ZERO;\n              mult_signed_mode_o = 2'b00;\n              mult_operator_o    = MUL_H;\n            end\n            {6'b00_0001, 3'b100}: begin // div\n              alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;\n              alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD;\n              regb_used_o        = 1'b1;\n              alu_operator_o     = ALU_DIV;\n            end\n            {6'b00_0001, 3'b101}: begin // divu\n              alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;\n              alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD;\n              regb_used_o        = 1'b1;\n              alu_operator_o     = ALU_DIVU;\n            end\n            {6'b00_0001, 3'b110}: begin // rem\n              alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;\n              alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD;\n              regb_used_o        = 1'b1;\n              alu_operator_o     = ALU_REM;\n            end\n            {6'b00_0001, 3'b111}: begin // remu\n              alu_op_a_mux_sel_o = OP_A_REGB_OR_FWD;\n              alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD;\n              regb_used_o        = 1'b1;\n              alu_operator_o     = ALU_REMU;\n            end\n\n            default: begin\n              illegal_insn_o = 1'b1;\n            end\n          endcase\n        end\n      end\n\n      ////////////////////////////\n      //  ______ _____  _    _  //\n      // |  ____|  __ \\| |  | | //\n      // | |__  | |__) | |  | | //\n      // |  __| |  ___/| |  | | //\n      // | |    | |    | |__| | //\n      // |_|    |_|     \\____/  //\n      //                        //\n      ////////////////////////////\n\n      // Floating Point arithmetic\n      OPCODE_OP_FP: begin\n        if (FPU == 1 && (ZFINX == 1 || fs_off_i == 1'b0)) begin\n\n          // using APU instead of ALU\n          alu_en           = 1'b0;\n          apu_en           = 1'b1;\n          // by default, set all registers to FP registers and use 2\n          rega_used_o      = 1'b1;\n          regb_used_o      = 1'b1;\n          if (ZFINX == 0) begin\n            reg_fp_a_o     = 1'b1;\n            reg_fp_b_o     = 1'b1;\n            reg_fp_d_o     = 1'b1;\n          end else begin\n            reg_fp_a_o     = 1'b0;\n            reg_fp_b_o     = 1'b0;\n            reg_fp_d_o     = 1'b0;\n          end\n          // by default we need to verify rm is legal but assume it is for now\n          check_fprm       = 1'b1;\n          fp_rnd_mode_o    = instr_rdata_i[14:12];\n\n          // Decode Formats (preliminary, can change for some ops)\n          unique case (instr_rdata_i[26:25])\n            // FP32\n            2'b00: fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP32;\n            // FP64\n            2'b01: fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP64;\n            // FP16 or FP16ALT\n            2'b10: begin\n              // FP16alt encoded in rm field\n              if (instr_rdata_i[14:12] == 3'b101) fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n              // this can still change to FP16ALT\n              else fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16;\n            end\n            // FP8\n            2'b11: fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP8;\n          endcase\n\n          // By default, src=dst\n          fpu_src_fmt_o = fpu_dst_fmt_o;\n\n          // decode FP instruction\n          unique case (instr_rdata_i[31:27])\n            // fadd.fmt - FP Addition\n            5'b00000: begin\n              fpu_op             = cv32e40p_fpu_pkg::ADD;\n              fp_op_group        = ADDMUL;\n              apu_op_o           = 2'b0;\n              alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD;\n              alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;\n            end\n            // fsub.fmt - FP Subtraction\n            5'b00001: begin\n              fpu_op             = cv32e40p_fpu_pkg::ADD;\n              fpu_op_mod         = 1'b1;\n              fp_op_group        = ADDMUL;\n              apu_op_o           = 2'b1;\n              alu_op_b_mux_sel_o = OP_B_REGA_OR_FWD;\n              alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;\n            end\n            // fmul.fmt - FP Multiplication\n            5'b00010: begin\n              fpu_op      = cv32e40p_fpu_pkg::MUL;\n              fp_op_group = ADDMUL;\n            end\n            // fdiv.fmt - FP Division\n            5'b00011: begin\n              fpu_op      = cv32e40p_fpu_pkg::DIV;\n              fp_op_group = DIVSQRT;\n            end\n            // fsqrt.fmt - FP Square Root\n            5'b01011: begin\n              regb_used_o = 1'b0;\n              fpu_op      = cv32e40p_fpu_pkg::SQRT;\n              fp_op_group = DIVSQRT;\n              apu_op_o    = 1'b1;\n              // rs2 must be zero\n              if (instr_rdata_i[24:20] != 5'b00000) illegal_insn_o = 1'b1;\n            end\n            // fsgn{j[n]/jx}.fmt - FP Sign Injection\n            5'b00100: begin\n              fpu_op        = cv32e40p_fpu_pkg::SGNJ;\n              fp_op_group   = NONCOMP;\n              check_fprm    = 1'b0; // instruction encoded in rm, do the check here\n              if (C_XF16ALT) begin  // FP16ALT instructions encoded in rm separately (static)\n                if (!(instr_rdata_i[14:12] inside {[3'b000:3'b010], [3'b100:3'b110]})) begin\n                  illegal_insn_o = 1'b1;\n                end\n                // FP16ALT uses special encoding here\n                if (instr_rdata_i[14]) begin\n                  fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end else begin\n                  fp_rnd_mode_o = {1'b0, instr_rdata_i[13:12]};\n                end\n              end else begin\n                if (!(instr_rdata_i[14:12] inside {[3'b000:3'b010]})) illegal_insn_o = 1'b1;\n              end\n            end\n            // fmin/fmax.fmt - FP Minimum / Maximum\n            5'b00101: begin\n              fpu_op        = cv32e40p_fpu_pkg::MINMAX;\n              fp_op_group   = NONCOMP;\n              check_fprm    = 1'b0; // instruction encoded in rm, do the check here\n              if (C_XF16ALT) begin  // FP16ALT instructions encoded in rm separately (static)\n                if (!(instr_rdata_i[14:12] inside {[3'b000:3'b001], [3'b100:3'b101]})) begin\n                  illegal_insn_o = 1'b1;\n                end\n                // FP16ALT uses special encoding here\n                if (instr_rdata_i[14]) begin\n                  fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end else begin\n                  fp_rnd_mode_o = {1'b0, instr_rdata_i[13:12]};\n                end\n              end else begin\n                if (!(instr_rdata_i[14:12] inside {[3'b000:3'b001]})) illegal_insn_o = 1'b1;\n              end\n            end\n            // fcvt.fmt.fmt - FP to FP Conversion\n            5'b01000: begin\n              regb_used_o   = 1'b0;\n              fpu_op        = cv32e40p_fpu_pkg::F2F;\n              fp_op_group   = CONV;\n              // bits [22:20] used, other bits must be 0\n              if (instr_rdata_i[24:23]) illegal_insn_o = 1'b1;\n              // check source format\n              unique case (instr_rdata_i[22:20])\n                // Only process instruction if corresponding extension is active (static)\n                3'b000: begin\n                  if (!(C_RVF && (C_XF16 || C_XF16ALT || C_XF8))) illegal_insn_o = 1'b1;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP32;\n                end\n                3'b001: begin\n                  if (~C_RVD) illegal_insn_o = 1'b1;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP64;\n                end\n                3'b010: begin\n                  if (~C_XF16) illegal_insn_o = 1'b1;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16;\n                end\n                3'b110: begin\n                  if (~C_XF16ALT) illegal_insn_o = 1'b1;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end\n                3'b011: begin\n                  if (~C_XF8) illegal_insn_o = 1'b1;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP8;\n                end\n                default: illegal_insn_o = 1'b1;\n              endcase\n            end\n            // fmulex.s.fmt - FP Expanding Multiplication to FP32\n            5'b01001: begin\n              if (~C_XF16 && ~C_XF16ALT && ~C_XF8) illegal_insn_o = 1;\n              fpu_op        = cv32e40p_fpu_pkg::MUL;\n              fp_op_group   = ADDMUL;\n              // set dst format to FP32\n              fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP32;\n            end\n            // fmacex.s.fmt - FP Expanding Multipy-Accumulate to FP32\n            5'b01010: begin\n              if (~C_XF16 && ~C_XF16ALT && ~C_XF8) illegal_insn_o = 1;\n              regc_used_o = 1'b1;\n              regc_mux_o  = REGC_RD; // third operand is rd\n              if (ZFINX == 0) begin\n                reg_fp_c_o = 1'b1;\n              end else begin\n                reg_fp_c_o = 1'b0;\n              end\n              fpu_op      = cv32e40p_fpu_pkg::FMADD;\n              fp_op_group = ADDMUL;\n              // set dst format to FP32\n              fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP32;\n            end\n            // feq/flt/fle.fmt - FP Comparisons\n            5'b10100: begin\n              fpu_op        = cv32e40p_fpu_pkg::CMP;\n              fp_op_group   = NONCOMP;\n              reg_fp_d_o    = 1'b0; // go to integer regfile\n              check_fprm    = 1'b0; // instruction encoded in rm, do the check here\n              if (C_XF16ALT) begin  // FP16ALT instructions encoded in rm separately (static)\n                if (!(instr_rdata_i[14:12] inside {[3'b000:3'b010], [3'b100:3'b110]})) begin\n                  illegal_insn_o = 1'b1;\n                end\n                // FP16ALT uses special encoding here\n                if (instr_rdata_i[14]) begin\n                  fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end else begin\n                  fp_rnd_mode_o = {1'b0, instr_rdata_i[13:12]};\n                end\n              end else begin\n                if (!(instr_rdata_i[14:12] inside {[3'b000:3'b010]})) illegal_insn_o = 1'b1;\n              end\n            end\n            // fcvt.ifmt.fmt - FP to Int Conversion\n            5'b11000: begin\n              regb_used_o = 1'b0;\n              reg_fp_d_o  = 1'b0; // go to integer regfile\n              fpu_op      = cv32e40p_fpu_pkg::F2I;\n              fp_op_group = CONV;\n              fpu_op_mod  = instr_rdata_i[20]; // signed/unsigned switch\n              apu_op_o    = 2'b1;\n\n              unique case (instr_rdata_i[26:25]) //fix for casting to different formats other than FP32\n                2'b00: begin\n                  if (~C_RVF) illegal_insn_o = 1;\n                  else fpu_src_fmt_o = cv32e40p_fpu_pkg::FP32;\n                end\n                2'b01: begin\n                  if (~C_RVD) illegal_insn_o = 1;\n                  else fpu_src_fmt_o = cv32e40p_fpu_pkg::FP64;\n                end\n                2'b10: begin\n                  if (instr_rdata_i[14:12] == 3'b101) begin\n                    if (~C_XF16ALT) illegal_insn_o = 1;\n                    else fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  end else if (~C_XF16) begin\n                    illegal_insn_o = 1;\n                  end else begin\n                    fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16;\n                  end\n                end\n                2'b11: begin\n                  if (~C_XF8) illegal_insn_o = 1;\n                  else fpu_src_fmt_o = cv32e40p_fpu_pkg::FP8;\n                end\n              endcase // unique case (instr_rdata_i[26:25])\n              // bits [21:20] used, other bits must be 0\n              if (instr_rdata_i[24:21]) illegal_insn_o = 1'b1;   // in RV32, no casts to L allowed.\n            end\n            // fcvt.fmt.ifmt - Int to FP Conversion\n            5'b11010: begin\n              regb_used_o = 1'b0;\n              reg_fp_a_o  = 1'b0; // go from integer regfile\n              fpu_op      = cv32e40p_fpu_pkg::I2F;\n              fp_op_group = CONV;\n              fpu_op_mod  = instr_rdata_i[20]; // signed/unsigned switch\n              apu_op_o    = 2'b0;\n              // bits [21:20] used, other bits must be 0\n              if (instr_rdata_i[24:21]) illegal_insn_o = 1'b1;   // in RV32, no casts to L allowed.\n            end\n            // move and class\n            5'b11100: begin\n              regb_used_o = 1'b0;\n              reg_fp_d_o  = 1'b0; // go to integer regfile\n              fp_op_group = NONCOMP;\n              check_fprm  = 1'b0; // instruction encoded in rm, do the check here\n              // fmv.x.fmt - FPR to GPR Move\n              if ((ZFINX == 0 && instr_rdata_i[14:12] == 3'b000) || (C_XF16ALT && instr_rdata_i[14:12] == 3'b100)) begin\n                alu_op_b_mux_sel_o  = OP_B_REGA_OR_FWD; // set rs2 = rs1 so we can map FMV to SGNJ in the unit\n                fpu_op              = cv32e40p_fpu_pkg::SGNJ; // mapped to SGNJ-passthrough since no recoding\n                fpu_op_mod          = 1'b1;    // sign-extend result\n                fp_rnd_mode_o       = 3'b011;  // passthrough without checking nan-box\n                // FP16ALT uses special encoding here\n                if (instr_rdata_i[14]) begin\n                  fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end\n              // fclass.fmt - FP Classify\n              end else if (instr_rdata_i[14:12] == 3'b001 || (C_XF16ALT && instr_rdata_i[14:12] == 3'b101)) begin\n                fpu_op        = cv32e40p_fpu_pkg::CLASSIFY;\n                fp_rnd_mode_o = 3'b000;\n                // FP16ALT uses special encoding here\n                if (instr_rdata_i[14]) begin\n                  fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end\n              end else begin\n                illegal_insn_o = 1'b1;\n              end\n              // rs2 must be zero\n              if (instr_rdata_i[24:20]) illegal_insn_o = 1'b1;\n            end\n            // fmv.fmt.x - GPR to FPR Move\n            5'b11110: begin\n              regb_used_o         = 1'b0;\n              reg_fp_a_o          = 1'b0; // go from integer regfile\n              alu_op_b_mux_sel_o  = OP_B_REGA_OR_FWD; // set rs2 = rs1 so we can map FMV to SGNJ in the unit\n              fpu_op              = cv32e40p_fpu_pkg::SGNJ; // mapped to SGNJ-passthrough since no recoding\n              fpu_op_mod          = 1'b0;    // nan-box result\n              fp_op_group         = NONCOMP;\n              fp_rnd_mode_o       = 3'b011;  // passthrough without checking nan-box\n              check_fprm          = 1'b0; // instruction encoded in rm, do the check here\n              if ((ZFINX == 0 && instr_rdata_i[14:12] == 3'b000) || (C_XF16ALT && instr_rdata_i[14:12] == 3'b100)) begin\n                // FP16ALT uses special encoding here\n                if (instr_rdata_i[14]) begin\n                  fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                  fpu_src_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n                end\n              end else begin\n                illegal_insn_o = 1'b1;\n              end\n              // rs2 must be zero\n              if (instr_rdata_i[24:20] != 5'b00000) illegal_insn_o = 1'b1;\n            end\n            // Rest are illegal instructions\n            default: illegal_insn_o = 1'b1;\n          endcase\n\n          // check enabled formats (static)\n          if (~C_RVF && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP32) illegal_insn_o = 1'b1;\n          if ((~C_RVD) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP64) illegal_insn_o = 1'b1;\n          if ((~C_XF16) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP16) illegal_insn_o = 1'b1;\n          if ((~C_XF16ALT) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP16ALT) begin\n            illegal_insn_o = 1'b1;\n          end\n          if ((~C_XF8) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP8) illegal_insn_o = 1'b1;\n\n          // check rounding mode\n          if (check_fprm) begin\n            unique case (instr_rdata_i[14:12]) inside\n              [3'b000:3'b100]: ; //legal rounding modes\n              3'b101: begin      // Alternative Half-Precsision encded as fmt=10 and rm=101\n                if (~C_XF16ALT || fpu_dst_fmt_o != cv32e40p_fpu_pkg::FP16ALT) illegal_insn_o = 1'b1;\n                // actual rounding mode from frm csr\n                unique case (frm_i) inside\n                  [3'b000:3'b100] : fp_rnd_mode_o = frm_i; //legal rounding modes\n                  default         : illegal_insn_o = 1'b1;\n                endcase\n              end\n              3'b111: begin\n                // rounding mode from frm csr\n                unique case (frm_i) inside\n                  [3'b000:3'b100] : fp_rnd_mode_o = frm_i; //legal rounding modes\n                  default         : illegal_insn_o = 1'b1;\n                endcase\n              end\n              default : illegal_insn_o = 1'b1;\n            endcase\n          end\n\n          // Set latencies for FPnew from config. The C_LAT constants contain the number\n          // of pipeline registers. the APU takes the following values:\n          // 1 = single cycle (no latency), 2 = one pipestage, 3 = two or more pipestages\n          case (fp_op_group)\n            // ADDMUL has format dependent latency\n            ADDMUL : begin\n              unique case (fpu_dst_fmt_o)\n                cv32e40p_fpu_pkg::FP32    : apu_lat_o = (FPU_ADDMUL_LAT<2)? FPU_ADDMUL_LAT+1: 2'h3;\n                cv32e40p_fpu_pkg::FP64    : apu_lat_o = (C_LAT_FP64<2)    ? C_LAT_FP64+1    : 2'h3;\n                cv32e40p_fpu_pkg::FP16    : apu_lat_o = (C_LAT_FP16<2)    ? C_LAT_FP16+1    : 2'h3;\n                cv32e40p_fpu_pkg::FP16ALT : apu_lat_o = (C_LAT_FP16ALT<2) ? C_LAT_FP16ALT+1 : 2'h3;\n                cv32e40p_fpu_pkg::FP8     : apu_lat_o = (C_LAT_FP8<2) "}
{"text": "    ? C_LAT_FP8+1     : 2'h3;\n                default : ;\n              endcase\n            end\n            // DIVSQRT is iterative and takes more than 2 cycles\n            DIVSQRT : apu_lat_o = 2'h3;\n            // NONCOMP uses the same latency for all formats\n            NONCOMP : apu_lat_o = (FPU_OTHERS_LAT<2) ? FPU_OTHERS_LAT+1 : 2'h3;\n            // CONV uses the same latency for all formats\n            CONV    : apu_lat_o = (FPU_OTHERS_LAT<2) ? FPU_OTHERS_LAT+1 : 2'h3;\n          endcase\n\n          // Set FPnew OP and OPMOD as the APU op\n          apu_op_o = {fpu_vec_op, fpu_op_mod, fpu_op};\n\n        // No FPU or (ZFINX == 0 && MSTATUS.FS == FS_OFF)\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      // Floating Point fused arithmetic\n      OPCODE_OP_FMADD,\n      OPCODE_OP_FMSUB,\n      OPCODE_OP_FNMSUB,\n      OPCODE_OP_FNMADD : begin\n        if (FPU == 1 && (ZFINX == 1 || fs_off_i == 1'b0)) begin\n          // using APU instead of ALU\n          alu_en        = 1'b0;\n          apu_en        = 1'b1;\n          // all registers are FP registers and use three\n          rega_used_o   = 1'b1;\n          regb_used_o   = 1'b1;\n          regc_used_o   = 1'b1;\n          regc_mux_o    = REGC_S4;\n          if (ZFINX == 0) begin\n            reg_fp_a_o  = 1'b1;\n            reg_fp_b_o  = 1'b1;\n            reg_fp_c_o  = 1'b1;\n            reg_fp_d_o  = 1'b1;\n          end else begin\n            reg_fp_a_o  = 1'b0;\n            reg_fp_b_o  = 1'b0;\n            reg_fp_c_o  = 1'b0;\n            reg_fp_d_o  = 1'b0;\n          end\n          fp_rnd_mode_o = instr_rdata_i[14:12];\n\n          // Decode Formats\n          unique case (instr_rdata_i[26:25])\n            // FP32\n            2'b00 : fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP32;\n            // FP64\n            2'b01 : fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP64;\n            // FP16 or FP16ALT\n            2'b10 : begin\n              // FP16alt encoded in rm field\n              if (instr_rdata_i[14:12] == 3'b101) fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16ALT;\n              else fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP16;\n            end\n            // FP8\n            2'b11 : fpu_dst_fmt_o = cv32e40p_fpu_pkg::FP8;\n          endcase\n\n          // By default, src=dst\n          fpu_src_fmt_o = fpu_dst_fmt_o;\n\n          // decode FP intstruction\n          unique case (instr_rdata_i[6:0])\n            // fmadd.fmt - FP Fused multiply-add\n            OPCODE_OP_FMADD : begin\n              fpu_op      = cv32e40p_fpu_pkg::FMADD;\n              apu_op_o    = 2'b00;\n            end\n            // fmsub.fmt - FP Fused multiply-subtract\n            OPCODE_OP_FMSUB : begin\n              fpu_op      = cv32e40p_fpu_pkg::FMADD;\n              fpu_op_mod  = 1'b1;\n              apu_op_o    = 2'b01;\n            end\n            // fnmsub.fmt - FP Negated fused multiply-subtract\n            OPCODE_OP_FNMSUB : begin\n              fpu_op      = cv32e40p_fpu_pkg::FNMSUB;\n              apu_op_o    = 2'b10;\n            end\n            // fnmadd.fmt - FP Negated fused multiply-add\n            OPCODE_OP_FNMADD : begin\n              fpu_op      = cv32e40p_fpu_pkg::FNMSUB;\n              fpu_op_mod  = 1'b1;\n              apu_op_o    = 2'b11;\n            end\n            default : ;\n          endcase\n\n          // check enabled formats (static)\n          if (~C_RVF && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP32) illegal_insn_o = 1'b1;\n          if ((~C_RVD) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP64) illegal_insn_o = 1'b1;\n          if ((~C_XF16) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP16) illegal_insn_o = 1'b1;\n          if ((~C_XF16ALT) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP16ALT) begin\n            illegal_insn_o = 1'b1;\n          end\n          if ((~C_XF8) && fpu_dst_fmt_o == cv32e40p_fpu_pkg::FP8) illegal_insn_o = 1'b1;\n\n          // check rounding mode\n          unique case (instr_rdata_i[14:12]) inside\n            [3'b000:3'b100]: ; //legal rounding modes\n            3'b101: begin      // Alternative Half-Precsision encded as fmt=10 and rm=101\n              if (~C_XF16ALT || fpu_dst_fmt_o != cv32e40p_fpu_pkg::FP16ALT) illegal_insn_o = 1'b1;\n              // actual rounding mode from frm csr\n              unique case (frm_i) inside\n                [3'b000:3'b100] : fp_rnd_mode_o = frm_i; //legal rounding modes\n                default         : illegal_insn_o = 1'b1;\n              endcase\n            end\n            3'b111: begin\n              // rounding mode from frm csr\n              unique case (frm_i) inside\n                [3'b000:3'b100] : fp_rnd_mode_o = frm_i; //legal rounding modes\n                default         : illegal_insn_o = 1'b1;\n              endcase\n            end\n            default : illegal_insn_o = 1'b1;\n          endcase\n\n          // Set latencies for FPnew from config. The C_LAT constants contain the number\n          // of pipeline registers. the APU takes the following values:\n          // 1 = single cycle (no latency), 2 = one pipestage, 3 = two or more pipestages\n          // format dependent latency\n          unique case (fpu_dst_fmt_o)\n            cv32e40p_fpu_pkg::FP32    : apu_lat_o = (FPU_ADDMUL_LAT<2)? FPU_ADDMUL_LAT+1: 2'h3;\n            cv32e40p_fpu_pkg::FP64    : apu_lat_o = (C_LAT_FP64<2)    ? C_LAT_FP64+1    : 2'h3;\n            cv32e40p_fpu_pkg::FP16    : apu_lat_o = (C_LAT_FP16<2)    ? C_LAT_FP16+1    : 2'h3;\n            cv32e40p_fpu_pkg::FP16ALT : apu_lat_o = (C_LAT_FP16ALT<2) ? C_LAT_FP16ALT+1 : 2'h3;\n            cv32e40p_fpu_pkg::FP8     : apu_lat_o = (C_LAT_FP8<2)     ? C_LAT_FP8+1     : 2'h3;\n            default : ;\n          endcase\n\n          // Set FPnew OP and OPMOD as the APU op\n          apu_op_o = {fpu_vec_op, fpu_op_mod, fpu_op};\n        // No FPU or (ZFINX == 0 && MSTATUS.FS == FS_OFF)\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      OPCODE_STORE_FP: begin\n        if (FPU == 1 && ZFINX == 0 && fs_off_i == 1'b0) begin\n          data_req            = 1'b1;\n          data_we_o           = 1'b1;\n          rega_used_o         = 1'b1;\n          regb_used_o         = 1'b1;\n          alu_operator_o      = ALU_ADD;\n          reg_fp_b_o          = 1'b1;\n\n          // offset from immediate\n          imm_b_mux_sel_o     = IMMB_S;\n          alu_op_b_mux_sel_o  = OP_B_IMM;\n\n          // pass write data through ALU operand c\n          alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;\n\n          // Decode data type\n          unique case (instr_rdata_i[14:12])\n            // fsb - FP8 store\n            3'b000 : if (C_XF8) data_type_o = 2'b10;\n                     else illegal_insn_o = 1'b1;\n            // fsh - FP16 store\n            3'b001 : if (C_XF16 | C_XF16ALT) data_type_o = 2'b01;\n                     else illegal_insn_o = 1'b1;\n            // fsw - FP32 store\n            3'b010 : if (C_RVF) data_type_o = 2'b00;\n                     else illegal_insn_o = 1'b1;\n            // fsd - FP64 store\n            3'b011 : if (C_RVD) data_type_o = 2'b00; // 64bit stores unsupported!\n                     else illegal_insn_o = 1'b1;\n            default: illegal_insn_o = 1'b1;\n          endcase\n\n          // sanitize memory bus signals for illegal instr (not sure if needed??)\n          if (illegal_insn_o) begin\n            data_req       = 1'b0;\n            data_we_o      = 1'b0;\n          end\n        // No FPU or ZFINX or MSTATUS.FS == FS_OFF\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      OPCODE_LOAD_FP: begin\n        if (FPU == 1 && ZFINX == 0 && fs_off_i == 1'b0) begin\n          data_req            = 1'b1;\n          regfile_mem_we      = 1'b1;\n          reg_fp_d_o          = 1'b1;\n          rega_used_o         = 1'b1;\n          alu_operator_o      = ALU_ADD;\n\n          // offset from immediate\n          imm_b_mux_sel_o     = IMMB_I;\n          alu_op_b_mux_sel_o  = OP_B_IMM;\n\n          // NaN boxing\n          data_sign_extension_o = 2'b10;\n\n          // Decode data type\n          unique case (instr_rdata_i[14:12])\n            // flb - FP8 load\n            3'b000 : if (C_XF8) data_type_o = 2'b10;\n                     else illegal_insn_o = 1'b1;\n            // flh - FP16 load\n            3'b001 : if (C_XF16 | C_XF16ALT) data_type_o = 2'b01;\n                     else illegal_insn_o = 1'b1;\n            // flw - FP32 load\n            3'b010 : if (C_RVF) data_type_o = 2'b00;\n                     else illegal_insn_o = 1'b1;\n            // fld - FP64 load\n            3'b011 : if (C_RVD) data_type_o = 2'b00; // 64bit loads unsupported!\n                     else illegal_insn_o = 1'b1;\n            default: illegal_insn_o = 1'b1;\n          endcase\n        // No FPU or ZFINX or MSTATUS.FS == FS_OFF\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      OPCODE_CUSTOM_0: begin\n        if (COREV_PULP && instr_rdata_i[14:13] != 2'b11) begin // cv.l[bhw][u] and cv.elw\n          data_req           = 1'b1;\n          regfile_mem_we     = 1'b1;\n          rega_used_o        = 1'b1;\n          alu_operator_o     = ALU_ADD;\n          // offset from immediate\n          alu_op_b_mux_sel_o = OP_B_IMM;\n          imm_b_mux_sel_o    = IMMB_I;\n\n          // post-increment setup\n          if (instr_rdata_i[13:12] != 2'b11) begin\n            prepost_useincr_o       = 1'b0;\n            regfile_alu_waddr_sel_o = 1'b0;\n            regfile_alu_we          = 1'b1;\n          end\n\n          // sign/zero extension\n          data_sign_extension_o = {1'b0,~instr_rdata_i[14]};\n\n          // load size\n          unique case (instr_rdata_i[13:12])\n            2'b00  : data_type_o = 2'b10; // LB/LBU\n            2'b01  : data_type_o = 2'b01; // LH/LHU\n            default: data_type_o = 2'b00; // LW/ELW\n          endcase\n\n          // special cv.elw (event load)\n          if (instr_rdata_i[13:12] == 2'b11) begin\n            if (COREV_CLUSTER) begin\n              data_load_event_o = 1'b1;\n            end else begin\n              // cv.elw only valid for COREV_CLUSTER = 1\n              illegal_insn_o    = 1'b1;\n            end\n          end\n        end else if (COREV_PULP) begin   // cv.beqimm and cv.bneimm \n          ctrl_transfer_target_mux_sel_o = JT_COND;\n          ctrl_transfer_insn             = BRANCH_COND;\n          alu_op_c_mux_sel_o             = OP_C_JT;\n          rega_used_o                    = 1'b1;\n          // offset from immediate\n          alu_op_b_mux_sel_o             = OP_B_IMM;\n          imm_b_mux_sel_o                = IMMB_BI;\n\n          if (instr_rdata_i[12] == 1'b0) begin // cv.beqimm\n            alu_operator_o      = ALU_EQ;\n          end else begin                       // cv.bneimm\n            alu_operator_o      = ALU_NE;\n          end\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      OPCODE_CUSTOM_1: begin\n        if (COREV_PULP) begin\n          unique case (instr_rdata_i[14:12])\n            3'b000, 3'b001, 3'b010: begin  // Immediate Post-Incremented Store\n              data_req                = 1'b1;\n              data_we_o               = 1'b1;\n              rega_used_o             = 1'b1;\n              regb_used_o             = 1'b1;\n              alu_operator_o          = ALU_ADD;\n              // pass write data through ALU operand c\n              alu_op_c_mux_sel_o      = OP_C_REGB_OR_FWD;\n              // offset from immediate\n              imm_b_mux_sel_o         = IMMB_S;\n              alu_op_b_mux_sel_o      = OP_B_IMM;\n\n              // post-increment setup\n              prepost_useincr_o       = 1'b0;\n              regfile_alu_waddr_sel_o = 1'b0;\n              regfile_alu_we          = 1'b1;\n\n              // store size\n              unique case (instr_rdata_i[13:12])\n                2'b00  : data_type_o = 2'b10; // SB\n                2'b01  : data_type_o = 2'b01; // SH\n                default: data_type_o = 2'b00; // SW\n              endcase\n            end\n\n            3'b011 : begin // Plane A\n              unique case (instr_rdata_i[31:25])\n                7'b0000000, 7'b0000001, 7'b0000010, 7'b0000011,         // Register Post-Incremented          Load\n                7'b0000100, 7'b0000101, 7'b0000110, 7'b0000111,         // Register Indexed                   Load\n                7'b0001000, 7'b0001001, 7'b0001010, 7'b0001011,         // Register Post-Incremented Unsigned Load\n                7'b0001100, 7'b0001101, 7'b0001110, 7'b0001111: begin   // Register Indexed          Unsigned Load\n                  data_req           = 1'b1;\n                  regfile_mem_we     = 1'b1;\n                  rega_used_o        = 1'b1;\n                  alu_operator_o     = ALU_ADD;\n                  // offset from RS2\n                  regb_used_o        = 1'b1;\n                  alu_op_b_mux_sel_o = OP_B_REGB_OR_FWD;\n\n                  // post-increment setup\n                  if (instr_rdata_i[27] == 1'b0) begin\n                    prepost_useincr_o       = 1'b0;\n                    regfile_alu_waddr_sel_o = 1'b0;\n                    regfile_alu_we          = 1'b1;\n                  end\n\n                  // sign/zero extension\n                  data_sign_extension_o = {1'b0,~instr_rdata_i[28]};\n\n                  // load size\n                  unique case ({instr_rdata_i[28],instr_rdata_i[26:25]})\n                    3'b000 : data_type_o = 2'b10; // LB\n                    3'b001 : data_type_o = 2'b01; // LH\n                    3'b010 : data_type_o = 2'b00; // LW\n                    3'b100 : data_type_o = 2'b10; // LBU\n                    3'b101 : data_type_o = 2'b01; // LHU\n                    default: begin\n                      illegal_insn_o = 1'b1;\n                      data_req       = 1'b0;\n                      regfile_mem_we = 1'b0;\n                      regfile_alu_we = 1'b0;\n                    end\n                  endcase\n                end\n\n                7'b0010000, 7'b0010001, 7'b0010010, 7'b0010011,         // Register Post-Incremented Store\n                7'b0010100, 7'b0010101, 7'b0010110, 7'b0010111: begin   // Register Indexed          Store\n                  data_req           = 1'b1;\n                  data_we_o          = 1'b1;\n                  rega_used_o        = 1'b1;\n                  regb_used_o        = 1'b1;\n                  alu_operator_o     = ALU_ADD;\n                  // pass write data through ALU operand c\n                  alu_op_c_mux_sel_o = OP_C_REGB_OR_FWD;\n                  // offset from register\n                  regc_used_o        = 1'b1;\n                  alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;\n                  regc_mux_o         = REGC_RD;\n\n                  // post-increment setup\n                  if (instr_rdata_i[27] == 1'b0) begin\n                    prepost_useincr_o       = 1'b0;\n                    regfile_alu_waddr_sel_o = 1'b0;\n                    regfile_alu_we          = 1'b1;\n                  end\n\n                  // store size\n                  unique case (instr_rdata_i[26:25])\n                    2'b00  : data_type_o = 2'b10; // SB\n                    2'b01  : data_type_o = 2'b01; // SH\n                    2'b10  : data_type_o = 2'b00; // SW\n                    default: begin\n                      illegal_insn_o = 1'b1;\n                      data_req       = 1'b0;\n                      data_we_o      = 1'b0;\n                      data_type_o    = 2'b00;\n                    end\n                  endcase\n                end\n\n                7'b0011000, 7'b0011001, 7'b0011010, 7'b0011011,\n                7'b0011100, 7'b0011101, 7'b0011110, 7'b0011111: begin   // Register Bit-Manipulation\n                  regfile_alu_we        = 1'b1;\n                  rega_used_o           = 1'b1;\n                  regb_used_o           = 1'b1;\n\n                  bmask_a_mux_o         = BMASK_A_S3;\n                  bmask_b_mux_o         = BMASK_B_S2;\n                  alu_op_b_mux_sel_o    = OP_B_IMM;\n                  alu_bmask_a_mux_sel_o = BMASK_A_REG;\n\n                  unique case (instr_rdata_i[27:25])\n                    3'b000: begin                                      // cv.extractr\n                      alu_operator_o        = ALU_BEXT;\n                      imm_b_mux_sel_o       = IMMB_S2;\n                      bmask_b_mux_o         = BMASK_B_ZERO;\n                      alu_op_b_mux_sel_o    = OP_B_BMASK;\n                    end\n                    3'b001: begin                                      // cv.extractur\n                      alu_operator_o        = ALU_BEXTU;\n                      imm_b_mux_sel_o       = IMMB_S2;\n                      bmask_b_mux_o         = BMASK_B_ZERO;\n                      alu_op_b_mux_sel_o    = OP_B_BMASK;\n                    end\n                    3'b010: begin                                      // cv.insertr\n                      alu_operator_o        = ALU_BINS;\n                      imm_b_mux_sel_o       = IMMB_S2;\n                      regc_used_o           = 1'b1;\n                      regc_mux_o            = REGC_RD;\n                      alu_op_b_mux_sel_o    = OP_B_BMASK;\n                      alu_bmask_b_mux_sel_o = BMASK_B_REG;\n                    end\n                    3'b100: begin                                      // cv.bclrr\n                      alu_operator_o        = ALU_BCLR;\n                      alu_bmask_b_mux_sel_o = BMASK_B_REG;\n                    end\n                    3'b101: begin                                      // cv.bsetr\n                      alu_operator_o        = ALU_BSET;\n                      alu_bmask_b_mux_sel_o = BMASK_B_REG;\n                    end\n                    default: illegal_insn_o = 1'b1;\n                  endcase\n                end\n\n                7'b0100000, 7'b0100001, 7'b0100010, 7'b0100011,\n                7'b0100100, 7'b0100101, 7'b0100110, 7'b0100111,\n                7'b0101000, 7'b0101001, 7'b0101010, 7'b0101011,\n                7'b0101100, 7'b0101101, 7'b0101110, 7'b0101111,\n                7'b0110000, 7'b0110001, 7'b0110010, 7'b0110011,\n                7'b0110100, 7'b0110101, 7'b0110110, 7'b0110111,\n                7'b0111000, 7'b0111001, 7'b0111010, 7'b0111011,\n                7'b0111100, 7'b0111101, 7'b0111110, 7'b0111111: begin  // General ALU\n                  regfile_alu_we = 1'b1;\n                  rega_used_o    = 1'b1;\n                  regb_used_o    = 1'b1;\n\n                  unique case (instr_rdata_i[29:25])\n                    5'b00000: alu_operator_o = ALU_ROR;                // cv.ror\n                    5'b00001: begin                                    // cv.ff1\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_FF1;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b00010: begin                                    // cv.fl1\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_FL1;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b00011: begin                                    // cv.clb\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_CLB;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b00100: begin                                    // cv.cnt\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_CNT;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b01000: begin                                    // cv.abs\n                      alu_operator_o = ALU_ABS;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n  "}
{"text": "                  5'b01001: alu_operator_o = ALU_SLETS;              // cv.slet\n                    5'b01010: alu_operator_o = ALU_SLETU;              // cv.sletu\n                    5'b01011: alu_operator_o = ALU_MIN;                // cv.min\n                    5'b01100: alu_operator_o = ALU_MINU;               // cv.minu\n                    5'b01101: alu_operator_o = ALU_MAX;                // cv.max\n                    5'b01110: alu_operator_o = ALU_MAXU;               // cv.maxu\n                    5'b10000: begin                                    // cv.exths\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_EXTS;\n                      alu_vec_mode_o = VEC_MODE16;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b10001: begin                                    // cv.exthz\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_EXT;\n                      alu_vec_mode_o = VEC_MODE16;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b10010: begin                                    // cv.extbs\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_EXTS;\n                      alu_vec_mode_o = VEC_MODE8;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b10011: begin                                    // cv.extbz\n                      regb_used_o    = 1'b0;\n                      alu_operator_o = ALU_EXT;\n                      alu_vec_mode_o = VEC_MODE8;\n                      if (instr_rdata_i[24:20] != 5'b0) begin\n                        illegal_insn_o = 1'b1;\n                      end\n                    end\n                    5'b11000: begin                                    // cv.clip\n                      regb_used_o        = 1'b0;\n                      alu_operator_o     = ALU_CLIP;\n                      alu_op_b_mux_sel_o = OP_B_IMM;\n                      imm_b_mux_sel_o    = IMMB_CLIP;\n                    end\n                    5'b11001: begin                                    // cv.clipu\n                      regb_used_o        = 1'b0;\n                      alu_operator_o     = ALU_CLIPU;\n                      alu_op_b_mux_sel_o = OP_B_IMM;\n                      imm_b_mux_sel_o    = IMMB_CLIP;\n                    end\n                    5'b11010: alu_operator_o = ALU_CLIP;               // cv.clipr\n                    5'b11011: alu_operator_o = ALU_CLIPU;              // cv.clipur\n                    default : illegal_insn_o = 1'b1;\n                  endcase\n                end\n\n                7'b1000000, 7'b1000001, 7'b1000010, 7'b1000011,\n                7'b1000100, 7'b1000101, 7'b1000110, 7'b1000111: begin  // Add/Sub with Normalization and Rounding\n                  regfile_alu_we        = 1'b1;\n                  rega_used_o           = 1'b1;\n                  regb_used_o           = 1'b1;\n                  regc_used_o           = 1'b1;\n                  regc_mux_o            = REGC_RD;\n                  bmask_a_mux_o         = BMASK_A_ZERO;\n                  bmask_b_mux_o         = BMASK_B_S3;\n                  alu_bmask_b_mux_sel_o = BMASK_B_REG;\n                  alu_op_a_mux_sel_o    = OP_A_REGC_OR_FWD;\n                  alu_op_b_mux_sel_o    = OP_B_REGA_OR_FWD;\n\n                  unique case (instr_rdata_i[27:25])\n                    3'b000: alu_operator_o = ALU_ADD;                  // cv.addNr\n                    3'b001: alu_operator_o = ALU_ADDU;                 // cv.adduNr\n                    3'b010: alu_operator_o = ALU_ADDR;                 // cv.addRNr\n                    3'b011: alu_operator_o = ALU_ADDUR;                // cv.adduRNr\n                    3'b100: alu_operator_o = ALU_SUB;                  // cv.subNr\n                    3'b101: alu_operator_o = ALU_SUBU;                 // cv.subuNr\n                    3'b110: alu_operator_o = ALU_SUBR;                 // cv.subRNr\n                    3'b111: alu_operator_o = ALU_SUBUR;                // cv.subuRNr\n                    default: alu_operator_o = ALU_ADD;\n                  endcase\n                end\n\n                7'b1001000, 7'b1001001: begin\n                  alu_en          = 1'b0;\n                  mult_int_en     = 1'b1;\n                  regfile_alu_we  = 1'b1;\n                  rega_used_o     = 1'b1;\n                  regb_used_o     = 1'b1;\n                  regc_used_o     = 1'b1;\n                  regc_mux_o      = REGC_RD;\n\n                  if (instr_rdata_i[25] == 1'b0) begin\n                    mult_operator_o = MUL_MAC32;                       // cv.mac\n                  end else begin\n                    mult_operator_o = MUL_MSU32;                       // cv.msu\n                  end\n                end\n\n                default: illegal_insn_o = 1'b1;\n              endcase\n            end // Plane A\n\n            ///////////////////////////////////////////////\n            //  _   ___        ___     ___   ___  ____   //\n            // | | | \\ \\      / / |   / _ \\ / _ \\|  _ \\  //\n            // | |_| |\\ \\ /\\ / /| |  | | | | | | | |_) | //\n            // |  _  | \\ V  V / | |__| |_| | |_| |  __/  //\n            // |_| |_|  \\_/\\_/  |_____\\___/ \\___/|_|     //\n            //                                           //\n            ///////////////////////////////////////////////\n            3'b100 : begin // Plane B\n              hwlp_target_mux_sel_o = 2'b0;\n\n              unique case (instr_rdata_i[11:8])\n                4'b0000: begin\n                  // lp.starti: set start address to PC + I-type immediate\n                  hwlp_we[0]           = 1'b1;\n                  hwlp_start_mux_sel_o = 2'b0;\n                  if (instr_rdata_i[19:15] != 5'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                4'b0001: begin\n                  // lp.start: set start address to rs1 content\n                  hwlp_we[0]           = 1'b1;\n                  hwlp_start_mux_sel_o = 2'b10;\n                  rega_used_o          = 1'b1;\n                  if (instr_rdata_i[31:20] != 12'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                4'b0010: begin\n                  // lp.endi: set end address to PC + I-type immediate - 4\n                  hwlp_we[1] = 1'b1;\n                  if (instr_rdata_i[19:15] != 5'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                4'b0011: begin\n                  // lp.end: set end address to (rs1 - 4) content\n                  hwlp_we[1]            = 1'b1;\n                  hwlp_target_mux_sel_o = 2'b10;\n                  rega_used_o           = 1'b1;\n                  if (instr_rdata_i[31:20] != 12'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                4'b0100: begin\n                  // lp.counti: initialize counter from I-type immediate\n                  hwlp_we[2]         = 1'b1;\n                  hwlp_cnt_mux_sel_o = 1'b0;\n                  if (instr_rdata_i[19:15] != 5'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                4'b0101: begin\n                  // lp.count: initialize counter from rs1\n                  hwlp_we[2]         = 1'b1;\n                  hwlp_cnt_mux_sel_o = 1'b1;\n                  rega_used_o        = 1'b1;\n                  if (instr_rdata_i[31:20] != 12'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                4'b0110: begin\n                  // lp.setupi: initialize counter from immediate, set start address to\n                  // next instruction and end address to PC + I-type immediate - 4\n                  hwlp_we               = 3'b111;\n                  hwlp_target_mux_sel_o = 2'b01;\n                  hwlp_start_mux_sel_o  = 2'b01;\n                  hwlp_cnt_mux_sel_o    = 1'b0;\n                end\n                4'b0111: begin\n                  // lp.setup: initialize counter from rs1, set start address to\n                  // next instruction and end address to PC + I-type immediate - 4\n                  hwlp_we              = 3'b111;\n                  hwlp_start_mux_sel_o = 2'b01;\n                  hwlp_cnt_mux_sel_o   = 1'b1;\n                  rega_used_o          = 1'b1;\n                end\n                default: begin\n                  illegal_insn_o = 1'b1;\n                end\n              endcase\n            end // Plane B\n\n            default: illegal_insn_o = 1'b1;\n          endcase\n\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      OPCODE_CUSTOM_2: begin  // PULP specific ALU instructions with two source operands and one immediate\n        if (COREV_PULP) begin\n          regfile_alu_we = 1'b1;\n          rega_used_o    = 1'b1;\n          regb_used_o    = 1'b1;\n\n          unique case (instr_rdata_i[14:13])\n            2'b00: begin\n              // Bit Manipulation instructions\n              regb_used_o         = 1'b0;\n              bmask_a_mux_o       = BMASK_A_S3;\n              bmask_b_mux_o       = BMASK_B_S2;\n              alu_op_b_mux_sel_o  = OP_B_IMM;\n     \n              unique case ({instr_rdata_i[31:30], instr_rdata_i[12]})\n                {2'b00, 1'b0}: begin                                       // cv.extract\n                  alu_operator_o  = ALU_BEXT;\n                  imm_b_mux_sel_o = IMMB_S2;\n                  bmask_b_mux_o   = BMASK_B_ZERO;\n                end\n                {2'b01, 1'b0}: begin                                       // cv.extractu\n                  alu_operator_o  = ALU_BEXTU;\n                  imm_b_mux_sel_o = IMMB_S2;\n                  bmask_b_mux_o   = BMASK_B_ZERO;\n                end\n                {2'b10, 1'b0}: begin                                       // cv.insert\n                  alu_operator_o  = ALU_BINS;\n                  imm_b_mux_sel_o = IMMB_S2;\n                  regc_used_o     = 1'b1;\n                  regc_mux_o      = REGC_RD;\n                end\n                {2'b00, 1'b1}: begin                                       // cv.bclr\n                  alu_operator_o = ALU_BCLR;\n                end\n                {2'b01, 1'b1}: begin                                       // cv.bset\n                  alu_operator_o = ALU_BSET;\n                end\n                {2'b11, 1'b1}: begin                                       // cv.bitrev\n                  alu_operator_o        = ALU_BREV;\n                  // Enable write back to RD\n                  regc_used_o           = 1'b1;\n                  regc_mux_o            = REGC_RD;\n                  // Extract the source register on operand a\n                  imm_b_mux_sel_o       = IMMB_S2;\n                  // Map the radix to bmask_a immediate\n                  alu_bmask_a_mux_sel_o = BMASK_A_IMM;\n                  if (instr_rdata_i[29:27] != 3'b0) begin\n                    illegal_insn_o = 1'b1;\n                  end\n                end\n                default: illegal_insn_o = 1'b1;\n              endcase\n            end\n\n            2'b01: begin\n              // ADD/SUB with normalization and rounding\n              bmask_a_mux_o  = BMASK_A_ZERO;\n              bmask_b_mux_o  = BMASK_B_S3;\n\n              // decide between using unsigned and rounding, and combinations\n              unique case ({instr_rdata_i[31:30], instr_rdata_i[12]})\n                {2'b00, 1'b0}: alu_operator_o = ALU_ADD;                   // cv.addN\n                {2'b01, 1'b0}: alu_operator_o = ALU_ADDU;                  // cv.adduN\n                {2'b10, 1'b0}: alu_operator_o = ALU_ADDR;                  // cv.addRN\n                {2'b11, 1'b0}: alu_operator_o = ALU_ADDUR;                 // cv.adduRN\n                {2'b00, 1'b1}: alu_operator_o = ALU_SUB;                   // cv.subN\n                {2'b01, 1'b1}: alu_operator_o = ALU_SUBU;                  // cv.subuN\n                {2'b10, 1'b1}: alu_operator_o = ALU_SUBR;                  // cv.subRN\n                {2'b11, 1'b1}: alu_operator_o = ALU_SUBUR;                 // cv.subuRN\n                default      : alu_operator_o = ALU_ADD;\n              endcase\n\n            end\n\n            2'b10, 2'b11: begin\n              // MUL/MAC with subword selection\n              alu_en             = 1'b0;\n              mult_int_en        = 1'b1;\n\n              mult_imm_mux_o     = MIMM_S3;\n              mult_sel_subword_o = instr_rdata_i[30];                      // cv.mulhhsN, cv.mulhhsRN, cv.mulhhuN, cv.mulhhuRN\n                                                                           // cv.machhsN, cv.machhsRN, cv.machhuN, cv.machhuRN\n              mult_signed_mode_o = {2{~instr_rdata_i[12]}};                // cv.mulsN,   cv.mulhhsN,  cv.mulsRN,  cv.mulhhsRN\n                                                                           // cv.macsN,   cv.machhsN,  cv.macsRN,  cv.machhsRN\n\n              if (instr_rdata_i[13]) begin                                 // cv.macsN,   cv.machhsN,  cv.macsRN,  cv.machhsRN\n                                                                           // cv.macuN,   cv.machhuN,  cv.macuRN,  cv.machhuRN\n                regc_used_o = 1'b1;\n                regc_mux_o  = REGC_RD;\n              end else begin                                               // cv.mulsN,   cv.mulhhsN,  cv.mulsRN,  cv.mulhhsRN\n                                                                           // cv.muluN,   cv.mulhhuN,  cv.muluRN,  cv.mulhhuRN\n                regc_mux_o  = REGC_ZERO;\n              end\n\n              if (instr_rdata_i[31]) begin                                 // cv.mulsRN,  cv.mulhhsRN, cv.muluRN,  cv.mulhhuRN\n                                                                           // cv.macsRN,  cv.machhsRN, cv.macuRN,  cv.machhuRN\n                mult_operator_o = MUL_IR;\n              end else begin                                               // cv.mulsN,   cv.mulhhsN,  cv.muluN,   cv.mulhhuN\n                                                                           // cv.macsN,   cv.machhsN,  cv.macuN,   cv.machhuN\n                mult_operator_o = MUL_I;\n              end\n            end\n            default: illegal_insn_o = 1'b1;\n          endcase\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      OPCODE_CUSTOM_3: begin\n        if (COREV_PULP) begin\n          regfile_alu_we      = 1'b1;\n          rega_used_o         = 1'b1;\n          imm_b_mux_sel_o     = IMMB_VS;\n\n          alu_vec_o = 1'b1;\n          // vector size\n          if (instr_rdata_i[12]) begin\n            alu_vec_mode_o  = VEC_MODE8;\n            mult_operator_o = MUL_DOT8;\n          end else begin\n            alu_vec_mode_o  = VEC_MODE16;\n            mult_operator_o = MUL_DOT16;\n          end\n\n          // distinguish normal vector, sc and sci modes\n          if (instr_rdata_i[14]) begin\n            scalar_replication_o = 1'b1;\n\n            if (instr_rdata_i[13]) begin\n              // immediate scalar replication, .sci\n              alu_op_b_mux_sel_o = OP_B_IMM;\n            end else begin\n              // register scalar replication, .sc\n              regb_used_o = 1'b1;\n            end\n          end else begin\n            // normal register use\n            regb_used_o = 1'b1;\n          end\n\n          // now decode the instruction\n          unique case (instr_rdata_i[31:26])\n            6'b00000_0: begin // cv.add\n              alu_operator_o = ALU_ADD;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00001_0: begin // cv.sub\n              alu_operator_o = ALU_SUB;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00010_0: begin // cv.avg\n              alu_operator_o = ALU_ADD;\n              imm_b_mux_sel_o = IMMB_VS;\n              bmask_b_mux_o = BMASK_B_ONE;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00011_0: begin // cv.avgu\n             alu_operator_o = ALU_ADDU;\n             imm_b_mux_sel_o = IMMB_VU;\n             bmask_b_mux_o = BMASK_B_ONE;\n             if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n               illegal_insn_o = 1'b1;\n             end\n             if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                 instr_rdata_i[25] != 1'b0) begin\n               illegal_insn_o = 1'b1;\n             end\n            end\n            6'b00100_0: begin // cv.min\n             alu_operator_o = ALU_MIN;\n             imm_b_mux_sel_o = IMMB_VS;\n             if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n               illegal_insn_o = 1'b1;\n             end\n             if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                 instr_rdata_i[25] != 1'b0) begin\n               illegal_insn_o = 1'b1;\n             end\n            end\n            6'b00101_0: begin // cv.minu\n              alu_operator_o = ALU_MINU;\n              imm_b_mux_sel_o = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00110_0: begin // cv.max\n              alu_operator_o = ALU_MAX;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00111_0: begin // cv.maxu\n              alu_operator_o = ALU_MAXU;\n              imm_b_mux_sel_o = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01000_0: begin // cv.srl\n              alu_operator_o = ALU_SRL;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14"}
{"text": ":12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01001_0: begin // cv.sra\n              alu_operator_o = ALU_SRA;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01010_0: begin // cv.sll\n              alu_operator_o = ALU_SLL;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01011_0: begin // cv.or\n              alu_operator_o = ALU_OR;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01100_0: begin // cv.xor\n              alu_operator_o = ALU_XOR;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01101_0: begin // cv.and\n              alu_operator_o = ALU_AND;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01110_0: begin // cv.abs\n              alu_operator_o = ALU_ABS;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] != 3'b000 && instr_rdata_i[14:12] != 3'b001) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[25:20] != 6'b000000) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10000_0: begin // cv.dotup\n              alu_en            = 1'b0;\n              mult_dot_en       = 1'b1;\n              mult_dot_signed_o = 2'b00;\n              imm_b_mux_sel_o   = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10001_0: begin // cv.dotusp\n              alu_en            = 1'b0;\n              mult_dot_en       = 1'b1;\n              mult_dot_signed_o = 2'b01;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10010_0: begin // cv.dotsp\n              alu_en            = 1'b0;\n              mult_dot_en       = 1'b1;\n              mult_dot_signed_o = 2'b11;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10011_0: begin // cv.sdotup\n              alu_en            = 1'b0;\n              mult_dot_en       = 1'b1;\n              mult_dot_signed_o = 2'b00;\n              regc_used_o       = 1'b1;\n              regc_mux_o        = REGC_RD;\n              imm_b_mux_sel_o   = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10100_0: begin // cv.sdotusp\n              alu_en            = 1'b0;\n              mult_dot_en       = 1'b1;\n              mult_dot_signed_o = 2'b01;\n              regc_used_o       = 1'b1;\n              regc_mux_o        = REGC_RD;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10101_0: begin // cv.sdotsp\n              alu_en            = 1'b0;\n              mult_dot_en       = 1'b1;\n              mult_dot_signed_o = 2'b11;\n              regc_used_o       = 1'b1;\n              regc_mux_o        = REGC_RD;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b10111_0: begin\n              unique case (instr_rdata_i[14:13])\n                2'b00: alu_operator_o = ALU_EXTS; // cv.extract\n                2'b01: alu_operator_o = ALU_EXT;  // cv.extractu\n                2'b10: begin                      // cv.insert\n                  alu_operator_o     = ALU_INS;\n                  regc_used_o        = 1'b1;\n                  regc_mux_o         = REGC_RD;\n                  alu_op_b_mux_sel_o = OP_B_REGC_OR_FWD;\n                end\n                default: illegal_insn_o = 1'b1;\n              endcase\n            end\n            6'b11000_0: begin // cv.shuffle, cv.shuffleI0\n              alu_operator_o       = ALU_SHUF;\n              imm_b_mux_sel_o      = IMMB_SHUF;\n              regb_used_o          = 1'b1;\n              scalar_replication_o = 1'b0;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011 ||\n                  instr_rdata_i[14:12] == 3'b100 || instr_rdata_i[14:12] == 3'b101) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b11001_0,\n            6'b11010_0,\n            6'b11011_0: begin // cv.shuffleI1 cv.shuffleI2 cv.shuffleI3\n              alu_operator_o       = ALU_SHUF;\n              imm_b_mux_sel_o      = IMMB_SHUF;\n              regb_used_o          = 1'b1;\n              scalar_replication_o = 1'b0;\n              if (instr_rdata_i[14:12] != 3'b111) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b11100_0: begin // cv.shuffle2\n              alu_operator_o       = ALU_SHUF2;\n              regb_used_o          = 1'b1;\n              regc_used_o          = 1'b1;\n              regc_mux_o           = REGC_RD;\n              scalar_replication_o = 1'b0;\n              if (instr_rdata_i[14:12] != 3'b000 && instr_rdata_i[14:12] != 3'b001) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b11110_0: begin // cv.pack, cv.pack.h\n              alu_operator_o = instr_rdata_i[25] ? ALU_PCKHI : ALU_PCKLO;\n              regb_used_o    = 1'b1;\n              if (instr_rdata_i[14:12] != 3'b000) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b11111_0: begin // cv.packhi, cv.packlo\n              alu_operator_o = instr_rdata_i[25] ? ALU_PCKHI : ALU_PCKLO;\n              regb_used_o    = 1'b1;\n              regc_used_o    = 1'b1;\n              regc_mux_o     = REGC_RD;\n              if (instr_rdata_i[14:12] != 3'b001) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n\n            // Comparisons, always have bit 26 set\n            6'b00000_1: begin // cv.cmpeq\n              alu_operator_o  = ALU_EQ;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00001_1: begin // cv.cmpne\n              alu_operator_o  = ALU_NE;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00010_1: begin // cv.cmpgt\n              alu_operator_o  = ALU_GTS;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00011_1: begin // cv.cmpge\n              alu_operator_o  = ALU_GES;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00100_1: begin // cv.cmplt\n              alu_operator_o  = ALU_LTS;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00101_1: begin // cv.cmple\n              alu_operator_o  = ALU_LES;\n              imm_b_mux_sel_o = IMMB_VS;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00110_1: begin // cv.cmpgtu\n              alu_operator_o  = ALU_GTU;\n              imm_b_mux_sel_o = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b00111_1: begin // cv.cmpgeu\n              alu_operator_o  = ALU_GEU;\n              imm_b_mux_sel_o = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01000_1: begin // cv.cmpltu\n              alu_operator_o  = ALU_LTU;\n              imm_b_mux_sel_o = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01001_1: begin // cv.cmpleu\n              alu_operator_o  = ALU_LEU;\n              imm_b_mux_sel_o = IMMB_VU;\n              if (instr_rdata_i[14:12] == 3'b010 || instr_rdata_i[14:12] == 3'b011) begin\n                illegal_insn_o = 1'b1;\n              end\n              if (instr_rdata_i[14:12] != 3'b110 && instr_rdata_i[14:12] != 3'b111 &&\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n\n            /*  Complex instructions */\n            6'b01010_1: begin // cv.cplxmul.{r,i}.{/,div2,div4,div8}\n              alu_en               = 1'b0;\n              mult_dot_en          = 1'b1;\n              mult_dot_signed_o    = 2'b11;\n              is_clpx_o            = 1'b1;\n              regc_used_o          = 1'b1;\n              regc_mux_o           = REGC_RD;\n              scalar_replication_o = 1'b0;\n              alu_op_b_mux_sel_o   = OP_B_REGB_OR_FWD;\n              regb_used_o          = 1'b1;\n              illegal_insn_o       = instr_rdata_i[12];\n            end\n            6'b01011_1: begin // cv.cplxconj\n              alu_operator_o       = ALU_ABS;\n              is_clpx_o            = 1'b1;\n              scalar_replication_o = 1'b0;\n              regb_used_o          = 1'b0;\n              if (instr_rdata_i[14:12] != 3'b000 || instr_rdata_i[25:20] != 6'b000000) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01100_1: begin // cv.subrotmj.{/,div2,div4,div8}\n              alu_operator_o       = ALU_SUB;\n              is_clpx_o            = 1'b1;\n              scalar_replication_o = 1'b0;\n              alu_op_b_mux_sel_o   = OP_B_REGB_OR_FWD;\n              regb_used_o          = 1'b1;\n              is_subrot_o          = 1'b1;\n              if (instr_rdata_i[12] != 1'b0 || instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01101_1: begin // cv.add.{div2,div4,div8}\n              alu_operator_o       = ALU_ADD;\n              is_clpx_o            = 1'b1;\n              scalar_replication_o = 1'b0;\n              alu_op_b_mux_sel_o   = OP_B_REGB_OR_FWD;\n              regb_used_o          = 1'b1;\n              if (instr_rdata_i[12] != 1'b0 || instr_rdata_i[14:12] == 3'b000 ||\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n            6'b01110_1: begin // cv.sub.{div2,div4,div8}\n              alu_operator_o       = ALU_SUB;\n              is_clpx_o            = 1'b1;\n              scalar_replication_o = 1'b0;\n              alu_op_b_mux_sel_o   = OP_B_REGB_OR_FWD;\n              regb_used_o          = 1'b1;\n              if (instr_rdata_i[12] != 1'b0 || instr_rdata_i[14:12] == 3'b000 ||\n                  instr_rdata_i[25] != 1'b0) begin\n                illegal_insn_o = 1'b1;\n              end\n            end\n\n            default: illegal_insn_o = 1'b1;\n          endcase\n        end else begin\n          illegal_insn_o = 1'b1;\n        end\n      end\n\n      ////////////////////////////////////////////////\n      //  ____  ____  _____ ____ ___    _    _      //\n      // / ___||  _ \\| ____/ ___|_ _|  / \\  | |     //\n      // \\___ \\| |_) |  _|| |    | |  / _ \\ | |     //\n      //  ___) |  __/| |__| |___ | | / ___ \\| |___  //\n      // |____/|_|   |_____\\____|___/_/   \\_\\_____| //\n      //                                            //\n      ////////////////////////////////////////////////\n\n      OPCODE_FENCE: begin\n        unique case (instr_rdata_i[14:12])\n          3'b000: begin // FENCE (FENCE.I instead, a bit more conservative)\n            // flush pipeline\n            fencei_insn_o = 1'b1;\n          end\n\n          3'b001: begin // FENCE.I\n            // flush prefetch buffer, flush pipeline\n            fencei_insn_o = 1'b1;\n          end\n\n          default: illegal_insn_o =  1'b1;\n        endcase\n      end\n\n      OPCODE_SYSTEM: begin\n        if (instr_rdata_i[14:12] == 3'b000)\n        begin\n          // non CSR related SYSTEM instructions\n          if ( {instr_rdata_i[19:15], instr_rdata_i[11:7]} == '0)\n          begin\n            unique case (instr_rdata_i[31:20])\n              12'h000:  // ECALL\n              begin\n                // environment (system) call\n                ecall_insn_o  = 1'b1;\n              end\n\n              12'h001:  // ebreak\n              begin\n                // debugger trap\n                ebrk_insn_o = 1'b1;\n              end\n\n              12'h302:  // mret\n              begin\n                illegal_insn_o = (PULP_SECURE) ? current_priv_lvl_i != PRIV_LVL_M : 1'b0;\n                mret_insn_o    = ~illegal_insn_o;\n                mret_dec_o     = 1'b1;\n              end\n\n              12'h002:  // uret\n              begin\n                illegal_insn_o = (PULP_SECURE) ? 1'b0 : 1'b1;\n                uret_insn_o    = ~illegal_insn_o;\n                uret_dec_o     = 1'b1;\n              end\n\n              12'h7b2:  // dret\n              begin\n                illegal_insn_o = !debug_mode_i;\n                dret_insn_o    =  debug_mode_i;\n                dret_dec_o     =  1'b1;\n              end\n\n              12'h105:  // wfi\n              begin\n                wfi_o = 1'b1;\n                if (debug_wfi_no_sleep_i) begin\n                  // Treat as NOP (do not cause sleep mode entry)\n                  // Using decoding similar to ADDI, but without register reads/writes,\n                  // i.e. keep regfile_alu_we = 0, rega_used_o = 0\n                  alu_op_b_mux_sel_o = OP_B_IMM;\n                  imm_b_mux_sel_o = IMMB_I;\n                  alu_operator_o = ALU_ADD;\n                end\n              end\n\n              default: illegal_insn_o = 1'b1;\n            endcase\n          end else illegal_insn_o = 1'b1;\n        end\n        else\n        begin\n          // instruction to read/modify CSR\n          csr_access_o        = 1'b1;\n          regfile_alu_we      = 1'b1;\n          alu_op_b_mux_sel_o  = OP_B_IMM;\n          imm_a_mux_sel_o     = IMMA_Z;\n          imm_b_mux_sel_o     = IMMB_I;    // CSR address is encoded in I imm\n\n          if (instr_rdata_i[14] == 1'b1) begin\n            // rs1 field is used as immediate\n            alu_op_a_mux_sel_o = OP_A_IMM;\n          end else begin\n            rega_used_o        = 1'b1;\n     "}
{"text": "       alu_op_a_mux_sel_o = OP_A_REGA_OR_FWD;\n          end\n\n          // instr_rdata_i[19:14] = rs or immediate value\n          //   if set or clear with rs == x0 or imm == 0,\n          //   then do not perform a write action\n          unique case (instr_rdata_i[13:12])\n            2'b01:   csr_op = CSR_OP_WRITE;\n            2'b10:   csr_op = instr_rdata_i[19:15] == 5'b0 ? CSR_OP_READ : CSR_OP_SET;\n            2'b11:   csr_op = instr_rdata_i[19:15] == 5'b0 ? CSR_OP_READ : CSR_OP_CLEAR;\n            default: csr_illegal = 1'b1;\n          endcase\n\n          if (instr_rdata_i[29:28] > current_priv_lvl_i) begin\n            // No access to higher privilege CSR\n            csr_illegal = 1'b1;\n          end\n\n          // Determine if CSR access is illegal\n          case (instr_rdata_i[31:20])\n            // Floating point\n            CSR_FFLAGS :\n                if (FPU == 0 || fs_off_i == 1'b1) csr_illegal = 1'b1;\n\n            CSR_FRM,\n              CSR_FCSR :\n                if (FPU == 0 || fs_off_i == 1'b1) begin\n                  csr_illegal = 1'b1;\n                end else begin\n                  // FRM updated value needed by following FPU instruction\n                  if (csr_op != CSR_OP_READ) csr_status_o = 1'b1;\n                end\n\n            //  Writes to read only CSRs results in illegal instruction\n            CSR_MVENDORID,\n              CSR_MARCHID,\n              CSR_MIMPID,\n              CSR_MHARTID :\n                if (csr_op != CSR_OP_READ) csr_illegal = 1'b1;\n\n            // These are valid CSR registers\n            CSR_MSTATUS,\n              CSR_MEPC,\n              CSR_MTVEC,\n              CSR_MCAUSE :\n                // Not illegal, but treat as status CSR for side effect handling\n                csr_status_o = 1'b1;\n\n            // These are valid CSR registers\n            CSR_MISA,\n              CSR_MIE,\n              CSR_MSCRATCH,\n              CSR_MTVAL,\n              CSR_MIP :\n                ; // do nothing, not illegal\n\n            // Hardware Performance Monitor\n            CSR_MCYCLE,\n              CSR_MINSTRET,\n              CSR_MHPMCOUNTER3,\n              CSR_MHPMCOUNTER4,  CSR_MHPMCOUNTER5,  CSR_MHPMCOUNTER6,  CSR_MHPMCOUNTER7,\n              CSR_MHPMCOUNTER8,  CSR_MHPMCOUNTER9,  CSR_MHPMCOUNTER10, CSR_MHPMCOUNTER11,\n              CSR_MHPMCOUNTER12, CSR_MHPMCOUNTER13, CSR_MHPMCOUNTER14, CSR_MHPMCOUNTER15,\n              CSR_MHPMCOUNTER16, CSR_MHPMCOUNTER17, CSR_MHPMCOUNTER18, CSR_MHPMCOUNTER19,\n              CSR_MHPMCOUNTER20, CSR_MHPMCOUNTER21, CSR_MHPMCOUNTER22, CSR_MHPMCOUNTER23,\n              CSR_MHPMCOUNTER24, CSR_MHPMCOUNTER25, CSR_MHPMCOUNTER26, CSR_MHPMCOUNTER27,\n              CSR_MHPMCOUNTER28, CSR_MHPMCOUNTER29, CSR_MHPMCOUNTER30, CSR_MHPMCOUNTER31,\n              CSR_MCYCLEH,\n              CSR_MINSTRETH,\n              CSR_MHPMCOUNTER3H,\n              CSR_MHPMCOUNTER4H,  CSR_MHPMCOUNTER5H,  CSR_MHPMCOUNTER6H,  CSR_MHPMCOUNTER7H,\n              CSR_MHPMCOUNTER8H,  CSR_MHPMCOUNTER9H,  CSR_MHPMCOUNTER10H, CSR_MHPMCOUNTER11H,\n              CSR_MHPMCOUNTER12H, CSR_MHPMCOUNTER13H, CSR_MHPMCOUNTER14H, CSR_MHPMCOUNTER15H,\n              CSR_MHPMCOUNTER16H, CSR_MHPMCOUNTER17H, CSR_MHPMCOUNTER18H, CSR_MHPMCOUNTER19H,\n              CSR_MHPMCOUNTER20H, CSR_MHPMCOUNTER21H, CSR_MHPMCOUNTER22H, CSR_MHPMCOUNTER23H,\n              CSR_MHPMCOUNTER24H, CSR_MHPMCOUNTER25H, CSR_MHPMCOUNTER26H, CSR_MHPMCOUNTER27H,\n              CSR_MHPMCOUNTER28H, CSR_MHPMCOUNTER29H, CSR_MHPMCOUNTER30H, CSR_MHPMCOUNTER31H,\n              CSR_MCOUNTINHIBIT,\n              CSR_MHPMEVENT3,\n              CSR_MHPMEVENT4,  CSR_MHPMEVENT5,  CSR_MHPMEVENT6,  CSR_MHPMEVENT7,\n              CSR_MHPMEVENT8,  CSR_MHPMEVENT9,  CSR_MHPMEVENT10, CSR_MHPMEVENT11,\n              CSR_MHPMEVENT12, CSR_MHPMEVENT13, CSR_MHPMEVENT14, CSR_MHPMEVENT15,\n              CSR_MHPMEVENT16, CSR_MHPMEVENT17, CSR_MHPMEVENT18, CSR_MHPMEVENT19,\n              CSR_MHPMEVENT20, CSR_MHPMEVENT21, CSR_MHPMEVENT22, CSR_MHPMEVENT23,\n              CSR_MHPMEVENT24, CSR_MHPMEVENT25, CSR_MHPMEVENT26, CSR_MHPMEVENT27,\n              CSR_MHPMEVENT28, CSR_MHPMEVENT29, CSR_MHPMEVENT30, CSR_MHPMEVENT31 :\n                // Not illegal, but treat as status CSR to get accurate counts\n                csr_status_o = 1'b1;\n\n            // Hardware Performance Monitor (unprivileged read-only mirror CSRs)\n            CSR_CYCLE,\n              CSR_INSTRET,\n              CSR_HPMCOUNTER3,\n              CSR_HPMCOUNTER4,  CSR_HPMCOUNTER5,  CSR_HPMCOUNTER6,  CSR_HPMCOUNTER7,\n              CSR_HPMCOUNTER8,  CSR_HPMCOUNTER9,  CSR_HPMCOUNTER10, CSR_HPMCOUNTER11,\n              CSR_HPMCOUNTER12, CSR_HPMCOUNTER13, CSR_HPMCOUNTER14, CSR_HPMCOUNTER15,\n              CSR_HPMCOUNTER16, CSR_HPMCOUNTER17, CSR_HPMCOUNTER18, CSR_HPMCOUNTER19,\n              CSR_HPMCOUNTER20, CSR_HPMCOUNTER21, CSR_HPMCOUNTER22, CSR_HPMCOUNTER23,\n              CSR_HPMCOUNTER24, CSR_HPMCOUNTER25, CSR_HPMCOUNTER26, CSR_HPMCOUNTER27,\n              CSR_HPMCOUNTER28, CSR_HPMCOUNTER29, CSR_HPMCOUNTER30, CSR_HPMCOUNTER31,\n              CSR_CYCLEH,\n              CSR_INSTRETH,\n              CSR_HPMCOUNTER3H,\n              CSR_HPMCOUNTER4H,  CSR_HPMCOUNTER5H,  CSR_HPMCOUNTER6H,  CSR_HPMCOUNTER7H,\n              CSR_HPMCOUNTER8H,  CSR_HPMCOUNTER9H,  CSR_HPMCOUNTER10H, CSR_HPMCOUNTER11H,\n              CSR_HPMCOUNTER12H, CSR_HPMCOUNTER13H, CSR_HPMCOUNTER14H, CSR_HPMCOUNTER15H,\n              CSR_HPMCOUNTER16H, CSR_HPMCOUNTER17H, CSR_HPMCOUNTER18H, CSR_HPMCOUNTER19H,\n              CSR_HPMCOUNTER20H, CSR_HPMCOUNTER21H, CSR_HPMCOUNTER22H, CSR_HPMCOUNTER23H,\n              CSR_HPMCOUNTER24H, CSR_HPMCOUNTER25H, CSR_HPMCOUNTER26H, CSR_HPMCOUNTER27H,\n              CSR_HPMCOUNTER28H, CSR_HPMCOUNTER29H, CSR_HPMCOUNTER30H, CSR_HPMCOUNTER31H :\n                // Read-only and readable from user mode only if the bit of mcounteren is set\n                if ((csr_op != CSR_OP_READ) ||\n                    (PULP_SECURE && (current_priv_lvl_i != PRIV_LVL_M) && !mcounteren_i[instr_rdata_i[24:20]])) begin\n                  csr_illegal = 1'b1;\n                end else begin\n                  csr_status_o = 1'b1;\n                end\n\n            // This register only exists in user mode\n            CSR_MCOUNTEREN :\n                if (!PULP_SECURE) begin\n                  csr_illegal = 1'b1;\n                end else begin\n                  csr_status_o = 1'b1;\n                end\n\n            // Debug register access\n            CSR_DCSR,\n              CSR_DPC,\n              CSR_DSCRATCH0,\n              CSR_DSCRATCH1 :\n                if (!debug_mode_i) begin\n                  csr_illegal = 1'b1;\n                end else begin\n                  csr_status_o = 1'b1;\n                end\n\n            // Debug Trigger register access\n            CSR_TSELECT,\n              CSR_TDATA1,\n              CSR_TDATA2,\n              CSR_TDATA3,\n              CSR_TINFO,\n              CSR_MCONTEXT,\n              CSR_SCONTEXT :\n                if (DEBUG_TRIGGER_EN != 1)\n                  csr_illegal = 1'b1;\n\n            // Hardware Loop register\n            CSR_LPSTART0,\n              CSR_LPEND0,\n              CSR_LPCOUNT0,\n              CSR_LPSTART1,\n              CSR_LPEND1,\n              CSR_LPCOUNT1:\n                if (!COREV_PULP || csr_op != CSR_OP_READ) csr_illegal = 1'b1;\n\n            // UHARTID access\n            CSR_UHARTID :\n                if (!COREV_PULP || csr_op != CSR_OP_READ) csr_illegal = 1'b1;\n\n            // PRIVLV access\n            CSR_PRIVLV :\n                if (!COREV_PULP || csr_op != CSR_OP_READ) begin\n                  csr_illegal = 1'b1;\n                end else begin\n                  csr_status_o = 1'b1;\n                end\n\n            // ZFINX\n            CSR_ZFINX :\n                if (!COREV_PULP || (FPU && !ZFINX) || csr_op != CSR_OP_READ) begin\n                  csr_illegal = 1'b1;\n                end\n\n            // PMP register access\n            CSR_PMPCFG0,\n              CSR_PMPCFG1,\n              CSR_PMPCFG2,\n              CSR_PMPCFG3,\n              CSR_PMPADDR0,\n              CSR_PMPADDR1,\n              CSR_PMPADDR2,\n              CSR_PMPADDR3,\n              CSR_PMPADDR4,\n              CSR_PMPADDR5,\n              CSR_PMPADDR6,\n              CSR_PMPADDR7,\n              CSR_PMPADDR8,\n              CSR_PMPADDR9,\n              CSR_PMPADDR10,\n              CSR_PMPADDR11,\n              CSR_PMPADDR12,\n              CSR_PMPADDR13,\n              CSR_PMPADDR14,\n              CSR_PMPADDR15 :\n                if (!USE_PMP) csr_illegal = 1'b1;\n\n            // User register access\n            CSR_USTATUS,\n              CSR_UEPC,\n              CSR_UTVEC,\n              CSR_UCAUSE :\n                if (!PULP_SECURE) begin\n                  csr_illegal = 1'b1;\n                end else begin\n                  csr_status_o = 1'b1;\n                end\n\n            default : csr_illegal = 1'b1;\n\n          endcase // case (instr_rdata_i[31:20])\n\n          illegal_insn_o = csr_illegal;\n\n        end\n      end\n      default: illegal_insn_o = 1'b1;\n    endcase\n\n    // make sure invalid compressed instruction causes an exception\n    if (illegal_c_insn_i) begin\n      illegal_insn_o = 1'b1;\n    end\n\n  end\n\n  // deassert we signals (in case of stalls)\n  assign alu_en_o                    = (deassert_we_i) ? 1'b0          : alu_en;\n  assign mult_int_en_o               = (deassert_we_i) ? 1'b0          : mult_int_en;\n  assign mult_dot_en_o               = (deassert_we_i) ? 1'b0          : mult_dot_en;\n  assign apu_en_o                    = (deassert_we_i) ? 1'b0          : apu_en;\n  assign regfile_mem_we_o            = (deassert_we_i) ? 1'b0          : regfile_mem_we;\n  assign regfile_alu_we_o            = (deassert_we_i) ? 1'b0          : regfile_alu_we;\n  assign data_req_o                  = (deassert_we_i) ? 1'b0          : data_req;\n  assign hwlp_we_o                   = (deassert_we_i) ? 3'b0          : hwlp_we;\n  assign csr_op_o                    = (deassert_we_i) ? CSR_OP_READ   : csr_op;\n  assign ctrl_transfer_insn_in_id_o  = (deassert_we_i) ? BRANCH_NONE   : ctrl_transfer_insn;\n\n  assign ctrl_transfer_insn_in_dec_o  = ctrl_transfer_insn;\n  assign regfile_alu_we_dec_o         = regfile_alu_we;\n\nendmodule // cv32e40p_decoder\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Renzo Andri - andrire@student.ethz.ch                      //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Sven Stucki - svstucki@student.ethz.ch                     //\n//                 Andreas Traber - atraber@iis.ee.ethz.ch                    //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Execute stage                                              //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Execution stage: Hosts ALU and MAC unit                    //\n//                 ALU: computes additions/subtractions/comparisons           //\n//                 MULT: computes normal multiplications                      //\n//                 APU_DISP: offloads instructions to the shared unit.        //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_ex_stage\n  import cv32e40p_pkg::*;\n  import cv32e40p_apu_core_pkg::*;\n#(\n    parameter COREV_PULP       = 0,\n    parameter FPU              = 0,\n    parameter APU_NARGS_CPU    = 3,\n    parameter APU_WOP_CPU      = 6,\n    parameter APU_NDSFLAGS_CPU = 15,\n    parameter APU_NUSFLAGS_CPU = 5\n) (\n    input logic clk,\n    input logic rst_n,\n\n    // ALU signals from ID stage\n    input alu_opcode_e        alu_operator_i,\n    input logic        [31:0] alu_operand_a_i,\n    input logic        [31:0] alu_operand_b_i,\n    input logic        [31:0] alu_operand_c_i,\n    input logic               alu_en_i,\n    input logic        [ 4:0] bmask_a_i,\n    input logic        [ 4:0] bmask_b_i,\n    input logic        [ 1:0] imm_vec_ext_i,\n    input logic        [ 1:0] alu_vec_mode_i,\n    input logic               alu_is_clpx_i,\n    input logic               alu_is_subrot_i,\n    input logic        [ 1:0] alu_clpx_shift_i,\n\n    // Multiplier signals\n    input mul_opcode_e        mult_operator_i,\n    input logic        [31:0] mult_operand_a_i,\n    input logic        [31:0] mult_operand_b_i,\n    input logic        [31:0] mult_operand_c_i,\n    input logic               mult_en_i,\n    input logic               mult_sel_subword_i,\n    input logic        [ 1:0] mult_signed_mode_i,\n    input logic        [ 4:0] mult_imm_i,\n\n    input logic [31:0] mult_dot_op_a_i,\n    input logic [31:0] mult_dot_op_b_i,\n    input logic [31:0] mult_dot_op_c_i,\n    input logic [ 1:0] mult_dot_signed_i,\n    input logic        mult_is_clpx_i,\n    input logic [ 1:0] mult_clpx_shift_i,\n    input logic        mult_clpx_img_i,\n\n    output logic mult_multicycle_o,\n\n    input logic data_req_i,\n    input logic data_rvalid_i,\n    input logic data_misaligned_ex_i,\n    input logic data_misaligned_i,\n\n    input logic [1:0] ctrl_transfer_insn_in_dec_i,\n\n    // FPU signals\n    output logic fpu_fflags_we_o,\n    output logic [APU_NUSFLAGS_CPU-1:0] fpu_fflags_o,\n\n    // APU signals\n    input logic                              apu_en_i,\n    input logic [     APU_WOP_CPU-1:0]       apu_op_i,\n    input logic [                 1:0]       apu_lat_i,\n    input logic [   APU_NARGS_CPU-1:0][31:0] apu_operands_i,\n    input logic [                 5:0]       apu_waddr_i,\n    input logic [APU_NUSFLAGS_CPU-1:0]       apu_flags_i,\n\n    input  logic [2:0][5:0] apu_read_regs_i,\n    input  logic [2:0]      apu_read_regs_valid_i,\n    output logic            apu_read_dep_o,\n    output logic            apu_read_dep_for_jalr_o,\n    input  logic [1:0][5:0] apu_write_regs_i,\n    input  logic [1:0]      apu_write_regs_valid_i,\n    output logic            apu_write_dep_o,\n\n    output logic apu_perf_type_o,\n    output logic apu_perf_cont_o,\n    output logic apu_perf_wb_o,\n\n    output logic apu_busy_o,\n    output logic apu_ready_wb_o,\n\n    // apu-interconnect\n    // handshake signals\n    output logic                           apu_req_o,\n    input  logic                           apu_gnt_i,\n    // request channel\n    output logic [APU_NARGS_CPU-1:0][31:0] apu_operands_o,\n    output logic [  APU_WOP_CPU-1:0]       apu_op_o,\n    // response channel\n    input  logic                           apu_rvalid_i,\n    input  logic [             31:0]       apu_result_i,\n\n    input logic        lsu_en_i,\n    input logic [31:0] lsu_rdata_i,\n\n    // input from ID stage\n    input logic       branch_in_ex_i,\n    input logic [5:0] regfile_alu_waddr_i,\n    input logic       regfile_alu_we_i,\n\n    // directly passed through to WB stage, not used in EX\n    input logic       regfile_we_i,\n    input logic [5:0] regfile_waddr_i,\n\n    // CSR access\n    input logic        csr_access_i,\n    input logic [31:0] csr_rdata_i,\n\n    // Output of EX stage pipeline\n    output logic [ 5:0] regfile_waddr_wb_o,\n    output logic        regfile_we_wb_o,\n    output logic        regfile_we_wb_power_o,\n    output logic [31:0] regfile_wdata_wb_o,\n\n    // Forwarding ports : to ID stage\n    output logic [ 5:0] regfile_alu_waddr_fw_o,\n    output logic        regfile_alu_we_fw_o,\n    output logic        regfile_alu_we_fw_power_o,\n    output logic [31:0] regfile_alu_wdata_fw_o,  // forward to RF and ID/EX pipe, ALU & MUL\n\n    // To IF: Jump and branch target and decision\n    output logic [31:0] jump_target_o,\n    output logic        branch_decision_o,\n\n    // Stall Control\n    input logic is_decoding_i, // Used to mask data Dependency inside the APU dispatcher in case of an istruction non valid\n    input logic lsu_ready_ex_i,  // EX part of LSU is done\n    input logic lsu_err_i,\n\n    output logic ex_ready_o,  // EX stage ready for new data\n    output logic ex_valid_o,  // EX stage gets new data\n    input  logic wb_ready_i  // WB stage ready for new data\n);\n\n  logic [                31:0] alu_result;\n  logic [                31:0] mult_result;\n  logic                        alu_cmp_result;\n\n  logic                        regfile_we_lsu;\n  logic [                 5:0] regfile_waddr_lsu;\n\n  logic                        wb_contention;\n  logic                        wb_contention_lsu;\n\n  logic                        alu_ready;\n  logic                        mulh_active;\n  logic                        mult_ready;\n\n  // APU signals\n  logic                        apu_valid;\n  logic [                 5:0] apu_waddr;\n  logic [                31:0] apu_result;\n  logic                        apu_stall;\n  logic                        apu_active;\n  logic                        apu_singlecycle;\n  logic                        apu_multicycle;\n  logic                        apu_req;\n  logic                        apu_gnt;\n\n  logic                        apu_rvalid_q;\n  logic [                31:0] apu_result_q;\n  logic [APU_NUSFLAGS_CPU-1:0] apu_flags_q;\n\n  // ALU write port mux\n  always_comb begin\n    regfile_alu_wdata_fw_o    = '0;\n    regfile_alu_waddr_fw_o    = '0;\n    regfile_alu_we_fw_o       = 1'b0;\n    regfile_alu_we_fw_power_o = 1'b0;\n    wb_contention             = 1'b0;\n\n    // APU single cycle operations, and multicycle operations (> 2cycles) are written back on ALU port\n    if (apu_valid & (apu_singlecycle | apu_multicycle)) begin\n      regfile_alu_we_fw_o       = 1'b1;\n      regfile_alu_we_fw_power_o = 1'b1;\n      regfile_alu_waddr_fw_o    = apu_waddr;\n      regfile_alu_wdata_fw_o    = apu_result;\n\n      if (regfile_alu_we_i & ~apu_en_i) begin\n        wb_contention = 1'b1;\n      end\n    end else begin\n      regfile_alu_we_fw_o = regfile_alu_we_i & ~apu_en_i;\n      regfile_alu_we_fw_power_o = !COREV_PULP ? regfile_alu_we_i & ~apu_en_i : \n                                                regfile_alu_we_i & ~apu_en_i &\n                                                mult_ready & alu_ready & lsu_ready_ex_i;\n      regfile_alu_waddr_fw_o = regfile_alu_waddr_i;\n      if (alu_en_i) regfile_alu_wdata_fw_o = alu_result;\n      if (mult_en_i) regfile_alu_wdata_fw_o = mult_result;\n      if (csr_access_i) regfile_alu_wdata_fw_o = csr_rdata_i;\n    end\n  end\n\n  // LSU write port mux\n  always_comb begin\n    regfile_we_wb_o       = 1'b0;\n    regfile_we_wb_power_o = 1'b0;\n    regfile_waddr_wb_o    = regfile_waddr_lsu;\n    regfile_wdata_wb_o    = lsu_rdata_i;\n    wb_contention_lsu     = 1'b0;\n\n    if (regfile_we_lsu) begin\n      regfile_we_wb_o       = 1'b1;\n      regfile_we_wb_power_o = !COREV_PULP ? 1'b1 : ~data_misaligned_ex_i & wb_ready_i;\n      if (apu_valid & (!apu_singlecycle & !apu_multicycle)) begin\n        wb_contention_lsu = 1'b1;\n      end\n      // APU two-cycle operations are written back on LSU port\n    end else if (apu_valid & (!apu_singlecycle & !apu_multicycle)) begin\n      regfile_we_wb_o       = 1'b1;\n      regfile_we_wb_power_o = 1'b1;\n      regfile_waddr_wb_o    = apu_waddr;\n      regfile_wdata_wb_o    = apu_result;\n    end\n  end\n\n  // branch handling\n  assign branch_decision_o = alu_cmp_result;\n  assign jump_target_o     = alu_operand_c_i;\n\n\n  ////////////////////////////\n  //     _    _    _   _    //\n  //    / \\  | |  | | | |   //\n  //   / _ \\ | |  | | | |   //\n  //  / ___ \\| |__| |_| |   //\n  // /_/   \\_\\_____\\___/    //\n  //                        //\n  ////////////////////////////\n\n  cv32e40p_alu alu_i (\n      .clk        (clk),\n      .rst_n      (rst_n),\n      .enable_i   (alu_en_i),\n      .operator_i (alu_operator_i),\n      .operand_a_i(alu_operand_a_i),\n      .operand_b_i(alu_operand_b_i),\n      .operand_c_i(alu_operand_c_i),\n\n      .vector_mode_i(alu_vec_mode_i),\n      .bmask_a_i    (bmask_a_i),\n      .bmask_b_i    (bmask_b_i),\n      .imm_vec_ext_i(imm_vec_ext_i),\n\n      .is_clpx_i   (alu_is_clpx_i),\n      .clpx_shift_i(alu_clpx_shift_i),\n      .is_subrot_i (alu_is_subrot_i),\n\n      .result_o           (alu_result),\n      .comparison_result_o(alu_cmp_result),\n\n      .ready_o   (alu_ready),\n      .ex_ready_i(ex_ready_o)\n  );\n\n\n  ////////////////////////////////////////////////////////////////\n  //  __  __ _   _ _   _____ ___ ____  _     ___ _____ ____     //\n  // |  \\/  | | | | | |_   _|_ _|  _ \\| |   |_ _| ____|  _ \\    //\n  // | |\\/| | | | | |   | |  | || |_) | |    | ||  _| | |_) |   //\n  // | |  | | |_| | |___| |  | ||  __/| |___ | || |___|  _ <    //\n  // |_|  |_|\\___/|_____|_| |___|_|   |_____|___|_____|_| \\_\\   //\n  //                                                            //\n  ////////////////////////////////////////////////////////////////\n\n  cv32e40p_mult mult_i (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      .enable_i  (mult_en_i),\n      .operator_i(mult_operator_i),\n\n      .short_subword_i(mult_sel_subword_i),\n      .short_signed_i (mult_signed_mode_i),\n\n      .op_a_i(mult_operand_a_i),\n      .op_b_i(mult_operand_b_i),\n      .op_c_i(mult_operand_c_i),\n      .imm_i (mult_imm_i),\n\n      .dot_op_a_i  (mult_dot_op_a_i),\n      .dot_op_b_i  (mult_dot_op_b_i),\n      .dot_op_c_i  (mult_dot_op_c_i),\n      .dot_signed_i(mult_dot_signed_i),\n      .is_clpx_i   (mult_is_clpx_i),\n      .clpx_shift_i(mult_clpx_shift_i),\n      .clpx_img_i  (mult_clpx_img_i),\n\n      .result_o(mult_result),\n\n      .multicycle_o (mult_multicycle_o),\n      .mulh_active_o(mulh_active),\n      .ready_o      (mult_ready),\n      .ex_ready_i   (ex_ready_o)\n  );\n\n  generate\n    if (FPU == 1) begin : gen_apu\n      ////////////////////////////////////////////////////\n      //     _    ____  _   _   ____ ___ ____  ____     //\n      //    / \\  |  _ \\| | | | |  _ \\_ _/ ___||  _ \\    //\n      //   / _ \\ | |_) | | | | | | | | |\\___ \\| |_) |   //\n      //  / ___ \\|  __/| |_| | | |_| | | ___) |  __/    //\n      // /_/   \\_\\_|    \\___/  |____/___|____/|_|       //\n      //                                                //\n      ////////////////////////////////////////////////////\n\n      cv32e40p_apu_disp apu_disp_i (\n          .clk_i (clk),\n          .rst_ni(rst_n),\n\n          .enable_i   (apu_en_i),\n          .apu_lat_i  (apu_lat_i),\n          .apu_waddr_i(apu_waddr_i),\n\n          .apu_waddr_o      (apu_waddr),\n          .apu_multicycle_o (apu_multicycle),\n          .apu_singlecycle_o(apu_singlecycle),\n\n          .active_o(apu_active),\n          .stall_o (apu_stall),\n\n          .is_decoding_i      (is_decoding_i),\n          .read_regs_i        (apu_read_regs_i),\n          .read_regs_valid_i  (apu_read_regs_valid_i),\n          .read_dep_o         (apu_read_dep_o),\n          .read_dep_for_jalr_o(apu_read_dep_for_jalr_o),\n          .write_regs_i       (apu_write_regs_i),\n          .write_regs_valid_i (apu_write_regs_valid_i),\n          .write_dep_o        (apu_write_dep_o),\n\n          .perf_type_o(apu_perf_type_o),\n          .perf_cont_o(apu_perf_cont_o),\n\n          // apu-interconnect\n          // handshake signals\n          .apu_req_o   (apu_req),\n          .apu_gnt_i   (apu_gnt),\n          // response channel\n          .apu_rvalid_i(apu_valid)\n      );\n\n      assign apu_perf_wb_o  = wb_contention | wb_contention_lsu;\n      assign apu_ready_wb_o = ~(apu_active | apu_en_i | apu_stall) | apu_valid;\n\n      ///////////////////////////////////////\n      // APU result memorization Register  //\n      ///////////////////////////////////////\n      always_ff @(posedge clk, negedge rst_n) begin : APU_Result_Memorization\n        if (~rst_n) begin\n          apu_rvalid_q <= 1'b0;\n          apu_result_q <= 'b0;\n          apu_flags_q  <= 'b0;\n        end else begin\n          if (apu_rvalid_i && apu_multicycle &&\n              (data_misaligned_i || data_misaligned_ex_i ||\n               ((data_req_i || data_rvalid_i) && regfile_alu_we_i) ||\n               (mulh_active && (mult_operator_i == MUL_H)) ||\n               ((ctrl_transfer_insn_in_dec_i == BRANCH_JALR) &&\n                regfile_alu_we_i && ~apu_read_dep_for_jalr_o))) begin\n            apu_rvalid_q <= 1'b1;\n            apu_result_q <= apu_result_i;\n            apu_flags_q  <= apu_flags_i;\n          end else if (apu_rvalid_q && !(data_misaligned_i || data_misaligned_ex_i ||\n                                         ((data_req_i || data_rvalid_i) && regfile_alu_we_i) ||\n                                         (mulh_active && (mult_operator_i == MUL_H)) ||\n                                         ((ctrl_transfer_insn_in_dec_i == BRANCH_JALR) &&\n                                          regfile_alu_we_i && ~apu_read_dep_for_jalr_o))) begin\n            apu_rvalid_q <= 1'b0;\n          end\n        end\n      end\n\n      assign apu_req_o = apu_req;\n      assign apu_gnt = apu_gnt_i;\n      assign apu_valid = (apu_multicycle && (data_misaligned_i || data_misaligned_ex_i ||\n                                             ((data_req_i || data_rvalid_i) && regfile_alu_we_i) ||\n                                             (mulh_active && (mult_operator_i == MUL_H)) ||\n                                             ((ctrl_transfer_insn_in_dec_i == BRANCH_JALR) &&\n                                              regfile_alu_we_i && ~apu_read_dep_for_jalr_o)))\n                         ? 1'b0 : (apu_rvalid_i || apu_rvalid_q);\n      assign apu_operands_o = apu_operands_i;\n      assign apu_op_o = apu_op_i;\n      assign apu_result = apu_rvalid_q ? apu_result_q : apu_result_i;\n      assign fpu_fflags_we_o = apu_valid;\n      assign fpu_fflags_o = apu_rvalid_q ? apu_flags_q : apu_flags_i;\n    end else begin : gen_no_apu\n      // default assignements for the case when no FPU/APU is attached.\n      assign apu_req_o               = '0;\n      assign apu_operands_o[0]       = '0;\n      assign apu_operands_o[1]       = '0;\n      assign apu_operands_o[2]       = '0;\n      assign apu_op_o                = '0;\n      assign apu_req                 = 1'b0;\n      assign apu_gnt                 = 1'b0;\n      assign apu_result              = 32'b0;\n      assign apu_valid               = 1'b0;\n      assign apu_waddr               = 6'b0;\n      assign apu_stall               = 1'b0;\n      assign apu_active              = 1'b0;\n      assign apu_ready_wb_o          = 1'b1;\n      assign apu_perf_wb_o           = 1'b0;\n      assign apu_perf_cont_o         = 1'b0;\n      assign apu_perf_type_o         = 1'b0;\n      assign apu_singlecycle         = 1'b0;\n      assign apu_multicycle          = 1'b0;\n      assign apu_read_dep_o          = 1'b0;\n      assign apu_read_dep_for_jalr_o = 1'b0;\n      assign apu_write_dep_o         = 1'b0;\n      assign fpu_fflags_o            = '0;\n      assign fpu_fflags_we_o         = '0;\n    end\n  endgenerate\n\n  assign apu_busy_o = apu_active;\n\n  ///////////////////////////////////////\n  // EX/WB Pipeline Register           //\n  ///////////////////////////////////////\n  always_ff @(posedge clk, negedge rst_n) begin : EX_WB_Pipeline_Register\n    if (~rst_n) begin\n      regfile_waddr_lsu <= '0;\n      regfile_we_lsu    <= 1'b0;\n    end else begin\n      if (ex_valid_o) // wb_ready_i is implied\n      begin\n        regfile_we_lsu <= regfile_we_i & ~lsu_err_i;\n        if (regfile_we_i & ~lsu_err_i) begin\n          regfile_waddr_lsu <= regfile_waddr_i;\n        end\n      end else if (wb_ready_i) begin\n        // we are ready for a new instruction, but there is none available,\n        // so we just flush the current one out of the pipe\n        regfile_we_lsu <= 1'b0;\n      end\n    end\n  end\n\n  // As valid always goes to the right and ready to the left, and we are able\n  // to finish branches without going to the WB stage, ex_valid does not\n  // depend on ex_ready.\n  assign ex_ready_o = (~apu_stall & alu_ready & mult_ready & lsu_ready_ex_i\n                       & wb_ready_i & ~wb_contention) | (branch_in_ex_i);\n  assign ex_valid_o = (apu_valid | alu_en_i | mult_en_i | csr_access_i | lsu_en_i)\n                       & (alu_ready & mult_ready & lsu_ready_ex_i & wb_ready_i);\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Andreas Traber - atraber@student.ethz.ch                   //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    cv32e40p_ff_one                                               //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Find First One                                             //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_ff_one #(\n    parameter LEN = 32\n) (\n    input logic [LEN-1:0] in_i,\n\n    output logic [$clog2(LEN)-1:0] first_one_o,\n    output logic                   no_ones_o\n);\n\n  localparam NUM_LEVELS = $clog2(LEN);\n\n  logic [          LEN-1:0][NUM_LEVELS-1:0] index_lut;\n  logic [2**NUM_LEVELS-1:0]                 sel_nodes;\n  logic [2**NUM_LEVELS-1:0][NUM_LEVELS-1:0] index_nodes;\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // generate tree structure\n  //////////////////////////////////////////////////////////////////////////////\n\n  generate\n    genvar j;\n    for (j = 0; j < LEN; j++) begin : gen_index_lut\n      assign index_lut[j] = $unsigned(j);\n    end\n  endgenerate\n\n  generate\n    genvar k;\n    genvar l;\n    genvar level;\n\n    assign sel_nodes[2**NUM_LEVELS-1] = 1'b0;\n\n    for (level = 0; level < NUM_LEVELS; level++) begin : gen_tree\n      //------------------------------------------------------------\n      if (level < NUM_LEVELS - 1) begin : gen_non_root_level\n        for (l = 0; l < 2 ** level; l++) begin : gen_node\n          assign sel_nodes[2**level-1+l]   = sel_nodes[2**(level+1)-1+l*2] | sel_nodes[2**(level+1)-1+l*2+1];\n          assign index_nodes[2**level-1+l] = (sel_nodes[2**(level+1)-1+l*2] == 1'b1) ?\n                                           index_nodes[2**(level+1)-1+l*2] : index_nodes[2**(level+1)-1+l*2+1];\n        end\n      end\n      //------------------------------------------------------------\n      if (level == NUM_LEVELS - 1) begin : gen_root_level\n        for (k = 0; k < 2 ** level; k++) begin : gen_node\n          // if two successive indices are still in the vector...\n          if (k * 2 < LEN - 1) begin : gen_two\n            assign sel_nodes[2**level-1+k] = in_i[k*2] | in_i[k*2+1];\n            assign index_nodes[2**level-1+k] = (in_i[k*2] == 1'b1) ? index_lut[k*2] : index_lut[k*2+1];\n          end\n          // if only the first index is still in the vector...\n          if (k * 2 == LEN - 1) begin : gen_one\n            assign sel_nodes[2**level-1+k]   = in_i[k*2];\n            assign index_nodes[2**level-1+k] = index_lut[k*2];\n          end\n          // if index is out of range\n          if (k * 2 > LEN - 1) begin : gen_out_of_range\n            assign sel_nodes[2**level-1+k]   = 1'b0;\n            assign index_nodes[2**level-1+k] = '0;\n          end\n        end\n      end\n      //------------------------------------------------------------\n    end\n  endgenerate\n\n  //////////////////////////////////////////////////////////////////////////////\n  // connect output\n  //////////////////////////////////////////////////////////////////////////////\n\n  assign first_one_o = index_nodes[0];\n  assign no_ones_o   = ~sel_nodes[0];\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>\n\n// Copy of fifo_v3 from https://github.com/pulp-platform/common_cells b2a4b2d3decdfc152ad9b4564a48ed3b2649fd6c\n\nmodule cv32e40p_fifo #(\n    parameter bit FALL_THROUGH = 1'b0,  // fifo is in fall-through mode\n    parameter int unsigned DATA_WIDTH = 32,  // default data width if the fifo is of type logic\n    parameter int unsigned DEPTH = 8,  // depth can be arbitrary from 0 to 2**32\n    // DO NOT OVERWRITE THIS PARAMETER\n    parameter int unsigned ADDR_DEPTH = (DEPTH > 1) ? $clog2(DEPTH) : 1\n) (\n    input logic clk_i,  // Clock\n    input logic rst_ni,  // Asynchronous reset active low\n    input logic flush_i,  // flush the queue\n    input logic flush_but_first_i,  // flush the queue except the first instruction\n    input logic testmode_i,  // test_mode to bypass clock gating\n    // status flags\n    output logic full_o,  // queue is full\n    output logic empty_o,  // queue is empty\n    output logic [ADDR_DEPTH:0] cnt_o,  // FIFO counter\n    // as long as the queue is not full we can push new data\n    input logic [DATA_WIDTH-1:0] data_i,  // data to push into the queue\n    input logic push_i,  // data is valid and can be pushed to the queue\n    // as long as the queue is not empty we can pop new elements\n    output logic [DATA_WIDTH-1:0] data_o,  // output data\n    input logic pop_i  // pop head from queue\n);\n  // local parameter\n  // FIFO depth - handle the case of pass-through, synthesizer will do constant propagation\n  localparam int unsigned FIFO_DEPTH = (DEPTH > 0) ? DEPTH : 1;\n  // clock gating control\n  logic gate_clock;\n  // pointer to the read and write section of the queue\n  logic [ADDR_DEPTH - 1:0] read_pointer_n, read_pointer_q, write_pointer_n, write_pointer_q;\n  // keep a counter to keep track of the current queue status\n  logic [ADDR_DEPTH:0]\n      status_cnt_n, status_cnt_q;  // this integer will be truncated by the synthesis tool\n  // actual memory\n  logic [FIFO_DEPTH - 1:0][DATA_WIDTH-1:0] mem_n, mem_q;\n\n  assign cnt_o = status_cnt_q;\n\n  // status flags\n  generate\n    if (DEPTH == 0) begin : gen_zero_depth\n      assign empty_o = ~push_i;\n      assign full_o  = ~pop_i;\n    end else begin : gen_non_zero_depth\n      assign full_o  = (status_cnt_q == FIFO_DEPTH[ADDR_DEPTH:0]);\n      assign empty_o = (status_cnt_q == 0) & ~(FALL_THROUGH & push_i);\n    end\n  endgenerate\n\n  // read and write queue logic\n  always_comb begin : read_write_comb\n    // default assignment\n    read_pointer_n  = read_pointer_q;\n    write_pointer_n = write_pointer_q;\n    status_cnt_n    = status_cnt_q;\n    data_o          = (DEPTH == 0) ? data_i : mem_q[read_pointer_q];\n    mem_n           = mem_q;\n    gate_clock      = 1'b1;\n\n    // push a new element to the queue\n    if (push_i && ~full_o) begin\n      // push the data onto the queue\n      mem_n[write_pointer_q] = data_i;\n      // un-gate the clock, we want to write something\n      gate_clock = 1'b0;\n      // increment the write counter\n      if (write_pointer_q == FIFO_DEPTH[ADDR_DEPTH-1:0] - 1) write_pointer_n = '0;\n      else write_pointer_n = write_pointer_q + 1;\n      // increment the overall counter\n      status_cnt_n = status_cnt_q + 1;\n    end\n\n    if (pop_i && ~empty_o) begin\n      // read from the queue is a default assignment\n      // but increment the read pointer...\n      if (read_pointer_n == FIFO_DEPTH[ADDR_DEPTH-1:0] - 1) read_pointer_n = '0;\n      else read_pointer_n = read_pointer_q + 1;\n      // ... and decrement the overall count\n      status_cnt_n = status_cnt_q - 1;\n    end\n\n    // keep the count pointer stable if we push and pop at the same time\n    if (push_i && pop_i && ~full_o && ~empty_o) status_cnt_n = status_cnt_q;\n\n    // FIFO is in pass through mode -> do not change the pointers\n    if (FALL_THROUGH && (status_cnt_q == 0) && push_i) begin\n      data_o = data_i;\n      if (pop_i) begin\n        status_cnt_n = status_cnt_q;\n        read_pointer_n = read_pointer_q;\n        write_pointer_n = write_pointer_q;\n      end\n    end\n  end\n\n  // sequential process\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      read_pointer_q  <= '0;\n      write_pointer_q <= '0;\n      status_cnt_q    <= '0;\n    end else begin\n      unique case (1'b1)\n        // Flush the FIFO\n        flush_i: begin\n          read_pointer_q  <= '0;\n          write_pointer_q <= '0;\n          status_cnt_q    <= '0;\n        end\n        // Flush the FIFO but keep the first instruction alive if present\n        flush_but_first_i: begin\n          read_pointer_q  <= (status_cnt_q > 0) ? read_pointer_q : '0;\n          write_pointer_q <= (status_cnt_q > 0) ? read_pointer_q + 1 : '0;\n          status_cnt_q    <= (status_cnt_q > 0) ? 1'b1 : '0;\n        end\n        // If we are not flushing, update the pointers\n        default: begin\n          read_pointer_q  <= read_pointer_n;\n          write_pointer_q <= write_pointer_n;\n          status_cnt_q    <= status_cnt_n;\n        end\n      endcase\n    end\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      mem_q <= '0;\n    end else if (!gate_clock) begin\n      mem_q <= mem_n;\n    end\n  end\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Assertions\n  //////////////////////////////////////////////////////////////////////////////\n\n`ifdef CV32E40P_ASSERT_ON\n\n  initial begin\n    assert (DEPTH > 0)\n    else $error(\"DEPTH must be greater than 0.\");\n  end\n\n  full_write :\n  assert property (@(posedge clk_i) disable iff (~rst_ni) (full_o |-> ~push_i))\n  else $fatal(1, \"Trying to push new data although the FIFO is full.\");\n\n  empty_read :\n  assert property (@(posedge clk_i) disable iff (~rst_ni) (empty_o |-> ~pop_i))\n  else $fatal(1, \"Trying to pop data although the FIFO is empty.\");\n`endif\n\nendmodule  // cv32e40p_fifo\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// Wrapper for a fpnew\n// Contributor: Davide Schiavone <davide@openhwgroup.org>\n\nmodule cv32e40p_fp_wrapper\n  import cv32e40p_apu_core_pkg::*;\n#(\n    parameter FPU_ADDMUL_LAT = 0,  // Floating-Point ADDition/MULtiplication computing lane pipeline registers number\n    parameter FPU_OTHERS_LAT = 0  // Floating-Point COMParison/CONVersion computing lanes pipeline registers number\n) (\n    // Clock and Reset\n    input logic clk_i,\n    input logic rst_ni,\n\n    // APU Side: Master port\n    input  logic apu_req_i,\n    output logic apu_gnt_o,\n\n    // request channel\n    input logic [   APU_NARGS_CPU-1:0][31:0] apu_operands_i,\n    input logic [     APU_WOP_CPU-1:0]       apu_op_i,\n    input logic [APU_NDSFLAGS_CPU-1:0]       apu_flags_i,\n\n    // response channel\n    output logic                        apu_rvalid_o,\n    output logic [                31:0] apu_rdata_o,\n    output logic [APU_NUSFLAGS_CPU-1:0] apu_rflags_o\n);\n\n\n  import cv32e40p_pkg::*;\n  import fpnew_pkg::*;\n\n  logic [        fpnew_pkg::OP_BITS-1:0] fpu_op;\n  logic                                  fpu_op_mod;\n  logic                                  fpu_vec_op;\n\n  logic [ fpnew_pkg::FP_FORMAT_BITS-1:0] fpu_dst_fmt;\n  logic [ fpnew_pkg::FP_FORMAT_BITS-1:0] fpu_src_fmt;\n  logic [fpnew_pkg::INT_FORMAT_BITS-1:0] fpu_int_fmt;\n  logic [                      C_RM-1:0] fp_rnd_mode;\n\n\n\n  // assign apu_rID_o = '0;\n  assign {fpu_vec_op, fpu_op_mod, fpu_op}                     = apu_op_i;\n\n  assign {fpu_int_fmt, fpu_src_fmt, fpu_dst_fmt, fp_rnd_mode} = apu_flags_i;\n\n\n\n  // -----------\n  // FPU Config\n  // -----------\n  // Features (enabled formats, vectors etc.)\n  localparam fpnew_pkg::fpu_features_t FPU_FEATURES = '{\n      Width: C_FLEN,\n      EnableVectors: C_XFVEC,\n      EnableNanBox: 1'b0,\n      FpFmtMask: {\n    C_RVF, C_RVD, C_XF16, C_XF8, C_XF16ALT\n  }, IntFmtMask: {\n    C_XFVEC && C_XF8, C_XFVEC && (C_XF16 || C_XF16ALT), 1'b1, 1'b0\n  }};\n\n  // Implementation (number of registers etc)\n  localparam fpnew_pkg::fpu_implementation_t FPU_IMPLEMENTATION = '{\n      PipeRegs: '{  // FP32, FP64, FP16, FP8, FP16alt\n      '{\n          FPU_ADDMUL_LAT, C_LAT_FP64, C_LAT_FP16, C_LAT_FP8, C_LAT_FP16ALT\n      },  // ADDMUL\n      '{default: C_LAT_DIVSQRT},  // DIVSQRT\n      '{default: FPU_OTHERS_LAT},  // NONCOMP\n      '{default: FPU_OTHERS_LAT}\n  },  // CONV\n  UnitTypes: '{\n      '{default: fpnew_pkg::MERGED},  // ADDMUL\n      '{default: fpnew_pkg::MERGED},  // DIVSQRT\n      '{default: fpnew_pkg::PARALLEL},  // NONCOMP\n      '{default: fpnew_pkg::MERGED}\n  },  // CONV\n  PipeConfig: fpnew_pkg::AFTER};\n\n  //---------------\n  // FPU instance\n  //---------------\n\n  fpnew_top #(\n      .Features      (FPU_FEATURES),\n      .Implementation(FPU_IMPLEMENTATION),\n      .PulpDivsqrt   (1'b0),\n      .TagType       (logic)\n  ) i_fpnew_bulk (\n      .clk_i         (clk_i),\n      .rst_ni        (rst_ni),\n      .operands_i    (apu_operands_i),\n      .rnd_mode_i    (fpnew_pkg::roundmode_e'(fp_rnd_mode)),\n      .op_i          (fpnew_pkg::operation_e'(fpu_op)),\n      .op_mod_i      (fpu_op_mod),\n      .src_fmt_i     (fpnew_pkg::fp_format_e'(fpu_src_fmt)),\n      .dst_fmt_i     (fpnew_pkg::fp_format_e'(fpu_dst_fmt)),\n      .int_fmt_i     (fpnew_pkg::int_format_e'(fpu_int_fmt)),\n      .vectorial_op_i(fpu_vec_op),\n      .tag_i         (1'b0),\n      .simd_mask_i   (1'b0),\n      .in_valid_i    (apu_req_i),\n      .in_ready_o    (apu_gnt_o),\n      .flush_i       (1'b0),\n      .result_o      (apu_rdata_o),\n      .status_o      (apu_rflags_o),\n      .tag_o         (  /* unused */),\n      .out_valid_o   (apu_rvalid_o),\n      .out_ready_i   (1'b1),\n      .busy_o        (  /* unused */)\n  );\n\nendmodule  // cv32e40p_fp_wrapper\n\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    hwloop regs                                                //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Hardware loop registers                                    //\n//                 a) store start/end address of N=4 hardware loops           //\n//                 b) store init value of counter for each hardware loop      //\n//                 c) decrement counter if hwloop taken                       //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_hwloop_regs #(\n    parameter N_REGS     = 2,\n    parameter N_REG_BITS = $clog2(N_REGS)\n) (\n    input logic clk,\n    input logic rst_n,\n\n    // from ex stage\n    input logic [          31:0] hwlp_start_data_i,\n    input logic [          31:0] hwlp_end_data_i,\n    input logic [          31:0] hwlp_cnt_data_i,\n    input logic [           2:0] hwlp_we_i,\n    input logic [N_REG_BITS-1:0] hwlp_regid_i,  // selects the register set\n\n    // from controller\n    input logic valid_i,\n\n    // from hwloop controller\n    input logic [N_REGS-1:0] hwlp_dec_cnt_i,\n\n    // to hwloop controller\n    output logic [N_REGS-1:0][31:0] hwlp_start_addr_o,\n    output logic [N_REGS-1:0][31:0] hwlp_end_addr_o,\n    output logic [N_REGS-1:0][31:0] hwlp_counter_o\n);\n\n\n  logic [N_REGS-1:0][31:0] hwlp_start_q;\n  logic [N_REGS-1:0][31:0] hwlp_end_q;\n  logic [N_REGS-1:0][31:0] hwlp_counter_q, hwlp_counter_n;\n\n  int unsigned i;\n\n\n  assign hwlp_start_addr_o = hwlp_start_q;\n  assign hwlp_end_addr_o   = hwlp_end_q;\n  assign hwlp_counter_o    = hwlp_counter_q;\n\n\n  /////////////////////////////////////////////////////////////////////////////////\n  // HWLOOP start-address register                                               //\n  /////////////////////////////////////////////////////////////////////////////////\n  always_ff @(posedge clk, negedge rst_n) begin : HWLOOP_REGS_START\n    if (rst_n == 1'b0) begin\n      hwlp_start_q <= '{default: 32'b0};\n    end else if (hwlp_we_i[0] == 1'b1) begin\n      hwlp_start_q[hwlp_regid_i] <= {hwlp_start_data_i[31:2], 2'b0};\n    end\n  end\n\n\n  /////////////////////////////////////////////////////////////////////////////////\n  // HWLOOP end-address register                                                 //\n  /////////////////////////////////////////////////////////////////////////////////\n  always_ff @(posedge clk, negedge rst_n) begin : HWLOOP_REGS_END\n    if (rst_n == 1'b0) begin\n      hwlp_end_q <= '{default: 32'b0};\n    end else if (hwlp_we_i[1] == 1'b1) begin\n      hwlp_end_q[hwlp_regid_i] <= {hwlp_end_data_i[31:2], 2'b0};\n    end\n  end\n\n\n  /////////////////////////////////////////////////////////////////////////////////\n  // HWLOOP counter register with decrement logic                                //\n  /////////////////////////////////////////////////////////////////////////////////\n  genvar k;\n  for (k = 0; k < N_REGS; k++) begin\n    assign hwlp_counter_n[k] = hwlp_counter_q[k] - 1;\n  end\n\n  always_ff @(posedge clk, negedge rst_n) begin : HWLOOP_REGS_COUNTER\n    if (rst_n == 1'b0) begin\n      hwlp_counter_q <= '{default: 32'b0};\n    end else begin\n      for (i = 0; i < N_REGS; i++) begin\n        if ((hwlp_we_i[2] == 1'b1) && (i == hwlp_regid_i)) begin\n          hwlp_counter_q[i] <= hwlp_cnt_data_i;\n        end else begin\n          if (hwlp_dec_cnt_i[i] && valid_i) hwlp_counter_q[i] <= hwlp_counter_n[i];\n        end\n      end\n    end\n  end\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n`ifdef CV32E40P_ASSERT_ON\n  // do not decrement more than one counter at once\n  assert property (@(posedge clk) (valid_i) |-> ($countones(hwlp_dec_cnt_i) <= 1));\n`endif\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Renzo Andri - andrire@student.ethz.ch                      //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Andreas Traber - atraber@student.ethz.ch                   //\n//                 Sven Stucki - svstucki@student.ethz.ch                     //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Instruction Decode Stage                                   //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Decode stage of the core. It decodes the instructions      //\n//                 and hosts the register file.                               //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_id_stage\n  import cv32e40p_pkg::*;\n  import cv32e40p_apu_core_pkg::*;\n#(\n    parameter COREV_PULP =  1,  // PULP ISA Extension (including PULP specific CSRs and hardware loop, excluding cv.elw)\n    parameter COREV_CLUSTER = 0,\n    parameter N_HWLP = 2,\n    parameter N_HWLP_BITS = $clog2(N_HWLP),\n    parameter PULP_SECURE = 0,\n    parameter USE_PMP = 0,\n    parameter A_EXTENSION = 0,\n    parameter APU = 0,\n    parameter FPU = 0,\n    parameter FPU_ADDMUL_LAT = 0,\n    parameter FPU_OTHERS_LAT = 0,\n    parameter ZFINX = 0,\n    parameter APU_NARGS_CPU = 3,\n    parameter APU_WOP_CPU = 6,\n    parameter APU_NDSFLAGS_CPU = 15,\n    parameter APU_NUSFLAGS_CPU = 5,\n    parameter DEBUG_TRIGGER_EN = 1\n) (\n    input logic clk,  // Gated clock\n    input logic clk_ungated_i,  // Ungated clock\n    input logic rst_n,\n\n    input logic scan_cg_en_i,\n\n    input  logic fetch_enable_i,\n    output logic ctrl_busy_o,\n    output logic is_decoding_o,\n\n    // Interface to IF stage\n    input  logic        instr_valid_i,\n    input  logic [31:0] instr_rdata_i,  // comes from pipeline of IF stage\n    output logic        instr_req_o,\n    input  logic        is_compressed_i,\n    input  logic        illegal_c_insn_i,\n\n    // Jumps and branches\n    output logic        branch_in_ex_o,\n    input  logic        branch_decision_i,\n    output logic [31:0] jump_target_o,\n    output logic [ 1:0] ctrl_transfer_insn_in_dec_o,\n\n    // IF and ID stage signals\n    output logic       clear_instr_valid_o,\n    output logic       pc_set_o,\n    output logic [3:0] pc_mux_o,\n    output logic [2:0] exc_pc_mux_o,\n    output logic [1:0] trap_addr_mux_o,\n\n\n    input logic is_fetch_failed_i,\n\n    input logic [31:0] pc_id_i,\n\n    // Stalls\n    output logic halt_if_o,  // controller requests a halt of the IF stage\n\n    output logic id_ready_o,  // ID stage is ready for the next instruction\n    input  logic ex_ready_i,  // EX stage is ready for the next instruction\n    input  logic wb_ready_i,  // WB stage is ready for the next instruction\n\n    output logic id_valid_o,  // ID stage is done\n    input  logic ex_valid_i,  // EX stage is done\n\n    // Pipeline ID/EX\n    output logic [31:0] pc_ex_o,\n\n    output logic [31:0] alu_operand_a_ex_o,\n    output logic [31:0] alu_operand_b_ex_o,\n    output logic [31:0] alu_operand_c_ex_o,\n    output logic [ 4:0] bmask_a_ex_o,\n    output logic [ 4:0] bmask_b_ex_o,\n    output logic [ 1:0] imm_vec_ext_ex_o,\n    output logic [ 1:0] alu_vec_mode_ex_o,\n\n    output logic [5:0] regfile_waddr_ex_o,\n    output logic       regfile_we_ex_o,\n\n    output logic [5:0] regfile_alu_waddr_ex_o,\n    output logic       regfile_alu_we_ex_o,\n\n    // ALU\n    output logic              alu_en_ex_o,\n    output alu_opcode_e       alu_operator_ex_o,\n    output logic              alu_is_clpx_ex_o,\n    output logic              alu_is_subrot_ex_o,\n    output logic        [1:0] alu_clpx_shift_ex_o,\n\n    // MUL\n    output mul_opcode_e        mult_operator_ex_o,\n    output logic        [31:0] mult_operand_a_ex_o,\n    output logic        [31:0] mult_operand_b_ex_o,\n    output logic        [31:0] mult_operand_c_ex_o,\n    output logic               mult_en_ex_o,\n    output logic               mult_sel_subword_ex_o,\n    output logic        [ 1:0] mult_signed_mode_ex_o,\n    output logic        [ 4:0] mult_imm_ex_o,\n\n    output logic [31:0] mult_dot_op_a_ex_o,\n    output logic [31:0] mult_dot_op_b_ex_o,\n    output logic [31:0] mult_dot_op_c_ex_o,\n    output logic [ 1:0] mult_dot_signed_ex_o,\n    output logic        mult_is_clpx_ex_o,\n    output logic [ 1:0] mult_clpx_shift_ex_o,\n    output logic        mult_clpx_img_ex_o,\n\n    // APU\n    output logic                              apu_en_ex_o,\n    output logic [     APU_WOP_CPU-1:0]       apu_op_ex_o,\n    output logic [                 1:0]       apu_lat_ex_o,\n    output logic [   APU_NARGS_CPU-1:0][31:0] apu_operands_ex_o,\n    output logic [APU_NDSFLAGS_CPU-1:0]       apu_flags_ex_o,\n    output logic [                 5:0]       apu_waddr_ex_o,\n\n    output logic [2:0][5:0] apu_read_regs_o,\n    output logic [2:0]      apu_read_regs_valid_o,\n    input  logic            apu_read_dep_i,\n    input  logic            apu_read_dep_for_jalr_i,\n    output logic [1:0][5:0] apu_write_regs_o,\n    output logic [1:0]      apu_write_regs_valid_o,\n    input  logic            apu_write_dep_i,\n    output logic            apu_perf_dep_o,\n    input  logic            apu_busy_i,\n\n    input logic            fs_off_i,\n    input logic [C_RM-1:0] frm_i,\n\n    // CSR ID/EX\n    output logic              csr_access_ex_o,\n    output csr_opcode_e       csr_op_ex_o,\n    input  PrivLvl_t          current_priv_lvl_i,\n    output logic              csr_irq_sec_o,\n    output logic        [5:0] csr_cause_o,\n    output logic              csr_save_if_o,\n    output logic              csr_save_id_o,\n    output logic              csr_save_ex_o,\n    output logic              csr_restore_mret_id_o,\n    output logic              csr_restore_uret_id_o,\n    output logic              csr_restore_dret_id_o,\n    output logic              csr_save_cause_o,\n\n    // hwloop signals\n    output logic [N_HWLP-1:0][31:0] hwlp_start_o,\n    output logic [N_HWLP-1:0][31:0] hwlp_end_o,\n    output logic [N_HWLP-1:0][31:0] hwlp_cnt_o,\n    output logic                    hwlp_jump_o,\n    output logic [      31:0]       hwlp_target_o,\n\n    // Interface to load store unit\n    output logic       data_req_ex_o,\n    output logic       data_we_ex_o,\n    output logic [1:0] data_type_ex_o,\n    output logic [1:0] data_sign_ext_ex_o,\n    output logic [1:0] data_reg_offset_ex_o,\n    output logic       data_load_event_ex_o,\n\n    output logic data_misaligned_ex_o,\n\n    output logic prepost_useincr_ex_o,\n    input  logic data_misaligned_i,\n    input  logic data_err_i,\n    output logic data_err_ack_o,\n\n    output logic [5:0] atop_ex_o,\n\n    // Interrupt signals\n    input  logic [31:0] irq_i,\n    input  logic        irq_sec_i,\n    input  logic [31:0] mie_bypass_i,  // MIE CSR (bypass)\n    output logic [31:0] mip_o,  // MIP CSR\n    input  logic        m_irq_enable_i,\n    input  logic        u_irq_enable_i,\n    output logic        irq_ack_o,\n    output logic [ 4:0] irq_id_o,\n    output logic [ 4:0] exc_cause_o,\n\n    // Debug Signal\n    output logic       debug_mode_o,\n    output logic [2:0] debug_cause_o,\n    output logic       debug_csr_save_o,\n    input  logic       debug_req_i,\n    input  logic       debug_single_step_i,\n    input  logic       debug_ebreakm_i,\n    input  logic       debug_ebreaku_i,\n    input  logic       trigger_match_i,\n    output logic       debug_p_elw_no_sleep_o,\n    output logic       debug_havereset_o,\n    output logic       debug_running_o,\n    output logic       debug_halted_o,\n\n    // Wakeup Signal\n    output logic wake_from_sleep_o,\n\n    // Forward Signals\n    input logic [5:0] regfile_waddr_wb_i,\n    input logic regfile_we_wb_i,\n    input logic regfile_we_wb_power_i,\n    input  logic [31:0] regfile_wdata_wb_i, // From wb_stage: selects data from data memory, ex_stage result and sp rdata\n\n    input logic [ 5:0] regfile_alu_waddr_fw_i,\n    input logic        regfile_alu_we_fw_i,\n    input logic        regfile_alu_we_fw_power_i,\n    input logic [31:0] regfile_alu_wdata_fw_i,\n\n    // from ALU\n    input  logic        mult_multicycle_i,    // when we need multiple cycles in the multiplier and use op c as storage\n\n    // Performance Counters\n    output logic mhpmevent_minstret_o,\n    output logic mhpmevent_load_o,\n    output logic mhpmevent_store_o,\n    output logic mhpmevent_jump_o,\n    output logic mhpmevent_branch_o,\n    output logic mhpmevent_branch_taken_o,\n    output logic mhpmevent_compressed_o,\n    output logic mhpmevent_jr_stall_o,\n    output logic mhpmevent_imiss_o,\n    output logic mhpmevent_ld_stall_o,\n    output logic mhpmevent_pipe_stall_o,\n\n    input logic        perf_imiss_i,\n    input logic [31:0] mcounteren_i\n);\n\n  // Source/Destination register instruction index\n  localparam REG_S1_MSB = 19;\n  localparam REG_S1_LSB = 15;\n\n  localparam REG_S2_MSB = 24;\n  localparam REG_S2_LSB = 20;\n\n  localparam REG_S4_MSB = 31;\n  localparam REG_S4_LSB = 27;\n\n  localparam REG_D_MSB = 11;\n  localparam REG_D_LSB = 7;\n\n  logic [31:0] instr;\n\n\n  // Decoder/Controller ID stage internal signals\n  logic        deassert_we;\n\n  logic        illegal_insn_dec;\n  logic        ebrk_insn_dec;\n  logic        mret_insn_dec;\n  logic        uret_insn_dec;\n\n  logic        dret_insn_dec;\n\n  logic        ecall_insn_dec;\n  logic        wfi_insn_dec;\n\n  logic        fencei_insn_dec;\n\n  logic        rega_used_dec;\n  logic        regb_used_dec;\n  logic        regc_used_dec;\n\n  logic        branch_taken_ex;\n  logic [ 1:0] ctrl_transfer_insn_in_id;\n  logic [ 1:0] ctrl_transfer_insn_in_dec;\n\n  logic        misaligned_stall;\n  logic        jr_stall;\n  logic        load_stall;\n  logic        csr_apu_stall;\n  logic        hwlp_mask;\n  logic        halt_id;\n  logic        halt_if;\n\n  logic        debug_wfi_no_sleep;\n\n  // Immediate decoding and sign extension\n  logic [31:0] imm_i_type;\n  logic [31:0] imm_iz_type;\n  logic [31:0] imm_s_type;\n  logic [31:0] imm_sb_type;\n  logic [31:0] imm_u_type;\n  logic [31:0] imm_uj_type;\n  logic [31:0] imm_z_type;\n  logic [31:0] imm_s2_type;\n  logic [31:0] imm_bi_type;\n  logic [31:0] imm_s3_type;\n  logic [31:0] imm_vs_type;\n  logic [31:0] imm_vu_type;\n  logic [31:0] imm_shuffleb_type;\n  logic [31:0] imm_shuffleh_type;\n  logic [31:0] imm_shuffle_type;\n  logic [31:0] imm_clip_type;\n\n  logic [31:0] imm_a;  // contains the immediate for operand b\n  logic [31:0] imm_b;  // contains the immediate for operand b\n\n  logic [31:0] jump_target;  // calculated jump target (-> EX -> IF)\n\n  // Signals running between controller and int_controller\n  logic        irq_req_ctrl;\n  logic        irq_sec_ctrl;\n  logic        irq_wu_ctrl;\n  logic [ 4:0] irq_id_ctrl;\n\n  // Register file interface\n  logic [ 5:0] regfile_addr_ra_id;\n  logic [ 5:0] regfile_addr_rb_id;\n  logic [ 5:0] regfile_addr_rc_id;\n\n  logic        regfile_fp_a;\n  logic        regfile_fp_b;\n  logic        regfile_fp_c;\n  logic        regfile_fp_d;\n\n  logic [ 5:0] regfile_waddr_id;\n  logic [ 5:0] regfile_alu_waddr_id;\n  logic regfile_alu_we_id, regfile_alu_we_dec_id;\n\n  logic [31:0] regfile_data_ra_id;\n  logic [31:0] regfile_data_rb_id;\n  logic [31:0] regfile_data_rc_id;\n\n  // ALU Control\n  logic alu_en;\n  alu_opcode_e alu_operator;\n  logic [2:0] alu_op_a_mux_sel;\n  logic [2:0] alu_op_b_mux_sel;\n  logic [1:0] alu_op_c_mux_sel;\n  logic [1:0] regc_mux;\n\n  logic [0:0] imm_a_mux_sel;\n  logic [3:0] imm_b_mux_sel;\n  logic [1:0] ctrl_transfer_target_mux_sel;\n\n  // Multiplier Control\n  mul_opcode_e mult_operator;  // multiplication operation selection\n  logic mult_en;  // multiplication is used instead of ALU\n  logic mult_int_en;  // use integer multiplier\n  logic mult_sel_subword;  // Select a subword when doing multiplications\n  logic [1:0]  mult_signed_mode; // Signed mode multiplication at the output of the controller, and before the pipe registers\n  logic mult_dot_en;  // use dot product\n  logic [1:0] mult_dot_signed;  // Signed mode dot products (can be mixed types)\n\n  // FPU signals\n  logic [cv32e40p_fpu_pkg::FP_FORMAT_BITS-1:0] fpu_src_fmt;\n  logic [cv32e40p_fpu_pkg::FP_FORMAT_BITS-1:0] fpu_dst_fmt;\n  logic [cv32e40p_fpu_pkg::INT_FORMAT_BITS-1:0] fpu_int_fmt;\n\n  // APU signals\n  logic apu_en;\n  logic [APU_WOP_CPU-1:0] apu_op;\n  logic [1:0] apu_lat;\n  logic [APU_NARGS_CPU-1:0][31:0] apu_operands;\n  logic [APU_NDSFLAGS_CPU-1:0] apu_flags;\n  logic [5:0] apu_waddr;\n\n  logic [2:0][5:0] apu_read_regs;\n  logic [2:0] apu_read_regs_valid;\n  logic [1:0][5:0] apu_write_regs;\n  logic [1:0] apu_write_regs_valid;\n\n  logic apu_stall;\n  logic [2:0] fp_rnd_mode;\n\n  // Register Write Control\n  logic regfile_we_id;\n  logic regfile_alu_waddr_mux_sel;\n\n  // Data Memory Control\n  logic data_we_id;\n  logic [1:0] data_type_id;\n  logic [1:0] data_sign_ext_id;\n  logic [1:0] data_reg_offset_id;\n  logic data_req_id;\n  logic data_load_event_id;\n\n  // Atomic memory instruction\n  logic [5:0] atop_id;\n\n  // hwloop signals\n  logic [N_HWLP_BITS-1:0] hwlp_regid;\n  logic [2:0] hwlp_we, hwlp_we_masked;\n  logic        [       1:0] hwlp_target_mux_sel;\n  logic        [       1:0] hwlp_start_mux_sel;\n  logic                     hwlp_cnt_mux_sel;\n\n  logic        [      31:0] hwlp_start;\n  logic        [      31:0] hwlp_end;\n  logic        [      31:0] hwlp_cnt;\n  logic        [N_HWLP-1:0] hwlp_dec_cnt;\n  logic                     hwlp_valid;\n\n  // CSR control\n  logic                     csr_access;\n  csr_opcode_e              csr_op;\n  logic                     csr_status;\n\n  logic                     prepost_useincr;\n\n  // Forwarding\n  logic        [       1:0] operand_a_fw_mux_sel;\n  logic        [       1:0] operand_b_fw_mux_sel;\n  logic        [       1:0] operand_c_fw_mux_sel;\n  logic        [      31:0] operand_a_fw_id;\n  logic        [      31:0] operand_b_fw_id;\n  logic        [      31:0] operand_c_fw_id;\n\n  logic [31:0] operand_b, operand_b_vec;\n  logic [31:0] operand_c, operand_c_vec;\n\n  logic [31:0] alu_operand_a;\n  logic [31:0] alu_operand_b;\n  logic [31:0] alu_operand_c;\n\n  // Immediates for ID\n  logic [ 0:0] bmask_a_mux;\n  logic [ 1:0] bmask_b_mux;\n  logic        alu_bmask_a_mux_sel;\n  logic        alu_bmask_b_mux_sel;\n  logic [ 0:0] mult_imm_mux;\n\n  logic [ 4:0] bmask_a_id_imm;\n  logic [ 4:0] bmask_b_id_imm;\n  logic [ 4:0] bmask_a_id;\n  logic [ 4:0] bmask_b_id;\n  logic [ 1:0] imm_vec_ext_id;\n  logic [ 4:0] mult_imm_id;\n\n  logic        alu_vec;\n  logic [ 1:0] alu_vec_mode;\n  logic        scalar_replication;\n  logic        scalar_replication_c;\n\n  // Forwarding detection signals\n  logic        reg_d_ex_is_reg_a_id;\n  logic        reg_d_ex_is_reg_b_id;\n  logic        reg_d_ex_is_reg_c_id;\n  logic        reg_d_wb_is_reg_a_id;\n  logic        reg_d_wb_is_reg_b_id;\n  logic        reg_d_wb_is_reg_c_id;\n  logic        reg_d_alu_is_reg_a_id;\n  logic        reg_d_alu_is_reg_b_id;\n  logic        reg_d_alu_is_reg_c_id;\n\n  logic is_clpx, is_subrot;\n\n  logic mret_dec;\n  logic uret_dec;\n  logic dret_dec;\n\n  // Performance counters\n  logic id_valid_q;\n  logic minstret;\n  logic perf_pipeline_stall;\n\n  assign instr = instr_rdata_i;\n\n\n  // immediate extraction and sign extension\n  assign imm_i_type = {{20{instr[31]}}, instr[31:20]};\n  assign imm_iz_type = {20'b0, instr[31:20]};\n  assign imm_s_type = {{20{instr[31]}}, instr[31:25], instr[11:7]};\n  assign imm_sb_type = {{19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0};\n  assign imm_u_type = {instr[31:12], 12'b0};\n  assign imm_uj_type = {{12{instr[31]}}, instr[19:12], instr[20], instr[30:21], 1'b0};\n\n  // immediate for CSR manipulatin (zero extended)\n  assign imm_z_type = {27'b0, instr[REG_S1_MSB:REG_S1_LSB]};\n\n  assign imm_s2_type = {27'b0, instr[24:20]};\n  assign imm_bi_type = {{27{instr[24]}}, instr[24:20]};\n  assign imm_s3_type = {27'b0, instr[29:25]};\n  assign imm_vs_type = {{26{instr[24]}}, instr[24:20], instr[25]};\n  assign imm_vu_type = {26'b0, instr[24:20], instr[25]};\n\n  // same format as rS2 for shuffle needs, expands immediate\n  assign imm_shuffleb_type = {\n    6'b0, instr[28:27], 6'b0, instr[24:23], 6'b0, instr[22:21], 6'b0, instr[20], instr[25]\n  };\n  assign imm_shuffleh_type = {15'h0, instr[20], 15'h0, instr[25]};\n\n  // clipping immediate, uses a small barrel shifter to pre-process the\n  // immediate and an adder to subtract 1\n  // The end result is a mask that has 1's set in the lower part\n  assign imm_clip_type = (32'h1 << instr[24:20]) - 1;\n\n  //---------------------------------------------------------------------------\n  // source register selection regfile_fp_x=1 <=> CV32E40P_REG_x is a FP-register\n  //---------------------------------------------------------------------------\n  assign regfile_addr_ra_id = {regfile_fp_a, instr[REG_S1_MSB:REG_S1_LSB]};\n  assign regfile_addr_rb_id = {regfile_fp_b, instr[REG_S2_MSB:REG_S2_LSB]};\n\n  // register C mux\n  always_comb begin\n    unique case (regc_mux)\n      REGC_ZERO: regfile_addr_rc_id = '0;\n      REGC_RD:   regfile_addr_rc_id = {regfile_fp_c, instr[REG_D_MSB:REG_D_LSB]};\n      REGC_S1:   regfile_addr_rc_id = {regfile_fp_c, instr[REG_S1_MSB:REG_S1_LSB]};\n      REGC_S4:   regfile_addr_rc_id = {regfile_fp_c, instr[REG_S4_MSB:REG_S4_LSB]};\n    endcase\n  end\n\n  //---------------------------------------------------------------------------\n  // destination registers regfile_fp_d=1 <=> REG_D is a FP-register\n  //---------------------------------------------------------------------------\n  assign regfile_waddr_id = {regfile_fp_d, instr[REG_D_MSB:REG_D_LSB]};\n\n  // Second Register Write Address Selection\n  // Used for prepost load/store and multiplier\n  assign regfile_alu_waddr_id = regfile_alu_waddr_mux_sel ? regfile_waddr_id : regfile_addr_ra_id;\n\n  // Forwarding control signals\n  assign reg_d_ex_is_reg_a_id  = (regfile_waddr_ex_o     == regfile_addr_ra_id) && (rega_used_dec == 1'b1) && (regfile_addr_ra_id != '0);\n  assign reg_d_ex_is_reg_b_id  = (regfile_waddr_ex_o     == regfile_addr_rb_id) && (regb_used_dec == 1'b1) && (regfile_addr_rb_id != '0);\n  assign reg_d_ex_is_reg_c_id  = (regfile_waddr_ex_o     == regfile_addr_rc_id) && (regc_used_dec == 1'b1) && (regfile_addr_rc_id != '0);\n  assign reg_d_wb_is_reg_a_id  = (regfile_waddr_wb_i     == regfile_addr_ra_id) && (rega_used_dec == 1'b1) && (regfile_addr_ra_id != '0);\n  assign reg_d_wb_is_reg_b_id  = (regfile_waddr_wb_i     == regfile_addr_rb_id) && (regb_used_dec == 1'b1) && (regfile_addr_rb_id != '0);\n  assign reg_d_wb_is_reg_c_id  = (regfile_waddr_wb_i     == regfile_addr_rc_id) && (regc_used_dec == 1'b1) && (regfile_addr_rc_id != '0);\n  assign reg_d_alu_is_reg_a_id = (regfile_alu_waddr_fw_i == regfile_addr_ra_id) && (rega_used_dec == 1'b1) && (regfile_addr_ra_id != '0);\n  assign reg_d_alu_is_reg_b_id = (regfi"}
{"text": "le_alu_waddr_fw_i == regfile_addr_rb_id) && (regb_used_dec == 1'b1) && (regfile_addr_rb_id != '0);\n  assign reg_d_alu_is_reg_c_id = (regfile_alu_waddr_fw_i == regfile_addr_rc_id) && (regc_used_dec == 1'b1) && (regfile_addr_rc_id != '0);\n\n\n  // kill instruction in the IF/ID stage by setting the instr_valid_id control\n  // signal to 0 for instructions that are done\n  assign clear_instr_valid_o = id_ready_o | halt_id | branch_taken_ex;\n\n  assign branch_taken_ex = branch_in_ex_o && branch_decision_i;\n\n\n  assign mult_en = mult_int_en | mult_dot_en;\n\n\n  //////////////////////////////////////////////////////////////////\n  //      _                         _____                    _    //\n  //     | |_   _ _ __ ___  _ __   |_   _|_ _ _ __ __ _  ___| |_  //\n  //  _  | | | | | '_ ` _ \\| '_ \\    | |/ _` | '__/ _` |/ _ \\ __| //\n  // | |_| | |_| | | | | | | |_) |   | | (_| | | | (_| |  __/ |_  //\n  //  \\___/ \\__,_|_| |_| |_| .__/    |_|\\__,_|_|  \\__, |\\___|\\__| //\n  //                       |_|                    |___/           //\n  //////////////////////////////////////////////////////////////////\n\n  always_comb begin : jump_target_mux\n    unique case (ctrl_transfer_target_mux_sel)\n      JT_JAL:  jump_target = pc_id_i + imm_uj_type;\n      JT_COND: jump_target = pc_id_i + imm_sb_type;\n\n      // JALR: Cannot forward RS1, since the path is too long\n      JT_JALR: jump_target = regfile_data_ra_id + imm_i_type;\n      default: jump_target = regfile_data_ra_id + imm_i_type;\n    endcase\n  end\n\n  assign jump_target_o = jump_target;\n\n\n  ////////////////////////////////////////////////////////\n  //   ___                                 _      _     //\n  //  / _ \\ _ __   ___ _ __ __ _ _ __   __| |    / \\    //\n  // | | | | '_ \\ / _ \\ '__/ _` | '_ \\ / _` |   / _ \\   //\n  // | |_| | |_) |  __/ | | (_| | | | | (_| |  / ___ \\  //\n  //  \\___/| .__/ \\___|_|  \\__,_|_| |_|\\__,_| /_/   \\_\\ //\n  //       |_|                                          //\n  ////////////////////////////////////////////////////////\n\n  // ALU_Op_a Mux\n  always_comb begin : alu_operand_a_mux\n    case (alu_op_a_mux_sel)\n      OP_A_REGA_OR_FWD: alu_operand_a = operand_a_fw_id;\n      OP_A_REGB_OR_FWD: alu_operand_a = operand_b_fw_id;\n      OP_A_REGC_OR_FWD: alu_operand_a = operand_c_fw_id;\n      OP_A_CURRPC:      alu_operand_a = pc_id_i;\n      OP_A_IMM:         alu_operand_a = imm_a;\n      default:          alu_operand_a = operand_a_fw_id;\n    endcase\n    ;  // case (alu_op_a_mux_sel)\n  end\n\n  always_comb begin : immediate_a_mux\n    unique case (imm_a_mux_sel)\n      IMMA_Z:    imm_a = imm_z_type;\n      IMMA_ZERO: imm_a = '0;\n    endcase\n  end\n\n  // Operand a forwarding mux\n  always_comb begin : operand_a_fw_mux\n    case (operand_a_fw_mux_sel)\n      SEL_FW_EX:   operand_a_fw_id = regfile_alu_wdata_fw_i;\n      SEL_FW_WB:   operand_a_fw_id = regfile_wdata_wb_i;\n      SEL_REGFILE: operand_a_fw_id = regfile_data_ra_id;\n      default:     operand_a_fw_id = regfile_data_ra_id;\n    endcase\n    ;  // case (operand_a_fw_mux_sel)\n  end\n\n  //////////////////////////////////////////////////////\n  //   ___                                 _   ____   //\n  //  / _ \\ _ __   ___ _ __ __ _ _ __   __| | | __ )  //\n  // | | | | '_ \\ / _ \\ '__/ _` | '_ \\ / _` | |  _ \\  //\n  // | |_| | |_) |  __/ | | (_| | | | | (_| | | |_) | //\n  //  \\___/| .__/ \\___|_|  \\__,_|_| |_|\\__,_| |____/  //\n  //       |_|                                        //\n  //////////////////////////////////////////////////////\n\n  // Immediate Mux for operand B\n  always_comb begin : immediate_b_mux\n    unique case (imm_b_mux_sel)\n      IMMB_I:      imm_b = imm_i_type;\n      IMMB_S:      imm_b = imm_s_type;\n      IMMB_U:      imm_b = imm_u_type;\n      IMMB_PCINCR: imm_b = is_compressed_i ? 32'h2 : 32'h4;\n      IMMB_S2:     imm_b = imm_s2_type;\n      IMMB_BI:     imm_b = imm_bi_type;\n      IMMB_S3:     imm_b = imm_s3_type;\n      IMMB_VS:     imm_b = imm_vs_type;\n      IMMB_VU:     imm_b = imm_vu_type;\n      IMMB_SHUF:   imm_b = imm_shuffle_type;\n      IMMB_CLIP:   imm_b = {1'b0, imm_clip_type[31:1]};\n      default:     imm_b = imm_i_type;\n    endcase\n  end\n\n  // ALU_Op_b Mux\n  always_comb begin : alu_operand_b_mux\n    case (alu_op_b_mux_sel)\n      OP_B_REGA_OR_FWD: operand_b = operand_a_fw_id;\n      OP_B_REGB_OR_FWD: operand_b = operand_b_fw_id;\n      OP_B_REGC_OR_FWD: operand_b = operand_c_fw_id;\n      OP_B_IMM:         operand_b = imm_b;\n      OP_B_BMASK:       operand_b = $unsigned(operand_b_fw_id[4:0]);\n      default:          operand_b = operand_b_fw_id;\n    endcase  // case (alu_op_b_mux_sel)\n  end\n\n\n  // scalar replication for operand B and shuffle type\n  always_comb begin\n    if (alu_vec_mode == VEC_MODE8) begin\n      operand_b_vec    = {4{operand_b[7:0]}};\n      imm_shuffle_type = imm_shuffleb_type;\n    end else begin\n      operand_b_vec    = {2{operand_b[15:0]}};\n      imm_shuffle_type = imm_shuffleh_type;\n    end\n  end\n\n  // choose normal or scalar replicated version of operand b\n  assign alu_operand_b = (scalar_replication == 1'b1) ? operand_b_vec : operand_b;\n\n\n  // Operand b forwarding mux\n  always_comb begin : operand_b_fw_mux\n    case (operand_b_fw_mux_sel)\n      SEL_FW_EX:   operand_b_fw_id = regfile_alu_wdata_fw_i;\n      SEL_FW_WB:   operand_b_fw_id = regfile_wdata_wb_i;\n      SEL_REGFILE: operand_b_fw_id = regfile_data_rb_id;\n      default:     operand_b_fw_id = regfile_data_rb_id;\n    endcase\n    ;  // case (operand_b_fw_mux_sel)\n  end\n\n\n  //////////////////////////////////////////////////////\n  //   ___                                 _    ____  //\n  //  / _ \\ _ __   ___ _ __ __ _ _ __   __| |  / ___| //\n  // | | | | '_ \\ / _ \\ '__/ _` | '_ \\ / _` | | |     //\n  // | |_| | |_) |  __/ | | (_| | | | | (_| | | |___  //\n  //  \\___/| .__/ \\___|_|  \\__,_|_| |_|\\__,_|  \\____| //\n  //       |_|                                        //\n  //////////////////////////////////////////////////////\n\n  // ALU OP C Mux\n  always_comb begin : alu_operand_c_mux\n    case (alu_op_c_mux_sel)\n      OP_C_REGC_OR_FWD: operand_c = operand_c_fw_id;\n      OP_C_REGB_OR_FWD: operand_c = operand_b_fw_id;\n      OP_C_JT:          operand_c = jump_target;\n      default:          operand_c = operand_c_fw_id;\n    endcase  // case (alu_op_c_mux_sel)\n  end\n\n\n  // scalar replication for operand C and shuffle type\n  always_comb begin\n    if (alu_vec_mode == VEC_MODE8) begin\n      operand_c_vec = {4{operand_c[7:0]}};\n    end else begin\n      operand_c_vec = {2{operand_c[15:0]}};\n    end\n  end\n\n  // choose normal or scalar replicated version of operand b\n  assign alu_operand_c = (scalar_replication_c == 1'b1) ? operand_c_vec : operand_c;\n\n\n  // Operand c forwarding mux\n  always_comb begin : operand_c_fw_mux\n    case (operand_c_fw_mux_sel)\n      SEL_FW_EX:   operand_c_fw_id = regfile_alu_wdata_fw_i;\n      SEL_FW_WB:   operand_c_fw_id = regfile_wdata_wb_i;\n      SEL_REGFILE: operand_c_fw_id = regfile_data_rc_id;\n      default:     operand_c_fw_id = regfile_data_rc_id;\n    endcase\n    ;  // case (operand_c_fw_mux_sel)\n  end\n\n\n  ///////////////////////////////////////////////////////////////////////////\n  //  ___                              _ _       _              ___ ____   //\n  // |_ _|_ __ ___  _ __ ___   ___  __| (_) __ _| |_ ___  ___  |_ _|  _ \\  //\n  //  | || '_ ` _ \\| '_ ` _ \\ / _ \\/ _` | |/ _` | __/ _ \\/ __|  | || | | | //\n  //  | || | | | | | | | | | |  __/ (_| | | (_| | ||  __/\\__ \\  | || |_| | //\n  // |___|_| |_| |_|_| |_| |_|\\___|\\__,_|_|\\__,_|\\__\\___||___/ |___|____/  //\n  //                                                                       //\n  ///////////////////////////////////////////////////////////////////////////\n\n  always_comb begin\n    unique case (bmask_a_mux)\n      BMASK_A_ZERO: bmask_a_id_imm = '0;\n      BMASK_A_S3:   bmask_a_id_imm = imm_s3_type[4:0];\n    endcase\n  end\n  always_comb begin\n    unique case (bmask_b_mux)\n      BMASK_B_ZERO: bmask_b_id_imm = '0;\n      BMASK_B_ONE:  bmask_b_id_imm = 5'd1;\n      BMASK_B_S2:   bmask_b_id_imm = imm_s2_type[4:0];\n      BMASK_B_S3:   bmask_b_id_imm = imm_s3_type[4:0];\n    endcase\n  end\n\n  always_comb begin\n    unique case (alu_bmask_a_mux_sel)\n      BMASK_A_IMM: bmask_a_id = bmask_a_id_imm;\n      BMASK_A_REG: bmask_a_id = operand_b_fw_id[9:5];\n    endcase\n  end\n  always_comb begin\n    unique case (alu_bmask_b_mux_sel)\n      BMASK_B_IMM: bmask_b_id = bmask_b_id_imm;\n      BMASK_B_REG: bmask_b_id = operand_b_fw_id[4:0];\n    endcase\n  end\n\n  generate\n    if (!COREV_PULP) begin\n      assign imm_vec_ext_id = imm_vu_type[1:0];\n    end else begin\n      assign imm_vec_ext_id = (alu_vec) ? imm_vu_type[1:0] : 2'b0;\n    end\n  endgenerate\n\n  always_comb begin\n    unique case (mult_imm_mux)\n      MIMM_ZERO: mult_imm_id = '0;\n      MIMM_S3:   mult_imm_id = imm_s3_type[4:0];\n    endcase\n  end\n\n  /////////////////////////////\n  // APU operand assignment  //\n  /////////////////////////////\n  // read regs\n  generate\n    if (APU == 1) begin : gen_apu\n\n      if (APU_NARGS_CPU >= 1) assign apu_operands[0] = alu_operand_a;\n      if (APU_NARGS_CPU >= 2) assign apu_operands[1] = alu_operand_b;\n      if (APU_NARGS_CPU >= 3) assign apu_operands[2] = alu_operand_c;\n\n      // write reg\n      assign apu_waddr = regfile_alu_waddr_id;\n\n      // flags\n      assign apu_flags = (FPU == 1) ? {fpu_int_fmt, fpu_src_fmt, fpu_dst_fmt, fp_rnd_mode} : '0;\n\n      // dependency checks\n      always_comb begin\n        unique case (alu_op_a_mux_sel)\n          OP_A_CURRPC: begin\n            if (ctrl_transfer_target_mux_sel == JT_JALR) begin\n              apu_read_regs[0]       = regfile_addr_ra_id;\n              apu_read_regs_valid[0] = 1'b1;\n            end else begin\n              apu_read_regs[0]       = regfile_addr_ra_id;\n              apu_read_regs_valid[0] = 1'b0;\n            end\n          end  // OP_A_CURRPC:\n          OP_A_REGA_OR_FWD: begin\n            apu_read_regs[0]       = regfile_addr_ra_id;\n            apu_read_regs_valid[0] = 1'b1;\n          end  // OP_A_REGA_OR_FWD:\n          OP_A_REGB_OR_FWD, OP_A_REGC_OR_FWD: begin\n            apu_read_regs[0]       = regfile_addr_rb_id;\n            apu_read_regs_valid[0] = 1'b1;\n          end\n          default: begin\n            apu_read_regs[0]       = regfile_addr_ra_id;\n            apu_read_regs_valid[0] = 1'b0;\n          end\n        endcase\n      end\n\n      always_comb begin\n        unique case (alu_op_b_mux_sel)\n          OP_B_REGA_OR_FWD: begin\n            apu_read_regs[1]       = regfile_addr_ra_id;\n            apu_read_regs_valid[1] = 1'b1;\n          end\n          OP_B_REGB_OR_FWD, OP_B_BMASK: begin\n            apu_read_regs[1]       = regfile_addr_rb_id;\n            apu_read_regs_valid[1] = 1'b1;\n          end\n          OP_B_REGC_OR_FWD: begin\n            apu_read_regs[1]       = regfile_addr_rc_id;\n            apu_read_regs_valid[1] = 1'b1;\n          end\n          OP_B_IMM: begin\n            if (alu_bmask_b_mux_sel == BMASK_B_REG) begin\n              apu_read_regs[1]       = regfile_addr_rb_id;\n              apu_read_regs_valid[1] = 1'b1;\n            end else begin\n              apu_read_regs[1]       = regfile_addr_rb_id;\n              apu_read_regs_valid[1] = 1'b0;\n            end\n          end\n          default: begin\n            apu_read_regs[1]       = regfile_addr_rb_id;\n            apu_read_regs_valid[1] = 1'b0;\n          end\n        endcase\n      end\n\n      always_comb begin\n        unique case (alu_op_c_mux_sel)\n          OP_C_REGB_OR_FWD: begin\n            apu_read_regs[2]       = regfile_addr_rb_id;\n            apu_read_regs_valid[2] = 1'b1;\n          end\n          OP_C_REGC_OR_FWD: begin\n            if ((alu_op_a_mux_sel != OP_A_REGC_OR_FWD) && (ctrl_transfer_target_mux_sel != JT_JALR) &&\n                !((alu_op_b_mux_sel == OP_B_IMM) && (alu_bmask_b_mux_sel == BMASK_B_REG)) &&\n                !(alu_op_b_mux_sel == OP_B_BMASK)) begin\n              apu_read_regs[2]       = regfile_addr_rc_id;\n              apu_read_regs_valid[2] = 1'b1;\n            end else begin\n              apu_read_regs[2]       = regfile_addr_rc_id;\n              apu_read_regs_valid[2] = 1'b0;\n            end\n          end\n          default: begin\n            apu_read_regs[2]       = regfile_addr_rc_id;\n            apu_read_regs_valid[2] = 1'b0;\n          end\n        endcase\n      end\n\n      assign apu_write_regs[0]       = regfile_alu_waddr_id;\n      assign apu_write_regs_valid[0] = regfile_alu_we_id;\n\n      assign apu_write_regs[1]       = regfile_waddr_id;\n      assign apu_write_regs_valid[1] = regfile_we_id;\n\n      assign apu_read_regs_o         = apu_read_regs;\n      assign apu_read_regs_valid_o   = apu_read_regs_valid;\n\n      assign apu_write_regs_o        = apu_write_regs;\n      assign apu_write_regs_valid_o  = apu_write_regs_valid;\n    end else begin : gen_no_apu\n      for (genvar i = 0; i < APU_NARGS_CPU; i++) begin : gen_apu_tie_off\n        assign apu_operands[i] = '0;\n      end\n\n      assign apu_read_regs          = '0;\n      assign apu_read_regs_valid    = '0;\n      assign apu_write_regs         = '0;\n      assign apu_write_regs_valid   = '0;\n      assign apu_waddr              = '0;\n      assign apu_flags              = '0;\n      assign apu_write_regs_o       = '0;\n      assign apu_read_regs_o        = '0;\n      assign apu_write_regs_valid_o = '0;\n      assign apu_read_regs_valid_o  = '0;\n    end\n  endgenerate\n\n  assign apu_perf_dep_o = apu_stall;\n  // stall when we access the CSR after a multicycle APU instruction\n  assign csr_apu_stall  = (csr_access & (apu_en_ex_o & (apu_lat_ex_o[1] == 1'b1) | apu_busy_i));\n\n  /////////////////////////////////////////////////////////\n  //  ____  _____ ____ ___ ____ _____ _____ ____  ____   //\n  // |  _ \\| ____/ ___|_ _/ ___|_   _| ____|  _ \\/ ___|  //\n  // | |_) |  _|| |  _ | |\\___ \\ | | |  _| | |_) \\___ \\  //\n  // |  _ <| |__| |_| || | ___) || | | |___|  _ < ___) | //\n  // |_| \\_\\_____\\____|___|____/ |_| |_____|_| \\_\\____/  //\n  //                                                     //\n  /////////////////////////////////////////////////////////\n\n  cv32e40p_register_file #(\n      .ADDR_WIDTH(6),\n      .DATA_WIDTH(32),\n      .FPU       (FPU),\n      .ZFINX     (ZFINX)\n  ) register_file_i (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      .scan_cg_en_i(scan_cg_en_i),\n\n      // Read port a\n      .raddr_a_i(regfile_addr_ra_id),\n      .rdata_a_o(regfile_data_ra_id),\n\n      // Read port b\n      .raddr_b_i(regfile_addr_rb_id),\n      .rdata_b_o(regfile_data_rb_id),\n\n      // Read port c\n      .raddr_c_i(regfile_addr_rc_id),\n      .rdata_c_o(regfile_data_rc_id),\n\n      // Write port a\n      .waddr_a_i(regfile_waddr_wb_i),\n      .wdata_a_i(regfile_wdata_wb_i),\n      .we_a_i   (regfile_we_wb_power_i),\n\n      // Write port b\n      .waddr_b_i(regfile_alu_waddr_fw_i),\n      .wdata_b_i(regfile_alu_wdata_fw_i),\n      .we_b_i   (regfile_alu_we_fw_power_i)\n  );\n\n\n  ///////////////////////////////////////////////\n  //  ____  _____ ____ ___  ____  _____ ____   //\n  // |  _ \\| ____/ ___/ _ \\|  _ \\| ____|  _ \\  //\n  // | | | |  _|| |  | | | | | | |  _| | |_) | //\n  // | |_| | |__| |__| |_| | |_| | |___|  _ <  //\n  // |____/|_____\\____\\___/|____/|_____|_| \\_\\ //\n  //                                           //\n  ///////////////////////////////////////////////\n\n  cv32e40p_decoder #(\n      .COREV_PULP      (COREV_PULP),\n      .COREV_CLUSTER   (COREV_CLUSTER),\n      .A_EXTENSION     (A_EXTENSION),\n      .FPU             (FPU),\n      .FPU_ADDMUL_LAT  (FPU_ADDMUL_LAT),\n      .FPU_OTHERS_LAT  (FPU_OTHERS_LAT),\n      .ZFINX           (ZFINX),\n      .PULP_SECURE     (PULP_SECURE),\n      .USE_PMP         (USE_PMP),\n      .APU_WOP_CPU     (APU_WOP_CPU),\n      .DEBUG_TRIGGER_EN(DEBUG_TRIGGER_EN)\n  ) decoder_i (\n      // controller related signals\n      .deassert_we_i(deassert_we),\n\n      .illegal_insn_o(illegal_insn_dec),\n      .ebrk_insn_o   (ebrk_insn_dec),\n\n      .mret_insn_o(mret_insn_dec),\n      .uret_insn_o(uret_insn_dec),\n      .dret_insn_o(dret_insn_dec),\n\n      .mret_dec_o(mret_dec),\n      .uret_dec_o(uret_dec),\n      .dret_dec_o(dret_dec),\n\n      .ecall_insn_o(ecall_insn_dec),\n      .wfi_o       (wfi_insn_dec),\n\n      .fencei_insn_o(fencei_insn_dec),\n\n      .rega_used_o(rega_used_dec),\n      .regb_used_o(regb_used_dec),\n      .regc_used_o(regc_used_dec),\n\n      .reg_fp_a_o(regfile_fp_a),\n      .reg_fp_b_o(regfile_fp_b),\n      .reg_fp_c_o(regfile_fp_c),\n      .reg_fp_d_o(regfile_fp_d),\n\n      .bmask_a_mux_o        (bmask_a_mux),\n      .bmask_b_mux_o        (bmask_b_mux),\n      .alu_bmask_a_mux_sel_o(alu_bmask_a_mux_sel),\n      .alu_bmask_b_mux_sel_o(alu_bmask_b_mux_sel),\n\n      // from IF/ID pipeline\n      .instr_rdata_i   (instr),\n      .illegal_c_insn_i(illegal_c_insn_i),\n\n      // ALU signals\n      .alu_en_o              (alu_en),\n      .alu_operator_o        (alu_operator),\n      .alu_op_a_mux_sel_o    (alu_op_a_mux_sel),\n      .alu_op_b_mux_sel_o    (alu_op_b_mux_sel),\n      .alu_op_c_mux_sel_o    (alu_op_c_mux_sel),\n      .alu_vec_o             (alu_vec),\n      .alu_vec_mode_o        (alu_vec_mode),\n      .scalar_replication_o  (scalar_replication),\n      .scalar_replication_c_o(scalar_replication_c),\n      .imm_a_mux_sel_o       (imm_a_mux_sel),\n      .imm_b_mux_sel_o       (imm_b_mux_sel),\n      .regc_mux_o            (regc_mux),\n      .is_clpx_o             (is_clpx),\n      .is_subrot_o           (is_subrot),\n\n      // MUL signals\n      .mult_operator_o   (mult_operator),\n      .mult_int_en_o     (mult_int_en),\n      .mult_sel_subword_o(mult_sel_subword),\n      .mult_signed_mode_o(mult_signed_mode),\n      .mult_imm_mux_o    (mult_imm_mux),\n      .mult_dot_en_o     (mult_dot_en),\n      .mult_dot_signed_o (mult_dot_signed),\n\n      // FPU / APU signals\n      .fs_off_i     (fs_off_i),\n      .frm_i        (frm_i),\n      .fpu_src_fmt_o(fpu_src_fmt),\n      .fpu_dst_fmt_o(fpu_dst_fmt),\n      .fpu_int_fmt_o(fpu_int_fmt),\n      .apu_en_o     (apu_en),\n      .apu_op_o     (apu_op),\n      .apu_lat_o    (apu_lat),\n      .fp_rnd_mode_o(fp_rnd_mode),\n\n      // Register file control signals\n      .regfile_mem_we_o       (regfile_we_id),\n      .regfile_alu_we_o       (regfile_alu_we_id),\n      .regfile_alu_we_dec_o   (regfile_alu_we_dec_id),\n      .regfile_alu_waddr_sel_o(regfile_alu_waddr_mux_sel),\n\n      // CSR control signals\n      .csr_access_o      (csr_access),\n      .csr_status_o      (csr_status),\n      .csr_op_o          (csr_op),\n      .current_priv_lvl_i(current_priv_lvl_i),\n\n      // Data bus interface\n      .data_req_o           (data_req_id),\n      .data_we_o            (data_we_id),\n      .prepost_useincr_o    (prepost_useincr),\n      .data_type_o          (data_type_id),\n      .data_sign_extension_o(data_sign_ext_id),\n      .data_reg_offset_o    (data_reg_offset_id),\n      .data_load_event_o    (data_load_event_id),\n\n      // Atomic memory access\n      .atop_o(atop_id),\n\n      // hwloop signals\n      .hwlp_we_o            (hwlp_we),\n      .hwlp_target_mux_sel_o(hwlp_target_mux_sel),\n      .hwlp_start_mux_sel_o (hwlp_start_mux_sel),\n      .hwlp_cnt_mux_sel_o   (hwlp_cnt_mux_sel),\n\n      // debug mode\n      .debug_mode_i        (debug_mode_o),\n      .debug_wfi_no_sleep_i(debug_wfi_no_sleep),\n\n      // jump/branches\n      .ctrl_transfer_insn_in_dec_o   (ctrl_transfer_insn_in_dec_o),\n      .ctrl_transfer_insn_in_id_o    (ctrl_transfer_insn_in_id),\n      .ctrl_transfer_target_mux_sel_o(ctrl_transfer_target_mux_sel),\n\n      // HPM related control signals\n      .mcounteren_i(mcounteren_i)\n\n  );\n\n  ////////////////////////////////////////////////////////////////////\n  //    ____ ___  _   _ _____ ____   ___  _     _     _____ ____    //\n  //   / ___/ _ \\| \\ | |_   _|  _ \\ / _ \\| |   | |   | ____|  _ \\   //\n  //  | |  | | | |  \\| | | | | |_) | | | | |   | |   |  _| | |_) |  //\n  //  | |__| |_| | |\\  | | | |  _ <| |_| | |___| |___| |___|  _ <   //\n  //   \\____\\___/|_| \\_| |_| |_| \\_\\\\___/|_____|_____|_____|_| \\_\\  //\n  //                                                                //\n  ////////////////////////////////////////////////////////////////////\n\n  cv"}
{"text": "32e40p_controller #(\n      .COREV_CLUSTER(COREV_CLUSTER),\n      .COREV_PULP   (COREV_PULP),\n      .FPU          (FPU)\n  ) controller_i (\n      .clk          (clk),  // Gated clock\n      .clk_ungated_i(clk_ungated_i),  // Ungated clock\n      .rst_n        (rst_n),\n\n      .fetch_enable_i   (fetch_enable_i),\n      .ctrl_busy_o      (ctrl_busy_o),\n      .is_decoding_o    (is_decoding_o),\n      .is_fetch_failed_i(is_fetch_failed_i),\n\n      // decoder related signals\n      .deassert_we_o(deassert_we),\n\n      .illegal_insn_i(illegal_insn_dec),\n      .ecall_insn_i  (ecall_insn_dec),\n      .mret_insn_i   (mret_insn_dec),\n      .uret_insn_i   (uret_insn_dec),\n\n      .dret_insn_i(dret_insn_dec),\n\n      .mret_dec_i(mret_dec),\n      .uret_dec_i(uret_dec),\n      .dret_dec_i(dret_dec),\n\n\n      .wfi_i        (wfi_insn_dec),\n      .ebrk_insn_i  (ebrk_insn_dec),\n      .fencei_insn_i(fencei_insn_dec),\n      .csr_status_i (csr_status),\n\n      .hwlp_mask_o(hwlp_mask),\n\n      // from IF/ID pipeline\n      .instr_valid_i(instr_valid_i),\n\n      // from prefetcher\n      .instr_req_o(instr_req_o),\n\n      // to prefetcher\n      .pc_set_o       (pc_set_o),\n      .pc_mux_o       (pc_mux_o),\n      .exc_pc_mux_o   (exc_pc_mux_o),\n      .exc_cause_o    (exc_cause_o),\n      .trap_addr_mux_o(trap_addr_mux_o),\n\n      // HWLoop signls\n      .pc_id_i(pc_id_i),\n\n      .hwlp_start_addr_i(hwlp_start_o),\n      .hwlp_end_addr_i  (hwlp_end_o),\n      .hwlp_counter_i   (hwlp_cnt_o),\n      .hwlp_dec_cnt_o   (hwlp_dec_cnt),\n\n      .hwlp_jump_o     (hwlp_jump_o),\n      .hwlp_targ_addr_o(hwlp_target_o),\n\n      // LSU\n      .data_req_ex_i    (data_req_ex_o),\n      .data_we_ex_i     (data_we_ex_o),\n      .data_misaligned_i(data_misaligned_i),\n      .data_load_event_i(data_load_event_id),\n      .data_err_i       (data_err_i),\n      .data_err_ack_o   (data_err_ack_o),\n\n      // ALU\n      .mult_multicycle_i(mult_multicycle_i),\n\n      // APU\n      .apu_en_i               (apu_en),\n      .apu_read_dep_i         (apu_read_dep_i),\n      .apu_read_dep_for_jalr_i(apu_read_dep_for_jalr_i),\n      .apu_write_dep_i        (apu_write_dep_i),\n\n      .apu_stall_o(apu_stall),\n\n      // jump/branch control\n      .branch_taken_ex_i          (branch_taken_ex),\n      .ctrl_transfer_insn_in_id_i (ctrl_transfer_insn_in_id),\n      .ctrl_transfer_insn_in_dec_i(ctrl_transfer_insn_in_dec_o),\n\n      // Interrupt signals\n      .irq_wu_ctrl_i     (irq_wu_ctrl),\n      .irq_req_ctrl_i    (irq_req_ctrl),\n      .irq_sec_ctrl_i    (irq_sec_ctrl),\n      .irq_id_ctrl_i     (irq_id_ctrl),\n      .current_priv_lvl_i(current_priv_lvl_i),\n      .irq_ack_o         (irq_ack_o),\n      .irq_id_o          (irq_id_o),\n\n      // Debug Signal\n      .debug_mode_o          (debug_mode_o),\n      .debug_cause_o         (debug_cause_o),\n      .debug_csr_save_o      (debug_csr_save_o),\n      .debug_req_i           (debug_req_i),\n      .debug_single_step_i   (debug_single_step_i),\n      .debug_ebreakm_i       (debug_ebreakm_i),\n      .debug_ebreaku_i       (debug_ebreaku_i),\n      .trigger_match_i       (trigger_match_i),\n      .debug_p_elw_no_sleep_o(debug_p_elw_no_sleep_o),\n      .debug_wfi_no_sleep_o  (debug_wfi_no_sleep),\n      .debug_havereset_o     (debug_havereset_o),\n      .debug_running_o       (debug_running_o),\n      .debug_halted_o        (debug_halted_o),\n\n      // Wakeup Signal\n      .wake_from_sleep_o(wake_from_sleep_o),\n\n      // CSR Controller Signals\n      .csr_save_cause_o     (csr_save_cause_o),\n      .csr_cause_o          (csr_cause_o),\n      .csr_save_if_o        (csr_save_if_o),\n      .csr_save_id_o        (csr_save_id_o),\n      .csr_save_ex_o        (csr_save_ex_o),\n      .csr_restore_mret_id_o(csr_restore_mret_id_o),\n      .csr_restore_uret_id_o(csr_restore_uret_id_o),\n\n      .csr_restore_dret_id_o(csr_restore_dret_id_o),\n\n      .csr_irq_sec_o(csr_irq_sec_o),\n\n      // Write targets from ID\n      .regfile_we_id_i       (regfile_alu_we_dec_id),\n      .regfile_alu_waddr_id_i(regfile_alu_waddr_id),\n\n      // Forwarding signals from regfile\n      .regfile_we_ex_i   (regfile_we_ex_o),\n      .regfile_waddr_ex_i(regfile_waddr_ex_o),\n      .regfile_we_wb_i   (regfile_we_wb_i),\n\n      // regfile port 2\n      .regfile_alu_we_fw_i(regfile_alu_we_fw_i),\n\n      // Forwarding detection signals\n      .reg_d_ex_is_reg_a_i (reg_d_ex_is_reg_a_id),\n      .reg_d_ex_is_reg_b_i (reg_d_ex_is_reg_b_id),\n      .reg_d_ex_is_reg_c_i (reg_d_ex_is_reg_c_id),\n      .reg_d_wb_is_reg_a_i (reg_d_wb_is_reg_a_id),\n      .reg_d_wb_is_reg_b_i (reg_d_wb_is_reg_b_id),\n      .reg_d_wb_is_reg_c_i (reg_d_wb_is_reg_c_id),\n      .reg_d_alu_is_reg_a_i(reg_d_alu_is_reg_a_id),\n      .reg_d_alu_is_reg_b_i(reg_d_alu_is_reg_b_id),\n      .reg_d_alu_is_reg_c_i(reg_d_alu_is_reg_c_id),\n\n      // Forwarding signals\n      .operand_a_fw_mux_sel_o(operand_a_fw_mux_sel),\n      .operand_b_fw_mux_sel_o(operand_b_fw_mux_sel),\n      .operand_c_fw_mux_sel_o(operand_c_fw_mux_sel),\n\n      // Stall signals\n      .halt_if_o(halt_if),\n      .halt_id_o(halt_id),\n\n      .misaligned_stall_o(misaligned_stall),\n      .jr_stall_o        (jr_stall),\n      .load_stall_o      (load_stall),\n\n      .id_ready_i(id_ready_o),\n      .id_valid_i(id_valid_o),\n\n      .ex_valid_i(ex_valid_i),\n\n      .wb_ready_i(wb_ready_i),\n\n      // Performance Counters\n      .perf_pipeline_stall_o(perf_pipeline_stall)\n  );\n\n\n  ////////////////////////////////////////////////////////////////////////\n  //  _____      _       _____             _             _ _            //\n  // |_   _|    | |     /  __ \\           | |           | | |           //\n  //   | | _ __ | |_    | /  \\/ ___  _ __ | |_ _ __ ___ | | | ___ _ __  //\n  //   | || '_ \\| __|   | |    / _ \\| '_ \\| __| '__/ _ \\| | |/ _ \\ '__| //\n  //  _| || | | | |_ _  | \\__/\\ (_) | | | | |_| | | (_) | | |  __/ |    //\n  //  \\___/_| |_|\\__(_)  \\____/\\___/|_| |_|\\__|_|  \\___/|_|_|\\___|_|    //\n  //                                                                    //\n  ////////////////////////////////////////////////////////////////////////\n\n  cv32e40p_int_controller #(\n      .PULP_SECURE(PULP_SECURE)\n  ) int_controller_i (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      // External interrupt lines\n      .irq_i    (irq_i),\n      .irq_sec_i(irq_sec_i),\n\n      // To cv32e40p_controller\n      .irq_req_ctrl_o(irq_req_ctrl),\n      .irq_sec_ctrl_o(irq_sec_ctrl),\n      .irq_id_ctrl_o (irq_id_ctrl),\n      .irq_wu_ctrl_o (irq_wu_ctrl),\n\n      // To/from with cv32e40p_cs_registers\n      .mie_bypass_i      (mie_bypass_i),\n      .mip_o             (mip_o),\n      .m_ie_i            (m_irq_enable_i),\n      .u_ie_i            (u_irq_enable_i),\n      .current_priv_lvl_i(current_priv_lvl_i)\n  );\n\n  generate\n    if (COREV_PULP) begin : gen_hwloop_regs\n\n      ///////////////////////////////////////////////\n      //  _   ___        ___     ___   ___  ____   //\n      // | | | \\ \\      / / |   / _ \\ / _ \\|  _ \\  //\n      // | |_| |\\ \\ /\\ / /| |  | | | | | | | |_) | //\n      // |  _  | \\ V  V / | |__| |_| | |_| |  __/  //\n      // |_| |_|  \\_/\\_/  |_____\\___/ \\___/|_|     //\n      //                                           //\n      ///////////////////////////////////////////////\n\n\n      cv32e40p_hwloop_regs #(\n          .N_REGS(N_HWLP)\n      ) hwloop_regs_i (\n          .clk  (clk),\n          .rst_n(rst_n),\n\n          // from ID\n          .hwlp_start_data_i(hwlp_start),\n          .hwlp_end_data_i  (hwlp_end),\n          .hwlp_cnt_data_i  (hwlp_cnt),\n          .hwlp_we_i        (hwlp_we_masked),\n          .hwlp_regid_i     (hwlp_regid),\n\n          // from controller\n          .valid_i(hwlp_valid),\n\n          // to hwloop controller\n          .hwlp_start_addr_o(hwlp_start_o),\n          .hwlp_end_addr_o  (hwlp_end_o),\n          .hwlp_counter_o   (hwlp_cnt_o),\n\n          // from hwloop controller\n          .hwlp_dec_cnt_i(hwlp_dec_cnt)\n      );\n\n      assign hwlp_valid = instr_valid_i & clear_instr_valid_o;\n\n      // hwloop register id\n      assign hwlp_regid = instr[7];  // rd contains hwloop register id\n\n      // hwloop target mux\n      always_comb begin\n        case (hwlp_target_mux_sel)\n          2'b00:   hwlp_end = pc_id_i + {imm_iz_type[29:0], 2'b0};\n          2'b01:   hwlp_end = pc_id_i + {imm_z_type[29:0], 2'b0};\n          2'b10:   hwlp_end = operand_a_fw_id;\n          default: hwlp_end = operand_a_fw_id;\n        endcase\n      end\n\n      // hwloop start mux\n      always_comb begin\n        case (hwlp_start_mux_sel)\n          2'b00:   hwlp_start = hwlp_end;  // for PC + I imm\n          2'b01:   hwlp_start = pc_id_i + 4;  // for next PC\n          2'b10:   hwlp_start = operand_a_fw_id;\n          default: hwlp_start = operand_a_fw_id;\n        endcase\n      end\n\n      // hwloop cnt mux\n      always_comb begin : hwlp_cnt_mux\n        case (hwlp_cnt_mux_sel)\n          1'b0: hwlp_cnt = imm_iz_type;\n          1'b1: hwlp_cnt = operand_a_fw_id;\n        endcase\n        ;\n      end\n\n      /*\n        when hwlp_mask is 1, the controller is about to take an interrupt\n        the xEPC is going to have the hwloop instruction PC, therefore, do not update the\n        hwloop registers to make clear that the instruction hasn't been executed.\n        Although it may not be a HW bugs causing uninteded behaviours,\n        it helps verifications processes when checking the hwloop regs\n      */\n      assign hwlp_we_masked = hwlp_we & ~{3{hwlp_mask}} & {3{id_ready_o}};\n\n    end else begin : gen_no_hwloop_regs\n\n      assign hwlp_start_o   = 'b0;\n      assign hwlp_end_o     = 'b0;\n      assign hwlp_cnt_o     = 'b0;\n      assign hwlp_valid     = 'b0;\n      assign hwlp_we_masked = 'b0;\n      assign hwlp_start     = 'b0;\n      assign hwlp_end       = 'b0;\n      assign hwlp_cnt       = 'b0;\n      assign hwlp_regid     = 'b0;\n\n    end\n  endgenerate\n\n\n  /////////////////////////////////////////////////////////////////////////////////\n  //   ___ ____        _______  __  ____ ___ ____  _____ _     ___ _   _ _____   //\n  //  |_ _|  _ \\      | ____\\ \\/ / |  _ \\_ _|  _ \\| ____| |   |_ _| \\ | | ____|  //\n  //   | || | | |_____|  _|  \\  /  | |_) | || |_) |  _| | |    | ||  \\| |  _|    //\n  //   | || |_| |_____| |___ /  \\  |  __/| ||  __/| |___| |___ | || |\\  | |___   //\n  //  |___|____/      |_____/_/\\_\\ |_|  |___|_|   |_____|_____|___|_| \\_|_____|  //\n  //                                                                             //\n  /////////////////////////////////////////////////////////////////////////////////\n\n  always_ff @(posedge clk, negedge rst_n) begin : ID_EX_PIPE_REGISTERS\n    if (rst_n == 1'b0) begin\n      alu_en_ex_o            <= '0;\n      alu_operator_ex_o      <= ALU_SLTU;\n      alu_operand_a_ex_o     <= '0;\n      alu_operand_b_ex_o     <= '0;\n      alu_operand_c_ex_o     <= '0;\n      bmask_a_ex_o           <= '0;\n      bmask_b_ex_o           <= '0;\n      imm_vec_ext_ex_o       <= '0;\n      alu_vec_mode_ex_o      <= '0;\n      alu_clpx_shift_ex_o    <= 2'b0;\n      alu_is_clpx_ex_o       <= 1'b0;\n      alu_is_subrot_ex_o     <= 1'b0;\n\n      mult_operator_ex_o     <= MUL_MAC32;\n      mult_operand_a_ex_o    <= '0;\n      mult_operand_b_ex_o    <= '0;\n      mult_operand_c_ex_o    <= '0;\n      mult_en_ex_o           <= 1'b0;\n      mult_sel_subword_ex_o  <= 1'b0;\n      mult_signed_mode_ex_o  <= 2'b00;\n      mult_imm_ex_o          <= '0;\n\n      mult_dot_op_a_ex_o     <= '0;\n      mult_dot_op_b_ex_o     <= '0;\n      mult_dot_op_c_ex_o     <= '0;\n      mult_dot_signed_ex_o   <= '0;\n      mult_is_clpx_ex_o      <= 1'b0;\n      mult_clpx_shift_ex_o   <= 2'b0;\n      mult_clpx_img_ex_o     <= 1'b0;\n\n      apu_en_ex_o            <= '0;\n      apu_op_ex_o            <= '0;\n      apu_lat_ex_o           <= '0;\n      apu_operands_ex_o[0]   <= '0;\n      apu_operands_ex_o[1]   <= '0;\n      apu_operands_ex_o[2]   <= '0;\n      apu_flags_ex_o         <= '0;\n      apu_waddr_ex_o         <= '0;\n\n\n      regfile_waddr_ex_o     <= 6'b0;\n      regfile_we_ex_o        <= 1'b0;\n\n      regfile_alu_waddr_ex_o <= 6'b0;\n      regfile_alu_we_ex_o    <= 1'b0;\n      prepost_useincr_ex_o   <= 1'b0;\n\n      csr_access_ex_o        <= 1'b0;\n      csr_op_ex_o            <= CSR_OP_READ;\n\n      data_we_ex_o           <= 1'b0;\n      data_type_ex_o         <= 2'b0;\n      data_sign_ext_ex_o     <= 2'b0;\n      data_reg_offset_ex_o   <= 2'b0;\n      data_req_ex_o          <= 1'b0;\n      data_load_event_ex_o   <= 1'b0;\n      atop_ex_o              <= 5'b0;\n\n      data_misaligned_ex_o   <= 1'b0;\n\n      pc_ex_o                <= '0;\n\n      branch_in_ex_o         <= 1'b0;\n\n    end else if (data_misaligned_i) begin\n      // misaligned data access case\n      if (ex_ready_i) begin  // misaligned access case, only unstall alu operands\n\n        // if we are using post increments, then we have to use the\n        // original value of the register for the second memory access\n        // => keep it stalled\n        if (prepost_useincr_ex_o == 1'b1) begin\n          alu_operand_a_ex_o <= operand_a_fw_id;\n        end\n\n        alu_operand_b_ex_o   <= 32'h4;\n        regfile_alu_we_ex_o  <= 1'b0;\n        prepost_useincr_ex_o <= 1'b1;\n\n        data_misaligned_ex_o <= 1'b1;\n      end\n    end else if (mult_multicycle_i) begin\n      mult_operand_c_ex_o <= operand_c_fw_id;\n    end else begin\n      // normal pipeline unstall case\n\n      if (id_valid_o) begin  // unstall the whole pipeline\n        alu_en_ex_o <= alu_en;\n        if (alu_en) begin\n          alu_operator_ex_o   <= alu_operator;\n          alu_operand_a_ex_o  <= alu_operand_a;\n          alu_operand_b_ex_o  <= alu_operand_b;\n          alu_operand_c_ex_o  <= alu_operand_c;\n          bmask_a_ex_o        <= bmask_a_id;\n          bmask_b_ex_o        <= bmask_b_id;\n          imm_vec_ext_ex_o    <= imm_vec_ext_id;\n          alu_vec_mode_ex_o   <= alu_vec_mode;\n          alu_is_clpx_ex_o    <= is_clpx;\n          alu_clpx_shift_ex_o <= instr[14:13];\n          alu_is_subrot_ex_o  <= is_subrot;\n        end\n\n        mult_en_ex_o <= mult_en;\n        if (mult_int_en) begin\n          mult_operator_ex_o    <= mult_operator;\n          mult_sel_subword_ex_o <= mult_sel_subword;\n          mult_signed_mode_ex_o <= mult_signed_mode;\n          mult_operand_a_ex_o   <= alu_operand_a;\n          mult_operand_b_ex_o   <= alu_operand_b;\n          mult_operand_c_ex_o   <= alu_operand_c;\n          mult_imm_ex_o         <= mult_imm_id;\n        end\n        if (mult_dot_en) begin\n          mult_operator_ex_o   <= mult_operator;\n          mult_dot_signed_ex_o <= mult_dot_signed;\n          mult_dot_op_a_ex_o   <= alu_operand_a;\n          mult_dot_op_b_ex_o   <= alu_operand_b;\n          mult_dot_op_c_ex_o   <= alu_operand_c;\n          mult_is_clpx_ex_o    <= is_clpx;\n          mult_clpx_shift_ex_o <= instr[14:13];\n          mult_clpx_img_ex_o   <= instr[25];\n        end\n\n        // APU pipeline\n        apu_en_ex_o <= apu_en;\n        if (apu_en) begin\n          apu_op_ex_o       <= apu_op;\n          apu_lat_ex_o      <= apu_lat;\n          apu_operands_ex_o <= apu_operands;\n          apu_flags_ex_o    <= apu_flags;\n          apu_waddr_ex_o    <= apu_waddr;\n        end\n\n        regfile_we_ex_o <= regfile_we_id;\n        if (regfile_we_id) begin\n          regfile_waddr_ex_o <= regfile_waddr_id;\n        end\n\n        regfile_alu_we_ex_o <= regfile_alu_we_id;\n        if (regfile_alu_we_id) begin\n          regfile_alu_waddr_ex_o <= regfile_alu_waddr_id;\n        end\n\n        prepost_useincr_ex_o <= prepost_useincr;\n\n        csr_access_ex_o      <= csr_access;\n        csr_op_ex_o          <= csr_op;\n\n        data_req_ex_o        <= data_req_id;\n        if (data_req_id) begin  // only needed for LSU when there is an active request\n          data_we_ex_o         <= data_we_id;\n          data_type_ex_o       <= data_type_id;\n          data_sign_ext_ex_o   <= data_sign_ext_id;\n          data_reg_offset_ex_o <= data_reg_offset_id;\n          data_load_event_ex_o <= data_load_event_id;\n          atop_ex_o            <= atop_id;\n        end else begin\n          data_load_event_ex_o <= 1'b0;\n        end\n\n        data_misaligned_ex_o <= 1'b0;\n\n        if ((ctrl_transfer_insn_in_id == BRANCH_COND) || data_req_id) begin\n          pc_ex_o <= pc_id_i;\n        end\n\n        branch_in_ex_o <= ctrl_transfer_insn_in_id == BRANCH_COND;\n      end else if (ex_ready_i) begin\n        // EX stage is ready but we don't have a new instruction for it,\n        // so we set all write enables to 0, but unstall the pipe\n\n        regfile_we_ex_o      <= 1'b0;\n\n        regfile_alu_we_ex_o  <= 1'b0;\n\n        csr_op_ex_o          <= CSR_OP_READ;\n\n        data_req_ex_o        <= 1'b0;\n\n        data_load_event_ex_o <= 1'b0;\n\n        data_misaligned_ex_o <= 1'b0;\n\n        branch_in_ex_o       <= 1'b0;\n\n        apu_en_ex_o          <= 1'b0;\n\n        alu_operator_ex_o    <= ALU_SLTU;\n\n        mult_en_ex_o         <= 1'b0;\n\n        alu_en_ex_o          <= 1'b1;\n\n      end else if (csr_access_ex_o) begin\n        //In the EX stage there was a CSR access, to avoid multiple\n        //writes to the RF, disable regfile_alu_we_ex_o.\n        //Not doing it can overwrite the RF file with the currennt CSR value rather than the old one\n        regfile_alu_we_ex_o <= 1'b0;\n      end\n    end\n  end\n\n  // Performance Counter Events\n\n  // Illegal/ebreak/ecall are never counted as retired instructions. Note that actually issued instructions\n  // are being counted; the manner in which CSR instructions access the performance counters guarantees\n  // that this count will correspond to the retired isntructions count.\n  assign minstret = id_valid_o && is_decoding_o && !(illegal_insn_dec || ebrk_insn_dec || ecall_insn_dec);\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      id_valid_q               <= 1'b0;\n      mhpmevent_minstret_o     <= 1'b0;\n      mhpmevent_load_o         <= 1'b0;\n      mhpmevent_store_o        <= 1'b0;\n      mhpmevent_jump_o         <= 1'b0;\n      mhpmevent_branch_o       <= 1'b0;\n      mhpmevent_compressed_o   <= 1'b0;\n      mhpmevent_branch_taken_o <= 1'b0;\n      mhpmevent_jr_stall_o     <= 1'b0;\n      mhpmevent_imiss_o        <= 1'b0;\n      mhpmevent_ld_stall_o     <= 1'b0;\n      mhpmevent_pipe_stall_o   <= 1'b0;\n    end else begin\n      // Helper signal\n      id_valid_q <= id_valid_o;\n      // ID stage counts\n      mhpmevent_minstret_o <= minstret;\n      mhpmevent_load_o <= minstret && data_req_id && !data_we_id;\n      mhpmevent_store_o <= minstret && data_req_id && data_we_id;\n      mhpmevent_jump_o           <= minstret && ((ctrl_transfer_insn_in_id == BRANCH_JAL) || (ctrl_transfer_insn_in_id == BRANCH_JALR));\n      mhpmevent_branch_o <= minstret && (ctrl_transfer_insn_in_id == BRANCH_COND);\n      mhpmevent_compressed_o <= minstret && is_compressed_i;\n      // EX stage count\n      mhpmevent_branch_taken_o <= mhpmevent_branch_o && branch_decision_i;\n      // IF stage count\n      mhpmevent_imiss_o <= perf_imiss_i;\n      // Jump-register-hazard; do not count stall on flushed instructions (id_valid_q used to only count first cycle)\n      mhpmevent_jr_stall_o <= jr_stall && !halt_id && id_valid_q;\n      // Load-use-hazard; do not count stall on flushed instructions (id_valid_q used to only count first cycle)\n      mhpmevent_ld_stall_o <= load_stall && !halt_id && id_valid_q;\n      // ELW\n      mhpmevent_pipe_stall_o <= perf_pipeline_stall;\n    end\n  end\n\n  // stall control\n  assign id_ready_o = ((~misaligned_stall) & (~jr_stall) & (~load_stall) & (~apu_stall) & (~csr_apu_stall) & ex_ready_i);\n  assign id_valid_o = (~halt_id) & id_ready_o;\n  assign halt_if_o = halt_if;\n\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n`ifdef CV32E40P_ASSERT_ON\n\n  always_comb begin\n    if (FPU == 1) begin\n      assert (APU_NDSFLAGS_CPU >= C_RM+2*cv32e40p_fpu_pkg::FP_FORMAT_BITS+cv32e40p_fpu_pkg::INT_FORMAT_BITS)\n      else\n        $error(\"[apu] APU_NDSFLAGS_CPU APU flagbits is smaller than %0d\",\n               C_RM + 2 * cv32e40p_fpu_pkg::FP_FORMAT_BITS + cv3"}
{"text": "2e40p_fpu_pkg::INT_FORMAT_BITS);\n    end\n  end\n\n  // make sure that branch decision is valid when jumping\n  a_br_decision :\n  assert property (@(posedge clk) (branch_in_ex_o) |-> (branch_decision_i !== 1'bx))\n  else begin\n    $warning(\"%t, Branch decision is X in module %m\", $time);\n    $stop;\n  end\n\n  // the instruction delivered to the ID stage should always be valid\n  a_valid_instr :\n  assert property (@(posedge clk) (instr_valid_i & (~illegal_c_insn_i)) |-> (!$isunknown(instr)))\n  else $warning(\"%t, Instruction is valid, but has at least one X\", $time);\n\n  // Check that instruction after taken branch is flushed (more should actually be flushed, but that is not checked here)\n  // and that EX stage is ready to receive flushed instruction immediately\n  property p_branch_taken_ex;\n    @(posedge clk) disable iff (!rst_n) (branch_taken_ex == 1'b1) |-> ((ex_ready_i == 1'b1) &&\n                                                                          (alu_en == 1'b0) && (apu_en == 1'b0) &&\n                                                                          (mult_en == 1'b0) && (mult_int_en == 1'b0) &&\n                                                                          (mult_dot_en == 1'b0) && (regfile_we_id == 1'b0) &&\n                                                                          (regfile_alu_we_id == 1'b0) && (data_req_id == 1'b0));\n  endproperty\n\n  a_branch_taken_ex :\n  assert property (p_branch_taken_ex);\n\n  // Check that if IRQ PC update does not coincide with IRQ related CSR write\n  // MIE is excluded from the check because it has a bypass.\n  property p_irq_csr;\n    @(posedge clk) disable iff (!rst_n) (pc_set_o && (pc_mux_o == PC_EXCEPTION) && ((exc_pc_mux_o == EXC_PC_EXCEPTION) || (exc_pc_mux_o == EXC_PC_IRQ)) &&\n                                            csr_access_ex_o && (csr_op_ex_o != CSR_OP_READ)) |->\n                                           ((alu_operand_b_ex_o[11:0] != CSR_MSTATUS) && (alu_operand_b_ex_o[11:0] != CSR_USTATUS) &&\n                                            (alu_operand_b_ex_o[11:0] != CSR_MEPC) && (alu_operand_b_ex_o[11:0] != CSR_UEPC) &&\n                                            (alu_operand_b_ex_o[11:0] != CSR_MCAUSE) && (alu_operand_b_ex_o[11:0] != CSR_UCAUSE) &&\n                                            (alu_operand_b_ex_o[11:0] != CSR_MTVEC) && (alu_operand_b_ex_o[11:0] != CSR_UTVEC));\n  endproperty\n\n  a_irq_csr :\n  assert property (p_irq_csr);\n\n  // Check that xret does not coincide with CSR write (to avoid using wrong return address)\n  // This check is more strict than really needed; a CSR instruction would be allowed in EX as long\n  // as its write action happens before the xret CSR usage\n  property p_xret_csr;\n    @(posedge clk) disable iff (!rst_n) (pc_set_o && ((pc_mux_o == PC_MRET) || (pc_mux_o == PC_URET) || (pc_mux_o == PC_DRET))) |->\n                                           (!(csr_access_ex_o && (csr_op_ex_o != CSR_OP_READ)));\n  endproperty\n\n  a_xret_csr :\n  assert property (p_xret_csr);\n\n  generate\n    if (!A_EXTENSION) begin : gen_no_a_extension_assertions\n\n      // Check that A extension opcodes are decoded as illegal when A extension not enabled\n      property p_illegal_0;\n        @(posedge clk) disable iff (!rst_n) (instr[6:0] == OPCODE_AMO) |-> (illegal_insn_dec == 'b1);\n      endproperty\n\n      a_illegal_0 :\n      assert property (p_illegal_0);\n\n    end\n  endgenerate\n\n  generate\n    if (!COREV_PULP) begin : gen_no_pulp_xpulp_assertions\n\n      // Check that PULP extension opcodes are decoded as illegal when PULP extension is not enabled\n      property p_illegal_1;\n        @(posedge clk) disable iff (!rst_n) ((instr[6:0] == OPCODE_CUSTOM_0) || (instr[6:0] == OPCODE_CUSTOM_1) ||\n                                             (instr[6:0] == OPCODE_CUSTOM_2) || (instr[6:0] == OPCODE_CUSTOM_3))\n                                            |-> (illegal_insn_dec == 'b1);\n      endproperty\n\n      a_illegal_1 :\n      assert property (p_illegal_1);\n\n      // Check that certain ALU operations are not used when PULP extension is not enabled\n      property p_alu_op;\n        @(posedge clk) disable iff (!rst_n) (1'b1) |-> ( (alu_operator != ALU_ADDU ) && (alu_operator != ALU_SUBU ) &&\n                                                           (alu_operator != ALU_ADDR ) && (alu_operator != ALU_SUBR ) &&\n                                                           (alu_operator != ALU_ADDUR) && (alu_operator != ALU_SUBUR) &&\n                                                           (alu_operator != ALU_ROR) && (alu_operator != ALU_BEXT) &&\n                                                           (alu_operator != ALU_BEXTU) && (alu_operator != ALU_BINS) &&\n                                                           (alu_operator != ALU_BCLR) && (alu_operator != ALU_BSET) &&\n                                                           (alu_operator != ALU_BREV) && (alu_operator != ALU_FF1) &&\n                                                           (alu_operator != ALU_FL1) && (alu_operator != ALU_CNT) &&\n                                                           (alu_operator != ALU_CLB) && (alu_operator != ALU_EXTS) &&\n                                                           (alu_operator != ALU_EXT) && (alu_operator != ALU_LES) &&\n                                                           (alu_operator != ALU_LEU) && (alu_operator != ALU_GTS) &&\n                                                           (alu_operator != ALU_GTU) && (alu_operator != ALU_SLETS) &&\n                                                           (alu_operator != ALU_SLETU) && (alu_operator != ALU_ABS) &&\n                                                           (alu_operator != ALU_CLIP) && (alu_operator != ALU_CLIPU) &&\n                                                           (alu_operator != ALU_INS) && (alu_operator != ALU_MIN) &&\n                                                           (alu_operator != ALU_MINU) && (alu_operator != ALU_MAX) &&\n                                                           (alu_operator != ALU_MAXU) && (alu_operator != ALU_SHUF) &&\n                                                           (alu_operator != ALU_SHUF2) && (alu_operator != ALU_PCKLO) &&\n                                                           (alu_operator != ALU_PCKHI) );\n      endproperty\n\n      a_alu_op :\n      assert property (p_alu_op);\n\n      // Check that certain vector modes are not used when PULP extension is not enabled\n      property p_vector_mode;\n        @(posedge clk) disable iff (!rst_n) (1'b1) |-> ( (alu_vec_mode != VEC_MODE8 ) && (alu_vec_mode != VEC_MODE16 ) );\n      endproperty\n\n      a_vector_mode :\n      assert property (p_vector_mode);\n\n      // Check that certain multiplier operations are not used when PULP extension is not enabled\n      property p_mul_op;\n        @(posedge clk) disable iff (!rst_n) (mult_int_en == 1'b1) |-> ( (mult_operator != MUL_MSU32) && (mult_operator != MUL_I) &&\n                                                                         (mult_operator != MUL_IR) && (mult_operator != MUL_DOT8) &&\n                                                                         (mult_operator != MUL_DOT16) );\n      endproperty\n\n      a_mul_op :\n      assert property (p_mul_op);\n\n    end\n  endgenerate\n\n  // Check that illegal instruction has no other side effects\n  property p_illegal_2;\n    @(posedge clk) disable iff (!rst_n) (illegal_insn_dec == 1'b1) |-> !(ebrk_insn_dec || mret_insn_dec || uret_insn_dec || dret_insn_dec ||\n                                                                            ecall_insn_dec || wfi_insn_dec || fencei_insn_dec ||\n                                                                            alu_en || mult_int_en || mult_dot_en || apu_en ||\n                                                                            regfile_we_id || regfile_alu_we_id ||\n                                                                            csr_op != CSR_OP_READ || data_req_id);\n  endproperty\n\n  a_illegal_2 :\n  assert property (p_illegal_2);\n\n`endif\n\nendmodule  // cv32e40p_id_stage\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Renzo Andri - andrire@student.ethz.ch                      //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Igor Loi - igor.loi@unibo.it                               //\n//                 Andreas Traber - atraber@student.ethz.ch                   //\n//                 Sven Stucki - svstucki@student.ethz.ch                     //\n//                                                                            //\n// Design Name:    Instruction Fetch Stage                                    //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Instruction fetch unit: Selection of the next PC, and      //\n//                 buffering (sampling) of the read instruction               //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_if_stage #(\n    parameter COREV_PULP = 0, // PULP ISA Extension (including PULP specific CSRs and hardware loop, excluding cv.elw)\n    parameter PULP_OBI = 0,  // Legacy PULP OBI behavior\n    parameter PULP_SECURE = 0,\n    parameter FPU = 0,\n    parameter ZFINX = 0\n) (\n    input logic clk,\n    input logic rst_n,\n\n    // Used to calculate the exception offsets\n    input logic [23:0] m_trap_base_addr_i,\n    input logic [23:0] u_trap_base_addr_i,\n    input logic [ 1:0] trap_addr_mux_i,\n    // Boot address\n    input logic [31:0] boot_addr_i,\n    input logic [31:0] dm_exception_addr_i,\n\n    // Debug mode halt address\n    input logic [31:0] dm_halt_addr_i,\n\n    // instruction request control\n    input logic req_i,\n\n    // instruction cache interface\n    output logic instr_req_o,\n    output logic [31:0] instr_addr_o,\n    input logic instr_gnt_i,\n    input logic instr_rvalid_i,\n    input logic [31:0] instr_rdata_i,\n    input logic instr_err_i,      // External bus error (validity defined by instr_rvalid_i) (not used yet)\n    input logic instr_err_pmp_i,  // PMP error (validity defined by instr_gnt_i)\n\n    // Output of IF Pipeline stage\n    output logic instr_valid_id_o,  // instruction in IF/ID pipeline is valid\n    output logic [31:0] instr_rdata_id_o,      // read instruction is sampled and sent to ID stage for decoding\n    output logic is_compressed_id_o,  // compressed decoder thinks this is a compressed instruction\n    output logic illegal_c_insn_id_o,  // compressed decoder thinks this is an invalid instruction\n    output logic [31:0] pc_if_o,\n    output logic [31:0] pc_id_o,\n    output logic is_fetch_failed_o,\n\n    // Forwarding ports - control signals\n    input logic clear_instr_valid_i,  // clear instruction valid bit in IF/ID pipe\n    input logic pc_set_i,  // set the program counter to a new value\n    input logic [31:0] mepc_i,  // address used to restore PC when the interrupt/exception is served\n    input logic [31:0] uepc_i,  // address used to restore PC when the interrupt/exception is served\n\n    input logic [31:0] depc_i,  // address used to restore PC when the debug is served\n\n    input logic [3:0] pc_mux_i,  // sel for pc multiplexer\n    input logic [2:0] exc_pc_mux_i,  // selects ISR address\n\n    input  logic [4:0] m_exc_vec_pc_mux_i,  // selects ISR address for vectorized interrupt lines\n    input  logic [4:0] u_exc_vec_pc_mux_i,  // selects ISR address for vectorized interrupt lines\n    output logic       csr_mtvec_init_o,  // tell CS regfile to init mtvec\n\n    // jump and branch target and decision\n    input logic [31:0] jump_target_id_i,  // jump target address\n    input logic [31:0] jump_target_ex_i,  // jump target address\n\n    // from hwloop controller\n    input logic        hwlp_jump_i,\n    input logic [31:0] hwlp_target_i,\n\n    // pipeline stall\n    input logic halt_if_i,\n    input logic id_ready_i,\n\n    // misc signals\n    output logic if_busy_o,  // is the IF stage busy fetching instructions?\n    output logic perf_imiss_o  // Instruction Fetch Miss\n);\n\n  import cv32e40p_pkg::*;\n\n  logic if_valid, if_ready;\n\n  // prefetch buffer related signals\n  logic        prefetch_busy;\n  logic        branch_req;\n  logic [31:0] branch_addr_n;\n\n  logic        fetch_valid;\n  logic        fetch_ready;\n  logic [31:0] fetch_rdata;\n\n  logic [31:0] exc_pc;\n\n  logic [23:0] trap_base_addr;\n  logic [ 4:0] exc_vec_pc_mux;\n  logic        fetch_failed;\n\n  logic        aligner_ready;\n  logic        instr_valid;\n\n  logic        illegal_c_insn;\n  logic [31:0] instr_aligned;\n  logic [31:0] instr_decompressed;\n  logic        instr_compressed_int;\n\n\n  // exception PC selection mux\n  always_comb begin : EXC_PC_MUX\n    unique case (trap_addr_mux_i)\n      TRAP_MACHINE: trap_base_addr = m_trap_base_addr_i;\n      TRAP_USER:    trap_base_addr = u_trap_base_addr_i;\n      default:      trap_base_addr = m_trap_base_addr_i;\n    endcase\n\n    unique case (trap_addr_mux_i)\n      TRAP_MACHINE: exc_vec_pc_mux = m_exc_vec_pc_mux_i;\n      TRAP_USER:    exc_vec_pc_mux = u_exc_vec_pc_mux_i;\n      default:      exc_vec_pc_mux = m_exc_vec_pc_mux_i;\n    endcase\n\n    unique case (exc_pc_mux_i)\n      EXC_PC_EXCEPTION:\n      exc_pc = {trap_base_addr, 8'h0};  //1.10 all the exceptions go to base address\n      EXC_PC_IRQ: exc_pc = {trap_base_addr, 1'b0, exc_vec_pc_mux, 2'b0};  // interrupts are vectored\n      EXC_PC_DBD: exc_pc = {dm_halt_addr_i[31:2], 2'b0};\n      EXC_PC_DBE: exc_pc = {dm_exception_addr_i[31:2], 2'b0};\n      default: exc_pc = {trap_base_addr, 8'h0};\n    endcase\n  end\n\n  // fetch address selection\n  always_comb begin\n    // Default assign PC_BOOT (should be overwritten in below case)\n    branch_addr_n = {boot_addr_i[31:2], 2'b0};\n\n    unique case (pc_mux_i)\n      PC_BOOT: branch_addr_n = {boot_addr_i[31:2], 2'b0};\n      PC_JUMP: branch_addr_n = jump_target_id_i;\n      PC_BRANCH: branch_addr_n = jump_target_ex_i;\n      PC_EXCEPTION: branch_addr_n = exc_pc;  // set PC to exception handler\n      PC_MRET: branch_addr_n = mepc_i;  // PC is restored when returning from IRQ/exception\n      PC_URET: branch_addr_n = uepc_i;  // PC is restored when returning from IRQ/exception\n      PC_DRET: branch_addr_n = depc_i;  //\n      PC_FENCEI: branch_addr_n = pc_id_o + 4;  // jump to next instr forces prefetch buffer reload\n      PC_HWLOOP: branch_addr_n = hwlp_target_i;\n      default: ;\n    endcase\n  end\n\n  // tell CS register file to initialize mtvec on boot\n  assign csr_mtvec_init_o = (pc_mux_i == PC_BOOT) & pc_set_i;\n\n  assign fetch_failed    = 1'b0; // PMP is not supported in CV32E40P\n\n  // prefetch buffer, caches a fixed number of instructions\n  cv32e40p_prefetch_buffer #(\n      .PULP_OBI  (PULP_OBI),\n      .COREV_PULP(COREV_PULP)\n  ) prefetch_buffer_i (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      .req_i(req_i),\n\n      .branch_i     (branch_req),\n      .branch_addr_i({branch_addr_n[31:1], 1'b0}),\n\n      .hwlp_jump_i  (hwlp_jump_i),\n      .hwlp_target_i(hwlp_target_i),\n\n      .fetch_ready_i(fetch_ready),\n      .fetch_valid_o(fetch_valid),\n      .fetch_rdata_o(fetch_rdata),\n\n      // goes to instruction memory / instruction cache\n      .instr_req_o    (instr_req_o),\n      .instr_addr_o   (instr_addr_o),\n      .instr_gnt_i    (instr_gnt_i),\n      .instr_rvalid_i (instr_rvalid_i),\n      .instr_err_i    (instr_err_i),  // Not supported (yet)\n      .instr_err_pmp_i(instr_err_pmp_i),  // Not supported (yet)\n      .instr_rdata_i  (instr_rdata_i),\n\n      // Prefetch Buffer Status\n      .busy_o(prefetch_busy)\n  );\n\n  // offset FSM state transition logic\n  always_comb begin\n\n    fetch_ready = 1'b0;\n    branch_req  = 1'b0;\n    // take care of jumps and branches\n    if (pc_set_i) begin\n      branch_req = 1'b1;\n    end else if (fetch_valid) begin\n      if (req_i && if_valid) begin\n        fetch_ready = aligner_ready;\n      end\n    end\n  end\n\n  assign if_busy_o    = prefetch_busy;\n  assign perf_imiss_o = !fetch_valid && !branch_req;\n\n  // IF-ID pipeline registers, frozen when the ID stage is stalled\n  always_ff @(posedge clk, negedge rst_n) begin : IF_ID_PIPE_REGISTERS\n    if (rst_n == 1'b0) begin\n      instr_valid_id_o    <= 1'b0;\n      instr_rdata_id_o    <= '0;\n      is_fetch_failed_o   <= 1'b0;\n      pc_id_o             <= '0;\n      is_compressed_id_o  <= 1'b0;\n      illegal_c_insn_id_o <= 1'b0;\n    end else begin\n\n      if (if_valid && instr_valid) begin\n        instr_valid_id_o    <= 1'b1;\n        instr_rdata_id_o    <= instr_decompressed;\n        is_compressed_id_o  <= instr_compressed_int;\n        illegal_c_insn_id_o <= illegal_c_insn;\n        is_fetch_failed_o   <= 1'b0;\n        pc_id_o             <= pc_if_o;\n      end else if (clear_instr_valid_i) begin\n        instr_valid_id_o  <= 1'b0;\n        is_fetch_failed_o <= fetch_failed;\n      end\n    end\n  end\n\n  assign if_ready = fetch_valid & id_ready_i;\n  assign if_valid = (~halt_if_i) & if_ready;\n\n  cv32e40p_aligner aligner_i (\n      .clk             (clk),\n      .rst_n           (rst_n),\n      .fetch_valid_i   (fetch_valid),\n      .aligner_ready_o (aligner_ready),\n      .if_valid_i      (if_valid),\n      .fetch_rdata_i   (fetch_rdata),\n      .instr_aligned_o (instr_aligned),\n      .instr_valid_o   (instr_valid),\n      .branch_addr_i   ({branch_addr_n[31:1], 1'b0}),\n      .branch_i        (branch_req),\n      .hwlp_addr_i     (hwlp_target_i),\n      .hwlp_update_pc_i(hwlp_jump_i),\n      .pc_o            (pc_if_o)\n  );\n\n  cv32e40p_compressed_decoder #(\n      .FPU  (FPU),\n      .ZFINX(ZFINX)\n  ) compressed_decoder_i (\n      .instr_i        (instr_aligned),\n      .instr_o        (instr_decompressed),\n      .is_compressed_o(instr_compressed_int),\n      .illegal_instr_o(illegal_c_insn)\n  );\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n\n`ifdef CV32E40P_ASSERT_ON\n\n  generate\n    if (!COREV_PULP) begin : gen_no_pulp_xpulp_assertions\n\n      // Check that PC Mux cannot select Hardware Loop address iF PULP extensions are not included\n      property p_pc_mux_0;\n        @(posedge clk) disable iff (!rst_n) (1'b1) |-> (pc_mux_i != PC_HWLOOP);\n      endproperty\n\n      a_pc_mux_0 :\n      assert property (p_pc_mux_0);\n\n    end\n  endgenerate\n\n  generate\n    if (!PULP_SECURE) begin : gen_no_pulp_secure_assertions\n\n      // Check that PC Mux cannot select URET address if User Mode is not included\n      property p_pc_mux_1;\n        @(posedge clk) disable iff (!rst_n) (1'b1) |-> (pc_mux_i != PC_URET);\n      endproperty\n\n      a_pc_mux_1 :\n      assert property (p_pc_mux_1);\n\n    end\n  endgenerate\n\n`endif\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Additional contributions by:                                               //\n//                                                                            //\n// Design Name:    Interrupt Controller                                       //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Interrupt Controller of the pipelined processor            //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_int_controller\n  import cv32e40p_pkg::*;\n#(\n    parameter PULP_SECURE = 0\n) (\n    input logic clk,\n    input logic rst_n,\n\n    // External interrupt lines\n    input logic [31:0] irq_i,  // Level-triggered interrupt inputs\n    input logic        irq_sec_i,  // Interrupt secure bit from EU\n\n    // To cv32e40p_controller\n    output logic       irq_req_ctrl_o,\n    output logic       irq_sec_ctrl_o,\n    output logic [4:0] irq_id_ctrl_o,\n    output logic       irq_wu_ctrl_o,\n\n    // To/from cv32e40p_cs_registers\n    input  logic     [31:0] mie_bypass_i,  // MIE CSR (bypass)\n    output logic     [31:0] mip_o,  // MIP CSR\n    input  logic            m_ie_i,  // Interrupt enable bit from CSR (M mode)\n    input  logic            u_ie_i,  // Interrupt enable bit from CSR (U mode)\n    input  PrivLvl_t        current_priv_lvl_i\n);\n\n  logic        global_irq_enable;\n  logic [31:0] irq_local_qual;\n  logic [31:0] irq_q;\n  logic        irq_sec_q;\n\n  // Register all interrupt inputs (on gated clock). The wake-up logic will\n  // observe irq_i as well, but in all other places irq_q will be used to \n  // avoid timing paths from irq_i to instr_*_o\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      irq_q     <= '0;\n      irq_sec_q <= 1'b0;\n    end else begin\n      irq_q     <= irq_i & IRQ_MASK;\n      irq_sec_q <= irq_sec_i;\n    end\n  end\n\n  // MIP CSR\n  assign mip_o = irq_q;\n\n  // Qualify registered IRQ with MIE CSR to compute locally enabled IRQs\n  assign irq_local_qual = irq_q & mie_bypass_i;\n\n  // Wake-up signal based on unregistered IRQ such that wake-up can be caused if no clock is present\n  assign irq_wu_ctrl_o = |(irq_i & mie_bypass_i);\n\n  // Global interrupt enable\n  generate\n    if (PULP_SECURE) begin : gen_pulp_secure\n      assign global_irq_enable = ((u_ie_i || irq_sec_i) && current_priv_lvl_i == PRIV_LVL_U) || (m_ie_i && current_priv_lvl_i == PRIV_LVL_M);\n    end else begin : gen_no_pulp_secure\n      assign global_irq_enable = m_ie_i;\n    end\n  endgenerate\n\n  // Request to take interrupt if there is a locally enabled interrupt while interrupts are also enabled globally\n  assign irq_req_ctrl_o = (|irq_local_qual) && global_irq_enable;\n\n  // Interrupt Encoder\n  //\n  // - sets correct id to request to ID\n  // - encodes priority order\n\n  always_comb begin\n    if (irq_local_qual[31]) irq_id_ctrl_o = 5'd31;  // Custom irq_i[31]\n    else if (irq_local_qual[30]) irq_id_ctrl_o = 5'd30;  // Custom irq_i[30]\n    else if (irq_local_qual[29]) irq_id_ctrl_o = 5'd29;  // Custom irq_i[29]\n    else if (irq_local_qual[28]) irq_id_ctrl_o = 5'd28;  // Custom irq_i[28]\n    else if (irq_local_qual[27]) irq_id_ctrl_o = 5'd27;  // Custom irq_i[27]\n    else if (irq_local_qual[26]) irq_id_ctrl_o = 5'd26;  // Custom irq_i[26]\n    else if (irq_local_qual[25]) irq_id_ctrl_o = 5'd25;  // Custom irq_i[25]\n    else if (irq_local_qual[24]) irq_id_ctrl_o = 5'd24;  // Custom irq_i[24]\n    else if (irq_local_qual[23]) irq_id_ctrl_o = 5'd23;  // Custom irq_i[23]\n    else if (irq_local_qual[22]) irq_id_ctrl_o = 5'd22;  // Custom irq_i[22]\n    else if (irq_local_qual[21]) irq_id_ctrl_o = 5'd21;  // Custom irq_i[21]\n    else if (irq_local_qual[20]) irq_id_ctrl_o = 5'd20;  // Custom irq_i[20]\n    else if (irq_local_qual[19]) irq_id_ctrl_o = 5'd19;  // Custom irq_i[19]\n    else if (irq_local_qual[18]) irq_id_ctrl_o = 5'd18;  // Custom irq_i[18]\n    else if (irq_local_qual[17]) irq_id_ctrl_o = 5'd17;  // Custom irq_i[17]\n    else if (irq_local_qual[16]) irq_id_ctrl_o = 5'd16;  // Custom irq_i[16]\n\n    else if (irq_local_qual[15])\n      irq_id_ctrl_o = 5'd15;  // Reserved  (default masked out with IRQ_MASK)\n    else if (irq_local_qual[14])\n      irq_id_ctrl_o = 5'd14;  // Reserved  (default masked out with IRQ_MASK)\n    else if (irq_local_qual[13])\n      irq_id_ctrl_o = 5'd13;  // Reserved  (default masked out with IRQ_MASK)\n    else if (irq_local_qual[12])\n      irq_id_ctrl_o = 5'd12;  // Reserved  (default masked out with IRQ_MASK)\n\n    else if (irq_local_qual[CSR_MEIX_BIT]) irq_id_ctrl_o = CSR_MEIX_BIT;  // MEI, irq_i[11]\n    else if (irq_local_qual[CSR_MSIX_BIT]) irq_id_ctrl_o = CSR_MSIX_BIT;  // MSI, irq_i[3]\n    else if (irq_local_qual[CSR_MTIX_BIT]) irq_id_ctrl_o = CSR_MTIX_BIT;  // MTI, irq_i[7]\n\n    else if (irq_local_qual[10])\n      irq_id_ctrl_o = 5'd10;                         // Reserved (for now assuming EI, SI, TI priority) (default masked out with IRQ_MASK)\n    else if (irq_local_qual[2])\n      irq_id_ctrl_o = 5'd2;                          // Reserved (for now assuming EI, SI, TI priority) (default masked out with IRQ_MASK)\n    else if (irq_local_qual[6])\n      irq_id_ctrl_o = 5'd6;                          // Reserved (for now assuming EI, SI, TI priority) (default masked out with IRQ_MASK)\n\n    else if (irq_local_qual[9])\n      irq_id_ctrl_o = 5'd9;  // Reserved: SEI (default masked out with IRQ_MASK)\n    else if (irq_local_qual[1])\n      irq_id_ctrl_o = 5'd1;  // Reserved: SSI (default masked out with IRQ_MASK)\n    else if (irq_local_qual[5])\n      irq_id_ctrl_o = 5'd5;  // Reserved: STI (default masked out with IRQ_MASK)\n\n    else if (irq_local_qual[8])\n      irq_id_ctrl_o = 5'd8;  // Reserved: UEI (default masked out with IRQ_MASK)\n    else if (irq_local_qual[0])\n      irq_id_ctrl_o = 5'd0;  // Reserved: USI (default masked out with IRQ_MASK)\n    else if (irq_local_qual[4])\n      irq_id_ctrl_o = 5'd4;  // Reserved: UTI (default masked out with IRQ_MASK)\n\n    else irq_id_ctrl_o = CSR_MTIX_BIT;  // Value not relevant\n  end\n\n  assign irq_sec_ctrl_o = irq_sec_q;\n\nendmodule  // cv32e40p_int_controller\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Igor Loi - igor.loi@unibo.it                               //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Andreas Traber - atraber@iis.ee.ethz.ch                    //\n//                                                                            //\n// Design Name:    Load Store Unit                                            //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Load Store Unit, used to eliminate multiple access during  //\n//                 processor stalls, and to align bytes and halfwords         //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_load_store_unit #(\n    parameter PULP_OBI = 0  // Legacy PULP OBI behavior\n) (\n    input logic clk,\n    input logic rst_n,\n\n    // output to data memory\n    output logic data_req_o,\n    input logic data_gnt_i,\n    input logic data_rvalid_i,\n    input  logic         data_err_i,           // External bus error (validity defined by data_rvalid_i) (not used yet)\n    input logic data_err_pmp_i,  // PMP error (validity defined by data_gnt_i)\n\n    output logic [31:0] data_addr_o,\n    output logic        data_we_o,\n    output logic [ 3:0] data_be_o,\n    output logic [31:0] data_wdata_o,\n    input  logic [31:0] data_rdata_i,\n\n    // signals from ex stage\n    input logic        data_we_ex_i,  // write enable                      -> from ex stage\n    input logic [ 1:0] data_type_ex_i,  // Data type word, halfword, byte    -> from ex stage\n    input logic [31:0] data_wdata_ex_i,  // data to write to memory           -> from ex stage\n    input logic [ 1:0] data_reg_offset_ex_i,  // offset inside register for stores -> from ex stage\n    input logic        data_load_event_ex_i,  // load event                        -> from ex stage\n    input logic [ 1:0] data_sign_ext_ex_i,  // sign extension                    -> from ex stage\n\n    output logic [31:0] data_rdata_ex_o,  // requested data                    -> to ex stage\n    input  logic        data_req_ex_i,  // data request                      -> from ex stage\n    input  logic [31:0] operand_a_ex_i,  // operand a from RF for address     -> from ex stage\n    input  logic [31:0] operand_b_ex_i,  // operand b from RF for address     -> from ex stage\n    input  logic        addr_useincr_ex_i,  // use a + b or just a for address   -> from ex stage\n\n    input  logic data_misaligned_ex_i,  // misaligned access in last ld/st   -> from ID/EX pipeline\n    output logic data_misaligned_o,  // misaligned access was detected    -> to controller\n\n    input  logic [5:0] data_atop_ex_i,  // atomic instructions signal        -> from ex stage\n    output logic [5:0] data_atop_o,  // atomic instruction signal         -> core output\n\n    output logic p_elw_start_o,  // load event starts\n    output logic p_elw_finish_o,  // load event finishes\n\n    // stall signal\n    output logic lsu_ready_ex_o,  // LSU ready for new data in EX stage\n    output logic lsu_ready_wb_o,  // LSU ready for new data in WB stage\n\n    output logic busy_o\n);\n\n  localparam DEPTH = 2;  // Maximum number of outstanding transactions\n\n  // Transaction request (to cv32e40p_obi_interface)\n  logic trans_valid;\n  logic trans_ready;\n  logic [31:0] trans_addr;\n  logic trans_we;\n  logic [3:0] trans_be;\n  logic [31:0] trans_wdata;\n  logic [5:0] trans_atop;\n\n  // Transaction response interface (from cv32e40p_obi_interface)\n  logic resp_valid;\n  logic [31:0] resp_rdata;\n  logic resp_err;  // Unused for now\n\n  // Counter to count maximum number of outstanding transactions\n  logic [1:0] cnt_q;  // Transaction counter\n  logic [1:0] next_cnt;  // Next value for cnt_q\n  logic         count_up;               // Increment outstanding transaction count by 1 (can happen at same time as count_down)\n  logic         count_down;             // Decrement outstanding transaction count by 1 (can happen at same time as count_up)\n\n  logic ctrl_update;  // Update load/store control info in WB stage\n\n  logic [31:0] data_addr_int;\n\n  // registers for data_rdata alignment and sign extension\n  logic [1:0] data_type_q;\n  logic [1:0] rdata_offset_q;\n  logic [1:0] data_sign_ext_q;\n  logic data_we_q;\n  logic data_load_event_q;\n\n  logic [1:0] wdata_offset;  // mux control for data to be written to memory\n\n  logic [3:0] data_be;\n  logic [31:0] data_wdata;\n\n  logic misaligned_st;  // high if we are currently performing the second part of a misaligned store\n  logic load_err_o, store_err_o;\n\n  logic [31:0] rdata_q;\n\n  ///////////////////////////////// BE generation ////////////////////////////////\n  always_comb begin\n    case (data_type_ex_i)  // Data type 00 Word, 01 Half word, 11,10 byte\n      2'b00: begin  // Writing a word\n        if (misaligned_st == 1'b0) begin  // non-misaligned case\n          case (data_addr_int[1:0])\n            2'b00: data_be = 4'b1111;\n            2'b01: data_be = 4'b1110;\n            2'b10: data_be = 4'b1100;\n            2'b11: data_be = 4'b1000;\n          endcase\n          ;  // case (data_addr_int[1:0])\n        end else begin  // misaligned case\n          case (data_addr_int[1:0])\n            2'b00: data_be = 4'b0000;  // this is not used, but included for completeness\n            2'b01: data_be = 4'b0001;\n            2'b10: data_be = 4'b0011;\n            2'b11: data_be = 4'b0111;\n          endcase\n          ;  // case (data_addr_int[1:0])\n        end\n      end\n\n      2'b01: begin  // Writing a half word\n        if (misaligned_st == 1'b0) begin  // non-misaligned case\n          case (data_addr_int[1:0])\n            2'b00: data_be = 4'b0011;\n            2'b01: data_be = 4'b0110;\n            2'b10: data_be = 4'b1100;\n            2'b11: data_be = 4'b1000;\n          endcase\n          ;  // case (data_addr_int[1:0])\n        end else begin  // misaligned case\n          data_be = 4'b0001;\n        end\n      end\n\n      2'b10, 2'b11: begin  // Writing a byte\n        case (data_addr_int[1:0])\n          2'b00: data_be = 4'b0001;\n          2'b01: data_be = 4'b0010;\n          2'b10: data_be = 4'b0100;\n          2'b11: data_be = 4'b1000;\n        endcase\n        ;  // case (data_addr_int[1:0])\n      end\n    endcase\n    ;  // case (data_type_ex_i)\n  end\n\n  // prepare data to be written to the memory\n  // we handle misaligned accesses, half word and byte accesses and\n  // register offsets here\n  assign wdata_offset = data_addr_int[1:0] - data_reg_offset_ex_i[1:0];\n  always_comb begin\n    case (wdata_offset)\n      2'b00: data_wdata = data_wdata_ex_i[31:0];\n      2'b01: data_wdata = {data_wdata_ex_i[23:0], data_wdata_ex_i[31:24]};\n      2'b10: data_wdata = {data_wdata_ex_i[15:0], data_wdata_ex_i[31:16]};\n      2'b11: data_wdata = {data_wdata_ex_i[7:0], data_wdata_ex_i[31:8]};\n    endcase\n    ;  // case (wdata_offset)\n  end\n\n\n  // FF for rdata alignment and sign-extension\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      data_type_q       <= '0;\n      rdata_offset_q    <= '0;\n      data_sign_ext_q   <= '0;\n      data_we_q         <= 1'b0;\n      data_load_event_q <= 1'b0;\n    end\n    else if (ctrl_update) // request was granted, we wait for rvalid and can continue to WB\n    begin\n      data_type_q       <= data_type_ex_i;\n      rdata_offset_q    <= data_addr_int[1:0];\n      data_sign_ext_q   <= data_sign_ext_ex_i;\n      data_we_q         <= data_we_ex_i;\n      data_load_event_q <= data_load_event_ex_i;\n    end\n  end\n\n  // Load event starts when request is sent and finishes when (final) rvalid is received\n  assign p_elw_start_o  = data_load_event_ex_i && data_req_o;\n  assign p_elw_finish_o = data_load_event_q && data_rvalid_i && !data_misaligned_ex_i;\n\n  ////////////////////////////////////////////////////////////////////////\n  //  ____  _               _____      _                 _              //\n  // / ___|(_) __ _ _ __   | ____|_  _| |_ ___ _ __  ___(_) ___  _ __   //\n  // \\___ \\| |/ _` | '_ \\  |  _| \\ \\/ / __/ _ \\ '_ \\/ __| |/ _ \\| '_ \\  //\n  //  ___) | | (_| | | | | | |___ >  <| ||  __/ | | \\__ \\ | (_) | | | | //\n  // |____/|_|\\__, |_| |_| |_____/_/\\_\\\\__\\___|_| |_|___/_|\\___/|_| |_| //\n  //          |___/                                                     //\n  ////////////////////////////////////////////////////////////////////////\n\n  logic [31:0] data_rdata_ext;\n\n  logic [31:0] rdata_w_ext;  // sign extension for words, actually only misaligned assembly\n  logic [31:0] rdata_h_ext;  // sign extension for half words\n  logic [31:0] rdata_b_ext;  // sign extension for bytes\n\n  // take care of misaligned words\n  always_comb begin\n    case (rdata_offset_q)\n      2'b00: rdata_w_ext = resp_rdata[31:0];\n      2'b01: rdata_w_ext = {resp_rdata[7:0], rdata_q[31:8]};\n      2'b10: rdata_w_ext = {resp_rdata[15:0], rdata_q[31:16]};\n      2'b11: rdata_w_ext = {resp_rdata[23:0], rdata_q[31:24]};\n    endcase\n  end\n\n  // sign extension for half words\n  always_comb begin\n    case (rdata_offset_q)\n      2'b00: begin\n        if (data_sign_ext_q == 2'b00) rdata_h_ext = {16'h0000, resp_rdata[15:0]};\n        else if (data_sign_ext_q == 2'b10) rdata_h_ext = {16'hffff, resp_rdata[15:0]};\n        else rdata_h_ext = {{16{resp_rdata[15]}}, resp_rdata[15:0]};\n      end\n\n      2'b01: begin\n        if (data_sign_ext_q == 2'b00) rdata_h_ext = {16'h0000, resp_rdata[23:8]};\n        else if (data_sign_ext_q == 2'b10) rdata_h_ext = {16'hffff, resp_rdata[23:8]};\n        else rdata_h_ext = {{16{resp_rdata[23]}}, resp_rdata[23:8]};\n      end\n\n      2'b10: begin\n        if (data_sign_ext_q == 2'b00) rdata_h_ext = {16'h0000, resp_rdata[31:16]};\n        else if (data_sign_ext_q == 2'b10) rdata_h_ext = {16'hffff, resp_rdata[31:16]};\n        else rdata_h_ext = {{16{resp_rdata[31]}}, resp_rdata[31:16]};\n      end\n\n      2'b11: begin\n        if (data_sign_ext_q == 2'b00) rdata_h_ext = {16'h0000, resp_rdata[7:0], rdata_q[31:24]};\n        else if (data_sign_ext_q == 2'b10)\n          rdata_h_ext = {16'hffff, resp_rdata[7:0], rdata_q[31:24]};\n        else rdata_h_ext = {{16{resp_rdata[7]}}, resp_rdata[7:0], rdata_q[31:24]};\n      end\n    endcase  // case (rdata_offset_q)\n  end\n\n  // sign extension for bytes\n  always_comb begin\n    case (rdata_offset_q)\n      2'b00: begin\n        if (data_sign_ext_q == 2'b00) rdata_b_ext = {24'h00_0000, resp_rdata[7:0]};\n        else if (data_sign_ext_q == 2'b10) rdata_b_ext = {24'hff_ffff, resp_rdata[7:0]};\n        else rdata_b_ext = {{24{resp_rdata[7]}}, resp_rdata[7:0]};\n      end\n\n      2'b01: begin\n        if (data_sign_ext_q == 2'b00) rdata_b_ext = {24'h00_0000, resp_rdata[15:8]};\n        else if (data_sign_ext_q == 2'b10) rdata_b_ext = {24'hff_ffff, resp_rdata[15:8]};\n        else rdata_b_ext = {{24{resp_rdata[15]}}, resp_rdata[15:8]};\n      end\n\n      2'b10: begin\n        if (data_sign_ext_q == 2'b00) rdata_b_ext = {24'h00_0000, resp_rdata[23:16]};\n        else if (data_sign_ext_q == 2'b10) rdata_b_ext = {24'hff_ffff, resp_rdata[23:16]};\n        else rdata_b_ext = {{24{resp_rdata[23]}}, resp_rdata[23:16]};\n      end\n\n      2'b11: begin\n        if (data_sign_ext_q == 2'b00) rdata_b_ext = {24'h00_0000, resp_rdata[31:24]};\n        else if (data_sign_ext_q == 2'b10) rdata_b_ext = {24'hff_ffff, resp_rdata[31:24]};\n        else rdata_b_ext = {{24{resp_rdata[31]}}, resp_rdata[31:24]};\n      end\n    endcase  // case (rdata_offset_q)\n  end\n\n  // select word, half word or byte sign extended version\n  always_comb begin\n    case (data_type_q)\n      2'b00:        data_rdata_ext = rdata_w_ext;\n      2'b01:        data_rdata_ext = rdata_h_ext;\n      2'b10, 2'b11: data_rdata_ext = rdata_b_ext;\n    endcase  //~case(rdata_type_q)\n  end\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      rdata_q <= '0;\n    end else begin\n      if (resp_valid && (~data_we_q)) begin\n        // if we have detected a misaligned access, and we are\n        // currently doing the first part of this access, then\n        // store the data coming from memory in rdata_q.\n        // In all other cases, rdata_q gets the value that we are\n        // writing to the register file\n        if ((data_misaligned_ex_i == 1'b1) || (data_misaligned_o == 1'b1)) rdata_q <= resp_rdata;\n        else rdata_q <= data_rdata_ext;\n      end\n    end\n  end\n\n  // output to register file\n  assign data_rdata_ex_o = (resp_valid == 1'b1) ? data_rdata_ext : rdata_q;\n\n  assign misaligned_st   = data_misaligned_ex_i;\n\n  // Note: PMP is not fully supported at the moment (not even if USE_PMP = 1)\n  assign load_err_o      = data_gnt_i && data_err_pmp_i && ~data_we_o;  // Not currently used\n  assign store_err_o     = data_gnt_i && data_err_pmp_i && data_we_o;  // Not currently used\n\n\n  // check for misaligned accesses that need a second memory access\n  // If one is detected, this is signaled with data_misaligned_o to\n  // the controller which selectively stalls the pipeline\n  always_comb begin\n    data_misaligned_o = 1'b0;\n\n    if ((data_req_ex_i == 1'b1) && (data_misaligned_ex_i == 1'b0)) begin\n      case (data_type_ex_i)\n        2'b00: // word\n        begin\n          if (data_addr_int[1:0] != 2'b00) data_misaligned_o = 1'b1;\n        end\n        2'b01: // half word\n        begin\n          if (data_addr_int[1:0] == 2'b11) data_misaligned_o = 1'b1;\n        end\n      endcase  // case (data_type_ex_i)\n    end\n  end\n\n  // generate address from operands\n  assign data_addr_int = (addr_useincr_ex_i) ? (operand_a_ex_i + operand_b_ex_i) : operand_a_ex_i;\n\n  // Busy if there are ongoing (or potentially outstanding) transfers\n  assign busy_o = (cnt_q != 2'b00) || trans_valid;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Transaction request generation\n  //\n  // Assumes that corresponding response is at least 1 cycle after request\n  //\n  // - Only request transaction when EX stage requires data transfer (data_req_ex_i), and\n  // - maximum number of outstanding transactions will not be exceeded (cnt_q < DEPTH)\n  //////////////////////////////////////////////////////////////////////////////\n\n  // For last phase of misaligned transfer the address needs to be word aligned (as LSB of data_be will be set)\n  assign trans_addr = data_misaligned_ex_i ? {data_addr_int[31:2], 2'b00} : data_addr_int;\n  assign trans_we = data_we_ex_i;\n  assign trans_be = data_be;\n  assign trans_wdata = data_wdata;\n  assign trans_atop = data_atop_ex_i;\n\n  // Transaction request generation\n  generate\n    if (PULP_OBI == 0) begin : gen_no_pulp_obi\n      // OBI compatible (avoids combinatorial path from data_rvalid_i to data_req_o).\n      // Multiple trans_* transactions can be issued (and accepted) before a response\n      // (resp_*) is received.\n      assign trans_valid = data_req_ex_i && (cnt_q < DEPTH);\n    end else begin : gen_pulp_obi\n      // Legacy PULP OBI behavior, i.e. only issue subsequent transaction if preceding transfer\n      // is about to finish (re-introducing timing critical path from data_rvalid_i to data_req_o)\n      assign trans_valid = (cnt_q == 2'b00) ? data_req_ex_i && (cnt_q < DEPTH) :\n                                              data_req_ex_i && (cnt_q < DEPTH) && resp_valid;\n    end\n  endgenerate\n\n  // LSU WB stage is ready if it is not being used (i.e. no outstanding transfers, cnt_q = 0),\n  // or if it WB stage is being used and the awaited response arrives (resp_rvalid).\n  assign lsu_ready_wb_o = (cnt_q == 2'b00) ? 1'b1 : resp_valid;\n\n  // LSU EX stage readyness requires two criteria to be met:\n  // \n  // - A data request (data_req_ex_i) has been forwarded/accepted (trans_valid && trans_ready)\n  // - The LSU WB stage is available such that EX and WB can be updated in lock step\n  //\n  // Default (if there is not even a data request) LSU EX is signaled to be ready, else\n  // if there are no outstanding transactions the EX stage is ready again once the transaction\n  // request is accepted (at which time this load/store will move to the WB stage), else\n  // in case there is already at least one outstanding transaction (so WB is full) the EX \n  // and WB stage can only signal readiness in lock step (so resp_valid is used as well).\n\n  assign lsu_ready_ex_o = (data_req_ex_i == 1'b0) ? 1'b1 :\n                          (cnt_q == 2'b00) ? (              trans_valid && trans_ready) : \n                          (cnt_q == 2'b01) ? (resp_valid && trans_valid && trans_ready) : \n                                              resp_valid;\n\n  // Update signals for EX/WB registers (when EX has valid data itself and is ready for next)\n  assign ctrl_update = lsu_ready_ex_o && data_req_ex_i;\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Counter (cnt_q, next_cnt) to count number of outstanding OBI transactions \n  // (maximum = DEPTH)\n  // \n  // Counter overflow is prevented by limiting the number of outstanding transactions\n  // to DEPTH. Counter underflow is prevented by the assumption that resp_valid = 1 \n  // will only occur in response to accepted transfer request (as per the OBI protocol).\n  //////////////////////////////////////////////////////////////////////////////\n\n  assign count_up = trans_valid && trans_ready;  // Increment upon accepted transfer request\n  assign count_down = resp_valid;  // Decrement upon accepted transfer response\n\n  always_comb begin\n    unique case ({\n      count_up, count_down\n    })\n      2'b00: begin\n        next_cnt = cnt_q;\n      end\n      2'b01: begin\n        next_cnt = cnt_q - 1'b1;\n      end\n      2'b10: begin\n        next_cnt = cnt_q + 1'b1;\n      end\n      2'b11: begin\n        next_cnt = cnt_q;\n      end\n    endcase\n  end\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Registers\n  //////////////////////////////////////////////////////////////////////////////\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      cnt_q <= '0;\n    end else begin\n      cnt_q <= next_cnt;\n    end\n  end\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // OBI interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  cv32e40p_obi_interface #(\n      .TRANS_STABLE(1)\n  ) data_obi_i (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      .trans_valid_i(trans_valid),\n      .trans_ready_o(trans_ready),\n      .trans_addr_i (trans_addr),\n      .trans_we_i   (trans_we),\n      .trans_be_i   (trans_be),\n      .trans_wdata_i(trans_wdata),\n      .trans_atop_i (trans_atop),\n\n      .resp_valid_o(resp_valid),\n      .resp_rdata_o(resp_rdata),\n      .resp_err_o  (resp_err),  // Unused for now\n\n      .obi_req_o   (data_req_o),\n      .obi_gnt_i   (data_gnt_i),\n      .obi_addr_o  (data_addr_o),\n      .obi_we_o    (data_we_o),\n      .obi_be_o    (data_be_o),\n      .obi_wdata_o (data_wdata_o),\n      .obi_atop_o  (data_atop_o),  // Not (yet) defined in OBI 1.0 spec\n      .obi_rdata_i (data_rdata_i),\n      .obi_rvalid_i(data_r"}
{"text": "valid_i),\n      .obi_err_i   (data_err_i)  // External bus error (validity defined by obi_rvalid_i)\n  );\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Assertions\n  //////////////////////////////////////////////////////////////////////////////\n\n`ifdef CV32E40P_ASSERT_ON\n\n  // External data bus errors are not supported yet. PMP errors are not supported yet.\n  // \n  // Note: Once PMP is re-introduced please consider to make data_err_pmp_i a 'data' signal\n  // that is qualified with data_req_o && data_gnt_i (instead of suppressing data_gnt_i \n  // as is currently done. This will keep the data_req_o/data_gnt_i protocol intact.\n  //\n  // JUST RE-ENABLING the PMP VIA ITS USE_PMP LOCALPARAM WILL NOT WORK AS DATA_ERR_PMP_I \n  // NO LONGER FEEDS INTO LSU_READY_EX_O.\n\n  property p_no_error;\n    @(posedge clk) (1'b1) |-> ((data_err_i == 1'b0) && (data_err_pmp_i == 1'b0));\n  endproperty\n\n  a_no_error :\n  assert property (p_no_error);\n\n  // Check that outstanding transaction count will not overflow DEPTH\n  property p_no_transaction_count_overflow_0;\n    @(posedge clk) (1'b1) |-> (cnt_q <= DEPTH);\n  endproperty\n\n  a_no_transaction_count_overflow_0 :\n  assert property (p_no_transaction_count_overflow_0);\n\n  property p_no_transaction_count_overflow_1;\n    @(posedge clk) (cnt_q == DEPTH) |-> (!count_up || count_down);\n  endproperty\n\n  a_no_transaction_count_overflow_1 :\n  assert property (p_no_transaction_count_overflow_1);\n\n  // Check that an rvalid only occurs when there are outstanding transaction(s)\n  property p_no_spurious_rvalid;\n    @(posedge clk) (data_rvalid_i == 1'b1) |-> (cnt_q > 0);\n  endproperty\n\n  a_no_spurious_rvalid :\n  assert property (p_no_spurious_rvalid);\n\n  // Check that the address/we/be/atop does not contain X when request is sent\n  property p_address_phase_signals_defined;\n    @(posedge clk) (data_req_o == 1'b1) |-> (!($isunknown(\n        data_addr_o\n    ) || $isunknown(\n        data_we_o\n    ) || $isunknown(\n        data_be_o\n    ) || $isunknown(\n        data_atop_o\n    )));\n  endproperty\n\n  a_address_phase_signals_defined :\n  assert property (p_address_phase_signals_defined);\n\n`endif\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Matthias Baer - baermatt@student.ethz.ch                   //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Andreas Traber - atraber@student.ethz.ch                   //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    Subword multiplier and MAC                                 //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Advanced MAC unit for PULP.                                //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_mult\n  import cv32e40p_pkg::*;\n(\n    input logic clk,\n    input logic rst_n,\n\n    input logic        enable_i,\n    input mul_opcode_e operator_i,\n\n    // integer and short multiplier\n    input logic       short_subword_i,\n    input logic [1:0] short_signed_i,\n\n    input logic [31:0] op_a_i,\n    input logic [31:0] op_b_i,\n    input logic [31:0] op_c_i,\n\n    input logic [4:0] imm_i,\n\n\n    // dot multiplier\n    input logic [ 1:0] dot_signed_i,\n    input logic [31:0] dot_op_a_i,\n    input logic [31:0] dot_op_b_i,\n    input logic [31:0] dot_op_c_i,\n    input logic        is_clpx_i,\n    input logic [ 1:0] clpx_shift_i,\n    input logic        clpx_img_i,\n\n    output logic [31:0] result_o,\n\n    output logic multicycle_o,\n    output logic mulh_active_o,\n    output logic ready_o,\n    input  logic ex_ready_i\n);\n\n  ///////////////////////////////////////////////////////////////\n  //  ___ _  _ _____ ___ ___ ___ ___   __  __ _   _ _  _____   //\n  // |_ _| \\| |_   _| __/ __| __| _ \\ |  \\/  | | | | ||_   _|  //\n  //  | || .  | | | | _| (_ | _||   / | |\\/| | |_| | |__| |    //\n  // |___|_|\\_| |_| |___\\___|___|_|_\\ |_|  |_|\\___/|____|_|    //\n  //                                                           //\n  ///////////////////////////////////////////////////////////////\n\n  logic [16:0] short_op_a;\n  logic [16:0] short_op_b;\n  logic [32:0] short_op_c;\n  logic [33:0] short_mul;\n  logic [33:0] short_mac;\n  logic [31:0] short_round, short_round_tmp;\n  logic [33:0] short_result;\n\n  logic        short_mac_msb1;\n  logic        short_mac_msb0;\n\n  logic [ 4:0] short_imm;\n  logic [ 1:0] short_subword;\n  logic [ 1:0] short_signed;\n  logic        short_shift_arith;\n  logic [ 4:0] mulh_imm;\n  logic [ 1:0] mulh_subword;\n  logic [ 1:0] mulh_signed;\n  logic        mulh_shift_arith;\n  logic        mulh_carry_q;\n  logic        mulh_save;\n  logic        mulh_clearcarry;\n  logic        mulh_ready;\n\n  mult_state_e mulh_CS, mulh_NS;\n\n  // prepare the rounding value\n  assign short_round_tmp = (32'h00000001) << imm_i;\n  assign short_round = (operator_i == MUL_IR) ? {1'b0, short_round_tmp[31:1]} : '0;\n\n  // perform subword selection and sign extensions\n  assign short_op_a[15:0] = short_subword[0] ? op_a_i[31:16] : op_a_i[15:0];\n  assign short_op_b[15:0] = short_subword[1] ? op_b_i[31:16] : op_b_i[15:0];\n\n  assign short_op_a[16] = short_signed[0] & short_op_a[15];\n  assign short_op_b[16] = short_signed[1] & short_op_b[15];\n\n  assign short_op_c = mulh_active_o ? $signed({mulh_carry_q, op_c_i}) : $signed(op_c_i);\n\n  assign short_mul = $signed(short_op_a) * $signed(short_op_b);\n  assign short_mac = $signed(short_op_c) + $signed(short_mul) + $signed(short_round);\n\n  //we use only short_signed_i[0] as it cannot be short_signed_i[1] 1 and short_signed_i[0] 0\n  assign short_result = $signed(\n      {short_shift_arith & short_mac_msb1, short_shift_arith & short_mac_msb0, short_mac[31:0]}\n  ) >>> short_imm;\n\n  // choose between normal short multiplication operation and mulh operation\n  assign short_imm = mulh_active_o ? mulh_imm : imm_i;\n  assign short_subword = mulh_active_o ? mulh_subword : {2{short_subword_i}};\n  assign short_signed = mulh_active_o ? mulh_signed : short_signed_i;\n  assign short_shift_arith = mulh_active_o ? mulh_shift_arith : short_signed_i[0];\n\n  assign short_mac_msb1 = mulh_active_o ? short_mac[33] : short_mac[31];\n  assign short_mac_msb0 = mulh_active_o ? short_mac[32] : short_mac[31];\n\n\n  always_comb begin\n    mulh_NS          = mulh_CS;\n    mulh_imm         = 5'd0;\n    mulh_subword     = 2'b00;\n    mulh_signed      = 2'b00;\n    mulh_shift_arith = 1'b0;\n    mulh_ready       = 1'b0;\n    mulh_active_o    = 1'b1;\n    mulh_save        = 1'b0;\n    mulh_clearcarry  = 1'b0;\n    multicycle_o     = 1'b0;\n\n    case (mulh_CS)\n      IDLE_MULT: begin\n        mulh_active_o = 1'b0;\n        mulh_ready    = 1'b1;\n        mulh_save     = 1'b0;\n        if ((operator_i == MUL_H) && enable_i) begin\n          mulh_ready = 1'b0;\n          mulh_NS    = STEP0;\n        end\n      end\n\n      STEP0: begin\n        multicycle_o  = 1'b1;\n        mulh_imm      = 5'd16;\n        mulh_active_o = 1'b1;\n        //AL*BL never overflows\n        mulh_save     = 1'b0;\n        mulh_NS       = STEP1;\n        //Here always a 32'b unsigned result (no carry)\n      end\n\n      STEP1: begin\n        multicycle_o     = 1'b1;\n        //AL*BH is signed iff B is signed\n        mulh_signed      = {short_signed_i[1], 1'b0};\n        mulh_subword     = 2'b10;\n        mulh_save        = 1'b1;\n        mulh_shift_arith = 1'b1;\n        mulh_NS          = STEP2;\n        //Here signed 32'b + unsigned 32'b result.\n        //Result is a signed 33'b\n        //Store the carry as it will be used as sign extension, we do\n        //not shift\n      end\n\n      STEP2: begin\n        multicycle_o     = 1'b1;\n        //AH*BL is signed iff A is signed\n        mulh_signed      = {1'b0, short_signed_i[0]};\n        mulh_subword     = 2'b01;\n        mulh_imm         = 5'd16;\n        mulh_save        = 1'b1;\n        mulh_clearcarry  = 1'b1;\n        mulh_shift_arith = 1'b1;\n        mulh_NS          = FINISH;\n        //Here signed 32'b + signed 33'b result.\n        //Result is a signed 34'b\n        //We do not store the carries as the bits 34:33 are shifted back, so we clear it\n      end\n\n      FINISH: begin\n        mulh_signed  = short_signed_i;\n        mulh_subword = 2'b11;\n        mulh_ready   = 1'b1;\n        if (ex_ready_i) mulh_NS = IDLE_MULT;\n      end\n    endcase\n  end\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (~rst_n) begin\n      mulh_CS      <= IDLE_MULT;\n      mulh_carry_q <= 1'b0;\n    end else begin\n      mulh_CS <= mulh_NS;\n\n      if (mulh_save) mulh_carry_q <= ~mulh_clearcarry & short_mac[32];\n      else if (ex_ready_i)  // clear carry when we are going to the next instruction\n        mulh_carry_q <= 1'b0;\n    end\n  end\n\n  // 32x32 = 32-bit multiplier\n  logic [31:0] int_op_a_msu;\n  logic [31:0] int_op_b_msu;\n  logic [31:0] int_result;\n\n  logic        int_is_msu;\n\n  assign int_is_msu = (operator_i == MUL_MSU32);\n\n  assign int_op_a_msu = op_a_i ^ {32{int_is_msu}};\n  assign int_op_b_msu = op_b_i & {32{int_is_msu}};\n\n  assign int_result = $signed(\n      op_c_i\n  ) + $signed(\n      int_op_b_msu\n  ) + $signed(\n      int_op_a_msu\n  ) * $signed(\n      op_b_i\n  );\n\n  ///////////////////////////////////////////////\n  //  ___   ___ _____   __  __ _   _ _  _____  //\n  // |   \\ / _ \\_   _| |  \\/  | | | | ||_   _| //\n  // | |) | (_) || |   | |\\/| | |_| | |__| |   //\n  // |___/ \\___/ |_|   |_|  |_|\\___/|____|_|   //\n  //                                           //\n  ///////////////////////////////////////////////\n\n  logic [31:0] dot_char_result;\n  logic [32:0] dot_short_result;\n  logic [31:0] accumulator;\n  logic [15:0] clpx_shift_result;\n  logic [3:0][8:0] dot_char_op_a;\n  logic [3:0][8:0] dot_char_op_b;\n  logic [3:0][17:0] dot_char_mul;\n\n  logic [1:0][16:0] dot_short_op_a;\n  logic [1:0][16:0] dot_short_op_b;\n  logic [1:0][33:0] dot_short_mul;\n  logic      [16:0] dot_short_op_a_1_neg; //to compute -rA[31:16]*rB[31:16] -> (!rA[31:16] + 1)*rB[31:16] = !rA[31:16]*rB[31:16] + rB[31:16]\n  logic [31:0] dot_short_op_b_ext;\n\n  assign dot_char_op_a[0] = {dot_signed_i[1] & dot_op_a_i[7], dot_op_a_i[7:0]};\n  assign dot_char_op_a[1] = {dot_signed_i[1] & dot_op_a_i[15], dot_op_a_i[15:8]};\n  assign dot_char_op_a[2] = {dot_signed_i[1] & dot_op_a_i[23], dot_op_a_i[23:16]};\n  assign dot_char_op_a[3] = {dot_signed_i[1] & dot_op_a_i[31], dot_op_a_i[31:24]};\n\n  assign dot_char_op_b[0] = {dot_signed_i[0] & dot_op_b_i[7], dot_op_b_i[7:0]};\n  assign dot_char_op_b[1] = {dot_signed_i[0] & dot_op_b_i[15], dot_op_b_i[15:8]};\n  assign dot_char_op_b[2] = {dot_signed_i[0] & dot_op_b_i[23], dot_op_b_i[23:16]};\n  assign dot_char_op_b[3] = {dot_signed_i[0] & dot_op_b_i[31], dot_op_b_i[31:24]};\n\n  assign dot_char_mul[0] = $signed(dot_char_op_a[0]) * $signed(dot_char_op_b[0]);\n  assign dot_char_mul[1] = $signed(dot_char_op_a[1]) * $signed(dot_char_op_b[1]);\n  assign dot_char_mul[2] = $signed(dot_char_op_a[2]) * $signed(dot_char_op_b[2]);\n  assign dot_char_mul[3] = $signed(dot_char_op_a[3]) * $signed(dot_char_op_b[3]);\n\n  assign dot_char_result = $signed(\n      dot_char_mul[0]\n  ) + $signed(\n      dot_char_mul[1]\n  ) + $signed(\n      dot_char_mul[2]\n  ) + $signed(\n      dot_char_mul[3]\n  ) + $signed(\n      dot_op_c_i\n  );\n\n\n  assign dot_short_op_a[0] = {dot_signed_i[1] & dot_op_a_i[15], dot_op_a_i[15:0]};\n  assign dot_short_op_a[1] = {dot_signed_i[1] & dot_op_a_i[31], dot_op_a_i[31:16]};\n  assign dot_short_op_a_1_neg = dot_short_op_a[1] ^ {17{(is_clpx_i & ~clpx_img_i)}}; //negates whether clpx_img_i is 0 or 1, only REAL PART needs to be negated\n\n  assign dot_short_op_b[0] = (is_clpx_i & clpx_img_i) ? {\n    dot_signed_i[0] & dot_op_b_i[31], dot_op_b_i[31:16]\n  } : {\n    dot_signed_i[0] & dot_op_b_i[15], dot_op_b_i[15:0]\n  };\n  assign dot_short_op_b[1] = (is_clpx_i & clpx_img_i) ? {\n    dot_signed_i[0] & dot_op_b_i[15], dot_op_b_i[15:0]\n  } : {\n    dot_signed_i[0] & dot_op_b_i[31], dot_op_b_i[31:16]\n  };\n\n  assign dot_short_mul[0] = $signed(dot_short_op_a[0]) * $signed(dot_short_op_b[0]);\n  assign dot_short_mul[1] = $signed(dot_short_op_a_1_neg) * $signed(dot_short_op_b[1]);\n\n  assign dot_short_op_b_ext = $signed(dot_short_op_b[1]);\n  assign accumulator = is_clpx_i ? dot_short_op_b_ext & {32{~clpx_img_i}} : $signed(dot_op_c_i);\n\n  assign dot_short_result = $signed(\n      dot_short_mul[0][31:0]\n  ) + $signed(\n      dot_short_mul[1][31:0]\n  ) + $signed(\n      accumulator\n  );\n  assign clpx_shift_result = $signed(dot_short_result[31:15]) >>> clpx_shift_i;\n\n  ////////////////////////////////////////////////////////\n  //   ____                 _ _     __  __              //\n  //  |  _ \\ ___  ___ _   _| | |_  |  \\/  |_   ___  __  //\n  //  | |_) / _ \\/ __| | | | | __| | |\\/| | | | \\ \\/ /  //\n  //  |  _ <  __/\\__ \\ |_| | | |_  | |  | | |_| |>  <   //\n  //  |_| \\_\\___||___/\\__,_|_|\\__| |_|  |_|\\__,_/_/\\_\\  //\n  //                                                    //\n  ////////////////////////////////////////////////////////\n\n  always_comb begin\n    result_o = '0;\n\n    unique case (operator_i)\n      MUL_MAC32, MUL_MSU32: result_o = int_result[31:0];\n\n      MUL_I, MUL_IR, MUL_H: result_o = short_result[31:0];\n\n      MUL_DOT8: result_o = dot_char_result[31:0];\n      MUL_DOT16: begin\n        if (is_clpx_i) begin\n          if (clpx_img_i) begin\n            result_o[31:16] = clpx_shift_result;\n            result_o[15:0]  = dot_op_c_i[15:0];\n          end else begin\n            result_o[15:0]  = clpx_shift_result;\n            result_o[31:16] = dot_op_c_i[31:16];\n          end\n        end else begin\n          result_o = dot_short_result[31:0];\n        end\n      end\n\n      default: ;  // default case to suppress unique warning\n    endcase\n  end\n\n  assign ready_o = mulh_ready;\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n\n  // check multiplication result for mulh\n`ifdef CV32E40P_ASSERT_ON\n  assert property (\n    @(posedge clk) ((mulh_CS == FINISH) && (operator_i == MUL_H) && (short_signed_i == 2'b11))\n    |->\n    (result_o == (($signed(\n      {{32{op_a_i[31]}}, op_a_i}\n  ) * $signed(\n      {{32{op_b_i[31]}}, op_b_i}\n  )) >>> 32)));\n\n  // check multiplication result for mulhsu\n  assert property (\n    @(posedge clk) ((mulh_CS == FINISH) && (operator_i == MUL_H) && (short_signed_i == 2'b01))\n    |->\n    (result_o == (($signed(\n      {{32{op_a_i[31]}}, op_a_i}\n  ) * {\n    32'b0, op_b_i\n  }) >> 32)));\n\n  // check multiplication result for mulhu\n  assert property (\n    @(posedge clk) ((mulh_CS == FINISH) && (operator_i == MUL_H) && (short_signed_i == 2'b00))\n    |->\n    (result_o == (({\n    32'b0, op_a_i\n  } * {\n    32'b0, op_b_i\n  }) >> 32)));\n`endif\nendmodule\n"}
{"text": "// Copyright 2020 Silicon Labs, Inc.\n//\n// This file, and derivatives thereof are licensed under the\n// Solderpad License, Version 2.0 (the \"License\").\n//\n// Use of this file means you agree to the terms and conditions\n// of the license and are in full compliance with the License.\n//\n// You may obtain a copy of the License at:\n//\n//     https://solderpad.org/licenses/SHL-2.0/\n//\n// Unless required by applicable law or agreed to in writing, software\n// and hardware implementations thereof distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n// OF ANY KIND, EITHER EXPRESSED OR IMPLIED.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Arjan Bink - arjan.bink@silabs.com                         //\n//                                                                            //\n// Design Name:    OBI (Open Bus Interface)                                   //\n// Project Name:   CV32E40P                                                   //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Open Bus Interface adapter. Translates transaction request //\n//                 on the trans_* interface into an OBI A channel transfer.   //\n//                 The OBI R channel transfer translated (i.e. passed on) as  //\n//                 a transaction response on the resp_* interface.            //\n//                                                                            //\n//                 This adapter does not limit the number of outstanding      //\n//                 OBI transactions in any way.                               //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_obi_interface #(\n    parameter TRANS_STABLE =  0                   // Are trans_addr_i, trans_we_i, trans_be_i, trans_wdata_i, trans_atop_i signals stable during a non-accepted transaction?\n) (\n    input logic clk,\n    input logic rst_n,\n\n    // Transaction request interface\n    input logic trans_valid_i,\n    output logic trans_ready_o,\n    input logic [31:0] trans_addr_i,\n    input logic trans_we_i,\n    input logic [3:0] trans_be_i,\n    input logic [31:0] trans_wdata_i,\n    input  logic  [5:0] trans_atop_i,             // Future proof addition (not part of OBI 1.0 spec; not used in CV32E40P)\n\n    // Transaction response interface\n    output logic resp_valid_o,  // Note: Consumer is assumed to be 'ready' whenever resp_valid_o = 1\n    output logic [31:0] resp_rdata_o,\n    output logic resp_err_o,\n\n    // OBI interface\n    output logic        obi_req_o,\n    input  logic        obi_gnt_i,\n    output logic [31:0] obi_addr_o,\n    output logic        obi_we_o,\n    output logic [ 3:0] obi_be_o,\n    output logic [31:0] obi_wdata_o,\n    output logic [ 5:0] obi_atop_o,\n    input  logic [31:0] obi_rdata_i,\n    input  logic        obi_rvalid_i,\n    input  logic        obi_err_i\n);\n\n  enum logic {\n    TRANSPARENT,\n    REGISTERED\n  }\n      state_q, next_state;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // OBI R Channel\n  //////////////////////////////////////////////////////////////////////////////\n\n  // The OBI R channel signals are passed on directly on the transaction response\n  // interface (resp_*). It is assumed that the consumer of the transaction response\n  // is always receptive when resp_valid_o = 1 (otherwise a response would get dropped)\n\n  assign resp_valid_o = obi_rvalid_i;\n  assign resp_rdata_o = obi_rdata_i;\n  assign resp_err_o   = obi_err_i;\n\n\n  //////////////////////////////////////////////////////////////////////////////\n  // OBI A Channel\n  //////////////////////////////////////////////////////////////////////////////\n\n  generate\n    if (TRANS_STABLE) begin : gen_trans_stable\n\n      // If the incoming transaction itself is stable, then it satisfies the OBI protocol\n      // and signals can be passed to/from OBI directly.\n      assign obi_req_o     = trans_valid_i;\n      assign obi_addr_o    = trans_addr_i;\n      assign obi_we_o      = trans_we_i;\n      assign obi_be_o      = trans_be_i;\n      assign obi_wdata_o   = trans_wdata_i;\n      assign obi_atop_o    = trans_atop_i;\n\n      assign trans_ready_o = obi_gnt_i;\n\n      // FSM not used\n      assign state_q       = TRANSPARENT;\n      assign next_state    = TRANSPARENT;\n    end else begin : gen_no_trans_stable\n\n      // OBI A channel registers (to keep A channel stable)\n      logic [31:0] obi_addr_q;\n      logic        obi_we_q;\n      logic [ 3:0] obi_be_q;\n      logic [31:0] obi_wdata_q;\n      logic [ 5:0] obi_atop_q;\n\n      // If the incoming transaction itself is not stable; use an FSM to make sure that\n      // the OBI address phase signals are kept stable during non-granted requests.\n\n      //////////////////////////////////////////////////////////////////////////////\n      // OBI FSM\n      //////////////////////////////////////////////////////////////////////////////\n\n      // FSM (state_q, next_state) to control OBI A channel signals.\n\n      always_comb begin\n        next_state = state_q;\n\n        case (state_q)\n\n          // Default (transparent) state. Transaction requests are passed directly onto the OBI A channel.\n          TRANSPARENT: begin\n            if (obi_req_o && !obi_gnt_i) begin\n              // OBI request not immediately granted. Move to REGISTERED state such that OBI address phase\n              // signals can be kept stable while the transaction request (trans_*) can possibly change.\n              next_state = REGISTERED;\n            end\n          end  // case: TRANSPARENT\n\n          // Registered state. OBI address phase signals are kept stable (driven from registers).\n          REGISTERED: begin\n            if (obi_gnt_i) begin\n              // Received grant. Move back to TRANSPARENT state such that next transaction request can be passed on.\n              next_state = TRANSPARENT;\n            end\n          end  // case: REGISTERED\n\n        endcase\n      end\n\n      always_comb begin\n        if (state_q == TRANSPARENT) begin\n          obi_req_o   = trans_valid_i;  // Do not limit number of outstanding transactions\n          obi_addr_o  = trans_addr_i;\n          obi_we_o    = trans_we_i;\n          obi_be_o    = trans_be_i;\n          obi_wdata_o = trans_wdata_i;\n          obi_atop_o  = trans_atop_i;\n        end else begin\n          // state_q == REGISTERED\n          obi_req_o   = 1'b1;  // Never retract request\n          obi_addr_o  = obi_addr_q;\n          obi_we_o    = obi_we_q;\n          obi_be_o    = obi_be_q;\n          obi_wdata_o = obi_wdata_q;\n          obi_atop_o  = obi_atop_q;\n        end\n      end\n\n      //////////////////////////////////////////////////////////////////////////////\n      // Registers\n      //////////////////////////////////////////////////////////////////////////////\n\n      always_ff @(posedge clk, negedge rst_n) begin\n        if (rst_n == 1'b0) begin\n          state_q     <= TRANSPARENT;\n          obi_addr_q  <= 32'b0;\n          obi_we_q    <= 1'b0;\n          obi_be_q    <= 4'b0;\n          obi_wdata_q <= 32'b0;\n          obi_atop_q  <= 6'b0;\n        end else begin\n          state_q <= next_state;\n          if ((state_q == TRANSPARENT) && (next_state == REGISTERED)) begin\n            // Keep OBI A channel signals stable throughout REGISTERED state\n            obi_addr_q  <= obi_addr_o;\n            obi_we_q    <= obi_we_o;\n            obi_be_q    <= obi_be_o;\n            obi_wdata_q <= obi_wdata_o;\n            obi_atop_q  <= obi_atop_o;\n          end\n        end\n      end\n\n      // Always ready to accept a new transfer requests when previous A channel\n      // transfer has been granted. Note that cv32e40p_obi_interface does not limit\n      // the number of outstanding transactions in any way.\n      assign trans_ready_o = (state_q == TRANSPARENT);\n\n    end\n  endgenerate\n\nendmodule  // cv32e40p_obi_interface\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Andreas Traber - atraber@student.ethz.ch                   //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    cv32e40p_popcnt                                               //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Count the number of '1's in a word                         //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_popcnt (\n    input  logic [31:0] in_i,\n    output logic [ 5:0] result_o\n);\n\n  logic [15:0][1:0] cnt_l1;\n  logic [ 7:0][2:0] cnt_l2;\n  logic [ 3:0][3:0] cnt_l3;\n  logic [ 1:0][4:0] cnt_l4;\n\n  genvar l, m, n, p;\n  generate\n    for (l = 0; l < 16; l++) begin : gen_cnt_l1\n      assign cnt_l1[l] = {1'b0, in_i[2*l]} + {1'b0, in_i[2*l+1]};\n    end\n  endgenerate\n\n  generate\n    for (m = 0; m < 8; m++) begin : gen_cnt_l2\n      assign cnt_l2[m] = {1'b0, cnt_l1[2*m]} + {1'b0, cnt_l1[2*m+1]};\n    end\n  endgenerate\n\n  generate\n    for (n = 0; n < 4; n++) begin : gen_cnt_l3\n      assign cnt_l3[n] = {1'b0, cnt_l2[2*n]} + {1'b0, cnt_l2[2*n+1]};\n    end\n  endgenerate\n\n  generate\n    for (p = 0; p < 2; p++) begin : gen_cnt_l4\n      assign cnt_l4[p] = {1'b0, cnt_l3[2*p]} + {1'b0, cnt_l3[2*p+1]};\n    end\n  endgenerate\n\n  assign result_o = {1'b0, cnt_l4[0]} + {1'b0, cnt_l4[1]};\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Andreas Traber - atraber@iis.ee.ethz.ch                    //\n//                                                                            //\n// Design Name:    Prefetcher Buffer for 32 bit memory interface              //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Prefetch Buffer that caches instructions. This cuts overly //\n//                 long critical paths to the instruction cache               //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\n// input port: send address one cycle before the data\n// clear_i clears the FIFO for the following cycle. in_addr_i can be sent in\n// this cycle already\n\nmodule cv32e40p_prefetch_buffer #(\n    parameter PULP_OBI = 0,  // Legacy PULP OBI behavior\n    parameter COREV_PULP = 1  // PULP ISA Extension (including PULP specific CSRs and hardware loop, excluding p.elw)\n) (\n    input logic clk,\n    input logic rst_n,\n\n    input logic        req_i,\n    input logic        branch_i,\n    input logic [31:0] branch_addr_i,\n\n    input logic        hwlp_jump_i,\n    input logic [31:0] hwlp_target_i,\n\n    input  logic        fetch_ready_i,\n    output logic        fetch_valid_o,\n    output logic [31:0] fetch_rdata_o,\n\n    // goes to instruction memory / instruction cache\n    output logic        instr_req_o,\n    input  logic        instr_gnt_i,\n    output logic [31:0] instr_addr_o,\n    input  logic [31:0] instr_rdata_i,\n    input  logic        instr_rvalid_i,\n    input  logic        instr_err_i,  // Not used yet (future addition)\n    input  logic        instr_err_pmp_i,  // Not used yet (future addition)\n\n    // Prefetch Buffer Status\n    output logic busy_o\n);\n  // FIFO_DEPTH controls also the number of outstanding memory requests\n  // FIFO_DEPTH must be greater than 1 to respect assertion in prefetch controller\n  // FIFO_DEPTH must be a power of 2 (because of the FIFO implementation)\n  localparam FIFO_DEPTH                     = 2; //must be greater or equal to 2 //Set at least to 3 to avoid stalls compared to the master branch\n  localparam int unsigned FIFO_ADDR_DEPTH = $clog2(FIFO_DEPTH);\n\n  // Transaction request (between cv32e40p_prefetch_controller and cv32e40p_obi_interface)\n  logic                     trans_valid;\n  logic                     trans_ready;\n  logic [             31:0] trans_addr;\n\n  logic                     fifo_flush;\n  logic                     fifo_flush_but_first;\n  logic [FIFO_ADDR_DEPTH:0] fifo_cnt;  // fifo_cnt should count from 0 to FIFO_DEPTH!\n\n  logic [             31:0] fifo_rdata;\n  logic                     fifo_push;\n  logic                     fifo_pop;\n  logic                     fifo_empty;\n\n  // Transaction response interface (between cv32e40p_obi_interface and cv32e40p_fetch_fifo)\n  logic                     resp_valid;\n  logic [             31:0] resp_rdata;\n  logic                     resp_err;  // Unused for now\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Prefetch Controller\n  //////////////////////////////////////////////////////////////////////////////\n\n  cv32e40p_prefetch_controller #(\n      .DEPTH     (FIFO_DEPTH),\n      .PULP_OBI  (PULP_OBI),\n      .COREV_PULP(COREV_PULP)\n  ) prefetch_controller_i (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      .req_i        (req_i),\n      .branch_i     (branch_i),\n      .branch_addr_i(branch_addr_i),\n      .busy_o       (busy_o),\n\n      .hwlp_jump_i  (hwlp_jump_i),\n      .hwlp_target_i(hwlp_target_i),\n\n      .trans_valid_o(trans_valid),\n      .trans_ready_i(trans_ready),\n      .trans_addr_o (trans_addr),\n\n      .resp_valid_i(resp_valid),\n\n      .fetch_ready_i(fetch_ready_i),\n      .fetch_valid_o(fetch_valid_o),\n\n      .fifo_push_o           (fifo_push),\n      .fifo_pop_o            (fifo_pop),\n      .fifo_flush_o          (fifo_flush),\n      .fifo_flush_but_first_o(fifo_flush_but_first),\n      .fifo_cnt_i            (fifo_cnt),\n      .fifo_empty_i          (fifo_empty)\n  );\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Fetch FIFO && fall-through path\n  //////////////////////////////////////////////////////////////////////////////\n\n  cv32e40p_fifo #(\n      .FALL_THROUGH(1'b0),\n      .DATA_WIDTH  (32),\n      .DEPTH       (FIFO_DEPTH)\n  ) fifo_i (\n      .clk_i            (clk),\n      .rst_ni           (rst_n),\n      .flush_i          (fifo_flush),\n      .flush_but_first_i(fifo_flush_but_first),\n      .testmode_i       (1'b0),\n      .full_o           (),\n      .empty_o          (fifo_empty),\n      .cnt_o            (fifo_cnt),\n      .data_i           (resp_rdata),\n      .push_i           (fifo_push),\n      .data_o           (fifo_rdata),\n      .pop_i            (fifo_pop)\n  );\n\n  // First POP from the FIFO if it is not empty.\n  // Otherwise, try to fall-through it.\n  assign fetch_rdata_o = fifo_empty ? resp_rdata : fifo_rdata;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // OBI interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  cv32e40p_obi_interface #(\n      .TRANS_STABLE(0)  // trans_* is NOT guaranteed stable during waited transfers;\n      // this is ignored for legacy PULP behavior (not compliant to OBI)\n  )                                                     // Keep this parameter stuck to 0 to make HWLP work\n\n  instruction_obi_i\n  (\n      .clk  (clk),\n      .rst_n(rst_n),\n\n      .trans_valid_i(trans_valid),\n      .trans_ready_o(trans_ready),\n      .trans_addr_i ({trans_addr[31:2], 2'b00}),\n      .trans_we_i   (1'b0),  // Instruction interface (never write)\n      .trans_be_i   (4'b1111),  // Corresponding obi_be_o not used\n      .trans_wdata_i(32'b0),  // Corresponding obi_wdata_o not used\n      .trans_atop_i (6'b0),  // Atomics not used on instruction bus\n\n      .resp_valid_o(resp_valid),\n      .resp_rdata_o(resp_rdata),\n      .resp_err_o  (resp_err),  // Unused for now\n\n      .obi_req_o   (instr_req_o),\n      .obi_gnt_i   (instr_gnt_i),\n      .obi_addr_o  (instr_addr_o),\n      .obi_we_o    (),  // Left unconnected on purpose\n      .obi_be_o    (),  // Left unconnected on purpose\n      .obi_wdata_o (),  // Left unconnected on purpose\n      .obi_atop_o  (),  // Left unconnected on purpose\n      .obi_rdata_i (instr_rdata_i),\n      .obi_rvalid_i(instr_rvalid_i),\n      .obi_err_i   (instr_err_i)\n  );\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n\n`ifdef CV32E40P_ASSERT_ON\n\n  // FIFO_DEPTH must be greater than 1. Otherwise, the property\n  // p_hwlp_end_already_gnt_when_hwlp_branch in cv32e40p_prefetch_controller\n  // is not verified, since the prefetcher cannot ask for HWLP_END the cycle\n  // in which HWLP_END-4 is being absorbed by ID.\n  property p_fifo_depth_gt_1;\n    @(posedge clk) (FIFO_DEPTH > 1);\n  endproperty\n\n  a_fifo_depth_gt_1 :\n  assert property (p_fifo_depth_gt_1);\n\n  // Check that branch target address is half-word aligned (RV32-C)\n  property p_branch_halfword_aligned;\n    @(posedge clk) (branch_i) |-> (branch_addr_i[0] == 1'b0);\n  endproperty\n\n  a_branch_halfword_aligned :\n  assert property (p_branch_halfword_aligned);\n\n  // Check that bus interface transactions are word aligned\n  property p_instr_addr_word_aligned;\n    @(posedge clk) (1'b1) |-> (instr_addr_o[1:0] == 2'b00);\n  endproperty\n\n  a_instr_addr_word_aligned :\n  assert property (p_instr_addr_word_aligned);\n\n  // Check that a taken branch can only occur if fetching is requested\n  property p_branch_implies_req;\n    @(posedge clk) (branch_i) |-> (req_i);\n  endproperty\n\n  a_branch_implies_req :\n  assert property (p_branch_implies_req);\n\n  // Check that after a taken branch the initial FIFO output is not accepted\n  property p_branch_invalidates_fifo;\n    @(posedge clk) (branch_i) |-> (!(fetch_valid_o && fetch_ready_i));\n  endproperty\n\n  a_branch_invalidates_fifo :\n  assert property (p_branch_invalidates_fifo);\n\n  // External instruction bus errors are not supported yet. PMP errors are not supported yet.\n  //\n  // Note: Once PMP is re-introduced please consider to make instr_err_pmp_i a 'data' signal\n  // that is qualified with instr_req_o && instr_gnt_i (instead of suppressing instr_gnt_i\n  // as is currently done. This will keep the instr_req_o/instr_gnt_i protocol intact.\n  //\n  // JUST RE-ENABLING the PMP VIA ITS USE_PMP LOCALPARAM WILL NOT WORK BECAUSE OF THE\n  // GRANT SUPPRESSION IN THE PMP.\n\n  property p_no_error;\n    @(posedge clk) (1'b1) |-> ((instr_err_i == 1'b0) && (instr_err_pmp_i == 1'b0));\n  endproperty\n\n  a_no_error :\n  assert property (p_no_error);\n\n\n\n\n`endif\n\nendmodule  // cv32e40p_prefetch_buffer\n"}
{"text": "// Copyright 2020 Silicon Labs, Inc.\n//\n// This file, and derivatives thereof are licensed under the\n// Solderpad License, Version 2.0 (the \"License\").\n//\n// Use of this file means you agree to the terms and conditions\n// of the license and are in full compliance with the License.\n//\n// You may obtain a copy of the License at:\n//\n//     https://solderpad.org/licenses/SHL-2.0/\n//\n// Unless required by applicable law or agreed to in writing, software\n// and hardware implementations thereof distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n// OF ANY KIND, EITHER EXPRESSED OR IMPLIED.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Arjan Bink - arjan.bink@silabs.com                         //\n//                                                                            //\n// Design Name:    Prefetcher Controller                                      //\n// Project Name:   CV32E40P                                                   //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Prefetch Controller which receives control flow            //\n//                 information (req_i, branch_*) from the Fetch stage         //\n//                 and based on that performs transactions requests to the    //\n//                 bus interface adapter instructions. Prefetching based on   //\n//                 incrementing addressed is performed when no new control    //\n//                 flow change is requested. New transaction requests are     //\n//                 only performed if it can be guaranteed that the fetch FIFO //\n//                 will not overflow (resulting in a maximum of DEPTH         //\n//                 outstanding transactions.                                  //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_prefetch_controller #(\n    parameter PULP_OBI = 0,  // Legacy PULP OBI behavior\n    parameter COREV_PULP = 1,  // PULP ISA Extension (including PULP specific CSRs and hardware loop, excluding cv.elw)\n    parameter DEPTH = 4,  // Prefetch FIFO Depth\n    parameter FIFO_ADDR_DEPTH = (DEPTH > 1) ? $clog2(DEPTH) : 1  // Do not override this parameter\n) (\n    input logic clk,\n    input logic rst_n,\n\n    // Fetch stage interface\n    input  logic        req_i,  // Fetch stage requests instructions\n    input  logic        branch_i,  // Taken branch\n    input  logic [31:0] branch_addr_i,  // Taken branch address (only valid when branch_i = 1)\n    output logic        busy_o,  // Prefetcher busy\n\n    // HW loop signals\n    input logic        hwlp_jump_i,\n    input logic [31:0] hwlp_target_i,\n\n    // Transaction request interface\n    output logic trans_valid_o,  // Transaction request valid (to bus interface adapter)\n    input  logic                     trans_ready_i,           // Transaction request ready (transaction gets accepted when trans_valid_o and trans_ready_i are both 1)\n    output logic [31:0]              trans_addr_o,            // Transaction address (only valid when trans_valid_o = 1). No stability requirements.\n\n    // Transaction response interface\n    input logic resp_valid_i,  // Note: Consumer is assumed to be 'ready' whenever resp_valid_i = 1\n\n    // Fetch interface is ready/valid\n    input  logic fetch_ready_i,\n    output logic fetch_valid_o,\n\n    // FIFO interface\n    output logic fifo_push_o,  // PUSH an instruction into the FIFO\n    output logic fifo_pop_o,  // POP an instruction from the FIFO\n    output logic fifo_flush_o,  // Flush the FIFO\n    output logic                     fifo_flush_but_first_o,  // Flush the FIFO, but keep the first instruction if present\n    input logic [FIFO_ADDR_DEPTH:0] fifo_cnt_i,  // Number of valid items/words in the prefetch FIFO\n    input logic fifo_empty_i  // FIFO is empty\n);\n\n  import cv32e40p_pkg::*;\n\n  prefetch_state_e state_q, next_state;\n\n  logic [FIFO_ADDR_DEPTH:0] cnt_q;  // Transaction counter\n  logic [FIFO_ADDR_DEPTH:0] next_cnt;  // Next value for cnt_q\n  logic                          count_up;                        // Increment outstanding transaction count by 1 (can happen at same time as count_down)\n  logic                          count_down;                      // Decrement outstanding transaction count by 1 (can happen at same time as count_up)\n\n  logic  [FIFO_ADDR_DEPTH:0]     flush_cnt_q;                     // Response flush counter (to flush speculative responses after branch)\n  logic [FIFO_ADDR_DEPTH:0] next_flush_cnt;  // Next value for flush_cnt_q\n\n  // Transaction address\n  logic [31:0] trans_addr_q, trans_addr_incr;\n\n  // Word-aligned branch target address\n  logic [31:0] aligned_branch_addr;  // Word aligned branch target address\n\n  // FIFO auxiliary signal\n  logic fifo_valid;  // FIFO output valid (if !fifo_empty)\n  logic [FIFO_ADDR_DEPTH:0]      fifo_cnt_masked;                 // FIFO_cnt signal, masked when we are branching to allow a new memory request in that cycle\n\n  // HW loop support signals\n  logic hwlp_wait_resp_flush;  // Trigger for the delayed flush\n  logic hwlp_flush_after_resp;  // Wait for HWLP_END and then flush the wrong granted requests\n  logic [FIFO_ADDR_DEPTH:0]      hwlp_flush_cnt_delayed_q;        // The number of outstanding requests to flush when HWLP_END is returned\n  logic hwlp_flush_resp_delayed;  // Actual delayed flush\n  logic hwlp_flush_resp;  // Response flush counter when hwlp occurs\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Prefetch buffer status\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Busy if there are ongoing (or potentially outstanding) transfers\n  assign busy_o = (cnt_q != 3'b000) || trans_valid_o;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // IF/ID interface\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Fectch valid control. Fetch never valid if jumping or flushing responses.\n  // Fetch valid if there are instructions in FIFO or there is an incoming\n  // instruction from memory.\n  assign fetch_valid_o = (fifo_valid || resp_valid_i) && !(branch_i || (flush_cnt_q > 0));\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Transaction request generation\n  //\n  // Assumes that corresponding response is at least 1 cycle after request\n  //\n  // - Only request transaction when fetch stage requires fetch (req_i), and\n  // - make sure that FIFO (cv32e40p_fetch_fifo) never overflows (fifo_cnt_i + cnt_q < DEPTH)\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Prefetcher will only perform word fetches\n  assign aligned_branch_addr = {branch_addr_i[31:2], 2'b00};\n\n  // Increment address (always word fetch)\n  assign trans_addr_incr = {trans_addr_q[31:2], 2'b00} + 32'd4;\n\n  // Transaction request generation\n  generate\n    if (PULP_OBI == 0) begin : gen_no_pulp_obi\n      // OBI compatible (avoids combinatorial path from instr_rvalid_i to instr_req_o).\n      // Multiple trans_* transactions can be issued (and accepted) before a response\n      // (resp_*) is received.\n      assign trans_valid_o = req_i && (fifo_cnt_masked + cnt_q < DEPTH);\n    end else begin : gen_pulp_obi\n      // Legacy PULP OBI behavior, i.e. only issue subsequent transaction if preceding transfer\n      // is about to finish (re-introducing timing critical path from instr_rvalid_i to instr_req_o)\n      assign trans_valid_o = (cnt_q == 3'b000) ? req_i && (fifo_cnt_masked + cnt_q < DEPTH) :\n                                                 req_i && (fifo_cnt_masked + cnt_q < DEPTH) && resp_valid_i;\n    end\n  endgenerate\n\n  // Optimization:\n  // fifo_cnt is used to understand if we can perform new memory requests\n  // When branching, we flush both the FIFO and the outstanding requests. Therefore,\n  // there is surely space for a new request.\n  // Masking fifo_cnt in this case allows for making a new request when the FIFO\n  // is not empty and we are jumping, and (fifo_cnt_i + cnt_q == DEPTH)\n  assign fifo_cnt_masked = (branch_i || hwlp_jump_i) ? '0 : fifo_cnt_i;\n\n  // FSM (state_q, next_state) to control OBI A channel signals.\n  always_comb begin\n    next_state   = state_q;\n    trans_addr_o = trans_addr_q;\n\n    case (state_q)\n      // Default state (pass on branch target address or transaction with incremented address)\n      IDLE: begin\n        begin\n          if (branch_i) begin\n            // Jumps must have the highest priority (e.g. an interrupt must\n            // have higher priority than a HW-loop branch)\n            trans_addr_o = aligned_branch_addr;\n          end else if (hwlp_jump_i) begin\n            trans_addr_o = hwlp_target_i;\n          end else begin\n            trans_addr_o = trans_addr_incr;\n          end\n        end\n        if ((branch_i || hwlp_jump_i) && !(trans_valid_o && trans_ready_i)) begin\n          // Taken branch, but transaction not yet accepted by bus interface adapter.\n          next_state = BRANCH_WAIT;\n        end\n      end  // case: IDLE\n\n      BRANCH_WAIT: begin\n        // Replay previous branch target address (trans_addr_q) or new branch address (this can\n        // occur if for example an interrupt is taken right after a taken jump which did not\n        // yet have its target address accepted by the bus interface adapter.\n        trans_addr_o = branch_i ? aligned_branch_addr : trans_addr_q;\n        if (trans_valid_o && trans_ready_i) begin\n          // Transaction with branch target address has been accepted. Start regular prefetch again.\n          next_state = IDLE;\n        end\n      end  // case: BRANCH_WAIT\n    endcase\n  end\n\n  //////////////////////////////////////////////////////////////////////////////\n  // FIFO management\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Pass on response transfer directly to FIFO (which should be ready, otherwise\n  // the corresponding transfer would not have been requested via trans_valid_o).\n  // Upon a branch (branch_i) all incoming responses (resp_valid_i) are flushed\n  // until the flush count is 0 again. (The flush count is initialized with the\n  // number of outstanding transactions at the time of the branch).\n  assign fifo_valid = !fifo_empty_i;\n  assign fifo_push_o = resp_valid_i && (fifo_valid || !fetch_ready_i) && !(branch_i || (flush_cnt_q > 0));\n  assign fifo_pop_o = fifo_valid && fetch_ready_i;\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Counter (cnt_q, next_cnt) to count number of outstanding OBI transactions\n  // (maximum = DEPTH)\n  //\n  // Counter overflow is prevented by limiting the number of outstanding transactions\n  // to DEPTH. Counter underflow is prevented by the assumption that resp_valid_i = 1\n  // will only occur in response to accepted transfer request (as per the OBI protocol).\n  //////////////////////////////////////////////////////////////////////////////\n\n  assign count_up = trans_valid_o && trans_ready_i;  // Increment upon accepted transfer request\n  assign count_down = resp_valid_i;  // Decrement upon accepted transfer response\n\n  always_comb begin\n    case ({\n      count_up, count_down\n    })\n      2'b00: begin\n        next_cnt = cnt_q;\n      end\n      2'b01: begin\n        next_cnt = cnt_q - 1'b1;\n      end\n      2'b10: begin\n        next_cnt = cnt_q + 1'b1;\n      end\n      2'b11: begin\n        next_cnt = cnt_q;\n      end\n    endcase\n  end\n\n  generate\n    if (COREV_PULP) begin : gen_hwlp\n\n      // Flush the FIFO if it is not empty and we are hwlp branching.\n      // If HWLP_END is not going to ID, save it from the flush.\n      // Don't flush the FIFO if it is empty (maybe we must accept\n      // HWLP_end from the memory in this cycle)\n      assign fifo_flush_o           = branch_i || (hwlp_jump_i && !fifo_empty_i && fifo_pop_o);\n      assign fifo_flush_but_first_o = (hwlp_jump_i && !fifo_empty_i && !fifo_pop_o);\n\n      //////////////////////////////////////////////////////////////////////////////\n      // HWLP main resp flush controller\n      //////////////////////////////////////////////////////////////////////////////\n\n      // If HWLP_END-4 is in ID and HWLP_END is being/was returned by the memory\n      // we can flush all the eventual outstanding requests up to now\n      assign hwlp_flush_resp        = hwlp_jump_i && !(fifo_empty_i && !resp_valid_i);\n\n      //////////////////////////////////////////////////////////////////////////////\n      // HWLP delayed flush controller\n      //////////////////////////////////////////////////////////////////////////////\n\n      // If HWLP_END-4 is in ID and HWLP_END has not been returned yet,\n      // save the present number of outstanding requests (subtract the HWLP_END one).\n      // Wait for HWLP_END then flush the saved number of (wrong) outstanding requests\n      assign hwlp_wait_resp_flush   = hwlp_jump_i && (fifo_empty_i && !resp_valid_i);\n\n      always_ff @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n          hwlp_flush_after_resp    <= 1'b0;\n          hwlp_flush_cnt_delayed_q <= 2'b00;\n        end else begin\n          if (branch_i) begin\n            // Reset the flush request if an interrupt is taken\n            hwlp_flush_after_resp    <= 1'b0;\n            hwlp_flush_cnt_delayed_q <= 2'b00;\n          end else begin\n            if (hwlp_wait_resp_flush) begin\n              hwlp_flush_after_resp    <= 1'b1;\n              // cnt_q > 0 checked by an assertion\n              hwlp_flush_cnt_delayed_q <= cnt_q - 1'b1;\n            end else begin\n              // Reset the delayed flush request when it's completed\n              if (hwlp_flush_resp_delayed) begin\n                hwlp_flush_after_resp    <= 1'b0;\n                hwlp_flush_cnt_delayed_q <= 2'b00;\n              end\n            end\n          end\n        end\n      end\n\n      // This signal is masked by branch_i in the flush counter process,\n      // because if an interrupt occurs during a delayed flush, the interrupt\n      // is served first so the flush should be normal (caused by branch_i)\n      assign hwlp_flush_resp_delayed = hwlp_flush_after_resp && resp_valid_i;\n\n    end else begin : gen_no_hwlp\n\n      // Flush the FIFO if it is not empty\n      assign fifo_flush_o             = branch_i;\n      assign fifo_flush_but_first_o   = 1'b0;\n      assign hwlp_flush_resp          = 1'b0;\n      assign hwlp_wait_resp_flush     = 1'b0;\n\n      assign hwlp_flush_after_resp    = 1'b0;\n      assign hwlp_flush_cnt_delayed_q = 2'b00;\n      assign hwlp_flush_resp_delayed  = 1'b0;\n\n\n    end\n  endgenerate\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Counter (flush_cnt_q, next_flush_cnt) to count reseponses to be flushed.\n  //////////////////////////////////////////////////////////////////////////////\n\n  always_comb begin\n    next_flush_cnt = flush_cnt_q;\n\n    // Number of outstanding transfers at time of branch equals the number of\n    // responses that will need to be flushed (responses already in the FIFO will\n    // be flushed there)\n    if (branch_i || hwlp_flush_resp) begin\n      next_flush_cnt = cnt_q;\n      if (resp_valid_i && (cnt_q > 0)) begin\n        next_flush_cnt = cnt_q - 1'b1;\n      end\n    end else if (hwlp_flush_resp_delayed) begin\n      // Delayed flush has a lower priority than the normal flush,\n      // because HW loops branches have lower priority than\n      // taken interrupts\n      next_flush_cnt = hwlp_flush_cnt_delayed_q;\n    end else if (resp_valid_i && (flush_cnt_q > 0)) begin\n      next_flush_cnt = flush_cnt_q - 1'b1;\n    end\n  end\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Registers\n  //////////////////////////////////////////////////////////////////////////////\n\n  always_ff @(posedge clk, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      state_q      <= IDLE;\n      cnt_q        <= '0;\n      flush_cnt_q  <= '0;\n      trans_addr_q <= '0;\n    end else begin\n      state_q     <= next_state;\n      cnt_q       <= next_cnt;\n      flush_cnt_q <= next_flush_cnt;\n      if (branch_i || hwlp_jump_i || (trans_valid_o && trans_ready_i)) begin\n        trans_addr_q <= trans_addr_o;\n      end\n    end\n  end\n\nendmodule  // cv32e40p_prefetch_controller\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Francesco Conti - f.conti@unibo.it                         //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    RISC-V register file                                       //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Register file with 31x 32 bit wide registers. Register 0   //\n//                 is fixed to 0. This register file is based on flip-flops.  //\n//                 Also supports the fp-register file now if FPU=1            //\n//                 If ZFINX is 1, floating point operations take values       //\n//                 from the X register file                                   //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_register_file #(\n    parameter ADDR_WIDTH = 5,\n    parameter DATA_WIDTH = 32,\n    parameter FPU        = 0,\n    parameter ZFINX      = 0\n) (\n    // Clock and Reset\n    input logic clk,\n    input logic rst_n,\n\n    input logic scan_cg_en_i,\n\n    //Read port R1\n    input  logic [ADDR_WIDTH-1:0] raddr_a_i,\n    output logic [DATA_WIDTH-1:0] rdata_a_o,\n\n    //Read port R2\n    input  logic [ADDR_WIDTH-1:0] raddr_b_i,\n    output logic [DATA_WIDTH-1:0] rdata_b_o,\n\n    //Read port R3\n    input  logic [ADDR_WIDTH-1:0] raddr_c_i,\n    output logic [DATA_WIDTH-1:0] rdata_c_o,\n\n    // Write port W1\n    input logic [ADDR_WIDTH-1:0] waddr_a_i,\n    input logic [DATA_WIDTH-1:0] wdata_a_i,\n    input logic                  we_a_i,\n\n    // Write port W2\n    input logic [ADDR_WIDTH-1:0] waddr_b_i,\n    input logic [DATA_WIDTH-1:0] wdata_b_i,\n    input logic                  we_b_i\n);\n\n  // number of integer registers\n  localparam NUM_WORDS = 2 ** (ADDR_WIDTH - 1);\n  // number of floating point registers\n  localparam NUM_FP_WORDS = 2 ** (ADDR_WIDTH - 1);\n  localparam NUM_TOT_WORDS = FPU ? (ZFINX ? NUM_WORDS : NUM_WORDS + NUM_FP_WORDS) : NUM_WORDS;\n\n  // integer register file\n  logic [    NUM_WORDS-1:0][DATA_WIDTH-1:0] mem;\n\n  // fp register file\n  logic [ NUM_FP_WORDS-1:0][DATA_WIDTH-1:0] mem_fp;\n\n  // masked write addresses\n  logic [   ADDR_WIDTH-1:0]                 waddr_a;\n  logic [   ADDR_WIDTH-1:0]                 waddr_b;\n\n  // write enable signals for all registers\n  logic [NUM_TOT_WORDS-1:0]                 we_a_dec;\n  logic [NUM_TOT_WORDS-1:0]                 we_b_dec;\n\n\n  //-----------------------------------------------------------------------------\n  //-- READ : Read address decoder RAD\n  //-----------------------------------------------------------------------------\n  assign rdata_a_o = raddr_a_i[5] ? mem_fp[raddr_a_i[4:0]] : mem[raddr_a_i[4:0]];\n  assign rdata_b_o = raddr_b_i[5] ? mem_fp[raddr_b_i[4:0]] : mem[raddr_b_i[4:0]];\n  assign rdata_c_o = raddr_c_i[5] ? mem_fp[raddr_c_i[4:0]] : mem[raddr_c_i[4:0]];\n\n  //-----------------------------------------------------------------------------\n  //-- WRITE : Write Address Decoder (WAD), combinatorial process\n  //-----------------------------------------------------------------------------\n\n  // Mask top bit of write address to disable fp regfile\n  assign waddr_a   = waddr_a_i;\n  assign waddr_b   = waddr_b_i;\n\n  genvar gidx;\n  generate\n    for (gidx = 0; gidx < NUM_TOT_WORDS; gidx++) begin : gen_we_decoder\n      assign we_a_dec[gidx] = (waddr_a == gidx) ? we_a_i : 1'b0;\n      assign we_b_dec[gidx] = (waddr_b == gidx) ? we_b_i : 1'b0;\n    end\n  endgenerate\n\n  genvar i, l;\n  generate\n\n    //-----------------------------------------------------------------------------\n    //-- WRITE : Write operation\n    //-----------------------------------------------------------------------------\n    // R0 is nil\n    always_ff @(posedge clk or negedge rst_n) begin\n      if (~rst_n) begin\n        // R0 is nil\n        mem[0] <= 32'b0;\n      end else begin\n        // R0 is nil\n        mem[0] <= 32'b0;\n      end\n    end\n\n    // loop from 1 to NUM_WORDS-1 as R0 is nil\n    for (i = 1; i < NUM_WORDS; i++) begin : gen_rf\n\n      always_ff @(posedge clk, negedge rst_n) begin : register_write_behavioral\n        if (rst_n == 1'b0) begin\n          mem[i] <= 32'b0;\n        end else begin\n          if (we_b_dec[i] == 1'b1) mem[i] <= wdata_b_i;\n          else if (we_a_dec[i] == 1'b1) mem[i] <= wdata_a_i;\n        end\n      end\n\n    end\n\n    if (FPU == 1 && ZFINX == 0) begin : gen_mem_fp_write\n      // Floating point registers\n      for (l = 0; l < NUM_FP_WORDS; l++) begin\n        always_ff @(posedge clk, negedge rst_n) begin : fp_regs\n          if (rst_n == 1'b0) mem_fp[l] <= '0;\n          else if (we_b_dec[l+NUM_WORDS] == 1'b1) mem_fp[l] <= wdata_b_i;\n          else if (we_a_dec[l+NUM_WORDS] == 1'b1) mem_fp[l] <= wdata_a_i;\n        end\n      end\n    end else begin : gen_no_mem_fp_write\n      assign mem_fp = 'b0;\n    end\n\n  endgenerate\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Antonio Pullini - pullinia@iis.ee.ethz.ch                  //\n//                                                                            //\n// Additional contributions by:                                               //\n//                 Sven Stucki - svstucki@student.ethz.ch                     //\n//                 Michael Gautschi - gautschi@iis.ee.ethz.ch                 //\n//                 Davide Schiavone - pschiavo@iis.ee.ethz.ch                 //\n//                                                                            //\n// Design Name:    RISC-V register file                                       //\n// Project Name:   RI5CY                                                      //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Register file with 31x 32 bit wide registers. Register 0   //\n//                 is fixed to 0. This register file is based on latches and  //\n//                 is thus smaller than the flip-flop based register file.    //\n//                 Also supports the fp-register file now if FPU=1            //\n//                 If ZFINX is 1, floating point operations take values       //\n//                 from the X register file                                   //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_register_file #(\n    parameter ADDR_WIDTH = 5,\n    parameter DATA_WIDTH = 32,\n    parameter FPU        = 0,\n    parameter ZFINX      = 0\n) (\n    // Clock and Reset\n    input logic clk,\n    input logic rst_n,\n\n    input logic scan_cg_en_i,\n\n    //Read port R1\n    input  logic [ADDR_WIDTH-1:0] raddr_a_i,\n    output logic [DATA_WIDTH-1:0] rdata_a_o,\n\n    //Read port R2\n    input  logic [ADDR_WIDTH-1:0] raddr_b_i,\n    output logic [DATA_WIDTH-1:0] rdata_b_o,\n\n    //Read port R3\n    input  logic [ADDR_WIDTH-1:0] raddr_c_i,\n    output logic [DATA_WIDTH-1:0] rdata_c_o,\n\n    // Write port W1\n    input logic [ADDR_WIDTH-1:0] waddr_a_i,\n    input logic [DATA_WIDTH-1:0] wdata_a_i,\n    input logic                  we_a_i,\n\n    // Write port W2\n    input logic [ADDR_WIDTH-1:0] waddr_b_i,\n    input logic [DATA_WIDTH-1:0] wdata_b_i,\n    input logic                  we_b_i\n);\n\n  // number of integer registers\n  localparam NUM_WORDS = 2 ** (ADDR_WIDTH - 1);\n  // number of floating point registers\n  localparam NUM_FP_WORDS = 2 ** (ADDR_WIDTH - 1);\n  localparam NUM_TOT_WORDS = FPU ? (ZFINX ? NUM_WORDS : NUM_WORDS + NUM_FP_WORDS) : NUM_WORDS;\n\n  // integer register file\n  logic [   DATA_WIDTH-1:0] mem            [NUM_WORDS];\n  logic [NUM_TOT_WORDS-1:1] waddr_onehot_a;\n  logic [NUM_TOT_WORDS-1:1] waddr_onehot_b, waddr_onehot_b_q;\n  logic        [NUM_TOT_WORDS-1:1] mem_clocks;\n  logic        [   DATA_WIDTH-1:0] wdata_a_q;\n  logic        [   DATA_WIDTH-1:0] wdata_b_q;\n\n  // masked write addresses\n  logic        [   ADDR_WIDTH-1:0] waddr_a;\n  logic        [   ADDR_WIDTH-1:0] waddr_b;\n\n  logic                            clk_int;\n\n  // fp register file\n  logic        [   DATA_WIDTH-1:0] mem_fp     [NUM_FP_WORDS];\n\n  int unsigned                     i;\n  int unsigned                     j;\n  int unsigned                     k;\n  int unsigned                     l;\n\n  genvar x;\n  genvar y;\n\n  //-----------------------------------------------------------------------------\n  //-- READ : Read address decoder RAD\n  //-----------------------------------------------------------------------------\n  assign rdata_a_o = raddr_a_i[5] ? mem_fp[raddr_a_i[4:0]] : mem[raddr_a_i[4:0]];\n  assign rdata_b_o = raddr_b_i[5] ? mem_fp[raddr_b_i[4:0]] : mem[raddr_b_i[4:0]];\n  assign rdata_c_o = raddr_c_i[5] ? mem_fp[raddr_c_i[4:0]] : mem[raddr_c_i[4:0]];\n\n  //-----------------------------------------------------------------------------\n  // WRITE : SAMPLE INPUT DATA\n  //---------------------------------------------------------------------------\n\n  cv32e40p_clock_gate CG_WE_GLOBAL (\n      .clk_i       (clk),\n      .en_i        (we_a_i | we_b_i),\n      .scan_cg_en_i(scan_cg_en_i),\n      .clk_o       (clk_int)\n  );\n\n  // use clk_int here, since otherwise we don't want to write anything anyway\n  always_ff @(posedge clk_int, negedge rst_n) begin : sample_waddr\n    if (~rst_n) begin\n      wdata_a_q        <= '0;\n      wdata_b_q        <= '0;\n      waddr_onehot_b_q <= '0;\n    end else begin\n      if (we_a_i) wdata_a_q <= wdata_a_i;\n\n      if (we_b_i) wdata_b_q <= wdata_b_i;\n\n      waddr_onehot_b_q <= waddr_onehot_b;\n    end\n  end\n\n  //-----------------------------------------------------------------------------\n  //-- WRITE : Write Address Decoder (WAD), combinatorial process\n  //-----------------------------------------------------------------------------\n\n  assign waddr_a = waddr_a_i;\n  assign waddr_b = waddr_b_i;\n\n  genvar gidx;\n  generate\n    for (gidx = 1; gidx < NUM_TOT_WORDS; gidx++) begin : gen_we_decoder\n      assign waddr_onehot_a[gidx] = (we_a_i == 1'b1) && (waddr_a == gidx);\n      assign waddr_onehot_b[gidx] = (we_b_i == 1'b1) && (waddr_b == gidx);\n    end\n  endgenerate\n\n  //-----------------------------------------------------------------------------\n  //-- WRITE : Clock gating (if integrated clock-gating cells are available)\n  //-----------------------------------------------------------------------------\n  generate\n    for (x = 1; x < NUM_TOT_WORDS; x++) begin : gen_clock_gate\n      cv32e40p_clock_gate clock_gate_i (\n          .clk_i       (clk_int),\n          .en_i        (waddr_onehot_a[x] | waddr_onehot_b[x]),\n          .scan_cg_en_i(scan_cg_en_i),\n          .clk_o       (mem_clocks[x])\n      );\n    end\n  endgenerate\n\n  //-----------------------------------------------------------------------------\n  //-- WRITE : Write operation\n  //-----------------------------------------------------------------------------\n  //-- Generate M = WORDS sequential processes, each of which describes one\n  //-- word of the memory. The processes are synchronized with the clocks\n  //-- ClocksxC(i), i = 0, 1, ..., M-1\n  //-- Use active low, i.e. transparent on low latches as storage elements\n  //-- Data is sampled on rising clock edge\n\n  // Integer registers\n  always_latch begin : latch_wdata\n    // Note: The assignment has to be done inside this process or Modelsim complains about it\n    mem[0] = '0;\n\n    for (k = 1; k < NUM_WORDS; k++) begin : w_WordIter\n      if (~rst_n) mem[k] = '0;\n      else if (mem_clocks[k] == 1'b1) mem[k] = waddr_onehot_b_q[k] ? wdata_b_q : wdata_a_q;\n    end\n  end\n\n  if (FPU == 1 && ZFINX == 0) begin\n    // Floating point registers\n    always_latch begin : latch_wdata_fp\n      if (FPU == 1) begin\n        for (l = 0; l < NUM_FP_WORDS; l++) begin : w_WordIter\n          if (~rst_n) mem_fp[l] = '0;\n          else if (mem_clocks[l+NUM_WORDS] == 1'b1)\n            mem_fp[l] = waddr_onehot_b_q[l+NUM_WORDS] ? wdata_b_q : wdata_a_q;\n        end\n      end\n    end\n  end\nendmodule\n"}
{"text": "// Copyright 2020 Silicon Labs, Inc.\n//\n// This file, and derivatives thereof are licensed under the\n// Solderpad License, Version 2.0 (the \"License\").\n//\n// Use of this file means you agree to the terms and conditions\n// of the license and are in full compliance with the License.\n//\n// You may obtain a copy of the License at:\n//\n//     https://solderpad.org/licenses/SHL-2.0/\n//\n// Unless required by applicable law or agreed to in writing, software\n// and hardware implementations thereof distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS\n// OF ANY KIND, EITHER EXPRESSED OR IMPLIED.\n//\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n////////////////////////////////////////////////////////////////////////////////\n// Engineer:       Arjan Bink - arjan.bink@silabs.com                         //\n//                                                                            //\n// Design Name:    Sleep Unit                                                 //\n// Project Name:   CV32E40P                                                   //\n// Language:       SystemVerilog                                              //\n//                                                                            //\n// Description:    Sleep unit containing the instantiated clock gate which    //\n//                 provides the gated clock (clk_gated_o) for the rest        //\n//                 of the design.                                             //\n//                                                                            //\n//                 The clock is gated for the following scenarios:            //\n//                                                                            //\n//                 - While waiting for fetch to become enabled                //\n//                 - While blocked on a WFI (COREV_CLUSTER = 0)               //\n//                 - While clock_en_i = 0 during a cv.elw (COREV_CLUSTER = 1) //\n//                                                                            //\n//                 Sleep is signaled via core_sleep_o when:                   //\n//                                                                            //\n//                 - During a cv.elw (except in debug (i.e. pending debug     //\n//                   request, debug mode, single stepping, trigger match)     //\n//                 - During a WFI (except in debug)                           //\n//                                                                            //\n// Requirements:   If COREV_CLUSTER = 1 the environment must guarantee:       //\n//                                                                            //\n//                 - If core_sleep_o    == 1'b0, then pulp_clock_en_i == 1'b1 //\n//                 - If pulp_clock_en_i == 1'b0, then irq_i == 'b0            //\n//                 - If pulp_clock_en_i == 1'b0, then debug_req_i == 1'b0     //\n//                 - If pulp_clock_en_i == 1'b0, then instr_rvalid_i == 1'b0  //\n//                 - If pulp_clock_en_i == 1'b0, then instr_gnt_i == 1'b0     //\n//                 - If pulp_clock_en_i == 1'b0, then data_rvalid_i == 1'b0   //\n//                 - If pulp_clock_en_i == 1'b0, then data_gnt_i == 1'b1      //\n//                                                                            //\n////////////////////////////////////////////////////////////////////////////////\n\nmodule cv32e40p_sleep_unit #(\n    parameter COREV_CLUSTER = 0\n) (\n    // Clock, reset interface\n    input  logic clk_ungated_i,  // Free running clock\n    input  logic rst_n,\n    output logic clk_gated_o,  // Gated clock\n    input  logic scan_cg_en_i,  // Enable all clock gates for testing\n\n    // Core sleep\n    output logic core_sleep_o,\n\n    // Fetch enable\n    input  logic fetch_enable_i,\n    output logic fetch_enable_o,\n\n    // Core status\n    input logic if_busy_i,\n    input logic ctrl_busy_i,\n    input logic lsu_busy_i,\n    input logic apu_busy_i,\n\n    // PULP Cluster interface\n    input logic pulp_clock_en_i,  // PULP clock enable (only used if COREV_CLUSTER = 1)\n    input logic p_elw_start_i,\n    input logic p_elw_finish_i,\n    input logic debug_p_elw_no_sleep_i,\n\n    // WFI wake\n    input logic wake_from_sleep_i\n);\n\n  import cv32e40p_pkg::*;\n\n  logic fetch_enable_q;  // Sticky version of fetch_enable_i\n  logic fetch_enable_d;\n  logic              core_busy_q;               // Is core still busy (and requires a clock) with what needs to finish before entering sleep?\n  logic core_busy_d;\n  logic p_elw_busy_q;  // Busy with cv.elw (transaction in progress)?\n  logic p_elw_busy_d;\n  logic clock_en;  // Final clock enable\n\n  //////////////////////////////////////////////////////////////////////////////\n  // Sleep FSM\n  //////////////////////////////////////////////////////////////////////////////\n\n  // Make sticky version of fetch_enable_i\n  assign fetch_enable_d = fetch_enable_i ? 1'b1 : fetch_enable_q;\n\n  generate\n    if (COREV_CLUSTER) begin : g_pulp_sleep\n\n      // Busy unless in a cv.elw and IF/APU are no longer busy\n      assign core_busy_d = p_elw_busy_d ? (if_busy_i || apu_busy_i) : 1'b1;\n\n      // Enable the clock only after the initial fetch enable while busy or instructed so by PULP Cluster's pulp_clock_en_i\n      assign clock_en = fetch_enable_q && (pulp_clock_en_i || core_busy_q);\n\n      // Sleep only in response to cv.elw onec no longer busy (but not during various debug scenarios)\n      assign core_sleep_o = p_elw_busy_d && !core_busy_q && !debug_p_elw_no_sleep_i;\n\n      // cv.elw is busy between load start and load finish (data_req_o / data_rvalid_i)\n      assign p_elw_busy_d = p_elw_start_i ? 1'b1 : (p_elw_finish_i ? 1'b0 : p_elw_busy_q);\n\n    end else begin : g_no_pulp_sleep\n\n      // Busy when any of the sub units is busy (typically wait for the instruction buffer to fill up)\n      assign core_busy_d = if_busy_i || ctrl_busy_i || lsu_busy_i || apu_busy_i;\n\n      // Enable the clock only after the initial fetch enable while busy or waking up to become busy\n      assign clock_en = fetch_enable_q && (wake_from_sleep_i || core_busy_q);\n\n      // Sleep only in response to WFI which leads to clock disable; debug_wfi_no_sleep_o in\n      // cv32e40p_controller determines the scenarios for which WFI can(not) cause sleep.\n      assign core_sleep_o = fetch_enable_q && !clock_en;\n\n      // cv.elw does not exist for COREV_CLUSTER = 0\n      assign p_elw_busy_d = 1'b0;\n\n    end\n  endgenerate\n\n  always_ff @(posedge clk_ungated_i, negedge rst_n) begin\n    if (rst_n == 1'b0) begin\n      core_busy_q    <= 1'b0;\n      p_elw_busy_q   <= 1'b0;\n      fetch_enable_q <= 1'b0;\n    end else begin\n      core_busy_q    <= core_busy_d;\n      p_elw_busy_q   <= p_elw_busy_d;\n      fetch_enable_q <= fetch_enable_d;\n    end\n  end\n\n  // Fetch enable for Controller\n  assign fetch_enable_o = fetch_enable_q;\n\n  // Main clock gate of CV32E40P\n  cv32e40p_clock_gate core_clock_gate_i (\n      .clk_i       (clk_ungated_i),\n      .en_i        (clock_en),\n      .scan_cg_en_i(scan_cg_en_i),\n      .clk_o       (clk_gated_o)\n  );\n\n  //----------------------------------------------------------------------------\n  // Assertions\n  //----------------------------------------------------------------------------\n\n`ifdef CV32E40P_ASSERT_ON\n\n  // Clock gate is disabled during RESET state of the controller\n  property p_clock_en_0;\n    @(posedge clk_ungated_i) disable iff (!rst_n) ((id_stage_i.controller_i.ctrl_fsm_cs == cv32e40p_pkg::RESET) && (id_stage_i.controller_i.ctrl_fsm_ns == cv32e40p_pkg::RESET)) |-> (clock_en == 1'b0);\n  endproperty\n\n  a_clock_en_0 :\n  assert property (p_clock_en_0);\n\n  // Clock gate is enabled when exit from RESET state is required\n  property p_clock_en_1;\n    @(posedge clk_ungated_i) disable iff (!rst_n) ((id_stage_i.controller_i.ctrl_fsm_cs == cv32e40p_pkg::RESET) && (id_stage_i.controller_i.ctrl_fsm_ns != cv32e40p_pkg::RESET)) |-> (clock_en == 1'b1);\n  endproperty\n\n  a_clock_en_1 :\n  assert property (p_clock_en_1);\n\n  // Clock gate is not enabled before receiving fetch_enable_i pulse\n  property p_clock_en_2;\n    @(posedge clk_ungated_i) disable iff (!rst_n) (fetch_enable_q == 1'b0) |-> (clock_en == 1'b0);\n  endproperty\n\n  a_clock_en_2 :\n  assert property (p_clock_en_2);\n\n  generate\n    if (COREV_CLUSTER) begin : g_pulp_cluster_assertions\n\n      // Clock gate is only possibly disabled in RESET or when COREV_CLUSTER disables clock\n      property p_clock_en_3;\n        @(posedge clk_ungated_i) disable iff (!rst_n) (clock_en == 1'b0) -> ((id_stage_i.controller_i.ctrl_fsm_cs == cv32e40p_pkg::RESET) || (COREV_CLUSTER && !pulp_clock_en_i));\n      endproperty\n\n      a_clock_en_3 :\n      assert property (p_clock_en_3);\n\n      // Core can only sleep in response to cv.elw\n      property p_only_sleep_during_p_elw;\n        @(posedge clk_ungated_i) disable iff (!rst_n) (core_sleep_o == 1'b1) |-> (p_elw_busy_d == 1'b1);\n      endproperty\n\n      a_only_sleep_during_p_elw :\n      assert property (p_only_sleep_during_p_elw);\n\n\n      // Environment fully controls clock_en during sleep\n      property p_full_clock_en_control;\n        @(posedge clk_ungated_i) disable iff (!rst_n) (core_sleep_o == 1'b1) |-> (pulp_clock_en_i == clock_en);\n      endproperty\n\n      a_full_clock_en_control :\n      assert property (p_full_clock_en_control);\n\n    end else begin : g_no_pulp_cluster_assertions\n\n      // Clock gate is only possibly disabled in RESET or SLEEP\n      property p_clock_en_4;\n        @(posedge clk_ungated_i) disable iff (!rst_n) (clock_en == 1'b0) -> ((id_stage_i.controller_i.ctrl_fsm_cs == cv32e40p_pkg::RESET) || (id_stage_i.controller_i.ctrl_fsm_ns == cv32e40p_pkg::SLEEP));\n      endproperty\n\n      a_clock_en_4 :\n      assert property (p_clock_en_4);\n\n      // Clock gate is enabled when exit from SLEEP state is required\n      property p_clock_en_5;\n        @(posedge clk_ungated_i) disable iff (!rst_n)  ((id_stage_i.controller_i.ctrl_fsm_cs == cv32e40p_pkg::SLEEP) && (id_stage_i.controller_i.ctrl_fsm_ns != cv32e40p_pkg::SLEEP)) |-> (clock_en == 1'b1);\n      endproperty\n\n      a_clock_en_5 :\n      assert property (p_clock_en_5);\n\n      // Core sleep is only signaled in SLEEP state\n      property p_core_sleep;\n        @(posedge clk_ungated_i) disable iff (!rst_n) (core_sleep_o == 1'b1) -> ((id_stage_i.controller_i.ctrl_fsm_cs == cv32e40p_pkg::SLEEP));\n      endproperty\n\n      a_core_sleep :\n      assert property (p_core_sleep);\n\n      // Core can only become non-busy due to SLEEP entry\n      property p_non_busy;\n        @(posedge clk_ungated_i) disable iff (!rst_n) (core_busy_d == 1'b0) |-> (id_stage_i.controller_i.ctrl_fsm_cs == cv32e40p_pkg::WAIT_SLEEP) || (id_stage_i.controller_i.ctrl_fsm_cs == cv32e40p_pkg::SLEEP);\n      endproperty\n\n      a_non_busy :\n      assert property (p_non_busy);\n\n      // During (COREV_CLUSTER = 0) sleep it should be allowed to externally gate clk_i\n      property p_gate_clk_i;\n        @(posedge clk_ungated_i) disable iff (!rst_n) (core_sleep_o == 1'b1) |-> (core_busy_q == core_busy_d) && (p_elw_busy_q == p_elw_busy_d) && (fetch_enable_q == fetch_enable_d);\n      endproperty\n\n      a_gate_clk_i :\n      assert property (p_gate_clk_i);\n\n      // During sleep the internal clock is gated\n      property p_gate_clock_during_sleep;\n        @(posedge clk_ungated_i) disable iff (!rst_n) (core_sleep_o == 1'b1) |-> (clock_en == 1'b0);\n      endproperty\n\n      a_gate_clock_during_sleep :\n      assert property (p_gate_clock_during_sleep);\n\n      // Sleep mode can only be entered in response to a WFI instruction\n      property p_only_sleep_for_wfi;\n        @(posedge clk_ungated_i) disable iff (!rst_n) (core_sleep_o == 1'b1) |-> (id_stage_i.instr == {\n          12'b000100000101, 13'b0, OPCODE_SYSTEM\n        });\n      endproperty\n\n      a_only_sleep_for_wfi :\n      assert property (p_only_sleep_for_wfi);\n\n      // In sleep mode the core will not be busy (e.g. no ongoing/outstanding instruction or data transactions)\n      property p_not_busy_during_sleep;\n        @(posedge clk_ungated_i) disable iff (!rst_n) (core_sleep_o == 1'b1) |-> ((core_busy_q == 1'b0) && (core_busy_d == 1'b0));\n      endproperty\n\n      a_not_busy_during_sleep :\n      assert property (p_not_busy_during_sleep);\n\n    end\n  endgenerate\n\n`endif\n\nendmodule  // cv32e40p_sleep_unit\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// Top file instantiating a CV32E40P core and an optional FPU\n// Contributor: Davide Schiavone <davide@openhwgroup.org>\n\nmodule cv32e40p_top #(\n    parameter COREV_PULP = 0, // PULP ISA Extension (incl. custom CSRs and hardware loop, excl. cv.elw)\n    parameter COREV_CLUSTER = 0,  // PULP Cluster interface (incl. cv.elw)\n    parameter FPU = 0,  // Floating Point Unit (interfaced via APU interface)\n    parameter FPU_ADDMUL_LAT = 0,  // Floating-Point ADDition/MULtiplication computing lane pipeline registers number\n    parameter FPU_OTHERS_LAT = 0,  // Floating-Point COMParison/CONVersion computing lanes pipeline registers number\n    parameter ZFINX = 0,  // Float-in-General Purpose registers\n    parameter NUM_MHPMCOUNTERS = 1\n) (\n    // Clock and Reset\n    input logic clk_i,\n    input logic rst_ni,\n\n    input logic pulp_clock_en_i,  // PULP clock enable (only used if COREV_CLUSTER = 1)\n    input logic scan_cg_en_i,  // Enable all clock gates for testing\n\n    // Core ID, Cluster ID, debug mode halt address and boot address are considered more or less static\n    input logic [31:0] boot_addr_i,\n    input logic [31:0] mtvec_addr_i,\n    input logic [31:0] dm_halt_addr_i,\n    input logic [31:0] hart_id_i,\n    input logic [31:0] dm_exception_addr_i,\n\n    // Instruction memory interface\n    output logic        instr_req_o,\n    input  logic        instr_gnt_i,\n    input  logic        instr_rvalid_i,\n    output logic [31:0] instr_addr_o,\n    input  logic [31:0] instr_rdata_i,\n\n    // Data memory interface\n    output logic        data_req_o,\n    input  logic        data_gnt_i,\n    input  logic        data_rvalid_i,\n    output logic        data_we_o,\n    output logic [ 3:0] data_be_o,\n    output logic [31:0] data_addr_o,\n    output logic [31:0] data_wdata_o,\n    input  logic [31:0] data_rdata_i,\n\n    // Interrupt inputs\n    input  logic [31:0] irq_i,  // CLINT interrupts + CLINT extension interrupts\n    output logic        irq_ack_o,\n    output logic [ 4:0] irq_id_o,\n\n    // Debug Interface\n    input  logic debug_req_i,\n    output logic debug_havereset_o,\n    output logic debug_running_o,\n    output logic debug_halted_o,\n\n    // CPU Control Signals\n    input  logic fetch_enable_i,\n    output logic core_sleep_o\n);\n\n  import cv32e40p_apu_core_pkg::*;\n\n  // Core to FPU\n  logic                              clk;\n  logic                              apu_req;\n  logic [   APU_NARGS_CPU-1:0][31:0] apu_operands;\n  logic [     APU_WOP_CPU-1:0]       apu_op;\n  logic [APU_NDSFLAGS_CPU-1:0]       apu_flags;\n\n  // FPU to Core\n  logic                              apu_gnt;\n  logic                              apu_rvalid;\n  logic [                31:0]       apu_rdata;\n  logic [APU_NUSFLAGS_CPU-1:0]       apu_rflags;\n\n  // Instantiate the Core\n  cv32e40p_core #(\n      .COREV_PULP      (COREV_PULP),\n      .COREV_CLUSTER   (COREV_CLUSTER),\n      .FPU             (FPU),\n      .FPU_ADDMUL_LAT  (FPU_ADDMUL_LAT),\n      .FPU_OTHERS_LAT  (FPU_OTHERS_LAT),\n      .ZFINX           (ZFINX),\n      .NUM_MHPMCOUNTERS(NUM_MHPMCOUNTERS)\n  ) core_i (\n      .clk_i (clk_i),\n      .rst_ni(rst_ni),\n\n      .pulp_clock_en_i(pulp_clock_en_i),\n      .scan_cg_en_i   (scan_cg_en_i),\n\n      .boot_addr_i        (boot_addr_i),\n      .mtvec_addr_i       (mtvec_addr_i),\n      .dm_halt_addr_i     (dm_halt_addr_i),\n      .hart_id_i          (hart_id_i),\n      .dm_exception_addr_i(dm_exception_addr_i),\n\n      .instr_req_o   (instr_req_o),\n      .instr_gnt_i   (instr_gnt_i),\n      .instr_rvalid_i(instr_rvalid_i),\n      .instr_addr_o  (instr_addr_o),\n      .instr_rdata_i (instr_rdata_i),\n\n      .data_req_o   (data_req_o),\n      .data_gnt_i   (data_gnt_i),\n      .data_rvalid_i(data_rvalid_i),\n      .data_we_o    (data_we_o),\n      .data_be_o    (data_be_o),\n      .data_addr_o  (data_addr_o),\n      .data_wdata_o (data_wdata_o),\n      .data_rdata_i (data_rdata_i),\n\n      .apu_req_o     (apu_req),\n      .apu_gnt_i     (apu_gnt),\n      .apu_operands_o(apu_operands),\n      .apu_op_o      (apu_op),\n      .apu_flags_o   (apu_flags),\n      .apu_rvalid_i  (apu_rvalid),\n      .apu_result_i  (apu_rdata),\n      .apu_flags_i   (apu_rflags),\n\n      .irq_i    (irq_i),\n      .irq_ack_o(irq_ack_o),\n      .irq_id_o (irq_id_o),\n\n      .debug_req_i      (debug_req_i),\n      .debug_havereset_o(debug_havereset_o),\n      .debug_running_o  (debug_running_o),\n      .debug_halted_o   (debug_halted_o),\n\n      .fetch_enable_i(fetch_enable_i),\n      .core_sleep_o  (core_sleep_o)\n  );\n\n  generate\n    if (FPU) begin : fpu_gen\n      // FPU clock gate\n      cv32e40p_clock_gate core_clock_gate_i (\n          .clk_i       (clk_i),\n          .en_i        (!core_sleep_o),\n          .scan_cg_en_i(scan_cg_en_i),\n          .clk_o       (clk)\n      );\n\n      // Instantiate the FPU wrapper\n      cv32e40p_fp_wrapper #(\n          .FPU_ADDMUL_LAT(FPU_ADDMUL_LAT),\n          .FPU_OTHERS_LAT(FPU_OTHERS_LAT)\n      ) fp_wrapper_i (\n          .clk_i         (clk),\n          .rst_ni        (rst_ni),\n          .apu_req_i     (apu_req),\n          .apu_gnt_o     (apu_gnt),\n          .apu_operands_i(apu_operands),\n          .apu_op_i      (apu_op),\n          .apu_flags_i   (apu_flags),\n          .apu_rvalid_o  (apu_rvalid),\n          .apu_rdata_o   (apu_rdata),\n          .apu_rflags_o  (apu_rflags)\n      );\n    end else begin : no_fpu_gen\n      // Drive FPU output signals to 0\n      assign apu_gnt    = '0;\n      assign apu_rvalid = '0;\n      assign apu_rdata  = '0;\n      assign apu_rflags = '0;\n    end\n  endgenerate\n\nendmodule\n"}
