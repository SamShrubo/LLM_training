{"text": "// Copyright 2020 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Authors: Matheus Cavalcante, ETH Zurich\n//          Nils Wistoff, ETH Zurich\n// Date: 20.11.2020\n// Description: Functional unit that dispatches CVA6 instructions to accelerators.\n\nmodule acc_dispatcher\n  import ariane_pkg::*;\n  import riscv::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg    = config_pkg::cva6_cfg_empty,\n    parameter type                   acc_req_t  = acc_pkg::accelerator_req_t,\n    parameter type                   acc_resp_t = acc_pkg::accelerator_resp_t,\n    parameter type                   acc_cfg_t  = logic,\n    parameter acc_cfg_t              AccCfg     = '0\n) (\n    input logic clk_i,\n    input logic rst_ni,\n    // Interface with the CSR regfile\n    input logic acc_cons_en_i,  // Accelerator memory consistent mode\n    output logic acc_fflags_valid_o,\n    output logic [4:0] acc_fflags_o,\n    // Interface with the CSRs\n    input priv_lvl_t ld_st_priv_lvl_i,\n    input logic sum_i,\n    input pmpcfg_t [15:0] pmpcfg_i,\n    input logic [15:0][PLEN-3:0] pmpaddr_i,\n    input logic [2:0] fcsr_frm_i,\n    output logic dirty_v_state_o,\n    // Interface with the issue stage\n    input scoreboard_entry_t issue_instr_i,\n    input logic issue_instr_hs_i,\n    output logic issue_stall_o,\n    input fu_data_t fu_data_i,\n    input scoreboard_entry_t [CVA6Cfg.NrCommitPorts-1:0] commit_instr_i,\n    output logic [TRANS_ID_BITS-1:0] acc_trans_id_o,\n    output xlen_t acc_result_o,\n    output logic acc_valid_o,\n    output exception_t acc_exception_o,\n    // Interface with the execute stage\n    output logic acc_valid_ex_o,  // FU executed\n    // Interface with the commit stage\n    input logic [CVA6Cfg.NrCommitPorts-1:0] commit_ack_i,\n    input logic commit_st_barrier_i,  // A store barrier was commited\n    // Interface with the load/store unit\n    output logic acc_stall_st_pending_o,\n    input logic acc_no_st_pending_i,\n    input dcache_req_i_t [2:0] dcache_req_ports_i,\n    // Interface with the controller\n    output logic ctrl_halt_o,\n    input logic flush_unissued_instr_i,\n    input logic flush_ex_i,\n    output logic flush_pipeline_o,\n    // Interface with cache subsystem\n    output dcache_req_i_t [1:0] acc_dcache_req_ports_o,\n    input dcache_req_o_t [1:0] acc_dcache_req_ports_i,\n    input logic inval_ready_i,\n    output logic inval_valid_o,\n    output logic [63:0] inval_addr_o,\n    // Accelerator interface\n    output acc_req_t acc_req_o,\n    input acc_resp_t acc_resp_i\n);\n\n  `include \"common_cells/registers.svh\"\n\n  import cf_math_pkg::idx_width;\n\n  /***********************\n   *  Common signals     *\n   ***********************/\n\n  logic acc_ready;\n  logic acc_valid_d, acc_valid_q;\n\n  /**************************\n   *  Accelerator issue     *\n   **************************/\n\n  // Issue accelerator instructions\n  `FF(acc_valid_q, acc_valid_d, '0)\n\n  assign acc_valid_ex_o = acc_valid_q;\n  assign acc_valid_d    = ~issue_instr_i.ex.valid &\n                          issue_instr_hs_i &\n                          (issue_instr_i.fu == ACCEL) &\n                          ~flush_unissued_instr_i;\n\n  // Accelerator load/store pending signals\n  logic acc_no_ld_pending;\n  logic acc_no_st_pending;\n\n  // Stall issue stage in three cases:\n  always_comb begin : stall_issue\n    unique case (issue_instr_i.fu)\n      ACCEL:\n      // 1. We're issuing an accelerator instruction but the dispatcher isn't ready yet\n      issue_stall_o = ~acc_ready;\n      LOAD:\n      // 2. We're issuing a scalar load but there is an inflight accelerator store.\n      issue_stall_o = acc_cons_en_i & ~acc_no_st_pending;\n      STORE:\n      // 3. We're issuing a scalar store but there is an inflight accelerator load or store.\n      issue_stall_o = acc_cons_en_i & (~acc_no_st_pending | ~acc_no_ld_pending);\n      default: issue_stall_o = 1'b0;\n    endcase\n  end\n\n  /***********************\n   *  Instruction queue  *\n   ***********************/\n\n  localparam InstructionQueueDepth = 3;\n\n  fu_data_t                                        acc_data;\n  fu_data_t                                        acc_insn_queue_o;\n  logic                                            acc_insn_queue_pop;\n  logic                                            acc_insn_queue_empty;\n  logic     [idx_width(InstructionQueueDepth)-1:0] acc_insn_queue_usage;\n  logic                                            acc_commit;\n  logic     [                   TRANS_ID_BITS-1:0] acc_commit_trans_id;\n\n  assign acc_data = acc_valid_ex_o ? fu_data_i : '0;\n\n  fifo_v3 #(\n      .DEPTH       (InstructionQueueDepth),\n      .FALL_THROUGH(1'b1),\n      .dtype       (fu_data_t)\n  ) i_acc_insn_queue (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .flush_i   (flush_ex_i),\n      .testmode_i(1'b0),\n      .data_i    (fu_data_i),\n      .push_i    (acc_valid_q),\n      .full_o    (  /* Unused */),\n      .data_o    (acc_insn_queue_o),\n      .pop_i     (acc_insn_queue_pop),\n      .empty_o   (acc_insn_queue_empty),\n      .usage_o   (acc_insn_queue_usage)\n  );\n\n  // We are ready if the instruction queue is able to accept at least one more entry.\n  assign acc_ready = acc_insn_queue_usage < (InstructionQueueDepth - 1);\n\n  /**********************************\n   *  Non-speculative instructions  *\n   **********************************/\n\n  // Keep track of the instructions that were received by the dispatcher.\n  logic [NR_SB_ENTRIES-1:0] insn_pending_d, insn_pending_q;\n  `FF(insn_pending_q, insn_pending_d, '0)\n\n  // Only non-speculative instructions can be issued to the accelerators.\n  // The following block keeps track of which transaction IDs reached the\n  // top of the scoreboard, and are therefore no longer speculative.\n  logic [NR_SB_ENTRIES-1:0] insn_ready_d, insn_ready_q;\n  `FF(insn_ready_q, insn_ready_d, '0)\n\n  always_comb begin : p_non_speculative_ff\n    // Maintain state\n    insn_pending_d = insn_pending_q;\n    insn_ready_d   = insn_ready_q;\n\n    // We received a new instruction\n    if (acc_valid_q) insn_pending_d[acc_data.trans_id] = 1'b1;\n    // Flush all received instructions\n    if (flush_ex_i) insn_pending_d = '0;\n\n    // An accelerator instruction is no longer speculative.\n    if (acc_commit && insn_pending_q[acc_commit_trans_id]) begin\n      insn_ready_d[acc_commit_trans_id]   = 1'b1;\n      insn_pending_d[acc_commit_trans_id] = 1'b0;\n    end\n\n    // An accelerator instruction was issued.\n    if (acc_req_o.req_valid) insn_ready_d[acc_req_o.trans_id] = 1'b0;\n  end : p_non_speculative_ff\n\n  /*************************\n   *  Accelerator request  *\n   *************************/\n\n  acc_pkg::accelerator_req_t acc_req;\n  logic                      acc_req_valid;\n  logic                      acc_req_ready;\n\n  acc_pkg::accelerator_req_t acc_req_int;\n  fall_through_register #(\n      .T(acc_pkg::accelerator_req_t)\n  ) i_accelerator_req_register (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .clr_i     (1'b0),\n      .testmode_i(1'b0),\n      .data_i    (acc_req),\n      .valid_i   (acc_req_valid),\n      .ready_o   (acc_req_ready),\n      .data_o    (acc_req_int),\n      .valid_o   (acc_req_o.req_valid),\n      .ready_i   (acc_resp_i.req_ready)\n  );\n\n  assign acc_req_o.insn          = acc_req_int.insn;\n  assign acc_req_o.rs1           = acc_req_int.rs1;\n  assign acc_req_o.rs2           = acc_req_int.rs2;\n  assign acc_req_o.frm           = acc_req_int.frm;\n  assign acc_req_o.trans_id      = acc_req_int.trans_id;\n  assign acc_req_o.store_pending = !acc_no_st_pending_i && acc_cons_en_i;\n  assign acc_req_o.acc_cons_en   = acc_cons_en_i;\n  assign acc_req_o.inval_ready   = inval_ready_i;\n\n  always_comb begin : accelerator_req_dispatcher\n    // Do not fetch from the instruction queue\n    acc_insn_queue_pop = 1'b0;\n\n    // Default values\n    acc_req            = '0;\n    acc_req_valid      = 1'b0;\n\n    // Unpack fu_data_t into accelerator_req_t\n    if (!acc_insn_queue_empty) begin\n      acc_req = '{\n          // Instruction is forwarded from the decoder as an immediate\n          // -\n          // frm rounding information is up to date during a valid request to the accelerator\n          // The scoreboard synchronizes it with previous fcsr writes, and future fcsr writes\n          // do not take place until the accelerator answers (Ariane commits in-order)\n          insn    :\n          acc_insn_queue_o.imm[\n          31\n          :\n          0\n          ],\n          rs1     : acc_insn_queue_o.operand_a,\n          rs2     : acc_insn_queue_o.operand_b,\n          frm     : fpnew_pkg::roundmode_e'(fcsr_frm_i),\n          trans_id: acc_insn_queue_o.trans_id,\n          default: '0\n      };\n      // Wait until the instruction is no longer speculative.\n      acc_req_valid      = insn_ready_q[acc_insn_queue_o.trans_id] ||\n                           (acc_commit && insn_pending_q[acc_commit_trans_id]);\n      acc_insn_queue_pop = acc_req_valid && acc_req_ready;\n    end\n  end\n\n  /**************************\n   *  Accelerator response  *\n   **************************/\n\n  logic acc_ld_disp;\n  logic acc_st_disp;\n\n  // Unpack the accelerator response\n  assign acc_trans_id_o       = acc_resp_i.trans_id;\n  assign acc_result_o         = acc_resp_i.result;\n  assign acc_valid_o          = acc_resp_i.resp_valid;\n  assign acc_exception_o      = '{cause: riscv::ILLEGAL_INSTR, tval : '0, valid: acc_resp_i.error};\n  assign acc_fflags_valid_o   = acc_resp_i.fflags_valid;\n  assign acc_fflags_o         = acc_resp_i.fflags;\n  // Always ready to receive responses\n  assign acc_req_o.resp_ready = 1'b1;\n\n  // Signal dispatched load/store to issue stage\n  assign acc_ld_disp          = acc_req_valid && (acc_insn_queue_o.operation == ACCEL_OP_LOAD);\n  assign acc_st_disp          = acc_req_valid && (acc_insn_queue_o.operation == ACCEL_OP_STORE);\n\n  // Cache invalidation\n  assign inval_valid_o        = acc_resp_i.inval_valid;\n  assign inval_addr_o         = acc_resp_i.inval_addr;\n\n  /**************************\n   *  Accelerator commit    *\n   **************************/\n\n  // Instruction can be issued to the (in-order) back-end if\n  // it reached the top of the scoreboard and it hasn't been\n  // issued yet\n  always_comb begin : accelerator_commit\n    acc_commit = 1'b0;\n    if (!commit_instr_i[0].valid && commit_instr_i[0].fu == ACCEL) acc_commit = 1'b1;\n    if (commit_instr_i[0].valid && !commit_instr_i[1].valid && commit_instr_i[1].fu == ACCEL)\n      acc_commit = 1'b1;\n  end\n\n  // Dirty the V state if we are committing anything related to the vector accelerator\n  always_comb begin : dirty_v_state\n    dirty_v_state_o = 1'b0;\n    for (int i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin\n      dirty_v_state_o |= commit_ack_i[i] & (commit_instr_i[i].fu == ACCEL);\n    end\n  end\n\n  assign acc_commit_trans_id = !commit_instr_i[0].valid ? commit_instr_i[0].trans_id\n                                                        : commit_instr_i[1].trans_id;\n\n  /**************************\n   *  Accelerator barriers  *\n   **************************/\n\n  // On a store barrier (i.e. any barrier that requires preceeding stores to complete\n  // before continuing execution), halt execution while there are pending stores in\n  // the accelerator pipeline.\n  logic wait_acc_store_d, wait_acc_store_q;\n  `FF(wait_acc_store_q, wait_acc_store_d, '0)\n\n  // Set on store barrier. Clear when no store is pending.\n  assign wait_acc_store_d = (wait_acc_store_q | commit_st_barrier_i) & acc_resp_i.store_pending;\n  assign ctrl_halt_o      = wait_acc_store_q;\n\n  /**************************\n   *  Load/Store tracking   *\n   **************************/\n\n  // Loads\n  logic       acc_spec_loads_overflow;\n  logic [2:0] acc_spec_loads_pending;\n  logic       acc_disp_loads_overflow;\n  logic [2:0] acc_disp_loads_pending;\n\n  assign acc_no_ld_pending = (acc_spec_loads_pending == 3'b0) && (acc_disp_loads_pending == 3'b0);\n\n  // Count speculative loads. These can still be flushed.\n  counter #(\n      .WIDTH          (3),\n      .STICKY_OVERFLOW(0)\n  ) i_acc_spec_loads (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .clear_i   (flush_ex_i),\n      .en_i      ((acc_valid_d && issue_instr_i.op == ACCEL_OP_LOAD) ^ acc_ld_disp),\n      .load_i    (1'b0),\n      .down_i    (acc_ld_disp),\n      .d_i       ('0),\n      .q_o       (acc_spec_loads_pending),\n      .overflow_o(acc_spec_loads_overflow)\n  );\n\n  // Count dispatched loads. These cannot be flushed anymore.\n  counter #(\n      .WIDTH          (3),\n      .STICKY_OVERFLOW(0)\n  ) i_acc_disp_loads (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .clear_i   (1'b0),\n      .en_i      (acc_ld_disp ^ acc_resp_i.load_complete),\n      .load_i    (1'b0),\n      .down_i    (acc_resp_i.load_complete),\n      .d_i       ('0),\n      .q_o       (acc_disp_loads_pending),\n      .overflow_o(acc_disp_loads_overflow)\n  );\n\n  acc_dispatcher_no_load_overflow :\n  assert property (\n      @(posedge clk_i) disable iff (~rst_ni) (acc_spec_loads_overflow == 1'b0) && (acc_disp_loads_overflow == 1'b0) )\n  else $error(\"[acc_dispatcher] Too many pending loads.\");\n\n  // Stores\n  logic       acc_spec_stores_overflow;\n  logic [2:0] acc_spec_stores_pending;\n  logic       acc_disp_stores_overflow;\n  logic [2:0] acc_disp_stores_pending;\n\n  assign acc_no_st_pending = (acc_spec_stores_pending == 3'b0) && (acc_disp_stores_pending == 3'b0);\n\n  // Count speculative stores. These can still be flushed.\n  counter #(\n      .WIDTH          (3),\n      .STICKY_OVERFLOW(0)\n  ) i_acc_spec_stores (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .clear_i   (flush_ex_i),\n      .en_i      ((acc_valid_d && issue_instr_i.op == ACCEL_OP_STORE) ^ acc_st_disp),\n      .load_i    (1'b0),\n      .down_i    (acc_st_disp),\n      .d_i       ('0),\n      .q_o       (acc_spec_stores_pending),\n      .overflow_o(acc_spec_stores_overflow)\n  );\n\n  // Count dispatched stores. These cannot be flushed anymore.\n  counter #(\n      .WIDTH          (3),\n      .STICKY_OVERFLOW(0)\n  ) i_acc_disp_stores (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .clear_i   (1'b0),\n      .en_i      (acc_st_disp ^ acc_resp_i.store_complete),\n      .load_i    (1'b0),\n      .down_i    (acc_resp_i.store_complete),\n      .d_i       ('0),\n      .q_o       (acc_disp_stores_pending),\n      .overflow_o(acc_disp_stores_overflow)\n  );\n\n  acc_dispatcher_no_store_overflow :\n  assert property (\n      @(posedge clk_i) disable iff (~rst_ni) (acc_spec_stores_overflow == 1'b0) && (acc_disp_stores_overflow == 1'b0) )\n  else $error(\"[acc_dispatcher] Too many pending stores.\");\n\n  /**************************\n   * Tie Off Unused Signals *\n   **************************/\n\n  assign acc_stall_st_pending_o = 1'b0;\n  assign flush_pipeline_o       = 1'b0;\n  assign acc_dcache_req_ports_o = '0;\n\nendmodule : acc_dispatcher\n"}
{"text": "// Copyright 2023 ETH Zurich and University of Bologna.\n// Solderpad Hardware License, Version 0.51, see LICENSE for details.\n// SPDX-License-Identifier: SHL-0.51\n\n// Authors: Matheus Cavalcante <matheusd@iis.ee.ethz.ch>\n//          Nils Wistoff <nwistoff@iis.ee.ethz.ch>\n\n// Package defining the accelerator interface as used by Ara + CVA6\n\npackage acc_pkg;\n\n  // ----------------------\n  // Accelerator Interface\n  // ----------------------\n\n  typedef struct packed {\n    logic                                 req_valid;\n    logic                                 resp_ready;\n    riscv::instruction_t                  insn;\n    riscv::xlen_t                         rs1;\n    riscv::xlen_t                         rs2;\n    fpnew_pkg::roundmode_e                frm;\n    logic [ariane_pkg::TRANS_ID_BITS-1:0] trans_id;\n    logic                                 store_pending;\n    // Invalidation interface\n    logic                                 acc_cons_en;\n    logic                                 inval_ready;\n  } accelerator_req_t;\n\n  typedef struct packed {\n    logic                                 req_ready;\n    logic                                 resp_valid;\n    riscv::xlen_t                         result;\n    logic [ariane_pkg::TRANS_ID_BITS-1:0] trans_id;\n    logic                                 error;\n    // Metadata\n    logic                                 store_pending;\n    logic                                 store_complete;\n    logic                                 load_complete;\n    logic [4:0]                           fflags;\n    logic                                 fflags_valid;\n    // Invalidation interface\n    logic                                 inval_valid;\n    logic [63:0]                          inval_addr;\n  } accelerator_resp_t;\n\nendpackage\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Matthias Baer <baermatt@student.ethz.ch>\n// Author: Igor Loi <igor.loi@unibo.it>\n// Author: Andreas Traber <atraber@student.ethz.ch>\n// Author: Lukas Mueller <lukasmue@student.ethz.ch>\n// Author: Florian Zaruba <zaruabf@iis.ee.ethz.ch>\n//\n// Date: 19.03.2017\n// Description: Ariane ALU based on RI5CY's ALU\n\n\nmodule alu\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // FU data needed to execute instruction - ISSUE_STAGE\n    input fu_data_t fu_data_i,\n    // ALU result - ISSUE_STAGE\n    output riscv::xlen_t result_o,\n    // ALU branch compare result - branch_unit\n    output logic alu_branch_res_o\n);\n\n  riscv::xlen_t                   operand_a_rev;\n  logic         [           31:0] operand_a_rev32;\n  logic         [  riscv::XLEN:0] operand_b_neg;\n  logic         [riscv::XLEN+1:0] adder_result_ext_o;\n  logic                           less;  // handles both signed and unsigned forms\n  logic         [           31:0] rolw;  // Rotate Left Word\n  logic         [           31:0] rorw;  // Rotate Right Word\n  logic [31:0] orcbw, rev8w;\n  logic [  $clog2(riscv::XLEN) : 0] cpop;  // Count Population\n  logic [$clog2(riscv::XLEN)-1 : 0] lz_tz_count;  // Count Leading Zeros\n  logic [                      4:0] lz_tz_wcount;  // Count Leading Zeros Word\n  logic lz_tz_empty, lz_tz_wempty;\n  riscv::xlen_t orcbw_result, rev8w_result;\n\n  // bit reverse operand_a for left shifts and bit counting\n  generate\n    genvar k;\n    for (k = 0; k < riscv::XLEN; k++)\n      assign operand_a_rev[k] = fu_data_i.operand_a[riscv::XLEN-1-k];\n\n    for (k = 0; k < 32; k++) assign operand_a_rev32[k] = fu_data_i.operand_a[31-k];\n  endgenerate\n\n  // ------\n  // Adder\n  // ------\n  logic adder_op_b_negate;\n  logic adder_z_flag;\n  logic [riscv::XLEN:0] adder_in_a, adder_in_b;\n  riscv::xlen_t adder_result;\n  logic [riscv::XLEN-1:0] operand_a_bitmanip, bit_indx;\n\n  always_comb begin\n    adder_op_b_negate = 1'b0;\n\n    unique case (fu_data_i.operation)\n      // ADDER OPS\n      EQ, NE, SUB, SUBW, ANDN, ORN, XNOR: adder_op_b_negate = 1'b1;\n      default: ;\n    endcase\n  end\n\n  always_comb begin\n    operand_a_bitmanip = fu_data_i.operand_a;\n\n    if (CVA6Cfg.RVB) begin\n      if (riscv::IS_XLEN64) begin\n        unique case (fu_data_i.operation)\n          SH1ADDUW:           operand_a_bitmanip = fu_data_i.operand_a[31:0] << 1;\n          SH2ADDUW:           operand_a_bitmanip = fu_data_i.operand_a[31:0] << 2;\n          SH3ADDUW:           operand_a_bitmanip = fu_data_i.operand_a[31:0] << 3;\n          CTZW:               operand_a_bitmanip = operand_a_rev32;\n          ADDUW, CPOPW, CLZW: operand_a_bitmanip = fu_data_i.operand_a[31:0];\n          default:            ;\n        endcase\n      end\n      unique case (fu_data_i.operation)\n        SH1ADD:  operand_a_bitmanip = fu_data_i.operand_a << 1;\n        SH2ADD:  operand_a_bitmanip = fu_data_i.operand_a << 2;\n        SH3ADD:  operand_a_bitmanip = fu_data_i.operand_a << 3;\n        CTZ:     operand_a_bitmanip = operand_a_rev;\n        default: ;\n      endcase\n    end\n  end\n\n  // prepare operand a\n  assign adder_in_a         = {operand_a_bitmanip, 1'b1};\n\n  // prepare operand b\n  assign operand_b_neg      = {fu_data_i.operand_b, 1'b0} ^ {riscv::XLEN + 1{adder_op_b_negate}};\n  assign adder_in_b         = operand_b_neg;\n\n  // actual adder\n  assign adder_result_ext_o = $unsigned(adder_in_a) + $unsigned(adder_in_b);\n  assign adder_result       = adder_result_ext_o[riscv::XLEN:1];\n  assign adder_z_flag       = ~|adder_result;\n\n  // get the right branch comparison result\n  always_comb begin : branch_resolve\n    // set comparison by default\n    alu_branch_res_o = 1'b1;\n    case (fu_data_i.operation)\n      EQ:       alu_branch_res_o = adder_z_flag;\n      NE:       alu_branch_res_o = ~adder_z_flag;\n      LTS, LTU: alu_branch_res_o = less;\n      GES, GEU: alu_branch_res_o = ~less;\n      default:  alu_branch_res_o = 1'b1;\n    endcase\n  end\n\n  // ---------\n  // Shifts\n  // ---------\n\n  // TODO: this can probably optimized significantly\n  logic                         shift_left;  // should we shift left\n  logic                         shift_arithmetic;\n\n  riscv::xlen_t                 shift_amt;  // amount of shift, to the right\n  riscv::xlen_t                 shift_op_a;  // input of the shifter\n  logic         [         31:0] shift_op_a32;  // input to the 32 bit shift operation\n\n  riscv::xlen_t                 shift_result;\n  logic         [         31:0] shift_result32;\n\n  logic         [riscv::XLEN:0] shift_right_result;\n  logic         [         32:0] shift_right_result32;\n\n  riscv::xlen_t                 shift_left_result;\n  logic         [         31:0] shift_left_result32;\n\n  assign shift_amt = fu_data_i.operand_b;\n\n  assign shift_left = (fu_data_i.operation == SLL) | (fu_data_i.operation == SLLW);\n\n  assign shift_arithmetic = (fu_data_i.operation == SRA) | (fu_data_i.operation == SRAW);\n\n  // right shifts, we let the synthesizer optimize this\n  logic [riscv::XLEN:0] shift_op_a_64;\n  logic [32:0] shift_op_a_32;\n\n  // choose the bit reversed or the normal input for shift operand a\n  assign shift_op_a           = shift_left ? operand_a_rev : fu_data_i.operand_a;\n  assign shift_op_a32         = shift_left ? operand_a_rev32 : fu_data_i.operand_a[31:0];\n\n  assign shift_op_a_64        = {shift_arithmetic & shift_op_a[riscv::XLEN-1], shift_op_a};\n  assign shift_op_a_32        = {shift_arithmetic & shift_op_a[31], shift_op_a32};\n\n  assign shift_right_result   = $unsigned($signed(shift_op_a_64) >>> shift_amt[5:0]);\n\n  assign shift_right_result32 = $unsigned($signed(shift_op_a_32) >>> shift_amt[4:0]);\n  // bit reverse the shift_right_result for left shifts\n  genvar j;\n  generate\n    for (j = 0; j < riscv::XLEN; j++)\n      assign shift_left_result[j] = shift_right_result[riscv::XLEN-1-j];\n\n    for (j = 0; j < 32; j++) assign shift_left_result32[j] = shift_right_result32[31-j];\n\n  endgenerate\n\n  assign shift_result   = shift_left ? shift_left_result : shift_right_result[riscv::XLEN-1:0];\n  assign shift_result32 = shift_left ? shift_left_result32 : shift_right_result32[31:0];\n\n  // ------------\n  // Comparisons\n  // ------------\n\n  always_comb begin\n    logic sgn;\n    sgn = 1'b0;\n\n    if ((fu_data_i.operation == SLTS) ||\n            (fu_data_i.operation == LTS)  ||\n            (fu_data_i.operation == GES)  ||\n            (fu_data_i.operation == MAX)  ||\n            (fu_data_i.operation == MIN))\n      sgn = 1'b1;\n\n    less = ($signed({sgn & fu_data_i.operand_a[riscv::XLEN-1], fu_data_i.operand_a}) <\n            $signed({sgn & fu_data_i.operand_b[riscv::XLEN-1], fu_data_i.operand_b}));\n  end\n\n  if (CVA6Cfg.RVB) begin : gen_bitmanip\n    // Count Population + Count population Word\n\n    popcount #(\n        .INPUT_WIDTH(riscv::XLEN)\n    ) i_cpop_count (\n        .data_i    (operand_a_bitmanip),\n        .popcount_o(cpop)\n    );\n\n    // Count Leading/Trailing Zeros\n    // 64b\n    lzc #(\n        .WIDTH(riscv::XLEN),\n        .MODE (1)\n    ) i_clz_64b (\n        .in_i(operand_a_bitmanip),\n        .cnt_o(lz_tz_count),\n        .empty_o(lz_tz_empty)\n    );\n    if (riscv::IS_XLEN64) begin\n      //32b\n      lzc #(\n          .WIDTH(32),\n          .MODE (1)\n      ) i_clz_32b (\n          .in_i(operand_a_bitmanip[31:0]),\n          .cnt_o(lz_tz_wcount),\n          .empty_o(lz_tz_wempty)\n      );\n    end\n  end\n\n  if (CVA6Cfg.RVB) begin : gen_orcbw_rev8w_results\n    assign orcbw = {\n      {8{|fu_data_i.operand_a[31:24]}},\n      {8{|fu_data_i.operand_a[23:16]}},\n      {8{|fu_data_i.operand_a[15:8]}},\n      {8{|fu_data_i.operand_a[7:0]}}\n    };\n    assign rev8w = {\n      {fu_data_i.operand_a[7:0]},\n      {fu_data_i.operand_a[15:8]},\n      {fu_data_i.operand_a[23:16]},\n      {fu_data_i.operand_a[31:24]}\n    };\n    if (riscv::IS_XLEN64) begin : gen_64b\n      assign orcbw_result = {\n        {8{|fu_data_i.operand_a[63:56]}},\n        {8{|fu_data_i.operand_a[55:48]}},\n        {8{|fu_data_i.operand_a[47:40]}},\n        {8{|fu_data_i.operand_a[39:32]}},\n        orcbw\n      };\n      assign rev8w_result = {\n        rev8w,\n        {fu_data_i.operand_a[39:32]},\n        {fu_data_i.operand_a[47:40]},\n        {fu_data_i.operand_a[55:48]},\n        {fu_data_i.operand_a[63:56]}\n      };\n    end else begin : gen_32b\n      assign orcbw_result = orcbw;\n      assign rev8w_result = rev8w;\n    end\n  end\n\n  // -----------\n  // Result MUX\n  // -----------\n  always_comb begin\n    result_o = '0;\n    if (riscv::IS_XLEN64) begin\n      unique case (fu_data_i.operation)\n        // Add word: Ignore the upper bits and sign extend to 64 bit\n        ADDW, SUBW: result_o = {{riscv::XLEN - 32{adder_result[31]}}, adder_result[31:0]};\n        SH1ADDUW, SH2ADDUW, SH3ADDUW: result_o = adder_result;\n        // Shifts 32 bit\n        SLLW, SRLW, SRAW: result_o = {{riscv::XLEN - 32{shift_result32[31]}}, shift_result32[31:0]};\n        default: ;\n      endcase\n    end\n    unique case (fu_data_i.operation)\n      // Standard Operations\n      ANDL, ANDN: result_o = fu_data_i.operand_a & operand_b_neg[riscv::XLEN:1];\n      ORL, ORN: result_o = fu_data_i.operand_a | operand_b_neg[riscv::XLEN:1];\n      XORL, XNOR: result_o = fu_data_i.operand_a ^ operand_b_neg[riscv::XLEN:1];\n      // Adder Operations\n      ADD, SUB, ADDUW, SH1ADD, SH2ADD, SH3ADD: result_o = adder_result;\n      // Shift Operations\n      SLL, SRL, SRA: result_o = (riscv::IS_XLEN64) ? shift_result : shift_result32;\n      // Comparison Operations\n      SLTS, SLTU: result_o = {{riscv::XLEN - 1{1'b0}}, less};\n      default: ;  // default case to suppress unique warning\n    endcase\n\n    if (CVA6Cfg.RVB) begin\n      // Index for Bitwise Rotation\n      bit_indx = 1 << (fu_data_i.operand_b & (riscv::XLEN - 1));\n      // rolw, roriw, rorw\n      rolw = ({{riscv::XLEN-32{1'b0}},fu_data_i.operand_a[31:0]} << fu_data_i.operand_b[4:0]) | ({{riscv::XLEN-32{1'b0}},fu_data_i.operand_a[31:0]} >> (riscv::XLEN-32-fu_data_i.operand_b[4:0]));\n      rorw = ({{riscv::XLEN-32{1'b0}},fu_data_i.operand_a[31:0]} >> fu_data_i.operand_b[4:0]) | ({{riscv::XLEN-32{1'b0}},fu_data_i.operand_a[31:0]} << (riscv::XLEN-32-fu_data_i.operand_b[4:0]));\n      if (riscv::IS_XLEN64) begin\n        unique case (fu_data_i.operation)\n          CLZW, CTZW:\n          result_o = (lz_tz_wempty) ? 32 : {{riscv::XLEN - 5{1'b0}}, lz_tz_wcount};  // change\n          ROLW: result_o = {{riscv::XLEN - 32{rolw[31]}}, rolw};\n          RORW, RORIW: result_o = {{riscv::XLEN - 32{rorw[31]}}, rorw};\n          default: ;\n        endcase\n      end\n      unique case (fu_data_i.operation)\n        // Integer minimum/maximum\n        MAX:  result_o = less ? fu_data_i.operand_b : fu_data_i.operand_a;\n        MAXU: result_o = less ? fu_data_i.operand_b : fu_data_i.operand_a;\n        MIN:  result_o = ~less ? fu_data_i.operand_b : fu_data_i.operand_a;\n        MINU: result_o = ~less ? fu_data_i.operand_b : fu_data_i.operand_a;\n\n        // Single bit instructions operations\n        BCLR, BCLRI: result_o = fu_data_i.operand_a & ~bit_indx;\n        BEXT, BEXTI: result_o = {{riscv::XLEN - 1{1'b0}}, |(fu_data_i.operand_a & bit_indx)};\n        BINV, BINVI: result_o = fu_data_i.operand_a ^ bit_indx;\n        BSET, BSETI: result_o = fu_data_i.operand_a | bit_indx;\n\n        // Count Leading/Trailing Zeros\n        CLZ, CTZ:\n        result_o = (lz_tz_empty) ? ({{riscv::XLEN - $clog2(riscv::XLEN) {1'b0}}, lz_tz_count} + 1) :\n            {{riscv::XLEN - $clog2(riscv::XLEN) {1'b0}}, lz_tz_count};\n\n        // Count population\n        CPOP, CPOPW: result_o = {{(riscv::XLEN - ($clog2(riscv::XLEN) + 1)) {1'b0}}, cpop};\n\n        // Sign and Zero Extend\n        SEXTB: result_o = {{riscv::XLEN - 8{fu_data_i.operand_a[7]}}, fu_data_i.operand_a[7:0]};\n        SEXTH: result_o = {{riscv::XLEN - 16{fu_data_i.operand_a[15]}}, fu_data_i.operand_a[15:0]};\n        ZEXTH: result_o = {{riscv::XLEN - 16{1'b0}}, fu_data_i.operand_a[15:0]};\n\n        // Bitwise Rotation\n        ROL:\n        result_o = (riscv::IS_XLEN64) ? ((fu_data_i.operand_a << fu_data_i.operand_b[5:0]) | (fu_data_i.operand_a >> (riscv::XLEN-fu_data_i.operand_b[5:0]))) : ((fu_data_i.operand_a << fu_data_i.operand_b[4:0]) | (fu_data_i.operand_a >> (riscv::XLEN-fu_data_i.operand_b[4:0])));\n\n        ROR, RORI:\n        result_o = (riscv::IS_XLEN64) ? ((fu_data_i.operand_a >> fu_data_i.operand_b[5:0]) | (fu_data_i.operand_a << (riscv::XLEN-fu_data_i.operand_b[5:0]))) : ((fu_data_i.operand_a >> fu_data_i.operand_b[4:0]) | (fu_data_i.operand_a << (riscv::XLEN-fu_data_i.operand_b[4:0])));\n\n        ORCB: result_o = orcbw_result;\n        REV8: result_o = rev8w_result;\n\n        default:\n        if (fu_data_i.operation == SLLIUW && riscv::IS_XLEN64)\n          result_o = {{riscv::XLEN-32{1'b0}}, fu_data_i.operand_a[31:0]} << fu_data_i.operand_b[5:0];  // Left Shift 32 bit unsigned\n      endcase\n    end\n    if (CVA6Cfg.ZiCondExtEn) begin\n      unique case (fu_data_i.operation)\n        CZERO_EQZ:\n        result_o = (|fu_data_i.operand_b) ? fu_data_i.operand_a : '0;  // move zero to rd if rs2 is equal to zero else rs1\n        CZERO_NEZ:\n        result_o = (|fu_data_i.operand_b) ? '0 : fu_data_i.operand_a; // move zero to rd if rs2 is nonzero else rs1\n        default: ;  // default case to suppress unique warning\n      endcase\n    end\n  end\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 15.09.2018\n// Description: Combinatorial AMO unit\nmodule amo_alu #(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // AMO interface\n    input  ariane_pkg::amo_t        amo_op_i,\n    input  logic             [63:0] amo_operand_a_i,\n    input  logic             [63:0] amo_operand_b_i,\n    output logic             [63:0] amo_result_o      // result of atomic memory operation\n);\n\n  logic [64:0] adder_sum;\n  logic [64:0] adder_operand_a, adder_operand_b;\n\n  assign adder_sum = adder_operand_a + adder_operand_b;\n\n  always_comb begin\n\n    adder_operand_a = $signed(amo_operand_a_i);\n    adder_operand_b = $signed(amo_operand_b_i);\n\n    amo_result_o = amo_operand_b_i;\n\n    unique case (amo_op_i)\n      // the default is to output operand_b\n      ariane_pkg::AMO_SC: ;\n      ariane_pkg::AMO_SWAP: ;\n      ariane_pkg::AMO_ADD: amo_result_o = adder_sum[63:0];\n      ariane_pkg::AMO_AND: amo_result_o = amo_operand_a_i & amo_operand_b_i;\n      ariane_pkg::AMO_OR: amo_result_o = amo_operand_a_i | amo_operand_b_i;\n      ariane_pkg::AMO_XOR: amo_result_o = amo_operand_a_i ^ amo_operand_b_i;\n      ariane_pkg::AMO_MAX: begin\n        adder_operand_b = -$signed(amo_operand_b_i);\n        amo_result_o = adder_sum[64] ? amo_operand_b_i : amo_operand_a_i;\n      end\n      ariane_pkg::AMO_MIN: begin\n        adder_operand_b = -$signed(amo_operand_b_i);\n        amo_result_o = adder_sum[64] ? amo_operand_a_i : amo_operand_b_i;\n      end\n      ariane_pkg::AMO_MAXU: begin\n        adder_operand_a = $unsigned(amo_operand_a_i);\n        adder_operand_b = -$unsigned(amo_operand_b_i);\n        amo_result_o = adder_sum[64] ? amo_operand_b_i : amo_operand_a_i;\n      end\n      ariane_pkg::AMO_MINU: begin\n        adder_operand_a = $unsigned(amo_operand_a_i);\n        adder_operand_b = -$unsigned(amo_operand_b_i);\n        amo_result_o = adder_sum[64] ? amo_operand_a_i : amo_operand_b_i;\n      end\n      default: amo_result_o = '0;\n    endcase\n  end\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 20.09.2018\n// Description: Buffers AMO requests\n// This unit buffers an atomic memory operations for the cache subsyste.\n// Furthermore it handles interfacing with the commit stage\n\nmodule amo_buffer #(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    input logic clk_i,   // Clock\n    input logic rst_ni,  // Asynchronous reset active low\n    input logic flush_i, // pipeline flush\n\n    input logic valid_i,  // AMO is valid\n    output logic ready_o,  // AMO unit is ready\n    input ariane_pkg::amo_t amo_op_i,  // AMO Operation\n    input  logic [riscv::PLEN-1:0]      paddr_i,            // physical address of store which needs to be placed in the queue\n    input riscv::xlen_t data_i,  // data which is placed in the queue\n    input logic [1:0] data_size_i,  // type of request we are making (e.g.: bytes to write)\n    // D$\n    output ariane_pkg::amo_req_t amo_req_o,  // request to cache subsytem\n    input ariane_pkg::amo_resp_t amo_resp_i,  // response from cache subsystem\n    // Auxiliary signals\n    input logic amo_valid_commit_i,  // We have a vaild AMO in the commit stage\n    input logic no_st_pending_i  // there is currently no store pending anymore\n);\n  logic flush_amo_buffer;\n  logic amo_valid;\n\n  typedef struct packed {\n    ariane_pkg::amo_t       op;\n    logic [riscv::PLEN-1:0] paddr;\n    riscv::xlen_t           data;\n    logic [1:0]             size;\n  } amo_op_t;\n\n  amo_op_t amo_data_in, amo_data_out;\n\n  // validate this request as soon as all stores have drained and the AMO is in the commit stage\n  assign amo_req_o.req = no_st_pending_i & amo_valid_commit_i & amo_valid;\n  assign amo_req_o.amo_op = amo_data_out.op;\n  assign amo_req_o.size = amo_data_out.size;\n  assign amo_req_o.operand_a = {{64 - riscv::PLEN{1'b0}}, amo_data_out.paddr};\n  assign amo_req_o.operand_b = {{64 - riscv::XLEN{1'b0}}, amo_data_out.data};\n\n  assign amo_data_in.op = amo_op_i;\n  assign amo_data_in.data = data_i;\n  assign amo_data_in.paddr = paddr_i;\n  assign amo_data_in.size = data_size_i;\n\n  // only flush if we are currently not committing the AMO\n  // e.g.: it is not speculative anymore\n  assign flush_amo_buffer = flush_i & !amo_valid_commit_i;\n\n  fifo_v3 #(\n      .DEPTH(1),\n      .dtype(amo_op_t)\n  ) i_amo_fifo (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .flush_i   (flush_amo_buffer),\n      .testmode_i(1'b0),\n      .full_o    (amo_valid),\n      .empty_o   (ready_o),\n      .usage_o   (),                  // left open\n      .data_i    (amo_data_in),\n      .push_i    (valid_i),\n      .data_o    (amo_data_out),\n      .pop_i     (amo_resp_i.ack)\n  );\n\nendmodule\n"}
{"text": "/* Copyright 2018 ETH Zurich and University of Bologna.\n * Copyright and related rights are licensed under the Solderpad Hardware\n * License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n * or agreed to in writing, software, hardware and materials distributed under\n * this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * File:   ariane_pkg.sv\n * Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>\n * Date:   8.4.2017\n *\n * Description: Contains all the necessary defines for Ariane\n *              in one package.\n */\n\n// this is needed to propagate the\n// configuration in case Ariane is\n// instantiated in OpenPiton\n`ifdef PITON_ARIANE\n`include \"l15.tmp.h\"\n`endif\n\n/// This package contains `functions` and global defines for CVA6.\n/// *Note*: There are some parameters here as well which will eventually be\n/// moved out to favour a fully parameterizable core.\npackage ariane_pkg;\n\n  // TODO: Slowly move those parameters to the new system.\n  localparam NR_SB_ENTRIES = cva6_config_pkg::CVA6ConfigNrScoreboardEntries; // number of scoreboard entries\n  localparam TRANS_ID_BITS = $clog2(\n      NR_SB_ENTRIES\n  );  // depending on the number of scoreboard entries we need that many bits\n      // to uniquely identify the entry in the scoreboard\n  localparam ASID_WIDTH = (riscv::XLEN == 64) ? 16 : 1;\n  localparam BITS_SATURATION_COUNTER = 2;\n\n  localparam ISSUE_WIDTH = 1;\n\n  // depth of store-buffers, this needs to be a power of two\n  localparam logic [2:0] DEPTH_SPEC = 'd4;\n\n  localparam int unsigned DCACHE_TYPE = int'(cva6_config_pkg::CVA6ConfigDcacheType);\n  // if DCACHE_TYPE = cva6_config_pkg::WT\n  // we can use a small commit queue since we have a write buffer in the dcache\n  // we could in principle do without the commit queue in this case, but the timing degrades if we do that due\n  // to longer paths into the commit stage\n  // if DCACHE_TYPE = cva6_config_pkg::WB\n  // allocate more space for the commit buffer to be on the save side, this needs to be a power of two\n  localparam logic [2:0] DEPTH_COMMIT = 'd4;\n\n  localparam bit FPGA_EN = cva6_config_pkg::CVA6ConfigFPGAEn;  // Is FPGA optimization of CV32A6\n\n  localparam bit RVC = cva6_config_pkg::CVA6ConfigCExtEn;  // Is C extension configuration\n\n  // Transprecision float unit\n  localparam int unsigned LAT_COMP_FP32 = 'd2;\n  localparam int unsigned LAT_COMP_FP64 = 'd3;\n  localparam int unsigned LAT_COMP_FP16 = 'd1;\n  localparam int unsigned LAT_COMP_FP16ALT = 'd1;\n  localparam int unsigned LAT_COMP_FP8 = 'd1;\n  localparam int unsigned LAT_DIVSQRT = 'd2;\n  localparam int unsigned LAT_NONCOMP = 'd1;\n  localparam int unsigned LAT_CONV = 'd2;\n\n  localparam riscv::xlen_t OPENHWGROUP_MVENDORID = {{riscv::XLEN - 32{1'b0}}, 32'h0602};\n  localparam riscv::xlen_t ARIANE_MARCHID = {{riscv::XLEN - 32{1'b0}}, 32'd3};\n\n  // 32 registers\n  localparam REG_ADDR_SIZE = 5;\n\n  // Read ports for general purpose register files\n  localparam NR_RGPR_PORTS = 2;\n\n  // static debug hartinfo\n  // debug causes\n  localparam logic [2:0] CauseBreakpoint = 3'h1;\n  localparam logic [2:0] CauseTrigger = 3'h2;\n  localparam logic [2:0] CauseRequest = 3'h3;\n  localparam logic [2:0] CauseSingleStep = 3'h4;\n  // amount of data count registers implemented\n  localparam logic [3:0] DataCount = 4'h2;\n\n  // address where data0-15 is shadowed or if shadowed in a CSR\n  // address of the first CSR used for shadowing the data\n  localparam logic [11:0] DataAddr = 12'h380;  // we are aligned with Rocket here\n  typedef struct packed {\n    logic [31:24] zero1;\n    logic [23:20] nscratch;\n    logic [19:17] zero0;\n    logic         dataaccess;\n    logic [15:12] datasize;\n    logic [11:0]  dataaddr;\n  } hartinfo_t;\n\n  localparam hartinfo_t DebugHartInfo = '{\n      zero1: '0,\n      nscratch: 2,  // Debug module needs at least two scratch regs\n      zero0: '0,\n      dataaccess: 1'b1,  // data registers are memory mapped in the debugger\n      datasize: DataCount,\n      dataaddr: DataAddr\n  };\n\n  // enables a commit log which matches spikes commit log format for easier trace comparison\n  localparam bit ENABLE_SPIKE_COMMIT_LOG = 1'b1;\n\n  // ------------- Dangerous -------------\n  // if set to zero a flush will not invalidate the cache-lines, in a single core environment\n  // where coherence is not necessary this can improve performance. This needs to be switched on\n  // when more than one core is in a system\n  localparam logic INVALIDATE_ON_FLUSH = 1'b1;\n\n`ifdef SPIKE_TANDEM\n  // Spike still places 0 in TVAL for ENV_CALL_* exceptions.\n  // This may eventually go away when Spike starts to handle TVAL for *all* exceptions.\n  localparam bit ZERO_TVAL = 1'b1;\n`else\n  localparam bit ZERO_TVAL = 1'b0;\n`endif\n  // read mask for SSTATUS over MMSTATUS\n  localparam logic [63:0] SMODE_STATUS_READ_MASK = riscv::SSTATUS_UIE\n                                                   | riscv::SSTATUS_SIE\n                                                   | riscv::SSTATUS_SPIE\n                                                   | riscv::SSTATUS_SPP\n                                                   | riscv::SSTATUS_FS\n                                                   | riscv::SSTATUS_XS\n                                                   | riscv::SSTATUS_SUM\n                                                   | riscv::SSTATUS_MXR\n                                                   | riscv::SSTATUS_UPIE\n                                                   | riscv::SSTATUS_SPIE\n                                                   | riscv::SSTATUS_UXL\n                                                   | riscv::SSTATUS_SD;\n\n  localparam logic [63:0] SMODE_STATUS_WRITE_MASK = riscv::SSTATUS_SIE\n                                                    | riscv::SSTATUS_SPIE\n                                                    | riscv::SSTATUS_SPP\n                                                    | riscv::SSTATUS_FS\n                                                    | riscv::SSTATUS_SUM\n                                                    | riscv::SSTATUS_MXR;\n  // ---------------\n  // AXI\n  // ---------------\n\n  localparam FETCH_USER_WIDTH = cva6_config_pkg::CVA6ConfigFetchUserWidth;\n  localparam DATA_USER_WIDTH = cva6_config_pkg::CVA6ConfigDataUserWidth;\n  localparam AXI_USER_EN = cva6_config_pkg::CVA6ConfigDataUserEn | cva6_config_pkg::CVA6ConfigFetchUserEn;\n  localparam AXI_USER_WIDTH = cva6_config_pkg::CVA6ConfigDataUserWidth;\n  localparam DATA_USER_EN = cva6_config_pkg::CVA6ConfigDataUserEn;\n  localparam FETCH_USER_EN = cva6_config_pkg::CVA6ConfigFetchUserEn;\n\n  typedef enum logic {\n    SINGLE_REQ,\n    CACHE_LINE_REQ\n  } ad_req_t;\n\n  // ---------------\n  // Fetch Stage\n  // ---------------\n\n  // leave as is (fails with >8 entries and wider fetch width)\n  localparam int unsigned FETCH_FIFO_DEPTH = 4;\n  localparam int unsigned FETCH_WIDTH = 32;\n  // maximum instructions we can fetch on one request (we support compressed instructions)\n  localparam int unsigned INSTR_PER_FETCH = RVC == 1'b1 ? (FETCH_WIDTH / 16) : 1;\n  localparam int unsigned LOG2_INSTR_PER_FETCH = RVC == 1'b1 ? $clog2(INSTR_PER_FETCH) : 1;\n\n  // Only use struct when signals have same direction\n  // exception\n  typedef struct packed {\n    riscv::xlen_t cause;  // cause of exception\n    riscv::xlen_t       tval;  // additional information of causing exception (e.g.: instruction causing it),\n    // address of LD/ST fault\n    logic valid;\n  } exception_t;\n\n  typedef enum logic [2:0] {\n    NoCF,    // No control flow prediction\n    Branch,  // Branch\n    Jump,    // Jump to address from immediate\n    JumpR,   // Jump to address from registers\n    Return   // Return Address Prediction\n  } cf_t;\n\n  // branch-predict\n  // this is the struct we get back from ex stage and we will use it to update\n  // all the necessary data structures\n  // bp_resolve_t\n  typedef struct packed {\n    logic                   valid;           // prediction with all its values is valid\n    logic [riscv::VLEN-1:0] pc;              // PC of predict or mis-predict\n    logic [riscv::VLEN-1:0] target_address;  // target address at which to jump, or not\n    logic                   is_mispredict;   // set if this was a mis-predict\n    logic                   is_taken;        // branch is taken\n    cf_t                    cf_type;         // Type of control flow change\n  } bp_resolve_t;\n\n  // branchpredict scoreboard entry\n  // this is the struct which we will inject into the pipeline to guide the various\n  // units towards the correct branch decision and resolve\n  typedef struct packed {\n    cf_t                    cf;               // type of control flow prediction\n    logic [riscv::VLEN-1:0] predict_address;  // target address at which to jump, or not\n  } branchpredict_sbe_t;\n\n  typedef struct packed {\n    logic                   valid;\n    logic [riscv::VLEN-1:0] pc;              // update at PC\n    logic [riscv::VLEN-1:0] target_address;\n  } btb_update_t;\n\n  typedef struct packed {\n    logic                   valid;\n    logic [riscv::VLEN-1:0] target_address;\n  } btb_prediction_t;\n\n  typedef struct packed {\n    logic                   valid;\n    logic [riscv::VLEN-1:0] ra;\n  } ras_t;\n\n  typedef struct packed {\n    logic                   valid;\n    logic [riscv::VLEN-1:0] pc;     // update at PC\n    logic                   taken;\n  } bht_update_t;\n\n  typedef struct packed {\n    logic valid;\n    logic taken;\n  } bht_prediction_t;\n\n  typedef struct packed {\n    logic       valid;\n    logic [1:0] saturation_counter;\n  } bht_t;\n\n  typedef enum logic [3:0] {\n    NONE,       // 0\n    LOAD,       // 1\n    STORE,      // 2\n    ALU,        // 3\n    CTRL_FLOW,  // 4\n    MULT,       // 5\n    CSR,        // 6\n    FPU,        // 7\n    FPU_VEC,    // 8\n    CVXIF,      // 9\n    ACCEL       // 10\n  } fu_t;\n\n  localparam EXC_OFF_RST = 8'h80;\n\n  localparam SupervisorIrq = 1;\n  localparam MachineIrq = 0;\n\n  // All information needed to determine whether we need to associate an interrupt\n  // with the corresponding instruction or not.\n  typedef struct packed {\n    riscv::xlen_t mie;\n    riscv::xlen_t mip;\n    riscv::xlen_t mideleg;\n    logic         sie;\n    logic         global_enable;\n  } irq_ctrl_t;\n\n  // ---------------\n  // Cache config\n  // ---------------\n\n  // for usage in OpenPiton we have to propagate the openpiton L15 configuration from l15.h\n`ifdef PITON_ARIANE\n\n`ifndef CONFIG_L1I_CACHELINE_WIDTH\n  `define CONFIG_L1I_CACHELINE_WIDTH 128\n`endif\n\n`ifndef CONFIG_L1I_ASSOCIATIVITY\n  `define CONFIG_L1I_ASSOCIATIVITY 4\n`endif\n\n`ifndef CONFIG_L1I_SIZE\n  `define CONFIG_L1I_SIZE 16*1024\n`endif\n\n`ifndef CONFIG_L1D_CACHELINE_WIDTH\n  `define CONFIG_L1D_CACHELINE_WIDTH 128\n`endif\n\n`ifndef CONFIG_L1D_ASSOCIATIVITY\n  `define CONFIG_L1D_ASSOCIATIVITY 8\n`endif\n\n`ifndef CONFIG_L1D_SIZE\n  `define CONFIG_L1D_SIZE 32*1024\n`endif\n\n`ifndef L15_THREADID_WIDTH\n  `define L15_THREADID_WIDTH 3\n`endif\n\n  // I$\n  localparam int unsigned ICACHE_LINE_WIDTH = `CONFIG_L1I_CACHELINE_WIDTH;\n  localparam int unsigned ICACHE_SET_ASSOC = `CONFIG_L1I_ASSOCIATIVITY;\n  localparam int unsigned ICACHE_INDEX_WIDTH = $clog2(`CONFIG_L1I_SIZE / ICACHE_SET_ASSOC);\n  localparam int unsigned ICACHE_TAG_WIDTH = riscv::PLEN - ICACHE_INDEX_WIDTH;\n  localparam int unsigned ICACHE_USER_LINE_WIDTH = (AXI_USER_WIDTH == 1) ? 4 : 128;  // in bit\n  // D$\n  localparam int unsigned DCACHE_LINE_WIDTH = `CONFIG_L1D_CACHELINE_WIDTH;\n  localparam int unsigned DCACHE_SET_ASSOC = `CONFIG_L1D_ASSOCIATIVITY;\n  localparam int unsigned DCACHE_INDEX_WIDTH = $clog2(`CONFIG_L1D_SIZE / DCACHE_SET_ASSOC);\n  localparam int unsigned DCACHE_TAG_WIDTH = riscv::PLEN - DCACHE_INDEX_WIDTH;\n  localparam int unsigned DCACHE_USER_LINE_WIDTH = (AXI_USER_WIDTH == 1) ? 4 : 128;  // in bit\n  localparam int unsigned DCACHE_USER_WIDTH = DATA_USER_WIDTH;\n\n  localparam int unsigned MEM_TID_WIDTH = `L15_THREADID_WIDTH;\n`else\n  // I$\n  localparam int unsigned CONFIG_L1I_SIZE = cva6_config_pkg::CVA6ConfigIcacheByteSize;  // in byte\n  localparam int unsigned ICACHE_SET_ASSOC   = cva6_config_pkg::CVA6ConfigIcacheSetAssoc; // number of ways\n  localparam int unsigned ICACHE_INDEX_WIDTH = $clog2(\n      CONFIG_L1I_SIZE / ICACHE_SET_ASSOC\n  );  // in bit, contains also offset width\n  localparam int unsigned ICACHE_TAG_WIDTH = riscv::PLEN - ICACHE_INDEX_WIDTH;  // in bit\n  localparam int unsigned ICACHE_LINE_WIDTH = cva6_config_pkg::CVA6ConfigIcacheLineWidth;  // in bit\n  localparam int unsigned ICACHE_USER_LINE_WIDTH  = (AXI_USER_WIDTH == 1) ? 4 : cva6_config_pkg::CVA6ConfigIcacheLineWidth; // in bit\n  // D$\n  localparam int unsigned CONFIG_L1D_SIZE = cva6_config_pkg::CVA6ConfigDcacheByteSize;  // in byte\n  localparam int unsigned DCACHE_SET_ASSOC   = cva6_config_pkg::CVA6ConfigDcacheSetAssoc; // number of ways\n  localparam int unsigned DCACHE_INDEX_WIDTH = $clog2(\n      CONFIG_L1D_SIZE / DCACHE_SET_ASSOC\n  );  // in bit, contains also offset width\n  localparam int unsigned DCACHE_TAG_WIDTH = riscv::PLEN - DCACHE_INDEX_WIDTH;  // in bit\n  localparam int unsigned DCACHE_LINE_WIDTH = cva6_config_pkg::CVA6ConfigDcacheLineWidth;  // in bit\n  localparam int unsigned DCACHE_USER_LINE_WIDTH  = (AXI_USER_WIDTH == 1) ? 4 : cva6_config_pkg::CVA6ConfigDcacheLineWidth; // in bit\n  localparam int unsigned DCACHE_USER_WIDTH = DATA_USER_WIDTH;\n\n  localparam int unsigned MEM_TID_WIDTH = cva6_config_pkg::CVA6ConfigMemTidWidth;\n`endif\n\n  localparam int unsigned DCACHE_TID_WIDTH = cva6_config_pkg::CVA6ConfigDcacheIdWidth;\n\n  localparam int unsigned WT_DCACHE_WBUF_DEPTH = cva6_config_pkg::CVA6ConfigWtDcacheWbufDepth;\n\n  // ---------------\n  // EX Stage\n  // ---------------\n\n  typedef enum logic [7:0] {  // basic ALU op\n    ADD,\n    SUB,\n    ADDW,\n    SUBW,\n    // logic operations\n    XORL,\n    ORL,\n    ANDL,\n    // shifts\n    SRA,\n    SRL,\n    SLL,\n    SRLW,\n    SLLW,\n    SRAW,\n    // comparisons\n    LTS,\n    LTU,\n    GES,\n    GEU,\n    EQ,\n    NE,\n    // jumps\n    JALR,\n    BRANCH,\n    // set lower than operations\n    SLTS,\n    SLTU,\n    // CSR functions\n    MRET,\n    SRET,\n    DRET,\n    ECALL,\n    WFI,\n    FENCE,\n    FENCE_I,\n    SFENCE_VMA,\n    CSR_WRITE,\n    CSR_READ,\n    CSR_SET,\n    CSR_CLEAR,\n    // LSU functions\n    LD,\n    SD,\n    LW,\n    LWU,\n    SW,\n    LH,\n    LHU,\n    SH,\n    LB,\n    SB,\n    LBU,\n    // Atomic Memory Operations\n    AMO_LRW,\n    AMO_LRD,\n    AMO_SCW,\n    AMO_SCD,\n    AMO_SWAPW,\n    AMO_ADDW,\n    AMO_ANDW,\n    AMO_ORW,\n    AMO_XORW,\n    AMO_MAXW,\n    AMO_MAXWU,\n    AMO_MINW,\n    AMO_MINWU,\n    AMO_SWAPD,\n    AMO_ADDD,\n    AMO_ANDD,\n    AMO_ORD,\n    AMO_XORD,\n    AMO_MAXD,\n    AMO_MAXDU,\n    AMO_MIND,\n    AMO_MINDU,\n    // Multiplications\n    MUL,\n    MULH,\n    MULHU,\n    MULHSU,\n    MULW,\n    // Divisions\n    DIV,\n    DIVU,\n    DIVW,\n    DIVUW,\n    REM,\n    REMU,\n    REMW,\n    REMUW,\n    // Floating-Point Load and Store Instructions\n    FLD,\n    FLW,\n    FLH,\n    FLB,\n    FSD,\n    FSW,\n    FSH,\n    FSB,\n    // Floating-Point Computational Instructions\n    FADD,\n    FSUB,\n    FMUL,\n    FDIV,\n    FMIN_MAX,\n    FSQRT,\n    FMADD,\n    FMSUB,\n    FNMSUB,\n    FNMADD,\n    // Floating-Point Conversion and Move Instructions\n    FCVT_F2I,\n    FCVT_I2F,\n    FCVT_F2F,\n    FSGNJ,\n    FMV_F2X,\n    FMV_X2F,\n    // Floating-Point Compare Instructions\n    FCMP,\n    // Floating-Point Classify Instruction\n    FCLASS,\n    // Vectorial Floating-Point Instructions that don't directly map onto the scalar ones\n    VFMIN,\n    VFMAX,\n    VFSGNJ,\n    VFSGNJN,\n    VFSGNJX,\n    VFEQ,\n    VFNE,\n    VFLT,\n    VFGE,\n    VFLE,\n    VFGT,\n    VFCPKAB_S,\n    VFCPKCD_S,\n    VFCPKAB_D,\n    VFCPKCD_D,\n    // Offload Instructions to be directed into cv_x_if\n    OFFLOAD,\n    // Or-Combine and REV8\n    ORCB,\n    REV8,\n    // Bitwise Rotation\n    ROL,\n    ROLW,\n    ROR,\n    RORI,\n    RORIW,\n    RORW,\n    // Sign and Zero Extend\n    SEXTB,\n    SEXTH,\n    ZEXTH,\n    // Count population\n    CPOP,\n    CPOPW,\n    // Count Leading/Training Zeros\n    CLZ,\n    CLZW,\n    CTZ,\n    CTZW,\n    // Carry less multiplication Op's\n    CLMUL,\n    CLMULH,\n    CLMULR,\n    // Single bit instructions Op's\n    BCLR,\n    BCLRI,\n    BEXT,\n    BEXTI,\n    BINV,\n    BINVI,\n    BSET,\n    BSETI,\n    // Integer minimum/maximum\n    MAX,\n    MAXU,\n    MIN,\n    MINU,\n    // Shift with Add Unsigned Word and Unsigned Word Op's (Bitmanip)\n    SH1ADDUW,\n    SH2ADDUW,\n    SH3ADDUW,\n    ADDUW,\n    SLLIUW,\n    // Shift with Add (Bitmanip)\n    SH1ADD,\n    SH2ADD,\n    SH3ADD,\n    // Bitmanip Logical with negate op (Bitmanip)\n    ANDN,\n    ORN,\n    XNOR,\n    // Accelerator operations\n    ACCEL_OP,\n    ACCEL_OP_FS1,\n    ACCEL_OP_FD,\n    ACCEL_OP_LOAD,\n    ACCEL_OP_STORE,\n    // Zicond instruction\n    CZERO_EQZ,\n    CZERO_NEZ\n  } fu_op;\n\n  typedef struct packed {\n    fu_t                      fu;\n    fu_op                     operation;\n    riscv::xlen_t             operand_a;\n    riscv::xlen_t             operand_b;\n    riscv::xlen_t             imm;\n    logic [TRANS_ID_BITS-1:0] trans_id;\n  } fu_data_t;\n\n  function automatic logic op_is_branch(input fu_op op);\n    unique case (op) inside\n      EQ, NE, LTS, GES, LTU, GEU: return 1'b1;\n      default:                    return 1'b0;  // all other ops\n    endcase\n  endfunction\n\n  // -------------------------------\n  // Extract Src/Dst FP Reg from Op\n  // -------------------------------\n  // function used in instr_trace svh\n  // is_rs1_fpr function is kept to allow cva6 compilation with instr_trace feature\n  function automatic logic is_rs1_fpr(input fu_op op);\n    unique case (op) inside\n      [FMUL : FNMADD],  // Computational Operations (except ADD/SUB)\n      FCVT_F2I,  // Float-Int Casts\n      FCVT_F2F,  // Float-Float Casts\n      FSGNJ,  // Sign Injections\n      FMV_F2X,  // FPR-GPR Moves\n      FCMP,  // Comparisons\n      FCLASS,  // Classifications\n      [VFMIN : VFCPKCD_D],  // Additional Vectorial FP ops\n      ACCEL_OP_FS1:\n      return 1'b1;  // Accelerator instructions\n      default: return 1'b0;  // all other ops\n    endcase\n  endfunction\n\n  // function used in instr_trace svh\n  // is_rs2_fpr function is kept to allow cva6 compilation with instr_trace feature\n  function automatic logic is_rs2_fpr(input fu_op op);\n    unique case (op) inside\n      [FSD : FSB],  // FP Stores\n      [FADD : FMIN_MAX],  // Computational Operations (no sqrt)\n      [FMADD : FNMADD],  // Fused Computational Operations\n      FCVT_F2F,  // Vectorial F2F Conversions requrie target\n      [FSGNJ : FMV_F2X],  // Sign Injections and moves mapped to SGNJ\n      FCMP,  // Comparisons\n      [VFMIN : VFCPKCD_D]:\n      return 1'b1;  // Additional Vectorial FP ops\n      default: return 1'b0;  // all other ops\n    endcase\n  endfunction\n\n  // function used in instr_trace svh\n  // is_imm_fpr function is kept to allow cva6 compilation with instr_trace feature\n  // ternary operations encode the rs3 address in the imm field, also add/sub\n  function automatic logic is_imm_fpr(input fu_op op);\n    unique case (op) inside\n      [FADD : FSUB],  // ADD/SUB need inputs as Operand B/C\n      [FMADD : FNMADD],  // Fused Computational Operations\n      [VFCPKAB_S : VFCPKCD_D]:\n      return 1'b1;  // Vectorial FP cast and pack ops\n      default: return 1'b0;  // all other ops\n    endcase\n  endfunction\n\n  // function used in instr_trace svh\n  // is_rd_fpr function is kept to allow cva6 compilation with instr_trace feature\n  function automatic logic is_rd_fpr(input fu_op op);\n    unique case (op) inside\n      [FLD : FLB],  // FP Loads\n      [FADD : FNMADD],  // Computational Operations\n      FCVT_I2F,  // Int-Float Casts\n      FCVT_F2F,  // Float-Float Casts\n      FSGNJ,  // Sign Injections\n      FMV_X2F,  // GPR-FPR Moves\n      [VFMIN : VFSGNJX],  // Vectorial MIN/MAX and SGNJ\n      [VFCPKAB_S"}
{"text": " : VFCPKCD_D],  // Vectorial FP cast and pack ops\n      ACCEL_OP_FD:\n      return 1'b1;  // Accelerator instructions\n      default: return 1'b0;  // all other ops\n    endcase\n  endfunction\n\n  function automatic logic is_amo(fu_op op);\n    case (op) inside\n      [AMO_LRW : AMO_MINDU]: begin\n        return 1'b1;\n      end\n      default: return 1'b0;\n    endcase\n  endfunction\n\n  typedef struct packed {\n    logic                       valid;\n    logic [riscv::VLEN-1:0]     vaddr;\n    logic                       overflow;\n    riscv::xlen_t               data;\n    logic [(riscv::XLEN/8)-1:0] be;\n    fu_t                        fu;\n    fu_op                       operation;\n    logic [TRANS_ID_BITS-1:0]   trans_id;\n  } lsu_ctrl_t;\n\n  // ---------------\n  // IF/ID Stage\n  // ---------------\n  // store the decompressed instruction\n  typedef struct packed {\n    logic [riscv::VLEN-1:0] address;  // the address of the instructions from below\n    logic [31:0] instruction;  // instruction word\n    branchpredict_sbe_t     branch_predict; // this field contains branch prediction information regarding the forward branch path\n    exception_t             ex;             // this field contains exceptions which might have happened earlier, e.g.: fetch exceptions\n  } fetch_entry_t;\n\n  // ---------------\n  // ID/EX/WB Stage\n  // ---------------\n\n  typedef struct packed {\n    logic [riscv::VLEN-1:0] pc;  // PC of instruction\n    logic [TRANS_ID_BITS-1:0] trans_id;      // this can potentially be simplified, we could index the scoreboard entry\n                                             // with the transaction id in any case make the width more generic\n    fu_t fu;  // functional unit to use\n    fu_op op;  // operation to perform in each functional unit\n    logic [REG_ADDR_SIZE-1:0] rs1;  // register source address 1\n    logic [REG_ADDR_SIZE-1:0] rs2;  // register source address 2\n    logic [REG_ADDR_SIZE-1:0] rd;  // register destination address\n    riscv::xlen_t result;  // for unfinished instructions this field also holds the immediate,\n                           // for unfinished floating-point that are partly encoded in rs2, this field also holds rs2\n                           // for unfinished floating-point fused operations (FMADD, FMSUB, FNMADD, FNMSUB)\n                           // this field holds the address of the third operand from the floating-point register file\n    logic valid;  // is the result valid\n    logic use_imm;  // should we use the immediate as operand b?\n    logic use_zimm;  // use zimm as operand a\n    logic use_pc;  // set if we need to use the PC as operand a, PC from exception\n    exception_t ex;  // exception has occurred\n    branchpredict_sbe_t bp;  // branch predict scoreboard data structure\n    logic                     is_compressed; // signals a compressed instructions, we need this information at the commit stage if\n                                             // we want jump accordingly e.g.: +4, +2\n    logic vfp;  // is this a vector floating-point instruction?\n  } scoreboard_entry_t;\n\n  // ---------------\n  // MMU instanciation\n  // ---------------\n  localparam bit MMU_PRESENT = cva6_config_pkg::CVA6ConfigMmuPresent;\n\n  localparam int unsigned INSTR_TLB_ENTRIES = cva6_config_pkg::CVA6ConfigInstrTlbEntries;\n  localparam int unsigned DATA_TLB_ENTRIES = cva6_config_pkg::CVA6ConfigDataTlbEntries;\n\n  // -------------------\n  // Performance counter\n  // -------------------\n  localparam bit PERF_COUNTER_EN = cva6_config_pkg::CVA6ConfigPerfCounterEn;\n  localparam int unsigned MHPMCounterNum = 6;\n\n  // --------------------\n  // Atomics\n  // --------------------\n  typedef enum logic [3:0] {\n    AMO_NONE = 4'b0000,\n    AMO_LR   = 4'b0001,\n    AMO_SC   = 4'b0010,\n    AMO_SWAP = 4'b0011,\n    AMO_ADD  = 4'b0100,\n    AMO_AND  = 4'b0101,\n    AMO_OR   = 4'b0110,\n    AMO_XOR  = 4'b0111,\n    AMO_MAX  = 4'b1000,\n    AMO_MAXU = 4'b1001,\n    AMO_MIN  = 4'b1010,\n    AMO_MINU = 4'b1011,\n    AMO_CAS1 = 4'b1100,  // unused, not part of riscv spec, but provided in OpenPiton\n    AMO_CAS2 = 4'b1101   // unused, not part of riscv spec, but provided in OpenPiton\n  } amo_t;\n\n  typedef struct packed {\n    logic                  valid;    // valid flag\n    logic                  is_2M;    //\n    logic                  is_1G;    //\n    logic [27-1:0]         vpn;      // VPN (39bits) = 27bits + 12bits offset\n    logic [ASID_WIDTH-1:0] asid;\n    riscv::pte_t           content;\n  } tlb_update_t;\n\n  // Bits required for representation of physical address space as 4K pages\n  // (e.g. 27*4K == 39bit address space).\n  localparam PPN4K_WIDTH = 38;\n\n  typedef struct packed {\n    logic             valid;    // valid flag\n    logic             is_4M;    //\n    logic [20-1:0]    vpn;      //VPN (32bits) = 20bits + 12bits offset\n    logic [9-1:0]     asid;     //ASID length = 9 for Sv32 mmu\n    riscv::pte_sv32_t content;\n  } tlb_update_sv32_t;\n\n  typedef enum logic [1:0] {\n    FE_NONE,\n    FE_INSTR_ACCESS_FAULT,\n    FE_INSTR_PAGE_FAULT\n  } frontend_exception_t;\n\n  // ----------------------\n  // cache request ports\n  // ----------------------\n  // I$ address translation requests\n  typedef struct packed {\n    logic                   fetch_valid;      // address translation valid\n    logic [riscv::PLEN-1:0] fetch_paddr;      // physical address in\n    exception_t             fetch_exception;  // exception occurred during fetch\n  } icache_areq_t;\n\n  typedef struct packed {\n    logic                   fetch_req;    // address translation request\n    logic [riscv::VLEN-1:0] fetch_vaddr;  // virtual address out\n  } icache_arsp_t;\n\n  // I$ data requests\n  typedef struct packed {\n    logic                   req;      // we request a new word\n    logic                   kill_s1;  // kill the current request\n    logic                   kill_s2;  // kill the last request\n    logic                   spec;     // request is speculative\n    logic [riscv::VLEN-1:0] vaddr;    // 1st cycle: 12 bit index is taken for lookup\n  } icache_dreq_t;\n\n  typedef struct packed {\n    logic                        ready;  // icache is ready\n    logic                        valid;  // signals a valid read\n    logic [FETCH_WIDTH-1:0]      data;   // 2+ cycle out: tag\n    logic [FETCH_USER_WIDTH-1:0] user;   // User bits\n    logic [riscv::VLEN-1:0]      vaddr;  // virtual address out\n    exception_t                  ex;     // we've encountered an exception\n  } icache_drsp_t;\n\n  // AMO request going to cache. this request is unconditionally valid as soon\n  // as request goes high.\n  // Furthermore, those signals are kept stable until the response indicates\n  // completion by asserting ack.\n  typedef struct packed {\n    logic        req;        // this request is valid\n    amo_t        amo_op;     // atomic memory operation to perform\n    logic [1:0]  size;       // 2'b10 --> word operation, 2'b11 --> double word operation\n    logic [63:0] operand_a;  // address\n    logic [63:0] operand_b;  // data as layouted in the register\n  } amo_req_t;\n\n  // AMO response coming from cache.\n  typedef struct packed {\n    logic        ack;     // response is valid\n    logic [63:0] result;  // sign-extended, result\n  } amo_resp_t;\n\n  // D$ data requests\n  typedef struct packed {\n    logic [DCACHE_INDEX_WIDTH-1:0] address_index;\n    logic [DCACHE_TAG_WIDTH-1:0]   address_tag;\n    riscv::xlen_t                  data_wdata;\n    logic [DCACHE_USER_WIDTH-1:0]  data_wuser;\n    logic                          data_req;\n    logic                          data_we;\n    logic [(riscv::XLEN/8)-1:0]    data_be;\n    logic [1:0]                    data_size;\n    logic [DCACHE_TID_WIDTH-1:0]   data_id;\n    logic                          kill_req;\n    logic                          tag_valid;\n  } dcache_req_i_t;\n\n  typedef struct packed {\n    logic                         data_gnt;\n    logic                         data_rvalid;\n    logic [DCACHE_TID_WIDTH-1:0]  data_rid;\n    riscv::xlen_t                 data_rdata;\n    logic [DCACHE_USER_WIDTH-1:0] data_ruser;\n  } dcache_req_o_t;\n\n  // RVFI instr \n  typedef struct packed {\n    logic [TRANS_ID_BITS-1:0] issue_pointer;\n    logic [cva6_config_pkg::CVA6ConfigNrCommitPorts-1:0][TRANS_ID_BITS-1:0] commit_pointer;\n    logic flush_unissued_instr;\n    logic decoded_instr_valid;\n    logic decoded_instr_ack;\n    logic flush;\n    logic issue_instr_ack;\n    logic fetch_entry_valid;\n    logic [31:0] instruction;\n    logic is_compressed;\n    riscv::xlen_t rs1_forwarding;\n    riscv::xlen_t rs2_forwarding;\n    scoreboard_entry_t [cva6_config_pkg::CVA6ConfigNrCommitPorts-1:0] commit_instr;\n    exception_t ex_commit;\n    riscv::priv_lvl_t priv_lvl;\n    lsu_ctrl_t lsu_ctrl;\n    logic [((cva6_config_pkg::CVA6ConfigCvxifEn || cva6_config_pkg::CVA6ConfigVExtEn) ? 5 : 4)-1:0][riscv::XLEN-1:0] wbdata;\n    logic [cva6_config_pkg::CVA6ConfigNrCommitPorts-1:0] commit_ack;\n    logic [riscv::PLEN-1:0] mem_paddr;\n    logic debug_mode;\n    logic [cva6_config_pkg::CVA6ConfigNrCommitPorts-1:0][riscv::XLEN-1:0] wdata;\n  } rvfi_probes_instr_t;\n\n  // RVFI CSR element\n  typedef struct packed {\n    riscv::xlen_t rdata;\n    riscv::xlen_t rmask;\n    riscv::xlen_t wdata;\n    riscv::xlen_t wmask;\n  } rvfi_csr_elmt_t;\n\n  // RVFI CSR structure\n  typedef struct packed {\n    riscv::fcsr_t fcsr_q;\n    riscv::dcsr_t dcsr_q;\n    riscv::xlen_t dpc_q;\n    riscv::xlen_t dscratch0_q;\n    riscv::xlen_t dscratch1_q;\n    riscv::xlen_t mie_q;\n    riscv::xlen_t mip_q;\n    riscv::xlen_t stvec_q;\n    riscv::xlen_t scounteren_q;\n    riscv::xlen_t sscratch_q;\n    riscv::xlen_t sepc_q;\n    riscv::xlen_t scause_q;\n    riscv::xlen_t stval_q;\n    riscv::satp_t satp_q;\n    riscv::xlen_t mstatus_extended;\n    riscv::xlen_t medeleg_q;\n    riscv::xlen_t mideleg_q;\n    riscv::xlen_t mtvec_q;\n    riscv::xlen_t mcounteren_q;\n    riscv::xlen_t mscratch_q;\n    riscv::xlen_t mepc_q;\n    riscv::xlen_t mcause_q;\n    riscv::xlen_t mtval_q;\n    logic fiom_q;\n    logic [MHPMCounterNum+3-1:0] mcountinhibit_q;\n    logic [63:0] cycle_q;\n    logic [63:0] instret_q;\n    riscv::xlen_t dcache_q;\n    riscv::xlen_t icache_q;\n    riscv::xlen_t acc_cons_q;\n    riscv::pmpcfg_t [15:0] pmpcfg_q;\n    logic [15:0][riscv::PLEN-3:0] pmpaddr_q;\n  } rvfi_probes_csr_t;\n\n  // RVFI CSR structure\n  typedef struct packed {\n    rvfi_csr_elmt_t fflags;\n    rvfi_csr_elmt_t frm;\n    rvfi_csr_elmt_t fcsr;\n    rvfi_csr_elmt_t ftran;\n    rvfi_csr_elmt_t dcsr;\n    rvfi_csr_elmt_t dpc;\n    rvfi_csr_elmt_t dscratch0;\n    rvfi_csr_elmt_t dscratch1;\n    rvfi_csr_elmt_t sstatus;\n    rvfi_csr_elmt_t sie;\n    rvfi_csr_elmt_t sip;\n    rvfi_csr_elmt_t stvec;\n    rvfi_csr_elmt_t scounteren;\n    rvfi_csr_elmt_t sscratch;\n    rvfi_csr_elmt_t sepc;\n    rvfi_csr_elmt_t scause;\n    rvfi_csr_elmt_t stval;\n    rvfi_csr_elmt_t satp;\n    rvfi_csr_elmt_t mstatus;\n    rvfi_csr_elmt_t mstatush;\n    rvfi_csr_elmt_t misa;\n    rvfi_csr_elmt_t medeleg;\n    rvfi_csr_elmt_t mideleg;\n    rvfi_csr_elmt_t mie;\n    rvfi_csr_elmt_t mtvec;\n    rvfi_csr_elmt_t mcounteren;\n    rvfi_csr_elmt_t mscratch;\n    rvfi_csr_elmt_t mepc;\n    rvfi_csr_elmt_t mcause;\n    rvfi_csr_elmt_t mtval;\n    rvfi_csr_elmt_t mip;\n    rvfi_csr_elmt_t menvcfg;\n    rvfi_csr_elmt_t menvcfgh;\n    rvfi_csr_elmt_t mvendorid;\n    rvfi_csr_elmt_t marchid;\n    rvfi_csr_elmt_t mhartid;\n    rvfi_csr_elmt_t mcountinhibit;\n    rvfi_csr_elmt_t mcycle;\n    rvfi_csr_elmt_t mcycleh;\n    rvfi_csr_elmt_t minstret;\n    rvfi_csr_elmt_t minstreth;\n    rvfi_csr_elmt_t cycle;\n    rvfi_csr_elmt_t cycleh;\n    rvfi_csr_elmt_t instret;\n    rvfi_csr_elmt_t instreth;\n    rvfi_csr_elmt_t dcache;\n    rvfi_csr_elmt_t icache;\n    rvfi_csr_elmt_t acc_cons;\n    rvfi_csr_elmt_t pmpcfg0;\n    rvfi_csr_elmt_t pmpcfg1;\n    rvfi_csr_elmt_t pmpcfg2;\n    rvfi_csr_elmt_t pmpcfg3;\n    rvfi_csr_elmt_t [15:0] pmpaddr;\n\n  } rvfi_csr_t;\n\n\n  localparam RVFI = cva6_config_pkg::CVA6ConfigRvfiTrace;\n\n\n\n  // ----------------------\n  // Arithmetic Functions\n  // ----------------------\n  function automatic riscv::xlen_t sext32(logic [31:0] operand);\n    return {{riscv::XLEN - 32{operand[31]}}, operand[31:0]};\n  endfunction\n\n  // ----------------------\n  // Immediate functions\n  // ----------------------\n  function automatic logic [riscv::VLEN-1:0] uj_imm(logic [31:0] instruction_i);\n    return {\n      {44 + riscv::VLEN - 64{instruction_i[31]}},\n      instruction_i[19:12],\n      instruction_i[20],\n      instruction_i[30:21],\n      1'b0\n    };\n  endfunction\n\n  function automatic logic [riscv::VLEN-1:0] i_imm(logic [31:0] instruction_i);\n    return {{52 + riscv::VLEN - 64{instruction_i[31]}}, instruction_i[31:20]};\n  endfunction\n\n  function automatic logic [riscv::VLEN-1:0] sb_imm(logic [31:0] instruction_i);\n    return {\n      {51 + riscv::VLEN - 64{instruction_i[31]}},\n      instruction_i[31],\n      instruction_i[7],\n      instruction_i[30:25],\n      instruction_i[11:8],\n      1'b0\n    };\n  endfunction\n\n  // ----------------------\n  // LSU Functions\n  // ----------------------\n  // align data to address e.g.: shift data to be naturally 64\n  function automatic riscv::xlen_t data_align(logic [2:0] addr, logic [63:0] data);\n    // Set addr[2] to 1'b0 when 32bits\n    logic [ 2:0] addr_tmp = {(addr[2] && riscv::IS_XLEN64), addr[1:0]};\n    logic [63:0] data_tmp = {64{1'b0}};\n    case (addr_tmp)\n      3'b000: data_tmp[riscv::XLEN-1:0] = {data[riscv::XLEN-1:0]};\n      3'b001:\n      data_tmp[riscv::XLEN-1:0] = {data[riscv::XLEN-9:0], data[riscv::XLEN-1:riscv::XLEN-8]};\n      3'b010:\n      data_tmp[riscv::XLEN-1:0] = {data[riscv::XLEN-17:0], data[riscv::XLEN-1:riscv::XLEN-16]};\n      3'b011:\n      data_tmp[riscv::XLEN-1:0] = {data[riscv::XLEN-25:0], data[riscv::XLEN-1:riscv::XLEN-24]};\n      3'b100: data_tmp = {data[31:0], data[63:32]};\n      3'b101: data_tmp = {data[23:0], data[63:24]};\n      3'b110: data_tmp = {data[15:0], data[63:16]};\n      3'b111: data_tmp = {data[7:0], data[63:8]};\n    endcase\n    return data_tmp[riscv::XLEN-1:0];\n  endfunction\n\n  // generate byte enable mask\n  function automatic logic [7:0] be_gen(logic [2:0] addr, logic [1:0] size);\n    case (size)\n      2'b11: begin\n        return 8'b1111_1111;\n      end\n      2'b10: begin\n        case (addr[2:0])\n          3'b000:  return 8'b0000_1111;\n          3'b001:  return 8'b0001_1110;\n          3'b010:  return 8'b0011_1100;\n          3'b011:  return 8'b0111_1000;\n          3'b100:  return 8'b1111_0000;\n          default: ;  // Do nothing\n        endcase\n      end\n      2'b01: begin\n        case (addr[2:0])\n          3'b000:  return 8'b0000_0011;\n          3'b001:  return 8'b0000_0110;\n          3'b010:  return 8'b0000_1100;\n          3'b011:  return 8'b0001_1000;\n          3'b100:  return 8'b0011_0000;\n          3'b101:  return 8'b0110_0000;\n          3'b110:  return 8'b1100_0000;\n          default: ;  // Do nothing\n        endcase\n      end\n      2'b00: begin\n        case (addr[2:0])\n          3'b000: return 8'b0000_0001;\n          3'b001: return 8'b0000_0010;\n          3'b010: return 8'b0000_0100;\n          3'b011: return 8'b0000_1000;\n          3'b100: return 8'b0001_0000;\n          3'b101: return 8'b0010_0000;\n          3'b110: return 8'b0100_0000;\n          3'b111: return 8'b1000_0000;\n        endcase\n      end\n    endcase\n    return 8'b0;\n  endfunction\n\n  function automatic logic [3:0] be_gen_32(logic [1:0] addr, logic [1:0] size);\n    case (size)\n      2'b10: begin\n        return 4'b1111;\n      end\n      2'b01: begin\n        case (addr[1:0])\n          2'b00:   return 4'b0011;\n          2'b01:   return 4'b0110;\n          2'b10:   return 4'b1100;\n          default: ;  // Do nothing\n        endcase\n      end\n      2'b00: begin\n        case (addr[1:0])\n          2'b00: return 4'b0001;\n          2'b01: return 4'b0010;\n          2'b10: return 4'b0100;\n          2'b11: return 4'b1000;\n        endcase\n      end\n      default: return 4'b0;\n    endcase\n    return 4'b0;\n  endfunction\n\n  // ----------------------\n  // Extract Bytes from Op\n  // ----------------------\n  function automatic logic [1:0] extract_transfer_size(fu_op op);\n    case (op)\n      LD, SD, FLD, FSD,\n            AMO_LRD,   AMO_SCD,\n            AMO_SWAPD, AMO_ADDD,\n            AMO_ANDD,  AMO_ORD,\n            AMO_XORD,  AMO_MAXD,\n            AMO_MAXDU, AMO_MIND,\n            AMO_MINDU: begin\n        return 2'b11;\n      end\n      LW, LWU, SW, FLW, FSW,\n            AMO_LRW,   AMO_SCW,\n            AMO_SWAPW, AMO_ADDW,\n            AMO_ANDW,  AMO_ORW,\n            AMO_XORW,  AMO_MAXW,\n            AMO_MAXWU, AMO_MINW,\n            AMO_MINWU: begin\n        return 2'b10;\n      end\n      LH, LHU, SH, FLH, FSH: return 2'b01;\n      LB, LBU, SB, FLB, FSB: return 2'b00;\n      default:               return 2'b11;\n    endcase\n  endfunction\nendpackage\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author:         Antonio Pullini - pullinia@iis.ee.ethz.ch\n//\n// Additional contributions by:\n//                 Sven Stucki - svstucki@student.ethz.ch\n//                 Markus Wegmann - markus.wegmann@technokrat.ch\n//\n// Design Name:    RISC-V register file\n// Project Name:   zero-riscy\n// Language:       SystemVerilog\n//\n// Description:    Register file with 31 or 15x 32 bit wide registers.\n//                 Register 0 is fixed to 0. This register file is based on\n//                 latches and is thus smaller than the flip-flop based RF.\n//\n\nmodule ariane_regfile_lol #(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg       = config_pkg::cva6_cfg_empty,\n    parameter int unsigned           DATA_WIDTH    = 32,\n    parameter int unsigned           NR_READ_PORTS = 2,\n    parameter bit                    ZERO_REG_ZERO = 0\n) (\n    // clock and reset\n    input  logic                                             clk_i,\n    input  logic                                             rst_ni,\n    // disable clock gates for testing\n    input  logic                                             test_en_i,\n    // read port\n    input  logic [        NR_READ_PORTS-1:0][           4:0] raddr_i,\n    output logic [        NR_READ_PORTS-1:0][DATA_WIDTH-1:0] rdata_o,\n    // write port\n    input  logic [CVA6Cfg.NrCommitPorts-1:0][           4:0] waddr_i,\n    input  logic [CVA6Cfg.NrCommitPorts-1:0][DATA_WIDTH-1:0] wdata_i,\n    input  logic [CVA6Cfg.NrCommitPorts-1:0]                 we_i\n);\n\n  localparam ADDR_WIDTH = 5;\n  localparam NUM_WORDS = 2 ** ADDR_WIDTH;\n\n  logic [NUM_WORDS-1:ZERO_REG_ZERO] mem_clocks;\n\n  logic [           DATA_WIDTH-1:0] mem        [NUM_WORDS];\n  logic [CVA6Cfg.NrCommitPorts-1:0][NUM_WORDS-1:1] waddr_onehot, waddr_onehot_q;\n  logic [CVA6Cfg.NrCommitPorts-1:0][DATA_WIDTH-1:0] wdata_q;\n\n\n  // decode addresses\n  for (genvar i = 0; i < NR_READ_PORTS; i++) assign rdata_o[i] = mem[raddr_i[i][ADDR_WIDTH-1:0]];\n\n  always_ff @(posedge clk_i, negedge rst_ni) begin : sample_waddr\n    if (~rst_ni) begin\n      wdata_q <= '0;\n    end else begin\n      for (int unsigned i = 0; i < CVA6Cfg.NrCommitPorts; i++)\n      // enable flipflop will most probably infer clock gating\n      if (we_i[i]) begin\n        wdata_q[i] <= wdata_i[i];\n      end\n      waddr_onehot_q <= waddr_onehot;\n    end\n  end\n\n  // WRITE : Write Address Decoder (WAD), combinatorial process\n  always_comb begin : decode_write_addess\n    for (int unsigned i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin\n      for (int unsigned j = 1; j < NUM_WORDS; j++) begin\n        if (we_i[i] && (waddr_i[i] == j)) waddr_onehot[i][j] = 1'b1;\n        else waddr_onehot[i][j] = 1'b0;\n      end\n    end\n  end\n\n  // WRITE : Clock gating (if integrated clock-gating cells are available)\n  for (genvar x = ZERO_REG_ZERO; x < NUM_WORDS; x++) begin\n\n    logic [CVA6Cfg.NrCommitPorts-1:0] waddr_ored;\n\n    for (genvar i = 0; i < CVA6Cfg.NrCommitPorts; i++) assign waddr_ored[i] = waddr_onehot[i][x];\n\n    cluster_clock_gating i_cg (\n        .clk_i    (clk_i),\n        .en_i     (|waddr_ored),\n        .test_en_i(test_en_i),\n        .clk_o    (mem_clocks[x])\n    );\n  end\n\n  // Generate M = WORDS sequential processes, each of which describes one\n  // word of the memory. The processes are synchronized with the clocks\n  // ClocksxC(i), i = 0, 1, ..., M-1\n  // Use active low, i.e. transparent on low latches as storage elements\n  // Data is sampled on rising clock edge\n\n  // Integer registers\n  always_latch begin : latch_wdata\n    // Note: The assignment has to be done inside this process or Modelsim complains about it\n    if (ZERO_REG_ZERO) mem[0] = '0;\n\n    for (int unsigned i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin\n      for (int unsigned k = ZERO_REG_ZERO; k < NUM_WORDS; k++) begin\n        if (mem_clocks[k] && waddr_onehot_q[i][k]) mem[k] = wdata_q[i];\n      end\n    end\n  end\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Engineer:       Francesco Conti - f.conti@unibo.it\n//\n// Additional contributions by:\n//                 Markus Wegmann - markus.wegmann@technokrat.ch\n//\n// Design Name:    RISC-V register file\n// Project Name:   zero-riscy\n// Language:       SystemVerilog\n//\n// Description:    Register file with 31 or 15x 32 bit wide registers.\n//                 Register 0 is fixed to 0. This register file is based on\n//                 flip flops.\n//\n\nmodule ariane_regfile #(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg       = config_pkg::cva6_cfg_empty,\n    parameter int unsigned           DATA_WIDTH    = 32,\n    parameter int unsigned           NR_READ_PORTS = 2,\n    parameter bit                    ZERO_REG_ZERO = 0\n) (\n    // clock and reset\n    input  logic                                             clk_i,\n    input  logic                                             rst_ni,\n    // disable clock gates for testing\n    input  logic                                             test_en_i,\n    // read port\n    input  logic [        NR_READ_PORTS-1:0][           4:0] raddr_i,\n    output logic [        NR_READ_PORTS-1:0][DATA_WIDTH-1:0] rdata_o,\n    // write port\n    input  logic [CVA6Cfg.NrCommitPorts-1:0][           4:0] waddr_i,\n    input  logic [CVA6Cfg.NrCommitPorts-1:0][DATA_WIDTH-1:0] wdata_i,\n    input  logic [CVA6Cfg.NrCommitPorts-1:0]                 we_i\n);\n\n  localparam ADDR_WIDTH = 5;\n  localparam NUM_WORDS = 2 ** ADDR_WIDTH;\n\n  logic [            NUM_WORDS-1:0][DATA_WIDTH-1:0] mem;\n  logic [CVA6Cfg.NrCommitPorts-1:0][ NUM_WORDS-1:0] we_dec;\n\n\n  always_comb begin : we_decoder\n    for (int unsigned j = 0; j < CVA6Cfg.NrCommitPorts; j++) begin\n      for (int unsigned i = 0; i < NUM_WORDS; i++) begin\n        if (waddr_i[j] == i) we_dec[j][i] = we_i[j];\n        else we_dec[j][i] = 1'b0;\n      end\n    end\n  end\n\n  // loop from 1 to NUM_WORDS-1 as R0 is nil\n  always_ff @(posedge clk_i, negedge rst_ni) begin : register_write_behavioral\n    if (~rst_ni) begin\n      mem <= '{default: '0};\n    end else begin\n      for (int unsigned j = 0; j < CVA6Cfg.NrCommitPorts; j++) begin\n        for (int unsigned i = 0; i < NUM_WORDS; i++) begin\n          if (we_dec[j][i]) begin\n            mem[i] <= wdata_i[j];\n          end\n        end\n        if (ZERO_REG_ZERO) begin\n          mem[0] <= '0;\n        end\n      end\n    end\n  end\n\n  for (genvar i = 0; i < NR_READ_PORTS; i++) begin\n    assign rdata_o[i] = mem[raddr_i[i]];\n  end\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Engineer:       Francesco Conti - f.conti@unibo.it\n//\n// Additional contributions by:\n//                 Markus Wegmann - markus.wegmann@technokrat.ch\n//                 Noam Gallmann - gnoam@live.com\n//                 Felipe Lisboa Malaquias\n//                 Henry Suzukawa\n//\n//\n// Description:    This register file is optimized for implementation on\n//                 FPGAs. The register file features one distributed RAM block per implemented\n//                 sync-write port, each with a parametrized number of async-read ports.\n//                 Read-accesses are multiplexed from the relevant block depending on which block\n//                 was last written to. For that purpose an additional array of registers is\n//                 maintained keeping track of write acesses.\n//\n\nmodule ariane_regfile_fpga #(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg       = config_pkg::cva6_cfg_empty,\n    parameter int unsigned           DATA_WIDTH    = 32,\n    parameter int unsigned           NR_READ_PORTS = 2,\n    parameter bit                    ZERO_REG_ZERO = 0\n) (\n    // clock and reset\n    input  logic                                             clk_i,\n    input  logic                                             rst_ni,\n    // disable clock gates for testing\n    input  logic                                             test_en_i,\n    // read port\n    input  logic [        NR_READ_PORTS-1:0][           4:0] raddr_i,\n    output logic [        NR_READ_PORTS-1:0][DATA_WIDTH-1:0] rdata_o,\n    // write port\n    input  logic [CVA6Cfg.NrCommitPorts-1:0][           4:0] waddr_i,\n    input  logic [CVA6Cfg.NrCommitPorts-1:0][DATA_WIDTH-1:0] wdata_i,\n    input  logic [CVA6Cfg.NrCommitPorts-1:0]                 we_i\n);\n\n  localparam ADDR_WIDTH = 5;\n  localparam NUM_WORDS = 2 ** ADDR_WIDTH;\n  localparam LOG_NR_WRITE_PORTS = CVA6Cfg.NrCommitPorts == 1 ? 1 : $clog2(CVA6Cfg.NrCommitPorts);\n\n  // Distributed RAM usually supports one write port per block - duplicate for each write port.\n  logic [            NUM_WORDS-1:0][        DATA_WIDTH-1:0] mem             [CVA6Cfg.NrCommitPorts];\n\n  logic [CVA6Cfg.NrCommitPorts-1:0][         NUM_WORDS-1:0] we_dec;\n  logic [            NUM_WORDS-1:0][LOG_NR_WRITE_PORTS-1:0] mem_block_sel;\n  logic [            NUM_WORDS-1:0][LOG_NR_WRITE_PORTS-1:0] mem_block_sel_q;\n\n  // write adress decoder (for block selector)\n  always_comb begin\n    for (int unsigned j = 0; j < CVA6Cfg.NrCommitPorts; j++) begin\n      for (int unsigned i = 0; i < NUM_WORDS; i++) begin\n        if (waddr_i[j] == i) begin\n          we_dec[j][i] = we_i[j];\n        end else begin\n          we_dec[j][i] = 1'b0;\n        end\n      end\n    end\n  end\n\n  // update block selector:\n  // signal mem_block_sel records where the current valid value is stored.\n  // if multiple ports try to write to the same address simultaneously, the port with the highest\n  // index has priority.\n  always_comb begin\n    mem_block_sel = mem_block_sel_q;\n    for (int i = 0; i < NUM_WORDS; i++) begin\n      for (int j = 0; j < CVA6Cfg.NrCommitPorts; j++) begin\n        if (we_dec[j][i] == 1'b1) begin\n          mem_block_sel[i] = LOG_NR_WRITE_PORTS'(j);\n        end\n      end\n    end\n  end\n\n  // block selector flops\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      mem_block_sel_q <= '0;\n    end else begin\n      mem_block_sel_q <= mem_block_sel;\n    end\n  end\n\n  // distributed RAM blocks\n  logic [NR_READ_PORTS-1:0][DATA_WIDTH-1:0] mem_read[CVA6Cfg.NrCommitPorts];\n  for (genvar j = 0; j < CVA6Cfg.NrCommitPorts; j++) begin : regfile_ram_block\n    always_ff @(posedge clk_i) begin\n      if (we_i[j] && ~waddr_i[j] != 0) begin\n        mem[j][waddr_i[j]] <= wdata_i[j];\n      end\n    end\n    for (genvar k = 0; k < NR_READ_PORTS; k++) begin : block_read\n      assign mem_read[j][k] = mem[j][raddr_i[k]];\n    end\n  end\n\n  // output MUX\n  logic [NR_READ_PORTS-1:0][LOG_NR_WRITE_PORTS-1:0] block_addr;\n  for (genvar k = 0; k < NR_READ_PORTS; k++) begin : regfile_read_port\n    assign block_addr[k] = mem_block_sel_q[raddr_i[k]];\n    assign rdata_o[k] = (ZERO_REG_ZERO && raddr_i[k] == '0) ? '0 : mem_read[block_addr[k]][k];\n  end\n\n  // random initialization of the memory to suppress assert warnings on Questa.\n  initial begin\n    for (int i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin\n      for (int j = 0; j < NUM_WORDS; j++) begin\n        mem[i][j] = $random();\n      end\n    end\n  end\n\nendmodule\n"}
{"text": "/* Copyright 2018 ETH Zurich and University of Bologna.\n * Copyright and related rights are licensed under the Solderpad Hardware\n * License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n * or agreed to in writing, software, hardware and materials distributed under\n * this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * File:  axi_adapter.sv\n * Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>\n * Date:   1.8.2018\n *\n * Description: Manages communication with the AXI Bus\n */\n//import std_cache_pkg::*;\n\nmodule axi_adapter #(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int unsigned DATA_WIDTH = 256,\n    parameter logic        CRITICAL_WORD_FIRST   = 0, // the AXI subsystem needs to support wrapping reads for this feature\n    parameter int unsigned CACHELINE_BYTE_OFFSET = 8,\n    parameter type axi_req_t = logic,\n    parameter type axi_rsp_t = logic\n) (\n    input logic clk_i,  // Clock\n    input logic rst_ni, // Asynchronous reset active low\n\n    input logic req_i,\n    input ariane_pkg::ad_req_t type_i,\n    input ariane_pkg::amo_t amo_i,\n    output logic gnt_o,\n    input logic [riscv::XLEN-1:0] addr_i,\n    input logic we_i,\n    input logic [(DATA_WIDTH/CVA6Cfg.AxiDataWidth)-1:0][CVA6Cfg.AxiDataWidth-1:0] wdata_i,\n    input logic [(DATA_WIDTH/CVA6Cfg.AxiDataWidth)-1:0][(CVA6Cfg.AxiDataWidth/8)-1:0] be_i,\n    input logic [1:0] size_i,\n    input logic [CVA6Cfg.AxiIdWidth-1:0] id_i,\n    // read port\n    output logic valid_o,\n    output logic [(DATA_WIDTH/CVA6Cfg.AxiDataWidth)-1:0][CVA6Cfg.AxiDataWidth-1:0] rdata_o,\n    output logic [CVA6Cfg.AxiIdWidth-1:0] id_o,\n    // critical word - read port\n    output logic [CVA6Cfg.AxiDataWidth-1:0] critical_word_o,\n    output logic critical_word_valid_o,\n    // AXI port\n    output axi_req_t axi_req_o,\n    input axi_rsp_t axi_resp_i\n);\n  localparam BURST_SIZE = (DATA_WIDTH / CVA6Cfg.AxiDataWidth) - 1;\n  localparam ADDR_INDEX = ($clog2(\n      DATA_WIDTH / CVA6Cfg.AxiDataWidth\n  ) > 0) ? $clog2(\n      DATA_WIDTH / CVA6Cfg.AxiDataWidth\n  ) : 1;\n  localparam MAX_OUTSTANDING_AW = CVA6Cfg.MaxOutstandingStores;\n  localparam MAX_OUTSTANDING_AW_CNT_WIDTH = $clog2(\n      MAX_OUTSTANDING_AW + 1\n  ) > 0 ? $clog2(\n      MAX_OUTSTANDING_AW + 1\n  ) : 1;\n\n  typedef logic [MAX_OUTSTANDING_AW_CNT_WIDTH-1:0] outstanding_aw_cnt_t;\n\n  enum logic [3:0] {\n    IDLE,\n    WAIT_B_VALID,\n    WAIT_AW_READY,\n    WAIT_LAST_W_READY,\n    WAIT_LAST_W_READY_AW_READY,\n    WAIT_AW_READY_BURST,\n    WAIT_R_VALID,\n    WAIT_R_VALID_MULTIPLE,\n    COMPLETE_READ,\n    WAIT_AMO_R_VALID\n  }\n      state_q, state_d;\n\n  // counter for AXI transfers\n  logic [ADDR_INDEX-1:0] cnt_d, cnt_q;\n  logic [(DATA_WIDTH/CVA6Cfg.AxiDataWidth)-1:0][CVA6Cfg.AxiDataWidth-1:0]\n      cache_line_d, cache_line_q;\n  // save the address for a read, as we allow for non-cacheline aligned accesses\n  logic [(DATA_WIDTH/CVA6Cfg.AxiDataWidth)-1:0] addr_offset_d, addr_offset_q;\n  logic [CVA6Cfg.AxiIdWidth-1:0] id_d, id_q;\n  logic [ADDR_INDEX-1:0] index;\n  // save the atomic operation and size\n  ariane_pkg::amo_t amo_d, amo_q;\n  logic [1:0] size_d, size_q;\n  // outstanding write transactions counter\n  outstanding_aw_cnt_t outstanding_aw_cnt_q, outstanding_aw_cnt_d;\n  logic any_outstanding_aw;\n\n  assign any_outstanding_aw = outstanding_aw_cnt_q != '0;\n\n  always_comb begin : axi_fsm\n    // Default assignments\n    axi_req_o.aw_valid  = 1'b0;\n    // Cast to AXI address width\n    axi_req_o.aw.addr   = addr_i;\n    axi_req_o.aw.prot   = 3'b0;\n    axi_req_o.aw.region = 4'b0;\n    axi_req_o.aw.len    = 8'b0;\n    axi_req_o.aw.size   = {1'b0, size_i};  // 1, 2, 4 or 8 bytes\n    axi_req_o.aw.burst  = axi_pkg::BURST_INCR;  // Use BURST_INCR for AXI regular transaction\n    axi_req_o.aw.lock   = 1'b0;\n    axi_req_o.aw.cache  = axi_pkg::CACHE_MODIFIABLE;\n    axi_req_o.aw.qos    = 4'b0;\n    axi_req_o.aw.id     = id_i;\n    axi_req_o.aw.atop   = atop_from_amo(amo_i);\n    axi_req_o.aw.user   = '0;\n\n    axi_req_o.ar_valid  = 1'b0;\n    // Cast to AXI address width\n    axi_req_o.ar.addr   = addr_i;\n    // in case of a single request or wrapping transfer we can simply begin at the address, if we want to request a cache-line\n    // with an incremental transfer we need to output the corresponding base address of the cache line\n    if (!CRITICAL_WORD_FIRST && type_i != ariane_pkg::SINGLE_REQ) begin\n      axi_req_o.ar.addr[CACHELINE_BYTE_OFFSET-1:0] = '0;\n    end\n    axi_req_o.ar.prot = 3'b0;\n    axi_req_o.ar.region = 4'b0;\n    axi_req_o.ar.len = 8'b0;\n    axi_req_o.ar.size = {1'b0, size_i};  // 1, 2, 4 or 8 bytes\n    axi_req_o.ar.burst  = (CRITICAL_WORD_FIRST ? axi_pkg::BURST_WRAP : axi_pkg::BURST_INCR); // wrapping transfer in case of a critical word first strategy\n    axi_req_o.ar.lock = 1'b0;\n    axi_req_o.ar.cache = axi_pkg::CACHE_MODIFIABLE;\n    axi_req_o.ar.qos = 4'b0;\n    axi_req_o.ar.id = id_i;\n    axi_req_o.ar.user = '0;\n\n    axi_req_o.w_valid = 1'b0;\n    axi_req_o.w.data = wdata_i[0];\n    axi_req_o.w.strb = be_i[0];\n    axi_req_o.w.last = 1'b0;\n    axi_req_o.w.user = '0;\n\n    axi_req_o.b_ready = 1'b0;\n    axi_req_o.r_ready = 1'b0;\n\n    gnt_o = 1'b0;\n    valid_o = 1'b0;\n    id_o = axi_resp_i.r.id;\n\n    critical_word_o = axi_resp_i.r.data;\n    critical_word_valid_o = 1'b0;\n    rdata_o = cache_line_q;\n\n    state_d = state_q;\n    cnt_d = cnt_q;\n    cache_line_d = cache_line_q;\n    addr_offset_d = addr_offset_q;\n    id_d = id_q;\n    amo_d = amo_q;\n    size_d = size_q;\n    index = '0;\n\n    outstanding_aw_cnt_d = outstanding_aw_cnt_q;\n\n    case (state_q)\n\n      IDLE: begin\n        cnt_d = '0;\n        // we have an incoming request\n        if (req_i) begin\n          // is this a read or write?\n          // write\n          if (we_i) begin\n            // multiple outstanding write transactions are only\n            // allowed if they are guaranteed not to be reordered\n            // i.e. same ID\n            if (!any_outstanding_aw || ((id_i == id_q) && (amo_i == ariane_pkg::AMO_NONE))) begin\n              // the data is valid\n              axi_req_o.aw_valid = 1'b1;\n              axi_req_o.w_valid  = 1'b1;\n              // store-conditional requires exclusive access\n              axi_req_o.aw.lock  = amo_i == ariane_pkg::AMO_SC;\n              // its a single write\n              if (type_i == ariane_pkg::SINGLE_REQ) begin\n                // only a single write so the data is already the last one\n                axi_req_o.w.last = 1'b1;\n                // single req can be granted here\n                gnt_o = axi_resp_i.aw_ready & axi_resp_i.w_ready;\n                case ({\n                  axi_resp_i.aw_ready, axi_resp_i.w_ready\n                })\n                  2'b11:   state_d = WAIT_B_VALID;\n                  2'b01:   state_d = WAIT_AW_READY;\n                  2'b10:   state_d = WAIT_LAST_W_READY;\n                  default: state_d = IDLE;\n                endcase\n\n                if (axi_resp_i.aw_ready) begin\n                  id_d   = id_i;\n                  amo_d  = amo_i;\n                  size_d = size_i;\n                end\n\n                // its a request for the whole cache line\n              end else begin\n                // bursts of AMOs unsupported\n                assert (amo_i == ariane_pkg::AMO_NONE)\n                else $fatal(\"Bursts of atomic operations are not supported\");\n\n                axi_req_o.aw.len = BURST_SIZE[7:0];  // number of bursts to do\n                axi_req_o.w.data = wdata_i[0];\n                axi_req_o.w.strb = be_i[0];\n\n                if (axi_resp_i.w_ready) cnt_d = BURST_SIZE[ADDR_INDEX-1:0] - 1;\n                else cnt_d = BURST_SIZE[ADDR_INDEX-1:0];\n\n                case ({\n                  axi_resp_i.aw_ready, axi_resp_i.w_ready\n                })\n                  2'b11:   state_d = WAIT_LAST_W_READY;\n                  2'b01:   state_d = WAIT_LAST_W_READY_AW_READY;\n                  2'b10:   state_d = WAIT_LAST_W_READY;\n                  default: ;\n                endcase\n              end\n            end\n            // read\n          end else begin\n            // only multiple outstanding write transactions are allowed\n            if (!any_outstanding_aw) begin\n\n              axi_req_o.ar_valid = 1'b1;\n              // load-reserved requires exclusive access\n              axi_req_o.ar.lock = amo_i == ariane_pkg::AMO_LR;\n\n              gnt_o = axi_resp_i.ar_ready;\n              if (type_i != ariane_pkg::SINGLE_REQ) begin\n                assert (amo_i == ariane_pkg::AMO_NONE)\n                else $fatal(\"Bursts of atomic operations are not supported\");\n\n                axi_req_o.ar.len = BURST_SIZE[7:0];\n                cnt_d = BURST_SIZE[ADDR_INDEX-1:0];\n              end\n\n              if (axi_resp_i.ar_ready) begin\n                state_d = (type_i == ariane_pkg::SINGLE_REQ) ? WAIT_R_VALID : WAIT_R_VALID_MULTIPLE;\n                addr_offset_d = addr_i[ADDR_INDEX-1+3:3];\n              end\n            end\n          end\n        end\n      end\n\n      // ~> from single write\n      WAIT_AW_READY: begin\n        axi_req_o.aw_valid = 1'b1;\n\n        if (axi_resp_i.aw_ready) begin\n          gnt_o   = 1'b1;\n          state_d = WAIT_B_VALID;\n          id_d    = id_i;\n          amo_d   = amo_i;\n          size_d  = size_i;\n        end\n      end\n\n      // ~> we need to wait for an aw_ready and there is at least one outstanding write\n      WAIT_LAST_W_READY_AW_READY: begin\n        axi_req_o.w_valid = 1'b1;\n        axi_req_o.w.last  = (cnt_q == '0);\n        if (type_i == ariane_pkg::SINGLE_REQ) begin\n          axi_req_o.w.data = wdata_i[0];\n          axi_req_o.w.strb = be_i[0];\n        end else begin\n          axi_req_o.w.data = wdata_i[BURST_SIZE[ADDR_INDEX-1:0]-cnt_q];\n          axi_req_o.w.strb = be_i[BURST_SIZE[ADDR_INDEX-1:0]-cnt_q];\n        end\n        axi_req_o.aw_valid = 1'b1;\n        // we are here because we want to write a cache line\n        axi_req_o.aw.len   = BURST_SIZE[7:0];\n        // we got an aw_ready\n        case ({\n          axi_resp_i.aw_ready, axi_resp_i.w_ready\n        })\n          // we got an aw ready\n          2'b01: begin\n            // are there any outstanding transactions?\n            if (cnt_q == 0) state_d = WAIT_AW_READY_BURST;\n            else  // yes, so reduce the count and stay here\n              cnt_d = cnt_q - 1;\n          end\n          2'b10:   state_d = WAIT_LAST_W_READY;\n          2'b11: begin\n            // we are finished\n            if (cnt_q == 0) begin\n              state_d = WAIT_B_VALID;\n              gnt_o   = 1'b1;\n              // there are outstanding transactions\n            end else begin\n              state_d = WAIT_LAST_W_READY;\n              cnt_d   = cnt_q - 1;\n            end\n          end\n          default: ;\n        endcase\n\n      end\n\n      // ~> all data has already been sent, we are only waiting for the aw_ready\n      WAIT_AW_READY_BURST: begin\n        axi_req_o.aw_valid = 1'b1;\n        axi_req_o.aw.len   = BURST_SIZE[7:0];\n\n        if (axi_resp_i.aw_ready) begin\n          state_d = WAIT_B_VALID;\n          gnt_o   = 1'b1;\n        end\n      end\n\n      // ~> from write, there is an outstanding write\n      WAIT_LAST_W_READY: begin\n        axi_req_o.w_valid = 1'b1;\n\n        if (type_i != ariane_pkg::SINGLE_REQ) begin\n          axi_req_o.w.data = wdata_i[BURST_SIZE[ADDR_INDEX-1:0]-cnt_q];\n          axi_req_o.w.strb = be_i[BURST_SIZE[ADDR_INDEX-1:0]-cnt_q];\n        end\n\n        // this is the last write\n        if (cnt_q == '0) begin\n          axi_req_o.w.last = 1'b1;\n          if (axi_resp_i.w_ready) begin\n            state_d = WAIT_B_VALID;\n            gnt_o   = 1'b1;\n          end\n        end else if (axi_resp_i.w_ready) begin\n          cnt_d = cnt_q - 1;\n        end\n      end\n\n      // ~> finish write transaction\n      WAIT_B_VALID: begin\n        id_o = axi_resp_i.b.id;\n\n        // Write is valid\n        if (axi_resp_i.b_valid && !any_outstanding_aw) begin\n          axi_req_o.b_ready = 1'b1;\n\n          // some atomics must wait for read data\n          // we only accept it after accepting bvalid\n          if (amo_returns_data(amo_q)) begin\n            if (axi_resp_i.r_valid) begin\n              // return read data if valid\n              valid_o           = 1'b1;\n              axi_req_o.r_ready = 1'b1;\n              state_d           = IDLE;\n              rdata_o           = axi_resp_i.r.data;\n            end else begin\n              // wait otherwise\n              state_d = WAIT_AMO_R_VALID;\n            end\n          end else begin\n            valid_o = 1'b1;\n            state_d = IDLE;\n\n            // store-conditional response\n            if (amo_q == ariane_pkg::AMO_SC) begin\n              if (axi_resp_i.b.resp == axi_pkg::RESP_EXOKAY) begin\n                // success -> return 0\n                rdata_o = 'b0;\n              end else begin\n                // failure -> when request is 64-bit, return 1;\n                // when request is 32-bit place a 1 in both upper\n                // and lower half words. The right word will be\n                // realigned/masked externally\n                rdata_o = size_q == 2'b10 ? (1'b1 << 32) | 64'b1 : 64'b1;\n              end\n            end\n          end\n          // if the request was not an atomic we can possibly issue\n          // other requests while waiting for the response\n        end else begin\n          if ((amo_q == ariane_pkg::AMO_NONE) && (outstanding_aw_cnt_q != MAX_OUTSTANDING_AW)) begin\n            state_d = IDLE;\n            outstanding_aw_cnt_d = outstanding_aw_cnt_q + 1;\n          end\n        end\n      end\n\n      // ~> some atomics wait for read data\n      WAIT_AMO_R_VALID: begin\n        // acknowledge data and terminate atomic\n        if (axi_resp_i.r_valid) begin\n          axi_req_o.r_ready = 1'b1;\n          state_d           = IDLE;\n          valid_o           = 1'b1;\n          rdata_o           = axi_resp_i.r.data;\n        end\n      end\n\n      // ~> cacheline read, single read\n      WAIT_R_VALID_MULTIPLE, WAIT_R_VALID: begin\n        if (CRITICAL_WORD_FIRST) index = addr_offset_q + (BURST_SIZE[ADDR_INDEX-1:0] - cnt_q);\n        else index = BURST_SIZE[ADDR_INDEX-1:0] - cnt_q;\n\n        // reads are always wrapping here\n        axi_req_o.r_ready = 1'b1;\n        // this is the first read a.k.a the critical word\n        if (axi_resp_i.r_valid) begin\n          if (CRITICAL_WORD_FIRST) begin\n            // this is the first word of a cacheline read, e.g.: the word which was causing the miss\n            if (state_q == WAIT_R_VALID_MULTIPLE && cnt_q == BURST_SIZE) begin\n              critical_word_valid_o = 1'b1;\n              critical_word_o       = axi_resp_i.r.data;\n            end\n          end else begin\n            // check if the address offset matches - then we are getting the critical word\n            if (index == addr_offset_q) begin\n              critical_word_valid_o = 1'b1;\n              critical_word_o       = axi_resp_i.r.data;\n            end\n          end\n\n          // this is the last read\n          if (axi_resp_i.r.last) begin\n            id_d    = axi_resp_i.r.id;\n            state_d = COMPLETE_READ;\n          end\n\n          // save the word\n          if (state_q == WAIT_R_VALID_MULTIPLE) begin\n            cache_line_d[index] = axi_resp_i.r.data;\n\n          end else cache_line_d[0] = axi_resp_i.r.data;\n\n          // Decrease the counter\n          cnt_d = cnt_q - 1;\n        end\n      end\n      // ~> read is complete\n      COMPLETE_READ: begin\n        valid_o = 1'b1;\n        state_d = IDLE;\n        id_o    = id_q;\n      end\n\n      default: state_d = IDLE;\n    endcase\n\n    // This process handles B responses when accepting\n    // multiple outstanding write transactions\n    if (any_outstanding_aw && axi_resp_i.b_valid) begin\n      axi_req_o.b_ready = 1'b1;\n      valid_o = 1'b1;\n      // Right hand side contains non-registered signal as we want\n      // to preserve a possible increment from the WAIT_B_VALID state\n      outstanding_aw_cnt_d = outstanding_aw_cnt_d - 1;\n    end\n  end\n\n  // ----------------\n  // Registers\n  // ----------------\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      // start in flushing state and initialize the memory\n      state_q              <= IDLE;\n      cnt_q                <= '0;\n      cache_line_q         <= '0;\n      addr_offset_q        <= '0;\n      id_q                 <= '0;\n      amo_q                <= ariane_pkg::AMO_NONE;\n      size_q               <= '0;\n      outstanding_aw_cnt_q <= '0;\n    end else begin\n      state_q              <= state_d;\n      cnt_q                <= cnt_d;\n      cache_line_q         <= cache_line_d;\n      addr_offset_q        <= addr_offset_d;\n      id_q                 <= id_d;\n      amo_q                <= amo_d;\n      size_q               <= size_d;\n      outstanding_aw_cnt_q <= outstanding_aw_cnt_d;\n    end\n  end\n\n  function automatic axi_pkg::atop_t atop_from_amo(ariane_pkg::amo_t amo);\n    axi_pkg::atop_t result = 6'b000000;\n\n    unique case (amo)\n      ariane_pkg::AMO_NONE: result = {axi_pkg::ATOP_NONE, 4'b0000};\n      ariane_pkg::AMO_SWAP: result = {axi_pkg::ATOP_ATOMICSWAP};\n      ariane_pkg::AMO_ADD:\n      result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_ADD};\n      ariane_pkg::AMO_AND:\n      result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_CLR};\n      ariane_pkg::AMO_OR:\n      result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_SET};\n      ariane_pkg::AMO_XOR:\n      result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_EOR};\n      ariane_pkg::AMO_MAX:\n      result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_SMAX};\n      ariane_pkg::AMO_MAXU:\n      result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_UMAX};\n      ariane_pkg::AMO_MIN:\n      result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_SMIN};\n      ariane_pkg::AMO_MINU:\n      result = {axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_UMIN};\n      ariane_pkg::AMO_CAS1: result = {axi_pkg::ATOP_NONE, 4'b0000};  // Unsupported\n      ariane_pkg::AMO_CAS2: result = {axi_pkg::ATOP_NONE, 4'b0000};  // Unsupported\n      default: result = 6'b000000;\n    endcase\n\n    return result;\n  endfunction\n\n  function automatic logic amo_returns_data(ariane_pkg::amo_t amo);\n    axi_pkg::atop_t atop = atop_from_amo(amo);\n    logic           is_load = atop[5:4] == axi_pkg::ATOP_ATOMICLOAD;\n    logic           is_swap_or_cmp = atop[5:4] == axi_pkg::ATOP_ATOMICSWAP[5:4];\n    return is_load || is_swap_or_cmp;\n  endfunction\n\nendmodule\n"}
{"text": "/* Copyright 2018 ETH Zurich and University of Bologna.\n * Copyright and related rights are licensed under the Solderpad Hardware\n * License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n * or agreed to in writing, software, hardware and materials distributed under\n * this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * File:  axi_shim.sv\n * Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>\n *         Florian Zaruba <zarubaf@iis.ee.ethz.ch>\n * Date:   1.8.2018\n *\n * Description: Manages communication with the AXI Bus. Note that this unit does not\n *              buffer requests and register the signals.\n *\n */\n\n\nmodule axi_shim #(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int unsigned AxiNumWords = 4, // data width in dwords, this is also the maximum burst length, must be >=2\n    parameter type axi_req_t = logic,\n    parameter type axi_rsp_t = logic\n) (\n    input logic clk_i,  // Clock\n    input logic rst_ni,  // Asynchronous reset active low\n    // read channel\n    // request\n    input logic rd_req_i,\n    output logic rd_gnt_o,\n    input logic [CVA6Cfg.AxiAddrWidth-1:0] rd_addr_i,\n    input logic [$clog2(AxiNumWords)-1:0] rd_blen_i,  // axi convention: LEN-1\n    input logic [2:0] rd_size_i,\n    input  logic [CVA6Cfg.AxiIdWidth-1:0]   rd_id_i,   // use same ID for reads, or make sure you only have one outstanding read tx\n    input logic rd_lock_i,\n    // read response (we have to unconditionally sink the response)\n    input logic rd_rdy_i,\n    output logic rd_last_o,\n    output logic rd_valid_o,\n    output logic [CVA6Cfg.AxiDataWidth-1:0] rd_data_o,\n    output logic [CVA6Cfg.AxiUserWidth-1:0] rd_user_o,\n    output logic [CVA6Cfg.AxiIdWidth-1:0] rd_id_o,\n    output logic rd_exokay_o,  // indicates whether exclusive tx succeeded\n    // write channel\n    input logic wr_req_i,\n    output logic wr_gnt_o,\n    input logic [CVA6Cfg.AxiAddrWidth-1:0] wr_addr_i,\n    input logic [AxiNumWords-1:0][CVA6Cfg.AxiDataWidth-1:0] wr_data_i,\n    input logic [AxiNumWords-1:0][CVA6Cfg.AxiUserWidth-1:0] wr_user_i,\n    input logic [AxiNumWords-1:0][(CVA6Cfg.AxiDataWidth/8)-1:0] wr_be_i,\n    input logic [$clog2(AxiNumWords)-1:0] wr_blen_i,  // axi convention: LEN-1\n    input logic [2:0] wr_size_i,\n    input logic [CVA6Cfg.AxiIdWidth-1:0] wr_id_i,\n    input logic wr_lock_i,\n    input logic [5:0] wr_atop_i,\n    // write response\n    input logic wr_rdy_i,\n    output logic wr_valid_o,\n    output logic [CVA6Cfg.AxiIdWidth-1:0] wr_id_o,\n    output logic wr_exokay_o,  // indicates whether exclusive tx succeeded\n    // AXI port\n    output axi_req_t axi_req_o,\n    input axi_rsp_t axi_resp_i\n);\n  localparam AddrIndex = ($clog2(AxiNumWords) > 0) ? $clog2(AxiNumWords) : 1;\n\n  ///////////////////////////////////////////////////////\n  // write channel\n  ///////////////////////////////////////////////////////\n\n  enum logic [3:0] {\n    IDLE,\n    WAIT_AW_READY,\n    WAIT_LAST_W_READY,\n    WAIT_LAST_W_READY_AW_READY,\n    WAIT_AW_READY_BURST\n  }\n      wr_state_q, wr_state_d;\n\n  // AXI tx counter\n  logic [AddrIndex-1:0] wr_cnt_d, wr_cnt_q;\n  logic wr_single_req, wr_cnt_done, wr_cnt_clr, wr_cnt_en;\n\n  assign wr_single_req = (wr_blen_i == 0);\n\n  // address\n  assign axi_req_o.aw.burst = axi_pkg::BURST_INCR;  // Use BURST_INCR for AXI regular transaction\n  assign axi_req_o.aw.addr = wr_addr_i[CVA6Cfg.AxiAddrWidth-1:0];\n  assign axi_req_o.aw.size = wr_size_i;\n  assign axi_req_o.aw.len = wr_blen_i;\n  assign axi_req_o.aw.id = wr_id_i;\n  assign axi_req_o.aw.prot = 3'b0;\n  assign axi_req_o.aw.region = 4'b0;\n  assign axi_req_o.aw.lock = wr_lock_i;\n  assign axi_req_o.aw.cache = axi_pkg::CACHE_MODIFIABLE;\n  assign axi_req_o.aw.qos = 4'b0;\n  assign axi_req_o.aw.atop = wr_atop_i;\n  assign axi_req_o.aw.user = '0;\n\n  // data\n  assign axi_req_o.w.data = wr_data_i[wr_cnt_q];\n  assign axi_req_o.w.user = wr_user_i[wr_cnt_q];\n  assign axi_req_o.w.strb = wr_be_i[wr_cnt_q];\n  assign axi_req_o.w.last = wr_cnt_done;\n\n  // write response\n  assign wr_exokay_o = (axi_resp_i.b.resp == axi_pkg::RESP_EXOKAY);\n  assign axi_req_o.b_ready = wr_rdy_i;\n  assign wr_valid_o = axi_resp_i.b_valid;\n  assign wr_id_o = axi_resp_i.b.id;\n\n  // tx counter\n  assign wr_cnt_done = (wr_cnt_q == wr_blen_i);\n  assign wr_cnt_d            = (wr_cnt_clr) ? '0 : (wr_cnt_en && CVA6Cfg.AxiBurstWriteEn) ? wr_cnt_q + 1 : wr_cnt_q;\n\n  always_comb begin : p_axi_write_fsm\n    // default\n    wr_state_d         = wr_state_q;\n\n    axi_req_o.aw_valid = 1'b0;\n    axi_req_o.w_valid  = 1'b0;\n    wr_gnt_o           = 1'b0;\n\n    wr_cnt_en          = 1'b0;\n    wr_cnt_clr         = 1'b0;\n\n    case (wr_state_q)\n      ///////////////////////////////////\n      IDLE: begin\n        // we have an incoming request\n        if (wr_req_i) begin\n          // is this a read or write?\n          axi_req_o.aw_valid = 1'b1;\n          axi_req_o.w_valid  = 1'b1;\n\n          if (CVA6Cfg.AxiBurstWriteEn && !wr_single_req) begin\n            wr_cnt_en = axi_resp_i.w_ready;\n\n            case ({\n              axi_resp_i.aw_ready, axi_resp_i.w_ready\n            })\n              2'b11:   wr_state_d = WAIT_LAST_W_READY;\n              2'b01:   wr_state_d = WAIT_LAST_W_READY_AW_READY;\n              2'b10:   wr_state_d = WAIT_LAST_W_READY;\n              default: ;\n            endcase\n          end else if (wr_single_req) begin  // its a single write\n            wr_cnt_clr = 1'b1;\n            // single req can be granted here\n            wr_gnt_o   = axi_resp_i.aw_ready & axi_resp_i.w_ready;\n            case ({\n              axi_resp_i.aw_ready, axi_resp_i.w_ready\n            })\n              2'b01:   wr_state_d = WAIT_AW_READY;\n              2'b10:   wr_state_d = WAIT_LAST_W_READY;\n              default: wr_state_d = IDLE;\n            endcase\n            // its a request for the whole cache line\n          end\n        end\n      end\n      ///////////////////////////////////\n      // ~> from single write\n      WAIT_AW_READY: begin\n        axi_req_o.aw_valid = 1'b1;\n\n        if (axi_resp_i.aw_ready) begin\n          wr_state_d = IDLE;\n          wr_gnt_o   = 1'b1;\n        end\n      end\n      ///////////////////////////////////\n      // ~> from write, there is an outstanding write\n      WAIT_LAST_W_READY: begin\n        axi_req_o.w_valid = 1'b1;\n\n        if (CVA6Cfg.AxiBurstWriteEn && axi_resp_i.w_ready && !wr_cnt_done) begin\n          wr_cnt_en = 1'b1;\n        end else if (wr_cnt_done) begin  // this is the last write\n          if (axi_resp_i.w_ready) begin\n            wr_state_d = IDLE;\n            wr_cnt_clr = 1'b1;\n            wr_gnt_o   = 1'b1;\n          end\n        end\n      end\n      ///////////////////////////////////\n      default: begin\n        ///////////////////////////////////\n        // ~> we need to wait for an aw_ready and there is at least one outstanding write\n        if (CVA6Cfg.AxiBurstWriteEn) begin\n          if (wr_state_q == WAIT_LAST_W_READY_AW_READY) begin\n            axi_req_o.w_valid  = 1'b1;\n            axi_req_o.aw_valid = 1'b1;\n            // we got an aw_ready\n            case ({\n              axi_resp_i.aw_ready, axi_resp_i.w_ready\n            })\n              // we got an aw ready\n              2'b01: begin\n                // are there any outstanding transactions?\n                if (wr_cnt_done) begin\n                  wr_state_d = WAIT_AW_READY_BURST;\n                  wr_cnt_clr = 1'b1;\n                end else begin\n                  // yes, so reduce the count and stay here\n                  wr_cnt_en = 1'b1;\n                end\n              end\n              2'b10:   wr_state_d = WAIT_LAST_W_READY;\n              2'b11: begin\n                // we are finished\n                if (wr_cnt_done) begin\n                  wr_state_d = IDLE;\n                  wr_gnt_o   = 1'b1;\n                  wr_cnt_clr = 1'b1;\n                  // there are outstanding transactions\n                end else begin\n                  wr_state_d = WAIT_LAST_W_READY;\n                  wr_cnt_en  = 1'b1;\n                end\n              end\n              default: ;\n            endcase\n          end  ///////////////////////////////////\n               // ~> all data has already been sent, we are only waiting for the aw_ready\n          else if (wr_state_q == WAIT_AW_READY_BURST) begin\n            axi_req_o.aw_valid = 1'b1;\n\n            if (axi_resp_i.aw_ready) begin\n              wr_state_d = IDLE;\n              wr_gnt_o   = 1'b1;\n            end\n          end\n        end else begin\n          wr_state_d = IDLE;\n        end\n      end\n    endcase\n  end\n\n\n  ///////////////////////////////////////////////////////\n  // read channel\n  ///////////////////////////////////////////////////////\n\n  // address\n  // in case of a wrapping transfer we can simply begin at the address, if we want to request a cache-line\n  // with an incremental transfer we need to output the corresponding base address of the cache line\n  assign axi_req_o.ar.burst  = axi_pkg::BURST_INCR;  // Use BURST_INCR for AXI regular transaction\n  assign axi_req_o.ar.addr   = rd_addr_i[CVA6Cfg.AxiAddrWidth-1:0];\n  assign axi_req_o.ar.size   = rd_size_i;\n  assign axi_req_o.ar.len    = rd_blen_i;\n  assign axi_req_o.ar.id     = rd_id_i;\n  assign axi_req_o.ar.prot   = 3'b0;\n  assign axi_req_o.ar.region = 4'b0;\n  assign axi_req_o.ar.lock   = rd_lock_i;\n  assign axi_req_o.ar.cache  = axi_pkg::CACHE_MODIFIABLE;\n  assign axi_req_o.ar.qos    = 4'b0;\n  assign axi_req_o.ar.user   = '0;\n\n  // make the read request\n  assign axi_req_o.ar_valid  = rd_req_i;\n  assign rd_gnt_o            = rd_req_i & axi_resp_i.ar_ready;\n\n  // return path\n  assign axi_req_o.r_ready   = rd_rdy_i;\n  assign rd_data_o           = axi_resp_i.r.data;\n  if (ariane_pkg::AXI_USER_EN) begin\n    assign rd_user_o = axi_resp_i.r.user;\n  end else begin\n    assign rd_user_o = '0;\n  end\n  assign rd_last_o   = axi_resp_i.r.last;\n  assign rd_valid_o  = axi_resp_i.r_valid;\n  assign rd_id_o     = axi_resp_i.r.id;\n  assign rd_exokay_o = (axi_resp_i.r.resp == axi_pkg::RESP_EXOKAY);\n\n\n  // ----------------\n  // Registers\n  // ----------------\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      // start in flushing state and initialize the memory\n      wr_state_q <= IDLE;\n      wr_cnt_q   <= '0;\n    end else begin\n      wr_state_q <= wr_state_d;\n      wr_cnt_q   <= wr_cnt_d;\n    end\n  end\n\n  // ----------------\n  // Assertions\n  // ----------------\n\n  //pragma translate_off\n  initial begin\n    assert (AxiNumWords >= 1)\n    else $fatal(1, \"[axi adapter] AxiNumWords must be >= 1\");\n    assert (CVA6Cfg.AxiIdWidth >= 2)\n    else $fatal(1, \"[axi adapter] AXI id width must be at least 2 bit wide\");\n  end\n  //pragma translate_on\n\nendmodule  // axi_adapter2\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 09.05.2017\n// Description: Branch target calculation and comparison\n\nmodule branch_unit #(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Debug mode state - CSR_REGFILE\n    input logic debug_mode_i,\n    // FU data needed to execute instruction - ISSUE_STAGE\n    input ariane_pkg::fu_data_t fu_data_i,\n    // Instruction PC - ISSUE_STAGE\n    input logic [riscv::VLEN-1:0] pc_i,\n    // Instruction is compressed - ISSUE_STAGE\n    input logic is_compressed_instr_i,\n    // any functional unit is valid, check that there is no accidental mis-predict - TO_BE_COMPLETED\n    input logic fu_valid_i,\n    // Branch unit instruction is valid - ISSUE_STAGE\n    input logic branch_valid_i,\n    // ALU branch compare result - ALU\n    input logic branch_comp_res_i,\n    // Brach unit result - ISSUE_STAGE\n    output logic [riscv::VLEN-1:0] branch_result_o,\n    // Information of branch prediction - ISSUE_STAGE\n    input ariane_pkg::branchpredict_sbe_t branch_predict_i,\n    // Signaling that we resolved the branch - ISSUE_STAGE\n    output ariane_pkg::bp_resolve_t resolved_branch_o,\n    // Branch is resolved, new entries can be accepted by scoreboard - ID_STAGE\n    output logic resolve_branch_o,\n    // Branch exception out - TO_BE_COMPLETED\n    output ariane_pkg::exception_t branch_exception_o\n);\n  logic [riscv::VLEN-1:0] target_address;\n  logic [riscv::VLEN-1:0] next_pc;\n\n  // here we handle the various possibilities of mis-predicts\n  always_comb begin : mispredict_handler\n    // set the jump base, for JALR we need to look at the register, for all other control flow instructions we can take the current PC\n    automatic logic [riscv::VLEN-1:0] jump_base;\n    // TODO(zarubaf): The ALU can be used to calculate the branch target\n    jump_base = (fu_data_i.operation == ariane_pkg::JALR) ? fu_data_i.operand_a[riscv::VLEN-1:0] : pc_i;\n\n    target_address = {riscv::VLEN{1'b0}};\n    resolve_branch_o = 1'b0;\n    resolved_branch_o.target_address = {riscv::VLEN{1'b0}};\n    resolved_branch_o.is_taken = 1'b0;\n    resolved_branch_o.valid = branch_valid_i;\n    resolved_branch_o.is_mispredict = 1'b0;\n    resolved_branch_o.cf_type = branch_predict_i.cf;\n    // calculate next PC, depending on whether the instruction is compressed or not this may be different\n    // TODO(zarubaf): We already calculate this a couple of times, maybe re-use?\n    next_pc                          = pc_i + ((is_compressed_instr_i) ? {{riscv::VLEN-2{1'b0}}, 2'h2} : {{riscv::VLEN-3{1'b0}}, 3'h4});\n    // calculate target address simple 64 bit addition\n    target_address = $unsigned($signed(jump_base) + $signed(fu_data_i.imm[riscv::VLEN-1:0]));\n    // on a JALR we are supposed to reset the LSB to 0 (according to the specification)\n    if (fu_data_i.operation == ariane_pkg::JALR) target_address[0] = 1'b0;\n    // we need to put the branch target address into rd, this is the result of this unit\n    branch_result_o = next_pc;\n    resolved_branch_o.pc = pc_i;\n    // There are only two sources of mispredicts:\n    // 1. Branches\n    // 2. Jumps to register addresses\n    if (branch_valid_i) begin\n      // write target address which goes to PC Gen\n      resolved_branch_o.target_address = (branch_comp_res_i) ? target_address : next_pc;\n      resolved_branch_o.is_taken = branch_comp_res_i;\n      // check the outcome of the branch speculation\n      if (ariane_pkg::op_is_branch(fu_data_i.operation)) begin\n        // Set the `cf_type` of the output as `branch`, this will update the BHT.\n        resolved_branch_o.cf_type = ariane_pkg::Branch;\n        // If the ALU comparison does not agree with the BHT prediction set the resolution as mispredicted.\n        resolved_branch_o.is_mispredict  = branch_comp_res_i != (branch_predict_i.cf == ariane_pkg::Branch);\n      end\n      if (fu_data_i.operation == ariane_pkg::JALR\n          // check if the address of the jump register is correct and that we actually predicted\n          && (branch_predict_i.cf == ariane_pkg::NoCF || target_address != branch_predict_i.predict_address)) begin\n        resolved_branch_o.is_mispredict = 1'b1;\n        // update BTB only if this wasn't a return\n        if (branch_predict_i.cf != ariane_pkg::Return)\n          resolved_branch_o.cf_type = ariane_pkg::JumpR;\n      end\n      // to resolve the branch in ID\n      resolve_branch_o = 1'b1;\n    end\n  end\n  // use ALU exception signal for storing instruction fetch exceptions if\n  // the target address is not aligned to a 2 byte boundary\n  //\n  logic jump_taken;\n  always_comb begin : exception_handling\n\n    // Do a jump if it is either unconditional jump (JAL | JALR) or `taken` conditional jump\n    jump_taken = !(ariane_pkg::op_is_branch(fu_data_i.operation)) ||\n        ((ariane_pkg::op_is_branch(fu_data_i.operation)) && branch_comp_res_i);\n    branch_exception_o.cause = riscv::INSTR_ADDR_MISALIGNED;\n    branch_exception_o.valid = 1'b0;\n    if (CVA6Cfg.TvalEn)\n      branch_exception_o.tval = {{riscv::XLEN - riscv::VLEN{pc_i[riscv::VLEN-1]}}, pc_i};\n    else branch_exception_o.tval = '0;\n    // Only throw instruction address misaligned exception if this is indeed a `taken` conditional branch or\n    // an unconditional jump\n    if (branch_valid_i && (target_address[0] || (!CVA6Cfg.RVC && target_address[1])) && jump_taken) begin\n      branch_exception_o.valid = 1'b1;\n    end\n  end\nendmodule\n"}
{"text": "package build_config_pkg;\n\n  function automatic config_pkg::cva6_cfg_t build_config(config_pkg::cva6_user_cfg_t CVA6Cfg);\n    bit RVF = (riscv::IS_XLEN64 | riscv::IS_XLEN32) & CVA6Cfg.FpuEn;\n    bit RVD = (riscv::IS_XLEN64 ? 1 : 0) & CVA6Cfg.FpuEn;\n    bit FpPresent = RVF | RVD | CVA6Cfg.XF16 | CVA6Cfg.XF16ALT | CVA6Cfg.XF8;\n    bit NSX = CVA6Cfg.XF16 | CVA6Cfg.XF16ALT | CVA6Cfg.XF8 | CVA6Cfg.XFVec;  // Are non-standard extensions present?\n    int unsigned FLen = RVD ? 64 :  // D ext.\n    RVF ? 32 :  // F ext.\n    CVA6Cfg.XF16 ? 16 :  // Xf16 ext.\n    CVA6Cfg.XF16ALT ? 16 :  // Xf16alt ext.\n    CVA6Cfg.XF8 ? 8 :  // Xf8 ext.\n    1;  // Unused in case of no FP\n\n    // Transprecision floating-point extensions configuration\n    bit RVFVec     = RVF             & CVA6Cfg.XFVec & FLen>32; // FP32 vectors available if vectors and larger fmt enabled\n    bit XF16Vec    = CVA6Cfg.XF16    & CVA6Cfg.XFVec & FLen>16; // FP16 vectors available if vectors and larger fmt enabled\n    bit XF16ALTVec = CVA6Cfg.XF16ALT & CVA6Cfg.XFVec & FLen>16; // FP16ALT vectors available if vectors and larger fmt enabled\n    bit XF8Vec     = CVA6Cfg.XF8     & CVA6Cfg.XFVec & FLen>8;  // FP8 vectors available if vectors and larger fmt enabled\n\n    bit EnableAccelerator = CVA6Cfg.RVV;  // Currently only used by V extension (Ara)\n    int unsigned NrWbPorts = (CVA6Cfg.CvxifEn || EnableAccelerator) ? 5 : 4;\n\n    config_pkg::cva6_cfg_t cfg;\n\n    cfg.NrCommitPorts = CVA6Cfg.NrCommitPorts;\n    cfg.AxiAddrWidth = CVA6Cfg.AxiAddrWidth;\n    cfg.AxiDataWidth = CVA6Cfg.AxiDataWidth;\n    cfg.AxiIdWidth = CVA6Cfg.AxiIdWidth;\n    cfg.AxiUserWidth = CVA6Cfg.AxiUserWidth;\n    cfg.NrLoadBufEntries = CVA6Cfg.NrLoadBufEntries;\n    cfg.FpuEn = CVA6Cfg.FpuEn;\n    cfg.XF16 = CVA6Cfg.XF16;\n    cfg.XF16ALT = CVA6Cfg.XF16ALT;\n    cfg.XF8 = CVA6Cfg.XF8;\n    cfg.RVA = CVA6Cfg.RVA;\n    cfg.RVB = CVA6Cfg.RVB;\n    cfg.RVV = CVA6Cfg.RVV;\n    cfg.RVC = CVA6Cfg.RVC;\n    cfg.RVZCB = CVA6Cfg.RVZCB;\n    cfg.XFVec = CVA6Cfg.XFVec;\n    cfg.CvxifEn = CVA6Cfg.CvxifEn;\n    cfg.ZiCondExtEn = CVA6Cfg.ZiCondExtEn;\n\n    cfg.RVF = bit'(RVF);\n    cfg.RVD = bit'(RVD);\n    cfg.FpPresent = bit'(FpPresent);\n    cfg.NSX = bit'(NSX);\n    cfg.FLen = unsigned'(FLen);\n    cfg.RVFVec = bit'(RVFVec);\n    cfg.XF16Vec = bit'(XF16Vec);\n    cfg.XF16ALTVec = bit'(XF16ALTVec);\n    cfg.XF8Vec = bit'(XF8Vec);\n    cfg.NrRgprPorts = unsigned'(2);\n    cfg.NrWbPorts = unsigned'(NrWbPorts);\n    cfg.EnableAccelerator = bit'(EnableAccelerator);\n    cfg.RVS = CVA6Cfg.RVS;\n    cfg.RVU = CVA6Cfg.RVU;\n\n    cfg.HaltAddress = CVA6Cfg.HaltAddress;\n    cfg.ExceptionAddress = CVA6Cfg.ExceptionAddress;\n    cfg.RASDepth = CVA6Cfg.RASDepth;\n    cfg.BTBEntries = CVA6Cfg.BTBEntries;\n    cfg.BHTEntries = CVA6Cfg.BHTEntries;\n    cfg.DmBaseAddress = CVA6Cfg.DmBaseAddress;\n    cfg.TvalEn = CVA6Cfg.TvalEn;\n    cfg.NrPMPEntries = CVA6Cfg.NrPMPEntries;\n    cfg.PMPCfgRstVal = CVA6Cfg.PMPCfgRstVal;\n    cfg.PMPAddrRstVal = CVA6Cfg.PMPAddrRstVal;\n    cfg.PMPEntryReadOnly = CVA6Cfg.PMPEntryReadOnly;\n    cfg.NOCType = CVA6Cfg.NOCType;\n    cfg.NrNonIdempotentRules = CVA6Cfg.NrNonIdempotentRules;\n    cfg.NonIdempotentAddrBase = CVA6Cfg.NonIdempotentAddrBase;\n    cfg.NonIdempotentLength = CVA6Cfg.NonIdempotentLength;\n    cfg.NrExecuteRegionRules = CVA6Cfg.NrExecuteRegionRules;\n    cfg.ExecuteRegionAddrBase = CVA6Cfg.ExecuteRegionAddrBase;\n    cfg.ExecuteRegionLength = CVA6Cfg.ExecuteRegionLength;\n    cfg.NrCachedRegionRules = CVA6Cfg.NrCachedRegionRules;\n    cfg.CachedRegionAddrBase = CVA6Cfg.CachedRegionAddrBase;\n    cfg.CachedRegionLength = CVA6Cfg.CachedRegionLength;\n    cfg.MaxOutstandingStores = CVA6Cfg.MaxOutstandingStores;\n    cfg.DebugEn = CVA6Cfg.DebugEn;\n    cfg.NonIdemPotenceEn = CVA6Cfg.NrNonIdempotentRules && CVA6Cfg.NonIdempotentLength;\n    cfg.AxiBurstWriteEn = CVA6Cfg.AxiBurstWriteEn;\n\n    return cfg;\n  endfunction\n\nendpackage\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// File:   cache_ctrl.svh\n// Author: Florian Zaruba <zarubaf@ethz.ch>\n// Date:   14.10.2017\n//\n// Copyright (C) 2017 ETH Zurich, University of Bologna\n// All rights reserved.\n//\n// Description: Cache controller\n\n\nmodule cache_ctrl\n  import ariane_pkg::*;\n  import std_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    input logic clk_i,  // Clock\n    input logic rst_ni,  // Asynchronous reset active low\n    input logic flush_i,\n    input logic bypass_i,  // enable cache\n    output logic busy_o,\n    // Core request ports\n    input dcache_req_i_t req_port_i,\n    output dcache_req_o_t req_port_o,\n    // SRAM interface\n    output logic [DCACHE_SET_ASSOC-1:0] req_o,  // req is valid\n    output logic [DCACHE_INDEX_WIDTH-1:0] addr_o,  // address into cache array\n    input logic gnt_i,\n    output cache_line_t data_o,\n    output cl_be_t be_o,\n    output logic [DCACHE_TAG_WIDTH-1:0] tag_o,  //valid one cycle later\n    input cache_line_t [DCACHE_SET_ASSOC-1:0] data_i,\n    output logic we_o,\n    input logic [DCACHE_SET_ASSOC-1:0] hit_way_i,\n    // Miss handling\n    output miss_req_t miss_req_o,\n    // return\n    input logic miss_gnt_i,\n    input  logic                                 active_serving_i, // the miss unit is currently active for this unit, serving the miss\n    input logic [63:0] critical_word_i,\n    input logic critical_word_valid_i,\n    // bypass ports\n    input logic bypass_gnt_i,\n    input logic bypass_valid_i,\n    input logic [63:0] bypass_data_i,\n    // check MSHR for aliasing\n    output logic [55:0] mshr_addr_o,\n    input logic mshr_addr_matches_i,\n    input logic mshr_index_matches_i\n);\n\n  enum logic [3:0] {\n    IDLE,               // 0\n    WAIT_TAG,           // 1\n    WAIT_TAG_BYPASSED,  // 2\n    WAIT_GNT,           // 3\n    WAIT_GNT_SAVED,     // 4\n    STORE_REQ,          // 5\n    WAIT_REFILL_VALID,  // 6\n    WAIT_REFILL_GNT,    // 7\n    WAIT_TAG_SAVED,     // 8\n    WAIT_MSHR,          // 9\n    WAIT_CRITICAL_WORD  // 10\n  }\n      state_d, state_q;\n\n  typedef struct packed {\n    logic [DCACHE_INDEX_WIDTH-1:0] index;\n    logic [DCACHE_TAG_WIDTH-1:0]   tag;\n    logic [DCACHE_TID_WIDTH-1:0]   id;\n    logic [7:0]                    be;\n    logic [1:0]                    size;\n    logic                          we;\n    logic [63:0]                   wdata;\n    logic                          bypass;\n    logic                          killed;\n  } mem_req_t;\n\n  logic [DCACHE_SET_ASSOC-1:0] hit_way_d, hit_way_q;\n\n  mem_req_t mem_req_d, mem_req_q;\n\n  assign busy_o = (state_q != IDLE);\n  assign tag_o  = mem_req_d.tag;\n\n  logic [DCACHE_LINE_WIDTH-1:0] cl_i;\n\n  always_comb begin : way_select\n    cl_i = '0;\n    for (int unsigned i = 0; i < DCACHE_SET_ASSOC; i++) if (hit_way_i[i]) cl_i = data_i[i].data;\n\n    // cl_i = data_i[one_hot_to_bin(hit_way_i)].data;\n  end\n\n  // --------------\n  // Cache FSM\n  // --------------\n  always_comb begin : cache_ctrl_fsm\n    automatic logic [$clog2(DCACHE_LINE_WIDTH)-1:0] cl_offset;\n    // incoming cache-line -> this is needed as synthesis is not supporting +: indexing in a multi-dimensional array\n    // cache-line offset -> multiple of 64\n    cl_offset = mem_req_q.index[DCACHE_BYTE_OFFSET-1:3] << 6;  // shift by 6 to the left\n    // default assignments\n    state_d = state_q;\n    mem_req_d = mem_req_q;\n    hit_way_d = hit_way_q;\n    // output assignments\n    req_port_o.data_gnt = 1'b0;\n    req_port_o.data_rvalid = 1'b0;\n    req_port_o.data_rdata = '0;\n    req_port_o.data_rid = mem_req_q.id;\n    miss_req_o = '0;\n    mshr_addr_o = '0;\n    // Memory array communication\n    req_o = '0;\n    addr_o = req_port_i.address_index;\n    data_o = '0;\n    be_o = '0;\n    we_o = '0;\n\n    mem_req_d.killed |= req_port_i.kill_req;\n\n    case (state_q)\n\n      IDLE: begin\n        // a new request arrived\n        if (req_port_i.data_req && !flush_i) begin\n          // request the cache line - we can do this speculatively\n          req_o = '1;\n\n          // save index, be and we\n          mem_req_d.index = req_port_i.address_index;\n          mem_req_d.id    = req_port_i.data_id;\n          mem_req_d.be    = req_port_i.data_be;\n          mem_req_d.size  = req_port_i.data_size;\n          mem_req_d.we    = req_port_i.data_we;\n          mem_req_d.wdata = req_port_i.data_wdata;\n          mem_req_d.killed = req_port_i.kill_req;\n\n          // Bypass mode, check for uncacheable address here as well\n          if (bypass_i) begin\n            state_d = WAIT_TAG_BYPASSED;\n            // grant this access only if it was a load\n            req_port_o.data_gnt = (req_port_i.data_we) ? 1'b0 : 1'b1;\n            mem_req_d.bypass = 1'b1;\n            // ------------------\n            // Cache is enabled\n            // ------------------\n          end else begin\n            // Wait that we have access on the memory array\n            if (gnt_i) begin\n              state_d = WAIT_TAG;\n              mem_req_d.bypass = 1'b0;\n              // only for a read\n              if (!req_port_i.data_we) req_port_o.data_gnt = 1'b1;\n            end\n          end\n        end\n      end\n\n      // cache enabled and waiting for tag\n      WAIT_TAG, WAIT_TAG_SAVED: begin\n        // check that the client really wants to do the request and that we have a valid tag\n        if (!req_port_i.kill_req && (req_port_i.tag_valid || state_q == WAIT_TAG_SAVED || mem_req_q.we)) begin\n          // save tag if we didn't already save it\n          if (state_q != WAIT_TAG_SAVED) begin\n            mem_req_d.tag = req_port_i.address_tag;\n          end\n          // we speculatively request another transfer\n          if (req_port_i.data_req && !flush_i) begin\n            req_o = '1;\n          end\n          // ------------\n          // HIT CASE\n          // ------------\n          if (|hit_way_i) begin\n            // we can request another cache-line if this was a load\n            if (req_port_i.data_req && !mem_req_q.we && !flush_i) begin\n              state_d             = WAIT_TAG;  // switch back to WAIT_TAG\n              mem_req_d.index     = req_port_i.address_index;\n              mem_req_d.id        = req_port_i.data_id;\n              mem_req_d.be        = req_port_i.data_be;\n              mem_req_d.size      = req_port_i.data_size;\n              mem_req_d.we        = req_port_i.data_we;\n              mem_req_d.wdata     = req_port_i.data_wdata;\n              mem_req_d.killed    = req_port_i.kill_req;\n              mem_req_d.bypass    = 1'b0;\n\n              req_port_o.data_gnt = gnt_i;\n\n              if (!gnt_i) begin\n                state_d = IDLE;\n              end\n            end else begin\n              state_d = IDLE;\n            end\n\n            // this is timing critical\n            req_port_o.data_rdata = cl_i[cl_offset+:64];\n\n            // report data for a read\n            if (!mem_req_q.we) begin\n              req_port_o.data_rvalid = ~mem_req_q.killed;\n              // else this was a store so we need an extra step to handle it\n            end else begin\n              state_d   = STORE_REQ;\n              hit_way_d = hit_way_i;\n            end\n            // ------------\n            // MISS CASE\n            // ------------\n          end else begin\n            // make a miss request\n            state_d = WAIT_REFILL_GNT;\n          end\n          // ----------------------------------------------\n          // Check MSHR - Miss Status Handling Register\n          // ----------------------------------------------\n          mshr_addr_o = {tag_o, mem_req_q.index};\n          // 1. We've got a match on MSHR and while are going down the\n          //    store path. This means that the miss controller is\n          //    currently evicting our cache-line. As the store is\n          //    non-atomic we need to constantly check whether we are\n          //    matching the address the miss handler is serving.\n          //    Furthermore we need to check for the whole index\n          //    because a completely different memory line could alias\n          //    with the cache-line we are evicting.\n          // 2. The second case is where we are currently loading and\n          //    the address matches the exact CL the miss controller\n          //    is currently serving. That means we need to wait for\n          //    the miss controller to finish its request before we\n          //    can continue to serve this CL. Otherwise we will fetch\n          //    the cache-line again and potentially loosing any\n          //    content we've written so far. This as a consequence\n          //    means we can't have hit on the CL which mean the\n          //    req_port_o.data_rvalid will be de-asserted.\n          if ((mshr_index_matches_i && mem_req_q.we) || mshr_addr_matches_i) begin\n            state_d = WAIT_MSHR;\n          end\n\n          // -------------------------\n          // Check for cache-ability\n          // -------------------------\n          if (!config_pkg::is_inside_cacheable_regions(\n                  CVA6Cfg, {{{64 - riscv::PLEN} {1'b0}}, tag_o, {DCACHE_INDEX_WIDTH{1'b0}}}\n              )) begin\n            mem_req_d.bypass = 1'b1;\n            state_d = WAIT_REFILL_GNT;\n          end\n\n          // we are still waiting for a valid tag\n        end else begin\n          // request cache line for saved index\n          addr_o = mem_req_q.index;\n          req_o  = '1;\n\n          // check that we still have a memory grant\n          if (!gnt_i) begin\n            state_d = WAIT_GNT;\n          end\n        end\n      end\n\n      // ~> we already granted the request but lost the memory grant while waiting for the tag\n      WAIT_GNT, WAIT_GNT_SAVED: begin\n        // request cache line for saved index\n        addr_o = mem_req_q.index;\n        req_o  = '1;\n\n        // if we get a valid tag while waiting for the memory grant, save it\n        if (req_port_i.tag_valid) begin\n          mem_req_d.tag = req_port_i.address_tag;\n          state_d = WAIT_GNT_SAVED;\n        end\n\n        // we have a memory grant again ~> go back to WAIT_TAG\n        if (gnt_i) begin\n          state_d = (state_d == WAIT_GNT) ? WAIT_TAG : WAIT_TAG_SAVED;\n        end\n      end\n\n      // ~> we are here as we need a second round of memory access for a store\n      STORE_REQ: begin\n        // check if the MSHR still doesn't match\n        mshr_addr_o = {mem_req_q.tag, mem_req_q.index};\n\n        // We need to re-check for MSHR aliasing here as the store requires at least\n        // two memory look-ups on a single-ported SRAM and therefore is non-atomic\n        if (!mshr_index_matches_i) begin\n          // store data, write dirty bit\n          req_o                      = hit_way_q;\n          addr_o                     = mem_req_q.index;\n          we_o                       = 1'b1;\n\n          be_o.vldrty                = hit_way_q;\n\n          // set the correct byte enable\n          be_o.data[cl_offset>>3+:8] = mem_req_q.be;\n          data_o.data[cl_offset+:64] = mem_req_q.wdata;\n          // ~> change the state\n          data_o.dirty               = 1'b1;\n          data_o.valid               = 1'b1;\n\n          // got a grant ~> this is finished now\n          if (gnt_i) begin\n            req_port_o.data_gnt = 1'b1;\n            state_d = IDLE;\n          end\n        end else begin\n          state_d = WAIT_MSHR;\n        end\n      end  // case: STORE_REQ\n\n      // we've got a match on MSHR ~> miss unit is currently serving a request\n      WAIT_MSHR: begin\n        mshr_addr_o = {mem_req_q.tag, mem_req_q.index};\n        // we can start a new request\n        if (!mshr_index_matches_i) begin\n          req_o  = '1;\n\n          addr_o = mem_req_q.index;\n\n          if (gnt_i) state_d = WAIT_TAG_SAVED;\n        end\n      end\n\n      // its for sure a miss\n      WAIT_TAG_BYPASSED: begin\n        // check that the client really wants to do the request and that we have a valid tag\n        if (!req_port_i.kill_req && (req_port_i.tag_valid || mem_req_q.we)) begin\n          // save tag\n          mem_req_d.tag = req_port_i.address_tag;\n          state_d = WAIT_REFILL_GNT;\n        end\n      end\n\n      // ~> wait for grant from miss unit\n      WAIT_REFILL_GNT: begin\n\n        mshr_addr_o = {mem_req_q.tag, mem_req_q.index};\n\n        miss_req_o.valid = 1'b1;\n        miss_req_o.bypass = mem_req_q.bypass;\n        miss_req_o.addr = {mem_req_q.tag, mem_req_q.index};\n        miss_req_o.be = mem_req_q.be;\n        miss_req_o.size = mem_req_q.size;\n        miss_req_o.we = mem_req_q.we;\n        miss_req_o.wdata = mem_req_q.wdata;\n\n        // got a grant so go to valid\n        if (bypass_gnt_i) begin\n          state_d = WAIT_REFILL_VALID;\n          // if this was a write we still need to give a grant to the store unit.\n          // We can also avoid waiting for the response valid, this signal is\n          // currently not used by the store unit\n          if (mem_req_q.we) begin\n            req_port_o.data_gnt = 1'b1;\n            state_d = IDLE;\n          end\n        end\n\n        if (miss_gnt_i && !mem_req_q.we) state_d = WAIT_CRITICAL_WORD;\n        else if (miss_gnt_i) begin\n          state_d = IDLE;\n          req_port_o.data_gnt = 1'b1;\n        end\n\n        // it can be the case that the miss unit is currently serving a\n        // request which matches ours\n        // so we need to check the MSHR for matching continuously\n        // if the MSHR matches we need to go to a different state -> we should never get a matching MSHR and a high miss_gnt_i\n        if (mshr_addr_matches_i && !active_serving_i) begin\n          state_d = WAIT_MSHR;\n        end\n      end\n\n      // ~> wait for critical word to arrive\n      WAIT_CRITICAL_WORD: begin\n        // speculatively request another word\n        if (req_port_i.data_req) begin\n          // request the cache line\n          req_o = '1;\n        end\n\n        if (critical_word_valid_i) begin\n          req_port_o.data_rvalid = ~mem_req_q.killed;\n          req_port_o.data_rdata  = critical_word_i;\n          // we can make another request\n          if (req_port_i.data_req && !flush_i) begin\n            // save index, be and we\n            mem_req_d.index = req_port_i.address_index;\n            mem_req_d.id    = req_port_i.data_id;\n            mem_req_d.be    = req_port_i.data_be;\n            mem_req_d.size  = req_port_i.data_size;\n            mem_req_d.we    = req_port_i.data_we;\n            mem_req_d.wdata = req_port_i.data_wdata;\n            mem_req_d.killed = req_port_i.kill_req;\n\n            state_d = IDLE;\n\n            // Wait until we have access on the memory array\n            if (gnt_i) begin\n              state_d = WAIT_TAG;\n              mem_req_d.bypass = 1'b0;\n              req_port_o.data_gnt = 1'b1;\n            end\n          end else begin\n            state_d = IDLE;\n          end\n        end\n      end\n      // ~> wait until the bypass request is valid\n      WAIT_REFILL_VALID: begin\n        // got a valid answer\n        if (bypass_valid_i) begin\n          req_port_o.data_rdata = bypass_data_i;\n          req_port_o.data_rvalid = ~mem_req_q.killed;\n          state_d = IDLE;\n        end\n      end\n    endcase\n\n    if (req_port_i.kill_req) begin\n      req_port_o.data_rvalid = 1'b1;\n      if (!(state_q inside {WAIT_REFILL_GNT, WAIT_CRITICAL_WORD})) begin\n        state_d = IDLE;\n      end\n    end\n  end\n\n  // --------------\n  // Registers\n  // --------------\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      state_q   <= IDLE;\n      mem_req_q <= '0;\n      hit_way_q <= '0;\n    end else begin\n      state_q   <= state_d;\n      mem_req_q <= mem_req_d;\n      hit_way_q <= hit_way_d;\n    end\n  end\n\n  //pragma translate_off\n`ifndef VERILATOR\n  initial begin\n    assert (DCACHE_LINE_WIDTH == 128)\n    else\n      $error(\n          \"Cacheline width has to be 128 for the moment. But only small changes required in data select logic\"\n      );\n  end\n  // if the full MSHR address matches so should also match the partial one\n  partial_full_mshr_match :\n  assert property(@(posedge  clk_i) disable iff (~rst_ni) mshr_addr_matches_i -> mshr_index_matches_i)\n  else $fatal(1, \"partial mshr index doesn't match\");\n  // there should never be a valid answer when the MSHR matches and we are not being served\n  no_valid_on_mshr_match :\n  assert property(@(posedge  clk_i) disable iff (~rst_ni) (mshr_addr_matches_i && !active_serving_i)-> !req_port_o.data_rvalid || req_port_i.kill_req)\n  else $fatal(1, \"rvalid_o should not be set on MSHR match\");\n`endif\n  //pragma translate_on\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 15.04.2017\n// Description: Commits to the architectural state resulting from the scoreboard.\n\n\nmodule commit_stage\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Request to halt the core - CONTROLLER\n    input logic halt_i,\n    // request to flush dcache, also flush the pipeline - CACHE\n    input logic flush_dcache_i,\n    // TO_BE_COMPLETED - EX_STAGE\n    output exception_t exception_o,\n    // Mark the F state as dirty - CSR_REGFILE\n    output logic dirty_fp_state_o,\n    // TO_BE_COMPLETED - CSR_REGFILE\n    input logic single_step_i,\n    // The instruction we want to commit - ISSUE_STAGE\n    input scoreboard_entry_t [CVA6Cfg.NrCommitPorts-1:0] commit_instr_i,\n    // Acknowledge that we are indeed committing - ISSUE_STAGE\n    output logic [CVA6Cfg.NrCommitPorts-1:0] commit_ack_o,\n    // Register file write address - ISSUE_STAGE\n    output logic [CVA6Cfg.NrCommitPorts-1:0][4:0] waddr_o,\n    // Register file write data - ISSUE_STAGE\n    output logic [CVA6Cfg.NrCommitPorts-1:0][riscv::XLEN-1:0] wdata_o,\n    // Register file write enable - ISSUE_STAGE\n    output logic [CVA6Cfg.NrCommitPorts-1:0] we_gpr_o,\n    // Floating point register enable - ISSUE_STAGE\n    output logic [CVA6Cfg.NrCommitPorts-1:0] we_fpr_o,\n    // Result of AMO operation - CACHE\n    input amo_resp_t amo_resp_i,\n    // TO_BE_COMPLETED - FRONTEND_CSR\n    output logic [riscv::VLEN-1:0] pc_o,\n    // Decoded CSR operation - CSR_REGFILE\n    output fu_op csr_op_o,\n    // Data to write to CSR - CSR_REGFILE\n    output riscv::xlen_t csr_wdata_o,\n    // Data to read from CSR - CSR_REGFILE\n    input riscv::xlen_t csr_rdata_i,\n    // Exception or interrupt occurred in CSR stage (the same as commit) - CSR_REGFILE\n    input exception_t csr_exception_i,\n    // Write the fflags CSR - CSR_REGFILE\n    output logic csr_write_fflags_o,\n    // Commit the pending store - EX_STAGE\n    output logic commit_lsu_o,\n    // Commit buffer of LSU is ready - EX_STAGE\n    input logic commit_lsu_ready_i,\n    // Transaction id of first commit port - ID_STAGE\n    output logic [TRANS_ID_BITS-1:0] commit_tran_id_o,\n    // Valid AMO in commit stage - EX_STAGE\n    output logic amo_valid_commit_o,\n    // no store is pending - EX_STAGE\n    input logic no_st_pending_i,\n    // Commit the pending CSR instruction - EX_STAGE\n    output logic commit_csr_o,\n    // Flush I$ and pipeline - CONTROLLER\n    output logic fence_i_o,\n    // Flush D$ and pipeline - CONTROLLER\n    output logic fence_o,\n    // Request a pipeline flush - CONTROLLER\n    output logic flush_commit_o,\n    // Flush TLBs and pipeline - CONTROLLER\n    output logic sfence_vma_o\n);\n\n  // ila_0 i_ila_commit (\n  //     .clk(clk_i), // input wire clk\n  //     .probe0(commit_instr_i[0].pc), // input wire [63:0]  probe0\n  //     .probe1(commit_instr_i[1].pc), // input wire [63:0]  probe1\n  //     .probe2(commit_instr_i[0].valid), // input wire [0:0]  probe2\n  //     .probe3(commit_instr_i[1].valid), // input wire [0:0]  probe3\n  //     .probe4(commit_ack_o[0]), // input wire [0:0]  probe4\n  //     .probe5(commit_ack_o[0]), // input wire [0:0]  probe5\n  //     .probe6(1'b0), // input wire [0:0]  probe6\n  //     .probe7(1'b0), // input wire [0:0]  probe7\n  //     .probe8(1'b0), // input wire [0:0]  probe8\n  //     .probe9(1'b0) // input wire [0:0]  probe9\n  // );\n\n  for (genvar i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin : gen_waddr\n    assign waddr_o[i] = commit_instr_i[i].rd[4:0];\n  end\n\n  assign pc_o = commit_instr_i[0].pc;\n  // Dirty the FP state if we are committing anything related to the FPU\n  always_comb begin : dirty_fp_state\n    dirty_fp_state_o = 1'b0;\n    for (int i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin\n      dirty_fp_state_o |= commit_ack_o[i] & (commit_instr_i[i].fu inside {FPU, FPU_VEC} || (CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(\n          commit_instr_i[i].op\n      )));\n      // Check if we issued a vector floating-point instruction to the accellerator\n      dirty_fp_state_o |= commit_instr_i[i].fu == ACCEL && commit_instr_i[i].vfp;\n    end\n  end\n\n  assign commit_tran_id_o = commit_instr_i[0].trans_id;\n\n  logic instr_0_is_amo;\n  assign instr_0_is_amo = is_amo(commit_instr_i[0].op);\n  // -------------------\n  // Commit Instruction\n  // -------------------\n  // write register file or commit instruction in LSU or CSR Buffer\n  always_comb begin : commit\n    // default assignments\n    commit_ack_o[0] = 1'b0;\n\n    amo_valid_commit_o = 1'b0;\n\n    we_gpr_o[0] = 1'b0;\n    we_fpr_o = '{default: 1'b0};\n    commit_lsu_o = 1'b0;\n    commit_csr_o = 1'b0;\n    // amos will commit on port 0\n    wdata_o[0] = (CVA6Cfg.RVA && amo_resp_i.ack) ? amo_resp_i.result[riscv::XLEN-1:0] : commit_instr_i[0].result;\n    csr_op_o = ADD;  // this corresponds to a CSR NOP\n    csr_wdata_o = {riscv::XLEN{1'b0}};\n    fence_i_o = 1'b0;\n    fence_o = 1'b0;\n    sfence_vma_o = 1'b0;\n    csr_write_fflags_o = 1'b0;\n    flush_commit_o = 1'b0;\n\n    // we will not commit the instruction if we took an exception\n    // and we do not commit the instruction if we requested a halt\n    if (commit_instr_i[0].valid && !commit_instr_i[0].ex.valid && !halt_i) begin\n      // we can definitely write the register file\n      // if the instruction is not committing anything the destination\n      commit_ack_o[0] = 1'b1;\n      if (CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(commit_instr_i[0].op)) begin\n        we_fpr_o[0] = 1'b1;\n      end else begin\n        we_gpr_o[0] = 1'b1;\n      end\n      // check whether the instruction we retire was a store\n      if ((!CVA6Cfg.RVA && commit_instr_i[0].fu == STORE) || (CVA6Cfg.RVA && commit_instr_i[0].fu == STORE && !instr_0_is_amo)) begin\n        // check if the LSU is ready to accept another commit entry (e.g.: a non-speculative store)\n        if (commit_lsu_ready_i) begin\n          commit_ack_o[0] = 1'b1;\n          commit_lsu_o = 1'b1;\n          // stall in case the store buffer is not able to accept anymore instructions\n        end else begin\n          commit_ack_o[0] = 1'b0;\n        end\n      end\n      // ---------\n      // FPU Flags\n      // ---------\n      if (CVA6Cfg.FpPresent) begin\n        if (commit_instr_i[0].fu inside {FPU, FPU_VEC}) begin\n          // write the CSR with potential exception flags from retiring floating point instruction\n          csr_wdata_o = {{riscv::XLEN - 5{1'b0}}, commit_instr_i[0].ex.cause[4:0]};\n          csr_write_fflags_o = 1'b1;\n          commit_ack_o[0] = 1'b1;\n        end\n      end\n      // ---------\n      // CSR Logic\n      // ---------\n      // check whether the instruction we retire was a CSR instruction and it did not\n      // throw an exception\n      if (commit_instr_i[0].fu == CSR) begin\n        // write the CSR file\n        csr_op_o    = commit_instr_i[0].op;\n        csr_wdata_o = commit_instr_i[0].result;\n        if (!csr_exception_i.valid) begin\n          commit_csr_o = 1'b1;\n          wdata_o[0] = csr_rdata_i;\n          commit_ack_o[0] = 1'b1;\n        end else begin\n          commit_ack_o[0] = 1'b0;\n          we_gpr_o[0] = 1'b0;\n        end\n      end\n      // ------------------\n      // SFENCE.VMA Logic\n      // ------------------\n      // sfence.vma is idempotent so we can safely re-execute it after returning\n      // from interrupt service routine\n      // check if this instruction was a SFENCE_VMA\n      if (CVA6Cfg.RVS && commit_instr_i[0].op == SFENCE_VMA) begin\n        // no store pending so we can flush the TLBs and pipeline\n        sfence_vma_o = no_st_pending_i;\n        // wait for the store buffer to drain until flushing the pipeline\n        commit_ack_o[0] = no_st_pending_i;\n      end\n      // ------------------\n      // FENCE.I Logic\n      // ------------------\n      // fence.i is idempotent so we can safely re-execute it after returning\n      // from interrupt service routine\n      // Fence synchronizes data and instruction streams. That means that we need to flush the private icache\n      // and the private dcache. This is the most expensive instruction.\n      if (commit_instr_i[0].op == FENCE_I || (flush_dcache_i && DCACHE_TYPE == int'(config_pkg::WB) && commit_instr_i[0].fu != STORE)) begin\n        commit_ack_o[0] = no_st_pending_i;\n        // tell the controller to flush the I$\n        fence_i_o = no_st_pending_i;\n      end\n      // ------------------\n      // FENCE Logic\n      // ------------------\n      // fence is idempotent so we can safely re-execute it after returning\n      // from interrupt service routine\n      if (commit_instr_i[0].op == FENCE) begin\n        commit_ack_o[0] = no_st_pending_i;\n        // tell the controller to flush the D$\n        fence_o = no_st_pending_i;\n      end\n      // ------------------\n      // AMO\n      // ------------------\n      if (CVA6Cfg.RVA && instr_0_is_amo) begin\n        // AMO finished\n        commit_ack_o[0] = amo_resp_i.ack;\n        // flush the pipeline\n        flush_commit_o = amo_resp_i.ack;\n        amo_valid_commit_o = 1'b1;\n        we_gpr_o[0] = amo_resp_i.ack;\n      end\n    end\n\n    if (CVA6Cfg.NrCommitPorts > 1) begin\n\n      commit_ack_o[1] = 1'b0;\n      we_gpr_o[1]     = 1'b0;\n      wdata_o[1]      = commit_instr_i[1].result;\n\n      // -----------------\n      // Commit Port 2\n      // -----------------\n      // check if the second instruction can be committed as well and the first wasn't a CSR instruction\n      // also if we are in single step mode don't retire the second instruction\n      if (commit_ack_o[0] && commit_instr_i[1].valid\n                                && !halt_i\n                                && !(commit_instr_i[0].fu inside {CSR})\n                                && !flush_dcache_i\n                                && !instr_0_is_amo\n                                && !single_step_i) begin\n        // only if the first instruction didn't throw an exception and this instruction won't throw an exception\n        // and the functional unit is of type ALU, LOAD, CTRL_FLOW, MULT, FPU or FPU_VEC\n        if (!exception_o.valid && !commit_instr_i[1].ex.valid\n                                       && (commit_instr_i[1].fu inside {ALU, LOAD, CTRL_FLOW, MULT, FPU, FPU_VEC})) begin\n\n          if (CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(commit_instr_i[1].op)) we_fpr_o[1] = 1'b1;\n          else we_gpr_o[1] = 1'b1;\n\n          commit_ack_o[1] = 1'b1;\n\n          // additionally check if we are retiring an FPU instruction because we need to make sure that we write all\n          // exception flags\n          if (CVA6Cfg.FpPresent && commit_instr_i[1].fu inside {FPU, FPU_VEC}) begin\n            if (csr_write_fflags_o)\n              csr_wdata_o = {\n                {riscv::XLEN - 5{1'b0}},\n                (commit_instr_i[0].ex.cause[4:0] | commit_instr_i[1].ex.cause[4:0])\n              };\n            else csr_wdata_o = {{riscv::XLEN - 5{1'b0}}, commit_instr_i[1].ex.cause[4:0]};\n\n            csr_write_fflags_o = 1'b1;\n          end\n        end\n      end\n    end\n  end\n\n  // -----------------------------\n  // Exception & Interrupt Logic\n  // -----------------------------\n  // here we know for sure that we are taking the exception\n  always_comb begin : exception_handling\n    // Multiple simultaneous interrupts and traps at the same privilege level are handled in the following decreasing\n    // priority order: external interrupts, software interrupts, timer interrupts, then finally any synchronous traps. (1.10 p.30)\n    // interrupts are correctly prioritized in the CSR reg file, exceptions are prioritized here\n    exception_o.valid = 1'b0;\n    exception_o.cause = '0;\n    exception_o.tval  = '0;\n    // we need a valid instruction in the commit stage\n    if (commit_instr_i[0].valid) begin\n      // ------------------------\n      // check for CSR exception\n      // ------------------------\n      if (csr_exception_i.valid) begin\n        exception_o      = csr_exception_i;\n        // if no earlier exception happened the commit instruction will still contain\n        // the instruction bits from the ID stage. If a earlier exception happened we don't care\n        // as we will overwrite it anyway in the next IF bl\n        exception_o.tval = commit_instr_i[0].ex.tval;\n      end\n      // ------------------------\n      // Earlier Exceptions\n      // ------------------------\n      // but we give precedence to exceptions which happened earlier e.g.: instruction page\n      // faults for example\n      if (commit_instr_i[0].ex.valid) begin\n        exception_o = commit_instr_i[0].ex;\n      end\n    end\n    // Don't take any exceptions iff:\n    // - If we halted the processor\n    if (halt_i) begin\n      exception_o.valid = 1'b0;\n    end\n  end\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.                                          //\n//\n// Author:         Florian Zaruba - zarubaf@iis.ee.ethz.ch\n// Engineer:       Sven Stucki - svstucki@student.ethz.ch\n//\n// Design Name:    Compressed instruction decoder\n// Project Name:   zero-riscy\n// Language:       SystemVerilog\n//\n// Description:    Decodes RISC-V compressed instructions into their RV32\n//                 equivalent. This module is fully combinatorial.\n\n\nmodule compressed_decoder #(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Input instruction coming from fetch stage - FRONTEND\n    input  logic [31:0] instr_i,\n    // Output instruction in uncompressed format - decoder\n    output logic [31:0] instr_o,\n    // Input instruction is illegal - decoder\n    output logic        illegal_instr_o,\n    // Output instruction is compressed - decoder\n    output logic        is_compressed_o\n);\n\n  // -------------------\n  // Compressed Decoder\n  // -------------------\n  always_comb begin\n    illegal_instr_o = 1'b0;\n    instr_o         = '0;\n    is_compressed_o = 1'b1;\n    instr_o         = instr_i;\n\n    // I: |    imm[11:0]    | rs1 | funct3 |    rd    | opcode |\n    // S: | imm[11:5] | rs2 | rs1 | funct3 | imm[4:0] | opcode |\n    unique case (instr_i[1:0])\n      // C0\n      riscv::OpcodeC0: begin\n        unique case (instr_i[15:13])\n          riscv::OpcodeC0Addi4spn: begin\n            // c.addi4spn -> addi rd', x2, imm\n            instr_o = {\n              2'b0,\n              instr_i[10:7],\n              instr_i[12:11],\n              instr_i[5],\n              instr_i[6],\n              2'b00,\n              5'h02,\n              3'b000,\n              2'b01,\n              instr_i[4:2],\n              riscv::OpcodeOpImm\n            };\n            if (instr_i[12:5] == 8'b0) illegal_instr_o = 1'b1;\n          end\n\n          riscv::OpcodeC0Fld: begin\n            if (CVA6Cfg.FpPresent) begin\n              // c.fld -> fld rd', imm(rs1')\n              // CLD: | funct3 | imm[5:3] | rs1' | imm[7:6] | rd' | C0 |\n              instr_o = {\n                4'b0,\n                instr_i[6:5],\n                instr_i[12:10],\n                3'b000,\n                2'b01,\n                instr_i[9:7],\n                3'b011,\n                2'b01,\n                instr_i[4:2],\n                riscv::OpcodeLoadFp\n              };\n            end else begin\n              illegal_instr_o = 1'b1;\n            end\n          end\n\n          riscv::OpcodeC0Lw: begin\n            // c.lw -> lw rd', imm(rs1')\n            instr_o = {\n              5'b0,\n              instr_i[5],\n              instr_i[12:10],\n              instr_i[6],\n              2'b00,\n              2'b01,\n              instr_i[9:7],\n              3'b010,\n              2'b01,\n              instr_i[4:2],\n              riscv::OpcodeLoad\n            };\n          end\n\n          riscv::OpcodeC0Ld: begin\n            // RV64\n            //   c.ld -> ld rd', imm(rs1')\n            // RV32\n            //   c.flw -> flw fprd', imm(rs1')\n            if (riscv::IS_XLEN64) begin\n              // CLD: | funct3 | imm[5:3] | rs1' | imm[7:6] | rd' | C0 |\n              instr_o = {\n                4'b0,\n                instr_i[6:5],\n                instr_i[12:10],\n                3'b000,\n                2'b01,\n                instr_i[9:7],\n                3'b011,\n                2'b01,\n                instr_i[4:2],\n                riscv::OpcodeLoad\n              };\n            end else begin\n              if (CVA6Cfg.FpPresent) begin\n                // CFLW: | funct3 (change to LW) | imm[5:3] | rs1' | imm[2|6] | rd' | C0 |\n                instr_o = {\n                  5'b0,\n                  instr_i[5],\n                  instr_i[12:10],\n                  instr_i[6],\n                  2'b00,\n                  2'b01,\n                  instr_i[9:7],\n                  3'b010,\n                  2'b01,\n                  instr_i[4:2],\n                  riscv::OpcodeLoadFp\n                };\n              end else begin\n                illegal_instr_o = 1'b1;\n              end\n            end\n          end\n\n          riscv::OpcodeC0Zcb: begin\n            if (CVA6Cfg.RVZCB) begin\n              unique case (instr_i[12:10])\n                3'b000: begin\n                  // c.lbu -> lbu rd', uimm(rs1')\n                  instr_o = {\n                    10'b0,\n                    instr_i[5],\n                    instr_i[6],\n                    2'b01,\n                    instr_i[9:7],\n                    3'b100,\n                    2'b01,\n                    instr_i[4:2],\n                    riscv::OpcodeLoad\n                  };\n                end\n\n                3'b001: begin\n                  if (instr_i[6]) begin\n                    // c.lh -> lh rd', uimm(rs1')\n                    instr_o = {\n                      10'b0,\n                      instr_i[5],\n                      1'b0,\n                      2'b01,\n                      instr_i[9:7],\n                      3'b001,\n                      2'b01,\n                      instr_i[4:2],\n                      riscv::OpcodeLoad\n                    };\n                  end else begin\n                    // c.lhu -> lhu rd', uimm(rs1')\n                    instr_o = {\n                      10'b0,\n                      instr_i[5],\n                      1'b0,\n                      2'b01,\n                      instr_i[9:7],\n                      3'b101,\n                      2'b01,\n                      instr_i[4:2],\n                      riscv::OpcodeLoad\n                    };\n                  end\n                end\n\n                3'b010: begin\n                  // c.sb -> sb rs2', uimm(rs1')\n                  instr_o = {\n                    7'b0,\n                    2'b01,\n                    instr_i[4:2],\n                    2'b01,\n                    instr_i[9:7],\n                    3'b000,\n                    3'b0,\n                    instr_i[5],\n                    instr_i[6],\n                    riscv::OpcodeStore\n                  };\n                end\n\n                3'b011: begin\n                  // c.sh -> sh rs2', uimm(rs1')\n                  instr_o = {\n                    7'b0,\n                    2'b01,\n                    instr_i[4:2],\n                    2'b01,\n                    instr_i[9:7],\n                    3'b001,\n                    3'b0,\n                    instr_i[5],\n                    1'b0,\n                    riscv::OpcodeStore\n                  };\n                end\n\n                default: begin\n                  illegal_instr_o = 1'b1;\n                end\n              endcase\n\n            end else begin\n              instr_o = instr_i;\n              illegal_instr_o = 1'b1;\n            end\n          end\n\n          riscv::OpcodeC0Fsd: begin\n            if (CVA6Cfg.FpPresent) begin\n              // c.fsd -> fsd rs2', imm(rs1')\n              instr_o = {\n                4'b0,\n                instr_i[6:5],\n                instr_i[12],\n                2'b01,\n                instr_i[4:2],\n                2'b01,\n                instr_i[9:7],\n                3'b011,\n                instr_i[11:10],\n                3'b000,\n                riscv::OpcodeStoreFp\n              };\n            end else begin\n              illegal_instr_o = 1'b1;\n            end\n          end\n\n          riscv::OpcodeC0Sw: begin\n            // c.sw -> sw rs2', imm(rs1')\n            instr_o = {\n              5'b0,\n              instr_i[5],\n              instr_i[12],\n              2'b01,\n              instr_i[4:2],\n              2'b01,\n              instr_i[9:7],\n              3'b010,\n              instr_i[11:10],\n              instr_i[6],\n              2'b00,\n              riscv::OpcodeStore\n            };\n          end\n\n          riscv::OpcodeC0Sd: begin\n            // RV64\n            //   c.sd -> sd rs2', imm(rs1')\n            // RV32\n            //   c.fsw -> fsw fprs2', imm(rs1')\n            if (riscv::IS_XLEN64) begin\n              instr_o = {\n                4'b0,\n                instr_i[6:5],\n                instr_i[12],\n                2'b01,\n                instr_i[4:2],\n                2'b01,\n                instr_i[9:7],\n                3'b011,\n                instr_i[11:10],\n                3'b000,\n                riscv::OpcodeStore\n              };\n            end else begin\n              if (CVA6Cfg.FpPresent) begin\n                instr_o = {\n                  5'b0,\n                  instr_i[5],\n                  instr_i[12],\n                  2'b01,\n                  instr_i[4:2],\n                  2'b01,\n                  instr_i[9:7],\n                  3'b010,\n                  instr_i[11:10],\n                  instr_i[6],\n                  2'b00,\n                  riscv::OpcodeStoreFp\n                };\n              end else begin\n                illegal_instr_o = 1'b1;\n              end\n            end\n          end\n\n          default: begin\n            illegal_instr_o = 1'b1;\n          end\n        endcase\n      end\n\n      // C1\n      riscv::OpcodeC1: begin\n        unique case (instr_i[15:13])\n          riscv::OpcodeC1Addi: begin\n            // c.addi -> addi rd, rd, nzimm\n            // c.nop -> addi 0, 0, 0\n            instr_o = {\n              {6{instr_i[12]}},\n              instr_i[12],\n              instr_i[6:2],\n              instr_i[11:7],\n              3'b0,\n              instr_i[11:7],\n              riscv::OpcodeOpImm\n            };\n          end\n\n\n          riscv::OpcodeC1Addiw: begin  // or riscv::OpcodeC1Jal for RV32IC\n            if (riscv::IS_XLEN64) begin\n              // c.addiw -> addiw rd, rd, nzimm for RV64IC\n              if (instr_i[11:7] != 5'h0) begin  // only valid if the destination is not r0\n                instr_o = {\n                  {6{instr_i[12]}},\n                  instr_i[12],\n                  instr_i[6:2],\n                  instr_i[11:7],\n                  3'b0,\n                  instr_i[11:7],\n                  riscv::OpcodeOpImm32\n                };\n              end else begin\n                illegal_instr_o = 1'b1;\n              end\n            end else begin\n              // c.jal -> jal x1, imm for RV32IC only\n              instr_o = {\n                instr_i[12],\n                instr_i[8],\n                instr_i[10:9],\n                instr_i[6],\n                instr_i[7],\n                instr_i[2],\n                instr_i[11],\n                instr_i[5:3],\n                {9{instr_i[12]}},\n                5'b1,\n                riscv::OpcodeJal\n              };\n\n\n\n            end\n          end\n\n          riscv::OpcodeC1Li: begin\n            // c.li -> addi rd, x0, nzimm\n            instr_o = {\n              {6{instr_i[12]}},\n              instr_i[12],\n              instr_i[6:2],\n              5'b0,\n              3'b0,\n              instr_i[11:7],\n              riscv::OpcodeOpImm\n            };\n          end\n\n          riscv::OpcodeC1LuiAddi16sp: begin\n            // c.lui -> lui rd, imm\n            instr_o = {{15{instr_i[12]}}, instr_i[6:2], instr_i[11:7], riscv::OpcodeLui};\n\n            if (instr_i[11:7] == 5'h02) begin\n              // c.addi16sp -> addi x2, x2, nzimm\n              instr_o = {\n                {3{instr_i[12]}},\n                instr_i[4:3],\n                instr_i[5],\n                instr_i[2],\n                instr_i[6],\n                4'b0,\n                5'h02,\n                3'b000,\n                5'h02,\n                riscv::OpcodeOpImm\n              };\n            end\n\n            if ({instr_i[12], instr_i[6:2]} == 6'b0) illegal_instr_o = 1'b1;\n          end\n\n          riscv::OpcodeC1MiscAlu: begin\n            unique case (instr_i[11:10])\n              2'b00, 2'b01: begin\n                // 00: c.srli -> srli rd, rd, shamt\n                // 01: c.srai -> srai rd, rd, shamt\n                instr_o = {\n                  1'b0,\n                  instr_i[10],\n                  4'b0,\n                  instr_i[12],\n                  instr_i[6:2],\n                  2'b01,\n                  instr_i[9:7],\n                  3'b101,\n                  2'b01,\n                  instr_i[9:7],\n                  riscv::OpcodeOpImm\n                };\n              end\n\n              2'b10: begin\n                // c.andi -> andi rd, rd, imm\n                instr_o = {\n                  {6{instr_i[12]}},\n                  instr_i[12],\n                  instr_i[6:2],\n                  2'b01,\n                  instr_i[9:7],\n                  3'b111,\n                  2'b01,\n                  instr_i[9:7],\n                  riscv::OpcodeOpImm\n                };\n              end\n\n              2'b11: begin\n                unique case ({\n                  instr_i[12], instr_i[6:5]\n                })\n                  3'b000: begin\n                    // c.sub -> sub rd', rd', rs2'\n                    instr_o = {\n                      2'b01,\n                      5'b0,\n                      2'b01,\n                      instr_i[4:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b000,\n                      2'b01,\n                      instr_i[9:7],\n                      riscv::OpcodeOp\n                    };\n                  end\n\n                  3'b001: begin\n                    // c.xor -> xor rd', rd', rs2'\n                    instr_o = {\n                      7'b0,\n                      2'b01,\n                      instr_i[4:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b100,\n                      2'b01,\n                      instr_i[9:7],\n                      riscv::OpcodeOp\n                    };\n                  end\n\n                  3'b010: begin\n                    // c.or  -> or  rd', rd', rs2'\n                    instr_o = {\n                      7'b0,\n                      2'b01,\n                      instr_i[4:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b110,\n                      2'b01,\n                      instr_i[9:7],\n                      riscv::OpcodeOp\n                    };\n                  end\n\n                  3'b011: begin\n                    // c.and -> and rd', rd', rs2'\n                    instr_o = {\n                      7'b0,\n                      2'b01,\n                      instr_i[4:2],\n                      2'b01,\n                      instr_i[9:7],\n                      3'b111,\n                      2'b01,\n                      instr_i[9:7],\n                      riscv::OpcodeOp\n                    };\n                  end\n\n                  3'b100: begin\n                    if (riscv::IS_XLEN64) begin\n                      // c.subw -> subw rd', rd', rs2'\n                      instr_o = {\n                        2'b01,\n                        5'b0,\n                        2'b01,\n                        instr_i[4:2],\n                        2'b01,\n                        instr_i[9:7],\n                        3'b000,\n                        2'b01,\n                        instr_i[9:7],\n                        riscv::OpcodeOp32\n                      };\n                    end else begin\n                      illegal_instr_o = 1'b1;\n                    end\n                  end\n\n                  3'b101: begin\n                    if (riscv::IS_XLEN64) begin\n                      // c.addw -> addw rd', rd', rs2'\n                      instr_o = {\n                        2'b00,\n                        5'b0,\n                        2'b01,\n                        instr_i[4:2],\n                        2'b01,\n                        instr_i[9:7],\n                        3'b000,\n                        2'b01,\n                        instr_i[9:7],\n                        riscv::OpcodeOp32\n                      };\n                    end else begin\n                      illegal_instr_o = 1'b1;\n                    end\n                  end\n\n                  3'b110: begin\n                    if (CVA6Cfg.RVZCB) begin\n                      // c.mul -> mul rd', rd', rs2'\n                      instr_o = {\n                        6'b0,\n                        1'b1,\n                        2'b01,\n                        instr_i[4:2],\n                        2'b01,\n                        instr_i[9:7],\n                        3'b000,\n                        2'b01,\n                        instr_i[9:7],\n                        riscv::OpcodeOp\n                      };\n                    end else begin\n                      instr_o = instr_i;\n                      illegal_instr_o = 1'b1;\n                    end\n                  end\n\n                  3'b111: begin\n                    if (CVA6Cfg.RVZCB) begin\n\n                      unique case (instr_i[4:2])\n                        3'b000: begin\n                          // c.zext.b -> andi rd', rd', 0xff\n                          instr_o = {\n                            4'b0,\n                            8'hFF,\n                            2'b01,\n                            instr_i[9:7],\n                            3'b111,\n                            2'b01,\n                            instr_i[9:7],\n                            riscv::OpcodeOpImm\n                          };\n                        end\n\n                        3'b001: begin\n                          if (CVA6Cfg.RVB) begin\n                            // c.sext.b -> sext.b rd', rd'\n                            instr_o = {\n                              7'h30,\n                              5'h4,\n                              2'b01,\n                              instr_i[9:7],\n                              3'b001,\n                              2'b01,\n                              instr_i[9:7],\n                              riscv::OpcodeOpImm\n                            };\n                          end else illegal_instr_o = 1'b1;\n                        end\n\n                        3'b010: begin\n                          if (CVA6Cfg.RVB) begin\n                            // c.zext.h -> zext.h rd', rd'\n                            if (riscv::IS_XLEN64) begin\n                              instr_o = {\n                                7'h4,\n                                5'h0,\n                                2'b01,\n                                instr_i[9:7],\n                                3'b100,\n                                2'b01,\n                                instr_i[9:7],\n                                riscv::OpcodeOp32\n                              };\n                            end else begin\n                              instr_o = {\n                                7'h4,\n                                5'h0,\n                                2'b01,\n                                instr_i[9:7],\n                                3'b100,\n                                2'b01,\n                                instr_i[9:7],\n                                riscv::OpcodeOp\n                              };\n                            end\n                          end else illegal_instr_o = 1'b1;\n                        end\n\n                        3'b011: begin\n                          if (CVA6Cfg.RVB) begin\n                            // c.sext.h -> sext.h rd', rd'\n                            instr_o = {\n                              7'h30,\n                              5'h5,\n                              2'b01,\n                              instr_i[9:7],\n                      "}
{"text": "        3'b001,\n                              2'b01,\n                              instr_i[9:7],\n                              riscv::OpcodeOpImm\n                            };\n                          end else illegal_instr_o = 1'b1;\n                        end\n\n                        3'b100: begin\n                          if (CVA6Cfg.RVB) begin\n                            // c.zext.w -> add.uw\n                            if (riscv::IS_XLEN64) begin\n                              instr_o = {\n                                7'h4,\n                                5'h0,\n                                2'b01,\n                                instr_i[9:7],\n                                3'b000,\n                                2'b01,\n                                instr_i[9:7],\n                                riscv::OpcodeOp32\n                              };\n                            end else begin\n                              illegal_instr_o = 1'b1;\n                            end\n                          end else illegal_instr_o = 1'b1;\n                        end\n\n                        3'b101: begin\n                          // c.not -> xori rd', rd', -1\n                          instr_o = {\n                            12'hFFF,\n                            2'b01,\n                            instr_i[9:7],\n                            3'b100,\n                            2'b01,\n                            instr_i[9:7],\n                            riscv::OpcodeOpImm\n                          };\n                        end\n\n                        default: begin\n                          instr_o = instr_i;\n                          illegal_instr_o = 1;\n                        end\n                      endcase\n                    end\n                  end\n                endcase\n              end\n            endcase\n          end\n\n          riscv::OpcodeC1J: begin\n            // 101: c.j   -> jal x0, imm\n            instr_o = {\n              instr_i[12],\n              instr_i[8],\n              instr_i[10:9],\n              instr_i[6],\n              instr_i[7],\n              instr_i[2],\n              instr_i[11],\n              instr_i[5:3],\n              {9{instr_i[12]}},\n              4'b0,\n              ~instr_i[15],\n              riscv::OpcodeJal\n            };\n          end\n\n          riscv::OpcodeC1Beqz, riscv::OpcodeC1Bnez: begin\n            // 0: c.beqz -> beq rs1', x0, imm\n            // 1: c.bnez -> bne rs1', x0, imm\n            instr_o = {\n              {4{instr_i[12]}},\n              instr_i[6:5],\n              instr_i[2],\n              5'b0,\n              2'b01,\n              instr_i[9:7],\n              2'b00,\n              instr_i[13],\n              instr_i[11:10],\n              instr_i[4:3],\n              instr_i[12],\n              riscv::OpcodeBranch\n            };\n          end\n        endcase\n      end\n\n      // C2\n      riscv::OpcodeC2: begin\n        unique case (instr_i[15:13])\n          riscv::OpcodeC2Slli: begin\n            // c.slli -> slli rd, rd, shamt\n            instr_o = {\n              6'b0,\n              instr_i[12],\n              instr_i[6:2],\n              instr_i[11:7],\n              3'b001,\n              instr_i[11:7],\n              riscv::OpcodeOpImm\n            };\n          end\n\n          riscv::OpcodeC2Fldsp: begin\n            if (CVA6Cfg.FpPresent) begin\n              // c.fldsp -> fld rd, imm(x2)\n              instr_o = {\n                3'b0,\n                instr_i[4:2],\n                instr_i[12],\n                instr_i[6:5],\n                3'b000,\n                5'h02,\n                3'b011,\n                instr_i[11:7],\n                riscv::OpcodeLoadFp\n              };\n            end else begin\n              illegal_instr_o = 1'b1;\n            end\n          end\n\n          riscv::OpcodeC2Lwsp: begin\n            // c.lwsp -> lw rd, imm(x2)\n            instr_o = {\n              4'b0,\n              instr_i[3:2],\n              instr_i[12],\n              instr_i[6:4],\n              2'b00,\n              5'h02,\n              3'b010,\n              instr_i[11:7],\n              riscv::OpcodeLoad\n            };\n            if (instr_i[11:7] == 5'b0) illegal_instr_o = 1'b1;\n          end\n\n          riscv::OpcodeC2Ldsp: begin\n            // RV64\n            //   c.ldsp -> ld rd, imm(x2)\n            // RV32\n            //   c.flwsp -> flw fprd, imm(x2)\n            if (riscv::IS_XLEN64) begin\n              instr_o = {\n                3'b0,\n                instr_i[4:2],\n                instr_i[12],\n                instr_i[6:5],\n                3'b000,\n                5'h02,\n                3'b011,\n                instr_i[11:7],\n                riscv::OpcodeLoad\n              };\n              if (instr_i[11:7] == 5'b0) illegal_instr_o = 1'b1;\n            end else begin\n              if (CVA6Cfg.FpPresent) begin\n                instr_o = {\n                  4'b0,\n                  instr_i[3:2],\n                  instr_i[12],\n                  instr_i[6:4],\n                  2'b00,\n                  5'h02,\n                  3'b010,\n                  instr_i[11:7],\n                  riscv::OpcodeLoadFp\n                };\n              end else begin\n                illegal_instr_o = 1'b1;\n              end\n            end\n          end\n\n          riscv::OpcodeC2JalrMvAdd: begin\n            if (instr_i[12] == 1'b0) begin\n              // c.mv -> add rd/rs1, x0, rs2\n              instr_o = {7'b0, instr_i[6:2], 5'b0, 3'b0, instr_i[11:7], riscv::OpcodeOp};\n\n              if (instr_i[6:2] == 5'b0) begin\n                // c.jr -> jalr x0, rd/rs1, 0\n                instr_o = {12'b0, instr_i[11:7], 3'b0, 5'b0, riscv::OpcodeJalr};\n                // rs1 != 0\n                illegal_instr_o = (instr_i[11:7] != '0) ? 1'b0 : 1'b1;\n              end\n            end else begin\n              // c.add -> add rd, rd, rs2\n              instr_o = {7'b0, instr_i[6:2], instr_i[11:7], 3'b0, instr_i[11:7], riscv::OpcodeOp};\n\n              if (instr_i[6:2] == 5'b0) begin\n                if (instr_i[11:7] == 5'b0) begin\n                  // c.ebreak -> ebreak\n                  instr_o = {32'h00_10_00_73};\n                end else begin\n                  // c.jalr -> jalr x1, rs1, 0\n                  instr_o = {12'b0, instr_i[11:7], 3'b000, 5'b00001, riscv::OpcodeJalr};\n                end\n              end\n            end\n          end\n\n          riscv::OpcodeC2Fsdsp: begin\n            if (CVA6Cfg.FpPresent) begin\n              // c.fsdsp -> fsd rs2, imm(x2)\n              instr_o = {\n                3'b0,\n                instr_i[9:7],\n                instr_i[12],\n                instr_i[6:2],\n                5'h02,\n                3'b011,\n                instr_i[11:10],\n                3'b000,\n                riscv::OpcodeStoreFp\n              };\n            end else begin\n              illegal_instr_o = 1'b1;\n            end\n          end\n\n          riscv::OpcodeC2Swsp: begin\n            // c.swsp -> sw rs2, imm(x2)\n            instr_o = {\n              4'b0,\n              instr_i[8:7],\n              instr_i[12],\n              instr_i[6:2],\n              5'h02,\n              3'b010,\n              instr_i[11:9],\n              2'b00,\n              riscv::OpcodeStore\n            };\n          end\n\n          riscv::OpcodeC2Sdsp: begin\n            // RV64\n            //   c.sdsp -> sd rs2, imm(x2)\n            // RV32\n            //   c.fswsp -> fsw fprs2, imm(x2)\n            if (riscv::IS_XLEN64) begin\n              instr_o = {\n                3'b0,\n                instr_i[9:7],\n                instr_i[12],\n                instr_i[6:2],\n                5'h02,\n                3'b011,\n                instr_i[11:10],\n                3'b000,\n                riscv::OpcodeStore\n              };\n            end else begin\n              if (CVA6Cfg.FpPresent) begin\n                instr_o = {\n                  4'b0,\n                  instr_i[8:7],\n                  instr_i[12],\n                  instr_i[6:2],\n                  5'h02,\n                  3'b010,\n                  instr_i[11:9],\n                  2'b00,\n                  riscv::OpcodeStoreFp\n                };\n              end else begin\n                illegal_instr_o = 1'b1;\n              end\n            end\n          end\n\n          default: begin\n            illegal_instr_o = 1'b1;\n          end\n        endcase\n      end\n\n      // normal instruction\n      default: is_compressed_o = 1'b0;\n    endcase\n\n    // Check if the instruction was illegal, if it was then output the offending instruction (zero-extended)\n    if (illegal_instr_o) begin\n      instr_o = instr_i;\n    end\n  end\nendmodule\n"}
{"text": "// Copyright 2023 Thales DIS France SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\npackage config_pkg;\n\n  // ---------------\n  // Global Config\n  // ---------------\n  localparam int unsigned ILEN = 32;\n  localparam int unsigned NRET = 1;\n\n  /// The NoC type is a top-level parameter, hence we need a bit more\n  /// information on what protocol those type parameters are supporting.\n  /// Currently two values are supported\"\n  typedef enum {\n    /// The \"classic\" AXI4 protocol.\n    NOC_TYPE_AXI4_ATOP,\n    /// In the OpenPiton setting the WT cache is connected to the L15.\n    NOC_TYPE_L15_BIG_ENDIAN,\n    NOC_TYPE_L15_LITTLE_ENDIAN\n  } noc_type_e;\n\n  /// Cache type parameter\n  typedef enum logic [1:0] {\n    WB = 0,\n    WT = 1,\n    HPDCACHE = 2\n  } cache_type_t;\n\n  localparam NrMaxRules = 16;\n\n  typedef struct packed {\n    // Number of commit ports\n    int unsigned                 NrCommitPorts;\n    // AXI address width\n    int unsigned                 AxiAddrWidth;\n    // AXI data width\n    int unsigned                 AxiDataWidth;\n    // AXI ID width\n    int unsigned                 AxiIdWidth;\n    // AXI User width\n    int unsigned                 AxiUserWidth;\n    // Load buffer entry buffer\n    int unsigned                 NrLoadBufEntries;\n    // Floating Point\n    bit                          FpuEn;\n    // Non standard 16bits Floating Point\n    bit                          XF16;\n    // Non standard 16bits Floating Point Alt\n    bit                          XF16ALT;\n    // Non standard 8bits Floating Point\n    bit                          XF8;\n    // Atomic RISC-V extension\n    bit                          RVA;\n    // Bit manipulation RISC-V extension\n    bit                          RVB;\n    // Vector RISC-V extension\n    bit                          RVV;\n    // Compress RISC-V extension\n    bit                          RVC;\n    // Zcb RISC-V extension\n    bit                          RVZCB;\n    // Non standard Vector Floating Point\n    bit                          XFVec;\n    // CV-X-IF coprocessor interface is supported\n    bit                          CvxifEn;\n    // Zicond RISC-V extension\n    bit                          ZiCondExtEn;\n    // Supervisor mode\n    bit                          RVS;\n    // User mode\n    bit                          RVU;\n    // Address to jump when halt request\n    logic [63:0]                 HaltAddress;\n    // Address to jump when exception \n    logic [63:0]                 ExceptionAddress;\n    // Return address stack depth\n    int unsigned                 RASDepth;\n    // Branch target buffer entries\n    int unsigned                 BTBEntries;\n    // Branch history entries\n    int unsigned                 BHTEntries;\n    // Base address of the debug module\n    logic [63:0]                 DmBaseAddress;\n    // Tval Support Enable\n    bit                          TvalEn;\n    // Number of PMP entries\n    int unsigned                 NrPMPEntries;\n    // PMP CSR configuration reset values\n    logic [15:0][63:0]           PMPCfgRstVal;\n    // PMP CSR address reset values\n    logic [15:0][63:0]           PMPAddrRstVal;\n    // PMP CSR read-only bits\n    bit [15:0]                   PMPEntryReadOnly;\n    // NOC bus type\n    noc_type_e                   NOCType;\n    // Number of PMA non idempotent rules\n    int unsigned                 NrNonIdempotentRules;\n    // PMA NonIdempotent region base address\n    logic [NrMaxRules-1:0][63:0] NonIdempotentAddrBase;\n    // PMA NonIdempotent region length\n    logic [NrMaxRules-1:0][63:0] NonIdempotentLength;\n    // Number of PMA regions with execute rules\n    int unsigned                 NrExecuteRegionRules;\n    // PMA Execute region base address\n    logic [NrMaxRules-1:0][63:0] ExecuteRegionAddrBase;\n    // PMA Execute region address base\n    logic [NrMaxRules-1:0][63:0] ExecuteRegionLength;\n    // Number of PMA regions with cache rules\n    int unsigned                 NrCachedRegionRules;\n    // PMA cache region base address\n    logic [NrMaxRules-1:0][63:0] CachedRegionAddrBase;\n    // PMA cache region rules\n    logic [NrMaxRules-1:0][63:0] CachedRegionLength;\n    // Maximum number of outstanding stores\n    int unsigned                 MaxOutstandingStores;\n    // Debug support\n    bit                          DebugEn;\n    // AXI burst in write\n    bit                          AxiBurstWriteEn;\n  } cva6_user_cfg_t;\n\n  typedef struct packed {\n    /// Number of commit ports, i.e., maximum number of instructions that the\n    /// core can retire per cycle. It can be beneficial to have more commit\n    /// ports than issue ports, for the scoreboard to empty out in case one\n    /// instruction stalls a little longer.\n    int unsigned NrCommitPorts;\n    /// AXI parameters.\n    int unsigned AxiAddrWidth;\n    int unsigned AxiDataWidth;\n    int unsigned AxiIdWidth;\n    int unsigned AxiUserWidth;\n    int unsigned NrLoadBufEntries;\n    bit          FpuEn;\n    bit          XF16;\n    bit          XF16ALT;\n    bit          XF8;\n    bit          RVA;\n    bit          RVB;\n    bit          RVV;\n    bit          RVC;\n    bit          RVZCB;\n    bit          XFVec;\n    bit          CvxifEn;\n    bit          ZiCondExtEn;\n    // Calculated\n    bit          RVF;\n    bit          RVD;\n    bit          FpPresent;\n    bit          NSX;\n    int unsigned FLen;\n    bit          RVFVec;\n    bit          XF16Vec;\n    bit          XF16ALTVec;\n    bit          XF8Vec;\n    int unsigned NrRgprPorts;\n    int unsigned NrWbPorts;\n    bit          EnableAccelerator;\n    bit          RVS;                //Supervisor mode\n    bit          RVU;                //User mode\n\n    logic [63:0]                 HaltAddress;\n    logic [63:0]                 ExceptionAddress;\n    int unsigned                 RASDepth;\n    int unsigned                 BTBEntries;\n    int unsigned                 BHTEntries;\n    logic [63:0]                 DmBaseAddress;\n    bit                          TvalEn;\n    int unsigned                 NrPMPEntries;\n    logic [15:0][63:0]           PMPCfgRstVal;\n    logic [15:0][63:0]           PMPAddrRstVal;\n    bit [15:0]                   PMPEntryReadOnly;\n    noc_type_e                   NOCType;\n    int unsigned                 NrNonIdempotentRules;\n    logic [NrMaxRules-1:0][63:0] NonIdempotentAddrBase;\n    logic [NrMaxRules-1:0][63:0] NonIdempotentLength;\n    int unsigned                 NrExecuteRegionRules;\n    logic [NrMaxRules-1:0][63:0] ExecuteRegionAddrBase;\n    logic [NrMaxRules-1:0][63:0] ExecuteRegionLength;\n    int unsigned                 NrCachedRegionRules;\n    logic [NrMaxRules-1:0][63:0] CachedRegionAddrBase;\n    logic [NrMaxRules-1:0][63:0] CachedRegionLength;\n    int unsigned                 MaxOutstandingStores;\n    bit                          DebugEn;\n    bit                          NonIdemPotenceEn;       // Currently only used by V extension (Ara)\n    bit                          AxiBurstWriteEn;\n  } cva6_cfg_t;\n\n  /// Empty configuration to sanity check proper parameter passing. Whenever\n  /// you develop a module that resides within the core, assign this constant.\n  localparam cva6_cfg_t cva6_cfg_empty = '0;\n\n  /// Utility function being called to check parameters. Not all values make\n  /// sense for all parameters, here is the place to sanity check them.\n  function automatic void check_cfg(cva6_cfg_t Cfg);\n    // pragma translate_off\n`ifndef VERILATOR\n    assert (Cfg.RASDepth > 0);\n    assert (2 ** $clog2(Cfg.BTBEntries) == Cfg.BTBEntries);\n    assert (2 ** $clog2(Cfg.BHTEntries) == Cfg.BHTEntries);\n    assert (Cfg.NrNonIdempotentRules <= NrMaxRules);\n    assert (Cfg.NrExecuteRegionRules <= NrMaxRules);\n    assert (Cfg.NrCachedRegionRules <= NrMaxRules);\n    assert (Cfg.NrPMPEntries <= 16);\n`endif\n    // pragma translate_on\n  endfunction\n\n  function automatic logic range_check(logic [63:0] base, logic [63:0] len, logic [63:0] address);\n    // if len is a power of two, and base is properly aligned, this check could be simplified\n    // Extend base by one bit to prevent an overflow.\n    return (address >= base) && (({1'b0, address}) < (65'(base) + len));\n  endfunction : range_check\n\n\n  function automatic logic is_inside_nonidempotent_regions(cva6_cfg_t Cfg, logic [63:0] address);\n    logic [NrMaxRules-1:0] pass;\n    pass = '0;\n    for (int unsigned k = 0; k < Cfg.NrNonIdempotentRules; k++) begin\n      pass[k] = range_check(Cfg.NonIdempotentAddrBase[k], Cfg.NonIdempotentLength[k], address);\n    end\n    return |pass;\n  endfunction : is_inside_nonidempotent_regions\n\n  function automatic logic is_inside_execute_regions(cva6_cfg_t Cfg, logic [63:0] address);\n    // if we don't specify any region we assume everything is accessible\n    logic [NrMaxRules-1:0] pass;\n    pass = '0;\n    for (int unsigned k = 0; k < Cfg.NrExecuteRegionRules; k++) begin\n      pass[k] = range_check(Cfg.ExecuteRegionAddrBase[k], Cfg.ExecuteRegionLength[k], address);\n    end\n    return |pass;\n  endfunction : is_inside_execute_regions\n\n  function automatic logic is_inside_cacheable_regions(cva6_cfg_t Cfg, logic [63:0] address);\n    automatic logic [NrMaxRules-1:0] pass;\n    pass = '0;\n    for (int unsigned k = 0; k < Cfg.NrCachedRegionRules; k++) begin\n      pass[k] = range_check(Cfg.CachedRegionAddrBase[k], Cfg.CachedRegionLength[k], address);\n    end\n    return |pass;\n  endfunction : is_inside_cacheable_regions\n\nendpackage\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 08.05.2017\n// Description: Flush controller\n\n\nmodule controller\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Set PC om PC Gen - FRONTEND\n    output logic set_pc_commit_o,\n    // Flush the IF stage - FRONTEND\n    output logic flush_if_o,\n    // Flush un-issued instructions of the scoreboard - FRONTEND\n    output logic flush_unissued_instr_o,\n    // Flush ID stage - ID_STAGE\n    output logic flush_id_o,\n    // Flush EX stage - EX_STAGE\n    output logic flush_ex_o,\n    // Flush branch predictors - FRONTEND\n    output logic flush_bp_o,\n    // Flush ICache - CACHE\n    output logic flush_icache_o,\n    // Flush DCache - CACHE\n    output logic flush_dcache_o,\n    // Acknowledge the whole DCache Flush - CACHE\n    input logic flush_dcache_ack_i,\n    // Flush TLBs - EX_STAGE\n    output logic flush_tlb_o,\n    // Halt request from CSR (WFI instruction) - CSR_REGFILE\n    input logic halt_csr_i,\n    // Halt request from accelerator dispatcher - ACC_DISPATCHER\n    input logic halt_acc_i,\n    // Halt signal to commit stage - COMMIT_STAGE\n    output logic halt_o,\n    // Return from exception - CSR_REGFILE\n    input logic eret_i,\n    // We got an exception, flush the pipeline - FRONTEND\n    input logic ex_valid_i,\n    // set the debug pc from CSR - FRONTEND\n    input logic set_debug_pc_i,\n    // We got a resolved branch, check if we need to flush the front-end - EX_STAGE\n    input bp_resolve_t resolved_branch_i,\n    // We got an instruction which altered the CSR, flush the pipeline - CSR_REGFILE\n    input logic flush_csr_i,\n    // fence.i in - ACC_DISPATCH\n    input logic fence_i_i,\n    // fence in - ACC_DISPATCH\n    input logic fence_i,\n    // We got an instruction to flush the TLBs and pipeline - COMMIT_STAGE\n    input logic sfence_vma_i,\n    // Flush request from commit stage - COMMIT_STAGE\n    input logic flush_commit_i,\n    // Flush request from accelerator - ACC_DISPATCHER\n    input logic flush_acc_i\n);\n\n  // active fence - high if we are currently flushing the dcache\n  logic fence_active_d, fence_active_q;\n  logic flush_dcache;\n\n  // ------------\n  // Flush CTRL\n  // ------------\n  always_comb begin : flush_ctrl\n    fence_active_d         = fence_active_q;\n    set_pc_commit_o        = 1'b0;\n    flush_if_o             = 1'b0;\n    flush_unissued_instr_o = 1'b0;\n    flush_id_o             = 1'b0;\n    flush_ex_o             = 1'b0;\n    flush_dcache           = 1'b0;\n    flush_icache_o         = 1'b0;\n    flush_tlb_o            = 1'b0;\n    flush_bp_o             = 1'b0;\n    // ------------\n    // Mis-predict\n    // ------------\n    // flush on mispredict\n    if (resolved_branch_i.is_mispredict) begin\n      // flush only un-issued instructions\n      flush_unissued_instr_o = 1'b1;\n      // and if stage\n      flush_if_o             = 1'b1;\n    end\n\n    // ---------------------------------\n    // FENCE\n    // ---------------------------------\n    if (fence_i) begin\n      // this can be seen as a CSR instruction with side-effect\n      set_pc_commit_o        = 1'b1;\n      flush_if_o             = 1'b1;\n      flush_unissued_instr_o = 1'b1;\n      flush_id_o             = 1'b1;\n      flush_ex_o             = 1'b1;\n      // this is not needed in the case since we\n      // have a write-through cache in this case\n      if (DCACHE_TYPE == int'(config_pkg::WB)) begin\n        flush_dcache   = 1'b1;\n        fence_active_d = 1'b1;\n      end\n    end\n\n    // ---------------------------------\n    // FENCE.I\n    // ---------------------------------\n    if (fence_i_i) begin\n      set_pc_commit_o        = 1'b1;\n      flush_if_o             = 1'b1;\n      flush_unissued_instr_o = 1'b1;\n      flush_id_o             = 1'b1;\n      flush_ex_o             = 1'b1;\n      flush_icache_o         = 1'b1;\n      // this is not needed in the case since we\n      // have a write-through cache in this case\n      if (DCACHE_TYPE == int'(config_pkg::WB)) begin\n        flush_dcache   = 1'b1;\n        fence_active_d = 1'b1;\n      end\n    end\n\n    // this is not needed in the case since we\n    // have a write-through cache in this case\n    if (DCACHE_TYPE == int'(config_pkg::WB)) begin\n      // wait for the acknowledge here\n      if (flush_dcache_ack_i && fence_active_q) begin\n        fence_active_d = 1'b0;\n        // keep the flush dcache signal high as long as we didn't get the acknowledge from the cache\n      end else if (fence_active_q) begin\n        flush_dcache = 1'b1;\n      end\n    end\n    // ---------------------------------\n    // SFENCE.VMA\n    // ---------------------------------\n    if (CVA6Cfg.RVS && sfence_vma_i) begin\n      set_pc_commit_o        = 1'b1;\n      flush_if_o             = 1'b1;\n      flush_unissued_instr_o = 1'b1;\n      flush_id_o             = 1'b1;\n      flush_ex_o             = 1'b1;\n\n      flush_tlb_o            = 1'b1;\n    end\n\n    // Set PC to commit stage and flush pipeline\n    if (flush_csr_i || flush_acc_i) begin\n      set_pc_commit_o        = 1'b1;\n      flush_if_o             = 1'b1;\n      flush_unissued_instr_o = 1'b1;\n      flush_id_o             = 1'b1;\n      flush_ex_o             = 1'b1;\n    end else if (CVA6Cfg.RVA && flush_commit_i) begin\n      set_pc_commit_o        = 1'b1;\n      flush_if_o             = 1'b1;\n      flush_unissued_instr_o = 1'b1;\n      flush_id_o             = 1'b1;\n      flush_ex_o             = 1'b1;\n    end\n\n    // ---------------------------------\n    // 1. Exception\n    // 2. Return from exception\n    // ---------------------------------\n    if (ex_valid_i || eret_i || (CVA6Cfg.DebugEn && set_debug_pc_i)) begin\n      // don't flush pcgen as we want to take the exception: Flush PCGen is not a flush signal\n      // for the PC Gen stage but instead tells it to take the PC we gave it\n      set_pc_commit_o        = 1'b0;\n      flush_if_o             = 1'b1;\n      flush_unissued_instr_o = 1'b1;\n      flush_id_o             = 1'b1;\n      flush_ex_o             = 1'b1;\n      // this potentially reduces performance, but is needed\n      // to suppress speculative fetches to virtual memory from\n      // machine mode. TODO: remove when PMA checkers have been\n      // added to the system\n      flush_bp_o             = 1'b1;\n    end\n  end\n\n  // ----------------------\n  // Halt Logic\n  // ----------------------\n  always_comb begin\n    // halt the core if the fence is active\n    halt_o = halt_csr_i || halt_acc_i || (DCACHE_TYPE == int'(config_pkg::WB) && fence_active_q);\n  end\n\n  // ----------------------\n  // Registers\n  // ----------------------\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      fence_active_q <= 1'b0;\n      flush_dcache_o <= 1'b0;\n    end else begin\n      fence_active_q <= fence_active_d;\n      // register on the flush signal, this signal might be critical\n      flush_dcache_o <= flush_dcache;\n    end\n  end\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 05.05.2017\n// Description: Buffer to hold CSR address, this acts like a functional unit\n//              to the scoreboard.\n\n\nmodule csr_buffer\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Flush CSR - CONTROLLER\n    input logic flush_i,\n    // FU data needed to execute instruction - ISSUE_STAGE\n    input fu_data_t fu_data_i,\n    // CSR FU is ready - ISSUE_STAGE\n    output logic csr_ready_o,\n    // CSR instruction is valid - ISSUE_STAGE\n    input logic csr_valid_i,\n    // CSR buffer result - ISSUE_STAGE\n    output riscv::xlen_t csr_result_o,\n    // commit the pending CSR OP - TO_BE_COMPLETED\n    input logic csr_commit_i,\n    // CSR address to write - COMMIT_STAGE\n    output logic [11:0] csr_addr_o\n);\n  // this is a single entry store buffer for the address of the CSR\n  // which we are going to need in the commit stage\n  struct packed {\n    logic [11:0] csr_address;\n    logic        valid;\n  }\n      csr_reg_n, csr_reg_q;\n\n  // control logic, scoreboard signals\n  assign csr_result_o = fu_data_i.operand_a;\n  assign csr_addr_o   = csr_reg_q.csr_address;\n\n  // write logic\n  always_comb begin : write\n    csr_reg_n   = csr_reg_q;\n    // by default we are ready\n    csr_ready_o = 1'b1;\n    // if we have a valid uncomiited csr req or are just getting one WITHOUT a commit in, we are not ready\n    if ((csr_reg_q.valid || csr_valid_i) && ~csr_commit_i) csr_ready_o = 1'b0;\n    // if we got a valid from the scoreboard\n    // store the CSR address\n    if (csr_valid_i) begin\n      csr_reg_n.csr_address = fu_data_i.operand_b[11:0];\n      csr_reg_n.valid       = 1'b1;\n    end\n    // if we get a commit and no new valid instruction -> clear the valid bit\n    if (csr_commit_i && ~csr_valid_i) begin\n      csr_reg_n.valid = 1'b0;\n    end\n    // clear the buffer if we flushed\n    if (flush_i) csr_reg_n.valid = 1'b0;\n  end\n  // sequential process\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      csr_reg_q <= '{default: 0};\n    end else begin\n      csr_reg_q <= csr_reg_n;\n    end\n  end\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 05.05.2017\n// Description: CSR Register File as specified by RISC-V\n\n\nmodule csr_regfile\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg        = config_pkg::cva6_cfg_empty,\n    parameter int                    AsidWidth      = 1,\n    parameter int unsigned           MHPMCounterNum = 6\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Timer threw a interrupt - SUBSYSTEM\n    input logic time_irq_i,\n    // send a flush request out when a CSR with a side effect changes - CONTROLLER\n    output logic flush_o,\n    // halt requested - CONTROLLER\n    output logic halt_csr_o,\n    // Instruction to be committed - ID_STAGE\n    input scoreboard_entry_t [CVA6Cfg.NrCommitPorts-1:0] commit_instr_i,\n    // Commit acknowledged a instruction -> increase instret CSR - COMMIT_STAGE\n    input logic [CVA6Cfg.NrCommitPorts-1:0] commit_ack_i,\n    // Address from which to start booting, mtvec is set to the same address - SUBSYSTEM\n    input logic [riscv::VLEN-1:0] boot_addr_i,\n    // Hart id in a multicore environment (reflected in a CSR) - SUBSYSTEM\n    input logic [riscv::XLEN-1:0] hart_id_i,\n    // we are taking an exception\n    // We've got an exception from the commit stage, take it - COMMIT_STAGE\n    input exception_t ex_i,\n    // Operation to perform on the CSR file - COMMIT_STAGE\n    input fu_op csr_op_i,\n    // Address of the register to read/write - EX_STAGE\n    input logic [11:0] csr_addr_i,\n    // Write data in - COMMIT_STAGE\n    input logic [riscv::XLEN-1:0] csr_wdata_i,\n    // Read data out - COMMIT_STAGE\n    output logic [riscv::XLEN-1:0] csr_rdata_o,\n    // Mark the FP sate as dirty - COMMIT_STAGE\n    input logic dirty_fp_state_i,\n    // Write fflags register e.g.: we are retiring a floating point instruction - COMMIT_STAGE\n    input logic csr_write_fflags_i,\n    // Mark the V state as dirty - ACC_DISPATCHER\n    input logic dirty_v_state_i,\n    // PC of instruction accessing the CSR - COMMIT_STAGE\n    input logic [riscv::VLEN-1:0] pc_i,\n    // attempts to access a CSR without appropriate privilege - COMMIT_STAGE\n    output exception_t csr_exception_o,\n    // Output the exception PC to PC Gen, the correct CSR (mepc, sepc) is set accordingly - FRONTEND\n    output logic [riscv::VLEN-1:0] epc_o,\n    // Return from exception, set the PC of epc_o - FRONTEND\n    output logic eret_o,\n    // Output base of exception vector, correct CSR is output (mtvec, stvec) - FRONTEND\n    output logic [riscv::VLEN-1:0] trap_vector_base_o,\n    // Current privilege level the CPU is in - EX_STAGE\n    output riscv::priv_lvl_t priv_lvl_o,\n    // Imprecise FP exception from the accelerator (fcsr.fflags format) - ACC_DISPATCHER\n    input logic [4:0] acc_fflags_ex_i,\n    // An FP exception from the accelerator occurred - ACC_DISPATCHER\n    input logic acc_fflags_ex_valid_i,\n    // Floating point extension status - ID_STAGE\n    output riscv::xs_t fs_o,\n    // Floating-Point Accured Exceptions - COMMIT_STAGE\n    output logic [4:0] fflags_o,\n    // Floating-Point Dynamic Rounding Mode - EX_STAGE\n    output logic [2:0] frm_o,\n    // Floating-Point Precision Control - EX_STAGE\n    output logic [6:0] fprec_o,\n    // Vector extension status - ID_STAGE\n    output riscv::xs_t vs_o,\n    // interrupt management to id stage - ID_STAGE\n    output irq_ctrl_t irq_ctrl_o,\n    // Enable virtual address translation - EX_STAGE\n    output logic en_translation_o,\n    // Enable virtual address translation for load and stores - EX_STAGE\n    output logic en_ld_st_translation_o,\n    // Privilege level at which load and stores should happen - EX_STAGE\n    output riscv::priv_lvl_t ld_st_priv_lvl_o,\n    // Supervisor User Memory - EX_STAGE\n    output logic sum_o,\n    // Make Executable Readable - EX_STAGE\n    output logic mxr_o,\n    // TO_BE_COMPLETED - EX_STAGE\n    output logic [riscv::PPNW-1:0] satp_ppn_o,\n    // TO_BE_COMPLETED - EX_STAGE\n    output logic [AsidWidth-1:0] asid_o,\n    // external interrupt in - SUBSYSTEM\n    input logic [1:0] irq_i,\n    // inter processor interrupt -> connected to machine mode sw - SUBSYSTEM\n    input logic ipi_i,\n    // debug request in - ID_STAGE\n    input logic debug_req_i,\n    // TO_BE_COMPLETED - FRONTEND\n    output logic set_debug_pc_o,\n    // trap virtual memory - ID_STAGE\n    output logic tvm_o,\n    // timeout wait - ID_STAGE\n    output logic tw_o,\n    // trap sret - ID_STAGE\n    output logic tsr_o,\n    // we are in debug mode -> that will change some decoding - EX_STAGE\n    output logic debug_mode_o,\n    // we are in single-step mode - COMMIT_STAGE\n    output logic single_step_o,\n    // L1 ICache Enable - CACHE\n    output logic icache_en_o,\n    // L1 DCache Enable - CACHE\n    output logic dcache_en_o,\n    // Accelerator memory consistent mode - ACC_DISPATCHER\n    output logic acc_cons_en_o,\n    // Performance Counter\n    // read/write address to performance counter module - PERF_COUNTERS\n    output logic [11:0] perf_addr_o,\n    // write data to performance counter module - PERF_COUNTERS\n    output logic [riscv::XLEN-1:0] perf_data_o,\n    // read data from performance counter module - PERF_COUNTERS\n    input logic [riscv::XLEN-1:0] perf_data_i,\n    // TO_BE_COMPLETED - PERF_COUNTERS\n    output logic perf_we_o,\n    // PMP configuration containing pmpcfg for max 16 PMPs - ACC_DISPATCHER\n    output riscv::pmpcfg_t [15:0] pmpcfg_o,\n    // PMP addresses - ACC_DISPATCHER\n    output logic [15:0][riscv::PLEN-3:0] pmpaddr_o,\n    // TO_BE_COMPLETED - PERF_COUNTERS\n    output logic [31:0] mcountinhibit_o,\n    // RVFI\n    output rvfi_probes_csr_t rvfi_csr_o\n);\n\n  // internal signal to keep track of access exceptions\n  logic read_access_exception, update_access_exception, privilege_violation;\n  logic csr_we, csr_read;\n  riscv::xlen_t csr_wdata, csr_rdata;\n  riscv::priv_lvl_t trap_to_priv_lvl;\n  // register for enabling load store address translation, this is critical, hence the register\n  logic en_ld_st_translation_d, en_ld_st_translation_q;\n  logic mprv;\n  logic mret;  // return from M-mode exception\n  logic sret;  // return from S-mode exception\n  logic dret;  // return from debug mode\n  // CSR write causes us to mark the FPU state as dirty\n  logic dirty_fp_state_csr;\n  riscv::mstatus_rv_t mstatus_q, mstatus_d;\n  riscv::xlen_t mstatus_extended;\n  riscv::satp_t satp_q, satp_d;\n  riscv::dcsr_t dcsr_q, dcsr_d;\n  riscv::csr_t csr_addr;\n  // privilege level register\n  riscv::priv_lvl_t priv_lvl_d, priv_lvl_q;\n  // we are in debug\n  logic debug_mode_q, debug_mode_d;\n  logic mtvec_rst_load_q;  // used to determine whether we came out of reset\n\n  riscv::xlen_t dpc_q, dpc_d;\n  riscv::xlen_t dscratch0_q, dscratch0_d;\n  riscv::xlen_t dscratch1_q, dscratch1_d;\n  riscv::xlen_t mtvec_q, mtvec_d;\n  riscv::xlen_t medeleg_q, medeleg_d;\n  riscv::xlen_t mideleg_q, mideleg_d;\n  riscv::xlen_t mip_q, mip_d;\n  riscv::xlen_t mie_q, mie_d;\n  riscv::xlen_t mcounteren_q, mcounteren_d;\n  riscv::xlen_t mscratch_q, mscratch_d;\n  riscv::xlen_t mepc_q, mepc_d;\n  riscv::xlen_t mcause_q, mcause_d;\n  riscv::xlen_t mtval_q, mtval_d;\n  logic fiom_d, fiom_q;\n\n  riscv::xlen_t stvec_q, stvec_d;\n  riscv::xlen_t scounteren_q, scounteren_d;\n  riscv::xlen_t sscratch_q, sscratch_d;\n  riscv::xlen_t sepc_q, sepc_d;\n  riscv::xlen_t scause_q, scause_d;\n  riscv::xlen_t stval_q, stval_d;\n  riscv::xlen_t dcache_q, dcache_d;\n  riscv::xlen_t icache_q, icache_d;\n  riscv::xlen_t acc_cons_q, acc_cons_d;\n\n  logic wfi_d, wfi_q;\n\n  logic [63:0] cycle_q, cycle_d;\n  logic [63:0] instret_q, instret_d;\n\n  riscv::pmpcfg_t [15:0] pmpcfg_q, pmpcfg_d, pmpcfg_next;\n  logic [15:0][riscv::PLEN-3:0] pmpaddr_q, pmpaddr_d, pmpaddr_next;\n  logic [MHPMCounterNum+3-1:0] mcountinhibit_d, mcountinhibit_q;\n  logic [3:0] index;\n\n  localparam riscv::xlen_t IsaCode = (riscv::XLEN'(CVA6Cfg.RVA) <<  0)                // A - Atomic Instructions extension\n  | (riscv::XLEN'(CVA6Cfg.RVB) << 1)  // C - Bitmanip extension\n  | (riscv::XLEN'(CVA6Cfg.RVC) << 2)  // C - Compressed extension\n  | (riscv::XLEN'(CVA6Cfg.RVD) << 3)  // D - Double precision floating-point extension\n  | (riscv::XLEN'(CVA6Cfg.RVF) << 5)  // F - Single precision floating-point extension\n  | (riscv::XLEN'(1) << 8)  // I - RV32I/64I/128I base ISA\n  | (riscv::XLEN'(1) << 12)  // M - Integer Multiply/Divide extension\n  | (riscv::XLEN'(0) << 13)  // N - User level interrupts supported\n  | (riscv::XLEN'(CVA6Cfg.RVS) << 18)  // S - Supervisor mode implemented\n  | (riscv::XLEN'(CVA6Cfg.RVU) << 20)  // U - User mode implemented\n  | (riscv::XLEN'(CVA6Cfg.RVV) << 21)  // V - Vector extension\n  | (riscv::XLEN'(CVA6Cfg.NSX) << 23)  // X - Non-standard extensions present\n  | ((riscv::XLEN == 64 ? 2 : 1) << riscv::XLEN - 2);  // MXL\n\n  assign pmpcfg_o  = pmpcfg_q[15:0];\n  assign pmpaddr_o = pmpaddr_q;\n\n  riscv::fcsr_t fcsr_q, fcsr_d;\n  // ----------------\n  // Assignments\n  // ----------------\n  assign csr_addr = riscv::csr_t'(csr_addr_i);\n  assign fs_o = mstatus_q.fs;\n  assign vs_o = mstatus_q.vs;\n  // ----------------\n  // CSR Read logic\n  // ----------------\n  assign mstatus_extended = riscv::IS_XLEN64 ? mstatus_q[riscv::XLEN-1:0] :\n                              {mstatus_q.sd, mstatus_q.wpri3[7:0], mstatus_q[22:0]};\n\n\n  always_comb begin : csr_read_process\n    // a read access exception can only occur if we attempt to read a CSR which does not exist\n    read_access_exception = 1'b0;\n    csr_rdata = '0;\n    perf_addr_o = csr_addr.address[11:0];\n    index = '0;\n\n    if (csr_read) begin\n      unique case (csr_addr.address)\n        riscv::CSR_FFLAGS: begin\n          if (CVA6Cfg.FpPresent) begin\n            csr_rdata = {{riscv::XLEN - 5{1'b0}}, fcsr_q.fflags};\n          end else begin\n            read_access_exception = 1'b1;\n          end\n        end\n        riscv::CSR_FRM: begin\n          if (CVA6Cfg.FpPresent) begin\n            csr_rdata = {{riscv::XLEN - 3{1'b0}}, fcsr_q.frm};\n          end else begin\n            read_access_exception = 1'b1;\n          end\n        end\n        riscv::CSR_FCSR: begin\n          if (CVA6Cfg.FpPresent) begin\n            csr_rdata = {{riscv::XLEN - 8{1'b0}}, fcsr_q.frm, fcsr_q.fflags};\n          end else begin\n            read_access_exception = 1'b1;\n          end\n        end\n        // non-standard extension\n        riscv::CSR_FTRAN: begin\n          if (CVA6Cfg.FpPresent) begin\n            csr_rdata = {{riscv::XLEN - 7{1'b0}}, fcsr_q.fprec};\n          end else begin\n            read_access_exception = 1'b1;\n          end\n        end\n        // debug registers\n        riscv::CSR_DCSR:\n        if (CVA6Cfg.DebugEn) csr_rdata = {{riscv::XLEN - 32{1'b0}}, dcsr_q};\n        else read_access_exception = 1'b1;\n        riscv::CSR_DPC:\n        if (CVA6Cfg.DebugEn) csr_rdata = dpc_q;\n        else read_access_exception = 1'b1;\n        riscv::CSR_DSCRATCH0:\n        if (CVA6Cfg.DebugEn) csr_rdata = dscratch0_q;\n        else read_access_exception = 1'b1;\n        riscv::CSR_DSCRATCH1:\n        if (CVA6Cfg.DebugEn) csr_rdata = dscratch1_q;\n        else read_access_exception = 1'b1;\n        // trigger module registers\n        riscv::CSR_TSELECT: read_access_exception = 1'b1;  // not implemented\n        riscv::CSR_TDATA1: read_access_exception = 1'b1;  // not implemented\n        riscv::CSR_TDATA2: read_access_exception = 1'b1;  // not implemented\n        riscv::CSR_TDATA3: read_access_exception = 1'b1;  // not implemented\n        // supervisor registers\n        riscv::CSR_SSTATUS: begin\n          if (CVA6Cfg.RVS)\n            csr_rdata = mstatus_extended & ariane_pkg::SMODE_STATUS_READ_MASK[riscv::XLEN-1:0];\n          else read_access_exception = 1'b1;\n        end\n        riscv::CSR_SIE:\n        if (CVA6Cfg.RVS) csr_rdata = mie_q & mideleg_q;\n        else read_access_exception = 1'b1;\n        riscv::CSR_SIP:\n        if (CVA6Cfg.RVS) csr_rdata = mip_q & mideleg_q;\n        else read_access_exception = 1'b1;\n        riscv::CSR_STVEC:\n        if (CVA6Cfg.RVS) csr_rdata = stvec_q;\n        else read_access_exception = 1'b1;\n        riscv::CSR_SCOUNTEREN:\n        if (CVA6Cfg.RVS) csr_rdata = scounteren_q;\n        else read_access_exception = 1'b1;\n        riscv::CSR_SSCRATCH:\n        if (CVA6Cfg.RVS) csr_rdata = sscratch_q;\n        else read_access_exception = 1'b1;\n        riscv::CSR_SEPC:\n        if (CVA6Cfg.RVS) csr_rdata = sepc_q;\n        else read_access_exception = 1'b1;\n        riscv::CSR_SCAUSE:\n        if (CVA6Cfg.RVS) csr_rdata = scause_q;\n        else read_access_exception = 1'b1;\n        riscv::CSR_STVAL:\n        if (CVA6Cfg.RVS) csr_rdata = stval_q;\n        else read_access_exception = 1'b1;\n        riscv::CSR_SATP: begin\n          if (CVA6Cfg.RVS) begin\n            // intercept reads to SATP if in S-Mode and TVM is enabled\n            if (priv_lvl_o == riscv::PRIV_LVL_S && mstatus_q.tvm) begin\n              read_access_exception = 1'b1;\n            end else begin\n              csr_rdata = satp_q;\n            end\n          end else begin\n            read_access_exception = 1'b1;\n          end\n        end\n        // machine mode registers\n        riscv::CSR_MSTATUS: csr_rdata = mstatus_extended;\n        riscv::CSR_MSTATUSH:\n        if (riscv::XLEN == 32) csr_rdata = '0;\n        else read_access_exception = 1'b1;\n        riscv::CSR_MISA: csr_rdata = IsaCode;\n        riscv::CSR_MEDELEG:\n        if (CVA6Cfg.RVS) csr_rdata = medeleg_q;\n        else read_access_exception = 1'b1;\n        riscv::CSR_MIDELEG:\n        if (CVA6Cfg.RVS) csr_rdata = mideleg_q;\n        else read_access_exception = 1'b1;\n        riscv::CSR_MIE: csr_rdata = mie_q;\n        riscv::CSR_MTVEC: csr_rdata = mtvec_q;\n        riscv::CSR_MCOUNTEREN: csr_rdata = mcounteren_q;\n        riscv::CSR_MSCRATCH: csr_rdata = mscratch_q;\n        riscv::CSR_MEPC: csr_rdata = mepc_q;\n        riscv::CSR_MCAUSE: csr_rdata = mcause_q;\n        riscv::CSR_MTVAL: csr_rdata = mtval_q;\n        riscv::CSR_MIP: csr_rdata = mip_q;\n        riscv::CSR_MENVCFG: begin\n          if (CVA6Cfg.RVU) csr_rdata = '0 | fiom_q;\n          else read_access_exception = 1'b1;\n        end\n        riscv::CSR_MENVCFGH: begin\n          if (CVA6Cfg.RVU && riscv::XLEN == 32) csr_rdata = '0;\n          else read_access_exception = 1'b1;\n        end\n        riscv::CSR_MVENDORID: csr_rdata = OPENHWGROUP_MVENDORID;\n        riscv::CSR_MARCHID: csr_rdata = ARIANE_MARCHID;\n        riscv::CSR_MIMPID: csr_rdata = '0;  // not implemented\n        riscv::CSR_MHARTID: csr_rdata = hart_id_i;\n        riscv::CSR_MCONFIGPTR: csr_rdata = '0;  // not implemented\n        riscv::CSR_MCOUNTINHIBIT:\n        if (PERF_COUNTER_EN)\n          csr_rdata = {{(riscv::XLEN - (MHPMCounterNum + 3)) {1'b0}}, mcountinhibit_q};\n        else read_access_exception = 1'b1;\n        // Counters and Timers\n        riscv::CSR_MCYCLE: csr_rdata = cycle_q[riscv::XLEN-1:0];\n        riscv::CSR_MCYCLEH:\n        if (riscv::XLEN == 32) csr_rdata = cycle_q[63:32];\n        else read_access_exception = 1'b1;\n        riscv::CSR_MINSTRET: csr_rdata = instret_q[riscv::XLEN-1:0];\n        riscv::CSR_MINSTRETH:\n        if (riscv::XLEN == 32) csr_rdata = instret_q[63:32];\n        else read_access_exception = 1'b1;\n        riscv::CSR_CYCLE: csr_rdata = cycle_q[riscv::XLEN-1:0];\n        riscv::CSR_CYCLEH:\n        if (riscv::XLEN == 32) csr_rdata = cycle_q[63:32];\n        else read_access_exception = 1'b1;\n        riscv::CSR_INSTRET: csr_rdata = instret_q[riscv::XLEN-1:0];\n        riscv::CSR_INSTRETH:\n        if (riscv::XLEN == 32) csr_rdata = instret_q[63:32];\n        else read_access_exception = 1'b1;\n        //Event Selector\n        riscv::CSR_MHPM_EVENT_3,\n                riscv::CSR_MHPM_EVENT_4,\n                riscv::CSR_MHPM_EVENT_5,\n                riscv::CSR_MHPM_EVENT_6,\n                riscv::CSR_MHPM_EVENT_7,\n                riscv::CSR_MHPM_EVENT_8,\n                riscv::CSR_MHPM_EVENT_9,\n                riscv::CSR_MHPM_EVENT_10,\n                riscv::CSR_MHPM_EVENT_11,\n                riscv::CSR_MHPM_EVENT_12,\n                riscv::CSR_MHPM_EVENT_13,\n                riscv::CSR_MHPM_EVENT_14,\n                riscv::CSR_MHPM_EVENT_15,\n                riscv::CSR_MHPM_EVENT_16,\n                riscv::CSR_MHPM_EVENT_17,\n                riscv::CSR_MHPM_EVENT_18,\n                riscv::CSR_MHPM_EVENT_19,\n                riscv::CSR_MHPM_EVENT_20,\n                riscv::CSR_MHPM_EVENT_21,\n                riscv::CSR_MHPM_EVENT_22,\n                riscv::CSR_MHPM_EVENT_23,\n                riscv::CSR_MHPM_EVENT_24,\n                riscv::CSR_MHPM_EVENT_25,\n                riscv::CSR_MHPM_EVENT_26,\n                riscv::CSR_MHPM_EVENT_27,\n                riscv::CSR_MHPM_EVENT_28,\n                riscv::CSR_MHPM_EVENT_29,\n                riscv::CSR_MHPM_EVENT_30,\n                riscv::CSR_MHPM_EVENT_31 :\n        csr_rdata = perf_data_i;\n\n        riscv::CSR_MHPM_COUNTER_3,\n                riscv::CSR_MHPM_COUNTER_4,\n                riscv::CSR_MHPM_COUNTER_5,\n                riscv::CSR_MHPM_COUNTER_6,\n                riscv::CSR_MHPM_COUNTER_7,\n                riscv::CSR_MHPM_COUNTER_8,\n                riscv::CSR_MHPM_COUNTER_9,\n                riscv::CSR_MHPM_COUNTER_10,\n                riscv::CSR_MHPM_COUNTER_11,\n                riscv::CSR_MHPM_COUNTER_12,\n                riscv::CSR_MHPM_COUNTER_13,\n                riscv::CSR_MHPM_COUNTER_14,\n                riscv::CSR_MHPM_COUNTER_15,\n                riscv::CSR_MHPM_COUNTER_16,\n                riscv::CSR_MHPM_COUNTER_17,\n                riscv::CSR_MHPM_COUNTER_18,\n                riscv::CSR_MHPM_COUNTER_19,\n                riscv::CSR_MHPM_COUNTER_20,\n                riscv::CSR_MHPM_COUNTER_21,\n                riscv::CSR_MHPM_COUNTER_22,\n                riscv::CSR_MHPM_COUNTER_23,\n                riscv::CSR_MHPM_COUNTER_24,\n                riscv::CSR_MHPM_COUNTER_25,\n                riscv::CSR_MHPM_COUNTER_26,\n                riscv::CSR_MHPM_COUNTER_27,\n                riscv::CSR_MHPM_COUNTER_28,\n                riscv::CSR_MHPM_COUNTER_29,\n                riscv::CSR_MHPM_COUNTER_30,\n                riscv::CSR_MHPM_COUNTER_31 :\n        csr_rdata = perf_data_i;\n\n        riscv::CSR_MHPM_COUNTER_3H,\n                riscv::CSR_MHPM_COUNTER_4H,\n                riscv::CSR_MHPM_COUNTER_5H,\n                riscv::CSR_MHPM_COUNTER_6H,\n                riscv::CSR_MHPM_COUNTER_7H,\n                riscv::CSR_MHPM_COUNTER_8H,\n                riscv::CSR_MHPM_COUNTER_9H,\n                riscv::CSR_MHPM_COUNTER_10H,\n                riscv::CSR_MHPM_COUNTER_11H,\n                riscv::CSR_MHPM_COUNTER_12H,\n                riscv::CSR_MHPM_COUNTER_13H,\n                riscv::CSR_MHPM_COUNTER_14H,\n                riscv::CSR_MHPM_COUNTER_15H,\n                riscv::CSR_MHPM_COUNTER_16H,\n                riscv::CSR_MHPM_COUNTER_17H,\n                riscv::CSR_MHPM_COUNTER_18H,\n                riscv::CSR_MHPM_COUNTER_19H,\n                riscv::CSR_MHPM_COUNTER_20H,\n                riscv::CSR_MHPM_COUNTER_21H,\n                riscv::CSR_MHPM_COUNTER_22H,\n                riscv::CSR_MHPM_COUNTER_23H,\n                riscv::CSR_MHPM_COUNTER_24H,\n                riscv::CSR_MHPM_COUNTER_25H,\n                riscv::CSR_MHPM_COUNTER_26H,\n                riscv::CSR_MHPM_COUNTER_27H,\n                riscv::CSR_MHPM_COUNTER_28H,\n                riscv::CSR_MHPM_COUNTER_29H,\n           "}
{"text": "     riscv::CSR_MHPM_COUNTER_30H,\n                riscv::CSR_MHPM_COUNTER_31H :\n        if (riscv::XLEN == 32) csr_rdata = perf_data_i;\n        else read_access_exception = 1'b1;\n\n        // Performance counters (User Mode - R/O Shadows)\n        riscv::CSR_HPM_COUNTER_3,\n                riscv::CSR_HPM_COUNTER_4,\n                riscv::CSR_HPM_COUNTER_5,\n                riscv::CSR_HPM_COUNTER_6,\n                riscv::CSR_HPM_COUNTER_7,\n                riscv::CSR_HPM_COUNTER_8,\n                riscv::CSR_HPM_COUNTER_9,\n                riscv::CSR_HPM_COUNTER_10,\n                riscv::CSR_HPM_COUNTER_11,\n                riscv::CSR_HPM_COUNTER_12,\n                riscv::CSR_HPM_COUNTER_13,\n                riscv::CSR_HPM_COUNTER_14,\n                riscv::CSR_HPM_COUNTER_15,\n                riscv::CSR_HPM_COUNTER_16,\n                riscv::CSR_HPM_COUNTER_17,\n                riscv::CSR_HPM_COUNTER_18,\n                riscv::CSR_HPM_COUNTER_19,\n                riscv::CSR_HPM_COUNTER_20,\n                riscv::CSR_HPM_COUNTER_21,\n                riscv::CSR_HPM_COUNTER_22,\n                riscv::CSR_HPM_COUNTER_23,\n                riscv::CSR_HPM_COUNTER_24,\n                riscv::CSR_HPM_COUNTER_25,\n                riscv::CSR_HPM_COUNTER_26,\n                riscv::CSR_HPM_COUNTER_27,\n                riscv::CSR_HPM_COUNTER_28,\n                riscv::CSR_HPM_COUNTER_29,\n                riscv::CSR_HPM_COUNTER_30,\n                riscv::CSR_HPM_COUNTER_31 :\n        csr_rdata = perf_data_i;\n\n        riscv::CSR_HPM_COUNTER_3H,\n                riscv::CSR_HPM_COUNTER_4H,\n                riscv::CSR_HPM_COUNTER_5H,\n                riscv::CSR_HPM_COUNTER_6H,\n                riscv::CSR_HPM_COUNTER_7H,\n                riscv::CSR_HPM_COUNTER_8H,\n                riscv::CSR_HPM_COUNTER_9H,\n                riscv::CSR_HPM_COUNTER_10H,\n                riscv::CSR_HPM_COUNTER_11H,\n                riscv::CSR_HPM_COUNTER_12H,\n                riscv::CSR_HPM_COUNTER_13H,\n                riscv::CSR_HPM_COUNTER_14H,\n                riscv::CSR_HPM_COUNTER_15H,\n                riscv::CSR_HPM_COUNTER_16H,\n                riscv::CSR_HPM_COUNTER_17H,\n                riscv::CSR_HPM_COUNTER_18H,\n                riscv::CSR_HPM_COUNTER_19H,\n                riscv::CSR_HPM_COUNTER_20H,\n                riscv::CSR_HPM_COUNTER_21H,\n                riscv::CSR_HPM_COUNTER_22H,\n                riscv::CSR_HPM_COUNTER_23H,\n                riscv::CSR_HPM_COUNTER_24H,\n                riscv::CSR_HPM_COUNTER_25H,\n                riscv::CSR_HPM_COUNTER_26H,\n                riscv::CSR_HPM_COUNTER_27H,\n                riscv::CSR_HPM_COUNTER_28H,\n                riscv::CSR_HPM_COUNTER_29H,\n                riscv::CSR_HPM_COUNTER_30H,\n                riscv::CSR_HPM_COUNTER_31H :\n        if (riscv::XLEN == 32) csr_rdata = perf_data_i;\n        else read_access_exception = 1'b1;\n\n        // custom (non RISC-V) cache control\n        riscv::CSR_DCACHE: csr_rdata = dcache_q;\n        riscv::CSR_ICACHE: csr_rdata = icache_q;\n        // custom (non RISC-V) accelerator memory consistency mode\n        riscv::CSR_ACC_CONS: begin\n          if (CVA6Cfg.EnableAccelerator) begin\n            csr_rdata = acc_cons_q;\n          end else begin\n            read_access_exception = 1'b1;\n          end\n        end\n        // PMPs\n        riscv::CSR_PMPCFG0: csr_rdata = pmpcfg_q[riscv::XLEN/8-1:0];\n        riscv::CSR_PMPCFG1:\n        if (riscv::XLEN == 32) csr_rdata = pmpcfg_q[7:4];\n        else read_access_exception = 1'b1;\n        riscv::CSR_PMPCFG2: csr_rdata = pmpcfg_q[8+:riscv::XLEN/8];\n        riscv::CSR_PMPCFG3:\n        if (riscv::XLEN == 32) csr_rdata = pmpcfg_q[15:12];\n        else read_access_exception = 1'b1;\n        // PMPADDR\n        riscv::CSR_PMPADDR0,\n                riscv::CSR_PMPADDR1,\n                riscv::CSR_PMPADDR2,\n                riscv::CSR_PMPADDR3,\n                riscv::CSR_PMPADDR4,\n                riscv::CSR_PMPADDR5,\n                riscv::CSR_PMPADDR6,\n                riscv::CSR_PMPADDR7,\n                riscv::CSR_PMPADDR8,\n                riscv::CSR_PMPADDR9,\n                riscv::CSR_PMPADDR10,\n                riscv::CSR_PMPADDR11,\n                riscv::CSR_PMPADDR12,\n                riscv::CSR_PMPADDR13,\n                riscv::CSR_PMPADDR14,\n                riscv::CSR_PMPADDR15: begin\n          // index is specified by the last byte in the address\n          index = csr_addr.csr_decode.address[3:0];\n          // Important: we only support granularity 8 bytes (G=1)\n          // -> last bit of pmpaddr must be set 0/1 based on the mode:\n          // NA4, NAPOT: 1\n          // TOR, OFF:   0\n          if (pmpcfg_q[index].addr_mode[1] == 1'b1) csr_rdata = pmpaddr_q[index][riscv::PLEN-3:0];\n          else csr_rdata = {pmpaddr_q[index][riscv::PLEN-3:1], 1'b0};\n        end\n        default: read_access_exception = 1'b1;\n      endcase\n    end\n  end\n  // ---------------------------\n  // CSR Write and update logic\n  // ---------------------------\n  riscv::xlen_t mask;\n  always_comb begin : csr_update\n    automatic riscv::satp_t satp;\n    automatic logic [63:0] instret;\n\n\n    satp            = satp_q;\n    instret         = instret_q;\n\n    mcountinhibit_d = mcountinhibit_q;\n\n    // --------------------\n    // Counters\n    // --------------------\n    cycle_d         = cycle_q;\n    instret_d       = instret_q;\n    if (!debug_mode_q) begin\n      // increase instruction retired counter\n      for (int i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin\n        if (commit_ack_i[i] && !ex_i.valid && (!PERF_COUNTER_EN || (PERF_COUNTER_EN && !mcountinhibit_q[2])))\n          instret++;\n      end\n      instret_d = instret;\n      // increment the cycle count\n      if (!PERF_COUNTER_EN || (PERF_COUNTER_EN && !mcountinhibit_q[0])) cycle_d = cycle_q + 1'b1;\n      else cycle_d = cycle_q;\n    end\n\n    eret_o                  = 1'b0;\n    flush_o                 = 1'b0;\n    update_access_exception = 1'b0;\n\n    set_debug_pc_o          = 1'b0;\n\n    perf_we_o               = 1'b0;\n    perf_data_o             = 'b0;\n\n    fcsr_d                  = fcsr_q;\n\n    priv_lvl_d              = priv_lvl_q;\n    debug_mode_d            = debug_mode_q;\n    dcsr_d                  = dcsr_q;\n    dpc_d                   = dpc_q;\n    dscratch0_d             = dscratch0_q;\n    dscratch1_d             = dscratch1_q;\n    mstatus_d               = mstatus_q;\n\n    // check whether we come out of reset\n    // this is a workaround. some tools have issues\n    // having boot_addr_i in the asynchronous\n    // reset assignment to mtvec_d, even though\n    // boot_addr_i will be assigned a constant\n    // on the top-level.\n    if (mtvec_rst_load_q) begin\n      mtvec_d = {{riscv::XLEN - riscv::VLEN{1'b0}}, boot_addr_i} + 'h40;\n    end else begin\n      mtvec_d = mtvec_q;\n    end\n\n    medeleg_d              = medeleg_q;\n    mideleg_d              = mideleg_q;\n    mip_d                  = mip_q;\n    mie_d                  = mie_q;\n    mepc_d                 = mepc_q;\n    mcause_d               = mcause_q;\n    mcounteren_d           = mcounteren_q;\n    mscratch_d             = mscratch_q;\n    mtval_d                = mtval_q;\n    fiom_d                 = fiom_q;\n    dcache_d               = dcache_q;\n    icache_d               = icache_q;\n    acc_cons_d             = acc_cons_q;\n\n    sepc_d                 = sepc_q;\n    scause_d               = scause_q;\n    stvec_d                = stvec_q;\n    scounteren_d           = scounteren_q;\n    sscratch_d             = sscratch_q;\n    stval_d                = stval_q;\n    satp_d                 = satp_q;\n\n    en_ld_st_translation_d = en_ld_st_translation_q;\n    dirty_fp_state_csr     = 1'b0;\n\n    pmpcfg_d               = pmpcfg_q;\n    pmpaddr_d              = pmpaddr_q;\n\n    // check for correct access rights and that we are writing\n    if (csr_we) begin\n      unique case (csr_addr.address)\n        // Floating-Point\n        riscv::CSR_FFLAGS: begin\n          if (CVA6Cfg.FpPresent) begin\n            dirty_fp_state_csr = 1'b1;\n            fcsr_d.fflags = csr_wdata[4:0];\n            // this instruction has side-effects\n            flush_o = 1'b1;\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n        riscv::CSR_FRM: begin\n          if (CVA6Cfg.FpPresent) begin\n            dirty_fp_state_csr = 1'b1;\n            fcsr_d.frm    = csr_wdata[2:0];\n            // this instruction has side-effects\n            flush_o = 1'b1;\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n        riscv::CSR_FCSR: begin\n          if (CVA6Cfg.FpPresent) begin\n            dirty_fp_state_csr = 1'b1;\n            fcsr_d[7:0] = csr_wdata[7:0];  // ignore writes to reserved space\n            // this instruction has side-effects\n            flush_o = 1'b1;\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n        riscv::CSR_FTRAN: begin\n          if (CVA6Cfg.FpPresent) begin\n            dirty_fp_state_csr = 1'b1;\n            fcsr_d.fprec = csr_wdata[6:0];  // ignore writes to reserved space\n            // this instruction has side-effects\n            flush_o = 1'b1;\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n        // debug CSR\n        riscv::CSR_DCSR: begin\n          if (CVA6Cfg.DebugEn) begin\n            dcsr_d           = csr_wdata[31:0];\n            // debug is implemented\n            dcsr_d.xdebugver = 4'h4;\n            // currently not supported\n            dcsr_d.nmip      = 1'b0;\n            dcsr_d.stopcount = 1'b0;\n            dcsr_d.stoptime  = 1'b0;\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n        riscv::CSR_DPC:\n        if (CVA6Cfg.DebugEn) dpc_d = csr_wdata;\n        else update_access_exception = 1'b1;\n        riscv::CSR_DSCRATCH0:\n        if (CVA6Cfg.DebugEn) dscratch0_d = csr_wdata;\n        else update_access_exception = 1'b1;\n        riscv::CSR_DSCRATCH1:\n        if (CVA6Cfg.DebugEn) dscratch1_d = csr_wdata;\n        else update_access_exception = 1'b1;\n        // trigger module CSRs\n        riscv::CSR_TSELECT: update_access_exception = 1'b1;  // not implemented\n        riscv::CSR_TDATA1: update_access_exception = 1'b1;  // not implemented\n        riscv::CSR_TDATA2: update_access_exception = 1'b1;  // not implemented\n        riscv::CSR_TDATA3: update_access_exception = 1'b1;  // not implemented\n        // sstatus is a subset of mstatus - mask it accordingly\n        riscv::CSR_SSTATUS: begin\n          if (CVA6Cfg.RVS) begin\n            mask = ariane_pkg::SMODE_STATUS_WRITE_MASK[riscv::XLEN-1:0];\n            mstatus_d = (mstatus_q & ~{{64-riscv::XLEN{1'b0}}, mask}) | {{64-riscv::XLEN{1'b0}}, (csr_wdata & mask)};\n            // hardwire to zero if floating point extension is not present\n            if (!CVA6Cfg.FpPresent) begin\n              mstatus_d.fs = riscv::Off;\n            end\n            // hardwire to zero if vector extension is not present\n            if (!CVA6Cfg.RVV) begin\n              mstatus_d.vs = riscv::Off;\n            end\n            // this instruction has side-effects\n            flush_o = 1'b1;\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n        // even machine mode interrupts can be visible and set-able to supervisor\n        // if the corresponding bit in mideleg is set\n        riscv::CSR_SIE: begin\n          if (CVA6Cfg.RVS) begin\n            // the mideleg makes sure only delegate-able register (and therefore also only implemented registers) are written\n            mie_d = (mie_q & ~mideleg_q) | (csr_wdata & mideleg_q);\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n\n        riscv::CSR_SIP: begin\n          if (CVA6Cfg.RVS) begin\n            // only the supervisor software interrupt is write-able, iff delegated\n            mask  = riscv::MIP_SSIP & mideleg_q;\n            mip_d = (mip_q & ~mask) | (csr_wdata & mask);\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n\n        riscv::CSR_STVEC:\n        if (CVA6Cfg.RVS) stvec_d = {csr_wdata[riscv::XLEN-1:2], 1'b0, csr_wdata[0]};\n        else update_access_exception = 1'b1;\n        riscv::CSR_SCOUNTEREN:\n        if (CVA6Cfg.RVS) scounteren_d = {{riscv::XLEN - 32{1'b0}}, csr_wdata[31:0]};\n        else update_access_exception = 1'b1;\n        riscv::CSR_SSCRATCH:\n        if (CVA6Cfg.RVS) sscratch_d = csr_wdata;\n        else update_access_exception = 1'b1;\n        riscv::CSR_SEPC:\n        if (CVA6Cfg.RVS) sepc_d = {csr_wdata[riscv::XLEN-1:1], 1'b0};\n        else update_access_exception = 1'b1;\n        riscv::CSR_SCAUSE:\n        if (CVA6Cfg.RVS) scause_d = csr_wdata;\n        else update_access_exception = 1'b1;\n        riscv::CSR_STVAL:\n        if (CVA6Cfg.RVS && CVA6Cfg.TvalEn) stval_d = csr_wdata;\n        else update_access_exception = 1'b1;\n        // supervisor address translation and protection\n        riscv::CSR_SATP: begin\n          if (CVA6Cfg.RVS) begin\n            // intercept SATP writes if in S-Mode and TVM is enabled\n            if (priv_lvl_o == riscv::PRIV_LVL_S && mstatus_q.tvm) update_access_exception = 1'b1;\n            else begin\n              satp      = riscv::satp_t'(csr_wdata);\n              // only make ASID_LEN - 1 bit stick, that way software can figure out how many ASID bits are supported\n              satp.asid = satp.asid & {{(riscv::ASIDW - AsidWidth) {1'b0}}, {AsidWidth{1'b1}}};\n              // only update if we actually support this mode\n              if (riscv::vm_mode_t'(satp.mode) == riscv::ModeOff ||\n                                riscv::vm_mode_t'(satp.mode) == riscv::MODE_SV)\n                satp_d = satp;\n            end\n            // changing the mode can have side-effects on address translation (e.g.: other instructions), re-fetch\n            // the next instruction by executing a flush\n            flush_o = 1'b1;\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n\n        riscv::CSR_MSTATUS: begin\n          mstatus_d    = {{64 - riscv::XLEN{1'b0}}, csr_wdata};\n          mstatus_d.xs = riscv::Off;\n          if (!CVA6Cfg.FpPresent) begin\n            mstatus_d.fs = riscv::Off;\n          end\n          if (!CVA6Cfg.RVV) begin\n            mstatus_d.vs = riscv::Off;\n          end\n          mstatus_d.wpri3 = 9'b0;\n          mstatus_d.wpri1 = 1'b0;\n          mstatus_d.wpri2 = 1'b0;\n          mstatus_d.wpri0 = 1'b0;\n          mstatus_d.ube   = 1'b0;  // CVA6 is little-endian\n          // this register has side-effects on other registers, flush the pipeline\n          flush_o         = 1'b1;\n        end\n        riscv::CSR_MSTATUSH: if (riscv::XLEN != 32) update_access_exception = 1'b1;\n        // MISA is WARL (Write Any Value, Reads Legal Value)\n        riscv::CSR_MISA: ;\n        // machine exception delegation register\n        // 0 - 15 exceptions supported\n        riscv::CSR_MEDELEG: begin\n          if (CVA6Cfg.RVS) begin\n            mask = (1 << riscv::INSTR_ADDR_MISALIGNED) |\n                             (1 << riscv::BREAKPOINT) |\n                             (1 << riscv::ENV_CALL_UMODE) |\n                             (1 << riscv::INSTR_PAGE_FAULT) |\n                             (1 << riscv::LOAD_PAGE_FAULT) |\n                             (1 << riscv::STORE_PAGE_FAULT);\n            medeleg_d = (medeleg_q & ~mask) | (csr_wdata & mask);\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n        // machine interrupt delegation register\n        // we do not support user interrupt delegation\n        riscv::CSR_MIDELEG: begin\n          if (CVA6Cfg.RVS) begin\n            mask = riscv::MIP_SSIP | riscv::MIP_STIP | riscv::MIP_SEIP;\n            mideleg_d = (mideleg_q & ~mask) | (csr_wdata & mask);\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n        // mask the register so that unsupported interrupts can never be set\n        riscv::CSR_MIE: begin\n          mask = riscv::MIP_SSIP | riscv::MIP_STIP | riscv::MIP_SEIP | riscv::MIP_MSIP | riscv::MIP_MTIP | riscv::MIP_MEIP;\n          mie_d = (mie_q & ~mask) | (csr_wdata & mask); // we only support supervisor and M-mode interrupts\n        end\n\n        riscv::CSR_MTVEC: begin\n          mtvec_d = {csr_wdata[riscv::XLEN-1:2], 1'b0, csr_wdata[0]};\n          // we are in vector mode, this implementation requires the additional\n          // alignment constraint of 64 * 4 bytes\n          if (csr_wdata[0]) mtvec_d = {csr_wdata[riscv::XLEN-1:8], 7'b0, csr_wdata[0]};\n        end\n        riscv::CSR_MCOUNTEREN: begin\n          if (CVA6Cfg.RVU) mcounteren_d = {{riscv::XLEN - 32{1'b0}}, csr_wdata[31:0]};\n          else update_access_exception = 1'b1;\n        end\n\n        riscv::CSR_MSCRATCH: mscratch_d = csr_wdata;\n        riscv::CSR_MEPC: mepc_d = {csr_wdata[riscv::XLEN-1:1], 1'b0};\n        riscv::CSR_MCAUSE: mcause_d = csr_wdata;\n        riscv::CSR_MTVAL: begin\n          if (CVA6Cfg.TvalEn) mtval_d = csr_wdata;\n          else update_access_exception = 1'b1;\n        end\n        riscv::CSR_MIP: begin\n          mask  = riscv::MIP_SSIP | riscv::MIP_STIP | riscv::MIP_SEIP;\n          mip_d = (mip_q & ~mask) | (csr_wdata & mask);\n        end\n        riscv::CSR_MENVCFG: if (CVA6Cfg.RVU) fiom_d = csr_wdata[0];\n        riscv::CSR_MENVCFGH: begin\n          if (!CVA6Cfg.RVU || riscv::XLEN != 32) update_access_exception = 1'b1;\n        end\n        riscv::CSR_MCOUNTINHIBIT:\n        if (PERF_COUNTER_EN) mcountinhibit_d = {csr_wdata[MHPMCounterNum+2:2], 1'b0, csr_wdata[0]};\n        else update_access_exception = 1'b1;\n        // performance counters\n        riscv::CSR_MCYCLE: cycle_d[riscv::XLEN-1:0] = csr_wdata;\n        riscv::CSR_MCYCLEH:\n        if (riscv::XLEN == 32) cycle_d[63:32] = csr_wdata;\n        else update_access_exception = 1'b1;\n        riscv::CSR_MINSTRET: instret_d[riscv::XLEN-1:0] = csr_wdata;\n        riscv::CSR_MINSTRETH:\n        if (riscv::XLEN == 32) instret_d[63:32] = csr_wdata;\n        else update_access_exception = 1'b1;\n        //Event Selector\n        riscv::CSR_MHPM_EVENT_3,\n                riscv::CSR_MHPM_EVENT_4,\n                riscv::CSR_MHPM_EVENT_5,\n                riscv::CSR_MHPM_EVENT_6,\n                riscv::CSR_MHPM_EVENT_7,\n                riscv::CSR_MHPM_EVENT_8,\n                riscv::CSR_MHPM_EVENT_9,\n                riscv::CSR_MHPM_EVENT_10,\n                riscv::CSR_MHPM_EVENT_11,\n                riscv::CSR_MHPM_EVENT_12,\n                riscv::CSR_MHPM_EVENT_13,\n                riscv::CSR_MHPM_EVENT_14,\n                riscv::CSR_MHPM_EVENT_15,\n                riscv::CSR_MHPM_EVENT_16,\n                riscv::CSR_MHPM_EVENT_17,\n                riscv::CSR_MHPM_EVENT_18,\n                riscv::CSR_MHPM_EVENT_19,\n                riscv::CSR_MHPM_EVENT_20,\n                riscv::CSR_MHPM_EVENT_21,\n                riscv::CSR_MHPM_EVENT_22,\n                riscv::CSR_MHPM_EVENT_23,\n                riscv::CSR_MHPM_EVENT_24,\n                riscv::CSR_MHPM_EVENT_25,\n                riscv::CSR_MHPM_EVENT_26,\n                riscv::CSR_MHPM_EVENT_27,\n                riscv::CSR_MHPM_EVENT_28,\n                riscv::CSR_MHPM_EVENT_29,\n                riscv::CSR_MHPM_EVENT_30,\n                riscv::CSR_MHPM_EVENT_31 :     begin\n          perf_we_o   = 1'b1;\n          perf_data_o = csr_wdata;\n        end\n\n        riscv::CSR_MHPM_COUNTER_3,\n                riscv::CSR_MHPM_COUNTER_4,\n                riscv::CSR_MHPM_COUNTER_5,\n                riscv::CSR_MHPM_COUNTER_6,\n                riscv::CSR_MHPM_COUNTER_7,\n                riscv::CSR_MHPM_COUNTER_8,\n                riscv::CSR_MHPM_COUNTER_9,\n                riscv::CSR_MHPM_COUNTER_10,\n                riscv::CSR_MHPM_COUNTER_11,\n                riscv::CSR_MHPM_COUNTER_12,\n                riscv::CSR_MHPM_COUNTER_13,\n                riscv::CSR_MHPM_COUNTER_14,\n                riscv::CSR_MHPM_COUNTER_15,\n                r"}
{"text": "iscv::CSR_MHPM_COUNTER_16,\n                riscv::CSR_MHPM_COUNTER_17,\n                riscv::CSR_MHPM_COUNTER_18,\n                riscv::CSR_MHPM_COUNTER_19,\n                riscv::CSR_MHPM_COUNTER_20,\n                riscv::CSR_MHPM_COUNTER_21,\n                riscv::CSR_MHPM_COUNTER_22,\n                riscv::CSR_MHPM_COUNTER_23,\n                riscv::CSR_MHPM_COUNTER_24,\n                riscv::CSR_MHPM_COUNTER_25,\n                riscv::CSR_MHPM_COUNTER_26,\n                riscv::CSR_MHPM_COUNTER_27,\n                riscv::CSR_MHPM_COUNTER_28,\n                riscv::CSR_MHPM_COUNTER_29,\n                riscv::CSR_MHPM_COUNTER_30,\n                riscv::CSR_MHPM_COUNTER_31 :  begin\n          perf_we_o   = 1'b1;\n          perf_data_o = csr_wdata;\n        end\n\n        riscv::CSR_MHPM_COUNTER_3H,\n                riscv::CSR_MHPM_COUNTER_4H,\n                riscv::CSR_MHPM_COUNTER_5H,\n                riscv::CSR_MHPM_COUNTER_6H,\n                riscv::CSR_MHPM_COUNTER_7H,\n                riscv::CSR_MHPM_COUNTER_8H,\n                riscv::CSR_MHPM_COUNTER_9H,\n                riscv::CSR_MHPM_COUNTER_10H,\n                riscv::CSR_MHPM_COUNTER_11H,\n                riscv::CSR_MHPM_COUNTER_12H,\n                riscv::CSR_MHPM_COUNTER_13H,\n                riscv::CSR_MHPM_COUNTER_14H,\n                riscv::CSR_MHPM_COUNTER_15H,\n                riscv::CSR_MHPM_COUNTER_16H,\n                riscv::CSR_MHPM_COUNTER_17H,\n                riscv::CSR_MHPM_COUNTER_18H,\n                riscv::CSR_MHPM_COUNTER_19H,\n                riscv::CSR_MHPM_COUNTER_20H,\n                riscv::CSR_MHPM_COUNTER_21H,\n                riscv::CSR_MHPM_COUNTER_22H,\n                riscv::CSR_MHPM_COUNTER_23H,\n                riscv::CSR_MHPM_COUNTER_24H,\n                riscv::CSR_MHPM_COUNTER_25H,\n                riscv::CSR_MHPM_COUNTER_26H,\n                riscv::CSR_MHPM_COUNTER_27H,\n                riscv::CSR_MHPM_COUNTER_28H,\n                riscv::CSR_MHPM_COUNTER_29H,\n                riscv::CSR_MHPM_COUNTER_30H,\n                riscv::CSR_MHPM_COUNTER_31H :  begin\n          perf_we_o = 1'b1;\n          if (riscv::XLEN == 32) perf_data_o = csr_wdata;\n          else update_access_exception = 1'b1;\n        end\n\n        riscv::CSR_DCACHE: dcache_d = {{riscv::XLEN - 1{1'b0}}, csr_wdata[0]};  // enable bit\n        riscv::CSR_ICACHE: icache_d = {{riscv::XLEN - 1{1'b0}}, csr_wdata[0]};  // enable bit\n        riscv::CSR_ACC_CONS: begin\n          if (CVA6Cfg.EnableAccelerator) begin\n            acc_cons_d = {{riscv::XLEN - 1{1'b0}}, csr_wdata[0]};  // enable bit\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n        // PMP locked logic\n        // 1. refuse to update any locked entry\n        // 2. also refuse to update the entry below a locked TOR entry\n        // Note that writes to pmpcfg below a locked TOR entry are valid\n        riscv::CSR_PMPCFG0:\n        for (int i = 0; i < (riscv::XLEN / 8); i++)\n        if (!pmpcfg_q[i].locked) pmpcfg_d[i] = csr_wdata[i*8+:8];\n        riscv::CSR_PMPCFG1: begin\n          if (riscv::XLEN == 32) begin\n            for (int i = 0; i < 4; i++)\n            if (!pmpcfg_q[i+4].locked) pmpcfg_d[i+4] = csr_wdata[i*8+:8];\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n        riscv::CSR_PMPCFG2:\n        for (int i = 0; i < (riscv::XLEN / 8); i++)\n        if (!pmpcfg_q[i+8].locked) pmpcfg_d[i+8] = csr_wdata[i*8+:8];\n        riscv::CSR_PMPCFG3: begin\n          if (riscv::XLEN == 32) begin\n            for (int i = 0; i < 4; i++)\n            if (!pmpcfg_q[i+12].locked) pmpcfg_d[i+12] = csr_wdata[i*8+:8];\n          end else begin\n            update_access_exception = 1'b1;\n          end\n        end\n        riscv::CSR_PMPADDR0,\n                riscv::CSR_PMPADDR1,\n                riscv::CSR_PMPADDR2,\n                riscv::CSR_PMPADDR3,\n                riscv::CSR_PMPADDR4,\n                riscv::CSR_PMPADDR5,\n                riscv::CSR_PMPADDR6,\n                riscv::CSR_PMPADDR7,\n                riscv::CSR_PMPADDR8,\n                riscv::CSR_PMPADDR9,\n                riscv::CSR_PMPADDR10,\n                riscv::CSR_PMPADDR11,\n                riscv::CSR_PMPADDR12,\n                riscv::CSR_PMPADDR13,\n                riscv::CSR_PMPADDR14,\n                riscv::CSR_PMPADDR15:  begin\n          // index is specified by the last byte in the address\n          automatic logic [3:0] index = csr_addr.csr_decode.address[3:0];\n          // check if the entry or the entry above is locked\n          if (!pmpcfg_q[index].locked && !(pmpcfg_q[index+1].locked && pmpcfg_q[index].addr_mode == riscv::TOR)) begin\n            pmpaddr_d[index] = csr_wdata[riscv::PLEN-3:0];\n          end\n        end\n        default: update_access_exception = 1'b1;\n      endcase\n    end\n\n    mstatus_d.sxl = riscv::XLEN_64;\n    mstatus_d.uxl = riscv::XLEN_64;\n    if (!CVA6Cfg.RVU) begin\n      mstatus_d.mpp = riscv::PRIV_LVL_M;\n    end\n    // mark the floating point extension register as dirty\n    if (CVA6Cfg.FpPresent && (dirty_fp_state_csr || dirty_fp_state_i)) begin\n      mstatus_d.fs = riscv::Dirty;\n    end\n    // mark the vector extension register as dirty\n    if (CVA6Cfg.RVV && dirty_v_state_i) begin\n      mstatus_d.vs = riscv::Dirty;\n    end\n    // hardwired extension registers\n    mstatus_d.sd = (mstatus_q.xs == riscv::Dirty) | (mstatus_q.fs == riscv::Dirty);\n\n    // reserve PMPCFG bits 5 and 6 (hardwire to 0)\n    for (int i = 0; i < CVA6Cfg.NrPMPEntries; i++) pmpcfg_d[i].reserved = 2'b0;\n\n    // write the floating point status register\n    if (CVA6Cfg.FpPresent && csr_write_fflags_i) begin\n      fcsr_d.fflags = csr_wdata_i[4:0] | fcsr_q.fflags;\n    end\n\n    // ----------------------------\n    // Accelerator FP imprecise exceptions\n    // ----------------------------\n\n    // Update fflags as soon as a FP exception occurs in the accelerator\n    // The exception is imprecise, and the fcsr.fflags update always happens immediately\n    if (CVA6Cfg.EnableAccelerator) begin\n      fcsr_d.fflags |= acc_fflags_ex_valid_i ? acc_fflags_ex_i : 5'b0;\n    end\n\n    // ---------------------\n    // External Interrupts\n    // ---------------------\n    // Machine Mode External Interrupt Pending\n    mip_d[riscv::IRQ_M_EXT] = irq_i[0];\n    // Machine software interrupt\n    mip_d[riscv::IRQ_M_SOFT] = ipi_i;\n    // Timer interrupt pending, coming from platform timer\n    mip_d[riscv::IRQ_M_TIMER] = time_irq_i;\n\n    // -----------------------\n    // Manage Exception Stack\n    // -----------------------\n    // update exception CSRs\n    // we got an exception update cause, pc and stval register\n    trap_to_priv_lvl = riscv::PRIV_LVL_M;\n    // Exception is taken and we are not in debug mode\n    // exceptions in debug mode don't update any fields\n    if ((CVA6Cfg.DebugEn && !debug_mode_q && ex_i.cause != riscv::DEBUG_REQUEST && ex_i.valid) || (!CVA6Cfg.DebugEn && ex_i.valid)) begin\n      // do not flush, flush is reserved for CSR writes with side effects\n      flush_o = 1'b0;\n      // figure out where to trap to\n      // a m-mode trap might be delegated if we are taking it in S mode\n      // first figure out if this was an exception or an interrupt e.g.: look at bit (XLEN-1)\n      // the cause register can only be $clog2(riscv::XLEN) bits long (as we only support XLEN exceptions)\n      if (CVA6Cfg.RVS && ((ex_i.cause[riscv::XLEN-1] && mideleg_q[ex_i.cause[$clog2(\n              riscv::XLEN\n          )-1:0]]) || (~ex_i.cause[riscv::XLEN-1] && medeleg_q[ex_i.cause[$clog2(\n              riscv::XLEN\n          )-1:0]]))) begin\n        // traps never transition from a more-privileged mode to a less privileged mode\n        // so if we are already in M mode, stay there\n        if (priv_lvl_o == riscv::PRIV_LVL_M) trap_to_priv_lvl = riscv::PRIV_LVL_M;\n        else trap_to_priv_lvl = riscv::PRIV_LVL_S;\n      end\n\n      // trap to supervisor mode\n      if (CVA6Cfg.RVS && trap_to_priv_lvl == riscv::PRIV_LVL_S) begin\n        // update sstatus\n        mstatus_d.sie = 1'b0;\n        mstatus_d.spie = mstatus_q.sie;\n        // this can either be user or supervisor mode\n        mstatus_d.spp = priv_lvl_q[0];\n        // set cause\n        scause_d = ex_i.cause;\n        // set epc\n        sepc_d = {{riscv::XLEN - riscv::VLEN{pc_i[riscv::VLEN-1]}}, pc_i};\n        // set mtval or stval\n        stval_d        = (ariane_pkg::ZERO_TVAL\n                                  && (ex_i.cause inside {\n                                    riscv::ILLEGAL_INSTR,\n                                    riscv::BREAKPOINT,\n                                    riscv::ENV_CALL_UMODE,\n                                    riscv::ENV_CALL_SMODE,\n                                    riscv::ENV_CALL_MMODE\n                                  } || ex_i.cause[riscv::XLEN-1])) ? '0 : ex_i.tval;\n        // trap to machine mode\n      end else begin\n        // update mstatus\n        mstatus_d.mie = 1'b0;\n        mstatus_d.mpie = mstatus_q.mie;\n        // save the previous privilege mode\n        mstatus_d.mpp = priv_lvl_q;\n        mcause_d = ex_i.cause;\n        // set epc\n        mepc_d = {{riscv::XLEN - riscv::VLEN{pc_i[riscv::VLEN-1]}}, pc_i};\n        // set mtval or stval\n        if (CVA6Cfg.TvalEn) begin\n          mtval_d        = (ariane_pkg::ZERO_TVAL\n                                    && (ex_i.cause inside {\n                                      riscv::ILLEGAL_INSTR,\n                                      riscv::BREAKPOINT,\n                                      riscv::ENV_CALL_UMODE,\n                                      riscv::ENV_CALL_SMODE,\n                                      riscv::ENV_CALL_MMODE\n                                    } || ex_i.cause[riscv::XLEN-1])) ? '0 : ex_i.tval;\n        end else begin\n          mtval_d = '0;\n        end\n      end\n\n      priv_lvl_d = trap_to_priv_lvl;\n    end\n\n    // ------------------------------\n    // Debug\n    // ------------------------------\n    // Explains why Debug Mode was entered.\n    // When there are multiple reasons to enter Debug Mode in a single cycle, hardware should set cause to the cause with the highest priority.\n    // 1: An ebreak instruction was executed. (priority 3)\n    // 2: The Trigger Module caused a breakpoint exception. (priority 4)\n    // 3: The debugger requested entry to Debug Mode. (priority 2)\n    // 4: The hart single stepped because step was set. (priority 1)\n    // we are currently not in debug mode and could potentially enter\n    if (!debug_mode_q) begin\n      dcsr_d.prv = priv_lvl_o;\n      // trigger module fired\n\n      // caused by a breakpoint\n      if (CVA6Cfg.DebugEn && ex_i.valid && ex_i.cause == riscv::BREAKPOINT) begin\n        dcsr_d.prv = priv_lvl_o;\n        // check that we actually want to enter debug depending on the privilege level we are currently in\n        unique case (priv_lvl_o)\n          riscv::PRIV_LVL_M: begin\n            debug_mode_d   = dcsr_q.ebreakm;\n            set_debug_pc_o = dcsr_q.ebreakm;\n          end\n          riscv::PRIV_LVL_S: begin\n            if (CVA6Cfg.RVS) begin\n              debug_mode_d   = dcsr_q.ebreaks;\n              set_debug_pc_o = dcsr_q.ebreaks;\n            end\n          end\n          riscv::PRIV_LVL_U: begin\n            if (CVA6Cfg.RVU) begin\n              debug_mode_d   = dcsr_q.ebreaku;\n              set_debug_pc_o = dcsr_q.ebreaku;\n            end\n          end\n          default: ;\n        endcase\n        // save PC of next this instruction e.g.: the next one to be executed\n        dpc_d = {{riscv::XLEN - riscv::VLEN{pc_i[riscv::VLEN-1]}}, pc_i};\n        dcsr_d.cause = ariane_pkg::CauseBreakpoint;\n      end\n\n      // we've got a debug request\n      if (CVA6Cfg.DebugEn && ex_i.valid && ex_i.cause == riscv::DEBUG_REQUEST) begin\n        dcsr_d.prv = priv_lvl_o;\n        // save the PC\n        dpc_d = {{riscv::XLEN - riscv::VLEN{pc_i[riscv::VLEN-1]}}, pc_i};\n        // enter debug mode\n        debug_mode_d = 1'b1;\n        // jump to the base address\n        set_debug_pc_o = 1'b1;\n        // save the cause as external debug request\n        dcsr_d.cause = ariane_pkg::CauseRequest;\n      end\n\n      // single step enable and we just retired an instruction\n      if (CVA6Cfg.DebugEn && dcsr_q.step && commit_ack_i[0]) begin\n        dcsr_d.prv = priv_lvl_o;\n        // valid CTRL flow change\n        if (commit_instr_i[0].fu == CTRL_FLOW) begin\n          // we saved the correct target address during execute\n          dpc_d = {\n            {riscv::XLEN - riscv::VLEN{commit_instr_i[0].bp.predict_address[riscv::VLEN-1]}},\n            commit_instr_i[0].bp.predict_address\n          };\n          // exception valid\n        end else if (ex_i.valid) begin\n          dpc_d = {{riscv::XLEN - riscv::VLEN{1'b0}}, trap_vector_base_o};\n          // return from environment\n        end else if (eret_o) begin\n          dpc_d = {{riscv::XLEN - riscv::VLEN{1'b0}}, epc_o};\n          // consecutive PC\n        end else begin\n          dpc_d = {\n            {riscv::XLEN - riscv::VLEN{commit_instr_i[0].pc[riscv::VLEN-1]}},\n            commit_instr_i[0].pc + (commit_instr_i[0].is_compressed ? 'h2 : 'h4)\n          };\n        end\n        debug_mode_d   = 1'b1;\n        set_debug_pc_o = 1'b1;\n        dcsr_d.cause   = ariane_pkg::CauseSingleStep;\n      end\n    end\n    // go in halt-state again when we encounter an exception\n    if (CVA6Cfg.DebugEn && debug_mode_q && ex_i.valid && ex_i.cause == riscv::BREAKPOINT) begin\n      set_debug_pc_o = 1'b1;\n    end\n\n    // ------------------------------\n    // MPRV - Modify Privilege Level\n    // ------------------------------\n    // Set the address translation at which the load and stores should occur\n    // we can use the previous values since changing the address translation will always involve a pipeline flush\n    if (ariane_pkg::MMU_PRESENT && mprv && CVA6Cfg.RVS && riscv::vm_mode_t'(satp_q.mode) == riscv::MODE_SV && (mstatus_q.mpp != riscv::PRIV_LVL_M))\n      en_ld_st_translation_d = 1'b1;\n    else  // otherwise we go with the regular settings\n      en_ld_st_translation_d = en_translation_o;\n\n    ld_st_priv_lvl_o = (mprv) ? mstatus_q.mpp : priv_lvl_o;\n    en_ld_st_translation_o = en_ld_st_translation_q;\n    // ------------------------------\n    // Return from Environment\n    // ------------------------------\n    // When executing an xRET instruction, supposing xPP holds the value y, xIE is set to xPIE; the privilege\n    // mode is changed to y; xPIE is set to 1; and xPP is set to U\n    if (mret) begin\n      // return from exception, IF doesn't care from where we are returning\n      eret_o        = 1'b1;\n      // return to the previous privilege level and restore all enable flags\n      // get the previous machine interrupt enable flag\n      mstatus_d.mie = mstatus_q.mpie;\n      // restore the previous privilege level\n      priv_lvl_d    = mstatus_q.mpp;\n      mstatus_d.mpp = riscv::PRIV_LVL_M;\n      if (CVA6Cfg.RVU) begin\n        // set mpp to user mode\n        mstatus_d.mpp = riscv::PRIV_LVL_U;\n      end\n      // set mpie to 1\n      mstatus_d.mpie = 1'b1;\n    end\n\n    if (CVA6Cfg.RVS && sret) begin\n      // return from exception, IF doesn't care from where we are returning\n      eret_o         = 1'b1;\n      // return the previous supervisor interrupt enable flag\n      mstatus_d.sie  = mstatus_q.spie;\n      // restore the previous privilege level\n      priv_lvl_d     = riscv::priv_lvl_t'({1'b0, mstatus_q.spp});\n      // set spp to user mode\n      mstatus_d.spp  = 1'b0;\n      // set spie to 1\n      mstatus_d.spie = 1'b1;\n    end\n\n    // return from debug mode\n    if (CVA6Cfg.DebugEn && dret) begin\n      // return from exception, IF doesn't care from where we are returning\n      eret_o       = 1'b1;\n      // restore the previous privilege level\n      priv_lvl_d   = riscv::priv_lvl_t'(dcsr_q.prv);\n      // actually return from debug mode\n      debug_mode_d = 1'b0;\n    end\n  end\n\n  // ---------------------------\n  // CSR OP Select Logic\n  // ---------------------------\n  always_comb begin : csr_op_logic\n    csr_wdata = csr_wdata_i;\n    csr_we    = 1'b1;\n    csr_read  = 1'b1;\n    mret      = 1'b0;\n    sret      = 1'b0;\n    dret      = 1'b0;\n\n    unique case (csr_op_i)\n      CSR_WRITE: csr_wdata = csr_wdata_i;\n      CSR_SET:   csr_wdata = csr_wdata_i | csr_rdata;\n      CSR_CLEAR: csr_wdata = (~csr_wdata_i) & csr_rdata;\n      CSR_READ:  csr_we = 1'b0;\n      MRET: begin\n        // the return should not have any write or read side-effects\n        csr_we   = 1'b0;\n        csr_read = 1'b0;\n        mret     = 1'b1;  // signal a return from machine mode\n      end\n      default: begin\n        if (CVA6Cfg.RVS && csr_op_i == SRET) begin\n          // the return should not have any write or read side-effects\n          csr_we   = 1'b0;\n          csr_read = 1'b0;\n          sret     = 1'b1;  // signal a return from supervisor mode\n        end else if (CVA6Cfg.DebugEn && csr_op_i == DRET) begin\n          // the return should not have any write or read side-effects\n          csr_we   = 1'b0;\n          csr_read = 1'b0;\n          dret     = 1'b1;  // signal a return from debug mode\n        end else begin\n          csr_we   = 1'b0;\n          csr_read = 1'b0;\n        end\n      end\n    endcase\n    // if we are violating our privilges do not update the architectural state\n    if (privilege_violation) begin\n      csr_we   = 1'b0;\n      csr_read = 1'b0;\n    end\n  end\n\n  assign irq_ctrl_o.mie = mie_q;\n  assign irq_ctrl_o.mip = mip_q;\n  assign irq_ctrl_o.sie = mstatus_q.sie;\n  assign irq_ctrl_o.mideleg = mideleg_q;\n  assign irq_ctrl_o.global_enable = (~debug_mode_q)\n      // interrupts are enabled during single step or we are not stepping\n      // No need to check interrupts during single step if we don't support DEBUG mode\n      & (~CVA6Cfg.DebugEn | (~dcsr_q.step | dcsr_q.stepie))\n                                    & ((mstatus_q.mie & (priv_lvl_o == riscv::PRIV_LVL_M))\n                                    | (priv_lvl_o != riscv::PRIV_LVL_M));\n\n  always_comb begin : privilege_check\n    // -----------------\n    // Privilege Check\n    // -----------------\n    privilege_violation = 1'b0;\n    // if we are reading or writing, check for the correct privilege level this has\n    // precedence over interrupts\n    if (csr_op_i inside {CSR_WRITE, CSR_SET, CSR_CLEAR, CSR_READ}) begin\n      if ((riscv::priv_lvl_t'(priv_lvl_o & csr_addr.csr_decode.priv_lvl) != csr_addr.csr_decode.priv_lvl)) begin\n        privilege_violation = 1'b1;\n      end\n      // check access to debug mode only CSRs\n      if ((!CVA6Cfg.DebugEn && csr_addr_i[11:4] == 8'h7b) || (CVA6Cfg.DebugEn && csr_addr_i[11:4] == 8'h7b && !debug_mode_q)) begin\n        privilege_violation = 1'b1;\n      end\n      // check counter-enabled counter CSR accesses\n      // counter address range is C00 to C1F\n      if (csr_addr_i inside {[riscv::CSR_CYCLE : riscv::CSR_HPM_COUNTER_31]}) begin\n        if (priv_lvl_o == riscv::PRIV_LVL_S && CVA6Cfg.RVS) begin\n          privilege_violation = ~mcounteren_q[csr_addr_i[4:0]];\n        end else if (priv_lvl_o == riscv::PRIV_LVL_U && CVA6Cfg.RVU) begin\n          privilege_violation = ~mcounteren_q[csr_addr_i[4:0]] | ~scounteren_q[csr_addr_i[4:0]];\n        end else if (priv_lvl_o == riscv::PRIV_LVL_M) begin\n          privilege_violation = 1'b0;\n        end\n      end\n    end\n  end\n  // ----------------------\n  // CSR Exception Control\n  // ----------------------\n  always_comb begin : exception_ctrl\n    csr_exception_o = {{riscv::XLEN{1'b0}}, {riscv::XLEN{1'b0}}, 1'b0};\n    // ----------------------------------\n    // Illegal Access (decode exception)\n    // ----------------------------------\n    // we got an exception in one of the processes above\n    // throw an illegal instruction exception\n    if (update_access_exception || read_access_exception) begin\n      csr_exception_o.cause = riscv::ILLEGAL_INSTR;\n      // we don't set the tval field as this will be set by the commit stage\n      // this spares the extra wiring from commit to CSR and back to commit\n      csr_exception_o.valid = 1'"}
{"text": "b1;\n    end\n\n    if (privilege_violation) begin\n      csr_exception_o.cause = riscv::ILLEGAL_INSTR;\n      csr_exception_o.valid = 1'b1;\n    end\n  end\n\n  // -------------------\n  // Wait for Interrupt\n  // -------------------\n  always_comb begin : wfi_ctrl\n    // wait for interrupt register\n    wfi_d = wfi_q;\n    // if there is any (enabled) interrupt pending un-stall the core\n    // also un-stall if we want to enter debug mode\n    if (|(mip_q & mie_q) || (CVA6Cfg.DebugEn && debug_req_i) || irq_i[1]) begin\n      wfi_d = 1'b0;\n      // or alternatively if there is no exception pending and we are not in debug mode wait here\n      // for the interrupt\n    end else if (((CVA6Cfg.DebugEn && !debug_mode_q) && csr_op_i == WFI && !ex_i.valid) || (!CVA6Cfg.DebugEn && csr_op_i == WFI && !ex_i.valid)) begin\n      wfi_d = 1'b1;\n    end\n  end\n\n  // output assignments dependent on privilege mode\n  always_comb begin : priv_output\n    trap_vector_base_o = {mtvec_q[riscv::VLEN-1:2], 2'b0};\n    // output user mode stvec\n    if (CVA6Cfg.RVS && trap_to_priv_lvl == riscv::PRIV_LVL_S) begin\n      trap_vector_base_o = {stvec_q[riscv::VLEN-1:2], 2'b0};\n    end\n\n    // if we are in debug mode jump to a specific address\n    if (CVA6Cfg.DebugEn && debug_mode_q) begin\n      trap_vector_base_o = CVA6Cfg.DmBaseAddress[riscv::VLEN-1:0] + CVA6Cfg.ExceptionAddress[riscv::VLEN-1:0];\n    end\n\n    // check if we are in vectored mode, if yes then do BASE + 4 * cause we\n    // are imposing an additional alignment-constraint of 64 * 4 bytes since\n    // we want to spare the costly addition. Furthermore check to which\n    // privilege level we are jumping and whether the vectored mode is\n    // activated for _that_ privilege level.\n    if (ex_i.cause[riscv::XLEN-1] &&\n                ((((CVA6Cfg.RVS || CVA6Cfg.RVU) && trap_to_priv_lvl == riscv::PRIV_LVL_M && mtvec_q[0]) || (!CVA6Cfg.RVS && !CVA6Cfg.RVU && mtvec_q[0]))\n               || (CVA6Cfg.RVS && trap_to_priv_lvl == riscv::PRIV_LVL_S && stvec_q[0]))) begin\n      trap_vector_base_o[7:2] = ex_i.cause[5:0];\n    end\n\n    epc_o = mepc_q[riscv::VLEN-1:0];\n    // we are returning from supervisor mode, so take the sepc register\n    if (CVA6Cfg.RVS && sret) begin\n      epc_o = sepc_q[riscv::VLEN-1:0];\n    end\n    // we are returning from debug mode, to take the dpc register\n    if (CVA6Cfg.DebugEn && dret) begin\n      epc_o = dpc_q[riscv::VLEN-1:0];\n    end\n  end\n\n  // -------------------\n  // Output Assignments\n  // -------------------\n  always_comb begin\n    // When the SEIP bit is read with a CSRRW, CSRRS, or CSRRC instruction, the value\n    // returned in the rd destination register contains the logical-OR of the software-writable\n    // bit and the interrupt signal from the interrupt controller.\n    csr_rdata_o = csr_rdata;\n\n    unique case (csr_addr.address)\n      riscv::CSR_MIP:\n      csr_rdata_o = csr_rdata | ({{riscv::XLEN - 1{1'b0}}, irq_i[1]} << riscv::IRQ_S_EXT);\n      // in supervisor mode we also need to check whether we delegated this bit\n      riscv::CSR_SIP: begin\n        if (CVA6Cfg.RVS) begin\n          csr_rdata_o = csr_rdata\n                              | ({{riscv::XLEN-1{1'b0}}, (irq_i[1] & mideleg_q[riscv::IRQ_S_EXT])} << riscv::IRQ_S_EXT);\n        end\n      end\n      default: ;\n    endcase\n  end\n\n  // in debug mode we execute with privilege level M\n  assign priv_lvl_o = (CVA6Cfg.DebugEn && debug_mode_q) ? riscv::PRIV_LVL_M : priv_lvl_q;\n  // FPU outputs\n  assign fflags_o = fcsr_q.fflags;\n  assign frm_o = fcsr_q.frm;\n  assign fprec_o = fcsr_q.fprec;\n  // MMU outputs\n  assign satp_ppn_o = satp_q.ppn;\n  assign asid_o = satp_q.asid[AsidWidth-1:0];\n  assign sum_o = mstatus_q.sum;\n  // we support bare memory addressing and SV39\n  assign en_translation_o = ((CVA6Cfg.RVS && riscv::vm_mode_t'(satp_q.mode) == riscv::MODE_SV) &&\n                               priv_lvl_o != riscv::PRIV_LVL_M)\n                              ? 1'b1\n                              : 1'b0;\n  assign mxr_o = mstatus_q.mxr;\n  assign tvm_o = mstatus_q.tvm;\n  assign tw_o = mstatus_q.tw;\n  assign tsr_o = mstatus_q.tsr;\n  assign halt_csr_o = wfi_q;\n`ifdef PITON_ARIANE\n  assign icache_en_o = icache_q[0];\n`else\n  assign icache_en_o = icache_q[0] & (~debug_mode_q);\n`endif\n  assign dcache_en_o = dcache_q[0];\n  assign acc_cons_en_o = CVA6Cfg.EnableAccelerator ? acc_cons_q[0] : 1'b0;\n\n  // determine if mprv needs to be considered if in debug mode\n  assign mprv = (CVA6Cfg.DebugEn && debug_mode_q && !dcsr_q.mprven) ? 1'b0 : mstatus_q.mprv;\n  assign debug_mode_o = debug_mode_q;\n  assign single_step_o = dcsr_q.step;\n  assign mcountinhibit_o = {{29 - MHPMCounterNum{1'b0}}, mcountinhibit_q};\n\n  // sequential process\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      priv_lvl_q   <= riscv::PRIV_LVL_M;\n      // floating-point registers\n      fcsr_q       <= '0;\n      // debug signals\n      debug_mode_q <= 1'b0;\n      if (CVA6Cfg.DebugEn) begin\n        dcsr_q           <= '0;\n        dcsr_q.prv       <= riscv::PRIV_LVL_M;\n        dcsr_q.xdebugver <= 4'h4;\n        dpc_q            <= '0;\n        dscratch0_q      <= {riscv::XLEN{1'b0}};\n        dscratch1_q      <= {riscv::XLEN{1'b0}};\n      end\n      // machine mode registers\n      mstatus_q        <= 64'b0;\n      // set to boot address + direct mode + 4 byte offset which is the initial trap\n      mtvec_rst_load_q <= 1'b1;\n      mtvec_q          <= '0;\n      mip_q            <= {riscv::XLEN{1'b0}};\n      mie_q            <= {riscv::XLEN{1'b0}};\n      mepc_q           <= {riscv::XLEN{1'b0}};\n      mcause_q         <= {riscv::XLEN{1'b0}};\n      mcounteren_q     <= {riscv::XLEN{1'b0}};\n      mscratch_q       <= {riscv::XLEN{1'b0}};\n      mtval_q          <= {riscv::XLEN{1'b0}};\n      fiom_q           <= '0;\n      dcache_q         <= {{riscv::XLEN - 1{1'b0}}, 1'b1};\n      icache_q         <= {{riscv::XLEN - 1{1'b0}}, 1'b1};\n      mcountinhibit_q  <= '0;\n      acc_cons_q       <= {{riscv::XLEN - 1{1'b0}}, CVA6Cfg.EnableAccelerator};\n      // supervisor mode registers\n      if (CVA6Cfg.RVS) begin\n        medeleg_q    <= {riscv::XLEN{1'b0}};\n        mideleg_q    <= {riscv::XLEN{1'b0}};\n        sepc_q       <= {riscv::XLEN{1'b0}};\n        scause_q     <= {riscv::XLEN{1'b0}};\n        stvec_q      <= {riscv::XLEN{1'b0}};\n        scounteren_q <= {riscv::XLEN{1'b0}};\n        sscratch_q   <= {riscv::XLEN{1'b0}};\n        stval_q      <= {riscv::XLEN{1'b0}};\n        satp_q       <= {riscv::XLEN{1'b0}};\n      end\n      // timer and counters\n      cycle_q                <= 64'b0;\n      instret_q              <= 64'b0;\n      // aux registers\n      en_ld_st_translation_q <= 1'b0;\n      // wait for interrupt\n      wfi_q                  <= 1'b0;\n      // pmp\n      for (int i = 0; i < 16; i++) begin\n        if (i < CVA6Cfg.NrPMPEntries) begin\n          pmpcfg_q[i]  <= riscv::pmpcfg_t'(CVA6Cfg.PMPCfgRstVal[i]);\n          pmpaddr_q[i] <= CVA6Cfg.PMPAddrRstVal[i][riscv::PLEN-3:0];\n        end else begin\n          pmpcfg_q[i]  <= '0;\n          pmpaddr_q[i] <= '0;\n        end\n      end\n    end else begin\n      priv_lvl_q <= priv_lvl_d;\n      // floating-point registers\n      fcsr_q     <= fcsr_d;\n      // debug signals\n      if (CVA6Cfg.DebugEn) begin\n        debug_mode_q <= debug_mode_d;\n        dcsr_q       <= dcsr_d;\n        dpc_q        <= dpc_d;\n        dscratch0_q  <= dscratch0_d;\n        dscratch1_q  <= dscratch1_d;\n      end\n      // machine mode registers\n      mstatus_q        <= mstatus_d;\n      mtvec_rst_load_q <= 1'b0;\n      mtvec_q          <= mtvec_d;\n      mip_q            <= mip_d;\n      mie_q            <= mie_d;\n      mepc_q           <= mepc_d;\n      mcause_q         <= mcause_d;\n      mcounteren_q     <= mcounteren_d;\n      mscratch_q       <= mscratch_d;\n      if (CVA6Cfg.TvalEn) mtval_q <= mtval_d;\n      fiom_q          <= fiom_d;\n      dcache_q        <= dcache_d;\n      icache_q        <= icache_d;\n      mcountinhibit_q <= mcountinhibit_d;\n      acc_cons_q      <= acc_cons_d;\n      // supervisor mode registers\n      if (CVA6Cfg.RVS) begin\n        medeleg_q    <= medeleg_d;\n        mideleg_q    <= mideleg_d;\n        sepc_q       <= sepc_d;\n        scause_q     <= scause_d;\n        stvec_q      <= stvec_d;\n        scounteren_q <= scounteren_d;\n        sscratch_q   <= sscratch_d;\n        if (CVA6Cfg.TvalEn) stval_q <= stval_d;\n        satp_q <= satp_d;\n      end\n      // timer and counters\n      cycle_q                <= cycle_d;\n      instret_q              <= instret_d;\n      // aux registers\n      en_ld_st_translation_q <= en_ld_st_translation_d;\n      // wait for interrupt\n      wfi_q                  <= wfi_d;\n      // pmp\n      pmpcfg_q               <= pmpcfg_next;\n      pmpaddr_q              <= pmpaddr_next;\n    end\n  end\n\n  // write logic pmp\n  always_comb begin : write\n    for (int i = 0; i < 16; i++) begin\n      if (i < CVA6Cfg.NrPMPEntries) begin\n        // We only support >=8-byte granularity, NA4 is disabled\n        if(!CVA6Cfg.PMPEntryReadOnly[i] && pmpcfg_d[i].addr_mode != riscv::NA4 && !(pmpcfg_d[i].access_type.r == '0 && pmpcfg_d[i].access_type.w == '1)) begin\n          pmpcfg_next[i] = pmpcfg_d[i];\n        end else begin\n          pmpcfg_next[i] = pmpcfg_q[i];\n        end\n        if (!CVA6Cfg.PMPEntryReadOnly[i]) begin\n          pmpaddr_next[i] = pmpaddr_d[i];\n        end else begin\n          pmpaddr_next[i] = pmpaddr_q[i];\n        end\n      end else begin\n        pmpcfg_next[i]  = '0;\n        pmpaddr_next[i] = '0;\n      end\n    end\n  end\n\n  //-------------\n  // Assertions\n  //-------------\n  //pragma translate_off\n  // check that eret and ex are never valid together\n  assert property (@(posedge clk_i) disable iff (!rst_ni !== '0) !(eret_o && ex_i.valid))\n  else begin\n    $error(\"eret and exception should never be valid at the same time\");\n    $stop();\n  end\n  //pragma translate_on\n\n\n  //RVFI CSR\n\n  //-------------\n  // RVFI\n  //-------------\n  assign rvfi_csr_o.fcsr_q = CVA6Cfg.FpPresent ? fcsr_q : '0;\n  assign rvfi_csr_o.dcsr_q = CVA6Cfg.DebugEn ? dcsr_q : '0;\n  assign rvfi_csr_o.dpc_q = CVA6Cfg.DebugEn ? dpc_q : '0;\n  assign rvfi_csr_o.dscratch0_q = CVA6Cfg.DebugEn ? dscratch0_q : '0;\n  assign rvfi_csr_o.dscratch1_q = CVA6Cfg.DebugEn ? dscratch1_q : '0;\n  assign rvfi_csr_o.mie_q = mie_q;\n  assign rvfi_csr_o.mip_q = mip_q;\n  assign rvfi_csr_o.stvec_q = CVA6Cfg.RVS ? stvec_q : '0;\n  assign rvfi_csr_o.scounteren_q = CVA6Cfg.RVS ? scounteren_q : '0;\n  assign rvfi_csr_o.sscratch_q = CVA6Cfg.RVS ? sscratch_q : '0;\n  assign rvfi_csr_o.sepc_q = CVA6Cfg.RVS ? sepc_q : '0;\n  assign rvfi_csr_o.scause_q = CVA6Cfg.RVS ? scause_q : '0;\n  assign rvfi_csr_o.stval_q = CVA6Cfg.RVS ? stval_q : '0;\n  assign rvfi_csr_o.satp_q = CVA6Cfg.RVS ? satp_q : '0;\n  assign rvfi_csr_o.mstatus_extended = mstatus_extended;\n  assign rvfi_csr_o.medeleg_q = CVA6Cfg.RVS ? medeleg_q : '0;\n  assign rvfi_csr_o.mideleg_q = CVA6Cfg.RVS ? mideleg_q : '0;\n  assign rvfi_csr_o.mtvec_q = mtvec_q;\n  assign rvfi_csr_o.mcounteren_q = mcounteren_q;\n  assign rvfi_csr_o.mscratch_q = mscratch_q;\n  assign rvfi_csr_o.mepc_q = mepc_q;\n  assign rvfi_csr_o.mcause_q = mcause_q;\n  assign rvfi_csr_o.mtval_q = mtval_q;\n  assign rvfi_csr_o.fiom_q = fiom_q;\n  assign rvfi_csr_o.mcountinhibit_q = mcountinhibit_q;\n  assign rvfi_csr_o.cycle_q = cycle_q;\n  assign rvfi_csr_o.instret_q = instret_q;\n  assign rvfi_csr_o.dcache_q = dcache_q;\n  assign rvfi_csr_o.icache_q = icache_q;\n  assign rvfi_csr_o.acc_cons_q = CVA6Cfg.EnableAccelerator ? acc_cons_q : '0;\n  assign rvfi_csr_o.pmpcfg_q = pmpcfg_q;\n  assign rvfi_csr_o.pmpaddr_q = pmpaddr_q;\n\n\nendmodule\n"}
{"text": "// Copyright 2022 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 32;\n\n  localparam CVA6ConfigFpuEn = 0;\n  localparam CVA6ConfigF16En = 0;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 1;\n  localparam CVA6ConfigCExtEn = 1;\n  localparam CVA6ConfigZcbExtEn = 1;\n  localparam CVA6ConfigAExtEn = 1;\n  localparam CVA6ConfigBExtEn = 1;\n  localparam CVA6ConfigVExtEn = 0;\n  localparam CVA6ConfigZiCondExtEn = 1;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = CVA6ConfigXlen;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = CVA6ConfigXlen;\n\n  localparam CVA6ConfigIcacheByteSize = 16384;\n  localparam CVA6ConfigIcacheSetAssoc = 4;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 32768;\n  localparam CVA6ConfigDcacheSetAssoc = 8;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 1;\n  localparam CVA6ConfigMemTidWidth = 2;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 8;\n\n  localparam CVA6ConfigNrCommitPorts = 1;\n  localparam CVA6ConfigNrScoreboardEntries = 4;\n\n  localparam CVA6ConfigFPGAEn = 0;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 1;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n  localparam CVA6ConfigNrLoadBufEntries = 2;\n\n  localparam CVA6ConfigInstrTlbEntries = 2;\n  localparam CVA6ConfigDataTlbEntries = 2;\n\n  localparam CVA6ConfigRASDepth = 0;\n  localparam CVA6ConfigBTBEntries = 0;\n  localparam CVA6ConfigBHTEntries = 0;\n\n  localparam CVA6ConfigTvalEn = 1;\n\n  localparam CVA6ConfigNrPMPEntries = 8;\n\n  localparam CVA6ConfigPerfCounterEn = 0;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::WT;\n\n  localparam CVA6ConfigMmuPresent = 1;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(1),\n      RVU: bit'(1),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: bit'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_AXI4_ATOP,\n      // idempotent region\n      NrNonIdempotentRules:\n      unsigned'(\n      2\n      ),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      //                      DRAM,          Boot ROM,   Debug Module\n      ExecuteRegionAddrBase:\n      1024'(\n      {64'h8000_0000, 64'h1_0000, 64'h0}\n      ),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      // cached region\n      NrCachedRegionRules:\n      unsigned'(\n      1\n      ),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(1),\n      AxiBurstWriteEn: bit'(0)\n  };\n\nendpackage\n"}
{"text": "// Copyright 2022 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 32;\n\n  localparam CVA6ConfigFpuEn = 0;\n  localparam CVA6ConfigF16En = 0;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 1;\n  localparam CVA6ConfigCExtEn = 1;\n  localparam CVA6ConfigZcbExtEn = 1;\n  localparam CVA6ConfigAExtEn = 0;\n  localparam CVA6ConfigBExtEn = 1;\n  localparam CVA6ConfigVExtEn = 0;\n  localparam CVA6ConfigZiCondExtEn = 0;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = 32;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = 32;\n\n  localparam CVA6ConfigIcacheByteSize = 2048;\n  localparam CVA6ConfigIcacheSetAssoc = 2;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 32768;\n  localparam CVA6ConfigDcacheSetAssoc = 8;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 1;\n  localparam CVA6ConfigMemTidWidth = 2;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 2;\n\n  localparam CVA6ConfigNrCommitPorts = 1;\n  localparam CVA6ConfigNrScoreboardEntries = 4;\n\n  localparam CVA6ConfigFPGAEn = 0;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 0;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n  localparam CVA6ConfigNrLoadBufEntries = 1;\n\n  localparam CVA6ConfigInstrTlbEntries = 2;\n  localparam CVA6ConfigDataTlbEntries = 2;\n\n  localparam CVA6ConfigRASDepth = 2;\n  localparam CVA6ConfigBTBEntries = 0;\n  localparam CVA6ConfigBHTEntries = 32;\n\n  localparam CVA6ConfigTvalEn = 0;\n\n  localparam CVA6ConfigNrPMPEntries = 8;\n\n  localparam CVA6ConfigPerfCounterEn = 0;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::WT;\n\n  localparam CVA6ConfigMmuPresent = 0;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(0),\n      RVU: bit'(0),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: bit'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_AXI4_ATOP,\n      NrNonIdempotentRules: unsigned'(2),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      ExecuteRegionAddrBase: 1024'({64'h8000_0000, 64'h1_0000, 64'h0}),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      NrCachedRegionRules: unsigned'(1),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(0),\n      AxiBurstWriteEn: bit'(0)\n  };\n\nendpackage\n"}
{"text": "// Copyright 2022 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 32;\n\n  localparam CVA6ConfigFpuEn = 0;\n  localparam CVA6ConfigF16En = 0;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 1;\n  localparam CVA6ConfigCExtEn = 1;\n  localparam CVA6ConfigZcbExtEn = 1;\n  localparam CVA6ConfigAExtEn = 0;\n  localparam CVA6ConfigBExtEn = 1;\n  localparam CVA6ConfigVExtEn = 0;\n  localparam CVA6ConfigZiCondExtEn = 0;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = CVA6ConfigXlen;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = CVA6ConfigXlen;\n\n  localparam CVA6ConfigIcacheByteSize = 16384;\n  localparam CVA6ConfigIcacheSetAssoc = 4;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 32768;\n  localparam CVA6ConfigDcacheSetAssoc = 8;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 1;\n  localparam CVA6ConfigMemTidWidth = 2;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 2;\n\n  localparam CVA6ConfigNrCommitPorts = 1;\n  localparam CVA6ConfigNrScoreboardEntries = 4;\n\n  localparam CVA6ConfigFPGAEn = 0;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 0;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n  localparam CVA6ConfigNrLoadBufEntries = 1;\n\n  localparam CVA6ConfigInstrTlbEntries = 2;\n  localparam CVA6ConfigDataTlbEntries = 2;\n\n  localparam CVA6ConfigRASDepth = 2;\n  localparam CVA6ConfigBTBEntries = 0;\n  localparam CVA6ConfigBHTEntries = 32;\n\n  localparam CVA6ConfigTvalEn = 0;\n\n  localparam CVA6ConfigNrPMPEntries = 8;\n\n  localparam CVA6ConfigPerfCounterEn = 0;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::WT;\n\n  localparam CVA6ConfigMmuPresent = 0;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(0),\n      RVU: bit'(0),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: bit'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_AXI4_ATOP,\n      // idempotent region\n      NrNonIdempotentRules:\n      unsigned'(\n      2\n      ),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      //                      DRAM,          Boot ROM,   Debug Module\n      ExecuteRegionAddrBase:\n      1024'(\n      {64'h8000_0000, 64'h1_0000, 64'h0}\n      ),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      // cached region\n      NrCachedRegionRules:\n      unsigned'(\n      1\n      ),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(0),\n      AxiBurstWriteEn: bit'(0)\n  };\n\nendpackage\n"}
{"text": "// Copyright 2021 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 32;\n\n  localparam CVA6ConfigFpuEn = 0;\n  localparam CVA6ConfigF16En = 0;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 0;\n  localparam CVA6ConfigCExtEn = 1;\n  localparam CVA6ConfigZcbExtEn = 0;\n  localparam CVA6ConfigAExtEn = 1;\n  localparam CVA6ConfigBExtEn = 0;\n  localparam CVA6ConfigVExtEn = 0;\n  localparam CVA6ConfigZiCondExtEn = 0;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = CVA6ConfigXlen;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = CVA6ConfigXlen;\n\n  localparam CVA6ConfigIcacheByteSize = 16384;\n  localparam CVA6ConfigIcacheSetAssoc = 4;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 32768;\n  localparam CVA6ConfigDcacheSetAssoc = 8;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 1;\n  localparam CVA6ConfigMemTidWidth = 2;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 8;\n\n  localparam CVA6ConfigNrCommitPorts = 2;\n  localparam CVA6ConfigNrScoreboardEntries = 8;\n  localparam CVA6ConfigNrLoadBufEntries = 2;\n\n  localparam CVA6ConfigFPGAEn = 0;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 1;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n\n  localparam CVA6ConfigInstrTlbEntries = 2;\n  localparam CVA6ConfigDataTlbEntries = 2;\n\n  localparam CVA6ConfigRASDepth = 2;\n  localparam CVA6ConfigBTBEntries = 32;\n  localparam CVA6ConfigBHTEntries = 128;\n\n  localparam CVA6ConfigTvalEn = 1;\n\n  localparam CVA6ConfigNrPMPEntries = 8;\n\n  localparam CVA6ConfigPerfCounterEn = 1;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::WT;\n\n  localparam CVA6ConfigMmuPresent = 1;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(1),\n      RVU: bit'(1),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: unsigned'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_AXI4_ATOP,\n      NrNonIdempotentRules: unsigned'(2),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      //                      DRAM,          Boot ROM,   Debug Module\n      ExecuteRegionAddrBase:\n      1024'(\n      {64'h8000_0000, 64'h1_0000, 64'h0}\n      ),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      NrCachedRegionRules: unsigned'(1),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(1),\n      AxiBurstWriteEn: bit'(0)\n  };\nendpackage\n"}
{"text": "// Copyright 2021 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 32;\n\n  localparam CVA6ConfigFpuEn = 0;\n  localparam CVA6ConfigF16En = 0;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 0;\n  localparam CVA6ConfigCExtEn = 1;\n  localparam CVA6ConfigZcbExtEn = 0;\n  localparam CVA6ConfigAExtEn = 1;\n  localparam CVA6ConfigBExtEn = 0;\n  localparam CVA6ConfigVExtEn = 0;\n  localparam CVA6ConfigZiCondExtEn = 0;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = CVA6ConfigXlen;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = CVA6ConfigXlen;\n\n  localparam CVA6ConfigIcacheByteSize = 16384;\n  localparam CVA6ConfigIcacheSetAssoc = 4;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 32768;\n  localparam CVA6ConfigDcacheSetAssoc = 8;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 1;\n  localparam CVA6ConfigMemTidWidth = 2;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 8;\n\n  localparam CVA6ConfigNrCommitPorts = 2;\n  localparam CVA6ConfigNrScoreboardEntries = 8;\n\n  localparam CVA6ConfigFPGAEn = 0;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 1;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n  localparam CVA6ConfigNrLoadBufEntries = 2;\n\n  localparam CVA6ConfigInstrTlbEntries = 2;\n  localparam CVA6ConfigDataTlbEntries = 2;\n\n  localparam CVA6ConfigRASDepth = 2;\n  localparam CVA6ConfigBTBEntries = 32;\n  localparam CVA6ConfigBHTEntries = 128;\n\n  localparam CVA6ConfigTvalEn = 1;\n\n  localparam CVA6ConfigNrPMPEntries = 8;\n\n  localparam CVA6ConfigPerfCounterEn = 1;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::WT;\n\n  localparam CVA6ConfigMmuPresent = 1;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(1),\n      RVU: bit'(1),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: bit'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_AXI4_ATOP,\n      // idempotent region\n      NrNonIdempotentRules:\n      unsigned'(\n      2\n      ),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      //                      DRAM,          Boot ROM,   Debug Module\n      ExecuteRegionAddrBase:\n      1024'(\n      {64'h8000_0000, 64'h1_0000, 64'h0}\n      ),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      // cached region\n      NrCachedRegionRules:\n      unsigned'(\n      1\n      ),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(1),\n      AxiBurstWriteEn: bit'(0)\n  };\n\nendpackage\n"}
{"text": "// Copyright 2021 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 32;\n\n  localparam CVA6ConfigFpuEn = 1;\n  localparam CVA6ConfigF16En = 0;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 0;\n  localparam CVA6ConfigCExtEn = 1;\n  localparam CVA6ConfigZcbExtEn = 0;\n  localparam CVA6ConfigAExtEn = 1;\n  localparam CVA6ConfigBExtEn = 0;\n  localparam CVA6ConfigVExtEn = 0;\n  localparam CVA6ConfigZiCondExtEn = 0;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = CVA6ConfigXlen;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = CVA6ConfigXlen;\n\n  localparam CVA6ConfigIcacheByteSize = 16384;\n  localparam CVA6ConfigIcacheSetAssoc = 4;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 32768;\n  localparam CVA6ConfigDcacheSetAssoc = 8;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 1;\n  localparam CVA6ConfigMemTidWidth = 2;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 8;\n\n  localparam CVA6ConfigNrCommitPorts = 2;\n  localparam CVA6ConfigNrScoreboardEntries = 8;\n\n  localparam CVA6ConfigFPGAEn = 0;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 1;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n  localparam CVA6ConfigNrLoadBufEntries = 2;\n\n  localparam CVA6ConfigInstrTlbEntries = 2;\n  localparam CVA6ConfigDataTlbEntries = 2;\n\n  localparam CVA6ConfigRASDepth = 2;\n  localparam CVA6ConfigBTBEntries = 32;\n  localparam CVA6ConfigBHTEntries = 128;\n\n  localparam CVA6ConfigTvalEn = 1;\n\n  localparam CVA6ConfigNrPMPEntries = 8;\n\n  localparam CVA6ConfigPerfCounterEn = 1;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::WB;\n\n  localparam CVA6ConfigMmuPresent = 1;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(1),\n      RVU: bit'(1),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: bit'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_AXI4_ATOP,\n      // idempotent region\n      NrNonIdempotentRules:\n      unsigned'(\n      2\n      ),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      //                      DRAM,          Boot ROM,   Debug Module\n      ExecuteRegionAddrBase:\n      1024'(\n      {64'h8000_0000, 64'h1_0000, 64'h0}\n      ),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      // cached region\n      NrCachedRegionRules:\n      unsigned'(\n      1\n      ),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(1),\n      AxiBurstWriteEn: bit'(0)\n  };\n\nendpackage\n"}
{"text": "// Copyright 2021 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 32;\n\n  localparam CVA6ConfigFpuEn = 0;\n  localparam CVA6ConfigF16En = 0;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 0;\n  localparam CVA6ConfigCExtEn = 0;\n  localparam CVA6ConfigZcbExtEn = 0;\n  localparam CVA6ConfigAExtEn = 1;\n  localparam CVA6ConfigBExtEn = 0;\n  localparam CVA6ConfigVExtEn = 0;\n  localparam CVA6ConfigZiCondExtEn = 0;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = CVA6ConfigXlen;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = CVA6ConfigXlen;\n\n  localparam CVA6ConfigIcacheByteSize = 8192;\n  localparam CVA6ConfigIcacheSetAssoc = 2;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 8192;\n  localparam CVA6ConfigDcacheSetAssoc = 2;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 1;\n  localparam CVA6ConfigMemTidWidth = 2;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 2;\n\n  localparam CVA6ConfigNrCommitPorts = 1;\n  localparam CVA6ConfigNrScoreboardEntries = 4;\n\n  localparam CVA6ConfigFPGAEn = 1;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 1;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n  localparam CVA6ConfigNrLoadBufEntries = 2;\n\n  localparam CVA6ConfigInstrTlbEntries = 2;\n  localparam CVA6ConfigDataTlbEntries = 2;\n\n  localparam CVA6ConfigRASDepth = 2;\n  localparam CVA6ConfigBTBEntries = 32;\n  localparam CVA6ConfigBHTEntries = 128;\n\n  localparam CVA6ConfigTvalEn = 1;\n\n  localparam CVA6ConfigNrPMPEntries = 0;\n\n  localparam CVA6ConfigPerfCounterEn = 0;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::WT;\n\n  localparam CVA6ConfigMmuPresent = 1;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(1),\n      RVU: bit'(1),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: unsigned'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_AXI4_ATOP,\n      // idempotent region\n      NrNonIdempotentRules:\n      unsigned'(\n      2\n      ),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      //                      DRAM,          Boot ROM,   Debug Module\n      ExecuteRegionAddrBase:\n      1024'(\n      {64'h8000_0000, 64'h1_0000, 64'h0}\n      ),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      // cached region\n      NrCachedRegionRules:\n      unsigned'(\n      1\n      ),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(1),\n      AxiBurstWriteEn: bit'(0)\n  };\n\nendpackage\n"}
{"text": "// Copyright 2021 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 64;\n\n  localparam CVA6ConfigFpuEn = 1;\n  localparam CVA6ConfigF16En = 1;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 0;\n  localparam CVA6ConfigCExtEn = 1;\n  localparam CVA6ConfigZcbExtEn = 0;\n  localparam CVA6ConfigAExtEn = 1;\n  localparam CVA6ConfigBExtEn = 0;\n  localparam CVA6ConfigVExtEn = 1;\n  localparam CVA6ConfigZiCondExtEn = 0;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = CVA6ConfigXlen;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = CVA6ConfigXlen;\n\n  localparam CVA6ConfigIcacheByteSize = 16384;\n  localparam CVA6ConfigIcacheSetAssoc = 4;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 32768;\n  localparam CVA6ConfigDcacheSetAssoc = 8;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 1;\n  localparam CVA6ConfigMemTidWidth = 2;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 8;\n\n  localparam CVA6ConfigNrCommitPorts = 2;\n  localparam CVA6ConfigNrScoreboardEntries = 8;\n\n  localparam CVA6ConfigFPGAEn = 0;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 1;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n  localparam CVA6ConfigNrLoadBufEntries = 2;\n\n  localparam CVA6ConfigInstrTlbEntries = 16;\n  localparam CVA6ConfigDataTlbEntries = 16;\n\n  localparam CVA6ConfigRASDepth = 2;\n  localparam CVA6ConfigBTBEntries = 32;\n  localparam CVA6ConfigBHTEntries = 128;\n\n  localparam CVA6ConfigTvalEn = 1;\n\n  localparam CVA6ConfigNrPMPEntries = 8;\n\n  localparam CVA6ConfigPerfCounterEn = 1;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::WT;\n\n  localparam CVA6ConfigMmuPresent = 1;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(1),\n      RVU: bit'(1),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: bit'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_L15_BIG_ENDIAN,\n      // idempotent region\n      NrNonIdempotentRules:\n      unsigned'(\n      2\n      ),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      //                      DRAM,          Boot ROM,   Debug Module\n      ExecuteRegionAddrBase:\n      1024'(\n      {64'h8000_0000, 64'h1_0000, 64'h0}\n      ),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      // cached region\n      NrCachedRegionRules:\n      unsigned'(\n      1\n      ),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(1),\n      AxiBurstWriteEn: bit'(0)\n  };\n\nendpackage\n"}
{"text": "// Copyright 2021 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 64;\n\n  localparam CVA6ConfigFpuEn = 1;\n  localparam CVA6ConfigF16En = 0;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 0;\n  localparam CVA6ConfigCExtEn = 1;\n  localparam CVA6ConfigZcbExtEn = 0;\n  localparam CVA6ConfigAExtEn = 1;\n  localparam CVA6ConfigBExtEn = 0;\n  localparam CVA6ConfigVExtEn = 1;\n  localparam CVA6ConfigZiCondExtEn = 0;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = CVA6ConfigXlen;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = CVA6ConfigXlen;\n\n  localparam CVA6ConfigIcacheByteSize = 16384;\n  localparam CVA6ConfigIcacheSetAssoc = 4;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 16384;\n  localparam CVA6ConfigDcacheSetAssoc = 4;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 1;\n  localparam CVA6ConfigMemTidWidth = 2;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 8;\n\n  localparam CVA6ConfigNrCommitPorts = 1;\n  localparam CVA6ConfigNrScoreboardEntries = 8;\n\n  localparam CVA6ConfigFPGAEn = 0;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 1;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n  localparam CVA6ConfigNrLoadBufEntries = 2;\n\n  localparam CVA6ConfigInstrTlbEntries = 16;\n  localparam CVA6ConfigDataTlbEntries = 16;\n\n  localparam CVA6ConfigRASDepth = 2;\n  localparam CVA6ConfigBTBEntries = 32;\n  localparam CVA6ConfigBHTEntries = 128;\n\n  localparam CVA6ConfigTvalEn = 1;\n\n  localparam CVA6ConfigNrPMPEntries = 8;\n\n  localparam CVA6ConfigPerfCounterEn = 1;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::WT;\n\n  localparam CVA6ConfigMmuPresent = 1;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(1),\n      RVU: bit'(1),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: bit'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_AXI4_ATOP,\n      // idempotent region\n      NrNonIdempotentRules:\n      unsigned'(\n      2\n      ),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      //                      DRAM,          Boot ROM,   Debug Module\n      ExecuteRegionAddrBase:\n      1024'(\n      {64'h8000_0000, 64'h1_0000, 64'h0}\n      ),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      // cached region\n      NrCachedRegionRules:\n      unsigned'(\n      1\n      ),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(1),\n      AxiBurstWriteEn: bit'(0)\n  };\nendpackage\n"}
{"text": "// Copyright 2021 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 64;\n\n  localparam CVA6ConfigFpuEn = 1;\n  localparam CVA6ConfigF16En = 0;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 1;\n  localparam CVA6ConfigCExtEn = 1;\n  localparam CVA6ConfigZcbExtEn = 1;\n  localparam CVA6ConfigAExtEn = 1;\n  localparam CVA6ConfigBExtEn = 1;\n  localparam CVA6ConfigVExtEn = 0;\n  localparam CVA6ConfigZiCondExtEn = 1;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = CVA6ConfigXlen;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = CVA6ConfigXlen;\n\n  localparam CVA6ConfigIcacheByteSize = 16384;\n  localparam CVA6ConfigIcacheSetAssoc = 4;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 32768;\n  localparam CVA6ConfigDcacheSetAssoc = 8;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 1;\n  localparam CVA6ConfigMemTidWidth = 2;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 8;\n\n  localparam CVA6ConfigNrCommitPorts = 2;\n  localparam CVA6ConfigNrScoreboardEntries = 8;\n\n  localparam CVA6ConfigFPGAEn = 0;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 1;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n  localparam CVA6ConfigNrLoadBufEntries = 2;\n\n  localparam CVA6ConfigInstrTlbEntries = 16;\n  localparam CVA6ConfigDataTlbEntries = 16;\n\n  localparam CVA6ConfigRASDepth = 2;\n  localparam CVA6ConfigBTBEntries = 32;\n  localparam CVA6ConfigBHTEntries = 128;\n\n  localparam CVA6ConfigTvalEn = 1;\n\n  localparam CVA6ConfigNrPMPEntries = 8;\n\n  localparam CVA6ConfigPerfCounterEn = 1;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::WT;\n\n  localparam CVA6ConfigMmuPresent = 1;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(1),\n      RVU: bit'(1),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: bit'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_AXI4_ATOP,\n      // idempotent region\n      NrNonIdempotentRules:\n      unsigned'(\n      2\n      ),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      //                      DRAM,          Boot ROM,   Debug Module\n      ExecuteRegionAddrBase:\n      1024'(\n      {64'h8000_0000, 64'h1_0000, 64'h0}\n      ),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      // cached region\n      NrCachedRegionRules:\n      unsigned'(\n      1\n      ),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(1),\n      AxiBurstWriteEn: bit'(0)\n  };\n\nendpackage\n"}
{"text": "// Copyright 2021 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n//\n// Copyright 2023 Commissariat a l'Energie Atomique et aux Energies\n//                Alternatives (CEA)\n//\n// Author: Cesar Fuguet - CEA\n// Date: August, 2023\n// Description: CVA6 configuration package using the HPDcache as cache subsystem\n\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 64;\n\n  localparam CVA6ConfigFpuEn = 1;\n  localparam CVA6ConfigF16En = 0;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 1;\n  localparam CVA6ConfigCExtEn = 1;\n  localparam CVA6ConfigZcbExtEn = 1;\n  localparam CVA6ConfigAExtEn = 1;\n  localparam CVA6ConfigBExtEn = 1;\n  localparam CVA6ConfigVExtEn = 0;\n  localparam CVA6ConfigZiCondExtEn = 1;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = CVA6ConfigXlen;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = CVA6ConfigXlen;\n\n  localparam CVA6ConfigIcacheByteSize = 16384;\n  localparam CVA6ConfigIcacheSetAssoc = 4;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 32768;\n  localparam CVA6ConfigDcacheSetAssoc = 8;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 3;\n  localparam CVA6ConfigMemTidWidth = CVA6ConfigAxiIdWidth;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 8;\n\n  localparam CVA6ConfigNrCommitPorts = 2;\n  localparam CVA6ConfigNrScoreboardEntries = 8;\n\n  localparam CVA6ConfigFPGAEn = 0;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 1;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n  localparam CVA6ConfigNrLoadBufEntries = 8;\n\n  localparam CVA6ConfigInstrTlbEntries = 16;\n  localparam CVA6ConfigDataTlbEntries = 16;\n\n  localparam CVA6ConfigRASDepth = 2;\n  localparam CVA6ConfigBTBEntries = 32;\n  localparam CVA6ConfigBHTEntries = 128;\n\n  localparam CVA6ConfigTvalEn = 1;\n\n  localparam CVA6ConfigNrPMPEntries = 8;\n\n  localparam CVA6ConfigPerfCounterEn = 1;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::HPDCACHE;\n\n  localparam CVA6ConfigMmuPresent = 1;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(1),\n      RVU: bit'(1),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: bit'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_AXI4_ATOP,\n      // idempotent region\n      NrNonIdempotentRules:\n      unsigned'(\n      2\n      ),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      //                      DRAM,          Boot ROM,   Debug Module\n      ExecuteRegionAddrBase:\n      1024'(\n      {64'h8000_0000, 64'h1_0000, 64'h0}\n      ),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      // cached region\n      NrCachedRegionRules:\n      unsigned'(\n      1\n      ),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(1),\n      AxiBurstWriteEn: bit'(0)\n  };\n\nendpackage\n"}
{"text": "// Copyright 2021 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 64;\n\n  localparam CVA6ConfigFpuEn = 1;\n  localparam CVA6ConfigF16En = 0;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 0;\n  localparam CVA6ConfigCExtEn = 1;\n  localparam CVA6ConfigZcbExtEn = 0;\n  localparam CVA6ConfigAExtEn = 1;\n  localparam CVA6ConfigBExtEn = 0;\n  localparam CVA6ConfigVExtEn = 0;\n  localparam CVA6ConfigZiCondExtEn = 0;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = CVA6ConfigXlen;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = CVA6ConfigXlen;\n\n  localparam CVA6ConfigIcacheByteSize = 16384;\n  localparam CVA6ConfigIcacheSetAssoc = 4;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 32768;\n  localparam CVA6ConfigDcacheSetAssoc = 8;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 1;\n  localparam CVA6ConfigMemTidWidth = 2;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 8;\n\n  localparam CVA6ConfigNrCommitPorts = 2;\n  localparam CVA6ConfigNrScoreboardEntries = 8;\n\n  localparam CVA6ConfigFPGAEn = 0;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 1;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n  localparam CVA6ConfigNrLoadBufEntries = 2;\n\n  localparam CVA6ConfigInstrTlbEntries = 16;\n  localparam CVA6ConfigDataTlbEntries = 16;\n\n  localparam CVA6ConfigRASDepth = 2;\n  localparam CVA6ConfigBTBEntries = 32;\n  localparam CVA6ConfigBHTEntries = 128;\n\n  localparam CVA6ConfigTvalEn = 1;\n\n  localparam CVA6ConfigNrPMPEntries = 8;\n\n  localparam CVA6ConfigPerfCounterEn = 1;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::WT;\n\n  localparam CVA6ConfigMmuPresent = 1;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(1),\n      RVU: bit'(1),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: bit'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_L15_BIG_ENDIAN,\n      // idempotent region\n      NrNonIdempotentRules:\n      unsigned'(\n      2\n      ),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      //                      DRAM,          Boot ROM,   Debug Module\n      ExecuteRegionAddrBase:\n      1024'(\n      {64'h8000_0000, 64'h1_0000, 64'h0}\n      ),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      // cached region\n      NrCachedRegionRules:\n      unsigned'(\n      1\n      ),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(1),\n      AxiBurstWriteEn: bit'(0)\n  };\n\nendpackage\n"}
{"text": "// Copyright 2021 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\n\npackage cva6_config_pkg;\n\n  localparam CVA6ConfigXlen = 64;\n\n  localparam CVA6ConfigFpuEn = 1;\n  localparam CVA6ConfigF16En = 0;\n  localparam CVA6ConfigF16AltEn = 0;\n  localparam CVA6ConfigF8En = 0;\n  localparam CVA6ConfigFVecEn = 0;\n\n  localparam CVA6ConfigCvxifEn = 1;\n  localparam CVA6ConfigCExtEn = 1;\n  localparam CVA6ConfigZcbExtEn = 1;\n  localparam CVA6ConfigAExtEn = 1;\n  localparam CVA6ConfigBExtEn = 1;\n  localparam CVA6ConfigVExtEn = 0;\n  localparam CVA6ConfigZiCondExtEn = 1;\n\n  localparam CVA6ConfigAxiIdWidth = 4;\n  localparam CVA6ConfigAxiAddrWidth = 64;\n  localparam CVA6ConfigAxiDataWidth = 64;\n  localparam CVA6ConfigFetchUserEn = 0;\n  localparam CVA6ConfigFetchUserWidth = CVA6ConfigXlen;\n  localparam CVA6ConfigDataUserEn = 0;\n  localparam CVA6ConfigDataUserWidth = CVA6ConfigXlen;\n\n  localparam CVA6ConfigIcacheByteSize = 16384;\n  localparam CVA6ConfigIcacheSetAssoc = 4;\n  localparam CVA6ConfigIcacheLineWidth = 128;\n  localparam CVA6ConfigDcacheByteSize = 32768;\n  localparam CVA6ConfigDcacheSetAssoc = 8;\n  localparam CVA6ConfigDcacheLineWidth = 128;\n\n  localparam CVA6ConfigDcacheIdWidth = 1;\n  localparam CVA6ConfigMemTidWidth = 2;\n\n  localparam CVA6ConfigWtDcacheWbufDepth = 8;\n\n  localparam CVA6ConfigNrCommitPorts = 2;\n  localparam CVA6ConfigNrScoreboardEntries = 8;\n\n  localparam CVA6ConfigFPGAEn = 0;\n\n  localparam CVA6ConfigNrLoadPipeRegs = 1;\n  localparam CVA6ConfigNrStorePipeRegs = 0;\n  localparam CVA6ConfigNrLoadBufEntries = 2;\n\n  localparam CVA6ConfigInstrTlbEntries = 16;\n  localparam CVA6ConfigDataTlbEntries = 16;\n\n  localparam CVA6ConfigRASDepth = 2;\n  localparam CVA6ConfigBTBEntries = 32;\n  localparam CVA6ConfigBHTEntries = 128;\n\n  localparam CVA6ConfigTvalEn = 1;\n\n  localparam CVA6ConfigNrPMPEntries = 8;\n\n  localparam CVA6ConfigPerfCounterEn = 1;\n\n  localparam config_pkg::cache_type_t CVA6ConfigDcacheType = config_pkg::WB;\n\n  localparam CVA6ConfigMmuPresent = 1;\n\n  localparam CVA6ConfigRvfiTrace = 1;\n\n  localparam config_pkg::cva6_user_cfg_t cva6_cfg = '{\n      NrCommitPorts: unsigned'(CVA6ConfigNrCommitPorts),\n      AxiAddrWidth: unsigned'(CVA6ConfigAxiAddrWidth),\n      AxiDataWidth: unsigned'(CVA6ConfigAxiDataWidth),\n      AxiIdWidth: unsigned'(CVA6ConfigAxiIdWidth),\n      AxiUserWidth: unsigned'(CVA6ConfigDataUserWidth),\n      NrLoadBufEntries: unsigned'(CVA6ConfigNrLoadBufEntries),\n      FpuEn: bit'(CVA6ConfigFpuEn),\n      XF16: bit'(CVA6ConfigF16En),\n      XF16ALT: bit'(CVA6ConfigF16AltEn),\n      XF8: bit'(CVA6ConfigF8En),\n      RVA: bit'(CVA6ConfigAExtEn),\n      RVB: bit'(CVA6ConfigBExtEn),\n      RVV: bit'(CVA6ConfigVExtEn),\n      RVC: bit'(CVA6ConfigCExtEn),\n      RVZCB: bit'(CVA6ConfigZcbExtEn),\n      XFVec: bit'(CVA6ConfigFVecEn),\n      CvxifEn: bit'(CVA6ConfigCvxifEn),\n      ZiCondExtEn: bit'(CVA6ConfigZiCondExtEn),\n      RVS: bit'(1),\n      RVU: bit'(1),\n      HaltAddress: 64'h800,\n      ExceptionAddress: 64'h808,\n      RASDepth: unsigned'(CVA6ConfigRASDepth),\n      BTBEntries: unsigned'(CVA6ConfigBTBEntries),\n      BHTEntries: unsigned'(CVA6ConfigBHTEntries),\n      DmBaseAddress: 64'h0,\n      TvalEn: bit'(CVA6ConfigTvalEn),\n      NrPMPEntries: unsigned'(CVA6ConfigNrPMPEntries),\n      PMPCfgRstVal: {16{64'h0}},\n      PMPAddrRstVal: {16{64'h0}},\n      PMPEntryReadOnly: 16'd0,\n      NOCType: config_pkg::NOC_TYPE_AXI4_ATOP,\n      // idempotent region\n      NrNonIdempotentRules:\n      unsigned'(\n      2\n      ),\n      NonIdempotentAddrBase: 1024'({64'b0, 64'b0}),\n      NonIdempotentLength: 1024'({64'b0, 64'b0}),\n      NrExecuteRegionRules: unsigned'(3),\n      //                      DRAM,          Boot ROM,   Debug Module\n      ExecuteRegionAddrBase:\n      1024'(\n      {64'h8000_0000, 64'h1_0000, 64'h0}\n      ),\n      ExecuteRegionLength: 1024'({64'h40000000, 64'h10000, 64'h1000}),\n      // cached region\n      NrCachedRegionRules:\n      unsigned'(\n      1\n      ),\n      CachedRegionAddrBase: 1024'({64'h8000_0000}),\n      CachedRegionLength: 1024'({64'h40000000}),\n      MaxOutstandingStores: unsigned'(7),\n      DebugEn: bit'(1),\n      AxiBurstWriteEn: bit'(0)\n  };\n\nendpackage\n"}
{"text": "// Copyright 2017-2019 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 19.03.2017\n// Description: CVA6 Top-level module\n\n\nmodule cva6\n  import ariane_pkg::*;\n#(\n    // CVA6 config\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = build_config_pkg::build_config(\n        cva6_config_pkg::cva6_cfg\n    ),\n\n    parameter type rvfi_probes_t = struct packed {\n      logic csr;  //disabled \n      rvfi_probes_instr_t instr;\n    },\n\n    // AXI types\n    parameter type axi_ar_chan_t = struct packed {\n      logic [CVA6Cfg.AxiIdWidth-1:0]   id;\n      logic [CVA6Cfg.AxiAddrWidth-1:0] addr;\n      axi_pkg::len_t                   len;\n      axi_pkg::size_t                  size;\n      axi_pkg::burst_t                 burst;\n      logic                            lock;\n      axi_pkg::cache_t                 cache;\n      axi_pkg::prot_t                  prot;\n      axi_pkg::qos_t                   qos;\n      axi_pkg::region_t                region;\n      logic [CVA6Cfg.AxiUserWidth-1:0] user;\n    },\n    parameter type axi_aw_chan_t = struct packed {\n      logic [CVA6Cfg.AxiIdWidth-1:0]   id;\n      logic [CVA6Cfg.AxiAddrWidth-1:0] addr;\n      axi_pkg::len_t                   len;\n      axi_pkg::size_t                  size;\n      axi_pkg::burst_t                 burst;\n      logic                            lock;\n      axi_pkg::cache_t                 cache;\n      axi_pkg::prot_t                  prot;\n      axi_pkg::qos_t                   qos;\n      axi_pkg::region_t                region;\n      axi_pkg::atop_t                  atop;\n      logic [CVA6Cfg.AxiUserWidth-1:0] user;\n    },\n    parameter type axi_w_chan_t = struct packed {\n      logic [CVA6Cfg.AxiDataWidth-1:0]     data;\n      logic [(CVA6Cfg.AxiDataWidth/8)-1:0] strb;\n      logic                                last;\n      logic [CVA6Cfg.AxiUserWidth-1:0]     user;\n    },\n    parameter type b_chan_t = struct packed {\n      logic [CVA6Cfg.AxiIdWidth-1:0]   id;\n      axi_pkg::resp_t                  resp;\n      logic [CVA6Cfg.AxiUserWidth-1:0] user;\n    },\n    parameter type r_chan_t = struct packed {\n      logic [CVA6Cfg.AxiIdWidth-1:0]   id;\n      logic [CVA6Cfg.AxiDataWidth-1:0] data;\n      axi_pkg::resp_t                  resp;\n      logic                            last;\n      logic [CVA6Cfg.AxiUserWidth-1:0] user;\n    },\n    parameter type noc_req_t = struct packed {\n      axi_aw_chan_t aw;\n      logic         aw_valid;\n      axi_w_chan_t  w;\n      logic         w_valid;\n      logic         b_ready;\n      axi_ar_chan_t ar;\n      logic         ar_valid;\n      logic         r_ready;\n    },\n    parameter type noc_resp_t = struct packed {\n      logic    aw_ready;\n      logic    ar_ready;\n      logic    w_ready;\n      logic    b_valid;\n      b_chan_t b;\n      logic    r_valid;\n      r_chan_t r;\n    },\n    //\n    parameter type acc_cfg_t = logic,\n    parameter acc_cfg_t AccCfg = '0,\n    parameter type cvxif_req_t = cvxif_pkg::cvxif_req_t,\n    parameter type cvxif_resp_t = cvxif_pkg::cvxif_resp_t\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Reset boot address - SUBSYSTEM\n    input logic [riscv::VLEN-1:0] boot_addr_i,\n    // Hard ID reflected as CSR - SUBSYSTEM\n    input logic [riscv::XLEN-1:0] hart_id_i,\n    // Level sensitive (async) interrupts - SUBSYSTEM\n    input logic [1:0] irq_i,\n    // Inter-processor (async) interrupt - SUBSYSTEM\n    input logic ipi_i,\n    // Timer (async) interrupt - SUBSYSTEM\n    input logic time_irq_i,\n    // Debug (async) request - SUBSYSTEM\n    input logic debug_req_i,\n    // Probes to build RVFI, can be left open when not used - RVFI\n    output rvfi_probes_t rvfi_probes_o,\n    // CVXIF request - SUBSYSTEM\n    output cvxif_req_t cvxif_req_o,\n    // CVXIF response - SUBSYSTEM\n    input cvxif_resp_t cvxif_resp_i,\n    // noc request, can be AXI or OpenPiton - SUBSYSTEM\n    output noc_req_t noc_req_o,\n    // noc response, can be AXI or OpenPiton - SUBSYSTEM\n    input noc_resp_t noc_resp_i\n);\n\n  // ------------------------------------------\n  // Global Signals\n  // Signals connecting more than one module\n  // ------------------------------------------\n  riscv::priv_lvl_t                             priv_lvl;\n  exception_t                                   ex_commit;  // exception from commit stage\n  bp_resolve_t                                  resolved_branch;\n  logic             [          riscv::VLEN-1:0] pc_commit;\n  logic                                         eret;\n  logic             [CVA6Cfg.NrCommitPorts-1:0] commit_ack;\n\n  localparam NumPorts = 4;\n  cvxif_pkg::cvxif_req_t cvxif_req;\n  cvxif_pkg::cvxif_resp_t cvxif_resp;\n\n  // --------------\n  // PCGEN <-> CSR\n  // --------------\n  logic [riscv::VLEN-1:0] trap_vector_base_commit_pcgen;\n  logic [riscv::VLEN-1:0] epc_commit_pcgen;\n  // --------------\n  // IF <-> ID\n  // --------------\n  fetch_entry_t fetch_entry_if_id;\n  logic fetch_valid_if_id;\n  logic fetch_ready_id_if;\n\n  // --------------\n  // ID <-> ISSUE\n  // --------------\n  scoreboard_entry_t issue_entry_id_issue;\n  logic [31:0] orig_instr_id_issue;\n  logic issue_entry_valid_id_issue;\n  logic is_ctrl_fow_id_issue;\n  logic issue_instr_issue_id;\n\n  // --------------\n  // ISSUE <-> EX\n  // --------------\n  logic [riscv::VLEN-1:0] rs1_forwarding_id_ex;  // unregistered version of fu_data_o.operanda\n  logic [riscv::VLEN-1:0] rs2_forwarding_id_ex;  // unregistered version of fu_data_o.operandb\n\n  fu_data_t fu_data_id_ex;\n  logic [riscv::VLEN-1:0] pc_id_ex;\n  logic is_compressed_instr_id_ex;\n  // fixed latency units\n  logic flu_ready_ex_id;\n  logic [TRANS_ID_BITS-1:0] flu_trans_id_ex_id;\n  logic flu_valid_ex_id;\n  riscv::xlen_t flu_result_ex_id;\n  exception_t flu_exception_ex_id;\n  // ALU\n  logic alu_valid_id_ex;\n  // Branches and Jumps\n  logic branch_valid_id_ex;\n\n  branchpredict_sbe_t branch_predict_id_ex;\n  logic resolve_branch_ex_id;\n  // LSU\n  logic lsu_valid_id_ex;\n  logic lsu_ready_ex_id;\n\n  logic [TRANS_ID_BITS-1:0] load_trans_id_ex_id;\n  riscv::xlen_t load_result_ex_id;\n  logic load_valid_ex_id;\n  exception_t load_exception_ex_id;\n\n  riscv::xlen_t store_result_ex_id;\n  logic [TRANS_ID_BITS-1:0] store_trans_id_ex_id;\n  logic store_valid_ex_id;\n  exception_t store_exception_ex_id;\n  // MULT\n  logic mult_valid_id_ex;\n  // FPU\n  logic fpu_ready_ex_id;\n  logic fpu_valid_id_ex;\n  logic [1:0] fpu_fmt_id_ex;\n  logic [2:0] fpu_rm_id_ex;\n  logic [TRANS_ID_BITS-1:0] fpu_trans_id_ex_id;\n  riscv::xlen_t fpu_result_ex_id;\n  logic fpu_valid_ex_id;\n  exception_t fpu_exception_ex_id;\n  // Accelerator\n  logic stall_acc_id;\n  scoreboard_entry_t issue_instr_id_acc;\n  logic issue_instr_hs_id_acc;\n  logic [TRANS_ID_BITS-1:0] acc_trans_id_ex_id;\n  riscv::xlen_t acc_result_ex_id;\n  logic acc_valid_ex_id;\n  exception_t acc_exception_ex_id;\n  logic halt_acc_ctrl;\n  logic [4:0] acc_resp_fflags;\n  logic acc_resp_fflags_valid;\n  // CSR\n  logic csr_valid_id_ex;\n  // CVXIF\n  logic [TRANS_ID_BITS-1:0] x_trans_id_ex_id;\n  riscv::xlen_t x_result_ex_id;\n  logic x_valid_ex_id;\n  exception_t x_exception_ex_id;\n  logic x_we_ex_id;\n  logic x_issue_valid_id_ex;\n  logic x_issue_ready_ex_id;\n  logic [31:0] x_off_instr_id_ex;\n  // --------------\n  // EX <-> COMMIT\n  // --------------\n  // CSR Commit\n  logic csr_commit_commit_ex;\n  logic dirty_fp_state;\n  logic dirty_v_state;\n  // LSU Commit\n  logic lsu_commit_commit_ex;\n  logic lsu_commit_ready_ex_commit;\n  logic [TRANS_ID_BITS-1:0] lsu_commit_trans_id;\n  logic stall_st_pending_ex;\n  logic no_st_pending_ex;\n  logic no_st_pending_commit;\n  logic amo_valid_commit;\n  // ACCEL Commit\n  logic acc_valid_acc_ex;\n  // --------------\n  // ID <-> COMMIT\n  // --------------\n  scoreboard_entry_t [CVA6Cfg.NrCommitPorts-1:0] commit_instr_id_commit;\n  // --------------\n  // RVFI\n  // --------------\n  logic [TRANS_ID_BITS-1:0] rvfi_issue_pointer;\n  logic [CVA6Cfg.NrCommitPorts-1:0][TRANS_ID_BITS-1:0] rvfi_commit_pointer;\n  // --------------\n  // COMMIT <-> ID\n  // --------------\n  logic [CVA6Cfg.NrCommitPorts-1:0][4:0] waddr_commit_id;\n  logic [CVA6Cfg.NrCommitPorts-1:0][riscv::XLEN-1:0] wdata_commit_id;\n  logic [CVA6Cfg.NrCommitPorts-1:0] we_gpr_commit_id;\n  logic [CVA6Cfg.NrCommitPorts-1:0] we_fpr_commit_id;\n  // --------------\n  // CSR <-> *\n  // --------------\n  logic [4:0] fflags_csr_commit;\n  riscv::xs_t fs;\n  logic [2:0] frm_csr_id_issue_ex;\n  logic [6:0] fprec_csr_ex;\n  riscv::xs_t vs;\n  logic enable_translation_csr_ex;\n  logic en_ld_st_translation_csr_ex;\n  riscv::priv_lvl_t ld_st_priv_lvl_csr_ex;\n  logic sum_csr_ex;\n  logic mxr_csr_ex;\n  logic [riscv::PPNW-1:0] satp_ppn_csr_ex;\n  logic [ASID_WIDTH-1:0] asid_csr_ex;\n  logic [11:0] csr_addr_ex_csr;\n  fu_op csr_op_commit_csr;\n  riscv::xlen_t csr_wdata_commit_csr;\n  riscv::xlen_t csr_rdata_csr_commit;\n  exception_t csr_exception_csr_commit;\n  logic tvm_csr_id;\n  logic tw_csr_id;\n  logic tsr_csr_id;\n  irq_ctrl_t irq_ctrl_csr_id;\n  logic dcache_en_csr_nbdcache;\n  logic csr_write_fflags_commit_cs;\n  logic icache_en_csr;\n  logic acc_cons_en_csr;\n  logic debug_mode;\n  logic single_step_csr_commit;\n  riscv::pmpcfg_t [15:0] pmpcfg;\n  logic [15:0][riscv::PLEN-3:0] pmpaddr;\n  logic [31:0] mcountinhibit_csr_perf;\n  // ----------------------------\n  // Performance Counters <-> *\n  // ----------------------------\n  logic [11:0] addr_csr_perf;\n  riscv::xlen_t data_csr_perf, data_perf_csr;\n  logic                                                     we_csr_perf;\n\n  logic                                                     icache_flush_ctrl_cache;\n  logic                                                     itlb_miss_ex_perf;\n  logic                                                     dtlb_miss_ex_perf;\n  logic                                                     dcache_miss_cache_perf;\n  logic                                                     icache_miss_cache_perf;\n  logic             [   NumPorts-1:0][DCACHE_SET_ASSOC-1:0] miss_vld_bits;\n  logic                                                     stall_issue;\n  // --------------\n  // CTRL <-> *\n  // --------------\n  logic                                                     set_pc_ctrl_pcgen;\n  logic                                                     flush_csr_ctrl;\n  logic                                                     flush_unissued_instr_ctrl_id;\n  logic                                                     flush_ctrl_if;\n  logic                                                     flush_ctrl_id;\n  logic                                                     flush_ctrl_ex;\n  logic                                                     flush_ctrl_bp;\n  logic                                                     flush_tlb_ctrl_ex;\n  logic                                                     fence_i_commit_controller;\n  logic                                                     fence_commit_controller;\n  logic                                                     sfence_vma_commit_controller;\n  logic                                                     halt_ctrl;\n  logic                                                     halt_csr_ctrl;\n  logic                                                     dcache_flush_ctrl_cache;\n  logic                                                     dcache_flush_ack_cache_ctrl;\n  logic                                                     set_debug_pc;\n  logic                                                     flush_commit;\n  logic                                                     flush_acc;\n\n  icache_areq_t                                             icache_areq_ex_cache;\n  icache_arsp_t                                             icache_areq_cache_ex;\n  icache_dreq_t                                             icache_dreq_if_cache;\n  icache_drsp_t                                             icache_dreq_cache_if;\n\n  amo_req_t                                                 amo_req;\n  amo_resp_t                                                amo_resp;\n  logic                                                     sb_full;\n\n  // ----------------\n  // DCache <-> *\n  // ----------------\n  dcache_req_i_t    [            2:0]                       dcache_req_ports_ex_cache;\n  dcache_req_o_t    [            2:0]                       dcache_req_ports_cache_ex;\n  dcache_req_i_t    [            1:0]                       dcache_req_ports_acc_cache;\n  dcache_req_o_t    [            1:0]                       dcache_req_ports_cache_acc;\n  logic                                                     dcache_commit_wbuffer_empty;\n  logic                                                     dcache_commit_wbuffer_not_ni;\n\n  //RVFI\n  lsu_ctrl_t                                                rvfi_lsu_ctrl;\n  logic             [riscv::PLEN-1:0]                       rvfi_mem_paddr;\n  logic                                                     rvfi_is_compressed;\n  rvfi_probes_csr_t                                         rvfi_csr;\n\n  // Accelerator port\n  logic             [           63:0]                       inval_addr;\n  logic                                                     inval_valid;\n  logic                                                     inval_ready;\n\n  // --------------\n  // Frontend\n  // --------------\n  frontend #(\n      .CVA6Cfg(CVA6Cfg)\n  ) i_frontend (\n      .flush_i            (flush_ctrl_if),                  // not entirely correct\n      .flush_bp_i         (1'b0),\n      .halt_i             (halt_ctrl),\n      .debug_mode_i       (debug_mode),\n      .boot_addr_i        (boot_addr_i[riscv::VLEN-1:0]),\n      .icache_dreq_i      (icache_dreq_cache_if),\n      .icache_dreq_o      (icache_dreq_if_cache),\n      .resolved_branch_i  (resolved_branch),\n      .pc_commit_i        (pc_commit),\n      .set_pc_commit_i    (set_pc_ctrl_pcgen),\n      .set_debug_pc_i     (set_debug_pc),\n      .epc_i              (epc_commit_pcgen),\n      .eret_i             (eret),\n      .trap_vector_base_i (trap_vector_base_commit_pcgen),\n      .ex_valid_i         (ex_commit.valid),\n      .fetch_entry_o      (fetch_entry_if_id),\n      .fetch_entry_valid_o(fetch_valid_if_id),\n      .fetch_entry_ready_i(fetch_ready_id_if),\n      .*\n  );\n\n  // ---------\n  // ID\n  // ---------\n  id_stage #(\n      .CVA6Cfg(CVA6Cfg)\n  ) id_stage_i (\n      .clk_i,\n      .rst_ni,\n      .flush_i(flush_ctrl_if),\n      .debug_req_i,\n\n      .fetch_entry_i      (fetch_entry_if_id),\n      .fetch_entry_valid_i(fetch_valid_if_id),\n      .fetch_entry_ready_o(fetch_ready_id_if),\n\n      .issue_entry_o      (issue_entry_id_issue),\n      .orig_instr_o       (orig_instr_id_issue),\n      .issue_entry_valid_o(issue_entry_valid_id_issue),\n      .is_ctrl_flow_o     (is_ctrl_fow_id_issue),\n      .issue_instr_ack_i  (issue_instr_issue_id),\n\n      .rvfi_is_compressed_o(rvfi_is_compressed),\n\n      .priv_lvl_i  (priv_lvl),\n      .fs_i        (fs),\n      .frm_i       (frm_csr_id_issue_ex),\n      .vs_i        (vs),\n      .irq_i       (irq_i),\n      .irq_ctrl_i  (irq_ctrl_csr_id),\n      .debug_mode_i(debug_mode),\n      .tvm_i       (tvm_csr_id),\n      .tw_i        (tw_csr_id),\n      .tsr_i       (tsr_csr_id)\n  );\n\n  logic [CVA6Cfg.NrWbPorts-1:0][TRANS_ID_BITS-1:0] trans_id_ex_id;\n  logic [CVA6Cfg.NrWbPorts-1:0][riscv::XLEN-1:0] wbdata_ex_id;\n  exception_t [CVA6Cfg.NrWbPorts-1:0] ex_ex_ex_id;  // exception from execute, ex_stage to id_stage\n  logic [CVA6Cfg.NrWbPorts-1:0] wt_valid_ex_id;\n\n  if (CVA6Cfg.CvxifEn) begin\n    assign trans_id_ex_id = {\n      x_trans_id_ex_id,\n      flu_trans_id_ex_id,\n      load_trans_id_ex_id,\n      store_trans_id_ex_id,\n      fpu_trans_id_ex_id\n    };\n    assign wbdata_ex_id = {\n      x_result_ex_id, flu_result_ex_id, load_result_ex_id, store_result_ex_id, fpu_result_ex_id\n    };\n    assign ex_ex_ex_id = {\n      x_exception_ex_id,\n      flu_exception_ex_id,\n      load_exception_ex_id,\n      store_exception_ex_id,\n      fpu_exception_ex_id\n    };\n    assign wt_valid_ex_id = {\n      x_valid_ex_id, flu_valid_ex_id, load_valid_ex_id, store_valid_ex_id, fpu_valid_ex_id\n    };\n  end else if (CVA6Cfg.EnableAccelerator) begin\n    assign trans_id_ex_id = {\n      flu_trans_id_ex_id,\n      load_trans_id_ex_id,\n      store_trans_id_ex_id,\n      fpu_trans_id_ex_id,\n      acc_trans_id_ex_id\n    };\n    assign wbdata_ex_id = {\n      flu_result_ex_id, load_result_ex_id, store_result_ex_id, fpu_result_ex_id, acc_result_ex_id\n    };\n    assign ex_ex_ex_id = {\n      flu_exception_ex_id,\n      load_exception_ex_id,\n      store_exception_ex_id,\n      fpu_exception_ex_id,\n      acc_exception_ex_id\n    };\n    assign wt_valid_ex_id = {\n      flu_valid_ex_id, load_valid_ex_id, store_valid_ex_id, fpu_valid_ex_id, acc_valid_ex_id\n    };\n  end else begin\n    assign trans_id_ex_id = {\n      flu_trans_id_ex_id, load_trans_id_ex_id, store_trans_id_ex_id, fpu_trans_id_ex_id\n    };\n    assign wbdata_ex_id = {\n      flu_result_ex_id, load_result_ex_id, store_result_ex_id, fpu_result_ex_id\n    };\n    assign ex_ex_ex_id = {\n      flu_exception_ex_id, load_exception_ex_id, store_exception_ex_id, fpu_exception_ex_id\n    };\n    assign wt_valid_ex_id = {flu_valid_ex_id, load_valid_ex_id, store_valid_ex_id, fpu_valid_ex_id};\n  end\n\n  if (CVA6Cfg.CvxifEn && CVA6Cfg.EnableAccelerator) begin : gen_err_xif_and_acc\n    $error(\"X-interface and accelerator port cannot be enabled at the same time.\");\n  end\n\n  // ---------\n  // Issue\n  // ---------\n  issue_stage #(\n      .CVA6Cfg(CVA6Cfg)\n  ) issue_stage_i (\n      .clk_i,\n      .rst_ni,\n      .sb_full_o             (sb_full),\n      .flush_unissued_instr_i(flush_unissued_instr_ctrl_id),\n      .flush_i               (flush_ctrl_id),\n      .stall_i               (stall_acc_id),\n      // ID Stage\n      .decoded_instr_i       (issue_entry_id_issue),\n      .orig_instr_i          (orig_instr_id_issue),\n      .decoded_instr_valid_i (issue_entry_valid_id_issue),\n      .is_ctrl_flow_i        (is_ctrl_fow_id_issue),\n      .decoded_instr_ack_o   (issue_instr_issue_id),\n      // Functional Units\n      .rs1_forwarding_o      (rs1_forwarding_id_ex),\n      .rs2_forwarding_o      (rs2_forwarding_id_ex),\n      .fu_data_o             (fu_data_id_ex),\n      .pc_o                  (pc_id_ex),\n      .is_compressed_instr_o (is_compressed_instr_id_ex),\n      // fixed latency unit ready\n      .flu_ready_i           (flu_ready_ex_id),\n      // ALU\n      .alu_valid_o           (alu_valid_id_ex),\n      // Branches and Jumps\n      .branch_valid_o        (branch_valid_id_ex),            // branch is valid\n      .branch_predict_o      (branch_predict_id_ex),          // branch predict to ex\n      .resolve_branch_i      (resolve_branch_ex_id),          // in order to resolve the branch\n      // LSU\n      .lsu_ready_i           (lsu_ready_ex_id),\n      .lsu_valid_o           (lsu_valid_id_ex),\n      // Multiplier\n      .mult_valid_o          (mult_valid_id_ex),\n      // FPU\n      .fpu_ready_i           (fpu_ready_ex_id),\n      .fpu_valid_o           (fpu_valid_id_ex),\n      .fpu_fmt_o             (fpu_fmt_id_ex),\n      .fpu_rm_o              (fpu_rm_id_ex),\n      // CSR\n      .csr_valid_o           (csr_valid_id_ex),\n      // CVXIF\n      .x_issue_valid_o       (x_issue_valid_id_ex),\n      .x_issue_ready_i       (x_issue_ready_ex_id),\n      .x_off_instr_o         (x_off_instr_id_ex),\n      // Accelerator\n      .issue_instr_o         (issue_instr_id_acc),\n      .issue_instr_hs_o      (is"}
{"text": "sue_instr_hs_id_acc),\n      // Commit\n      .resolved_branch_i     (resolved_branch),\n      .trans_id_i            (trans_id_ex_id),\n      .wbdata_i              (wbdata_ex_id),\n      .ex_ex_i               (ex_ex_ex_id),\n      .wt_valid_i            (wt_valid_ex_id),\n      .x_we_i                (x_we_ex_id),\n\n      .waddr_i              (waddr_commit_id),\n      .wdata_i              (wdata_commit_id),\n      .we_gpr_i             (we_gpr_commit_id),\n      .we_fpr_i             (we_fpr_commit_id),\n      .commit_instr_o       (commit_instr_id_commit),\n      .commit_ack_i         (commit_ack),\n      // Performance Counters\n      .stall_issue_o        (stall_issue),\n      //RVFI\n      .rvfi_issue_pointer_o (rvfi_issue_pointer),\n      .rvfi_commit_pointer_o(rvfi_commit_pointer),\n      .*\n  );\n\n  // ---------\n  // EX\n  // ---------\n  ex_stage #(\n      .CVA6Cfg   (CVA6Cfg),\n      .ASID_WIDTH(ASID_WIDTH)\n  ) ex_stage_i (\n      .clk_i                (clk_i),\n      .rst_ni               (rst_ni),\n      .debug_mode_i         (debug_mode),\n      .flush_i              (flush_ctrl_ex),\n      .rs1_forwarding_i     (rs1_forwarding_id_ex),\n      .rs2_forwarding_i     (rs2_forwarding_id_ex),\n      .fu_data_i            (fu_data_id_ex),\n      .pc_i                 (pc_id_ex),\n      .is_compressed_instr_i(is_compressed_instr_id_ex),\n      // fixed latency units\n      .flu_result_o         (flu_result_ex_id),\n      .flu_trans_id_o       (flu_trans_id_ex_id),\n      .flu_valid_o          (flu_valid_ex_id),\n      .flu_exception_o      (flu_exception_ex_id),\n      .flu_ready_o          (flu_ready_ex_id),\n      // ALU\n      .alu_valid_i          (alu_valid_id_ex),\n      // Branches and Jumps\n      .branch_valid_i       (branch_valid_id_ex),\n      .branch_predict_i     (branch_predict_id_ex),       // branch predict to ex\n      .resolved_branch_o    (resolved_branch),\n      .resolve_branch_o     (resolve_branch_ex_id),\n      // CSR\n      .csr_valid_i          (csr_valid_id_ex),\n      .csr_addr_o           (csr_addr_ex_csr),\n      .csr_commit_i         (csr_commit_commit_ex),       // from commit\n      // MULT\n      .mult_valid_i         (mult_valid_id_ex),\n      // LSU\n      .lsu_ready_o          (lsu_ready_ex_id),\n      .lsu_valid_i          (lsu_valid_id_ex),\n\n      .load_result_o   (load_result_ex_id),\n      .load_trans_id_o (load_trans_id_ex_id),\n      .load_valid_o    (load_valid_ex_id),\n      .load_exception_o(load_exception_ex_id),\n\n      .store_result_o   (store_result_ex_id),\n      .store_trans_id_o (store_trans_id_ex_id),\n      .store_valid_o    (store_valid_ex_id),\n      .store_exception_o(store_exception_ex_id),\n\n      .lsu_commit_i           (lsu_commit_commit_ex),          // from commit\n      .lsu_commit_ready_o     (lsu_commit_ready_ex_commit),    // to commit\n      .commit_tran_id_i       (lsu_commit_trans_id),           // from commit\n      .stall_st_pending_i     (stall_st_pending_ex),\n      .no_st_pending_o        (no_st_pending_ex),\n      // FPU\n      .fpu_ready_o            (fpu_ready_ex_id),\n      .fpu_valid_i            (fpu_valid_id_ex),\n      .fpu_fmt_i              (fpu_fmt_id_ex),\n      .fpu_rm_i               (fpu_rm_id_ex),\n      .fpu_frm_i              (frm_csr_id_issue_ex),\n      .fpu_prec_i             (fprec_csr_ex),\n      .fpu_trans_id_o         (fpu_trans_id_ex_id),\n      .fpu_result_o           (fpu_result_ex_id),\n      .fpu_valid_o            (fpu_valid_ex_id),\n      .fpu_exception_o        (fpu_exception_ex_id),\n      .amo_valid_commit_i     (amo_valid_commit),\n      .amo_req_o              (amo_req),\n      .amo_resp_i             (amo_resp),\n      // CoreV-X-Interface\n      .x_valid_i              (x_issue_valid_id_ex),\n      .x_ready_o              (x_issue_ready_ex_id),\n      .x_off_instr_i          (x_off_instr_id_ex),\n      .x_trans_id_o           (x_trans_id_ex_id),\n      .x_exception_o          (x_exception_ex_id),\n      .x_result_o             (x_result_ex_id),\n      .x_valid_o              (x_valid_ex_id),\n      .x_we_o                 (x_we_ex_id),\n      .cvxif_req_o            (cvxif_req),\n      .cvxif_resp_i           (cvxif_resp),\n      // Accelerator\n      .acc_valid_i            (acc_valid_acc_ex),\n      // Performance counters\n      .itlb_miss_o            (itlb_miss_ex_perf),\n      .dtlb_miss_o            (dtlb_miss_ex_perf),\n      // Memory Management\n      .enable_translation_i   (enable_translation_csr_ex),     // from CSR\n      .en_ld_st_translation_i (en_ld_st_translation_csr_ex),\n      .flush_tlb_i            (flush_tlb_ctrl_ex),\n      .priv_lvl_i             (priv_lvl),                      // from CSR\n      .ld_st_priv_lvl_i       (ld_st_priv_lvl_csr_ex),         // from CSR\n      .sum_i                  (sum_csr_ex),                    // from CSR\n      .mxr_i                  (mxr_csr_ex),                    // from CSR\n      .satp_ppn_i             (satp_ppn_csr_ex),               // from CSR\n      .asid_i                 (asid_csr_ex),                   // from CSR\n      .icache_areq_i          (icache_areq_cache_ex),\n      .icache_areq_o          (icache_areq_ex_cache),\n      // DCACHE interfaces\n      .dcache_req_ports_i     (dcache_req_ports_cache_ex),\n      .dcache_req_ports_o     (dcache_req_ports_ex_cache),\n      .dcache_wbuffer_empty_i (dcache_commit_wbuffer_empty),\n      .dcache_wbuffer_not_ni_i(dcache_commit_wbuffer_not_ni),\n      // PMP\n      .pmpcfg_i               (pmpcfg),\n      .pmpaddr_i              (pmpaddr),\n      //RVFI\n      .rvfi_lsu_ctrl_o        (rvfi_lsu_ctrl),\n      .rvfi_mem_paddr_o       (rvfi_mem_paddr)\n  );\n\n  // ---------\n  // Commit\n  // ---------\n\n  // we have to make sure that the whole write buffer path is empty before\n  // used e.g. for fence instructions.\n  assign no_st_pending_commit = no_st_pending_ex & dcache_commit_wbuffer_empty;\n\n  commit_stage #(\n      .CVA6Cfg(CVA6Cfg)\n  ) commit_stage_i (\n      .clk_i,\n      .rst_ni,\n      .halt_i            (halt_ctrl),\n      .flush_dcache_i    (dcache_flush_ctrl_cache),\n      .exception_o       (ex_commit),\n      .dirty_fp_state_o  (dirty_fp_state),\n      .single_step_i     (single_step_csr_commit),\n      .commit_instr_i    (commit_instr_id_commit),\n      .commit_ack_o      (commit_ack),\n      .no_st_pending_i   (no_st_pending_commit),\n      .waddr_o           (waddr_commit_id),\n      .wdata_o           (wdata_commit_id),\n      .we_gpr_o          (we_gpr_commit_id),\n      .we_fpr_o          (we_fpr_commit_id),\n      .commit_lsu_o      (lsu_commit_commit_ex),\n      .commit_lsu_ready_i(lsu_commit_ready_ex_commit),\n      .commit_tran_id_o  (lsu_commit_trans_id),\n      .amo_valid_commit_o(amo_valid_commit),\n      .amo_resp_i        (amo_resp),\n      .commit_csr_o      (csr_commit_commit_ex),\n      .pc_o              (pc_commit),\n      .csr_op_o          (csr_op_commit_csr),\n      .csr_wdata_o       (csr_wdata_commit_csr),\n      .csr_rdata_i       (csr_rdata_csr_commit),\n      .csr_write_fflags_o(csr_write_fflags_commit_cs),\n      .csr_exception_i   (csr_exception_csr_commit),\n      .fence_i_o         (fence_i_commit_controller),\n      .fence_o           (fence_commit_controller),\n      .sfence_vma_o      (sfence_vma_commit_controller),\n      .flush_commit_o    (flush_commit),\n      .*\n  );\n\n  // ---------\n  // CSR\n  // ---------\n  csr_regfile #(\n      .CVA6Cfg       (CVA6Cfg),\n      .AsidWidth     (ASID_WIDTH),\n      .MHPMCounterNum(MHPMCounterNum)\n  ) csr_regfile_i (\n      .flush_o               (flush_csr_ctrl),\n      .halt_csr_o            (halt_csr_ctrl),\n      .commit_instr_i        (commit_instr_id_commit),\n      .commit_ack_i          (commit_ack),\n      .boot_addr_i           (boot_addr_i[riscv::VLEN-1:0]),\n      .hart_id_i             (hart_id_i[riscv::XLEN-1:0]),\n      .ex_i                  (ex_commit),\n      .csr_op_i              (csr_op_commit_csr),\n      .csr_write_fflags_i    (csr_write_fflags_commit_cs),\n      .dirty_fp_state_i      (dirty_fp_state),\n      .dirty_v_state_i       (dirty_v_state),\n      .csr_addr_i            (csr_addr_ex_csr),\n      .csr_wdata_i           (csr_wdata_commit_csr),\n      .csr_rdata_o           (csr_rdata_csr_commit),\n      .pc_i                  (pc_commit),\n      .csr_exception_o       (csr_exception_csr_commit),\n      .epc_o                 (epc_commit_pcgen),\n      .eret_o                (eret),\n      .set_debug_pc_o        (set_debug_pc),\n      .trap_vector_base_o    (trap_vector_base_commit_pcgen),\n      .priv_lvl_o            (priv_lvl),\n      .acc_fflags_ex_i       (acc_resp_fflags),\n      .acc_fflags_ex_valid_i (acc_resp_fflags_valid),\n      .fs_o                  (fs),\n      .fflags_o              (fflags_csr_commit),\n      .frm_o                 (frm_csr_id_issue_ex),\n      .fprec_o               (fprec_csr_ex),\n      .vs_o                  (vs),\n      .irq_ctrl_o            (irq_ctrl_csr_id),\n      .ld_st_priv_lvl_o      (ld_st_priv_lvl_csr_ex),\n      .en_translation_o      (enable_translation_csr_ex),\n      .en_ld_st_translation_o(en_ld_st_translation_csr_ex),\n      .sum_o                 (sum_csr_ex),\n      .mxr_o                 (mxr_csr_ex),\n      .satp_ppn_o            (satp_ppn_csr_ex),\n      .asid_o                (asid_csr_ex),\n      .tvm_o                 (tvm_csr_id),\n      .tw_o                  (tw_csr_id),\n      .tsr_o                 (tsr_csr_id),\n      .debug_mode_o          (debug_mode),\n      .single_step_o         (single_step_csr_commit),\n      .dcache_en_o           (dcache_en_csr_nbdcache),\n      .icache_en_o           (icache_en_csr),\n      .acc_cons_en_o         (acc_cons_en_csr),\n      .perf_addr_o           (addr_csr_perf),\n      .perf_data_o           (data_csr_perf),\n      .perf_data_i           (data_perf_csr),\n      .perf_we_o             (we_csr_perf),\n      .pmpcfg_o              (pmpcfg),\n      .pmpaddr_o             (pmpaddr),\n      .mcountinhibit_o       (mcountinhibit_csr_perf),\n      //RVFI\n      .rvfi_csr_o            (rvfi_csr),\n      .debug_req_i,\n      .ipi_i,\n      .irq_i,\n      .time_irq_i,\n      .*\n  );\n\n  // ------------------------\n  // Performance Counters\n  // ------------------------\n  if (PERF_COUNTER_EN) begin : gen_perf_counter\n    perf_counters #(\n        .CVA6Cfg (CVA6Cfg),\n        .NumPorts(NumPorts)\n    ) perf_counters_i (\n        .clk_i         (clk_i),\n        .rst_ni        (rst_ni),\n        .debug_mode_i  (debug_mode),\n        .addr_i        (addr_csr_perf),\n        .we_i          (we_csr_perf),\n        .data_i        (data_csr_perf),\n        .data_o        (data_perf_csr),\n        .commit_instr_i(commit_instr_id_commit),\n        .commit_ack_i  (commit_ack),\n\n        .l1_icache_miss_i   (icache_miss_cache_perf),\n        .l1_dcache_miss_i   (dcache_miss_cache_perf),\n        .itlb_miss_i        (itlb_miss_ex_perf),\n        .dtlb_miss_i        (dtlb_miss_ex_perf),\n        .sb_full_i          (sb_full),\n        .if_empty_i         (~fetch_valid_if_id),\n        .ex_i               (ex_commit),\n        .eret_i             (eret),\n        .resolved_branch_i  (resolved_branch),\n        .branch_exceptions_i(flu_exception_ex_id),\n        .l1_icache_access_i (icache_dreq_if_cache),\n        .l1_dcache_access_i (dcache_req_ports_ex_cache),\n        .miss_vld_bits_i    (miss_vld_bits),\n        .i_tlb_flush_i      (flush_tlb_ctrl_ex),\n        .stall_issue_i      (stall_issue),\n        .mcountinhibit_i    (mcountinhibit_csr_perf)\n    );\n  end : gen_perf_counter\n  else begin : gen_no_perf_counter\n    assign data_perf_csr = '0;\n  end : gen_no_perf_counter\n\n  // ------------\n  // Controller\n  // ------------\n  controller #(\n      .CVA6Cfg(CVA6Cfg)\n  ) controller_i (\n      // flush ports\n      .set_pc_commit_o       (set_pc_ctrl_pcgen),\n      .flush_unissued_instr_o(flush_unissued_instr_ctrl_id),\n      .flush_if_o            (flush_ctrl_if),\n      .flush_id_o            (flush_ctrl_id),\n      .flush_ex_o            (flush_ctrl_ex),\n      .flush_bp_o            (flush_ctrl_bp),\n      .flush_tlb_o           (flush_tlb_ctrl_ex),\n      .flush_dcache_o        (dcache_flush_ctrl_cache),\n      .flush_dcache_ack_i    (dcache_flush_ack_cache_ctrl),\n\n      .halt_csr_i       (halt_csr_ctrl),\n      .halt_acc_i       (halt_acc_ctrl),\n      .halt_o           (halt_ctrl),\n      // control ports\n      .eret_i           (eret),\n      .ex_valid_i       (ex_commit.valid),\n      .set_debug_pc_i   (set_debug_pc),\n      .flush_csr_i      (flush_csr_ctrl),\n      .resolved_branch_i(resolved_branch),\n      .fence_i_i        (fence_i_commit_controller),\n      .fence_i          (fence_commit_controller),\n      .sfence_vma_i     (sfence_vma_commit_controller),\n      .flush_commit_i   (flush_commit),\n      .flush_acc_i      (flush_acc),\n\n      .flush_icache_o(icache_flush_ctrl_cache),\n      .*\n  );\n\n  // -------------------\n  // Cache Subsystem\n  // -------------------\n\n  // Acc dispatcher and store buffer share a dcache request port.\n  // Store buffer always has priority access over acc dipsatcher.\n  dcache_req_i_t [NumPorts-1:0] dcache_req_to_cache;\n  dcache_req_o_t [NumPorts-1:0] dcache_req_from_cache;\n\n  // D$ request\n  assign dcache_req_to_cache[0] = dcache_req_ports_ex_cache[0];\n  assign dcache_req_to_cache[1] = dcache_req_ports_ex_cache[1];\n  assign dcache_req_to_cache[2] = dcache_req_ports_acc_cache[0];\n  assign dcache_req_to_cache[3] = dcache_req_ports_ex_cache[2].data_req ? dcache_req_ports_ex_cache [2] :\n                                                                          dcache_req_ports_acc_cache[1];\n\n  // D$ response\n  assign dcache_req_ports_cache_ex[0] = dcache_req_from_cache[0];\n  assign dcache_req_ports_cache_ex[1] = dcache_req_from_cache[1];\n  assign dcache_req_ports_cache_acc[0] = dcache_req_from_cache[2];\n  always_comb begin : gen_dcache_req_store_data_gnt\n    dcache_req_ports_cache_ex[2]  = dcache_req_from_cache[3];\n    dcache_req_ports_cache_acc[1] = dcache_req_from_cache[3];\n\n    // Set gnt signal\n    dcache_req_ports_cache_ex[2].data_gnt &= dcache_req_ports_ex_cache[2].data_req;\n    dcache_req_ports_cache_acc[1].data_gnt &= !dcache_req_ports_ex_cache[2].data_req;\n  end\n\n  if (DCACHE_TYPE == int'(config_pkg::WT)) begin : gen_cache_wt\n    // this is a cache subsystem that is compatible with OpenPiton\n    wt_cache_subsystem #(\n        .CVA6Cfg   (CVA6Cfg),\n        .NumPorts  (NumPorts),\n        .noc_req_t (noc_req_t),\n        .noc_resp_t(noc_resp_t)\n    ) i_cache_subsystem (\n        // to D$\n        .clk_i             (clk_i),\n        .rst_ni            (rst_ni),\n        // I$\n        .icache_en_i       (icache_en_csr),\n        .icache_flush_i    (icache_flush_ctrl_cache),\n        .icache_miss_o     (icache_miss_cache_perf),\n        .icache_areq_i     (icache_areq_ex_cache),\n        .icache_areq_o     (icache_areq_cache_ex),\n        .icache_dreq_i     (icache_dreq_if_cache),\n        .icache_dreq_o     (icache_dreq_cache_if),\n        // D$\n        .dcache_enable_i   (dcache_en_csr_nbdcache),\n        .dcache_flush_i    (dcache_flush_ctrl_cache),\n        .dcache_flush_ack_o(dcache_flush_ack_cache_ctrl),\n        // to commit stage\n        .dcache_amo_req_i  (amo_req),\n        .dcache_amo_resp_o (amo_resp),\n        // from PTW, Load Unit  and Store Unit\n        .dcache_miss_o     (dcache_miss_cache_perf),\n        .miss_vld_bits_o   (miss_vld_bits),\n        .dcache_req_ports_i(dcache_req_to_cache),\n        .dcache_req_ports_o(dcache_req_from_cache),\n        // write buffer status\n        .wbuffer_empty_o   (dcache_commit_wbuffer_empty),\n        .wbuffer_not_ni_o  (dcache_commit_wbuffer_not_ni),\n        // memory side\n        .noc_req_o         (noc_req_o),\n        .noc_resp_i        (noc_resp_i),\n        .inval_addr_i      (inval_addr),\n        .inval_valid_i     (inval_valid),\n        .inval_ready_o     (inval_ready)\n    );\n  end else if (DCACHE_TYPE == int'(config_pkg::HPDCACHE)) begin : gen_cache_hpd\n    cva6_hpdcache_subsystem #(\n        .CVA6Cfg   (CVA6Cfg),\n        .NumPorts  (NumPorts),\n        .axi_ar_chan_t(axi_ar_chan_t),\n        .axi_aw_chan_t(axi_aw_chan_t),\n        .axi_w_chan_t (axi_w_chan_t),\n        .axi_b_chan_t (b_chan_t),\n        .axi_r_chan_t (r_chan_t),\n        .noc_req_t (noc_req_t),\n        .noc_resp_t(noc_resp_t),\n        .cmo_req_t (logic  /*FIXME*/),\n        .cmo_rsp_t (logic  /*FIXME*/)\n    ) i_cache_subsystem (\n        .clk_i (clk_i),\n        .rst_ni(rst_ni),\n\n        .icache_en_i   (icache_en_csr),\n        .icache_flush_i(icache_flush_ctrl_cache),\n        .icache_miss_o (icache_miss_cache_perf),\n        .icache_areq_i (icache_areq_ex_cache),\n        .icache_areq_o (icache_areq_cache_ex),\n        .icache_dreq_i (icache_dreq_if_cache),\n        .icache_dreq_o (icache_dreq_cache_if),\n\n        .dcache_enable_i   (dcache_en_csr_nbdcache),\n        .dcache_flush_i    (dcache_flush_ctrl_cache),\n        .dcache_flush_ack_o(dcache_flush_ack_cache_ctrl),\n        .dcache_miss_o     (dcache_miss_cache_perf),\n\n        .dcache_amo_req_i (amo_req),\n        .dcache_amo_resp_o(amo_resp),\n\n        .dcache_cmo_req_i ('0  /*FIXME*/),\n        .dcache_cmo_resp_o(  /*FIXME*/),\n\n        .dcache_req_ports_i(dcache_req_to_cache),\n        .dcache_req_ports_o(dcache_req_from_cache),\n\n        .wbuffer_empty_o (dcache_commit_wbuffer_empty),\n        .wbuffer_not_ni_o(dcache_commit_wbuffer_not_ni),\n\n        .hwpf_base_set_i    ('0  /*FIXME*/),\n        .hwpf_base_i        ('0  /*FIXME*/),\n        .hwpf_base_o        (  /*FIXME*/),\n        .hwpf_param_set_i   ('0  /*FIXME*/),\n        .hwpf_param_i       ('0  /*FIXME*/),\n        .hwpf_param_o       (  /*FIXME*/),\n        .hwpf_throttle_set_i('0  /*FIXME*/),\n        .hwpf_throttle_i    ('0  /*FIXME*/),\n        .hwpf_throttle_o    (  /*FIXME*/),\n        .hwpf_status_o      (  /*FIXME*/),\n\n        .noc_req_o (noc_req_o),\n        .noc_resp_i(noc_resp_i)\n    );\n    assign inval_ready = 1'b1;\n  end else begin : gen_cache_wb\n    std_cache_subsystem #(\n        // note: this only works with one cacheable region\n        // not as important since this cache subsystem is about to be\n        // deprecated\n        .CVA6Cfg      (CVA6Cfg),\n        .NumPorts     (NumPorts),\n        .axi_ar_chan_t(axi_ar_chan_t),\n        .axi_aw_chan_t(axi_aw_chan_t),\n        .axi_w_chan_t (axi_w_chan_t),\n        .axi_req_t    (noc_req_t),\n        .axi_rsp_t    (noc_resp_t)\n    ) i_cache_subsystem (\n        // to D$\n        .clk_i             (clk_i),\n        .rst_ni            (rst_ni),\n        .priv_lvl_i        (priv_lvl),\n        // I$\n        .icache_en_i       (icache_en_csr),\n        .icache_flush_i    (icache_flush_ctrl_cache),\n        .icache_miss_o     (icache_miss_cache_perf),\n        .icache_areq_i     (icache_areq_ex_cache),\n        .icache_areq_o     (icache_areq_cache_ex),\n        .icache_dreq_i     (icache_dreq_if_cache),\n        .icache_dreq_o     (icache_dreq_cache_if),\n        // D$\n        .dcache_enable_i   (dcache_en_csr_nbdcache),\n        .dcache_flush_i    (dcache_flush_ctrl_cache),\n        .dcache_flush_ack_o(dcache_flush_ack_cache_ctrl),\n        // to commit stage\n        .amo_req_i         (amo_req),\n        .amo_resp_o        (amo_resp),\n        .dcache_miss_o     (dcache_miss_cache_perf),\n        // this is statically set to 1 as the std_cache does not have a wbuffer\n        .wbuffer_empty_o   (dcache_commit_wbuffer_empty),\n        // from PTW, Load Unit  and Store Unit\n        .dcache_req_ports_i(dcache_req_to_cache),\n        .dcache_req_ports_o(dcache_req_from_cache),\n        // memory side\n        .axi_req_o         (noc_req_o),\n        .axi_resp_i        (noc_resp_i)\n    );\n    assign dcache_commit_wbuffer_not_ni = 1'b1;\n    assign inval_ready                  = 1'b1;\n  end\n\n  // ----------------\n  // Accelerator\n  // ----------------\n\n  if (CVA6Cfg.EnableAccelerator) begin : gen_accelerator\n    acc_dispatcher #(\n        .CVA6Cfg   (CVA6Cfg),\n        .acc_cfg_t (acc_cfg_t),\n        .AccCfg    (AccCfg),\n        .acc_req_t (cvxif_req_t),\n        .acc_resp_t(cvxif_resp_t)\n    ) i_acc_dispatcher (\n        .clk_i                 (clk_i),\n        .rst_ni                (rst_n"}
{"text": "i),\n        .flush_unissued_instr_i(flush_unissued_instr_ctrl_id),\n        .flush_ex_i            (flush_ctrl_ex),\n        .flush_pipeline_o      (flush_acc),\n        .acc_cons_en_i         (acc_cons_en_csr),\n        .acc_fflags_valid_o    (acc_resp_fflags_valid),\n        .acc_fflags_o          (acc_resp_fflags),\n        .ld_st_priv_lvl_i      (ld_st_priv_lvl_csr_ex),\n        .sum_i                 (sum_csr_ex),\n        .pmpcfg_i              (pmpcfg),\n        .pmpaddr_i             (pmpaddr),\n        .fcsr_frm_i            (frm_csr_id_issue_ex),\n        .dirty_v_state_o       (dirty_v_state),\n        .issue_instr_i         (issue_instr_id_acc),\n        .issue_instr_hs_i      (issue_instr_hs_id_acc),\n        .issue_stall_o         (stall_acc_id),\n        .fu_data_i             (fu_data_id_ex),\n        .commit_instr_i        (commit_instr_id_commit),\n        .commit_st_barrier_i   (fence_i_commit_controller | fence_commit_controller),\n        .acc_trans_id_o        (acc_trans_id_ex_id),\n        .acc_result_o          (acc_result_ex_id),\n        .acc_valid_o           (acc_valid_ex_id),\n        .acc_exception_o       (acc_exception_ex_id),\n        .acc_valid_ex_o        (acc_valid_acc_ex),\n        .commit_ack_i          (commit_ack),\n        .acc_stall_st_pending_o(stall_st_pending_ex),\n        .acc_no_st_pending_i   (no_st_pending_commit),\n        .dcache_req_ports_i    (dcache_req_ports_ex_cache),\n        .ctrl_halt_o           (halt_acc_ctrl),\n        .acc_dcache_req_ports_o(dcache_req_ports_acc_cache),\n        .acc_dcache_req_ports_i(dcache_req_ports_cache_acc),\n        .inval_ready_i         (inval_ready),\n        .inval_valid_o         (inval_valid),\n        .inval_addr_o          (inval_addr),\n        .acc_req_o             (cvxif_req_o),\n        .acc_resp_i            (cvxif_resp_i)\n    );\n  end : gen_accelerator\n  else begin : gen_no_accelerator\n    assign acc_trans_id_ex_id         = '0;\n    assign acc_result_ex_id           = '0;\n    assign acc_valid_ex_id            = '0;\n    assign acc_exception_ex_id        = '0;\n    assign acc_resp_fflags            = '0;\n    assign acc_resp_fflags_valid      = '0;\n    assign stall_acc_id               = '0;\n    assign dirty_v_state              = '0;\n    assign acc_valid_acc_ex           = '0;\n    assign halt_acc_ctrl              = '0;\n    assign stall_st_pending_ex        = '0;\n    assign flush_acc                  = '0;\n\n    // D$ connection is unused\n    assign dcache_req_ports_acc_cache = '0;\n\n    // No invalidation interface\n    assign inval_valid                = '0;\n    assign inval_addr                 = '0;\n\n    // Feed through cvxif\n    assign cvxif_req_o                = cvxif_req;\n    assign cvxif_resp                 = cvxif_resp_i;\n  end : gen_no_accelerator\n\n  // -------------------\n  // Parameter Check\n  // -------------------\n  // pragma translate_off\n`ifndef VERILATOR\n  initial config_pkg::check_cfg(CVA6Cfg);\n`endif\n  // pragma translate_on\n\n  // -------------------\n  // Instruction Tracer\n  // -------------------\n\n  //pragma translate_off\n`ifdef PITON_ARIANE\n  localparam PC_QUEUE_DEPTH = 16;\n\n  logic                                              piton_pc_vld;\n  logic [          riscv::VLEN-1:0]                  piton_pc;\n  logic [CVA6Cfg.NrCommitPorts-1:0][riscv::VLEN-1:0] pc_data;\n  logic [CVA6Cfg.NrCommitPorts-1:0] pc_pop, pc_empty;\n\n  for (genvar i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin : gen_pc_fifo\n    fifo_v3 #(\n        .DATA_WIDTH(64),\n        .DEPTH(PC_QUEUE_DEPTH)\n    ) i_pc_fifo (\n        .clk_i     (clk_i),\n        .rst_ni    (rst_ni),\n        .flush_i   ('0),\n        .testmode_i('0),\n        .full_o    (),\n        .empty_o   (pc_empty[i]),\n        .usage_o   (),\n        .data_i    (commit_instr_id_commit[i].pc),\n        .push_i    (commit_ack[i] & ~commit_instr_id_commit[i].ex.valid),\n        .data_o    (pc_data[i]),\n        .pop_i     (pc_pop[i])\n    );\n  end\n\n  rr_arb_tree #(\n      .NumIn(CVA6Cfg.NrCommitPorts),\n      .DataWidth(64)\n  ) i_rr_arb_tree (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i('0),\n      .rr_i   ('0),\n      .req_i  (~pc_empty),\n      .gnt_o  (pc_pop),\n      .data_i (pc_data),\n      .gnt_i  (piton_pc_vld),\n      .req_o  (piton_pc_vld),\n      .data_o (piton_pc),\n      .idx_o  ()\n  );\n`endif  // PITON_ARIANE\n\n`ifndef VERILATOR\n  instr_tracer_if tracer_if (clk_i);\n  // assign instruction tracer interface\n  // control signals\n  assign tracer_if.rstn           = rst_ni;\n  assign tracer_if.flush_unissued = flush_unissued_instr_ctrl_id;\n  assign tracer_if.flush          = flush_ctrl_ex;\n  // fetch\n  assign tracer_if.instruction    = id_stage_i.fetch_entry_i.instruction;\n  assign tracer_if.fetch_valid    = id_stage_i.fetch_entry_valid_i;\n  assign tracer_if.fetch_ack      = id_stage_i.fetch_entry_ready_o;\n  // Issue\n  assign tracer_if.issue_ack      = issue_stage_i.i_scoreboard.issue_ack_i;\n  assign tracer_if.issue_sbe      = issue_stage_i.i_scoreboard.issue_instr_o;\n  // write-back\n  assign tracer_if.waddr          = waddr_commit_id;\n  assign tracer_if.wdata          = wdata_commit_id;\n  assign tracer_if.we_gpr         = we_gpr_commit_id;\n  assign tracer_if.we_fpr         = we_fpr_commit_id;\n  // commit\n  assign tracer_if.commit_instr   = commit_instr_id_commit;\n  assign tracer_if.commit_ack     = commit_ack;\n  // branch predict\n  assign tracer_if.resolve_branch = resolved_branch;\n  // address translation\n  // stores\n  assign tracer_if.st_valid       = ex_stage_i.lsu_i.i_store_unit.store_buffer_i.valid_i;\n  assign tracer_if.st_paddr       = ex_stage_i.lsu_i.i_store_unit.store_buffer_i.paddr_i;\n  // loads\n  assign tracer_if.ld_valid       = ex_stage_i.lsu_i.i_load_unit.req_port_o.tag_valid;\n  assign tracer_if.ld_kill        = ex_stage_i.lsu_i.i_load_unit.req_port_o.kill_req;\n  assign tracer_if.ld_paddr       = ex_stage_i.lsu_i.i_load_unit.paddr_i;\n  // exceptions\n  assign tracer_if.exception      = commit_stage_i.exception_o;\n  // assign current privilege level\n  assign tracer_if.priv_lvl       = priv_lvl;\n  assign tracer_if.debug_mode     = debug_mode;\n\n  instr_tracer instr_tracer_i (\n      .tracer_if(tracer_if),\n      .hart_id_i\n  );\n\n  // mock tracer for Verilator, to be used with spike-dasm\n`else\n\n  int f;\n  logic [63:0] cycles;\n\n  initial begin\n    string fn;\n    $sformat(fn, \"trace_hart_%0.0f.dasm\", hart_id_i);\n    f = $fopen(fn, \"w\");\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      cycles <= 0;\n    end else begin\n      byte mode = \"\";\n      if (CVA6Cfg.DebugEn && debug_mode) mode = \"D\";\n      else begin\n        case (priv_lvl)\n          riscv::PRIV_LVL_M: mode = \"M\";\n          riscv::PRIV_LVL_S: if (CVA6Cfg.RVS) mode = \"S\";\n          riscv::PRIV_LVL_U: mode = \"U\";\n          default: ;  // Do nothing\n        endcase\n      end\n      for (int i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin\n        if (commit_ack[i] && !commit_instr_id_commit[i].ex.valid) begin\n          $fwrite(f, \"%d 0x%0h %s (0x%h) DASM(%h)\\n\", cycles, commit_instr_id_commit[i].pc, mode,\n                  commit_instr_id_commit[i].ex.tval[31:0], commit_instr_id_commit[i].ex.tval[31:0]);\n        end else if (commit_ack[i] && commit_instr_id_commit[i].ex.valid) begin\n          if (commit_instr_id_commit[i].ex.cause == 2) begin\n            $fwrite(f, \"Exception Cause: Illegal Instructions, DASM(%h) PC=%h\\n\",\n                    commit_instr_id_commit[i].ex.tval[31:0], commit_instr_id_commit[i].pc);\n          end else begin\n            if (CVA6Cfg.DebugEn && debug_mode) begin\n              $fwrite(f, \"%d 0x%0h %s (0x%h) DASM(%h)\\n\", cycles, commit_instr_id_commit[i].pc,\n                      mode, commit_instr_id_commit[i].ex.tval[31:0],\n                      commit_instr_id_commit[i].ex.tval[31:0]);\n            end else begin\n              $fwrite(f, \"Exception Cause: %5d, DASM(%h) PC=%h\\n\",\n                      commit_instr_id_commit[i].ex.cause, commit_instr_id_commit[i].ex.tval[31:0],\n                      commit_instr_id_commit[i].pc);\n            end\n          end\n        end\n      end\n      cycles <= cycles + 1;\n    end\n  end\n\n  final begin\n    $fclose(f);\n  end\n`endif  // VERILATOR\n  //pragma translate_on\n\n\n  //RVFI INSTR\n\n  cva6_rvfi_probes #(\n      .CVA6Cfg      (CVA6Cfg),\n      .rvfi_probes_t(rvfi_probes_t)\n  ) i_cva6_rvfi_probes (\n\n      .flush_i            (flush_ctrl_if),\n      .issue_instr_ack_i  (issue_instr_issue_id),\n      .fetch_entry_valid_i(fetch_valid_if_id),\n      .instruction_i      (fetch_entry_if_id.instruction),\n      .is_compressed_i    (rvfi_is_compressed),\n\n      .issue_pointer_i (rvfi_issue_pointer),\n      .commit_pointer_i(rvfi_commit_pointer),\n\n      .flush_unissued_instr_i(flush_unissued_instr_ctrl_id),\n      .decoded_instr_valid_i (issue_entry_valid_id_issue),\n      .decoded_instr_ack_i   (issue_instr_issue_id),\n\n      .rs1_forwarding_i(rs1_forwarding_id_ex),\n      .rs2_forwarding_i(rs2_forwarding_id_ex),\n\n      .commit_instr_i(commit_instr_id_commit),\n      .ex_commit_i   (ex_commit),\n      .priv_lvl_i    (priv_lvl),\n\n      .lsu_ctrl_i  (rvfi_lsu_ctrl),\n      .wbdata_i    (wbdata_ex_id),\n      .commit_ack_i(commit_ack),\n      .mem_paddr_i (rvfi_mem_paddr),\n      .debug_mode_i(debug_mode),\n      .wdata_i     (wdata_commit_id),\n\n      .csr_i(rvfi_csr),\n\n      .rvfi_probes_o(rvfi_probes_o)\n\n  );\n\n\nendmodule  // ariane\n"}
{"text": "// Copyright 2023 ETH Zurich and University of Bologna.\n// Solderpad Hardware License, Version 0.51, see LICENSE for details.\n// SPDX-License-Identifier: SHL-0.51\n\n// Author: Nils Wistoff <nwistoff@iis.ee.ethz.ch>\n\n// Module stub for the cva6_accel_first_pass_decoder. Replace this with your accelerator's\n// first pass decoder.\n\nmodule cva6_accel_first_pass_decoder\n  import ariane_pkg::*;\n(\n    input  logic              [31:0] instruction_i,           // instruction from IF\n    input  riscv::xs_t               fs_i,                    // floating point extension status\n    input  riscv::xs_t               vs_i,                    // vector extension status\n    output logic                     is_accel_o,              // is an accelerator instruction\n    output scoreboard_entry_t        instruction_o,           // predecoded instruction\n    output logic                     illegal_instr_o,         // is an illegal instruction\n    output logic                     is_control_flow_instr_o  // is a control flow instruction\n);\n\n  assign is_accel_o              = 1'b0;\n  assign instruction_o           = '0;\n  assign illegal_instr_o         = 1'b0;\n  assign is_control_flow_instr_o = 1'b0;\n\n  $error(\"cva6_accel_first_pass_decoder: instantiated non-functional module stub.\\\n          Please replace this with your accelerator's first pass decoder \\\n          (or unset ENABLE_ACCELERATOR).\");\n\nendmodule : cva6_accel_first_pass_decoder\n"}
{"text": "// Copyright 2023 Commissariat a l'Energie Atomique et aux Energies\n//                Alternatives (CEA)\n//\n// Licensed under the Solderpad Hardware License, Version 2.1 (the \u201cLicense\u201d);\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Authors: Cesar Fuguet\n// Date: February, 2023\n// Description:\n//   Default package with parameters for the HPDcache in a CVA6 platform.\n//   Users can copy this file, rename it, and adapt the configuration values as\n//   needed.\n\npackage hpdcache_params_pkg;\n  //  Imports from the CVA6 configuration package\n  //  {{{\n  import cva6_config_pkg::CVA6ConfigXlen;\n  import cva6_config_pkg::CVA6ConfigDcacheByteSize;\n  import cva6_config_pkg::CVA6ConfigDcacheSetAssoc;\n  import cva6_config_pkg::CVA6ConfigDcacheLineWidth;\n  import cva6_config_pkg::CVA6ConfigDcacheIdWidth;\n  import cva6_config_pkg::CVA6ConfigWtDcacheWbufDepth;\n  import cva6_config_pkg::CVA6ConfigNrLoadBufEntries;\n  //  }}}\n\n  //  Definition of constants and functions used only in this file\n  //  {{{\n  localparam int unsigned __BYTES_PER_WAY = CVA6ConfigDcacheByteSize / CVA6ConfigDcacheSetAssoc;\n  localparam int unsigned __BYTES_PER_CACHELINE = CVA6ConfigDcacheLineWidth / 8;\n  localparam int unsigned __MAX_RAM_WORD_BITS = 128;\n\n  function int unsigned __minu(int unsigned x, int unsigned y);\n    return x < y ? x : y;\n  endfunction\n\n  function int unsigned __maxu(int unsigned x, int unsigned y);\n    return y < x ? x : y;\n  endfunction\n  //  }}}\n\n  //  Definition of global constants for the HPDcache data and directory\n  //  {{{\n  //  HPDcache physical address width (in bits)\n  localparam int unsigned PARAM_PA_WIDTH = riscv::PLEN;\n\n  //  HPDcache number of sets\n  localparam int unsigned PARAM_SETS = __BYTES_PER_WAY / __BYTES_PER_CACHELINE;\n\n  //  HPDcache number of ways\n  localparam int unsigned PARAM_WAYS = CVA6ConfigDcacheSetAssoc;\n\n  //  HPDcache word width (bits)\n  localparam int unsigned PARAM_WORD_WIDTH = CVA6ConfigXlen;\n\n  //  HPDcache cache-line width (bits)\n  localparam int unsigned PARAM_CL_WORDS = CVA6ConfigDcacheLineWidth / PARAM_WORD_WIDTH;\n\n  //  HPDcache number of words in the request data channels (request and response)\n  localparam int unsigned PARAM_REQ_WORDS = 1;\n\n  //  HPDcache request transaction ID width (bits)\n  localparam int unsigned PARAM_REQ_TRANS_ID_WIDTH = CVA6ConfigDcacheIdWidth;\n\n  //  HPDcache request source ID width (bits)\n  localparam int unsigned PARAM_REQ_SRC_ID_WIDTH = 3;\n\n  //  HPDcache victim selection policy\n  //  0: (Pseudo) RANDOM\n  //  1: (Pseudo) LRU\n  localparam int unsigned PARAM_VICTIM_SEL = 0;\n  //  }}}\n\n  //  Definition of constants and types for HPDcache data memory\n  //  {{{\n  localparam int unsigned PARAM_DATA_WAYS_PER_RAM_WORD = __minu(\n      __MAX_RAM_WORD_BITS / PARAM_WORD_WIDTH, PARAM_WAYS\n  );\n\n  localparam int unsigned PARAM_DATA_SETS_PER_RAM = PARAM_SETS;\n\n  //  HPDcache DATA RAM macros whether implements:\n  //  -  Write byte enable (1'b1)\n  //  -  Write bit mask (1'b0)\n  localparam bit PARAM_DATA_RAM_WBYTEENABLE = 1'b1;\n\n  //  Define the number of memory contiguous words that can be accessed\n  //  simultaneously from the cache.\n  //  -  This limits the maximum width for the data channel from requesters\n  //  -  This impacts the refill latency (more ACCESS_WORDS -> less REFILL LATENCY)\n  localparam int unsigned PARAM_ACCESS_WORDS = PARAM_CL_WORDS / 2;\n  //  }}}\n\n  //  Definition of constants and types for the Miss Status Holding Register (MSHR)\n  //  {{{\n  //  HPDcache MSHR number of sets\n  localparam int unsigned PARAM_MSHR_SETS = 1;\n\n  //  HPDcache MSHR number of ways\n  localparam int unsigned PARAM_MSHR_WAYS = CVA6ConfigNrLoadBufEntries;\n\n  //  HPDcache MSHR number of ways in the same SRAM word\n  localparam int unsigned PARAM_MSHR_WAYS_PER_RAM_WORD = (PARAM_MSHR_WAYS > 1) ? 2 : 1;\n\n  //  HPDcache MSHR number of sets in the same SRAM\n  localparam int unsigned PARAM_MSHR_SETS_PER_RAM = PARAM_MSHR_SETS;\n\n  //  HPDcache MSHR RAM whether implements:\n  //  -  Write byte enable (1'b1)\n  //  -  Write bit mask (1'b0)\n  localparam bit PARAM_MSHR_RAM_WBYTEENABLE = 1'b1;\n\n  //  HPDcache MSHR whether uses FFs or SRAM\n  localparam bit PARAM_MSHR_USE_REGBANK = (PARAM_MSHR_SETS * PARAM_MSHR_WAYS) <= 16;\n\n  //  HPDcache feedthrough FIFOs from the refill handler to the core\n  localparam bit PARAM_REFILL_CORE_RSP_FEEDTHROUGH = 1'b1;\n\n  //  HPDcache depth of the refill FIFO\n  localparam int PARAM_REFILL_FIFO_DEPTH = 32'd2;\n  //  }}}\n\n  //  Definition of constants and types for the Write Buffer (WBUF)\n  //  {{{\n  //  HPDcache Write-Buffer number of entries in the directory\n  localparam int unsigned PARAM_WBUF_DIR_ENTRIES = CVA6ConfigWtDcacheWbufDepth;\n\n  //  HPDcache Write-Buffer number of entries in the data buffer\n  localparam int unsigned PARAM_WBUF_DATA_ENTRIES = CVA6ConfigWtDcacheWbufDepth;\n\n  //  HPDcache Write-Buffer number of words per entry\n  localparam int unsigned PARAM_WBUF_WORDS = PARAM_REQ_WORDS;\n\n  //  HPDcache Write-Buffer threshold counter width (in bits)\n  localparam int unsigned PARAM_WBUF_TIMECNT_WIDTH = 3;\n  localparam bit PARAM_WBUF_SEND_FEEDTHROUGH = 1'b0;\n  //  }}}\n\n  //  Definition of constants and types for the Replay Table (RTAB)\n  //  {{{\n  localparam int PARAM_RTAB_ENTRIES = 4;\n  //  }}}\nendpackage\n"}
{"text": "// Copyright 2023 Commissariat a l'Energie Atomique et aux Energies\n//                Alternatives (CEA)\n//\n// Licensed under the Solderpad Hardware License, Version 2.1 (the \u201cLicense\u201d);\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Authors: Cesar Fuguet\n// Date: February, 2023\n// Description: Interface adapter for the CVA6 core\nmodule cva6_hpdcache_if_adapter\n  import hpdcache_pkg::*;\n\n//  Parameters\n//  {{{\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg      = config_pkg::cva6_cfg_empty,\n    parameter bit                    is_load_port = 1'b1\n)\n//  }}}\n\n//  Ports\n//  {{{\n(\n    //  Clock and active-low reset pins\n    input logic clk_i,\n    input logic rst_ni,\n\n    //  Port ID\n    input hpdcache_pkg::hpdcache_req_sid_t hpdcache_req_sid_i,\n\n    //  Request/response ports from/to the CVA6 core\n    input  ariane_pkg::dcache_req_i_t cva6_req_i,\n    output ariane_pkg::dcache_req_o_t cva6_req_o,\n    input  ariane_pkg::amo_req_t      cva6_amo_req_i,\n    output ariane_pkg::amo_resp_t     cva6_amo_resp_o,\n\n    //  Request port to the L1 Dcache\n    output logic                        hpdcache_req_valid_o,\n    input  logic                        hpdcache_req_ready_i,\n    output hpdcache_pkg::hpdcache_req_t hpdcache_req_o,\n    output logic                        hpdcache_req_abort_o,\n    output hpdcache_pkg::hpdcache_tag_t hpdcache_req_tag_o,\n    output hpdcache_pkg::hpdcache_pma_t hpdcache_req_pma_o,\n\n    //  Response port from the L1 Dcache\n    input logic                        hpdcache_rsp_valid_i,\n    input hpdcache_pkg::hpdcache_rsp_t hpdcache_rsp_i\n);\n  //  }}}\n\n  //  Internal nets and registers\n  //  {{{\n  logic forward_store, forward_amo;\n  logic hpdcache_req_is_uncacheable;\n  //  }}}\n\n  //  Request forwarding\n  //  {{{\n  generate\n    //  LOAD request\n    //  {{{\n    if (is_load_port == 1'b1) begin : load_port_gen\n      assign hpdcache_req_is_uncacheable = !config_pkg::is_inside_cacheable_regions(\n          CVA6Cfg,\n          {\n            {64 - ariane_pkg::DCACHE_TAG_WIDTH{1'b0}}\n            , cva6_req_i.address_tag\n            , {ariane_pkg::DCACHE_INDEX_WIDTH{1'b0}}\n          }\n      );\n\n      //    Request forwarding\n      assign hpdcache_req_valid_o = cva6_req_i.data_req,\n          hpdcache_req_o.addr_offset = cva6_req_i.address_index,\n          hpdcache_req_o.wdata = '0,\n          hpdcache_req_o.op = hpdcache_pkg::HPDCACHE_REQ_LOAD,\n          hpdcache_req_o.be = cva6_req_i.data_be,\n          hpdcache_req_o.size = cva6_req_i.data_size,\n          hpdcache_req_o.sid = hpdcache_req_sid_i,\n          hpdcache_req_o.tid = cva6_req_i.data_id,\n          hpdcache_req_o.need_rsp = 1'b1,\n          hpdcache_req_o.phys_indexed = 1'b0,\n          hpdcache_req_o.addr_tag = '0,  // unused on virtually indexed request\n          hpdcache_req_o.pma = '0;  // unused on virtually indexed request\n\n      assign hpdcache_req_abort_o = cva6_req_i.kill_req,\n          hpdcache_req_tag_o = cva6_req_i.address_tag,\n          hpdcache_req_pma_o.uncacheable = hpdcache_req_is_uncacheable,\n          hpdcache_req_pma_o.io = 1'b0;\n\n      //    Response forwarding\n      assign cva6_req_o.data_rvalid = hpdcache_rsp_valid_i,\n          cva6_req_o.data_rdata = hpdcache_rsp_i.rdata,\n          cva6_req_o.data_rid = hpdcache_rsp_i.tid,\n          cva6_req_o.data_gnt = hpdcache_req_ready_i;\n    end  //  }}}\n\n         //  {{{\n    else begin : store_amo_gen\n      //  STORE/AMO request\n      hpdcache_req_addr_t   amo_addr;\n      hpdcache_req_offset_t amo_addr_offset;\n      hpdcache_tag_t        amo_tag;\n      logic amo_is_word, amo_is_word_hi;\n      logic             [63:0] amo_data;\n      logic             [ 7:0] amo_data_be;\n      hpdcache_req_op_t        amo_op;\n      logic             [31:0] amo_resp_word;\n      logic                    amo_pending_q;\n\n      //  AMO logic\n      //  {{{\n      always_comb begin : amo_op_comb\n        amo_addr = cva6_amo_req_i.operand_a;\n        amo_addr_offset = amo_addr[0+:HPDCACHE_REQ_OFFSET_WIDTH];\n        amo_tag = amo_addr[HPDCACHE_REQ_OFFSET_WIDTH+:HPDCACHE_TAG_WIDTH];\n        unique case (cva6_amo_req_i.amo_op)\n          ariane_pkg::AMO_LR:   amo_op = HPDCACHE_REQ_AMO_LR;\n          ariane_pkg::AMO_SC:   amo_op = HPDCACHE_REQ_AMO_SC;\n          ariane_pkg::AMO_SWAP: amo_op = HPDCACHE_REQ_AMO_SWAP;\n          ariane_pkg::AMO_ADD:  amo_op = HPDCACHE_REQ_AMO_ADD;\n          ariane_pkg::AMO_AND:  amo_op = HPDCACHE_REQ_AMO_AND;\n          ariane_pkg::AMO_OR:   amo_op = HPDCACHE_REQ_AMO_OR;\n          ariane_pkg::AMO_XOR:  amo_op = HPDCACHE_REQ_AMO_XOR;\n          ariane_pkg::AMO_MAX:  amo_op = HPDCACHE_REQ_AMO_MAX;\n          ariane_pkg::AMO_MAXU: amo_op = HPDCACHE_REQ_AMO_MAXU;\n          ariane_pkg::AMO_MIN:  amo_op = HPDCACHE_REQ_AMO_MIN;\n          ariane_pkg::AMO_MINU: amo_op = HPDCACHE_REQ_AMO_MINU;\n          default:              amo_op = HPDCACHE_REQ_LOAD;\n        endcase\n      end\n      //  }}}\n\n      //  Request forwarding\n      //  {{{\n      assign hpdcache_req_is_uncacheable = !config_pkg::is_inside_cacheable_regions(\n          CVA6Cfg,\n          {\n            {64 - ariane_pkg::DCACHE_TAG_WIDTH{1'b0}}\n            , hpdcache_req_o.addr_tag,\n            {ariane_pkg::DCACHE_INDEX_WIDTH{1'b0}}\n          }\n      );\n\n      assign amo_is_word = (cva6_amo_req_i.size == 2'b10);\n      assign amo_is_word_hi = cva6_amo_req_i.operand_a[2];\n      if (riscv::XLEN == 64) begin : amo_data_64_gen\n        assign amo_data    = amo_is_word ? {2{cva6_amo_req_i.operand_b[0+:32]}} : cva6_amo_req_i.operand_b;\n        assign amo_data_be = amo_is_word_hi ? 8'hf0 : amo_is_word ? 8'h0f : 8'hff;\n      end else begin : amo_data_32_gen\n        assign amo_data    = {32'b0, cva6_amo_req_i.operand_b};\n        assign amo_data_be = 8'h0f;\n      end\n\n      assign forward_store = cva6_req_i.data_req;\n      assign forward_amo = cva6_amo_req_i.req;\n\n      assign hpdcache_req_valid_o = forward_store | (forward_amo & ~amo_pending_q);\n      assign hpdcache_req_o.addr_offset = forward_amo ? amo_addr_offset : cva6_req_i.address_index;\n      assign hpdcache_req_o.wdata = forward_amo ? amo_data : cva6_req_i.data_wdata;\n      assign hpdcache_req_o.op = forward_amo ? amo_op : hpdcache_pkg::HPDCACHE_REQ_STORE;\n      assign hpdcache_req_o.be = forward_amo ? amo_data_be : cva6_req_i.data_be;\n      assign hpdcache_req_o.size = forward_amo ? cva6_amo_req_i.size : cva6_req_i.data_size;\n      assign hpdcache_req_o.sid = hpdcache_req_sid_i;\n      assign hpdcache_req_o.tid = forward_amo ? '1 : '0;\n      assign hpdcache_req_o.need_rsp = forward_amo;\n      assign hpdcache_req_o.phys_indexed = 1'b1;\n      assign hpdcache_req_o.addr_tag = forward_amo ? amo_tag : cva6_req_i.address_tag;\n      assign hpdcache_req_o.pma.uncacheable = hpdcache_req_is_uncacheable;\n      assign hpdcache_req_o.pma.io = 1'b0;\n      assign hpdcache_req_abort_o = 1'b0;  // unused on physically indexed requests\n      assign hpdcache_req_tag_o = '0;  // unused on physically indexed requests\n      assign hpdcache_req_pma_o = '0;  // unused on physically indexed requests\n      //  }}}\n\n      //  Response forwarding\n      //  {{{\n      if (riscv::XLEN == 64) begin : amo_resp_64_gen\n        assign amo_resp_word = amo_is_word_hi\n                             ? hpdcache_rsp_i.rdata[0][32 +: 32]\n                             : hpdcache_rsp_i.rdata[0][0  +: 32];\n      end else begin : amo_resp_32_gen\n        assign amo_resp_word = hpdcache_rsp_i.rdata[0];\n      end\n\n      assign cva6_req_o.data_rvalid = hpdcache_rsp_valid_i && (hpdcache_rsp_i.tid != '1);\n      assign cva6_req_o.data_rdata = hpdcache_rsp_i.rdata;\n      assign cva6_req_o.data_rid = hpdcache_rsp_i.tid;\n      assign cva6_req_o.data_gnt = hpdcache_req_ready_i;\n\n      assign cva6_amo_resp_o.ack = hpdcache_rsp_valid_i && (hpdcache_rsp_i.tid == '1);\n      assign cva6_amo_resp_o.result = amo_is_word ? {{32{amo_resp_word[31]}}, amo_resp_word}\n                                                        : hpdcache_rsp_i.rdata[0];\n      //  }}}\n\n      always_ff @(posedge clk_i or negedge rst_ni) begin : amo_pending_ff\n        if (!rst_ni) begin\n          amo_pending_q <= 1'b0;\n        end else begin\n          amo_pending_q <=\n              ( cva6_amo_req_i.req  & hpdcache_req_ready_i & ~amo_pending_q) |\n              (~cva6_amo_resp_o.ack & amo_pending_q);\n        end\n      end\n    end\n    //  }}}\n  endgenerate\n  //  }}}\n\n  //  Assertions\n  //  {{{\n  //    pragma translate_off\n  forward_one_request_assert :\n  assert property (@(posedge clk_i) ($onehot0({forward_store, forward_amo})))\n  else $error(\"Only one request shall be forwarded\");\n  //    pragma translate_on\n  //  }}}\nendmodule\n"}
{"text": "// Copyright 2023 Commissariat a l'Energie Atomique et aux Energies\n//                Alternatives (CEA)\n//\n// Licensed under the Solderpad Hardware License, Version 2.1 (the \u201cLicense\u201d);\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Authors: Cesar Fuguet\n// Date: February, 2023\n// Description: CVA6 cache subsystem integrating standard CVA6's\n//              instruction cache and the Core-V High-Performance L1\n//              data cache (CV-HPDcache).\n\nmodule cva6_hpdcache_subsystem\n//  Parameters\n//  {{{\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int NumPorts = 4,\n    parameter int NrHwPrefetchers = 4,\n    // AXI types\n    parameter type axi_ar_chan_t = logic,\n    parameter type axi_aw_chan_t = logic,\n    parameter type axi_w_chan_t = logic,\n    parameter type axi_b_chan_t = logic,\n    parameter type axi_r_chan_t = logic,\n    parameter type noc_req_t = logic,\n    parameter type noc_resp_t = logic,\n    parameter type cmo_req_t = logic,\n    parameter type cmo_rsp_t = logic\n)\n//  }}}\n\n//  Ports\n//  {{{\n(\n    input logic clk_i,\n    input logic rst_ni,\n\n    //  I$\n    //  {{{\n    input logic icache_en_i,  // enable icache (or bypass e.g: in debug mode)\n    input logic icache_flush_i,  // flush the icache, flush and kill have to be asserted together\n    output logic icache_miss_o,  // to performance counter\n    // address translation requests\n    input ariane_pkg::icache_areq_t icache_areq_i,  // to/from frontend\n    output ariane_pkg::icache_arsp_t icache_areq_o,\n    // data requests\n    input ariane_pkg::icache_dreq_t icache_dreq_i,  // to/from frontend\n    output ariane_pkg::icache_drsp_t icache_dreq_o,\n    //   }}}\n\n    //  D$\n    //  {{{\n    //    Cache management\n    input logic dcache_enable_i,  // from CSR\n    input logic dcache_flush_i,  // high until acknowledged\n    output logic                       dcache_flush_ack_o,     // send a single cycle acknowledge signal when the cache is flushed\n    output logic dcache_miss_o,  // we missed on a ld/st\n\n    //  AMO interface\n    input  ariane_pkg::amo_req_t                     dcache_amo_req_i,    // from LSU\n    output ariane_pkg::amo_resp_t                    dcache_amo_resp_o,   // to LSU\n    //  CMO interface\n    input  cmo_req_t                                 dcache_cmo_req_i,    // from CMO FU\n    output cmo_rsp_t                                 dcache_cmo_resp_o,   // to CMO FU\n    //  Request ports\n    input  ariane_pkg::dcache_req_i_t [NumPorts-1:0] dcache_req_ports_i,  // from LSU\n    output ariane_pkg::dcache_req_o_t [NumPorts-1:0] dcache_req_ports_o,  // to LSU\n    //  Write Buffer status\n    output logic                                     wbuffer_empty_o,\n    output logic                                     wbuffer_not_ni_o,\n\n    //  Hardware memory prefetcher configuration\n    input  logic [NrHwPrefetchers-1:0]       hwpf_base_set_i,\n    input  logic [NrHwPrefetchers-1:0][63:0] hwpf_base_i,\n    output logic [NrHwPrefetchers-1:0][63:0] hwpf_base_o,\n    input  logic [NrHwPrefetchers-1:0]       hwpf_param_set_i,\n    input  logic [NrHwPrefetchers-1:0][63:0] hwpf_param_i,\n    output logic [NrHwPrefetchers-1:0][63:0] hwpf_param_o,\n    input  logic [NrHwPrefetchers-1:0]       hwpf_throttle_set_i,\n    input  logic [NrHwPrefetchers-1:0][63:0] hwpf_throttle_i,\n    output logic [NrHwPrefetchers-1:0][63:0] hwpf_throttle_o,\n    output logic [               63:0]       hwpf_status_o,\n    //  }}}\n\n    //  AXI port to upstream memory/peripherals\n    //  {{{\n    output noc_req_t  noc_req_o,\n    input  noc_resp_t noc_resp_i\n    //  }}}\n);\n  //  }}}\n\n  //  I$ instantiation\n  //  {{{\n  logic icache_miss_valid, icache_miss_ready;\n  wt_cache_pkg::icache_req_t icache_miss;\n\n  logic icache_miss_resp_valid;\n  wt_cache_pkg::icache_rtrn_t icache_miss_resp;\n\n  localparam int ICACHE_RDTXID = 1 << (ariane_pkg::MEM_TID_WIDTH - 1);\n\n  cva6_icache #(\n      .CVA6Cfg(CVA6Cfg),\n      .RdTxId (ICACHE_RDTXID)\n  ) i_cva6_icache (\n      .clk_i         (clk_i),\n      .rst_ni        (rst_ni),\n      .flush_i       (icache_flush_i),\n      .en_i          (icache_en_i),\n      .miss_o        (icache_miss_o),\n      .areq_i        (icache_areq_i),\n      .areq_o        (icache_areq_o),\n      .dreq_i        (icache_dreq_i),\n      .dreq_o        (icache_dreq_o),\n      .mem_rtrn_vld_i(icache_miss_resp_valid),\n      .mem_rtrn_i    (icache_miss_resp),\n      .mem_data_req_o(icache_miss_valid),\n      .mem_data_ack_i(icache_miss_ready),\n      .mem_data_o    (icache_miss)\n  );\n  //  }}}\n\n  //  D$ instantiation\n  //  {{{\n  `include \"hpdcache_typedef.svh\"\n\n  //    0: Page-Table Walk (PTW)\n  //    1: Load unit\n  //    2: Accelerator load\n  //    3: Store/AMO\n  //    .\n  //    .\n  //    .\n  //    NumPorts: CMO\n  //    NumPorts + 1: Hardware Memory Prefetcher (hwpf)\n  localparam int HPDCACHE_NREQUESTERS = NumPorts + 2;\n\n  typedef logic [riscv::PLEN-1:0] hpdcache_mem_addr_t;\n  typedef logic [ariane_pkg::MEM_TID_WIDTH-1:0] hpdcache_mem_id_t;\n  typedef logic [CVA6Cfg.AxiDataWidth-1:0] hpdcache_mem_data_t;\n  typedef logic [CVA6Cfg.AxiDataWidth/8-1:0] hpdcache_mem_be_t;\n  `HPDCACHE_TYPEDEF_MEM_REQ_T(hpdcache_mem_req_t, hpdcache_mem_addr_t, hpdcache_mem_id_t);\n  `HPDCACHE_TYPEDEF_MEM_RESP_R_T(hpdcache_mem_resp_r_t, hpdcache_mem_id_t, hpdcache_mem_data_t);\n  `HPDCACHE_TYPEDEF_MEM_REQ_W_T(hpdcache_mem_req_w_t, hpdcache_mem_data_t, hpdcache_mem_be_t);\n  `HPDCACHE_TYPEDEF_MEM_RESP_W_T(hpdcache_mem_resp_w_t, hpdcache_mem_id_t);\n\n  typedef logic [63:0] hwpf_stride_param_t;\n\n  logic                        dcache_req_valid[HPDCACHE_NREQUESTERS-1:0];\n  logic                        dcache_req_ready[HPDCACHE_NREQUESTERS-1:0];\n  hpdcache_pkg::hpdcache_req_t dcache_req      [HPDCACHE_NREQUESTERS-1:0];\n  logic                        dcache_req_abort[HPDCACHE_NREQUESTERS-1:0];\n  hpdcache_pkg::hpdcache_tag_t dcache_req_tag  [HPDCACHE_NREQUESTERS-1:0];\n  hpdcache_pkg::hpdcache_pma_t dcache_req_pma  [HPDCACHE_NREQUESTERS-1:0];\n  logic                        dcache_rsp_valid[HPDCACHE_NREQUESTERS-1:0];\n  hpdcache_pkg::hpdcache_rsp_t dcache_rsp      [HPDCACHE_NREQUESTERS-1:0];\n  logic dcache_read_miss, dcache_write_miss;\n\n  logic                                   [                2:0] snoop_valid;\n  logic                                   [                2:0] snoop_abort;\n  hpdcache_pkg::hpdcache_req_offset_t     [                2:0] snoop_addr_offset;\n  hpdcache_pkg::hpdcache_tag_t            [                2:0] snoop_addr_tag;\n  logic                                   [                2:0] snoop_phys_indexed;\n\n  logic                                                         dcache_cmo_req_is_prefetch;\n\n  logic                                                         dcache_miss_ready;\n  logic                                                         dcache_miss_valid;\n  hpdcache_mem_req_t                                            dcache_miss;\n\n  logic                                                         dcache_miss_resp_ready;\n  logic                                                         dcache_miss_resp_valid;\n  hpdcache_mem_resp_r_t                                         dcache_miss_resp;\n\n  logic                                                         dcache_wbuf_ready;\n  logic                                                         dcache_wbuf_valid;\n  hpdcache_mem_req_t                                            dcache_wbuf;\n\n  logic                                                         dcache_wbuf_data_ready;\n  logic                                                         dcache_wbuf_data_valid;\n  hpdcache_mem_req_w_t                                          dcache_wbuf_data;\n\n  logic                                                         dcache_wbuf_resp_ready;\n  logic                                                         dcache_wbuf_resp_valid;\n  hpdcache_mem_resp_w_t                                         dcache_wbuf_resp;\n\n  logic                                                         dcache_uc_read_ready;\n  logic                                                         dcache_uc_read_valid;\n  hpdcache_mem_req_t                                            dcache_uc_read;\n\n  logic                                                         dcache_uc_read_resp_ready;\n  logic                                                         dcache_uc_read_resp_valid;\n  hpdcache_mem_resp_r_t                                         dcache_uc_read_resp;\n\n  logic                                                         dcache_uc_write_ready;\n  logic                                                         dcache_uc_write_valid;\n  hpdcache_mem_req_t                                            dcache_uc_write;\n\n  logic                                                         dcache_uc_write_data_ready;\n  logic                                                         dcache_uc_write_data_valid;\n  hpdcache_mem_req_w_t                                          dcache_uc_write_data;\n\n  logic                                                         dcache_uc_write_resp_ready;\n  logic                                                         dcache_uc_write_resp_valid;\n  hpdcache_mem_resp_w_t                                         dcache_uc_write_resp;\n\n  hwpf_stride_pkg::hwpf_stride_throttle_t [NrHwPrefetchers-1:0] hwpf_throttle_in;\n  hwpf_stride_pkg::hwpf_stride_throttle_t [NrHwPrefetchers-1:0] hwpf_throttle_out;\n\n  generate\n    ariane_pkg::dcache_req_i_t dcache_req_ports[HPDCACHE_NREQUESTERS-1:0];\n\n    for (genvar r = 0; r < (NumPorts - 1); r++) begin : cva6_hpdcache_load_if_adapter_gen\n      assign dcache_req_ports[r] = dcache_req_ports_i[r];\n\n      cva6_hpdcache_if_adapter #(\n          .CVA6Cfg     (CVA6Cfg),\n          .is_load_port(1'b1)\n      ) i_cva6_hpdcache_load_if_adapter (\n          .clk_i,\n          .rst_ni,\n\n          .hpdcache_req_sid_i(hpdcache_pkg::hpdcache_req_sid_t'(r)),\n\n          .cva6_req_i     (dcache_req_ports[r]),\n          .cva6_req_o     (dcache_req_ports_o[r]),\n          .cva6_amo_req_i ('0),\n          .cva6_amo_resp_o(  /* unused */),\n\n          .hpdcache_req_valid_o(dcache_req_valid[r]),\n          .hpdcache_req_ready_i(dcache_req_ready[r]),\n          .hpdcache_req_o      (dcache_req[r]),\n          .hpdcache_req_abort_o(dcache_req_abort[r]),\n          .hpdcache_req_tag_o  (dcache_req_tag[r]),\n          .hpdcache_req_pma_o  (dcache_req_pma[r]),\n\n          .hpdcache_rsp_valid_i(dcache_rsp_valid[r]),\n          .hpdcache_rsp_i      (dcache_rsp[r])\n      );\n    end\n\n    cva6_hpdcache_if_adapter #(\n        .CVA6Cfg     (CVA6Cfg),\n        .is_load_port(1'b0)\n    ) i_cva6_hpdcache_store_if_adapter (\n        .clk_i,\n        .rst_ni,\n\n        .hpdcache_req_sid_i(hpdcache_pkg::hpdcache_req_sid_t'(NumPorts - 1)),\n\n        .cva6_req_i     (dcache_req_ports_i[NumPorts-1]),\n        .cva6_req_o     (dcache_req_ports_o[NumPorts-1]),\n        .cva6_amo_req_i (dcache_amo_req_i),\n        .cva6_amo_resp_o(dcache_amo_resp_o),\n\n        .hpdcache_req_valid_o(dcache_req_valid[NumPorts-1]),\n        .hpdcache_req_ready_i(dcache_req_ready[NumPorts-1]),\n        .hpdcache_req_o      (dcache_req[NumPorts-1]),\n        .hpdcache_req_abort_o(dcache_req_abort[NumPorts-1]),\n        .hpdcache_req_tag_o  (dcache_req_tag[NumPorts-1]),\n        .hpdcache_req_pma_o  (dcache_req_pma[NumPorts-1]),\n\n        .hpdcache_rsp_valid_i(dcache_rsp_valid[NumPorts-1]),\n        .hpdcache_rsp_i      (dcache_rsp[NumPorts-1])\n    );\n\n`ifdef HPDCACHE_ENABLE_CMO\n    cva6_hpdcache_cmo_if_adapter #(\n        .cmo_req_t(cmo_req_t),\n        .cmo_rsp_t(cmo_rsp_t)\n    ) i_cva6_hpdcache_cmo_if_adapter (\n        .clk_i,\n        .rst_ni,\n\n        .dcache_req_sid_i(hpdcache_pkg::hpdcache_req_sid_t'(NumPorts)),\n\n        .cva6_cmo_req_i (dcache_cmo_req_i),\n        .cva6_cmo_resp_o(dcache_cmo_resp_o),\n\n        .dcache_req_valid_o(dcache_req_valid[NumPorts]),\n        .dcache_req_ready_i(dcache_req_ready[NumPorts]),\n        .dcache_req_o      (dcache_req[NumPorts]),\n        .dcache_req_abort_o(dcache_req_abort[NumPorts]),\n        .dcache_req_tag_o  (dcache_req_tag[NumPorts]),\n        .dcache_req_pma_o  (dcache_req_pma[NumPorts]),\n\n        .dcache_rsp_valid_i(dcache_rsp_valid[NumPorts]),\n        .dcache_rsp_i      (dcache_rsp[NumPorts])\n    );\n`else\n    assign dcache_req_valid[NumPorts] = 1'b0,\n        dcache_req[NumPorts] = '0,\n        dcache_req_abort[NumPorts] = 1'b0,\n        dcache_req_tag[NumPorts] = '0,\n        dcache_req_pma[NumPorts] = '0;\n`endif\n  endgenerate\n\n  //  Snoop load port\n  assign snoop_valid[0] = dcache_req_valid[1] & dcache_req_ready[1],\n      snoop_abort[0] = dcache_req_abort[1],\n      snoop_addr_offset[0] = dcache_req[1].addr_offset,\n      snoop_addr_tag[0] = dcache_req_tag[1],\n      snoop_phys_indexed[0] = dcache_req[1].phys_indexed;\n\n  //  Snoop Store/AMO port\n  assign snoop_valid[1] = dcache_req_valid[NumPorts-1] & dcache_req_ready[NumPorts-1],\n      snoop_abort[1] = dcache_req_abort[NumPorts-1],\n      snoop_addr_offset[1] = dcache_req[NumPorts-1].addr_offset,\n      snoop_addr_tag[1] = dcache_req_tag[NumPorts-1],\n      snoop_phys_indexed[1] = dcache_req[NumPorts-1].phys_indexed;\n\n`ifdef HPDCACHE_ENABLE_CMO\n  //  Snoop CMO port (in case of read prefetch accesses)\n  assign dcache_cmo_req_is_prefetch = hpdcache_pkg::is_cmo_prefetch(\n      dcache_req[NumPorts].op, dcache_req[NumPorts].size\n  );\n  assign snoop_valid[2]        = dcache_req_valid[NumPorts]\n                               & dcache_req_ready[NumPorts]\n                               & dcache_cmo_req_is_prefetch,\n      snoop_abort[2] = dcache_req_abort[NumPorts],\n      snoop_addr_offset[2] = dcache_req[NumPorts].addr_offset,\n      snoop_addr_tag[2] = dcache_req_tag[NumPorts],\n      snoop_phys_indexed[2] = dcache_req[NumPorts].phys_indexed;\n`else\n  assign snoop_valid[2] = 1'b0,\n      snoop_abort[2] = 1'b0,\n      snoop_addr_offset[2] = '0,\n      snoop_addr_tag[2] = '0,\n      snoop_phys_indexed[2] = 1'b0;\n`endif\n\n  generate\n    for (genvar h = 0; h < NrHwPrefetchers; h++) begin : hwpf_throttle_gen\n      assign hwpf_throttle_in[h] = hwpf_stride_pkg::hwpf_stride_throttle_t'(hwpf_throttle_i[h]),\n          hwpf_throttle_o[h] = hwpf_stride_pkg::hwpf_stride_param_t'(hwpf_throttle_out[h]);\n    end\n  endgenerate\n\n  hwpf_stride_wrapper #(\n      .NUM_HW_PREFETCH(NrHwPrefetchers),\n      .NUM_SNOOP_PORTS(3)\n  ) i_hwpf_stride_wrapper (\n      .clk_i,\n      .rst_ni,\n\n      .hwpf_stride_base_set_i    (hwpf_base_set_i),\n      .hwpf_stride_base_i        (hwpf_base_i),\n      .hwpf_stride_base_o        (hwpf_base_o),\n      .hwpf_stride_param_set_i   (hwpf_param_set_i),\n      .hwpf_stride_param_i       (hwpf_param_i),\n      .hwpf_stride_param_o       (hwpf_param_o),\n      .hwpf_stride_throttle_set_i(hwpf_throttle_set_i),\n      .hwpf_stride_throttle_i    (hwpf_throttle_in),\n      .hwpf_stride_throttle_o    (hwpf_throttle_out),\n      .hwpf_stride_status_o      (hwpf_status_o),\n\n      .snoop_valid_i       (snoop_valid),\n      .snoop_abort_i       (snoop_abort),\n      .snoop_addr_offset_i (snoop_addr_offset),\n      .snoop_addr_tag_i    (snoop_addr_tag),\n      .snoop_phys_indexed_i(snoop_phys_indexed),\n\n      .hpdcache_req_sid_i(hpdcache_pkg::hpdcache_req_sid_t'(NumPorts + 1)),\n\n      .hpdcache_req_valid_o(dcache_req_valid[NumPorts+1]),\n      .hpdcache_req_ready_i(dcache_req_ready[NumPorts+1]),\n      .hpdcache_req_o      (dcache_req[NumPorts+1]),\n      .hpdcache_req_abort_o(dcache_req_abort[NumPorts+1]),\n      .hpdcache_req_tag_o  (dcache_req_tag[NumPorts+1]),\n      .hpdcache_req_pma_o  (dcache_req_pma[NumPorts+1]),\n      .hpdcache_rsp_valid_i(dcache_rsp_valid[NumPorts+1]),\n      .hpdcache_rsp_i      (dcache_rsp[NumPorts+1])\n  );\n\n  hpdcache #(\n      .NREQUESTERS         (HPDCACHE_NREQUESTERS),\n      .HPDcacheMemAddrWidth(riscv::PLEN),\n      .HPDcacheMemIdWidth  (ariane_pkg::MEM_TID_WIDTH),\n      .HPDcacheMemDataWidth(CVA6Cfg.AxiDataWidth)\n  ) i_hpdcache (\n      .clk_i,\n      .rst_ni,\n\n      .wbuf_flush_i(dcache_flush_i),\n\n      .core_req_valid_i(dcache_req_valid),\n      .core_req_ready_o(dcache_req_ready),\n      .core_req_i      (dcache_req),\n      .core_req_abort_i(dcache_req_abort),\n      .core_req_tag_i  (dcache_req_tag),\n      .core_req_pma_i  (dcache_req_pma),\n\n      .core_rsp_valid_o(dcache_rsp_valid),\n      .core_rsp_o      (dcache_rsp),\n\n      .mem_req_miss_read_ready_i(dcache_miss_ready),\n      .mem_req_miss_read_valid_o(dcache_miss_valid),\n      .mem_req_miss_read_o      (dcache_miss),\n\n      .mem_resp_miss_read_ready_o(dcache_miss_resp_ready),\n      .mem_resp_miss_read_valid_i(dcache_miss_resp_valid),\n      .mem_resp_miss_read_i      (dcache_miss_resp),\n\n      .mem_req_wbuf_write_ready_i(dcache_wbuf_ready),\n      .mem_req_wbuf_write_valid_o(dcache_wbuf_valid),\n      .mem_req_wbuf_write_o      (dcache_wbuf),\n\n      .mem_req_wbuf_write_data_ready_i(dcache_wbuf_data_ready),\n      .mem_req_wbuf_write_data_valid_o(dcache_wbuf_data_valid),\n      .mem_req_wbuf_write_data_o      (dcache_wbuf_data),\n\n      .mem_resp_wbuf_write_ready_o(dcache_wbuf_resp_ready),\n      .mem_resp_wbuf_write_valid_i(dcache_wbuf_resp_valid),\n      .mem_resp_wbuf_write_i      (dcache_wbuf_resp),\n\n      .mem_req_uc_read_ready_i(dcache_uc_read_ready),\n      .mem_req_uc_read_valid_o(dcache_uc_read_valid),\n      .mem_req_uc_read_o      (dcache_uc_read),\n\n      .mem_resp_uc_read_ready_o(dcache_uc_read_resp_ready),\n      .mem_resp_uc_read_valid_i(dcache_uc_read_resp_valid),\n      .mem_resp_uc_read_i      (dcache_uc_read_resp),\n\n      .mem_req_uc_write_ready_i(dcache_uc_write_ready),\n      .mem_req_uc_write_valid_o(dcache_uc_write_valid),\n      .mem_req_uc_write_o      (dcache_uc_write),\n\n      .mem_req_uc_write_data_ready_i(dcache_uc_write_data_ready),\n      .mem_req_uc_write_data_valid_o(dcache_uc_write_data_valid),\n      .mem_req_uc_write_data_o      (dcache_uc_write_data),\n\n      .mem_resp_uc_write_ready_o(dcache_uc_write_resp_ready),\n      .mem_resp_uc_write_valid_i(dcache_uc_write_resp_valid),\n      .mem_resp_uc_write_i      (dcache_uc_write_resp),\n\n      .evt_cache_write_miss_o(dcache_write_miss),\n      .evt_cache_read_miss_o (dcache_read_miss),\n      .evt_uncached_req_o    (  /* unused */),\n      .evt_cmo_req_o         (  /* unused */),\n      .evt_write_req_o       (  /* unused */),\n      .evt_read_req_o        (  /* unused */),\n      .evt_prefetch_req_o    (  /* unused */),\n      .evt_req_on_hold_o     (  /* unused */),\n      .evt_rtab_rollback_o   (  /* unused */),\n      .evt_stall_refill_o    (  /* unused */),\n      .evt_stall_o           (  /* unused */),\n\n      .wbuf_empty_o(wbuffer_empty_o),\n\n      .cfg_enable_i                       (dcache_enable_i),\n      .cfg_wbuf_threshold_i               (4'd2),\n      .cfg_wbuf_reset_timecnt_on_write_i  (1'b1),\n      .cfg_wbuf_sequential_waw_i          (1'b0),\n      .cfg_wbuf_inhibit_write_coalescing_i(1'b0),\n      .cfg_prefetch_updt_plru_i           (1'b1),\n      .cfg_error_on_cacheable_amo_i       (1'b0),\n      .cfg_rtab_single_entry_i            (1'b0)\n  );\n\n  assign dcache_miss_o = dcache_read_miss, wbuffer_not_ni_o = wbuffer_empty_o;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : dcache_flush_ff\n    if (!rst_ni) dcache_flush_ack_o <= 1'b0;\n    else dcache_flush_ack_o <= ~dcache_flush_ack_o & dcache_flush_i;\n  end\n\n  //  }}}\n\n  //  AXI arbiter instantiation\n  //  {{{\n  cva6_hpdcache_subsystem_axi_arbiter #(\n      .HPDcacheMemIdWidth   (ariane_pkg::MEM_TID_WIDTH),\n      .HPDcacheMemDataWidth (CVA6Cfg.AxiDataWidth),\n      .hpdcache_mem_req_t   (hpdcache_mem_req_t),\n      .hpdcache_mem_req_w_t (hpdcache_mem_req_w_t),\n      .hpdcache_mem_resp_r_t(hpdcache_mem_resp_r_t),\n      .hpdcache_mem_resp_w_t(hpdcache_mem_resp_w_t),\n\n      .AxiAddrWidth (CVA6Cfg.AxiAddrWidth),\n      .AxiDataWidth (CVA6Cfg.AxiDataWidth),\n      .AxiIdWidth   (CVA6Cfg.AxiIdWidth),\n      .AxiUserWidth (CVA6Cfg.AxiUserWidth),\n      .axi_ar_chan_t"}
{"text": "(axi_ar_chan_t),\n      .axi_aw_chan_t(axi_aw_chan_t),\n      .axi_w_chan_t (axi_w_chan_t),\n      .axi_b_chan_t (axi_b_chan_t),\n      .axi_r_chan_t (axi_r_chan_t),\n      .axi_req_t    (noc_req_t),\n      .axi_rsp_t    (noc_resp_t)\n  ) i_axi_arbiter (\n      .clk_i,\n      .rst_ni,\n\n      .icache_miss_valid_i(icache_miss_valid),\n      .icache_miss_ready_o(icache_miss_ready),\n      .icache_miss_i      (icache_miss),\n      .icache_miss_id_i   (hpdcache_mem_id_t'(ICACHE_RDTXID)),\n\n      .icache_miss_resp_valid_o(icache_miss_resp_valid),\n      .icache_miss_resp_o      (icache_miss_resp),\n\n      .dcache_miss_ready_o(dcache_miss_ready),\n      .dcache_miss_valid_i(dcache_miss_valid),\n      .dcache_miss_i      (dcache_miss),\n\n      .dcache_miss_resp_ready_i(dcache_miss_resp_ready),\n      .dcache_miss_resp_valid_o(dcache_miss_resp_valid),\n      .dcache_miss_resp_o      (dcache_miss_resp),\n\n      .dcache_wbuf_ready_o(dcache_wbuf_ready),\n      .dcache_wbuf_valid_i(dcache_wbuf_valid),\n      .dcache_wbuf_i      (dcache_wbuf),\n\n      .dcache_wbuf_data_ready_o(dcache_wbuf_data_ready),\n      .dcache_wbuf_data_valid_i(dcache_wbuf_data_valid),\n      .dcache_wbuf_data_i      (dcache_wbuf_data),\n\n      .dcache_wbuf_resp_ready_i(dcache_wbuf_resp_ready),\n      .dcache_wbuf_resp_valid_o(dcache_wbuf_resp_valid),\n      .dcache_wbuf_resp_o      (dcache_wbuf_resp),\n\n      .dcache_uc_read_ready_o(dcache_uc_read_ready),\n      .dcache_uc_read_valid_i(dcache_uc_read_valid),\n      .dcache_uc_read_i      (dcache_uc_read),\n      .dcache_uc_read_id_i   ('1),\n\n      .dcache_uc_read_resp_ready_i(dcache_uc_read_resp_ready),\n      .dcache_uc_read_resp_valid_o(dcache_uc_read_resp_valid),\n      .dcache_uc_read_resp_o      (dcache_uc_read_resp),\n\n      .dcache_uc_write_ready_o(dcache_uc_write_ready),\n      .dcache_uc_write_valid_i(dcache_uc_write_valid),\n      .dcache_uc_write_i      (dcache_uc_write),\n      .dcache_uc_write_id_i   ('1),\n\n      .dcache_uc_write_data_ready_o(dcache_uc_write_data_ready),\n      .dcache_uc_write_data_valid_i(dcache_uc_write_data_valid),\n      .dcache_uc_write_data_i      (dcache_uc_write_data),\n\n      .dcache_uc_write_resp_ready_i(dcache_uc_write_resp_ready),\n      .dcache_uc_write_resp_valid_o(dcache_uc_write_resp_valid),\n      .dcache_uc_write_resp_o      (dcache_uc_write_resp),\n\n      .axi_req_o (noc_req_o),\n      .axi_resp_i(noc_resp_i)\n  );\n  //  }}}\n\n  //  Assertions\n  //  {{{\n  //  pragma translate_off\n  initial\n    assert (hpdcache_pkg::HPDCACHE_REQ_SRC_ID_WIDTH >= $clog2(HPDCACHE_NREQUESTERS))\n    else $fatal(1, \"HPDCACHE_REQ_SRC_ID_WIDTH is not wide enough\");\n\n  a_invalid_instruction_fetch :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) icache_dreq_o.valid |-> (|icache_dreq_o.data) !== 1'hX)\n  else\n    $warning(\n        1,\n        \"[l1 dcache] reading invalid instructions: vaddr=%08X, data=%08X\",\n        icache_dreq_o.vaddr,\n        icache_dreq_o.data\n    );\n\n  a_invalid_write_data :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) dcache_req_ports_i[2].data_req |-> |dcache_req_ports_i[2].data_be |-> (|dcache_req_ports_i[2].data_wdata) !== 1'hX)\n  else\n    $warning(\n        1,\n        \"[l1 dcache] writing invalid data: paddr=%016X, be=%02X, data=%016X\",\n        {\n          dcache_req_ports_i[2].address_tag, dcache_req_ports_i[2].address_index\n        },\n        dcache_req_ports_i[2].data_be,\n        dcache_req_ports_i[2].data_wdata\n    );\n\n  for (genvar j = 0; j < 2; j++) begin : gen_assertion\n    a_invalid_read_data :\n    assert property (\n      @(posedge clk_i) disable iff (!rst_ni) dcache_req_ports_o[j].data_rvalid && ~dcache_req_ports_i[j].kill_req |-> (|dcache_req_ports_o[j].data_rdata) !== 1'hX)\n    else\n      $warning(\n          1,\n          \"[l1 dcache] reading invalid data on port %01d: data=%016X\",\n          j,\n          dcache_req_ports_o[j].data_rdata\n      );\n  end\n  //  pragma translate_on\n  //  }}}\n\nendmodule : cva6_hpdcache_subsystem\n"}
{"text": "// Copyright 2023 Commissariat a l'Energie Atomique et aux Energies\n//                Alternatives (CEA)\n//\n// Licensed under the Solderpad Hardware License, Version 2.1 (the \u201cLicense\u201d);\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Authors: Cesar Fuguet\n// Date: February, 2023\n// Description: AXI arbiter for the CVA6 cache subsystem integrating standard\n//              CVA6's instruction cache and the Core-V High-Performance\n//              L1 Dcache (CV-HPDcache).\n\nmodule cva6_hpdcache_subsystem_axi_arbiter\n//  Parameters\n//  {{{\n#(\n    parameter int HPDcacheMemIdWidth = 8,\n    parameter int HPDcacheMemDataWidth = 512,\n    parameter type hpdcache_mem_req_t = logic,\n    parameter type hpdcache_mem_req_w_t = logic,\n    parameter type hpdcache_mem_resp_r_t = logic,\n    parameter type hpdcache_mem_resp_w_t = logic,\n\n    parameter int unsigned AxiAddrWidth = 1,\n    parameter int unsigned AxiDataWidth = 1,\n    parameter int unsigned AxiIdWidth = 1,\n    parameter int unsigned AxiUserWidth = 1,\n    parameter type axi_ar_chan_t = logic,\n    parameter type axi_aw_chan_t = logic,\n    parameter type axi_w_chan_t = logic,\n    parameter type axi_b_chan_t = logic,\n    parameter type axi_r_chan_t = logic,\n    parameter type axi_req_t = logic,\n    parameter type axi_rsp_t = logic,\n\n    localparam type hpdcache_mem_id_t = logic [HPDcacheMemIdWidth-1:0]\n)\n//  }}}\n\n//  Ports\n//  {{{\n(\n    input logic clk_i,\n    input logic rst_ni,\n\n    //  Interfaces from/to I$\n    //  {{{\n    input  logic                      icache_miss_valid_i,\n    output logic                      icache_miss_ready_o,\n    input  wt_cache_pkg::icache_req_t icache_miss_i,\n    input  hpdcache_mem_id_t          icache_miss_id_i,\n\n    output logic                       icache_miss_resp_valid_o,\n    output wt_cache_pkg::icache_rtrn_t icache_miss_resp_o,\n    //  }}}\n\n    //  Interfaces from/to D$\n    //  {{{\n    output logic              dcache_miss_ready_o,\n    input  logic              dcache_miss_valid_i,\n    input  hpdcache_mem_req_t dcache_miss_i,\n\n    input  logic                 dcache_miss_resp_ready_i,\n    output logic                 dcache_miss_resp_valid_o,\n    output hpdcache_mem_resp_r_t dcache_miss_resp_o,\n\n    //      Write-buffer write interface\n    output logic              dcache_wbuf_ready_o,\n    input  logic              dcache_wbuf_valid_i,\n    input  hpdcache_mem_req_t dcache_wbuf_i,\n\n    output logic                dcache_wbuf_data_ready_o,\n    input  logic                dcache_wbuf_data_valid_i,\n    input  hpdcache_mem_req_w_t dcache_wbuf_data_i,\n\n    input  logic                 dcache_wbuf_resp_ready_i,\n    output logic                 dcache_wbuf_resp_valid_o,\n    output hpdcache_mem_resp_w_t dcache_wbuf_resp_o,\n\n    //      Uncached read interface\n    output logic              dcache_uc_read_ready_o,\n    input  logic              dcache_uc_read_valid_i,\n    input  hpdcache_mem_req_t dcache_uc_read_i,\n    input  hpdcache_mem_id_t  dcache_uc_read_id_i,\n\n    input  logic                 dcache_uc_read_resp_ready_i,\n    output logic                 dcache_uc_read_resp_valid_o,\n    output hpdcache_mem_resp_r_t dcache_uc_read_resp_o,\n\n    //      Uncached write interface\n    output logic              dcache_uc_write_ready_o,\n    input  logic              dcache_uc_write_valid_i,\n    input  hpdcache_mem_req_t dcache_uc_write_i,\n    input  hpdcache_mem_id_t  dcache_uc_write_id_i,\n\n    output logic                dcache_uc_write_data_ready_o,\n    input  logic                dcache_uc_write_data_valid_i,\n    input  hpdcache_mem_req_w_t dcache_uc_write_data_i,\n\n    input  logic                 dcache_uc_write_resp_ready_i,\n    output logic                 dcache_uc_write_resp_valid_o,\n    output hpdcache_mem_resp_w_t dcache_uc_write_resp_o,\n    //  }}}\n\n    //  AXI port to upstream memory/peripherals\n    //  {{{\n    output axi_req_t axi_req_o,\n    input  axi_rsp_t axi_resp_i\n    //  }}}\n);\n  //  }}}\n\n  //  Internal type definitions\n  //  {{{\n\n  localparam int MEM_RESP_RT_DEPTH = (1 << HPDcacheMemIdWidth);\n  typedef hpdcache_mem_id_t [MEM_RESP_RT_DEPTH-1:0] mem_resp_rt_t;\n  typedef logic [ariane_pkg::ICACHE_LINE_WIDTH-1:0] icache_resp_data_t;\n  //  }}}\n\n  //  Adapt the I$ interface to the HPDcache memory interface\n  //  {{{\n  localparam int ICACHE_CL_WORDS = ariane_pkg::ICACHE_LINE_WIDTH / 64;\n  localparam int ICACHE_CL_WORD_INDEX = $clog2(ICACHE_CL_WORDS);\n  localparam int ICACHE_CL_SIZE = $clog2(ariane_pkg::ICACHE_LINE_WIDTH / 8);\n  localparam int ICACHE_WORD_SIZE = 3;\n  localparam int ICACHE_MEM_REQ_CL_LEN =\n    (ariane_pkg::ICACHE_LINE_WIDTH + HPDcacheMemDataWidth - 1)/HPDcacheMemDataWidth;\n  localparam int ICACHE_MEM_REQ_CL_SIZE =\n    (HPDcacheMemDataWidth <= ariane_pkg::ICACHE_LINE_WIDTH) ?\n      $clog2(\n      HPDcacheMemDataWidth / 8\n  ) : ICACHE_CL_SIZE;\n\n  //    I$ request\n  hpdcache_mem_req_t icache_miss_req_wdata;\n  logic icache_miss_req_w, icache_miss_req_wok;\n\n  hpdcache_mem_req_t icache_miss_req_rdata;\n  logic icache_miss_req_r, icache_miss_req_rok;\n\n  logic icache_miss_pending_q;\n\n  //  This FIFO has two functionnalities:\n  //  -  Stabilize the ready-valid protocol. The ICACHE can abort a valid\n  //     transaction without receiving the corresponding ready signal. This\n  //     behavior is not supported by AXI.\n  //  -  Cut a possible long timing path.\n  hpdcache_fifo_reg #(\n      .FIFO_DEPTH (1),\n      .fifo_data_t(hpdcache_mem_req_t)\n  ) i_icache_miss_req_fifo (\n      .clk_i,\n      .rst_ni,\n\n      .w_i    (icache_miss_req_w),\n      .wok_o  (icache_miss_req_wok),\n      .wdata_i(icache_miss_req_wdata),\n\n      .r_i    (icache_miss_req_r),\n      .rok_o  (icache_miss_req_rok),\n      .rdata_o(icache_miss_req_rdata)\n  );\n\n  assign icache_miss_req_w = icache_miss_valid_i, icache_miss_ready_o = icache_miss_req_wok;\n\n  assign icache_miss_req_wdata.mem_req_addr = icache_miss_i.paddr,\n      icache_miss_req_wdata.mem_req_len = icache_miss_i.nc ? 0 : ICACHE_MEM_REQ_CL_LEN - 1,\n      icache_miss_req_wdata.mem_req_size      = icache_miss_i.nc ? ICACHE_WORD_SIZE : ICACHE_MEM_REQ_CL_SIZE,\n      icache_miss_req_wdata.mem_req_id = icache_miss_i.tid,\n      icache_miss_req_wdata.mem_req_command = hpdcache_pkg::HPDCACHE_MEM_READ,\n      icache_miss_req_wdata.mem_req_atomic = hpdcache_pkg::hpdcache_mem_atomic_e'(0),\n      icache_miss_req_wdata.mem_req_cacheable = ~icache_miss_i.nc;\n\n\n  //    I$ response\n  logic icache_miss_resp_w, icache_miss_resp_wok;\n  hpdcache_mem_resp_r_t icache_miss_resp_wdata;\n\n  logic icache_miss_resp_data_w, icache_miss_resp_data_wok;\n  logic icache_miss_resp_data_r, icache_miss_resp_data_rok;\n  icache_resp_data_t icache_miss_resp_data_rdata;\n\n  logic icache_miss_resp_meta_w, icache_miss_resp_meta_wok;\n  logic icache_miss_resp_meta_r, icache_miss_resp_meta_rok;\n  hpdcache_mem_id_t  icache_miss_resp_meta_id;\n\n  icache_resp_data_t icache_miss_rdata;\n\n  generate\n    if (HPDcacheMemDataWidth < ariane_pkg::ICACHE_LINE_WIDTH) begin\n      hpdcache_fifo_reg #(\n          .FIFO_DEPTH (1),\n          .fifo_data_t(hpdcache_mem_id_t)\n      ) i_icache_refill_meta_fifo (\n          .clk_i,\n          .rst_ni,\n\n          .w_i    (icache_miss_resp_meta_w),\n          .wok_o  (icache_miss_resp_meta_wok),\n          .wdata_i(icache_miss_resp_wdata.mem_resp_r_id),\n\n          .r_i    (icache_miss_resp_meta_r),\n          .rok_o  (icache_miss_resp_meta_rok),\n          .rdata_o(icache_miss_resp_meta_id)\n      );\n\n      hpdcache_data_upsize #(\n          .WR_WIDTH(HPDcacheMemDataWidth),\n          .RD_WIDTH(ariane_pkg::ICACHE_LINE_WIDTH),\n          .DEPTH   (1)\n      ) i_icache_hpdcache_data_upsize (\n          .clk_i,\n          .rst_ni,\n\n          .w_i    (icache_miss_resp_data_w),\n          .wlast_i(icache_miss_resp_wdata.mem_resp_r_last),\n          .wok_o  (icache_miss_resp_data_wok),\n          .wdata_i(icache_miss_resp_wdata.mem_resp_r_data),\n\n          .r_i    (icache_miss_resp_data_r),\n          .rok_o  (icache_miss_resp_data_rok),\n          .rdata_o(icache_miss_resp_data_rdata)\n      );\n\n      assign icache_miss_resp_meta_r = 1'b1, icache_miss_resp_data_r = 1'b1;\n\n      assign icache_miss_resp_meta_w = icache_miss_resp_w & icache_miss_resp_wdata.mem_resp_r_last;\n\n      assign icache_miss_resp_data_w = icache_miss_resp_w;\n\n      assign icache_miss_resp_wok = icache_miss_resp_data_wok & (\n               icache_miss_resp_meta_wok | ~icache_miss_resp_wdata.mem_resp_r_last);\n\n      assign icache_miss_rdata = icache_miss_resp_data_rdata;\n\n    end else begin\n      assign icache_miss_resp_data_rok = icache_miss_resp_w;\n      assign icache_miss_resp_meta_rok = icache_miss_resp_w;\n      assign icache_miss_resp_wok = 1'b1;\n      assign icache_miss_resp_meta_id = icache_miss_resp_wdata.mem_resp_r_id;\n      assign icache_miss_resp_data_rdata = icache_miss_resp_wdata.mem_resp_r_data;\n\n      //  In the case of uncacheable accesses, the Icache expects the data to be right-aligned\n      always_comb begin : icache_miss_resp_data_comb\n        if (!icache_miss_req_rdata.mem_req_cacheable) begin\n          automatic logic [ICACHE_CL_WORD_INDEX - 1:0] icache_miss_word_index;\n          automatic logic [63:0] icache_miss_word;\n          icache_miss_word_index = icache_miss_req_rdata.mem_req_addr[3+:ICACHE_CL_WORD_INDEX];\n          icache_miss_word = icache_miss_resp_data_rdata[icache_miss_word_index*64+:64];\n          icache_miss_rdata = {{ariane_pkg::ICACHE_LINE_WIDTH - 64{1'b0}}, icache_miss_word};\n        end else begin\n          icache_miss_rdata = icache_miss_resp_data_rdata;\n        end\n      end\n    end\n  endgenerate\n\n  assign icache_miss_resp_valid_o = icache_miss_resp_meta_rok,\n      icache_miss_resp_o.rtype = wt_cache_pkg::ICACHE_IFILL_ACK,\n      icache_miss_resp_o.user = '0,\n      icache_miss_resp_o.inv = '0,\n      icache_miss_resp_o.tid = icache_miss_resp_meta_id,\n      icache_miss_resp_o.data = icache_miss_rdata;\n\n  //  consume the Icache miss on the arrival of the response. The request\n  //  metadata is decoded to forward the correct word in case of uncacheable\n  //  Icache access\n  assign icache_miss_req_r = icache_miss_resp_meta_rok;\n  //  }}}\n\n  //  Read request arbiter\n  //  {{{\n  logic              mem_req_read_ready     [2:0];\n  logic              mem_req_read_valid     [2:0];\n  hpdcache_mem_req_t mem_req_read           [2:0];\n\n  logic              mem_req_read_ready_arb;\n  logic              mem_req_read_valid_arb;\n  hpdcache_mem_req_t mem_req_read_arb;\n\n  assign mem_req_read_valid[0] = icache_miss_req_rok & ~icache_miss_pending_q,\n      mem_req_read[0] = icache_miss_req_rdata;\n\n  assign dcache_miss_ready_o = mem_req_read_ready[1],\n      mem_req_read_valid[1] = dcache_miss_valid_i,\n      mem_req_read[1] = dcache_miss_i;\n\n  assign dcache_uc_read_ready_o = mem_req_read_ready[2],\n      mem_req_read_valid[2] = dcache_uc_read_valid_i,\n      mem_req_read[2] = dcache_uc_read_i;\n\n  hpdcache_mem_req_read_arbiter #(\n      .N                 (3),\n      .hpdcache_mem_req_t(hpdcache_mem_req_t)\n  ) i_mem_req_read_arbiter (\n      .clk_i,\n      .rst_ni,\n\n      .mem_req_read_ready_o(mem_req_read_ready),\n      .mem_req_read_valid_i(mem_req_read_valid),\n      .mem_req_read_i      (mem_req_read),\n\n      .mem_req_read_ready_i(mem_req_read_ready_arb),\n      .mem_req_read_valid_o(mem_req_read_valid_arb),\n      .mem_req_read_o      (mem_req_read_arb)\n  );\n  //  }}}\n\n  //  Read response demultiplexor\n  //  {{{\n  logic                 mem_resp_read_ready;\n  logic                 mem_resp_read_valid;\n  hpdcache_mem_resp_r_t mem_resp_read;\n\n  logic                 mem_resp_read_ready_arb[2:0];\n  logic                 mem_resp_read_valid_arb[2:0];\n  hpdcache_mem_resp_r_t mem_resp_read_arb      [2:0];\n\n  mem_resp_rt_t         mem_resp_read_rt;\n\n  always_comb begin\n    for (int i = 0; i < MEM_RESP_RT_DEPTH; i++) begin\n      mem_resp_read_rt[i] = (i == int'(   icache_miss_id_i)) ? 0 :\n                            (i == int'(dcache_uc_read_id_i)) ? 2 : 1;\n    end\n  end\n\n  hpdcache_mem_resp_demux #(\n      .N        (3),\n      .resp_t   (hpdcache_mem_resp_r_t),\n      .resp_id_t(hpdcache_mem_id_t)\n  ) i_mem_resp_read_demux (\n      .clk_i,\n      .rst_ni,\n\n      .mem_resp_ready_o(mem_resp_read_ready),\n      .mem_resp_valid_i(mem_resp_read_valid),\n      .mem_resp_id_i   (mem_resp_read.mem_resp_r_id),\n      .mem_resp_i      (mem_resp_read),\n\n      .mem_resp_ready_i(mem_resp_read_ready_arb),\n      .mem_resp_valid_o(mem_resp_read_valid_arb),\n      .mem_resp_o      (mem_resp_read_arb),\n\n      .mem_resp_rt_i(mem_resp_read_rt)\n  );\n\n  assign icache_miss_resp_w = mem_resp_read_valid_arb[0],\n      icache_miss_resp_wdata = mem_resp_read_arb[0],\n      mem_resp_read_ready_arb[0] = icache_miss_resp_wok;\n\n  assign dcache_miss_resp_valid_o = mem_resp_read_valid_arb[1],\n      dcache_miss_resp_o = mem_resp_read_arb[1],\n      mem_resp_read_ready_arb[1] = dcache_miss_resp_ready_i;\n\n  assign dcache_uc_read_resp_valid_o = mem_resp_read_valid_arb[2],\n      dcache_uc_read_resp_o = mem_resp_read_arb[2],\n      mem_resp_read_ready_arb[2] = dcache_uc_read_resp_ready_i;\n  //  }}}\n\n  //  Write request arbiter\n  //  {{{\n  logic                mem_req_write_ready          [1:0];\n  logic                mem_req_write_valid          [1:0];\n  hpdcache_mem_req_t   mem_req_write                [1:0];\n\n  logic                mem_req_write_data_ready     [1:0];\n  logic                mem_req_write_data_valid     [1:0];\n  hpdcache_mem_req_w_t mem_req_write_data           [1:0];\n\n  logic                mem_req_write_ready_arb;\n  logic                mem_req_write_valid_arb;\n  hpdcache_mem_req_t   mem_req_write_arb;\n\n  logic                mem_req_write_data_ready_arb;\n  logic                mem_req_write_data_valid_arb;\n  hpdcache_mem_req_w_t mem_req_write_data_arb;\n\n  assign dcache_wbuf_ready_o = mem_req_write_ready[0],\n      mem_req_write_valid[0] = dcache_wbuf_valid_i,\n      mem_req_write[0] = dcache_wbuf_i;\n\n  assign dcache_wbuf_data_ready_o = mem_req_write_data_ready[0],\n      mem_req_write_data_valid[0] = dcache_wbuf_data_valid_i,\n      mem_req_write_data[0] = dcache_wbuf_data_i;\n\n  assign dcache_uc_write_ready_o = mem_req_write_ready[1],\n      mem_req_write_valid[1] = dcache_uc_write_valid_i,\n      mem_req_write[1] = dcache_uc_write_i;\n\n  assign dcache_uc_write_data_ready_o = mem_req_write_data_ready[1],\n      mem_req_write_data_valid[1] = dcache_uc_write_data_valid_i,\n      mem_req_write_data[1] = dcache_uc_write_data_i;\n\n  hpdcache_mem_req_write_arbiter #(\n      .N                   (2),\n      .hpdcache_mem_req_t  (hpdcache_mem_req_t),\n      .hpdcache_mem_req_w_t(hpdcache_mem_req_w_t)\n  ) i_mem_req_write_arbiter (\n      .clk_i,\n      .rst_ni,\n\n      .mem_req_write_ready_o(mem_req_write_ready),\n      .mem_req_write_valid_i(mem_req_write_valid),\n      .mem_req_write_i      (mem_req_write),\n\n      .mem_req_write_data_ready_o(mem_req_write_data_ready),\n      .mem_req_write_data_valid_i(mem_req_write_data_valid),\n      .mem_req_write_data_i      (mem_req_write_data),\n\n      .mem_req_write_ready_i(mem_req_write_ready_arb),\n      .mem_req_write_valid_o(mem_req_write_valid_arb),\n      .mem_req_write_o      (mem_req_write_arb),\n\n      .mem_req_write_data_ready_i(mem_req_write_data_ready_arb),\n      .mem_req_write_data_valid_o(mem_req_write_data_valid_arb),\n      .mem_req_write_data_o      (mem_req_write_data_arb)\n  );\n  //  }}}\n\n  //  Write response demultiplexor\n  //  {{{\n  logic                 mem_resp_write_ready;\n  logic                 mem_resp_write_valid;\n  hpdcache_mem_resp_w_t mem_resp_write;\n\n  logic                 mem_resp_write_ready_arb[1:0];\n  logic                 mem_resp_write_valid_arb[1:0];\n  hpdcache_mem_resp_w_t mem_resp_write_arb      [1:0];\n\n  mem_resp_rt_t         mem_resp_write_rt;\n\n  always_comb begin\n    for (int i = 0; i < MEM_RESP_RT_DEPTH; i++) begin\n      mem_resp_write_rt[i] = (i == int'(dcache_uc_write_id_i)) ? 1 : 0;\n    end\n  end\n\n  hpdcache_mem_resp_demux #(\n      .N        (2),\n      .resp_t   (hpdcache_mem_resp_w_t),\n      .resp_id_t(hpdcache_mem_id_t)\n  ) i_hpdcache_mem_resp_write_demux (\n      .clk_i,\n      .rst_ni,\n\n      .mem_resp_ready_o(mem_resp_write_ready),\n      .mem_resp_valid_i(mem_resp_write_valid),\n      .mem_resp_id_i   (mem_resp_write.mem_resp_w_id),\n      .mem_resp_i      (mem_resp_write),\n\n      .mem_resp_ready_i(mem_resp_write_ready_arb),\n      .mem_resp_valid_o(mem_resp_write_valid_arb),\n      .mem_resp_o      (mem_resp_write_arb),\n\n      .mem_resp_rt_i(mem_resp_write_rt)\n  );\n\n  assign dcache_wbuf_resp_valid_o = mem_resp_write_valid_arb[0],\n      dcache_wbuf_resp_o = mem_resp_write_arb[0],\n      mem_resp_write_ready_arb[0] = dcache_wbuf_resp_ready_i;\n\n  assign dcache_uc_write_resp_valid_o = mem_resp_write_valid_arb[1],\n      dcache_uc_write_resp_o = mem_resp_write_arb[1],\n      mem_resp_write_ready_arb[1] = dcache_uc_write_resp_ready_i;\n  //  }}}\n\n  //  I$ miss pending\n  //  {{{\n  always_ff @(posedge clk_i or negedge rst_ni) begin : icache_miss_pending_ff\n    if (!rst_ni) begin\n      icache_miss_pending_q <= 1'b0;\n    end else begin\n      icache_miss_pending_q <= ( (icache_miss_req_rok & mem_req_read_ready[0]) & ~icache_miss_pending_q) |\n                               (~(icache_miss_req_r   & icache_miss_req_rok)   &  icache_miss_pending_q);\n    end\n  end\n  // }}}\n\n  //  AXI adapters\n  //  {{{\n\n  hpdcache_mem_to_axi_write #(\n      .hpdcache_mem_req_t   (hpdcache_mem_req_t),\n      .hpdcache_mem_req_w_t (hpdcache_mem_req_w_t),\n      .hpdcache_mem_resp_w_t(hpdcache_mem_resp_w_t),\n      .aw_chan_t            (axi_aw_chan_t),\n      .w_chan_t             (axi_w_chan_t),\n      .b_chan_t             (axi_b_chan_t)\n  ) i_hpdcache_mem_to_axi_write (\n      .req_ready_o(mem_req_write_ready_arb),\n      .req_valid_i(mem_req_write_valid_arb),\n      .req_i      (mem_req_write_arb),\n\n      .req_data_ready_o(mem_req_write_data_ready_arb),\n      .req_data_valid_i(mem_req_write_data_valid_arb),\n      .req_data_i      (mem_req_write_data_arb),\n\n      .resp_ready_i(mem_resp_write_ready),\n      .resp_valid_o(mem_resp_write_valid),\n      .resp_o      (mem_resp_write),\n\n      .axi_aw_valid_o(axi_req_o.aw_valid),\n      .axi_aw_o      (axi_req_o.aw),\n      .axi_aw_ready_i(axi_resp_i.aw_ready),\n\n      .axi_w_valid_o(axi_req_o.w_valid),\n      .axi_w_o      (axi_req_o.w),\n      .axi_w_ready_i(axi_resp_i.w_ready),\n\n      .axi_b_valid_i(axi_resp_i.b_valid),\n      .axi_b_i      (axi_resp_i.b),\n      .axi_b_ready_o(axi_req_o.b_ready)\n  );\n\n  hpdcache_mem_to_axi_read #(\n      .hpdcache_mem_req_t   (hpdcache_mem_req_t),\n      .hpdcache_mem_resp_r_t(hpdcache_mem_resp_r_t),\n      .ar_chan_t            (axi_ar_chan_t),\n      .r_chan_t             (axi_r_chan_t)\n  ) i_hpdcache_mem_to_axi_read (\n      .req_ready_o(mem_req_read_ready_arb),\n      .req_valid_i(mem_req_read_valid_arb),\n      .req_i      (mem_req_read_arb),\n\n      .resp_ready_i(mem_resp_read_ready),\n      .resp_valid_o(mem_resp_read_valid),\n      .resp_o      (mem_resp_read),\n\n      .axi_ar_valid_o(axi_req_o.ar_valid),\n      .axi_ar_o      (axi_req_o.ar),\n      .axi_ar_ready_i(axi_resp_i.ar_ready),\n\n      .axi_r_valid_i(axi_resp_i.r_valid),\n      .axi_r_i      (axi_resp_i.r),\n      .axi_r_ready_o(axi_req_o.r_ready)\n  );\n\n  //  }}}\n\n  //  Assertions\n  //  {{{\n  //  pragma translate_off\n  initial\n    assert (HPDcacheMemIdWidth <= AxiIdWidth)\n    else $fatal(\"HPDcacheMemIdWidth shall be less or equal to AxiIdWidth\");\n  initial\n    assert (HPDcacheMemIdWidth >= (hpdcache_pkg::HPDCACHE_MSHR_SET_WIDTH + hpdcache_pkg::HPDCACHE_MSHR_WAY_WIDTH + 1))\n    else\n      $fatal(\n          \"HPDcacheMemIdWidth shall be wide enough to identify all pending HPDcache misses and Icache misses\"\n      );\n  initial\n    assert (HPDcacheMemIdWidth >= (hpdcache_pkg::HPDCACHE_WBUF_DIR_PTR_WIDTH + 1))\n    else\n      $fatal(\n          \"HPDcacheMemIdWidth shall be wide enough to identify all pending HPDcache cacheable writes and uncacheable"}
{"text": " writes\"\n      );\n  initial\n    assert (HPDcacheMemDataWidth <= ariane_pkg::ICACHE_LINE_WIDTH)\n    else $fatal(\"HPDcacheMemDataWidth shall be less or equal to the width of a Icache line\");\n  initial\n    assert (HPDcacheMemDataWidth <= ariane_pkg::DCACHE_LINE_WIDTH)\n    else $fatal(\"HPDcacheMemDataWidth shall be less or equal to the width of a Dcache line\");\n  //  pragma translate_on\n  //  }}}\n\nendmodule : cva6_hpdcache_subsystem_axi_arbiter\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 15.08.2018\n// Description: Instruction cache that is compatible with openpiton.\n//\n// Some notes:\n//\n// 1) refills always have the size of one cache line, except for accesses to the I/O region, which is mapped\n//    to the top half of the physical address space (bit 39 = 1). the data width of the interface has the width\n//    of one cache line, and hence the ifills can be transferred in a single cycle. note that the ifills must be\n//    consumed unconditionally.\n//\n// 2) instruction fetches are always assumed to be aligned to 32bit (lower 2 bits are ignored)\n//\n// 3) NC accesses to I/O space are expected to return 32bit from memory.\n//\n\n\nmodule cva6_icache\n  import ariane_pkg::*;\n  import wt_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    /// ID to be used for read transactions\n    parameter logic [MEM_TID_WIDTH-1:0] RdTxId = 0\n) (\n    input logic clk_i,\n    input logic rst_ni,\n\n    /// flush the icache, flush and kill have to be asserted together\n    input  logic         flush_i,\n    /// enable icache\n    input  logic         en_i,\n    /// to performance counter\n    output logic         miss_o,\n    // address translation requests\n    input  icache_areq_t areq_i,\n    output icache_arsp_t areq_o,\n    // data requests\n    input  icache_dreq_t dreq_i,\n    output icache_drsp_t dreq_o,\n    // refill port\n    input  logic         mem_rtrn_vld_i,\n    input  icache_rtrn_t mem_rtrn_i,\n    output logic         mem_data_req_o,\n    input  logic         mem_data_ack_i,\n    output icache_req_t  mem_data_o\n);\n\n  // functions\n  function automatic logic [ariane_pkg::ICACHE_SET_ASSOC-1:0] icache_way_bin2oh(\n      input logic [L1I_WAY_WIDTH-1:0] in);\n    logic [ariane_pkg::ICACHE_SET_ASSOC-1:0] out;\n    out     = '0;\n    out[in] = 1'b1;\n    return out;\n  endfunction\n\n  // signals\n  logic cache_en_d, cache_en_q;  // cache is enabled\n  logic [riscv::VLEN-1:0] vaddr_d, vaddr_q;\n  logic                        paddr_is_nc;  // asserted if physical address is non-cacheable\n  logic [ICACHE_SET_ASSOC-1:0] cl_hit;  // hit from tag compare\n  logic                        cache_rden;  // triggers cache lookup\n  logic                        cache_wren;  // triggers write to cacheline\n  logic\n      cmp_en_d,\n      cmp_en_q;  // enable tag comparison in next cycle. used to cut long path due to NC signal.\n  logic flush_d, flush_q;  // used to register and signal pending flushes\n\n  // replacement strategy\n  logic                                update_lfsr;  // shift the LFSR\n  logic [$clog2(ICACHE_SET_ASSOC)-1:0] inv_way;  // first non-valid encountered\n  logic [$clog2(ICACHE_SET_ASSOC)-1:0] rnd_way;  // random index for replacement\n  logic [$clog2(ICACHE_SET_ASSOC)-1:0] repl_way;  // way to replace\n  logic [ICACHE_SET_ASSOC-1:0] repl_way_oh_d, repl_way_oh_q;  // way to replace (onehot)\n  logic all_ways_valid;  // we need to switch repl strategy since all are valid\n\n  // invalidations / flushing\n  logic inv_en;  // incoming invalidations\n  logic inv_d, inv_q;  // invalidation in progress\n  logic flush_en, flush_done;  // used to flush cache entries\n  logic [ICACHE_CL_IDX_WIDTH-1:0] flush_cnt_d, flush_cnt_q;  // used to flush cache entries\n\n  // mem arrays\n  logic                           cl_we;  // write enable to memory array\n  logic [   ICACHE_SET_ASSOC-1:0] cl_req;  // request to memory array\n  logic [ICACHE_CL_IDX_WIDTH-1:0] cl_index;  // this is a cache-line index, to memory array\n  logic [ICACHE_OFFSET_WIDTH-1:0] cl_offset_d, cl_offset_q;  // offset in cache line\n  logic [ICACHE_TAG_WIDTH-1:0] cl_tag_d, cl_tag_q;  // this is the cache tag\n  logic [ICACHE_TAG_WIDTH-1:0]          cl_tag_rdata [ICACHE_SET_ASSOC-1:0]; // these are the tags coming from the tagmem\n  logic [ICACHE_LINE_WIDTH-1:0]         cl_rdata     [ICACHE_SET_ASSOC-1:0]; // these are the cachelines coming from the cache\n  logic [ICACHE_USER_LINE_WIDTH-1:0]    cl_ruser[ICACHE_SET_ASSOC-1:0]; // these are the cachelines coming from the user cache\n  logic [ICACHE_SET_ASSOC-1:0][FETCH_WIDTH-1:0] cl_sel;  // selected word from each cacheline\n  logic [ICACHE_SET_ASSOC-1:0][FETCH_USER_WIDTH-1:0] cl_user;  // selected word from each cacheline\n  logic [ICACHE_SET_ASSOC-1:0] vld_req;  // bit enable for valid regs\n  logic vld_we;  // valid bits write enable\n  logic [ICACHE_SET_ASSOC-1:0] vld_wdata;  // valid bits to write\n  logic [ICACHE_SET_ASSOC-1:0] vld_rdata;  // valid bits coming from valid regs\n  logic [ICACHE_CL_IDX_WIDTH-1:0] vld_addr;  // valid bit\n\n  // cpmtroller FSM\n  typedef enum logic [2:0] {\n    FLUSH,\n    IDLE,\n    READ,\n    MISS,\n    KILL_ATRANS,\n    KILL_MISS\n  } state_e;\n  state_e state_d, state_q;\n\n  ///////////////////////////////////////////////////////\n  // address -> cl_index mapping, interface plumbing\n  ///////////////////////////////////////////////////////\n\n  // extract tag from physical address, check if NC\n  assign cl_tag_d  = (areq_i.fetch_valid) ? areq_i.fetch_paddr[ICACHE_TAG_WIDTH+ICACHE_INDEX_WIDTH-1:ICACHE_INDEX_WIDTH] : cl_tag_q;\n\n  // noncacheable if request goes to I/O space, or if cache is disabled\n  assign paddr_is_nc = (~cache_en_q) | (~config_pkg::is_inside_cacheable_regions(\n      CVA6Cfg, {{64 - riscv::PLEN{1'b0}}, cl_tag_d, {ICACHE_INDEX_WIDTH{1'b0}}}\n  ));\n\n  // pass exception through\n  assign dreq_o.ex = areq_i.fetch_exception;\n\n  // latch this in case we have to stall later on\n  // make sure this is 32bit aligned\n  assign vaddr_d = (dreq_o.ready & dreq_i.req) ? dreq_i.vaddr : vaddr_q;\n  assign areq_o.fetch_vaddr = {vaddr_q[riscv::VLEN-1:2], 2'b0};\n\n  // split virtual address into index and offset to address cache arrays\n  assign cl_index = vaddr_d[ICACHE_INDEX_WIDTH-1:ICACHE_OFFSET_WIDTH];\n\n\n  if (CVA6Cfg.NOCType == config_pkg::NOC_TYPE_AXI4_ATOP) begin : gen_axi_offset\n    // if we generate a noncacheable access, the word will be at offset 0 or 4 in the cl coming from memory\n    assign cl_offset_d = ( dreq_o.ready & dreq_i.req)      ? {dreq_i.vaddr[ICACHE_OFFSET_WIDTH-1:2], 2'b0} :\n                         ( paddr_is_nc  & mem_data_req_o ) ? {{ICACHE_OFFSET_WIDTH-1{1'b0}}, cl_offset_q[2]}<<2 : // needed since we transfer 32bit over a 64bit AXI bus in this case\n        cl_offset_q;\n    // request word address instead of cl address in case of NC access\n    assign mem_data_o.paddr = (paddr_is_nc) ? {cl_tag_d, vaddr_q[ICACHE_INDEX_WIDTH-1:3], 3'b0} :                                         // align to 64bit\n        {cl_tag_d, vaddr_q[ICACHE_INDEX_WIDTH-1:ICACHE_OFFSET_WIDTH], {ICACHE_OFFSET_WIDTH{1'b0}}}; // align to cl\n  end else begin : gen_piton_offset\n    // icache fills are either cachelines or 4byte fills, depending on whether they go to the Piton I/O space or not.\n    // since the piton cache system replicates the data, we can always index the full CL\n    assign cl_offset_d = (dreq_o.ready & dreq_i.req) ? {dreq_i.vaddr >> 2, 2'b0} : cl_offset_q;\n\n    // request word address instead of cl address in case of NC access\n    assign mem_data_o.paddr = (paddr_is_nc) ? {cl_tag_d, vaddr_q[ICACHE_INDEX_WIDTH-1:2], 2'b0} :                                         // align to 32bit\n        {cl_tag_d, vaddr_q[ICACHE_INDEX_WIDTH-1:ICACHE_OFFSET_WIDTH], {ICACHE_OFFSET_WIDTH{1'b0}}}; // align to cl\n  end\n\n\n  assign mem_data_o.tid = RdTxId;\n\n  assign mem_data_o.nc  = paddr_is_nc;\n  // way that is being replaced\n  assign mem_data_o.way = repl_way;\n  assign dreq_o.vaddr   = vaddr_q;\n\n  // invalidations take two cycles\n  assign inv_d          = inv_en;\n\n  ///////////////////////////////////////////////////////\n  // main control logic\n  ///////////////////////////////////////////////////////\n  logic addr_ni;\n  assign addr_ni = config_pkg::is_inside_nonidempotent_regions(\n      CVA6Cfg, {{64 - riscv::PLEN{1'b0}}, areq_i.fetch_paddr}\n  );\n  always_comb begin : p_fsm\n    // default assignment\n    state_d = state_q;\n    cache_en_d   = cache_en_q & en_i;// disabling the cache is always possible, enable needs to go via flush\n    flush_en = 1'b0;\n    cmp_en_d = 1'b0;\n    cache_rden = 1'b0;\n    cache_wren = 1'b0;\n    inv_en = 1'b0;\n    flush_d = flush_q | flush_i;  // register incoming flush\n\n    // interfaces\n    dreq_o.ready = 1'b0;\n    areq_o.fetch_req = 1'b0;\n    dreq_o.valid = 1'b0;\n    mem_data_req_o = 1'b0;\n    // performance counter\n    miss_o = 1'b0;\n\n    // handle invalidations unconditionally\n    // note: invald are mutually exclusive with\n    // ifills, since both arrive over the same IF\n    // however, we need to make sure below that we\n    // do not trigger a cache readout at the same time...\n    if (mem_rtrn_vld_i && mem_rtrn_i.rtype == ICACHE_INV_REQ) begin\n      inv_en = 1'b1;\n    end\n\n    unique case (state_q)\n      //////////////////////////////////\n      // this clears all valid bits\n      FLUSH: begin\n        flush_en = 1'b1;\n        if (flush_done) begin\n          state_d = IDLE;\n          flush_d = 1'b0;\n          // if the cache was not enabled set this\n          cache_en_d = en_i;\n        end\n      end\n      //////////////////////////////////\n      // wait for an incoming request\n      IDLE: begin\n        // only enable tag comparison if cache is enabled\n        cmp_en_d = cache_en_q;\n\n        // handle pending flushes, or perform cache clear upon enable\n        if (flush_d || (en_i && !cache_en_q)) begin\n          state_d = FLUSH;\n          // wait for incoming requests\n        end else begin\n          // mem requests are for sure invals here\n          if (!mem_rtrn_vld_i) begin\n            dreq_o.ready = 1'b1;\n            // we have a new request\n            if (dreq_i.req) begin\n              cache_rden = 1'b1;\n              state_d    = READ;\n            end\n          end\n          if (dreq_i.kill_s1) begin\n            state_d = IDLE;\n          end\n        end\n      end\n      //////////////////////////////////\n      // check whether we have a hit\n      // in case the cache is disabled,\n      // or in case the address is NC, we\n      // reuse the miss mechanism to handle\n      // the request\n      READ: begin\n        areq_o.fetch_req = '1;\n        // only enable tag comparison if cache is enabled\n        cmp_en_d    = cache_en_q;\n        // readout speculatively\n        cache_rden  = cache_en_q;\n\n        if (areq_i.fetch_valid && (!dreq_i.spec || ((CVA6Cfg.NonIdemPotenceEn && !addr_ni) || (!CVA6Cfg.NonIdemPotenceEn)))) begin\n          // check if we have to flush\n          if (flush_d) begin\n            state_d = IDLE;\n            // we have a hit or an exception output valid result\n          end else if (((|cl_hit && cache_en_q) || areq_i.fetch_exception.valid) && !inv_q) begin\n            dreq_o.valid = ~dreq_i.kill_s2;  // just don't output in this case\n            state_d      = IDLE;\n\n            // we can accept another request\n            // and stay here, but only if no inval is coming in\n            // note: we are not expecting ifill return packets here...\n            if (!mem_rtrn_vld_i) begin\n              dreq_o.ready = 1'b1;\n              if (dreq_i.req) begin\n                state_d = READ;\n              end\n            end\n            // if a request is being killed at this stage,\n            // we have to bail out and wait for the address translation to complete\n            if (dreq_i.kill_s1) begin\n              state_d = IDLE;\n            end\n            // we have a miss / NC transaction\n          end else if (dreq_i.kill_s2) begin\n            state_d = IDLE;\n          end else if (!inv_q) begin\n            cmp_en_d = 1'b0;\n            // only count this as a miss if the cache is enabled, and\n            // the address is cacheable\n            // send out ifill request\n            mem_data_req_o = 1'b1;\n            if (mem_data_ack_i) begin\n              miss_o  = ~paddr_is_nc;\n              state_d = MISS;\n            end\n          end\n          // bail out if this request is being killed (and we missed on the TLB)\n        end else if (dreq_i.kill_s2 || flush_d) begin\n          state_d = KILL_ATRANS;\n        end\n      end\n      //////////////////////////////////\n      // wait until the memory transaction\n      // returns. do not write to memory\n      // if the nc bit is set.\n      MISS: begin\n        // note: this is mutually exclusive with ICACHE_INV_REQ,\n        // so we do not have to check for invals here\n        if (mem_rtrn_vld_i && mem_rtrn_i.rtype == ICACHE_IFILL_ACK) begin\n          state_d = IDLE;\n          // only return data if request is not being killed\n          if (!(dreq_i.kill_s2 || flush_d)) begin\n            dreq_o.valid = 1'b1;\n            // only write to cache if this address is cacheable\n            cache_wren   = ~paddr_is_nc;\n          end\n          // bail out if this request is being killed\n        end else if (dreq_i.kill_s2 || flush_d) begin\n          state_d = KILL_MISS;\n        end\n      end\n      //////////////////////////////////\n      // killed address translation,\n      // wait until paddr is valid, and go\n      // back to idle\n      KILL_ATRANS: begin\n        areq_o.fetch_req = '1;\n        if (areq_i.fetch_valid) begin\n          state_d = IDLE;\n        end\n      end\n      //////////////////////////////////\n      // killed miss,\n      // wait until memory responds and\n      // go back to idle\n      KILL_MISS: begin\n        if (mem_rtrn_vld_i && mem_rtrn_i.rtype == ICACHE_IFILL_ACK) begin\n          state_d = IDLE;\n        end\n      end\n      default: begin\n        // we should never get here\n        state_d = FLUSH;\n      end\n    endcase  // state_q\n  end\n\n  ///////////////////////////////////////////////////////\n  // valid bit invalidation and replacement strategy\n  ///////////////////////////////////////////////////////\n\n  // note: it cannot happen that we get an invalidation + a cl replacement\n  // in the same cycle as these requests arrive via the same interface\n  // flushes take precedence over invalidations (it is ok if we ignore\n  // the inval since the cache is cleared anyway)\n\n  assign flush_cnt_d = (flush_done) ? '0 : (flush_en) ? flush_cnt_q + 1 : flush_cnt_q;\n\n  assign flush_done = (flush_cnt_q == (ICACHE_NUM_WORDS - 1));\n\n  // invalidation/clearing address\n  // flushing takes precedence over invals\n  assign vld_addr = (flush_en)       ? flush_cnt_q        :\n                    (inv_en)         ? mem_rtrn_i.inv.idx[ICACHE_INDEX_WIDTH-1:ICACHE_OFFSET_WIDTH] :\n                                       cl_index;\n\n  assign vld_req  = (flush_en || cache_rden)        ? '1                                    :\n                    (mem_rtrn_i.inv.all && inv_en)  ? '1                                    :\n                    (mem_rtrn_i.inv.vld && inv_en)  ? icache_way_bin2oh(\n      mem_rtrn_i.inv.way\n  ) : repl_way_oh_q;\n\n  assign vld_wdata = (cache_wren) ? '1 : '0;\n\n  assign vld_we = (cache_wren | inv_en | flush_en);\n  // assign vld_req   = (vld_we | cache_rden);\n\n\n  // chose random replacement if all are valid\n  assign update_lfsr = cache_wren & all_ways_valid;\n  assign repl_way = (all_ways_valid) ? rnd_way : inv_way;\n  assign repl_way_oh_d = (cmp_en_q) ? icache_way_bin2oh(repl_way) : repl_way_oh_q;\n\n  // enable signals for memory arrays\n  assign cl_req = (cache_rden) ? '1 : (cache_wren) ? repl_way_oh_q : '0;\n  assign cl_we = cache_wren;\n\n\n  // find invalid cache line\n  lzc #(\n      .WIDTH(ICACHE_SET_ASSOC)\n  ) i_lzc (\n      .in_i   (~vld_rdata),\n      .cnt_o  (inv_way),\n      .empty_o(all_ways_valid)\n  );\n\n  // generate random cacheline index\n  lfsr #(\n      .LfsrWidth(8),\n      .OutWidth ($clog2(ariane_pkg::ICACHE_SET_ASSOC))\n  ) i_lfsr (\n      .clk_i (clk_i),\n      .rst_ni(rst_ni),\n      .en_i  (update_lfsr),\n      .out_o (rnd_way)\n  );\n\n\n  ///////////////////////////////////////////////////////\n  // tag comparison, hit generation\n  ///////////////////////////////////////////////////////\n\n  logic [$clog2(ICACHE_SET_ASSOC)-1:0] hit_idx;\n\n  for (genvar i = 0; i < ICACHE_SET_ASSOC; i++) begin : gen_tag_cmpsel\n    assign cl_hit[i]  = (cl_tag_rdata[i] == cl_tag_d) & vld_rdata[i];\n    assign cl_sel[i]  = cl_rdata[i][{cl_offset_q, 3'b0}+:FETCH_WIDTH];\n    assign cl_user[i] = cl_ruser[i][{cl_offset_q, 3'b0}+:FETCH_USER_WIDTH];\n  end\n\n\n  lzc #(\n      .WIDTH(ICACHE_SET_ASSOC)\n  ) i_lzc_hit (\n      .in_i   (cl_hit),\n      .cnt_o  (hit_idx),\n      .empty_o()\n  );\n\n  always_comb begin\n    if (cmp_en_q) begin\n      dreq_o.data = cl_sel[hit_idx];\n      dreq_o.user = cl_user[hit_idx];\n    end else begin\n      dreq_o.data = mem_rtrn_i.data[{cl_offset_q, 3'b0}+:FETCH_WIDTH];\n      dreq_o.user = mem_rtrn_i.user[{cl_offset_q, 3'b0}+:FETCH_USER_WIDTH];\n    end\n  end\n\n  ///////////////////////////////////////////////////////\n  // memory arrays and regs\n  ///////////////////////////////////////////////////////\n\n\n  logic [ICACHE_TAG_WIDTH:0] cl_tag_valid_rdata[ICACHE_SET_ASSOC-1:0];\n\n  for (genvar i = 0; i < ICACHE_SET_ASSOC; i++) begin : gen_sram\n    // Tag RAM\n    sram #(\n        // tag + valid bit\n        .DATA_WIDTH(ICACHE_TAG_WIDTH + 1),\n        .NUM_WORDS (ICACHE_NUM_WORDS)\n    ) tag_sram (\n        .clk_i  (clk_i),\n        .rst_ni (rst_ni),\n        .req_i  (vld_req[i]),\n        .we_i   (vld_we),\n        .addr_i (vld_addr),\n        // we can always use the saved tag here since it takes a\n        // couple of cycle until we write to the cache upon a miss\n        .wuser_i('0),\n        .wdata_i({vld_wdata[i], cl_tag_q}),\n        .be_i   ('1),\n        .ruser_o(),\n        .rdata_o(cl_tag_valid_rdata[i])\n    );\n\n    assign cl_tag_rdata[i] = cl_tag_valid_rdata[i][ICACHE_TAG_WIDTH-1:0];\n    assign vld_rdata[i]    = cl_tag_valid_rdata[i][ICACHE_TAG_WIDTH];\n\n    // Data RAM\n    sram #(\n        .USER_WIDTH(ICACHE_USER_LINE_WIDTH),\n        .DATA_WIDTH(ICACHE_LINE_WIDTH),\n        .USER_EN   (ariane_pkg::FETCH_USER_EN),\n        .NUM_WORDS (ICACHE_NUM_WORDS)\n    ) data_sram (\n        .clk_i  (clk_i),\n        .rst_ni (rst_ni),\n        .req_i  (cl_req[i]),\n        .we_i   (cl_we),\n        .addr_i (cl_index),\n        .wuser_i(mem_rtrn_i.user),\n        .wdata_i(mem_rtrn_i.data),\n        .be_i   ('1),\n        .ruser_o(cl_ruser[i]),\n        .rdata_o(cl_rdata[i])\n    );\n  end\n\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs\n    if (!rst_ni) begin\n      cl_tag_q      <= '0;\n      flush_cnt_q   <= '0;\n      vaddr_q       <= '0;\n      cmp_en_q      <= '0;\n      cache_en_q    <= '0;\n      flush_q       <= '0;\n      state_q       <= FLUSH;\n      cl_offset_q   <= '0;\n      repl_way_oh_q <= '0;\n      inv_q         <= '0;\n    end else begin\n      cl_tag_q      <= cl_tag_d;\n      flush_cnt_q   <= flush_cnt_d;\n      vaddr_q       <= vaddr_d;\n      cmp_en_q      <= cmp_en_d;\n      cache_en_q    <= cache_en_d;\n      flush_q       <= flush_d;\n      state_q       <= state_d;\n      cl_offset_q   <= cl_offset_d;\n      repl_way_oh_q <= repl_way_oh_d;\n      inv_q         <= inv_d;\n    end\n  end\n\n  ///////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////\n\n  //pragma translate_off\n`ifndef VERILATOR\n  repl_inval0 :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) cache_wren |-> !(mem_rtrn_i.inv.all | mem_rtrn_i.inv.vld))\n  else $fatal(1, \"[l1 icache] cannot replace cacheline and invalidate cacheline simultaneously\");\n\n  repl_inval1 :\n  assert property (\n    @(po"}
{"text": "sedge clk_i) disable iff (!rst_ni) (mem_rtrn_i.inv.all | mem_rtrn_i.inv.vld) |-> !cache_wren)\n  else $fatal(1, \"[l1 icache] cannot replace cacheline and invalidate cacheline simultaneously\");\n\n  invalid_state :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) (state_q inside {FLUSH, IDLE, READ, MISS, KILL_ATRANS, KILL_MISS}))\n  else $fatal(1, \"[l1 icache] fsm reached an invalid state\");\n\n  hot1 :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) (!inv_en) |-> cache_rden |=> cmp_en_q |-> $onehot0(\n      cl_hit\n  ))\n  else $fatal(1, \"[l1 icache] cl_hit signal must be hot1\");\n\n  // this is only used for verification!\n  logic vld_mirror[wt_cache_pkg::ICACHE_NUM_WORDS-1:0][ariane_pkg::ICACHE_SET_ASSOC-1:0];\n  logic [ariane_pkg::ICACHE_TAG_WIDTH-1:0] tag_mirror[wt_cache_pkg::ICACHE_NUM_WORDS-1:0][ariane_pkg::ICACHE_SET_ASSOC-1:0];\n  logic [ariane_pkg::ICACHE_SET_ASSOC-1:0] tag_write_duplicate_test;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : p_mirror\n    if (!rst_ni) begin\n      vld_mirror <= '{default: '0};\n      tag_mirror <= '{default: '0};\n    end else begin\n      for (int i = 0; i < ICACHE_SET_ASSOC; i++) begin\n        if (vld_req[i] & vld_we) begin\n          vld_mirror[vld_addr][i] <= vld_wdata[i];\n          tag_mirror[vld_addr][i] <= cl_tag_q;\n        end\n      end\n    end\n  end\n\n  for (genvar i = 0; i < ICACHE_SET_ASSOC; i++) begin : gen_tag_dupl\n    assign tag_write_duplicate_test[i] = (tag_mirror[vld_addr][i] == cl_tag_q) & vld_mirror[vld_addr][i] & (|vld_wdata);\n  end\n\n  tag_write_duplicate :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) |vld_req |-> vld_we |-> !(|tag_write_duplicate_test))\n  else $fatal(1, \"[l1 icache] cannot allocate a CL that is already present in the cache\");\n\n\n  initial begin\n    // assert wrong parameterizations\n    assert (ICACHE_INDEX_WIDTH <= 12)\n    else $fatal(1, \"[l1 icache] cache index width can be maximum 12bit since VM uses 4kB pages\");\n  end\n`endif\n  //pragma translate_on\n\nendmodule  // cva6_icache\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Nils Wistoff <nwistoff@iis.ee.ethz.ch>, ETH Zurich\n// Date: 07.09.2020\n// Description: wrapper module to connect the L1I$ to a 64bit AXI bus.\n//\n\nmodule cva6_icache_axi_wrapper\n  import ariane_pkg::*;\n  import wt_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter type axi_req_t = logic,\n    parameter type axi_rsp_t = logic\n) (\n    input logic             clk_i,\n    input logic             rst_ni,\n    input riscv::priv_lvl_t priv_lvl_i,\n\n    input logic flush_i,  // flush the icache, flush and kill have to be asserted together\n    input logic en_i,  // enable icache\n    output logic miss_o,  // to performance counter\n    // address translation requests\n    input icache_areq_t areq_i,\n    output icache_arsp_t areq_o,\n    // data requests\n    input icache_dreq_t dreq_i,\n    output icache_drsp_t dreq_o,\n    // AXI refill port\n    output axi_req_t axi_req_o,\n    input axi_rsp_t axi_resp_i\n);\n\n  localparam AxiNumWords = (ICACHE_LINE_WIDTH/CVA6Cfg.AxiDataWidth) * (ICACHE_LINE_WIDTH  > DCACHE_LINE_WIDTH)  +\n                           (DCACHE_LINE_WIDTH/CVA6Cfg.AxiDataWidth) * (ICACHE_LINE_WIDTH <= DCACHE_LINE_WIDTH) ;\n\n  logic                                    icache_mem_rtrn_vld;\n  icache_rtrn_t                            icache_mem_rtrn;\n  logic                                    icache_mem_data_req;\n  logic                                    icache_mem_data_ack;\n  icache_req_t                             icache_mem_data;\n\n  logic                                    axi_rd_req;\n  logic                                    axi_rd_gnt;\n  logic         [CVA6Cfg.AxiAddrWidth-1:0] axi_rd_addr;\n  logic         [ $clog2(AxiNumWords)-1:0] axi_rd_blen;\n  logic         [                     2:0] axi_rd_size;\n  logic         [  CVA6Cfg.AxiIdWidth-1:0] axi_rd_id_in;\n  logic                                    axi_rd_rdy;\n  logic                                    axi_rd_lock;\n  logic                                    axi_rd_last;\n  logic                                    axi_rd_valid;\n  logic         [CVA6Cfg.AxiDataWidth-1:0] axi_rd_data;\n  logic         [  CVA6Cfg.AxiIdWidth-1:0] axi_rd_id_out;\n  logic                                    axi_rd_exokay;\n\n  logic req_valid_d, req_valid_q;\n  icache_req_t req_data_d, req_data_q;\n  logic first_d, first_q;\n  logic [ICACHE_LINE_WIDTH/CVA6Cfg.AxiDataWidth-1:0][CVA6Cfg.AxiDataWidth-1:0]\n      rd_shift_d, rd_shift_q;\n\n  // Keep read request asserted until we have an AXI grant. This is not guaranteed by icache (but\n  // required by AXI).\n  assign req_valid_d           = ~axi_rd_gnt & (icache_mem_data_req | req_valid_q);\n\n  // Update read request information on a new request\n  assign req_data_d            = (icache_mem_data_req) ? icache_mem_data : req_data_q;\n\n  // We have a new or pending read request\n  assign axi_rd_req            = icache_mem_data_req | req_valid_q;\n  assign axi_rd_addr           = CVA6Cfg.AxiAddrWidth'(req_data_d.paddr);\n\n  // Fetch a full cache line on a cache miss, or a single word on a bypassed access\n  assign axi_rd_blen           = (req_data_d.nc) ? '0 : ariane_pkg::ICACHE_LINE_WIDTH / 64 - 1;\n  assign axi_rd_size           = $clog2(CVA6Cfg.AxiDataWidth / 8);  // Maximum\n  assign axi_rd_id_in          = req_data_d.tid;\n  assign axi_rd_rdy            = 1'b1;\n  assign axi_rd_lock           = 1'b0;\n\n  // Immediately acknowledge read request. This is an implicit requirement for the icache.\n  assign icache_mem_data_ack   = icache_mem_data_req;\n\n  // Return data as soon as last word arrives\n  assign icache_mem_rtrn_vld   = axi_rd_valid & axi_rd_last;\n  assign icache_mem_rtrn.data  = rd_shift_d;\n  assign icache_mem_rtrn.tid   = req_data_q.tid;\n  assign icache_mem_rtrn.rtype = wt_cache_pkg::ICACHE_IFILL_ACK;\n  assign icache_mem_rtrn.inv   = '0;\n\n  // -------\n  // I-Cache\n  // -------\n  cva6_icache #(\n      // use ID 0 for icache reads\n      .CVA6Cfg(CVA6Cfg),\n      .RdTxId (0)\n  ) i_cva6_icache (\n      .clk_i         (clk_i),\n      .rst_ni        (rst_ni),\n      .flush_i       (flush_i),\n      .en_i          (en_i),\n      .miss_o        (miss_o),\n      .areq_i        (areq_i),\n      .areq_o        (areq_o),\n      .dreq_i        (dreq_i),\n      .dreq_o        (dreq_o),\n      .mem_rtrn_vld_i(icache_mem_rtrn_vld),\n      .mem_rtrn_i    (icache_mem_rtrn),\n      .mem_data_req_o(icache_mem_data_req),\n      .mem_data_ack_i(icache_mem_data_ack),\n      .mem_data_o    (icache_mem_data)\n  );\n\n  // --------\n  // AXI shim\n  // --------\n  axi_shim #(\n      .CVA6Cfg    (CVA6Cfg),\n      .AxiNumWords(AxiNumWords),\n      .axi_req_t  (axi_req_t),\n      .axi_rsp_t  (axi_rsp_t)\n  ) i_axi_shim (\n      .clk_i      (clk_i),\n      .rst_ni     (rst_ni),\n      .rd_req_i   (axi_rd_req),\n      .rd_gnt_o   (axi_rd_gnt),\n      .rd_addr_i  (axi_rd_addr),\n      .rd_blen_i  (axi_rd_blen),\n      .rd_size_i  (axi_rd_size),\n      .rd_id_i    (axi_rd_id_in),\n      .rd_rdy_i   (axi_rd_rdy),\n      .rd_lock_i  (axi_rd_lock),\n      .rd_last_o  (axi_rd_last),\n      .rd_valid_o (axi_rd_valid),\n      .rd_data_o  (axi_rd_data),\n      .rd_user_o  (),\n      .rd_id_o    (axi_rd_id_out),\n      .rd_exokay_o(axi_rd_exokay),\n      .wr_req_i   ('0),\n      .wr_gnt_o   (),\n      .wr_addr_i  ('0),\n      .wr_data_i  ('0),\n      .wr_user_i  ('0),\n      .wr_be_i    ('0),\n      .wr_blen_i  ('0),\n      .wr_size_i  ('0),\n      .wr_id_i    ('0),\n      .wr_lock_i  ('0),\n      .wr_atop_i  ('0),\n      .wr_rdy_i   ('0),\n      .wr_valid_o (),\n      .wr_id_o    (),\n      .wr_exokay_o(),\n      .axi_req_o  (axi_req_o),\n      .axi_resp_i (axi_resp_i)\n  );\n\n  // Buffer burst data in shift register\n  always_comb begin : p_axi_rtrn_shift\n    first_d    = first_q;\n    rd_shift_d = rd_shift_q;\n\n    if (axi_rd_valid) begin\n      first_d = axi_rd_last;\n      if (ICACHE_LINE_WIDTH == CVA6Cfg.AxiDataWidth) begin\n        rd_shift_d = axi_rd_data;\n      end else begin\n        rd_shift_d = {axi_rd_data, rd_shift_q[ICACHE_LINE_WIDTH/CVA6Cfg.AxiDataWidth-1:1]};\n      end\n\n      // If this is a single word transaction, we need to make sure that word is placed at offset 0\n      if (first_q) begin\n        rd_shift_d[0] = axi_rd_data;\n      end\n    end\n  end\n\n  // Registers\n  always_ff @(posedge clk_i or negedge rst_ni) begin : p_rd_buf\n    if (!rst_ni) begin\n      req_valid_q <= 1'b0;\n      req_data_q  <= '0;\n      first_q     <= 1'b1;\n      rd_shift_q  <= '0;\n    end else begin\n      req_valid_q <= req_valid_d;\n      req_data_q  <= req_data_d;\n      first_q     <= first_d;\n      rd_shift_q  <= rd_shift_d;\n    end\n  end\n\nendmodule  // cva6_icache_axi_wrapper\n"}
{"text": "// Copyright (c) 2021 Thales.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Sebastien Jacq Thales Research & Technology\n// Date: 17/07/2021\n//\n// Additional contributions by:\n//         Sebastien Jacq - sjthales on github.com\n//\n// Description: Memory Management Unit for CV32A6, contains TLB and\n//              address translation unit. Sv32 as defined in RISC-V\n//              privilege specification 1.11-WIP.\n//              This module is an adaptation of the MMU Sv39 developed\n//              by Florian Zaruba to the Sv32 standard.\n//\n// =========================================================================== //\n// Revisions  :\n// Date        Version  Author       Description\n// 2020-02-17  0.1      S.Jacq       MMU Sv32 for CV32A6\n// =========================================================================== //\n\nmodule cva6_mmu_sv32\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg           = config_pkg::cva6_cfg_empty,\n    parameter int unsigned           INSTR_TLB_ENTRIES = 2,\n    parameter int unsigned           DATA_TLB_ENTRIES  = 2,\n    parameter int unsigned           ASID_WIDTH        = 1\n) (\n    input logic clk_i,\n    input logic rst_ni,\n    input logic flush_i,\n    input logic enable_translation_i,\n    input logic en_ld_st_translation_i,  // enable virtual memory translation for load/stores\n    // IF interface\n    input icache_arsp_t icache_areq_i,\n    output icache_areq_t icache_areq_o,\n    // LSU interface\n    // this is a more minimalistic interface because the actual addressing logic is handled\n    // in the LSU as we distinguish load and stores, what we do here is simple address translation\n    input exception_t misaligned_ex_i,\n    input logic lsu_req_i,  // request address translation\n    input logic [riscv::VLEN-1:0] lsu_vaddr_i,  // virtual address in\n    input logic lsu_is_store_i,  // the translation is requested by a store\n    // if we need to walk the page table we can't grant in the same cycle\n    // Cycle 0\n    output logic                            lsu_dtlb_hit_o,   // sent in the same cycle as the request if translation hits in the DTLB\n    output logic [riscv::PPNW-1:0] lsu_dtlb_ppn_o,  // ppn (send same cycle as hit)\n    // Cycle 1\n    output logic lsu_valid_o,  // translation is valid\n    output logic [riscv::PLEN-1:0] lsu_paddr_o,  // translated address\n    output exception_t lsu_exception_o,  // address translation threw an exception\n    // General control signals\n    input riscv::priv_lvl_t priv_lvl_i,\n    input riscv::priv_lvl_t ld_st_priv_lvl_i,\n    input logic sum_i,\n    input logic mxr_i,\n    // input logic flag_mprv_i,\n    input logic [riscv::PPNW-1:0] satp_ppn_i,\n    input logic [ASID_WIDTH-1:0] asid_i,\n    input logic [ASID_WIDTH-1:0] asid_to_be_flushed_i,\n    input logic [riscv::VLEN-1:0] vaddr_to_be_flushed_i,\n    input logic flush_tlb_i,\n    // Performance counters\n    output logic itlb_miss_o,\n    output logic dtlb_miss_o,\n    // PTW memory interface\n    input dcache_req_o_t req_port_i,\n    output dcache_req_i_t req_port_o,\n    // PMP\n    input riscv::pmpcfg_t [15:0] pmpcfg_i,\n    input logic [15:0][riscv::PLEN-3:0] pmpaddr_i\n);\n\n  logic                   iaccess_err;  // insufficient privilege to access this instruction page\n  logic                   daccess_err;  // insufficient privilege to access this data page\n  logic                   ptw_active;  // PTW is currently walking a page table\n  logic                   walking_instr;  // PTW is walking because of an ITLB miss\n  logic                   ptw_error;  // PTW threw an exception\n  logic                   ptw_access_exception;  // PTW threw an access exception (PMPs)\n  logic [riscv::PLEN-1:0] ptw_bad_paddr;  // PTW PMP exception bad physical addr\n\n  logic [riscv::VLEN-1:0] update_vaddr;\n  tlb_update_sv32_t update_itlb, update_dtlb, update_shared_tlb;\n\n  logic                               itlb_lu_access;\n  riscv::pte_sv32_t                   itlb_content;\n  logic                               itlb_is_4M;\n  logic                               itlb_lu_hit;\n\n  logic                               dtlb_lu_access;\n  riscv::pte_sv32_t                   dtlb_content;\n  logic                               dtlb_is_4M;\n  logic                               dtlb_lu_hit;\n\n  logic                               shared_tlb_access;\n  logic             [riscv::VLEN-1:0] shared_tlb_vaddr;\n  logic                               shared_tlb_hit;\n\n  logic                               itlb_req;\n\n\n  // Assignments\n  assign itlb_lu_access = icache_areq_i.fetch_req;\n  assign dtlb_lu_access = lsu_req_i;\n\n\n  cva6_tlb_sv32 #(\n      .CVA6Cfg    (CVA6Cfg),\n      .TLB_ENTRIES(INSTR_TLB_ENTRIES),\n      .ASID_WIDTH (ASID_WIDTH)\n  ) i_itlb (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i(flush_tlb_i),\n\n      .update_i(update_itlb),\n\n      .lu_access_i          (itlb_lu_access),\n      .lu_asid_i            (asid_i),\n      .asid_to_be_flushed_i (asid_to_be_flushed_i),\n      .vaddr_to_be_flushed_i(vaddr_to_be_flushed_i),\n      .lu_vaddr_i           (icache_areq_i.fetch_vaddr),\n      .lu_content_o         (itlb_content),\n\n      .lu_is_4M_o(itlb_is_4M),\n      .lu_hit_o  (itlb_lu_hit)\n  );\n\n  cva6_tlb_sv32 #(\n      .CVA6Cfg    (CVA6Cfg),\n      .TLB_ENTRIES(DATA_TLB_ENTRIES),\n      .ASID_WIDTH (ASID_WIDTH)\n  ) i_dtlb (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i(flush_tlb_i),\n\n      .update_i(update_dtlb),\n\n      .lu_access_i          (dtlb_lu_access),\n      .lu_asid_i            (asid_i),\n      .asid_to_be_flushed_i (asid_to_be_flushed_i),\n      .vaddr_to_be_flushed_i(vaddr_to_be_flushed_i),\n      .lu_vaddr_i           (lsu_vaddr_i),\n      .lu_content_o         (dtlb_content),\n\n      .lu_is_4M_o(dtlb_is_4M),\n      .lu_hit_o  (dtlb_lu_hit)\n  );\n\n  cva6_shared_tlb_sv32 #(\n      .CVA6Cfg         (CVA6Cfg),\n      .SHARED_TLB_DEPTH(64),\n      .SHARED_TLB_WAYS (2),\n      .ASID_WIDTH      (ASID_WIDTH)\n  ) i_shared_tlb (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i(flush_tlb_i),\n\n      .enable_translation_i  (enable_translation_i),\n      .en_ld_st_translation_i(en_ld_st_translation_i),\n\n      .asid_i       (asid_i),\n      // from TLBs\n      // did we miss?\n      .itlb_access_i(itlb_lu_access),\n      .itlb_hit_i   (itlb_lu_hit),\n      .itlb_vaddr_i (icache_areq_i.fetch_vaddr),\n\n      .dtlb_access_i(dtlb_lu_access),\n      .dtlb_hit_i   (dtlb_lu_hit),\n      .dtlb_vaddr_i (lsu_vaddr_i),\n\n      // to TLBs, update logic\n      .itlb_update_o(update_itlb),\n      .dtlb_update_o(update_dtlb),\n\n      // Performance counters\n      .itlb_miss_o(itlb_miss_o),\n      .dtlb_miss_o(dtlb_miss_o),\n\n      .shared_tlb_access_o(shared_tlb_access),\n      .shared_tlb_hit_o   (shared_tlb_hit),\n      .shared_tlb_vaddr_o (shared_tlb_vaddr),\n\n      .itlb_req_o         (itlb_req),\n      // to update shared tlb\n      .shared_tlb_update_i(update_shared_tlb)\n  );\n\n  cva6_ptw_sv32 #(\n      .CVA6Cfg   (CVA6Cfg),\n      .ASID_WIDTH(ASID_WIDTH)\n  ) i_ptw (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i(flush_i),\n\n      .ptw_active_o          (ptw_active),\n      .walking_instr_o       (walking_instr),\n      .ptw_error_o           (ptw_error),\n      .ptw_access_exception_o(ptw_access_exception),\n\n      .lsu_is_store_i(lsu_is_store_i),\n      // PTW memory interface\n      .req_port_i    (req_port_i),\n      .req_port_o    (req_port_o),\n\n      // to Shared TLB, update logic\n      .shared_tlb_update_o(update_shared_tlb),\n\n      .update_vaddr_o(update_vaddr),\n\n      .asid_i(asid_i),\n\n      // from shared TLB\n      // did we miss?\n      .shared_tlb_access_i(shared_tlb_access),\n      .shared_tlb_hit_i   (shared_tlb_hit),\n      .shared_tlb_vaddr_i (shared_tlb_vaddr),\n\n      .itlb_req_i(itlb_req),\n\n      // from CSR file\n      .satp_ppn_i(satp_ppn_i),  // ppn from satp\n      .mxr_i     (mxr_i),\n\n      // Performance counters\n      .shared_tlb_miss_o(),  //open for now\n\n      // PMP\n      .pmpcfg_i   (pmpcfg_i),\n      .pmpaddr_i  (pmpaddr_i),\n      .bad_paddr_o(ptw_bad_paddr)\n\n  );\n\n  // ila_1 i_ila_1 (\n  //     .clk(clk_i), // input wire clk\n  //     .probe0({req_port_o.address_tag, req_port_o.address_index}),\n  //     .probe1(req_port_o.data_req), // input wire [63:0]  probe1\n  //     .probe2(req_port_i.data_gnt), // input wire [0:0]  probe2\n  //     .probe3(req_port_i.data_rdata), // input wire [0:0]  probe3\n  //     .probe4(req_port_i.data_rvalid), // input wire [0:0]  probe4\n  //     .probe5(ptw_error), // input wire [1:0]  probe5\n  //     .probe6(update_vaddr), // input wire [0:0]  probe6\n  //     .probe7(update_itlb.valid), // input wire [0:0]  probe7\n  //     .probe8(update_dtlb.valid), // input wire [0:0]  probe8\n  //     .probe9(dtlb_lu_access), // input wire [0:0]  probe9\n  //     .probe10(lsu_vaddr_i), // input wire [0:0]  probe10\n  //     .probe11(dtlb_lu_hit), // input wire [0:0]  probe11\n  //     .probe12(itlb_lu_access), // input wire [0:0]  probe12\n  //     .probe13(icache_areq_i.fetch_vaddr), // input wire [0:0]  probe13\n  //     .probe14(itlb_lu_hit) // input wire [0:0]  probe13\n  // );\n\n  //-----------------------\n  // Instruction Interface\n  //-----------------------\n  logic match_any_execute_region;\n  logic pmp_instr_allow;\n\n  // The instruction interface is a simple request response interface\n  always_comb begin : instr_interface\n    // MMU disabled: just pass through\n    icache_areq_o.fetch_valid = icache_areq_i.fetch_req;\n    if (riscv::PLEN > riscv::VLEN)\n      icache_areq_o.fetch_paddr = {\n        {riscv::PLEN - riscv::VLEN{1'b0}}, icache_areq_i.fetch_vaddr\n      };  // play through in case we disabled address translation\n    else\n      icache_areq_o.fetch_paddr = {\n        2'b00, icache_areq_i.fetch_vaddr[riscv::VLEN-1:0]\n      };  // play through in case we disabled address translation\n    // two potential exception sources:\n    // 1. HPTW threw an exception -> signal with a page fault exception\n    // 2. We got an access error because of insufficient permissions -> throw an access exception\n    icache_areq_o.fetch_exception = '0;\n    // Check whether we are allowed to access this memory region from a fetch perspective\n    iaccess_err   = icache_areq_i.fetch_req && (((priv_lvl_i == riscv::PRIV_LVL_U) && ~itlb_content.u)\n                                                 || ((priv_lvl_i == riscv::PRIV_LVL_S) && itlb_content.u));\n\n    // MMU enabled: address from TLB, request delayed until hit. Error when TLB\n    // hit and no access right or TLB hit and translated address not valid (e.g.\n    // AXI decode error), or when PTW performs walk due to ITLB miss and raises\n    // an error.\n    if (enable_translation_i) begin\n      // we work with SV32, so if VM is enabled, check that all bits [riscv::VLEN-1:riscv::SV-1] are equal\n      if (icache_areq_i.fetch_req && !((&icache_areq_i.fetch_vaddr[riscv::VLEN-1:riscv::SV-1]) == 1'b1 || (|icache_areq_i.fetch_vaddr[riscv::VLEN-1:riscv::SV-1]) == 1'b0)) begin\n        icache_areq_o.fetch_exception.cause = riscv::INSTR_ACCESS_FAULT;\n        icache_areq_o.fetch_exception.valid = 1'b1;\n        if (CVA6Cfg.TvalEn)\n          icache_areq_o.fetch_exception.tval = {\n            {riscv::XLEN - riscv::VLEN{1'b0}}, icache_areq_i.fetch_vaddr\n          };\n      end\n\n      icache_areq_o.fetch_valid = 1'b0;\n\n      // 4K page\n      icache_areq_o.fetch_paddr = {itlb_content.ppn, icache_areq_i.fetch_vaddr[11:0]};\n      // Mega page\n      if (itlb_is_4M) begin\n        icache_areq_o.fetch_paddr[21:12] = icache_areq_i.fetch_vaddr[21:12];\n      end\n\n\n      // ---------\n      // ITLB Hit\n      // --------\n      // if we hit the ITLB output the request signal immediately\n      if (itlb_lu_hit) begin\n        icache_areq_o.fetch_valid = icache_areq_i.fetch_req;\n        // we got an access error\n        if (iaccess_err) begin\n          // throw a page fault\n          icache_areq_o.fetch_exception.cause = riscv::INSTR_PAGE_FAULT;\n          icache_areq_o.fetch_exception.valid = 1'b1;\n          if (CVA6Cfg.TvalEn)\n            icache_areq_o.fetch_exception.tval = {\n              {riscv::XLEN - riscv::VLEN{1'b0}}, icache_areq_i.fetch_vaddr\n            };\n          //to check on wave --> not connected\n        end else if (!pmp_instr_allow) begin\n          icache_areq_o.fetch_exception.cause = riscv::INSTR_ACCESS_FAULT;\n          icache_areq_o.fetch_exception.valid = 1'b1;\n          if (CVA6Cfg.TvalEn) icache_areq_o.fetch_exception.tval = icache_areq_i.fetch_vaddr;\n          //to check on wave --> not connected\n        end\n      end else\n      // ---------\n      // ITLB Miss\n      // ---------\n      // watch out for exceptions happening during walking the page table\n      if (ptw_active && walking_instr) begin\n        icache_areq_o.fetch_valid = ptw_error | ptw_access_exception;\n        if (ptw_error) begin\n          icache_areq_o.fetch_exception.cause = riscv::INSTR_PAGE_FAULT;\n          icache_areq_o.fetch_exception.valid = 1'b1;\n          if (CVA6Cfg.TvalEn)\n            icache_areq_o.fetch_exception.tval = {{riscv::XLEN - riscv::VLEN{1'b0}}, update_vaddr};\n        end  //to check on wave\n        // TODO(moschn,zarubaf): What should the value of tval be in this case?\n        else begin\n          icache_areq_o.fetch_exception.cause = riscv::INSTR_ACCESS_FAULT;\n          icache_areq_o.fetch_exception.valid = 1'b1;\n          if (CVA6Cfg.TvalEn) icache_areq_o.fetch_exception.tval = ptw_bad_paddr[riscv::PLEN-1:2];\n        end\n      end\n    end\n    // if it didn't match any execute region throw an `Instruction Access Fault`\n    // or: if we are not translating, check PMPs immediately on the paddr\n    if (!match_any_execute_region || (!enable_translation_i && !pmp_instr_allow)) begin\n      icache_areq_o.fetch_exception.cause = riscv::INSTR_ACCESS_FAULT;\n      icache_areq_o.fetch_exception.valid = 1'b1;\n      if (CVA6Cfg.TvalEn)\n        icache_areq_o.fetch_exception.tval = icache_areq_o.fetch_paddr[riscv::PLEN-1:2];\n      //to check on wave --> not connected\n    end\n  end\n\n  // check for execute flag on memory\n  assign match_any_execute_region = config_pkg::is_inside_execute_regions(\n      CVA6Cfg, {{64 - riscv::PLEN{1'b0}}, icache_areq_o.fetch_paddr}\n  );\n\n  // Instruction fetch\n  pmp #(\n      .PLEN      (riscv::PLEN),\n      .PMP_LEN   (riscv::PLEN - 2),\n      .NR_ENTRIES(CVA6Cfg.NrPMPEntries)\n  ) i_pmp_if (\n      .addr_i       (icache_areq_o.fetch_paddr),\n      .priv_lvl_i,\n      // we will always execute on the instruction fetch port\n      .access_type_i(riscv::ACCESS_EXEC),\n      // Configuration\n      .conf_addr_i  (pmpaddr_i),\n      .conf_i       (pmpcfg_i),\n      .allow_o      (pmp_instr_allow)\n  );\n\n  //-----------------------\n  // Data Interface\n  //-----------------------\n  logic [riscv::VLEN-1:0] lsu_vaddr_n, lsu_vaddr_q;\n  riscv::pte_sv32_t dtlb_pte_n, dtlb_pte_q;\n  exception_t misaligned_ex_n, misaligned_ex_q;\n  logic lsu_req_n, lsu_req_q;\n  logic lsu_is_store_n, lsu_is_store_q;\n  logic dtlb_hit_n, dtlb_hit_q;\n  logic dtlb_is_4M_n, dtlb_is_4M_q;\n\n  // check if we need to do translation or if we are always ready (e.g.: we are not translating anything)\n  assign lsu_dtlb_hit_o = (en_ld_st_translation_i) ? dtlb_lu_hit : 1'b1;\n\n  // Wires to PMP checks\n  riscv::pmp_access_t pmp_access_type;\n  logic               pmp_data_allow;\n  localparam PPNWMin = (riscv::PPNW - 1 > 29) ? 29 : riscv::PPNW - 1;\n  // The data interface is simpler and only consists of a request/response interface\n  always_comb begin : data_interface\n    // save request and DTLB response\n    lsu_vaddr_n     = lsu_vaddr_i;\n    lsu_req_n       = lsu_req_i;\n    misaligned_ex_n = misaligned_ex_i;\n    dtlb_pte_n      = dtlb_content;\n    dtlb_hit_n      = dtlb_lu_hit;\n    lsu_is_store_n  = lsu_is_store_i;\n    dtlb_is_4M_n    = dtlb_is_4M;\n\n    if (riscv::PLEN > riscv::VLEN) begin\n      lsu_paddr_o    = {{riscv::PLEN - riscv::VLEN{1'b0}}, lsu_vaddr_q};\n      lsu_dtlb_ppn_o = {{riscv::PLEN - riscv::VLEN{1'b0}}, lsu_vaddr_n[riscv::VLEN-1:12]};\n    end else begin\n      lsu_paddr_o    = {2'b00, lsu_vaddr_q[riscv::VLEN-1:0]};\n      lsu_dtlb_ppn_o = lsu_vaddr_n[riscv::PPNW-1:0];\n    end\n    lsu_valid_o = lsu_req_q;\n    lsu_exception_o = misaligned_ex_q;\n    pmp_access_type = lsu_is_store_q ? riscv::ACCESS_WRITE : riscv::ACCESS_READ;\n\n    // mute misaligned exceptions if there is no request otherwise they will throw accidental exceptions\n    misaligned_ex_n.valid = misaligned_ex_i.valid & lsu_req_i;\n\n    // Check if the User flag is set, then we may only access it in supervisor mode\n    // if SUM is enabled\n    daccess_err = (ld_st_priv_lvl_i == riscv::PRIV_LVL_S && !sum_i && dtlb_pte_q.u) || // SUM is not set and we are trying to access a user page in supervisor mode\n    (ld_st_priv_lvl_i == riscv::PRIV_LVL_U && !dtlb_pte_q.u);            // this is not a user page but we are in user mode and trying to access it\n    // translation is enabled and no misaligned exception occurred\n    if (en_ld_st_translation_i && !misaligned_ex_q.valid) begin\n      lsu_valid_o = 1'b0;\n      // 4K page\n      lsu_paddr_o = {dtlb_pte_q.ppn, lsu_vaddr_q[11:0]};\n      lsu_dtlb_ppn_o = dtlb_content.ppn;\n      // Mega page\n      if (dtlb_is_4M_q) begin\n        lsu_paddr_o[21:12] = lsu_vaddr_q[21:12];\n        lsu_dtlb_ppn_o[21:12] = lsu_vaddr_n[21:12];\n      end\n      // ---------\n      // DTLB Hit\n      // --------\n      if (dtlb_hit_q && lsu_req_q) begin\n        lsu_valid_o = 1'b1;\n        // exception priority:\n        // PAGE_FAULTS have higher priority than ACCESS_FAULTS\n        // virtual memory based exceptions are PAGE_FAULTS\n        // physical memory based exceptions are ACCESS_FAULTS (PMA/PMP)\n\n        // this is a store\n        if (lsu_is_store_q) begin\n          // check if the page is write-able and we are not violating privileges\n          // also check if the dirty flag is set\n          if (!dtlb_pte_q.w || daccess_err || !dtlb_pte_q.d) begin\n            lsu_exception_o.cause = riscv::STORE_PAGE_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn)\n              lsu_exception_o.tval = {\n                {riscv::XLEN - riscv::VLEN{lsu_vaddr_q[riscv::VLEN-1]}}, lsu_vaddr_q\n              };\n            // to check on wave\n            // Check if any PMPs are violated\n          end else if (!pmp_data_allow) begin\n            lsu_exception_o.cause = riscv::ST_ACCESS_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn) lsu_exception_o.tval = lsu_paddr_o[riscv::PLEN-1:2];\n            //only 32 bits on 34b of lsu_paddr_o are returned.\n          end\n\n          // this is a load\n        end else begin\n          // check for sufficient access privileges - throw a page fault if necessary\n          if (daccess_err) begin\n            lsu_exception_o.cause = riscv::LOAD_PAGE_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn)\n              lsu_exception_o.tval = {\n                {riscv::XLEN - riscv::VLEN{lsu_vaddr_q[riscv::VLEN-1]}}, lsu_vaddr_q\n              };\n            // Check if any PMPs are violated\n          end else if (!pmp_data_allow) begin\n            lsu_exception_o.cause = riscv::LD_ACCESS_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn) lsu_exception_o.tval = lsu_paddr_o[riscv::PLEN-1:2];\n          end\n        end\n      end else\n\n      // ---------\n      // DTLB Miss\n      // ---------\n      // watch out for exceptions\n      if (ptw_active && !walking_instr) "}
{"text": "begin\n        // page table walker threw an exception\n        if (ptw_error) begin\n          // an error makes the translation valid\n          lsu_valid_o = 1'b1;\n          // the page table walker can only throw page faults\n          if (lsu_is_store_q) begin\n            lsu_exception_o.cause = riscv::STORE_PAGE_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn)\n              lsu_exception_o.tval = {\n                {riscv::XLEN - riscv::VLEN{lsu_vaddr_q[riscv::VLEN-1]}}, update_vaddr\n              };\n          end else begin\n            lsu_exception_o.cause = riscv::LOAD_PAGE_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn)\n              lsu_exception_o.tval = {\n                {riscv::XLEN - riscv::VLEN{lsu_vaddr_q[riscv::VLEN-1]}}, update_vaddr\n              };\n          end\n        end\n\n        if (ptw_access_exception) begin\n          // an error makes the translation valid\n          lsu_valid_o = 1'b1;\n          // the page table walker can only throw page faults\n          lsu_exception_o.cause = riscv::LD_ACCESS_FAULT;\n          lsu_exception_o.valid = 1'b1;\n          if (CVA6Cfg.TvalEn) lsu_exception_o.tval = ptw_bad_paddr[riscv::PLEN-1:2];\n        end\n      end\n    end  // If translation is not enabled, check the paddr immediately against PMPs\n    else if (lsu_req_q && !misaligned_ex_q.valid && !pmp_data_allow) begin\n      if (lsu_is_store_q) begin\n        lsu_exception_o.cause = riscv::ST_ACCESS_FAULT;\n        lsu_exception_o.valid = 1'b1;\n        if (CVA6Cfg.TvalEn) lsu_exception_o.tval = lsu_paddr_o[riscv::PLEN-1:2];\n      end else begin\n        lsu_exception_o.cause = riscv::LD_ACCESS_FAULT;\n        lsu_exception_o.valid = 1'b1;\n        if (CVA6Cfg.TvalEn) lsu_exception_o.tval = lsu_paddr_o[riscv::PLEN-1:2];\n      end\n    end\n  end\n\n  // Load/store PMP check\n  pmp #(\n      .PLEN      (riscv::PLEN),\n      .PMP_LEN   (riscv::PLEN - 2),\n      .NR_ENTRIES(CVA6Cfg.NrPMPEntries)\n  ) i_pmp_data (\n      .addr_i       (lsu_paddr_o),\n      .priv_lvl_i   (ld_st_priv_lvl_i),\n      .access_type_i(pmp_access_type),\n      // Configuration\n      .conf_addr_i  (pmpaddr_i),\n      .conf_i       (pmpcfg_i),\n      .allow_o      (pmp_data_allow)\n  );\n\n  // ----------\n  // Registers\n  // ----------\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      lsu_vaddr_q     <= '0;\n      lsu_req_q       <= '0;\n      misaligned_ex_q <= '0;\n      dtlb_pte_q      <= '0;\n      dtlb_hit_q      <= '0;\n      lsu_is_store_q  <= '0;\n      dtlb_is_4M_q    <= '0;\n    end else begin\n      lsu_vaddr_q     <= lsu_vaddr_n;\n      lsu_req_q       <= lsu_req_n;\n      misaligned_ex_q <= misaligned_ex_n;\n      dtlb_pte_q      <= dtlb_pte_n;\n      dtlb_hit_q      <= dtlb_hit_n;\n      lsu_is_store_q  <= lsu_is_store_n;\n      dtlb_is_4M_q    <= dtlb_is_4M_n;\n    end\n  end\nendmodule\n"}
{"text": "// Copyright (c) 2021 Thales.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Sebastien Jacq Thales Research & Technology\n// Date: 17/07/2021\n//\n// Additional contributions by:\n//         Sebastien Jacq - sjthales on github.com\n//\n// Description: Hardware-PTW (Page-Table-Walker) for MMU Sv32.\n//              This module is an adaptation of the Sv39 PTW developed\n//              by Florian Zaruba and David Schaffenrath to the Sv32 standard.\n//\n// =========================================================================== //\n// Revisions  :\n// Date        Version  Author       Description\n// 2020-02-17  0.1      S.Jacq       PTW Sv32 for CV32A6\n// =========================================================================== //\n\n/* verilator lint_off WIDTH */\n\nmodule cva6_ptw_sv32\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int ASID_WIDTH = 1\n) (\n    input  logic clk_i,                  // Clock\n    input  logic rst_ni,                 // Asynchronous reset active low\n    input  logic flush_i,                // flush everything, we need to do this because\n                                         // actually everything we do is speculative at this stage\n                                         // e.g.: there could be a CSR instruction that changes everything\n    output logic ptw_active_o,\n    output logic walking_instr_o,        // set when walking for TLB\n    output logic ptw_error_o,            // set when an error occurred\n    output logic ptw_access_exception_o, // set when an PMP access exception occured\n\n    input  logic          lsu_is_store_i,  // this translation was triggered by a store\n    // PTW memory interface\n    input  dcache_req_o_t req_port_i,\n    output dcache_req_i_t req_port_o,\n\n    // to Shared TLB, update logic\n    output tlb_update_sv32_t shared_tlb_update_o,\n\n    output logic [riscv::VLEN-1:0] update_vaddr_o,\n\n    input logic [ASID_WIDTH-1:0] asid_i,\n\n    // from shared TLB\n    input logic                   shared_tlb_access_i,\n    input logic                   shared_tlb_hit_i,\n    input logic [riscv::VLEN-1:0] shared_tlb_vaddr_i,\n\n    input logic itlb_req_i,\n\n    // from CSR file\n    input logic [riscv::PPNW-1:0] satp_ppn_i,  // ppn from satp\n    input logic                   mxr_i,\n\n    // Performance counters\n    output logic shared_tlb_miss_o,\n\n    // PMP\n    input riscv::pmpcfg_t [15:0] pmpcfg_i,\n    input logic [15:0][riscv::PLEN-3:0] pmpaddr_i,\n    output logic [riscv::PLEN-1:0] bad_paddr_o\n\n);\n\n  // input registers\n  logic data_rvalid_q;\n  riscv::xlen_t data_rdata_q;\n\n  riscv::pte_sv32_t pte;\n  assign pte = riscv::pte_sv32_t'(data_rdata_q);\n\n\n  enum logic [2:0] {\n    IDLE,\n    WAIT_GRANT,\n    PTE_LOOKUP,\n    WAIT_RVALID,\n    PROPAGATE_ERROR,\n    PROPAGATE_ACCESS_ERROR,\n    LATENCY\n  }\n      state_q, state_d;\n\n  // SV32 defines two levels of page tables\n  enum logic {\n    LVL1,\n    LVL2\n  }\n      ptw_lvl_q, ptw_lvl_n;\n\n  // is this an instruction page table walk?\n  logic is_instr_ptw_q, is_instr_ptw_n;\n  logic global_mapping_q, global_mapping_n;\n  // latched tag signal\n  logic tag_valid_n, tag_valid_q;\n  // register the ASID\n  logic [ASID_WIDTH-1:0] tlb_update_asid_q, tlb_update_asid_n;\n  // register the VPN we need to walk, SV32 defines a 32 bit virtual address\n  logic [riscv::VLEN-1:0] vaddr_q, vaddr_n;\n  // 4 byte aligned physical pointer\n  logic [riscv::PLEN-1:0] ptw_pptr_q, ptw_pptr_n;\n\n  // Assignments\n  assign update_vaddr_o = vaddr_q;\n\n  assign ptw_active_o = (state_q != IDLE);\n  //assign walking_instr_o = is_instr_ptw_q;\n  assign walking_instr_o = is_instr_ptw_q;\n  // directly output the correct physical address\n  assign req_port_o.address_index = ptw_pptr_q[DCACHE_INDEX_WIDTH-1:0];\n  assign req_port_o.address_tag   = ptw_pptr_q[DCACHE_INDEX_WIDTH+DCACHE_TAG_WIDTH-1:DCACHE_INDEX_WIDTH];\n  // we are never going to kill this request\n  assign req_port_o.kill_req = '0;\n  // we are never going to write with the HPTW\n  assign req_port_o.data_wdata = '0;\n  // we only issue one single request at a time\n  assign req_port_o.data_id = '0;\n\n  // -----------\n  // Shared TLB Update\n  // -----------\n  assign shared_tlb_update_o.vpn = vaddr_q[riscv::SV-1:12];\n  // update the correct page table level\n  assign shared_tlb_update_o.is_4M = (ptw_lvl_q == LVL1);\n  // output the correct ASID\n  assign shared_tlb_update_o.asid = tlb_update_asid_q;\n  // set the global mapping bit\n  assign shared_tlb_update_o.content = pte | (global_mapping_q << 5);\n\n\n  assign req_port_o.tag_valid = tag_valid_q;\n\n  logic allow_access;\n\n  assign bad_paddr_o = ptw_access_exception_o ? ptw_pptr_q : 'b0;\n\n  pmp #(\n      .CVA6Cfg   (CVA6Cfg),\n      .PLEN      (riscv::PLEN),\n      .PMP_LEN   (riscv::PLEN - 2),\n      .NR_ENTRIES(CVA6Cfg.NrPMPEntries)\n  ) i_pmp_ptw (\n      .addr_i       (ptw_pptr_q),\n      // PTW access are always checked as if in S-Mode...\n      .priv_lvl_i   (riscv::PRIV_LVL_S),\n      // ...and they are always loads\n      .access_type_i(riscv::ACCESS_READ),\n      // Configuration\n      .conf_addr_i  (pmpaddr_i),\n      .conf_i       (pmpcfg_i),\n      .allow_o      (allow_access)\n  );\n\n\n  assign req_port_o.data_be = be_gen_32(req_port_o.address_index[1:0], req_port_o.data_size);\n\n  //-------------------\n  // Page table walker\n  //-------------------\n  // A virtual address va is translated into a physical address pa as follows:\n  // 1. Let a be sptbr.ppn \u00d7 PAGESIZE, and let i = LEVELS-1. (For Sv39,\n  //    PAGESIZE=2^12 and LEVELS=3.)\n  // 2. Let pte be the value of the PTE at address a+va.vpn[i]\u00d7PTESIZE. (For\n  //    Sv32, PTESIZE=4.)\n  // 3. If pte.v = 0, or if pte.r = 0 and pte.w = 1, stop and raise an access\n  //    exception.\n  // 4. Otherwise, the PTE is valid. If pte.r = 1 or pte.x = 1, go to step 5.\n  //    Otherwise, this PTE is a pointer to the next level of the page table.\n  //    Let i=i-1. If i < 0, stop and raise an access exception. Otherwise, let\n  //    a = pte.ppn \u00d7 PAGESIZE and go to step 2.\n  // 5. A leaf PTE has been found. Determine if the requested memory access\n  //    is allowed by the pte.r, pte.w, and pte.x bits. If not, stop and\n  //    raise an access exception. Otherwise, the translation is successful.\n  //    Set pte.a to 1, and, if the memory access is a store, set pte.d to 1.\n  //    The translated physical address is given as follows:\n  //      - pa.pgoff = va.pgoff.\n  //      - If i > 0, then this is a superpage translation and\n  //        pa.ppn[i-1:0] = va.vpn[i-1:0].\n  //      - pa.ppn[LEVELS-1:i] = pte.ppn[LEVELS-1:i].\n  always_comb begin : ptw\n    // default assignments\n    // PTW memory interface\n    tag_valid_n               = 1'b0;\n    req_port_o.data_req       = 1'b0;\n    req_port_o.data_size      = 2'b10;\n    req_port_o.data_we        = 1'b0;\n    ptw_error_o               = 1'b0;\n    ptw_access_exception_o    = 1'b0;\n    shared_tlb_update_o.valid = 1'b0;\n    is_instr_ptw_n            = is_instr_ptw_q;\n    ptw_lvl_n                 = ptw_lvl_q;\n    ptw_pptr_n                = ptw_pptr_q;\n    state_d                   = state_q;\n    global_mapping_n          = global_mapping_q;\n    // input registers\n    tlb_update_asid_n         = tlb_update_asid_q;\n    vaddr_n                   = vaddr_q;\n\n    shared_tlb_miss_o         = 1'b0;\n\n    case (state_q)\n\n      IDLE: begin\n        // by default we start with the top-most page table\n        ptw_lvl_n        = LVL1;\n        global_mapping_n = 1'b0;\n        is_instr_ptw_n   = 1'b0;\n        // if we got a Shared TLB miss\n        if (shared_tlb_access_i & ~shared_tlb_hit_i) begin\n          ptw_pptr_n = {\n            satp_ppn_i, shared_tlb_vaddr_i[riscv::SV-1:22], 2'b0\n          };  // SATP.PPN * PAGESIZE + VPN*PTESIZE = SATP.PPN * 2^(12) + VPN*4\n          is_instr_ptw_n = itlb_req_i;\n          tlb_update_asid_n = asid_i;\n          vaddr_n = shared_tlb_vaddr_i;\n          state_d = WAIT_GRANT;\n          shared_tlb_miss_o = 1'b1;\n        end\n      end\n\n      WAIT_GRANT: begin\n        // send a request out\n        req_port_o.data_req = 1'b1;\n        // wait for the WAIT_GRANT\n        if (req_port_i.data_gnt) begin\n          // send the tag valid signal one cycle later\n          tag_valid_n = 1'b1;\n          state_d     = PTE_LOOKUP;\n        end\n      end\n\n      PTE_LOOKUP: begin\n        // we wait for the valid signal\n        if (data_rvalid_q) begin\n\n          // check if the global mapping bit is set\n          if (pte.g) global_mapping_n = 1'b1;\n\n          // -------------\n          // Invalid PTE\n          // -------------\n          // If pte.v = 0, or if pte.r = 0 and pte.w = 1, stop and raise a page-fault exception.\n          if (!pte.v || (!pte.r && pte.w)) state_d = PROPAGATE_ERROR;\n          // -----------\n          // Valid PTE\n          // -----------\n          else begin\n            //state_d = IDLE;\n            state_d = LATENCY;\n            // it is a valid PTE\n            // if pte.r = 1 or pte.x = 1 it is a valid PTE\n            if (pte.r || pte.x) begin\n              // Valid translation found (either 4M or 4K entry)\n              if (is_instr_ptw_q) begin\n                // ------------\n                // Update ITLB\n                // ------------\n                // If page is not executable, we can directly raise an error. This\n                // doesn't put a useless entry into the TLB. The same idea applies\n                // to the access flag since we let the access flag be managed by SW.\n                if (!pte.x || !pte.a) state_d = PROPAGATE_ERROR;\n                else shared_tlb_update_o.valid = 1'b1;\n\n              end else begin\n                // ------------\n                // Update DTLB\n                // ------------\n                // Check if the access flag has been set, otherwise throw a page-fault\n                // and let the software handle those bits.\n                // If page is not readable (there are no write-only pages)\n                // we can directly raise an error. This doesn't put a useless\n                // entry into the TLB.\n                if (pte.a && (pte.r || (pte.x && mxr_i))) begin\n                  shared_tlb_update_o.valid = 1'b1;\n                end else begin\n                  state_d = PROPAGATE_ERROR;\n                end\n                // Request is a store: perform some additional checks\n                // If the request was a store and the page is not write-able, raise an error\n                // the same applies if the dirty flag is not set\n                if (lsu_is_store_i && (!pte.w || !pte.d)) begin\n                  shared_tlb_update_o.valid = 1'b0;\n                  state_d = PROPAGATE_ERROR;\n                end\n              end\n              // check if the ppn is correctly aligned:\n              // 6. If i > 0 and pa.ppn[i \u2212 1 : 0] != 0, this is a misaligned superpage; stop and raise a page-fault\n              // exception.\n              if (ptw_lvl_q == LVL1 && pte.ppn[9:0] != '0) begin\n                state_d                   = PROPAGATE_ERROR;\n                shared_tlb_update_o.valid = 1'b0;\n              end\n              // this is a pointer to the next TLB level\n            end else begin\n              // pointer to next level of page table\n              if (ptw_lvl_q == LVL1) begin\n                // we are in the second level now\n                ptw_lvl_n  = LVL2;\n                ptw_pptr_n = {pte.ppn, vaddr_q[21:12], 2'b0};\n              end\n\n              state_d = WAIT_GRANT;\n\n              if (ptw_lvl_q == LVL2) begin\n                // Should already be the last level page table => Error\n                ptw_lvl_n = LVL2;\n                state_d   = PROPAGATE_ERROR;\n              end\n            end\n          end\n\n          // Check if this access was actually allowed from a PMP perspective\n          if (!allow_access) begin\n            shared_tlb_update_o.valid = 1'b0;\n            // we have to return the failed address in bad_addr\n            ptw_pptr_n = ptw_pptr_q;\n            state_d = PROPAGATE_ACCESS_ERROR;\n          end\n        end\n        // we've got a data WAIT_GRANT so tell the cache that the tag is valid\n      end\n      // Propagate error to MMU/LSU\n      PROPAGATE_ERROR: begin\n        state_d     = LATENCY;\n        ptw_error_o = 1'b1;\n      end\n      PROPAGATE_ACCESS_ERROR: begin\n        state_d                = LATENCY;\n        ptw_access_exception_o = 1'b1;\n      end\n      // wait for the rvalid before going back to IDLE\n      WAIT_RVALID: begin\n        if (data_rvalid_q) state_d = IDLE;\n      end\n      LATENCY: begin\n        state_d = IDLE;\n      end\n      default: begin\n        state_d = IDLE;\n      end\n    endcase\n\n    // -------\n    // Flush\n    // -------\n    // should we have flushed before we got an rvalid, wait for it until going back to IDLE\n    if (flush_i) begin\n      // on a flush check whether we are\n      // 1. in the PTE Lookup check whether we still need to wait for an rvalid\n      // 2. waiting for a grant, if so: wait for it\n      // if not, go back to idle\n      if (((state_q inside {PTE_LOOKUP, WAIT_RVALID}) && !data_rvalid_q) ||\n                ((state_q == WAIT_GRANT) && req_port_i.data_gnt))\n        state_d = WAIT_RVALID;\n      else state_d = LATENCY;\n    end\n  end\n\n  // sequential process\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      state_q           <= IDLE;\n      is_instr_ptw_q    <= 1'b0;\n      ptw_lvl_q         <= LVL1;\n      tag_valid_q       <= 1'b0;\n      tlb_update_asid_q <= '0;\n      vaddr_q           <= '0;\n      ptw_pptr_q        <= '0;\n      global_mapping_q  <= 1'b0;\n      data_rdata_q      <= '0;\n      data_rvalid_q     <= 1'b0;\n    end else begin\n      state_q           <= state_d;\n      ptw_pptr_q        <= ptw_pptr_n;\n      is_instr_ptw_q    <= is_instr_ptw_n;\n      ptw_lvl_q         <= ptw_lvl_n;\n      tag_valid_q       <= tag_valid_n;\n      tlb_update_asid_q <= tlb_update_asid_n;\n      vaddr_q           <= vaddr_n;\n      global_mapping_q  <= global_mapping_n;\n      data_rdata_q      <= req_port_i.data_rdata;\n      data_rvalid_q     <= req_port_i.data_rvalid;\n    end\n  end\n\nendmodule\n/* verilator lint_on WIDTH */\n"}
{"text": "// Copyright 2024 Thales DIS France SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Yannick Casamatta - Thales\n// Date: 09/01/2024\n\n\nmodule cva6_rvfi\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter type rvfi_instr_t = logic,\n    parameter type rvfi_csr_t = logic,\n    parameter type rvfi_probes_t = logic\n\n) (\n\n    input logic clk_i,\n    input logic rst_ni,\n\n    input rvfi_probes_t rvfi_probes_i,\n    output rvfi_instr_t [CVA6Cfg.NrCommitPorts-1:0] rvfi_instr_o,\n    output rvfi_csr_t rvfi_csr_o\n\n\n);\n\n  // ------------------------------------------\n  // CVA6 configuration\n  // ------------------------------------------\n  // Extended config\n  localparam bit RVF = (riscv::IS_XLEN64 | riscv::IS_XLEN32) & CVA6Cfg.FpuEn;\n  localparam bit RVD = (riscv::IS_XLEN64 ? 1 : 0) & CVA6Cfg.FpuEn;\n  localparam bit FpPresent = RVF | RVD | CVA6Cfg.XF16 | CVA6Cfg.XF16ALT | CVA6Cfg.XF8;\n\n  localparam riscv::xlen_t IsaCode = (riscv::XLEN'(CVA6Cfg.RVA) <<  0)                // A - Atomic Instructions extension\n  | (riscv::XLEN'(CVA6Cfg.RVB) << 1)  // C - Bitmanip extension\n  | (riscv::XLEN'(CVA6Cfg.RVC) << 2)  // C - Compressed extension\n  | (riscv::XLEN'(CVA6Cfg.RVD) << 3)  // D - Double precision floating-point extension\n  | (riscv::XLEN'(CVA6Cfg.RVF) << 5)  // F - Single precision floating-point extension\n  | (riscv::XLEN'(1) << 8)  // I - RV32I/64I/128I base ISA\n  | (riscv::XLEN'(1) << 12)  // M - Integer Multiply/Divide extension\n  | (riscv::XLEN'(0) << 13)  // N - User level interrupts supported\n  | (riscv::XLEN'(CVA6Cfg.RVS) << 18)  // S - Supervisor mode implemented\n  | (riscv::XLEN'(CVA6Cfg.RVU) << 20)  // U - User mode implemented\n  | (riscv::XLEN'(CVA6Cfg.RVV) << 21)  // V - Vector extension\n  | (riscv::XLEN'(CVA6Cfg.NSX) << 23)  // X - Non-standard extensions present\n  | ((riscv::XLEN == 64 ? 2 : 1) << riscv::XLEN - 2);  // MXL\n\n  localparam riscv::xlen_t hart_id_i = '0;\n  logic flush;\n  logic issue_instr_ack;\n  logic fetch_entry_valid;\n  logic [31:0] instruction;\n  logic is_compressed;\n\n  logic [TRANS_ID_BITS-1:0] issue_pointer;\n  logic [CVA6Cfg.NrCommitPorts-1:0][TRANS_ID_BITS-1:0] commit_pointer;\n\n  logic flush_unissued_instr;\n  logic decoded_instr_valid;\n  logic decoded_instr_ack;\n\n  riscv::xlen_t rs1_forwarding;\n  riscv::xlen_t rs2_forwarding;\n\n  scoreboard_entry_t [CVA6Cfg.NrCommitPorts-1:0] commit_instr;\n  exception_t ex_commit;\n  riscv::priv_lvl_t priv_lvl;\n\n  lsu_ctrl_t lsu_ctrl;\n  logic [((CVA6Cfg.CvxifEn || CVA6Cfg.RVV) ? 5 : 4)-1:0][riscv::XLEN-1:0] wbdata;\n  logic [CVA6Cfg.NrCommitPorts-1:0] commit_ack;\n  logic [riscv::PLEN-1:0] mem_paddr;\n  logic debug_mode;\n  logic [CVA6Cfg.NrCommitPorts-1:0][riscv::XLEN-1:0] wdata;\n\n  logic [riscv::VLEN-1:0] lsu_addr;\n  logic [(riscv::XLEN/8)-1:0] lsu_rmask;\n  logic [(riscv::XLEN/8)-1:0] lsu_wmask;\n  logic [TRANS_ID_BITS-1:0] lsu_addr_trans_id;\n\n  riscv::pmpcfg_t [15:0] pmpcfg_q, pmpcfg_d;\n\n  rvfi_probes_csr_t   csr;\n  rvfi_probes_instr_t instr;\n\n  always_comb begin\n    csr   = '0;\n    instr = '0;\n\n    if ($bits(rvfi_probes_i.instr) == $bits(instr)) begin\n      instr = rvfi_probes_i.instr;\n    end\n\n    if ($bits(rvfi_probes_i.csr) == $bits(csr)) begin\n      csr = rvfi_probes_i.csr;\n    end\n\n  end\n\n\n  assign flush = instr.flush;\n  assign issue_instr_ack = instr.issue_instr_ack;\n  assign fetch_entry_valid = instr.fetch_entry_valid;\n  assign instruction = instr.instruction;\n  assign is_compressed = instr.is_compressed;\n\n  assign issue_pointer = instr.issue_pointer;\n  assign commit_pointer = instr.commit_pointer;\n\n  assign flush_unissued_instr = instr.flush_unissued_instr;\n  assign decoded_instr_valid = instr.decoded_instr_valid;\n  assign decoded_instr_ack = instr.decoded_instr_ack;\n\n  assign rs1_forwarding = instr.rs1_forwarding;\n  assign rs2_forwarding = instr.rs2_forwarding;\n\n  assign commit_instr = instr.commit_instr;\n  assign ex_commit = instr.ex_commit;\n  assign priv_lvl = instr.priv_lvl;\n\n  assign lsu_ctrl = instr.lsu_ctrl;\n  assign wbdata = instr.wbdata;\n  assign commit_ack = instr.commit_ack;\n  assign mem_paddr = instr.mem_paddr;\n  assign debug_mode = instr.debug_mode;\n  assign wdata = instr.wdata;\n\n  assign lsu_addr = lsu_ctrl.vaddr;\n  assign lsu_rmask = lsu_ctrl.fu == LOAD ? lsu_ctrl.be : '0;\n  assign lsu_wmask = lsu_ctrl.fu == STORE ? lsu_ctrl.be : '0;\n  assign lsu_addr_trans_id = lsu_ctrl.trans_id;\n\n\n  //ID STAGE\n\n  typedef struct packed {\n    logic        valid;\n    logic [31:0] instr;\n  } issue_struct_t;\n  issue_struct_t issue_n, issue_q;\n\n  always_comb begin\n    issue_n = issue_q;\n\n    if (issue_instr_ack) issue_n.valid = 1'b0;\n\n    if ((!issue_q.valid || issue_instr_ack) && fetch_entry_valid) begin\n      issue_n.valid = 1'b1;\n      issue_n.instr = (is_compressed) ? {{16{1'b0}}, instruction[15:0]} : instruction;\n    end\n\n    if (flush) issue_n.valid = 1'b0;\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      issue_q <= '0;\n    end else begin\n      issue_q <= issue_n;\n    end\n  end\n\n  //ISSUE STAGE\n\n  // this is the FIFO struct of the issue queue\n  typedef struct packed {\n    riscv::xlen_t rs1_rdata;\n    riscv::xlen_t rs2_rdata;\n    logic [riscv::VLEN-1:0] lsu_addr;\n    logic [(riscv::XLEN/8)-1:0] lsu_rmask;\n    logic [(riscv::XLEN/8)-1:0] lsu_wmask;\n    riscv::xlen_t lsu_wdata;\n    logic [31:0] instr;\n  } sb_mem_t;\n  sb_mem_t [NR_SB_ENTRIES-1:0] mem_q, mem_n;\n\n  always_comb begin : issue_fifo\n    mem_n = mem_q;\n\n    if (decoded_instr_valid && decoded_instr_ack && !flush_unissued_instr) begin\n      mem_n[issue_pointer] = '{\n          rs1_rdata: rs1_forwarding,\n          rs2_rdata: rs2_forwarding,\n          lsu_addr: '0,\n          lsu_rmask: '0,\n          lsu_wmask: '0,\n          lsu_wdata: '0,\n          instr: issue_q.instr\n      };\n    end\n\n    if (lsu_rmask != 0) begin\n      mem_n[lsu_addr_trans_id].lsu_addr  = lsu_addr;\n      mem_n[lsu_addr_trans_id].lsu_rmask = lsu_rmask;\n    end else if (lsu_wmask != 0) begin\n      mem_n[lsu_addr_trans_id].lsu_addr  = lsu_addr;\n      mem_n[lsu_addr_trans_id].lsu_wmask = lsu_wmask;\n      mem_n[lsu_addr_trans_id].lsu_wdata = wbdata[1];\n    end\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : regs\n    if (!rst_ni) begin\n      mem_q <= '{default: sb_mem_t'(0)};\n    end else begin\n      mem_q <= mem_n;\n    end\n  end\n\n  //----------------------------------------------------------------------------------------------------------\n  // PACK\n  //----------------------------------------------------------------------------------------------------------\n\n  always_comb begin\n    for (int i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin\n      logic exception;\n      exception = commit_instr[i].valid && ex_commit.valid;\n      rvfi_instr_o[i].valid    = (commit_ack[i] && !ex_commit.valid) ||\n        (exception && (ex_commit.cause == riscv::ENV_CALL_MMODE ||\n                  ex_commit.cause == riscv::ENV_CALL_SMODE ||\n                  ex_commit.cause == riscv::ENV_CALL_UMODE));\n      rvfi_instr_o[i].insn = mem_q[commit_pointer[i]].instr;\n      // when trap, the instruction is not executed\n      rvfi_instr_o[i].trap = exception;\n      rvfi_instr_o[i].cause = ex_commit.cause;\n      rvfi_instr_o[i].mode = (CVA6Cfg.DebugEn && debug_mode) ? 2'b10 : priv_lvl;\n      rvfi_instr_o[i].ixl = riscv::XLEN == 64 ? 2 : 1;\n      rvfi_instr_o[i].rs1_addr = commit_instr[i].rs1[4:0];\n      rvfi_instr_o[i].rs2_addr = commit_instr[i].rs2[4:0];\n      rvfi_instr_o[i].rd_addr = commit_instr[i].rd[4:0];\n      rvfi_instr_o[i].rd_wdata = (FpPresent && is_rd_fpr(commit_instr[i].op)) ?\n          commit_instr[i].result : wdata[i];\n      rvfi_instr_o[i].pc_rdata = commit_instr[i].pc;\n      rvfi_instr_o[i].mem_addr = mem_q[commit_pointer[i]].lsu_addr;\n      // So far, only write paddr is reported. TODO: read paddr\n      rvfi_instr_o[i].mem_paddr = mem_paddr;\n      rvfi_instr_o[i].mem_wmask = mem_q[commit_pointer[i]].lsu_wmask;\n      rvfi_instr_o[i].mem_wdata = mem_q[commit_pointer[i]].lsu_wdata;\n      rvfi_instr_o[i].mem_rmask = mem_q[commit_pointer[i]].lsu_rmask;\n      rvfi_instr_o[i].mem_rdata = commit_instr[i].result;\n      rvfi_instr_o[i].rs1_rdata = mem_q[commit_pointer[i]].rs1_rdata;\n      rvfi_instr_o[i].rs2_rdata = mem_q[commit_pointer[i]].rs2_rdata;\n    end\n  end\n\n\n  //----------------------------------------------------------------------------------------------------------\n  // CSR\n  //----------------------------------------------------------------------------------------------------------\n\n\n  always_comb begin\n\n    rvfi_csr_o.fflags = CVA6Cfg.FpPresent ?\n    '{rdata: {'0, csr.fcsr_q.fflags}, wdata: {'0, csr.fcsr_q.fflags}, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.frm = CVA6Cfg.FpPresent ?\n    '{rdata: {'0, csr.fcsr_q.frm}, wdata: {'0, csr.fcsr_q.frm}, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.fcsr = CVA6Cfg.FpPresent ?\n    '{\n        rdata: {'0, csr.fcsr_q.frm, csr.fcsr_q.fflags},\n        wdata: {'0, csr.fcsr_q.frm, csr.fcsr_q.fflags},\n        rmask: '1,\n        wmask: '1\n    }\n    : '0;\n    rvfi_csr_o.ftran = CVA6Cfg.FpPresent ?\n    '{rdata: {'0, csr.fcsr_q.fprec}, wdata: {'0, csr.fcsr_q.fprec}, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.dcsr = CVA6Cfg.DebugEn ?\n    '{rdata: {'0, csr.dcsr_q}, wdata: {'0, csr.dcsr_q}, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.dpc = CVA6Cfg.DebugEn ?\n    '{rdata: {csr.dpc_q}, wdata: csr.dpc_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.dscratch0 = CVA6Cfg.DebugEn ?\n    '{rdata: csr.dscratch0_q, wdata: csr.dscratch0_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.dscratch1 = CVA6Cfg.DebugEn ?\n    '{rdata: csr.dscratch1_q, wdata: csr.dscratch1_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.sstatus = CVA6Cfg.RVS ?\n    '{\n        rdata: csr.mstatus_extended & ariane_pkg::SMODE_STATUS_READ_MASK[riscv::XLEN-1:0],\n        wdata: csr.mstatus_extended & ariane_pkg::SMODE_STATUS_READ_MASK[riscv::XLEN-1:0],\n        rmask: '1,\n        wmask: '1\n    }\n    : '0;\n    rvfi_csr_o.sie = CVA6Cfg.RVS ?\n    '{rdata: csr.mie_q & csr.mideleg_q, wdata: csr.mie_q & csr.mideleg_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.sip = CVA6Cfg.RVS ?\n    '{rdata: csr.mip_q & csr.mideleg_q, wdata: csr.mip_q & csr.mideleg_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.stvec = CVA6Cfg.RVS ?\n    '{rdata: csr.stvec_q, wdata: csr.stvec_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.scounteren = CVA6Cfg.RVS ?\n    '{rdata: csr.scounteren_q, wdata: csr.scounteren_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.sscratch = CVA6Cfg.RVS ?\n    '{rdata: csr.sscratch_q, wdata: csr.sscratch_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.sepc = CVA6Cfg.RVS ?\n    '{rdata: csr.sepc_q, wdata: csr.sepc_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.scause = CVA6Cfg.RVS ?\n    '{rdata: csr.scause_q, wdata: csr.scause_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.stval = CVA6Cfg.RVS ?\n    '{rdata: csr.stval_q, wdata: csr.stval_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.satp = CVA6Cfg.RVS ?\n    '{rdata: csr.satp_q, wdata: csr.satp_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.mstatus = '{\n        rdata: csr.mstatus_extended,\n        wdata: csr.mstatus_extended,\n        rmask: '1,\n        wmask: '1\n    };\n    rvfi_csr_o.mstatush = riscv::XLEN == 32 ?\n    '{rdata: '0, wdata: '0, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.misa = '{rdata: IsaCode, wdata: IsaCode, rmask: '1, wmask: '1};\n    rvfi_csr_o.medeleg = CVA6Cfg.RVS ?\n    '{rdata: csr.medeleg_q, wdata: csr.medeleg_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.mideleg = CVA6Cfg.RVS ?\n    '{rdata: csr.mideleg_q, wdata: csr.mideleg_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.mie = '{rdata: csr.mie_q, wdata: csr.mie_q, rmask: '1, wmask: '1};\n    rvfi_csr_o.mtvec = '{rdata: csr.mtvec_q, wdata: csr.mtvec_q, rmask: '1, wmask: '1};\n    rvfi_csr_o.mcounteren = '{\n        rdata: csr.mcounteren_q,\n        wdata: csr.mcounteren_q,\n        rmask: '1,\n        wmask: '1\n    };\n    rvfi_csr_o.mscratch = '{rdata: csr.mscratch_q, wdata: csr.mscratch_q, rmask: '1, wmask: '1};\n    rvfi_csr_o.mepc = '{rdata: csr.mepc_q, wdata: csr.mepc_q, rmask: '1, wmask: '1};\n    rvfi_csr_o.mcause = '{rdata: csr.mcause_q, wdata: csr.mcause_q, rmask: '1, wmask: '1};\n    rvfi_csr_o.mtval = '{rdata: csr.mtval_q, wdata: csr.mtval_q, rmask: '1, wmask: '1};\n    rvfi_csr_o.mip = '{rdata: csr.mip_q, wdata: csr.mip_q, rmask: '1, wmask: '1};\n    rvfi_csr_o.menvcfg = '{\n        rdata: {'0, csr.fiom_q},\n        wdata: {'0, csr.fiom_q},\n        rmask: '1,\n        wmask: '1\n    };\n    rvfi_csr_o.menvcfgh = riscv::XLEN == 32 ?\n    '{rdata: '0, wdata: '0, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.mvendorid = '{\n        rdata: OPENHWGROUP_MVENDORID,\n        wdata: OPENHWGROUP_MVENDORID,\n        rmask: '1,\n        wmask: '1\n    };\n    rvfi_csr_o.marchid = '{rdata: ARIANE_MARCHID, wdata: ARIANE_MARCHID, rmask: '1, wmask: '1};\n    rvfi_csr_o.mhartid = '{rdata: hart_id_i, wdata: hart_id_i, rmask: '1, wmask: '1};\n    rvfi_csr_o.mcountinhibit = '{\n        rdata: {'0, csr.mcountinhibit_q},\n        wdata: {'0, csr.mcountinhibit_q},\n        rmask: '1,\n        wmask: '1\n    };\n    rvfi_csr_o.mcycle = '{\n        rdata: csr.cycle_q[riscv::XLEN-1:0],\n        wdata: csr.cycle_q[riscv::XLEN-1:0],\n        rmask: '1,\n        wmask: '1\n    };\n    rvfi_csr_o.mcycleh = riscv::XLEN == 32 ?\n    '{rdata: csr.cycle_q[63:32], wdata: csr.cycle_q[63:32], rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.minstret = '{\n        rdata: csr.instret_q[riscv::XLEN-1:0],\n        wdata: csr.instret_q[riscv::XLEN-1:0],\n        rmask: '1,\n        wmask: '1\n    };\n    rvfi_csr_o.minstreth = riscv::XLEN == 32 ?\n    '{rdata: csr.instret_q[63:32], wdata: csr.instret_q[63:32], rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.cycle = '{\n        rdata: csr.cycle_q[riscv::XLEN-1:0],\n        wdata: csr.cycle_q[riscv::XLEN-1:0],\n        rmask: '1,\n        wmask: '1\n    };\n    rvfi_csr_o.cycleh = riscv::XLEN == 32 ?\n    '{rdata: csr.cycle_q[63:32], wdata: csr.cycle_q[63:32], rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.instret = '{\n        rdata: csr.instret_q[riscv::XLEN-1:0],\n        wdata: csr.instret_q[riscv::XLEN-1:0],\n        rmask: '1,\n        wmask: '1\n    };\n    rvfi_csr_o.instreth = riscv::XLEN == 32 ?\n    '{rdata: csr.instret_q[63:32], wdata: csr.instret_q[63:32], rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.dcache = '{rdata: csr.dcache_q, wdata: csr.dcache_q, rmask: '1, wmask: '1};\n    rvfi_csr_o.icache = '{rdata: csr.icache_q, wdata: csr.icache_q, rmask: '1, wmask: '1};\n    rvfi_csr_o.acc_cons = CVA6Cfg.EnableAccelerator ?\n    '{rdata: csr.acc_cons_q, wdata: csr.acc_cons_q, rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.pmpcfg0 = '{\n        rdata: csr.pmpcfg_q[riscv::XLEN/8-1:0],\n        wdata: csr.pmpcfg_q[riscv::XLEN/8-1:0],\n        rmask: '1,\n        wmask: '1\n    };\n    rvfi_csr_o.pmpcfg1 = riscv::XLEN == 32 ?\n    '{rdata: csr.pmpcfg_q[7:4], wdata: csr.pmpcfg_q[7:4], rmask: '1, wmask: '1}\n    : '0;\n    rvfi_csr_o.pmpcfg2 = '{\n        rdata: csr.pmpcfg_q[8+:riscv::XLEN/8],\n        wdata: csr.pmpcfg_q[8+:riscv::XLEN/8],\n        rmask: '1,\n        wmask: '1\n    };\n    rvfi_csr_o.pmpcfg3 = riscv::XLEN == 32 ?\n    '{rdata: csr.pmpcfg_q[15:12], wdata: csr.pmpcfg_q[15:12], rmask: '1, wmask: '1}\n    : '0;\n\n    for (int i = 0; i < 16; i++) begin\n      rvfi_csr_o.pmpaddr[i] = '{\n          rdata:\n          csr.pmpcfg_q[i].addr_mode[1]\n          == 1'b1 ?\n          {'0, csr.pmpaddr_q[i][riscv::PLEN-3:0]}\n          : {\n          '0\n          ,\n          csr.pmpaddr_q[i][riscv::PLEN-3:1]\n          ,\n          1'b0\n          },\n          wdata:\n          csr.pmpcfg_q[i].addr_mode[1]\n          == 1'b1 ?\n          {'0, csr.pmpaddr_q[i][riscv::PLEN-3:0]}\n          : {\n          '0\n          ,\n          csr.pmpaddr_q[i][riscv::PLEN-3:1]\n          ,\n          1'b0\n          },\n          rmask: '1,\n          wmask: '1\n      };\n    end\n    ;\n\n  end\n\n\nendmodule\n"}
{"text": "// Copyright 2024 Thales DIS France SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Yannick Casamatta - Thales\n// Date: 09/01/2024\n\n\nmodule cva6_rvfi_probes\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter type rvfi_probes_t = logic\n\n) (\n\n    input logic        flush_i,\n    input logic        issue_instr_ack_i,\n    input logic        fetch_entry_valid_i,\n    input logic [31:0] instruction_i,\n    input logic        is_compressed_i,\n\n    input logic [TRANS_ID_BITS-1:0] issue_pointer_i,\n    input logic [CVA6Cfg.NrCommitPorts-1:0][TRANS_ID_BITS-1:0] commit_pointer_i,\n\n    input logic flush_unissued_instr_i,\n    input logic decoded_instr_valid_i,\n    input logic decoded_instr_ack_i,\n\n    input riscv::xlen_t rs1_forwarding_i,\n    input riscv::xlen_t rs2_forwarding_i,\n\n    input scoreboard_entry_t [CVA6Cfg.NrCommitPorts-1:0] commit_instr_i,\n    input exception_t ex_commit_i,\n    input riscv::priv_lvl_t priv_lvl_i,\n\n    input lsu_ctrl_t                                              lsu_ctrl_i,\n    input logic      [    CVA6Cfg.NrWbPorts-1:0][riscv::XLEN-1:0] wbdata_i,\n    input logic      [CVA6Cfg.NrCommitPorts-1:0]                  commit_ack_i,\n    input logic      [          riscv::PLEN-1:0]                  mem_paddr_i,\n    input logic                                                   debug_mode_i,\n    input logic      [CVA6Cfg.NrCommitPorts-1:0][riscv::XLEN-1:0] wdata_i,\n\n    input rvfi_probes_csr_t csr_i,\n\n    output rvfi_probes_t rvfi_probes_o\n);\n\n\n  rvfi_probes_csr_t   csr;\n  rvfi_probes_instr_t instr;\n\n  always_comb begin\n    csr = '0;\n    instr = '0;\n\n    instr.flush = flush_i;\n    instr.issue_instr_ack = issue_instr_ack_i;\n    instr.fetch_entry_valid = fetch_entry_valid_i;\n    instr.instruction = instruction_i;\n    instr.is_compressed = is_compressed_i;\n\n    instr.issue_pointer = issue_pointer_i;\n\n    instr.flush_unissued_instr = flush_unissued_instr_i;\n    instr.decoded_instr_valid = decoded_instr_valid_i;\n    instr.decoded_instr_ack = decoded_instr_ack_i;\n\n    instr.rs1_forwarding = rs1_forwarding_i;\n    instr.rs2_forwarding = rs2_forwarding_i;\n\n    instr.ex_commit = ex_commit_i;\n    instr.priv_lvl = priv_lvl_i;\n\n    instr.lsu_ctrl = lsu_ctrl_i;\n    instr.wbdata = wbdata_i;\n    instr.mem_paddr = mem_paddr_i;\n    instr.debug_mode = debug_mode_i;\n\n    instr.commit_pointer = commit_pointer_i;\n    instr.commit_instr = commit_instr_i;\n    instr.commit_ack = commit_ack_i;\n    instr.wdata = wdata_i;\n\n    csr = csr_i;\n\n  end\n\n\n  always_comb begin\n    rvfi_probes_o = '0;\n\n    if ($bits(rvfi_probes_o.instr) == $bits(instr)) begin\n      rvfi_probes_o.instr = instr;\n    end\n\n    if ($bits(rvfi_probes_o.csr) == $bits(csr)) begin\n      rvfi_probes_o.csr = csr;\n    end\n\n  end\n\n\nendmodule\n\n\n\n\n\n"}
{"text": "// Copyright (c) 2023 Thales.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Sebastien Jacq - Thales Research & Technology\n// Date: 08/03/2023\n//\n// Description: N-way associative shared TLB, it allows to reduce the number\n//              of ITLB and DTLB entries.\n//\n\n/* verilator lint_off WIDTH */\n\nmodule cva6_shared_tlb_sv32\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int SHARED_TLB_DEPTH = 64,\n    parameter int SHARED_TLB_WAYS = 2,\n    parameter int ASID_WIDTH = 1\n) (\n    input logic clk_i,   // Clock\n    input logic rst_ni,  // Asynchronous reset active low\n    input logic flush_i,\n\n    input logic enable_translation_i,   // CSRs indicate to enable SV32\n    input logic en_ld_st_translation_i, // enable virtual memory translation for load/stores\n\n    input logic [ASID_WIDTH-1:0] asid_i,\n\n    // from TLBs\n    // did we miss?\n    input logic                   itlb_access_i,\n    input logic                   itlb_hit_i,\n    input logic [riscv::VLEN-1:0] itlb_vaddr_i,\n\n    input logic                   dtlb_access_i,\n    input logic                   dtlb_hit_i,\n    input logic [riscv::VLEN-1:0] dtlb_vaddr_i,\n\n    // to TLBs, update logic\n    output tlb_update_sv32_t itlb_update_o,\n    output tlb_update_sv32_t dtlb_update_o,\n\n    // Performance counters\n    output logic itlb_miss_o,\n    output logic dtlb_miss_o,\n\n    output logic                   shared_tlb_access_o,\n    output logic                   shared_tlb_hit_o,\n    output logic [riscv::VLEN-1:0] shared_tlb_vaddr_o,\n\n    output logic itlb_req_o,\n\n    // Update shared TLB in case of miss\n    input tlb_update_sv32_t shared_tlb_update_i\n\n);\n\n  function logic [SHARED_TLB_WAYS-1:0] shared_tlb_way_bin2oh(input logic [$clog2(SHARED_TLB_WAYS\n)-1:0] in);\n    logic [SHARED_TLB_WAYS-1:0] out;\n    out     = '0;\n    out[in] = 1'b1;\n    return out;\n  endfunction\n\n  typedef struct packed {\n    logic [8:0] asid;   //9 bits wide\n    logic [9:0] vpn1;   //10 bits wide\n    logic [9:0] vpn0;   //10 bits wide\n    logic       is_4M;\n  } shared_tag_t;\n\n  shared_tag_t shared_tag_wr;\n  shared_tag_t [SHARED_TLB_WAYS-1:0] shared_tag_rd;\n\n  logic [SHARED_TLB_DEPTH-1:0][SHARED_TLB_WAYS-1:0] shared_tag_valid_q, shared_tag_valid_d;\n\n  logic [         SHARED_TLB_WAYS-1:0] shared_tag_valid;\n\n  logic [         SHARED_TLB_WAYS-1:0] tag_wr_en;\n  logic [$clog2(SHARED_TLB_DEPTH)-1:0] tag_wr_addr;\n  logic [     $bits(shared_tag_t)-1:0] tag_wr_data;\n\n  logic [         SHARED_TLB_WAYS-1:0] tag_rd_en;\n  logic [$clog2(SHARED_TLB_DEPTH)-1:0] tag_rd_addr;\n  logic [     $bits(shared_tag_t)-1:0] tag_rd_data      [SHARED_TLB_WAYS-1:0];\n\n  logic [         SHARED_TLB_WAYS-1:0] tag_req;\n  logic [         SHARED_TLB_WAYS-1:0] tag_we;\n  logic [$clog2(SHARED_TLB_DEPTH)-1:0] tag_addr;\n\n  logic [         SHARED_TLB_WAYS-1:0] pte_wr_en;\n  logic [$clog2(SHARED_TLB_DEPTH)-1:0] pte_wr_addr;\n  logic [$bits(riscv::pte_sv32_t)-1:0] pte_wr_data;\n\n  logic [         SHARED_TLB_WAYS-1:0] pte_rd_en;\n  logic [$clog2(SHARED_TLB_DEPTH)-1:0] pte_rd_addr;\n  logic [$bits(riscv::pte_sv32_t)-1:0] pte_rd_data      [SHARED_TLB_WAYS-1:0];\n\n  logic [         SHARED_TLB_WAYS-1:0] pte_req;\n  logic [         SHARED_TLB_WAYS-1:0] pte_we;\n  logic [$clog2(SHARED_TLB_DEPTH)-1:0] pte_addr;\n\n  logic [9:0] vpn0_d, vpn1_d, vpn0_q, vpn1_q;\n\n  riscv::pte_sv32_t [SHARED_TLB_WAYS-1:0] pte;\n\n  logic [riscv::VLEN-1-12:0] itlb_vpn_q;\n  logic [riscv::VLEN-1-12:0] dtlb_vpn_q;\n\n  logic [ASID_WIDTH-1:0] tlb_update_asid_q, tlb_update_asid_d;\n\n  logic shared_tlb_access_q, shared_tlb_access_d;\n  logic shared_tlb_hit_d;\n  logic [riscv::VLEN-1:0] shared_tlb_vaddr_q, shared_tlb_vaddr_d;\n\n  logic itlb_req_d, itlb_req_q;\n  logic dtlb_req_d, dtlb_req_q;\n\n  // replacement strategy\n  logic [SHARED_TLB_WAYS-1:0] way_valid;\n  logic update_lfsr;  // shift the LFSR\n  logic [$clog2(SHARED_TLB_WAYS)-1:0] inv_way;  // first non-valid encountered\n  logic [$clog2(SHARED_TLB_WAYS)-1:0] rnd_way;  // random index for replacement\n  logic [$clog2(SHARED_TLB_WAYS)-1:0] repl_way;  // way to replace\n  logic [SHARED_TLB_WAYS-1:0] repl_way_oh_d;  // way to replace (onehot)\n  logic all_ways_valid;  // we need to switch repl strategy since all are valid\n\n  assign shared_tlb_access_o = shared_tlb_access_q;\n  assign shared_tlb_hit_o = shared_tlb_hit_d;\n  assign shared_tlb_vaddr_o = shared_tlb_vaddr_q;\n\n  assign itlb_req_o = itlb_req_q;\n\n  ///////////////////////////////////////////////////////\n  // tag comparison, hit generation\n  ///////////////////////////////////////////////////////\n  always_comb begin : itlb_dtlb_miss\n    itlb_miss_o         = 1'b0;\n    dtlb_miss_o         = 1'b0;\n    vpn0_d              = vpn0_q;\n    vpn1_d              = vpn1_q;\n\n    tag_rd_en           = '0;\n    pte_rd_en           = '0;\n\n    itlb_req_d          = 1'b0;\n    dtlb_req_d          = 1'b0;\n\n    tlb_update_asid_d   = tlb_update_asid_q;\n\n    shared_tlb_access_d = '0;\n    shared_tlb_vaddr_d  = shared_tlb_vaddr_q;\n\n    tag_rd_addr         = '0;\n    pte_rd_addr         = '0;\n\n    // if we got an ITLB miss\n    if (enable_translation_i & itlb_access_i & ~itlb_hit_i & ~dtlb_access_i) begin\n      tag_rd_en           = '1;\n      tag_rd_addr         = itlb_vaddr_i[12+:$clog2(SHARED_TLB_DEPTH)];\n      pte_rd_en           = '1;\n      pte_rd_addr         = itlb_vaddr_i[12+:$clog2(SHARED_TLB_DEPTH)];\n\n      vpn0_d              = itlb_vaddr_i[21:12];\n      vpn1_d              = itlb_vaddr_i[31:22];\n\n      itlb_miss_o         = 1'b1;\n      itlb_req_d          = 1'b1;\n\n      tlb_update_asid_d   = asid_i;\n\n      shared_tlb_access_d = 1'b1;\n      shared_tlb_vaddr_d  = itlb_vaddr_i;\n\n      // we got an DTLB miss\n    end else if (en_ld_st_translation_i & dtlb_access_i & ~dtlb_hit_i) begin\n      tag_rd_en           = '1;\n      tag_rd_addr         = dtlb_vaddr_i[12+:$clog2(SHARED_TLB_DEPTH)];\n      pte_rd_en           = '1;\n      pte_rd_addr         = dtlb_vaddr_i[12+:$clog2(SHARED_TLB_DEPTH)];\n\n      vpn0_d              = dtlb_vaddr_i[21:12];\n      vpn1_d              = dtlb_vaddr_i[31:22];\n\n      dtlb_miss_o         = 1'b1;\n      dtlb_req_d          = 1'b1;\n\n      tlb_update_asid_d   = asid_i;\n\n      shared_tlb_access_d = 1'b1;\n      shared_tlb_vaddr_d  = dtlb_vaddr_i;\n    end\n  end  //itlb_dtlb_miss\n\n  always_comb begin : tag_comparison\n    shared_tlb_hit_d = 1'b0;\n    dtlb_update_o = '0;\n    itlb_update_o = '0;\n    //number of ways\n    for (int unsigned i = 0; i < SHARED_TLB_WAYS; i++) begin\n      if (shared_tag_valid[i] && ((tlb_update_asid_q == shared_tag_rd[i].asid) || pte[i].g)  && vpn1_q == shared_tag_rd[i].vpn1) begin\n        if (shared_tag_rd[i].is_4M || vpn0_q == shared_tag_rd[i].vpn0) begin\n          shared_tlb_hit_d = 1'b1;\n          if (itlb_req_q) begin\n            itlb_update_o.valid = 1'b1;\n            itlb_update_o.vpn = itlb_vpn_q;\n            itlb_update_o.is_4M = shared_tag_rd[i].is_4M;\n            itlb_update_o.asid = tlb_update_asid_q;\n            itlb_update_o.content = pte[i];\n          end else if (dtlb_req_q) begin\n            dtlb_update_o.valid = 1'b1;\n            dtlb_update_o.vpn = dtlb_vpn_q;\n            dtlb_update_o.is_4M = shared_tag_rd[i].is_4M;\n            dtlb_update_o.asid = tlb_update_asid_q;\n            dtlb_update_o.content = pte[i];\n          end\n        end\n      end\n    end\n  end  //tag_comparison\n\n  // sequential process\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      itlb_vpn_q <= '0;\n      dtlb_vpn_q <= '0;\n      tlb_update_asid_q <= '0;\n      shared_tlb_access_q <= '0;\n      shared_tlb_vaddr_q <= '0;\n      shared_tag_valid_q <= '0;\n      vpn0_q <= '0;\n      vpn1_q <= '0;\n      itlb_req_q <= '0;\n      dtlb_req_q <= '0;\n      shared_tag_valid <= '0;\n    end else begin\n      itlb_vpn_q <= itlb_vaddr_i[riscv::SV-1:12];\n      dtlb_vpn_q <= dtlb_vaddr_i[riscv::SV-1:12];\n      tlb_update_asid_q <= tlb_update_asid_d;\n      shared_tlb_access_q <= shared_tlb_access_d;\n      shared_tlb_vaddr_q <= shared_tlb_vaddr_d;\n      shared_tag_valid_q <= shared_tag_valid_d;\n      vpn0_q <= vpn0_d;\n      vpn1_q <= vpn1_d;\n      itlb_req_q <= itlb_req_d;\n      dtlb_req_q <= dtlb_req_d;\n      shared_tag_valid <= shared_tag_valid_q[tag_rd_addr];\n    end\n  end\n\n  // ------------------\n  // Update and Flush\n  // ------------------\n  always_comb begin : update_flush\n    shared_tag_valid_d = shared_tag_valid_q;\n    tag_wr_en = '0;\n    pte_wr_en = '0;\n\n    if (flush_i) begin\n      shared_tag_valid_d = '0;\n    end else if (shared_tlb_update_i.valid) begin\n      for (int unsigned i = 0; i < SHARED_TLB_WAYS; i++) begin\n        if (repl_way_oh_d[i]) begin\n          shared_tag_valid_d[shared_tlb_update_i.vpn[$clog2(SHARED_TLB_DEPTH)-1:0]][i] = 1'b1;\n          tag_wr_en[i] = 1'b1;\n          pte_wr_en[i] = 1'b1;\n        end\n      end\n    end\n  end  //update_flush\n\n  assign shared_tag_wr.asid = shared_tlb_update_i.asid;\n  assign shared_tag_wr.vpn1 = shared_tlb_update_i.vpn[19:10];\n  assign shared_tag_wr.vpn0 = shared_tlb_update_i.vpn[9:0];\n  assign shared_tag_wr.is_4M = shared_tlb_update_i.is_4M;\n\n  assign tag_wr_addr = shared_tlb_update_i.vpn[$clog2(SHARED_TLB_DEPTH)-1:0];\n  assign tag_wr_data = shared_tag_wr;\n\n  assign pte_wr_addr = shared_tlb_update_i.vpn[$clog2(SHARED_TLB_DEPTH)-1:0];\n  assign pte_wr_data = shared_tlb_update_i.content;\n\n  assign way_valid = shared_tag_valid_q[shared_tlb_update_i.vpn[$clog2(SHARED_TLB_DEPTH)-1:0]];\n  assign repl_way = (all_ways_valid) ? rnd_way : inv_way;\n  assign update_lfsr = shared_tlb_update_i.valid & all_ways_valid;\n  assign repl_way_oh_d = (shared_tlb_update_i.valid) ? shared_tlb_way_bin2oh(repl_way) : '0;\n\n  lzc #(\n      .WIDTH(SHARED_TLB_WAYS)\n  ) i_lzc (\n      .in_i   (~way_valid),\n      .cnt_o  (inv_way),\n      .empty_o(all_ways_valid)\n  );\n\n  lfsr #(\n      .LfsrWidth(8),\n      .OutWidth ($clog2(SHARED_TLB_WAYS))\n  ) i_lfsr (\n      .clk_i (clk_i),\n      .rst_ni(rst_ni),\n      .en_i  (update_lfsr),\n      .out_o (rnd_way)\n  );\n\n  ///////////////////////////////////////////////////////\n  // memory arrays and regs\n  ///////////////////////////////////////////////////////\n\n  assign tag_req  = tag_wr_en | tag_rd_en;\n  assign tag_we   = tag_wr_en;\n  assign tag_addr = tag_wr_en ? tag_wr_addr : tag_rd_addr;\n\n  assign pte_req  = pte_wr_en | pte_rd_en;\n  assign pte_we   = pte_wr_en;\n  assign pte_addr = pte_wr_en ? pte_wr_addr : pte_rd_addr;\n\n  for (genvar i = 0; i < SHARED_TLB_WAYS; i++) begin : gen_sram\n    // Tag RAM\n    sram #(\n        .DATA_WIDTH($bits(shared_tag_t)),\n        .NUM_WORDS (SHARED_TLB_DEPTH)\n    ) tag_sram (\n        .clk_i  (clk_i),\n        .rst_ni (rst_ni),\n        .req_i  (tag_req[i]),\n        .we_i   (tag_we[i]),\n        .addr_i (tag_addr),\n        .wuser_i('0),\n        .wdata_i(tag_wr_data),\n        .be_i   ('1),\n        .ruser_o(),\n        .rdata_o(tag_rd_data[i])\n    );\n\n    assign shared_tag_rd[i] = shared_tag_t'(tag_rd_data[i]);\n\n    // PTE RAM\n    sram #(\n        .DATA_WIDTH($bits(riscv::pte_sv32_t)),\n        .NUM_WORDS (SHARED_TLB_DEPTH)\n    ) pte_sram (\n        .clk_i  (clk_i),\n        .rst_ni (rst_ni),\n        .req_i  (pte_req[i]),\n        .we_i   (pte_we[i]),\n        .addr_i (pte_addr),\n        .wuser_i('0),\n        .wdata_i(pte_wr_data),\n        .be_i   ('1),\n        .ruser_o(),\n        .rdata_o(pte_rd_data[i])\n    );\n    assign pte[i] = riscv::pte_sv32_t'(pte_rd_data[i]);\n  end\nendmodule\n\n/* verilator lint_on WIDTH */\n"}
{"text": "// Copyright (c) 2021 Thales.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Sebastien Jacq Thales Research & Technology\n// Date: 17/07/2021\n//\n// Additional contributions by:\n//         Sebastien Jacq - sjthales on github.com\n//\n// Description: Translation Lookaside Buffer, Sv32 , fully set-associative\n//              This module is an adaptation of the Sv39 TLB developed\n//              by Florian Zaruba and David Schaffenrath to the Sv32 standard.\n//\n// =========================================================================== //\n// Revisions  :\n// Date        Version  Author       Description\n// 2020-02-17  0.1      S.Jacq       TLB Sv32 for CV32A6\n// =========================================================================== //\n\nmodule cva6_tlb_sv32\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int unsigned TLB_ENTRIES = 4,\n    parameter int unsigned ASID_WIDTH = 1\n) (\n    input logic clk_i,  // Clock\n    input logic rst_ni,  // Asynchronous reset active low\n    input logic flush_i,  // Flush signal\n    // Update TLB\n    input tlb_update_sv32_t update_i,\n    // Lookup signals\n    input logic lu_access_i,\n    input logic [ASID_WIDTH-1:0] lu_asid_i,\n    input logic [riscv::VLEN-1:0] lu_vaddr_i,\n    output riscv::pte_sv32_t lu_content_o,\n    input logic [ASID_WIDTH-1:0] asid_to_be_flushed_i,\n    input logic [riscv::VLEN-1:0] vaddr_to_be_flushed_i,\n    output logic lu_is_4M_o,\n    output logic lu_hit_o\n);\n\n  // Sv32 defines two levels of page tables\n  struct packed {\n    logic [8:0] asid;   //9 bits wide\n    logic [9:0] vpn1;   //10 bits wide\n    logic [9:0] vpn0;   //10 bits wide\n    logic       is_4M;\n    logic       valid;\n  } [TLB_ENTRIES-1:0]\n      tags_q, tags_n;\n\n  riscv::pte_sv32_t [TLB_ENTRIES-1:0] content_q, content_n;\n  logic [9:0] vpn0, vpn1;\n  logic [TLB_ENTRIES-1:0] lu_hit;  // to replacement logic\n  logic [TLB_ENTRIES-1:0] replace_en;  // replace the following entry, set by replacement strategy\n  //-------------\n  // Translation\n  //-------------\n  always_comb begin : translation\n    vpn0         = lu_vaddr_i[21:12];\n    vpn1         = lu_vaddr_i[31:22];\n\n\n    // default assignment\n    lu_hit       = '{default: 0};\n    lu_hit_o     = 1'b0;\n    lu_content_o = '{default: 0};\n    lu_is_4M_o   = 1'b0;\n\n    for (int unsigned i = 0; i < TLB_ENTRIES; i++) begin\n      // first level match, this may be a mega page, check the ASID flags as well\n      // if the entry is associated to a global address, don't match the ASID (ASID is don't care)\n      if (tags_q[i].valid && ((lu_asid_i == tags_q[i].asid[ASID_WIDTH-1:0]) || content_q[i].g)  && vpn1 == tags_q[i].vpn1) begin\n        if (tags_q[i].is_4M || vpn0 == tags_q[i].vpn0) begin\n          lu_is_4M_o   = tags_q[i].is_4M;\n          lu_content_o = content_q[i];\n          lu_hit_o     = 1'b1;\n          lu_hit[i]    = 1'b1;\n        end\n      end\n    end\n  end\n\n  logic asid_to_be_flushed_is0;  // indicates that the ASID provided by SFENCE.VMA (rs2)is 0, active high\n  logic vaddr_to_be_flushed_is0;  // indicates that the VADDR provided by SFENCE.VMA (rs1)is 0, active high\n  logic [TLB_ENTRIES-1:0] vaddr_vpn0_match;\n  logic [TLB_ENTRIES-1:0] vaddr_vpn1_match;\n\n\n  assign asid_to_be_flushed_is0  = ~(|asid_to_be_flushed_i);\n  assign vaddr_to_be_flushed_is0 = ~(|vaddr_to_be_flushed_i);\n\n  // ------------------\n  // Update and Flush\n  // ------------------\n  always_comb begin : update_flush\n    tags_n    = tags_q;\n    content_n = content_q;\n\n    for (int unsigned i = 0; i < TLB_ENTRIES; i++) begin\n\n      vaddr_vpn0_match[i] = (vaddr_to_be_flushed_i[21:12] == tags_q[i].vpn0);\n      vaddr_vpn1_match[i] = (vaddr_to_be_flushed_i[31:22] == tags_q[i].vpn1);\n\n      if (flush_i) begin\n        // invalidate logic\n        // flush everything if ASID is 0 and vaddr is 0 (\"SFENCE.VMA x0 x0\" case)\n        if (asid_to_be_flushed_is0 && vaddr_to_be_flushed_is0) tags_n[i].valid = 1'b0;\n        // flush vaddr in all addressing space (\"SFENCE.VMA vaddr x0\" case), it should happen only for leaf pages\n        else if (asid_to_be_flushed_is0 && ( (vaddr_vpn0_match[i] && vaddr_vpn1_match[i]) || (vaddr_vpn1_match[i] && tags_q[i].is_4M) ) && (~vaddr_to_be_flushed_is0))\n          tags_n[i].valid = 1'b0;\n        // the entry is flushed if it's not global and asid and vaddr both matches with the entry to be flushed (\"SFENCE.VMA vaddr asid\" case)\n        else if ((!content_q[i].g) && ((vaddr_vpn0_match[i] && vaddr_vpn1_match[i]) || (vaddr_vpn1_match[i] && tags_q[i].is_4M)) && (asid_to_be_flushed_i == tags_q[i].asid[ASID_WIDTH-1:0]) && (!vaddr_to_be_flushed_is0) && (!asid_to_be_flushed_is0))\n          tags_n[i].valid = 1'b0;\n        // the entry is flushed if it's not global, and the asid matches and vaddr is 0. (\"SFENCE.VMA 0 asid\" case)\n        else if ((!content_q[i].g) && (vaddr_to_be_flushed_is0) && (asid_to_be_flushed_i == tags_q[i].asid[ASID_WIDTH-1:0]) && (!asid_to_be_flushed_is0))\n          tags_n[i].valid = 1'b0;\n        // normal replacement\n      end else if (update_i.valid & replace_en[i]) begin\n        // update tag array\n        tags_n[i] = '{\n            asid: update_i.asid,\n            vpn1: update_i.vpn[19:10],\n            vpn0: update_i.vpn[9:0],\n            is_4M: update_i.is_4M,\n            valid: 1'b1\n        };\n        // and content as well\n        content_n[i] = update_i.content;\n      end\n    end\n  end\n\n  // -----------------------------------------------\n  // PLRU - Pseudo Least Recently Used Replacement\n  // -----------------------------------------------\n  logic [2*(TLB_ENTRIES-1)-1:0] plru_tree_q, plru_tree_n;\n  logic en;\n  int unsigned idx_base, shift, new_index;\n  always_comb begin : plru_replacement\n    plru_tree_n = plru_tree_q;\n    en = '0;\n    idx_base = '0;\n    shift = '0;\n    new_index = '0;\n    // The PLRU-tree indexing:\n    // lvl0        0\n    //            / \\\n        //           /   \\\n        // lvl1     1     2\n        //         / \\   / \\\n        // lvl2   3   4 5   6\n        //       / \\ /\\/\\  /\\\n        //      ... ... ... ...\n        // Just predefine which nodes will be set/cleared\n        // E.g. for a TLB with 8 entries, the for-loop is semantically\n        // equivalent to the following pseudo-code:\n        // unique case (1'b1)\n        // lu_hit[7]: plru_tree_n[0, 2, 6] = {1, 1, 1};\n        // lu_hit[6]: plru_tree_n[0, 2, 6] = {1, 1, 0};\n        // lu_hit[5]: plru_tree_n[0, 2, 5] = {1, 0, 1};\n        // lu_hit[4]: plru_tree_n[0, 2, 5] = {1, 0, 0};\n        // lu_hit[3]: plru_tree_n[0, 1, 4] = {0, 1, 1};\n        // lu_hit[2]: plru_tree_n[0, 1, 4] = {0, 1, 0};\n        // lu_hit[1]: plru_tree_n[0, 1, 3] = {0, 0, 1};\n        // lu_hit[0]: plru_tree_n[0, 1, 3] = {0, 0, 0};\n        // default: begin /* No hit */ end\n        // endcase\n        for (\n        int unsigned i = 0; i < TLB_ENTRIES; i++\n    ) begin\n      // we got a hit so update the pointer as it was least recently used\n      if (lu_hit[i] & lu_access_i) begin\n        // Set the nodes to the values we would expect\n        for (int unsigned lvl = 0; lvl < $clog2(TLB_ENTRIES); lvl++) begin\n          idx_base = $unsigned((2 ** lvl) - 1);\n          // lvl0 <=> MSB, lvl1 <=> MSB-1, ...\n          shift = $clog2(TLB_ENTRIES) - lvl;\n          // to circumvent the 32 bit integer arithmetic assignment\n          new_index = ~((i >> (shift - 1)) & 32'b1);\n          plru_tree_n[idx_base+(i>>shift)] = new_index[0];\n        end\n      end\n    end\n    // Decode tree to write enable signals\n    // Next for-loop basically creates the following logic for e.g. an 8 entry\n    // TLB (note: pseudo-code obviously):\n    // replace_en[7] = &plru_tree_q[ 6, 2, 0]; //plru_tree_q[0,2,6]=={1,1,1}\n    // replace_en[6] = &plru_tree_q[~6, 2, 0]; //plru_tree_q[0,2,6]=={1,1,0}\n    // replace_en[5] = &plru_tree_q[ 5,~2, 0]; //plru_tree_q[0,2,5]=={1,0,1}\n    // replace_en[4] = &plru_tree_q[~5,~2, 0]; //plru_tree_q[0,2,5]=={1,0,0}\n    // replace_en[3] = &plru_tree_q[ 4, 1,~0]; //plru_tree_q[0,1,4]=={0,1,1}\n    // replace_en[2] = &plru_tree_q[~4, 1,~0]; //plru_tree_q[0,1,4]=={0,1,0}\n    // replace_en[1] = &plru_tree_q[ 3,~1,~0]; //plru_tree_q[0,1,3]=={0,0,1}\n    // replace_en[0] = &plru_tree_q[~3,~1,~0]; //plru_tree_q[0,1,3]=={0,0,0}\n    // For each entry traverse the tree. If every tree-node matches,\n    // the corresponding bit of the entry's index, this is\n    // the next entry to replace.\n    for (int unsigned i = 0; i < TLB_ENTRIES; i += 1) begin\n      en = 1'b1;\n      for (int unsigned lvl = 0; lvl < $clog2(TLB_ENTRIES); lvl++) begin\n        idx_base = $unsigned((2 ** lvl) - 1);\n        // lvl0 <=> MSB, lvl1 <=> MSB-1, ...\n        shift = $clog2(TLB_ENTRIES) - lvl;\n\n        // en &= plru_tree_q[idx_base + (i>>shift)] == ((i >> (shift-1)) & 1'b1);\n        new_index = (i >> (shift - 1)) & 32'b1;\n        if (new_index[0]) begin\n          en &= plru_tree_q[idx_base+(i>>shift)];\n        end else begin\n          en &= ~plru_tree_q[idx_base+(i>>shift)];\n        end\n      end\n      replace_en[i] = en;\n    end\n  end\n\n  // sequential process\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      tags_q      <= '{default: 0};\n      content_q   <= '{default: 0};\n      plru_tree_q <= '{default: 0};\n    end else begin\n      tags_q      <= tags_n;\n      content_q   <= content_n;\n      plru_tree_q <= plru_tree_n;\n    end\n  end\n  //--------------\n  // Sanity checks\n  //--------------\n\n  //pragma translate_off\n`ifndef VERILATOR\n\n  initial begin : p_assertions\n    assert ((TLB_ENTRIES % 2 == 0) && (TLB_ENTRIES > 1))\n    else begin\n      $error(\"TLB size must be a multiple of 2 and greater than 1\");\n      $stop();\n    end\n    assert (ASID_WIDTH >= 1)\n    else begin\n      $error(\"ASID width must be at least 1\");\n      $stop();\n    end\n  end\n\n  // Just for checking\n  function int countSetBits(logic [TLB_ENTRIES-1:0] vector);\n    automatic int count = 0;\n    foreach (vector[idx]) begin\n      count += vector[idx];\n    end\n    return count;\n  endfunction\n\n  assert property (@(posedge clk_i) (countSetBits(lu_hit) <= 1))\n  else begin\n    $error(\"More then one hit in TLB!\");\n    $stop();\n  end\n  assert property (@(posedge clk_i) (countSetBits(replace_en) <= 1))\n  else begin\n    $error(\"More then one TLB entry selected for next replace!\");\n    $stop();\n  end\n\n`endif\n  //pragma translate_on\n\nendmodule\n"}
{"text": "// Copyright 2021 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Guillaume CHAUVON (guillaume.chauvon@thalesgroup.com)\n\n// Functional Unit for the logic of the CoreV-X-Interface\n\n\nmodule cvxif_fu\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input  logic                                       clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input  logic                                       rst_ni,\n    // FU data needed to execute instruction - ISSUE_STAGE\n    input  fu_data_t                                   fu_data_i,\n    // Current privilege mode - CSR_REGFILE\n    input  riscv::priv_lvl_t                           priv_lvl_i,\n    // CVXIF instruction is valid - ISSUE_STAGE\n    input  logic                                       x_valid_i,\n    // CVXIF is ready - ISSUE_STAGE\n    output logic                                       x_ready_o,\n    // Offloaded instruction - ISSUE_STAGE\n    input  logic                   [             31:0] x_off_instr_i,\n    // CVXIF transaction ID - ISSUE_STAGE\n    output logic                   [TRANS_ID_BITS-1:0] x_trans_id_o,\n    // CVXIF exception - ISSUE_STAGE\n    output exception_t                                 x_exception_o,\n    // CVXIF FU result - ISSUE_STAGE\n    output riscv::xlen_t                               x_result_o,\n    // CVXIF result valid - ISSUE_STAGE\n    output logic                                       x_valid_o,\n    // CVXIF write enable - ISSUE_STAGE\n    output logic                                       x_we_o,\n    // CVXIF request - SUBSYSTEM\n    output cvxif_pkg::cvxif_req_t                      cvxif_req_o,\n    // CVXIF response - SUBSYSTEM\n    input  cvxif_pkg::cvxif_resp_t                     cvxif_resp_i\n);\n  localparam X_NUM_RS = ariane_pkg::NR_RGPR_PORTS;\n\n  logic illegal_n, illegal_q;\n  logic [TRANS_ID_BITS-1:0] illegal_id_n, illegal_id_q;\n  logic [31:0] illegal_instr_n, illegal_instr_q;\n  logic [X_NUM_RS-1:0] rs_valid;\n\n  if (cvxif_pkg::X_NUM_RS == 3) begin : gen_third_operand\n    assign rs_valid = 3'b111;\n  end else begin : gen_no_third_operand\n    assign rs_valid = 2'b11;\n  end\n\n  always_comb begin\n    cvxif_req_o = '0;\n    cvxif_req_o.x_result_ready = 1'b1;\n    x_ready_o = cvxif_resp_i.x_issue_ready;\n    if (x_valid_i) begin\n      cvxif_req_o.x_issue_valid     = x_valid_i;\n      cvxif_req_o.x_issue_req.instr = x_off_instr_i;\n      cvxif_req_o.x_issue_req.mode  = priv_lvl_i;\n      cvxif_req_o.x_issue_req.id    = fu_data_i.trans_id;\n      cvxif_req_o.x_issue_req.rs[0] = fu_data_i.operand_a;\n      cvxif_req_o.x_issue_req.rs[1] = fu_data_i.operand_b;\n      if (cvxif_pkg::X_NUM_RS == 3) begin\n        cvxif_req_o.x_issue_req.rs[2] = fu_data_i.imm;\n      end\n      cvxif_req_o.x_issue_req.rs_valid   = rs_valid;\n      cvxif_req_o.x_commit_valid         = x_valid_i;\n      cvxif_req_o.x_commit.id            = fu_data_i.trans_id;\n      cvxif_req_o.x_commit.x_commit_kill = 1'b0;\n    end\n  end\n\n  always_comb begin\n    illegal_n       = illegal_q;\n    illegal_id_n    = illegal_id_q;\n    illegal_instr_n = illegal_instr_q;\n    if (~cvxif_resp_i.x_issue_resp.accept && cvxif_req_o.x_issue_valid && cvxif_resp_i.x_issue_ready && ~illegal_n) begin\n      illegal_n       = 1'b1;\n      illegal_id_n    = cvxif_req_o.x_issue_req.id;\n      illegal_instr_n = cvxif_req_o.x_issue_req.instr;\n    end\n    x_valid_o = cvxif_resp_i.x_result_valid;  //Read result only when CVXIF is enabled\n    x_trans_id_o = x_valid_o ? cvxif_resp_i.x_result.id : '0;\n    x_result_o = x_valid_o ? cvxif_resp_i.x_result.data : '0;\n    x_exception_o.cause   = x_valid_o ? {{(riscv::XLEN-6){1'b0}}, cvxif_resp_i.x_result.exccode} : '0;\n    x_exception_o.valid = x_valid_o ? cvxif_resp_i.x_result.exc : '0;\n    x_exception_o.tval = '0;\n    x_we_o = x_valid_o ? cvxif_resp_i.x_result.we : '0;\n    if (illegal_n) begin\n      if (~x_valid_o) begin\n        x_trans_id_o = illegal_id_n;\n        x_result_o = '0;\n        x_valid_o = 1'b1;\n        x_exception_o.cause = riscv::ILLEGAL_INSTR;\n        x_exception_o.valid = 1'b1;\n        if (CVA6Cfg.TvalEn) x_exception_o.tval = illegal_instr_n;\n        x_we_o = '0;\n        illegal_n             = '0; // Reset flag for illegal instr. illegal_id and illegal instr values are a don't care, no need to reset it.\n      end\n    end\n  end\n\n  always_ff @(posedge clk_i, negedge rst_ni) begin\n    if (~rst_ni) begin\n      illegal_q       <= 1'b0;\n      illegal_id_q    <= '0;\n      illegal_instr_q <= '0;\n    end else begin\n      illegal_q       <= illegal_n;\n      illegal_id_q    <= illegal_id_n;\n      illegal_instr_q <= illegal_instr_n;\n    end\n  end\n\nendmodule\n"}
{"text": "// Copyright 2021 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Guillaume CHAUVON (guillaume.chauvon@thalesgroup.com)\n\n// Package for the CoreV-X-Interface for the CVA6\n\npackage cvxif_pkg;\n\n  localparam X_DATAWIDTH = riscv::XLEN;\n  localparam X_NUM_RS = ariane_pkg::NR_RGPR_PORTS;  //2 or 3\n  localparam X_ID_WIDTH = ariane_pkg::TRANS_ID_BITS;\n  localparam X_MEM_WIDTH = 64;\n  localparam X_RFR_WIDTH = riscv::XLEN;\n  localparam X_RFW_WIDTH = riscv::XLEN;\n\n  typedef struct packed {\n    logic [15:0]           instr;\n    logic [1:0]            mode;\n    logic [X_ID_WIDTH-1:0] id;\n  } x_compressed_req_t;\n\n  typedef struct packed {\n    logic [31:0] instr;\n    logic        accept;\n  } x_compressed_resp_t;\n\n  typedef struct packed {\n    logic [31:0]                          instr;\n    logic [1:0]                           mode;\n    logic [X_ID_WIDTH-1:0]                id;\n    logic [X_NUM_RS-1:0][X_RFR_WIDTH-1:0] rs;\n    logic [X_NUM_RS-1:0]                  rs_valid;\n  } x_issue_req_t;\n\n  typedef struct packed {\n    logic accept;\n    logic writeback;\n    logic dualwrite;\n    logic dualread;\n    logic loadstore;\n    logic exc;\n  } x_issue_resp_t;\n\n  typedef struct packed {\n    logic [X_ID_WIDTH-1:0] id;\n    logic                  x_commit_kill;\n  } x_commit_t;\n\n  typedef struct packed {\n    logic [X_ID_WIDTH-1:0]  id;\n    logic [31:0]            addr;\n    logic [1:0]             mode;\n    logic                   we;\n    logic [1:0]             size;\n    logic [X_MEM_WIDTH-1:0] wdata;\n    logic                   last;\n    logic                   spec;\n  } x_mem_req_t;\n\n  typedef struct packed {\n    logic       exc;\n    logic [5:0] exccode;\n  } x_mem_resp_t;\n\n  typedef struct packed {\n    logic [X_ID_WIDTH-1:0]  id;\n    logic [X_MEM_WIDTH-1:0] rdata;\n    logic                   err;\n  } x_mem_result_t;\n\n  typedef struct packed {\n    logic [X_ID_WIDTH-1:0]  id;\n    logic [X_RFW_WIDTH-1:0] data;\n    logic [4:0]             rd;\n    logic                   we;\n    logic                   exc;\n    logic [5:0]             exccode;\n  } x_result_t;\n\n  typedef struct packed {\n    logic              x_compressed_valid;\n    x_compressed_req_t x_compressed_req;\n    logic              x_issue_valid;\n    x_issue_req_t      x_issue_req;\n    logic              x_commit_valid;\n    x_commit_t         x_commit;\n    logic              x_mem_ready;\n    x_mem_resp_t       x_mem_resp;\n    logic              x_mem_result_valid;\n    x_mem_result_t     x_mem_result;\n    logic              x_result_ready;\n  } cvxif_req_t;\n\n  typedef struct packed {\n    logic               x_compressed_ready;\n    x_compressed_resp_t x_compressed_resp;\n    logic               x_issue_ready;\n    x_issue_resp_t      x_issue_resp;\n    logic               x_mem_valid;\n    x_mem_req_t         x_mem_req;\n    logic               x_result_valid;\n    x_result_t          x_result;\n  } cvxif_resp_t;\n\nendpackage\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// File:   issue_read_operands.sv\n// Author: Florian Zaruba <zarubaf@ethz.ch>\n// Date:   8.4.2017\n//\n// Copyright (C) 2017 ETH Zurich, University of Bologna\n// All rights reserved.\n//\n// Description: Issues instruction from the scoreboard and fetches the operands\n//              This also includes all the forwarding logic\n//\n\nmodule decoder\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Debug (async) request - SUBSYSTEM\n    input logic debug_req_i,\n    // PC from fetch stage - FRONTEND\n    input logic [riscv::VLEN-1:0] pc_i,\n    // Is a compressed instruction - compressed_decoder\n    input logic is_compressed_i,\n    // Compressed form of instruction - FRONTEND\n    input logic [15:0] compressed_instr_i,\n    // Illegal compressed instruction - compressed_decoder\n    input logic is_illegal_i,\n    // Instruction from fetch stage - FRONTEND\n    input logic [31:0] instruction_i,\n    // Is a branch predict instruction - FRONTEND\n    input branchpredict_sbe_t branch_predict_i,\n    // If an exception occured in fetch stage - FRONTEND\n    input exception_t ex_i,\n    // Level sensitive (async) interrupts - SUBSYSTEM\n    input logic [1:0] irq_i,\n    // Interrupt control status - CSR_REGFILE\n    input irq_ctrl_t irq_ctrl_i,\n    // Current privilege level - CSR_REGFILE\n    input riscv::priv_lvl_t priv_lvl_i,\n    // Is debug mode - CSR_REGFILE\n    input logic debug_mode_i,\n    // Floating point extension status - CSR_REGFILE\n    input riscv::xs_t fs_i,\n    // Floating-point dynamic rounding mode - CSR_REGFILE\n    input logic [2:0] frm_i,\n    // Vector extension status - CSR_REGFILE\n    input riscv::xs_t vs_i,\n    // Trap virtual memory - CSR_REGFILE\n    input logic tvm_i,\n    // Timeout wait - CSR_REGFILE\n    input logic tw_i,\n    // Trap sret - CSR_REGFILE\n    input logic tsr_i,\n    // Instruction to be added to scoreboard entry - ISSUE_STAGE\n    output scoreboard_entry_t instruction_o,\n    // Instruction - ISSUE_STAGE\n    output logic [31:0] orig_instr_o,\n    // Is a control flow instruction - ISSUE_STAGE\n    output logic is_control_flow_instr_o\n);\n  logic illegal_instr;\n  logic illegal_instr_bm;\n  logic illegal_instr_zic;\n  logic illegal_instr_non_bm;\n  // this instruction is an environment call (ecall), it is handled like an exception\n  logic ecall;\n  // this instruction is a software break-point\n  logic ebreak;\n  // this instruction needs floating-point rounding-mode verification\n  logic check_fprm;\n  riscv::instruction_t instr;\n  assign instr = riscv::instruction_t'(instruction_i);\n  // --------------------\n  // Immediate select\n  // --------------------\n  enum logic         [3:0] {NOIMM, IIMM, SIMM, SBIMM, UIMM, JIMM, RS3} imm_select;\n\n  riscv::xlen_t                                                        imm_i_type;\n  riscv::xlen_t                                                        imm_s_type;\n  riscv::xlen_t                                                        imm_sb_type;\n  riscv::xlen_t                                                        imm_u_type;\n  riscv::xlen_t                                                        imm_uj_type;\n  riscv::xlen_t                                                        imm_bi_type;\n\n  // ---------------------------------------\n  // Accelerator instructions' first-pass decoder\n  // ---------------------------------------\n  logic                                                                is_accel;\n  scoreboard_entry_t                                                   acc_instruction;\n  logic                                                                acc_illegal_instr;\n  logic                                                                acc_is_control_flow_instr;\n\n  if (CVA6Cfg.EnableAccelerator) begin : gen_accel_decoder\n    // This module is responsible for a light-weight decoding of accelerator instructions,\n    // identifying them, but also whether they read/write scalar registers.\n    // Accelerators are supposed to define this module.\n    cva6_accel_first_pass_decoder i_accel_decoder (\n        .instruction_i(instruction_i),\n        .fs_i(fs_i),\n        .vs_i(vs_i),\n        .is_accel_o(is_accel),\n        .instruction_o(acc_instruction),\n        .illegal_instr_o(acc_illegal_instr),\n        .is_control_flow_instr_o(acc_is_control_flow_instr)\n    );\n  end : gen_accel_decoder\n  else begin\n    assign is_accel                  = 1'b0;\n    assign acc_instruction           = '0;\n    assign acc_illegal_instr         = 1'b1;  // this should never propagate\n    assign acc_is_control_flow_instr = 1'b0;\n  end\n\n  always_comb begin : decoder\n\n    imm_select                  = NOIMM;\n    is_control_flow_instr_o     = 1'b0;\n    illegal_instr               = 1'b0;\n    illegal_instr_non_bm        = 1'b0;\n    illegal_instr_bm            = 1'b0;\n    illegal_instr_zic           = 1'b0;\n    instruction_o.pc            = pc_i;\n    instruction_o.trans_id      = '0;\n    instruction_o.fu            = NONE;\n    instruction_o.op            = ariane_pkg::ADD;\n    instruction_o.rs1           = '0;\n    instruction_o.rs2           = '0;\n    instruction_o.rd            = '0;\n    instruction_o.use_pc        = 1'b0;\n    instruction_o.is_compressed = is_compressed_i;\n    instruction_o.use_zimm      = 1'b0;\n    instruction_o.bp            = branch_predict_i;\n    instruction_o.vfp           = 1'b0;\n    ecall                       = 1'b0;\n    ebreak                      = 1'b0;\n    check_fprm                  = 1'b0;\n\n    if (~ex_i.valid) begin\n      case (instr.rtype.opcode)\n        riscv::OpcodeSystem: begin\n          instruction_o.fu = CSR;\n          instruction_o.rs1[4:0] = instr.itype.rs1;\n          instruction_o.rs2[4:0] = instr.rtype.rs2;   //TODO: needs to be checked if better way is available\n          instruction_o.rd[4:0] = instr.itype.rd;\n\n          unique case (instr.itype.funct3)\n            3'b000: begin\n              // check if the RD and and RS1 fields are zero, this may be reset for the SENCE.VMA instruction\n              if (instr.itype.rs1 != '0 || instr.itype.rd != '0) illegal_instr = 1'b1;\n              // decode the immiediate field\n              case (instr.itype.imm)\n                // ECALL -> inject exception\n                12'b0: ecall = 1'b1;\n                // EBREAK -> inject exception\n                12'b1: ebreak = 1'b1;\n                // SRET\n                12'b1_0000_0010: begin\n                  if (CVA6Cfg.RVS) begin\n                    instruction_o.op = ariane_pkg::SRET;\n                    // check privilege level, SRET can only be executed in S and M mode\n                    // we'll just decode an illegal instruction if we are in the wrong privilege level\n                    if (CVA6Cfg.RVU && priv_lvl_i == riscv::PRIV_LVL_U) begin\n                      illegal_instr = 1'b1;\n                      //  do not change privilege level if this is an illegal instruction\n                      instruction_o.op = ariane_pkg::ADD;\n                    end\n                    // if we are in S-Mode and Trap SRET (tsr) is set -> trap on illegal instruction\n                    if (priv_lvl_i == riscv::PRIV_LVL_S && tsr_i) begin\n                      illegal_instr = 1'b1;\n                      //  do not change privilege level if this is an illegal instruction\n                      instruction_o.op = ariane_pkg::ADD;\n                    end\n                  end else begin\n                    illegal_instr = 1'b1;\n                    instruction_o.op = ariane_pkg::ADD;\n                  end\n                end\n                // MRET\n                12'b11_0000_0010: begin\n                  instruction_o.op = ariane_pkg::MRET;\n                  // check privilege level, MRET can only be executed in M mode\n                  // otherwise we decode an illegal instruction\n                  if ((CVA6Cfg.RVS && priv_lvl_i == riscv::PRIV_LVL_S) || (CVA6Cfg.RVU && priv_lvl_i == riscv::PRIV_LVL_U))\n                    illegal_instr = 1'b1;\n                end\n                // DRET\n                12'b111_1011_0010: begin\n                  instruction_o.op = ariane_pkg::DRET;\n                  if (CVA6Cfg.DebugEn) begin\n                    // check that we are in debug mode when executing this instruction\n                    illegal_instr = (!debug_mode_i) ? 1'b1 : illegal_instr;\n                  end else begin\n                    illegal_instr = 1'b1;\n                  end\n                end\n                // WFI\n                12'b1_0000_0101: begin\n                  instruction_o.op = ariane_pkg::WFI;\n                  // if timeout wait is set, trap on an illegal instruction in S Mode\n                  // (after 0 cycles timeout)\n                  if (CVA6Cfg.RVS && priv_lvl_i == riscv::PRIV_LVL_S && tw_i) begin\n                    illegal_instr = 1'b1;\n                    instruction_o.op = ariane_pkg::ADD;\n                  end\n                  // we don't support U mode interrupts so WFI is illegal in this context\n                  if (CVA6Cfg.RVU && priv_lvl_i == riscv::PRIV_LVL_U) begin\n                    illegal_instr = 1'b1;\n                    instruction_o.op = ariane_pkg::ADD;\n                  end\n                end\n                // SFENCE.VMA\n                default: begin\n                  if (instr.instr[31:25] == 7'b1001) begin\n                    // check privilege level, SFENCE.VMA can only be executed in M/S mode\n                    // only if S mode is supported\n                    // otherwise decode an illegal instruction\n                    illegal_instr    = (CVA6Cfg.RVS && (priv_lvl_i inside {riscv::PRIV_LVL_M, riscv::PRIV_LVL_S}) && instr.itype.rd == '0) ? 1'b0 : 1'b1;\n                    instruction_o.op = ariane_pkg::SFENCE_VMA;\n                    // check TVM flag and intercept SFENCE.VMA call if necessary\n                    if (CVA6Cfg.RVS && priv_lvl_i == riscv::PRIV_LVL_S && tvm_i)\n                      illegal_instr = 1'b1;\n                  end else begin\n                    illegal_instr = 1'b1;\n                  end\n                end\n              endcase\n            end\n            // atomically swaps values in the CSR and integer register\n            3'b001: begin  // CSRRW\n              imm_select = IIMM;\n              instruction_o.op = ariane_pkg::CSR_WRITE;\n            end\n            // atomically set values in the CSR and write back to rd\n            3'b010: begin  // CSRRS\n              imm_select = IIMM;\n              // this is just a read\n              if (instr.itype.rs1 == 5'b0) instruction_o.op = ariane_pkg::CSR_READ;\n              else instruction_o.op = ariane_pkg::CSR_SET;\n            end\n            // atomically clear values in the CSR and write back to rd\n            3'b011: begin  // CSRRC\n              imm_select = IIMM;\n              // this is just a read\n              if (instr.itype.rs1 == 5'b0) instruction_o.op = ariane_pkg::CSR_READ;\n              else instruction_o.op = ariane_pkg::CSR_CLEAR;\n            end\n            // use zimm and iimm\n            3'b101: begin  // CSRRWI\n              instruction_o.rs1[4:0] = instr.itype.rs1;\n              imm_select = IIMM;\n              instruction_o.use_zimm = 1'b1;\n              instruction_o.op = ariane_pkg::CSR_WRITE;\n            end\n            3'b110: begin  // CSRRSI\n              instruction_o.rs1[4:0] = instr.itype.rs1;\n              imm_select = IIMM;\n              instruction_o.use_zimm = 1'b1;\n              // this is just a read\n              if (instr.itype.rs1 == 5'b0) instruction_o.op = ariane_pkg::CSR_READ;\n              else instruction_o.op = ariane_pkg::CSR_SET;\n            end\n            3'b111: begin  // CSRRCI\n              instruction_o.rs1[4:0] = instr.itype.rs1;\n              imm_select = IIMM;\n              instruction_o.use_zimm = 1'b1;\n              // this is just a read\n              if (instr.itype.rs1 == 5'b0) instruction_o.op = ariane_pkg::CSR_READ;\n              else instruction_o.op = ariane_pkg::CSR_CLEAR;\n            end\n            default: illegal_instr = 1'b1;\n          endcase\n        end\n        // Memory ordering instructions\n        riscv::OpcodeMiscMem: begin\n          instruction_o.fu  = CSR;\n          instruction_o.rs1 = '0;\n          instruction_o.rs2 = '0;\n          instruction_o.rd  = '0;\n\n          case (instr.stype.funct3)\n            // FENCE\n            // Currently implemented as a whole DCache flush boldly ignoring other things\n            3'b000: instruction_o.op = ariane_pkg::FENCE;\n            // FENCE.I\n            3'b001: instruction_o.op = ariane_pkg::FENCE_I;\n\n            default: illegal_instr = 1'b1;\n          endcase\n        end\n\n        // --------------------------\n        // Reg-Reg Operations\n        // --------------------------\n        riscv::OpcodeOp: begin\n          // --------------------------------------------\n          // Vectorial Floating-Point Reg-Reg Operations\n          // --------------------------------------------\n          if (instr.rvftype.funct2 == 2'b10) begin  // Prefix 10 for all Xfvec ops\n            // only generate decoder if FP extensions are enabled (static)\n            if (CVA6Cfg.FpPresent && CVA6Cfg.XFVec && fs_i != riscv::Off) begin\n              automatic logic allow_replication;  // control honoring of replication flag\n\n              instruction_o.fu       = FPU_VEC;  // Same unit, but sets 'vectorial' signal\n              instruction_o.rs1[4:0] = instr.rvftype.rs1;\n              instruction_o.rs2[4:0] = instr.rvftype.rs2;\n              instruction_o.rd[4:0]  = instr.rvftype.rd;\n              check_fprm             = 1'b1;\n              allow_replication      = 1'b1;\n              // decode vectorial FP instruction\n              unique case (instr.rvftype.vecfltop)\n                5'b00001: begin\n                  instruction_o.op       = ariane_pkg::FADD;  // vfadd.vfmt - Vectorial FP Addition\n                  instruction_o.rs1      = '0;  // Operand A is set to 0\n                  instruction_o.rs2[4:0] = instr.rvftype.rs1;  // Operand B is set to rs1\n                  imm_select             = IIMM;  // Operand C is set to rs2\n                end\n                5'b00010: begin\n                  instruction_o.op = ariane_pkg::FSUB;  // vfsub.vfmt - Vectorial FP Subtraction\n                  instruction_o.rs1 = '0;  // Operand A is set to 0\n                  instruction_o.rs2[4:0] = instr.rvftype.rs1;  // Operand B is set to rs1\n                  imm_select = IIMM;  // Operand C is set to rs2\n                end\n                5'b00011:\n                instruction_o.op = ariane_pkg::FMUL;  // vfmul.vfmt - Vectorial FP Multiplication\n                5'b00100:\n                instruction_o.op = ariane_pkg::FDIV;  // vfdiv.vfmt - Vectorial FP Division\n                5'b00101: begin\n                  instruction_o.op = ariane_pkg::VFMIN;  // vfmin.vfmt - Vectorial FP Minimum\n                  check_fprm       = 1'b0;  // rounding mode irrelevant\n                end\n                5'b00110: begin\n                  instruction_o.op = ariane_pkg::VFMAX;  // vfmax.vfmt - Vectorial FP Maximum\n                  check_fprm       = 1'b0;  // rounding mode irrelevant\n                end\n                5'b00111: begin\n                  instruction_o.op  = ariane_pkg::FSQRT;  // vfsqrt.vfmt - Vectorial FP Square Root\n                  allow_replication = 1'b0;  // only one operand\n                  if (instr.rvftype.rs2 != 5'b00000) illegal_instr = 1'b1;  // rs2 must be 0\n                end\n                5'b01000: begin\n                  instruction_o.op = ariane_pkg::FMADD; // vfmac.vfmt - Vectorial FP Multiply-Accumulate\n                  imm_select = SIMM;  // rd into result field (upper bits don't matter)\n                end\n                5'b01001: begin\n                  instruction_o.op = ariane_pkg::FMSUB; // vfmre.vfmt - Vectorial FP Multiply-Reduce\n                  imm_select = SIMM;  // rd into result field (upper bits don't matter)\n                end\n                5'b01100: begin\n                  unique case (instr.rvftype.rs2) inside // operation encoded in rs2, `inside` for matching ?\n                    5'b00000: begin\n                      instruction_o.rs2[4:0] = instr.rvftype.rs1; // set rs2 = rs1 so we can map FMV to SGNJ in the unit\n                      if (instr.rvftype.repl)\n                        instruction_o.op = ariane_pkg::FMV_X2F;  // vfmv.vfmt.x - GPR to FPR Move\n                      else instruction_o.op = ariane_pkg::FMV_F2X;  // vfmv.x.vfmt - FPR to GPR Move\n                      check_fprm = 1'b0;  // no rounding for moves\n                    end\n                    5'b00001: begin\n                      instruction_o.op  = ariane_pkg::FCLASS; // vfclass.vfmt - Vectorial FP Classify\n                      check_fprm = 1'b0;  // no rounding for classification\n                      allow_replication = 1'b0;  // R must not be set\n                    end\n                    5'b00010:\n                    instruction_o.op = ariane_pkg::FCVT_F2I; // vfcvt.x.vfmt - Vectorial FP to Int Conversion\n                    5'b00011:\n                    instruction_o.op = ariane_pkg::FCVT_I2F; // vfcvt.vfmt.x - Vectorial Int to FP Conversion\n                    5'b001??: begin\n                      instruction_o.op       = ariane_pkg::FCVT_F2F; // vfcvt.vfmt.vfmt - Vectorial FP to FP Conversion\n                      instruction_o.rs2[4:0] = instr.rvftype.rd; // set rs2 = rd as target vector for conversion\n                      imm_select = IIMM;  // rs2 holds part of the intruction\n                      // TODO CHECK R bit for valid fmt combinations\n                      // determine source format\n                      unique case (instr.rvftype.rs2[21:20])\n                        // Only process instruction if corresponding extension is active (static)\n                        2'b00:   if (~CVA6Cfg.RVFVec) illegal_instr = 1'b1;\n                        2'b01:   if (~CVA6Cfg.XF16ALTVec) illegal_instr = 1'b1;\n                        2'b10:   if (~CVA6Cfg.XF16Vec) illegal_instr = 1'b1;\n                        2'b11:   if (~CVA6Cfg.XF8Vec) illegal_instr = 1'b1;\n                        default: illegal_instr = 1'b1;\n                      endcase\n                    end\n                    default: illegal_instr = 1'b1;\n                  endcase\n                end\n                5'b01101: begin\n                  check_fprm = 1'b0;  // no rounding for sign-injection\n                  instruction_o.op = ariane_pkg::VFSGNJ; // vfsgnj.vfmt - Vectorial FP Sign Injection\n                end\n                5'b01110: begin\n                  check_fprm = 1'b0;  // no rounding for sign-injection\n                  instruction_o.op = ariane_pkg::VFSGNJN; // vfsgnjn.vfmt - Vectorial FP Negated Sign Injection\n                end\n                5'b01111: begin\n                  check_fprm = 1'b0;  // no rounding for sign-injection\n                  instruction_o.op = ariane_pkg::VFSGNJX; // vfsgnjx.vfmt - Vectorial FP XORed Sign Injection\n                end\n                5'b10000: begin\n                  check_fprm       = 1'b0;  // no rounding for comparisons\n                  instruction_o.op = ariane_pkg::VFEQ;  // vfeq.vfmt - Vectorial FP Equality\n                end\n                5'b10001: begin\n                  check_fprm    "}
{"text": "   = 1'b0;  // no rounding for comparisons\n                  instruction_o.op = ariane_pkg::VFNE;  // vfne.vfmt - Vectorial FP Non-Equality\n                end\n                5'b10010: begin\n                  check_fprm       = 1'b0;  // no rounding for comparisons\n                  instruction_o.op = ariane_pkg::VFLT;  // vfle.vfmt - Vectorial FP Less Than\n                end\n                5'b10011: begin\n                  check_fprm = 1'b0;  // no rounding for comparisons\n                  instruction_o.op = ariane_pkg::VFGE;  // vfge.vfmt - Vectorial FP Greater or Equal\n                end\n                5'b10100: begin\n                  check_fprm       = 1'b0;  // no rounding for comparisons\n                  instruction_o.op = ariane_pkg::VFLE;  // vfle.vfmt - Vectorial FP Less or Equal\n                end\n                5'b10101: begin\n                  check_fprm       = 1'b0;  // no rounding for comparisons\n                  instruction_o.op = ariane_pkg::VFGT;  // vfgt.vfmt - Vectorial FP Greater Than\n                end\n                5'b11000: begin\n                  instruction_o.op  = ariane_pkg::VFCPKAB_S; // vfcpka/b.vfmt.s - Vectorial FP Cast-and-Pack from 2x FP32, lowest 4 entries\n                  imm_select = SIMM;  // rd into result field (upper bits don't matter)\n                  if (~CVA6Cfg.RVF)\n                    illegal_instr = 1'b1;  // if we don't support RVF, we can't cast from FP32\n                  // check destination format\n                  unique case (instr.rvftype.vfmt)\n                    // Only process instruction if corresponding extension is active and FLEN suffices (static)\n                    2'b00: begin\n                      if (~CVA6Cfg.RVFVec)\n                        illegal_instr = 1'b1;  // destination vector not supported\n                      if (instr.rvftype.repl)\n                        illegal_instr = 1'b1;  // no entries 2/3 in vector of 2 fp32\n                    end\n                    2'b01: begin\n                      if (~CVA6Cfg.XF16ALTVec)\n                        illegal_instr = 1'b1;  // destination vector not supported\n                    end\n                    2'b10: begin\n                      if (~CVA6Cfg.XF16Vec)\n                        illegal_instr = 1'b1;  // destination vector not supported\n                    end\n                    2'b11: begin\n                      if (~CVA6Cfg.XF8Vec)\n                        illegal_instr = 1'b1;  // destination vector not supported\n                    end\n                    default: illegal_instr = 1'b1;\n                  endcase\n                end\n                5'b11001: begin\n                  instruction_o.op  = ariane_pkg::VFCPKCD_S; // vfcpkc/d.vfmt.s - Vectorial FP Cast-and-Pack from 2x FP32, second 4 entries\n                  imm_select = SIMM;  // rd into result field (upper bits don't matter)\n                  if (~CVA6Cfg.RVF)\n                    illegal_instr = 1'b1;  // if we don't support RVF, we can't cast from FP32\n                  // check destination format\n                  unique case (instr.rvftype.vfmt)\n                    // Only process instruction if corresponding extension is active and FLEN suffices (static)\n                    2'b00:   illegal_instr = 1'b1;  // no entries 4-7 in vector of 2 FP32\n                    2'b01:   illegal_instr = 1'b1;  // no entries 4-7 in vector of 4 FP16ALT\n                    2'b10:   illegal_instr = 1'b1;  // no entries 4-7 in vector of 4 FP16\n                    2'b11: begin\n                      if (~CVA6Cfg.XF8Vec)\n                        illegal_instr = 1'b1;  // destination vector not supported\n                    end\n                    default: illegal_instr = 1'b1;\n                  endcase\n                end\n                5'b11010: begin\n                  instruction_o.op  = ariane_pkg::VFCPKAB_D; // vfcpka/b.vfmt.d - Vectorial FP Cast-and-Pack from 2x FP64, lowest 4 entries\n                  imm_select = SIMM;  // rd into result field (upper bits don't matter)\n                  if (~CVA6Cfg.RVD)\n                    illegal_instr = 1'b1;  // if we don't support RVD, we can't cast from FP64\n                  // check destination format\n                  unique case (instr.rvftype.vfmt)\n                    // Only process instruction if corresponding extension is active and FLEN suffices (static)\n                    2'b00: begin\n                      if (~CVA6Cfg.RVFVec)\n                        illegal_instr = 1'b1;  // destination vector not supported\n                      if (instr.rvftype.repl)\n                        illegal_instr = 1'b1;  // no entries 2/3 in vector of 2 fp32\n                    end\n                    2'b01: begin\n                      if (~CVA6Cfg.XF16ALTVec)\n                        illegal_instr = 1'b1;  // destination vector not supported\n                    end\n                    2'b10: begin\n                      if (~CVA6Cfg.XF16Vec)\n                        illegal_instr = 1'b1;  // destination vector not supported\n                    end\n                    2'b11: begin\n                      if (~CVA6Cfg.XF8Vec)\n                        illegal_instr = 1'b1;  // destination vector not supported\n                    end\n                    default: illegal_instr = 1'b1;\n                  endcase\n                end\n                5'b11011: begin\n                  instruction_o.op  = ariane_pkg::VFCPKCD_D; // vfcpka/b.vfmt.d - Vectorial FP Cast-and-Pack from 2x FP64, second 4 entries\n                  imm_select = SIMM;  // rd into result field (upper bits don't matter)\n                  if (~CVA6Cfg.RVD)\n                    illegal_instr = 1'b1;  // if we don't support RVD, we can't cast from FP64\n                  // check destination format\n                  unique case (instr.rvftype.vfmt)\n                    // Only process instruction if corresponding extension is active and FLEN suffices (static)\n                    2'b00:   illegal_instr = 1'b1;  // no entries 4-7 in vector of 2 FP32\n                    2'b01:   illegal_instr = 1'b1;  // no entries 4-7 in vector of 4 FP16ALT\n                    2'b10:   illegal_instr = 1'b1;  // no entries 4-7 in vector of 4 FP16\n                    2'b11: begin\n                      if (~CVA6Cfg.XF8Vec)\n                        illegal_instr = 1'b1;  // destination vector not supported\n                    end\n                    default: illegal_instr = 1'b1;\n                  endcase\n                end\n                default: illegal_instr = 1'b1;\n              endcase\n\n              // check format\n              unique case (instr.rvftype.vfmt)\n                // Only process instruction if corresponding extension is active (static)\n                2'b00:   if (~CVA6Cfg.RVFVec) illegal_instr = 1'b1;\n                2'b01:   if (~CVA6Cfg.XF16ALTVec) illegal_instr = 1'b1;\n                2'b10:   if (~CVA6Cfg.XF16Vec) illegal_instr = 1'b1;\n                2'b11:   if (~CVA6Cfg.XF8Vec) illegal_instr = 1'b1;\n                default: illegal_instr = 1'b1;\n              endcase\n\n              // check disallowed replication\n              if (~allow_replication & instr.rvftype.repl) illegal_instr = 1'b1;\n\n              // check rounding mode\n              if (check_fprm) begin\n                unique case (frm_i) inside  // actual rounding mode from frm csr\n                  [3'b000 : 3'b100]: ;  //legal rounding modes\n                  default: illegal_instr = 1'b1;\n                endcase\n              end\n\n            end else begin  // No vectorial FP enabled (static)\n              illegal_instr = 1'b1;\n            end\n\n            // ---------------------------\n            // Integer Reg-Reg Operations\n            // ---------------------------\n          end else begin\n            if (CVA6Cfg.RVB) begin\n              instruction_o.fu  = (instr.rtype.funct7 == 7'b000_0001 || ((instr.rtype.funct7 == 7'b000_0101) && !(instr.rtype.funct3[14]))) ? MULT : ALU;\n            end else begin\n              instruction_o.fu = (instr.rtype.funct7 == 7'b000_0001) ? MULT : ALU;\n            end\n            instruction_o.rs1[4:0] = instr.rtype.rs1;\n            instruction_o.rs2[4:0] = instr.rtype.rs2;\n            instruction_o.rd[4:0]  = instr.rtype.rd;\n\n            unique case ({\n              instr.rtype.funct7, instr.rtype.funct3\n            })\n              {7'b000_0000, 3'b000} : instruction_o.op = ariane_pkg::ADD;  // Add\n              {7'b010_0000, 3'b000} : instruction_o.op = ariane_pkg::SUB;  // Sub\n              {7'b000_0000, 3'b010} : instruction_o.op = ariane_pkg::SLTS;  // Set Lower Than\n              {\n                7'b000_0000, 3'b011\n              } :\n              instruction_o.op = ariane_pkg::SLTU;  // Set Lower Than Unsigned\n              {7'b000_0000, 3'b100} : instruction_o.op = ariane_pkg::XORL;  // Xor\n              {7'b000_0000, 3'b110} : instruction_o.op = ariane_pkg::ORL;  // Or\n              {7'b000_0000, 3'b111} : instruction_o.op = ariane_pkg::ANDL;  // And\n              {7'b000_0000, 3'b001} : instruction_o.op = ariane_pkg::SLL;  // Shift Left Logical\n              {7'b000_0000, 3'b101} : instruction_o.op = ariane_pkg::SRL;  // Shift Right Logical\n              {7'b010_0000, 3'b101} : instruction_o.op = ariane_pkg::SRA;  // Shift Right Arithmetic\n              // Multiplications\n              {7'b000_0001, 3'b000} : instruction_o.op = ariane_pkg::MUL;\n              {7'b000_0001, 3'b001} : instruction_o.op = ariane_pkg::MULH;\n              {7'b000_0001, 3'b010} : instruction_o.op = ariane_pkg::MULHSU;\n              {7'b000_0001, 3'b011} : instruction_o.op = ariane_pkg::MULHU;\n              {7'b000_0001, 3'b100} : instruction_o.op = ariane_pkg::DIV;\n              {7'b000_0001, 3'b101} : instruction_o.op = ariane_pkg::DIVU;\n              {7'b000_0001, 3'b110} : instruction_o.op = ariane_pkg::REM;\n              {7'b000_0001, 3'b111} : instruction_o.op = ariane_pkg::REMU;\n              default: begin\n                illegal_instr_non_bm = 1'b1;\n              end\n            endcase\n            if (CVA6Cfg.RVB) begin\n              unique case ({\n                instr.rtype.funct7, instr.rtype.funct3\n              })\n                //Logical with Negate\n                {7'b010_0000, 3'b111} : instruction_o.op = ariane_pkg::ANDN;  // Andn\n                {7'b010_0000, 3'b110} : instruction_o.op = ariane_pkg::ORN;  // Orn\n                {7'b010_0000, 3'b100} : instruction_o.op = ariane_pkg::XNOR;  // Xnor\n                //Shift and Add (Bitmanip)\n                {7'b001_0000, 3'b010} : instruction_o.op = ariane_pkg::SH1ADD;  // Sh1add\n                {7'b001_0000, 3'b100} : instruction_o.op = ariane_pkg::SH2ADD;  // Sh2add\n                {7'b001_0000, 3'b110} : instruction_o.op = ariane_pkg::SH3ADD;  // Sh3add\n                // Integer maximum/minimum\n                {7'b000_0101, 3'b110} : instruction_o.op = ariane_pkg::MAX;  // max\n                {7'b000_0101, 3'b111} : instruction_o.op = ariane_pkg::MAXU;  // maxu\n                {7'b000_0101, 3'b100} : instruction_o.op = ariane_pkg::MIN;  // min\n                {7'b000_0101, 3'b101} : instruction_o.op = ariane_pkg::MINU;  // minu\n                // Single bit instructions\n                {7'b010_0100, 3'b001} : instruction_o.op = ariane_pkg::BCLR;  // bclr\n                {7'b010_0100, 3'b101} : instruction_o.op = ariane_pkg::BEXT;  // bext\n                {7'b011_0100, 3'b001} : instruction_o.op = ariane_pkg::BINV;  // binv\n                {7'b001_0100, 3'b001} : instruction_o.op = ariane_pkg::BSET;  // bset\n                // Carry-Less-Multiplication (clmul, clmulh, clmulr)\n                {7'b000_0101, 3'b001} : instruction_o.op = ariane_pkg::CLMUL;  // clmul\n                {7'b000_0101, 3'b011} : instruction_o.op = ariane_pkg::CLMULH;  // clmulh\n                {7'b000_0101, 3'b010} : instruction_o.op = ariane_pkg::CLMULR;  // clmulr\n                // Bitwise Shifting\n                {7'b011_0000, 3'b001} : instruction_o.op = ariane_pkg::ROL;  // rol\n                {7'b011_0000, 3'b101} : instruction_o.op = ariane_pkg::ROR;  // ror\n                // Zero Extend Op\n                {7'b000_0100, 3'b100} : instruction_o.op = ariane_pkg::ZEXTH;\n                default: begin\n                  illegal_instr_bm = 1'b1;\n                end\n              endcase\n            end\n            if (CVA6Cfg.ZiCondExtEn) begin\n              unique case ({\n                instr.rtype.funct7, instr.rtype.funct3\n              })\n                //Conditional move\n                {7'b000_0111, 3'b101} : instruction_o.op = ariane_pkg::CZERO_EQZ;  // czero.eqz\n                {7'b000_0111, 3'b111} : instruction_o.op = ariane_pkg::CZERO_NEZ;  // czero.nez\n                default: begin\n                  illegal_instr_zic = 1'b1;\n                end\n              endcase\n            end\n            //VCS coverage on\n            unique case ({\n              CVA6Cfg.RVB, CVA6Cfg.ZiCondExtEn\n            })\n              2'b00: illegal_instr = illegal_instr_non_bm;\n              2'b01: illegal_instr = illegal_instr_non_bm & illegal_instr_zic;\n              2'b10: illegal_instr = illegal_instr_non_bm & illegal_instr_bm;\n              2'b11: illegal_instr = illegal_instr_non_bm & illegal_instr_bm & illegal_instr_zic;\n            endcase\n          end\n        end\n\n        // --------------------------\n        // 32bit Reg-Reg Operations\n        // --------------------------\n        riscv::OpcodeOp32: begin\n          instruction_o.fu = (instr.rtype.funct7 == 7'b000_0001) ? MULT : ALU;\n          instruction_o.rs1[4:0] = instr.rtype.rs1;\n          instruction_o.rs2[4:0] = instr.rtype.rs2;\n          instruction_o.rd[4:0] = instr.rtype.rd;\n          if (riscv::IS_XLEN64) begin\n            unique case ({\n              instr.rtype.funct7, instr.rtype.funct3\n            })\n              {7'b000_0000, 3'b000} : instruction_o.op = ariane_pkg::ADDW;  // addw\n              {7'b010_0000, 3'b000} : instruction_o.op = ariane_pkg::SUBW;  // subw\n              {7'b000_0000, 3'b001} : instruction_o.op = ariane_pkg::SLLW;  // sllw\n              {7'b000_0000, 3'b101} : instruction_o.op = ariane_pkg::SRLW;  // srlw\n              {7'b010_0000, 3'b101} : instruction_o.op = ariane_pkg::SRAW;  // sraw\n              // Multiplications\n              {7'b000_0001, 3'b000} : instruction_o.op = ariane_pkg::MULW;\n              {7'b000_0001, 3'b100} : instruction_o.op = ariane_pkg::DIVW;\n              {7'b000_0001, 3'b101} : instruction_o.op = ariane_pkg::DIVUW;\n              {7'b000_0001, 3'b110} : instruction_o.op = ariane_pkg::REMW;\n              {7'b000_0001, 3'b111} : instruction_o.op = ariane_pkg::REMUW;\n              default: illegal_instr_non_bm = 1'b1;\n            endcase\n            if (CVA6Cfg.RVB) begin\n              unique case ({\n                instr.rtype.funct7, instr.rtype.funct3\n              })\n                // Shift with Add (Unsigned Word)\n                {7'b001_0000, 3'b010}: instruction_o.op = ariane_pkg::SH1ADDUW; // sh1add.uw\n                {7'b001_0000, 3'b100}: instruction_o.op = ariane_pkg::SH2ADDUW; // sh2add.uw\n                {7'b001_0000, 3'b110}: instruction_o.op = ariane_pkg::SH3ADDUW; // sh3add.uw\n                // Unsigned word Op's\n                {7'b000_0100, 3'b000}: instruction_o.op = ariane_pkg::ADDUW;    // add.uw\n                // Bitwise Shifting\n                {7'b011_0000, 3'b001}: instruction_o.op = ariane_pkg::ROLW;     // rolw\n                {7'b011_0000, 3'b101}: instruction_o.op = ariane_pkg::RORW;     // rorw\n                default: illegal_instr_bm = 1'b1;\n              endcase\n              illegal_instr = illegal_instr_non_bm & illegal_instr_bm;\n            end else begin\n              illegal_instr = illegal_instr_non_bm;\n            end\n          end else illegal_instr = 1'b1;\n        end\n        // --------------------------------\n        // Reg-Immediate Operations\n        // --------------------------------\n        riscv::OpcodeOpImm: begin\n          instruction_o.fu = ALU;\n          imm_select = IIMM;\n          instruction_o.rs1[4:0] = instr.itype.rs1;\n          instruction_o.rd[4:0] = instr.itype.rd;\n          unique case (instr.itype.funct3)\n            3'b000: instruction_o.op = ariane_pkg::ADD;  // Add Immediate\n            3'b010: instruction_o.op = ariane_pkg::SLTS;  // Set to one if Lower Than Immediate\n            3'b011:\n            instruction_o.op = ariane_pkg::SLTU;  // Set to one if Lower Than Immediate Unsigned\n            3'b100: instruction_o.op = ariane_pkg::XORL;  // Exclusive Or with Immediate\n            3'b110: instruction_o.op = ariane_pkg::ORL;  // Or with Immediate\n            3'b111: instruction_o.op = ariane_pkg::ANDL;  // And with Immediate\n\n            3'b001: begin\n              instruction_o.op = ariane_pkg::SLL;  // Shift Left Logical by Immediate\n              if (instr.instr[31:26] != 6'b0) illegal_instr_non_bm = 1'b1;\n              if (instr.instr[25] != 1'b0 && riscv::XLEN == 32) illegal_instr_non_bm = 1'b1;\n            end\n\n            3'b101: begin\n              if (instr.instr[31:26] == 6'b0)\n                instruction_o.op = ariane_pkg::SRL;  // Shift Right Logical by Immediate\n              else if (instr.instr[31:26] == 6'b010_000)\n                instruction_o.op = ariane_pkg::SRA;  // Shift Right Arithmetically by Immediate\n              else illegal_instr_non_bm = 1'b1;\n              if (instr.instr[25] != 1'b0 && riscv::XLEN == 32) illegal_instr_non_bm = 1'b1;\n            end\n          endcase\n          if (CVA6Cfg.RVB) begin\n            unique case (instr.itype.funct3)\n              3'b001: begin\n                if (instr.instr[31:25] == 7'b0110000) begin\n                  if (instr.instr[22:20] == 3'b100) instruction_o.op = ariane_pkg::SEXTB;\n                  else if (instr.instr[22:20] == 3'b101) instruction_o.op = ariane_pkg::SEXTH;\n                  else if (instr.instr[22:20] == 3'b010) instruction_o.op = ariane_pkg::CPOP;\n                  else if (instr.instr[22:20] == 3'b000) instruction_o.op = ariane_pkg::CLZ;\n                  else if (instr.instr[22:20] == 3'b001) instruction_o.op = ariane_pkg::CTZ;\n                end else if (instr.instr[31:26] == 6'b010010) instruction_o.op = ariane_pkg::BCLRI;\n                else if (instr.instr[31:26] == 6'b011010) instruction_o.op = ariane_pkg::BINVI;\n                else if (instr.instr[31:26] == 6'b001010) instruction_o.op = ariane_pkg::BSETI;\n                else illegal_instr_bm = 1'b1;\n              end\n              3'b101: begin\n                if (instr.instr[31:20] == 12'b001010000111) instruction_o.op = ariane_pkg::ORCB;\n                else if (riscv::IS_XLEN64 && instr.instr[31:20] == 12'b011010111000)\n                  instruction_o.op = ariane_pkg::REV8;\n                else if (instr.instr[31:20] == 12'b011010011000)\n                  instruction_o.op = ariane_pkg::REV8;\n                else if (instr.instr[31:26] == 6'b010_010) instruction_o.op = ariane_pkg::BEXTI;\n                else if (instr.instr[31:26] == 6'b011_000) instruction_o.op = ariane_pkg::RORI;\n                else illegal_instr_bm = 1'b1;\n              end\n              default: illegal_instr_bm = 1'b1;\n            endcase\n            illegal_instr = illegal_instr_non_bm & illegal_instr_bm;\n          end else begin\n            illegal_instr = illegal_instr_non_bm;\n          end\n        end\n\n        // --------------------------------\n        // 32 bit Reg-Immediate Operations\n        // --------------------------------\n        riscv::OpcodeOpImm32: begin\n          instruction_o.fu = ALU;\n          imm_select = IIMM;\n          instruction_o.rs1[4:0] = instr.itype.rs1;\n          instruction_o.rd[4:0] = instr.itype.rd;\n          if (riscv::IS_XLEN64) begin\n            unique case (instr.itype.funct3)\n              3'b000:  instruction_o.op = ariane_pkg::ADDW;  // Add Immediate\n              3'b001: begin\n                instruction_o.op = ariane_pkg::SLLW;  // Shift Left Logical by Immediat"}
{"text": "e\n                if (instr.instr[31:25] != 7'b0) illegal_instr_non_bm = 1'b1;\n              end\n              3'b101: begin\n                if (instr.instr[31:25] == 7'b0)\n                  instruction_o.op = ariane_pkg::SRLW;  // Shift Right Logical by Immediate\n                else if (instr.instr[31:25] == 7'b010_0000)\n                  instruction_o.op = ariane_pkg::SRAW;  // Shift Right Arithmetically by Immediate\n                else illegal_instr_non_bm = 1'b1;\n              end\n              default: illegal_instr_non_bm = 1'b1;\n            endcase\n            if (CVA6Cfg.RVB) begin\n              unique case (instr.itype.funct3)\n                3'b001: begin\n                  if (instr.instr[31:25] == 7'b0110000) begin\n                    if (instr.instr[21:20] == 2'b10) instruction_o.op = ariane_pkg::CPOPW;\n                    else if (instr.instr[21:20] == 2'b00) instruction_o.op = ariane_pkg::CLZW;\n                    else if (instr.instr[21:20] == 2'b01) instruction_o.op = ariane_pkg::CTZW;\n                    else illegal_instr_bm = 1'b1;\n                  end else if (instr.instr[31:26] == 6'b000010) begin\n                    instruction_o.op = ariane_pkg::SLLIUW; // Shift Left Logic by Immediate (Unsigned Word)\n                  end else illegal_instr_bm = 1'b1;\n                end\n                3'b101: begin\n                  if (instr.instr[31:25] == 7'b011_0000) instruction_o.op = ariane_pkg::RORIW;\n                  else illegal_instr_bm = 1'b1;\n                end\n                default: illegal_instr_bm = 1'b1;\n              endcase\n              illegal_instr = illegal_instr_non_bm & illegal_instr_bm;\n            end else begin\n              illegal_instr = illegal_instr_non_bm;\n            end\n\n          end else illegal_instr = 1'b1;\n        end\n        // --------------------------------\n        // LSU\n        // --------------------------------\n        riscv::OpcodeStore: begin\n          instruction_o.fu = STORE;\n          imm_select = SIMM;\n          instruction_o.rs1[4:0] = instr.stype.rs1;\n          instruction_o.rs2[4:0] = instr.stype.rs2;\n          // determine store size\n          unique case (instr.stype.funct3)\n            3'b000: instruction_o.op = ariane_pkg::SB;\n            3'b001: instruction_o.op = ariane_pkg::SH;\n            3'b010: instruction_o.op = ariane_pkg::SW;\n            3'b011:\n            if (riscv::XLEN == 64) instruction_o.op = ariane_pkg::SD;\n            else illegal_instr = 1'b1;\n            default: illegal_instr = 1'b1;\n          endcase\n        end\n\n        riscv::OpcodeLoad: begin\n          instruction_o.fu = LOAD;\n          imm_select = IIMM;\n          instruction_o.rs1[4:0] = instr.itype.rs1;\n          instruction_o.rd[4:0] = instr.itype.rd;\n          // determine load size and signed type\n          unique case (instr.itype.funct3)\n            3'b000: instruction_o.op = ariane_pkg::LB;\n            3'b001: instruction_o.op = ariane_pkg::LH;\n            3'b010: instruction_o.op = ariane_pkg::LW;\n            3'b100: instruction_o.op = ariane_pkg::LBU;\n            3'b101: instruction_o.op = ariane_pkg::LHU;\n            3'b110:\n            if (riscv::XLEN == 64) instruction_o.op = ariane_pkg::LWU;\n            else illegal_instr = 1'b1;\n            3'b011:\n            if (riscv::XLEN == 64) instruction_o.op = ariane_pkg::LD;\n            else illegal_instr = 1'b1;\n            default: illegal_instr = 1'b1;\n          endcase\n        end\n\n        // --------------------------------\n        // Floating-Point Load/store\n        // --------------------------------\n        riscv::OpcodeStoreFp: begin\n          if (CVA6Cfg.FpPresent && fs_i != riscv::Off) begin // only generate decoder if FP extensions are enabled (static)\n            instruction_o.fu = STORE;\n            imm_select = SIMM;\n            instruction_o.rs1[4:0] = instr.stype.rs1;\n            instruction_o.rs2[4:0] = instr.stype.rs2;\n            // determine store size\n            unique case (instr.stype.funct3)\n              // Only process instruction if corresponding extension is active (static)\n              3'b000:\n              if (CVA6Cfg.XF8) instruction_o.op = ariane_pkg::FSB;\n              else illegal_instr = 1'b1;\n              3'b001:\n              if (CVA6Cfg.XF16 | CVA6Cfg.XF16ALT) instruction_o.op = ariane_pkg::FSH;\n              else illegal_instr = 1'b1;\n              3'b010:\n              if (CVA6Cfg.RVF) instruction_o.op = ariane_pkg::FSW;\n              else illegal_instr = 1'b1;\n              3'b011:\n              if (CVA6Cfg.RVD) instruction_o.op = ariane_pkg::FSD;\n              else illegal_instr = 1'b1;\n              default: illegal_instr = 1'b1;\n            endcase\n          end else illegal_instr = 1'b1;\n        end\n\n        riscv::OpcodeLoadFp: begin\n          if (CVA6Cfg.FpPresent && fs_i != riscv::Off) begin // only generate decoder if FP extensions are enabled (static)\n            instruction_o.fu = LOAD;\n            imm_select = IIMM;\n            instruction_o.rs1[4:0] = instr.itype.rs1;\n            instruction_o.rd[4:0] = instr.itype.rd;\n            // determine load size\n            unique case (instr.itype.funct3)\n              // Only process instruction if corresponding extension is active (static)\n              3'b000:\n              if (CVA6Cfg.XF8) instruction_o.op = ariane_pkg::FLB;\n              else illegal_instr = 1'b1;\n              3'b001:\n              if (CVA6Cfg.XF16 | CVA6Cfg.XF16ALT) instruction_o.op = ariane_pkg::FLH;\n              else illegal_instr = 1'b1;\n              3'b010:\n              if (CVA6Cfg.RVF) instruction_o.op = ariane_pkg::FLW;\n              else illegal_instr = 1'b1;\n              3'b011:\n              if (CVA6Cfg.RVD) instruction_o.op = ariane_pkg::FLD;\n              else illegal_instr = 1'b1;\n              default: illegal_instr = 1'b1;\n            endcase\n          end else illegal_instr = 1'b1;\n        end\n\n        // ----------------------------------\n        // Floating-Point Reg-Reg Operations\n        // ----------------------------------\n        riscv::OpcodeMadd, riscv::OpcodeMsub, riscv::OpcodeNmsub, riscv::OpcodeNmadd: begin\n          if (CVA6Cfg.FpPresent && fs_i != riscv::Off) begin // only generate decoder if FP extensions are enabled (static)\n            instruction_o.fu       = FPU;\n            instruction_o.rs1[4:0] = instr.r4type.rs1;\n            instruction_o.rs2[4:0] = instr.r4type.rs2;\n            instruction_o.rd[4:0]  = instr.r4type.rd;\n            imm_select             = RS3;  // rs3 into result field\n            check_fprm             = 1'b1;\n            // select the correct fused operation\n            unique case (instr.r4type.opcode)\n              default: instruction_o.op = ariane_pkg::FMADD;  // fmadd.fmt - FP Fused multiply-add\n              riscv::OpcodeMsub:\n              instruction_o.op = ariane_pkg::FMSUB;  // fmsub.fmt - FP Fused multiply-subtract\n              riscv::OpcodeNmsub:\n              instruction_o.op = ariane_pkg::FNMSUB; // fnmsub.fmt - FP Negated fused multiply-subtract\n              riscv::OpcodeNmadd:\n              instruction_o.op = ariane_pkg::FNMADD;  // fnmadd.fmt - FP Negated fused multiply-add\n            endcase\n\n            // determine fp format\n            unique case (instr.r4type.funct2)\n              // Only process instruction if corresponding extension is active (static)\n              2'b00:   if (~CVA6Cfg.RVF) illegal_instr = 1'b1;\n              2'b01:   if (~CVA6Cfg.RVD) illegal_instr = 1'b1;\n              2'b10:   if (~CVA6Cfg.XF16 & ~CVA6Cfg.XF16ALT) illegal_instr = 1'b1;\n              2'b11:   if (~CVA6Cfg.XF8) illegal_instr = 1'b1;\n              default: illegal_instr = 1'b1;\n            endcase\n\n            // check rounding mode\n            if (check_fprm) begin\n              unique case (instr.rftype.rm) inside\n                [3'b000 : 3'b100]: ;  //legal rounding modes\n                3'b101: begin  // Alternative Half-Precsision encded as fmt=10 and rm=101\n                  if (~CVA6Cfg.XF16ALT || instr.rftype.fmt != 2'b10) illegal_instr = 1'b1;\n                  unique case (frm_i) inside  // actual rounding mode from frm csr\n                    [3'b000 : 3'b100]: ;  //legal rounding modes\n                    default: illegal_instr = 1'b1;\n                  endcase\n                end\n                3'b111: begin\n                  // rounding mode from frm csr\n                  unique case (frm_i) inside\n                    [3'b000 : 3'b100]: ;  //legal rounding modes\n                    default: illegal_instr = 1'b1;\n                  endcase\n                end\n                default:           illegal_instr = 1'b1;\n              endcase\n            end\n          end else begin\n            illegal_instr = 1'b1;\n          end\n        end\n\n        riscv::OpcodeOpFp: begin\n          if (CVA6Cfg.FpPresent && fs_i != riscv::Off) begin // only generate decoder if FP extensions are enabled (static)\n            instruction_o.fu       = FPU;\n            instruction_o.rs1[4:0] = instr.rftype.rs1;\n            instruction_o.rs2[4:0] = instr.rftype.rs2;\n            instruction_o.rd[4:0]  = instr.rftype.rd;\n            check_fprm             = 1'b1;\n            // decode FP instruction\n            unique case (instr.rftype.funct5)\n              5'b00000: begin\n                instruction_o.op       = ariane_pkg::FADD;  // fadd.fmt - FP Addition\n                instruction_o.rs1      = '0;  // Operand A is set to 0\n                instruction_o.rs2[4:0] = instr.rftype.rs1;  // Operand B is set to rs1\n                imm_select             = IIMM;  // Operand C is set to rs2\n              end\n              5'b00001: begin\n                instruction_o.op       = ariane_pkg::FSUB;  // fsub.fmt - FP Subtraction\n                instruction_o.rs1      = '0;  // Operand A is set to 0\n                instruction_o.rs2[4:0] = instr.rftype.rs1;  // Operand B is set to rs1\n                imm_select             = IIMM;  // Operand C is set to rs2\n              end\n              5'b00010: instruction_o.op = ariane_pkg::FMUL;  // fmul.fmt - FP Multiplication\n              5'b00011: instruction_o.op = ariane_pkg::FDIV;  // fdiv.fmt - FP Division\n              5'b01011: begin\n                instruction_o.op = ariane_pkg::FSQRT;  // fsqrt.fmt - FP Square Root\n                // rs2 must be zero\n                if (instr.rftype.rs2 != 5'b00000) illegal_instr = 1'b1;\n              end\n              5'b00100: begin\n                instruction_o.op = ariane_pkg::FSGNJ;  // fsgn{j[n]/jx}.fmt - FP Sign Injection\n                check_fprm       = 1'b0;  // instruction encoded in rm, do the check here\n                if (CVA6Cfg.XF16ALT) begin        // FP16ALT instructions encoded in rm separately (static)\n                  if (!(instr.rftype.rm inside {[3'b000 : 3'b010], [3'b100 : 3'b110]}))\n                    illegal_instr = 1'b1;\n                end else begin\n                  if (!(instr.rftype.rm inside {[3'b000 : 3'b010]})) illegal_instr = 1'b1;\n                end\n              end\n              5'b00101: begin\n                instruction_o.op = ariane_pkg::FMIN_MAX;  // fmin/fmax.fmt - FP Minimum / Maximum\n                check_fprm       = 1'b0;  // instruction encoded in rm, do the check here\n                if (CVA6Cfg.XF16ALT) begin           // FP16ALT instructions encoded in rm separately (static)\n                  if (!(instr.rftype.rm inside {[3'b000 : 3'b001], [3'b100 : 3'b101]}))\n                    illegal_instr = 1'b1;\n                end else begin\n                  if (!(instr.rftype.rm inside {[3'b000 : 3'b001]})) illegal_instr = 1'b1;\n                end\n              end\n              5'b01000: begin\n                instruction_o.op = ariane_pkg::FCVT_F2F;  // fcvt.fmt.fmt - FP to FP Conversion\n                instruction_o.rs2[4:0] = instr.rvftype.rs1; // tie rs2 to rs1 to be safe (vectors use rs2)\n                imm_select = IIMM;  // rs2 holds part of the intruction\n                if (|instr.rftype.rs2[24:23])\n                  illegal_instr = 1'b1;  // bits [22:20] used, other bits must be 0\n                // check source format\n                unique case (instr.rftype.rs2[22:20])\n                  // Only process instruction if corresponding extension is active (static)\n                  3'b000:  if (~CVA6Cfg.RVF) illegal_instr = 1'b1;\n                  3'b001:  if (~CVA6Cfg.RVD) illegal_instr = 1'b1;\n                  3'b010:  if (~CVA6Cfg.XF16) illegal_instr = 1'b1;\n                  3'b110:  if (~CVA6Cfg.XF16ALT) illegal_instr = 1'b1;\n                  3'b011:  if (~CVA6Cfg.XF8) illegal_instr = 1'b1;\n                  default: illegal_instr = 1'b1;\n                endcase\n              end\n              5'b10100: begin\n                instruction_o.op = ariane_pkg::FCMP;  // feq/flt/fle.fmt - FP Comparisons\n                check_fprm       = 1'b0;  // instruction encoded in rm, do the check here\n                if (CVA6Cfg.XF16ALT) begin       // FP16ALT instructions encoded in rm separately (static)\n                  if (!(instr.rftype.rm inside {[3'b000 : 3'b010], [3'b100 : 3'b110]}))\n                    illegal_instr = 1'b1;\n                end else begin\n                  if (!(instr.rftype.rm inside {[3'b000 : 3'b010]})) illegal_instr = 1'b1;\n                end\n              end\n              5'b11000: begin\n                instruction_o.op = ariane_pkg::FCVT_F2I;  // fcvt.ifmt.fmt - FP to Int Conversion\n                imm_select       = IIMM;  // rs2 holds part of the instruction\n                if (|instr.rftype.rs2[24:22])\n                  illegal_instr = 1'b1;  // bits [21:20] used, other bits must be 0\n              end\n              5'b11010: begin\n                instruction_o.op = ariane_pkg::FCVT_I2F;  // fcvt.fmt.ifmt - Int to FP Conversion\n                imm_select       = IIMM;  // rs2 holds part of the instruction\n                if (|instr.rftype.rs2[24:22])\n                  illegal_instr = 1'b1;  // bits [21:20] used, other bits must be 0\n              end\n              5'b11100: begin\n                instruction_o.rs2[4:0] = instr.rftype.rs1; // set rs2 = rs1 so we can map FMV to SGNJ in the unit\n                check_fprm = 1'b0;  // instruction encoded in rm, do the check here\n                if (instr.rftype.rm == 3'b000 || (CVA6Cfg.XF16ALT && instr.rftype.rm == 3'b100)) // FP16ALT has separate encoding\n                  instruction_o.op = ariane_pkg::FMV_F2X;  // fmv.ifmt.fmt - FPR to GPR Move\n                else if (instr.rftype.rm == 3'b001 || (CVA6Cfg.XF16ALT && instr.rftype.rm == 3'b101)) // FP16ALT has separate encoding\n                  instruction_o.op = ariane_pkg::FCLASS;  // fclass.fmt - FP Classify\n                else illegal_instr = 1'b1;\n                // rs2 must be zero\n                if (instr.rftype.rs2 != 5'b00000) illegal_instr = 1'b1;\n              end\n              5'b11110: begin\n                instruction_o.op = ariane_pkg::FMV_X2F;  // fmv.fmt.ifmt - GPR to FPR Move\n                instruction_o.rs2[4:0] = instr.rftype.rs1; // set rs2 = rs1 so we can map FMV to SGNJ in the unit\n                check_fprm = 1'b0;  // instruction encoded in rm, do the check here\n                if (!(instr.rftype.rm == 3'b000 || (CVA6Cfg.XF16ALT && instr.rftype.rm == 3'b100)))\n                  illegal_instr = 1'b1;\n                // rs2 must be zero\n                if (instr.rftype.rs2 != 5'b00000) illegal_instr = 1'b1;\n              end\n              default:  illegal_instr = 1'b1;\n            endcase\n\n            // check format\n            unique case (instr.rftype.fmt)\n              // Only process instruction if corresponding extension is active (static)\n              2'b00:   if (~CVA6Cfg.RVF) illegal_instr = 1'b1;\n              2'b01:   if (~CVA6Cfg.RVD) illegal_instr = 1'b1;\n              2'b10:   if (~CVA6Cfg.XF16 & ~CVA6Cfg.XF16ALT) illegal_instr = 1'b1;\n              2'b11:   if (~CVA6Cfg.XF8) illegal_instr = 1'b1;\n              default: illegal_instr = 1'b1;\n            endcase\n\n            // check rounding mode\n            if (check_fprm) begin\n              unique case (instr.rftype.rm) inside\n                [3'b000 : 3'b100]: ;  //legal rounding modes\n                3'b101: begin  // Alternative Half-Precsision encded as fmt=10 and rm=101\n                  if (~CVA6Cfg.XF16ALT || instr.rftype.fmt != 2'b10) illegal_instr = 1'b1;\n                  unique case (frm_i) inside  // actual rounding mode from frm csr\n                    [3'b000 : 3'b100]: ;  //legal rounding modes\n                    default: illegal_instr = 1'b1;\n                  endcase\n                end\n                3'b111: begin\n                  // rounding mode from frm csr\n                  unique case (frm_i) inside\n                    [3'b000 : 3'b100]: ;  //legal rounding modes\n                    default: illegal_instr = 1'b1;\n                  endcase\n                end\n                default:           illegal_instr = 1'b1;\n              endcase\n            end\n          end else begin\n            illegal_instr = 1'b1;\n          end\n        end\n\n        // ----------------------------------\n        // Atomic Operations\n        // ----------------------------------\n        riscv::OpcodeAmo: begin\n          // we are going to use the load unit for AMOs\n          instruction_o.fu = STORE;\n          instruction_o.rs1[4:0] = instr.atype.rs1;\n          instruction_o.rs2[4:0] = instr.atype.rs2;\n          instruction_o.rd[4:0] = instr.atype.rd;\n          // TODO(zarubaf): Ordering\n          // words\n          if (CVA6Cfg.RVA && instr.stype.funct3 == 3'h2) begin\n            unique case (instr.instr[31:27])\n              5'h0: instruction_o.op = ariane_pkg::AMO_ADDW;\n              5'h1: instruction_o.op = ariane_pkg::AMO_SWAPW;\n              5'h2: begin\n                instruction_o.op = ariane_pkg::AMO_LRW;\n                if (instr.atype.rs2 != 0) illegal_instr = 1'b1;\n              end\n              5'h3: instruction_o.op = ariane_pkg::AMO_SCW;\n              5'h4: instruction_o.op = ariane_pkg::AMO_XORW;\n              5'h8: instruction_o.op = ariane_pkg::AMO_ORW;\n              5'hC: instruction_o.op = ariane_pkg::AMO_ANDW;\n              5'h10: instruction_o.op = ariane_pkg::AMO_MINW;\n              5'h14: instruction_o.op = ariane_pkg::AMO_MAXW;\n              5'h18: instruction_o.op = ariane_pkg::AMO_MINWU;\n              5'h1C: instruction_o.op = ariane_pkg::AMO_MAXWU;\n              default: illegal_instr = 1'b1;\n            endcase\n            // double words\n          end else if (riscv::IS_XLEN64 && CVA6Cfg.RVA && instr.stype.funct3 == 3'h3) begin\n            unique case (instr.instr[31:27])\n              5'h0: instruction_o.op = ariane_pkg::AMO_ADDD;\n              5'h1: instruction_o.op = ariane_pkg::AMO_SWAPD;\n              5'h2: begin\n                instruction_o.op = ariane_pkg::AMO_LRD;\n                if (instr.atype.rs2 != 0) illegal_instr = 1'b1;\n              end\n              5'h3: instruction_o.op = ariane_pkg::AMO_SCD;\n              5'h4: instruction_o.op = ariane_pkg::AMO_XORD;\n              5'h8: instruction_o.op = ariane_pkg::AMO_ORD;\n              5'hC: instruction_o.op = ariane_pkg::AMO_ANDD;\n              5'h10: instruction_o.op = ariane_pkg::AMO_MIND;\n              5'h14: instruction_o.op = ariane_pkg::AMO_MAXD;\n              5'h18: instruction_o.op = ariane_pkg::AMO_MINDU;\n              5'h1C: instruction_o.op = ariane_pkg::AMO_MAXDU;\n              default: illegal_instr = 1'b1;\n            endcase\n          end else begin\n            illegal_instr = 1'b1;\n          end\n        end\n\n        // --------------------------------\n        // Control Flow Instructions\n        // --------------------------------\n        riscv::OpcodeBranch: begin\n          imm_select              = SBIMM;\n          instruction_o.fu        = CTRL_FLOW;\n          instruction_o.rs1[4:0]  = instr.stype.rs1;\n          instruction_o.rs2[4:0]  = instr.stype.rs2;\n\n          is_control_flow_instr_o = 1'b1;\n\n          case "}
{"text": "(instr.stype.funct3)\n            3'b000: instruction_o.op = ariane_pkg::EQ;\n            3'b001: instruction_o.op = ariane_pkg::NE;\n            3'b100: instruction_o.op = ariane_pkg::LTS;\n            3'b101: instruction_o.op = ariane_pkg::GES;\n            3'b110: instruction_o.op = ariane_pkg::LTU;\n            3'b111: instruction_o.op = ariane_pkg::GEU;\n            default: begin\n              is_control_flow_instr_o = 1'b0;\n              illegal_instr           = 1'b1;\n            end\n          endcase\n        end\n        // Jump and link register\n        riscv::OpcodeJalr: begin\n          instruction_o.fu        = CTRL_FLOW;\n          instruction_o.op        = ariane_pkg::JALR;\n          instruction_o.rs1[4:0]  = instr.itype.rs1;\n          imm_select              = IIMM;\n          instruction_o.rd[4:0]   = instr.itype.rd;\n          is_control_flow_instr_o = 1'b1;\n          // invalid jump and link register -> reserved for vector encoding\n          if (instr.itype.funct3 != 3'b0) illegal_instr = 1'b1;\n        end\n        // Jump and link\n        riscv::OpcodeJal: begin\n          instruction_o.fu        = CTRL_FLOW;\n          imm_select              = JIMM;\n          instruction_o.rd[4:0]   = instr.utype.rd;\n          is_control_flow_instr_o = 1'b1;\n        end\n\n        riscv::OpcodeAuipc: begin\n          instruction_o.fu      = ALU;\n          imm_select            = UIMM;\n          instruction_o.use_pc  = 1'b1;\n          instruction_o.rd[4:0] = instr.utype.rd;\n        end\n\n        riscv::OpcodeLui: begin\n          imm_select            = UIMM;\n          instruction_o.fu      = ALU;\n          instruction_o.rd[4:0] = instr.utype.rd;\n        end\n\n        default: illegal_instr = 1'b1;\n      endcase\n    end\n    if (CVA6Cfg.CvxifEn) begin\n      if (is_illegal_i || illegal_instr) begin\n        instruction_o.fu       = CVXIF;\n        instruction_o.rs1[4:0] = instr.r4type.rs1;\n        instruction_o.rs2[4:0] = instr.r4type.rs2;\n        instruction_o.rd[4:0]  = instr.r4type.rd;\n        instruction_o.op       = ariane_pkg::OFFLOAD;\n        imm_select             = RS3;\n      end\n    end\n\n    // Accelerator instructions.\n    // These can overwrite the previous decoding entirely.\n    if (CVA6Cfg.EnableAccelerator) begin // only generate decoder if accelerators are enabled (static)\n      if (is_accel) begin\n        instruction_o.fu        = acc_instruction.fu;\n        instruction_o.vfp       = acc_instruction.vfp;\n        instruction_o.rs1       = acc_instruction.rs1;\n        instruction_o.rs2       = acc_instruction.rs2;\n        instruction_o.rd        = acc_instruction.rd;\n        instruction_o.op        = acc_instruction.op;\n        illegal_instr           = acc_illegal_instr;\n        is_control_flow_instr_o = acc_is_control_flow_instr;\n      end\n    end\n  end\n\n  // --------------------------------\n  // Sign extend immediate\n  // --------------------------------\n  always_comb begin : sign_extend\n    imm_i_type = {{riscv::XLEN - 12{instruction_i[31]}}, instruction_i[31:20]};\n    imm_s_type = {{riscv::XLEN - 12{instruction_i[31]}}, instruction_i[31:25], instruction_i[11:7]};\n    imm_sb_type = {\n      {riscv::XLEN - 13{instruction_i[31]}},\n      instruction_i[31],\n      instruction_i[7],\n      instruction_i[30:25],\n      instruction_i[11:8],\n      1'b0\n    };\n    imm_u_type = {\n      {riscv::XLEN - 32{instruction_i[31]}}, instruction_i[31:12], 12'b0\n    };  // JAL, AUIPC, sign extended to 64 bit\n    imm_uj_type = {\n      {riscv::XLEN - 20{instruction_i[31]}},\n      instruction_i[19:12],\n      instruction_i[20],\n      instruction_i[30:21],\n      1'b0\n    };\n    imm_bi_type = {{riscv::XLEN - 5{instruction_i[24]}}, instruction_i[24:20]};\n\n    // NOIMM, IIMM, SIMM, BIMM, UIMM, JIMM, RS3\n    // select immediate\n    case (imm_select)\n      IIMM: begin\n        instruction_o.result  = imm_i_type;\n        instruction_o.use_imm = 1'b1;\n      end\n      SIMM: begin\n        instruction_o.result  = imm_s_type;\n        instruction_o.use_imm = 1'b1;\n      end\n      SBIMM: begin\n        instruction_o.result  = imm_sb_type;\n        instruction_o.use_imm = 1'b1;\n      end\n      UIMM: begin\n        instruction_o.result  = imm_u_type;\n        instruction_o.use_imm = 1'b1;\n      end\n      JIMM: begin\n        instruction_o.result  = imm_uj_type;\n        instruction_o.use_imm = 1'b1;\n      end\n      RS3: begin\n        // result holds address of fp operand rs3\n        instruction_o.result  = {{riscv::XLEN - 5{1'b0}}, instr.r4type.rs3};\n        instruction_o.use_imm = 1'b0;\n      end\n      default: begin\n        instruction_o.result  = {riscv::XLEN{1'b0}};\n        instruction_o.use_imm = 1'b0;\n      end\n    endcase\n\n    if (CVA6Cfg.EnableAccelerator) begin\n      if (is_accel) begin\n        instruction_o.result  = acc_instruction.result;\n        instruction_o.use_imm = acc_instruction.use_imm;\n      end\n    end\n  end\n\n  // ---------------------\n  // Exception handling\n  // ---------------------\n  riscv::xlen_t interrupt_cause;\n\n  // this instruction has already executed if the exception is valid\n  assign instruction_o.valid = instruction_o.ex.valid;\n\n  always_comb begin : exception_handling\n    interrupt_cause = '0;\n    instruction_o.ex = ex_i;\n    orig_instr_o = '0;\n    // look if we didn't already get an exception in any previous\n    // stage - we should not overwrite it as we retain order regarding the exception\n    if (~ex_i.valid) begin\n      // if we didn't already get an exception save the instruction here as we may need it\n      // in the commit stage if we got a access exception to one of the CSR registers\n      if (CVA6Cfg.CvxifEn || CVA6Cfg.FpuEn)\n        orig_instr_o = (is_compressed_i) ? {{riscv::XLEN-16{1'b0}}, compressed_instr_i} : {{riscv::XLEN-32{1'b0}}, instruction_i};\n      if (CVA6Cfg.TvalEn)\n        instruction_o.ex.tval  = (is_compressed_i) ? {{riscv::XLEN-16{1'b0}}, compressed_instr_i} : {{riscv::XLEN-32{1'b0}}, instruction_i};\n      else instruction_o.ex.tval = '0;\n      // instructions which will throw an exception are marked as valid\n      // e.g.: they can be committed anytime and do not need to wait for any functional unit\n      // check here if we decoded an invalid instruction or if the compressed decoder already decoded\n      // a invalid instruction\n      if (illegal_instr || is_illegal_i) begin\n        if (!CVA6Cfg.CvxifEn) instruction_o.ex.valid = 1'b1;\n        // we decoded an illegal exception here\n        instruction_o.ex.cause = riscv::ILLEGAL_INSTR;\n        // we got an ecall, set the correct cause depending on the current privilege level\n      end else if (ecall) begin\n        // this exception is valid\n        instruction_o.ex.valid = 1'b1;\n        // depending on the privilege mode, set the appropriate cause\n        if (priv_lvl_i == riscv::PRIV_LVL_S && CVA6Cfg.RVS) begin\n          instruction_o.ex.cause = riscv::ENV_CALL_SMODE;\n        end else if (priv_lvl_i == riscv::PRIV_LVL_U && CVA6Cfg.RVU) begin\n          instruction_o.ex.cause = riscv::ENV_CALL_UMODE;\n        end else if (priv_lvl_i == riscv::PRIV_LVL_M) begin\n          instruction_o.ex.cause = riscv::ENV_CALL_MMODE;\n        end\n      end else if (ebreak) begin\n        // this exception is valid\n        instruction_o.ex.valid = 1'b1;\n        // set breakpoint cause\n        instruction_o.ex.cause = riscv::BREAKPOINT;\n      end\n      // -----------------\n      // Interrupt Control\n      // -----------------\n      // we decode an interrupt the same as an exception, hence it will be taken if the instruction did not\n      // throw any previous exception.\n      // we have three interrupt sources: external interrupts, software interrupts, timer interrupts (order of precedence)\n      // for two privilege levels: Supervisor and Machine Mode\n      // Supervisor Timer Interrupt\n      if (irq_ctrl_i.mie[riscv::IRQ_S_TIMER] && irq_ctrl_i.mip[riscv::IRQ_S_TIMER]) begin\n        interrupt_cause = riscv::S_TIMER_INTERRUPT;\n      end\n      // Supervisor Software Interrupt\n      if (irq_ctrl_i.mie[riscv::IRQ_S_SOFT] && irq_ctrl_i.mip[riscv::IRQ_S_SOFT]) begin\n        interrupt_cause = riscv::S_SW_INTERRUPT;\n      end\n      // Supervisor External Interrupt\n      // The logical-OR of the software-writable bit and the signal from the external interrupt controller is\n      // used to generate external interrupts to the supervisor\n      if (irq_ctrl_i.mie[riscv::IRQ_S_EXT] && (irq_ctrl_i.mip[riscv::IRQ_S_EXT] | irq_i[ariane_pkg::SupervisorIrq])) begin\n        interrupt_cause = riscv::S_EXT_INTERRUPT;\n      end\n      // Machine Timer Interrupt\n      if (irq_ctrl_i.mip[riscv::IRQ_M_TIMER] && irq_ctrl_i.mie[riscv::IRQ_M_TIMER]) begin\n        interrupt_cause = riscv::M_TIMER_INTERRUPT;\n      end\n      // Machine Mode Software Interrupt\n      if (irq_ctrl_i.mip[riscv::IRQ_M_SOFT] && irq_ctrl_i.mie[riscv::IRQ_M_SOFT]) begin\n        interrupt_cause = riscv::M_SW_INTERRUPT;\n      end\n      // Machine Mode External Interrupt\n      if (irq_ctrl_i.mip[riscv::IRQ_M_EXT] && irq_ctrl_i.mie[riscv::IRQ_M_EXT]) begin\n        interrupt_cause = riscv::M_EXT_INTERRUPT;\n      end\n\n      if (interrupt_cause[riscv::XLEN-1] && irq_ctrl_i.global_enable) begin\n        // However, if bit i in mideleg is set, interrupts are considered to be globally enabled if the hart\u2019s current privilege\n        // mode equals the delegated privilege mode (S or U) and that mode\u2019s interrupt enable bit\n        // (SIE or UIE in mstatus) is set, or if the current privilege mode is less than the delegated privilege mode.\n        if (irq_ctrl_i.mideleg[interrupt_cause[$clog2(riscv::XLEN)-1:0]]) begin\n          if ((CVA6Cfg.RVS && irq_ctrl_i.sie && priv_lvl_i == riscv::PRIV_LVL_S) || (CVA6Cfg.RVU && priv_lvl_i == riscv::PRIV_LVL_U)) begin\n            instruction_o.ex.valid = 1'b1;\n            instruction_o.ex.cause = interrupt_cause;\n          end\n        end else begin\n          instruction_o.ex.valid = 1'b1;\n          instruction_o.ex.cause = interrupt_cause;\n        end\n      end\n    end\n\n    // a debug request has precendece over everything else\n    if (CVA6Cfg.DebugEn && debug_req_i && !debug_mode_i) begin\n      instruction_o.ex.valid = 1'b1;\n      instruction_o.ex.cause = riscv::DEBUG_REQUEST;\n    end\n  end\nendmodule\n"}
{"text": "\n// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 19.04.2017\n// Description: Instantiation of all functional units residing in the execute stage\n\n\nmodule ex_stage\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int unsigned ASID_WIDTH = 1\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Fetch flush request - CONTROLLER\n    input logic flush_i,\n    // Debug mode is enabled - CSR_REGFILE\n    input logic debug_mode_i,\n    // rs1 forwarding - ISSUE_STAGE\n    input logic [riscv::VLEN-1:0] rs1_forwarding_i,\n    // rs2 forwarding - ISSUE_STAGE\n    input logic [riscv::VLEN-1:0] rs2_forwarding_i,\n    // FU data useful to execute instruction - ISSUE_STAGE\n    input fu_data_t fu_data_i,\n    // PC of the current instruction - ISSUE_STAGE\n    input logic [riscv::VLEN-1:0] pc_i,\n    // Report whether isntruction is compressed - ISSUE_STAGE\n    input logic is_compressed_instr_i,\n    // Fixed Latency Unit result - ISSUE_STAGE\n    output riscv::xlen_t flu_result_o,\n    // ID of the scoreboard entry at which a=to write back - ISSUE_STAGE\n    output logic [TRANS_ID_BITS-1:0] flu_trans_id_o,\n    // Fixed Latency Unit exception - ISSUE_STAGE\n    output exception_t flu_exception_o,\n    // FLU is ready - ISSUE_STAGE\n    output logic flu_ready_o,\n    // FLU result is valid - ISSUE_STAGE\n    output logic flu_valid_o,\n    // ALU instruction is valid - ISSUE_STAGE\n    input logic alu_valid_i,\n    // Branch unit instruction is valid - ISSUE_STAGE\n    input logic branch_valid_i,\n    // Information of branch prediction - ISSUE_STAGE\n    input branchpredict_sbe_t branch_predict_i,\n    // The branch engine uses the write back from the ALU - several_modules\n    output bp_resolve_t resolved_branch_o,\n    // Signaling that we resolved the branch - ISSUE_STAGE\n    output logic resolve_branch_o,\n    // CSR instruction is valid - ISSUE_STAGE\n    input logic csr_valid_i,\n    // CSR address to write - COMMIT_STAGE\n    output logic [11:0] csr_addr_o,\n    // CSR commit - COMMIT_STAGE\n    input logic csr_commit_i,\n    // MULT instruction is valid - ISSUE_STAGE\n    input logic mult_valid_i,\n    // LSU is ready - ISSUE_STAGE\n    output logic lsu_ready_o,\n    // LSU instruction is valid - ISSUE_STAGE\n    input logic lsu_valid_i,\n    // Load result is valid - ISSUE_STAGE\n    output logic load_valid_o,\n    // Load result valid - ISSUE_STAGE\n    output riscv::xlen_t load_result_o,\n    // Load instruction ID - ISSUE_STAGE\n    output logic [TRANS_ID_BITS-1:0] load_trans_id_o,\n    // Exception generated by load instruction - ISSUE_STAGE\n    output exception_t load_exception_o,\n    // Store result is valid - ISSUe_STAGE\n    output logic store_valid_o,\n    // Store result - ISSUE_STAGE\n    output riscv::xlen_t store_result_o,\n    // Store instruction ID - ISSUE_STAGE\n    output logic [TRANS_ID_BITS-1:0] store_trans_id_o,\n    // Exception generated by store instruction - ISSUE_STAGE\n    output exception_t store_exception_o,\n    // LSU commit - COMMIT_STAGE\n    input logic lsu_commit_i,\n    // Commit queue ready to accept another commit request - COMMIT_STAGE\n    output logic lsu_commit_ready_o,\n    // Commit transaction ID - COMMIT_STAGE\n    input logic [TRANS_ID_BITS-1:0] commit_tran_id_i,\n    // TO_BE_COMPLETED - ACC_DISPATCHER\n    input logic stall_st_pending_i,\n    // TO_BE_COMPLETED - COMMIT_STAGE\n    output logic no_st_pending_o,\n    // Atomic result is valid - COMMIT_STAGE\n    input logic amo_valid_commit_i,\n    // FU is ready - ISSUE_STAGE\n    output logic fpu_ready_o,\n    // FPU instruction is ready - ISSUE_STAGE\n    input logic fpu_valid_i,\n    // FPU format - ISSUE_STAGE\n    input logic [1:0] fpu_fmt_i,\n    // FPU rm - ISSUE_STAGE\n    input logic [2:0] fpu_rm_i,\n    // FPU frm - ISSUE_STAGE\n    input logic [2:0] fpu_frm_i,\n    // FPU precision control - CSR_REGFILE\n    input logic [6:0] fpu_prec_i,\n    // FPU transaction ID - ISSUE_STAGE\n    output logic [TRANS_ID_BITS-1:0] fpu_trans_id_o,\n    // FPU result - ISSUE_STAGE\n    output riscv::xlen_t fpu_result_o,\n    // FPU valid - ISSUE_STAGE\n    output logic fpu_valid_o,\n    // FPU exception - ISSUE_STAGE\n    output exception_t fpu_exception_o,\n    // CVXIF instruction is valid - ISSUE_STAGE\n    input logic x_valid_i,\n    // CVXIF is ready - ISSUE_STAGE\n    output logic x_ready_o,\n    // undecoded instruction - ISSUE_STAGE\n    input logic [31:0] x_off_instr_i,\n    // CVXIF transaction ID - ISSUE_STAGE\n    output logic [TRANS_ID_BITS-1:0] x_trans_id_o,\n    // CVXIF exception - ISSUE_STAGE\n    output exception_t x_exception_o,\n    // CVXIF result - ISSUE_STAGE\n    output riscv::xlen_t x_result_o,\n    // CVXIF result valid - ISSUE_STAGE\n    output logic x_valid_o,\n    // CVXIF write enable - ISSUE_STAGE\n    output logic x_we_o,\n    // CVXIF request - SUBSYSTEM\n    output cvxif_pkg::cvxif_req_t cvxif_req_o,\n    // CVXIF response - SUBSYSTEM\n    input cvxif_pkg::cvxif_resp_t cvxif_resp_i,\n    // accelerate port result is valid - ACC_DISPATCHER\n    input logic acc_valid_i,\n    // Enable virtual memory translation - CSR_REGFILE\n    input logic enable_translation_i,\n    // Enable virtual memory translation for load/stores - CSR_REGFILE\n    input logic en_ld_st_translation_i,\n    // Flush TLB - CONTROLLER\n    input logic flush_tlb_i,\n    // Privilege mode - CSR_REGFILE\n    input riscv::priv_lvl_t priv_lvl_i,\n    // Privilege level at which load and stores should happen - CSR_REGFILE\n    input riscv::priv_lvl_t ld_st_priv_lvl_i,\n    // Supervisor user memory - CSR_REGFILE\n    input logic sum_i,\n    // Make executable readable - CSR_REGFILE\n    input logic mxr_i,\n    // TO_BE_COMPLETED - CSR_REGFILE\n    input logic [riscv::PPNW-1:0] satp_ppn_i,\n    // TO_BE_COMPLETED - CSR_REGFILE\n    input logic [ASID_WIDTH-1:0] asid_i,\n    // icache translation response - CACHE\n    input icache_arsp_t icache_areq_i,\n    // icache translation request - CACHE\n    output icache_areq_t icache_areq_o,\n    // Data cache request ouput - CACHE\n    input dcache_req_o_t [2:0] dcache_req_ports_i,\n    // Data cache request input - CACHE\n    output dcache_req_i_t [2:0] dcache_req_ports_o,\n    // Write buffer is empty - CACHE\n    input logic dcache_wbuffer_empty_i,\n    // TO_BE_COMPLETED - CACHE\n    input logic dcache_wbuffer_not_ni_i,\n    // AMO request - CACHE\n    output amo_req_t amo_req_o,\n    // AMO response - CACHE\n    input amo_resp_t amo_resp_i,\n    // To count the instruction TLB misses - PERF_COUNTERS\n    output logic itlb_miss_o,\n    // To count the data TLB misses - PERF_COUNTERS\n    output logic dtlb_miss_o,\n    // Report the PMP configuration - CSR_REGFILE\n    input riscv::pmpcfg_t [15:0] pmpcfg_i,\n    // Report the PMP addresses - CSR_REGFILE\n    input logic [15:0][riscv::PLEN-3:0] pmpaddr_i,\n    // Information dedicated to RVFI - RVFI\n    output lsu_ctrl_t rvfi_lsu_ctrl_o,\n    // Information dedicated to RVFI - RVFI\n    output [riscv::PLEN-1:0] rvfi_mem_paddr_o\n);\n\n  // -------------------------\n  // Fixed Latency Units\n  // -------------------------\n  // all fixed latency units share a single issue port and a sing write\n  // port into the scoreboard. At the moment those are:\n  // 1. ALU - all operations are single cycle\n  // 2. Branch unit: operation is single cycle, the ALU is needed\n  //    for comparison\n  // 3. CSR: This is a small buffer which saves the address of the CSR.\n  //    The value is then re-fetched once the instruction retires. The buffer\n  //    is only a single entry deep, hence this operation will block all\n  //    other operations once this buffer is full. This should not be a major\n  //    concern though as CSRs are infrequent.\n  // 4. Multiplier/Divider: The multiplier has a fixed latency of 1 cycle.\n  //                        The issue logic will take care of not issuing\n  //                        another instruction if it will collide on the\n  //                        output port. Divisions are arbitrary in length\n  //                        they will simply block the issue of all other\n  //                        instructions.\n\n\n  logic current_instruction_is_sfence_vma;\n  // These two register store the rs1 and rs2 parameters in case of `SFENCE_VMA`\n  // instruction to be used for TLB flush in the next clock cycle.\n  logic [ASID_WIDTH-1:0] asid_to_be_flushed;\n  logic [riscv::VLEN-1:0] vaddr_to_be_flushed;\n\n  // from ALU to branch unit\n  logic alu_branch_res;  // branch comparison result\n  riscv::xlen_t alu_result, csr_result, mult_result;\n  logic [riscv::VLEN-1:0] branch_result;\n  logic csr_ready, mult_ready;\n  logic [TRANS_ID_BITS-1:0] mult_trans_id;\n  logic mult_valid;\n\n  // 1. ALU (combinatorial)\n  // data silence operation\n  fu_data_t alu_data;\n  assign alu_data = (alu_valid_i | branch_valid_i) ? fu_data_i : '0;\n\n  alu #(\n      .CVA6Cfg(CVA6Cfg)\n  ) alu_i (\n      .clk_i,\n      .rst_ni,\n      .fu_data_i       (alu_data),\n      .result_o        (alu_result),\n      .alu_branch_res_o(alu_branch_res)\n  );\n\n  // 2. Branch Unit (combinatorial)\n  // we don't silence the branch unit as this is already critical and we do\n  // not want to add another layer of logic\n  branch_unit #(\n      .CVA6Cfg(CVA6Cfg)\n  ) branch_unit_i (\n      .clk_i,\n      .rst_ni,\n      .debug_mode_i,\n      .fu_data_i,\n      .pc_i,\n      .is_compressed_instr_i,\n      // any functional unit is valid, check that there is no accidental mis-predict\n      .fu_valid_i ( alu_valid_i || lsu_valid_i || csr_valid_i || mult_valid_i || fpu_valid_i || acc_valid_i ) ,\n      .branch_valid_i,\n      .branch_comp_res_i(alu_branch_res),\n      .branch_result_o(branch_result),\n      .branch_predict_i,\n      .resolved_branch_o,\n      .resolve_branch_o,\n      .branch_exception_o(flu_exception_o)\n  );\n\n  // 3. CSR (sequential)\n  csr_buffer #(\n      .CVA6Cfg(CVA6Cfg)\n  ) csr_buffer_i (\n      .clk_i,\n      .rst_ni,\n      .flush_i,\n      .fu_data_i,\n      .csr_valid_i,\n      .csr_ready_o (csr_ready),\n      .csr_result_o(csr_result),\n      .csr_commit_i,\n      .csr_addr_o\n  );\n\n  assign flu_valid_o = alu_valid_i | branch_valid_i | csr_valid_i | mult_valid;\n\n  // result MUX\n  always_comb begin\n    // Branch result as default case\n    flu_result_o   = {{riscv::XLEN - riscv::VLEN{1'b0}}, branch_result};\n    flu_trans_id_o = fu_data_i.trans_id;\n    // ALU result\n    if (alu_valid_i) begin\n      flu_result_o = alu_result;\n      // CSR result\n    end else if (csr_valid_i) begin\n      flu_result_o = csr_result;\n    end else if (mult_valid) begin\n      flu_result_o   = mult_result;\n      flu_trans_id_o = mult_trans_id;\n    end\n  end\n\n  // ready flags for FLU\n  always_comb begin\n    flu_ready_o = csr_ready & mult_ready;\n  end\n\n  // 4. Multiplication (Sequential)\n  fu_data_t mult_data;\n  // input silencing of multiplier\n  assign mult_data = mult_valid_i ? fu_data_i : '0;\n\n  mult #(\n      .CVA6Cfg(CVA6Cfg)\n  ) i_mult (\n      .clk_i,\n      .rst_ni,\n      .flush_i,\n      .mult_valid_i,\n      .fu_data_i      (mult_data),\n      .result_o       (mult_result),\n      .mult_valid_o   (mult_valid),\n      .mult_ready_o   (mult_ready),\n      .mult_trans_id_o(mult_trans_id)\n  );\n\n  // ----------------\n  // FPU\n  // ----------------\n  generate\n    if (CVA6Cfg.FpPresent) begin : fpu_gen\n      fu_data_t fpu_data;\n      assign fpu_data = fpu_valid_i ? fu_data_i : '0;\n\n      fpu_wrap #(\n          .CVA6Cfg(CVA6Cfg)\n      ) fpu_i (\n          .clk_i,\n          .rst_ni,\n          .flush_i,\n          .fpu_valid_i,\n          .fpu_ready_o,\n          .fu_data_i(fpu_data),\n          .fpu_fmt_i,\n          .fpu_rm_i,\n          .fpu_frm_i,\n          .fpu_prec_i,\n          .fpu_trans_id_o,\n          .result_o (fpu_result_o),\n          .fpu_valid_o,\n          .fpu_exception_o\n      );\n    end else begin : no_fpu_gen\n      assign fpu_ready_o     = '0;\n      assign fpu_trans_id_o  = '0;\n      assign fpu_result_o    = '0;\n      assign fpu_valid_o     = '0;\n      assign fpu_exception_o = '0;\n    end\n  endgenerate\n\n  // ----------------\n  // Load-Store Unit\n  // ----------------\n  fu_data_t lsu_data;\n\n  assign lsu_data = lsu_valid_i ? fu_data_i : '0;\n\n  load_store_unit #(\n      .CVA6Cfg   (CVA6Cfg),\n      .ASID_WIDTH(ASID_WIDTH)\n  ) lsu_i (\n      .clk_i,\n      .rst_ni,\n      .flush_i,\n      .stall_st_pending_i,\n      .no_st_pending_o,\n      .fu_data_i            (lsu_data),\n      .lsu_ready_o,\n      .lsu_valid_i,\n      .load_trans_id_o,\n      .load_result_o,\n      .load_valid_o,\n      .load_exception_o,\n      .store_trans_id_o,\n      .store_result_o,\n      .store_valid_o,\n      .store_exception_o,\n      .commit_i             (lsu_commit_i),\n      .commit_ready_o       (lsu_commit_ready_o),\n      .commit_tran_id_i,\n      .enable_translation_i,\n      .en_ld_st_translation_i,\n      .icache_areq_i,\n      .icache_areq_o,\n      .priv_lvl_i,\n      .ld_st_priv_lvl_i,\n      .sum_i,\n      .mxr_i,\n      .satp_ppn_i,\n      .asid_i,\n      .asid_to_be_flushed_i (asid_to_be_flushed),\n      .vaddr_to_be_flushed_i(vaddr_to_be_flushed),\n      .flush_tlb_i,\n      .itlb_miss_o,\n      .dtlb_miss_o,\n      .dcache_req_ports_i,\n      .dcache_req_ports_o,\n      .dcache_wbuffer_empty_i,\n      .dcache_wbuffer_not_ni_i,\n      .amo_valid_commit_i,\n      .amo_req_o,\n      .amo_resp_i,\n      .pmpcfg_i,\n      .pmpaddr_i,\n      .rvfi_lsu_ctrl_o,\n      .rvfi_mem_paddr_o\n  );\n\n  if (CVA6Cfg.CvxifEn) begin : gen_cvxif\n    fu_data_t cvxif_data;\n    assign cvxif_data = x_valid_i ? fu_data_i : '0;\n    cvxif_fu #(\n        .CVA6Cfg(CVA6Cfg)\n    ) cvxif_fu_i (\n        .clk_i,\n        .rst_ni,\n        .fu_data_i,\n        .priv_lvl_i(ld_st_priv_lvl_i),\n        .x_valid_i,\n        .x_ready_o,\n        .x_off_instr_i,\n        .x_trans_id_o,\n        .x_exception_o,\n        .x_result_o,\n        .x_valid_o,\n        .x_we_o,\n        .cvxif_req_o,\n        .cvxif_resp_i\n    );\n  end else begin : gen_no_cvxif\n    assign cvxif_req_o   = '0;\n    assign x_trans_id_o  = '0;\n    assign x_exception_o = '0;\n    assign x_result_o    = '0;\n    assign x_valid_o     = '0;\n  end\n\n  if (CVA6Cfg.RVS) begin\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (~rst_ni) begin\n        current_instruction_is_sfence_vma <= 1'b0;\n      end else begin\n        if (flush_i) begin\n          current_instruction_is_sfence_vma <= 1'b0;\n        end else if ((fu_data_i.operation == SFENCE_VMA) && csr_valid_i) begin\n          current_instruction_is_sfence_vma <= 1'b1;\n        end\n      end\n    end\n\n    // This process stores the rs1 and rs2 parameters of a SFENCE_VMA instruction.\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (~rst_ni) begin\n        asid_to_be_flushed  <= '0;\n        vaddr_to_be_flushed <= '0;\n        // if the current instruction in EX_STAGE is a sfence.vma, in the next cycle no writes will happen\n      end else if ((~current_instruction_is_sfence_vma) && (~((fu_data_i.operation == SFENCE_VMA) && csr_valid_i))) begin\n        vaddr_to_be_flushed <= rs1_forwarding_i;\n        asid_to_be_flushed  <= rs2_forwarding_i[ASID_WIDTH-1:0];\n      end\n    end\n  end else begin\n    assign current_instruction_is_sfence_vma = 1'b0;\n    assign asid_to_be_flushed                = '0;\n    assign vaddr_to_be_flushed               = '0;\n  end\n\nendmodule\n"}
{"text": "// Copyright (c) 2018 ETH Zurich, University of Bologna\n// All rights reserved.\n//\n// This code is under development and not yet released to the public.\n// Until it is released, the code is under the copyright of ETH Zurich and\n// the University of Bologna, and may contain confidential and/or unpublished\n// work. Any reuse/redistribution is strictly forbidden without written\n// permission from ETH Zurich.\n//\n// Bug fixes and contributions will eventually be released under the\n// SolderPad open hardware license in the context of the PULP platform\n// (http://www.pulp-platform.org), under the copyright of ETH Zurich and the\n// University of Bologna.\n\n\n/// A leading-one finder / leading zero counter.\n/// Set FLIP to 0 for find_first_one => first_one_o is the index of the first one (from the LSB)\n/// Set FLIP to 1 for leading zero counter => first_one_o is the number of leading zeroes (from the MSB)\nmodule find_first_one #(\n    /// The width of the input vector.\n    parameter int WIDTH = -1,\n    parameter int FLIP = 0\n)(\n    input  logic [WIDTH-1:0]         in_i,\n    output logic [$clog2(WIDTH)-1:0] first_one_o,\n    output logic                     no_ones_o\n);\n\n    localparam int NUM_LEVELS = $clog2(WIDTH);\n\n    // pragma translate_off\n    initial begin\n        assert(WIDTH >= 0);\n    end\n    // pragma translate_on\n\n    logic [WIDTH-1:0][NUM_LEVELS-1:0]          index_lut;\n    logic [2**NUM_LEVELS-1:0]                  sel_nodes;\n    logic [2**NUM_LEVELS-1:0][NUM_LEVELS-1:0]  index_nodes;\n\n    logic [WIDTH-1:0] in_tmp;\n\n    for (genvar i = 0; i < WIDTH; i++) begin\n        assign in_tmp[i] = FLIP ? in_i[WIDTH-1-i] : in_i[i];\n    end\n\n    for (genvar j = 0; j < WIDTH; j++) begin\n        assign index_lut[j] = j;\n    end\n\n    for (genvar level = 0; level < NUM_LEVELS; level++) begin\n\n        if (level < NUM_LEVELS-1) begin\n            for (genvar l = 0; l < 2**level; l++) begin\n                assign sel_nodes[2**level-1+l]   = sel_nodes[2**(level+1)-1+l*2] | sel_nodes[2**(level+1)-1+l*2+1];\n                assign index_nodes[2**level-1+l] = (sel_nodes[2**(level+1)-1+l*2] == 1'b1) ?\n                    index_nodes[2**(level+1)-1+l*2] : index_nodes[2**(level+1)-1+l*2+1];\n            end\n        end\n\n        if (level == NUM_LEVELS-1) begin\n            for (genvar k = 0; k < 2**level; k++) begin\n                // if two successive indices are still in the vector...\n                if (k * 2 < WIDTH-1) begin\n                    assign sel_nodes[2**level-1+k]   = in_tmp[k*2] | in_tmp[k*2+1];\n                    assign index_nodes[2**level-1+k] = (in_tmp[k*2] == 1'b1) ? index_lut[k*2] : index_lut[k*2+1];\n                end\n                // if only the first index is still in the vector...\n                if (k * 2 == WIDTH-1) begin\n                    assign sel_nodes[2**level-1+k]   = in_tmp[k*2];\n                    assign index_nodes[2**level-1+k] = index_lut[k*2];\n                end\n                // if index is out of range\n                if (k * 2 > WIDTH-1) begin\n                    assign sel_nodes[2**level-1+k]   = 1'b0;\n                    assign index_nodes[2**level-1+k] = '0;\n                end\n            end\n        end\n    end\n\n    assign first_one_o = NUM_LEVELS > 0 ? index_nodes[0] : '0;\n    assign no_ones_o   = NUM_LEVELS > 0 ? ~sel_nodes[0]  : '1;\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Stefan Mach, ETH Zurich\n// Date: 12.04.2018\n// Description: Wrapper for the floating-point unit\n\n\nmodule fpu_wrap\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    input  logic     clk_i,\n    input  logic     rst_ni,\n    input  logic     flush_i,\n    input  logic     fpu_valid_i,\n    output logic     fpu_ready_o,\n    input  fu_data_t fu_data_i,\n\n    input  logic       [              1:0] fpu_fmt_i,\n    input  logic       [              2:0] fpu_rm_i,\n    input  logic       [              2:0] fpu_frm_i,\n    input  logic       [              6:0] fpu_prec_i,\n    output logic       [TRANS_ID_BITS-1:0] fpu_trans_id_o,\n    output logic       [ CVA6Cfg.FLen-1:0] result_o,\n    output logic                           fpu_valid_o,\n    output exception_t                     fpu_exception_o\n);\n\n  // this is a workaround\n  // otherwise compilation might issue an error if FLEN=0\n  enum logic {\n    READY,\n    STALL\n  }\n      state_q, state_d;\n  if (CVA6Cfg.FpPresent) begin : fpu_gen\n    logic [CVA6Cfg.FLen-1:0] operand_a_i;\n    logic [CVA6Cfg.FLen-1:0] operand_b_i;\n    logic [CVA6Cfg.FLen-1:0] operand_c_i;\n    assign operand_a_i = fu_data_i.operand_a[CVA6Cfg.FLen-1:0];\n    assign operand_b_i = fu_data_i.operand_b[CVA6Cfg.FLen-1:0];\n    assign operand_c_i = fu_data_i.imm[CVA6Cfg.FLen-1:0];\n\n    //-----------------------------------\n    // FPnew config from FPnew package\n    //-----------------------------------\n    localparam OPBITS = fpnew_pkg::OP_BITS;\n    localparam FMTBITS = $clog2(fpnew_pkg::NUM_FP_FORMATS);\n    localparam IFMTBITS = $clog2(fpnew_pkg::NUM_INT_FORMATS);\n\n    // Features (enabled formats, vectors etc.)\n    localparam fpnew_pkg::fpu_features_t FPU_FEATURES = '{\n        Width: unsigned'(riscv::XLEN),  // parameterized using XLEN\n        EnableVectors: CVA6Cfg.XFVec,\n        EnableNanBox: 1'b1,\n        FpFmtMask: {CVA6Cfg.RVF, CVA6Cfg.RVD, CVA6Cfg.XF16, CVA6Cfg.XF8, CVA6Cfg.XF16ALT},\n        IntFmtMask: {\n          CVA6Cfg.XFVec && CVA6Cfg.XF8,\n          CVA6Cfg.XFVec && (CVA6Cfg.XF16 || CVA6Cfg.XF16ALT),\n          1'b1,\n          1'b1\n        }\n    };\n\n    // Implementation (number of registers etc)\n    localparam fpnew_pkg::fpu_implementation_t FPU_IMPLEMENTATION = '{\n        PipeRegs: '{  // FP32, FP64, FP16, FP8, FP16alt\n            '{\n                unsigned'(LAT_COMP_FP32),\n                unsigned'(LAT_COMP_FP64),\n                unsigned'(LAT_COMP_FP16),\n                unsigned'(LAT_COMP_FP8),\n                unsigned'(LAT_COMP_FP16ALT)\n            },  // ADDMUL\n            '{default: unsigned'(LAT_DIVSQRT)},  // DIVSQRT\n            '{default: unsigned'(LAT_NONCOMP)},  // NONCOMP\n            '{default: unsigned'(LAT_CONV)}\n        },  // CONV\n        UnitTypes: '{\n            '{default: fpnew_pkg::PARALLEL},  // ADDMUL\n            '{default: fpnew_pkg::MERGED},  // DIVSQRT\n            '{default: fpnew_pkg::PARALLEL},  // NONCOMP\n            '{default: fpnew_pkg::MERGED}\n        },  // CONV\n        PipeConfig: fpnew_pkg::DISTRIBUTED\n    };\n\n    //-------------------------------------------------\n    // Inputs to the FPU and protocol inversion buffer\n    //-------------------------------------------------\n    logic [CVA6Cfg.FLen-1:0] operand_a_d, operand_a_q, operand_a;\n    logic [CVA6Cfg.FLen-1:0] operand_b_d, operand_b_q, operand_b;\n    logic [CVA6Cfg.FLen-1:0] operand_c_d, operand_c_q, operand_c;\n    logic [OPBITS-1:0] fpu_op_d, fpu_op_q, fpu_op;\n    logic fpu_op_mod_d, fpu_op_mod_q, fpu_op_mod;\n    logic [FMTBITS-1:0] fpu_srcfmt_d, fpu_srcfmt_q, fpu_srcfmt;\n    logic [FMTBITS-1:0] fpu_dstfmt_d, fpu_dstfmt_q, fpu_dstfmt;\n    logic [IFMTBITS-1:0] fpu_ifmt_d, fpu_ifmt_q, fpu_ifmt;\n    logic [2:0] fpu_rm_d, fpu_rm_q, fpu_rm;\n    logic fpu_vec_op_d, fpu_vec_op_q, fpu_vec_op;\n\n    logic [TRANS_ID_BITS-1:0] fpu_tag_d, fpu_tag_q, fpu_tag;\n\n    logic fpu_in_ready, fpu_in_valid;\n    logic fpu_out_ready, fpu_out_valid;\n\n    logic [4:0] fpu_status;\n\n    // FSM to handle protocol inversion\n    logic hold_inputs;\n    logic use_hold;\n\n    //-----------------------------\n    // Translate inputs\n    //-----------------------------\n\n    always_comb begin : input_translation\n\n      automatic logic vec_replication;  // control honoring of replication flag\n      automatic logic replicate_c;  // replicate operand C instead of B (for ADD/SUB)\n      automatic logic check_ah;  // Decide for AH from RM field encoding\n\n      // Default Values\n      operand_a_d     = operand_a_i;\n      operand_b_d     = operand_b_i;  // immediates come through this port unless used as operand\n      operand_c_d     = operand_c_i;  // immediates come through this port unless used as operand\n      fpu_op_d        = fpnew_pkg::SGNJ;  // sign injection by default\n      fpu_op_mod_d    = 1'b0;\n      fpu_dstfmt_d    = fpnew_pkg::FP32;\n      fpu_ifmt_d      = fpnew_pkg::INT32;\n      fpu_rm_d        = fpu_rm_i;\n      fpu_vec_op_d    = fu_data_i.fu == FPU_VEC;\n      fpu_tag_d       = fu_data_i.trans_id;\n      vec_replication = fpu_rm_i[0];  // replication bit is sent via rm field\n      replicate_c     = 1'b0;\n      check_ah        = 1'b0;  // whether set scalar AH encoding from MSB of rm_i\n\n      // Scalar Rounding Modes - some ops encode inside RM but use smaller range\n      if (!(fpu_rm_i inside {[3'b000 : 3'b100]})) fpu_rm_d = fpu_frm_i;\n\n      // Vectorial ops always consult FRM\n      if (fpu_vec_op_d) fpu_rm_d = fpu_frm_i;\n\n      // Formats\n      unique case (fpu_fmt_i)\n        // FP32\n        2'b00:   fpu_dstfmt_d = fpnew_pkg::FP32;\n        // FP64 or FP16ALT (vectorial)\n        2'b01:   fpu_dstfmt_d = fpu_vec_op_d ? fpnew_pkg::FP16ALT : fpnew_pkg::FP64;\n        // FP16 or FP16ALT (scalar)\n        2'b10: begin\n          if (!fpu_vec_op_d && fpu_rm_i == 3'b101) fpu_dstfmt_d = fpnew_pkg::FP16ALT;\n          else fpu_dstfmt_d = fpnew_pkg::FP16;\n        end\n        // FP8\n        default: fpu_dstfmt_d = fpnew_pkg::FP8;\n      endcase\n\n      // By default, set src=dst\n      fpu_srcfmt_d = fpu_dstfmt_d;\n\n      // Operations (this can modify the rounding mode field and format!)\n      unique case (fu_data_i.operation)\n        // Addition\n        FADD: begin\n          fpu_op_d    = fpnew_pkg::ADD;\n          replicate_c = 1'b1; // second operand is in C\n        end\n        // Subtraction is modified ADD\n        FSUB: begin\n          fpu_op_d     = fpnew_pkg::ADD;\n          fpu_op_mod_d = 1'b1;\n          replicate_c  = 1'b1;  // second operand is in C\n        end\n        // Multiplication\n        FMUL:    fpu_op_d = fpnew_pkg::MUL;\n        // Division\n        FDIV:    fpu_op_d = fpnew_pkg::DIV;\n        // Min/Max - OP is encoded in rm (000-001)\n        FMIN_MAX: begin\n          fpu_op_d = fpnew_pkg::MINMAX;\n          fpu_rm_d = {1'b0, fpu_rm_i[1:0]};  // mask out AH encoding bit\n          check_ah = 1'b1;  // AH has RM MSB encoding\n        end\n        // Square Root\n        FSQRT:   fpu_op_d = fpnew_pkg::SQRT;\n        // Fused Multiply Add\n        FMADD:   fpu_op_d = fpnew_pkg::FMADD;\n        // Fused Multiply Subtract is modified FMADD\n        FMSUB: begin\n          fpu_op_d     = fpnew_pkg::FMADD;\n          fpu_op_mod_d = 1'b1;\n        end\n        // Fused Negated Multiply Subtract\n        FNMSUB:  fpu_op_d = fpnew_pkg::FNMSUB;\n        // Fused Negated Multiply Add is modified FNMSUB\n        FNMADD: begin\n          fpu_op_d     = fpnew_pkg::FNMSUB;\n          fpu_op_mod_d = 1'b1;\n        end\n        // Float to Int Cast - Op encoded in lowest two imm bits or rm\n        FCVT_F2I: begin\n          fpu_op_d = fpnew_pkg::F2I;\n          // Vectorial Ops encoded in R bit\n          if (fpu_vec_op_d) begin\n            fpu_op_mod_d    = fpu_rm_i[0];\n            vec_replication = 1'b0;  // no replication, R bit used for op\n            unique case (fpu_fmt_i)\n              2'b00: fpu_ifmt_d = fpnew_pkg::INT32;\n              2'b01, 2'b10: fpu_ifmt_d = fpnew_pkg::INT16;\n              2'b11: fpu_ifmt_d = fpnew_pkg::INT8;\n            endcase\n            // Scalar casts encoded in imm\n          end else begin\n            fpu_op_mod_d = operand_c_i[0];\n            if (operand_c_i[1]) fpu_ifmt_d = fpnew_pkg::INT64;\n            else fpu_ifmt_d = fpnew_pkg::INT32;\n          end\n        end\n        // Int to Float Cast - Op encoded in lowest two imm bits or rm\n        FCVT_I2F: begin\n          fpu_op_d = fpnew_pkg::I2F;\n          // Vectorial Ops encoded in R bit\n          if (fpu_vec_op_d) begin\n            fpu_op_mod_d    = fpu_rm_i[0];\n            vec_replication = 1'b0;  // no replication, R bit used for op\n            unique case (fpu_fmt_i)\n              2'b00: fpu_ifmt_d = fpnew_pkg::INT32;\n              2'b01, 2'b10: fpu_ifmt_d = fpnew_pkg::INT16;\n              2'b11: fpu_ifmt_d = fpnew_pkg::INT8;\n            endcase\n            // Scalar casts encoded in imm\n          end else begin\n            fpu_op_mod_d = operand_c_i[0];\n            if (operand_c_i[1]) fpu_ifmt_d = fpnew_pkg::INT64;\n            else fpu_ifmt_d = fpnew_pkg::INT32;\n          end\n        end\n        // Float to Float Cast - Source format encoded in lowest two/three imm bits\n        FCVT_F2F: begin\n          fpu_op_d = fpnew_pkg::F2F;\n          // Vectorial ops encoded in lowest two imm bits\n          if (fpu_vec_op_d) begin\n            vec_replication = 1'b0;  // no replication for casts (not needed)\n            unique case (operand_c_i[1:0])\n              2'b00: fpu_srcfmt_d = fpnew_pkg::FP32;\n              2'b01: fpu_srcfmt_d = fpnew_pkg::FP16ALT;\n              2'b10: fpu_srcfmt_d = fpnew_pkg::FP16;\n              2'b11: fpu_srcfmt_d = fpnew_pkg::FP8;\n            endcase\n            // Scalar ops encoded in lowest three imm bits\n          end else begin\n            unique case (operand_c_i[2:0])\n              3'b000:  fpu_srcfmt_d = fpnew_pkg::FP32;\n              3'b001:  fpu_srcfmt_d = fpnew_pkg::FP64;\n              3'b010:  fpu_srcfmt_d = fpnew_pkg::FP16;\n              3'b110:  fpu_srcfmt_d = fpnew_pkg::FP16ALT;\n              3'b011:  fpu_srcfmt_d = fpnew_pkg::FP8;\n              default: ;  // Do nothing\n            endcase\n          end\n        end\n        // Scalar Sign Injection - op encoded in rm (000-010)\n        FSGNJ: begin\n          fpu_op_d = fpnew_pkg::SGNJ;\n          fpu_rm_d = {1'b0, fpu_rm_i[1:0]};  // mask out AH encoding bit\n          check_ah = 1'b1;  // AH has RM MSB encoding\n        end\n        // Move from FPR to GPR - mapped to SGNJ-passthrough since no recoding\n        FMV_F2X: begin\n          fpu_op_d        = fpnew_pkg::SGNJ;\n          fpu_rm_d        = 3'b011;  // passthrough without checking nan-box\n          fpu_op_mod_d    = 1'b1;  // no NaN-Boxing\n          check_ah        = 1'b1;  // AH has RM MSB encoding\n          vec_replication = 1'b0;  // no replication, we set second operand\n        end\n        // Move from GPR to FPR - mapped to NOP since no recoding\n        FMV_X2F: begin\n          fpu_op_d        = fpnew_pkg::SGNJ;\n          fpu_rm_d        = 3'b011;  // passthrough without checking nan-box\n          check_ah        = 1'b1;  // AH has RM MSB encoding\n          vec_replication = 1'b0;  // no replication, we set second operand\n        end\n        // Scalar Comparisons - op encoded in rm (000-010)\n        FCMP: begin\n          fpu_op_d = fpnew_pkg::CMP;\n          fpu_rm_d = {1'b0, fpu_rm_i[1:0]};  // mask out AH encoding bit\n          check_ah = 1'b1;  // AH has RM MSB encoding\n        end\n        // Classification\n        FCLASS: begin\n          fpu_op_d = fpnew_pkg::CLASSIFY;\n          fpu_rm_d = {\n            1'b0, fpu_rm_i[1:0]\n          };  // mask out AH encoding bit - CLASS doesn't care anyways\n          check_ah = 1'b1;  // AH has RM MSB encoding\n        end\n        // Vectorial Minimum - set up scalar encoding in rm\n        VFMIN: begin\n          fpu_op_d = fpnew_pkg::MINMAX;\n          fpu_rm_d = 3'b000;  // min\n        end\n        // Vectorial Maximum - set up scalar encoding in rm\n        VFMAX: begin\n          fpu_op_d = fpnew_pkg::MINMAX;\n          fpu_rm_d = 3'b001;  // max\n        end\n        // Vectorial Sign Injection - set up scalar encoding in rm\n        VFSGNJ: begin\n          fpu_op_d = fpnew_pkg::SGNJ;\n          fpu_rm_d = 3'b000;  // sgnj\n        end\n        // Vectorial Negated Sign Injection - set up scalar encoding in rm\n        VFSGNJN: begin\n          fpu_op_d = fpnew_pkg::SGNJ;\n          fpu_rm_d = 3'b001;  // sgnjn\n        end\n        // Vectorial Xored Sign Injection - set up scalar encoding in rm\n        VFSGNJX: begin\n          fpu_op_d = fpnew_pkg::SGNJ;\n          fpu_rm_d = 3'b010;  // sgnjx\n        end\n        // Vectorial Equals - set up scalar encoding in rm\n        VFEQ: begin\n          fpu_op_d = fpnew_pkg::CMP;\n          fpu_rm_d = 3'b010;  // eq\n        end\n        // Vectorial Not Equals - set up scalar encoding in rm\n        VFNE: begin\n          fpu_op_d     = fpnew_pkg::CMP;\n          fpu_op_mod_d = 1'b1;  // invert output\n          fpu_rm_d     = 3'b010;  // eq\n        end\n        // Vectorial Less Than - set up scalar encoding in rm\n        VFLT: begin\n          fpu_op_d = fpnew_pkg::CMP;\n          fpu_rm_d = 3'b001;  // lt\n        end\n        // Vectorial Greater or Equal - set up scalar encoding in rm\n        VFGE: begin\n          fpu_op_d     = fpnew_pkg::CMP;\n          fpu_op_mod_d = 1'b1;  // invert output\n          fpu_rm_d     = 3'b001;  // lt\n        end\n        // Vectorial Less or Equal - set up scalar encoding in rm\n        VFLE: begin\n          fpu_op_d = fpnew_pkg::CMP;\n          fpu_rm_d = 3'b000;  // le\n        end\n        // Vectorial Greater Than - set up scalar encoding in rm\n        VFGT: begin\n          fpu_op_d     = fpnew_pkg::CMP;\n          fpu_op_mod_d = 1'b1;  // invert output\n          fpu_rm_d     = 3'b000;  // le\n        end\n        // Vectorial Convert-and-Pack from FP32, lower 4 entries\n        VFCPKAB_S: begin\n          fpu_op_d        = fpnew_pkg::CPKAB;\n          fpu_op_mod_d    = fpu_rm_i[0];  // A/B selection from R bit\n          vec_replication = 1'b0;  // no replication, R bit used for op\n          fpu_srcfmt_d    = fpnew_pkg::FP32;  // Cast from FP32\n        end\n        // Vectorial Convert-and-Pack from FP32, upper 4 entries\n        VFCPKCD_S: begin\n          fpu_op_d        = fpnew_pkg::CPKCD;\n          fpu_op_mod_d    = fpu_rm_i[0];  // C/D selection from R bit\n          vec_replication = 1'b0;  // no replication, R bit used for op\n          fpu_srcfmt_d    = fpnew_pkg::FP32;  // Cast from FP32\n        end\n        // Vectorial Convert-and-Pack from FP64, lower 4 entries\n        VFCPKAB_D: begin\n          fpu_op_d        = fpnew_pkg::CPKAB;\n          fpu_op_mod_d    = fpu_rm_i[0];  // A/B selection from R bit\n          vec_replication = 1'b0;  // no replication, R bit used for op\n          fpu_srcfmt_d    = fpnew_pkg::FP64;  // Cast from FP64\n        end\n        // Vectorial Convert-and-Pack from FP64, upper 4 entries\n        VFCPKCD_D: begin\n          fpu_op_d        = fpnew_pkg::CPKCD;\n          fpu_op_mod_d    = fpu_rm_i[0];  // C/D selection from R bit\n          vec_replication = 1'b0;  // no replication, R bit used for op\n          fpu_srcfmt_d    = fpnew_pkg::FP64;  // Cast from FP64\n        end\n        // No changes per default\n        default: ;  //nothing\n      endcase\n\n      // Scalar AH encoding fixing\n      if (!fpu_vec_op_d && check_ah) if (fpu_rm_i[2]) fpu_dstfmt_d = fpnew_pkg::FP16ALT;\n\n      // Replication\n      if (fpu_vec_op_d && vec_replication) begin\n        if (replicate_c) begin\n          unique case (fpu_dstfmt_d)\n            fpnew_pkg::FP32: operand_c_d = CVA6Cfg.RVD ? {2{operand_c_i[31:0]}} : operand_c_i;\n            fpnew_pkg::FP16, fpnew_pkg::FP16ALT:\n            operand_c_d = CVA6Cfg.RVD ? {4{operand_c_i[15:0]}} : {2{operand_c_i[15:0]}};\n            fpnew_pkg::FP8:\n            operand_c_d = CVA6Cfg.RVD ? {8{operand_c_i[7:0]}} : {4{operand_c_i[7:0]}};\n            default: ;  // Do nothing\n          endcase  // fpu_dstfmt_d\n        end else begin\n          unique case (fpu_dstfmt_d)\n            fpnew_pkg::FP32: operand_b_d = CVA6Cfg.RVD ? {2{operand_b_i[31:0]}} : operand_b_i;\n            fpnew_pkg::FP16, fpnew_pkg::FP16ALT:\n            operand_b_d = CVA6Cfg.RVD ? {4{operand_b_i[15:0]}} : {2{operand_b_i[15:0]}};\n            fpnew_pkg::FP8:\n            operand_b_d = CVA6Cfg.RVD ? {8{operand_b_i[7:0]}} : {4{operand_b_i[7:0]}};\n            default: ;  // Do nothing\n          endcase  // fpu_dstfmt_d\n        end\n      end\n    end\n\n\n    //---------------------------------------------------------\n    // Upstream protocol inversion: InValid depends on InReady\n    //---------------------------------------------------------\n\n    always_comb begin : p_inputFSM\n      // Default Values\n      fpu_ready_o  = 1'b0;\n      fpu_in_valid = 1'b0;\n      hold_inputs  = 1'b0;  // hold register disabled\n      use_hold     = 1'b0;  // inputs go directly to unit\n      state_d      = state_q;  // stay in the same state\n\n      // FSM\n      unique case (state_q)\n        // Default state, ready for instructions\n        READY: begin\n          fpu_ready_o  = 1'b1;  // Act as if FPU ready\n          fpu_in_valid = fpu_valid_i;  // Forward input valid to FPU\n          // There is a transaction but the FPU can't handle it\n          if (fpu_valid_i & ~fpu_in_ready) begin\n            fpu_ready_o = 1'b0;  // No token given to Issue\n            hold_inputs = 1'b1;  // save inputs to the holding register\n            state_d     = STALL;  // stall future incoming requests\n          end\n        end\n        // We're stalling the upstream (ready=0)\n        STALL: begin\n          fpu_in_valid = 1'b1;  // we have data for the FPU\n          use_hold     = 1'b1;  // the data comes from the hold reg\n          // Wait until it's consumed\n          if (fpu_in_ready) begin\n            fpu_ready_o = 1'b1;  // Give a token to issue\n            state_d     = READY;  // accept future requests\n          end\n        end\n        // Default: emit default values\n        default: ;\n      endcase\n\n      // Flushing will override issue and go back to idle\n      if (flush_i) begin\n        state_d = READY;\n      end\n\n    end\n\n    // Buffer register and FSM state holding\n    always_ff @(posedge clk_i or negedge rst_ni) begin : fp_hold_reg\n      if (~rst_ni) begin\n        state_q      <= READY;\n        operand_a_q  <= '0;\n        operand_b_q  <= '0;\n        operand_c_q  <= '0;\n        fpu_op_q     <= '0;\n        fpu_op_mod_q <= '0;\n        fpu_srcfmt_q <= '0;\n        fpu_dstfmt_q <= '0;\n        fpu_ifmt_q   <= '0;\n        fpu_rm_q     <= '0;\n        fpu_vec_op_q <= '0;\n        fpu_tag_q    <= '0;\n      end else begin\n        state_q <= state_d;\n        // Hold register is [TRIGGERED] by FSM\n        if (hold_inputs) begin\n          operand_a_q  <= operand_a_d;\n          operand_b_q  <= operand_b_d;\n          operand_c_q  <= operand_c_d;\n          fpu_op_q     <= fpu_op_d;\n          fpu_op_mod_q <= fpu_op_mod_d;\n          fpu_srcfmt_q <= fpu_srcfmt_d;\n          fpu_dstfmt_q <= fpu_dstfmt_d;\n          fpu_ifmt_q   <= fpu_ifmt_d;\n          fpu_rm_q     <= fpu_rm_d;\n          fpu_vec_op_q <= fpu_vec_op_d;\n          fpu_tag_q    <= fpu_tag_d;\n        end\n      end\n    end\n\n    // Select FPU input data: from register if valid data in register, else directly from input\n    assign operand_a  = use_hold ? op"}
{"text": "erand_a_q : operand_a_d;\n    assign operand_b  = use_hold ? operand_b_q : operand_b_d;\n    assign operand_c  = use_hold ? operand_c_q : operand_c_d;\n    assign fpu_op     = use_hold ? fpu_op_q : fpu_op_d;\n    assign fpu_op_mod = use_hold ? fpu_op_mod_q : fpu_op_mod_d;\n    assign fpu_srcfmt = use_hold ? fpu_srcfmt_q : fpu_srcfmt_d;\n    assign fpu_dstfmt = use_hold ? fpu_dstfmt_q : fpu_dstfmt_d;\n    assign fpu_ifmt   = use_hold ? fpu_ifmt_q : fpu_ifmt_d;\n    assign fpu_rm     = use_hold ? fpu_rm_q : fpu_rm_d;\n    assign fpu_vec_op = use_hold ? fpu_vec_op_q : fpu_vec_op_d;\n    assign fpu_tag    = use_hold ? fpu_tag_q : fpu_tag_d;\n\n    // Consolidate operands\n    logic [2:0][CVA6Cfg.FLen-1:0] fpu_operands;\n\n    assign fpu_operands[0] = operand_a;\n    assign fpu_operands[1] = operand_b;\n    assign fpu_operands[2] = operand_c;\n\n    //---------------\n    // FPU instance\n    //---------------\n\n    fpnew_top #(\n        .Features      (FPU_FEATURES),\n        .Implementation(FPU_IMPLEMENTATION),\n        .TagType       (logic [TRANS_ID_BITS-1:0])\n    ) i_fpnew_bulk (\n        .clk_i,\n        .rst_ni,\n        .operands_i    (fpu_operands),\n        .rnd_mode_i    (fpnew_pkg::roundmode_e'(fpu_rm)),\n        .op_i          (fpnew_pkg::operation_e'(fpu_op)),\n        .op_mod_i      (fpu_op_mod),\n        .src_fmt_i     (fpnew_pkg::fp_format_e'(fpu_srcfmt)),\n        .dst_fmt_i     (fpnew_pkg::fp_format_e'(fpu_dstfmt)),\n        .int_fmt_i     (fpnew_pkg::int_format_e'(fpu_ifmt)),\n        .vectorial_op_i(fpu_vec_op),\n        .tag_i         (fpu_tag),\n        .simd_mask_i   (1'b1),\n        .in_valid_i    (fpu_in_valid),\n        .in_ready_o    (fpu_in_ready),\n        .flush_i,\n        .result_o,\n        .status_o      (fpu_status),\n        .tag_o         (fpu_trans_id_o),\n        .out_valid_o   (fpu_out_valid),\n        .out_ready_i   (fpu_out_ready),\n        .busy_o        (  /* unused */)\n    );\n\n    // Pack status flag into exception cause, tval ignored in wb, exception is always invalid\n    assign fpu_exception_o.cause = {59'h0, fpu_status};\n    assign fpu_exception_o.valid = 1'b0;\n    assign fpu_exception_o.tval = '0;\n\n    // Donwstream write port is dedicated to FPU and always ready\n    assign fpu_out_ready = 1'b1;\n\n    // Downstream valid from unit\n    assign fpu_valid_o = fpu_out_valid;\n\n  end\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 15.04.2017\n// Description: Instruction decode, contains the logic for decode,\n//              issue and read operands.\n\nmodule id_stage #(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Fetch flush request - CONTROLLER\n    input logic flush_i,\n    // Debug (async) request - SUBSYSTEM\n    input logic debug_req_i,\n    // Handshake's data between fetch and decode - FRONTEND\n    input ariane_pkg::fetch_entry_t fetch_entry_i,\n    // Handshake's valid between fetch and decode - FRONTEND\n    input logic fetch_entry_valid_i,\n    // Handshake's ready between fetch and decode - FRONTEND\n    output logic fetch_entry_ready_o,\n    // Handshake's data between decode and issue - ISSUE\n    output ariane_pkg::scoreboard_entry_t issue_entry_o,\n    // Instruction value - ISSUE\n    output logic [31:0] orig_instr_o,\n    // Handshake's valid between decode and issue - ISSUE\n    output logic issue_entry_valid_o,\n    // Report if instruction is a control flow instruction - ISSUE\n    output logic is_ctrl_flow_o,\n    // Handshake's acknowlege between decode and issue - ISSUE\n    input logic issue_instr_ack_i,\n    // Information dedicated to RVFI - RVFI\n    output logic rvfi_is_compressed_o,\n    // Current privilege level - CSR_REGFILE\n    input riscv::priv_lvl_t priv_lvl_i,\n    // Floating point extension status - CSR_REGFILE\n    input riscv::xs_t fs_i,\n    // Floating point dynamic rounding mode - CSR_REGFILE\n    input logic [2:0] frm_i,\n    // Vector extension status - CSR_REGFILE\n    input riscv::xs_t vs_i,\n    // Level sensitive (async) interrupts - SUBSYSTEM\n    input logic [1:0] irq_i,\n    // Interrupt control status - CSR_REGFILE\n    input ariane_pkg::irq_ctrl_t irq_ctrl_i,\n    // Is current mode debug ? - CSR_REGFILE\n    input logic debug_mode_i,\n    // Trap virtual memory - CSR_REGFILE\n    input logic tvm_i,\n    // Timeout wait - CSR_REGFILE\n    input logic tw_i,\n    // Trap sret - CSR_REGFILE\n    input logic tsr_i\n);\n  // ID/ISSUE register stage\n  typedef struct packed {\n    logic                          valid;\n    ariane_pkg::scoreboard_entry_t sbe;\n    logic [31:0]                   orig_instr;\n    logic                          is_ctrl_flow;\n  } issue_struct_t;\n  issue_struct_t issue_n, issue_q;\n\n  logic                                 is_control_flow_instr;\n  ariane_pkg::scoreboard_entry_t        decoded_instruction;\n  logic                          [31:0] orig_instr;\n\n  logic                                 is_illegal;\n  logic                          [31:0] instruction;\n  logic                                 is_compressed;\n\n  if (CVA6Cfg.RVC) begin\n    // ---------------------------------------------------------\n    // 1. Check if they are compressed and expand in case they are\n    // ---------------------------------------------------------\n    compressed_decoder #(\n        .CVA6Cfg(CVA6Cfg)\n    ) compressed_decoder_i (\n        .instr_i        (fetch_entry_i.instruction),\n        .instr_o        (instruction),\n        .illegal_instr_o(is_illegal),\n        .is_compressed_o(is_compressed)\n    );\n  end else begin\n    assign instruction = fetch_entry_i.instruction;\n    assign is_illegal = '0;\n    assign is_compressed = '0;\n  end\n\n  assign rvfi_is_compressed_o = is_compressed;\n  // ---------------------------------------------------------\n  // 2. Decode and emit instruction to issue stage\n  // ---------------------------------------------------------\n  decoder #(\n      .CVA6Cfg(CVA6Cfg)\n  ) decoder_i (\n      .debug_req_i,\n      .irq_ctrl_i,\n      .irq_i,\n      .pc_i                   (fetch_entry_i.address),\n      .is_compressed_i        (is_compressed),\n      .is_illegal_i           (is_illegal),\n      .instruction_i          (instruction),\n      .compressed_instr_i     (fetch_entry_i.instruction[15:0]),\n      .branch_predict_i       (fetch_entry_i.branch_predict),\n      .ex_i                   (fetch_entry_i.ex),\n      .priv_lvl_i             (priv_lvl_i),\n      .debug_mode_i           (debug_mode_i),\n      .fs_i,\n      .frm_i,\n      .vs_i,\n      .tvm_i,\n      .tw_i,\n      .tsr_i,\n      .instruction_o          (decoded_instruction),\n      .orig_instr_o           (orig_instr),\n      .is_control_flow_instr_o(is_control_flow_instr)\n  );\n\n  // ------------------\n  // Pipeline Register\n  // ------------------\n  assign issue_entry_o = issue_q.sbe;\n  assign issue_entry_valid_o = issue_q.valid;\n  assign is_ctrl_flow_o = issue_q.is_ctrl_flow;\n  assign orig_instr_o = issue_q.orig_instr;\n\n  always_comb begin\n    issue_n             = issue_q;\n    fetch_entry_ready_o = 1'b0;\n\n    // Clear the valid flag if issue has acknowledged the instruction\n    if (issue_instr_ack_i) issue_n.valid = 1'b0;\n\n    // if we have a space in the register and the fetch is valid, go get it\n    // or the issue stage is currently acknowledging an instruction, which means that we will have space\n    // for a new instruction\n    if ((!issue_q.valid || issue_instr_ack_i) && fetch_entry_valid_i) begin\n      fetch_entry_ready_o = 1'b1;\n      issue_n = '{1'b1, decoded_instruction, orig_instr, is_control_flow_instr};\n    end\n\n    // invalidate the pipeline register on a flush\n    if (flush_i) issue_n.valid = 1'b0;\n  end\n  // -------------------------\n  // Registers (ID <-> Issue)\n  // -------------------------\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      issue_q <= '0;\n    end else begin\n      issue_q <= issue_n;\n    end\n  end\nendmodule\n"}
{"text": "// Copyright 2018 - 2019 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>\n// Description: Instruction Re-aligner\n//\n// This module takes 32-bit aligned cache blocks and extracts the instructions.\n// As we are supporting the compressed instruction set extension in a 32 bit instruction word\n// are up to 2 compressed instructions.\n// Furthermore those instructions can be arbitrarily interleaved which makes it possible to fetch\n// only the lower part of a 32 bit instruction.\n// Furthermore we need to handle the case if we want to start fetching from an unaligned\n// instruction e.g. a branch.\n\n\nmodule instr_realign\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Fetch flush request - CONTROLLER\n    input logic flush_i,\n    // 32-bit block is valid - CACHE\n    input logic valid_i,\n    // Instruction is unaligned - FRONTEND\n    output logic serving_unaligned_o,\n    // 32-bit block address - CACHE\n    input logic [riscv::VLEN-1:0] address_i,\n    // 32-bit block - CACHE\n    input logic [FETCH_WIDTH-1:0] data_i,\n    // instruction is valid - FRONTEND\n    output logic [INSTR_PER_FETCH-1:0] valid_o,\n    // Instruction address - FRONTEND\n    output logic [INSTR_PER_FETCH-1:0][riscv::VLEN-1:0] addr_o,\n    // Instruction - instr_scan&instr_queue\n    output logic [INSTR_PER_FETCH-1:0][31:0] instr_o\n);\n  // as a maximum we support a fetch width of 64-bit, hence there can be 4 compressed instructions\n  logic [3:0] instr_is_compressed;\n\n  for (genvar i = 0; i < INSTR_PER_FETCH; i++) begin\n    // LSB != 2'b11\n    assign instr_is_compressed[i] = ~&data_i[i*16+:2];\n  end\n\n  // save the unaligned part of the instruction to this ff\n  logic [15:0] unaligned_instr_d, unaligned_instr_q;\n  // the last instruction was unaligned\n  logic unaligned_d, unaligned_q;\n  // register to save the unaligned address\n  logic [riscv::VLEN-1:0] unaligned_address_d, unaligned_address_q;\n  // we have an unaligned instruction\n  assign serving_unaligned_o = unaligned_q;\n\n  // Instruction re-alignment\n  if (FETCH_WIDTH == 32) begin : realign_bp_32\n    always_comb begin : re_align\n      unaligned_d = unaligned_q;\n      unaligned_address_d = {address_i[riscv::VLEN-1:2], 2'b10};\n      unaligned_instr_d = data_i[31:16];\n\n      valid_o[0] = valid_i;\n      instr_o[0] = (unaligned_q) ? {data_i[15:0], unaligned_instr_q} : data_i[31:0];\n      addr_o[0] = (unaligned_q) ? unaligned_address_q : address_i;\n\n      valid_o[1] = 1'b0;\n      instr_o[1] = '0;\n      addr_o[1] = {address_i[riscv::VLEN-1:2], 2'b10};\n\n      // this instruction is compressed or the last instruction was unaligned\n      if (instr_is_compressed[0] || unaligned_q) begin\n        // check if this is instruction is still unaligned e.g.: it is not compressed\n        // if its compressed re-set unaligned flag\n        // for 32 bit we can simply check the next instruction and whether it is compressed or not\n        // if it is compressed the next fetch will contain an aligned instruction\n        // is instruction 1 also compressed\n        // yes? -> no problem, no -> we've got an unaligned instruction\n        if (instr_is_compressed[1]) begin\n          unaligned_d = 1'b0;\n          valid_o[1]  = valid_i;\n          instr_o[1]  = {16'b0, data_i[31:16]};\n        end else begin\n          // save the upper bits for next cycle\n          unaligned_d = 1'b1;\n          unaligned_instr_d = data_i[31:16];\n          unaligned_address_d = {address_i[riscv::VLEN-1:2], 2'b10};\n        end\n      end  // else -> normal fetch\n\n      // we started to fetch on a unaligned boundary with a whole instruction -> wait until we've\n      // received the next instruction\n      if (valid_i && address_i[1]) begin\n        // the instruction is not compressed so we can't do anything in this cycle\n        if (!instr_is_compressed[0]) begin\n          valid_o = '0;\n          unaligned_d = 1'b1;\n          unaligned_address_d = {address_i[riscv::VLEN-1:2], 2'b10};\n          unaligned_instr_d = data_i[15:0];\n          // the instruction isn't compressed but only the lower is ready\n        end else begin\n          valid_o = {{INSTR_PER_FETCH - 1{1'b0}}, 1'b1};\n        end\n      end\n    end\n    // TODO(zarubaf): Fix 64 bit FETCH_WIDTH, maybe generalize to arbitrary fetch width\n  end else if (FETCH_WIDTH == 64) begin : realign_bp_64\n    initial begin\n      $error(\"Not propperly implemented\");\n    end\n    always_comb begin : re_align\n      unaligned_d = unaligned_q;\n      unaligned_address_d = unaligned_address_q;\n      unaligned_instr_d = unaligned_instr_q;\n\n      valid_o    = '0;\n      valid_o[0] = valid_i;\n\n      instr_o[0] = data_i[31:0];\n      addr_o[0]  = address_i;\n\n      instr_o[1] = '0;\n      addr_o[1]  = {address_i[riscv::VLEN-1:3], 3'b010};\n\n      instr_o[2] = {16'b0, data_i[47:32]};\n      addr_o[2]  = {address_i[riscv::VLEN-1:3], 3'b100};\n\n      instr_o[3] = {16'b0, data_i[63:48]};\n      addr_o[3]  = {address_i[riscv::VLEN-1:3], 3'b110};\n\n      // last instruction was unaligned\n      if (unaligned_q) begin\n        instr_o[0] = {data_i[15:0], unaligned_instr_q};\n        addr_o[0]  = unaligned_address_q;\n        // for 64 bit there exist the following options:\n        //     64      32      0\n        //     | 3 | 2 | 1 | 0 | <- instruction slot\n        // |   I   |   I   |   U   | -> again unaligned\n        // | * | C |   I   |   U   | -> aligned\n        // | * |   I   | C |   U   | -> aligned\n        // |   I   | C | C |   U   | -> again unaligned\n        // | * | C | C | C |   U   | -> aligned\n        // Legend: C = compressed, I = 32 bit instruction, U = unaligned upper half\n        //         * = don't care\n        if (instr_is_compressed[1]) begin\n          instr_o[1] = {16'b0, data_i[31:16]};\n          valid_o[1] = valid_i;\n\n          if (instr_is_compressed[2]) begin\n            if (instr_is_compressed[3]) begin\n              unaligned_d = 1'b0;\n              valid_o[3]  = valid_i;\n            end else begin\n              // continues to be unaligned\n            end\n          end else begin\n            unaligned_d = 1'b0;\n            instr_o[2]  = data_i[63:32];\n            valid_o[2]  = valid_i;\n          end\n          // instruction 1 is not compressed\n        end else begin\n          instr_o[1] = data_i[47:16];\n          valid_o[1] = valid_i;\n          addr_o[2]  = {address_i[riscv::VLEN-1:3], 3'b110};\n          if (instr_is_compressed[2]) begin\n            unaligned_d = 1'b0;\n            instr_o[2]  = {16'b0, data_i[63:48]};\n            valid_o[2]  = valid_i;\n          end else begin\n            // continues to be unaligned\n          end\n        end\n      end else if (instr_is_compressed[0]) begin  // instruction zero is RVC\n        //     64     32       0\n        //     | 3 | 2 | 1 | 0 | <- instruction slot\n        // |   I   |   I   | C | -> again unaligned\n        // | * | C |   I   | C | -> aligned\n        // | * |   I   | C | C | -> aligned\n        // |   I   | C | C | C | -> again unaligned\n        // | * | C | C | C | C | -> aligned\n        if (instr_is_compressed[1]) begin\n          instr_o[1] = {16'b0, data_i[31:16]};\n          valid_o[1] = valid_i;\n\n          if (instr_is_compressed[2]) begin\n            valid_o[2] = valid_i;\n            if (instr_is_compressed[3]) begin\n              valid_o[3] = valid_i;\n            end else begin\n              // this instruction is unaligned\n              unaligned_d = 1'b1;\n              unaligned_instr_d = data_i[63:48];\n              unaligned_address_d = addr_o[3];\n            end\n          end else begin\n            instr_o[2] = data_i[63:32];\n            valid_o[2] = valid_i;\n          end\n          // instruction 1 is not compressed -> check slot 3\n        end else begin\n          instr_o[1] = data_i[47:16];\n          valid_o[1] = valid_i;\n          addr_o[2]  = {address_i[riscv::VLEN-1:3], 3'b110};\n          if (instr_is_compressed[3]) begin\n            instr_o[2] = data_i[63:48];\n            valid_o[2] = valid_i;\n          end else begin\n            unaligned_d = 1'b1;\n            unaligned_instr_d = data_i[63:48];\n            unaligned_address_d = addr_o[2];\n          end\n        end\n\n        // Full instruction in slot zero\n        //     64     32       0\n        //     | 3 | 2 | 1 | 0 | <- instruction slot\n        // |   I   | C |   I   |\n        // | * | C | C |   I   |\n        // | * |   I   |   I   |\n      end else begin\n        addr_o[1] = {address_i[riscv::VLEN-1:3], 3'b100};\n\n        if (instr_is_compressed[2]) begin\n          instr_o[1] = {16'b0, data_i[47:32]};\n          valid_o[1] = valid_i;\n          addr_o[2]  = {address_i[riscv::VLEN-1:3], 3'b110};\n          if (instr_is_compressed[3]) begin\n            // | * | C | C |   I   |\n            valid_o[2] = valid_i;\n            addr_o[2]  = {16'b0, data_i[63:48]};\n          end else begin\n            // this instruction is unaligned\n            unaligned_d = 1'b1;\n            unaligned_instr_d = data_i[63:48];\n            unaligned_address_d = addr_o[2];\n          end\n        end else begin\n          // two regular instructions back-to-back\n          instr_o[1] = data_i[63:32];\n          valid_o[1] = valid_i;\n        end\n      end\n\n      // --------------------------\n      // Unaligned fetch\n      // --------------------------\n      // Address was not 64 bit aligned\n      case (address_i[2:1])\n        // this means the previouse instruction was either compressed or unaligned\n        // in any case we don't ccare\n        2'b01: begin\n          //     64     32       0\n          //     | 3 | 2 | 1 | 0 | <- instruction slot\n          // |   I   |   I   | x  -> again unaligned\n          // | * | C |   I   | x  -> aligned\n          // | * |   I   | C | x  -> aligned\n          // |   I   | C | C | x  -> again unaligned\n          // | * | C | C | C | x  -> aligned\n          addr_o[0] = {address_i[riscv::VLEN-1:3], 3'b010};\n\n          if (instr_is_compressed[1]) begin\n            instr_o[0] = {16'b0, data_i[31:16]};\n            valid_o[0] = valid_i;\n\n            if (instr_is_compressed[2]) begin\n              valid_o[1] = valid_i;\n              instr_o[1] = {16'b0, data_i[47:32]};\n              addr_o[1]  = {address_i[riscv::VLEN-1:3], 3'b100};\n              if (instr_is_compressed[3]) begin\n                instr_o[2] = {16'b0, data_i[63:48]};\n                addr_o[2]  = {address_i[riscv::VLEN-1:3], 3'b110};\n                valid_o[2] = valid_i;\n              end else begin\n                // this instruction is unaligned\n                unaligned_d = 1'b1;\n                unaligned_instr_d = data_i[63:48];\n                unaligned_address_d = addr_o[3];\n              end\n            end else begin\n              instr_o[1] = data_i[63:32];\n              addr_o[1]  = {address_i[riscv::VLEN-1:3], 3'b100};\n              valid_o[1] = valid_i;\n            end\n            // instruction 1 is not compressed -> check slot 3\n          end else begin\n            instr_o[0] = data_i[47:16];\n            valid_o[0] = valid_i;\n            addr_o[1]  = {address_i[riscv::VLEN-1:3], 3'b110};\n            if (instr_is_compressed[3]) begin\n              instr_o[1] = data_i[63:48];\n              valid_o[1] = valid_i;\n            end else begin\n              unaligned_d = 1'b1;\n              unaligned_instr_d = data_i[63:48];\n              unaligned_address_d = addr_o[1];\n            end\n          end\n        end\n        2'b10: begin\n          valid_o = '0;\n          //     64     32       0\n          //     | 3 | 2 | 1 | 0 | <- instruction slot\n          // |   I   | C |   *   | <- unaligned\n          //    | C  | C |   *   | <- aligned\n          //    |    I   |   *   | <- aligned\n          if (instr_is_compressed[2]) begin\n            valid_o[0] = valid_i;\n            instr_o[0] = data_i[47:32];\n            // second instruction is also compressed\n            if (instr_is_compressed[3]) begin\n              valid_o[1] = valid_i;\n              instr_o[1] = data_i[63:48];\n              // regular instruction -> unaligned\n            end else begin\n              unaligned_d = 1'b1;\n              unaligned_address_d = {address_i[riscv::VLEN-1:3], 3'b110};\n              unaligned_instr_d = data_i[63:48];\n            end\n            // instruction is a regular instruction\n          end else begin\n            valid_o[0] = valid_i;\n            instr_o[0] = data_i[63:32];\n            addr_o[0]  = address_i;\n          end\n        end\n        // we started to fetch on a unaligned boundary with a whole instruction -> wait until we've\n        // received the next instruction\n        2'b11: begin\n          valid_o = '0;\n          if (!instr_is_compressed[3]) begin\n            unaligned_d = 1'b1;\n            unaligned_address_d = {address_i[riscv::VLEN-1:3], 3'b110};\n            unaligned_instr_d = data_i[63:48];\n          end else begin\n            valid_o[3] = valid_i;\n          end\n        end\n      endcase\n    end\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      unaligned_q         <= 1'b0;\n      unaligned_address_q <= '0;\n      unaligned_instr_q   <= '0;\n    end else begin\n      if (valid_i) begin\n        unaligned_address_q <= unaligned_address_d;\n        unaligned_instr_q   <= unaligned_instr_d;\n      end\n\n      if (flush_i) begin\n        unaligned_q <= 1'b0;\n      end else if (valid_i) begin\n        unaligned_q <= unaligned_d;\n      end\n    end\n  end\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 16.05.2017\n// Description: Instruction Tracer Main Class\n\n`ifndef VERILATOR\n//pragma translate_off\n`include \"ex_trace_item.svh\"\n`include \"instr_trace_item.svh\"\n\nmodule instr_tracer (\n  instr_tracer_if   tracer_if,\n  input logic[riscv::XLEN-1:0] hart_id_i\n);\n\n  // keep the decoded instructions in a queue\n  logic [31:0] decode_queue [$];\n  // keep the issued instructions in a queue\n  logic [31:0] issue_queue [$];\n  // issue scoreboard entries\n  ariane_pkg::scoreboard_entry_t issue_sbe_queue [$];\n  ariane_pkg::scoreboard_entry_t issue_sbe;\n  // store resolved branches, get (mis-)predictions\n  ariane_pkg::bp_resolve_t bp [$];\n  // shadow copy of the register files\n  logic [63:0] gp_reg_file [32];\n  logic [63:0] fp_reg_file [32];\n  // 64 bit clock tick count\n  longint unsigned clk_ticks;\n  int f, commit_log;\n  // address mapping\n  // contains mappings of the form vaddr <-> paddr\n  logic [63:0] store_mapping[$], load_mapping[$], address_mapping;\n\n  // static uvm_cmdline_processor uvcl = uvm_cmdline_processor::get_inst();\n\n  function void create_file(logic [63:0] hart_id);\n    string fn, fn_commit_log;\n    $sformat(fn, \"trace_hart_%0.0f.log\", hart_id);\n    $sformat(fn_commit_log, \"trace_hart_%0.0f_commit.log\", hart_id);\n    $display(\"[TRACER] Output filename is: %s\", fn);\n\n    f = $fopen(fn,\"w\");\n    if (ariane_pkg::ENABLE_SPIKE_COMMIT_LOG) commit_log = $fopen(fn_commit_log, \"w\");\n  endfunction : create_file\n\n  task trace();\n    automatic logic [31:0] decode_instruction, issue_instruction, issue_commit_instruction;\n    automatic ariane_pkg::scoreboard_entry_t commit_instruction;\n    // initialize register 0\n    gp_reg_file  = '{default:0};\n    fp_reg_file  = '{default:0};\n\n    forever begin\n      automatic ariane_pkg::bp_resolve_t bp_instruction = '0;\n      // new cycle, we are only interested if reset is de-asserted\n      @(tracer_if.pck) if (tracer_if.pck.rstn !== 1'b1) begin\n        flush();\n        continue;\n      end\n\n      // increment clock tick\n      clk_ticks++;\n\n      // -------------------\n      // Instruction Decode\n      // -------------------\n      // we are decoding an instruction\n      if (tracer_if.pck.fetch_valid && tracer_if.pck.fetch_ack) begin\n        decode_instruction = tracer_if.pck.instruction;\n        decode_queue.push_back(decode_instruction);\n      end\n      // -------------------\n      // Instruction Issue\n      // -------------------\n      // we got a new issue ack, so put the element from the decode queue to\n      // the issue queue\n      if (tracer_if.pck.issue_ack && !tracer_if.pck.flush_unissued) begin\n        issue_instruction = decode_queue.pop_front();\n        issue_queue.push_back(issue_instruction);\n        // also save the scoreboard entry to a separate issue queue\n        issue_sbe_queue.push_back(ariane_pkg::scoreboard_entry_t'(tracer_if.pck.issue_sbe));\n      end\n\n      // --------------------\n      // Address Translation\n      // --------------------\n      if (tracer_if.pck.st_valid) begin\n        store_mapping.push_back(tracer_if.pck.st_paddr);\n      end\n\n      if (tracer_if.pck.ld_valid && !tracer_if.pck.ld_kill) begin\n        load_mapping.push_back(tracer_if.pck.ld_paddr);\n      end\n      // ----------------------\n      // Store predictions\n      // ----------------------\n      if (tracer_if.pck.resolve_branch.valid) begin\n        bp.push_back(tracer_if.pck.resolve_branch);\n      end\n      // --------------\n      //  Commit\n      // --------------\n      // we are committing an instruction\n      for (int i = 0; i < 2; i++) begin\n        if (tracer_if.pck.commit_ack[i]) begin\n          commit_instruction = ariane_pkg::scoreboard_entry_t'(tracer_if.pck.commit_instr[i]);\n          issue_commit_instruction = issue_queue.pop_front();\n          issue_sbe = issue_sbe_queue.pop_front();\n          // check if the instruction retiring is a load or store, get the physical address accordingly\n          if (tracer_if.pck.commit_instr[i].fu == ariane_pkg::LOAD)\n            address_mapping = load_mapping.pop_front();\n          else if (tracer_if.pck.commit_instr[i].fu == ariane_pkg::STORE)\n            address_mapping = store_mapping.pop_front();\n\n          if (tracer_if.pck.commit_instr[i].fu == ariane_pkg::CTRL_FLOW)\n            bp_instruction = bp.pop_front();\n          // the scoreboards issue entry still contains the immediate value as a result\n          // check if the write back is valid, if not we need to source the result from the register file\n          // as the most recent version of this register will be there.\n          if (tracer_if.pck.we_gpr[i] || tracer_if.pck.we_fpr[i]) begin\n            printInstr(issue_sbe, issue_commit_instruction, tracer_if.pck.wdata[i], address_mapping, tracer_if.pck.priv_lvl, tracer_if.pck.debug_mode, bp_instruction);\n          end else if (ariane_pkg::is_rd_fpr(commit_instruction.op)) begin\n            printInstr(issue_sbe, issue_commit_instruction, fp_reg_file[commit_instruction.rd], address_mapping, tracer_if.pck.priv_lvl, tracer_if.pck.debug_mode, bp_instruction);\n          end else begin\n            printInstr(issue_sbe, issue_commit_instruction, gp_reg_file[commit_instruction.rd], address_mapping, tracer_if.pck.priv_lvl, tracer_if.pck.debug_mode, bp_instruction);\n          end\n        end\n      end\n      // --------------\n      // Exceptions\n      // --------------\n      if (tracer_if.pck.exception.valid && !(tracer_if.pck.debug_mode && tracer_if.pck.exception.cause == riscv::BREAKPOINT)) begin\n        // print exception\n        printException(tracer_if.pck.commit_instr[0].pc, tracer_if.pck.exception.cause, tracer_if.pck.exception.tval);\n      end\n      // ----------------------\n      // Commit Registers\n      // ----------------------\n      // update shadow reg files here\n      for (int i = 0; i < 2; i++) begin\n        if (tracer_if.pck.we_gpr[i] && tracer_if.pck.waddr[i] != 5'b0) begin\n          gp_reg_file[tracer_if.pck.waddr[i]] = tracer_if.pck.wdata[i];\n        end else if (tracer_if.pck.we_fpr[i]) begin\n          fp_reg_file[tracer_if.pck.waddr[i]] = tracer_if.pck.wdata[i];\n        end\n      end\n      // --------------\n      // Flush Signals\n      // --------------\n      // flush un-issued instructions\n      if (tracer_if.pck.flush_unissued) begin\n        flushDecode();\n      end\n      // flush whole pipeline\n      if (tracer_if.pck.flush) begin\n        flush();\n      end\n    end\n\n  endtask\n\n  // flush all decoded instructions\n  function void flushDecode ();\n    decode_queue = {};\n  endfunction\n\n  // flush everything, we took an exception/interrupt\n  function void flush ();\n    flushDecode();\n    // clear all elements in the queue\n    issue_queue     = {};\n    issue_sbe_queue = {};\n    // also clear mappings\n    store_mapping   = {};\n    load_mapping    = {};\n    bp              = {};\n  endfunction\n\n  function void printInstr(ariane_pkg::scoreboard_entry_t sbe, logic [31:0] instr, logic [63:0] result, logic [riscv::PLEN-1:0] paddr, riscv::priv_lvl_t priv_lvl, logic debug_mode, ariane_pkg::bp_resolve_t bp);\n    automatic instr_trace_item iti = new ($time, clk_ticks, sbe, instr, gp_reg_file, fp_reg_file, result, paddr, priv_lvl, debug_mode, bp);\n    // print instruction to console\n    automatic string print_instr = iti.printInstr();\n    if (ariane_pkg::ENABLE_SPIKE_COMMIT_LOG && !debug_mode) begin\n      $fwrite(commit_log, riscv::spikeCommitLog(sbe.pc, priv_lvl, instr, sbe.rd, result, ariane_pkg::is_rd_fpr(sbe.op)));\n    end\n    $fwrite(f, {print_instr, \"\\n\"});\n  endfunction\n\n  function void printException(logic [riscv::VLEN-1:0] pc, logic [63:0] cause, logic [63:0] tval);\n    automatic ex_trace_item eti = new (pc, cause, tval);\n    automatic string print_ex = eti.printException();\n    $fwrite(f, {print_ex, \"\\n\"});\n  endfunction\n\n  function void close();\n    if (f) $fclose(f);\n    if (ariane_pkg::ENABLE_SPIKE_COMMIT_LOG && commit_log) $fclose(commit_log);\n  endfunction\n\n\n  initial begin\n    #15ns;\n    create_file(hart_id_i);\n    trace();\n  end\n\n  final begin\n    close();\n  end\n\nendmodule : instr_tracer\n//pragma translate_on\n`endif\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 16.05.2017\n// Description: Instruction Tracer Interface\n\n`ifndef VERILATOR\n`ifndef INSTR_TRACER_IF_SV\n`define INSTR_TRACER_IF_SV\ninterface instr_tracer_if (\n        input clk\n    );\n\n    logic             rstn;\n    logic             flush_unissued;\n    logic             flush;\n    // Decode\n    logic [31:0]      instruction;\n    logic             fetch_valid;\n    logic             fetch_ack;\n    // Issue stage\n    logic                           issue_ack; // issue acknowledged\n    ariane_pkg::scoreboard_entry_t  issue_sbe; // issue scoreboard entry\n    // WB stage\n    logic [1:0][4:0]  waddr;\n    logic [1:0][63:0] wdata;\n    logic [1:0]       we_gpr;\n    logic [1:0]       we_fpr;\n    // commit stage\n    ariane_pkg::scoreboard_entry_t [1:0] commit_instr; // commit instruction\n    logic                          [1:0] commit_ack;\n    // address translation\n    // stores\n    logic                         st_valid;\n    logic [riscv::PLEN-1:0]       st_paddr;\n    // loads\n    logic                         ld_valid;\n    logic                         ld_kill;\n    logic [riscv::PLEN-1:0]       ld_paddr;\n    // misprediction\n    ariane_pkg::bp_resolve_t resolve_branch;\n    // exceptions\n    ariane_pkg::exception_t  exception;\n    // current privilege level\n    riscv::priv_lvl_t  priv_lvl;\n    logic              debug_mode;\n    // the tracer just has a passive interface we do not drive anything with it\n\n    //pragma translate_off\n    clocking pck @(posedge clk);\n        input rstn, flush_unissued, flush, instruction, fetch_valid, fetch_ack, issue_ack, issue_sbe, waddr,\n              st_valid, st_paddr, ld_valid, ld_kill, ld_paddr, resolve_branch,\n              wdata, we_gpr, we_fpr, commit_instr, commit_ack, exception, priv_lvl, debug_mode;\n    endclocking\n    //pragma translate_on\n\nendinterface\n`endif\n`endif\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 16.05.2017\n// Description: Instruction Tracer Defines\n\n`ifndef VERILATOR\npackage instr_tracer_pkg;\n\n  parameter INSTR_NOP = 32'h00_00_00_13;\n\n  parameter INSTR_LUI = {25'b?, riscv::OpcodeLui};\n  parameter INSTR_AUIPC = {25'b?, riscv::OpcodeAuipc};\n  parameter INSTR_JAL = {25'b?, riscv::OpcodeJal};\n  parameter INSTR_JALR = {17'b?, 3'b000, 5'b?, riscv::OpcodeJalr};\n  // BRANCH\n  parameter INSTR_BEQZ = {7'b?, 5'b0, 5'b?, 3'b000, 5'b?, riscv::OpcodeBranch};\n  parameter INSTR_BEQ = {7'b?, 5'b?, 5'b?, 3'b000, 5'b?, riscv::OpcodeBranch};\n  parameter INSTR_BNEZ = {7'b?, 5'b0, 5'b?, 3'b001, 5'b?, riscv::OpcodeBranch};\n  parameter INSTR_BNE = {7'b?, 5'b?, 5'b?, 3'b001, 5'b?, riscv::OpcodeBranch};\n  parameter INSTR_BLTZ = {7'b?, 5'b0, 5'b?, 3'b100, 5'b?, riscv::OpcodeBranch};\n  parameter INSTR_BLT = {7'b?, 5'b?, 5'b?, 3'b100, 5'b?, riscv::OpcodeBranch};\n  parameter INSTR_BGEZ = {7'b?, 5'b0, 5'b?, 3'b101, 5'b?, riscv::OpcodeBranch};\n  parameter INSTR_BGE = {7'b?, 5'b?, 5'b?, 3'b101, 5'b?, riscv::OpcodeBranch};\n  parameter INSTR_BLTU = {7'b?, 5'b?, 5'b?, 3'b110, 5'b?, riscv::OpcodeBranch};\n  parameter INSTR_BGEU = {7'b?, 5'b?, 5'b?, 3'b111, 5'b?, riscv::OpcodeBranch};\n\n  // OP-IMM\n  parameter INSTR_LI = {12'b?, 5'b0, 3'b000, 5'b?, riscv::OpcodeOpImm};\n  parameter INSTR_ADDI = {17'b?, 3'b000, 5'b?, riscv::OpcodeOpImm};\n  parameter INSTR_SLTI = {17'b?, 3'b010, 5'b?, riscv::OpcodeOpImm};\n  parameter INSTR_SLTIU = {17'b?, 3'b011, 5'b?, riscv::OpcodeOpImm};\n  parameter INSTR_XORI = {17'b?, 3'b100, 5'b?, riscv::OpcodeOpImm};\n  parameter INSTR_ORI = {17'b?, 3'b110, 5'b?, riscv::OpcodeOpImm};\n  parameter INSTR_ANDI = {17'b?, 3'b111, 5'b?, riscv::OpcodeOpImm};\n  parameter INSTR_SLLI = {6'b000000, 11'b?, 3'b001, 5'b?, riscv::OpcodeOpImm};\n  parameter INSTR_SRLI = {6'b000000, 11'b?, 3'b101, 5'b?, riscv::OpcodeOpImm};\n  parameter INSTR_SRAI = {6'b010000, 11'b?, 3'b101, 5'b?, riscv::OpcodeOpImm};\n\n  // OP-IMM-32\n  parameter INSTR_ADDIW = {17'b?, 3'b000, 5'b?, riscv::OpcodeOpImm32};\n  parameter INSTR_SLLIW = {7'b0000000, 10'b?, 3'b001, 5'b?, riscv::OpcodeOpImm32};\n  parameter INSTR_SRLIW = {7'b0000000, 10'b?, 3'b101, 5'b?, riscv::OpcodeOpImm32};\n  parameter INSTR_SRAIW = {7'b0100000, 10'b?, 3'b101, 5'b?, riscv::OpcodeOpImm32};\n\n  // OP\n  parameter INSTR_ADD = {7'b0000000, 10'b?, 3'b000, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_SUB = {7'b0100000, 10'b?, 3'b000, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_SLL = {7'b0000000, 10'b?, 3'b001, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_SLT = {7'b0000000, 10'b?, 3'b010, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_SLTU = {7'b0000000, 10'b?, 3'b011, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_XOR = {7'b0000000, 10'b?, 3'b100, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_SRL = {7'b0000000, 10'b?, 3'b101, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_SRA = {7'b0100000, 10'b?, 3'b101, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_OR = {7'b0000000, 10'b?, 3'b110, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_AND = {7'b0000000, 10'b?, 3'b111, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_MUL = {7'b0000001, 10'b?, 3'b???, 5'b?, riscv::OpcodeOp};\n\n  // OP32\n  parameter INSTR_ADDW = {7'b0000000, 10'b?, 3'b000, 5'b?, riscv::OpcodeOp32};\n  parameter INSTR_SUBW = {7'b0100000, 10'b?, 3'b000, 5'b?, riscv::OpcodeOp32};\n  parameter INSTR_SLLW = {7'b0000000, 10'b?, 3'b001, 5'b?, riscv::OpcodeOp32};\n  parameter INSTR_SRLW = {7'b0000000, 10'b?, 3'b101, 5'b?, riscv::OpcodeOp32};\n  parameter INSTR_SRAW = {7'b0100000, 10'b?, 3'b101, 5'b?, riscv::OpcodeOp32};\n  parameter INSTR_MULW = {7'b0000001, 10'b?, 3'b???, 5'b?, riscv::OpcodeOp32};\n\n  // MISC-MEM\n  parameter INSTR_FENCE = {4'b0, 8'b?, 13'b0, riscv::OpcodeMiscMem};\n  parameter INSTR_FENCEI = {17'b0, 3'b001, 5'b0, riscv::OpcodeMiscMem};\n\n  // SYSTEM\n  parameter INSTR_CSRW = {12'b?, 5'b?, 3'b001, 5'b0, riscv::OpcodeSystem};\n  parameter INSTR_CSRRW = {12'b?, 5'b?, 3'b001, 5'b?, riscv::OpcodeSystem};\n  parameter INSTR_CSRR = {12'b?, 5'b0, 3'b010, 5'b?, riscv::OpcodeSystem};\n  parameter INSTR_CSRRS = {12'b?, 5'b?, 3'b010, 5'b?, riscv::OpcodeSystem};\n  parameter INSTR_CSRS = {12'b?, 5'b?, 3'b010, 5'b0, riscv::OpcodeSystem};\n  parameter INSTR_CSRRC = {12'b?, 5'b?, 3'b011, 5'b?, riscv::OpcodeSystem};\n  parameter INSTR_CSRC = {12'b?, 5'b?, 3'b011, 5'b0, riscv::OpcodeSystem};\n\n  parameter INSTR_CSRWI = {17'b?, 3'b101, 5'b0, riscv::OpcodeSystem};\n  parameter INSTR_CSRRWI = {17'b?, 3'b101, 5'b?, riscv::OpcodeSystem};\n  parameter INSTR_CSRSI = {17'b?, 3'b110, 5'b0, riscv::OpcodeSystem};\n  parameter INSTR_CSRRSI = {17'b?, 3'b110, 5'b?, riscv::OpcodeSystem};\n  parameter INSTR_CSRCI = {17'b?, 3'b111, 5'b0, riscv::OpcodeSystem};\n  parameter INSTR_CSRRCI = {17'b?, 3'b111, 5'b?, riscv::OpcodeSystem};\n\n  parameter INSTR_ECALL = {12'b000000000000, 13'b0, riscv::OpcodeSystem};\n  parameter INSTR_EBREAK = {12'b000000000001, 13'b0, riscv::OpcodeSystem};\n  parameter INSTR_MRET = {12'b001100000010, 13'b0, riscv::OpcodeSystem};\n  parameter INSTR_SRET = {12'b000100000010, 13'b0, riscv::OpcodeSystem};\n  parameter INSTR_DRET = {12'b011110110010, 13'b0, riscv::OpcodeSystem};\n  parameter INSTR_WFI = {12'b000100000101, 13'b0, riscv::OpcodeSystem};\n  parameter INSTR_SFENCE = {12'b0001001?????, 13'b?, riscv::OpcodeSystem};\n\n  // RV32M\n  parameter INSTR_PMUL = {7'b0000001, 10'b?, 3'b000, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_DIV = {7'b0000001, 10'b?, 3'b100, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_DIVU = {7'b0000001, 10'b?, 3'b101, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_REM = {7'b0000001, 10'b?, 3'b110, 5'b?, riscv::OpcodeOp};\n  parameter INSTR_REMU = {7'b0000001, 10'b?, 3'b111, 5'b?, riscv::OpcodeOp};\n\n  // RVFD\n  parameter INSTR_FMADD = {5'b?, 2'b?, 5'b?, 5'b?, 3'b?, 5'b?, riscv::OpcodeMadd};\n  parameter INSTR_FMSUB = {5'b?, 2'b?, 5'b?, 5'b?, 3'b?, 5'b?, riscv::OpcodeMsub};\n  parameter INSTR_FNSMSUB = {5'b?, 2'b?, 5'b?, 5'b?, 3'b?, 5'b?, riscv::OpcodeNmsub};\n  parameter INSTR_FNMADD = {5'b?, 2'b?, 5'b?, 5'b?, 3'b?, 5'b?, riscv::OpcodeNmadd};\n\n  parameter INSTR_FADD = {5'b00000, 2'b?, 5'b?, 5'b?, 3'b?, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FSUB = {5'b00001, 2'b?, 5'b?, 5'b?, 3'b?, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FMUL = {5'b00010, 2'b?, 5'b?, 5'b?, 3'b?, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FDIV = {5'b00011, 2'b?, 5'b?, 5'b?, 3'b?, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FSQRT = {5'b01011, 2'b?, 5'b0, 5'b?, 3'b?, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FSGNJ = {5'b00100, 2'b?, 5'b?, 5'b?, 3'b000, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FSGNJN = {5'b00100, 2'b?, 5'b?, 5'b?, 3'b001, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FSGNJX = {5'b00100, 2'b?, 5'b?, 5'b?, 3'b010, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FMIN = {5'b00101, 2'b?, 5'b?, 5'b?, 3'b000, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FMAX = {5'b00101, 2'b?, 5'b?, 5'b?, 3'b001, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FLE = {5'b10100, 2'b?, 5'b?, 5'b?, 3'b000, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FLT = {5'b10100, 2'b?, 5'b?, 5'b?, 3'b001, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FEQ = {5'b10100, 2'b?, 5'b?, 5'b?, 3'b010, 5'b?, riscv::OpcodeOpFp};\n\n  parameter INSTR_FCVT_F2F = {5'b01000, 2'b?, 5'b000??, 5'b?, 3'b?, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FMV_F2X = {5'b11100, 2'b?, 5'b0, 5'b?, 3'b000, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FCLASS = {5'b11100, 2'b?, 5'b0, 5'b?, 3'b001, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FMV_X2F = {5'b11110, 2'b?, 5'b0, 5'b?, 3'b000, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FCVT_F2I = {5'b11000, 2'b?, 5'b000??, 5'b?, 3'b?, 5'b?, riscv::OpcodeOpFp};\n  parameter INSTR_FCVT_I2F = {5'b11010, 2'b?, 5'b000??, 5'b?, 3'b?, 5'b?, riscv::OpcodeOpFp};\n\n  // A\n  parameter INSTR_AMO = {25'b?, riscv::OpcodeAmo};\n\n  // Load/Stores\n  parameter [31:0] LB = 32'b?????????????????000?????0000011;\n  parameter [31:0] LH = 32'b?????????????????001?????0000011;\n  parameter [31:0] LW = 32'b?????????????????010?????0000011;\n  parameter [31:0] LD = 32'b?????????????????011?????0000011;\n  parameter [31:0] LBU = 32'b?????????????????100?????0000011;\n  parameter [31:0] LHU = 32'b?????????????????101?????0000011;\n  parameter [31:0] LWU = 32'b?????????????????110?????0000011;\n  parameter [31:0] FLW = 32'b?????????????????010?????0000111;\n  parameter [31:0] FLD = 32'b?????????????????011?????0000111;\n  parameter [31:0] FLQ = 32'b?????????????????100?????0000111;\n  parameter [31:0] SB = 32'b?????????????????000?????0100011;\n  parameter [31:0] SH = 32'b?????????????????001?????0100011;\n  parameter [31:0] SW = 32'b?????????????????010?????0100011;\n  parameter [31:0] SD = 32'b?????????????????011?????0100011;\n  parameter [31:0] FSW = 32'b?????????????????010?????0100111;\n  parameter [31:0] FSD = 32'b?????????????????011?????0100111;\n  parameter [31:0] FSQ = 32'b?????????????????100?????0100111;\n  parameter [31:0] C_ADDI4SPN = 32'b????????????????000???????????00;\n  parameter [31:0] C_FLD = 32'b????????????????001???????????00;\n  parameter [31:0] C_LW = 32'b????????????????010???????????00;\n  parameter [31:0] C_FLW = 32'b????????????????011???????????00;\n  parameter [31:0] C_FSD = 32'b????????????????101???????????00;\n  parameter [31:0] C_SW = 32'b????????????????110???????????00;\n  parameter [31:0] C_FSW = 32'b????????????????111???????????00;\n  parameter [31:0] C_ADDI = 32'b????????????????000???????????01;\n  parameter [31:0] C_JAL = 32'b????????????????001???????????01;\n  parameter [31:0] C_LI = 32'b????????????????010???????????01;\n  parameter [31:0] C_LUI = 32'b????????????????011???????????01;\n  parameter [31:0] C_SRLI = 32'b????????????????100?00????????01;\n  parameter [31:0] C_SRAI = 32'b????????????????100?01????????01;\n  parameter [31:0] C_ANDI = 32'b????????????????100?10????????01;\n  parameter [31:0] C_SUB = 32'b????????????????100011???00???01;\n  parameter [31:0] C_XOR = 32'b????????????????100011???01???01;\n  parameter [31:0] C_OR = 32'b????????????????100011???10???01;\n  parameter [31:0] C_AND = 32'b????????????????100011???11???01;\n  parameter [31:0] C_SUBW = 32'b????????????????100111???00???01;\n  parameter [31:0] C_ADDW = 32'b????????????????100111???01???01;\n  parameter [31:0] C_J = 32'b????????????????101???????????01;\n  parameter [31:0] C_BEQZ = 32'b????????????????110???????????01;\n  parameter [31:0] C_BNEZ = 32'b????????????????111???????????01;\n  parameter [31:0] C_SLLI = 32'b????????????????000???????????10;\n  parameter [31:0] C_FLDSP = 32'b????????????????001???????????10;\n  parameter [31:0] C_LWSP = 32'b????????????????010???????????10;\n  parameter [31:0] C_FLWSP = 32'b????????????????011???????????10;\n  parameter [31:0] C_MV = 32'b????????????????1000??????????10;\n  parameter [31:0] C_ADD = 32'b????????????????1001??????????10;\n  parameter [31:0] C_FSDSP = 32'b????????????????101???????????10;\n  parameter [31:0] C_SWSP = 32'b????????????????110???????????10;\n  parameter [31:0] C_FSWSP = 32'b????????????????111???????????10;\n  parameter [31:0] C_NOP = 32'b????????????????0000000000000001;\n  parameter [31:0] C_ADDI16SP = 32'b????????????????011?00010?????01;\n  parameter [31:0] C_JR = 32'b????????????????1000?????0000010;\n  parameter [31:0] C_JALR = 32'b????????????????1001?????0000010;\n  parameter [31:0] C_EBREAK = 32'b????????????????1001000000000010;\n  parameter [31:0] C_LD = 32'b????????????????011???????????00;\n  parameter [31:0] C_SD = 32'b????????????????111???????????00;\n  parameter [31:0] C_ADDIW = 32'b????????????????001???????????01;\n  parameter [31:0] C_LDSP = 32'b????????????????011???????????10;\n  parameter [31:0] C_SDSP = 32'b????????????????111???????????10;\n\nendpackage\n`endif\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 08.04.2017\n// Description: Issues instruction from the scoreboard and fetches the operands\n//              This also includes all the forwarding logic\n\n\nmodule issue_read_operands\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter type rs3_len_t = logic\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Flush - CONTROLLER\n    input logic flush_i,\n    // Stall inserted by Acc dispatcher - ACC_DISPATCHER\n    input logic stall_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input scoreboard_entry_t issue_instr_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic [31:0] orig_instr_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic issue_instr_valid_i,\n    // Issue stage acknowledge - TO_BE_COMPLETED\n    output logic issue_ack_o,\n    // rs1 operand address - scoreboard\n    output logic [REG_ADDR_SIZE-1:0] rs1_o,\n    // rs1 operand - scoreboard\n    input riscv::xlen_t rs1_i,\n    // rs1 operand is valid - scoreboard\n    input logic rs1_valid_i,\n    // rs2 operand address - scoreboard\n    output logic [REG_ADDR_SIZE-1:0] rs2_o,\n    // rs2 operand - scoreboard\n    input riscv::xlen_t rs2_i,\n    // rs2 operand is valid - scoreboard\n    input logic rs2_valid_i,\n    // rs3 operand address - scoreboard\n    output logic [REG_ADDR_SIZE-1:0] rs3_o,\n    // rs3 operand - scoreboard\n    input rs3_len_t rs3_i,\n    // rs3 operand is valid - scoreboard\n    input logic rs3_valid_i,\n    // get clobber input\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input fu_t [2**REG_ADDR_SIZE-1:0] rd_clobber_gpr_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input fu_t [2**REG_ADDR_SIZE-1:0] rd_clobber_fpr_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output fu_data_t fu_data_o,\n    // Unregistered version of fu_data_o.operanda - TO_BE_COMPLETED\n    output riscv::xlen_t rs1_forwarding_o,\n    // Unregistered version of fu_data_o.operandb - TO_BE_COMPLETED\n    output riscv::xlen_t rs2_forwarding_o,\n    // Instruction pc - TO_BE_COMPLETED\n    output logic [riscv::VLEN-1:0] pc_o,\n    // Is compressed instruction - TO_BE_COMPLETED\n    output logic is_compressed_instr_o,\n    // Fixed Latency Unit ready to accept new request - TO_BE_COMPLETED\n    input logic flu_ready_i,\n    // ALU output is valid - TO_BE_COMPLETED\n    output logic alu_valid_o,\n    // Branch instruction is valid - TO_BE_COMPLETED\n    output logic branch_valid_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output branchpredict_sbe_t branch_predict_o,\n    // Load Store Unit is ready - TO_BE_COMPLETED\n    input logic lsu_ready_i,\n    // Load Store Unit result is valid - TO_BE_COMPLETED\n    output logic lsu_valid_o,\n    // Mult result is valid - TO_BE_COMPLETED\n    output logic mult_valid_o,\n    // FPU is ready - TO_BE_COMPLETED\n    input logic fpu_ready_i,\n    // FPU result is valid - TO_BE_COMPLETED\n    output logic fpu_valid_o,\n    // FPU fmt field from instruction - TO_BE_COMPLETED\n    output logic [1:0] fpu_fmt_o,\n    // FPU rm field from isntruction - TO_BE_COMPLETED\n    output logic [2:0] fpu_rm_o,\n    // CSR result is valid - TO_BE_COMPLETED\n    output logic csr_valid_o,\n    // CVXIF result is valid - TO_BE_COMPLETED\n    output logic cvxif_valid_o,\n    // CVXIF is ready - TO_BE_COMPLETED\n    input logic cvxif_ready_i,\n    // CVXIF offloaded instruction - TO_BE_COMPLETED\n    output logic [31:0] cvxif_off_instr_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic [CVA6Cfg.NrCommitPorts-1:0][4:0] waddr_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic [CVA6Cfg.NrCommitPorts-1:0][riscv::XLEN-1:0] wdata_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic [CVA6Cfg.NrCommitPorts-1:0] we_gpr_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic [CVA6Cfg.NrCommitPorts-1:0] we_fpr_i,\n\n    // Stall signal, we do not want to fetch any more entries - TO_BE_COMPLETED\n    output logic stall_issue_o\n);\n  logic stall;\n  logic fu_busy;  // functional unit is busy\n  riscv::xlen_t operand_a_regfile, operand_b_regfile;  // operands coming from regfile\n  rs3_len_t\n      operand_c_regfile,\n      operand_c_fpr,\n      operand_c_gpr;  // third operand from fp regfile or gp regfile if NR_RGPR_PORTS == 3\n  // output flipflop (ID <-> EX)\n  riscv::xlen_t operand_a_n, operand_a_q, operand_b_n, operand_b_q, imm_n, imm_q, imm_forward_rs3;\n\n  logic        alu_valid_q;\n  logic        mult_valid_q;\n  logic        fpu_valid_q;\n  logic [ 1:0] fpu_fmt_q;\n  logic [ 2:0] fpu_rm_q;\n  logic        lsu_valid_q;\n  logic        csr_valid_q;\n  logic        branch_valid_q;\n  logic        cvxif_valid_q;\n  logic [31:0] cvxif_off_instr_q;\n\n  logic [TRANS_ID_BITS-1:0] trans_id_n, trans_id_q;\n  fu_op operator_n, operator_q;  // operation to perform\n  fu_t fu_n, fu_q;  // functional unit to use\n\n  // forwarding signals\n  logic forward_rs1, forward_rs2, forward_rs3;\n\n  // original instruction\n  riscv::instruction_t orig_instr;\n  assign orig_instr          = riscv::instruction_t'(orig_instr_i);\n\n  // ID <-> EX registers\n\n  assign rs1_forwarding_o    = operand_a_n[riscv::VLEN-1:0];  //forwarding or unregistered rs1 value\n  assign rs2_forwarding_o    = operand_b_n[riscv::VLEN-1:0];  //forwarding or unregistered rs2 value\n\n  assign fu_data_o.operand_a = operand_a_q;\n  assign fu_data_o.operand_b = operand_b_q;\n  assign fu_data_o.fu        = fu_q;\n  assign fu_data_o.operation = operator_q;\n  assign fu_data_o.trans_id  = trans_id_q;\n  assign fu_data_o.imm       = imm_q;\n  assign alu_valid_o         = alu_valid_q;\n  assign branch_valid_o      = branch_valid_q;\n  assign lsu_valid_o         = lsu_valid_q;\n  assign csr_valid_o         = csr_valid_q;\n  assign mult_valid_o        = mult_valid_q;\n  assign fpu_valid_o         = fpu_valid_q;\n  assign fpu_fmt_o           = fpu_fmt_q;\n  assign fpu_rm_o            = fpu_rm_q;\n  assign cvxif_valid_o       = CVA6Cfg.CvxifEn ? cvxif_valid_q : '0;\n  assign cvxif_off_instr_o   = CVA6Cfg.CvxifEn ? cvxif_off_instr_q : '0;\n  assign stall_issue_o       = stall;\n  // ---------------\n  // Issue Stage\n  // ---------------\n\n  // select the right busy signal\n  // this obviously depends on the functional unit we need\n  always_comb begin : unit_busy\n    unique case (issue_instr_i.fu)\n      NONE: fu_busy = 1'b0;\n      ALU, CTRL_FLOW, CSR, MULT: fu_busy = ~flu_ready_i;\n      LOAD, STORE: fu_busy = ~lsu_ready_i;\n      CVXIF: fu_busy = ~cvxif_ready_i;\n      default: begin\n        if (CVA6Cfg.FpPresent && (issue_instr_i.fu == FPU || issue_instr_i.fu == FPU_VEC)) begin\n          fu_busy = ~fpu_ready_i;\n        end else begin\n          fu_busy = 1'b0;\n        end\n      end\n    endcase\n  end\n\n  // ---------------\n  // Register stage\n  // ---------------\n  // check that all operands are available, otherwise stall\n  // forward corresponding register\n  always_comb begin : operands_available\n    stall = stall_i;\n    // operand forwarding signals\n    forward_rs1 = 1'b0;\n    forward_rs2 = 1'b0;\n    forward_rs3 = 1'b0;  // FPR only\n    // poll the scoreboard for those values\n    rs1_o = issue_instr_i.rs1;\n    rs2_o = issue_instr_i.rs2;\n    rs3_o = issue_instr_i.result[REG_ADDR_SIZE-1:0];  // rs3 is encoded in imm field\n\n    // 0. check that we are not using the zimm type in RS1\n    //    as this is an immediate we do not have to wait on anything here\n    // 1. check if the source registers are clobbered --> check appropriate clobber list (gpr/fpr)\n    // 2. poll the scoreboard\n    if (!issue_instr_i.use_zimm && ((CVA6Cfg.FpPresent && is_rs1_fpr(\n            issue_instr_i.op\n        )) ? rd_clobber_fpr_i[issue_instr_i.rs1] != NONE :\n            rd_clobber_gpr_i[issue_instr_i.rs1] != NONE)) begin\n      // check if the clobbering instruction is not a CSR instruction, CSR instructions can only\n      // be fetched through the register file since they can't be forwarded\n      // if the operand is available, forward it. CSRs don't write to/from FPR\n      if (rs1_valid_i && (CVA6Cfg.FpPresent && is_rs1_fpr(\n              issue_instr_i.op\n          ) ? 1'b1 : ((rd_clobber_gpr_i[issue_instr_i.rs1] != CSR) ||\n                      (CVA6Cfg.RVS && issue_instr_i.op == SFENCE_VMA)))) begin\n        forward_rs1 = 1'b1;\n      end else begin  // the operand is not available -> stall\n        stall = 1'b1;\n      end\n    end\n\n    if ((CVA6Cfg.FpPresent && is_rs2_fpr(\n            issue_instr_i.op\n        )) ? rd_clobber_fpr_i[issue_instr_i.rs2] != NONE :\n            rd_clobber_gpr_i[issue_instr_i.rs2] != NONE) begin\n      // if the operand is available, forward it. CSRs don't write to/from FPR\n      if (rs2_valid_i && (CVA6Cfg.FpPresent && is_rs2_fpr(\n              issue_instr_i.op\n          ) ? 1'b1 : ((rd_clobber_gpr_i[issue_instr_i.rs2] != CSR) ||\n                      (CVA6Cfg.RVS && issue_instr_i.op == SFENCE_VMA)))) begin\n        forward_rs2 = 1'b1;\n      end else begin  // the operand is not available -> stall\n        stall = 1'b1;\n      end\n    end\n\n    // Only check clobbered gpr for OFFLOADED instruction\n    if ((CVA6Cfg.FpPresent && is_imm_fpr(\n            issue_instr_i.op\n        )) ? rd_clobber_fpr_i[issue_instr_i.result[REG_ADDR_SIZE-1:0]] != NONE :\n            issue_instr_i.op == OFFLOAD && CVA6Cfg.NrRgprPorts == 3 ?\n            rd_clobber_gpr_i[issue_instr_i.result[REG_ADDR_SIZE-1:0]] != NONE : 0) begin\n      // if the operand is available, forward it. CSRs don't write to/from FPR so no need to check\n      if (rs3_valid_i) begin\n        forward_rs3 = 1'b1;\n      end else begin  // the operand is not available -> stall\n        stall = 1'b1;\n      end\n    end\n  end\n\n  // third operand from fp regfile or gp regfile if NR_RGPR_PORTS == 3\n  if (CVA6Cfg.NrRgprPorts == 3) begin : gen_gp_rs3\n    assign imm_forward_rs3 = rs3_i;\n  end else begin : gen_fp_rs3\n    assign imm_forward_rs3 = {{riscv::XLEN - CVA6Cfg.FLen{1'b0}}, rs3_i};\n  end\n\n  // Forwarding/Output MUX\n  always_comb begin : forwarding_operand_select\n    // default is regfiles (gpr or fpr)\n    operand_a_n = operand_a_regfile;\n    operand_b_n = operand_b_regfile;\n    // immediates are the third operands in the store case\n    // for FP operations, the imm field can also be the third operand from the regfile\n    if (CVA6Cfg.NrRgprPorts == 3) begin\n      imm_n = (CVA6Cfg.FpPresent && is_imm_fpr(issue_instr_i.op)) ?\n          {{riscv::XLEN - CVA6Cfg.FLen{1'b0}}, operand_c_regfile} :\n          issue_instr_i.op == OFFLOAD ? operand_c_regfile : issue_instr_i.result;\n    end else begin\n      imm_n = (CVA6Cfg.FpPresent && is_imm_fpr(issue_instr_i.op)) ?\n          {{riscv::XLEN - CVA6Cfg.FLen{1'b0}}, operand_c_regfile} : issue_instr_i.result;\n    end\n    trans_id_n = issue_instr_i.trans_id;\n    fu_n       = issue_instr_i.fu;\n    operator_n = issue_instr_i.op;\n    // or should we forward\n    if (forward_rs1) begin\n      operand_a_n = rs1_i;\n    end\n\n    if (forward_rs2) begin\n      operand_b_n = rs2_i;\n    end\n\n    if (CVA6Cfg.FpPresent && forward_rs3) begin\n      imm_n = imm_forward_rs3;\n    end\n\n    // use the PC as operand a\n    if (issue_instr_i.use_pc) begin\n      operand_a_n = {\n        {riscv::XLEN - riscv::VLEN{issue_instr_i.pc[riscv::VLEN-1]}}, issue_instr_i.pc\n      };\n    end\n\n    // use the zimm as operand a\n    if (issue_instr_i.use_zimm) begin\n      // zero extend operand a\n      operand_a_n = {{riscv::XLEN - 5{1'b0}}, issue_instr_i.rs1[4:0]};\n    end\n    // or is it an immediate (including PC), this is not the case for a store, control flow, and accelerator instructions\n    // also make sure operand B is not already used as an FP operand\n    if (issue_instr_i.use_imm && (issue_instr_i.fu != STORE) && (issue_instr_i.fu != CTRL_FLOW) && (issue_instr_i.fu != ACCEL) && !(CVA6Cfg.FpPresent && is_rs2_fpr(\n            issue_instr_i.op\n        ))) begin\n      operand_b_n = issue_instr_i.result;\n    end\n  end\n\n  // FU select, assert the correct valid out signal (in the next cycle)\n  // This needs to be like this to make verilator happy. I know its ugly.\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      alu_valid_q    <= 1'b0;\n      lsu_valid_q    <= 1'b0;\n      mult_valid_q   <= 1'b0;\n      fpu_valid_q    <= 1'b0;\n      fpu_fmt_q      <= 2'b0;\n      fpu_rm_q       <= 3'b0;\n      csr_valid_q    <= 1'b0;\n      branch_valid_q <= 1'b0;\n    end else begin\n      alu_valid_q    <= 1'b0;\n      lsu_valid_q    <= 1'b0;\n      mult_valid_q   <= 1'b0;\n      fpu_valid_q    <= 1'b0;\n      fpu_fmt_q      <= 2'b0;\n      fpu_rm_q       <= 3'b0;\n      csr_valid_q    <= 1'b0;\n      branch_valid_q <= 1'b0;\n      // Exception pass through:\n      // If an exception has occurred simply pass it through\n      // we do not want to issue this instruction\n      if (!issue_instr_i.ex.valid && issue_instr_valid_i && issue_ack_o) begin\n        case (issue_instr_i.fu)\n          ALU: begin\n            alu_valid_q <= 1'b1;\n          end\n          CTRL_FLOW: begin\n            branch_valid_q <= 1'b1;\n          end\n          MULT: begin\n            mult_valid_q <= 1'b1;\n          end\n          LOAD, STORE: begin\n            lsu_valid_q <= 1'b1;\n          end\n          CSR: begin\n            csr_valid_q <= 1'b1;\n          end\n          default: begin\n            if (issue_instr_i.fu == FPU && CVA6Cfg.FpPresent) begin\n              fpu_valid_q <= 1'b1;\n              fpu_fmt_q   <= orig_instr.rftype.fmt;  // fmt bits from instruction\n              fpu_rm_q    <= orig_instr.rftype.rm;  // rm bits from instruction\n            end else if (issue_instr_i.fu == FPU_VEC && CVA6Cfg.FpPresent) begin\n              fpu_valid_q <= 1'b1;\n              fpu_fmt_q   <= orig_instr.rvftype.vfmt;  // vfmt bits from instruction\n              fpu_rm_q    <= {2'b0, orig_instr.rvftype.repl};  // repl bit from instruction\n            end\n          end\n        endcase\n      end\n      // if we got a flush request, de-assert the valid flag, otherwise we will start this\n      // functional unit with the wrong inputs\n      if (flush_i) begin\n        alu_valid_q    <= 1'b0;\n        lsu_valid_q    <= 1'b0;\n        mult_valid_q   <= 1'b0;\n        fpu_valid_q    <= 1'b0;\n        csr_valid_q    <= 1'b0;\n        branch_valid_q <= 1'b0;\n      end\n    end\n  end\n\n  if (CVA6Cfg.CvxifEn) begin\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (!rst_ni) begin\n        cvxif_valid_q <= 1'b0;\n        cvxif_off_instr_q <= 32'b0;\n      end else begin\n        cvxif_valid_q <= 1'b0;\n        cvxif_off_instr_q <= 32'b0;\n        if (!issue_instr_i.ex.valid && issue_instr_valid_i && issue_ack_o) begin\n          case (issue_instr_i.fu)\n            CVXIF: begin\n              cvxif_valid_q     <= 1'b1;\n              cvxif_off_instr_q <= orig_instr;\n            end\n            default: ;\n          endcase\n        end\n        if (flush_i) begin\n          cvxif_valid_q <= 1'b0;\n          cvxif_off_instr_q <= 32'b0;\n        end\n      end\n    end\n  end\n\n  // We can issue an instruction if we do not detect that any other instruction is writing the same\n  // destination register.\n  // We also need to check if there is an unresolved branch in the scoreboard.\n  always_comb begin : issue_scoreboard\n    // default assignment\n    issue_ack_o = 1'b0;\n    // check that we didn't stall, that the instruction we got is valid\n    // and that the functional unit we need is not busy\n    if (issue_instr_valid_i) begin\n      // check that the corresponding functional unit is not busy\n      if (!stall && !fu_busy) begin\n        // -----------------------------------------\n        // WAW - Write After Write Dependency Check\n        // -----------------------------------------\n        // no other instruction has the same destination register -> issue the instruction\n        if ((CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(\n                issue_instr_i.op\n            )) ? (rd_clobber_fpr_i[issue_instr_i.rd] == NONE) :\n                (rd_clobber_gpr_i[issue_instr_i.rd] == NONE)) begin\n          issue_ack_o = 1'b1;\n        end\n        // or check that the target destination register will be written in this cycle by the\n        // commit stage\n        for (int unsigned i = 0; i < CVA6Cfg.NrCommitPorts; i++)\n        if ((CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(\n                issue_instr_i.op\n            )) ? (we_fpr_i[i] && waddr_i[i] == issue_instr_i.rd[4:0]) :\n                (we_gpr_i[i] && waddr_i[i] == issue_instr_i.rd[4:0])) begin\n          issue_ack_o = 1'b1;\n        end\n\n      end\n      // we can also issue the instruction under the following two circumstances:\n      // we can do this even if we are stalled or no functional unit is ready (as we don't need one)\n      // the decoder needs to make sure that the instruction is marked as valid when it does not\n      // need any functional unit or if an exception occurred previous to the execute stage.\n      // 1. we already got an exception\n      if (issue_instr_i.ex.valid) begin\n        issue_ack_o = 1'b1;\n      end\n      // 2. it is an instruction which does not need any functional unit\n      if (issue_instr_i.fu == NONE) begin\n        issue_ack_o = 1'b1;\n      end\n    end\n    // after a multiplication was issued we can only issue another multiplication\n    // otherwise we will get contentions on the fixed latency bus\n    if (mult_valid_q && issue_instr_i.fu inside {ALU, CTRL_FLOW, CSR}) begin\n      issue_ack_o = 1'b0;\n    end\n  end\n\n  // ----------------------\n  // Integer Register File\n  // ----------------------\n  logic [  CVA6Cfg.NrRgprPorts-1:0][riscv::XLEN-1:0] rdata;\n  logic [  CVA6Cfg.NrRgprPorts-1:0][            4:0] raddr_pack;\n\n  // pack signals\n  logic [CVA6Cfg.NrCommitPorts-1:0][            4:0] waddr_pack;\n  logic [CVA6Cfg.NrCommitPorts-1:0][riscv::XLEN-1:0] wdata_pack;\n  logic [CVA6Cfg.NrCommitPorts-1:0]                  we_pack;\n\n  if (CVA6Cfg.NrRgprPorts == 3) begin : gen_rs3\n    assign raddr_pack = {issue_instr_i.result[4:0], issue_instr_i.rs2[4:0], issue_instr_i.rs1[4:0]};\n  end else begin : gen_no_rs3\n    assign raddr_pack = {issue_instr_i.rs2[4:0], issue_instr_i.rs1[4:0]};\n  end\n\n  for (genvar i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin : gen_write_back_port\n    assign waddr_pack[i] = waddr_i[i];\n    assign wdata_pack[i] = wdata_i[i];\n    assign we_pack[i]    = we_gpr_i[i];\n  end\n  if (ariane_pkg::FPGA_EN) begin : gen_fpga_regfile\n    ariane_regfile_fpga #(\n        .CVA6Cfg      (CVA6Cfg),\n        .DATA_WIDTH   (riscv::XLEN),\n        .NR_READ_PORTS(CVA6Cfg.NrRgprPorts),\n        .ZERO_REG_ZERO(1)\n    ) i_ariane_regfile_fpga (\n        .test_en_i(1'b0),\n        .raddr_i  (raddr_pack),\n        .rdata_o  (rdata),\n        .waddr_i  (waddr_pack),\n        .wdata_i  (wdata_pack),\n        .we_i     (we_pack),\n        .*\n    );\n  end else begin : gen_asic_regfile\n    ariane_regfile #(\n        .CVA6Cfg      (CVA6Cfg),\n        .DATA_WIDTH   (riscv::XLEN),\n        .NR_READ_PORTS(CVA6Cfg.NrRgprPorts),\n        .ZERO_REG_ZERO(1)\n    ) i_ariane_regfile (\n        .test_en_i(1'b0),\n        .raddr_i  (raddr_pack),\n        .rdata_o  (rdata),\n        .waddr_i  (waddr_pack),\n        .wdata_i  (wdata_pack),\n        .we_i     (we_pack),\n        .*\n    );\n  end\n\n  // -----------------------------\n  // Floating-Point Register File\n  // -----------------------------\n  logic [2:0][CVA6Cfg.FLen-1:0] fprdata;\n\n  // pack"}
{"text": " signals\n  logic [2:0][4:0] fp_raddr_pack;\n  logic [CVA6Cfg.NrCommitPorts-1:0][riscv::XLEN-1:0] fp_wdata_pack;\n\n  generate\n    if (CVA6Cfg.FpPresent) begin : float_regfile_gen\n      assign fp_raddr_pack = {\n        issue_instr_i.result[4:0], issue_instr_i.rs2[4:0], issue_instr_i.rs1[4:0]\n      };\n      for (genvar i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin : gen_fp_wdata_pack\n        assign fp_wdata_pack[i] = {wdata_i[i][CVA6Cfg.FLen-1:0]};\n      end\n      if (ariane_pkg::FPGA_EN) begin : gen_fpga_fp_regfile\n        ariane_regfile_fpga #(\n            .CVA6Cfg      (CVA6Cfg),\n            .DATA_WIDTH   (CVA6Cfg.FLen),\n            .NR_READ_PORTS(3),\n            .ZERO_REG_ZERO(0)\n        ) i_ariane_fp_regfile_fpga (\n            .test_en_i(1'b0),\n            .raddr_i  (fp_raddr_pack),\n            .rdata_o  (fprdata),\n            .waddr_i  (waddr_pack),\n            .wdata_i  (fp_wdata_pack),\n            .we_i     (we_fpr_i),\n            .*\n        );\n      end else begin : gen_asic_fp_regfile\n        ariane_regfile #(\n            .CVA6Cfg      (CVA6Cfg),\n            .DATA_WIDTH   (CVA6Cfg.FLen),\n            .NR_READ_PORTS(3),\n            .ZERO_REG_ZERO(0)\n        ) i_ariane_fp_regfile (\n            .test_en_i(1'b0),\n            .raddr_i  (fp_raddr_pack),\n            .rdata_o  (fprdata),\n            .waddr_i  (waddr_pack),\n            .wdata_i  (fp_wdata_pack),\n            .we_i     (we_fpr_i),\n            .*\n        );\n      end\n    end else begin : no_fpr_gen\n      assign fprdata = '{default: '0};\n    end\n  endgenerate\n\n  if (CVA6Cfg.NrRgprPorts == 3) begin : gen_operand_c\n    assign operand_c_fpr = {{riscv::XLEN - CVA6Cfg.FLen{1'b0}}, fprdata[2]};\n    assign operand_c_gpr = rdata[2];\n  end else begin\n    assign operand_c_fpr = fprdata[2];\n  end\n\n  assign operand_a_regfile = (CVA6Cfg.FpPresent && is_rs1_fpr(\n      issue_instr_i.op\n  )) ? {{riscv::XLEN - CVA6Cfg.FLen{1'b0}}, fprdata[0]} : rdata[0];\n  assign operand_b_regfile = (CVA6Cfg.FpPresent && is_rs2_fpr(\n      issue_instr_i.op\n  )) ? {{riscv::XLEN - CVA6Cfg.FLen{1'b0}}, fprdata[1]} : rdata[1];\n  assign operand_c_regfile = (CVA6Cfg.NrRgprPorts == 3) ? ((CVA6Cfg.FpPresent && is_imm_fpr(\n      issue_instr_i.op\n  )) ? operand_c_fpr : operand_c_gpr) : operand_c_fpr;\n\n\n  // ----------------------\n  // Registers (ID <-> EX)\n  // ----------------------\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      operand_a_q           <= '{default: 0};\n      operand_b_q           <= '{default: 0};\n      imm_q                 <= '0;\n      fu_q                  <= NONE;\n      operator_q            <= ADD;\n      trans_id_q            <= '0;\n      pc_o                  <= '0;\n      is_compressed_instr_o <= 1'b0;\n      branch_predict_o      <= {cf_t'(0), {riscv::VLEN{1'b0}}};\n    end else begin\n      operand_a_q           <= operand_a_n;\n      operand_b_q           <= operand_b_n;\n      imm_q                 <= imm_n;\n      fu_q                  <= fu_n;\n      operator_q            <= operator_n;\n      trans_id_q            <= trans_id_n;\n      pc_o                  <= issue_instr_i.pc;\n      is_compressed_instr_o <= issue_instr_i.is_compressed;\n      branch_predict_o      <= issue_instr_i.bp;\n    end\n  end\n\n  //pragma translate_off\n  initial begin\n    assert (CVA6Cfg.NrRgprPorts == 2 || (CVA6Cfg.NrRgprPorts == 3 && CVA6Cfg.CvxifEn))\n    else\n      $fatal(\n          1,\n          \"If CVXIF is enable, ariane regfile can have either 2 or 3 read ports. Else it has 2 read ports.\"\n      );\n  end\n\n  assert property (@(posedge clk_i) (branch_valid_q) |-> (!$isunknown(\n      operand_a_q\n  ) && !$isunknown(\n      operand_b_q\n  )))\n  else $warning(\"Got unknown value in one of the operands\");\n\n  //pragma translate_on\nendmodule\n\n\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 21.05.2017\n// Description: Issue stage dispatches instructions to the FUs and keeps track of them\n//              in a scoreboard like data-structure.\n\n\nmodule issue_stage\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Is scoreboard full - PERF_COUNTERS\n    output logic sb_full_o,\n    // TO_BE_COMPLETED - CONTROLLER\n    input logic flush_unissued_instr_i,\n    // TO_BE_COMPLETED - CONTROLLER\n    input logic flush_i,\n    // Stall inserted by Acc dispatcher - ACC_DISPATCHER\n    input logic stall_i,\n    // Handshake's data with decode stage - ID_STAGE\n    input scoreboard_entry_t decoded_instr_i,\n    // instruction value - ID_STAGE\n    input logic [31:0] orig_instr_i,\n    // Handshake's valid with decode stage - ID_STAGE\n    input logic decoded_instr_valid_i,\n    // Is instruction a control flow instruction - ID_STAGE\n    input logic is_ctrl_flow_i,\n    // Handshake's acknowlege with decode stage - ID_STAGE\n    output logic decoded_instr_ack_o,\n    // rs1 forwarding - EX_STAGE\n    output [riscv::VLEN-1:0] rs1_forwarding_o,\n    // rs2 forwarding - EX_STAGE\n    output [riscv::VLEN-1:0] rs2_forwarding_o,\n    // FU data useful to execute instruction - EX_STAGE\n    output fu_data_t fu_data_o,\n    // Program Counter - EX_STAGE\n    output logic [riscv::VLEN-1:0] pc_o,\n    // Is compressed instruction - EX_STAGE\n    output logic is_compressed_instr_o,\n    // Fixed Latency Unit is ready - EX_STAGE\n    input logic flu_ready_i,\n    // ALU FU is valid - EX_STAGE\n    output logic alu_valid_o,\n    // Signaling that we resolved the branch - EX_STAGE\n    input logic resolve_branch_i,\n    // Load store unit FU is ready - EX_STAGE\n    input logic lsu_ready_i,\n    // Load store unit FU is valid - EX_STAGE\n    output logic lsu_valid_o,\n    // Branch unit is valid - EX_STAGE\n    output logic branch_valid_o,\n    // Information of branch prediction - EX_STAGE\n    output branchpredict_sbe_t branch_predict_o,\n    // Mult FU is valid - EX_STAGE\n    output logic mult_valid_o,\n    // FPU FU is ready - EX_STAGE\n    input logic fpu_ready_i,\n    // FPU FU is valid - EX_STAGE\n    output logic fpu_valid_o,\n    // FPU fmt field - EX_STAGE\n    output logic [1:0] fpu_fmt_o,\n    // FPU rm field - EX_STAGE\n    output logic [2:0] fpu_rm_o,\n    // CSR is valid - EX_STAGE\n    output logic csr_valid_o,\n    // CVXIF FU is valid - EX_STAGE\n    output logic x_issue_valid_o,\n    // CVXIF is FU ready - EX_STAGE\n    input logic x_issue_ready_i,\n    // CVXIF offloader instruction value - EX_STAGE\n    output logic [31:0] x_off_instr_o,\n    // Issue scoreboard entry - ACC_DISPATCHER\n    output scoreboard_entry_t issue_instr_o,\n    // TO_BE_COMPLETED - ACC_DISPATCHER\n    output logic issue_instr_hs_o,\n    // Transaction ID - EX_STAGE\n    input logic [CVA6Cfg.NrWbPorts-1:0][TRANS_ID_BITS-1:0] trans_id_i,\n    // The branch engine uses the write back from the ALU - EX_STAGE\n    input bp_resolve_t resolved_branch_i,\n    // TO_BE_COMPLETED - EX_STAGE\n    input logic [CVA6Cfg.NrWbPorts-1:0][riscv::XLEN-1:0] wbdata_i,\n    // exception from execute stage or CVXIF - EX_STAGE\n    input exception_t [CVA6Cfg.NrWbPorts-1:0] ex_ex_i,\n    // TO_BE_COMPLETED - EX_STAGE\n    input logic [CVA6Cfg.NrWbPorts-1:0] wt_valid_i,\n    // CVXIF write enable - EX_STAGE\n    input logic x_we_i,\n    // TO_BE_COMPLETED - EX_STAGE\n    input logic [CVA6Cfg.NrCommitPorts-1:0][4:0] waddr_i,\n    // TO_BE_COMPLETED - EX_STAGE\n    input logic [CVA6Cfg.NrCommitPorts-1:0][riscv::XLEN-1:0] wdata_i,\n    // GPR write enable - EX_STAGE\n    input logic [CVA6Cfg.NrCommitPorts-1:0] we_gpr_i,\n    // FPR write enable - EX_STAGE\n    input logic [CVA6Cfg.NrCommitPorts-1:0] we_fpr_i,\n    // Instructions to commit - COMMIT_STAGE\n    output scoreboard_entry_t [CVA6Cfg.NrCommitPorts-1:0] commit_instr_o,\n    // Commit acknowledge - COMMIT_STAGE\n    input logic [CVA6Cfg.NrCommitPorts-1:0] commit_ack_i,\n    // Issue stall - PERF_COUNTERS\n    output logic stall_issue_o,\n    // Information dedicated to RVFI - RVFI\n    output logic [TRANS_ID_BITS-1:0] rvfi_issue_pointer_o,\n    // Information dedicated to RVFI - RVFI\n    output logic [CVA6Cfg.NrCommitPorts-1:0][TRANS_ID_BITS-1:0] rvfi_commit_pointer_o\n);\n  // ---------------------------------------------------\n  // Scoreboard (SB) <-> Issue and Read Operands (IRO)\n  // ---------------------------------------------------\n  typedef logic [(CVA6Cfg.NrRgprPorts == 3 ? riscv::XLEN : CVA6Cfg.FLen)-1:0] rs3_len_t;\n\n  fu_t               [2**REG_ADDR_SIZE-1:0] rd_clobber_gpr_sb_iro;\n  fu_t               [2**REG_ADDR_SIZE-1:0] rd_clobber_fpr_sb_iro;\n\n  logic              [   REG_ADDR_SIZE-1:0] rs1_iro_sb;\n  riscv::xlen_t                             rs1_sb_iro;\n  logic                                     rs1_valid_sb_iro;\n\n  logic              [   REG_ADDR_SIZE-1:0] rs2_iro_sb;\n  riscv::xlen_t                             rs2_sb_iro;\n  logic                                     rs2_valid_iro_sb;\n\n  logic              [   REG_ADDR_SIZE-1:0] rs3_iro_sb;\n  rs3_len_t                                 rs3_sb_iro;\n  logic                                     rs3_valid_iro_sb;\n\n  scoreboard_entry_t                        issue_instr_sb_iro;\n  logic              [                31:0] orig_instr_sb_iro;\n  logic                                     issue_instr_valid_sb_iro;\n  logic                                     issue_ack_iro_sb;\n\n  riscv::xlen_t                             rs1_forwarding_xlen;\n  riscv::xlen_t                             rs2_forwarding_xlen;\n\n  assign rs1_forwarding_o = rs1_forwarding_xlen[riscv::VLEN-1:0];\n  assign rs2_forwarding_o = rs2_forwarding_xlen[riscv::VLEN-1:0];\n\n  assign issue_instr_o    = issue_instr_sb_iro;\n  assign issue_instr_hs_o = issue_instr_valid_sb_iro & issue_ack_iro_sb;\n\n\n  // ---------------------------------------------------------\n  // 2. Manage instructions in a scoreboard\n  // ---------------------------------------------------------\n  scoreboard #(\n      .CVA6Cfg  (CVA6Cfg),\n      .rs3_len_t(rs3_len_t)\n  ) i_scoreboard (\n      .sb_full_o          (sb_full_o),\n      .unresolved_branch_i(1'b0),\n      .rd_clobber_gpr_o   (rd_clobber_gpr_sb_iro),\n      .rd_clobber_fpr_o   (rd_clobber_fpr_sb_iro),\n      .rs1_i              (rs1_iro_sb),\n      .rs1_o              (rs1_sb_iro),\n      .rs1_valid_o        (rs1_valid_sb_iro),\n      .rs2_i              (rs2_iro_sb),\n      .rs2_o              (rs2_sb_iro),\n      .rs2_valid_o        (rs2_valid_iro_sb),\n      .rs3_i              (rs3_iro_sb),\n      .rs3_o              (rs3_sb_iro),\n      .rs3_valid_o        (rs3_valid_iro_sb),\n\n      .decoded_instr_i      (decoded_instr_i),\n      .decoded_instr_valid_i(decoded_instr_valid_i),\n      .decoded_instr_ack_o  (decoded_instr_ack_o),\n      .issue_instr_o        (issue_instr_sb_iro),\n      .orig_instr_o         (orig_instr_sb_iro),\n      .issue_instr_valid_o  (issue_instr_valid_sb_iro),\n      .issue_ack_i          (issue_ack_iro_sb),\n\n      .resolved_branch_i(resolved_branch_i),\n      .trans_id_i       (trans_id_i),\n      .wbdata_i         (wbdata_i),\n      .ex_i             (ex_ex_i),\n      .*\n  );\n\n  // ---------------------------------------------------------\n  // 3. Issue instruction and read operand, also commit\n  // ---------------------------------------------------------\n  issue_read_operands #(\n      .CVA6Cfg  (CVA6Cfg),\n      .rs3_len_t(rs3_len_t)\n  ) i_issue_read_operands (\n      .flush_i            (flush_unissued_instr_i),\n      .issue_instr_i      (issue_instr_sb_iro),\n      .orig_instr_i       (orig_instr_sb_iro),\n      .issue_instr_valid_i(issue_instr_valid_sb_iro),\n      .issue_ack_o        (issue_ack_iro_sb),\n      .fu_data_o          (fu_data_o),\n      .flu_ready_i        (flu_ready_i),\n      .rs1_o              (rs1_iro_sb),\n      .rs1_i              (rs1_sb_iro),\n      .rs1_valid_i        (rs1_valid_sb_iro),\n      .rs2_o              (rs2_iro_sb),\n      .rs2_i              (rs2_sb_iro),\n      .rs2_valid_i        (rs2_valid_iro_sb),\n      .rs3_o              (rs3_iro_sb),\n      .rs3_i              (rs3_sb_iro),\n      .rs3_valid_i        (rs3_valid_iro_sb),\n      .rd_clobber_gpr_i   (rd_clobber_gpr_sb_iro),\n      .rd_clobber_fpr_i   (rd_clobber_fpr_sb_iro),\n      .alu_valid_o        (alu_valid_o),\n      .branch_valid_o     (branch_valid_o),\n      .csr_valid_o        (csr_valid_o),\n      .cvxif_valid_o      (x_issue_valid_o),\n      .cvxif_ready_i      (x_issue_ready_i),\n      .cvxif_off_instr_o  (x_off_instr_o),\n      .mult_valid_o       (mult_valid_o),\n      .rs1_forwarding_o   (rs1_forwarding_xlen),\n      .rs2_forwarding_o   (rs2_forwarding_xlen),\n      .stall_issue_o      (stall_issue_o),\n      .*\n  );\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 19.04.2017\n// Description: Load Store Unit, handles address calculation and memory interface signals\n\n\nmodule load_store_unit\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int unsigned ASID_WIDTH = 1\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic flush_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic stall_st_pending_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output logic no_st_pending_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic amo_valid_commit_i,\n    // FU data needed to execute instruction - ISSUE_STAGE\n    input fu_data_t fu_data_i,\n    // Load Store Unit is ready - ISSUE_STAGE\n    output logic lsu_ready_o,\n    // Load Store Unit instruction is valid - ISSUE_STAGE\n    input logic lsu_valid_i,\n\n    // Load transaction ID - ISSUE_STAGE\n    output logic [TRANS_ID_BITS-1:0] load_trans_id_o,\n    // Load result - ISSUE_STAGE\n    output riscv::xlen_t load_result_o,\n    // Load result is valid - ISSUE_STAGE\n    output logic load_valid_o,\n    // Load exception - ISSUE_STAGE\n    output exception_t load_exception_o,\n\n    // Store transaction ID - ISSUE_STAGE\n    output logic [TRANS_ID_BITS-1:0] store_trans_id_o,\n    // Store result - ISSUE_STAGE\n    output riscv::xlen_t store_result_o,\n    // Store result is valid - ISSUE_STAGE\n    output logic store_valid_o,\n    // Store exception - ISSUE_STAGE\n    output exception_t store_exception_o,\n\n    // Commit the first pending store - TO_BE_COMPLETED\n    input logic commit_i,\n    // Commit queue is ready to accept another commit request - TO_BE_COMPLETED\n    output logic commit_ready_o,\n    // Commit transaction ID - TO_BE_COMPLETED\n    input logic [TRANS_ID_BITS-1:0] commit_tran_id_i,\n\n    // Enable virtual memory translation - TO_BE_COMPLETED\n    input logic enable_translation_i,\n    // Enable virtual memory translation for load/stores - TO_BE_COMPLETED\n    input logic en_ld_st_translation_i,\n\n    // Instruction cache input request - CACHES\n    input  icache_arsp_t icache_areq_i,\n    // Instruction cache output request - CACHES\n    output icache_areq_t icache_areq_o,\n\n    // Current privilege mode - CSR_REGFILE\n    input  riscv::priv_lvl_t                   priv_lvl_i,\n    // Privilege level at which load and stores should happen - CSR_REGFILE\n    input  riscv::priv_lvl_t                   ld_st_priv_lvl_i,\n    // Supervisor User Memory - CSR_REGFILE\n    input  logic                               sum_i,\n    // Make Executable Readable - CSR_REGFILE\n    input  logic                               mxr_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input  logic             [riscv::PPNW-1:0] satp_ppn_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input  logic             [ ASID_WIDTH-1:0] asid_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input  logic             [ ASID_WIDTH-1:0] asid_to_be_flushed_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input  logic             [riscv::VLEN-1:0] vaddr_to_be_flushed_i,\n    // TLB flush - CONTROLLER\n    input  logic                               flush_tlb_i,\n    // Instruction TLB miss - PERF_COUNTERS\n    output logic                               itlb_miss_o,\n    // Data TLB miss - PERF_COUNTERS\n    output logic                               dtlb_miss_o,\n\n    // Data cache request output - CACHES\n    input  dcache_req_o_t  [ 2:0]                  dcache_req_ports_i,\n    // Data cache request input - CACHES\n    output dcache_req_i_t  [ 2:0]                  dcache_req_ports_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input  logic                                   dcache_wbuffer_empty_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input  logic                                   dcache_wbuffer_not_ni_i,\n    // AMO request - CACHE\n    output amo_req_t                               amo_req_o,\n    // AMO response - CACHE\n    input  amo_resp_t                              amo_resp_i,\n    // PMP configuration - CSR_REGFILE\n    input  riscv::pmpcfg_t [15:0]                  pmpcfg_i,\n    // PMP address - CSR_REGFILE\n    input  logic           [15:0][riscv::PLEN-3:0] pmpaddr_i,\n\n    // RVFI inforamtion - RVFI\n    output lsu_ctrl_t                   rvfi_lsu_ctrl_o,\n    // RVFI information - RVFI\n    output            [riscv::PLEN-1:0] rvfi_mem_paddr_o\n);\n  // data is misaligned\n  logic                               data_misaligned;\n  // --------------------------------------\n  // 1st register stage - (stall registers)\n  // --------------------------------------\n  // those are the signals which are always correct\n  // e.g.: they keep the value in the stall case\n  lsu_ctrl_t                          lsu_ctrl;\n\n  logic                               pop_st;\n  logic                               pop_ld;\n\n  // ------------------------------\n  // Address Generation Unit (AGU)\n  // ------------------------------\n  // virtual address as calculated by the AGU in the first cycle\n  logic         [    riscv::VLEN-1:0] vaddr_i;\n  riscv::xlen_t                       vaddr_xlen;\n  logic                               overflow;\n  logic         [(riscv::XLEN/8)-1:0] be_i;\n\n  assign vaddr_xlen = $unsigned($signed(fu_data_i.imm) + $signed(fu_data_i.operand_a));\n  assign vaddr_i = vaddr_xlen[riscv::VLEN-1:0];\n  // we work with SV39 or SV32, so if VM is enabled, check that all bits [XLEN-1:38] or [XLEN-1:31] are equal\n  assign overflow = (riscv::IS_XLEN64 && (!((&vaddr_xlen[riscv::XLEN-1:riscv::SV-1]) == 1'b1 || (|vaddr_xlen[riscv::XLEN-1:riscv::SV-1]) == 1'b0)));\n\n  logic                   st_valid_i;\n  logic                   ld_valid_i;\n  logic                   ld_translation_req;\n  logic                   st_translation_req;\n  logic [riscv::VLEN-1:0] ld_vaddr;\n  logic [riscv::VLEN-1:0] st_vaddr;\n  logic                   translation_req;\n  logic                   translation_valid;\n  logic [riscv::VLEN-1:0] mmu_vaddr;\n  logic [riscv::PLEN-1:0] mmu_paddr, mmu_vaddr_plen, fetch_vaddr_plen;\n  exception_t                       mmu_exception;\n  logic                             dtlb_hit;\n  logic         [  riscv::PPNW-1:0] dtlb_ppn;\n\n  logic                             ld_valid;\n  logic         [TRANS_ID_BITS-1:0] ld_trans_id;\n  riscv::xlen_t                     ld_result;\n  logic                             st_valid;\n  logic         [TRANS_ID_BITS-1:0] st_trans_id;\n  riscv::xlen_t                     st_result;\n\n  logic         [             11:0] page_offset;\n  logic                             page_offset_matches;\n\n  exception_t                       misaligned_exception;\n  exception_t                       ld_ex;\n  exception_t                       st_ex;\n\n  // -------------------\n  // MMU e.g.: TLBs/PTW\n  // -------------------\n  if (MMU_PRESENT && (riscv::XLEN == 64)) begin : gen_mmu_sv39\n    mmu #(\n        .CVA6Cfg          (CVA6Cfg),\n        .INSTR_TLB_ENTRIES(ariane_pkg::INSTR_TLB_ENTRIES),\n        .DATA_TLB_ENTRIES (ariane_pkg::DATA_TLB_ENTRIES),\n        .ASID_WIDTH       (ASID_WIDTH)\n    ) i_cva6_mmu (\n        // misaligned bypass\n        .misaligned_ex_i(misaligned_exception),\n        .lsu_is_store_i (st_translation_req),\n        .lsu_req_i      (translation_req),\n        .lsu_vaddr_i    (mmu_vaddr),\n        .lsu_valid_o    (translation_valid),\n        .lsu_paddr_o    (mmu_paddr),\n        .lsu_exception_o(mmu_exception),\n        .lsu_dtlb_hit_o (dtlb_hit),               // send in the same cycle as the request\n        .lsu_dtlb_ppn_o (dtlb_ppn),               // send in the same cycle as the request\n        // connecting PTW to D$ IF\n        .req_port_i     (dcache_req_ports_i[0]),\n        .req_port_o     (dcache_req_ports_o[0]),\n        // icache address translation requests\n        .icache_areq_i  (icache_areq_i),\n        .asid_to_be_flushed_i,\n        .vaddr_to_be_flushed_i,\n        .icache_areq_o  (icache_areq_o),\n        .pmpcfg_i,\n        .pmpaddr_i,\n        .*\n    );\n  end else if (MMU_PRESENT && (riscv::XLEN == 32)) begin : gen_mmu_sv32\n    cva6_mmu_sv32 #(\n        .CVA6Cfg          (CVA6Cfg),\n        .INSTR_TLB_ENTRIES(ariane_pkg::INSTR_TLB_ENTRIES),\n        .DATA_TLB_ENTRIES (ariane_pkg::DATA_TLB_ENTRIES),\n        .ASID_WIDTH       (ASID_WIDTH)\n    ) i_cva6_mmu (\n        // misaligned bypass\n        .misaligned_ex_i(misaligned_exception),\n        .lsu_is_store_i (st_translation_req),\n        .lsu_req_i      (translation_req),\n        .lsu_vaddr_i    (mmu_vaddr),\n        .lsu_valid_o    (translation_valid),\n        .lsu_paddr_o    (mmu_paddr),\n        .lsu_exception_o(mmu_exception),\n        .lsu_dtlb_hit_o (dtlb_hit),               // send in the same cycle as the request\n        .lsu_dtlb_ppn_o (dtlb_ppn),               // send in the same cycle as the request\n        // connecting PTW to D$ IF\n        .req_port_i     (dcache_req_ports_i[0]),\n        .req_port_o     (dcache_req_ports_o[0]),\n        // icache address translation requests\n        .icache_areq_i  (icache_areq_i),\n        .asid_to_be_flushed_i,\n        .vaddr_to_be_flushed_i,\n        .icache_areq_o  (icache_areq_o),\n        .pmpcfg_i,\n        .pmpaddr_i,\n        .*\n    );\n  end else begin : gen_no_mmu\n\n    if (riscv::VLEN > riscv::PLEN) begin\n      assign mmu_vaddr_plen   = mmu_vaddr[riscv::PLEN-1:0];\n      assign fetch_vaddr_plen = icache_areq_i.fetch_vaddr[riscv::PLEN-1:0];\n    end else begin\n      assign mmu_vaddr_plen   = {{{riscv::PLEN - riscv::VLEN} {1'b0}}, mmu_vaddr};\n      assign fetch_vaddr_plen = {{{riscv::PLEN - riscv::VLEN} {1'b0}}, icache_areq_i.fetch_vaddr};\n    end\n\n    assign icache_areq_o.fetch_valid           = icache_areq_i.fetch_req;\n    assign icache_areq_o.fetch_paddr           = fetch_vaddr_plen;\n    assign icache_areq_o.fetch_exception       = '0;\n\n    assign dcache_req_ports_o[0].address_index = '0;\n    assign dcache_req_ports_o[0].address_tag   = '0;\n    assign dcache_req_ports_o[0].data_wdata    = '0;\n    assign dcache_req_ports_o[0].data_req      = 1'b0;\n    assign dcache_req_ports_o[0].data_be       = '1;\n    assign dcache_req_ports_o[0].data_size     = 2'b11;\n    assign dcache_req_ports_o[0].data_we       = 1'b0;\n    assign dcache_req_ports_o[0].kill_req      = '0;\n    assign dcache_req_ports_o[0].tag_valid     = 1'b0;\n\n    assign itlb_miss_o                         = 1'b0;\n    assign dtlb_miss_o                         = 1'b0;\n    assign dtlb_ppn                            = mmu_vaddr_plen[riscv::PLEN-1:12];\n    assign dtlb_hit                            = 1'b1;\n\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (~rst_ni) begin\n        mmu_paddr         <= '0;\n        translation_valid <= '0;\n        mmu_exception     <= '0;\n      end else begin\n        mmu_paddr         <= mmu_vaddr_plen;\n        translation_valid <= translation_req;\n        mmu_exception     <= misaligned_exception;\n      end\n    end\n  end\n\n\n  logic store_buffer_empty;\n  // ------------------\n  // Store Unit\n  // ------------------\n  store_unit #(\n      .CVA6Cfg(CVA6Cfg)\n  ) i_store_unit (\n      .clk_i,\n      .rst_ni,\n      .flush_i,\n      .stall_st_pending_i,\n      .no_st_pending_o,\n      .store_buffer_empty_o(store_buffer_empty),\n\n      .valid_i   (st_valid_i),\n      .lsu_ctrl_i(lsu_ctrl),\n      .pop_st_o  (pop_st),\n      .commit_i,\n      .commit_ready_o,\n      .amo_valid_commit_i,\n\n      .valid_o              (st_valid),\n      .trans_id_o           (st_trans_id),\n      .result_o             (st_result),\n      .ex_o                 (st_ex),\n      // MMU port\n      .translation_req_o    (st_translation_req),\n      .vaddr_o              (st_vaddr),\n      .rvfi_mem_paddr_o     (rvfi_mem_paddr_o),\n      .paddr_i              (mmu_paddr),\n      .ex_i                 (mmu_exception),\n      .dtlb_hit_i           (dtlb_hit),\n      // Load Unit\n      .page_offset_i        (page_offset),\n      .page_offset_matches_o(page_offset_matches),\n      // AMOs\n      .amo_req_o,\n      .amo_resp_i,\n      // to memory arbiter\n      .req_port_i           (dcache_req_ports_i[2]),\n      .req_port_o           (dcache_req_ports_o[2])\n  );\n\n  // ------------------\n  // Load Unit\n  // ------------------\n  load_unit #(\n      .CVA6Cfg(CVA6Cfg)\n  ) i_load_unit (\n      .valid_i   (ld_valid_i),\n      .lsu_ctrl_i(lsu_ctrl),\n      .pop_ld_o  (pop_ld),\n\n      .valid_o              (ld_valid),\n      .trans_id_o           (ld_trans_id),\n      .result_o             (ld_result),\n      .ex_o                 (ld_ex),\n      // MMU port\n      .translation_req_o    (ld_translation_req),\n      .vaddr_o              (ld_vaddr),\n      .paddr_i              (mmu_paddr),\n      .ex_i                 (mmu_exception),\n      .dtlb_hit_i           (dtlb_hit),\n      .dtlb_ppn_i           (dtlb_ppn),\n      // to store unit\n      .page_offset_o        (page_offset),\n      .page_offset_matches_i(page_offset_matches),\n      .store_buffer_empty_i (store_buffer_empty),\n      // to memory arbiter\n      .req_port_i           (dcache_req_ports_i[1]),\n      .req_port_o           (dcache_req_ports_o[1]),\n      .dcache_wbuffer_not_ni_i,\n      .commit_tran_id_i,\n      .*\n  );\n\n  // ----------------------------\n  // Output Pipeline Register\n  // ----------------------------\n\n  // amount of pipeline registers inserted for load/store return path\n  // can be tuned to trade-off IPC vs. cycle time\n\n  shift_reg #(\n      .dtype(logic [$bits(ld_valid) + $bits(ld_trans_id) + $bits(ld_result) + $bits(ld_ex) - 1:0]),\n      .Depth(cva6_config_pkg::CVA6ConfigNrLoadPipeRegs)\n  ) i_pipe_reg_load (\n      .clk_i,\n      .rst_ni,\n      .d_i({ld_valid, ld_trans_id, ld_result, ld_ex}),\n      .d_o({load_valid_o, load_trans_id_o, load_result_o, load_exception_o})\n  );\n\n  shift_reg #(\n      .dtype(logic [$bits(st_valid) + $bits(st_trans_id) + $bits(st_result) + $bits(st_ex) - 1:0]),\n      .Depth(cva6_config_pkg::CVA6ConfigNrStorePipeRegs)\n  ) i_pipe_reg_store (\n      .clk_i,\n      .rst_ni,\n      .d_i({st_valid, st_trans_id, st_result, st_ex}),\n      .d_o({store_valid_o, store_trans_id_o, store_result_o, store_exception_o})\n  );\n\n  // determine whether this is a load or store\n  always_comb begin : which_op\n\n    ld_valid_i      = 1'b0;\n    st_valid_i      = 1'b0;\n\n    translation_req = 1'b0;\n    mmu_vaddr       = {riscv::VLEN{1'b0}};\n\n    // check the operation to activate the right functional unit accordingly\n    unique case (lsu_ctrl.fu)\n      // all loads go here\n      LOAD: begin\n        ld_valid_i      = lsu_ctrl.valid;\n        translation_req = ld_translation_req;\n        mmu_vaddr       = ld_vaddr;\n      end\n      // all stores go here\n      STORE: begin\n        st_valid_i      = lsu_ctrl.valid;\n        translation_req = st_translation_req;\n        mmu_vaddr       = st_vaddr;\n      end\n      // not relevant for the LSU\n      default: ;\n    endcase\n  end\n\n\n  // ---------------\n  // Byte Enable\n  // ---------------\n  // we can generate the byte enable from the virtual address since the last\n  // 12 bit are the same anyway\n  // and we can always generate the byte enable from the address at hand\n\n  if (riscv::IS_XLEN64) begin : gen_8b_be\n    assign be_i = be_gen(vaddr_i[2:0], extract_transfer_size(fu_data_i.operation));\n  end else begin : gen_4b_be\n    assign be_i = be_gen_32(vaddr_i[1:0], extract_transfer_size(fu_data_i.operation));\n  end\n\n  // ------------------------\n  // Misaligned Exception\n  // ------------------------\n  // we can detect a misaligned exception immediately\n  // the misaligned exception is passed to the functional unit via the MMU, which in case\n  // can augment the exception if other memory related exceptions like a page fault or access errors\n  always_comb begin : data_misaligned_detection\n\n    misaligned_exception = {{riscv::XLEN{1'b0}}, {riscv::XLEN{1'b0}}, 1'b0};\n\n    data_misaligned = 1'b0;\n\n    if (lsu_ctrl.valid) begin\n      case (lsu_ctrl.operation)\n        // double word\n        LD, SD, FLD, FSD,\n                AMO_LRD, AMO_SCD,\n                AMO_SWAPD, AMO_ADDD, AMO_ANDD, AMO_ORD,\n                AMO_XORD, AMO_MAXD, AMO_MAXDU, AMO_MIND,\n                AMO_MINDU: begin\n          if (riscv::IS_XLEN64 && lsu_ctrl.vaddr[2:0] != 3'b000) begin\n            data_misaligned = 1'b1;\n          end\n        end\n        // word\n        LW, LWU, SW, FLW, FSW,\n                AMO_LRW, AMO_SCW,\n                AMO_SWAPW, AMO_ADDW, AMO_ANDW, AMO_ORW,\n                AMO_XORW, AMO_MAXW, AMO_MAXWU, AMO_MINW,\n                AMO_MINWU: begin\n          if (lsu_ctrl.vaddr[1:0] != 2'b00) begin\n            data_misaligned = 1'b1;\n          end\n        end\n        // half word\n        LH, LHU, SH, FLH, FSH: begin\n          if (lsu_ctrl.vaddr[0] != 1'b0) begin\n            data_misaligned = 1'b1;\n          end\n        end\n        // byte -> is always aligned\n        default: ;\n      endcase\n    end\n\n    if (data_misaligned) begin\n\n      if (lsu_ctrl.fu == LOAD) begin\n        misaligned_exception.cause = riscv::LD_ADDR_MISALIGNED;\n        misaligned_exception.valid = 1'b1;\n        if (CVA6Cfg.TvalEn)\n          misaligned_exception.tval = {{riscv::XLEN - riscv::VLEN{1'b0}}, lsu_ctrl.vaddr};\n\n      end else if (lsu_ctrl.fu == STORE) begin\n        misaligned_exception.cause = riscv::ST_ADDR_MISALIGNED;\n        misaligned_exception.valid = 1'b1;\n        if (CVA6Cfg.TvalEn)\n          misaligned_exception.tval = {{riscv::XLEN - riscv::VLEN{1'b0}}, lsu_ctrl.vaddr};\n      end\n    end\n\n    if (ariane_pkg::MMU_PRESENT && en_ld_st_translation_i && lsu_ctrl.overflow) begin\n\n      if (lsu_ctrl.fu == LOAD) begin\n        misaligned_exception.cause = riscv::LD_ACCESS_FAULT;\n        misaligned_exception.valid = 1'b1;\n        if (CVA6Cfg.TvalEn)\n          misaligned_exception.tval = {{riscv::XLEN - riscv::VLEN{1'b0}}, lsu_ctrl.vaddr};\n\n      end else if (lsu_ctrl.fu == STORE) begin\n        misaligned_exception.cause = riscv::ST_ACCESS_FAULT;\n        misaligned_exception.valid = 1'b1;\n        if (CVA6Cfg.TvalEn)\n          misaligned_exception.tval = {{riscv::XLEN - riscv::VLEN{1'b0}}, lsu_ctrl.vaddr};\n      end\n    end\n  end\n\n  // ------------------\n  // LSU Control\n  // ------------------\n  // new data arrives here\n  lsu_ctrl_t lsu_req_i;\n\n  assign lsu_req_i = {\n    lsu_valid_i,\n    vaddr_i,\n    overflow,\n    fu_data_i.operand_b,\n    be_i,\n    fu_data_i.fu,\n    fu_data_i.operation,\n    fu_data_i.trans_id\n  };\n\n  lsu_bypass #(\n      .CVA6Cfg(CVA6Cfg)\n  ) lsu_bypass_i (\n      .lsu_req_i      (lsu_req_i),\n      .lsu_req_valid_i(lsu_valid_i),\n      .pop_ld_i       (pop_ld),\n      .pop_st_i       (pop_st),\n\n      .lsu_ctrl_o(lsu_ctrl),\n      .ready_o   (lsu_ready_o),\n      .*\n  );\n\n  assign rvfi_lsu_ctrl_o = lsu_ctrl;\n\nendmodule\n\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba    <zarubaf@iis.ee.ethz.ch>, ETH Zurich\n//         Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 15.08.2018\n// Description: Load Unit, takes care of all load requests\n//\n// Contributor: Cesar Fuguet <cesar.fuguettortolero@cea.fr>, CEA List\n// Date: August 29, 2023\n// Modification: add support for multiple outstanding load operations\n//               to the data cache\n\nmodule load_unit\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic flush_i,\n    // Load unit input port - TO_BE_COMPLETED\n    input logic valid_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input lsu_ctrl_t lsu_ctrl_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output logic pop_ld_o,\n    // Load unit result is valid - TO_BE_COMPLETED\n    output logic valid_o,\n    // Load transaction ID - TO_BE_COMPLETED\n    output logic [TRANS_ID_BITS-1:0] trans_id_o,\n    // Load result - TO_BE_COMPLETED\n    output riscv::xlen_t result_o,\n    // Load exception - TO_BE_COMPLETED\n    output exception_t ex_o,\n    // Request address translation - TO_BE_COMPLETED\n    output logic translation_req_o,\n    // Virtual address - TO_BE_COMPLETED\n    output logic [riscv::VLEN-1:0] vaddr_o,\n    // Physical address - TO_BE_COMPLETED\n    input logic [riscv::PLEN-1:0] paddr_i,\n    // Excepted which appears before load - TO_BE_COMPLETED\n    input exception_t ex_i,\n    // Data TLB hit - lsu\n    input logic dtlb_hit_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic [riscv::PPNW-1:0] dtlb_ppn_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output logic [11:0] page_offset_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic page_offset_matches_i,\n    // Store buffer is empty - TO_BE_COMPLETED\n    input logic store_buffer_empty_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic [TRANS_ID_BITS-1:0] commit_tran_id_i,\n    // Data cache request out - CACHES\n    input dcache_req_o_t req_port_i,\n    // Data cache request in - CACHES\n    output dcache_req_i_t req_port_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic dcache_wbuffer_not_ni_i\n);\n  enum logic [3:0] {\n    IDLE,\n    WAIT_GNT,\n    SEND_TAG,\n    WAIT_PAGE_OFFSET,\n    ABORT_TRANSACTION,\n    ABORT_TRANSACTION_NI,\n    WAIT_TRANSLATION,\n    WAIT_FLUSH,\n    WAIT_WB_EMPTY\n  }\n      state_d, state_q;\n\n  // in order to decouple the response interface from the request interface,\n  // we need a a buffer which can hold all inflight memory load requests\n  typedef struct packed {\n    logic [TRANS_ID_BITS-1:0]           trans_id;        // scoreboard identifier\n    logic [riscv::XLEN_ALIGN_BYTES-1:0] address_offset;  // least significant bits of the address\n    fu_op                               operation;       // type of load\n  } ldbuf_t;\n\n\n  // to support a throughput of one load per cycle, if the number of entries\n  // of the load buffer is 1, implement a fall-through mode. This however\n  // adds a combinational path between the request and response interfaces\n  // towards the cache.\n  localparam logic LDBUF_FALLTHROUGH = (CVA6Cfg.NrLoadBufEntries == 1);\n  localparam int unsigned REQ_ID_BITS = CVA6Cfg.NrLoadBufEntries > 1 ? $clog2(\n      CVA6Cfg.NrLoadBufEntries\n  ) : 1;\n\n  typedef logic [REQ_ID_BITS-1:0] ldbuf_id_t;\n\n  logic [CVA6Cfg.NrLoadBufEntries-1:0] ldbuf_valid_q, ldbuf_valid_d;\n  logic [CVA6Cfg.NrLoadBufEntries-1:0] ldbuf_flushed_q, ldbuf_flushed_d;\n  ldbuf_t [CVA6Cfg.NrLoadBufEntries-1:0] ldbuf_q;\n  logic ldbuf_empty, ldbuf_full;\n  ldbuf_id_t ldbuf_free_index;\n  logic      ldbuf_w;\n  ldbuf_t    ldbuf_wdata;\n  ldbuf_id_t ldbuf_windex;\n  logic      ldbuf_r;\n  ldbuf_t    ldbuf_rdata;\n  ldbuf_id_t ldbuf_rindex;\n  ldbuf_id_t ldbuf_last_id_q;\n\n  assign ldbuf_full = &ldbuf_valid_q;\n\n  //\n  //  buffer of outstanding loads\n\n  //  write in the first available slot\n  generate\n    if (CVA6Cfg.NrLoadBufEntries > 1) begin : ldbuf_free_index_multi_gen\n      lzc #(\n          .WIDTH(CVA6Cfg.NrLoadBufEntries),\n          .MODE (1'b0)                       // Count leading zeros\n      ) lzc_windex_i (\n          .in_i   (~ldbuf_valid_q),\n          .cnt_o  (ldbuf_free_index),\n          .empty_o(ldbuf_empty)\n      );\n    end else begin : ldbuf_free_index_single_gen\n      assign ldbuf_free_index = 1'b0;\n    end\n  endgenerate\n\n  assign ldbuf_windex = (LDBUF_FALLTHROUGH && ldbuf_r) ? ldbuf_rindex : ldbuf_free_index;\n\n  always_comb begin : ldbuf_comb\n    ldbuf_flushed_d = ldbuf_flushed_q;\n    ldbuf_valid_d   = ldbuf_valid_q;\n\n    //  In case of flush, raise the flushed flag in all slots.\n    if (flush_i) begin\n      ldbuf_flushed_d = '1;\n    end\n    //  Free read entry (in the case of fall-through mode, free the entry\n    //  only if there is no pending load)\n    if (ldbuf_r && (!LDBUF_FALLTHROUGH || !ldbuf_w)) begin\n      ldbuf_valid_d[ldbuf_rindex] = 1'b0;\n    end\n    //  Track a new outstanding operation in the load buffer\n    if (ldbuf_w) begin\n      ldbuf_flushed_d[ldbuf_windex] = 1'b0;\n      ldbuf_valid_d[ldbuf_windex]   = 1'b1;\n    end\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : ldbuf_ff\n    if (!rst_ni) begin\n      ldbuf_flushed_q <= '0;\n      ldbuf_valid_q   <= '0;\n      ldbuf_last_id_q <= '0;\n      ldbuf_q         <= '0;\n    end else begin\n      ldbuf_flushed_q <= ldbuf_flushed_d;\n      ldbuf_valid_q   <= ldbuf_valid_d;\n      if (ldbuf_w) begin\n        ldbuf_last_id_q       <= ldbuf_windex;\n        ldbuf_q[ldbuf_windex] <= ldbuf_wdata;\n      end\n    end\n  end\n\n  // page offset is defined as the lower 12 bits, feed through for address checker\n  assign page_offset_o = lsu_ctrl_i.vaddr[11:0];\n  // feed-through the virtual address for VA translation\n  assign vaddr_o = lsu_ctrl_i.vaddr;\n  // this is a read-only interface so set the write enable to 0\n  assign req_port_o.data_we = 1'b0;\n  assign req_port_o.data_wdata = '0;\n  // compose the load buffer write data, control is handled in the FSM\n  assign ldbuf_wdata = {\n    lsu_ctrl_i.trans_id, lsu_ctrl_i.vaddr[riscv::XLEN_ALIGN_BYTES-1:0], lsu_ctrl_i.operation\n  };\n  // output address\n  // we can now output the lower 12 bit as the index to the cache\n  assign req_port_o.address_index = lsu_ctrl_i.vaddr[ariane_pkg::DCACHE_INDEX_WIDTH-1:0];\n  // translation from last cycle, again: control is handled in the FSM\n  assign req_port_o.address_tag   = paddr_i[ariane_pkg::DCACHE_TAG_WIDTH     +\n                                              ariane_pkg::DCACHE_INDEX_WIDTH-1 :\n                                              ariane_pkg::DCACHE_INDEX_WIDTH];\n  // request id = index of the load buffer's entry\n  assign req_port_o.data_id = ldbuf_windex;\n  // directly forward exception fields (valid bit is set below)\n  assign ex_o.cause = ex_i.cause;\n  assign ex_o.tval = ex_i.tval;\n\n  // Check that NI operations follow the necessary conditions\n  logic paddr_ni;\n  logic not_commit_time;\n  logic inflight_stores;\n  logic stall_ni;\n  assign paddr_ni = config_pkg::is_inside_nonidempotent_regions(\n      CVA6Cfg, {{52 - riscv::PPNW{1'b0}}, dtlb_ppn_i, 12'd0}\n  );\n  assign not_commit_time = commit_tran_id_i != lsu_ctrl_i.trans_id;\n  assign inflight_stores = (!dcache_wbuffer_not_ni_i || !store_buffer_empty_i);\n  assign stall_ni = (inflight_stores || not_commit_time) && (paddr_ni && CVA6Cfg.NonIdemPotenceEn);\n\n  // ---------------\n  // Load Control\n  // ---------------\n  always_comb begin : load_control\n    automatic logic accept_req;\n\n    // default assignments\n    state_d              = state_q;\n    translation_req_o    = 1'b0;\n    req_port_o.data_req  = 1'b0;\n    // tag control\n    req_port_o.kill_req  = 1'b0;\n    req_port_o.tag_valid = 1'b0;\n    req_port_o.data_be   = lsu_ctrl_i.be;\n    req_port_o.data_size = extract_transfer_size(lsu_ctrl_i.operation);\n    pop_ld_o             = 1'b0;\n\n    // In IDLE and SEND_TAG states, this unit can accept a new load request\n    // when the load buffer is not full or if there is a response and the\n    // load buffer is in fall-through mode\n    accept_req           = (valid_i && (!ldbuf_full || (LDBUF_FALLTHROUGH && ldbuf_r)));\n\n    case (state_q)\n      IDLE: begin\n        if (accept_req) begin\n          // start the translation process even though we do not know if the addresses match\n          // this should ease timing\n          translation_req_o = 1'b1;\n          // check if the page offset matches with a store, if it does then stall and wait\n          if (!page_offset_matches_i) begin\n            // make a load request to memory\n            req_port_o.data_req = 1'b1;\n            // we got no data grant so wait for the grant before sending the tag\n            if (!req_port_i.data_gnt) begin\n              state_d = WAIT_GNT;\n            end else begin\n              if (ariane_pkg::MMU_PRESENT && !dtlb_hit_i) begin\n                state_d = ABORT_TRANSACTION;\n              end else begin\n                if (!stall_ni) begin\n                  // we got a grant and a hit on the DTLB so we can send the tag in the next cycle\n                  state_d  = SEND_TAG;\n                  pop_ld_o = 1'b1;\n                  // translation valid but this is to NC and the WB is not yet empty.\n                end else if (CVA6Cfg.NonIdemPotenceEn) begin\n                  state_d = ABORT_TRANSACTION_NI;\n                end\n              end\n            end\n          end else begin\n            // wait for the store buffer to train and the page offset to not match anymore\n            state_d = WAIT_PAGE_OFFSET;\n          end\n        end\n      end\n\n      // wait here for the page offset to not match anymore\n      WAIT_PAGE_OFFSET: begin\n        // we make a new request as soon as the page offset does not match anymore\n        if (!page_offset_matches_i) begin\n          state_d = WAIT_GNT;\n        end\n      end\n\n      WAIT_GNT: begin\n        // keep the translation request up\n        translation_req_o   = 1'b1;\n        // keep the request up\n        req_port_o.data_req = 1'b1;\n        // we finally got a data grant\n        if (req_port_i.data_gnt) begin\n          // so we send the tag in the next cycle\n          if (ariane_pkg::MMU_PRESENT && !dtlb_hit_i) begin\n            state_d = ABORT_TRANSACTION;\n          end else begin\n            if (!stall_ni) begin\n              // we got a grant and a hit on the DTLB so we can send the tag in the next cycle\n              state_d  = SEND_TAG;\n              pop_ld_o = 1'b1;\n              // translation valid but this is to NC and the WB is not yet empty.\n            end else if (CVA6Cfg.NonIdemPotenceEn) begin\n              state_d = ABORT_TRANSACTION_NI;\n            end\n          end\n\n        end\n        // otherwise we keep waiting on our grant\n      end\n      // we know for sure that the tag we want to send is valid\n      SEND_TAG: begin\n        req_port_o.tag_valid = 1'b1;\n        state_d = IDLE;\n\n        if (accept_req) begin\n          // start the translation process even though we do not know if the addresses match\n          // this should ease timing\n          translation_req_o = 1'b1;\n          // check if the page offset matches with a store, if it does stall and wait\n          if (!page_offset_matches_i) begin\n            // make a load request to memory\n            req_port_o.data_req = 1'b1;\n            // we got no data grant so wait for the grant before sending the tag\n            if (!req_port_i.data_gnt) begin\n              state_d = WAIT_GNT;\n            end else begin\n              // we got a grant so we can send the tag in the next cycle\n              if (ariane_pkg::MMU_PRESENT && !dtlb_hit_i) begin\n                state_d = ABORT_TRANSACTION;\n              end else begin\n                if (!stall_ni) begin\n                  // we got a grant and a hit on the DTLB so we can send the tag in the next cycle\n                  state_d  = SEND_TAG;\n                  pop_ld_o = 1'b1;\n                  // translation valid but this is to NC and the WB is not yet empty.\n                end else if (CVA6Cfg.NonIdemPotenceEn) begin\n                  state_d = ABORT_TRANSACTION_NI;\n                end\n              end\n            end\n          end else begin\n            // wait for the store buffer to train and the page offset to not match anymore\n            state_d = WAIT_PAGE_OFFSET;\n          end\n        end\n        // ----------\n        // Exception\n        // ----------\n        // if we got an exception we need to kill the request immediately\n        if (ex_i.valid) begin\n          req_port_o.kill_req = 1'b1;\n        end\n      end\n\n      WAIT_FLUSH: begin\n        // the D$ arbiter will take care of presenting this to the memory only in case we\n        // have an outstanding request\n        req_port_o.kill_req = 1'b1;\n        req_port_o.tag_valid = 1'b1;\n        // we've killed the current request so we can go back to idle\n        state_d = IDLE;\n      end\n\n      default: begin\n        // abort the previous request - free the D$ arbiter\n        // we are here because of a TLB miss, we need to abort the current request and give way for the\n        // PTW walker to satisfy the TLB miss\n        if (state_q == ABORT_TRANSACTION && ariane_pkg::MMU_PRESENT) begin\n          req_port_o.kill_req = 1'b1;\n          req_port_o.tag_valid = 1'b1;\n          // wait until the WB is empty\n          state_d = WAIT_TRANSLATION;\n        end else if (state_q == ABORT_TRANSACTION_NI && CVA6Cfg.NonIdemPotenceEn) begin\n          req_port_o.kill_req = 1'b1;\n          req_port_o.tag_valid = 1'b1;\n          // re-do the request\n          state_d = WAIT_WB_EMPTY;\n        end else if (state_q == WAIT_WB_EMPTY && CVA6Cfg.NonIdemPotenceEn && dcache_wbuffer_not_ni_i) begin\n          // Wait until the write-back buffer is empty in the data cache.\n          // the write buffer is empty, so lets go and re-do the translation.\n          state_d = WAIT_TRANSLATION;\n        end else if(state_q == WAIT_TRANSLATION && (ariane_pkg::MMU_PRESENT || CVA6Cfg.NonIdemPotenceEn)) begin\n          translation_req_o = 1'b1;\n          // we've got a hit and we can continue with the request process\n          if (dtlb_hit_i) state_d = WAIT_GNT;\n\n          // we got an exception\n          if (ex_i.valid) begin\n            // the next state will be the idle state\n            state_d  = IDLE;\n            // pop load - but only if we are not getting an rvalid in here - otherwise we will over-write an incoming transaction\n            pop_ld_o = ~req_port_i.data_rvalid;\n          end\n        end else begin\n          state_d = IDLE;\n        end\n      end\n    endcase\n\n    // if we just flushed and the queue is not empty or we are getting an rvalid this cycle wait in a extra stage\n    if (flush_i) begin\n      state_d = WAIT_FLUSH;\n    end\n  end\n\n  // track the load data for later usage\n  assign ldbuf_w = req_port_o.data_req & req_port_i.data_gnt;\n\n  // ---------------\n  // Retire Load\n  // ---------------\n  assign ldbuf_rindex = (CVA6Cfg.NrLoadBufEntries > 1) ? ldbuf_id_t'(req_port_i.data_rid) : 1'b0,\n      ldbuf_rdata = ldbuf_q[ldbuf_rindex];\n\n  // decoupled rvalid process\n  always_comb begin : rvalid_output\n    //  read the pending load buffer\n    ldbuf_r    = req_port_i.data_rvalid;\n    trans_id_o = ldbuf_q[ldbuf_rindex].trans_id;\n    valid_o    = 1'b0;\n    ex_o.valid = 1'b0;\n\n    // we got an rvalid and it's corresponding request was not flushed\n    if (req_port_i.data_rvalid && !ldbuf_flushed_q[ldbuf_rindex]) begin\n      // if the response corresponds to the last request, check that we are not killing it\n      if ((ldbuf_last_id_q != ldbuf_rindex) || !req_port_o.kill_req) valid_o = 1'b1;\n      // the output is also valid if we got an exception. An exception arrives one cycle after\n      // dtlb_hit_i is asserted, i.e. when we are in SEND_TAG. Otherwise, the exception\n      // corresponds to the next request that is already being translated (see below).\n      if (ex_i.valid && (state_q == SEND_TAG)) begin\n        valid_o    = 1'b1;\n        ex_o.valid = 1'b1;\n      end\n    end\n\n    // an exception occurred during translation\n    // exceptions can retire out-of-order -> but we need to give priority to non-excepting load and stores\n    // so we simply check if we got an rvalid if so we prioritize it by not retiring the exception - we simply go for another\n    // round in the load FSM\n    if ((ariane_pkg::MMU_PRESENT || CVA6Cfg.NonIdemPotenceEn) && (state_q == WAIT_TRANSLATION) && !req_port_i.data_rvalid && ex_i.valid && valid_i) begin\n      trans_id_o = lsu_ctrl_i.trans_id;\n      valid_o = 1'b1;\n      ex_o.valid = 1'b1;\n    end\n  end\n\n\n  // latch physical address for the tag cycle (one cycle after applying the index)\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      state_q <= IDLE;\n    end else begin\n      state_q <= state_d;\n    end\n  end\n\n  // ---------------\n  // Sign Extend\n  // ---------------\n  riscv::xlen_t shifted_data;\n\n  // realign as needed\n  assign shifted_data = req_port_i.data_rdata >> {ldbuf_rdata.address_offset, 3'b000};\n\n  /*  // result mux (leaner code, but more logic stages.\n    // can be used instead of the code below (in between //result mux fast) if timing is not so critical)\n    always_comb begin\n        unique case (ldbuf_rdata.operation)\n            LWU:        result_o = shifted_data[31:0];\n            LHU:        result_o = shifted_data[15:0];\n            LBU:        result_o = shifted_data[7:0];\n            LW:         result_o = 64'(signed'(shifted_data[31:0]));\n            LH:         result_o = 64'(signed'(shifted_data[15:0]));\n            LB:         result_o = 64'(signed'(shifted_data[ 7:0]));\n            default:    result_o = shifted_data;\n        endcase\n    end  */\n\n  // result mux fast\n  logic [        (riscv::XLEN/8)-1:0] rdata_sign_bits;\n  logic [riscv::XLEN_ALIGN_BYTES-1:0] rdata_offset;\n  logic rdata_sign_bit, rdata_is_signed, rdata_is_fp_signed;\n\n\n  // prepare these signals for faster selection in the next cycle\n  assign rdata_is_signed    =   ldbuf_rdata.operation inside {ariane_pkg::LW,  ariane_pkg::LH,  ariane_pkg::LB};\n  assign rdata_is_fp_signed =   ldbuf_rdata.operation inside {ariane_pkg::FLW, ariane_pkg::FLH, ariane_pkg::FLB};\n  assign rdata_offset       = ((ldbuf_rdata.operation inside {ariane_pkg::LW,  ariane_pkg::FLW}) & riscv::IS_XLEN64) ? ldbuf_rdata.address_offset + 3 :\n                                ( ldbuf_rdata.operation inside {ariane_pkg::LH,  ariane_pkg::FLH})                     ? ldbuf_rdata.address_offset + 1 :\n                                                                                                                         ldbuf_rdata.address_offset;\n\n  for (genvar i = 0; i < (riscv::XLEN / 8); i++) begin : gen_sign_bits\n    assign rdata_sign_bits[i] = req_port_i.data_rdata[(i+1)*8-1];\n  end\n\n\n  // select correct sign bit in parallel to result shifter above\n  // pull to 0 if unsigned\n  assign rdata_sign_bit = rdata_is_signed & rdata_sign_bits[rdata_offset] | rdata_is_fp_signed;\n\n  // result mux\n  always_comb begin\n    unique case (ldbuf_rdata.operation)\n      ariane_pkg::LW, ariane_pkg::LWU:\n      result_o = {{riscv::XLEN - 32{rdata_sign_bit}}, shifted_data[31:0]};\n      ariane_pkg::LH, ariane_pkg::LHU:\n      result_o ="}
{"text": " {{riscv::XLEN - 32 + 16{rdata_sign_bit}}, shifted_data[15:0]};\n      ariane_pkg::LB, ariane_pkg::LBU:\n      result_o = {{riscv::XLEN - 32 + 24{rdata_sign_bit}}, shifted_data[7:0]};\n      default: begin\n        // FLW, FLH and FLB have been defined here in default case to improve Code Coverage\n        if (CVA6Cfg.FpPresent) begin\n          unique case (ldbuf_rdata.operation)\n            ariane_pkg::FLW: begin\n              result_o = {{riscv::XLEN - 32{rdata_sign_bit}}, shifted_data[31:0]};\n            end\n            ariane_pkg::FLH: begin\n              result_o = {{riscv::XLEN - 32 + 16{rdata_sign_bit}}, shifted_data[15:0]};\n            end\n            ariane_pkg::FLB: begin\n              result_o = {{riscv::XLEN - 32 + 24{rdata_sign_bit}}, shifted_data[7:0]};\n            end\n            default: begin\n              result_o = shifted_data[riscv::XLEN-1:0];\n            end\n          endcase\n        end else begin\n          result_o = shifted_data[riscv::XLEN-1:0];\n        end\n      end\n    endcase\n  end\n  // end result mux fast\n\n  ///////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////\n\n  //pragma translate_off\n`ifndef VERILATOR\n  initial\n    assert (ariane_pkg::DCACHE_TID_WIDTH >= REQ_ID_BITS)\n    else $fatal(1, \"CVA6ConfigDcacheIdWidth parameter is not wide enough to encode pending loads\");\n  // check invalid offsets, but only issue a warning as these conditions actually trigger a load address misaligned exception\n  addr_offset0 :\n  assert property (@(posedge clk_i) disable iff (~rst_ni)\n        ldbuf_w |->  (ldbuf_wdata.operation inside {ariane_pkg::LW, ariane_pkg::LWU}) |-> ldbuf_wdata.address_offset < 5)\n  else $fatal(1, \"invalid address offset used with {LW, LWU}\");\n  addr_offset1 :\n  assert property (@(posedge clk_i) disable iff (~rst_ni)\n        ldbuf_w |->  (ldbuf_wdata.operation inside {ariane_pkg::LH, ariane_pkg::LHU}) |-> ldbuf_wdata.address_offset < 7)\n  else $fatal(1, \"invalid address offset used with {LH, LHU}\");\n  addr_offset2 :\n  assert property (@(posedge clk_i) disable iff (~rst_ni)\n        ldbuf_w |->  (ldbuf_wdata.operation inside {ariane_pkg::LB, ariane_pkg::LBU}) |-> ldbuf_wdata.address_offset < 8)\n  else $fatal(1, \"invalid address offset used with {LB, LBU}\");\n`endif\n  //pragma translate_on\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 19.04.2017\n// Description: Load Store Unit, handles address calculation and memory interface signals\n\n\n// ------------------\n// LSU Control\n// ------------------\n// The LSU consists of two independent block which share a common address translation block.\n// The one block is the load unit, the other one is the store unit. They will signal their readiness\n// with separate signals. If they are not ready the LSU control should keep the last applied signals stable.\n// Furthermore it can be the case that another request for one of the two store units arrives in which case\n// the LSU control should sample it and store it for later application to the units. It does so, by storing it in a\n// two element FIFO. This is necessary as we only know very late in the cycle whether the load/store will succeed (address check,\n// TLB hit mainly). So we better unconditionally allow another request to arrive and store this request in case we need to.\nmodule lsu_bypass\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic flush_i,\n\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input lsu_ctrl_t lsu_req_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic      lsu_req_valid_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic      pop_ld_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic      pop_st_i,\n\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output lsu_ctrl_t lsu_ctrl_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output logic      ready_o\n);\n\n  lsu_ctrl_t [1:0] mem_n, mem_q;\n  logic read_pointer_n, read_pointer_q;\n  logic write_pointer_n, write_pointer_q;\n  logic [1:0] status_cnt_n, status_cnt_q;\n\n  logic empty;\n  assign empty   = (status_cnt_q == 0);\n  assign ready_o = empty;\n\n  always_comb begin\n    automatic logic [1:0] status_cnt;\n    automatic logic write_pointer;\n    automatic logic read_pointer;\n\n    status_cnt = status_cnt_q;\n    write_pointer = write_pointer_q;\n    read_pointer = read_pointer_q;\n\n    mem_n = mem_q;\n    // we've got a valid LSU request\n    if (lsu_req_valid_i) begin\n      mem_n[write_pointer_q] = lsu_req_i;\n      write_pointer++;\n      status_cnt++;\n    end\n\n    if (pop_ld_i) begin\n      // invalidate the result\n      mem_n[read_pointer_q].valid = 1'b0;\n      read_pointer++;\n      status_cnt--;\n    end\n\n    if (pop_st_i) begin\n      // invalidate the result\n      mem_n[read_pointer_q].valid = 1'b0;\n      read_pointer++;\n      status_cnt--;\n    end\n\n    if (pop_st_i && pop_ld_i) mem_n = '0;\n\n    if (flush_i) begin\n      status_cnt = '0;\n      write_pointer = '0;\n      read_pointer = '0;\n      mem_n = '0;\n    end\n    // default assignments\n    read_pointer_n  = read_pointer;\n    write_pointer_n = write_pointer;\n    status_cnt_n    = status_cnt;\n  end\n\n  // output assignment\n  always_comb begin : output_assignments\n    if (empty) begin\n      lsu_ctrl_o = lsu_req_i;\n    end else begin\n      lsu_ctrl_o = mem_q[read_pointer_q];\n    end\n  end\n\n  // registers\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      mem_q           <= '0;\n      status_cnt_q    <= '0;\n      write_pointer_q <= '0;\n      read_pointer_q  <= '0;\n    end else begin\n      mem_q           <= mem_n;\n      status_cnt_q    <= status_cnt_n;\n      write_pointer_q <= write_pointer_n;\n      read_pointer_q  <= read_pointer_n;\n    end\n  end\nendmodule\n\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 12.11.2017\n// Description: Handles cache misses.\n\n// --------------\n// MISS Handler\n// --------------\n\nmodule miss_handler\n  import ariane_pkg::*;\n  import std_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg   = config_pkg::cva6_cfg_empty,\n    parameter int unsigned           NR_PORTS  = 4,\n    parameter type                   axi_req_t = logic,\n    parameter type                   axi_rsp_t = logic\n) (\n    input logic clk_i,\n    input logic rst_ni,\n    input logic flush_i,  // flush request\n    output logic flush_ack_o,  // acknowledge successful flush\n    output logic miss_o,\n    input logic busy_i,  // dcache is busy with something\n    // Bypass or miss\n    input logic [NR_PORTS-1:0][$bits(miss_req_t)-1:0] miss_req_i,\n    // Bypass handling\n    output logic [NR_PORTS-1:0] bypass_gnt_o,\n    output logic [NR_PORTS-1:0] bypass_valid_o,\n    output logic [NR_PORTS-1:0][63:0] bypass_data_o,\n\n    // AXI port\n    output axi_req_t axi_bypass_o,\n    input  axi_rsp_t axi_bypass_i,\n\n    // Miss handling (~> cacheline refill)\n    output logic [NR_PORTS-1:0] miss_gnt_o,\n    output logic [NR_PORTS-1:0] active_serving_o,\n\n    output logic     [63:0] critical_word_o,\n    output logic            critical_word_valid_o,\n    output axi_req_t        axi_data_o,\n    input  axi_rsp_t        axi_data_i,\n\n    input logic [NR_PORTS-1:0][55:0] mshr_addr_i,\n    output logic [NR_PORTS-1:0] mshr_addr_matches_o,\n    output logic [NR_PORTS-1:0] mshr_index_matches_o,\n    // AMO\n    input amo_req_t amo_req_i,\n    output amo_resp_t amo_resp_o,\n    // Port to SRAMs, for refill and eviction\n    output logic [DCACHE_SET_ASSOC-1:0] req_o,\n    output logic [DCACHE_INDEX_WIDTH-1:0] addr_o,  // address into cache array\n    output cache_line_t data_o,\n    output cl_be_t be_o,\n    input cache_line_t [DCACHE_SET_ASSOC-1:0] data_i,\n    output logic we_o\n);\n\n  // Three MSHR ports + AMO port\n  parameter NR_BYPASS_PORTS = NR_PORTS + 1;\n\n  // FSM states\n  enum logic [3:0] {\n    IDLE,                // 0\n    FLUSHING,            // 1\n    FLUSH,               // 2\n    WB_CACHELINE_FLUSH,  // 3\n    FLUSH_REQ_STATUS,    // 4\n    WB_CACHELINE_MISS,   // 5\n    WAIT_GNT_SRAM,       // 6\n    MISS,                // 7\n    REQ_CACHELINE,       // 8\n    MISS_REPL,           // 9\n    SAVE_CACHELINE,      // A\n    INIT,                // B\n    AMO_REQ,             // C\n    AMO_WAIT_RESP        // D\n  }\n      state_d, state_q;\n\n  // Registers\n  mshr_t mshr_d, mshr_q;\n  logic [DCACHE_INDEX_WIDTH-1:0] cnt_d, cnt_q;\n  logic [DCACHE_SET_ASSOC-1:0] evict_way_d, evict_way_q;\n  // cache line to evict\n  cache_line_t evict_cl_d, evict_cl_q;\n\n  logic serve_amo_d, serve_amo_q;\n  // Request from one FSM\n  logic                [                  NR_PORTS-1:0]       miss_req_valid;\n  logic                [                  NR_PORTS-1:0]       miss_req_bypass;\n  logic                [                  NR_PORTS-1:0][63:0] miss_req_addr;\n  logic                [                  NR_PORTS-1:0][63:0] miss_req_wdata;\n  logic                [                  NR_PORTS-1:0]       miss_req_we;\n  logic                [                  NR_PORTS-1:0][ 7:0] miss_req_be;\n  logic                [                  NR_PORTS-1:0][ 1:0] miss_req_size;\n\n  // Bypass AMO port\n  bypass_req_t                                                amo_bypass_req;\n  bypass_rsp_t                                                amo_bypass_rsp;\n\n  // Bypass ports <-> Arbiter\n  bypass_req_t         [           NR_BYPASS_PORTS-1:0]       bypass_ports_req;\n  bypass_rsp_t         [           NR_BYPASS_PORTS-1:0]       bypass_ports_rsp;\n\n  // Arbiter <-> Bypass AXI adapter\n  bypass_req_t                                                bypass_adapter_req;\n  bypass_rsp_t                                                bypass_adapter_rsp;\n\n  // Cache Line Refill <-> AXI\n  logic                                                       req_fsm_miss_valid;\n  logic                [                          63:0]       req_fsm_miss_addr;\n  logic                [         DCACHE_LINE_WIDTH-1:0]       req_fsm_miss_wdata;\n  logic                                                       req_fsm_miss_we;\n  logic                [     (DCACHE_LINE_WIDTH/8)-1:0]       req_fsm_miss_be;\n  ariane_pkg::ad_req_t                                        req_fsm_miss_req;\n  logic                [                           1:0]       req_fsm_miss_size;\n\n  logic                                                       gnt_miss_fsm;\n  logic                                                       valid_miss_fsm;\n  logic                [    (DCACHE_LINE_WIDTH/64)-1:0][63:0] data_miss_fsm;\n\n  // Cache Management <-> LFSR\n  logic                                                       lfsr_enable;\n  logic                [          DCACHE_SET_ASSOC-1:0]       lfsr_oh;\n  logic                [$clog2(DCACHE_SET_ASSOC-1)-1:0]       lfsr_bin;\n  // AMOs\n  ariane_pkg::amo_t                                           amo_op;\n  logic                [                          63:0]       amo_operand_b;\n\n  // ------------------------------\n  // Cache Management\n  // ------------------------------\n  always_comb begin : cache_management\n    automatic logic [DCACHE_SET_ASSOC-1:0] evict_way, valid_way;\n\n    for (int unsigned i = 0; i < DCACHE_SET_ASSOC; i++) begin\n      evict_way[i] = data_i[i].valid & data_i[i].dirty;\n      valid_way[i] = data_i[i].valid;\n    end\n    // ----------------------\n    // Default Assignments\n    // ----------------------\n    // memory array\n    req_o                       = '0;\n    addr_o                      = '0;\n    data_o                      = '0;\n    be_o                        = '0;\n    we_o                        = '0;\n    // Cache controller\n    miss_gnt_o                  = '0;\n    active_serving_o            = '0;\n    // LFSR replacement unit\n    lfsr_enable                 = 1'b0;\n    // to AXI refill\n    req_fsm_miss_valid          = 1'b0;\n    req_fsm_miss_addr           = '0;\n    req_fsm_miss_wdata          = '0;\n    req_fsm_miss_we             = 1'b0;\n    req_fsm_miss_be             = '0;\n    req_fsm_miss_req            = ariane_pkg::CACHE_LINE_REQ;\n    req_fsm_miss_size           = 2'b11;\n    // to AXI bypass\n    amo_bypass_req.req          = 1'b0;\n    amo_bypass_req.reqtype      = ariane_pkg::SINGLE_REQ;\n    amo_bypass_req.amo          = ariane_pkg::AMO_NONE;\n    amo_bypass_req.addr         = '0;\n    amo_bypass_req.we           = 1'b0;\n    amo_bypass_req.wdata        = '0;\n    amo_bypass_req.be           = '0;\n    amo_bypass_req.size         = 2'b11;\n    amo_bypass_req.id           = 4'b1000 | 4'(NR_PORTS);  // map AMO id to the first non-MSHR id\n    // core\n    flush_ack_o                 = 1'b0;\n    miss_o                      = 1'b0;  // to performance counter\n    serve_amo_d                 = serve_amo_q;\n    // --------------------------------\n    // Flush and Miss operation\n    // --------------------------------\n    state_d                     = state_q;\n    cnt_d                       = cnt_q;\n    evict_way_d                 = evict_way_q;\n    evict_cl_d                  = evict_cl_q;\n    mshr_d                      = mshr_q;\n    // communicate to the requester which unit we are currently serving\n    active_serving_o[mshr_q.id] = mshr_q.valid;\n    // AMOs\n    amo_resp_o.ack              = 1'b0;\n    amo_resp_o.result           = '0;\n    amo_operand_b               = '0;\n\n    case (state_q)\n\n      IDLE: begin\n        // lowest priority are AMOs, wait until everything else is served before going for the AMOs\n        if (amo_req_i.req && !busy_i) begin\n          // 1. Flush the cache\n          state_d = FLUSH_REQ_STATUS;\n          serve_amo_d = 1'b1;\n          cnt_d = '0;\n        end\n        // check if we want to flush and can flush e.g.: we are not busy anymore\n        // TODO: Check that the busy flag is indeed needed\n        if (flush_i && !busy_i) begin\n          state_d = FLUSH_REQ_STATUS;\n          cnt_d   = '0;\n        end\n\n        // check if one of the state machines missed\n        for (int unsigned i = 0; i < NR_PORTS; i++) begin\n          // here comes the refill portion of code\n          if (miss_req_valid[i] && !miss_req_bypass[i]) begin\n            state_d      = MISS;\n            // we are taking another request so don't take the AMO\n            serve_amo_d  = 1'b0;\n            // save to MSHR\n            mshr_d.valid = 1'b1;\n            mshr_d.we    = miss_req_we[i];\n            mshr_d.id    = i;\n            mshr_d.addr  = miss_req_addr[i][DCACHE_TAG_WIDTH+DCACHE_INDEX_WIDTH-1:0];\n            mshr_d.wdata = miss_req_wdata[i];\n            mshr_d.be    = miss_req_be[i];\n            break;\n          end\n        end\n      end\n\n      //  ~> we missed on the cache\n      MISS: begin\n        // 1. Check if there is an empty cache-line\n        // 2. If not -> evict one\n        req_o   = '1;\n        addr_o  = mshr_q.addr[DCACHE_INDEX_WIDTH-1:0];\n        state_d = MISS_REPL;\n        miss_o  = 1'b1;\n      end\n\n      // ~> second miss cycle\n      MISS_REPL: begin\n        // if all are valid we need to evict one, pseudo random from LFSR\n        if (&valid_way) begin\n          lfsr_enable = 1'b1;\n          evict_way_d = lfsr_oh;\n          // do we need to write back the cache line?\n          if (data_i[lfsr_bin].dirty) begin\n            state_d = WB_CACHELINE_MISS;\n            evict_cl_d.tag = data_i[lfsr_bin].tag;\n            evict_cl_d.data = data_i[lfsr_bin].data;\n            cnt_d = mshr_q.addr[DCACHE_INDEX_WIDTH-1:0];\n            // no - we can request a cache line now\n          end else state_d = REQ_CACHELINE;\n          // we have at least one free way\n        end else begin\n          // get victim cache-line by looking for the first non-valid bit\n          evict_way_d = get_victim_cl(~valid_way);\n          state_d = REQ_CACHELINE;\n        end\n      end\n\n      // ~> we can just load the cache-line, the way is store in evict_way_q\n      REQ_CACHELINE: begin\n        req_fsm_miss_valid = 1'b1;\n        req_fsm_miss_addr  = mshr_q.addr;\n\n        if (gnt_miss_fsm) begin\n          state_d = SAVE_CACHELINE;\n          miss_gnt_o[mshr_q.id] = 1'b1;\n        end\n      end\n\n      // ~> replace the cacheline\n      SAVE_CACHELINE: begin\n        // calculate cacheline offset\n        automatic logic [$clog2(DCACHE_LINE_WIDTH)-1:0] cl_offset;\n        cl_offset = mshr_q.addr[DCACHE_BYTE_OFFSET-1:3] << 6;\n        // we've got a valid response from refill unit\n        if (valid_miss_fsm) begin\n\n          addr_o       = mshr_q.addr[DCACHE_INDEX_WIDTH-1:0];\n          req_o        = evict_way_q;\n          we_o         = 1'b1;\n          be_o         = '1;\n          be_o.vldrty  = evict_way_q;\n          data_o.tag   = mshr_q.addr[DCACHE_TAG_WIDTH+DCACHE_INDEX_WIDTH-1:DCACHE_INDEX_WIDTH];\n          data_o.data  = data_miss_fsm;\n          data_o.valid = 1'b1;\n          data_o.dirty = 1'b0;\n\n          // is this a write?\n          if (mshr_q.we) begin\n            // Yes, so safe the updated data now\n            for (int i = 0; i < 8; i++) begin\n              // check if we really want to write the corresponding byte\n              if (mshr_q.be[i]) data_o.data[(cl_offset+i*8)+:8] = mshr_q.wdata[i];\n            end\n            // its immediately dirty if we write\n            data_o.dirty = 1'b1;\n          end\n          // reset MSHR\n          mshr_d.valid = 1'b0;\n          // go back to idle\n          state_d = IDLE;\n        end\n      end\n\n      // ------------------------------\n      // Write Back Operation\n      // ------------------------------\n      // ~> evict a cache line from way saved in evict_way_q\n      WB_CACHELINE_FLUSH, WB_CACHELINE_MISS: begin\n\n        req_fsm_miss_valid = 1'b1;\n        req_fsm_miss_addr = {\n          evict_cl_q.tag,\n          cnt_q[DCACHE_INDEX_WIDTH-1:DCACHE_BYTE_OFFSET],\n          {{DCACHE_BYTE_OFFSET} {1'b0}}\n        };\n        req_fsm_miss_be = '1;\n        req_fsm_miss_we = 1'b1;\n        req_fsm_miss_wdata = evict_cl_q.data;\n\n        // we've got a grant --> this is timing critical, think about it\n        if (gnt_miss_fsm) begin\n          // write status array\n          addr_o       = cnt_q;\n          req_o        = 1'b1;\n          we_o         = 1'b1;\n          data_o.valid = INVALIDATE_ON_FLUSH ? 1'b0 : 1'b1;\n          // invalidate\n          be_o.vldrty  = evict_way_q;\n          // go back to handling the miss or flushing, depending on where we came from\n          state_d      = (state_q == WB_CACHELINE_MISS) ? MISS : FLUSH_REQ_STATUS;\n        end\n      end\n\n      // ------------------------------\n      // Flushing & Initialization\n      // ------------------------------\n      // ~> make another request to check the same cache-line if there are still some valid entries\n      FLUSH_REQ_STATUS: begin\n        req_o   = '1;\n        addr_o  = cnt_q;\n        state_d = FLUSHING;\n      end\n\n      FLUSHING: begin\n        // this has priority\n        // at least one of the cache lines is dirty\n        if (|evict_way) begin\n          // evict cache line, look for the first cache-line which is dirty\n          evict_way_d = get_victim_cl(evict_way);\n          evict_cl_d  = data_i[one_hot_to_bin(evict_way)];\n          state_d     = WB_CACHELINE_FLUSH;\n          // not dirty ~> increment and continue\n        end else begin\n          // increment and re-request\n          cnt_d       = cnt_q + (1'b1 << DCACHE_BYTE_OFFSET);\n          state_d     = FLUSH_REQ_STATUS;\n          addr_o      = cnt_q;\n          req_o       = 1'b1;\n          be_o.vldrty = INVALIDATE_ON_FLUSH ? '1 : '0;\n          we_o        = 1'b1;\n          // finished with flushing operation, go back to idle\n          if (cnt_q[DCACHE_INDEX_WIDTH-1:DCACHE_BYTE_OFFSET] == DCACHE_NUM_WORDS - 1) begin\n            // only acknowledge if the flush wasn't triggered by an atomic\n            flush_ack_o = ~serve_amo_q;\n            // if we are flushing because of an AMO go to serve it\n            if (serve_amo_q) begin\n              state_d = AMO_REQ;\n              serve_amo_d = 1'b0;\n            end else begin\n              state_d = IDLE;\n            end\n          end\n        end\n      end\n\n      // ~> only called after reset\n      INIT: begin\n        // initialize status array\n        addr_o      = cnt_q;\n        req_o       = 1'b1;\n        we_o        = 1'b1;\n        // only write the dirty array\n        be_o.vldrty = '1;\n        cnt_d       = cnt_q + (1'b1 << DCACHE_BYTE_OFFSET);\n        // finished initialization\n        if (cnt_q[DCACHE_INDEX_WIDTH-1:DCACHE_BYTE_OFFSET] == DCACHE_NUM_WORDS - 1) state_d = IDLE;\n      end\n      // ----------------------\n      // AMOs\n      // ----------------------\n      // ~> we are here because we need to do the AMO, the cache is clean at this point\n      AMO_REQ: begin\n        amo_bypass_req.req     = 1'b1;\n        amo_bypass_req.reqtype = ariane_pkg::SINGLE_REQ;\n        amo_bypass_req.amo     = amo_req_i.amo_op;\n        // address is in operand a\n        amo_bypass_req.addr    = amo_req_i.operand_a;\n        if (amo_req_i.amo_op != AMO_LR) begin\n          amo_bypass_req.we = 1'b1;\n        end\n        amo_bypass_req.size = amo_req_i.size;\n        // AXI implements CLR op instead of AND, negate operand\n        if (amo_req_i.amo_op == AMO_AND) begin\n          amo_operand_b = ~amo_req_i.operand_b;\n        end else begin\n          amo_operand_b = amo_req_i.operand_b;\n        end\n        // align data and byte-enable to correct byte lanes\n        amo_bypass_req.wdata = amo_operand_b;\n        if (amo_req_i.size == 2'b11) begin\n          // 64b transfer\n          amo_bypass_req.be = 8'b11111111;\n        end else begin\n          // 32b transfer\n          if (amo_req_i.operand_a[2:0] == '0) begin\n            // 64b aligned -> activate lower 4 byte lanes\n            amo_bypass_req.be = 8'b00001111;\n          end else begin\n            // 64b unaligned -> activate upper 4 byte lanes\n            amo_bypass_req.be = 8'b11110000;\n            amo_bypass_req.wdata = amo_operand_b[31:0] << 32;\n          end\n        end\n\n        // when request is accepted, wait for response\n        if (amo_bypass_rsp.gnt) begin\n          if (amo_bypass_rsp.valid) begin\n            state_d = IDLE;\n            amo_resp_o.ack = 1'b1;\n            amo_resp_o.result = amo_bypass_rsp.rdata;\n          end else begin\n            state_d = AMO_WAIT_RESP;\n          end\n        end\n      end\n      AMO_WAIT_RESP: begin\n        if (amo_bypass_rsp.valid) begin\n          state_d = IDLE;\n          amo_resp_o.ack = 1'b1;\n          // Request is assumed to be still valid (ack not granted yet)\n          if (amo_req_i.size == 2'b10) begin\n            // 32b request\n            logic [31:0] halfword;\n            if (amo_req_i.operand_a[2:0] == '0) begin\n              // 64b aligned -> activate lower 4 byte lanes\n              halfword = amo_bypass_rsp.rdata[31:0];\n            end else begin\n              // 64b unaligned -> activate upper 4 byte lanes\n              halfword = amo_bypass_rsp.rdata[63:32];\n            end\n            // Sign-extend 32b requests as per RISC-V spec\n            amo_resp_o.result = {{32{halfword[31]}}, halfword};\n          end else begin\n            // 64b request\n            amo_resp_o.result = amo_bypass_rsp.rdata;\n          end\n        end\n      end\n    endcase\n  end\n\n  // check MSHR for aliasing\n  always_comb begin\n\n    mshr_addr_matches_o  = 'b0;\n    mshr_index_matches_o = 'b0;\n\n    for (int i = 0; i < NR_PORTS; i++) begin\n      // check mshr for potential matching of other units, exclude the unit currently being served\n      if (mshr_q.valid && mshr_addr_i[i][55:DCACHE_BYTE_OFFSET] == mshr_q.addr[55:DCACHE_BYTE_OFFSET]) begin\n        mshr_addr_matches_o[i] = 1'b1;\n      end\n\n      // same as previous, but checking only the index\n      if (mshr_q.valid && mshr_addr_i[i][DCACHE_INDEX_WIDTH-1:DCACHE_BYTE_OFFSET] == mshr_q.addr[DCACHE_INDEX_WIDTH-1:DCACHE_BYTE_OFFSET]) begin\n        mshr_index_matches_o[i] = 1'b1;\n      end\n    end\n  end\n  // --------------------\n  // Sequential Process\n  // --------------------\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      mshr_q      <= '0;\n      state_q     <= INIT;\n      cnt_q       <= '0;\n      evict_way_q <= '0;\n      evict_cl_q  <= '0;\n      serve_amo_q <= 1'b0;\n    end else begin\n      mshr_q      <= mshr_d;\n      state_q     <= state_d;\n      cnt_q       <= cnt_d;\n      evict_way_q <= evict_way_d;\n      evict_cl_q  <= evict_cl_d;\n      serve_amo_q <= serve_amo_d;\n    end\n  end\n\n  //pragma translate_off\n`ifndef VERILATOR\n  // assert that cache only hits on one way\n  assert property (@(posedge clk_i) $onehot0(evict_way_q))\n  else $warning(\"Evict-way should be one-hot encoded\");\n`endif\n  //pragma translate_on\n\n  // ----------------------\n  // Pack bypass ports\n  // ----------------------\n  always_comb begin\n    logic [$clog2(NR_BYPASS_PORTS)-1:0] id;\n\n    // Pack MHSR ports first\n    for (id = 0; id < NR_PORTS; id++) begin\n      bypass_ports_req[id].req     = miss_req_valid[id] & miss_req_bypass[id];\n      bypass_ports_req[id].reqtype = ariane_pkg::SINGLE_REQ;\n      bypass_ports_req[id].amo     = AMO_NONE;\n      bypass_ports_req[id].id      = 4'b1000 | 4'(id);\n      bypass_ports_req[id].addr    = miss_req_addr[id];\n      bypass_ports_req[id].wdata   = miss_req_wdata[id];\n      bypass"}
{"text": "_ports_req[id].we      = miss_req_we[id];\n      bypass_ports_req[id].be      = miss_req_be[id];\n      bypass_ports_req[id].size    = miss_req_size[id];\n\n      bypass_gnt_o[id]             = bypass_ports_rsp[id].gnt;\n      bypass_valid_o[id]           = bypass_ports_rsp[id].valid;\n      bypass_data_o[id]            = bypass_ports_rsp[id].rdata;\n    end\n\n    // AMO port has lowest priority\n    bypass_ports_req[id] = amo_bypass_req;\n    amo_bypass_rsp       = bypass_ports_rsp[id];\n  end\n\n  // ----------------------\n  // Arbitrate bypass ports\n  // ----------------------\n  axi_adapter_arbiter #(\n      .NR_PORTS           (NR_BYPASS_PORTS),\n      .MAX_OUTSTANDING_REQ(CVA6Cfg.MaxOutstandingStores),\n      .req_t              (bypass_req_t),\n      .rsp_t              (bypass_rsp_t)\n  ) i_bypass_arbiter (\n      .clk_i (clk_i),\n      .rst_ni(rst_ni),\n      // Master Side\n      .req_i (bypass_ports_req),\n      .rsp_o (bypass_ports_rsp),\n      // Slave Side\n      .req_o (bypass_adapter_req),\n      .rsp_i (bypass_adapter_rsp)\n  );\n\n  // ----------------------\n  // Bypass AXI Interface\n  // ----------------------\n  // Cast bypass_adapter_req.addr to axi_adapter port size\n  logic [riscv::XLEN-1:0] bypass_addr;\n  assign bypass_addr = bypass_adapter_req.addr;\n\n  axi_adapter #(\n      .CVA6Cfg              (CVA6Cfg),\n      .DATA_WIDTH           (64),\n      .CACHELINE_BYTE_OFFSET(DCACHE_BYTE_OFFSET),\n      .axi_req_t            (axi_req_t),\n      .axi_rsp_t            (axi_rsp_t)\n  ) i_bypass_axi_adapter (\n      .clk_i(clk_i),\n      .rst_ni(rst_ni),\n      .req_i(bypass_adapter_req.req),\n      .type_i(bypass_adapter_req.reqtype),\n      .amo_i(bypass_adapter_req.amo),\n      .id_i(({{CVA6Cfg.AxiIdWidth - 4{1'b0}}, bypass_adapter_req.id})),\n      .addr_i(bypass_addr),\n      .wdata_i(bypass_adapter_req.wdata),\n      .we_i(bypass_adapter_req.we),\n      .be_i(bypass_adapter_req.be),\n      .size_i(bypass_adapter_req.size),\n      .gnt_o(bypass_adapter_rsp.gnt),\n      .valid_o(bypass_adapter_rsp.valid),\n      .rdata_o(bypass_adapter_rsp.rdata),\n      .id_o(),  // not used, single outstanding request in arbiter\n      .critical_word_o(),  // not used for single requests\n      .critical_word_valid_o(),  // not used for single requests\n      .axi_req_o(axi_bypass_o),\n      .axi_resp_i(axi_bypass_i)\n  );\n\n  // ----------------------\n  // Cache Line AXI Refill\n  // ----------------------\n  // Cast req_fsm_miss_addr to axi_adapter port size\n  logic [riscv::XLEN-1:0] miss_addr;\n  assign miss_addr = req_fsm_miss_addr;\n\n  axi_adapter #(\n      .CVA6Cfg              (CVA6Cfg),\n      .DATA_WIDTH           (DCACHE_LINE_WIDTH),\n      .CACHELINE_BYTE_OFFSET(DCACHE_BYTE_OFFSET),\n      .axi_req_t            (axi_req_t),\n      .axi_rsp_t            (axi_rsp_t)\n  ) i_miss_axi_adapter (\n      .clk_i,\n      .rst_ni,\n      .req_i                (req_fsm_miss_valid),\n      .type_i               (req_fsm_miss_req),\n      .amo_i                (AMO_NONE),\n      .gnt_o                (gnt_miss_fsm),\n      .addr_i               (miss_addr),\n      .we_i                 (req_fsm_miss_we),\n      .wdata_i              (req_fsm_miss_wdata),\n      .be_i                 (req_fsm_miss_be),\n      .size_i               (req_fsm_miss_size),\n      .id_i                 ({{CVA6Cfg.AxiIdWidth - 4{1'b0}}, 4'b0111}),\n      .valid_o              (valid_miss_fsm),\n      .rdata_o              (data_miss_fsm),\n      .id_o                 (),\n      .critical_word_o      (critical_word_o),\n      .critical_word_valid_o(critical_word_valid_o),\n      .axi_req_o            (axi_data_o),\n      .axi_resp_i           (axi_data_i)\n  );\n\n  // -----------------\n  // Replacement LFSR\n  // -----------------\n  lfsr_8bit #(\n      .WIDTH(DCACHE_SET_ASSOC)\n  ) i_lfsr (\n      .en_i          (lfsr_enable),\n      .refill_way_oh (lfsr_oh),\n      .refill_way_bin(lfsr_bin),\n      .*\n  );\n\n  // -----------------\n  // Struct Split\n  // -----------------\n  // Hack as system verilog support in modelsim seems to be buggy here\n  always_comb begin\n    automatic miss_req_t miss_req;\n\n    for (int unsigned i = 0; i < NR_PORTS; i++) begin\n      miss_req           = miss_req_t'(miss_req_i[i]);\n      miss_req_valid[i]  = miss_req.valid;\n      miss_req_bypass[i] = miss_req.bypass;\n      miss_req_addr[i]   = miss_req.addr;\n      miss_req_wdata[i]  = miss_req.wdata;\n      miss_req_we[i]     = miss_req.we;\n      miss_req_be[i]     = miss_req.be;\n      miss_req_size[i]   = miss_req.size;\n    end\n  end\nendmodule\n\n// --------------\n// AXI Arbiter\n// --------------\n//\n// Description: Arbitrates access to AXI refill/bypass\n//\nmodule axi_adapter_arbiter #(\n    parameter NR_PORTS = 4,\n    parameter MAX_OUTSTANDING_REQ = 0,\n    parameter type req_t = std_cache_pkg::bypass_req_t,\n    parameter type rsp_t = std_cache_pkg::bypass_rsp_t\n) (\n    input  logic                clk_i,   // Clock\n    input  logic                rst_ni,  // Asynchronous reset active low\n    // Master ports\n    input  req_t [NR_PORTS-1:0] req_i,\n    output rsp_t [NR_PORTS-1:0] rsp_o,\n    // Slave port\n    output req_t                req_o,\n    input  rsp_t                rsp_i\n);\n\n  localparam MAX_OUTSTANDING_CNT_WIDTH = $clog2(\n      MAX_OUTSTANDING_REQ + 1\n  ) > 0 ? $clog2(\n      MAX_OUTSTANDING_REQ + 1\n  ) : 1;\n\n  typedef logic [MAX_OUTSTANDING_CNT_WIDTH-1:0] outstanding_cnt_t;\n\n  enum logic {\n    IDLE,\n    SERVING\n  }\n      state_d, state_q;\n\n  req_t req_d, req_q;\n  logic [NR_PORTS-1:0] sel_d, sel_q;\n  outstanding_cnt_t outstanding_cnt_d, outstanding_cnt_q;\n\n  logic [NR_PORTS-1:0] req_flat;\n  logic any_unselected_port_valid;\n\n  for (genvar i = 0; i < NR_PORTS; i++) begin : gen_req_flat\n    assign req_flat[i] = req_i[i].req;\n  end\n  assign any_unselected_port_valid = |(req_flat & ~(1 << sel_q));\n\n\n  always_comb begin\n    sel_d = sel_q;\n    outstanding_cnt_d = outstanding_cnt_q;\n\n    state_d = state_q;\n    req_d = req_q;\n\n    req_o = req_q;\n\n    rsp_o = '0;\n    rsp_o[sel_q].rdata = rsp_i.rdata;\n\n    case (state_q)\n\n      IDLE: begin\n        // wait for incoming requests\n        for (int unsigned i = 0; i < NR_PORTS; i++) begin\n          if (req_i[i].req == 1'b1) begin\n            sel_d   = i[$bits(sel_d)-1:0];\n            state_d = SERVING;\n            break;\n          end\n        end\n\n        req_d = req_i[sel_d];\n        req_o = req_i[sel_d];\n        rsp_o[sel_d].gnt = req_i[sel_d].req;\n\n        // Count outstanding transactions, i.e. requests which have been\n        // granted but response hasn't arrived yet\n        if (req_o.req && rsp_i.gnt) begin\n          req_d.req = 1'b0;\n          outstanding_cnt_d += 1;\n        end\n      end\n\n      SERVING: begin\n        // We can accept multiple outstanding transactions from same port.\n        // To ensure fairness, we allow this only if all other ports are idle\n        if ((!req_o.req) && !any_unselected_port_valid &&\n          (outstanding_cnt_q != (MAX_OUTSTANDING_REQ - 1))) begin\n          if (req_i[sel_q].req) begin\n            req_d = req_i[sel_q];\n            req_o = req_i[sel_q];\n            rsp_o[sel_q].gnt = 1'b1;\n            state_d = SERVING;\n          end\n        end\n\n        // Count outstanding transactions, i.e. requests which have been\n        // granted but response hasn't arrived yet\n        if (req_o.req && rsp_i.gnt) begin\n          req_d.req = 1'b0;\n          outstanding_cnt_d += 1;\n        end\n        if (rsp_i.valid) begin\n          outstanding_cnt_d -= 1;\n          rsp_o[sel_q].valid = 1'b1;\n\n          if ((outstanding_cnt_d == 0) && (!req_o.req || rsp_i.gnt)) state_d = IDLE;\n        end\n      end\n\n      default:  /* default */;\n    endcase\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      state_q           <= IDLE;\n      sel_q             <= '0;\n      req_q             <= '0;\n      outstanding_cnt_q <= '0;\n    end else begin\n      state_q           <= state_d;\n      sel_q             <= sel_d;\n      req_q             <= req_d;\n      outstanding_cnt_q <= outstanding_cnt_d;\n    end\n  end\n  // ------------\n  // Assertions\n  // ------------\n\n  //pragma translate_off\n`ifndef VERILATOR\n  // make sure that we eventually get an rvalid after we received a grant\n  assert property (@(posedge clk_i) rsp_i.gnt |-> ##[1:$] rsp_i.valid)\n  else begin\n    $error(\"There was a grant without a rvalid\");\n    $stop();\n  end\n  // assert that there is no grant without a request or outstanding transactions\n  assert property (@(negedge clk_i) rsp_i.gnt |-> req_o.req)\n  else begin\n    $error(\"There was a grant without a request.\");\n    $stop();\n  end\n  // assert that the address does not contain X when request is sent\n  assert property (@(posedge clk_i) (req_o.req) |-> (!$isunknown(req_o.addr)))\n  else begin\n    $error(\"address contains X when request is set\");\n    $stop();\n  end\n\n`endif\n  //pragma translate_on\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 19/04/2017\n// Description: Memory Management Unit for Ariane, contains TLB and\n//              address translation unit. SV39 as defined in RISC-V\n//              privilege specification 1.11-WIP\n\n\nmodule mmu\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg           = config_pkg::cva6_cfg_empty,\n    parameter int unsigned           INSTR_TLB_ENTRIES = 4,\n    parameter int unsigned           DATA_TLB_ENTRIES  = 4,\n    parameter int unsigned           ASID_WIDTH        = 1\n) (\n    input logic clk_i,\n    input logic rst_ni,\n    input logic flush_i,\n    input logic enable_translation_i,\n    input logic en_ld_st_translation_i,  // enable virtual memory translation for load/stores\n    // IF interface\n    input icache_arsp_t icache_areq_i,\n    output icache_areq_t icache_areq_o,\n    // LSU interface\n    // this is a more minimalistic interface because the actual addressing logic is handled\n    // in the LSU as we distinguish load and stores, what we do here is simple address translation\n    input exception_t misaligned_ex_i,\n    input logic lsu_req_i,  // request address translation\n    input logic [riscv::VLEN-1:0] lsu_vaddr_i,  // virtual address in\n    input logic lsu_is_store_i,  // the translation is requested by a store\n    // if we need to walk the page table we can't grant in the same cycle\n    // Cycle 0\n    output logic                            lsu_dtlb_hit_o,   // sent in the same cycle as the request if translation hits in the DTLB\n    output logic [riscv::PPNW-1:0] lsu_dtlb_ppn_o,  // ppn (send same cycle as hit)\n    // Cycle 1\n    output logic lsu_valid_o,  // translation is valid\n    output logic [riscv::PLEN-1:0] lsu_paddr_o,  // translated address\n    output exception_t lsu_exception_o,  // address translation threw an exception\n    // General control signals\n    input riscv::priv_lvl_t priv_lvl_i,\n    input riscv::priv_lvl_t ld_st_priv_lvl_i,\n    input logic sum_i,\n    input logic mxr_i,\n    // input logic flag_mprv_i,\n    input logic [riscv::PPNW-1:0] satp_ppn_i,\n    input logic [ASID_WIDTH-1:0] asid_i,\n    input logic [ASID_WIDTH-1:0] asid_to_be_flushed_i,\n    input logic [riscv::VLEN-1:0] vaddr_to_be_flushed_i,\n    input logic flush_tlb_i,\n    // Performance counters\n    output logic itlb_miss_o,\n    output logic dtlb_miss_o,\n    // PTW memory interface\n    input dcache_req_o_t req_port_i,\n    output dcache_req_i_t req_port_o,\n    // PMP\n    input riscv::pmpcfg_t [15:0] pmpcfg_i,\n    input logic [15:0][riscv::PLEN-3:0] pmpaddr_i\n);\n\n  logic                   iaccess_err;  // insufficient privilege to access this instruction page\n  logic                   daccess_err;  // insufficient privilege to access this data page\n  logic                   ptw_active;  // PTW is currently walking a page table\n  logic                   walking_instr;  // PTW is walking because of an ITLB miss\n  logic                   ptw_error;  // PTW threw an exception\n  logic                   ptw_access_exception;  // PTW threw an access exception (PMPs)\n  logic [riscv::PLEN-1:0] ptw_bad_paddr;  // PTW PMP exception bad physical addr\n\n  logic [riscv::VLEN-1:0] update_vaddr;\n  tlb_update_t update_ptw_itlb, update_ptw_dtlb;\n\n  logic        itlb_lu_access;\n  riscv::pte_t itlb_content;\n  logic        itlb_is_2M;\n  logic        itlb_is_1G;\n  logic        itlb_lu_hit;\n\n  logic        dtlb_lu_access;\n  riscv::pte_t dtlb_content;\n  logic        dtlb_is_2M;\n  logic        dtlb_is_1G;\n  logic        dtlb_lu_hit;\n\n\n  // Assignments\n  assign itlb_lu_access = icache_areq_i.fetch_req;\n  assign dtlb_lu_access = lsu_req_i;\n\n\n  tlb #(\n      .CVA6Cfg    (CVA6Cfg),\n      .TLB_ENTRIES(INSTR_TLB_ENTRIES),\n      .ASID_WIDTH (ASID_WIDTH)\n  ) i_itlb (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i(flush_tlb_i),\n\n      .update_i(update_ptw_itlb),\n\n      .lu_access_i          (itlb_lu_access),\n      .lu_asid_i            (asid_i),\n      .asid_to_be_flushed_i (asid_to_be_flushed_i),\n      .vaddr_to_be_flushed_i(vaddr_to_be_flushed_i),\n      .lu_vaddr_i           (icache_areq_i.fetch_vaddr),\n      .lu_content_o         (itlb_content),\n\n      .lu_is_2M_o(itlb_is_2M),\n      .lu_is_1G_o(itlb_is_1G),\n      .lu_hit_o  (itlb_lu_hit)\n  );\n\n  tlb #(\n      .CVA6Cfg    (CVA6Cfg),\n      .TLB_ENTRIES(DATA_TLB_ENTRIES),\n      .ASID_WIDTH (ASID_WIDTH)\n  ) i_dtlb (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i(flush_tlb_i),\n\n      .update_i(update_ptw_dtlb),\n\n      .lu_access_i          (dtlb_lu_access),\n      .lu_asid_i            (asid_i),\n      .asid_to_be_flushed_i (asid_to_be_flushed_i),\n      .vaddr_to_be_flushed_i(vaddr_to_be_flushed_i),\n      .lu_vaddr_i           (lsu_vaddr_i),\n      .lu_content_o         (dtlb_content),\n\n      .lu_is_2M_o(dtlb_is_2M),\n      .lu_is_1G_o(dtlb_is_1G),\n      .lu_hit_o  (dtlb_lu_hit)\n  );\n\n\n  ptw #(\n      .CVA6Cfg   (CVA6Cfg),\n      .ASID_WIDTH(ASID_WIDTH)\n  ) i_ptw (\n      .clk_i                 (clk_i),\n      .rst_ni                (rst_ni),\n      .ptw_active_o          (ptw_active),\n      .walking_instr_o       (walking_instr),\n      .ptw_error_o           (ptw_error),\n      .ptw_access_exception_o(ptw_access_exception),\n      .enable_translation_i  (enable_translation_i),\n\n      .update_vaddr_o(update_vaddr),\n      .itlb_update_o (update_ptw_itlb),\n      .dtlb_update_o (update_ptw_dtlb),\n\n      .itlb_access_i(itlb_lu_access),\n      .itlb_hit_i   (itlb_lu_hit),\n      .itlb_vaddr_i (icache_areq_i.fetch_vaddr),\n\n      .dtlb_access_i(dtlb_lu_access),\n      .dtlb_hit_i   (dtlb_lu_hit),\n      .dtlb_vaddr_i (lsu_vaddr_i),\n\n      .req_port_i (req_port_i),\n      .req_port_o (req_port_o),\n      .pmpcfg_i,\n      .pmpaddr_i,\n      .bad_paddr_o(ptw_bad_paddr),\n      .*\n  );\n\n  // ila_1 i_ila_1 (\n  //     .clk(clk_i), // input wire clk\n  //     .probe0({req_port_o.address_tag, req_port_o.address_index}),\n  //     .probe1(req_port_o.data_req), // input wire [63:0]  probe1\n  //     .probe2(req_port_i.data_gnt), // input wire [0:0]  probe2\n  //     .probe3(req_port_i.data_rdata), // input wire [0:0]  probe3\n  //     .probe4(req_port_i.data_rvalid), // input wire [0:0]  probe4\n  //     .probe5(ptw_error), // input wire [1:0]  probe5\n  //     .probe6(update_vaddr), // input wire [0:0]  probe6\n  //     .probe7(update_ptw_itlb.valid), // input wire [0:0]  probe7\n  //     .probe8(update_ptw_dtlb.valid), // input wire [0:0]  probe8\n  //     .probe9(dtlb_lu_access), // input wire [0:0]  probe9\n  //     .probe10(lsu_vaddr_i), // input wire [0:0]  probe10\n  //     .probe11(dtlb_lu_hit), // input wire [0:0]  probe11\n  //     .probe12(itlb_lu_access), // input wire [0:0]  probe12\n  //     .probe13(icache_areq_i.fetch_vaddr), // input wire [0:0]  probe13\n  //     .probe14(itlb_lu_hit) // input wire [0:0]  probe13\n  // );\n\n  //-----------------------\n  // Instruction Interface\n  //-----------------------\n  logic match_any_execute_region;\n  logic pmp_instr_allow;\n\n  // The instruction interface is a simple request response interface\n  always_comb begin : instr_interface\n    // MMU disabled: just pass through\n    icache_areq_o.fetch_valid = icache_areq_i.fetch_req;\n    icache_areq_o.fetch_paddr  = icache_areq_i.fetch_vaddr[riscv::PLEN-1:0]; // play through in case we disabled address translation\n    // two potential exception sources:\n    // 1. HPTW threw an exception -> signal with a page fault exception\n    // 2. We got an access error because of insufficient permissions -> throw an access exception\n    icache_areq_o.fetch_exception = '0;\n    // Check whether we are allowed to access this memory region from a fetch perspective\n    iaccess_err   = icache_areq_i.fetch_req && enable_translation_i\n                                                 && (((priv_lvl_i == riscv::PRIV_LVL_U) && ~itlb_content.u)\n                                                 || ((priv_lvl_i == riscv::PRIV_LVL_S) && itlb_content.u));\n\n    // MMU enabled: address from TLB, request delayed until hit. Error when TLB\n    // hit and no access right or TLB hit and translated address not valid (e.g.\n    // AXI decode error), or when PTW performs walk due to ITLB miss and raises\n    // an error.\n    if (enable_translation_i) begin\n      // we work with SV39 or SV32, so if VM is enabled, check that all bits [riscv::VLEN-1:riscv::SV-1] are equal\n      if (icache_areq_i.fetch_req && !((&icache_areq_i.fetch_vaddr[riscv::VLEN-1:riscv::SV-1]) == 1'b1 || (|icache_areq_i.fetch_vaddr[riscv::VLEN-1:riscv::SV-1]) == 1'b0)) begin\n        icache_areq_o.fetch_exception.cause = riscv::INSTR_ACCESS_FAULT;\n        icache_areq_o.fetch_exception.valid = 1'b1;\n        if (CVA6Cfg.TvalEn)\n          icache_areq_o.fetch_exception.tval = {\n            {riscv::XLEN - riscv::VLEN{1'b0}}, icache_areq_i.fetch_vaddr\n          };\n      end\n\n      icache_areq_o.fetch_valid = 1'b0;\n\n      // 4K page\n      icache_areq_o.fetch_paddr = {itlb_content.ppn, icache_areq_i.fetch_vaddr[11:0]};\n      // Mega page\n      if (itlb_is_2M) begin\n        icache_areq_o.fetch_paddr[20:12] = icache_areq_i.fetch_vaddr[20:12];\n      end\n      // Giga page\n      if (itlb_is_1G) begin\n        icache_areq_o.fetch_paddr[29:12] = icache_areq_i.fetch_vaddr[29:12];\n      end\n\n      // ---------\n      // ITLB Hit\n      // --------\n      // if we hit the ITLB output the request signal immediately\n      if (itlb_lu_hit) begin\n        icache_areq_o.fetch_valid = icache_areq_i.fetch_req;\n        // we got an access error\n        if (iaccess_err) begin\n          // throw a page fault\n          icache_areq_o.fetch_exception.cause = riscv::INSTR_PAGE_FAULT;\n          icache_areq_o.fetch_exception.valid = 1'b1;\n          if (CVA6Cfg.TvalEn)\n            icache_areq_o.fetch_exception.tval = {\n              {riscv::XLEN - riscv::VLEN{1'b0}}, icache_areq_i.fetch_vaddr\n            };\n        end else if (!pmp_instr_allow) begin\n          icache_areq_o.fetch_exception.cause = riscv::INSTR_ACCESS_FAULT;\n          icache_areq_o.fetch_exception.valid = 1'b1;\n          if (CVA6Cfg.TvalEn)\n            icache_areq_o.fetch_exception.tval = {\n              {riscv::XLEN - riscv::VLEN{1'b0}}, icache_areq_i.fetch_vaddr\n            };\n        end\n      end else\n      // ---------\n      // ITLB Miss\n      // ---------\n      // watch out for exceptions happening during walking the page table\n      if (ptw_active && walking_instr) begin\n        icache_areq_o.fetch_valid = ptw_error | ptw_access_exception;\n        if (ptw_error) begin\n          icache_areq_o.fetch_exception.cause = riscv::INSTR_PAGE_FAULT;\n          icache_areq_o.fetch_exception.valid = 1'b1;\n          if (CVA6Cfg.TvalEn)\n            icache_areq_o.fetch_exception.tval = {{riscv::XLEN - riscv::VLEN{1'b0}}, update_vaddr};\n        end else begin\n          icache_areq_o.fetch_exception.cause = riscv::INSTR_ACCESS_FAULT;\n          icache_areq_o.fetch_exception.valid = 1'b1;\n          if (CVA6Cfg.TvalEn)\n            icache_areq_o.fetch_exception.tval = {{riscv::XLEN - riscv::VLEN{1'b0}}, update_vaddr};\n        end\n      end\n    end\n    // if it didn't match any execute region throw an `Instruction Access Fault`\n    // or: if we are not translating, check PMPs immediately on the paddr\n    if ((!match_any_execute_region && !ptw_error) || (!enable_translation_i && !pmp_instr_allow)) begin\n      icache_areq_o.fetch_exception.cause = riscv::INSTR_ACCESS_FAULT;\n      icache_areq_o.fetch_exception.valid = 1'b1;\n      if (CVA6Cfg.TvalEn)\n        icache_areq_o.fetch_exception.tval = {\n          {riscv::XLEN - riscv::PLEN{1'b0}}, icache_areq_o.fetch_paddr\n        };\n    end\n  end\n\n  // check for execute flag on memory\n  assign match_any_execute_region = config_pkg::is_inside_execute_regions(\n      CVA6Cfg, {{64 - riscv::PLEN{1'b0}}, icache_areq_o.fetch_paddr}\n  );\n\n  // Instruction fetch\n  pmp #(\n      .CVA6Cfg   (CVA6Cfg),\n      .PLEN      (riscv::PLEN),\n      .PMP_LEN   (riscv::PLEN - 2),\n      .NR_ENTRIES(CVA6Cfg.NrPMPEntries)\n  ) i_pmp_if (\n      .addr_i       (icache_areq_o.fetch_paddr),\n      .priv_lvl_i,\n      // we will always execute on the instruction fetch port\n      .access_type_i(riscv::ACCESS_EXEC),\n      // Configuration\n      .conf_addr_i  (pmpaddr_i),\n      .conf_i       (pmpcfg_i),\n      .allow_o      (pmp_instr_allow)\n  );\n\n  //-----------------------\n  // Data Interface\n  //-----------------------\n  logic [riscv::VLEN-1:0] lsu_vaddr_n, lsu_vaddr_q;\n  riscv::pte_t dtlb_pte_n, dtlb_pte_q;\n  exception_t misaligned_ex_n, misaligned_ex_q;\n  logic lsu_req_n, lsu_req_q;\n  logic lsu_is_store_n, lsu_is_store_q;\n  logic dtlb_hit_n, dtlb_hit_q;\n  logic dtlb_is_2M_n, dtlb_is_2M_q;\n  logic dtlb_is_1G_n, dtlb_is_1G_q;\n\n  // check if we need to do translation or if we are always ready (e.g.: we are not translating anything)\n  assign lsu_dtlb_hit_o = (en_ld_st_translation_i) ? dtlb_lu_hit : 1'b1;\n\n  // Wires to PMP checks\n  riscv::pmp_access_t pmp_access_type;\n  logic               pmp_data_allow;\n  localparam PPNWMin = (riscv::PPNW - 1 > 29) ? 29 : riscv::PPNW - 1;\n  // The data interface is simpler and only consists of a request/response interface\n  always_comb begin : data_interface\n    // save request and DTLB response\n    lsu_vaddr_n = lsu_vaddr_i;\n    lsu_req_n = lsu_req_i;\n    misaligned_ex_n = misaligned_ex_i;\n    dtlb_pte_n = dtlb_content;\n    dtlb_hit_n = dtlb_lu_hit;\n    lsu_is_store_n = lsu_is_store_i;\n    dtlb_is_2M_n = dtlb_is_2M;\n    dtlb_is_1G_n = dtlb_is_1G;\n\n    lsu_paddr_o = lsu_vaddr_q[riscv::PLEN-1:0];\n    lsu_dtlb_ppn_o = lsu_vaddr_n[riscv::PLEN-1:12];\n    lsu_valid_o = lsu_req_q;\n    lsu_exception_o = misaligned_ex_q;\n    pmp_access_type = lsu_is_store_q ? riscv::ACCESS_WRITE : riscv::ACCESS_READ;\n\n    // mute misaligned exceptions if there is no request otherwise they will throw accidental exceptions\n    misaligned_ex_n.valid = misaligned_ex_i.valid & lsu_req_i;\n\n    // Check if the User flag is set, then we may only access it in supervisor mode\n    // if SUM is enabled\n    daccess_err = en_ld_st_translation_i && ((ld_st_priv_lvl_i == riscv::PRIV_LVL_S && !sum_i && dtlb_pte_q.u) || // SUM is not set and we are trying to access a user page in supervisor mode\n    (ld_st_priv_lvl_i == riscv::PRIV_LVL_U && !dtlb_pte_q.u));            // this is not a user page but we are in user mode and trying to access it\n    // translation is enabled and no misaligned exception occurred\n    if (en_ld_st_translation_i && !misaligned_ex_q.valid) begin\n      lsu_valid_o = 1'b0;\n      // 4K page\n      lsu_paddr_o = {dtlb_pte_q.ppn, lsu_vaddr_q[11:0]};\n      lsu_dtlb_ppn_o = dtlb_content.ppn;\n      // Mega page\n      if (dtlb_is_2M_q) begin\n        lsu_paddr_o[20:12] = lsu_vaddr_q[20:12];\n        lsu_dtlb_ppn_o[20:12] = lsu_vaddr_n[20:12];\n      end\n      // Giga page\n      if (dtlb_is_1G_q) begin\n        lsu_paddr_o[PPNWMin:12] = lsu_vaddr_q[PPNWMin:12];\n        lsu_dtlb_ppn_o[PPNWMin:12] = lsu_vaddr_n[PPNWMin:12];\n      end\n      // ---------\n      // DTLB Hit\n      // --------\n      if (dtlb_hit_q && lsu_req_q) begin\n        lsu_valid_o = 1'b1;\n        // exception priority:\n        // PAGE_FAULTS have higher priority than ACCESS_FAULTS\n        // virtual memory based exceptions are PAGE_FAULTS\n        // physical memory based exceptions are ACCESS_FAULTS (PMA/PMP)\n\n        // this is a store\n        if (lsu_is_store_q) begin\n          // check if the page is write-able and we are not violating privileges\n          // also check if the dirty flag is set\n          if (!dtlb_pte_q.w || daccess_err || !dtlb_pte_q.d) begin\n            lsu_exception_o.cause = riscv::STORE_PAGE_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn)\n              lsu_exception_o.tval = {\n                {riscv::XLEN - riscv::VLEN{lsu_vaddr_q[riscv::VLEN-1]}}, lsu_vaddr_q\n              };\n            // Check if any PMPs are violated\n          end else if (!pmp_data_allow) begin\n            lsu_exception_o.cause = riscv::ST_ACCESS_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn)\n              lsu_exception_o.tval = {\n                {riscv::XLEN - riscv::VLEN{lsu_vaddr_q[riscv::VLEN-1]}}, lsu_vaddr_q\n              };\n          end\n\n          // this is a load\n        end else begin\n          // check for sufficient access privileges - throw a page fault if necessary\n          if (daccess_err) begin\n            lsu_exception_o.cause = riscv::LOAD_PAGE_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn)\n              lsu_exception_o.tval = {\n                {riscv::XLEN - riscv::VLEN{lsu_vaddr_q[riscv::VLEN-1]}}, lsu_vaddr_q\n              };\n            // Check if any PMPs are violated\n          end else if (!pmp_data_allow) begin\n            lsu_exception_o.cause = riscv::LD_ACCESS_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn)\n              lsu_exception_o.tval = {\n                {riscv::XLEN - riscv::VLEN{lsu_vaddr_q[riscv::VLEN-1]}}, lsu_vaddr_q\n              };\n          end\n        end\n      end else\n\n      // ---------\n      // DTLB Miss\n      // ---------\n      // watch out for exceptions\n      if (ptw_active && !walking_instr) begin\n        // page table walker threw an exception\n        if (ptw_error) begin\n          // an error makes the translation valid\n          lsu_valid_o = 1'b1;\n          // the page table walker can only throw page faults\n          if (lsu_is_store_q) begin\n            lsu_exception_o.cause = riscv::STORE_PAGE_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn)\n              lsu_exception_o.tval = {\n                {riscv::XLEN - riscv::VLEN{lsu_vaddr_q[riscv::VLEN-1]}}, update_vaddr\n              };\n          end else begin\n            lsu_exception_o.cause = riscv::LOAD_PAGE_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn)\n              lsu_exception_o.tval = {\n                {riscv::XLEN - riscv::VLEN{lsu_vaddr_q[riscv::VLEN-1]}}, update_vaddr\n              };\n          end\n        end\n\n        if (ptw_access_exception) begin\n          // an error makes the translation valid\n          lsu_valid_o = 1'b1;\n          // Any fault of the page table walk should be based of the original access type\n          if (lsu_is_store_q) begin\n            lsu_exception_o.cause = riscv::ST_ACCESS_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn)\n              lsu_exception_o.tval = {{riscv::XLEN - riscv::VLEN{1'b0}}, lsu_vaddr_n};\n          end else begin\n            lsu_exception_o.cause = riscv::LD_ACCESS_FAULT;\n            lsu_exception_o.valid = 1'b1;\n            if (CVA6Cfg.TvalEn)\n              lsu_exception_o.tval = {{riscv::XLEN - riscv::VLEN{1'b0}}, lsu_vaddr_n};\n          end\n        end\n      end\n    end  // If translation is not enabled, check the paddr immediately against PMPs\n    else if (lsu_req_q && !misaligned_ex_q.valid && !pmp_data_allow) begin\n      if (lsu_is_store_q) begin\n        lsu_exception_o.cause = riscv::ST_ACCESS_FAULT;\n        lsu_exception_o.valid = 1'b1;\n        if (CVA6Cfg.TvalEn) lsu_exception_o.tval = {{riscv::XLEN - riscv::PLEN{1'b0}}, lsu_paddr_o};\n      end else begin\n        lsu_exception_o.cause = riscv::LD_ACCESS_FAULT;\n        lsu_exception_o.valid = 1'b1;\n        if (CVA6Cfg.TvalEn) lsu_exception_o.tval = {{riscv"}
{"text": "::XLEN - riscv::PLEN{1'b0}}, lsu_paddr_o};\n      end\n    end\n  end\n\n  // Load/store PMP check\n  pmp #(\n      .CVA6Cfg   (CVA6Cfg),\n      .PLEN      (riscv::PLEN),\n      .PMP_LEN   (riscv::PLEN - 2),\n      .NR_ENTRIES(CVA6Cfg.NrPMPEntries)\n  ) i_pmp_data (\n      .addr_i       (lsu_paddr_o),\n      .priv_lvl_i   (ld_st_priv_lvl_i),\n      .access_type_i(pmp_access_type),\n      // Configuration\n      .conf_addr_i  (pmpaddr_i),\n      .conf_i       (pmpcfg_i),\n      .allow_o      (pmp_data_allow)\n  );\n\n  // ----------\n  // Registers\n  // ----------\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      lsu_vaddr_q     <= '0;\n      lsu_req_q       <= '0;\n      misaligned_ex_q <= '0;\n      dtlb_pte_q      <= '0;\n      dtlb_hit_q      <= '0;\n      lsu_is_store_q  <= '0;\n      dtlb_is_2M_q    <= '0;\n      dtlb_is_1G_q    <= '0;\n    end else begin\n      lsu_vaddr_q     <= lsu_vaddr_n;\n      lsu_req_q       <= lsu_req_n;\n      misaligned_ex_q <= misaligned_ex_n;\n      dtlb_pte_q      <= dtlb_pte_n;\n      dtlb_hit_q      <= dtlb_hit_n;\n      lsu_is_store_q  <= lsu_is_store_n;\n      dtlb_is_2M_q    <= dtlb_is_2M_n;\n      dtlb_is_1G_q    <= dtlb_is_1G_n;\n    end\n  end\nendmodule\n"}
{"text": "\n\nmodule mult\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input  logic                             clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input  logic                             rst_ni,\n    // Flush - CONTROLLER\n    input  logic                             flush_i,\n    // FU data needed to execute instruction - ISSUE_STAGE\n    input  fu_data_t                         fu_data_i,\n    // Mult instruction is valid - ISSUE_STAGE\n    input  logic                             mult_valid_i,\n    // Mult result - ISSUE_STAGE\n    output riscv::xlen_t                     result_o,\n    // Mult result is valid - ISSUE_STAGE\n    output logic                             mult_valid_o,\n    // Mutl is ready - ISSUE_STAGE\n    output logic                             mult_ready_o,\n    // Mult transaction ID - ISSUE_STAGE\n    output logic         [TRANS_ID_BITS-1:0] mult_trans_id_o\n);\n  logic mul_valid;\n  logic div_valid;\n  logic div_ready_i;  // receiver of division result is able to accept the result\n  logic [TRANS_ID_BITS-1:0] mul_trans_id;\n  logic [TRANS_ID_BITS-1:0] div_trans_id;\n  riscv::xlen_t mul_result;\n  riscv::xlen_t div_result;\n\n  logic div_valid_op;\n  logic mul_valid_op;\n  // Input Arbitration\n\n  assign mul_valid_op = ~flush_i && mult_valid_i && (fu_data_i.operation inside { MUL, MULH, MULHU, MULHSU, MULW, CLMUL, CLMULH, CLMULR });\n\n  assign div_valid_op = ~flush_i && mult_valid_i && (fu_data_i.operation inside { DIV, DIVU, DIVW, DIVUW, REM, REMU, REMW, REMUW });\n\n  // ---------------------\n  // Output Arbitration\n  // ---------------------\n  // we give precedence to multiplication as the divider supports stalling and the multiplier is\n  // just a dumb pipelined multiplier\n  assign div_ready_i = (mul_valid) ? 1'b0 : 1'b1;\n  assign mult_trans_id_o = (mul_valid) ? mul_trans_id : div_trans_id;\n  assign result_o = (mul_valid) ? mul_result : div_result;\n  assign mult_valid_o = div_valid | mul_valid;\n  // mult_ready_o = division as the multiplication will unconditionally be ready to accept new requests\n\n  // ---------------------\n  // Multiplication\n  // ---------------------\n  multiplier #(\n      .CVA6Cfg(CVA6Cfg)\n  ) i_multiplier (\n      .clk_i,\n      .rst_ni,\n      .trans_id_i     (fu_data_i.trans_id),\n      .operation_i    (fu_data_i.operation),\n      .operand_a_i    (fu_data_i.operand_a),\n      .operand_b_i    (fu_data_i.operand_b),\n      .result_o       (mul_result),\n      .mult_valid_i   (mul_valid_op),\n      .mult_valid_o   (mul_valid),\n      .mult_trans_id_o(mul_trans_id),\n      .mult_ready_o   ()                      // this unit is unconditionally ready\n  );\n\n  // ---------------------\n  // Division\n  // ---------------------\n  riscv::xlen_t\n      operand_b,\n      operand_a;  // input operands after input MUX (input silencing, word operations or full inputs)\n  riscv::xlen_t result;  // result before result mux\n\n  logic         div_signed;  // signed or unsigned division\n  logic         rem;  // is it a reminder (or not a reminder e.g.: a division)\n  logic word_op_d, word_op_q;  // save whether the operation was signed or not\n\n  // is this a signed op?\n  assign div_signed = fu_data_i.operation inside {DIV, DIVW, REM, REMW};\n  // is this a modulo?\n  assign rem        = fu_data_i.operation inside {REM, REMU, REMW, REMUW};\n\n  // prepare the input operands and control divider\n  always_comb begin\n    // silence the inputs\n    operand_a = '0;\n    operand_b = '0;\n    // control signals\n    word_op_d = word_op_q;\n\n    // we've go a new division operation\n    if (mult_valid_i && fu_data_i.operation inside {DIV, DIVU, DIVW, DIVUW, REM, REMU, REMW, REMUW}) begin\n      // is this a word operation?\n      if (riscv::IS_XLEN64 && (fu_data_i.operation == DIVW || fu_data_i.operation == DIVUW || fu_data_i.operation == REMW || fu_data_i.operation == REMUW)) begin\n        // yes so check if we should sign extend this is only done for a signed operation\n        if (div_signed) begin\n          operand_a = sext32(fu_data_i.operand_a[31:0]);\n          operand_b = sext32(fu_data_i.operand_b[31:0]);\n        end else begin\n          operand_a = fu_data_i.operand_a[31:0];\n          operand_b = fu_data_i.operand_b[31:0];\n        end\n\n        // save whether we want sign extend the result or not, this is done for all word operations\n        word_op_d = 1'b1;\n      end else begin\n        // regular op\n        operand_a = fu_data_i.operand_a;\n        operand_b = fu_data_i.operand_b;\n        word_op_d = 1'b0;\n      end\n    end\n  end\n\n  // ---------------------\n  // Serial Divider\n  // ---------------------\n  serdiv #(\n      .CVA6Cfg(CVA6Cfg),\n      .WIDTH  (riscv::XLEN)\n  ) i_div (\n      .clk_i    (clk_i),\n      .rst_ni   (rst_ni),\n      .id_i     (fu_data_i.trans_id),\n      .op_a_i   (operand_a),\n      .op_b_i   (operand_b),\n      .opcode_i ({rem, div_signed}),   // 00: udiv, 10: urem, 01: div, 11: rem\n      .in_vld_i (div_valid_op),\n      .in_rdy_o (mult_ready_o),\n      .flush_i  (flush_i),\n      .out_vld_o(div_valid),\n      .out_rdy_i(div_ready_i),\n      .id_o     (div_trans_id),\n      .res_o    (result)\n  );\n\n  // Result multiplexer\n  // if it was a signed word operation the bit will be set and the result will be sign extended accordingly\n  assign div_result = (riscv::IS_XLEN64 && word_op_q) ? sext32(result) : result;\n\n  // ---------------------\n  // Registers\n  // ---------------------\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      word_op_q <= '0;\n    end else begin\n      word_op_q <= word_op_d;\n    end\n  end\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>\n//\n// Description: Multiplication Unit with one pipeline register\n//              This unit relies on retiming features of the synthesizer\n//\n\n\nmodule multiplier\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input  logic                             clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input  logic                             rst_ni,\n    // Multiplier transaction ID - Mult\n    input  logic         [TRANS_ID_BITS-1:0] trans_id_i,\n    // Multiplier instruction is valid - Mult\n    input  logic                             mult_valid_i,\n    // Multiplier operation - Mult\n    input  fu_op                             operation_i,\n    // A operand - Mult\n    input  riscv::xlen_t                     operand_a_i,\n    // B operand - Mult\n    input  riscv::xlen_t                     operand_b_i,\n    // Multiplier result - Mult\n    output riscv::xlen_t                     result_o,\n    // Mutliplier result is valid - Mult\n    output logic                             mult_valid_o,\n    // Multiplier FU is ready - Mult\n    output logic                             mult_ready_o,\n    // Multiplier transaction ID - Mult\n    output logic         [TRANS_ID_BITS-1:0] mult_trans_id_o\n);\n  // Carry-less multiplication\n  logic [riscv::XLEN-1:0]\n      clmul_q, clmul_d, clmulr_q, clmulr_d, operand_a, operand_b, operand_a_rev, operand_b_rev;\n  logic clmul_rmode, clmul_hmode;\n\n  if (CVA6Cfg.RVB) begin : gen_bitmanip\n    // checking for clmul_rmode and clmul_hmode\n    assign clmul_rmode = (operation_i == CLMULR);\n    assign clmul_hmode = (operation_i == CLMULH);\n\n    // operand_a and b reverse generator\n    for (genvar i = 0; i < riscv::XLEN; i++) begin\n      assign operand_a_rev[i] = operand_a_i[(riscv::XLEN-1)-i];\n      assign operand_b_rev[i] = operand_b_i[(riscv::XLEN-1)-i];\n    end\n\n    // operand_a and operand_b selection\n    assign operand_a = (clmul_rmode | clmul_hmode) ? operand_a_rev : operand_a_i;\n    assign operand_b = (clmul_rmode | clmul_hmode) ? operand_b_rev : operand_b_i;\n\n    // implementation\n    always_comb begin\n      clmul_d = '0;\n      for (int i = 0; i <= riscv::XLEN; i++) begin\n        clmul_d = (|((operand_b >> i) & 1)) ? clmul_d ^ (operand_a << i) : clmul_d;\n      end\n    end\n\n    // clmulr + clmulh result generator\n    for (genvar i = 0; i < riscv::XLEN; i++) begin\n      assign clmulr_d[i] = clmul_d[(riscv::XLEN-1)-i];\n    end\n  end\n\n  // Pipeline register\n  logic [TRANS_ID_BITS-1:0] trans_id_q;\n  logic                     mult_valid_q;\n  fu_op operator_d, operator_q;\n  logic [riscv::XLEN*2-1:0] mult_result_d, mult_result_q;\n\n  // control registers\n  logic sign_a, sign_b;\n  logic mult_valid;\n\n  // control signals\n  assign mult_valid_o = mult_valid_q;\n  assign mult_trans_id_o = trans_id_q;\n  assign mult_ready_o = 1'b1;\n\n  assign mult_valid      = mult_valid_i && (operation_i inside {MUL, MULH, MULHU, MULHSU, MULW, CLMUL, CLMULH, CLMULR});\n\n  // Sign Select MUX\n  always_comb begin\n    sign_a = 1'b0;\n    sign_b = 1'b0;\n\n    // signed multiplication\n    if (operation_i == MULH) begin\n      sign_a = 1'b1;\n      sign_b = 1'b1;\n      // signed - unsigned multiplication\n    end else if (operation_i == MULHSU) begin\n      sign_a = 1'b1;\n      // unsigned multiplication\n    end else begin\n      sign_a = 1'b0;\n      sign_b = 1'b0;\n    end\n  end\n\n\n  // single stage version\n  assign mult_result_d = $signed(\n      {operand_a_i[riscv::XLEN-1] & sign_a, operand_a_i}\n  ) * $signed(\n      {operand_b_i[riscv::XLEN-1] & sign_b, operand_b_i}\n  );\n\n\n  assign operator_d = operation_i;\n\n  always_comb begin : p_selmux\n    unique case (operator_q)\n      MULH, MULHU, MULHSU: result_o = mult_result_q[riscv::XLEN*2-1:riscv::XLEN];\n      CLMUL:               result_o = clmul_q;\n      CLMULH:              result_o = clmulr_q >> 1;\n      CLMULR:              result_o = clmulr_q;\n      // MUL performs an XLEN-bit\u00d7XLEN-bit multiplication and places the lower XLEN bits in the destination register\n      default: begin\n        if (operator_q == MULW && riscv::IS_XLEN64) result_o = sext32(mult_result_q[31:0]);\n        else result_o = mult_result_q[riscv::XLEN-1:0];  // including MUL\n      end\n    endcase\n  end\n  if (CVA6Cfg.RVB) begin\n    always_ff @(posedge clk_i or negedge rst_ni) begin\n      if (~rst_ni) begin\n        clmul_q  <= '0;\n        clmulr_q <= '0;\n      end else begin\n        clmul_q  <= clmul_d;\n        clmulr_q <= clmulr_d;\n      end\n    end\n  end\n  // -----------------------\n  // Output pipeline register\n  // -----------------------\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      mult_valid_q  <= '0;\n      trans_id_q    <= '0;\n      operator_q    <= MUL;\n      mult_result_q <= '0;\n    end else begin\n      // Input silencing\n      trans_id_q    <= trans_id_i;\n      // Output Register\n      mult_valid_q  <= mult_valid;\n      operator_q    <= operator_d;\n      mult_result_q <= mult_result_d;\n    end\n  end\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 06.10.2017\n// Description: Performance counters\n\n\nmodule perf_counters\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg  = config_pkg::cva6_cfg_empty,\n    parameter int unsigned           NumPorts = 3                            // number of miss ports\n) (\n    input logic clk_i,\n    input logic rst_ni,\n    input logic debug_mode_i,  // debug mode\n    // SRAM like interface\n    input logic [11:0] addr_i,  // read/write address (up to 6 counters possible)\n    input logic we_i,  // write enable\n    input riscv::xlen_t data_i,  // data to write\n    output riscv::xlen_t data_o,  // data to read\n    // from commit stage\n    input  scoreboard_entry_t [CVA6Cfg.NrCommitPorts-1:0] commit_instr_i,     // the instruction we want to commit\n    input  logic [CVA6Cfg.NrCommitPorts-1:0]              commit_ack_i,       // acknowledge that we are indeed committing\n    // from L1 caches\n    input logic l1_icache_miss_i,\n    input logic l1_dcache_miss_i,\n    // from MMU\n    input logic itlb_miss_i,\n    input logic dtlb_miss_i,\n    // from issue stage\n    input logic sb_full_i,\n    // from frontend\n    input logic if_empty_i,\n    // from PC Gen\n    input exception_t ex_i,\n    input logic eret_i,\n    input bp_resolve_t resolved_branch_i,\n    // for newly added events\n    input exception_t branch_exceptions_i,  //Branch exceptions->execute unit-> branch_exception_o\n    input icache_dreq_t l1_icache_access_i,\n    input dcache_req_i_t [2:0] l1_dcache_access_i,\n    input  logic [NumPorts-1:0][DCACHE_SET_ASSOC-1:0]miss_vld_bits_i,  //For Cache eviction (3ports-LOAD,STORE,PTW)\n    input logic i_tlb_flush_i,\n    input logic stall_issue_i,  //stall-read operands\n    input logic [31:0] mcountinhibit_i\n);\n\n  logic [63:0] generic_counter_d[6:1];\n  logic [63:0] generic_counter_q[6:1];\n\n  //internal signal to keep track of exception\n  logic read_access_exception, update_access_exception;\n\n  logic events[6:1];\n  //internal signal for  MUX select line input\n  logic [4:0] mhpmevent_d[6:1];\n  logic [4:0] mhpmevent_q[6:1];\n  // internal signal to detect event on multiple commit ports\n  logic [CVA6Cfg.NrCommitPorts-1:0] load_event;\n  logic [CVA6Cfg.NrCommitPorts-1:0] store_event;\n  logic [CVA6Cfg.NrCommitPorts-1:0] branch_event;\n  logic [CVA6Cfg.NrCommitPorts-1:0] call_event;\n  logic [CVA6Cfg.NrCommitPorts-1:0] return_event;\n  logic [CVA6Cfg.NrCommitPorts-1:0] int_event;\n  logic [CVA6Cfg.NrCommitPorts-1:0] fp_event;\n\n  //Multiplexer\n  always_comb begin : Mux\n    events[6:1] = '{default: 0};\n    load_event = '{default: 0};\n    store_event = '{default: 0};\n    branch_event = '{default: 0};\n    call_event = '{default: 0};\n    return_event = '{default: 0};\n    int_event = '{default: 0};\n    fp_event = '{default: 0};\n\n    for (int unsigned j = 0; j < CVA6Cfg.NrCommitPorts; j++) begin\n      load_event[j] = commit_ack_i[j] & (commit_instr_i[j].fu == LOAD);\n      store_event[j] = commit_ack_i[j] & (commit_instr_i[j].fu == STORE);\n      branch_event[j] = commit_ack_i[j] & (commit_instr_i[j].fu == CTRL_FLOW);\n      call_event[j] = commit_ack_i[j] & (commit_instr_i[j].fu == CTRL_FLOW && (commit_instr_i[j].op == ADD || commit_instr_i[j].op == JALR) && (commit_instr_i[j].rd == 'd1 || commit_instr_i[j].rd == 'd5));\n      return_event[j] = commit_ack_i[j] & (commit_instr_i[j].op == JALR && commit_instr_i[j].rd == 'd0);\n      int_event[j] = commit_ack_i[j] & (commit_instr_i[j].fu == ALU || commit_instr_i[j].fu == MULT);\n      fp_event[j] = commit_ack_i[j] & (commit_instr_i[j].fu == FPU || commit_instr_i[j].fu == FPU_VEC);\n    end\n\n    for (int unsigned i = 1; i <= 6; i++) begin\n      case (mhpmevent_q[i])\n        5'b00000: events[i] = 0;\n        5'b00001: events[i] = l1_icache_miss_i;  //L1 I-Cache misses\n        5'b00010: events[i] = l1_dcache_miss_i;  //L1 D-Cache misses\n        5'b00011: events[i] = itlb_miss_i;  //ITLB misses\n        5'b00100: events[i] = dtlb_miss_i;  //DTLB misses\n        5'b00101: events[i] = |load_event;  //Load accesses\n        5'b00110: events[i] = |store_event;  //Store accesses\n        5'b00111: events[i] = ex_i.valid;  //Exceptions\n        5'b01000: events[i] = eret_i;  //Exception handler returns\n        5'b01001: events[i] = |branch_event;  // Branch instructions\n        5'b01010:\n        events[i] = resolved_branch_i.valid && resolved_branch_i.is_mispredict;//Branch mispredicts\n        5'b01011: events[i] = branch_exceptions_i.valid;  //Branch exceptions\n        // The standard software calling convention uses register x1 to hold the return address on a call\n        // the unconditional jump is decoded as ADD op\n        5'b01100: events[i] = |call_event;  //Call\n        5'b01101: events[i] = |return_event;  //Return\n        5'b01110: events[i] = sb_full_i;  //MSB Full\n        5'b01111: events[i] = if_empty_i;  //Instruction fetch Empty\n        5'b10000: events[i] = l1_icache_access_i.req;  //L1 I-Cache accesses\n        5'b10001:\n        events[i] = l1_dcache_access_i[0].data_req || l1_dcache_access_i[1].data_req || l1_dcache_access_i[2].data_req;//L1 D-Cache accesses\n        5'b10010:\n        events[i] = (l1_dcache_miss_i && miss_vld_bits_i[0] == 8'hFF) || (l1_dcache_miss_i && miss_vld_bits_i[1] == 8'hFF) || (l1_dcache_miss_i && miss_vld_bits_i[2] == 8'hFF);//eviction\n        5'b10011: events[i] = i_tlb_flush_i;  //I-TLB flush\n        5'b10100: events[i] = |int_event;  //Integer instructions\n        5'b10101: events[i] = |fp_event;  //Floating Point Instructions\n        5'b10110: events[i] = stall_issue_i;  //Pipeline bubbles\n        default: events[i] = 0;\n      endcase\n    end\n\n  end\n\n  always_comb begin : generic_counter\n    generic_counter_d = generic_counter_q;\n    data_o = 'b0;\n    mhpmevent_d = mhpmevent_q;\n    read_access_exception = 1'b0;\n    update_access_exception = 1'b0;\n\n    // Increment the non-inhibited counters with active events\n    for (int unsigned i = 1; i <= 6; i++) begin\n      if ((!debug_mode_i) && (!we_i)) begin\n        if ((events[i]) == 1 && (!mcountinhibit_i[i+2])) begin\n          generic_counter_d[i] = generic_counter_q[i] + 1'b1;\n        end\n      end\n    end\n\n    //Read\n    unique case (addr_i)\n      riscv::CSR_MHPM_COUNTER_3,\n            riscv::CSR_MHPM_COUNTER_4,\n            riscv::CSR_MHPM_COUNTER_5,\n            riscv::CSR_MHPM_COUNTER_6,\n            riscv::CSR_MHPM_COUNTER_7,\n            riscv::CSR_MHPM_COUNTER_8  :begin\n        if (riscv::XLEN == 32) data_o = generic_counter_q[addr_i-riscv::CSR_MHPM_COUNTER_3+1][31:0];\n        else data_o = generic_counter_q[addr_i-riscv::CSR_MHPM_COUNTER_3+1];\n      end\n      riscv::CSR_MHPM_COUNTER_3H,\n            riscv::CSR_MHPM_COUNTER_4H,\n            riscv::CSR_MHPM_COUNTER_5H,\n            riscv::CSR_MHPM_COUNTER_6H,\n            riscv::CSR_MHPM_COUNTER_7H,\n            riscv::CSR_MHPM_COUNTER_8H :begin\n        if (riscv::XLEN == 32)\n          data_o = generic_counter_q[addr_i-riscv::CSR_MHPM_COUNTER_3H+1][63:32];\n        else read_access_exception = 1'b1;\n      end\n      riscv::CSR_MHPM_EVENT_3,\n            riscv::CSR_MHPM_EVENT_4,\n            riscv::CSR_MHPM_EVENT_5,\n            riscv::CSR_MHPM_EVENT_6,\n            riscv::CSR_MHPM_EVENT_7,\n            riscv::CSR_MHPM_EVENT_8   :\n      data_o = mhpmevent_q[addr_i-riscv::CSR_MHPM_EVENT_3+1];\n      riscv::CSR_HPM_COUNTER_3,\n            riscv::CSR_HPM_COUNTER_4,\n            riscv::CSR_HPM_COUNTER_5,\n            riscv::CSR_HPM_COUNTER_6,\n            riscv::CSR_HPM_COUNTER_7,\n            riscv::CSR_HPM_COUNTER_8  :begin\n        if (riscv::XLEN == 32) data_o = generic_counter_q[addr_i-riscv::CSR_HPM_COUNTER_3+1][31:0];\n        else data_o = generic_counter_q[addr_i-riscv::CSR_HPM_COUNTER_3+1];\n      end\n      riscv::CSR_HPM_COUNTER_3H,\n            riscv::CSR_HPM_COUNTER_4H,\n            riscv::CSR_HPM_COUNTER_5H,\n            riscv::CSR_HPM_COUNTER_6H,\n            riscv::CSR_HPM_COUNTER_7H,\n            riscv::CSR_HPM_COUNTER_8H :begin\n        if (riscv::XLEN == 32)\n          data_o = generic_counter_q[addr_i-riscv::CSR_HPM_COUNTER_3H+1][63:32];\n        else read_access_exception = 1'b1;\n      end\n      default: data_o = 'b0;\n    endcase\n\n    //Write\n    if (we_i) begin\n      unique case (addr_i)\n        riscv::CSR_MHPM_COUNTER_3,\n            riscv::CSR_MHPM_COUNTER_4,\n            riscv::CSR_MHPM_COUNTER_5,\n            riscv::CSR_MHPM_COUNTER_6,\n            riscv::CSR_MHPM_COUNTER_7,\n            riscv::CSR_MHPM_COUNTER_8  :begin\n          if (riscv::XLEN == 32)\n            generic_counter_d[addr_i-riscv::CSR_MHPM_COUNTER_3+1][31:0] = data_i;\n          else generic_counter_d[addr_i-riscv::CSR_MHPM_COUNTER_3+1] = data_i;\n        end\n        riscv::CSR_MHPM_COUNTER_3H,\n            riscv::CSR_MHPM_COUNTER_4H,\n            riscv::CSR_MHPM_COUNTER_5H,\n            riscv::CSR_MHPM_COUNTER_6H,\n            riscv::CSR_MHPM_COUNTER_7H,\n            riscv::CSR_MHPM_COUNTER_8H :begin\n          if (riscv::XLEN == 32)\n            generic_counter_d[addr_i-riscv::CSR_MHPM_COUNTER_3H+1][63:32] = data_i;\n          else update_access_exception = 1'b1;\n        end\n        riscv::CSR_MHPM_EVENT_3,\n            riscv::CSR_MHPM_EVENT_4,\n            riscv::CSR_MHPM_EVENT_5,\n            riscv::CSR_MHPM_EVENT_6,\n            riscv::CSR_MHPM_EVENT_7,\n            riscv::CSR_MHPM_EVENT_8   :\n        mhpmevent_d[addr_i-riscv::CSR_MHPM_EVENT_3+1] = data_i;\n        default: update_access_exception = 1'b1;\n      endcase\n    end\n  end\n\n  //Registers\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (!rst_ni) begin\n      generic_counter_q <= '{default: 0};\n      mhpmevent_q       <= '{default: 0};\n    end else begin\n      generic_counter_q <= generic_counter_d;\n      mhpmevent_q       <= mhpmevent_d;\n    end\n  end\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: David Schaffenrath, TU Graz\n// Author: Florian Zaruba, ETH Zurich\n// Date: 24.4.2017\n// Description: Hardware-PTW\n\n/* verilator lint_off WIDTH */\n\nmodule ptw\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int ASID_WIDTH = 1\n) (\n    input  logic clk_i,                   // Clock\n    input  logic rst_ni,                  // Asynchronous reset active low\n    input  logic flush_i,                 // flush everything, we need to do this because\n                                          // actually everything we do is speculative at this stage\n                                          // e.g.: there could be a CSR instruction that changes everything\n    output logic ptw_active_o,\n    output logic walking_instr_o,         // set when walking for TLB\n    output logic ptw_error_o,             // set when an error occurred\n    output logic ptw_access_exception_o,  // set when an PMP access exception occured\n    input  logic enable_translation_i,    // CSRs indicate to enable SV39\n    input  logic en_ld_st_translation_i,  // enable virtual memory translation for load/stores\n\n    input  logic          lsu_is_store_i,  // this translation was triggered by a store\n    // PTW memory interface\n    input  dcache_req_o_t req_port_i,\n    output dcache_req_i_t req_port_o,\n\n\n    // to TLBs, update logic\n    output tlb_update_t itlb_update_o,\n    output tlb_update_t dtlb_update_o,\n\n    output logic [riscv::VLEN-1:0] update_vaddr_o,\n\n    input logic [ ASID_WIDTH-1:0] asid_i,\n    // from TLBs\n    // did we miss?\n    input logic                   itlb_access_i,\n    input logic                   itlb_hit_i,\n    input logic [riscv::VLEN-1:0] itlb_vaddr_i,\n\n    input  logic                   dtlb_access_i,\n    input  logic                   dtlb_hit_i,\n    input  logic [riscv::VLEN-1:0] dtlb_vaddr_i,\n    // from CSR file\n    input  logic [riscv::PPNW-1:0] satp_ppn_i,     // ppn from satp\n    input  logic                   mxr_i,\n    // Performance counters\n    output logic                   itlb_miss_o,\n    output logic                   dtlb_miss_o,\n    // PMP\n\n    input riscv::pmpcfg_t [15:0] pmpcfg_i,\n    input logic [15:0][riscv::PLEN-3:0] pmpaddr_i,\n    output logic [riscv::PLEN-1:0] bad_paddr_o\n\n);\n\n  // input registers\n  logic data_rvalid_q;\n  logic [63:0] data_rdata_q;\n\n  riscv::pte_t pte;\n  assign pte = riscv::pte_t'(data_rdata_q);\n\n  enum logic [2:0] {\n    IDLE,\n    WAIT_GRANT,\n    PTE_LOOKUP,\n    WAIT_RVALID,\n    PROPAGATE_ERROR,\n    PROPAGATE_ACCESS_ERROR\n  }\n      state_q, state_d;\n\n  // SV39 defines three levels of page tables\n  enum logic [1:0] {\n    LVL1,\n    LVL2,\n    LVL3\n  }\n      ptw_lvl_q, ptw_lvl_n;\n\n  // is this an instruction page table walk?\n  logic is_instr_ptw_q, is_instr_ptw_n;\n  logic global_mapping_q, global_mapping_n;\n  // latched tag signal\n  logic tag_valid_n, tag_valid_q;\n  // register the ASID\n  logic [ASID_WIDTH-1:0] tlb_update_asid_q, tlb_update_asid_n;\n  // register the VPN we need to walk, SV39 defines a 39 bit virtual address\n  logic [riscv::VLEN-1:0] vaddr_q, vaddr_n;\n  // 4 byte aligned physical pointer\n  logic [riscv::PLEN-1:0] ptw_pptr_q, ptw_pptr_n;\n\n  // Assignments\n  assign update_vaddr_o = vaddr_q;\n\n  assign ptw_active_o = (state_q != IDLE);\n  assign walking_instr_o = is_instr_ptw_q;\n  // directly output the correct physical address\n  assign req_port_o.address_index = ptw_pptr_q[DCACHE_INDEX_WIDTH-1:0];\n  assign req_port_o.address_tag   = ptw_pptr_q[DCACHE_INDEX_WIDTH+DCACHE_TAG_WIDTH-1:DCACHE_INDEX_WIDTH];\n  // we are never going to kill this request\n  assign req_port_o.kill_req = '0;\n  // we are never going to write with the HPTW\n  assign req_port_o.data_wdata = 64'b0;\n  // we only issue one single request at a time\n  assign req_port_o.data_id = '0;\n  // -----------\n  // TLB Update\n  // -----------\n  assign itlb_update_o.vpn = {{39 - riscv::SV{1'b0}}, vaddr_q[riscv::SV-1:12]};\n  assign dtlb_update_o.vpn = {{39 - riscv::SV{1'b0}}, vaddr_q[riscv::SV-1:12]};\n  // update the correct page table level\n  assign itlb_update_o.is_2M = (ptw_lvl_q == LVL2);\n  assign itlb_update_o.is_1G = (ptw_lvl_q == LVL1);\n  assign dtlb_update_o.is_2M = (ptw_lvl_q == LVL2);\n  assign dtlb_update_o.is_1G = (ptw_lvl_q == LVL1);\n  // output the correct ASID\n  assign itlb_update_o.asid = tlb_update_asid_q;\n  assign dtlb_update_o.asid = tlb_update_asid_q;\n  // set the global mapping bit\n  assign itlb_update_o.content = pte | (global_mapping_q << 5);\n  assign dtlb_update_o.content = pte | (global_mapping_q << 5);\n\n  assign req_port_o.tag_valid = tag_valid_q;\n\n  logic allow_access;\n\n  assign bad_paddr_o = ptw_access_exception_o ? ptw_pptr_q : 'b0;\n\n  pmp #(\n      .CVA6Cfg   (CVA6Cfg),\n      .PLEN      (riscv::PLEN),\n      .PMP_LEN   (riscv::PLEN - 2),\n      .NR_ENTRIES(CVA6Cfg.NrPMPEntries)\n  ) i_pmp_ptw (\n      .addr_i       (ptw_pptr_q),\n      // PTW access are always checked as if in S-Mode...\n      .priv_lvl_i   (riscv::PRIV_LVL_S),\n      // ...and they are always loads\n      .access_type_i(riscv::ACCESS_READ),\n      // Configuration\n      .conf_addr_i  (pmpaddr_i),\n      .conf_i       (pmpcfg_i),\n      .allow_o      (allow_access)\n  );\n\n  //-------------------\n  // Page table walker\n  //-------------------\n  // A virtual address va is translated into a physical address pa as follows:\n  // 1. Let a be sptbr.ppn \u00d7 PAGESIZE, and let i = LEVELS-1. (For Sv39,\n  //    PAGESIZE=2^12 and LEVELS=3.)\n  // 2. Let pte be the value of the PTE at address a+va.vpn[i]\u00d7PTESIZE. (For\n  //    Sv32, PTESIZE=4.)\n  // 3. If pte.v = 0, or if pte.r = 0 and pte.w = 1, stop and raise an access\n  //    exception.\n  // 4. Otherwise, the PTE is valid. If pte.r = 1 or pte.x = 1, go to step 5.\n  //    Otherwise, this PTE is a pointer to the next level of the page table.\n  //    Let i=i-1. If i < 0, stop and raise an access exception. Otherwise, let\n  //    a = pte.ppn \u00d7 PAGESIZE and go to step 2.\n  // 5. A leaf PTE has been found. Determine if the requested memory access\n  //    is allowed by the pte.r, pte.w, and pte.x bits. If not, stop and\n  //    raise an access exception. Otherwise, the translation is successful.\n  //    Set pte.a to 1, and, if the memory access is a store, set pte.d to 1.\n  //    The translated physical address is given as follows:\n  //      - pa.pgoff = va.pgoff.\n  //      - If i > 0, then this is a superpage translation and\n  //        pa.ppn[i-1:0] = va.vpn[i-1:0].\n  //      - pa.ppn[LEVELS-1:i] = pte.ppn[LEVELS-1:i].\n  always_comb begin : ptw\n    // default assignments\n    // PTW memory interface\n    tag_valid_n            = 1'b0;\n    req_port_o.data_req    = 1'b0;\n    req_port_o.data_be     = 8'hFF;\n    req_port_o.data_size   = 2'b11;\n    req_port_o.data_we     = 1'b0;\n    ptw_error_o            = 1'b0;\n    ptw_access_exception_o = 1'b0;\n    itlb_update_o.valid    = 1'b0;\n    dtlb_update_o.valid    = 1'b0;\n    is_instr_ptw_n         = is_instr_ptw_q;\n    ptw_lvl_n              = ptw_lvl_q;\n    ptw_pptr_n             = ptw_pptr_q;\n    state_d                = state_q;\n    global_mapping_n       = global_mapping_q;\n    // input registers\n    tlb_update_asid_n      = tlb_update_asid_q;\n    vaddr_n                = vaddr_q;\n\n    itlb_miss_o            = 1'b0;\n    dtlb_miss_o            = 1'b0;\n\n    case (state_q)\n\n      IDLE: begin\n        // by default we start with the top-most page table\n        ptw_lvl_n        = LVL1;\n        global_mapping_n = 1'b0;\n        is_instr_ptw_n   = 1'b0;\n        // if we got an ITLB miss\n        if (enable_translation_i & itlb_access_i & ~itlb_hit_i & ~dtlb_access_i) begin\n          ptw_pptr_n        = {satp_ppn_i, itlb_vaddr_i[riscv::SV-1:30], 3'b0};\n          is_instr_ptw_n    = 1'b1;\n          tlb_update_asid_n = asid_i;\n          vaddr_n           = itlb_vaddr_i;\n          state_d           = WAIT_GRANT;\n          itlb_miss_o       = 1'b1;\n          // we got an DTLB miss\n        end else if (en_ld_st_translation_i & dtlb_access_i & ~dtlb_hit_i) begin\n          ptw_pptr_n        = {satp_ppn_i, dtlb_vaddr_i[riscv::SV-1:30], 3'b0};\n          tlb_update_asid_n = asid_i;\n          vaddr_n           = dtlb_vaddr_i;\n          state_d           = WAIT_GRANT;\n          dtlb_miss_o       = 1'b1;\n        end\n      end\n\n      WAIT_GRANT: begin\n        // send a request out\n        req_port_o.data_req = 1'b1;\n        // wait for the WAIT_GRANT\n        if (req_port_i.data_gnt) begin\n          // send the tag valid signal one cycle later\n          tag_valid_n = 1'b1;\n          state_d     = PTE_LOOKUP;\n        end\n      end\n\n      PTE_LOOKUP: begin\n        // we wait for the valid signal\n        if (data_rvalid_q) begin\n\n          // check if the global mapping bit is set\n          if (pte.g) global_mapping_n = 1'b1;\n\n          // -------------\n          // Invalid PTE\n          // -------------\n          // If pte.v = 0, or if pte.r = 0 and pte.w = 1, stop and raise a page-fault exception.\n          if (!pte.v || (!pte.r && pte.w)) state_d = PROPAGATE_ERROR;\n          // -----------\n          // Valid PTE\n          // -----------\n          else begin\n            state_d = IDLE;\n            // it is a valid PTE\n            // if pte.r = 1 or pte.x = 1 it is a valid PTE\n            if (pte.r || pte.x) begin\n              // Valid translation found (either 1G, 2M or 4K entry)\n              if (is_instr_ptw_q) begin\n                // ------------\n                // Update ITLB\n                // ------------\n                // If page is not executable, we can directly raise an error. This\n                // doesn't put a useless entry into the TLB. The same idea applies\n                // to the access flag since we let the access flag be managed by SW.\n                if (!pte.x || !pte.a) state_d = PROPAGATE_ERROR;\n                else itlb_update_o.valid = 1'b1;\n\n              end else begin\n                // ------------\n                // Update DTLB\n                // ------------\n                // Check if the access flag has been set, otherwise throw a page-fault\n                // and let the software handle those bits.\n                // If page is not readable (there are no write-only pages)\n                // we can directly raise an error. This doesn't put a useless\n                // entry into the TLB.\n                if (pte.a && (pte.r || (pte.x && mxr_i))) begin\n                  dtlb_update_o.valid = 1'b1;\n                end else begin\n                  state_d = PROPAGATE_ERROR;\n                end\n                // Request is a store: perform some additional checks\n                // If the request was a store and the page is not write-able, raise an error\n                // the same applies if the dirty flag is not set\n                if (lsu_is_store_i && (!pte.w || !pte.d)) begin\n                  dtlb_update_o.valid = 1'b0;\n                  state_d = PROPAGATE_ERROR;\n                end\n              end\n              // check if the ppn is correctly aligned:\n              // 6. If i > 0 and pa.ppn[i \u2212 1 : 0] != 0, this is a misaligned superpage; stop and raise a page-fault\n              // exception.\n              if (ptw_lvl_q == LVL1 && pte.ppn[17:0] != '0) begin\n                state_d             = PROPAGATE_ERROR;\n                dtlb_update_o.valid = 1'b0;\n                itlb_update_o.valid = 1'b0;\n              end else if (ptw_lvl_q == LVL2 && pte.ppn[8:0] != '0) begin\n                state_d             = PROPAGATE_ERROR;\n                dtlb_update_o.valid = 1'b0;\n                itlb_update_o.valid = 1'b0;\n              end\n              // this is a pointer to the next TLB level\n            end else begin\n              // pointer to next level of page table\n              if (ptw_lvl_q == LVL1) begin\n                // we are in the second level now\n                ptw_lvl_n  = LVL2;\n                ptw_pptr_n = {pte.ppn, vaddr_q[29:21], 3'b0};\n              end\n\n              if (ptw_lvl_q == LVL2) begin\n                // here we received a pointer to the third level\n                ptw_lvl_n  = LVL3;\n                ptw_pptr_n = {pte.ppn, vaddr_q[20:12], 3'b0};\n              end\n\n              state_d = WAIT_GRANT;\n\n              if (ptw_lvl_q == LVL3) begin\n                // Should already be the last level page table => Error\n                ptw_lvl_n = LVL3;\n                state_d   = PROPAGATE_ERROR;\n              end\n            end\n          end\n\n          // Check if this access was actually allowed from a PMP perspective\n          if (!allow_access) begin\n            itlb_update_o.valid = 1'b0;\n            dtlb_update_o.valid = 1'b0;\n            // we have to return the failed address in bad_addr\n            ptw_pptr_n = ptw_pptr_q;\n            state_d = PROPAGATE_ACCESS_ERROR;\n          end\n        end\n        // we've got a data WAIT_GRANT so tell the cache that the tag is valid\n      end\n      // Propagate error to MMU/LSU\n      PROPAGATE_ERROR: begin\n        state_d     = IDLE;\n        ptw_error_o = 1'b1;\n      end\n      PROPAGATE_ACCESS_ERROR: begin\n        state_d                = IDLE;\n        ptw_access_exception_o = 1'b1;\n      end\n      // wait for the rvalid before going back to IDLE\n      WAIT_RVALID: begin\n        if (data_rvalid_q) state_d = IDLE;\n      end\n      default: begin\n        state_d = IDLE;\n      end\n    endcase\n\n    // -------\n    // Flush\n    // -------\n    // should we have flushed before we got an rvalid, wait for it until going back to IDLE\n    if (flush_i) begin\n      // on a flush check whether we are\n      // 1. in the PTE Lookup check whether we still need to wait for an rvalid\n      // 2. waiting for a grant, if so: wait for it\n      // if not, go back to idle\n      if (((state_q inside {PTE_LOOKUP, WAIT_RVALID}) && !data_rvalid_q) ||\n                ((state_q == WAIT_GRANT) && req_port_i.data_gnt))\n        state_d = WAIT_RVALID;\n      else state_d = IDLE;\n    end\n  end\n\n  // sequential process\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      state_q           <= IDLE;\n      is_instr_ptw_q    <= 1'b0;\n      ptw_lvl_q         <= LVL1;\n      tag_valid_q       <= 1'b0;\n      tlb_update_asid_q <= '0;\n      vaddr_q           <= '0;\n      ptw_pptr_q        <= '0;\n      global_mapping_q  <= 1'b0;\n      data_rdata_q      <= '0;\n      data_rvalid_q     <= 1'b0;\n    end else begin\n      state_q           <= state_d;\n      ptw_pptr_q        <= ptw_pptr_n;\n      is_instr_ptw_q    <= is_instr_ptw_n;\n      ptw_lvl_q         <= ptw_lvl_n;\n      tag_valid_q       <= tag_valid_n;\n      tlb_update_asid_q <= tlb_update_asid_n;\n      vaddr_q           <= vaddr_n;\n      global_mapping_q  <= global_mapping_n;\n      data_rdata_q      <= req_port_i.data_rdata;\n      data_rvalid_q     <= req_port_i.data_rvalid;\n    end\n  end\n\nendmodule\n/* verilator lint_on WIDTH */\n"}
{"text": "/* Copyright 2018 ETH Zurich and University of Bologna.\n * Copyright and related rights are licensed under the Solderpad Hardware\n * License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n * or agreed to in writing, software, hardware and materials distributed under\n * this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n *\n * File:   riscv_pkg.sv\n * Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>\n * Date:   30.6.2017\n *\n * Description: Common RISC-V definitions.\n */\n\npackage riscv;\n\n  // ----------------------\n  // Import cva6 config from cva6_config_pkg\n  // ----------------------\n  localparam XLEN = cva6_config_pkg::CVA6ConfigXlen;\n  localparam FPU_EN = cva6_config_pkg::CVA6ConfigFpuEn;\n\n  // ----------------------\n  // Data and Address length\n  // ----------------------\n  typedef enum logic [3:0] {\n    ModeOff  = 0,\n    ModeSv32 = 1,\n    ModeSv39 = 8,\n    ModeSv48 = 9,\n    ModeSv57 = 10,\n    ModeSv64 = 11\n  } vm_mode_t;\n\n  // Warning: When using STD_CACHE, configuration must be PLEN=56 and VLEN=64\n  // Warning: VLEN must be superior or equal to PLEN\n  localparam VLEN = (XLEN == 32) ? 32 : 64;  // virtual address length\n  localparam PLEN = (XLEN == 32) ? 34 : 56;  // physical address length\n\n  localparam IS_XLEN32 = (XLEN == 32) ? 1'b1 : 1'b0;\n  localparam IS_XLEN64 = (XLEN == 32) ? 1'b0 : 1'b1;\n  localparam ModeW = (XLEN == 32) ? 1 : 4;\n  localparam ASIDW = (XLEN == 32) ? 9 : 16;\n  localparam PPNW = (XLEN == 32) ? 22 : 44;\n  localparam vm_mode_t MODE_SV = (XLEN == 32) ? ModeSv32 : ModeSv39;\n  localparam SV = (MODE_SV == ModeSv32) ? 32 : 39;\n  localparam VPN2 = (VLEN - 31 < 8) ? VLEN - 31 : 8;\n  localparam XLEN_ALIGN_BYTES = $clog2(XLEN / 8);\n\n  typedef logic [XLEN-1:0] xlen_t;\n\n  // --------------------\n  // Privilege Spec\n  // --------------------\n  typedef enum logic [1:0] {\n    PRIV_LVL_M = 2'b11,\n    PRIV_LVL_S = 2'b01,\n    PRIV_LVL_U = 2'b00\n  } priv_lvl_t;\n\n  // type which holds xlen\n  typedef enum logic [1:0] {\n    XLEN_32  = 2'b01,\n    XLEN_64  = 2'b10,\n    XLEN_128 = 2'b11\n  } xlen_e;\n\n  typedef enum logic [1:0] {\n    Off     = 2'b00,\n    Initial = 2'b01,\n    Clean   = 2'b10,\n    Dirty   = 2'b11\n  } xs_t;\n\n  typedef struct packed {\n    logic sd;  // signal dirty state - read-only\n    logic [62:34] wpri6;  // writes preserved reads ignored\n    xlen_e uxl;  // variable user mode xlen - hardwired to zero\n    logic [12:0] wpri5;  // writes preserved reads ignored\n    logic mxr;  // make executable readable\n    logic sum;  // permit supervisor user memory access\n    logic wpri4;  // writes preserved reads ignored\n    xs_t xs;  // extension register - hardwired to zero\n    xs_t fs;  // floating point extension register\n    logic [1:0] wpri3;  // writes preserved reads ignored\n    xs_t vs;  // vector extension register\n    logic spp;  // holds the previous privilege mode up to supervisor\n    logic wpri2;  // writes preserved reads ignored\n    logic         ube;    // UBE controls whether explicit load and store memory accesses made from U-mode are little-endian (UBE=0) or big-endian (UBE=1)\n    logic spie;  // supervisor interrupts enable bit active prior to trap\n    logic [1:0] wpri1;  // writes preserved reads ignored\n    logic sie;  // supervisor interrupts enable\n    logic wpri0;  // writes preserved reads ignored\n  } sstatus_rv_t;\n\n  typedef struct packed {\n    logic sd;  // signal dirty state - read-only\n    logic [62:36] wpri4;  // writes preserved reads ignored\n    xlen_e sxl;  // variable supervisor mode xlen - hardwired to zero\n    xlen_e uxl;  // variable user mode xlen - hardwired to zero\n    logic [8:0] wpri3;  // writes preserved reads ignored\n    logic tsr;  // trap sret\n    logic tw;  // time wait\n    logic tvm;  // trap virtual memory\n    logic mxr;  // make executable readable\n    logic sum;  // permit supervisor user memory access\n    logic mprv;  // modify privilege - privilege level for ld/st\n    xs_t xs;  // extension register - hardwired to zero\n    xs_t fs;  // floating point extension register\n    priv_lvl_t mpp;  // holds the previous privilege mode up to machine\n    xs_t vs;  // vector extension register\n    logic spp;  // holds the previous privilege mode up to supervisor\n    logic mpie;  // machine interrupts enable bit active prior to trap\n    logic         ube;    // UBE controls whether explicit load and store memory accesses made from U-mode are little-endian (UBE=0) or big-endian (UBE=1)\n    logic spie;  // supervisor interrupts enable bit active prior to trap\n    logic wpri2;  // writes preserved reads ignored\n    logic mie;  // machine interrupts enable\n    logic wpri1;  // writes preserved reads ignored\n    logic sie;  // supervisor interrupts enable\n    logic wpri0;  // writes preserved reads ignored\n  } mstatus_rv_t;\n\n  typedef struct packed {\n    logic [ModeW-1:0] mode;\n    logic [ASIDW-1:0] asid;\n    logic [PPNW-1:0]  ppn;\n  } satp_t;\n\n  // --------------------\n  // Instruction Types\n  // --------------------\n  typedef struct packed {\n    logic [31:25] funct7;\n    logic [24:20] rs2;\n    logic [19:15] rs1;\n    logic [14:12] funct3;\n    logic [11:7]  rd;\n    logic [6:0]   opcode;\n  } rtype_t;\n\n  typedef struct packed {\n    logic [31:27] rs3;\n    logic [26:25] funct2;\n    logic [24:20] rs2;\n    logic [19:15] rs1;\n    logic [14:12] funct3;\n    logic [11:7]  rd;\n    logic [6:0]   opcode;\n  } r4type_t;\n\n  typedef struct packed {\n    logic [31:27] funct5;\n    logic [26:25] fmt;\n    logic [24:20] rs2;\n    logic [19:15] rs1;\n    logic [14:12] rm;\n    logic [11:7]  rd;\n    logic [6:0]   opcode;\n  } rftype_t;  // floating-point\n\n  typedef struct packed {\n    logic [31:30] funct2;\n    logic [29:25] vecfltop;\n    logic [24:20] rs2;\n    logic [19:15] rs1;\n    logic [14:14] repl;\n    logic [13:12] vfmt;\n    logic [11:7]  rd;\n    logic [6:0]   opcode;\n  } rvftype_t;  // vectorial floating-point\n\n  typedef struct packed {\n    logic [31:20] imm;\n    logic [19:15] rs1;\n    logic [14:12] funct3;\n    logic [11:7]  rd;\n    logic [6:0]   opcode;\n  } itype_t;\n\n  typedef struct packed {\n    logic [31:25] imm;\n    logic [24:20] rs2;\n    logic [19:15] rs1;\n    logic [14:12] funct3;\n    logic [11:7]  imm0;\n    logic [6:0]   opcode;\n  } stype_t;\n\n  typedef struct packed {\n    logic [31:12] imm;\n    logic [11:7]  rd;\n    logic [6:0]   opcode;\n  } utype_t;\n\n  // atomic instructions\n  typedef struct packed {\n    logic [31:27] funct5;\n    logic         aq;\n    logic         rl;\n    logic [24:20] rs2;\n    logic [19:15] rs1;\n    logic [14:12] funct3;\n    logic [11:7]  rd;\n    logic [6:0]   opcode;\n  } atype_t;\n\n  typedef union packed {\n    logic [31:0] instr;\n    rtype_t      rtype;\n    r4type_t     r4type;\n    rftype_t     rftype;\n    rvftype_t    rvftype;\n    itype_t      itype;\n    stype_t      stype;\n    utype_t      utype;\n    atype_t      atype;\n  } instruction_t;\n\n  // --------------------\n  // Opcodes\n  // --------------------\n  // RV32/64G listings:\n  // Quadrant 0\n  localparam OpcodeLoad = 7'b00_000_11;\n  localparam OpcodeLoadFp = 7'b00_001_11;\n  localparam OpcodeCustom0 = 7'b00_010_11;\n  localparam OpcodeMiscMem = 7'b00_011_11;\n  localparam OpcodeOpImm = 7'b00_100_11;\n  localparam OpcodeAuipc = 7'b00_101_11;\n  localparam OpcodeOpImm32 = 7'b00_110_11;\n  // Quadrant 1\n  localparam OpcodeStore = 7'b01_000_11;\n  localparam OpcodeStoreFp = 7'b01_001_11;\n  localparam OpcodeCustom1 = 7'b01_010_11;\n  localparam OpcodeAmo = 7'b01_011_11;\n  localparam OpcodeOp = 7'b01_100_11;\n  localparam OpcodeLui = 7'b01_101_11;\n  localparam OpcodeOp32 = 7'b01_110_11;\n  // Quadrant 2\n  localparam OpcodeMadd = 7'b10_000_11;\n  localparam OpcodeMsub = 7'b10_001_11;\n  localparam OpcodeNmsub = 7'b10_010_11;\n  localparam OpcodeNmadd = 7'b10_011_11;\n  localparam OpcodeOpFp = 7'b10_100_11;\n  localparam OpcodeVec = 7'b10_101_11;\n  localparam OpcodeCustom2 = 7'b10_110_11;\n  // Quadrant 3\n  localparam OpcodeBranch = 7'b11_000_11;\n  localparam OpcodeJalr = 7'b11_001_11;\n  localparam OpcodeRsrvd2 = 7'b11_010_11;\n  localparam OpcodeJal = 7'b11_011_11;\n  localparam OpcodeSystem = 7'b11_100_11;\n  localparam OpcodeRsrvd3 = 7'b11_101_11;\n  localparam OpcodeCustom3 = 7'b11_110_11;\n\n  // RV64C/RV32C listings:\n  // Quadrant 0\n  localparam OpcodeC0 = 2'b00;\n  localparam OpcodeC0Addi4spn = 3'b000;\n  localparam OpcodeC0Fld = 3'b001;\n  localparam OpcodeC0Lw = 3'b010;\n  localparam OpcodeC0Ld = 3'b011;\n  localparam OpcodeC0Zcb = 3'b100;\n  localparam OpcodeC0Fsd = 3'b101;\n  localparam OpcodeC0Sw = 3'b110;\n  localparam OpcodeC0Sd = 3'b111;\n  // Quadrant 1\n  localparam OpcodeC1 = 2'b01;\n  localparam OpcodeC1Addi = 3'b000;\n  localparam OpcodeC1Addiw = 3'b001;  //for RV64I only\n  localparam OpcodeC1Jal = 3'b001;  //for RV32I only\n  localparam OpcodeC1Li = 3'b010;\n  localparam OpcodeC1LuiAddi16sp = 3'b011;\n  localparam OpcodeC1MiscAlu = 3'b100;\n  localparam OpcodeC1J = 3'b101;\n  localparam OpcodeC1Beqz = 3'b110;\n  localparam OpcodeC1Bnez = 3'b111;\n  // Quadrant 2\n  localparam OpcodeC2 = 2'b10;\n  localparam OpcodeC2Slli = 3'b000;\n  localparam OpcodeC2Fldsp = 3'b001;\n  localparam OpcodeC2Lwsp = 3'b010;\n  localparam OpcodeC2Ldsp = 3'b011;\n  localparam OpcodeC2JalrMvAdd = 3'b100;\n  localparam OpcodeC2Fsdsp = 3'b101;\n  localparam OpcodeC2Swsp = 3'b110;\n  localparam OpcodeC2Sdsp = 3'b111;\n\n  // ----------------------\n  // Virtual Memory\n  // ----------------------\n  // memory management, pte for sv39\n  typedef struct packed {\n    logic [9:0] reserved;\n    logic [44-1:0] ppn;  // PPN length for\n    logic [1:0] rsw;\n    logic d;\n    logic a;\n    logic g;\n    logic u;\n    logic x;\n    logic w;\n    logic r;\n    logic v;\n  } pte_t;\n\n  // memory management, pte for sv32\n  typedef struct packed {\n    logic [22-1:0] ppn;  // PPN length for\n    logic [1:0] rsw;\n    logic d;\n    logic a;\n    logic g;\n    logic u;\n    logic x;\n    logic w;\n    logic r;\n    logic v;\n  } pte_sv32_t;\n\n  // ----------------------\n  // Exception Cause Codes\n  // ----------------------\n  localparam logic [XLEN-1:0] INSTR_ADDR_MISALIGNED = 0;\n  localparam logic [XLEN-1:0] INSTR_ACCESS_FAULT    = 1;  // Illegal access as governed by PMPs and PMAs\n  localparam logic [XLEN-1:0] ILLEGAL_INSTR = 2;\n  localparam logic [XLEN-1:0] BREAKPOINT = 3;\n  localparam logic [XLEN-1:0] LD_ADDR_MISALIGNED = 4;\n  localparam logic [XLEN-1:0] LD_ACCESS_FAULT = 5;  // Illegal access as governed by PMPs and PMAs\n  localparam logic [XLEN-1:0] ST_ADDR_MISALIGNED = 6;\n  localparam logic [XLEN-1:0] ST_ACCESS_FAULT = 7;  // Illegal access as governed by PMPs and PMAs\n  localparam logic [XLEN-1:0] ENV_CALL_UMODE = 8;  // environment call from user mode\n  localparam logic [XLEN-1:0] ENV_CALL_SMODE = 9;  // environment call from supervisor mode\n  localparam logic [XLEN-1:0] ENV_CALL_MMODE = 11;  // environment call from machine mode\n  localparam logic [XLEN-1:0] INSTR_PAGE_FAULT = 12;  // Instruction page fault\n  localparam logic [XLEN-1:0] LOAD_PAGE_FAULT = 13;  // Load page fault\n  localparam logic [XLEN-1:0] STORE_PAGE_FAULT = 15;  // Store page fault\n  localparam logic [XLEN-1:0] DEBUG_REQUEST = 24;  // Debug request\n\n  localparam int unsigned IRQ_S_SOFT = 1;\n  localparam int unsigned IRQ_M_SOFT = 3;\n  localparam int unsigned IRQ_S_TIMER = 5;\n  localparam int unsigned IRQ_M_TIMER = 7;\n  localparam int unsigned IRQ_S_EXT = 9;\n  localparam int unsigned IRQ_M_EXT = 11;\n\n  localparam logic [XLEN-1:0] MIP_SSIP = 1 << IRQ_S_SOFT;\n  localparam logic [XLEN-1:0] MIP_MSIP = 1 << IRQ_M_SOFT;\n  localparam logic [XLEN-1:0] MIP_STIP = 1 << IRQ_S_TIMER;\n  localparam logic [XLEN-1:0] MIP_MTIP = 1 << IRQ_M_TIMER;\n  localparam logic [XLEN-1:0] MIP_SEIP = 1 << IRQ_S_EXT;\n  localparam logic [XLEN-1:0] MIP_MEIP = 1 << IRQ_M_EXT;\n\n  localparam logic [XLEN-1:0] S_SW_INTERRUPT = (1 << (XLEN - 1)) | XLEN'(IRQ_S_SOFT);\n  localparam logic [XLEN-1:0] M_SW_INTERRUPT = (1 << (XLEN - 1)) | XLEN'(IRQ_M_SOFT);\n  localparam logic [XLEN-1:0] S_TIMER_INTERRUPT = (1 << (XLEN - 1)) | XLEN'(IRQ_S_TIMER);\n  localparam logic [XLEN-1:0] M_TIMER_INTERRUPT = (1 << (XLEN - 1)) | XLEN'(IRQ_M_TIMER);\n  localparam logic [XLEN-1:0] S_EXT_INTERRUPT = (1 << (XLEN - 1)) | XLEN'(IRQ_S_EXT);\n  localparam logic [XLEN-1:0] M_EXT_INTERRUPT = (1 << (XLEN - 1)) | XLEN'(IRQ_M_EXT);\n\n  // -----\n  // CSRs\n  // -----\n  typedef enum logic [11:0] {\n    // Floating-Point CSRs\n    CSR_FFLAGS           = 12'h001,\n    CSR_FRM              = 12'h002,\n    CSR_FCSR             = 12'h003,\n    CSR_FTRAN            = 12'h800,\n    // Vector CSRs\n    CSR_VSTART           = 12'h008,\n    CSR_VXSAT            = 12'h009,\n    CSR_VXRM             = 12'h00A,\n    CSR_VCSR             = 12'h00F,\n    CSR_VL               = 12'hC20,\n    CSR_VTYPE            = 12'hC21,\n    CSR_VLENB            = 12'hC22,\n    // Supervisor Mode CSRs\n    CSR_SSTATUS          = 12'h100,\n    CSR_SIE              = 12'h104,\n    CSR_STVEC            = 12'h105,\n    CSR_SCOUNTEREN       = 12'h106,\n    CSR_SSCRATCH         = 12'h140,\n    CSR_SEPC             = 12'h141,\n    CSR_SCAUSE           = 12'h142,\n    CSR_STVAL            = 12'h143,\n    CSR_SIP              = 12'h144,\n    CSR_SATP             = 12'h180,\n    // Machine Mode CSRs\n    CSR_MSTATUS          = 12'h300,\n    CSR_MISA             = 12'h301,\n    CSR_MEDELEG          = 12'h302,\n    CSR_MIDELEG          = 12'h303,\n    CSR_MIE              = 12'h304,\n    CSR_MTVEC            = 12'h305,\n    CSR_MCOUNTEREN       = 12'h306,\n    CSR_MSTATUSH         = 12'h310,\n    CSR_MCOUNTINHIBIT    = 12'h320,\n    CSR_MHPM_EVENT_3     = 12'h323,  //Machine performance monitoring Event Selector\n    CSR_MHPM_EVENT_4     = 12'h324,  //Machine performance monitoring Event Selector\n    CSR_MHPM_EVENT_5     = 12'h325,  //Machine performance monitoring Event Selector\n    CSR_MHPM_EVENT_6     = 12'h326,  //Machine performance monitoring Event Selector\n    CSR_MHPM_EVENT_7     = 12'h327,  //Machine performance monitoring Event Selector\n    CSR_MHPM_EVENT_8     = 12'h328,  //Machine performance monitoring Event Selector\n    CSR_MHPM_EVENT_9     = 12'h329,  //Reserved\n    CSR_MHPM_EVENT_10    = 12'h32A,  //Reserved\n    CSR_MHPM_EVENT_11    = 12'h32B,  //Reserved\n    CSR_MHPM_EVENT_12    = 12'h32C,  //Reserved\n    CSR_MHPM_EVENT_13    = 12'h32D,  //Reserved\n    CSR_MHPM_EVENT_14    = 12'h32E,  //Reserved\n    CSR_MHPM_EVENT_15    = 12'h32F,  //Reserved\n    CSR_MHPM_EVENT_16    = 12'h330,  //Reserved\n    CSR_MHPM_EVENT_17    = 12'h331,  //Reserved\n    CSR_MHPM_EVENT_18    = 12'h332,  //Reserved\n    CSR_MHPM_EVENT_19    = 12'h333,  //Reserved\n    CSR_MHPM_EVENT_20    = 12'h334,  //Reserved\n    CSR_MHPM_EVENT_21    = 12'h335,  //Reserved\n    CSR_MHPM_EVENT_22    = 12'h336,  //Reserved\n    CSR_MHPM_EVENT_23    = 12'h337,  //Reserved\n    CSR_MHPM_EVENT_24    = 12'h338,  //Reserved\n    CSR_MHPM_EVENT_25    = 12'h339,  //Reserved\n    CSR_MHPM_EVENT_26    = 12'h33A,  //Reserved\n    CSR_MHPM_EVENT_27    = 12'h33B,  //Reserved\n    CSR_MHPM_EVENT_28    = 12'h33C,  //Reserved\n    CSR_MHPM_EVENT_29    = 12'h33D,  //Reserved\n    CSR_MHPM_EVENT_30    = 12'h33E,  //Reserved\n    CSR_MHPM_EVENT_31    = 12'h33F,  //Reserved\n    CSR_MSCRATCH         = 12'h340,\n    CSR_MEPC             = 12'h341,\n    CSR_MCAUSE           = 12'h342,\n    CSR_MTVAL            = 12'h343,\n    CSR_MIP              = 12'h344,\n    CSR_MENVCFG          = 12'h30A,\n    CSR_MENVCFGH         = 12'h31A,\n    CSR_PMPCFG0          = 12'h3A0,\n    CSR_PMPCFG1          = 12'h3A1,\n    CSR_PMPCFG2          = 12'h3A2,\n    CSR_PMPCFG3          = 12'h3A3,\n    CSR_PMPADDR0         = 12'h3B0,\n    CSR_PMPADDR1         = 12'h3B1,\n    CSR_PMPADDR2         = 12'h3B2,\n    CSR_PMPADDR3         = 12'h3B3,\n    CSR_PMPADDR4         = 12'h3B4,\n    CSR_PMPADDR5         = 12'h3B5,\n    CSR_PMPADDR6         = 12'h3B6,\n    CSR_PMPADDR7         = 12'h3B7,\n    CSR_PMPADDR8         = 12'h3B8,\n    CSR_PMPADDR9         = 12'h3B9,\n    CSR_PMPADDR10        = 12'h3BA,\n    CSR_PMPADDR11        = 12'h3BB,\n    CSR_PMPADDR12        = 12'h3BC,\n    CSR_PMPADDR13        = 12'h3BD,\n    CSR_PMPADDR14        = 12'h3BE,\n    CSR_PMPADDR15        = 12'h3BF,\n    CSR_MVENDORID        = 12'hF11,\n    CSR_MARCHID          = 12'hF12,\n    CSR_MIMPID           = 12'hF13,\n    CSR_MHARTID          = 12'hF14,\n    CSR_MCONFIGPTR       = 12'hF15,\n    CSR_MCYCLE           = 12'hB00,\n    CSR_MCYCLEH          = 12'hB80,\n    CSR_MINSTRET         = 12'hB02,\n    CSR_MINSTRETH        = 12'hB82,\n    //Performance Counters\n    CSR_MHPM_COUNTER_3   = 12'hB03,\n    CSR_MHPM_COUNTER_4   = 12'hB04,\n    CSR_MHPM_COUNTER_5   = 12'hB05,\n    CSR_MHPM_COUNTER_6   = 12'hB06,\n    CSR_MHPM_COUNTER_7   = 12'hB07,\n    CSR_MHPM_COUNTER_8   = 12'hB08,\n    CSR_MHPM_COUNTER_9   = 12'hB09,  // reserved\n    CSR_MHPM_COUNTER_10  = 12'hB0A,  // reserved\n    CSR_MHPM_COUNTER_11  = 12'hB0B,  // reserved\n    CSR_MHPM_COUNTER_12  = 12'hB0C,  // reserved\n    CSR_MHPM_COUNTER_13  = 12'hB0D,  // reserved\n    CSR_MHPM_COUNTER_14  = 12'hB0E,  // reserved\n    CSR_MHPM_COUNTER_15  = 12'hB0F,  // reserved\n    CSR_MHPM_COUNTER_16  = 12'hB10,  // reserved\n    CSR_MHPM_COUNTER_17  = 12'hB11,  // reserved\n    CSR_MHPM_COUNTER_18  = 12'hB12,  // reserved\n    CSR_MHPM_COUNTER_19  = 12'hB13,  // reserved\n    CSR_MHPM_COUNTER_20  = 12'hB14,  // reserved\n    CSR_MHPM_COUNTER_21  = 12'hB15,  // reserved\n    CSR_MHPM_COUNTER_22  = 12'hB16,  // reserved\n    CSR_MHPM_COUNTER_23  = 12'hB17,  // reserved\n    CSR_MHPM_COUNTER_24  = 12'hB18,  // reserved\n    CSR_MHPM_COUNTER_25  = 12'hB19,  // reserved\n    CSR_MHPM_COUNTER_26  = 12'hB1A,  // reserved\n    CSR_MHPM_COUNTER_27  = 12'hB1B,  // reserved\n    CSR_MHPM_COUNTER_28  = 12'hB1C,  // reserved\n    CSR_MHPM_COUNTER_29  = 12'hB1D,  // reserved\n    CSR_MHPM_COUNTER_30  = 12'hB1E,  // reserved\n    CSR_MHPM_COUNTER_31  = 12'hB1F,  // reserved\n    CSR_MHPM_COUNTER_3H  = 12'hB83,\n    CSR_MHPM_COUNTER_4H  = 12'hB84,\n    CSR_MHPM_COUNTER_5H  = 12'hB85,\n    CSR_MHPM_COUNTER_6H  = 12'hB86,\n    CSR_MHPM_COUNTER_7H  = 12'hB87,\n    CSR_MHPM_COUNTER_8H  = 12'hB88,\n    CSR_MHPM_COUNTER_9H  = 12'hB89,  // reserved\n    CSR_MHPM_COUNTER_10H = 12'hB8A,  // reserved\n    CSR_MHPM_COUNTER_11H = 12'hB8B,  // reserved\n    CSR_MHPM_COUNTER_12H = 12'hB8C,  // reserved\n    CSR_MHPM_COUNTER_13H = 12'hB8D,  // reserved\n    CSR_MHPM_COUNTER_14H = 12'hB8E,  // reserved\n    CSR_MHPM_COUNTER_15H = 12'hB8F,  // reserved\n    CSR_MHPM_COUNTER_16H = 12'hB90,  // reserved\n    CSR_MHPM_COUNTER_17H = 12'hB91,  // reserved\n    CSR_MHPM_COUNTER_18H = 12'hB92,  // reserved\n    CSR_MHPM_COUNTER_19H = 12'hB93,  // reserved\n    CSR_MHPM_COUNTER_20H = 12'hB94,  // reserved\n    CSR_MHPM_COUNTER_21H = 12'hB95,  // reserved\n    CSR_MHPM_COUNTER_22H = 12'hB96,  // reserved\n    CSR_MHPM_COUNTER_23H = 12'hB97,  // reserved\n    CSR_MHPM_COUNTER_24H = 12'hB98,  // reserved\n    CSR_MHPM_COUNTER_25H = 12'hB99,  // reserved\n    CSR_MHPM_COUNTER_26H = 12'hB9A,  // reserved\n    CSR_MHPM_COUNTER_27H = 12'hB9B,  // reserved\n    CSR_MHPM_COUNTER_28H = 12'hB9C,  // reserved\n    CSR_MHPM_COUNTER_29H = 12'hB9D,  // reserved\n    CSR_MHPM_COUNTER_30H = 12'hB9E,  // reserved\n    CSR_MHPM_COUNTER_31H = 12'hB9F,  // reserved\n    // Cache Control (platform specifc)\n    CSR_DCACHE           = 12'h7C1,\n    CSR_ICACHE           = 12'h7C0,\n    // Accelerator memory consistency (platform specific)\n    CSR_ACC_CONS         = 12'h7C2,\n    // Triggers\n    CSR_TSELECT          = 12'h7A0,\n    CSR_TDATA1           = 12'h7A1,\n    CSR_TDATA2           = 12'h7A2,\n    CSR_TDATA3           = 12'h7A3,\n    CSR_TINFO            = 12'h7A4,\n    // Debug CSR\n    CSR_DCSR             = 12'h7b0,\n    CSR_DPC              = 12'h7b1,\n    CSR_DSCRATCH0        = 12'h7b2,  // optional\n    CSR_DSCRATCH1        = 12'h7b3,  // optional\n    // Counters and Timers (User Mode - R/O Sha"}
{"text": "dows)\n    CSR_CYCLE            = 12'hC00,\n    CSR_CYCLEH           = 12'hC80,\n    CSR_TIME             = 12'hC01,\n    CSR_TIMEH            = 12'hC81,\n    CSR_INSTRET          = 12'hC02,\n    CSR_INSTRETH         = 12'hC82,\n    // Performance counters (User Mode - R/O Shadows)\n    CSR_HPM_COUNTER_3    = 12'hC03,\n    CSR_HPM_COUNTER_4    = 12'hC04,\n    CSR_HPM_COUNTER_5    = 12'hC05,\n    CSR_HPM_COUNTER_6    = 12'hC06,\n    CSR_HPM_COUNTER_7    = 12'hC07,\n    CSR_HPM_COUNTER_8    = 12'hC08,\n    CSR_HPM_COUNTER_9    = 12'hC09,  // reserved\n    CSR_HPM_COUNTER_10   = 12'hC0A,  // reserved\n    CSR_HPM_COUNTER_11   = 12'hC0B,  // reserved\n    CSR_HPM_COUNTER_12   = 12'hC0C,  // reserved\n    CSR_HPM_COUNTER_13   = 12'hC0D,  // reserved\n    CSR_HPM_COUNTER_14   = 12'hC0E,  // reserved\n    CSR_HPM_COUNTER_15   = 12'hC0F,  // reserved\n    CSR_HPM_COUNTER_16   = 12'hC10,  // reserved\n    CSR_HPM_COUNTER_17   = 12'hC11,  // reserved\n    CSR_HPM_COUNTER_18   = 12'hC12,  // reserved\n    CSR_HPM_COUNTER_19   = 12'hC13,  // reserved\n    CSR_HPM_COUNTER_20   = 12'hC14,  // reserved\n    CSR_HPM_COUNTER_21   = 12'hC15,  // reserved\n    CSR_HPM_COUNTER_22   = 12'hC16,  // reserved\n    CSR_HPM_COUNTER_23   = 12'hC17,  // reserved\n    CSR_HPM_COUNTER_24   = 12'hC18,  // reserved\n    CSR_HPM_COUNTER_25   = 12'hC19,  // reserved\n    CSR_HPM_COUNTER_26   = 12'hC1A,  // reserved\n    CSR_HPM_COUNTER_27   = 12'hC1B,  // reserved\n    CSR_HPM_COUNTER_28   = 12'hC1C,  // reserved\n    CSR_HPM_COUNTER_29   = 12'hC1D,  // reserved\n    CSR_HPM_COUNTER_30   = 12'hC1E,  // reserved\n    CSR_HPM_COUNTER_31   = 12'hC1F,  // reserved\n    CSR_HPM_COUNTER_3H   = 12'hC83,\n    CSR_HPM_COUNTER_4H   = 12'hC84,\n    CSR_HPM_COUNTER_5H   = 12'hC85,\n    CSR_HPM_COUNTER_6H   = 12'hC86,\n    CSR_HPM_COUNTER_7H   = 12'hC87,\n    CSR_HPM_COUNTER_8H   = 12'hC88,\n    CSR_HPM_COUNTER_9H   = 12'hC89,  // reserved\n    CSR_HPM_COUNTER_10H  = 12'hC8A,  // reserved\n    CSR_HPM_COUNTER_11H  = 12'hC8B,  // reserved\n    CSR_HPM_COUNTER_12H  = 12'hC8C,  // reserved\n    CSR_HPM_COUNTER_13H  = 12'hC8D,  // reserved\n    CSR_HPM_COUNTER_14H  = 12'hC8E,  // reserved\n    CSR_HPM_COUNTER_15H  = 12'hC8F,  // reserved\n    CSR_HPM_COUNTER_16H  = 12'hC90,  // reserved\n    CSR_HPM_COUNTER_17H  = 12'hC91,  // reserved\n    CSR_HPM_COUNTER_18H  = 12'hC92,  // reserved\n    CSR_HPM_COUNTER_19H  = 12'hC93,  // reserved\n    CSR_HPM_COUNTER_20H  = 12'hC94,  // reserved\n    CSR_HPM_COUNTER_21H  = 12'hC95,  // reserved\n    CSR_HPM_COUNTER_22H  = 12'hC96,  // reserved\n    CSR_HPM_COUNTER_23H  = 12'hC97,  // reserved\n    CSR_HPM_COUNTER_24H  = 12'hC98,  // reserved\n    CSR_HPM_COUNTER_25H  = 12'hC99,  // reserved\n    CSR_HPM_COUNTER_26H  = 12'hC9A,  // reserved\n    CSR_HPM_COUNTER_27H  = 12'hC9B,  // reserved\n    CSR_HPM_COUNTER_28H  = 12'hC9C,  // reserved\n    CSR_HPM_COUNTER_29H  = 12'hC9D,  // reserved\n    CSR_HPM_COUNTER_30H  = 12'hC9E,  // reserved\n    CSR_HPM_COUNTER_31H  = 12'hC9F   // reserved\n  } csr_reg_t;\n\n  localparam logic [63:0] SSTATUS_UIE = 'h00000001;\n  localparam logic [63:0] SSTATUS_SIE = 'h00000002;\n  localparam logic [63:0] SSTATUS_SPIE = 'h00000020;\n  localparam logic [63:0] SSTATUS_SPP = 'h00000100;\n  localparam logic [63:0] SSTATUS_FS = 'h00006000;\n  localparam logic [63:0] SSTATUS_XS = 'h00018000;\n  localparam logic [63:0] SSTATUS_SUM = 'h00040000;\n  localparam logic [63:0] SSTATUS_MXR = 'h00080000;\n  localparam logic [63:0] SSTATUS_UPIE = 'h00000010;\n  localparam logic [63:0] SSTATUS_UXL = 64'h0000000300000000;\n  localparam logic [63:0] SSTATUS_SD = {IS_XLEN64, 31'h00000000, ~IS_XLEN64, 31'h00000000};\n\n  localparam logic [63:0] MSTATUS_UIE = 'h00000001;\n  localparam logic [63:0] MSTATUS_SIE = 'h00000002;\n  localparam logic [63:0] MSTATUS_HIE = 'h00000004;\n  localparam logic [63:0] MSTATUS_MIE = 'h00000008;\n  localparam logic [63:0] MSTATUS_UPIE = 'h00000010;\n  localparam logic [63:0] MSTATUS_SPIE = 'h00000020;\n  localparam logic [63:0] MSTATUS_HPIE = 'h00000040;\n  localparam logic [63:0] MSTATUS_MPIE = 'h00000080;\n  localparam logic [63:0] MSTATUS_SPP = 'h00000100;\n  localparam logic [63:0] MSTATUS_HPP = 'h00000600;\n  localparam logic [63:0] MSTATUS_MPP = 'h00001800;\n  localparam logic [63:0] MSTATUS_FS = 'h00006000;\n  localparam logic [63:0] MSTATUS_XS = 'h00018000;\n  localparam logic [63:0] MSTATUS_MPRV = 'h00020000;\n  localparam logic [63:0] MSTATUS_SUM = 'h00040000;\n  localparam logic [63:0] MSTATUS_MXR = 'h00080000;\n  localparam logic [63:0] MSTATUS_TVM = 'h00100000;\n  localparam logic [63:0] MSTATUS_TW = 'h00200000;\n  localparam logic [63:0] MSTATUS_TSR = 'h00400000;\n  localparam logic [63:0] MSTATUS_UXL = {30'h0000000, IS_XLEN64, IS_XLEN64, 32'h00000000};\n  localparam logic [63:0] MSTATUS_SXL = {28'h0000000, IS_XLEN64, IS_XLEN64, 34'h00000000};\n  localparam logic [63:0] MSTATUS_SD = {IS_XLEN64, 31'h00000000, ~IS_XLEN64, 31'h00000000};\n\n  typedef enum logic [2:0] {\n    CSRRW  = 3'h1,\n    CSRRS  = 3'h2,\n    CSRRC  = 3'h3,\n    CSRRWI = 3'h5,\n    CSRRSI = 3'h6,\n    CSRRCI = 3'h7\n  } csr_op_t;\n\n  // decoded CSR address\n  typedef struct packed {\n    logic [1:0] rw;\n    priv_lvl_t  priv_lvl;\n    logic [7:0] address;\n  } csr_addr_t;\n\n  typedef union packed {\n    csr_reg_t  address;\n    csr_addr_t csr_decode;\n  } csr_t;\n\n  // Floating-Point control and status register (32-bit!)\n  typedef struct packed {\n    logic [31:15] reserved;  // reserved for L extension, return 0 otherwise\n    logic [6:0]   fprec;     // div/sqrt precision control\n    logic [2:0]   frm;       // float rounding mode\n    logic [4:0]   fflags;    // float exception flags\n  } fcsr_t;\n\n  // PMP\n  typedef enum logic [1:0] {\n    OFF   = 2'b00,\n    TOR   = 2'b01,\n    NA4   = 2'b10,\n    NAPOT = 2'b11\n  } pmp_addr_mode_t;\n\n  // PMP Access Type\n  typedef enum logic [2:0] {\n    ACCESS_NONE  = 3'b000,\n    ACCESS_READ  = 3'b001,\n    ACCESS_WRITE = 3'b010,\n    ACCESS_EXEC  = 3'b100\n  } pmp_access_t;\n\n  typedef struct packed {\n    logic x;\n    logic w;\n    logic r;\n  } pmpcfg_access_t;\n\n  // packed struct of a PMP configuration register (8bit)\n  typedef struct packed {\n    logic           locked;       // lock this configuration\n    logic [1:0]     reserved;\n    pmp_addr_mode_t addr_mode;    // Off, TOR, NA4, NAPOT\n    pmpcfg_access_t access_type;\n  } pmpcfg_t;\n\n  // -----\n  // Debug\n  // -----\n  typedef struct packed {\n    logic [31:28] xdebugver;\n    logic [27:16] zero2;\n    logic         ebreakm;\n    logic         zero1;\n    logic         ebreaks;\n    logic         ebreaku;\n    logic         stepie;\n    logic         stopcount;\n    logic         stoptime;\n    logic [8:6]   cause;\n    logic         zero0;\n    logic         mprven;\n    logic         nmip;\n    logic         step;\n    priv_lvl_t    prv;\n  } dcsr_t;\n\n  // Instruction Generation *incomplete*\n  function automatic logic [31:0] jal(logic [4:0] rd, logic [20:0] imm);\n    // OpCode Jal\n    return {imm[20], imm[10:1], imm[11], imm[19:12], rd, 7'h6f};\n  endfunction\n\n  function automatic logic [31:0] jalr(logic [4:0] rd, logic [4:0] rs1, logic [11:0] offset);\n    // OpCode Jal\n    return {offset[11:0], rs1, 3'b0, rd, 7'h67};\n  endfunction\n\n  function automatic logic [31:0] andi(logic [4:0] rd, logic [4:0] rs1, logic [11:0] imm);\n    // OpCode andi\n    return {imm[11:0], rs1, 3'h7, rd, 7'h13};\n  endfunction\n\n  function automatic logic [31:0] slli(logic [4:0] rd, logic [4:0] rs1, logic [5:0] shamt);\n    // OpCode slli\n    return {6'b0, shamt[5:0], rs1, 3'h1, rd, 7'h13};\n  endfunction\n\n  function automatic logic [31:0] srli(logic [4:0] rd, logic [4:0] rs1, logic [5:0] shamt);\n    // OpCode srli\n    return {6'b0, shamt[5:0], rs1, 3'h5, rd, 7'h13};\n  endfunction\n\n  function automatic logic [31:0] load(logic [2:0] size, logic [4:0] dest, logic [4:0] base,\n                                       logic [11:0] offset);\n    // OpCode Load\n    return {offset[11:0], base, size, dest, 7'h03};\n  endfunction\n\n  function automatic logic [31:0] auipc(logic [4:0] rd, logic [20:0] imm);\n    // OpCode Auipc\n    return {imm[20], imm[10:1], imm[11], imm[19:12], rd, 7'h17};\n  endfunction\n\n  function automatic logic [31:0] store(logic [2:0] size, logic [4:0] src, logic [4:0] base,\n                                        logic [11:0] offset);\n    // OpCode Store\n    return {offset[11:5], src, base, size, offset[4:0], 7'h23};\n  endfunction\n\n  function automatic logic [31:0] float_load(logic [2:0] size, logic [4:0] dest, logic [4:0] base,\n                                             logic [11:0] offset);\n    // OpCode Load\n    return {offset[11:0], base, size, dest, 7'b00_001_11};\n  endfunction\n\n  function automatic logic [31:0] float_store(logic [2:0] size, logic [4:0] src, logic [4:0] base,\n                                              logic [11:0] offset);\n    // OpCode Store\n    return {offset[11:5], src, base, size, offset[4:0], 7'b01_001_11};\n  endfunction\n\n  function automatic logic [31:0] csrw(csr_reg_t csr, logic [4:0] rs1);\n    // CSRRW, rd, OpCode System\n    return {csr, rs1, 3'h1, 5'h0, 7'h73};\n  endfunction\n\n  function automatic logic [31:0] csrr(csr_reg_t csr, logic [4:0] dest);\n    // rs1, CSRRS, rd, OpCode System\n    return {csr, 5'h0, 3'h2, dest, 7'h73};\n  endfunction\n\n  function automatic logic [31:0] branch(logic [4:0] src2, logic [4:0] src1, logic [2:0] funct3,\n                                         logic [11:0] offset);\n    // OpCode Branch\n    return {offset[11], offset[9:4], src2, src1, funct3, offset[3:0], offset[10], 7'b11_000_11};\n  endfunction\n\n  function automatic logic [31:0] ebreak();\n    return 32'h00100073;\n  endfunction\n\n  function automatic logic [31:0] wfi();\n    return 32'h10500073;\n  endfunction\n\n  function automatic logic [31:0] nop();\n    return 32'h00000013;\n  endfunction\n\n  function automatic logic [31:0] illegal();\n    return 32'h00000000;\n  endfunction\n\n\n  // trace log compatible to spikes commit log feature\n  // pragma translate_off\n  function string spikeCommitLog(logic [63:0] pc, priv_lvl_t priv_lvl, logic [31:0] instr,\n                                 logic [4:0] rd, logic [63:0] result, logic rd_fpr);\n    string rd_s;\n    string instr_word;\n\n    automatic string rf_s = rd_fpr ? \"f\" : \"x\";\n\n    if (instr[1:0] != 2'b11) begin\n      instr_word = $sformatf(\"(0x%h)\", instr[15:0]);\n    end else begin\n      instr_word = $sformatf(\"(0x%h)\", instr);\n    end\n\n    if (rd < 10) rd_s = $sformatf(\"%s %0d\", rf_s, rd);\n    else rd_s = $sformatf(\"%s%0d\", rf_s, rd);\n\n    if (rd_fpr || rd != 0) begin\n      // 0 0x0000000080000118 (0xeecf8f93) x31 0x0000000080004000\n      return $sformatf(\"%d 0x%h %s %s 0x%h\\n\", priv_lvl, pc, instr_word, rd_s, result);\n    end else begin\n      // 0 0x000000008000019c (0x0040006f)\n      return $sformatf(\"%d 0x%h %s\\n\", priv_lvl, pc, instr_word);\n    end\n  endfunction\n\n  typedef struct {\n    byte priv;\n    longint unsigned pc;\n    byte is_fp;\n    byte rd;\n    longint unsigned data;\n    int unsigned instr;\n    byte was_exception;\n  } commit_log_t;\n  // pragma translate_on\n\nendpackage\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 08.04.2017\n// Description: Scoreboard - keeps track of all decoded, issued and committed instructions\n\nmodule scoreboard #(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter type rs3_len_t = logic\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output logic sb_full_o,\n    // Flush only un-issued instructions - TO_BE_COMPLETED\n    input logic flush_unissued_instr_i,\n    // Flush whole scoreboard - TO_BE_COMPLETED\n    input logic flush_i,\n    // We have an unresolved branch - TO_BE_COMPLETED\n    input logic unresolved_branch_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output ariane_pkg::fu_t [2**ariane_pkg::REG_ADDR_SIZE-1:0] rd_clobber_gpr_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output ariane_pkg::fu_t [2**ariane_pkg::REG_ADDR_SIZE-1:0] rd_clobber_fpr_o,\n\n    // rs1 operand address - issue_read_operands\n    input  logic         [ariane_pkg::REG_ADDR_SIZE-1:0] rs1_i,\n    // rs1 operand - issue_read_operands\n    output riscv::xlen_t                                 rs1_o,\n    // rs1 operand is valid - issue_read_operands\n    output logic                                         rs1_valid_o,\n\n    // rs2 operand address - issue_read_operands\n    input  logic         [ariane_pkg::REG_ADDR_SIZE-1:0] rs2_i,\n    // rs2 operand - issue_read_operands\n    output riscv::xlen_t                                 rs2_o,\n    // rs2 operand is valid - issue_read_operands\n    output logic                                         rs2_valid_o,\n\n    // rs3 operand address - issue_read_operands\n    input  logic     [ariane_pkg::REG_ADDR_SIZE-1:0] rs3_i,\n    // rs3 operand - issue_read_operands\n    output rs3_len_t                                 rs3_o,\n    // rs3 operand is valid - issue_read_operands\n    output logic                                     rs3_valid_o,\n\n    // advertise instruction to commit stage, if commit_ack_i is asserted advance the commit pointer\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output ariane_pkg::scoreboard_entry_t [CVA6Cfg.NrCommitPorts-1:0] commit_instr_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input  logic                          [CVA6Cfg.NrCommitPorts-1:0] commit_ack_i,\n\n    // instruction to put on top of scoreboard e.g.: top pointer\n    // we can always put this instruction to the top unless we signal with asserted full_o\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input  ariane_pkg::scoreboard_entry_t        decoded_instr_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input  logic                          [31:0] orig_instr_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input  logic                                 decoded_instr_valid_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output logic                                 decoded_instr_ack_o,\n\n    // instruction to issue logic, if issue_instr_valid and issue_ready is asserted, advance the issue pointer\n    // Issue scoreboard entry - ACC_DISPATCHER\n    output ariane_pkg::scoreboard_entry_t        issue_instr_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output logic                          [31:0] orig_instr_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output logic                                 issue_instr_valid_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input  logic                                 issue_ack_i,\n\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input ariane_pkg::bp_resolve_t resolved_branch_i,\n    // Transaction ID at which to write the result back - TO_BE_COMPLETED\n    input logic [CVA6Cfg.NrWbPorts-1:0][ariane_pkg::TRANS_ID_BITS-1:0] trans_id_i,\n    // Results to write back - TO_BE_COMPLETED\n    input logic [CVA6Cfg.NrWbPorts-1:0][riscv::XLEN-1:0] wbdata_i,\n    // Exception from a functional unit (e.g.: ld/st exception) - TO_BE_COMPLETED\n    input ariane_pkg::exception_t [CVA6Cfg.NrWbPorts-1:0] ex_i,\n    // Indicates valid results - TO_BE_COMPLETED\n    input logic [CVA6Cfg.NrWbPorts-1:0] wt_valid_i,\n    // Cvxif we for writeback - TO_BE_COMPLETED\n    input logic x_we_i,\n\n    // TO_BE_COMPLETED - RVFI\n    output logic [ariane_pkg::TRANS_ID_BITS-1:0] rvfi_issue_pointer_o,\n    // TO_BE_COMPLETED - RVFI\n    output logic [CVA6Cfg.NrCommitPorts-1:0][ariane_pkg::TRANS_ID_BITS-1:0] rvfi_commit_pointer_o\n);\n\n  // this is the FIFO struct of the issue queue\n  typedef struct packed {\n    logic issued;  // this bit indicates whether we issued this instruction e.g.: if it is valid\n    logic is_rd_fpr_flag;  // redundant meta info, added for speed\n    ariane_pkg::scoreboard_entry_t sbe;  // this is the score board entry we will send to ex\n  } sb_mem_t;\n  sb_mem_t [ariane_pkg::NR_SB_ENTRIES-1:0] mem_q, mem_n;\n\n  logic issue_full, issue_en;\n  logic [ariane_pkg::TRANS_ID_BITS:0] issue_cnt_n, issue_cnt_q;\n  logic [ariane_pkg::TRANS_ID_BITS-1:0] issue_pointer_n, issue_pointer_q;\n  logic [CVA6Cfg.NrCommitPorts-1:0][ariane_pkg::TRANS_ID_BITS-1:0]\n      commit_pointer_n, commit_pointer_q;\n  logic [$clog2(CVA6Cfg.NrCommitPorts):0] num_commit;\n\n  // the issue queue is full don't issue any new instructions\n  // works since aligned to power of 2\n  assign issue_full = (issue_cnt_q[ariane_pkg::TRANS_ID_BITS] == 1'b1);\n\n  assign sb_full_o  = issue_full;\n\n  ariane_pkg::scoreboard_entry_t decoded_instr;\n  always_comb begin\n    decoded_instr = decoded_instr_i;\n  end\n\n  // output commit instruction directly\n  always_comb begin : commit_ports\n    for (int unsigned i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin\n      commit_instr_o[i] = mem_q[commit_pointer_q[i]].sbe;\n      commit_instr_o[i].trans_id = commit_pointer_q[i];\n    end\n  end\n\n  // an instruction is ready for issue if we have place in the issue FIFO and it the decoder says it is valid\n  always_comb begin\n    issue_instr_o          = decoded_instr_i;\n    orig_instr_o           = orig_instr_i;\n    // make sure we assign the correct trans ID\n    issue_instr_o.trans_id = issue_pointer_q;\n    // we are ready if we are not full and don't have any unresolved branches, but it can be\n    // the case that we have an unresolved branch which is cleared in that cycle (resolved_branch_i == 1)\n    issue_instr_valid_o    = decoded_instr_valid_i & ~unresolved_branch_i & ~issue_full;\n    decoded_instr_ack_o    = issue_ack_i & ~issue_full;\n  end\n\n  // maintain a FIFO with issued instructions\n  // keep track of all issued instructions\n  always_comb begin : issue_fifo\n    // default assignment\n    mem_n    = mem_q;\n    issue_en = 1'b0;\n\n    // if we got a acknowledge from the issue stage, put this scoreboard entry in the queue\n    if (decoded_instr_valid_i && decoded_instr_ack_o && !flush_unissued_instr_i) begin\n      // the decoded instruction we put in there is valid (1st bit)\n      // increase the issue counter and advance issue pointer\n      issue_en = 1'b1;\n      mem_n[issue_pointer_q] = {\n        1'b1,  // valid bit\n        (CVA6Cfg.FpPresent && ariane_pkg::is_rd_fpr(\n          decoded_instr_i.op\n        )),  // whether rd goes to the fpr\n        decoded_instr  // decoded instruction record\n      };\n    end\n\n    // ------------\n    // FU NONE\n    // ------------\n    for (int unsigned i = 0; i < ariane_pkg::NR_SB_ENTRIES; i++) begin\n      // The FU is NONE -> this instruction is valid immediately\n      if (mem_q[i].sbe.fu == ariane_pkg::NONE && mem_q[i].issued) mem_n[i].sbe.valid = 1'b1;\n    end\n\n    // ------------\n    // Write Back\n    // ------------\n    for (int unsigned i = 0; i < CVA6Cfg.NrWbPorts; i++) begin\n      // check if this instruction was issued (e.g.: it could happen after a flush that there is still\n      // something in the pipeline e.g. an incomplete memory operation)\n      if (wt_valid_i[i] && mem_q[trans_id_i[i]].issued) begin\n        mem_n[trans_id_i[i]].sbe.valid  = 1'b1;\n        mem_n[trans_id_i[i]].sbe.result = wbdata_i[i];\n        // save the target address of a branch (needed for debug in commit stage)\n        if (CVA6Cfg.DebugEn) begin\n          mem_n[trans_id_i[i]].sbe.bp.predict_address = resolved_branch_i.target_address;\n        end\n        if (mem_n[trans_id_i[i]].sbe.fu == ariane_pkg::CVXIF && ~x_we_i) begin\n          mem_n[trans_id_i[i]].sbe.rd = 5'b0;\n        end\n        // write the exception back if it is valid\n        if (ex_i[i].valid) mem_n[trans_id_i[i]].sbe.ex = ex_i[i];\n        // write the fflags back from the FPU (exception valid is never set), leave tval intact\n        else if(CVA6Cfg.FpPresent && (mem_q[trans_id_i[i]].sbe.fu == ariane_pkg::FPU || mem_q[trans_id_i[i]].sbe.fu == ariane_pkg::FPU_VEC)) begin\n          mem_n[trans_id_i[i]].sbe.ex.cause = ex_i[i].cause;\n        end\n      end\n    end\n\n    // ------------\n    // Commit Port\n    // ------------\n    // we've got an acknowledge from commit\n    for (int i = 0; i < CVA6Cfg.NrCommitPorts; i++) begin\n      if (commit_ack_i[i]) begin\n        // this instruction is no longer in issue e.g.: it is considered finished\n        mem_n[commit_pointer_q[i]].issued    = 1'b0;\n        mem_n[commit_pointer_q[i]].sbe.valid = 1'b0;\n      end\n    end\n\n    // ------\n    // Flush\n    // ------\n    if (flush_i) begin\n      for (int unsigned i = 0; i < ariane_pkg::NR_SB_ENTRIES; i++) begin\n        // set all valid flags for all entries to zero\n        mem_n[i].issued       = 1'b0;\n        mem_n[i].sbe.valid    = 1'b0;\n        mem_n[i].sbe.ex.valid = 1'b0;\n      end\n    end\n  end\n\n  // FIFO counter updates\n  if (CVA6Cfg.NrCommitPorts == 2) begin : gen_commit_ports\n    assign num_commit = commit_ack_i[1] + commit_ack_i[0];\n  end else begin : gen_one_commit_port\n    assign num_commit = commit_ack_i[0];\n  end\n\n  assign issue_cnt_n = (flush_i) ? '0 : issue_cnt_q - {{ariane_pkg::TRANS_ID_BITS - $clog2(\n      CVA6Cfg.NrCommitPorts\n  ) {1'b0}}, num_commit} + {{ariane_pkg::TRANS_ID_BITS - 1{1'b0}}, issue_en};\n  assign commit_pointer_n[0] = (flush_i) ? '0 : commit_pointer_q[0] + num_commit;\n  assign issue_pointer_n = (flush_i) ? '0 : issue_pointer_q + issue_en;\n\n  // precompute offsets for commit slots\n  for (genvar k = 1; k < CVA6Cfg.NrCommitPorts; k++) begin : gen_cnt_incr\n    assign commit_pointer_n[k] = (flush_i) ? '0 : commit_pointer_n[0] + unsigned'(k);\n  end\n\n  // -------------------\n  // RD clobber process\n  // -------------------\n  // rd_clobber output: output currently clobbered destination registers\n  logic            [2**ariane_pkg::REG_ADDR_SIZE-1:0][ariane_pkg::NR_SB_ENTRIES:0] gpr_clobber_vld;\n  logic            [2**ariane_pkg::REG_ADDR_SIZE-1:0][ariane_pkg::NR_SB_ENTRIES:0] fpr_clobber_vld;\n  ariane_pkg::fu_t [     ariane_pkg::NR_SB_ENTRIES:0]                              clobber_fu;\n\n  always_comb begin : clobber_assign\n    gpr_clobber_vld = '0;\n    fpr_clobber_vld = '0;\n\n    // default (highest entry hast lowest prio in arbiter tree below)\n    clobber_fu[ariane_pkg::NR_SB_ENTRIES] = ariane_pkg::NONE;\n    for (int unsigned i = 0; i < 2 ** ariane_pkg::REG_ADDR_SIZE; i++) begin\n      gpr_clobber_vld[i][ariane_pkg::NR_SB_ENTRIES] = 1'b1;\n      fpr_clobber_vld[i][ariane_pkg::NR_SB_ENTRIES] = 1'b1;\n    end\n\n    // check for all valid entries and set the clobber accordingly\n    for (int unsigned i = 0; i < ariane_pkg::NR_SB_ENTRIES; i++) begin\n      gpr_clobber_vld[mem_q[i].sbe.rd][i] = mem_q[i].issued & ~mem_q[i].is_rd_fpr_flag;\n      fpr_clobber_vld[mem_q[i].sbe.rd][i] = mem_q[i].issued & mem_q[i].is_rd_fpr_flag;\n      clobber_fu[i]                       = mem_q[i].sbe.fu;\n    end\n\n    // GPR[0] is always free\n    gpr_clobber_vld[0] = '0;\n  end\n\n  for (genvar k = 0; k < 2 ** ariane_pkg::REG_ADDR_SIZE; k++) begin : gen_sel_clobbers\n    // get fu that is going to clobber this register (there should be only one)\n    rr_arb_tree #(\n        .NumIn(ariane_pkg::NR_SB_ENTRIES + 1),\n        .DataType(ariane_pkg::fu_t),\n        .ExtPrio(1'b1),\n        .AxiVldRdy(1'b1)\n    ) i_sel_gpr_clobbers (\n        .clk_i  (clk_i),\n        .rst_ni (rst_ni),\n        .flush_i(1'b0),\n        .rr_i   ('0),\n        .req_i  (gpr_clobber_vld[k]),\n        .gnt_o  (),\n        .data_i (clobber_fu),\n        .gnt_i  (1'b1),\n        .req_o  (),\n        .data_o (rd_clobber_gpr_o[k]),\n        .idx_o  ()\n    );\n    if (CVA6Cfg.FpPresent) begin\n      rr_arb_tree #(\n          .NumIn(ariane_pkg::NR_SB_ENTRIES + 1),\n          .DataType(ariane_pkg::fu_t),\n          .ExtPrio(1'b1),\n          .AxiVldRdy(1'b1)\n      ) i_sel_fpr_clobbers (\n          .clk_i  (clk_i),\n          .rst_ni (rst_ni),\n          .flush_i(1'b0),\n          .rr_i   ('0),\n          .req_i  (fpr_clobber_vld[k]),\n          .gnt_o  (),\n          .data_i (clobber_fu),\n          .gnt_i  (1'b1),\n          .req_o  (),\n          .data_o (rd_clobber_fpr_o[k]),\n          .idx_o  ()\n      );\n    end\n  end\n\n  // ----------------------------------\n  // Read Operands (a.k.a forwarding)\n  // ----------------------------------\n  // read operand interface: same logic as register file\n  logic [ariane_pkg::NR_SB_ENTRIES+CVA6Cfg.NrWbPorts-1:0] rs1_fwd_req, rs2_fwd_req, rs3_fwd_req;\n  logic [ariane_pkg::NR_SB_ENTRIES+CVA6Cfg.NrWbPorts-1:0][riscv::XLEN-1:0] rs_data;\n  logic rs1_valid, rs2_valid, rs3_valid;\n\n  // WB ports have higher prio than entries\n  for (genvar k = 0; unsigned'(k) < CVA6Cfg.NrWbPorts; k++) begin : gen_rs_wb\n    assign rs1_fwd_req[k] = (mem_q[trans_id_i[k]].sbe.rd == rs1_i) & wt_valid_i[k] & (~ex_i[k].valid) & (mem_q[trans_id_i[k]].is_rd_fpr_flag == (CVA6Cfg.FpPresent && ariane_pkg::is_rs1_fpr(\n        issue_instr_o.op\n    )));\n    assign rs2_fwd_req[k] = (mem_q[trans_id_i[k]].sbe.rd == rs2_i) & wt_valid_i[k] & (~ex_i[k].valid) & (mem_q[trans_id_i[k]].is_rd_fpr_flag == (CVA6Cfg.FpPresent && ariane_pkg::is_rs2_fpr(\n        issue_instr_o.op\n    )));\n    assign rs3_fwd_req[k] = (mem_q[trans_id_i[k]].sbe.rd == rs3_i) & wt_valid_i[k] & (~ex_i[k].valid) & (mem_q[trans_id_i[k]].is_rd_fpr_flag == (CVA6Cfg.FpPresent && ariane_pkg::is_imm_fpr(\n        issue_instr_o.op\n    )));\n    assign rs_data[k] = wbdata_i[k];\n  end\n  for (genvar k = 0; unsigned'(k) < ariane_pkg::NR_SB_ENTRIES; k++) begin : gen_rs_entries\n    assign rs1_fwd_req[k+CVA6Cfg.NrWbPorts] = (mem_q[k].sbe.rd == rs1_i) & mem_q[k].issued & mem_q[k].sbe.valid & (mem_q[k].is_rd_fpr_flag == (CVA6Cfg.FpPresent && ariane_pkg::is_rs1_fpr(\n        issue_instr_o.op\n    )));\n    assign rs2_fwd_req[k+CVA6Cfg.NrWbPorts] = (mem_q[k].sbe.rd == rs2_i) & mem_q[k].issued & mem_q[k].sbe.valid & (mem_q[k].is_rd_fpr_flag == (CVA6Cfg.FpPresent && ariane_pkg::is_rs2_fpr(\n        issue_instr_o.op\n    )));\n    assign rs3_fwd_req[k+CVA6Cfg.NrWbPorts] = (mem_q[k].sbe.rd == rs3_i) & mem_q[k].issued & mem_q[k].sbe.valid & (mem_q[k].is_rd_fpr_flag == (CVA6Cfg.FpPresent && ariane_pkg::is_imm_fpr(\n        issue_instr_o.op\n    )));\n    assign rs_data[k+CVA6Cfg.NrWbPorts] = mem_q[k].sbe.result;\n  end\n\n  // check whether we are accessing GPR[0]\n  assign rs1_valid_o = rs1_valid & ((|rs1_i) | (CVA6Cfg.FpPresent && ariane_pkg::is_rs1_fpr(\n      issue_instr_o.op\n  )));\n  assign rs2_valid_o = rs2_valid & ((|rs2_i) | (CVA6Cfg.FpPresent && ariane_pkg::is_rs2_fpr(\n      issue_instr_o.op\n  )));\n  assign rs3_valid_o = CVA6Cfg.NrRgprPorts == 3 ? rs3_valid & ((|rs3_i) | (CVA6Cfg.FpPresent && ariane_pkg::is_imm_fpr(\n      issue_instr_o.op\n  ))) : rs3_valid;\n\n  // use fixed prio here\n  // this implicitly gives higher prio to WB ports\n  rr_arb_tree #(\n      .NumIn(ariane_pkg::NR_SB_ENTRIES + CVA6Cfg.NrWbPorts),\n      .DataWidth(riscv::XLEN),\n      .ExtPrio(1'b1),\n      .AxiVldRdy(1'b1)\n  ) i_sel_rs1 (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i(1'b0),\n      .rr_i   ('0),\n      .req_i  (rs1_fwd_req),\n      .gnt_o  (),\n      .data_i (rs_data),\n      .gnt_i  (1'b1),\n      .req_o  (rs1_valid),\n      .data_o (rs1_o),\n      .idx_o  ()\n  );\n\n  rr_arb_tree #(\n      .NumIn(ariane_pkg::NR_SB_ENTRIES + CVA6Cfg.NrWbPorts),\n      .DataWidth(riscv::XLEN),\n      .ExtPrio(1'b1),\n      .AxiVldRdy(1'b1)\n  ) i_sel_rs2 (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i(1'b0),\n      .rr_i   ('0),\n      .req_i  (rs2_fwd_req),\n      .gnt_o  (),\n      .data_i (rs_data),\n      .gnt_i  (1'b1),\n      .req_o  (rs2_valid),\n      .data_o (rs2_o),\n      .idx_o  ()\n  );\n\n  riscv::xlen_t rs3;\n\n  rr_arb_tree #(\n      .NumIn(ariane_pkg::NR_SB_ENTRIES + CVA6Cfg.NrWbPorts),\n      .DataWidth(riscv::XLEN),\n      .ExtPrio(1'b1),\n      .AxiVldRdy(1'b1)\n  ) i_sel_rs3 (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i(1'b0),\n      .rr_i   ('0),\n      .req_i  (rs3_fwd_req),\n      .gnt_o  (),\n      .data_i (rs_data),\n      .gnt_i  (1'b1),\n      .req_o  (rs3_valid),\n      .data_o (rs3),\n      .idx_o  ()\n  );\n\n  if (CVA6Cfg.NrRgprPorts == 3) begin : gen_gp_three_port\n    assign rs3_o = rs3[riscv::XLEN-1:0];\n  end else begin : gen_fp_three_port\n    assign rs3_o = rs3[CVA6Cfg.FLen-1:0];\n  end\n\n\n  // sequential process\n  always_ff @(posedge clk_i or negedge rst_ni) begin : regs\n    if (!rst_ni) begin\n      mem_q            <= '{default: sb_mem_t'(0)};\n      issue_cnt_q      <= '0;\n      commit_pointer_q <= '0;\n      issue_pointer_q  <= '0;\n    end else begin\n      issue_cnt_q      <= issue_cnt_n;\n      issue_pointer_q  <= issue_pointer_n;\n      mem_q            <= mem_n;\n      commit_pointer_q <= commit_pointer_n;\n    end\n  end\n\n  //RVFI\n  assign rvfi_issue_pointer_o  = issue_pointer_q;\n  assign rvfi_commit_pointer_o = commit_pointer_q;\n\n  //pragma translate_off\n  initial begin\n    assert (ariane_pkg::NR_SB_ENTRIES == 2 ** ariane_pkg::TRANS_ID_BITS)\n    else $fatal(1, \"Scoreboard size needs to be a power of two.\");\n  end\n\n  // assert that zero is never set\n  assert property (@(posedge clk_i) disable iff (!rst_ni) (rd_clobber_gpr_o[0] == ariane_pkg::NONE))\n  else $fatal(1, \"RD 0 should not bet set\");\n  // assert that we never acknowledge a commit if the instruction is not valid\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) commit_ack_i[0] |-> commit_instr_o[0].valid)\n  else $fatal(1, \"Commit acknowledged but instruction is not valid\");\n  if (CVA6Cfg.NrCommitPorts == 2) begin : gen_two_commit_ports\n    assert property (\n        @(posedge clk_i) disable iff (!rst_ni) commit_ack_i[1] |-> commit_instr_o[1].valid)\n    else $fatal(1, \"Commit acknowledged but instruction is not valid\");\n  end\n  // assert that we never give an issue ack signal if the instruction is not valid\n  assert property (@(posedge clk_i) disable iff (!rst_ni) issue_ack_i |-> issue_instr_valid_o)\n  else $fatal(1, \"Issue acknowledged but instruction is not valid\");\n\n  // there should never be more than one instruction writing the same destination register (except x0)\n  // check that no functional unit is retiring with the same transaction id\n  for (genvar i = 0; i < CVA6Cfg.NrWbPorts; i++) begin\n    for (genvar j = 0; j < CVA6Cfg.NrWbPorts; j++) begin\n      assert property (\n        @(posedge clk_i) disable iff (!rst_ni) wt_valid_i[i] && wt_valid_i[j] && (i != j) |-> (trans_id_i[i] != trans_id_i[j]))\n      else\n        $fatal(\n            1,\n            \"Two or more functional units are retiring instructions with the same transaction id!\"\n        );\n    end\n  end\n  //pragma translate_on\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n//         Andreas Traber    <traber@iis.ee.ethz.ch>, ETH Zurich\n//\n// Date: 18.10.2018\n// Description: simple 64bit serial divider\n\n\nmodule serdiv\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter WIDTH = 64,\n    parameter STABLE_HANDSHAKE = 0             // Guarantee a stable in_rdy_o during the input handshake. Keep it at 0 in CVA6\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Serdiv translation ID - Mult\n    input logic [TRANS_ID_BITS-1:0] id_i,\n    // A operand - Mult\n    input logic [WIDTH-1:0] op_a_i,\n    // B operand - Mult\n    input logic [WIDTH-1:0] op_b_i,\n    // Serdiv operation - Mult\n    input logic [1:0] opcode_i,  // 0: udiv, 2: urem, 1: div, 3: rem\n    // Serdiv instruction is valid - Mult\n    input logic in_vld_i,\n    // Serdiv FU is ready - Mult\n    output logic in_rdy_o,\n    // Flush - CONTROLLER\n    input logic flush_i,\n    // Serdiv result is valid - Mult\n    output logic out_vld_o,\n    // Serdiv is ready - Mult\n    input logic out_rdy_i,\n    // Serdiv transaction ID - Mult\n    output logic [TRANS_ID_BITS-1:0] id_o,\n    // Serdiv result - Mult\n    output logic [WIDTH-1:0] res_o\n);\n\n  /////////////////////////////////////\n  // signal declarations\n  /////////////////////////////////////\n\n  enum logic [1:0] {\n    IDLE,\n    DIVIDE,\n    FINISH\n  }\n      state_d, state_q;\n\n  logic [WIDTH-1:0] res_q, res_d;\n  logic [WIDTH-1:0] op_a_q, op_a_d;\n  logic [WIDTH-1:0] op_b_q, op_b_d;\n  logic op_a_sign, op_b_sign;\n  logic op_b_zero, op_b_zero_q, op_b_zero_d;\n  logic op_b_neg_one, op_b_neg_one_q, op_b_neg_one_d;\n\n  logic [TRANS_ID_BITS-1:0] id_q, id_d;\n\n  logic rem_sel_d, rem_sel_q;\n  logic comp_inv_d, comp_inv_q;\n  logic res_inv_d, res_inv_q;\n\n  logic [WIDTH-1:0] add_mux;\n  logic [WIDTH-1:0] add_out;\n  logic [WIDTH-1:0] add_tmp;\n  logic [WIDTH-1:0] b_mux;\n  logic [WIDTH-1:0] out_mux;\n\n  logic [$clog2(WIDTH)-1:0] cnt_q, cnt_d;\n  logic cnt_zero;\n\n  logic [WIDTH-1:0] lzc_a_input, lzc_b_input, op_b;\n  logic [$clog2(WIDTH)-1:0] lzc_a_result, lzc_b_result;\n  logic [$clog2(WIDTH+1)-1:0] shift_a;\n  logic [  $clog2(WIDTH+1):0] div_shift;\n\n  logic a_reg_en, b_reg_en, res_reg_en, ab_comp, pm_sel, load_en;\n  logic lzc_a_no_one, lzc_b_no_one;\n  logic div_res_zero_d, div_res_zero_q;\n\n\n  /////////////////////////////////////\n  // align the input operands\n  // for faster division\n  /////////////////////////////////////\n\n  assign op_a_sign    = op_a_i[$high(op_a_i)];\n  assign op_b_sign    = op_b_i[$high(op_b_i)];\n  assign op_b_zero    = lzc_b_no_one & ~op_b_sign;\n  assign op_b_neg_one = lzc_b_no_one & op_b_sign;\n\n  assign lzc_a_input  = (opcode_i[0] & op_a_sign) ? {~op_a_i[$high(op_a_i)-1:0], 1'b1} : op_a_i;\n  assign lzc_b_input  = (opcode_i[0] & op_b_sign) ? ~op_b_i : op_b_i;\n\n  lzc #(\n      .MODE (1),     // count leading zeros\n      .WIDTH(WIDTH)\n  ) i_lzc_a (\n      .in_i   (lzc_a_input),\n      .cnt_o  (lzc_a_result),\n      .empty_o(lzc_a_no_one)\n  );\n\n  lzc #(\n      .MODE (1),     // count leading zeros\n      .WIDTH(WIDTH)\n  ) i_lzc_b (\n      .in_i   (lzc_b_input),\n      .cnt_o  (lzc_b_result),\n      .empty_o(lzc_b_no_one)\n  );\n\n  assign shift_a = (lzc_a_no_one) ? WIDTH : {1'b0, lzc_a_result};\n  assign div_shift = {1'b0, lzc_b_result} - shift_a;\n\n  assign op_b = op_b_i <<< $unsigned(div_shift);\n\n  // the division is zero if |opB| > |opA| and can be terminated\n  assign div_res_zero_d = (load_en) ? div_shift[$high(div_shift)] : div_res_zero_q;\n\n  /////////////////////////////////////\n  // Datapath\n  /////////////////////////////////////\n\n  assign pm_sel = load_en & ~(opcode_i[0] & (op_a_sign ^ op_b_sign));\n\n  // muxes\n  assign add_mux = (load_en) ? op_a_i : op_b_q;\n\n  // attention: logical shift by one in case of negative operand B!\n  assign b_mux = (load_en) ? op_b : {comp_inv_q, (op_b_q[$high(op_b_q):1])};\n\n  // in case of bad timing, we could output from regs -> needs a cycle more in the FSM\n  assign out_mux     = (rem_sel_q) ? (op_b_neg_one_q ? '0 : op_a_q) : (op_b_zero_q ? '1 : (op_b_neg_one_q ? op_a_q : res_q));\n\n  // invert if necessary\n  assign res_o = (res_inv_q) ? -$signed(out_mux) : out_mux;\n\n  // main comparator\n  assign ab_comp     = ((op_a_q == op_b_q) | ((op_a_q > op_b_q) ^ comp_inv_q)) & ((|op_a_q) | op_b_zero_q);\n\n  // main adder\n  assign add_tmp = (load_en) ? 0 : op_a_q;\n  assign add_out = (pm_sel) ? add_tmp + add_mux : add_tmp - $signed(add_mux);\n\n  /////////////////////////////////////\n  // FSM, counter\n  /////////////////////////////////////\n\n  assign cnt_zero = (cnt_q == 0);\n  assign cnt_d = (load_en) ? div_shift[$clog2(WIDTH)-1:0] : (~cnt_zero) ? cnt_q - 1 : cnt_q;\n\n  always_comb begin : p_fsm\n    // default\n    state_d    = state_q;\n    in_rdy_o   = 1'b0;\n    out_vld_o  = 1'b0;\n    load_en    = 1'b0;\n    a_reg_en   = 1'b0;\n    b_reg_en   = 1'b0;\n    res_reg_en = 1'b0;\n\n    unique case (state_q)\n      IDLE: begin\n        in_rdy_o = 1'b1;\n\n        if (in_vld_i) begin\n          // CVA6: there is a cycle delay until the valid signal is asserted by the id stage\n          // Ara:  we need a stable handshake\n          in_rdy_o = (STABLE_HANDSHAKE) ? 1'b1 : 1'b0;\n          a_reg_en = 1'b1;\n          b_reg_en = 1'b1;\n          load_en  = 1'b1;\n          state_d  = DIVIDE;\n        end\n      end\n      DIVIDE: begin\n        if (~(div_res_zero_q | op_b_zero_q | op_b_neg_one_q)) begin\n          a_reg_en   = ab_comp;\n          b_reg_en   = 1'b1;\n          res_reg_en = 1'b1;\n        end\n        // can end the division immediately if the result is known\n        if (div_res_zero_q | op_b_zero_q | op_b_neg_one_q) begin\n          out_vld_o = 1'b1;\n          state_d   = FINISH;\n          if (out_rdy_i) begin\n            // in_rdy_o = 1'b1;// there is a cycle delay until the valid signal is asserted by the id stage\n            state_d = IDLE;\n          end\n        end else if (cnt_zero) begin\n          state_d = FINISH;\n        end\n      end\n      FINISH: begin\n        out_vld_o = 1'b1;\n\n        if (out_rdy_i) begin\n          // in_rdy_o = 1'b1;// there is a cycle delay until the valid signal is asserted by the id stage\n          state_d = IDLE;\n        end\n      end\n      default: state_d = IDLE;\n    endcase\n\n    if (flush_i) begin\n      in_rdy_o  = 1'b0;\n      out_vld_o = 1'b0;\n      a_reg_en  = 1'b0;\n      b_reg_en  = 1'b0;\n      load_en   = 1'b0;\n      state_d   = IDLE;\n    end\n  end\n\n  /////////////////////////////////////\n  // regs, flags\n  /////////////////////////////////////\n\n  // get flags\n  assign rem_sel_d = (load_en) ? opcode_i[1] : rem_sel_q;\n  assign comp_inv_d = (load_en) ? opcode_i[0] & op_b_sign : comp_inv_q;\n  assign op_b_zero_d = (load_en) ? op_b_zero : op_b_zero_q;\n  assign op_b_neg_one_d = (load_en) ? op_b_neg_one : op_b_neg_one_q;\n  assign res_inv_d       = (load_en) ? (~op_b_zero | opcode_i[1]) & opcode_i[0] & (op_a_sign ^ op_b_sign ^ op_b_neg_one) : res_inv_q;\n\n  // transaction id\n  assign id_d = (load_en) ? id_i : id_q;\n  assign id_o = id_q;\n\n  assign op_a_d = (a_reg_en) ? add_out : op_a_q;\n  assign op_b_d = (b_reg_en) ? b_mux : op_b_q;\n  assign res_d = (load_en) ? '0 : (res_reg_en) ? {res_q[$high(res_q)-1:0], ab_comp} : res_q;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs\n    if (~rst_ni) begin\n      state_q        <= IDLE;\n      op_a_q         <= '0;\n      op_b_q         <= '0;\n      res_q          <= '0;\n      cnt_q          <= '0;\n      id_q           <= '0;\n      rem_sel_q      <= 1'b0;\n      comp_inv_q     <= 1'b0;\n      res_inv_q      <= 1'b0;\n      op_b_zero_q    <= 1'b0;\n      op_b_neg_one_q <= 1'b0;\n      div_res_zero_q <= 1'b0;\n    end else begin\n      state_q        <= state_d;\n      op_a_q         <= op_a_d;\n      op_b_q         <= op_b_d;\n      res_q          <= res_d;\n      cnt_q          <= cnt_d;\n      id_q           <= id_d;\n      rem_sel_q      <= rem_sel_d;\n      comp_inv_q     <= comp_inv_d;\n      res_inv_q      <= res_inv_d;\n      op_b_zero_q    <= op_b_zero_d;\n      op_b_neg_one_q <= op_b_neg_one_d;\n      div_res_zero_q <= div_res_zero_d;\n    end\n  end\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba    <zarubaf@iis.ee.ethz.ch>, ETH Zurich\n//         Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 15.08.2018\n// Description: SRAM wrapper for FPGA (requires the fpga-support submodule)\n//\n// Note: the wrapped module contains two different implementations for\n// ALTERA and XILINX tools, since these follow different coding styles for\n// inferrable RAMS with byte enable. define `FPGA_TARGET_XILINX or\n// `FPGA_TARGET_ALTERA in your build environment (default is ALTERA)\n\nmodule sram #(\n    parameter DATA_WIDTH = 64,\n    parameter USER_WIDTH = 1,\n    parameter USER_EN    = 0,\n    parameter NUM_WORDS  = 1024,\n    parameter SIM_INIT   = \"none\",\n    parameter OUT_REGS   = 0     // enables output registers in FPGA macro (read lat = 2)\n)(\n   input  logic                          clk_i,\n   input  logic                          rst_ni,\n   input  logic                          req_i,\n   input  logic                          we_i,\n   input  logic [$clog2(NUM_WORDS)-1:0]  addr_i,\n   input  logic [USER_WIDTH-1:0]         wuser_i,\n   input  logic [DATA_WIDTH-1:0]         wdata_i,\n   input  logic [(DATA_WIDTH+7)/8-1:0]   be_i,\n   output logic [USER_WIDTH-1:0]         ruser_o,\n   output logic [DATA_WIDTH-1:0]         rdata_o\n);\n\nlocalparam DATA_WIDTH_ALIGNED = ((DATA_WIDTH+63)/64)*64;\nlocalparam USER_WIDTH_ALIGNED = DATA_WIDTH_ALIGNED; // To be fine tuned to reduce memory size\nlocalparam BE_WIDTH_ALIGNED   = (((DATA_WIDTH+7)/8+7)/8)*8;\n\nlogic [DATA_WIDTH_ALIGNED-1:0]  wdata_aligned;\nlogic [USER_WIDTH_ALIGNED-1:0]  wuser_aligned;\nlogic [BE_WIDTH_ALIGNED-1:0]    be_aligned;\nlogic [DATA_WIDTH_ALIGNED-1:0]  rdata_aligned;\nlogic [USER_WIDTH_ALIGNED-1:0]  ruser_aligned;\n\n// align to 64 bits for inferrable macro below\nalways_comb begin : p_align\n    wdata_aligned                    ='0;\n    wuser_aligned                    ='0;\n    be_aligned                       ='0;\n    wdata_aligned[DATA_WIDTH-1:0]    = wdata_i;\n    wuser_aligned[USER_WIDTH-1:0]    = wuser_i;\n    be_aligned[BE_WIDTH_ALIGNED-1:0] = be_i;\n\n    rdata_o = rdata_aligned[DATA_WIDTH-1:0];\n    ruser_o = ruser_aligned[USER_WIDTH-1:0];\nend\n\n  for (genvar k = 0; k<(DATA_WIDTH+63)/64; k++) begin : gen_cut\n      // unused byte-enable segments (8bits) are culled by the tool\n      tc_sram_wrapper #(\n        .NumWords(NUM_WORDS),           // Number of Words in data array\n        .DataWidth(64),                 // Data signal width\n        .ByteWidth(32'd8),              // Width of a data byte\n        .NumPorts(32'd1),               // Number of read and write ports\n        .Latency(32'd1),                // Latency when the read data is available\n        .SimInit(SIM_INIT),             // Simulation initialization\n        .PrintSimCfg(1'b0)              // Print configuration\n      ) i_tc_sram_wrapper (\n          .clk_i    ( clk_i                     ),\n          .rst_ni   ( rst_ni                    ),\n          .req_i    ( req_i                     ),\n          .we_i     ( we_i                      ),\n          .be_i     ( be_aligned[k*8 +: 8]      ),\n          .wdata_i  ( wdata_aligned[k*64 +: 64] ),\n          .addr_i   ( addr_i                    ),\n          .rdata_o  ( rdata_aligned[k*64 +: 64] )\n      );\n      if (USER_EN > 0) begin : gen_mem_user\n        tc_sram_wrapper #(\n          .NumWords(NUM_WORDS),           // Number of Words in data array\n          .DataWidth(64),                 // Data signal width\n          .ByteWidth(32'd8),              // Width of a data byte\n          .NumPorts(32'd1),               // Number of read and write ports\n          .Latency(32'd1),                // Latency when the read data is available\n          .SimInit(SIM_INIT),             // Simulation initialization\n          .PrintSimCfg(1'b0)              // Print configuration\n        ) i_tc_sram_wrapper_user (\n            .clk_i    ( clk_i                     ),\n            .rst_ni   ( rst_ni                    ),\n            .req_i    ( req_i                     ),\n            .we_i     ( we_i                      ),\n            .be_i     ( be_aligned[k*8 +: 8]      ),\n            .wdata_i  ( wuser_aligned[k*64 +: 64] ),\n            .addr_i   ( addr_i                    ),\n            .rdata_o  ( ruser_aligned[k*64 +: 64] )\n        );\n      end else begin\n        assign ruser_aligned[k*64 +: 64] = '0;\n      end\n  end\nendmodule : sram\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba    <zarubaf@iis.ee.ethz.ch>, ETH Zurich\n//         Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 15.08.2018\n\n// ******* WIP *******\n// Description: package for the standard Ariane cache subsystem.\n\npackage std_cache_pkg;\n\n  // Calculated parameter\n  localparam DCACHE_BYTE_OFFSET = $clog2(ariane_pkg::DCACHE_LINE_WIDTH / 8);\n  localparam DCACHE_NUM_WORDS = 2 ** (ariane_pkg::DCACHE_INDEX_WIDTH - DCACHE_BYTE_OFFSET);\n  localparam DCACHE_DIRTY_WIDTH = ariane_pkg::DCACHE_SET_ASSOC * 2;\n  localparam DCACHE_SET_ASSOC_WIDTH = $clog2(ariane_pkg::DCACHE_SET_ASSOC);\n  // localparam DECISION_BIT = 30; // bit on which to decide whether the request is cache-able or not\n\n  typedef struct packed {\n    logic [1:0]      id;     // id for which we handle the miss\n    logic            valid;\n    logic            we;\n    logic [55:0]     addr;\n    logic [7:0][7:0] wdata;\n    logic [7:0]      be;\n  } mshr_t;\n\n  typedef struct packed {\n    logic        valid;\n    logic [63:0] addr;\n    logic [7:0]  be;\n    logic [1:0]  size;\n    logic        we;\n    logic [63:0] wdata;\n    logic        bypass;\n  } miss_req_t;\n\n  typedef struct packed {\n    logic                req;\n    ariane_pkg::ad_req_t reqtype;\n    ariane_pkg::amo_t    amo;\n    logic [3:0]          id;\n    logic [63:0]         addr;\n    logic [63:0]         wdata;\n    logic                we;\n    logic [7:0]          be;\n    logic [1:0]          size;\n  } bypass_req_t;\n\n  typedef struct packed {\n    logic        gnt;\n    logic        valid;\n    logic [63:0] rdata;\n  } bypass_rsp_t;\n\n  typedef struct packed {\n    logic [ariane_pkg::DCACHE_TAG_WIDTH-1:0]  tag;    // tag array\n    logic [ariane_pkg::DCACHE_LINE_WIDTH-1:0] data;   // data array\n    logic                                     valid;  // state array\n    logic                                     dirty;  // state array\n  } cache_line_t;\n\n  // cache line byte enable\n  typedef struct packed {\n    logic [(ariane_pkg::DCACHE_TAG_WIDTH+7)/8-1:0] tag;  // byte enable into tag array\n    logic [(ariane_pkg::DCACHE_LINE_WIDTH+7)/8-1:0] data;  // byte enable into data array\n    logic [ariane_pkg::DCACHE_SET_ASSOC-1:0]        vldrty; // bit enable into state array (valid for a pair of dirty/valid bits)\n  } cl_be_t;\n\n  // convert one hot to bin for -> needed for cache replacement\n  function automatic logic [DCACHE_SET_ASSOC_WIDTH-1:0] one_hot_to_bin(\n      input logic [ariane_pkg::DCACHE_SET_ASSOC-1:0] in);\n    for (int unsigned i = 0; i < ariane_pkg::DCACHE_SET_ASSOC; i++) begin\n      if (in[i]) return i;\n    end\n  endfunction\n  // get the first bit set, returns one hot value\n  function automatic logic [ariane_pkg::DCACHE_SET_ASSOC-1:0] get_victim_cl(\n      input logic [ariane_pkg::DCACHE_SET_ASSOC-1:0] valid_dirty);\n    // one-hot return vector\n    logic [ariane_pkg::DCACHE_SET_ASSOC-1:0] oh = '0;\n    for (int unsigned i = 0; i < ariane_pkg::DCACHE_SET_ASSOC; i++) begin\n      if (valid_dirty[i]) begin\n        oh[i] = 1'b1;\n        return oh;\n      end\n    end\n  endfunction\nendpackage : std_cache_pkg\n\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba    <zarubaf@iis.ee.ethz.ch>, ETH Zurich\n//         Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 15.08.2018\n// Description: Standard Ariane cache subsystem with instruction cache and\n//              write-back data cache.\n\n\nmodule std_cache_subsystem\n  import ariane_pkg::*;\n  import std_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int unsigned NumPorts = 4,\n    parameter type axi_ar_chan_t = logic,\n    parameter type axi_aw_chan_t = logic,\n    parameter type axi_w_chan_t = logic,\n    parameter type axi_req_t = logic,\n    parameter type axi_rsp_t = logic\n) (\n    input logic clk_i,\n    input logic rst_ni,\n    input riscv::priv_lvl_t priv_lvl_i,\n    // I$\n    input logic icache_en_i,  // enable icache (or bypass e.g: in debug mode)\n    input logic icache_flush_i,  // flush the icache, flush and kill have to be asserted together\n    output logic icache_miss_o,  // to performance counter\n    // address translation requests\n    input icache_areq_t icache_areq_i,  // to/from frontend\n    output icache_arsp_t icache_areq_o,\n    // data requests\n    input icache_dreq_t icache_dreq_i,  // to/from frontend\n    output icache_drsp_t icache_dreq_o,\n    // AMOs\n    input amo_req_t amo_req_i,\n    output amo_resp_t amo_resp_o,\n    // D$\n    // Cache management\n    input logic dcache_enable_i,  // from CSR\n    input logic dcache_flush_i,  // high until acknowledged\n    output logic                           dcache_flush_ack_o,     // send a single cycle acknowledge signal when the cache is flushed\n    output logic dcache_miss_o,  // we missed on a ld/st\n    output logic                           wbuffer_empty_o,        // statically set to 1, as there is no wbuffer in this cache system\n    // Request ports\n    input dcache_req_i_t [NumPorts-1:0] dcache_req_ports_i,  // to/from LSU\n    output dcache_req_o_t [NumPorts-1:0] dcache_req_ports_o,  // to/from LSU\n    // memory side\n    output axi_req_t axi_req_o,\n    input axi_rsp_t axi_resp_i\n);\n\n  assign wbuffer_empty_o = 1'b1;\n\n  axi_req_t axi_req_icache;\n  axi_rsp_t axi_resp_icache;\n  axi_req_t axi_req_bypass;\n  axi_rsp_t axi_resp_bypass;\n  axi_req_t axi_req_data;\n  axi_rsp_t axi_resp_data;\n\n  cva6_icache_axi_wrapper #(\n      .CVA6Cfg  (CVA6Cfg),\n      .axi_req_t(axi_req_t),\n      .axi_rsp_t(axi_rsp_t)\n  ) i_cva6_icache_axi_wrapper (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .priv_lvl_i(priv_lvl_i),\n      .flush_i   (icache_flush_i),\n      .en_i      (icache_en_i),\n      .miss_o    (icache_miss_o),\n      .areq_i    (icache_areq_i),\n      .areq_o    (icache_areq_o),\n      .dreq_i    (icache_dreq_i),\n      .dreq_o    (icache_dreq_o),\n      .axi_req_o (axi_req_icache),\n      .axi_resp_i(axi_resp_icache)\n  );\n\n  // decreasing priority\n  // Port 0: PTW\n  // Port 1: Load Unit\n  // Port 2: Accelerator\n  // Port 3: Store Unit\n  std_nbdcache #(\n      .CVA6Cfg  (CVA6Cfg),\n      .NumPorts (NumPorts),\n      .axi_req_t(axi_req_t),\n      .axi_rsp_t(axi_rsp_t)\n  ) i_nbdcache (\n      .clk_i,\n      .rst_ni,\n      .enable_i    (dcache_enable_i),\n      .flush_i     (dcache_flush_i),\n      .flush_ack_o (dcache_flush_ack_o),\n      .miss_o      (dcache_miss_o),\n      .axi_bypass_o(axi_req_bypass),\n      .axi_bypass_i(axi_resp_bypass),\n      .axi_data_o  (axi_req_data),\n      .axi_data_i  (axi_resp_data),\n      .req_ports_i (dcache_req_ports_i),\n      .req_ports_o (dcache_req_ports_o),\n      .amo_req_i,\n      .amo_resp_o\n  );\n\n  // -----------------------\n  // Arbitrate AXI Ports\n  // -----------------------\n  logic [1:0] w_select, w_select_fifo, w_select_arbiter;\n  logic [1:0] w_fifo_usage;\n  logic w_fifo_empty, w_fifo_full;\n\n\n  // AR Channel\n  stream_arbiter #(\n      .DATA_T(axi_ar_chan_t),\n      .N_INP (3)\n  ) i_stream_arbiter_ar (\n      .clk_i,\n      .rst_ni,\n      .inp_data_i ({axi_req_icache.ar, axi_req_bypass.ar, axi_req_data.ar}),\n      .inp_valid_i({axi_req_icache.ar_valid, axi_req_bypass.ar_valid, axi_req_data.ar_valid}),\n      .inp_ready_o({axi_resp_icache.ar_ready, axi_resp_bypass.ar_ready, axi_resp_data.ar_ready}),\n      .oup_data_o (axi_req_o.ar),\n      .oup_valid_o(axi_req_o.ar_valid),\n      .oup_ready_i(axi_resp_i.ar_ready)\n  );\n\n  // AW Channel\n  stream_arbiter #(\n      .DATA_T(axi_aw_chan_t),\n      .N_INP (3)\n  ) i_stream_arbiter_aw (\n      .clk_i,\n      .rst_ni,\n      .inp_data_i ({axi_req_icache.aw, axi_req_bypass.aw, axi_req_data.aw}),\n      .inp_valid_i({axi_req_icache.aw_valid, axi_req_bypass.aw_valid, axi_req_data.aw_valid}),\n      .inp_ready_o({axi_resp_icache.aw_ready, axi_resp_bypass.aw_ready, axi_resp_data.aw_ready}),\n      .oup_data_o (axi_req_o.aw),\n      .oup_valid_o(axi_req_o.aw_valid),\n      .oup_ready_i(axi_resp_i.aw_ready)\n  );\n\n  // WID has been removed in AXI 4 so we need to keep track which AW request has been accepted\n  // to forward the correct write data.\n  always_comb begin\n    w_select = 0;\n    unique casez (axi_req_o.aw.id)\n      4'b0111: w_select = 2;  // dcache\n      4'b1???: w_select = 1;  // bypass\n      default: w_select = 0;  // icache\n    endcase\n  end\n\n  // W Channel\n  fifo_v3 #(\n      .DATA_WIDTH  (2),\n      // we can have a maximum of 4 oustanding transactions as each port is blocking\n      .DEPTH       (4),\n      .FALL_THROUGH(1'b1)\n  ) i_fifo_w_channel (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .flush_i   (1'b0),\n      .testmode_i(1'b0),\n      .full_o    (w_fifo_full),\n      .empty_o   (),                                                          // leave open\n      .usage_o   (w_fifo_usage),\n      .data_i    (w_select),\n      // a new transaction was requested and granted\n      .push_i    (axi_req_o.aw_valid & axi_resp_i.aw_ready),\n      // write ID to select the output MUX\n      .data_o    (w_select_fifo),\n      // transaction has finished\n      .pop_i     (axi_req_o.w_valid & axi_resp_i.w_ready & axi_req_o.w.last)\n  );\n\n  // In fall-through mode, the empty_o will be low when push_i is high (on zero usage).\n  // We do not want this here. Also, usage_o is missing the MSB, so on full fifo, usage_o is zero.\n  assign w_fifo_empty = w_fifo_usage == 0 && !w_fifo_full;\n\n  // icache will never write so select it as default (e.g.: when no arbitration is active)\n  // this is equal to setting it to zero\n  assign w_select_arbiter = w_fifo_empty ? (axi_req_o.aw_valid ? w_select : 0) : w_select_fifo;\n\n  stream_mux #(\n      .DATA_T(axi_w_chan_t),\n      .N_INP (3)\n  ) i_stream_mux_w (\n      .inp_data_i ({axi_req_data.w, axi_req_bypass.w, axi_req_icache.w}),\n      .inp_valid_i({axi_req_data.w_valid, axi_req_bypass.w_valid, axi_req_icache.w_valid}),\n      .inp_ready_o({axi_resp_data.w_ready, axi_resp_bypass.w_ready, axi_resp_icache.w_ready}),\n      .inp_sel_i  (w_select_arbiter),\n      .oup_data_o (axi_req_o.w),\n      .oup_valid_o(axi_req_o.w_valid),\n      .oup_ready_i(axi_resp_i.w_ready)\n  );\n\n  // Route responses based on ID\n  // 0000 -> I$\n  // 0111 -> D$\n  // 1??? -> Bypass\n  // R Channel\n  assign axi_resp_icache.r = axi_resp_i.r;\n  assign axi_resp_bypass.r = axi_resp_i.r;\n  assign axi_resp_data.r   = axi_resp_i.r;\n\n  logic [1:0] r_select;\n\n  always_comb begin\n    r_select = 0;\n    unique casez (axi_resp_i.r.id)\n      4'b0111: r_select = 0;  // dcache\n      4'b1???: r_select = 1;  // bypass\n      4'b0000: r_select = 2;  // icache\n      default: r_select = 0;\n    endcase\n  end\n\n  stream_demux #(\n      .N_OUP(3)\n  ) i_stream_demux_r (\n      .inp_valid_i(axi_resp_i.r_valid),\n      .inp_ready_o(axi_req_o.r_ready),\n      .oup_sel_i  (r_select),\n      .oup_valid_o({axi_resp_icache.r_valid, axi_resp_bypass.r_valid, axi_resp_data.r_valid}),\n      .oup_ready_i({axi_req_icache.r_ready, axi_req_bypass.r_ready, axi_req_data.r_ready})\n  );\n\n  // B Channel\n  logic [1:0] b_select;\n\n  assign axi_resp_icache.b = axi_resp_i.b;\n  assign axi_resp_bypass.b = axi_resp_i.b;\n  assign axi_resp_data.b   = axi_resp_i.b;\n\n  always_comb begin\n    b_select = 0;\n    unique casez (axi_resp_i.b.id)\n      4'b0111: b_select = 0;  // dcache\n      4'b1???: b_select = 1;  // bypass\n      4'b0000: b_select = 2;  // icache\n      default: b_select = 0;\n    endcase\n  end\n\n  stream_demux #(\n      .N_OUP(3)\n  ) i_stream_demux_b (\n      .inp_valid_i(axi_resp_i.b_valid),\n      .inp_ready_o(axi_req_o.b_ready),\n      .oup_sel_i  (b_select),\n      .oup_valid_o({axi_resp_icache.b_valid, axi_resp_bypass.b_valid, axi_resp_data.b_valid}),\n      .oup_ready_i({axi_req_icache.b_ready, axi_req_bypass.b_ready, axi_req_data.b_ready})\n  );\n\n  ///////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////\n\n  //pragma translate_off\n`ifndef VERILATOR\n\n  a_invalid_instruction_fetch :\n  assert property (\n    @(posedge clk_i) disable iff (~rst_ni) icache_dreq_o.valid |-> (|icache_dreq_o.data) !== 1'hX)\n  else\n    $warning(\n        1,\n        \"[l1 dcache] reading invalid instructions: vaddr=%08X, data=%08X\",\n        icache_dreq_o.vaddr,\n        icache_dreq_o.data\n    );\n\n  a_invalid_write_data :\n  assert property (\n    @(posedge clk_i) disable iff (~rst_ni) dcache_req_ports_i[NumPorts-1].data_req |-> |dcache_req_ports_i[NumPorts-1].data_be |-> (|dcache_req_ports_i[NumPorts-1].data_wdata) !== 1'hX)\n  else\n    $warning(\n        1,\n        \"[l1 dcache] writing invalid data: paddr=%016X, be=%02X, data=%016X\",\n        {\n          dcache_req_ports_i[NumPorts-1].address_tag, dcache_req_ports_i[NumPorts-1].address_index\n        },\n        dcache_req_ports_i[NumPorts-1].data_be,\n        dcache_req_ports_i[NumPorts-1].data_wdata\n    );\n  generate\n    for (genvar j = 0; j < NumPorts - 1; j++) begin\n      a_invalid_read_data :\n      assert property (\n          @(posedge clk_i) disable iff (~rst_ni) dcache_req_ports_o[j].data_rvalid |-> (|dcache_req_ports_o[j].data_rdata) !== 1'hX)\n      else\n        $warning(\n            1,\n            \"[l1 dcache] reading invalid data on port %01d: data=%016X\",\n            j,\n            dcache_req_ports_o[j].data_rdata\n        );\n    end\n  endgenerate\n\n`endif\n  //pragma translate_on\nendmodule  // std_cache_subsystem\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 13.10.2017\n// Description: Nonblocking private L1 dcache\n\n\nmodule std_nbdcache\n  import std_cache_pkg::*;\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int unsigned NumPorts = 4,\n    parameter type axi_req_t = logic,\n    parameter type axi_rsp_t = logic\n) (\n    input logic clk_i,  // Clock\n    input logic rst_ni,  // Asynchronous reset active low\n    // Cache management\n    input logic enable_i,  // from CSR\n    input logic flush_i,  // high until acknowledged\n    output logic flush_ack_o,  // send a single cycle acknowledge signal when the cache is flushed\n    output logic miss_o,  // we missed on a LD/ST\n    // AMOs\n    input amo_req_t amo_req_i,\n    output amo_resp_t amo_resp_o,\n    // Request ports\n    input dcache_req_i_t [NumPorts-1:0] req_ports_i,  // request ports\n    output dcache_req_o_t [NumPorts-1:0] req_ports_o,  // request ports\n    // Cache AXI refill port\n    output axi_req_t axi_data_o,\n    input axi_rsp_t axi_data_i,\n    output axi_req_t axi_bypass_o,\n    input axi_rsp_t axi_bypass_i\n);\n\n  import std_cache_pkg::*;\n\n  // -------------------------------\n  // Controller <-> Arbiter\n  // -------------------------------\n  // 1. Miss handler\n  // 2. PTW\n  // 3. Load Unit\n  // 4. Accelerator\n  // 5. Store unit\n  logic        [            NumPorts:0][  DCACHE_SET_ASSOC-1:0] req;\n  logic        [            NumPorts:0][DCACHE_INDEX_WIDTH-1:0] addr;\n  logic        [            NumPorts:0]                         gnt;\n  cache_line_t [  DCACHE_SET_ASSOC-1:0]                         rdata;\n  logic        [            NumPorts:0][  DCACHE_TAG_WIDTH-1:0] tag;\n\n  cache_line_t [            NumPorts:0]                         wdata;\n  logic        [            NumPorts:0]                         we;\n  cl_be_t      [            NumPorts:0]                         be;\n  logic        [  DCACHE_SET_ASSOC-1:0]                         hit_way;\n  // -------------------------------\n  // Controller <-> Miss unit\n  // -------------------------------\n  logic        [          NumPorts-1:0]                         busy;\n  logic        [          NumPorts-1:0][                  55:0] mshr_addr;\n  logic        [          NumPorts-1:0]                         mshr_addr_matches;\n  logic        [          NumPorts-1:0]                         mshr_index_matches;\n  logic        [                  63:0]                         critical_word;\n  logic                                                         critical_word_valid;\n\n  logic        [          NumPorts-1:0][ $bits(miss_req_t)-1:0] miss_req;\n  logic        [          NumPorts-1:0]                         miss_gnt;\n  logic        [          NumPorts-1:0]                         active_serving;\n\n  logic        [          NumPorts-1:0]                         bypass_gnt;\n  logic        [          NumPorts-1:0]                         bypass_valid;\n  logic        [          NumPorts-1:0][                  63:0] bypass_data;\n  // -------------------------------\n  // Arbiter <-> Datram,\n  // -------------------------------\n  logic        [  DCACHE_SET_ASSOC-1:0]                         req_ram;\n  logic        [DCACHE_INDEX_WIDTH-1:0]                         addr_ram;\n  logic                                                         we_ram;\n  cache_line_t                                                  wdata_ram;\n  cache_line_t [  DCACHE_SET_ASSOC-1:0]                         rdata_ram;\n  cl_be_t                                                       be_ram;\n\n  // ------------------\n  // Cache Controller\n  // ------------------\n  generate\n    for (genvar i = 0; i < NumPorts; i++) begin : master_ports\n      cache_ctrl #(\n          .CVA6Cfg(CVA6Cfg)\n      ) i_cache_ctrl (\n          .bypass_i  (~enable_i),\n          .busy_o    (busy[i]),\n          // from core\n          .req_port_i(req_ports_i[i]),\n          .req_port_o(req_ports_o[i]),\n          // to SRAM array\n          .req_o     (req[i+1]),\n          .addr_o    (addr[i+1]),\n          .gnt_i     (gnt[i+1]),\n          .data_i    (rdata),\n          .tag_o     (tag[i+1]),\n          .data_o    (wdata[i+1]),\n          .we_o      (we[i+1]),\n          .be_o      (be[i+1]),\n          .hit_way_i (hit_way),\n\n          .miss_req_o           (miss_req[i]),\n          .miss_gnt_i           (miss_gnt[i]),\n          .active_serving_i     (active_serving[i]),\n          .critical_word_i      (critical_word),\n          .critical_word_valid_i(critical_word_valid),\n          .bypass_gnt_i         (bypass_gnt[i]),\n          .bypass_valid_i       (bypass_valid[i]),\n          .bypass_data_i        (bypass_data[i]),\n\n          .mshr_addr_o         (mshr_addr[i]),\n          .mshr_addr_matches_i (mshr_addr_matches[i]),\n          .mshr_index_matches_i(mshr_index_matches[i]),\n          .*\n      );\n    end\n  endgenerate\n\n  // ------------------\n  // Miss Handling Unit\n  // ------------------\n  miss_handler #(\n      .CVA6Cfg  (CVA6Cfg),\n      .NR_PORTS (NumPorts),\n      .axi_req_t(axi_req_t),\n      .axi_rsp_t(axi_rsp_t)\n  ) i_miss_handler (\n      .flush_i              (flush_i),\n      .busy_i               (|busy),\n      // AMOs\n      .amo_req_i            (amo_req_i),\n      .amo_resp_o           (amo_resp_o),\n      .miss_req_i           (miss_req),\n      .miss_gnt_o           (miss_gnt),\n      .bypass_gnt_o         (bypass_gnt),\n      .bypass_valid_o       (bypass_valid),\n      .bypass_data_o        (bypass_data),\n      .critical_word_o      (critical_word),\n      .critical_word_valid_o(critical_word_valid),\n      .mshr_addr_i          (mshr_addr),\n      .mshr_addr_matches_o  (mshr_addr_matches),\n      .mshr_index_matches_o (mshr_index_matches),\n      .active_serving_o     (active_serving),\n      .req_o                (req[0]),\n      .addr_o               (addr[0]),\n      .data_i               (rdata),\n      .be_o                 (be[0]),\n      .data_o               (wdata[0]),\n      .we_o                 (we[0]),\n      .axi_bypass_o,\n      .axi_bypass_i,\n      .axi_data_o,\n      .axi_data_i,\n      .*\n  );\n\n  assign tag[0] = '0;\n\n  // --------------\n  // Memory Arrays\n  // --------------\n  for (genvar i = 0; i < DCACHE_SET_ASSOC; i++) begin : sram_block\n    sram #(\n        .DATA_WIDTH(DCACHE_LINE_WIDTH),\n        .NUM_WORDS (DCACHE_NUM_WORDS)\n    ) data_sram (\n        .req_i  (req_ram[i]),\n        .rst_ni (rst_ni),\n        .we_i   (we_ram),\n        .addr_i (addr_ram[DCACHE_INDEX_WIDTH-1:DCACHE_BYTE_OFFSET]),\n        .wuser_i('0),\n        .wdata_i(wdata_ram.data),\n        .be_i   (be_ram.data),\n        .ruser_o(),\n        .rdata_o(rdata_ram[i].data),\n        .*\n    );\n\n    sram #(\n        .DATA_WIDTH(DCACHE_TAG_WIDTH),\n        .NUM_WORDS (DCACHE_NUM_WORDS)\n    ) tag_sram (\n        .req_i  (req_ram[i]),\n        .rst_ni (rst_ni),\n        .we_i   (we_ram),\n        .addr_i (addr_ram[DCACHE_INDEX_WIDTH-1:DCACHE_BYTE_OFFSET]),\n        .wuser_i('0),\n        .wdata_i(wdata_ram.tag),\n        .be_i   (be_ram.tag),\n        .ruser_o(),\n        .rdata_o(rdata_ram[i].tag),\n        .*\n    );\n\n  end\n\n  // ----------------\n  // Valid/Dirty Regs\n  // ----------------\n\n  // align each valid/dirty bit pair to a byte boundary in order to leverage byte enable signals.\n  // note: if you have an SRAM that supports flat bit enables for your target technology,\n  // you can use it here to save the extra 4x overhead introduced by this workaround.\n  logic [4*DCACHE_DIRTY_WIDTH-1:0] dirty_wdata, dirty_rdata;\n\n  for (genvar i = 0; i < DCACHE_SET_ASSOC; i++) begin\n    assign dirty_wdata[8*i]   = wdata_ram.dirty;\n    assign dirty_wdata[8*i+1] = wdata_ram.valid;\n    assign rdata_ram[i].dirty = dirty_rdata[8*i];\n    assign rdata_ram[i].valid = dirty_rdata[8*i+1];\n  end\n\n  sram #(\n      .USER_WIDTH(1),\n      .DATA_WIDTH(4 * DCACHE_DIRTY_WIDTH),\n      .NUM_WORDS (DCACHE_NUM_WORDS)\n  ) valid_dirty_sram (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .req_i  (|req_ram),\n      .we_i   (we_ram),\n      .addr_i (addr_ram[DCACHE_INDEX_WIDTH-1:DCACHE_BYTE_OFFSET]),\n      .wuser_i('0),\n      .wdata_i(dirty_wdata),\n      .be_i   (be_ram.vldrty),\n      .ruser_o(),\n      .rdata_o(dirty_rdata)\n  );\n\n  // ------------------------------------------------\n  // Tag Comparison and memory arbitration\n  // ------------------------------------------------\n  tag_cmp #(\n      .CVA6Cfg         (CVA6Cfg),\n      .NR_PORTS        (NumPorts + 1),\n      .ADDR_WIDTH      (DCACHE_INDEX_WIDTH),\n      .DCACHE_SET_ASSOC(DCACHE_SET_ASSOC)\n  ) i_tag_cmp (\n      .req_i    (req),\n      .gnt_o    (gnt),\n      .addr_i   (addr),\n      .wdata_i  (wdata),\n      .we_i     (we),\n      .be_i     (be),\n      .rdata_o  (rdata),\n      .tag_i    (tag),\n      .hit_way_o(hit_way),\n\n      .req_o  (req_ram),\n      .addr_o (addr_ram),\n      .wdata_o(wdata_ram),\n      .we_o   (we_ram),\n      .be_o   (be_ram),\n      .rdata_i(rdata_ram),\n      .*\n  );\n\n\n  //pragma translate_off\n  initial begin\n    assert (DCACHE_LINE_WIDTH / CVA6Cfg.AxiDataWidth inside {2, 4, 8, 16})\n    else $fatal(1, \"Cache line size needs to be a power of two multiple of AxiDataWidth\");\n  end\n  //pragma translate_on\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 25.04.2017\n// Description: Store queue persists store requests and pushes them to memory\n//              if they are no longer speculative\n\n\nmodule store_buffer\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    input logic clk_i,  // Clock\n    input logic rst_ni,  // Asynchronous reset active low\n    input logic flush_i,  // if we flush we need to pause the transactions on the memory\n                          // otherwise we will run in a deadlock with the memory arbiter\n    input logic stall_st_pending_i,  // Stall issuing non-speculative request\n    output logic         no_st_pending_o, // non-speculative queue is empty (e.g.: everything is committed to the memory hierarchy)\n    output logic         store_buffer_empty_o, // there is no store pending in neither the speculative unit or the non-speculative queue\n\n    input  logic [11:0]  page_offset_i,         // check for the page offset (the last 12 bit if the current load matches them)\n    output logic         page_offset_matches_o, // the above input page offset matches -> let the store buffer drain\n\n    input logic commit_i,  // commit the instruction which was placed there most recently\n    output logic commit_ready_o,  // commit queue is ready to accept another commit request\n    output logic ready_o,  // the store queue is ready to accept a new request\n                           // it is only ready if it can unconditionally commit the instruction, e.g.:\n                           // the commit buffer needs to be empty\n    input logic valid_i,  // this is a valid store\n    input  logic         valid_without_flush_i, // just tell if the address is valid which we are current putting and do not take any further action\n\n    input  logic [riscv::PLEN-1:0]  paddr_i,         // physical address of store which needs to be placed in the queue\n    output [riscv::PLEN-1:0] rvfi_mem_paddr_o,\n    input riscv::xlen_t data_i,  // data which is placed in the queue\n    input logic [(riscv::XLEN/8)-1:0] be_i,  // byte enable in\n    input logic [1:0] data_size_i,  // type of request we are making (e.g.: bytes to write)\n\n    // D$ interface\n    input  dcache_req_o_t req_port_i,\n    output dcache_req_i_t req_port_o\n);\n\n  // the store queue has two parts:\n  // 1. Speculative queue\n  // 2. Commit queue which is non-speculative, e.g.: the store will definitely happen.\n  struct packed {\n    logic [riscv::PLEN-1:0] address;\n    riscv::xlen_t data;\n    logic [(riscv::XLEN/8)-1:0] be;\n    logic [1:0] data_size;\n    logic valid;  // this entry is valid, we need this for checking if the address offset matches\n  }\n      speculative_queue_n[DEPTH_SPEC-1:0],\n      speculative_queue_q[DEPTH_SPEC-1:0],\n      commit_queue_n[DEPTH_COMMIT-1:0],\n      commit_queue_q[DEPTH_COMMIT-1:0];\n\n  // keep a status count for both buffers\n  logic [$clog2(DEPTH_SPEC):0] speculative_status_cnt_n, speculative_status_cnt_q;\n  logic [$clog2(DEPTH_COMMIT):0] commit_status_cnt_n, commit_status_cnt_q;\n  // Speculative queue\n  logic [$clog2(DEPTH_SPEC)-1:0] speculative_read_pointer_n, speculative_read_pointer_q;\n  logic [$clog2(DEPTH_SPEC)-1:0] speculative_write_pointer_n, speculative_write_pointer_q;\n  // Commit Queue\n  logic [$clog2(DEPTH_COMMIT)-1:0] commit_read_pointer_n, commit_read_pointer_q;\n  logic [$clog2(DEPTH_COMMIT)-1:0] commit_write_pointer_n, commit_write_pointer_q;\n\n  assign store_buffer_empty_o = (speculative_status_cnt_q == 0) & no_st_pending_o;\n  // ----------------------------------------\n  // Speculative Queue - Core Interface\n  // ----------------------------------------\n  always_comb begin : core_if\n    automatic logic [$clog2(DEPTH_SPEC):0] speculative_status_cnt;\n    speculative_status_cnt      = speculative_status_cnt_q;\n\n    // default assignments\n    speculative_status_cnt_n    = speculative_status_cnt_q;\n    speculative_read_pointer_n  = speculative_read_pointer_q;\n    speculative_write_pointer_n = speculative_write_pointer_q;\n    speculative_queue_n         = speculative_queue_q;\n    // LSU interface\n    // we are ready to accept a new entry and the input data is valid\n    if (valid_i) begin\n      speculative_queue_n[speculative_write_pointer_q].address = paddr_i;\n      speculative_queue_n[speculative_write_pointer_q].data = data_i;\n      speculative_queue_n[speculative_write_pointer_q].be = be_i;\n      speculative_queue_n[speculative_write_pointer_q].data_size = data_size_i;\n      speculative_queue_n[speculative_write_pointer_q].valid = 1'b1;\n      // advance the write pointer\n      speculative_write_pointer_n = speculative_write_pointer_q + 1'b1;\n      speculative_status_cnt++;\n    end\n\n    // evict the current entry out of this queue, the commit queue will thankfully take it and commit it\n    // to the memory hierarchy\n    if (commit_i) begin\n      // invalidate\n      speculative_queue_n[speculative_read_pointer_q].valid = 1'b0;\n      // advance the read pointer\n      speculative_read_pointer_n = speculative_read_pointer_q + 1'b1;\n      speculative_status_cnt--;\n    end\n\n    speculative_status_cnt_n = speculative_status_cnt;\n\n    // when we flush evict the speculative stores\n    if (flush_i) begin\n      // reset all valid flags\n      for (int unsigned i = 0; i < DEPTH_SPEC; i++) speculative_queue_n[i].valid = 1'b0;\n\n      speculative_write_pointer_n = speculative_read_pointer_q;\n      // also reset the status count\n      speculative_status_cnt_n = 'b0;\n    end\n\n    // we are ready if the speculative and the commit queue have a space left\n    ready_o = (speculative_status_cnt_n < (DEPTH_SPEC)) || commit_i;\n  end\n\n  // ----------------------------------------\n  // Commit Queue - Memory Interface\n  // ----------------------------------------\n\n  // we will never kill a request in the store buffer since we already know that the translation is valid\n  // e.g.: a kill request will only be necessary if we are not sure if the requested memory address will result in a TLB fault\n  assign req_port_o.kill_req = 1'b0;\n  assign req_port_o.data_we = 1'b1;  // we will always write in the store queue\n  assign req_port_o.tag_valid = 1'b0;\n\n  // we do not require an acknowledgement for writes, thus we do not need to identify uniquely the responses\n  assign req_port_o.data_id = '0;\n  // those signals can directly be output to the memory\n  assign req_port_o.address_index = commit_queue_q[commit_read_pointer_q].address[ariane_pkg::DCACHE_INDEX_WIDTH-1:0];\n  // if we got a new request we already saved the tag from the previous cycle\n  assign req_port_o.address_tag   = commit_queue_q[commit_read_pointer_q].address[ariane_pkg::DCACHE_TAG_WIDTH     +\n                                                                                    ariane_pkg::DCACHE_INDEX_WIDTH-1 :\n                                                                                    ariane_pkg::DCACHE_INDEX_WIDTH];\n  assign req_port_o.data_wdata = commit_queue_q[commit_read_pointer_q].data;\n  assign req_port_o.data_be = commit_queue_q[commit_read_pointer_q].be;\n  assign req_port_o.data_size = commit_queue_q[commit_read_pointer_q].data_size;\n\n  assign rvfi_mem_paddr_o = commit_queue_n[commit_read_pointer_n].address;\n\n  always_comb begin : store_if\n    automatic logic [$clog2(DEPTH_COMMIT):0] commit_status_cnt;\n    commit_status_cnt      = commit_status_cnt_q;\n\n    commit_ready_o         = (commit_status_cnt_q < DEPTH_COMMIT);\n    // no store is pending if we don't have any element in the commit queue e.g.: it is empty\n    no_st_pending_o        = (commit_status_cnt_q == 0);\n    // default assignments\n    commit_read_pointer_n  = commit_read_pointer_q;\n    commit_write_pointer_n = commit_write_pointer_q;\n\n    commit_queue_n         = commit_queue_q;\n\n    req_port_o.data_req    = 1'b0;\n\n    // there should be no commit when we are flushing\n    // if the entry in the commit queue is valid and not speculative anymore we can issue this instruction\n    if (commit_queue_q[commit_read_pointer_q].valid && !stall_st_pending_i) begin\n      req_port_o.data_req = 1'b1;\n      if (req_port_i.data_gnt) begin\n        // we can evict it from the commit buffer\n        commit_queue_n[commit_read_pointer_q].valid = 1'b0;\n        // advance the read_pointer\n        commit_read_pointer_n = commit_read_pointer_q + 1'b1;\n        commit_status_cnt--;\n      end\n    end\n    // we ignore the rvalid signal for now as we assume that the store\n    // happened if we got a grant\n\n    // shift the store request from the speculative buffer to the non-speculative\n    if (commit_i) begin\n      commit_queue_n[commit_write_pointer_q] = speculative_queue_q[speculative_read_pointer_q];\n      commit_write_pointer_n = commit_write_pointer_n + 1'b1;\n      commit_status_cnt++;\n    end\n\n    commit_status_cnt_n = commit_status_cnt;\n  end\n\n  // ------------------\n  // Address Checker\n  // ------------------\n  // The load should return the data stored by the most recent store to the\n  // same physical address.  The most direct way to implement this is to\n  // maintain physical addresses in the store buffer.\n\n  // Of course, there are other micro-architectural techniques to accomplish\n  // the same thing: you can interlock and wait for the store buffer to\n  // drain if the load VA matches any store VA modulo the page size (i.e.\n  // bits 11:0).  As a special case, it is correct to bypass if the full VA\n  // matches, and no younger stores' VAs match in bits 11:0.\n  //\n  // checks if the requested load is in the store buffer\n  // page offsets are virtually and physically the same\n  always_comb begin : address_checker\n    page_offset_matches_o = 1'b0;\n\n    // check if the LSBs are identical and the entry is valid\n    for (int unsigned i = 0; i < DEPTH_COMMIT; i++) begin\n      // Check if the page offset matches and whether the entry is valid, for the commit queue\n      if ((page_offset_i[11:3] == commit_queue_q[i].address[11:3]) && commit_queue_q[i].valid) begin\n        page_offset_matches_o = 1'b1;\n        break;\n      end\n    end\n\n    for (int unsigned i = 0; i < DEPTH_SPEC; i++) begin\n      // do the same for the speculative queue\n      if ((page_offset_i[11:3] == speculative_queue_q[i].address[11:3]) && speculative_queue_q[i].valid) begin\n        page_offset_matches_o = 1'b1;\n        break;\n      end\n    end\n    // or it matches with the entry we are currently putting into the queue\n    if ((page_offset_i[11:3] == paddr_i[11:3]) && valid_without_flush_i) begin\n      page_offset_matches_o = 1'b1;\n    end\n  end\n\n\n  // registers\n  always_ff @(posedge clk_i or negedge rst_ni) begin : p_spec\n    if (~rst_ni) begin\n      speculative_queue_q         <= '{default: 0};\n      speculative_read_pointer_q  <= '0;\n      speculative_write_pointer_q <= '0;\n      speculative_status_cnt_q    <= '0;\n    end else begin\n      speculative_queue_q         <= speculative_queue_n;\n      speculative_read_pointer_q  <= speculative_read_pointer_n;\n      speculative_write_pointer_q <= speculative_write_pointer_n;\n      speculative_status_cnt_q    <= speculative_status_cnt_n;\n    end\n  end\n\n  // registers\n  always_ff @(posedge clk_i or negedge rst_ni) begin : p_commit\n    if (~rst_ni) begin\n      commit_queue_q         <= '{default: 0};\n      commit_read_pointer_q  <= '0;\n      commit_write_pointer_q <= '0;\n      commit_status_cnt_q    <= '0;\n    end else begin\n      commit_queue_q         <= commit_queue_n;\n      commit_read_pointer_q  <= commit_read_pointer_n;\n      commit_write_pointer_q <= commit_write_pointer_n;\n      commit_status_cnt_q    <= commit_status_cnt_n;\n    end\n  end\n\n  ///////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////\n\n  //pragma translate_off\n  // assert that commit is never set when we are flushing this would be counter intuitive\n  // as flush and commit is decided in the same stage\n  commit_and_flush :\n  assert property (@(posedge clk_i) rst_ni && flush_i |-> !commit_i)\n  else $error(\"[Commit Queue] You are trying to commit and flush in the same cycle\");\n\n  speculative_buffer_overflow :\n  assert property (@(posedge clk_i) rst_ni && (speculative_status_cnt_q == DEPTH_SPEC) |-> !valid_i)\n  else\n    $error(\"[Speculative Queue] You are trying to push new data although the buffer is not ready\");\n\n  speculative_buffer_underflow :\n  assert property (@(posedge clk_i) rst_ni && (speculative_status_cnt_q == 0) |-> !commit_i)\n  else $error(\"[Speculative Queue] You are committing although there are no stores to commit\");\n\n  commit_buffer_overflow :\n  assert property (@(posedge clk_i) rst_ni && (commit_status_cnt_q == DEPTH_COMMIT) |-> !commit_i)\n  else $error(\"[Commit Queue] You are trying to commit a store although the buffer is full\");\n  //pragma translate_on\nendmodule\n\n\n\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Florian Zaruba, ETH Zurich\n// Date: 22.05.2017\n// Description: Store Unit, takes care of all store requests and atomic memory operations (AMOs)\n\n\nmodule store_unit\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    // Subsystem Clock - SUBSYSTEM\n    input logic clk_i,\n    // Asynchronous reset active low - SUBSYSTEM\n    input logic rst_ni,\n    // Flush - CONTROLLER\n    input logic flush_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic stall_st_pending_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output logic no_st_pending_o,\n    // Store buffer is empty - TO_BE_COMPLETED\n    output logic store_buffer_empty_o,\n    // Store instruction is valid - ISSUE_STAGE\n    input logic valid_i,\n    // Data input - ISSUE_STAGE\n    input lsu_ctrl_t lsu_ctrl_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output logic pop_st_o,\n    // Instruction commit - TO_BE_COMPLETED\n    input logic commit_i,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    output logic commit_ready_o,\n    // TO_BE_COMPLETED - TO_BE_COMPLETED\n    input logic amo_valid_commit_i,\n    // Store result is valid - ISSUE_STAGE\n    output logic valid_o,\n    // Transaction ID - ISSUE_STAGE\n    output logic [TRANS_ID_BITS-1:0] trans_id_o,\n    // Store result - ISSUE_STAGE\n    output riscv::xlen_t result_o,\n    // Store exception output - TO_BE_COMPLETED\n    output exception_t ex_o,\n    // Address translation request - TO_BE_COMPLETED\n    output logic translation_req_o,\n    // Virtual address - TO_BE_COMPLETED\n    output logic [riscv::VLEN-1:0] vaddr_o,\n    // RVFI information - RVFI\n    output [riscv::PLEN-1:0] rvfi_mem_paddr_o,\n    // Physical address - TO_BE_COMPLETED\n    input logic [riscv::PLEN-1:0] paddr_i,\n    // Exception raised before store - TO_BE_COMPLETED\n    input exception_t ex_i,\n    // Data TLB hit - lsu\n    input logic dtlb_hit_i,\n    // Address to be checked - load_unit\n    input logic [11:0] page_offset_i,\n    // Address check result - load_unit\n    output logic page_offset_matches_o,\n    // AMO request - CACHES\n    output amo_req_t amo_req_o,\n    // AMO response - CACHES\n    input amo_resp_t amo_resp_i,\n    // Data cache request - CACHES\n    input dcache_req_o_t req_port_i,\n    // Data cache response - CACHES\n    output dcache_req_i_t req_port_o\n);\n  // it doesn't matter what we are writing back as stores don't return anything\n  assign result_o = lsu_ctrl_i.data;\n\n  enum logic [1:0] {\n    IDLE,\n    VALID_STORE,\n    WAIT_TRANSLATION,\n    WAIT_STORE_READY\n  }\n      state_d, state_q;\n\n  // store buffer control signals\n  logic st_ready;\n  logic st_valid;\n  logic st_valid_without_flush;\n  logic instr_is_amo;\n  assign instr_is_amo = is_amo(lsu_ctrl_i.operation);\n  // keep the data and the byte enable for the second cycle (after address translation)\n  riscv::xlen_t st_data_n, st_data_q;\n  logic [(riscv::XLEN/8)-1:0] st_be_n, st_be_q;\n  logic [1:0] st_data_size_n, st_data_size_q;\n  amo_t amo_op_d, amo_op_q;\n\n  logic [TRANS_ID_BITS-1:0] trans_id_n, trans_id_q;\n\n  // output assignments\n  assign vaddr_o    = lsu_ctrl_i.vaddr; // virtual address\n  assign trans_id_o = trans_id_q; // transaction id from previous cycle\n\n  always_comb begin : store_control\n    translation_req_o      = 1'b0;\n    valid_o                = 1'b0;\n    st_valid               = 1'b0;\n    st_valid_without_flush = 1'b0;\n    pop_st_o               = 1'b0;\n    ex_o                   = ex_i;\n    trans_id_n             = lsu_ctrl_i.trans_id;\n    state_d                = state_q;\n\n    case (state_q)\n      // we got a valid store\n      IDLE: begin\n        if (valid_i) begin\n          state_d = VALID_STORE;\n          translation_req_o = 1'b1;\n          pop_st_o = 1'b1;\n          // check if translation was valid and we have space in the store buffer\n          // otherwise simply stall\n          if (ariane_pkg::MMU_PRESENT && !dtlb_hit_i) begin\n            state_d  = WAIT_TRANSLATION;\n            pop_st_o = 1'b0;\n          end\n\n          if (!st_ready) begin\n            state_d  = WAIT_STORE_READY;\n            pop_st_o = 1'b0;\n          end\n        end\n      end\n\n      VALID_STORE: begin\n        valid_o = 1'b1;\n        // post this store to the store buffer if we are not flushing\n        if (!flush_i) st_valid = 1'b1;\n\n        st_valid_without_flush = 1'b1;\n\n        // we have another request and its not an AMO (the AMO buffer only has depth 1)\n        if ((valid_i && CVA6Cfg.RVA && !instr_is_amo) || (valid_i && !CVA6Cfg.RVA)) begin\n\n          translation_req_o = 1'b1;\n          state_d = VALID_STORE;\n          pop_st_o = 1'b1;\n\n          if (ariane_pkg::MMU_PRESENT && !dtlb_hit_i) begin\n            state_d  = WAIT_TRANSLATION;\n            pop_st_o = 1'b0;\n          end\n\n          if (!st_ready) begin\n            state_d  = WAIT_STORE_READY;\n            pop_st_o = 1'b0;\n          end\n          // if we do not have another request go back to idle\n        end else begin\n          state_d = IDLE;\n        end\n      end\n\n      // the store queue is currently full\n      WAIT_STORE_READY: begin\n        // keep the translation request high\n        translation_req_o = 1'b1;\n\n        if (st_ready && dtlb_hit_i) begin\n          state_d = IDLE;\n        end\n      end\n\n      default: begin\n        // we didn't receive a valid translation, wait for one\n        // but we know that the store queue is not full as we could only have landed here if\n        // it wasn't full\n        if (state_q == WAIT_TRANSLATION && ariane_pkg::MMU_PRESENT) begin\n          translation_req_o = 1'b1;\n\n          if (dtlb_hit_i) begin\n            state_d = IDLE;\n          end\n        end\n      end\n    endcase\n\n    // -----------------\n    // Access Exception\n    // -----------------\n    // we got an address translation exception (access rights, misaligned or page fault)\n    if (ex_i.valid && (state_q != IDLE)) begin\n      // the only difference is that we do not want to store this request\n      pop_st_o = 1'b1;\n      st_valid = 1'b0;\n      state_d  = IDLE;\n      valid_o  = 1'b1;\n    end\n\n    if (flush_i) state_d = IDLE;\n  end\n\n  // -----------\n  // Re-aligner\n  // -----------\n  // re-align the write data to comply with the address offset\n  always_comb begin\n    st_be_n = lsu_ctrl_i.be;\n    // don't shift the data if we are going to perform an AMO as we still need to operate on this data\n    st_data_n = (CVA6Cfg.RVA && instr_is_amo) ? lsu_ctrl_i.data[riscv::XLEN-1:0] :\n        data_align(lsu_ctrl_i.vaddr[2:0], {{64 - riscv::XLEN{1'b0}}, lsu_ctrl_i.data});\n    st_data_size_n = extract_transfer_size(lsu_ctrl_i.operation);\n    // save AMO op for next cycle\n    if (CVA6Cfg.RVA) begin\n      case (lsu_ctrl_i.operation)\n        AMO_LRW, AMO_LRD:     amo_op_d = AMO_LR;\n        AMO_SCW, AMO_SCD:     amo_op_d = AMO_SC;\n        AMO_SWAPW, AMO_SWAPD: amo_op_d = AMO_SWAP;\n        AMO_ADDW, AMO_ADDD:   amo_op_d = AMO_ADD;\n        AMO_ANDW, AMO_ANDD:   amo_op_d = AMO_AND;\n        AMO_ORW, AMO_ORD:     amo_op_d = AMO_OR;\n        AMO_XORW, AMO_XORD:   amo_op_d = AMO_XOR;\n        AMO_MAXW, AMO_MAXD:   amo_op_d = AMO_MAX;\n        AMO_MAXWU, AMO_MAXDU: amo_op_d = AMO_MAXU;\n        AMO_MINW, AMO_MIND:   amo_op_d = AMO_MIN;\n        AMO_MINWU, AMO_MINDU: amo_op_d = AMO_MINU;\n        default:              amo_op_d = AMO_NONE;\n      endcase\n    end else begin\n      amo_op_d = AMO_NONE;\n    end\n  end\n\n  logic store_buffer_valid, amo_buffer_valid;\n  logic store_buffer_ready, amo_buffer_ready;\n\n  // multiplex between store unit and amo buffer\n  assign store_buffer_valid = st_valid & (amo_op_q == AMO_NONE);\n  assign amo_buffer_valid = st_valid & (amo_op_q != AMO_NONE);\n\n  assign st_ready = store_buffer_ready & amo_buffer_ready;\n\n  // ---------------\n  // Store Queue\n  // ---------------\n  store_buffer #(\n      .CVA6Cfg(CVA6Cfg)\n  ) store_buffer_i (\n      .clk_i,\n      .rst_ni,\n      .flush_i,\n      .stall_st_pending_i,\n      .no_st_pending_o,\n      .store_buffer_empty_o,\n      .page_offset_i,\n      .page_offset_matches_o,\n      .commit_i,\n      .commit_ready_o,\n      .ready_o              (store_buffer_ready),\n      .valid_i              (store_buffer_valid),\n      // the flush signal can be critical and we need this valid\n      // signal to check whether the page_offset matches or not,\n      // functionaly it doesn't make a difference whether we use\n      // the correct valid signal or not as we are flushing\n      // the whole pipeline anyway\n      .valid_without_flush_i(st_valid_without_flush),\n      .paddr_i,\n      .rvfi_mem_paddr_o     (rvfi_mem_paddr_o),\n      .data_i               (st_data_q),\n      .be_i                 (st_be_q),\n      .data_size_i          (st_data_size_q),\n      .req_port_i           (req_port_i),\n      .req_port_o           (req_port_o)\n  );\n\n  if (CVA6Cfg.RVA) begin\n    amo_buffer #(\n        .CVA6Cfg(CVA6Cfg)\n    ) i_amo_buffer (\n        .clk_i,\n        .rst_ni,\n        .flush_i,\n        .valid_i           (amo_buffer_valid),\n        .ready_o           (amo_buffer_ready),\n        .paddr_i           (paddr_i),\n        .amo_op_i          (amo_op_q),\n        .data_i            (st_data_q),\n        .data_size_i       (st_data_size_q),\n        .amo_req_o         (amo_req_o),\n        .amo_resp_i        (amo_resp_i),\n        .amo_valid_commit_i(amo_valid_commit_i),\n        .no_st_pending_i   (no_st_pending_o)\n    );\n  end else begin\n    assign amo_buffer_ready = '1;\n    assign amo_req_o        = '0;\n  end\n\n  // ---------------\n  // Registers\n  // ---------------\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      state_q        <= IDLE;\n      st_be_q        <= '0;\n      st_data_q      <= '0;\n      st_data_size_q <= '0;\n      trans_id_q     <= '0;\n      amo_op_q       <= AMO_NONE;\n    end else begin\n      state_q        <= state_d;\n      st_be_q        <= st_be_n;\n      st_data_q      <= st_data_n;\n      trans_id_q     <= trans_id_n;\n      st_data_size_q <= st_data_size_n;\n      amo_op_q       <= amo_op_d;\n    end\n  end\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n// Author: Florian Zaruba <zarubaf@iis.ee.ethz.ch>\n// --------------\n// Tag Compare\n// --------------\n//\n// Description: Arbitrates access to cache memories, simplified request grant protocol\n//              checks for hit or miss on cache\n//\nmodule tag_cmp #(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg          = config_pkg::cva6_cfg_empty,\n    parameter int unsigned           NR_PORTS         = 3,\n    parameter int unsigned           ADDR_WIDTH       = 64,\n    parameter type                   l_data_t         = std_cache_pkg::cache_line_t,\n    parameter type                   l_be_t           = std_cache_pkg::cl_be_t,\n    parameter int unsigned           DCACHE_SET_ASSOC = 8\n) (\n    input logic clk_i,\n    input logic rst_ni,\n\n    input logic [NR_PORTS-1:0][DCACHE_SET_ASSOC-1:0] req_i,\n    output logic [NR_PORTS-1:0] gnt_o,\n    input logic [NR_PORTS-1:0][ADDR_WIDTH-1:0] addr_i,\n    input l_data_t [NR_PORTS-1:0] wdata_i,\n    input logic [NR_PORTS-1:0] we_i,\n    input l_be_t [NR_PORTS-1:0] be_i,\n    output l_data_t [DCACHE_SET_ASSOC-1:0] rdata_o,\n    input  logic    [NR_PORTS-1:0][ariane_pkg::DCACHE_TAG_WIDTH-1:0] tag_i, // tag in - comes one cycle later\n    output logic [DCACHE_SET_ASSOC-1:0] hit_way_o,  // we've got a hit on the corresponding way\n\n\n    output logic    [DCACHE_SET_ASSOC-1:0] req_o,\n    output logic    [      ADDR_WIDTH-1:0] addr_o,\n    output l_data_t                        wdata_o,\n    output logic                           we_o,\n    output l_be_t                          be_o,\n    input  l_data_t [DCACHE_SET_ASSOC-1:0] rdata_i\n);\n\n  assign rdata_o = rdata_i;\n  // one hot encoded\n  logic [NR_PORTS-1:0] id_d, id_q;\n  logic [ariane_pkg::DCACHE_TAG_WIDTH-1:0] sel_tag;\n\n  always_comb begin : tag_sel\n    sel_tag = '0;\n    for (int unsigned i = 0; i < NR_PORTS; i++) if (id_q[i]) sel_tag = tag_i[i];\n  end\n\n  for (genvar j = 0; j < DCACHE_SET_ASSOC; j++) begin : tag_cmp\n    assign hit_way_o[j] = (sel_tag == rdata_i[j].tag) ? rdata_i[j].valid : 1'b0;\n  end\n\n  always_comb begin\n\n    gnt_o   = '0;\n    id_d    = '0;\n    wdata_o = '0;\n    req_o   = '0;\n    addr_o  = '0;\n    be_o    = '0;\n    we_o    = '0;\n    // Request Side\n    // priority select\n    for (int unsigned i = 0; i < NR_PORTS; i++) begin\n      req_o    = req_i[i];\n      id_d     = (1'b1 << i);\n      gnt_o[i] = 1'b1;\n      addr_o   = addr_i[i];\n      be_o     = be_i[i];\n      we_o     = we_i[i];\n      wdata_o  = wdata_i[i];\n\n      if (req_i[i]) break;\n    end\n\n`ifndef SYNTHESIS\n`ifndef VERILATOR\n    // assert that cache only hits on one way\n    // this only needs to be checked one cycle after all ways have been requested\n    onehot :\n    assert property (@(posedge clk_i) disable iff (!rst_ni) &req_i |=> $onehot0(hit_way_o))\n    else begin\n      $fatal(1, \"Hit should be one-hot encoded\");\n    end\n`endif\n`endif\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      id_q <= 0;\n    end else begin\n      id_q <= id_d;\n    end\n  end\n\nendmodule\n"}
{"text": "// Copyright 2022 Thales Research and Technology\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: S\u00e9bastien Jacq\n\nmodule tc_sram_wrapper #(\n  parameter int unsigned NumWords     = 32'd1024, // Number of Words in data array\n  parameter int unsigned DataWidth    = 32'd128,  // Data signal width\n  parameter int unsigned ByteWidth    = 32'd8,    // Width of a data byte\n  parameter int unsigned NumPorts     = 32'd1,    // Number of read and write ports\n  parameter int unsigned Latency      = 32'd1,    // Latency when the read data is available\n  parameter              SimInit      = \"none\",   // Simulation initialization\n  parameter bit          PrintSimCfg  = 1'b0,     // Print configuration\n  // DEPENDENT PARAMETERS, DO NOT OVERWRITE!\n  parameter int unsigned AddrWidth = (NumWords > 32'd1) ? $clog2(NumWords) : 32'd1,\n  parameter int unsigned BeWidth   = (DataWidth + ByteWidth - 32'd1) / ByteWidth, // ceil_div\n  parameter type         addr_t    = logic [AddrWidth-1:0],\n  parameter type         data_t    = logic [DataWidth-1:0],\n  parameter type         be_t      = logic [BeWidth-1:0]\n) (\n  input  logic                 clk_i,      // Clock\n  input  logic                 rst_ni,     // Asynchronous reset active low\n  // input ports\n  input  logic  [NumPorts-1:0] req_i,      // request\n  input  logic  [NumPorts-1:0] we_i,       // write enable\n  input  addr_t [NumPorts-1:0] addr_i,     // request address\n  input  data_t [NumPorts-1:0] wdata_i,    // write data\n  input  be_t   [NumPorts-1:0] be_i,       // write byte enable\n  // output ports\n  output data_t [NumPorts-1:0] rdata_o     // read data\n);\n\n  SyncSpRamBeNx64 #(\n    .ADDR_WIDTH(AddrWidth),\n    .DATA_DEPTH(NumWords),\n    .OUT_REGS (0),\n    // this initializes the memory with 0es. adjust to taste...\n    // 0: no init, 1: zero init, 2: random init, 3: deadbeef init\n    .SIM_INIT (1)\n  ) i_ram (\n    .Clk_CI    ( clk_i      ),\n    .Rst_RBI   ( rst_ni     ),\n    .CSel_SI   ( req_i[0]   ),\n    .WrEn_SI   ( we_i[0]    ),\n    .BEn_SI    ( be_i[0]    ),\n    .WrData_DI ( wdata_i[0] ),\n    .Addr_DI   ( addr_i[0]  ),\n    .RdData_DO ( rdata_o[0] )\n  );\n\n\n\n\nendmodule\n"}
{"text": "// Copyright 2022 Thales DIS design services SAS\n//\n// Licensed under the Solderpad Hardware Licence, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// SPDX-License-Identifier: Apache-2.0 WITH SHL-2.0\n// You may obtain a copy of the License at https://solderpad.org/licenses/\n//\n// Original Author: Jean-Roch COULON - Thales\n\nmodule tc_sram_wrapper #(\n  parameter int unsigned NumWords     = 32'd1024, // Number of Words in data array\n  parameter int unsigned DataWidth    = 32'd128,  // Data signal width\n  parameter int unsigned ByteWidth    = 32'd8,    // Width of a data byte\n  parameter int unsigned NumPorts     = 32'd2,    // Number of read and write ports\n  parameter int unsigned Latency      = 32'd1,    // Latency when the read data is available\n  parameter              SimInit      = \"none\",   // Simulation initialization\n  parameter bit          PrintSimCfg  = 1'b0,     // Print configuration\n  // DEPENDENT PARAMETERS, DO NOT OVERWRITE!\n  parameter int unsigned AddrWidth = (NumWords > 32'd1) ? $clog2(NumWords) : 32'd1,\n  parameter int unsigned BeWidth   = (DataWidth + ByteWidth - 32'd1) / ByteWidth, // ceil_div\n  parameter type         addr_t    = logic [AddrWidth-1:0],\n  parameter type         data_t    = logic [DataWidth-1:0],\n  parameter type         be_t      = logic [BeWidth-1:0]\n) (\n  input  logic                 clk_i,      // Clock\n  input  logic                 rst_ni,     // Asynchronous reset active low\n  // input ports\n  input  logic  [NumPorts-1:0] req_i,      // request\n  input  logic  [NumPorts-1:0] we_i,       // write enable\n  input  addr_t [NumPorts-1:0] addr_i,     // request address\n  input  data_t [NumPorts-1:0] wdata_i,    // write data\n  input  be_t   [NumPorts-1:0] be_i,       // write byte enable\n  // output ports\n  output data_t [NumPorts-1:0] rdata_o     // read data\n);\n\n// synthesis translate_off\n\n  tc_sram #(\n    .NumWords(NumWords),\n    .DataWidth(DataWidth),\n    .ByteWidth(ByteWidth),\n    .NumPorts(NumPorts),\n    .Latency(Latency),\n    .SimInit(SimInit),\n    .PrintSimCfg(PrintSimCfg)\n  ) i_tc_sram (\n      .clk_i    ( clk_i   ),\n      .rst_ni   ( rst_ni  ),\n      .req_i    ( req_i   ),\n      .we_i     ( we_i    ),\n      .be_i     ( be_i    ),\n      .wdata_i  ( wdata_i ),\n      .addr_i   ( addr_i  ),\n      .rdata_o  ( rdata_o )\n    );\n\n// synthesis translate_on\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: David Schaffenrath, TU Graz\n// Author: Florian Zaruba, ETH Zurich\n// Date: 21.4.2017\n// Description: Translation Lookaside Buffer, SV39\n//              fully set-associative\n\n\nmodule tlb\n  import ariane_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int unsigned TLB_ENTRIES = 4,\n    parameter int unsigned ASID_WIDTH = 1\n) (\n    input  logic                          clk_i,                  // Clock\n    input  logic                          rst_ni,                 // Asynchronous reset active low\n    input  logic                          flush_i,                // Flush signal\n    // Update TLB\n    input  tlb_update_t                   update_i,\n    // Lookup signals\n    input  logic                          lu_access_i,\n    input  logic        [ ASID_WIDTH-1:0] lu_asid_i,\n    input  logic        [riscv::VLEN-1:0] lu_vaddr_i,\n    output riscv::pte_t                   lu_content_o,\n    input  logic        [ ASID_WIDTH-1:0] asid_to_be_flushed_i,\n    input  logic        [riscv::VLEN-1:0] vaddr_to_be_flushed_i,\n    output logic                          lu_is_2M_o,\n    output logic                          lu_is_1G_o,\n    output logic                          lu_hit_o\n);\n\n  // SV39 defines three levels of page tables\n  struct packed {\n    logic [ASID_WIDTH-1:0] asid;\n    logic [riscv::VPN2:0]  vpn2;\n    logic [8:0]            vpn1;\n    logic [8:0]            vpn0;\n    logic                  is_2M;\n    logic                  is_1G;\n    logic                  valid;\n  } [TLB_ENTRIES-1:0]\n      tags_q, tags_n;\n\n  riscv::pte_t [TLB_ENTRIES-1:0] content_q, content_n;\n  logic [8:0] vpn0, vpn1;\n  logic [  riscv::VPN2:0] vpn2;\n  logic [TLB_ENTRIES-1:0] lu_hit;  // to replacement logic\n  logic [TLB_ENTRIES-1:0] replace_en;  // replace the following entry, set by replacement strategy\n  //-------------\n  // Translation\n  //-------------\n  always_comb begin : translation\n    vpn0         = lu_vaddr_i[20:12];\n    vpn1         = lu_vaddr_i[29:21];\n    vpn2         = lu_vaddr_i[30+riscv::VPN2:30];\n\n    // default assignment\n    lu_hit       = '{default: 0};\n    lu_hit_o     = 1'b0;\n    lu_content_o = '{default: 0};\n    lu_is_1G_o   = 1'b0;\n    lu_is_2M_o   = 1'b0;\n\n    for (int unsigned i = 0; i < TLB_ENTRIES; i++) begin\n      // first level match, this may be a giga page, check the ASID flags as well\n      // if the entry is associated to a global address, don't match the ASID (ASID is don't care)\n      if (tags_q[i].valid && ((lu_asid_i == tags_q[i].asid) || content_q[i].g)  && vpn2 == tags_q[i].vpn2) begin\n        // second level\n        if (tags_q[i].is_1G) begin\n          lu_is_1G_o = 1'b1;\n          lu_content_o = content_q[i];\n          lu_hit_o = 1'b1;\n          lu_hit[i] = 1'b1;\n          // not a giga page hit so check further\n        end else if (vpn1 == tags_q[i].vpn1) begin\n          // this could be a 2 mega page hit or a 4 kB hit\n          // output accordingly\n          if (tags_q[i].is_2M || vpn0 == tags_q[i].vpn0) begin\n            lu_is_2M_o   = tags_q[i].is_2M;\n            lu_content_o = content_q[i];\n            lu_hit_o     = 1'b1;\n            lu_hit[i]    = 1'b1;\n          end\n        end\n      end\n    end\n  end\n\n\n\n  logic asid_to_be_flushed_is0;  // indicates that the ASID provided by SFENCE.VMA (rs2)is 0, active high\n  logic vaddr_to_be_flushed_is0;  // indicates that the VADDR provided by SFENCE.VMA (rs1)is 0, active high\n  logic [TLB_ENTRIES-1:0] vaddr_vpn0_match;\n  logic [TLB_ENTRIES-1:0] vaddr_vpn1_match;\n  logic [TLB_ENTRIES-1:0] vaddr_vpn2_match;\n\n  assign asid_to_be_flushed_is0  = ~(|asid_to_be_flushed_i);\n  assign vaddr_to_be_flushed_is0 = ~(|vaddr_to_be_flushed_i);\n\n  // ------------------\n  // Update and Flush\n  // ------------------\n  always_comb begin : update_flush\n    tags_n    = tags_q;\n    content_n = content_q;\n\n    for (int unsigned i = 0; i < TLB_ENTRIES; i++) begin\n\n      vaddr_vpn0_match[i] = (vaddr_to_be_flushed_i[20:12] == tags_q[i].vpn0);\n      vaddr_vpn1_match[i] = (vaddr_to_be_flushed_i[29:21] == tags_q[i].vpn1);\n      vaddr_vpn2_match[i] = (vaddr_to_be_flushed_i[30+riscv::VPN2:30] == tags_q[i].vpn2);\n\n      if (flush_i) begin\n        // invalidate logic\n        // flush everything if ASID is 0 and vaddr is 0 (\"SFENCE.VMA x0 x0\" case)\n        if (asid_to_be_flushed_is0 && vaddr_to_be_flushed_is0) tags_n[i].valid = 1'b0;\n        // flush vaddr in all addressing space (\"SFENCE.VMA vaddr x0\" case), it should happen only for leaf pages\n        else if (asid_to_be_flushed_is0 && ((vaddr_vpn0_match[i] && vaddr_vpn1_match[i] && vaddr_vpn2_match[i]) || (vaddr_vpn2_match[i] && tags_q[i].is_1G) || (vaddr_vpn1_match[i] && vaddr_vpn2_match[i] && tags_q[i].is_2M) ) && (~vaddr_to_be_flushed_is0))\n          tags_n[i].valid = 1'b0;\n        // the entry is flushed if it's not global and asid and vaddr both matches with the entry to be flushed (\"SFENCE.VMA vaddr asid\" case)\n        else if ((!content_q[i].g) && ((vaddr_vpn0_match[i] && vaddr_vpn1_match[i] && vaddr_vpn2_match[i]) || (vaddr_vpn2_match[i] && tags_q[i].is_1G) || (vaddr_vpn1_match[i] && vaddr_vpn2_match[i] && tags_q[i].is_2M)) && (asid_to_be_flushed_i == tags_q[i].asid) && (!vaddr_to_be_flushed_is0) && (!asid_to_be_flushed_is0))\n          tags_n[i].valid = 1'b0;\n        // the entry is flushed if it's not global, and the asid matches and vaddr is 0. (\"SFENCE.VMA 0 asid\" case)\n        else if ((!content_q[i].g) && (vaddr_to_be_flushed_is0) && (asid_to_be_flushed_i == tags_q[i].asid) && (!asid_to_be_flushed_is0))\n          tags_n[i].valid = 1'b0;\n        // normal replacement\n      end else if (update_i.valid & replace_en[i]) begin\n        // update tag array\n        tags_n[i] = '{\n            asid: update_i.asid,\n            vpn2: update_i.vpn[18+riscv::VPN2:18],\n            vpn1: update_i.vpn[17:9],\n            vpn0: update_i.vpn[8:0],\n            is_1G: update_i.is_1G,\n            is_2M: update_i.is_2M,\n            valid: 1'b1\n        };\n        // and content as well\n        content_n[i] = update_i.content;\n      end\n    end\n  end\n\n  // -----------------------------------------------\n  // PLRU - Pseudo Least Recently Used Replacement\n  // -----------------------------------------------\n  logic [2*(TLB_ENTRIES-1)-1:0] plru_tree_q, plru_tree_n;\n  always_comb begin : plru_replacement\n    plru_tree_n = plru_tree_q;\n    // The PLRU-tree indexing:\n    // lvl0        0\n    //            / \\\n        //           /   \\\n        // lvl1     1     2\n        //         / \\   / \\\n        // lvl2   3   4 5   6\n        //       / \\ /\\/\\  /\\\n        //      ... ... ... ...\n        // Just predefine which nodes will be set/cleared\n        // E.g. for a TLB with 8 entries, the for-loop is semantically\n        // equivalent to the following pseudo-code:\n        // unique case (1'b1)\n        // lu_hit[7]: plru_tree_n[0, 2, 6] = {1, 1, 1};\n        // lu_hit[6]: plru_tree_n[0, 2, 6] = {1, 1, 0};\n        // lu_hit[5]: plru_tree_n[0, 2, 5] = {1, 0, 1};\n        // lu_hit[4]: plru_tree_n[0, 2, 5] = {1, 0, 0};\n        // lu_hit[3]: plru_tree_n[0, 1, 4] = {0, 1, 1};\n        // lu_hit[2]: plru_tree_n[0, 1, 4] = {0, 1, 0};\n        // lu_hit[1]: plru_tree_n[0, 1, 3] = {0, 0, 1};\n        // lu_hit[0]: plru_tree_n[0, 1, 3] = {0, 0, 0};\n        // default: begin /* No hit */ end\n        // endcase\n        for (\n        int unsigned i = 0; i < TLB_ENTRIES; i++\n    ) begin\n      automatic int unsigned idx_base, shift, new_index;\n      // we got a hit so update the pointer as it was least recently used\n      if (lu_hit[i] & lu_access_i) begin\n        // Set the nodes to the values we would expect\n        for (int unsigned lvl = 0; lvl < $clog2(TLB_ENTRIES); lvl++) begin\n          idx_base = $unsigned((2 ** lvl) - 1);\n          // lvl0 <=> MSB, lvl1 <=> MSB-1, ...\n          shift = $clog2(TLB_ENTRIES) - lvl;\n          // to circumvent the 32 bit integer arithmetic assignment\n          new_index = ~((i >> (shift - 1)) & 32'b1);\n          plru_tree_n[idx_base+(i>>shift)] = new_index[0];\n        end\n      end\n    end\n    // Decode tree to write enable signals\n    // Next for-loop basically creates the following logic for e.g. an 8 entry\n    // TLB (note: pseudo-code obviously):\n    // replace_en[7] = &plru_tree_q[ 6, 2, 0]; //plru_tree_q[0,2,6]=={1,1,1}\n    // replace_en[6] = &plru_tree_q[~6, 2, 0]; //plru_tree_q[0,2,6]=={1,1,0}\n    // replace_en[5] = &plru_tree_q[ 5,~2, 0]; //plru_tree_q[0,2,5]=={1,0,1}\n    // replace_en[4] = &plru_tree_q[~5,~2, 0]; //plru_tree_q[0,2,5]=={1,0,0}\n    // replace_en[3] = &plru_tree_q[ 4, 1,~0]; //plru_tree_q[0,1,4]=={0,1,1}\n    // replace_en[2] = &plru_tree_q[~4, 1,~0]; //plru_tree_q[0,1,4]=={0,1,0}\n    // replace_en[1] = &plru_tree_q[ 3,~1,~0]; //plru_tree_q[0,1,3]=={0,0,1}\n    // replace_en[0] = &plru_tree_q[~3,~1,~0]; //plru_tree_q[0,1,3]=={0,0,0}\n    // For each entry traverse the tree. If every tree-node matches,\n    // the corresponding bit of the entry's index, this is\n    // the next entry to replace.\n    for (int unsigned i = 0; i < TLB_ENTRIES; i += 1) begin\n      automatic logic en;\n      automatic int unsigned idx_base, shift, new_index;\n      en = 1'b1;\n      for (int unsigned lvl = 0; lvl < $clog2(TLB_ENTRIES); lvl++) begin\n        idx_base = $unsigned((2 ** lvl) - 1);\n        // lvl0 <=> MSB, lvl1 <=> MSB-1, ...\n        shift = $clog2(TLB_ENTRIES) - lvl;\n\n        // en &= plru_tree_q[idx_base + (i>>shift)] == ((i >> (shift-1)) & 1'b1);\n        new_index = (i >> (shift - 1)) & 32'b1;\n        if (new_index[0]) begin\n          en &= plru_tree_q[idx_base+(i>>shift)];\n        end else begin\n          en &= ~plru_tree_q[idx_base+(i>>shift)];\n        end\n      end\n      replace_en[i] = en;\n    end\n  end\n\n  // sequential process\n  always_ff @(posedge clk_i or negedge rst_ni) begin\n    if (~rst_ni) begin\n      tags_q      <= '{default: 0};\n      content_q   <= '{default: 0};\n      plru_tree_q <= '{default: 0};\n    end else begin\n      tags_q      <= tags_n;\n      content_q   <= content_n;\n      plru_tree_q <= plru_tree_n;\n    end\n  end\n  //--------------\n  // Sanity checks\n  //--------------\n\n  //pragma translate_off\n`ifndef VERILATOR\n\n  initial begin : p_assertions\n    assert ((TLB_ENTRIES % 2 == 0) && (TLB_ENTRIES > 1))\n    else begin\n      $error(\"TLB size must be a multiple of 2 and greater than 1\");\n      $stop();\n    end\n    assert (ASID_WIDTH >= 1)\n    else begin\n      $error(\"ASID width must be at least 1\");\n      $stop();\n    end\n  end\n\n  // Just for checking\n  function int countSetBits(logic [TLB_ENTRIES-1:0] vector);\n    automatic int count = 0;\n    foreach (vector[idx]) begin\n      count += vector[idx];\n    end\n    return count;\n  endfunction\n\n  assert property (@(posedge clk_i) (countSetBits(lu_hit) <= 1))\n  else begin\n    $error(\"More then one hit in TLB!\");\n    $stop();\n  end\n  assert property (@(posedge clk_i) (countSetBits(replace_en) <= 1))\n  else begin\n    $error(\"More then one TLB entry selected for next replace!\");\n    $stop();\n  end\n\n`endif\n  //pragma translate_on\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 08.08.2018\n// Description: adapter module to connect the L1D$ and L1I$ to a 64bit AXI bus.\n//\n\n\nmodule wt_axi_adapter\n  import ariane_pkg::*;\n  import wt_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int unsigned ReqFifoDepth = 2,\n    parameter int unsigned MetaFifoDepth = wt_cache_pkg::DCACHE_MAX_TX,\n    parameter type axi_req_t = logic,\n    parameter type axi_rsp_t = logic\n) (\n    input logic clk_i,\n    input logic rst_ni,\n\n    // icache\n    input  logic         icache_data_req_i,\n    output logic         icache_data_ack_o,\n    input  icache_req_t  icache_data_i,\n    // returning packets must be consumed immediately\n    output logic         icache_rtrn_vld_o,\n    output icache_rtrn_t icache_rtrn_o,\n\n    // dcache\n    input  logic         dcache_data_req_i,\n    output logic         dcache_data_ack_o,\n    input  dcache_req_t  dcache_data_i,\n    // returning packets must be consumed immediately\n    output logic         dcache_rtrn_vld_o,\n    output dcache_rtrn_t dcache_rtrn_o,\n\n    // AXI port\n    output axi_req_t axi_req_o,\n    input  axi_rsp_t axi_resp_i,\n\n    // Invalidations\n    input  logic [63:0] inval_addr_i,\n    input  logic        inval_valid_i,\n    output logic        inval_ready_o\n);\n\n  // support up to 512bit cache lines\n  localparam AxiNumWords = (ariane_pkg::ICACHE_LINE_WIDTH/CVA6Cfg.AxiDataWidth) * (ariane_pkg::ICACHE_LINE_WIDTH > ariane_pkg::DCACHE_LINE_WIDTH)  +\n                           (ariane_pkg::DCACHE_LINE_WIDTH/CVA6Cfg.AxiDataWidth) * (ariane_pkg::ICACHE_LINE_WIDTH <= ariane_pkg::DCACHE_LINE_WIDTH) ;\n  localparam MaxNumWords = $clog2(CVA6Cfg.AxiDataWidth / 8);\n  localparam AxiRdBlenIcache = ariane_pkg::ICACHE_LINE_WIDTH / CVA6Cfg.AxiDataWidth - 1;\n  localparam AxiRdBlenDcache = ariane_pkg::DCACHE_LINE_WIDTH / CVA6Cfg.AxiDataWidth - 1;\n\n  ///////////////////////////////////////////////////////\n  // request path\n  ///////////////////////////////////////////////////////\n\n  icache_req_t icache_data;\n  logic icache_data_full, icache_data_empty;\n  dcache_req_t dcache_data;\n  logic dcache_data_full, dcache_data_empty;\n\n  logic [1:0] arb_req, arb_ack;\n  logic arb_idx, arb_gnt;\n\n  logic axi_rd_req, axi_rd_gnt;\n  logic axi_wr_req, axi_wr_gnt;\n  logic axi_wr_valid, axi_rd_valid, axi_rd_rdy, axi_wr_rdy;\n  logic axi_rd_lock, axi_wr_lock, axi_rd_exokay, axi_wr_exokay, wr_exokay;\n  logic [CVA6Cfg.AxiAddrWidth-1:0] axi_rd_addr, axi_wr_addr;\n  logic [$clog2(AxiNumWords)-1:0] axi_rd_blen, axi_wr_blen;\n  logic [2:0] axi_rd_size, axi_wr_size;\n  logic [CVA6Cfg.AxiIdWidth-1:0]\n      axi_rd_id_in, axi_wr_id_in, axi_rd_id_out, axi_wr_id_out, wr_id_out;\n  logic [AxiNumWords-1:0][CVA6Cfg.AxiDataWidth-1:0] axi_wr_data;\n  logic [AxiNumWords-1:0][CVA6Cfg.AxiUserWidth-1:0] axi_wr_user;\n  logic [CVA6Cfg.AxiDataWidth-1:0] axi_rd_data;\n  logic [CVA6Cfg.AxiUserWidth-1:0] axi_rd_user;\n  logic [AxiNumWords-1:0][(CVA6Cfg.AxiDataWidth/8)-1:0] axi_wr_be;\n  logic [5:0] axi_wr_atop;\n  logic invalidate;\n  logic [$clog2(CVA6Cfg.AxiDataWidth/8)-1:0] amo_off_d, amo_off_q;\n  // AMO generates r beat\n  logic amo_gen_r_d, amo_gen_r_q;\n\n  logic [wt_cache_pkg::CACHE_ID_WIDTH-1:0] icache_rtrn_tid_d, icache_rtrn_tid_q;\n  logic [wt_cache_pkg::CACHE_ID_WIDTH-1:0] dcache_rtrn_tid_d, dcache_rtrn_tid_q;\n  logic [wt_cache_pkg::CACHE_ID_WIDTH-1:0] dcache_rtrn_rd_tid, dcache_rtrn_wr_tid;\n  logic dcache_rd_pop, dcache_wr_pop;\n  logic icache_rd_full, icache_rd_empty;\n  logic dcache_rd_full, dcache_rd_empty;\n  logic dcache_wr_full, dcache_wr_empty;\n\n  assign icache_data_ack_o = icache_data_req_i & ~icache_data_full;\n  assign dcache_data_ack_o = dcache_data_req_i & ~dcache_data_full;\n\n  // arbiter\n  assign arb_req = {\n    ~(dcache_data_empty | dcache_wr_full | dcache_rd_full), ~(icache_data_empty | icache_rd_full)\n  };\n\n  assign arb_gnt = axi_rd_gnt | axi_wr_gnt;\n\n  rr_arb_tree #(\n      .NumIn    (2),\n      .DataWidth(1),\n      .AxiVldRdy(1'b1),\n      .LockIn   (1'b1)\n  ) i_rr_arb_tree (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i('0),\n      .rr_i   ('0),\n      .req_i  (arb_req),\n      .gnt_o  (arb_ack),\n      .data_i ('0),\n      .gnt_i  (arb_gnt),\n      .req_o  (),\n      .data_o (),\n      .idx_o  (arb_idx)\n  );\n\n  // request side\n  always_comb begin : p_axi_req\n    // write channel\n    axi_wr_id_in = {{CVA6Cfg.AxiIdWidth-1{1'b0}}, arb_idx};\n    axi_wr_data[0]  = {(CVA6Cfg.AxiDataWidth/riscv::XLEN){dcache_data.data}};\n    axi_wr_user[0]  = dcache_data.user;\n    // Cast to AXI address width\n    axi_wr_addr  = {{CVA6Cfg.AxiAddrWidth-riscv::PLEN{1'b0}}, dcache_data.paddr};\n    axi_wr_size  = dcache_data.size;\n    axi_wr_req   = 1'b0;\n    axi_wr_blen  = '0;// single word writes\n    axi_wr_be    = '0;\n    axi_wr_lock  = '0;\n    axi_wr_atop  = '0;\n    amo_off_d    = amo_off_q;\n    amo_gen_r_d  = amo_gen_r_q;\n\n    // read channel\n    axi_rd_id_in = {{CVA6Cfg.AxiIdWidth-1{1'b0}}, arb_idx};\n    axi_rd_req   = 1'b0;\n    axi_rd_lock  = '0;\n    axi_rd_blen  = '0;\n\n    if (dcache_data.paddr[2] == 1'b0) begin\n      axi_wr_user = {{64 - CVA6Cfg.AxiUserWidth{1'b0}}, dcache_data.user};\n    end else begin\n      axi_wr_user = {dcache_data.user, {64 - CVA6Cfg.AxiUserWidth{1'b0}}};\n    end\n\n    // arbiter mux\n    if (arb_idx) begin\n      // Cast to AXI address width\n      axi_rd_addr = {{CVA6Cfg.AxiAddrWidth - riscv::PLEN{1'b0}}, dcache_data.paddr};\n      // If dcache_data.size MSB is set, we want to read as much as possible\n      axi_rd_size = dcache_data.size[2] ? MaxNumWords[2:0] : dcache_data.size;\n      if (dcache_data.size[2]) begin\n        axi_rd_blen = AxiRdBlenDcache[$clog2(AxiNumWords)-1:0];\n      end\n    end else begin\n      // Cast to AXI address width\n      axi_rd_addr = {{CVA6Cfg.AxiAddrWidth - riscv::PLEN{1'b0}}, icache_data.paddr};\n      axi_rd_size = MaxNumWords[2:0];  // always request max number of words in case of ifill\n      if (!icache_data.nc) begin\n        axi_rd_blen = AxiRdBlenIcache[$clog2(AxiNumWords)-1:0];\n      end\n    end\n\n    // signal that an invalidation message\n    // needs to be generated\n    invalidate = 1'b0;\n\n    // decode message type\n    if (|arb_req) begin\n      if (arb_idx == 0) begin\n        //////////////////////////////////////\n        // IMISS\n        axi_rd_req = 1'b1;\n        //////////////////////////////////////\n      end else begin\n        unique case (dcache_data.rtype)\n          //////////////////////////////////////\n          wt_cache_pkg::DCACHE_LOAD_REQ: begin\n            axi_rd_req = 1'b1;\n          end\n          //////////////////////////////////////\n          wt_cache_pkg::DCACHE_STORE_REQ: begin\n            axi_wr_req = 1'b1;\n            axi_wr_be  = '0;\n            unique case (dcache_data.size[1:0])\n              2'b00:\n              axi_wr_be[0][dcache_data.paddr[$clog2(CVA6Cfg.AxiDataWidth/8)-1:0]] = '1;  // byte\n              2'b01:\n              axi_wr_be[0][dcache_data.paddr[$clog2(CVA6Cfg.AxiDataWidth/8)-1:0]+:2] = '1;  // hword\n              2'b10:\n              axi_wr_be[0][dcache_data.paddr[$clog2(CVA6Cfg.AxiDataWidth/8)-1:0]+:4] = '1;  // word\n              default:\n              if (riscv::IS_XLEN64)\n                axi_wr_be[0][dcache_data.paddr[$clog2(\n                    CVA6Cfg.AxiDataWidth/8\n                )-1:0]+:8] = '1;  // dword\n            endcase\n          end\n          //////////////////////////////////////\n          wt_cache_pkg::DCACHE_ATOMIC_REQ: begin\n            if (CVA6Cfg.RVA) begin\n              // default\n              // push back an invalidation here.\n              // since we only keep one read tx in flight, and since\n              // the dcache drains all writes/reads before executing\n              // an atomic, this is safe.\n              invalidate = arb_gnt;\n              axi_wr_req = 1'b1;\n              axi_wr_be  = '0;\n              unique case (dcache_data.size[1:0])\n                2'b00:\n                axi_wr_be[0][dcache_data.paddr[$clog2(CVA6Cfg.AxiDataWidth/8)-1:0]] = '1;  // byte\n                2'b01:\n                axi_wr_be[0][dcache_data.paddr[$clog2(CVA6Cfg.AxiDataWidth/8)-1:0]+:2] =\n                    '1;  // hword\n                2'b10:\n                axi_wr_be[0][dcache_data.paddr[$clog2(CVA6Cfg.AxiDataWidth/8)-1:0]+:4] =\n                    '1;  // word\n                default:\n                axi_wr_be[0][dcache_data.paddr[$clog2(CVA6Cfg.AxiDataWidth/8)-1:0]+:8] =\n                    '1;  // dword\n              endcase\n              amo_gen_r_d = 1'b1;\n              // need to use a separate ID here, so concat an additional bit\n              axi_wr_id_in[1] = 1'b1;\n\n              unique case (dcache_data.amo_op)\n                AMO_LR: begin\n                  axi_rd_lock     = 1'b1;\n                  axi_rd_req      = 1'b1;\n                  axi_rd_id_in[1] = 1'b1;\n                  // tie to zero in this special case\n                  axi_wr_req      = 1'b0;\n                  axi_wr_be       = '0;\n                end\n                AMO_SC: begin\n                  axi_wr_lock = 1'b1;\n                  amo_gen_r_d = 1'b0;\n                  // needed to properly encode success. store the result at offset within the returned\n                  // AXI data word aligned with the requested word size.\n                  amo_off_d = dcache_data.paddr[$clog2(CVA6Cfg.AxiDataWidth/8)-\n                                                1:0] & ~((1 << dcache_data.size[1:0]) - 1);\n                end\n                // RISC-V atops have a load semantic\n                AMO_SWAP: axi_wr_atop = axi_pkg::ATOP_ATOMICSWAP;\n                AMO_ADD:\n                axi_wr_atop = {\n                  axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_ADD\n                };\n                AMO_AND: begin\n                  // in this case we need to invert the data to get a \"CLR\"\n                  axi_wr_data[0] = ~{(CVA6Cfg.AxiDataWidth / riscv::XLEN) {dcache_data.data}};\n                  axi_wr_user = ~{(CVA6Cfg.AxiDataWidth / riscv::XLEN) {dcache_data.user}};\n                  axi_wr_atop = {\n                    axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_CLR\n                  };\n                end\n                AMO_OR:\n                axi_wr_atop = {\n                  axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_SET\n                };\n                AMO_XOR:\n                axi_wr_atop = {\n                  axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_EOR\n                };\n                AMO_MAX:\n                axi_wr_atop = {\n                  axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_SMAX\n                };\n                AMO_MAXU:\n                axi_wr_atop = {\n                  axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_UMAX\n                };\n                AMO_MIN:\n                axi_wr_atop = {\n                  axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_SMIN\n                };\n                AMO_MINU:\n                axi_wr_atop = {\n                  axi_pkg::ATOP_ATOMICLOAD, axi_pkg::ATOP_LITTLE_END, axi_pkg::ATOP_UMIN\n                };\n                default: ;  // Do nothing\n              endcase\n            end\n          end\n          default: ;  // Do nothing\n          //////////////////////////////////////\n        endcase\n      end\n    end\n  end\n\n  fifo_v3 #(\n      .dtype(icache_req_t),\n      .DEPTH(ReqFifoDepth)\n  ) i_icache_data_fifo (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .flush_i   (1'b0),\n      .testmode_i(1'b0),\n      .full_o    (icache_data_full),\n      .empty_o   (icache_data_empty),\n      .usage_o   (),\n      .data_i    (icache_data_i),\n      .push_i    (icache_data_ack_o),\n      .data_o    (icache_data),\n      .pop_i     (arb_ack[0])\n  );\n\n  fifo_v3 #(\n      .dtype(dcache_req_t),\n      .DEPTH(ReqFifoDepth)\n  ) i_dcache_data_fifo (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .flush_i   (1'b0),\n      .testmode_i(1'b0),\n      .full_o    (dcache_data_full),\n      .empty_o   (dcache_data_empty),\n      .usage_o   (),\n      .data_i    (dcache_data_i),\n      .push_i    (dcache_data_ack_o),\n      .data_o    (dcache_data),\n      .pop_i     (arb_ack[1])\n  );\n\n  ///////////////////////////////////////////////////////\n  // meta info feedback fifos\n  ///////////////////////////////////////////////////////\n\n  logic icache_rtrn_rd_en, dcache_rtrn_rd_en;\n  logic icache_rtrn_vld_d, icache_rtrn_vld_q, dcache_rtrn_vld_d, dcache_rtrn_vld_q;\n\n  fifo_v3 #(\n      .DATA_WIDTH(wt_cache_pkg::CACHE_ID_WIDTH),\n      .DEPTH     (MetaFifoDepth)\n  ) i_rd_icache_id (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .flush_i   (1'b0),\n      .testmode_i(1'b0),\n      .full_o    (icache_rd_full),\n      .empty_o   (icache_rd_empty),\n      .usage_o   (),\n      .data_i    (icache_data.tid),\n      .push_i    (arb_ack[0] & axi_rd_gnt),\n      .data_o    (icache_rtrn_tid_d),\n      .pop_i     (icache_rtrn_vld_d)\n  );\n\n  fifo_v3 #(\n      .DATA_WIDTH(wt_cache_pkg::CACHE_ID_WIDTH),\n      .DEPTH     (MetaFifoDepth)\n  ) i_rd_dcache_id (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .flush_i   (1'b0),\n      .testmode_i(1'b0),\n      .full_o    (dcache_rd_full),\n      .empty_o   (dcache_rd_empty),\n      .usage_o   (),\n      .data_i    (dcache_data.tid),\n      .push_i    (arb_ack[1] & axi_rd_gnt),\n      .data_o    (dcache_rtrn_rd_tid),\n      .pop_i     (dcache_rd_pop)\n  );\n\n  fifo_v3 #(\n      .DATA_WIDTH(wt_cache_pkg::CACHE_ID_WIDTH),\n      .DEPTH     (MetaFifoDepth)\n  ) i_wr_dcache_id (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .flush_i   (1'b0),\n      .testmode_i(1'b0),\n      .full_o    (dcache_wr_full),\n      .empty_o   (dcache_wr_empty),\n      .usage_o   (),\n      .data_i    (dcache_data.tid),\n      .push_i    (arb_ack[1] & axi_wr_gnt),\n      .data_o    (dcache_rtrn_wr_tid),\n      .pop_i     (dcache_wr_pop)\n  );\n\n  // select correct tid to return\n  assign dcache_rtrn_tid_d = (dcache_wr_pop) ? dcache_rtrn_wr_tid : dcache_rtrn_rd_tid;\n\n  ///////////////////////////////////////////////////////\n  // return path\n  ///////////////////////////////////////////////////////\n\n  // buffer write responses\n  logic b_full, b_empty, b_push, b_pop;\n  assign axi_wr_rdy = ~b_full;\n  assign b_push     = axi_wr_valid & axi_wr_rdy;\n\n  fifo_v3 #(\n      .DATA_WIDTH  (CVA6Cfg.AxiIdWidth + 1),\n      .DEPTH       (MetaFifoDepth),\n      .FALL_THROUGH(1'b1)\n  ) i_b_fifo (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .flush_i   (1'b0),\n      .testmode_i(1'b0),\n      .full_o    (b_full),\n      .empty_o   (b_empty),\n      .usage_o   (),\n      .data_i    ({axi_wr_exokay, axi_wr_id_out}),\n      .push_i    (b_push),\n      .data_o    ({wr_exokay, wr_id_out}),\n      .pop_i     (b_pop)\n  );\n\n  // buffer read responses in shift regs\n  logic icache_first_d, icache_first_q, dcache_first_d, dcache_first_q;\n  logic [ICACHE_USER_LINE_WIDTH/CVA6Cfg.AxiUserWidth-1:0][CVA6Cfg.AxiUserWidth-1:0]\n      icache_rd_shift_user_d, icache_rd_shift_user_q;\n  logic [DCACHE_USER_LINE_WIDTH/CVA6Cfg.AxiUserWidth-1:0][CVA6Cfg.AxiUserWidth-1:0]\n      dcache_rd_shift_user_d, dcache_rd_shift_user_q;\n  logic [ICACHE_LINE_WIDTH/CVA6Cfg.AxiDataWidth-1:0][CVA6Cfg.AxiDataWidth-1:0]\n      icache_rd_shift_d, icache_rd_shift_q;\n  logic [DCACHE_LINE_WIDTH/CVA6Cfg.AxiDataWidth-1:0][CVA6Cfg.AxiDataWidth-1:0]\n      dcache_rd_shift_d, dcache_rd_shift_q;\n  wt_cache_pkg::dcache_in_t dcache_rtrn_type_d, dcache_rtrn_type_q;\n  wt_cache_pkg::dcache_inval_t dcache_rtrn_inv_d, dcache_rtrn_inv_q;\n  logic dcache_sc_rtrn, axi_rd_last;\n\n  always_comb begin : p_axi_rtrn_shift\n    // output directly from regs\n    icache_rtrn_o          = '0;\n    icache_rtrn_o.rtype    = wt_cache_pkg::ICACHE_IFILL_ACK;\n    icache_rtrn_o.tid      = icache_rtrn_tid_q;\n    icache_rtrn_o.data     = icache_rd_shift_q;\n    icache_rtrn_o.user     = icache_rd_shift_user_q;\n    icache_rtrn_vld_o      = icache_rtrn_vld_q;\n\n    dcache_rtrn_o          = '0;\n    dcache_rtrn_o.rtype    = dcache_rtrn_type_q;\n    dcache_rtrn_o.inv      = dcache_rtrn_inv_q;\n    dcache_rtrn_o.tid      = dcache_rtrn_tid_q;\n    dcache_rtrn_o.data     = dcache_rd_shift_q;\n    dcache_rtrn_o.user     = dcache_rd_shift_user_q;\n    dcache_rtrn_vld_o      = dcache_rtrn_vld_q;\n\n    // read shift registers\n    icache_rd_shift_d      = icache_rd_shift_q;\n    icache_rd_shift_user_d = icache_rd_shift_user_q;\n    dcache_rd_shift_d      = dcache_rd_shift_q;\n    dcache_rd_shift_user_d = dcache_rd_shift_user_q;\n    icache_first_d         = icache_first_q;\n    dcache_first_d         = dcache_first_q;\n\n    if (icache_rtrn_rd_en) begin\n      icache_first_d = axi_rd_last;\n      if (ICACHE_LINE_WIDTH == CVA6Cfg.AxiDataWidth) begin\n        icache_rd_shift_d[0] = axi_rd_data;\n      end else begin\n        icache_rd_shift_d = {\n          axi_rd_data, icache_rd_shift_q[ICACHE_LINE_WIDTH/CVA6Cfg.AxiDataWidth-1:1]\n        };\n      end\n      icache_rd_shift_user_d = {\n        axi_rd_user, icache_rd_shift_user_q[ICACHE_USER_LINE_WIDTH/CVA6Cfg.AxiUserWidth-1:1]\n      };\n      // if this is a single word transaction, we need to make sure that word is placed at offset 0\n      if (icache_first_q) begin\n        icache_rd_shift_d[0] = axi_rd_data;\n        icache_rd_shift_user_d[0] = axi_rd_user;\n      end\n    end\n\n    if (dcache_rtrn_rd_en) begin\n      dcache_first_d = axi_rd_last;\n      if (DCACHE_LINE_WIDTH == CVA6Cfg.AxiDataWidth) begin\n        dcache_rd_shift_d[0] = axi_rd_data;\n      end else begin\n        dcache_rd_shift_d = {\n          axi_rd_data, dcache_rd_shift_q[DCACHE_LINE_WIDTH/CVA6Cfg.AxiDataWidth-1:1]\n        };\n      end\n      dcache_rd_shift_user_d = {\n        axi_rd_user, dcache_rd_shift_user_q[DCACHE_USER_LINE_WIDTH/CVA6Cfg.AxiUserWidth-1:1]\n      };\n      // if this is a single word transaction, we need to make sure that word is placed at offset 0\n      if (dcache_first_q) begin\n        dcache_rd_shift_d[0] = axi_rd_data;\n        dcache_rd_shift_user_d[0] = axi_rd_user;\n      end\n    end else if (CVA6Cfg.RVA && dcache_sc_rtrn) begin\n      // encode lr/sc success\n      dcache_rd_shift_d[0] = '0;\n      dcache_rd_shift_user_d[0] = '0;\n      dcache_rd_shift_d[0][amo_off_q*8] = (wr_exokay) ? '0 : 1'b1;\n      dcache_rd_shift_user_d[0][amo_off_q*8] = (wr_exokay) ? '0 : 1'b1;\n    end\n  end\n\n  // decode virtual read channels of icache\n  always_comb begin : p_axi_rtrn_decode\n    // we are not ready when invalidating\n    // note: b's are buffered separately\n    axi_rd_rdy        = ~invalidate;\n\n    icache_rtrn_rd_en = 1'b0;\n    icache_rtrn_vld_d = 1'b0;\n\n    // decode virtual icache channel,\n    // this is independent on dcache decoding below\n    if (axi_rd_valid && axi_rd_id_out == 0 && axi_rd_rdy) begin\n      icache_rtrn_rd_en = 1'b1;\n      icache_rtrn_vld_d = axi_rd_last;\n    end\n\n    dcache_rtrn_rd_en  = 1'b0;\n    dcache_rtrn_vld_d  = 1'b0;\n    dcache_rd_pop      = 1'b0;\n    dcache_wr_pop      = 1'b0;\n    dcache_rtrn_inv_d  = '0;\n    dcache_rtrn_type_d = wt_cache_pkg::DCACHE_LOAD_ACK;\n    b_pop              = 1'b0;\n    dcache_sc_rtrn     = 1'b0;\n\n    // External invalidation requests (from coprocessor). This is safe as\n    // there are no other transactions when a coprocessor has pending stores.\n    inval_rea"}
{"text": "dy_o      = 1'b0;\n    if (inval_valid_i) begin\n      inval_ready_o         = 1'b1;\n      dcache_rtrn_type_d    = wt_cache_pkg::DCACHE_INV_REQ;\n      dcache_rtrn_vld_d     = 1'b1;\n      dcache_rtrn_inv_d.all = 1'b1;\n      dcache_rtrn_inv_d.idx = inval_addr_i[ariane_pkg::DCACHE_INDEX_WIDTH-1:0];\n      //////////////////////////////////////\n      // dcache needs some special treatment\n      // for arbitration and decoding of atomics\n      //////////////////////////////////////\n      // this is safe, there is no other read tx in flight than this atomic.\n      // note that this self invalidation is handled in this way due to the\n      // write-through cache architecture, which is aligned with the openpiton\n      // cache subsystem.\n    end else if (CVA6Cfg.RVA && invalidate) begin\n      dcache_rtrn_type_d = wt_cache_pkg::DCACHE_INV_REQ;\n      dcache_rtrn_vld_d = 1'b1;\n\n      dcache_rtrn_inv_d.all = 1'b1;\n      dcache_rtrn_inv_d.idx = dcache_data.paddr[ariane_pkg::DCACHE_INDEX_WIDTH-1:0];\n      //////////////////////////////////////\n      // read responses\n      // note that in case of atomics, the dcache sequentializes requests and\n      // guarantees that there are no other pending transactions in flight\n    end else if (axi_rd_valid && axi_rd_id_out[0] && axi_rd_rdy) begin\n      dcache_rtrn_rd_en = 1'b1;\n      dcache_rtrn_vld_d = axi_rd_last;\n\n      // if this was an atomic op\n      if (CVA6Cfg.RVA && axi_rd_id_out[1]) begin\n        dcache_rtrn_type_d = wt_cache_pkg::DCACHE_ATOMIC_ACK;\n\n        // check if transaction was issued over write channel and pop that ID\n        if (!dcache_wr_empty) begin\n          dcache_wr_pop = axi_rd_last;\n          // if this is not the case, there MUST be an id in the read channel (LR)\n        end else begin\n          dcache_rd_pop = axi_rd_last;\n        end\n      end else begin\n        dcache_rd_pop = axi_rd_last;\n      end\n      //////////////////////////////////////\n      // write responses, check b fifo\n    end else if (!b_empty) begin\n      b_pop = 1'b1;\n\n      // this was an atomic\n      if (CVA6Cfg.RVA && wr_id_out[1]) begin\n        dcache_rtrn_type_d = wt_cache_pkg::DCACHE_ATOMIC_ACK;\n\n        // silently discard b response if we already popped the fifo\n        // with a R beat (iff the amo transaction generated an R beat)\n        if (!amo_gen_r_q) begin\n          dcache_rtrn_vld_d = 1'b1;\n          dcache_wr_pop     = 1'b1;\n          dcache_sc_rtrn    = 1'b1;\n        end\n      end else begin\n        // regular response\n        dcache_rtrn_type_d = wt_cache_pkg::DCACHE_STORE_ACK;\n        dcache_rtrn_vld_d  = 1'b1;\n        dcache_wr_pop      = 1'b1;\n      end\n    end\n    //////////////////////////////////////\n  end\n\n  // remote invalidations are not supported yet (this needs a cache coherence protocol)\n  // note that the atomic transactions would also need a \"master exclusive monitor\" in that case\n  // assign icache_rtrn_o.inv.idx  = '0;\n  // assign icache_rtrn_o.inv.way  = '0;\n  // assign icache_rtrn_o.inv.vld  = '0;\n  // assign icache_rtrn_o.inv.all  = '0;\n\n  // assign dcache_rtrn_o.inv.idx  = '0;\n  // assign dcache_rtrn_o.inv.way  = '0;\n  // assign dcache_rtrn_o.inv.vld  = '0;\n  // assign dcache_rtrn_o.inv.all  = '0;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : p_rd_buf\n    if (!rst_ni) begin\n      icache_first_q         <= 1'b1;\n      dcache_first_q         <= 1'b1;\n      icache_rd_shift_q      <= '0;\n      icache_rd_shift_user_q <= '0;\n      dcache_rd_shift_q      <= '0;\n      dcache_rd_shift_user_q <= '0;\n      icache_rtrn_vld_q      <= '0;\n      dcache_rtrn_vld_q      <= '0;\n      icache_rtrn_tid_q      <= '0;\n      dcache_rtrn_tid_q      <= '0;\n      dcache_rtrn_type_q     <= wt_cache_pkg::DCACHE_LOAD_ACK;\n      dcache_rtrn_inv_q      <= '0;\n      amo_off_q              <= '0;\n      amo_gen_r_q            <= 1'b0;\n    end else begin\n      icache_first_q         <= icache_first_d;\n      dcache_first_q         <= dcache_first_d;\n      icache_rd_shift_q      <= icache_rd_shift_d;\n      icache_rd_shift_user_q <= icache_rd_shift_user_d;\n      dcache_rd_shift_q      <= dcache_rd_shift_d;\n      dcache_rd_shift_user_q <= dcache_rd_shift_user_d;\n      icache_rtrn_vld_q      <= icache_rtrn_vld_d;\n      dcache_rtrn_vld_q      <= dcache_rtrn_vld_d;\n      icache_rtrn_tid_q      <= icache_rtrn_tid_d;\n      dcache_rtrn_tid_q      <= dcache_rtrn_tid_d;\n      dcache_rtrn_type_q     <= dcache_rtrn_type_d;\n      dcache_rtrn_inv_q      <= dcache_rtrn_inv_d;\n      amo_off_q              <= amo_off_d;\n      amo_gen_r_q            <= amo_gen_r_d;\n    end\n  end\n\n\n  ///////////////////////////////////////////////////////\n  // axi protocol shim\n  ///////////////////////////////////////////////////////\n\n  axi_shim #(\n      .CVA6Cfg    (CVA6Cfg),\n      .AxiNumWords(AxiNumWords),\n      .axi_req_t  (axi_req_t),\n      .axi_rsp_t  (axi_rsp_t)\n  ) i_axi_shim (\n      .clk_i      (clk_i),\n      .rst_ni     (rst_ni),\n      .rd_req_i   (axi_rd_req),\n      .rd_gnt_o   (axi_rd_gnt),\n      .rd_addr_i  (axi_rd_addr),\n      .rd_blen_i  (axi_rd_blen),\n      .rd_size_i  (axi_rd_size),\n      .rd_id_i    (axi_rd_id_in),\n      .rd_rdy_i   (axi_rd_rdy),\n      .rd_lock_i  (axi_rd_lock),\n      .rd_last_o  (axi_rd_last),\n      .rd_valid_o (axi_rd_valid),\n      .rd_data_o  (axi_rd_data),\n      .rd_user_o  (axi_rd_user),\n      .rd_id_o    (axi_rd_id_out),\n      .rd_exokay_o(axi_rd_exokay),\n      .wr_req_i   (axi_wr_req),\n      .wr_gnt_o   (axi_wr_gnt),\n      .wr_addr_i  (axi_wr_addr),\n      .wr_data_i  (axi_wr_data),\n      .wr_user_i  (axi_wr_user),\n      .wr_be_i    (axi_wr_be),\n      .wr_blen_i  (axi_wr_blen),\n      .wr_size_i  (axi_wr_size),\n      .wr_id_i    (axi_wr_id_in),\n      .wr_lock_i  (axi_wr_lock),\n      .wr_atop_i  (axi_wr_atop),\n      .wr_rdy_i   (axi_wr_rdy),\n      .wr_valid_o (axi_wr_valid),\n      .wr_id_o    (axi_wr_id_out),\n      .wr_exokay_o(axi_wr_exokay),\n      .axi_req_o  (axi_req_o),\n      .axi_resp_i (axi_resp_i)\n  );\n\n  ///////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////\n\n  //pragma translate_off\n`ifndef VERILATOR\n\n`endif\n  //pragma translate_on\n\nendmodule  // wt_l15_adapter\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 15.08.2018\n// Description: Package for OpenPiton compatible L1 cache subsystem\n\n// this is needed to propagate the\n// configuration in case Ariane is\n// instantiated in OpenPiton\n`ifdef PITON_ARIANE\n`include \"l15.tmp.h\"\n`include \"define.tmp.h\"\n`endif\n\npackage wt_cache_pkg;\n\n  // these parames need to coincide with the\n  // L1.5 parameterization, do not change\n`ifdef PITON_ARIANE\n\n`ifndef CONFIG_L15_ASSOCIATIVITY\n  `define CONFIG_L15_ASSOCIATIVITY 4\n`endif\n\n`ifndef TLB_CSM_WIDTH\n  `define TLB_CSM_WIDTH 33\n`endif\n\n  localparam L15_SET_ASSOC = `CONFIG_L15_ASSOCIATIVITY;\n  localparam L15_TLB_CSM_WIDTH = `TLB_CSM_WIDTH;\n`else\n  localparam L15_SET_ASSOC           = ariane_pkg::DCACHE_SET_ASSOC;// align with dcache for compatibility with the standard Ariane setup\n  localparam L15_TLB_CSM_WIDTH = 33;\n`endif\n  localparam L15_TID_WIDTH = ariane_pkg::MEM_TID_WIDTH;\n  localparam L15_WAY_WIDTH = $clog2(L15_SET_ASSOC);\n  localparam L1I_WAY_WIDTH = $clog2(ariane_pkg::ICACHE_SET_ASSOC);\n  localparam L1D_WAY_WIDTH = $clog2(ariane_pkg::DCACHE_SET_ASSOC);\n\n  // FIFO depths of L15 adapter\n  localparam ADAPTER_REQ_FIFO_DEPTH = 2;\n  localparam ADAPTER_RTRN_FIFO_DEPTH = 2;\n\n\n  // Calculated parameter\n  localparam ICACHE_OFFSET_WIDTH = $clog2(ariane_pkg::ICACHE_LINE_WIDTH / 8);\n  localparam ICACHE_NUM_WORDS = 2 ** (ariane_pkg::ICACHE_INDEX_WIDTH - ICACHE_OFFSET_WIDTH);\n  localparam ICACHE_CL_IDX_WIDTH = $clog2(ICACHE_NUM_WORDS);  // excluding byte offset\n\n  localparam DCACHE_OFFSET_WIDTH = $clog2(ariane_pkg::DCACHE_LINE_WIDTH / 8);\n  localparam DCACHE_NUM_WORDS = 2 ** (ariane_pkg::DCACHE_INDEX_WIDTH - DCACHE_OFFSET_WIDTH);\n  localparam DCACHE_CL_IDX_WIDTH = $clog2(DCACHE_NUM_WORDS);  // excluding byte offset\n\n  localparam DCACHE_NUM_BANKS = ariane_pkg::DCACHE_LINE_WIDTH / riscv::XLEN;\n  localparam DCACHE_NUM_BANKS_WIDTH = $clog2(DCACHE_NUM_BANKS);\n\n  // write buffer parameterization\n  localparam DCACHE_WBUF_DEPTH = ariane_pkg::WT_DCACHE_WBUF_DEPTH;\n  localparam DCACHE_MAX_TX = 2 ** L15_TID_WIDTH;\n  localparam CACHE_ID_WIDTH = L15_TID_WIDTH;\n\n\n  typedef struct packed {\n    logic [ariane_pkg::DCACHE_TAG_WIDTH+(ariane_pkg::DCACHE_INDEX_WIDTH-riscv::XLEN_ALIGN_BYTES)-1:0] wtag;\n    riscv::xlen_t data;\n    logic [ariane_pkg::DCACHE_USER_WIDTH-1:0] user;\n    logic [(riscv::XLEN/8)-1:0] dirty;  // byte is dirty\n    logic [(riscv::XLEN/8)-1:0] valid;  // byte is valid\n    logic [(riscv::XLEN/8)-1:0] txblock;  // byte is part of transaction in-flight\n    logic checked;  // if cache state of this word has been checked\n    logic [ariane_pkg::DCACHE_SET_ASSOC-1:0] hit_oh;  // valid way in the cache\n  } wbuffer_t;\n\n  // TX status registers are indexed with the transaction ID\n  // they basically store which bytes from which buffer entry are part\n  // of that transaction\n\n  typedef struct packed {\n    logic                                 vld;\n    logic [(riscv::XLEN/8)-1:0]           be;\n    logic [$clog2(DCACHE_WBUF_DEPTH)-1:0] ptr;\n  } tx_stat_t;\n\n  // local interfaces between caches and L15 adapter\n  typedef enum logic [1:0] {\n    DCACHE_STORE_REQ,\n    DCACHE_LOAD_REQ,\n    DCACHE_ATOMIC_REQ,\n    DCACHE_INT_REQ\n  } dcache_out_t;\n\n  typedef enum logic [2:0] {\n    DCACHE_INV_REQ,  // no ack from the core required\n    DCACHE_STORE_ACK,  // note: this may contain an invalidation vector, too\n    DCACHE_LOAD_ACK,\n    DCACHE_ATOMIC_ACK,\n    DCACHE_INT_ACK\n  } dcache_in_t;\n\n  typedef enum logic [0:0] {\n    ICACHE_INV_REQ,   // no ack from the core required\n    ICACHE_IFILL_ACK\n  } icache_in_t;\n\n  // icache interface\n  typedef struct packed {\n    logic                                      vld;  // invalidate only affected way\n    logic                                      all;  // invalidate all ways\n    logic [ariane_pkg::ICACHE_INDEX_WIDTH-1:0] idx;  // physical address to invalidate\n    logic [L1I_WAY_WIDTH-1:0]                  way;  // way to invalidate\n  } icache_inval_t;\n\n  typedef struct packed {\n    logic [$clog2(ariane_pkg::ICACHE_SET_ASSOC)-1:0] way;  // way to replace\n    logic [riscv::PLEN-1:0] paddr;  // physical address\n    logic nc;  // noncacheable\n    logic [CACHE_ID_WIDTH-1:0] tid;  // threadi id (used as transaction id in Ariane)\n  } icache_req_t;\n\n  typedef struct packed {\n    icache_in_t rtype;  // see definitions above\n    logic [ariane_pkg::ICACHE_LINE_WIDTH-1:0] data;  // full cache line width\n    logic [ariane_pkg::ICACHE_USER_LINE_WIDTH-1:0] user;  // user bits\n    icache_inval_t inv;  // invalidation vector\n    logic [CACHE_ID_WIDTH-1:0] tid;  // threadi id (used as transaction id in Ariane)\n  } icache_rtrn_t;\n\n  // dcache interface\n  typedef struct packed {\n    logic                                      vld;  // invalidate only affected way\n    logic                                      all;  // invalidate all ways\n    logic [ariane_pkg::DCACHE_INDEX_WIDTH-1:0] idx;  // physical address to invalidate\n    logic [L15_WAY_WIDTH-1:0]                  way;  // way to invalidate\n  } dcache_inval_t;\n\n  typedef struct packed {\n    dcache_out_t rtype;  // see definitions above\n    logic [2:0]                                      size;        // transaction size: 000=Byte 001=2Byte; 010=4Byte; 011=8Byte; 111=Cache line (16/32Byte)\n    logic [L1D_WAY_WIDTH-1:0] way;  // way to replace\n    logic [riscv::PLEN-1:0] paddr;  // physical address\n    riscv::xlen_t data;  // word width of processor (no block stores at the moment)\n    logic [ariane_pkg::DATA_USER_WIDTH-1:0]          user;        // user width of processor (no block stores at the moment)\n    logic nc;  // noncacheable\n    logic [CACHE_ID_WIDTH-1:0] tid;  // threadi id (used as transaction id in Ariane)\n    ariane_pkg::amo_t amo_op;  // amo opcode\n  } dcache_req_t;\n\n  typedef struct packed {\n    dcache_in_t rtype;  // see definitions above\n    logic [ariane_pkg::DCACHE_LINE_WIDTH-1:0] data;  // full cache line width\n    logic [ariane_pkg::DCACHE_USER_LINE_WIDTH-1:0] user;  // user bits\n    dcache_inval_t inv;  // invalidation vector\n    logic [CACHE_ID_WIDTH-1:0] tid;  // threadi id (used as transaction id in Ariane)\n  } dcache_rtrn_t;\n\n\n  // taken from iop.h in openpiton\n  // to l1.5 (only marked subset is used)\n  typedef enum logic [4:0] {\n    L15_LOAD_RQ    = 5'b00000,  // load request\n    L15_IMISS_RQ   = 5'b10000,  // instruction fill request\n    L15_STORE_RQ   = 5'b00001,  // store request\n    L15_ATOMIC_RQ  = 5'b00110,  // atomic op\n    //L15_CAS1_RQ     = 5'b00010, // compare and swap1 packet (OpenSparc atomics)\n    //L15_CAS2_RQ     = 5'b00011, // compare and swap2 packet (OpenSparc atomics)\n    //L15_SWAP_RQ     = 5'b00110, // swap packet (OpenSparc atomics)\n    L15_STRLOAD_RQ = 5'b00100,  // unused\n    L15_STRST_RQ   = 5'b00101,  // unused\n    L15_STQ_RQ     = 5'b00111,  // unused\n    L15_INT_RQ     = 5'b01001,  // interrupt request\n    L15_FWD_RQ     = 5'b01101,  // unused\n    L15_FWD_RPY    = 5'b01110,  // unused\n    L15_RSVD_RQ    = 5'b11111   // unused\n  } l15_reqtypes_t;\n\n  // from l1.5 (only marked subset is used)\n  typedef enum logic [3:0] {\n    L15_LOAD_RET               = 4'b0000,  // load packet\n    // L15_INV_RET                = 4'b0011, // invalidate packet, not unique...\n    L15_ST_ACK                 = 4'b0100,  // store ack packet\n    //L15_AT_ACK                 = 4'b0011, // unused, not unique...\n    L15_INT_RET                = 4'b0111,  // interrupt packet\n    L15_TEST_RET               = 4'b0101,  // unused\n    L15_FP_RET                 = 4'b1000,  // unused\n    L15_IFILL_RET              = 4'b0001,  // instruction fill packet\n    L15_EVICT_REQ              = 4'b0011,  // eviction request\n    L15_ERR_RET                = 4'b1100,  // unused\n    L15_STRLOAD_RET            = 4'b0010,  // unused\n    L15_STRST_ACK              = 4'b0110,  // unused\n    L15_FWD_RQ_RET             = 4'b1010,  // unused\n    L15_FWD_RPY_RET            = 4'b1011,  // unused\n    L15_RSVD_RET               = 4'b1111,  // unused\n    L15_CPX_RESTYPE_ATOMIC_RES = 4'b1110   // custom type for atomic responses\n  } l15_rtrntypes_t;\n\n\n  typedef struct packed {\n    logic l15_val;  // valid signal, asserted with request\n    logic l15_req_ack;  // ack for response\n    l15_reqtypes_t l15_rqtype;  // see below for encoding\n    logic l15_nc;  // non-cacheable bit\n    logic [2:0]                        l15_size;                  // transaction size: 000=Byte 001=2Byte; 010=4Byte; 011=8Byte; 111=Cache line (16/32Byte)\n    logic [L15_TID_WIDTH-1:0] l15_threadid;  // currently 0 or 1\n    logic l15_prefetch;  // unused in openpiton\n    logic l15_invalidate_cacheline;  // unused by Ariane as L1 has no ECC at the moment\n    logic l15_blockstore;  // unused in openpiton\n    logic l15_blockinitstore;  // unused in openpiton\n    logic [L15_WAY_WIDTH-1:0] l15_l1rplway;  // way to replace\n    logic [39:0] l15_address;  // physical address\n    logic [63:0] l15_data;  // word to write\n    logic [63:0] l15_data_next_entry;  // unused in Ariane (only used for CAS atomic requests)\n    logic [L15_TLB_CSM_WIDTH-1:0] l15_csm_data;  // unused in Ariane\n    logic [3:0] l15_amo_op;  // atomic operation type\n  } l15_req_t;\n\n  typedef struct packed {\n    logic l15_ack;  // ack for request struct\n    logic l15_header_ack;  // ack for request struct\n    logic l15_val;  // valid signal for return struct\n    l15_rtrntypes_t l15_returntype;  // see below for encoding\n    logic l15_l2miss;  // unused in Ariane\n    logic [1:0] l15_error;  // unused in openpiton\n    logic l15_noncacheable;  // non-cacheable bit\n    logic l15_atomic;  // asserted in load return and store ack packets of atomic tx\n    logic [L15_TID_WIDTH-1:0] l15_threadid;  // used as transaction ID\n    logic l15_prefetch;  // unused in openpiton\n    logic l15_f4b;  // 4byte instruction fill from I/O space (nc).\n    logic [63:0] l15_data_0;  // used for both caches\n    logic [63:0] l15_data_1;  // used for both caches\n    logic [63:0] l15_data_2;  // currently only used for I$\n    logic [63:0] l15_data_3;  // currently only used for I$\n    logic l15_inval_icache_all_way;  // invalidate all ways\n    logic l15_inval_dcache_all_way;  // unused in openpiton\n    logic [15:4] l15_inval_address_15_4;  // invalidate selected cacheline\n    logic l15_cross_invalidate;  // unused in openpiton\n    logic [L15_WAY_WIDTH-1:0] l15_cross_invalidate_way;  // unused in openpiton\n    logic l15_inval_dcache_inval;  // invalidate selected cacheline and way\n    logic l15_inval_icache_inval;  // unused in openpiton\n    logic [L15_WAY_WIDTH-1:0] l15_inval_way;  // way to invalidate\n    logic l15_blockinitstore;  // unused in openpiton\n  } l15_rtrn_t;\n\n  // swap endianess in a 64bit word\n  function automatic logic [63:0] swendian64(input logic [63:0] in);\n    automatic logic [63:0] out;\n    for (int k = 0; k < 64; k += 8) begin\n      out[k+:8] = in[63-k-:8];\n    end\n    return out;\n  endfunction\n\n  function automatic logic [5:0] popcnt64(input logic [63:0] in);\n    logic [5:0] cnt = 0;\n    foreach (in[k]) begin\n      cnt += 6'(in[k]);\n    end\n    return cnt;\n  endfunction : popcnt64\n\n  function automatic logic [(riscv::XLEN/8)-1:0] to_byte_enable8(\n      input logic [riscv::XLEN_ALIGN_BYTES-1:0] offset, input logic [1:0] size);\n    logic [(riscv::XLEN/8)-1:0] be;\n    be = '0;\n    unique case (size)\n      2'b00:   be[offset] = '1;  // byte\n      2'b01:   be[offset+:2] = '1;  // hword\n      2'b10:   be[offset+:4] = '1;  // word\n      default: be = '1;  // dword\n    endcase  // size\n    return be;\n  endfunction : to_byte_enable8\n\n  function automatic logic [(riscv::XLEN/8)-1:0] to_byte_enable4(\n      input logic [riscv::XLEN_ALIGN_BYTES-1:0] offset, input logic [1:0] size);\n    logic [3:0] be;\n    be = '0;\n    unique case (size)\n      2'b00:   be[offset] = '1;  // byte\n      2'b01:   be[offset+:2] = '1;  // hword\n      default: be = '1;  // word\n    endcase  // size\n    return be;\n  endfunction : to_byte_enable4\n\n  // openpiton requires the data to be replicated in case of smaller sizes than dwords\n  function automatic riscv::xlen_t repData64(input riscv::xlen_t data,\n                                             input logic [riscv::XLEN_ALIGN_BYTES-1:0] offset,\n                                             input logic [1:0] size);\n    riscv::xlen_t out;\n    unique case (size)\n      2'b00:   for (int k = 0; k < 8; k++) out[k*8+:8] = data[offset*8+:8];  // byte\n      2'b01:   for (int k = 0; k < 4; k++) out[k*16+:16] = data[offset*8+:16];  // hword\n      2'b10:   for (int k = 0; k < 2; k++) out[k*32+:32] = data[offset*8+:32];  // word\n      default: out = data;  // dword\n    endcase  // size\n    return out;\n  endfunction : repData64\n\n  function automatic riscv::xlen_t repData32(input riscv::xlen_t data,\n                                             input logic [riscv::XLEN_ALIGN_BYTES-1:0] offset,\n                                             input logic [1:0] size);\n    riscv::xlen_t out;\n    unique case (size)\n      2'b00:   for (int k = 0; k < 4; k++) out[k*8+:8] = data[offset*8+:8];  // byte\n      2'b01:   for (int k = 0; k < 2; k++) out[k*16+:16] = data[offset*8+:16];  // hword\n      default: out = data;  // word\n    endcase  // size\n    return out;\n  endfunction : repData32\n\n  // note: this is openpiton specific. cannot transmit unaligned words.\n  // hence we default to individual bytes in that case, and they have to be transmitted\n  // one after the other\n  function automatic logic [1:0] toSize64(input logic [7:0] be);\n    logic [1:0] size;\n    unique case (be)\n      8'b1111_1111:                                           size = 2'b11;  // dword\n      8'b0000_1111, 8'b1111_0000:                             size = 2'b10;  // word\n      8'b1100_0000, 8'b0011_0000, 8'b0000_1100, 8'b0000_0011: size = 2'b01;  // hword\n      default:                                                size = 2'b00;  // individual bytes\n    endcase  // be\n    return size;\n  endfunction : toSize64\n\n\n  function automatic logic [1:0] toSize32(input logic [3:0] be);\n    logic [1:0] size;\n    unique case (be)\n      4'b1111:          size = 2'b10;  // word\n      4'b1100, 4'b0011: size = 2'b01;  // hword\n      default:          size = 2'b00;  // individual bytes\n    endcase  // be\n    return size;\n  endfunction : toSize32\n\nendpackage\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 15.08.2018\n// Description: Ariane cache subsystem that is compatible with the OpenPiton\n//              coherent memory system.\n//\n//              Define PITON_ARIANE if you want to use this cache.\n//              Define DCACHE_TYPE if you want to use this cache\n//              with a standard 64 bit AXI interface instead of the OpenPiton\n//              L1.5 interface.\n\n\nmodule wt_cache_subsystem\n  import ariane_pkg::*;\n  import wt_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg    = config_pkg::cva6_cfg_empty,\n    parameter int unsigned           NumPorts   = 4,\n    parameter type                   noc_req_t  = logic,\n    parameter type                   noc_resp_t = logic\n) (\n    input logic clk_i,\n    input logic rst_ni,\n    // I$\n    input logic icache_en_i,  // enable icache (or bypass e.g: in debug mode)\n    input logic icache_flush_i,  // flush the icache, flush and kill have to be asserted together\n    output logic icache_miss_o,  // to performance counter\n    // address translation requests\n    input icache_areq_t icache_areq_i,  // to/from frontend\n    output icache_arsp_t icache_areq_o,\n    // data requests\n    input icache_dreq_t icache_dreq_i,  // to/from frontend\n    output icache_drsp_t icache_dreq_o,\n    // D$\n    // Cache management\n    input logic dcache_enable_i,  // from CSR\n    input logic dcache_flush_i,  // high until acknowledged\n    output logic                           dcache_flush_ack_o,     // send a single cycle acknowledge signal when the cache is flushed\n    output logic dcache_miss_o,  // we missed on a ld/st\n    // For Performance Counter\n    output logic [NumPorts-1:0][DCACHE_SET_ASSOC-1:0] miss_vld_bits_o,\n    // AMO interface\n    input amo_req_t dcache_amo_req_i,\n    output amo_resp_t dcache_amo_resp_o,\n    // Request ports\n    input dcache_req_i_t [NumPorts-1:0] dcache_req_ports_i,  // to/from LSU\n    output dcache_req_o_t [NumPorts-1:0] dcache_req_ports_o,  // to/from LSU\n    // writebuffer status\n    output logic wbuffer_empty_o,\n    output logic wbuffer_not_ni_o,\n    // memory side\n    output noc_req_t noc_req_o,\n    input noc_resp_t noc_resp_i,\n    // Invalidations\n    input logic [63:0] inval_addr_i,\n    input logic inval_valid_i,\n    output logic inval_ready_o\n    // TODO: interrupt interface\n);\n\n  logic icache_adapter_data_req, adapter_icache_data_ack, adapter_icache_rtrn_vld;\n  wt_cache_pkg::icache_req_t  icache_adapter;\n  wt_cache_pkg::icache_rtrn_t adapter_icache;\n\n\n  logic dcache_adapter_data_req, adapter_dcache_data_ack, adapter_dcache_rtrn_vld;\n  wt_cache_pkg::dcache_req_t  dcache_adapter;\n  wt_cache_pkg::dcache_rtrn_t adapter_dcache;\n\n  cva6_icache #(\n      // use ID 0 for icache reads\n      .CVA6Cfg(CVA6Cfg),\n      .RdTxId (0)\n  ) i_cva6_icache (\n      .clk_i         (clk_i),\n      .rst_ni        (rst_ni),\n      .flush_i       (icache_flush_i),\n      .en_i          (icache_en_i),\n      .miss_o        (icache_miss_o),\n      .areq_i        (icache_areq_i),\n      .areq_o        (icache_areq_o),\n      .dreq_i        (icache_dreq_i),\n      .dreq_o        (icache_dreq_o),\n      .mem_rtrn_vld_i(adapter_icache_rtrn_vld),\n      .mem_rtrn_i    (adapter_icache),\n      .mem_data_req_o(icache_adapter_data_req),\n      .mem_data_ack_i(adapter_icache_data_ack),\n      .mem_data_o    (icache_adapter)\n  );\n\n\n  // Note:\n  // Ports 0/1 for PTW and LD unit are read only.\n  // they have equal prio and are RR arbited\n  // Port 2 is write only and goes into the merging write buffer\n  wt_dcache #(\n      .CVA6Cfg  (CVA6Cfg),\n      // use ID 1 for dcache reads and amos. note that the writebuffer\n      // uses all IDs up to DCACHE_MAX_TX-1 for write transactions.\n      .RdAmoTxId(1)\n  ) i_wt_dcache (\n      .clk_i           (clk_i),\n      .rst_ni          (rst_ni),\n      .enable_i        (dcache_enable_i),\n      .flush_i         (dcache_flush_i),\n      .flush_ack_o     (dcache_flush_ack_o),\n      .miss_o          (dcache_miss_o),\n      .wbuffer_empty_o (wbuffer_empty_o),\n      .wbuffer_not_ni_o(wbuffer_not_ni_o),\n      .amo_req_i       (dcache_amo_req_i),\n      .amo_resp_o      (dcache_amo_resp_o),\n      .req_ports_i     (dcache_req_ports_i),\n      .req_ports_o     (dcache_req_ports_o),\n      .miss_vld_bits_o (miss_vld_bits_o),\n      .mem_rtrn_vld_i  (adapter_dcache_rtrn_vld),\n      .mem_rtrn_i      (adapter_dcache),\n      .mem_data_req_o  (dcache_adapter_data_req),\n      .mem_data_ack_i  (adapter_dcache_data_ack),\n      .mem_data_o      (dcache_adapter)\n  );\n\n\n  ///////////////////////////////////////////////////////\n  // memory plumbing, either use 64bit AXI port or native\n  // L15 cache interface (derived from OpenSPARC CCX).\n  ///////////////////////////////////////////////////////\n\n`ifdef PITON_ARIANE\n  wt_l15_adapter #(\n      .CVA6Cfg(CVA6Cfg),\n  ) i_adapter (\n      .clk_i            (clk_i),\n      .rst_ni           (rst_ni),\n      .icache_data_req_i(icache_adapter_data_req),\n      .icache_data_ack_o(adapter_icache_data_ack),\n      .icache_data_i    (icache_adapter),\n      .icache_rtrn_vld_o(adapter_icache_rtrn_vld),\n      .icache_rtrn_o    (adapter_icache),\n      .dcache_data_req_i(dcache_adapter_data_req),\n      .dcache_data_ack_o(adapter_dcache_data_ack),\n      .dcache_data_i    (dcache_adapter),\n      .dcache_rtrn_vld_o(adapter_dcache_rtrn_vld),\n      .dcache_rtrn_o    (adapter_dcache),\n      .l15_req_o        (noc_req_o),\n      .l15_rtrn_i       (noc_resp_i)\n  );\n`else\n  wt_axi_adapter #(\n      .CVA6Cfg  (CVA6Cfg),\n      .axi_req_t(noc_req_t),\n      .axi_rsp_t(noc_resp_t)\n  ) i_adapter (\n      .clk_i            (clk_i),\n      .rst_ni           (rst_ni),\n      .icache_data_req_i(icache_adapter_data_req),\n      .icache_data_ack_o(adapter_icache_data_ack),\n      .icache_data_i    (icache_adapter),\n      .icache_rtrn_vld_o(adapter_icache_rtrn_vld),\n      .icache_rtrn_o    (adapter_icache),\n      .dcache_data_req_i(dcache_adapter_data_req),\n      .dcache_data_ack_o(adapter_dcache_data_ack),\n      .dcache_data_i    (dcache_adapter),\n      .dcache_rtrn_vld_o(adapter_dcache_rtrn_vld),\n      .dcache_rtrn_o    (adapter_dcache),\n      .axi_req_o        (noc_req_o),\n      .axi_resp_i       (noc_resp_i),\n      .inval_addr_i     (inval_addr_i),\n      .inval_valid_i    (inval_valid_i),\n      .inval_ready_o    (inval_ready_o)\n  );\n`endif\n\n  ///////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////\n\n  //pragma translate_off\n`ifndef VERILATOR\n  a_invalid_instruction_fetch :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) icache_dreq_o.valid |-> (|icache_dreq_o.data) !== 1'hX)\n  else\n    $warning(\n        1,\n        \"[l1 dcache] reading invalid instructions: vaddr=%08X, data=%08X\",\n        icache_dreq_o.vaddr,\n        icache_dreq_o.data\n    );\n\n  for (genvar j = 0; j < riscv::XLEN / 8; j++) begin : gen_invalid_write_assertion\n    a_invalid_write_data :\n    assert property (\n      @(posedge clk_i) disable iff (!rst_ni) dcache_req_ports_i[NumPorts-1].data_req |-> dcache_req_ports_i[NumPorts-1].data_be[j] |-> (|dcache_req_ports_i[NumPorts-1].data_wdata[j*8+:8] !== 1'hX))\n    else\n      $warning(\n          1,\n          \"[l1 dcache] writing invalid data: paddr=%016X, be=%02X, data=%016X, databe=%016X\",\n          {\n            dcache_req_ports_i[NumPorts-1].address_tag, dcache_req_ports_i[NumPorts-1].address_index\n          },\n          dcache_req_ports_i[NumPorts-1].data_be,\n          dcache_req_ports_i[NumPorts-1].data_wdata,\n          dcache_req_ports_i[NumPorts-1].data_be & dcache_req_ports_i[NumPorts-1].data_wdata\n      );\n  end\n\n\n  for (genvar j = 0; j < NumPorts - 1; j++) begin : gen_assertion\n    a_invalid_read_data :\n    assert property (\n      @(posedge clk_i) disable iff (!rst_ni) dcache_req_ports_o[j].data_rvalid && ~dcache_req_ports_i[j].kill_req |-> (|dcache_req_ports_o[j].data_rdata) !== 1'hX)\n    else\n      $warning(\n          1,\n          \"[l1 dcache] reading invalid data on port %01d: data=%016X\",\n          j,\n          dcache_req_ports_o[j].data_rdata\n      );\n  end\n`endif\n  //pragma translate_on\n\n\nendmodule  // wt_cache_subsystem\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 13.09.2018\n// Description: Write-Through Data cache that is compatible with openpiton.\n\n\nmodule wt_dcache\n  import ariane_pkg::*;\n  import wt_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter int unsigned NumPorts = 4,  // number of miss ports\n    // ID to be used for read and AMO transactions.\n    // note that the write buffer uses all IDs up to DCACHE_MAX_TX-1 for write transactions\n    parameter logic [CACHE_ID_WIDTH-1:0] RdAmoTxId = 1\n) (\n    input logic clk_i,  // Clock\n    input logic rst_ni, // Asynchronous reset active low\n\n    // Cache management\n    input logic enable_i,  // from CSR\n    input logic flush_i,  // high until acknowledged\n    output logic flush_ack_o,  // send a single cycle acknowledge signal when the cache is flushed\n    output logic miss_o,  // we missed on a ld/st\n    output logic wbuffer_empty_o,\n    output logic wbuffer_not_ni_o,\n\n    // AMO interface\n    input  amo_req_t  amo_req_i,\n    output amo_resp_t amo_resp_o,\n\n    // Request ports\n    input  dcache_req_i_t [NumPorts-1:0] req_ports_i,\n    output dcache_req_o_t [NumPorts-1:0] req_ports_o,\n\n    output logic [NumPorts-1:0][DCACHE_SET_ASSOC-1:0] miss_vld_bits_o,\n\n    input  logic         mem_rtrn_vld_i,\n    input  dcache_rtrn_t mem_rtrn_i,\n    output logic         mem_data_req_o,\n    input  logic         mem_data_ack_i,\n    output dcache_req_t  mem_data_o\n);\n\n  // miss unit <-> read controllers\n  logic                                                               cache_en;\n\n  // miss unit <-> memory\n  logic                                                               wr_cl_vld;\n  logic                                                               wr_cl_nc;\n  logic         [      DCACHE_SET_ASSOC-1:0]                          wr_cl_we;\n  logic         [      DCACHE_TAG_WIDTH-1:0]                          wr_cl_tag;\n  logic         [   DCACHE_CL_IDX_WIDTH-1:0]                          wr_cl_idx;\n  logic         [   DCACHE_OFFSET_WIDTH-1:0]                          wr_cl_off;\n  logic         [     DCACHE_LINE_WIDTH-1:0]                          wr_cl_data;\n  logic         [DCACHE_USER_LINE_WIDTH-1:0]                          wr_cl_user;\n  logic         [   DCACHE_LINE_WIDTH/8-1:0]                          wr_cl_data_be;\n  logic         [      DCACHE_SET_ASSOC-1:0]                          wr_vld_bits;\n  logic         [      DCACHE_SET_ASSOC-1:0]                          wr_req;\n  logic                                                               wr_ack;\n  logic         [   DCACHE_CL_IDX_WIDTH-1:0]                          wr_idx;\n  logic         [   DCACHE_OFFSET_WIDTH-1:0]                          wr_off;\n  riscv::xlen_t                                                       wr_data;\n  logic         [       (riscv::XLEN/8)-1:0]                          wr_data_be;\n  logic         [     DCACHE_USER_WIDTH-1:0]                          wr_user;\n\n  // miss unit <-> controllers/wbuffer\n  logic         [              NumPorts-1:0]                          miss_req;\n  logic         [              NumPorts-1:0]                          miss_ack;\n  logic         [              NumPorts-1:0]                          miss_nc;\n  logic         [              NumPorts-1:0]                          miss_we;\n  logic         [              NumPorts-1:0][        riscv::XLEN-1:0] miss_wdata;\n  logic         [              NumPorts-1:0][  DCACHE_USER_WIDTH-1:0] miss_wuser;\n  logic         [              NumPorts-1:0][        riscv::PLEN-1:0] miss_paddr;\n  logic         [              NumPorts-1:0][                    2:0] miss_size;\n  logic         [              NumPorts-1:0][     CACHE_ID_WIDTH-1:0] miss_id;\n  logic         [              NumPorts-1:0]                          miss_replay;\n  logic         [              NumPorts-1:0]                          miss_rtrn_vld;\n  logic         [        CACHE_ID_WIDTH-1:0]                          miss_rtrn_id;\n\n  // memory <-> read controllers/miss unit\n  logic         [              NumPorts-1:0]                          rd_prio;\n  logic         [              NumPorts-1:0]                          rd_tag_only;\n  logic         [              NumPorts-1:0]                          rd_req;\n  logic         [              NumPorts-1:0]                          rd_ack;\n  logic         [              NumPorts-1:0][   DCACHE_TAG_WIDTH-1:0] rd_tag;\n  logic         [              NumPorts-1:0][DCACHE_CL_IDX_WIDTH-1:0] rd_idx;\n  logic         [              NumPorts-1:0][DCACHE_OFFSET_WIDTH-1:0] rd_off;\n  riscv::xlen_t                                                       rd_data;\n  logic         [     DCACHE_USER_WIDTH-1:0]                          rd_user;\n  logic         [      DCACHE_SET_ASSOC-1:0]                          rd_vld_bits;\n  logic         [      DCACHE_SET_ASSOC-1:0]                          rd_hit_oh;\n\n  // miss unit <-> wbuffer\n  logic         [         DCACHE_MAX_TX-1:0][        riscv::PLEN-1:0] tx_paddr;\n  logic         [         DCACHE_MAX_TX-1:0]                          tx_vld;\n\n  // wbuffer <-> memory\n  wbuffer_t     [     DCACHE_WBUF_DEPTH-1:0]                          wbuffer_data;\n\n\n  ///////////////////////////////////////////////////////\n  // miss handling unit\n  ///////////////////////////////////////////////////////\n\n  wt_dcache_missunit #(\n      .CVA6Cfg (CVA6Cfg),\n      .AmoTxId (RdAmoTxId),\n      .NumPorts(NumPorts)\n  ) i_wt_dcache_missunit (\n      .clk_i          (clk_i),\n      .rst_ni         (rst_ni),\n      .enable_i       (enable_i),\n      .flush_i        (flush_i),\n      .flush_ack_o    (flush_ack_o),\n      .miss_o         (miss_o),\n      .wbuffer_empty_i(wbuffer_empty_o),\n      .cache_en_o     (cache_en),\n      // amo interface\n      .amo_req_i      (amo_req_i),\n      .amo_resp_o     (amo_resp_o),\n      // miss handling interface\n      .miss_req_i     (miss_req),\n      .miss_ack_o     (miss_ack),\n      .miss_nc_i      (miss_nc),\n      .miss_we_i      (miss_we),\n      .miss_wdata_i   (miss_wdata),\n      .miss_wuser_i   (miss_wuser),\n      .miss_paddr_i   (miss_paddr),\n      .miss_vld_bits_i(miss_vld_bits_o),\n      .miss_size_i    (miss_size),\n      .miss_id_i      (miss_id),\n      .miss_replay_o  (miss_replay),\n      .miss_rtrn_vld_o(miss_rtrn_vld),\n      .miss_rtrn_id_o (miss_rtrn_id),\n      // from writebuffer\n      .tx_paddr_i     (tx_paddr),\n      .tx_vld_i       (tx_vld),\n      // cache memory interface\n      .wr_cl_vld_o    (wr_cl_vld),\n      .wr_cl_nc_o     (wr_cl_nc),\n      .wr_cl_we_o     (wr_cl_we),\n      .wr_cl_tag_o    (wr_cl_tag),\n      .wr_cl_idx_o    (wr_cl_idx),\n      .wr_cl_off_o    (wr_cl_off),\n      .wr_cl_data_o   (wr_cl_data),\n      .wr_cl_user_o   (wr_cl_user),\n      .wr_cl_data_be_o(wr_cl_data_be),\n      .wr_vld_bits_o  (wr_vld_bits),\n      // memory interface\n      .mem_rtrn_vld_i (mem_rtrn_vld_i),\n      .mem_rtrn_i     (mem_rtrn_i),\n      .mem_data_req_o (mem_data_req_o),\n      .mem_data_ack_i (mem_data_ack_i),\n      .mem_data_o     (mem_data_o)\n  );\n\n  ///////////////////////////////////////////////////////\n  // read controllers (LD unit and PTW/MMU)\n  ///////////////////////////////////////////////////////\n\n  // 0 is used by MMU, 1 by READ access requests\n  for (genvar k = 0; k < NumPorts - 1; k++) begin : gen_rd_ports\n    // set these to high prio ports\n    if ((k == 0 && MMU_PRESENT) || (k == 1) || (k == 2 && CVA6Cfg.EnableAccelerator)) begin\n      assign rd_prio[k] = 1'b1;\n      wt_dcache_ctrl #(\n          .CVA6Cfg(CVA6Cfg),\n          .RdTxId (RdAmoTxId)\n      ) i_wt_dcache_ctrl (\n          .clk_i          (clk_i),\n          .rst_ni         (rst_ni),\n          .cache_en_i     (cache_en),\n          // reqs from core\n          .req_port_i     (req_ports_i[k]),\n          .req_port_o     (req_ports_o[k]),\n          // miss interface\n          .miss_req_o     (miss_req[k]),\n          .miss_ack_i     (miss_ack[k]),\n          .miss_we_o      (miss_we[k]),\n          .miss_wdata_o   (miss_wdata[k]),\n          .miss_wuser_o   (miss_wuser[k]),\n          .miss_vld_bits_o(miss_vld_bits_o[k]),\n          .miss_paddr_o   (miss_paddr[k]),\n          .miss_nc_o      (miss_nc[k]),\n          .miss_size_o    (miss_size[k]),\n          .miss_id_o      (miss_id[k]),\n          .miss_replay_i  (miss_replay[k]),\n          .miss_rtrn_vld_i(miss_rtrn_vld[k]),\n          // used to detect readout mux collisions\n          .wr_cl_vld_i    (wr_cl_vld),\n          // cache mem interface\n          .rd_tag_o       (rd_tag[k]),\n          .rd_idx_o       (rd_idx[k]),\n          .rd_off_o       (rd_off[k]),\n          .rd_req_o       (rd_req[k]),\n          .rd_tag_only_o  (rd_tag_only[k]),\n          .rd_ack_i       (rd_ack[k]),\n          .rd_data_i      (rd_data),\n          .rd_user_i      (rd_user),\n          .rd_vld_bits_i  (rd_vld_bits),\n          .rd_hit_oh_i    (rd_hit_oh)\n      );\n    end else begin\n      assign rd_prio[k] = 1'b0;\n      assign req_ports_o[k] = '0;\n      assign miss_req[k] = 1'b0;\n      assign miss_we[k] = 1'b0;\n      assign miss_wdata[k] = {{riscv::XLEN} {1'b0}};\n      assign miss_wuser[k] = {{DCACHE_USER_WIDTH} {1'b0}};\n      assign miss_vld_bits_o[k] = {{DCACHE_SET_ASSOC} {1'b0}};\n      assign miss_paddr[k] = {{riscv::PLEN} {1'b0}};\n      assign miss_nc[k] = 1'b0;\n      assign miss_size[k] = 3'b0;\n      assign miss_id[k] = {{CACHE_ID_WIDTH} {1'b0}};\n      assign rd_tag[k] = {{DCACHE_TAG_WIDTH} {1'b0}};\n      assign rd_idx[k] = {{DCACHE_CL_IDX_WIDTH} {1'b0}};\n      assign rd_off[k] = {{DCACHE_OFFSET_WIDTH} {1'b0}};\n      assign rd_req[k] = 1'b0;\n      assign rd_tag_only[k] = 1'b0;\n    end\n  end\n\n  ///////////////////////////////////////////////////////\n  // store unit controller\n  ///////////////////////////////////////////////////////\n\n  // set read port to low priority\n  assign rd_prio[NumPorts-1] = 1'b0;\n\n  wt_dcache_wbuffer #(\n      .CVA6Cfg(CVA6Cfg)\n  ) i_wt_dcache_wbuffer (\n      .clk_i          (clk_i),\n      .rst_ni         (rst_ni),\n      .empty_o        (wbuffer_empty_o),\n      .not_ni_o       (wbuffer_not_ni_o),\n      // TODO: fix this\n      .cache_en_i     (cache_en),\n      // .cache_en_i      ( '0                  ),\n      // request ports from core (store unit)\n      .req_port_i     (req_ports_i[NumPorts-1]),\n      .req_port_o     (req_ports_o[NumPorts-1]),\n      // miss unit interface\n      .miss_req_o     (miss_req[NumPorts-1]),\n      .miss_ack_i     (miss_ack[NumPorts-1]),\n      .miss_we_o      (miss_we[NumPorts-1]),\n      .miss_wdata_o   (miss_wdata[NumPorts-1]),\n      .miss_wuser_o   (miss_wuser[NumPorts-1]),\n      .miss_vld_bits_o(miss_vld_bits_o[NumPorts-1]),\n      .miss_paddr_o   (miss_paddr[NumPorts-1]),\n      .miss_nc_o      (miss_nc[NumPorts-1]),\n      .miss_size_o    (miss_size[NumPorts-1]),\n      .miss_id_o      (miss_id[NumPorts-1]),\n      .miss_rtrn_vld_i(miss_rtrn_vld[NumPorts-1]),\n      .miss_rtrn_id_i (miss_rtrn_id),\n      // cache read interface\n      .rd_tag_o       (rd_tag[NumPorts-1]),\n      .rd_idx_o       (rd_idx[NumPorts-1]),\n      .rd_off_o       (rd_off[NumPorts-1]),\n      .rd_req_o       (rd_req[NumPorts-1]),\n      .rd_tag_only_o  (rd_tag_only[NumPorts-1]),\n      .rd_ack_i       (rd_ack[NumPorts-1]),\n      .rd_data_i      (rd_data),\n      .rd_vld_bits_i  (rd_vld_bits),\n      .rd_hit_oh_i    (rd_hit_oh),\n      // incoming invalidations/cache refills\n      .wr_cl_vld_i    (wr_cl_vld),\n      .wr_cl_idx_i    (wr_cl_idx),\n      // single word write interface\n      .wr_req_o       (wr_req),\n      .wr_ack_i       (wr_ack),\n      .wr_idx_o       (wr_idx),\n      .wr_off_o       (wr_off),\n      .wr_data_o      (wr_data),\n      .wr_user_o      (wr_user),\n      .wr_data_be_o   (wr_data_be),\n      // write buffer forwarding\n      .wbuffer_data_o (wbuffer_data),\n      .tx_paddr_o     (tx_paddr),\n      .tx_vld_o       (tx_vld)\n  );\n\n  ///////////////////////////////////////////////////////\n  // memory arrays, arbitration and tag comparison\n  ///////////////////////////////////////////////////////\n\n  wt_dcache_mem #(\n      .CVA6Cfg (CVA6Cfg),\n      .NumPorts(NumPorts)\n  ) i_wt_dcache_mem (\n      .clk_i          (clk_i),\n      .rst_ni         (rst_ni),\n      // read ports\n      .rd_prio_i      (rd_prio),\n      .rd_tag_i       (rd_tag),\n      .rd_idx_i       (rd_idx),\n      .rd_off_i       (rd_off),\n      .rd_req_i       (rd_req),\n      .rd_tag_only_i  (rd_tag_only),\n      .rd_ack_o       (rd_ack),\n      .rd_vld_bits_o  (rd_vld_bits),\n      .rd_hit_oh_o    (rd_hit_oh),\n      .rd_data_o      (rd_data),\n      .rd_user_o      (rd_user),\n      // cacheline write port\n      .wr_cl_vld_i    (wr_cl_vld),\n      .wr_cl_nc_i     (wr_cl_nc),\n      .wr_cl_we_i     (wr_cl_we),\n      .wr_cl_tag_i    (wr_cl_tag),\n      .wr_cl_idx_i    (wr_cl_idx),\n      .wr_cl_off_i    (wr_cl_off),\n      .wr_cl_data_i   (wr_cl_data),\n      .wr_cl_user_i   (wr_cl_user),\n      .wr_cl_data_be_i(wr_cl_data_be),\n      .wr_vld_bits_i  (wr_vld_bits),\n      // single word write port\n      .wr_req_i       (wr_req),\n      .wr_ack_o       (wr_ack),\n      .wr_idx_i       (wr_idx),\n      .wr_off_i       (wr_off),\n      .wr_data_i      (wr_data),\n      .wr_user_i      (wr_user),\n      .wr_data_be_i   (wr_data_be),\n      // write buffer forwarding\n      .wbuffer_data_i (wbuffer_data)\n  );\n\n  ///////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////\n\n  // check for concurrency issues\n\n\n  //pragma translate_off\n`ifndef VERILATOR\n  flush :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) flush_i |-> flush_ack_o |-> wbuffer_empty_o)\n  else $fatal(1, \"[l1 dcache] flushed cache implies flushed wbuffer\");\n\n  initial begin\n    // assert wrong parameterizations\n    assert (DCACHE_INDEX_WIDTH <= 12)\n    else $fatal(1, \"[l1 dcache] cache index width can be maximum 12bit since VM uses 4kB pages\");\n  end\n`endif\n  //pragma translate_on\n\nendmodule  // wt_dcache\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 13.09.2018\n// Description: DCache controller for read port\n\n\nmodule wt_dcache_ctrl\n  import ariane_pkg::*;\n  import wt_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter logic [CACHE_ID_WIDTH-1:0]  RdTxId    = 1\n) (\n    input logic clk_i,  // Clock\n    input logic rst_ni,  // Asynchronous reset active low\n    input logic cache_en_i,\n    // core request ports\n    input dcache_req_i_t req_port_i,\n    output dcache_req_o_t req_port_o,\n    // interface to miss handler\n    output logic miss_req_o,\n    input logic miss_ack_i,\n    output logic miss_we_o,  // unused (set to 0)\n    output riscv::xlen_t miss_wdata_o,  // unused (set to 0)\n    output logic [DCACHE_USER_WIDTH-1:0] miss_wuser_o,  // unused (set to 0)\n    output logic [DCACHE_SET_ASSOC-1:0] miss_vld_bits_o,  // valid bits at the missed index\n    output logic [riscv::PLEN-1:0] miss_paddr_o,\n    output logic miss_nc_o,  // request to I/O space\n    output logic [2:0] miss_size_o,  // 00: 1byte, 01: 2byte, 10: 4byte, 11: 8byte, 111: cacheline\n    output logic [CACHE_ID_WIDTH-1:0] miss_id_o,  // set to constant ID\n    input logic miss_replay_i,  // request collided with pending miss - have to replay the request\n    input  logic                            miss_rtrn_vld_i, // signals that the miss has been served, asserted in the same cycle as when the data returns from memory\n    // used to detect readout mux collisions\n    input logic wr_cl_vld_i,\n    // cache memory interface\n    output logic [DCACHE_TAG_WIDTH-1:0] rd_tag_o,  // tag in - comes one cycle later\n    output logic [DCACHE_CL_IDX_WIDTH-1:0] rd_idx_o,\n    output logic [DCACHE_OFFSET_WIDTH-1:0] rd_off_o,\n    output logic rd_req_o,  // read the word at offset off_i[:3] in all ways\n    output logic rd_tag_only_o,  // set to zero here\n    input logic rd_ack_i,\n    input riscv::xlen_t rd_data_i,\n    input logic [DCACHE_USER_WIDTH-1:0] rd_user_i,\n    input logic [DCACHE_SET_ASSOC-1:0] rd_vld_bits_i,\n    input logic [DCACHE_SET_ASSOC-1:0] rd_hit_oh_i\n);\n\n  // controller FSM\n  typedef enum logic [2:0] {\n    IDLE,\n    READ,\n    MISS_REQ,\n    MISS_WAIT,\n    KILL_MISS,\n    KILL_MISS_ACK,\n    REPLAY_REQ,\n    REPLAY_READ\n  } state_e;\n  state_e state_d, state_q;\n\n  logic [DCACHE_TAG_WIDTH-1:0] address_tag_d, address_tag_q;\n  logic [DCACHE_CL_IDX_WIDTH-1:0] address_idx_d, address_idx_q;\n  logic [DCACHE_OFFSET_WIDTH-1:0] address_off_d, address_off_q;\n  logic [DCACHE_TID_WIDTH-1:0] id_d, id_q;\n  logic [DCACHE_SET_ASSOC-1:0] vld_data_d, vld_data_q;\n  logic save_tag, rd_req_d, rd_req_q, rd_ack_d, rd_ack_q;\n  logic [1:0] data_size_d, data_size_q;\n\n  ///////////////////////////////////////////////////////\n  // misc\n  ///////////////////////////////////////////////////////\n\n  // map address to tag/idx/offset and save\n  assign vld_data_d = (rd_req_q) ? rd_vld_bits_i : vld_data_q;\n  assign address_tag_d = (save_tag) ? req_port_i.address_tag : address_tag_q;\n  assign address_idx_d = (req_port_o.data_gnt) ? req_port_i.address_index[DCACHE_INDEX_WIDTH-1:DCACHE_OFFSET_WIDTH] : address_idx_q;\n  assign address_off_d = (req_port_o.data_gnt) ? req_port_i.address_index[DCACHE_OFFSET_WIDTH-1:0]                  : address_off_q;\n  assign id_d = (req_port_o.data_gnt) ? req_port_i.data_id : id_q;\n  assign data_size_d = (req_port_o.data_gnt) ? req_port_i.data_size : data_size_q;\n  assign rd_tag_o = address_tag_d;\n  assign rd_idx_o = address_idx_d;\n  assign rd_off_o = address_off_d;\n\n  assign req_port_o.data_rdata = rd_data_i;\n  assign req_port_o.data_ruser = rd_user_i;\n  assign req_port_o.data_rid = id_q;\n\n  // to miss unit\n  assign miss_vld_bits_o = vld_data_q;\n  assign miss_paddr_o = {address_tag_q, address_idx_q, address_off_q};\n  assign miss_size_o = (miss_nc_o) ? {1'b0, data_size_q} : 3'b111;\n\n  // noncacheable if request goes to I/O space, or if cache is disabled\n  assign miss_nc_o = (~cache_en_i) | (~config_pkg::is_inside_cacheable_regions(\n      CVA6Cfg,\n      {{{64-DCACHE_TAG_WIDTH-DCACHE_INDEX_WIDTH}{1'b0}}, address_tag_q, {DCACHE_INDEX_WIDTH{1'b0}}}\n  ));\n\n\n  assign miss_we_o = '0;\n  assign miss_wdata_o = '0;\n  assign miss_wuser_o = '0;\n  assign miss_id_o = RdTxId;\n  assign rd_req_d = rd_req_o;\n  assign rd_ack_d = rd_ack_i;\n  assign rd_tag_only_o = '0;\n\n  ///////////////////////////////////////////////////////\n  // main control logic\n  ///////////////////////////////////////////////////////\n\n  always_comb begin : p_fsm\n    // default assignment\n    state_d                = state_q;\n    save_tag               = 1'b0;\n    rd_req_o               = 1'b0;\n    miss_req_o             = 1'b0;\n    req_port_o.data_rvalid = 1'b0;\n    req_port_o.data_gnt    = 1'b0;\n\n    // interfaces\n    unique case (state_q)\n      //////////////////////////////////\n      // wait for an incoming request\n      IDLE: begin\n        if (req_port_i.data_req) begin\n          rd_req_o = 1'b1;\n          // if read ack then ack the `req_port_o`, and goto `READ` state\n          if (rd_ack_i) begin\n            state_d = READ;\n            req_port_o.data_gnt = 1'b1;\n          end\n        end\n      end\n      //////////////////////////////////\n      // check whether we have a hit\n      // in case the cache is disabled,\n      // or in case the address is NC, we\n      // reuse the miss mechanism to handle\n      // the request\n      READ, REPLAY_READ: begin\n        // speculatively request cache line\n        rd_req_o = 1'b1;\n\n        // kill -> go back to IDLE\n        if (req_port_i.kill_req) begin\n          state_d = IDLE;\n          req_port_o.data_rvalid = 1'b1;\n        end else if (req_port_i.tag_valid | state_q == REPLAY_READ) begin\n          save_tag = (state_q != REPLAY_READ);\n          if (wr_cl_vld_i || !rd_ack_q) begin\n            state_d = REPLAY_REQ;\n            // we've got a hit\n          end else if ((|rd_hit_oh_i) && cache_en_i) begin\n            state_d = IDLE;\n            req_port_o.data_rvalid = 1'b1;\n            // we can handle another request\n            if (rd_ack_i && req_port_i.data_req) begin\n              state_d = READ;\n              req_port_o.data_gnt = 1'b1;\n            end\n            // we've got a miss\n          end else begin\n            state_d = MISS_REQ;\n          end\n        end\n      end\n      //////////////////////////////////\n      // issue request\n      MISS_REQ: begin\n        miss_req_o = 1'b1;\n\n        if (req_port_i.kill_req) begin\n          req_port_o.data_rvalid = 1'b1;\n          if (miss_ack_i) begin\n            state_d = KILL_MISS;\n          end else begin\n            state_d = KILL_MISS_ACK;\n          end\n        end else if (miss_replay_i) begin\n          state_d = REPLAY_REQ;\n        end else if (miss_ack_i) begin\n          state_d = MISS_WAIT;\n        end\n      end\n      //////////////////////////////////\n      // wait until the memory transaction\n      // returns.\n      MISS_WAIT: begin\n        if (req_port_i.kill_req) begin\n          req_port_o.data_rvalid = 1'b1;\n          if (miss_rtrn_vld_i) begin\n            state_d = IDLE;\n          end else begin\n            state_d = KILL_MISS;\n          end\n        end else if (miss_rtrn_vld_i) begin\n          state_d = IDLE;\n          req_port_o.data_rvalid = 1'b1;\n        end\n      end\n      //////////////////////////////////\n      // replay read request\n      REPLAY_REQ: begin\n        rd_req_o = 1'b1;\n        if (req_port_i.kill_req) begin\n          req_port_o.data_rvalid = 1'b1;\n          state_d = IDLE;\n        end else if (rd_ack_i) begin\n          state_d = REPLAY_READ;\n        end\n      end\n      //////////////////////////////////\n      KILL_MISS_ACK: begin\n        miss_req_o = 1'b1;\n        // in this case the miss handler did not issue\n        // a transaction and we can safely go to idle\n        if (miss_replay_i) begin\n          state_d = IDLE;\n        end else if (miss_ack_i) begin\n          state_d = KILL_MISS;\n        end\n      end\n      //////////////////////////////////\n      // killed miss,\n      // wait until miss unit responds and\n      // go back to idle\n      KILL_MISS: begin\n        if (miss_rtrn_vld_i) begin\n          state_d = IDLE;\n        end\n      end\n      default: begin\n        // we should never get here\n        state_d = IDLE;\n      end\n    endcase  // state_q\n  end\n\n  ///////////////////////////////////////////////////////\n  // ff's\n  ///////////////////////////////////////////////////////\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs\n    if (!rst_ni) begin\n      state_q       <= IDLE;\n      address_tag_q <= '0;\n      address_idx_q <= '0;\n      address_off_q <= '0;\n      id_q          <= '0;\n      vld_data_q    <= '0;\n      data_size_q   <= '0;\n      rd_req_q      <= '0;\n      rd_ack_q      <= '0;\n    end else begin\n      state_q       <= state_d;\n      address_tag_q <= address_tag_d;\n      address_idx_q <= address_idx_d;\n      address_off_q <= address_off_d;\n      id_q          <= id_d;\n      vld_data_q    <= vld_data_d;\n      data_size_q   <= data_size_d;\n      rd_req_q      <= rd_req_d;\n      rd_ack_q      <= rd_ack_d;\n    end\n  end\n\n  ///////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////\n\n  //pragma translate_off\n`ifndef VERILATOR\n\n  hot1 :\n  assert property (@(posedge clk_i) disable iff (!rst_ni) (!rd_ack_i) |=> cache_en_i |-> $onehot0(\n      rd_hit_oh_i\n  ))\n  else $fatal(1, \"[l1 dcache ctrl] rd_hit_oh_i signal must be hot1\");\n\n  initial begin\n    // assert wrong parameterizations\n    assert (DCACHE_INDEX_WIDTH <= 12)\n    else\n      $fatal(1, \"[l1 dcache ctrl] cache index width can be maximum 12bit since VM uses 4kB pages\");\n  end\n`endif\n  //pragma translate_on\n\nendmodule  // wt_dcache_ctrl\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 13.09.2018\n// Description: Memory arrays, arbiter and tag comparison for WT dcache.\n//\n//\n// Notes: 1) all ports can trigger a readout of all ways, and the way where the tag hits is selected\n//\n//        2) only port0 can write full cache lines. higher ports are read only. also, port0 can only read the tag array,\n//           and does not trigger a cache line readout.\n//\n//        3) the single word write port is a separate port without access to the tag memory.\n//           these single word writes can interleave with read operations if they go to different\n//           cacheline offsets, since each word offset is placed into a different SRAM bank.\n//\n//        4) Read ports with same priority are RR arbited. but high prio ports (rd_prio_i[port_nr] = '1b1) will stall\n//           low prio ports (rd_prio_i[port_nr] = '1b0)\n\n\nmodule wt_dcache_mem\n  import ariane_pkg::*;\n  import wt_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg  = config_pkg::cva6_cfg_empty,\n    parameter int unsigned           NumPorts = 3\n) (\n    input logic clk_i,\n    input logic rst_ni,\n\n    // ports\n    input logic [NumPorts-1:0][DCACHE_TAG_WIDTH-1:0] rd_tag_i,  // tag in - comes one cycle later\n    input logic [NumPorts-1:0][DCACHE_CL_IDX_WIDTH-1:0] rd_idx_i,\n    input logic [NumPorts-1:0][DCACHE_OFFSET_WIDTH-1:0] rd_off_i,\n    input logic [NumPorts-1:0] rd_req_i,  // read the word at offset off_i[:3] in all ways\n    input  logic  [NumPorts-1:0]                              rd_tag_only_i,      // only do a tag/valid lookup, no access to data arrays\n    input logic [NumPorts-1:0] rd_prio_i,  // 0: low prio, 1: high prio\n    output logic [NumPorts-1:0] rd_ack_o,\n    output logic [DCACHE_SET_ASSOC-1:0] rd_vld_bits_o,\n    output logic [DCACHE_SET_ASSOC-1:0] rd_hit_oh_o,\n    output riscv::xlen_t rd_data_o,\n    output logic [DCACHE_USER_WIDTH-1:0] rd_user_o,\n\n    // only available on port 0, uses address signals of port 0\n    input logic                              wr_cl_vld_i,\n    input logic                              wr_cl_nc_i,       // noncacheable access\n    input logic [      DCACHE_SET_ASSOC-1:0] wr_cl_we_i,       // writes a full cacheline\n    input logic [      DCACHE_TAG_WIDTH-1:0] wr_cl_tag_i,\n    input logic [   DCACHE_CL_IDX_WIDTH-1:0] wr_cl_idx_i,\n    input logic [   DCACHE_OFFSET_WIDTH-1:0] wr_cl_off_i,\n    input logic [     DCACHE_LINE_WIDTH-1:0] wr_cl_data_i,\n    input logic [DCACHE_USER_LINE_WIDTH-1:0] wr_cl_user_i,\n    input logic [   DCACHE_LINE_WIDTH/8-1:0] wr_cl_data_be_i,\n    input logic [      DCACHE_SET_ASSOC-1:0] wr_vld_bits_i,\n\n    // separate port for single word write, no tag access\n    input logic [DCACHE_SET_ASSOC-1:0] wr_req_i,  // write a single word to offset off_i[:3]\n    output logic wr_ack_o,\n    input logic [DCACHE_CL_IDX_WIDTH-1:0] wr_idx_i,\n    input logic [DCACHE_OFFSET_WIDTH-1:0] wr_off_i,\n    input riscv::xlen_t wr_data_i,\n    input logic [DCACHE_USER_WIDTH-1:0] wr_user_i,\n    input logic [(riscv::XLEN/8)-1:0] wr_data_be_i,\n\n    // forwarded wbuffer\n    input wbuffer_t [DCACHE_WBUF_DEPTH-1:0] wbuffer_data_i\n);\n\n  // functions\n  function automatic logic [DCACHE_NUM_BANKS-1:0] dcache_cl_bin2oh(\n      input logic [DCACHE_NUM_BANKS_WIDTH-1:0] in);\n    logic [DCACHE_NUM_BANKS-1:0] out;\n    out     = '0;\n    out[in] = 1'b1;\n    return out;\n  endfunction\n\n  // number of bits needed to address AXI data. If AxiDataWidth equals XLEN this parameter\n  // is not needed. Therefore, increment it by one to avoid reverse range select during elaboration.\n  localparam AXI_OFFSET_WIDTH = CVA6Cfg.AxiDataWidth == riscv::XLEN ? $clog2(\n      CVA6Cfg.AxiDataWidth / 8\n  ) + 1 : $clog2(\n      CVA6Cfg.AxiDataWidth / 8\n  );\n\n  logic [DCACHE_NUM_BANKS-1:0]                                               bank_req;\n  logic [DCACHE_NUM_BANKS-1:0]                                               bank_we;\n  logic [DCACHE_NUM_BANKS-1:0][   DCACHE_SET_ASSOC-1:0][(riscv::XLEN/8)-1:0] bank_be;\n  logic [DCACHE_NUM_BANKS-1:0][DCACHE_CL_IDX_WIDTH-1:0]                      bank_idx;\n  logic [DCACHE_CL_IDX_WIDTH-1:0] bank_idx_d, bank_idx_q;\n  logic [DCACHE_OFFSET_WIDTH-1:0] bank_off_d, bank_off_q;\n\n  logic [DCACHE_NUM_BANKS-1:0][DCACHE_SET_ASSOC-1:0][riscv::XLEN-1:0] bank_wdata;  //\n  logic [DCACHE_NUM_BANKS-1:0][DCACHE_SET_ASSOC-1:0][riscv::XLEN-1:0] bank_rdata;  //\n  logic [DCACHE_SET_ASSOC-1:0][riscv::XLEN-1:0] rdata_cl;  // selected word from each cacheline\n  logic [DCACHE_NUM_BANKS-1:0][DCACHE_SET_ASSOC-1:0][DCACHE_USER_WIDTH-1:0] bank_wuser;  //\n  logic [DCACHE_NUM_BANKS-1:0][DCACHE_SET_ASSOC-1:0][DCACHE_USER_WIDTH-1:0] bank_ruser;  //\n  logic [DCACHE_SET_ASSOC-1:0][DCACHE_USER_WIDTH-1:0]                      ruser_cl;          // selected word from each cacheline\n\n  logic [DCACHE_TAG_WIDTH-1:0] rd_tag;\n  logic [DCACHE_SET_ASSOC-1:0] vld_req;  // bit enable for valid regs\n  logic vld_we;  // valid bits write enable\n  logic [DCACHE_SET_ASSOC-1:0] vld_wdata;  // valid bits to write\n  logic [DCACHE_SET_ASSOC-1:0][DCACHE_TAG_WIDTH-1:0]            tag_rdata;                    // these are the tags coming from the tagmem\n  logic [DCACHE_CL_IDX_WIDTH-1:0] vld_addr;  // valid bit\n\n  logic [$clog2(NumPorts)-1:0] vld_sel_d, vld_sel_q;\n\n  logic [DCACHE_WBUF_DEPTH-1:0] wbuffer_hit_oh;\n  logic [  (riscv::XLEN/8)-1:0] wbuffer_be;\n  riscv::xlen_t wbuffer_rdata, rdata;\n  logic [DCACHE_USER_WIDTH-1:0] wbuffer_ruser, ruser;\n  logic [riscv::PLEN-1:0] wbuffer_cmp_addr;\n\n  logic cmp_en_d, cmp_en_q;\n  logic rd_acked;\n  logic [NumPorts-1:0] bank_collision, rd_req_masked, rd_req_prio;\n\n  ///////////////////////////////////////////////////////\n  // arbiter\n  ///////////////////////////////////////////////////////\n\n  // Priority is highest for lowest read port index\n  //\n  // SRAM bank mapping:\n  //\n  // Bank 0                   Bank 2\n  // [way0, w0] [way1, w0] .. [way0, w1] [way1, w1] ..\n\n  // byte enable mapping\n  for (genvar k = 0; k < DCACHE_NUM_BANKS; k++) begin : gen_bank\n    for (genvar j = 0; j < DCACHE_SET_ASSOC; j++) begin : gen_bank_way\n      assign bank_be[k][j]   = (wr_cl_we_i[j] & wr_cl_vld_i)  ? wr_cl_data_be_i[k*(riscv::XLEN/8) +: (riscv::XLEN/8)] :\n                               (wr_req_i[j]   & wr_ack_o)     ? wr_data_be_i              :\n                                                                '0;\n      assign bank_wdata[k][j] = (wr_cl_we_i[j] & wr_cl_vld_i) ?  wr_cl_data_i[k*riscv::XLEN +: riscv::XLEN] :\n                                                                 wr_data_i;\n      assign bank_wuser[k][j] = (wr_cl_we_i[j] & wr_cl_vld_i) ?  wr_cl_user_i[k*DCACHE_USER_WIDTH +: DCACHE_USER_WIDTH] :\n                                                                 wr_user_i;\n    end\n  end\n\n  assign vld_wdata     = wr_vld_bits_i;\n  assign vld_addr      = (wr_cl_vld_i) ? wr_cl_idx_i : rd_idx_i[vld_sel_d];\n  assign rd_tag        = rd_tag_i[vld_sel_q];  //delayed by one cycle\n  assign bank_off_d    = (wr_cl_vld_i) ? wr_cl_off_i : rd_off_i[vld_sel_d];\n  assign bank_idx_d    = (wr_cl_vld_i) ? wr_cl_idx_i : rd_idx_i[vld_sel_d];\n  assign vld_req       = (wr_cl_vld_i) ? wr_cl_we_i : (rd_acked) ? '1 : '0;\n\n\n  // priority masking\n  // disable low prio requests when any of the high prio reqs is present\n  assign rd_req_prio   = rd_req_i & rd_prio_i;\n  assign rd_req_masked = (|rd_req_prio) ? rd_req_prio : rd_req_i;\n\n  logic rd_req;\n  rr_arb_tree #(\n      .NumIn    (NumPorts),\n      .DataWidth(1)\n  ) i_rr_arb_tree (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i('0),\n      .rr_i   ('0),\n      .req_i  (rd_req_masked),\n      .gnt_o  (rd_ack_o),\n      .data_i ('0),\n      .gnt_i  (~wr_cl_vld_i),\n      .req_o  (rd_req),\n      .data_o (),\n      .idx_o  (vld_sel_d)\n  );\n\n  assign rd_acked = rd_req & ~wr_cl_vld_i;\n\n  always_comb begin : p_bank_req\n    vld_we   = wr_cl_vld_i;\n    bank_req = '0;\n    wr_ack_o = '0;\n    bank_we  = '0;\n    bank_idx = '{default: wr_idx_i};\n\n    for (int k = 0; k < NumPorts; k++) begin\n      bank_collision[k] = rd_off_i[k][DCACHE_OFFSET_WIDTH-1:riscv::XLEN_ALIGN_BYTES] == wr_off_i[DCACHE_OFFSET_WIDTH-1:riscv::XLEN_ALIGN_BYTES];\n    end\n\n    if (wr_cl_vld_i & |wr_cl_we_i) begin\n      bank_req = '1;\n      bank_we  = '1;\n      bank_idx = '{default: wr_cl_idx_i};\n    end else begin\n      if (rd_acked) begin\n        if (!rd_tag_only_i[vld_sel_d]) begin\n          bank_req =\n              dcache_cl_bin2oh(rd_off_i[vld_sel_d][DCACHE_OFFSET_WIDTH-1:riscv::XLEN_ALIGN_BYTES]);\n          bank_idx[rd_off_i[vld_sel_d][DCACHE_OFFSET_WIDTH-1:riscv::XLEN_ALIGN_BYTES]] = rd_idx_i[vld_sel_d];\n        end\n      end\n\n      if (|wr_req_i) begin\n        if (rd_tag_only_i[vld_sel_d] || !(rd_ack_o[vld_sel_d] && bank_collision[vld_sel_d])) begin\n          wr_ack_o = 1'b1;\n          bank_req |= dcache_cl_bin2oh(wr_off_i[DCACHE_OFFSET_WIDTH-1:riscv::XLEN_ALIGN_BYTES]);\n          bank_we = dcache_cl_bin2oh(wr_off_i[DCACHE_OFFSET_WIDTH-1:riscv::XLEN_ALIGN_BYTES]);\n        end\n      end\n    end\n  end\n\n  ///////////////////////////////////////////////////////\n  // tag comparison, hit generatio, readoud muxes\n  ///////////////////////////////////////////////////////\n\n  logic [DCACHE_OFFSET_WIDTH-riscv::XLEN_ALIGN_BYTES-1:0] wr_cl_off;\n  logic [DCACHE_OFFSET_WIDTH-riscv::XLEN_ALIGN_BYTES-1:0] wr_cl_nc_off;\n  logic [                  $clog2(DCACHE_WBUF_DEPTH)-1:0] wbuffer_hit_idx;\n  logic [                   $clog2(DCACHE_SET_ASSOC)-1:0] rd_hit_idx;\n\n  assign cmp_en_d = (|vld_req) & ~vld_we;\n\n  // word tag comparison in write buffer\n  assign wbuffer_cmp_addr = (wr_cl_vld_i) ? {wr_cl_tag_i, wr_cl_idx_i, wr_cl_off_i} :\n                                            {rd_tag, bank_idx_q, bank_off_q};\n  // hit generation\n  for (genvar i = 0; i < DCACHE_SET_ASSOC; i++) begin : gen_tag_cmpsel\n    // tag comparison of ways >0\n    assign rd_hit_oh_o[i] = (rd_tag == tag_rdata[i]) & rd_vld_bits_o[i] & cmp_en_q;\n    // byte offset mux of ways >0\n    assign rdata_cl[i] = bank_rdata[bank_off_q[DCACHE_OFFSET_WIDTH-1:riscv::XLEN_ALIGN_BYTES]][i];\n    assign ruser_cl[i] = bank_ruser[bank_off_q[DCACHE_OFFSET_WIDTH-1:riscv::XLEN_ALIGN_BYTES]][i];\n  end\n\n  for (genvar k = 0; k < DCACHE_WBUF_DEPTH; k++) begin : gen_wbuffer_hit\n    assign wbuffer_hit_oh[k] = (|wbuffer_data_i[k].valid) & ({{riscv::XLEN_ALIGN_BYTES{1'b0}}, wbuffer_data_i[k].wtag} == (wbuffer_cmp_addr >> riscv::XLEN_ALIGN_BYTES));\n  end\n\n  lzc #(\n      .WIDTH(DCACHE_WBUF_DEPTH)\n  ) i_lzc_wbuffer_hit (\n      .in_i   (wbuffer_hit_oh),\n      .cnt_o  (wbuffer_hit_idx),\n      .empty_o()\n  );\n\n  lzc #(\n      .WIDTH(DCACHE_SET_ASSOC)\n  ) i_lzc_rd_hit (\n      .in_i   (rd_hit_oh_o),\n      .cnt_o  (rd_hit_idx),\n      .empty_o()\n  );\n\n  assign wbuffer_rdata = wbuffer_data_i[wbuffer_hit_idx].data;\n  assign wbuffer_ruser = wbuffer_data_i[wbuffer_hit_idx].user;\n  assign wbuffer_be    = (|wbuffer_hit_oh) ? wbuffer_data_i[wbuffer_hit_idx].valid : '0;\n\n  if (CVA6Cfg.NOCType == config_pkg::NOC_TYPE_AXI4_ATOP) begin : gen_axi_offset\n    // In case of an uncached read, return the desired XLEN-bit segment of the most recent AXI read\n    assign wr_cl_off     = (wr_cl_nc_i) ? (CVA6Cfg.AxiDataWidth == riscv::XLEN) ? '0 :\n                              {{DCACHE_OFFSET_WIDTH-AXI_OFFSET_WIDTH{1'b0}}, wr_cl_off_i[AXI_OFFSET_WIDTH-1:riscv::XLEN_ALIGN_BYTES]} :\n                              wr_cl_off_i[DCACHE_OFFSET_WIDTH-1:riscv::XLEN_ALIGN_BYTES];\n  end else begin : gen_piton_offset\n    assign wr_cl_off = wr_cl_off_i[DCACHE_OFFSET_WIDTH-1:3];\n  end\n\n  always_comb begin\n    if (wr_cl_vld_i) begin\n      rdata = wr_cl_data_i[wr_cl_off*riscv::XLEN+:riscv::XLEN];\n      ruser = wr_cl_user_i[wr_cl_off*DCACHE_USER_WIDTH+:DCACHE_USER_WIDTH];\n    end else begin\n      rdata = rdata_cl[rd_hit_idx];\n      ruser = ruser_cl[rd_hit_idx];\n    end\n  end\n\n  // overlay bytes that hit in the write buffer\n  for (genvar k = 0; k < (riscv::XLEN / 8); k++) begin : gen_rd_data\n    assign rd_data_o[8*k+:8] = (wbuffer_be[k]) ? wbuffer_rdata[8*k+:8] : rdata[8*k+:8];\n  end\n  for (genvar k = 0; k < DCACHE_USER_WIDTH / 8; k++) begin : gen_rd_user\n    assign rd_user_o[8*k+:8] = (wbuffer_be[k]) ? wbuffer_ruser[8*k+:8] : ruser[8*k+:8];\n  end\n\n  ///////////////////////////////////////////////////////\n  // memory arrays and regs\n  ///////////////////////////////////////////////////////\n\n  logic [DCACHE_TAG_WIDTH:0] vld_tag_rdata[DCACHE_SET_ASSOC-1:0];\n\n  for (genvar k = 0; k < DCACHE_NUM_BANKS; k++) begin : gen_data_banks\n    // Data RAM\n    sram #(\n        .USER_WIDTH(ariane_pkg::DCACHE_SET_ASSOC * DATA_USER_WIDTH),\n        .DATA_WIDTH(ariane_pkg::DCACHE_SET_ASSOC * riscv::XLEN),\n        .USER_EN   (ariane_pkg::DATA_USER_EN),\n        .NUM_WORDS (wt_cache_pkg::DCACHE_NUM_WORDS)\n    ) i_data_sram (\n        .clk_i  (clk_i),\n        .rst_ni (rst_ni),\n        .req_i  (bank_req[k]),\n        .we_i   (bank_we[k]),\n        .addr_i (bank_idx[k]),\n        .wuser_i(bank_wuser[k]),\n        .wdata_i(bank_wdata[k]),\n        .be_i   (bank_be[k]),\n        .ruser_o(bank_ruser[k]),\n        .rdata_o(bank_rdata[k])\n    );\n  end\n\n  for (genvar i = 0; i < DCACHE_SET_ASSOC; i++) begin : gen_tag_srams\n\n    assign tag_rdata[i]     = vld_tag_rdata[i][DCACHE_TAG_WIDTH-1:0];\n    assign rd_vld_bits_o[i] = vld_tag_rdata[i][DCACHE_TAG_WIDTH];\n\n    // Tag RAM\n    sram #(\n        // tag + valid bit\n        .DATA_WIDTH(ariane_pkg::DCACHE_TAG_WIDTH + 1),\n        .NUM_WORDS (wt_cache_pkg::DCACHE_NUM_WORDS)\n    ) i_tag_sram (\n        .clk_i  (clk_i),\n        .rst_ni (rst_ni),\n        .req_i  (vld_req[i]),\n        .we_i   (vld_we),\n        .addr_i (vld_addr),\n        .wuser_i('0),\n        .wdata_i({vld_wdata[i], wr_cl_tag_i}),\n        .be_i   ('1),\n        .ruser_o(),\n        .rdata_o(vld_tag_rdata[i])\n    );\n  end\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs\n    if (!rst_ni) begin\n      bank_idx_q <= '0;\n      bank_off_q <= '0;\n      vld_sel_q  <= '0;\n      cmp_en_q   <= '0;\n    end else begin\n      bank_idx_q <= bank_idx_d;\n      bank_off_q <= bank_off_d;\n      vld_sel_q  <= vld_sel_d;\n      cmp_en_q   <= cmp_en_d;\n    end\n  end\n\n  ///////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////\n\n  //pragma translate_off\n`ifndef VERILATOR\n  initial begin\n    cach_line_width_axi :\n    assert (DCACHE_LINE_WIDTH >= CVA6Cfg.AxiDataWidth)\n    else $fatal(1, \"[l1 dcache] cache line size needs to be greater or equal AXI data width\");\n  end\n\n  initial begin\n    axi_xlen :\n    assert (CVA6Cfg.AxiDataWidth >= riscv::XLEN)\n    else $fatal(1, \"[l1 dcache] AXI data width needs to be greater or equal XLEN\");\n  end\n\n  initial begin\n    cach_line_width_xlen :\n    assert (DCACHE_LINE_WIDTH > riscv::XLEN)\n    else $fatal(1, \"[l1 dcache] cache_line_size needs to be greater than XLEN\");\n  end\n\n  hit_hot1 :\n  assert property (@(posedge clk_i) disable iff (!rst_ni) &vld_req |-> !vld_we |=> $onehot0(\n      rd_hit_oh_o\n  ))\n  else $fatal(1, \"[l1 dcache] rd_hit_oh_o signal must be hot1\");\n\n  word_write_hot1 :\n  assert property (@(posedge clk_i) disable iff (!rst_ni) wr_ack_o |-> $onehot0(wr_req_i))\n  else $fatal(1, \"[l1 dcache] wr_req_i signal must be hot1\");\n\n  wbuffer_hit_hot1 :\n  assert property (@(posedge clk_i) disable iff (!rst_ni) &vld_req |-> !vld_we |=> $onehot0(\n      wbuffer_hit_oh\n  ))\n  else $fatal(1, \"[l1 dcache] wbuffer_hit_oh signal must be hot1\");\n\n  // this is only used for verification!\n  logic vld_mirror[wt_cache_pkg::DCACHE_NUM_WORDS-1:0][ariane_pkg::DCACHE_SET_ASSOC-1:0];\n  logic [ariane_pkg::DCACHE_TAG_WIDTH-1:0] tag_mirror[wt_cache_pkg::DCACHE_NUM_WORDS-1:0][ariane_pkg::DCACHE_SET_ASSOC-1:0];\n  logic [ariane_pkg::DCACHE_SET_ASSOC-1:0] tag_write_duplicate_test;\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : p_mirror\n    if (!rst_ni) begin\n      vld_mirror <= '{default: '0};\n      tag_mirror <= '{default: '0};\n    end else begin\n      for (int i = 0; i < DCACHE_SET_ASSOC; i++) begin\n        if (vld_req[i] & vld_we) begin\n          vld_mirror[vld_addr][i] <= vld_wdata[i];\n          tag_mirror[vld_addr][i] <= wr_cl_tag_i;\n        end\n      end\n    end\n  end\n\n  for (genvar i = 0; i < DCACHE_SET_ASSOC; i++) begin : gen_tag_dubl_test\n    assign tag_write_duplicate_test[i] = (tag_mirror[vld_addr][i] == wr_cl_tag_i) & vld_mirror[vld_addr][i] & (|vld_wdata);\n  end\n\n  tag_write_duplicate :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) |vld_req |-> vld_we |-> !(|tag_write_duplicate_test))\n  else $fatal(1, \"[l1 dcache] cannot allocate a CL that is already present in the cache\");\n\n`endif\n  //pragma translate_on\n\nendmodule  // wt_dcache_mem\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 13.09.2018\n// Description: miss controller for WT dcache. Note that the current assumption\n// is that the port with the highest index issues writes instead of reads.\n\n\nmodule wt_dcache_missunit\n  import ariane_pkg::*;\n  import wt_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty,\n    parameter logic [CACHE_ID_WIDTH-1:0] AmoTxId = 1,  // TX id to be used for AMOs\n    parameter int unsigned NumPorts = 4  // number of miss ports\n) (\n    input logic clk_i,  // Clock\n    input logic rst_ni,  // Asynchronous reset active low\n    // cache management, signals from/to core\n    input logic enable_i,  // from CSR\n    input  logic                                       flush_i,     // flush request, this waits for pending tx (write, read) to finish and will clear the cache\n    output logic flush_ack_o,  // send a single cycle acknowledge signal when the cache is flushed\n    output logic miss_o,  // we missed on a ld/st\n    // local cache management signals\n    input logic wbuffer_empty_i,\n    output logic cache_en_o,  // local cache enable signal\n    // AMO interface\n    input amo_req_t amo_req_i,\n    output amo_resp_t amo_resp_o,\n    // miss handling interface (ld, ptw, wbuffer)\n    input logic [NumPorts-1:0] miss_req_i,\n    output logic [NumPorts-1:0] miss_ack_o,\n    input logic [NumPorts-1:0] miss_nc_i,\n    input logic [NumPorts-1:0] miss_we_i,\n    input logic [NumPorts-1:0][riscv::XLEN-1:0] miss_wdata_i,\n    input logic [NumPorts-1:0][DCACHE_USER_WIDTH-1:0] miss_wuser_i,\n    input logic [NumPorts-1:0][riscv::PLEN-1:0] miss_paddr_i,\n    input logic [NumPorts-1:0][DCACHE_SET_ASSOC-1:0] miss_vld_bits_i,\n    input logic [NumPorts-1:0][2:0] miss_size_i,\n    input logic [NumPorts-1:0][CACHE_ID_WIDTH-1:0] miss_id_i,  // used as transaction ID\n    // signals that the request collided with a pending read\n    output logic [NumPorts-1:0] miss_replay_o,\n    // signals response from memory\n    output logic [NumPorts-1:0] miss_rtrn_vld_o,\n    output logic [CACHE_ID_WIDTH-1:0]                  miss_rtrn_id_o,     // only used for writes, set to zero fro reads\n    // from writebuffer\n    input  logic [DCACHE_MAX_TX-1:0][riscv::PLEN-1:0]  tx_paddr_i,         // used to check for address collisions with read operations\n    input  logic [DCACHE_MAX_TX-1:0]                   tx_vld_i,           // used to check for address collisions with read operations\n    // write interface to cache memory\n    output logic wr_cl_vld_o,  // writes a full cacheline\n    output logic wr_cl_nc_o,  // writes a full cacheline\n    output logic [DCACHE_SET_ASSOC-1:0] wr_cl_we_o,  // writes a full cacheline\n    output logic [DCACHE_TAG_WIDTH-1:0] wr_cl_tag_o,\n    output logic [DCACHE_CL_IDX_WIDTH-1:0] wr_cl_idx_o,\n    output logic [DCACHE_OFFSET_WIDTH-1:0] wr_cl_off_o,\n    output logic [DCACHE_LINE_WIDTH-1:0] wr_cl_data_o,\n    output logic [DCACHE_USER_LINE_WIDTH-1:0] wr_cl_user_o,\n    output logic [DCACHE_LINE_WIDTH/8-1:0] wr_cl_data_be_o,\n    output logic [DCACHE_SET_ASSOC-1:0] wr_vld_bits_o,\n    // memory interface\n    input logic mem_rtrn_vld_i,\n    input dcache_rtrn_t mem_rtrn_i,\n    output logic mem_data_req_o,\n    input logic mem_data_ack_i,\n    output dcache_req_t mem_data_o\n);\n\n  // functions\n  function automatic logic [ariane_pkg::DCACHE_SET_ASSOC-1:0] dcache_way_bin2oh(\n      input logic [L1D_WAY_WIDTH-1:0] in);\n    logic [ariane_pkg::DCACHE_SET_ASSOC-1:0] out;\n    out     = '0;\n    out[in] = 1'b1;\n    return out;\n  endfunction\n\n  // align the physical address to the specified size:\n  // 000: bytes\n  // 001: hword\n  // 010: word\n  // 011: dword\n  // 111: DCACHE line\n  function automatic logic [riscv::PLEN-1:0] paddrSizeAlign(input logic [riscv::PLEN-1:0] paddr,\n                                                            input logic [2:0] size);\n    logic [riscv::PLEN-1:0] out;\n    out = paddr;\n    unique case (size)\n      3'b001:  out[0:0] = '0;\n      3'b010:  out[1:0] = '0;\n      3'b011:  out[2:0] = '0;\n      3'b111:  out[DCACHE_OFFSET_WIDTH-1:0] = '0;\n      default: ;\n    endcase\n    return out;\n  endfunction : paddrSizeAlign\n\n  // controller FSM\n  typedef enum logic [2:0] {\n    IDLE,\n    DRAIN,\n    AMO,\n    FLUSH,\n    STORE_WAIT,\n    LOAD_WAIT,\n    AMO_WAIT\n  } state_e;\n  state_e state_d, state_q;\n\n  // MSHR for reads\n  typedef struct packed {\n    logic [riscv::PLEN-1:0]              paddr;\n    logic [2:0]                          size;\n    logic [DCACHE_SET_ASSOC-1:0]         vld_bits;\n    logic [CACHE_ID_WIDTH-1:0]           id;\n    logic                                nc;\n    logic [$clog2(DCACHE_SET_ASSOC)-1:0] repl_way;\n    logic [$clog2(NumPorts)-1:0]         miss_port_idx;\n  } mshr_t;\n\n  mshr_t mshr_d, mshr_q;\n  logic [$clog2(DCACHE_SET_ASSOC)-1:0] repl_way, inv_way, rnd_way;\n  logic mshr_vld_d, mshr_vld_q, mshr_vld_q1;\n  logic mshr_allocate;\n  logic update_lfsr, all_ways_valid;\n\n  logic enable_d, enable_q;\n  logic flush_ack_d, flush_ack_q;\n  logic flush_en, flush_done;\n  logic mask_reads, lock_reqs;\n  logic amo_sel, miss_is_write;\n  logic amo_req_d, amo_req_q;\n  logic [63:0] amo_rtrn_mux;\n  riscv::xlen_t amo_data, amo_data_a, amo_data_b;\n  riscv::xlen_t amo_user;  //DCACHE USER ? DATA_USER_WIDTH\n  logic [riscv::PLEN-1:0] tmp_paddr;\n  logic [$clog2(NumPorts)-1:0] miss_port_idx;\n  logic [DCACHE_CL_IDX_WIDTH-1:0] cnt_d, cnt_q;\n  logic [NumPorts-1:0] miss_req_masked_d, miss_req_masked_q;\n\n  logic inv_vld, inv_vld_all, cl_write_en;\n  logic load_ack, store_ack, amo_ack;\n\n  logic [NumPorts-1:0] mshr_rdrd_collision_d, mshr_rdrd_collision_q;\n  logic [NumPorts-1:0] mshr_rdrd_collision;\n  logic tx_rdwr_collision, mshr_rdwr_collision;\n\n  ///////////////////////////////////////////////////////\n  // input arbitration and general control sigs\n  ///////////////////////////////////////////////////////\n\n  assign cache_en_o = enable_q;\n  assign cnt_d = (flush_en) ? cnt_q + 1 : '0;\n  assign flush_done = (cnt_q == wt_cache_pkg::DCACHE_NUM_WORDS - 1);\n\n  assign miss_req_masked_d = (lock_reqs)  ? miss_req_masked_q      :\n                             (mask_reads) ? miss_we_i & miss_req_i : miss_req_i;\n  assign miss_is_write = miss_we_i[miss_port_idx];\n\n  // read port arbiter\n  lzc #(\n      .WIDTH(NumPorts)\n  ) i_lzc_reqs (\n      .in_i   (miss_req_masked_d),\n      .cnt_o  (miss_port_idx),\n      .empty_o()\n  );\n\n  always_comb begin : p_ack\n    miss_ack_o = '0;\n    if (!amo_sel) begin\n      miss_ack_o[miss_port_idx] = mem_data_ack_i & mem_data_req_o;\n    end\n  end\n\n  ///////////////////////////////////////////////////////\n  // MSHR and way replacement logic (only for read ops)\n  ///////////////////////////////////////////////////////\n\n  // find invalid cache line\n  lzc #(\n      .WIDTH(ariane_pkg::DCACHE_SET_ASSOC)\n  ) i_lzc_inv (\n      .in_i   (~miss_vld_bits_i[miss_port_idx]),\n      .cnt_o  (inv_way),\n      .empty_o(all_ways_valid)\n  );\n\n  // generate random cacheline index\n  lfsr #(\n      .LfsrWidth(8),\n      .OutWidth ($clog2(ariane_pkg::DCACHE_SET_ASSOC))\n  ) i_lfsr_inv (\n      .clk_i (clk_i),\n      .rst_ni(rst_ni),\n      .en_i  (update_lfsr),\n      .out_o (rnd_way)\n  );\n\n  assign repl_way             = (all_ways_valid) ? rnd_way : inv_way;\n\n  assign mshr_d.size          = (mshr_allocate) ? miss_size_i[miss_port_idx] : mshr_q.size;\n  assign mshr_d.paddr         = (mshr_allocate) ? miss_paddr_i[miss_port_idx] : mshr_q.paddr;\n  assign mshr_d.vld_bits      = (mshr_allocate) ? miss_vld_bits_i[miss_port_idx] : mshr_q.vld_bits;\n  assign mshr_d.id            = (mshr_allocate) ? miss_id_i[miss_port_idx] : mshr_q.id;\n  assign mshr_d.nc            = (mshr_allocate) ? miss_nc_i[miss_port_idx] : mshr_q.nc;\n  assign mshr_d.repl_way      = (mshr_allocate) ? repl_way : mshr_q.repl_way;\n  assign mshr_d.miss_port_idx = (mshr_allocate) ? miss_port_idx : mshr_q.miss_port_idx;\n\n  // currently we only have one outstanding read TX, hence an incoming load clears the MSHR\n  assign mshr_vld_d           = (mshr_allocate) ? 1'b1 : (load_ack) ? 1'b0 : mshr_vld_q;\n\n  assign miss_o               = (mshr_allocate) ? ~miss_nc_i[miss_port_idx] : 1'b0;\n\n\n  for (genvar k = 0; k < NumPorts; k++) begin : gen_rdrd_collision\n    assign mshr_rdrd_collision[k]   = (mshr_q.paddr[riscv::PLEN-1:DCACHE_OFFSET_WIDTH] == miss_paddr_i[k][riscv::PLEN-1:DCACHE_OFFSET_WIDTH]) && (mshr_vld_q | mshr_vld_q1);\n    assign mshr_rdrd_collision_d[k] = (!miss_req_i[k]) ? 1'b0 : mshr_rdrd_collision_q[k] | mshr_rdrd_collision[k];\n  end\n\n  // read/write collision, stalls the corresponding request\n  // write port[NumPorts-1] collides with MSHR_Q\n  assign mshr_rdwr_collision = (mshr_q.paddr[riscv::PLEN-1:DCACHE_OFFSET_WIDTH] == miss_paddr_i[NumPorts-1][riscv::PLEN-1:DCACHE_OFFSET_WIDTH]) && mshr_vld_q;\n\n  // read collides with inflight TX\n  always_comb begin : p_tx_coll\n    tx_rdwr_collision = 1'b0;\n    for (int k = 0; k < DCACHE_MAX_TX; k++) begin\n      tx_rdwr_collision |= (miss_paddr_i[miss_port_idx][riscv::PLEN-1:DCACHE_OFFSET_WIDTH] == tx_paddr_i[k][riscv::PLEN-1:DCACHE_OFFSET_WIDTH]) && tx_vld_i[k];\n    end\n  end\n\n  ///////////////////////////////////////////////////////\n  // to memory\n  ///////////////////////////////////////////////////////\n\n  // if size = 32bit word, select appropriate offset, replicate for openpiton...\n\n  if (CVA6Cfg.RVA) begin\n    if (riscv::IS_XLEN64) begin : gen_amo_64b_data\n      assign amo_data_a = {amo_req_i.operand_b[0+:32], amo_req_i.operand_b[0+:32]};\n      assign amo_data_b = amo_req_i.operand_b;\n    end else begin : gen_amo_32b_data\n      assign amo_data_a = amo_req_i.operand_b[0+:32];\n    end\n  end\n\n  always_comb begin\n    if (CVA6Cfg.RVA) begin\n      if (riscv::IS_XLEN64) begin\n        if (amo_req_i.size == 2'b10) begin\n          amo_data = amo_data_a;\n        end else begin\n          amo_data = amo_data_b;\n        end\n      end else begin\n        amo_data = amo_data_a;\n      end\n      if (ariane_pkg::DATA_USER_EN) begin\n        amo_user = amo_data;\n      end else begin\n        amo_user = '0;\n      end\n    end\n  end\n\n  if (CVA6Cfg.RVA) begin\n    // note: openpiton returns a full cacheline!\n    if (CVA6Cfg.NOCType == config_pkg::NOC_TYPE_AXI4_ATOP) begin : gen_axi_rtrn_mux\n      if (CVA6Cfg.AxiDataWidth > 64) begin\n        assign amo_rtrn_mux = mem_rtrn_i.data[amo_req_i.operand_a[$clog2(\n            CVA6Cfg.AxiDataWidth/8\n        )-1:3]*64+:64];\n      end else begin\n        assign amo_rtrn_mux = mem_rtrn_i.data[0+:64];\n      end\n    end else begin : gen_piton_rtrn_mux\n      assign amo_rtrn_mux = mem_rtrn_i.data[amo_req_i.operand_a[DCACHE_OFFSET_WIDTH-1:3]*64+:64];\n    end\n\n    // always sign extend 32bit values\n    assign amo_resp_o.result = (amo_req_i.size==2'b10) ? {{32{amo_rtrn_mux[amo_req_i.operand_a[2]*32 + 31]}},amo_rtrn_mux[amo_req_i.operand_a[2]*32 +: 32]} :\n                                                       amo_rtrn_mux ;\n    assign amo_req_d = amo_req_i.req;\n  end\n\n  // outgoing memory requests (AMOs are always uncached)\n  assign mem_data_o.tid = (CVA6Cfg.RVA && amo_sel) ? AmoTxId : miss_id_i[miss_port_idx];\n  assign mem_data_o.nc = (CVA6Cfg.RVA && amo_sel) ? 1'b1 : miss_nc_i[miss_port_idx];\n  assign mem_data_o.way = (CVA6Cfg.RVA && amo_sel) ? '0 : repl_way;\n  assign mem_data_o.data = (CVA6Cfg.RVA && amo_sel) ? amo_data : miss_wdata_i[miss_port_idx];\n  assign mem_data_o.user = (CVA6Cfg.RVA && amo_sel) ? amo_user : miss_wuser_i[miss_port_idx];\n  assign mem_data_o.size   = (CVA6Cfg.RVA && amo_sel) ? {1'b0, amo_req_i.size} : miss_size_i [miss_port_idx];\n  assign mem_data_o.amo_op = (CVA6Cfg.RVA && amo_sel) ? amo_req_i.amo_op : AMO_NONE;\n\n  assign tmp_paddr         = (CVA6Cfg.RVA && amo_sel) ? amo_req_i.operand_a[riscv::PLEN-1:0] : miss_paddr_i[miss_port_idx];\n  assign mem_data_o.paddr = paddrSizeAlign(tmp_paddr, mem_data_o.size);\n\n  ///////////////////////////////////////////////////////\n  // back-off mechanism for LR/SC completion guarantee\n  ///////////////////////////////////////////////////////\n\n  logic sc_fail, sc_pass, sc_backoff_over;\n  exp_backoff #(\n      .Seed  (3),\n      .MaxExp(16)\n  ) i_exp_backoff (\n      .clk_i,\n      .rst_ni,\n      .set_i    (sc_fail),\n      .clr_i    (sc_pass),\n      .is_zero_o(sc_backoff_over)\n  );\n\n  ///////////////////////////////////////////////////////\n  // responses from memory\n  ///////////////////////////////////////////////////////\n\n  // keep track of pending stores\n  logic store_sent;\n  logic [$clog2(wt_cache_pkg::DCACHE_MAX_TX + 1)-1:0] stores_inflight_d, stores_inflight_q;\n  assign store_sent = mem_data_req_o & mem_data_ack_i & (mem_data_o.rtype == DCACHE_STORE_REQ);\n\n  assign stores_inflight_d = (store_ack && store_sent) ? stores_inflight_q     :\n                             (store_ack)               ? stores_inflight_q - 1 :\n                             (store_sent)              ? stores_inflight_q + 1 :\n                                                         stores_inflight_q;\n\n  // incoming responses\n  always_comb begin : p_rtrn_logic\n    load_ack        = 1'b0;\n    store_ack       = 1'b0;\n    amo_ack         = 1'b0;\n    inv_vld         = 1'b0;\n    inv_vld_all     = 1'b0;\n    sc_fail         = 1'b0;\n    sc_pass         = 1'b0;\n    miss_rtrn_vld_o = '0;\n    if (mem_rtrn_vld_i) begin\n      unique case (mem_rtrn_i.rtype)\n        DCACHE_LOAD_ACK: begin\n          if (mshr_vld_q) begin\n            load_ack = 1'b1;\n            miss_rtrn_vld_o[mshr_q.miss_port_idx] = 1'b1;\n          end\n        end\n        DCACHE_STORE_ACK: begin\n          if (stores_inflight_q > 0) begin\n            store_ack = 1'b1;\n            miss_rtrn_vld_o[NumPorts-1] = 1'b1;\n          end\n        end\n        DCACHE_ATOMIC_ACK: begin\n          if (CVA6Cfg.RVA) begin\n            if (amo_req_q) begin\n              amo_ack = 1'b1;\n              // need to set SC backoff counter if\n              // this op failed\n              if (amo_req_i.amo_op == AMO_SC) begin\n                if (amo_resp_o.result > 0) begin\n                  sc_fail = 1'b1;\n                end else begin\n                  sc_pass = 1'b1;\n                end\n              end\n            end\n          end\n        end\n        DCACHE_INV_REQ: begin\n          inv_vld     = mem_rtrn_i.inv.vld | mem_rtrn_i.inv.all;\n          inv_vld_all = mem_rtrn_i.inv.all;\n        end\n        // TODO:\n        // DCACHE_INT_REQ: begin\n        // end\n        default: begin\n        end\n      endcase\n    end\n  end\n\n  // to write buffer\n  assign miss_rtrn_id_o = mem_rtrn_i.tid;\n\n  ///////////////////////////////////////////////////////\n  // writes to cache memory\n  ///////////////////////////////////////////////////////\n\n  // cacheline write port\n  assign wr_cl_nc_o = mshr_q.nc;\n  assign wr_cl_vld_o = load_ack | (|wr_cl_we_o);\n\n  assign wr_cl_we_o = (flush_en) ? '1 : (inv_vld_all) ? '1 : (inv_vld) ? dcache_way_bin2oh(\n      mem_rtrn_i.inv.way\n  ) : (cl_write_en) ? dcache_way_bin2oh(\n      mshr_q.repl_way\n  ) : '0;\n\n  assign wr_vld_bits_o = (flush_en) ? '0 : (inv_vld) ? '0 : (cl_write_en) ? dcache_way_bin2oh(\n      mshr_q.repl_way\n  ) : '0;\n\n  assign wr_cl_idx_o     = (flush_en) ? cnt_q                                                        :\n                           (inv_vld)  ? mem_rtrn_i.inv.idx[DCACHE_INDEX_WIDTH-1:DCACHE_OFFSET_WIDTH] :\n                                        mshr_q.paddr[DCACHE_INDEX_WIDTH-1:DCACHE_OFFSET_WIDTH];\n\n  assign wr_cl_tag_o = mshr_q.paddr[DCACHE_TAG_WIDTH+DCACHE_INDEX_WIDTH-1:DCACHE_INDEX_WIDTH];\n  assign wr_cl_off_o = mshr_q.paddr[DCACHE_OFFSET_WIDTH-1:0];\n  assign wr_cl_data_o = mem_rtrn_i.data;\n  assign wr_cl_user_o = mem_rtrn_i.user;\n  assign wr_cl_data_be_o = (cl_write_en) ? '1 : '0;// we only write complete cachelines into the memory\n\n  // only non-NC responses write to the cache\n  assign cl_write_en = load_ack & ~mshr_q.nc;\n\n  ///////////////////////////////////////////////////////\n  // main control logic for generating tx\n  ///////////////////////////////////////////////////////\n\n  always_comb begin : p_fsm\n    // default assignment\n    state_d          = state_q;\n\n    flush_ack_o      = 1'b0;\n    mem_data_o.rtype = DCACHE_LOAD_REQ;\n    mem_data_req_o   = 1'b0;\n    amo_resp_o.ack   = 1'b0;\n    miss_replay_o    = '0;\n\n    // disabling cache is possible anytime, enabling goes via flush\n    enable_d         = enable_q & enable_i;\n    flush_ack_d      = flush_ack_q;\n    flush_en         = 1'b0;\n    amo_sel          = 1'b0;\n    update_lfsr      = 1'b0;\n    mshr_allocate    = 1'b0;\n    lock_reqs        = 1'b0;\n    mask_reads       = mshr_vld_q;\n\n    // interfaces\n    unique case (state_q)\n      //////////////////////////////////\n      // wait for misses / amo ops\n      IDLE: begin\n        if (flush_i || (enable_i && !enable_q)) begin\n          if (wbuffer_empty_i && !mshr_vld_q) begin\n            flush_ack_d = flush_i;\n            state_d     = FLUSH;\n          end else begin\n            state_d = DRAIN;\n          end\n        end else if (CVA6Cfg.RVA && amo_req_i.req) begin\n          if (wbuffer_empty_i && !mshr_vld_q) begin\n            state_d = AMO;\n          end else begin\n            state_d = DRAIN;\n          end\n          // we've got a miss to handle\n        end else if (|miss_req_masked_d) begin\n          // this is a write miss, just pass through (but check whether write collides with MSHR)\n          if (miss_is_write) begin\n            // stall in case this write collides with the MSHR address\n            if (!mshr_rdwr_collision) begin\n              mem_data_req_o   = 1'b1;\n              mem_data_o.rtype = DCACHE_STORE_REQ;\n              if (!mem_data_ack_i) begin\n                state_d = STORE_WAIT;\n              end\n            end\n            // this is a read miss, can only allocate 1 MSHR\n            // in case of a load_ack we can accept a new miss, since the MSHR is being cleared\n          end else if (!mshr_vld_q || load_ack) begin\n            // replay the read request in case the address has collided with MSHR during the time the request was pending\n            // i.e., the cache state may have been updated in the mean time due to a refill at the same CL address\n            if (mshr_rdrd_collision_d[miss_port_idx]) begin\n              miss_replay_o[miss_port_idx] = 1'b1;\n              // stall in case this CL address overlaps with a write TX that is in flight\n            end else if (!tx_rdwr_collision) begin\n              mem_data_req_o   = 1'b1;\n              mem_data_o.rtype = DCACHE_LOAD_REQ;\n              update_lfsr      = all_ways_valid & mem_data_ack_i;  // need to evict a random way\n              mshr_allocate    = mem_data_ack_i;\n              if (!mem_data_ack_i) begin\n                state_d = LOAD_WAIT;\n              end\n            end\n          end\n        end\n      end\n      //////////////////////////////////\n      // wait until this request is acked\n      STORE_WAIT: begin\n        lock_reqs        = 1'b1;\n        mem_data_req_o   = 1'b1;\n        mem_data_o.rtype = DCACHE_STORE_REQ;\n        if (mem_data_ack_i) begin\n          state_d = IDLE;\n        end\n      end\n      //////////////////////////////////\n      // wait until this request is acked\n      LOAD_WAIT: begin\n        lock_reqs        = 1'b1;\n        mem_data_req_o   = 1'b1;\n        mem_data_o.rtype = DCACHE_LOAD_REQ;\n        if (mem_data_ack_i) begin\n          update_lfsr   = all_ways_valid;  // need to evict a random w"}
{"text": "ay\n          mshr_allocate = 1'b1;\n          state_d       = IDLE;\n        end\n      end\n      //////////////////////////////////\n      // only handle stores, do not accept new read requests\n      // wait until MSHR is cleared and wbuffer is empty\n      DRAIN: begin\n        mask_reads = 1'b1;\n        // these are writes, check whether they collide with MSHR\n        if (|miss_req_masked_d && !mshr_rdwr_collision) begin\n          mem_data_req_o   = 1'b1;\n          mem_data_o.rtype = DCACHE_STORE_REQ;\n        end\n\n        if (wbuffer_empty_i && !mshr_vld_q) begin\n          state_d = IDLE;\n        end\n      end\n      //////////////////////////////////\n      // flush the cache\n      FLUSH: begin\n        // internal flush signal\n        flush_en = 1'b1;\n        if (flush_done) begin\n          state_d     = IDLE;\n          flush_ack_o = flush_ack_q;\n          flush_ack_d = 1'b0;\n          enable_d    = enable_i;\n        end\n      end\n      //////////////////////////////////\n      // send out amo op request\n      AMO: begin\n        if (CVA6Cfg.RVA) begin\n          mem_data_o.rtype = DCACHE_ATOMIC_REQ;\n          amo_sel          = 1'b1;\n          // if this is an LR, we need to consult the backoff counter\n          if ((amo_req_i.amo_op != AMO_LR) || sc_backoff_over) begin\n            mem_data_req_o = 1'b1;\n            if (mem_data_ack_i) begin\n              state_d = AMO_WAIT;\n            end\n          end\n        end\n      end\n      //////////////////////////////////\n      // block and wait until AMO OP returns\n      AMO_WAIT: begin\n        if (CVA6Cfg.RVA) begin\n          amo_sel = 1'b1;\n          if (amo_ack) begin\n            amo_resp_o.ack = 1'b1;\n            state_d        = IDLE;\n          end\n        end\n      end\n      //////////////////////////////////\n      default: begin\n        // we should never get here\n        state_d = IDLE;\n      end\n    endcase  // state_q\n  end\n\n  ///////////////////////////////////////////////////////\n  // ff's\n  ///////////////////////////////////////////////////////\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs\n    if (!rst_ni) begin\n      state_q               <= FLUSH;\n      cnt_q                 <= '0;\n      enable_q              <= '0;\n      flush_ack_q           <= '0;\n      mshr_vld_q            <= '0;\n      mshr_vld_q1           <= '0;\n      mshr_q                <= '0;\n      mshr_rdrd_collision_q <= '0;\n      miss_req_masked_q     <= '0;\n      amo_req_q             <= '0;\n      stores_inflight_q     <= '0;\n    end else begin\n      state_q               <= state_d;\n      cnt_q                 <= cnt_d;\n      enable_q              <= enable_d;\n      flush_ack_q           <= flush_ack_d;\n      mshr_vld_q            <= mshr_vld_d;\n      mshr_vld_q1           <= mshr_vld_q;\n      mshr_q                <= mshr_d;\n      mshr_rdrd_collision_q <= mshr_rdrd_collision_d;\n      miss_req_masked_q     <= miss_req_masked_d;\n      amo_req_q             <= amo_req_d;\n      stores_inflight_q     <= stores_inflight_d;\n    end\n  end\n\n  ///////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////\n\n  //pragma translate_off\n`ifndef VERILATOR\n\n  read_tid :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) mshr_vld_q |-> mem_rtrn_vld_i |-> load_ack |-> mem_rtrn_i.tid == mshr_q.id)\n  else $fatal(1, \"[l1 dcache missunit] TID of load response doesn't match\");\n\n  read_ports :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) |miss_req_i[NumPorts-2:0] |-> miss_we_i[NumPorts-2:0] == 0)\n  else $fatal(1, \"[l1 dcache missunit] only last port can issue write requests\");\n\n  write_port :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) miss_req_i[NumPorts-1] |-> miss_we_i[NumPorts-1])\n  else $fatal(1, \"[l1 dcache missunit] last port can only issue write requests\");\n\n  initial begin\n    // assert wrong parameterizations\n    assert (NumPorts >= 2)\n    else\n      $fatal(\n          1, \"[l1 dcache missunit] at least two ports are required (one read port, one write port)\"\n      );\n  end\n`endif\n  //pragma translate_on\n\nendmodule  // wt_dcache_missunit\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 13.09.2018\n// Description: coalescing write buffer for WT dcache\n//\n// A couple of notes:\n//\n// 1) the write buffer behaves as a fully-associative cache, and is therefore coalescing.\n//    this cache is used by the cache readout logic to forward data to the load unit.\n//\n//    each byte can be in the following states (valid/dirty/txblock):\n//\n//    0/0/0:    invalid -> free entry in the buffer\n//    1/1/0:    valid and dirty, Byte is hence not part of TX in-flight\n//    1/0/1:    valid and not dirty, Byte is part of a TX in-flight\n//    1/1/1:    valid and, part of tx and dirty. this means that the byte has been\n//              overwritten while in TX and needs to be retransmitted once the write of that byte returns.\n//    1/0/0:    this would represent a clean state, but is never reached in the wbuffer in the current implementation.\n//              this is because when a TX returns, and the byte is in state [1/0/1], it is written to cache if needed and\n//              its state is immediately cleared to 0/x/x.\n//\n//    this state is used to distinguish between bytes that have been written and not\n//    yet sent to the memory subsystem, and bytes that are part of a transaction.\n//\n// 2) further, each word in the write buffer has a cache states (checked, hit_oh)\n//\n//    checked == 0: unknown cache state\n//    checked == 1: cache state has been looked up, valid way is stored in \"hit_oh\"\n//\n//    cache invalidations/refills affecting a particular word will clear its word state to 0,\n//    so another lookup has to be done. note that these lookups are triggered as soon as there is\n//    a valid word with checked == 0 in the write buffer.\n//\n// 3) returning write ACKs trigger a cache update if the word is present in the cache, and evict that\n//    word from the write buffer. if the word is not allocated to the cache, it is just evicted from the write buffer.\n//    if the word cache state is VOID, the pipeline is stalled until it is clear whether that word is in the cache or not.\n//\n// 4) we handle NC writes using the writebuffer circuitry. upon an NC request, the writebuffer will first be drained.\n//    then, only the NC word is written into the write buffer and no further write requests are acknowledged until that\n//    word has been evicted from the write buffer.\n\n\nmodule wt_dcache_wbuffer\n  import ariane_pkg::*;\n  import wt_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    input logic clk_i,  // Clock\n    input logic rst_ni, // Asynchronous reset active low\n\n    input logic cache_en_i,  // writes are treated as NC if disabled\n    output logic empty_o,  // asserted if no data is present in write buffer\n    output logic not_ni_o,  // asserted if no ni data is present in write buffer\n    // core request ports\n    input dcache_req_i_t req_port_i,\n    output dcache_req_o_t req_port_o,\n    // interface to miss handler\n    input logic miss_ack_i,\n    output logic [riscv::PLEN-1:0] miss_paddr_o,\n    output logic miss_req_o,\n    output logic miss_we_o,  // always 1 here\n    output riscv::xlen_t miss_wdata_o,\n    output logic [DCACHE_USER_WIDTH-1:0] miss_wuser_o,\n    output logic [DCACHE_SET_ASSOC-1:0] miss_vld_bits_o,  // unused here (set to 0)\n    output logic miss_nc_o,  // request to I/O space\n    output logic [2:0] miss_size_o,  //\n    output logic [CACHE_ID_WIDTH-1:0]          miss_id_o,       // ID of this transaction (wbuffer uses all IDs from 0 to DCACHE_MAX_TX-1)\n    // write responses from memory\n    input logic miss_rtrn_vld_i,\n    input logic [CACHE_ID_WIDTH-1:0] miss_rtrn_id_i,  // transaction ID to clear\n    // cache read interface\n    output logic [DCACHE_TAG_WIDTH-1:0] rd_tag_o,  // tag in - comes one cycle later\n    output logic [DCACHE_CL_IDX_WIDTH-1:0] rd_idx_o,\n    output logic [DCACHE_OFFSET_WIDTH-1:0] rd_off_o,\n    output logic rd_req_o,  // read the word at offset off_i[:3] in all ways\n    output logic rd_tag_only_o,  // set to 1 here as we do not have to read the data arrays\n    input logic rd_ack_i,\n    input riscv::xlen_t rd_data_i,  // unused\n    input logic [DCACHE_SET_ASSOC-1:0] rd_vld_bits_i,  // unused\n    input logic [DCACHE_SET_ASSOC-1:0] rd_hit_oh_i,\n    // cacheline writes\n    input logic wr_cl_vld_i,\n    input logic [DCACHE_CL_IDX_WIDTH-1:0] wr_cl_idx_i,\n    // cache word write interface\n    output logic [DCACHE_SET_ASSOC-1:0] wr_req_o,\n    input logic wr_ack_i,\n    output logic [DCACHE_CL_IDX_WIDTH-1:0] wr_idx_o,\n    output logic [DCACHE_OFFSET_WIDTH-1:0] wr_off_o,\n    output riscv::xlen_t wr_data_o,\n    output logic [(riscv::XLEN/8)-1:0] wr_data_be_o,\n    output logic [DCACHE_USER_WIDTH-1:0] wr_user_o,\n    // to forwarding logic and miss unit\n    output wbuffer_t [DCACHE_WBUF_DEPTH-1:0] wbuffer_data_o,\n    output logic [DCACHE_MAX_TX-1:0][riscv::PLEN-1:0]     tx_paddr_o,      // used to check for address collisions with read operations\n    output logic [DCACHE_MAX_TX-1:0] tx_vld_o\n);\n\n  tx_stat_t [DCACHE_MAX_TX-1:0] tx_stat_d, tx_stat_q;\n  wbuffer_t [DCACHE_WBUF_DEPTH-1:0] wbuffer_d, wbuffer_q;\n  logic [DCACHE_WBUF_DEPTH-1:0] valid;\n  logic [DCACHE_WBUF_DEPTH-1:0] dirty;\n  logic [DCACHE_WBUF_DEPTH-1:0] tocheck;\n  logic [DCACHE_WBUF_DEPTH-1:0] wbuffer_hit_oh, inval_hit;\n  //logic     [DCACHE_WBUF_DEPTH-1:0][7:0]    bdirty;\n  logic [DCACHE_WBUF_DEPTH-1:0][(riscv::XLEN/8)-1:0] bdirty;\n\n  logic [$clog2(DCACHE_WBUF_DEPTH)-1:0]\n      next_ptr, dirty_ptr, hit_ptr, wr_ptr, check_ptr_d, check_ptr_q, check_ptr_q1, rtrn_ptr;\n  logic [CACHE_ID_WIDTH-1:0] tx_id, rtrn_id;\n\n  logic [riscv::XLEN_ALIGN_BYTES-1:0] bdirty_off;\n  logic [(riscv::XLEN/8)-1:0] tx_be;\n  logic [riscv::PLEN-1:0] wr_paddr, rd_paddr, extract_tag;\n  logic [DCACHE_TAG_WIDTH-1:0] rd_tag_d, rd_tag_q;\n  logic [DCACHE_SET_ASSOC-1:0] rd_hit_oh_d, rd_hit_oh_q;\n  logic check_en_d, check_en_q, check_en_q1;\n  logic full, dirty_rd_en, rdy;\n  logic rtrn_empty, evict;\n  logic [DCACHE_WBUF_DEPTH-1:0] ni_pending_d, ni_pending_q;\n  logic wbuffer_wren;\n  logic free_tx_slots;\n\n  logic wr_cl_vld_q, wr_cl_vld_d;\n  logic [DCACHE_CL_IDX_WIDTH-1:0] wr_cl_idx_q, wr_cl_idx_d;\n\n  logic [riscv::PLEN-1:0] debug_paddr[DCACHE_WBUF_DEPTH-1:0];\n\n  wbuffer_t wbuffer_check_mux, wbuffer_dirty_mux;\n\n  ///////////////////////////////////////////////////////\n  // misc\n  ///////////////////////////////////////////////////////\n  logic [ariane_pkg::DCACHE_TAG_WIDTH-1:0] miss_tag;\n  logic is_nc_miss;\n  logic is_ni;\n  assign miss_tag = miss_paddr_o[ariane_pkg::DCACHE_INDEX_WIDTH+:ariane_pkg::DCACHE_TAG_WIDTH];\n  assign is_nc_miss = !config_pkg::is_inside_cacheable_regions(\n      CVA6Cfg,\n      {\n        {64 - DCACHE_TAG_WIDTH - DCACHE_INDEX_WIDTH{1'b0}}, miss_tag, {DCACHE_INDEX_WIDTH{1'b0}}\n      }\n  );\n  assign miss_nc_o = !cache_en_i || is_nc_miss;\n  // Non-idempotent if request goes to NI region\n  assign is_ni = config_pkg::is_inside_nonidempotent_regions(\n      CVA6Cfg,\n      {\n        {64 - DCACHE_TAG_WIDTH - DCACHE_INDEX_WIDTH{1'b0}},\n        req_port_i.address_tag,\n        {DCACHE_INDEX_WIDTH{1'b0}}\n      }\n  );\n\n  assign miss_we_o = 1'b1;\n  assign miss_vld_bits_o = '0;\n  assign wbuffer_data_o = wbuffer_q;\n\n  for (genvar k = 0; k < DCACHE_MAX_TX; k++) begin : gen_tx_vld\n    assign tx_vld_o[k] = tx_stat_q[k].vld;\n    assign tx_paddr_o[k] = {\n      {riscv::XLEN_ALIGN_BYTES{1'b0}}, wbuffer_q[tx_stat_q[k].ptr].wtag << riscv::XLEN_ALIGN_BYTES\n    };\n  end\n\n  ///////////////////////////////////////////////////////\n  // openpiton does not understand byte enable sigs\n  // need to convert to the four cases:\n  // 00: byte\n  // 01: halfword\n  // 10: word\n  // 11: dword\n  // non-contiguous writes need to be serialized!\n  // e.g. merged dwords with BE like this: 8'b01001100\n  ///////////////////////////////////////////////////////\n\n  // get byte offset\n  lzc #(\n      .WIDTH(riscv::XLEN / 8)\n  ) i_vld_bdirty (\n      .in_i   (bdirty[dirty_ptr]),\n      .cnt_o  (bdirty_off),\n      .empty_o()\n  );\n\n  // add the offset to the physical base address of this buffer entry\n  assign miss_paddr_o = {wbuffer_dirty_mux.wtag, bdirty_off};\n  assign miss_id_o = tx_id;\n\n  // is there any dirty word to be transmitted, and is there a free TX slot?\n  assign miss_req_o = (|dirty) && free_tx_slots;\n\n  // get size of aligned words, and the corresponding byte enables\n  // note: openpiton can only handle aligned offsets + size, and hence\n  // we have to split unaligned data into multiple transfers (see toSize64)\n  // e.g. if we have the following valid bytes: 0011_1001 -> TX0: 0000_0001, TX1: 0000_1000, TX2: 0011_0000\n  if (riscv::IS_XLEN64) begin : gen_size_64b\n    assign miss_size_o = {1'b0, toSize64(bdirty[dirty_ptr])};\n  end else begin : gen_size_32b\n    assign miss_size_o = {1'b0, toSize32(bdirty[dirty_ptr])};\n  end\n\n  // replicate transfers shorter than a dword\n  assign miss_wdata_o = riscv::IS_XLEN64 ? repData64(\n      wbuffer_dirty_mux.data, bdirty_off, miss_size_o[1:0]\n  ) : repData32(\n      wbuffer_dirty_mux.data, bdirty_off, miss_size_o[1:0]\n  );\n  if (ariane_pkg::DATA_USER_EN) begin\n    assign miss_wuser_o = riscv::IS_XLEN64 ? repData64(\n        wbuffer_dirty_mux.user, bdirty_off, miss_size_o[1:0]\n    ) : repData32(\n        wbuffer_dirty_mux.user, bdirty_off, miss_size_o[1:0]\n    );\n  end else begin\n    assign miss_wuser_o = '0;\n  end\n\n  assign tx_be = riscv::IS_XLEN64 ? to_byte_enable8(\n      bdirty_off, miss_size_o[1:0]\n  ) : to_byte_enable4(\n      bdirty_off, miss_size_o[1:0]\n  );\n\n  ///////////////////////////////////////////////////////\n  // TX status registers and ID counters\n  ///////////////////////////////////////////////////////\n\n  // TODO: todo: make this fall through if timing permits it\n  fifo_v3 #(\n      .FALL_THROUGH(1'b0),\n      .DATA_WIDTH  ($clog2(DCACHE_MAX_TX)),\n      .DEPTH       (DCACHE_MAX_TX)\n  ) i_rtrn_id_fifo (\n      .clk_i     (clk_i),\n      .rst_ni    (rst_ni),\n      .flush_i   (1'b0),\n      .testmode_i(1'b0),\n      .full_o    (),\n      .empty_o   (rtrn_empty),\n      .usage_o   (),\n      .data_i    (miss_rtrn_id_i),\n      .push_i    (miss_rtrn_vld_i),\n      .data_o    (rtrn_id),\n      .pop_i     (evict)\n  );\n\n  always_comb begin : p_tx_stat\n    tx_stat_d = tx_stat_q;\n    evict     = 1'b0;\n    wr_req_o  = '0;\n\n    // clear entry if it is clear whether it can be pushed to the cache or not\n    if ((!rtrn_empty) && wbuffer_q[rtrn_ptr].checked) begin\n      // check if data is clean and can be written, otherwise skip\n      // check if CL is present, otherwise skip\n      if ((|wr_data_be_o) && (|wbuffer_q[rtrn_ptr].hit_oh)) begin\n        wr_req_o = wbuffer_q[rtrn_ptr].hit_oh;\n        if (wr_ack_i) begin\n          evict    = 1'b1;\n          tx_stat_d[rtrn_id].vld = 1'b0;\n        end\n      end else begin\n        evict = 1'b1;\n        tx_stat_d[rtrn_id].vld = 1'b0;\n      end\n    end\n\n    // allocate a new entry\n    if (dirty_rd_en) begin\n      tx_stat_d[tx_id].vld = 1'b1;\n      tx_stat_d[tx_id].ptr = dirty_ptr;\n      tx_stat_d[tx_id].be  = tx_be;\n    end\n  end\n\n  assign free_tx_slots = |(~tx_vld_o);\n\n  // next word to lookup in the cache\n  rr_arb_tree #(\n      .NumIn    (DCACHE_MAX_TX),\n      .LockIn   (1'b1),\n      .DataWidth(1)\n  ) i_tx_id_rr (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i('0),\n      .rr_i   ('0),\n      .req_i  (~tx_vld_o),\n      .gnt_o  (),\n      .data_i ('0),\n      .gnt_i  (dirty_rd_en),\n      .req_o  (),\n      .data_o (),\n      .idx_o  (tx_id)\n  );\n\n  ///////////////////////////////////////////////////////\n  // cache readout & update\n  ///////////////////////////////////////////////////////\n\n  assign extract_tag = rd_paddr >> DCACHE_INDEX_WIDTH;\n  assign rd_tag_d = extract_tag[DCACHE_TAG_WIDTH-1:0];\n\n  // trigger TAG readout in cache\n  assign rd_tag_only_o = 1'b1;\n  assign rd_paddr = {\n    {riscv::XLEN_ALIGN_BYTES{1'b0}}, wbuffer_check_mux.wtag << riscv::XLEN_ALIGN_BYTES\n  };\n  assign rd_req_o = |tocheck;\n  assign rd_tag_o = rd_tag_q;  //delay by one cycle\n  assign rd_idx_o = rd_paddr[DCACHE_INDEX_WIDTH-1:DCACHE_OFFSET_WIDTH];\n  assign rd_off_o = rd_paddr[DCACHE_OFFSET_WIDTH-1:0];\n  assign check_en_d = rd_req_o & rd_ack_i;\n\n  // cache update port\n  assign rtrn_ptr = tx_stat_q[rtrn_id].ptr;\n  // if we wrote into a word while it was in-flight, we cannot write the dirty bytes to the cache\n  // when the TX returns\n  assign wr_data_be_o = tx_stat_q[rtrn_id].be & (~wbuffer_q[rtrn_ptr].dirty);\n  assign wr_paddr = {\n    {riscv::XLEN_ALIGN_BYTES{1'b0}}, wbuffer_q[rtrn_ptr].wtag << riscv::XLEN_ALIGN_BYTES\n  };\n  assign wr_idx_o = wr_paddr[DCACHE_INDEX_WIDTH-1:DCACHE_OFFSET_WIDTH];\n  assign wr_off_o = wr_paddr[DCACHE_OFFSET_WIDTH-1:0];\n  assign wr_data_o = wbuffer_q[rtrn_ptr].data;\n  assign wr_user_o = wbuffer_q[rtrn_ptr].user;\n\n\n  ///////////////////////////////////////////////////////\n  // readout of status bits, index calculation\n  ///////////////////////////////////////////////////////\n\n  logic [DCACHE_WBUF_DEPTH-1:0][DCACHE_CL_IDX_WIDTH-1:0] wtag_comp;\n\n  assign wr_cl_vld_d = wr_cl_vld_i;\n  assign wr_cl_idx_d = wr_cl_idx_i;\n\n  for (genvar k = 0; k < DCACHE_WBUF_DEPTH; k++) begin : gen_flags\n    // only for debug, will be pruned\n    if (CVA6Cfg.DebugEn) begin\n      assign debug_paddr[k] = {\n        {riscv::XLEN_ALIGN_BYTES{1'b0}}, wbuffer_q[k].wtag << riscv::XLEN_ALIGN_BYTES\n      };\n    end\n\n    // dirty bytes that are ready for transmission.\n    // note that we cannot retransmit a word that is already in-flight\n    // since the multiple transactions might overtake each other in the memory system!\n    assign bdirty[k] = (|wbuffer_q[k].txblock) ? '0 : wbuffer_q[k].dirty & wbuffer_q[k].valid;\n\n\n    assign dirty[k] = |bdirty[k];\n    assign valid[k] = |wbuffer_q[k].valid;\n    assign wbuffer_hit_oh[k] = valid[k] & (wbuffer_q[k].wtag == {req_port_i.address_tag, req_port_i.address_index[DCACHE_INDEX_WIDTH-1:riscv::XLEN_ALIGN_BYTES]});\n\n    // checks if an invalidation/cache refill hits a particular word\n    // note: an invalidation can hit multiple words!\n    // need to respect previous cycle, too, since we add a cycle of latency to the rd_hit_oh_i signal...\n    assign wtag_comp[k] = wbuffer_q[k].wtag[DCACHE_INDEX_WIDTH-riscv::XLEN_ALIGN_BYTES-1:DCACHE_OFFSET_WIDTH-riscv::XLEN_ALIGN_BYTES];\n    assign inval_hit[k]  = (wr_cl_vld_d & valid[k] & (wtag_comp[k] == wr_cl_idx_d)) |\n                           (wr_cl_vld_q & valid[k] & (wtag_comp[k] == wr_cl_idx_q));\n\n    // these word have to be looked up in the cache\n    assign tocheck[k] = (~wbuffer_q[k].checked) & valid[k];\n  end\n\n  assign wr_ptr = (|wbuffer_hit_oh) ? hit_ptr : next_ptr;\n  assign rdy    = (|wbuffer_hit_oh) | (~full);\n\n  // next free entry in the buffer\n  lzc #(\n      .WIDTH(DCACHE_WBUF_DEPTH)\n  ) i_vld_lzc (\n      .in_i   (~valid),\n      .cnt_o  (next_ptr),\n      .empty_o(full)\n  );\n\n  // get index of hit\n  lzc #(\n      .WIDTH(DCACHE_WBUF_DEPTH)\n  ) i_hit_lzc (\n      .in_i   (wbuffer_hit_oh),\n      .cnt_o  (hit_ptr),\n      .empty_o()\n  );\n\n  // next dirty word to serve\n  rr_arb_tree #(\n      .NumIn   (DCACHE_WBUF_DEPTH),\n      .LockIn  (1'b1),\n      .DataType(wbuffer_t)\n  ) i_dirty_rr (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i('0),\n      .rr_i   ('0),\n      .req_i  (dirty),\n      .gnt_o  (),\n      .data_i (wbuffer_q),\n      .gnt_i  (dirty_rd_en),\n      .req_o  (),\n      .data_o (wbuffer_dirty_mux),\n      .idx_o  (dirty_ptr)\n  );\n\n  // next word to lookup in the cache\n  rr_arb_tree #(\n      .NumIn   (DCACHE_WBUF_DEPTH),\n      .DataType(wbuffer_t)\n  ) i_clean_rr (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i('0),\n      .rr_i   ('0),\n      .req_i  (tocheck),\n      .gnt_o  (),\n      .data_i (wbuffer_q),\n      .gnt_i  (check_en_d),\n      .req_o  (),\n      .data_o (wbuffer_check_mux),\n      .idx_o  (check_ptr_d)\n  );\n\n  ///////////////////////////////////////////////////////\n  // update logic\n  ///////////////////////////////////////////////////////\n\n  assign req_port_o.data_rvalid = '0;\n  assign req_port_o.data_rdata  = '0;\n  assign req_port_o.data_ruser  = '0;\n  assign req_port_o.data_rid    = '0;\n\n  assign rd_hit_oh_d = rd_hit_oh_i;\n\n  logic ni_inside, ni_conflict;\n  assign ni_inside = |ni_pending_q;\n  assign ni_conflict = CVA6Cfg.NonIdemPotenceEn && is_ni && ni_inside;\n  assign not_ni_o = !ni_inside;\n  assign empty_o    = !(|valid);\n\n  // TODO: rewrite and separate into MUXES and write strobe logic\n  always_comb begin : p_buffer\n    wbuffer_d           = wbuffer_q;\n    ni_pending_d        = ni_pending_q;\n    dirty_rd_en         = 1'b0;\n    req_port_o.data_gnt = 1'b0;\n    wbuffer_wren        = 1'b0;\n\n    // TAG lookup returns, mark corresponding word\n    if (check_en_q1) begin\n      if (|wbuffer_q[check_ptr_q1].valid) begin\n        wbuffer_d[check_ptr_q1].checked = 1'b1;\n        wbuffer_d[check_ptr_q1].hit_oh  = rd_hit_oh_q;\n      end\n    end\n\n    // if an invalidation or cache line refill comes in and hits on the write buffer,\n    // we have to discard our knowledge of the corresponding cacheline state\n    for (int k = 0; k < DCACHE_WBUF_DEPTH; k++) begin\n      if (inval_hit[k]) begin\n        wbuffer_d[k].checked = 1'b0;\n      end\n    end\n\n    // once TX write response came back, we can clear the TX block. if it was not dirty, we\n    // can completely evict it - otherwise we have to leave it there for retransmission\n    if (evict) begin\n      for (int k = 0; k < (riscv::XLEN / 8); k++) begin\n        if (tx_stat_q[rtrn_id].be[k]) begin\n          wbuffer_d[rtrn_ptr].txblock[k] = 1'b0;\n          if (!wbuffer_q[rtrn_ptr].dirty[k]) begin\n            wbuffer_d[rtrn_ptr].valid[k] = 1'b0;\n\n            // NOTE: this is not strictly needed, but makes it much\n            // easier to debug, since no invalid data remains in the buffer\n            // wbuffer_d[rtrn_ptr].data[k*8 +:8] = '0;\n          end\n        end\n      end\n      // if all bytes are evicted, clear the cache status flag\n      if (wbuffer_d[rtrn_ptr].valid == 0) begin\n        wbuffer_d[rtrn_ptr].checked = 1'b0;\n        ni_pending_d[rtrn_ptr] = 1'b0;\n      end\n    end\n\n    // mark bytes sent out to the memory system\n    if (miss_req_o && miss_ack_i) begin\n      dirty_rd_en = 1'b1;\n      for (int k = 0; k < (riscv::XLEN / 8); k++) begin\n        if (tx_be[k]) begin\n          wbuffer_d[dirty_ptr].dirty[k]   = 1'b0;\n          wbuffer_d[dirty_ptr].txblock[k] = 1'b1;\n        end\n      end\n    end\n\n    // write new word into the buffer\n    if (req_port_i.data_req && rdy) begin\n      // in case we have an NI address, need to drain the buffer first\n      // in case we are serving an NI address,  we block until it is written to memory\n      if (!ni_conflict) begin  //empty of NI operations\n        wbuffer_wren = 1'b1;\n\n        req_port_o.data_gnt = 1'b1;\n        ni_pending_d[wr_ptr] = is_ni;\n\n        wbuffer_d[wr_ptr].checked = 1'b0;\n        wbuffer_d[wr_ptr].wtag = {\n          req_port_i.address_tag,\n          req_port_i.address_index[DCACHE_INDEX_WIDTH-1:riscv::XLEN_ALIGN_BYTES]\n        };\n\n        // mark bytes as dirty\n        for (int k = 0; k < (riscv::XLEN / 8); k++) begin\n          if (req_port_i.data_be[k]) begin\n            wbuffer_d[wr_ptr].valid[k]     = 1'b1;\n            wbuffer_d[wr_ptr].dirty[k]     = 1'b1;\n            wbuffer_d[wr_ptr].data[k*8+:8] = req_port_i.data_wdata[k*8+:8];\n            if (ariane_pkg::DATA_USE"}
{"text": "R_EN) begin\n              wbuffer_d[wr_ptr].user[k*8+:8] = req_port_i.data_wuser[k*8+:8];\n            end else begin\n              wbuffer_d[wr_ptr].user[k*8+:8] = '0;\n            end\n          end\n        end\n      end\n    end\n  end\n\n\n  ///////////////////////////////////////////////////////\n  // ff's\n  ///////////////////////////////////////////////////////\n\n  always_ff @(posedge clk_i or negedge rst_ni) begin : p_regs\n    if (!rst_ni) begin\n      wbuffer_q    <= '{default: '0};\n      tx_stat_q    <= '{default: '0};\n      ni_pending_q <= '0;\n      check_ptr_q  <= '0;\n      check_ptr_q1 <= '0;\n      check_en_q   <= '0;\n      check_en_q1  <= '0;\n      rd_tag_q     <= '0;\n      rd_hit_oh_q  <= '0;\n      wr_cl_vld_q  <= '0;\n      wr_cl_idx_q  <= '0;\n    end else begin\n      wbuffer_q    <= wbuffer_d;\n      tx_stat_q    <= tx_stat_d;\n      ni_pending_q <= ni_pending_d;\n      check_ptr_q  <= check_ptr_d;\n      check_ptr_q1 <= check_ptr_q;\n      check_en_q   <= check_en_d;\n      check_en_q1  <= check_en_q;\n      rd_tag_q     <= rd_tag_d;\n      rd_hit_oh_q  <= rd_hit_oh_d;\n      wr_cl_vld_q  <= wr_cl_vld_d;\n      wr_cl_idx_q  <= wr_cl_idx_d;\n    end\n  end\n\n\n  ///////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////\n\n  //pragma translate_off\n`ifndef VERILATOR\n\n  hot1 :\n  assert property (@(posedge clk_i) disable iff (!rst_ni) req_port_i.data_req |-> $onehot0(\n      wbuffer_hit_oh\n  ))\n  else $fatal(1, \"[l1 dcache wbuffer] wbuffer_hit_oh signal must be hot1\");\n\n  tx_status :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) evict && miss_ack_i && miss_req_o |-> (tx_id != rtrn_id))\n  else $fatal(1, \"[l1 dcache wbuffer] cannot allocate and clear same tx slot id in the same cycle\");\n\n  tx_valid0 :\n  assert property (@(posedge clk_i) disable iff (!rst_ni) evict |-> tx_stat_q[rtrn_id].vld)\n  else $fatal(1, \"[l1 dcache wbuffer] evicting invalid transaction slot\");\n\n  tx_valid1 :\n  assert property (@(posedge clk_i) disable iff (!rst_ni) evict |-> |wbuffer_q[rtrn_ptr].valid)\n  else $fatal(1, \"[l1 dcache wbuffer] wbuffer entry corresponding to this transaction is invalid\");\n\n  write_full :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) req_port_i.data_req |-> req_port_o.data_gnt |-> ((!full) || (|wbuffer_hit_oh)))\n  else $fatal(1, \"[l1 dcache wbuffer] cannot write if full or no hit\");\n\n  unused0 :\n  assert property (@(posedge clk_i) disable iff (!rst_ni) !req_port_i.tag_valid)\n  else $fatal(1, \"[l1 dcache wbuffer] req_port_i.tag_valid should not be asserted\");\n\n  unused1 :\n  assert property (@(posedge clk_i) disable iff (!rst_ni) !req_port_i.kill_req)\n  else $fatal(1, \"[l1 dcache wbuffer] req_port_i.kill_req should not be asserted\");\n\n  for (genvar k = 0; k < DCACHE_WBUF_DEPTH; k++) begin : gen_assert1\n    for (genvar j = 0; j < (riscv::XLEN / 8); j++) begin : gen_assert2\n      byteStates :\n      assert property (\n        @(posedge clk_i) disable iff (!rst_ni) {wbuffer_q[k].valid[j], wbuffer_q[k].dirty[j], wbuffer_q[k].txblock[j]} inside {3'b000, 3'b110, 3'b101, 3'b111} )\n      else\n        $fatal(\n            1,\n            \"[l1 dcache wbuffer] byte %02d of wbuffer entry %02d has invalid state: valid=%01b, dirty=%01b, txblock=%01b\",\n            j,\n            k,\n            wbuffer_q[k].valid[j],\n            wbuffer_q[k].dirty[j],\n            wbuffer_q[k].txblock[j]\n        );\n    end\n  end\n`endif\n  //pragma translate_on\n\nendmodule  // wt_dcache_wbuffer\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// Author: Michael Schaffner <schaffner@iis.ee.ethz.ch>, ETH Zurich\n// Date: 08.08.2018\n// Description: adapter module to connect the L1D$ and L1I$ to the native\n// interface of the OpenPiton L1.5 cache.\n//\n// A couple of notes:\n//\n// 1) the L15 has been designed for an OpenSparc T1 core with 2 threads and can serve only\n//    1 ld and rd request per thread. Ariane has only one hart, but the LSU can issue several write\n//    requests to optimize bandwidth. hence, we reuse the threadid field to issue and track multiple\n//    requests (up to 2 in this case).\n//\n// 2) the CSM (clumped shared memory = coherence domain restriction in OpenPiton)\n//    feature is currently not supported by Ariane.\n//\n// 3) some features like blockinitstore, prefetch, ECC errors are not used (see interface below)\n//\n// 4) the arbiter can store upt to two outgoing requests per cache. incoming responses are passed\n//    through one streaming register, and need to be consumed unconditionally by the caches.\n//\n// 5) The L1.5 protocol is closely related to the CPX bus of openSPARC, see also [1,2]\n//\n// 6) Note on transaction data and size: if a store packet is less than 64 bits, then\n//    the field is filled with copies of the data. in case of an interrupt vector,\n//    an 18bit interrupt vector is expected.\n//\n// 7) L1I$ refill requests always have precedence over L1D$ requests.\n//\n// 8) L1I$ fill requests are always complete cache lines at the moment\n//\n// 9) the adapter converts from little endian (Ariane) to big endian (openpiton), and vice versa.\n//\n// 10) L1I$ requests to I.O space (bit39 of address = 1'b1) always return 32bit nc data\n//\n// Refs: [1] OpenSPARC T1 Microarchitecture Specification\n//           https://www.oracle.com/technetwork/systems/opensparc/t1-01-opensparct1-micro-arch-1538959.html\n//       [2] OpenPiton Microarchitecture Specification\n//           https://parallel.princeton.edu/openpiton/docs/micro_arch.pdf\n//\n\n\nmodule wt_l15_adapter\n  import ariane_pkg::*;\n  import wt_cache_pkg::*;\n#(\n    parameter config_pkg::cva6_cfg_t CVA6Cfg = config_pkg::cva6_cfg_empty\n) (\n    input logic clk_i,\n    input logic rst_ni,\n\n    // icache\n    input  logic         icache_data_req_i,\n    output logic         icache_data_ack_o,\n    input  icache_req_t  icache_data_i,\n    // returning packets must be consumed immediately\n    output logic         icache_rtrn_vld_o,\n    output icache_rtrn_t icache_rtrn_o,\n\n    // dcache\n    input  logic         dcache_data_req_i,\n    output logic         dcache_data_ack_o,\n    input  dcache_req_t  dcache_data_i,\n    // returning packets must be consumed immediately\n    output logic         dcache_rtrn_vld_o,\n    output dcache_rtrn_t dcache_rtrn_o,\n\n    // L15\n    output l15_req_t  l15_req_o,\n    input  l15_rtrn_t l15_rtrn_i\n);\n\n  // request path\n  icache_req_t icache_data;\n  logic icache_data_full, icache_data_empty;\n\n  dcache_req_t dcache_data;\n  logic dcache_data_full, dcache_data_empty;\n\n  logic [1:0] arb_req, arb_ack;\n  logic arb_idx;\n\n  // return path\n  logic rtrn_fifo_empty, rtrn_fifo_full, rtrn_fifo_pop;\n  l15_rtrn_t rtrn_fifo_data;\n\n\n  ///////////////////////////////////////////////////////\n  // request path to L15\n  ///////////////////////////////////////////////////////\n\n  // relevant l15 signals\n  // l15_req_t                          l15_req_o.l15_rqtype;                // see below for encoding\n  // logic                              l15_req_o.l15_nc;                    // non-cacheable bit\n  // logic [2:0]                        l15_req_o.l15_size;                  // transaction size: 000=Byte 001=2Byte; 010=4Byte; 011=8Byte; 111=Cache line (16/32Byte)\n  // logic [L15_TID_WIDTH-1:0]          l15_req_o.l15_threadid;              // currently 0 or 1\n  // logic                              l15_req_o.l15_invalidate_cacheline;  // unused by Ariane as L1 has no ECC at the moment\n  // logic [L15_WAY_WIDTH-1:0]          l15_req_o.l15_l1rplway;              // way to replace\n  // logic [39:0]                       l15_req_o.l15_address;               // physical address\n  // logic [63:0]                       l15_req_o.l15_data;                  // word to write\n  // logic [63:0]                       l15_req_o.l15_data_next_entry;       // unused in Ariane (only used for CAS atomic requests)\n  // logic [L15_TLB_CSM_WIDTH-1:0]      l15_req_o.l15_csm_data;\n\n\n  assign icache_data_ack_o = icache_data_req_i & ~icache_data_full;\n  assign dcache_data_ack_o = dcache_data_req_i & ~dcache_data_full;\n\n  // data mux\n  assign l15_req_o.l15_nc = (arb_idx) ? dcache_data.nc : icache_data.nc;\n  // icache fills are either cachelines or 4byte fills, depending on whether they go to the Piton I/O space or not.\n  assign l15_req_o.l15_size = (arb_idx) ? dcache_data.size : (icache_data.nc) ? 3'b010 : 3'b111;\n  assign l15_req_o.l15_threadid = (arb_idx) ? dcache_data.tid : icache_data.tid;\n  assign l15_req_o.l15_prefetch = '0;  // unused in openpiton\n  assign l15_req_o.l15_invalidate_cacheline = '0; // unused by Ariane as L1 has no ECC at the moment\n  assign l15_req_o.l15_blockstore = '0;  // unused in openpiton\n  assign l15_req_o.l15_blockinitstore = '0;  // unused in openpiton\n  assign l15_req_o.l15_l1rplway = (arb_idx) ? dcache_data.way : icache_data.way;\n\n  assign l15_req_o.l15_address = (arb_idx) ? dcache_data.paddr : icache_data.paddr;\n\n  assign l15_req_o.l15_data_next_entry      = '0; // unused in Ariane (only used for CAS atomic requests)\n  assign l15_req_o.l15_csm_data             = '0; // unused in Ariane (only used for coherence domain restriction features)\n  assign l15_req_o.l15_amo_op = dcache_data.amo_op;\n\n\n  // openpiton is big endian\n  if (CVA6Cfg.NOCType == config_pkg::NOC_TYPE_L15_BIG_ENDIAN)\n    assign l15_req_o.l15_data = swendian64(dcache_data.data);\n  else if (CVA6Cfg.NOCType == config_pkg::NOC_TYPE_L15_LITTLE_ENDIAN)\n    assign l15_req_o.l15_data = dcache_data.data;\n  else $fatal(1, \"[wt_l15_adapter] Unsupported NOC type\");\n\n  // arbiter\n  rrarbiter #(\n      .NUM_REQ(2),\n      .LOCK_IN(1)\n  ) i_rrarbiter (\n      .clk_i  (clk_i),\n      .rst_ni (rst_ni),\n      .flush_i('0),\n      .en_i   (l15_rtrn_i.l15_ack),\n      .req_i  (arb_req),\n      .ack_o  (arb_ack),\n      .vld_o  (),\n      .idx_o  (arb_idx)\n  );\n\n  assign arb_req           = {~dcache_data_empty, ~icache_data_empty};\n  assign l15_req_o.l15_val = (|arb_req);  // & ~header_ack_q;\n\n  // encode packet type\n  always_comb begin : p_req\n    l15_req_o.l15_rqtype = L15_LOAD_RQ;\n\n    unique case (arb_idx)\n      0: begin  // icache\n        l15_req_o.l15_rqtype = L15_IMISS_RQ;\n      end\n      1: begin\n        unique case (dcache_data.rtype)\n          DCACHE_STORE_REQ: begin\n            l15_req_o.l15_rqtype = L15_STORE_RQ;\n          end\n          DCACHE_LOAD_REQ: begin\n            l15_req_o.l15_rqtype = L15_LOAD_RQ;\n          end\n          DCACHE_ATOMIC_REQ: begin\n            l15_req_o.l15_rqtype = L15_ATOMIC_RQ;\n          end\n          // DCACHE_INT_REQ: begin\n          //     //TODO interrupt requests\n          // end\n          default: begin\n            ;\n          end\n        endcase  // dcache_data.rtype\n      end\n      default: begin\n        ;\n      end\n    endcase\n  end  // p_req\n\n  fifo_v2 #(\n      .dtype(icache_req_t),\n      .DEPTH(ADAPTER_REQ_FIFO_DEPTH)\n  ) i_icache_data_fifo (\n      .clk_i      (clk_i),\n      .rst_ni     (rst_ni),\n      .flush_i    (1'b0),\n      .testmode_i (1'b0),\n      .full_o     (icache_data_full),\n      .empty_o    (icache_data_empty),\n      .alm_full_o (),\n      .alm_empty_o(),\n      .data_i     (icache_data_i),\n      .push_i     (icache_data_ack_o),\n      .data_o     (icache_data),\n      .pop_i      (arb_ack[0])\n  );\n\n  fifo_v2 #(\n      .dtype(dcache_req_t),\n      .DEPTH(ADAPTER_REQ_FIFO_DEPTH)\n  ) i_dcache_data_fifo (\n      .clk_i      (clk_i),\n      .rst_ni     (rst_ni),\n      .flush_i    (1'b0),\n      .testmode_i (1'b0),\n      .full_o     (dcache_data_full),\n      .empty_o    (dcache_data_empty),\n      .alm_full_o (),\n      .alm_empty_o(),\n      .data_i     (dcache_data_i),\n      .push_i     (dcache_data_ack_o),\n      .data_o     (dcache_data),\n      .pop_i      (arb_ack[1])\n  );\n\n  ///////////////////////////////////////////////////////\n  // return path from L15\n  ///////////////////////////////////////////////////////\n\n  // relevant l15 signals\n  // l15_rtrn_i.l15_returntype;            // see below for encoding\n  // l15_rtrn_i.l15_noncacheable;          // non-cacheable bit\n  // l15_rtrn_i.l15_atomic;                // asserted in load return and store ack pack\n  // l15_rtrn_i.l15_threadid;              // used as transaction ID\n  // l15_rtrn_i.l15_f4b;                   // 4byte instruction fill from I/O space (nc).\n  // l15_rtrn_i.l15_data_0;                // used for both caches\n  // l15_rtrn_i.l15_data_1;                // used for both caches\n  // l15_rtrn_i.l15_data_2;                // currently only used for I$\n  // l15_rtrn_i.l15_data_3;                // currently only used for I$\n  // l15_rtrn_i.l15_inval_icache_all_way;  // invalidate all ways\n  // l15_rtrn_i.l15_inval_address_15_4;    // invalidate selected cacheline\n  // l15_rtrn_i.l15_inval_dcache_inval;    // invalidate selected cacheline and way\n  // l15_rtrn_i.l15_inval_way;             // way to invalidate\n\n  // acknowledge if we have space to hold this packet\n  assign l15_req_o.l15_req_ack = l15_rtrn_i.l15_val & ~rtrn_fifo_full;\n  // packets have to be consumed immediately\n  assign rtrn_fifo_pop = ~rtrn_fifo_empty;\n\n  // decode packet type\n  always_comb begin : p_rtrn_logic\n    icache_rtrn_o.rtype = ICACHE_IFILL_ACK;\n    dcache_rtrn_o.rtype = DCACHE_LOAD_ACK;\n    icache_rtrn_vld_o   = 1'b0;\n    dcache_rtrn_vld_o   = 1'b0;\n    if (!rtrn_fifo_empty) begin\n      unique case (rtrn_fifo_data.l15_returntype)\n        L15_LOAD_RET: begin\n          dcache_rtrn_o.rtype = DCACHE_LOAD_ACK;\n          dcache_rtrn_vld_o   = 1'b1;\n        end\n        L15_ST_ACK: begin\n          dcache_rtrn_o.rtype = DCACHE_STORE_ACK;\n          dcache_rtrn_vld_o   = 1'b1;\n        end\n        L15_IFILL_RET: begin\n          icache_rtrn_o.rtype = ICACHE_IFILL_ACK;\n          icache_rtrn_vld_o   = 1'b1;\n        end\n        L15_EVICT_REQ: begin\n          icache_rtrn_o.rtype = ICACHE_INV_REQ;\n          dcache_rtrn_o.rtype = DCACHE_INV_REQ;\n          icache_rtrn_vld_o   = icache_rtrn_o.inv.vld | icache_rtrn_o.inv.all;\n          dcache_rtrn_vld_o   = dcache_rtrn_o.inv.vld | dcache_rtrn_o.inv.all;\n        end\n        L15_CPX_RESTYPE_ATOMIC_RES: begin\n          dcache_rtrn_o.rtype = DCACHE_ATOMIC_ACK;\n          dcache_rtrn_vld_o   = 1'b1;\n        end\n        // L15_INT_RET:   begin\n        // TODO: implement this\n        // dcache_rtrn_o.reqType = DCACHE_INT_ACK;\n        // end\n        default: begin\n          ;\n        end\n      endcase  // rtrn_fifo_data.l15_returntype\n    end\n  end\n\n  // openpiton is big endian\n  if (SwapEndianess) begin : gen_swap\n    assign dcache_rtrn_o.data = {\n      swendian64(rtrn_fifo_data.l15_data_1), swendian64(rtrn_fifo_data.l15_data_0)\n    };\n\n    assign icache_rtrn_o.data = {\n      swendian64(rtrn_fifo_data.l15_data_3),\n      swendian64(rtrn_fifo_data.l15_data_2),\n      swendian64(rtrn_fifo_data.l15_data_1),\n      swendian64(rtrn_fifo_data.l15_data_0)\n    };\n  end else begin : gen_no_swap\n    assign dcache_rtrn_o.data = {rtrn_fifo_data.l15_data_1, rtrn_fifo_data.l15_data_0};\n\n    assign icache_rtrn_o.data = {\n      rtrn_fifo_data.l15_data_3,\n      rtrn_fifo_data.l15_data_2,\n      rtrn_fifo_data.l15_data_1,\n      rtrn_fifo_data.l15_data_0\n    };\n  end\n\n  // fifo signals\n  assign icache_rtrn_o.tid     = rtrn_fifo_data.l15_threadid;\n  assign dcache_rtrn_o.tid     = rtrn_fifo_data.l15_threadid;\n\n  // invalidation signal mapping\n  assign icache_rtrn_o.inv.idx = {rtrn_fifo_data.l15_inval_address_15_4, 4'b0000};\n  assign icache_rtrn_o.inv.way = rtrn_fifo_data.l15_inval_way;\n  assign icache_rtrn_o.inv.vld = rtrn_fifo_data.l15_inval_icache_inval;\n  assign icache_rtrn_o.inv.all = rtrn_fifo_data.l15_inval_icache_all_way;\n\n  assign dcache_rtrn_o.inv.idx = {rtrn_fifo_data.l15_inval_address_15_4, 4'b0000};\n  assign dcache_rtrn_o.inv.way = rtrn_fifo_data.l15_inval_way;\n  assign dcache_rtrn_o.inv.vld = rtrn_fifo_data.l15_inval_dcache_inval;\n  assign dcache_rtrn_o.inv.all = rtrn_fifo_data.l15_inval_dcache_all_way;\n\n  fifo_v2 #(\n      .dtype(l15_rtrn_t),\n      .DEPTH(ADAPTER_RTRN_FIFO_DEPTH)\n  ) i_rtrn_fifo (\n      .clk_i      (clk_i),\n      .rst_ni     (rst_ni),\n      .flush_i    (1'b0),\n      .testmode_i (1'b0),\n      .full_o     (rtrn_fifo_full),\n      .empty_o    (rtrn_fifo_empty),\n      .alm_full_o (),\n      .alm_empty_o(),\n      .data_i     (l15_rtrn_i),\n      .push_i     (l15_req_o.l15_req_ack),\n      .data_o     (rtrn_fifo_data),\n      .pop_i      (rtrn_fifo_pop)\n  );\n\n\n  ///////////////////////////////////////////////////////\n  // assertions\n  ///////////////////////////////////////////////////////\n\n  //pragma translate_off\n`ifndef VERILATOR\n\n  invalidations :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) l15_rtrn_i.l15_val |-> l15_rtrn_i.l15_returntype == L15_EVICT_REQ |-> (l15_rtrn_i.l15_inval_icache_inval    |\n                                                                                                                  l15_rtrn_i.l15_inval_dcache_inval    |\n                                                                                                                  l15_rtrn_i.l15_inval_icache_all_way  |\n                                                                                                                  l15_rtrn_i.l15_inval_dcache_all_way))\n  else $fatal(1, \"[l15_adapter] got invalidation package with zero invalidation flags\");\n\n  blockstore_o :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) l15_req_o.l15_val |-> l15_req_o.l15_rqtype == L15_STORE_RQ |-> !(l15_req_o.l15_blockstore || l15_req_o.l15_blockinitstore))\n  else $fatal(1, \"[l15_adapter] blockstores are not supported (out)\");\n\n  blockstore_i :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) l15_rtrn_i.l15_val |-> l15_rtrn_i.l15_returntype inside {L15_ST_ACK, L15_ST_ACK} |-> !l15_rtrn_i.l15_blockinitstore)\n  else $fatal(1, \"[l15_adapter] blockstores are not supported (in)\");\n\n  unsuported_rtrn_types :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) (l15_rtrn_i.l15_val |-> l15_rtrn_i.l15_returntype inside {L15_LOAD_RET, L15_ST_ACK, L15_IFILL_RET, L15_EVICT_REQ, L15_CPX_RESTYPE_ATOMIC_RES}))\n  else\n    $warning(\n        \"[l15_adapter] return type %X04 is not (yet) supported by l15 adapter.\",\n        l15_rtrn_i.l15_returntype\n    );\n\n  amo_type :\n  assert property (\n    @(posedge clk_i) disable iff (!rst_ni) (l15_rtrn_i.l15_val |-> l15_rtrn_i.l15_returntype inside {L15_CPX_RESTYPE_ATOMIC_RES} |-> l15_rtrn_i.l15_atomic ))\n  else $fatal(1, \"[l15_adapter] l15_atomic must be asserted when the return type is an ATOMIC_RES\");\n\n  initial begin\n    // assert wrong parameterizations\n    assert (L15_SET_ASSOC >= ICACHE_SET_ASSOC)\n    else\n      $fatal(\n          1, \"[l15_adapter] number of icache ways must be smaller or equal the number of L15 ways\"\n      );\n    // assert wrong parameterizations\n    assert (L15_SET_ASSOC >= DCACHE_SET_ASSOC)\n    else\n      $fatal(\n          1, \"[l15_adapter] number of dcache ways must be smaller or equal the number of L15 ways\"\n      );\n    // invalidation address returned by L1.5 is 16 bit\n    assert (16 >= DCACHE_INDEX_WIDTH && 16 >= ICACHE_INDEX_WIDTH)\n    else $fatal(1, \"[l15_adapter] maximum number of index bits supported by L1.5 is 16\");\n  end\n`endif\n  //pragma translate_on\n\nendmodule  // wt_l15_adapter\n"}
