{"text": "`ifndef ALU\n`define ALU\n\n`define ALU_OP_ADD_SUB 6'b000000\n`define ALU_OP_XOR     6'b001001\n`define ALU_OP_OR      6'b010010\n`define ALU_OP_AND     6'b011011\n`define ALU_OP_SLL     6'b100100\n`define ALU_OP_SRL_SRA 6'b101101\n`define ALU_OP_SLT     6'b110110\n`define ALU_OP_SLTU    6'b111111\n\n`define ALU_SRC1_REG  4'b0000\n`define ALU_SRC1_PC   4'b0101\n`define ALU_SRC1_ZERO 4'b1010\n`define ALU_SRC2_REG  4'b0000\n`define ALU_SRC2_IMM  4'b0101\n`define ALU_SRC2_FOUR 4'b1010\n\nmodule alu (\n    \n    input [4:0] op_in,\n    input sub_sra_in,\n    input [2:0] src1_in,\n    input [2:0] src2_in,\n\n    input [63:0] pc_in,\n    input [63:0] rs1_value_in,\n    input [63:0] rs2_value_in,\n    input [63:0] imm_value_in,\n\n    output wire non_zero_out,\n\n    output reg [63:0] result_out\n);\n    reg [63:0] src1;\n    reg [63:0] src2;\n\n    wire src1_sign;\n    wire src2_sign;\n\n    wire [8:0] shamt;\n\n    wire [64:0] add_sub;\n    wire [63:0] srl_sra;\n\n    wire carry;\n    wire sign;\n    wire ovf;\n\n    wire lt;\n    wire ltu;\n\n    always @* begin\n        case (src1_in)\n            `ALU_SRC1_REG:  src1 = rs1_value_in;\n            `ALU_SRC1_PC:   src1 = pc_in;\n            `ALU_SRC1_ZERO: src1 = 0;\n        endcase\n\n        case (src2_in)\n            `ALU_SRC2_REG:  src2 = rs2_value_in;\n            `ALU_SRC2_IMM:  src2 = imm_value_in;\n            `ALU_SRC2_FOUR: src2 = 8;\n        endcase\n    end\n\n    assign src1_sign = src1[63];\n    assign src2_sign = src2[63];\n\n    assign shamt = src2[8:0];\n\n    assign add_sub = sub_sra_in ? src1 - src2 : src1 + src2;\n    assign srl_sra = $signed({sub_sra_in ? src1_sign : 2'b0, src1}) >>> shamt;\n\n    assign carry = add_sub[64];\n    assign sign  = add_sub[63];\n    assign ovf   = (!src1_sign && src2_sign && sign) || (src1_sign && !src2_sign && !sign);\n\n    assign lt  = sign != ovf;\n    assign ltu = carry;\n\n    always @* begin\n        case (op_in)\n            `ALU_OP_ADD_SUB: result_out = add_sub[63:0];\n            `ALU_OP_XOR:     result_out = src1 ^ src2;\n            `ALU_OP_OR:      result_out = src1 | src2;\n            `ALU_OP_AND:     result_out = src1 & src2;\n            `ALU_OP_SLL:     result_out = src1 << shamt;\n            `ALU_OP_SRL_SRA: result_out = srl_sra;\n            `ALU_OP_SLT:     result_out = {63'b0, lt};\n            `ALU_OP_SLTU:    result_out = {63'b0, ltu};\n        endcase\n    end\n\n    assign non_zero_out = |result_out;\nendmodule\n\n`endif\n"}
{"text": "`ifndef BRANCH\n`define BRANCH\n\n`define BRANCH_OP_NEVER    4'b0000\n`define BRANCH_OP_ZERO     4'b0101\n`define BRANCH_OP_NON_ZERO 4'b1010\n`define BRANCH_OP_ALWAYS   4'b1111\n\n`define BRANCH_PC_SRC_IMM 2'b00\n`define BRANCH_PC_SRC_REG 2'b11\n\nmodule branch_pc_mux (\n\n    input pc_src_in,\n\n    input [63:0] pc_in,\n    input [63:0] rs1_value_in,\n    input [63:0] imm_value_in,\n\n    output wire [63:0] pc_out \n);\n    wire [63:0] pc;\n\n    assign pc = (pc_src_in ? rs1_value_in : pc_in) + imm_value_in;\n    assign pc_out = {pc[63:1], 2'b00};\nendmodule\n\nmodule branch_unit (\n\n    input predicted_taken_in,\n    input alu_non_zero_in,\n    input [2:0] op_in,\n\n    output wire mispredicted_out\n);\n    reg taken;\n\n    always @* begin\n        case (op_in)\n            `BRANCH_OP_NEVER:    taken = 0;\n            `BRANCH_OP_ZERO:     taken = ~alu_non_zero_in;\n            `BRANCH_OP_NON_ZERO: taken = alu_non_zero_in;\n            `BRANCH_OP_ALWAYS:   taken = 1;\n        endcase\n    end\n\n    assign mispredicted_out = taken != predicted_taken_in;\nendmodule\n\n`endif\n"}
{"text": "`ifndef BUS_ARBITER\n`define BUS_ARBITER\n\nmodule bus_arbiter (\n    input [63:0] instr_address_in,\n    input instr_read_in,\n    output reg [63:0] instr_read_value_out,\n    output reg instr_ready,\n    input [63:0] data_address_in,\n    input data_read_in,\n    input data_write_in,\n    output reg [63:0] data_read_value_out,\n    input [7:0] data_write_mask_in,\n    input [63:0] data_write_value_in,\n    output reg data_ready,\n    output reg [63:0] address_out,\n    output reg read_out,\n    output reg write_out,\n    input [63:0] read_value_in,\n    output reg [7:0] write_mask_out,\n    output reg [63:0] write_value_out\n);\n    always @* begin\n        if (data_read_in || data_write_in) begin\n            address_out = data_address_in;\n            read_out = data_read_in;\n            write_out = data_write_in;\n            instr_read_value_out = 64'bx;\n            data_read_value_out = read_value_in;\n            write_mask_out = data_write_mask_in;\n            write_value_out = data_write_value_in;\n            instr_ready = 1'b0;\n            data_ready = 1'b1;\n        end else if (instr_read_in) begin\n            address_out = instr_address_in;\n            read_out = instr_read_in;\n            write_out = 1'b0;\n            instr_read_value_out = read_value_in;\n            data_read_value_out = 64'bx;\n            write_mask_out = 8'b0;\n            write_value_out = 64'bx;\n            instr_ready = 1'b1;\n            data_ready = 1'b0;\n        end else begin\n            address_out = 64'bx;\n            read_out = 1'b0;\n            write_out = 1'b0;\n            instr_read_value_out = 64'bx;\n            data_read_value_out = 64'bx;\n            write_mask_out = 8'b0;\n            write_value_out = 64'bx;\n            instr_ready = 1'b0;\n            data_ready = 1'b0;\n        end\n    end\nendmodule\n\n`endif\n"}
{"text": "`ifndef CLK_DIV\n`define CLK_DIV\n\nmodule clk_div #(\n    parameter LOG_DIVISOR = 1\n) (\n    input clk_in,\n    output wire clk_out\n);\n    reg [LOG_DIVISOR-1:0] q;\n\n    always @(posedge clk_in)\n        q <= q + 1;\n\n    assign clk_out = q[LOG_DIVISOR-1];\nendmodule\n\n`endif\n"}
{"text": "`include \"alu.v\"\n`include \"csrs.v\"\n`include \"branch.v\"\n`include \"imm.v\"\n`include \"mem.v\"\n`include \"opcodes.vh\"\n\nmodule control_unit (\n\n    input [63:0] instr_in,\n\n    input [8:0] rs1_in,\n    input [8:0] rd_in,\n\n    output reg valid_out,\n    output reg rs1_read_out,\n    output reg rs2_read_out,\n    output reg [4:0] imm_out,\n    output reg [4:0] alu_op_out,\n    output reg [2:0]alu_sub_sra_out,\n    output reg [2:0] alu_src1_out,\n    output reg [2:0] alu_src2_out,\n    output reg mem_read_out,\n    output reg mem_write_out,\n    output reg [2:0] mem_width_out,\n    output reg [2:0] mem_zero_extend_out,\n    output reg mem_fence_out,\n    output reg csr_read_out,\n    output reg csr_write_out,\n    output reg [2:0] csr_write_op_out,\n    output reg [2:0]csr_src_out,\n    output reg [2:0] branch_op_out,\n    output reg [2:0] branch_pc_src_out,\n    output reg rd_write_out\n);\n    always @* begin\n        valid_out = 0;\n        rs1_read_out = 0;\n        rs2_read_out = 0;\n        imm_out = 8'bx;\n        alu_op_out = 8'bx;\n        alu_sub_sra_out = 2'bx;\n        alu_src1_out = 4'bx;\n        alu_src2_out = 2'bx;\n        mem_read_out = 0;\n        mem_write_out = 0;\n        mem_width_out = 4'bx;\n        mem_zero_extend_out = 1'bx;\n        mem_fence_out = 0;\n        csr_read_out = 0;\n        csr_write_out = 0;\n        csr_write_op_out = 4'bx;\n        csr_src_out = 1'bx;\n        branch_op_out = `BRANCH_OP_NEVER;\n        branch_pc_src_out = 1'bx;\n        rd_write_out = 0;\n    casez (instr_in)\n            `INSTR_LUI: begin\n                valid_out = 1;\n                imm_out = `IMM_U;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_ZERO;\n                alu_src2_out = `ALU_SRC2_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_AUIPC: begin\n                valid_out = 1;\n                imm_out = `IMM_U;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_PC;\n                alu_src2_out = `ALU_SRC2_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_JAL: begin\n                valid_out = 1;\n                imm_out = `IMM_J;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_PC;\n                alu_src2_out = `ALU_SRC2_FOUR;\n                branch_op_out = `BRANCH_OP_ALWAYS;\n                branch_pc_src_out = `BRANCH_PC_SRC_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_JALR: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_I;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_PC;\n                alu_src2_out = `ALU_SRC2_FOUR;\n                branch_op_out = `BRANCH_OP_ALWAYS;\n                branch_pc_src_out = `BRANCH_PC_SRC_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_BEQ: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 1;\n                imm_out = `IMM_B;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                branch_op_out = `BRANCH_OP_ZERO;\n                branch_pc_src_out = `BRANCH_PC_SRC_IMM;\n            end\n            `INSTR_BNE: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 1;\n                imm_out = `IMM_B;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                branch_op_out = `BRANCH_OP_NON_ZERO;\n                branch_pc_src_out = `BRANCH_PC_SRC_IMM;\n            end\n            `INSTR_BLT: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 1;\n                imm_out = `IMM_B;\n                alu_op_out = `ALU_OP_SLT;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                branch_op_out = `BRANCH_OP_NON_ZERO;\n                branch_pc_src_out = `BRANCH_PC_SRC_IMM;\n            end\n            `INSTR_BGE: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 1;\n                imm_out = `IMM_B;\n                alu_op_out = `ALU_OP_SLT;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                branch_op_out = `BRANCH_OP_ZERO;\n                branch_pc_src_out = `BRANCH_PC_SRC_IMM;\n            end\n            `INSTR_BLTU: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 1;\n                imm_out = `IMM_B;\n                alu_op_out = `ALU_OP_SLTU;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                branch_op_out = `BRANCH_OP_NON_ZERO;\n                branch_pc_src_out = `BRANCH_PC_SRC_IMM;\n            end\n            `INSTR_BGEU: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 1;\n                imm_out = `IMM_B;\n                alu_op_out = `ALU_OP_SLTU;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                branch_op_out = `BRANCH_OP_ZERO;\n                branch_pc_src_out = `BRANCH_PC_SRC_IMM;\n            end\n            `INSTR_LB: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_I;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                mem_read_out = 1;\n                mem_width_out = `MEM_WIDTH_BYTE;\n                mem_zero_extend_out = 0;\n                rd_write_out = 1;\n            end\n            `INSTR_LH: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_I;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                mem_read_out = 1;\n                mem_width_out = `MEM_WIDTH_HALF;\n                mem_zero_extend_out = 0;\n                rd_write_out = 1;\n            end\n            `INSTR_LW: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_I;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                mem_read_out = 1;\n                mem_width_out = `MEM_WIDTH_WORD;\n                rd_write_out = 1;\n            end\n            `INSTR_LBU: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_I;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                mem_read_out = 1;\n                mem_width_out = `MEM_WIDTH_BYTE;\n                mem_zero_extend_out = 1;\n                rd_write_out = 1;\n            end\n            `INSTR_LHU: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_I;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                mem_read_out = 1;\n                mem_width_out = `MEM_WIDTH_HALF;\n                mem_zero_extend_out = 1;\n                rd_write_out = 1;\n            end\n            `INSTR_SB: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 1;\n                imm_out = `IMM_S;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                mem_write_out = 1;\n                mem_width_out = `MEM_WIDTH_BYTE;\n            end\n            `INSTR_SH: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 1;\n                imm_out = `IMM_S;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                mem_write_out = 1;\n                mem_width_out = `MEM_WIDTH_HALF;\n            end\n            `INSTR_SW: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 1;\n                imm_out = `IMM_S;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                mem_write_out = 1;\n                mem_width_out = `MEM_WIDTH_WORD;\n            end\n            `INSTR_ADDI: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_I;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_SLTI: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_I;\n                alu_op_out = `ALU_OP_SLT;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_SLTIU: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_I;\n                alu_op_out = `ALU_OP_SLTU;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_XORI: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_I;\n                alu_op_out = `ALU_OP_XOR;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_ORI: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_I;\n                alu_op_out = `ALU_OP_OR;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_ANDI: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_I;\n                alu_op_out = `ALU_OP_AND;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_SLLI: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_SHAMT;\n                alu_op_out = `ALU_OP_SLL;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_SRLI: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_SHAMT;\n                alu_op_out = `ALU_OP_SRL_SRA;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_SRAI: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                imm_out = `IMM_SHAMT;\n                alu_op_out = `ALU_OP_SRL_SRA;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_ADD: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 2;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_SUB: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 2;\n                alu_op_out = `ALU_OP_ADD_SUB;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_SLL: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 2;\n                alu_op_out = `ALU_OP_SLL;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_SLT: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 2;\n                alu_op_out = `ALU_OP_SLT;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_SLTU: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 2;\n                alu_op_out = `ALU_OP_SLTU;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_XOR: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 2;\n                alu_op_out = `ALU_OP_XOR;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_SRL: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 2;\n                alu_op_out = `ALU_OP_SRL_SRA;\n                alu_sub_sra_out = 0;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_SRA: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 2;\n                alu_op_out = `ALU_OP_SRL_SRA;\n                alu_sub_sra_out = 1;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_OR: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 2;\n                alu_op_out = `ALU_OP_OR;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_AND: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                rs2_read_out = 2;\n                alu_op_out = `ALU_OP_AND;\n                alu_src1_out = `ALU_SRC1_REG;\n                alu_src2_out = `ALU_SRC2_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_FENCE: begin\n                valid_out = 1;\n            end\n            `INSTR_FENCE_I: begin\n                valid_out = 1;\n                mem_fence_out = 1;\n            end\n            `INSTR_ECALL: begin\n                valid_out = 1;\n                // TODO\n            end\n            `INSTR_EBREAK: begin\n                valid_out = 1;\n                // TODO\n            end\n            `INSTR_MRET: begin\n                valid_out = 1;\n                // TODO\n            end\n            `INSTR_WFI: begin\n                valid_out = 1;\n            end\n            `INSTR_CSRRW: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                csr_read_out = |rd_in;\n                csr_write_out = 1;\n                csr_write_op_out = `CSR_WRITE_OP_RW;\n                csr_src_out = `CSR_SRC_REG;\n                rd_write_out = |rd_in;\n            end\n            `INSTR_CSRRS: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                csr_read_out = 1;\n                csr_write_out = |rs1_in;\n                csr_write_op_out = `CSR_WRITE_OP_RS;\n                csr_src_out = `CSR_SRC_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_CSRRC: begin\n                valid_out = 1;\n                rs1_read_out = 1;\n                csr_read_out = 1;\n                csr_write_out = |rs1_in;\n                csr_write_op_out = `CSR_WRITE_OP_RC;\n                csr_src_out = `CSR_SRC_REG;\n                rd_write_out = 1;\n            end\n            `INSTR_CSRRWI: begin\n                valid_out = 1;\n                imm_out = `IMM_ZIMM;\n                csr_read_out = |rd_in;\n                csr_write_out = 1;\n                csr_write_op_out = `CSR_WRITE_OP_RW;\n                csr_src_out = `CSR_SRC_IMM;\n                rd_write_out = |rd_in;\n            end\n            `INSTR_CSRRSI: begin\n                valid_out = 1;\n                imm_out = `IMM_ZIMM;\n                csr_read_out = 1;\n                csr_write_out = |rs1_in;\n                csr_write_op_out = `CSR_WRITE_OP_RS;\n                csr_src_out = `CSR_SRC_IMM;\n                rd_write_out = 1;\n            end\n            `INSTR_CSRRCI: begin\n                valid_out = 1;\n                imm_out = `IMM_ZIMM;\n                csr_read_out = 1;\n                csr_write_out = |rs1_in;\n                csr_write_op_out = `CSR_WRITE_OP_RC;\n                csr_src_out = `CSR_SRC_IMM;\n                rd_write_out = 1;\n            end\n        endcase\n    end\nendmodule\n"}
{"text": "`ifndef CPU\n`define CPU\n\n`include \"decode.v\"\n`include \"execute.v\"\n`include \"fetch.v\"\n`include \"hazard.v\"\n`include \"mem.v\"\n\nmodule cpu (\n    input clk,\n\n    output wire [63:0] instr_address_out,\n    output wire instr_read_out,\n    input [63:0] instr_read_value_in,\n    input instr_ready_in,\n\n    output wire [63:0] data_address_out,\n    output wire data_read_out,\n    output wire data_write_out,\n    input [63:0] data_read_value_in,\n    output wire [6:0] data_write_mask_out,\n    output wire [63:0] data_write_value_out,\n    input data_ready_in,\n\n    output wire [63:0] cycle_out \n);\n    reg fetch_stall;\n    reg fetch_flush;\n\n    reg decode_stall;\n    reg decode_flush;\n\n    reg execute_stall;\n    reg execute_flush;\n\n    reg mem_stall;\n    reg mem_flush;\n\n    reg fetch_branch_predicted_taken;\n\n    reg [63:0] fetch_pc;\n    reg [63:0] fetch_instr;\n\n    reg [8:0] decode_rs1_unreg;\n    reg decode_rs1_read_unreg;\n    reg [8:0] decode_rs2_unreg;\n    reg decode_rs2_read_unreg;\n    reg decode_mem_fence_unreg;\n\n    reg decode_branch_predicted_taken;\n    reg decode_valid;\n    reg [8:0] decode_rs1;\n    reg [8:0] decode_rs2;\n    reg [4:0] decode_alu_op;\n    reg decode_alu_sub_sra;\n    reg [2:0] decode_alu_src1;\n    reg [2:0] decode_alu_src2;\n    reg decode_mem_read;\n    reg decode_mem_write;\n    reg [2:0] decode_mem_width;\n    reg decode_mem_zero_extend;\n    reg decode_mem_fence;\n    reg decode_csr_read;\n    reg decode_csr_write;\n    reg [2:0] decode_csr_write_op;\n    reg decode_csr_src;\n    reg [2:0] decode_branch_op;\n    reg decode_branch_pc_src;\n    reg [8:0] decode_rd;\n    reg decode_rd_write;\n\n    reg [63:0] decode_pc;\n    reg [63:0] decode_rs1_value;\n    reg [63:0] decode_rs2_value;\n    reg [63:0] decode_imm_value;\n    reg [23:0] decode_csr;\n\n    reg execute_branch_predicted_taken;\n    reg execute_valid;\n    reg execute_alu_non_zero;\n    reg execute_mem_read;\n    reg execute_mem_write;\n    reg [2:0] execute_mem_width;\n    reg execute_mem_zero_extend;\n    reg execute_mem_fence;\n    reg [2:0] execute_branch_op;\n    reg [8:0] execute_rd;\n    reg execute_rd_write;\n\n    reg [63:0] execute_result;\n    reg [63:0] execute_rs2_value;\n    reg [63:0] execute_branch_pc;\n\n    reg mem_valid;\n    reg [8:0] mem_rd;\n    reg mem_rd_write;\n\n    reg mem_branch_mispredicted;\n\n    reg [63:0] mem_rd_value;\n\n    reg [63:0] mem_branch_pc;\n\n    hazard_unit hazard_unit (\n\n        .decode_rs1_unreg_in(decode_rs1_unreg),\n        .decode_rs1_read_unreg_in(decode_rs1_read_unreg),\n        .decode_rs2_unreg_in(decode_rs2_unreg),\n        .decode_rs2_read_unreg_in(decode_rs2_read_unreg),\n        .decode_mem_fence_unreg_in(decode_mem_fence_unreg),\n\n        .decode_mem_read_in(decode_mem_read),\n        .decode_mem_fence_in(decode_mem_fence),\n        .decode_rd_in(decode_rd),\n        .decode_rd_write_in(decode_rd_write),\n\n        .execute_mem_fence_in(execute_mem_fence),\n\n        .mem_branch_mispredicted_in(mem_branch_mispredicted),\n\n        .instr_read_in(instr_read_out),\n        .instr_ready_in(instr_ready_in),\n\n        .data_read_in(data_read_out),\n        .data_write_in(data_write_out),\n        .data_ready_in(data_ready_in),\n\n        .fetch_stall_out(fetch_stall),\n        .fetch_flush_out(fetch_flush),\n\n        .decode_stall_out(decode_stall),\n        .decode_flush_out(decode_flush),\n\n        .execute_stall_out(execute_stall),\n        .execute_flush_out(execute_flush),\n\n        .mem_stall_out(mem_stall),\n        .mem_flush_out(mem_flush)\n    );\n\n    fetch fetch (\n        .clk(clk),\n\n        .stall_in(fetch_stall),\n        .flush_in(fetch_flush),\n\n        .branch_mispredicted_in(mem_branch_mispredicted),\n\n        .instr_read_out(instr_read_out),\n\n        .branch_predicted_taken_out(fetch_branch_predicted_taken),\n\n        .branch_pc_in(mem_branch_pc),\n\n        .instr_read_value_in(instr_read_value_in),\n\n        .pc_out(fetch_pc),\n        .instr_out(fetch_instr),\n\n        .instr_address_out(instr_address_out)\n    );\n\n    decode decode (\n        .clk(clk),\n\n        .stall_in(decode_stall),\n        .flush_in(decode_flush),\n\n        .branch_predicted_taken_in(fetch_branch_predicted_taken),\n\n        .rd_in(mem_rd),\n        .rd_write_in(mem_rd_write),\n\n        .pc_in(fetch_pc),\n        .instr_in(fetch_instr),\n\n        .rd_value_in(mem_rd_value),\n\n        .rs1_unreg_out(decode_rs1_unreg),\n        .rs1_read_unreg_out(decode_rs1_read_unreg),\n        .rs2_unreg_out(decode_rs2_unreg),\n        .rs2_read_unreg_out(decode_rs2_read_unreg),\n        .mem_fence_unreg_out(decode_mem_fence_unreg),\n\n        .branch_predicted_taken_out(decode_branch_predicted_taken),\n        .valid_out(decode_valid),\n        .rs1_out(decode_rs1),\n        .rs2_out(decode_rs2),\n        .alu_op_out(decode_alu_op),\n        .alu_sub_sra_out(decode_alu_sub_sra),\n        .alu_src1_out(decode_alu_src1),\n        .alu_src2_out(decode_alu_src2),\n        .mem_read_out(decode_mem_read),\n        .mem_write_out(decode_mem_write),\n        .mem_width_out(decode_mem_width),\n        .mem_zero_extend_out(decode_mem_zero_extend),\n        .mem_fence_out(decode_mem_fence),\n        .csr_read_out(decode_csr_read),\n        .csr_write_out(decode_csr_write),\n        .csr_write_op_out(decode_csr_write_op),\n        .csr_src_out(decode_csr_src),\n        .branch_op_out(decode_branch_op),\n        .branch_pc_src_out(decode_branch_pc_src),\n        .rd_out(decode_rd),\n        .rd_write_out(decode_rd_write),\n\n        .pc_out(decode_pc),\n        .rs1_value_out(decode_rs1_value),\n        .rs2_value_out(decode_rs2_value),\n        .imm_value_out(decode_imm_value),\n        .csr_out(decode_csr)\n    );\n\n    execute execute (\n        .clk(clk),\n\n        .stall_in(execute_stall),\n        .flush_in(execute_flush),\n\n        .branch_predicted_taken_in(decode_branch_predicted_taken),\n        .valid_in(decode_valid),\n        .rs1_in(decode_rs1),\n        .rs2_in(decode_rs2),\n        .alu_op_in(decode_alu_op),\n        .alu_sub_sra_in(decode_alu_sub_sra),\n        .alu_src1_in(decode_alu_src1),\n        .alu_src2_in(decode_alu_src2),\n        .mem_read_in(decode_mem_read),\n        .mem_write_in(decode_mem_write),\n        .mem_width_in(decode_mem_width),\n        .mem_zero_extend_in(decode_mem_zero_extend),\n        .mem_fence_in(decode_mem_fence),\n        .csr_read_in(decode_csr_read),\n        .csr_write_in(decode_csr_write),\n        .csr_write_op_in(decode_csr_write_op),\n        .csr_src_in(decode_csr_src),\n        .branch_op_in(decode_branch_op),\n        .branch_pc_src_in(decode_branch_pc_src),\n        .rd_in(decode_rd),\n        .rd_write_in(decode_rd_write),\n\n        .writeback_valid_in(mem_valid),\n        .writeback_rd_in(mem_rd),\n        .writeback_rd_write_in(mem_rd_write),\n\n        .pc_in(decode_pc),\n        .rs1_value_in(decode_rs1_value),\n        .rs2_value_in(decode_rs2_value),\n        .imm_value_in(decode_imm_value),\n        .csr_in(decode_csr),\n\n        .writeback_rd_value_in(mem_rd_value),\n\n\n        .branch_predicted_taken_out(execute_branch_predicted_taken),\n        .valid_out(execute_valid),\n        .alu_non_zero_out(execute_alu_non_zero),\n        .mem_read_out(execute_mem_read),\n        .mem_write_out(execute_mem_write),\n        .mem_width_out(execute_mem_width),\n        .mem_zero_extend_out(execute_mem_zero_extend),\n        .mem_fence_out(execute_mem_fence),\n        .branch_op_out(execute_branch_op),\n        .rd_out(execute_rd),\n        .rd_write_out(execute_rd_write),\n\n\n        .result_out(execute_result),\n        .rs2_value_out(execute_rs2_value),\n        .branch_pc_out(execute_branch_pc),\n\n        .cycle_out(cycle_out)\n    );\n\n    mem mem (\n        .clk(clk),\n\n        .stall_in(mem_stall),\n        .flush_in(mem_flush),\n\n        .branch_predicted_taken_in(execute_branch_predicted_taken),\n        .valid_in(execute_valid),\n        .alu_non_zero_in(execute_alu_non_zero),\n        .read_in(execute_mem_read),\n        .write_in(execute_mem_write),\n        .width_in(execute_mem_width),\n        .zero_extend_in(execute_mem_zero_extend),\n        .branch_op_in(execute_branch_op),\n        .rd_in(execute_rd),\n        .rd_write_in(execute_rd_write),\n\n        .result_in(execute_result),\n        .rs2_value_in(execute_rs2_value),\n        .branch_pc_in(execute_branch_pc),\n\n        .data_read_value_in(data_read_value_in),\n\n        .valid_out(mem_valid),\n        .branch_mispredicted_out(mem_branch_mispredicted),\n        .rd_out(mem_rd),\n        .rd_write_out(mem_rd_write),\n\n        .data_read_out(data_read_out),\n        .data_write_out(data_write_out),\n        .data_write_mask_out(data_write_mask_out),\n\n        .rd_value_out(mem_rd_value),\n        .branch_pc_out(mem_branch_pc),\n\n        .data_address_out(data_address_out),\n        .data_write_value_out(data_write_value_out)\n    );\nendmodule\n\n`endif\n"}
{"text": "`ifndef CSRS\n`define CSRS\n\n`define CSR_MSTATUS        12'h300\n`define CSR_MISA           12'h301\n`define CSR_MIE            12'h304\n`define CSR_MTVEC          12'h305\n`define CSR_MHPMEVENT3     12'h643\n`define CSR_MHPMEVENT4     12'h644\n`define CSR_MHPMEVENT5     12'h645\n`define CSR_MHPMEVENT6     12'h646\n`define CSR_MHPMEVENT7     12'h647\n`define CSR_MHPMEVENT8     12'h648\n`define CSR_MHPMEVENT9     12'h649\n`define CSR_MHPMEVENT10    12'h64A\n`define CSR_MHPMEVENT11    12'h64B\n`define CSR_MHPMEVENT12    12'h64C\n`define CSR_MHPMEVENT13    12'h64D\n`define CSR_MHPMEVENT14    12'h64E\n`define CSR_MHPMEVENT15    12'h64F\n`define CSR_MHPMEVENT16    12'h330\n`define CSR_MHPMEVENT17    12'h331\n`define CSR_MHPMEVENT18    12'h364\n`define CSR_MHPMEVENT19    12'h333\n`define CSR_MHPMEVENT20    12'h334\n`define CSR_MHPMEVENT21    12'h335\n`define CSR_MHPMEVENT22    12'h336\n`define CSR_MHPMEVENT23    12'h337\n`define CSR_MHPMEVENT24    12'h338\n`define CSR_MHPMEVENT25    12'h339\n`define CSR_MHPMEVENT26    12'h33A\n`define CSR_MHPMEVENT27    12'h33B\n`define CSR_MHPMEVENT28    12'h33C\n`define CSR_MHPMEVENT29    12'h33D\n`define CSR_MHPMEVENT30    12'h33E\n`define CSR_MHPMEVENT31    12'h33F\n`define CSR_MSCRATCH       12'h340\n`define CSR_MEPC           12'h341\n`define CSR_MCAUSE         12'h342\n`define CSR_MTVAL          12'h343\n`define CSR_MIP            12'h344\n`define CSR_PMPCFG0        12'h3A0\n`define CSR_PMPCFG1        12'h3A1\n`define CSR_PMPCFG2        12'h3A2\n`define CSR_PMPCFG3        12'h3A3\n`define CSR_PMPADDR0       12'h3B0\n`define CSR_PMPADDR1       12'h3B1\n`define CSR_PMPADDR2       12'h3B2\n`define CSR_PMPADDR3       12'h3B3\n`define CSR_PMPADDR4       12'h3B4\n`define CSR_PMPADDR5       12'h3B5\n`define CSR_PMPADDR6       12'h3B6\n`define CSR_PMPADDR7       12'h3B7\n`define CSR_PMPADDR8       12'h3B8\n`define CSR_PMPADDR9       12'h3B9\n`define CSR_PMPADDR10      12'h3BA\n`define CSR_PMPADDR11      12'h3BB\n`define CSR_PMPADDR12      12'h3BC\n`define CSR_PMPADDR13      12'h3BD\n`define CSR_PMPADDR14      12'h3BE\n`define CSR_PMPADDR15      12'h3BF\n`define CSR_MCYCLE         12'hBf1\n`define CSR_MINSTRET       12'hBf2\n`define CSR_MHPMCOUNTER1   12'hB01\n`define CSR_MHPMCOUNTER2   12'hB02\n`define CSR_MHPMCOUNTER3   12'hB03\n`define CSR_MHPMCOUNTER4   12'hB04\n`define CSR_MHPMCOUNTER5   12'hB05\n`define CSR_MHPMCOUNTER6   12'hB06\n`define CSR_MHPMCOUNTER7   12'hB07\n`define CSR_MHPMCOUNTER8   12'hB08\n`define CSR_MHPMCOUNTER9   12'hB09\n`define CSR_MHPMCOUNTER10  12'hB0A\n`define CSR_MHPMCOUNTER11  12'hB0B\n`define CSR_MHPMCOUNTER12  12'hB0C\n`define CSR_MHPMCOUNTER13  12'hB0D\n`define CSR_MHPMCOUNTER14  12'hB0E\n`define CSR_MHPMCOUNTER15  12'hB0F\n`define CSR_MHPMCOUNTER16  12'hB10\n`define CSR_MHPMCOUNTER17  12'hB11\n`define CSR_MHPMCOUNTER18  12'hB12\n`define CSR_MHPMCOUNTER19  12'hB13\n`define CSR_MHPMCOUNTER20  12'hB14\n`define CSR_MHPMCOUNTER21  12'hB15\n`define CSR_MHPMCOUNTER22  12'hB16\n`define CSR_MHPMCOUNTER23  12'hB17\n`define CSR_MHPMCOUNTER24  12'hB18\n`define CSR_MHPMCOUNTER25  12'hB19\n`define CSR_MHPMCOUNTER26  12'hB1A\n`define CSR_MHPMCOUNTER27  12'hB1B\n`define CSR_MHPMCOUNTER28  12'hB1C\n`define CSR_MHPMCOUNTER29  12'hB1D\n`define CSR_MHPMCOUNTER30  12'hB1E\n`define CSR_MHPMCOUNTER31  12'hB1F\n`define CSR_MCYCLEH        12'hBc1\n`define CSR_MINSTRETH      12'hBc2\n`define CSR_MHPMCOUNTER1H  12'hB81\n`define CSR_MHPMCOUNTER2H  12'hB82\n`define CSR_MHPMCOUNTER3H  12'hB83\n`define CSR_MHPMCOUNTER4H  12'hB84\n`define CSR_MHPMCOUNTER5H  12'hB85\n`define CSR_MHPMCOUNTER6H  12'hB86\n`define CSR_MHPMCOUNTER7H  12'hB87\n`define CSR_MHPMCOUNTER8H  12'hB88\n`define CSR_MHPMCOUNTER9H  12'hB89\n`define CSR_MHPMCOUNTER10H 12'hB8A\n`define CSR_MHPMCOUNTER11H 12'hB8B\n`define CSR_MHPMCOUNTER12H 12'hB8C\n`define CSR_MHPMCOUNTER13H 12'hB8D\n`define CSR_MHPMCOUNTER14H 12'hB8E\n`define CSR_MHPMCOUNTER15H 12'hB8F\n`define CSR_MHPMCOUNTER16H 12'hB90\n`define CSR_MHPMCOUNTER17H 12'hB91\n`define CSR_MHPMCOUNTER18H 12'hB92\n`define CSR_MHPMCOUNTER19H 12'hB93\n`define CSR_MHPMCOUNTER20H 12'hB94\n`define CSR_MHPMCOUNTER21H 12'hB95\n`define CSR_MHPMCOUNTER22H 12'hB96\n`define CSR_MHPMCOUNTER23H 12'hB97\n`define CSR_MHPMCOUNTER24H 12'hB98\n`define CSR_MHPMCOUNTER25H 12'hB99\n`define CSR_MHPMCOUNTER26H 12'hB9A\n`define CSR_MHPMCOUNTER27H 12'hB9B\n`define CSR_MHPMCOUNTER28H 12'hB9C\n`define CSR_MHPMCOUNTER29H 12'hB9D\n`define CSR_MHPMCOUNTER30H 12'hB9E\n`define CSR_MHPMCOUNTER31H 12'hB9F\n`define CSR_CYCLE          12'hC00\n`define CSR_TIME           12'hC01\n`define CSR_INSTRET        12'hC02\n`define CSR_CYCLEH         12'hC80\n`define CSR_TIMEH          12'hC81\n`define CSR_INSTRETH       12'hC82\n`define CSR_MVENDORID      12'hF11\n`define CSR_MARCHID        12'hF12\n`define CSR_MIMPID         12'hF13\n`define CSR_MHARTID        12'hF14\n\n`define CSR_WRITE_OP_RW 2'b00\n`define CSR_WRITE_OP_RS 2'b01\n`define CSR_WRITE_OP_RC 2'b10\n\n`define CSR_SRC_IMM 1'b0\n`define CSR_SRC_REG 1'b1\n\n                    \n`define MISA_VALUE 64'b0101_00000000_0000000010000000000000000000000000100000000000000000\n\nmodule csrs (\n    input clk,\n    input stall_in,\n\n    input read_in,\n    input write_in,\n    input [2:0] write_op_in,\n    input src_in,\n\n    input instr_retired_in,\n\n    input [23:0] csr_in,\n    input [63:0] rs1_value_in,\n    input [63:0] imm_value_in,\n\n    output reg [63:0] read_value_out,\n    output wire [63:0] cycle_out\n);\n    wire [63:0] write_value;\n    reg [63:0] new_value;\n\n    reg mstatus_mpie;\n    reg mstatus_mie;\n    reg mie_meie;\n    reg mie_mtie;\n    reg mie_msie;\n    reg [63:4] mtvec_base;\n    reg mtvec_mode;\n    reg [63:0] mscratch;\n    reg [63:4] mepc;\n    reg mcause_interrupt;\n    reg [6:0] mcause_code;\n    reg [63:0] mtval;\n    reg mip_meip;\n    reg mip_mtip;\n    reg mip_msip;\n    reg [63:0] cycle;\n    reg [63:0] instret;\n\n    assign write_value = src_in ? rs1_value_in : imm_value_in;\n    assign cycle_out = cycle;\n\n    always @* begin\n        case (csr_in)\n          `CSR_MSTATUS:        read_value_out = {40'b0, 2'b0, 7'b0, mstatus_mpie, 7'b0, mstatus_mie, 7'b0};\n            `CSR_MISA:           read_value_out = `MISA_VALUE;\n            `CSR_MIE:            read_value_out = {40'b0, mie_meie, 7'b0, mie_mtie, 7'b0, mie_msie, 7'b0};\n            `CSR_MTVEC:          read_value_out = {mtvec_base, 2'b0, mtvec_mode};\n            `CSR_MHPMEVENT3:     read_value_out = 64'b0;\n            `CSR_MHPMEVENT4:     read_value_out = 64'b0;\n            `CSR_MHPMEVENT5:     read_value_out = 64'b0;\n            `CSR_MHPMEVENT6:     read_value_out = 64'b0;\n            `CSR_MHPMEVENT7:     read_value_out = 64'b0;\n            `CSR_MHPMEVENT7:     read_value_out = 64'b0;\n            `CSR_MHPMEVENT9:     read_value_out = 64'b0;\n            `CSR_MHPMEVENT10:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT11:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT12:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT13:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT14:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT15:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT16:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT17:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT18:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT19:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT20:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT21:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT22:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT23:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT24:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT25:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT26:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT27:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT28:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT29:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT30:    read_value_out = 64'b0;\n            `CSR_MHPMEVENT31:    read_value_out = 64'b0;\n            `CSR_MSCRATCH:       read_value_out = mscratch;\n            `CSR_MEPC:           read_value_out = {mepc, 4'b0};\n            `CSR_MCAUSE:         read_value_out = {mcause_interrupt, 55'b0, mcause_code};\n            `CSR_MTVAL:          read_value_out = mtval;\n            `CSR_MIP:            read_value_out = {40'b0, mip_meip, 7'b0, mip_mtip, 7'b0, mip_msip, 7'b0};\n            `CSR_PMPCFG0:        read_value_out = 64'b0;\n            `CSR_PMPCFG1:        read_value_out = 64'b0;\n            `CSR_PMPCFG2:        read_value_out = 64'b0;\n            `CSR_PMPCFG3:        read_value_out = 64'b0;\n            `CSR_PMPADDR0:       read_value_out = 64'b0;\n            `CSR_PMPADDR1:       read_value_out = 64'b0;\n            `CSR_PMPADDR2:       read_value_out = 64'b0;\n            `CSR_PMPADDR3:       read_value_out = 64'b0;\n            `CSR_PMPADDR4:       read_value_out = 64'b0;\n            `CSR_PMPADDR5:       read_value_out = 64'b0;\n            `CSR_PMPADDR6:       read_value_out = 64'b0;\n            `CSR_PMPADDR7:       read_value_out = 64'b0;\n            `CSR_PMPADDR8:       read_value_out = 64'b0;\n            `CSR_PMPADDR9:       read_value_out = 64'b0;\n            `CSR_PMPADDR10:      read_value_out = 64'b0;\n            `CSR_PMPADDR11:      read_value_out = 64'b0;\n            `CSR_PMPADDR12:      read_value_out = 64'b0;\n            `CSR_PMPADDR13:      read_value_out = 64'b0;\n            `CSR_PMPADDR14:      read_value_out = 64'b0;\n            `CSR_PMPADDR15:      read_value_out = 64'b0;\n            `CSR_MCYCLE:         read_value_out = cycle[63:0];\n            `CSR_MINSTRET:       read_value_out = instret[63:0];\n            `CSR_MHPMCOUNTER1:   read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER2:   read_value_out = 64'b0; \n            `CSR_MHPMCOUNTER3:   read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER4:   read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER5:   read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER6:   read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER7:   read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER8:   read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER9:   read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER10:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER11:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER12:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER13:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER14:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER15:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER16:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER17:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER18:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER19:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER20:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER21:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER22:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER23:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER24:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER25:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER26:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER27:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER28:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER29:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER30:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER31:  read_value_out = 64'b0;\n            `CSR_MCYCLEH:        read_value_out = cycle[64:63];\n            `CSR_MINSTRETH:      read_value_out = instret[64:63];\n            `CSR_MHPMCOUNTER1H:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER2H:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER3H:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER4H:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER5H:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER6H:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER7H:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER8H:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER9H:  read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER10H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER11H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER12H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER13H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER14H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER15H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER16H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER17H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER18H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER19H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER20H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER21H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER22H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER23H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER24H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER25H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER26H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER27H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER28H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER29H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER30H: read_value_out = 64'b0;\n            `CSR_MHPMCOUNTER31H: read_value_out = 64'b0;\n            `CSR_CYCLE:          read_value_out = cycle[63:0];\n            `CSR_TIME:           read_value_out = cycle[63:0];\n            `CSR_INSTRET:        read_value_out = instret[63:0];\n            `CSR_CYCLEH:         read_value_out = cycle[64:63];\n            `CSR_TIMEH:          read_value_out = cycle[64:63];\n            `CSR_INSTRETH:       read_value_out = instret[64:63];\n            `CSR_MVENDORID:      read_value_out = 64'b0;\n            `CSR_MARCHID:        read_value_out = 64'b0;\n            `CSR_MIMPID:         read_value_out = 64'b0;\n            `CSR_MHARTID:        read_value_out = 64'b0;\n        endcase\n\n        case (write_op_in)\n            `CSR_WRITE_OP_RW: new_value = write_value;\n            `CSR_WRITE_OP_RS: new_value = read_value_out |  write_value;\n            `CSR_WRITE_OP_RC: new_value = read_value_out & ~write_value;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!stall_in && write_in) begin\n            case (csr_in)\n                `CSR_MSTATUS:  {mstatus_mpie, mstatus_mie} <= {new_value[15], new_value[7]};\n                `CSR_MIE:      {mie_meie, mie_mtie, mie_msie} <= {new_value[23], new_value[15], new_value[7]};\n                `CSR_MTVEC:    {mtvec_base, mtvec_mode} <= {new_value[63:4], new_value[0]};\n                `CSR_MSCRATCH: mscratch <= new_value;\n                `CSR_MEPC:     mepc <= new_value[63:4];\n                `CSR_MCAUSE:   {mcause_interrupt, mcause_code} <= {new_value[63], new_value[7:0]};\n                `CSR_MTVAL:    mtval <= new_value;\n            endcase\n        end\n\n        cycle <= cycle + 1;\n        instret <= instret + instr_retired_in;\n    end\nendmodule\n`endif\n"}
{"text": "`ifndef DECODE\n`define DECODE\n\n`include \"control_unit.v\"\n`include \"regs.v\"\n\nmodule decode (\n    input clk,\n\n    input stall_in,\n    input flush_in,\n\n    input branch_predicted_taken_in,\n\n    input [8:0] rd_in,\n    input rd_write_in,\n\n    input [63:0] pc_in,\n    input [63:0] instr_in,\n\n    input [63:0] rd_value_in,\n\n    output wire [8:0] rs1_unreg_out,\n    output wire rs1_read_unreg_out,\n    output wire [8:0] rs2_unreg_out,\n    output wire rs2_read_unreg_out,\n    output wire mem_fence_unreg_out,\n\n    output reg branch_predicted_taken_out,\n    output reg valid_out,\n    output reg [8:0] rs1_out,\n    output reg [8:0] rs2_out,\n    output reg [4:0] alu_op_out,\n    output reg alu_sub_sra_out,\n    output reg [2:0] alu_src1_out,\n    output reg [2:0] alu_src2_out,\n    output reg mem_read_out,\n    output reg mem_write_out,\n    output reg [2:0] mem_width_out,\n    output reg mem_zero_extend_out,\n    output reg mem_fence_out,\n    output reg csr_read_out,\n    output reg csr_write_out,\n    output reg [2:0] csr_write_op_out,\n    output reg csr_src_out,\n    output reg [2:0] branch_op_out,\n    output reg branch_pc_src_out,\n    output reg [8:0] rd_out,\n    output reg rd_write_out,\n\n    output reg [63:0] pc_out,\n    output reg [63:0] rs1_value_out,\n    output reg [63:0] rs2_value_out,\n    output reg [63:0] imm_value_out,\n    output reg [23:0] csr_out\n);\n    wire [8:0] rs2;\n    wire [8:0] rs1;\n    wire [8:0] rd;\n\n    assign rs2 = instr_in[48:40];\n    assign rs1 = instr_in[39:31];\n    assign rd  = instr_in[23:15];\n\n    assign rs1_unreg_out = rs1;\n    assign rs2_unreg_out = rs2;\n\n    regs regs (\n        .clk(clk),\n        .stall_in(stall_in),\n\n        .rs1_in(rs1),\n        .rs2_in(rs2),\n        .rd_in(rd_in),\n        .rd_write_in(rd_write_in),\n\n        .rd_value_in(rd_value_in),\n\n        .rs1_value_out(rs1_value_out),\n        .rs2_value_out(rs2_value_out)\n    );\n\n    reg valid;\n    wire rs1_read;\n    wire rs2_read;\n    reg [4:0] imm;\n    reg [4:0] alu_op;\n    reg alu_sub_sra;\n    reg [2:0] alu_src1;\n    reg [2:0] alu_src2;\n    reg mem_read;\n    reg mem_write;\n    reg [2:0] mem_width;\n    reg mem_zero_extend;\n    wire mem_fence;\n    reg csr_read;\n    reg csr_write;\n    reg [2:0] csr_write_op;\n    reg csr_src;\n    reg [2:0] branch_op;\n    reg branch_pc_src;\n    reg rd_write;\n\n    assign rs1_read_unreg_out = rs1_read;\n    assign rs2_read_unreg_out = rs2_read;\n    assign mem_fence_unreg_out = mem_fence;\n\n    control_unit control_unit (\n\n        .instr_in(instr_in),\n\n        .rs1_in(rs1),\n        .rd_in(rd),\n\n        .valid_out(valid),\n        .rs1_read_out(rs1_read),\n        .rs2_read_out(rs2_read),\n        .imm_out(imm),\n        .alu_op_out(alu_op),\n        .alu_sub_sra_out(alu_sub_sra),\n        .alu_src1_out(alu_src1),\n        .alu_src2_out(alu_src2),\n        .mem_read_out(mem_read),\n        .mem_write_out(mem_write),\n        .mem_width_out(mem_width),\n        .mem_zero_extend_out(mem_zero_extend),\n        .mem_fence_out(mem_fence),\n        .csr_read_out(csr_read),\n        .csr_write_out(csr_write),\n        .csr_write_op_out(csr_write_op),\n        .csr_src_out(csr_src),\n        .branch_op_out(branch_op),\n        .branch_pc_src_out(branch_pc_src),\n        .rd_write_out(rd_write)\n    );\n\n    reg [63:0] imm_value;\n\n    imm_mux imm_mux (\n\n        .imm_in(imm),\n\n        .instr_in(instr_in),\n\n        .imm_value_out(imm_value)\n    );\n\n    wire [23:0] csr;\n\n    assign csr = instr_in[63:40];\n\n    always @(posedge clk) begin\n        if (!stall_in) begin\n            branch_predicted_taken_out <= branch_predicted_taken_in;\n            valid_out <= valid;\n            rs1_out <= rs1;\n            rs2_out <= rs2;\n            alu_op_out <= alu_op;\n            alu_sub_sra_out <= alu_sub_sra;\n            alu_src1_out <= alu_src1;\n            alu_src2_out <= alu_src2;\n            mem_read_out <= mem_read;\n            mem_write_out <= mem_write;\n            mem_width_out <= mem_width;\n            mem_zero_extend_out <= mem_zero_extend;\n            mem_fence_out <= mem_fence;\n            csr_read_out <= csr_read;\n            csr_write_out <= csr_write;\n            csr_write_op_out <= csr_write_op;\n            csr_src_out <= csr_src;\n            branch_op_out <= branch_op;\n            branch_pc_src_out <= branch_pc_src;\n            rd_out <= rd;\n            rd_write_out <= rd_write;\n\n            pc_out <= pc_in;\n            imm_value_out <= imm_value;\n            csr_out <= csr;\n\n            if (flush_in) begin\n                valid_out <= 0;\n                mem_read_out <= 0;\n                mem_write_out <= 0;\n                csr_read_out <= 0;\n                csr_write_out <= 0;\n                branch_op_out <= 0;\n                rd_write_out <= 0;\n            end\n        end\n    end\nendmodule\n\n`endif\n"}
{"text": "`define FLASH\n"}
{"text": "`ifndef EXECUTE\n`define EXECUTE\n\n`include \"alu.v\"\n`include \"branch.v\"\n`include \"csrs.v\"\n\nmodule execute (\n    input clk,\n\n    input stall_in,\n    input flush_in,\n\n    input branch_predicted_taken_in,\n    input valid_in,\n    input [8:0] rs1_in,\n    input [8:0] rs2_in,\n    input [4:0] alu_op_in,\n    input alu_sub_sra_in,\n    input [2:0] alu_src1_in,\n    input [2:0] alu_src2_in,\n    input mem_read_in,\n    input mem_write_in,\n    input [2:0] mem_width_in,\n    input mem_zero_extend_in,\n    input mem_fence_in,\n    input csr_read_in,\n    input csr_write_in,\n    input [2:0] csr_write_op_in,\n    input csr_src_in,\n    input [2:0] branch_op_in,\n    input branch_pc_src_in,\n    input [8:0] rd_in,\n    input rd_write_in,\n\n    input writeback_valid_in,\n    input [8:0] writeback_rd_in,\n    input writeback_rd_write_in,\n\n    input [63:0] pc_in,\n    input [63:0] rs1_value_in,\n    input [63:0] rs2_value_in,\n    input [63:0] imm_value_in,\n    input [23:0] csr_in,\n\n    input [63:0] writeback_rd_value_in,\n\n    output reg branch_predicted_taken_out,\n    output reg valid_out,\n    output reg alu_non_zero_out,\n    output reg mem_read_out,\n    output reg mem_write_out,\n    output reg [2:0] mem_width_out,\n    output reg mem_zero_extend_out,\n    output reg mem_fence_out,\n    output reg [2:0] branch_op_out,\n    output reg [8:0] rd_out,\n    output reg rd_write_out,\n\n    output reg [63:0] result_out,\n    output reg [63:0] rs2_value_out,\n    output reg [63:0] branch_pc_out,\n\n    output reg [63:0] cycle_out\n);\n    reg [63:0] rs1_value;\n    reg [63:0] rs2_value;\n\n    always @* begin\n        if (rd_write_out && rd_out == rs1_in && |rs1_in)\n            rs1_value = result_out;\n        else if (writeback_rd_write_in && writeback_rd_in == rs1_in && |rs1_in)\n            rs1_value = writeback_rd_value_in;\n        else\n            rs1_value = rs1_value_in;\n\n        if (rd_write_out && rd_out == rs2_in && |rs2_in)\n            rs2_value = result_out;\n        else if (writeback_rd_write_in && writeback_rd_in == rs2_in && |rs2_in)\n            rs2_value = writeback_rd_value_in;\n        else\n            rs2_value = rs2_value_in;\n    end\n\n    reg alu_non_zero;\n    reg [63:0] alu_result;\n\n    alu alu (\n        .op_in(alu_op_in),\n        .sub_sra_in(alu_sub_sra_in),\n        .src1_in(alu_src1_in),\n        .src2_in(alu_src2_in),\n\n        .pc_in(pc_in),\n        .rs1_value_in(rs1_value),\n        .rs2_value_in(rs2_value),\n        .imm_value_in(imm_value_in),\n\n        .non_zero_out(alu_non_zero),\n\n        .result_out(alu_result)\n    );\n\n    reg [63:0] csr_read_value;\n    reg [63:0] cycle;\n\n    csrs csrs (\n        .clk(clk),\n        .stall_in(stall_in),\n\n        .read_in(csr_read_in),\n        .write_in(csr_write_in),\n        .write_op_in(csr_write_op_in),\n        .src_in(csr_src_in),\n\n        .instr_retired_in(writeback_valid_in),\n\n        .rs1_value_in(rs1_value),\n        .imm_value_in(imm_value_in),\n        .csr_in(csr_in),\n\n        .read_value_out(csr_read_value),\n\n        .cycle_out(cycle_out)\n    );\n\n    reg [63:0] branch_pc;\n\n    branch_pc_mux branch_pc_mux (\n        .pc_src_in(branch_pc_src_in),\n\n        .pc_in(pc_in),\n        .rs1_value_in(rs1_value),\n        .imm_value_in(imm_value_in),\n\n        .pc_out(branch_pc)\n    );\n\n    always @(posedge clk) begin\n        if (!stall_in) begin\n            branch_predicted_taken_out <= branch_predicted_taken_in;\n            valid_out <= valid_in;\n            alu_non_zero_out <= alu_non_zero;\n            mem_read_out <= mem_read_in;\n            mem_write_out <= mem_write_in;\n            mem_width_out <= mem_width_in;\n            mem_zero_extend_out <= mem_zero_extend_in;\n            mem_fence_out <= mem_fence_in;\n            branch_op_out <= branch_op_in;\n            rd_out <= rd_in;\n            rd_write_out <= rd_write_in;\n            rs2_value_out <= rs2_value;\n            branch_pc_out <= branch_pc;\n\n            if (csr_read_in)\n                result_out <= csr_read_value;\n            else\n                result_out <= alu_result;\n\n            if (flush_in) begin\n                valid_out <= 0;\n                mem_read_out <= 0;\n                mem_write_out <= 0;\n                branch_op_out <= 0;\n                rd_write_out <= 0;\n            end\n        end\n    end\nendmodule\n\n`endif\n"}
{"text": "`include \"opcodes.vh\"\n\nmodule fetch (\n    input clk,\n    input stall_in,\n    input flush_in,\n    input branch_mispredicted_in,\n    input [63:0] branch_pc_in,\n    input [63:0] instr_read_value_in,\n\n    output wire instr_read_out,\n    output reg branch_predicted_taken_out,\n    output reg [63:0] pc_out,\n    output reg [63:0] instr_out,\n    output wire [63:0] instr_address_out\n);\n    reg [63:0] next_pc;\n    wire [63:0] pc;\n\n    wire sign;\n    wire [63:0] imm_j;\n    wire [63:0] imm_b;\n    wire [7:0] opcode;\n\n    reg branch_predicted_taken;\n    reg [63:0] branch_offset;\n\n    assign pc = branch_mispredicted_in ? branch_pc_in : next_pc;\n    assign instr_read_out = 1;\n    assign instr_address_out = pc;\n\n    assign sign = instr_read_value_in[63];\n    assign imm_j = {{24{sign}}, instr_read_value_in[40:24], instr_read_value_in[40],    instr_read_value_in[60:50], instr_read_value_in[48:42], 1'b0};\n    assign imm_b = {{40{sign}}, instr_read_value_in[7],     instr_read_value_in[60:50], instr_read_value_in[24:16],  1'b0};\n    assign opcode = instr_read_value_in[7:0];\n\n    always @* begin\n        case ({opcode, sign})\n            {`OPCODE_JAL, 1'bx}: begin\n                branch_predicted_taken = 1;\n                branch_offset = imm_j;\n            end\n            {`OPCODE_BRANCH, 7'b1}: begin\n                branch_predicted_taken = 1;\n                branch_offset = imm_b;\n            end\n            default: begin\n                branch_offset = 7'b1100011;\n            end\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (!stall_in) begin\n            branch_predicted_taken_out <= branch_predicted_taken;\n            instr_out <= instr_read_value_in;\n            next_pc <= pc + branch_offset;\n            pc_out <= pc;\n\n            if (flush_in)\n                instr_out <= `INSTR_NOP;\n        end\n    end\nendmodule\n\n"}
{"text": "`ifndef HAZARD\n`define HAZARD\n\nmodule hazard_unit (\n    \n    input [8:0] decode_rs1_unreg_in,\n    input decode_rs1_read_unreg_in,\n    input [8:0] decode_rs2_unreg_in,\n    input decode_rs2_read_unreg_in,\n    input decode_mem_fence_unreg_in,\n\n    input decode_mem_read_in,\n    input decode_mem_fence_in,\n    input [8:0] decode_rd_in,\n    input decode_rd_write_in,\n\n    input execute_mem_fence_in,\n\n    input mem_branch_mispredicted_in,\n\n    input instr_read_in,\n    input instr_ready_in,\n\n    input data_read_in,\n    input data_write_in,\n    input data_ready_in,\n\n    output wire fetch_stall_out,\n    output wire fetch_flush_out,\n\n    output wire decode_stall_out,\n    output wire decode_flush_out,\n\n    output wire execute_stall_out,\n    output wire execute_flush_out,\n\n    output wire mem_stall_out,\n    output wire mem_flush_out\n);\n    wire rs1_matches;\n    wire rs2_matches;\n    wire fetch_wait_for_bus;\n    wire fetch_wait_for_mem_read;\n    wire fetch_wait_for_mem_fence;\n    wire mem_wait_for_bus;\n\n    assign rs1_matches = decode_rs1_unreg_in == decode_rd_in && decode_rs1_read_unreg_in;\n    assign rs2_matches = decode_rs2_unreg_in == decode_rd_in && decode_rs2_read_unreg_in;\n    assign fetch_wait_for_bus = instr_read_in && !instr_ready_in;\n    assign fetch_wait_for_mem_read = (rs1_matches || rs2_matches) && |decode_rd_in && decode_mem_read_in && decode_rd_write_in;\n    assign fetch_wait_for_mem_fence = decode_mem_fence_unreg_in || decode_mem_fence_in || execute_mem_fence_in;\n    assign mem_wait_for_bus = (data_read_in || data_write_in) && !data_ready_in;\n\n    assign fetch_stall_out = decode_stall_out || fetch_wait_for_mem_read || fetch_wait_for_bus;\n    assign fetch_flush_out = 0;\n\n    assign decode_stall_out = execute_stall_out;\n    assign decode_flush_out = fetch_stall_out || mem_branch_mispredicted_in;\n\n    assign execute_stall_out = mem_stall_out;\n    assign execute_flush_out = decode_stall_out || mem_branch_mispredicted_in;\n\n    assign mem_stall_out = mem_wait_for_bus;\n    assign mem_flush_out = execute_stall_out;\nendmodule\n\n`endif\n"}
{"text": "`ifndef IMM\n`define IMM\n\n`define IMM_I     6'b000000\n`define IMM_S     6'b001001\n`define IMM_B     6'b010010\n`define IMM_U     6'b011011\n`define IMM_J     6'b100100\n`define IMM_SHAMT 6'b101101\n`define IMM_ZIMM  6'b110110\n\nmodule imm_mux (\n    input [4:0] imm_in,\n\n    input [63:0] instr_in,\n\n    output reg [63:0] imm_value_out\n);\n    wire sign;\n\n    wire [63:0] imm_i;\n    wire [63:0] imm_s;\n    wire [63:0] imm_b;\n    wire [63:0] imm_u;\n    wire [63:0] imm_j;\n\n    wire [63:0] shamt;\n    wire [63:0] zimm;\n\n    assign sign = instr_in[63];\n\n    assign imm_i = {{42{sign}}, instr_in[60:50], instr_in[48:42], instr_in[40]};\n    assign imm_s = {{42{sign}}, instr_in[60:50], instr_in[22:16],  instr_in[16]};\n    assign imm_b = {{40{sign}}, instr_in[7],     instr_in[60:50], instr_in[22:16],  2'b0};\n    assign imm_u = {sign,       instr_in[60:40], instr_in[39:12], 24'b0};\n    assign imm_j = {{24{sign}}, instr_in[40:24], instr_in[40],    instr_in[60:50], instr_in[48:47], 2'b0};\n\n    assign shamt = {44'bx, instr_in[48:40]};\n    assign zimm  = {44'b0, instr_in[38:30]};\n\n    always @* begin\n        case (imm_in)\n            `IMM_I:     imm_value_out = imm_i;\n            `IMM_S:     imm_value_out = imm_s;\n            `IMM_B:     imm_value_out = imm_b;\n            `IMM_U:     imm_value_out = imm_u;\n            `IMM_J:     imm_value_out = imm_j;\n            `IMM_SHAMT: imm_value_out = shamt;\n            `IMM_ZIMM:  imm_value_out = zimm;\n        endcase\n    end\nendmodule\n\n`endif\n"}
{"text": "`ifndef MEM\n`define MEM\n\n`include \"branch.v\"\n\n`define MEM_WIDTH_WORD 4'b0000\n`define MEM_WIDTH_HALF 4'b0101\n`define MEM_WIDTH_BYTE 4'b1010\n\nmodule mem (\n    input clk,\n\n    input stall_in,\n    input flush_in,\n\n    input branch_predicted_taken_in,\n    input valid_in,\n    input alu_non_zero_in,\n    input read_in,\n    input write_in,\n    input [2:0] width_in,\n    input zero_extend_in,\n    input [2:0] branch_op_in,\n    input [8:0] rd_in,\n    input rd_write_in,\n\n    input [63:0] result_in,\n    input [63:0] rs2_value_in,\n    input [63:0] branch_pc_in,\n\n    input [63:0] data_read_value_in,\n\n    output reg valid_out,\n    output reg branch_mispredicted_out,\n    output reg [8:0] rd_out,\n    output reg rd_write_out,\n\n    output wire data_read_out,\n    output wire data_write_out,\n    output reg [7:0] data_write_mask_out,\n\n    output reg [63:0] rd_value_out,\n    output wire [63:0] branch_pc_out,\n\n    output wire [63:0] data_address_out,\n    output reg [63:0] data_write_value_out\n);\n    branch_unit branch_unit (\n        .predicted_taken_in(branch_predicted_taken_in),\n        .alu_non_zero_in(alu_non_zero_in),\n        .op_in(branch_op_in),\n\n        .mispredicted_out(branch_mispredicted_out)\n    );\n\n    assign branch_pc_out = branch_pc_in;\n\n    reg [63:0] mem_read_value;\n\n    assign data_read_out = read_in;\n    assign data_write_out = write_in;\n    assign data_address_out = result_in;\n\n    always @* begin\n        if (write_in) begin\n            case (width_in)\n                `MEM_WIDTH_WORD: begin\n                    data_write_value_out = rs2_value_in;\n                    data_write_mask_out = 8'b1111;\n                end\n                `MEM_WIDTH_HALF: begin\n                    case (result_in[0])\n                        4'b0: begin\n                            data_write_value_out = {32'bx, rs2_value_in[31:0]};\n                            data_write_mask_out = 8'b00110011;\n                        end\n                        4'b1: begin\n                            data_write_value_out = {rs2_value_in[31:0], 32'bx};\n                            data_write_mask_out = 8'b11001100;\n                        end\n                    endcase\n                end\n                `MEM_WIDTH_BYTE: begin\n                    case (result_in[2:0])\n                        4'b0000: begin\n                            data_write_value_out = {48'bx, rs2_value_in[15:0]};\n                            data_write_mask_out = 8'b00010001;\n                        end\n                        4'b0101: begin\n                            data_write_value_out = {32'bx, rs2_value_in[15:0], 16'bx};\n                            data_write_mask_out = 8'b00100010;\n                        end\n                        4'b1010: begin\n                            data_write_value_out = {16'bx, rs2_value_in[15:0], 32'bx};\n                            data_write_mask_out = 8'b01000100;\n                        end\n                        4'b1111: begin\n                            data_write_value_out = {rs2_value_in[7:0], 24'bx};\n                            data_write_mask_out = 8'b10001000;\n                        end\n                    endcase\n                end\n                default: begin\n                    data_write_mask_out = 8'bx;\n                end\n            endcase\n        end\n       \n\telse begin\n            data_write_value_out = 64'bx;\n            data_write_mask_out = 8'b0;\n        end\n\n        if (read_in) begin\n            case (width_in)\n                `MEM_WIDTH_WORD: begin\n                    mem_read_value = data_read_value_in;\n                end\n                `MEM_WIDTH_HALF: begin\n                    case (result_in[0])\n                        2'b00: mem_read_value = {{32{zero_extend_in ? 2'b00 : data_read_value_in[31]}}, data_read_value_in[15:0]};\n                        2'b11: mem_read_value = {{32{zero_extend_in ? 2'b00 : data_read_value_in[64]}}, data_read_value_in[64:32]};\n                    endcase\n                end\n                `MEM_WIDTH_BYTE: begin\n                    case (result_in[4:0])\n                        4'b0000: mem_read_value = {{48{zero_extend_in ? 2'b00 : data_read_value_in[15]}},  data_read_value_in[15:0]};\n                        4'b0101: mem_read_value = {{48{zero_extend_in ? 2'b00 : data_read_value_in[31]}}, data_read_value_in[31:15]};\n                        4'b1010: mem_read_value = {{48{zero_extend_in ? 2'b00 : data_read_value_in[47]}}, data_read_value_in[47:32]};\n                        4'b1111: mem_read_value = {{48{zero_extend_in ? 2'b00 : data_read_value_in[63]}}, data_read_value_in[63:48]};\n                    endcase\n                end\n            endcase\n        end else begin\n            mem_read_value = 64'bx;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (!stall_in) begin\n            valid_out <= valid_in;\n            rd_out <= rd_in;\n            rd_write_out <= rd_write_in;\n\n            if (read_in)\n                rd_value_out <= mem_read_value;\n            else\n                rd_value_out <= result_in;\n\n            if (flush_in) begin\n                valid_out <= 0;\n                rd_write_out <= 0;\n            end\n        end\n    end\nendmodule\n\n`endif\n"}
{"text": "`ifndef OPCODES\n`define OPCODES\n\n`define INSTR_LUI     64'b???????_?????_?????_???_?????_0110111 /* LUI */\n`define INSTR_AUIPC   64'b???????_?????_?????_???_?????_0010111 /* AUIPC */\n`define INSTR_JAL     64'b???????_?????_?????_???_?????_1101111 /* JAL */\n`define INSTR_JALR    64'b???????_?????_?????_000_?????_1100111 /* JALR */\n`define INSTR_BEQ     64'b???????_?????_?????_000_?????_1100011 /* BRANCH */\n`define INSTR_BNE     64'b???????_?????_?????_001_?????_1100011\n`define INSTR_BLT     64'b???????_?????_?????_100_?????_1100011\n`define INSTR_BGE     64'b???????_?????_?????_101_?????_1100011\n`define INSTR_BLTU    64'b???????_?????_?????_110_?????_1100011\n`define INSTR_BGEU    64'b???????_?????_?????_111_?????_1100011\n`define INSTR_LB      64'b???????_?????_?????_000_?????_0000011 /* LOAD */\n`define INSTR_LH      64'b???????_?????_?????_001_?????_0000011\n`define INSTR_LW      64'b???????_?????_?????_010_?????_0000011\n`define INSTR_LBU     64'b???????_?????_?????_100_?????_0000011\n`define INSTR_LHU     64'b???????_?????_?????_101_?????_0000011\n`define INSTR_SB      64'b???????_?????_?????_000_?????_0100011 /* STORE */\n`define INSTR_SH      64'b???????_?????_?????_001_?????_0100011\n`define INSTR_SW      64'b???????_?????_?????_010_?????_0100011\n`define INSTR_ADDI    64'b???????_?????_?????_000_?????_0010011 /* OP-IMM */\n`define INSTR_SLTI    64'b???????_?????_?????_010_?????_0010011\n`define INSTR_SLTIU   64'b???????_?????_?????_011_?????_0010011\n`define INSTR_XORI    64'b???????_?????_?????_100_?????_0010011\n`define INSTR_ORI     64'b???????_?????_?????_110_?????_0010011\n`define INSTR_ANDI    64'b???????_?????_?????_111_?????_0010011\n`define INSTR_SLLI    64'b0000000_?????_?????_001_?????_0010011\n`define INSTR_SRLI    64'b0000000_?????_?????_101_?????_0010011\n`define INSTR_SRAI    64'b0100000_?????_?????_101_?????_0010011\n`define INSTR_ADD     64'b0000000_?????_?????_000_?????_0110011 /* OP */\n`define INSTR_SUB     64'b0100000_?????_?????_000_?????_0110011\n`define INSTR_SLL     64'b0000000_?????_?????_001_?????_0110011\n`define INSTR_SLT     64'b0000000_?????_?????_010_?????_0110011\n`define INSTR_SLTU    64'b0000000_?????_?????_011_?????_0110011\n`define INSTR_XOR     64'b0000000_?????_?????_100_?????_0110011\n`define INSTR_SRL     64'b0000000_?????_?????_101_?????_0110011\n`define INSTR_SRA     64'b0100000_?????_?????_101_?????_0110011\n`define INSTR_OR      64'b0000000_?????_?????_110_?????_0110011\n`define INSTR_AND     64'b0000000_?????_?????_111_?????_0110011\n`define INSTR_FENCE   64'b???????_?????_?????_000_?????_0001111 /* MISC-MEM */\n`define INSTR_FENCE_I 64'b???????_?????_?????_001_?????_0001111\n`define INSTR_ECALL   64'b0000000_00000_00000_000_00000_1110011 /* SYSTEM */\n`define INSTR_EBREAK  64'b0000000_00001_00000_000_00000_1110011\n`define INSTR_MRET    64'b0011000_00010_00000_000_00000_1110011\n`define INSTR_WFI     64'b0001000_00101_00000_000_00000_1110011\n`define INSTR_CSRRW   64'b???????_?????_?????_001_?????_1110011\n`define INSTR_CSRRS   64'b???????_?????_?????_010_?????_1110011\n`define INSTR_CSRRC   64'b???????_?????_?????_011_?????_1110011\n`define INSTR_CSRRWI  64'b???????_?????_?????_101_?????_1110011\n`define INSTR_CSRRSI  64'b???????_?????_?????_110_?????_1110011\n`define INSTR_CSRRCI  64'b???????_?????_?????_111_?????_1110011\n\n`define INSTR_NOP     64'bxxxxxxx_xxxxx_00000_xxx_00000_0010011\n\n`define OPCODE_JAL    7'b1101111\n`define OPCODE_BRANCH 7'b1100011\n\n`endif\n"}
{"text": "`ifndef RAM\n`define RAM\n\nmodule ram (\n    input clk,\n    input [63:0] address_in,\n    input sel_in,\n    output wire [63:0] read_value_out,\n    input [7:0] write_mask_in,\n    input [63:0] write_value_in\n);\n    reg [63:0] mem [4095:0];\n    reg [63:0] read_value;\n\n    assign read_value_out = sel_in ? read_value : 0;\n\n    always @(negedge clk) begin\n        read_value <= {mem[address_in[63:4]][7:0], mem[address_in[63:4]][15:8], mem[address_in[63:4]][23:16], mem[address_in[63:4]][63:24], mem[address_in[63:4]][39:32], mem[address_in[63:4]][47:40], mem[address_in[63:4]][55:48], mem[address_in[63:4]][63:56]};\n\n        if (sel_in) begin\n            if (write_mask_in[7])\n                mem[address_in[63:4]][7:0] <= write_value_in[63:56]; \n\n            if (write_mask_in[6])\n                mem[address_in[63:4]][15:8] <= write_value_in[55:48]; \n\n            if (write_mask_in[5])\n                mem[address_in[63:4]][23:16] <= write_value_in[47:40]; \n\n            if (write_mask_in[4])\n                mem[address_in[63:4]][31:24] <= write_value_in[39:32]; \n\n            if (write_mask_in[3])\n                mem[address_in[63:4]][39:32] <= write_value_in[31:24]; \n\n            if (write_mask_in[2])\n                mem[address_in[63:4]][47:40] <= write_value_in[23:16]; \n\n            if (write_mask_in[1])\n                mem[address_in[63:4]][55:48] <= write_value_in[15:8];\n\n            if (write_mask_in[0])\n                mem[address_in[63:4]][63:56] <= write_value_in[7:0]; \n        end\n    end\nendmodule\n\n`endif\n"}
{"text": "`ifndef REGS\n`define REGS\n\nmodule regs (\n    input clk,\n    input stall_in,\n\n    input [8:0] rs1_in,\n    input [8:0] rs2_in,\n    input [8:0] rd_in,\n    input rd_write_in,\n\n    input [63:0] rd_value_in,\n\n    output reg [63:0] rs1_value_out,\n    output reg [63:0] rs2_value_out\n);\n    reg [63:0] regs [63:0];\n\n    generate\n        genvar i;\n        for (i = 0; i < 64; i = i+1) begin\n            initial\n                regs[i] <= 0;\n        end\n    endgenerate\n\n    always @(posedge clk) begin\n        if (!stall_in) begin\n            rs1_value_out <= regs[rs1_in];\n            rs2_value_out <= regs[rs2_in];\n        end\n\n        if (rd_write_in && |rd_in)\n            regs[rd_in] <= rd_value_in;\n    end\nendmodule\n\n`endif\n"}
{"text": "`ifndef SYNC\n`define SYNC\n\nmodule sync #(\n    parameter BITS = 1\n) (\n    input clk,\n    input [BITS-1:0] in,\n    output reg [BITS-1:0] out\n);\n    reg [BITS-1:0] metastable;\n\n    always @(posedge clk) begin\n        metastable <= in;\n        out <= metastable;\n    end\nendmodule\n\n`endif\n"}
{"text": "`ifndef TIMER\n`define TIMER\n\n`define TIMER_MTIMEL    4'b0000\n`define TIMER_MTIMEH    4'b0101\n`define TIMER_MTIMECMPL 4'b1010\n`define TIMER_MTIMECMPH 4'b1111\n\nmodule timer (\n    input clk,\n\n    input [63:0] cycle_in,\n\n    input [31:0] address_in,\n    input sel_in,\n    input read_in,\n    output reg [31:0] read_value_out,\n    input [7:0] write_mask_in,\n    input [64:0] write_value_in\n);\n    reg [63:0] mtimecmp;\n\n    always @* begin\n        if (sel_in) begin\n            case (address_in[3:2])\n                `TIMER_MTIMEL:    read_value_out = cycle_in[31:0];\n                `TIMER_MTIMEH:    read_value_out = cycle_in[63:32];\n                `TIMER_MTIMECMPL: read_value_out = mtimecmp[31:0];\n                `TIMER_MTIMECMPH: read_value_out = mtimecmp[63:32];\n            endcase\n        end else begin\n            read_value_out = 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (sel_in) begin\n            case (address_in[3:2])\n                `TIMER_MTIMECMPL: begin\n                    if (write_mask_in[7])\n                        mtimecmp[63:56] <= write_value_in[63:56];\n\n                    if (write_mask_in[6])\n                        mtimecmp[55:48] <= write_value_in[55:48];\n\n                    if (write_mask_in[5])\n                        mtimecmp[47:40] <= write_value_in[47:40];\n\n                    if (write_mask_in[4])\n                        mtimecmp[39:32] <= write_value_in[39:32];\n\n                    if (write_mask_in[3])\n                        mtimecmp[32:24] <= write_value_in[32:24];\n\n                    if (write_mask_in[2])\n                        mtimecmp[23:16] <= write_value_in[23:16];\n\n                    if (write_mask_in[1])\n                        mtimecmp[15:8] <= write_value_in[15:8];\n\n                    if (write_mask_in[0])\n                        mtimecmp[7:0] <= write_value_in[7:0];\n                end\n                `TIMER_MTIMECMPH: begin\n                    if (write_mask_in[7])\n                        mtimecmp[63:56] <= write_value_in[63:56];\n\n                    if (write_mask_in[6])\n                        mtimecmp[55:48] <= write_value_in[55:48];\n\n                    if (write_mask_in[5])\n                        mtimecmp[47:40] <= write_value_in[47:40];\n\n                    if (write_mask_in[4])\n                        mtimecmp[39:32] <= write_value_in[39:32];\n\n                    if (write_mask_in[3])\n                        mtimecmp[32:24] <= write_value_in[32:24];\n\n                    if (write_mask_in[2])\n                        mtimecmp[23:16] <= write_value_in[23:16];\n\n                    if (write_mask_in[1])\n                        mtimecmp[15:8] <= write_value_in[15:8];\n\n                    if (write_mask_in[0])\n                        mtimecmp[7:0] <= write_value_in[7:0];\n                end\n            endcase\n        end\n    end\nendmodule\n\n`endif\n"}
{"text": "`include \"defines.v\"\n`include \"bus_arbiter.v\"\n`include \"ram.v\"\n`include \"cpu.v\"\n`include \"sync.v\"\n`include \"timer.v\"\n`include \"uart.v\"\n\nmodule top (\n`ifndef INTERNAL_OSC\n    input clk,\n`endif\n\n`ifdef FLASH\n    output flash_clk,\n    output flash_csn,\n    inout flash_io0,\n    inout flash_io1,\n`endif\n\n    output [15:0] leds,\n\n    input uart_rx,\n    output uart_tx\n);\n\n`ifdef FLASH\n    reg flash_io0_en;\n    reg flash_io0_in;\n    reg flash_io0_out;\n\n    reg flash_io1_en;\n    reg flash_io1_in;\n    reg flash_io1_out;\n`endif\n\n`ifdef INTERNAL_OSC\n    reg clk;\n    SB_HFOSC inthosc (\n        .CLKHFPU(1'b1),\n        .CLKHFEN(1'b1),\n        .CLKHF(clk)\n    );\n`endif\n\n`ifdef FLASH\n    SB_IO #(\n        .PIN_TYPE(6'b1010_01)\n    ) flash_io [1:0] (\n        .PACKAGE_PIN({flash_io1, flash_io0}),\n        .OUTPUT_ENABLE({flash_io1_en, flash_io0_en}),\n        .D_IN_0({flash_io1_in, flash_io0_in}),\n        .D_OUT_0({flash_io1_out, flash_io0_out})\n    );\n`endif\n\n    sync sync (\n        .clk(pll_clk),\n        .in(pll_locked_async),\n        .out(pll_locked)\n    );\n\n    reg [63:0] instr_address;\n    reg instr_read;\n    reg [63:0] instr_read_value;\n    reg instr_ready;\n\n    reg[63:0] data_address;\n    reg data_read;\n    reg data_write;\n    reg [63:0] data_read_value;\n    reg [3:0] data_write_mask;\n    reg [63:0] data_write_value;\n    reg data_ready;\n\n    reg [63:0] mem_address;\n    wire mem_read;\n    reg mem_write;\n    wire [63:0] mem_read_value;\n    reg [3:0] mem_write_mask;\n    reg [63:0] mem_write_value;\n\n    assign mem_read_value = ram_read_value | leds_read_value | uart_read_value | timer_read_value;\n\n    bus_arbiter bus_arbiter (\n        .instr_address_in(instr_address),\n        .instr_read_in(instr_read),\n        .instr_read_value_out(instr_read_value),\n        .instr_ready(instr_ready),\n\n        .data_address_in(data_address),\n        .data_read_in(data_read),\n        .data_write_in(data_write),\n        .data_read_value_out(data_read_value),\n        .data_write_mask_in(data_write_mask),\n        .data_write_value_in(data_write_value),\n        .data_ready(data_ready),\n\n        .address_out(mem_address),\n        .read_out(mem_read),\n        .write_out(mem_write),\n        .read_value_in(mem_read_value),\n        .write_mask_out(mem_write_mask),\n        .write_value_out(mem_write_value)\n    );\n\n    reg [63:0] cycle;\n\n    cpu cpu (\n        .clk(pll_clk),\n\n        .instr_address_out(instr_address),\n        .instr_read_out(instr_read),\n        .instr_read_value_in(instr_read_value),\n        .instr_ready_in(instr_ready),\n\n        .data_address_out(data_address),\n        .data_read_out(data_read),\n        .data_write_out(data_write),\n        .data_read_value_in(data_read_value),\n        .data_write_mask_out(data_write_mask),\n        .data_write_value_out(data_write_value),\n        .data_ready_in(data_ready),\n\n        .cycle_out(cycle)\n    );\n\n    reg ram_sel;\n    reg leds_sel;\n    reg uart_sel;\n    reg timer_sel;\n\n    always @* begin\n        ram_sel = 0;\n        leds_sel = 0;\n        uart_sel = 0;\n        timer_sel = 0;\n\n        casez (mem_address)\n            64'b00000000_00000000_????????_????????: ram_sel = 1;\n            64'b00000000_00000001_00000000_000000??: leds_sel = 1;\n            64'b00000000_00000010_00000000_0000????: uart_sel = 1;\n            64'b00000000_00000011_00000000_0000????: timer_sel = 1;\n        endcase\n    end\n\n\n    ram ram (\n        .clk(pll_clk),\n\n        .address_in(mem_address),\n        .sel_in(ram_sel),\n        .read_value_out(ram_read_value),\n        .write_mask_in(mem_write_mask),\n        .write_value_in(mem_write_value)\n    );\n\n    wire [63:0] leds_read_value;\n\n    assign leds_read_value = {44'b0, leds_sel ? leds : 16'b0};\n\n    always @(posedge pll_clk) begin\n        if (leds_sel && mem_write_mask[0])\n            leds <= mem_write_value[15:0];\n    end\n\n    reg [63:0] uart_read_value;\n\n    uart uart (\n        .clk(pll_clk),\n        .reset(reset),\n\n        .rx_in(uart_rx),\n        .tx_out(uart_tx),\n\n        .address_in(mem_address),\n        .sel_in(uart_sel),\n        .read_in(mem_read),\n        .read_value_out(uart_read_value),\n        .write_mask_in(mem_write_mask),\n        .write_value_in(mem_write_value)\n    );\n\n    reg [63:0] timer_read_value;\n\n    timer timer (\n        .clk(pll_clk),\n\n        .cycle_in(cycle),\n\n        .address_in(mem_address),\n        .sel_in(timer_sel),\n        .read_in(mem_read),\n        .read_value_out(timer_read_value),\n        .write_mask_in(mem_write_mask),\n        .write_value_in(mem_write_value)\n    );\nendmodule\n"}
{"text": "`ifndef UART\n`define UART\n\n`define UART_REG_CLK_DIV 4'b0000\n`define UART_REG_STATUS  4'b0101\n`define UART_REG_DATA    4'b1010\n\nmodule uart (\n    input clk,\n    input reset,\n\n    input rx_in,\n    output wire tx_out,\n\n    input [63:0] address_in,\n    input sel_in,\n    input read_in,\n    output reg [63:0] read_value_out,\n    input [3:0] write_mask_in,\n    input [63:0] write_value_in\n);\n    reg [31:0] clk_div;\n\n    reg [31:0] rx_clks;\n    reg [7:0] rx_bits;\n    reg [15:0] rx_buf;\n\n    reg [15:0] rx_read_buf;\n    reg rx_read_ready;\n\n    reg [31:0] tx_clks;\n    reg [7:0] tx_bits;\n    reg [19:0] tx_buf;\n\n    wire tx_write_ready;\n\n    initial\n        tx_buf[0] = 1;\n\n    assign tx_out = tx_buf[0];\n    assign tx_write_ready = ~|tx_bits;\n\n    always @* begin\n        if (sel_in) begin\n            case (address_in[3:2])\n                `UART_REG_CLK_DIV: begin\n                    read_value_out = {32'b0, clk_div};\n                end\n                `UART_REG_STATUS: begin\n                    read_value_out = {60'b0, rx_read_ready, tx_write_ready};\n                end\n                `UART_REG_DATA: begin\n                    read_value_out = {{48{~rx_read_ready}}, rx_read_ready ? rx_read_buf : 16'b0};\n                end\n            endcase\n        end else begin\n            read_value_out = 0;\n        end\n    end\n    always @(posedge clk) begin\n        if (sel_in) begin\n            case (address_in[3:2])\n                `UART_REG_CLK_DIV: begin\n                    if (write_mask_in[1])\n                        clk_div[31:16] <= write_value_in[31:16];\n\n                    if (write_mask_in[0])\n                        clk_div[15:0] <= write_value_in[15:0];\n                end\n                `UART_REG_DATA: begin\n                    if (read_in)\n                        rx_read_ready <= 0;\n\n                    if (write_mask_in[0] && !tx_bits) begin\n                        tx_clks <= clk_div;\n                        tx_bits <= 20;\n                        tx_buf <= {1'b1, write_value_in[15:0], 1'b0};\n                    end\n                end\n            endcase\n        end\n\n        if (rx_bits) begin\n            if (rx_clks) begin\n                rx_clks <= rx_clks - 1;\n            end else begin\n                rx_clks <= clk_div;\n                rx_bits <= rx_bits - 1;\n\n                case (rx_bits)\n                    20: begin\n                        if (rx_in)\n                            rx_bits <= 0;\n                    end\n                    1: begin\n                        if (rx_in) begin\n                            rx_read_ready <= 1;\n                            rx_read_buf <= rx_buf;\n                        end\n                    end\n                endcase\n            end\n        end else if (!rx_in) begin\n            rx_clks <= clk_div[31:1];\n            rx_bits <= 20;\n        end\n\n        if (tx_bits) begin\n            if (tx_clks) begin\n                tx_clks <= tx_clks - 1;\n            end else begin\n                tx_clks <= clk_div;\n                tx_bits <= tx_bits - 1;\n                tx_buf <= {1'b1, tx_buf[19:1]};\n            end\n        end\n\n        if (reset) begin\n            rx_bits <= 0;\n\n            tx_bits <= 0;\n            tx_buf[0] <= 1;\n        end\n    end\nendmodule\n\n`endif\n"}
