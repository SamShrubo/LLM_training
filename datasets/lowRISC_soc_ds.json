{"text": "function [6:0] ASCII_code;\n\n   input [6:0] scancode;\n   input       shift;\n\n   begin\n      case (scancode)\n        7'H0: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H1: ASCII_code = shift ? 7'H1B /* ? */ : 7'H1B /* ? */;\n        7'H2: ASCII_code = shift ? 7'H21 /* ! */ : 7'H31 /* 1 */;\n        7'H3: ASCII_code = shift ? 7'H22 /* \" */ : 7'H32 /* 2 */;\n        7'H4: ASCII_code = shift ? 7'H23 /* # */ : 7'H33 /* 3 */;\n        7'H5: ASCII_code = shift ? 7'H24 /* $ */ : 7'H34 /* 4 */;\n        7'H6: ASCII_code = shift ? 7'H25 /* % */ : 7'H35 /* 5 */;\n        7'H7: ASCII_code = shift ? 7'H5E /* ^ */ : 7'H36 /* 6 */;\n        7'H8: ASCII_code = shift ? 7'H26 /* & */ : 7'H37 /* 7 */;\n        7'H9: ASCII_code = shift ? 7'H2A /* * */ : 7'H38 /* 8 */;\n        7'HA: ASCII_code = shift ? 7'H28 /* ( */ : 7'H39 /* 9 */;\n        7'HB: ASCII_code = shift ? 7'H29 /* ) */ : 7'H30 /* 0 */;\n        7'HC: ASCII_code = shift ? 7'H5F /* _ */ : 7'H2D /* - */;\n        7'HD: ASCII_code = shift ? 7'H2B /* + */ : 7'H3D /* = */;\n        7'HE: ASCII_code = shift ? 7'H8 /* ? */ : 7'H8 /* ? */;\n        7'HF: ASCII_code = shift ? 7'H9 /* ? */ : 7'H9 /* ? */;\n        7'H10: ASCII_code = shift ? 7'H51 /* Q */ : 7'H71 /* q */;\n        7'H11: ASCII_code = shift ? 7'H57 /* W */ : 7'H77 /* w */;\n        7'H12: ASCII_code = shift ? 7'H45 /* E */ : 7'H65 /* e */;\n        7'H13: ASCII_code = shift ? 7'H52 /* R */ : 7'H72 /* r */;\n        7'H14: ASCII_code = shift ? 7'H54 /* T */ : 7'H74 /* t */;\n        7'H15: ASCII_code = shift ? 7'H59 /* Y */ : 7'H79 /* y */;\n        7'H16: ASCII_code = shift ? 7'H55 /* U */ : 7'H75 /* u */;\n        7'H17: ASCII_code = shift ? 7'H49 /* I */ : 7'H69 /* i */;\n        7'H18: ASCII_code = shift ? 7'H4F /* O */ : 7'H6F /* o */;\n        7'H19: ASCII_code = shift ? 7'H50 /* P */ : 7'H70 /* p */;\n        7'H1A: ASCII_code = shift ? 7'H7B /* { */ : 7'H5B /* [ */;\n        7'H1B: ASCII_code = shift ? 7'H7D /* } */ : 7'H5D /* ] */;\n        7'H1C: ASCII_code = shift ? 7'HD /* ? */ : 7'HD /* ? */;\n        7'H1D: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H1E: ASCII_code = shift ? 7'H41 /* A */ : 7'H61 /* a */;\n        7'H1F: ASCII_code = shift ? 7'H53 /* S */ : 7'H73 /* s */;\n        7'H20: ASCII_code = shift ? 7'H44 /* D */ : 7'H64 /* d */;\n        7'H21: ASCII_code = shift ? 7'H46 /* F */ : 7'H66 /* f */;\n        7'H22: ASCII_code = shift ? 7'H47 /* G */ : 7'H67 /* g */;\n        7'H23: ASCII_code = shift ? 7'H48 /* H */ : 7'H68 /* h */;\n        7'H24: ASCII_code = shift ? 7'H4A /* J */ : 7'H6A /* j */;\n        7'H25: ASCII_code = shift ? 7'H4B /* K */ : 7'H6B /* k */;\n        7'H26: ASCII_code = shift ? 7'H4C /* L */ : 7'H6C /* l */;\n        7'H27: ASCII_code = shift ? 7'H3A /* : */ : 7'H3B /* ; */;\n        7'H28: ASCII_code = shift ? 7'H40 /* @ */ : 7'H27 /* ' */;\n        7'H29: ASCII_code = shift ? 7'H60 /* ` */ : 7'H60 /* ` */;\n        7'H2A: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H2B: ASCII_code = shift ? 7'H7C /* | */ : 7'H5C /* \\ */;\n        7'H2C: ASCII_code = shift ? 7'H5A /* Z */ : 7'H7A /* z */;\n        7'H2D: ASCII_code = shift ? 7'H58 /* X */ : 7'H78 /* x */;\n        7'H2E: ASCII_code = shift ? 7'H43 /* C */ : 7'H63 /* c */;\n        7'H2F: ASCII_code = shift ? 7'H56 /* V */ : 7'H76 /* v */;\n        7'H30: ASCII_code = shift ? 7'H42 /* B */ : 7'H62 /* b */;\n        7'H31: ASCII_code = shift ? 7'H4E /* N */ : 7'H6E /* n */;\n        7'H32: ASCII_code = shift ? 7'H4D /* M */ : 7'H6D /* m */;\n        7'H33: ASCII_code = shift ? 7'H3C /* < */ : 7'H2C /* , */;\n        7'H34: ASCII_code = shift ? 7'H3E /* > */ : 7'H2E /* . */;\n        7'H35: ASCII_code = shift ? 7'H3F /* ? */ : 7'H2F /* / */;\n        7'H36: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H37: ASCII_code = shift ? 7'H2A /* * */ : 7'H2A /* * */;\n        7'H38: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H39: ASCII_code = shift ? 7'H20 /* ? */ : 7'H20 /* ? */;\n        7'H3A: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H3B: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H3C: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H3D: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H3E: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H3F: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H40: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H41: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H42: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H43: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H44: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H45: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H46: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H47: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H48: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H49: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H4A: ASCII_code = shift ? 7'H5F /* _ */ : 7'H2D /* - */;\n        7'H4B: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H4C: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H4D: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H4E: ASCII_code = shift ? 7'H2B /* + */ : 7'H2B /* + */;\n        7'H4F: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H50: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H51: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H52: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H53: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H54: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H55: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H56: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H57: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H58: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H59: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H5A: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H5B: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H5C: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H5D: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H5E: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H5F: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H60: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H61: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H62: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H63: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H64: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H65: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H66: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H67: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H68: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H69: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H6A: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H6B: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H6C: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H6D: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H6E: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H6F: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H70: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H71: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H72: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H73: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H74: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H75: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H76: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H77: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H78: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H79: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H7A: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H7B: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H7C: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H7D: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H7E: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n        7'H7F: ASCII_code = shift ? 7'H0 /* ? */ : 7'H0 /* ? */;\n      endcase\n   end\n\nendfunction\n"}
{"text": "// See LICENSE.SiFive for license details.\n\n/** This black-boxes an Async Reset\n  * Reg.\n  *  \n  * Because Chisel doesn't support\n  * parameterized black boxes, \n  * we unfortunately have to \n  * instantiate a number of these.\n  *  \n  * We also have to hard-code the set/reset.\n  *  \n  *  Do not confuse an asynchronous\n  *  reset signal with an asynchronously\n  *  reset reg. You should still \n  *  properly synchronize your reset \n  *  deassertion.\n  *  \n  *  @param d Data input\n  *  @param q Data Output\n  *  @param clk Clock Input\n  *  @param rst Reset Input\n  *  @param en Write Enable Input\n  *  \n  */\n\n`default_nettype wire\n\nmodule AsyncResetReg (\n                      input      d,\n                      output reg q,\n                      input      en,\n\n                      input      clk,\n                      input      rst);\n   \n   always @(posedge clk or posedge rst) begin\n\n      if (rst) begin\n         q <= 1'b0;\n      end else if (en) begin\n         q <= d;\n      end\n   end\n   \n\nendmodule // AsyncResetReg\n\n"}
{"text": "/*\n\nCopyright (c) 2015-2017 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\ncommit 9a507b388ddddb0a7b54f88ad217d5e4bc48822c\nAuthor: Alex Forencich <alex@alexforencich.com>\nDate:   Fri Jun 9 21:17:28 2017 -0700\n\norigin\thttps://github.com/alexforencich/verilog-ethernet.git\n\nModified by the lowrisc team (Jonathan Kimmitt) to extract CRC bytes\n*/\n\n// Language: Verilog 2001\n\n`timescale 1ns / 1ps\n\n/*\n * AXI4-Stream GMII frame receiver (GMII in, AXI out)\n */\nmodule axis_gmii_rx\n(\n    input  wire        clk,\n    input  wire        rst,\n\n    /*\n     * GMII input\n     */\n    input  wire [7:0]  gmii_rxd,\n    input  wire        gmii_rx_dv,\n    input  wire        gmii_rx_er,\n\n    /*\n     * AXI output\n     */\n    output wire [7:0]  output_axis_tdata,\n    output wire        output_axis_tvalid,\n    output wire        output_axis_tlast,\n    output wire        output_axis_tuser,\n\n    /*\n     * Control\n     */\n    input  wire        clk_enable,\n    input  wire        mii_select,\n\n    /*\n     * Status\n     */\n    output wire        error_bad_frame,\n    output wire        error_bad_fcs,\n\n    /* debug */\n    output reg [31:0]  fcs_reg\n \n);\n\nlocalparam [2:0]\n    STATE_IDLE = 3'd0,\n    STATE_PAYLOAD = 3'd1,\n    STATE_WAIT_LAST = 3'd2,\n    STATE_CRC = 3'd3;\n   \nreg [2:0] state_reg = STATE_IDLE, state_next;\n\n// datapath control signals\nreg reset_crc;\nreg update_crc;\n\nreg mii_odd = 1'b0;\nreg mii_locked = 1'b0;\n\nreg [7:0] gmii_rxd_d0 = 8'd0;\nreg [7:0] gmii_rxd_d1 = 8'd0;\nreg [7:0] gmii_rxd_d2 = 8'd0;\nreg [7:0] gmii_rxd_d3 = 8'd0;\nreg [7:0] gmii_rxd_d4 = 8'd0;\n\nreg gmii_rx_dv_d0 = 1'b0;\nreg gmii_rx_dv_d1 = 1'b0;\nreg gmii_rx_dv_d2 = 1'b0;\nreg gmii_rx_dv_d3 = 1'b0;\nreg gmii_rx_dv_d4 = 1'b0;\n\nreg gmii_rx_er_d0 = 1'b0;\nreg gmii_rx_er_d1 = 1'b0;\nreg gmii_rx_er_d2 = 1'b0;\nreg gmii_rx_er_d3 = 1'b0;\nreg gmii_rx_er_d4 = 1'b0;\n\nreg [7:0] output_axis_tdata_reg = 8'd0, output_axis_tdata_next;\nreg output_axis_tvalid_reg = 1'b0, output_axis_tvalid_next;\nreg output_axis_tlast_reg = 1'b0, output_axis_tlast_next;\nreg output_axis_tuser_reg = 1'b0, output_axis_tuser_next;\n\nreg error_bad_frame_reg = 1'b0, error_bad_frame_next;\nreg error_bad_fcs_reg = 1'b0, error_bad_fcs_next;\nreg [31:0] fcs_next;\nreg [31:0] crc_state;\nreg [1:0] crc_cnt, crc_cnt_next;\n\nwire [31:0] crc_next;\n\nassign output_axis_tdata = output_axis_tdata_reg;\nassign output_axis_tvalid = output_axis_tvalid_reg;\nassign output_axis_tlast = output_axis_tlast_reg;\nassign output_axis_tuser = output_axis_tuser_reg;\n\nassign error_bad_frame = error_bad_frame_reg;\nassign error_bad_fcs = error_bad_fcs_reg;\n\neth_lfsr #(\n    .LFSR_WIDTH(32),\n    .LFSR_POLY(32'h4c11db7),\n    .LFSR_CONFIG(\"GALOIS\"),\n    .LFSR_FEED_FORWARD(0),\n    .REVERSE(1),\n    .DATA_WIDTH(8),\n    .STYLE(\"AUTO\")\n)\neth_crc_8 (\n    .data_in(gmii_rxd_d4),\n    .state_in(crc_state),\n    .data_out(),\n    .state_out(crc_next)\n);\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n    update_crc = 1'b0;\n\n    output_axis_tdata_next = 8'd0;\n    output_axis_tvalid_next = 1'b0;\n    output_axis_tlast_next = 1'b0;\n    output_axis_tuser_next = 1'b0;\n\n    error_bad_frame_next = 1'b0;\n    error_bad_fcs_next = 1'b0;\n    fcs_next = fcs_reg;\n    crc_cnt_next = crc_cnt;\n   \n    if (!clk_enable) begin\n        // clock disabled - hold state\n        state_next = state_reg;\n    end else if (mii_select & ~mii_odd) begin\n        // MII even cycle - hold state\n        state_next = state_reg;\n    end else begin\n        case (state_reg)\n            STATE_IDLE: begin\n                // idle state - wait for packet\n                reset_crc = 1'b1;\n\n                if (gmii_rx_dv_d4 && ~gmii_rx_er_d4 && gmii_rxd_d4 == 8'hD5) begin\n                    state_next = STATE_PAYLOAD;\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n            STATE_PAYLOAD: begin\n                // read payload\n                update_crc = 1'b1;\n\n                output_axis_tdata_next = gmii_rxd_d4;\n                output_axis_tvalid_next = 1'b1;\n\n                if (gmii_rx_dv_d4 & gmii_rx_er_d4) begin\n                    // error\n                    output_axis_tlast_next = 1'b1;\n                    output_axis_tuser_next = 1'b1;\n                    error_bad_frame_next = 1'b1;\n                    fcs_next = 32'HDEADBEEF;\n                    state_next = STATE_WAIT_LAST;\n                end else if (~gmii_rx_dv) begin\n                    if (gmii_rx_er_d0 | gmii_rx_er_d1 | gmii_rx_er_d2 | gmii_rx_er_d3) begin\n                        // error received in FCS bytes\n                        output_axis_tuser_next = 1'b1;\n                        error_bad_frame_next = 1'b1;\n                    end else if ({gmii_rxd_d0, gmii_rxd_d1, gmii_rxd_d2, gmii_rxd_d3} == ~crc_next) begin\n                        // FCS good\n                        output_axis_tuser_next = 1'b0;\n                    end else begin\n                        // FCS bad\n                        output_axis_tuser_next = 1'b1;\n                        error_bad_frame_next = 1'b1;\n                        error_bad_fcs_next = 1'b1;\n                    end\n                    crc_cnt_next = 2'b0;\n                    state_next = STATE_CRC;\n                end else begin\n                    state_next = STATE_PAYLOAD;\n                end\n            end\n            STATE_CRC: begin\n                // wait for CRC\n                update_crc = 1'b1;\n\n                output_axis_tdata_next = gmii_rxd_d4;\n                output_axis_tvalid_next = 1'b1;\n\n                crc_cnt_next = crc_cnt + 1;\n                if (&crc_cnt) begin\n                    // end of packet + CRC bytes\n                    fcs_next = crc_next;\n                    output_axis_tlast_next = 1'b1;\n                    state_next = STATE_IDLE;\n                end else begin\n                    fcs_next = 32'b0;\n                    state_next = STATE_CRC;\n                end\n            end\n            STATE_WAIT_LAST: begin\n                // wait for end of packet\n\n                if (~gmii_rx_dv) begin\n                    state_next = STATE_IDLE;\n                end else begin\n                    state_next = STATE_WAIT_LAST;\n                end\n            end\n            default:;\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n\n        output_axis_tvalid_reg <= 1'b0;\n\n        error_bad_frame_reg <= 1'b0;\n        error_bad_fcs_reg <= 1'b0;\n        fcs_reg <= 32'hFFFFFFFF;\n        crc_state <= 32'hFFFFFFFF;\n        crc_cnt <= 2'b0;\n       \n        mii_locked <= 1'b0;\n        mii_odd <= 1'b0;\n\n        gmii_rx_dv_d0 <= 1'b0;\n        gmii_rx_dv_d1 <= 1'b0;\n        gmii_rx_dv_d2 <= 1'b0;\n        gmii_rx_dv_d3 <= 1'b0;\n        gmii_rx_dv_d4 <= 1'b0;\n    end else begin\n        state_reg <= state_next;\n\n        output_axis_tvalid_reg <= output_axis_tvalid_next;\n\n        error_bad_frame_reg <= error_bad_frame_next;\n        error_bad_fcs_reg <= error_bad_fcs_next;\n\n        fcs_reg <= fcs_next;\n        crc_cnt <= crc_cnt_next;\n       \n        // datapath\n        if (reset_crc) begin\n            crc_state <= 32'hFFFFFFFF;\n        end else if (update_crc) begin\n            crc_state <= crc_next;\n        end\n\n        if (clk_enable) begin\n            if (mii_select) begin\n                mii_odd <= ~mii_odd;\n\n                if (mii_locked) begin\n                    mii_locked <= gmii_rx_dv;\n                end else if (gmii_rx_dv & {gmii_rxd[3:0], gmii_rxd_d0[7:4]} == 8'hD5) begin\n                    mii_locked <= 1'b1;\n                    mii_odd <= 1'b1;\n                end\n\n                if (mii_odd) begin\n                    gmii_rx_dv_d0 <= gmii_rx_dv & gmii_rx_dv_d0;\n                    gmii_rx_dv_d1 <= gmii_rx_dv_d0 & gmii_rx_dv;\n                    gmii_rx_dv_d2 <= gmii_rx_dv_d1 & gmii_rx_dv;\n                    gmii_rx_dv_d3 <= gmii_rx_dv_d2 & gmii_rx_dv;\n                    gmii_rx_dv_d4 <= gmii_rx_dv_d3 & gmii_rx_dv;\n                end else begin\n                    gmii_rx_dv_d0 <= gmii_rx_dv;\n                end\n            end else begin\n                gmii_rx_dv_d0 <= gmii_rx_dv;\n                gmii_rx_dv_d1 <= gmii_rx_dv_d0 & gmii_rx_dv;\n                gmii_rx_dv_d2 <= gmii_rx_dv_d1 & gmii_rx_dv;\n                gmii_rx_dv_d3 <= gmii_rx_dv_d2 & gmii_rx_dv;\n                gmii_rx_dv_d4 <= gmii_rx_dv_d3 & gmii_rx_dv;\n            end\n        end\n    end\n\n    output_axis_tdata_reg <= output_axis_tdata_next;\n    output_axis_tlast_reg <= output_axis_tlast_next;\n    output_axis_tuser_reg <= output_axis_tuser_next;\n\n    // delay input\n    if (clk_enable) begin\n        if (mii_select) begin\n            gmii_rxd_d0 <= {gmii_rxd[3:0], gmii_rxd_d0[7:4]};\n\n            if (mii_odd) begin\n                gmii_rxd_d1 <= gmii_rxd_d0;\n                gmii_rxd_d2 <= gmii_rxd_d1;\n                gmii_rxd_d3 <= gmii_rxd_d2;\n                gmii_rxd_d4 <= gmii_rxd_d3;\n\n                gmii_rx_er_d0 <= gmii_rx_er | gmii_rx_er_d0;\n                gmii_rx_er_d1 <= gmii_rx_er_d0;\n                gmii_rx_er_d2 <= gmii_rx_er_d1;\n                gmii_rx_er_d3 <= gmii_rx_er_d2;\n                gmii_rx_er_d4 <= gmii_rx_er_d3;\n            end else begin\n                gmii_rx_er_d0 <= gmii_rx_er;\n            end\n        end else begin\n            gmii_rxd_d0 <= gmii_rxd;\n            gmii_rxd_d1 <= gmii_rxd_d0;\n            gmii_rxd_d2 <= gmii_rxd_d1;\n            gmii_rxd_d3 <= gmii_rxd_d2;\n            gmii_rxd_d4 <= gmii_rxd_d3;\n\n            gmii_rx_er_d0 <= gmii_rx_er;\n            gmii_rx_er_d1 <= gmii_rx_er_d0;\n            gmii_rx_er_d2 <= gmii_rx_er_d1;\n            gmii_rx_er_d3 <= gmii_rx_er_d2;\n            gmii_rx_er_d4 <= gmii_rx_er_d3;\n        end\n    end\nend\n\nendmodule\n"}
{"text": "/*\n\nCopyright (c) 2015-2017 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\ncommit 9a507b388ddddb0a7b54f88ad217d5e4bc48822c\nAuthor: Alex Forencich <alex@alexforencich.com>\nDate:   Fri Jun 9 21:17:28 2017 -0700\n\norigin\thttps://github.com/alexforencich/verilog-ethernet.git\n\nModified by the LowRISC team (Jonathan Kimmitt) to extract CRC and correct packet gap logic.\n*/\n\n// Language: Verilog 2001\n\n`timescale 1ns / 1ps\n\n/*\n * AXI4-Stream GMII frame transmitter (AXI in, GMII out)\n */\nmodule axis_gmii_tx #\n(\n    parameter ENABLE_PADDING = 1,\n    parameter MIN_FRAME_LENGTH = 64\n)\n(\n    input wire \t      clk,\n    input wire \t      rst,\n\n    /*\n     * AXI input\n     */\n    input wire [7:0]  input_axis_tdata,\n    input wire \t      input_axis_tvalid,\n    output wire       input_axis_tready,\n    input wire \t      input_axis_tlast,\n    input wire \t      input_axis_tuser,\n\n    /*\n     * GMII output\n     */\n    output wire [7:0] gmii_txd,\n    output wire       gmii_tx_en,\n    output wire       gmii_tx_er,\n\n    /*\n     * Control\n     */\n    input wire \t      clk_enable,\n    input wire \t      mii_select,\n\n    /*\n     * Configuration\n     */\n    input wire [7:0]  ifg_delay,\n\n    /* debug */\n    output reg [31:0] fcs_reg\n\n);\n\nlocalparam [2:0]\n    STATE_IDLE = 3'd0,\n    STATE_PREAMBLE = 3'd1,\n    STATE_PAYLOAD = 3'd2,\n    STATE_LAST = 3'd3,\n    STATE_PAD = 3'd4,\n    STATE_FCS = 3'd5,\n    STATE_WAIT_END = 3'd6,\n    STATE_IFG = 3'd7;\n\nreg [2:0] state_reg = STATE_IDLE, state_next;\n\n// datapath control signals\nreg reset_crc;\nreg update_crc;\n\nreg [7:0] input_tdata_reg = 8'd0, input_tdata_next, ifg_reg, ifg_next;\n\nreg mii_odd_reg = 1'b0, mii_odd_next;\nreg [3:0] mii_msn_reg = 4'b0, mii_msn_next;\n\nreg [15:0] frame_ptr_reg = 16'd0, frame_ptr_next;\n\nreg [7:0] gmii_txd_reg = 8'd0, gmii_txd_next;\nreg gmii_tx_en_reg = 1'b0, gmii_tx_en_next;\nreg gmii_tx_er_reg = 1'b0, gmii_tx_er_next;\n\nreg input_axis_tready_reg = 1'b0, input_axis_tready_next;\nreg [31:0] crc_state, fcs_next;   \n\nwire [31:0] crc_next;\n\nassign input_axis_tready = input_axis_tready_reg;\n\nassign gmii_txd = gmii_txd_reg;\nassign gmii_tx_en = gmii_tx_en_reg;\nassign gmii_tx_er = gmii_tx_er_reg;\n\neth_lfsr #(\n    .LFSR_WIDTH(32),\n    .LFSR_POLY(32'h4c11db7),\n    .LFSR_CONFIG(\"GALOIS\"),\n    .LFSR_FEED_FORWARD(0),\n    .REVERSE(1),\n    .DATA_WIDTH(8),\n    .STYLE(\"AUTO\")\n)\neth_crc_8 (\n    .data_in(input_tdata_reg),\n    .state_in(crc_state),\n    .data_out(),\n    .state_out(crc_next)\n);\n\nalways @* begin\n    state_next = STATE_IDLE;\n\n    reset_crc = 1'b0;\n    update_crc = 1'b0;\n\n    mii_odd_next = mii_odd_reg;\n    mii_msn_next = mii_msn_reg;\n\n    frame_ptr_next = frame_ptr_reg;\n    fcs_next = fcs_reg;\n    ifg_next = ifg_reg;\n\n    input_axis_tready_next = 1'b0;\n\n    input_tdata_next = input_tdata_reg;\n\n    gmii_txd_next = 8'd0;\n    gmii_tx_en_next = 1'b0;\n    gmii_tx_er_next = 1'b0;\n\n    if (!clk_enable) begin\n        // clock disabled - hold state and outputs\n        gmii_txd_next = gmii_txd_reg;\n        gmii_tx_en_next = gmii_tx_en_reg;\n        gmii_tx_er_next = gmii_tx_er_reg;\n        state_next = state_reg;\n    end else if (mii_select & mii_odd_reg) begin\n        // MII odd cycle - hold state, output MSN\n        mii_odd_next = 1'b0;\n        gmii_txd_next = {4'd0, mii_msn_reg};\n        gmii_tx_en_next = gmii_tx_en_reg;\n        gmii_tx_er_next = gmii_tx_er_reg;\n        state_next = state_reg;\n    end else begin\n        case (state_reg)\n            STATE_IDLE: begin\n                // idle state - wait for packet\n                reset_crc = 1'b1;\n                mii_odd_next = 1'b0;\n\n                if (input_axis_tvalid) begin\n                    mii_odd_next = 1'b1;\n                    frame_ptr_next = 16'd1;\n                    gmii_txd_next = 8'h55; // Preamble\n                    gmii_tx_en_next = 1'b1;\n                    state_next = STATE_PREAMBLE;\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n            STATE_PREAMBLE: begin\n                // send preamble\n                reset_crc = 1'b1;\n\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n\n                gmii_txd_next = 8'h55; // Preamble\n                gmii_tx_en_next = 1'b1;\n\n                if (frame_ptr_reg == 16'd6) begin\n                    input_axis_tready_next = 1'b1;\n                    input_tdata_next = input_axis_tdata;\n                    state_next = STATE_PREAMBLE;\n                end else if (frame_ptr_reg == 16'd7) begin\n                    // end of preamble; start payload\n                    frame_ptr_next = 16'd0;\n                    if (input_axis_tready_reg) begin\n                        input_axis_tready_next = 1'b1;\n                        input_tdata_next = input_axis_tdata;\n                    end\n                    gmii_txd_next = 8'hD5; // SFD\n                    state_next = STATE_PAYLOAD;\n                end else begin\n                    state_next = STATE_PREAMBLE;\n                end\n            end\n            STATE_PAYLOAD: begin\n                // send payload\n\n                update_crc = 1'b1;\n                input_axis_tready_next = 1'b1;\n\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n\n                gmii_txd_next = input_tdata_reg;\n                gmii_tx_en_next = 1'b1;\n\n                input_tdata_next = input_axis_tdata;\n\n                if (input_axis_tvalid) begin\n                    if (input_axis_tlast) begin\n                        input_axis_tready_next = ~input_axis_tready_reg;\n                        if (input_axis_tuser) begin\n                            gmii_tx_er_next = 1'b1;\n                            frame_ptr_next = 1'b0;\n                            state_next = STATE_IFG;\n                        end else begin\n                            state_next = STATE_LAST;\n                        end\n                    end else begin\n                        state_next = STATE_PAYLOAD;\n                    end\n                end else begin\n                    // tvalid deassert, fail frame\n                    gmii_tx_er_next = 1'b1;\n                    frame_ptr_next = 16'd0;\n                    state_next = STATE_WAIT_END;\n                end\n            end\n            STATE_LAST: begin\n                // last payload word\n\n                update_crc = 1'b1;\n\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n\n                gmii_txd_next = input_tdata_reg;\n                gmii_tx_en_next = 1'b1;\n\n                if (ENABLE_PADDING && frame_ptr_reg < MIN_FRAME_LENGTH-5) begin\n                    input_tdata_next = 8'd0;\n                    state_next = STATE_PAD;\n                end else begin\n                    frame_ptr_next = 16'd0;\n                    state_next = STATE_FCS;\n                end\n            end\n            STATE_PAD: begin\n                // send padding\n\n                update_crc = 1'b1;\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n\n                gmii_txd_next = 8'd0;\n                gmii_tx_en_next = 1'b1;\n\n                input_tdata_next = 8'd0;\n\n                if (frame_ptr_reg < MIN_FRAME_LENGTH-5) begin\n                    state_next = STATE_PAD;\n                end else begin\n                    frame_ptr_next = 16'd0;\n                    state_next = STATE_FCS;\n                end\n            end\n            STATE_FCS: begin\n                // send FCS\n\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n\n                case (frame_ptr_reg)\n                    2'd0: gmii_txd_next = ~crc_state[7:0];\n                    2'd1: gmii_txd_next = ~crc_state[15:8];\n                    2'd2: gmii_txd_next = ~crc_state[23:16];\n                    2'd3: gmii_txd_next = ~crc_state[31:24];\n                    default:;\n                endcase\n                gmii_tx_en_next = 1'b1;\n\n                if (frame_ptr_reg < 3) begin\n                    state_next = STATE_FCS;\n                end else begin\n                    frame_ptr_next = 16'd0;\n                    fcs_next = crc_state;\n                    state_next = STATE_IFG;\n                end\n            end\n            STATE_WAIT_END: begin\n                // wait for end of frame\n\n                reset_crc = 1'b1;\n\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n                input_axis_tready_next = 1'b1;\n\n                if (input_axis_tvalid) begin\n                    if (input_axis_tlast) begin\n                        input_axis_tready_next = 1'b0;\n                        ifg_next = 8'b0;\n                        state_next = STATE_IFG;\n                    end else begin\n                        state_next = STATE_WAIT_END;\n                    end\n                end else begin\n                    state_next = STATE_WAIT_END;\n                end\n            end\n            STATE_IFG: begin\n                // send IFG\n\n                reset_crc = 1'b1;\n\n                mii_odd_next = 1'b1;\n                frame_ptr_next = frame_ptr_reg + 16'd1;\n\n                if (ifg_reg < ifg_delay-1) begin\n                    ifg_next = ifg_reg + 1;\n                    state_next = STATE_IFG;\n                end else begin\n                    state_next = STATE_IDLE;\n                end\n            end\n        endcase\n\n        if (mii_select) begin\n            mii_msn_next = gmii_txd_next[7:4];\n            gmii_txd_next[7:4] = 4'd0;\n        end\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        state_reg <= STATE_IDLE;\n\n        frame_ptr_reg <= 16'd0;\n\n        input_axis_tready_reg <= 1'b0;\n\n        gmii_tx_en_reg <= 1'b0;\n        gmii_tx_er_reg <= 1'b0;\n\n        crc_state <= 32'hFFFFFFFF;\n        fcs_reg <= 32'hFFFFFFFF;\n    end else begin\n        state_reg <= state_next;\n\n        frame_ptr_reg <= frame_ptr_next;\n\n        input_axis_tready_reg <= input_axis_tready_next;\n\n        gmii_tx_en_reg <= gmii_tx_en_next;\n        gmii_tx_er_reg <= gmii_tx_er_next;\n\n        fcs_reg <= fcs_next;\n        ifg_reg <= ifg_next;\n        // datapath\n        if (reset_crc) begin\n            crc_state <= 32'hFFFFFFFF;\n        end else if (update_crc) begin\n            crc_state <= crc_next;\n        end\n    end\n\n    mii_odd_reg <= mii_odd_next;\n    mii_msn_reg <= mii_msn_next;\n\n    input_tdata_reg <= input_tdata_next;\n\n    gmii_txd_reg <= gmii_txd_next;\nend\n\nendmodule\n"}
{"text": "// See LICENSE for license details.\n\n`include \"consts.vh\"\n`include \"config.vh\"\n\n// Allow ISA regression test to use proper FPGA configuration\n`ifdef ADD_HOST\n`ifndef FPGA\n`undef ADD_BRAM\n`undef ADD_UART\n`undef ADD_FLASH\n`undef ADD_SPI\n`undef ADD_ETH\n`endif\n`endif\n\nmodule chip_top\n  (\n`ifdef ADD_PHY_DDR\n `ifdef KC705\n   // DDR3 RAM\n   inout wire [63:0]  ddr_dq,\n   inout wire [7:0]   ddr_dqs_n,\n   inout wire [7:0]   ddr_dqs_p,\n   output [13:0] ddr_addr,\n   output [2:0]  ddr_ba,\n   output        ddr_ras_n,\n   output        ddr_cas_n,\n   output        ddr_we_n,\n   output        ddr_reset_n,\n   output        ddr_ck_n,\n   output        ddr_ck_p,\n   output        ddr_cke,\n   output        ddr_cs_n,\n   output [7:0]  ddr_dm,\n   output        ddr_odt,\n `elsif NEXYS4_VIDEO\n   // DDR3 RAM\n   inout wire [15:0]  ddr_dq,\n   inout wire [1:0]   ddr_dqs_n,\n   inout wire [1:0]   ddr_dqs_p,\n   output [14:0] ddr_addr,\n   output [2:0]  ddr_ba,\n   output        ddr_ras_n,\n   output        ddr_cas_n,\n   output        ddr_we_n,\n   output        ddr_reset_n,\n   output        ddr_ck_n,\n   output        ddr_ck_p,\n   output        ddr_cke,\n   output [1:0]  ddr_dm,\n   output        ddr_odt,\n `elsif NEXYS4\n   // DDR2 RAM\n   inout wire [15:0]  ddr_dq,\n   inout wire [1:0]   ddr_dqs_n,\n   inout wire [1:0]   ddr_dqs_p,\n   output [12:0] ddr_addr,\n   output [2:0]  ddr_ba,\n   output        ddr_ras_n,\n   output        ddr_cas_n,\n   output        ddr_we_n,\n   output        ddr_ck_n,\n   output        ddr_ck_p,\n   output        ddr_cke,\n   output        ddr_cs_n,\n   output [1:0]  ddr_dm,\n   output        ddr_odt,\n  `elsif ZED\n   // RAM ACCESS THROUGH PS7's HP0 -> MEMCNT\n   output [31:0] mem_nasti_dram_araddr,\n   output  [1:0] mem_nasti_dram_arburst,\n   output  [3:0] mem_nasti_dram_arcache,\n   output  [5:0] mem_nasti_dram_arid,\n   output  [7:0] mem_nasti_dram_arlen,\n   output        mem_nasti_dram_arlock,\n   output  [2:0] mem_nasti_dram_arprot,\n   output  [3:0] mem_nasti_dram_arqos,\n   input wire         mem_nasti_dram_arready,\n   output  [2:0] mem_nasti_dram_arsize,\n   output        mem_nasti_dram_arvalid,\n   output  [3:0] mem_nasti_dram_arregion,\n   output [31:0] mem_nasti_dram_awaddr,\n   output  [1:0] mem_nasti_dram_awburst,\n   output  [3:0] mem_nasti_dram_awcache,\n   output  [5:0] mem_nasti_dram_awid,\n   output  [7:0] mem_nasti_dram_awlen,\n   output        mem_nasti_dram_awlock,\n   output  [2:0] mem_nasti_dram_awprot,\n   output  [3:0] mem_nasti_dram_awqos,\n   input wire         mem_nasti_dram_awready,\n   output  [2:0] mem_nasti_dram_awsize,\n   output  [2:0] mem_nasti_dram_awsize,\n   output        mem_nasti_dram_awvalid,\n   output  [3:0] mem_nasti_dram_awregion,\n   input wire   [5:0] mem_nasti_dram_bid,\n   output        mem_nasti_dram_bready,\n   input wire   [1:0] mem_nasti_dram_bresp,\n   input wire         mem_nasti_dram_bvalid,\n   input wire  [63:0] mem_nasti_dram_rdata,\n   input wire   [5:0] mem_nasti_dram_rid,\n   input wire         mem_nasti_dram_rlast,\n   output        mem_nasti_dram_rready,\n   input wire   [1:0] mem_nasti_dram_rresp,\n   input wire         mem_nasti_dram_rvalid,\n   output [63:0] mem_nasti_dram_wdata,\n   output        mem_nasti_dram_wlast,\n   input wire         mem_nasti_dram_wready,\n   output  [7:0] mem_nasti_dram_wstrb,\n   output        mem_nasti_dram_wvalid,\n `endif\n`endif //  `ifdef ADD_DDR_IO\n\n`ifdef ADD_FLASH\n   inout wire         flash_ss,\n   inout wire [3:0]   flash_io,\n`endif\n\n`ifdef ADD_SPI\n   inout wire         spi_cs,\n   inout wire         spi_sclk,\n   inout wire         spi_mosi,\n   inout wire         spi_miso,\n   output        sd_reset,\n`endif\n\n`ifdef ADD_HID\n   // Simple UART interface\n   input wire         rxd,\n   output wire       txd,\n   output wire       rts,\n   input wire         cts,\n\n   // 4-bit full SD interface\n   inout wire         sd_sclk,\n   input wire         sd_detect,\n   inout wire [3:0]   sd_dat,\n   inout wire         sd_cmd,\n   output wire        sd_reset,\n\n   // LED and DIP switch\n   output wire [21:0] o_led,\n   input wire  [15:0] i_dip,\n\n   // push button array\n   input wire         GPIO_SW_C,\n   input wire         GPIO_SW_W,\n   input wire         GPIO_SW_E,\n   input wire         GPIO_SW_N,\n   input wire         GPIO_SW_S,\n\n   //keyboard\n   inout wire         PS2_CLK,\n   inout wire         PS2_DATA,\n\n  // display\n   output wire       VGA_HS_O,\n   output wire       VGA_VS_O,\n   output wire [3:0]  VGA_RED_O,\n   output wire [3:0]  VGA_BLUE_O,\n   output wire [3:0]  VGA_GREEN_O,\n\n //! Ethernet MAC PHY interface signals\n input wire [1:0]   i_erxd, // RMII receive data\n input wire         i_erx_dv, // PHY data valid\n input wire         i_erx_er, // PHY coding error\n input wire         i_emdint, // PHY interrupt in active low\n output reg         o_erefclk, // RMII clock out\n output reg [1:0]   o_etxd, // RMII transmit data\n output reg         o_etx_en, // RMII transmit enable\n output wire        o_emdc, // MDIO clock\n inout wire         io_emdio, // MDIO inout\n output wire        o_erstn, // PHY reset active low\n`endif //  `ifdef ADD_HID\n   // clock and reset\n   input wire         clk_p,\n   input wire         clk_n,\n   input wire         rst_top\n   );\n\n   genvar        i;\n\n   // internal clock and reset signals\n   logic  clk, rst, rstn;\n   assign rst = !rstn;\n\n   // Debug controlled reset of the Rocket system\n   logic  sys_rst;\n   // Interrupts\n   logic spi_irq, sd_irq, eth_irq, uart_irq;\n   // Miscellaneous\n   logic TDO_driven;\n   /////////////////////////////////////////////////////////////\n   // NASTI/Lite on-chip interconnects\n\n   // Rocket memory nasti bus\n   nasti_channel\n     #(\n       .ID_WIDTH    ( `MEM_ID_WIDTH   ),\n       .ADDR_WIDTH  ( `MEM_ADDR_WIDTH ),\n       .DATA_WIDTH  ( `MEM_DATA_WIDTH ))\n   mem_nasti();\nwire io_emdio_i, phy_emdio_o, phy_emdio_t, clk_rmii, clk_rmii_quad, clk_locked, clk_locked_wiz;\nreg phy_emdio_i, io_emdio_o, io_emdio_t;\nlogic mig_sys_clk, clk_pixel;\n\n   // the NASTI bus for off-FPGA DRAM, converted to High frequency\n   nasti_channel   \n     #(\n       .ID_WIDTH    ( `MEM_ID_WIDTH   ),\n       .ADDR_WIDTH  ( `MEM_ADDR_WIDTH ),\n       .DATA_WIDTH  ( `MEM_DATA_WIDTH ))\n   mem_mig_nasti();\n\n`ifdef ADD_PHY_DDR\n\n `ifdef ZED\n   // Clock is generated by PS7, and reset as well.\n   // So there is no need to clock generator,\n   // just use the inputs to the module\n   assign clk = clk_p;\n   assign rstn = !rst_top;\n\n   assign mem_nasti_dram_araddr       = mem_nasti.ar_addr      ;\n   assign mem_nasti_dram_arburst      = mem_nasti.ar_burst     ;\n   assign mem_nasti_dram_arcache      = mem_nasti.ar_cache     ;\n   assign mem_nasti_dram_arid         = mem_nasti.ar_id        ;\n   assign mem_nasti_dram_arlen        = mem_nasti.ar_len       ;\n   assign mem_nasti_dram_arlock       = mem_nasti.ar_lock      ;\n   assign mem_nasti_dram_arprot       = mem_nasti.ar_prot      ;\n   assign mem_nasti_dram_arqos        = mem_nasti.ar_qos       ;\n   assign mem_nasti_dram_arready      = mem_nasti.ar_ready     ;\n   assign mem_nasti_dram_arsize       = mem_nasti.ar_size      ;\n   assign mem_nasti_dram_arvalid      = mem_nasti.ar_valid     ;\n   assign mem_nasti_dram_arregion     = mem_nasti.ar_region    ;\n   assign mem_nasti_dram_awaddr       = mem_nasti.aw_addr      ;\n   assign mem_nasti_dram_awburst      = mem_nasti.aw_burst     ;\n   assign mem_nasti_dram_awcache      = mem_nasti.aw_cache     ;\n   assign mem_nasti_dram_awid         = mem_nasti.aw_id        ;\n   assign mem_nasti_dram_awlen        = mem_nasti.aw_len       ;\n   assign mem_nasti_dram_awlock       = mem_nasti.aw_lock      ;\n   assign mem_nasti_dram_awprot       = mem_nasti.aw_prot      ;\n   assign mem_nasti_dram_awqos        = mem_nasti.aw_qos       ;\n   assign mem_nasti_dram_awready      = mem_nasti.aw_ready     ;\n   assign mem_nasti_dram_awsize       = mem_nasti.aw_size      ;\n   assign mem_nasti_dram_awvalid      = mem_nasti.aw_valid     ;\n   assign mem_nasti_dram_awregion     = mem_nasti.aw_region    ;\n   assign mem_nasti_dram_bid          = mem_nasti.b_id         ;\n   assign mem_nasti_dram_bready       = mem_nasti.b_ready      ;\n   assign mem_nasti_dram_bresp        = mem_nasti.b_resp       ;\n   assign mem_nasti_dram_bvalid       = mem_nasti.b_valid      ;\n   assign mem_nasti_dram_rdata        = mem_nasti.r_data       ;\n   assign mem_nasti_dram_rid          = mem_nasti.r_id         ;\n   assign mem_nasti_dram_rlast        = mem_nasti.r_last       ;\n   assign mem_nasti_dram_rready       = mem_nasti.r_ready      ;\n   assign mem_nasti_dram_rresp        = mem_nasti.r_resp       ;\n   assign mem_nasti_dram_rvalid       = mem_nasti.r_valid      ;\n   assign mem_nasti_dram_wdata        = mem_nasti.w_data       ;\n   assign mem_nasti_dram_wlast        = mem_nasti.w_last       ;\n   assign mem_nasti_dram_wready       = mem_nasti.w_ready      ;\n   assign mem_nasti_dram_wstrb        = mem_nasti.w_strb       ;\n   assign mem_nasti_dram_wvalid       = mem_nasti.w_valid      ;\n\n `else // !`ifdef ZED\n\n   // MIG clock\n   logic mig_ui_clk, mig_ui_rst, mig_ui_rstn;\n   assign mig_ui_rstn = !mig_ui_rst;\n\n`define ROCKET_50MHZ\n`ifdef ROCKET_50MHZ\n`define MEM_NASTI mem_mig_nasti\n`define UBAUD_DEFAULT 108\n`else\n`define MEM_NASTI mem_nasti\n`define UBAUD_DEFAULT 54\n\n   // clock converter\n   axi_clock_converter_0 clk_conv\n     (\n      .s_axi_aclk           ( clk                      ),\n      .s_axi_aresetn        ( rstn                     ),\n      .s_axi_awid           ( mem_nasti.aw_id          ),\n      .s_axi_awaddr         ( mem_nasti.aw_addr        ),\n      .s_axi_awlen          ( mem_nasti.aw_len         ),\n      .s_axi_awsize         ( mem_nasti.aw_size        ),\n      .s_axi_awburst        ( mem_nasti.aw_burst       ),\n      .s_axi_awlock         ( 1'b0                     ), // not supported in AXI4\n      .s_axi_awcache        ( mem_nasti.aw_cache       ),\n      .s_axi_awprot         ( mem_nasti.aw_prot        ),\n      .s_axi_awqos          ( mem_nasti.aw_qos         ),\n      .s_axi_awregion       ( 4'b0                     ), // not supported in AXI4\n      .s_axi_awvalid        ( mem_nasti.aw_valid       ),\n      .s_axi_awready        ( mem_nasti.aw_ready       ),\n      .s_axi_wdata          ( mem_nasti.w_data         ),\n      .s_axi_wstrb          ( mem_nasti.w_strb         ),\n      .s_axi_wlast          ( mem_nasti.w_last         ),\n      .s_axi_wvalid         ( mem_nasti.w_valid        ),\n      .s_axi_wready         ( mem_nasti.w_ready        ),\n      .s_axi_bid            ( mem_nasti.b_id           ),\n      .s_axi_bresp          ( mem_nasti.b_resp         ),\n      .s_axi_bvalid         ( mem_nasti.b_valid        ),\n      .s_axi_bready         ( mem_nasti.b_ready        ),\n      .s_axi_arid           ( mem_nasti.ar_id          ),\n      .s_axi_araddr         ( mem_nasti.ar_addr        ),\n      .s_axi_arlen          ( mem_nasti.ar_len         ),\n      .s_axi_arsize         ( mem_nasti.ar_size        ),\n      .s_axi_arburst        ( mem_nasti.ar_burst       ),\n      .s_axi_arlock         ( 1'b0                     ), // not supported in AXI4\n      .s_axi_arcache        ( mem_nasti.ar_cache       ),\n      .s_axi_arprot         ( mem_nasti.ar_prot        ),\n      .s_axi_arqos          ( mem_nasti.ar_qos         ),\n      .s_axi_arregion       ( 4'b0                     ), // not supported in AXI4\n      .s_axi_arvalid        ( mem_nasti.ar_valid       ),\n      .s_axi_arready        ( mem_nasti.ar_ready       ),\n      .s_axi_rid            ( mem_nasti.r_id           ),\n      .s_axi_rdata          ( mem_nasti.r_data         ),\n      .s_axi_rresp          ( mem_nasti.r_resp         ),\n      .s_axi_rlast          ( mem_nasti.r_last         ),\n      .s_axi_rvalid         ( mem_nasti.r_valid        ),\n      .s_axi_rready         ( mem_nasti.r_ready        ),\n      .m_axi_aclk           ( mig_ui_clk               ),\n      .m_axi_aresetn        ( mig_ui_rstn              ),\n      .m_axi_awid           ( mem_mig_nasti.aw_id      ),\n      .m_axi_awaddr         ( mem_mig_nasti.aw_addr    ),\n      .m_axi_awlen          ( mem_mig_nasti.aw_len     ),\n      .m_axi_awsize         ( mem_mig_nasti.aw_size    ),\n      .m_axi_awburst        ( mem_mig_nasti.aw_burst   ),\n      .m_axi_awlock         (                          ), // not supported in AXI4\n      .m_axi_awcache        ( mem_mig_nasti.aw_cache   ),\n      .m_axi_awprot         ( mem_mig_nasti.aw_prot    ),\n      .m_axi_awqos          ( mem_mig_nasti.aw_qos     ),\n      .m_axi_awregion       ( mem_mig_nasti.aw_region  ),\n      .m_axi_awvalid        ( mem_mig_nasti.aw_valid   ),\n      .m_axi_awready        ( mem_mig_nasti.aw_ready   ),\n      .m_axi_wdata          ( mem_mig_nasti.w_data     ),\n      .m_axi_wstrb          ( mem_mig_nasti.w_strb     ),\n      .m_axi_wlast          ( mem_mig_nasti.w_last     ),\n      .m_axi_wvalid         ( mem_mig_nasti.w_valid    ),\n      .m_axi_wready         ( mem_mig_nasti.w_ready    ),\n      .m_axi_bid            ( mem_mig_nasti.b_id       ),\n      .m_axi_bresp          ( mem_mig_nasti.b_resp     ),\n      .m_axi_bvalid         ( mem_mig_nasti.b_valid    ),\n      .m_axi_bready         ( mem_mig_nasti.b_ready    ),\n      .m_axi_arid           ( mem_mig_nasti.ar_id      ),\n      .m_axi_araddr         ( mem_mig_nasti.ar_addr    ),\n      .m_axi_arlen          ( mem_mig_nasti.ar_len     ),\n      .m_axi_arsize         ( mem_mig_nasti.ar_size    ),\n      .m_axi_arburst        ( mem_mig_nasti.ar_burst   ),\n      .m_axi_arlock         (                          ), // not supported in AXI4\n      .m_axi_arcache        ( mem_mig_nasti.ar_cache   ),\n      .m_axi_arprot         ( mem_mig_nasti.ar_prot    ),\n      .m_axi_arqos          ( mem_mig_nasti.ar_qos     ),\n      .m_axi_arregion       ( mem_mig_nasti.ar_region  ),\n      .m_axi_arvalid        ( mem_mig_nasti.ar_valid   ),\n      .m_axi_arready        ( mem_mig_nasti.ar_ready   ),\n      .m_axi_rid            ( mem_mig_nasti.r_id       ),\n      .m_axi_rdata          ( mem_mig_nasti.r_data     ),\n      .m_axi_rresp          ( mem_mig_nasti.r_resp     ),\n      .m_axi_rlast          ( mem_mig_nasti.r_last     ),\n      .m_axi_rvalid         ( mem_mig_nasti.r_valid    ),\n      .m_axi_rready         ( mem_mig_nasti.r_ready    )\n      );\n\n`endif\n\n `ifdef NEXYS4_COMMON\n   //clock generator\n   logic clk_io_uart; // UART IO clock for debug\n\n   clk_wiz_0 clk_gen\n     (\n      .clk_in1       ( clk_p         ), // 100 MHz onboard\n      .clk_out1      ( mig_sys_clk   ), // 200 MHz\n      .clk_io_uart   ( clk_io_uart   ), // 60 MHz\n      .clk_rmii      ( clk_rmii      ), // 50 MHz rmii\n      .clk_rmii_quad ( clk_rmii_quad ), // 50 MHz rmii quad\n      .clk_pixel     ( clk_pixel     ), // 120 MHz\n      .resetn        ( rst_top       ),\n      .locked        ( clk_locked_wiz )\n      );\n   assign clk_locked = clk_locked_wiz & rst_top;\n   assign sys_rst = ~rstn;\n      \n `endif //  `ifdef NEXYS4_COMMON\n\n   // DRAM controller\n   mig_7series_0 dram_ctl\n     (\n `ifdef KC705\n      .sys_clk_p            ( clk_p                  ),\n      .sys_clk_n            ( clk_n                  ),\n      .sys_rst              ( rst_top                ),\n      .ui_addn_clk_0        ( clk                    ),\n      .ddr3_dq              ( ddr_dq                 ),\n      .ddr3_dqs_n           ( ddr_dqs_n              ),\n      .ddr3_dqs_p           ( ddr_dqs_p              ),\n      .ddr3_addr            ( ddr_addr               ),\n      .ddr3_ba              ( ddr_ba                 ),\n      .ddr3_ras_n           ( ddr_ras_n              ),\n      .ddr3_cas_n           ( ddr_cas_n              ),\n      .ddr3_we_n            ( ddr_we_n               ),\n      .ddr3_reset_n         ( ddr_reset_n            ),\n      .ddr3_ck_p            ( ddr_ck_p               ),\n      .ddr3_ck_n            ( ddr_ck_n               ),\n      .ddr3_cke             ( ddr_cke                ),\n      .ddr3_cs_n            ( ddr_cs_n               ),\n      .ddr3_dm              ( ddr_dm                 ),\n      .ddr3_odt             ( ddr_odt                ),\n `elsif NEXYS4_VIDEO\n      .sys_clk_i            ( mig_sys_clk            ),\n      .sys_rst              ( clk_locked             ),\n      .ui_addn_clk_0        ( clk                    ),\n      .ddr3_addr            ( ddr_addr               ),\n      .ddr3_ba              ( ddr_ba                 ),\n      .ddr3_cas_n           ( ddr_cas_n              ),\n      .ddr3_ck_n            ( ddr_ck_n               ),\n      .ddr3_ck_p            ( ddr_ck_p               ),\n      .ddr3_cke             ( ddr_cke                ),\n      .ddr3_ras_n           ( ddr_ras_n              ),\n      .ddr3_reset_n         ( ddr_reset_n            ),\n      .ddr3_we_n            ( ddr_we_n               ),\n      .ddr3_dq              ( ddr_dq                 ),\n      .ddr3_dqs_n           ( ddr_dqs_n              ),\n      .ddr3_dqs_p           ( ddr_dqs_p              ),\n      .ddr3_dm              ( ddr_dm                 ),\n      .ddr3_odt             ( ddr_odt                ),\n `elsif NEXYS4\n      .sys_clk_i            ( mig_sys_clk            ),\n      .sys_rst              ( clk_locked             ),\n      .ui_addn_clk_0        ( clk                    ),\n      .device_temp_i        ( 0                      ),\n      .ddr2_dq              ( ddr_dq                 ),\n      .ddr2_dqs_n           ( ddr_dqs_n              ),\n      .ddr2_dqs_p           ( ddr_dqs_p              ),\n      .ddr2_addr            ( ddr_addr               ),\n      .ddr2_ba              ( ddr_ba                 ),\n      .ddr2_ras_n           ( ddr_ras_n              ),\n      .ddr2_cas_n           ( ddr_cas_n              ),\n      .ddr2_we_n            ( ddr_we_n               ),\n      .ddr2_ck_p            ( ddr_ck_p               ),\n      .ddr2_ck_n            ( ddr_ck_n               ),\n      .ddr2_cke             ( ddr_cke                ),\n      .ddr2_cs_n            ( ddr_cs_n               ),\n      .ddr2_dm              ( ddr_dm                 ),\n      .ddr2_odt             ( ddr_odt                ),\n `endif // !`elsif NEXYS4\n      .ui_clk               ( mig_ui_clk             ),\n      .ui_clk_sync_rst      ( mig_ui_rst             ),\n      .mmcm_locked          ( rstn                   ),\n      .aresetn              ( rstn                   ), // AXI reset\n      .app_sr_req           ( 1'b0                   ),\n      .app_ref_req          ( 1'b0                   ),\n      .app_zq_req           ( 1'b0                   ),\n      .s_axi_awid           ( mem_mig_nasti.aw_id    ),\n      .s_axi_awaddr         ( mem_mig_nasti.aw_addr  ),\n      .s_axi_awlen          ( mem_mig_nasti.aw_len   ),\n      .s_axi_awsize         ( mem_mig_nasti.aw_size  ),\n      .s_axi_awburst        ( mem_mig_nasti.aw_burst ),\n      .s_axi_awlock         ( 1'b0                   ), // not supported in AXI4\n      .s_axi_awcache        ( mem_mig_nasti.aw_cache ),\n      .s_axi_awprot         ( mem_mig_nasti.aw_prot  ),\n      .s_axi_awqos          ( mem_mig_nasti.aw_qos   ),\n      .s_axi_awvalid        ( mem_mig_nasti.aw_valid ),\n      .s_axi_awready        ( mem_mig_nasti.aw_ready ),\n      .s_axi_wdata          ( mem_mig_nasti.w_data   ),\n      .s_axi_wstrb          ( mem_mig_nasti.w_strb   ),\n      .s_axi_wlast          ( mem_mig_nasti.w_last   ),\n      .s_axi_wvalid         ( mem_mig_nasti.w_valid  ),\n      .s_axi_wready         ( mem_mig_nasti.w_ready  ),\n      .s_axi_bid            ( mem_mig_nasti.b_id     ),\n      .s_axi_bresp          ( mem_mig_nasti.b_resp   ),\n      .s_axi_bvalid         ( mem_mig_nasti.b_valid  ),\n      .s_axi_bready         ( mem_mig_nasti.b_ready  ),\n      .s_axi_arid           ( mem_mig_nasti.ar_id    ),\n      .s_axi_araddr         ( mem_mig_nasti.ar_addr  ),\n      .s_axi_arlen          ( mem_mig_nasti.ar_len   ),\n      .s_axi_arsize         ( mem_mig_nasti.ar_size  ),\n      .s_axi_arburst        ( mem_mig_nasti.ar_burst ),\n      .s_axi_arlock         ( 1'b0                   ), // not supported in AXI4\n      .s_axi_arcache        ( mem_mig_nasti.ar_cache ),\n      .s_axi_arprot         ( mem_mig_nasti.ar_prot  ),\n"}
{"text": "      .s_axi_arqos          ( mem_mig_nasti.ar_qos   ),\n      .s_axi_arvalid        ( mem_mig_nasti.ar_valid ),\n      .s_axi_arready        ( mem_mig_nasti.ar_ready ),\n      .s_axi_rid            ( mem_mig_nasti.r_id     ),\n      .s_axi_rdata          ( mem_mig_nasti.r_data   ),\n      .s_axi_rresp          ( mem_mig_nasti.r_resp   ),\n      .s_axi_rlast          ( mem_mig_nasti.r_last   ),\n      .s_axi_rvalid         ( mem_mig_nasti.r_valid  ),\n      .s_axi_rready         ( mem_mig_nasti.r_ready  )\n      );\n\n  `endif // !`ifdef ZED\n`else // !`ifdef ADD_PHY_DDR\n`define MEM_NASTI mem_mig_nasti\n`define UBAUD_DEFAULT 108\n\n   assign clk = clk_p;\n   assign clk_rmii = clk_p;\n   assign clk_rmii_quad = clk_p;\n   assign rstn = !rst_top;\n   assign clk_locked = !rst_top;\n   assign clk_locked_wiz = !rst_top;\n   assign mig_sys_clk = clk_p;\n   assign clk_pixel = clk_p;   \n   assign sys_rst = rst_top;\n   \n   nasti_ram_sim\n     #(\n       .ID_WIDTH     ( `MEM_ID_WIDTH    ),\n       .ADDR_WIDTH   ( `MEM_ADDR_WIDTH  ),\n       .DATA_WIDTH   ( `MEM_DATA_WIDTH  ),\n       .USER_WIDTH   ( 1                )\n       )\n   ram_behav\n     (\n      .clk           ( clk         ),\n      .rstn          ( rstn        ),\n      .nasti         ( `MEM_NASTI   )\n      );\n`endif // !`ifdef ADD_PHY_DDR\n\n   /////////////////////////////////////////////////////////////\n   // IO space buses\n\n   nasti_channel\n     #(\n       .ID_WIDTH    ( `MMIO_MASTER_ID_WIDTH   ),\n       .ADDR_WIDTH  ( `MMIO_MASTER_ADDR_WIDTH ),\n       .DATA_WIDTH  ( `MMIO_MASTER_DATA_WIDTH ))\n   mmio_master_nasti();\n\n   nasti_channel\n     #(\n       .ID_WIDTH    ( `MMIO_SLAVE_ID_WIDTH   ),\n       .ADDR_WIDTH  ( `MMIO_SLAVE_ADDR_WIDTH ),\n       .DATA_WIDTH  ( `MMIO_SLAVE_DATA_WIDTH ))\n   io_slave_nasti();      // IO nasti interface to Rocket\n\n   // currently the slave port is not used\n   assign io_slave_nasti.aw_valid = 'b0;\n   assign io_slave_nasti.w_valid  = 'b0;\n   assign io_slave_nasti.b_ready  = 'b0;\n   assign io_slave_nasti.ar_valid = 'b0;\n   assign io_slave_nasti.r_ready  = 'b0;\n\n   /////////////////////////////////////////////////////////////\n   // On-chip Block RAM\n\n`ifdef ADD_BRAM\n\n   localparam BRAM_SIZE          = 16;        // 2^16 -> 64 KB\n   localparam BRAM_WIDTH         = 128;       // always 128-bit wide\n   localparam BRAM_LINE          = 2 ** BRAM_SIZE / (BRAM_WIDTH/8);\n   localparam BRAM_OFFSET_BITS   = $clog2(`LOWRISC_IO_DAT_WIDTH/8);\n   localparam BRAM_ADDR_LSB_BITS = $clog2(BRAM_WIDTH / `LOWRISC_IO_DAT_WIDTH);\n   localparam BRAM_ADDR_BLK_BITS = BRAM_SIZE - BRAM_ADDR_LSB_BITS - BRAM_OFFSET_BITS;\n\n   initial assert (BRAM_OFFSET_BITS < 7) else $fatal(1, \"Do not support BRAM AXI width > 64-bit!\");\n\n   // BRAM controller\n   logic ram_clk, ram_rst, ram_en;\n   logic [7:0] ram_we;\n   logic [15:0] ram_addr;\n   logic [63:0]   ram_wrdata, ram_rddata;\n\n   logic [30:0] bram_ar_addr, bram_aw_addr;\n\n   assign bram_ar_addr = mmio_master_nasti.ar_addr ;\n   assign bram_aw_addr = mmio_master_nasti.aw_addr ;\n   \n   reg   [BRAM_WIDTH-1:0]         ram [0 : BRAM_LINE-1];\n   logic [BRAM_ADDR_BLK_BITS-1:0] ram_block_addr, ram_block_addr_delay;\n   logic [BRAM_ADDR_LSB_BITS-1:0] ram_lsb_addr, ram_lsb_addr_delay;\n   logic [BRAM_WIDTH/8-1:0]       ram_we_full;\n   logic [BRAM_WIDTH-1:0]         ram_wrdata_full, ram_rddata_full;\n   int                            ram_rddata_shift, ram_we_shift;\n\n   assign ram_block_addr = ram_addr >> BRAM_ADDR_LSB_BITS + BRAM_OFFSET_BITS;\n   assign ram_lsb_addr = ram_addr >> BRAM_OFFSET_BITS;\n   assign ram_we_shift = ram_lsb_addr << BRAM_OFFSET_BITS; // avoid ISim error\n   assign ram_we_full = ram_we << ram_we_shift;\n   assign ram_wrdata_full = {(BRAM_WIDTH / `LOWRISC_IO_DAT_WIDTH){ram_wrdata}};\n\n   always @(posedge ram_clk)\n    begin\n     if(ram_en) begin\n        ram_block_addr_delay <= ram_block_addr;\n        ram_lsb_addr_delay <= ram_lsb_addr;\n        foreach (ram_we_full[i])\n          if(ram_we_full[i]) ram[ram_block_addr][i*8 +:8] <= ram_wrdata_full[i*8 +: 8];\n     end\n    end\n\n   assign ram_rddata_full = ram[ram_block_addr_delay];\n   assign ram_rddata_shift = ram_lsb_addr_delay << (BRAM_OFFSET_BITS + 3); // avoid ISim error\n   assign ram_rddata = ram_rddata_full >> ram_rddata_shift;\n\n   initial $readmemh(\"boot.mem\", ram);\n\n`endif //  `ifdef ADD_BRAM\n\n   /////////////////////////////////////////////////////////////\n   // XIP SPI Flash\n\n`ifdef ADD_FLASH\n\n   wire       flash_ss_i,  flash_ss_o,  flash_ss_t;\n   wire [3:0] flash_io_i,  flash_io_o,  flash_io_t;\n\n   axi_quad_spi_1 flash_i\n     (\n      .ext_spi_clk      ( clk                           ),\n      .s_axi_aclk       ( clk                           ),\n      .s_axi_aresetn    ( rstn                          ),\n      .s_axi4_aclk      ( clk                           ),\n      .s_axi4_aresetn   ( rstn                          ),\n      .s_axi_araddr     ( 7'b0                          ),\n      .s_axi_arready    (                               ),\n      .s_axi_arvalid    ( 1'b0                          ),\n      .s_axi_awaddr     ( 7'b0                          ),\n      .s_axi_awready    (                               ),\n      .s_axi_awvalid    ( 1'b0                          ),\n      .s_axi_bready     ( 1'b0                          ),\n      .s_axi_bresp      (                               ),\n      .s_axi_bvalid     (                               ),\n      .s_axi_rdata      (                               ),\n      .s_axi_rready     ( 1'b0                          ),\n      .s_axi_rresp      (                               ),\n      .s_axi_rvalid     (                               ),\n      .s_axi_wdata      ( 0                             ),\n      .s_axi_wready     (                               ),\n      .s_axi_wstrb      ( 4'b0                          ),\n      .s_axi_wvalid     ( 1'b0                          ),\n      .s_axi4_awid      ( local_flash_nasti.aw_id       ),\n      .s_axi4_awaddr    ( local_flash_nasti.aw_addr     ),\n      .s_axi4_awlen     ( local_flash_nasti.aw_len      ),\n      .s_axi4_awsize    ( local_flash_nasti.aw_size     ),\n      .s_axi4_awburst   ( local_flash_nasti.aw_burst    ),\n      .s_axi4_awlock    ( local_flash_nasti.aw_lock     ),\n      .s_axi4_awcache   ( local_flash_nasti.aw_cache    ),\n      .s_axi4_awprot    ( local_flash_nasti.aw_prot     ),\n      .s_axi4_awvalid   ( local_flash_nasti.aw_valid    ),\n      .s_axi4_awready   ( local_flash_nasti.aw_ready    ),\n      .s_axi4_wdata     ( local_flash_nasti.w_data      ),\n      .s_axi4_wstrb     ( local_flash_nasti.w_strb      ),\n      .s_axi4_wlast     ( local_flash_nasti.w_last      ),\n      .s_axi4_wvalid    ( local_flash_nasti.w_valid     ),\n      .s_axi4_wready    ( local_flash_nasti.w_ready     ),\n      .s_axi4_bid       ( local_flash_nasti.b_id        ),\n      .s_axi4_bresp     ( local_flash_nasti.b_resp      ),\n      .s_axi4_bvalid    ( local_flash_nasti.b_valid     ),\n      .s_axi4_bready    ( local_flash_nasti.b_ready     ),\n      .s_axi4_arid      ( local_flash_nasti.ar_id       ),\n      .s_axi4_araddr    ( local_flash_nasti.ar_addr     ),\n      .s_axi4_arlen     ( local_flash_nasti.ar_len      ),\n      .s_axi4_arsize    ( local_flash_nasti.ar_size     ),\n      .s_axi4_arburst   ( local_flash_nasti.ar_burst    ),\n      .s_axi4_arlock    ( local_flash_nasti.ar_lock     ),\n      .s_axi4_arcache   ( local_flash_nasti.ar_cache    ),\n      .s_axi4_arprot    ( local_flash_nasti.ar_prot     ),\n      .s_axi4_arvalid   ( local_flash_nasti.ar_valid    ),\n      .s_axi4_arready   ( local_flash_nasti.ar_ready    ),\n      .s_axi4_rid       ( local_flash_nasti.r_id        ),\n      .s_axi4_rdata     ( local_flash_nasti.r_data      ),\n      .s_axi4_rresp     ( local_flash_nasti.r_resp      ),\n      .s_axi4_rlast     ( local_flash_nasti.r_last      ),\n      .s_axi4_rvalid    ( local_flash_nasti.r_valid     ),\n      .s_axi4_rready    ( local_flash_nasti.r_ready     ),\n      .io0_i            ( flash_io_i[0]                 ),\n      .io0_o            ( flash_io_o[0]                 ),\n      .io0_t            ( flash_io_t[0]                 ),\n      .io1_i            ( flash_io_i[1]                 ),\n      .io1_o            ( flash_io_o[1]                 ),\n      .io1_t            ( flash_io_t[1]                 ),\n      .io2_i            ( flash_io_i[2]                 ),\n      .io2_o            ( flash_io_o[2]                 ),\n      .io2_t            ( flash_io_t[2]                 ),\n      .io3_i            ( flash_io_i[3]                 ),\n      .io3_o            ( flash_io_o[3]                 ),\n      .io3_t            ( flash_io_t[3]                 ),\n      .ss_i             ( flash_ss_i                    ),\n      .ss_o             ( flash_ss_o                    ),\n      .ss_t             ( flash_ss_t                    )\n      );\n\n   // tri-state gates\n   generate for(i=0; i<4; i++) begin\n      assign flash_io[i] = !flash_io_t[i] ? flash_io_o[i] : 1'bz;\n      assign flash_io_i[i] = flash_io[i];\n   end\n   endgenerate\n\n   assign flash_ss = !flash_ss_t ? flash_ss_o : 1'bz;\n   assign flash_ss_i = flash_ss;\n\n`endif //  `ifdef ADD_FLASH\n\n   assign spi_irq = 1'b0;\n\n   /////////////////////////////////////////////////////////////\n   // Human interface and miscellaneous devices\n\n`ifdef ADD_HID\n   \n   wire                        hid_rst, hid_clk, hid_en;\n   wire [7:0]                  hid_we;\n   wire [17:0]                 hid_addr;\n   wire [63:0]                 hid_wrdata,  hid_rddata;\n   logic [30:0]                hid_ar_addr, hid_aw_addr;\n   logic [1:0] eth_txd;\n   logic eth_rstn, eth_refclk, eth_txen;\n   assign o_erstn = eth_rstn & clk_locked_wiz;\n\n   axi_bram_ctrl_dummy BramCtl\n     (\n      .s_axi_aclk      ( clk                        ),\n      .s_axi_aresetn   ( rstn                       ),\n      .s_axi_arid      ( mmio_master_nasti.ar_id    ),\n      .s_axi_araddr    ( bram_ar_addr[17:0]         ),\n      .s_axi_arlen     ( mmio_master_nasti.ar_len   ),\n      .s_axi_arsize    ( mmio_master_nasti.ar_size  ),\n      .s_axi_arburst   ( mmio_master_nasti.ar_burst ),\n      .s_axi_arlock    ( mmio_master_nasti.ar_lock  ),\n      .s_axi_arcache   ( mmio_master_nasti.ar_cache ),\n      .s_axi_arprot    ( mmio_master_nasti.ar_prot  ),\n      .s_axi_arready   ( mmio_master_nasti.ar_ready ),\n      .s_axi_arvalid   ( mmio_master_nasti.ar_valid ),\n      .s_axi_rid       ( mmio_master_nasti.r_id     ),\n      .s_axi_rdata     ( mmio_master_nasti.r_data   ),\n      .s_axi_rresp     ( mmio_master_nasti.r_resp   ),\n      .s_axi_rlast     ( mmio_master_nasti.r_last   ),\n      .s_axi_rready    ( mmio_master_nasti.r_ready  ),\n      .s_axi_rvalid    ( mmio_master_nasti.r_valid  ),\n      .s_axi_awid      ( mmio_master_nasti.aw_id    ),\n      .s_axi_awaddr    ( bram_aw_addr[17:0]         ),\n      .s_axi_awlen     ( mmio_master_nasti.aw_len   ),\n      .s_axi_awsize    ( mmio_master_nasti.aw_size  ),\n      .s_axi_awburst   ( mmio_master_nasti.aw_burst ),\n      .s_axi_awlock    ( mmio_master_nasti.aw_lock  ),\n      .s_axi_awcache   ( mmio_master_nasti.aw_cache ),\n      .s_axi_awprot    ( mmio_master_nasti.aw_prot  ),\n      .s_axi_awready   ( mmio_master_nasti.aw_ready ),\n      .s_axi_awvalid   ( mmio_master_nasti.aw_valid ),\n      .s_axi_wdata     ( mmio_master_nasti.w_data   ),\n      .s_axi_wstrb     ( mmio_master_nasti.w_strb   ),\n      .s_axi_wlast     ( mmio_master_nasti.w_last   ),\n      .s_axi_wready    ( mmio_master_nasti.w_ready  ),\n      .s_axi_wvalid    ( mmio_master_nasti.w_valid  ),\n      .s_axi_bid       ( mmio_master_nasti.b_id     ),\n      .s_axi_bresp     ( mmio_master_nasti.b_resp   ),\n      .s_axi_bready    ( mmio_master_nasti.b_ready  ),\n      .s_axi_bvalid    ( mmio_master_nasti.b_valid  ),\n      .bram_rst_a      ( hid_rst                   ),\n      .bram_clk_a      ( hid_clk                   ),\n      .bram_en_a       ( hid_en                    ),\n      .bram_we_a       ( hid_we                    ),\n      .bram_addr_a     ( hid_addr                  ),\n      .bram_wrdata_a   ( hid_wrdata                ),\n      .bram_rddata_a   ( hid_rddata                )\n      );\n  \n   always @(posedge clk_rmii)\n     begin\n        phy_emdio_i <= io_emdio_i;\n        io_emdio_o <= phy_emdio_o;\n        io_emdio_t <= phy_emdio_t;\n     end\n\n   IOBUF #(\n      .DRIVE(12), // Specify the output drive strength\n      .IBUF_LOW_PWR(\"TRUE\"),  // Low Power - \"TRUE\", High Performance = \"FALSE\" \n      .IOSTANDARD(\"DEFAULT\"), // Specify the I/O standard\n      .SLEW(\"SLOW\") // Specify the output slew rate\n   ) IOBUF_inst (\n      .O(io_emdio_i),     // Buffer output\n      .IO(io_emdio),   // Buffer inout port (connect directly to top-level port)\n      .I(io_emdio_o),     // Buffer input\n      .T(io_emdio_t)      // 3-state enable input, high=input, low=output\n   );\n\n  ODDR #(\n    .DDR_CLK_EDGE(\"OPPOSITE_EDGE\"),\n    .INIT(1'b0),\n    .IS_C_INVERTED(1'b0),\n    .IS_D1_INVERTED(1'b0),\n    .IS_D2_INVERTED(1'b0),\n    .SRTYPE(\"SYNC\")) \n    refclk_inst\n       (.C(eth_refclk),\n        .CE(1'b1),\n        .D1(1'b1),\n        .D2(1'b0),\n        .Q(o_erefclk),\n        .R(1'b0),\n        .S( ));\n    \n    always @(posedge clk_rmii_quad)\n        begin\n        o_etxd = eth_txd;\n        o_etx_en = eth_txen;\n        end\n\n   periph_soc #(.UBAUD_DEFAULT(`UBAUD_DEFAULT)) psoc\n     (\n      .msoc_clk   ( clk             ),\n      .sd_sclk    ( sd_sclk         ),\n      .sd_detect  ( sd_detect       ),\n      .sd_dat     ( sd_dat          ),\n      .sd_cmd     ( sd_cmd          ),\n      .sd_irq     ( sd_irq          ),\n      .from_dip   ( i_dip           ),\n      .to_led     ( o_led           ),\n      .rstn       ( clk_locked      ),\n      .clk_200MHz ( mig_sys_clk     ),\n      .pxl_clk    ( clk_pixel       ),\n      .uart_rx    ( rxd             ),\n      .uart_tx    ( txd             ),\n      .clk_rmii   ( clk_rmii        ),\n      .locked     ( clk_locked      ),\n    // SMSC ethernet PHY connections\n      .eth_rstn   ( eth_rstn        ),\n      .eth_crsdv  ( i_erx_dv        ),\n      .eth_refclk ( eth_refclk      ),\n      .eth_txd    ( eth_txd         ),\n      .eth_txen   ( eth_txen        ),\n      .eth_rxd    ( i_erxd          ),\n      .eth_rxerr  ( i_erx_er        ),\n      .eth_mdc    ( o_emdc          ),\n      .phy_mdio_i ( phy_emdio_i     ),\n      .phy_mdio_o ( phy_emdio_o     ),\n      .phy_mdio_t ( phy_emdio_t     ),\n      .eth_irq    ( eth_irq         ),\n      .*\n      );\n\n   assign rts = cts;\n   \n`else // !`ifdef ADD_HID\n\n   assign hid_irq = 1'b0;\n   assign sd_irq = 1'b0;\n   assign eth_irq = 1'b0;\n\n`endif // !`ifdef ADD_HID\n\n   /////////////////////////////////////////////////////////////\n   // Host for ISA regression\n\n   nasti_channel\n     #(\n       .ADDR_WIDTH  ( `MMIO_MASTER_ADDR_WIDTH   ),\n       .DATA_WIDTH  ( `LOWRISC_IO_DAT_WIDTH     ))\n   io_host_lite();\n\n`ifdef ADD_HOST\n   host_behav host\n     (\n      .clk          ( clk          ),\n      .rstn         ( rstn         ),\n      .nasti        ( io_host_lite )\n      );\n`endif\n\n   /////////////////////////////////////////////////////////////\n   // the Rocket chip\n\n   wire CAPTURE, DRCK, RESET, RUNTEST, SEL, SHIFT, TCK, TDI, TMS, UPDATE, TDO, TCK_unbuf;\n\n   /* This block is just used to feed the JTAG clock into the parts of Rocket that need it */\n      \n   BSCANE2 #(\n      .JTAG_CHAIN(2)  // Value for USER command.\n   )\n   BSCANE2_inst1 (\n      .CAPTURE(CAPTURE), // 1-bit output: CAPTURE output from TAP controller.\n      .DRCK(DRCK),       // 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or\n                         // SHIFT are asserted.\n\n      .RESET(RESET),     // 1-bit output: Reset output for TAP controller.\n      .RUNTEST(RUNTEST), // 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.\n      .SEL(SEL),         // 1-bit output: USER instruction active output.\n      .SHIFT(SHIFT),     // 1-bit output: SHIFT output from TAP controller.\n      .TCK(TCK_unbuf),   // 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.\n      .TDI(TDI),         // 1-bit output: Test Data Input (TDI) output from TAP controller.\n      .TMS(TMS),         // 1-bit output: Test Mode Select output. Fabric connection to TAP.\n      .UPDATE(UPDATE),   // 1-bit output: UPDATE output from TAP controller\n      .TDO(TDO)          // 1-bit input: Test Data Output (TDO) input for USER function.\n   );\n\n   // BUFH: HROW Clock Buffer for a Single Clocking Region\n   //       Artix-7\n   // Xilinx HDL Language Template, version 2016.1\n\n   BUFH BUFH_inst (\n      .O(TCK), // 1-bit output: Clock output\n      .I(TCK_unbuf)  // 1-bit input: Clock input\n   );\n  \n  /* DMI interface tie-off */\n  wire  ExampleRocketSystem_debug_ndreset;\n  wire  ExampleRocketSystem_debug_dmactive;\n  reg [31:0] io_reset_vector;\n\n   always @*\n     begin\n        casez (i_dip[1:0])\n          2'b?0: io_reset_vector = 32'h40000000;\n          2'b01: io_reset_vector = 32'h80000000;\n          2'b11: io_reset_vector = 32'h80200000;\n        endcase // casez ()\n     end\n   \n   ExampleRocketSystem Rocket\n     (\n      .debug_systemjtag_jtag_TCK(TCK),\n      .debug_systemjtag_jtag_TMS(TMS),\n      .debug_systemjtag_jtag_TDI(TDI),\n      .debug_systemjtag_jtag_TDO_data(TDO),\n      .debug_systemjtag_jtag_TDO_driven(TDO_driven),\n      .debug_systemjtag_reset(RESET),\n      .debug_systemjtag_mfr_id(11'h5AA),\n      .debug_ndreset(ExampleRocketSystem_debug_ndreset),\n      .debug_dmactive(ExampleRocketSystem_debug_dmactive),\n      .mem_axi4_0_aw_valid                ( `MEM_NASTI.aw_valid                     ),\n      .mem_axi4_0_aw_ready                ( `MEM_NASTI.aw_ready                     ),\n      .mem_axi4_0_aw_bits_id              ( `MEM_NASTI.aw_id                        ),\n      .mem_axi4_0_aw_bits_addr            ( `MEM_NASTI.aw_addr                      ),\n      .mem_axi4_0_aw_bits_len             ( `MEM_NASTI.aw_len                       ),\n      .mem_axi4_0_aw_bits_size            ( `MEM_NASTI.aw_size                      ),\n      .mem_axi4_0_aw_bits_burst           ( `MEM_NASTI.aw_burst                     ),\n      .mem_axi4_0_aw_bits_lock            ( `MEM_NASTI.aw_lock                      ),\n      .mem_axi4_0_aw_bits_cache           ( `MEM_NASTI.aw_cache                     ),\n      .mem_axi4_0_aw_bits_prot            ( `MEM_NASTI.aw_prot                      ),\n      .mem_axi4_0_aw_bits_qos             ( `MEM_NASTI.aw_qos                       ),\n      .mem_axi4_0_w_valid                 ( `MEM_NASTI.w_valid                      ),\n      .mem_axi4_0_w_ready                 ( `MEM_NASTI.w_ready                      ),\n      .mem_axi4_0_w_bits_data             ( `MEM_NASTI.w_data                       ),\n      .mem_axi4_0_w_bits_strb             ( `MEM_NASTI.w_strb                       ),\n      .mem_axi4_0_w_bits_last             ( `MEM_NASTI.w_last                       ),\n      .mem_axi4_0_b_valid                 ( `MEM_NASTI.b_valid                      ),\n      .mem_axi4_0_b_ready                 ( `MEM_NASTI.b_ready                      ),\n      .mem_axi4_0_b_bits_id               ( `MEM_NASTI.b_id                         ),\n      .mem_axi4_0_b_bits_resp             ( `MEM_NASTI.b_resp                       ),\n      .mem_axi4_0_ar_valid                ( `MEM_NASTI.ar_valid                     ),\n      .mem_axi4_0_ar_ready                ( `MEM_NASTI.ar_ready                     ),\n      .mem_axi4_0_ar_bits_id              ( `MEM_NASTI.ar_id                        ),\n      .mem_axi4_0_ar_bits_addr            ( `MEM_NASTI.ar_addr                      ),\n      .mem_axi4_0_ar_bits_len             ( `MEM_NASTI.ar_len                       ),\n      .mem_axi4_0_ar_bits_size            ( `MEM_NASTI.ar_size                      ),\n      .mem_axi4_0_ar_bits_burst           ( `MEM_NASTI.ar_burst                     ),\n      .mem_axi4_0_ar_bits_lock            ( `MEM_NASTI.ar_lock                      ),\n      .mem_axi4_0_ar_bits_cache           ( `MEM_NASTI.ar_cache                     ),\n      .mem_axi4_0_ar_bits_prot            ( `MEM_NASTI.ar_prot        "}
{"text": "              ),\n      .mem_axi4_0_ar_bits_qos             ( `MEM_NASTI.ar_qos                       ),\n      .mem_axi4_0_r_valid                 ( `MEM_NASTI.r_valid                      ),\n      .mem_axi4_0_r_ready                 ( `MEM_NASTI.r_ready                      ),\n      .mem_axi4_0_r_bits_id               ( `MEM_NASTI.r_id                         ),\n      .mem_axi4_0_r_bits_data             ( `MEM_NASTI.r_data                       ),\n      .mem_axi4_0_r_bits_resp             ( `MEM_NASTI.r_resp                       ),\n      .mem_axi4_0_r_bits_last             ( `MEM_NASTI.r_last                       ),\n`ifdef MEM_USER_WIDTH\n      .mem_axi4_0_aw_bits_user            ( `MEM_NASTI.aw_user                      ),\n      .mem_axi4_0_w_bits_user             ( `MEM_NASTI.w_user                       ),\n      .mem_axi4_0_b_bits_user             ( `MEM_NASTI.b_user                       ),\n      .mem_axi4_0_ar_bits_user            ( `MEM_NASTI.ar_user                      ),\n      .mem_axi4_0_r_bits_user             ( `MEM_NASTI.r_user                       ),\n`endif\n      .mmio_axi4_0_aw_valid        ( mmio_master_nasti.aw_valid               ),\n      .mmio_axi4_0_aw_ready        ( mmio_master_nasti.aw_ready               ),\n      .mmio_axi4_0_aw_bits_id      ( mmio_master_nasti.aw_id                  ),\n      .mmio_axi4_0_aw_bits_addr    ( mmio_master_nasti.aw_addr                ),\n      .mmio_axi4_0_aw_bits_len     ( mmio_master_nasti.aw_len                 ),\n      .mmio_axi4_0_aw_bits_size    ( mmio_master_nasti.aw_size                ),\n      .mmio_axi4_0_aw_bits_burst   ( mmio_master_nasti.aw_burst               ),\n      .mmio_axi4_0_aw_bits_lock    ( mmio_master_nasti.aw_lock                ),\n      .mmio_axi4_0_aw_bits_cache   ( mmio_master_nasti.aw_cache               ),\n      .mmio_axi4_0_aw_bits_prot    ( mmio_master_nasti.aw_prot                ),\n      .mmio_axi4_0_aw_bits_qos     ( mmio_master_nasti.aw_qos                 ),\n      .mmio_axi4_0_w_valid         ( mmio_master_nasti.w_valid                ),\n      .mmio_axi4_0_w_ready         ( mmio_master_nasti.w_ready                ),\n      .mmio_axi4_0_w_bits_data     ( mmio_master_nasti.w_data                 ),\n      .mmio_axi4_0_w_bits_strb     ( mmio_master_nasti.w_strb                 ),\n      .mmio_axi4_0_w_bits_last     ( mmio_master_nasti.w_last                 ),\n      .mmio_axi4_0_b_valid         ( mmio_master_nasti.b_valid                ),\n      .mmio_axi4_0_b_ready         ( mmio_master_nasti.b_ready                ),\n      .mmio_axi4_0_b_bits_id       ( mmio_master_nasti.b_id                   ),\n      .mmio_axi4_0_b_bits_resp     ( mmio_master_nasti.b_resp                 ),\n      .mmio_axi4_0_ar_valid        ( mmio_master_nasti.ar_valid               ),\n      .mmio_axi4_0_ar_ready        ( mmio_master_nasti.ar_ready               ),\n      .mmio_axi4_0_ar_bits_id      ( mmio_master_nasti.ar_id                  ),\n      .mmio_axi4_0_ar_bits_addr    ( mmio_master_nasti.ar_addr                ),\n      .mmio_axi4_0_ar_bits_len     ( mmio_master_nasti.ar_len                 ),\n      .mmio_axi4_0_ar_bits_size    ( mmio_master_nasti.ar_size                ),\n      .mmio_axi4_0_ar_bits_burst   ( mmio_master_nasti.ar_burst               ),\n      .mmio_axi4_0_ar_bits_lock    ( mmio_master_nasti.ar_lock                ),\n      .mmio_axi4_0_ar_bits_cache   ( mmio_master_nasti.ar_cache               ),\n      .mmio_axi4_0_ar_bits_prot    ( mmio_master_nasti.ar_prot                ),\n      .mmio_axi4_0_ar_bits_qos     ( mmio_master_nasti.ar_qos                 ),\n      .mmio_axi4_0_r_valid         ( mmio_master_nasti.r_valid                ),\n      .mmio_axi4_0_r_ready         ( mmio_master_nasti.r_ready                ),\n      .mmio_axi4_0_r_bits_id       ( mmio_master_nasti.r_id                   ),\n      .mmio_axi4_0_r_bits_data     ( mmio_master_nasti.r_data                 ),\n      .mmio_axi4_0_r_bits_resp     ( mmio_master_nasti.r_resp                 ),\n      .mmio_axi4_0_r_bits_last     ( mmio_master_nasti.r_last                 ),\n`ifdef MMIO_MASTER_USER_WIDTH\n      .mmio_axi4_0_aw_bits_user    ( mmio_master_nasti.aw_user                ),\n      .mmio_axi4_0_w_bits_user     ( mmio_master_nasti.w_user                 ),\n      .mmio_axi4_0_b_bits_user     ( mmio_master_nasti.b_user                 ),\n      .mmio_axi4_0_ar_bits_user    ( mmio_master_nasti.ar_user                ),\n      .mmio_axi4_0_r_bits_user     ( mmio_master_nasti.r_user                 ),\n`endif\n      .l2_frontend_bus_axi4_0_aw_valid         ( io_slave_nasti.aw_valid                ),\n      .l2_frontend_bus_axi4_0_aw_ready         ( io_slave_nasti.aw_ready                ),\n      .l2_frontend_bus_axi4_0_aw_bits_id       ( io_slave_nasti.aw_id                   ),\n      .l2_frontend_bus_axi4_0_aw_bits_addr     ( io_slave_nasti.aw_addr                 ),\n      .l2_frontend_bus_axi4_0_aw_bits_len      ( io_slave_nasti.aw_len                  ),\n      .l2_frontend_bus_axi4_0_aw_bits_size     ( io_slave_nasti.aw_size                 ),\n      .l2_frontend_bus_axi4_0_aw_bits_burst    ( io_slave_nasti.aw_burst                ),\n      .l2_frontend_bus_axi4_0_aw_bits_lock     ( io_slave_nasti.aw_lock                 ),\n      .l2_frontend_bus_axi4_0_aw_bits_cache    ( io_slave_nasti.aw_cache                ),\n      .l2_frontend_bus_axi4_0_aw_bits_prot     ( io_slave_nasti.aw_prot                 ),\n      .l2_frontend_bus_axi4_0_aw_bits_qos      ( io_slave_nasti.aw_qos                  ),\n      .l2_frontend_bus_axi4_0_w_valid          ( io_slave_nasti.w_valid                 ),\n      .l2_frontend_bus_axi4_0_w_ready          ( io_slave_nasti.w_ready                 ),\n      .l2_frontend_bus_axi4_0_w_bits_data      ( io_slave_nasti.w_data                  ),\n      .l2_frontend_bus_axi4_0_w_bits_strb      ( io_slave_nasti.w_strb                  ),\n      .l2_frontend_bus_axi4_0_w_bits_last      ( io_slave_nasti.w_last                  ),\n      .l2_frontend_bus_axi4_0_b_valid          ( io_slave_nasti.b_valid                 ),\n      .l2_frontend_bus_axi4_0_b_ready          ( io_slave_nasti.b_ready                 ),\n      .l2_frontend_bus_axi4_0_b_bits_id        ( io_slave_nasti.b_id                    ),\n      .l2_frontend_bus_axi4_0_b_bits_resp      ( io_slave_nasti.b_resp                  ),\n      .l2_frontend_bus_axi4_0_ar_valid         ( io_slave_nasti.ar_valid                ),\n      .l2_frontend_bus_axi4_0_ar_ready         ( io_slave_nasti.ar_ready                ),\n      .l2_frontend_bus_axi4_0_ar_bits_id       ( io_slave_nasti.ar_id                   ),\n      .l2_frontend_bus_axi4_0_ar_bits_addr     ( io_slave_nasti.ar_addr                 ),\n      .l2_frontend_bus_axi4_0_ar_bits_len      ( io_slave_nasti.ar_len                  ),\n      .l2_frontend_bus_axi4_0_ar_bits_size     ( io_slave_nasti.ar_size                 ),\n      .l2_frontend_bus_axi4_0_ar_bits_burst    ( io_slave_nasti.ar_burst                ),\n      .l2_frontend_bus_axi4_0_ar_bits_lock     ( io_slave_nasti.ar_lock                 ),\n      .l2_frontend_bus_axi4_0_ar_bits_cache    ( io_slave_nasti.ar_cache                ),\n      .l2_frontend_bus_axi4_0_ar_bits_prot     ( io_slave_nasti.ar_prot                 ),\n      .l2_frontend_bus_axi4_0_ar_bits_qos      ( io_slave_nasti.ar_qos                  ),\n      .l2_frontend_bus_axi4_0_r_valid          ( io_slave_nasti.r_valid                 ),\n      .l2_frontend_bus_axi4_0_r_ready          ( io_slave_nasti.r_ready                 ),\n      .l2_frontend_bus_axi4_0_r_bits_id        ( io_slave_nasti.r_id                    ),\n      .l2_frontend_bus_axi4_0_r_bits_data      ( io_slave_nasti.r_data                  ),\n      .l2_frontend_bus_axi4_0_r_bits_resp      ( io_slave_nasti.r_resp                  ),\n      .l2_frontend_bus_axi4_0_r_bits_last      ( io_slave_nasti.r_last                  ),\n`ifdef MMIO_SLAVE_USER_WIDTH\n      .l2_frontend_bus_axi4_0_aw_bits_user     ( io_salve_nasti.aw_user                 ),\n      .l2_frontend_bus_axi4_0_w_bits_user      ( io_salve_nasti.w_user                  ),\n      .l2_frontend_bus_axi4_0_b_bits_user      ( io_salve_nasti.b_user                  ),\n      .l2_frontend_bus_axi4_0_ar_bits_user     ( io_salve_nasti.ar_user                 ),\n      .l2_frontend_bus_axi4_0_r_bits_user      ( io_salve_nasti.r_user                  ),\n`endif\n      .interrupts                    ( {sd_irq, eth_irq, spi_irq, uart_irq} ),\n      .io_reset_vector               ( io_reset_vector                      ),\n      .clock                         ( clk                                  ),\n      .reset                         ( sys_rst                              )\n      );\n   \nendmodule // chip_top\n"}
{"text": "module chip_top_dummy( // @[:freechips.rocketchip.system.DefaultFPGAConfig.fir@257214.2]\n  input   clk_p, // @[:freechips.rocketchip.system.DefaultFPGAConfig.fir@257215.4]\n  input   clk_n, // @[:freechips.rocketchip.system.DefaultFPGAConfig.fir@257215.4]\n  input   rst_top, // @[:freechips.rocketchip.system.DefaultFPGAConfig.fir@257216.4]\n  output GPIO_LED_0_LS\n);\n\n   logic clock, clk_locked, clk_locked_wiz;\n\nTestHarness dut( // @[:freechips.rocketchip.system.DefaultFPGAConfig.fir@257214.2]\n  .clock(clock), // @[:freechips.rocketchip.system.DefaultFPGAConfig.fir@257215.4]\n  .reset(~clk_locked), // @[:freechips.rocketchip.system.DefaultFPGAConfig.fir@257216.4]\n  .io_success(GPIO_LED_0_LS) // @[:freechips.rocketchip.system.DefaultFPGAConfig.fir@257217.4]\n);\n\n  clk_wiz_dummy clk_gen\n     (\n   // Clock in ports\n    .clk_in1_p(clk_p),    // input clk_in1_p\n    .clk_in1_n(clk_n),    // input clk_in1_n\n    // Clock out ports\n    .clk_out1(clock),     // output clk_out1\n    // Status and control signals\n    .resetn(~rst_top), // input resetn\n    .locked(clk_locked_wiz));      // output locked\n\n   assign clk_locked = clk_locked_wiz & ~rst_top;\n\nendmodule\n"}
{"text": "// See LICENSE.SiFive for license details.\n\n/** This black-boxes a Clock Divider by 2.\n  * The output clock is phase-aligned to the input clock.\n  * If you use this in synthesis, make sure your sdc\n  * declares that you want it to do the same.\n  *\n  * Because Chisel does not support\n  * blocking assignments, it is impossible\n  * to create a deterministic divided clock.\n  *\n  *  @param clk_out Divided Clock\n  *  @param clk_in  Clock Input\n  *\n  */\n\nmodule ClockDivider2 (output reg clk_out, input clk_in);\n\n   initial clk_out = 1'b0;\n   always @(posedge clk_in) begin\n      clk_out = ~clk_out; // Must use =, NOT <=\n   end\n\nendmodule // ClockDivider2\n"}
{"text": "// See LICENSE.SiFive for license details.\n\n/** This black-boxes a Clock Divider by 3.\n  * The output clock is phase-aligned to the input clock.\n  * Do NOT use this in synthesis; the duty cycle is 2:1.\n  *\n  * Because Chisel does not support\n  * blocking assignments, it is impossible\n  * to create a deterministic divided clock.\n  *\n  *  @param clk_out Divided Clock\n  *  @param clk_in  Clock Input\n  *\n  */\n\nmodule ClockDivider3 (output reg clk_out, input clk_in);\n\n   reg delay;\n\n   initial begin\n     clk_out = 1'b0;\n     delay = 1'b0;\n   end\n\n   always @(posedge clk_in) begin\n      if (clk_out == 1'b0) begin\n        clk_out = 1'b1;\n        delay <= 1'b0;\n      end else if (delay == 1'b1) begin\n        clk_out = 1'b0;\n        delay <= 1'b0;\n      end else begin\n        delay <= 1'b1;\n      end\n   end\n\nendmodule // ClockDivider3\n"}
{"text": "// See LICENSE for license details.\n\n//-------------------------------------------------\n// Define the features in simulatio/fpga/asic\n//-------------------------------------------------\n\n`ifndef CHIP_CONFIG_VH\n `define CHIP_CONFIG_VH\n\n // For some known cases\n `ifdef VERILATOR_SIM\n  // when verilator is used for behavioural simulation\n  `define SIMULATION\n `endif\n\n `ifdef VCS\n  // when Synopsys VCS is used for behavioural simulation\n  `define SIMULATION\n `endif\n\n `ifdef INCA\n  // when Cadence NCSIM is used for behavioural simulation\n  `define SIMULATION\n `endif\n\n `ifdef MODEL_TECH\n  // when Mentor Graphic Modelsom is used for behavioural simulation\n  `define SIMULATION\n `endif\n\n // The following should be indicated but can be directly enabled\n // SIMULATION            : simulation\n // FPGA                  : FPGA implementation\n // ASIC                  : ASIC implementation\n\n // FPGA_FULL             : simulation/implement very ip of FPGA\n\n //----------- Detailed configuration -------------//\n\n `define LOWRISC_IO_DAT_WIDTH 32\n\n `ifdef FPGA\n\n  `ifdef FPGA_FULL\n   `define ADD_PHY_DDR\n  `endif\n\n  `ifdef NEXYS4_VIDEO\n   `define NEXYS4_COMMON\n  `endif\n\n  `ifdef NEXYS4\n   `define NEXYS4_COMMON\n  `endif\n\n  //`define ADD_MINION_SD\n\n `endif //  `ifdef FPGA\n\n`endif //  `ifndef CHIP_CONFIG_VH\n\n"}
{"text": "`ifndef LoRCCoreplex_HD\n  `define LoRCCoreplex_HD\n  `define ADD_BRAM\n  `define ADD_ROCKET_INT\n  `define ADD_HID\n  `define BRAM_BASE (31'h40000000)\n  `define BRAM_SIZE (21'h00100000)\n  `define HID_BASE  (31'h41000000)\n  `define HID_SIZE  (21'h00100000)\n  `define MEM_ADDR_WIDTH (32'h00000020)\n  `define MEM_BASE (64'h0000000080000000)\n  `define MEM_DATA_WIDTH (32'h00000040)\n  `define MEM_ID_WIDTH (32'h00000004)\n  `define MEM_SIZE (64'h0000000010000000)\n  `define MMIO_MASTER_ADDR_WIDTH (32'h0000001f)\n  `define MMIO_MASTER_DATA_WIDTH (32'h00000040)\n  `define MMIO_MASTER_ID_WIDTH (32'h00000004)\n  `define MMIO_SLAVE_ADDR_WIDTH (32'h00000020)\n  `define MMIO_SLAVE_DATA_WIDTH (32'h00000040)\n  `define MMIO_SLAVE_ID_WIDTH (32'h00000008)\n  `define ROCKET_INT_SIZE (32'h00000004)\n`endif\n"}
{"text": "import dii_package::dii_flit;\n\n`include \"consts.vh\"\n\nmodule debug_system\n  #(parameter N_CORES        = 1,\n    parameter MAM_DATA_WIDTH = 16,\n    parameter MAM_REGIONS    = 2,\n    parameter MAM_BASE_ADDR0 = 0,\n    parameter MAM_MEM_SIZE0  = 'h10000,\n    parameter MAM_BASE_ADDR1 = 'h40000000,\n    parameter MAM_MEM_SIZE1  = 'h8000000,\n    parameter MAM_ADDR_WIDTH = 64,\n    parameter FREQ_CLK_IO    = 'x,\n    parameter UART_BAUD      = 'x)\n  (\n   input                        clk, rstn,\n   input                        clk_io,\n\n   input                        rx,\n   output                       tx,\n   input                        cts,\n   output                       rts,\n\n   output                       uart_irq,\n\n   input [12:0]                 uart_ar_addr,\n   input                        uart_ar_valid,\n   output                       uart_ar_ready,\n\n   output [1:0]                 uart_r_resp,\n   output [31:0]                uart_r_data,\n   output                       uart_r_valid,\n   input                        uart_r_ready,\n\n   input [12:0]                 uart_aw_addr,\n   input                        uart_aw_valid,\n   output                       uart_aw_ready,\n\n   input [31:0]                 uart_w_data,\n   input                        uart_w_valid,\n   output                       uart_w_ready,\n\n   output [1:0]                 uart_b_resp,\n   output                       uart_b_valid,\n   input                        uart_b_ready,\n\n   output                       sys_rst, cpu_rst,\n\n   input  dii_flit [1:0]        ring_in,\n   output [1:0]                 ring_in_ready,\n   output dii_flit [1:0]        ring_out,\n   input [1:0]                  ring_out_ready,\n\n   output                       req_valid,\n   input                        req_ready,\n   output                       req_rw,\n   output [MAM_ADDR_WIDTH-1:0]  req_addr,\n   output                       req_burst,\n   output [13:0]                req_beats,\n\n   output                       write_valid,\n   input                        write_ready,\n   output [MAM_DATA_WIDTH-1:0]  write_data,\n   logic [MAM_DATA_WIDTH/8-1:0] write_strb,\n\n   input                        read_valid,\n   input [MAM_DATA_WIDTH-1:0]   read_data,\n   output                       read_ready\n   );\n\n   localparam MAX_PKT_LEN = 16;\n\n   initial assert (MAM_DATA_WIDTH == 16) else $fatal(1, \"MAM_DATA_WIDTH must be 16!\");\n\n   logic  rst;\n   assign rst = ~rstn;\n\n   glip_channel #(.WIDTH(16)) fifo_in (.*);\n   glip_channel #(.WIDTH(16)) fifo_out (.*);\n\n   logic  logic_rst, com_rst;\n\n`ifdef FPGA_FULL\n   logic [15:0]  fifo_out_data;\n   logic         fifo_out_valid;\n   logic         fifo_out_ready;\n   logic  [15:0] fifo_in_data;\n   logic         fifo_in_valid;\n   logic         fifo_in_ready;\n\n   assign fifo_in.data = fifo_in_data;\n   assign fifo_in.valid = fifo_in_valid;\n   assign fifo_in_ready = fifo_in.ready;\n   assign fifo_out_data = fifo_out.data;\n   assign fifo_out_valid = fifo_out.valid;\n   assign fifo_out.ready = fifo_out_ready;\n\n   glip_uart_toplevel\n     #(.WIDTH(16), .BAUD(UART_BAUD), .FREQ_CLK_IO(FREQ_CLK_IO))\n   u_glip(.clk_io    (clk_io),\n          .clk       (clk),\n          .rst       (rst),\n          .ctrl_logic_rst (logic_rst),\n          .com_rst   (com_rst),\n          .fifo_in_data  (fifo_in_data[15:0]),\n          .fifo_in_valid (fifo_in_valid),\n          .fifo_in_ready (fifo_in_ready),\n          .fifo_out_data  (fifo_out_data[15:0]),\n          .fifo_out_valid (fifo_out_valid),\n          .fifo_out_ready (fifo_out_ready),\n          .uart_rx (rx),\n          .uart_tx (tx),\n          .uart_cts_n (cts),\n          .uart_rts_n (rts),\n          .error ());\n`else // !`ifdef FPGA\n\n   glip_tcp_toplevel\n     #(.WIDTH(16))\n   u_glip(.clk_io    (clk),\n          .clk_logic (clk),\n          .rst       (rst),\n          .logic_rst (logic_rst),\n          .com_rst   (com_rst),\n          .fifo_in   (fifo_in),\n          .fifo_out  (fifo_out));\n`endif\n\n   parameter PERCORE = 2;\n   localparam N_OSD = 4;\n   localparam N = N_CORES*PERCORE+N_OSD;\n\n   logic [N_OSD-1:0][9:0] id_map;\n   assign id_map[0] = 0;        // HIM\n   assign id_map[1] = 1;        // SCM\n   assign id_map[2] = 2;        // UART\n   assign id_map[3] = 3;        // MAM\n\n   dii_flit [N_OSD-1:0] dii_out; logic [N_OSD-1:0] dii_out_ready;\n   dii_flit [N_OSD-1:0] dii_in; logic [N_OSD-1:0] dii_in_ready;\n\n   osd_him\n     #(.MAX_PKT_LEN(MAX_PKT_LEN))\n     u_him(.*,\n           .glip_in  (fifo_in),\n           .glip_out (fifo_out),\n           .dii_out        ( dii_out[0]        ),\n           .dii_out_ready  ( dii_out_ready[0]  ),\n           .dii_in         ( dii_in[0]         ),\n           .dii_in_ready   ( dii_in_ready[0]   )\n           );\n\n   osd_scm\n     #(.SYSTEMID(16'hdead), .NUM_MOD(N-1),\n       .MAX_PKT_LEN(MAX_PKT_LEN))\n   u_scm(.*,\n         .id              ( id_map[1]        ),\n         .debug_in        ( dii_in[1]        ),\n         .debug_in_ready  ( dii_in_ready[1]  ),\n         .debug_out       ( dii_out[1]       ),\n         .debug_out_ready ( dii_out_ready[1] )\n         );\n\n   assign uart_r_data[31:8] = 0;\n\n   osd_dem_uart_nasti\n     u_uart (.*,\n             .id ( id_map[2] ),\n             .irq (uart_irq),\n             .ar_addr (uart_ar_addr[4:2]),\n             .ar_valid (uart_ar_valid),\n             .ar_ready (uart_ar_ready),\n             .r_data (uart_r_data[7:0]),\n             .r_valid (uart_r_valid),\n             .r_ready (uart_r_ready),\n             .r_resp (uart_r_resp),\n             .aw_addr (uart_aw_addr[4:2]),\n             .aw_valid (uart_aw_valid),\n             .aw_ready (uart_aw_ready),\n             .w_data (uart_w_data),\n             .w_valid (uart_w_valid),\n             .w_ready (uart_w_ready),\n             .b_valid (uart_b_valid),\n             .b_ready (uart_b_ready),\n             .b_resp (uart_b_resp),\n\n             .debug_in        ( dii_in[2]        ),\n             .debug_in_ready  ( dii_in_ready[2]  ),\n             .debug_out       ( dii_out[2]       ),\n             .debug_out_ready ( dii_out_ready[2] )\n             );\n\n   osd_mam\n     #(.DATA_WIDTH(MAM_DATA_WIDTH), .REGIONS(MAM_REGIONS),\n       .BASE_ADDR0(MAM_BASE_ADDR0), .MEM_SIZE0(MAM_MEM_SIZE0),\n       .BASE_ADDR1(MAM_BASE_ADDR1), .MEM_SIZE1(MAM_MEM_SIZE1),\n       .ADDR_WIDTH(MAM_ADDR_WIDTH), .MAX_PKT_LEN(MAX_PKT_LEN),\n       .ENDIAN(0))\n   u_mam (.*,\n          .id              ( id_map[3]        ),\n          .debug_in        ( dii_in[3]        ),\n          .debug_in_ready  ( dii_in_ready[3]  ),\n          .debug_out       ( dii_out[3]       ),\n          .debug_out_ready ( dii_out_ready[3] ),\n          .read_data       ( read_data        ),\n          .write_data      ( write_data       )\n          );\n\n   dii_flit [1:0] ext_in;  logic [1:0] ext_in_ready;\n   dii_flit [1:0] ext_out; logic [1:0] ext_out_ready;\n\n   debug_ring_expand\n     #(.PORTS(N_OSD))\n   u_ring(.*,\n          .dii_in        ( dii_out        ),\n          .dii_in_ready  ( dii_out_ready  ),\n          .dii_out       ( dii_in         ),\n          .dii_out_ready ( dii_in_ready   ),\n          .ext_in        ( ext_in         ),\n          .ext_in_ready  ( ext_in_ready   ),\n          .ext_out       ( ext_out        ),\n          .ext_out_ready ( ext_out_ready  )\n          );\n\n   assign ext_in[0].valid = 1'b0;\n   assign ext_in[1] = ring_in[0];\n   assign ring_in_ready[0] = ext_in_ready[1];\n   assign ring_out = ext_out;\n   assign ext_out_ready = ring_out_ready;\n   assign ring_in_ready[1] = 1'b1;\n\nendmodule // debug_system\n"}
{"text": "\nmodule dualmem(clka, clkb, dina, dinb, addra, addrb, wea, web, douta, doutb, ena, enb);\n\n   input wire clka, clkb;\n   input [63:0] dina;\n   input [63:0] dinb;\n   input [10:0] addra;\n   input [10:0] addrb;\n   input [7:0]        wea;\n   input [7:0]        web;\n   input [0:0]        ena, enb;\n   output [63:0]      douta;\n   output [63:0]      doutb;\n\n   genvar r;\n\n`ifdef FPGA\n   \n   generate for (r = 0; r < 8; r=r+1)\n     RAMB16_S9_S9\n     RAMB16_S9_S9_inst\n       (\n        .CLKA   ( clka                     ),     // Port A Clock\n        .DOA    ( douta[r*8 +: 8]          ),     // Port A 1-bit Data Output\n        .DOPA   (                          ),\n        .ADDRA  ( addra                    ),     // Port A 14-bit Address Input\n        .DIA    ( dina[r*8 +: 8]           ),     // Port A 1-bit Data Input\n        .DIPA   ( 1'b0                     ),\n        .ENA    ( ena                      ),     // Port A RAM Enable Input\n        .SSRA   ( 1'b0                     ),     // Port A Synchronous Set/Reset Input\n        .WEA    ( wea[r]                   ),     // Port A Write Enable Input\n        .CLKB   ( clkb                     ),     // Port B Clock\n        .DOB    ( doutb[r*8 +: 8]          ),     // Port B 1-bit Data Output\n        .DOPB   (                          ),\n        .ADDRB  ( addrb                    ),     // Port B 14-bit Address Input\n        .DIB    ( dinb[r*8 +: 8]           ),     // Port B 1-bit Data Input\n        .DIPB   ( 1'b0                     ),\n        .ENB    ( enb                      ),     // Port B RAM Enable Input\n        .SSRB   ( 1'b0                     ),     // Port B Synchronous Set/Reset Input\n        .WEB    ( web[r]                   )      // Port B Write Enable Input\n        );\n   endgenerate\n\n`else // !`ifdef FPGA\n\ninfer_dpram #(.RAM_SIZE(11), .BYTE_WIDTH(8)) ram1 // RAM_SIZE is in words\n(\n.ram_clk_a(clka),\n.ram_en_a(ena),\n.ram_we_a(wea),\n.ram_addr_a(addra),\n.ram_wrdata_a(dina),\n.ram_rddata_a(douta),\n.ram_clk_b(clkb),\n.ram_en_b(enb),\n.ram_we_b(web),\n.ram_addr_b(addrb),\n.ram_wrdata_b(dinb),\n.ram_rddata_b(doutb)\n );\n   \n`endif\n   \nendmodule // dualmem\n"}
{"text": "\nmodule dualmem_32K_64(clka, clkb, dina, dinb, addra, addrb, wea, web, douta, doutb, ena, enb);\n\n   input wire clka, clkb;\n   input [63:0] dina;\n   input [63:0] dinb;\n   input [8:0] addra;\n   input [8:0] addrb;\n   input [7:0]        wea;\n   input [7:0]        web;\n   input [0:0]        ena, enb;\n   output [63:0]      douta;\n   output [63:0]      doutb;\n\n   genvar r;\n\n`ifdef FPGA\n   \n   generate for (r = 0; r < 2; r=r+1)\n     RAMB16_S36_S36\n     RAMB16_S36_S36_inst\n       (\n        .CLKA   ( clka                     ),     // Port A Clock\n        .DOA    ( douta[r*32 +: 32]        ),     // Port A 1-bit Data Output\n        .DOPA   (                          ),\n        .ADDRA  ( addra                    ),     // Port A 14-bit Address Input\n        .DIA    ( dina[r*32 +: 32]         ),     // Port A 1-bit Data Input\n        .DIPA   ( 4'b0                     ),\n        .ENA    ( ena                      ),     // Port A RAM Enable Input\n        .SSRA   ( 1'b0                     ),     // Port A Synchronous Set/Reset Input\n        .WEA    ( wea[r*4]                 ),     // Port A Write Enable Input\n        .CLKB   ( clkb                     ),     // Port B Clock\n        .DOB    ( doutb[r*32 +: 32]        ),     // Port B 1-bit Data Output\n        .DOPB   (                          ),\n        .ADDRB  ( addrb                    ),     // Port B 14-bit Address Input\n        .DIB    ( dinb[r*32 +: 32]         ),     // Port B 1-bit Data Input\n        .DIPB   ( 4'b0                     ),\n        .ENB    ( enb                      ),     // Port B RAM Enable Input\n        .SSRB   ( 1'b0                     ),     // Port B Synchronous Set/Reset Input\n        .WEB    ( web[r*4]                 )      // Port B Write Enable Input\n        );\n   endgenerate\n\n`else // !`ifdef FPGA\n\ninfer_dpram #(.RAM_SIZE(9), .BYTE_WIDTH(8)) ram1 // RAM_SIZE is in words\n(\n.ram_clk_a(clka),\n.ram_en_a(ena),\n.ram_we_a(wea),\n.ram_addr_a(addra),\n.ram_wrdata_a(dina),\n.ram_rddata_a(douta),\n.ram_clk_b(clkb),\n.ram_en_b(enb),\n.ram_we_b(web),\n.ram_addr_b(addrb),\n.ram_wrdata_b(dinb),\n.ram_rddata_b(doutb)\n );\n   \n`endif\n   \nendmodule // dualmem\n"}
{"text": "\nmodule dualmem_widen(clka, clkb, dina, dinb, addra, addrb, wea, web, douta, doutb, ena, enb);\n\n   input wire clka, clkb;\n   input  [15:0] dina;\n   input  [63:0] dinb;\n   input  [10:0] addra;\n   input   [8:0] addrb;\n   input   [1:0]        wea;\n   input   [1:0]        web;\n   input   [0:0]        ena, enb;\n   output [15:0]      douta;\n   output [63:0]      doutb;\n\n   genvar r;\n   wire [47:0]        dout;\n\n`ifdef FPGA\n   \n   generate for (r = 0; r < 2; r=r+1)\n     RAMB16_S9_S36\n     RAMB16_S9_S36_inst\n       (\n        .CLKA   ( clka                     ),     // Port A Clock\n        .DOA    ( douta[r*8 +: 8]          ),     // Port A 1-bit Data Output\n        .DOPA   (                          ),\n        .ADDRA  ( addra                    ),     // Port A 14-bit Address Input\n        .DIA    ( dina[r*8 +: 8]           ),     // Port A 1-bit Data Input\n        .DIPA   ( 1'b0                     ),\n        .ENA    ( ena                      ),     // Port A RAM Enable Input\n        .SSRA   ( 1'b0                     ),     // Port A Synchronous Set/Reset Input\n        .WEA    ( wea[r]                   ),     // Port A Write Enable Input\n        .CLKB   ( clkb                     ),     // Port B Clock\n        .DOB    ( doutb[r*32 +: 32]        ),     // Port B 1-bit Data Output\n        .DOPB   (                          ),\n        .ADDRB  ( addrb                    ),     // Port B 14-bit Address Input\n        .DIB    ( dinb[r*32 +: 32]         ),     // Port B 1-bit Data Input\n        .DIPB   ( 4'b0                     ),\n        .ENB    ( enb                      ),     // Port B RAM Enable Input\n        .SSRB   ( 1'b0                     ),     // Port B Synchronous Set/Reset Input\n        .WEB    ( web[r]                   )      // Port B Write Enable Input\n        );\n   endgenerate\n\n`else // !`ifdef FPGA\n\n// This bit is a placeholder\n\ninfer_dpram #(.RAM_SIZE(11), .BYTE_WIDTH(8)) ram1 // RAM_SIZE is in words\n(\n.ram_clk_a(clka),\n.ram_en_a(|ena),\n.ram_we_a({wea[1],wea[1],wea[1],wea[1],wea[0],wea[0],wea[0],wea[0]}),\n.ram_addr_a(addra),\n.ram_wrdata_a({dina,dina,dina,dina}),\n.ram_rddata_a({dout,douta}),\n.ram_clk_b(clkb),\n.ram_en_b(|enb),\n.ram_we_b({web[1],web[1],web[1],web[1],web[0],web[0],web[0],web[0]}),\n.ram_addr_b({2'b0,addrb}),\n.ram_wrdata_b(dinb),\n.ram_rddata_b(doutb)\n );\n   \n`endif\n   \nendmodule // dualmem\n"}
{"text": "\nmodule dualmem_widen8(clka, clkb, dina, dinb, addra, addrb, wea, web, douta, doutb, ena, enb);\n\n   input wire clka, clkb;\n   input  [15:0] dina;\n   input  [63:0] dinb;\n   input  [12:0] addra;\n   input  [10:0] addrb;\n   input   [1:0]        wea;\n   input   [1:0]        web;\n   input   [0:0]        ena, enb;\n   output [15:0]      douta;\n   output [63:0]      doutb;\n\n   genvar r;\n   wire [63:0]        dout0;\n   wire [255:0]       dout1;\n   wire [7:0] \t      we0, we1, en0, en1;\n   wire [63:0]        din0;\n   wire [255:0]       din1;\n   \n   reg [12:0]       addra_dly;\n   reg [10:0]       addrb_dly;\n\n`ifdef FPGA\n\n   assign douta = dout0 >> {addra_dly[12:11],4'b0000};\n   assign doutb = dout1 >> {addrb_dly[10:9],6'b000000};\n   assign we0 = wea << {addra[12:11],1'b0};\n   assign we1 = web << {addrb[10:9],1'b0};\n   assign en0 = {ena,ena} << {addra[12:11],1'b0};\n   assign en1 = {enb,enb} << {addrb[10:9],1'b0};\n   assign din0 = {dina,dina,dina,dina};\n   assign din1 = {dinb,dinb,dinb,dinb};\n   \n   always @(posedge clka)\n     begin\n\taddra_dly <= addra;\n\taddrb_dly <= addrb;\n     end\n   \n   generate for (r = 0; r < 8; r=r+1)\n     RAMB16_S9_S36\n     RAMB16_S9_S36_inst\n       (\n        .CLKA   ( clka                     ),     // Port A Clock\n        .DOA    ( dout0[r*8 +: 8]          ),     // Port A 1-bit Data Output\n        .DOPA   (                          ),\n        .ADDRA  ( addra[10:0]              ),     // Port A 14-bit Address Input\n        .DIA    ( din0[r*8 +: 8]           ),     // Port A 1-bit Data Input\n        .DIPA   ( 1'b0                     ),\n        .ENA    ( en0[r]                   ),     // Port A RAM Enable Input\n        .SSRA   ( 1'b0                     ),     // Port A Synchronous Set/Reset Input\n        .WEA    ( we0[r]                   ),     // Port A Write Enable Input\n        .CLKB   ( clkb                     ),     // Port B Clock\n        .DOB    ( dout1[r*32 +: 32]        ),     // Port B 1-bit Data Output\n        .DOPB   (                          ),\n        .ADDRB  ( addrb[8:0]               ),     // Port B 14-bit Address Input\n        .DIB    ( din1[r*32 +: 32]         ),     // Port B 1-bit Data Input\n        .DIPB   ( 4'b0                     ),\n        .ENB    ( en1[r]                   ),     // Port B RAM Enable Input\n        .SSRB   ( 1'b0                     ),     // Port B Synchronous Set/Reset Input\n        .WEB    ( we1[r]                   )      // Port B Write Enable Input\n        );\n   endgenerate\n\n`else // !`ifdef FPGA\n\n// This bit is a placeholder\n\ninfer_dpram #(.RAM_SIZE(11), .BYTE_WIDTH(8)) ram1 // RAM_SIZE is in words\n(\n.ram_clk_a(clka),\n.ram_en_a(|ena),\n.ram_we_a({wea[1],wea[1],wea[1],wea[1],wea[0],wea[0],wea[0],wea[0]}),\n.ram_addr_a(addra),\n.ram_wrdata_a({dina,dina,dina,dina}),\n.ram_rddata_a({dout,douta}),\n.ram_clk_b(clkb),\n.ram_en_b(|enb),\n.ram_we_b({web[1],web[1],web[1],web[1],web[0],web[0],web[0],web[0]}),\n.ram_addr_b({2'b0,addrb}),\n.ram_wrdata_b(dinb),\n.ram_rddata_b(doutb)\n );\n   \n`endif\n   \nendmodule // dualmem\n"}
{"text": "/*\n\nCopyright (c) 2016-2017 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\ncommit 9a507b388ddddb0a7b54f88ad217d5e4bc48822c\nAuthor: Alex Forencich <alex@alexforencich.com>\nDate:   Fri Jun 9 21:17:28 2017 -0700\n\norigin\thttps://github.com/alexforencich/verilog-ethernet.git\n\n*/\n\n// Language: Verilog 2001\n\n`timescale 1ns / 1ps\n\n/*\n * Parametrizable combinatorial parallel LFSR/CRC\n */\nmodule eth_lfsr #\n(\n    // width of LFSR\n    parameter LFSR_WIDTH = 31,\n    // LFSR polynomial\n    parameter LFSR_POLY = 31'h10000001,\n    // LFSR configuration: \"GALOIS\", \"FIBONACCI\"\n    parameter LFSR_CONFIG = \"FIBONACCI\",\n    // LFSR feed forward enable\n    parameter LFSR_FEED_FORWARD = 0,\n    // bit-reverse input and output\n    parameter REVERSE = 0,\n    // width of data input\n    parameter DATA_WIDTH = 8,\n    // implementation style: \"AUTO\", \"LOOP\", \"REDUCTION\"\n    parameter STYLE = \"AUTO\"\n)\n(\n    input  wire [DATA_WIDTH-1:0] data_in,\n    input  wire [LFSR_WIDTH-1:0] state_in,\n    output wire [DATA_WIDTH-1:0] data_out,\n    output wire [LFSR_WIDTH-1:0] state_out\n);\n\n/*\n\nFully parametrizable combinatorial parallel LFSR/CRC module.  Implements an unrolled LFSR\nnext state computation, shifting DATA_WIDTH bits per pass through the module.  Input data\nis XORed with LFSR feedback path, tie data_in to zero if this is not required.\n\nWorks in two parts: statically computes a set of bit masks, then uses these bit masks to\nselect bits for XORing to compute the next state.  \n\nPorts:\n\ndata_in\n\nData bits to be shifted through the LFSR (DATA_WIDTH bits)\n\nstate_in\n\nLFSR/CRC current state input (LFSR_WIDTH bits)\n\ndata_out\n\nData bits shifted out of LFSR (DATA_WIDTH bits)\n\nstate_out\n\nLFSR/CRC next state output (LFSR_WIDTH bits)\n\nParameters:\n\nLFSR_WIDTH\n\nSpecify width of LFSR/CRC register\n\nLFSR_POLY\n\nSpecify the LFSR/CRC polynomial in hex format.  For example, the polynomial\n\nx^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1\n\nwould be represented as\n\n32'h04c11db7\n\nNote that the largest term (x^32) is suppressed.  This term is generated automatically based\non LFSR_WIDTH.\n\nLFSR_CONFIG\n\nSpecify the LFSR configuration, either Fibonacci or Galois.  Fibonacci is generally used\nfor linear-feedback shift registers (LFSR) for pseudorandom binary sequence (PRBS) generators,\nscramblers, and descrambers, while Galois is generally used for cyclic redundancy check\ngenerators and checkers.\n\nFibonacci style (example for 64b66b scrambler, 0x8000000001)\n\n   DIN (LSB first)\n    |\n    V\n   (+)<---------------------------(+)<-----------------------------.\n    |                              ^                               |\n    |  .----.  .----.       .----. |  .----.       .----.  .----.  |\n    +->|  0 |->|  1 |->...->| 38 |-+->| 39 |->...->| 56 |->| 57 |--'\n    |  '----'  '----'       '----'    '----'       '----'  '----'\n    V\n   DOUT\n\nGalois style (example for CRC16, 0x8005)\n\n    ,-------------------+-------------------------+----------(+)<-- DIN (MSB first)\n    |                   |                         |           ^\n    |  .----.  .----.   V   .----.       .----.   V   .----.  |\n    `->|  0 |->|  1 |->(+)->|  2 |->...->| 14 |->(+)->| 15 |--+---> DOUT\n       '----'  '----'       '----'       '----'       '----'\n\nLFSR_FEED_FORWARD\n\nGenerate feed forward instead of feed back LFSR.  Enable this for PRBS checking and self-\nsynchronous descrambling.\n\nFibonacci feed-forward style (example for 64b66b descrambler, 0x8000000001)\n\n   DIN (LSB first)\n    |\n    |  .----.  .----.       .----.    .----.       .----.  .----.\n    +->|  0 |->|  1 |->...->| 38 |-+->| 39 |->...->| 56 |->| 57 |--.\n    |  '----'  '----'       '----' |  '----'       '----'  '----'  |\n    |                              V                               |\n   (+)<---------------------------(+)------------------------------'\n    |\n    V\n   DOUT\n\nGalois feed-forward style\n\n    ,-------------------+-------------------------+------------+--- DIN (MSB first)\n    |                   |                         |            |\n    |  .----.  .----.   V   .----.       .----.   V   .----.   V\n    `->|  0 |->|  1 |->(+)->|  2 |->...->| 14 |->(+)->| 15 |->(+)-> DOUT\n       '----'  '----'       '----'       '----'       '----'\n\nREVERSE\n\nBit-reverse LFSR input and output.  Shifts MSB first by default, set REVERSE for LSB first.\n\nDATA_WIDTH\n\nSpecify width of input and output data bus.  The module will perform one shift per input\ndata bit, so if the input data bus is not required tie data_in to zero and set DATA_WIDTH\nto the required number of shifts per clock cycle.  \n\nSTYLE\n\nSpecify implementation style.  Can be \"AUTO\", \"LOOP\", or \"REDUCTION\".  When \"AUTO\"\nis selected, implemenation will be \"LOOP\" or \"REDUCTION\" based on synthesis translate\ndirectives.  \"REDUCTION\" and \"LOOP\" are functionally identical, however they simulate\nand synthesize differently.  \"REDUCTION\" is implemented with a loop over a Verilog\nreduction operator.  \"LOOP\" is implemented as a doubly-nested loop with no reduction\noperator.  \"REDUCTION\" is very fast for simulation in iverilog and synthesizes well in\nQuartus but synthesizes poorly in ISE, likely due to large inferred XOR gates causing\nproblems with the optimizer.  \"LOOP\" synthesizes will in both ISE and Quartus.  \"AUTO\"\nwill default to \"REDUCTION\" when simulating and \"LOOP\" for synthesizers that obey\nsynthesis translate directives.\n\nSettings for common LFSR/CRC implementations:\n\nName        Configuration           Length  Polynomial      Initial value   Notes\nCRC16-IBM   Galois, bit-reverse     16      16'h8005        16'hffff\nCRC16-CCITT Galois                  16      16'h1021        16'h1d0f\nCRC32       Galois, bit-reverse     32      32'h04c11db7    32'hffffffff    Ethernet FCS; invert final output\nPRBS6       Fibonacci               6       6'h21           any\nPRBS7       Fibonacci               7       7'h41           any\nPRBS9       Fibonacci               9       9'h021          any             ITU V.52\nPRBS10      Fibonacci               10      10'h081         any             ITU\nPRBS11      Fibonacci               11      11'h201         any             ITU O.152\nPRBS15      Fibonacci, inverted     15      15'h4001        any             ITU O.152\nPRBS17      Fibonacci               17      17'h04001       any\nPRBS20      Fibonacci               20      20'h00009       any             ITU V.57\nPRBS23      Fibonacci, inverted     23      23'h040001      any             ITU O.151\nPRBS29      Fibonacci, inverted     29      29'h08000001    any\nPRBS31      Fibonacci, inverted     31      31'h10000001    any\n64b66b      Fibonacci, bit-reverse  58      58'h8000000001  any             10G Ethernet\n128b130b    Galois, bit-reverse     23      23'h210125      any             PCIe gen 3\n\n*/\n\nreg [LFSR_WIDTH-1:0] lfsr_mask_state[LFSR_WIDTH-1:0];\nreg [DATA_WIDTH-1:0] lfsr_mask_data[LFSR_WIDTH-1:0];\nreg [LFSR_WIDTH-1:0] output_mask_state[DATA_WIDTH-1:0];\nreg [DATA_WIDTH-1:0] output_mask_data[DATA_WIDTH-1:0];\n\nreg [LFSR_WIDTH-1:0] state_val = 0;\nreg [DATA_WIDTH-1:0] data_val = 0;\n\ninteger i, j, k;\n\ninitial begin\n    // init bit masks\n    for (i = 0; i < LFSR_WIDTH; i = i + 1) begin\n        lfsr_mask_state[i] = {LFSR_WIDTH{1'b0}};\n        lfsr_mask_state[i][i] = 1'b1;\n        lfsr_mask_data[i] = {DATA_WIDTH{1'b0}};\n    end\n    for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n        output_mask_state[i] = {LFSR_WIDTH{1'b0}};\n        if (i < LFSR_WIDTH) begin\n            output_mask_state[i][i] = 1'b1;\n        end\n        output_mask_data[i] = {DATA_WIDTH{1'b0}};\n    end\n\n    // simulate shift register\n    if (LFSR_CONFIG == \"FIBONACCI\") begin\n        // Fibonacci configuration\n        for (i = DATA_WIDTH-1; i >= 0; i = i - 1) begin\n            // determine shift in value\n            // current value in last FF, XOR with input data bit (MSB first)\n            state_val = lfsr_mask_state[LFSR_WIDTH-1];\n            data_val = lfsr_mask_data[LFSR_WIDTH-1];\n            data_val = data_val ^ (1 << i);\n\n            // add XOR inputs from correct indicies\n            for (j = 1; j < LFSR_WIDTH; j = j + 1) begin\n                if (LFSR_POLY & (1 << j)) begin\n                    state_val = lfsr_mask_state[j-1] ^ state_val;\n                    data_val = lfsr_mask_data[j-1] ^ data_val;\n                end\n            end\n\n            // shift\n            for (j = LFSR_WIDTH-1; j > 0; j = j - 1) begin\n                lfsr_mask_state[j] = lfsr_mask_state[j-1];\n                lfsr_mask_data[j] = lfsr_mask_data[j-1];\n            end\n            for (j = DATA_WIDTH-1; j > 0; j = j - 1) begin\n                output_mask_state[j] = output_mask_state[j-1];\n                output_mask_data[j] = output_mask_data[j-1];\n            end\n            output_mask_state[0] = state_val;\n            output_mask_data[0] = data_val;\n            if (LFSR_FEED_FORWARD) begin\n                // only shift in new input data\n                state_val = {LFSR_WIDTH{1'b0}};\n                data_val = 1 << i;\n            end\n            lfsr_mask_state[0] = state_val;\n            lfsr_mask_data[0] = data_val;\n        end\n    end else if (LFSR_CONFIG == \"GALOIS\") begin\n        // Galois configuration\n        for (i = DATA_WIDTH-1; i >= 0; i = i - 1) begin\n            // determine shift in value\n            // current value in last FF, XOR with input data bit (MSB first)\n            state_val = lfsr_mask_state[LFSR_WIDTH-1];\n            data_val = lfsr_mask_data[LFSR_WIDTH-1];\n            data_val = data_val ^ (1 << i);\n\n            // shift\n            for (j = LFSR_WIDTH-1; j > 0; j = j - 1) begin\n                lfsr_mask_state[j] = lfsr_mask_state[j-1];\n                lfsr_mask_data[j] = lfsr_mask_data[j-1];\n            end\n            for (j = DATA_WIDTH-1; j > 0; j = j - 1) begin\n                output_mask_state[j] = output_mask_state[j-1];\n                output_mask_data[j] = output_mask_data[j-1];\n            end\n            output_mask_state[0] = state_val;\n            output_mask_data[0] = data_val;\n            if (LFSR_FEED_FORWARD) begin\n                // only shift in new input data\n                state_val = {LFSR_WIDTH{1'b0}};\n                data_val = 1 << i;\n            end\n            lfsr_mask_state[0] = state_val;\n            lfsr_mask_data[0] = data_val;\n\n            // add XOR inputs at correct indicies\n            for (j = 1; j < LFSR_WIDTH; j = j + 1) begin\n                if (LFSR_POLY & (1 << j)) begin\n                    lfsr_mask_state[j] = lfsr_mask_state[j] ^ state_val;\n                    lfsr_mask_data[j] = lfsr_mask_data[j] ^ data_val;\n                end\n            end\n        end\n    end else begin\n        $error(\"Error: unknown configuration setting!\");\n        $finish;\n    end\n\n    // reverse bits if selected\n    if (REVERSE) begin\n        // reverse order\n        for (i = 0; i < LFSR_WIDTH/2; i = i + 1) begin\n            state_val = lfsr_mask_state[i];\n            data_val = lfsr_mask_data[i];\n            lfsr_mask_state[i] = lfsr_mask_state[LFSR_WIDTH-i-1];\n            lfsr_mask_data[i] = lfsr_mask_data[LFSR_WIDTH-i-1];\n            lfsr_mask_state[LFSR_WIDTH-i-1] = state_val;\n            lfsr_mask_data[LFSR_WIDTH-i-1] = data_val;\n        end\n        for (i = 0; i < DATA_WIDTH/2; i = i + 1) begin\n            state_val = output_mask_state[i];\n            data_val = output_mask_data[i];\n            output_mask_state[i] = output_mask_state[DATA_WIDTH-i-1];\n            output_mask_data[i] = output_mask_data[DATA_WIDTH-i-1];\n            output_mask_state[DATA_WIDTH-i-1] = state_val;\n            output_mask_data[DATA_WIDTH-i-1] = data_val;\n        end\n        // reverse bits\n        for (i = 0; i < LFSR_WIDTH; i = i + 1) begin\n            state_val = 0;\n            for (j = 0; j < LFSR_WIDTH; j = j + 1) begin\n                state_val[j] = lfsr_mask_state[i][LFSR_WIDTH-j-1];\n            end\n            lfsr_mask_state[i] = state_val;\n\n            data_val = 0;\n            for (j = 0; j < DATA_WIDTH; j = j + 1) begin\n                data_val[j] = lfsr_mask_data[i][DATA_WIDTH-j-1];\n            end\n            lfsr_mask_data[i] = data_val;\n        end\n        for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n            state_val = 0;\n            for (j = 0; j < LFSR_WIDTH; j = j + 1) begin\n                state_val[j] = output_mask_state[i][LFSR_WIDTH-j-1];\n            end\n            output_mask_state[i] = state_val;\n\n            data_val = 0;\n            for (j = 0; j < DATA_WIDTH; j = j + 1) begin\n                data_val[j] = output_mask_data[i][DATA_WIDTH-j-1];\n            end\n            output_mask_data[i] = data_val;\n        end\n    end\n\n    // for (i = 0; i < LFSR_WIDTH; i = i + 1) begin\n    //     $display(\"%b %b\", lfsr_mask_state[i], lfsr_mask_data[i]);\n    // end\nend\n\n// synthesis translate_off\n`define SIMULATION\n// synthesis translate_on\n\n`ifdef SIMULATION\n// \"AUTO\" style is \"REDUCTION\" for faster simulation\nparameter STYLE_INT = (STYLE == \"AUTO\") ? \"REDUCTION\" : STYLE;\n`else\n// \"AUTO\" style is \"LOOP\" for better synthesis result\nlocalparam STYLE_INT = (STYLE == \"AUTO\") ? \"LOOP\" : STYLE;\n`endif\n\ngenvar n;\n\ngenerate\n\nif (STYLE_INT == \"REDUCTION\") begin:reduce\n\n    // use Verilog reduction operator\n    // fast in iverilog\n    // significantly larger than generated code with ISE (inferred wide XORs may be tripping up optimizer)\n    // slightly smaller than generated code with Quartus\n    // --> better for simulation\n\n    for (n = 0; n < LFSR_WIDTH; n = n + 1) begin : loop1\n        assign state_out[n] = ^{(state_in & lfsr_mask_state[n]), (data_in & lfsr_mask_data[n])};\n    end\n    for (n = 0; n < DATA_WIDTH; n = n + 1) begin : loop2\n        assign data_out[n] = ^{(state_in & output_mask_state[n]), (data_in & output_mask_data[n])};\n    end\n\nend else if (STYLE_INT == \"LOOP\") begin:loop\n\n    // use nested loops\n    // very slow in iverilog\n    // slightly smaller than generated code with ISE\n    // same size as generated code with Quartus\n    // --> better for synthesis\n\n    reg [LFSR_WIDTH-1:0] state_out_reg = 0;\n    reg [DATA_WIDTH-1:0] data_out_reg = 0;\n\n    assign state_out = state_out_reg;\n    assign data_out = data_out_reg;\n\n    always @* begin\n        for (i = 0; i < LFSR_WIDTH; i = i + 1) begin\n            state_out_reg[i] = 0;\n            for (j = 0; j < LFSR_WIDTH; j = j + 1) begin\n                if (lfsr_mask_state[i][j]) begin\n                    state_out_reg[i] = state_out_reg[i] ^ state_in[j];\n                end\n            end\n            for (j = 0; j < DATA_WIDTH; j = j + 1) begin\n                if (lfsr_mask_data[i][j]) begin\n                    state_out_reg[i] = state_out_reg[i] ^ data_in[j];\n                end\n            end\n        end\n        for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n            data_out_reg[i] = 0;\n            for (j = 0; j < LFSR_WIDTH; j = j + 1) begin\n                if (output_mask_state[i][j]) begin\n                    data_out_reg[i] = data_out_reg[i] ^ state_in[j];\n                end\n            end\n            for (j = 0; j < DATA_WIDTH; j = j + 1) begin\n                if (output_mask_data[i][j]) begin\n                    data_out_reg[i] = data_out_reg[i] ^ data_in[j];\n                end\n            end\n        end\n    end\n\nend else begin:other\n\n    initial begin\n        $error(\"Error: unknown style setting!\");\n        $finish;\n    end\n\nend\n\nendgenerate\n\nendmodule\n"}
{"text": "\nmodule data_arrays_0_ext(\n  input RW0_clk,\n  input [8:0] RW0_addr,\n  input RW0_en,\n  input RW0_wmode,\n  input [31:0] RW0_wmask,\n  input [255:0] RW0_wdata,\n  output [255:0] RW0_rdata\n);\n\n/* name=data_arrays_0_ext, width=256, depth=512, mask_gran=8, mask_seg=32, ports=['mrw'] FPGA special case */\n\n  infer_bram  #(\n    .BRAM_SIZE(9),\n    .BRAM_WIDTH(256),\n    .IO_DAT_WIDTH(256))\n    my_block_ram (\n  .ram_clk(RW0_clk),    // input wire clka\n  .ram_en(RW0_en),      // input wire ena\n  .ram_we({RW0_wmask}),   // input wire [31 : 0] wea\n  .ram_addr(RW0_addr),  // input wire [8: 0] addra\n  .ram_wrdata(RW0_wdata),  // input wire [255 : 0] dina\n  .ram_rddata(RW0_rdata)  // output wire [255 : 0] douta\n  );\n  \nendmodule\n\nmodule tag_array_ext(\n  input RW0_clk,\n  input [5:0] RW0_addr,\n  input RW0_en,\n  input RW0_wmode,\n  input [3:0] RW0_wmask,\n  input [87:0] RW0_wdata,\n  output [87:0] RW0_rdata\n);\n\n  \n/* name=tag_array_ext, width=88, depth=64, mask_gran=22, mask_seg=4, ports=['mrw'] normal case */\n\n  reg reg_RW0_ren;\n  reg [5:0] reg_RW0_addr;\n  reg [87:0] ram [63:0];\n  `ifdef RANDOMIZE_MEM_INIT\n    integer initvar;\n    initial begin\n      #0.002 begin end\n      for (initvar = 0; initvar < 64; initvar = initvar+1)\n        ram[initvar] = {3 {$random}};\n      reg_RW0_addr = {1 {$random}};\n    end\n  `endif\n  integer i;\n  always @(posedge RW0_clk)\n    reg_RW0_ren <= RW0_en && !RW0_wmode;\n  always @(posedge RW0_clk)\n    if (RW0_en && !RW0_wmode) reg_RW0_addr <= RW0_addr;\n  always @(posedge RW0_clk)\n    if (RW0_en && RW0_wmode) begin\n      if (RW0_wmask[0]) ram[RW0_addr][21:0] <= RW0_wdata[21:0];\n      if (RW0_wmask[1]) ram[RW0_addr][43:22] <= RW0_wdata[43:22];\n      if (RW0_wmask[2]) ram[RW0_addr][65:44] <= RW0_wdata[65:44];\n      if (RW0_wmask[3]) ram[RW0_addr][87:66] <= RW0_wdata[87:66];\n    end\n  `ifdef RANDOMIZE_GARBAGE_ASSIGN\n  reg [95:0] RW0_random;\n  `ifdef RANDOMIZE_MEM_INIT\n    initial begin\n      #0.002 begin end\n      RW0_random = {$random, $random, $random};\n      reg_RW0_ren = RW0_random[0];\n    end\n  `endif\n  always @(posedge RW0_clk) RW0_random <= {$random, $random, $random};\n  assign RW0_rdata = reg_RW0_ren ? ram[reg_RW0_addr] : RW0_random[87:0];\n  `else\n  assign RW0_rdata = ram[reg_RW0_addr];\n  `endif\n\nendmodule\n\nmodule tag_array_0_ext(\n  input RW0_clk,\n  input [5:0] RW0_addr,\n  input RW0_en,\n  input RW0_wmode,\n  input [3:0] RW0_wmask,\n  input [83:0] RW0_wdata,\n  output [83:0] RW0_rdata\n);\n\n  \n/* name=tag_array_0_ext, width=84, depth=64, mask_gran=21, mask_seg=4, ports=['mrw'] normal case */\n\n  reg reg_RW0_ren;\n  reg [5:0] reg_RW0_addr;\n  reg [83:0] ram [63:0];\n  `ifdef RANDOMIZE_MEM_INIT\n    integer initvar;\n    initial begin\n      #0.002 begin end\n      for (initvar = 0; initvar < 64; initvar = initvar+1)\n        ram[initvar] = {3 {$random}};\n      reg_RW0_addr = {1 {$random}};\n    end\n  `endif\n  integer i;\n  always @(posedge RW0_clk)\n    reg_RW0_ren <= RW0_en && !RW0_wmode;\n  always @(posedge RW0_clk)\n    if (RW0_en && !RW0_wmode) reg_RW0_addr <= RW0_addr;\n  always @(posedge RW0_clk)\n    if (RW0_en && RW0_wmode) begin\n      if (RW0_wmask[0]) ram[RW0_addr][20:0] <= RW0_wdata[20:0];\n      if (RW0_wmask[1]) ram[RW0_addr][41:21] <= RW0_wdata[41:21];\n      if (RW0_wmask[2]) ram[RW0_addr][62:42] <= RW0_wdata[62:42];\n      if (RW0_wmask[3]) ram[RW0_addr][83:63] <= RW0_wdata[83:63];\n    end\n  `ifdef RANDOMIZE_GARBAGE_ASSIGN\n  reg [95:0] RW0_random;\n  `ifdef RANDOMIZE_MEM_INIT\n    initial begin\n      #0.002 begin end\n      RW0_random = {$random, $random, $random};\n      reg_RW0_ren = RW0_random[0];\n    end\n  `endif\n  always @(posedge RW0_clk) RW0_random <= {$random, $random, $random};\n  assign RW0_rdata = reg_RW0_ren ? ram[reg_RW0_addr] : RW0_random[83:0];\n  `else\n  assign RW0_rdata = ram[reg_RW0_addr];\n  `endif\n\nendmodule\n\nmodule data_arrays_0_0_ext(\n  input RW0_clk,\n  input [8:0] RW0_addr,\n  input RW0_en,\n  input RW0_wmode,\n  input [3:0] RW0_wmask,\n  input [127:0] RW0_wdata,\n  output [127:0] RW0_rdata\n);\n\n/* name=data_arrays_0_0_ext, width=128, depth=512, mask_gran=32, mask_seg=4, ports=['mrw'] FPGA special case */\n\n  infer_bram  #(\n    .BRAM_SIZE(9),\n    .BRAM_WIDTH(128),\n    .IO_DAT_WIDTH(128))\n    my_block_ram (\n  .ram_clk(RW0_clk),    // input wire clka\n  .ram_en(RW0_en),      // input wire ena\n  .ram_we({RW0_wmask[3],RW0_wmask[3],RW0_wmask[3],RW0_wmask[3],RW0_wmask[2],RW0_wmask[2],RW0_wmask[2],RW0_wmask[2],RW0_wmask[1],RW0_wmask[1],RW0_wmask[1],RW0_wmask[1],RW0_wmask[0],RW0_wmask[0],RW0_wmask[0],RW0_wmask[0]}),   // input wire [15 : 0] wea\n  .ram_addr(RW0_addr),  // input wire [8: 0] addra\n  .ram_wrdata(RW0_wdata),  // input wire [255 : 0] dina\n  .ram_rddata(RW0_rdata)  // output wire [255 : 0] douta\n  );\n\nendmodule\n\nmodule mem_ext(\n  input W0_clk,\n  input [24:0] W0_addr,\n  input W0_en,\n  input [63:0] W0_data,\n  input [7:0] W0_mask,\n  input R0_clk,\n  input [24:0] R0_addr,\n  input R0_en,\n  output reg [63:0] R0_data\n);\n\n  \n/* name=mem_ext, width=64, depth=33554432, mask_gran=8, mask_seg=8, ports=['mwrite', 'read'] normal case */\n\n  reg [63:0] ram [33554431:0];\n  integer i;\n  always @(posedge R0_clk)\n    if (R0_en) R0_data <= ram[R0_addr];\n  always @(posedge W0_clk)\n    if (W0_en) begin\n      if (W0_mask[0]) ram[W0_addr][7:0] <= W0_data[7:0];\n      if (W0_mask[1]) ram[W0_addr][15:8] <= W0_data[15:8];\n      if (W0_mask[2]) ram[W0_addr][23:16] <= W0_data[23:16];\n      if (W0_mask[3]) ram[W0_addr][31:24] <= W0_data[31:24];\n      if (W0_mask[4]) ram[W0_addr][39:32] <= W0_data[39:32];\n      if (W0_mask[5]) ram[W0_addr][47:40] <= W0_data[47:40];\n      if (W0_mask[6]) ram[W0_addr][55:48] <= W0_data[55:48];\n      if (W0_mask[7]) ram[W0_addr][63:56] <= W0_data[63:56];\n    end\n\nendmodule\n\nmodule mem_0_ext(\n  input W0_clk,\n  input [8:0] W0_addr,\n  input W0_en,\n  input [63:0] W0_data,\n  input [7:0] W0_mask,\n  input R0_clk,\n  input [8:0] R0_addr,\n  input R0_en,\n  output reg [63:0] R0_data\n);\n\n/* name=mem_0_ext, width=64, depth=512, mask_gran=8, mask_seg=8, ports=['mwrite', 'read'] normal case */\n\n  reg [63:0] ram [511:0];\n  integer i;\n  always @(posedge R0_clk)\n    if (R0_en) R0_data <= ram[R0_addr];\n  always @(posedge W0_clk)\n    if (W0_en) begin\n      if (W0_mask[0]) ram[W0_addr][7:0] <= W0_data[7:0];\n      if (W0_mask[1]) ram[W0_addr][15:8] <= W0_data[15:8];\n      if (W0_mask[2]) ram[W0_addr][23:16] <= W0_data[23:16];\n      if (W0_mask[3]) ram[W0_addr][31:24] <= W0_data[31:24];\n      if (W0_mask[4]) ram[W0_addr][39:32] <= W0_data[39:32];\n      if (W0_mask[5]) ram[W0_addr][47:40] <= W0_data[47:40];\n      if (W0_mask[6]) ram[W0_addr][55:48] <= W0_data[55:48];\n      if (W0_mask[7]) ram[W0_addr][63:56] <= W0_data[63:56];\n    end\n\nendmodule\n"}
{"text": "// See LICENSE for license details.\n`default_nettype none\n\nmodule framing_top\n  (\n  input wire rstn, msoc_clk, clk_rmii,\n  input wire [14:0] core_lsu_addr,\n  input wire [63:0] core_lsu_wdata,\n  input wire [7:0] core_lsu_be,\n  input wire       ce_d,\n  input wire   we_d,\n  input wire framing_sel,\n  output logic [63:0] framing_rdata,\n\n  //! Ethernet MAC PHY interface signals\noutput wire   o_edutrefclk     , // RMII clock out\ninput wire [1:0] i_edutrxd    ,\ninput wire  i_edutrx_dv       ,\ninput wire  i_edutrx_er       ,\noutput wire [1:0] o_eduttxd   ,\noutput wire o_eduttx_en      ,\noutput wire   o_edutmdc        ,\ninput wire i_edutmdio ,\noutput reg  o_edutmdio   ,\noutput reg  oe_edutmdio   ,\noutput wire   o_edutrstn    ,   \n\noutput reg eth_irq\n   );\n\nlogic [14:0] core_lsu_addr_dly;   \n\nlogic tx_enable_i;\nlogic [47:0] mac_address, rx_dest_mac;\nlogic  [7:0] mii_rx_data_i;\nlogic [10:0] tx_frame_addr, rx_length_axis[0:7], tx_packet_length;\nlogic [12:0] axis_tx_frame_size;\nlogic        ce_d_dly, avail;\nlogic [63:0] framing_rdata_pkt, framing_wdata_pkt;\nlogic [3:0] tx_enable_dly, firstbuf, nextbuf, lastbuf;\n\nreg [12:0] addr_tap, nxt_addr;\nreg [23:0] rx_byte, rx_nxt, rx_byte_dly;\nreg  [2:0] rx_pair;\nreg        mii_rx_byte_received_i, full, byte_sync, sync, irq_en, mii_rx_frame_i, tx_busy;\n\n   wire [7:0] m_enb = (we_d ? core_lsu_be : 8'hFF);\n   logic edutmdio, o_edutmdclk, o_edutrst, cooked, tx_enable_old, loopback, promiscuous;\n   logic [3:0] spare;   \n   logic [10:0] rx_addr_axis;\n   \n       /*\n        * AXI input\n        */\n        reg         tx_axis_tvalid;\n        reg         tx_axis_tvalid_dly;\n        reg \t    tx_axis_tlast;\n        wire [7:0]  tx_axis_tdata;\n        wire        tx_axis_tready;\n        wire        tx_axis_tuser = 0;\n   \n       /*\n        * AXI output\n        */\n       wire [7:0]  rx_axis_tdata;\n       wire        rx_axis_tvalid;\n       wire        rx_axis_tlast;\n       wire        rx_axis_tuser;\n   \n       /*\n        * GMII interface\n        */\n        wire        gmii_rx_er = loopback ? 1'b0 : i_edutrx_er;\n        wire [7:0]  gmii_txd;\n        wire        gmii_tx_en;\n        wire        gmii_tx_er;\n      /*\n        * AXIS Status\n        */\n         wire        axis_error_bad_frame;\n         wire        axis_error_bad_fcs;\n         wire [31:0] tx_fcs_reg_rev, rx_fcs_reg_rev;\n   \n   always @(posedge clk_rmii)\n     if (rstn == 1'b0)\n       begin\n\t  byte_sync <= 1'b0;\n\t  addr_tap <= 'H0;\n\t  rx_byte_dly <= {8{3'H1}};\n       end\n     else\n       begin\n\t  mii_rx_byte_received_i <= 0;\n\t  rx_pair <= loopback ? {o_eduttx_en,o_eduttxd} : {i_edutrx_dv,i_edutrxd[1:0]};\n\t  full = &addr_tap;\n\t  rx_nxt = {rx_pair,rx_byte[23:3]};\n\t  rx_byte <= rx_nxt;\n\t  if ((rx_nxt == {3'H7,{7{3'H5}}}) && (byte_sync == 0) && (nextbuf != (firstbuf+lastbuf)&15))\n            begin\n               byte_sync <= 1'b1;\n               mii_rx_byte_received_i <= 1'b1;\n               addr_tap <= {addr_tap[12:2],2'b00};\n            end\n\t  else\n            begin\n               if (full == 0)\n\t\t begin\n                    nxt_addr = addr_tap+1;\n                    addr_tap <= byte_sync ? nxt_addr : nxt_addr&3;\n\t\t end\n               mii_rx_byte_received_i <= &addr_tap[1:0];\n            end\n\t  if (mii_rx_byte_received_i)\n\t    begin\n\t       rx_byte_dly <= byte_sync ? rx_byte : {8{3'H1}};\n               mii_rx_frame_i <= rx_byte_dly[2];\n\t       mii_rx_data_i <= {rx_byte_dly[10:9],rx_byte_dly[7:6],rx_byte_dly[4:3],rx_byte_dly[1:0]};\n            end\n\t  if (rx_axis_tlast)\n            begin\n\t       byte_sync <= 1'b0;\n\t       addr_tap <= 'H0;\n            end\n       end\n\n   always @(posedge clk_rmii)\n       tx_enable_old <= tx_enable_i;\n\n   logic [1:0] rx_wr = rx_axis_tvalid << rx_addr_axis[2];\n   logic [15:0] douta;\n   assign tx_axis_tdata = douta >> {tx_frame_addr[2],3'b000};\n   \n   dualmem_widen8 RAMB16_inst_rx (\n                                    .clka(clk_rmii),              // Port A Clock\n                                    .clkb(msoc_clk),              // Port A Clock\n                                    .douta(),                     // Port A 8-bit Data Output\n                                    .addra({nextbuf[2:0],rx_addr_axis[10:3],rx_addr_axis[1:0]}),    // Port A 11-bit Address Input\n                                    .dina({rx_axis_tdata,rx_axis_tdata}), // Port A 8-bit Data Input\n                                    .ena(rx_axis_tvalid),         // Port A RAM Enable Input\n                                    .wea(rx_wr),                  // Port A Write Enable Input\n                                    .doutb(framing_rdata_pkt),    // Port B 32-bit Data Output\n                                    .addrb(core_lsu_addr[13:3]),  // Port B 9-bit Address Input\n                                    .dinb(core_lsu_wdata),        // Port B 32-bit Data Input\n                                    .enb(ce_d & framing_sel & core_lsu_addr[14]),\n                                                                  // Port B RAM Enable Input\n                                    .web(we_d ? {(|core_lsu_be[7:4]),(|core_lsu_be[3:0])} : 2'b0) // Port B Write Enable Input\n                                    );\n\n    dualmem_widen RAMB16_inst_tx (\n                                   .clka(~clk_rmii),             // Port A Clock\n                                   .clkb(msoc_clk),              // Port A Clock\n                                   .douta(douta),                // Port A 8-bit Data Output\n                                   .addra({1'b0,tx_frame_addr[10:3],tx_frame_addr[1:0]}),  // Port A 11-bit Address Input\n                                   .dina(16'b0),                 // Port A 8-bit Data Input\n                                   .ena(tx_axis_tvalid),         // Port A RAM Enable Input\n                                   .wea(2'b0),                  // Port A Write Enable Input\n                                   .doutb(framing_wdata_pkt),    // Port B 32-bit Data Output\n                                   .addrb(core_lsu_addr[11:3]),  // Port B 9-bit Address Input\n                                   .dinb(core_lsu_wdata), // Port B 32-bit Data Input\n                                   .enb(ce_d & framing_sel & (core_lsu_addr[14:12]==3'b001)),\n\t\t\t\t                                 // Port B RAM Enable Input\n                                   .web(we_d ? {(|core_lsu_be[7:4]),(|core_lsu_be[3:0])} : 2'b0) // Port B Write Enable Input\n                                   );\n\nassign o_edutmdc = o_edutmdclk;\nassign o_edutrefclk = clk_rmii; // was i_clk50_quad;\n\nalways @(posedge msoc_clk)\n  if (!rstn)\n    begin\n    core_lsu_addr_dly <= 0;\n    mac_address <= 48'H230100890702;\n    tx_packet_length <= 0;\n    tx_enable_dly <= 0;\n    cooked <= 1'b0;\n    loopback <= 1'b0;\n    spare <= 4'b0;\n    promiscuous <= 1'b0;\n    oe_edutmdio <= 1'b0;\n    o_edutmdio <= 1'b0;\n    o_edutmdclk <= 1'b0;\n    o_edutrst <= 1'b0;\n    sync <= 1'b0;\n    firstbuf <= 4'b0;\n    lastbuf <= 4'b0;\n    nextbuf <= 4'b0;\n    eth_irq <= 1'b0;\n    irq_en <= 1'b0;\n    ce_d_dly <= 1'b0;\n    tx_busy <= 1'b0;\n    avail = 1'b0;         \n    end\n  else\n    begin\n    core_lsu_addr_dly <= core_lsu_addr;\n    edutmdio <= i_edutmdio;\n    ce_d_dly <= ce_d;\n    avail = nextbuf != firstbuf;\n    eth_irq <= avail & irq_en; // make eth_irq go away immediately if irq_en is low\n    if (framing_sel&we_d&(core_lsu_addr[14:11]==4'b0001))\n      case(core_lsu_addr[6:3])\n        0: mac_address[31:0] <= core_lsu_wdata;\n        1: {irq_en,promiscuous,spare,loopback,cooked,mac_address[47:32]} <= core_lsu_wdata;\n        2: begin tx_enable_dly <= 10; tx_packet_length <= core_lsu_wdata; end /* tx payload size */\n        3: begin tx_enable_dly <= 0; tx_packet_length <= 0; end\n        4: begin {o_edutrst,oe_edutmdio,o_edutmdio,o_edutmdclk} <= core_lsu_wdata; end\n        5: begin lastbuf <= core_lsu_wdata[3:0]; end\n        6: begin firstbuf <= core_lsu_wdata[3:0]; end\n        default:;\n      endcase\n       if (byte_sync & (~rx_pair[2]) & ~sync)\n         begin\n         // check broadcast/multicast address\n\t     sync <= (rx_dest_mac[47:24]==24'h01005E) | (&rx_dest_mac) | (mac_address == rx_dest_mac) | promiscuous;\n         end\n       else if (~byte_sync)\n         begin\n         if (sync) nextbuf <= nextbuf + 1'b1;\n         sync <= 1'b0;\n         end\n       if (gmii_tx_en && tx_axis_tlast)\n         begin\n            tx_enable_dly <= 0;\n         end\n       else if (1'b1 == |tx_enable_dly)\n         begin\n         tx_busy <= 1'b1;\n         tx_enable_dly <= tx_enable_dly + 1'b1;\n         end\n       else if (~gmii_tx_en)\n         tx_busy <= 1'b0;         \n    end\n\nalways @(posedge clk_rmii)\n  if (!rstn)\n    begin\n    tx_enable_i <= 1'b0;\n    end\n  else\n    begin\n    if (gmii_tx_en && tx_axis_tlast)\n       begin\n       tx_enable_i <= 1'b0;\n       end\n    else if (1'b1 == &tx_enable_dly)\n         tx_enable_i <= 1'b1;\n    end\n\n   always @* casez({ce_d_dly,core_lsu_addr_dly[14:3]})\n    13'b10001????0000 : framing_rdata = mac_address[31:0];\n    13'b10001????0001 : framing_rdata = {irq_en, promiscuous, spare, loopback, cooked, mac_address[47:32]};\n    13'b1000?????0010 : framing_rdata = {tx_busy, 4'b0, tx_frame_addr, 5'b0, tx_packet_length};\n    13'b10001????0011 : framing_rdata = tx_fcs_reg_rev;\n    13'b10001????0100 : framing_rdata = {i_edutmdio,oe_edutmdio,o_edutmdio,o_edutmdclk};\n    13'b10001????0101 : framing_rdata = rx_fcs_reg_rev;\n    13'b10001????0110 : framing_rdata = {eth_irq, avail, lastbuf, nextbuf, firstbuf};\n    13'b10001????1??? : framing_rdata = rx_length_axis[core_lsu_addr_dly[5:3]];\n    13'b10010???????? : framing_rdata = framing_wdata_pkt;\n    13'b11??????????? : framing_rdata = framing_rdata_pkt;\n    default: framing_rdata = 'h0;\n    endcase\n\n   assign o_edutrstn = ~o_edutrst;\n  \n   parameter dly = 0;\n   \n   reg [1:0] \t    axis_eduttxd ;\n   reg \t\t    axis_eduttx_en;\n   reg [31:0] \t    tx_fcs_reg, rx_fcs_reg;\n   assign \t    tx_fcs_reg_rev = {tx_fcs_reg[0],tx_fcs_reg[1],tx_fcs_reg[2],tx_fcs_reg[3],\n                                          tx_fcs_reg[4],tx_fcs_reg[5],tx_fcs_reg[6],tx_fcs_reg[7],\n                                          tx_fcs_reg[8],tx_fcs_reg[9],tx_fcs_reg[10],tx_fcs_reg[11],\n                                          tx_fcs_reg[12],tx_fcs_reg[13],tx_fcs_reg[14],tx_fcs_reg[15],\n                                          tx_fcs_reg[16],tx_fcs_reg[17],tx_fcs_reg[18],tx_fcs_reg[19],\n                                          tx_fcs_reg[20],tx_fcs_reg[21],tx_fcs_reg[22],tx_fcs_reg[23],\n                                          tx_fcs_reg[24],tx_fcs_reg[25],tx_fcs_reg[26],tx_fcs_reg[27],\n                                          tx_fcs_reg[28],tx_fcs_reg[29],tx_fcs_reg[30],tx_fcs_reg[31]};\n   assign \t    rx_fcs_reg_rev = {rx_fcs_reg[0],rx_fcs_reg[1],rx_fcs_reg[2],rx_fcs_reg[3],\n                                          rx_fcs_reg[4],rx_fcs_reg[5],rx_fcs_reg[6],rx_fcs_reg[7],\n                                          rx_fcs_reg[8],rx_fcs_reg[9],rx_fcs_reg[10],rx_fcs_reg[11],\n                                          rx_fcs_reg[12],rx_fcs_reg[13],rx_fcs_reg[14],rx_fcs_reg[15],\n                                          rx_fcs_reg[16],rx_fcs_reg[17],rx_fcs_reg[18],rx_fcs_reg[19],\n                                          rx_fcs_reg[20],rx_fcs_reg[21],rx_fcs_reg[22],rx_fcs_reg[23],\n                                          rx_fcs_reg[24],rx_fcs_reg[25],rx_fcs_reg[26],rx_fcs_reg[27],\n                                          rx_fcs_reg[28],rx_fcs_reg[29],rx_fcs_reg[30],rx_fcs_reg[31]};\n   wire axis_tx_byte_sent = &axis_tx_frame_size[1:0];\n   \n   always @(posedge clk_rmii)\n     if (~rstn)\n       begin\n          rx_addr_axis <= 'b0;\n          tx_axis_tvalid <= 'b0;\n\t  axis_tx_frame_size <= 0;\n\t  axis_eduttxd <= 'b0;\n\t  axis_eduttx_en <= 'b0;\n\t  tx_axis_tvalid_dly <= 'b0;\n\t  tx_frame_addr <= 'b0;\n\t  tx_axis_tlast <= 'b0;\n          rx_dest_mac <= 'b0;\n       end\n     else\n       begin\n\t  axis_eduttx_en <= gmii_tx_en;\n\t  if (tx_enable_i & (tx_enable_old == 0))\n\t    begin\n\t       axis_tx_frame_size <= 'b0;\n\t       tx_frame_addr <= 'b0;\n\t    end\n\t  else if (1'b0 == &axis_tx_frame_size)\n            begin\n               axis_tx_frame_size <= axis_tx_frame_size + 1;\n\t       axis_eduttxd <= gmii_txd >> {axis_tx_frame_size[1:0],1'b0};\n            end\n\t  if (tx_axis_tready)\n\t    begin\n\t       tx_frame_addr <= tx_frame_addr + 1;\n\t       tx_axis_tlast <= (tx_frame_addr == tx_packet_length-2) & tx_axis_tvalid_dly;\n\t    end\n          if (axis_tx_byte_sent)\n\t    begin\n\t       tx_axis_tvalid <= tx_axis_tvalid_dly;\n\t       if (tx_enable_old)\n\t\t tx_axis_tvalid_dly <= 1'b1;\n\t       else if (~tx_axis_tlast)\n\t\t tx_axis_tvalid_dly <= 1'b0;\n\t    end\n\t  if (rx_axis_tvalid)\n            begin\n            rx_addr_axis <= rx_addr_axis + 1;\n            if (rx_addr_axis < 6)\n              rx_dest_mac <= {rx_dest_mac[39:0],rx_axis_tdata};\n            end\n\t  if (rx_axis_tlast)\n            begin\n\t        rx_length_axis[nextbuf[2:0]] <= rx_addr_axis + 1;\n\t        rx_addr_axis <= 'b0;\n            end\n      end\n \n   axis_gmii_rx gmii_rx_inst (\n       .clk(clk_rmii),\n       .rst(~rstn),\n       .mii_select(1'b0),\n       .clk_enable(mii_rx_byte_received_i),\n       .gmii_rxd(mii_rx_data_i),\n       .gmii_rx_dv(mii_rx_frame_i),\n       .gmii_rx_er(gmii_rx_er),\n       .output_axis_tdata(rx_axis_tdata),\n       .output_axis_tvalid(rx_axis_tvalid),\n       .output_axis_tlast(rx_axis_tlast),\n       .output_axis_tuser(rx_axis_tuser),\n       .error_bad_frame(axis_error_bad_frame),\n       .error_bad_fcs(axis_error_bad_fcs),\n       .fcs_reg(rx_fcs_reg)\n   );\n   \n   axis_gmii_tx #(\n       .ENABLE_PADDING(1),\n       .MIN_FRAME_LENGTH(64)\n   )\n   gmii_tx_inst (\n       .clk(clk_rmii),\n       .rst(~rstn),\n       .mii_select(1'b0),\n       .clk_enable(axis_tx_byte_sent),\n       .input_axis_tdata(tx_axis_tdata),\n       .input_axis_tvalid(tx_axis_tvalid),\n       .input_axis_tready(tx_axis_tready),\n       .input_axis_tlast(tx_axis_tlast),\n       .input_axis_tuser(tx_axis_tuser),\n       .gmii_txd(gmii_txd),\n       .gmii_tx_en(gmii_tx_en),\n       .gmii_tx_er(gmii_tx_er),\n       .ifg_delay(8'd12),\n       .fcs_reg(tx_fcs_reg)\n   );\n\n   assign o_eduttxd = axis_eduttxd;\n   assign o_eduttx_en = axis_eduttx_en;\n   \nendmodule // framing_top\n`default_nettype wire\n"}
{"text": "/*\nCopyright 2015-2017 University of Cambridge\nCopyright and related rights are licensed under the Solderpad Hardware\nLicense, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\ncompliance with the License. You may obtain a copy of the License at\nhttp://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\nor agreed to in writing, software, hardware and materials distributed under\nthis License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\nCONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n*/\n\n// A simple monitor (LCD display) driver with glass TTY behaviour in text mode\n\nmodule fstore2(\n               input wire         pixel2_clk,\n               output reg [7:0]   red,\n               output reg [7:0]   green,\n               output reg [7:0]   blue,\n\n               output wire        vsyn,\n               output reg         hsyn,\n\n               output wire [63:0] doutb,\n               input wire  [63:0] dinb,\n               input wire  [14:0] addrb,\n               input wire  [7:0]  web,\n               input wire         enb,\n               input wire         clk_data,\n               input wire         irst\n               );\n\n   parameter rwidth = 14;\n\n   integer                       i;\n   \n   wire                          m0 = 1'b0;\n   \n   reg                           hstart, hstop, vstart, vstop;\n   reg [12:6]                    offhreg, offhreg1;\n   reg [5:3]                     offpixel, offpixel1;\n   reg [11:5]                    offvreg;\n   reg [4:1]                     vrow;\n   reg [4:0]                     divreg, divreg0, hdiv;\n   reg [6:0]                     xcursor, ycursor, xcursor0, ycursor0, cursorvreg, cursorvreg0;\n   reg [11:0]                    hstartreg, hsynreg, hstopreg, vstartreg,\n                                 vstopreg, vpixstartreg,\n                                 vpixstopreg, hpixstartreg, hpixstopreg, hpixreg, vpixreg,\n                                 hstartreg0, hsynreg0, hstopreg0, vstartreg0,\n                                 vstopreg0, vpixstartreg0,\n                                 vpixstopreg0, hpixstartreg0, hpixstopreg0, hpixreg0, vpixreg0;\n   wire [63:0]                   dout, dout0;\n   wire [15:0]                   dout16 = dout >> {offhreg1[7:6],4'b0000};\n   reg [15:0]                    dout16_1;\n   wire                          cursor = (offvreg[10:5] == ycursor[6:0]) && (offhreg[12:6] == xcursor[6:0]) && (vrow==cursorvreg);\n   \n   // 100 MHz / 2100 is 47.6kHz.  Divide by further 788 to get 60.4 Hz.\n   // Aim for 1024x768 non interlaced at 60 Hz.  \n   \n   reg [11:0]                    hreg, vreg;\n\n   reg                           bitmapped_pixel, bitmapped_pixel1, addrb14;\n   \n   reg [7:0]                     red_in, green_in, blue_in;\n\n   reg [23:0]                    palette0[0:15], palette[0:15];\n                  \n   dualmem ram1(.clka(pixel2_clk),\n                .dina(8'b0), .addra({offvreg[10:5],offhreg[12:8]}), .wea(8'b0), .douta(dout), .ena(1'b1),\n                .clkb(~clk_data), .dinb(dinb), .addrb(addrb[13:3]), .web(web), .doutb(dout0), .enb(enb&~addrb[14]));\n\n   always @(posedge clk_data)\n   if (irst)\n     begin\n        cursorvreg0 <= 10;\n        xcursor0 <= 0;\n        ycursor0 <= 32;\n        hstartreg0 <= 2048;\n        hsynreg0 <= 2048+20;\n        hstopreg0 <= 2100-1;\n        vstartreg0 <= 768;\n        vstopreg0 <= 768+19;\n        vpixstartreg0 <= 16;\n        vpixstopreg0 <= 16+768;\n        hpixstartreg0 <= 128*3;\n        hpixstopreg0 <= 128*3+256*6;\n        hpixreg0 <= 5;\n        vpixreg0 <= 11;\n        divreg0 <= 1;\n     end\n   else\n     begin\n        addrb14 <= addrb[14];\n        if (web && enb && addrb[14] && ~addrb[13])\n          casez (addrb[8:3])\n            6'd1: cursorvreg0 <= dinb[6:0];\n            6'd2: xcursor0 <= dinb[6:0];\n            6'd3: ycursor0 <= dinb[6:0];\n            6'd4: hstartreg0 <= dinb[11:0];\n            6'd5: hsynreg0 <= dinb[11:0];\n            6'd6: hstopreg0 <= dinb[11:0];\n            6'd7: vstartreg0 <= dinb[11:0];\n            6'd8: vstopreg0 <= dinb[11:0];\n            6'd11: vpixstartreg0 <= dinb[11:0];\n            6'd12: vpixstopreg0 <= dinb[11:0];\n            6'd13: hpixstartreg0 <= dinb[11:0];\n            6'd14: hpixstopreg0 <= dinb[11:0];\n            6'd15: hpixreg0 <= dinb[11:0];\n            6'd16: vpixreg0 <= dinb[11:0];\n            6'd17: divreg0 <= dinb[3:0];\n            default:;\n          endcase\n        if (web && enb && addrb[14] && ~addrb[13] && addrb[8])\n            palette0[addrb[6:3]] <= dinb[23:0];\n     end\n\n`ifdef LASTMSG\n   \n   parameter msgwid = 32;\n   \n   reg [msgwid*8-1:0]            last_msg;\n               \n   reg [7:0]                     crnt, msgi;\n                     \n   // This section generates a message in simulation, it gets trimmed in hardware.\n   always @(posedge clk_data)\n     if (irst)\n       last_msg = {msgwid{8'h20}};\n     else\n     begin\n        if (enb) for (msgi = 0; msgi < 8; msgi=msgi+1)\n          if (web[msgi])\n            begin\n               crnt = dinb >> msgi*8;\n               $write(\"%c\", crnt);\n               if (crnt==10 || crnt==13) $fflush();\n               last_msg = {last_msg[msgwid*8-9:0],crnt};\n            end\n     end\n`endif\n   \n   always @(posedge pixel2_clk) // or posedge reset) // JRRK - does this need async ?\n   if (irst)\n     begin\n        hreg <= 0;\n        hstart <= 0;\n        hsyn <= 0;\n        hstop <= 0;\n        vreg <= 0;\n        vstart <= 0;\n        vstop <= 0;\n        red <= 0;\n        green <= 0;\n        blue <= 0;\n        bitmapped_pixel <= 0;\n        offhreg <= 0;\n        offvreg <= 0;\n        offpixel <= 0;\n        vrow <= 0;\n     end\n   else\n     begin\n        offhreg1 <= offhreg;\n        offpixel1 <= offpixel;\n        dout16_1 <= dout16;\n        bitmapped_pixel1 <= bitmapped_pixel;\n        cursorvreg <= cursorvreg0;\n\txcursor <= xcursor0;\n\tycursor <= ycursor0;\n        hstartreg <= hstartreg0;\n        hsynreg <= hsynreg0;\n        hstopreg <= hstopreg0;\n        vstartreg <= vstartreg0;\n        vstopreg <= vstopreg0;\n        vpixstartreg <= vpixstartreg0;\n        vpixstopreg <= vpixstopreg0;\n        hpixstartreg <= hpixstartreg0;\n        hpixstopreg <= hpixstopreg0;\n        hpixreg <= hpixreg0;\n        vpixreg <= vpixreg0;\n        divreg <= divreg0;\n        for (i = 0; i < 16; i=i+1)\n          palette[i] = palette0[i];\n        hreg <= (hstop) ? 0: hreg + 1;\n        hstart <= hreg == hstartreg;      \n        if (hstart) hsyn <= 1; else if (hreg == hsynreg) hsyn <= 0;\n        hstop <= hreg == hstopreg;\n        if (hstop) begin\n           if (vstop)\n             begin\n                vreg <= 0;\n             end\n           else\n             vreg <= vreg + 1;\n           vstart <= vreg == vstartreg;\n           vstop <= vreg == vstopreg;\n        end\n\n        red <= red_in;         \n        blue <= blue_in;\n        green <= green_in;\n\n        if (vreg >= vpixstartreg && vreg < vpixstopreg)\n          begin\n             if (hreg >= hpixstartreg && hreg < hpixstopreg)\n               begin\n                  if (hdiv == divreg)\n                    begin\n                       if (offpixel == hpixreg)\n                         begin\n                            offpixel <= 0;\n                            offhreg <= offhreg+1;\n                         end\n                       else\n                         offpixel <= offpixel+1;\n                       hdiv <= 0;\n                    end\n                  else\n                    hdiv = hdiv + 1;\n                  bitmapped_pixel <= 1;\n               end\n             else\n               begin\n                  hdiv <= 0;\n                  offpixel <= 0;\n                  offhreg <= 0;\n                  if (hstop & vreg[0])\n                    begin\n                       if (vrow == vpixreg)\n                         begin\n                            vrow <= 0;\n                            offvreg <= offvreg+1;\n                         end\n                       else\n                         begin\n                            vrow <= vrow + 1;\n                         end\n                    end\n                  bitmapped_pixel <= 0;\n               end\n          end\n        else\n          begin\n             vrow <= 0;\n             offvreg <= 0;\n             bitmapped_pixel <= 0;\n          end\n\n     end\n\n   assign vsyn = vstart;\n\n   wire [7:0] pixels_out, fout;\n   reg [3:0]  faddr;\n\n   always @(web)\n     case(web)\n       8'h01: faddr = 0;\n       8'h02: faddr = 1;\n       8'h04: faddr = 2;\n       8'h08: faddr = 3;\n       8'h10: faddr = 4;\n       8'h20: faddr = 5;\n       8'h40: faddr = 6;\n       8'h80: faddr = 7;\n       default: faddr = 8;\n   endcase // case (web)\n   \n   assign doutb = addrb14 ? {fout,fout,fout,fout,fout,fout,fout,fout} : dout0;\n   wire [7:0] font_in = dinb >> {faddr[2:0],3'b000};\n                  \n   chargen_7x5_rachel the_rachel(\n    .clk(pixel2_clk),\n    .ascii(dout16[7:0]),\n    .row(vrow),\n    .pixels_out(pixels_out),\n    .font_clk(~clk_data),\n    .font_out(fout),\n    .font_addr({addrb[10:3],faddr[2:0]}),\n    .font_in(font_in),\n    .font_en(enb & addrb[14] & addrb[13]),\n    .font_we(~faddr[3]));\n   \n   wire       pixel = pixels_out[3'd7 ^ offpixel1] || cursor;\n\n   always @(dout16_1 or pixel or bitmapped_pixel1)\n     {red_in,green_in,blue_in} = bitmapped_pixel1 ? palette[pixel ? dout16_1[11:8]: dout16_1[14:12]] : 24'b0;\n   \nendmodule\n"}
{"text": "// See LICENSE.SiFive for license details.\n\nmodule JTAGDummy(\n   // LED and DIP switch\n  output [7:0]  o_led,\n  input         clk_p,\n  input         rst_top\n  );\n    \n     wire          rxd;\n     wire          txd;\n     wire          rts;\n     wire          cts;\n     wire         flash_ss;\n     wire [3:0]   flash_io;\n     wire         spi_cs;\n     wire         spi_sclk;\n     wire         spi_mosi;\n     wire         spi_miso;\n     // 4-bit full SD interface\n     wire         sd_sclk;\n     wire         sd_detect;\n     wire [3:0]   sd_dat;\n     wire         sd_cmd;\n     wire         sd_reset;\n  \n     // LED and DIP switch\n     wire [7:0]  o_led;\n     wire  [3:0]  i_dip;\n  \n     // push button array\n     wire         GPIO_SW_C;\n     wire         GPIO_SW_W;\n     wire         GPIO_SW_E;\n     wire         GPIO_SW_N;\n     wire         GPIO_SW_S;\n  \n     //keyboard\n     wire         PS2_CLK;\n     wire         PS2_DATA;\n  \n    // display\n     wire        VGA_HS_O;\n     wire        VGA_VS_O;\n     wire [3:0]  VGA_RED_O;\n     wire [3:0]  VGA_BLUE_O;\n     wire [3:0]  VGA_GREEN_O;\n   //! Ethernet MAC PHY interface signals\n   wire [1:0]   i_erxd; // RMII receive data\n   wire         i_erx_dv; // PHY data valid\n   wire         i_erx_er; // PHY coding error\n   wire         i_emdint; // PHY interrupt in active low\n   wire         o_erefclk; // RMII clock out\n   wire  [1:0]  o_etxd; // RMII transmit data\n   wire         o_etx_en; // RMII transmit enable\n   wire         o_emdc; // MDIO clock\n   wire         io_emdio; // MDIO wire\n   wire         o_erstn; // PHY reset active low\n\n`ifdef verilator\n  wire         clk = clk_p;\n  wire         rst = ~rst_top;\n`else\n  wire clk_locked;\n  wire         clk;\n  wire         rst = ~clk_locked;\n  \n   clk_wiz_2 clk_gen\n     (\n      .clk_in1       ( clk_p         ), // 100 MHz onboard\n      .clk_out1      ( clk           ), // 25 MHz\n      .resetn        ( rst_top       ),\n      .locked        ( clk_locked    )\n      );\n`endif // !`ifdef verilator\n\n   chip_top\n   DUT\n     (\n      .*,\n      .clk_p        ( clk       ),\n      .clk_n        ( !clk      ),\n      .rst_top      ( rst       )\n      );\n \nendmodule\n"}
{"text": "module jtag_addr(output reg [1:0] OP, output reg INC, output reg [31:0] ADDR,\ninput wire CAPTURE, RESET, RUNTEST, SEL, SHIFT, TDI, TMS, UPDATE, TCK,\noutput wire TDO);\n\nparameter wid = 35;\n\nreg [wid-1:0] SR;\n\nassign TDO = SR[0];\n   \nalways @(posedge TCK)\n       begin\n       if (RESET)\n           begin\n           SR = 0;\n           WR = 0;\n\t   INC = 0;\n           ADDR = 0;\n           end\n       else if (SEL)\n           begin\n           if (CAPTURE)\n               begin\n               SR = {INC,OP,ADDR};\n               end\n           if (UPDATE)\n               begin\n                  {INC,OP,ADDR} = SR;\n               end\n           if (SHIFT)\n             begin\n                SR = {TDI,SR[wid-1:1]};\n               end\n           end\n       end\n\nendmodule\n"}
{"text": "`timescale 1ns / 1ps\n`default_nettype none\n\nmodule jtag_dummy(\n    output wire [1:0] OP,\n    output wire [31:0] TO_MEM,\n    output wire [31:0] ADDR,\n    input wire [31:0] FROM_MEM,\n    output wire TCK,\n    output wire TCK2,\n    output wire RESET,\n    output wire RUNTEST);\n\nwire CAPTURE, DRCK, SEL, SHIFT, TDI, TDO, TMS, UPDATE, TCK_unbuf;\nwire CAPTURE2, DRCK2, RESET2, RUNTEST2, SEL2, SHIFT2, TDI2, TDO2, TMS2, UPDATE2;\nwire INC;\nwire [1:0] OP;\nwire [31:0] ADDR0;\n   \nBUFH jtag_buf(.I(TCK_unbuf), .O(TCK));\n\n   // BSCANE2: Boundary-Scan User Instruction\n   //          Artix-7\n   // Xilinx HDL Language Template, version 2017.1\n\n   BSCANE2 #(\n      .JTAG_CHAIN(1)  // Value for USER command.\n   )\n   BSCANE2_inst (\n      .CAPTURE(CAPTURE), // 1-bit output: CAPTURE output from TAP controller.\n      .DRCK(DRCK),       // 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or\n                         // SHIFT are asserted.\n\n      .RESET(RESET),     // 1-bit output: Reset output for TAP controller.\n      .RUNTEST(RUNTEST), // 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.\n      .SEL(SEL),         // 1-bit output: USER instruction active output.\n      .SHIFT(SHIFT),     // 1-bit output: SHIFT output from TAP controller.\n      .TCK(TCK_unbuf),   // 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.\n      .TDI(TDI),         // 1-bit output: Test Data Input (TDI) output from TAP controller.\n      .TMS(TMS),         // 1-bit output: Test Mode Select output. Fabric connection to TAP.\n      .UPDATE(UPDATE),   // 1-bit output: UPDATE output from TAP controller\n      .TDO(TDO)    // 1-bit input: Test Data Output (TDO) input for USER function.\n   );\n\n   BSCANE2 #(\n      .JTAG_CHAIN(2)  // Value for USER command.\n   )\n   BSCANE2_inst2 (\n      .CAPTURE(CAPTURE2), // 1-bit output: CAPTURE output from TAP controller.\n      .DRCK(DRCK2),       // 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or\n                         // SHIFT are asserted.\n\n      .RESET(RESET2),     // 1-bit output: Reset output for TAP controller.\n      .RUNTEST(RUNTEST2), // 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.\n      .SEL(SEL2),         // 1-bit output: USER instruction active output.\n      .SHIFT(SHIFT2),     // 1-bit output: SHIFT output from TAP controller.\n      .TCK(TCK2),   // 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.\n      .TDI(TDI2),         // 1-bit output: Test Data Input (TDI) output from TAP controller.\n      .TMS(TMS2),         // 1-bit output: Test Mode Select output. Fabric connection to TAP.\n      .UPDATE(UPDATE2),   // 1-bit output: UPDATE output from TAP controller\n      .TDO(TDO2)    // 1-bit input: Test Data Output (TDO) input for USER function.\n   );\n\njtag_rom rom1(\n.WREN(WREN),\n.TO_MEM(TO_MEM),\n.ADDR(ADDR),\n.FROM_MEM(FROM_MEM),\n.INC(INC),\n.OP(OP),\n.OPIN(OPIN),\n.ADDR0(ADDR0),\n.TDO(TDO),\t \n.CAPTURE(CAPTURE), \n.RESET(RESET), \n.RUNTEST(RUNTEST), \n.SEL(SEL), \n.SHIFT(SHIFT), \n.TDI(TDI), \n.TMS(TMS), \n.UPDATE(UPDATE), \n.TCK(TCK)\n);\n\njtag_addr addr1(\n.DBG(DBG),\n.INC(INC),\n.OP(OP),\n.ADDR(ADDR0),\n.TDO(TDO2),\t \n.CAPTURE(CAPTURE2), \n.RESET(RESET2), \n.RUNTEST(RUNTEST2), \n.SEL(SEL2), \n.SHIFT(SHIFT2), \n.TDI(TDI2), \n.TMS(TMS2), \n.UPDATE(UPDATE2), \n.TCK(TCK)\n);\n\t\t\t\t\nendmodule\n"}
{"text": "module jtag_rom(input wire INC, input wire [1:0] OPIN, input wire [31:0] ADDR0,\ninput wire CAPTURE, RESET, RUNTEST, SEL, SHIFT, TDI, TMS, UPDATE, TCK,\noutput wire TDO, output reg [1:0] OP, output reg VALID, output reg [31:0] TO_MEM, output reg [31:0] ADDR,\ninput wire [31:0] FROM_MEM );\n\nparameter dataw = 32;\n\nreg [dataw-1:0] SR;\n\nreg  INCEN;\nreg [7:0] CNT;\n\nassign TDO = SR[0];\n\t     \nalways @(posedge TCK)\n       begin\n       if (RESET)\n           begin\n           CNT = 0;\n           SR = 0;\n           WREN = 0;\n           TO_MEM = 0;\n\t       ADDR = 0;\n\t       INCEN = 1'b0;\n           end\n       else if (SEL)\n           begin\n           if (CAPTURE)\n               begin\n               CNT = 0;\n               SR = ADDR0;\n\t           OP = OPIN;\n\t           INCEN = 1'b0;\n\t           ADDR = ADDR0;\n               end\n           if (UPDATE)\n               begin\n                  if (WR)\n                      TO_MEM = SR;\n                  WREN = WR;\n        \t\t  INCEN = 1'b0;\n                  CNT = 0;\n               end\n           if (SHIFT)\n             begin\n\t\t     ADDR = ADDR + {INCEN,2'b0};\n\t\t     INCEN = 1'b0;\n             VALID = 1'b0;\n             SR = {TDI,SR[dataw-1:1]};\n             CNT = CNT + 1;\n             if (CNT == dataw)\n                  begin\n                     if (WR)\n                        TO_MEM = SR;\n\t\t             else\n\t\t                SR = FROM_MEM;\n                     VALID = 1'b1;\n                     INCEN = INC;\n                     CNT = 0;\n                  end\n               end\n           end\n       end\n      // End of BSCANE2_inst instantiation\n\nendmodule // unmatched end(function|task|module|primitive|interface|package|class|clocking)\n"}
{"text": "// See LICENSE.SiFive for license details.\n\n/*\n * TCP/IP controlled VPI JTAG Interface.\n * Based on Julius Baxter's work on jp_vpi.c\n *\n * Copyright (C) 2012 Franck Jullien, <franck.jullien@gmail.com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation  and/or other materials provided with the distribution.\n * 3. Neither the names of the copyright holders nor the names of any\n *    contributors may be used to endorse or promote products derived from this\n *    software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n`define CMD_RESET\t\t0\n`define CMD_TMS_SEQ\t\t1\n`define CMD_SCAN_CHAIN\t\t2\n`define CMD_SCAN_CHAIN_FLIP_TMS\t3\n`define CMD_STOP_SIMU\t\t4\n\nmodule JTAGVPI\n#(\tparameter DEBUG_INFO = 0,\n\tparameter TP = 1,\n\tparameter TCK_HALF_PERIOD = 2,// 50, // Clock half period (Clock period = 100 ns => 10 MHz)\n        parameter  CMD_DELAY = 2 // 1000\n)   \n(\n\toutput jtag_TMS,\n\toutput jtag_TCK,\n\toutput jtag_TDI,\n\tinput  jtag_TDO_data,\n        input  jtag_TDO_driven,\n\n\tinput  enable,\n\tinput  init_done);\n\n   reg                  tms;\n   reg                  tck;\n   reg                  tdi;\n   wire                 tdo;\n   \n   assign jtag_TMS = tms;\n   assign jtag_TCK = tck;\n   assign jtag_TDI = tdi;\n   assign tdo = jtag_TDO_driven ? jtag_TDO_data : 1'bz;\n      \ninteger\t\tcmd;\ninteger\t\tlength;\ninteger\t\tnb_bits;\n\nreg [31:0] \tbuffer_out [0:4095];   // Data storage from the jtag server\nreg [31:0] \tbuffer_in  [0:4095];   // Data storage to the jtag server\n\ninteger\t\tflip_tms;\n\nreg [31:0]\tdata_out;\nreg [31:0]\tdata_in;\n\ninteger\t\tdebug;\n\ninitial\nbegin\n\ttck\t\t<= #TP 1'b0;\n\ttdi\t\t<= #TP 1'bz;\n\ttms\t\t<= #TP 1'b0;\n\n\tdata_out\t<= 32'h0;\n\tdata_in\t\t<= 32'h0;\n\n\t// Insert a #delay here because we need to\n\t// wait until the PC isn't pointing to flash anymore\n\t// (this is around 20k ns if the flash_crash boot code\n\t// is being booted from, else much bigger, around 10mil ns)\n\twait(init_done)\n\t\tif($test$plusargs(\"jtag_vpi_enable\")) main;\nend\n\ntask main;\nbegin\n\t$display(\"JTAG debug module with VPI interface enabled\\n\");\n\n\treset_tap;\n\tgoto_run_test_idle_from_reset;\n\n\twhile (1) begin\n\n\t\t// Check for incoming command\n\t\t// wait until a command is sent\n\t\t// poll with a delay here\n\t\tcmd = -1;\n\n\t\twhile (cmd == -1)\n\t\tbegin\n                     #CMD_DELAY $check_for_command(cmd, length, nb_bits, buffer_out);\n\t\tend\n\n\t\t// now switch on the command\n\t\tcase (cmd)\n\n\t\t`CMD_RESET :\n\t\tbegin\n\t\t\tif (DEBUG_INFO)\n\t\t\t\t$display(\"%t ----> CMD_RESET %h\\n\", $time, length);\n\t\t\treset_tap;\n\t\t\tgoto_run_test_idle_from_reset;\n\t\tend\n\n\t\t`CMD_TMS_SEQ :\n\t\tbegin\n\t\t\tif (DEBUG_INFO)\n\t\t\t\t$display(\"%t ----> CMD_TMS_SEQ\\n\", $time);\n\t\t\tdo_tms_seq;\n\t\tend\n\n\t\t`CMD_SCAN_CHAIN :\n\t\tbegin\n\t\t\tif (DEBUG_INFO)\n\t\t\t\t$display(\"%t ----> CMD_SCAN_CHAIN\\n\", $time);\n\t\t\tflip_tms = 0;\n\t\t\tdo_scan_chain;\n\t\t\t$send_result_to_server(length, buffer_in);\n\t\tend\n\n\t\t`CMD_SCAN_CHAIN_FLIP_TMS :\n\t\tbegin\n\t\t\tif(DEBUG_INFO)\n\t\t\t\t$display(\"%t ----> CMD_SCAN_CHAIN\\n\", $time);\n\t\t\tflip_tms = 1;\n\t\t\tdo_scan_chain;\n\t\t\t$send_result_to_server(length, buffer_in);\n\t\tend\n\n\t\t`CMD_STOP_SIMU :\n\t\tbegin\n\t\t\tif(DEBUG_INFO)\n\t\t\t\t$display(\"%t ----> End of simulation\\n\", $time);\n\t\t\t$finish();\n\t\tend\n\n\t\tdefault:\n\t\tbegin\n\t\t\t$display(\"Somehow got to the default case in the command case statement.\");\n\t\t\t$display(\"Command was: %x\", cmd);\n\t\t\t$display(\"Exiting...\");\n\t\t\t$finish();\n\t\tend\n\n\t\tendcase // case (cmd)\n\n\tend // while (1)\nend\n\nendtask // main\n\n\n// Generation of the TCK signal\ntask gen_clk;\ninput [31:0] number;\ninteger i;\n\nbegin\n\tfor (i = 0; i < number; i = i + 1)\n\tbegin\n\t\t#TCK_HALF_PERIOD tck <= 1;\n\t\t#TCK_HALF_PERIOD tck <= 0;\n\tend\nend\n\nendtask\n\n// TAP reset\ntask reset_tap;\nbegin\n\tif (DEBUG_INFO)\n\t\t$display(\"(%0t) Task reset_tap\", $time);\n\ttms <= #1 1'b1;\n\tgen_clk(5);\nend\n\nendtask\n\n\n// Goes to RunTestIdle state\ntask goto_run_test_idle_from_reset;\nbegin\n\tif (DEBUG_INFO)\n\t\t$display(\"(%0t) Task goto_run_test_idle_from_reset\", $time);\n\ttms <= #1 1'b0;\n\tgen_clk(1);\nend\n\nendtask\n\n// \ntask do_tms_seq;\n\ninteger\t\ti,j;\nreg [31:0]\tdata;\ninteger\t\tnb_bits_rem;\ninteger\t\tnb_bits_in_this_byte;\n\nbegin\n\tif (DEBUG_INFO)\n\t\t$display(\"(%0t) Task do_tms_seq of %d bits (length = %d)\", $time, nb_bits, length);\n\n\t// Number of bits to send in the last byte\n\tnb_bits_rem = nb_bits % 8;\n\n\tfor (i = 0; i < length; i = i + 1)\n\tbegin\n\t\t// If we are in the last byte, we have to send only\n\t\t// nb_bits_rem bits. If not, we send the whole byte.\n\t\tnb_bits_in_this_byte = (i == (length - 1)) ? nb_bits_rem : 8;\n\n\t\tdata = buffer_out[i];\n\t\tfor (j = 0; j < nb_bits_in_this_byte; j = j + 1)\n\t\tbegin\n\t\t\ttms <= #1 1'b0;\n\t\t\tif (data[j] == 1) begin\n\t\t\t\ttms <= #1 1'b1;\n                        end\n\t\t\tgen_clk(1);\n\t\tend\n\tend\n\n\ttms <= #1 1'b0;\nend\n\nendtask\n\n\n// \ntask do_scan_chain;\n\ninteger\t\t_bit;\ninteger\t\tnb_bits_rem;\ninteger\t\tnb_bits_in_this_byte;\ninteger\t\tindex;\n\nbegin\n\tif(DEBUG_INFO)\n\t\t$display(\"(%0t) Task do_scan_chain of %d bits (length = %d)\", $time, nb_bits, length);\n\n\t// Number of bits to send in the last byte\n\tnb_bits_rem = nb_bits % 8;\n\n\tfor (index = 0; index < length; index = index + 1)\n\tbegin\n\t\t// If we are in the last byte, we have to send only\n\t\t// nb_bits_rem bits if it's not zero.\n\t\t// If not, we send the whole byte.\n\t\tnb_bits_in_this_byte = (index == (length - 1)) ? ((nb_bits_rem == 0) ? 8 : nb_bits_rem) : 8;\n\n\t\tdata_out = buffer_out[index];\n\t\tfor (_bit = 0; _bit < nb_bits_in_this_byte; _bit = _bit + 1)\n\t\tbegin\n\t\t\ttdi <= 1'b0;\n\t\t\tif (data_out[_bit] == 1'b1) begin\n\t\t\t\ttdi <= 1'b1;\n\t\t\tend\n\n\t\t\t// On the last bit, set TMS to '1'\n\t\t\tif (((_bit == (nb_bits_in_this_byte - 1)) && (index == (length - 1))) && (flip_tms == 1)) begin\n\t\t\t\ttms <= 1'b1;\n\t\t\tend\n\n\t\t\t#TCK_HALF_PERIOD tck <= 1;\n\t\t\tdata_in[_bit] <= tdo;\n\t\t\t#TCK_HALF_PERIOD tck <= 0;\n\t\tend\n\t\tbuffer_in[index] = data_in;\n\tend\n\n\ttdi <= 1'b0;\n\ttms <= 1'b0;\nend\n\nendtask\n\nendmodule\n"}
{"text": "/*\n\nCopyright (c) 2016-2017 Alex Forencich\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n\ncommit 9a507b388ddddb0a7b54f88ad217d5e4bc48822c\nAuthor: Alex Forencich <alex@alexforencich.com>\nDate:   Fri Jun 9 21:17:28 2017 -0700\n\norigin\thttps://github.com/alexforencich/verilog-ethernet.git\n\n*/\n\n// Language: Verilog 2001\n\n`timescale 1ns / 1ps\n\n/*\n * Parametrizable combinatorial parallel LFSR/CRC\n */\nmodule lfsr #\n(\n    // width of LFSR\n    parameter LFSR_WIDTH = 31,\n    // LFSR polynomial\n    parameter LFSR_POLY = 31'h10000001,\n    // LFSR configuration: \"GALOIS\", \"FIBONACCI\"\n    parameter LFSR_CONFIG = \"FIBONACCI\",\n    // LFSR feed forward enable\n    parameter LFSR_FEED_FORWARD = 0,\n    // bit-reverse input and output\n    parameter REVERSE = 0,\n    // width of data input\n    parameter DATA_WIDTH = 8,\n    // implementation style: \"AUTO\", \"LOOP\", \"REDUCTION\"\n    parameter STYLE = \"AUTO\"\n)\n(\n    input  wire [DATA_WIDTH-1:0] data_in,\n    input  wire [LFSR_WIDTH-1:0] state_in,\n    output wire [DATA_WIDTH-1:0] data_out,\n    output wire [LFSR_WIDTH-1:0] state_out\n);\n\n/*\n\nFully parametrizable combinatorial parallel LFSR/CRC module.  Implements an unrolled LFSR\nnext state computation, shifting DATA_WIDTH bits per pass through the module.  Input data\nis XORed with LFSR feedback path, tie data_in to zero if this is not required.\n\nWorks in two parts: statically computes a set of bit masks, then uses these bit masks to\nselect bits for XORing to compute the next state.  \n\nPorts:\n\ndata_in\n\nData bits to be shifted through the LFSR (DATA_WIDTH bits)\n\nstate_in\n\nLFSR/CRC current state input (LFSR_WIDTH bits)\n\ndata_out\n\nData bits shifted out of LFSR (DATA_WIDTH bits)\n\nstate_out\n\nLFSR/CRC next state output (LFSR_WIDTH bits)\n\nParameters:\n\nLFSR_WIDTH\n\nSpecify width of LFSR/CRC register\n\nLFSR_POLY\n\nSpecify the LFSR/CRC polynomial in hex format.  For example, the polynomial\n\nx^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11 + x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1\n\nwould be represented as\n\n32'h04c11db7\n\nNote that the largest term (x^32) is suppressed.  This term is generated automatically based\non LFSR_WIDTH.\n\nLFSR_CONFIG\n\nSpecify the LFSR configuration, either Fibonacci or Galois.  Fibonacci is generally used\nfor linear-feedback shift registers (LFSR) for pseudorandom binary sequence (PRBS) generators,\nscramblers, and descrambers, while Galois is generally used for cyclic redundancy check\ngenerators and checkers.\n\nFibonacci style (example for 64b66b scrambler, 0x8000000001)\n\n   DIN (LSB first)\n    |\n    V\n   (+)<---------------------------(+)<-----------------------------.\n    |                              ^                               |\n    |  .----.  .----.       .----. |  .----.       .----.  .----.  |\n    +->|  0 |->|  1 |->...->| 38 |-+->| 39 |->...->| 56 |->| 57 |--'\n    |  '----'  '----'       '----'    '----'       '----'  '----'\n    V\n   DOUT\n\nGalois style (example for CRC16, 0x8005)\n\n    ,-------------------+-------------------------+----------(+)<-- DIN (MSB first)\n    |                   |                         |           ^\n    |  .----.  .----.   V   .----.       .----.   V   .----.  |\n    `->|  0 |->|  1 |->(+)->|  2 |->...->| 14 |->(+)->| 15 |--+---> DOUT\n       '----'  '----'       '----'       '----'       '----'\n\nLFSR_FEED_FORWARD\n\nGenerate feed forward instead of feed back LFSR.  Enable this for PRBS checking and self-\nsynchronous descrambling.\n\nFibonacci feed-forward style (example for 64b66b descrambler, 0x8000000001)\n\n   DIN (LSB first)\n    |\n    |  .----.  .----.       .----.    .----.       .----.  .----.\n    +->|  0 |->|  1 |->...->| 38 |-+->| 39 |->...->| 56 |->| 57 |--.\n    |  '----'  '----'       '----' |  '----'       '----'  '----'  |\n    |                              V                               |\n   (+)<---------------------------(+)------------------------------'\n    |\n    V\n   DOUT\n\nGalois feed-forward style\n\n    ,-------------------+-------------------------+------------+--- DIN (MSB first)\n    |                   |                         |            |\n    |  .----.  .----.   V   .----.       .----.   V   .----.   V\n    `->|  0 |->|  1 |->(+)->|  2 |->...->| 14 |->(+)->| 15 |->(+)-> DOUT\n       '----'  '----'       '----'       '----'       '----'\n\nREVERSE\n\nBit-reverse LFSR input and output.  Shifts MSB first by default, set REVERSE for LSB first.\n\nDATA_WIDTH\n\nSpecify width of input and output data bus.  The module will perform one shift per input\ndata bit, so if the input data bus is not required tie data_in to zero and set DATA_WIDTH\nto the required number of shifts per clock cycle.  \n\nSTYLE\n\nSpecify implementation style.  Can be \"AUTO\", \"LOOP\", or \"REDUCTION\".  When \"AUTO\"\nis selected, implemenation will be \"LOOP\" or \"REDUCTION\" based on synthesis translate\ndirectives.  \"REDUCTION\" and \"LOOP\" are functionally identical, however they simulate\nand synthesize differently.  \"REDUCTION\" is implemented with a loop over a Verilog\nreduction operator.  \"LOOP\" is implemented as a doubly-nested loop with no reduction\noperator.  \"REDUCTION\" is very fast for simulation in iverilog and synthesizes well in\nQuartus but synthesizes poorly in ISE, likely due to large inferred XOR gates causing\nproblems with the optimizer.  \"LOOP\" synthesizes will in both ISE and Quartus.  \"AUTO\"\nwill default to \"REDUCTION\" when simulating and \"LOOP\" for synthesizers that obey\nsynthesis translate directives.\n\nSettings for common LFSR/CRC implementations:\n\nName        Configuration           Length  Polynomial      Initial value   Notes\nCRC16-IBM   Galois, bit-reverse     16      16'h8005        16'hffff\nCRC16-CCITT Galois                  16      16'h1021        16'h1d0f\nCRC32       Galois, bit-reverse     32      32'h04c11db7    32'hffffffff    Ethernet FCS; invert final output\nPRBS6       Fibonacci               6       6'h21           any\nPRBS7       Fibonacci               7       7'h41           any\nPRBS9       Fibonacci               9       9'h021          any             ITU V.52\nPRBS10      Fibonacci               10      10'h081         any             ITU\nPRBS11      Fibonacci               11      11'h201         any             ITU O.152\nPRBS15      Fibonacci, inverted     15      15'h4001        any             ITU O.152\nPRBS17      Fibonacci               17      17'h04001       any\nPRBS20      Fibonacci               20      20'h00009       any             ITU V.57\nPRBS23      Fibonacci, inverted     23      23'h040001      any             ITU O.151\nPRBS29      Fibonacci, inverted     29      29'h08000001    any\nPRBS31      Fibonacci, inverted     31      31'h10000001    any\n64b66b      Fibonacci, bit-reverse  58      58'h8000000001  any             10G Ethernet\n128b130b    Galois, bit-reverse     23      23'h210125      any             PCIe gen 3\n\n*/\n\nreg [LFSR_WIDTH-1:0] lfsr_mask_state[LFSR_WIDTH-1:0];\nreg [DATA_WIDTH-1:0] lfsr_mask_data[LFSR_WIDTH-1:0];\nreg [LFSR_WIDTH-1:0] output_mask_state[DATA_WIDTH-1:0];\nreg [DATA_WIDTH-1:0] output_mask_data[DATA_WIDTH-1:0];\n\nreg [LFSR_WIDTH-1:0] state_val = 0;\nreg [DATA_WIDTH-1:0] data_val = 0;\n\ninteger i, j, k;\n\ninitial begin\n    // init bit masks\n    for (i = 0; i < LFSR_WIDTH; i = i + 1) begin\n        lfsr_mask_state[i] = {LFSR_WIDTH{1'b0}};\n        lfsr_mask_state[i][i] = 1'b1;\n        lfsr_mask_data[i] = {DATA_WIDTH{1'b0}};\n    end\n    for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n        output_mask_state[i] = {LFSR_WIDTH{1'b0}};\n        if (i < LFSR_WIDTH) begin\n            output_mask_state[i][i] = 1'b1;\n        end\n        output_mask_data[i] = {DATA_WIDTH{1'b0}};\n    end\n\n    // simulate shift register\n    if (LFSR_CONFIG == \"FIBONACCI\") begin\n        // Fibonacci configuration\n        for (i = DATA_WIDTH-1; i >= 0; i = i - 1) begin\n            // determine shift in value\n            // current value in last FF, XOR with input data bit (MSB first)\n            state_val = lfsr_mask_state[LFSR_WIDTH-1];\n            data_val = lfsr_mask_data[LFSR_WIDTH-1];\n            data_val = data_val ^ (1 << i);\n\n            // add XOR inputs from correct indicies\n            for (j = 1; j < LFSR_WIDTH; j = j + 1) begin\n                if (LFSR_POLY & (1 << j)) begin\n                    state_val = lfsr_mask_state[j-1] ^ state_val;\n                    data_val = lfsr_mask_data[j-1] ^ data_val;\n                end\n            end\n\n            // shift\n            for (j = LFSR_WIDTH-1; j > 0; j = j - 1) begin\n                lfsr_mask_state[j] = lfsr_mask_state[j-1];\n                lfsr_mask_data[j] = lfsr_mask_data[j-1];\n            end\n            for (j = DATA_WIDTH-1; j > 0; j = j - 1) begin\n                output_mask_state[j] = output_mask_state[j-1];\n                output_mask_data[j] = output_mask_data[j-1];\n            end\n            output_mask_state[0] = state_val;\n            output_mask_data[0] = data_val;\n            if (LFSR_FEED_FORWARD) begin\n                // only shift in new input data\n                state_val = {LFSR_WIDTH{1'b0}};\n                data_val = 1 << i;\n            end\n            lfsr_mask_state[0] = state_val;\n            lfsr_mask_data[0] = data_val;\n        end\n    end else if (LFSR_CONFIG == \"GALOIS\") begin\n        // Galois configuration\n        for (i = DATA_WIDTH-1; i >= 0; i = i - 1) begin\n            // determine shift in value\n            // current value in last FF, XOR with input data bit (MSB first)\n            state_val = lfsr_mask_state[LFSR_WIDTH-1];\n            data_val = lfsr_mask_data[LFSR_WIDTH-1];\n            data_val = data_val ^ (1 << i);\n\n            // shift\n            for (j = LFSR_WIDTH-1; j > 0; j = j - 1) begin\n                lfsr_mask_state[j] = lfsr_mask_state[j-1];\n                lfsr_mask_data[j] = lfsr_mask_data[j-1];\n            end\n            for (j = DATA_WIDTH-1; j > 0; j = j - 1) begin\n                output_mask_state[j] = output_mask_state[j-1];\n                output_mask_data[j] = output_mask_data[j-1];\n            end\n            output_mask_state[0] = state_val;\n            output_mask_data[0] = data_val;\n            if (LFSR_FEED_FORWARD) begin\n                // only shift in new input data\n                state_val = {LFSR_WIDTH{1'b0}};\n                data_val = 1 << i;\n            end\n            lfsr_mask_state[0] = state_val;\n            lfsr_mask_data[0] = data_val;\n\n            // add XOR inputs at correct indicies\n            for (j = 1; j < LFSR_WIDTH; j = j + 1) begin\n                if (LFSR_POLY & (1 << j)) begin\n                    lfsr_mask_state[j] = lfsr_mask_state[j] ^ state_val;\n                    lfsr_mask_data[j] = lfsr_mask_data[j] ^ data_val;\n                end\n            end\n        end\n    end else begin\n        $error(\"Error: unknown configuration setting!\");\n        $finish;\n    end\n\n    // reverse bits if selected\n    if (REVERSE) begin\n        // reverse order\n        for (i = 0; i < LFSR_WIDTH/2; i = i + 1) begin\n            state_val = lfsr_mask_state[i];\n            data_val = lfsr_mask_data[i];\n            lfsr_mask_state[i] = lfsr_mask_state[LFSR_WIDTH-i-1];\n            lfsr_mask_data[i] = lfsr_mask_data[LFSR_WIDTH-i-1];\n            lfsr_mask_state[LFSR_WIDTH-i-1] = state_val;\n            lfsr_mask_data[LFSR_WIDTH-i-1] = data_val;\n        end\n        for (i = 0; i < DATA_WIDTH/2; i = i + 1) begin\n            state_val = output_mask_state[i];\n            data_val = output_mask_data[i];\n            output_mask_state[i] = output_mask_state[DATA_WIDTH-i-1];\n            output_mask_data[i] = output_mask_data[DATA_WIDTH-i-1];\n            output_mask_state[DATA_WIDTH-i-1] = state_val;\n            output_mask_data[DATA_WIDTH-i-1] = data_val;\n        end\n        // reverse bits\n        for (i = 0; i < LFSR_WIDTH; i = i + 1) begin\n            state_val = 0;\n            for (j = 0; j < LFSR_WIDTH; j = j + 1) begin\n                state_val[j] = lfsr_mask_state[i][LFSR_WIDTH-j-1];\n            end\n            lfsr_mask_state[i] = state_val;\n\n            data_val = 0;\n            for (j = 0; j < DATA_WIDTH; j = j + 1) begin\n                data_val[j] = lfsr_mask_data[i][DATA_WIDTH-j-1];\n            end\n            lfsr_mask_data[i] = data_val;\n        end\n        for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n            state_val = 0;\n            for (j = 0; j < LFSR_WIDTH; j = j + 1) begin\n                state_val[j] = output_mask_state[i][LFSR_WIDTH-j-1];\n            end\n            output_mask_state[i] = state_val;\n\n            data_val = 0;\n            for (j = 0; j < DATA_WIDTH; j = j + 1) begin\n                data_val[j] = output_mask_data[i][DATA_WIDTH-j-1];\n            end\n            output_mask_data[i] = data_val;\n        end\n    end\n\n    // for (i = 0; i < LFSR_WIDTH; i = i + 1) begin\n    //     $display(\"%b %b\", lfsr_mask_state[i], lfsr_mask_data[i]);\n    // end\nend\n\n// synthesis translate_off\n`define SIMULATION\n// synthesis translate_on\n\n`ifdef SIMULATION\n// \"AUTO\" style is \"REDUCTION\" for faster simulation\nparameter STYLE_INT = (STYLE == \"AUTO\") ? \"REDUCTION\" : STYLE;\n`else\n// \"AUTO\" style is \"LOOP\" for better synthesis result\nparameter STYLE_INT = (STYLE == \"AUTO\") ? \"LOOP\" : STYLE;\n`endif\n\ngenvar n;\n\ngenerate\n\nif (STYLE_INT == \"REDUCTION\") begin\n\n    // use Verilog reduction operator\n    // fast in iverilog\n    // significantly larger than generated code with ISE (inferred wide XORs may be tripping up optimizer)\n    // slightly smaller than generated code with Quartus\n    // --> better for simulation\n\n    for (n = 0; n < LFSR_WIDTH; n = n + 1) begin : loop1\n        assign state_out[n] = ^{(state_in & lfsr_mask_state[n]), (data_in & lfsr_mask_data[n])};\n    end\n    for (n = 0; n < DATA_WIDTH; n = n + 1) begin : loop2\n        assign data_out[n] = ^{(state_in & output_mask_state[n]), (data_in & output_mask_data[n])};\n    end\n\nend else if (STYLE_INT == \"LOOP\") begin\n\n    // use nested loops\n    // very slow in iverilog\n    // slightly smaller than generated code with ISE\n    // same size as generated code with Quartus\n    // --> better for synthesis\n\n    reg [LFSR_WIDTH-1:0] state_out_reg = 0;\n    reg [DATA_WIDTH-1:0] data_out_reg = 0;\n\n    assign state_out = state_out_reg;\n    assign data_out = data_out_reg;\n\n    always @* begin\n        for (i = 0; i < LFSR_WIDTH; i = i + 1) begin\n            state_out_reg[i] = 0;\n            for (j = 0; j < LFSR_WIDTH; j = j + 1) begin\n                if (lfsr_mask_state[i][j]) begin\n                    state_out_reg[i] = state_out_reg[i] ^ state_in[j];\n                end\n            end\n            for (j = 0; j < DATA_WIDTH; j = j + 1) begin\n                if (lfsr_mask_data[i][j]) begin\n                    state_out_reg[i] = state_out_reg[i] ^ data_in[j];\n                end\n            end\n        end\n        for (i = 0; i < DATA_WIDTH; i = i + 1) begin\n            data_out_reg[i] = 0;\n            for (j = 0; j < LFSR_WIDTH; j = j + 1) begin\n                if (output_mask_state[i][j]) begin\n                    data_out_reg[i] = data_out_reg[i] ^ state_in[j];\n                end\n            end\n            for (j = 0; j < DATA_WIDTH; j = j + 1) begin\n                if (output_mask_data[i][j]) begin\n                    data_out_reg[i] = data_out_reg[i] ^ data_in[j];\n                end\n            end\n        end\n    end\n\nend else begin\n\n    initial begin\n        $error(\"Error: unknown style setting!\");\n        $finish;\n    end\n\nend\n\nendgenerate\n\nendmodule\n"}
{"text": "// File mii_to_rmii_0_exdes.vhd translated with vhd2vl v2.0 VHDL to Verilog RTL translator\n// Copyright (C) 2001 Vincenzo Liguori - Ocean Logic Pty Ltd - http://www.ocean-logic.com\n// Modifications (C) 2006 Mark Gonzales - PMC Sierra Inc\n// \n// vhd2vl comes with ABSOLUTELY NO WARRANTY\n// ALWAYS RUN A FORMAL VERIFICATION TOOL TO COMPARE VHDL INPUT TO VERILOG OUTPUT \n// \n// This is free software, and you are welcome to redistribute it under certain conditions.\n// See the license file license.txt included with the source for details.\n\n//Example design Top\n// file: exdes_top.vhd\n// \n// (c) Copyright 2008 - 2013 Xilinx, Inc. All rights reserved.\n// \n// This file contains confidential and proprietary information\n// of Xilinx, Inc. and is protected under U.S. and\n// international copyright and other intellectual property\n// laws.\n// \n// DISCLAIMER\n// This disclaimer is not a license and does not grant any\n// rights to the materials distributed herewith. Except as\n// otherwise provided in a valid license issued to you by\n// Xilinx, and to the maximum extent permitted by applicable\n// law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n// (2) Xilinx shall not be liable (whether in contract or tort,\n// including negligence, or under any other theory of\n// liability) for any loss or damage of any kind or nature\n// related to, arising under or in connection with these\n// materials, including for any direct, or any indirect,\n// special, incidental, or consequential loss or damage\n// (including loss of data, profits, goodwill, or any type of\n// loss or damage suffered as a result of any action brought\n// by a third party) even if such damage or loss was\n// reasonably foreseeable or Xilinx had been advised of the\n// possibility of the same.\n// \n// CRITICAL APPLICATIONS\n// Xilinx products are not designed or intended to be fail-\n// safe, or for use in any application requiring fail-safe\n// performance, such as life-support or safety devices or\n// systems, Class III medical devices, nuclear facilities,\n// applications related to the deployment of airbags, or any\n// other applications that could lead to death, personal\n// injury, or severe property or environmental damage\n// (individually and collectively, \"Critical\n// Applications\"). Customer assumes the sole risk and\n// liability of any use of Xilinx products in Critical\n// Applications, subject only to applicable laws and\n// regulations governing limitations on product liability.\n// \n// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n// PART OF THIS FILE AT ALL TIMES.\n// \n//----------------------------------------------------------------------------\n// User entered comments\n//----------------------------------------------------------------------------\n// This is a self-desigined TOP Wrapper developed for MII to RMII Example Design\n//\n//----------------------------------------------------------------------------\n`default_nettype none\n\nmodule mii_to_rmii_0_open(\ninput wire clk_rmii,\ninput wire locked,\n// SMSC ethernet PHY\noutput wire eth_rstn,\ninput wire eth_crsdv,\noutput wire eth_refclk,\noutput wire[1:0] eth_txd,\noutput wire eth_txen,\ninput wire[1:0] eth_rxd,\ninput wire eth_rxerr,\noutput wire eth_mdc,\ninput wire phy_mdio_i,\noutput wire phy_mdio_o,\noutput wire phy_mdio_t,\ninput wire s_axi_aclk,\ninput wire s_axi_aresetn,\ninput wire [7:0]s_axi_awid,\ninput wire [31:0]s_axi_awaddr,\ninput wire [7:0]s_axi_awlen,\ninput wire [2:0]s_axi_awsize,\ninput wire [1:0]s_axi_awburst,\ninput wire s_axi_awlock,\ninput wire [3:0]s_axi_awcache,\ninput wire [2:0]s_axi_awprot,\ninput wire s_axi_awvalid,\noutput wire s_axi_awready,\ninput wire [31:0]s_axi_wdata,\ninput wire [3:0]s_axi_wstrb,\ninput wire s_axi_wlast,\ninput wire s_axi_wvalid,\noutput wire s_axi_wready,\noutput wire [7:0] s_axi_bid,\noutput wire [1:0]s_axi_bresp,\noutput wire s_axi_bvalid,\ninput wire s_axi_bready,\ninput wire [7:0] s_axi_arid,\ninput wire [31:0]s_axi_araddr,\ninput wire [7:0]s_axi_arlen,\ninput wire [2:0]s_axi_arsize,\ninput wire [1:0]s_axi_arburst,\ninput wire s_axi_arlock,\ninput wire [3:0]s_axi_arcache,\ninput wire [2:0]s_axi_arprot,\ninput wire s_axi_arvalid,\noutput wire s_axi_arready,\noutput wire [7:0] s_axi_rid,\noutput wire [31:0]s_axi_rdata,\noutput wire [1:0]s_axi_rresp,\noutput wire s_axi_rlast,\noutput wire s_axi_rvalid,\ninput wire s_axi_rready,\noutput wire eth_irq);\n\n   wire     bram_rst_a;\n   wire     bram_clk_a;\n   wire     bram_en_a;\n   wire [3:0] bram_we_a;\n   wire [12:0] bram_addr_a;\n   wire [31:0] bram_wrdata_a, bram_rddata_a;\n\n   axi_bram_ctrl_1 BramCtl\n     (\n      .s_axi_aclk(s_axi_aclk),        // input wire s_axi_aclk\n      .s_axi_aresetn(s_axi_aresetn),  // input wire s_axi_aresetn\n      .s_axi_awid(s_axi_awid),        // input wire [7 : 0] s_axi_awid\n      .s_axi_awaddr(s_axi_awaddr[12:0]),    // input wire [12 : 0] s_axi_awaddr\n      .s_axi_awlen(s_axi_awlen),      // input wire [7 : 0] s_axi_awlen\n      .s_axi_awsize(s_axi_awsize),    // input wire [2 : 0] s_axi_awsize\n      .s_axi_awburst(s_axi_awburst),  // input wire [1 : 0] s_axi_awburst\n      .s_axi_awlock(s_axi_awlock),    // input wire s_axi_awlock\n      .s_axi_awcache(s_axi_awcache),  // input wire [3 : 0] s_axi_awcache\n      .s_axi_awprot(s_axi_awprot),    // input wire [2 : 0] s_axi_awprot\n      .s_axi_awvalid(s_axi_awvalid),  // input wire s_axi_awvalid\n      .s_axi_awready(s_axi_awready),  // output wire s_axi_awready\n      .s_axi_wdata(s_axi_wdata),      // input wire [31 : 0] s_axi_wdata\n      .s_axi_wstrb(s_axi_wstrb),      // input wire [3 : 0] s_axi_wstrb\n      .s_axi_wlast(s_axi_wlast),      // input wire s_axi_wlast\n      .s_axi_wvalid(s_axi_wvalid),    // input wire s_axi_wvalid\n      .s_axi_wready(s_axi_wready),    // output wire s_axi_wready\n      .s_axi_bid(s_axi_bid),          // output wire [7 : 0] s_axi_bid\n      .s_axi_bresp(s_axi_bresp),      // output wire [1 : 0] s_axi_bresp\n      .s_axi_bvalid(s_axi_bvalid),    // output wire s_axi_bvalid\n      .s_axi_bready(s_axi_bready),    // input wire s_axi_bready\n      .s_axi_arid(s_axi_arid),        // input wire [7 : 0] s_axi_arid\n      .s_axi_araddr(s_axi_araddr[12:0]),    // input wire [12 : 0] s_axi_araddr\n      .s_axi_arlen(s_axi_arlen),      // input wire [7 : 0] s_axi_arlen\n      .s_axi_arsize(s_axi_arsize),    // input wire [2 : 0] s_axi_arsize\n      .s_axi_arburst(s_axi_arburst),  // input wire [1 : 0] s_axi_arburst\n      .s_axi_arlock(s_axi_arlock),    // input wire s_axi_arlock\n      .s_axi_arcache(s_axi_arcache),  // input wire [3 : 0] s_axi_arcache\n      .s_axi_arprot(s_axi_arprot),    // input wire [2 : 0] s_axi_arprot\n      .s_axi_arvalid(s_axi_arvalid),  // input wire s_axi_arvalid\n      .s_axi_arready(s_axi_arready),  // output wire s_axi_arready\n      .s_axi_rid(s_axi_rid),          // output wire [7 : 0] s_axi_rid\n      .s_axi_rdata(s_axi_rdata),      // output wire [31 : 0] s_axi_rdata\n      .s_axi_rresp(s_axi_rresp),      // output wire [1 : 0] s_axi_rresp\n      .s_axi_rlast(s_axi_rlast),      // output wire s_axi_rlast\n      .s_axi_rvalid(s_axi_rvalid),    // output wire s_axi_rvalid\n      .s_axi_rready(s_axi_rready),    // input wire s_axi_rready\n      .bram_rst_a(bram_rst_a),        // output wire bram_rst_a\n      .bram_clk_a(bram_clk_a),        // output wire bram_clk_a\n      .bram_en_a(bram_en_a),          // output wire bram_en_a\n      .bram_we_a(bram_we_a),          // output wire [3 : 0] bram_we_a\n      .bram_addr_a(bram_addr_a),      // output wire [14 : 0] bram_addr_a\n      .bram_wrdata_a(bram_wrdata_a),  // output wire [31 : 0] bram_wrdata_a\n      .bram_rddata_a(bram_rddata_a)   // input wire [31 : 0] bram_rddata_a\n      );\n   \nframing_top open\n  (\n   .rstn(locked),\n   .msoc_clk(s_axi_aclk),\n   .clk_rmii(clk_rmii),\n   .core_lsu_addr(bram_addr_a),\n   .core_lsu_wdata(bram_wrdata_a),\n   .core_lsu_be(bram_we_a),\n   .ce_d(bram_en_a),\n   .we_d(|bram_we_a),\n   .framing_sel(bram_en_a),\n   .framing_rdata(bram_rddata_a),\n   .o_edutrefclk(eth_refclk),\n   .i_edutrxd(eth_rxd),\n   .i_edutrx_dv(eth_crsdv),\n   .i_edutrx_er(eth_rxerr),\n   .o_eduttxd(eth_txd),\n   .o_eduttx_en(eth_txen),\n   .o_edutmdc(eth_mdc),\n   .i_edutmdio(phy_mdio_i),\n   .o_edutmdio(phy_mdio_o),\n   .oe_edutmdio(phy_mdio_t),\n   .o_edutrstn(eth_rstn),\n   .eth_irq(eth_irq)\n);\n\nendmodule\n"}
{"text": "// Abstraction of subset of Xilinx FIFO generator functionality to a primitive\n`default_nettype none\n\n  module my_fifo #(parameter width=9) (\n                                       input wire              clk,\n                                       input wire              rst,\n                                       input wire [width-1:0]  din,\n                                       input wire              wr_en,\n                                       input wire              rd_en,\n                                       output wire [width-1:0] dout,\n                                       output wire             full,\n                                       output wire             empty,\n                                       output wire [11:0]      rdcount, // 12-bit output: Read count\n                                       output wire [11:0]      wrcount // 12-bit output: Write count\n                                       );\n\n`ifdef FPGA\n\n   wire [31:0]                                                 DO, DI;\n   wire [3:0]                                                  DOP, DIP;\n   \n   assign dout = {DOP[width/9-1:0],DO[width/9*8-1:0]};\n   assign DIP = din[width-1:width/9*8];\n   assign DI = din[width/9*8-1:0];\n   \n   \n   // FIFO18E1: 18Kb FIFO (First-In-First-Out) Block RAM Memory\n   //           Artix-7\n   // Xilinx HDL Language Template, version 2015.4\n\n   generate\n         if (width==36)\n      begin:gen36\n     \n     FIFO18E1 #(\n                .ALMOST_EMPTY_OFFSET(13'h0080),    // Sets the almost empty threshold\n                .ALMOST_FULL_OFFSET(13'h0080),     // Sets almost full threshold\n                .DATA_WIDTH(width),                // Sets data width to 4-36\n                .DO_REG(1),                        // Enable output register (1-0) Must be 1 if EN_SYN = FALSE\n                .EN_SYN(\"FALSE\"),                  // Specifies FIFO as dual-clock (FALSE) or Synchronous (TRUE)\n                .FIFO_MODE(\"FIFO18_36\"),           // Sets mode to FIFO18 or FIFO18_36\n                .FIRST_WORD_FALL_THROUGH(\"FALSE\"), // Sets the FIFO FWFT to FALSE, TRUE\n                .INIT(36'h000000000),              // Initial values on output port\n                .SIM_DEVICE(\"7SERIES\"),            // Must be set to \"7SERIES\" for simulation behavior\n                .SRVAL(36'h000000000)              // Set/Reset value for output port\n                )\n      FIFO18E1_inst_36 (\n                        // Read Data: 32-bit (each) output: Read output data\n                        .DO(DO),                   // 32-bit output: Data output\n                        .DOP(DOP),                 // 4-bit output: Parity data output\n                        // Status: 1-bit (each) output: Flags and other FIFO status outputs\n                        .ALMOSTEMPTY(),            // 1-bit output: Almost empty flag\n                        .ALMOSTFULL(),             // 1-bit output: Almost full flag\n                        .EMPTY(empty),             // 1-bit output: Empty flag\n                        .FULL(full),               // 1-bit output: Full flag\n                        .RDCOUNT(rdcount),         // 12-bit output: Read count\n                        .RDERR(),                  // 1-bit output: Read error\n                        .WRCOUNT(wrcount),         // 12-bit output: Write count\n                        .WRERR(),                  // 1-bit output: Write error\n                        // Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals\n                        .RDCLK(clk),               // 1-bit input: Read clock\n                        .RDEN(rd_en),              // 1-bit input: Read enable\n                        .REGCE(1'b1),              // 1-bit input: Clock enable\n                        .RSTREG(1'b0),              // 1-bit input: Asynchronous Reset\n                        .RST(rst),                 // 1-bit input: Asynchronous Reset\n                        // Write Control Signals: 1-bit (each) input: Write clock and enable input signals\n                        .WRCLK(clk),               // 1-bit input: Write clock\n                        .WREN(wr_en),              // 1-bit input: Write enable\n                        // Write Data: 32-bit (each) input: Write input data\n                        .DI(DI),                   // 32-bit input: Data input\n                        .DIP(DIP)                  // 4-bit input: Parity input\n                        );\n         end\n         else\n           begin:genelse\n     FIFO18E1 #(\n                .ALMOST_EMPTY_OFFSET(13'h0080),    // Sets the almost empty threshold\n                .ALMOST_FULL_OFFSET(13'h0080),     // Sets almost full threshold\n                .DATA_WIDTH(width),                // Sets data width to 4-36\n      .DO_REG(0),                        // Enable output register (1-0) Must be 1 if EN_SYN = FALSE\n      .EN_SYN(\"TRUE\"),                   // Specifies FIFO as dual-clock (FALSE) or Synchronous (TRUE)\n                .FIFO_MODE(\"FIFO18\"),              // Sets mode to FIFO18 or FIFO18_36\n                .FIRST_WORD_FALL_THROUGH(\"FALSE\"), // Sets the FIFO FWFT to FALSE, TRUE\n                .INIT(36'h000000000),              // Initial values on output port\n                .SIM_DEVICE(\"7SERIES\"),            // Must be set to \"7SERIES\" for simulation behavior\n                .SRVAL(36'h000000000)              // Set/Reset value for output port\n                )\n      FIFO18E1_inst_18 (\n                        // Read Data: 32-bit (each) output: Read output data\n                        .DO(DO),                   // 32-bit output: Data output\n                        .DOP(DOP),                 // 4-bit output: Parity data output\n                        // Status: 1-bit (each) output: Flags and other FIFO status outputs\n                        .ALMOSTEMPTY(),            // 1-bit output: Almost empty flag\n                        .ALMOSTFULL(),             // 1-bit output: Almost full flag\n                        .EMPTY(empty),             // 1-bit output: Empty flag\n                        .FULL(full),               // 1-bit output: Full flag\n                        .RDCOUNT(rdcount),         // 12-bit output: Read count\n                        .RDERR(),                  // 1-bit output: Read error\n                        .WRCOUNT(wrcount),         // 12-bit output: Write count\n                        .WRERR(),                  // 1-bit output: Write error\n                        // Read Control Signals: 1-bit (each) input: Read clock, enable and reset input signals\n                        .RDCLK(clk),              // 1-bit input: Read clock\n                        .RDEN(rd_en),              // 1-bit input: Read enable\n                        .REGCE(1'b1),              // 1-bit input: Clock enable\n                        .RST(rst),                 // 1-bit input: Asynchronous Reset\n                        .RSTREG(1'b0),              // 1-bit input: Output register set/reset\n                        // Write Control Signals: 1-bit (each) input: Write clock and enable input signals\n                        .WRCLK(clk),              // 1-bit input: Write clock\n                        .WREN(wr_en),               // 1-bit input: Write enable\n                        // Write Data: 32-bit (each) input: Write input data\n                        .DI(DI),                   // 32-bit input: Data input\n                        .DIP(DIP)                  // 4-bit input: Parity input\n                        );\n      end\n   endgenerate\n\n`else // !`ifdef FPGA\n\n   wire grant, valid;\n   \n generic_fifo\n  #(\n     .DATA_WIDTH(width),\n     .DATA_DEPTH(512)\n     )\n   fifo1\n   (\n    .clk(clk),\n    .rst_n(!rst),\n    //PUSH SIDE\n    .data_i(din),\n    .valid_i(wr_en),\n    .grant_o(grant),\n    //POP SIDE\n    .data_o(dout),\n    .valid_o(valid),\n    .grant_i(rd_en),\n    .test_mode_i(1'b0)\n    );\n\n   assign empty = !valid;\n   assign full = !grant;\n   assign wrcount = 0;\n   assign rdcount = 0;\n   \n`endif\n   \nendmodule\n`default_nettype wire\n"}
{"text": "// See LICENSE for license details.\n\n// Define the SV interfaces for NASTI channels\n\ninterface nasti_channel\n  #(\n    N_PORT = 1,                 // number of nasti ports\n    ID_WIDTH = 1,               // id width\n    ADDR_WIDTH = 8,             // address width\n    DATA_WIDTH = 8,             // width of data\n    USER_WIDTH = 1              // width of user field, must > 0, let synthesizer trim it if not in use\n    );\n\n   initial assert(USER_WIDTH > 0) else $fatal(1, \"[nasti interface] User field must have at least 1 bit!\");\n\n   // write/read address\n   logic [N_PORT-1:0][ID_WIDTH-1:0]     aw_id,     ar_id;\n   logic [N_PORT-1:0][ADDR_WIDTH-1:0]   aw_addr,   ar_addr;\n   logic [N_PORT-1:0][7:0]              aw_len,    ar_len;\n   logic [N_PORT-1:0][2:0]              aw_size,   ar_size;\n   logic [N_PORT-1:0][1:0]              aw_burst,  ar_burst;\n   logic [N_PORT-1:0]                   aw_lock,   ar_lock;\n   logic [N_PORT-1:0][3:0]              aw_cache,  ar_cache;\n   logic [N_PORT-1:0][2:0]              aw_prot,   ar_prot;\n   logic [N_PORT-1:0][3:0]              aw_qos,    ar_qos;\n   logic [N_PORT-1:0][3:0]              aw_region, ar_region;\n   logic [N_PORT-1:0][USER_WIDTH-1:0]   aw_user,   ar_user;\n   logic [N_PORT-1:0]                   aw_valid,  ar_valid;\n   logic [N_PORT-1:0]                   aw_ready,  ar_ready;\n\n   // write/read data\n   logic [N_PORT-1:0][DATA_WIDTH-1:0]   w_data,    r_data;\n   logic [N_PORT-1:0][DATA_WIDTH/8-1:0] w_strb;\n   logic [N_PORT-1:0]                   w_last,    r_last;\n   logic [N_PORT-1:0][USER_WIDTH-1:0]   w_user;\n   logic [N_PORT-1:0]                   w_valid;\n   logic [N_PORT-1:0]                   w_ready;\n\n   // write/read response\n   logic [N_PORT-1:0][ID_WIDTH-1:0]     b_id,      r_id;\n   logic [N_PORT-1:0][1:0]              b_resp,    r_resp;\n   logic [N_PORT-1:0][USER_WIDTH-1:0]   b_user,    r_user;\n   logic [N_PORT-1:0]                   b_valid,   r_valid;\n   logic [N_PORT-1:0]                   b_ready,   r_ready;\n\n\n   modport master (\n                   // write/read address\n                   output aw_id,     ar_id,\n                   output aw_addr,   ar_addr,\n                   output aw_len,    ar_len,\n                   output aw_size,   ar_size,\n                   output aw_burst,  ar_burst,\n                   output aw_lock,   ar_lock,\n                   output aw_cache,  ar_cache,\n                   output aw_prot,   ar_prot,\n                   output aw_qos,    ar_qos,\n                   output aw_region, ar_region,\n                   output aw_user,   ar_user,\n                   output aw_valid,  ar_valid,\n                   input  aw_ready,  ar_ready,\n                   // write data\n                   output w_data,\n                   output w_strb,\n                   output w_last,\n                   output w_user,\n                   output w_valid,\n                   input  w_ready,\n                   // read data\n                   input  r_data,\n                   input  r_last,\n                   // write/read response\n                   input  b_id,    r_id,\n                   input  b_resp,  r_resp,\n                   input  b_user,  r_user,\n                   input  b_valid, r_valid,\n                   output b_ready, r_ready\n                   );\n\n   modport slave (\n                  // write/read address\n                  input  aw_id,     ar_id,\n                  input  aw_addr,   ar_addr,\n                  input  aw_len,    ar_len,\n                  input  aw_size,   ar_size,\n                  input  aw_burst,  ar_burst,\n                  input  aw_lock,   ar_lock,\n                  input  aw_cache,  ar_cache,\n                  input  aw_prot,   ar_prot,\n                  input  aw_qos,    ar_qos,\n                  input  aw_region, ar_region,\n                  input  aw_user,   ar_user,\n                  input  aw_valid,  ar_valid,\n                  output aw_ready,  ar_ready,\n                   // write data\n                  input  w_data,\n                  input  w_strb,\n                  input  w_last,\n                  input  w_user,\n                  input  w_valid,\n                  output w_ready,\n                   // read data\n                  output r_data,\n                  output r_last,\n                   // write/read response\n                  output b_id,    r_id,\n                  output b_resp,  r_resp,\n                  output b_user,  r_user,\n                  output b_valid, r_valid,\n                  input  b_ready, r_ready\n                   );\n\nendinterface // nasti_channel\n\n\n\n"}
{"text": "// Copyright 2015 ETH Zurich, University of Bologna, and University of Cambridge\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n// See LICENSE for license details.\n\n`default_nettype none\n\nmodule periph_soc #(UBAUD_DEFAULT=54)\n  (\n output wire        uart_tx,\n output wire        uart_irq,\n input wire         uart_rx,\n // clock and reset\n input wire         clk_200MHz,\n input wire         pxl_clk,\n input wire         msoc_clk,\n input wire         rstn,\n output reg [21:0]  to_led,\n input wire [15:0]  from_dip,\n output wire        sd_sclk,\n input wire         sd_detect,\n inout wire [3:0]   sd_dat,\n inout wire         sd_cmd,\n output reg         sd_reset,\n output reg         sd_irq,\n input wire         hid_en,\n input wire [7:0]   hid_we,\n input wire [17:0]  hid_addr,\n input wire [63:0]  hid_wrdata,\n output reg [63:0]  hid_rddata,\n //keyboard\n inout wire         PS2_CLK,\n inout wire         PS2_DATA,\n \n   // display\n output wire        VGA_HS_O,\n output wire        VGA_VS_O,\n output wire [3:0]  VGA_RED_O,\n output wire [3:0]  VGA_BLUE_O,\n output wire [3:0]  VGA_GREEN_O,\n// SMSC ethernet PHY to framing_top connections\n input wire         clk_rmii,\n input wire         locked,\n output wire        eth_rstn,\n input wire         eth_crsdv,\n output wire        eth_refclk,\n output wire [1:0]  eth_txd,\n output wire        eth_txen,\n input wire [1:0]   eth_rxd,\n input wire         eth_rxerr,\n output wire        eth_mdc,\n input wire         phy_mdio_i,\n output wire        phy_mdio_o,\n output wire        phy_mdio_t,\n output wire        eth_irq,\n output wire        ram_clk,\n output wire        ram_rst,\n output wire        ram_en,\n output wire [7:0]  ram_we,\n output wire [15:0] ram_addr,\n output wire [63:0] ram_wrdata,\n input  wire [63:0] ram_rddata\n );\n \n wire [19:0] dummy;\n wire        scan_ready, scan_released;\n wire [7:0]  scan_code, fstore_data;\n wire        keyb_empty, tx_error_no_keyboard_ack;   \n reg [31:0]  keycode;\n reg scan_ready_dly;\n wire [8:0] keyb_fifo_out;\n // signals from/to core\nlogic [7:0] one_hot_data_addr;\nlogic [63:0] one_hot_rdata[7:0];\n\n    ps2 keyb_mouse(\n      .clk(msoc_clk),\n      .rst(~rstn),\n      .PS2_K_CLK_IO(PS2_CLK),\n      .PS2_K_DATA_IO(PS2_DATA),\n      .PS2_M_CLK_IO(),\n      .PS2_M_DATA_IO(),\n      .rx_released(scan_released),\n      .rx_scan_ready(scan_ready),\n      .rx_scan_code(scan_code),\n      .rx_scan_read(scan_ready),\n      .tx_error_no_keyboard_ack(tx_error_no_keyboard_ack));\n \n always @(negedge msoc_clk)\n    begin\n        scan_ready_dly <= scan_ready;\n    end\n    \n my_fifo #(.width(9)) keyb_fifo (\n       .clk(~msoc_clk),      // input wire read clk\n       .rst(~rstn),      // input wire rst\n       .din({scan_released, scan_code}),      // input wire [31 : 0] din\n       .wr_en(scan_ready & ~scan_ready_dly),  // input wire wr_en\n       .rd_en(hid_en&(|hid_we)&one_hot_data_addr[6]&~hid_addr[14]),  // input wire rd_en\n       .dout(keyb_fifo_out),    // output wire [31 : 0] dout\n       .rdcount(),         // 12-bit output: Read count\n       .wrcount(),         // 12-bit output: Write count\n       .full(),    // output wire full\n       .empty(keyb_empty)  // output wire empty\n     );\n\n    wire [7:0] red,  green, blue;\n \n    fstore2 the_fstore(\n      .pixel2_clk(pxl_clk),\n      .vsyn(VGA_VS_O),\n      .hsyn(VGA_HS_O),\n      .red(red),\n      .green(green),\n      .blue(blue),\n      .web(hid_we),\n      .enb(hid_en & one_hot_data_addr[7]),\n      .addrb(hid_addr[14:0]),\n      .dinb(hid_wrdata),\n      .doutb(one_hot_rdata[7]),\n      .irst(~rstn),\n      .clk_data(msoc_clk)\n     );\n\n assign VGA_RED_O = red[7:4];\n assign VGA_GREEN_O = green[7:4];\n assign VGA_BLUE_O = blue[7:4];\n\n   reg         u_trans, u_recv, uart_rx_full, uart_rx_empty, uart_tx_empty, uart_tx_full;   \n   reg [15:0]  u_baud;\n   wire        received, recv_err, is_recv, is_trans, uart_maj;\n   wire [11:0] uart_rx_wrcount, uart_rx_rdcount, uart_tx_wrcount, uart_tx_rdcount;\n   wire [8:0]  uart_rx_fifo_data_out, uart_tx_fifo_data_out;\n   reg [7:0]   u_rx_byte, u_tx_byte;\n\n   assign uart_irq = ~uart_rx_empty;\n\n   assign one_hot_rdata[6] = hid_addr[14] ?\n                              (hid_addr[13] ?\n                               {4'b0,uart_tx_wrcount,\n                                4'b0,uart_tx_rdcount,\n                                4'b0,uart_rx_wrcount,\n                                4'b0,uart_rx_rdcount} : \n                               {4'b0,uart_rx_full,uart_tx_full,uart_rx_empty,uart_rx_fifo_data_out}) :\n                              {tx_error_no_keyboard_ack,keyb_empty,keyb_fifo_out[8:0]};\n\ntypedef enum {UTX_IDLE, UTX_EMPTY, UTX_INUSE, UTX_POP, UTX_START} utx_t;\n\n   utx_t utxstate_d, utxstate_q;\n   \nalways @(posedge msoc_clk)\n    if (~rstn)\n    begin\n    u_baud = UBAUD_DEFAULT;\n    u_recv = 0;\n    u_trans = 0;\n    u_tx_byte = 0;\n    utxstate_q = UTX_IDLE;\n    end\n  else\n    begin\n    u_recv = 0;\n    u_trans = 0;\n    utxstate_q = utxstate_d;\n    if (hid_en & (|hid_we) & one_hot_data_addr[6] & hid_addr[14])\n        casez (hid_addr[13:12])\n         2'b00: begin u_trans = 1; u_tx_byte = hid_wrdata[7:0]; $write(\"%c\", u_tx_byte); $fflush(); end\n         2'b01: begin u_recv = 1; end\n         2'b10: begin u_baud = hid_wrdata; end\n         2'b11: begin end\n        endcase\n    end // else: !if(~rstn)\n\nalways @*\n  begin\n     utxstate_d = utxstate_q;\n     casez(utxstate_q)\n       UTX_IDLE:\n         utxstate_d = UTX_EMPTY;\n       UTX_EMPTY:\n         if (~uart_tx_empty)\n           utxstate_d = UTX_POP;\n       UTX_INUSE:\n         if (~is_trans)\n           utxstate_d = UTX_IDLE;\n       UTX_POP:\n         utxstate_d = UTX_START;\n       UTX_START:\n         utxstate_d = UTX_INUSE;\n       default:;\n     endcase\n  end\n   \n//----------------------------------------------------------------------------//\nrx_delay uart_rx_dly(\n.clk(msoc_clk),\n.in(uart_rx),\t\t     \n.maj(uart_maj));\n// Core Instantiation\nuart i_uart(\n    .clk(msoc_clk), // The master clock for this module\n    .rst(~rstn), // Synchronous reset.\n    .rx(uart_maj), // Incoming serial line\n    .tx(uart_tx), // Outgoing serial line\n    .transmit(utxstate_q==UTX_START), // Signal to transmit\n    .tx_byte(uart_tx_fifo_data_out[7:0]), // Byte to transmit\n    .received(received), // Indicated that a byte has been received.\n    .rx_byte(u_rx_byte), // Byte received\n    .is_receiving(is_recv), // Low when receive line is idle.\n    .is_transmitting(is_trans), // Low when transmit line is idle.\n    .recv_error(recv_err), // Indicates error in receiving packet.\n    .baud(u_baud),\n    .recv_ack(received)\n    );\n\n my_fifo #(.width(9)) uart_rx_fifo (\n       .clk(msoc_clk),      // input wire read clk\n       .rst(~rstn),      // input wire rst\n       .din({recv_err,u_rx_byte}),      // input wire [8 : 0] din\n       .wr_en(received),  // input wire wr_en\n       .rd_en(u_recv),  // input wire rd_en\n       .dout(uart_rx_fifo_data_out),    // output wire [8 : 0] dout\n       .rdcount(uart_rx_rdcount),         // 12-bit output: Read count\n       .wrcount(uart_rx_wrcount),         // 12-bit output: Write count\n       .full(uart_rx_full),    // output wire full\n       .empty(uart_rx_empty)  // output wire empty\n     );\n\n my_fifo #(.width(9)) uart_tx_fifo (\n       .clk(msoc_clk),      // input wire read clk\n       .rst(~rstn),      // input wire rst\n       .din({1'b0,u_tx_byte}),      // input wire [8 : 0] din\n       .wr_en(u_trans),  // input wire wr_en\n       .rd_en(utxstate_q==UTX_POP),  // input wire rd_en\n       .dout(uart_tx_fifo_data_out),    // output wire [8 : 0] dout\n       .rdcount(uart_tx_rdcount),         // 12-bit output: Read count\n       .wrcount(uart_tx_wrcount),         // 12-bit output: Write count\n       .full(uart_tx_full),    // output wire full\n       .empty(uart_tx_empty)  // output wire empty\n     );\n   \n//----------------------------------------------------------------------------//\n\nalways_comb\n  begin:onehot\n     integer i;\n     hid_rddata = 64'b0;\n     for (i = 0; i < 8; i++)\n       begin\n\t   one_hot_data_addr[i] = hid_addr[17:15] == i;\n\t   hid_rddata |= (one_hot_data_addr[i] ? one_hot_rdata[i] : 64'b0);\n       end\n  end\n\n   wire    tx_rd, rx_wr_en;\n   wire       sd_data_busy, data_crc_ok, sd_dat_oe;\n   wire [3:0] sd_dat_to_mem, sd_dat_to_host, sd_dat_to_host_maj;\n   wire       sd_cmd_to_mem, sd_cmd_to_host, sd_cmd_to_host_maj, sd_cmd_oe;\n   wire       sd_clk_o;       \n   wire       sd_cmd_finish, sd_data_finish, sd_cmd_crc_ok, sd_cmd_index_ok;\n\n   reg [2:0]  sd_data_start_reg;\n   reg [1:0]  sd_align_reg;\n   reg [15:0] sd_blkcnt_reg;\n   reg [11:0] sd_blksize_reg;\n   \n   reg [15:0] clock_divider_sd_clk_reg;\n   reg [2:0]  sd_cmd_setting_reg;\n   reg [5:0]  sd_cmd_i_reg;\n   reg [31:0] sd_cmd_arg_reg;\n   reg [31:0] sd_cmd_timeout_reg;\n\n   reg sd_cmd_start_reg;\n\n   reg [2:0]  sd_data_start;\n   reg [1:0]  sd_align;\n   reg [15:0] sd_blkcnt;\n   reg [11:0] sd_blksize;\n   \n   reg [15:0] clock_divider_sd_clk;\n   reg [2:0]  sd_cmd_setting;\n   reg [5:0]  sd_cmd_i;\n   reg [31:0] sd_cmd_arg;\n   reg [31:0] sd_cmd_timeout;\n\n   reg \t   sd_cmd_start, sd_cmd_rst, sd_data_rst, sd_clk_rst;\n   reg [15:0] from_dip_reg;\n\n   wire [9:0] sd_xfr_addr;\n   \nlogic [6:0] sd_clk_daddr;\nlogic       sd_clk_dclk, sd_clk_den, sd_clk_drdy, sd_clk_dwe, sd_clk_locked;\nlogic [15:0] sd_clk_din, sd_clk_dout;\nlogic [3:0] sd_irq_en_reg, sd_irq_stat_reg;\n   logic [133:0]    sd_cmd_response, sd_cmd_response_reg;\n   logic [31:0] \tsd_cmd_resp_sel, sd_status_reg;\n   logic [31:0] \tsd_status, sd_cmd_wait, sd_data_wait, sd_cmd_wait_reg, sd_data_wait_reg;\n   logic [6:0] \t    sd_cmd_crc_val;\n   logic [47:0] \tsd_cmd_packet, sd_cmd_packet_reg;\n   logic [15:0] \tsd_transf_cnt, sd_transf_cnt_reg;\n   logic            sd_detect_reg;\n   \nassign sd_clk_dclk = msoc_clk;\n\nalways @(posedge msoc_clk or negedge rstn)\n  if (!rstn)\n    begin\n       from_dip_reg <= 0;\n\tsd_align_reg <= 0;\n\tsd_blkcnt_reg <= 0;\n\tsd_blksize_reg <= 0;\n\tsd_data_start_reg <= 0;\n\tsd_clk_din <= 0;\n\tsd_clk_den <= 0;\n\tsd_clk_dwe <= 0;\n\tsd_clk_daddr <= 0;\n\tsd_cmd_i_reg <= 0;\n\tsd_cmd_arg_reg <= 0;\n\tsd_cmd_setting_reg <= 0;\n\tsd_cmd_start_reg <= 0;\n\tsd_reset <= 0;\n\tsd_data_rst <= 0;\n\tsd_cmd_rst <= 0;\n\tsd_clk_rst <= 0;\n\tsd_cmd_timeout_reg <= 0;\n        sd_irq_stat_reg <= 0;\n        sd_irq_en_reg <= 0;\n        sd_irq <= 0;\n\tto_led <= 0;\n   end\n   else\n     begin\n        sd_irq_stat_reg <= {~sd_detect_reg,sd_detect_reg,sd_status[10],sd_status[8]};\n        sd_irq <= |(sd_irq_en_reg & sd_irq_stat_reg);\n        from_dip_reg <= from_dip;\n\t if (hid_en&(|hid_we)&one_hot_data_addr[2]&~hid_addr[14])\n\t  case(hid_addr[6:3])\n\t    0: sd_align_reg <= hid_wrdata;\n\t    1: sd_clk_din <= hid_wrdata;\n\t    2: sd_cmd_arg_reg <= hid_wrdata;\n\t    3: sd_cmd_i_reg <= hid_wrdata;\n\t    4: {sd_data_start_reg,sd_cmd_setting_reg[2:0]} <= hid_wrdata;\n\t    5: sd_cmd_start_reg <= hid_wrdata;\n\t    6: {sd_reset,sd_clk_rst,sd_data_rst,sd_cmd_rst} <= hid_wrdata;\n\t    7: sd_blkcnt_reg <= hid_wrdata;\n\t    8: sd_blksize_reg <= hid_wrdata;\n\t    9: sd_cmd_timeout_reg <= hid_wrdata;\n\t   10: {sd_clk_dwe,sd_clk_den,sd_clk_daddr} <= hid_wrdata;\n       11: sd_irq_en_reg <= hid_wrdata;            \n\t   // Not strictly related, but can indicate SD-card activity and so on\n\t   15: to_led <= hid_wrdata;\n\t   default:;\n\t  endcase\n    end\n\nalways @(posedge sd_clk_o)\n    begin\n\tsd_align <= sd_align_reg;\n\tsd_cmd_arg <= sd_cmd_arg_reg;\n\tsd_cmd_i <= sd_cmd_i_reg;\n\t{sd_data_start,sd_cmd_setting} <= {sd_data_start_reg,sd_cmd_setting_reg};\n\tsd_cmd_start <= sd_cmd_start_reg;\n\tsd_blkcnt <= sd_blkcnt_reg;\n\tsd_blksize <= sd_blksize_reg;\n\tsd_cmd_timeout <= sd_cmd_timeout_reg;\n    end\n\n   //Tx SD data\n   wire [31:0] data_in_rx;\n   //Rx SD data\n   wire [31:0] data_out_tx;\n   \n   // tri-state gate\n   io_buffer_fast IOBUF_cmd_inst (\n       .outg(sd_cmd_to_host),     // Buffer output\n       .inoutg(sd_cmd),   // Buffer inout port (connect directly to top-level port)\n       .ing(sd_cmd_to_mem),     // Buffer input\n       .ctrl(~sd_cmd_oe)      // 3-state enable input, high=input, low=output\n    );\n\n    rx_delay cmd_rx_dly(\n        .clk(clk_200MHz),\n        .in(sd_cmd_to_host),             \n        .maj(sd_cmd_to_host_maj));\n\n   io_buffer_fast IOBUF_clk_inst (\n        .outg(),     // Buffer output\n        .inoutg(sd_sclk),   // Buffer inout port (connect directly to top-level port)\n        .ing(~sd_clk_o),     // Buffer input\n        .ctrl(~sd_clk_rst)      // 3-state enable input, high=input, low=output\n   );\n\n    genvar sd_dat_ix;\n    generate for (sd_dat_ix = 0; sd_dat_ix < 4; sd_dat_ix=sd_dat_ix+1)\n        begin:sd_dat_gen\n         io_buffer_fast IOBUF_dat_inst (\n            .outg(sd_dat_to_host[sd_dat_ix]),     // Buffer output\n            .inoutg(sd_dat[sd_dat_ix]),   // Buffer inout port (connect directly to top-level port)\n            .ing(sd_dat_to_mem[sd_dat_ix]),     // Buffer input\n            .ctrl(~sd_dat_oe)      // 3-state enable input, high=input, low=output\n        );\n        rx_delay dat_rx_dly(\n            .clk(clk_200MHz),\n            .in(sd_dat_to_host[sd_dat_ix]),             \n            .maj(sd_dat_to_host_maj[sd_dat_ix]));\n        end\n        \n   endgenerate\n   \n   logic [7:0] rx_wr = rx_wr_en ? (sd_xfr_addr[0] ? 8'hF0 : 8'hF) : 8'b0;\n   logic [63:0] douta, doutb;\n   logic sd_xfr_addr_prev;\n   logic [31:0] swapbein = {data_in_rx[7:0],data_in_rx[15:8],data_in_rx[23:16],data_in_rx[31:24]};\n   assign one_hot_rdata[3] = doutb;\n   assign data_out_tx = sd_xfr_addr_prev ? {douta[39:32],douta[47:40],douta[55:48],douta[63:56]} :\n                                           {douta[7:0],douta[15:8],douta[23:16],douta[31:24]};\n  \n   always @(negedge sd_clk_o)\n       begin\n       if (tx_rd) sd_xfr_addr_prev = sd_xfr_addr[0];\n       end            \n \n   dualmem_32K_64 RAMB16_S36_S36_inst_sd\n       (\n        .clka   ( ~sd_clk_o                   ),     // Port A Clock\n        .douta  ( douta                       ),     // Port A 1-bit Data Output\n        .addra  ( sd_xfr_addr[9:1]            ),     // Port A 9-bit Address Input\n        .dina   ( {swapbein,swapbein}         ),     // Port A 1-bit Data Input\n        .ena    ( tx_rd|rx_wr_en              ),     // Port A RAM Enable Input\n        .wea    ( rx_wr                       ),     // Port A Write Enable Input\n        .clkb   ( msoc_clk                    ),     // Port B Clock\n        .doutb  ( doutb                       ),     // Port B 1-bit Data Output\n        .addrb  ( hid_addr[11:3]              ),     // Port B 14-bit Address Input\n        .dinb   ( hid_wrdata                  ),     // Port B 1-bit Data Input\n        .enb    ( hid_en&one_hot_data_addr[3] ),     // Port B RAM Enable Input\n        .web    ( hid_we                      )      // Port B Write Enable Input\n        );\n\n   always @(posedge msoc_clk)\n     begin\n     sd_status_reg <= sd_status;\n     sd_cmd_response_reg <= sd_cmd_response;\n     sd_cmd_wait_reg <= sd_cmd_wait;\n     sd_data_wait_reg <= sd_data_wait;\n     sd_cmd_packet_reg <= sd_cmd_packet;\n     sd_transf_cnt_reg <= sd_transf_cnt;\n     sd_detect_reg <= sd_detect;\n        \n     case(hid_addr[7:3])\n       0: sd_cmd_resp_sel = sd_cmd_response_reg[38:7];\n       1: sd_cmd_resp_sel = sd_cmd_response_reg[70:39];\n       2: sd_cmd_resp_sel = sd_cmd_response_reg[102:71];\n       3: sd_cmd_resp_sel = sd_cmd_response_reg[133:103];\n       4: sd_cmd_resp_sel = sd_cmd_wait_reg;\n       5: sd_cmd_resp_sel = sd_status_reg;\n       6: sd_cmd_resp_sel = sd_cmd_packet_reg[31:0];\n       7: sd_cmd_resp_sel = sd_cmd_packet_reg[47:32];       \n       8: sd_cmd_resp_sel = sd_data_wait_reg;\n       9: sd_cmd_resp_sel = sd_transf_cnt_reg;\n      10: sd_cmd_resp_sel = 0;\n      11: sd_cmd_resp_sel = 0;\n      12: sd_cmd_resp_sel = sd_detect_reg;\n      13: sd_cmd_resp_sel = sd_xfr_addr;\n      14: sd_cmd_resp_sel = sd_irq_stat_reg;\n      15: sd_cmd_resp_sel = {sd_clk_locked,sd_clk_drdy,sd_clk_dout};\n      16: sd_cmd_resp_sel = sd_align_reg;\n      17: sd_cmd_resp_sel = sd_clk_din;\n      18: sd_cmd_resp_sel = sd_cmd_arg_reg;\n      19: sd_cmd_resp_sel = sd_cmd_i_reg;\n      20: sd_cmd_resp_sel = {sd_data_start_reg,sd_cmd_setting_reg};\n      21: sd_cmd_resp_sel = sd_cmd_start_reg;\n      22: sd_cmd_resp_sel = {sd_reset,sd_clk_rst,sd_data_rst,sd_cmd_rst};\n      23: sd_cmd_resp_sel = sd_blkcnt_reg;\n      24: sd_cmd_resp_sel = sd_blksize_reg;\n      25: sd_cmd_resp_sel = sd_cmd_timeout_reg;\n      26: sd_cmd_resp_sel = {sd_clk_dwe,sd_clk_den,sd_clk_daddr};\n      27: sd_cmd_resp_sel = sd_irq_en_reg;\n      // not really related but we can decide if we want to autoboot, and so on.\n      31: sd_cmd_resp_sel = from_dip_reg;\n      default: sd_cmd_resp_sel = 32'HDEADBEEF;\n     endcase // case (hid_addr[7:3])\n     end\n   \n   assign sd_status[3:0] = 4'b0;\n\n   assign one_hot_rdata[2] = sd_cmd_resp_sel;\n\n`ifdef FPGA_FULL\n \nclk_wiz_1 sd_clk_div\n     (\n     // Clock in ports\n      .clk_in1(msoc_clk),      // input clk_in1\n      // Clock out ports\n      .clk_sdclk(sd_clk_o),     // output clk_sdclk\n      // Dynamic reconfiguration ports\n      .daddr(sd_clk_daddr), // input [6:0] daddr\n      .dclk(sd_clk_dclk), // input dclk\n      .den(sd_clk_den), // input den\n      .din(sd_clk_din), // input [15:0] din\n      .dout(sd_clk_dout), // output [15:0] dout\n      .drdy(sd_clk_drdy), // output drdy\n      .dwe(sd_clk_dwe), // input dwe\n      // Status and control signals\n      .reset(~(sd_clk_rst&rstn)), // input reset\n      .locked(sd_clk_locked));      // output locked\n\n`else // !`ifdef FPGA\n\n   assign sd_clk_o = msoc_clk;\n   \n`endif\n   \nsd_top sdtop(\n    .sd_clk     (sd_clk_o),\n    .cmd_rst    (~(sd_cmd_rst&rstn)),\n    .data_rst   (~(sd_data_rst&rstn)),\n    .setting_i  (sd_cmd_setting),\n    .timeout_i  (sd_cmd_timeout),\n    .cmd_i      (sd_cmd_i),\n    .arg_i      (sd_cmd_arg),\n    .start_i    (sd_cmd_start),\n    .sd_data_start_i(sd_data_start),\n    .sd_align_i(sd_align),\n    .sd_blkcnt_i(sd_blkcnt),\n    .sd_blksize_i(sd_blksize),\n    .sd_data_i(data_out_tx),\n    .sd_dat_to_host(sd_dat_to_host_maj),\n    .sd_cmd_to_host(sd_cmd_to_host_maj),\n    .finish_cmd_o(sd_cmd_finish),\n    .finish_data_o(sd_data_finish),\n    .response0_o(sd_cmd_response[38:7]),\n    .response1_o(sd_cmd_response[70:39]),\n    .response2_o(sd_cmd_response[102:71]),\n    .response3_o(sd_cmd_response[133:103]),\n    .crc_ok_o   (sd_cmd_crc_ok),\n    .index_ok_o (sd_cmd_index_ok),\n    .transf_cnt_o(sd_transf_cnt),\n    .wait_o(sd_cmd_wait),\n    .wait_data_o(sd_data_wait),\n    .status_o(sd_status[31:4]),\n    .packet0_o(sd_cmd_packet[31:0]),\n    .packet1_o(sd_cmd_packet[47:32]),\n    .crc_val_o(sd_cmd_crc_val),\n    .crc_actual_o(sd_cmd_response[6:0]),\n    .sd_rd_o(tx_rd),\n    .sd_we_o(rx_wr_en),\n    .sd_data_o(data_in_rx),    \n    .sd_dat_to_mem(sd_dat_to_mem),\n    .sd_cmd_to_mem(sd_cmd_to_mem),\n    .sd_dat_oe(sd_dat_oe),\n    .sd_cmd_oe(sd_cmd_oe),\n    .sd_xfr_addr(sd_xfr_addr)\n    );\n\nframing_top open\n  (\n   .rstn(locked),\n   .msoc_clk(msoc_clk),\n   .clk_rmii(clk_rmii),\n   .core_lsu_addr(hid_addr[14:0]),\n   .core_lsu_wdata(hid_wrdata),\n   .core_lsu_be(hid_we),\n   .ce_d(hid_en),\n   .we_d(hid_en & one_hot_data_addr[4] & (|hid_we)),\n   .framing_sel(hid_en),\n   .framing_rdata(one_hot_rdata[4]),\n   .o_edutrefclk(eth_refclk),\n   .i_edutrxd(eth_rxd),\n   .i_edutrx_dv(eth_crsdv),\n   .i_edutrx_er(eth_rxerr),\n   .o_eduttxd(eth_txd),\n   .o_eduttx_en(eth_txen),\n   .o_edutmdc(eth_mdc),\n   .i_edutmdio(phy_mdio_i),\n   .o_edutmdio(phy_mdio_o),\n   .oe_edutmdio(phy_mdio_t),\n   .o_edutrstn(eth_rstn),\n   .eth_irq(eth_irq)\n);\n\n   assign one_hot_rdata[1] = one_ho"}
{"text": "t_rdata[0];\n   assign one_hot_rdata[0] = ram_rddata;\n   assign ram_wrdata = hid_wrdata;\n   assign ram_addr = hid_addr[15:0];\n   assign ram_we = hid_we;\n   assign ram_en = hid_en&(one_hot_data_addr[1]|one_hot_data_addr[0]);\n   assign ram_clk = msoc_clk;\n   assign ram_rst = ~rstn;\n   \nendmodule // chip_top\n`default_nettype wire\n"}
{"text": "// See LICENSE.SiFive for license details.\n\n// No default parameter values are intended, nor does IEEE 1800-2012 require them (clause A.2.4 param_assignment),\n// but Incisive demands them. These default values should never be used.\nmodule plusarg_reader #(FORMAT=\"borked=%d\", DEFAULT=0) (\n   output wire [31:0] out\n);\n\n`ifdef SYNTHESIS\nassign out = DEFAULT;\n`else\n `ifdef verilator\nassign out = DEFAULT;\n`else   \nreg [31:0] myplus;\nassign out = myplus;\n\ninitial begin\n   if (!$value$plusargs(FORMAT, myplus)) myplus = DEFAULT;\nend\n`endif\n`endif\n\nendmodule\n"}
{"text": "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  ps2.v                                                       ////\n////                                                              ////\n////  This file is part of the \"ps2\" project                      ////\n////  http://www.opencores.org/cores/ps2/                         ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - mihad@opencores.org                                   ////\n////      - Miha Dolenc                                           ////\n////                                                              ////\n////  All additional information is avaliable in the README.txt   ////\n////  file.                                                       ////\n////                                                              ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Miha Dolenc, mihad@opencores.org          ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n\nmodule ps2(clk, rst,\n           PS2_K_CLK_IO, PS2_K_DATA_IO, PS2_M_CLK_IO, PS2_M_DATA_IO,\n           rx_scan_read, rx_released, rx_scan_ready, rx_scan_code, tx_error_no_keyboard_ack);\n\n   input clk, rst;\n   input rx_scan_read;\n\n   inout PS2_K_CLK_IO;\n   inout PS2_K_DATA_IO;\n   inout PS2_M_CLK_IO;\n   inout PS2_M_DATA_IO;\n\n   output rx_scan_ready, rx_released, tx_error_no_keyboard_ack;\n   output [7:0] rx_scan_code;\n\n   wire             ps2_k_clk_en_o_ ;\n   wire             ps2_k_data_en_o_ ;\n   wire             ps2_k_clk_i ;\n   wire             ps2_k_data_i ;\n\n   wire             rx_released;\n   wire [7:0]       rx_scan_code;\n   wire             rx_scan_read;\n   wire             rx_scan_ready;\n   reg [7:0]        tx_data;\n   reg              tx_write;\n   wire             tx_write_ack_o;\n   wire             tx_error_no_keyboard_ack;\n   wire [15:0]      divide_reg = 13000;\n\n   io_buffer_generic IOBUF_k_clk (\n                          .outg(ps2_k_clk_i),     // Buffer output\n                          .inoutg(PS2_K_CLK_IO),   // Buffer inout port (connect directly to top-level port)\n                          .ing(ps2_k_clk_en_o_),     // Buffer input\n                          .ctrl(ps2_k_clk_en_o_)      // 3-state enable input \n                          );\n\n   io_buffer_generic IOBUF_k_data (\n                           .outg(ps2_k_data_i),     // Buffer output\n                           .inoutg(PS2_K_DATA_IO),   // Buffer inout port (connect directly to top-level port)\n                           .ing(ps2_k_data_en_o_),     // Buffer input\n                           .ctrl(ps2_k_data_en_o_)      // 3-state enable input \n                           );\n\n   ps2_keyboard key1(\n                     .clock_i(clk),\n                     .reset_i(rst),\n                     .ps2_clk_en_o_(ps2_k_clk_en_o_),\n                     .ps2_data_en_o_(ps2_k_data_en_o_),\n                     .ps2_clk_i(ps2_k_clk_i),\n                     .ps2_data_i(ps2_k_data_i),\n                     .rx_released(rx_released),\n                     .rx_scan_code(rx_scan_code),\n                     .rx_data_ready(rx_scan_ready),       // rx_read_o\n                     .rx_read(rx_scan_read),             // rx_read_ack_i\n                     .tx_data(tx_data),\n                     .tx_write(tx_write),\n                     .tx_write_ack_o(tx_write_ack_o),\n                     .tx_error_no_keyboard_ack(tx_error_no_keyboard_ack),\n                     .divide_reg_i(divide_reg)\n                     );\n\n   wire ps2_m_clk_en_o_ ;\n   wire ps2_m_data_en_o_ ;\n   wire ps2_m_clk_i ;\n   wire ps2_m_data_i ;\n\n   io_buffer_generic IOBUF_m_clk (\n                          .outg(ps2_m_clk_i),     // Buffer output\n                          .inoutg(PS2_M_CLK_IO),   // Buffer inout port (connect directly to top-level port)\n                          .ing(ps2_m_clk_en_o_),     // Buffer input\n                          .ctrl(ps2_m_clk_en_o_)      // 3-state enable input \n                          );\n\n   io_buffer_generic IOBUF_m_data (\n                           .outg(ps2_m_data_i),     // Buffer output\n                           .inoutg(PS2_M_DATA_IO),   // Buffer inout port (connect directly to top-level port)\n                           .ing(ps2_m_data_en_o_),     // Buffer input\n                           .ctrl(ps2_m_data_en_o_)      // 3-state enable input \n                           );\n\nendmodule\n"}
{"text": "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  ps2_defines.v                                               ////\n////                                                              ////\n////  This file is part of the \"ps2\" project                      ////\n////  http://www.opencores.org/cores/ps2/                         ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - mihad@opencores.org                                   ////\n////      - Miha Dolenc                                           ////\n////                                                              ////\n////  All additional information is avaliable in the README.txt   ////\n////  file.                                                       ////\n////                                                              ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Miha Dolenc, mihad@opencores.org          ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// CVS Revision History\n//\n// $Log: not supported by cvs2svn $\n// Revision 1.4  2003/07/01 12:34:03  mihad\n// Added an option to use constant values instead of RAM\n// in the translation table.\n//\n// Revision 1.3  2002/04/09 13:21:15  mihad\n// Added mouse interface and everything for its handling, cleaned up some unused code\n//\n// Revision 1.2  2002/02/18 16:33:08  mihad\n// Changed defines for simulation to work without xilinx primitives\n//\n// Revision 1.1.1.1  2002/02/18 16:16:56  mihad\n// Initial project import - working\n//\n//\n\n//`define PS2_RAMB4\n`define PS2_CONSTANTS_ROM\n\n`define PS2_TRANSLATION_TABLE_31_0    256'h5b03111e1f2c71665a02101d702a386559290f3e40424464583c3b3d3f4143ff\n`define PS2_TRANSLATION_TABLE_63_32   256'h5f0908162432726a5e071522233031695d061314212f39685c040512202d2e67\n`define PS2_TRANSLATION_TABLE_95_64   256'h76632b751b1c363a6e620d1a7428736d610c19272635346c600a0b181725336b\n`define PS2_TRANSLATION_TABLE_127_96  256'h544649374a514e574501484d4c5053526f7f7e474b7d4f7c7b0e7a7978775655\n`define PS2_TRANSLATION_TABLE_159_128 256'h9f9e9d9c9b9a999897969594939291908f8e8d8c8b8a89888786855441828180\n`define PS2_TRANSLATION_TABLE_191_160 256'hbfbebdbcbbbab9b8b7b6b5b4b3b2b1b0afaeadacabaaa9a8a7a6a5a4a3a2a1a0\n`define PS2_TRANSLATION_TABLE_223_192 256'hdfdedddcdbdad9d8d7d6d5d4d3d2d1d0cfcecdcccbcac9c8c7c6c5c4c3c2c1c0\n`define PS2_TRANSLATION_TABLE_255_224 256'hfffefdfcfbfaf9f8f7f6f5f4f3f2f1f0efeeedecebeae9e8e7e6e5e4e3e2e1e0\n\n`define PS2_TIMER_60USEC_VALUE_PP 12  // Number of sys_clks for 60usec.\n`define PS2_TIMER_60USEC_BITS_PP  4    // Number of bits needed for timer\n`define PS2_TIMER_5USEC_VALUE_PP 500    // Number of sys_clks for debounce\n`define PS2_TIMER_5USEC_BITS_PP 16       // Number of bits needed for timer\n\n//`define PS2_AUX\n"}
{"text": "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  ps2_keyboard.v                                              ////\n////                                                              ////\n////  This file is part of the \"ps2\" project                      ////\n////  http://www.github.com/freecores/ps2/                         ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - John Clayton                                          ////\n////                                                              ////\n////  All additional information is avaliable in the README.txt   ////\n////  file.                                                       ////\n////                                                              ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2001 John Clayton                              ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//-------------------------------------------------------------------------------------\n//\n// Author: John Clayton\n// Date  : April 30, 2001\n// Update: 4/30/01 copied this file from lcd_2.v (pared down).\n// Update: 5/24/01 changed the first module from \"ps2_keyboard_receiver\"\n//                 to \"ps2_keyboard_interface\"\n// Update: 5/29/01 Added input synchronizing flip-flops.  Changed state\n//                 encoding (m1) for good operation after part config.\n// Update: 5/31/01 Added low drive strength and slow transitions to ps2_clk\n//                 and ps2_data in the constraints file.  Added the signal\n//                 \"tx_shifting_done\" as distinguished from \"rx_shifting_done.\"\n//                 Debugged the transmitter portion in the lab.\n// Update: 6/01/01 Added horizontal tab to the ascii output.\n// Update: 6/01/01 Added parameter TRAP_SHIFT_KEYS.\n// Update: 6/05/01 Debugged the \"debounce\" timer functionality.\n//                 Used 60usec timer as a \"watchdog\" timeout during\n//                 receive from the keyboard.  This means that a keyboard\n//                 can now be \"hot plugged\" into the interface, without\n//                 messing up the bit_count, since the bit_count is reset\n//                 to zero during periods of inactivity anyway.  This was\n//                 difficult to debug.  I ended up using the logic analyzer,\n//                 and had to scratch my head quite a bit.\n// Update: 6/06/01 Removed extra comments before the input synchronizing\n//                 flip-flops.  Used the correct parameter to size the\n//                 5usec_timer_count.  Changed the name of this file from\n//                 ps2.v to ps2_keyboard.v\n// Update: 6/06/01 Removed \"&& q[7:0]\" in output_strobe logic.  Removed extra\n//                 commented out \"else\" condition in the shift register and\n//                 bit counter.\n// Update: 6/07/01 Changed default values for 60usec timer parameters so that\n//                 they correspond to 60usec for a 49.152MHz clock.\n//\n//\n//\n//\n//\n// Description\n//-------------------------------------------------------------------------------------\n// This is a state-machine driven serial-to-parallel and parallel-to-serial\n// interface to the ps2 style keyboard interface.  The details of the operation\n// of the keyboard interface were obtained from the following website:\n//\n//   http://www.beyondlogic.org/keyboard/keybrd.htm\n//\n// Some aspects of the keyboard interface are not implemented (e.g, parity\n// checking for the receive side, and recognition of the various commands\n// which the keyboard sends out, such as \"power on selt test passed,\" \"Error\"\n// and \"Resend.\")  However, if the user wishes to recognize these reply\n// messages, the scan code output can always be used to extend functionality\n// as desired.\n//\n// Note that the \"Extended\" (0xE0) and \"Released\" (0xF0) codes are recognized.\n// The rx interface provides separate indicator flags for these two conditions\n// with every valid character scan code which it provides.  The shift keys are\n// also trapped by the interface, in order to provide correct uppercase ASCII\n// characters at the ascii output, although the scan codes for the shift keys\n// are still provided at the scan code output.  So, the left/right ALT keys\n// can be differentiated by the presence of the rx_entended signal, while the\n// left/right shift keys are differentiable by the different scan codes\n// received.\n//\n// The interface to the ps2 keyboard uses ps2_clk clock rates of\n// 30-40 kHz, dependent upon the keyboard itself.  The rate at which the state\n// machine runs should be at least twice the rate of the ps2_clk, so that the\n// states can accurately follow the clock signal itself.  Four times\n// oversampling is better.  Say 200kHz at least.  The upper limit for clocking\n// the state machine will undoubtedly be determined by delays in the logic\n// which decodes the scan codes into ASCII equivalents.  The maximum speed\n// will be most likely many megahertz, depending upon target technology.\n// In order to run the state machine extremely fast, synchronizing flip-flops\n// have been added to the ps2_clk and ps2_data inputs of the state machine.\n// This avoids poor performance related to slow transitions of the inputs.\n//\n// Because this is a bi-directional interface, while reading from the keyboard\n// the ps2_clk and ps2_data lines are used as inputs.  While writing to the\n// keyboard, however (which may be done at any time.  If writing interrupts a\n// read from the keyboard, the keyboard will buffer up its data, and send\n// it later) both the ps2_clk and ps2_data lines are occasionally pulled low,\n// and pullup resistors are used to bring the lines high again, by setting\n// the drivers to high impedance state.\n//\n// The tx interface, for writing to the keyboard, does not provide any special\n// pre-processing.  It simply transmits the 8-bit command value to the\n// keyboard.\n//\n// Pullups MUST BE USED on the ps2_clk and ps2_data lines for this design,\n// whether they be internal to an FPGA I/O pad, or externally placed.\n// If internal pullups are used, they may be fairly weak, causing bounces\n// due to crosstalk, etc.  There is a \"debounce timer\" implemented in order\n// to eliminate erroneous state transitions which would occur based on bounce.\n//\n// Parameters are provided in order to configure and appropriately size the\n// counter of a 60 microsecond timer used in the transmitter, depending on\n// the clock frequency used.  The 60 microsecond period is guaranteed to be\n// more than one period of the ps2_clk_s signal.\n//\n// Also, a smaller 5 microsecond timer has been included for \"debounce\".\n// This is used because, with internal pullups on the ps2_clk and ps2_data\n// lines, there is some bouncing around which occurs\n//\n// A parameter TRAP_SHIFT_KEYS allows the user to eliminate shift keypresses\n// from producing scan codes (along with their \"undefined\" ASCII equivalents)\n// at the output of the interface.  If TRAP_SHIFT_KEYS is non-zero, the shift\n// key status will only be reported by rx_shift_key_on.  No ascii or scan\n// codes will be reported for the shift keys.  This is useful for those who\n// wish to use the ASCII data stream, and who don't want to have to \"filter\n// out\" the shift key codes.\n//\n//-------------------------------------------------------------------------------------\n\n\n// synopsys translate_off\n//`include \"timescale.v\"\n// synopsys translate_on\n`define TOTAL_BITS   11\n`define RELEASE_CODE 16'hF0\n\nmodule ps2_keyboard (\n                     clock_i,\n                     reset_i,\n                     ps2_clk_en_o_,\n                     ps2_data_en_o_,\n                     ps2_clk_i,\n                     ps2_data_i,\n                     rx_released,\n                     rx_scan_code,\n                     rx_data_ready,       // rx_read_o\n                     rx_read,             // rx_read_ack_i\n                     tx_data,\n                     tx_write,\n                     tx_write_ack_o,\n                     tx_error_no_keyboard_ack,\n                     divide_reg_i\n                     );\n\n   // Parameters\n\n\n   // The timer value can be up to (2^bits) inclusive.\n   parameter TIMER_60USEC_VALUE_PP = 2950; // Number of sys_clks for 60usec.\n   parameter TIMER_60USEC_BITS_PP  = 12;   // Number of bits needed for timer\n   parameter TIMER_5USEC_VALUE_PP = 186;   // Number of sys_clks for debounce\n   parameter TIMER_5USEC_BITS_PP  = 8;     // Number of bits needed for timer\n\n   // State encodings, provided as parameters\n   // for flexibility to the one instantiating the module.\n   // In general, the default values need not be changed.\n\n   // State \"m1_rx_clk_l\" has been chosen on purpose.  Since the input\n   // synchronizing flip-flops initially contain zero, it takes one clk\n   // for them to update to reflect the actual (idle = high) status of\n   // the I/O lines from the keyboard.  Therefore, choosing 0 for m1_rx_clk_l\n   // allows the state machine to transition to m1_rx_clk_h when the true\n   // values of the input signals become present at the outputs of the\n   // synchronizing flip-flops.  This initial transition is harmless, and it\n   // eliminates the need for a \"reset\" pulse before the interface can operate.\n\n   parameter m1_rx_clk_h = 1;\n   parameter m1_rx_clk_l = 0;\n   parameter m1_rx_falling_edge_marker = 13;\n   parameter m1_rx_rising_edge_marker = 14;\n   parameter m1_tx_force_clk_l = 3;\n   parameter m1_tx_first_wait_clk_h = 10;\n   parameter m1_tx_first_wait_clk_l = 11;\n   parameter m1_tx_reset_timer = 12;\n   parameter m1_tx_wait_clk_h = 2;\n   parameter m1_tx_clk_h = 4;\n   parameter m1_tx_clk_l = 5;\n   parameter m1_tx_wait_keyboard_ack = 6;\n   parameter m1_tx_done_recovery = 7;\n   parameter m1_tx_error_no_keyboard_ack = 8;\n   parameter m1_tx_rising_edge_marker = 9;\n   parameter m2_rx_data_ready = 1;\n   parameter m2_rx_data_ready_ack = 0;\n\n\n   // I/O declarations\n   input wire clock_i;\n   input wire reset_i;\n   output wire ps2_clk_en_o_ ;\n   output wire ps2_data_en_o_ ;\n   input  wire ps2_clk_i ;\n   input  wire ps2_data_i ;\n   output rx_released;\n   output [7:0] rx_scan_code;\n   output       rx_data_ready;\n   input        wire rx_read;\n   input [7:0]  tx_data;\n   input        wire tx_write;\n   output       wire tx_write_ack_o;\n   output       reg tx_error_no_keyboard_ack;\n\n   input [15:0] divide_reg_i;\n\n   reg          rx_released;\n   reg [7:0]    rx_scan_code;\n   reg          rx_data_ready;\n \n   // Internal signal declarations\n   wire         timer_60usec_done;\n   wire         timer_5usec_done;\n   wire         released;\n\n   // NOTE: These two signals used to be one.  They\n   //       were split into two signals because of\n   //       shift key trapping.  With shift key\n   //       trapping, no event is generated externally,\n   //       but the \"hold\" data must still be cleared\n   //       anyway regardless, in preparation for the\n   //       next scan codes.\n   wire         rx_output_event;    // Used only to clear: hold_released, hold_extended\n   wire         rx_output_strobe;   // Used to produce the actual output.\n\n   wire         tx_parity_bit;\n   wire         rx_shifting_done;\n   wire         tx_shifting_done;\n\n   reg [`TOTAL_BITS-1:0] q;\n   reg [3:0]             m1_state;\n   reg [3:0]             m1_next_state;\n   reg                   m2_state;\n   reg                   m2_next_state;\n   reg [3:0]             bit_count;\n   reg                   enable_timer_60usec;\n   reg                   enable_timer_5usec;\n   reg [TIMER_60USEC_BITS_PP-1:0] timer_60usec_count;\n   reg [TIMER_5USEC_BITS_PP-1:0]  timer_5usec_count;\n   reg                            hold_released;    // Holds prior value, cleared at rx_output_strobe\n   reg                            ps2_clk_s;        // Synchronous version of this input\n   reg                            ps2_data_s;       // Synchronous version of this input\n   reg                            ps2_clk_hi_z;     // Without keyboard, high Z equals 1 due to pullups.\n   reg                            ps2_data_hi_z;    // Without keyboard, high Z equals 1 due to pullups.\n   reg                            ps2_clk_ms;\n   reg                            ps2_data_ms;\n\n\n   reg [15:0]                     timer_5usec;\n   reg                            timer_done;\n\n\n\n   //--------------------------------------------------------------------------\n   // Module code\n\n   assign ps2_clk_en_o_  = ps2_clk_hi_z  ;\n   assign ps2_data_en_o_ = ps2_data_hi_z ;\n\n   // Input \"synchronizing\" logic -- synchronizes the inputs to the state\n   // machine clock, thus avoiding errors related to\n   // spurious state machine transitions.\n   always @(posedge clock_i)\n     begin\n        ps2_clk_ms <= #1 ps2_clk_i;\n        ps2_data_ms <= #1  ps2_data_i;\n\n        ps2_clk_s <= #1 ps2_clk_ms;\n        ps2_data_s <= #1 ps2_data_ms;\n\n     end\n\n   // State register\n   always @(posedge clock_i) // or posedge reset_i)\n     begin : m1_state_register\n        if (reset_i) m1_state <= #1 m1_rx_clk_h;\n        else m1_state <= #1 m1_next_state;\n     end\n\n   // State transition logic\n   always @(m1_state\n            or q\n            or tx_shifting_done\n            or tx_write\n            or ps2_clk_s\n            or ps2_data_s\n            or timer_60usec_done\n            or timer_5usec_done\n            )\n     begin : m1_state_logic\n\n        // Output signals default to this value, unless changed in a state condition.\n        ps2_clk_hi_z <= #1 1;\n        ps2_data_hi_z <= #1 1;\n        tx_error_no_keyboard_ack <= #1 1'b0;\n        enable_timer_60usec <= #1 0;\n        enable_timer_5usec <= #1 0;\n\n        case (m1_state)\n\n          m1_rx_clk_h :\n            begin\n               enable_timer_60usec <= #1 1;\n               if (tx_write) m1_next_state <= #1 m1_tx_reset_timer;\n               else if (~ps2_clk_s) m1_next_state <= #1 m1_rx_falling_edge_marker;\n               else m1_next_state <= #1 m1_rx_clk_h;\n            end\n\n          m1_rx_falling_edge_marker :\n            begin\n               enable_timer_60usec <= #1 0;\n               m1_next_state <= #1 m1_rx_clk_l;\n            end\n\n          m1_rx_rising_edge_marker :\n            begin\n               enable_timer_60usec <= #1 0;\n               m1_next_state <= #1 m1_rx_clk_h;\n            end\n\n\n          m1_rx_clk_l :\n            begin\n               enable_timer_60usec <= #1 1;\n               if (tx_write) m1_next_state <= #1 m1_tx_reset_timer;\n               else if (ps2_clk_s) m1_next_state <= #1 m1_rx_rising_edge_marker;\n               else m1_next_state <= #1 m1_rx_clk_l;\n            end\n\n          m1_tx_reset_timer:\n            begin\n               enable_timer_60usec <= #1 0;\n               m1_next_state <= #1 m1_tx_force_clk_l;\n            end\n\n          m1_tx_force_clk_l :\n            begin\n               enable_timer_60usec <= #1 1;\n               ps2_clk_hi_z <= #1 0;  // Force the ps2_clk line low.\n               if (timer_60usec_done) m1_next_state <= #1 m1_tx_first_wait_clk_h;\n               else m1_next_state <= #1 m1_tx_force_clk_l;\n            end\n\n          m1_tx_first_wait_clk_h :\n            begin\n               enable_timer_5usec <= #1 1;\n               ps2_data_hi_z <= #1 0;        // Start bit.\n               if (~ps2_clk_s && timer_5usec_done)\n                 m1_next_state <= #1 m1_tx_clk_l;\n               else\n                 m1_next_state <= #1 m1_tx_first_wait_clk_h;\n            end\n\n          // This state must be included because the device might possibly\n          // delay for up to 10 milliseconds before beginning its clock pulses.\n          // During that waiting time, we cannot drive the data (q[0]) because it\n          // is possibly 1, which would cause the keyboard to abort its receive\n          // and the expected clocks would then never be generated.\n          m1_tx_first_wait_clk_l :\n            begin\n               ps2_data_hi_z <= #1 0;\n               if (~ps2_clk_s) m1_next_state <= #1 m1_tx_clk_l;\n               else m1_next_state <= #1 m1_tx_first_wait_clk_l;\n            end\n\n          m1_tx_wait_clk_h :\n            begin\n               enable_timer_5usec <= #1 1;\n               ps2_data_hi_z <= #1 q[0];\n               if (ps2_clk_s && timer_5usec_done)\n                 m1_next_state <= #1 m1_tx_rising_edge_marker;\n               else\n                 m1_next_state <= #1 m1_tx_wait_clk_h;\n            end\n\n          m1_tx_rising_edge_marker :\n            begin\n               ps2_data_hi_z <= #1 q[0];\n               m1_next_state <= #1 m1_tx_clk_h;\n            end\n\n          m1_tx_clk_h :\n            begin\n               ps2_data_hi_z <= #1 q[0];\n               if (tx_shifting_done) m1_next_state <= #1 m1_tx_wait_keyboard_ack;\n               else if (~ps2_clk_s) m1_next_state <= #1 m1_tx_clk_l;\n               else m1_next_state <= #1 m1_tx_clk_h;\n            end\n\n          m1_tx_clk_l :\n            begin\n               ps2_data_hi_z <= #1 q[0];\n               if (ps2_clk_s) m1_next_state <= #1 m1_tx_wait_clk_h;\n               else m1_next_state <= #1 m1_tx_clk_l;\n            end\n\n          m1_tx_wait_keyboard_ack :\n            begin\n               if (~ps2_clk_s && ps2_data_s)\n                 m1_next_state <= #1 m1_tx_error_no_keyboard_ack;\n               else if (~ps2_clk_s && ~ps2_data_s)\n                 m1_next_state <= #1 m1_tx_done_recovery;\n               else m1_next_state <= #1 m1_tx_wait_keyboard_ack;\n            end\n\n          m1_tx_done_recovery :\n            begin\n               if (ps2_clk_s && ps2_data_s) m1_next_state <= #1 m1_rx_clk_h;\n               else m1_next_state <= #1 m1_tx_done_recovery;\n            end\n\n          m1_tx_error_no_keyboard_ack :\n            begin\n               tx_error_no_keyboard_ack <= #1 1;\n               if (ps2_clk_s && ps2_data_s) m1_next_state <= #1 m1_rx_clk_h;\n               else m1_next_state <= #1 m1_tx_error_no_keyboard_ack;\n            end\n\n          default : m1_next_state <= #1 m1_rx_clk_h;\n        endcase\n     end\n\n   // State register\n   always @(posedge clock_i) // or posedge reset_i)\n     begin : m2_state_register\n        if (reset_i) m2_state <= #1 m2_rx_data_ready_ack;\n        else "}
{"text": "m2_state <= #1 m2_next_state;\n     end\n\n   // State transition logic\n   always @(m2_state or rx_output_strobe or rx_read)\n     begin : m2_state_logic\n        case (m2_state)\n          m2_rx_data_ready_ack:\n            begin\n               rx_data_ready <= #1 1'b0;\n               if (rx_output_strobe) m2_next_state <= #1 m2_rx_data_ready;\n               else m2_next_state <= #1 m2_rx_data_ready_ack;\n            end\n          m2_rx_data_ready:\n            begin\n               rx_data_ready <= #1 1'b1;\n               if (rx_read) m2_next_state <= #1 m2_rx_data_ready_ack;\n               else m2_next_state <= #1 m2_rx_data_ready;\n            end\n          default : m2_next_state <= #1 m2_rx_data_ready_ack;\n        endcase\n     end\n\n   // This is the bit counter\n   always @(posedge clock_i) // or posedge reset_i)\n     begin\n        if ( reset_i) bit_count <= #1 0;\n        else if ( rx_shifting_done || (m1_state == m1_tx_wait_keyboard_ack)        // After tx is done.\n                  ) bit_count <= #1 0;  // normal reset\n        else if (timer_60usec_done\n                 && (m1_state == m1_rx_clk_h)\n                 && (ps2_clk_s)\n                 ) bit_count <= #1 0;  // rx watchdog timer reset\n        else if ( (m1_state == m1_rx_falling_edge_marker)   // increment for rx\n                  ||(m1_state == m1_tx_rising_edge_marker)   // increment for tx\n                  )\n          bit_count <= #1 bit_count + 1;\n     end\n   // This signal is high for one clock at the end of the timer count.\n   assign rx_shifting_done = (bit_count == `TOTAL_BITS);\n   assign tx_shifting_done = (bit_count == `TOTAL_BITS-1);\n\n   // This is the signal which enables loading of the shift register.\n   // It also indicates \"ack\" to the device writing to the transmitter.\n   assign tx_write_ack_o = (  (tx_write && (m1_state == m1_rx_clk_h))\n                              ||(tx_write && (m1_state == m1_rx_clk_l))\n                              );\n\n   // This is the ODD parity bit for the transmitted word.\n   assign tx_parity_bit = ~^tx_data;\n\n   // This is the shift register\n   always @(posedge clock_i) // or posedge reset_i)\n     begin\n        if (reset_i) q <= #1 0;\n        else if (tx_write_ack_o) q <= #1 {1'b1,tx_parity_bit,tx_data,1'b0};\n        else if ( (m1_state == m1_rx_falling_edge_marker)\n                  ||(m1_state == m1_tx_rising_edge_marker) )\n          q <= #1 {ps2_data_s,q[`TOTAL_BITS-1:1]};\n     end\n\n   // This is the 60usec timer counter\n   always @(posedge clock_i)\n     begin\n        if (~enable_timer_60usec) timer_60usec_count <= #1 0;\n        else if ( timer_done && !timer_60usec_done)\n          timer_60usec_count<= #1 timer_60usec_count +1;\n     end\n   assign timer_60usec_done = (timer_60usec_count == (TIMER_60USEC_VALUE_PP ));\n\n\n\n   always @(posedge clock_i) // or posedge reset_i)\n     if (reset_i) timer_5usec <= #1 1;\n     else if (!enable_timer_60usec) timer_5usec <= #1 1;\n     else if (timer_5usec == divide_reg_i) \n       begin\n          timer_5usec <= #1 1;\n          timer_done  <= #1 1;\n       end\n     else \n       begin\n          timer_5usec<= #1 timer_5usec +1;\n          timer_done  <= #1 0;\n       end\n\n   // This is the 5usec timer counter\n   always @(posedge clock_i)\n     begin\n        if (~enable_timer_5usec) timer_5usec_count <= #1 0;\n        else if (~timer_5usec_done) timer_5usec_count <= #1 timer_5usec_count + 1;\n     end\n   assign timer_5usec_done = (timer_5usec_count == divide_reg_i -1);\n\n\n   // Create the signals which indicate special scan codes received.\n   // These are the \"unlatched versions.\"\n   assign released = (q[8:1] == `RELEASE_CODE) && rx_shifting_done;\n\n   // Store the special scan code status bits\n   // Not the final output, but an intermediate storage place,\n   // until the entire set of output data can be assembled.\n   always @(posedge clock_i) // or posedge reset_i)\n     begin\n        if (reset_i) hold_released <= #1 0;\n        else if (rx_output_event)\n          begin\n             hold_released <= #1 0;\n          end\n        else\n          begin\n             if (rx_shifting_done && released) hold_released <= #1 1;\n          end\n     end\n\n   // Output the special scan code flags, the scan code and the ascii\n   always @(posedge clock_i) // or posedge reset_i)\n     begin\n        if (reset_i)\n          begin\n             rx_released <= #1 0;\n             rx_scan_code <= #1 0;\n          end\n        else if (rx_output_strobe)\n          begin\n             rx_released <= #1 hold_released;\n             rx_scan_code <= #1 q[8:1];\n          end\n     end\n\n   // Store the final rx output data only when all extend and release codes\n   // are received and the next (actual key) scan code is also ready.\n   // (the presence of rx_extended or rx_released refers to the\n   // the current latest scan code received, not the previously latched flags.)\n   assign rx_output_event  = (rx_shifting_done\n                              && ~released\n                              );\n\n   assign rx_output_strobe = (rx_shifting_done\n                              && ~released\n                              );\n\nendmodule\n\n//`undefine TOTAL_BITS\n//`undefine EXTEND_CODE\n//`undefine RELEASE_CODE\n//`undefine LEFT_SHIFT\n//`undefine RIGHT_SHIFT\n\n"}
{"text": "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n////  ps2_translation_table.v                                     ////\n////                                                              ////\n////  This file is part of the \"ps2\" project                      ////\n////  https://github.com/freecores/ps2/verilog                    ////\n////                                                              ////\n////  Author(s):                                                  ////\n////      - mihad@opencores.org                                   ////\n////      - Miha Dolenc                                           ////\n////                                                              ////\n////  All additional information is avaliable in the README.txt   ////\n////  file.                                                       ////\n////                                                              ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2000 Miha Dolenc, mihad@opencores.org          ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE.  See the GNU Lesser General Public License for more ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n//\n// CVS Revision History\n//\n// $Log: not supported by cvs2svn $\n// Revision 1.3  2003/06/02 17:13:22  simons\n// resetall keyword removed. ifdef moved to a separated line.\n//\n// Revision 1.2  2002/04/09 13:21:15  mihad\n// Added mouse interface and everything for its handling, cleaned up some unused code\n//\n// Revision 1.1.1.1  2002/02/18 16:16:56  mihad\n// Initial project import - working\n//\n//\n\n`include \"ps2_defines.v\"\n\n// synopsys translate_off\n//`include \"timescale.v\"\n// synopsys translate_on\n\nmodule ps2_translation_table\n  (\n   reset_i,\n   clock_i,\n   translate_i,\n   code_i,\n   code_o,\n   address_i,\n   data_i,\n   we_i,\n   re_i,\n   data_o,\n   rx_data_ready_i,\n   rx_translated_data_ready_o,\n   rx_read_i,\n   rx_read_o,\n   rx_released_i\n   ) ;\n\n   input wire reset_i,\n         clock_i,\n         translate_i ;\n\n   input [7:0] code_i ;\n   output [7:0] code_o ;\n   input [7:0]  address_i ;\n   input [7:0]  data_i ;\n   input        wire we_i,\n                re_i ;\n\n   output [7:0] data_o ;\n\n   input        wire rx_data_ready_i,\n                rx_read_i ;\n\n   output       wire rx_translated_data_ready_o ;\n   output       wire rx_read_o ;\n\n   input        wire rx_released_i ;\n\n   wire         translation_table_write_enable  = we_i && (!translate_i || !rx_data_ready_i) ;\n   wire [7:0]   translation_table_address = ((we_i || re_i) && (!rx_data_ready_i || !translate_i)) ? address_i : code_i ;\n   wire         translation_table_enable        = we_i || re_i || (translate_i && rx_data_ready_i) ;\n\n   reg          rx_translated_data_ready ;\n   always@(posedge clock_i) // or posedge reset_i)\n     begin\n        if ( reset_i )\n          rx_translated_data_ready <= #1 1'b0 ;\n        else if ( rx_read_i || !translate_i )\n          rx_translated_data_ready <= #1 1'b0 ;\n        else\n          rx_translated_data_ready <= #1 rx_data_ready_i ;\n     end\n\n`ifdef PS2_RAMB4\n `define PS2_RAM_SELECTED\n\n   wire [7:0] ram_out ;\n   RAMB4_S8 \n `ifdef SIM\n     #(\"ignore\",\n       `PS2_TRANSLATION_TABLE_31_0,\n       `PS2_TRANSLATION_TABLE_63_32,\n       `PS2_TRANSLATION_TABLE_95_64,\n       `PS2_TRANSLATION_TABLE_127_96,\n       `PS2_TRANSLATION_TABLE_159_128,\n       `PS2_TRANSLATION_TABLE_191_160,\n       `PS2_TRANSLATION_TABLE_223_192,\n       `PS2_TRANSLATION_TABLE_255_224)\n `endif\n   ps2_ram\n     (\n      .DO   (ram_out),\n      .ADDR ({1'b0, translation_table_address}),\n      .DI   (data_i),\n      .EN   (translation_table_enable),\n      .CLK  (clock_i),\n      .WE   (translation_table_write_enable),\n      .RST  (reset_i)\n      ) ;\n\n`endif\n\n`ifdef PS2_CONSTANTS_ROM\n `define PS2_RAM_SELECTED\n\n   reg [32 * 8 - 1:0] ps2_32byte_constant ;\n   reg [7:0]          ram_out ;\n\n   always@(translation_table_address)\n     begin\n        case (translation_table_address[7:5])\n          3'b000:ps2_32byte_constant = `PS2_TRANSLATION_TABLE_31_0    ;\n          3'b001:ps2_32byte_constant = `PS2_TRANSLATION_TABLE_63_32   ;\n          3'b010:ps2_32byte_constant = `PS2_TRANSLATION_TABLE_95_64   ;\n          3'b011:ps2_32byte_constant = `PS2_TRANSLATION_TABLE_127_96  ;\n          3'b100:ps2_32byte_constant = `PS2_TRANSLATION_TABLE_159_128 ;\n          3'b101:ps2_32byte_constant = `PS2_TRANSLATION_TABLE_191_160 ;\n          3'b110:ps2_32byte_constant = `PS2_TRANSLATION_TABLE_223_192 ;\n          3'b111:ps2_32byte_constant = `PS2_TRANSLATION_TABLE_255_224 ;\n        endcase\n     end\n\n   always@(posedge clock_i) // or posedge reset_i)\n     begin\n        if ( reset_i )\n          ram_out <= #1 8'h0 ;\n        else if ( translation_table_enable )\n          begin:get_dat_out\n             reg [7:0] bit_num ;\n             \n             bit_num = translation_table_address[4:0] << 3 ;\n\n             repeat(8)\n               begin\n                  ram_out[bit_num % 8] <= #1 ps2_32byte_constant[bit_num] ;\n                  bit_num = bit_num + 1'b1 ;\n               end\n          end\n     end\n\n`endif\n\n`ifdef PS2_RAM_SELECTED\n`else\n `define PS2_RAM_SELECTED\n\n   reg [7:0] ps2_ram [0:255] ;\n   reg [7:0] ram_out ;\n\n   always@(posedge clock_i) // or posedge reset_i)\n     begin\n        if ( reset_i )\n          ram_out <= #1 8'h0 ;\n        else if ( translation_table_enable )\n          ram_out <= #1 ps2_ram[translation_table_address] ;\n     end\n\n   always@(posedge clock_i)\n     begin\n        if ( translation_table_write_enable )\n          ps2_ram[translation_table_address] <= #1 data_i ;\n     end\n\n   // synopsys translate_off\n   initial\n     begin:ps2_ram_init\n        integer i ;\n        reg [255:0] temp_init_val ;\n\n        temp_init_val = `PS2_TRANSLATION_TABLE_31_0 ;\n\n        for ( i = 0 ; i <= 31 ; i = i + 1 )\n          begin\n             ps2_ram[i] = temp_init_val[7:0] ;\n             temp_init_val = temp_init_val >> 8 ;\n          end\n\n        temp_init_val = `PS2_TRANSLATION_TABLE_63_32 ;\n\n        for ( i = 32 ; i <= 63 ; i = i + 1 )\n          begin\n             ps2_ram[i] = temp_init_val[7:0] ;\n             temp_init_val = temp_init_val >> 8 ;\n          end\n\n        temp_init_val = `PS2_TRANSLATION_TABLE_95_64 ;\n\n        for ( i = 64 ; i <= 95 ; i = i + 1 )\n          begin\n             ps2_ram[i] = temp_init_val[7:0] ;\n             temp_init_val = temp_init_val >> 8 ;\n          end\n\n        temp_init_val = `PS2_TRANSLATION_TABLE_127_96 ;\n\n        for ( i = 96 ; i <= 127 ; i = i + 1 )\n          begin\n             ps2_ram[i] = temp_init_val[7:0] ;\n             temp_init_val = temp_init_val >> 8 ;\n          end\n\n        temp_init_val = `PS2_TRANSLATION_TABLE_159_128 ;\n\n        for ( i = 128 ; i <= 159 ; i = i + 1 )\n          begin\n             ps2_ram[i] = temp_init_val[7:0] ;\n             temp_init_val = temp_init_val >> 8 ;\n          end\n\n        temp_init_val = `PS2_TRANSLATION_TABLE_191_160 ;\n\n        for ( i = 160 ; i <= 191 ; i = i + 1 )\n          begin\n             ps2_ram[i] = temp_init_val[7:0] ;\n             temp_init_val = temp_init_val >> 8 ;\n          end\n\n        temp_init_val = `PS2_TRANSLATION_TABLE_223_192 ;\n\n        for ( i = 192 ; i <= 223 ; i = i + 1 )\n          begin\n             ps2_ram[i] = temp_init_val[7:0] ;\n             temp_init_val = temp_init_val >> 8 ;\n          end\n\n        temp_init_val = `PS2_TRANSLATION_TABLE_255_224 ;\n\n        for ( i = 224 ; i <= 255 ; i = i + 1 )\n          begin\n             ps2_ram[i] = temp_init_val[7:0] ;\n             temp_init_val = temp_init_val >> 8 ;\n          end\n     end\n\n   // synopsys translate_on\n\n`endif\n\n   assign data_o = ram_out ;\n   assign code_o = translate_i ? {(rx_released_i | ram_out[7]), ram_out[6:0]} : code_i ;\n   assign rx_translated_data_ready_o = translate_i ? rx_translated_data_ready : rx_data_ready_i ;\n   assign rx_read_o = rx_read_i ;\n\n`undef PS2_RAM_SELECTED\n\nendmodule //ps2_translation_table\n"}
{"text": "/*\nCopyright 2015-2017 University of Cambridge\nCopyright and related rights are licensed under the Solderpad Hardware\nLicense, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\ncompliance with the License. You may obtain a copy of the License at\nhttp://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\nor agreed to in writing, software, hardware and materials distributed under\nthis License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\nCONDITIONS OF ANY KIND, either express or implied. See the License for the\nspecific language governing permissions and limitations under the License.\n*/\n\n// ASCII character set ROM (like the good old RO-3-2513)\n\nmodule chargen_7x5_rachel(input clk, input [7:0] ascii, input[3:0] row, output [7:0] pixels_out,\n                          input font_clk, output[7:0] font_out, input [10:0] font_addr, input [7:0] font_in,\n                          input font_en, input font_we);\n`ifndef FPGA\n\n   reg[7:0] lower [0:32*12-1];\n   reg[7:0] upper [0:64*8-1];\n   reg inverse;\n   wire [5:0] char6 = ascii[5:0];\n   wire[15:0] l_address = (ascii[4:0] ^ 0) * 12 + row; // 32 chars in lower case generator.\n   wire[15:0] u_address = (ascii[5:0] ^ 32) * 8 + row; // 64 chars in upper case generator\n   reg [7:0] ld, ud;\n   reg [1:0] sel;\n   reg blank_upper, blank_lower;\n   always @(posedge clk) begin\n      ld <= lower [l_address];\n      ud <= upper [u_address];      \n      sel <= ascii[6:5];\n      blank_upper <= row >= 8;   // Upper case does not have the extra four lines, so needs blanking.\n      blank_lower <= row >= 12;\n      inverse <= ascii [7];\n   end\n\n   assign pixels_out =  // Msb is first bit to render (leftmost).\n    (inverse ? 8'hff:8'h00) ^\n    ((sel==2'b00) ? (blank_lower ? 8'h00: 8'h3E):// Control chars - display as BLOB\n     (sel==2'b11) ? (blank_lower ? 8'h00: ld):   // Lower case is 0x60 to 0x7F.\n                    (blank_upper ? 8'h00: ud));  // Upper data is from 0x20 to 0x5F (capitals and punctuation)\n\n   initial begin // Initialise ROM.\n lower[12*8'h00 + 0] <= 8'h00; // backtick - ASCII character : ASCII 0x60\n lower[12*8'h00 + 1] <= 8'h00;\n lower[12*8'h00 + 2] <= 8'h20;\n lower[12*8'h00 + 3] <= 8'h10;\n lower[12*8'h00 + 4] <= 8'h08;\n lower[12*8'h00 + 5] <= 8'h00;\n lower[12*8'h00 + 6] <= 8'h00;\n lower[12*8'h00 + 7] <= 8'h00;\n lower[12*8'h00 + 8] <= 8'h00;\n lower[12*8'h00 + 9] <= 8'h00;\n lower[12*8'h00 + 10] <= 8'h00;\n lower[12*8'h00 + 11] <= 8'h00;\n lower[12*8'h01 + 0] <= 8'h00;\n lower[12*8'h01 + 1] <= 8'h00;\n lower[12*8'h01 + 2] <= 8'h00;\n lower[12*8'h01 + 3] <= 8'h30;\n lower[12*8'h01 + 4] <= 8'h08;\n lower[12*8'h01 + 5] <= 8'h04;\n lower[12*8'h01 + 6] <= 8'h3C;\n lower[12*8'h01 + 7] <= 8'h44;\n lower[12*8'h01 + 8] <= 8'h3A;\n lower[12*8'h01 + 9] <= 8'h00;\n lower[12*8'h01 + 10] <= 8'h00;\n lower[12*8'h01 + 11] <= 8'h00;\n lower[12*8'h02 + 0] <= 8'h00;\n lower[12*8'h02 + 1] <= 8'h00;\n lower[12*8'h02 + 2] <= 8'h40;\n lower[12*8'h02 + 3] <= 8'h40;\n lower[12*8'h02 + 4] <= 8'h58;\n lower[12*8'h02 + 5] <= 8'h64;\n lower[12*8'h02 + 6] <= 8'h44;\n lower[12*8'h02 + 7] <= 8'h64;\n lower[12*8'h02 + 8] <= 8'h98;\n lower[12*8'h02 + 9] <= 8'h00;\n lower[12*8'h02 + 10] <= 8'h00;\n lower[12*8'h02 + 11] <= 8'h00;\n lower[12*8'h03 + 0] <= 8'h00;\n lower[12*8'h03 + 1] <= 8'h00;\n lower[12*8'h03 + 2] <= 8'h00;\n lower[12*8'h03 + 3] <= 8'h00;\n lower[12*8'h03 + 4] <= 8'h38;\n lower[12*8'h03 + 5] <= 8'h44;\n lower[12*8'h03 + 6] <= 8'h40;\n lower[12*8'h03 + 7] <= 8'h44;\n lower[12*8'h03 + 8] <= 8'h38;\n lower[12*8'h03 + 9] <= 8'h00;\n lower[12*8'h03 + 10] <= 8'h00;\n lower[12*8'h03 + 11] <= 8'h00;\n lower[12*8'h04 + 0] <= 8'h00;\n lower[12*8'h04 + 1] <= 8'h00;\n lower[12*8'h04 + 2] <= 8'h04;\n lower[12*8'h04 + 3] <= 8'h04;\n lower[12*8'h04 + 4] <= 8'h34;\n lower[12*8'h04 + 5] <= 8'h4C;\n lower[12*8'h04 + 6] <= 8'h44;\n lower[12*8'h04 + 7] <= 8'h4C;\n lower[12*8'h04 + 8] <= 8'h32;\n lower[12*8'h04 + 9] <= 8'h00;\n lower[12*8'h04 + 10] <= 8'h00;\n lower[12*8'h04 + 11] <= 8'h00;\n lower[12*8'h05 + 0] <= 8'h00;\n lower[12*8'h05 + 1] <= 8'h00;\n lower[12*8'h05 + 2] <= 8'h00;\n lower[12*8'h05 + 3] <= 8'h00;\n lower[12*8'h05 + 4] <= 8'h38;\n lower[12*8'h05 + 5] <= 8'h44;\n lower[12*8'h05 + 6] <= 8'h78;\n lower[12*8'h05 + 7] <= 8'h40;\n lower[12*8'h05 + 8] <= 8'h38;\n lower[12*8'h05 + 9] <= 8'h00;\n lower[12*8'h05 + 10] <= 8'h00;\n lower[12*8'h05 + 11] <= 8'h00;\n lower[12*8'h06 + 0] <= 8'h00;\n lower[12*8'h06 + 1] <= 8'h00;\n lower[12*8'h06 + 2] <= 8'h18;\n lower[12*8'h06 + 3] <= 8'h24;\n lower[12*8'h06 + 4] <= 8'h70;\n lower[12*8'h06 + 5] <= 8'h20;\n lower[12*8'h06 + 6] <= 8'h20;\n lower[12*8'h06 + 7] <= 8'h20;\n lower[12*8'h06 + 8] <= 8'h20;\n lower[12*8'h06 + 9] <= 8'h00;\n lower[12*8'h06 + 10] <= 8'h00;\n lower[12*8'h06 + 11] <= 8'h00;\n lower[12*8'h07 + 0] <= 8'h00;\n lower[12*8'h07 + 1] <= 8'h00;\n lower[12*8'h07 + 2] <= 8'h00;\n lower[12*8'h07 + 3] <= 8'h00;\n lower[12*8'h07 + 4] <= 8'h38;\n lower[12*8'h07 + 5] <= 8'h44;\n lower[12*8'h07 + 6] <= 8'h44;\n lower[12*8'h07 + 7] <= 8'h4C;\n lower[12*8'h07 + 8] <= 8'h34;\n lower[12*8'h07 + 9] <= 8'h04;\n lower[12*8'h07 + 10] <= 8'h44;\n lower[12*8'h07 + 11] <= 8'h38;\n lower[12*8'h08 + 0] <= 8'h00;\n lower[12*8'h08 + 1] <= 8'h00;\n lower[12*8'h08 + 2] <= 8'h40;\n lower[12*8'h08 + 3] <= 8'h40;\n lower[12*8'h08 + 4] <= 8'h58;\n lower[12*8'h08 + 5] <= 8'h64;\n lower[12*8'h08 + 6] <= 8'h44;\n lower[12*8'h08 + 7] <= 8'h44;\n lower[12*8'h08 + 8] <= 8'h44;\n lower[12*8'h08 + 9] <= 8'h00;\n lower[12*8'h08 + 10] <= 8'h00;\n lower[12*8'h08 + 11] <= 8'h00;\n lower[12*8'h09 + 0] <= 8'h00;\n lower[12*8'h09 + 1] <= 8'h00;\n lower[12*8'h09 + 2] <= 8'h10;\n lower[12*8'h09 + 3] <= 8'h00;\n lower[12*8'h09 + 4] <= 8'h30;\n lower[12*8'h09 + 5] <= 8'h10;\n lower[12*8'h09 + 6] <= 8'h10;\n lower[12*8'h09 + 7] <= 8'h10;\n lower[12*8'h09 + 8] <= 8'h38;\n lower[12*8'h09 + 9] <= 8'h00;\n lower[12*8'h09 + 10] <= 8'h00;\n lower[12*8'h09 + 11] <= 8'h00;\n lower[12*8'h0A + 0] <= 8'h00;\n lower[12*8'h0A + 1] <= 8'h00;\n lower[12*8'h0A + 2] <= 8'h08;\n lower[12*8'h0A + 3] <= 8'h00;\n lower[12*8'h0A + 4] <= 8'h18;\n lower[12*8'h0A + 5] <= 8'h08;\n lower[12*8'h0A + 6] <= 8'h08;\n lower[12*8'h0A + 7] <= 8'h08;\n lower[12*8'h0A + 8] <= 8'h08;\n lower[12*8'h0A + 9] <= 8'h48;\n lower[12*8'h0A + 10] <= 8'h30;\n lower[12*8'h0A + 11] <= 8'h00;\n lower[12*8'h0B + 0] <= 8'h00;\n lower[12*8'h0B + 1] <= 8'h00;\n lower[12*8'h0B + 2] <= 8'h40;\n lower[12*8'h0B + 3] <= 8'h40;\n lower[12*8'h0B + 4] <= 8'h44;\n lower[12*8'h0B + 5] <= 8'h48;\n lower[12*8'h0B + 6] <= 8'h70;\n lower[12*8'h0B + 7] <= 8'h48;\n lower[12*8'h0B + 8] <= 8'h44;\n lower[12*8'h0B + 9] <= 8'h00;\n lower[12*8'h0B + 10] <= 8'h00;\n lower[12*8'h0B + 11] <= 8'h00;\n lower[12*8'h0C + 0] <= 8'h00;\n lower[12*8'h0C + 1] <= 8'h00;\n lower[12*8'h0C + 2] <= 8'h30;\n lower[12*8'h0C + 3] <= 8'h10;\n lower[12*8'h0C + 4] <= 8'h10;\n lower[12*8'h0C + 5] <= 8'h10;\n lower[12*8'h0C + 6] <= 8'h10;\n lower[12*8'h0C + 7] <= 8'h10;\n lower[12*8'h0C + 8] <= 8'h38;\n lower[12*8'h0C + 9] <= 8'h00;\n lower[12*8'h0C + 10] <= 8'h00;\n lower[12*8'h0C + 11] <= 8'h00;\n lower[12*8'h0D + 0] <= 8'h00;\n lower[12*8'h0D + 1] <= 8'h00;\n lower[12*8'h0D + 2] <= 8'h00;\n lower[12*8'h0D + 3] <= 8'h00;\n lower[12*8'h0D + 4] <= 8'h38;\n lower[12*8'h0D + 5] <= 8'h54;\n lower[12*8'h0D + 6] <= 8'h54;\n lower[12*8'h0D + 7] <= 8'h54;\n lower[12*8'h0D + 8] <= 8'h54;\n lower[12*8'h0D + 9] <= 8'h00;\n lower[12*8'h0D + 10] <= 8'h00;\n lower[12*8'h0D + 11] <= 8'h00;\n lower[12*8'h0E + 0] <= 8'h00;\n lower[12*8'h0E + 1] <= 8'h00;\n lower[12*8'h0E + 2] <= 8'h00;\n lower[12*8'h0E + 3] <= 8'h00;\n lower[12*8'h0E + 4] <= 8'h58;\n lower[12*8'h0E + 5] <= 8'h64;\n lower[12*8'h0E + 6] <= 8'h44;\n lower[12*8'h0E + 7] <= 8'h44;\n lower[12*8'h0E + 8] <= 8'h44;\n lower[12*8'h0E + 9] <= 8'h00;\n lower[12*8'h0E + 10] <= 8'h00;\n lower[12*8'h0E + 11] <= 8'h00;\n lower[12*8'h0F + 0] <= 8'h00;\n lower[12*8'h0F + 1] <= 8'h00;\n lower[12*8'h0F + 2] <= 8'h00;\n lower[12*8'h0F + 3] <= 8'h00;\n lower[12*8'h0F + 4] <= 8'h38;\n lower[12*8'h0F + 5] <= 8'h44;\n lower[12*8'h0F + 6] <= 8'h44;\n lower[12*8'h0F + 7] <= 8'h44;\n lower[12*8'h0F + 8] <= 8'h38;\n lower[12*8'h0F + 9] <= 8'h00;\n lower[12*8'h0F + 10] <= 8'h00;\n lower[12*8'h0F + 11] <= 8'h00;\n lower[12*8'h10 + 0] <= 8'h00;\n lower[12*8'h10 + 1] <= 8'h00;\n lower[12*8'h10 + 2] <= 8'h00;\n lower[12*8'h10 + 3] <= 8'h00;\n lower[12*8'h10 + 4] <= 8'h98;\n lower[12*8'h10 + 5] <= 8'h64;\n lower[12*8'h10 + 6] <= 8'h44;\n lower[12*8'h10 + 7] <= 8'h64;\n lower[12*8'h10 + 8] <= 8'h58;\n lower[12*8'h10 + 9] <= 8'h40;\n lower[12*8'h10 + 10] <= 8'h40;\n lower[12*8'h10 + 11] <= 8'h40;\n lower[12*8'h11 + 0] <= 8'h00;\n lower[12*8'h11 + 1] <= 8'h00;\n lower[12*8'h11 + 2] <= 8'h00;\n lower[12*8'h11 + 3] <= 8'h00;\n lower[12*8'h11 + 4] <= 8'h34;\n lower[12*8'h11 + 5] <= 8'h4C;\n lower[12*8'h11 + 6] <= 8'h44;\n lower[12*8'h11 + 7] <= 8'h4C;\n lower[12*8'h11 + 8] <= 8'h34;\n lower[12*8'h11 + 9] <= 8'h04;\n lower[12*8'h11 + 10] <= 8'h06;\n lower[12*8'h11 + 11] <= 8'h04;\n lower[12*8'h12 + 0] <= 8'h00;\n lower[12*8'h12 + 1] <= 8'h00;\n lower[12*8'h12 + 2] <= 8'h00;\n lower[12*8'h12 + 3] <= 8'h00;\n lower[12*8'h12 + 4] <= 8'h58;\n lower[12*8'h12 + 5] <= 8'h64;\n lower[12*8'h12 + 6] <= 8'h40;\n lower[12*8'h12 + 7] <= 8'h40;\n lower[12*8'h12 + 8] <= 8'h40;\n lower[12*8'h12 + 9] <= 8'h00;\n lower[12*8'h12 + 10] <= 8'h00;\n lower[12*8'h12 + 11] <= 8'h00;\n lower[12*8'h13 + 0] <= 8'h00;\n lower[12*8'h13 + 1] <= 8'h00;\n lower[12*8'h13 + 2] <= 8'h00;\n lower[12*8'h13 + 3] <= 8'h00;\n lower[12*8'h13 + 4] <= 8'h38;\n lower[12*8'h13 + 5] <= 8'h40;\n lower[12*8'h13 + 6] <= 8'h38;\n lower[12*8'h13 + 7] <= 8'h04;\n lower[12*8'h13 + 8] <= 8'h38;\n lower[12*8'h13 + 9] <= 8'h00;\n lower[12*8'h13 + 10] <= 8'h00;\n lower[12*8'h13 + 11] <= 8'h00;\n lower[12*8'h14 + 0] <= 8'h00;\n lower[12*8'h14 + 1] <= 8'h00;\n lower[12*8'h14 + 2] <= 8'h10;\n lower[12*8'h14 + 3] <= 8'h10;\n lower[12*8'h14 + 4] <= 8'h38;\n lower[12*8'h14 + 5] <= 8'h10;\n lower[12*8'h14 + 6] <= 8'h10;\n lower[12*8'h14 + 7] <= 8'h12;\n lower[12*8'h14 + 8] <= 8'h0C;\n lower[12*8'h14 + 9] <= 8'h00;\n lower[12*8'h14 + 10] <= 8'h00;\n lower[12*8'h14 + 11] <= 8'h00;\n lower[12*8'h15 + 0] <= 8'h00;\n lower[12*8'h15 + 1] <= 8'h00;\n lower[12*8'h15 + 2] <= 8'h00;\n lower[12*8'h15 + 3] <= 8'h00;\n lower[12*8'h15 + 4] <= 8'h44;\n lower[12*8'h15 + 5] <= 8'h44;\n lower[12*8'h15 + 6] <= 8'h44;\n lower[12*8'h15 + 7] <= 8'h4C;\n lower[12*8'h15 + 8] <= 8'h34;\n lower[12*8'h15 + 9] <= 8'h00;\n lower[12*8'h15 + 10] <= 8'h00;\n lower[12*8'h15 + 11] <= 8'h00;\n lower[12*8'h16 + 0] <= 8'h00;\n lower[12*8'h16 + 1] <= 8'h00;\n lower[12*8'h16 + 2] <= 8'h00;\n lower[12*8'h16 + 3] <= 8'h00;\n lower[12*8'h16 + 4] <= 8'h44;\n lower[12*8'h16 + 5] <= 8'h44;\n lower[12*8'h16 + 6] <= 8'h44;\n lower[12*8'h16 + 7] <= 8'h28;\n lower[12*8'h16 + 8] <= 8'h10;\n lower[12*8'h16 + 9] <= 8'h00;\n lower[12*8'h16 + 10] <= 8'h00;\n lower[12*8'h16 + 11] <= 8'h00;\n lower[12*8'h17 + 0] <= 8'h00;\n lower[12*8'h17 + 1] <= 8'h00;\n lower[12*8'h17 + 2] <= 8'h00;\n lower[12*8'h17 + 3] <= 8'h00;\n lower[12*8'h17 + 4] <= 8'h44;\n lower[12*8'h17 + 5] <= 8'h54;\n lower[12*8'h17 + 6] <= 8'h54;\n lower[12*8'h17 + 7] <= 8'h54;\n lower[12*8'h17 + 8] <= 8'h38;\n lower[12*8'h17 + 9] <= 8'h00;\n lower[12*8'h17 + 10] <= 8'h00;\n lower[12*8'h17 + 11] <= 8'h00;\n lower[12*8'h18 + 0] <= 8'h00;\n lower[12*8'h18 + 1] <= 8'h00;\n lower[12*8'h18 + 2] <= 8'h00;\n lower[12*8'h18 + 3] <= 8'h00;\n lower[12*8'h18 + 4] <= 8'h44;\n lower[12*8'h18 + 5] <= 8'h28;\n lower[12*8'h18 + 6] <= 8'h10;\n lower[12*8'h18 + 7] <= 8'h28;\n lower[12*8'h18 + 8] <= 8'h44;\n lower[12*8'h18 + 9] <= 8'h00;\n lower[12*8'h18 + 10] <= 8'h00;\n lower[12*8'h18 + 11] <= 8'h00;\n lower[12*8'h19 + 0] <= 8'h00;\n lower[12*8'h19 + 1] <= 8'h00;\n lower[12*8'h19 + 2] <= 8'h00;\n lower[12*8'h19 + 3] <= 8'h00;\n lower[12*8'h19 + 4] <= 8'h44;\n lower[12*8'h19 + 5] <= 8'h44;\n lower[12*8'h19 + 6] <= 8'h44;\n lower[12*8'h19 + 7] <= 8'h44;\n lower[12*8'h19 + 8] <= 8'h34;\n lower[12*8'h19 + 9] <= 8'h04;\n lower[12*8'h19 + 10] <= 8'h44;\n lower[12*8'h19 + 11] <= 8'h38;\n lower[12*8'h1A + 0] <= 8'h00;\n lower[12*8'h1A + 1] <= 8'h00;\n lower[12*8'h1A + 2] <= 8'h00;\n lower[12*8'h1A + 3] <= 8'h00;\n lower[12*8'h1A + 4] <= 8'h7C;\n lower[12*8'h1A + 5] <= 8'h08;\n lower[12*8'h1A + 6] <= 8'h10;\n lower[12*8'h1A + 7] <= 8'h20;\n lower[12*8'h1A + 8] <= 8'h7C;\n lower[12*8'h1A + 9] <= 8'h00;\n lower[12*8'h1A + 10] <= 8'h00;\n lower[12*8'h1A + 11] <= 8'h00;\n lower[12*8'h1B + 0] <= 8'h00;\n lower[12*8'h1B + 1] <= 8'h00;\n lower[12*8'h1B + 2] <= 8'h0C;\n lower[12*8'h1B + 3] <= 8'h10;\n lower[12*8'h1B + 4] <= 8'h10;\n lower[12*8'h1B + 5] <= 8'h60;\n lower[12*8'h1B + 6] <= 8'h10;\n lower[12*8'h1B + 7] <= 8'h10;\n lower[12*8'h1B + 8] <= 8'h0C;\n lower[12*8'h1B + 9] <= 8'h00;\n lower[12*8'h1B + 10] <= 8'h00;\n lower[12*8'h1B + 11] <= 8'h00;\n lower[12*8'h1C + 0] <= 8'h00;\n lower[12*8'h1C + 1] <= 8'h00;\n lower[12*8'h1C + 2] <= 8'h10;\n lower[12*8'h1C + 3] <= 8'h10;\n lower[12*8'h1C + 4] <= 8'h10;\n lower[12*8'h1C + 5] <= 8'h00;\n lower[12*8'h1C + 6] <= 8'h10;\n lower[12*8'h1C + 7] <= 8'h10;\n lower[12*8'h1C + 8] <= 8'h10;\n lower[12*8'h1C + 9] <= 8'h00;\n lower[12*8'h1C + 10] <= 8'h00;\n lower[12*8'h1C + 11] <= 8'h00;\n lower[12*8'h1D + 0] <= 8'h00;\n lower[12*8'h1D + 1] <= 8'h00;\n lower[12*8'h1D + 2] <= 8'h60;\n lower[12*8'h1D + 3] <= 8'h10;\n lower[12*8'h1D + 4] <= 8'h10;\n lower[12*8'h1D + 5] <= 8'h0C;\n lower[12*8'h1D + 6] <= 8'h10;\n lower[12*8'h1D + 7] <= 8'h10;\n lower[12*8'h1D + 8] <= 8'h60;\n lower[12*8'h1D + 9] <= 8'h00;\n lower[12*8'h1D + 10] <= 8'h00;\n lower[12*8'h1D + 11] <= 8'h00;\n lower[12*8'h1E + 0] <= 8'h00;\n lower[12*8'h1E + 1] <= 8'h00;\n lower[12*8'h1E + 2] <= 8'h00;\n lower[12*8'h1E + 3] <= 8'h7E;\n lower[12*8'h1E + 4] <= 8'h02;\n lower[12*8'h1E + 5] <= 8'h02;\n lower[12*8'h1E + 6] <= 8'h00;\n lower[12*8'h1E + 7] <= 8'h00;\n lower[12*8'h1E + 8] <= 8'h00;\n lower[12*8'h1E + 9] <= 8'h00;\n lower[12*8'h1E + 10] <= 8'h00;\n lower[12*8'h1E + 11] <= 8'h00;\n lower[12*8'h1F + 0] <= 8'h00;\n lower[12*8'h1F + 1] <= 8'h00;\n lower[12*8'h1F + 2] <= 8'h00;\n lower[12*8'h1F + 3] <= 8'h00;\n lower[12*8'h1F + 4] <= 8'h7C;\n lower[12*8'h1F + 5] <= 8'h7C;\n lower[12*8'h1F + 6] <= 8'h7C;\n lower[12*8'h1F + 7] <= 8'h7C;\n lower[12*8'h1F + 8] <= 8'h00;\n lower[12*8'h1F + 9] <= 8'h00;\n lower[12*8'h1F + 10] <= 8'h00;\n lower[12*8'h1F + 11] <= 8'h00;\n\n\n upper[8*8'h00 + 0] <= 8'h00; // Space character: ASCII character 0x20\n upper[8*8'h00 + 1] <= 8'h00;\n upper[8*8'h00 + 2] <= 8'h00;\n upper[8*8'h00 + 3] <= 8'h00;\n upper[8*8'h00 + 4] <= 8'h00;\n upper[8*8'h00 + 5] <= 8'h00;\n upper[8*8'h00 + 6] <= 8'h00;\n upper[8*8'h00 + 7] <= 8'h00;\n upper[8*8'h01 + 0] <= 8'h10; // Pling character !: ASCII character 0x21\n upper[8*8'h01 + 1] <= 8'h10;\n upper[8*8'h01 + 2] <= 8'h10;\n upper[8*8'h01 + 3] <= 8'h10;\n upper[8*8'h01 + 4] <= 8'h10;\n upper[8*8'h01 + 5] <= 8'h00;\n upper[8*8'h01 + 6] <= 8'h10;\n upper[8*8'h01 + 7] <= 8'h00;\n upper[8*8'h02 + 0] <= 8'h28;\n upper[8*8'h02 + 1] <= 8'h28;\n upper[8*8'h02 + 2] <= 8'h00;\n upper[8*8'h02 + 3] <= 8'h00;\n upper[8*8'h02 + 4] <= 8'h00;\n upper[8*8'h02 + 5] <= 8'h00;\n upper[8*8'h02 + 6] <= 8'h00;\n upper[8*8'h02 + 7] <= 8'h00;\n upper[8*8'h03 + 0] <= 8'h28;\n upper[8*8'h03 + 1] <= 8'h28;\n upper[8*8'h03 + 2] <= 8'h7C;\n upper[8*8'h03 + 3] <= 8'h28;\n upper[8*8'h03 + 4] <= 8'h7C;\n upper[8*8'h03 + 5] <= 8'h28;\n upper[8*8'h03 + 6] <= 8'h28;\n upper[8*8'h03 + 7] <= 8'h00;\n upper[8*8'h04 + 0] <= 8'h10;\n upper[8*8'h04 + 1] <= 8'h3C;\n upper[8*8'h04 + 2] <= 8'h50;\n upper[8*8'h04 + 3] <= 8'h70;\n upper[8*8'h04 + 4] <= 8'h1C;\n upper[8*8'h04 + 5] <= 8'h14;\n upper[8*8'h04 + 6] <= 8'h78;\n upper[8*8'h04 + 7] <= 8'h10;\n upper[8*8'h05 + 0] <= 8'h52;\n upper[8*8'h05 + 1] <= 8'h24;\n upper[8*8'h05 + 2] <= 8'h08;\n upper[8*8'h05 + 3] <= 8'h10;\n upper[8*8'h05 + 4] <= 8'h24;\n upper[8*8'h05 + 5] <= 8'h4A;\n upper[8*8'h05 + 6] <= 8'h04;\n upper[8*8'h05 + 7] <= 8'h00;\n upper[8*8'h06 + 0] <= 8'h30;\n upper[8*8'h06 + 1] <= 8'h48;\n upper[8*8'h06 + 2] <= 8'h50;\n upper[8*8'h06 + 3] <= 8'h20;\n upper[8*8'h06 + 4] <= 8'h54;\n upper[8*8'h06 + 5] <= 8'h48;\n upper[8*8'h06 + 6] <= 8'h34;\n upper[8*8'h06 + 7] <= 8'h00;\n upper[8*8'h07 + 0] <= 8'h18;\n upper[8*8'h07 + 1] <= 8'h18;\n upper[8*8'h07 + 2] <= 8'h20;\n upper[8*8'h07 + 3] <= 8'h00;\n upper[8*8'h07 + 4] <= 8'h00;\n upper[8*8'h07 + 5] <= 8'h00;\n upper[8*8'h07 + 6] <= 8'h00;\n upper[8*8'h07 + 7] <= 8'h00;\n upper[8*8'h08 + 0] <= 8'h08;\n upper[8*8'h08 + 1] <= 8'h10;\n upper[8*8'h08 + 2] <= 8'h20;\n upper[8*8'h08 + 3] <= 8'h20;\n upper[8*8'h08 + 4] <= 8'h20;\n upper[8*8'h08 + 5] <= 8'h10;\n upper[8*8'h08 + 6] <= 8'h08;\n upper[8*8'h08 + 7] <= 8'h00;\n upper[8*8'h09 + 0] <= 8'h20;\n upper[8*8'h09 + 1] <= 8'h10;\n upper[8*8'h09 + 2] <= 8'h08;\n upper[8*8'h09 + 3] <= 8'h08;\n upper[8*8'h09 + 4] <= 8'h08;\n upper[8*8'h09 + 5] <= 8'h10;\n upper[8*8'h09 + 6] <= 8'h20;\n upper[8*8'h09 + 7] <= 8'h00;\n upper[8*8'h0A + 0] <= 8'h10;\n upper[8*8'h0A + 1] <= 8'h54;\n upper[8*8'h0A + 2] <= 8'h38;\n upper[8*8'h0A + 3] <= 8'h7C;\n upper[8*8'h0A + 4] <= 8'h38;\n upper[8*8'h0A + 5] <= 8'h54;\n upper[8*8'h0A + 6] <= 8'h10;\n upper[8*8'h0A + 7] <= 8'h00;\n upper[8*8'h0B + 0] <= 8'h00;\n upper[8*8'h0B + 1] <= 8'h00;\n upper[8*8'h0B + 2] <= 8'h10;\n upper[8*8'h0B + 3] <= 8'h10;\n upper[8*8'h0B + 4] <= 8'h7C;\n upper[8*8'h0B + 5] <= 8'h10;\n upper[8*8'h0B + 6] <= 8'h10;\n upper[8*8'h0B + 7] <= 8'h00;\n upper[8*8'h0C + 0] <= 8'h00;\n upper[8*8'h0C + 1] <= 8'h00;\n upper[8*8'h0C + 2] <= 8'h00;\n upper[8*8'h0C + 3] <= 8'h00;\n upper[8*8'h0C + 4] <= 8'h00;\n upper[8*8'h0C + 5] <= 8'h18;\n upper[8*8'h0C + 6] <= 8'h18;\n upper[8*8'h0C + 7] <= 8'h20;\n upper[8*8'h0D + 0] <= 8'h00;\n upper[8*8'h0D + 1] <= 8'h00;\n upper[8*8'h0D + 2] <= 8'h00;\n upper[8*8'h0D + 3] <= 8'h00;\n upper[8*8'h0D + 4] <= 8'h7C;\n upper[8*8'h0D + 5] <= 8'h00;\n upper[8*8'h0D + 6] <= 8'h00;\n upper[8*8'h0D + 7] <= 8'h00;\n upper[8*8'h0E + 0] <= 8'h00;\n upper[8*8'h0E + 1] <= 8'h00;\n upper[8*8'h0E + 2] <= 8'h00;\n upper[8*8'h0E + 3] <= 8'h00;\n upper[8*8'h0E + 4] <= 8'h00;\n upper[8*8'h0E + 5] <= 8'h00;\n upper[8*8'h0E + 6] <= 8'h18;\n upper[8*8'h0E + 7] <= 8'h18;\n upper[8*8'h0F + 0] <= 8'h04;\n upper[8*8'h0F + 1] <= 8'h04;\n upper[8*8'h0F + 2] <= 8'h08;\n upper[8*8'h0F + 3] <= 8'h10;\n upper[8*8'h0F + 4] <= 8'h20;\n upper[8*8'h0F + 5] <= 8'h40;\n upper[8*8'h0F + 6] <= 8'h40;\n upper[8*8'h0F + 7] <= 8'h00;\n upper[8*8'h10 + 0] <= 8'h38;\n upper[8*8'h10 + 1] <= 8'h44;\n upper[8*8'h10 + 2] <= 8'h4C;\n upper[8*8'h10 + 3] <= 8'h54;\n upper[8*8'h10 + 4] <= 8'h64;\n upper[8*8'h10 + 5] <= 8'h44;\n upper[8*8'h10 + 6] <= 8'h38;\n upper[8*8'h10 + 7] <= 8'h00;\n upper[8*8'h11 + 0] <= 8'h10;\n upper[8*8'h11 + 1] <= 8'h30;\n upper[8*8'h11 + 2] <= 8'h10;\n upper[8*8'h11 + 3] <= 8'h10;\n upper[8*8'h11 + 4] <= 8'h10;\n upper[8*8'h11 + 5] <= 8'h10;\n upper[8*8'h11 + 6] <= 8'h38;\n upper[8*8'h11 + 7] <= 8'h00;\n upper[8*8'h12 + 0] <= 8'h38;\n upper[8*8'h12 + 1] <= 8'h44;\n upper[8*8'h12 + 2] <= 8'h04;\n upper[8*8'h12 + 3] <= 8'h08;\n upper[8*8'h12 + 4] <= 8'h10;\n upper[8*8'h12 + 5] <= 8'h20;\n upper[8*8'h12 + 6] <= 8'h7C;\n upper[8*8'h12 + 7] <= 8'h00;\n upper[8*8'h13 + 0] <= 8'h38;\n upper[8*8'h13 + 1] <= 8'h44;\n upper[8*8'h13 + 2] <= 8'h04;\n upper[8*8'h13 + 3] <= 8'h18;\n upper[8*8'h13 + 4] <= 8'h04;\n upper[8*8'h13 + 5] <= 8'h44;\n upper[8*8'h13 + 6] <= 8'h38;\n upper[8*8'h13 + 7] <= 8'h00;\n upper[8*8'h14 + 0] <= 8'h08;\n upper[8*8'h14 + 1] <= 8'h18;\n upper[8*8'h14 + 2] <= 8'h28;\n upper[8*8'h14 + 3] <= 8'h48;\n upper[8*8'h14 + 4] <= 8'h7C;\n upper[8*8'h14 + 5] <= 8'h08;\n upper[8*8'h14 + 6] <= 8'h08;\n upper[8*8'h14 + 7] <= 8'h00;\n upper[8*8'h15 + 0] <= 8'h7C;\n upper[8*8'h15 + 1] <= 8'h40;\n upper[8*8'h15 + 2] <= 8'h78;\n upper[8*8'h15 + 3] <= 8'h44;\n upper[8*8'h15 + 4] <= 8'h04;\n upper[8*8'h15 + 5] <= 8'h44;\n upper[8*8'h15 + 6] <= 8'h38;\n upper[8*8'h15 + 7] <= 8'h00;\n upper[8*8'h16 + 0] <= 8'h18;\n upper[8*8'h16 + 1] <= 8'h20;\n upper[8*8'h16 + 2] <= 8'h40;\n upper[8*8'h16 + 3] <= 8'h78;\n upper[8*8'h16 + 4] <= 8'h44;\n upper[8*8'h16 + 5] <= 8'h44;\n upper[8*8'h16 + 6] <= 8'h38;\n upper[8*8'h16 + 7] <= 8'h00;\n upper[8*8'h17 + 0] <= 8'h7C;\n upper[8*8'h17 + 1] <= 8'h44;\n upper[8*8'h17 + 2] <= 8'h08;\n upper[8*8'h17 + 3] <= 8'h10;\n upper[8*8'h17 + 4] <= 8'h20;\n upper[8*8'h17 + 5] <= 8'h20;\n upper[8*8'h17 + 6] <= 8'h20;\n upper[8*8'h17 + 7] <= 8'h00;\n upper[8*8'h18 + 0] <= 8'h38;\n upper[8*8'h18 + 1] <= 8'h44;\n upper[8*8'h18 + 2] <= 8'h44;\n upper[8*8'h1"}
{"text": "8 + 3] <= 8'h38;\n upper[8*8'h18 + 4] <= 8'h44;\n upper[8*8'h18 + 5] <= 8'h44;\n upper[8*8'h18 + 6] <= 8'h38;\n upper[8*8'h18 + 7] <= 8'h00;\n upper[8*8'h19 + 0] <= 8'h38;\n upper[8*8'h19 + 1] <= 8'h44;\n upper[8*8'h19 + 2] <= 8'h44;\n upper[8*8'h19 + 3] <= 8'h3C;\n upper[8*8'h19 + 4] <= 8'h04;\n upper[8*8'h19 + 5] <= 8'h08;\n upper[8*8'h19 + 6] <= 8'h30;\n upper[8*8'h19 + 7] <= 8'h00;\n upper[8*8'h1A + 0] <= 8'h00;\n upper[8*8'h1A + 1] <= 8'h00;\n upper[8*8'h1A + 2] <= 8'h18;\n upper[8*8'h1A + 3] <= 8'h18;\n upper[8*8'h1A + 4] <= 8'h00;\n upper[8*8'h1A + 5] <= 8'h18;\n upper[8*8'h1A + 6] <= 8'h18;\n upper[8*8'h1A + 7] <= 8'h00;\n upper[8*8'h1B + 0] <= 8'h00;\n upper[8*8'h1B + 1] <= 8'h00;\n upper[8*8'h1B + 2] <= 8'h18;\n upper[8*8'h1B + 3] <= 8'h18;\n upper[8*8'h1B + 4] <= 8'h00;\n upper[8*8'h1B + 5] <= 8'h18;\n upper[8*8'h1B + 6] <= 8'h18;\n upper[8*8'h1B + 7] <= 8'h20;\n upper[8*8'h1C + 0] <= 8'h00;\n upper[8*8'h1C + 1] <= 8'h00;\n upper[8*8'h1C + 2] <= 8'h08;\n upper[8*8'h1C + 3] <= 8'h10;\n upper[8*8'h1C + 4] <= 8'h20;\n upper[8*8'h1C + 5] <= 8'h10;\n upper[8*8'h1C + 6] <= 8'h08;\n upper[8*8'h1C + 7] <= 8'h00;\n upper[8*8'h1D + 0] <= 8'h00;\n upper[8*8'h1D + 1] <= 8'h00;\n upper[8*8'h1D + 2] <= 8'h00;\n upper[8*8'h1D + 3] <= 8'h7C;\n upper[8*8'h1D + 4] <= 8'h00;\n upper[8*8'h1D + 5] <= 8'h7C;\n upper[8*8'h1D + 6] <= 8'h00;\n upper[8*8'h1D + 7] <= 8'h00;\n upper[8*8'h1E + 0] <= 8'h00;\n upper[8*8'h1E + 1] <= 8'h00;\n upper[8*8'h1E + 2] <= 8'h20;\n upper[8*8'h1E + 3] <= 8'h10;\n upper[8*8'h1E + 4] <= 8'h08;\n upper[8*8'h1E + 5] <= 8'h10;\n upper[8*8'h1E + 6] <= 8'h20;\n upper[8*8'h1E + 7] <= 8'h00;\n upper[8*8'h1F + 0] <= 8'h30;\n upper[8*8'h1F + 1] <= 8'h48;\n upper[8*8'h1F + 2] <= 8'h08;\n upper[8*8'h1F + 3] <= 8'h30;\n upper[8*8'h1F + 4] <= 8'h20;\n upper[8*8'h1F + 5] <= 8'h00;\n upper[8*8'h1F + 6] <= 8'h20;\n upper[8*8'h1F + 7] <= 8'h00;\n upper[8*8'h20 + 0] <= 8'h1C;\n upper[8*8'h20 + 1] <= 8'h22;\n upper[8*8'h20 + 2] <= 8'h4E;\n upper[8*8'h20 + 3] <= 8'h54;\n upper[8*8'h20 + 4] <= 8'h4C;\n upper[8*8'h20 + 5] <= 8'h20;\n upper[8*8'h20 + 6] <= 8'h1C;\n upper[8*8'h20 + 7] <= 8'h00;\n upper[8*8'h21 + 0] <= 8'h10;\n upper[8*8'h21 + 1] <= 8'h28;\n upper[8*8'h21 + 2] <= 8'h44;\n upper[8*8'h21 + 3] <= 8'h7C;\n upper[8*8'h21 + 4] <= 8'h44;\n upper[8*8'h21 + 5] <= 8'h44;\n upper[8*8'h21 + 6] <= 8'h44;\n upper[8*8'h21 + 7] <= 8'h00;\n upper[8*8'h22 + 0] <= 8'h78;\n upper[8*8'h22 + 1] <= 8'h24;\n upper[8*8'h22 + 2] <= 8'h24;\n upper[8*8'h22 + 3] <= 8'h38;\n upper[8*8'h22 + 4] <= 8'h24;\n upper[8*8'h22 + 5] <= 8'h24;\n upper[8*8'h22 + 6] <= 8'h78;\n upper[8*8'h22 + 7] <= 8'h00;\n upper[8*8'h23 + 0] <= 8'h38;\n upper[8*8'h23 + 1] <= 8'h44;\n upper[8*8'h23 + 2] <= 8'h40;\n upper[8*8'h23 + 3] <= 8'h40;\n upper[8*8'h23 + 4] <= 8'h40;\n upper[8*8'h23 + 5] <= 8'h44;\n upper[8*8'h23 + 6] <= 8'h38;\n upper[8*8'h23 + 7] <= 8'h00;\n upper[8*8'h24 + 0] <= 8'h78;\n upper[8*8'h24 + 1] <= 8'h24;\n upper[8*8'h24 + 2] <= 8'h24;\n upper[8*8'h24 + 3] <= 8'h24;\n upper[8*8'h24 + 4] <= 8'h24;\n upper[8*8'h24 + 5] <= 8'h24;\n upper[8*8'h24 + 6] <= 8'h78;\n upper[8*8'h24 + 7] <= 8'h00;\n upper[8*8'h25 + 0] <= 8'h7C;\n upper[8*8'h25 + 1] <= 8'h40;\n upper[8*8'h25 + 2] <= 8'h40;\n upper[8*8'h25 + 3] <= 8'h78;\n upper[8*8'h25 + 4] <= 8'h40;\n upper[8*8'h25 + 5] <= 8'h40;\n upper[8*8'h25 + 6] <= 8'h7C;\n upper[8*8'h25 + 7] <= 8'h00;\n upper[8*8'h26 + 0] <= 8'h7C;\n upper[8*8'h26 + 1] <= 8'h40;\n upper[8*8'h26 + 2] <= 8'h40;\n upper[8*8'h26 + 3] <= 8'h78;\n upper[8*8'h26 + 4] <= 8'h40;\n upper[8*8'h26 + 5] <= 8'h40;\n upper[8*8'h26 + 6] <= 8'h40;\n upper[8*8'h26 + 7] <= 8'h00;\n upper[8*8'h27 + 0] <= 8'h38;\n upper[8*8'h27 + 1] <= 8'h44;\n upper[8*8'h27 + 2] <= 8'h40;\n upper[8*8'h27 + 3] <= 8'h5C;\n upper[8*8'h27 + 4] <= 8'h44;\n upper[8*8'h27 + 5] <= 8'h44;\n upper[8*8'h27 + 6] <= 8'h38;\n upper[8*8'h27 + 7] <= 8'h00;\n upper[8*8'h28 + 0] <= 8'h44;\n upper[8*8'h28 + 1] <= 8'h44;\n upper[8*8'h28 + 2] <= 8'h44;\n upper[8*8'h28 + 3] <= 8'h7C;\n upper[8*8'h28 + 4] <= 8'h44;\n upper[8*8'h28 + 5] <= 8'h44;\n upper[8*8'h28 + 6] <= 8'h44;\n upper[8*8'h28 + 7] <= 8'h00;\n upper[8*8'h29 + 0] <= 8'h38;\n upper[8*8'h29 + 1] <= 8'h10;\n upper[8*8'h29 + 2] <= 8'h10;\n upper[8*8'h29 + 3] <= 8'h10;\n upper[8*8'h29 + 4] <= 8'h10;\n upper[8*8'h29 + 5] <= 8'h10;\n upper[8*8'h29 + 6] <= 8'h38;\n upper[8*8'h29 + 7] <= 8'h00;\n upper[8*8'h2A + 0] <= 8'h1C;\n upper[8*8'h2A + 1] <= 8'h08;\n upper[8*8'h2A + 2] <= 8'h08;\n upper[8*8'h2A + 3] <= 8'h08;\n upper[8*8'h2A + 4] <= 8'h08;\n upper[8*8'h2A + 5] <= 8'h48;\n upper[8*8'h2A + 6] <= 8'h30;\n upper[8*8'h2A + 7] <= 8'h00;\n upper[8*8'h2B + 0] <= 8'h44;\n upper[8*8'h2B + 1] <= 8'h48;\n upper[8*8'h2B + 2] <= 8'h50;\n upper[8*8'h2B + 3] <= 8'h60;\n upper[8*8'h2B + 4] <= 8'h50;\n upper[8*8'h2B + 5] <= 8'h48;\n upper[8*8'h2B + 6] <= 8'h44;\n upper[8*8'h2B + 7] <= 8'h00;\n upper[8*8'h2C + 0] <= 8'h40;\n upper[8*8'h2C + 1] <= 8'h40;\n upper[8*8'h2C + 2] <= 8'h40;\n upper[8*8'h2C + 3] <= 8'h40;\n upper[8*8'h2C + 4] <= 8'h40;\n upper[8*8'h2C + 5] <= 8'h40;\n upper[8*8'h2C + 6] <= 8'h7C;\n upper[8*8'h2C + 7] <= 8'h00;\n upper[8*8'h2D + 0] <= 8'h44;\n upper[8*8'h2D + 1] <= 8'h6C;\n upper[8*8'h2D + 2] <= 8'h54;\n upper[8*8'h2D + 3] <= 8'h54;\n upper[8*8'h2D + 4] <= 8'h44;\n upper[8*8'h2D + 5] <= 8'h44;\n upper[8*8'h2D + 6] <= 8'h44;\n upper[8*8'h2D + 7] <= 8'h00;\n upper[8*8'h2E + 0] <= 8'h44;\n upper[8*8'h2E + 1] <= 8'h44;\n upper[8*8'h2E + 2] <= 8'h64;\n upper[8*8'h2E + 3] <= 8'h54;\n upper[8*8'h2E + 4] <= 8'h4C;\n upper[8*8'h2E + 5] <= 8'h44;\n upper[8*8'h2E + 6] <= 8'h44;\n upper[8*8'h2E + 7] <= 8'h00;\n upper[8*8'h2F + 0] <= 8'h10;\n upper[8*8'h2F + 1] <= 8'h28;\n upper[8*8'h2F + 2] <= 8'h44;\n upper[8*8'h2F + 3] <= 8'h44;\n upper[8*8'h2F + 4] <= 8'h44;\n upper[8*8'h2F + 5] <= 8'h28;\n upper[8*8'h2F + 6] <= 8'h10;\n upper[8*8'h2F + 7] <= 8'h00;\n upper[8*8'h30 + 0] <= 8'h78;\n upper[8*8'h30 + 1] <= 8'h44;\n upper[8*8'h30 + 2] <= 8'h44;\n upper[8*8'h30 + 3] <= 8'h78;\n upper[8*8'h30 + 4] <= 8'h40;\n upper[8*8'h30 + 5] <= 8'h40;\n upper[8*8'h30 + 6] <= 8'h40;\n upper[8*8'h30 + 7] <= 8'h00;\n upper[8*8'h31 + 0] <= 8'h38;\n upper[8*8'h31 + 1] <= 8'h44;\n upper[8*8'h31 + 2] <= 8'h44;\n upper[8*8'h31 + 3] <= 8'h44;\n upper[8*8'h31 + 4] <= 8'h44;\n upper[8*8'h31 + 5] <= 8'h4C;\n upper[8*8'h31 + 6] <= 8'h3C;\n upper[8*8'h31 + 7] <= 8'h00;\n upper[8*8'h32 + 0] <= 8'h78;\n upper[8*8'h32 + 1] <= 8'h44;\n upper[8*8'h32 + 2] <= 8'h44;\n upper[8*8'h32 + 3] <= 8'h78;\n upper[8*8'h32 + 4] <= 8'h50;\n upper[8*8'h32 + 5] <= 8'h48;\n upper[8*8'h32 + 6] <= 8'h44;\n upper[8*8'h32 + 7] <= 8'h00;\n upper[8*8'h33 + 0] <= 8'h38;\n upper[8*8'h33 + 1] <= 8'h44;\n upper[8*8'h33 + 2] <= 8'h40;\n upper[8*8'h33 + 3] <= 8'h38;\n upper[8*8'h33 + 4] <= 8'h04;\n upper[8*8'h33 + 5] <= 8'h44;\n upper[8*8'h33 + 6] <= 8'h38;\n upper[8*8'h33 + 7] <= 8'h00;\n upper[8*8'h34 + 0] <= 8'h7C;\n upper[8*8'h34 + 1] <= 8'h10;\n upper[8*8'h34 + 2] <= 8'h10;\n upper[8*8'h34 + 3] <= 8'h10;\n upper[8*8'h34 + 4] <= 8'h10;\n upper[8*8'h34 + 5] <= 8'h10;\n upper[8*8'h34 + 6] <= 8'h10;\n upper[8*8'h34 + 7] <= 8'h00;\n upper[8*8'h35 + 0] <= 8'h44;\n upper[8*8'h35 + 1] <= 8'h44;\n upper[8*8'h35 + 2] <= 8'h44;\n upper[8*8'h35 + 3] <= 8'h44;\n upper[8*8'h35 + 4] <= 8'h44;\n upper[8*8'h35 + 5] <= 8'h44;\n upper[8*8'h35 + 6] <= 8'h38;\n upper[8*8'h35 + 7] <= 8'h00;\n upper[8*8'h36 + 0] <= 8'h44;\n upper[8*8'h36 + 1] <= 8'h44;\n upper[8*8'h36 + 2] <= 8'h44;\n upper[8*8'h36 + 3] <= 8'h28;\n upper[8*8'h36 + 4] <= 8'h28;\n upper[8*8'h36 + 5] <= 8'h10;\n upper[8*8'h36 + 6] <= 8'h10;\n upper[8*8'h36 + 7] <= 8'h00;\n upper[8*8'h37 + 0] <= 8'h44;\n upper[8*8'h37 + 1] <= 8'h44;\n upper[8*8'h37 + 2] <= 8'h44;\n upper[8*8'h37 + 3] <= 8'h54;\n upper[8*8'h37 + 4] <= 8'h54;\n upper[8*8'h37 + 5] <= 8'h6C;\n upper[8*8'h37 + 6] <= 8'h44;\n upper[8*8'h37 + 7] <= 8'h00;\n upper[8*8'h38 + 0] <= 8'h44;\n upper[8*8'h38 + 1] <= 8'h44;\n upper[8*8'h38 + 2] <= 8'h28;\n upper[8*8'h38 + 3] <= 8'h10;\n upper[8*8'h38 + 4] <= 8'h28;\n upper[8*8'h38 + 5] <= 8'h44;\n upper[8*8'h38 + 6] <= 8'h44;\n upper[8*8'h38 + 7] <= 8'h00;\n upper[8*8'h39 + 0] <= 8'h44;\n upper[8*8'h39 + 1] <= 8'h44;\n upper[8*8'h39 + 2] <= 8'h28;\n upper[8*8'h39 + 3] <= 8'h10;\n upper[8*8'h39 + 4] <= 8'h10;\n upper[8*8'h39 + 5] <= 8'h10;\n upper[8*8'h39 + 6] <= 8'h10;\n upper[8*8'h39 + 7] <= 8'h00;\n upper[8*8'h3A + 0] <= 8'h7C;\n upper[8*8'h3A + 1] <= 8'h04;\n upper[8*8'h3A + 2] <= 8'h08;\n upper[8*8'h3A + 3] <= 8'h10;\n upper[8*8'h3A + 4] <= 8'h20;\n upper[8*8'h3A + 5] <= 8'h40;\n upper[8*8'h3A + 6] <= 8'h7C;\n upper[8*8'h3A + 7] <= 8'h00;\n upper[8*8'h3B + 0] <= 8'h38;\n upper[8*8'h3B + 1] <= 8'h20;\n upper[8*8'h3B + 2] <= 8'h20;\n upper[8*8'h3B + 3] <= 8'h20;\n upper[8*8'h3B + 4] <= 8'h20;\n upper[8*8'h3B + 5] <= 8'h20;\n upper[8*8'h3B + 6] <= 8'h38;\n upper[8*8'h3B + 7] <= 8'h00;\n upper[8*8'h3C + 0] <= 8'h00;\n upper[8*8'h3C + 1] <= 8'h40;\n upper[8*8'h3C + 2] <= 8'h20;\n upper[8*8'h3C + 3] <= 8'h10;\n upper[8*8'h3C + 4] <= 8'h08;\n upper[8*8'h3C + 5] <= 8'h04;\n upper[8*8'h3C + 6] <= 8'h00;\n upper[8*8'h3C + 7] <= 8'h00;\n upper[8*8'h3D + 0] <= 8'h1C;\n upper[8*8'h3D + 1] <= 8'h04;\n upper[8*8'h3D + 2] <= 8'h04;\n upper[8*8'h3D + 3] <= 8'h04;\n upper[8*8'h3D + 4] <= 8'h04;\n upper[8*8'h3D + 5] <= 8'h04;\n upper[8*8'h3D + 6] <= 8'h1C;\n upper[8*8'h3D + 7] <= 8'h00;\n upper[8*8'h3E + 0] <= 8'h10;\n upper[8*8'h3E + 1] <= 8'h38;\n upper[8*8'h3E + 2] <= 8'h54;\n upper[8*8'h3E + 3] <= 8'h10;\n upper[8*8'h3E + 4] <= 8'h10;\n upper[8*8'h3E + 5] <= 8'h10;\n upper[8*8'h3E + 6] <= 8'h10;\n upper[8*8'h3E + 7] <= 8'h00;\n upper[8*8'h3F + 0] <= 8'h00;\n upper[8*8'h3F + 1] <= 8'h00;\n upper[8*8'h3F + 2] <= 8'h00;\n upper[8*8'h3F + 3] <= 8'h00;\n upper[8*8'h3F + 4] <= 8'h00;\n upper[8*8'h3F + 5] <= 8'h00;\n upper[8*8'h3F + 6] <= 8'hFF;\n upper[8*8'h3F + 7] <= 8'hFF;\n   end\n`else\n\n   RAMB16_S9_S9 #(\n      // The following INIT_xx declarations specify the initial contents of the RAM\n      .INIT_00(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_01(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_02(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_03(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_04(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_05(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_06(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_07(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_08(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_09(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_0A(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_0B(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_0C(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_0D(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_0E(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_0F(256'h000000003E3E3E3E3E3E3E3E3E3E3E3E000000003E3E3E3E3E3E3E3E3E3E3E3E),\n      .INIT_10(256'h0000000000000000001000101010101000000000000000000000000000000000),\n      .INIT_11(256'h00000000000000000028287C287C282800000000000000000000000000002828),\n      .INIT_12(256'h000000000000000000044A241008245200000000000000001078141C70503C10),\n      .INIT_13(256'h0000000000000000000000000020181800000000000000000034485420504830),\n      .INIT_14(256'h0000000000000000002010080808102000000000000000000008102020201008),\n      .INIT_15(256'h00000000000000000010107C101000000000000000000000001054387C385410),\n      .INIT_16(256'h00000000000000000000007C0000000000000000000000002018180000000000),\n      .INIT_17(256'h0000000000000000004040201008040400000000000000001818000000000000),\n      .INIT_18(256'h00000000000000000038101010103010000000000000000000384464544C4438),\n      .INIT_19(256'h000000000000000000384404180444380000000000000000007C201008044438),\n      .INIT_1A(256'h0000000000000000003844044478407C00000000000000000008087C48281808),\n      .INIT_1B(256'h0000000000000000002020201008447C00000000000000000038444478402018),\n      .INIT_1C(256'h0000000000000000003008043C44443800000000000000000038444438444438),\n      .INIT_1D(256'h0000000000000000201818001818000000000000000000000018180018180000),\n      .INIT_1E(256'h000000000000000000007C007C00000000000000000000000008102010080000),\n      .INIT_1F(256'h0000000000000000002000203008483000000000000000000020100810200000),\n      .INIT_20(256'h0000000000000000004444447C4428100000000000000000001C204C544E221C),\n      .INIT_21(256'h0000000000000000003844404040443800000000000000000078242438242478),\n      .INIT_22(256'h0000000000000000007C40407840407C00000000000000000078242424242478),\n      .INIT_23(256'h0000000000000000003844445C4044380000000000000000004040407840407C),\n      .INIT_24(256'h000000000000000000381010101010380000000000000000004444447C444444),\n      .INIT_25(256'h000000000000000000444850605048440000000000000000003048080808081C),\n      .INIT_26(256'h00000000000000000044444454546C440000000000000000007C404040404040),\n      .INIT_27(256'h0000000000000000001028444444281000000000000000000044444C54644444),\n      .INIT_28(256'h0000000000000000003C4C444444443800000000000000000040404078444478),\n      .INIT_29(256'h0000000000000000003844043840443800000000000000000044485078444478),\n      .INIT_2A(256'h000000000000000000384444444444440000000000000000001010101010107C),\n      .INIT_2B(256'h000000000000000000446C545444444400000000000000000010102828444444),\n      .INIT_2C(256'h0000000000000000001010101028444400000000000000000044442810284444),\n      .INIT_2D(256'h000000000000000000382020202020380000000000000000007C40201008047C),\n      .INIT_2E(256'h0000000000000000001C04040404041C00000000000000000000040810204000),\n      .INIT_2F(256'h0000000000000000FFFF00000000000000000000000000000010101010543810),\n      .INIT_30(256'h000000000000003A443C04083000000000000000000000000000000810200000),\n      .INIT_31(256'h0000000000000038444044380000000000000000000000986444645840400000),\n      .INIT_32(256'h0000000000000038407844380000000000000000000000324C444C3404040000),\n      .INIT_33(256'h00000000384404344C4444380000000000000000000000202020207024180000),\n      .INIT_34(256'h0000000000000038101010300010000000000000000000444444645840400000),\n      .INIT_35(256'h0000000000000044487048444040000000000000003048080808081800080000),\n      .INIT_36(256'h0000000000000054545454380000000000000000000000381010101010300000),\n      .INIT_37(256'h0000000000000038444444380000000000000000000000444444645800000000),\n      .INIT_38(256'h00000000040604344C444C340000000000000000404040586444649800000000),\n      .INIT_39(256'h0000000000000038043840380000000000000000000000404040645800000000),\n      .INIT_3A(256'h00000000000000344C44444400000000000000000000000C1210103810100000),\n      .INIT_3B(256'h0000000000000038545454440000000000000000000000102844444400000000),\n      .INIT_3C(256'h0000000038440434444444440000000000000000000000442810284400000000),\n      .INIT_3D(256'h000000000000000C10106010100C0000000000000000007C2010087C00000000),\n      .INIT_3E(256'h000000000000006010100C101060000000000000000000101010001010100000),\n      .INIT_3F(256'h00000000000000007C7C7C7C000000000000000000000000000002027E000000)\n     ) RAMB16_S1_inst_0 (\n      .CLKA(clk),      // Port A Clock\n      .DOA(pixels_out), // Port A 8-bit Data Output\n      .ADDRA({ascii[6:0],row}),    // Port A 11-bit Address Input\n      .DIA(8'b0),  // Port A 8-bit Data Input\n      .ENA(1'b1),        // Port A RAM Enable Input\n      .SSRA(1'b0),      // Port A Synchronous Set/Reset Input\n      .WEA(1'b0),        // Port A Write Enable Input\n      .DIPA(1'b0),\n      .DOPA(),\n      .CLKB(font_clk),      // Port A Clock\n      .DOB(font_out), // Port A 8-bit Data Output\n      .ADDRB(font_addr),    // Port A 11-bit Address Input\n      .DIB(font_in),  // Port A 8-bit Data Input\n      .ENB(font_en),        // Port A RAM Enable Input\n      .SSRB(1'b0),      // Port A Synchronous Set/Reset Input\n      .WEB(font_we),        // Port A Write Enable Input\n      .DIPB(1'b0),\n      .DOPB()\n   );\n\n`endif\nendmodule /* chargen_7x5_rachel */\n\n`ifdef rachel_tb\n`timescale 1ns/1ps\n\nmodule tb();\n\n   reg   clk;\n   reg [7:0] init;\n   \n   reg [11:0] addr;\n   wire [7:0] pixels_out;\n   reg \t[7:0] contents[0:4095];\n\nchargen_7x5_rachel rom1(.clk(clk), .ascii(addr[11:4]), .row(addr[3:0]), .pixels_out(pixels_out));\n\n   integer  i, last;\n\n   initial\n      begin\n\t clk = 0;\n\t addr = 0;\n\t for (i = 0; i < 4096; i=i+1)\n\t    begin\n\t       #1000 clk = 1;\n\t       #1000 clk = 0;\n//\t       $display(\"%X\", pixels_out);\n\t       contents[addr] = pixels_out;\n\t       addr = addr + 1;\n\t    end;\n\t for (init = 0; init < 64; init=init+1)\n\t   begin\n\t      $write(\"      .INIT_%X(256'h\", init);\n\t      for (i = 31; i >= 0; i=i-1)\n\t\t$write(\"%X\", contents[i + {init,5'b0}]);\n\t      if (init == 63) $display(\")\"); else $display(\"),\");\n\t      end\n      end\n   \nendmodule // tb\n\n`endif\n`ifdef graphic_tb\n`timescale 1ns/1ps\n\nmodule tb();\n\n   reg   clk;\n   reg [7:0] init;\n   \n   reg [11:0] addr;\n   wire [7:0] pixels_out;\n\nchargen_7x5_rachel rom1(.clk(clk), .ascii(addr[11:4]), .row(addr[3:0]), .pixels_out(pixels_out));\n\n   integer  i, j;\n\n   initial\n      begin\n\t clk = 0;\n\t addr = 0;\n\t for (i = 0; i < 4096; i=i+1)\n\t    begin\n\t       #1000 clk = 1;\n\t       #1000 clk = 0;\n\t       if (!addr[3:0])\n\t\t $display(\"\\n%d\", addr[11:4]);\n\t       else if (addr[3:0]<12)\n\t\t begin\n\t\t    for (j = 7; j >= 0; j=j-1)\n\t\t      $write(\"%c\", pixels_out & (1<<j) ? \"*\":\" \");\n\t\t    $display;\n\t\t end\n\t       addr = addr + 1;\n\t    end;\n      end\n   \nendmodule\n\n`endif\n   \n// eof\n\n\n"}
{"text": "module rx_delay(\n                input wire clk,\n                input wire in,\n                output reg maj\n                );\n\n   reg [4:0]               rx_dly;\n   \n   always @(posedge clk)\n     begin\n        maj <= (rx_dly[0] + rx_dly[1] + rx_dly[2] + rx_dly[3] + rx_dly[4]) > 2;\n        rx_dly <= {rx_dly[4:0],in};     \n     end // else: !if(!rstn)\n   \nendmodule // rx_delay\n"}
{"text": "// Copyright 2017 University of Cambridge.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n// See LICENSE for license details.\n\n`default_nettype none\n\n  module sd_bus(\n                input              msoc_clk,\n                input              sd_clk,\n                input              rstn,\n                input [31:0]       core_lsu_addr,\n                input wire [31:0]  core_lsu_wdata,\n                input              core_sd_we,\n                input wire         sd_detect,\n                input wire [3:0]   fifo_status,\n                input wire [31:0]  rx_fifo_status,\n                input wire [31:0]  tx_fifo_status, \n                input wire [31:0]  data_out_tx_fifo,\n                input              sd_cmd_to_host,\n                input [3:0]        sd_dat_to_host,\n                //---------------Output ports---------------\n                output reg [31:0]  sd_cmd_resp_sel,\n                output wire [31:0] data_in_rx_fifo,\n                output             tx_rd_fifo,\n                output             rx_wr_fifo,\n                output wire [12:0] sd_transf_cnt, \n                output reg         sd_reset,\n                output reg [7:0]   clock_divider_sd_clk,\n                output reg         sd_data_rst,\n                output reg         sd_clk_rst,\n output reg\t    sd_cmd_oe,\n output reg\t    sd_cmd_to_mem,\n output reg\t    sd_dat_oe,\n output reg [3:0]   sd_dat_to_mem,\n output wire [31:0] sd_status\n                );\n   wire \t    sd_cmd_oe_pos;\n   wire \t    sd_cmd_to_mem_pos;\n   wire \t    sd_dat_oe_pos;\n   wire [3:0] \t    sd_dat_to_mem_pos;\n\n   reg                             sd_cmd_to_host_dly;\n   reg [3:0]                       sd_dat_to_host_dly;\n   \n   wire [133:0]                    sd_cmd_response;\n   wire [31:0] \t    sd_cmd_wait, sd_data_wait;\n   wire [6:0]                      sd_cmd_crc_val;\n   wire [47:0]                     sd_cmd_packet;\n   wire                            sd_cmd_finish, sd_data_finish, sd_cmd_crc_ok, sd_cmd_index_ok;\n   wire [4:0]                      sd_data_crc_s;\n   wire [3:0]                      sd_data_crc_lane_ok;\n   wire [15:0]                     sd_crc_din[3:0];\n   wire [15:0]                     sd_crc_calc[3:0];\n   \n   reg [2:0]                       sd_data_start;\n   reg [11:0]                      sd_blksize;\n   \n   reg [2:0]                       sd_cmd_setting;\n   reg [5:0]                       sd_cmd_i;\n   reg [31:0]                      sd_cmd_arg;\n   reg [31:0]                      sd_cmd_timeout;\n   reg                             sd_cmd_start, sd_cmd_rst, dmy;\n   wire [5:0]                      sd_cmd_state;\n   wire [6:0]                      sd_data_state;\n\nalways @(negedge sd_clk or negedge rstn)\n   if (rstn == 0)\n     begin\n        sd_cmd_oe <= 1'b0;\n        sd_cmd_to_mem <= 1'b0;\n        sd_dat_oe <= 1'b0;\n        sd_dat_to_mem <= 4'b0;\n     end\n   else\n     begin\n        sd_cmd_oe <= sd_cmd_oe_pos;\n        sd_cmd_to_mem <= sd_cmd_to_mem_pos;\n        sd_dat_oe <= sd_dat_oe_pos;\n        sd_dat_to_mem <= sd_dat_to_mem_pos;\n     end // else: !if(!rstn)\n   \n   always @(posedge msoc_clk or negedge rstn)\n     if (rstn == 0)\n       begin\n          sd_blksize <= 0;\n          sd_data_start <= 0;\n          clock_divider_sd_clk <= 0;\n          sd_cmd_i <= 0;\n          sd_cmd_arg <= 0;\n          sd_cmd_setting <= 0;\n          sd_cmd_start <= 0;\n          sd_reset <= 0;\n          sd_data_rst <= 0;\n          sd_cmd_rst <= 0;\n          sd_clk_rst <= 0;\n          sd_cmd_timeout <= 15;\n       end\n     else\n       begin\n          if (core_sd_we)\n            case(core_lsu_addr[5:2])\n              1: clock_divider_sd_clk <= core_lsu_wdata[7:0];\n              2: sd_cmd_arg <= core_lsu_wdata;\n              3: sd_cmd_i <= core_lsu_wdata[5:0];\n              4: {sd_data_start,sd_cmd_setting} <= core_lsu_wdata[5:0];\n              5: sd_cmd_start <= core_lsu_wdata[0];\n              6: {sd_reset,sd_clk_rst,sd_data_rst,sd_cmd_rst} <= core_lsu_wdata[3:0];\n              8: sd_blksize <= core_lsu_wdata[11:0];\n              9: sd_cmd_timeout <= core_lsu_wdata;\n            endcase\n       end\n\n   always_comb\n     case(core_lsu_addr[6:2])\n       0: sd_cmd_resp_sel = sd_cmd_response[38:7];\n       1: sd_cmd_resp_sel = sd_cmd_response[70:39];\n       2: sd_cmd_resp_sel = sd_cmd_response[102:71];\n       3: sd_cmd_resp_sel = {1'b0,sd_cmd_response[133:103]};\n       4: sd_cmd_resp_sel = sd_cmd_wait;\n       5: sd_cmd_resp_sel = {sd_status[31:4],fifo_status[3:0]};\n       6: sd_cmd_resp_sel = sd_cmd_packet[31:0];\n       7: sd_cmd_resp_sel = {16'b0,sd_cmd_packet[47:32]};       \n       8: sd_cmd_resp_sel = sd_data_wait;\n       9: sd_cmd_resp_sel = {19'b0,sd_transf_cnt};\n       10: sd_cmd_resp_sel = rx_fifo_status;\n       11: sd_cmd_resp_sel = tx_fifo_status;\n       12: sd_cmd_resp_sel = {31'b0,sd_detect};\n       13: sd_cmd_resp_sel = {26'b0,sd_cmd_state};\n       14: sd_cmd_resp_sel = {25'b0,sd_data_state};\n       15: sd_cmd_resp_sel = {23'b0,sd_data_crc_s,sd_data_crc_lane_ok};\n       16: sd_cmd_resp_sel = {32'b0};\n       17: sd_cmd_resp_sel = {24'b0,clock_divider_sd_clk};\n       18: sd_cmd_resp_sel = sd_cmd_arg;\n       19: sd_cmd_resp_sel = {26'b0,sd_cmd_i};\n       20: sd_cmd_resp_sel = {26'b0,sd_data_start,sd_cmd_setting[2:0]};\n       21: sd_cmd_resp_sel = {31'b0,sd_cmd_start};\n       22: sd_cmd_resp_sel = {28'b0,sd_reset,sd_clk_rst,sd_data_rst,sd_cmd_rst};\n       23: sd_cmd_resp_sel = {32'b1};\n       24: sd_cmd_resp_sel = {20'b0,sd_blksize};\n       25: sd_cmd_resp_sel = sd_cmd_timeout;\n       26: sd_cmd_resp_sel = {sd_crc_din[1],sd_crc_din[0]};\n       27: sd_cmd_resp_sel = {sd_crc_din[3],sd_crc_din[2]};\n       28: sd_cmd_resp_sel = {sd_crc_calc[1],sd_crc_calc[0]};\n       29: sd_cmd_resp_sel = {sd_crc_calc[3],sd_crc_calc[2]};\n       default: sd_cmd_resp_sel = 32'HDEADBEEF;\n     endcase // case (core_lsu_addr[6:2])\n\n   sd_top sdtop(\n                .sd_clk     (sd_clk),\n                .cmd_rst    (~(sd_cmd_rst&rstn)),\n                .data_rst   (~(sd_data_rst&rstn)),\n                .setting_i  (sd_cmd_setting),\n                .timeout_i  (sd_cmd_timeout),\n                .cmd_i      (sd_cmd_i),\n                .arg_i      (sd_cmd_arg),\n                .start_i    (sd_cmd_start),\n                .sd_data_start_i(sd_data_start),\n                .sd_blksize_i(sd_blksize),\n                .sd_data_i(data_out_tx_fifo),\n                .sd_dat_to_host(sd_dat_to_host),\n                .sd_cmd_to_host(sd_cmd_to_host),\n                .finish_cmd_o(sd_cmd_finish),\n                .finish_data_o(sd_data_finish),\n                .response0_o(sd_cmd_response[38:7]),\n                .response1_o(sd_cmd_response[70:39]),\n                .response2_o(sd_cmd_response[102:71]),\n                .response3_o(sd_cmd_response[133:103]),\n                .crc_ok_o   (sd_cmd_crc_ok),\n                .index_ok_o (sd_cmd_index_ok),\n                .sd_transf_cnt(sd_transf_cnt),\n                .wait_o(sd_cmd_wait),\n                .wait_data_o(sd_data_wait),\n                .status_o(sd_status[31:4]),\n                .packet0_o(sd_cmd_packet[31:0]),\n                .packet1_o(sd_cmd_packet[47:32]),\n                .crc_val_o(sd_cmd_crc_val),\n                .crc_actual_o(sd_cmd_response[6:0]),\n                .sd_rd_o(tx_rd_fifo),\n                .sd_we_o(rx_wr_fifo),\n                .sd_data_o(data_in_rx_fifo),    \n\t\t\t\t.sd_dat_to_mem(sd_dat_to_mem_pos),\n\t\t\t\t.sd_cmd_to_mem(sd_cmd_to_mem_pos),\n\t\t\t\t.sd_dat_oe(sd_dat_oe_pos),\n\t\t\t\t.sd_cmd_oe(sd_cmd_oe_pos),\n                .sd_cmd_state(sd_cmd_state),\n                .sd_data_state(sd_data_state),\n                .sd_data_crc_s(sd_data_crc_s),\n                .sd_data_crc_lane_ok(sd_data_crc_lane_ok),\n                .sd_crc_din(sd_crc_din),\n                .sd_crc_calc(sd_crc_calc)                                     \n                );\n\nendmodule // chip_top\n`default_nettype wire\n"}
{"text": "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// WISHBONE SD Card Controller IP Core                          ////\n////                                                              ////\n//// sd_clock_divider.v                                           ////\n////                                                              ////\n//// This file is part of the WISHBONE SD Card                    ////\n//// Controller IP Core project                                   ////\n//// http://opencores.org/project,sd_card_controller              ////\n////                                                              ////\n//// Description                                                  ////\n//// Control of sd card clock rate                                ////\n////                                                              ////\n//// Author(s):                                                   ////\n////     - Marek Czerski, ma.czerski@gmail.com                    ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2013 Authors                                   ////\n////                                                              ////\n//// Based on original work by                                    ////\n////     Adam Edvardsson (adam.edvardsson@orsoc.se)               ////\n////                                                              ////\n////     Copyright (C) 2009 Authors                               ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE. See the GNU Lesser General Public License for more  ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n\nmodule sd_clock_divider (\n                         input       CLK,\n                         input [7:0] DIVIDER,\n                         input       RST,\n                         output      SD_CLK\n                         );\n\n   reg [7:0]                         ClockDiv;\n   reg                               SD_CLK_O;\n\n   BUFG SD_CLK_buf_inst (\n                    .O(SD_CLK), // 1-bit output: Clock output\n                    .I(SD_CLK_O)  // 1-bit input: Clock input\n                    );\n\n   always @(posedge CLK or posedge RST)\n     begin\n        if (RST) begin\n           ClockDiv <= 8'b0000_0000;\n           SD_CLK_O <= 0;\n        end\n        else if (ClockDiv == DIVIDER) begin\n           ClockDiv <= 0;\n           SD_CLK_O <= ~SD_CLK_O;\n        end else begin\n           ClockDiv <= ClockDiv + 8'h1;\n           SD_CLK_O <= SD_CLK_O;\n        end\n     end\n\nendmodule\n\n\n"}
{"text": "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// WISHBONE SD Card Controller IP Core                          ////\n////                                                              ////\n//// sd_cmd_serial_host.v                                         ////\n////                                                              ////\n//// This file is part of the WISHBONE SD Card                    ////\n//// Controller IP Core project                                   ////\n//// http://opencores.org/project,sd_card_controller              ////\n////                                                              ////\n//// Description                                                  ////\n//// Module resposible for sending and receiving commands         ////\n//// through 1-bit sd card command interface                      ////\n////                                                              ////\n//// Author(s):                                                   ////\n////     - Marek Czerski, ma.czerski@gmail.com                    ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2013 Authors                                   ////\n////                                                              ////\n//// Based on original work by                                    ////\n////     Adam Edvardsson (adam.edvardsson@orsoc.se)               ////\n////                                                              ////\n////     Copyright (C) 2009 Authors                               ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE. See the GNU Lesser General Public License for more  ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n\nmodule sd_cmd_serial_host (\n           sd_clk,\n           rst,\n           setting_i,\n           cmd_i,\n           start_i,\n\t   timeout_i,\n           response_o,\n           crc_ok_o,\n           index_ok_o,\n           finish_o,\n\t   wait_reg_o,\n\t   crc_val_o,\n\t   packet_o,\n\t   start_data_o,\n           cmd_dat_i,\n           cmd_out_o,\n           cmd_oe_o\n       );\n\n//-------------Internal Constant-------------\nparameter INIT_DELAY = 74;\nparameter BITS_TO_SEND = 48;\nparameter CMD_SIZE = 40;\nparameter RESP_SIZE_LONG = 127;\nparameter RESP_SIZE_SHORT = 39;\n//---------------Input ports---------------\ninput wire sd_clk;\ninput wire rst;\ninput [2:0] setting_i;\ninput [37:0] cmd_i;\ninput wire start_i;\ninput wire cmd_dat_i;\ninput [31:0] timeout_i;   \n//---------------Output ports---------------\noutput reg [BITS_TO_SEND-1:0] packet_o;\noutput reg [RESP_SIZE_LONG+6:0] response_o;\noutput reg finish_o;\noutput reg crc_ok_o;\noutput reg index_ok_o;\noutput reg cmd_oe_o;\noutput reg cmd_out_o;\noutput reg start_data_o;\noutput wire [6:0] crc_val_o;\noutput reg [31:0] wait_reg_o;\n//---------------Internal variable-----------\n   reg [CMD_SIZE-1:0]  cmd_buff;\n   reg \t\t       cmd_dat_reg;\n   reg [7:0] \t       resp_len;\n   reg \t\t       with_response, with_data;\n   \n//CRC\nreg crc_rst;\nreg crc_enable;\nreg crc_bit;\n//-Internal Counterns\nreg [7:0] counter;\n//-State Machine\nparameter STATE_SIZE = 6;\nparameter\n    INIT = 6'h00,\n    IDLE = 6'h01,\n    SETUP_CRC = 6'h02,\n    WRITE = 6'h04,\n    READ_WAIT = 6'h08,\n    READ = 6'h10,\n    FINISH_RD_WR = 6'h20;\nreg [STATE_SIZE-1:0] state;\nreg [STATE_SIZE-1:0] next_state;\n\n//------------------------------------------\nsd_crc_7 CRC_7(\n             crc_bit,\n             crc_enable,\n             sd_clk,\n             crc_rst,\n             crc_val_o);\n\n//------------------------------------------\nalways @(state or counter or start_i or with_response or cmd_dat_reg or resp_len or timeout_i or wait_reg_o)\nbegin: FSM_COMBO\n    case(state)\n        INIT: begin\n            if (counter >= INIT_DELAY) begin\n                next_state = IDLE;\n            end\n            else begin\n                next_state = INIT;\n            end\n        end\n        IDLE: begin\n            if (start_i) begin\n                next_state = SETUP_CRC;\n            end\n            else begin\n                next_state = IDLE;\n            end\n        end\n        SETUP_CRC:\n            next_state = WRITE;\n        WRITE:\n            if (counter >= BITS_TO_SEND && with_response) begin\n                next_state = READ_WAIT;\n            end\n            else if (counter >= BITS_TO_SEND) begin\n                next_state = FINISH_RD_WR;\n            end\n            else begin\n                next_state = WRITE;\n            end\n        READ_WAIT:\n            if ((wait_reg_o >= 3) && !cmd_dat_reg) begin // allow time for bus to change direction\n                next_state = READ;\n            end\n            else if (wait_reg_o >= timeout_i) begin // prevent hang if card did not respond\n                next_state = FINISH_RD_WR;\n            end\n            else begin\n                next_state = READ_WAIT;\n            end\n        READ:\n            if (counter >= resp_len+8) begin\n                next_state = FINISH_RD_WR;\n            end\n            else begin\n               next_state = READ;\n            end\n        FINISH_RD_WR:\n\t    if (start_i)\n              next_state = FINISH_RD_WR;\n            else\n              next_state = IDLE;\n        default: \n            next_state = INIT;\n    endcase\nend\n\nalways @(posedge sd_clk or posedge rst)\nbegin: COMMAND_DECODER\n    if (rst) begin\n        resp_len <= 0;\n        with_response <= 0;\n        with_data <= 0;\n        cmd_buff <= 0;\n    end\n    else begin\n        if (start_i == 1) begin\n            resp_len <= setting_i[1] ? RESP_SIZE_LONG : RESP_SIZE_SHORT;\n            with_response <= setting_i[0];\n            with_data <= setting_i[2];\n            cmd_buff <= {2'b01,cmd_i};\n        end\n    end\nend\n\n//----------------Seq logic------------\nalways @(posedge sd_clk or posedge rst)\nbegin: FSM_SEQ\n    if (rst) begin\n        state <= INIT;\n    end\n    else begin\n        state <= next_state;\n    end\nend\n\n//-------------OUTPUT_LOGIC-------\nalways @(posedge sd_clk or posedge rst)\nbegin: FSM_OUT\n    if (rst) begin\n       crc_enable <= 0;\n       cmd_oe_o = 1;\n       cmd_out_o = 1;\n       response_o <= 0;\n       finish_o <= 0;\n       crc_rst <= 1;\n       crc_bit <= 0;\n       index_ok_o <= 0;\n       crc_ok_o <= 0;\n       counter <= 0;\n       cmd_dat_reg <= 0;\n       packet_o <= 0;\n       start_data_o <= 0;\n       wait_reg_o <= 0;\n    end\n    else begin\n       case(state)\n            INIT: begin\n               counter <= counter+1;\n               cmd_oe_o = 1;\n               cmd_out_o = 1;\n            end\n            IDLE: begin\n               cmd_oe_o = 0;      //Put CMD to Z\n               counter <= 0;\n               crc_rst <= 1;\n               crc_enable <= 0;\n               index_ok_o <= 0;\n               finish_o <= 0;\n\t       start_data_o <= 0;\n            end\n            SETUP_CRC: begin\n               crc_rst <= 0;\n               crc_enable <= 1;\n\t       response_o <= 0;\n\t       packet_o <= 0;\n               crc_bit <= cmd_buff[CMD_SIZE-1];\n            end\n            WRITE: begin\n\t       cmd_dat_reg <= 1'b1;\n               if (counter < BITS_TO_SEND-8) begin  // 1->40 CMD, (41 >= CNT && CNT <=47) CRC, 48 stop_bit\n                  cmd_oe_o = 1;\n                  cmd_out_o = cmd_buff[CMD_SIZE-1-counter];\n                  if (counter < BITS_TO_SEND-9) begin //1 step ahead\n                     crc_bit <= cmd_buff[CMD_SIZE-2-counter];\n                  end else begin\n                     crc_enable <= 0;\n                  end\n               end\n               else if (counter < BITS_TO_SEND-1) begin\n                  cmd_oe_o = 1;\n                  crc_enable <= 0;\n                  cmd_out_o = crc_val_o[BITS_TO_SEND-counter-2];\n               end\n               else if (counter == BITS_TO_SEND-1) begin\n                  cmd_oe_o = 1;\n                  cmd_out_o = 1'b1;\n               end\n               else begin\n                  cmd_oe_o = 0;\n                  cmd_out_o = 1'b1;\n               end\n               counter <= counter+1;\n\t       wait_reg_o <= 0;\n\t       if (cmd_oe_o) packet_o <= {packet_o[BITS_TO_SEND-2:0],cmd_out_o};\n            end\n            READ_WAIT: begin\n\t       cmd_dat_reg <= cmd_dat_i;\n               crc_enable <= 0;\n               crc_rst <= 1;\n               counter <= 1;\n               cmd_oe_o = 0;\n               wait_reg_o <= wait_reg_o + 1;\n            end\n            READ: begin\n\t       cmd_dat_reg <= cmd_dat_i;\n               crc_rst <= 0;\n               crc_enable <= (resp_len != RESP_SIZE_LONG || counter > 7);\n               cmd_oe_o = 0;\n               if (counter <= resp_len)\n                 crc_bit <= cmd_dat_reg;\n\t       else\n\t\t begin\n                    crc_enable <= 0;\n\t\t end\n               if (counter <= resp_len+7) begin\n                  response_o <= {response_o[RESP_SIZE_LONG+5:0],cmd_dat_reg};\n               end\n               else begin\n                  crc_enable <= 0;\n                  crc_ok_o <= (response_o[6:0] == crc_val_o);\n                   start_data_o <= with_data;\n               end\n               counter <= counter + 1;\n            end\n            FINISH_RD_WR: begin\n                index_ok_o <= (cmd_buff[37:32] == response_o[125:120]);\n                finish_o <= 1;\n                crc_enable <= 0;\n                counter <= 0;\n                cmd_oe_o = 0;\n            end // case: FINISH_RD_WR\n\t  default:;\n        endcase\n    end\nend\n\nendmodule\n\n\n"}
{"text": "// ==========================================================================\n// CRC Generation Unit - Linear Feedback Shift Register implementation\n// (c) Kay Gorontzi, GHSi.de, distributed under the terms of LGPL\n// ==========================================================================\nmodule sd_crc_16(BITVAL, ENABLE, BITSTRB, CLEAR, CRC);\n   input        BITVAL;                            // Next input bit\n   input        ENABLE;                            // Enable calculation\n   input        BITSTRB;                           // Current bit valid (Clock)\n   input        CLEAR;                             // Init CRC value\n   output [15:0] CRC;                               // Current output CRC value\n\n   reg [15:0]    CRC;                               // We need output registers\n   wire          inv;\n   \n   assign inv = BITVAL ^ CRC[15];                   // XOR required?\n   \n   always @(posedge BITSTRB or posedge CLEAR) begin\n      if (CLEAR) begin\n         CRC <= 0;                                  // Init before calculation\n      end\n      else begin\n         if (ENABLE == 1) begin\n            CRC[15] <= CRC[14];\n            CRC[14] <= CRC[13];\n            CRC[13] <= CRC[12];\n            CRC[12] <= CRC[11] ^ inv;\n            CRC[11] <= CRC[10];\n            CRC[10] <= CRC[9];\n            CRC[9] <= CRC[8];\n            CRC[8] <= CRC[7];\n            CRC[7] <= CRC[6];\n            CRC[6] <= CRC[5];\n            CRC[5] <= CRC[4] ^ inv;\n            CRC[4] <= CRC[3];\n            CRC[3] <= CRC[2];\n            CRC[2] <= CRC[1];\n            CRC[1] <= CRC[0];\n            CRC[0] <= inv;\n         end\n      end\n   end\n   \nendmodule\n"}
{"text": "// ==========================================================================\n// CRC Generation Unit - Linear Feedback Shift Register implementation\n// (c) Kay Gorontzi, GHSi.de, distributed under the terms of LGPL\n// ==========================================================================\nmodule sd_crc_7(BITVAL, ENABLE, BITSTRB, CLEAR, CRC);\n   input        BITVAL;                            // Next input bit\n   input        ENABLE;                            // Enable calculation\n   input        BITSTRB;                           // Current bit valid (Clock)\n   input        CLEAR;                             // Init CRC value\n   output [6:0] CRC;                               // Current output CRC value\n\n   reg [6:0]    CRC;                               // We need output registers\n   wire         inv;\n   \n   assign inv = BITVAL ^ CRC[6];                   // XOR required?\n   \n   always @(posedge BITSTRB or posedge CLEAR) begin\n      if (CLEAR) begin\n         CRC <= 0;                                  // Init before calculation\n      end\n      else begin\n         if (ENABLE == 1) begin\n            CRC[6] <= CRC[5];\n            CRC[5] <= CRC[4];\n            CRC[4] <= CRC[3];\n            CRC[3] <= CRC[2] ^ inv;\n            CRC[2] <= CRC[1];\n            CRC[1] <= CRC[0];\n            CRC[0] <= inv;\n         end\n      end\n   end\n   \nendmodule\n"}
{"text": "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// WISHBONE SD Card Controller IP Core                          ////\n////                                                              ////\n//// sd_data_serial_host.v                                        ////\n////                                                              ////\n//// This file is part of the WISHBONE SD Card                    ////\n//// Controller IP Core project                                   ////\n//// http://opencores.org/project,sd_card_controller              ////\n////                                                              ////\n//// Description                                                  ////\n//// Module resposible for sending and receiving data through     ////\n//// 4-bit sd card data interface                                 ////\n////                                                              ////\n//// Author(s):                                                   ////\n////     - Marek Czerski, ma.czerski@gmail.com                    ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2013 Authors                                   ////\n////                                                              ////\n//// Based on original work by                                    ////\n////     Adam Edvardsson (adam.edvardsson@orsoc.se)               ////\n////                                                              ////\n////     Copyright (C) 2009 Authors                               ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE. See the GNU Lesser General Public License for more  ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n`include \"sd_defines.h\"\n\nmodule sd_data_serial_host(\n           input \t\t\t sd_clk,\n           input \t\t\t rst,\n           //Tx Fifo\n           input [31:0] \t\t data_in,\n           output reg \t\t\t rd,\n           //Rx Fifo\n           output reg [31:0] \t\t data_out,\n           output reg \t\t\t we,\n           //tristate data\n           output reg \t\t\t DAT_oe_o,\n           output reg [3:0] \t\t DAT_dat_o,\n           input [3:0] \t\t\t DAT_dat_i,\n           //Control signals\n           input [`BLKSIZE_W-1:0] \t blksize,\n           input \t\t\t bus_4bit,\n           input [`BLKCNT_W-1:0] \t blkcnt,\n           input [1:0] \t\t\t start,\n           input [1:0] \t\t\t byte_alignment,\n\t   input [31:0] \t\t timeout_i,\n           output \t\t\t sd_data_busy,\n           output \t\t\t busy,\n           output\t\t\t crc_ok,\n           output reg \t\t\t finish_o,\n\t   output reg [31:0] \t\t wait_reg_o,\n\t   output reg [`BLKSIZE_W-1+4:0] transf_cnt_o\n       );\n\nreg [4:0] crc_s;\nreg [3:0] crc_lane_ok;\nreg [15:0]         crc_din[3:0];\nwire [15:0]        crc_calc[3:0];\nreg [31:0]                                        data_out0;\nreg                                               we0;\nreg [3:0] DAT_dat_reg;\nreg [`BLKSIZE_W-1+4:0] data_cycles;\nreg bus_4bit_reg;\n//CRC16\n   reg [4:0]                                         crc_in;\nreg crc_rst;\nparameter SIZE = 7;\nreg [SIZE-1:0] state;\nreg [SIZE-1:0] next_state;\nparameter IDLE       = 7'b0000001;\nparameter WRITE_DAT  = 7'b0000010;\nparameter WRITE_CRC  = 7'b0000100;\nparameter WRITE_BUSY = 7'b0001000;\nparameter READ_WAIT  = 7'b0010000;\nparameter READ_DAT   = 7'b0100000;\nparameter FINISH     = 7'b1000000;\nreg [2:0] crc_status;\nreg busy_int;\nreg [`BLKSIZE_W-1:0] blksize_reg;\nreg [4:0] crc_c;\n   reg [3:0]                                         crnt_din;\nreg [4:0] data_index;\n\n   integer                                           k;\ngenvar i;\ngenerate\n    for(i=0; i<4; i=i+1) begin: CRC_16_gen\n         sd_crc_16 CRC_16_i (crc_in[i], crc_in[4], ~sd_clk, crc_rst, crc_calc[i]);\n    end\nendgenerate\n\nassign busy = (state != IDLE) && (state != FINISH);\nassign sd_data_busy = !DAT_dat_reg[0];\nassign crc_ok = &crc_lane_ok;\n\nalways @(posedge sd_clk or posedge rst)\nbegin: FSM_OUT\n    if (rst) begin\n        state <= IDLE;\n        DAT_oe_o <= 0;\n        crc_in <= 0;\n        crc_rst <= 1;\n        transf_cnt_o <= 0;\n        crc_c <= 15;\n        rd <= 0;\n        crc_c <= 0;\n        DAT_dat_o <= 0;\n        crc_status <= 0;\n        crc_lane_ok <= 0;\n        crc_s <= 0;\n        we0 <= 0;\n        we <= 0;\n        data_out0 <= 0;\n        busy_int <= 0;\n        data_index <= 0;\n        data_cycles <= 0;\n        bus_4bit_reg <= 0;     \n        wait_reg_o <= 0;\n        finish_o <= 0;\n           DAT_dat_reg <= 0;\n           data_out <= 0;\n           transf_cnt_o <= 0;\n    end\n    else begin\n           // sd data input pad register\n           DAT_dat_reg <= DAT_dat_i;\n           crnt_din = 4'hf;\n           if (we0) data_out <= data_out0;\n           we <= we0;\n        case(state)\n            IDLE: begin\n                for (k = 0; k < 4; k=k+1)\n                  crc_din[k] <= 0;\n                DAT_oe_o <= 0;\n                DAT_dat_o <= 4'b1111;\n                crc_in <= 0;\n                crc_rst <= 1;\n                transf_cnt_o <= 0;\n                crc_c <= 16;\n                crc_status <= 0;\n                crc_lane_ok <= 0;\n                crc_s <= 0;\n                we0 <= 0;\n                rd <= 0;\n                data_index <= 0;\n                blksize_reg <= blksize;\n                data_cycles <= (bus_4bit ? {2'b0,blksize,1'b0} + 'd2 : {blksize,3'b0} + 'd8);\n                bus_4bit_reg <= bus_4bit;\n\t        wait_reg_o <= 0;\n\t        finish_o <= 0;\n                data_out <= 0;\n                if (start == 2'b01)\n                  state <= WRITE_DAT;\n                else if (start == 2'b10)\n                  state <= READ_WAIT;\n            end\n            WRITE_DAT: begin\n                transf_cnt_o <= transf_cnt_o + 16'h1;\n                rd <= 0;\n                //special case\n                if (transf_cnt_o == 0) begin\n                    crc_rst <= 0;\n                   data_index <= 0;\n                   crnt_din = bus_4bit_reg ? 4'h0 : 4'he;\n                   rd <= 1;\n                    DAT_oe_o <= 1;\n                   DAT_dat_o <= crnt_din;\n                end\n                else if (transf_cnt_o < data_cycles+16) begin /* send the write data */\n                    if (bus_4bit_reg) begin\n                      crnt_din = {\n                            data_in[31-({data_index[2:0],2'b00})], \n                            data_in[30-({data_index[2:0],2'b00})], \n                            data_in[29-({data_index[2:0],2'b00})], \n                            data_in[28-({data_index[2:0],2'b00})]\n                            };\n                      if (data_index[2:0] == 3'h7 && transf_cnt_o < data_cycles-2) begin\n                         begin\n                            rd <= 1;\n                         end\n                        end\n                    end\n                    else begin\n                      crnt_din = {3'h7, data_in[31-data_index]};\n                        if (data_index == 29/*not 31 - read delay !!!*/) begin\n                         begin\n                            rd <= 1;\n                         end\n                        end\n                    end\n                    data_index <= data_index + 5'h1;\n                   if (transf_cnt_o < data_cycles-1)\n                     begin\n                        crc_in <= {1'b1,crnt_din};\n                        DAT_dat_o <= crnt_din;\n                end\n                   else if (crc_c!=0) begin /* send the CRC */\n                      crc_in <= 0;\n                    crc_c <= crc_c - 5'h1;\n                    DAT_oe_o <= 1;\n                      DAT_dat_o[0] <= crc_calc[0][crc_c-1];\n                    if (bus_4bit_reg)\n                        DAT_dat_o[3:1] <= {crc_calc[3][crc_c-1], crc_calc[2][crc_c-1], crc_calc[1][crc_c-1]};\n                    else\n                        DAT_dat_o[3:1] <= {3'h7};\n                end\n                   else /* send the stop bit */\n                     begin\n                        crc_in <= 0;\n                    DAT_oe_o <= 1;\n                    DAT_dat_o <= 4'hf;\n                end\n                end\n                else begin /* wait for write ack */\n                    DAT_oe_o <= 0;\n                    crc_s[4] <= DAT_dat_reg[0];\n                    if (!DAT_dat_reg[0])\n                        state <= WRITE_CRC;\n                end\n            end\n             WRITE_CRC: begin /* get write ack */\n                DAT_oe_o <= 0;\n                crc_status <= crc_status + 3'h1;\n                crc_s[3-crc_status[1:0]] <= DAT_dat_reg[0];                \n                busy_int <= 1;\n                if (crc_status == 3)\n                  state <= WRITE_BUSY;\n            end\n             WRITE_BUSY: begin /* wait for write completion */\n                busy_int <= !DAT_dat_reg[0];\n                if (!busy_int)\n                  state <= FINISH;\n                end\n             READ_WAIT: begin /* wait for a start bit in read mode */\n                DAT_oe_o <= 0;\n                crc_rst <= 0;\n                crc_in <= 0;\n                crc_c <= 15;// end\n                transf_cnt_o <= 0;\n                data_index <= 0;\n\t        wait_reg_o <= wait_reg_o + 1;\n                if ((wait_reg_o >= 3) && !DAT_dat_reg[0]) begin // allow time for bus to change direction\n                   state <= READ_DAT;\n            end\n                else if (wait_reg_o >= timeout_i) begin // prevent hang if card did not respond\n                   state <= FINISH;\n                end\n             end\n             READ_DAT: begin /* read the data and calculate CRC */\n                we0 <= 0;\n                if (transf_cnt_o < data_cycles-2) begin\n                    if (bus_4bit_reg) begin\n                      if (&data_index[2:0])\n                        begin\n                           we0 <= 1;\n                        end;\n                        data_out0[31-({data_index[2:0],2'b00})] <= DAT_dat_reg[3];\n                        data_out0[30-({data_index[2:0],2'b00})] <= DAT_dat_reg[2];\n                        data_out0[29-({data_index[2:0],2'b00})] <= DAT_dat_reg[1];\n                        data_out0[28-({data_index[2:0],2'b00})] <= DAT_dat_reg[0];\n                    end\n                    else begin\n                      if (&data_index)\n                        begin\n                           we0 <= 1;\n                        end;\n                        data_out0[31-data_index] <= DAT_dat_reg[0];\n                    end\n                    data_index <= data_index + 5'h1;\n                   crc_in <= {1'b1,DAT_dat_reg};\n                   transf_cnt_o <= transf_cnt_o + 16'h1;\n                end\n                else if (crc_c != 5'h1f) begin\n                   for (k = 0; k < 4; k=k+1)\n                     begin\n                        crc_din[k][crc_c[3:0]] <= DAT_dat_reg[k];\n                     end\n                   transf_cnt_o <= transf_cnt_o + 16'h1;\n                   crc_in <= 0;\n                    we0 <=0;\n                        crc_c <= crc_c - 5'h1;\n                        end\n                else\n                  begin\n                     for (k = 0; k < 4; k=k+1)\n                       crc_lane_ok[k] <= crc_calc[k] == crc_din[k];\n                     state <= FINISH;\n                end\n            end // case: READ_DAT\n\t  FINISH:\n               begin\n\t    finish_o <= 1;\n                  if (start == 2'b00)\n                    state <= IDLE;\n               end\n             default:\n               state <= IDLE;          \n           endcase; // case (state)\n           //abort\n           if (start == 2'b11)\n             state <= IDLE;       \n    end\nend\n\nendmodule\n\n\n\n\n\n"}
{"text": "//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// WISHBONE SD Card Controller IP Core                          ////\n////                                                              ////\n//// sd_defines.h                                                 ////\n////                                                              ////\n//// This file is part of the WISHBONE SD Card                    ////\n//// Controller IP Core project                                   ////\n//// http://opencores.org/project,sd_card_controller              ////\n////                                                              ////\n//// Description                                                  ////\n//// Header file with common definitions                          ////\n////                                                              ////\n//// Author(s):                                                   ////\n////     - Marek Czerski, ma.czerski@gmail.com                    ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n////                                                              ////\n//// Copyright (C) 2013 Authors                                   ////\n////                                                              ////\n//// Based on original work by                                    ////\n////     Adam Edvardsson (adam.edvardsson@orsoc.se)               ////\n////                                                              ////\n////     Copyright (C) 2009 Authors                               ////\n////                                                              ////\n//// This source file may be used and distributed without         ////\n//// restriction provided that this copyright statement is not    ////\n//// removed from the file and that any derivative work contains  ////\n//// the original copyright notice and the associated disclaimer. ////\n////                                                              ////\n//// This source file is free software; you can redistribute it   ////\n//// and/or modify it under the terms of the GNU Lesser General   ////\n//// Public License as published by the Free Software Foundation; ////\n//// either version 2.1 of the License, or (at your option) any   ////\n//// later version.                                               ////\n////                                                              ////\n//// This source is distributed in the hope that it will be       ////\n//// useful, but WITHOUT ANY WARRANTY; without even the implied   ////\n//// warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR      ////\n//// PURPOSE. See the GNU Lesser General Public License for more  ////\n//// details.                                                     ////\n////                                                              ////\n//// You should have received a copy of the GNU Lesser General    ////\n//// Public License along with this source; if not, download it   ////\n//// from http://www.opencores.org/lgpl.shtml                     ////\n////                                                              ////\n//////////////////////////////////////////////////////////////////////\n\n//global defines\n`define BLKSIZE_W 12\n`define BLKCNT_W 16\n`define CMD_TIMEOUT_W 24\n`define DATA_TIMEOUT_W 24\n\n//cmd module interrupts\n`define INT_CMD_SIZE 5\n`define INT_CMD_CC 0\n`define INT_CMD_EI 1\n`define INT_CMD_CTE 2\n`define INT_CMD_CCRCE 3\n`define INT_CMD_CIE  4\n\n//data module interrupts\n`define INT_DATA_SIZE 5\n`define INT_DATA_CC 0\n`define INT_DATA_EI 1\n`define INT_DATA_CTE 2\n`define INT_DATA_CCRCE 3\n`define INT_DATA_CFE 4\n\n//command register defines\n`define CMD_REG_SIZE 14\n`define CMD_RESPONSE_CHECK 1:0\n`define CMD_BUSY_CHECK 2\n`define CMD_CRC_CHECK 3\n`define CMD_IDX_CHECK 4\n`define CMD_WITH_DATA 6:5\n`define CMD_INDEX 13:8\n\n//register addreses\n`define argument 8'h00\n`define command 8'h04\n`define resp0 8'h08\n`define resp1 8'h0c\n`define resp2 8'h10\n`define resp3 8'h14\n`define data_timeout 8'h18\n`define controller 8'h1c\n`define cmd_timeout 8'h20\n`define clock_d 8'h24\n`define reset 8'h28\n`define voltage 8'h2c\n`define capa 8'h30\n`define cmd_isr 8'h34\n`define cmd_iser 8'h38\n`define data_isr 8'h3c\n`define data_iser 8'h40\n`define blksize 8'h44\n`define blkcnt 8'h48\n`define dst_src_addr 8'h60\n\n//wb module defines\n`define RESET_BLOCK_SIZE 12'd511\n`define RESET_CLK_DIV 0\n`define SUPPLY_VOLTAGE_mV 3300\n"}
{"text": "// \n// (c) Copyright 2008 - 2013 Xilinx, Inc. All rights reserved.\n// \n// This file contains confidential and proprietary information\n// of Xilinx, Inc. and is protected under U.S. and\n// international copyright and other intellectual property\n// laws.\n// \n// DISCLAIMER\n// This disclaimer is not a license and does not grant any\n// rights to the materials distributed herewith. Except as\n// otherwise provided in a valid license issued to you by\n// Xilinx, and to the maximum extent permitted by applicable\n// law: (1) THESE MATERIALS ARE MADE AVAILABLE \"AS IS\" AND\n// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES\n// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING\n// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-\n// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and\n// (2) Xilinx shall not be liable (whether in contract or tort,\n// including negligence, or under any other theory of\n// liability) for any loss or damage of any kind or nature\n// related to, arising under or in connection with these\n// materials, including for any direct, or any indirect,\n// special, incidental, or consequential loss or damage\n// (including loss of data, profits, goodwill, or any type of\n// loss or damage suffered as a result of any action brought\n// by a third party) even if such damage or loss was\n// reasonably foreseeable or Xilinx had been advised of the\n// possibility of the same.\n// \n// CRITICAL APPLICATIONS\n// Xilinx products are not designed or intended to be fail-\n// safe, or for use in any application requiring fail-safe\n// performance, such as life-support or safety devices or\n// systems, Class III medical devices, nuclear facilities,\n// applications related to the deployment of airbags, or any\n// other applications that could lead to death, personal\n// injury, or severe property or environmental damage\n// (individually and collectively, \"Critical\n// Applications\"). Customer assumes the sole risk and\n// liability of any use of Xilinx products in Critical\n// Applications, subject only to applicable laws and\n// regulations governing limitations on product liability.\n// \n// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS\n// PART OF THIS FILE AT ALL TIMES.\n// \n\n// Copyright 2015 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n// See LICENSE for license details.\n\n`default_nettype none\n\nmodule sd_top(\n input wire \t\t sd_clk,\n input wire \t\t cmd_rst,\n input wire \t\t data_rst,\n input wire [2:0] \t setting_i,\n input wire \t\t start_i,\n input wire [31:0] \t arg_i,\n input wire [5:0] \t cmd_i,\n input wire [31:0] \t timeout_i,\n input wire [2:0] \t sd_data_start_i,\n input wire [1:0] \t sd_align_i,\n input wire [15:0] \t sd_blkcnt_i,\n input wire [11:0] \t sd_blksize_i,\n input wire [31:0] \t sd_data_i,\n input wire [3:0] \t sd_dat_to_host,\n input wire \t\t sd_cmd_to_host,\n//---------------Output ports---------------\n output wire [31:0] \t response0_o,\n output wire [63:32]  response1_o,\n output wire [95:64]  response2_o,\n output wire [126:96] response3_o,\n output wire [31:0] \t wait_o,\n output wire [31:0] \t wait_data_o,\n output wire [31:4] \t status_o,\n output wire [31:0] \t packet0_o,\n output wire [15:0] \t packet1_o,\n output wire [6:0] \t crc_val_o,\n output wire [6:0] \t crc_actual_o,\n output wire \t finish_cmd_o,\n output wire \t finish_data_o,\n output wire \t crc_ok_o,\n output wire \t index_ok_o,\n output wire \t sd_rd_o,\n output wire \t sd_we_o,\n output wire [31:0] \t sd_data_o,\n output wire [15:0] \t transf_cnt_o,\n output wire [3:0] \t sd_dat_to_mem,\n output wire \t sd_cmd_to_mem,\n output wire \t sd_cmd_oe,\n output wire \t sd_dat_oe,\n output reg [9:0]  sd_xfr_addr);\n\n   reg \t\t    sd_cmd_to_host_dly;\n   reg [3:0] \t    sd_dat_to_host_dly;\n\t\t    \n   wire\t\t    start_data;\n   wire \t    data_crc_ok;\n   wire \t    sd_busy, sd_data_busy;\n  \n   assign status_o = {1'b0,crc_val_o[6:0],\n\t\t      1'b0,crc_actual_o[6:0],\n\t\t      5'b0,finish_data_o,sd_data_busy,finish_cmd_o,\n\t\t      index_ok_o,crc_ok_o,data_crc_ok,sd_busy};\n\t    \nalways @(negedge sd_clk)\n  begin\n     if (data_rst)\n       sd_xfr_addr <= 0;\n     else\n       begin\n        if (sd_rd_o|sd_we_o)\n            sd_xfr_addr <= sd_xfr_addr + 1;          \n       end\n     sd_cmd_to_host_dly <= sd_cmd_to_host;\n     sd_dat_to_host_dly <= sd_dat_to_host;\n  end\n   \nsd_cmd_serial_host cmd_serial_host0(\n    .sd_clk     (sd_clk),\n    .rst        (cmd_rst),\n    .setting_i  (setting_i),\n    .cmd_i      ({cmd_i,arg_i}),\n    .start_i    (start_i),\n    .timeout_i  (timeout_i),\n    .finish_o   (finish_cmd_o),\n    .response_o ({response3_o,response2_o,response1_o,response0_o,crc_actual_o}),\n    .crc_ok_o   (crc_ok_o),\n    .crc_val_o  (crc_val_o),\n    .packet_o\t({packet1_o,packet0_o}),\n    .index_ok_o (index_ok_o),\n    .wait_reg_o (wait_o),\n    .start_data_o(start_data),\t\t\t\t    \n    .cmd_dat_i  (sd_cmd_to_host_dly),\n    .cmd_out_o  (sd_cmd_to_mem),\n    .cmd_oe_o   (sd_cmd_oe)\n    );\n\nsd_data_serial_host data_serial_host0(\n    .sd_clk         (sd_clk),\n    .rst            (data_rst),\n    .data_in        (sd_data_i),\n    .rd             (sd_rd_o),\n    .data_out       (sd_data_o),\n    .we             (sd_we_o),\n    .finish_o       (finish_data_o),\n    .DAT_oe_o       (sd_dat_oe),\n    .DAT_dat_o      (sd_dat_to_mem),\n    .DAT_dat_i      (sd_dat_to_host_dly),\n    .blksize        (sd_blksize_i),\n    .bus_4bit       (sd_data_start_i[2]),\n    .blkcnt         (sd_blkcnt_i),\n    .start          (start_data ? sd_data_start_i[1:0] : 2'b00),\n    .byte_alignment (sd_align_i),\n    .timeout_i      (timeout_i),\n    .sd_data_busy   (sd_data_busy),\n    .busy           (sd_busy),\n    .wait_reg_o     (wait_data_o),\n    .crc_ok         (data_crc_ok),\n    .transf_cnt_o   (transf_cnt_o)\t\t\t\t      \n    );\n  \nendmodule // chip_top\n`default_nettype wire\n"}
{"text": "// See LICENSE.SiFive for license details.\n\nimport \"DPI-C\" function int debug_tick\n(\n  output bit     debug_req_valid,\n  input  bit     debug_req_ready,\n  output int     debug_req_bits_addr,\n  output int     debug_req_bits_op,\n  output int     debug_req_bits_data,\n\n  input  bit        debug_resp_valid,\n  output bit        debug_resp_ready,\n  input  int        debug_resp_bits_resp,\n  input  int        debug_resp_bits_data\n);\n\nmodule SimDTM(\n  input clk,\n  input reset,\n\n  output        debug_req_valid,\n  input         debug_req_ready,\n  output [ 6:0] debug_req_bits_addr,\n  output [ 1:0] debug_req_bits_op,\n  output [31:0] debug_req_bits_data,\n\n  input         debug_resp_valid,\n  output        debug_resp_ready,\n  input  [ 1:0] debug_resp_bits_resp,\n  input  [31:0] debug_resp_bits_data,\n\n  output [31:0] exit\n);\n\n  bit r_reset;\n\n  wire #0.1 __debug_req_ready = debug_req_ready;\n  wire #0.1 __debug_resp_valid = debug_resp_valid;\n  wire [31:0] #0.1 __debug_resp_bits_resp = {30'b0, debug_resp_bits_resp};\n  wire [31:0] #0.1 __debug_resp_bits_data = debug_resp_bits_data;\n\n  bit __debug_req_valid;\n  int __debug_req_bits_addr;\n  int __debug_req_bits_op;\n  int __debug_req_bits_data;\n  bit __debug_resp_ready;\n  int __exit;\n\n  assign #0.1 debug_req_valid = __debug_req_valid;\n  assign #0.1 debug_req_bits_addr = __debug_req_bits_addr[6:0];\n  assign #0.1 debug_req_bits_op = __debug_req_bits_op[1:0];\n  assign #0.1 debug_req_bits_data = __debug_req_bits_data[31:0];\n  assign #0.1 debug_resp_ready = __debug_resp_ready;\n  assign #0.1 exit = __exit;\n\n  always @(posedge clk)\n  begin\n    r_reset <= reset;\n    if (reset || r_reset)\n    begin\n      __debug_req_valid = 0;\n      __debug_resp_ready = 0;\n      __exit = 0;\n    end\n    else\n    begin\n      __exit = debug_tick(\n        __debug_req_valid,\n        __debug_req_ready,\n        __debug_req_bits_addr,\n        __debug_req_bits_op,\n        __debug_req_bits_data,\n        __debug_resp_valid,\n        __debug_resp_ready,\n        __debug_resp_bits_resp,\n        __debug_resp_bits_data\n      );\n    end\n  end\nendmodule\n"}
{"text": "// See LICENSE.SiFive for license details.\n\nmodule SimJTAG #(\n                 parameter TICK_DELAY = 50\n                 )(\n\n                   input         clock,\n                   input         reset,\n                   \n                   input         enable,\n                   input         init_done,\n\n                   output        jtag_TCK,\n                   output        jtag_TMS,\n                   output        jtag_TDI,\n                   output        jtag_TRSTn,\n \n                   input         jtag_TDO_data,\n                   input         jtag_TDO_driven,\n                          \n                   output [31:0] exit\n                   );\n\n   wire CAPTURE, DRCK, RESET, RUNTEST, SEL, SHIFT, TCK, TDI, TMS, UPDATE, TDO;\n\n   /* This block is just used to feed the JTAG clock into the parts of Rocket that need it */\n      \n   BSCANE2 #(\n      .JTAG_CHAIN(2)  // Value for USER command.\n   )\n   BSCANE2_inst1 (\n      .CAPTURE(CAPTURE), // 1-bit output: CAPTURE output from TAP controller.\n      .DRCK(DRCK),       // 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or\n                         // SHIFT are asserted.\n\n      .RESET(RESET),     // 1-bit output: Reset output for TAP controller.\n      .RUNTEST(RUNTEST), // 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.\n      .SEL(SEL),         // 1-bit output: USER instruction active output.\n      .SHIFT(SHIFT),     // 1-bit output: SHIFT output from TAP controller.\n      .TCK(jtag_TCK),         // 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.\n      .TDI(jtag_TDI),         // 1-bit output: Test Data Input (TDI) output from TAP controller.\n      .TMS(jtag_TMS),         // 1-bit output: Test Mode Select output. Fabric connection to TAP.\n      .UPDATE(UPDATE),   // 1-bit output: UPDATE output from TAP controller\n      .TDO(jtag_TDO_data)          // 1-bit input: Test Data Output (TDO) input for USER function.\n   );\n\nassign jtag_TRSTn = ~RESET;\nassign exit = 32'b0;\n\nendmodule\n"}
{"text": "// See LICENSE for license details.\n\nmodule spi_wrapper\n  #(\n    parameter ADDR_WIDTH = 8,\n    parameter DATA_WIDTH = 8,\n    parameter RESET_ADDR = 0\n    )\n   (\n    input                    clk, rstn,\n    nasti_channel.slave nasti,\n    input                    io0_i,\n    output                   io0_o, io0_t,\n    input                    io1_i,\n    output                   io1_o, io1_t,\n    input                    sck_i,\n    output                   sck_o, sck_t,\n    input                    ss_i,\n    output                   ss_o, ss_t,\n    output                   ip2intc_irpt,\n    output reg               sd_reset\n    );\n\n   // internal AXI signals\n   logic [ADDR_WIDTH-1:0]   aw_addr,   ar_addr;\n   logic                    aw_valid,  ar_valid;\n   logic                    aw_ready,  ar_ready;\n   logic [DATA_WIDTH-1:0]   w_data,    r_data;\n   logic [DATA_WIDTH/8-1:0] w_strb;\n   logic                    w_valid;\n   logic                    w_ready;\n   logic [1:0]              b_resp,    r_resp;\n   logic                    b_valid,   r_valid;\n   logic                    b_ready,   r_ready;\n\n\n   // internal control signals\n   logic                    write_addr_match, read_addr_match;\n   logic                    read_sel, write_sel, write_enable;\n\n   assign read_addr_match = nasti.ar_valid && (nasti.ar_addr & 8'hff) == RESET_ADDR;\n   assign write_addr_match = nasti.aw_valid && (nasti.aw_addr & 8'hff) == RESET_ADDR;\n\n   always_ff @(posedge clk or negedge rstn)\n     if(!rstn)\n       read_sel <= 1'b0;\n     else if(read_addr_match)\n       read_sel <= 1'b1;\n     else if(nasti.r_valid && nasti.r_ready)\n       read_sel <= 1'b0;\n\n   always_ff @(posedge clk or negedge rstn)\n     if(!rstn)\n       write_sel <= 1'b0;\n     else if(write_addr_match)\n       write_sel <= 1'b1;\n     else if(nasti.b_valid && nasti.b_ready)\n       write_sel <= 1'b0;\n\n   always_ff @(posedge clk or negedge rstn)\n     if(!rstn)\n       sd_reset <= 1'b1;\n     else if(write_sel && nasti.w_valid && nasti.w_ready)\n       sd_reset <= nasti.w_strb & 1'h1 ? nasti.w_data & 8'hff : sd_reset;\n\n   assign ar_addr = nasti.ar_addr;\n   assign ar_valid = nasti.ar_valid && !read_addr_match;\n   assign nasti.ar_ready = ar_ready || read_addr_match;\n\n   assign aw_addr = nasti.aw_addr;\n   assign aw_valid = nasti.aw_valid && !write_addr_match;\n   assign nasti.aw_ready = aw_ready || write_addr_match;\n\n   assign w_data = nasti.w_data;\n   assign w_strb = nasti.w_strb;\n   assign w_valid = nasti.w_valid && !write_sel;\n   assign nasti.w_ready = w_ready || write_sel;\n\n   assign nasti.r_data = read_sel ? sd_reset : r_data;\n   assign nasti.r_resp = read_sel ? 0 : r_resp;\n   assign nasti.r_valid = r_valid || read_sel;\n   assign r_ready = read_sel ? 0 : nasti.r_ready;\n\n   assign nasti.b_resp = write_sel ? 0 : b_resp;\n   assign nasti.b_valid = b_valid || write_sel;\n   assign b_ready = write_sel ? 0 : nasti.b_ready;\n\n   axi_quad_spi_0 spi_i\n     (\n      .ext_spi_clk     ( clk          ),\n      .s_axi_aclk      ( clk          ),\n      .s_axi_aresetn   ( rstn         ),\n      .s_axi_araddr    ( ar_addr      ),\n      .s_axi_arready   ( ar_ready     ),\n      .s_axi_arvalid   ( ar_valid     ),\n      .s_axi_awaddr    ( aw_addr      ),\n      .s_axi_awready   ( aw_ready     ),\n      .s_axi_awvalid   ( aw_valid     ),\n      .s_axi_bready    ( b_ready      ),\n      .s_axi_bresp     ( b_resp       ),\n      .s_axi_bvalid    ( b_valid      ),\n      .s_axi_rdata     ( r_data       ),\n      .s_axi_rready    ( r_ready      ),\n      .s_axi_rresp     ( r_resp       ),\n      .s_axi_rvalid    ( r_valid      ),\n      .s_axi_wdata     ( w_data       ),\n      .s_axi_wready    ( w_ready      ),\n      .s_axi_wstrb     ( w_strb       ),\n      .s_axi_wvalid    ( w_valid      ),\n      .io0_i           ( io0_i        ),\n      .io0_o           ( io0_o        ),\n      .io0_t           ( io0_t        ),\n      .io1_i           ( io1_i        ),\n      .io1_o           ( io1_o        ),\n      .io1_t           ( io1_t        ),\n      .sck_i           ( sck_i        ),\n      .sck_o           ( sck_o        ),\n      .sck_t           ( sck_t        ),\n      .ss_i            ( ss_i         ),\n      .ss_o            ( ss_o         ),\n      .ss_t            ( ss_t         ),\n      .ip2intc_irpt    ( ip2intc_irpt )\n      );\n\nendmodule // spi_wrapper\n"}
{"text": "`default_nettype none\n\nmodule clock_buffer_generic(input wire ing, output wire outg);\n\n`ifdef FPGA\n   \nBUFH buf1(.I(ing), .O(outg));\n\n`else\n\n   assign outg = ing;\n   \n`endif\n   \nendmodule // clock_buffer_generic\n\nmodule io_buffer_generic(inout wire inoutg, output wire outg, input wire ing, input wire ctrl);\n\n`ifdef FPGA\n   \n   IOBUF #(\n      .DRIVE(12), // Specify the output drive strength\n      .IBUF_LOW_PWR(\"TRUE\"),  // Low Power - \"TRUE\", High Performance = \"FALSE\" \n      .IOSTANDARD(\"DEFAULT\"), // Specify the I/O standard\n      .SLEW(\"SLOW\") // Specify the output slew rate\n   ) IOBUF_inst (\n      .O(outg),     // Buffer output\n      .IO(inoutg),   // Buffer inout port (connect directly to top-level port)\n      .I(ing),     // Buffer input\n      .T(ctrl)      // 3-state enable input, high=input, low=output\n   );\n\n`else\n\n   assign outg = inoutg;\n   assign inoutg = ctrl ? 1'bz : ing;\n   \n`endif\n   \nendmodule // io_buffer_generic\n\nmodule io_buffer_fast(inout wire inoutg, output wire outg, input wire ing, input wire ctrl);\n\n`ifdef FPGA\n   \n   IOBUF #(\n      .DRIVE(24), // Specify the output drive strength\n      .IBUF_LOW_PWR(\"FALSE\"),  // Low Power - \"TRUE\", High Performance = \"FALSE\" \n      .IOSTANDARD(\"LVTTL\"), // Specify the I/O standard\n      .SLEW(\"FAST\") // Specify the output slew rate\n   ) IOBUF_inst (\n      .O(outg),     // Buffer output\n      .IO(inoutg),   // Buffer inout port (connect directly to top-level port)\n      .I(ing),     // Buffer input\n      .T(ctrl)      // 3-state enable input, high=input, low=output\n   );\n\n`else\n\n   assign outg = inoutg;\n   assign inoutg = ctrl ? 1'bz : ing;\n   \n`endif\n   \nendmodule // io_buffer_fast\n\nmodule oddr_buffer_generic(output wire outg, input wire ing);\n\n`ifdef FPGA\n   \n  ODDR #(\n    .DDR_CLK_EDGE(\"OPPOSITE_EDGE\"),\n    .INIT(1'b0),\n    .IS_C_INVERTED(1'b0),\n    .IS_D1_INVERTED(1'b0),\n    .IS_D2_INVERTED(1'b0),\n    .SRTYPE(\"SYNC\")) \n    refclk_inst\n       (.C(ing),\n        .CE(1'b1),\n        .D1(1'b1),\n        .D2(1'b0),\n        .Q(outg),\n        .R(1'b0),\n        .S( ));\n\n`else\n\n   assign outg = ing;\n   \n`endif\n   \nendmodule // oddr_buffer_generic\n\nmodule bscan_generic #(\n    parameter integer JTAG_CHAIN = 1\n )\n(output wire CAPTURE, DRCK, RESET, RUNTEST, SEL, SHIFT, TCK, TDI, TMS, UPDATE, input wire TDO);\n\n`ifdef FPGA\n   \n   BSCANE2 #(\n      .JTAG_CHAIN(JTAG_CHAIN)  // Value for USER command.\n   )\n   BSCANE2_inst (\n      .CAPTURE(CAPTURE), // 1-bit output: CAPTURE output from TAP controller.\n      .DRCK(DRCK),       // 1-bit output: Gated TCK output. When SEL is asserted, DRCK toggles when CAPTURE or\n                         // SHIFT are asserted.\n      .RESET(RESET),     // 1-bit output: Reset output for TAP controller.\n      .RUNTEST(RUNTEST), // 1-bit output: Output asserted when TAP controller is in Run Test/Idle state.\n      .SEL(SEL),         // 1-bit output: USER instruction active output.\n      .SHIFT(SHIFT),     // 1-bit output: SHIFT output from TAP controller.\n      .TCK(TCK),         // 1-bit output: Test Clock output. Fabric connection to TAP Clock pin.\n      .TDI(TDI),         // 1-bit output: Test Data Input (TDI) output from TAP controller.\n      .TMS(TMS),         // 1-bit output: Test Mode Select output. Fabric connection to TAP.\n      .UPDATE(UPDATE),   // 1-bit output: UPDATE output from TAP controller\n      .TDO(TDO)          // 1-bit input: Test Data Output (TDO) input for USER function.\n   );\n\n`else // !`ifdef FPGA\n\nassign {CAPTURE, DRCK, RESET, RUNTEST, SEL, SHIFT, TCK, TDI, TMS, UPDATE} = 'b0;\n   \n`endif //  `ifdef FPGA\n\nendmodule // bscan_generic\n"}
{"text": "// See LICENSE.SiFive for license details.\n\n`ifndef RESET_DELAY\n `define RESET_DELAY 777.7\n`endif\n\nmodule TestDriver;\n\n  reg clock = 1'b0;\n  reg reset = 1'b1;\n\n  always #(`CLOCK_PERIOD/2.0) clock = ~clock;\n  initial #(`RESET_DELAY) reset = 0;\n\n  // Read input arguments and initialize\n  reg verbose = 1'b0;\n  wire printf_cond = verbose && !reset;\n  reg [63:0] max_cycles = 0;\n  reg [63:0] dump_start = 0;\n  reg [63:0] trace_count = 0;\n  reg [1023:0] vcdplusfile = 0;\n  reg [1023:0] vcdfile = 0;\n  int unsigned rand_value;\n  initial\n  begin\n    void'($value$plusargs(\"max-cycles=%d\", max_cycles));\n    void'($value$plusargs(\"dump-start=%d\", dump_start));\n    verbose = $test$plusargs(\"verbose\");\n\n    // do not delete the lines below.\n    // $random function needs to be called with the seed once to affect all\n    // the downstream $random functions within the Chisel-generated Verilog\n    // code.\n    // $urandom is seeded via cmdline (+ntb_random_seed in VCS) but that\n    // doesn't seed $random.\n    rand_value = $urandom;\n    rand_value = $random(rand_value);\n    if (verbose) begin\n`ifdef VCS\n      $fdisplay(stderr, \"testing $random %0x seed %d\", rand_value, unsigned'($get_initial_random_seed));\n`else\n      $fdisplay(stderr, \"testing $random %0x\", rand_value);\n`endif\n    end\n\n`ifdef DEBUG\n\n    if ($value$plusargs(\"vcdplusfile=%s\", vcdplusfile))\n    begin\n`ifdef VCS\n      $vcdplusfile(vcdplusfile);\n`else\n      $fdisplay(stderr, \"Error: +vcdplusfile is VCS-only; use +vcdfile instead\");\n      $fatal;\n`endif\n    end\n\n    if ($value$plusargs(\"vcdfile=%s\", vcdfile))\n    begin\n      $dumpfile(vcdfile);\n      $dumpvars(0, testHarness);\n    end\n`ifdef VCS\n`define VCDPLUSON $vcdpluson(0); $vcdplusmemon(0);\n`define VCDPLUSCLOSE $vcdplusclose; $dumpoff;\n`else\n`define VCDPLUSON $dumpon;\n`define VCDPLUSCLOSE $dumpoff;\n`endif\n`else\n  // No +define+DEBUG\n`define VCDPLUSON\n`define VCDPLUSCLOSE\n\n    if ($test$plusargs(\"vcdplusfile=\") || $test$plusargs(\"vcdfile=\"))\n    begin\n      $fdisplay(stderr, \"Error: +vcdfile or +vcdplusfile requested but compile did not have +define+DEBUG enabled\");\n      $fatal;\n    end\n\n`endif\n  end\n\n`ifdef TESTBENCH_IN_UVM\n  // UVM library has its own way to manage end-of-simulation.\n  // A UVM-based testbench will raise an objection, watch this signal until this goes 1, then drop the objection.\n  reg finish_request = 1'b0;\n`endif\n  reg [255:0] reason = \"\";\n  reg failure = 1'b0;\n  wire success;\n  integer stderr = 32'h80000002;\n  always @(posedge clock)\n  begin\n`ifdef GATE_LEVEL\n    if (verbose)\n    begin\n      $fdisplay(stderr, \"C: %10d\", trace_count);\n    end\n`endif\n    if (trace_count == dump_start)\n    begin\n      `VCDPLUSON\n    end\n\n    trace_count = trace_count + 1;\n    if (!reset)\n    begin\n      if (max_cycles > 0 && trace_count > max_cycles)\n      begin\n        reason = \" (timeout)\";\n        failure = 1'b1;\n      end\n\n      if (failure)\n      begin\n        $fdisplay(stderr, \"*** FAILED ***%s after %d simulation cycles\", reason, trace_count);\n        `VCDPLUSCLOSE\n        $fatal;\n      end\n\n      if (success)\n      begin\n        if (verbose)\n          $fdisplay(stderr, \"Completed after %d simulation cycles\", trace_count);\n        `VCDPLUSCLOSE\n`ifdef TESTBENCH_IN_UVM\n        finish_request = 1;\n`else\n        $finish;\n`endif\n      end\n    end\n  end\n\n  TestHarness testHarness(\n    .clock(clock),\n    .reset(reset),\n    .io_success(success)\n  );\n\nendmodule\n"}
{"text": "`timescale 1ns / 1ps\n// Documented Verilog UART\n// Copyright (C) 2010 Timothy Goddard (tim@goddard.net.nz)\n// Distributed under the MIT licence.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n// \n`default_nettype wire\n\nmodule uart(\n            input            clk, // The master clock for this module\n            input            rst, // Synchronous reset.\n            input            rx, // Incoming serial line\n            output           tx, // Outgoing serial line\n            input            transmit, // Signal to transmit\n            input [7:0]      tx_byte, // Byte to transmit\n            output reg       received, // Indicated that a byte has been received.\n            output reg [7:0] rx_byte, // Byte received\n            output           is_receiving, // Low when receive line is idle.\n            output           is_transmitting, // Low when transmit line is idle.\n            output reg       recv_error, // Indicates error in receiving packet.\n            input [15:0]     baud,\n            input            recv_ack\n            );\n\n   // parameter CLOCK_DIVIDE = 1302; // clock rate (50Mhz) / (baud rate (9600) * 4)\n\n   // States for the receiving state machine.\n   // These are just constants, not parameters to override.\n   parameter RX_IDLE = 0;\n   parameter RX_CHECK_START = 1;\n   parameter RX_READ_BITS = 2;\n   parameter RX_CHECK_STOP = 3;\n   parameter RX_DELAY_RESTART = 4;\n   parameter RX_ERROR = 5;\n   parameter RX_RECEIVED = 6;\n\n   // States for the transmitting state machine.\n   // Constants - do not override.\n   parameter TX_IDLE = 0;\n   parameter TX_SENDING = 1;\n   parameter TX_DELAY_RESTART = 2;\n\n   reg [10:0]                rx_clk_divider;\n   reg [10:0]                tx_clk_divider;\n\n   reg [2:0]                 recv_state;\n   reg [5:0]                 rx_countdown;\n   reg [3:0]                 rx_bits_remaining;\n   reg [7:0]                 rx_data;\n\n   reg [8:0]                 tx_out;\n   reg [1:0]                 tx_state;\n   reg [5:0]                 tx_countdown;\n   reg [3:0]                 tx_bits_remaining;\n   reg [7:0]                 tx_data;\n   \n   assign is_receiving = recv_state != RX_IDLE;\n\n   assign tx = tx_out[0];\n   assign is_transmitting = tx_state != TX_IDLE;\n\n   always @(posedge clk) begin\n      if (rst) begin\n         received = 1'b0;\n         recv_error = 1'b0;\n         recv_state = RX_IDLE;\n         tx_state = TX_DELAY_RESTART;\n         rx_clk_divider = baud;\n         tx_clk_divider = baud;\n         tx_out = 9'b1_1111_1111;\n         tx_countdown = 15;\n         rx_byte = 0;\n         rx_data = 0;\n         tx_data = 0;\n         tx_bits_remaining = 0;\n      end\n      if (recv_ack)\n        begin\n           received = 1'b0;\n           recv_error = 1'b0;\n        end\n      // The clk_divider counter counts down from\n      // the CLOCK_DIVIDE constant. Whenever it\n      // reaches 0, 1/16 of the bit period has elapsed.\n      // Countdown timers for the receiving and transmitting\n      // state machines are decremented.\n      rx_clk_divider = rx_clk_divider - 1;\n      if (!rx_clk_divider) begin\n         rx_clk_divider = baud;\n         rx_countdown = rx_countdown - 1;\n      end\n      tx_clk_divider = tx_clk_divider - 1;\n      if (!tx_clk_divider) begin\n         tx_clk_divider = baud;\n         tx_countdown = tx_countdown - 1;\n      end\n      \n      // Receive state machine\n      case (recv_state)\n        RX_IDLE: begin\n           // A low pulse on the receive line indicates the\n           // start of data.\n           if (!rx) begin\n              // Wait half the period - should resume in the\n              // middle of this first pulse.\n              rx_clk_divider = baud;\n              rx_countdown = 2;\n              recv_state = RX_CHECK_START;\n           end\n        end\n        RX_CHECK_START: begin\n           if (!rx_countdown) begin\n              // Check the pulse is still there\n              if (!rx) begin\n                 // Pulse still there - good\n                 // Wait the bit period to resume half-way\n                 // through the first bit.\n                 rx_countdown = 4;\n                 rx_bits_remaining = 8;\n                 recv_state = RX_READ_BITS;\n              end else begin\n                 // Pulse lasted less than half the period -\n                 // not a valid transmission.\n                 recv_state = RX_ERROR;\n              end\n           end\n        end\n        RX_READ_BITS: begin\n           if (!rx_countdown) begin\n              // Should be half-way through a bit pulse here.\n              // Read this bit in, wait for the next if we\n              // have more to get.\n              rx_data = {rx, rx_data[7:1]};\n              rx_countdown = 4;\n              rx_bits_remaining = rx_bits_remaining - 1;\n              recv_state = rx_bits_remaining ? RX_READ_BITS : RX_CHECK_STOP;\n           end\n        end\n        RX_CHECK_STOP: begin\n           if (!rx_countdown) begin\n              // Should resume half-way through the stop bit\n              // This should be high - if not, reject the\n              // transmission and signal an error.\n              recv_state = rx ? RX_RECEIVED : RX_ERROR;\n           end\n        end\n        RX_DELAY_RESTART: begin\n           // Waits a set number of cycles before accepting\n           // another transmission.\n           recv_state = rx_countdown ? RX_DELAY_RESTART : RX_IDLE;\n        end\n        RX_ERROR: begin\n           // There was an error receiving.\n           // Raises the recv_error flag for one clock\n           // cycle while in this state and then waits\n           // 2 bit periods before accepting another\n           // transmission.\n           rx_countdown = 8;\n           recv_error = 1'b1;\n           recv_state = RX_DELAY_RESTART;\n        end\n        RX_RECEIVED: begin\n           // Successfully received a byte.\n           // Raises the received flag.\n           received = 1'b1;\n           rx_byte = rx_data;\n           recv_state = RX_IDLE;\n        end\n        default:;\n      endcase\n      \n      // Transmit state machine\n      case (tx_state)\n        TX_IDLE: begin\n           if (transmit) begin\n              // If the transmit flag is raised in the idle\n              // state, start transmitting the current content\n              // of the tx_byte input.\n              tx_data = tx_byte;\n              tx_out = {tx_data,1'b0};\n              // Send the initial, low pulse of 1 bit period\n              // to signal the start, followed by the data\n              tx_clk_divider = baud;\n              tx_countdown = 4;\n              tx_bits_remaining = 9;\n              tx_state = TX_SENDING;\n           end\n        end\n        TX_SENDING: begin\n           if (!tx_countdown) begin\n              if (tx_bits_remaining) begin\n                 tx_bits_remaining = tx_bits_remaining - 1;\n                 tx_out = {1'b1, tx_out[8:1]};\n                 tx_countdown = 4;\n                 tx_state = TX_SENDING;\n              end else begin\n                 // Set delay to send out 2 stop bits.\n                 tx_countdown = 8;\n                 tx_state = TX_DELAY_RESTART;\n              end\n           end\n        end\n        TX_DELAY_RESTART: begin\n           // Wait until tx_countdown reaches the end before\n           // we send another transmission. This covers the\n           // \"stop bit\" delay.\n           tx_state = tx_countdown ? TX_DELAY_RESTART : TX_IDLE;\n        end\n        default:;\n      endcase\n   end\n\nendmodule\n"}
{"text": "///////////////////////////////////////////////////////////////////////////////\n// Copyright (c) 1995/2010 Xilinx, Inc.\n// All Right Reserved.\n///////////////////////////////////////////////////////////////////////////////\n// This version is a simulation stub.\n\nmodule BSCANE2 (\n  output CAPTURE,\n  output DRCK,\n  output RESET,\n  output RUNTEST,\n  output SEL,\n  output SHIFT,\n  output TCK,\n  output TDI,\n  output TMS,\n  output UPDATE,\n\n  input TDO\n);\n\n  parameter DISABLE_JTAG = \"FALSE\";\n  parameter integer JTAG_CHAIN = 1;\n\n  pulldown (CAPTURE);\n  pulldown (DRCK);\n  pulldown (RESET);\n  pulldown (RUNTEST);\n  pulldown (SEL);\n  pulldown (SHIFT);\n  pulldown (TCK);\n  pulldown (TDI);\n  pulldown (TMS);\n  pulldown (UPDATE);\n\nendmodule\n"}
{"text": "// $Header: /devl/xcs/repo/env/Databases/CAEInterfaces/verunilibs/data/glbl.v,v 1.14 2010/10/28 20:44:00 fphillip Exp $\n`ifndef GLBL\n`define GLBL\n`timescale  1 ps / 1 ps\n\nmodule glbl (   // LED and DIP switch\n input        tms_pad_i, // JTAG test mode select pad\ninput         tck_pad_i, // JTAG test clock pad\ninput         trstn_pad_i, // JTAG test reset pad\ninput         tdi_pad_i, // JTAG test data input pad\noutput        tdo_pad_o, // JTAG test data output pad\noutput        tdo_padoe_o, // Output enable for JTAG test data output pad\noutput [5:0]  latched_jtag_ir,                \n output [7:0] o_led,\n input        clk_p,\n input        rst_top\n  );\n\n    parameter ROC_WIDTH = 100000;\n    parameter TOC_WIDTH = 0;\n  \n// TAP states\nwire  test_logic_reset_o;\nwire  run_test_idle_o;\nwire  shift_dr_o;\nwire  pause_dr_o;\nwire  update_dr_o;\nwire  capture_dr_o;\n\n// Select signals for boundary scan or mbist\nwire  extest_select_o;\nwire  sample_preload_select_o;\nwire  user1_select_o;\nwire  user2_select_o;\nwire  user3_select_o;\nwire  user4_select_o;\n\n// TDO signal that is connected to TDI of sub-modules.\nwire  tdi_o;\n\n// TDI signals from sub-modules\nwire   debug_tdo_i;    // from debug module\nwire   bs_chain_tdo_i; // from Boundary Scan Chain\nwire   user1_tdo_i;    // from BSCANE2 Chain\nwire   user2_tdo_i;    // from BSCANE2 Chain\nwire   user3_tdo_i;    // from BSCANE2 Chain\nwire   user4_tdo_i;    // from BSCANE2 Chain\n\n//--------   STARTUP Globals --------------\n    wire GSR;\n    wire GTS;\n    wire GWE;\n    wire PRLD;\n    tri1 p_up_tmp;\n    tri PLL_LOCKG = p_up_tmp;\n\n    wire PROGB_GLBL;\n    wire CCLKO_GLBL;\n    wire FCSBO_GLBL;\n    wire [3:0] DO_GLBL;\n    wire [3:0] DI_GLBL;\n   \n    reg GSR_int;\n    reg GTS_int;\n    reg PRLD_int;\n\n//--------   JTAG Globals --------------\n    wire JTAG_TCK_GLBL = tck_pad_i;\n    wire JTAG_TDI_GLBL = tdi_pad_i;\n    wire JTAG_TMS_GLBL = tms_pad_i;\n    wire JTAG_TRST_GLBL = !trstn_pad_i;\n\n    wire  JTAG_CAPTURE_GLBL = capture_dr_o;\n    wire  JTAG_RESET_GLBL = test_logic_reset_o;\n    wire  JTAG_SHIFT_GLBL = shift_dr_o;\n    wire  JTAG_UPDATE_GLBL = update_dr_o;\n    wire  JTAG_RUNTEST_GLBL = run_test_idle_o;\n\n    wire   JTAG_SEL1_GLBL = user1_select_o;\n    wire   JTAG_SEL2_GLBL = user2_select_o;\n    wire   JTAG_SEL3_GLBL = user3_select_o;\n    wire   JTAG_SEL4_GLBL = user4_select_o;\n\n    wire JTAG_TDO_GLBL;\n    assign tdo_pad_o = JTAG_TDO_GLBL;\n   \n    bit JTAG_USER_TDO1_GLBL;\n    bit JTAG_USER_TDO2_GLBL;\n    bit JTAG_USER_TDO3_GLBL;\n    bit JTAG_USER_TDO4_GLBL;\n\n   assign user1_tdo_i = JTAG_USER_TDO1_GLBL;\n   assign user2_tdo_i = JTAG_USER_TDO2_GLBL;\n   assign user3_tdo_i = JTAG_USER_TDO3_GLBL;\n   assign user4_tdo_i = JTAG_USER_TDO4_GLBL;\n   \n    assign GSR = GSR_int;\n    assign GTS = GTS_int;\n    assign PRLD = PRLD_int;\n\n    initial begin\n\tGSR_int = 1'b1;\n\tPRLD_int = 1'b1;\n\tGSR_int = 1'b0;\n\tPRLD_int = 1'b0;\n    end\n\n    initial begin\n\tGTS_int = 1'b1;\n\tGTS_int = 1'b0;\n    end\n\n  JTAGDummy dummy1(\n   // LED and DIP switch\n  .o_led(o_led),\n  .clk_p(clk_p),\n  .rst_top(rst_top)\n  );\n\n`ifdef TAP1   \n tap_top tap1 (\n                // JTAG pads\n                .tms_pad_i(tms_pad_i), \n                .tck_pad_i(tck_pad_i), \n                .trstn_pad_i(trstn_pad_i), \n                .tdi_pad_i(tdi_pad_i), \n                .tdo_pad_o(tdo_pad_o), \n                .tdo_padoe_o(tdo_padoe_o),\n\n                // TAP states\n\t\t.test_logic_reset_o(test_logic_reset_o),\n\t\t.run_test_idle_o(run_test_idle_o),\n                .shift_dr_o(shift_dr_o),\n                .pause_dr_o(pause_dr_o), \n                .update_dr_o(update_dr_o),\n                .capture_dr_o(capture_dr_o),\n                \n                // Select signals for boundary scan or mbist\n                .extest_select_o(extest_select_o), \n                .user1_select_o(user1_select_o), \n                .user2_select_o(user2_select_o), \n                .user3_select_o(user3_select_o), \n                .user4_select_o(user4_select_o), \n                .sample_preload_select_o(sample_preload_select_o),\n                \n                // TDO signal that is connected to TDI of sub-modules.\n                .tdi_o(tdi_o), \n                \n                // TDI signals from sub-modules\n                .user1_tdo_i(user1_tdo_i),    // from BSCANE2 module\n                .user2_tdo_i(user2_tdo_i),    // from BSCANE2 module\n                .user3_tdo_i(user3_tdo_i),    // from BSCANE2 module\n                .user4_tdo_i(user4_tdo_i),    // from BSCANE2 module\n                .bs_chain_tdo_i(bs_chain_tdo_i), // from Boundary Scan Chain\n\n                .latched_jtag_ir(latched_jtag_ir)\n              );\n`endif\n   \nendmodule\n`endif\n"}
