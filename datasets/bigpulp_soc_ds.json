{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`define REG_PADFUN0     6'b000000 //BASEADDR+0x00\n//`define REG_PADFUN1     6'b000001 //BASEADDR+0x04\n`define REG_CLKDIV0     6'b000010 //BASEADDR+0x08\n`define REG_CLKDIV1     6'b000011 //BASEADDR+0x0C\n`define REG_INFO        6'b000100 //BASEADDR+0x10\n`define REG_INFOEXTD    6'b000101 //BASEADDR+0x14\n`define REG_MMARGIN     6'b000110 //BASEADDR+0x18\n`define REG_PADCFG0     6'b000111 //BASEADDR+0x1C\n`define REG_PADCFG1     6'b001000 //BASEADDR+0x20\n`define REG_PADCFG2     6'b001001 //BASEADDR+0x24\n`define REG_PADCFG3     6'b001010 //BASEADDR+0x28\n`define REG_PADCFG4     6'b001011 //BASEADDR+0x2C\n`define REG_PADCFG5     6'b001100 //BASEADDR+0x30\n`define REG_PADCFG6     6'b001101 //BASEADDR+0x34\n`define REG_PADCFG7     6'b001110 //BASEADDR+0x38\n//`define REG_PADCFG8     6'b001111 //BASEADDR+0x3C\n`define REG_PWRCMD      6'b010000 //BASEADDR+0x40\n`define REG_PWRCFG      6'b010001 //BASEADDR+0x44\n`define REG_PWRREG      6'b010010 //BASEADDR+0x48\n`define REG_CLKDIV2     6'b010011 //BASEADDR+0x4C\n`define REG_CLKDIV3     6'b010100 //BASEADDR+0x50\n`define REG_HS_LS_L2    6'b010101 //BASEADDR+0x54\n`define REG_L2_SLEEP    6'b010110 //BASEADDR+0x58\n`define REG_CLKDIV4     6'b010111 //BASEADDR+0x5C\n\n`define REG_RES_CORE0   6'b100000 //BASEADDR+0x80\n`define REG_RES_CORE1   6'b100001 //BASEADDR+0x84\n`define REG_RES_CORE2   6'b100010 //BASEADDR+0x88\n`define REG_RES_CORE3   6'b100011 //BASEADDR+0x8C\n\nmodule apb_soc_ctrl_multicluster\n#(\n  parameter APB_ADDR_WIDTH = 12,   //APB slaves are 4KB by default\n  parameter NB_CLUSTERS     = 1,   //N_CLUSTERS\n  parameter NB_CORES        = 4    //N_CORES\n)\n(\n  input  logic                      HCLK,\n  input  logic                      HRESETn,\n  input  logic [APB_ADDR_WIDTH-1:0] PADDR,\n  input  logic               [31:0] PWDATA,\n  input  logic                      PWRITE,\n  input  logic                      PSEL,\n  input  logic                      PENABLE,\n  output logic               [31:0] PRDATA,\n  output logic                      PREADY,\n  output logic                      PSLVERR\n);\n\n  logic [7:0]                        r_res_core0;\n  logic [7:0]                        r_res_core1;\n  logic [7:0]                        r_res_core2;\n  logic [7:0]                        r_res_core3;\n\n  logic [5:0]                        s_apb_addr;\n\n  logic [15:0]                       n_cores;\n  logic [15:0]                       n_clusters;\n\n  assign s_apb_addr = PADDR[7:2];\n\n  always_ff @ (posedge HCLK, negedge HRESETn) \n    begin\n      if(~HRESETn) \n        begin\n          r_res_core0          <=  'h0;\n          r_res_core1          <=  'h0;\n          r_res_core2          <=  'h0;\n          r_res_core3          <=  'h0;\n        end\n      else \n        begin\n          if (PSEL && PENABLE && PWRITE)\n            begin\n              case (s_apb_addr)\n                `REG_RES_CORE0:\n                  begin\n                    r_res_core0      <= PWDATA[7:0];\n                  end                    \n                `REG_RES_CORE1:\n                  begin\n                    r_res_core1      <= PWDATA[7:0];\n                  end                    \n                `REG_RES_CORE2:\n                  begin\n                    r_res_core2      <= PWDATA[7:0];\n                  end                    \n                `REG_RES_CORE3:\n                  begin\n                    r_res_core3      <= PWDATA[7:0];\n                  end                    \n              endcase\n            end\n        end\n    end\n\n  always_comb\n    begin\n      case (s_apb_addr)\n        `REG_INFO:\n          PRDATA = {n_cores,n_clusters};\n        `REG_RES_CORE0:\n          PRDATA = {24'h0,r_res_core0};\n        `REG_RES_CORE1:\n          PRDATA = {24'h0,r_res_core1};\n        `REG_RES_CORE2:\n          PRDATA = {24'h0,r_res_core2};\n        `REG_RES_CORE3:\n          PRDATA = {24'h0,r_res_core3};\n        default:\n          PRDATA = 'h0;\n      endcase\n    end\n\n  assign n_cores    = NB_CORES;\n  assign n_clusters = NB_CLUSTERS;\n\n  assign PREADY  = 1'b1;\n  assign PSLVERR = 1'b0;\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"pulp_soc_defines.sv\"\n\nmodule axi2apb_wrap\n#(\n  parameter AXI_ADDR_WIDTH = 32,\n  parameter AXI_DATA_WIDTH = 64,\n  parameter AXI_USER_WIDTH = 6,\n  parameter AXI_ID_WIDTH   = 6,\n  parameter APB_ADDR_WIDTH = 12,\n  parameter APB_NUM_SLAVES = 8\n)\n(\n  input logic                              clk_i,\n  input logic                              rst_ni,\n  input logic                              test_en_i,\n\n  AXI_BUS.Slave                            axi_slave,\n\n  output logic                             penable,\n  output logic                             pwrite,\n  output logic        [APB_ADDR_WIDTH-1:0] paddr,\n  output logic        [APB_NUM_SLAVES-1:0] psel,\n  output logic                      [31:0] pwdata,\n  input  logic [APB_NUM_SLAVES-1:0] [31:0] prdata,\n  input  logic        [APB_NUM_SLAVES-1:0] pready,\n  input  logic        [APB_NUM_SLAVES-1:0] pslverr\n);\n\n\n  AXI_2_APB #(\n    .AXI4_ADDRESS_WIDTH ( AXI_ADDR_WIDTH   ),\n    .AXI4_RDATA_WIDTH   ( AXI_DATA_WIDTH   ),\n    .AXI4_WDATA_WIDTH   ( AXI_DATA_WIDTH   ),\n    .AXI4_ID_WIDTH      ( AXI_ID_WIDTH     ),\n    .AXI4_USER_WIDTH    ( AXI_USER_WIDTH   ),\n    .AXI_NUMBYTES       ( AXI_DATA_WIDTH/8 ),\n\n    .BUFF_DEPTH_SLAVE   ( 4                ),\n    .APB_NUM_SLAVES     ( APB_NUM_SLAVES   ),\n    .APB_ADDR_WIDTH     ( APB_ADDR_WIDTH   )  //APB slaves are 4KB by default\n  ) axi2apb_i (\n    .ACLK       (clk_i),\n    .ARESETn    (rst_ni),\n    .test_en_i  (test_en_i),\n    // ---------------------------------------------------------\n    // AXI TARG Port Declarations ------------------------------\n    // ---------------------------------------------------------\n    //AXI write address bus -------------- // USED// -----------\n    .AWID_i     (axi_slave.aw_id     ),\n    .AWADDR_i   (axi_slave.aw_addr   ),\n    .AWLEN_i    (axi_slave.aw_len    ),\n    .AWSIZE_i   (axi_slave.aw_size   ),\n    .AWBURST_i  (axi_slave.aw_burst  ),\n    .AWLOCK_i   (axi_slave.aw_lock   ),\n    .AWCACHE_i  (axi_slave.aw_cache  ),\n    .AWPROT_i   (axi_slave.aw_prot   ),\n    .AWREGION_i (axi_slave.aw_region ),\n    .AWUSER_i   (axi_slave.aw_user   ),\n    .AWQOS_i    (axi_slave.aw_qos    ),\n    .AWVALID_i  (axi_slave.aw_valid  ),\n    .AWREADY_o  (axi_slave.aw_ready  ),\n    // ---------------------------------------------------------\n\n    //AXI write data bus -------------- // USED// --------------\n    .WDATA_i    (axi_slave.w_data   ),\n    .WSTRB_i    (axi_slave.w_strb   ),\n    .WLAST_i    (axi_slave.w_last   ),\n    .WUSER_i    (axi_slave.w_user   ),\n    .WVALID_i   (axi_slave.w_valid  ),\n    .WREADY_o   (axi_slave.w_ready  ),\n    // ---------------------------------------------------------\n\n    //AXI write response bus -------------- // USED// ----------\n    .BID_o      (axi_slave.b_id     ),\n    .BRESP_o    (axi_slave.b_resp   ),\n    .BVALID_o   (axi_slave.b_valid  ),\n    .BUSER_o    (axi_slave.b_user   ),\n    .BREADY_i   (axi_slave.b_ready  ),\n    // ---------------------------------------------------------\n\n    //AXI read address bus -------------------------------------\n    .ARID_i     (axi_slave.ar_id     ),\n    .ARADDR_i   (axi_slave.ar_addr   ),\n    .ARLEN_i    (axi_slave.ar_len    ),\n    .ARSIZE_i   (axi_slave.ar_size   ),\n    .ARBURST_i  (axi_slave.ar_burst  ),\n    .ARLOCK_i   (axi_slave.ar_lock   ),\n    .ARCACHE_i  (axi_slave.ar_cache  ),\n    .ARPROT_i   (axi_slave.ar_prot   ),\n    .ARREGION_i (axi_slave.ar_region ),\n    .ARUSER_i   (axi_slave.ar_user   ),\n    .ARQOS_i    (axi_slave.ar_qos    ),\n    .ARVALID_i  (axi_slave.ar_valid  ),\n    .ARREADY_o  (axi_slave.ar_ready  ),\n    // ---------------------------------------------------------\n\n    //AXI read data bus ----------------------------------------\n    .RID_o      (axi_slave.r_id    ),\n    .RDATA_o    (axi_slave.r_data  ),\n    .RRESP_o    (axi_slave.r_resp  ),\n    .RLAST_o    (axi_slave.r_last  ),\n    .RUSER_o    (axi_slave.r_user  ),\n    .RVALID_o   (axi_slave.r_valid ),\n    .RREADY_i   (axi_slave.r_ready ),\n    // ---------------------------------------------------------\n\n    .PENABLE   (penable ),\n    .PWRITE    (pwrite  ),\n    .PADDR     (paddr   ),\n    .PSEL      (psel    ),\n    .PWDATA    (pwdata  ),\n    .PRDATA    (prdata  ),\n    .PREADY    (pready  ),\n    .PSLVERR   (pslverr )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"pulp_soc_defines.sv\"\n\nmodule axi_id_remap_wrap\n#(\n  parameter AXI_ADDR_WIDTH   = 32,\n  parameter AXI_DATA_WIDTH   = 64,\n  parameter AXI_USER_WIDTH   = 6,\n  parameter AXI_ID_IN_WIDTH  = 6,\n  parameter AXI_ID_OUT_WIDTH = 6,\n  parameter AXI_ID_SLOT      = 16\n)\n(\n  input logic\t   clk_i,\n  input logic\t   rst_ni,\n\n  AXI_BUS.Slave  axi_slave,\n\n  AXI_BUS.Master axi_master\n);\n\n  axi_id_remap #(\n    .AXI_ADDRESS_W ( AXI_ADDR_WIDTH   ),\n    .AXI_DATA_W    ( AXI_DATA_WIDTH   ),\n    .AXI_USER_W    ( AXI_USER_WIDTH   ),\n    .AXI_ID_IN     ( AXI_ID_IN_WIDTH  ),\n    .AXI_ID_OUT    ( AXI_ID_OUT_WIDTH ),\n    .ID_SLOT       ( AXI_ID_SLOT      )\n  ) axi_id_remap_i (\n    .clk             ( clk_i                                  ),\n    .rst_n           ( rst_ni                                 ),\n\n    .targ_awvalid_i  ( axi_slave.aw_valid                     ),\n    .targ_awaddr_i   ( axi_slave.aw_addr                      ),\n    .targ_awprot_i   ( axi_slave.aw_prot                      ),\n    .targ_awregion_i ( axi_slave.aw_region                    ),\n    .targ_awlen_i    ( axi_slave.aw_len                       ),\n    .targ_awsize_i   ( axi_slave.aw_size                      ),\n    .targ_awburst_i  ( axi_slave.aw_burst                     ),\n    .targ_awlock_i   ( axi_slave.aw_lock                      ),\n    .targ_awcache_i  ( axi_slave.aw_cache                     ),\n    .targ_awqos_i    ( axi_slave.aw_qos                       ),\n    .targ_awid_i     ( axi_slave.aw_id[AXI_ID_IN_WIDTH-1:0]   ),\n    .targ_awuser_i   ( axi_slave.aw_user                      ),\n    .targ_awready_o  ( axi_slave.aw_ready                     ),\n\n    .targ_arvalid_i  ( axi_slave.ar_valid                     ),\n    .targ_araddr_i   ( axi_slave.ar_addr                      ),\n    .targ_arprot_i   ( axi_slave.ar_prot                      ),\n    .targ_arregion_i ( axi_slave.ar_region                    ),\n    .targ_arlen_i    ( axi_slave.ar_len                       ),\n    .targ_arsize_i   ( axi_slave.ar_size                      ),\n    .targ_arburst_i  ( axi_slave.ar_burst                     ),\n    .targ_arlock_i   ( axi_slave.ar_lock                      ),\n    .targ_arcache_i  ( axi_slave.ar_cache                     ),\n    .targ_arqos_i    ( axi_slave.ar_qos                       ),\n    .targ_arid_i     ( axi_slave.ar_id[AXI_ID_IN_WIDTH-1:0]   ),\n    .targ_aruser_i   ( axi_slave.ar_user                      ),\n    .targ_arready_o  ( axi_slave.ar_ready                     ),\n\n    .targ_wvalid_i   ( axi_slave.w_valid                      ),\n    .targ_wdata_i    ( axi_slave.w_data                       ),\n    .targ_wstrb_i    ( axi_slave.w_strb                       ),\n    .targ_wuser_i    ( axi_slave.w_user                       ),\n    .targ_wlast_i    ( axi_slave.w_last                       ),\n    .targ_wready_o   ( axi_slave.w_ready                      ),\n\n    .targ_rvalid_o   ( axi_slave.r_valid                      ),\n    .targ_rdata_o    ( axi_slave.r_data                       ),\n    .targ_rresp_o    ( axi_slave.r_resp                       ),\n    .targ_rlast_o    ( axi_slave.r_last                       ),\n    .targ_rid_o      ( axi_slave.r_id[AXI_ID_IN_WIDTH-1:0]    ),\n    .targ_ruser_o    ( axi_slave.r_user                       ),\n    .targ_rready_i   ( axi_slave.r_ready                      ),\n\n    .targ_bvalid_o   ( axi_slave.b_valid                      ),\n    .targ_bresp_o    ( axi_slave.b_resp                       ),\n    .targ_bid_o      ( axi_slave.b_id[AXI_ID_IN_WIDTH-1:0]    ),\n    .targ_buser_o    ( axi_slave.b_user                       ),\n    .targ_bready_i   ( axi_slave.b_ready                      ),\n\n    .init_awvalid_o  ( axi_master.aw_valid                    ),\n    .init_awaddr_o   ( axi_master.aw_addr                     ),\n    .init_awprot_o   ( axi_master.aw_prot                     ),\n    .init_awregion_o ( axi_master.aw_region                   ),\n    .init_awlen_o    ( axi_master.aw_len                      ),\n    .init_awsize_o   ( axi_master.aw_size                     ),\n    .init_awburst_o  ( axi_master.aw_burst                    ),\n    .init_awlock_o   ( axi_master.aw_lock                     ),\n    .init_awcache_o  ( axi_master.aw_cache                    ),\n    .init_awqos_o    ( axi_master.aw_qos                      ),\n    .init_awid_o     ( axi_master.aw_id[AXI_ID_OUT_WIDTH-1:0] ),\n    .init_awuser_o   ( axi_master.aw_user                     ),\n    .init_awready_i  ( axi_master.aw_ready                    ),\n\n    .init_arvalid_o  ( axi_master.ar_valid                    ),\n    .init_araddr_o   ( axi_master.ar_addr                     ),\n    .init_arprot_o   ( axi_master.ar_prot                     ),\n    .init_arregion_o ( axi_master.ar_region                   ),\n    .init_arlen_o    ( axi_master.ar_len                      ),\n    .init_arsize_o   ( axi_master.ar_size                     ),\n    .init_arburst_o  ( axi_master.ar_burst                    ),\n    .init_arlock_o   ( axi_master.ar_lock                     ),\n    .init_arcache_o  ( axi_master.ar_cache                    ),\n    .init_arqos_o    ( axi_master.ar_qos                      ),\n    .init_arid_o     ( axi_master.ar_id[AXI_ID_OUT_WIDTH-1:0] ),\n    .init_aruser_o   ( axi_master.ar_user                     ),\n    .init_arready_i  ( axi_master.ar_ready                    ),\n\n    .init_wvalid_o   ( axi_master.w_valid                     ),\n    .init_wdata_o    ( axi_master.w_data                      ),\n    .init_wstrb_o    ( axi_master.w_strb                      ),\n    .init_wuser_o    ( axi_master.w_user                      ),\n    .init_wlast_o    ( axi_master.w_last                      ),\n    .init_wready_i   ( axi_master.w_ready                     ),\n\n    .init_rvalid_i   ( axi_master.r_valid                     ),\n    .init_rdata_i    ( axi_master.r_data                      ),\n    .init_rresp_i    ( axi_master.r_resp                      ),\n    .init_rlast_i    ( axi_master.r_last                      ),\n    .init_rid_i      ( axi_master.r_id[AXI_ID_OUT_WIDTH-1:0]  ),\n    .init_ruser_i    ( axi_master.r_user                      ),\n    .init_rready_o   ( axi_master.r_ready                     ),\n\n    .init_bvalid_i   ( axi_master.b_valid                     ),\n    .init_bresp_i    ( axi_master.b_resp                      ),\n    .init_bid_i      ( axi_master.b_id[AXI_ID_OUT_WIDTH-1:0]  ),\n    .init_buser_i    ( axi_master.b_user                      ),\n    .init_bready_o   ( axi_master.b_ready                     )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// --=========================================================================--\n//\n//  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557    \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n// \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551  \u2588\u2588\u2588\u2557\n// \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551   \u2588\u2588\u2551\n// \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u255d \u2588\u2588\u2557\u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n// \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d    \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d    \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \n//\n// \n// Author: Pirmin Vogel - vogelpi@iis.ee.ethz.ch\n// \n// Purpose : AXI4-Lite interrupt register with clear on read\n//           Writes are completely ignored!\n//\n//           The interrupt remains high until cleared.\n//\n//           Edge detection on input interrupts.\n// \n// --=========================================================================--\n\nmodule axi_intr_reg\n  #(\n    parameter AXI_ADDR_WIDTH = 32,\n    parameter AXI_DATA_WIDTH = 64\n   )\n  (\n    input  logic                      Clk_CI,\n    input  logic                      Rst_RBI,\n    \n    AXI_LITE.Slave                    axi4lite,\n\n    input  logic [AXI_DATA_WIDTH-1:0] IntrPulp_SI,\n    output logic                      IntrHost_SO\n  );\n\n  //  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557\u2588\u2588\u2557  \u2588\u2588\u2557      \u2588\u2588\u2557     \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551      \u2588\u2588\u2551     \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \n  // \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u255d \u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551      \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d      \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n  //    \n  logic [AXI_ADDR_WIDTH-1:0]         awaddr_reg;\n  logic                              awaddr_done_rise;\n  logic                              awaddr_done_reg;\n  logic                              awaddr_done_reg_dly;\n\n  logic [AXI_DATA_WIDTH-1:0]         wdata_reg;\n  logic [AXI_ADDR_WIDTH/8-1:0]       wstrb_reg;\n  logic                              wdata_done_rise;\n  logic                              wdata_done_reg;\n  logic                              wdata_done_reg_dly;\n\n  logic                              bresp_done_reg;\n  logic                              bresp_running_reg;\n\n  logic [AXI_ADDR_WIDTH-1:0]         araddr_reg;\n  logic                              araddr_done_reg;\n\n  logic [AXI_DATA_WIDTH-1:0]         rdata_reg;\n  logic                              rresp_done_reg;\n  logic                              rresp_running_reg;\n\n  logic                              write_en;\n\n  assign write_en         = ( wdata_done_rise & awaddr_done_reg ) | ( awaddr_done_rise & wdata_done_reg );\n  assign wdata_done_rise  = wdata_done_reg  & ~wdata_done_reg_dly;\n  assign awaddr_done_rise = awaddr_done_reg & ~awaddr_done_reg_dly;\n\n  assign rdata_reg = '0; // not used\n   \n  // reg_dly\n  always @(posedge Clk_CI or negedge Rst_RBI)\n    begin\n      if ( Rst_RBI == 1'b0 )\n        begin\n          wdata_done_reg_dly  <= 1'b0;\n          awaddr_done_reg_dly <= 1'b0;\n        end\n      else\n        begin\n          wdata_done_reg_dly  <= wdata_done_reg;\n          awaddr_done_reg_dly <= awaddr_done_reg;\n        end\n    end\n\n  // AW Channel\n  always @(posedge Clk_CI or negedge Rst_RBI)\n    begin\n      if ( Rst_RBI == 1'b0 )\n        begin\n          awaddr_done_reg   <= 1'b0;\n          awaddr_reg        <= '0;\n          axi4lite.aw_ready <= 1'b1;\n        end\n      else\n        begin\n          if (axi4lite.aw_ready && axi4lite.aw_valid)\n            begin\n              axi4lite.aw_ready <= 1'b0;\n              awaddr_done_reg   <= 1'b1;\n              awaddr_reg        <= axi4lite.aw_addr;\n            end\n          else if (awaddr_done_reg && bresp_done_reg)\n            begin\n              axi4lite.aw_ready <= 1'b1;\n              awaddr_done_reg   <= 1'b0;\n            end\n        end\n    end\n\n  // W Channel\n  always @(posedge Clk_CI or negedge Rst_RBI)\n    begin\n      if ( Rst_RBI == 1'b0 )\n        begin\n          wdata_done_reg   <= 1'b0;\n          axi4lite.w_ready <= 1'b1;\n          wdata_reg        <= '0;\n          wstrb_reg        <= '0;\n        end\n      else\n        begin\n          if (axi4lite.w_ready && axi4lite.w_valid)\n            begin\n              axi4lite.w_ready <= 1'b0;\n              wdata_done_reg   <= 1'b1;\n              wdata_reg        <= axi4lite.w_data;\n              wstrb_reg        <= axi4lite.w_strb;\n            end\n          else if (wdata_done_reg && bresp_done_reg)\n            begin\n              axi4lite.w_ready <= 1'b1;\n              wdata_done_reg   <= 1'b0;\n            end\n        end\n    end\n\n  // B Channel\n  always @(posedge Clk_CI or negedge Rst_RBI)\n    begin\n      if ( Rst_RBI == 1'b0 )\n        begin\n          axi4lite.b_valid  <= 1'b0;\n          bresp_done_reg    <= 1'b0;\n          bresp_running_reg <= 1'b0;\n        end\n      else\n        begin\n          if (awaddr_done_reg && wdata_done_reg && !bresp_done_reg)\n            begin\n              if ( bresp_running_reg == 1'b0 )\n                begin\n                  axi4lite.b_valid  <= 1'b1;\n                  bresp_running_reg <= 1'b1;\n                end\n              else if ( axi4lite.b_ready == 1'b1 )\n                begin\n                  axi4lite.b_valid  <= 1'b0;\n                  bresp_done_reg    <= 1'b1;\n                  bresp_running_reg <= 1'b0;\n                end\n            end\n          else\n            begin\n               axi4lite.b_valid  <= 1'b0;\n               bresp_done_reg    <= 1'b0;\n               bresp_running_reg <= 1'b0;\n            end\n        end\n    end\n\n  // AR Channel\n  always @(posedge Clk_CI or negedge Rst_RBI)\n    begin\n      if ( Rst_RBI == 1'b0 )\n        begin\n          araddr_done_reg   <= 1'b0;\n          axi4lite.ar_ready <= 1'b1;\n          araddr_reg        <= '0;\n        end\n      else\n        begin\n          if (axi4lite.ar_ready && axi4lite.ar_valid)\n            begin\n              axi4lite.ar_ready <= 1'b0;\n              araddr_done_reg   <= 1'b1;\n              araddr_reg        <= axi4lite.ar_addr;\n            end\n          else if (araddr_done_reg && rresp_done_reg)\n            begin\n              axi4lite.ar_ready <= 1'b1;\n              araddr_done_reg   <= 1'b0;\n            end\n        end\n    end\n\n  // R Channel\n  always @(posedge Clk_CI or negedge Rst_RBI)\n    begin\n      if ( Rst_RBI == 1'b0 )\n        begin\n          rresp_done_reg    <= 1'b0;\n          axi4lite.r_valid  <= 1'b0;\n          rresp_running_reg <= 1'b0;\n        end\n      else\n        begin\n          if (araddr_done_reg && !rresp_done_reg)\n            begin\n              if ( rresp_running_reg == 1'b0 )\n                begin\n                  axi4lite.r_valid  <= 1'b1;\n                  rresp_running_reg <= 1'b1;\n                end\n              else if (axi4lite.r_ready == 1'b1)\n                begin\n                  axi4lite.r_valid  <= 1'b0;\n                  rresp_done_reg    <= 1'b1;\n                  rresp_running_reg <= 1'b0;\n                end\n            end\n          else\n            begin\n              axi4lite.r_valid  <= 1'b0;\n              rresp_done_reg    <= 1'b0;\n              rresp_running_reg <= 1'b0;\n            end\n        end\n    end\n   \n  assign axi4lite.b_resp = 2'b00;\n  assign axi4lite.r_resp = 2'b00;\n\n  // \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n  // \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \n  // \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551  \u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551   \u2588\u2588\u2551\n  // \u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n  // \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d    \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \n  //                                                              \n  logic [AXI_DATA_WIDTH-1:0]         Intr_SP, Intr_SN;\n  logic [AXI_DATA_WIDTH-1:0]         IntrPulp_SN, IntrPulp_SP;\n  logic [AXI_DATA_WIDTH-1:0]         IntrEdge_S;\n  logic                              IntrHost_SP, IntrHost_SN;\n\n  logic                              IntrEn_S, IntrClr_S;\n\n  // input\n  assign IntrPulp_SN = IntrPulp_SI;\n\n  // output\n  assign IntrHost_SO = IntrHost_SP;\n\n  // edge detection\n  assign IntrEdge_S = (~IntrPulp_SP) & IntrPulp_SN;\n\n  // enable\n  assign IntrEn_S = |IntrEdge_S;\n\n  // interrupt\n  assign IntrHost_SN     = 1'b1;    // only latched upon IntrEn_S\n  assign Intr_SN         = Intr_SP | IntrPulp_SN;\n  assign axi4lite.r_data = Intr_SN; // don't miss interrupts arriving in the read cycle\n  \n  // clear on read\n  assign IntrClr_S = axi4lite.r_valid & axi4lite.r_ready;\n\n  // the registers\n  always_ff @(posedge Clk_CI, negedge Rst_RBI)\n    begin\n      if ( Rst_RBI == 1'b0 )\n        begin\n          Intr_SP     <=  'b0;\n          IntrHost_SP <= 1'b0;\n          IntrPulp_SP <=  'b0;\n        end\n      else\n        begin\n          IntrPulp_SP <= IntrPulp_SN; \n          if      ( IntrClr_S == 1'b1 )\n            begin\n              Intr_SP     <=  'b0;\n              IntrHost_SP <= 1'b0;\n            end\n          else if ( IntrEn_S  == 1'b1 )\n            begin\n              Intr_SP     <= Intr_SN;\n              IntrHost_SP <= IntrHost_SN;\n            end\n        end\n    end\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule axi_mem_if_wrap\n#(\n  parameter AXI_ADDRESS_WIDTH = 32,\n  parameter AXI_DATA_WIDTH    = 64,\n  parameter AXI_ID_WIDTH      = 16,\n  parameter AXI_USER_WIDTH    = 10,\n  parameter BUFF_DEPTH_SLAVE  = 2\n)\n(\n  input logic              clk_i,\n  input logic              rst_ni,\n  input logic              test_en_i,\n\n  AXI_BUS.Slave            axi_slave,\n\n  UNICAD_MEM_BUS_64.Master mem_master\n);\n\n  logic [AXI_ADDRESS_WIDTH-1:0] aw_addr;\n  logic [AXI_ADDRESS_WIDTH-1:0] ar_addr;\n\n  assign aw_addr = {3'b000, axi_slave.aw_addr[AXI_ADDRESS_WIDTH-1:3]};\n  assign ar_addr = {3'b000, axi_slave.ar_addr[AXI_ADDRESS_WIDTH-1:3]};\n\n  axi_mem_if #(\n    .AXI4_ADDRESS_WIDTH ( AXI_ADDRESS_WIDTH   ),\n    .AXI4_RDATA_WIDTH   ( AXI_DATA_WIDTH      ),\n    .AXI4_WDATA_WIDTH   ( AXI_DATA_WIDTH      ),\n    .AXI4_ID_WIDTH      ( AXI_ID_WIDTH        ),\n    .AXI4_USER_WIDTH    ( AXI_USER_WIDTH      ),\n    .BUFF_DEPTH_SLAVE   ( BUFF_DEPTH_SLAVE    )\n  ) axi_mem_if_i (\n    .ACLK               ( clk_i               ),\n    .ARESETn            ( rst_ni              ),\n    .test_en_i          ( test_en_i           ),\n\n    .AWVALID_i          ( axi_slave.aw_valid  ),\n    .AWADDR_i           ( aw_addr             ),\n    .AWPROT_i           ( axi_slave.aw_prot   ),\n    .AWREGION_i         ( axi_slave.aw_region ),\n    .AWLEN_i            ( axi_slave.aw_len    ),\n    .AWSIZE_i           ( axi_slave.aw_size   ),\n    .AWBURST_i          ( axi_slave.aw_burst  ),\n    .AWLOCK_i           ( axi_slave.aw_lock   ),\n    .AWCACHE_i          ( axi_slave.aw_cache  ),\n    .AWQOS_i            ( axi_slave.aw_qos    ),\n    .AWID_i             ( axi_slave.aw_id     ),\n    .AWUSER_i           ( axi_slave.aw_user   ),\n    .AWREADY_o          ( axi_slave.aw_ready  ),\n\n    .ARVALID_i          ( axi_slave.ar_valid  ),\n    .ARADDR_i           ( ar_addr             ),\n    .ARPROT_i           ( axi_slave.ar_prot   ),\n    .ARREGION_i         ( axi_slave.ar_region ),\n    .ARLEN_i            ( axi_slave.ar_len    ),\n    .ARSIZE_i           ( axi_slave.ar_size   ),\n    .ARBURST_i          ( axi_slave.ar_burst  ),\n    .ARLOCK_i           ( axi_slave.ar_lock   ),\n    .ARCACHE_i          ( axi_slave.ar_cache  ),\n    .ARQOS_i            ( axi_slave.ar_qos    ),\n    .ARID_i             ( axi_slave.ar_id     ),\n    .ARUSER_i           ( axi_slave.ar_user   ),\n    .ARREADY_o          ( axi_slave.ar_ready  ),\n\n    .RVALID_o           ( axi_slave.r_valid   ),\n    .RDATA_o            ( axi_slave.r_data    ),\n    .RRESP_o            ( axi_slave.r_resp    ),\n    .RLAST_o            ( axi_slave.r_last    ),\n    .RID_o              ( axi_slave.r_id      ),\n    .RUSER_o            ( axi_slave.r_user    ),\n    .RREADY_i           ( axi_slave.r_ready   ),\n\n    .WVALID_i           ( axi_slave.w_valid   ),\n    .WDATA_i            ( axi_slave.w_data    ),\n    .WSTRB_i            ( axi_slave.w_strb    ),\n    .WLAST_i            ( axi_slave.w_last    ),\n    .WUSER_i            ( axi_slave.w_user    ),\n    .WREADY_o           ( axi_slave.w_ready   ),\n\n    .BVALID_o           ( axi_slave.b_valid   ),\n    .BRESP_o            ( axi_slave.b_resp    ),\n    .BID_o              ( axi_slave.b_id      ),\n    .BUSER_o            ( axi_slave.b_user    ),\n    .BREADY_i           ( axi_slave.b_ready   ),\n\n    .CEN                ( mem_master.csn      ),\n    .WEN                ( mem_master.wen      ),\n    .A                  ( mem_master.add      ),\n    .D                  ( mem_master.wdata    ),\n    .BE                 ( mem_master.be       ),\n    .Q                  ( mem_master.rdata    )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"soc_bus_defines.sv\"\n\nmodule axi_node_intf_wrap\n  #(\n    parameter NB_MASTER        = 4,\n    parameter NB_SLAVE         = 4,\n    parameter NB_REGION        = 1,\n    parameter AXI_ADDR_WIDTH   = 32,\n    parameter AXI_DATA_WIDTH   = 32,\n    parameter AXI_ID_IN_WIDTH  = 6,\n    parameter AXI_ID_OUT_WIDTH = 10,\n    parameter AXI_USER_WIDTH   = 0\n    )\n  (\n    // Clock and Reset\n    input logic clk,\n    input logic rst_n,\n\n    input logic test_en_i,\n\n    AXI_BUS.Slave  slave[NB_SLAVE-1:0],\n\n    AXI_BUS.Master master[NB_MASTER-1:0],\n\n    // Memory map\n    input  logic [NB_REGION-1:0][NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0]  start_addr_i,\n    input  logic [NB_REGION-1:0][NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0]  end_addr_i,\n    input  logic [NB_REGION-1:0][NB_MASTER-1:0]                      valid_rule_i,\n    input  logic [ NB_SLAVE-1:0][NB_MASTER-1:0]                      connectivity_map_i\n  );\n\n  localparam AXI_STRB_WIDTH = AXI_DATA_WIDTH/8;\n\n  // AXI ID WIDTHs for master and slave IPs\n  localparam AXI_ID_WIDTH_TARG = AXI_ID_IN_WIDTH;\n  localparam AXI_ID_WIDTH_INIT = AXI_ID_OUT_WIDTH;\n\n\n  // Signals to slave periperhals\n  logic [NB_MASTER-1:0][AXI_ID_WIDTH_INIT-1:0] s_master_aw_id;\n  logic [NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0]    s_master_aw_addr;\n  logic [NB_MASTER-1:0][7:0]                   s_master_aw_len;\n  logic [NB_MASTER-1:0][2:0]                   s_master_aw_size;\n  logic [NB_MASTER-1:0][1:0]                   s_master_aw_burst;\n  logic [NB_MASTER-1:0]                        s_master_aw_lock;\n  logic [NB_MASTER-1:0][3:0]                   s_master_aw_cache;\n  logic [NB_MASTER-1:0][2:0]                   s_master_aw_prot;\n  logic [NB_MASTER-1:0][3:0]                   s_master_aw_region;\n  logic [NB_MASTER-1:0][AXI_USER_WIDTH-1:0]    s_master_aw_user;\n  logic [NB_MASTER-1:0][3:0]                   s_master_aw_qos;\n  logic [NB_MASTER-1:0]                        s_master_aw_valid;\n  logic [NB_MASTER-1:0]                        s_master_aw_ready;\n\n  logic [NB_MASTER-1:0][AXI_ID_WIDTH_INIT-1:0] s_master_ar_id;\n  logic [NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0]    s_master_ar_addr;\n  logic [NB_MASTER-1:0][7:0]                   s_master_ar_len;\n  logic [NB_MASTER-1:0][2:0]                   s_master_ar_size;\n  logic [NB_MASTER-1:0][1:0]                   s_master_ar_burst;\n  logic [NB_MASTER-1:0]                        s_master_ar_lock;\n  logic [NB_MASTER-1:0][3:0]                   s_master_ar_cache;\n  logic [NB_MASTER-1:0][2:0]                   s_master_ar_prot;\n  logic [NB_MASTER-1:0][3:0]                   s_master_ar_region;\n  logic [NB_MASTER-1:0][AXI_USER_WIDTH-1:0]    s_master_ar_user;\n  logic [NB_MASTER-1:0][3:0]                   s_master_ar_qos;\n  logic [NB_MASTER-1:0]                        s_master_ar_valid;\n  logic [NB_MASTER-1:0]                        s_master_ar_ready;\n\n  logic [NB_MASTER-1:0][AXI_DATA_WIDTH-1:0]    s_master_w_data;\n  logic [NB_MASTER-1:0][AXI_STRB_WIDTH-1:0]    s_master_w_strb;\n  logic [NB_MASTER-1:0]                        s_master_w_last;\n  logic [NB_MASTER-1:0][AXI_USER_WIDTH-1:0]    s_master_w_user;\n  logic [NB_MASTER-1:0]                        s_master_w_valid;\n  logic [NB_MASTER-1:0]                        s_master_w_ready;\n\n  logic [NB_MASTER-1:0][AXI_ID_WIDTH_INIT-1:0] s_master_b_id;\n  logic [NB_MASTER-1:0][1:0]                   s_master_b_resp;\n  logic [NB_MASTER-1:0]                        s_master_b_valid;\n  logic [NB_MASTER-1:0][AXI_USER_WIDTH-1:0]    s_master_b_user;\n  logic [NB_MASTER-1:0]                        s_master_b_ready;\n\n  logic [NB_MASTER-1:0][AXI_ID_WIDTH_INIT-1:0] s_master_r_id;\n  logic [NB_MASTER-1:0][AXI_DATA_WIDTH-1:0]    s_master_r_data;\n  logic [NB_MASTER-1:0][1:0]                   s_master_r_resp;\n  logic [NB_MASTER-1:0]                        s_master_r_last;\n  logic [NB_MASTER-1:0][AXI_USER_WIDTH-1:0]    s_master_r_user;\n  logic [NB_MASTER-1:0]                        s_master_r_valid;\n  logic [NB_MASTER-1:0]                        s_master_r_ready;\n\n  // Signals from AXI masters\n  logic [NB_SLAVE-1:0][AXI_ID_WIDTH_TARG-1:0] s_slave_aw_id;\n  logic [NB_SLAVE-1:0][AXI_ADDR_WIDTH-1:0]    s_slave_aw_addr;\n  logic [NB_SLAVE-1:0][7:0]                   s_slave_aw_len;\n  logic [NB_SLAVE-1:0][2:0]                   s_slave_aw_size;\n  logic [NB_SLAVE-1:0][1:0]                   s_slave_aw_burst;\n  logic [NB_SLAVE-1:0]                        s_slave_aw_lock;\n  logic [NB_SLAVE-1:0][3:0]                   s_slave_aw_cache;\n  logic [NB_SLAVE-1:0][2:0]                   s_slave_aw_prot;\n  logic [NB_SLAVE-1:0][3:0]                   s_slave_aw_region;\n  logic [NB_SLAVE-1:0][AXI_USER_WIDTH-1:0]    s_slave_aw_user;\n  logic [NB_SLAVE-1:0][3:0]                   s_slave_aw_qos;\n  logic [NB_SLAVE-1:0]                        s_slave_aw_valid;\n  logic [NB_SLAVE-1:0]                        s_slave_aw_ready;\n\n  logic [NB_SLAVE-1:0][AXI_ID_WIDTH_TARG-1:0] s_slave_ar_id;\n  logic [NB_SLAVE-1:0][AXI_ADDR_WIDTH-1:0]    s_slave_ar_addr;\n  logic [NB_SLAVE-1:0][7:0]                   s_slave_ar_len;\n  logic [NB_SLAVE-1:0][2:0]                   s_slave_ar_size;\n  logic [NB_SLAVE-1:0][1:0]                   s_slave_ar_burst;\n  logic [NB_SLAVE-1:0]                        s_slave_ar_lock;\n  logic [NB_SLAVE-1:0][3:0]                   s_slave_ar_cache;\n  logic [NB_SLAVE-1:0][2:0]                   s_slave_ar_prot;\n  logic [NB_SLAVE-1:0][3:0]                   s_slave_ar_region;\n  logic [NB_SLAVE-1:0][AXI_USER_WIDTH-1:0]    s_slave_ar_user;\n  logic [NB_SLAVE-1:0][3:0]                   s_slave_ar_qos;\n  logic [NB_SLAVE-1:0]                        s_slave_ar_valid;\n  logic [NB_SLAVE-1:0]                        s_slave_ar_ready;\n\n  logic [NB_SLAVE-1:0][AXI_DATA_WIDTH-1:0]    s_slave_w_data;\n  logic [NB_SLAVE-1:0][AXI_STRB_WIDTH-1:0]    s_slave_w_strb;\n  logic [NB_SLAVE-1:0]                        s_slave_w_last;\n  logic [NB_SLAVE-1:0][AXI_USER_WIDTH-1:0]    s_slave_w_user;\n  logic [NB_SLAVE-1:0]                        s_slave_w_valid;\n  logic [NB_SLAVE-1:0]                        s_slave_w_ready;\n\n  logic [NB_SLAVE-1:0][AXI_ID_WIDTH_TARG-1:0] s_slave_b_id;\n  logic [NB_SLAVE-1:0][1:0]                   s_slave_b_resp;\n  logic [NB_SLAVE-1:0]                        s_slave_b_valid;\n  logic [NB_SLAVE-1:0][AXI_USER_WIDTH-1:0]    s_slave_b_user;\n  logic [NB_SLAVE-1:0]                        s_slave_b_ready;\n\n  logic [NB_SLAVE-1:0][AXI_ID_WIDTH_TARG-1:0] s_slave_r_id;\n  logic [NB_SLAVE-1:0][AXI_DATA_WIDTH-1:0]    s_slave_r_data;\n  logic [NB_SLAVE-1:0][1:0]                   s_slave_r_resp;\n  logic [NB_SLAVE-1:0]                        s_slave_r_last;\n  logic [NB_SLAVE-1:0][AXI_USER_WIDTH-1:0]    s_slave_r_user;\n  logic [NB_SLAVE-1:0]                        s_slave_r_valid;\n  logic [NB_SLAVE-1:0]                        s_slave_r_ready;\n\n\n  generate\n    genvar i;\n    for(i = 0; i < NB_MASTER; i++)\n    begin\n      assign                        master[i].aw_id[AXI_ID_WIDTH_INIT-1:0] = s_master_aw_id[i];\n      assign                        master[i].aw_addr                      = s_master_aw_addr[i];\n      assign                        master[i].aw_len                       = s_master_aw_len[i];\n      assign                        master[i].aw_size                      = s_master_aw_size[i];\n      assign                        master[i].aw_burst                     = s_master_aw_burst[i];\n      assign                        master[i].aw_lock                      = s_master_aw_lock[i];\n      assign                        master[i].aw_cache                     = s_master_aw_cache[i];\n      assign                        master[i].aw_prot                      = s_master_aw_prot[i];\n      assign                        master[i].aw_region                    = s_master_aw_region[i];\n      assign                        master[i].aw_user                      = s_master_aw_user[i];\n      assign                        master[i].aw_qos                       = s_master_aw_qos[i];\n      assign                        master[i].aw_valid                     = s_master_aw_valid[i];\n      assign s_master_aw_ready[i] = master[i].aw_ready;\n\n      assign                        master[i].ar_id[AXI_ID_WIDTH_INIT-1:0] = s_master_ar_id[i];\n      assign                        master[i].ar_addr                      = s_master_ar_addr[i];\n      assign                        master[i].ar_len                       = s_master_ar_len[i];\n      assign                        master[i].ar_size                      = s_master_ar_size[i];\n      assign                        master[i].ar_burst                     = s_master_ar_burst[i];\n      assign                        master[i].ar_lock                      = s_master_ar_lock[i];\n      assign                        master[i].ar_cache                     = s_master_ar_cache[i];\n      assign                        master[i].ar_prot                      = s_master_ar_prot[i];\n      assign                        master[i].ar_region                    = s_master_ar_region[i];\n      assign                        master[i].ar_user                      = s_master_ar_user[i];\n      assign                        master[i].ar_qos                       = s_master_ar_qos[i];\n      assign                        master[i].ar_valid                     = s_master_ar_valid[i];\n      assign s_master_ar_ready[i] = master[i].ar_ready;\n\n      assign                        master[i].w_data  = s_master_w_data[i];\n      assign                        master[i].w_strb  = s_master_w_strb[i];\n      assign                        master[i].w_last  = s_master_w_last[i];\n      assign                        master[i].w_user  = s_master_w_user[i];\n      assign                        master[i].w_valid = s_master_w_valid[i];\n      assign s_master_w_ready[i]  = master[i].w_ready;\n\n      assign s_master_b_id[i]     = master[i].b_id[AXI_ID_WIDTH_INIT-1:0];\n      assign s_master_b_resp[i]   = master[i].b_resp;\n      assign s_master_b_valid[i]  = master[i].b_valid;\n      assign s_master_b_user[i]   = master[i].b_user;\n      assign                        master[i].b_ready = s_master_b_ready[i];\n\n      assign s_master_r_id[i]     = master[i].r_id[AXI_ID_WIDTH_INIT-1:0];\n      assign s_master_r_data[i]   = master[i].r_data;\n      assign s_master_r_resp[i]   = master[i].r_resp;\n      assign s_master_r_last[i]   = master[i].r_last;\n      assign s_master_r_user[i]   = master[i].r_user;\n      assign s_master_r_valid[i]  = master[i].r_valid;\n      assign                        master[i].r_ready = s_master_r_ready[i];\n    end\n  endgenerate\n\n  generate\n    genvar j;\n    for(j = 0; j < NB_SLAVE; j++)\n    begin\n      assign s_slave_aw_id[j]     = slave[j].aw_id[AXI_ID_WIDTH_TARG-1:0];\n      assign s_slave_aw_addr[j]   = slave[j].aw_addr;\n      assign s_slave_aw_len[j]    = slave[j].aw_len;\n      assign s_slave_aw_size[j]   = slave[j].aw_size;\n      assign s_slave_aw_burst[j]  = slave[j].aw_burst;\n      assign s_slave_aw_lock[j]   = slave[j].aw_lock;\n      assign s_slave_aw_cache[j]  = slave[j].aw_cache;\n      assign s_slave_aw_prot[j]   = slave[j].aw_prot;\n      assign s_slave_aw_region[j] = slave[j].aw_region;\n      assign s_slave_aw_user[j]   = slave[j].aw_user;\n      assign s_slave_aw_qos[j]    = slave[j].aw_qos;\n      assign s_slave_aw_valid[j]  = slave[j].aw_valid;\n      assign                        slave[j].aw_ready = s_slave_aw_ready[j];\n\n      assign s_slave_ar_id[j]     = slave[j].ar_id[AXI_ID_WIDTH_TARG-1:0];\n      assign s_slave_ar_addr[j]   = slave[j].ar_addr;\n      assign s_slave_ar_len[j]    = slave[j].ar_len;\n      assign s_slave_ar_size[j]   = slave[j].ar_size;\n      assign s_slave_ar_burst[j]  = slave[j].ar_burst;\n      assign s_slave_ar_lock[j]   = slave[j].ar_lock;\n      assign s_slave_ar_cache[j]  = slave[j].ar_cache;\n      assign s_slave_ar_prot[j]   = slave[j].ar_prot;\n      assign s_slave_ar_region[j] = slave[j].ar_region;\n      assign s_slave_ar_user[j]   = slave[j].ar_user;\n      assign s_slave_ar_qos[j]    = slave[j].ar_qos;\n      assign s_slave_ar_valid[j]  = slave[j].ar_valid;\n      assign                        slave[j].ar_ready = s_slave_ar_ready[j];\n\n      assign s_slave_w_data[j]    = slave[j].w_data;\n      assign s_slave_w_strb[j]    = slave[j].w_strb;\n      assign s_slave_w_last[j]    = slave[j].w_last;\n      assign s_slave_w_user[j]    = slave[j].w_user;\n      assign s_slave_w_valid[j]   = slave[j].w_valid;\n      assign                        slave[j].w_ready = s_slave_w_ready[j];\n\n      assign                        slave[j].b_id[AXI_ID_WIDTH_TARG-1:0] = s_slave_b_id[j];\n      assign                        slave[j].b_resp                      = s_slave_b_resp[j];\n      assign                        slave[j].b_valid                     = s_slave_b_valid[j];\n      assign                        slave[j].b_user                      = s_slave_b_user[j];\n      assign s_slave_b_ready[j]   = slave[j].b_ready;\n\n      assign                        slave[j].r_id[AXI_ID_WIDTH_TARG-1:0] = s_slave_r_id[j];\n      assign                        slave[j].r_data                      = s_slave_r_data[j];\n      assign                        slave[j].r_resp                      = s_slave_r_resp[j];\n      assign                        slave[j].r_last                      = s_slave_r_last[j];\n      assign                        slave[j].r_user                      = s_slave_r_user[j];\n      assign                        slave[j].r_valid                     = s_slave_r_valid[j];\n      assign s_slave_r_ready[j]   = slave[j].r_ready;\n    end\n  endgenerate\n\n  axi_node #(\n    .AXI_ADDRESS_W      ( AXI_ADDR_WIDTH    ),\n    .AXI_DATA_W         ( AXI_DATA_WIDTH    ),\n    .AXI_NUMBYTES       ( AXI_STRB_WIDTH    ),\n    .AXI_ID_IN          ( AXI_ID_WIDTH_TARG ),\n    .AXI_USER_W         ( AXI_USER_WIDTH    ),\n\n    .N_MASTER_PORT      ( NB_MASTER         ),\n    .N_SLAVE_PORT       ( NB_SLAVE          ),\n    .N_REGION           ( NB_REGION         ),\n    .FIFO_DEPTH_DW      ( 2                 )\n  ) axi_node_i (\n    .clk                    ( clk                ),\n    .rst_n                  ( rst_n              ),\n    .test_en_i              ( test_en_i          ),\n\n    .slave_awid_i           ( s_slave_aw_id      ),\n    .slave_awaddr_i         ( s_slave_aw_addr    ),\n    .slave_awlen_i          ( s_slave_aw_len     ),\n    .slave_awsize_i         ( s_slave_aw_size    ),\n    .slave_awburst_i        ( s_slave_aw_burst   ),\n    .slave_awlock_i         ( s_slave_aw_lock    ),\n    .slave_awcache_i        ( s_slave_aw_cache   ),\n    .slave_awprot_i         ( s_slave_aw_prot    ),\n    .slave_awregion_i       ( s_slave_aw_region  ),\n    .slave_awqos_i          ( s_slave_aw_qos     ),\n    .slave_awuser_i         ( s_slave_aw_user    ),\n    .slave_awvalid_i        ( s_slave_aw_valid   ),\n    .slave_awready_o        ( s_slave_aw_ready   ),\n\n    .slave_wdata_i          ( s_slave_w_data     ),\n    .slave_wstrb_i          ( s_slave_w_strb     ),\n    .slave_wlast_i          ( s_slave_w_last     ),\n    .slave_wuser_i          ( s_slave_w_user     ),\n    .slave_wvalid_i         ( s_slave_w_valid    ),\n    .slave_wready_o         ( s_slave_w_ready    ),\n\n    .slave_bid_o            ( s_slave_b_id       ),\n    .slave_bresp_o          ( s_slave_b_resp     ),\n    .slave_buser_o          ( s_slave_b_user     ),\n    .slave_bvalid_o         ( s_slave_b_valid    ),\n    .slave_bready_i         ( s_slave_b_ready    ),\n\n    .slave_arid_i           ( s_slave_ar_id      ),\n    .slave_araddr_i         ( s_slave_ar_addr    ),\n    .slave_arlen_i          ( s_slave_ar_len     ),\n    .slave_arsize_i         ( s_slave_ar_size    ),\n    .slave_arburst_i        ( s_slave_ar_burst   ),\n    .slave_arlock_i         ( s_slave_ar_lock    ),\n    .slave_arcache_i        ( s_slave_ar_cache   ),\n    .slave_arprot_i         ( s_slave_ar_prot    ),\n    .slave_arregion_i       ( s_slave_ar_region  ),\n    .slave_aruser_i         ( s_slave_ar_user    ),\n    .slave_arqos_i          ( s_slave_ar_qos     ),\n    .slave_arvalid_i        ( s_slave_ar_valid   ),\n    .slave_arready_o        ( s_slave_ar_ready   ),\n\n    .slave_rid_o            ( s_slave_r_id       ),\n    .slave_rdata_o          ( s_slave_r_data     ),\n    .slave_rresp_o          ( s_slave_r_resp     ),\n    .slave_rlast_o          ( s_slave_r_last     ),\n    .slave_ruser_o          ( s_slave_r_user     ),\n    .slave_rvalid_o         ( s_slave_r_valid    ),\n    .slave_rready_i         ( s_slave_r_ready    ),\n\n    .master_awid_o          ( s_master_aw_id     ),\n    .master_awaddr_o        ( s_master_aw_addr   ),\n    .master_awlen_o         ( s_master_aw_len    ),\n    .master_awsize_o        ( s_master_aw_size   ),\n    .master_awburst_o       ( s_master_aw_burst  ),\n    .master_awlock_o        ( s_master_aw_lock   ),\n    .master_awcache_o       ( s_master_aw_cache  ),\n    .master_awprot_o        ( s_master_aw_prot   ),\n    .master_awregion_o      ( s_master_aw_region ),\n    .master_awqos_o         ( s_master_aw_qos    ),\n    .master_awuser_o        ( s_master_aw_user   ),\n    .master_awvalid_o       ( s_master_aw_valid  ),\n    .master_awready_i       ( s_master_aw_ready  ),\n\n    .master_wdata_o         ( s_master_w_data    ),\n    .master_wstrb_o         ( s_master_w_strb    ),\n    .master_wlast_o         ( s_master_w_last    ),\n    .master_wuser_o         ( s_master_w_user    ),\n    .master_wvalid_o        ( s_master_w_valid   ),\n    .master_wready_i        ( s_master_w_ready   ),\n\n    .master_bid_i           ( s_master_b_id      ),\n    .master_bresp_i         ( s_master_b_resp    ),\n    .master_buser_i         ( s_master_b_user    ),\n    .master_bvalid_i        ( s_master_b_valid   ),\n    .master_bready_o        ( s_master_b_ready   ),\n\n    .master_arid_o          ( s_master_ar_id     ),\n    .master_araddr_o        ( s_master_ar_addr   ),\n    .master_arlen_o         ( s_master_ar_len    ),\n    .master_arsize_o        ( s_master_ar_size   ),\n    .master_arburst_o       ( s_master_ar_burst  ),\n    .master_arlock_o        ( s_master_ar_lock   ),\n    .master_arcache_o       ( s_master_ar_cache  ),\n    .master_arprot_o        ( s_master_ar_prot   ),\n    .master_arregion_o      ( s_master_ar_region ),\n    .master_aruser_o        ( s_master_ar_user   ),\n    .master_arqos_o         ( s_master_ar_qos    ),\n    .master_arvalid_o       ( s_master_ar_valid  ),\n    .master_arready_i       ( s_master_ar_ready  ),\n\n    .master_rid_i           ( s_master_r_id      ),\n    .master_rdata_i         ( s_master_r_data    ),\n    .master_rresp_i         ( s_master_r_resp    ),\n    .master_rlast_i         ( s_master_r_last    ),\n    .master_ruser_i         ( s_master_r_user    ),\n    .master_rvalid_i        ( s_master_r_valid   ),\n    .master_rready_o        ( s_master_r_ready   ),\n\n    .cfg_START_ADDR_i       ( start_addr_i       ),\n    .cfg_END_ADDR_i         ( end_addr_i         ),\n    .cfg_valid_rule_i       ( valid_rule_i       ),\n    .cfg_connectivity_map_i ( connectivity_map_i )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2014-2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule axi_node_intf_wrap_with_slices\n#(\n  parameter NB_MASTER          = 8,\n  parameter NB_SLAVE           = 4,\n  parameter NB_REGION          = 2,\n  parameter AXI_ADDR_WIDTH     = 32,\n  parameter AXI_DATA_WIDTH     = 64,\n  parameter AXI_ID_IN_WIDTH    = 4,\n  parameter AXI_ID_OUT_WIDTH   = AXI_ID_IN_WIDTH + $clog2(NB_SLAVE),\n  parameter AXI_USER_WIDTH     = 6,\n  parameter MASTER_SLICE_DEPTH = 2,\n  parameter SLAVE_SLICE_DEPTH  = 2\n)\n(\n  input logic                                       clk,\n  input logic                                       rst_n,\n  input logic                                       test_en_i,\n\n  AXI_BUS.Slave                                     slave  [NB_SLAVE-1:0],\n  AXI_BUS.Master                                    master [NB_MASTER-1:0],\n\n  input  logic [NB_REGION-1:0][NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0] start_addr_i,\n  input  logic [NB_REGION-1:0][NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0] end_addr_i,\n  input  logic [NB_REGION-1:0][NB_MASTER-1:0]                     valid_rule_i,\n  input  logic [NB_SLAVE-1:0] [NB_MASTER-1:0]                     connectivity_map_i\n);\n\n  genvar i;\n\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH  ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH  ),\n    .AXI_ID_WIDTH   ( AXI_ID_IN_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH  )\n  ) int_slave[NB_SLAVE-1:0]();\n\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH   ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH   ),\n    .AXI_ID_WIDTH   ( AXI_ID_OUT_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH   )\n  ) int_master[NB_MASTER-1:0]();\n\n  axi_node_intf_wrap #(\n    .NB_MASTER        ( NB_MASTER        ),\n    .NB_SLAVE         ( NB_SLAVE         ),\n    .NB_REGION        ( NB_REGION        ),\n    .AXI_ADDR_WIDTH   ( AXI_ADDR_WIDTH   ),\n    .AXI_DATA_WIDTH   ( AXI_DATA_WIDTH   ),\n    .AXI_USER_WIDTH   ( AXI_USER_WIDTH   ),\n    .AXI_ID_IN_WIDTH  ( AXI_ID_IN_WIDTH  ),\n    .AXI_ID_OUT_WIDTH ( AXI_ID_OUT_WIDTH )\n  ) i_axi_node_intf_wrap (\n    .clk                ( clk                ),\n    .rst_n              ( rst_n              ),\n    .test_en_i          ( test_en_i          ),\n\n    .slave              ( int_slave          ),\n    .master             ( int_master         ),\n\n    .start_addr_i       ( start_addr_i       ),\n    .end_addr_i         ( end_addr_i         ),\n    .valid_rule_i       ( valid_rule_i       ),\n    .connectivity_map_i ( connectivity_map_i )\n  );\n\n  generate\n    for( i=0; i<NB_MASTER; i++ ) begin : AXI_SLICE_MASTER_PORT\n      axi_slice_wrap #(\n        .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n        .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n        .AXI_USER_WIDTH ( AXI_USER_WIDTH     ),\n        .AXI_ID_WIDTH   ( AXI_ID_OUT_WIDTH   ),\n        .SLICE_DEPTH    ( MASTER_SLICE_DEPTH )\n      ) i_axi_slice_wrap_master (\n        .clk_i      ( clk           ),\n        .rst_ni     ( rst_n         ),\n        .test_en_i  ( test_en_i     ),\n\n        .axi_slave  ( int_master[i] ), // from the node\n        .axi_master ( master[i]     )  // to IO ports\n      );\n    end\n\n    for( i=0; i<NB_SLAVE; i++ ) begin : AXI_SLICE_SLAVE_PORT\n      axi_slice_wrap #(\n        .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH    ),\n        .AXI_DATA_WIDTH ( AXI_DATA_WIDTH    ),\n        .AXI_USER_WIDTH ( AXI_USER_WIDTH    ),\n        .AXI_ID_WIDTH   ( AXI_ID_IN_WIDTH   ),\n        .SLICE_DEPTH    ( SLAVE_SLICE_DEPTH )\n      ) i_axi_slice_wrap_slave (\n        .clk_i      ( clk          ),\n        .rst_ni     ( rst_n        ),\n        .test_en_i  ( test_en_i    ),\n\n        .axi_slave  ( slave[i]     ), // from IO_ports\n        .axi_master ( int_slave[i] )  // to axi_node\n      );\n    end\n  endgenerate\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// --=========================================================================--\n//\n//  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2557    \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n// \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d    \u2588\u2588\u2551 \u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n// \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2551\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \n// \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u255d \u2588\u2588\u2557\u2588\u2588\u2551    \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d    \u255a\u2588\u2588\u2588\u2554\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551     \n// \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d    \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d      \u255a\u2550\u2550\u255d\u255a\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \n//                                                                                     \n// --=========================================================================--\n\n`include \"pulp_soc_defines.sv\"\n\nmodule axi_rab_wrap\n#(\n  parameter AXI_EXT_ADDR_WIDTH     = 40,\n  parameter AXI_INT_ADDR_WIDTH     = 32,\n  parameter AXI_DATA_WIDTH         = 64,\n  parameter AXI_USER_WIDTH         = 6,\n  parameter AXI_LITE_ADDR_WIDTH    = 32,\n  parameter AXI_LITE_DATA_WIDTH    = 64, \n  parameter AXI_ID_EXT_S_WIDTH     = 6,\n  parameter AXI_ID_EXT_S_ACP_WIDTH = 6,\n  parameter AXI_ID_EXT_M_WIDTH     = 14,\n  parameter AXI_ID_SOC_S_WIDTH     = 7,\n  parameter AXI_ID_SOC_M_WIDTH     = 10,\n  parameter N_PORTS                = 2,\n  parameter N_L2_SETS              = 32,\n  parameter N_L2_SET_ENTRIES       = 32\n  )\n (\n  input  logic   clk_i,\n  input  logic   non_gated_clk_i,\n  input  logic   rst_ni,\n  \n  AXI_BUS.Master rab_to_socbus,\n  AXI_BUS.Slave  socbus_to_rab,\n\n  AXI_BUS.Master rab_master,\n`ifdef EN_ACP\n  AXI_BUS.Master rab_acp,\n`endif\n  AXI_BUS.Slave  rab_slave,\n\n  AXI_LITE.Slave rab_lite,\n\n`ifdef RAB_AX_LOG_EN\n  BramPort.Slave ArBram_PS,\n  BramPort.Slave AwBram_PS,\n\n  input  logic   LogEn_SI,\n  input  logic   ArLogClr_SI,\n  input  logic   AwLogClr_SI,\n  output logic   ArLogRdy_SO,\n  output logic   AwLogRdy_SO,\n\n  output logic   intr_ar_log_full_o,\n  output logic   intr_aw_log_full_o,\n`endif\n  output logic   intr_miss_o , \n  output logic   intr_multi_o,\n  output logic   intr_prot_o,\n  output logic   intr_mhf_full_o\n);\n   \n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551     \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\n  // \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n  //\n\n  // AXI_ID_WIDTH: This is the ID width internally used by the RAB. To the \n  // external world, AXI ID remappers are used for ID conversion. The\n  // internal IDs coming from the SoC Bus are not converted, but zero-\n  // extended to the maximum internal ID width. Converters cannot be used\n  // because the original ID is required for RAB miss handling.\n  localparam AXI_ID_WIDTH = FUNC_MAX(AXI_ID_SOC_S_WIDTH,AXI_ID_SOC_M_WIDTH);\n  \n  function int FUNC_MAX(int a, b);\n   if (a > b)\n     return a;\n   else\n     return b;     \n  endfunction\n\n  // AXI_EXT_ADDR_WIDTH: This is the AXI address width used in the external\n  // world. Internally, always 32-bit addresses are used.\n  localparam AXI_ADDR_WIDTH = FUNC_MAX(AXI_EXT_ADDR_WIDTH,AXI_INT_ADDR_WIDTH);\n\n  // ATTENTION: Assignments between arrays and signals of different bit\n  // widths need to be handled with care, Vivado tends to mix this up.  \n        \n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH ),\n    .AXI_ID_WIDTH   ( AXI_ID_WIDTH   ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH )\n  ) rab_master_id_remap();\n\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH ),\n    .AXI_ID_WIDTH   ( AXI_ID_WIDTH   ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH )\n  ) rab_acp_id_remap();\n\n  AXI_BUS #(\n     .AXI_ADDR_WIDTH ( AXI_INT_ADDR_WIDTH ), // Even on Juno, the slave port is mapped to a 32-bit address.\n     .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n     .AXI_ID_WIDTH   ( AXI_ID_WIDTH       ),\n     .AXI_USER_WIDTH ( AXI_USER_WIDTH     )\n  ) rab_slave_id_remap();\n\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH ),\n    .AXI_ID_WIDTH   ( AXI_ID_WIDTH   ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH )\n  ) dummy_axi();\n\n  logic [N_PORTS-1:0]       [AXI_ID_WIDTH-1:0] s_axi_awid;\n  logic [N_PORTS-1:0] [AXI_INT_ADDR_WIDTH-1:0] s_axi_awaddr;\n  logic [N_PORTS-1:0]                          s_axi_awvalid;\n  logic [N_PORTS-1:0]                          s_axi_awready;\n  logic [N_PORTS-1:0]                    [7:0] s_axi_awlen;\n  logic [N_PORTS-1:0]                    [2:0] s_axi_awsize;\n  logic [N_PORTS-1:0]                    [1:0] s_axi_awburst;\n  logic [N_PORTS-1:0]                          s_axi_awlock;\n  logic [N_PORTS-1:0]                    [2:0] s_axi_awprot;\n  logic [N_PORTS-1:0]                    [3:0] s_axi_awcache;\n  logic [N_PORTS-1:0]                    [3:0] s_axi_awregion;\n  logic [N_PORTS-1:0]                    [3:0] s_axi_awqos;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] s_axi_awuser;\n      \n  logic [N_PORTS-1:0]     [AXI_DATA_WIDTH-1:0] s_axi_wdata;\n  logic [N_PORTS-1:0]                          s_axi_wvalid;\n  logic [N_PORTS-1:0]                          s_axi_wready;\n  logic [N_PORTS-1:0]   [AXI_DATA_WIDTH/8-1:0] s_axi_wstrb;\n  logic [N_PORTS-1:0]                          s_axi_wlast;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] s_axi_wuser;\n      \n  logic [N_PORTS-1:0]       [AXI_ID_WIDTH-1:0] s_axi_bid;\n  logic [N_PORTS-1:0]                    [1:0] s_axi_bresp;\n  logic [N_PORTS-1:0]                          s_axi_bvalid;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] s_axi_buser;\n  logic [N_PORTS-1:0]                          s_axi_bready;\n      \n  logic [N_PORTS-1:0]       [AXI_ID_WIDTH-1:0] s_axi_arid;\n  logic [N_PORTS-1:0] [AXI_INT_ADDR_WIDTH-1:0] s_axi_araddr;\n  logic [N_PORTS-1:0]                          s_axi_arvalid;\n  logic [N_PORTS-1:0]                          s_axi_arready;\n  logic [N_PORTS-1:0]                    [7:0] s_axi_arlen;\n  logic [N_PORTS-1:0]                    [2:0] s_axi_arsize;\n  logic [N_PORTS-1:0]                    [1:0] s_axi_arburst;\n  logic [N_PORTS-1:0]                          s_axi_arlock;\n  logic [N_PORTS-1:0]                    [2:0] s_axi_arprot;\n  logic [N_PORTS-1:0]                    [3:0] s_axi_arcache;\n  logic [N_PORTS-1:0]                    [3:0] s_axi_arregion;\n  logic [N_PORTS-1:0]                    [3:0] s_axi_arqos;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] s_axi_aruser;\n      \n  logic [N_PORTS-1:0]       [AXI_ID_WIDTH-1:0] s_axi_rid;\n  logic [N_PORTS-1:0]     [AXI_DATA_WIDTH-1:0] s_axi_rdata;\n  logic [N_PORTS-1:0]                    [1:0] s_axi_rresp;\n  logic [N_PORTS-1:0]                          s_axi_rvalid;\n  logic [N_PORTS-1:0]                          s_axi_rready;\n  logic [N_PORTS-1:0]                          s_axi_rlast;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] s_axi_ruser;\n      \n  logic [N_PORTS-1:0]       [AXI_ID_WIDTH-1:0] m_axi_awid;\n  logic [N_PORTS-1:0]     [AXI_ADDR_WIDTH-1:0] m_axi_awaddr;\n  logic [N_PORTS-1:0]                          m_axi_awvalid;\n  logic [N_PORTS-1:0]                          m_axi_awready;\n  logic [N_PORTS-1:0]                    [7:0] m_axi_awlen;\n  logic [N_PORTS-1:0]                    [2:0] m_axi_awsize;\n  logic [N_PORTS-1:0]                    [1:0] m_axi_awburst;\n  logic [N_PORTS-1:0]                          m_axi_awlock;\n  logic [N_PORTS-1:0]                    [2:0] m_axi_awprot;\n  logic [N_PORTS-1:0]                    [3:0] m_axi_awcache;\n  logic [N_PORTS-1:0]                    [3:0] m_axi_awregion;\n  logic [N_PORTS-1:0]                    [3:0] m_axi_awqos;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] m_axi_awuser;\n      \n  logic [N_PORTS-1:0]     [AXI_DATA_WIDTH-1:0] m_axi_wdata;\n  logic [N_PORTS-1:0]                          m_axi_wvalid;\n  logic [N_PORTS-1:0]                          m_axi_wready;\n  logic [N_PORTS-1:0]   [AXI_DATA_WIDTH/8-1:0] m_axi_wstrb;\n  logic [N_PORTS-1:0]                          m_axi_wlast;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] m_axi_wuser;\n      \n  logic [N_PORTS-1:0]       [AXI_ID_WIDTH-1:0] m_axi_bid;\n  logic [N_PORTS-1:0]                    [1:0] m_axi_bresp;\n  logic [N_PORTS-1:0]                          m_axi_bvalid;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] m_axi_buser;\n  logic [N_PORTS-1:0]                          m_axi_bready;\n      \n  logic [N_PORTS-1:0]       [AXI_ID_WIDTH-1:0] m_axi_arid;\n  logic [N_PORTS-1:0]     [AXI_ADDR_WIDTH-1:0] m_axi_araddr;\n  logic [N_PORTS-1:0]                          m_axi_arvalid;\n  logic [N_PORTS-1:0]                          m_axi_arready;\n  logic [N_PORTS-1:0]                    [7:0] m_axi_arlen;\n  logic [N_PORTS-1:0]                    [2:0] m_axi_arsize;\n  logic [N_PORTS-1:0]                    [1:0] m_axi_arburst;\n  logic [N_PORTS-1:0]                          m_axi_arlock;\n  logic [N_PORTS-1:0]                    [2:0] m_axi_arprot;\n  logic [N_PORTS-1:0]                    [3:0] m_axi_arcache;\n  logic [N_PORTS-1:0]                    [3:0] m_axi_arregion;\n  logic [N_PORTS-1:0]                    [3:0] m_axi_arqos;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] m_axi_aruser;\n      \n  logic [N_PORTS-1:0]       [AXI_ID_WIDTH-1:0] m_axi_rid;\n  logic [N_PORTS-1:0]     [AXI_DATA_WIDTH-1:0] m_axi_rdata;\n  logic [N_PORTS-1:0]                    [1:0] m_axi_rresp;\n  logic [N_PORTS-1:0]                          m_axi_rvalid;\n  logic [N_PORTS-1:0]                          m_axi_rready;\n  logic [N_PORTS-1:0]                          m_axi_rlast;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] m_axi_ruser;\n\n  logic [N_PORTS-1:0]       [AXI_ID_WIDTH-1:0] m_axi_acp_awid;\n  logic [N_PORTS-1:0]     [AXI_ADDR_WIDTH-1:0] m_axi_acp_awaddr;\n  logic [N_PORTS-1:0]                          m_axi_acp_awvalid;\n  logic [N_PORTS-1:0]                          m_axi_acp_awready;\n  logic [N_PORTS-1:0]                    [7:0] m_axi_acp_awlen;\n  logic [N_PORTS-1:0]                    [2:0] m_axi_acp_awsize;\n  logic [N_PORTS-1:0]                    [1:0] m_axi_acp_awburst;\n  logic [N_PORTS-1:0]                          m_axi_acp_awlock;\n  logic [N_PORTS-1:0]                    [2:0] m_axi_acp_awprot;\n  logic [N_PORTS-1:0]                    [3:0] m_axi_acp_awcache;\n  logic [N_PORTS-1:0]                    [3:0] m_axi_acp_awregion;\n  logic [N_PORTS-1:0]                    [3:0] m_axi_acp_awqos;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] m_axi_acp_awuser;\n\n  logic [N_PORTS-1:0]     [AXI_DATA_WIDTH-1:0] m_axi_acp_wdata;\n  logic [N_PORTS-1:0]                          m_axi_acp_wvalid;\n  logic [N_PORTS-1:0]                          m_axi_acp_wready;\n  logic [N_PORTS-1:0]   [AXI_DATA_WIDTH/8-1:0] m_axi_acp_wstrb;\n  logic [N_PORTS-1:0]                          m_axi_acp_wlast;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] m_axi_acp_wuser;\n      \n  logic [N_PORTS-1:0]       [AXI_ID_WIDTH-1:0] m_axi_acp_bid;\n  logic [N_PORTS-1:0]                    [1:0] m_axi_acp_bresp;\n  logic [N_PORTS-1:0]                          m_axi_acp_bvalid;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] m_axi_acp_buser;\n  logic [N_PORTS-1:0]                          m_axi_acp_bready;\n\n  logic [N_PORTS-1:0]       [AXI_ID_WIDTH-1:0] m_axi_acp_arid;\n  logic [N_PORTS-1:0]     [AXI_ADDR_WIDTH-1:0] m_axi_acp_araddr;\n  logic [N_PORTS-1:0]                          m_axi_acp_arvalid;\n  logic [N_PORTS-1:0]                          m_axi_acp_arready;\n  logic [N_PORTS-1:0]                    [7:0] m_axi_acp_arlen;\n  logic [N_PORTS-1:0]                    [2:0] m_axi_acp_arsize;\n  logic [N_PORTS-1:0]                    [1:0] m_axi_acp_arburst;\n  logic [N_PORTS-1:0]                          m_axi_acp_arlock;\n  logic [N_PORTS-1:0]                    [2:0] m_axi_acp_arprot;\n  logic [N_PORTS-1:0]                    [3:0] m_axi_acp_arcache;\n  logic [N_PORTS-1:0]                    [3:0] m_axi_acp_arregion;\n  logic [N_PORTS-1:0]                    [3:0] m_axi_acp_arqos;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] m_axi_acp_aruser;\n\n  logic [N_PORTS-1:0]       [AXI_ID_WIDTH-1:0] m_axi_acp_rid;\n  logic [N_PORTS-1:0]     [AXI_DATA_WIDTH-1:0] m_axi_acp_rdata;\n  logic [N_PORTS-1:0]                    [1:0] m_axi_acp_rresp;\n  logic [N_PORTS-1:0]                          m_axi_acp_rvalid;\n  logic [N_PORTS-1:0]                          m_axi_acp_rready;\n  logic [N_PORTS-1:0]                          m_axi_acp_rlast;\n  logic [N_PORTS-1:0]     [AXI_USER_WIDTH-1:0] m_axi_acp_ruser;\n\n  logic [N_PORTS-1:0]                          intr_rab_miss;\n  logic [N_PORTS-1:0]                          intr_rab_multi;\n  logic [N_PORTS-1:0]                          intr_rab_prot;\n  logic                                        intr_mhf_full;\n`ifdef RAB_AX_LOG_EN\n  logic                                        intr_ar_log_full;\n  logic                                        intr_aw_log_full;\n`endif\n      \n  //  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551   \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\n  // \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\n  // \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n  //\n  //------------------------------   *******   ---------------------------------------\n  //assign s_axi_awid   = {socbus_to_rab.aw_id     , rab_slave_id_remap.aw_id    };                   // ATTENTION: different signal widths can lead to wrong assignments\n  //assign s_axi_awaddr = {socbus_to_rab.aw_addr   , rab_slave_id_remap.aw_addr  };                   // ATTENTION: different signal widths can lead to wrong assignments\n  assign s_axi_awvalid  = {socbus_to_rab.aw_valid  , rab_slave_id_remap.aw_valid };\n  assign                  {socbus_to_rab.aw_ready  , rab_slave_id_remap.aw_ready } = s_axi_awready;\n  assign s_axi_awlen    = {socbus_to_rab.aw_len    , rab_slave_id_remap.aw_len   };\n  assign s_axi_awsize   = {socbus_to_rab.aw_size   , rab_slave_id_remap.aw_size  };\n  assign s_axi_awburst  = {socbus_to_rab.aw_burst  , rab_slave_id_remap.aw_burst };\n  assign s_axi_awlock   = {socbus_to_rab.aw_lock   , rab_slave_id_remap.aw_lock  };\n  assign s_axi_awprot   = {socbus_to_rab.aw_prot   , rab_slave_id_remap.aw_prot  };\n  assign s_axi_awcache  = {socbus_to_rab.aw_cache  , rab_slave_id_remap.aw_cache };\n  assign s_axi_awregion = {socbus_to_rab.aw_region , rab_slave_id_remap.aw_region};\n  assign s_axi_awqos    = {socbus_to_rab.aw_qos    , rab_slave_id_remap.aw_qos   };\n  assign s_axi_awuser   = {socbus_to_rab.aw_user   , rab_slave_id_remap.aw_user  };\n\n  assign s_axi_wdata    = {socbus_to_rab.w_data    , rab_slave_id_remap.w_data   };\n  assign s_axi_wvalid   = {socbus_to_rab.w_valid   , rab_slave_id_remap.w_valid  };\n  assign                  {socbus_to_rab.w_ready   , rab_slave_id_remap.w_ready  } = s_axi_wready;\n  assign s_axi_wstrb    = {socbus_to_rab.w_strb    , rab_slave_id_remap.w_strb   };\n  assign s_axi_wlast    = {socbus_to_rab.w_last    , rab_slave_id_remap.w_last   };\n  assign s_axi_wuser    = {socbus_to_rab.w_user    , rab_slave_id_remap.w_user   };\n\n  //assign                {socbus_to_rab.b_id      , rab_slave_id_remap.b_id     } = s_axi_bid;       // ATTENTION: different signal widths can lead to wrong assignments\n  assign                  {socbus_to_rab.b_resp    , rab_slave_id_remap.b_resp   } = s_axi_bresp;\n  assign                  {socbus_to_rab.b_valid   , rab_slave_id_remap.b_valid  } = s_axi_bvalid;\n  assign                  {socbus_to_rab.b_user    , rab_slave_id_remap.b_user   } = s_axi_buser;\n  assign s_axi_bready   = {socbus_to_rab.b_ready   , rab_slave_id_remap.b_ready  };\n\n  //assign s_axi_arid   = {socbus_to_rab.ar_id     , rab_slave_id_remap.ar_id    };                   // ATTENTION: different signal widths can lead to wrong assignments\n  //assign s_axi_araddr = {socbus_to_rab.ar_addr   , rab_slave_id_remap.ar_addr  };                   // ATTENTION: different signal widths can lead to wrong assignments\n  assign s_axi_arvalid  = {socbus_to_rab.ar_valid  , rab_slave_id_remap.ar_valid };\n  assign                  {socbus_to_rab.ar_ready  , rab_slave_id_remap.ar_ready } = s_axi_arready;\n  assign s_axi_arlen    = {socbus_to_rab.ar_len    , rab_slave_id_remap.ar_len   };\n  assign s_axi_arsize   = {socbus_to_rab.ar_size   , rab_slave_id_remap.ar_size  };\n  assign s_axi_arburst  = {socbus_to_rab.ar_burst  , rab_slave_id_remap.ar_burst };\n  assign s_axi_arlock   = {socbus_to_rab.ar_lock   , rab_slave_id_remap.ar_lock  };\n  assign s_axi_arprot   = {socbus_to_rab.ar_prot   , rab_slave_id_remap.ar_prot  };\n  assign s_axi_arcache  = {socbus_to_rab.ar_cache  , rab_slave_id_remap.ar_cache };\n  assign s_axi_arregion = {socbus_to_rab.ar_region , rab_slave_id_remap.ar_region};\n  assign s_axi_arqos    = {socbus_to_rab.ar_qos    , rab_slave_id_remap.ar_qos   };\n  assign s_axi_aruser   = {socbus_to_rab.ar_user   , rab_slave_id_remap.ar_user  };\n\n  //assign                {socbus_to_rab.r_id      , rab_slave_id_remap.r_id     } = s_axi_rid;       // ATTENTION: different signal widths can lead to wrong assignments\n  assign                  {socbus_to_rab.r_data    , rab_slave_id_remap.r_data   } = s_axi_rdata;\n  assign                  {socbus_to_rab.r_resp    , rab_slave_id_remap.r_resp   } = s_axi_rresp;\n  assign                  {socbus_to_rab.r_valid   , rab_slave_id_remap.r_valid  } = s_axi_rvalid;\n  assign s_axi_rready   = {socbus_to_rab.r_ready   , rab_slave_id_remap.r_ready  };\n  assign                  {socbus_to_rab.r_last    , rab_slave_id_remap.r_last   } = s_axi_rlast;\n  assign                  {socbus_to_rab.r_user    , rab_slave_id_remap.r_user   } = s_axi_ruser;\n\n  // handling of ID and address assignments of possibly different bit widths\n  //assign s_axi_awid[1][AXI_ID_WIDTH-1:AXI_ID_SOC_M_WIDTH] = 'b0;                        // zero-extend incoming ID\n  assign s_axi_awid[1][AXI_ID_SOC_M_WIDTH-1:0]            = socbus_to_rab.aw_id;\n  assign s_axi_awid[0]                                    = rab_slave_id_remap.aw_id;\n  assign s_axi_awaddr[1]                                  = socbus_to_rab.aw_addr;      // incoming address is not zero extended, since we use 32-bit on the slave ports\n  assign s_axi_awaddr[0]                                  = rab_slave_id_remap.aw_addr;\n  \n  assign socbus_to_rab.b_id      = s_axi_bid[1];\n  assign rab_slave_id_remap.b_id = s_axi_bid[0];\n\n  //assign s_axi_arid[1][AXI_ID_WIDTH-1:AXI_ID_SOC_M_WIDTH] = 'b0;                        // zero-extend incoming ID\n  assign s_axi_arid[1][AXI_ID_SOC_M_WIDTH-1:0]            = socbus_to_rab.ar_id;\n  assign s_axi_arid[0]                                    = rab_slave_id_remap.ar_id;\n  assign s_axi_araddr[1]                                  = socbus_to_rab.ar_addr;      // incoming address is not zero extended, since we use 32-bit on the slave ports\n  assign s_axi_araddr[0]                                  = rab_slave_id_remap.ar_addr;\n\n  assign socbus_to_rab.r_id      = s_axi_ri"}
{"text": "d[1];\n  assign rab_slave_id_remap.r_id = s_axi_rid[0];\n\n  //------------------------------   *******   ---------------------------------------\n  //assign               {rab_master_id_remap.aw_id     , rab_to_socbus.aw_id    } = m_axi_awid;    // ATTENTION: different signal widths can lead to wrong assignments\n  //assign               {rab_master_id_remap.aw_addr   , rab_to_socbus.aw_addr  } = m_axi_awaddr;  // ATTENTION: different signal widths can lead to wrong assignments\n  assign                 {rab_master_id_remap.aw_valid  , rab_to_socbus.aw_valid } = m_axi_awvalid;\n  assign m_axi_awready = {rab_master_id_remap.aw_ready  , rab_to_socbus.aw_ready };\n  assign                 {rab_master_id_remap.aw_len    , rab_to_socbus.aw_len   } = m_axi_awlen;\n  assign                 {rab_master_id_remap.aw_size   , rab_to_socbus.aw_size  } = m_axi_awsize;\n  assign                 {rab_master_id_remap.aw_burst  , rab_to_socbus.aw_burst } = m_axi_awburst;\n  assign                 {rab_master_id_remap.aw_lock   , rab_to_socbus.aw_lock  } = m_axi_awlock;\n  //assign               {rab_master_id_remap.aw_prot   , rab_to_socbus.aw_prot  } = m_axi_awprot;  // force non-secure access for shared memory\n  assign                 {rab_master_id_remap.aw_cache  , rab_to_socbus.aw_cache } = m_axi_awcache;\n  assign                 {rab_master_id_remap.aw_region , rab_to_socbus.aw_region} = m_axi_awregion;\n  assign                 {rab_master_id_remap.aw_qos    , rab_to_socbus.aw_qos   } = m_axi_awqos;\n  assign                 {rab_master_id_remap.aw_user   , rab_to_socbus.aw_user  } = m_axi_awuser;\n\n  assign                 {rab_master_id_remap.w_data    , rab_to_socbus.w_data   } = m_axi_wdata;\n  assign                 {rab_master_id_remap.w_valid   , rab_to_socbus.w_valid  } = m_axi_wvalid;\n  assign m_axi_wready  = {rab_master_id_remap.w_ready   , rab_to_socbus.w_ready  };\n  assign                 {rab_master_id_remap.w_strb    , rab_to_socbus.w_strb   } = m_axi_wstrb;\n  assign                 {rab_master_id_remap.w_last    , rab_to_socbus.w_last   } = m_axi_wlast;\n  assign                 {rab_master_id_remap.w_user    , rab_to_socbus.w_user   } = m_axi_wuser;\n\n  //assign m_axi_bid   = {rab_master_id_remap.b_id      , rab_to_socbus.b_id     };                 // ATTENTION: different signal widths can lead to wrong assignments\n  assign m_axi_bresp   = {rab_master_id_remap.b_resp    , rab_to_socbus.b_resp   };\n  assign m_axi_bvalid  = {rab_master_id_remap.b_valid   , rab_to_socbus.b_valid  };\n  assign m_axi_buser   = {rab_master_id_remap.b_user    , rab_to_socbus.b_user   };\n  assign                 {rab_master_id_remap.b_ready   , rab_to_socbus.b_ready  } = m_axi_bready;\n\n  //assign               {rab_master_id_remap.ar_id     , rab_to_socbus.ar_id    } = m_axi_arid;    // ATTENTION: different signal widths can lead to wrong assignments\n  //assign               {rab_master_id_remap.ar_addr   , rab_to_socbus.ar_addr  } = m_axi_araddr;  // ATTENTION: different signal widths can lead to wrong assignments\n  assign                 {rab_master_id_remap.ar_valid  , rab_to_socbus.ar_valid } = m_axi_arvalid;\n  assign m_axi_arready = {rab_master_id_remap.ar_ready  , rab_to_socbus.ar_ready };\n  assign                 {rab_master_id_remap.ar_len    , rab_to_socbus.ar_len   } = m_axi_arlen;\n  assign                 {rab_master_id_remap.ar_size   , rab_to_socbus.ar_size  } = m_axi_arsize;\n  assign                 {rab_master_id_remap.ar_burst  , rab_to_socbus.ar_burst } = m_axi_arburst;\n  assign                 {rab_master_id_remap.ar_lock   , rab_to_socbus.ar_lock  } = m_axi_arlock;\n  //assign               {rab_master_id_remap.ar_prot   , rab_to_socbus.ar_prot  } = m_axi_arprot;  // force non-secure access for shared memory\n  assign                 {rab_master_id_remap.ar_cache  , rab_to_socbus.ar_cache } = m_axi_arcache;\n  assign                 {rab_master_id_remap.ar_region , rab_to_socbus.ar_region} = m_axi_arregion;\n  assign                 {rab_master_id_remap.ar_qos    , rab_to_socbus.ar_qos   } = m_axi_arqos;\n  assign                 {rab_master_id_remap.ar_user   , rab_to_socbus.ar_user  } = m_axi_aruser;\n\n  //assign  m_axi_rid  = {rab_master_id_remap.r_id      , rab_to_socbus.r_id     };                 // ATTENTION: different signal widths can lead to wrong assignments\n  assign  m_axi_rdata  = {rab_master_id_remap.r_data    , rab_to_socbus.r_data   };\n  assign  m_axi_rresp  = {rab_master_id_remap.r_resp    , rab_to_socbus.r_resp   };\n  assign  m_axi_rvalid = {rab_master_id_remap.r_valid   , rab_to_socbus.r_valid  };\n  assign                 {rab_master_id_remap.r_ready   , rab_to_socbus.r_ready  } = m_axi_rready;\n  assign  m_axi_rlast  = {rab_master_id_remap.r_last    , rab_to_socbus.r_last   };\n  assign  m_axi_ruser  = {rab_master_id_remap.r_user    , rab_to_socbus.r_user   };\n\n  // handling of ID and address assignments of possibly different bit widths\n  assign rab_master_id_remap.aw_id   = m_axi_awid[1];\n  assign rab_to_socbus.aw_id         = m_axi_awid[0];\n  assign rab_master_id_remap.aw_addr = m_axi_awaddr[1];\n  assign rab_to_socbus.aw_addr       = m_axi_awaddr[0];\n\n  assign m_axi_bid[1] = rab_master_id_remap.b_id;\n  assign m_axi_bid[0][AXI_ID_WIDTH-1      :AXI_ID_SOC_S_WIDTH] = 'b0;                // zero-extend incoming ID\n  assign m_axi_bid[0][AXI_ID_SOC_S_WIDTH-1:0]                  = rab_to_socbus.b_id; \n\n  assign rab_master_id_remap.ar_id   = m_axi_arid[1];\n  assign rab_to_socbus.ar_id         = m_axi_arid[0];\n  assign rab_master_id_remap.ar_addr = m_axi_araddr[1];\n  assign rab_to_socbus.ar_addr       = m_axi_araddr[0];\n\n  assign m_axi_rid[1] = rab_master_id_remap.r_id;\n  assign m_axi_rid[0][AXI_ID_WIDTH-1      :AXI_ID_SOC_S_WIDTH] = 'b0;                // zero-extend incoming ID\n  assign m_axi_rid[0][AXI_ID_SOC_S_WIDTH-1:0]                  = rab_to_socbus.r_id;\n\n  // force non-secure access for shared memory\n`ifdef HOST_IS_64_BIT\n  assign rab_master_id_remap.aw_prot = 3'b010;\n  assign rab_master_id_remap.ar_prot = 3'b010;\n`else \n  assign rab_master_id_remap.aw_prot = m_axi_awprot[1];\n  assign rab_master_id_remap.ar_prot = m_axi_arprot[1];\n`endif\n  assign rab_to_socbus.aw_prot       = m_axi_awprot[0];\n  assign rab_to_socbus.ar_prot       = m_axi_arprot[0]; \n\n  //------------------------------   *******   ---------------------------------------\n  //assign                   {rab_acp_id_remap.aw_id    , dummy_axi.aw_id    } = m_axi_acp_awid;    // ATTENTION: different signal widths can lead to wrong assignments\n  //assign                   {rab_acp_id_remap.aw_addr  , dummy_axi.aw_addr  } = m_axi_acp_awaddr;  // ATTENTION: different signal widths can lead to wrong assignments\n  assign                     {rab_acp_id_remap.aw_valid , dummy_axi.aw_valid } = m_axi_acp_awvalid;\n  assign m_axi_acp_awready = {rab_acp_id_remap.aw_ready , dummy_axi.aw_ready };\n  assign                     {rab_acp_id_remap.aw_len   , dummy_axi.aw_len   } = m_axi_acp_awlen;\n  assign                     {rab_acp_id_remap.aw_size  , dummy_axi.aw_size  } = m_axi_acp_awsize;\n  assign                     {rab_acp_id_remap.aw_burst , dummy_axi.aw_burst } = m_axi_acp_awburst;\n  assign                     {rab_acp_id_remap.aw_lock  , dummy_axi.aw_lock  } = m_axi_acp_awlock;\n  //assign                   {rab_acp_id_remap.aw_prot  , dummy_axi.aw_prot  } = m_axi_acp_awprot;  // force non-secure access for shared memory\n  assign                     {rab_acp_id_remap.aw_cache , dummy_axi.aw_cache } = m_axi_acp_awcache;\n  assign                     {rab_acp_id_remap.aw_region, dummy_axi.aw_region} = m_axi_acp_awregion;\n  assign                     {rab_acp_id_remap.aw_qos   , dummy_axi.aw_qos   } = m_axi_acp_awqos;\n  assign                     {rab_acp_id_remap.aw_user  , dummy_axi.aw_user  } = m_axi_acp_awuser;\n\n  assign                     {rab_acp_id_remap.w_data   , dummy_axi.w_data   } = m_axi_acp_wdata;\n  assign                     {rab_acp_id_remap.w_valid  , dummy_axi.w_valid  } = m_axi_acp_wvalid;\n  assign m_axi_acp_wready  = {rab_acp_id_remap.w_ready  , dummy_axi.w_ready  };\n  assign                     {rab_acp_id_remap.w_strb   , dummy_axi.w_strb   } = m_axi_acp_wstrb;\n  assign                     {rab_acp_id_remap.w_last   , dummy_axi.w_last   } = m_axi_acp_wlast;\n  assign                     {rab_acp_id_remap.w_user   , dummy_axi.w_user   } = m_axi_acp_wuser;\n\n  //assign m_axi_acp_bid   = {rab_acp_id_remap.b_id     , dummy_axi.b_id     };                     // ATTENTION: different signal widths can lead to wrong assignments\n  assign m_axi_acp_bresp   = {rab_acp_id_remap.b_resp   , dummy_axi.b_resp   };\n  assign m_axi_acp_bvalid  = {rab_acp_id_remap.b_valid  , dummy_axi.b_valid  };\n  assign m_axi_acp_buser   = {rab_acp_id_remap.b_user   , dummy_axi.b_user   };\n  assign                     {rab_acp_id_remap.b_ready  , dummy_axi.b_ready  } = m_axi_acp_bready;\n\n  //assign                   {rab_acp_id_remap.ar_id    , dummy_axi.ar_id    } = m_axi_acp_arid;    // ATTENTION: different signal widths can lead to wrong assignments\n  //assign                   {rab_acp_id_remap.ar_addr  , dummy_axi.ar_addr  } = m_axi_acp_araddr;  // ATTENTION: different signal widths can lead to wrong assignments\n  assign                     {rab_acp_id_remap.ar_valid , dummy_axi.ar_valid } = m_axi_acp_arvalid;\n  assign m_axi_acp_arready = {rab_acp_id_remap.ar_ready , dummy_axi.ar_ready };\n  assign                     {rab_acp_id_remap.ar_len   , dummy_axi.ar_len   } = m_axi_acp_arlen;\n  assign                     {rab_acp_id_remap.ar_size  , dummy_axi.ar_size  } = m_axi_acp_arsize;\n  assign                     {rab_acp_id_remap.ar_burst , dummy_axi.ar_burst } = m_axi_acp_arburst;\n  assign                     {rab_acp_id_remap.ar_lock  , dummy_axi.ar_lock  } = m_axi_acp_arlock;\n  //assign                   {rab_acp_id_remap.ar_prot  , dummy_axi.ar_prot  } = m_axi_acp_arprot;  // force non-secure access for shared memory\n  assign                     {rab_acp_id_remap.ar_region, dummy_axi.ar_region} = m_axi_acp_arregion;\n  assign                     {rab_acp_id_remap.ar_qos   , dummy_axi.ar_qos   } = m_axi_acp_arqos;\n  assign                     {rab_acp_id_remap.ar_cache , dummy_axi.ar_cache } = m_axi_acp_arcache;\n  assign                     {rab_acp_id_remap.ar_user  , dummy_axi.ar_user  } = m_axi_acp_aruser;\n\n  // assign m_axi_acp_rid  = {rab_acp_id_remap.r_id     , dummy_axi.r_id     };                     // ATTENTION: different signal widths can lead to wrong assignments\n  assign m_axi_acp_rdata   = {rab_acp_id_remap.r_data   , dummy_axi.r_data   };\n  assign m_axi_acp_rresp   = {rab_acp_id_remap.r_resp   , dummy_axi.r_resp   };\n  assign m_axi_acp_rvalid  = {rab_acp_id_remap.r_valid  , dummy_axi.r_valid  };\n  assign                     {rab_acp_id_remap.r_ready  , dummy_axi.r_ready  } = m_axi_acp_rready;\n  assign m_axi_acp_rlast   = {rab_acp_id_remap.r_last   , dummy_axi.r_last   };\n  assign m_axi_acp_ruser   = {rab_acp_id_remap.r_user   , dummy_axi.r_user   };\n\n  // handling of ID and address assignments of possibly different bit widths\n  assign rab_acp_id_remap.aw_id   = m_axi_acp_awid[1];\n  assign dummy_axi.aw_id          = m_axi_acp_awid[0];\n  assign rab_acp_id_remap.aw_addr = m_axi_acp_awaddr[1];\n  assign dummy_axi.aw_addr        = m_axi_acp_awaddr[0];\n\n  assign m_axi_acp_bid[1] = rab_acp_id_remap.b_id;\n  assign m_axi_acp_bid[0][AXI_ID_WIDTH-1      :AXI_ID_SOC_S_WIDTH] = 'b0;                // zero-extend incoming ID\n  assign m_axi_acp_bid[0][AXI_ID_SOC_S_WIDTH-1:0]                  = dummy_axi.b_id;\n\n  assign rab_acp_id_remap.ar_id   = m_axi_acp_arid[1];\n  assign dummy_axi.ar_id          = m_axi_acp_arid[0];\n  assign rab_acp_id_remap.ar_addr = m_axi_acp_araddr[1];\n  assign dummy_axi.ar_addr        = m_axi_acp_araddr[0];\n\n  assign m_axi_acp_rid[1] = rab_acp_id_remap.r_id;\n  assign m_axi_acp_rid[0][AXI_ID_WIDTH-1      :AXI_ID_SOC_S_WIDTH] = 'b0;                // zero-extend incoming ID\n  assign m_axi_acp_rid[0][AXI_ID_SOC_S_WIDTH-1:0]                  = dummy_axi.r_id;\n\n  // force non-secure access for shared memory\n`ifdef HOST_IS_64_BIT\n  assign rab_acp_id_remap.aw_prot = 3'b010;\n  assign rab_acp_id_remap.ar_prot = 3'b010;\n`else \n  assign rab_acp_id_remap.aw_prot = m_axi_acp_awprot[1];\n  assign rab_acp_id_remap.ar_prot = m_axi_acp_arprot[1];\n`endif\n  assign dummy_axi.aw_prot        = m_axi_acp_awprot[0];\n  assign dummy_axi.ar_prot        = m_axi_acp_arprot[0];\n\n  //------------------------------   *******   ---------------------------------------\n\n`ifdef EN_ACP\n  // dummy slave interface\n  assign dummy_axi.aw_ready  = 'b1;\n  assign dummy_axi.w_ready   = 'b1;\n  assign dummy_axi.b_id      = 'b0;\n  assign dummy_axi.b_resp    = 'b0;\n  assign dummy_axi.b_valid   = 'b0;\n  assign dummy_axi.b_user    = 'b0;\n  assign dummy_axi.ar_ready  = 'b1;\n  assign dummy_axi.r_id      = 'b0;\n  assign dummy_axi.r_data    = 'b0;\n  assign dummy_axi.r_resp    = 'b0;\n  assign dummy_axi.r_valid   = 'b0;\n  assign dummy_axi.r_last    = 'b0;\n  assign dummy_axi.r_user    = 'b0;\n`else \n  // let the synthesizer optimize it away\n  assign dummy_axi.aw_ready  = 'b0;\n  assign dummy_axi.w_ready   = 'b0;\n  assign dummy_axi.b_id      = 'b0;\n  assign dummy_axi.b_resp    = 'b0;\n  assign dummy_axi.b_valid   = 'b0;\n  assign dummy_axi.b_user    = 'b0;\n  assign dummy_axi.ar_ready  = 'b0;\n  assign dummy_axi.r_id      = 'b0;\n  assign dummy_axi.r_data    = 'b0;\n  assign dummy_axi.r_resp    = 'b0;\n  assign dummy_axi.r_valid   = 'b0;\n  assign dummy_axi.r_last    = 'b0;\n  assign dummy_axi.r_user    = 'b0;\n\n  assign rab_acp_id_remap.aw_ready = 'b0;\n  assign rab_acp_id_remap.w_ready  = 'b0;\n  assign rab_acp_id_remap.b_id     = 'b0;\n  assign rab_acp_id_remap.b_resp   = 'b0;\n  assign rab_acp_id_remap.b_valid  = 'b0;\n  assign rab_acp_id_remap.b_user   = 'b0;\n  assign rab_acp_id_remap.ar_ready = 'b0;\n  assign rab_acp_id_remap.r_id     = 'b0;\n  assign rab_acp_id_remap.r_data   = 'b0;\n  assign rab_acp_id_remap.r_resp   = 'b0;\n  assign rab_acp_id_remap.r_valid  = 'b0;\n  assign rab_acp_id_remap.r_last   = 'b0;\n  assign rab_acp_id_remap.r_user   = 'b0;\n`endif\n\n  //------------------------------   *******   ---------------------------------------\n  assign intr_miss_o     = | intr_rab_miss;\n  assign intr_multi_o    = | intr_rab_multi;\n  assign intr_prot_o     = | intr_rab_prot;\n  assign intr_mhf_full_o = intr_mhf_full;\n`ifdef RAB_AX_LOG_EN\n  assign intr_ar_log_full_o = | intr_ar_log_full;\n  assign intr_aw_log_full_o = | intr_aw_log_full;\n`endif\n\n  //------------------------------   arregion, arqos ---------------------------------\n  assign m_axi_arregion     = 4'b0;\n  assign m_axi_arqos        = 4'b0;\n  assign m_axi_acp_arregion = 4'b0;\n  assign m_axi_acp_arqos    = 4'b0;\n\n  //  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557    \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \n  // \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u255d \u2588\u2588\u2557\u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d    \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551     \n  // \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d    \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \n  //                                                                                  \n  axi_id_remap_wrap #(\n    .AXI_ADDR_WIDTH   ( AXI_INT_ADDR_WIDTH ),\n    .AXI_DATA_WIDTH   ( AXI_DATA_WIDTH     ),\n    .AXI_USER_WIDTH   ( AXI_USER_WIDTH     ),\n    .AXI_ID_IN_WIDTH  ( AXI_ID_EXT_M_WIDTH ),\n    .AXI_ID_OUT_WIDTH ( AXI_ID_WIDTH       ),\n`ifdef JUNO\n    .AXI_ID_SLOT      ( 16 )\n`elsif TE0808\n    .AXI_ID_SLOT      ( 16 )\n`elsif ZEDBOARD\n    .AXI_ID_SLOT      ( 8 )\n`else \n    .AXI_ID_SLOT      ( 8 )\n`endif\n  ) ext_m_id_remap_wrap_i (\n    .clk_i      ( clk_i              ),\n    .rst_ni     ( rst_ni             ),\n \n    .axi_slave  ( rab_slave          ),\n    .axi_master ( rab_slave_id_remap )\n  );\n\n  axi_id_remap_wrap #(\n    .AXI_ADDR_WIDTH   ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH   ( AXI_DATA_WIDTH     ),\n    .AXI_USER_WIDTH   ( AXI_USER_WIDTH     ),\n    .AXI_ID_IN_WIDTH  ( AXI_ID_WIDTH       ),\n    .AXI_ID_OUT_WIDTH ( AXI_ID_EXT_S_WIDTH ),\n`ifdef JUNO\n    .AXI_ID_SLOT      ( 16 )\n`elsif TE0808\n    .AXI_ID_SLOT      ( 16 )\n`elsif ZEDBOARD\n    .AXI_ID_SLOT      ( 8 )\n`else \n    .AXI_ID_SLOT      ( 8 )\n`endif\n  ) ext_s_id_remap_wrap_i (\n    .clk_i      ( clk_i               ),\n    .rst_ni     ( rst_ni              ),\n \n    .axi_slave  ( rab_master_id_remap ),\n    .axi_master ( rab_master          )\n  );\n    \n`ifdef EN_ACP   \n  axi_id_remap_wrap #(\n    .AXI_ADDR_WIDTH   ( AXI_ADDR_WIDTH         ),\n    .AXI_DATA_WIDTH   ( AXI_DATA_WIDTH         ),\n    .AXI_USER_WIDTH   ( AXI_USER_WIDTH         ),\n    .AXI_ID_IN_WIDTH  ( AXI_ID_WIDTH           ),\n    .AXI_ID_OUT_WIDTH ( AXI_ID_EXT_S_ACP_WIDTH ),\n`ifdef JUNO\n      .AXI_ID_SLOT    ( 16 )\n`elsif TE0808\n      .AXI_ID_SLOT    ( 16 )\n`elsif ZEDBOARD\n      .AXI_ID_SLOT    ( 1 ) // Actually 8, but MCHAN does not support read burst interleaving performed by the ACP.\n`else\n      .AXI_ID_SLOT    ( 1 ) // Actually 8, but MCHAN does not support read burst interleaving performed by the ACP.\n`endif\n  ) ext_s_acp_id_remap_wrap_i (\n    .clk_i      ( clk_i            ),\n    .rst_ni     ( rst_ni           ),\n \n    .axi_slave  ( rab_acp_id_remap ),\n    .axi_master ( rab_acp          )\n  );\n`endif\n  \n  //  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d       \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557       \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \n  // \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u255d \u2588\u2588\u2557\u2588\u2588\u2551    \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d       \u2588\u2588\u2551   \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \n  // \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d    \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d        \u255a\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d     \n  //                                                                           \n  axi_rab_top #(\n    .N_PORTS             ( N_PORTS             ),\n    .N_L2_SETS           ( N_L2_SETS           ),\n    .N_L2_SET_ENTRIES    ( N_L2_SET_ENTRIES    ),\n    .AXI_DATA_WIDTH      ( AXI_DATA_WIDTH      ), \n    .AXI_S_ADDR_WIDTH    ( AXI_INT_ADDR_WIDTH  ),\n    .AXI_M_ADDR_WIDTH    ( AXI_EXT_ADDR_WIDTH  ),\n    .AXI_LITE_DATA_WIDTH ( AXI_LITE_DATA_WIDTH ),\n    .AXI_LITE_ADDR_WIDTH ( AXI_LITE_ADDR_WIDTH ),\n    .AXI_ID_WIDTH        ( AXI_ID_WIDTH        ),\n    .AXI_USER_WIDTH      ( AXI_USER_WIDTH      ),\n  `ifdef ZEDBOARD\n    .MH_FIFO_DEPTH       ( 8                   )\n  `else\n    .MH_FIFO_DEPTH       ( 64                  )\n  `endif\n  ) axi_rab_top_i (\n    .Clk_CI          ( clk_i           ),\n    .NonGatedClk_CI  ( non_gated_clk_i ),\n    .Rst_RBI         ( rst_ni          ),\n\n    .s_axi4_awid     ( s_axi_awid      ),\n    .s_axi4_awaddr   ( s_axi_awaddr    ),\n    .s_axi4_awvalid  ( s_axi_awvalid   ),\n    .s_axi4_awready  ( s_axi_awready   ),\n    .s_axi4_awlen    ( s_axi_awlen     ),\n    .s_axi4_awsize   ( s_axi_awsize    ),\n    .s_axi4_awburst  ( s_axi_awburst   ),\n    .s_axi4_awlock   ( s_axi_awlock    ),\n    .s_axi4_awprot   ( s_axi_awprot    ),\n    .s_axi4_awcache  ( s_axi_awcache   ),\n    .s_axi4_awregion ( s_axi_awregion  ),\n    .s_axi4_awqos    ( s_axi_awqos     ),\n    .s_axi4_awuser   ( s_axi_awuser    ),\n\n    .s_axi4_wdata    ( s_axi_wdata     ),\n    .s_axi4_wvalid   ( s_axi_wvalid    ),\n    .s_axi4_wready   ( s_axi_wready    ),\n    .s_axi4_wstrb    ( s_axi_wstrb     ),\n    .s_axi4_wlast    ( s_axi_wlast     ),\n    .s_axi4_wuser    ( s_axi_wuser     ),\n\n    .s_axi4_bid      ( s_axi_bid       ),\n    .s_axi4_bresp    ( s_axi_bresp     ),\n    .s_axi4_bvalid   ( s_axi_bvalid    ),\n    .s_axi4_buser    ( s_axi_buser     ),\n    .s_axi4_bready   ( s_axi_bready    ),\n\n    .s_axi4_arid     ( s_axi_arid      ),\n    .s_axi4_araddr   ( s_axi_araddr    ),\n    .s_axi4_arvalid  ( s_axi_arvalid   ),\n    .s_axi4_arready  ( s_axi_arready   ),\n    .s_axi4_arlen  "}
{"text": "  ( s_axi_arlen     ),\n    .s_axi4_arsize   ( s_axi_arsize    ),\n    .s_axi4_arburst  ( s_axi_arburst   ),\n    .s_axi4_arlock   ( s_axi_arlock    ),\n    .s_axi4_arprot   ( s_axi_arprot    ),\n    .s_axi4_arcache  ( s_axi_arcache   ),\n    //.s_axi4_arregion ( s_axi_arregion  ), // not there in axi_rab_top...\n    //.s_axi4_arqos    ( s_axi_arqos     ), // not there in axi_rab_top...\n    .s_axi4_aruser   ( s_axi_aruser    ),\n\n    .s_axi4_rid      ( s_axi_rid       ),\n    .s_axi4_rdata    ( s_axi_rdata     ),\n    .s_axi4_rresp    ( s_axi_rresp     ),\n    .s_axi4_rvalid   ( s_axi_rvalid    ),\n    .s_axi4_rready   ( s_axi_rready    ),\n    .s_axi4_rlast    ( s_axi_rlast     ),\n    .s_axi4_ruser    ( s_axi_ruser     ),\n\n    .m0_axi4_awid    ( m_axi_awid      ),\n    .m0_axi4_awaddr  ( m_axi_awaddr    ),\n    .m0_axi4_awvalid ( m_axi_awvalid   ),\n    .m0_axi4_awready ( m_axi_awready   ),\n    .m0_axi4_awlen   ( m_axi_awlen     ),\n    .m0_axi4_awsize  ( m_axi_awsize    ),\n    .m0_axi4_awburst ( m_axi_awburst   ),\n    .m0_axi4_awlock  ( m_axi_awlock    ),\n    .m0_axi4_awprot  ( m_axi_awprot    ),\n    .m0_axi4_awcache ( m_axi_awcache   ),\n    .m0_axi4_awregion( m_axi_awregion  ),\n    .m0_axi4_awqos   ( m_axi_awqos     ),\n    .m0_axi4_awuser  ( m_axi_awuser    ),\n\n    .m0_axi4_wdata   ( m_axi_wdata     ),\n    .m0_axi4_wvalid  ( m_axi_wvalid    ),\n    .m0_axi4_wready  ( m_axi_wready    ),\n    .m0_axi4_wstrb   ( m_axi_wstrb     ),\n    .m0_axi4_wlast   ( m_axi_wlast     ),\n    .m0_axi4_wuser   ( m_axi_wuser     ),\n\n    .m0_axi4_bid     ( m_axi_bid       ),\n    .m0_axi4_bresp   ( m_axi_bresp     ),\n    .m0_axi4_bvalid  ( m_axi_bvalid    ),\n    .m0_axi4_buser   ( m_axi_buser     ),\n    .m0_axi4_bready  ( m_axi_bready    ),\n\n    .m0_axi4_arid    ( m_axi_arid      ),\n    .m0_axi4_araddr  ( m_axi_araddr    ),\n    .m0_axi4_arvalid ( m_axi_arvalid   ),\n    .m0_axi4_arready ( m_axi_arready   ),\n    .m0_axi4_arlen   ( m_axi_arlen     ),\n    .m0_axi4_arsize  ( m_axi_arsize    ),\n    .m0_axi4_arburst ( m_axi_arburst   ),\n    .m0_axi4_arlock  ( m_axi_arlock    ),\n    .m0_axi4_arprot  ( m_axi_arprot    ),\n    .m0_axi4_arcache ( m_axi_arcache   ),\n    //.m0_axi4_arregion( m_axi_arregion  ), // not there in axi_rab_top...\n    //.m0_axi4_arqos   ( m_axi_arqos     ), // not there in axi_rab_top...\n    .m0_axi4_aruser  ( m_axi_aruser    ),\n\n    .m0_axi4_rid     ( m_axi_rid       ),\n    .m0_axi4_rdata   ( m_axi_rdata     ),\n    .m0_axi4_rresp   ( m_axi_rresp     ),\n    .m0_axi4_rvalid  ( m_axi_rvalid    ),\n    .m0_axi4_rready  ( m_axi_rready    ),\n    .m0_axi4_rlast   ( m_axi_rlast     ),\n    .m0_axi4_ruser   ( m_axi_ruser     ),\n\n    .m1_axi4_awid    ( m_axi_acp_awid     ),\n    .m1_axi4_awaddr  ( m_axi_acp_awaddr   ),\n    .m1_axi4_awvalid ( m_axi_acp_awvalid  ),\n    .m1_axi4_awready ( m_axi_acp_awready  ),\n    .m1_axi4_awlen   ( m_axi_acp_awlen    ),\n    .m1_axi4_awsize  ( m_axi_acp_awsize   ),\n    .m1_axi4_awburst ( m_axi_acp_awburst  ),\n    .m1_axi4_awlock  ( m_axi_acp_awlock   ),\n    .m1_axi4_awprot  ( m_axi_acp_awprot   ),\n    .m1_axi4_awcache ( m_axi_acp_awcache  ),\n    .m1_axi4_awregion( m_axi_acp_awregion ),\n    .m1_axi4_awqos   ( m_axi_acp_awqos    ),\n    .m1_axi4_awuser  ( m_axi_acp_awuser   ),\n\n    .m1_axi4_wdata   ( m_axi_acp_wdata    ),\n    .m1_axi4_wvalid  ( m_axi_acp_wvalid   ),\n    .m1_axi4_wready  ( m_axi_acp_wready   ),\n    .m1_axi4_wstrb   ( m_axi_acp_wstrb    ),\n    .m1_axi4_wlast   ( m_axi_acp_wlast    ),\n    .m1_axi4_wuser   ( m_axi_acp_wuser    ),\n\n    .m1_axi4_bid     ( m_axi_acp_bid      ),\n    .m1_axi4_bresp   ( m_axi_acp_bresp    ),\n    .m1_axi4_bvalid  ( m_axi_acp_bvalid   ),\n    .m1_axi4_buser   ( m_axi_acp_buser    ),\n    .m1_axi4_bready  ( m_axi_acp_bready   ),\n\n    .m1_axi4_arid    ( m_axi_acp_arid     ),\n    .m1_axi4_araddr  ( m_axi_acp_araddr   ),\n    .m1_axi4_arvalid ( m_axi_acp_arvalid  ),\n    .m1_axi4_arready ( m_axi_acp_arready  ),\n    .m1_axi4_arlen   ( m_axi_acp_arlen    ),\n    .m1_axi4_arsize  ( m_axi_acp_arsize   ),\n    .m1_axi4_arburst ( m_axi_acp_arburst  ),\n    .m1_axi4_arlock  ( m_axi_acp_arlock   ),\n    .m1_axi4_arprot  ( m_axi_acp_arprot   ),\n    .m1_axi4_arcache ( m_axi_acp_arcache  ),\n    //.m1_axi4_arregion( m_axi_acp_arregion ), // not there in axi_rab_top...\n    //.m1_axi4_arqos   ( m_axi_acp_arqos    ),    // not there in axi_rab_top...\n    .m1_axi4_aruser  ( m_axi_acp_aruser   ),\n\n    .m1_axi4_rid     ( m_axi_acp_rid      ),\n    .m1_axi4_rdata   ( m_axi_acp_rdata    ),\n    .m1_axi4_rresp   ( m_axi_acp_rresp    ),\n    .m1_axi4_rvalid  ( m_axi_acp_rvalid   ),\n    .m1_axi4_rready  ( m_axi_acp_rready   ),\n    .m1_axi4_rlast   ( m_axi_acp_rlast    ),\n    .m1_axi4_ruser   ( m_axi_acp_ruser    ),\n\n    .s_axi4lite_awaddr  ( rab_lite.aw_addr  ),\n    .s_axi4lite_awvalid ( rab_lite.aw_valid ),\n    .s_axi4lite_awready ( rab_lite.aw_ready ),\n\n    .s_axi4lite_wdata   ( rab_lite.w_data   ),\n    .s_axi4lite_wvalid  ( rab_lite.w_valid  ),\n    .s_axi4lite_wready  ( rab_lite.w_ready  ),\n    .s_axi4lite_wstrb   ( rab_lite.w_strb   ),\n\n    .s_axi4lite_bresp   ( rab_lite.b_resp   ),\n    .s_axi4lite_bvalid  ( rab_lite.b_valid  ),\n    .s_axi4lite_bready  ( rab_lite.b_ready  ),\n\n    .s_axi4lite_araddr  ( rab_lite.ar_addr  ),\n    .s_axi4lite_arvalid ( rab_lite.ar_valid ),\n    .s_axi4lite_arready ( rab_lite.ar_ready ),\n\n    .s_axi4lite_rdata   ( rab_lite.r_data   ),\n    .s_axi4lite_rresp   ( rab_lite.r_resp   ),\n    .s_axi4lite_rvalid  ( rab_lite.r_valid  ),\n    .s_axi4lite_rready  ( rab_lite.r_ready  ),\n\n`ifdef RAB_AX_LOG_EN\n    .AwBram_PS          ( AwBram_PS         ),\n    .ArBram_PS          ( ArBram_PS         ),\n\n    .LogEn_SI           ( LogEn_SI          ),\n    .ArLogClr_SI        ( ArLogClr_SI       ),\n    .AwLogClr_SI        ( AwLogClr_SI       ),\n    .ArLogRdy_SO        ( ArLogRdy_SO       ),\n    .AwLogRdy_SO        ( AwLogRdy_SO       ),\n\n    .int_ar_log_full    ( intr_ar_log_full  ),\n    .int_aw_log_full    ( intr_aw_log_full  ),\n`endif\n    .int_miss           ( intr_rab_miss     ),\n    .int_multi          ( intr_rab_multi    ),\n    .int_prot           ( intr_rab_prot     ),\n    .int_mhf_full       ( intr_mhf_full     )\n  );\n\nendmodule\n\n// vim: ts=2 sw=2 sts=2 et nosmartindent autoindent foldmethod=marker\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"pulp_soc_defines.sv\"\n\nmodule axi_slice_dc_master_wrap\n  #(\n    parameter AXI_ADDR_WIDTH = 32,\n    parameter AXI_DATA_WIDTH = 64,\n    parameter AXI_USER_WIDTH = 6,\n    parameter AXI_ID_WIDTH   = 6,\n    parameter BUFFER_WIDTH   = 8\n   )\n  (\n    input logic         clk_i,\n    input logic         rst_ni,\n    input logic         test_cgbypass_i,\n\n    input  logic        clock_down_i,\n    input  logic        isolate_i,\n    output logic        incoming_req_o,\n\n    AXI_BUS_ASYNC.Slave axi_slave_async,\n\n    AXI_BUS.Master      axi_master\n  );\n\n  logic s_aw_valid;\n  logic s_w_valid;\n  logic s_ar_valid;\n  logic s_aw_ready;\n  logic s_ar_ready;\n  logic s_r_ready;\n  logic s_b_ready;\n\n  assign incoming_req_o = s_aw_valid | s_ar_valid;\n  assign s_aw_ready = ~clock_down_i & axi_master.aw_ready;\n  assign s_ar_ready = ~clock_down_i & axi_master.ar_ready;\n  assign axi_master.aw_valid = ~isolate_i & ~clock_down_i & s_aw_valid;\n  assign axi_master.w_valid  = ~isolate_i & ~clock_down_i & s_w_valid;\n  assign axi_master.ar_valid = ~isolate_i & ~clock_down_i & s_ar_valid;\n  assign axi_master.r_ready  = isolate_i | s_r_ready;\n  assign axi_master.b_ready  = isolate_i | s_b_ready;\n\n  axi_slice_dc_master #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH ),\n    .AXI_ID_WIDTH   ( AXI_ID_WIDTH   ),\n    .BUFFER_WIDTH   ( BUFFER_WIDTH   )\n  ) axi_slice_i (\n    .clk_i                    ( clk_i                                   ),\n    .rst_ni                   ( rst_ni                                  ),\n    .test_cgbypass_i          ( test_cgbypass_i                         ),\n\n    .axi_slave_aw_addr        ( axi_slave_async.aw_addr                 ),\n    .axi_slave_aw_prot        ( axi_slave_async.aw_prot                 ),\n    .axi_slave_aw_region      ( axi_slave_async.aw_region               ),\n    .axi_slave_aw_len         ( axi_slave_async.aw_len                  ),\n    .axi_slave_aw_size        ( axi_slave_async.aw_size                 ),\n    .axi_slave_aw_burst       ( axi_slave_async.aw_burst                ),\n    .axi_slave_aw_lock        ( axi_slave_async.aw_lock                 ),\n    .axi_slave_aw_cache       ( axi_slave_async.aw_cache                ),\n    .axi_slave_aw_qos         ( axi_slave_async.aw_qos                  ),\n    .axi_slave_aw_id          ( axi_slave_async.aw_id[AXI_ID_WIDTH-1:0] ),\n    .axi_slave_aw_user        ( axi_slave_async.aw_user                 ),\n    .axi_slave_aw_writetoken  ( axi_slave_async.aw_writetoken           ),\n    .axi_slave_aw_readpointer ( axi_slave_async.aw_readpointer          ),\n\n    .axi_slave_ar_addr        ( axi_slave_async.ar_addr                 ),\n    .axi_slave_ar_prot        ( axi_slave_async.ar_prot                 ),\n    .axi_slave_ar_region      ( axi_slave_async.ar_region               ),\n    .axi_slave_ar_len         ( axi_slave_async.ar_len                  ),\n    .axi_slave_ar_size        ( axi_slave_async.ar_size                 ),\n    .axi_slave_ar_burst       ( axi_slave_async.ar_burst                ),\n    .axi_slave_ar_lock        ( axi_slave_async.ar_lock                 ),\n    .axi_slave_ar_cache       ( axi_slave_async.ar_cache                ),\n    .axi_slave_ar_qos         ( axi_slave_async.ar_qos                  ),\n    .axi_slave_ar_id          ( axi_slave_async.ar_id[AXI_ID_WIDTH-1:0] ),\n    .axi_slave_ar_user        ( axi_slave_async.ar_user                 ),\n    .axi_slave_ar_writetoken  ( axi_slave_async.ar_writetoken           ),\n    .axi_slave_ar_readpointer ( axi_slave_async.ar_readpointer          ),\n\n    .axi_slave_w_data         ( axi_slave_async.w_data                  ),\n    .axi_slave_w_strb         ( axi_slave_async.w_strb                  ),\n    .axi_slave_w_user         ( axi_slave_async.w_user                  ),\n    .axi_slave_w_last         ( axi_slave_async.w_last                  ),\n    .axi_slave_w_writetoken   ( axi_slave_async.w_writetoken            ),\n    .axi_slave_w_readpointer  ( axi_slave_async.w_readpointer           ),\n\n    .axi_slave_r_data         ( axi_slave_async.r_data                  ),\n    .axi_slave_r_resp         ( axi_slave_async.r_resp                  ),\n    .axi_slave_r_last         ( axi_slave_async.r_last                  ),\n    .axi_slave_r_id           ( axi_slave_async.r_id[AXI_ID_WIDTH-1:0]  ),\n    .axi_slave_r_user         ( axi_slave_async.r_user                  ),\n    .axi_slave_r_writetoken   ( axi_slave_async.r_writetoken            ),\n    .axi_slave_r_readpointer  ( axi_slave_async.r_readpointer           ),\n\n    .axi_slave_b_resp         ( axi_slave_async.b_resp                  ),\n    .axi_slave_b_id           ( axi_slave_async.b_id[AXI_ID_WIDTH-1:0]  ),\n    .axi_slave_b_user         ( axi_slave_async.b_user                  ),\n    .axi_slave_b_writetoken   ( axi_slave_async.b_writetoken            ),\n    .axi_slave_b_readpointer  ( axi_slave_async.b_readpointer           ),\n\n    .axi_master_aw_valid      ( s_aw_valid                              ),\n    .axi_master_aw_ready      ( s_aw_ready                              ),\n    .axi_master_aw_addr       ( axi_master.aw_addr                      ),\n    .axi_master_aw_prot       ( axi_master.aw_prot                      ),\n    .axi_master_aw_region     ( axi_master.aw_region                    ),\n    .axi_master_aw_len        ( axi_master.aw_len                       ),\n    .axi_master_aw_size       ( axi_master.aw_size                      ),\n    .axi_master_aw_burst      ( axi_master.aw_burst                     ),\n    .axi_master_aw_lock       ( axi_master.aw_lock                      ),\n    .axi_master_aw_cache      ( axi_master.aw_cache                     ),\n    .axi_master_aw_qos        ( axi_master.aw_qos                       ),\n    .axi_master_aw_id         ( axi_master.aw_id[AXI_ID_WIDTH-1:0]      ),\n    .axi_master_aw_user       ( axi_master.aw_user                      ),\n\n    .axi_master_ar_valid      ( s_ar_valid                              ),\n    .axi_master_ar_ready      ( s_ar_ready                              ),\n    .axi_master_ar_addr       ( axi_master.ar_addr                      ),\n    .axi_master_ar_prot       ( axi_master.ar_prot                      ),\n    .axi_master_ar_region     ( axi_master.ar_region                    ),\n    .axi_master_ar_len        ( axi_master.ar_len                       ),\n    .axi_master_ar_size       ( axi_master.ar_size                      ),\n    .axi_master_ar_burst      ( axi_master.ar_burst                     ),\n    .axi_master_ar_lock       ( axi_master.ar_lock                      ),\n    .axi_master_ar_cache      ( axi_master.ar_cache                     ),\n    .axi_master_ar_qos        ( axi_master.ar_qos                       ),\n    .axi_master_ar_id         ( axi_master.ar_id[AXI_ID_WIDTH-1:0]      ),\n    .axi_master_ar_user       ( axi_master.ar_user                      ),\n\n    .axi_master_w_valid       ( s_w_valid                               ),\n    .axi_master_w_ready       ( axi_master.w_ready                      ),\n    .axi_master_w_data        ( axi_master.w_data                       ),\n    .axi_master_w_strb        ( axi_master.w_strb                       ),\n    .axi_master_w_user        ( axi_master.w_user                       ),\n    .axi_master_w_last        ( axi_master.w_last                       ),\n\n    .axi_master_r_valid       ( axi_master.r_valid                      ),\n    .axi_master_r_ready       ( s_r_ready                               ),\n    .axi_master_r_data        ( axi_master.r_data                       ),\n    .axi_master_r_resp        ( axi_master.r_resp                       ),\n    .axi_master_r_last        ( axi_master.r_last                       ),\n    .axi_master_r_id          ( axi_master.r_id[AXI_ID_WIDTH-1:0]       ),\n    .axi_master_r_user        ( axi_master.r_user                       ),\n\n    .axi_master_b_valid       ( axi_master.b_valid                      ),\n    .axi_master_b_ready       ( s_b_ready                               ),\n    .axi_master_b_resp        ( axi_master.b_resp                       ),\n    .axi_master_b_id          ( axi_master.b_id[AXI_ID_WIDTH-1:0]       ),\n    .axi_master_b_user        ( axi_master.b_user                       )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"pulp_soc_defines.sv\"\n\nmodule axi_slice_dc_slave_wrap\n  #(\n    parameter AXI_ADDR_WIDTH = 32,\n    parameter AXI_DATA_WIDTH = 64,\n    parameter AXI_USER_WIDTH = 6,\n    parameter AXI_ID_WIDTH   = 10,\n    parameter BUFFER_WIDTH   = 8\n   )\n  (\n    input logic\t         clk_i,\n    input logic\t         rst_ni,\n    input logic          test_cgbypass_i,\n    input logic          isolate_i,\n\n    AXI_BUS.Slave        axi_slave,\n\n    AXI_BUS_ASYNC.Master axi_master_async\n  );\n\n  logic s_b_valid;\n  logic s_b_ready;\n\n  logic s_r_valid;\n  logic s_r_ready;\n\n  assign axi_slave.b_valid = isolate_i ? 1'b0 : s_b_valid;\n  assign s_b_ready = isolate_i ? 1'b1 : axi_slave.b_ready;\n\n  assign axi_slave.r_valid = isolate_i ? 1'b0 : s_r_valid;\n  assign s_r_ready = isolate_i ? 1'b1 : axi_slave.r_ready;\n\n  axi_slice_dc_slave #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH ),\n    .AXI_ID_WIDTH   ( AXI_ID_WIDTH   ),\n    .BUFFER_WIDTH   ( BUFFER_WIDTH   )\n  ) axi_slice_i (\n    .clk_i                     ( clk_i                                    ),\n    .rst_ni                    ( rst_ni                                   ),\n    .test_cgbypass_i           ( test_cgbypass_i                          ),\n\n    .axi_slave_aw_valid        ( axi_slave.aw_valid                       ),\n    .axi_slave_aw_addr         ( axi_slave.aw_addr                        ),\n    .axi_slave_aw_prot         ( axi_slave.aw_prot                        ),\n    .axi_slave_aw_region       ( axi_slave.aw_region                      ),\n    .axi_slave_aw_len          ( axi_slave.aw_len                         ),\n    .axi_slave_aw_size         ( axi_slave.aw_size                        ),\n    .axi_slave_aw_burst        ( axi_slave.aw_burst                       ),\n    .axi_slave_aw_lock         ( axi_slave.aw_lock                        ),\n    .axi_slave_aw_cache        ( axi_slave.aw_cache                       ),\n    .axi_slave_aw_qos          ( axi_slave.aw_qos                         ),\n    .axi_slave_aw_id           ( axi_slave.aw_id[AXI_ID_WIDTH-1:0]        ),\n    .axi_slave_aw_user         ( axi_slave.aw_user                        ),\n    .axi_slave_aw_ready        ( axi_slave.aw_ready                       ),\n\n    .axi_slave_ar_valid        ( axi_slave.ar_valid                       ),\n    .axi_slave_ar_addr         ( axi_slave.ar_addr                        ),\n    .axi_slave_ar_prot         ( axi_slave.ar_prot                        ),\n    .axi_slave_ar_region       ( axi_slave.ar_region                      ),\n    .axi_slave_ar_len          ( axi_slave.ar_len                         ),\n    .axi_slave_ar_size         ( axi_slave.ar_size                        ),\n    .axi_slave_ar_burst        ( axi_slave.ar_burst                       ),\n    .axi_slave_ar_lock         ( axi_slave.ar_lock                        ),\n    .axi_slave_ar_cache        ( axi_slave.ar_cache                       ),\n    .axi_slave_ar_qos          ( axi_slave.ar_qos                         ),\n    .axi_slave_ar_id           ( axi_slave.ar_id[AXI_ID_WIDTH-1:0]        ),\n    .axi_slave_ar_user         ( axi_slave.ar_user                        ),\n    .axi_slave_ar_ready        ( axi_slave.ar_ready                       ),\n\n    .axi_slave_w_valid         ( axi_slave.w_valid                        ),\n    .axi_slave_w_data          ( axi_slave.w_data                         ),\n    .axi_slave_w_strb          ( axi_slave.w_strb                         ),\n    .axi_slave_w_user          ( axi_slave.w_user                         ),\n    .axi_slave_w_last          ( axi_slave.w_last                         ),\n    .axi_slave_w_ready         ( axi_slave.w_ready                        ),\n\n    .axi_slave_r_valid         ( s_r_valid                                ),\n    .axi_slave_r_data          ( axi_slave.r_data                         ),\n    .axi_slave_r_resp          ( axi_slave.r_resp                         ),\n    .axi_slave_r_last          ( axi_slave.r_last                         ),\n    .axi_slave_r_id            ( axi_slave.r_id[AXI_ID_WIDTH-1:0]         ),\n    .axi_slave_r_user          ( axi_slave.r_user                         ),\n    .axi_slave_r_ready         ( s_r_ready                                ),\n\n    .axi_slave_b_valid         ( s_b_valid                                ),\n    .axi_slave_b_resp          ( axi_slave.b_resp                         ),\n    .axi_slave_b_id            ( axi_slave.b_id[AXI_ID_WIDTH-1:0]         ),\n    .axi_slave_b_user          ( axi_slave.b_user                         ),\n    .axi_slave_b_ready         ( s_b_ready                                ),\n\n    .axi_master_aw_addr        ( axi_master_async.aw_addr                 ),\n    .axi_master_aw_prot        ( axi_master_async.aw_prot                 ),\n    .axi_master_aw_region      ( axi_master_async.aw_region               ),\n    .axi_master_aw_len         ( axi_master_async.aw_len                  ),\n    .axi_master_aw_size        ( axi_master_async.aw_size                 ),\n    .axi_master_aw_burst       ( axi_master_async.aw_burst                ),\n    .axi_master_aw_lock        ( axi_master_async.aw_lock                 ),\n    .axi_master_aw_cache       ( axi_master_async.aw_cache                ),\n    .axi_master_aw_qos         ( axi_master_async.aw_qos                  ),\n    .axi_master_aw_id          ( axi_master_async.aw_id[AXI_ID_WIDTH-1:0] ),\n    .axi_master_aw_user        ( axi_master_async.aw_user                 ),\n    .axi_master_aw_writetoken  ( axi_master_async.aw_writetoken           ),\n    .axi_master_aw_readpointer ( axi_master_async.aw_readpointer          ),\n\n    .axi_master_ar_addr        ( axi_master_async.ar_addr                 ),\n    .axi_master_ar_prot        ( axi_master_async.ar_prot                 ),\n    .axi_master_ar_region      ( axi_master_async.ar_region               ),\n    .axi_master_ar_len         ( axi_master_async.ar_len                  ),\n    .axi_master_ar_size        ( axi_master_async.ar_size                 ),\n    .axi_master_ar_burst       ( axi_master_async.ar_burst                ),\n    .axi_master_ar_lock        ( axi_master_async.ar_lock                 ),\n    .axi_master_ar_cache       ( axi_master_async.ar_cache                ),\n    .axi_master_ar_qos         ( axi_master_async.ar_qos                  ),\n    .axi_master_ar_id          ( axi_master_async.ar_id[AXI_ID_WIDTH-1:0] ),\n    .axi_master_ar_user        ( axi_master_async.ar_user                 ),\n    .axi_master_ar_writetoken  ( axi_master_async.ar_writetoken           ),\n    .axi_master_ar_readpointer ( axi_master_async.ar_readpointer          ),\n\n    .axi_master_w_data         ( axi_master_async.w_data                  ),\n    .axi_master_w_strb         ( axi_master_async.w_strb                  ),\n    .axi_master_w_user         ( axi_master_async.w_user                  ),\n    .axi_master_w_last         ( axi_master_async.w_last                  ),\n    .axi_master_w_writetoken   ( axi_master_async.w_writetoken            ),\n    .axi_master_w_readpointer  ( axi_master_async.w_readpointer           ),\n\n    .axi_master_r_data         ( axi_master_async.r_data                  ),\n    .axi_master_r_resp         ( axi_master_async.r_resp                  ),\n    .axi_master_r_last         ( axi_master_async.r_last                  ),\n    .axi_master_r_id           ( axi_master_async.r_id[AXI_ID_WIDTH-1:0]  ),\n    .axi_master_r_user         ( axi_master_async.r_user                  ),\n    .axi_master_r_writetoken   ( axi_master_async.r_writetoken            ),\n    .axi_master_r_readpointer  ( axi_master_async.r_readpointer           ),\n\n    .axi_master_b_resp         ( axi_master_async.b_resp                  ),\n    .axi_master_b_id           ( axi_master_async.b_id[AXI_ID_WIDTH-1:0]  ),\n    .axi_master_b_user         ( axi_master_async.b_user                  ),\n    .axi_master_b_writetoken   ( axi_master_async.b_writetoken            ),\n    .axi_master_b_readpointer  ( axi_master_async.b_readpointer           )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule axi_slice_wrap\n#(\n    parameter AXI_ADDR_WIDTH = 32,\n    parameter AXI_DATA_WIDTH = 64,\n    parameter AXI_USER_WIDTH = 6,\n    parameter AXI_ID_WIDTH   = 6,\n    parameter SLICE_DEPTH    = 2\n)\n(\n    input logic\t   clk_i,\n    input logic\t   rst_ni,\n    input logic\t   test_en_i,\n    \n    AXI_BUS.Slave  axi_slave,\n    AXI_BUS.Master axi_master\n);\n   \n   generate\n   \n   if( SLICE_DEPTH > 1)\n   begin : WITH_SLICE\n      axi_slice\n      #(\n\t  .AXI_ADDR_WIDTH (AXI_ADDR_WIDTH),\n\t  .AXI_DATA_WIDTH (AXI_DATA_WIDTH),\n\t  .AXI_USER_WIDTH (AXI_USER_WIDTH),\n\t  .AXI_ID_WIDTH   (AXI_ID_WIDTH),\n\t  .SLICE_DEPTH    (SLICE_DEPTH )\n      )\n      axi_slice_i\n      (\n\t  .clk_i(clk_i),\n\t  .rst_ni(rst_ni),\n\t  .test_en_i(test_en_i),\n\t  \n\t  .axi_slave_aw_valid_i  ( axi_slave.aw_valid               ),\n\t  .axi_slave_aw_addr_i   ( axi_slave.aw_addr                ),\n\t  .axi_slave_aw_prot_i   ( axi_slave.aw_prot                ),\n\t  .axi_slave_aw_region_i ( axi_slave.aw_region              ),\n\t  .axi_slave_aw_len_i    ( axi_slave.aw_len                 ),\n\t  .axi_slave_aw_size_i   ( axi_slave.aw_size                ),\n\t  .axi_slave_aw_burst_i  ( axi_slave.aw_burst               ),\n\t  .axi_slave_aw_lock_i   ( axi_slave.aw_lock                ),\n\t  .axi_slave_aw_cache_i  ( axi_slave.aw_cache               ),\n\t  .axi_slave_aw_qos_i    ( axi_slave.aw_qos                 ),\n\t  .axi_slave_aw_id_i     ( axi_slave.aw_id[AXI_ID_WIDTH-1:0]),\n\t  .axi_slave_aw_user_i   ( axi_slave.aw_user                ),\n\t  .axi_slave_aw_ready_o  ( axi_slave.aw_ready               ),\n\t  \n\t  .axi_slave_ar_valid_i  ( axi_slave.ar_valid               ),\n\t  .axi_slave_ar_addr_i   ( axi_slave.ar_addr                ),\n\t  .axi_slave_ar_prot_i   ( axi_slave.ar_prot                ),\n\t  .axi_slave_ar_region_i ( axi_slave.ar_region              ),\n\t  .axi_slave_ar_len_i    ( axi_slave.ar_len                 ),\n\t  .axi_slave_ar_size_i   ( axi_slave.ar_size                ),\n\t  .axi_slave_ar_burst_i  ( axi_slave.ar_burst               ),\n\t  .axi_slave_ar_lock_i   ( axi_slave.ar_lock                ),\n\t  .axi_slave_ar_cache_i  ( axi_slave.ar_cache               ),\n\t  .axi_slave_ar_qos_i    ( axi_slave.ar_qos                 ),\n\t  .axi_slave_ar_id_i     ( axi_slave.ar_id[AXI_ID_WIDTH-1:0]),\n\t  .axi_slave_ar_user_i   ( axi_slave.ar_user                ),\n\t  .axi_slave_ar_ready_o  ( axi_slave.ar_ready               ),\n\t  \n\t  .axi_slave_w_valid_i   ( axi_slave.w_valid                ),\n\t  .axi_slave_w_data_i    ( axi_slave.w_data                 ),\n\t  .axi_slave_w_strb_i    ( axi_slave.w_strb                 ),\n\t  .axi_slave_w_user_i    ( axi_slave.w_user                 ),\n\t  .axi_slave_w_last_i    ( axi_slave.w_last                 ),\n\t  .axi_slave_w_ready_o   ( axi_slave.w_ready                ),\n\t\t\t\t  \n\t  .axi_slave_r_valid_o   ( axi_slave.r_valid                ),\n\t  .axi_slave_r_data_o    ( axi_slave.r_data                 ),\n\t  .axi_slave_r_resp_o    ( axi_slave.r_resp                 ),\n\t  .axi_slave_r_last_o    ( axi_slave.r_last                 ),\n\t  .axi_slave_r_id_o      ( axi_slave.r_id[AXI_ID_WIDTH-1:0] ),\n\t  .axi_slave_r_user_o    ( axi_slave.r_user                 ),\n\t  .axi_slave_r_ready_i   ( axi_slave.r_ready                ),\n\t\t\t\t    \n\t  .axi_slave_b_valid_o   ( axi_slave.b_valid                ),\n\t  .axi_slave_b_resp_o    ( axi_slave.b_resp                 ),\n\t  .axi_slave_b_id_o      ( axi_slave.b_id[AXI_ID_WIDTH-1:0] ),\n\t  .axi_slave_b_user_o    ( axi_slave.b_user                 ),\n\t  .axi_slave_b_ready_i   ( axi_slave.b_ready                ),\n\t\t\t\t  \n\t  .axi_master_aw_valid_o ( axi_master.aw_valid               ),\n\t  .axi_master_aw_addr_o  ( axi_master.aw_addr                ),\n\t  .axi_master_aw_prot_o  ( axi_master.aw_prot                ),\n\t  .axi_master_aw_region_o( axi_master.aw_region              ),\n\t  .axi_master_aw_len_o   ( axi_master.aw_len                 ),\n\t  .axi_master_aw_size_o  ( axi_master.aw_size                ),\n\t  .axi_master_aw_burst_o ( axi_master.aw_burst               ),\n\t  .axi_master_aw_lock_o  ( axi_master.aw_lock                ),\n\t  .axi_master_aw_cache_o ( axi_master.aw_cache               ),\n\t  .axi_master_aw_qos_o   ( axi_master.aw_qos                 ),\n\t  .axi_master_aw_id_o    ( axi_master.aw_id[AXI_ID_WIDTH-1:0]),\n\t  .axi_master_aw_user_o  ( axi_master.aw_user                ),\n\t  .axi_master_aw_ready_i ( axi_master.aw_ready               ),\n\t  \n\t  .axi_master_ar_valid_o ( axi_master.ar_valid               ),\n\t  .axi_master_ar_addr_o  ( axi_master.ar_addr                ),\n\t  .axi_master_ar_prot_o  ( axi_master.ar_prot                ),\n\t  .axi_master_ar_region_o( axi_master.ar_region              ),\n\t  .axi_master_ar_len_o   ( axi_master.ar_len                 ),\n\t  .axi_master_ar_size_o  ( axi_master.ar_size                ),\n\t  .axi_master_ar_burst_o ( axi_master.ar_burst               ),\n\t  .axi_master_ar_lock_o  ( axi_master.ar_lock                ),\n\t  .axi_master_ar_cache_o ( axi_master.ar_cache               ),\n\t  .axi_master_ar_qos_o   ( axi_master.ar_qos                 ),\n\t  .axi_master_ar_id_o    ( axi_master.ar_id[AXI_ID_WIDTH-1:0]),\n\t  .axi_master_ar_user_o  ( axi_master.ar_user                ),\n\t  .axi_master_ar_ready_i ( axi_master.ar_ready               ),\n\t  \n\t  .axi_master_w_valid_o  ( axi_master.w_valid                ),\n\t  .axi_master_w_data_o   ( axi_master.w_data                 ),\n\t  .axi_master_w_strb_o   ( axi_master.w_strb                 ),\n\t  .axi_master_w_user_o   ( axi_master.w_user                 ),\n\t  .axi_master_w_last_o   ( axi_master.w_last                 ),\n\t  .axi_master_w_ready_i  ( axi_master.w_ready                ),\n\t  \n\t  .axi_master_r_valid_i  ( axi_master.r_valid                ),\n\t  .axi_master_r_data_i   ( axi_master.r_data                 ),\n\t  .axi_master_r_resp_i   ( axi_master.r_resp                 ),\n\t  .axi_master_r_last_i   ( axi_master.r_last                 ),\n\t  .axi_master_r_id_i     ( axi_master.r_id[AXI_ID_WIDTH-1:0] ),\n\t  .axi_master_r_user_i   ( axi_master.r_user                 ),\n\t  .axi_master_r_ready_o  ( axi_master.r_ready                ),\n\t  \n\t  .axi_master_b_valid_i  ( axi_master.b_valid                ),\n\t  .axi_master_b_resp_i   ( axi_master.b_resp                 ),\n\t  .axi_master_b_id_i     ( axi_master.b_id[AXI_ID_WIDTH-1:0] ),\n\t  .axi_master_b_user_i   ( axi_master.b_user                 ),\n\t  .axi_master_b_ready_o  ( axi_master.b_ready                )\n      );\n    end\n    else\n    begin : NO_SLICE\n\t  assign axi_master.aw_valid                  =  axi_slave.aw_valid                ;\n\t  assign axi_master.aw_addr                   =  axi_slave.aw_addr                 ;            \n\t  assign axi_master.aw_prot                   =  axi_slave.aw_prot                 ;\n\t  assign axi_master.aw_region                 =  axi_slave.aw_region               ;\n\t  assign axi_master.aw_len                    =  axi_slave.aw_len                  ;\n\t  assign axi_master.aw_size                   =  axi_slave.aw_size                 ;\n\t  assign axi_master.aw_burst                  =  axi_slave.aw_burst                ;\n\t  assign axi_master.aw_lock                   =  axi_slave.aw_lock                 ;\n\t  assign axi_master.aw_cache                  =  axi_slave.aw_cache                ;\n\t  assign axi_master.aw_qos                    =  axi_slave.aw_qos                  ;\n\t  assign axi_master.aw_id                     =  axi_slave.aw_id                   ;\n\t  assign axi_master.aw_user                   =  axi_slave.aw_user                 ;\n\t  assign axi_slave.aw_ready                   =  axi_master.aw_ready               ;\n\n\t  assign axi_master.ar_valid                  =  axi_slave.ar_valid                ;\n\t  assign axi_master.ar_addr                   =  axi_slave.ar_addr                 ; \n\t  assign axi_master.ar_prot                   =  axi_slave.ar_prot                 ;\n\t  assign axi_master.ar_region                 =  axi_slave.ar_region               ;\n\t  assign axi_master.ar_len                    =  axi_slave.ar_len                  ;\n\t  assign axi_master.ar_size                   =  axi_slave.ar_size                 ;\n\t  assign axi_master.ar_burst                  =  axi_slave.ar_burst                ;\n\t  assign axi_master.ar_lock                   =  axi_slave.ar_lock                 ;\n\t  assign axi_master.ar_cache                  =  axi_slave.ar_cache                ;\n\t  assign axi_master.ar_qos                    =  axi_slave.ar_qos                  ;\n\t  assign axi_master.ar_id                     =  axi_slave.ar_id                   ;\n\t  assign axi_master.ar_user                   =  axi_slave.ar_user                 ;\n\t  assign axi_slave.ar_ready                   =  axi_master.ar_ready               ;\n\t  \n\t  assign axi_master.w_valid                   =  axi_slave.w_valid                 ;\n\t  assign axi_master.w_data                    =  axi_slave.w_data                  ;\n\t  assign axi_master.w_strb                    =  axi_slave.w_strb                  ;\n\t  assign axi_master.w_user                    =  axi_slave.w_user                  ;\n\t  assign axi_master.w_last                    =  axi_slave.w_last                  ;\n\t  assign axi_slave.w_ready                    =  axi_master.w_ready                ;\n\t  \n\t  assign axi_slave.r_valid                    =  axi_master.r_valid                ;\n\t  assign axi_slave.r_data                     =  axi_master.r_data                 ;\n\t  assign axi_slave.r_resp                     =  axi_master.r_resp                 ;\n\t  assign axi_slave.r_last                     =  axi_master.r_last                 ;\n\t  assign axi_slave.r_id                       =  axi_master.r_id                   ;\n\t  assign axi_slave.r_user                     =  axi_master.r_user                 ;\n\t  assign axi_master.r_ready                   =  axi_slave.r_ready                 ;\n\t  \n\t  assign axi_slave.b_valid                    = axi_master.b_valid                 ;\n\t  assign axi_slave.b_resp                     = axi_master.b_resp                  ;\n\t  assign axi_slave.b_id                       = axi_master.b_id                    ;\n\t  assign axi_slave.b_user                     = axi_master.b_user                  ;\n\t  assign axi_master.b_ready                   = axi_slave.b_ready                  ;\n    end\n  endgenerate\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// --=========================================================================--\n//\n//  \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557     \u2588\u2588\u2557  \u2588\u2588\u2557    \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\n// \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551     \u2588\u2588\u2551 \u2588\u2588\u2554\u255d    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d    \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\n// \u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551       \u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\n// \u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2588\u2588\u2557     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551       \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\n// \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2557    \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551       \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\n//  \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d    \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d        \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\n// \n// Author: Pirmin Vogel - vogelpi@iis.ee.ethz.ch\n// \n// Purpose : Clock generation and gating, reset synchronization for host-2-pulp \n//           interconnects\n// \n// --=========================================================================--\n\nmodule clk_rst_gen\n  (\n    input  logic        ClkRef_CI,     // 100 MHz reference clock\n    input  logic        RstMaster_RBI, // board reset\n\n    input  logic        ClkIcHost_CI,\n    input  logic        RstIcHost_RBI, // needs to be combined with RstDebug_RBI and \n                                       // synced to ClkIcHost_CI\n    input  logic        ClkEn_SI,      \n    input  logic        RstDebug_RBI,  // MicroBlaze Debug Module reset\n    input  logic        RstUser_RBI,   // GPIO reset (axi_pulp_control)\n \n    input  logic [10:0] clking_axi_awaddr,\n    input  logic        clking_axi_awvalid,\n    output logic        clking_axi_awready,\n    input  logic [31:0] clking_axi_wdata,\n    input  logic  [3:0] clking_axi_wstrb,\n    input  logic        clking_axi_wvalid,\n    output logic        clking_axi_wready,\n    output logic  [1:0] clking_axi_bresp,\n    output logic        clking_axi_bvalid,\n    input  logic        clking_axi_bready,\n    input  logic [10:0] clking_axi_araddr,\n    input  logic        clking_axi_arvalid,\n    output logic        clking_axi_arready,\n    output logic [31:0] clking_axi_rdata,\n    output logic  [1:0] clking_axi_rresp,\n    output logic        clking_axi_rvalid,\n    input  logic        clking_axi_rready,\n  \n    output logic        ClkSoc_CO,\n    output logic        ClkSocGated_CO,\n    output logic        ClkCluster_CO,\n    output logic        ClkClusterGated_CO,\n  \n    output logic        RstSoc_RBO,     \n    output logic        RstIcPulp_RBO,\n    output logic        RstIcPulpGated_RBO,\n    output logic        RstIcHost_RBO,        // RstIcHost_RBI &\u00a0RstDebug_RBI synced to ClkIcHost\n    output logic        RstIcHostClkConv_RBO  //\u00a0RstIcHost_RBI & RstDebug_RBI &\u00a0~Locked synced to ClkIcHost\n  );\n\n  // Number of ClkIcHost_CI cycles to delay the locked signal.\n  //\n  // Xilinx recommends to keep all AXI interfaces in reset for at least 16 cycles of the slowest clock\n  // With a host interface clock of 100 MHz, the worst case is with PULP at 5 MHz (100/5*16 = 320).\n  localparam  N_DELAY_CYCLES = 320;\n\n  logic [N_DELAY_CYCLES-1:0] Locked_SP;\n\n  logic       RstClkMgr_RB;\n\n  logic       Locked_S;\n\n  logic       ClkEnSoc_SP;\n  logic       ClkEnCluster_SP;\n\n  //\u00a0Async resets\n  logic       RstSoc_RBA;\n  logic       RstIcPulp_RBA;\n  logic       RstIcHost_RBA;\n  logic       RstIcHostClkConv_RBA;\n\n  // Reset synchronizer\n  logic [2:0] RstSoc_RB;\n  logic [2:0] RstIcPulp_RB;\n  logic [2:0] RstIcPulpGated_RB;\n  logic [2:0] RstIcHost_RB;\n  logic [2:0] RstIcHostClkConv_RB;\n  \n  assign RstClkMgr_RB = RstMaster_RBI & RstIcHost_RBI;       \n\n  // Clock manager IP\n  xilinx_clock_manager clk_manager_i\n    (\n      .s_axi_aclk    ( ClkIcHost_CI       ),\n      .s_axi_aresetn ( RstClkMgr_RB       ),\n\n      .s_axi_awaddr  ( clking_axi_awaddr  ),\n      .s_axi_awvalid ( clking_axi_awvalid ),\n      .s_axi_awready ( clking_axi_awready ),\n      .s_axi_wdata   ( clking_axi_wdata   ),\n      .s_axi_wstrb   ( clking_axi_wstrb   ),\n      .s_axi_wvalid  ( clking_axi_wvalid  ),\n      .s_axi_wready  ( clking_axi_wready  ),\n      .s_axi_bresp   ( clking_axi_bresp   ),\n      .s_axi_bvalid  ( clking_axi_bvalid  ),\n      .s_axi_bready  ( clking_axi_bready  ),\n      .s_axi_araddr  ( clking_axi_araddr  ),\n      .s_axi_arvalid ( clking_axi_arvalid ),\n      .s_axi_arready ( clking_axi_arready ),\n      .s_axi_rdata   ( clking_axi_rdata   ),\n      .s_axi_rresp   ( clking_axi_rresp   ),\n      .s_axi_rvalid  ( clking_axi_rvalid  ),\n      .s_axi_rready  ( clking_axi_rready  ),\n\n      .clk_in1       ( ClkRef_CI          ),\n      .clk_out1      ( ClkSoc_CO          ),\n      .clk_out2      ( ClkCluster_CO      ),\n      .locked        ( Locked_S           )\n    );\n\n    // Clock gating\n    always_ff @(posedge ClkSoc_CO) begin\n      begin\n        ClkEnSoc_SP <= ClkEn_SI;\n      end\n    end\n\n    BUFGCE bufgce_soc_i\n      (\n        .I  ( ClkSoc_CO      ),\n        .CE ( ClkEnSoc_SP    ),\n        .O  ( ClkSocGated_CO )\n      );\n\n    always_ff @(posedge ClkCluster_CO) begin\n      begin\n        ClkEnCluster_SP <= ClkEn_SI;\n      end\n    end\n\n    BUFGCE bufgce_cluster_i\n      (\n        .I  ( ClkCluster_CO      ),\n        .CE ( ClkEnCluster_SP    ),\n        .O  ( ClkClusterGated_CO )\n      );\n\n    // Delay lock signal\n    always_ff @(posedge ClkIcHost_CI) begin\n      if (RstMaster_RBI == 1'b0)\n        Locked_SP <= 'b0;\n      else\n        begin\n          if (Locked_S == 1'b0) begin\n            Locked_SP <= 'b0;\n          end else begin\n            Locked_SP[N_DELAY_CYCLES-1]   <= 1'b1;\n            Locked_SP[N_DELAY_CYCLES-2:0] <= Locked_SP[N_DELAY_CYCLES-1:1];\n          end\n        end\n    end\n\n    // Resets ( ~RstMaster_RBI -> ~Locked_S )\n    assign RstIcHost_RBA        = RstIcHost_RBI & RstDebug_RBI;\n    assign RstIcHostClkConv_RBA = Locked_SP[0] & RstIcHost_RBI & RstDebug_RBI;\n    assign RstIcPulp_RBA        = Locked_SP[0] & RstMaster_RBI & RstDebug_RBI;\n    assign RstSoc_RBA           = Locked_SP[0] & RstMaster_RBI & RstDebug_RBI & RstUser_RBI;\n\n    // Sync resets for interconnects\n    always_ff @(posedge ClkIcHost_CI) begin\n      if (RstMaster_RBI == 1'b0)\n        RstIcHostClkConv_RB <= 'b0;\n      else\n        begin\n          RstIcHostClkConv_RB[1:0] <= RstIcHostClkConv_RB[2:1];\n          if(~RstIcHostClkConv_RBA) begin\n            RstIcHostClkConv_RB[2] <= 1'b0;\n          end else begin\n            RstIcHostClkConv_RB[2] <= 1'b1;\n          end\n        end\n    end\n\n    always_ff @(posedge ClkIcHost_CI) begin\n      if (RstMaster_RBI == 1'b0)\n        RstIcHost_RB <= 'b0;\n      else\n        begin\n          RstIcHost_RB[1:0] <= RstIcHost_RB[2:1];\n          if(~RstIcHost_RBA) begin\n            RstIcHost_RB[2] <= 1'b0;\n          end else begin\n            RstIcHost_RB[2] <= 1'b1;\n          end\n        end\n    end\n\n    always_ff @(posedge ClkSoc_CO) begin\n      if (RstMaster_RBI == 1'b0)\n        RstIcPulp_RB <= 'b0;\n      else\n        begin\n          RstIcPulp_RB[1:0] <= RstIcPulp_RB[2:1];\n          if(~RstIcPulp_RBA) begin\n            RstIcPulp_RB[2] <= 1'b0;\n          end else begin\n            RstIcPulp_RB[2] <= 1'b1;\n          end\n        end\n    end\n\n    always_ff @(posedge ClkSocGated_CO) begin\n      if (RstMaster_RBI == 1'b0)\n        RstIcPulpGated_RB <= 'b0;\n      else\n        begin\n          RstIcPulpGated_RB[1:0] <= RstIcPulpGated_RB[2:1];\n          if(~RstIcPulp_RBA) begin\n            RstIcPulpGated_RB[2] <= 1'b0;\n          end else begin\n            RstIcPulpGated_RB[2] <= 1'b1;\n          end\n        end\n    end\n\n    always_ff @(posedge ClkSoc_CO) begin\n      if (RstMaster_RBI == 1'b0)\n        RstSoc_RB <= 'b0;\n      else\n        begin\n          RstSoc_RB[1:0] <= RstSoc_RB[2:1];\n          if(~RstSoc_RBA) begin\n            RstSoc_RB[2] <= 1'b0;\n          end else begin\n            RstSoc_RB[2] <= 1'b1;\n          end\n        end\n    end\n\n    //\u00a0assign outputs\n    assign RstIcHostClkConv_RBO = RstIcHostClkConv_RB[0];\n    assign RstIcHost_RBO        = RstIcHost_RB[0];\n    assign RstIcPulp_RBO        = RstIcPulp_RB[0];\n    assign RstIcPulpGated_RBO   = RstIcPulpGated_RB[0];\n    assign RstSoc_RBO           = RstSoc_RB[0];\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/*\n * cluster_bus_defines.sv\n * Davide Rossi <davide.rossi@unibo.it>\n * Antonio Pullini <pullinia@iis.ee.ethz.ch>\n * Igor Loi <igor.loi@unibo.it>\n * Francesco Conti <fconti@iis.ee.ethz.ch>\n * Pasquale Davide Schiavone <pschiavo@iss.ee.ethz.ch>\n * Andreas Kurth <akurth@iis.ee.ethz.ch>\n */\n\n// CLUSTER BUS PARAMETRES\n\n`define NB_SLAVE  4\n`define NB_MASTER 3\n\n`define NB_REGION 2\n\n// MASTER PORT TO TCDM\n`define MASTER_0_START_ADDR 32'h1000_0000\n`define MASTER_0_END_ADDR   32'h101F_FFFF\n\n// MASTER PORT TO PERIPHERAL INTERCONNECT\n`define MASTER_1_START_ADDR 32'h1020_0000\n`define MASTER_1_END_ADDR   32'h103F_FFFF\n\n// MASTER PORT TO SOC\n// This port is divided into two regions.  All addresses that are not in the\n// cluster (i.e., that would go to one of the above master ports) go to the SoC.\n// Region 0 ends before Master 0, and Region 1 begins after Master 1.\n//\n// As the effective end address of Region 0 and start address of Region 1 depend\n// on the cluster ID, these addresses are set in the `cluster_bus_wrap` module.\n`define MASTER_2_REGION_0_START_ADDR 32'h0000_0000\n`define MASTER_2_REGION_1_END_ADDR   32'hFFFF_FFFF\n\n`define TCDM_ASSIGN_MASTER(lhs, rhs)      \\\n    assign lhs.req       = rhs.req;       \\\n    assign lhs.add       = rhs.add;       \\\n    assign lhs.wen       = rhs.wen;       \\\n    assign lhs.wdata     = rhs.wdata;     \\\n    assign lhs.be        = rhs.be;        \\\n                                          \\\n    assign rhs.gnt       = lhs.gnt;       \\\n    assign rhs.r_valid   = lhs.r_valid;   \\\n    assign rhs.r_opc     = lhs.r_opc;     \\\n    assign rhs.r_rdata   = lhs.r_rdata;\n\n`define TCDM_ASSIGN_SLAVE(lhs, rhs)  `TCDM_ASSIGN_MASTER(rhs, lhs)\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule cluster_clock_gating\n  (\n    input  logic clk_i,\n    input  logic en_i,\n    input  logic test_en_i,\n    output logic clk_o\n  );\n\n  assign clk_o = clk_i;\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule generic_memory\n#(\n  parameter ADDR_WIDTH = 12,\n  parameter DATA_WIDTH = 32,\n  parameter BE_WIDTH   = DATA_WIDTH/8\n)\n(\n  input  logic                  CLK,\n  input  logic                  INITN,\n\n  input  logic                  CEN,\n  input  logic [ADDR_WIDTH-1:0] A,\n  input  logic                  WEN,\n  input  logic [DATA_WIDTH-1:0] D,\n  input  logic [BE_WIDTH-1:0]   BEN,\n\n  output logic [DATA_WIDTH-1:0] Q\n);\n\n  localparam NUM_WORDS = 2**ADDR_WIDTH;\n\n  logic [DATA_WIDTH-1:0] MEM [NUM_WORDS-1:0];\n  logic [DATA_WIDTH-1:0] M;\n  genvar                 i,j;\n\n  generate\n    for (i=0; i<BE_WIDTH; i++) begin\n      for (j=0; j<8; j++) begin\n        assign M[i*8+j] = BEN[i];\n      end\n    end\n  endgenerate\n\n  generate\n    for (i=0; i < DATA_WIDTH ; i++) begin\n      always @ (posedge CLK) begin\n        if ( INITN == 1'b1 ) begin\n          if ( CEN == 1'b0 ) begin\n            if ( WEN == 1'b0 ) begin\n              if ( M[i] == 1'b0 ) begin\n                MEM[A][i] <= D[i];\n              end\n            end else if(WEN == 1'b1) begin\n              Q[i] <= MEM[A][i];\n            end\n          end\n        end\n      end\n    end\n  endgenerate\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule glitch_free_clk_mux\n  (\n    input  logic select_i,\n    input  logic test_mode_i,\n    output logic clk_selected_o,\n    input  logic clk0_i,\n    input  logic rstn0_i,\n    input  logic clk1_i,\n    input  logic rstn1_i,\n    output logic clk_out_o\n  );\n\n  BUFGMUX_CTRL bufgmux_i (\n    .S  ( select_i  ),\n    .I0 ( clk0_i    ),\n    .I1 ( clk1_i    ),\n    .O  ( clk_out_o )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule l2_generic\n#(\n  parameter MEM_ADDR_WIDTH = 13\n)\n(\n  input logic                       CLK,\n  input logic                       RSTN,\n  input logic                       INITN,\n\n  input logic                       CEN,\n  input logic                       WEN,\n  input logic  [MEM_ADDR_WIDTH-1:0] A,\n  input logic  [63:0]               D,\n  input logic  [7:0]                BE,\n  output logic [63:0]               Q,\n  input logic  [1:0]                WM,\n  input logic  [2:0]                RM,\n\n  input logic                       TM\n);\n\n  logic s_cen;\n  logic s_wen;\n\n  // GENERATION OF CEN\n  always_comb\n    begin\n      s_cen = 1'b1;\n      if (CEN == 1'b0)\n        s_cen = 1'b0;\n    end\n\n  // GENERATION OF WEN\n  always_comb\n    begin\n      s_wen = 1'b1;\n      if (WEN == 1'b0)\n        s_wen = 1'b0;\n    end\n\n  // MEMORY CUTS\n  generic_memory #(\n    .ADDR_WIDTH ( MEM_ADDR_WIDTH )\n  ) cut_lo (\n    .CLK        ( CLK      ),\n    .INITN      ( INITN    ),\n    .CEN        ( s_cen    ),\n    .A          ( A        ),\n    .WEN        ( s_wen    ),\n    .D          ( D[31:0]  ),\n    .BEN        ( ~BE[3:0] ),\n    .Q          ( Q[31:0]  )\n  );\n\n  generic_memory #(\n    .ADDR_WIDTH ( MEM_ADDR_WIDTH )\n  ) cut_hi (\n    .CLK        ( CLK      ),\n    .INITN      ( INITN    ),\n    .CEN        ( s_cen    ),\n    .A          ( A        ),\n    .WEN        ( s_wen    ),\n    .D          ( D[63:32] ),\n    .BEN        ( ~BE[7:4] ),\n    .Q          ( Q[63:32] )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule l2_mem\n#(\n  parameter MEM_ADDR_WIDTH = 1,\n  parameter NB_BANKS       = 2,\n  parameter BANK_SIZE      = 4096\n)\n(\n  input logic                 clk_i,\n  input logic                 rst_ni,\n  input logic                 test_en_i,\n\n  UNICAD_MEM_BUS_64.Slave     mem_slave\n);\n\n`ifdef PULP_FPGA_SIM\n\n  l2_generic #(\n    .MEM_ADDR_WIDTH ( MEM_ADDR_WIDTH )\n  ) l2_generic_i (\n    .CLK   ( clk_i                             ),\n    .RSTN  ( rst_ni                            ),\n    .INITN ( 1'b1                              ),\n    .D     ( mem_slave.wdata                   ),\n    .A     ( mem_slave.add[MEM_ADDR_WIDTH-1:0] ),\n    .CEN   ( mem_slave.csn                     ),\n    .WEN   ( mem_slave.wen                     ),\n    .BE    ( mem_slave.be                      ),\n    .Q     ( mem_slave.rdata                   ),\n    .WM    ( 2'b0                              ),\n    .RM    ( 3'b0                              ),\n    .TM    ( test_en_i                         )\n  );\n\n`else\n\n  SyncSpRamBeNx64 #(\n    .ADDR_WIDTH ( MEM_ADDR_WIDTH    ),\n    .DATA_DEPTH ( 2**MEM_ADDR_WIDTH ),\n    .OUT_REGS   ( 0                 )\n  ) SyncSpRamBeNx64_i (\n    .Clk_CI    ( clk_i                             ),\n    .Rst_RBI   ( rst_ni                            ),\n    .CSel_SI   ( ~mem_slave.csn                    ),\n    .WrEn_SI   ( ~mem_slave.wen                    ),\n    .BEn_SI    ( mem_slave.be                      ),\n    .Addr_DI   ( mem_slave.add[MEM_ADDR_WIDTH-1:0] ),\n    .WrData_DI ( mem_slave.wdata                   ),\n    .RdData_DO ( mem_slave.rdata                   )\n  );\n\n`endif\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"pulp_soc_defines.sv\"\n\nmodule pulp_cluster_wrap\n#(\n  // For simulation, the parameters are passed through this wrapper.\n  // For synthesis, the pulp_cluster.sv (top) gets the paramters from pulp_soc_defines.sv\n  // directly.\n  // cluster parameters\n  parameter NB_CORES           = `NB_CORES,\n  parameter NB_HWACC_PORTS     = 0,\n  parameter NB_DMAS            = 4,\n  parameter NB_MPERIPHS        = 1,\n  parameter NB_SPERIPHS        = 8,\n  parameter CLUSTER_ALIAS_BASE = 12'h1B0,\n  parameter TCDM_SIZE          = `TCDM_SIZE,              // [B], must be 2**N\n  parameter NB_TCDM_BANKS      = `NB_TCDM_BANKS,          // must be 2**N\n  parameter TCDM_BANK_SIZE     = TCDM_SIZE/NB_TCDM_BANKS, // [B]\n  parameter TCDM_NUM_ROWS      = TCDM_BANK_SIZE/4,        // [words]\n  parameter XNE_PRESENT        = 0,                       // set to 1 if XNE is present in the cluster\n\n  // I$ parameters\n  parameter SET_ASSOCIATIVE       = 4,\n  parameter NB_CACHE_BANKS        = `NB_CACHE_BANKS,\n  parameter CACHE_LINE            = 1,\n  parameter CACHE_SIZE            = `CACHE_SIZE,\n  parameter ICACHE_DATA_WIDTH     = 128,\n  parameter L0_BUFFER_FEATURE     = \"DISABLED\",\n  parameter MULTICAST_FEATURE     = \"DISABLED\",\n  parameter SHARED_ICACHE         = \"ENABLED\",\n  parameter DIRECT_MAPPED_FEATURE = \"DISABLED\",\n  parameter L2_SIZE               = `L2_SIZE,\n  parameter USE_REDUCED_TAG       = \"TRUE\",\n\n  // core parameters\n  parameter ROM_BOOT_ADDR     = 32'h1A000000,\n  parameter BOOT_ADDR         = 32'h1C000000,\n  parameter INSTR_RDATA_WIDTH = 128,\n  \n  // AXI parameters\n  parameter AXI_ADDR_WIDTH        = 32,\n  parameter AXI_DATA_C2S_WIDTH    = 64,\n  parameter AXI_DATA_S2C_WIDTH    = 64,\n  parameter AXI_USER_WIDTH        = 6,\n  parameter AXI_ID_IN_WIDTH       = 4,\n  parameter AXI_ID_OUT_WIDTH      = `AXI_ID_SOC_S_WIDTH,\n  parameter AXI_STRB_C2S_WIDTH    = AXI_DATA_C2S_WIDTH/8,\n  parameter AXI_STRB_S2C_WIDTH    = AXI_DATA_S2C_WIDTH/8,\n  parameter DC_SLICE_BUFFER_WIDTH = 8,\n  \n  // TCDM and log interconnect parameters\n  parameter DATA_WIDTH     = 32,\n  parameter ADDR_WIDTH     = 32,\n  parameter BE_WIDTH       = DATA_WIDTH/8,\n  parameter TEST_SET_BIT   = 20,                       // bit used to indicate a test-and-set operation during a load in TCDM\n  parameter ADDR_MEM_WIDTH = $clog2(TCDM_BANK_SIZE/4), // WORD address width per TCDM bank (the word width is 32 bits)\n  \n  // DMA parameters\n  parameter TCDM_ADD_WIDTH     = ADDR_MEM_WIDTH + $clog2(NB_TCDM_BANKS) + 2, // BYTE address width TCDM\n  parameter NB_OUTSND_BURSTS   = `NB_OUTSND_BURSTS,\n  parameter MCHAN_BURST_LENGTH = `MCHAN_BURST_LENGTH,\n\n  // peripheral and periph interconnect parameters\n  parameter LOG_CLUSTER    = 5,  // unused\n  parameter PE_ROUTING_LSB = 10, // LSB used as routing BIT in periph interco\n  parameter PE_ROUTING_MSB = 13, // MSB used as routing BIT in periph interco\n  parameter EVNT_WIDTH     = 8,  // size of the event bus\n  parameter REMAP_ADDRESS  = 0   // for cluster virtualization\n)\n(\n  input  logic                             clk_i,\n  input  logic                             rst_ni,\n  input  logic                             ref_clk_i,\n  input  logic                             pmu_mem_pwdn_i,\n  \n  input logic [3:0]                        base_addr_i,\n\n  input logic                              test_mode_i,\n\n  input logic                              en_sa_boot_i,\n\n  input logic [5:0]                        cluster_id_i,\n\n  input logic                              fetch_en_i,\n \n  output logic                             eoc_o,\n  \n  output logic                             busy_o,\n \n  input  logic [DC_SLICE_BUFFER_WIDTH-1:0] ext_events_writetoken_i,\n  output logic [DC_SLICE_BUFFER_WIDTH-1:0] ext_events_readpointer_o,\n  input  logic            [EVNT_WIDTH-1:0] ext_events_dataasync_i,\n  \n  input  logic                             dma_pe_evt_ack_i,\n  output logic                             dma_pe_evt_valid_o,\n\n  input  logic                             dma_pe_irq_ack_i,\n  output logic                             dma_pe_irq_valid_o,\n  \n  input  logic                             pf_evt_ack_i,\n  output logic                             pf_evt_valid_o,\n\n  AXI_BUS_ASYNC.Master                     data_master,\n  AXI_BUS_ASYNC.Slave                      data_slave\n);\n\n  // data_master\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_master_aw_writetoken_o ;  // output\n  logic        [AXI_ADDR_WIDTH-1:0] data_master_aw_addr_o ;        // output\n  logic                       [2:0] data_master_aw_prot_o ;        // output\n  logic                       [3:0] data_master_aw_region_o ;      // output\n  logic                       [7:0] data_master_aw_len_o ;         // output\n  logic                       [2:0] data_master_aw_size_o ;        // output\n  logic                       [1:0] data_master_aw_burst_o ;       // output\n  logic                             data_master_aw_lock_o ;        // output\n  logic                       [3:0] data_master_aw_cache_o ;       // output\n  logic                       [3:0] data_master_aw_qos_o ;         // output\n  logic      [AXI_ID_OUT_WIDTH-1:0] data_master_aw_id_o ;          // output\n  logic        [AXI_USER_WIDTH-1:0] data_master_aw_user_o ;        // output\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_master_aw_readpointer_i ; // input\n\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_master_ar_writetoken_o ;  // output\n  logic        [AXI_ADDR_WIDTH-1:0] data_master_ar_addr_o ;        // output\n  logic                       [2:0] data_master_ar_prot_o ;        // output\n  logic                       [3:0] data_master_ar_region_o ;      // output\n  logic                       [7:0] data_master_ar_len_o ;         // output\n  logic                       [2:0] data_master_ar_size_o ;        // output\n  logic                       [1:0] data_master_ar_burst_o ;       // output\n  logic                             data_master_ar_lock_o ;        // output\n  logic                       [3:0] data_master_ar_cache_o ;       // output\n  logic                       [3:0] data_master_ar_qos_o ;         // output\n  logic      [AXI_ID_OUT_WIDTH-1:0] data_master_ar_id_o ;          // output\n  logic        [AXI_USER_WIDTH-1:0] data_master_ar_user_o ;        // output\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_master_ar_readpointer_i ; // input\n\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_master_w_writetoken_o ;   // output  \n  logic    [AXI_DATA_C2S_WIDTH-1:0] data_master_w_data_o ;         // output\n  logic    [AXI_STRB_C2S_WIDTH-1:0] data_master_w_strb_o ;         // output\n  logic        [AXI_USER_WIDTH-1:0] data_master_w_user_o ;         // output\n  logic                             data_master_w_last_o ;         // output\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_master_w_readpointer_i ;  // input\n\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_master_r_writetoken_i ;   // input\n  logic    [AXI_DATA_C2S_WIDTH-1:0] data_master_r_data_i ;         // input\n  logic                       [1:0] data_master_r_resp_i ;         // input\n  logic                             data_master_r_last_i ;         // input\n  logic      [AXI_ID_OUT_WIDTH-1:0] data_master_r_id_i ;           // input\n  logic        [AXI_USER_WIDTH-1:0] data_master_r_user_i ;         // input\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_master_r_readpointer_o ;  // output\n\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_master_b_writetoken_i ;   // input\n  logic                       [1:0] data_master_b_resp_i ;         // input\n  logic      [AXI_ID_OUT_WIDTH-1:0] data_master_b_id_i ;           // input\n  logic        [AXI_USER_WIDTH-1:0] data_master_b_user_i ;         // input\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_master_b_readpointer_o ;  // output\n\n  // data_slave\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_slave_aw_writetoken_i ;   // input\n  logic        [AXI_ADDR_WIDTH-1:0] data_slave_aw_addr_i ;         // input\n  logic                       [2:0] data_slave_aw_prot_i ;         // input\n  logic                       [3:0] data_slave_aw_region_i ;       // input\n  logic                       [7:0] data_slave_aw_len_i ;          // input\n  logic                       [2:0] data_slave_aw_size_i ;         // input\n  logic                       [1:0] data_slave_aw_burst_i ;        // input\n  logic                             data_slave_aw_lock_i ;         // input\n  logic                       [3:0] data_slave_aw_cache_i ;        // input\n  logic                       [3:0] data_slave_aw_qos_i ;          // input\n  logic       [AXI_ID_IN_WIDTH-1:0] data_slave_aw_id_i ;           // input\n  logic        [AXI_USER_WIDTH-1:0] data_slave_aw_user_i ;         // input\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_slave_aw_readpointer_o ;  // output\n\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_slave_ar_writetoken_i ;   // input\n  logic        [AXI_ADDR_WIDTH-1:0] data_slave_ar_addr_i ;         // input\n  logic                       [2:0] data_slave_ar_prot_i ;         // input\n  logic                       [3:0] data_slave_ar_region_i ;       // input\n  logic                       [7:0] data_slave_ar_len_i ;          // input\n  logic                       [2:0] data_slave_ar_size_i ;         // input\n  logic                       [1:0] data_slave_ar_burst_i ;        // input\n  logic                             data_slave_ar_lock_i ;         // input\n  logic                       [3:0] data_slave_ar_cache_i ;        // input\n  logic                       [3:0] data_slave_ar_qos_i ;          // input\n  logic       [AXI_ID_IN_WIDTH-1:0] data_slave_ar_id_i ;           // input\n  logic        [AXI_USER_WIDTH-1:0] data_slave_ar_user_i ;         // input\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_slave_ar_readpointer_o ;  // output\n\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_slave_w_writetoken_i ;    // input\n  logic    [AXI_DATA_S2C_WIDTH-1:0] data_slave_w_data_i ;          // input\n  logic    [AXI_STRB_S2C_WIDTH-1:0] data_slave_w_strb_i ;          // input\n  logic        [AXI_USER_WIDTH-1:0] data_slave_w_user_i ;          // input\n  logic                             data_slave_w_last_i ;          // input\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_slave_w_readpointer_o ;   // output\n\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_slave_r_writetoken_o ;    // output\n  logic    [AXI_DATA_S2C_WIDTH-1:0] data_slave_r_data_o ;          // output\n  logic                       [1:0] data_slave_r_resp_o ;          // output\n  logic                             data_slave_r_last_o ;          // output\n  logic       [AXI_ID_IN_WIDTH-1:0] data_slave_r_id_o ;            // output\n  logic        [AXI_USER_WIDTH-1:0] data_slave_r_user_o ;          // output\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_slave_r_readpointer_i ;   // input\n\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_slave_b_writetoken_o ;    // output\n  logic                       [1:0] data_slave_b_resp_o ;          // output\n  logic       [AXI_ID_IN_WIDTH-1:0] data_slave_b_id_o ;            // output\n  logic        [AXI_USER_WIDTH-1:0] data_slave_b_user_o ;          // output\n  logic [DC_SLICE_BUFFER_WIDTH-1:0] data_slave_b_readpointer_i ;   // input\n\n  always_comb\n    begin : data_master_if\n      data_master.aw_writetoken    <= data_master_aw_writetoken_o ; // output\n      data_master.aw_addr          <= data_master_aw_addr_o ;       // output\n      data_master.aw_prot          <= data_master_aw_prot_o ;       // output\n      data_master.aw_region        <= data_master_aw_region_o ;     // output\n      data_master.aw_len           <= data_master_aw_len_o ;        // output\n      data_master.aw_size          <= data_master_aw_size_o ;       // output\n      data_master.aw_burst         <= data_master_aw_burst_o ;      // output\n      data_master.aw_lock          <= data_master_aw_lock_o ;       // output\n      data_master.aw_cache         <= data_master_aw_cache_o ;      // output\n      data_master.aw_qos           <= data_master_aw_qos_o ;        // output\n      data_master.aw_id            <= data_master_aw_id_o ;         // output\n      data_master.aw_user          <= data_master_aw_user_o ;       // output\n      data_master_aw_readpointer_i <= data_master.aw_readpointer ;  // input\n\n      data_master.ar_writetoken    <= data_master_ar_writetoken_o ; // output\n      data_master.ar_addr          <= data_master_ar_addr_o ;       // output\n      data_master.ar_prot          <= data_master_ar_prot_o ;       // output\n      data_master.ar_region        <= data_master_ar_region_o ;     // output\n      data_master.ar_len           <= data_master_ar_len_o ;        // output\n      data_master.ar_size          <= data_master_ar_size_o ;       // output\n      data_master.ar_burst         <= data_master_ar_burst_o ;      // output\n      data_master.ar_lock          <= data_master_ar_lock_o ;       // output\n      data_master.ar_cache         <= data_master_ar_cache_o ;      // output\n      data_master.ar_qos           <= data_master_ar_qos_o ;        // output\n      data_master.ar_id            <= data_master_ar_id_o ;         // output\n      data_master.ar_user          <= data_master_ar_user_o ;       // output\n      data_master_ar_readpointer_i <= data_master.ar_readpointer ;  // input\n\n      data_master.w_writetoken     <= data_master_w_writetoken_o ;  // output\n      data_master.w_data           <= data_master_w_data_o ;        // output\n      data_master.w_strb           <= data_master_w_strb_o ;        // output\n      data_master.w_user           <= data_master_w_user_o ;        // output\n      data_master.w_last           <= data_master_w_last_o ;        // output      \n      data_master_w_readpointer_i  <= data_master.w_readpointer ;   // input\n\n      data_master_r_writetoken_i   <= data_master.r_writetoken ;    // input\n      data_master_r_data_i         <= data_master.r_data ;          // input\n      data_master_r_resp_i         <= data_master.r_resp ;          // input\n      data_master_r_last_i         <= data_master.r_last ;          // input\n      data_master_r_id_i           <= data_master.r_id ;            // input\n      data_master_r_user_i         <= data_master.r_user ;          // input\n      data_master.r_readpointer    <= data_master_r_readpointer_o ; // output\n\n      data_master_b_writetoken_i   <= data_master.b_writetoken ;    // input\n      data_master_b_resp_i         <= data_master.b_resp ;          // input\n      data_master_b_id_i           <= data_master.b_id ;            // input\n      data_master_b_user_i         <= data_master.b_user ;          // input\n      data_master.b_readpointer    <= data_master_b_readpointer_o ; // output\n    end\n\n  always_comb\n    begin : data_slave_if\n      data_slave_aw_writetoken_i <= data_slave.aw_writetoken ;    // input\n      data_slave_aw_addr_i       <= data_slave.aw_addr ;          // input\n      data_slave_aw_prot_i       <= data_slave.aw_prot ;          // input\n      data_slave_aw_region_i     <= data_slave.aw_region ;        // input\n      data_slave_aw_len_i        <= data_slave.aw_len ;           // input\n      data_slave_aw_size_i       <= data_slave.aw_size ;          // input\n      data_slave_aw_burst_i      <= data_slave.aw_burst ;         // input\n      data_slave_aw_lock_i       <= data_slave.aw_lock ;          // input\n      data_slave_aw_cache_i      <= data_slave.aw_cache ;         // input\n      data_slave_aw_qos_i        <= data_slave.aw_qos ;           // input\n      data_slave_aw_id_i         <= data_slave.aw_id ;            // input\n      data_slave_aw_user_i       <= data_slave.aw_user ;          // input\n      data_slave.aw_readpointer  <= data_slave_aw_readpointer_o ; // output\n\n      data_slave_ar_writetoken_i <= data_slave.ar_writetoken ;    // input\n      data_slave_ar_addr_i       <= data_slave.ar_addr ;          // input\n      data_slave_ar_prot_i       <= data_slave.ar_prot ;          // input\n      data_slave_ar_region_i     <= data_slave.ar_region ;        // input\n      data_slave_ar_len_i        <= data_slave.ar_len ;           // input\n      data_slave_ar_size_i       <= data_slave.ar_size ;          // input\n      data_slave_ar_burst_i      <= data_slave.ar_burst ;         // input\n      data_slave_ar_lock_i       <= data_slave.ar_lock ;          // input\n      data_slave_ar_cache_i      <= data_slave.ar_cache ;         // input\n      data_slave_ar_qos_i        <= data_slave.ar_qos ;           // input\n      data_slave_ar_id_i         <= data_slave.ar_id ;            // input\n      data_slave_ar_user_i       <= data_slave.ar_user ;          // input\n      data_slave.ar_readpointer  <= data_slave_ar_readpointer_o ; // output\n\n      data_slave_w_writetoken_i  <= data_slave.w_writetoken ;     // input\n      data_slave_w_data_i        <= data_slave.w_data ;           // input\n      data_slave_w_strb_i        <= data_slave.w_strb ;           // input\n      data_slave_w_user_i        <= data_slave.w_user ;           // input\n      data_slave_w_last_i        <= data_slave.w_last ;           // input\n      data_slave.w_readpointer   <= data_slave_w_readpointer_o ;  // output\n      \n      data_slave.r_data          <= data_slave_r_data_o ;         // output\n      data_slave.r_resp          <= data_slave_r_resp_o ;         // output\n      data_slave.r_id            <= data_slave_r_id_o ;           // output\n      data_slave.r_user          <= data_slave_r_user_o ;         // output\n      data_slave.r_last          <= data_slave_r_last_o ;         // output\n      data_slave.r_writetoken    <= data_slave_r_writetoken_o ;   // output\n      data_slave_r_readpointer_i <= data_slave.r_readpointer ;    // input\n      \n      data_slave.b_resp          <= data_slave_b_resp_o ;         // output\n      data_slave.b_id            <= data_slave_b_id_o ;           // output\n      data_slave.b_user          <= data_slave_b_user_o ;         // output\n      data_slave.b_writetoken    <= data_slave_b_writetoken_o ;   // output\n      data_slave_b_readpointer_i <= data_slave.b_readpointer ;    // input\n    end\n\n  pulp_cluster #(\n`ifdef PULP_FPGA_SIM\n    // cluster parameters\n    .NB_CORES              ( NB_CORES              ),\n    .NB_HWACC_PORTS        ( NB_HWACC_PORTS        ),\n    .NB_DMAS               ( NB_DMAS               ),\n    .NB_MPERIPHS           ( NB_MPERIPHS           ),\n    .NB_SPERIPHS           ( NB_SPERIPHS           ),\n    .CLUSTER_ALIAS_BASE    ( CLUSTER_ALIAS_BASE    ),\n    .TCDM_SIZE             ( TCDM_SIZE             ),\n    .NB_TCDM_BANKS         ( NB_TCDM_BANKS         ),\n    .TCDM_BANK_SIZE        ( TCDM_BANK_SIZE        ),\n    .TCDM_NUM_ROWS         ( TCDM_NUM_ROWS         ),\n    .XNE_PRESENT           ( XNE_PRESENT           ),\n\n    // I$ parameters\n    .SET_ASSOCIATIVE       ( SET_ASSOCIATIVE       ),\n    .NB_CACHE_BANKS        ( NB_CACHE_BANKS        ),\n    .CACHE_LINE            ( CACHE_LINE            ),\n    .CACHE_SIZE            ( CACHE_SIZE            ),\n    .ICACHE_DATA_WIDTH     ( ICACHE_DATA_WIDTH     ),\n    .L0_BUFFER_FEATURE     ( L0_BUFFER_FEATURE     ),\n    .MULTICAST_FEATURE     ( MULTICAST_FEATURE     ),\n    .SHARED_ICACHE         ( SHARED_ICACHE         ),\n    .DIRECT_MAPPED_FEATURE ( DIRECT_MAPPED_FEATURE ),\n    .L2_SIZE               ( L2_SIZE               ),\n    .USE_REDUCED_TAG       ( USE_REDUCED_TAG       ),\n\n    // core parameters\n    .ROM_BOOT_ADDR         ( ROM_BOOT_ADDR         ),\n    .BOOT_ADDR             ( BOOT_ADDR             ),"}
{"text": "\n    .INSTR_RDATA_WIDTH     ( INSTR_RDATA_WIDTH     ),\n\n    // AXI parameters\n    .AXI_ADDR_WIDTH        ( AXI_ADDR_WIDTH        ),\n    .AXI_DATA_C2S_WIDTH    ( AXI_DATA_C2S_WIDTH    ),\n    .AXI_DATA_S2C_WIDTH    ( AXI_DATA_S2C_WIDTH    ),\n    .AXI_USER_WIDTH        ( AXI_USER_WIDTH        ),\n    .AXI_ID_IN_WIDTH       ( AXI_ID_IN_WIDTH       ),\n    .AXI_ID_OUT_WIDTH      ( AXI_ID_OUT_WIDTH      ),\n    .AXI_STRB_C2S_WIDTH    ( AXI_STRB_C2S_WIDTH    ),\n    .AXI_STRB_S2C_WIDTH    ( AXI_STRB_S2C_WIDTH    ),\n    .DC_SLICE_BUFFER_WIDTH ( DC_SLICE_BUFFER_WIDTH ),\n\n    // TCDM and log interconnect parameters\n    .DATA_WIDTH            ( DATA_WIDTH            ),\n    .ADDR_WIDTH            ( ADDR_WIDTH            ),\n    .BE_WIDTH              ( BE_WIDTH              ),\n    .TEST_SET_BIT          ( TEST_SET_BIT          ),\n    .ADDR_MEM_WIDTH        ( ADDR_MEM_WIDTH        ),\n\n    // DMA parameters\n    .TCDM_ADD_WIDTH        ( TCDM_ADD_WIDTH        ),\n    .NB_OUTSND_BURSTS      ( NB_OUTSND_BURSTS      ),\n    .MCHAN_BURST_LENGTH    ( MCHAN_BURST_LENGTH    ),\n\n    // peripheral and periph interconnect parameters\n    .LOG_CLUSTER           ( LOG_CLUSTER           ),\n    .PE_ROUTING_LSB        ( PE_ROUTING_LSB        ),\n    .PE_ROUTING_MSB        ( PE_ROUTING_MSB        ),\n    .EVNT_WIDTH            ( EVNT_WIDTH            ),\n    .REMAP_ADDRESS         ( REMAP_ADDRESS         )\n`endif\n  ) pulp_cluster_i (\n    .clk_i,\n    .rst_ni,\n    .ref_clk_i,\n    .pmu_mem_pwdn_i,\n\n    .base_addr_i,\n\n    .test_mode_i,\n\n    .en_sa_boot_i,\n\n    .cluster_id_i,\n\n    .fetch_en_i,\n\n    .eoc_o,\n\n    .busy_o,\n\n    .ext_events_writetoken_i,\n    .ext_events_readpointer_o,\n    .ext_events_dataasync_i,\n\n    .dma_pe_evt_ack_i,\n    .dma_pe_evt_valid_o,\n\n    .dma_pe_irq_ack_i,\n    .dma_pe_irq_valid_o,\n\n    .pf_evt_ack_i,\n    .pf_evt_valid_o,\n\n    // data slave IF\n    .data_slave_aw_writetoken_i,\n    .data_slave_aw_addr_i,\n    .data_slave_aw_prot_i,\n    .data_slave_aw_region_i,\n    .data_slave_aw_len_i,\n    .data_slave_aw_size_i,\n    .data_slave_aw_burst_i,\n    .data_slave_aw_lock_i,\n    .data_slave_aw_cache_i,\n    .data_slave_aw_qos_i,\n    .data_slave_aw_id_i,\n    .data_slave_aw_user_i,\n    .data_slave_aw_readpointer_o,\n\n    .data_slave_ar_writetoken_i,\n    .data_slave_ar_addr_i,\n    .data_slave_ar_prot_i,\n    .data_slave_ar_region_i,\n    .data_slave_ar_len_i,\n    .data_slave_ar_size_i,\n    .data_slave_ar_burst_i,\n    .data_slave_ar_lock_i,\n    .data_slave_ar_cache_i,\n    .data_slave_ar_qos_i,\n    .data_slave_ar_id_i,\n    .data_slave_ar_user_i,\n    .data_slave_ar_readpointer_o,\n\n    .data_slave_w_writetoken_i,\n    .data_slave_w_data_i,\n    .data_slave_w_strb_i,\n    .data_slave_w_user_i,\n    .data_slave_w_last_i,\n    .data_slave_w_readpointer_o,\n\n    .data_slave_r_writetoken_o,\n    .data_slave_r_data_o,\n    .data_slave_r_resp_o,\n    .data_slave_r_last_o,\n    .data_slave_r_id_o,\n    .data_slave_r_user_o,\n    .data_slave_r_readpointer_i,\n\n    .data_slave_b_writetoken_o,\n    .data_slave_b_resp_o,\n    .data_slave_b_id_o,\n    .data_slave_b_user_o,\n    .data_slave_b_readpointer_i,\n\n    // data maste rIF\n    .data_master_aw_writetoken_o,\n    .data_master_aw_addr_o,\n    .data_master_aw_prot_o,\n    .data_master_aw_region_o,\n    .data_master_aw_len_o,\n    .data_master_aw_size_o,\n    .data_master_aw_burst_o,\n    .data_master_aw_lock_o,\n    .data_master_aw_cache_o,\n    .data_master_aw_qos_o,\n    .data_master_aw_id_o,\n    .data_master_aw_user_o,\n    .data_master_aw_readpointer_i,\n\n    .data_master_ar_writetoken_o,\n    .data_master_ar_addr_o,\n    .data_master_ar_prot_o,\n    .data_master_ar_region_o,\n    .data_master_ar_len_o,\n    .data_master_ar_size_o,\n    .data_master_ar_burst_o,\n    .data_master_ar_lock_o,\n    .data_master_ar_cache_o,\n    .data_master_ar_qos_o,\n    .data_master_ar_id_o,\n    .data_master_ar_user_o,\n    .data_master_ar_readpointer_i,\n\n    .data_master_w_writetoken_o,\n    .data_master_w_data_o,\n    .data_master_w_strb_o,\n    .data_master_w_user_o,\n    .data_master_w_last_o,\n    .data_master_w_readpointer_i,\n\n    .data_master_r_writetoken_i,\n    .data_master_r_data_i,\n    .data_master_r_resp_i,\n    .data_master_r_last_i,\n    .data_master_r_id_i,\n    .data_master_r_user_i,\n    .data_master_r_readpointer_o,\n\n    .data_master_b_writetoken_i,\n    .data_master_b_resp_i,\n    .data_master_b_id_i,\n    .data_master_b_user_i,\n    .data_master_b_readpointer_o\n  );\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"pulp_soc_defines.sv\"\n\n//**********************************************************\n//**************** XBAR TCDM BUS 64 ************************\n//**********************************************************\n\ninterface XBAR_TCDM_BUS_64;\n\n  // REQUEST CHANNEL\n  //***************************************\n  logic        req;\n  logic [31:0] add;\n  logic        wen;\n  logic [63:0] wdata;\n  logic  [7:0] be;\n  logic        gnt;\n\n  // RESPONSE CHANNEL\n  //***************************************\n  logic        r_opc;\n  logic [63:0] r_rdata;\n  logic        r_valid;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output req,\n    output add,\n    output wen,\n    output wdata,\n    output be,\n    input  gnt,\n    input  r_rdata,\n    input  r_opc,\n    input  r_valid\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  req,\n    input  add,\n    input  wen,\n    input  wdata,\n    input  be,\n    output gnt,\n    output r_rdata,\n    output r_opc,\n    output r_valid\n  );\n\nendinterface\n\n//**********************************************************\n//**************** XBAR TCDM BUS ***************************\n//**********************************************************\n\ninterface XBAR_TCDM_BUS;\n\n  // REQUEST CHANNEL\n  //***************************************\n  logic        req;\n  logic [31:0] add;\n  logic        wen;\n  logic [31:0] wdata;\n  logic  [3:0] be;\n  logic        gnt;\n\n  // RESPONSE CHANNEL\n  //***************************************\n  logic        r_opc;\n  logic [31:0] r_rdata;\n  logic        r_valid;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output req,\n    output add,\n    output wen,\n    output wdata,\n    output be,\n    input  gnt,\n    input  r_rdata,\n    input  r_opc,\n    input  r_valid\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  req,\n    input  add,\n    input  wen,\n    input  wdata,\n    input  be,\n    output gnt,\n    output r_rdata,\n    output r_opc,\n    output r_valid\n  );\n\nendinterface\n\n//**********************************************************\n//**************** XBAR PERIPHERAL BUS *********************\n//**********************************************************\n\ninterface XBAR_PERIPH_BUS\n#(\n  parameter ID_WIDTH = `NB_CORES+1\n);\n\n  // REQUEST CHANNEL\n  //***************************************\n  logic                req;\n  logic         [31:0] add;\n  logic                wen;\n  logic         [31:0] wdata;\n  logic          [3:0] be;\n  logic                gnt;\n  logic [ID_WIDTH-1:0] id;\n\n  // RESPONSE CHANNEL\n  //***************************************\n  logic                r_valid;\n  logic                r_opc;\n  logic [ID_WIDTH-1:0] r_id;\n  logic         [31:0] r_rdata;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output req,\n    output add,\n    output wen,\n    output wdata,\n    output be,\n    output id,\n    input  gnt,\n    input  r_rdata,\n    input  r_opc,\n    input  r_id,\n    input  r_valid\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  req,\n    input  add,\n    input  wen,\n    input  wdata,\n    input  be,\n    input  id,\n    output gnt,\n    output r_rdata,\n    output r_opc,\n    output r_id,\n    output r_valid\n  );\n\nendinterface\n\n//**********************************************************\n//**************** MESSAGE BUS -- TODO *********************\n//**********************************************************\n\ninterface MESSAGE_BUS\n#(\n  parameter ID_WIDTH = `NB_CORES+1\n);\n\n  // REQUEST CHANNEL\n  //***************************************\n  logic                req;\n  logic         [31:0] add;\n  logic                wen;\n  logic         [31:0] wdata;\n  logic          [3:0] be;\n  logic                gnt;\n  logic [ID_WIDTH-1:0] id;\n\n  // RESPONSE CHANNEL\n  logic                r_valid;\n  logic                r_opc;\n  logic [ID_WIDTH-1:0] r_id;\n  logic         [31:0] r_rdata;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output req,\n    output add,\n    output wen,\n    output wdata,\n    output be,\n    output id,\n    input  gnt,\n    input  r_rdata,\n    input  r_opc,\n    input  r_id,\n    input  r_valid\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  req,\n    input  add,\n    input  wen,\n    input  wdata,\n    input  be,\n    input  id,\n    output gnt,\n    output r_rdata,\n    output r_opc,\n    output r_id,\n    output r_valid\n  );\n\nendinterface\n\n//**********************************************************\n//******************** XBAR DEMUX BUS **********************\n//**********************************************************\n\ninterface XBAR_DEMUX_BUS;\n\n  // REQUEST CHANNEL\n  //***************************************\n  logic        barrier;\n  logic        busy;\n  logic        exec_cancel;\n  logic        exec_stall;\n  logic        req;\n  logic [31:0] add;\n  logic        we;\n  logic [31:0] wdata;\n  logic  [3:0] be;\n  logic        gnt;\n\n  // RESPONSE CHANNEL\n  //***************************************\n  logic        r_gnt;\n  logic        r_valid;\n  logic [31:0] r_rdata;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output barrier,\n    input  busy,\n    output exec_cancel,\n    output exec_stall,\n    output req,\n    output add,\n    output we,\n    output wdata,\n    output be,\n    input  gnt,\n    output r_gnt,\n    input  r_rdata,\n    input  r_valid\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  barrier,\n    output busy,\n    input  exec_cancel,\n    input  exec_stall,\n    input  req,\n    input  add,\n    input  we,\n    input  wdata,\n    input  be,\n    output gnt,\n    input  r_gnt,\n    output r_rdata,\n    output r_valid\n  );\n\nendinterface\n\n//********************************************************\n//**************** TCDM BANK MEM BUS *********************\n//********************************************************\n\ninterface TCDM_BANK_MEM_BUS;\n\n  logic [31:0] wdata;\n  logic [31:0] add;\n  logic        req;\n  logic        wen;\n  logic  [3:0] be;\n  logic [31:0] rdata;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output wdata,\n    output add,\n    output req,\n    output wen,\n    output be,\n    input  rdata\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  wdata,\n    input  add,\n    input  req,\n    input  wen,\n    input  be,\n    output rdata\n  );\n\nendinterface\n\n//********************************************************\n//**************** UNICAD MEMORY BUS *********************\n//********************************************************\n\ninterface UNICAD_MEM_BUS_64;\n\n  logic [63:0] wdata;\n  logic [31:0] add;\n  logic        csn;\n  logic        wen;\n  logic  [7:0] be;\n  logic [63:0] rdata;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output wdata,\n    output add,\n    output csn,\n    output wen,\n    output be,\n    input  rdata\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  wdata,\n    input  add,\n    input  csn,\n    input  wen,\n    input  be,\n    output rdata\n  );\n\nendinterface\n\n//**********************************************************\n//**************** UNICAD_MEM_BUS_32************************\n//**********************************************************\n\ninterface UNICAD_MEM_BUS_32;\n  logic [31:0] wdata;\n  logic [31:0] add;\n  logic        csn;\n  logic        wen;\n  logic  [3:0] be;\n  logic [31:0] rdata;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output wdata,\n    output add,\n    output csn,\n    output wen,\n    output be,\n    input  rdata\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  wdata,\n    input  add,\n    input  csn,\n    input  wen,\n    input  be,\n    output rdata\n  );\n\nendinterface\n\n\n//********************************************************\n//******************** TCDM BUS **************************\n//********************************************************\n\ninterface TCDM_BUS;\n\n  logic      [63:0] data;\n  logic       [8:0] addr;\n  logic       [3:0] csn;\n  logic       [3:0] wen;\n  logic      [63:0] wmn;\n  logic [3:0][63:0] qdata;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output data,\n    output addr,\n    output csn,\n    output wen,\n    output wmn,\n    input  qdata\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  data,\n    input  addr,\n    input  csn,\n    input  wen,\n    input  wmn,\n    output qdata\n  );\n\nendinterface\n\n//********************************************************\n//***************** BBMUX CONFIG BUS *********************\n//********************************************************\n\ninterface BBMUX_CONFIG_BUS;\n\n  logic [3:0][1:0] bbmux_tcdm;\n  logic [3:0][1:0] bbmux_core;\n  logic      [1:0] bbmux_scm;\n  logic      [1:0] bbmux_int;\n  logic            bbmux_sel;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output bbmux_tcdm,\n    output bbmux_core,\n    output bbmux_scm,\n    output bbmux_int,\n    output bbmux_sel\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input bbmux_tcdm,\n    input bbmux_core,\n    input bbmux_scm,\n    input bbmux_int,\n    input bbmux_sel\n  );\n\nendinterface\n\n//********************************************************\n//********************** AXI BUS *************************\n//********************************************************\n\ninterface AXI_BUS\n#(\n  parameter AXI_ADDR_WIDTH = 32,\n  parameter AXI_DATA_WIDTH = 64,\n  parameter AXI_ID_WIDTH   = 10,\n  parameter AXI_USER_WIDTH = 6\n);\n\n  localparam AXI_STRB_WIDTH = `EVAL_BE_WIDTH(AXI_DATA_WIDTH);\n\n  logic [AXI_ADDR_WIDTH-1:0] aw_addr;\n  logic                [2:0] aw_prot;\n  logic                [3:0] aw_region;\n  logic                [7:0] aw_len;\n  logic                [2:0] aw_size;\n  logic                [1:0] aw_burst;\n  logic                      aw_lock;\n  logic                [3:0] aw_cache;\n  logic                [3:0] aw_qos;\n  logic   [AXI_ID_WIDTH-1:0] aw_id;\n  logic [AXI_USER_WIDTH-1:0] aw_user;\n  logic                      aw_ready;\n  logic                      aw_valid;\n\n  logic [AXI_ADDR_WIDTH-1:0] ar_addr;\n  logic                [2:0] ar_prot;\n  logic                [3:0] ar_region;\n  logic                [7:0] ar_len;\n  logic                [2:0] ar_size;\n  logic                [1:0] ar_burst;\n  logic                      ar_lock;\n  logic                [3:0] ar_cache;\n  logic                [3:0] ar_qos;\n  logic   [AXI_ID_WIDTH-1:0] ar_id;\n  logic [AXI_USER_WIDTH-1:0] ar_user;\n  logic                      ar_ready;\n  logic                      ar_valid;\n\n  logic                      w_valid;\n  logic [AXI_DATA_WIDTH-1:0] w_data;\n  logic [AXI_STRB_WIDTH-1:0] w_strb;\n  logic [AXI_USER_WIDTH-1:0] w_user;\n  logic                      w_last;\n  logic                      w_ready;\n\n  logic [AXI_DATA_WIDTH-1:0] r_data;\n  logic                [1:0] r_resp;\n  logic                      r_last;\n  logic   [AXI_ID_WIDTH-1:0] r_id;\n  logic [AXI_USER_WIDTH-1:0] r_user;\n  logic                      r_ready;\n  logic                      r_valid;\n\n  logic                [1:0] b_resp;\n  logic   [AXI_ID_WIDTH-1:0] b_id;\n  logic [AXI_USER_WIDTH-1:0] b_user;\n  logic                      b_ready;\n  logic                      b_valid;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output aw_valid,\n    output aw_addr,\n    output aw_prot,\n    output aw_region,\n    output aw_len,\n    output aw_size,\n    output aw_burst,\n    output aw_lock,\n    output aw_cache,\n    output aw_qos,\n    output aw_id,\n    output aw_user,\n    input  aw_ready,\n\n    output ar_valid,\n    output ar_addr,\n    output ar_prot,\n    output ar_region,\n    output ar_len,\n    output ar_size,\n    output ar_burst,\n    output ar_lock,\n    output ar_cache,\n    output ar_qos,\n    output ar_id,\n    output ar_user,\n    input  ar_ready,\n\n    output w_valid,\n    output w_data,\n    output w_strb,\n    output w_user,\n    output w_last,\n    input  w_ready,\n\n    input  r_valid,\n    input  r_data,\n    input  r_resp,\n    input  r_last,\n    input  r_id,\n    input  r_user,\n    output r_ready,\n\n    input  b_valid,\n    input  b_resp,\n    input  b_id,\n    input  b_user,\n    output b_ready\n  );\n\n  // Master Side\n  //***************************************\n  modport Slave\n  (\n    input  aw_valid,\n    input  aw_addr,\n    input  aw_prot,\n    input  aw_region,\n    input  aw_len,\n    input  aw_size,\n    input  aw_burst,\n    input  aw_lock,\n    input  aw_cache,\n    input  aw_qos,\n    input  aw_id,\n    input  aw_user,\n    output aw_ready,\n\n    input  ar_valid,\n    input  ar_addr,\n    input  ar_prot,\n    input  ar_region,\n    input  ar_len,\n    input  ar_size,\n    input  ar_burst,\n    input  ar_lock,\n    input  ar_cache,\n    input  ar_qos,\n    input  ar_id,\n    input  ar_user,\n    output ar_ready,\n\n    input  w_valid,\n    input  w_data,\n    input  w_strb,\n    input  w_user,\n    input  w_last,\n    output w_ready,\n\n    output r_valid,\n    output r_data,\n    output r_resp,\n    output r_last,\n    output r_id,\n    output r_user,\n    input  r_ready,\n\n    output b_valid,\n    output b_resp,\n    output b_id,\n    output b_user,\n    input  b_ready\n  );\n\nendinterface\n\n//********************************************************\n//******************* AXI BUS ASYNC **********************\n//********************************************************\n\ninterface AXI_BUS_ASYNC\n#(\n  parameter AXI_ADDR_WIDTH = 32,\n  parameter AXI_DATA_WIDTH = 64,\n  parameter AXI_ID_WIDTH   = 10,\n  parameter AXI_USER_WIDTH = 6,\n  parameter BUFFER_WIDTH = 8\n);\n\n  localparam AXI_STRB_WIDTH = `EVAL_BE_WIDTH(AXI_DATA_WIDTH);\n\n  logic [AXI_ADDR_WIDTH-1:0] aw_addr;\n  logic                [2:0] aw_prot;\n  logic                [3:0] aw_region;\n  logic                [7:0] aw_len;\n  logic                [2:0] aw_size;\n  logic                [1:0] aw_burst;\n  logic                      aw_lock;\n  logic                [3:0] aw_cache;\n  logic                [3:0] aw_qos;\n  logic   [AXI_ID_WIDTH-1:0] aw_id;\n  logic [AXI_USER_WIDTH-1:0] aw_user;\n  logic   [BUFFER_WIDTH-1:0] aw_writetoken;\n  logic   [BUFFER_WIDTH-1:0] aw_readpointer;\n\n  logic [AXI_ADDR_WIDTH-1:0] ar_addr;\n  logic                [2:0] ar_prot;\n  logic                [3:0] ar_region;\n  logic                [7:0] ar_len;\n  logic                [2:0] ar_size;\n  logic                [1:0] ar_burst;\n  logic                      ar_lock;\n  logic                [3:0] ar_cache;\n  logic                [3:0] ar_qos;\n  logic   [AXI_ID_WIDTH-1:0] ar_id;\n  logic [AXI_USER_WIDTH-1:0] ar_user;\n  logic   [BUFFER_WIDTH-1:0] ar_writetoken;\n  logic   [BUFFER_WIDTH-1:0] ar_readpointer;\n\n  logic [AXI_DATA_WIDTH-1:0] w_data;\n  logic [AXI_STRB_WIDTH-1:0] w_strb;\n  logic [AXI_USER_WIDTH-1:0] w_user;\n  logic                      w_last;\n  logic   [BUFFER_WIDTH-1:0] w_writetoken;\n  logic   [BUFFER_WIDTH-1:0] w_readpointer;\n\n  logic [AXI_DATA_WIDTH-1:0] r_data;\n  logic                [1:0] r_resp;\n  logic                      r_last;\n  logic   [AXI_ID_WIDTH-1:0] r_id;\n  logic [AXI_USER_WIDTH-1:0] r_user;\n  logic   [BUFFER_WIDTH-1:0] r_writetoken;\n  logic   [BUFFER_WIDTH-1:0] r_readpointer;\n\n  logic                [1:0] b_resp;\n  logic   [AXI_ID_WIDTH-1:0] b_id;\n  logic [AXI_USER_WIDTH-1:0] b_user;\n  logic   [BUFFER_WIDTH-1:0] b_writetoken;\n  logic   [BUFFER_WIDTH-1:0] b_readpointer;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output aw_addr,\n    output aw_prot,\n    output aw_region,\n    output aw_len,\n    output aw_size,\n    output aw_burst,\n    output aw_lock,\n    output aw_cache,\n    output aw_qos,\n    output aw_id,\n    output aw_user,\n    output aw_writetoken,\n    input  aw_readpointer,\n\n    output ar_addr,\n    output ar_prot,\n    output ar_region,\n    output ar_len,\n    output ar_size,\n    output ar_burst,\n    output ar_lock,\n    output ar_cache,\n    output ar_qos,\n    output ar_id,\n    output ar_user,\n    output ar_writetoken,\n    input  ar_readpointer,\n\n    output w_data,\n    output w_strb,\n    output w_user,\n    output w_last,\n    output w_writetoken,\n    input  w_readpointer,\n\n    input  r_data,\n    input  r_resp,\n    input  r_last,\n    input  r_id,\n    input  r_user,\n    input  r_writetoken,\n    output r_readpointer,\n\n    input  b_resp,\n    input  b_id,\n    input  b_user,\n    input  b_writetoken,\n    output b_readpointer\n  );\n\n  // Master Side\n  //***************************************\n  modport Slave\n  (\n    input  aw_addr,\n    input  aw_prot,\n    input  aw_region,\n    input  aw_len,\n    input  aw_size,\n    input  aw_burst,\n    input  aw_lock,\n    input  aw_cache,\n    input  aw_qos,\n    input  aw_id,\n    input  aw_user,\n    input  aw_writetoken,\n    output aw_readpointer,\n\n    input  ar_addr,\n    input  ar_prot,\n    input  ar_region,\n    input  ar_len,\n    input  ar_size,\n    input  ar_burst,\n    input  ar_lock,\n    input  ar_cache,\n    input  ar_qos,\n    input  ar_id,\n    input  ar_user,\n    input  ar_writetoken,\n    output ar_readpointer,\n\n    input  w_data,\n    input  w_strb,\n    input  w_user,\n    input  w_last,\n    input  w_writetoken,\n    output w_readpointer,\n\n    output r_data,\n    output r_resp,\n    output r_last,\n    output r_id,\n    output r_user,\n    output r_writetoken,\n    input  r_readpointer,\n\n    output b_resp,\n    output b_id,\n    output b_user,\n    output b_writetoken,\n    input  b_readpointer\n  );\n\nendinterface\n\n//********************************************************\n//********************** AXI LITE ************************\n//********************************************************\n\ninterface AXI_LITE\n#(\n  parameter AXI_ADDR_WIDTH = 32,\n  parameter AXI_DATA_WIDTH = 64,\n  parameter AXI_ID_WIDTH   = 6,\n  parameter AXI_USER_WIDTH = 6\n);\n\n  localparam AXI_STRB_WIDTH = `EVAL_BE_WIDTH(AXI_DATA_WIDTH);\n\n  logic [AXI_ADDR_WIDTH-1:0] aw_addr;\n  logic                      aw_valid;\n  logic                      aw_ready;\n\n  logic [AXI_DATA_WIDTH-1:0] w_data;\n  logic                      w_valid;\n  logic                      w_ready;\n  logic [AXI_STRB_WIDTH-1:0] w_strb;\n\n  logic                [1:0] b_resp;\n  logic                      b_valid;\n  logic                      b_ready;\n\n  logic [AXI_ADDR_WIDTH-1:0] ar_addr;\n  logic                      ar_valid;\n  logic                      ar_ready;\n\n  logic [AXI_DATA_WIDTH-1:0] r_data;\n  logic                [1:0] r_resp;\n  logic                      r_valid;\n  logic                      r_ready;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output aw_addr,\n    output aw_valid,\n    input  aw_ready,\n\n    output w_data,\n    output w_valid,\n    input  w_ready,\n    output w_strb,\n\n    input  b_resp,\n    input  b_valid,\n    output b_ready,\n\n    output ar_addr,\n    output ar_valid,\n    input  ar_ready,\n\n    input  r_data,\n    input  r_resp,\n    input  r_valid,\n    output r_ready\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  aw_addr,\n    input  aw_valid,\n    output aw_ready,"}
{"text": "\n\n    input  w_data,\n    input  w_valid,\n    output w_ready,\n    input  w_strb,\n\n    output b_resp,\n    output b_valid,\n    input  b_ready,\n\n    input  ar_addr,\n    input  ar_valid,\n    output ar_ready,\n\n    output r_data,\n    output r_resp,\n    output r_valid,\n    input  r_ready\n  );\n\nendinterface\n\n//********************************************************\n//***************** CLKGATE CONFIG BUS *******************\n//********************************************************\n\ninterface CLKGATE_CONFIG_BUS;\n\n  // REQUEST CHANNEL\n  //***************************************\n  logic [`NB_CORES-1:0] clkgate_tcdm;\n  logic [`NB_CORES-1:0] clkgate_core;\n  logic                 clkgate_scm;\n  logic                 clkgate_int;\n  logic                 clkgate_hwacc;\n  logic                 clkgate_sel;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output clkgate_tcdm,\n    output clkgate_core,\n    output clkgate_scm,\n    output clkgate_int,\n    output clkgate_hwacc,\n    output clkgate_sel\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input clkgate_tcdm,\n    input clkgate_core,\n    input clkgate_scm,\n    input clkgate_int,\n    input clkgate_hwacc,\n    input clkgate_sel\n  );\n\nendinterface\n\n//********************************************************\n//***************** MMU CONFIG BUS ***********************\n//********************************************************\n\ninterface MMU_CONFIG_BUS;\n\n  // size of section in SRAM that is mapped in sequential\n  // (non-interleaved) order for collision free private accesses,\n  // always starting at the top of the whole SRAM section\n  // n = 0: disable sequential section\n  // n > 0: seq. section of size 2^n * 32 Byte\n  logic [3:0] mmu_sram_seqsec_size;\n  // seperate section can be declared sindie the SCM part\n  // sizing works as above, the seq. section always starts\n  // at the top of the SCM section\n  logic [3:0] mmu_scm_seqsec_size;\n  // NOTE: address translation can be fully disabled setting\n  //       both mmu_sram_seq_size and mmu_scm_seq_size to 0\n  //       (this is the default reset value)\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output mmu_sram_seqsec_size,\n    output mmu_scm_seqsec_size\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input mmu_sram_seqsec_size,\n    input mmu_scm_seqsec_size\n  );\n\nendinterface\n\n//********************************************************\n//***************** BIST IC BUS **************************\n//********************************************************\n\ninterface BIST_BUS;\n\n  logic        bist_en;\n  logic        bist_done_even;\n  logic        bist_done_odd;\n  logic        bist_result_even;\n  logic        bist_result_odd;\n  logic [31:0] bist_pattern;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output bist_en,\n    input  bist_done_even,\n    input  bist_done_odd,\n    input  bist_result_even,\n    input  bist_result_odd,\n    output bist_pattern\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  bist_en,\n    output bist_done_even,\n    output bist_done_odd,\n    output bist_result_even,\n    output bist_result_odd,\n    input  bist_pattern\n  );\n\nendinterface\n\n//********************************************************\n//****************** BRAM PORT BUS ***********************\n//********************************************************\n\ninterface BRAM_PORT;\n\n  logic        clk;\n  logic        rst;\n  logic        en;\n  logic  [7:0] we;\n  logic [14:0] addr;\n  logic [63:0] din;\n  logic [63:0] dout;\n\n  modport Master (\n    output clk,\n    output rst,\n    output en,\n    output we,\n    output addr,\n    output din,\n    input  dout\n  );\n\n  modport Slave (\n    input  clk,\n    input  rst,\n    input  en,\n    input  we,\n    input  addr,\n    input  din,\n    output dout\n  );\n\nendinterface\n\n//********************************************************\n//************* SP ICACHE CTRL UNIT BUS ******************\n//********************************************************\n\ninterface SP_ICACHE_CTRL_UNIT_BUS;\n\n  // ICACHE_CTRL UNIT INTERFACE\n  //***************************************\n  logic        ctrl_req_enable;\n  logic        ctrl_ack_enable;\n  logic        ctrl_req_disable;\n  logic        ctrl_ack_disable;\n  logic        ctrl_pending_trans;\n  logic        flush_req;\n  logic        flush_ack;\n  logic        icache_is_private;\n`ifdef FEATURE_ICACHE_STAT\n  logic [31:0] ctrl_hit_count;\n  logic [31:0] ctrl_trans_count;\n  logic [31:0] ctrl_miss_count;\n  logic        ctrl_clear_regs;\n  logic        ctrl_enable_regs;\n`endif\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output ctrl_req_enable,\n    output ctrl_req_disable,\n    output flush_req,\n    output icache_is_private,\n    input  flush_ack,\n\n    input  ctrl_ack_enable,\n    input  ctrl_ack_disable,\n    input  ctrl_pending_trans\n`ifdef FEATURE_ICACHE_STAT\n    ,\n    input  ctrl_hit_count,\n    input  ctrl_trans_count,\n    input  ctrl_miss_count,\n    output ctrl_clear_regs,\n    output ctrl_enable_regs\n`endif\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  ctrl_req_enable,\n    input  ctrl_req_disable,\n    input  flush_req,\n    input  icache_is_private,\n    output flush_ack,\n\n    output ctrl_ack_enable,\n    output ctrl_ack_disable,\n    output ctrl_pending_trans\n`ifdef FEATURE_ICACHE_STAT\n    ,\n    output ctrl_hit_count,\n    output ctrl_trans_count,\n    output ctrl_miss_count,\n    input  ctrl_clear_regs,\n    input  ctrl_enable_regs\n`endif\n  );\n\nendinterface\n\n//********************************************************\n//************* MP ICACHE CTRL UNIT BUS ******************\n//********************************************************\n\ninterface MP_ICACHE_CTRL_UNIT_BUS;\n\n  // ICACHE_CTRL UNIT INTERFACE\n  //***************************************\n  logic                       bypass_req;\n  logic         [`NB_CORES:0] bypass_ack; // NB_CORES + 1\n  logic                       flush_req;\n  logic                       flush_ack;\n\n  logic                       sel_flush_req;\n  logic                [31:0] sel_flush_addr;\n  logic                       sel_flush_ack;\n`ifdef FEATURE_ICACHE_STAT\n  logic                [31:0] global_hit_count;\n  logic                [31:0] global_trans_count;\n  logic                [31:0] global_miss_count;\n\n  logic [`NB_CORES-1:0][31:0] bank_hit_count;\n  logic [`NB_CORES-1:0][31:0] bank_trans_count;\n  logic [`NB_CORES-1:0][31:0] bank_miss_count;\n\n  logic                       ctrl_clear_regs;\n  logic                       ctrl_enable_regs;\n`endif\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output bypass_req,\n    output flush_req,\n    input  bypass_ack,\n    input  flush_ack,\n\n    output sel_flush_req,\n    output sel_flush_addr,\n    input  sel_flush_ack\n`ifdef FEATURE_ICACHE_STAT\n    ,\n    input  global_hit_count,\n    input  global_trans_count,\n    input  global_miss_count,\n\n    input  bank_hit_count,\n    input  bank_trans_count,\n    input  bank_miss_count,\n\n    output ctrl_clear_regs,\n    output ctrl_enable_regs\n`endif\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  bypass_req,\n    input  flush_req,\n    output bypass_ack,\n    output flush_ack,\n\n    input  sel_flush_req,\n    input  sel_flush_addr,\n    output sel_flush_ack\n`ifdef FEATURE_ICACHE_STAT\n    ,\n    output global_hit_count,\n    output global_trans_count,\n    output global_miss_count,\n\n    output bank_hit_count,\n    output bank_trans_count,\n    output bank_miss_count,\n\n    input  ctrl_clear_regs,\n    input  ctrl_enable_regs\n`endif\n  );\n\nendinterface\n\n//********************************************************\n//************ MP PF ICACHE CTRL UNIT BUS ****************\n//********************************************************\n\ninterface MP_PF_ICACHE_CTRL_UNIT_BUS;\n\n  // ICACHE_CTRL UNIT INTERFACE\n  //***************************************\n  logic                       bypass_req;\n  logic         [`NB_CORES:0] bypass_ack; // NB_CORES + 1\n  logic                       flush_req;\n  logic                       flush_ack;\n\n  logic                       sel_flush_req;\n  logic                [31:0] sel_flush_addr;\n  logic                       sel_flush_ack;\n\n  logic                [31:0] pf_addr;\n  logic                 [7:0] pf_size;\n  logic                       pf_req;\n  logic                       pf_ack;\n  logic                       pf_done;\n`ifdef FEATURE_ICACHE_STAT\n  logic                [31:0] global_hit_count;\n  logic                [31:0] global_trans_count;\n  logic                [31:0] global_miss_count;\n\n  logic [`NB_CORES-1:0][31:0] bank_hit_count;\n  logic [`NB_CORES-1:0][31:0] bank_trans_count;\n  logic [`NB_CORES-1:0][31:0] bank_miss_count;\n\n  logic                       ctrl_clear_regs;\n  logic                       ctrl_enable_regs;\n`endif\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output bypass_req,\n    output flush_req,\n    input  bypass_ack,\n    input  flush_ack,\n\n    output sel_flush_req,\n    output sel_flush_addr,\n    input  sel_flush_ack,\n\n    output pf_addr, pf_size, pf_req,\n    input  pf_ack,  pf_done\n  `ifdef FEATURE_ICACHE_STAT\n    ,\n    input  global_hit_count,\n    input  global_trans_count,\n    input  global_miss_count,\n\n    input  bank_hit_count,\n    input  bank_trans_count,\n    input  bank_miss_count,\n\n    output ctrl_clear_regs,\n    output ctrl_enable_regs\n  `endif\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  bypass_req,\n    input  flush_req,\n    output bypass_ack,\n    output flush_ack,\n\n    input  sel_flush_req,\n    input  sel_flush_addr,\n    output sel_flush_ack,\n\n    input  pf_addr, pf_size, pf_req,\n    output pf_ack,  pf_done\n`ifdef FEATURE_ICACHE_STAT\n    ,\n    output global_hit_count,\n    output global_trans_count,\n    output global_miss_count,\n\n    output bank_hit_count,\n    output bank_trans_count,\n    output bank_miss_count,\n\n    input  ctrl_clear_regs,\n    input  ctrl_enable_regs\n`endif\n  );\n\nendinterface\n\n//********************************************************\n//************* PRI ICACHE CTRL UNIT BUS *****************\n//********************************************************\n\ninterface PRI_ICACHE_CTRL_UNIT_BUS;\n\n  // ICACHE_CTRL UNIT INTERFACE\n  //***************************************\n  logic        bypass_req;\n  logic        bypass_ack;\n  logic        flush_req;\n  logic        flush_ack;\n`ifdef FEATURE_ICACHE_STAT\n  logic [31:0] ctrl_hit_count;\n  logic [31:0] ctrl_trans_count;\n  logic [31:0] ctrl_miss_count;\n  logic        ctrl_clear_regs;\n  logic        ctrl_enable_regs;\n`endif\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output bypass_req,\n    output flush_req,\n    input  bypass_ack,\n    input  flush_ack\n`ifdef FEATURE_ICACHE_STAT\n    ,\n    input  ctrl_hit_count,\n    input  ctrl_trans_count,\n    input  ctrl_miss_count,\n    output ctrl_clear_regs,\n    output ctrl_enable_regs\n`endif\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  bypass_req,\n    input  flush_req,\n    output bypass_ack,\n    output flush_ack\n`ifdef FEATURE_ICACHE_STAT\n    ,\n    output ctrl_hit_count,\n    output ctrl_trans_count,\n    output ctrl_miss_count,\n    input  ctrl_clear_regs,\n    input  ctrl_enable_regs\n`endif\n  );\n\nendinterface\n\n//********************************************************\n//****************** L0 CTRL UNIT BUS ********************\n//********************************************************\n\ninterface L0_CTRL_UNIT_BUS;\n\n  // L0_CTRL_UNIT INTERFACE\n  //***************************************\n  logic        flush_FetchBuffer;\n  logic        flush_ack;\n//`ifdef FEATURE_ICACHE_STAT\n  logic [31:0] ctrl_stall_count;\n//`endif\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    input  ctrl_stall_count,\n    output flush_FetchBuffer,\n    input  flush_ack\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    output ctrl_stall_count,\n    input  flush_FetchBuffer,\n    output flush_ack\n  );\n\nendinterface\n\n//********************************************************\n//*********************** APB BUS ************************\n//********************************************************\n\ninterface APB_BUS\n#(\n  parameter APB_ADDR_WIDTH = 32,\n  parameter APB_DATA_WIDTH = 32\n);\n\n  logic [APB_ADDR_WIDTH-1:0] paddr;\n  logic [APB_DATA_WIDTH-1:0] pwdata;\n  logic                      pwrite;\n  logic                      psel;\n  logic                      penable;\n  logic [APB_DATA_WIDTH-1:0] prdata;\n  logic                      pready;\n  logic                      pslverr;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output paddr,\n    output pwdata,\n    output pwrite,\n    output psel,\n    output penable,\n    input  prdata,\n    input  pready,\n    input  pslverr\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  paddr,\n    input  pwdata,\n    input  pwrite,\n    input  psel,\n    input  penable,\n    output prdata,\n    output pready,\n    output pslverr\n  );\n\nendinterface\n\n//********************************************************\n//*********************** FLL BUS ************************\n//********************************************************\n\ninterface FLL_BUS\n#(\n  parameter FLL_ADDR_WIDTH = 2,\n  parameter FLL_DATA_WIDTH = 32\n);\n\n  logic                      req;\n  logic                      wrn;\n  logic [FLL_ADDR_WIDTH-1:0] add;\n  logic [FLL_DATA_WIDTH-1:0] data;\n  logic                      ack;\n  logic [FLL_DATA_WIDTH-1:0] r_data;\n  logic                      lock;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output req,\n    output wrn,\n    output add,\n    output data,\n    input  ack,\n    input  r_data,\n    input  lock\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input  req,\n    input  wrn,\n    input  add,\n    input  data,\n    output ack,\n    output r_data,\n    output lock\n  );\n\nendinterface\n\n//**********************************************************\n//**************** CORE PREF BUS ***************************\n//**********************************************************\n\ninterface CORE_PREF_BUS;\n\n  // REQUEST CHANNEL\n  //***************************************\n  logic        req;\n  logic [31:0] add;\n  logic        gnt;\n  logic        branch;\n\n  // RESPONSE CHANNEL\n  //***************************************\n  logic        r_ready;\n  logic [31:0] r_rdata;\n  logic        r_valid;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output req,\n    output add,\n    output r_ready,\n    output branch,\n    input gnt,\n    input r_rdata,\n    input r_valid\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input req,\n    input add,\n    input r_ready,\n    input branch,\n    output gnt,\n    output r_rdata,\n    output r_valid\n  );\n\nendinterface\n\n//**********************************************************\n//********************** MARX APU IF ***********************\n//**********************************************************\n\ninterface marx_apu_if\n#(\n  parameter WOP      = 1,\n  parameter NARGS    = 2,\n  parameter NUSFLAGS = 1,\n  parameter NDSFLAGS = 1,\n  parameter WAPUTAG  = 2,\n  parameter WRESULT  = 32,\n  parameter WARG     = 32\n);\n\n  // Downstream\n  //***************************************\n  logic                valid_ds_s;\n  logic                ready_ds_s;\n\n  logic     [WARG-1:0] operands_ds_d [NARGS-1:0];\n  logic      [WOP-1:0] op_ds_d;\n  logic [NDSFLAGS-1:0] flags_ds_d;\n  logic  [WAPUTAG-1:0] tag_ds_d;\n\n  // Upstream\n  //***************************************\n  logic                req_us_s;\n  logic                ack_us_s;\n\n  logic  [WRESULT-1:0] result_us_d;\n  logic [NUSFLAGS-1:0] flags_us_d;\n  logic  [WAPUTAG-1:0] tag_us_d;\n\n  // The interface from the APU's perspective.\n  //***************************************\n  modport apu\n  (\n    input  valid_ds_s,\n    input  operands_ds_d,\n    input  op_ds_d,\n    input  flags_ds_d,\n    input  tag_ds_d,\n    input  ack_us_s,\n    output ready_ds_s,\n    output req_us_s,\n    output result_us_d,\n    output flags_us_d,\n    output tag_us_d\n  );\n\n  // The interface from interconnect's perspective.\n  //***************************************\n  modport marx (\n    output valid_ds_s,\n    output operands_ds_d,\n    output op_ds_d,\n    output flags_ds_d,\n    output tag_ds_d,\n    output ack_us_s,\n    input  ready_ds_s,\n    input  req_us_s,\n    input  result_us_d,\n    input  flags_us_d,\n    input  tag_us_d\n  );\n\nendinterface\n\n//**********************************************************\n//********************* MARX ARBITER IF ********************\n//**********************************************************\n\ninterface marx_arbiter_if\n#(\n  parameter NIN  = -1, // number of request inputs\n  parameter NOUT = -1, // number of allocatable resources\n  parameter NIN2 = $clog2(NIN)\n);\n\n  // Allocation request handshake.\n  //***************************************\n  logic  [NIN-1:0] req_d;\n  logic  [NIN-1:0] ack_d;\n\n  // Index of the resource allocated.\n  //***************************************\n  logic            unsigned [NOUT-1:0][NIN2-1:0] assid_d;\n\n  // Resource handshake.\n  //***************************************\n  logic [NOUT-1:0] avail_d; // resource is ready to be allocated\n  logic [NOUT-1:0] alloc_d; // resource was allocated\n\n  //***************************************\n  modport arbiter\n  (\n    input  req_d,\n    input  avail_d,\n    output ack_d,\n    output assid_d,\n    output alloc_d\n  );\n\n  //***************************************\n  modport marx\n  (\n    output req_d,\n    output avail_d,\n    input  ack_d,\n    input  assid_d,\n    input  alloc_d\n  );\n\nendinterface\n\n//**********************************************************\n//*********************** CPU MARX IF **********************\n//**********************************************************\n\ninterface cpu_marx_if #(\n  parameter WOP_CPU      = 0,\n  parameter WAPUTYPE     = 0,\n  parameter NUSFLAGS_CPU = 1,\n  parameter NDSFLAGS_CPU = 1,\n  parameter WRESULT      = 32,\n  parameter WARG         = 32,\n  parameter NARGS_CPU    = 3\n);\n\n  // Downstream\n  //***************************************\n  logic                    req_ds_s;\n  logic                    ack_ds_s;\n\n  logic     [WAPUTYPE-1:0] type_ds_d;\n\n  logic         [WARG-1:0] operands_ds_d [NARGS_CPU-1:0];\n  logic      [WOP_CPU-1:0] op_ds_d;\n  logic [NDSFLAGS_CPU-1:0] flags_ds_d;\n\n  // Upstream\n  //***************************************\n  logic                    valid_us_s;\n  logic                    ready_us_s;\n\n  logic      [WRESULT-1:0] result_us_d;\n  logic [NUSFLAGS_CPU-1:0] flags_us_d;\n\n  // The interface from the Core's perspective.\n  //***************************************\n  modport cpu\n  (\n    output req_ds_s,\n    output type_ds_d,\n    output operands_ds_d,\n    output op_ds_d,\n    output flags_ds_d,\n    output ready_us_s,\n    input  ack_ds_s,\n    input  valid_us_s,\n    input  result_us_d,\n    input  flags_us_d\n  );\n\n  // The interface from the interconnect's perspective.\n  //***************************************\n  modport marx\n  (\n    input  req_ds_s,\n    input  type_ds_d,\n    input  operands_ds_d,\n    input  op_ds_d,\n    input  ready_us_s,\n    input  flags_ds_d,\n    output ack_ds_s,\n    output valid_us_s,\n    output result_us_d,\n    output flags_us_d\n  );\n\nendinterface\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"pulp_soc_defines.sv\"\n\nmodule pulp_soc\n\n// Parameters {{{\n#(\n  parameter AXI_EXT_ADDR_WIDTH     = `AXI_EXT_ADDR_WIDTH,\n  parameter AXI_ADDR_WIDTH         = 32,\n  parameter AXI_DATA_WIDTH         = 64,\n  parameter AXI_STRB_WIDTH         = AXI_DATA_WIDTH/8,\n  parameter AXI_USER_WIDTH         = 6,\n\n  parameter AXI_LITE_ADDR_WIDTH    = 16,\n  parameter AXI_LITE_DATA_WIDTH    = `AXI_LITE_DATA_WIDTH,\n\n  parameter AXI_ID_EXT_S_WIDTH     = `AXI_ID_EXT_S_WIDTH,\n  parameter AXI_ID_EXT_S_ACP_WIDTH = `AXI_ID_EXT_S_ACP_WIDTH,\n  parameter AXI_ID_EXT_M_WIDTH     = `AXI_ID_EXT_M_WIDTH,\n\n  parameter AXI_ID_SOC_S_WIDTH     = `AXI_ID_SOC_S_WIDTH,\n  parameter AXI_ID_SOC_M_WIDTH     = `AXI_ID_SOC_M_WIDTH,\n\n  parameter NB_CLUSTERS            = `NB_CLUSTERS,\n  parameter NB_CORES               = `NB_CORES,\n  parameter BUFFER_WIDTH           = 8,\n  parameter NB_L2_BANKS            = 4,\n  parameter L2_BANK_SIZE           = 8192, // in 64-bit words --> 256KB\n  parameter L2_MEM_ADDR_WIDTH      = $clog2(L2_BANK_SIZE * NB_L2_BANKS)\n)\n// }}}\n\n// Ports {{{\n(\n  input logic                               clk_cluster_i,        // Clock\n  input logic                               clk_soc_i,            // Clock\n  input logic                               clk_soc_non_gated_i,  // Clock\n\n  input logic                               rst_n,  // Asynchronous reset active low\n\n  input  logic                              test_mode_i,\n  input  logic                              mode_select_i,\n  input  logic            [NB_CLUSTERS-1:0] fetch_en_i,\n  output logic            [NB_CLUSTERS-1:0] eoc_o,\n  output logic            [NB_CLUSTERS-1:0] cluster_busy_o,\n\n  // uart\n  input  logic                              uart_rx_i,\n  output logic                              uart_tx_o,\n  output logic                              uart_rts_no,\n  output logic                              uart_dtr_no,\n  input  logic                              uart_cts_ni,\n  input  logic                              uart_dsr_ni,\n\n`ifdef JUNO\n  // stdout AXI port\n  output logic                              stdout_master_aw_valid,\n  output logic                              stdout_master_aw_lock,\n  input  logic                              stdout_master_aw_ready,\n  output logic                              stdout_master_ar_valid,\n  output logic                              stdout_master_ar_lock,\n  input  logic                              stdout_master_ar_ready,\n  output logic                              stdout_master_w_valid,\n  output logic                              stdout_master_w_last,\n  input  logic                              stdout_master_w_ready,\n  input  logic                              stdout_master_r_valid,\n  input  logic                              stdout_master_r_last,\n  output logic                              stdout_master_r_ready,\n  input  logic                              stdout_master_b_valid,\n  output logic                              stdout_master_b_ready,\n  output logic         [AXI_ADDR_WIDTH-1:0] stdout_master_aw_addr,\n  output logic                        [2:0] stdout_master_aw_prot,\n  output logic                        [3:0] stdout_master_aw_region,\n  output logic                        [7:0] stdout_master_aw_len,\n  output logic                        [2:0] stdout_master_aw_size,\n  output logic                        [1:0] stdout_master_aw_burst,\n  output logic                        [3:0] stdout_master_aw_cache,\n  output logic                        [3:0] stdout_master_aw_qos,\n  output logic                        [9:0] stdout_master_aw_id,\n  output logic         [AXI_USER_WIDTH-1:0] stdout_master_aw_user,\n  output logic         [AXI_ADDR_WIDTH-1:0] stdout_master_ar_addr,\n  output logic                        [2:0] stdout_master_ar_prot,\n  output logic                        [3:0] stdout_master_ar_region,\n  output logic                        [7:0] stdout_master_ar_len,\n  output logic                        [2:0] stdout_master_ar_size,\n  output logic                        [1:0] stdout_master_ar_burst,\n  output logic                        [3:0] stdout_master_ar_cache,\n  output logic                        [3:0] stdout_master_ar_qos,\n  output logic                        [9:0] stdout_master_ar_id,\n  output logic         [AXI_USER_WIDTH-1:0] stdout_master_ar_user,\n  output logic         [AXI_DATA_WIDTH-1:0] stdout_master_w_data,\n  output logic         [AXI_STRB_WIDTH-1:0] stdout_master_w_strb,\n  output logic         [AXI_USER_WIDTH-1:0] stdout_master_w_user,\n  input  logic         [AXI_DATA_WIDTH-1:0] stdout_master_r_data,\n  input  logic                        [1:0] stdout_master_r_resp,\n  input  logic                        [9:0] stdout_master_r_id,\n  input  logic         [AXI_USER_WIDTH-1:0] stdout_master_r_user,\n  input  logic                        [1:0] stdout_master_b_resp,\n  input  logic                        [9:0] stdout_master_b_id,\n  input  logic         [AXI_USER_WIDTH-1:0] stdout_master_b_user,\n`endif // JUNO\n\n  // Host -> RAB\n  input  logic                              rab_slave_aw_valid,\n  input  logic         [AXI_ADDR_WIDTH-1:0] rab_slave_aw_addr,\n  input  logic                        [2:0] rab_slave_aw_prot,\n  input  logic                        [3:0] rab_slave_aw_region,\n  input  logic                        [7:0] rab_slave_aw_len,\n  input  logic                        [2:0] rab_slave_aw_size,\n  input  logic                        [1:0] rab_slave_aw_burst,\n  input  logic                              rab_slave_aw_lock,\n  input  logic                        [3:0] rab_slave_aw_cache,\n  input  logic                        [3:0] rab_slave_aw_qos,\n  input  logic     [AXI_ID_EXT_M_WIDTH-1:0] rab_slave_aw_id,\n  input  logic         [AXI_USER_WIDTH-1:0] rab_slave_aw_user,\n  output logic                              rab_slave_aw_ready,\n  input  logic                              rab_slave_ar_valid,\n  input  logic         [AXI_ADDR_WIDTH-1:0] rab_slave_ar_addr,\n  input  logic                        [2:0] rab_slave_ar_prot,\n  input  logic                        [3:0] rab_slave_ar_region,\n  input  logic                        [7:0] rab_slave_ar_len,\n  input  logic                        [2:0] rab_slave_ar_size,\n  input  logic                        [1:0] rab_slave_ar_burst,\n  input  logic                              rab_slave_ar_lock,\n  input  logic                        [3:0] rab_slave_ar_cache,\n  input  logic                        [3:0] rab_slave_ar_qos,\n  input  logic     [AXI_ID_EXT_M_WIDTH-1:0] rab_slave_ar_id,\n  input  logic         [AXI_USER_WIDTH-1:0] rab_slave_ar_user,\n  output logic                              rab_slave_ar_ready,\n  input  logic                              rab_slave_w_valid,\n  input  logic         [AXI_DATA_WIDTH-1:0] rab_slave_w_data,\n  input  logic         [AXI_STRB_WIDTH-1:0] rab_slave_w_strb,\n  input  logic         [AXI_USER_WIDTH-1:0] rab_slave_w_user,\n  input  logic                              rab_slave_w_last,\n  output logic                              rab_slave_w_ready,\n  output logic                              rab_slave_r_valid,\n  output logic         [AXI_DATA_WIDTH-1:0] rab_slave_r_data,\n  output logic                        [1:0] rab_slave_r_resp,\n  output logic                              rab_slave_r_last,\n  output logic     [AXI_ID_EXT_M_WIDTH-1:0] rab_slave_r_id,\n  output logic         [AXI_USER_WIDTH-1:0] rab_slave_r_user,\n  input  logic                              rab_slave_r_ready,\n  output logic                              rab_slave_b_valid,\n  output logic                        [1:0] rab_slave_b_resp,\n  output logic     [AXI_ID_EXT_M_WIDTH-1:0] rab_slave_b_id,\n  output logic         [AXI_USER_WIDTH-1:0] rab_slave_b_user,\n  input  logic                              rab_slave_b_ready,\n\n  // RAB -> Host\n  output logic                              rab_master_aw_valid,\n  output logic     [AXI_EXT_ADDR_WIDTH-1:0] rab_master_aw_addr,\n  output logic                        [2:0] rab_master_aw_prot,\n  output logic                        [3:0] rab_master_aw_region,\n  output logic                        [7:0] rab_master_aw_len,\n  output logic                        [2:0] rab_master_aw_size,\n  output logic                        [1:0] rab_master_aw_burst,\n  output logic                              rab_master_aw_lock,\n  output logic                        [3:0] rab_master_aw_cache,\n  output logic                        [3:0] rab_master_aw_qos,\n  output logic     [AXI_ID_EXT_S_WIDTH-1:0] rab_master_aw_id,\n  output logic         [AXI_USER_WIDTH-1:0] rab_master_aw_user,\n  input  logic                              rab_master_aw_ready,\n  output logic                              rab_master_ar_valid,\n  output logic     [AXI_EXT_ADDR_WIDTH-1:0] rab_master_ar_addr,\n  output logic                        [2:0] rab_master_ar_prot,\n  output logic                        [3:0] rab_master_ar_region,\n  output logic                        [7:0] rab_master_ar_len,\n  output logic                        [2:0] rab_master_ar_size,\n  output logic                        [1:0] rab_master_ar_burst,\n  output logic                              rab_master_ar_lock,\n  output logic                        [3:0] rab_master_ar_cache,\n  output logic                        [3:0] rab_master_ar_qos,\n  output logic     [AXI_ID_EXT_S_WIDTH-1:0] rab_master_ar_id,\n  output logic         [AXI_USER_WIDTH-1:0] rab_master_ar_user,\n  input  logic                              rab_master_ar_ready,\n  output logic                              rab_master_w_valid,\n  output logic         [AXI_DATA_WIDTH-1:0] rab_master_w_data,\n  output logic         [AXI_STRB_WIDTH-1:0] rab_master_w_strb,\n  output logic         [AXI_USER_WIDTH-1:0] rab_master_w_user,\n  output logic                              rab_master_w_last,\n  input  logic                              rab_master_w_ready,\n  input  logic                              rab_master_r_valid,\n  input  logic         [AXI_DATA_WIDTH-1:0] rab_master_r_data,\n  input  logic                        [1:0] rab_master_r_resp,\n  input  logic                              rab_master_r_last,\n  input  logic     [AXI_ID_EXT_S_WIDTH-1:0] rab_master_r_id,\n  input  logic         [AXI_USER_WIDTH-1:0] rab_master_r_user,\n  output logic                              rab_master_r_ready,\n  input  logic                              rab_master_b_valid,\n  input  logic                        [1:0] rab_master_b_resp,\n  input  logic     [AXI_ID_EXT_S_WIDTH-1:0] rab_master_b_id,\n  input  logic         [AXI_USER_WIDTH-1:0] rab_master_b_user,\n  output logic                              rab_master_b_ready,\n\n`ifdef EN_ACP\n  // RAB -> Host (ACP)\n  output logic                              rab_acp_aw_valid,\n  output logic     [AXI_EXT_ADDR_WIDTH-1:0] rab_acp_aw_addr,\n  output logic                        [2:0] rab_acp_aw_prot,\n  output logic                        [3:0] rab_acp_aw_region,\n  output logic                        [7:0] rab_acp_aw_len,\n  output logic                        [2:0] rab_acp_aw_size,\n  output logic                        [1:0] rab_acp_aw_burst,\n  output logic                              rab_acp_aw_lock,\n  output logic                        [3:0] rab_acp_aw_cache,\n  output logic                        [3:0] rab_acp_aw_qos,\n  output logic [AXI_ID_EXT_S_ACP_WIDTH-1:0] rab_acp_aw_id,\n  output logic         [AXI_USER_WIDTH-1:0] rab_acp_aw_user,\n  input  logic                              rab_acp_aw_ready,\n  output logic                              rab_acp_ar_valid,\n  output logic     [AXI_EXT_ADDR_WIDTH-1:0] rab_acp_ar_addr,\n  output logic                        [2:0] rab_acp_ar_prot,\n  output logic                        [3:0] rab_acp_ar_region,\n  output logic                        [7:0] rab_acp_ar_len,\n  output logic                        [2:0] rab_acp_ar_size,\n  output logic                        [1:0] rab_acp_ar_burst,\n  output logic                              rab_acp_ar_lock,\n  output logic                        [3:0] rab_acp_ar_cache,\n  output logic                        [3:0] rab_acp_ar_qos,\n  output logic [AXI_ID_EXT_S_ACP_WIDTH-1:0] rab_acp_ar_id,\n  output logic         [AXI_USER_WIDTH-1:0] rab_acp_ar_user,\n  input  logic                              rab_acp_ar_ready,\n  output logic                              rab_acp_w_valid,\n  output logic         [AXI_DATA_WIDTH-1:0] rab_acp_w_data,\n  output logic         [AXI_STRB_WIDTH-1:0] rab_acp_w_strb,\n  output logic         [AXI_USER_WIDTH-1:0] rab_acp_w_user,\n  output logic                              rab_acp_w_last,\n  input  logic                              rab_acp_w_ready,\n  input  logic                              rab_acp_r_valid,\n  input  logic         [AXI_DATA_WIDTH-1:0] rab_acp_r_data,\n  input  logic                        [1:0] rab_acp_r_resp,\n  input  logic                              rab_acp_r_last,\n  input  logic [AXI_ID_EXT_S_ACP_WIDTH-1:0] rab_acp_r_id,\n  input  logic         [AXI_USER_WIDTH-1:0] rab_acp_r_user,\n  output logic                              rab_acp_r_ready,\n  input  logic                              rab_acp_b_valid,\n  input  logic                        [1:0] rab_acp_b_resp,\n  input  logic [AXI_ID_EXT_S_ACP_WIDTH-1:0] rab_acp_b_id,\n  input  logic         [AXI_USER_WIDTH-1:0] rab_acp_b_user,\n  output logic                              rab_acp_b_ready,\n`endif\n\n  // Host -> RAB config\n  input  logic    [AXI_LITE_ADDR_WIDTH-1:0] rab_lite_aw_addr,\n  input  logic                              rab_lite_aw_valid,\n  output logic                              rab_lite_aw_ready,\n  input  logic    [AXI_LITE_DATA_WIDTH-1:0] rab_lite_w_data,\n  input  logic  [AXI_LITE_DATA_WIDTH/8-1:0] rab_lite_w_strb,\n  input  logic                              rab_lite_w_valid,\n  output logic                              rab_lite_w_ready,\n  output logic                        [1:0] rab_lite_b_resp,\n  output logic                              rab_lite_b_valid,\n  input  logic                              rab_lite_b_ready,\n  input  logic    [AXI_LITE_ADDR_WIDTH-1:0] rab_lite_ar_addr,\n  input  logic                              rab_lite_ar_valid,\n  output logic                              rab_lite_ar_ready,\n  output logic    [AXI_LITE_DATA_WIDTH-1:0] rab_lite_r_data,\n  output logic                        [1:0] rab_lite_r_resp,\n  output logic                              rab_lite_r_valid,\n  input  logic                              rab_lite_r_ready,\n\n`ifdef RAB_AX_LOG_EN\n  // Host -> RAB Memory Logs\n  input  logic                              RabArBramClk_CI,\n  input  logic                              RabArBramRst_RI,\n  input  logic                              RabArBramEn_SI,\n  input  logic                     [32-1:0] RabArBramAddr_SI,\n  output logic                     [32-1:0] RabArBramRd_DO,\n  input  logic                     [32-1:0] RabArBramWr_DI,\n  input  logic                     [ 4-1:0] RabArBramWrEn_SI,\n  input  logic                              RabAwBramClk_CI,\n  input  logic                              RabAwBramRst_RI,\n  input  logic                              RabAwBramEn_SI,\n  input  logic                     [32-1:0] RabAwBramAddr_SI,\n  output logic                     [32-1:0] RabAwBramRd_DO,\n  input  logic                     [32-1:0] RabAwBramWr_DI,\n  input  logic                     [ 4-1:0] RabAwBramWrEn_SI,\n\n  // RAB Logger Control\n  input  logic                              RabLogEn_SI,\n  input  logic                              RabArLogClr_SI,\n  input  logic                              RabAwLogClr_SI,\n  output logic                              RabArLogRdy_SO,\n  output logic                              RabAwLogRdy_SO,\n`endif\n\n  // interrupts\n`ifdef RAB_AX_LOG_EN\n  output logic                              intr_rab_ar_log_full_o,\n  output logic                              intr_rab_aw_log_full_o,\n`endif\n  output logic                              intr_mailbox_o,\n  output logic                              intr_rab_miss_o,\n  output logic                              intr_rab_multi_o,\n  output logic                              intr_rab_prot_o,\n  output logic                              intr_rab_mhf_full_o\n\n);\n// }}}\n\n  localparam EVNT_WIDTH = 8;\n\n  logic                                     rstn_soc_sync;\n  logic                                     rstn_cluster_sync;\n  logic [NB_CLUSTERS-1:0][BUFFER_WIDTH-1:0] cluster_events_wt;\n  logic [NB_CLUSTERS-1:0][BUFFER_WIDTH-1:0] cluster_events_rp;\n  logic [NB_CLUSTERS-1:0][BUFFER_WIDTH-1:0] cluster_events_da;\n\n  // Interface Declarations {{{\n  // Host -> RAB\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_EXT_M_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     )\n  ) s_rab_slave();\n\n  // RAB -> Host\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_EXT_ADDR_WIDTH ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_EXT_S_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     )\n  ) s_rab_master();\n\n`ifdef RAB_AX_LOG_EN\n  // Host -> RAB Memory Logs\n  BramPort #(\n    .DATA_BITW  ( 32                    ),\n    .ADDR_BITW  ( `RAB_AX_LOG_ADDR_BITW )\n  ) RabArBram_PS();\n  BramPort #(\n    .DATA_BITW  ( 32                    ),\n    .ADDR_BITW  ( `RAB_AX_LOG_ADDR_BITW )\n  ) RabAwBram_PS();\n`endif\n\n`ifdef EN_ACP\n  // RAB -> Host (ACP)\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_EXT_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH         ),\n    .AXI_ID_WIDTH   ( AXI_ID_EXT_S_ACP_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH         )\n  ) s_rab_acp();\n`endif\n\n  // Host -> RAB config\n  AXI_LITE #(\n    .AXI_ADDR_WIDTH ( AXI_LITE_ADDR_WIDTH ),\n    .AXI_DATA_WIDTH ( AXI_LITE_DATA_WIDTH )\n  ) s_rab_lite_from_host();\n\n  // Crossbar -> RAB Config Port\n  AXI_LITE #(\n    .AXI_ADDR_WIDTH ( AXI_LITE_ADDR_WIDTH ),\n    .AXI_DATA_WIDTH ( AXI_LITE_DATA_WIDTH )\n  ) s_rab_lite();\n\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_M_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     )\n  ) soc_bus_to_apb();\n\n  // DC-FIFO -> SoC-Bus\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH      ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH      ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_S_WIDTH  ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH      )\n  ) s_data_master_bus[NB_CLUSTERS]();\n\n  // Cluster -> DC-FIFO\n  AXI_BUS_ASYNC #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_S_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     ),\n    .BUFFER_WIDTH   ( BUFFER_WIDTH       )\n  ) s_data_master_bus_async[NB_CLUSTERS]();\n\n  // SoC-Bus -> ID Remapper\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH      ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH      ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_M_WIDTH  ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH      )\n  ) s_data_slave_bus[NB_CLUSTERS]();\n\n  // ID Remapper -> DC-FIFO\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH   ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH   ),\n    .AXI_ID_WIDTH   ( 4                ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH   )\n  ) s_data_slave_bus_id_remapped[NB_CLUSTERS]();\n\n  // DC-FIFO -> Cluster\n  AXI_BUS_ASYNC #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( 4                  ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     ),\n    .BUFFER_WIDTH "}
{"text": "  ( BUFFER_WIDTH       )\n  ) s_data_slave_bus_async[NB_CLUSTERS]();\n\n  //AXI BUS FROM SOC_BUS to L2\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_M_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     )\n  ) s_soc_l2_bus();\n\n  // AXI BUS From SOCBUS to RAB\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_M_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     )\n  ) s_socbus_to_rab();\n\n  // AXI BUS From SOCBUS to Converter for RAB Config Port\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_M_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     )\n  ) s_socbus_to_rab_cfg();\n\n  // AXILite BUS From Converter to RAB Config Port Crossbar\n  AXI_LITE #(\n    .AXI_ADDR_WIDTH ( AXI_LITE_ADDR_WIDTH ),\n    .AXI_DATA_WIDTH ( AXI_LITE_DATA_WIDTH )\n  ) s_socbus_to_rab_cfg_conv();\n\n  // AXI BUS From RAB to SOCBUS\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_S_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     )\n  ) s_rab_to_socbus();\n\n  // AXI BUS From SOCBUS to Mailbox\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_M_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     )\n  ) s_socbus_to_mailbox();\n\n`ifdef JUNO\n  // AXI STDOUT\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_M_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     )\n  ) stdout_master();\n`endif // JUNO\n\n  // Interfavce between L2_ram_IF and BRAM\n  UNICAD_MEM_BUS_64 s_soc_l2_mem();\n\n  // }}}\n\n  genvar i,j;\n  generate\n\n  // AXI_RAB {{{\n  //  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557        \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2551        \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551        \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551        \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n  // \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u255d \u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n  // \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d\n  axi_rab_wrap #(\n    .AXI_EXT_ADDR_WIDTH     ( AXI_EXT_ADDR_WIDTH     ),\n    .AXI_INT_ADDR_WIDTH     ( AXI_ADDR_WIDTH         ),\n    .AXI_DATA_WIDTH         ( AXI_DATA_WIDTH         ),\n    .AXI_USER_WIDTH         ( AXI_USER_WIDTH         ),\n    .AXI_LITE_ADDR_WIDTH    ( AXI_LITE_ADDR_WIDTH    ),\n    .AXI_LITE_DATA_WIDTH    ( AXI_LITE_DATA_WIDTH    ),\n    .AXI_ID_EXT_S_WIDTH     ( AXI_ID_EXT_S_WIDTH     ),\n    .AXI_ID_EXT_S_ACP_WIDTH ( AXI_ID_EXT_S_ACP_WIDTH ),\n    .AXI_ID_EXT_M_WIDTH     ( AXI_ID_EXT_M_WIDTH     ),\n    .AXI_ID_SOC_S_WIDTH     ( AXI_ID_SOC_S_WIDTH     ),\n    .AXI_ID_SOC_M_WIDTH     ( AXI_ID_SOC_M_WIDTH     ),\n    .N_PORTS                ( `RAB_N_PORTS           ),\n    .N_L2_SETS              ( `RAB_L2_N_SETS         ),\n    .N_L2_SET_ENTRIES       ( `RAB_L2_N_SET_ENTRIES  )\n  ) axi_rab_wrap_i (\n    .clk_i              ( clk_soc_i              ),\n    .non_gated_clk_i    ( clk_soc_non_gated_i    ),\n    .rst_ni             ( rstn_soc_sync          ),\n\n    .rab_to_socbus      ( s_rab_to_socbus        ),\n    .socbus_to_rab      ( s_socbus_to_rab        ),\n\n    .rab_master         ( s_rab_master           ),\n\n`ifdef EN_ACP\n    .rab_acp            ( s_rab_acp              ),\n`endif\n\n    .rab_slave          ( s_rab_slave            ),\n\n    .rab_lite           ( s_rab_lite             ),\n\n`ifdef RAB_AX_LOG_EN\n    .ArBram_PS          ( RabArBram_PS           ),\n    .AwBram_PS          ( RabAwBram_PS           ),\n\n    .LogEn_SI           ( RabLogEn_SI            ),\n    .ArLogClr_SI        ( RabArLogClr_SI         ),\n    .AwLogClr_SI        ( RabAwLogClr_SI         ),\n    .ArLogRdy_SO        ( RabArLogRdy_SO         ),\n    .AwLogRdy_SO        ( RabAwLogRdy_SO         ),\n`endif\n\n`ifdef RAB_AX_LOG_EN\n    .intr_ar_log_full_o ( intr_rab_ar_log_full_o ),\n    .intr_aw_log_full_o ( intr_rab_aw_log_full_o ),\n`endif\n    .intr_miss_o        ( intr_rab_miss_o        ),\n    .intr_multi_o       ( intr_rab_multi_o       ),\n    .intr_prot_o        ( intr_rab_prot_o        ),\n    .intr_mhf_full_o    ( intr_rab_mhf_full_o    )\n  );\n  // }}}\n\n  // ULP Clusters {{{\n  //  \u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557     \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n  // \u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2551     \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\n  // \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\n  //  \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n  //\n  logic [NB_CLUSTERS-1:0] [5:0] CLUSTER_ID;\n  for(i=0;i<NB_CLUSTERS; i++)\n  begin : CLUSTER\n    assign CLUSTER_ID[i] = i;\n\n    pulp_cluster_wrap #(\n      // cluster parameters\n      .NB_CORES              ( `NB_CORES             ),\n\n      // AXI parameters\n      .AXI_ADDR_WIDTH        ( AXI_ADDR_WIDTH        ),\n      .AXI_DATA_C2S_WIDTH    ( AXI_DATA_WIDTH        ),\n      .AXI_DATA_S2C_WIDTH    ( AXI_DATA_WIDTH        ),\n      .AXI_USER_WIDTH        ( AXI_USER_WIDTH        ),\n      .AXI_ID_IN_WIDTH       ( 4                     ),\n      .AXI_ID_OUT_WIDTH      ( AXI_ID_SOC_S_WIDTH    ),\n      .AXI_STRB_C2S_WIDTH    ( AXI_STRB_WIDTH        ),\n      .AXI_STRB_S2C_WIDTH    ( AXI_STRB_WIDTH        ),\n      .DC_SLICE_BUFFER_WIDTH ( BUFFER_WIDTH          )\n    ) cluster_i (\n      .clk_i                    ( clk_cluster_i              ),\n      .rst_ni                   ( rstn_cluster_sync          ),\n      .ref_clk_i                ( clk_cluster_i              ),\n      .pmu_mem_pwdn_i           ( 1'b0                       ),\n\n      .base_addr_i              ( '0                         ), // not used\n\n      .test_mode_i              ( test_mode_i                ),\n\n      .en_sa_boot_i             ( mode_select_i              ),\n\n      .cluster_id_i             ( CLUSTER_ID[i]              ),\n\n      .fetch_en_i               ( fetch_en_i[i]              ),\n\n      .eoc_o                    ( eoc_o[i]                   ),\n\n      .busy_o                   ( cluster_busy_o[i]          ),\n\n      .ext_events_writetoken_i  ( cluster_events_wt[i]       ),\n      .ext_events_readpointer_o ( cluster_events_rp[i]       ),\n      .ext_events_dataasync_i   ( cluster_events_da[i]       ),\n\n      .dma_pe_evt_ack_i         ( 1'b1                       ),\n      .dma_pe_evt_valid_o       (                            ),\n\n      .dma_pe_irq_ack_i         ( 1'b1                       ),\n      .dma_pe_irq_valid_o       (                            ),\n\n      .pf_evt_ack_i             ( 1'b1                       ),\n      .pf_evt_valid_o           (                            ),\n\n      .data_master              ( s_data_master_bus_async[i] ),\n      .data_slave               ( s_data_slave_bus_async[i]  )\n    );\n  end\n  // }}}\n\n  // DC FIFOs {{{\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d        \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\n  // \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551             \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551   \u2588\u2588\u2551\n  // \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551             \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551   \u2588\u2588\u2551\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551     \u2588\u2588\u2551\u2588\u2588\u2551     \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n  // \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u255d      \u255a\u2550\u2550\u2550\u2550\u2550\u255d\n  for(i=0;i<NB_CLUSTERS; i++)\n  begin : DC_FIFO\n    axi_slice_dc_master_wrap #(\n      .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n      .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n      .AXI_ID_WIDTH   ( AXI_ID_SOC_S_WIDTH ),\n      .AXI_USER_WIDTH ( AXI_USER_WIDTH     ),\n      .BUFFER_WIDTH   ( BUFFER_WIDTH       )\n    ) dc_fifo_data_master_bus_i (\n      .clk_i           ( clk_soc_i                  ),\n      .rst_ni          ( rstn_soc_sync              ),\n      .test_cgbypass_i ( 1'b0                       ),\n      .isolate_i       ( 1'b0                       ),\n      .clock_down_i    ( 1'b0                       ),\n      .incoming_req_o  (                            ),\n      .axi_slave_async ( s_data_master_bus_async[i] ),\n      .axi_master      ( s_data_master_bus[i]       )\n    );\n\n    axi_slice_dc_slave_wrap #(\n      .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH    ),\n      .AXI_DATA_WIDTH ( AXI_DATA_WIDTH    ),\n      .AXI_ID_WIDTH   ( 4                 ),\n      .AXI_USER_WIDTH ( AXI_USER_WIDTH    ),\n      .BUFFER_WIDTH   ( BUFFER_WIDTH      )\n    ) dc_fifo_data_slave_bus_i (\n      .clk_i            ( clk_soc_i                       ),\n      .rst_ni           ( rstn_soc_sync                   ),\n      .test_cgbypass_i  ( 1'b0                            ),      \n      .isolate_i        ( 1'b0                            ),\n      .axi_slave        ( s_data_slave_bus_id_remapped[i] ), // FROM REMAPPER\n      .axi_master_async ( s_data_slave_bus_async[i]       )  // TO CLUSTER\n    );\n  end\n  // }}}\n\n  // L2 MEM {{{\n  // \u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2557         \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2551     \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557        \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\n  // \u2588\u2588\u2551      \u2588\u2588\u2588\u2588\u2588\u2554\u255d        \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\n  // \u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2550\u255d         \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\n  // \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d\n  axi_mem_if_wrap #(\n    .AXI_ADDRESS_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH    ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH      ( AXI_ID_SOC_M_WIDTH ),\n    .AXI_USER_WIDTH    ( AXI_USER_WIDTH     ),\n    .BUFF_DEPTH_SLAVE  ( 4                  )\n  ) l2_mem_if_i (\n    .clk_i      ( clk_soc_i     ),\n    .rst_ni     ( rstn_soc_sync ),\n    .test_en_i  ( test_mode_i   ),\n\n    .axi_slave  ( s_soc_l2_bus  ),\n    .mem_master ( s_soc_l2_mem  )\n  );\n\n  l2_mem #(\n    .MEM_ADDR_WIDTH ( L2_MEM_ADDR_WIDTH )\n  ) l2_mem_i (\n    .clk_i          ( clk_soc_i         ),\n    .rst_ni         ( rstn_soc_sync     ),\n    .test_en_i      ( test_mode_i       ),\n    .mem_slave      ( s_soc_l2_mem      )\n  );\n  // }}}\n\n  // AXI ID Remappers {{{\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d\n  // \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\n  // \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\n  for(i=0; i<NB_CLUSTERS; i++)\n  begin : ID_REMAPPER_CL\n    axi_id_remap_wrap #(\n      .AXI_ADDR_WIDTH   ( AXI_ADDR_WIDTH     ),\n      .AXI_DATA_WIDTH   ( AXI_DATA_WIDTH     ),\n      .AXI_USER_WIDTH   ( AXI_USER_WIDTH     ),\n      .AXI_ID_IN_WIDTH  ( AXI_ID_SOC_M_WIDTH ),\n      .AXI_ID_OUT_WIDTH ( 4                  ),\n      .AXI_ID_SLOT      ( 4                  )\n    ) i_axi_id_remap_wrap (\n      .clk_i      ( clk_soc_i                       ),\n      .rst_ni     ( rstn_soc_sync                   ),\n      .axi_slave  ( s_data_slave_bus[i]             ), //From SOCBUS\n      .axi_master ( s_data_slave_bus_id_remapped[i] )  //To DC_FIFO\n    );\n  end\n  // }}}\n\n  // Event distribution\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n  // \u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u255d  \u255a\u2588\u2588\u2557 \u2588\u2588\u2554\u255d\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551   \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u255a\u2588\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\n  // \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n  //just properly init the dc fifos, no events connected on SoC side\n  for(i=0;i<NB_CLUSTERS;i++)\n  begin :  EVENT_CLUSTER\n    dc_token_ring_fifo_din #(\n      .DATA_WIDTH   ( EVNT_WIDTH   ),\n      .BUFFER_DEPTH ( BUFFER_WIDTH )\n    ) u_event_dc (\n      .clk          ( clk_soc_i            ),\n      .rstn         ( rstn_soc_sync        ),\n      .data         ( '0                   ),\n      .valid        ( 1'b0                 ),\n      .ready        (                      ),\n      .write_token  ( cluster_events_wt[i] ),\n      .read_pointer ( cluster_events_rp[i] ),\n      .data_async   ( cluster_events_da[i] )\n    );\n  end\n  // }}}\n\n  endgenerate\n\n  // Clock and Reset Generators {{{\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d     \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557   \u2588\u2588\u2551        \u2588\u2588\u2551  \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551   \u2588\u2588\u2551        \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\n  // \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\n  // \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d   \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\n  //cluster rst is sync with the soc clock to proper reset the soc side of the dual clock fifos\n  rstgen i_rst_gen_cluster_soc (\n    // PAD FRAME SIGNALS\n    .clk_i       ( clk_soc_i     ),\n    .rst_ni      ( rst_n         ),\n\n    // TEST MODE\n    .test_mode_i ( test_mode_i   ),\n\n    // OUTPUT RESET\n    .rst_no      ( rstn_soc_sync ),\n    .init_no     (               ) //not used\n  );\n\n  //cluster rst is sync with the cluster clock\n  rstgen i_rst_gen_cluster (\n    // PAD FRAME SIGNALS\n    .clk_i      ( clk_cluster_i     ),\n    .rst_ni     ( rst_n             ),\n\n    // TEST MODE\n    .test_mode_i( test_mode_i       ),\n\n    // OUTPUT RES ET\n    .rst_no     ( rstn_cluster_sync ),\n    .init_no    (                   ) //not used\n  );\n  // }}}\n\n  // SoC Bus to RAB Configuration Port Converter {{{\n  socbus_to_rab_cfg_conv #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_M_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     )\n  ) i_socbus_to_rab_cfg_conv (\n    .Clk_CI      ( clk_soc_i                ),\n    .Rst_RBI     ( rstn_soc_sync            ),\n\n    .FromSoc_PS  ( s_socbus_to_rab_cfg      ),\n    .ToRabCfg_PM ( s_socbus_to_rab_cfg_conv )\n  );\n  // }}}\n\n  // AXI Lite Crossbar to connect Host and SoC Bus to RAB Configuration Port {{{\n  xilinx_axi_xbar_rab_cfg_wrap #(\n    .ADDR_BITW     ( AXI_ADDR_WIDTH           ),\n    .DATA_BITW     ( AXI_LITE_DATA_WIDTH      )\n  ) i_xilinx_axi_xbar_rab_cfg_wrap (\n    .Clk_CI        ( clk_soc_i                ),\n    .Rst_RBI       ( rstn_soc_sync            ),\n\n    .Slave0_PS     ( s_rab_lite_from_host     ),\n    .Slave1_PS     ( s_socbus_to_rab_cfg_conv ),\n    .Master_PM     ( s_rab_lite               )\n  );\n  // }}}\n\n  // SoC Bus {{{\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557        \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d        \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551             \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551             \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\n  // \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n  soc_bus_wrap #(\n    .AXI_ADDR_WIDTH   ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH   ( AXI_DATA_WIDTH     ),\n    .AXI_ID_IN_WIDTH  ( AXI_ID_SOC_S_WIDTH ),\n    .AXI_ID_OUT_WIDTH ( AXI_ID_SOC_M_WIDTH ),\n    .AXI_USER_WIDTH   ( AXI_USER_WIDTH     ),\n    .NB_CLUSTERS      ( NB_CLUSTERS        )\n  ) i_soc_bus_wrap (\n    .clk_i               ( clk_soc_i           ),\n    .rst_ni              ( rstn_soc_sync       ),\n    .test_en_i           ( test_mode_i         ),\n\n    //TARGET   --> AXI ID = 10bit\n    .cluster_data_slave  ( s_data_master_bus   ), // AXI_BUS.Slave\n    .cluster_data_master ( s_data_slave_bus    ), // AXI_BUS.Master\n    .soc_rab_slave       ( s_rab_to_socbus     ), // AXI_BUS.Slave\n    .soc_rab_master      ( s_socbus_to_rab     ), // AXI_BUS.Master\n    .soc_rab_cfg_master  ( s_socbus_to_rab_cfg ), // AXI_BUS.Master\n    .mailbox_master      ( s_socbus_to_mailbox ), // AXI_BUS.Master\n\n`ifdef JUNO\n    .soc_stdout_master   ( stdout_master       ), // AXI_BUS.Master\n`endif\n\n    .soc_l2_master       ( s_soc_l2_bus        ), // AXI_BUS.Master\n    .soc_apb_master      ( soc_bus_to_apb      )\n  );\n  // }}}\n\n  // Mailbox {{{\n  // \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\n  // \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\n  // \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d\n  // \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557\n  // \u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u255d \u2588\u2588\u2557\n  // \u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\n  xilinx_mailbox_wrap #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_M_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     )\n  ) xilinx_mailbox_wrap_i (\n    .Clk_CI     ( clk_soc_i           ),\n    .Rst_RBI    ( rstn_soc_sync       ),\n\n    .FromSoc_PS ( s_socbus_to_mailbox ),\n\n    .Irq0_SO    ( intr_mailbox_o      ),\n    .Irq1_SO    (                     )\n  );\n  // }}}\n\n  // SoC Peripherals (AXI 2 APB) {{{\n  //  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557\u2588\u2588\u2557        \u2588\u2588\u2588\u2588\u2588\u2588\u2557          \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d\u2588\u2588\u2551        \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2557        \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n  // \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d \u2588\u2588\u2551         \u2588\u2588\u2588\u2588\u2588\u2554\u255d        \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n  // \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551        \u2588\u2588\u2554\u2550\u2550\u2550\u255d         \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n  // \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u255d \u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n  // \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \u255a\u2550\u2550\u2550\u2550\u2550\u255d\n  soc_peripherals_multicluster #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH     ),\n    .AXI_ID_WIDTH   ( AXI_ID_SOC_M_WIDTH ),\n    .NB_CORES       ( NB_CORES           ),\n    .NB_CLUSTERS    ( NB_CLUSTERS        )\n  ) soc_registers (\n    .clk_i       ( clk_soc_i      ),\n    .rst_ni      ( rstn_soc_sync  ),\n\n    .test_mode_i ( test_mode_i    ),\n\n    .uart_rx_i   ( uart_rx_i      ),\n    .uart_tx_o   ( uart_tx_o      ),\n    .uart_rts_no ( uart_rts_no    ),\n    .uart_dtr_no ( uart_dtr_no    ),\n    .uart_cts_ni ( uart_cts_ni    ),\n    .uart_dsr_ni ( uart_dsr_ni    ),\n\n    // SLAVE PORTS\n    .axi_slave   ( soc_bus_to_apb )\n  );\n  // }}}\n\n  // Interface Bindings {{{\n  // \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588        \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n  // \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550        \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n  // \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557         \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\n  // \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d         \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\n  // \u2588\u2588\u2551\u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n  // \u255a\u2550\u255d\u255a\u2550\u255d    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d\n`ifdef JUNO\n  assign stdout_master_aw_valid  = stdout_master.aw_valid ;\n  assign stdout_master_aw_lock   = stdout_master.aw_lock  ;\n  assign stdout_master_ar_valid  = stdout_master.ar_valid ;\n  assign stdout_master_ar_lock   = stdout_master.ar_lock  ;\n  assign stdout_master_w_valid   = stdout_master.w_valid  ;\n  assign stdout_master_w_last    = stdout_master.w_last   ;\n  assign stdout_master_r_ready   = stdout_master.r_ready  ;\n  assign stdout_master_b_ready   = stdout_master.b_ready  ;\n  assign stdout_master_aw_addr   = stdout_master.aw_addr  ;\n  assign stdout_master_aw_prot   = stdout_master.aw_prot  ;\n  assign stdout_master_aw_region = stdout_master.aw_region;\n  assign stdout_master_aw_len    = stdout_master.aw_len   ;\n  assign stdout_master_aw_size   = stdout_master.aw_size  ;\n  assign stdout_master_aw_burst  = stdout_master.aw_burst ;\n  assign stdout_master_aw_cache  = stdout_master.aw_cache ;\n  assign stdout_master_aw_qos    = stdout_master.aw_qos   ;\n  assign stdout_master_aw_id     = stdout_master.aw_id    ;\n  assign stdout_master_aw_user   = stdout_master.aw_user  ;\n  assign stdout_master_ar_addr   = stdout_master.ar_addr  ;\n  assign stdout_master_ar_prot   = stdout_master.ar_prot  ;\n  assign stdout_master_ar_region = stdout_master.ar_region;\n  assign stdout_master_ar_len    = stdout_master.ar_len   ;\n  assign stdout_master_ar_size   = stdout_master.ar_size  ;\n  assign stdout_master_ar_burst  = stdout_master.ar_burst ;\n  assign stdout_master_ar_cache  = stdout_master.ar_cache ;\n  assign stdout_master_ar_qos    = stdout_master.ar_qos   ;\n  assign stdout_master_ar_id     = stdout_master.ar_id    ;\n  assign stdout_master_ar_user   = stdout_master.ar_user  ;\n  assign stdout_master_w_data    = stdout_master.w_data   ;\n  assign stdout_master_w_strb    = stdout_master.w_strb   ;\n  assign stdout_master_w_user    = stdout_master.w_user   ;\n  assign stdout_master.aw_ready  = stdout_master_aw_ready ;\n  assign stdout_master.ar_ready  = stdout_master_ar_read"}
{"text": "y ;\n  assign stdout_master.w_ready   = stdout_master_w_ready  ;\n  assign stdout_master.r_valid   = stdout_master_r_valid  ;\n  assign stdout_master.r_last    = stdout_master_r_last   ;\n  assign stdout_master.b_valid   = stdout_master_b_valid  ;\n  assign stdout_master.r_data    = stdout_master_r_data   ;\n  assign stdout_master.r_resp    = stdout_master_r_resp   ;\n  assign stdout_master.r_id      = stdout_master_r_id     ;\n  assign stdout_master.r_user    = stdout_master_r_user   ;\n  assign stdout_master.b_resp    = stdout_master_b_resp   ;\n  assign stdout_master.b_id      = stdout_master_b_id     ;\n  assign stdout_master.b_user    = stdout_master_b_user   ;\n`endif // JUNO\n\n  assign rab_master_aw_valid     = s_rab_master.aw_valid  ;\n  assign rab_master_aw_addr      = s_rab_master.aw_addr   ;\n  assign rab_master_aw_prot      = s_rab_master.aw_prot   ;\n  assign rab_master_aw_region    = s_rab_master.aw_region ;\n  assign rab_master_aw_len       = s_rab_master.aw_len    ;\n  assign rab_master_aw_size      = s_rab_master.aw_size   ;\n  assign rab_master_aw_burst     = s_rab_master.aw_burst  ;\n  assign rab_master_aw_lock      = s_rab_master.aw_lock   ;\n  assign rab_master_aw_cache     = s_rab_master.aw_cache  ;\n  assign rab_master_aw_qos       = s_rab_master.aw_qos    ;\n  assign rab_master_aw_id        = s_rab_master.aw_id     ;\n  assign rab_master_aw_user      = s_rab_master.aw_user   ;\n  assign s_rab_master.aw_ready   = rab_master_aw_ready    ;\n  assign rab_master_ar_valid     = s_rab_master.ar_valid  ;\n  assign rab_master_ar_addr      = s_rab_master.ar_addr   ;\n  assign rab_master_ar_prot      = s_rab_master.ar_prot   ;\n  assign rab_master_ar_region    = s_rab_master.ar_region ;\n  assign rab_master_ar_len       = s_rab_master.ar_len    ;\n  assign rab_master_ar_size      = s_rab_master.ar_size   ;\n  assign rab_master_ar_burst     = s_rab_master.ar_burst  ;\n  assign rab_master_ar_lock      = s_rab_master.ar_lock   ;\n  assign rab_master_ar_cache     = s_rab_master.ar_cache  ;\n  assign rab_master_ar_qos       = s_rab_master.ar_qos    ;\n  assign rab_master_ar_id        = s_rab_master.ar_id     ;\n  assign rab_master_ar_user      = s_rab_master.ar_user   ;\n  assign s_rab_master.ar_ready   = rab_master_ar_ready    ;\n  assign rab_master_w_valid      = s_rab_master.w_valid   ;\n  assign rab_master_w_data       = s_rab_master.w_data    ;\n  assign rab_master_w_strb       = s_rab_master.w_strb    ;\n  assign rab_master_w_user       = s_rab_master.w_user    ;\n  assign rab_master_w_last       = s_rab_master.w_last    ;\n  assign s_rab_master.w_ready    = rab_master_w_ready     ;\n  assign s_rab_master.r_valid    = rab_master_r_valid     ;\n  assign s_rab_master.r_data     = rab_master_r_data      ;\n  assign s_rab_master.r_resp     = rab_master_r_resp      ;\n  assign s_rab_master.r_last     = rab_master_r_last      ;\n  assign s_rab_master.r_id       = rab_master_r_id        ;\n  assign s_rab_master.r_user     = rab_master_r_user      ;\n  assign rab_master_r_ready      = s_rab_master.r_ready   ;\n  assign s_rab_master.b_valid    = rab_master_b_valid     ;\n  assign s_rab_master.b_resp     = rab_master_b_resp      ;\n  assign s_rab_master.b_id       = rab_master_b_id        ;\n  assign s_rab_master.b_user     = rab_master_b_user      ;\n  assign rab_master_b_ready      = s_rab_master.b_ready   ;\n\n`ifdef EN_ACP\n  assign rab_acp_aw_valid     = s_rab_acp.aw_valid  ;\n  assign rab_acp_aw_addr      = s_rab_acp.aw_addr   ;\n  assign rab_acp_aw_prot      = s_rab_acp.aw_prot   ;\n  assign rab_acp_aw_region    = s_rab_acp.aw_region ;\n  assign rab_acp_aw_len       = s_rab_acp.aw_len    ;\n  assign rab_acp_aw_size      = s_rab_acp.aw_size   ;\n  assign rab_acp_aw_burst     = s_rab_acp.aw_burst  ;\n  assign rab_acp_aw_lock      = s_rab_acp.aw_lock   ;\n  assign rab_acp_aw_cache     = s_rab_acp.aw_cache  ;\n  assign rab_acp_aw_qos       = s_rab_acp.aw_qos    ;\n  assign rab_acp_aw_id        = s_rab_acp.aw_id     ;\n  assign rab_acp_aw_user      = s_rab_acp.aw_user   ;\n  assign s_rab_acp.aw_ready   = rab_acp_aw_ready    ;\n  assign rab_acp_ar_valid     = s_rab_acp.ar_valid  ;\n  assign rab_acp_ar_addr      = s_rab_acp.ar_addr   ;\n  assign rab_acp_ar_prot      = s_rab_acp.ar_prot   ;\n  assign rab_acp_ar_region    = s_rab_acp.ar_region ;\n  assign rab_acp_ar_len       = s_rab_acp.ar_len    ;\n  assign rab_acp_ar_size      = s_rab_acp.ar_size   ;\n  assign rab_acp_ar_burst     = s_rab_acp.ar_burst  ;\n  assign rab_acp_ar_lock      = s_rab_acp.ar_lock   ;\n  assign rab_acp_ar_cache     = s_rab_acp.ar_cache  ;\n  assign rab_acp_ar_qos       = s_rab_acp.ar_qos    ;\n  assign rab_acp_ar_id        = s_rab_acp.ar_id     ;\n  assign rab_acp_ar_user      = s_rab_acp.ar_user   ;\n  assign s_rab_acp.ar_ready   = rab_acp_ar_ready    ;\n  assign rab_acp_w_valid      = s_rab_acp.w_valid   ;\n  assign rab_acp_w_data       = s_rab_acp.w_data    ;\n  assign rab_acp_w_strb       = s_rab_acp.w_strb    ;\n  assign rab_acp_w_user       = s_rab_acp.w_user    ;\n  assign rab_acp_w_last       = s_rab_acp.w_last    ;\n  assign s_rab_acp.w_ready    = rab_acp_w_ready     ;\n  assign s_rab_acp.r_valid    = rab_acp_r_valid     ;\n  assign s_rab_acp.r_data     = rab_acp_r_data      ;\n  assign s_rab_acp.r_resp     = rab_acp_r_resp      ;\n  assign s_rab_acp.r_last     = rab_acp_r_last      ;\n  assign s_rab_acp.r_id       = rab_acp_r_id        ;\n  assign s_rab_acp.r_user     = rab_acp_r_user      ;\n  assign rab_acp_r_ready      = s_rab_acp.r_ready   ;\n  assign s_rab_acp.b_valid    = rab_acp_b_valid     ;\n  assign s_rab_acp.b_resp     = rab_acp_b_resp      ;\n  assign s_rab_acp.b_id       = rab_acp_b_id        ;\n  assign s_rab_acp.b_user     = rab_acp_b_user      ;\n  assign rab_acp_b_ready      = s_rab_acp.b_ready   ;\n`endif\n\n  assign s_rab_slave.aw_valid    = rab_slave_aw_valid   ;\n  assign s_rab_slave.aw_addr     = rab_slave_aw_addr    ;\n  assign s_rab_slave.aw_prot     = rab_slave_aw_prot    ;\n  assign s_rab_slave.aw_region   = rab_slave_aw_region  ;\n  assign s_rab_slave.aw_len      = rab_slave_aw_len     ;\n  assign s_rab_slave.aw_size     = rab_slave_aw_size    ;\n  assign s_rab_slave.aw_burst    = rab_slave_aw_burst   ;\n  assign s_rab_slave.aw_lock     = rab_slave_aw_lock    ;\n  assign s_rab_slave.aw_cache    = rab_slave_aw_cache   ;\n  assign s_rab_slave.aw_qos      = rab_slave_aw_qos     ;\n  assign s_rab_slave.aw_id       = rab_slave_aw_id      ;\n  assign s_rab_slave.aw_user     = rab_slave_aw_user    ;\n  assign rab_slave_aw_ready      = s_rab_slave.aw_ready ;\n  assign s_rab_slave.ar_valid    = rab_slave_ar_valid   ;\n  assign s_rab_slave.ar_addr     = rab_slave_ar_addr    ;\n  assign s_rab_slave.ar_prot     = rab_slave_ar_prot    ;\n  assign s_rab_slave.ar_region   = rab_slave_ar_region  ;\n  assign s_rab_slave.ar_len      = rab_slave_ar_len     ;\n  assign s_rab_slave.ar_size     = rab_slave_ar_size    ;\n  assign s_rab_slave.ar_burst    = rab_slave_ar_burst   ;\n  assign s_rab_slave.ar_lock     = rab_slave_ar_lock    ;\n  assign s_rab_slave.ar_cache    = rab_slave_ar_cache   ;\n  assign s_rab_slave.ar_qos      = rab_slave_ar_qos     ;\n  assign s_rab_slave.ar_id       = rab_slave_ar_id      ;\n  assign s_rab_slave.ar_user     = rab_slave_ar_user    ;\n  assign rab_slave_ar_ready      = s_rab_slave.ar_ready ;\n  assign s_rab_slave.w_valid     = rab_slave_w_valid    ;\n  assign s_rab_slave.w_data      = rab_slave_w_data     ;\n  assign s_rab_slave.w_strb      = rab_slave_w_strb     ;\n  assign s_rab_slave.w_user      = rab_slave_w_user     ;\n  assign s_rab_slave.w_last      = rab_slave_w_last     ;\n  assign rab_slave_w_ready       = s_rab_slave.w_ready  ;\n  assign rab_slave_r_valid       = s_rab_slave.r_valid  ;\n  assign rab_slave_r_data        = s_rab_slave.r_data   ;\n  assign rab_slave_r_resp        = s_rab_slave.r_resp   ;\n  assign rab_slave_r_last        = s_rab_slave.r_last   ;\n  assign rab_slave_r_id          = s_rab_slave.r_id     ;\n  assign rab_slave_r_user        = s_rab_slave.r_user   ;\n  assign s_rab_slave.r_ready     = rab_slave_r_ready    ;\n  assign rab_slave_b_valid       = s_rab_slave.b_valid  ;\n  assign rab_slave_b_resp        = s_rab_slave.b_resp   ;\n  assign rab_slave_b_id          = s_rab_slave.b_id     ;\n  assign rab_slave_b_user        = s_rab_slave.b_user   ;\n  assign s_rab_slave.b_ready     = rab_slave_b_ready    ;\n\n  assign s_rab_lite_from_host.aw_addr  = rab_lite_aw_addr              ;\n  assign s_rab_lite_from_host.aw_valid = rab_lite_aw_valid             ;\n  assign rab_lite_aw_ready             = s_rab_lite_from_host.aw_ready ;\n  assign s_rab_lite_from_host.w_data   = rab_lite_w_data               ;\n  assign s_rab_lite_from_host.w_strb   = rab_lite_w_strb               ;\n  assign s_rab_lite_from_host.w_valid  = rab_lite_w_valid              ;\n  assign rab_lite_w_ready              = s_rab_lite_from_host.w_ready  ;\n  assign rab_lite_b_resp               = s_rab_lite_from_host.b_resp   ;\n  assign rab_lite_b_valid              = s_rab_lite_from_host.b_valid  ;\n  assign s_rab_lite_from_host.b_ready  = rab_lite_b_ready              ;\n  assign s_rab_lite_from_host.ar_addr  = rab_lite_ar_addr              ;\n  assign s_rab_lite_from_host.ar_valid = rab_lite_ar_valid             ;\n  assign rab_lite_ar_ready             = s_rab_lite_from_host.ar_ready ;\n  assign rab_lite_r_data               = s_rab_lite_from_host.r_data   ;\n  assign rab_lite_r_resp               = s_rab_lite_from_host.r_resp   ;\n  assign rab_lite_r_valid              = s_rab_lite_from_host.r_valid  ;\n  assign s_rab_lite_from_host.r_ready  = rab_lite_r_ready              ;\n\n`ifdef RAB_AX_LOG_EN\n  assign RabArBram_PS.Clk_C  = RabArBramClk_CI   ;\n  assign RabArBram_PS.Rst_R  = RabArBramRst_RI   ;\n  assign RabArBram_PS.En_S   = RabArBramEn_SI    ;\n  assign RabArBram_PS.Addr_S = RabArBramAddr_SI  ;\n  assign RabArBramRd_DO      = RabArBram_PS.Rd_D ;\n  assign RabArBram_PS.Wr_D   = RabArBramWr_DI    ;\n  assign RabArBram_PS.WrEn_S = RabArBramWrEn_SI  ;\n  assign RabAwBram_PS.Clk_C  = RabAwBramClk_CI   ;\n  assign RabAwBram_PS.Rst_R  = RabAwBramRst_RI   ;\n  assign RabAwBram_PS.En_S   = RabAwBramEn_SI    ;\n  assign RabAwBram_PS.Addr_S = RabAwBramAddr_SI  ;\n  assign RabAwBramRd_DO      = RabAwBram_PS.Rd_D ;\n  assign RabAwBram_PS.Wr_D   = RabAwBramWr_DI    ;\n  assign RabAwBram_PS.WrEn_S = RabAwBramWrEn_SI  ;\n`endif\n/// }}}\n\nendmodule\n\n// vim: ts=3 sw=3 sts=3 et nosmartindent autoindent foldmethod=marker\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/*\n * pulp_soc_defines.sv\n * Davide Rossi <davide.rossi@unibo.it>\n * Antonio Pullini <pullinia@iis.ee.ethz.ch>\n * Igor Loi <igor.loi@unibo.it>\n * Francesco Conti <fconti@iis.ee.ethz.ch>\n * Pasquale Davide Schiavone <pschiavo@iss.ee.ethz.ch>\n * Pirmin Vogel <vogelpi@iis.ee.ethz.ch>\n * Andreas Kurth <akurth@iis.ee.ethz.ch>\n */\n\n`ifndef PULP_SOC_DEFINES_SV\n`define PULP_SOC_DEFINES_SV\n\nimport CfMath::log2;\n\n// define if the 0x0000_0000 to 0x0040_0000 is the alias of the current cluster address space (eg cluster 0 is from  0x1000_0000 to 0x1040_0000)\n`define CLUSTER_ALIAS\n\n// To use new icache use this define\n`define MP_ICACHE\n//`define SP_ICACHE\n//`define PRIVATE_ICACHE\n\n// To use The L2 Multibank Feature, please decomment this define\n`define USE_L2_MULTIBANK\n`define NB_L2_CHANNELS 4\n\n// Hardware Accelerator selection\n//`define HWCRYPT\n\n// Uncomment if the SCM is not present (it will still be in the memory map)\n//`define NO_SCM -> anyway not active in Mr. Wolf cluster\n\n// Uncomment to enable APU/FPU, also apu_package.sv needs to be adapted!\n//`define APU_CLUSTER\n\n// uncomment if you want to place the DEMUX peripherals (EU, MCHAN) right before the Test and set region.\n// This will steal 16KB from the 1MB TCDM reegion.\n// EU is mapped           from 0x10100000 - 0x400\n// MCHAN regs are mapped  from 0x10100000 - 0x800\n// remember to change the defines in the pulp.h as well to be coherent with this approach\n//`define DEM_PER_BEFORE_TCDM_TS\n\n// uncomment if FPGA emulator\n// `define PULP_FPGA_EMUL 1\n// uncomment if using Vivado for ulpcluster synthesis\n`define VIVADO\n\n// Enables memory mapped register and counters to extract statistic on instruction cache\n`define FEATURE_ICACHE_STAT\n\n`ifdef PULP_FPGA_EMUL\n  // `undef  FEATURE_ICACHE_STAT\n  `define SCM_BASED_ICACHE\n`endif\n\n// Platform-Dependent Parameters {{{\n`ifdef ZEDBOARD\n  // SOC\n  `define NB_CLUSTERS            1\n  `define AXI_ID_EXT_S_WIDTH     6 // AXI ID of external slaves\n  `define AXI_ID_EXT_S_ACP_WIDTH 3 // AXI ID of external ACP slave\n  `define AXI_ID_EXT_M_WIDTH     6 // AXI ID of external masters\n  `define AXI_ID_SOC_S_WIDTH     6 // AXI ID of SoC Bus slaves\n  `define AXI_ID_SOC_M_WIDTH     7 // AXI ID of SoC Bus masters\n  `define L2_SIZE          64*1024 // Bytes    \n  // CLUSTER\n  `define NB_CORES               2\n  `define NB_TCDM_BANKS          4\n  `define TCDM_SIZE        32*1024 // Bytes\n  `define MCHAN_BURST_LENGTH   256 // max burst size in Bytes - any power of 2 value from 8 to 2048\n  `define NB_OUTSND_BURSTS       8 // max number of outstanding burst transactions\n   // CACHE\n  `define NB_CACHE_BANKS         1\n  `define CACHE_SIZE          1024\n    // RAB\n  `define AXI_EXT_ADDR_WIDTH    32\n  `define AXI_LITE_DATA_WIDTH   32\n  `define EN_L2TLB_ARRAY     {0,0} // Port 1, Port 0\n  `define N_SLICES_ARRAY     {8,4}\n  `define N_SLICES_MAX           8\n  `define EN_ACP                 1\n  //`define RAB_AX_LOG_EN          1 deactivated for zedboard (unsupported by bigpulp-z-70xx_top)\n  `define RAB_AX_LOG_ENTRIES     0\n`elsif JUNO\n  // SOC\n  `define NB_CLUSTERS            4\n  `define AXI_ID_EXT_S_WIDTH     6 // AXI ID of external slaves\n  `define AXI_ID_EXT_S_ACP_WIDTH 6 // AXI ID of external ACP slave -- actually not existing in JUNO\n  `define AXI_ID_EXT_M_WIDTH    15 // AXI ID of external masters // 14b tmif, 1b crossbar\n  `define AXI_ID_SOC_S_WIDTH     6 // AXI ID of SoC Bus slaves\n  `define AXI_ID_SOC_M_WIDTH     9 // AXI ID of SoC Bus masters\n  `define L2_SIZE         256*1024 // Bytes \n  // CLUSTER\n  `define NB_CORES               8\n  `define NB_TCDM_BANKS         16\n  `define TCDM_SIZE       256*1024 // Bytes\n  `define MCHAN_BURST_LENGTH   256 // max burst size in Bytes - any power of 2 value from 8 to 2048\n  `define NB_OUTSND_BURSTS       8 // 16 // max number of outstanding burst transactions\n  // CACHE\n  `define NB_CACHE_BANKS         2\n  `define CACHE_SIZE          4096\n  // RAB\n  `define AXI_EXT_ADDR_WIDTH    40\n  `define AXI_LITE_DATA_WIDTH   64\n  `define EN_L2TLB_ARRAY     {1,0}  // Port 1, Port 0\n  `define N_SLICES_ARRAY    {32,4}\n  `define N_SLICES_MAX          32\n  //`define EN_ACP               1\n  `define RAB_AX_LOG_EN          1\n  `define RAB_AX_LOG_ENTRIES     8*1024\n`elsif ZYNQMPSOC // te0808\n  // SOC\n  `define NB_CLUSTERS            1\n  `define AXI_ID_EXT_S_WIDTH     6 // AXI ID of external slaves\n  `define AXI_ID_EXT_S_ACP_WIDTH 6 // AXI ID of external ACP slave\n  `define AXI_ID_EXT_M_WIDTH     6 // AXI ID of external masters\n  `define AXI_ID_SOC_S_WIDTH     6 // AXI ID of SoC Bus slaves\n  `define AXI_ID_SOC_M_WIDTH     7 // AXI ID of SoC Bus masters\n  `define L2_SIZE         256*1024 // Bytes \n  // CLUSTER\n  `define NB_CORES               8\n  `define NB_TCDM_BANKS         16\n  `define TCDM_SIZE       256*1024 // Bytes\n  `define MCHAN_BURST_LENGTH   256 // max burst size in Bytes - any power of 2 value from 8 to 2048\n  `define NB_OUTSND_BURSTS       8 // 16 // max number of outstanding burst transactions\n  // CACHE\n  `define NB_CACHE_BANKS         4\n  `define CACHE_SIZE          4096\n   // RAB\n  `define AXI_EXT_ADDR_WIDTH    48\n  `define AXI_LITE_DATA_WIDTH   64\n  `define EN_L2TLB_ARRAY      {1,0} // Port 1, Port 0\n  `define N_SLICES_ARRAY     {32,4}\n  `define N_SLICES_MAX          32\n  `define EN_ACP                 1\n  `define RAB_AX_LOG_EN          1\n  `define RAB_AX_LOG_ENTRIES     2*1024\n`else // mini-itx, zc-706\n  // SOC\n  `define NB_CLUSTERS            1\n  `define AXI_ID_EXT_S_WIDTH     6 // AXI ID of external slaves\n  `define AXI_ID_EXT_S_ACP_WIDTH 3 // AXI ID of external ACP slave\n  `define AXI_ID_EXT_M_WIDTH     6 // AXI ID of external masters\n  `define AXI_ID_SOC_S_WIDTH     6 // AXI ID of SoC Bus slaves\n  `define AXI_ID_SOC_M_WIDTH     7 // AXI ID of SoC Bus masters\n  `define L2_SIZE         256*1024 // Bytes \n  // CLUSTER\n  `define NB_CORES               8\n  `define NB_TCDM_BANKS         16\n  `define TCDM_SIZE       256*1024 // Bytes\n  `define MCHAN_BURST_LENGTH   256 // max burst size in Bytes - any power of 2 value from 8 to 2048\n  `define NB_OUTSND_BURSTS       8 // max number of outstanding burst transactions\n  // CACHE\n  `define NB_CACHE_BANKS         4\n  `define CACHE_SIZE          4096\n   // RAB\n  `define AXI_EXT_ADDR_WIDTH    32\n  `define AXI_LITE_DATA_WIDTH   32\n  `define EN_L2TLB_ARRAY      {1,0} // Port 1, Port 0\n  `define N_SLICES_ARRAY     {32,4}\n  `define N_SLICES_MAX          32\n  `define EN_ACP                 1\n  `define RAB_AX_LOG_EN          1\n  `define RAB_AX_LOG_ENTRIES     2*1024\n`endif\n// }}}\n\n// Platform-Independent / Derived Parameters {{{\n`define RAB_AX_LOG_ADDR_BITW    log2(`RAB_AX_LOG_ENTRIES * 3 * 4)   // 3 32-bit words per entry\n\n`define RAB_N_PORTS              2\n`define RAB_L2_N_SETS           32\n`define RAB_L2_N_SET_ENTRIES    32\n`define RAB_L2_N_PAR_VA_RAMS     4\n// }}}\n\n// DEFINES\n`define MPER_EXT_ID   0\n\n`define NB_SPERIPH_PLUGS_EU 2\n\n`define SPER_EOC_ID      0\n`define SPER_TIMER_ID    1\n`define SPER_EVENT_U_ID  2\n`define SPER_HWCE_ID     4\n`define SPER_ICACHE_CTRL 5\n`define SPER_RPIPE_ID    6\n`define SPER_EXT_ID      7\n\n`define RVT 0\n`define LVT 1\n\n`ifndef PULP_FPGA_EMUL\n  `define LEVEL_SHIFTER\n`endif\n\n// Comment to use bheavioral memories, uncomment to use stdcell latches. If uncommented, simulations slowdown occuor\n`ifdef SYNTHESIS\n `define SCM_IMPLEMENTED\n `define SCM_BASED_ICACHE\n`endif\n//////////////////////\n// MMU DEFINES\n//\n// switch for including implementation of MMUs\n//`define MMU_IMPLEMENTED\n// number of logical TCDM banks (regarding interleaving)\n`define MMU_TCDM_BANKS 8\n// switch to enable local copy registers of\n// the control signals in every MMU\n//`define MMU_LOCAL_COPY_REGS\n//\n//////////////////////\n\n// Width of byte enable for a given data width\n`define EVAL_BE_WIDTH(DATAWIDTH) (DATAWIDTH/8)\n\n// LOG2()\n`define LOG2(VALUE) ((VALUE) < ( 1 ) ? 0 : (VALUE) < ( 2 ) ? 1 : (VALUE) < ( 4 ) ? 2 : (VALUE)< (8) ? 3:(VALUE) < ( 16 )  ? 4 : (VALUE) < ( 32 )  ? 5 : (VALUE) < ( 64 )  ? 6 : (VALUE) < ( 128 ) ? 7 : (VALUE) < ( 256 ) ? 8 : (VALUE) < ( 512 ) ? 9 : 10)\n\n`endif\n\n// vim: ts=2 sw=2 sts=2 et nosmartindent autoindent foldmethod=marker tw=100\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/*\n * SoC Bus to RAB Configuration Port Converter\n *\n * This module performs protocol conversion (AXI4 -> AXI4LITE) and, if necessary (depending on the\n * platform), data width conversion to connect a ULPSOC bus master to the RAB configuration slave.\n *\n * For read accesses aligned to 32-bit words but not to 64-bit words, the data is returned in the\n * upper 32 bit of the 64-bit word so that it ends up correctly in the registers of PULP.  The lower\n * 32 bit (ignored by PULP in this case) are set to zero.  This multiplexing on the R channel is\n * conditional on the last valid adddress on the AR channel.  Therefore, this module does not\n * support multiple outstanding reads and will serialize them.\n *\n * Also, only 32-bit reads are supported.\n *\n * Current Maintainers:\n * - Andreas Kurth  <andkurt@ee.ethz.ch>\n * - Pirmin Vogel   <vogelpi@iis.ee.ethz.ch>\n */\n\nmodule socbus_to_rab_cfg_conv\n\n  // Parameters {{{\n  #(\n    parameter AXI_ADDR_WIDTH  = 32,\n    parameter AXI_DATA_WIDTH  = 64,\n    parameter AXI_ID_WIDTH    = 10,\n    parameter AXI_USER_WIDTH  =  6\n  )\n  // }}}\n\n  // Ports {{{\n  (\n\n    input  logic  Clk_CI,\n    input  logic  Rst_RBI,\n\n    AXI_BUS.Slave   FromSoc_PS,\n    AXI_LITE.Master ToRabCfg_PM\n\n  );\n  // }}}\n\n  // Signal Declarations {{{\n  enum reg {READY, READ}    State_SP,   State_SN;\n  reg [AXI_ADDR_WIDTH-1:0]  ArAddr_DP,  ArAddr_DN;\n  // }}}\n\n  // Assert that module is used under the constraints it was designed for. {{{\n  initial begin\n    assert (AXI_DATA_WIDTH == 64)\n      else $fatal(1, \"This converter was designed for a 64-bit SoC data bus!\");\n  end\n  // }}}\n\n  // 32-to-64-bit Data Multiplexing to Make Reads Compatible with PULP {{{\n  //\n  // When reading, put 32-bit word from slave into lower or upper 32-bit of 64-bit of master,\n  // depending on the read address.\n  //\n  // The problem:  The interface coming from the SoC Bus is 64-bit wide, PULP has 32-bit registers,\n  // and the AXI Lite port is either 32- or 64-bit wide.  If a read is 32-bit, but not 64-bit\n  // aligned (e.g., on 0x4), PULP wants those 32 bit that are written to the registers in the upper\n  // 32 bit of the 64-bit bus.  The data width converter, however, places them in the lower 32 bit\n  // of the 64-bit bus.\n  //\n  // The solution:  In this section, 32 bit words on the 64-bit wide R channel are put in the\n  // position expected by PULP, conditional on the address on the AR channel.\n\n  AXI_BUS\n    #(\n      .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH ),\n      .AXI_DATA_WIDTH ( AXI_DATA_WIDTH ),\n      .AXI_ID_WIDTH   ( AXI_ID_WIDTH   ),\n      .AXI_USER_WIDTH ( AXI_USER_WIDTH )\n    ) InternalSoc_PM ();\n\n  // Connect signals that are directly forwarded. {{{\n\n  assign InternalSoc_PM.aw_addr   = FromSoc_PS.aw_addr;\n  assign InternalSoc_PM.aw_prot   = FromSoc_PS.aw_prot;\n  assign InternalSoc_PM.aw_region = FromSoc_PS.aw_region;\n  assign InternalSoc_PM.aw_len    = FromSoc_PS.aw_len;\n  assign InternalSoc_PM.aw_size   = FromSoc_PS.aw_size;\n  assign InternalSoc_PM.aw_burst  = FromSoc_PS.aw_burst;\n  assign InternalSoc_PM.aw_lock   = FromSoc_PS.aw_lock;\n  assign InternalSoc_PM.aw_cache  = FromSoc_PS.aw_cache;\n  assign InternalSoc_PM.aw_qos    = FromSoc_PS.aw_qos;\n  assign InternalSoc_PM.aw_id     = FromSoc_PS.aw_id;\n  assign InternalSoc_PM.aw_user   = FromSoc_PS.aw_user;\n  assign FromSoc_PS.aw_ready      = InternalSoc_PM.aw_ready;\n  assign InternalSoc_PM.aw_valid  = FromSoc_PS.aw_valid;\n\n  assign InternalSoc_PM.ar_addr   = FromSoc_PS.ar_addr;\n  assign InternalSoc_PM.ar_prot   = FromSoc_PS.ar_prot;\n  assign InternalSoc_PM.ar_region = FromSoc_PS.ar_region;\n  assign InternalSoc_PM.ar_len    = FromSoc_PS.ar_len;\n  assign InternalSoc_PM.ar_size   = FromSoc_PS.ar_size;\n  assign InternalSoc_PM.ar_burst  = FromSoc_PS.ar_burst;\n  assign InternalSoc_PM.ar_lock   = FromSoc_PS.ar_lock;\n  assign InternalSoc_PM.ar_cache  = FromSoc_PS.ar_cache;\n  assign InternalSoc_PM.ar_qos    = FromSoc_PS.ar_qos;\n  assign InternalSoc_PM.ar_id     = FromSoc_PS.ar_id;\n  assign InternalSoc_PM.ar_user   = FromSoc_PS.ar_user;\n  assign InternalSoc_PM.ar_valid  = FromSoc_PS.ar_valid;\n\n  assign InternalSoc_PM.w_data    = FromSoc_PS.w_data;\n  assign InternalSoc_PM.w_strb    = FromSoc_PS.w_strb;\n  assign InternalSoc_PM.w_user    = FromSoc_PS.w_user;\n  assign InternalSoc_PM.w_last    = FromSoc_PS.w_last;\n  assign FromSoc_PS.w_ready       = InternalSoc_PM.w_ready;\n  assign InternalSoc_PM.w_valid   = FromSoc_PS.w_valid;\n\n  assign FromSoc_PS.r_resp        = InternalSoc_PM.r_resp;\n  assign FromSoc_PS.r_id          = InternalSoc_PM.r_id;\n  assign FromSoc_PS.r_user        = InternalSoc_PM.r_user;\n  assign FromSoc_PS.r_last        = InternalSoc_PM.r_last;\n  assign InternalSoc_PM.r_ready   = FromSoc_PS.r_ready;\n\n  assign FromSoc_PS.b_resp        = InternalSoc_PM.b_resp;\n  assign FromSoc_PS.b_id          = InternalSoc_PM.b_id;\n  assign FromSoc_PS.b_user        = InternalSoc_PM.b_user;\n  assign InternalSoc_PM.b_ready   = FromSoc_PS.b_ready;\n  assign FromSoc_PS.b_valid       = InternalSoc_PM.b_valid;\n\n  // }}}\n\n  // Conditional on the latched AR address, place 32-bit word on R channel as expected by PULP. {{{\n  always_comb begin\n    if (ArAddr_DP[2] == 1'b1) begin // upper 32-bit word of 64-bit data double word\n      FromSoc_PS.r_data = {InternalSoc_PM.r_data[31:0], 32'h00000000};\n    end\n    else begin\n      FromSoc_PS.r_data = {32'h00000000, InternalSoc_PM.r_data[31:0]};\n    end\n  end\n  // }}}\n\n  // FSM to Control Handshaking Outputs and AR Latching. {{{\n  always_comb begin\n    // Default Assignments\n    ArAddr_DN           = ArAddr_DP;\n    FromSoc_PS.ar_ready = 1'b0;\n    FromSoc_PS.r_valid  = 1'b0;\n    State_SN            = State_SP;\n\n    case (State_SP)\n\n      READY: begin\n        FromSoc_PS.ar_ready = InternalSoc_PM.ar_ready;\n        if (FromSoc_PS.ar_valid && InternalSoc_PM.ar_ready) begin\n          ArAddr_DN = FromSoc_PS.ar_addr;\n          State_SN  = READ;\n        end\n      end\n\n      READ: begin\n        FromSoc_PS.r_valid  = InternalSoc_PM.r_valid;\n        if (FromSoc_PS.r_ready && InternalSoc_PM.r_valid) begin\n          State_SN  = READY;\n        end\n      end\n\n      default: begin\n        State_SN = READY;\n      end\n\n    endcase\n  end\n  // }}}\n\n\n  // }}}\n\n  `ifndef HOST_IS_64_BIT\n  AXI_LITE ToDwidthConv_P ();\n  `endif\n\n  // Protocol Converter {{{\n  AxiToAxiLitePc\n    #(\n      .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH  ),\n      .AXI_ID_WIDTH   ( AXI_ID_WIDTH    )\n    ) prot_conv\n    (\n      .Clk_CI     ( Clk_CI          ),\n      .Rst_RBI    ( Rst_RBI         ),\n\n      .Axi_PS     ( InternalSoc_PM  ),\n      `ifdef HOST_IS_64_BIT\n      .AxiLite_PM ( ToRabCfg_PM     )\n      `else\n      .AxiLite_PM ( ToDwidthConv_P  )\n      `endif\n    );\n  // }}}\n\n  // Data Width Converter (all platforms without 64-bit host) {{{\n  `ifndef HOST_IS_64_BIT\n  xilinx_axi_dwidth_conv_rab_cfg dwidth_conv\n    (\n      .s_axi_aclk     ( Clk_CI                  ),\n      .s_axi_aresetn  ( Rst_RBI                 ),\n\n      .s_axi_awaddr   ( ToDwidthConv_P.aw_addr  ),\n      .s_axi_awprot   ( 'b0                     ),\n      .s_axi_awvalid  ( ToDwidthConv_P.aw_valid ),\n      .s_axi_awready  ( ToDwidthConv_P.aw_ready ),\n      .s_axi_wdata    ( ToDwidthConv_P.w_data   ),\n      .s_axi_wstrb    ( ToDwidthConv_P.w_strb   ),\n      .s_axi_wvalid   ( ToDwidthConv_P.w_valid  ),\n      .s_axi_wready   ( ToDwidthConv_P.w_ready  ),\n      .s_axi_bresp    ( ToDwidthConv_P.b_resp   ),\n      .s_axi_bvalid   ( ToDwidthConv_P.b_valid  ),\n      .s_axi_bready   ( ToDwidthConv_P.b_ready  ),\n      .s_axi_araddr   ( ToDwidthConv_P.ar_addr  ),\n      .s_axi_arprot   ( 'b0                     ),\n      .s_axi_arvalid  ( ToDwidthConv_P.ar_valid ),\n      .s_axi_arready  ( ToDwidthConv_P.ar_ready ),\n      .s_axi_rdata    ( ToDwidthConv_P.r_data   ),\n      .s_axi_rresp    ( ToDwidthConv_P.r_resp   ),\n      .s_axi_rvalid   ( ToDwidthConv_P.r_valid  ),\n      .s_axi_rready   ( ToDwidthConv_P.r_ready  ),\n\n      .m_axi_awaddr   ( ToRabCfg_PM.aw_addr     ),\n      .m_axi_awprot   (                         ),\n      .m_axi_awvalid  ( ToRabCfg_PM.aw_valid    ),\n      .m_axi_awready  ( ToRabCfg_PM.aw_ready    ),\n      .m_axi_wdata    ( ToRabCfg_PM.w_data      ),\n      .m_axi_wstrb    ( ToRabCfg_PM.w_strb      ),\n      .m_axi_wvalid   ( ToRabCfg_PM.w_valid     ),\n      .m_axi_wready   ( ToRabCfg_PM.w_ready     ),\n      .m_axi_bresp    ( ToRabCfg_PM.b_resp      ),\n      .m_axi_bvalid   ( ToRabCfg_PM.b_valid     ),\n      .m_axi_bready   ( ToRabCfg_PM.b_ready     ),\n      .m_axi_araddr   ( ToRabCfg_PM.ar_addr     ),\n      .m_axi_arprot   (                         ),\n      .m_axi_arvalid  ( ToRabCfg_PM.ar_valid    ),\n      .m_axi_arready  ( ToRabCfg_PM.ar_ready    ),\n      .m_axi_rdata    ( ToRabCfg_PM.r_data      ),\n      .m_axi_rresp    ( ToRabCfg_PM.r_resp      ),\n      .m_axi_rvalid   ( ToRabCfg_PM.r_valid     ),\n      .m_axi_rready   ( ToRabCfg_PM.r_ready     )\n    );\n  `endif\n  // }}}\n\n  // Flip-Flops {{{\n  always_ff @ (posedge Clk_CI) begin\n    ArAddr_DP <= {AXI_ADDR_WIDTH{1'b0}};\n    State_SP  <= READY;\n    if (Rst_RBI) begin\n      ArAddr_DP <= ArAddr_DN;\n      State_SP  <= State_SN;\n    end\n  end\n  // }}}\n\nendmodule\n\n// vim: ts=2 sw=2 sts=2 et nosmartindent autoindent foldmethod=marker tw=100\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/*\n * soc_bus_defines.sv\n * Davide Rossi <davide.rossi@unibo.it>\n * Antonio Pullini <pullinia@iis.ee.ethz.ch>\n * Igor Loi <igor.loi@unibo.it>\n * Francesco Conti <fconti@iis.ee.ethz.ch>\n * Pasquale Davide Schiavone <pschiavo@iss.ee.ethz.ch>\n * Andreas Kurth <akurth@iis.ee.ethz.ch>\n */\n\n// SOC BUS PARAMETRES\n\n`include \"pulp_soc_defines.sv\"\n\n`define NB_SLAVE  (`NB_CLUSTERS+1)\n`ifdef JUNO\n    `define NB_MASTER (`NB_CLUSTERS+6)\n`else\n    `define NB_MASTER (`NB_CLUSTERS+5)\n`endif\n`define NB_REGION 2\n\n// MASTER PORT TO CLUSTER(3MB)\n`define CLUSTER_DATA_START_ADDR 32'h1000_0000\n`define CLUSTER_DATA_END_ADDR   32'h102F_FFFF\n\n// MASTER PORT TO L2(64MB) \n`define SOC_L2_START_ADDR       32'h1C00_0000\n`define SOC_L2_END_ADDR         32'h1FFF_FFFF\n\n// MASTER PORT TO PERIPHERALS APB0(16*4KB)\n`define SOC_APB_START_ADDR      32'h1A10_0000\n`define SOC_APB_END_ADDR        32'h1A10_FFFF\n\n`ifdef JUNO\n    // MASTER PORT TO STDOUT (JTAG_UART)\n    `define SOC_STDOUT_START_ADDR   32'h1A11_0000\n    `define SOC_STDOUT_END_ADDR     32'h1A11_FFFF\n`endif\n\n// MASTER PORT TO MAILBOX\n`define MAILBOX_START_ADDR      32'h1A12_0000\n`define MAILBOX_END_ADDR        32'h1A12_1FFF\n\n// MASTER PORT TO RAB CFG INTERFACE\n`define SOC_RAB_CFG_START_ADDR  32'h1A13_0000\n`define SOC_RAB_CFG_END_ADDR    32'h1A13_FFFF\n\n// MASTER PORT TO L3 via RAB (low)\n`define SOC_RAB_START_ADDR      32'h0000_0000\n`define SOC_RAB_END_ADDR        32'h0FFF_FFFF\n\n// MASTER PORT TO L3 via RAB (high)\n`define SOC_RAB_HIGH_START_ADDR 32'h2000_0000\n`define SOC_RAB_HIGH_END_ADDR   32'hFFFF_FFFF\n\n`define AXI_ASSIGN_SLAVE(lhs, rhs)        \\\n    assign lhs.aw_id     = rhs.aw_id;     \\\n    assign lhs.aw_addr   = rhs.aw_addr;   \\\n    assign lhs.aw_len    = rhs.aw_len;    \\\n    assign lhs.aw_size   = rhs.aw_size;   \\\n    assign lhs.aw_burst  = rhs.aw_burst;  \\\n    assign lhs.aw_lock   = rhs.aw_lock;   \\\n    assign lhs.aw_cache  = rhs.aw_cache;  \\\n    assign lhs.aw_prot   = rhs.aw_prot;   \\\n    assign lhs.aw_region = rhs.aw_region; \\\n    assign lhs.aw_user   = rhs.aw_user;   \\\n    assign lhs.aw_qos    = rhs.aw_qos;    \\\n    assign lhs.aw_valid  = rhs.aw_valid;  \\\n    assign rhs.aw_ready  = lhs.aw_ready;  \\\n                                          \\\n    assign lhs.ar_id     = rhs.ar_id;     \\\n    assign lhs.ar_addr   = rhs.ar_addr;   \\\n    assign lhs.ar_len    = rhs.ar_len;    \\\n    assign lhs.ar_size   = rhs.ar_size;   \\\n    assign lhs.ar_burst  = rhs.ar_burst;  \\\n    assign lhs.ar_lock   = rhs.ar_lock;   \\\n    assign lhs.ar_cache  = rhs.ar_cache;  \\\n    assign lhs.ar_prot   = rhs.ar_prot;   \\\n    assign lhs.ar_region = rhs.ar_region; \\\n    assign lhs.ar_user   = rhs.ar_user;   \\\n    assign lhs.ar_qos    = rhs.ar_qos;    \\\n    assign lhs.ar_valid  = rhs.ar_valid;  \\\n    assign rhs.ar_ready  = lhs.ar_ready;  \\\n                                          \\\n    assign lhs.w_data    = rhs.w_data;    \\\n    assign lhs.w_strb    = rhs.w_strb;    \\\n    assign lhs.w_last    = rhs.w_last;    \\\n    assign lhs.w_user    = rhs.w_user;    \\\n    assign lhs.w_valid   = rhs.w_valid;   \\\n    assign rhs.w_ready   = lhs.w_ready;   \\\n                                          \\\n    assign rhs.b_id      = lhs.b_id;      \\\n    assign rhs.b_resp    = lhs.b_resp;    \\\n    assign rhs.b_user    = lhs.b_user;    \\\n    assign rhs.b_valid   = lhs.b_valid;   \\\n    assign lhs.b_ready   = rhs.b_ready;   \\\n                                          \\\n    assign rhs.r_id      = lhs.r_id;      \\\n    assign rhs.r_data    = lhs.r_data;    \\\n    assign rhs.r_resp    = lhs.r_resp;    \\\n    assign rhs.r_last    = lhs.r_last;    \\\n    assign rhs.r_user    = lhs.r_user;    \\\n    assign rhs.r_valid   = lhs.r_valid;   \\\n    assign lhs.r_ready   = rhs.r_ready;\n\n`define AXI_ASSIGN_MASTER(lhs, rhs) `AXI_ASSIGN_SLAVE(rhs, lhs)\n"}
{"text": "// Copyright 2014-2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"soc_bus_defines.sv\"\n\n`ifdef JUNO\n  `define USE_AXI_NODE_WITH_SLICES\n`endif\n\nmodule soc_bus_wrap\n#(\n  parameter AXI_ADDR_WIDTH   = 32,\n  parameter AXI_DATA_WIDTH   = 32,\n  parameter AXI_ID_IN_WIDTH  = 7,\n  parameter AXI_ID_OUT_WIDTH = 10,\n  parameter AXI_USER_WIDTH   = 6,\n  parameter NB_CLUSTERS      = 4\n)\n(\n  input logic       clk_i,\n  input logic       rst_ni,\n  input logic       test_en_i,\n\n  AXI_BUS.Slave     cluster_data_slave[NB_CLUSTERS],\n  AXI_BUS.Master    cluster_data_master[NB_CLUSTERS],\n  AXI_BUS.Slave     soc_rab_slave,\n  AXI_BUS.Master    soc_rab_master,\n  AXI_BUS.Master    soc_rab_cfg_master,\n  AXI_BUS.Master    mailbox_master,\n`ifdef JUNO\n  AXI_BUS.Master    soc_stdout_master,\n`endif    \n  AXI_BUS.Master    soc_l2_master,\n  AXI_BUS.Master    soc_apb_master\n);\n\n  localparam NB_MASTER      = `NB_MASTER;\n  localparam NB_SLAVE       = `NB_SLAVE;\n  localparam NB_REGION      = `NB_REGION;\n  int unsigned j;\n\n  logic [NB_REGION-1:0][NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0] s_start_addr;\n  logic [NB_REGION-1:0][NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0] s_end_addr;\n  logic [NB_REGION-1:0][NB_MASTER-1:0]                     s_valid_rule;\n  logic [ NB_SLAVE-1:0][NB_MASTER-1:0]                     s_connectivity_map;\n\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH  ( AXI_ADDR_WIDTH   ),\n    .AXI_DATA_WIDTH  ( AXI_DATA_WIDTH   ),\n    .AXI_ID_WIDTH    ( AXI_ID_OUT_WIDTH ),\n    .AXI_USER_WIDTH  ( AXI_USER_WIDTH   )\n  ) masters[NB_MASTER-1:0]();\n\n  AXI_BUS #(\n    .AXI_ADDR_WIDTH  ( AXI_ADDR_WIDTH   ),\n    .AXI_DATA_WIDTH  ( AXI_DATA_WIDTH   ),\n    .AXI_ID_WIDTH    ( AXI_ID_IN_WIDTH  ),\n    .AXI_USER_WIDTH  ( AXI_USER_WIDTH   )\n  ) slaves[NB_SLAVE-1:0]();\n\n  genvar i;\n\n  generate\n    for(i=0;i<NB_CLUSTERS;i++)\n      begin : SLAVE_CLUSTER_BIND\n        `AXI_ASSIGN_SLAVE(slaves[i], cluster_data_slave[i]);\n      end\n\n    `AXI_ASSIGN_SLAVE(slaves[NB_CLUSTERS], soc_rab_slave);\n\n    for(i=0;i<NB_CLUSTERS;i++)\n      begin : MASTER_CLUSTER_BIND\n        `AXI_ASSIGN_MASTER(masters[i], cluster_data_master[i]);\n        assign s_start_addr[0][i] = `CLUSTER_DATA_START_ADDR + 32'h0040_0000*i;\n        assign s_end_addr[0][i]   = `CLUSTER_DATA_END_ADDR   + 32'h0040_0000*i;\n      end\n\n    `AXI_ASSIGN_MASTER(masters[NB_CLUSTERS], soc_l2_master);\n    assign s_start_addr[0][NB_CLUSTERS] = `SOC_L2_START_ADDR;\n    assign s_end_addr[0][NB_CLUSTERS]   = `SOC_L2_END_ADDR;\n\n    `AXI_ASSIGN_MASTER(masters[NB_CLUSTERS+1], soc_rab_master);\n    assign s_start_addr [0][NB_CLUSTERS+1]  = `SOC_RAB_START_ADDR;\n    assign s_end_addr   [0][NB_CLUSTERS+1]  = `SOC_RAB_END_ADDR;\n    assign s_start_addr [1][NB_CLUSTERS+1]  = `SOC_RAB_HIGH_START_ADDR;\n    assign s_end_addr   [1][NB_CLUSTERS+1]  = `SOC_RAB_HIGH_END_ADDR;\n\n    `AXI_ASSIGN_MASTER(masters[NB_CLUSTERS+2], mailbox_master);\n    assign s_start_addr[0][NB_CLUSTERS+2] = `MAILBOX_START_ADDR;\n    assign s_end_addr[0][NB_CLUSTERS+2]   = `MAILBOX_END_ADDR;\n\n    `AXI_ASSIGN_MASTER(masters[NB_CLUSTERS+3], soc_apb_master);\n    assign s_start_addr[0][NB_CLUSTERS+3] = `SOC_APB_START_ADDR;\n    assign s_end_addr[0][NB_CLUSTERS+3]   = `SOC_APB_END_ADDR;\n\n    `AXI_ASSIGN_MASTER(masters[NB_CLUSTERS+4], soc_rab_cfg_master);\n    assign s_start_addr[0][NB_CLUSTERS+4] = `SOC_RAB_CFG_START_ADDR;\n    assign s_end_addr  [0][NB_CLUSTERS+4] = `SOC_RAB_CFG_END_ADDR;\n\n`ifdef JUNO\n    `AXI_ASSIGN_MASTER(masters[NB_CLUSTERS+5], soc_stdout_master);\n    assign s_start_addr[0][NB_CLUSTERS+5] = `SOC_STDOUT_START_ADDR;\n    assign s_end_addr[0][NB_CLUSTERS+5]   = `SOC_STDOUT_END_ADDR;\n`endif\n\n    assign s_connectivity_map = {NB_MASTER*NB_SLAVE{1'b1}};\n\n    always_comb\n      begin\n        s_valid_rule = '0;\n        // REGION 0\n        for(j=0;j<NB_CLUSTERS;j++)\n          begin\n            s_valid_rule[0][j] = 1;\n          end\n        s_valid_rule[0][NB_CLUSTERS]   = 1;\n        s_valid_rule[0][NB_CLUSTERS+1] = 1;\n        s_valid_rule[0][NB_CLUSTERS+2] = 1;\n        s_valid_rule[0][NB_CLUSTERS+3] = 1;\n        s_valid_rule[0][NB_CLUSTERS+4] = 1;\n`ifdef JUNO\n        s_valid_rule[0][NB_CLUSTERS+5] = 1;\n`endif    \n        // REGION 1\n        s_valid_rule[1][NB_CLUSTERS+1] = 1;\n      end\n\n  endgenerate\n\n  //********************************************************\n  //**************** SOC BUS *******************************\n  //********************************************************\n\n`ifndef USE_AXI_NODE_WITH_SLICES  \n  axi_node_intf_wrap #(\n    .NB_MASTER        ( NB_MASTER         ),\n    .NB_SLAVE         ( NB_SLAVE          ),\n    .NB_REGION        ( NB_REGION         ),\n    .AXI_ADDR_WIDTH   ( AXI_ADDR_WIDTH    ),\n    .AXI_DATA_WIDTH   ( AXI_DATA_WIDTH    ),\n    .AXI_ID_IN_WIDTH  ( AXI_ID_IN_WIDTH   ),\n    .AXI_ID_OUT_WIDTH ( AXI_ID_OUT_WIDTH  ),\n    .AXI_USER_WIDTH   ( AXI_USER_WIDTH    )\n  ) axi_interconnect_i (\n    .clk                ( clk_i              ),\n    .rst_n              ( rst_ni             ),\n    .test_en_i          ( test_en_i          ),\n\n    .slave              ( slaves             ),\n    .master             ( masters            ),\n\n    .start_addr_i       ( s_start_addr       ),\n    .end_addr_i         ( s_end_addr         ),\n    .valid_rule_i       ( s_valid_rule       ),\n    .connectivity_map_i ( s_connectivity_map )\n  );\n`else\n  axi_node_intf_wrap_with_slices #(\n    .NB_MASTER          ( NB_MASTER        ),\n    .NB_SLAVE           ( NB_SLAVE         ),\n    .NB_REGION          ( NB_REGION        ),\n    .AXI_ADDR_WIDTH     ( AXI_ADDR_WIDTH   ),\n    .AXI_DATA_WIDTH     ( AXI_DATA_WIDTH   ),\n    .AXI_ID_IN_WIDTH    ( AXI_ID_IN_WIDTH  ),\n    .AXI_ID_OUT_WIDTH   ( AXI_ID_OUT_WIDTH ),\n    .AXI_USER_WIDTH     ( AXI_USER_WIDTH   ),\n    .MASTER_SLICE_DEPTH ( 2                ),\n    .SLAVE_SLICE_DEPTH  ( 2                )\n  ) axi_interconnect_i (\n    .clk                ( clk_i              ),\n    .rst_n              ( rst_ni             ),\n    .test_en_i          ( test_en_i          ),\n\n    .slave              ( slaves             ),\n    .master             ( masters            ),\n\n    .start_addr_i       ( s_start_addr       ),\n    .end_addr_i         ( s_end_addr         ),\n    .valid_rule_i       ( s_valid_rule       ),\n    .connectivity_map_i ( s_connectivity_map )\n  );\n`endif\n\nendmodule\n\n// vim: ts=2 sw=2 sts=2 et nosmartindent autoindent foldmethod=marker\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"pulp_soc_defines.sv\"\n\nmodule soc_peripherals_multicluster\n#(\n  parameter AXI_ADDR_WIDTH = 32,\n  parameter AXI_DATA_WIDTH = 64,\n  parameter AXI_USER_WIDTH = 6,\n  parameter AXI_ID_WIDTH   = 6,\n \n  parameter NB_CORES       = 4,\n  parameter NB_CLUSTERS    = 1\n)\n(\n  input logic   clk_i,\n  input logic   rst_ni,\n\n  input logic   test_mode_i,\n\n  input  logic  uart_rx_i,\n  output logic  uart_tx_o,\n  output logic  uart_rts_no,  \n  output logic  uart_dtr_no,\n  input  logic  uart_cts_ni,  \n  input  logic  uart_dsr_ni,\n\n  // SLAVE PORTS\n  AXI_BUS.Slave axi_slave\n);\n\n  localparam APB_NUM_SLAVES = 4;\n  localparam APB_ADDR_WIDTH = 12;\n\n  logic                             s_penable;\n  logic                             s_pwrite;\n  logic        [APB_ADDR_WIDTH-1:0] s_paddr;\n  logic        [APB_NUM_SLAVES-1:0] s_psel;\n  logic                      [31:0] s_pwdata;\n  logic [APB_NUM_SLAVES-1:0] [31:0] s_prdata;\n  logic        [APB_NUM_SLAVES-1:0] s_pready;\n  logic        [APB_NUM_SLAVES-1:0] s_pslverr;\n\n  logic                             uart_rts;\n  logic                             uart_cts;\n  logic                             uart_dtr;\n  logic                             uart_dsr;\n\n  axi2apb_wrap #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH ),\n    .AXI_ID_WIDTH   ( AXI_ID_WIDTH   ),\n    .APB_ADDR_WIDTH ( APB_ADDR_WIDTH ),\n    .APB_NUM_SLAVES ( APB_NUM_SLAVES )\n  ) axi2apb_i (\n    .clk_i     ( clk_i       ),\n    .rst_ni    ( rst_ni      ),\n    .test_en_i ( test_mode_i ),\n\n    .axi_slave ( axi_slave   ),\n\n    .penable   ( s_penable   ),\n    .pwrite    ( s_pwrite    ),\n    .paddr     ( s_paddr     ),\n    .psel      ( s_psel      ),\n    .pwdata    ( s_pwdata    ),\n    .prdata    ( s_prdata    ),\n    .pready    ( s_pready    ),\n    .pslverr   ( s_pslverr   )\n  );\n\n  assign s_prdata[0] = '0;\n  assign s_prdata[1] = '0;\n\n  assign s_pready[0] = '0;\n  assign s_pready[1] = '0;\n\n  assign s_pslverr[0] = '0;\n  assign s_pslverr[1] = '0;\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// APB Slave 2: APB UART interface                            ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n  apb_uart i_apb_uart (\n    .CLK     ( clk_i        ),\n    .RSTN    ( rst_ni       ),\n\n    .PSEL    ( s_psel[2]    ),  // APB psel signal   \n    .PENABLE ( s_penable    ),  // APB penable signal\n    .PWRITE  ( s_pwrite     ),  // APB pwrite signal\n    .PADDR   ( s_paddr[4:2] ),  // APB paddr signal\n    .PWDATA  ( s_pwdata     ),  // APB pwdata signal\n    .PRDATA  ( s_prdata[2]  ),  // APB prdata signal\n    .PREADY  ( s_pready[2]  ),  // APB pready signal\n    .PSLVERR ( s_pslverr[2] ),  // APB pslverr signal\n\n    .INT     (              ),  // Interrupt output\n\n    .OUT1N   (              ),  // Output 1\n    .OUT2N   (              ),  // Output 2\n    .RTSN    ( uart_rts_no  ),  // RTS output\n    .DTRN    ( uart_dtr_no  ),  // DTR output\n    .CTSN    ( uart_cts_ni  ),  // CTS input\n    .DSRN    ( uart_dsr_ni  ),  // DSR input\n    .DCDN    ( uart_dsr_ni  ),  // DCD input = DSR for null-modem wiring\n    .RIN     ( 1'b1         ),  // RI input\n    .SIN     ( uart_rx_i    ),  // Receiver input\n    .SOUT    ( uart_tx_o    )   // Transmitter output\n  );\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// APB Slave 3: APB SOC configuration                         ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n  apb_soc_ctrl_multicluster #(\n    .NB_CORES    ( NB_CORES    ),\n    .NB_CLUSTERS ( NB_CLUSTERS )\n  ) apb_soc_registers_i (\n    .HCLK                 ( clk_i                ),\n    .HRESETn              ( rst_ni               ),\n\n    .PADDR                ( s_paddr              ),\n    .PWDATA               ( s_pwdata             ),\n    .PWRITE               ( s_pwrite             ),\n    .PSEL                 ( s_psel[3]            ),\n    .PENABLE              ( s_penable            ),\n    .PRDATA               ( s_prdata[3]          ),\n    .PREADY               ( s_pready[3]          ),\n    .PSLVERR              ( s_pslverr[3]         )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n/*\n * Wrapper Around the Xilinx AXI Crossbar Used to Connect the RAB Configuration Port\n *\n * Current Maintainers:\n * - Andreas Kurth  <andkurt@ee.ethz.ch>\n * - Pirmin Vogel   <vogelpi@iis.ee.ethz.ch>\n */\n\nimport CfMath::ceil_div;\n\nmodule xilinx_axi_xbar_rab_cfg_wrap\n\n  // Parameters {{{\n  #(\n    parameter integer ADDR_BITW = 32,\n    parameter integer DATA_BITW = 32\n  )\n  // }}}\n\n  // Ports {{{\n  (\n\n    input  logic    Clk_CI,\n    input  logic    Rst_RBI,\n\n    AXI_LITE.Slave  Slave0_PS,\n    AXI_LITE.Slave  Slave1_PS,\n    AXI_LITE.Master Master_PM\n\n  );\n  // }}}\n\n  // Module-Wide Constants {{{\n  localparam integer NUM_SI     = 2;\n  localparam integer DATA_BYTEW = ceil_div(DATA_BITW, 8);\n  // }}}\n\n  // Signal Declarations {{{\n  logic [NUM_SI*ADDR_BITW -1:0] AwAddr_D, ArAddr_D;\n  logic [NUM_SI           -1:0] AwValid_D, WValid_D, BValid_D, ArValid_D, RValid_D;\n  logic [NUM_SI           -1:0] AwReady_D, WReady_D, BReady_D, ArReady_D, RReady_D;\n  logic [NUM_SI*DATA_BITW -1:0] WData_D, RData_D;\n  logic [NUM_SI*2         -1:0] BResp_D, RResp_D;\n  logic [NUM_SI*DATA_BYTEW-1:0] WStrb_D;\n  // }}}\n\n  // Pack and Unpack Slave Signals {{{\n  genvar s;\n  for (s = 0; s < NUM_SI; s++) begin\n\n    localparam integer ADDR_BIT_LOW   = ADDR_BITW * s;\n    localparam integer ADDR_BIT_HIGH  = ADDR_BIT_LOW + (ADDR_BITW-1);\n    localparam integer DATA_BIT_LOW   = DATA_BITW * s;\n    localparam integer DATA_BIT_HIGH  = DATA_BIT_LOW + (DATA_BITW-1);\n    localparam integer DATA_BYTE_LOW  = DATA_BYTEW * s;\n    localparam integer DATA_BYTE_HIGH = DATA_BYTE_LOW + (DATA_BYTEW-1);\n    localparam integer RESP_BIT_LOW   = 2 * s;\n    localparam integer RESP_BIT_HIGH  = RESP_BIT_LOW + (2-1);\n\n    // This is extremely ugly and only supports NUM_SI == 2, but it is the only way I found to get\n    // this interface construct to synthesize in Vivado.\n    if (s == 0) begin\n\n      assign AwAddr_D[ADDR_BIT_HIGH:ADDR_BIT_LOW] = Slave0_PS.aw_addr;\n      assign ArAddr_D[ADDR_BIT_HIGH:ADDR_BIT_LOW] = Slave0_PS.ar_addr;\n\n      assign AwValid_D[s]       = Slave0_PS.aw_valid;\n      assign WValid_D[s]        = Slave0_PS.w_valid;\n      assign Slave0_PS.b_valid  = BValid_D[s];\n      assign ArValid_D[s]       = Slave0_PS.ar_valid;\n      assign Slave0_PS.r_valid  = RValid_D[s];\n\n      assign Slave0_PS.aw_ready = AwReady_D[s];\n      assign Slave0_PS.w_ready  = WReady_D[s];\n      assign BReady_D[s]        = Slave0_PS.b_ready;\n      assign Slave0_PS.ar_ready = ArReady_D[s];\n      assign RReady_D[s]        = Slave0_PS.r_ready;\n\n      assign WData_D[DATA_BIT_HIGH:DATA_BIT_LOW]  = Slave0_PS.w_data;\n\n      assign Slave0_PS.r_data  = RData_D[DATA_BIT_HIGH:DATA_BIT_LOW];\n\n      assign Slave0_PS.b_resp  = BResp_D[RESP_BIT_HIGH:RESP_BIT_LOW];\n\n      assign Slave0_PS.r_resp  = RResp_D[RESP_BIT_HIGH:RESP_BIT_LOW];\n\n      assign WStrb_D[DATA_BYTE_HIGH:DATA_BYTE_LOW]  = Slave0_PS.w_strb;\n\n    end\n    else begin // s == 1\n\n      assign AwAddr_D[ADDR_BIT_HIGH:ADDR_BIT_LOW] = Slave1_PS.aw_addr;\n      assign ArAddr_D[ADDR_BIT_HIGH:ADDR_BIT_LOW] = Slave1_PS.ar_addr;\n\n      assign AwValid_D[s]       = Slave1_PS.aw_valid;\n      assign WValid_D[s]        = Slave1_PS.w_valid;\n      assign Slave1_PS.b_valid  = BValid_D[s];\n      assign ArValid_D[s]       = Slave1_PS.ar_valid;\n      assign Slave1_PS.r_valid  = RValid_D[s];\n\n      assign Slave1_PS.aw_ready = AwReady_D[s];\n      assign Slave1_PS.w_ready  = WReady_D[s];\n      assign BReady_D[s]        = Slave1_PS.b_ready;\n      assign Slave1_PS.ar_ready = ArReady_D[s];\n      assign RReady_D[s]        = Slave1_PS.r_ready;\n\n      assign WData_D[DATA_BIT_HIGH:DATA_BIT_LOW]  = Slave1_PS.w_data;\n\n      assign Slave1_PS.r_data  = RData_D[DATA_BIT_HIGH:DATA_BIT_LOW];\n\n      assign Slave1_PS.b_resp  = BResp_D[RESP_BIT_HIGH:RESP_BIT_LOW];\n\n      assign Slave1_PS.r_resp  = RResp_D[RESP_BIT_HIGH:RESP_BIT_LOW];\n\n      assign WStrb_D[DATA_BYTE_HIGH:DATA_BYTE_LOW]  = Slave1_PS.w_strb;\n\n    end\n\n  end\n  // }}}\n\n  // Wrapped Xilinx AXI Crossbar {{{\n  xilinx_axi_xbar_rab_cfg i_xilinx_axi_xbar_rab_cfg\n    (\n      .aclk           ( Clk_CI              ),\n      .aresetn        ( Rst_RBI             ),\n\n      .s_axi_awaddr   ( AwAddr_D            ),\n      .s_axi_awprot   ( 'b0                 ),\n      .s_axi_awvalid  ( AwValid_D           ),\n      .s_axi_awready  ( AwReady_D           ),\n      .s_axi_wdata    ( WData_D             ),\n      .s_axi_wstrb    ( WStrb_D             ),\n      .s_axi_wvalid   ( WValid_D            ),\n      .s_axi_wready   ( WReady_D            ),\n      .s_axi_bresp    ( BResp_D             ),\n      .s_axi_bvalid   ( BValid_D            ),\n      .s_axi_bready   ( BReady_D            ),\n      .s_axi_araddr   ( ArAddr_D            ),\n      .s_axi_arprot   ( 'b0                 ),\n      .s_axi_arvalid  ( ArValid_D           ),\n      .s_axi_arready  ( ArReady_D           ),\n      .s_axi_rdata    ( RData_D             ),\n      .s_axi_rresp    ( RResp_D             ),\n      .s_axi_rvalid   ( RValid_D            ),\n      .s_axi_rready   ( RReady_D            ),\n\n      .m_axi_awaddr   ( Master_PM.aw_addr   ),\n      .m_axi_awprot   (                     ),\n      .m_axi_awvalid  ( Master_PM.aw_valid  ),\n      .m_axi_awready  ( Master_PM.aw_ready  ),\n      .m_axi_wdata    ( Master_PM.w_data    ),\n      .m_axi_wstrb    ( Master_PM.w_strb    ),\n      .m_axi_wvalid   ( Master_PM.w_valid   ),\n      .m_axi_wready   ( Master_PM.w_ready   ),\n      .m_axi_bresp    ( Master_PM.b_resp    ),\n      .m_axi_bvalid   ( Master_PM.b_valid   ),\n      .m_axi_bready   ( Master_PM.b_ready   ),\n      .m_axi_araddr   ( Master_PM.ar_addr   ),\n      .m_axi_arprot   (                     ),\n      .m_axi_arvalid  ( Master_PM.ar_valid  ),\n      .m_axi_arready  ( Master_PM.ar_ready  ),\n      .m_axi_rdata    ( Master_PM.r_data    ),\n      .m_axi_rresp    ( Master_PM.r_resp    ),\n      .m_axi_rvalid   ( Master_PM.r_valid   ),\n      .m_axi_rready   ( Master_PM.r_ready   )\n    );\n  // }}}\n\nendmodule\n\n// vim: ts=2 sw=2 sts=2 et nosmartindent autoindent foldmethod=marker tw=100\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// --=========================================================================--\n//\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n// \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\n// \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551   \n// \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d    \u2588\u2588\u2551   \n// \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d    \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551        \u2588\u2588\u2551   \n// \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d     \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d        \u255a\u2550\u255d   \n//                                                                                               \n// --=========================================================================--\n/**\n * Read Channels Adaptor for Xilinx Mailbox\n *\n * Current Maintainers:\n * - Pirmin Vogel   <vogelpi@iis.ee.ethz.ch>\n *\n * AXI-to-AXI-Lite protocol conversion, including data width conversion, ID reflection logic,\n * and mailbox interface arbitration.\n *\n * The Xilinx Mailbox seems to latch the ar channel without proper hand shake (illegal) if the\n * master decides to apply another transaction after driving valid high but without hand shake\n * having happened (illegal). The safe solution to this issue performed by this adaptor is to\n * register the ar request and perform the handshake separately with the mailbox and the master.\n *\n * IMPORTANT NOTE: Bursts are NOT supported.\n */\n\nmodule xilinx_mailbox_read_adaptor\n  #(\n    parameter AXI_ADDR_WIDTH = 32,\n    parameter AXI_DATA_WIDTH = 64,\n    parameter AXI_ID_WIDTH   = 10,\n    parameter AXI_USER_WIDTH = 6\n   )\n  (\n    input logic                       Clk_CI,\n    input logic                       Rst_RBI,\n\n    // AXI4 interface\n    input  logic [AXI_ADDR_WIDTH-1:0] ArAddr_DI,\n    input  logic                      ArValid_SI,\n    output logic                      ArReady_SO,\n    input  logic                [7:0] ArLen_SI,\n    input  logic   [AXI_ID_WIDTH-1:0] ArId_DI,\n\n    output logic [AXI_DATA_WIDTH-1:0] RData_DO,\n    output logic                      RValid_SO,\n    input  logic                      RReady_SI,\n    output logic   [AXI_ID_WIDTH-1:0] RId_DO, \n    output logic                [1:0] RResp_DO,\n    output logic [AXI_USER_WIDTH-1:0] RUser_DO,\n    output logic                      RLast_SO,\n    \n    // AXI4-Lite interfaces\n    output logic [AXI_ADDR_WIDTH-1:0] If0_ArAddr_DO,\n    output logic                      If0_ArValid_SO,\n    input  logic                      If0_ArReady_SI,\n    input  logic               [31:0] If0_RData_DI,\n    input  logic                      If0_RValid_SI,\n    output logic                      If0_RReady_SO,\n    input  logic                [1:0] If0_RResp_DI,\n\n    output logic [AXI_ADDR_WIDTH-1:0] If1_ArAddr_DO,\n    output logic                      If1_ArValid_SO,\n    input  logic                      If1_ArReady_SI,\n    input  logic               [31:0] If1_RData_DI,\n    input  logic                      If1_RValid_SI,\n    output logic                      If1_RReady_SO,\n    input  logic                [1:0] If1_RResp_DI\n  );\n\n  logic                      RAccept_S;\n  logic                      RSel_SN, RSel_SP;\n  logic [AXI_ADDR_WIDTH-1:0] ArAddr_DN, ArAddr_DP;\n  logic   [AXI_ID_WIDTH-1:0] RId_DN, RId_DP;\n  logic               [31:0] RData_D;\n\n  enum logic [1:0] {IDLE, READ, RESP} State_SN, State_SP;\n\n  assign ArAddr_DN = ArAddr_DI;\n\n  /*\n   * Constant outputs\n   */\n  assign If0_ArAddr_DO = ArAddr_DP;\n  assign If1_ArAddr_DO = ArAddr_DP;\n  assign RLast_SO      = RValid_SO;\n  assign RUser_DO      = 'b0;\n\n  /*\n   *  ID reflection logic\n   */\n  assign RId_DN = ArId_DI;\n  assign RId_DO = RId_DP;\n\n  /*\n   *  Mailbox interface arbitration based on Bit 12\n   *  - Address 0x0000 - 0x0FFF: Port 0\n   *  - Address 0x1000 - 0x1FFF: Port 1\n   */\n  assign RSel_SN = ArAddr_DI[12];\n\n  /*\n   *  Data width conversion\n   */\n  generate\n    if (AXI_DATA_WIDTH == 64) begin\n      logic RDataSel_SN, RDataSel_SP;\n\n      assign RDataSel_SN = ArAddr_DI[2];\n\n      // register to buffer the relevant address bit\n      always_ff @(posedge Clk_CI, negedge Rst_RBI) begin\n        if (Rst_RBI == 1'b0) begin\n          RDataSel_SP <= 1'b0;\n        end else if (RAccept_S == 1'b1) begin\n          RDataSel_SP <= RDataSel_SN;\n        end\n      end\n\n      // byte-lane steering\n      always_comb begin\n        if (RDataSel_SP == 1'b1) begin\n          RData_DO[63:32] = RData_D;\n          RData_DO[31:0]  = 32'h00000000;\n        end else begin\n          RData_DO[63:32] = 32'h00000000;\n          RData_DO[31:0]  = RData_D;\n        end\n      end\n\n    end else begin\n      always_comb begin\n        RData_DO = RData_D;\n      end\n    end\n  endgenerate\n\n  /*\n   *  Transaction acceptance\n   *\n   *  Registering of ar channel for compatibility with Xilinx Mailbox:\n   *\n   *  The Xilinx Mailbox seems to latch the ar channel without hand shake (illegal).\n   *  This can cause deadlocks if master decides to apply another transaction after\n   *  driving valid high but before a hand shake happened (illegal).\n   */\n  // ar/r channel FSM\n  always_comb begin\n    // default assignments\n    RAccept_S      = 1'b0;\n    ArReady_SO     = 1'b0;\n    If0_ArValid_SO = 1'b0;\n    If1_ArValid_SO = 1'b0;\n    RValid_SO      = 1'b0;\n    If0_RReady_SO  = 1'b0;\n    If1_RReady_SO  = 1'b0;\n    RData_D        = If0_RData_DI;\n    RResp_DO       = If0_RResp_DI;\n    State_SN       = State_SP;\n\n    case (State_SP)\n\n      IDLE: begin\n        ArReady_SO   = 1'b1; // prepare hand shake, recommended by AXI protocol specification\n        if (ArValid_SI == 1'b1) begin\n          RAccept_S  = 1'b1; // store ID, addr, select and byte-lane steering flag\n          State_SN   = READ;\n          assert (ArLen_SI == 'b0)\n            else $error(\"Multi-beat read transactions are not supported!\");\n        end\n      end   \n          \n      READ: begin\n        If0_ArValid_SO = ~RSel_SP; // the slave must see the valid\n        If1_ArValid_SO =  RSel_SP;\n        if ( (If0_ArReady_SI & ~RSel_SP) || (If1_ArReady_SI & RSel_SP) ) begin          \n          State_SN     = RESP;\n        end\n      end\n\n      RESP: begin\n        RValid_SO = (If0_RValid_SI & ~RSel_SP) | (If1_RValid_SI & RSel_SP);\n        if (RReady_SI == 1'b1) begin\n          if          (If0_RValid_SI & ~RSel_SP) begin\n            If0_RReady_SO = 1'b1;  \n            RData_D       = If0_RData_DI;\n            RResp_DO      = If0_RResp_DI;\n            State_SN      = IDLE;\n          end else if (If1_RValid_SI &  RSel_SP) begin\n            If1_RReady_SO = 1'b1;\n            RData_D       = If1_RData_DI;\n            RResp_DO      = If1_RResp_DI;\n            State_SN      = IDLE;\n          end\n        end\n      end\n\n      default: begin\n        State_SN = IDLE;\n      end\n    endcase // State_SP\n  end\n\n  always_ff @(posedge Clk_CI, negedge Rst_RBI) begin\n    if (Rst_RBI == 1'b0) begin\n      RSel_SP     <= 1'b0;\n      RId_DP      <=  'b0;\n      ArAddr_DP   <=  'b0;\n    end else if (RAccept_S == 1'b1) begin\n      RSel_SP     <= RSel_SN;\n      RId_DP      <= RId_DN;\n      ArAddr_DP   <= ArAddr_DN;\n    end\n  end\n\n  always_ff @(posedge Clk_CI, negedge Rst_RBI) begin\n    if (Rst_RBI == 1'b0) begin\n      State_SP <= IDLE;\n    end else begin\n      State_SP <= State_SN;\n    end\n  end\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// --=========================================================================--\n//\n// \u2588\u2588\u2588\u2557   \u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557  \u2588\u2588\u2557    \u2588\u2588\u2557    \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \n// \u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u255a\u2588\u2588\u2557\u2588\u2588\u2554\u255d    \u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\n// \u2588\u2588\u2554\u2588\u2588\u2588\u2588\u2554\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2554\u255d     \u2588\u2588\u2551 \u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\n// \u2588\u2588\u2551\u255a\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551 \u2588\u2588\u2554\u2588\u2588\u2557     \u2588\u2588\u2551\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \n// \u2588\u2588\u2551 \u255a\u2550\u255d \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2554\u255d \u2588\u2588\u2557    \u255a\u2588\u2588\u2588\u2554\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551     \n// \u255a\u2550\u255d     \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d     \u255a\u2550\u2550\u255d\u255a\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d     \n//                                                                           \n// --=========================================================================-- \n/**\n * Wrapper Around the Xilinx Mailbox\n *\n * Current Maintainers:\n * - Pirmin Vogel   <vogelpi@iis.ee.ethz.ch>\n *\n * Includes read and write channel adaptor for AXI-to-AXI-Lite protocol\n * conversion, data width conversion, and mailbox interface arbitration.\n *\n * This adaptor also handles multi-beat write transactions as they occur when,\n *  e.g., a 64-bit master interfaced through a Xilinx data width converter\n * issues a 32-bit write.\n *\n * IMPORTANT NOTES:\n *\n * - As the mailbox is a 32-bit AXI-Lite slave, only 1 32-bit word per\n *   data beat is written. Additional write data in other beats with non-zero\n *   wstrb is written, too.\n *\n * - Multi-beat read transactions are not supported. The master is supposed\n *   specify arsize accordingly when connecting through Xilinx data width\n *   converters.\n */\n\nmodule xilinx_mailbox_wrap\n  #(\n    parameter AXI_ADDR_WIDTH = 32,\n    parameter AXI_DATA_WIDTH = 64,\n    parameter AXI_ID_WIDTH   = 10,\n    parameter AXI_USER_WIDTH = 6\n   )\n  (\n    input  logic  Clk_CI,\n    input  logic  Rst_RBI,\n    \n    AXI_BUS.Slave FromSoc_PS,\n\n    output logic  Irq0_SO,\n    output logic  Irq1_SO\n  );\n\n  localparam AXI_STRB_WIDTH = AXI_DATA_WIDTH/8;\n\n  logic [AXI_ADDR_WIDTH-1:0] If0_ArAddr_D;\n  logic                      If0_ArValid_S;\n  logic                      If0_ArReady_S;\n  logic               [31:0] If0_RData_D;\n  logic                      If0_RValid_S;\n  logic                      If0_RReady_S;\n  logic                [1:0] If0_RResp_D;\n  logic [AXI_ADDR_WIDTH-1:0] If0_AwAddr_D;\n  logic                      If0_AwValid_S;\n  logic                      If0_AwReady_S;\n  logic               [31:0] If0_WData_D;\n  logic                [3:0] If0_WStrb_D;\n  logic                      If0_WValid_S;\n  logic                      If0_WReady_S;\n  logic                      If0_BValid_S;\n  logic                      If0_BReady_S;\n  logic                [1:0] If0_BResp_D;\n\n  logic [AXI_ADDR_WIDTH-1:0] If1_ArAddr_D;\n  logic                      If1_ArValid_S;\n  logic                      If1_ArReady_S;\n  logic               [31:0] If1_RData_D;\n  logic                      If1_RValid_S;\n  logic                      If1_RReady_S;\n  logic                [1:0] If1_RResp_D;\n  logic [AXI_ADDR_WIDTH-1:0] If1_AwAddr_D;\n  logic                      If1_AwValid_S;\n  logic                      If1_AwReady_S;\n  logic               [31:0] If1_WData_D;\n  logic                [3:0] If1_WStrb_D;\n  logic                      If1_WValid_S;\n  logic                      If1_WReady_S;\n  logic                      If1_BValid_S;\n  logic                      If1_BReady_S;\n  logic                [1:0] If1_BResp_D;\n\n  xilinx_mailbox_read_adaptor #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH  ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH  ),\n    .AXI_ID_WIDTH   ( AXI_ID_WIDTH    ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH  )\n  ) xilinx_mailbox_read_adaptor_i (\n    .Clk_CI         ( Clk_CI              ),\n    .Rst_RBI        ( Rst_RBI             ),\n    .ArAddr_DI      ( FromSoc_PS.ar_addr  ),\n    .ArValid_SI     ( FromSoc_PS.ar_valid ),\n    .ArReady_SO     ( FromSoc_PS.ar_ready ),\n    .ArLen_SI       ( FromSoc_PS.ar_len   ),\n    .ArId_DI        ( FromSoc_PS.ar_id    ),\n    .RData_DO       ( FromSoc_PS.r_data   ),\n    .RValid_SO      ( FromSoc_PS.r_valid  ),\n    .RReady_SI      ( FromSoc_PS.r_ready  ),\n    .RId_DO         ( FromSoc_PS.r_id     ),\n    .RResp_DO       ( FromSoc_PS.r_resp   ),\n    .RUser_DO       ( FromSoc_PS.r_user   ),\n    .RLast_SO       ( FromSoc_PS.r_last   ),\n    .If0_ArAddr_DO  ( If0_ArAddr_D        ),\n    .If0_ArValid_SO ( If0_ArValid_S       ),\n    .If0_ArReady_SI ( If0_ArReady_S       ),\n    .If0_RData_DI   ( If0_RData_D         ),\n    .If0_RValid_SI  ( If0_RValid_S        ),\n    .If0_RReady_SO  ( If0_RReady_S        ),\n    .If0_RResp_DI   ( If0_RResp_D         ),\n    .If1_ArAddr_DO  ( If1_ArAddr_D        ),\n    .If1_ArValid_SO ( If1_ArValid_S       ),\n    .If1_ArReady_SI ( If1_ArReady_S       ),\n    .If1_RData_DI   ( If1_RData_D         ),\n    .If1_RValid_SI  ( If1_RValid_S        ),\n    .If1_RReady_SO  ( If1_RReady_S        ),\n    .If1_RResp_DI   ( If1_RResp_D         )\n  );\n\n  xilinx_mailbox_write_adaptor #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH  ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH  ),\n    .AXI_ID_WIDTH   ( AXI_ID_WIDTH    ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH  ),\n    .AXI_STRB_WIDTH ( AXI_STRB_WIDTH  )\n  ) xilinx_mailbox_write_adaptor_i (\n    .Clk_CI         ( Clk_CI              ),\n    .Rst_RBI        ( Rst_RBI             ),\n    .AwAddr_DI      ( FromSoc_PS.aw_addr  ),\n    .AwValid_SI     ( FromSoc_PS.aw_valid ),\n    .AwReady_SO     ( FromSoc_PS.aw_ready ),\n    .AwLen_SI       ( FromSoc_PS.aw_len   ),\n    .AwId_DI        ( FromSoc_PS.aw_id    ),\n    .WData_DI       ( FromSoc_PS.w_data   ),\n    .WStrb_DI       ( FromSoc_PS.w_strb   ),\n    .WValid_SI      ( FromSoc_PS.w_valid  ),\n    .WReady_SO      ( FromSoc_PS.w_ready  ),\n    .BValid_SO      ( FromSoc_PS.b_valid  ),\n    .BReady_SI      ( FromSoc_PS.b_ready  ),\n    .BId_DO         ( FromSoc_PS.b_id     ),\n    .BResp_DO       ( FromSoc_PS.b_resp   ),\n    .BUser_DO       ( FromSoc_PS.b_user   ),\n    .If0_AwAddr_DO  ( If0_AwAddr_D        ),\n    .If0_AwValid_SO ( If0_AwValid_S       ),\n    .If0_AwReady_SI ( If0_AwReady_S       ),\n    .If0_WData_DO   ( If0_WData_D         ),\n    .If0_WStrb_DO   ( If0_WStrb_D         ),\n    .If0_WValid_SO  ( If0_WValid_S        ),\n    .If0_WReady_SI  ( If0_WReady_S        ),\n    .If0_BValid_SI  ( If0_BValid_S        ),\n    .If0_BReady_SO  ( If0_BReady_S        ),\n    .If0_BResp_DI   ( If0_BResp_D         ),\n    .If1_AwAddr_DO  ( If1_AwAddr_D        ),\n    .If1_AwValid_SO ( If1_AwValid_S       ),\n    .If1_AwReady_SI ( If1_AwReady_S       ),\n    .If1_WData_DO   ( If1_WData_D         ),\n    .If1_WStrb_DO   ( If1_WStrb_D         ),\n    .If1_WValid_SO  ( If1_WValid_S        ),\n    .If1_WReady_SI  ( If1_WReady_S        ),\n    .If1_BValid_SI  ( If1_BValid_S        ),\n    .If1_BReady_SO  ( If1_BReady_S        ),\n    .If1_BResp_DI   ( If1_BResp_D         )\n  );\n\n  xilinx_mailbox xilinx_mailbox_i (\n    .S0_AXI_ACLK    ( Clk_CI        ),\n    .S0_AXI_ARESETN ( Rst_RBI       ),\n    .S0_AXI_AWADDR  ( If0_AwAddr_D  ),\n    .S0_AXI_AWVALID ( If0_AwValid_S ),\n    .S0_AXI_AWREADY ( If0_AwReady_S ),\n    .S0_AXI_WDATA   ( If0_WData_D   ),\n    .S0_AXI_WSTRB   ( If0_WStrb_D   ),\n    .S0_AXI_WVALID  ( If0_WValid_S  ),\n    .S0_AXI_WREADY  ( If0_WReady_S  ),\n    .S0_AXI_BRESP   ( If0_BResp_D   ),\n    .S0_AXI_BVALID  ( If0_BValid_S  ),\n    .S0_AXI_BREADY  ( If0_BReady_S  ),\n    .S0_AXI_ARADDR  ( If0_ArAddr_D  ),\n    .S0_AXI_ARVALID ( If0_ArValid_S ),\n    .S0_AXI_ARREADY ( If0_ArReady_S ),\n    .S0_AXI_RDATA   ( If0_RData_D   ),\n    .S0_AXI_RRESP   ( If0_RResp_D   ),\n    .S0_AXI_RVALID  ( If0_RValid_S  ),\n    .S0_AXI_RREADY  ( If0_RReady_S  ),\n\n    .S1_AXI_ACLK    ( Clk_CI        ),\n    .S1_AXI_ARESETN ( Rst_RBI       ),\n    .S1_AXI_AWADDR  ( If1_AwAddr_D  ),\n    .S1_AXI_AWVALID ( If1_AwValid_S ),\n    .S1_AXI_AWREADY ( If1_AwReady_S ),\n    .S1_AXI_WDATA   ( If1_WData_D   ),\n    .S1_AXI_WSTRB   ( If1_WStrb_D   ),\n    .S1_AXI_WVALID  ( If1_WValid_S  ),\n    .S1_AXI_WREADY  ( If1_WReady_S  ),\n    .S1_AXI_BRESP   ( If1_BResp_D   ),\n    .S1_AXI_BVALID  ( If1_BValid_S  ),\n    .S1_AXI_BREADY  ( If1_BReady_S  ),\n    .S1_AXI_ARADDR  ( If1_ArAddr_D  ),\n    .S1_AXI_ARVALID ( If1_ArValid_S ),\n    .S1_AXI_ARREADY ( If1_ArReady_S ),\n    .S1_AXI_RDATA   ( If1_RData_D   ),\n    .S1_AXI_RRESP   ( If1_RResp_D   ),\n    .S1_AXI_RVALID  ( If1_RValid_S  ),\n    .S1_AXI_RREADY  ( If1_RReady_S  ),\n\n    .Interrupt_0    ( Irq0_SO       ),\n    .Interrupt_1    ( Irq1_SO       )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2018 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \"License\"); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n// --=========================================================================--\n//\n// \u2588\u2588\u2557    \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557     \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\n// \u2588\u2588\u2551    \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d    \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\n// \u2588\u2588\u2551 \u2588\u2557 \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2557      \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d   \u2588\u2588\u2551\n// \u2588\u2588\u2551\u2588\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u255d      \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d    \u2588\u2588\u2551\n// \u255a\u2588\u2588\u2588\u2554\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557    \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551        \u2588\u2588\u2551\n//  \u255a\u2550\u2550\u255d\u255a\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d    \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d        \u255a\u2550\u255d\n//\n// --=========================================================================--\n/**\n * Write Channels Adaptor for Xilinx Mailbox\n *\n * Current Maintainers:\n * - Pirmin Vogel   <vogelpi@iis.ee.ethz.ch>\n *\n * AXI-to-AXI-Lite protocol conversion, including data width conversion, ID reflection logic,\n * and mailbox interface arbitration.\n *\n * Since Xilinx AXI-Lite slaves want the aw and w channel signals simultaneously, this\n * converter fakes the aw_ready and accepts the aw_addr whenever no transaction is currently\n * ongoing.\n *\n * This adaptor also properly handles multi-beat write transactions as they occur when, e.g.,\n * a 64-bit master interfaced through a Xilinx data width converter issues a 32-bit write.\n *\n * IMPORTANT NOTE: Only 1 word in 1 data beat is supposed to have non-zero wstrb.\n */\n\nmodule xilinx_mailbox_write_adaptor\n  #(\n    parameter AXI_ADDR_WIDTH = 32,\n    parameter AXI_DATA_WIDTH = 64,\n    parameter AXI_ID_WIDTH   = 10,\n    parameter AXI_USER_WIDTH = 6,\n    parameter AXI_STRB_WIDTH = 8\n   )\n  (\n    input logic                       Clk_CI,\n    input logic                       Rst_RBI,\n\n    // AXI4 interface\n    input  logic [AXI_ADDR_WIDTH-1:0] AwAddr_DI,\n    input  logic                      AwValid_SI,\n    output logic                      AwReady_SO,\n    input  logic                [7:0] AwLen_SI,\n    input  logic   [AXI_ID_WIDTH-1:0] AwId_DI,\n\n    input  logic [AXI_DATA_WIDTH-1:0] WData_DI,\n    input  logic [AXI_STRB_WIDTH-1:0] WStrb_DI,\n    input  logic                      WValid_SI,\n    output logic                      WReady_SO,\n\n    output logic                      BValid_SO,\n    input  logic                      BReady_SI,\n    output logic   [AXI_ID_WIDTH-1:0] BId_DO,\n    output logic                [1:0] BResp_DO,\n    output logic [AXI_USER_WIDTH-1:0] BUser_DO,\n\n    // AXI4-Lite interfaces\n    output logic [AXI_ADDR_WIDTH-1:0] If0_AwAddr_DO,\n    output logic                      If0_AwValid_SO,\n    input  logic                      If0_AwReady_SI, // not used\n    output logic               [31:0] If0_WData_DO,\n    output logic                [3:0] If0_WStrb_DO,\n    output logic                      If0_WValid_SO,\n    input  logic                      If0_WReady_SI,\n    input  logic                      If0_BValid_SI,\n    output logic                      If0_BReady_SO,\n    input  logic                [1:0] If0_BResp_DI,\n\n    output logic [AXI_ADDR_WIDTH-1:0] If1_AwAddr_DO,\n    output logic                      If1_AwValid_SO,\n    input  logic                      If1_AwReady_SI, // not used\n    output logic               [31:0] If1_WData_DO,\n    output logic                [3:0] If1_WStrb_DO,\n    output logic                      If1_WValid_SO,\n    input  logic                      If1_WReady_SI,\n    input  logic                      If1_BValid_SI,\n    output logic                      If1_BReady_SO,\n    input  logic                [1:0] If1_BResp_DI\n  );\n\n  logic                      WAccept_S;\n  logic                      WSel_SN, WSel_SP;\n  logic                      HighWordSel_S;\n  logic                      AddrAligned_S;\n  logic                [7:0] BeatCnt_SN, BeatCnt_SP;\n  logic [AXI_ADDR_WIDTH-1:0] AwAddr_DN, AwAddr_DP;\n  logic   [AXI_ID_WIDTH-1:0] WId_DN, WId_DP;\n  logic               [31:0] WData_D;\n  logic                [3:0] WStrb_D;\n\n  enum logic [1:0] {IDLE, WRITE, RESP} State_SN, State_SP;\n\n  /*\n   * Constant outputs\n   */\n  assign If0_WData_DO  = WData_D;\n  assign If0_WStrb_DO  = WStrb_D;\n  assign If1_WData_DO  = WData_D;\n  assign If1_WStrb_DO  = WStrb_D;\n  assign BUser_DO      = 'b0;\n\n  /*\n   *  ID reflection logic\n   */\n  assign WId_DN = AwId_DI;\n  assign BId_DO = WId_DP;\n\n  /*\n   *  Mailbox interface arbitration based on Bit 12\n   *  - Address 0x0000 - 0x0FFF: Port 0\n   *  - Address 0x1000 - 0x1FFF: Port 1\n   */\n  assign WSel_SN = AwAddr_DI[12];\n\n  /*\n   *  Data width conversion\n   */\n  generate\n    if (AXI_DATA_WIDTH == 64) begin\n\n      // byte-lane steering\n      assign HighWordSel_S = |WStrb_DI[7:4];\n      always_comb begin\n        if ( HighWordSel_S == 1'b1 ) begin\n          WData_D = WData_DI[63:32];\n          WStrb_D = WStrb_DI[7:4];\n        end else begin\n          WData_D = WData_DI[31:0];\n          WStrb_D = WStrb_DI[3:0];\n        end\n      end\n\n    end else begin\n\n      assign HighWordSel_S = 0;\n      always_comb begin\n        WData_D = WData_DI;\n        WStrb_D = WStrb_DI;\n      end\n\n    end\n  endgenerate\n\n  /*\n   *  Transaction acceptance\n   *\n   *  Registering of aw channel for compatibility with Xilinx AXI4-Lite slaves:\n   *\n   *  Xilinx AXI4-Lite slaves want the aw and w channel signals simultaneously!\n   */\n  // aw/w/b channel FSM\n  always_comb begin\n    // default assignments\n    If0_AwAddr_DO  =  'b0;\n    If1_AwAddr_DO  =  'b0;\n    WAccept_S      = 1'b0;\n    AwAddr_DN      = AwAddr_DP;\n    AddrAligned_S  = ~AwAddr_DP[2];\n    BeatCnt_SN     = BeatCnt_SP;\n    AwReady_SO     = 1'b0;\n    If0_AwValid_SO = 1'b0;\n    If0_WValid_SO  = 1'b0;\n    If1_AwValid_SO = 1'b0;\n    If1_WValid_SO  = 1'b0;\n    WReady_SO      = 1'b0;\n    BValid_SO      = 1'b0;\n    If0_BReady_SO  = 1'b0;\n    If1_BReady_SO  = 1'b0;\n    BResp_DO       = If0_BResp_DI;\n    State_SN       = State_SP;\n\n    case (State_SP)\n\n      IDLE: begin\n        AwAddr_DN  = AwAddr_DI;\n        AwReady_SO = 1'b1; // prepare hand shake, recommended by AXI protocol specification\n        if (AwValid_SI == 1'b1) begin\n          WAccept_S  = 1'b1; // store ID, addr, select and byte-lane steering flag\n          BeatCnt_SN = AwLen_SI;\n          State_SN   = WRITE;\n        end\n      end\n\n      WRITE: begin\n        if (WValid_SI == 1'b1) begin\n\n          if (WStrb_D == 'b0) begin // nothing to write downstream, skip this beat\n            WReady_SO  = 1'b1;                         // hand shake with master\n            AwAddr_DN  = AwAddr_DP + AXI_DATA_WIDTH/8; // increment address for next beat\n            BeatCnt_SN = BeatCnt_SP-1;                 // decrement beat counter\n            if (BeatCnt_SP == 'b0) begin\n              State_SN     = RESP;\n            end\n\n          end else begin\n\n            if ( ~WSel_SP ) begin\n              if ( HighWordSel_S & AddrAligned_S ) begin\n                If0_AwAddr_DO = AwAddr_DP + AXI_DATA_WIDTH/8/2;\n              end else begin\n                If0_AwAddr_DO = AwAddr_DP;\n              end\n              If0_AwValid_SO = 1'b1; // apply aw and w channel simultaneously\n              If0_WValid_SO  = 1'b1;\n              if (If0_WReady_SI == 1'b1) begin\n                WReady_SO    = 1'b1;\n                AwAddr_DN    = AwAddr_DP + AXI_DATA_WIDTH/8;\n                BeatCnt_SN   = BeatCnt_SP-1;\n                if (BeatCnt_SP == 'b0) begin\n                  State_SN     = RESP;\n                end\n              end\n            end else begin // WSel_SP\n              if ( HighWordSel_S & AddrAligned_S ) begin\n                If1_AwAddr_DO = AwAddr_DP + AXI_DATA_WIDTH/8/2;\n              end else begin\n                If1_AwAddr_DO = AwAddr_DP;\n              end\n              If1_AwValid_SO = 1'b1;\n              If1_WValid_SO  = 1'b1;\n              if (If1_WReady_SI == 1'b1) begin\n                WReady_SO    = 1'b1;\n                AwAddr_DN    = AwAddr_DP + AXI_DATA_WIDTH/8;\n                BeatCnt_SN   = BeatCnt_SP-1;\n                if (BeatCnt_SP == 'b0) begin\n                  State_SN     = RESP;\n                end\n              end\n            end // WSel_SP\n\n          end // WStrb_D\n        end // WValid\n      end\n\n      RESP: begin\n        BValid_SO = (If0_BValid_SI & ~WSel_SP) | (If1_BValid_SI & WSel_SP);\n        if (BReady_SI == 1'b1) begin\n          if          (If0_BValid_SI & ~WSel_SP) begin\n            If0_BReady_SO = 1'b1;\n            BResp_DO      = If0_BResp_DI;\n            State_SN      = IDLE;\n          end else if (If1_BValid_SI &  WSel_SP) begin\n            If1_BReady_SO = 1'b1;\n            BResp_DO      = If1_BResp_DI;\n            State_SN      = IDLE;\n          end\n        end\n      end\n\n      default: begin\n        State_SN = IDLE;\n      end\n    endcase // State_SP\n  end\n\n  always_ff @(posedge Clk_CI, negedge Rst_RBI) begin\n    if (Rst_RBI == 1'b0) begin\n      WSel_SP <= 1'b0;\n      WId_DP  <=  'b0;\n    end else if (WAccept_S == 1'b1) begin\n      WSel_SP <= WSel_SN;\n      WId_DP  <= WId_DN;\n    end\n  end\n\n  always_ff @(posedge Clk_CI, negedge Rst_RBI) begin\n    if (Rst_RBI == 1'b0) begin\n      BeatCnt_SP <= 'b0;\n      AwAddr_DP  <= 'b0;\n    end else begin\n      BeatCnt_SP <= BeatCnt_SN;\n      AwAddr_DP  <= AwAddr_DN;\n    end\n  end\n\n  always_ff @(posedge Clk_CI, negedge Rst_RBI) begin\n    if (Rst_RBI == 1'b0) begin\n      State_SP <= IDLE;\n    end else begin\n      State_SP <= State_SN;\n    end\n  end\n\nendmodule\n"}
