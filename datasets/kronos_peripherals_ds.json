{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nParameterizable FIFO\nWith a slave write interface and master read interface\n\nNative AXI4-Stream interface, Wishbone compatible\n\ndin         ---  DAT_I\ndin_vld     ---  STB_I\ndin_rdy     ---  ACK_O\ndout        ---  DAT_O\ndout_vld    ---  STB_O\ndout_rdy    ---  ACK_I\n\nAlso has full, empty and size status indicators.\nThe actual size is N+1, because the output is registered.\n*/\n\nmodule fifo #(\n    parameter WIDTH=8,\n    parameter DEPTH=32\n)(\n    input  logic                        clk,\n    input  logic                        rstz,\n    input  logic                        clear,\n    output logic [$clog2(DEPTH):0]      size,\n    output logic                        full,\n    output logic                        empty,\n    input  logic [WIDTH-1:0]            din,\n    input  logic                        din_vld,\n    output logic                        din_rdy,\n    output logic [WIDTH-1:0]            dout,\n    output logic                        dout_vld,\n    input  logic                        dout_rdy\n);\n\nlocalparam PW = $clog2(DEPTH);\n\nlogic [WIDTH-1:0] MEM [DEPTH];\n\nlogic [PW-1:0] wraddr, rdaddr;\nlogic [PW:0] wrptr, rdptr;\nlogic wr_en, rd_en;\n\nlogic fifo_empty;\n\n// ------------------------------------------------------------\n// Write\n\n// write into the fiofo if the fifo is not full\nassign wr_en = din_vld && ~full;\n\nassign wraddr = wrptr[PW-1:0];\n\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz) wrptr <= '0;\n    else if (clear) wrptr <= '0;\n    else if (wr_en) begin\n        MEM[wraddr] <= din;\n\n        wrptr <= wrptr + 1'b1;\n    end\nend\n\nassign din_rdy = wr_en;\n\n// ------------------------------------------------------------\n// Read\n\n// read from the non-empty fifo if the output buffer is empty\n// or the output slave is ready to absorb the currently valid output buffer\nassign rd_en = (~dout_vld | dout_rdy) & ~fifo_empty;\n\nassign rdaddr = rdptr[PW-1:0];\n\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz) begin\n        rdptr <= '0;\n        dout_vld <= 1'b0;\n        dout <= '0;\n    end\n    else if (clear) begin\n        rdptr <= '0;\n        dout_vld <= 1'b0;\n        dout <= '0;\n    end\n    else begin\n        if (rd_en) begin\n            dout <= MEM[rdaddr];\n            dout_vld <= 1'b1;\n\n            rdptr <= rdptr + 1'b1;\n        end\n        else if (dout_vld && dout_rdy) begin\n            dout_vld <= 1'b0;\n            dout <= '0;\n        end\n    end\nend\n\n// ------------------------------------------------------------\n// Status\n// Full status doesn't use an adder chain!\nassign full = (wrptr[PW] != rdptr[PW]) && (wrptr[PW-1:0] == rdptr[PW-1:0]);\nassign fifo_empty = rdptr == wrptr;\n\n// Actual empty status should account for the output register as well\nassign empty = fifo_empty & ~dout_vld;\n\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz) size <= '0;\n    else if (clear) size <= '0;\n    else begin\n        if (wr_en && ~(dout_vld && dout_rdy)) size <= size + 1'b1;\n        else if (~wr_en && (dout_vld && dout_rdy)) size <= size - 1'b1;\n    end\nend\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nGeneric Read Only Memory\n\nFeatures:    \n    - Byte-accessible, 32-bit wide\n    - word-aligned, i.e. addr[1:0] is ignored\n\nNote: For FPGA, this will be inferred as EBR\nThere are 30 EBR or Embedded Block Ram (256x16) in iCE40UP5K.\nFor each KB, this module will use 2 EBR, i.e. 4KB will use 4x2 = 8 EBR\n*/\n\nmodule generic_rom #(\n    parameter AWIDTH = 32,\n    parameter KB = 4\n)(\n    input  logic                        clk,\n    input  logic [AWIDTH-1:0]           addr,\n    output logic [31:0]                 rdata,\n    input  logic                        en\n);\n\nlocalparam NWORDS = 256 * KB;\nlocalparam NWORDS_WIDTH = $clog2(NWORDS);\n\n// instance (256*KB)x32 memory - which will be inferred as EBR with appropriate muxing\nlogic [31:0] MEM [NWORDS];\n\n// There are 256*KB words\nlogic [NWORDS_WIDTH-1:0] word_addr;\n\n// Extract word address from the physical address\nassign word_addr = addr[2+:NWORDS_WIDTH];\n\nalways_ff @(posedge clk) begin\n    if (en) rdata <= MEM[word_addr];\nend\n\n// Initialize EBR if program is defined\n`ifdef PROGRAM\n    `define q(_s) `\"_s`\"\n    initial begin\n        $readmemh(`q(`PROGRAM), MEM);\n    end\n`endif\n\n// ------------------------------------------------------------\n`ifdef verilator\nlogic _unused = &{1'b0\n    , addr[AWIDTH-1:NWORDS_WIDTH]\n    , addr[1:0]\n};\n`endif\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nGeneric Single Port SRAM\n\nFeatures:    \n    - Byte-accessible, 32-bit wide\n    - word-aligned, i.e. addr[1:0] is ignored\n    - Mask should be used to access specific bytes\n    - Can be initialized while building using the macro PROGRAM\n\nNote: For FPGA, this will be inferred as EBR\nThere are 30 EBR or Embedded Block Ram (256x16) in iCE40UP5K.\nFor each KB, this module will use 2 EBR, i.e. 4KB will use 4x2 = 8 EBR\n*/\n\nmodule generic_spram #(\n    parameter AWIDTH = 32,\n    parameter KB = 4\n)(\n    input  logic                        clk,\n    input  logic [AWIDTH-1:0]           addr,\n    input  logic [31:0]                 wdata,\n    output logic [31:0]                 rdata,\n    input  logic                        en,\n    input  logic                        wr_en,\n    input  logic [3:0]                  mask\n);\n\nlocalparam NWORDS = 256 * KB;\nlocalparam NWORDS_WIDTH = $clog2(NWORDS);\n\n// instance (256*KB)x32 memory - which will be inferred as EBR with appropriate muxing\nlogic [31:0] MEM [NWORDS];\n\n// There are 256*KB words\nlogic [NWORDS_WIDTH-1:0] word_addr;\n\n// Extract word address from the physical address\nassign word_addr = addr[2+:NWORDS_WIDTH];\n\nalways_ff @(posedge clk) begin\n    if (en) begin\n        if (wr_en) begin\n            for (int i=0; i<4; i++) begin\n                if (mask[i]) MEM[word_addr][i*8+:8] <= wdata[i*8+:8];\n            end\n        end\n        else rdata <= MEM[word_addr];\n    end\nend\n\n// Initialize EBR if program is defined\n`ifdef PROGRAM\n    `define q(_s) `\"_s`\"\n    initial begin\n        $readmemh(`q(`PROGRAM), MEM);\n    end\n`endif\n\n// ------------------------------------------------------------\n`ifdef verilator\nlogic _unused = &{1'b0\n    , addr[AWIDTH-1:NWORDS_WIDTH]\n    , addr[1:0]\n};\n`endif\n\nendmodule\n"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n128KB Single Port SRAM for iCEBreaker FPGA\n\nFeatures:    \n    - 32K x 32\n    - Byte-accessible, 32-bit wide\n    - word-aligned, i.e. addr[1:0] is ignored\n\nThere are four SP256K (16K x 16) single port SRAM hard macros in iCE40UP5K.\nThis module cascades all of them to construct the main memory for the system.\nThe SP256K are arranged as a 2x2 grid.\n*/\n\nmodule ice40up_sram128K #(\n    parameter AWIDTH = 32\n)(\n    input  logic                        clk,\n    input  logic [AWIDTH-1:0]           addr,\n    input  logic [31:0]                 wdata,\n    output logic [31:0]                 rdata,\n    input  logic                        en,\n    input  logic                        wr_en,\n    input  logic [3:0]                  mask\n);\n\n// There are 32K words (15b)\nlogic [14:0] word_addr;\nlogic bank, rmux;\nlogic [1:0][31:0] bank_rdata;\n\n// Extract word address from the physical address\nassign word_addr = addr[2+:15];\n\n// Bank selection\nassign bank = word_addr[14];\n\ngenerate\n    genvar i,j;\n    for (i=0; i<2; i++) begin : MEMBANK\n        for (j=0; j<2; j++) begin : MEMINST\n            logic cs;\n            logic we;\n            logic [3:0] maskwe;\n\n            assign cs = (bank == i) & en;\n            assign we = cs & wr_en;\n            assign maskwe = {{2{mask[j*2+1]}}, {2{mask[j*2]}}};\n\n            SP256K u_spsram (\n                // Read/write address\n                .AD       (word_addr[13:0]),\n                // Data input\n                .DI       (wdata[j*16 +: 16]),\n                // Write enable mask. Each bit corresponds to one nibble of the data input           \n                .MASKWE   (maskwe),\n                // Write enable, active high           \n                .WE       (we),\n                // Chip select, active high\n                .CS       (cs),\n                // Read/write clock\n                .CK       (clk),\n                // Enable low leakage mode, with no change in the output state. Active high\n                .STDBY    (1'b0),\n                // Enable sleep mode, with the data outputs pulled low. Active high\n                .SLEEP    (1'b0),\n                // Enable power off mode, with no memory content retention. Active low\n                .PWROFF_N (1'b1),             \n                // Data output\n                .DO       (bank_rdata[i][j*16 +: 16])\n            );\n        end\n    end\nendgenerate\n\n// read mux needs latched\nalways_ff @(posedge clk) begin\n    if (en) rmux <= bank;\nend\n\nassign rdata = bank_rdata[rmux];\n\nendmodule"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n64KB Single Port SRAM for iCEBreaker FPGA\n\nFeatures:    \n    - 16K x 32\n    - Byte-accessible, 32-bit wide\n    - word-aligned, i.e. addr[1:0] is ignored\n\nThere are four SP256K (16K x 16) single port SRAM hard macros in iCE40UP5K.\nThis module cascades 2 of them to construct a 32-bit wide memory.\n\nTwo of these can be used as two independently accessible banks of sram.\n\n*/\n\nmodule ice40up_sram64K #(\n    parameter AWIDTH = 32\n)(\n    input  logic                        clk,\n    input  logic [AWIDTH-1:0]           addr,\n    input  logic [31:0]                 wdata,\n    output logic [31:0]                 rdata,\n    input  logic                        en,\n    input  logic                        wr_en,\n    input  logic [3:0]                  mask\n);\n\n// There are 16K words (14b)\nlogic [13:0] word_addr;\n\n// Extract word address from the physical address\nassign word_addr = addr[2+:14];\n\ngenerate\n    genvar j;\n    for (j=0; j<2; j++) begin : MEMINST\n        logic [3:0] maskwe;\n\n        assign maskwe = {{2{mask[j*2+1]}}, {2{mask[j*2]}}};\n\n        SP256K u_spsram (\n            // Read/write address\n            .AD       (word_addr),\n            // Data input\n            .DI       (wdata[j*16 +: 16]),\n            // Write enable mask. Each bit corresponds to one nibble of the data input           \n            .MASKWE   (maskwe),\n            // Write enable, active high           \n            .WE       (wr_en),\n            // Chip select, active high\n            .CS       (en),\n            // Read/write clock\n            .CK       (clk),\n            // Enable low leakage mode, with no change in the output state. Active high\n            .STDBY    (1'b0),\n            // Enable sleep mode, with the data outputs pulled low. Active high\n            .SLEEP    (1'b0),\n            // Enable power off mode, with no memory content retention. Active low\n            .PWROFF_N (1'b1),             \n            // Data output\n            .DO       (rdata[j*16 +: 16])\n        );\n    end\nendgenerate\n\nendmodule"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\nSimple Input Debouncer for groups of GPIO\n*/\n\nmodule input_debouncer #(\n    parameter N = 16,\n    parameter DEBOUNCE = 16\n)(\n    input  logic        clk,\n    input  logic        rstz,\n    output logic [N-1:0] read,\n    input  logic [N-1:0] gpio_in\n);\n\nlogic [DEBOUNCE:0] timer;\nlogic tick;\n\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz) timer <= '0;\n    else if (tick) timer <= '0;\n    else timer <= timer + 1'b1;\nend\n\nassign tick = timer[DEBOUNCE];\n\ngenerate\n    genvar i;\n\n    for (i=0; i<N; i++) begin\n        logic [1:0] sync;\n        logic raw_val;\n        logic [1:0] line;\n        logic [2:0] poll;\n\n        // sync inputs\n        always_ff @(posedge clk) begin\n            sync <= {sync[0], gpio_in[i]};\n        end\n\n        assign raw_val = sync[1];\n        assign poll = {line, raw_val};\n\n        // Record line value on every tick\n        // And if stable (three consecutive reads are the same), latch it\n        always_ff @(posedge clk) begin\n            if (tick) begin\n                line <= {line[0], raw_val};\n\n                if (poll == '0) read[i] <= 1'b0;\n                else if (poll == '1) read[i] <= 1'b1;\n            end\n        end\n    end\nendgenerate\n\nendmodule"}
{"text": "/*\n *  PicoSoC - A simple example SoC using PicoRV32\n *\n *  Copyright (C) 2017  Clifford Wolf <clifford@clifford.at>\n *\n *  Permission to use, copy, modify, and/or distribute this software for any\n *  purpose with or without fee is hereby granted, provided that the above\n *  copyright notice and this permission notice appear in all copies.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n *  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n *  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n *  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n *  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n *  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n *  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n *\n */\n\n`timescale 1 ns / 1 ps\n\n//\n// Simple SPI flash simulation model\n//\n// This model samples io input signals 1ns before the SPI clock edge and\n// updates output signals 1ns after the SPI clock edge.\n//\n// Supported commands:\n//    AB, B9, FF, 03, BB, EB, ED\n//\n// Well written SPI flash data sheets:\n//    Cypress S25FL064L http://www.cypress.com/file/316661/download\n//    Cypress S25FL128L http://www.cypress.com/file/316171/download\n//\n// SPI flash used on iCEBreaker board:\n//    https://www.winbond.com/resource-files/w25q128jv%20dtr%20revb%2011042016.pdf\n//\n\nmodule spiflash (\n    input csb,\n    input clk,\n    inout io0, // MOSI\n    inout io1, // MISO\n    inout io2,\n    inout io3\n);\n    localparam verbose = 0;\n    localparam integer latency = 8;\n    \n    reg [7:0] buffer;\n    integer bitcount = 0;\n    integer bytecount = 0;\n    integer dummycount = 0;\n\n    reg [7:0] spi_cmd;\n    reg [7:0] xip_cmd = 0;\n    reg [23:0] spi_addr;\n\n    reg [7:0] spi_in;\n    reg [7:0] spi_out;\n    reg spi_io_vld;\n\n    reg powered_up = 0;\n\n    localparam [3:0] mode_spi         = 1;\n    localparam [3:0] mode_dspi_rd     = 2;\n    localparam [3:0] mode_dspi_wr     = 3;\n    localparam [3:0] mode_qspi_rd     = 4;\n    localparam [3:0] mode_qspi_wr     = 5;\n    localparam [3:0] mode_qspi_ddr_rd = 6;\n    localparam [3:0] mode_qspi_ddr_wr = 7;\n\n    reg [3:0] mode = 0;\n    reg [3:0] next_mode = 0;\n\n    reg io0_oe = 0;\n    reg io1_oe = 0;\n    reg io2_oe = 0;\n    reg io3_oe = 0;\n\n    reg io0_dout = 0;\n    reg io1_dout = 0;\n    reg io2_dout = 0;\n    reg io3_dout = 0;\n\n    assign #1 io0 = io0_oe ? io0_dout : 1'bz;\n    assign #1 io1 = io1_oe ? io1_dout : 1'bz;\n    assign #1 io2 = io2_oe ? io2_dout : 1'bz;\n    assign #1 io3 = io3_oe ? io3_dout : 1'bz;\n\n    wire io0_delayed;\n    wire io1_delayed;\n    wire io2_delayed;\n    wire io3_delayed;\n\n    assign #1 io0_delayed = io0;\n    assign #1 io1_delayed = io1;\n    assign #1 io2_delayed = io2;\n    assign #1 io3_delayed = io3;\n\n    // 16 MB (128Mb) Flash\n    reg [7:0] memory [0:16*1024*1024-1];\n\n    reg [1023:0] firmware_file;\n    initial begin\n        if (!$value$plusargs(\"firmware=%s\", firmware_file))\n            firmware_file = \"firmware.hex\";\n        $readmemh(firmware_file, memory);\n    end\n\n    task spi_action;\n        begin\n            spi_in = buffer;\n\n            if (bytecount == 1) begin\n                spi_cmd = buffer;\n\n                if (spi_cmd == 8'h ab)\n                    powered_up = 1;\n\n                if (spi_cmd == 8'h b9)\n                    powered_up = 0;\n\n                if (spi_cmd == 8'h ff)\n                    xip_cmd = 0;\n            end\n\n            if (powered_up && spi_cmd == 'h 03) begin\n                if (bytecount == 2)\n                    spi_addr[23:16] = buffer;\n\n                if (bytecount == 3)\n                    spi_addr[15:8] = buffer;\n\n                if (bytecount == 4)\n                    spi_addr[7:0] = buffer;\n\n                if (bytecount >= 4) begin\n                    buffer = memory[spi_addr];\n                    spi_addr = spi_addr + 1;\n                end\n            end\n\n            if (powered_up && spi_cmd == 'h bb) begin\n                if (bytecount == 1)\n                    mode = mode_dspi_rd;\n\n                if (bytecount == 2)\n                    spi_addr[23:16] = buffer;\n\n                if (bytecount == 3)\n                    spi_addr[15:8] = buffer;\n\n                if (bytecount == 4)\n                    spi_addr[7:0] = buffer;\n\n                if (bytecount == 5) begin\n                    xip_cmd = (buffer == 8'h a5) ? spi_cmd : 8'h 00;\n                    mode = mode_dspi_wr;\n                    dummycount = latency;\n                end\n\n                if (bytecount >= 5) begin\n                    buffer = memory[spi_addr];\n                    spi_addr = spi_addr + 1;\n                end\n            end\n\n            if (powered_up && spi_cmd == 'h eb) begin\n                if (bytecount == 1)\n                    mode = mode_qspi_rd;\n\n                if (bytecount == 2)\n                    spi_addr[23:16] = buffer;\n\n                if (bytecount == 3)\n                    spi_addr[15:8] = buffer;\n\n                if (bytecount == 4)\n                    spi_addr[7:0] = buffer;\n\n                if (bytecount == 5) begin\n                    xip_cmd = (buffer == 8'h a5) ? spi_cmd : 8'h 00;\n                    mode = mode_qspi_wr;\n                    dummycount = latency;\n                end\n\n                if (bytecount >= 5) begin\n                    buffer = memory[spi_addr];\n                    spi_addr = spi_addr + 1;\n                end\n            end\n\n            if (powered_up && spi_cmd == 'h ed) begin\n                if (bytecount == 1)\n                    next_mode = mode_qspi_ddr_rd;\n\n                if (bytecount == 2)\n                    spi_addr[23:16] = buffer;\n\n                if (bytecount == 3)\n                    spi_addr[15:8] = buffer;\n\n                if (bytecount == 4)\n                    spi_addr[7:0] = buffer;\n\n                if (bytecount == 5) begin\n                    xip_cmd = (buffer == 8'h a5) ? spi_cmd : 8'h 00;\n                    mode = mode_qspi_ddr_wr;\n                    dummycount = latency;\n                end\n\n                if (bytecount >= 5) begin\n                    buffer = memory[spi_addr];\n                    spi_addr = spi_addr + 1;\n                end\n            end\n\n            spi_out = buffer;\n            spi_io_vld = 1;\n\n            if (verbose) begin\n                if (bytecount == 1)\n                    $write(\"<SPI-START>\");\n                $write(\"<SPI:%02x:%02x>\", spi_in, spi_out);\n            end\n\n        end\n    endtask\n\n    task ddr_rd_edge;\n        begin\n            buffer = {buffer, io3_delayed, io2_delayed, io1_delayed, io0_delayed};\n            bitcount = bitcount + 4;\n            if (bitcount == 8) begin\n                bitcount = 0;\n                bytecount = bytecount + 1;\n                spi_action;\n            end\n        end\n    endtask\n\n    task ddr_wr_edge;\n        begin\n            io0_oe = 1;\n            io1_oe = 1;\n            io2_oe = 1;\n            io3_oe = 1;\n\n            io0_dout = buffer[4];\n            io1_dout = buffer[5];\n            io2_dout = buffer[6];\n            io3_dout = buffer[7];\n\n            buffer = {buffer, 4'h 0};\n            bitcount = bitcount + 4;\n            if (bitcount == 8) begin\n                bitcount = 0;\n                bytecount = bytecount + 1;\n                spi_action;\n            end\n        end\n    endtask\n\n    always @(csb) begin\n        if (csb) begin\n            if (verbose) begin\n                $display(\"\");\n                $fflush;\n            end\n            buffer = 0;\n            bitcount = 0;\n            bytecount = 0;\n            mode = mode_spi;\n            io0_oe = 0;\n            io1_oe = 0;\n            io2_oe = 0;\n            io3_oe = 0;\n        end else\n        if (xip_cmd) begin\n            buffer = xip_cmd;\n            bitcount = 0;\n            bytecount = 1;\n            spi_action;\n        end\n    end\n\n    always @(csb, clk) begin\n        spi_io_vld = 0;\n        if (!csb && !clk) begin\n            if (dummycount > 0) begin\n                io0_oe = 0;\n                io1_oe = 0;\n                io2_oe = 0;\n                io3_oe = 0;\n            end else\n            case (mode)\n                mode_spi: begin\n                    io0_oe = 0;\n                    io1_oe = 1;\n                    io2_oe = 0;\n                    io3_oe = 0;\n                    io1_dout = buffer[7];\n                end\n                mode_dspi_rd: begin\n                    io0_oe = 0;\n                    io1_oe = 0;\n                    io2_oe = 0;\n                    io3_oe = 0;\n                end\n                mode_dspi_wr: begin\n                    io0_oe = 1;\n                    io1_oe = 1;\n                    io2_oe = 0;\n                    io3_oe = 0;\n                    io0_dout = buffer[6];\n                    io1_dout = buffer[7];\n                end\n                mode_qspi_rd: begin\n                    io0_oe = 0;\n                    io1_oe = 0;\n                    io2_oe = 0;\n                    io3_oe = 0;\n                end\n                mode_qspi_wr: begin\n                    io0_oe = 1;\n                    io1_oe = 1;\n                    io2_oe = 1;\n                    io3_oe = 1;\n                    io0_dout = buffer[4];\n                    io1_dout = buffer[5];\n                    io2_dout = buffer[6];\n                    io3_dout = buffer[7];\n                end\n                mode_qspi_ddr_rd: begin\n                    ddr_rd_edge;\n                end\n                mode_qspi_ddr_wr: begin\n                    ddr_wr_edge;\n                end\n            endcase\n            if (next_mode) begin\n                case (next_mode)\n                    mode_qspi_ddr_rd: begin\n                        io0_oe = 0;\n                        io1_oe = 0;\n                        io2_oe = 0;\n                        io3_oe = 0;\n                    end\n                    mode_qspi_ddr_wr: begin\n                        io0_oe = 1;\n                        io1_oe = 1;\n                        io2_oe = 1;\n                        io3_oe = 1;\n                        io0_dout = buffer[4];\n                        io1_dout = buffer[5];\n                        io2_dout = buffer[6];\n                        io3_dout = buffer[7];\n                    end\n                endcase\n                mode = next_mode;\n                next_mode = 0;\n            end\n        end\n    end\n\n    always @(posedge clk) begin\n        if (!csb) begin\n            if (dummycount > 0) begin\n                dummycount = dummycount - 1;\n            end else\n            case (mode)\n                mode_spi: begin\n                    buffer = {buffer, io0};\n                    bitcount = bitcount + 1;\n                    if (bitcount == 8) begin\n                        bitcount = 0;\n                        bytecount = bytecount + 1;\n                        spi_action;\n                    end\n                end\n                mode_dspi_rd, mode_dspi_wr: begin\n                    buffer = {buffer, io1, io0};\n                    bitcount = bitcount + 2;\n                    if (bitcount == 8) begin\n                        bitcount = 0;\n                        bytecount = bytecount + 1;\n                        spi_action;\n                    end\n                end\n                mode_qspi_rd, mode_qspi_wr: begin\n                    buffer = {buffer, io3, io2, io1, io0};\n                    bitcount = bitcount + 4;\n                    if (bitcount == 8) begin\n                        bitcount = 0;\n                        bytecount = bytecount + 1;\n                        spi_action;\n                    end\n                end\n                mode_qspi_ddr_rd: begin\n                    ddr_rd_edge;\n                end\n                mode_qspi_ddr_wr: begin\n                    ddr_wr_edge;\n                end\n            endcase\n        end\n    end\nendmodule"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n\n8-bit Full-Duplex SPI Master\n\n- Control and status\n    * CPOL/CPHA (All SPI Modes Supported)\n    * SPI clock rate = clk/(2 * prescaler+1)\n\nThe SCLK sets its idle value based on CPOL\n\n*/\n\nmodule spi_master #(\n    parameter PRESCALER_WIDTH = 16\n)(\n    input  logic        clk,\n    input  logic        rstz,\n    // SPI PHY\n    output logic        sclk,\n    output logic        mosi,\n    input  logic        miso,\n    // Config\n    input  logic [PRESCALER_WIDTH-1:0] prescaler,\n    input  logic        cpol,\n    input  logic        cpha,\n    // Data interface\n    input  logic [7:0]  din,\n    input  logic        din_vld,\n    output logic        din_rdy,\n    output logic [7:0]  dout,\n    output logic        dout_vld\n);\n\nlogic [PRESCALER_WIDTH-1:0] timer;\nlogic tick;\n\nlogic [4:0] state;\nlogic init, done, active;\n\nlogic [7:0] tx_buffer, rx_buffer;\n\n// ============================================================\n// SPI Master Sequencer\n\n// 17-state counter that starts when there's data to transmit,\n// and counts up on SPI ticks.\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz) state <= '0;\n    else if (din_vld && state == '0) state <= state + 1'b1;\n    else if (active && tick) state <= (done) ? '0 : state + 1'b1;\nend\n\n// sequence control signals\nassign active = state != '0;\nassign init = din_vld && state == '0;\nassign done = state == 5'd16 && tick;\n\n// inform host to prepare the next byte\nassign din_rdy = init;\n\n// Bit timer\nassign tick = timer == prescaler;\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz) timer <= '0;\n    else if (init) timer <= '0;\n    else if (active) timer <= tick ? '0 : timer + 1'b1;\nend\n\n// ============================================================\n// SPI CLK\n\n// The sclk sets its idle state as per CPOL.\n// In an active transmission, the first edge is set\n// as per CPOL/CPHA config. And, subsequent edges toggle on ticks.\n// Until the last edge, where it reverts to CPOL\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz) sclk <= 1'b0;\n    else if (init) sclk <= cpol ? ~cpha : cpha;\n    else if (active) begin\n        if (tick) sclk <= done ? cpol : ~sclk;\n    end\n    else sclk <= cpol;\nend\n\n// ============================================================\n// SPI MOSI\n\n// Shift out bits on every odd state, hence on the even state, the MOSI is stable\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz) tx_buffer <= '0;\n    else if (init) tx_buffer <= din;\n    else if (tick && ~state[0]) tx_buffer <= tx_buffer << 1;\nend\n\nassign mosi = tx_buffer[7];\n\n// ============================================================\n// SPI MISO\n\n// Shift in bits on every even state, expecting the slave has kept MISO stable\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz) rx_buffer <= '0;\n    else if (init) rx_buffer <= '0;\n    else if (tick && state[0] && ~done) rx_buffer <= {rx_buffer[6:0], miso};\nend\n\nassign dout = rx_buffer;\nassign dout_vld = done;\n\nendmodule"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n// 32-bit byte-addressable Single Port SRAM model\n\nmodule spsram32_model #(\n    parameter WORDS = 256,\n    parameter AWIDTH = 32,\n    parameter logic MASK_WR_ONLY = 0\n)(\n    input  logic                clk,\n    input  logic [AWIDTH-1:0]   addr,\n    input  logic [31:0]         wdata,\n    output logic [31:0]         rdata,\n    input  logic                en,\n    input  logic                wr_en,\n    input  logic [3:0]          mask\n);\n\nparameter D = $clog2(WORDS);\n\nlogic [31:0] MEM [WORDS];\nlogic [D-1:0] adr;\n\nassign adr = addr[2+:D];\n\nalways_ff @(posedge clk) begin\n    if (en) begin\n        if (wr_en) begin\n            for (int i=0; i<4; i++) begin\n                if (mask[i]) MEM[adr][i*8+:8] <= wdata[i*8+:8];\n            end\n        end\n        else begin\n            if (MASK_WR_ONLY) rdata <=  MEM[adr];\n            else begin\n                for (int i=0; i<4; i++) begin\n                    if (mask[i]) rdata[i*8+:8] <= MEM[adr][i*8+:8];\n                    else rdata[i*8+:8] <= 'x;\n                end\n            end\n        end\n    end\nend\n\nendmodule"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n\n8-bit UART (Serial) TX\n\nRuntime configurable baud rate (default 115200) = clk/(prescaler+1)\n\nSerial Protocol\n\n+-----+         +----+----+----+----+----+----+----+----+--------+\n      | START=0 | D0 | D1 | D2 | D3 | D4 | D5 | D6 | D7 | STOP=1\n      +---------+----+----+----+----+----+----+----+----+\n\n+ 1 extra stop bit\n\n*/\n\nmodule uart_tx #(\n    parameter PRESCALER_WIDTH = 16\n)(\n    input  logic        clk,\n    input  logic        rstz,\n    // UART TX PHY\n    output logic        tx,\n    // Config\n    input  logic [PRESCALER_WIDTH-1:0] prescaler,\n    // Data interface\n    input  logic [7:0]  din,\n    input  logic        din_vld,\n    output logic        din_rdy\n);\n\nlogic [PRESCALER_WIDTH-1:0] timer;\nlogic tick;\n\nlogic [3:0] state;\nlogic init, done, active;\n\nlogic [9:0] buffer;\n\n// ============================================================\n// UART TX Sequencer\n\n// 12-state counter that starts when there's data to transmit\n// and counts up on UART ticks\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz)\n        state <= '0;\n    else if (din_vld && state == '0)\n        state <= state + 1'b1;\n    else if (active && tick)\n        state <= (done) ? '0 : state + 1'b1;\nend\n\n// sequence control signals\nassign active = state != '0;\nassign init = din_vld && state == '0;\nassign done = state == 4'd11 && tick;\n\n// inform host to prepare the next byte\nalways_ff @(posedge clk) begin\n    din_rdy <= init;\nend\n\n// Bit timer\nassign tick = timer == prescaler;\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz)\n\t\ttimer <= '0;\n\telse if (init)\n        timer <= '0;\n    else if (active)\n        timer <= tick ? '0 : timer + 1'b1;\nend\n\n// Transmit buffer\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz)\n        buffer <= '1;\n    else if (init)\n        buffer <= {1'b1, din, 1'b0};\n    else if (active && tick)\n        buffer <= {1'b1, buffer[9:1]};\nend\n\nassign tx = buffer[0];\n\nendmodule"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n\n8-bit Full-Duplex SPI Master with RX/TX Queue\n\n- Wishbone slave, 8b data bus\n- Control and status\n    * CPOL/CPHA (All SPI Modes Supported)\n    * SPI clock rate = clk/(2 * prescaler+1)\n    * clear TX/RX Queue\n    * Size of the TX/RX Queue\n- Peek at RX Queue without reading it\n- No Chip Select - implementation left to the Host\n\nWishbone slave interface\n    - Registered Feedback Bus Cycle, Advanced\n\n*/\n\nmodule wb_spi_master #(\n    parameter BUFFER=32,\n    parameter PRESCALER_WIDTH = 16\n)(\n    input  logic        clk,\n    input  logic        rstz,\n    // SPI PHY\n    output logic        sclk,\n    output logic        mosi,\n    input  logic        miso,\n    // Control and Status\n    input  logic [PRESCALER_WIDTH-1:0]  prescaler,\n    input  logic                        cpol,\n    input  logic                        cpha,\n    input  logic                        tx_clear,\n    input  logic                        rx_clear,\n    output logic [$clog2(BUFFER):0]     tx_size,\n    output logic [$clog2(BUFFER):0]     rx_size,\n    // data interface\n    input  logic [7:0]  dat_i,\n    output logic [7:0]  dat_o,\n    input  logic        we_i,\n    input  logic        stb_i,\n    output logic        ack_o\n);\n\nlogic txq_ack;\n\nlogic txq_full, txq_empty;\nlogic [$clog2(BUFFER):0] txq_size;\n\nlogic txq_din_vld, txq_din_rdy;\nlogic txq_dout_vld, txq_dout_rdy;\nlogic [7:0] txq_din, txq_dout;\n\nlogic rxq_ack;\n\nlogic rxq_full, rxq_empty;\nlogic [$clog2(BUFFER):0] rxq_size;\n\nlogic rxq_din_vld, rxq_din_rdy;\nlogic rxq_dout_vld, rxq_dout_rdy;\nlogic [7:0] rxq_din, rxq_dout;\n\n\n// ============================================================\n// TX Queue\n// Shove data straight into the TX fifo\n// If the fifo is full, the new data is quietly dropped\n\nfifo #(\n    .WIDTH(8     ),\n    .DEPTH(BUFFER)\n) u_txq (\n    .clk     (clk         ),\n    .rstz    (rstz        ),\n    .clear   (tx_clear    ),\n    .size    (txq_size    ),\n    .full    (txq_full    ),\n    .empty   (txq_empty   ),\n    .din     (txq_din     ),\n    .din_vld (txq_din_vld ),\n    .din_rdy (txq_din_rdy ),\n    .dout    (txq_dout    ),\n    .dout_vld(txq_dout_vld),\n    .dout_rdy(txq_dout_rdy)\n);\n\nassign txq_din = dat_i;\nassign txq_din_vld = stb_i & we_i & txq_ack;\n\n// ============================================================\n// RX Queue\n// Send out data from the RX fifo when requested\n// If the fifo is empty, the send out zeros\n\nfifo #(\n    .WIDTH(8     ),\n    .DEPTH(BUFFER)\n) u_rxq (\n    .clk     (clk         ),\n    .rstz    (rstz        ),\n    .clear   (rx_clear    ),\n    .size    (rxq_size    ),\n    .full    (rxq_full    ),\n    .empty   (rxq_empty   ),\n    .din     (rxq_din     ),\n    .din_vld (rxq_din_vld ),\n    .din_rdy (rxq_din_rdy ),\n    .dout    (rxq_dout    ),\n    .dout_vld(rxq_dout_vld),\n    .dout_rdy(rxq_dout_rdy)\n);\n\nassign dat_o = rxq_dout;\nassign rxq_dout_rdy = stb_i & ~we_i & rxq_ack;\n\n// ============================================================\n// Host Interface\n\n// register the Read/Write ACK, always ack\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz) begin\n        txq_ack <= 1'b0;\n        rxq_ack <= 1'b0;\n    end\n    else begin\n        txq_ack <= stb_i & we_i;\n        rxq_ack <= stb_i & ~we_i;\n    end\nend\n\n// size is already registered in the fifo\nassign tx_size = txq_size;\nassign rx_size = rxq_size;\n\n// Advanced synchronous terminated burst\nassign ack_o = stb_i & (txq_ack | rxq_ack);\n\n// ============================================================\n// SPI Master Phy\n\nspi_master #(\n    .PRESCALER_WIDTH(PRESCALER_WIDTH)\n)u_spim (\n    .clk      (clk         ),\n    .rstz     (rstz        ),\n    .sclk     (sclk        ),\n    .mosi     (mosi        ),\n    .miso     (miso        ),\n    .prescaler(prescaler   ),\n    .cpol     (cpol        ),\n    .cpha     (cpha        ),\n    .din      (txq_dout    ),\n    .din_vld  (txq_dout_vld),\n    .din_rdy  (txq_dout_rdy),\n    .dout     (rxq_din     ),\n    .dout_vld (rxq_din_vld )\n);\n\n// ------------------------------------------------------------\n`ifdef verilator\nlogic _unused = &{1'b0\n    , txq_din_rdy\n    , txq_full\n    , txq_empty\n    , rxq_dout_vld\n    , rxq_din_rdy\n    , rxq_full\n    , rxq_empty\n};\n`endif\n\nendmodule"}
{"text": "// Copyright (c) 2020 Sonal Pinto\n// SPDX-License-Identifier: Apache-2.0\n\n/*\n\n8-bit UART (Serial) TX with TX Queue\n\n- Wishbone slave, 8b data bus\n- Control and status\n    * baud rate (default 115200) = clk/(prescaler+1)\n    * clear TX Queue\n    * Size of the TX Queue\n\nWishbone slave interface\n    - Registered Feedback Bus Cycle, Advanced\n*/\n\nmodule wb_uart_tx #(\n    parameter BUFFER=32,\n    parameter PRESCALER_WIDTH = 16\n)(\n    input  logic        clk,\n    input  logic        rstz,\n    // UART TX\n    output logic        tx,\n    // Control and Status\n    input  logic [PRESCALER_WIDTH-1:0]  prescaler,\n    input  logic                        clear,\n    output logic [$clog2(BUFFER):0]     size,\n    // data interface\n    input  logic [7:0]  dat_i,\n    input  logic        we_i,\n    input  logic        stb_i,\n    output logic        ack_o\n);\n\nlogic ack;\nlogic txq_full, txq_empty;\nlogic [$clog2(BUFFER):0] txq_size;\n\nlogic txq_din_vld, txq_din_rdy;\nlogic txq_dout_vld, txq_dout_rdy;\nlogic [7:0] txq_din, txq_dout;\n\n// ============================================================\n// TX Queue\n// Shove data straight into the TX fifo\n// If the fifo is full, the new data is quietly dropped\n\nfifo #(\n    .WIDTH(8     ),\n    .DEPTH(BUFFER)\n) u_txq (\n    .clk     (clk         ),\n    .rstz    (rstz        ),\n    .clear   (clear       ),\n    .size    (txq_size    ),\n    .full    (txq_full    ),\n    .empty   (txq_empty   ),\n    .din     (txq_din     ),\n    .din_vld (txq_din_vld ),\n    .din_rdy (txq_din_rdy ),\n    .dout    (txq_dout    ),\n    .dout_vld(txq_dout_vld),\n    .dout_rdy(txq_dout_rdy)\n);\n\nassign txq_din = dat_i;\nassign txq_din_vld = stb_i & we_i & ack;\n\n// register the ACK, always ack\nalways_ff @(posedge clk or negedge rstz) begin\n    if (~rstz) ack <= 1'b0;\n    else ack <= stb_i & we_i;\nend\n\n// Advanced synchronous terminated burst\nassign ack_o = stb_i & ack;\n\n// size is already registered in the fifo\nassign size = txq_size;\n\n// ============================================================\n// UART TX Phy\n\nuart_tx #(\n    .PRESCALER_WIDTH(PRESCALER_WIDTH)\n) u_tx (\n    .clk      (clk         ),\n    .rstz     (rstz        ),\n    .tx       (tx          ),\n    .prescaler(prescaler   ),\n    .din      (txq_dout    ),\n    .din_vld  (txq_dout_vld),\n    .din_rdy  (txq_dout_rdy)\n);\n\n// ------------------------------------------------------------\n`ifdef verilator\nlogic _unused = &{1'b0\n    , txq_din_rdy\n    , txq_full\n    , txq_empty\n};\n`endif\n\nendmodule"}
