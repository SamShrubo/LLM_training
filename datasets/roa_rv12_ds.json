{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Cache Bus Interface Statemachine                             //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2021 ROA Logic BV                     //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_cache_biu_ctrl\\n', 'import riscv_cache_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter                        XLEN           = 32,\\n', '  parameter                        PLEN           = XLEN,\\n', '\\n', '  parameter                        SIZE           = 64,\\n', '  parameter                        BLOCK_SIZE     = XLEN,\\n', '  parameter                        WAYS           = 2,\\n', '\\n', '  parameter                        INFLIGHT_DEPTH = 2,\\n', '  parameter                        BIUTAG_SIZE    = 2,\\n', '\\n', '  localparam                       BLK_BITS      = no_of_block_bits(BLOCK_SIZE),\\n', '  localparam                       INFLIGHT_BITS = $clog2(INFLIGHT_DEPTH+1)\\n', ')\\n', '(\\n', '  input  logic                     rst_ni,\\n', '  input  logic                     clk_i,\\n', '\\n', '  input  logic                     flush_i,              //flush pipe\\n', '\\n', '  input  biucmd_t                  biucmd_i,\\n', '  output logic                     biucmd_ack_o,\\n', '  output logic                     biucmd_busy_o,\\n', '  input  logic                     biucmd_noncacheable_req_i,\\n', '  output logic                     biucmd_noncacheable_ack_o,\\n', '  input  logic [BIUTAG_SIZE  -1:0] biucmd_tag_i,\\n', '  output logic [INFLIGHT_BITS-1:0] inflight_cnt_o,\\n', '\\n', '  input  logic                     req_i,\\n', '  input  logic [PLEN         -1:0] adr_i,\\n', '  input  biu_size_t                size_i,\\n', '  input  biu_prot_t                prot_i,\\n', '  input  logic                     lock_i,\\n', '  input  logic                     we_i,\\n', '  input  logic [XLEN/8       -1:0] be_i,\\n', '  input  logic [XLEN         -1:0] d_i,\\n', '\\n', '  input  logic [PLEN         -1:0] evictbuffer_adr_i,\\n', '  input  logic [BLK_BITS     -1:0] evictbuffer_d_i,\\n', '  output logic                     in_biubuffer_o,\\n', '  output logic [BLK_BITS     -1:0] biubuffer_o,          //data to cache-ctrl\\n', '  output logic [BLK_BITS     -1:0] biu_line_o,           //data to be written in DAT memory\\n', '  output logic                     biu_line_dirty_o,     //data to be written into DAT memory is dirty\\n', '\\n', '\\n', '  //To BIU\\n', '  output logic                     biu_stb_o,            //access request\\n', '  input  logic                     biu_stb_ack_i,        //access acknowledge\\n', '  input  logic                     biu_d_ack_i,          //BIU needs new data (biu_d_o)\\n', '  output logic [PLEN         -1:0] biu_adri_o,           //access start address\\n', '  input  logic [PLEN         -1:0] biu_adro_i,\\n', '  output biu_size_t                biu_size_o,           //transfer size\\n', '  output biu_type_t                biu_type_o,           //burst type\\n', '  output logic                     biu_lock_o,           //locked transfer\\n', '  output biu_prot_t                biu_prot_o,           //protection bits\\n', '  output logic                     biu_we_o,             //write enable\\n', '  output logic [XLEN         -1:0] biu_d_o,              //write data\\n', '  input  logic [XLEN         -1:0] biu_q_i,              //read data\\n', '  input  logic                     biu_ack_i,            //transfer acknowledge\\n', '  input  logic                     biu_err_i,            //transfer error\\n', '  output logic [BIUTAG_SIZE  -1:0] biu_tagi_o,\\n', '  input  logic [BIUTAG_SIZE  -1:0] biu_tago_i\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Constants\\n', '  //\\n', '  localparam SETS          = no_of_sets(SIZE, BLOCK_SIZE, WAYS);\\n', '  localparam BLK_OFFS_BITS = no_of_block_offset_bits(BLOCK_SIZE);\\n', '  localparam DAT_OFFS_BITS = no_of_data_offset_bits(XLEN, BLK_BITS);\\n', '  localparam BURST_SIZE    = burst_size(XLEN, BLK_BITS);\\n', '\\n', '  localparam BURST_BITS = $clog2(BURST_SIZE);\\n', '  localparam BURST_OFFS = XLEN / 8;\\n', '  localparam BURST_LSB  = $clog2(BURST_OFFS);\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Functions\\n', '  //\\n', '\\n', '  //convert burst type to counter length (actually length -1)\\n', '  function automatic [3:0] biu_type2cnt;\\n', '    input biu_type_t biu_type;\\n', '\\n', '    case (biu_type)\\n', '      SINGLE : biu_type2cnt =  0;\\n', '      INCR   : biu_type2cnt =  0;\\n', '      WRAP4  : biu_type2cnt =  3;\\n', '      INCR4  : biu_type2cnt =  3;\\n', '      WRAP8  : biu_type2cnt =  7;\\n', '      INCR8  : biu_type2cnt =  7;\\n', '      WRAP16 : biu_type2cnt = 15;\\n', '      INCR16 : biu_type2cnt = 15;\\n', \"      default: biu_type2cnt = 4'hx; //OOPS\\n\", '    endcase\\n', '  endfunction: biu_type2cnt\\n', '\\n', '\\n', '  //Byte-Enable driven MUX\\n', '  function automatic [XLEN-1:0] be_mux;\\n', '    input [XLEN/8-1:0] be;\\n', '    input [XLEN  -1:0] data_old; //old data\\n', '    input [XLEN  -1:0] data_new; //new data\\n', '\\n', '    for (int i=0; i<XLEN/8;i++)\\n', '      be_mux[i*8 +: 8] = be[i] ? data_new[i*8 +: 8] : data_old[i*8 +: 8];\\n', '  endfunction: be_mux\\n', '\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  genvar  way;\\n', '  integer n;\\n', '\\n', '\\n', '  /* Bus Interface State Machine Section\\n', '   */\\n', '  enum logic [               1:0] {IDLE, WAIT4BIU, BURST} biufsm_state;\\n', '\\n', '  logic      [BURST_SIZE    -1:0] biubuffer_valid;\\n', '  logic                           biubuffer_dirty;\\n', '  logic      [DAT_OFFS_BITS -1:0] dat_offset;\\n', '\\n', '  logic                           biu_adro_eq_cache_adr;\\n', '  logic      [XLEN          -1:0] biu_q;\\n', '\\n', '  logic      [PLEN          -1:0] biu_adri_hold;\\n', '  logic      [XLEN          -1:0] biu_d_hold;\\n', '  logic                           biu_we_hold;\\n', '\\n', '  logic      [BURST_BITS    -1:0] burst_cnt;\\n', '\\n', '  logic      [INFLIGHT_BITS -1:0] discard;\\n', ' \\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if (!rst_ni)\\n', '    begin\\n', '        biufsm_state <= IDLE;\\n', \"        biucmd_busy_o <= 1'b0;\\n\", '    end\\n', '    else\\n', '    begin\\n', '        unique case (biufsm_state)\\n', '          IDLE    : unique case (biucmd_i)\\n', '                      BIUCMD_NOP     : ; //do nothing\\n', '                                         //non-cacheable transfers may be initiated\\n', '\\n', '                      BIUCMD_READWAY : begin\\n', \"                                           biucmd_busy_o <= 1'b1;\\n\", '\\n', '                                           //read a way from main memory\\n', '                                           if (biu_stb_ack_i)\\n', '                                           begin\\n', '                                               biufsm_state <= BURST;\\n', '                                           end\\n', '                                           else\\n', '                                           begin\\n', '                                               //BIU is not ready to start a new transfer\\n', '                                               biufsm_state <= WAIT4BIU;\\n', '                                           end\\n', '                                       end\\n', '\\n', '                      BIUCMD_WRITEWAY: begin\\n', \"                                           biucmd_busy_o <= 1'b1;\\n\", '\\n', '                                           //write way back to main memory\\n', '                                           if (biu_stb_ack_i)\\n', '                                           begin\\n', '                                               biufsm_state <= BURST;\\n', '                                           end\\n', '                                           else\\n', '                                           begin\\n', '                                               //BIU is not ready to start a new transfer\\n', '                                               biufsm_state <= WAIT4BIU;\\n', '                                           end\\n', '                                       end\\n', '                       endcase\\n', '\\n', '          WAIT4BIU : if (biu_stb_ack_i)\\n', '                     begin\\n', '                         //BIU acknowledged burst transfer\\n', '                         biufsm_state <= BURST;\\n', '                     end\\n', '\\n', '          BURST    : if (biu_err_i || (~|burst_cnt && biu_ack_i))\\n', '                     begin\\n', '/*\\n', '                         unique case (biucmd_i)\\n', '                           BIUCMD_NOP     : begin\\n', '                                                biufsm_state  <= IDLE;\\n', \"                                                biucmd_busy_o <= 1'b0;\\n\", '                                            end\\n', '\\n', '\\n', '                           BIUCMD_READWAY : begin\\n', \"                                                biucmd_busy_o <= 1'b1;\\n\", '\\n', '                                                //read a way from main memory\\n', '                                                if (biu_stb_ack_i)\\n', '                                                begin\\n', '                                                    biufsm_state <= BURST;\\n', '                                                end\\n', '                                                else\\n', '                                                begin\\n', '                                                    //BIU is not ready to start a new transfer\\n', '                                                    biufsm_state <= WAIT4BIU;\\n', '                                                end\\n', '                                            end\\n', '\\n', '                           BIUCMD_WRITEWAY: begin\\n', \"                                                biucmd_busy_o <= 1'b1;\\n\", '\\n', '                                                //write way back to main memory\\n', '                                                if (biu_stb_ack_i)\\n', '                                                begin\\n', '                                                    biufsm_state <= BURST;\\n', '                                                end\\n', '                                                else\\n', '                                                begin\\n', '                                                    //BIU is not ready to start a new transfer\\n', '                                                    biufsm_state <= WAIT4BIU;\\n', '                                                end\\n', '                                            end\\n', '                            endcase\\n', '*/\\n', '                         biufsm_state  <= IDLE;\\n', \"                         biucmd_busy_o <= 1'b0;\\n\", '\\n', '                     end\\n', '        endcase\\n', '    end\\n', '\\n', '\\n', '\\n', '  //address check, used in a few places\\n', '  assign biu_adro_eq_cache_adr = (biu_adro_i[PLEN-1:BURST_LSB] == adr_i[PLEN-1:BURST_LSB]);\\n', '\\n', '\\n', '  //handle writing bits in read-cache-line\\n', '  assign biu_q = we_i && biu_adro_eq_cache_adr ? be_mux(be_i, biu_q_i, d_i)\\n', '                                               : biu_q_i;\\n', '\\n', '  //BIU Buffer\\n', '  always @(posedge clk_i)\\n', '    unique case (biufsm_state)\\n', '     IDLE   : begin\\n', '                  if (biucmd_i == BIUCMD_WRITEWAY) biubuffer_o <= evictbuffer_d_i >> XLEN;\\n', \"                  biubuffer_valid <=  'h0;\\n\", \"\\t\\t  biubuffer_dirty <= 1'b0;\\n\", '              end\\n', '\\n', '     BURST  : begin\\n', '                  if (!biu_we_hold)\\n', '                  begin\\n', '                      if (biu_ack_i)   //latch incoming data when transfer-acknowledged\\n', '                      begin\\n', '                          biubuffer_o    [ biu_adro_i[BLK_OFFS_BITS-1 -: DAT_OFFS_BITS] * XLEN +: XLEN ] <= biu_q;\\n', \"                          biubuffer_valid[ biu_adro_i[BLK_OFFS_BITS-1 -: DAT_OFFS_BITS] ]                <= 1'b1;\\n\", '                          biubuffer_dirty                                                                <= biubuffer_dirty | we_i; //& biu_adro_eq_cache_adr_dly\\n', '                      end\\n', '                  end\\n', '\\t\\t  else\\n', '                  begin\\n', '                      if (biu_d_ack_i)\\n', '                      begin\\n', '                          biubuffer_o     <= biubuffer_o >> XLEN; //next data to transfer (to BIU)\\n', \"                          biubuffer_valid <=  'h0;\\n\", \"                          biubuffer_dirty <= 1'b0;\\n\", '                      end\\n', '                  end\\n', '              end\\n', '      default: ;\\n', '    endcase\\n', '\\n', '\\n', '  //Shift amount for data\\n', '  assign dat_offset = adr_i[BLK_OFFS_BITS-1 -: DAT_OFFS_BITS];\\n', '\\n', '\\n', '  //Is requested data in biubuffer?\\n', '  assign in_biubuffer_o = req_i & (biu_adri_hold[PLEN-1:BLK_OFFS_BITS] == adr_i[PLEN-1:BLK_OFFS_BITS]) & (biubuffer_valid >> dat_offset);\\n', '\\n', '\\n', '  //Data to be written into DAT memory\\n', '  //Data is in biubuffer, except for last transaction\\n', '  always_comb\\n', '    begin\\n', '        biu_line_o = biubuffer_o;\\n', '        biu_line_o[ biu_adro_i[BLK_OFFS_BITS-1 -: DAT_OFFS_BITS] * XLEN +: XLEN] = biu_q;\\n', '    end\\n', '\\n', '  assign biu_line_dirty_o = biubuffer_dirty | we_i;\\n', '\\n', '\\n', '  //Acknowledge burst to memfsm\\n', '  always_comb\\n', '    unique case (biufsm_state)\\n', '      BURST   : biucmd_ack_o = (~|burst_cnt & biu_ack_i ) | biu_err_i;\\n', \"      default : biucmd_ack_o = 1'b0;\\n\", '    endcase\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', '    unique case (biufsm_state)\\n', \"      IDLE  : burst_cnt <= {BURST_BITS{1'b1}};\\n\", '      BURST : if (biu_ack_i) burst_cnt <= burst_cnt -1;\\n', '    endcase\\n', '\\n', '\\n', '  //Keep track of inflight transactions\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni) inflight_cnt_o <= 'h0;\\n\", '    else\\n', '      unique case ({biu_stb_ack_i, biu_ack_i | biu_err_i})\\n', \"        2'b01  : inflight_cnt_o <= inflight_cnt_o -1;\\n\", \"        2'b10  : inflight_cnt_o <= inflight_cnt_o +1 + biu_type2cnt(biu_type_o);\\n\", '        default: ; //do nothing\\n', '      endcase\\n', '\\n', '      \\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) discard <= 'h0;\\n\", '    else if (flush_i)\\n', '    begin\\n', '        if (|inflight_cnt_o && (biu_ack_i | biu_err_i)) discard <= inflight_cnt_o -1;\\n', '        else                                            discard <= inflight_cnt_o;\\n', '    end\\n', '    else if (|discard       && (biu_ack_i | biu_err_i)) discard <= discard -1;\\n', '\\n', '\\n', '  assign biucmd_noncacheable_ack_o = biu_ack_i & ~flush_i & ~|discard;\\n', '\\n', '\\n', '  //output BIU signals asynchronously for speed reasons. BIU will synchronize ...\\n', '  always_comb\\n', '    unique case (biufsm_state)\\n', '      IDLE    : unique case (biucmd_i)\\n', '                  BIUCMD_NOP      : begin\\n', '                                        biu_stb_o  = biucmd_noncacheable_req_i;\\n', '                                        biu_adri_o = adr_i[0 +: PLEN];\\n', '                                        biu_we_o   = we_i;\\n', '                                        biu_d_o    = d_i;\\n', '                                    end\\n', '\\n', '                  BIUCMD_READWAY  : begin\\n', \"                                        biu_stb_o  = 1'b1;\\n\", \"                                        biu_adri_o = {adr_i[PLEN-1 : BURST_LSB],{BURST_LSB{1'b0}}};\\n\", \"                                        biu_we_o   = 1'b0;\\n\", \"                                        biu_d_o    =  'hx;\\n\", '                                    end\\n', '\\n', '                  BIUCMD_WRITEWAY : begin\\n', \"                                        biu_stb_o  = 1'b1;\\n\", '                                        biu_adri_o = evictbuffer_adr_i;\\n', \"                                        biu_we_o   = 1'b1;\\n\", '                                        biu_d_o    = evictbuffer_d_i[0 +: XLEN];\\n', '                                    end\\n', '\\n', '                endcase\\n', '\\n', '      WAIT4BIU: begin\\n', '                    //stretch biu_*_o signals until BIU acknowledges strobe\\n', \"                    biu_stb_o  = 1'b1;\\n\", '                    biu_adri_o = biu_adri_hold;\\n', '                    biu_we_o   = biu_we_hold;\\n', '                    biu_d_o    = biu_d_hold;\\n', '                end\\n', '\\n', '      BURST   : begin\\n', '                    //continue burst operation\\n', \"                    biu_stb_o  = 1'b0;                    //don't start new (burst) transaction\\n\", \"                    biu_adri_o =  'hx;                    //don't care\\n\", \"                    biu_we_o   = 1'bx;                    //don't care\\n\", '                    biu_d_o    = biubuffer_o[0 +: XLEN];  //next data to transfer\\n', '                end\\n', '\\n', '      default : begin\\n', \"                    biu_stb_o  = 1'b0; //don't start a transaction\\n\", \"                    biu_adri_o =  'hx; //don't care\\n\", \"                    biu_we_o   = 1'bx; //don't care\\n\", \"                    biu_d_o    =  'hx; //don't care\\n\", '                end\\n', '    endcase\\n', '\\n', '\\n', '  //store biu_we/adri/d used when stretching biu_stb\\n', '  always @(posedge clk_i)\\n', '    if (biufsm_state == IDLE)\\n', '    begin\\n', '        biu_adri_hold <= biu_adri_o;\\n', '        biu_we_hold   <= biu_we_o;\\n', '        biu_d_hold    <= biu_d_o;\\n', '    end\\n', '\\n', '\\n', '  //BIU TAG\\n', '  assign biu_tagi_o = biucmd_tag_i;\\n', '\\n', '\\n', '  //transfer size\\n', '  assign biu_size_o = biucmd_noncacheable_req_i\\n', '                    ? size_i\\n', '                    : XLEN==64 ? DWORD : WORD;\\n', '\\n', ' \\n', '  //Protection bits\\n', \"  assign biu_prot_o = biu_prot_t'(prot_i | (biucmd_noncacheable_req_i ? PROT_NONCACHEABLE : PROT_CACHEABLE));\\n\", '  assign biu_lock_o = lock_i;\\n', '  \\n', '\\n', '  //burst length\\n', '  always_comb\\n', '    if ( (biufsm_state == IDLE) && (biucmd_i == BIUCMD_NOP) )\\n', '      biu_type_o = INCR;\\n', '    else\\n', '    unique case(BURST_SIZE)\\n', '       16     : biu_type_o = WRAP16;\\n', '       8      : biu_type_o = WRAP8;\\n', '       default: biu_type_o = WRAP4;\\n', '    endcase\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Cache Memory Block                                           //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2021 ROA Logic BV                     //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', '/*\\n', ' * Actual Cache memories\\n', ' * Memory is written when biucmd_ack_i = 1\\n', ' * Memory read must stall then\\n', ' */\\n', '\\n', '\\n', 'module riscv_cache_memory\\n', 'import riscv_cache_pkg::*;\\n', '#(\\n', '  parameter XLEN          = 32,\\n', '  parameter PLEN          = XLEN == 32 ? 34 : 56,\\n', '  parameter SIZE          = 4,\\n', '  parameter BLOCK_SIZE    = XLEN,\\n', '  parameter WAYS          = 2,\\n', '\\n', '  parameter TECHNOLOGY    = \"GENERIC\",\\n', '\\n', '  localparam SETS          = no_of_sets(SIZE, BLOCK_SIZE, WAYS),\\n', '  localparam IDX_BITS      = no_of_index_bits(SETS),\\n', '  localparam BLK_BITS      = no_of_block_bits(BLOCK_SIZE),\\n', '  localparam BLK_OFFS_BITS = no_of_block_offset_bits(BLOCK_SIZE),\\n', '  localparam DAT_OFFS_BITS = no_of_data_offset_bits(XLEN, BLK_BITS),\\n', '  localparam TAG_BITS      = no_of_tag_bits(PLEN, IDX_BITS, BLK_OFFS_BITS)\\n', ')\\n', '(\\n', '  input  logic                     rst_ni,\\n', '  input  logic                     clk_i,\\n', '\\n', '  input  logic                     stall_i,\\n', '\\n', '  input  logic                     armed_i,\\n', '  input  logic                     cleaning_i,\\n', '  input  logic                     invalidate_block_i,\\n', '  input  logic                     invalidate_all_blocks_i,\\n', '  input  logic                     filling_i,\\n', '  input  logic [WAYS         -1:0] fill_way_select_i,\\n', '  input  logic [WAYS         -1:0] fill_way_i,\\n', '  output logic [WAYS         -1:0] fill_way_o,\\n', '  output logic [$clog2(WAYS) -1:0] clean_way_int_o,\\n', '  output logic [IDX_BITS     -1:0] clean_idx_o,\\n', '  input  logic [WAYS         -1:0] clean_way_i,\\n', '  input  logic [IDX_BITS     -1:0] clean_idx_i,\\n', '\\n', '  input  logic [TAG_BITS     -1:0] rd_core_tag_i,\\n', '                                   wr_core_tag_i,\\n', '  input  logic [IDX_BITS     -1:0] rd_idx_i,\\n', '                                   wr_idx_i,\\n', '\\n', '  input  logic                     rreq_i,            //Read cache memories?\\n', '  input  logic                     writebuffer_we_i,\\n', '  input  logic [BLK_BITS/8   -1:0] writebuffer_be_i,  //writebuffer_be is already blk_bits aligned\\n', '  input  logic [IDX_BITS     -1:0] writebuffer_idx_i,\\n', '  input  logic [DAT_OFFS_BITS-1:0] writebuffer_offs_i,\\n', '  input  logic [XLEN         -1:0] writebuffer_data_i,\\n', '  input  logic [WAYS         -1:0] writebuffer_ways_hit_i,\\n', '  input  logic                     writebuffer_cleaning_i,\\n', '\\n', '  input  logic [BLK_BITS     -1:0] biu_line_i,\\n', '  input  logic                     biu_line_dirty_i,\\n', '  input  logic                     biucmd_ack_i,\\n', '\\n', '  input  logic                     evict_read_i,\\n', '  output logic [PLEN         -1:0] evict_adr_o,\\n', '  output logic [BLK_BITS     -1:0] evict_line_o,\\n', '\\n', '  input  logic                     latchmem_i,        //latch output from memories\\n', '  output logic                     hit_o,             //cache-hit\\n', '  output logic [WAYS         -1:0] ways_hit_o,        //list of hit ways\\n', '  output logic                     cache_dirty_o,     //(at least) one way is dirty\\n', '  output logic [WAYS         -1:0] ways_dirty_o,      //list of dirty ways\\n', '  output logic                     way_dirty_o,       //the selected way is dirty\\n', '  output logic [BLK_BITS     -1:0] cache_line_o       //Cacheline\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Typedef\\n', '  //\\n', '  \\n', '  //TAG-structure\\n', '  typedef struct packed {\\n', '    logic                valid;\\n', '    logic                dirty;\\n', '    logic [TAG_BITS-1:0] tag;\\n', '  } tag_struct;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Functions\\n', '  //\\n', '\\n', '  //Convert OneHot to integer value\\n', '  function automatic int onehot2int;\\n', '    input [WAYS-1:0] a;\\n', '\\n', '    integer i;\\n', '\\n', '    onehot2int = 0;\\n', '\\n', '    for (i=0; i<WAYS; i++)\\n', '      if (a[i]) onehot2int = i;\\n', '  endfunction: onehot2int\\n', '\\n', '\\n', '  //Byte-Enable driven MUX\\n', '  function automatic [BLK_BITS-1:0] be_mux;\\n', '    input                  ena;\\n', '    input [BLK_BITS/8-1:0] be;\\n', '    input [BLK_BITS  -1:0] data_old; //old data\\n', '    input [BLK_BITS  -1:0] data_new; //new data\\n', '\\n', '    for (int i=0; i<BLK_BITS/8;i++)\\n', '      be_mux[i*8 +: 8] = ena && be[i] ? data_new[i*8 +: 8] : data_old[i*8 +: 8];\\n', '  endfunction: be_mux\\n', '\\n', '\\n', '  //Find first one in dirty_ways (LSB first)\\n', '  function automatic int first_dirty_way;\\n', '    input [WAYS-1:0][SETS-1:0] valid, dirty;\\n', '\\n', '    logic [WAYS*SETS -1:0] valid_vect, dirty_vect;\\n', '\\n', '    //from packed array to vector\\n', '    valid_vect = valid;\\n', '    dirty_vect = dirty;\\n', '\\n', '    for (int n=0; n < WAYS*SETS; n++)\\n', '      if (valid_vect[n] && dirty_vect[n]) return n;\\n', '  endfunction: first_dirty_way\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  genvar  way;\\n', '\\n', '  logic                              biumem_we,               //write data from BIU\\n', '                                     writebuffer_we,          //write data from WriteBuffer (CPU)\\n', '                                     we_dly;\\n', '\\n', '  logic [WAYS        -1:0]           fill_way_select_dly;\\n', '  logic [$clog2(WAYS)-1:0]           fill_way_select_int_dly; //integer version of fill_way_select_dly\\n', '  logic [$clog2(WAYS)-1:0]           clean_way_int_dly;       //delayed way currently flushing\\n', '  logic [$clog2(WAYS)-1:0]           evict_way_select_int;    //integer version of fill_way_select_dly\\n', '\\n', '  logic [IDX_BITS    -1:0]           rd_idx_dly,              //delay idx, same delay as through memory\\n', '                                     filling_idx,             //index for/currently filling\\n', '                                     clean_idx,               //index for/currently flushing\\n', '                                     clean_idx_dly;           //delayed flusing idx, same delay as through memory\\n', '  logic [TAG_BITS    -1:0]           rd_core_tag_dly,         //delay core_tag, same delay as through memory\\n', '                                     filling_tag;             //TAG for filling\\n', '  logic                              bypass_biumem_we;        //bypass outputs on biumem_we\\n', '  logic [WAYS        -1:0]           bypass_writebuffer_we;   //bypass outputs on writebuffer_we\\n', '\\n', '  /* TAG\\n', '   */\\n', '  logic [IDX_BITS    -1:0]           tag_idx;                 //tag memory read index\\n', '  tag_struct                         tag_in          [WAYS],  //tag memory input data\\n', '                                     tag_out         [WAYS];  //tag memory output data\\n', '  logic [WAYS        -1:0]           tag_we,                  //tag memory write enable\\n', '                                     tag_we_dirty;            //tag-dirty write enable\\n', '  logic [TAG_BITS    -1:0]           tag_byp_tag;\\n', '  logic [WAYS        -1:0][SETS-1:0] tag_valid;\\n', '  logic [WAYS        -1:0][SETS-1:0] tag_dirty;\\n', '  logic [WAYS        -1:0]           way_hit,                 //got a hit on a way\\n', '                                     way_dirty;               //way is dirty\\n', '\\n', '\\n', '  /* DATA\\n', '  */\\n', '  logic [IDX_BITS    -1:0]           dat_idx;                 //data memory read index\\n', '  logic [BLK_BITS    -1:0]           dat_in;                  //data into memory\\n', '  logic [WAYS        -1:0]           dat_we;                  //data memory write enable\\n', '  logic [BLK_BITS/8  -1:0]           dat_be;                  //data memory write byte enables\\n', '  logic [BLK_BITS    -1:0]           dat_out         [WAYS],  //data memory output\\n', '                                     dat_out_bypassed[WAYS];  //data memory output with writebuffer bypass\\n', '  logic [BLK_BITS    -1:0]           way_q_mux       [WAYS];  //data out multiplexor\\n', '\\n', '\\n', '  /* EVICT\\n', '   */\\n', '  logic                              evict_latch;             //latch evict_* signals\\n', '  logic [TAG_BITS    -1:0]           evict_tag;               //tag to evict\\n', '  logic [IDX_BITS    -1:0]           evict_idx;               //index to evict\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  //write data from BIU \\n', '  assign biumem_we = filling_i & biucmd_ack_i;\\n', '\\n', '\\n', '  //WriteBuffer write opportunity\\n', '  assign writebuffer_we = (~rreq_i | writebuffer_cleaning_i) & writebuffer_we_i;\\n', '\\n', '\\n', \"  //Delayed write. Masks 'hit'\\n\", '  always @(posedge clk_i)\\n', '    we_dly <= biumem_we;\\n', '\\n', '\\n', '  //delay rd_idx_i, rd_core_tag_i, same delay as through memory\\n', '  always @(posedge clk_i)\\n', '  begin\\n', '      rd_idx_dly      <= rd_idx_i;\\n', '      rd_core_tag_dly <= rd_core_tag_i;\\n', '  end\\n', '\\n', '\\n', '  //hold idx and tag, to be used during biumem_we=1 and for evict_*\\n', '  always @(posedge clk_i)\\n', '    if (!filling_i)\\n', '    begin\\n', '        filling_idx <= wr_idx_i;\\n', '        filling_tag <= wr_core_tag_i;\\n', '    end\\n', '\\n', '\\n', '  //Latch evict_*\\n', '  always @(posedge clk_i)\\n', '    begin\\n', '        evict_latch          <= evict_read_i;\\n', '        evict_way_select_int <= onehot2int(fill_way_i);\\n', '    end\\n', '\\n', '\\n', '  //Index during cleaning\\n', '  always @(posedge clk_i)\\n', '  begin\\n', '      clean_idx_o       <= first_dirty_way(tag_valid, tag_dirty) % SETS; //from vector-int to index\\n', '      clean_way_int_o   <= first_dirty_way(tag_valid, tag_dirty) / SETS; //from vector-int to way\\n', '\\n', '      //same delay as through Data memory (adr=clean_idx_i)\\n', '      clean_idx_dly     <= clean_idx_i;\\n', '      clean_way_int_dly <= onehot2int(clean_way_i);\\n', '  end\\n', '\\n', '\\n', '  //delay fill-way-select, same delay as through memory\\n', '  always @(posedge clk_i)\\n', '    begin\\n', '        fill_way_select_dly     <= fill_way_select_i;\\n', '\\tfill_way_select_int_dly <= onehot2int(fill_way_select_i);\\n', '    end\\n', '\\n', '\\n', '  //Bypass on biumem_we?\\n', '  assign bypass_biumem_we      = biumem_we & (rd_idx_dly == filling_idx) & (rd_core_tag_dly == filling_tag);\\n', '\\n', '\\n', '  //Bypass on writebuffer_we?\\n', '  always_comb\\n', '    for (int n=0; n<WAYS; n++)\\n', '      bypass_writebuffer_we[n] = writebuffer_we_i & (rd_idx_dly == writebuffer_idx_i) & writebuffer_ways_hit_i[n];\\n', '\\n', '\\n', '  //----------------------------------------------------------------\\n', '  // Tag Memory\\n', '  //----------------------------------------------------------------\\n', '\\n', '  //Memory Index\\n', '  always_comb\\n', '    unique casex ( {cleaning_i, evict_read_i, biumem_we} )\\n', \"      {3'b1??}: tag_idx = clean_idx_i;\\n\", \"      {3'b?1?}: tag_idx = filling_idx;\\n\", \"      {3'b??1}: tag_idx = filling_idx;\\n\", '      default : tag_idx = rd_idx_i;\\n', '    endcase\\n', '\\n', '\\n', '  //tag-register for bypass (RAW hazard)\\n', '  always @(posedge clk_i)\\n', '    if (biumem_we) tag_byp_tag <= wr_core_tag_i;\\n', '\\n', '\\n', 'generate\\n', '  for (way=0; way<WAYS; way++)\\n', '  begin: gen_ways_tag\\n', '      /* TAG RAM\\n', '       */\\n', '      rl_ram_1rw #(\\n', '        .ABITS      ( IDX_BITS               ),\\n', '        .DBITS      ( TAG_BITS               ),\\n', '        .TECHNOLOGY ( TECHNOLOGY             ) )\\n', '      tag_ram (\\n', '        .rst_ni     ( rst_ni                 ),\\n', '        .clk_i      ( clk_i                  ),\\n', '        .addr_i     ( tag_idx                ),\\n', '        .we_i       ( tag_we [way]           ),\\n', \"        .be_i       ( {(TAG_BITS+7)/8{1'b1}} ),\\n\", '        .din_i      ( tag_in [way].tag       ),\\n', '        .dout_o     ( tag_out[way].tag       ) );\\n', '\\n', '\\n', '\\n', '      /* TAG Valid\\n', '       * Valid is stored in DFF\\n', '       */ \\n', '      always @(posedge clk_i, negedge rst_ni)\\n', \"        if      (!rst_ni                      ) tag_valid[way]          <= 'h0;\\n\", \"\\telse if ( invalidate_all_blocks_i     ) tag_valid[way]          <= 'h0;\\n\", \"        else if ( invalidate_block_i          ) tag_valid[way][tag_idx] <= 1'b0;         //TODO: specify block number for cbo.inval\\n\", '        else if ( tag_we[way]                 ) tag_valid[way][tag_idx] <= tag_in[way].valid;\\n', '\\n', '      assign tag_out[way].valid = tag_valid[way][rd_idx_dly];\\n', '\\n', '\\n', '      //compare way-tag to TAG;\\n', '      assign way_hit[way] = tag_out[way].valid & (rd_core_tag_i == tag_out[way].tag) &\\n', '                           ~(filling_i & fill_way_i[way] & ~rreq_i); //actually wreq_i.\\n', '                                                                     //Can get a hit when reading data as the block still contains previous data\\n', \"                                                                     //Cannot get a hit when writing data, because that's for the new block\\n\", '\\n', '      /* TAG Dirty\\n', '       * Dirty is stored in DFF\\n', '       * Use dat_idx here to update dirty on writebuffer_we\\n', '       */ \\n', '      always @(posedge clk_i, negedge rst_ni)\\n', \"        if      (!rst_ni            ) tag_dirty[way]              <= 'h0;\\n\", \"        else if ( clean_way_i [way] ) tag_dirty[way][clean_idx_i] <= 1'b0;\\n\", '        else if ( tag_we_dirty[way] ) tag_dirty[way][dat_idx    ] <= tag_in[way].dirty;\\n', '\\n', '      assign tag_out[way].dirty = tag_dirty[way][rd_idx_dly];\\n', '\\n', '\\n', \"      //extract 'dirty' from tag\\n\", '      assign way_dirty[way] = (tag_out[way].valid         & tag_out[way].dirty         ) |\\n', '                              (bypass_writebuffer_we[way] & writebuffer_ways_hit_i[way]);\\n', '\\n', '\\n', '      /* TAG Write Enable\\n', '       */\\n', '      assign tag_we      [way] =  biumem_we & fill_way_i[way];\\n', '      assign tag_we_dirty[way] = (biumem_we & fill_way_i[way]                 ) |\\n', '                                 (writebuffer_we & writebuffer_ways_hit_i[way]);\\n', '\\n', '      /* TAG Write Data\\n', '       */\\n', '      //clear valid tag during flushing and cache-coherency checks\\n', \"      assign tag_in[way].valid = 1'b1;\\n\", '      assign tag_in[way].dirty = biumem_we ? biu_line_dirty_i : writebuffer_we_i;\\n', '      assign tag_in[way].tag   = filling_tag;\\n', '  end\\n', 'endgenerate\\n', '\\n', '\\n', '  /* Generate Hit\\n', '   */\\n', '  always @(posedge clk_i)\\n', \"    if      ( invalidate_all_blocks_i) hit_o <= 1'b0;\\n\", \"    else if ( bypass_biumem_we       ) hit_o <= 1'b1;\\n\", '    else if ( latchmem_i             ) hit_o <= |way_hit & ~we_dly;\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', '    if      ( bypass_biumem_we) ways_hit_o <= fill_way_i;\\n', '    else if ( latchmem_i      ) ways_hit_o <= way_hit;\\n', '    \\n', '\\n', '  /* Generate Dirty\\n', '  */\\n', '  //cache has dirty lines\\n', '  always @(posedge clk_i)\\n', '    if      ( bypass_biumem_we) cache_dirty_o <= biu_line_dirty_i;\\n', '    else if ( latchmem_i      ) cache_dirty_o <= |(tag_valid & tag_dirty);\\n', '\\n', '\\n', '  //TODO: remove?\\n', '  always @(posedge clk_i)\\n', '    if      ( bypass_biumem_we ) ways_dirty_o <= {WAYS{biu_line_dirty_i}} & fill_way_i;\\n', '    else if (latchmem_i        ) ways_dirty_o <= way_dirty;\\n', '\\n', '\\n', '  //selected way is dirty\\n', '  always @(posedge clk_i)\\n', '    if      ( bypass_biumem_we) way_dirty_o <= biu_line_dirty_i;\\n', '    else if (latchmem_i       ) way_dirty_o <= way_dirty[fill_way_select_int_dly];\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', '    if (latchmem_i) fill_way_o <= fill_way_select_dly;\\n', '\\n', '\\n', '  /* TAG output\\n', '   * Used for EVICT address generation\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    if      ( cleaning_i ) evict_tag <= tag_out[clean_way_int_o].tag;   //this takes forever, can use clean_way_int_o\\n', '    else if ( evict_latch) evict_tag <= tag_out[evict_way_select_int].tag;\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', '    if      ( cleaning_i ) evict_idx <= clean_idx_dly;\\n', '    else if ( evict_latch) evict_idx <= filling_idx;\\n', '\\n', '\\n', \"  assign evict_adr_o = { evict_tag, evict_idx, {BLK_OFFS_BITS{1'b0}} };\\n\", '\\n', '\\n', '  //----------------------------------------------------------------\\n', '  // Data Memory\\n', '  //----------------------------------------------------------------\\n', '\\n', '  //Memory Index\\n', '  always_comb\\n', '    unique casex ( {cleaning_i, evict_read_i, biumem_we, writebuffer_we} )\\n', \"      {4'b1???}: dat_idx = clean_idx_i;\\n\", \"      {4'b?1??}: dat_idx = filling_idx;\\n\", \"      {4'b??1?}: dat_idx = filling_idx;\\n\", \"      {4'b???1}: dat_idx = writebuffer_idx_i;\\n\", '      default  : dat_idx = rd_idx_i;\\n', '    endcase\\n', '\\n', '\\n', '  //generate DAT-memory data input\\n', '  assign dat_in = writebuffer_we ? {BLK_BITS/XLEN{writebuffer_data_i}}\\n', '                                 : biu_line_i;\\n', '\\n', '\\n', '  //generate DAT-memory byte enable\\n', '  assign dat_be = writebuffer_we ? writebuffer_be_i\\n', \"                                 : {BLK_BITS/8{1'b1}};\\n\", '\\n', '\\n', 'generate\\n', '  for (way=0; way<WAYS; way++)\\n', '  begin: gen_ways_dat\\n', '      rl_ram_1rw #(\\n', '        .ABITS      ( IDX_BITS      ),\\n', '        .DBITS      ( BLK_BITS      ),\\n', '        .TECHNOLOGY ( TECHNOLOGY    ) )\\n', '      data_ram (\\n', '        .rst_ni     ( rst_ni        ),\\n', '        .clk_i      ( clk_i         ),\\n', '        .addr_i     ( dat_idx       ),\\n', '        .we_i       ( dat_we [way]  ),\\n', '        .be_i       ( dat_be        ),\\n', '        .din_i      ( dat_in        ),\\n', '        .dout_o     ( dat_out[way]) );\\n', '\\n', '\\n', '      /* Data Write Enable\\n', '       */\\n', '      assign dat_we[way] = (biumem_we      & fill_way_i[way]            ) |\\n', '                           (writebuffer_we & writebuffer_ways_hit_i[way]);\\n', '      \\n', '      /* Bypass Data Output\\n', '      */\\n', '      assign dat_out_bypassed[way] = be_mux(bypass_writebuffer_we[way],\\n', '                                            writebuffer_be_i,\\n', '                                            dat_out[way],\\n', '                                            {BLK_BITS/XLEN{writebuffer_data_i}});\\n', '\\n', '      /* Data Ouput Mux\\n', '       * assign way_q; Build MUX (AND/OR) structure\\n', '       */\\n', '      if (way == 0)\\n', '        assign way_q_mux[way] =  dat_out_bypassed[way] & {BLK_BITS{way_hit[way]}};\\n', '      else\\n', '        assign way_q_mux[way] = (dat_out_bypassed[way] & {BLK_BITS{way_hit[way]}}) | way_q_mux[way -1];\\n', '  end\\n', 'endgenerate\\n', '\\n', '\\n', '  /* Cache line output\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    if      ( bypass_biumem_we ) cache_line_o <= biu_line_i;\\n', '    else if ( latchmem_i       ) cache_line_o <= way_q_mux[WAYS-1];\\n', '\\n', '\\n', '  /* Evict line output\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    if      ( cleaning_i  ) evict_line_o <= dat_out_bypassed[clean_way_int_o]; //takes forever, can use clean_way_int_o\\n', '    else if ( evict_latch ) evict_line_o <= dat_out_bypassed[evict_way_select_int];\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Cache Address Setup Stage                                    //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2021 ROA Logic BV                     //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_cache_setup\\n', 'import riscv_cache_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter                    XLEN          = 32,\\n', '  parameter                    SIZE          = 64,\\n', '  parameter                    BLOCK_SIZE    = XLEN,\\n', '  parameter                    WAYS          = 2,\\n', '\\n', '  localparam                   SETS          = no_of_sets             (SIZE, BLOCK_SIZE, WAYS       ),\\n', '  localparam                   BLK_OFFS_BITS = no_of_block_offset_bits(BLOCK_SIZE                   ),\\n', '  localparam                   IDX_BITS      = no_of_index_bits       (SETS                         )\\n', ')\\n', '(\\n', '  input  logic                 rst_ni,\\n', '  input  logic                 clk_i,\\n', '\\n', '  input  logic                 stall_i,\\n', '  \\n', '  input  logic                 flush_i,\\n', '  input  logic                 req_i,\\n', '  input  logic [XLEN     -1:0] adr_i,   //virtualy index, physically tagged\\n', '  input  biu_size_t            size_i,\\n', '  input  logic                 lock_i,\\n', '  input  biu_prot_t            prot_i,\\n', '  input  logic                 we_i,\\n', '  input  logic [XLEN     -1:0] d_i,\\n', '  input  logic                 invalidate_i,\\n', '                               clean_i,\\n', '\\n', '  output logic                 req_o,\\n', '  output logic                 rreq_o,\\n', '  output biu_size_t            size_o,\\n', '  output logic                 lock_o,\\n', '  output biu_prot_t            prot_o,\\n', '  output logic                 we_o,\\n', '  output logic [XLEN     -1:0] q_o,\\n', '  output logic                 invalidate_o,\\n', '                               clean_o,\\n', '\\n', '  output logic [IDX_BITS -1:0] idx_o\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  logic                flush_dly;\\n', '\\n', '  logic [IDX_BITS-1:0] adr_idx,\\n', '                       adr_idx_dly;\\n', '\\n', '  logic                invalidate_hold,\\n', '                       clean_hold;\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '\\n', '  /*delay flush signals\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    flush_dly <= flush_i;\\n', '\\n', '\\n', '  /* Hold invalidate/clean signals\\n', '   */\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni ) invalidate_hold <= 1'b0;\\n\", \"    else if (!stall_i) invalidate_hold <= 1'b0;\\n\", '    else               invalidate_hold <= invalidate_i | invalidate_hold;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni ) clean_hold <= 1'b0;\\n\", \"    else if (!stall_i) clean_hold <= 1'b0;\\n\", '    else               clean_hold <= clean_i | clean_hold;\\n', '\\n', '\\n', '  /*feed input signals to next stage\\n', '   */\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni ) req_o <= 1'b0;\\n\", \"    else if ( flush_i) req_o <= 1'b0;\\n\", '    else if (!stall_i) req_o <= req_i;\\n', '\\n', '\\n', '  /* Latch signals\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    if (!stall_i)\\n', '    begin\\n', '        size_o       <= size_i;\\n', '        lock_o       <= lock_i;\\n', '        prot_o       <= prot_i;\\n', '        we_o         <= we_i;\\n', '        q_o          <= d_i;\\n', '    end\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if (!rst_ni)\\n', '    begin\\n', \"        invalidate_o <= 1'b0;\\n\", \"        clean_o      <= 1'b0;\\n\", '    end\\n', '    else if (!stall_i)\\n', '    begin\\n', '        invalidate_o <= invalidate_i | invalidate_hold;\\n', '        clean_o      <= clean_i      | clean_hold;\\n', '    end\\n', '\\n', '\\n', '  /* Read-Request\\n', '   * Used to push writebuffer into Cache-memory\\n', '   * Same delay as adr_idx\\n', '   */\\n', '  assign rreq_o = req_i & ~we_i;\\n', '\\n', '\\n', '  /* TAG and DATA index\\n', '   * Output asynchronously, registered by memories\\n', '   */\\n', '  assign adr_idx = adr_i[BLK_OFFS_BITS +: IDX_BITS];\\n', '\\n', '  always @(posedge clk_i)\\n', '    if (!stall_i || flush_dly) adr_idx_dly <= adr_idx;\\n', '\\n', '  assign idx_o = stall_i /*&& !flush_dly*/ ? adr_idx_dly : adr_idx;\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Cache Tag Stage                                              //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2021 ROA Logic BV                     //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_cache_tag\\n', 'import riscv_cache_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter                        XLEN          = 32,\\n', '  parameter                        PLEN          = XLEN,\\n', '  parameter                        SIZE          = 64,\\n', '  parameter                        BLOCK_SIZE    = XLEN,\\n', '  parameter                        WAYS          = 2,\\n', '\\n', '  localparam                       SETS          = no_of_sets             (SIZE, BLOCK_SIZE, WAYS       ),\\n', '  localparam                       BLK_OFFS_BITS = no_of_block_offset_bits(BLOCK_SIZE                   ),\\n', '  localparam                       IDX_BITS      = no_of_index_bits       (SETS                         ),\\n', '  localparam                       TAG_BITS      = no_of_tag_bits         (PLEN, IDX_BITS, BLK_OFFS_BITS)\\n', ')\\n', '(\\n', '  input  logic                     rst_ni,\\n', '  input  logic                     clk_i,\\n', '\\n', '  input  logic                     stall_i,\\n', '  \\n', '  input  logic                     flush_i,\\n', '  input  logic                     req_i,\\n', '  input  logic [PLEN         -1:0] phys_adr_i, //physical address\\n', '  input  biu_size_t                size_i,\\n', '  input                            lock_i,\\n', '  input  biu_prot_t                prot_i,\\n', '  input  logic                     we_i,\\n', '  input  logic [XLEN         -1:0] d_i,\\n', '  input  logic                     invalidate_i,\\n', '  input  logic                     clean_i,\\n', '  input  logic                     pagefault_i,\\n', '  input  logic                     invalidate_all_blocks_i,\\n', '\\n', '  output logic                     req_o,\\n', '  output logic                     wreq_o,\\n', '  output logic [PLEN         -1:0] adr_o,\\n', '  output biu_size_t                size_o,\\n', '  output logic                     lock_o,\\n', '  output biu_prot_t                prot_o,\\n', '  output logic                     we_o,\\n', '  output logic [XLEN/8       -1:0] be_o,\\n', '  output logic [XLEN         -1:0] q_o,\\n', '  output logic                     invalidate_o,\\n', '  output logic                     clean_o,\\n', '  output logic                     pagefault_o,\\n', '  output logic [TAG_BITS     -1:0] core_tag_o\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Functions\\n', '  //   \\n', '  function automatic [XLEN/8-1:0] size2be;\\n', '    input [     2:0] size;\\n', '    input [XLEN-1:0] adr;\\n', '\\n', '    logic [$clog2(XLEN/8)-1:0] adr_lsbs;\\n', '\\n', '    adr_lsbs = adr[$clog2(XLEN/8)-1:0];\\n', '\\n', '    unique case (size)\\n', \"      BYTE : size2be = 'h1  << adr_lsbs;\\n\", \"      HWORD: size2be = 'h3  << adr_lsbs;\\n\", \"      WORD : size2be = 'hf  << adr_lsbs;\\n\", \"      DWORD: size2be = 'hff << adr_lsbs;\\n\", '    endcase\\n', '  endfunction: size2be\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  /* Feed input signals to next stage\\n', '   * Just a delay while waiting for Hit and Cacheline\\n', '   */\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni ) req_o <= 1'b0;\\n\", \"    else if ( flush_i) req_o <= 1'b0;\\n\", '    else if (!stall_i) req_o <= req_i;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni ) wreq_o <= 1'b0;\\n\", \"    else if ( flush_i) wreq_o <= 1'b0;\\n\", '    else if (!stall_i) wreq_o <= req_i & we_i;\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', '    if (!stall_i)\\n', '    begin\\n', '        adr_o        <= phys_adr_i;\\n', '        size_o       <= size_i;\\n', '        lock_o       <= lock_i;\\n', '        prot_o       <= prot_i;\\n', '        we_o         <= we_i;\\n', '        be_o         <= size2be(size_i, phys_adr_i);\\n', '        q_o          <= d_i;\\n', '        pagefault_o  <= pagefault_i;\\n', '    end\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni ) clean_o <= 1'b0;\\n\", '    else if (!stall_i) clean_o <= clean_i;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni                 ) invalidate_o <= 1'b0;\\n\", \"    else if ( invalidate_all_blocks_i) invalidate_o <= 1'b0;\\n\", '    else if (!stall_i                ) invalidate_o <= invalidate_i;\\n', '\\n', '\\n', '  //core-tag\\n', '  assign core_tag_o = phys_adr_i[PLEN-1 -: TAG_BITS];\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Cache Pipeline                                               //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2021 ROA Logic BV                     //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '/*\\n', '  Customer should be able to chose\\n', '  - cache size\\n', '  - Set associativity\\n', '  therefore BLOCK_SIZE is autocalculated\\n', '\\n', '  RISC-V specifies a 4KB page. Thus page offset = 12bits\\n', '  MAX_IDX_BITS = $clog2(4*1024) = 12\\n', '\\n', '  BURST_SIZE = 16,8,4\\n', '\\n', '  BLOCK_SIZE = BURST_SIZE * XLEN/8 (bytes)\\n', '    rv32:  64,32,16 bytes\\n', '    rv64: 128,64,32 bytes\\n', '\\n', '  This affects associativity (the number of ways)\\n', '  BLOCK_OFFSET_BITS = $clog2(BLOCK_SIZE)\\n', '    rv32: 6,5,4 bits\\n', '    rv64: 7,6,5 bits\\n', '\\n', '  IDX_BITS = MAX_IDX_BITS - BLOCK_OFFSET_BITS\\n', '    rv32: 6,7,8\\n', '    rv64: 5,6,7\\n', '\\n', '  SETS = 2**IDX_BITS\\n', '    rv32: 64,128,256\\n', '    rv64: 32, 64,128\\n', '\\n', '  WAYS = CACHE_SIZE / (BLOCK_SIZE * SET) = CACHE_SIZE / PAGE_SIZE\\n', '     8KB:  2\\n', '    16KB:  4\\n', '    32KB:  8\\n', '    64KB: 16\\n', ' */\\n', '\\n', '\\n', 'module riscv_dcache_core\\n', 'import riscv_cache_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter                       XLEN        = 32,\\n', '  parameter                       PLEN        = XLEN,\\n', '\\n', '  parameter                       SIZE        = 64,     //KBYTES\\n', '  parameter                       BLOCK_SIZE  = XLEN,   //BYTES, number of bytes in a block (way)\\n', '                                                        //Must be [XLEN*2,XLEN,XLEN/2]\\n', '  parameter                       WAYS        =  2,     // 1           : Direct Mapped\\n', '                                                        //<n>          : n-way set associative\\n', '                                                        //<n>==<blocks>: fully associative\\n', '  parameter                       REPLACE_ALG = 0,      //0: Random\\n', '                                                        //1: FIFO\\n', '                                                        //2: LRU\\n', '\\n', '  parameter                       TECHNOLOGY  = \"GENERIC\",\\n', '\\n', '  parameter                       DEPTH       = 2,      //number of transactions in flight\\n', '  parameter                       BIUTAG_SIZE = 2\\n', ')\\n', '(\\n', '  input  logic                    rst_ni,\\n', '  input  logic                    clk_i,\\n', '\\n', '  output logic                    stall_o,\\n', '\\n', '  //from MMU\\n', '  input  logic [PLEN        -1:0] phys_adr_i,           //physical address\\n', '  input  logic                    pagefault_i,\\n', '\\n', '  //from PMA\\n', '  input  logic                    pma_misaligned_i,\\n', '  input  logic                    pma_cacheable_i,\\n', '  input  logic                    pma_exception_i,\\n', '\\n', '  //from PMP\\n', '  input  logic                    pmp_exception_i,      //aligned with TAG\\n', '\\n', '  //CPU side\\n', '  input  logic                    mem_flush_i,\\n', '  input  logic                    mem_req_i,\\n', '  output logic                    mem_ack_o,\\n', '  output logic                    mem_err_o,\\n', '  output logic                    mem_misaligned_o,\\n', '  output logic                    mem_pagefault_o,\\n', '  input  logic [XLEN        -1:0] mem_adr_i,            //virtual address\\n', '  input  biu_size_t               mem_size_i,\\n', '  input  logic                    mem_lock_i,\\n', '  input  biu_prot_t               mem_prot_i,\\n', '  input  logic                    mem_we_i,\\n', '  input  logic [XLEN        -1:0] mem_d_i,\\n', '  output logic [XLEN        -1:0] mem_q_o,\\n', '\\n', '  //Cache Block Management, per CMO spec\\n', '  //Flush = Invalidate + Clean\\n', '  input  logic                    invalidate_i,         //Invalidate blocks\\n', '  input  logic                    clean_i,              //Write back dirty blocks\\n', '  input  logic                    clean_rdy_clr_i,      //Clear data-cache-ready signal\\n', '  output logic                    clean_rdy_o,          //Data cache ready cleaning\\n', '\\n', '  //To BIU\\n', '  output logic                    biu_stb_o,            //access request\\n', '  input  logic                    biu_stb_ack_i,        //access acknowledge\\n', '  input  logic                    biu_d_ack_i,          //BIU needs new data (biu_d_o)\\n', '  output logic [PLEN        -1:0] biu_adri_o,           //access start address\\n', '  input  logic [PLEN        -1:0] biu_adro_i,\\n', '  output biu_size_t               biu_size_o,           //transfer size\\n', '  output biu_type_t               biu_type_o,           //burst type\\n', '  output logic                    biu_lock_o,           //locked transfer\\n', '  output biu_prot_t               biu_prot_o,           //protection bits\\n', '  output logic                    biu_we_o,             //write enable\\n', '  output logic [XLEN        -1:0] biu_d_o,              //write data\\n', '  input  logic [XLEN        -1:0] biu_q_i,              //read data\\n', '  input  logic                    biu_ack_i,            //transfer acknowledge\\n', '  input  logic                    biu_err_i,            //transfer error\\n', '  output logic [BIUTAG_SIZE -1:0] biu_tagi_o,\\n', '  input  logic [BIUTAG_SIZE -1:0] biu_tago_i\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Constants\\n', '  //\\n', '  \\n', '  //----------------------------------------------------------------\\n', '  // Cache\\n', '  //----------------------------------------------------------------\\n', '  localparam PAGE_SIZE        = 4*1024;                            //4KB pages\\n', '  localparam MAX_IDX_BITS     = $clog2(PAGE_SIZE) - $clog2(BLOCK_SIZE); //Maximum IDX_BITS\\n', '  \\n', '\\n', \"  localparam SETS             = (SIZE*1024) / BLOCK_SIZE / WAYS;   //Number of sets TODO:SETS=1 doesn't work\\n\", '  localparam BLK_OFFS_BITS    = $clog2(BLOCK_SIZE);                //Number of BlockOffset bits\\n', '  localparam IDX_BITS         = $clog2(SETS);                      //Number of Index-bits\\n', '  localparam TAG_BITS         = PLEN - IDX_BITS - BLK_OFFS_BITS;   //Number of TAG-bits\\n', '  localparam BLK_BITS         = 8*BLOCK_SIZE;                      //Total number of bits in a Block\\n', '  localparam BURST_SIZE       = BLK_BITS / XLEN;                   //Number of transfers to load 1 Block\\n', '  localparam BURST_BITS       = $clog2(BURST_SIZE);\\n', '  localparam BURST_OFFS       = XLEN/8;\\n', '  localparam BURST_LSB        = $clog2(BURST_OFFS);\\n', '\\n', '  //BLOCK decoding\\n', '  localparam DAT_OFFS_BITS    = $clog2(BLK_BITS / XLEN);           //Offset in block\\n', '\\n', '\\n', '  //Inflight transfers\\n', '  localparam INFLIGHT_DEPTH  = BURST_SIZE;                         //Wishbone has 1 transfers in flight\\n', '                                                                   //AHB      has 2 transfers in flight\\n', '                                                                   //AXI can have many transfers in flight\\n', '  localparam INFLIGHT_BITS   = $clog2(INFLIGHT_DEPTH+1);\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  logic [              6:0] way_random; //Up to 128ways\\n', '  logic [WAYS         -1:0] fill_way_select,\\n', '                            mem_fill_way, hit_fill_way;\\n', '\\n', '  logic                     setup_req,        tag_req,\\n', '                            setup_rreq,       tag_wreq;\\n', '  logic [PLEN         -1:0]                   tag_adr;\\n', '  biu_size_t                setup_size,       tag_size;\\n', '  logic                     setup_lock,       tag_lock;\\n', '  biu_prot_t                setup_prot,       tag_prot;\\n', '  logic                     setup_we,         tag_we;\\n', '  logic [XLEN         -1:0] setup_q,          tag_q;\\n', '  logic                     setup_invalidate, tag_invalidate;\\n', '  logic                     setup_clean,      tag_clean;\\n', '  logic                                       tag_pagefault;\\n', '  logic [XLEN/8       -1:0]                   tag_be;\\n', '\\n', '  logic                     writebuffer_we;\\n', '  logic [IDX_BITS     -1:0] writebuffer_idx;\\n', '  logic [DAT_OFFS_BITS-1:0] writebuffer_offs;\\n', '  logic [XLEN         -1:0] writebuffer_data;\\n', '  logic [BLK_BITS/8   -1:0] writebuffer_be;\\n', '  logic [WAYS         -1:0] writebuffer_ways_hit;\\n', '  logic                     writebuffer_cleaning;\\n', '\\n', '  logic [TAG_BITS     -1:0] tag_core_tag,\\n', '                            hit_core_tag;\\n', '  logic [IDX_BITS     -1:0] setup_idx,\\n', '                            hit_idx;\\n', '  logic [BLK_BITS/8   -1:0] dat_be;\\n', '\\n', '\\n', '  logic                     cache_hit,\\n', '                            cache_dirty,\\n', '                            way_dirty;\\n', '  logic [WAYS         -1:0] ways_hit,\\n', '                            ways_dirty;\\n', '  logic [BLK_BITS     -1:0] cache_line;\\n', '\\n', '\\n', '  logic                     evict_read;\\n', '  logic [PLEN         -1:0] evict_adr;\\n', '  logic [BLK_BITS     -1:0] evict_line;\\n', '\\n', '  logic [$clog2(WAYS) -1:0] mem_clean_way_int;\\n', '  logic [IDX_BITS     -1:0] mem_clean_idx;\\n', '  logic [WAYS         -1:0] hit_clean_way;\\n', '  logic [IDX_BITS     -1:0] hit_clean_idx;\\n', '\\n', '\\n', '  logic [INFLIGHT_BITS-1:0] inflight_cnt;\\n', '\\n', '  biucmd_t                  biucmd;\\n', '  logic                     biucmd_ack,\\n', '                            biucmd_busy,\\n', '                            biucmd_noncacheable_req,\\n', '                            biucmd_noncacheable_ack;\\n', '  logic [BLK_BITS     -1:0] biubuffer;\\n', '  logic                     in_biubuffer;\\n', '  logic [BLK_BITS     -1:0] biu_line;\\n', '  logic                     biu_line_dirty;\\n', '\\n', '  logic                     hit_latchmem;\\n', '  logic                     armed,\\n', '                            filling,\\n', '                            cleaning,\\n', '                            invalidate_block,\\n', '                            invalidate_all_blocks;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  \\n', '  //----------------------------------------------------------------\\n', '  // Cache Pipeline\\n', '  //----------------------------------------------------------------\\n', '\\n', \"  //This should go into a 'way-replacement module'\\n\", '  //Random generator for RANDOM replacement algorithm\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni ) way_random <= 'h0;\\n\", '    else if (!filling) way_random <= {way_random, way_random[6] ~^ way_random[5]};\\n', '\\n', '\\n', '  //fill-way-select\\n', 'generate\\n', '  if (WAYS == 1) assign fill_way_select = 1;\\n', '  else           assign fill_way_select = 1 << way_random[$clog2(WAYS)-1:0];\\n', 'endgenerate\\n', '\\n', '\\n', '  /* Address Setup Stage\\n', '   * Drives signals into TAG and DATA memories\\n', '   * Virtual Memory\\n', '   */\\n', '  riscv_cache_setup #(\\n', '    .XLEN                      ( XLEN                    ),\\n', '    .SIZE                      ( SIZE                    ),\\n', '    .BLOCK_SIZE                ( BLOCK_SIZE              ),\\n', '    .WAYS                      ( WAYS                    ) )\\n', '  cache_setup_inst (\\n', '    .rst_ni                    ( rst_ni                  ),\\n', '    .clk_i                     ( clk_i                   ),\\n', '\\n', '    .stall_i                   ( stall_o                 ),\\n', '    .flush_i                   ( mem_flush_i             ),\\n', '\\n', '    .req_i                     ( mem_req_i               ),\\n', '    .adr_i                     ( mem_adr_i               ),\\n', '    .size_i                    ( mem_size_i              ),\\n', '    .lock_i                    ( mem_lock_i              ),\\n', '    .prot_i                    ( mem_prot_i              ),\\n', '    .we_i                      ( mem_we_i                ),\\n', '    .d_i                       ( mem_d_i                 ),\\n', '    .invalidate_i              ( invalidate_i            ),\\n', '    .clean_i                   ( clean_i                 ),\\n', '\\n', '    .req_o                     ( setup_req               ),\\n', '    .rreq_o                    ( setup_rreq              ),\\n', '    .size_o                    ( setup_size              ),\\n', '    .lock_o                    ( setup_lock              ),\\n', '    .prot_o                    ( setup_prot              ),\\n', '    .we_o                      ( setup_we                ),\\n', '    .q_o                       ( setup_q                 ),\\n', '    .invalidate_o              ( setup_invalidate        ),\\n', '    .clean_o                   ( setup_clean             ),\\n', '\\n', '    .idx_o                     ( setup_idx               ) );\\n', '\\n', '\\n', '  /* Tag stage\\n', '   * Tag/Data memory access. Hit and cache-line available after this stage\\n', '   * Physical address is available here\\n', '   */\\n', '  riscv_cache_tag #(\\n', '    .XLEN                      ( XLEN                    ),\\n', '    .PLEN                      ( PLEN                    ),\\n', '    .SIZE                      ( SIZE                    ),\\n', '    .BLOCK_SIZE                ( BLOCK_SIZE              ),\\n', '    .WAYS                      ( WAYS                    ) )\\n', '  cache_tag_inst (\\n', '    .rst_ni                    ( rst_ni                  ),\\n', '    .clk_i                     ( clk_i                   ),\\n', '\\n', '    .stall_i                   ( stall_o                 ),\\n', '    .flush_i                   ( mem_flush_i             ),\\n', '    .req_i                     ( setup_req               ),\\n', '\\n', '    .phys_adr_i                ( phys_adr_i              ),\\n', '    .size_i                    ( setup_size              ),\\n', '    .lock_i                    ( setup_lock              ),\\n', '    .prot_i                    ( setup_prot              ),\\n', '    .we_i                      ( setup_we                ),\\n', '    .d_i                       ( setup_q                 ),\\n', '    .invalidate_i              ( setup_invalidate        ),\\n', '    .clean_i                   ( setup_clean             ),\\n', '    .pagefault_i               ( pagefault_i             ), //aligned with phys_adr_i\\n', '    .invalidate_all_blocks_i   ( invalidate_all_blocks   ),\\n', '\\n', '    .req_o                     ( tag_req                 ),\\n', '    .wreq_o                    ( tag_wreq                ),\\n', '    .adr_o                     ( tag_adr                 ),\\n', '    .size_o                    ( tag_size                ),\\n', '    .lock_o                    ( tag_lock                ),\\n', '    .prot_o                    ( tag_prot                ),\\n', '    .we_o                      ( tag_we                  ),\\n', '    .be_o                      ( tag_be                  ),\\n', '    .q_o                       ( tag_q                   ),\\n', '    .invalidate_o              ( tag_invalidate          ),\\n', '    .clean_o                   ( tag_clean               ),\\n', '    .pagefault_o               ( tag_pagefault           ),\\n', '    .core_tag_o                ( tag_core_tag            ) );\\n', '\\n', '  \\n', '  /* Hit stage / Cache Controller (FSM)\\n', '   * Takes hit, cache-line and biu signals and generates memory output\\n', '   */\\n', '  riscv_dcache_fsm #(\\n', '    .XLEN                      ( XLEN                    ),\\n', '    .PLEN                      ( PLEN                    ),\\n', '    .SIZE                      ( SIZE                    ),\\n', '    .BLOCK_SIZE                ( BLOCK_SIZE              ),\\n', '    .WAYS                      ( WAYS                    ),\\n', '    .INFLIGHT_DEPTH            ( INFLIGHT_DEPTH          ) )\\n', '  cache_fsm_inst (\\n', '    .rst_ni                    ( rst_ni                  ),\\n', '    .clk_i                     ( clk_i                   ),\\n', '\\n', '    .stall_o                   ( stall_o                 ),\\n', '    .flush_i                   ( mem_flush_i             ),\\n', '\\n', '    //flush in-order with CPU pipeline\\n', '    .invalidate_i              ( tag_invalidate          ),\\n', '    .clean_i                   ( tag_clean               ),\\n', '    .clean_rdy_clr_i           ( clean_rdy_clr_i         ),\\n', '    .clean_rdy_o               ( clean_rdy_o             ),\\n', '    .armed_o                   ( armed                   ),\\n', '    .cleaning_o                ( cleaning                ),\\n', '    .invalidate_block_o        ( invalidate_block        ),\\n', '    .invalidate_all_blocks_o   ( invalidate_all_blocks   ),\\n', '    .filling_o                 ( filling                 ),\\n', '    .fill_way_i                ( mem_fill_way            ),\\n', '    .fill_way_o                ( hit_fill_way            ),\\n', '    .clean_way_int_i           ( mem_clean_way_int       ),\\n', '    .clean_idx_i               ( mem_clean_idx           ),\\n', '    .clean_way_o               ( hit_clean_way           ),\\n', '    .clean_idx_o               ( hit_clean_idx           ),\\n', '\\n', '    .cacheable_i               ( pma_cacheable_i         ),\\n', '    .misaligned_i              ( pma_misaligned_i        ),\\n', '    .pma_exception_i           ( pma_exception_i         ),\\n', '    .pmp_exception_i           ( pmp_exception_i         ),\\n', '    .pagefault_i               ( tag_pagefault           ),\\n', '    .req_i                     ( tag_req                 ),\\n', '    .wreq_i                    ( tag_wreq                ),\\n', '    .adr_i                     ( tag_adr                 ),\\n', '    .size_i                    ( tag_size                ),\\n', '    .lock_i                    ( tag_lock                ),\\n', '    .prot_i                    ( tag_prot                ),\\n', '    .we_i                      ( tag_we                  ),\\n', '    .be_i                      ( tag_be                  ),\\n', '    .d_i                       ( tag_q                   ),\\n', '    .q_o                       ( mem_q_o                 ),\\n', '    .ack_o                     ( mem_ack_o               ),\\n', '    .err_o                     ( mem_err_o               ),\\n', '    .misaligned_o              ( mem_misaligned_o        ),\\n', '    .pagefault_o               ( mem_pagefault_o         ),\\n', '\\n', '    .latchmem_o                ( hit_latchmem            ),\\n', '    .idx_o                     ( hit_idx                 ),\\n', '    .core_tag_o                ( hit_core_tag            ),\\n', '\\n', '    .cache_hit_i               ( cache_hit               ),\\n', '    .ways_hit_i                ( ways_hit                ),\\n', '    .cache_line_i              ( cache_line              ),\\n', '    .cache_dirty_i             ( cache_dirty             ),\\n', '    .way_dirty_i               ( way_dirty               ),\\n', '\\n', '    .writebuffer_we_o          ( writebuffer_we          ),\\n', '    .writebuffer_ack_i         (~setup_rreq              ),\\n', '    .writebuffer_idx_o         ( writebuffer_idx         ),\\n', '    .writebuffer_offs_o        ( writebuffer_offs        ),\\n', '    .writebuffer_data_o        ( writebuffer_data        ),\\n', '    .writebuffer_be_o          ( writebuffer_be          ),\\n', '    .writebuffer_ways_hit_o    ( writebuffer_ways_hit    ),\\n', '    .writebuffer_cleaning_o    ( writebuffer_cleaning    ),\\n', '\\n', '    .evict_read_o              ( evict_read              ),\\n', '\\n', '    .biucmd_o                  ( biucmd                  ),\\n', '    .biucmd_ack_i              ( biucmd_ack              ),\\n', '    .biucmd_busy_i             ( biucmd_busy             ),\\n', '    .biucmd_noncacheable_req_o ( biucmd_noncacheable_req ),\\n', '    .biucmd_noncacheable_ack_i ( biucmd_noncacheable_ack ),\\n', '    .inflight_cnt_i            ( inflight_cnt            ),\\n', '\\n', '    .biu_stb_ack_i             ( biu_stb_ack_i           ),\\n', '    .biu_ack_i                 ( biu_ack_i               ),\\n', '    .biu_err_i                 ( biu_err_i               ),\\n', '    .biu_adro_i                ( biu_adro_i              ),\\n', '    .biu_q_i                   ( biu_q_i                 ),\\n', '    .in_biubuffer_i            ( in_biubuffer            ),\\n', '    .biubuffer_i               ( biubuffer               ) );\\n', '\\n', '\\n', '  //----------------------------------------------------------------\\n', '  // Memory Blocks\\n', '  //----------------------------------------------------------------\\n', '\\n', '  riscv_cache_memory #(\\n', '    .XLEN                      ( XLEN                    ),\\n', '    .PLEN                      ( PLEN                    ),\\n', '    .SIZE                      ( SIZE                    ),\\n', '    .BLOCK_SIZE                ( BLOCK_SIZE              ),\\n', '    .WAYS                      ( WAYS                    ),\\n', '\\n', '    .TECHNOLOGY                ( TECHNOLOGY              ) )\\n', '  cache_memory_inst (\\n', '    .rst_ni                    ( rst_ni                  ),\\n', '    .clk_i                     ( clk_i                   ),\\n', '\\n', '    .stall_i                   ( stall_o                 ),\\n', '\\n', '    .armed_i                   ( armed                   ),\\n', '    .cleaning_i                ( cleaning                ),\\n', \"    .invalidate_block_i        ( 1'b0                    ),\\n\", '    .invalidate_all_blocks_i   ( invalidate_all_blocks   ),\\n', '    .filling_i                 ( filling                 ),\\n', '    .fill_way_select_i         ( fill_way_select         ),\\n', '    .fill_way_i                ( hit_fill_way            ),\\n', '    .fill_way_o                ( mem_fill_way            ),\\n', '    .clean_way_int_o           ( mem_clean_way_int       ),\\n', '    .clean_idx_o               ( mem_clean_idx           ),\\n', '    .clean_way_i               ( hit_clean_way           ),\\n', '    .clean_idx_i               ( hit_clean_idx           ),\\n', '\\n', '    .rd_core_tag_i             ( tag_core_tag            ),\\n', '    .wr_core_tag_i             ( hit_core_tag            ),\\n', '    .rd_idx_i                  ( setup_idx               ),\\n', '    .wr_idx_i                  ( hit_idx                 ),\\n', '\\n', '    .rreq_i                    ( setup_rreq              ), //Read cache memories?\\n', '    .writebuffer_we_i          ( writebuffer_we          ),\\n', '    .writebuffer_be_i          ( writebuffer_be          ),\\n', '    .writebuffer_idx_i         ( writebuffer_idx         ),\\n', '    .writebuffer_offs_i        ( writebuffer_offs        ),\\n', '    .writebuffer_data_i        ( writebuffer_data        ),\\n', '    .writebuffer_ways_hit_i    ( writebuffer_ways_hit    ),\\n', '    .writebuffer_cleaning_i    ( writebuffer_cleaning    ),\\n', '\\n', '    .evict_read_i              ( evict_read              ),\\n', '    .evict_adr_o               ( evict_adr               ),\\n', '    .evict_line_o              ( evict_line              ),\\n', '\\n', '    .biu_line_i                ( biu_line                ), //Write data line\\n', '    .biu_line_dirty_i          ( biu_line_dirty          ), //Write data dirty\\n', '    .biucmd_ack_i              ( biucmd_ack              ), //Write data write-enable\\n', '\\n', '    .latchmem_i                ( hit_latchmem            ), //latch TAG/DATA memory output\\n', '    .hit_o                     ( cache_hit               ),\\n', '    .ways_hit_o                ( ways_hit                ),\\n', '    .cache_dirty_o             ( cache_dirty             ), //cache has dirty lines\\n', '    .way_dirty_o               ( way_dirty               ), //selected way is dirty (for evict)\\n', '    .ways_dirty_o              (                         ),\\n', '    .cache_line_o              ( cache_line              ) );\\n', '\\n', '\\n', '\\n', '  //----------------------------------------------------------------\\n', '  // Bus Interface Statemachine\\n', '  //----------------------------------------------------------------\\n', '  riscv_cache_biu_ctrl #(\\n', '    .XLEN                      ( XLEN                    ),\\n', '    .PLEN                      ( PLEN                    ),\\n', '    .SIZE                      ( SIZE                    ),\\n', '    .BLOCK_SIZE                ( BLOCK_SIZE              ),\\n', '    .WAYS                      ( WAYS                    ),\\n', '    .INFLIGHT_DEPTH            ( INFLIGHT_DEPTH          ),\\n', '    .BIUTAG_SIZE               ( BIUTAG_SIZE             ) )\\n', '  biu_ctrl_inst (\\n', '    .rst_ni                    ( rst_ni                  ),\\n', '    .clk_i                     ( clk_i                   ),\\n', '\\n', '    .flush_i                   ( mem_flush_i             ),\\n', '\\n', '    .biucmd_i                  ( biucmd                  ),\\n', '    .biucmd_ack_o              ( biucmd_ack              ),\\n', '    .biucmd_busy_o             ( biucmd_busy             ),\\n', '    .biucmd_noncacheable_req_i ( biucmd_noncacheable_req ),\\n', '    .biucmd_noncacheable_ack_o ( biucmd_noncacheable_ack ),\\n', \"    .biucmd_tag_i              ( {BIUTAG_SIZE{1'b0}}     ),\\n\", '    .inflight_cnt_o            ( inflight_cnt            ),\\n', '\\n', '    .req_i                     ( tag_req                 ),\\n', '    .adr_i                     ( tag_adr                 ),\\n', '    .size_i                    ( tag_size                ),\\n', '    .prot_i                    ( tag_prot                ),\\n', '    .lock_i                    ( tag_lock                ),\\n', '    .we_i                      ( tag_we                  ),\\n', '    .be_i                      ( tag_be                  ),\\n', '    .d_i                       ( tag_q                   ),\\n', '\\n', '    .biubuffer_o               ( biubuffer               ),\\n', '    .in_biubuffer_o            ( in_biubuffer            ),\\n', '    .biu_line_o                ( biu_line                ),\\n', '    .biu_line_dirty_o          ( biu_line_dirty          ),\\n', '\\n', '    .evictbuffer_adr_i         ( evict_adr               ),\\n', '    .evictbuffer_d_i           ( evict_line              ),\\n', '\\n', '     //To BIU\\n', '    .biu_stb_o                 ( biu_stb_o               ),\\n', '    .biu_stb_ack_i             ( biu_stb_ack_i           ),\\n', '    .biu_d_ack_i               ( biu_d_ack_i             ),\\n', '    .biu_adri_o                ( biu_adri_o              ),\\n', '    .biu_adro_i                ( biu_adro_i              ),\\n', '    .biu_size_o                ( biu_size_o              ),\\n', '    .biu_type_o                ( biu_type_o              ),\\n', '    .biu_lock_o                ( biu_lock_o              ),\\n', '    .biu_prot_o                ( biu_prot_o              ),\\n', '    .biu_we_o                  ( biu_we_o                ),\\n', '    .biu_d_o                   ( biu_d_o                 ),\\n', '    .biu_q_i                   ( biu_q_i                 ),\\n', '    .biu_ack_i                 ( biu_ack_i               ),\\n', '    .biu_err_i                 ( biu_err_i               ),\\n', '    .biu_tagi_o                ( biu_tagi_o              ),\\n', '    .biu_tago_i                ( biu_tago_i              ) );\\n', '\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Data Cache Statemachine/Controller                           //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2018 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_dcache_fsm\\n', 'import riscv_cache_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter XLEN           = 32,\\n', '  parameter PLEN           = XLEN,\\n', '\\n', '  parameter SIZE           = 64,\\n', '  parameter BLOCK_SIZE     = XLEN,\\n', '  parameter WAYS           = 2,\\n', '\\n', '  parameter INFLIGHT_DEPTH = 2,\\n', '\\n', '  localparam SETS          = no_of_sets(SIZE, BLOCK_SIZE, WAYS),\\n', '  localparam BLK_BITS      = no_of_block_bits(BLOCK_SIZE),\\n', '  localparam BLK_OFFS_BITS = no_of_block_offset_bits(BLOCK_SIZE),\\n', '  localparam DAT_OFFS_BITS = no_of_data_offset_bits (XLEN, BLK_BITS),                //Offset in block\\n', '  localparam IDX_BITS      = no_of_index_bits(SETS),\\n', '  localparam TAG_BITS      = no_of_tag_bits(PLEN, IDX_BITS, BLK_OFFS_BITS),\\n', '\\n', '  localparam INFLIGHT_BITS = $clog2(INFLIGHT_DEPTH+1)\\n', ')\\n', '(\\n', '  input  logic                        rst_ni,\\n', '  input  logic                        clk_i,\\n', '\\n', '  output logic                        stall_o,\\n', '  input  logic                        flush_i,                                       //flush pipe\\n', '\\n', '  input  logic                        invalidate_i,\\n', '  input  logic                        clean_i,                                       //clean cache\\n', '  input  logic                        clean_rdy_clr_i,                               //clear cache-clean-ready signal\\n', '  output logic                        clean_rdy_o,                                   //cache clean ready\\n', '  output logic                        armed_o,\\n', '  output logic                        cleaning_o,\\n', '  output logic                        invalidate_block_o,\\n', '  output logic                        invalidate_all_blocks_o,\\n', '  output logic                        filling_o,\\n', '  input  logic [WAYS            -1:0] fill_way_i,\\n', '  output logic [WAYS            -1:0] fill_way_o,\\n', '  input  logic [$clog2(WAYS)    -1:0] clean_way_int_i,\\n', '  input  logic [IDX_BITS        -1:0] clean_idx_i,\\n', '  output logic [WAYS            -1:0] clean_way_o,\\n', '  output logic [IDX_BITS        -1:0] clean_idx_o,\\n', '\\n', '  input  logic                        cacheable_i,\\n', '  input  logic                        misaligned_i,\\n', '  input  logic                        pma_exception_i,\\n', '  input  logic                        pmp_exception_i,\\n', '  input  logic                        pagefault_i,\\n', '  input  logic                        req_i,                                         //from previous-stage\\n', '  input  logic                        wreq_i,\\n', '  input  logic [PLEN            -1:0] adr_i,\\n', '  input  biu_size_t                   size_i,\\n', '  input  logic                        lock_i,\\n', '  input  biu_prot_t                   prot_i,\\n', '  input  logic                        we_i,\\n', '  input  logic [XLEN/8          -1:0] be_i,\\n', '  input  logic [XLEN            -1:0] d_i,\\n', '  output logic [XLEN            -1:0] q_o,\\n', '  output logic                        ack_o,\\n', '  output logic                        err_o,\\n', '  output logic                        misaligned_o,\\n', '  output logic                        pagefault_o,\\n', '  \\n', '  //To/From Cache Memories\\n', '  input  logic                        cache_hit_i,                                   //from cache-memory\\n', '  input  logic [WAYS            -1:0] ways_hit_i,\\n', '  input  logic [BLK_BITS        -1:0] cache_line_i,\\n', '  input  logic                        cache_dirty_i,\\n', '  input  logic                        way_dirty_i,\\n', '  output logic [IDX_BITS        -1:0] idx_o,\\n', '  output logic [TAG_BITS        -1:0] core_tag_o,\\n', '  output logic                        latchmem_o,                                    //latch TAG/DATA memory outputs\\n', '\\n', '  //WriteBuffer\\n', '  output logic                        writebuffer_we_o,\\n', '  input  logic                        writebuffer_ack_i,\\n', '  output logic [IDX_BITS        -1:0] writebuffer_idx_o,\\n', '  output logic [DAT_OFFS_BITS   -1:0] writebuffer_offs_o,\\n', '  output logic [XLEN            -1:0] writebuffer_data_o,\\n', '  output logic [BLK_BITS/8      -1:0] writebuffer_be_o,                              //writebuffer_be is already blk_bits aligned\\n', '  output logic [WAYS            -1:0] writebuffer_ways_hit_o,\\n', '  output logic                        writebuffer_cleaning_o,                        //clean(empty) writebuffer\\n', '\\n', '  //EvictBuffer\\n', '  output logic                        evict_read_o,\\n', '\\n', '  //To/From BIU\\n', '  output biucmd_t                     biucmd_o,\\n', '  input  logic                        biucmd_ack_i,\\n', '  input  logic                        biucmd_busy_i,\\n', '  output logic                        biucmd_noncacheable_req_o,\\n', '  input  logic                        biucmd_noncacheable_ack_i,\\n', '  input  logic [INFLIGHT_BITS   -1:0] inflight_cnt_i,\\n', '\\n', '  input  logic [XLEN            -1:0] biu_q_i,\\n', '  input  logic                        biu_stb_ack_i,\\n', '                                      biu_ack_i,\\n', '                                      biu_err_i,\\n', '  input  logic [PLEN            -1:0] biu_adro_i,\\n', '  input  logic                        in_biubuffer_i,\\n', '  input  logic [BLK_BITS        -1:0] biubuffer_i\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Constants\\n', '  //\\n', '  localparam BURST_OFF     = XLEN/8;\\n', '  localparam BURST_LSB     = $clog2(BURST_OFF);\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Functions\\n', '  //\\n', '  function automatic integer onehot2int;\\n', '    input [WAYS-1:0] a;\\n', '\\n', '    integer i;\\n', '\\n', '    onehot2int = 0;\\n', '\\n', '    for (i=0; i<WAYS; i++)\\n', '      if (a[i]) onehot2int = i;\\n', '  endfunction: onehot2int\\n', '\\n', '\\n', '  function automatic [XLEN/8-1:0] size2be;\\n', '    input [     2:0] size;\\n', '    input [XLEN-1:0] adr;\\n', '\\n', '    logic [$clog2(XLEN/8)-1:0] adr_lsbs;\\n', '\\n', '    adr_lsbs = adr[$clog2(XLEN/8)-1:0];\\n', '\\n', '    unique case (size)\\n', \"      BYTE : size2be = 'h1  << adr_lsbs;\\n\", \"      HWORD: size2be = 'h3  << adr_lsbs;\\n\", \"      WORD : size2be = 'hf  << adr_lsbs;\\n\", \"      DWORD: size2be = 'hff << adr_lsbs;\\n\", '    endcase\\n', '  endfunction: size2be\\n', '\\n', '\\n', '  function automatic [BLK_BITS-1:0] be_mux;\\n', '    input                  ena;\\n', '    input [BLK_BITS/8-1:0] be;\\n', '    input [BLK_BITS  -1:0] o; //old data\\n', '    input [BLK_BITS  -1:0] n; //new data\\n', '\\n', '    integer i;\\n', '\\n', '    for (i=0; i<BLK_BITS/8;i++)\\n', '      be_mux[i*8 +: 8] = ena && be[i] ? n[i*8 +: 8] : o[i*8 +: 8];\\n', '  endfunction: be_mux\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Typedefs\\n', '  //\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  logic [XLEN          -1:0] cache_q;\\n', '  logic                      cache_ack,\\n', '                             biu_cacheable_ack;\\n', '\\n', '  logic                      pma_pmp_exception;\\n', '  logic                      valid_req,\\n', '                             valid_wreq;\\n', '\\n', '\\n', '  enum logic [          3:0] {ARMED=0,\\n', '                              CLEAN0,\\n', '                              CLEAN1,\\n', '                              CLEAN2,\\n', '                              NONCACHEABLE,\\n', '                              EVICT,\\n', '                              CLEANWAYS,\\n', '                              READ,\\n', '                              RECOVER0,\\n', '                              RECOVER1\\n', '                           } nxt_memfsm_state, memfsm_state;\\n', '\\n', '  biucmd_t                   nxt_biucmd;\\n', '\\n', '  logic [WAYS          -1:0] fill_way;\\n', '\\n', '  logic                      invalidate_hold,\\n', '                             clean_hold,\\n', \"                             clean_hold_clr,                                         //when there's nothing to clear...\\n\", '                             clean_rdy,\\n', '                             clean_block,\\n', '                             invalidate_block,\\n', '                             invalidate_all_blocks,\\n', '                             writebuffer_cleaning;\\n', '\\n', '  logic                      evict_read;\\n', '\\n', '  logic                      biu_adro_eq_cache_adr;\\n', '  logic [DAT_OFFS_BITS -1:0] dat_offset;\\n', '  logic                      bypass_writebuffer_we;\\n', '  logic [BLK_BITS      -1:0] cache_line;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  assign pma_pmp_exception = pma_exception_i | pmp_exception_i;\\n', '  assign valid_req         = req_i  & ~pma_pmp_exception & ~misaligned_i & ~pagefault_i & ~flush_i;\\n', '  assign valid_wreq        = wreq_i & ~pma_pmp_exception & ~misaligned_i & ~pagefault_i & ~flush_i;\\n', '\\n', '\\n', '  //hold invalidate/clean until ready to be serviced\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) invalidate_hold <= 1'b0;\\n\", '    else         invalidate_hold <= invalidate_i | (invalidate_hold & ~invalidate_all_blocks_o);\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) clean_hold <= 1'b0;\\n\", '    else         clean_hold <= clean_i | (clean_hold & ~(cleaning_o | clean_hold_clr) );\\n', '\\n', '\\n', '  /* State Machine\\n', '   */\\n', '  always_comb\\n', '  begin\\n', '      nxt_memfsm_state      = memfsm_state;\\n', '      nxt_biucmd            = biucmd_o;\\n', '      fill_way              = fill_way_o;\\n', \"//      clean_rdy             = 1'b1;\\n\", \"      clean_rdy             = 1'b0;\\n\", \"      invalidate_all_blocks = 1'b0;\\n\", \"      invalidate_block      = 1'b0;\\n\", \"      clean_block           = 1'b0;\\n\", \"      evict_read            = 1'b0;\\n\", \"      writebuffer_cleaning  = 1'b0;\\n\", '\\n', '      unique case (memfsm_state)\\n', '        ARMED        : begin \\n', '                           if (clean_hold)\\n', '                           begin\\n', \"                               if (writebuffer_we_o) writebuffer_cleaning = 1'b1;    //wait for writebuffer to empty\\n\", '                               else\\n', '                               begin\\n', '                                   if (cache_dirty_i)\\n', '                                   begin\\n', '                                       //Cache has dirty ways\\n', '                                       nxt_memfsm_state = CLEAN0;\\n', '                                       nxt_biucmd       = BIUCMD_NOP;\\n', \"                                       clean_rdy        = 1'b0;\\n\", '                                   end\\n', '\\t\\t\\t           else if (invalidate_hold)\\n', '                                   begin\\n', \"                                       invalidate_all_blocks = 1'b1;\\n\", '                                   end\\n', '                               end\\n', '                           end\\n', '                           else if (invalidate_hold)\\n', '                           begin\\n', \"                               if (writebuffer_we_o) writebuffer_cleaning  = 1'b1;   //wait for writebuffer to empty\\n\", \"                               else                  invalidate_all_blocks = 1'b1;\\n\", '                           end\\n', '                           else if (valid_req && !cacheable_i && !biucmd_busy_i)\\n', '                           begin\\n', '                               nxt_memfsm_state = NONCACHEABLE;\\n', '                               nxt_biucmd       = BIUCMD_NOP;\\n', '                           end\\n', '                           else if (valid_req && cacheable_i && !cache_hit_i && !biucmd_busy_i)\\n', '                           begin\\n', '                               begin\\n', '                                   fill_way = fill_way_i;                            //write to same way as was read\\n', '\\n', '                                   if ( way_dirty_i                              ||\\n', '                                        (  writebuffer_we_o                      &&\\n', '                                          (idx_o      == writebuffer_idx_o     ) &&\\n', '                                          (fill_way_i == writebuffer_ways_hit_o)\\n', '                                        )\\n', '\\t\\t\\t\\t      )\\n', '                                   begin\\n', '                                       //selected way is dirty\\n', '                                       nxt_memfsm_state = EVICT;\\n', '                                       nxt_biucmd       = BIUCMD_READWAY;            //read new line before evicting old one\\n', \"                                       evict_read       = 1'b1;                      //read block to evict\\n\", '                                                                                     //in evict_* 2 cycles later\\n', '                                   end\\n', '                                   else\\n', '                                   begin\\n', '                                       //Load way\\n', '                                       nxt_memfsm_state = READ;\\n', '                                       nxt_biucmd       = BIUCMD_READWAY;\\n', '                                   end\\n', '                               end\\n', '                           end\\n', '                       end\\n', '\\n', '        CLEAN0       : begin\\n', '                          //clean_idx_o registered here\\n', '                          nxt_memfsm_state = CLEAN1;\\n', '                          nxt_biucmd       = BIUCMD_NOP;\\n', \"                          clean_rdy        = 1'b0;\\n\", '                      end\\n', '\\n', '        CLEAN1      : begin\\n', '                          //clean_idx registered in memory\\n', '                          //evict_* ready 2 cycles later\\n', '                          nxt_memfsm_state = CLEAN2;\\n', '                          nxt_biucmd       = BIUCMD_NOP;\\n', \"                          clean_rdy        = 1'b0;\\n\", '                      end\\n', '\\n', '        CLEAN2      : begin\\n', '                          //Latch evict data/tag/idx in evict_*\\n', '                          //clear way-dirty of flushed way => next flush_idx on next cycle\\n', '                          nxt_memfsm_state = CLEANWAYS;\\n', '                          nxt_biucmd       = BIUCMD_NOP;\\n', \"                          clean_rdy        = 1'b0;\\n\", \"                          clean_block      = 1'b1;\\n\", '                      end\\n', '\\n', '\\n', '        CLEANWAYS   : begin\\n', '                          //assert WRITE_WAY here (instead of in CLEAN) to allow time to load evict_*\\n', '                          nxt_memfsm_state = memfsm_state;\\n', '                          nxt_biucmd       = BIUCMD_WRITEWAY;\\n', \"                          clean_rdy        = 1'b0;\\n\", '\\n', '                          if (biucmd_ack_i)\\n', '                          begin\\n', '                              //Check if there are more dirty ways in this set\\n', '                              if (cache_dirty_i)\\n', '                              begin\\n', '                                  nxt_memfsm_state = CLEANWAYS;\\n', '                                  nxt_biucmd       = BIUCMD_WRITEWAY;\\n', \"                                  clean_block      = 1'b1;\\n\", '                              end\\n', '                              else\\n', '                              begin\\n', '                                  nxt_memfsm_state      = RECOVER0;\\n', '                                  nxt_biucmd            = BIUCMD_NOP;\\n', \"                                  clean_rdy             = 1'b1;\\n\", '                                  invalidate_all_blocks = invalidate_hold;\\n', '                              end\\n', '                          end\\n', '                      end\\n', '\\n', \"        NONCACHEABLE: if ( flush_i                                       ||  //flushed pipe, no biu_ack's will come\\n\", '                          (!valid_req && inflight_cnt_i==1 && biu_ack_i) ||  //no new request, wait for BIU to finish transfer\\n', '                          ( valid_req && cacheable_i       && biu_ack_i) )   //new cacheable request, wait for non-cacheable transfer to finish\\n', '                      begin\\n', '                          nxt_memfsm_state = ARMED;\\n', '                          nxt_biucmd       = BIUCMD_NOP;\\n', '                      end\\n', '\\n', '        EVICT       : if (biucmd_ack_i || biu_err_i)\\n', '                      begin\\n', '                          nxt_memfsm_state = RECOVER0;\\n', '                          nxt_biucmd       = BIUCMD_WRITEWAY; //evict dirty way\\n', '                      end\\n', '                      else\\n', '                      begin\\n', '                          nxt_biucmd = BIUCMD_NOP;\\n', '                      end\\n', '\\n', '        READ        : begin\\n', '                          nxt_biucmd = BIUCMD_NOP;\\n', '\\n', '                          if (biucmd_ack_i || biu_err_i)\\n', '                            nxt_memfsm_state = RECOVER0;\\n', '                      end\\n', '\\n', '        RECOVER0    : begin\\n', '                          //setup address (idx) for TAG and data memory\\n', '                          nxt_memfsm_state = RECOVER1;\\n', '                          nxt_biucmd       = BIUCMD_NOP;\\n', '                      end\\n', '\\n', '        RECOVER1    : begin\\n', '                          //Latch TAG and DATA memory output\\n', '                          nxt_memfsm_state = ARMED;\\n', '                          nxt_biucmd       = BIUCMD_NOP;\\n', '                      end\\n', '\\n', '        default     : begin\\n', '                          //something went really wrong, flush cache\\n', '                          nxt_memfsm_state = CLEAN0;\\n', '                          nxt_biucmd       = BIUCMD_NOP;\\n', '                      end\\n', '      endcase\\n', '  end\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if (!rst_ni)\\n', '    begin\\n', '        memfsm_state            <= ARMED;\\n', '        biucmd_o                <= BIUCMD_NOP;\\n', \"        armed_o                 <= 1'b1;\\n\", \"        cleaning_o              <= 1'b0;\\n\", \"        invalidate_all_blocks_o <= 1'b0;\\n\", \"        invalidate_block_o      <= 1'b0;\\n\", \"        filling_o               <= 1'b0;\\n\", \"        fill_way_o              <=  'hx;\\n\", \"        clean_hold_clr          <= 1'b0;\\n\", \"        clean_rdy_o             <= 1'b1;\\n\", \"        evict_read_o            <= 1'b0;\\n\", \"        writebuffer_cleaning_o  <= 1'b1;\\n\", '    end\\n', '    else\\n', '    begin\\n', '        memfsm_state            <= nxt_memfsm_state;\\n', '        biucmd_o                <= nxt_biucmd;\\n', '        fill_way_o              <= fill_way;\\n', \"        clean_hold_clr          <= 1'b0;\\n\", '        clean_rdy_o             <= (clean_rdy | clean_rdy_o) & ~clean_rdy_clr_i;\\n', '        invalidate_all_blocks_o <= invalidate_all_blocks;\\n', '        invalidate_block_o      <= invalidate_block;\\n', '        evict_read_o            <= evict_read;\\n', '        writebuffer_cleaning_o  <= writebuffer_cleaning;\\n', '\\n', '        unique case (nxt_memfsm_state)\\n', '          ARMED       : begin\\n', \"                            armed_o    <= 1'b1;\\n\", \"                            cleaning_o <= 1'b0;\\n\", \"                            filling_o  <= 1'b0;\\n\", '\\n', '                            if (clean_hold && !writebuffer_we_o)\\n', \"                              if (!cache_dirty_i) clean_hold_clr <= 1'b1;\\n\", '                        end\\n', '\\n', '          CLEAN0      : begin\\n', \"                            armed_o    <= 1'b0;\\n\", \"                            cleaning_o <= 1'b1;\\n\", \"                            filling_o  <= 1'b0;\\n\", '                        end\\n', '\\n', '          CLEAN1      : begin\\n', \"                            armed_o    <= 1'b0;\\n\", \"                            cleaning_o <= 1'b1;\\n\", \"                            filling_o  <= 1'b0;\\n\", '                        end\\n', '\\n', '          CLEAN2      : begin\\n', \"                            armed_o    <= 1'b0;\\n\", \"                            cleaning_o <= 1'b1;\\n\", \"                            filling_o  <= 1'b0;\\n\", '                        end\\n', '\\n', '\\n', '          CLEANWAYS   : begin\\n', \"                            armed_o    <= 1'b0;\\n\", \"                            cleaning_o <= 1'b1;\\n\", \"                            filling_o  <= 1'b0;\\n\", '                        end\\n', '\\n', '          NONCACHEABLE: begin\\n', \"                            armed_o    <= 1'b0;\\n\", \"                            cleaning_o <= 1'b0;\\n\", \"                            filling_o  <= 1'b0;\\n\", '                        end\\n', '\\n', '          EVICT       : begin\\n', \"                            armed_o    <= 1'b0;\\n\", \"                            cleaning_o <= 1'b0;\\n\", \"                            filling_o  <= 1'b1;\\n\", '                        end\\n', '\\n', '          READ        : begin\\n', \"                            armed_o    <= 1'b0;\\n\", \"                            cleaning_o <= 1'b0;\\n\", \"                            filling_o  <= 1'b1;\\n\", '                        end\\n', '\\n', '          RECOVER0    : begin\\n', '                            //setup IDX for TAG and DATA memory after filling\\n', \"                            armed_o    <= 1'b0;\\n\", \"                            cleaning_o <= 1'b0;\\n\", \"                            filling_o  <= 1'b0;\\n\", '                        end\\n', '\\n', '          RECOVER1    : begin\\n', '                            //Read TAG and DATA memory after writing/filling\\n', \"                            armed_o    <= 1'b0;\\n\", \"                            cleaning_o <= 1'b0;\\n\", \"                            filling_o  <= 1'b0;\\n\", '                        end\\n', '        endcase\\n', '\\n', '  end\\n', '\\n', '  //Tag/Dat-index (for writing)\\n', '  assign idx_o = adr_i[BLK_OFFS_BITS +: IDX_BITS];\\n', '\\n', '\\n', '  //core-tag (for writing)\\n', '  assign core_tag_o = adr_i[PLEN-1 -: TAG_BITS];\\n', '\\n', '\\n', '  /* WriteBuffer\\n', '   */\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni                                           ) writebuffer_we_o <= 1'b0;\\n\", \"    else if ( flush_i                                          ) writebuffer_we_o <= 1'b0;\\n\", \"    else if ( valid_req && wreq_i && cacheable_i && cache_hit_i) writebuffer_we_o <= 1'b1;\\n\", \"    else if ( writebuffer_ack_i                                ) writebuffer_we_o <= 1'b0;\\n\", '\\n', '\\n', '  always @(posedge clk_i)\\n', '    if (valid_req && wreq_i && cacheable_i && cache_hit_i)\\n', '    begin\\n', '        writebuffer_idx_o      <= adr_i[BLK_OFFS_BITS +: IDX_BITS];\\n', '        writebuffer_offs_o     <= dat_offset;\\n', '        writebuffer_data_o     <= d_i;\\n', '        writebuffer_be_o       <= be_i << (dat_offset * XLEN/8);\\n', '        writebuffer_ways_hit_o <= ways_hit_i;\\n', '    end\\n', '\\n', '\\n', '  /*Clean/Invalidate blocks\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    begin\\n', '        clean_way_o <= (1 << clean_way_int_i) & {WAYS{clean_block}};\\n', '        clean_idx_o <= clean_idx_i;\\n', '    end\\n', '\\n', '\\n', '  /* BIU control\\n', '  */\\n', '  //non-cacheable access\\n', '  always_comb\\n', '    unique case (memfsm_state)\\n', '      ARMED       : biucmd_noncacheable_req_o = valid_req & ~cacheable_i;\\n', '      NONCACHEABLE: biucmd_noncacheable_req_o = valid_req & ~cacheable_i & biu_ack_i;\\n', \"      default     : biucmd_noncacheable_req_o = 1'b0;\\n\", '    endcase\\n', '\\n', '\\n', '  //address check, used in a few places\\n', '  assign biu_adro_eq_cache_adr = (biu_adro_i[PLEN-1:BURST_LSB] == adr_i[PLEN-1:BURST_LSB]);\\n', '\\n', '\\n', '  //acknowledge cache hit\\n', '  assign cache_ack         =  valid_req & cacheable_i & cache_hit_i & ~flush_i;\\n', '  assign biu_cacheable_ack = (valid_req & biu_ack_i & biu_adro_eq_cache_adr & ~flush_i) |\\n', '                              cache_ack;\\n', '\\n', '\\n', '  /* Stall & Latchmem\\n', '   */\\n', '\\n', '  //Always stall on non-cacheable accesses.\\n', '  //This removes dependency on biu_stb_ack_i, which is an async path.\\n', '  //However this stalls the access, which causes it to be executed twice\\n', \"  //Use a registered version of biu_stb_ack_i to negate 'stall' for 1 cycle during NONCACHEABLE\\n\", '  //thus removing the second access\\n', '  logic biu_stb_ack_reg;\\n', '  always @(posedge clk_i)\\n', '    biu_stb_ack_reg <= (memfsm_state == ARMED) && biu_stb_ack_i;\\n', '\\n', '  always_comb\\n', '    unique case (memfsm_state)\\n', '      ARMED       : begin\\n', '                        stall_o    =(clean_hold & ~clean_hold_clr            ) |      //cacheclean pending\\n', '                                    (valid_req  & ~cacheable_i               ) |      //non-cacheable access\\n', '                                    (valid_req  &  cacheable_i & ~cache_hit_i);       //cacheable access\\n', '\\n', '\\t\\t        latchmem_o = ~stall_o;\\n', '                    end\\n', '\\n', '      //req_i == 0 ? stall=|inflight_cnt\\n', '      //else is_cacheable ? stall=1 (wait for transition to ARMED state)\\n', '      //else                stall=!biu_ack_i\\n', '      NONCACHEABLE: begin\\n', '                        stall_o    = ~valid_req ? |inflight_cnt_i\\n', '                                                :  cacheable_i |\\n', '                                                 (~cacheable_i & ~biu_ack_i & ~biu_stb_ack_reg); //=is_cacheble | biu_ack_i\\n', '\\n', '                        latchmem_o = ~stall_o;\\n', '                     end\\n', '\\n', '      //TODO: Add in_biubuffer\\n', '      READ        : begin\\n', '                        stall_o    = ~( biu_cacheable_ack |\\n', '                                       (valid_req & cache_hit_i)\\n', '                                      );\\n', '\\n', '                        latchmem_o = ~stall_o;\\n', '                    end\\n', '\\n', '      EVICT       : begin\\n', '                        stall_o    = ~( biu_cacheable_ack |\\n', '                                       (valid_req & cache_hit_i)\\n', '                                      );\\n', '\\n', '                        latchmem_o = ~stall_o;\\n', '                    end\\n', '\\n', '      RECOVER0    : begin\\n', \"                        stall_o    = 1'b1;\\n\", \"                        latchmem_o = 1'b0;\\n\", '                    end\\n', '      \\n', '      RECOVER1    : begin\\n', \"                        stall_o    = 1'b1;\\n\", \"                        latchmem_o = 1'b1;\\n\", '                    end\\n', '\\n', '      CLEANWAYS   : begin\\n', \"                        stall_o    = 1'b1;\\n\", \"                        latchmem_o = 1'b1;\\n\", '                    end\\n', '\\n', '      default     : begin //CLEAN0,1,2\\n', \"                        stall_o    = 1'b1;\\n\", \"                        latchmem_o = 1'b1;\\n\", '                    end\\n', '    endcase\\n', '\\n', '\\n', '  /* Downstream signals\\n', '  */  \\n', '  //signal downstream that data is ready\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) ack_o <= 1'b0;\\n\", '    else\\n', '      unique case (memfsm_state)\\n', '        ARMED        : ack_o <= cache_ack;\\n', '        NONCACHEABLE : ack_o <= biucmd_noncacheable_ack_i;\\n', '\\tREAD         : ack_o <= biu_cacheable_ack;\\n', '\\tEVICT        : ack_o <= biu_cacheable_ack;\\n', \"\\tdefault      : ack_o <= 1'b0;\\n\", '      endcase\\n', '\\n', '\\n', '  //generate access error (load/store access exception)\\n', '  always @(posedge clk_i) err_o <= biu_err_i | (req_i & pma_pmp_exception);\\n', '\\n', '\\n', '  //generate misaligned (misaligned load/store exception)\\n', '  always @(posedge clk_i) misaligned_o <= req_i & misaligned_i;\\n', '\\n', '\\n', '  //generate Page Fault\\n', '  always @(posedge clk_i) pagefault_o <= req_i & pagefault_i;\\n', '\\n', '\\n', '  //Bypass on writebuffer_we?\\n', '  assign bypass_writebuffer_we = writebuffer_we_o & (idx_o == writebuffer_idx_o) & (writebuffer_ways_hit_o == ways_hit_i);\\n', '  \\n', '\\n', '  //Shift amount for data\\n', '  assign dat_offset = adr_i[BLK_OFFS_BITS-1 -: DAT_OFFS_BITS];\\n', '\\n', '  //Assign q_o\\n', '  assign cache_line = be_mux(bypass_writebuffer_we,\\n', '                             writebuffer_be_o,\\n', '                             in_biubuffer_i ? biubuffer_i : cache_line_i,\\n', '                             {BLK_BITS/XLEN{writebuffer_data_o}});\\n', '\\n', '  assign cache_q = cache_line >> (dat_offset * XLEN);\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', '    unique case (memfsm_state)\\n', '      EVICT  : q_o <= cache_hit_i ? cache_q : biu_q_i;\\n', '      READ   : q_o <= cache_hit_i ? cache_q : biu_q_i;\\n', '      default: q_o <= cacheable_i ? cache_q : biu_q_i;\\n', '    endcase\\n', '\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Cache Pipeline                                               //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2021 ROA Logic BV                     //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '/*\\n', '  Customer should be able to chose\\n', '  - cache size\\n', '  - Set associativity\\n', '  therefore BLOCK_SIZE is autocalculated\\n', '\\n', '  RISC-V specifies a 4KB page. Thus page offset = 12bits\\n', '  MAX_IDX_BITS = $clog2(4*1024) = 12\\n', '\\n', '  BURST_SIZE = 16,8,4\\n', '\\n', '  BLOCK_SIZE = BURST_SIZE * XLEN/8 (bytes)\\n', '    rv32:  64,32,16 bytes\\n', '    rv64: 128,64,32 bytes\\n', '\\n', '  This affects associativity (the number of ways)\\n', '  BLOCK_OFFSET_BITS = $clog2(BLOCK_SIZE)\\n', '    rv32: 6,5,4 bits\\n', '    rv64: 7,6,5 bits\\n', '\\n', '  IDX_BITS = MAX_IDX_BITS - BLOCK_OFFSET_BITS\\n', '    rv32: 6,7,8\\n', '    rv64: 5,6,7\\n', '\\n', '  SETS = 2**IDX_BITS\\n', '    rv32: 64,128,256\\n', '    rv64: 32, 64,128\\n', '\\n', '  WAYS = CACHE_SIZE / (BLOCK_SIZE * SET) = CACHE_SIZE / PAGE_SIZE\\n', '     8KB:  2\\n', '    16KB:  4\\n', '    32KB:  8\\n', '    64KB: 16\\n', ' */\\n', '\\n', '\\n', 'module riscv_icache_core\\n', 'import riscv_cache_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter int    XLEN        = 32,\\n', '  parameter int    PLEN        = XLEN,\\n', '  parameter int    PARCEL_SIZE = XLEN,\\n', '  parameter int    HAS_RVC     = 0,\\n', '\\n', '  parameter int    SIZE        = 64,     //KBYTES\\n', '  parameter int    BLOCK_SIZE  = XLEN,   //BYTES, number of bytes in a block (way)\\n', '                                         //Must be [XLEN*2,XLEN,XLEN/2]\\n', '  parameter int    WAYS        =  2,     // 1           : Direct Mapped\\n', '                                         //<n>          : n-way set associative\\n', '                                         //<n>==<blocks>: fully associative\\n', '  parameter int    REPLACE_ALG = 0,      //0: Random\\n', '                                         //1: FIFO\\n', '                                         //2: LRU\\n', '\\n', '  parameter string TECHNOLOGY  = \"GENERIC\",\\n', '\\n', '  parameter int    DEPTH       = 2,      //number of transactions in flight\\n', '  parameter int    BIUTAG_SIZE = $clog2(XLEN/PARCEL_SIZE)\\n', ')\\n', '(\\n', '  input  logic                        rst_ni,\\n', '  input  logic                        clk_i,\\n', '\\n', '  //From MMU\\n', '  input  logic [PLEN            -1:0] phys_adr_i, //physical address\\n', '  input  logic                        pagefault_i,\\n', '\\n', '  //From PMA\\n', '  input  logic                        pma_cacheable_i,\\n', '  input  logic                        pma_misaligned_i,\\n', '  input  logic                        pma_exception_i,\\n', '\\n', '  //From PMP\\n', '  input  logic                        pmp_exception_i,\\n', '\\n', '  //CPU side\\n', '  input  logic                        mem_flush_i,\\n', '  input  logic                        mem_req_i,\\n', '  output logic                        mem_stall_o,\\n', '  input  logic [XLEN            -1:0] mem_adr_i,\\n', '  input  biu_size_t                   mem_size_i,\\n', '  input                               mem_lock_i,\\n', '  input  biu_prot_t                   mem_prot_i,\\n', '  output logic [XLEN            -1:0] parcel_o,\\n', '  output logic [XLEN/PARCEL_SIZE-1:0] parcel_valid_o,\\n', '  output logic                        parcel_error_o,\\n', '  output logic                        parcel_misaligned_o,\\n', '  output logic                        parcel_pagefault_o,\\n', '\\n', '  //Cache management\\n', '  input  logic                        invalidate_i,         //invalidate cache\\n', '  input  logic                        dc_clean_rdy_i,       //data cache ready cleaning\\n', '\\n', '  //To BIU\\n', '  output logic                        biu_stb_o,            //access request\\n', '  input  logic                        biu_stb_ack_i,        //access acknowledge\\n', '  input  logic                        biu_d_ack_i,          //BIU needs new data (biu_d_o)\\n', '  output logic [PLEN            -1:0] biu_adri_o,           //access start address\\n', '  input  logic [PLEN            -1:0] biu_adro_i,\\n', '  output biu_size_t                   biu_size_o,           //transfer size\\n', '  output biu_type_t                   biu_type_o,           //burst type\\n', '  output logic                        biu_lock_o,           //locked transfer\\n', '  output biu_prot_t                   biu_prot_o,           //protection bits\\n', '  output logic                        biu_we_o,             //write enable\\n', '  output logic [XLEN            -1:0] biu_d_o,              //write data\\n', '  input  logic [XLEN            -1:0] biu_q_i,              //read data\\n', '  input  logic                        biu_ack_i,            //transfer acknowledge\\n', '  input  logic                        biu_err_i,            //transfer error\\n', '  output logic [BIUTAG_SIZE     -1:0] biu_tagi_o,\\n', '  input  logic [BIUTAG_SIZE     -1:0] biu_tago_i\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Constants\\n', '  //\\n', '  \\n', '  //----------------------------------------------------------------\\n', '  // Cache\\n', '  //----------------------------------------------------------------\\n', '  localparam PAGE_SIZE        = 4*1024;                             //4KB pages\\n', '  localparam MAX_IDX_BITS     = $clog2(PAGE_SIZE) - $clog2(BLOCK_SIZE); //Maximum IDX_BITS\\n', '  \\n', '\\n', \"  localparam SETS             = (SIZE*1024) / BLOCK_SIZE / WAYS;    //Number of sets TODO:SETS=1 doesn't work\\n\", '  localparam BLK_OFFS_BITS    = $clog2(BLOCK_SIZE);                 //Number of BlockOffset bits\\n', '  localparam IDX_BITS         = $clog2(SETS);                       //Number of Index-bits\\n', '  localparam TAG_BITS         = PLEN - IDX_BITS - BLK_OFFS_BITS;     //Number of TAG-bits\\n', '  localparam BLK_BITS         = 8*BLOCK_SIZE;                       //Total number of bits in a Block\\n', '  localparam BURST_SIZE       = BLK_BITS / XLEN;                    //Number of transfers to load 1 Block\\n', '  localparam BURST_BITS       = $clog2(BURST_SIZE);\\n', '  localparam BURST_OFFS       = XLEN/8;\\n', '  localparam BURST_LSB        = $clog2(BURST_OFFS);\\n', '\\n', '  //BLOCK decoding\\n', '  localparam DAT_OFFS_BITS    = $clog2(BLK_BITS / XLEN);            //Offset in block\\n', '  localparam PARCEL_OFFS_BITS = $clog2(XLEN / PARCEL_SIZE);\\n', '\\n', '\\n', '  //Inflight transfers\\n', '  localparam INFLIGHT_DEPTH   = BURST_SIZE;                         //Wishbone has 1 transfers in flight\\n', '                                                                    //AHB      has 2 transfers in flight\\n', '                                                                    //AXI can have many transfers in flight\\n', '  localparam INFLIGHT_BITS    = $clog2(INFLIGHT_DEPTH+1);\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  logic [              6:0] way_random; //Up to 128ways\\n', '  logic [WAYS         -1:0] fill_way_select,\\n', '                            mem_fill_way, hit_fill_way;\\n', '\\n', '  logic                     setup_req,        tag_req;\\n', '  logic [PLEN         -1:0]                   tag_adr;\\n', '  biu_size_t                setup_size,       tag_size;\\n', '  logic                     setup_lock,       tag_lock;\\n', '  biu_prot_t                setup_prot,       tag_prot;\\n', '  logic                     setup_invalidate, tag_invalidate;\\n', '  logic                                       tag_pagefault;\\n', '\\n', '  logic [TAG_BITS     -1:0] tag_core_tag,\\n', '                            hit_core_tag;\\n', '  logic [IDX_BITS     -1:0] setup_idx,\\n', '                            hit_idx;\\n', '\\n', '  logic                     cache_hit;\\n', '  logic [BLK_BITS     -1:0] cache_line;\\n', '\\n', '  logic [INFLIGHT_BITS-1:0] inflight_cnt;\\n', '\\n', '  biucmd_t                  biucmd;\\n', '  logic                     biucmd_ack;\\n', '  logic                     biucmd_noncacheable_req,\\n', '                            biucmd_noncacheable_ack;\\n', '  logic [PLEN         -1:0] biucmd_adr;\\n', '  logic [BIUTAG_SIZE  -1:0] biucmd_tag;\\n', '  logic [BLK_BITS     -1:0] biubuffer;\\n', '  logic                     in_biubuffer;\\n', '  logic [BLK_BITS     -1:0] biu_line;\\n', '\\n', '  logic                     armed,\\n', '\\t                    filling,\\n', '                            invalidate_all_blocks;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  \\n', '  //----------------------------------------------------------------\\n', '  // Cache Pipeline\\n', '  //----------------------------------------------------------------\\n', '\\n', \"  //This should go into a 'way-replacement module'\\n\", '  //Random generator for RANDOM replacement algorithm\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni ) way_random <= 'h0;\\n\", '    else if (!filling) way_random <= {way_random, way_random[6] ~^ way_random[5]};\\n', '\\n', '\\n', '  //fill-way-select\\n', 'generate\\n', '  if (WAYS == 1) assign fill_way_select = 1;\\n', '  else           assign fill_way_select = 1 << way_random[$clog2(WAYS)-1:0];\\n', 'endgenerate\\n', '\\n', '\\n', '  /* Address Setup Stage\\n', '   * Drives signals into TAG and DATA memories\\n', '   * Virtual Memory\\n', '   */\\n', '  riscv_cache_setup #(\\n', '    .XLEN                      ( XLEN                    ),\\n', '    .SIZE                      ( SIZE                    ),\\n', '    .BLOCK_SIZE                ( BLOCK_SIZE              ),\\n', '    .WAYS                      ( WAYS                    ) )\\n', '  cache_setup_inst (\\n', '    .rst_ni                    ( rst_ni                  ),\\n', '    .clk_i                     ( clk_i                   ),\\n', '\\n', '    .stall_i                   ( mem_stall_o             ),\\n', '    .flush_i                   ( mem_flush_i             ),\\n', '\\n', '    .req_i                     ( mem_req_i               ),\\n', '    .adr_i                     ( mem_adr_i               ),\\n', '    .size_i                    ( mem_size_i              ),\\n', '    .lock_i                    ( mem_lock_i              ),\\n', '    .prot_i                    ( mem_prot_i              ),\\n', \"    .we_i                      ( 1'b0                    ),\\n\", \"    .d_i                       ( {XLEN{1'b0}}            ),\\n\", '    .invalidate_i              ( invalidate_i            ),\\n', \"    .clean_i                   ( 1'b0                    ),\\n\", '\\n', '    .req_o                     ( setup_req               ),\\n', '    .rreq_o                    (                         ),\\n', '    .size_o                    ( setup_size              ),\\n', '    .lock_o                    ( setup_lock              ),\\n', '    .prot_o                    ( setup_prot              ),\\n', '    .we_o                      (                         ),\\n', '    .q_o                       (                         ),\\n', '    .invalidate_o              ( setup_invalidate        ),\\n', '    .clean_o                   (                         ),\\n', ' \\n', '    .idx_o                     ( setup_idx               ) );\\n', '\\n', '\\n', '  /* Tag stage\\n', '   * Tag/Data memory access. Hit and cache-line available after this stage\\n', '   * Physical address is available here\\n', '   */\\n', '  riscv_cache_tag #(\\n', '    .XLEN                      ( XLEN                    ),\\n', '    .PLEN                      ( PLEN                    ),\\n', '    .SIZE                      ( SIZE                    ),\\n', '    .BLOCK_SIZE                ( BLOCK_SIZE              ),\\n', '    .WAYS                      ( WAYS                    ) )\\n', '  cache_tag_inst (\\n', '    .rst_ni                    ( rst_ni                  ),\\n', '    .clk_i                     ( clk_i                   ),\\n', '\\n', '    .stall_i                   ( mem_stall_o             ),\\n', '    .flush_i                   ( mem_flush_i             ),\\n', '    .pagefault_i               ( pagefault_i             ),\\n', '    .req_i                     ( setup_req               ),\\n', '    .phys_adr_i                ( phys_adr_i              ),\\n', '    .size_i                    ( setup_size              ),\\n', '    .lock_i                    ( setup_lock              ),\\n', '    .prot_i                    ( setup_prot              ),\\n', \"    .we_i                      ( 1'b0                    ),\\n\", \"    .d_i                       ( {XLEN{1'b0}}            ),\\n\", '    .invalidate_i              ( setup_invalidate        ),\\n', '    .clean_i                   (                         ),\\n', '    .invalidate_all_blocks_i   ( invalidate_all_blocks   ),\\n', '\\n', '    .req_o                     ( tag_req                 ),\\n', '    .wreq_o                    (                         ),\\n', '    .adr_o                     ( tag_adr                 ),\\n', '    .size_o                    ( tag_size                ),\\n', '    .lock_o                    ( tag_lock                ),\\n', '    .prot_o                    ( tag_prot                ),\\n', '    .we_o                      (                         ),\\n', '    .be_o                      (                         ),\\n', '    .q_o                       (                         ),\\n', '    .invalidate_o              ( tag_invalidate          ),\\n', '    .clean_o                   (                         ),\\n', '    .pagefault_o               ( tag_pagefault           ),\\n', '    .core_tag_o                ( tag_core_tag            ) );\\n', '\\n', '  \\n', '  /* Hit stage / Cache Controller\\n', '   * Takes hit, cache-line and biu signals and generates parcel-output\\n', '   */\\n', '  riscv_icache_fsm #(\\n', '    .XLEN                      ( XLEN                    ),\\n', '    .PLEN                      ( PLEN                    ),\\n', '    .PARCEL_SIZE               ( PARCEL_SIZE             ),\\n', '    .HAS_RVC                   ( HAS_RVC                 ),\\n', '    .SIZE                      ( SIZE                    ),\\n', '    .BLOCK_SIZE                ( BLOCK_SIZE              ),\\n', '    .WAYS                      ( WAYS                    ),\\n', '    .INFLIGHT_DEPTH            ( INFLIGHT_DEPTH          ),\\n', '    .BIUTAG_SIZE               ( BIUTAG_SIZE             ) )\\n', '  cache_fsm_inst (\\n', '    .rst_ni                    ( rst_ni                  ),\\n', '    .clk_i                     ( clk_i                   ),\\n', '\\n', '    .stall_o                   ( mem_stall_o             ),\\n', '    .flush_i                   ( mem_flush_i             ),\\n', '\\n', '    .invalidate_i              ( tag_invalidate          ),\\n', '    .dc_clean_rdy_i            ( dc_clean_rdy_i          ),\\n', '\\n', '    .armed_o                   ( armed                   ),\\n', '    .invalidate_all_blocks_o   ( invalidate_all_blocks   ),\\n', '    .filling_o                 ( filling                 ),\\n', '    .fill_way_i                ( mem_fill_way            ),\\n', '    .fill_way_o                ( hit_fill_way            ),\\n', '\\n', '    .req_i                     ( tag_req                 ),\\n', '    .adr_i                     ( tag_adr                 ),\\n', '    .size_i                    ( tag_size                ),\\n', '    .lock_i                    ( tag_lock                ),\\n', '    .prot_i                    ( tag_prot                ),\\n', '    .cacheable_i               ( pma_cacheable_i         ),\\n', '    .misaligned_i              ( pma_misaligned_i        ),\\n', '    .pma_exception_i           ( pma_exception_i         ),\\n', '    .pmp_exception_i           ( pmp_exception_i         ),\\n', '    .pagefault_i               ( tag_pagefault           ),\\n', '\\n', '    .idx_o                     ( hit_idx                 ),\\n', '    .core_tag_o                ( hit_core_tag            ),\\n', '\\n', '    .biucmd_o                  ( biucmd                  ),\\n', '    .biucmd_ack_i              ( biucmd_ack              ),\\n', '    .biucmd_noncacheable_req_o ( biucmd_noncacheable_req ),\\n', '    .biucmd_noncacheable_ack_i ( biucmd_noncacheable_ack ),\\n', '    .biucmd_adri_o             ( biucmd_adr              ),\\n', '    .biucmd_tagi_o             ( biucmd_tag              ),\\n', '    .inflight_cnt_i            ( inflight_cnt            ),\\n', '\\n', '    .cache_hit_i               ( cache_hit               ),\\n', '    .cache_line_i              ( cache_line              ),\\n', '\\n', '    .biu_stb_ack_i             ( biu_stb_ack_i           ),\\n', '    .biu_ack_i                 ( biu_ack_i               ),\\n', '    .biu_err_i                 ( biu_err_i               ),\\n', '    .biu_adro_i                ( biu_adro_i              ),\\n', '    .biu_tago_i                ( biu_tago_i              ),\\n', '    .biu_q_i                   ( biu_q_i                 ),\\n', '    .in_biubuffer_i            ( in_biubuffer            ),\\n', '    .biubuffer_i               ( biubuffer               ),\\n', '\\n', '    .parcel_o                  ( parcel_o                ),\\n', '    .parcel_valid_o            ( parcel_valid_o          ),\\n', '    .parcel_error_o            ( parcel_error_o          ),\\n', '    .parcel_misaligned_o       ( parcel_misaligned_o     ),\\n', '    .parcel_pagefault_o        ( parcel_pagefault_o      ) );\\n', '\\n', '\\n', '\\n', '  //----------------------------------------------------------------\\n', '  // Memory Blocks\\n', '  //----------------------------------------------------------------\\n', '  riscv_cache_memory #(\\n', '    .XLEN                      ( XLEN                    ),\\n', '    .PLEN                      ( PLEN                    ),\\n', '    .SIZE                      ( SIZE                    ),\\n', '    .BLOCK_SIZE                ( BLOCK_SIZE              ),\\n', '    .WAYS                      ( WAYS                    ),\\n', '\\n', '    .TECHNOLOGY                ( TECHNOLOGY              ) )\\n', '  cache_memory_inst (\\n', '    .rst_ni                    ( rst_ni                  ),\\n', '    .clk_i                     ( clk_i                   ),\\n', '\\n', '    .stall_i                   ( mem_stall_o             ),\\n', '\\n', '    .armed_i                   ( armed                   ),\\n', '\\n', \"    .cleaning_i                ( 1'b0                    ),\\n\", '    .clean_way_int_o           (                         ),\\n', '    .clean_idx_o               (                         ),\\n', \"    .clean_way_i               ( {WAYS        {1'b0}}    ),\\n\", \"    .clean_idx_i               ( {IDX_BITS    {1'b0}}    ),\\n\", '\\n', \"    .invalidate_block_i        ( 1'b0                    ),\\n\", '    .invalidate_all_blocks_i   ( invalidate_all_blocks   ),\\n', '    .filling_i                 ( filling                 ),\\n', '    .fill_way_select_i         ( fill_way_select         ),\\n', '    .fill_way_i                ( hit_fill_way            ),\\n', '    .fill_way_o                ( mem_fill_way            ),\\n', '\\n', '    .rd_core_tag_i             ( tag_core_tag            ),\\n', '    .wr_core_tag_i             ( hit_core_tag            ),\\n', '    .rd_idx_i                  ( setup_idx               ),\\n', '    .wr_idx_i                  ( hit_idx                 ),\\n', '\\n', \"    .rreq_i                    ( 1'b0                    ), //Read cache memories?\\n\", \"    .writebuffer_we_i          ( 1'b0                    ),\\n\", \"    .writebuffer_be_i          ( {BLK_BITS/8   {1'b0}}   ),\\n\", \"    .writebuffer_idx_i         ( {IDX_BITS     {1'b0}}   ),\\n\", \"    .writebuffer_offs_i        ( {DAT_OFFS_BITS{1'b0}}   ),\\n\", \"    .writebuffer_data_i        ( {XLEN         {1'b0}}   ),\\n\", \"    .writebuffer_ways_hit_i    ( {WAYS         {1'b0}}   ),\\n\", \"    .writebuffer_cleaning_i    ( 1'b0                    ),\\n\", '\\n', \"    .evict_read_i              ( 1'b0                    ),\\n\", '    .evict_adr_o               (                         ),\\n', '    .evict_line_o              (                         ),\\n', '\\n', '    .biu_line_i                ( biu_line                ),\\n', \"    .biu_line_dirty_i          ( 1'b0                    ),\\n\", '    .biucmd_ack_i              ( biucmd_ack              ),\\n', '\\n', '    .latchmem_i                (~mem_stall_o             ),\\n', '    .hit_o                     ( cache_hit               ),\\n', '    .ways_hit_o                (                         ),\\n', '    .cache_dirty_o             (                         ),\\n', '    .way_dirty_o               (                         ),\\n', '    .ways_dirty_o              (                         ),\\n', '    .cache_line_o              ( cache_line              ) );\\n', '\\n', '\\n', '\\n', '  //----------------------------------------------------------------\\n', '  // Bus Interface Statemachine\\n', '  //----------------------------------------------------------------\\n', '  riscv_cache_biu_ctrl #(\\n', '    .XLEN                      ( XLEN                    ),\\n', '    .PLEN                      ( PLEN                    ),\\n', '    .SIZE                      ( SIZE                    ),\\n', '    .BLOCK_SIZE                ( BLOCK_SIZE              ),\\n', '    .WAYS                      ( WAYS                    ),\\n', '    .INFLIGHT_DEPTH            ( INFLIGHT_DEPTH          ),\\n', '    .BIUTAG_SIZE               ( BIUTAG_SIZE             ) )\\n', '  biu_ctrl_inst (\\n', '    .rst_ni                    ( rst_ni                  ),\\n', '    .clk_i                     ( clk_i                   ),\\n', '\\n', '    .flush_i                   ( mem_flush_i             ),\\n', '\\n', '    .biucmd_i                  ( biucmd                  ),\\n', '    .biucmd_ack_o              ( biucmd_ack              ),\\n', '    .biucmd_busy_o             (                         ),\\n', '    .biucmd_noncacheable_req_i ( biucmd_noncacheable_req ),\\n', '    .biucmd_noncacheable_ack_o ( biucmd_noncacheable_ack ),\\n', '    .biucmd_tag_i              ( biucmd_tag              ),\\n', '    .inflight_cnt_o            ( inflight_cnt            ),\\n', '\\n', '    .req_i                     ( tag_req                 ),\\n', '    .adr_i                     ( biucmd_adr              ),\\n', '    .size_i                    ( tag_size                ),\\n', '    .prot_i                    ( tag_prot                ),\\n', \"    .lock_i                    ( 1'b0                    ),\\n\", \"    .we_i                      ( 1'b0                    ),\\n\", \"    .be_i                      ( {XLEN/8  {1'b0}}        ),\\n\", \"    .d_i                       ( {XLEN    {1'b0}}        ),\\n\", '\\n', \"    .evictbuffer_adr_i         ( {PLEN    {1'b0}}        ),\\n\", \"    .evictbuffer_d_i           ( {BLK_BITS{1'b0}}        ),\\n\", '    .biubuffer_o               ( biubuffer               ),\\n', '    .in_biubuffer_o            ( in_biubuffer            ),\\n', '    .biu_line_o                ( biu_line                ),\\n', '    .biu_line_dirty_o          (                         ),\\n', '\\n', '     //To BIU\\n', '    .biu_stb_o                 ( biu_stb_o               ),\\n', '    .biu_stb_ack_i             ( biu_stb_ack_i           ),\\n', '    .biu_d_ack_i               ( biu_d_ack_i             ),\\n', '    .biu_adri_o                ( biu_adri_o              ),\\n', '    .biu_adro_i                ( biu_adro_i              ),\\n', '    .biu_size_o                ( biu_size_o              ),\\n', '    .biu_type_o                ( biu_type_o              ),\\n', '    .biu_lock_o                ( biu_lock_o              ),\\n', '    .biu_prot_o                ( biu_prot_o              ),\\n', '    .biu_we_o                  ( biu_we_o                ),\\n', '    .biu_d_o                   ( biu_d_o                 ),\\n', '    .biu_q_i                   ( biu_q_i                 ),\\n', '    .biu_ack_i                 ( biu_ack_i               ),\\n', '    .biu_err_i                 ( biu_err_i               ),\\n', '    .biu_tagi_o                ( biu_tagi_o              ),\\n', '    .biu_tago_i                ( biu_tago_i              ) );\\n', '\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Instruction Cache FSM                                        //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2018 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_icache_fsm\\n', 'import riscv_cache_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter XLEN           = 32,\\n', '  parameter PLEN           = XLEN == 32 ? 34 : 56,\\n', '  parameter PARCEL_SIZE    = XLEN,\\n', '  parameter HAS_RVC        = 0,\\n', '\\n', '  parameter SIZE           = 64,\\n', '  parameter BLOCK_SIZE     = XLEN,\\n', '  parameter WAYS           = 2,\\n', '\\n', '  parameter INFLIGHT_DEPTH = 2,\\n', '  parameter BIUTAG_SIZE    = $clog2(XLEN/PARCEL_SIZE),\\n', ' \\n', '  localparam BLK_BITS      = no_of_block_bits(BLOCK_SIZE),\\n', '  localparam SETS          = no_of_sets(SIZE, BLOCK_SIZE, WAYS),\\n', '  localparam BLK_OFFS_BITS = no_of_block_offset_bits(BLOCK_SIZE),\\n', '  localparam IDX_BITS      = no_of_index_bits(SETS),\\n', '  localparam TAG_BITS      = no_of_tag_bits(PLEN, IDX_BITS, BLK_OFFS_BITS),\\n', '  localparam INFLIGHT_BITS = $clog2(INFLIGHT_DEPTH+1)\\n', ')\\n', '(\\n', '  input  logic                        rst_ni,\\n', '  input  logic                        clk_i,\\n', '\\n', '  output logic                        stall_o,\\n', '  input  logic                        flush_i,                 //flush pipe\\n', '\\n', '  input  logic                        invalidate_i,            //invalidate cache\\n', '  input  logic                        dc_clean_rdy_i,          //data cache clean ready\\n', '\\n', '  output logic                        armed_o,\\n', '  output logic                        invalidate_all_blocks_o, //invalidate all cache valid bits\\n', '  output logic                        filling_o,\\n', '  input  logic [WAYS            -1:0] fill_way_i,\\n', '  output logic [WAYS            -1:0] fill_way_o,\\n', '\\n', '  input  logic                        req_i,                   //from previous-stage\\n', '  input  logic [PLEN            -1:0] adr_i,\\n', '  input  biu_size_t                   size_i,\\n', '  input  logic                        lock_i,\\n', '  input  biu_prot_t                   prot_i,\\n', '  input  logic                        cacheable_i,\\n', '  input  logic                        misaligned_i,\\n', '  input  logic                        pma_exception_i,\\n', '  input  logic                        pmp_exception_i,\\n', '  input  logic                        pagefault_i,\\n', '\\n', '  input  logic                        cache_hit_i,             //from cache-memory\\n', '  input  logic [BLK_BITS        -1:0] cache_line_i,\\n', '  output logic [IDX_BITS        -1:0] idx_o,\\n', '  output logic [TAG_BITS        -1:0] core_tag_o,\\n', '\\n', '  output biucmd_t                     biucmd_o,\\n', '  input  logic                        biucmd_ack_i,\\n', '  output logic                        biucmd_noncacheable_req_o,\\n', '  input  logic                        biucmd_noncacheable_ack_i,\\n', '  output logic [PLEN            -1:0] biucmd_adri_o,\\n', '  output logic [BIUTAG_SIZE     -1:0] biucmd_tagi_o,\\n', '  input  logic [INFLIGHT_BITS   -1:0] inflight_cnt_i,\\n', '\\n', '\\n', '  input  logic [XLEN            -1:0] biu_q_i,\\n', '  input  logic                        biu_stb_ack_i,\\n', '                                      biu_ack_i,\\n', '                                      biu_err_i,\\n', '  input  logic [PLEN            -1:0] biu_adro_i,\\n', '  input  logic [BIUTAG_SIZE     -1:0] biu_tago_i,\\n', '  input  logic                        in_biubuffer_i,\\n', '  input  logic [BLK_BITS        -1:0] biubuffer_i,\\n', '\\n', '  output logic [XLEN            -1:0] parcel_o,\\n', '  output logic [XLEN/PARCEL_SIZE-1:0] parcel_valid_o,\\n', '  output logic                        parcel_error_o,\\n', '  output logic                        parcel_misaligned_o,\\n', '  output logic                        parcel_pagefault_o\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Constants\\n', '  //\\n', '  localparam DAT_OFFS_BITS = no_of_data_offset_bits (XLEN, BLK_BITS);   //Offset in block\\n', '  localparam BURST_OFF     = XLEN/8;\\n', '  localparam BURST_LSB     = $clog2(BURST_OFF);\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Functions\\n', '  //\\n', '  function automatic integer onehot2int;\\n', '    input [WAYS-1:0] a;\\n', '\\n', '    integer i;\\n', '\\n', '    onehot2int = 0;\\n', '\\n', '    for (i=0; i<WAYS; i++)\\n', '      if (a[i]) onehot2int = i;\\n', '  endfunction: onehot2int\\n', '\\n', '\\n', '  function automatic [XLEN/8-1:0] size2be;\\n', '    input [     2:0] size;\\n', '    input [XLEN-1:0] adr;\\n', '\\n', '    logic [$clog2(XLEN/8)-1:0] adr_lsbs;\\n', '\\n', '    adr_lsbs = adr[$clog2(XLEN/8)-1:0];\\n', '\\n', '    unique case (size)\\n', \"      BYTE : size2be = 'h1  << adr_lsbs;\\n\", \"      HWORD: size2be = 'h3  << adr_lsbs;\\n\", \"      WORD : size2be = 'hf  << adr_lsbs;\\n\", \"      DWORD: size2be = 'hff << adr_lsbs;\\n\", '    endcase\\n', '  endfunction: size2be\\n', '\\n', '\\n', '  function automatic [XLEN-1:0] be_mux;\\n', '    input [XLEN/8-1:0] be;\\n', '    input [XLEN  -1:0] o; //old data\\n', '    input [XLEN  -1:0] n; //new data\\n', '\\n', '    integer i;\\n', '\\n', '    for (i=0; i<XLEN/8;i++)\\n', '      be_mux[i*8 +: 8] = be[i] ? n[i*8 +: 8] : o[i*8 +: 8];\\n', '  endfunction: be_mux\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Typedefs\\n', '  //\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  logic [XLEN          -1:0] cache_q;\\n', '  logic                      cache_ack;\\n', '  logic                      biu_cacheable_ack;\\n', '  logic                      invalidate_hold;\\n', '  logic                      pma_pmp_exception;\\n', '  logic                      valid_req;\\n', '\\n', '  enum logic [2:0] {ARMED=0,\\n', '                    INVALIDATE,\\n', '                    NONCACHEABLE,\\n', '                    READ,\\n', '                    RECOVER0,\\n', '                    RECOVER1 } memfsm_state;\\n', '\\n', '  logic [PLEN          -1:0] biu_adro;\\n', '  logic                      biu_adro_eq_cache_adr_dly;\\n', '  logic [DAT_OFFS_BITS -1:0] dat_offset;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  assign pma_pmp_exception = pma_exception_i | pmp_exception_i;\\n', '  assign valid_req         = req_i & ~pma_pmp_exception & ~misaligned_i & ~pagefault_i & ~flush_i;\\n', '\\n', '\\n', '  //hold flush until ready to be serviced\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) invalidate_hold <= 1'b0;\\n\", '    else         invalidate_hold <= invalidate_i | (invalidate_hold & ~invalidate_all_blocks_o);\\n', '\\n', '\\n', '  //State Machine\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if (!rst_ni)\\n', '    begin\\n', '        memfsm_state            <= ARMED;\\n', \"        armed_o                 <= 1'b1;\\n\", \"        invalidate_all_blocks_o <= 1'b0;\\n\", \"        filling_o               <= 1'b0;\\n\", \"        fill_way_o              <=  'hx;\\n\", '        biucmd_o                <= BIUCMD_NOP;\\n', '    end\\n', '    else\\n', '    unique case (memfsm_state)\\n', '       ARMED        : if (invalidate_i | invalidate_hold)\\n', '                      begin\\n', '                          memfsm_state            <= INVALIDATE;\\n', \"                          armed_o                 <= 1'b0;\\n\", \"                          invalidate_all_blocks_o <= 1'b1;\\n\", '                      end\\n', '\\t\\t      else if (valid_req && !cacheable_i)\\n', '                      begin\\n', '                          memfsm_state <= NONCACHEABLE;\\n', \"                          armed_o      <= 1'b0;\\n\", '                      end\\n', '                      else if (valid_req && cacheable_i && !cache_hit_i)\\n', '                      begin\\n', '                          //Load way\\n', '                          memfsm_state <= READ;\\n', '                          biucmd_o     <= BIUCMD_READWAY;\\n', \"                          armed_o      <= 1'b0;\\n\", \"                          filling_o    <= 1'b1;\\n\", '                          fill_way_o   <= fill_way_i;\\n', '                      end\\n', '                      else\\n', '                      begin\\n', '                          biucmd_o <= BIUCMD_NOP;\\n', '                      end\\n', '\\n', '       INVALIDATE   : if (dc_clean_rdy_i) //wait for data-cache to complete cleaning\\n', '                      begin\\n', '                          memfsm_state            <= RECOVER0; //allow to read new tag_idx\\n', \"                          invalidate_all_blocks_o <= 1'b0;\\n\", '                      end\\n', '\\n', \"        NONCACHEABLE: if ( flush_i                                       ||  //flush pipe, no biu_ack's will come\\n\", '\\t                  (!valid_req && inflight_cnt_i==1 && biu_ack_i) ||  //no new request, wait for BIU to finish transfer\\n', '                          ( valid_req && cacheable_i       && biu_ack_i) )   //new cacheable request, wait for non-cacheable transfer to finish\\n', '                      begin\\n', '                          memfsm_state <= ARMED;\\n', \"                          armed_o      <= 1'b1;\\n\", '                      end\\n', '\\n', '        READ        : begin\\n', '                          biucmd_o <= BIUCMD_NOP;\\n', '\\n', '                          if (biucmd_ack_i || biu_err_i)\\n', '                          begin\\n', '                              memfsm_state <= RECOVER0;\\n', \"                              filling_o    <= 1'b0;\\n\", '                          end\\n', '                      end\\n', '\\n', '        RECOVER0    : begin\\n', '                          //Setup TAG and DATA IDX after writing/filling\\n', '\\t\\t\\t  memfsm_state <= RECOVER1;\\n', '\\t\\t\\t  biucmd_o     <= BIUCMD_NOP;\\n', '                      end\\n', '\\n', '        RECOVER1    : begin\\n', '                          //Read TAG and DATA memory after writing/filling\\n', '                          memfsm_state <= ARMED;\\n', '                          biucmd_o     <= BIUCMD_NOP;\\n', \"                          armed_o      <= 1'b1;\\n\", '                      end\\n', '\\n', '    endcase\\n', '\\n', '\\n', '\\n', '  //Tag/Dat-index (for writing)\\n', '  assign idx_o = adr_i[BLK_OFFS_BITS +: IDX_BITS];\\n', '\\n', '\\n', '  //core-tag (for writing)\\n', '  assign core_tag_o = adr_i[PLEN-1 -: TAG_BITS];\\n', '\\n', '\\n', '\\n', '  //non-cacheable access\\n', '  always_comb\\n', '    unique case (memfsm_state)\\n', \"      INVALIDATE: biucmd_noncacheable_req_o = 1'b0;\\n\", \"      READ      : biucmd_noncacheable_req_o = 1'b0;\\n\", \"      RECOVER0  : biucmd_noncacheable_req_o = 1'b0;\\n\", \"      RECOVER1  : biucmd_noncacheable_req_o = 1'b0;\\n\", '      default   : biucmd_noncacheable_req_o = valid_req & ~cacheable_i & ~(invalidate_i | invalidate_hold);\\n', '    endcase\\n', '\\n', '\\n', '  //Instruction fetch address\\n', '  assign biucmd_adri_o = ~cacheable_i\\n', \"                       ? adr_i & (XLEN==64 ? ~'h7 : ~'h3)\\n\", '                       : adr_i;\\n', '  assign biucmd_tagi_o = adr_i[1 +: BIUTAG_SIZE];\\n', '\\n', '\\n', '  //re-assemble biu_adro\\n', \"  assign biu_adro = {biu_adro_i[PLEN-1:BIUTAG_SIZE+1], biu_tago_i, 1'b0};\\n\", '\\n', '  //address check, used in a few places\\n', '  assign biu_adro_eq_cache_adr_dly = (biu_adro[PLEN-1:BURST_LSB] == adr_i[PLEN-1:BURST_LSB]);\\n', '\\n', '\\n', '  //Cache core halt signal\\n', '  always_comb\\n', '    unique case (memfsm_state)\\n', '      ARMED       : stall_o = (invalidate_i | invalidate_hold) |\\n', '                              (valid_req & (cacheable_i ? ~cache_hit_i : ~biu_stb_ack_i));\\n', '\\n', '      //req_i == 0 ? stall=|inflight_cnt\\n', '      //else is_cacheable ? stall=!biu_ack_i (wait for noncacheable transfer to finish)\\n', '      //else                stall=!biu_stb_ack_i\\n', '      NONCACHEABLE: stall_o = ~valid_req ? |inflight_cnt_i\\n', '\\t                                 : cacheable_i ? ~biu_ack_i : ~biu_stb_ack_i;\\n', '\\n', '      //TODO: Add in_biubuffer\\n', '      READ        : stall_o = ~( (valid_req & biu_ack_i & biu_adro_eq_cache_adr_dly) |\\n', '                                 (valid_req & cache_hit_i)\\n', '                               );\\n', '\\n', \"      RECOVER0    : stall_o = 1'b1;\\n\", '\\n', \"      RECOVER1    : stall_o = 1'b1;\\n\", '\\n', \"      INVALIDATE  : stall_o = 1'b1;\\n\", '\\n', \"      default     : stall_o = 1'b0;\\n\", '    endcase\\n', '\\n', '\\n', ' \\n', '\\n', '  //Shift amount for data\\n', '  assign dat_offset = adr_i[BLK_OFFS_BITS-1 -: DAT_OFFS_BITS];\\n', '\\n', '  //Assign parcel_o\\n', '  assign cache_q = (in_biubuffer_i ? biubuffer_i : cache_line_i) >> (dat_offset * XLEN);\\n', '\\n', '  always_comb\\n', '    unique case (memfsm_state)\\n', '      READ   : parcel_o = cache_hit_i ? cache_q : biu_q_i;\\n', '      default: parcel_o = cacheable_i ? cache_q : biu_q_i;\\n', '    endcase\\n', '\\n', '\\n', '  //acknowledge cache hit\\n', '  assign cache_ack         =  valid_req & cacheable_i & cache_hit_i & ~(invalidate_i | invalidate_hold);\\n', '  assign biu_cacheable_ack = (valid_req & biu_ack_i & biu_adro_eq_cache_adr_dly) |\\n', '                              cache_ack;\\n', '\\n', '\\n', '  //Assign parcel_valid\\n', '  always_comb\\n', '    unique case (memfsm_state)\\n', '      ARMED       : parcel_valid_o = {$bits(parcel_valid_o){cache_ack                }} << adr_i   [1 +: $clog2(XLEN/PARCEL_SIZE)]; \\n', '      NONCACHEABLE: parcel_valid_o = {$bits(parcel_valid_o){biucmd_noncacheable_ack_i}} << biu_adro[1 +: $clog2(XLEN/PARCEL_SIZE)];\\n', '      READ        : parcel_valid_o = {$bits(parcel_valid_o){biu_cacheable_ack        }} << adr_i   [1 +: $clog2(XLEN/PARCEL_SIZE)];\\n', \"      default     : parcel_valid_o = {$bits(parcel_valid_o){1'b0}};\\n\", '    endcase    \\n', '\\n', '\\n', ' //signal downstream the BIU reported an error\\n', '  assign parcel_error_o = biu_err_i | (req_i & pma_pmp_exception);\\n', '\\n', '\\n', '  //generate misaligned\\n', '  assign parcel_misaligned_o = req_i & misaligned_i;\\n', '\\n', '\\n', '  //generate pagefault\\n', '  assign parcel_pagefault_o = req_i & pagefault_i;\\n', '\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    No Data Cache Core Logic                                     //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2022 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_nodcache_core\\n', 'import biu_constants_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', '#(\\n', '  parameter XLEN        = 32,\\n', '  parameter ALEN        = XLEN,\\n', '  parameter DEPTH       = 2 \\n', ')\\n', '(\\n', '  input                  rst_ni,\\n', '  input                  clk_i,\\n', ' \\n', '  //CPU side\\n', '  input                  mem_req_i,\\n', '  input  biu_size_t      mem_size_i,\\n', '  input                  mem_lock_i,\\n', '  input                  mem_misaligned_i,\\n', '  input      [XLEN -1:0] mem_adr_i,\\n', '  input                  mem_we_i,\\n', '  input      [XLEN -1:0] mem_d_i,\\n', '  output     [XLEN -1:0] mem_q_o,\\n', '  output                 mem_ack_o,\\n', '  output                 mem_err_o,\\n', '  output reg             mem_misaligned_o,\\n', '  input      [      1:0] st_prv_i,\\n', '  \\n', '  //To BIU\\n', '  output reg             biu_stb_o,\\n', '  output     [ALEN -1:0] biu_adri_o,\\n', '  input      [ALEN -1:0] biu_adro_i,\\n', '  output biu_size_t      biu_size_o,     //transfer size\\n', '  output biu_type_t      biu_type_o,     //burst type -AHB style\\n', '  output                 biu_lock_o,\\n', '  output                 biu_we_o,\\n', '  output biu_prot_t      biu_prot_o,\\n', '  output     [XLEN -1:0] biu_d_o,\\n', '  input      [XLEN -1:0] biu_q_i,\\n', '  input                  biu_stb_ack_i,\\n', '  input                  biu_d_ack_i,\\n', '  input                  biu_ack_i,      //data acknowledge, 1 per data\\n', '  input                  biu_err_i       //data error\\n', ');\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  genvar                  n;\\n', '\\n', '  logic                   hold_mem_req;\\n', '  logic                   hold_mem_misaligned;\\n', '  logic [XLEN       -1:0] hold_mem_adr;\\n', '  logic [XLEN       -1:0] hold_mem_d;\\n', '  biu_size_t              hold_mem_size;\\n', '  biu_type_t              hold_mem_type;\\n', '  biu_prot_t              hold_mem_prot;\\n', '  logic                   hold_mem_lock;\\n', '  logic                   hold_mem_we;\\n', '\\n', '  logic                   misaligned;\\n', '  logic [DEPTH      -1:0] misaligned_queue;\\n', '  logic                   misaligned_in_pipe;\\n', '\\n', '  logic [$clog2(DEPTH):0] inflight,\\n', '\\t                  discard;\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '\\n', '  /* Statemachine\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    if (mem_req_i)\\n', '    begin\\n', '        hold_mem_misaligned <= mem_misaligned_i;\\n', '        hold_mem_adr        <= mem_adr_i;\\n', '        hold_mem_size       <= mem_size_i;\\n', '        hold_mem_lock       <= mem_lock_i;\\n', '        hold_mem_we         <= mem_we_i;\\n', '        hold_mem_d          <= mem_d_i;\\n', '    end\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', \"    if      (!rst_ni                ) hold_mem_req <= 1'b0;\\n\", '    else if ( misaligned_in_pipe ||\\n', \"              mem_err_o             ) hold_mem_req <= 1'b0;\\n\", '    else                              hold_mem_req <= (mem_req_i | hold_mem_req) & ~biu_stb_ack_i;\\n', '\\n', '\\n', '  assign misaligned = hold_mem_req ? hold_mem_misaligned : mem_misaligned_i & mem_req_i;\\n', '\\n', '  always @(posedge clk_i)\\n', '    misaligned_queue <= {misaligned_queue[0 +: DEPTH-1], misaligned};\\n', '\\n', '  assign misaligned_in_pipe = misaligned | |misaligned_queue;\\n', '  assign mem_misaligned_o   = misaligned_queue[DEPTH-1];\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni) inflight <= 'h0;\\n\", '    else\\n', '      unique case ({biu_stb_ack_i, biu_ack_i | biu_err_i})\\n', \"        2'b01  : inflight <= inflight -1;\\n\", \"        2'b10  : inflight <= inflight +1;\\n\", '        default: ; //do nothing\\n', '      endcase\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) discard <= 'h0;\\n\", '    else if (misaligned || mem_err_o)\\n', '    begin\\n', '        if (|inflight && (biu_ack_i | biu_err_i)) discard <= inflight -1;\\n', '        else                                      discard <= inflight;\\n', '    end\\n', '    else if (|discard && (biu_ack_i | biu_err_i)) discard <= discard -1;\\n', '\\n', '\\n', '  /* External Interface\\n', '   */\\n', '  assign biu_stb_o        = (mem_req_i | hold_mem_req) & ~misaligned_in_pipe;\\n', '  assign biu_adri_o       = hold_mem_req ? hold_mem_adr  : mem_adr_i;\\n', '  assign biu_size_o       = hold_mem_req ? hold_mem_size : mem_size_i;\\n', '  assign biu_lock_o       = hold_mem_req ? hold_mem_lock : mem_lock_i;\\n', \"  assign biu_prot_o       = biu_prot_t'(PROT_DATA |\\n\", '                                        st_prv_i == PRV_U ? PROT_USER : PROT_PRIVILEGED);\\n', '  assign biu_we_o         = hold_mem_req ? hold_mem_we   : mem_we_i;\\n', '  assign biu_d_o          = hold_mem_req ? hold_mem_d    : mem_d_i;\\n', '  assign biu_type_o       = SINGLE;\\n', '\\n', '  assign mem_q_o          = biu_q_i;\\n', \"  assign mem_ack_o        = |discard ? 1'b0\\n\", '                                     : |inflight ? biu_ack_i //& ~misaligned[0]\\n', '                                                 : biu_ack_i &  biu_stb_o;\\n', \"  assign mem_err_o        = |discard ? 1'b0\\n\", '                                     : |inflight ? biu_err_i //& ~misaligned[0]\\n', '                                                 : biu_err_i & biu_stb_o;\\n', '\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    No Instruction Cache Core Logic                              //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_noicache_core\\n', 'import biu_constants_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', '#(\\n', '  parameter XLEN        = 32,\\n', '  parameter PLEN        = XLEN,\\n', '  parameter PARCEL_SIZE = 16,\\n', '  parameter HAS_RVC     = 0,\\n', '  parameter DEPTH       = 2,        //number of transactions in flight\\n', '  parameter BIUTAG_SIZE = $clog2(XLEN/PARCEL_SIZE)\\n', ')\\n', '(\\n', '  input                             rst_ni,\\n', '  input                             clk_i,\\n', ' \\n', '  //CPU side\\n', '  input      [XLEN            -1:0] if_nxt_pc_i,\\n', '  input                             if_req_i,\\n', '  output                            if_ack_o,\\n', '  input  biu_prot_t                 if_prot_i,\\n', '  input                             if_flush_i,\\n', '  output     [XLEN            -1:0] if_parcel_pc_o,\\n', '  output     [XLEN            -1:0] if_parcel_o,\\n', '  output     [XLEN/PARCEL_SIZE-1:0] if_parcel_valid_o,\\n', '  output                            if_parcel_misaligned_o,\\n', '  output                            if_parcel_error_o,\\n', '  input                             cm_dc_clean_rdy_i,\\n', '  input      [                 1:0] st_prv_i,\\n', '\\n', '  //To BIU\\n', '  output                            biu_stb_o,\\n', '  input                             biu_stb_ack_i,\\n', '  input                             biu_d_ack_i,\\n', '  output     [PLEN            -1:0] biu_adri_o,\\n', '  input      [PLEN            -1:0] biu_adro_i,\\n', '  output biu_size_t                 biu_size_o,     //transfer size\\n', '  output biu_type_t                 biu_type_o,     //burst type -AHB style\\n', '  output                            biu_lock_o,\\n', '  output                            biu_we_o,\\n', '  output biu_prot_t                 biu_prot_o,\\n', '  output     [XLEN            -1:0] biu_d_o,\\n', '  input      [XLEN            -1:0] biu_q_i,\\n', '  input                             biu_ack_i,      //data acknowledge, 1 per data\\n', '  input                             biu_err_i,      //data error\\n', '  output     [BIUTAG_SIZE     -1:0] biu_tagi_o,\\n', '  input      [BIUTAG_SIZE     -1:0] biu_tago_i\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  logic if_flush_dly;\\n', '\\n', '  logic [$clog2(DEPTH):0] inflight,\\n', '\\t                  discard;\\n', '  \\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  //delay IF-flush\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) if_flush_dly <= 1'b0;\\n\", '    else         if_flush_dly <= if_flush_i;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni) inflight <= 'h0;\\n\", '    else\\n', '      unique case ({biu_stb_ack_i, biu_ack_i | biu_err_i})\\n', \"        2'b01  : inflight <= inflight -1;\\n\", \"        2'b10  : inflight <= inflight +1;\\n\", '        default: ; //do nothing\\n', '      endcase\\n', '\\n', '      \\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) discard <= 'h0;\\n\", '    else if (if_flush_i)\\n', '    begin\\n', '        if (|inflight && (biu_ack_i | biu_err_i)) discard <= inflight -1;\\n', '        else                                      discard <= inflight;\\n', '    end\\n', '    else if (|discard && (biu_ack_i | biu_err_i)) discard <= discard -1;\\n', '\\n', '\\n', '  /*\\n', '   * To CPU\\n', '   */\\n', '  assign if_ack_o               = cm_dc_clean_rdy_i & biu_stb_ack_i;  //get next parcel address\\n', '  assign if_parcel_misaligned_o = (HAS_RVC != 0) ? if_parcel_pc_o[0] : |if_parcel_pc_o[1:0];\\n', '  assign if_parcel_error_o      = biu_err_i;\\n', '  assign if_parcel_valid_o      = cm_dc_clean_rdy_i & ~(if_flush_i | if_flush_dly) & biu_ack_i & ~|discard\\n', \"                                ? {XLEN/PARCEL_SIZE{1'b1}} << biu_tago_i\\n\", \"                                : {XLEN/PARCEL_SIZE{1'b0}};\\n\", \"  assign if_parcel_pc_o         = { {PLEN - (BIUTAG_SIZE+1) - $bits(biu_tago_i) -1{1'b0}},biu_adro_i[PLEN -1 : BIUTAG_SIZE+1], biu_tago_i, 1'b0};\\n\", '  assign if_parcel_o            = biu_q_i;\\n', '\\n', '\\n', '  /*\\n', '   * External Interface\\n', '   */\\n', '  assign biu_stb_o   = cm_dc_clean_rdy_i & ~if_flush_i & if_req_i;\\n', 'generate  \\n', \"  if (PLEN <= XLEN) assign biu_adri_o = if_nxt_pc_i[PLEN -1:0]           & (XLEN==64 ? ~'h7 : ~'h3); //Always start at aligned address\\n\", \"  else              assign biu_adri_o = {{PLEN-XLEN{1'b0}}, if_nxt_pc_i} & (XLEN==64 ? ~'h7 : ~'h3);\\n\", 'endgenerate\\n', '  assign biu_tagi_o  = if_nxt_pc_i[1 +: BIUTAG_SIZE];                     //Use TAG to remember offset (actual address LSBs)\\n', '  assign biu_size_o  = XLEN==64 ? DWORD : WORD;\\n', \"  assign biu_lock_o  = 1'b0;\\n\", '  assign biu_prot_o  = if_prot_i;\\n', \"  assign biu_we_o    = 1'b0;   //no writes\\n\", \"  assign biu_d_o     =  'h0;\\n\", '  assign biu_type_o  = INCR;\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Arithmetic & Logical Unit (ALU)                              //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_alu\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', '#(\\n', '  parameter             XLEN    = 32,\\n', '  parameter             HAS_RVC = 0\\n', ')\\n', '(\\n', '  input                          rst_ni,\\n', '  input                          clk_i,\\n', '\\n', '  input                          ex_stall_i,\\n', '\\n', '  //Program counter\\n', '  input      [XLEN         -1:0] id_pc_i,\\n', '\\n', '  //Instruction\\n', '  input  instruction_t           id_insn_i,\\n', '\\n', '  //Operands\\n', '  input      [XLEN         -1:0] opA_i,\\n', '                                 opB_i,\\n', '\\n', '  //catch WB-exceptions\\n', '  input  interrupts_exceptions_t ex_exceptions_i,\\n', '                                 mem_exceptions_i,\\n', '                                 wb_exceptions_i,\\n', '\\n', '  //to WB\\n', '  output reg                     alu_bubble_o,\\n', '  output reg [XLEN         -1:0] alu_r_o,\\n', '\\n', '\\n', '  //To State\\n', '  output reg [             11:0] ex_csr_reg_o,\\n', '  output reg [XLEN         -1:0] ex_csr_wval_o,\\n', '  output reg                     ex_csr_we_o,\\n', '\\n', '  //From State\\n', '  input      [XLEN         -1:0] st_csr_rval_i,\\n', '  input      [              1:0] st_xlen_i\\n', ');\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // functions\\n', '  //\\n', '  function [XLEN-1:0] sext32;\\n', '    input [31:0] operand;\\n', '    logic sign;\\n', '  begin\\n', '    sign   = operand[31];\\n', '    sext32 = { {XLEN-31{sign}}, operand[30:0]};\\n', '  end\\n', '  endfunction\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  localparam SBITS=$clog2(XLEN);\\n', '\\n', '  opcR_t             opcR;\\n', '  logic              xlen32;\\n', '  logic              has_rvc;\\n', '\\n', '  //Operand generation\\n', '  logic [      31:0] opA32;\\n', '  logic [      31:0] opB32;\\n', '  logic [SBITS -1:0] shamt;\\n', '  logic [       4:0] shamt32;\\n', '  logic [XLEN  -1:0] csri;\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  /*\\n', '   * Instruction\\n', '   */\\n', '  assign opcR    = decode_opcR(id_insn_i.instr);\\n', '  assign xlen32  = (st_xlen_i == RV32I);\\n', '  assign has_rvc = (HAS_RVC !=     0);\\n', '\\n', '  /*\\n', '   *\\n', '   */\\n', '  assign opA32   = opA_i[     31:0];\\n', '  assign opB32   = opB_i[     31:0];\\n', '  assign shamt   = opB_i[SBITS-1:0];\\n', '  assign shamt32 = opB_i[      4:0];\\n', '  \\n', '\\n', '  /*\\n', '   * ALU operations\\n', '   */\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni    ) alu_r_o <= 'h0;\\n\", '    else if (!ex_stall_i)\\n', '      casex ( {xlen32, opcR} )\\n', \"        {1'b?,LUI   }: alu_r_o <= opA_i + opB_i; //actually just opB_i, but simplify encoding\\n\", \"        {1'b?,AUIPC }: alu_r_o <= opA_i + opB_i;\\n\", \"        {1'b?,JAL   }: alu_r_o <= id_pc_i + (&id_insn_i.instr[1:0] || !has_rvc ? 'h4 : 'h2);\\n\", \"        {1'b?,JALR  }: alu_r_o <= id_pc_i + (&id_insn_i.instr[1:0] || !has_rvc ? 'h4 : 'h2);\\n\", '\\n', '        //logical operators\\n', \"        {1'b?,ADDI  }: alu_r_o <= opA_i + opB_i;\\n\", \"        {1'b?,ADD   }: alu_r_o <= opA_i + opB_i;\\n\", \"        {1'b0,ADDIW }: alu_r_o <= sext32(opA32 + opB32);    //RV64\\n\", \"        {1'b0,ADDW  }: alu_r_o <= sext32(opA32 + opB32);    //RV64\\n\", \"        {1'b?,SUB   }: alu_r_o <= opA_i - opB_i;\\n\", \"        {1'b0,SUBW  }: alu_r_o <= sext32(opA32 - opB32);    //RV64\\n\", \"        {1'b?,XORI  }: alu_r_o <= opA_i ^ opB_i;\\n\", \"        {1'b?,XOR   }: alu_r_o <= opA_i ^ opB_i;\\n\", \"        {1'b?,ORI   }: alu_r_o <= opA_i | opB_i;\\n\", \"        {1'b?,OR    }: alu_r_o <= opA_i | opB_i;\\n\", \"        {1'b?,ANDI  }: alu_r_o <= opA_i & opB_i;\\n\", \"        {1'b?,AND   }: alu_r_o <= opA_i & opB_i;\\n\", \"        {1'b?,SLLI  }: alu_r_o <= opA_i << shamt;\\n\", \"        {1'b?,SLL   }: alu_r_o <= opA_i << shamt;\\n\", \"        {1'b0,SLLIW }: alu_r_o <= sext32(opA32 << shamt32); //RV64\\n\", \"        {1'b0,SLLW  }: alu_r_o <= sext32(opA32 << shamt32); //RV64\\n\", \"        {1'b?,SLTI  }: alu_r_o <= {~opA_i[XLEN-1],opA_i[XLEN-2:0]} < {~opB_i[XLEN-1],opB_i[XLEN-2:0]} ? 'h1 : 'h0;\\n\", \"        {1'b?,SLT   }: alu_r_o <= {~opA_i[XLEN-1],opA_i[XLEN-2:0]} < {~opB_i[XLEN-1],opB_i[XLEN-2:0]} ? 'h1 : 'h0;\\n\", \"        {1'b?,SLTIU }: alu_r_o <= opA_i < opB_i ? 'h1 : 'h0;\\n\", \"        {1'b?,SLTU  }: alu_r_o <= opA_i < opB_i ? 'h1 : 'h0;\\n\", \"        {1'b?,SRLI  }: alu_r_o <= opA_i >> shamt;\\n\", \"        {1'b?,SRL   }: alu_r_o <= opA_i >> shamt;\\n\", \"        {1'b0,SRLIW }: alu_r_o <= sext32(opA32 >> shamt32); //RV64\\n\", \"        {1'b0,SRLW  }: alu_r_o <= sext32(opA32 >> shamt32); //RV64\\n\", \"        {1'b?,SRAI  }: alu_r_o <= $signed(opA_i) >>> shamt;\\n\", \"        {1'b?,SRA   }: alu_r_o <= $signed(opA_i) >>> shamt;\\n\", \"        {1'b0,SRAIW }: alu_r_o <= sext32($signed(opA32) >>> shamt32);\\n\", \"        {1'b?,SRAW  }: alu_r_o <= sext32($signed(opA32) >>> shamt32);\\n\", '\\n', '        //CSR access\\n', \"        {1'b?,CSRRW }: alu_r_o <= {XLEN{1'b0}} | st_csr_rval_i;\\n\", \"        {1'b?,CSRRWI}: alu_r_o <= {XLEN{1'b0}} | st_csr_rval_i;\\n\", \"        {1'b?,CSRRS }: alu_r_o <= {XLEN{1'b0}} | st_csr_rval_i;\\n\", \"        {1'b?,CSRRSI}: alu_r_o <= {XLEN{1'b0}} | st_csr_rval_i;\\n\", \"        {1'b?,CSRRC }: alu_r_o <= {XLEN{1'b0}} | st_csr_rval_i;\\n\", \"        {1'b?,CSRRCI}: alu_r_o <= {XLEN{1'b0}} | st_csr_rval_i;\\n\", '\\n', \"        default      : alu_r_o <= 'hx;\\n\", '      endcase\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni                ) alu_bubble_o <= 1'b1;\\n\", '    else if ( ex_exceptions_i.any  ||\\n', '              mem_exceptions_i.any ||\\n', \"              wb_exceptions_i.any   ) alu_bubble_o <= 1'b1;\\n\", '    else if (!ex_stall_i)\\n', '      casex ( {xlen32,opcR} )\\n', \"        {1'b?,LUI   }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,AUIPC }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,JAL   }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,JALR  }: alu_bubble_o <= id_insn_i.bubble;\\n\", '\\n', '        //logical operators\\n', \"        {1'b?,ADDI  }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,ADD   }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b0,ADDIW }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b0,ADDW  }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,SUB   }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b0,SUBW  }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,XORI  }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,XOR   }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,ORI   }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,OR    }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,ANDI  }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,AND   }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,SLLI  }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,SLL   }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b0,SLLIW }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b0,SLLW  }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,SLTI  }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,SLT   }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,SLTIU }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,SLTU  }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,SRLI  }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,SRL   }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b0,SRLIW }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b0,SRLW  }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,SRAI  }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,SRA   }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b0,SRAIW }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,SRAW  }: alu_bubble_o <= id_insn_i.bubble;\\n\", '\\n', '        //CSR access\\n', \"        {1'b?,CSRRW }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,CSRRWI}: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,CSRRS }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,CSRRSI}: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,CSRRC }: alu_bubble_o <= id_insn_i.bubble;\\n\", \"        {1'b?,CSRRCI}: alu_bubble_o <= id_insn_i.bubble;\\n\", '\\n', \"        default      : alu_bubble_o <= 1'b1;\\n\", '    endcase\\n', '\\n', '\\n', '  /*\\n', '   * CSR\\n', '   */\\n', \"  assign csri = {{XLEN-5{1'b0}},opB_i[4:0]};\\n\", '\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', '    if (!rst_ni)\\n', '    begin\\n', \"        ex_csr_reg_o  <= 'hx;\\n\", \"        ex_csr_wval_o <= 'hx;\\n\", \"        ex_csr_we_o   <= 1'b0;\\n\", '    end\\n', '    else\\n', '    begin\\n', '        ex_csr_reg_o <= id_insn_i.instr.I.imm;\\n', '\\n', '        casex ( {id_insn_i.bubble,opcR} )\\n', \"          {1'b0,CSRRW } : begin\\n\", \"                              ex_csr_we_o   <= 'b1;\\n\", '                              ex_csr_wval_o <= opA_i;\\n', '                          end\\n', \"          {1'b0,CSRRWI} : begin\\n\", '                              ex_csr_we_o   <= |csri;\\n', '                              ex_csr_wval_o <= csri;\\n', '                          end\\n', \"          {1'b0,CSRRS } : begin\\n\", '                              ex_csr_we_o   <= |opA_i;\\n', '                              ex_csr_wval_o <= st_csr_rval_i | opA_i;\\n', '                          end\\n', \"          {1'b0,CSRRSI} : begin\\n\", '                              ex_csr_we_o   <= |csri;\\n', '                              ex_csr_wval_o <= st_csr_rval_i | csri;\\n', '                          end\\n', \"          {1'b0,CSRRC } : begin\\n\", '                              ex_csr_we_o   <= |opA_i;\\n', '                              ex_csr_wval_o <= st_csr_rval_i & ~opA_i;\\n', '                          end\\n', \"          {1'b0,CSRRCI} : begin\\n\", '                              ex_csr_we_o   <= |csri;\\n', '                              ex_csr_wval_o <= st_csr_rval_i & ~csri;\\n', '                          end\\n', '          default       : begin\\n', \"                              ex_csr_we_o   <= 'b0;\\n\", \"                              ex_csr_wval_o <= 'hx;\\n\", '                          end\\n', '    endcase\\n', '    end\\n', '\\n', 'endmodule \\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Branch Unit                                                  //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_bu\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', '#(\\n', '  parameter int        XLEN           = 32,\\n', \"  parameter [XLEN-1:0] PC_INIT        = 'h200,\\n\", '  parameter int        BP_GLOBAL_BITS = 2,\\n', '  parameter int        RSB_DEPTH      = 0,\\n', '  parameter int        HAS_RVC        = 0\\n', ')\\n', '(\\n', '  input                           rst_ni,\\n', '  input                           clk_i,\\n', '\\n', '  input                           ex_stall_i,\\n', '  input                           st_flush_i,\\n', '\\n', '  output reg                      bu_bubble_o,\\n', '\\n', '  //Program counter\\n', '  input      [XLEN          -1:0] id_pc_i,\\n', '                                  id_rsb_pc_i,\\n', '  output reg [XLEN          -1:0] bu_nxt_pc_o,\\n', '  output reg                      bu_flush_o,\\n', '                                  cm_ic_invalidate_o,\\n', '                                  cm_dc_invalidate_o,\\n', '                                  cm_dc_clean_o,\\n', '  input      [               1:0] id_bp_predict_i,\\n', '  output reg [               1:0] bu_bp_predict_o,\\n', '  input      [BP_GLOBAL_BITS-1:0] id_bp_history_i,\\n', '  output reg [BP_GLOBAL_BITS-1:0] bu_bp_history_update_o,\\n', '                                  bu_bp_history_o,\\n', '  output reg                      bu_bp_btaken_o,\\n', '  output reg                      bu_bp_update_o,\\n', '\\n', '  //Instruction\\n', '  input  instruction_t            id_insn_i,\\n', '\\n', '  input  interrupts_exceptions_t  id_exceptions_i,\\n', '                                  ex_exceptions_i,\\n', '                                  mem_exceptions_i,\\n', '                                  wb_exceptions_i,\\n', '  output interrupts_exceptions_t  bu_exceptions_o,\\n', '\\n', '  //from ID\\n', '  input      [XLEN          -1:0] opA_i,\\n', '                                  opB_i\\n', ');\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  localparam SBITS=$clog2(XLEN);\\n', '\\n', '  logic                    has_rvc;\\n', '  logic                    has_rsb;\\n', '  logic                    is_16bit_instruction;\\n', '  opcR_t                   opcR;\\n', '  rsd_t                    rs1;\\n', '  logic                    is_ret;\\n', '  logic                    misaligned_instruction;\\n', '\\n', '  //Immediates\\n', '  immUJ_t                  immUJ;\\n', '  immSB_t                  immSB;\\n', '  logic [XLEN        -1:0] ext_immUJ,\\n', '                           ext_immSB;\\n', '\\n', '  //Branch controls\\n', '  logic                    bu_bubble;\\n', '  logic                    pipeflush,\\n', '                           ic_invalidate,\\n', '                           dc_invalidate,\\n', '                           dc_clean,\\n', '                           cacheflush,\\n', '                           btaken,\\n', '                           bp_update;\\n', '  logic [BP_GLOBAL_BITS:0] bp_history;\\n', '  logic [XLEN        -1:0] nxt_pc;\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  /*\\n', '   * Instruction\\n', '   */\\n', '  assign has_rvc = (HAS_RVC !=  0);\\n', '  assign has_rsb = (RSB_DEPTH > 0);\\n', '  assign is_16bit_instruction = ~&id_insn_i.instr[1:0];\\n', '  assign opcR    = decode_opcR(id_insn_i.instr);\\n', '  assign rs1     = decode_rs1 (id_insn_i.instr);\\n', '  assign is_ret  = (rs1 == 1) | (rs1 == 5);\\n', '\\n', '  /*\\n', '   * Exceptions\\n', '   */\\n', '  always_comb\\n', '    casex ( {id_insn_i.bubble,id_insn_i.instr.R.opcode} )\\n', \"      {1'b0,OPC_JALR  } : misaligned_instruction = id_exceptions_i.exceptions.misaligned_instruction | has_rvc ? nxt_pc[0] : |nxt_pc[1:0];\\n\", \"      {1'b0,OPC_BRANCH} : misaligned_instruction = id_exceptions_i.exceptions.misaligned_instruction | has_rvc ? nxt_pc[0] : |nxt_pc[1:0];\\n\", '      default           : misaligned_instruction = id_exceptions_i.exceptions.misaligned_instruction;\\n', '    endcase\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni    ) bu_exceptions_o <= 'h0;\\n\", '    else if (!ex_stall_i)\\n', '    begin\\n', '        if ( bu_flush_o || st_flush_i || \\n', '             ex_exceptions_i.any || mem_exceptions_i.any || wb_exceptions_i.any  )\\n', '        begin\\n', \"            bu_exceptions_o <= 'h0;\\n\", '        end\\n', '        else\\n', '        begin\\n', '            bu_exceptions_o                                   <= id_exceptions_i;\\n', '            bu_exceptions_o.exceptions.misaligned_instruction <= misaligned_instruction;\\n', '            bu_exceptions_o.any                               <= id_exceptions_i.any | misaligned_instruction;\\n', '        end\\n', '    end\\n', '\\n', '\\n', '  /*\\n', '   * Decode Immediates\\n', '   */\\n', '  assign immUJ     = decode_immUJ(id_insn_i.instr);\\n', '  assign immSB     = decode_immSB(id_insn_i.instr);\\n', '  assign ext_immUJ = { {XLEN-$bits(immUJ){immUJ[$left(immUJ,1)]}}, immUJ};\\n', '  assign ext_immSB = { {XLEN-$bits(immSB){immSB[$left(immSB,1)]}}, immSB};\\n', '\\n', '\\n', '  /*\\n', '   * Program Counter modifications\\n', '   * - Branches/JALR (JAL/JALR results handled by ALU)\\n', '   * - Exceptions\\n', '   */\\n', '  always_comb \\n', '    casex ( {id_insn_i.bubble,opcR} )\\n', \"      {1'b0,JAL    }: begin //This is really only for the debug unit, such that NPC points to the correct address\\n\", \"                          bu_bubble     = 1'b0;\\n\", \"                          btaken        = 1'b1;\\n\", \"                          bp_update     = 1'b0;\\n\", '                          pipeflush     = ~id_bp_predict_i[1]; //Only flush here if no jump/branch prediction\\n', \"                          cacheflush    = 1'b0;\\n\", \"                          ic_invalidate = 1'b0;\\n\", \"                          dc_invalidate = 1'b0;\\n\", \"                          dc_clean      = 1'b0;\\n\", '                          nxt_pc        = id_pc_i + ext_immUJ;\\n', '                      end\\n', \"      {1'b0,JALR   }: if (has_rsb)\\n\", '                      begin\\n', \"                          bu_bubble     = 1'b0;\\n\", \"                          btaken        = 1'b1;\\n\", \"                          bp_update     = 1'b0;\\n\", \"                          cacheflush    = 1'b0;\\n\", \"                          ic_invalidate = 1'b0;\\n\", \"                          dc_invalidate = 1'b0;\\n\", \"                          dc_clean      = 1'b0;\\n\", \"                          nxt_pc        = (opA_i + opB_i) & { {XLEN-1{1'b1}},1'b0 };\\n\", \"                          pipeflush     = is_ret ?  (nxt_pc[XLEN-1:1] != id_rsb_pc_i[XLEN-1:1]) : 1'b1;\\n\", '                      end\\n', '                      else\\n', '                      begin\\n', \"                          bu_bubble     = 1'b0;\\n\", \"                          btaken        = 1'b1;\\n\", \"                          bp_update     = 1'b0;\\n\", \"                          pipeflush     = 1'b1;\\n\", \"                          cacheflush    = 1'b0;\\n\", \"                          ic_invalidate = 1'b0;\\n\", \"                          dc_invalidate = 1'b0;\\n\", \"                          dc_clean      = 1'b0;\\n\", \"                          nxt_pc        = (opA_i + opB_i) & { {XLEN-1{1'b1}},1'b0 };\\n\", '                      end\\n', \"      {1'b0,BEQ    }: begin\\n\", \"                          bu_bubble     = 1'b0;\\n\", '                          btaken        = (opA_i == opB_i);\\n', \"                          bp_update     = 1'b1;\\n\", '                          pipeflush     = btaken ^ id_bp_predict_i[1];\\n', \"                          cacheflush    = 1'b0;\\n\", \"                          ic_invalidate = 1'b0;\\n\", \"                          dc_invalidate = 1'b0;\\n\", \"                          dc_clean      = 1'b0;\\n\", \"                          nxt_pc        = btaken ? id_pc_i + ext_immSB : id_pc_i +(is_16bit_instruction ? 'h2 : 'h4);\\n\", '                      end\\n', \"      {1'b0,BNE    }: begin\\n\", \"                          bu_bubble     = 1'b0;\\n\", '                          btaken        = (opA_i != opB_i);\\n', \"                          bp_update     = 1'b1;\\n\", '                          pipeflush     = btaken ^ id_bp_predict_i[1];\\n', \"                          cacheflush    = 1'b0;\\n\", \"                          ic_invalidate = 1'b0;\\n\", \"                          dc_invalidate = 1'b0;\\n\", \"                          dc_clean      = 1'b0;\\n\", \"                          nxt_pc        = btaken ? id_pc_i + ext_immSB : id_pc_i + (is_16bit_instruction ? 'h2 : 'h4);\\n\", '                       end\\n', \"      {1'b0,BLTU   }: begin\\n\", \"                          bu_bubble     = 1'b0;\\n\", '                          btaken        = (opA_i < opB_i);\\n', \"                          bp_update     = 1'b1;\\n\", '                          pipeflush     = btaken ^ id_bp_predict_i[1];\\n', \"                          cacheflush    = 1'b0;\\n\", \"                          ic_invalidate = 1'b0;\\n\", \"                          dc_invalidate = 1'b0;\\n\", \"                          dc_clean      = 1'b0;\\n\", \"                          nxt_pc        = btaken ? id_pc_i + ext_immSB : id_pc_i + 'h4;\\n\", '                      end\\n', \"      {1'b0,BGEU   }: begin\\n\", \"                          bu_bubble     = 1'b0;\\n\", '                          btaken        = (opA_i >= opB_i);\\n', \"                          bp_update     = 1'b1;\\n\", '                          pipeflush     = btaken ^ id_bp_predict_i[1];\\n', \"                          cacheflush    = 1'b0;\\n\", \"                          ic_invalidate = 1'b0;\\n\", \"                          dc_invalidate = 1'b0;\\n\", \"                          dc_clean      = 1'b0;\\n\", \"                          nxt_pc        = btaken ? id_pc_i + ext_immSB : id_pc_i +'h4;\\n\", '                      end\\n', \"      {1'b0,BLT    }: begin\\n\", \"                          bu_bubble     = 1'b0;\\n\", '                          btaken        = $signed(opA_i) <  $signed(opB_i); \\n', \"                          bp_update     = 1'b1;\\n\", '                          pipeflush     = btaken ^ id_bp_predict_i[1];\\n', \"                          cacheflush    = 1'b0;\\n\", \"                          ic_invalidate = 1'b0;\\n\", \"                          dc_invalidate = 1'b0;\\n\", \"                          dc_clean      = 1'b0;\\n\", \"                          nxt_pc        = btaken ? id_pc_i + ext_immSB : id_pc_i + 'h4;\\n\", '                      end\\n', \"      {1'b0,BGE    }: begin\\n\", \"                          bu_bubble     = 1'b0;\\n\", '                          btaken        = $signed(opA_i) >= $signed(opB_i);\\n', \"                          bp_update     = 1'b1;\\n\", '                          pipeflush     = btaken ^ id_bp_predict_i[1];\\n', \"                          cacheflush    = 1'b0;\\n\", \"                          ic_invalidate = 1'b0;\\n\", \"                          dc_invalidate = 1'b0;\\n\", \"                          dc_clean      = 1'b0;\\n\", \"                          nxt_pc        = btaken ? id_pc_i + ext_immSB : id_pc_i + 'h4;\\n\", '                      end\\n', \"      {1'b0,MISCMEM}: case (id_insn_i.instr)\\n\", '                         FENCE_I: begin\\n', \"                                      bu_bubble     = 1'b0;\\n\", \"                                      btaken        = 1'b0;\\n\", \"                                      bp_update     = 1'b0;\\n\", \"                                      pipeflush     = 1'b1;\\n\", \"                                      cacheflush    = 1'b1;\\n\", \"                                      ic_invalidate = 1'b1;\\n\", \"                                      dc_invalidate = 1'b0;\\n\", \"                                      dc_clean      = 1'b1;\\n\", \"                                      nxt_pc        = id_pc_i +'h4;\\n\", '                                  end\\n', '                         default: begin\\n', \"                                      bu_bubble     = 1'b1;\\n\", \"                                      btaken        = 1'b0;\\n\", \"                                      bp_update     = 1'b0;\\n\", \"                                      pipeflush     = 1'b0;\\n\", \"                                      cacheflush    = 1'b0;\\n\", \"                                      ic_invalidate = 1'b0;\\n\", \"                                      dc_invalidate = 1'b0;\\n\", \"                                      dc_clean      = 1'b0;\\n\", \"                                      nxt_pc        = id_pc_i + 'h4;\\n\", '                                   end\\n', '                      endcase\\n', '      default       : begin\\n', \"                          bu_bubble     = 1'b1;\\n\", \"                          btaken        = 1'b0;\\n\", \"                          bp_update     = 1'b0;\\n\", \"                          pipeflush     = 1'b0;\\n\", \"                          cacheflush    = 1'b0;\\n\", \"                          ic_invalidate = 1'b0;\\n\", \"                          dc_invalidate = 1'b0;\\n\", \"                          dc_clean      = 1'b0;\\n\", \"                          nxt_pc        = id_pc_i + (is_16bit_instruction ? 'h2 : 'h4);\\n\", '                      end\\n', '    endcase\\n', '\\n', '\\n', '  /*\\n', '   * Program Counter modifications (Branches/JALR)\\n', '   */\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni                ) bu_bubble_o <= 1'b1;\\n\", '    else if ( ex_exceptions_i.any  ||\\n', '              mem_exceptions_i.any ||\\n', \"              wb_exceptions_i.any   ) bu_bubble_o <= 1'b1;\\n\", '    else if (!ex_stall_i            ) bu_bubble_o <= bu_bubble;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if (!rst_ni)\\n', '    begin\\n', \"        bu_flush_o                <= 1'b1;\\n\", \"\\tcm_ic_invalidate_o        <= 1'b0;\\n\", \"\\tcm_dc_invalidate_o        <= 1'b0;\\n\", \"\\tcm_dc_clean_o             <= 1'b0;\\n\", '\\n', \"        bu_bp_predict_o           <= 2'b00;\\n\", \"        bu_bp_btaken_o            <= 1'b0;\\n\", \"        bu_bp_update_o            <= 1'b0;\\n\", \"\\tbu_bp_history_update_o    <= 'h0;\\n\", \"        bp_history                <= 'h0;\\n\", '    end\\n', '    else\\n', '    begin\\n', \"        bu_flush_o                <= (pipeflush === 1'b1);\\n\", '        cm_ic_invalidate_o        <= ic_invalidate;\\n', '        cm_dc_invalidate_o        <= dc_invalidate;\\n', '        cm_dc_clean_o             <= dc_clean;\\n', '\\n', '        bu_bp_predict_o           <= id_bp_predict_i;\\n', '        bu_bp_btaken_o            <= btaken;\\n', '        bu_bp_update_o            <= bp_update;\\n', '\\tbu_bp_history_update_o    <= id_bp_history_i;\\n', '\\n', '\\t//Branch History is a simple shift register\\n', '        if (bp_update) bp_history <= {bp_history[BP_GLOBAL_BITS-1:0],btaken};\\n', '    end\\n', '\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '   if      (!rst_ni     ) bu_nxt_pc_o <= PC_INIT;\\n', '   else if (!ex_stall_i ) bu_nxt_pc_o <= nxt_pc;\\n', '\\n', '\\n', \"  //don't take myself (current branch) into account when updating branch history\\n\", '  assign bu_bp_history_o = bp_history[BP_GLOBAL_BITS:1];\\n', '\\n', 'endmodule \\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Division Unit                                                //\\n', '//                                                                 //\\n', '//    Implements Non-Performing Restoring Division                 //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2017-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_div\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', '#(\\n', '  parameter XLEN = 32\\n', ')\\n', '(\\n', '  input                 rst_ni,\\n', '  input                 clk_i,\\n', '\\n', '  input                 mem_stall_i,\\n', '  input                 ex_stall_i,\\n', '  output reg            div_stall_o,\\n', '\\n', '  //Instruction\\n', '  input  instruction_t  id_insn_i,\\n', '\\n', '  //Operands\\n', '  input      [XLEN-1:0] opA_i,\\n', '                        opB_i,\\n', '\\n', '  //From State\\n', '  input      [     1:0] st_xlen_i,\\n', '\\n', '  //To WB\\n', '  output reg            div_bubble_o,\\n', '  output reg [XLEN-1:0] div_r_o\\n', ');\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // functions\\n', '  //\\n', '  function [XLEN-1:0] sext32;\\n', '    input [31:0] operand;\\n', '    logic sign;\\n', '\\n', '    sign   = operand[31];\\n', '    sext32 = { {XLEN-32{sign}}, operand};\\n', '  endfunction\\n', '\\n', '\\n', '  function [XLEN-1:0] twos;\\n', '    input [XLEN-1:0] a;\\n', '\\n', \"    twos = ~a +'h1;\\n\", '  endfunction\\n', '\\n', '\\n', '  function [XLEN-1:0] abs;\\n', '    input [XLEN-1:0] a;\\n', '\\n', '    abs = a[XLEN-1] ? twos(a) : a;\\n', '  endfunction\\n', '\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  logic                    xlen32;\\n', '  instr_t                  div_instr;\\n', '\\n', '  opcR_t                   opcR, opcR_div;\\n', '\\n', '  //Operand generation\\n', '  logic [            31:0] opA_i32,\\n', '                           opB_i32;\\n', '\\n', '  logic [$clog2(XLEN)-1:0] cnt;\\n', '  logic                    neg_q, //negate quotient\\n', '                           neg_s; //negate remainder\\n', '\\n', '  //divider internals\\n', '  typedef struct packed {\\n', '    logic [XLEN-1:0] p, a;\\n', '  } pa_struct;\\n', '\\n', '  pa_struct                pa,\\n', '                           pa_shifted;\\n', '  logic [XLEN          :0] p_minus_b;\\n', '  logic [XLEN        -1:0] b;\\n', '\\n', '\\n', '  //FSM\\n', \"  enum logic [1:0] {ST_CHK=2'b00, ST_DIV=2'b01,ST_RES=2'b10} state;\\n\", '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  /*\\n', '   * Instruction\\n', '   */\\n', '  assign opcR     = decode_opcR(id_insn_i.instr);\\n', '  assign opcR_div = decode_opcR(div_instr);\\n', '\\n', '  assign xlen32  = st_xlen_i == RV32I;\\n', '\\n', '\\n', '  //retain instruction\\n', '  always @(posedge clk_i)\\n', '    if (!ex_stall_i) div_instr <= id_insn_i.instr;\\n', '\\n', '\\n', '  /*\\n', '   * 32bit operands\\n', '   */\\n', '  assign opA_i32   = opA_i[31:0];\\n', '  assign opB_i32   = opB_i[31:0];\\n', '\\n', '\\n', '  /*\\n', '   *  Divide operations\\n', '   *\\n', '   */\\n', '  assign pa_shifted = pa << 1;\\n', '  assign p_minus_b  = pa_shifted.p - b;\\n', '\\n', '\\n', '  //Division: bit-serial. Max XLEN cycles\\n', '  // q = z/d + s\\n', '  // z: Dividend\\n', '  // d: Divisor\\n', '  // q: Quotient\\n', '  // s: Remainder\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', '    if (!rst_ni)\\n', '    begin\\n', \"        cnt          <= {$bits(cnt){1'bx}};\\n\", '        state        <= ST_CHK;\\n', \"        div_bubble_o <= 1'b1;\\n\", \"        div_stall_o  <= 1'b0;\\n\", '\\n', \"        div_r_o      <= {$bits(div_r_o){1'bx}};\\n\", '\\n', \"        pa           <= {$bits(pa){1'bx}};\\n\", \"        b            <= {$bits(b){1'bx}};\\n\", \"        neg_q        <= 1'bx;\\n\", \"        neg_s        <= 1'bx;\\n\", '    end\\n', '    else\\n', '    begin\\n', \"        div_bubble_o <= 1'b1;\\n\", '\\n', '        case (state)\\n', '\\n', '          /*\\n', '           * Check for exceptions (divide by zero, signed overflow)\\n', '           * Setup dividor registers\\n', '           */\\n', '          ST_CHK: if (!ex_stall_i && !id_insn_i.bubble)\\n', '                    unique casex ( {xlen32,opcR} )\\n', \"                       {1'b?,DIV  } :\\n\", '                                if (~|opB_i)\\n', '                                begin //signed divide by zero\\n', \"                                    div_r_o      <= {XLEN{1'b1}}; //=-1\\n\", \"                                    div_bubble_o <= 1'b0;\\n\", '                                end\\n', '                                else\\n', \"                                if (opA_i == {1'b1,{XLEN-1{1'b0}}} && &opB_i) // signed overflow (Dividend=-2^(XLEN-1), Divisor=-1)\\n\", '                                begin\\n', \"                                    div_r_o      <= {1'b1,{XLEN-1{1'b0}}};\\n\", \"                                    div_bubble_o <= 1'b0;\\n\", '                                end\\n', '                                else\\n', '                                begin\\n', \"                                    cnt         <= {$bits(cnt){1'b1}};\\n\", '                                    state       <= ST_DIV;\\n', \"                                    div_stall_o <= 1'b1;\\n\", '\\n', '                                    neg_q       <= opA_i[XLEN-1] ^ opB_i[XLEN-1];\\n', '                                    neg_s       <= opA_i[XLEN-1];\\n', '\\n', \"                                    pa.p        <= 'h0;\\n\", '                                    pa.a        <= abs(opA_i);\\n', '                                    b           <= abs(opB_i);\\n', '                                 end\\n', '\\n', \"                       {1'b0,DIVW } :\\n\", '                                if (~|opB_i32)\\n', '                                begin //signed divide by zero\\n', \"                                    div_r_o      <= {XLEN{1'b1}}; //=-1\\n\", \"                                    div_bubble_o <= 1'b0;\\n\", '                                end\\n', '                                else\\n', \"                                if (opA_i32 == {1'b1,{31{1'b0}}} && &opB_i32) // signed overflow (Dividend=-2^(XLEN-1), Divisor=-1)\\n\", '                                begin\\n', \"                                    div_r_o      <= sext32( {1'b1,{31{1'b0}}} );\\n\", \"                                    div_bubble_o <= 1'b0;\\n\", '                                end\\n', '                                else\\n', '                                begin\\n', \"                                    cnt         <= {1'b0, {$bits(cnt)-1{1'b1}} };\\n\", '                                    state       <= ST_DIV;\\n', \"                                    div_stall_o <= 1'b1;\\n\", '\\n', '                                    neg_q       <= opA_i32[31] ^ opB_i32[31];\\n', '                                    neg_s       <= opA_i32[31];\\n', '\\n', \"                                    pa.p        <= 'h0;\\n\", \"                                    pa.a        <= { abs( sext32(opA_i32) ), {XLEN-32{1'b0}}      };\\n\", '                                    b           <= abs( sext32(opB_i32) );\\n', '                                end\\n', '\\n', \"                       {1'b?,DIVU } :\\n\", '                                if (~|opB_i)\\n', '                                begin //unsigned divide by zero\\n', \"                                    div_r_o      <= {XLEN{1'b1}}; //= 2^XLEN -1\\n\", \"                                    div_bubble_o <= 1'b0;\\n\", '                                end\\n', '                                else\\n', '                                begin\\n', \"                                    cnt         <= {$bits(cnt){1'b1}};\\n\", '                                    state       <= ST_DIV;\\n', \"                                    div_stall_o <= 1'b1;\\n\", '\\n', \"                                    neg_q       <= 1'b0;\\n\", \"                                    neg_s       <= 1'b0;\\n\", '\\n', \"                                    pa.p        <= 'h0;\\n\", '                                    pa.a        <= opA_i;\\n', '                                    b           <= opB_i;\\n', '                                end\\n', '\\n', \"                       {1'b0,DIVUW} :\\n\", '                                if (~|opB_i32)\\n', '                                begin //unsigned divide by zero\\n', \"                                    div_r_o      <= {XLEN{1'b1}}; //= 2^XLEN -1\\n\", \"                                    div_bubble_o <= 1'b0;\\n\", '                                end\\n', '                                else\\n', '                                begin\\n', \"                                    cnt         <= {1'b0, {$bits(cnt)-1{1'b1}} };\\n\", '                                    state       <= ST_DIV;\\n', \"                                    div_stall_o <= 1'b1;\\n\", '\\n', \"                                    neg_q       <= 1'b0;\\n\", \"                                    neg_s       <= 1'b0;\\n\", '\\n', \"                                    pa.p        <= 'h0;\\n\", \"                                    pa.a        <= { opA_i32, {XLEN-32{1'b0}} };\\n\", \"                                    b           <= { {XLEN-32{1'b0}}, opB_i32 };\\n\", '                                end\\n', '\\n', \"                       {1'b?,REM  } :\\n\", '                                if (~|opB_i)\\n', '                                begin //signed divide by zero\\n', '                                    div_r_o      <= opA_i;\\n', \"                                    div_bubble_o <= 1'b0;\\n\", '                                end\\n', '                                else\\n', \"                                if (opA_i == {1'b1,{XLEN-1{1'b0}}} && &opB_i) // signed overflow (Dividend=-2^(XLEN-1), Divisor=-1)\\n\", '                                begin\\n', \"                                    div_r_o      <=  'h0;\\n\", \"                                    div_bubble_o <= 1'b0;\\n\", '                                end\\n', '                                else\\n', '                                begin\\n', \"                                    cnt         <= {$bits(cnt){1'b1}};\\n\", '                                    state       <= ST_DIV;\\n', \"                                    div_stall_o <= 1'b1;\\n\", '\\n', '                                    neg_q       <= opA_i[XLEN-1] ^ opB_i[XLEN-1];\\n', '                                    neg_s       <= opA_i[XLEN-1];\\n', '\\n', \"                                    pa.p        <= 'h0;\\n\", '                                    pa.a        <= abs(opA_i);\\n', '                                    b           <= abs(opB_i);\\n', '                                end\\n', '\\n', \"                       {1'b0,REMW } :\\n\", '                                if (~|opB_i32)\\n', '                                begin //signed divide by zero\\n', '                                    div_r_o      <= sext32(opA_i32);\\n', \"                                    div_bubble_o <= 1'b0;\\n\", '                                end\\n', '                                else\\n', \"                                if (opA_i32 == {1'b1,{31{1'b0}}} && &opB_i32) // signed overflow (Dividend=-2^(XLEN-1), Divisor=-1)\\n\", '                                begin\\n', \"                                    div_r_o      <=  'h0;\\n\", \"                                    div_bubble_o <= 1'b0;\\n\", '                                end\\n', '                                else\\n', '                                begin\\n', \"                                    cnt         <= {1'b0, {$bits(cnt)-1{1'b1}} };\\n\", '                                    state       <= ST_DIV;\\n', \"                                    div_stall_o <= 1'b1;\\n\", '\\n', '                                    neg_q       <= opA_i32[31] ^ opB_i32[31];\\n', '                                    neg_s       <= opA_i32[31];\\n', '\\n', \"                                    pa.p        <= 'h0;\\n\", \"                                    pa.a        <= { abs( sext32(opA_i32) ), {XLEN-32{1'b0}}      };\\n\", '                                    b           <= abs( sext32(opB_i32) );\\n', '                                end\\n', '\\n', \"                       {1'b?,REMU } :\\n\", '                                if (~|opB_i)\\n', '                                begin //unsigned divide by zero\\n', '                                    div_r_o      <= opA_i;\\n', \"                                    div_bubble_o <= 1'b0;\\n\", '                                end\\n', '                                else\\n', '                                begin\\n', \"                                    cnt         <= {$bits(cnt){1'b1}};\\n\", '                                    state       <= ST_DIV;\\n', \"                                    div_stall_o <= 1'b1;\\n\", '\\n', \"                                    neg_q       <= 1'b0;\\n\", \"                                    neg_s       <= 1'b0;\\n\", '\\n', \"                                    pa.p        <= 'h0;\\n\", '                                    pa.a        <= opA_i;\\n', '                                    b           <= opB_i;\\n', '                                end\\n', '\\n', \"                       {1'b0,REMUW} :\\n\", '                                if (~|opB_i32)\\n', '                                begin\\n', '                                    div_r_o      <= sext32(opA_i32);\\n', \"                                    div_bubble_o <= 1'b0;\\n\", '                                end\\n', '                                else\\n', '                                begin\\n', \"                                    cnt         <= {1'b0, {$bits(cnt)-1{1'b1}} };\\n\", '                                    state       <= ST_DIV;\\n', \"                                    div_stall_o <= 1'b1;\\n\", '\\n', \"                                    neg_q       <= 1'b0;\\n\", \"                                    neg_s       <= 1'b0;\\n\", '\\n', \"                                    pa.p        <= 'h0;\\n\", \"                                    pa.a        <= { opA_i32, {XLEN-32{1'b0}} };\\n\", \"                                    b           <= { {XLEN-32{1'b0}}, opB_i32 };\\n\", '                                end\\n', '                       default: ;\\n', '                    endcase\\n', '\\n', '\\n', '          /*\\n', '           * actual division loop\\n', '           */\\n', '          ST_DIV: begin\\n', '                      cnt <= cnt -1;\\n', '                      if (~| cnt) state <= ST_RES;\\n', '\\n', '                      //restoring divider section\\n', '                      if (p_minus_b[XLEN])\\n', '                      begin //sub gave negative result\\n', '                          pa.p <=  pa_shifted.p;                   //restore\\n', \"                          pa.a <= {pa_shifted.a[XLEN-1:1], 1'b0};  //shift in '0' for Q\\n\", '                      end\\n', '                      else\\n', '                      begin //sub gave positive result\\n', '                          pa.p <=  p_minus_b[XLEN-1:0];            //store sub result\\n', \"                          pa.a <= {pa_shifted.a[XLEN-1:1], 1'b1};  //shift in '1' for Q\\n\", '                      end\\n', '                  end\\n', '\\n', '          /*\\n', '           * Result\\n', '           */\\n', '          ST_RES: if (!mem_stall_i)\\n', '\\t          begin\\n', '                      state        <= ST_CHK;\\n', \"                      div_bubble_o <= 1'b0;\\n\", \"                      div_stall_o  <= 1'b0;\\n\", '\\n', '                      unique casex ( opcR_div )\\n', '                         DIV    : div_r_o <=         neg_q ? twos(pa.a) : pa.a; \\n', '                         DIVW   : div_r_o <= sext32( neg_q ? twos(pa.a) : pa.a );\\n', '                         DIVU   : div_r_o <=                              pa.a;\\n', '                         DIVUW  : div_r_o <= sext32(                      pa.a );\\n', '                         REM    : div_r_o <=         neg_s ? twos(pa.p) : pa.p;\\n', '                         REMW   : div_r_o <= sext32( neg_s ? twos(pa.p) : pa.p );\\n', '                         REMU   : div_r_o <=                              pa.p;\\n', '                         REMUW  : div_r_o <= sext32(                      pa.p );\\n', \"                         default: div_r_o <= 'hx;\\n\", '                      endcase\\n', '                  end\\n', '        endcase\\n', '    end\\n', '\\n', 'endmodule \\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Load Store Unit                                              //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_lsu\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter XLEN           = 32,\\n', '  parameter HAS_A          = 0\\n', ')\\n', '(\\n', '  input                           rst_ni,\\n', '  input                           clk_i,\\n', '\\n', '  input                           ex_stall_i,\\n', '  output reg                      lsu_stall_o,\\n', '\\n', '\\n', '  //Instruction\\n', '  input  instruction_t            id_insn_i,\\n', '\\n', '  output reg                      lsu_bubble_o,\\n', '  output     [XLEN          -1:0] lsu_r_o,\\n', '\\n', '  input  interrupts_exceptions_t  id_exceptions_i,\\n', '                                  ex_exceptions_i,\\n', '                                  mem_exceptions_i,\\n', '                                  wb_exceptions_i,\\n', '\\t\\t\\t\\t  \\n', '  output interrupts_exceptions_t  lsu_exceptions_o,\\n', '\\n', '\\n', '  //Operands\\n', '  input      [XLEN          -1:0] opA_i,\\n', '                                  opB_i,\\n', '\\n', '  //From State\\n', '  input      [               1:0] st_xlen_i,\\n', '\\n', '  //To Memory\\n', '  output reg                      dmem_req_o,\\n', '                                  dmem_lock_o,\\n', '                                  dmem_we_o,\\n', '  output biu_size_t               dmem_size_o,\\n', '  output reg [XLEN          -1:0] dmem_adr_o,\\n', '                                  dmem_d_o,\\n', '\\n', '\\n', '  //From Memory (for AMO)\\n', '  input                           dmem_ack_i,\\n', '  input      [XLEN          -1:0] dmem_q_i,\\n', '  input                           dmem_misaligned_i,\\n', '                                  dmem_page_fault_i\\n', ');\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  opcR_t             opcR;\\n', '  logic              xlen32;\\n', '\\n', '  //Operand generation\\n', '  immS_t             immS;\\n', '  logic [XLEN  -1:0] ext_immS;\\n', '\\n', '\\n', '  //FSM\\n', \"  enum logic [1:0] {IDLE=2'b00} state;\\n\", '\\n', '  logic [XLEN  -1:0] adr,\\n', '                     d;\\n', '  biu_size_t         size;\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  /*\\n', '   * Instruction\\n', '   */\\n', '  assign opcR   = decode_opcR(id_insn_i.instr);\\n', '  assign xlen32 = (st_xlen_i == RV32I);\\n', '\\n', \"  assign lsu_r_o  = 'h0; //for AMO\\n\", '\\n', '\\n', '  /*\\n', '   * Decode Immediates\\n', '   */\\n', '  assign immS     = decode_immS(id_insn_i.instr);\\n', '  assign ext_immS = { {XLEN-$bits(immS){immS[$left(immS,1)]}}, immS};\\n', '\\n', '\\n', '  //Access Statemachine\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if (!rst_ni)\\n', '    begin\\n', '        state        <= IDLE;\\n', \"        lsu_stall_o  <= 1'b0;\\n\", \"        lsu_bubble_o <= 1'b1;\\n\", \"        dmem_req_o   <= 1'b0;\\n\", \"        dmem_lock_o  <= 1'b0;\\n\", '    end\\n', '    else\\n', '    begin\\n', \"        dmem_req_o   <= 1'b0;\\n\", '\\n', '        unique case (state)\\n', '            IDLE : if (!ex_stall_i)\\n', '                   begin\\n', '                       if (!id_insn_i.bubble && ~(id_exceptions_i.any || ex_exceptions_i.any || mem_exceptions_i.any || wb_exceptions_i.any))\\n', '                       begin\\n', '                           unique case (opcR.opcode)\\n', '                              OPC_LOAD : begin\\n', \"                                             dmem_req_o   <= 1'b1;\\n\", \"                                             dmem_lock_o  <= 1'b0;\\n\", \"                                             lsu_stall_o  <= 1'b0;\\n\", \"                                             lsu_bubble_o <= 1'b0;\\n\", '                                             state        <= IDLE;\\n', '                                         end\\n', '                              OPC_STORE: begin\\n', \"                                             dmem_req_o   <= 1'b1;\\n\", \"                                             dmem_lock_o  <= 1'b0;\\n\", \"                                             lsu_stall_o  <= 1'b0;\\n\", \"                                             lsu_bubble_o <= 1'b0;\\n\", '                                             state        <= IDLE;\\n', '                                         end\\n', '                              default  : begin\\n', \"                                             dmem_req_o   <= 1'b0;\\n\", \"                                             dmem_lock_o  <= 1'b0;\\n\", \"                                             lsu_stall_o  <= 1'b0;\\n\", \"                                             lsu_bubble_o <= 1'b1;\\n\", '                                             state        <= IDLE;\\n', '                                         end\\n', '                           endcase\\n', '                       end\\n', '                       else\\n', '                       begin\\n', \"                           dmem_req_o   <= 1'b0;\\n\", \"                           dmem_lock_o  <= 1'b0;\\n\", \"                           lsu_stall_o  <= 1'b0;\\n\", \"                           lsu_bubble_o <= 1'b1;\\n\", '                           state        <= IDLE;\\n', '                       end\\n', '                   end\\n', '\\n', '          default: begin\\n', \"                       dmem_req_o   <= 1'b0;\\n\", \"                       dmem_lock_o  <= 1'b0;\\n\", \"                       lsu_stall_o  <= 1'b0;\\n\", \"                       lsu_bubble_o <= 1'b1;\\n\", '                       state        <= IDLE;\\n', '                   end\\n', '        endcase\\n', '    end\\n', '\\n', '\\n', '  //Memory Control Signals\\n', '  always @(posedge clk_i)\\n', '    unique case (state)\\n', '      IDLE   : if (!id_insn_i.bubble)\\n', '                 unique case (opcR.opcode)\\n', '                   OPC_LOAD : begin\\n', \"                                  dmem_we_o   <= 1'b0;\\n\", '                                  dmem_size_o <= size;\\n', '                                  dmem_adr_o  <= adr;\\n', \"                                  dmem_d_o    <=  'hx;\\n\", '                              end\\n', '                   OPC_STORE: begin\\n', \"                                  dmem_we_o   <= 1'b1;\\n\", '                                  dmem_size_o <= size;\\n', '                                  dmem_adr_o  <= adr;\\n', '                                  dmem_d_o    <= d;\\n', '                              end\\n', '                   default  : ; //do nothing\\n', '                 endcase\\n', '\\n', '      default: begin\\n', \"                    dmem_we_o   <= 1'bx;\\n\", '                    dmem_size_o <= UNDEF_SIZE;\\n', \"                    dmem_adr_o  <=  'hx;\\n\", \"                    dmem_d_o    <=  'hx;\\n\", '                end\\n', '    endcase\\n', '\\n', '\\n', '\\n', '  //memory address\\n', '  always_comb\\n', '    casex ( {xlen32,opcR} )\\n', \"       {1'b?,LB    }: adr = opA_i + opB_i;\\n\", \"       {1'b?,LH    }: adr = opA_i + opB_i;\\n\", \"       {1'b?,LW    }: adr = opA_i + opB_i;\\n\", \"       {1'b0,LD    }: adr = opA_i + opB_i;              //RV64\\n\", \"       {1'b?,LBU   }: adr = opA_i + opB_i;\\n\", \"       {1'b?,LHU   }: adr = opA_i + opB_i;\\n\", \"       {1'b0,LWU   }: adr = opA_i + opB_i;              //RV64\\n\", \"       {1'b?,SB    }: adr = opA_i + ext_immS;\\n\", \"       {1'b?,SH    }: adr = opA_i + ext_immS;\\n\", \"       {1'b?,SW    }: adr = opA_i + ext_immS;\\n\", \"       {1'b0,SD    }: adr = opA_i + ext_immS;           //RV64\\n\", \"       default      : adr = opA_i + opB_i;              //'hx;\\n\", '    endcase\\n', '\\n', '\\n', 'generate\\n', '  //memory byte enable\\n', '  if (XLEN==64) //RV64\\n', '  begin\\n', '    always_comb\\n', '      casex ( opcR )\\n', '        LB     : size = BYTE;\\n', '        LH     : size = HWORD;\\n', '        LW     : size = WORD;\\n', '        LD     : size = DWORD;\\n', '        LBU    : size = BYTE;\\n', '        LHU    : size = HWORD;\\n', '        LWU    : size = WORD;\\n', '        SB     : size = BYTE;\\n', '        SH     : size = HWORD;\\n', '        SW     : size = WORD;\\n', '        SD     : size = DWORD;\\n', '        default: size = UNDEF_SIZE;\\n', '      endcase\\n', '\\n', '\\n', '    //memory write data\\n', '    always_comb\\n', '      casex ( opcR )\\n', '        SB     : d = opB_i[ 7:0] << (8* adr[2:0]);\\n', '        SH     : d = opB_i[15:0] << (8* adr[2:0]);\\n', '        SW     : d = opB_i[31:0] << (8* adr[2:0]);\\n', '        SD     : d = opB_i;\\n', \"        default: d = 'hx;\\n\", '      endcase\\n', '  end\\n', '  else //RV32\\n', '  begin\\n', '    always_comb\\n', '      casex ( opcR )\\n', '        LB     : size = BYTE;\\n', '        LH     : size = HWORD;\\n', '        LW     : size = WORD;\\n', '        LBU    : size = BYTE;\\n', '        LHU    : size = HWORD;\\n', '        SB     : size = BYTE;\\n', '        SH     : size = HWORD;\\n', '        SW     : size = WORD;\\n', '        default: size = UNDEF_SIZE;\\n', '      endcase\\n', '\\n', '\\n', '    //memory write data\\n', '    always_comb\\n', '      casex ( opcR )\\n', '        SB     : d = opB_i[ 7:0] << (8* adr[1:0]);\\n', '        SH     : d = opB_i[15:0] << (8* adr[1:0]);\\n', '        SW     : d = opB_i;\\n', \"        default: d = 'hx;\\n\", '      endcase\\n', '  end\\n', 'endgenerate\\n', '\\n', '\\n', '  /*\\n', '   * Exceptions\\n', '   * Regular memory exceptions are caught in the WB stage\\n', \"   * However AMO accesses handle the 'load' here.\\n\", '   */\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni     ) lsu_exceptions_o <= 'h0;\\n\", '    else if (!lsu_stall_o)\\n', '    begin\\n', '        lsu_exceptions_o <= id_exceptions_i;\\n', '    end\\n', '\\n', '\\n', '  /*\\n', '   * Assertions\\n', '   */\\n', '\\n', '  //assert that address is known when memory is accessed\\n', '//  assert property ( @(posedge clk_i)(dmem_req_o) |-> (!isunknown(dmem_adr_o)) );\\n', '\\n', 'endmodule : riscv_lsu\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Multiplier Unit                                              //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2017-2018 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_mul\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', '#(\\n', '  parameter XLEN         = 32,\\n', '  parameter MULT_LATENCY = 0\\n', ')\\n', '(\\n', '  input                 rst_ni,\\n', '  input                 clk_i,\\n', '\\n', '  input                 mem_stall_i,\\n', '  input                 ex_stall_i,\\n', '  output reg            mul_stall_o,\\n', '\\n', '  //Instruction\\n', '  input instruction_t   id_insn_i,\\n', '\\n', '  //Operands\\n', '  input      [XLEN-1:0] opA_i,\\n', '                        opB_i,\\n', '\\n', '  //from State\\n', '  input      [     1:0] st_xlen_i,\\n', '\\n', '  //to WB\\n', '  output reg            mul_bubble_o,\\n', '  output reg [XLEN-1:0] mul_r_o\\n', ');\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Constants\\n', '  //\\n', '  localparam DXLEN       = 2*XLEN;\\n', '\\n', '  localparam MAX_LATENCY = 3;\\n', '  localparam LATENCY     = MULT_LATENCY > MAX_LATENCY ? MAX_LATENCY : MULT_LATENCY;\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Checks (assertions)\\n', '  //\\n', '  initial\\n', '  begin\\n', '      a1: assert (MULT_LATENCY <= MAX_LATENCY)\\n', '          else $warning(\"MULT_LATENCY=%0d larger than allowed. Changed to %0d\", MULT_LATENCY, MAX_LATENCY);\\n', '  end\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // functions\\n', '  //\\n', '  function [XLEN-1:0] sext32;\\n', '    input [31:0] operand;\\n', '    logic sign;\\n', '\\n', '    sign   = operand[31];\\n', '    sext32 = { {XLEN-32{sign}}, operand};\\n', '  endfunction\\n', '\\n', '\\n', '  function [XLEN-1:0] twos;\\n', '    input [XLEN-1:0] a;\\n', '\\n', \"    twos = ~a +'h1;\\n\", '  endfunction\\n', '\\n', '  function [DXLEN-1:0] twos_dxlen;\\n', '    input [DXLEN-1:0] a;\\n', '\\n', \"    twos_dxlen = ~a +'h1;\\n\", '  endfunction\\n', '\\n', '\\n', '  function [XLEN-1:0] abs;\\n', '    input [XLEN-1:0] a;\\n', '\\n', '    abs = a[XLEN-1] ? twos(a) : a;\\n', '  endfunction\\n', '\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  logic              xlen32;\\n', '  instr_t            mul_instr;\\n', '\\n', '  opcR_t             opcR, opcR_mul;\\n', '  \\n', '  //Operand generation\\n', '  logic [      31:0] opA32,\\n', '                     opB32;\\n', '\\n', '\\n', '  logic              mult_neg,      mult_neg_reg;\\n', '  logic [XLEN  -1:0] mult_opA,      mult_opA_reg,\\n', '                     mult_opB,      mult_opB_reg;\\n', '  logic [DXLEN -1:0] mult_r,        mult_r_reg,\\n', '                     mult_r_signed, mult_r_signed_reg;\\n', '\\n', '  //FSM (bubble, stall generation)\\n', '  logic       is_mul;\\n', '  logic [1:0] cnt;\\n', \"  enum logic {ST_IDLE=1'b0, ST_WAIT=1'b1} state;\\n\", '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  /*\\n', '   * Instruction\\n', '   */\\n', '  assign opcR     = decode_opcR(id_insn_i.instr);\\n', '  assign opcR_mul = decode_opcR(mul_instr);\\n', '\\n', '  assign xlen32  = st_xlen_i == RV32I;\\n', '\\n', '\\n', '  /*\\n', '   * 32bit operands\\n', '   */\\n', '  assign opA32 = opA_i[31:0];\\n', '  assign opB32 = opB_i[31:0];\\n', '\\n', '\\n', '  /*\\n', '   *  Multiply operations\\n', '   *\\n', '   * Transform all multiplications into 1 unsigned multiplication\\n', '   * This avoids building multiple multipliers (signed x signed, signed x unsigned, unsigned x unsigned)\\n', '   *   at the expense of potentially making the path slower\\n', '   */\\n', '\\n', '  //multiplier operand-A\\n', '  always_comb \\n', '    unique casex ( opcR )\\n', '      MULW   : mult_opA = abs( sext32(opA32) ); //RV64\\n', '      MULHU  : mult_opA =             opA_i   ;\\n', '      default: mult_opA = abs(        opA_i  );\\n', '    endcase\\n', '\\n', '  //multiplier operand-B\\n', '  always_comb \\n', '    unique casex ( opcR )\\n', '      MULW   : mult_opB = abs( sext32(opB32) ); //RV64\\n', '      MULHSU : mult_opB =             opB_i   ;\\n', '      MULHU  : mult_opB =             opB_i   ;\\n', '      default: mult_opB = abs(        opB_i  );\\n', '    endcase\\n', '\\n', '  //negate multiplier output?\\n', '  always_comb \\n', '    unique casex ( opcR )\\n', '      MUL    : mult_neg = opA_i[XLEN-1] ^ opB_i[XLEN-1];\\n', '      MULH   : mult_neg = opA_i[XLEN-1] ^ opB_i[XLEN-1];\\n', '      MULHSU : mult_neg = opA_i[XLEN-1];\\n', \"      MULHU  : mult_neg = 1'b0;\\n\", '      MULW   : mult_neg = opA32[31] ^ opB32[31];  //RV64\\n', \"      default: mult_neg = 'hx;\\n\", '    endcase\\n', '\\n', '\\n', '  //Actual multiplier\\n', '  assign mult_r        = $unsigned(mult_opA_reg) * $unsigned(mult_opB_reg);\\n', '\\n', '  //Correct sign\\n', '  assign mult_r_signed = mult_neg_reg ? twos_dxlen(mult_r_reg) : mult_r_reg;\\n', '\\n', '\\n', '  /*\\n', '   *\\n', '   */\\n', 'generate\\n', '  if (LATENCY == 0)\\n', '  begin\\n', '      /*\\n', '       * Single cycle multiplier\\n', '       *\\n', '       * Registers at: - output\\n', '       */\\n', '      //Register holding instruction for multiplier-output-selector\\n', '      assign mul_instr = id_insn_i.instr;\\n', '\\n', '      //Registers holding multiplier operands\\n', '      assign mult_opA_reg = mult_opA;\\n', '      assign mult_opB_reg = mult_opB;\\n', '      assign mult_neg_reg = mult_neg;\\n', '\\n', '      //Register holding multiplier output\\n', '      assign mult_r_reg = mult_r;\\n', '\\n', '      //Register holding sign correction\\n', '      assign mult_r_signed_reg = mult_r_signed;\\n', '  end\\n', '  else\\n', '  begin\\n', '      /*\\n', '       * Multi cycle multiplier\\n', '       *\\n', '       * Registers at: - input\\n', '       *               - output\\n', '       */\\n', '      //Register holding instruction for multiplier-output-selector\\n', '      always @(posedge clk_i)\\n', '        if (!ex_stall_i) mul_instr <= id_insn_i.instr;\\n', '\\n', '      //Registers holding multiplier operands\\n', '      always @(posedge clk_i)\\n', '        if (!ex_stall_i)\\n', '        begin\\n', '            mult_opA_reg <= mult_opA;\\n', '            mult_opB_reg <= mult_opB;\\n', '            mult_neg_reg <= mult_neg;\\n', '        end\\n', '\\n', '      if (LATENCY == 1)\\n', '      begin\\n', '          //Register holding multiplier output\\n', '          assign mult_r_reg = mult_r;\\n', '\\n', '          //Register holding sign correction\\n', '          assign mult_r_signed_reg = mult_r_signed;\\n', '      end\\n', '      else if (LATENCY == 2)\\n', '      begin\\n', '          //Register holding multiplier output\\n', '          always @(posedge clk_i)\\n', '            mult_r_reg <= mult_r;\\n', '\\n', '          //Register holding sign correction\\n', '          assign mult_r_signed_reg = mult_r_signed;\\n', '      end\\n', '      else\\n', '      begin\\n', '          //Register holding multiplier output\\n', '          always @(posedge clk_i)\\n', '            mult_r_reg <= mult_r;\\n', '\\n', '          //Register holding sign correction\\n', '          always @(posedge clk_i)\\n', '            mult_r_signed_reg <= mult_r_signed;\\n', '      end\\n', '  end\\n', 'endgenerate\\n', '\\n', '\\n', '\\n', '  /*\\n', '   * Final output register\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    unique casex ( opcR_mul )\\n', '      MUL    : mul_r_o <= mult_r_signed_reg[XLEN -1:   0];\\n', '      MULW   : mul_r_o <= sext32( mult_r_signed_reg[31:0] );  //RV64\\n', '      default: mul_r_o <= mult_r_signed_reg[DXLEN-1:XLEN];\\n', '    endcase\\n', '\\n', '\\n', '  /*\\n', '   * Stall / Bubble generation\\n', '   */\\n', '  always_comb\\n', '    unique casex ( opcR )\\n', \"      MUL    : is_mul = 1'b1;\\n\", \"      MULH   : is_mul = 1'b1;\\n\", '      MULW   : is_mul = ~xlen32;\\n', \"      MULHSU : is_mul = 1'b1;\\n\", \"      MULHU  : is_mul = 1'b1;\\n\", \"      default: is_mul = 1'b0;\\n\", '    endcase\\n', '\\n', '\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', '    if (!rst_ni)\\n', '    begin\\n', '        state        <= ST_IDLE;\\n', '        cnt          <= LATENCY;\\n', '\\n', \"        mul_bubble_o <= 1'b1;\\n\", \"        mul_stall_o  <= 1'b0;\\n\", '    end\\n', '    else\\n', '    begin\\n', \"        mul_bubble_o <= 1'b1;\\n\", '\\n', '        unique case (state)\\n', '          ST_IDLE: if (!ex_stall_i)\\n', '                     if (!id_insn_i.bubble && is_mul)\\n', '                     begin\\n', '                         if (LATENCY == 0)\\n', '                         begin\\n', \"                             mul_bubble_o <= 1'b0;\\n\", \"                             mul_stall_o  <= 1'b0;\\n\", '                         end\\n', '                         else\\n', '                         begin\\n', '                             state        <= ST_WAIT;\\n', '                             cnt          <= LATENCY -1;\\n', '\\n', \"                             mul_bubble_o <= 1'b1;\\n\", \"                             mul_stall_o  <= 1'b1;\\n\", '                          end\\n', '                       end\\n', '\\n', '          ST_WAIT: if (|cnt)\\n', '                     cnt <= cnt -1;\\n', '                   else if (!mem_stall_i)\\n', '                   begin\\n', '                       state        <= ST_IDLE;\\n', '                       cnt          <= LATENCY;\\n', '\\n', \"                       mul_bubble_o <= 1'b0;\\n\", \"                       mul_stall_o  <= 1'b0;\\n\", '                   end\\n', '        endcase\\n', '    end\\n', '\\n', 'endmodule \\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Data Memory Access Block                                     //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_dmem_ctrl\\n', 'import riscv_state_pkg::*;\\n', 'import riscv_pma_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter XLEN              = 32,\\n', '  parameter PLEN              = XLEN==32 ? 34 : 56,\\n', '\\n', '  parameter HAS_RVC           = 0,\\n', '  parameter HAS_MMU           = 0,\\n', '\\n', '  parameter PMA_CNT           = 3,\\n', '  parameter PMP_CNT           = 16,\\n', '\\n', '  parameter CACHE_SIZE        = 64, //KBYTES\\n', '  parameter CACHE_BLOCK_SIZE  = 32, //BYTES\\n', '  parameter CACHE_WAYS        =  2, // 1           : Direct Mapped\\n', '                                    //<n>          : n-way set associative\\n', '                                    //<n>==<blocks>: fully associative\\n', '\\n', '/*\\n', '  parameter REPLACE_ALG      = 1,  //0: Random\\n', '                                   //1: FIFO\\n', '                                   //2: LRU\\n', '*/\\n', '  parameter TECHNOLOGY       = \"GENERIC\",\\n', '  parameter BIUTAG_SIZE      = 2\\n', ')\\n', '(\\n', '  input  logic                             rst_ni,\\n', '  input  logic                             clk_i,\\n', ' \\n', '  //Configuration\\n', '  input  pmacfg_t                          pma_cfg_i [PMA_CNT],\\n', '  input                 [XLEN        -1:0] pma_adr_i [PMA_CNT],\\n', '\\n', '  input  pmpcfg_t [15:0]                   st_pmpcfg_i,\\n', '  input  logic    [15:0][XLEN        -1:0] st_pmpaddr_i,\\n', '  input  logic          [             1:0] st_prv_i,\\n', '\\n', '  //CPU side\\n', '  input  logic                             mem_req_i,\\n', '  input  biu_size_t                        mem_size_i,\\n', '  input  logic                             mem_lock_i, \\n', '  input  logic          [XLEN        -1:0] mem_adr_i,\\n', '  input  logic                             mem_we_i,\\n', '  input  logic          [XLEN        -1:0] mem_d_i,\\n', '  output logic          [XLEN        -1:0] mem_q_o,\\n', '  output logic                             mem_ack_o,\\n', '  output logic                             mem_err_o,\\n', '                                           mem_misaligned_o,\\n', '                                           mem_pagefault_o,\\n', '\\n', '  //Cache Block Management, per CMO spec\\n', '  //Flush = Invalidate + Clean\\n', '  input  logic                             cm_invalidate_i,\\n', '                                           cm_clean_i,\\n', '  output logic                             cm_clean_rdy_o,\\n', '\\n', '  //BIU ports\\n', '  output logic                             biu_stb_o,\\n', '  input  logic                             biu_stb_ack_i,\\n', '  input  logic                             biu_d_ack_i,\\n', '  output logic          [PLEN        -1:0] biu_adri_o,\\n', '  input  logic          [PLEN        -1:0] biu_adro_i,\\n', '  output biu_size_t                        biu_size_o,\\n', '  output biu_type_t                        biu_type_o,\\n', '  output logic                             biu_we_o,\\n', '  output logic                             biu_lock_o,\\n', '  output biu_prot_t                        biu_prot_o,\\n', '  output logic          [XLEN        -1:0] biu_d_o,\\n', '  input  logic          [XLEN        -1:0] biu_q_i,\\n', '  input  logic                             biu_ack_i,\\n', '                                           biu_err_i,\\n', '  output logic          [BIUTAG_SIZE -1:0] biu_tagi_o,\\n', '  input  logic          [BIUTAG_SIZE -1:0] biu_tago_i\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '\\n', '  //Transfer parameters\\n', '  biu_prot_t       prot;\\n', '\\n', '\\n', '  //Queue\\n', '  logic            queue_req;\\n', '  logic [XLEN-1:0] queue_adr;\\n', '  biu_size_t       queue_size;\\n', '  logic            queue_lock;\\n', '  biu_prot_t       queue_prot;\\n', '  logic            queue_we;\\n', '  logic [XLEN-1:0] queue_d;\\n', '  logic            queue_misaligned;\\n', '\\n', '  logic            queue_cm_clean;\\n', '  logic            queue_cm_invalidate;\\n', '\\n', ' \\n', '  //MMU\\n', '  logic            mmu_req;\\n', '  logic [PLEN-1:0] mmu_adr;\\n', '  biu_size_t       mmu_size;\\n', '  logic            mmu_lock;\\n', '  logic            mmu_we;\\n', '  logic            mmu_misaligned;\\n', '  logic            mmu_pagefault;\\n', '\\n', '  logic            mmu_cm_clean;\\n', '  logic            mmu_cm_invalidate;\\n', '\\n', '  //Misalignment check\\n', '  logic            mem_misaligned;\\n', '\\n', '  //from PMA check\\n', '  logic            pma_exception,\\n', '                   pma_misaligned,\\n', '                   pma_cacheable;\\n', '\\n', '\\n', '  //from PMP check\\n', '  logic            pmp_exception;\\n', '\\n', '\\n', '  //From dcache-ctrl\\n', '  logic            stall;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', \"  assign prot             = biu_prot_t'( PROT_DATA                                        |\\n\", '\\t                                (st_prv_i == PRV_U ? PROT_USER : PROT_PRIVILEGED) );\\n', '\\n', '  /* Hookup misaligned check\\n', '   */\\n', '  riscv_memmisaligned #(\\n', '    .XLEN          ( XLEN           ),\\n', '    .HAS_RVC       ( HAS_RVC        ) )\\n', '  misaligned_inst (\\n', \"    .instruction_i ( 1'b0           ), //data access\\n\", '    .adr_i         ( mem_adr_i      ), //virtual address\\n', '    .size_i        ( mem_size_i     ),\\n', '    .misaligned_o  ( mem_misaligned ) );\\n', '\\n', '\\n', '  /* Hookup buffer\\n', '   */\\n', '  riscv_membuf #(\\n', '    .DEPTH           ( 2                   ),\\n', '    .XLEN            ( XLEN                ) )\\n', '  membuffer_inst (\\n', '    .rst_ni          ( rst_ni              ),\\n', '    .clk_i           ( clk_i               ),\\n', '\\n', \"    .flush_i         ( 1'b0                ),\\n\", '    .stall_i         ( stall               ),\\n', '\\n', '    .req_i           ( mem_req_i           ),\\n', '    .adr_i           ( mem_adr_i           ),\\n', '    .size_i          ( mem_size_i          ),\\n', '    .lock_i          ( mem_lock_i          ),\\n', '    .prot_i          ( prot                ),\\n', '    .we_i            ( mem_we_i            ),\\n', '    .d_i             ( mem_d_i             ),\\n', '    .misaligned_i    ( mem_misaligned      ),\\n', '\\n', '    .cm_clean_i      ( cm_clean_i          ),\\n', '    .cm_invalidate_i ( cm_invalidate_i     ),\\n', '\\n', '    .req_o           ( queue_req           ),\\n', '    .ack_i           ( mem_ack_o        |\\n', '                       mem_err_o        |\\n', '                       mem_misaligned_o |\\n', '                       mem_pagefault_o     ),\\n', '\\n', '    .adr_o           ( queue_adr           ),\\n', '    .size_o          ( queue_size          ),\\n', '    .lock_o          ( queue_lock          ),\\n', '    .prot_o          ( queue_prot          ),\\n', '    .we_o            ( queue_we            ),\\n', '    .q_o             ( queue_d             ),\\n', '    .misaligned_o    ( queue_misaligned    ),\\n', '\\n', '    .cm_clean_o      ( queue_cm_clean      ),\\n', '    .cm_invalidate_o ( queue_cm_invalidate ),\\n', '\\n', '    .empty_o         (                     ),\\n', '    .full_o          (                     ) );\\n', '\\n', '\\n', '\\n', '  /* Hookup Cache\\n', '   */\\n', 'generate\\n', '  if (CACHE_SIZE > 0)\\n', '  begin : cache_blk\\n', '      /* Hookup MMU\\n', '       */\\n', '      if (HAS_MMU != 0)\\n', '      begin : mmu_blk\\n', '      end\\n', '      else\\n', '      begin : nommu_blk\\n', '          riscv_nommu #(\\n', '            .XLEN            ( XLEN                ),\\n', '            .PLEN            ( PLEN                ) )\\n', '          mmu_inst (\\n', '            .rst_ni          ( rst_ni              ),\\n', '            .clk_i           ( clk_i               ),\\n', '            .stall_i         ( stall               ),\\n', '\\n', \"            .flush_i         ( 1'b0                ),\\n\", '            .req_i           ( queue_req           ),\\n', '            .adr_i           ( queue_adr           ), //virtual address\\n', '            .size_i          ( queue_size          ),\\n', '            .lock_i          ( queue_lock          ),\\n', '            .we_i            ( queue_we            ),\\n', '            .misaligned_i    ( queue_misaligned    ),\\n', '\\n', '            .cm_clean_i      ( queue_cm_clean      ),\\n', '            .cm_invalidate_i ( queue_cm_invalidate ),\\n', '\\n', '            .req_o           ( mmu_req             ),\\n', '            .adr_o           ( mmu_adr             ), //physical address\\n', '            .size_o          ( mmu_size            ),\\n', '            .lock_o          ( mmu_lock            ),\\n', '            .we_o            ( mmu_we              ),\\n', '            .misaligned_o    ( mmu_misaligned      ),\\n', '\\n', '            .cm_clean_o      ( mmu_cm_clean        ),\\n', '            .cm_invalidate_o ( mmu_cm_invalidate   ),\\n', '\\n', '            .pagefault_o     ( mmu_pagefault       ) );\\n', '      end\\n', '\\n', '\\n', '      /* Hookup Physical Memory Attribute Unit\\n', '       */\\n', '      if (PMA_CNT > 0)\\n', '      begin : pma_blk\\n', '          riscv_pmachk #(\\n', '            .XLEN          ( XLEN           ),\\n', '            .PLEN          ( PLEN           ),\\n', '            .HAS_RVC       ( HAS_RVC        ),\\n', '            .PMA_CNT       ( PMA_CNT        ) )\\n', '          pmachk_inst (\\n', '            .clk_i         ( clk_i          ),\\n', '            .stall_i       ( stall          ),\\n', '\\n', '            //Configuration\\n', '            .pma_cfg_i     ( pma_cfg_i      ),\\n', '            .pma_adr_i     ( pma_adr_i      ),\\n', '\\n', '            //Memory Access\\n', \"            .instruction_i ( 1'b0           ), //data access\\n\", '            .adr_i         ( mmu_adr        ), //physical address\\n', '            .size_i        ( mmu_size       ),\\n', '            .lock_i        ( mmu_lock       ),\\n', '            .we_i          ( mmu_we         ),\\n', '            .misaligned_i  ( mmu_misaligned ),\\n', '\\n', '            //Output\\n', '            .exception_o   ( pma_exception  ),\\n', '            .misaligned_o  ( pma_misaligned ),\\n', '            .cacheable_o   ( pma_cacheable  ) );\\n', '      end\\n', '      else\\n', '      begin\\n', '          //no PMA-check. Tie off signals\\n', \"          assign pma_cacheable = 1'b1; //Afterall, we do have a cache ...\\n\", \"          assign pma_exception = 1'b0;\\n\", '\\n', '          // pma_misaligned is delayed 1 cycle\\n', '          always @(posedge clk_i)\\n', '            if (!stall) pma_misaligned <= mmu_misaligned;\\n', '      end\\n', '\\n', '\\n', '\\n', '      /* Hookup Physical Memory Protection Unit\\n', '       */\\n', '      if (PMP_CNT > 0)\\n', '      begin : pmp_blk\\n', '          riscv_pmpchk #(\\n', '            .XLEN          ( XLEN          ),\\n', '            .PLEN          ( PLEN          ),\\n', '            .PMP_CNT       ( PMP_CNT       ) )\\n', '          pmpchk_inst (\\n', '            .clk_i         ( clk_i         ),\\n', '            .stall_i       ( stall         ),\\n', '\\n', '            .st_pmpcfg_i   ( st_pmpcfg_i   ),\\n', '            .st_pmpaddr_i  ( st_pmpaddr_i  ),\\n', '            .st_prv_i      ( st_prv_i      ),\\n', '\\n', \"            .instruction_i ( 1'b0          ),  //Data access\\n\", '            .adr_i         ( mmu_adr       ),  //Physical Memory address (i.e. after translation)\\n', '            .size_i        ( mmu_size      ),  //Transfer size\\n', '            .we_i          ( mmu_we        ),  //Read/Write enable\\n', '\\n', '            .exception_o   ( pmp_exception ) );\\n', '      end\\n', '      else\\n', '      begin\\n', '          //No PMP, tie off signals\\n', \"          assign pmp_exception = 1'b0;\\n\", '      end\\n', '\\n', '\\n', '      /* Instantiate Data Cache Core\\n', '       */\\n', '      riscv_dcache_core #(\\n', '        .XLEN              ( XLEN              ),\\n', '        .PLEN              ( PLEN              ),\\n', '        .SIZE              ( CACHE_SIZE        ),\\n', '        .BLOCK_SIZE        ( CACHE_BLOCK_SIZE  ),\\n', '        .WAYS              ( CACHE_WAYS        ),\\n', '        .TECHNOLOGY        ( TECHNOLOGY        ),\\n', '        .BIUTAG_SIZE       ( BIUTAG_SIZE       ) )\\n', '      dcache_inst (\\n', '        //common signals\\n', '        .rst_ni            ( rst_ni            ),\\n', '        .clk_i             ( clk_i             ),\\n', '\\n', '\\t.stall_o           ( stall             ),\\n', '\\n', '        //from MMU\\n', '        .phys_adr_i        ( mmu_adr           ), //physical address\\n', '        .pagefault_i       ( mmu_pagefault     ),\\n', '\\n', '        //from PMA\\n', '        .pma_cacheable_i   ( pma_cacheable     ),\\n', '        .pma_misaligned_i  ( pma_misaligned    ),\\n', '        .pma_exception_i   ( pma_exception     ),\\n', '\\n', '        //from PMP\\n', '\\t.pmp_exception_i   ( pmp_exception     ),\\n', '\\n', '        //from/to CPU\\n', '        .mem_req_i         ( queue_req         ),\\n', '        .mem_ack_o         ( mem_ack_o         ),\\n', '        .mem_adr_i         ( queue_adr         ), //virtual address\\n', \"        .mem_flush_i       ( 1'b0              ),\\n\", '        .mem_size_i        ( queue_size        ),\\n', '        .mem_lock_i        ( queue_lock        ),\\n', '        .mem_prot_i        ( queue_prot        ),\\n', '        .mem_we_i          ( queue_we          ),\\n', '        .mem_d_i           ( queue_d           ),\\n', '        .mem_q_o           ( mem_q_o           ),\\n', '        .mem_err_o         ( mem_err_o         ),\\n', '\\t.mem_misaligned_o  ( mem_misaligned_o  ),\\n', '        .mem_pagefault_o   ( mem_pagefault_o   ),\\n', '\\n', '\\t//Cache Block Management\\n', '\\t.invalidate_i      ( mmu_cm_invalidate ),\\n', '        .clean_i           ( mmu_cm_clean      ),\\n', '\\t.clean_rdy_clr_i   ( cm_clean_i        ), //immediately clear clean_rdy\\n', '        .clean_rdy_o       ( cm_clean_rdy_o    ),\\n', '\\n', '        //To BIU\\n', '        .biu_stb_o         ( biu_stb_o         ),\\n', '        .biu_stb_ack_i     ( biu_stb_ack_i     ),\\n', '        .biu_d_ack_i       ( biu_d_ack_i       ),\\n', '        .biu_adri_o        ( biu_adri_o        ),\\n', '        .biu_adro_i        ( biu_adro_i        ),\\n', '        .biu_size_o        ( biu_size_o        ),\\n', '        .biu_type_o        ( biu_type_o        ),\\n', '        .biu_we_o          ( biu_we_o          ),\\n', '        .biu_lock_o        ( biu_lock_o        ),\\n', '        .biu_prot_o        ( biu_prot_o        ),\\n', '        .biu_d_o           ( biu_d_o           ),\\n', '        .biu_q_i           ( biu_q_i           ),\\n', '        .biu_ack_i         ( biu_ack_i         ),\\n', '        .biu_err_i         ( biu_err_i         ),\\n', '        .biu_tagi_o        ( biu_tagi_o        ),\\n', '        .biu_tago_i        ( biu_tago_i        ) );\\n', '  end\\n', '  else  //No cache\\n', '  begin\\n', '      /*\\n', '       * No Data Cache Core\\n', '       * Control and glue logic only\\n', '       */\\n', '      riscv_nodcache_core #(\\n', '        .XLEN             ( XLEN             ),\\n', '        .ALEN             ( PLEN             ),\\n', '        .DEPTH            ( 2                ) )\\n', '      nodcache_core_inst (\\n', '        //common signals\\n', '        .rst_ni           ( rst_ni           ),\\n', '        .clk_i            ( clk_i            ),\\n', '\\n', '        //CPU\\n', '        .mem_req_i        ( mem_req_i        ),\\n', '        .mem_size_i       ( mem_size_i       ),\\n', '        .mem_lock_i       ( mem_lock_i       ),\\n', '        .mem_misaligned_i ( mem_misaligned   ),\\n', '        .mem_adr_i        ( mem_adr_i        ),\\n', '        .mem_we_i         ( mem_we_i         ),\\n', '        .mem_d_i          ( mem_d_i          ),\\n', '        .mem_q_o          ( mem_q_o          ),\\n', '        .mem_ack_o        ( mem_ack_o        ),\\n', '        .mem_err_o        ( mem_err_o        ),\\n', '        .mem_misaligned_o ( mem_misaligned_o ),\\n', '        .st_prv_i         ( st_prv_i         ),\\n', '\\n', '        //BIU\\n', '        .biu_stb_o        ( biu_stb_o        ),\\n', '        .biu_stb_ack_i    ( biu_stb_ack_i    ),\\n', '        .biu_d_ack_i      ( biu_d_ack_i      ),\\n', '        .biu_adri_o       ( biu_adri_o       ),\\n', '        .biu_adro_i       ( biu_adro_i       ),\\n', '        .biu_size_o       ( biu_size_o       ),\\n', '        .biu_type_o       ( biu_type_o       ),\\n', '        .biu_we_o         ( biu_we_o         ),\\n', '        .biu_lock_o       ( biu_lock_o       ),\\n', '        .biu_prot_o       ( biu_prot_o       ),\\n', '        .biu_d_o          ( biu_d_o          ),\\n', '        .biu_q_i          ( biu_q_i          ),\\n', '        .biu_ack_i        ( biu_ack_i        ),\\n', '        .biu_err_i        ( biu_err_i        ) );\\n', '\\n', \"      assign stall           = 1'b0;\\n\", \"      assign cm_clean_rdy_o  = 1'b1; //no data cache to flush. Always ready\\n\", \"      assign mem_pagefault_o = 1'b0;\\n\", '  end\\n', 'endgenerate\\n', '\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Instruction Memory Access Block                              //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_imem_ctrl\\n', 'import riscv_state_pkg::*;\\n', 'import riscv_pma_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter int    XLEN             = 32,\\n', '  parameter int    PLEN             = XLEN==32 ? 34 : 56,\\n', '  parameter int    PARCEL_SIZE      = 32,\\n', '\\n', '  parameter int    HAS_RVC          = 0,\\n', '  parameter int    HAS_MMU          = 0,\\n', '\\n', '  parameter int    PMA_CNT          = 3,\\n', '  parameter int    PMP_CNT          = 16,\\n', '\\n', '  parameter int    CACHE_SIZE       = 64, //KBYTES\\n', '  parameter int    CACHE_BLOCK_SIZE = 32, //BYTES\\n', '  parameter int    CACHE_WAYS       =  2, // 1           : Direct Mapped\\n', '                                          //<n>          : n-way set associative\\n', '                                          //<n>==<blocks>: fully associative\\n', '\\n', '/*\\n', '  parameter REPLACE_ALG     = 1,  //0: Random\\n', '                                  //1: FIFO\\n', '                                  //2: LRU\\n', '*/\\n', '  parameter string TECHNOLOGY      = \"GENERIC\",\\n', '\\n', '  parameter int    BIUTAG_SIZE     = $clog2(XLEN/PARCEL_SIZE)\\n', ')\\n', '(\\n', '  input  logic                                 rst_ni,\\n', '  input  logic                                 clk_i,\\n', ' \\n', '  //Configuration\\n', '  input  pmacfg_t                              pma_cfg_i [PMA_CNT],\\n', '  input                 [XLEN            -1:0] pma_adr_i [PMA_CNT],\\n', '\\n', '  input  pmpcfg_t [15:0]                       st_pmpcfg_i,\\n', '  input  logic    [15:0][XLEN            -1:0] st_pmpaddr_i,\\n', '  input  logic          [                 1:0] st_prv_i,\\n', '\\n', '  //CPU side\\n', '  input  logic                                 mem_req_i,\\n', '  output logic                                 mem_ack_o,\\n', '  input  logic                                 mem_flush_i,\\n', '  input  logic          [XLEN            -1:0] mem_adr_i,\\n', '  output logic          [XLEN            -1:0] parcel_o,\\n', '  output logic          [XLEN/PARCEL_SIZE-1:0] parcel_valid_o,\\n', '  output logic                                 mem_error_o,\\n', '                                               mem_misaligned_o,\\n', '                                               mem_pagefault_o,\\n', '\\n', '  //Cache Block Management, per CMO spec\\n', '  //Flush = Invalidate + Clean\\n', '  input  logic                                 cm_invalidate_i,\\n', '  input  logic                                 cm_dc_clean_rdy_i,\\n', '\\n', '  //BIU ports\\n', '  output logic                                 biu_stb_o,\\n', '  input  logic                                 biu_stb_ack_i,\\n', '  input  logic                                 biu_d_ack_i,\\n', '  output logic          [PLEN            -1:0] biu_adri_o,\\n', '  input  logic          [PLEN            -1:0] biu_adro_i,\\n', '  output biu_size_t                            biu_size_o,\\n', '  output biu_type_t                            biu_type_o,\\n', '  output logic                                 biu_we_o,\\n', '  output logic                                 biu_lock_o,\\n', '  output biu_prot_t                            biu_prot_o,\\n', '  output logic          [XLEN            -1:0] biu_d_o,\\n', '  input  logic          [XLEN            -1:0] biu_q_i,\\n', '  input  logic                                 biu_ack_i,\\n', '                                               biu_err_i,\\n', '  output logic          [BIUTAG_SIZE     -1:0] biu_tagi_o,\\n', '  input  logic          [BIUTAG_SIZE     -1:0] biu_tago_i\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '\\n', '  logic            stall;\\n', '\\n', '  //Transfer parameters\\n', '  biu_size_t       size;\\n', '  biu_prot_t       prot;\\n', '  logic            lock;\\n', '\\n', '  //MMU\\n', '  logic            mmu_req;\\n', '  logic [PLEN-1:0] mmu_adr;\\n', '  biu_size_t       mmu_size;\\n', '  logic            mmu_lock;\\n', '  logic            mmu_we;\\n', '  logic            mmu_misaligned;\\n', '  logic            mmu_pagefault;\\n', '\\n', '  logic            mmu_cm_invalidate;\\n', '\\n', '  //Misalignment check\\n', '  logic            mem_misaligned;\\n', '\\n', '  //from PMA check\\n', '  logic            pma_exception,\\n', '                   pma_misaligned;\\n', '  logic            pma_cacheable;\\n', '\\n', '  //from PMP check\\n', '  logic            pmp_exception;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '  assign size             = XLEN == 64 ? DWORD : WORD;   //Transfer size\\n', \"  assign prot             = biu_prot_t'( PROT_INSTRUCTION                                 |\\n\", '\\t                                (st_prv_i == PRV_U ? PROT_USER : PROT_PRIVILEGED) );\\n', \"  assign lock            = 1'b0; //no locked instruction accesses\\n\", '\\n', '  /* Hookup misalinged block\\n', '   */\\n', '  riscv_memmisaligned #(\\n', '    .XLEN          ( XLEN           ),\\n', '    .HAS_RVC       ( HAS_RVC        ) )\\n', '  misaligned_inst (\\n', \"    .instruction_i ( 1'b1           ), //instruction access\\n\", '    .adr_i         ( mem_adr_i      ), //virtual address\\n', '    .size_i        ( size           ),\\n', '    .misaligned_o  ( mem_misaligned ) );\\n', '\\n', '\\n', '  /* Hookup Cache\\n', '   */\\n', 'generate\\n', '  if (CACHE_SIZE > 0)\\n', '  begin : cache_blk\\n', '      /* Hookup MMU\\n', '       */\\n', '      if (HAS_MMU != 0)\\n', '      begin : mmu_blk\\n', '      end\\n', '      else\\n', '      begin : nommu_blk\\n', '          riscv_nommu #(\\n', '            .XLEN            ( XLEN              ),\\n', '            .PLEN            ( PLEN              ) )\\n', '          mmu_inst (\\n', '            .rst_ni          ( rst_ni            ),\\n', '            .clk_i           ( clk_i             ),\\n', '            .stall_i         ( stall             ),\\n', '\\n', '            .flush_i         ( mem_flush_i       ),\\n', '            .req_i           ( mem_req_i         ),\\n', '            .adr_i           ( mem_adr_i         ), //virtual address\\n', '            .size_i          ( size              ),\\n', '            .lock_i          ( lock              ),\\n', \"            .we_i            ( 1'b0              ),\\n\", '            .misaligned_i    ( mem_misaligned    ),\\n', '\\n', \"            .cm_clean_i      ( 1'b0              ),\\n\", '            .cm_invalidate_i ( cm_invalidate_i   ),\\n', '\\n', '            .req_o           ( mmu_req           ),\\n', '            .adr_o           ( mmu_adr           ), //physical address\\n', '            .size_o          ( mmu_size          ),\\n', '            .lock_o          ( mmu_lock          ),\\n', '            .we_o            (                   ),\\n', '            .misaligned_o    ( mmu_misaligned    ),\\n', '\\n', '            .cm_clean_o      (                   ),\\n', '            .cm_invalidate_o ( mmu_cm_invalidate ),\\n', '\\n', '            .pagefault_o     ( mmu_pagefault     ) );\\n', '      end\\n', '\\n', '\\n', '      /* Hookup Physical Memory Attributes Unit\\n', '       */\\n', '      if (PMA_CNT > 0)\\n', '      begin : pma_blk\\n', '          riscv_pmachk #(\\n', '            .XLEN           ( XLEN           ),\\n', '            .PLEN           ( PLEN           ),\\n', '            .HAS_RVC        ( HAS_RVC        ),\\n', '            .PMA_CNT        ( PMA_CNT        ) )\\n', '          pmachk_inst (\\n', '            .clk_i          ( clk_i          ),\\n', '            .stall_i        ( stall          ),\\n', '\\n', '            //Configuration\\n', '            .pma_cfg_i      ( pma_cfg_i      ),\\n', '            .pma_adr_i      ( pma_adr_i      ),\\n', '\\n', '            //misaligned\\n', '            .misaligned_i   ( mmu_misaligned ),\\n', '\\n', '            //Memory Access\\n', \"            .instruction_i  ( 1'b1           ), //Instruction access\\n\", '            .adr_i          ( mmu_adr        ),\\n', '            .size_i         ( size           ),\\n', '            .lock_i         ( lock           ),\\n', \"            .we_i           ( 1'b0           ), //Instruction bus doesn't write\\n\", '\\n', '            //Output\\n', '            .exception_o    ( pma_exception  ),\\n', '            .misaligned_o   ( pma_misaligned ),\\n', '            .cacheable_o    ( pma_cacheable  ) );\\n', '      end\\n', '      else\\n', '      begin\\n', '          //no PMA-check. Tie off signals\\n', \"          assign pma_cacheable = 1'b1; //Afterall, we do have a cache ...\\n\", \"          assign pma_exception = 1'b0;\\n\", '\\n', '          // pma_misaligned is registered\\n', '          always @(posedge clk_i)\\n', '            if (!stall) pma_misaligned <= mmu_misaligned;\\n', '      end\\n', '\\n', '\\n', '      /* Hookup Physical Memory Protection Unit\\n', '       */\\n', '      if (PMP_CNT > 0)\\n', '      begin: pmp_blk\\n', '      riscv_pmpchk #(\\n', '        .XLEN          ( XLEN          ),\\n', '        .PLEN          ( PLEN          ),\\n', '        .PMP_CNT       ( PMP_CNT       ) )\\n', '      pmpchk_inst (\\n', '        .clk_i         ( clk_i         ),\\n', '        .stall_i       ( stall         ),\\n', '\\n', '        .st_pmpcfg_i   ( st_pmpcfg_i   ),\\n', '        .st_pmpaddr_i  ( st_pmpaddr_i  ),\\n', '        .st_prv_i      ( st_prv_i      ),\\n', '\\n', \"        .instruction_i ( 1'b1          ),  //Instruction access\\n\", '        .adr_i         ( mmu_adr       ),  //Physical Memory address (i.e. after translation)\\n', '        .size_i        ( size          ),  //Transfer size\\n', \"        .we_i          ( 1'b0          ),  //Read/Write enable\\n\", '\\n', '        .exception_o   ( pmp_exception ) );\\n', '      end\\n', '      else\\n', '      begin\\n', '          //No PMP, tie off signals\\n', \"          assign pmp_exception = 1'b0;\\n\", '      end\\n', '\\n', '\\n', '      /* Instantiate Instruction Cache Core\\n', '       */\\n', '      riscv_icache_core #(\\n', '        .XLEN                ( XLEN               ),\\n', '        .PLEN                ( PLEN               ),\\n', '\\t.HAS_RVC             ( HAS_RVC            ),\\n', '        .PARCEL_SIZE         ( PARCEL_SIZE        ),\\n', '        .SIZE                ( CACHE_SIZE         ),\\n', '        .BLOCK_SIZE          ( CACHE_BLOCK_SIZE   ),\\n', '        .WAYS                ( CACHE_WAYS         ),\\n', '        .TECHNOLOGY          ( TECHNOLOGY         ),\\n', '        .BIUTAG_SIZE         ( BIUTAG_SIZE        ) )\\n', '      icache_inst (\\n', '        //common signals\\n', '        .rst_ni              ( rst_ni             ),\\n', '        .clk_i               ( clk_i              ),\\n', '\\n', '\\t//from MMU\\n', '\\t.phys_adr_i          ( mmu_adr            ),\\n', '        .pagefault_i         ( mmu_pagefault      ),\\n', '\\n', '        //from PMA\\n', '        .pma_cacheable_i     ( pma_cacheable      ),\\n', '        .pma_misaligned_i    ( pma_misaligned     ),\\n', '        .pma_exception_i     ( pma_exception      ),\\n', '\\n', '\\t//from PMP\\n', '\\t.pmp_exception_i     ( pmp_exception      ),\\n', '\\n', '\\t//from/to CPU\\n', '        .mem_req_i           ( mem_req_i          ),\\n', '\\t.mem_stall_o         ( stall              ),\\n', '        .mem_adr_i           ( mem_adr_i          ),\\n', '        .mem_flush_i         ( mem_flush_i        ),\\n', '        .mem_size_i          ( size               ),\\n', '        .mem_lock_i          ( lock               ),\\n', '        .mem_prot_i          ( prot               ),\\n', '        .parcel_o            ( parcel_o           ),\\n', '        .parcel_valid_o      ( parcel_valid_o     ),\\n', '\\t.parcel_misaligned_o ( mem_misaligned_o   ),\\n', '        .parcel_error_o      ( mem_error_o        ),\\n', '\\t.parcel_pagefault_o  ( mem_pagefault_o    ),\\n', '\\n', '\\t//Cache management\\n', '        .invalidate_i        ( cm_invalidate_i    ),\\n', '        .dc_clean_rdy_i      ( cm_dc_clean_rdy_i  ),\\n', '\\n', '        //To BIU\\n', '        .biu_stb_o           ( biu_stb_o          ),\\n', '        .biu_stb_ack_i       ( biu_stb_ack_i      ),\\n', '        .biu_d_ack_i         ( biu_d_ack_i        ),\\n', '        .biu_adri_o          ( biu_adri_o         ),\\n', '        .biu_adro_i          ( biu_adro_i         ),\\n', '        .biu_size_o          ( biu_size_o         ),\\n', '        .biu_type_o          ( biu_type_o         ),\\n', '\\t.biu_we_o            ( biu_we_o           ),\\n', '        .biu_lock_o          ( biu_lock_o         ),\\n', '        .biu_prot_o          ( biu_prot_o         ),\\n', '        .biu_d_o             ( biu_d_o            ),\\n', '        .biu_q_i             ( biu_q_i            ),\\n', '        .biu_ack_i           ( biu_ack_i          ),\\n', '        .biu_err_i           ( biu_err_i          ),\\n', '        .biu_tagi_o          ( biu_tagi_o         ),\\n', '        .biu_tago_i          ( biu_tago_i         ) );\\n', '\\n', '\\n', '      //assign memory fetch acknowledge\\n', '      assign mem_ack_o = ~stall;\\n', '  end\\n', '  else  //No cache\\n', '  begin\\n', '   /*\\n', '    * No Instruction Cache Core\\n', '    * Control and glue logic only\\n', '    */\\n', '   riscv_noicache_core #(\\n', '     .XLEN                   ( XLEN              ),\\n', '     .PLEN                   ( PLEN              ),\\n', '     .HAS_RVC                ( HAS_RVC           ),\\n', '     .PARCEL_SIZE            ( PARCEL_SIZE       ),\\n', '     .BIUTAG_SIZE            ( BIUTAG_SIZE       ) )\\n', '   noicache_core_inst (\\n', '     //common signals\\n', '     .rst_ni                 ( rst_ni            ),\\n', '     .clk_i                  ( clk_i             ),\\n', '\\n', '     //CPU\\n', '     .if_req_i               ( mem_req_i         ),\\n', '     .if_ack_o               ( mem_ack_o         ),\\n', '     .if_prot_i              ( prot              ),\\n', '     .if_flush_i             ( mem_flush_i       ),\\n', '     .if_nxt_pc_i            ( mem_adr_i         ),\\n', '     .if_parcel_pc_o         (                   ),\\n', '     .if_parcel_o            ( parcel_o          ),\\n', '     .if_parcel_valid_o      ( parcel_valid_o    ),\\n', '     .if_parcel_misaligned_o ( mem_misaligned_o  ),\\n', '     .if_parcel_error_o      ( mem_error_o       ),\\n', '     .cm_dc_clean_rdy_i      ( cm_dc_clean_rdy_i ),\\n', '     .st_prv_i               ( st_prv_i          ),\\n', '\\n', '     //BIU\\n', '     .biu_stb_o              ( biu_stb_o         ),\\n', '     .biu_stb_ack_i          ( biu_stb_ack_i     ),\\n', '     .biu_d_ack_i            ( biu_d_ack_i       ),\\n', '     .biu_adri_o             ( biu_adri_o        ),\\n', '     .biu_adro_i             ( biu_adro_i        ),\\n', '     .biu_size_o             ( biu_size_o        ),\\n', '     .biu_type_o             ( biu_type_o        ),\\n', '     .biu_we_o               ( biu_we_o          ),\\n', '     .biu_lock_o             ( biu_lock_o        ),\\n', '     .biu_prot_o             ( biu_prot_o        ),\\n', '     .biu_d_o                ( biu_d_o           ),\\n', '     .biu_q_i                ( biu_q_i           ),\\n', '     .biu_ack_i              ( biu_ack_i         ),\\n', '     .biu_err_i              ( biu_err_i         ),\\n', '     .biu_tagi_o             ( biu_tagi_o        ),\\n', '     .biu_tago_i             ( biu_tago_i        ) );\\n', '\\n', '   //no MMU\\n', \"   assign mem_pagefault_o = 1'b0;\\n\", '\\n', '  end\\n', 'endgenerate\\n', '\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Memory Access Buffer                                         //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2018 ROA Logic BV                     //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '/* Buffer memory access\\n', \" * Temporary buffer, in case previous access didn't finish yet\\n\", ' */\\n', '\\n', 'module riscv_membuf\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter DEPTH = 2,\\n', '  parameter XLEN  = 32\\n', ')\\n', '(\\n', '  input  logic             rst_ni,\\n', '  input  logic             clk_i,\\n', '\\n', '  input  logic             flush_i,  //clear pending requests\\n', '  input  logic             stall_i,\\n', '\\n', '  //CPU side\\n', '  input  logic             req_i,\\n', '  input  logic [XLEN -1:0] adr_i,\\n', '  input  biu_size_t        size_i,\\n', '  input  logic             lock_i,\\n', '  input  biu_prot_t        prot_i,\\n', '  input  logic             we_i,\\n', '  input  logic [XLEN -1:0] d_i,\\n', '  input  logic             misaligned_i,\\n', '\\n', '  input  logic             cm_clean_i,\\n', '  input  logic             cm_invalidate_i,\\n', '\\n', '  //Memory system side\\n', '  output logic             req_o,\\n', '  input  logic             ack_i,\\n', '  output logic [XLEN -1:0] adr_o,\\n', '  output biu_size_t        size_o,\\n', '  output logic             lock_o,\\n', '  output biu_prot_t        prot_o,\\n', '  output logic             we_o,\\n', '  output logic [XLEN -1:0] q_o,\\n', '  output logic             misaligned_o,\\n', '\\n', '  output logic             cm_clean_o,\\n', '  output logic             cm_invalidate_o,\\n', '\\n', '  output logic             empty_o,\\n', '  output logic             full_o\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Typedefs\\n', '  //\\n', '  typedef struct packed {\\n', '    logic             req;\\n', '    logic [XLEN -1:0] adr;\\n', '    biu_size_t        size;\\n', '    logic             lock;\\n', '    biu_prot_t        prot;\\n', '    logic             we;\\n', '    logic [XLEN -1:0] d;\\n', '    logic             misaligned;\\n', '\\n', '    logic             cm_clean;\\n', '    logic             cm_invalidate;\\n', '  } queue_t;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  queue_t                 queue_d,\\n', '                          queue_q;\\n', '  logic                   queue_we,\\n', '                          queue_re;\\n', '\\n', '  logic [$clog2(DEPTH):0] access_pending;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  // Assign queue-data\\n', '  assign queue_d.req           = req_i;\\n', '  assign queue_d.adr           = adr_i;\\n', '  assign queue_d.size          = size_i;\\n', '  assign queue_d.lock          = lock_i;\\n', '  assign queue_d.prot          = prot_i;\\n', '  assign queue_d.we            = we_i;\\n', '  assign queue_d.d             = d_i;\\n', '  assign queue_d.misaligned    = misaligned_i;\\n', '  assign queue_d.cm_clean      = cm_clean_i;\\n', '  assign queue_d.cm_invalidate = cm_invalidate_i;\\n', '\\n', '\\n', '  // Instantiate Queue \\n', '  rl_queue #(\\n', '    .DEPTH ( DEPTH          ),\\n', '    .DBITS ( $bits(queue_t) )\\n', '  )\\n', '  rl_queue_inst (\\n', '    .rst_ni         ( rst_ni    ),\\n', '    .clk_i          ( clk_i     ),\\n', '    .clr_i          ( flush_i   ),\\n', \"    .ena_i          ( 1'b1      ),\\n\", '    .we_i           ( queue_we  ),\\n', '    .d_i            ( queue_d   ),\\n', '    .re_i           ( queue_re  ),\\n', '    .q_o            ( queue_q   ),\\n', '    .empty_o        ( empty_o   ),\\n', '    .full_o         ( full_o    ),\\n', '    .almost_empty_o (           ),\\n', '    .almost_full_o  (           )\\n', '  );\\n', '\\n', '\\n', '  //control signals\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni  ) access_pending <= 'h0;\\n\", \"    else if ( flush_i ) access_pending <= 'h0;\\n\", '    else //if (!stall_i )\\n', '      unique case ( {req_i, ~stall_i} )\\n', \"         2'b01  : access_pending <= |access_pending ? access_pending -1 : 'h0;\\n\", \"         2'b10  : access_pending <= access_pending +1;\\n\", '         default: ; //do nothing\\n', '      endcase\\n', '\\n', '\\n', '  assign queue_we = (req_i   &  (stall_i | |access_pending)) |\\n', '                    cm_clean_i | cm_invalidate_i;\\n', '  assign queue_re = ~empty_o & ~stall_i;\\n', '\\n', '\\n', '  //queue outputs\\n', '  assign req_o           = empty_o ? req_i           : queue_q.req;\\n', '  assign adr_o           = empty_o ? adr_i           : queue_q.adr;\\n', '  assign size_o          = empty_o ? size_i          : queue_q.size;\\n', '  assign lock_o          = empty_o ? lock_i          : queue_q.lock;\\n', '  assign prot_o          = empty_o ? prot_i          : queue_q.prot;\\n', '  assign we_o            = empty_o ? we_i            : queue_q.we;\\n', '  assign q_o             = empty_o ? d_i             : queue_q.d;\\n', '  assign misaligned_o    = empty_o ? misaligned_i    : queue_q.misaligned;\\n', '  assign cm_clean_o      = empty_o ? cm_clean_i      : queue_q.cm_clean;\\n', '  assign cm_invalidate_o = empty_o ? cm_invalidate_i : queue_q.cm_invalidate;\\n', 'endmodule\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Misalignment Check                                           //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_memmisaligned\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter XLEN    = 32,\\n', '  parameter HAS_RVC = 0\\n', ')\\n', '(\\n', '  //CPU side\\n', '  input  logic              instruction_i,\\n', '  input  logic [XLEN  -1:0] adr_i,\\n', '  input  biu_size_t         size_i,\\n', '\\n', '  //To memory subsystem\\n', '  output logic              misaligned_o\\n', ');\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '  always_comb\\n', '    if (instruction_i)\\n', '      misaligned_o = (HAS_RVC != 0) ? adr_i[0] : |adr_i[1:0];\\n', '    else\\n', '      unique case (size_i)\\n', \"        BYTE   : misaligned_o = 1'b0;\\n\", '        HWORD  : misaligned_o =  adr_i[  0];\\n', '        WORD   : misaligned_o = |adr_i[1:0];\\n', '        DWORD  : misaligned_o = |adr_i[2:0];\\n', \"        default: misaligned_o = 1'b1;\\n\", '      endcase\\n', 'endmodule\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Memory Management Unit                                       //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2018 ROA Logic BV                     //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '/* Placeholder for MMU\\n', ' * RISC-V uses 4KB pages\\n', ' * SATP-CSR holds: [MODE|ASID|PPN]\\n', ' * Mode: rv32   rv64\\n', ' * 0     bare   bare (no translation)\\n', ' * 1     sv32   reserved\\n', ' * 2-7   .      reserved\\n', ' * 8     .      sv39\\n', ' * 9     .      sv48\\n', ' * 10    .      sv57\\n', ' * 11    .      sv64\\n', ' * 12-15 .      reserved\\n', ' */\\n', '\\n', 'import biu_constants_pkg::*;\\n', '\\n', 'module riscv_mmu #(\\n', '  parameter XLEN = 32,\\n', '  parameter PLEN = XLEN //\\n', ')\\n', '(\\n', '  input  logic            rst_ni,\\n', '  input  logic            clk_i,\\n', '  input  logic            clr_i,   //clear pending request\\n', '\\n', '  //Mode\\n', '//  input  logic [XLEN-1:0] st_satp;\\n', '\\n', '  //CPU side\\n', '  input  logic            vreq_i,  //Request from CPU\\n', '  input  logic [XLEN-1:0] vadr_i,  //Virtual Memory Address\\n', '  input  biu_size_t       vsize_i,\\n', '  input  logic            vlock_i,\\n', '  input  biu_prot_t       vprot_i,\\n', '  input  logic            vwe_i,\\n', '  input  logic [XLEN-1:0] vd_i,\\n', '\\n', '  //Memory system side\\n', '  output logic            preq_o,\\n', '  output logic [PLEN-1:0] padr_o,  //Physical Memory Address\\n', '  output biu_size_t       psize_o,\\n', '  output logic            plock_o,\\n', '  output biu_prot_t       pprot_o,\\n', '  output logic            pwe_o,\\n', '  output logic [XLEN-1:0] pd_o,\\n', '  input  logic [XLEN-1:0] pq_i,\\n', '  input  logic            pack_i,\\n', '\\n', '  //Exception\\n', '  output logic            page_fault_o\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  always @(posedge clk_i)\\n', '    if (vreq_i) padr_o <= vadr_i; //TODO: actual translation\\n', '\\n', '\\n', '  //Insert state machine here\\n', '  always @(posedge clk_i)\\n', \"    if (clr_i) preq_o <= 1'b0;\\n\", '    else       preq_o <= vreq_i;\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', '    begin\\n', '        psize_o <= vsize_i;\\n', '        plock_o <= vlock_i;\\n', '        pprot_o <= vprot_i;\\n', '        pwe_o   <= vwe_i;\\n', '    end\\n', '\\n', '\\n', '  //MMU does not write data\\n', '  always @(posedge clk_i)\\n', '    pd_o <= vd_i;\\n', '\\n', '\\n', '  //No page fault yet\\n', \"  assign page_fault_o = 1'b0;\\n\", '\\n', 'endmodule\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Physical Memory Attributes Checker                           //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2018-2022 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_pmachk\\n', 'import riscv_pma_pkg::*;\\n', \"import riscv_state_pkg::*; //pmpcfg_a_t; //Quartus doesn't like this\\n\", 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter XLEN    = 32,\\n', '  parameter PLEN    = XLEN == 32 ? 34 : 56,\\n', '  parameter HAS_RVC = 0,\\n', '  parameter PMA_CNT = 16\\n', ')\\n', '(\\n', '  input  logic               clk_i,\\n', '  input  logic               stall_i,\\n', '\\n', '  //PMA  configuration\\n', '  input  pmacfg_t            pma_cfg_i [PMA_CNT],\\n', '  input  logic    [XLEN-1:0] pma_adr_i [PMA_CNT],\\n', '\\n', '  //Memory Access\\n', '  input  logic               instruction_i, //This is an instruction access\\n', '  input  logic    [PLEN-1:0] adr_i,         //Physical Memory address (i.e. after translation)\\n', '  input  biu_size_t          size_i,        //Transfer size\\n', '  input  logic               lock_i,        //AMO : TODO: specify AMO type\\n', '  input  logic               we_i,\\n', '\\n', '  input  logic               misaligned_i,  //Misaligned access\\n', '\\n', '\\n', '  //Output\\n', '  output logic               exception_o,\\n', '                             misaligned_o,\\n', '                             cacheable_o\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Functions\\n', '  //\\n', '\\n', '  //convert transfer size in number of bytes in transfer\\n', '  function automatic int size2bytes;\\n', '    input biu_size_t size;\\n', '\\n', '    case (size)\\n', '      BYTE   : size2bytes = 1;\\n', '      HWORD  : size2bytes = 2;\\n', '      WORD   : size2bytes = 4;\\n', '      DWORD  : size2bytes = 8;\\n', '      QWORD  : size2bytes = 16;\\n', '      default: begin\\n', '                   size2bytes = -1;\\n', '                   $error (\"Illegal biu_size_t\");\\n', '               end\\n', '    endcase\\n', '  endfunction: size2bytes\\n', '\\n', '\\n', '  //Lower and Upper bounds for NA4/NAPOT\\n', '  function int napot_boundary;\\n', '    input na4; //special case na4\\n', '    input [XLEN-1:0] pmaddr;\\n', '\\n', '    int n;\\n', '    bit true;\\n', '\\n', \"    //find 'n' boundary = 2^(n+2) bytes\\n\", '    n = 2;\\n', '    if (!na4)\\n', '    begin\\n', \"        true = 1'b1;\\n\", '        for (int i=0; (i < $bits(pmaddr)) && true; i++)\\n', '          if (pmaddr[i]) n++;\\n', \"          else           true = 1'b0;\\n\", '\\t \\n', '        n++;\\n', '    end\\n', '\\n', '    return n;\\n', '  endfunction: napot_boundary\\n', '\\n', '\\n', '  function automatic [PLEN-1:0] napot_lb;\\n', '    input            na4; //special case na4\\n', '    input [XLEN-1:0] pmaddr;\\n', '\\n', '    int n;\\n', '    logic [PLEN-1:0] mask;\\n', '\\n', \"    //find 'n' boundary = 2^(n+2) bytes\\n\", '    n = napot_boundary(na4, pmaddr);\\n', '\\n', '    //create mask\\n', \"    mask = {$bits(mask){1'b1}} << n;\\n\", '\\n', '    //lower bound address\\n', '    napot_lb = pmaddr;\\n', '    napot_lb <<= 2;\\n', '    napot_lb &= mask;\\n', '  endfunction: napot_lb\\n', '\\n', '\\n', '  function automatic [PLEN-1:0] napot_ub;\\n', '    input            na4; //special case na4\\n', '    input [XLEN-1:0] pmaddr;\\n', '\\n', '    int n;\\n', '    logic [PLEN-1:0] mask,\\n', '                     range;\\n', '\\n', \"    //find 'n' boundary = 2^(n+2) bytes\\n\", '    n = napot_boundary(na4, pmaddr);\\n', '\\n', '    //create mask and increment\\n', \"    mask = {$bits(mask){1'b1}} << n;\\n\", '    range = 1 << n;\\n', '\\n', '    //upper bound address\\n', '    napot_ub = pmaddr;\\n', '    napot_ub <<= 2;\\n', '    napot_ub &= mask;\\n', '    napot_ub += range;\\n', '  endfunction: napot_ub\\n', '\\n', '\\n', \"  //Is ANY byte of 'access' in pma range?\\n\", '  function automatic match_any;\\n', '    input [PLEN-1:0] access_lb, access_ub,\\n', '                     pma_lb   , pma_ub;\\n', '\\n', '    /* Check if ANY byte of the access lies within the PMA range\\n', '     *   pma_lb <= range < pma_ub\\n', '     * \\n', '     *   match_none = (access_lb >= pma_ub) OR (access_ub < pma_lb)  (1)\\n', '     *   match_any  = !match_none                                    (2)\\n', '     */\\n', \"     match_any = (access_lb[PLEN-1:2] >= pma_ub[PLEN-1:2]) || (access_ub[PLEN-1:2] <  pma_lb[PLEN-1:2]) ? 1'b0 : 1'b1;\\n\", '  endfunction: match_any\\n', '\\n', '\\n', \"  //Are ALL bytes of 'access' in PMA range?\\n\", '  function automatic match_all;\\n', '    input [PLEN-1:0] access_lb, access_ub,\\n', '                     pma_lb   , pma_ub;\\n', '\\n', \"    match_all = (access_lb[PLEN-1:2] >= pma_lb[PLEN-1:2]) && (access_ub[PLEN-1:2] < pma_ub[PLEN-1:2]) ? 1'b1 : 1'b0;\\n\", '  endfunction: match_all\\n', '\\n', '\\n', '  //get highest priority (==lowest number) PMP that matches\\n', '  function automatic int highest_priority_match;\\n', '    input [PMA_CNT-1:0] m;\\n', '\\n', '    int n;\\n', '\\n', '    highest_priority_match = 0; //default value\\n', '\\n', '    for (n=PMA_CNT-1; n >= 0; n--)\\n', '      if (m[n]) highest_priority_match = n;\\n', '  endfunction: highest_priority_match\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  genvar i;\\n', '\\n', '  logic    [PLEN   -1:0] access_ub,\\n', '                         access_lb;\\n', '  logic    [PLEN   -1:0] pma_ub [PMA_CNT],\\n', '                         pma_lb [PMA_CNT];\\n', '  logic    [PMA_CNT-1:0] pma_match,\\n', '                         pma_match_all;\\n', '  int                    matched_pma_idx;\\n', '  pmacfg_t               pmacfg [PMA_CNT],\\n', '                         matched_pma;\\n', '\\n', '  logic                  we;\\n', '  logic                  misaligned;\\n', '\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  /* PMA configurations\\n', '   */\\n', 'generate\\n', '  for (i=0; i < PMA_CNT; i++)\\n', '  begin: set_pmacfg\\n', '      assign pmacfg[i].mem_type = pma_cfg_i[i].mem_type == MEM_TYPE_EMPTY ? MEM_TYPE_IO\\n', '                                                                          : pma_cfg_i[i].mem_type;\\n', '      assign pmacfg[i].amo_type = pma_cfg_i[i].mem_type == MEM_TYPE_EMPTY ? AMO_TYPE_NONE\\n', '                                                                          : pma_cfg_i[i].amo_type;\\n', \"      assign pmacfg[i].r        = pma_cfg_i[i].mem_type == MEM_TYPE_EMPTY ? 1'b0\\n\", '                                                                          : pma_cfg_i[i].r;\\n', \"      assign pmacfg[i].w        = pma_cfg_i[i].mem_type == MEM_TYPE_EMPTY ? 1'b0\\n\", '                                                                          : pma_cfg_i[i].w;\\n', \"      assign pmacfg[i].x        = pma_cfg_i[i].mem_type == MEM_TYPE_EMPTY ? 1'b0\\n\", '                                                                          : pma_cfg_i[i].x;\\n', '      assign pmacfg[i].c        = pma_cfg_i[i].mem_type == MEM_TYPE_MAIN  ? pma_cfg_i[i].c\\n', \"                                                                          : 1'b0;\\n\", '      assign pmacfg[i].cc       = pma_cfg_i[i].cc & pmacfg[i].c;\\n', '      assign pmacfg[i].ri       = pma_cfg_i[i].mem_type == MEM_TYPE_IO    ? pma_cfg_i[i].ri //idempotent read\\n', \"                                                                          : 1'b1;\\n\", '      assign pmacfg[i].wi       = pma_cfg_i[i].mem_type == MEM_TYPE_IO    ? pma_cfg_i[i].wi //idempotent write\\n', \"                                                                          : 1'b1;\\n\", '      assign pmacfg[i].m        = pma_cfg_i[i].m;\\n', '      assign pmacfg[i].a        = pma_cfg_i[i].a;\\n', '  end\\n', 'endgenerate\\n', '\\n', '\\n', '  /* Address Range Matching\\n', '   */\\n', '  assign access_lb = adr_i;\\n', '  assign access_ub = adr_i + size2bytes(size_i) -1;\\n', '\\n', 'generate\\n', '  for (i=0; i < PMA_CNT; i++)\\n', '  begin: gen_pma_bounds\\n', '      //lower bounds\\n', '      always_comb\\n', '        unique case (pmacfg[i].a)\\n', \"          TOR    : pma_lb[i] = (i==0) ? {PLEN{1'b0}} : pma_ub[i-1];\\n\", \"          NA4    : pma_lb[i] = napot_lb(1'b1, pma_adr_i[i]);\\n\", \"          NAPOT  : pma_lb[i] = napot_lb(1'b0, pma_adr_i[i]);\\n\", \"          default: pma_lb[i] = {$bits(pma_lb[i]){1'bx}};\\n\", '        endcase\\n', '\\n', '      //upper bounds\\n', '      always_comb\\n', '        unique case (pmacfg[i].a)\\n', '          TOR    : pma_ub[i] = pma_adr_i[i];\\n', \"          NA4    : pma_ub[i] = napot_ub(1'b1, pma_adr_i[i]);\\n\", \"          NAPOT  : pma_ub[i] = napot_ub(1'b0, pma_adr_i[i]);\\n\", \"          default: pma_ub[i] = {$bits(pma_ub[i]){1'bx}};\\n\", '        endcase\\n', '\\n', '      //match\\n', '      assign pma_match    [i] = match_any(access_lb, access_ub, pma_lb[i], pma_ub[i]) & (pmacfg[i].a != OFF);\\n', '//      assign pma_match_all[i] = match_all(access_lb, access_ub, pma_lb[i], pma_ub[i]) & (pmacfg[i].a != OFF);\\n', '\\n', '      always @(posedge clk_i)\\n', '        if (!stall_i) pma_match_all[i] <= match_all(access_lb, access_ub, pma_lb[i], pma_ub[i]) & (pmacfg[i].a != OFF);\\n', '  end\\n', 'endgenerate\\n', '\\n', '  assign matched_pma_idx = highest_priority_match(pma_match_all);\\n', '  assign matched_pma     = pmacfg[ matched_pma_idx ];\\n', '\\n', '\\n', '  //delay we/misaligned; align with matched_pma\\n', '  always @(posedge clk_i)\\n', '    if (!stall_i)\\n', '      begin\\n', '          we         <= we_i;\\n', '          misaligned <= misaligned_i;\\n', '      end\\n', '\\n', '\\n', '  /* Access/Misaligned Exception\\n', '   */\\n', '  assign exception_o = (~|pma_match_all                   |  // no memory range matched\\n', '                        ( instruction_i & ~matched_pma.x) |  // not executable\\n', '                        ( we            & ~matched_pma.w) |  // not writeable\\n', '                        (~we            & ~matched_pma.r) ); // not readable\\n', '\\n', '\\n', '  assign misaligned_o = misaligned & ~matched_pma.m;\\n', '\\n', '\\n', '  /* Access Types\\n', '   */\\n', '  assign cacheable_o = matched_pma.c; //implies MEM_TYPE_MAIN\\n', 'endmodule\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Physical Memory Protection Checker                           //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2018-2022 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_pmpchk\\n', 'import riscv_state_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter XLEN    = 32,\\n', '  parameter PLEN    = XLEN == 32 ? 34 : 56,\\n', '  parameter PMP_CNT = 16\\n', ')\\n', '(\\n', '  input  logic                     clk_i,\\n', '  input  logic                     stall_i,\\n', '\\n', '  //From State\\n', '  input  pmpcfg_t [15:0]           st_pmpcfg_i,\\n', '  input  logic    [15:0][XLEN-1:0] st_pmpaddr_i,\\n', '  input  logic          [     1:0] st_prv_i,\\n', '\\n', '  //Memory Access\\n', '  input  logic                     instruction_i,   //This is an instruction access\\n', '  input  logic          [PLEN-1:0] adr_i,           //Physical Memory address (i.e. after translation)\\n', '  input  biu_size_t                size_i,          //Transfer size\\n', '  input  logic                     we_i,            //Read/Write enable\\n', '\\n', '  //Output\\n', '  output logic                     exception_o\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Functions\\n', '  //\\n', '\\n', '  //convert transfer size in number of bytes in transfer\\n', '  function automatic int size2bytes;\\n', '    input biu_size_t size;\\n', '\\n', '    case (size)\\n', '      BYTE   : size2bytes =  1;\\n', '      HWORD  : size2bytes =  2;\\n', '      WORD   : size2bytes =  4;\\n', '      DWORD  : size2bytes =  8;\\n', '      QWORD  : size2bytes = 16;\\n', '      default: begin\\n', '                   size2bytes = -1;\\n', '                   $error(\"Illegal biu_size_t\");\\n', '               end\\n', '    endcase\\n', '  endfunction: size2bytes\\n', '\\n', '  //Lower and Upper bounds for NA4/NAPOT\\n', '  function int napot_boundary;\\n', '    input na4; //special case na4\\n', '    input [XLEN-1:0] pmaddr;\\n', '\\n', '    int n;\\n', '    bit true;\\n', '\\n', \"    //find 'n' boundary = 2^(n+2) bytes\\n\", '    n = 2;\\n', '    if (!na4)\\n', '    begin\\n', \"        true = 1'b1;\\n\", '        for (int i=0; (i < $bits(pmaddr)) && true; i++)\\n', '          if (pmaddr[i]) n++;\\n', \"          else           true = 1'b0;\\n\", '\\t \\n', '        n++;\\n', '    end\\n', '\\n', '    return n;\\n', '  endfunction: napot_boundary\\n', '\\n', '\\n', '  function automatic [PLEN-1:0] napot_lb;\\n', '    input            na4; //special case na4\\n', '    input [XLEN-1:0] pmaddr;\\n', '\\n', '    int n;\\n', '    logic [PLEN-1:0] mask;\\n', '\\n', \"    //find 'n' boundary = 2^(n+2) bytes\\n\", '    n = napot_boundary(na4, pmaddr);\\n', '\\n', '    //create mask\\n', \"    mask = {$bits(mask){1'b1}} << n;\\n\", '\\n', '    //lower bound address\\n', '    napot_lb = pmaddr;\\n', '    napot_lb <<= 2;\\n', '    napot_lb &= mask;\\n', '  endfunction: napot_lb\\n', '\\n', '\\n', '  function automatic [PLEN-1:0] napot_ub;\\n', '    input            na4; //special case na4\\n', '    input [XLEN-1:0] pmaddr;\\n', '\\n', '    int n;\\n', '    logic [PLEN-1:0] mask,\\n', '                     range;\\n', '\\n', \"    //find 'n' boundary = 2^(n+2) bytes\\n\", '    n = napot_boundary(na4, pmaddr);\\n', '\\n', '    //create mask and increment\\n', \"    mask = {$bits(mask){1'b1}} << n;\\n\", '    range = 1 << n;\\n', '\\n', '    //upper bound address\\n', '    napot_ub = pmaddr;\\n', '    napot_ub <<= 2;\\n', '    napot_ub &= mask;\\n', '    napot_ub += range;\\n', '  endfunction: napot_ub\\n', '\\n', '\\n', \"  //Is ANY byte of 'access' in pmp range?\\n\", '  function automatic match_any;\\n', '    input [PLEN-1:0] access_lb, access_ub,\\n', '                     pmp_lb   , pmp_ub;\\n', '\\n', '    /* Check if ANY byte of the access lies within the PMP range\\n', '     *   pmp_lb <= range < pmp_ub\\n', '     * \\n', '     *   match_none = (access_lb >= pmp_ub) OR (access_ub < pmp_lb)  (1)\\n', '     *   match_any  = !match_none                                    (2)\\n', '     */\\n', \"     match_any = (access_lb[PLEN-1:2] >= pmp_ub[PLEN-1:2]) || (access_ub[PLEN-1:2] <  pmp_lb[PLEN-1:2]) ? 1'b0 : 1'b1;\\n\", '  endfunction: match_any\\n', '\\n', '\\n', \"  //Are ALL bytes of 'access' in pmp range?\\n\", '  function automatic match_all;\\n', '    input [PLEN-1:0] access_lb, access_ub,\\n', '                     pmp_lb   , pmp_ub;\\n', '\\n', \"    match_all = (access_lb[PLEN-1:2] >= pmp_lb[PLEN-1:2]) && (access_ub[PLEN-1:2] < pmp_ub[PLEN-1:2]) ? 1'b1 : 1'b0;\\n\", '  endfunction: match_all\\n', '\\n', '\\n', '  //get highest priority (==lowest number) PMP that matches\\n', '  function automatic int highest_priority_match;\\n', '    input [PMP_CNT-1:0] m;\\n', '\\n', '    int n;\\n', '\\n', '    for (n=PMP_CNT-1; n >= 0; n--)\\n', '      if (m[n]) highest_priority_match = n;\\n', '  endfunction: highest_priority_match\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  genvar i;\\n', '\\n', '  logic [PLEN   -1:0] access_ub,\\n', '                      access_lb;\\n', '  logic [PLEN   -1:0] pmp_ub [16],\\n', '                      pmp_lb [16];\\n', '  logic [PMP_CNT-1:0] pmp_match,\\n', '                      pmp_match_all;\\n', '  int                 matched_pmp;\\n', '  pmpcfg_t            matched_pmpcfg;\\n', '\\n', '\\n', '  logic               we;\\n', '\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  /*\\n', '   * Address Range Matching\\n', '   * Access Exception\\n', '   * Cacheable\\n', '   */\\n', '  assign access_lb = adr_i;\\n', '  assign access_ub = adr_i + size2bytes(size_i) -1;\\n', '\\n', 'generate\\n', '  for (i=0; i < PMP_CNT; i++)\\n', '  begin: gen_pmp_bounds\\n', '      //lower bounds\\n', '      always_comb\\n', '      case (st_pmpcfg_i[i].a)\\n', \"        TOR    : pmp_lb[i] = (i==0) ? {PLEN{1'b0}} : pmp_ub[i-1];\\n\", \"        NA4    : pmp_lb[i] = napot_lb(1'b1, st_pmpaddr_i[i]);\\n\", \"        NAPOT  : pmp_lb[i] = napot_lb(1'b0, st_pmpaddr_i[i]);\\n\", \"        default: pmp_lb[i] = 'hx;\\n\", '      endcase\\n', '\\n', '      //upper bounds\\n', '      always_comb\\n', '      case (st_pmpcfg_i[i].a)\\n', '        TOR    : pmp_ub[i] = st_pmpaddr_i[i];\\n', \"        NA4    : pmp_ub[i] = napot_ub(1'b1, st_pmpaddr_i[i]);\\n\", \"        NAPOT  : pmp_ub[i] = napot_ub(1'b0, st_pmpaddr_i[i]);\\n\", \"        default: pmp_ub[i] = 'hx;\\n\", '      endcase\\n', '\\n', '      //match-any\\n', '      assign pmp_match    [i] = match_any(access_lb, access_ub, pmp_lb[i], pmp_ub[i]) & (st_pmpcfg_i[i].a != OFF);\\n', '//     assign pmp_match_all[i] = match_all(access_lb, access_ub, pmp_lb[i], pmp_ub[i]);\\n', '\\n', '      always @(posedge clk_i)\\n', '        if (!stall_i) pmp_match_all[i] <= match_all(access_lb, access_ub, pmp_lb[i], pmp_ub[i]);\\n', '  end\\n', 'endgenerate\\n', '\\n', '  //TODO: where to insert register stage\\n', '  //for now pick matched_pmp\\n', '//  assign matched_pmp    = highest_priority_match(pmp_match);\\n', '  always @(posedge clk_i)\\n', '    if (!stall_i) matched_pmp <= highest_priority_match(pmp_match);\\n', '\\n', '  assign matched_pmpcfg = st_pmpcfg_i[ matched_pmp ];\\n', '\\n', '\\n', '  //delay we; same delay as matched_pmpcfg and pmp_match_all;\\n', '  always @(posedge clk_i)\\n', '    if (!stall_i) we <= we_i;\\n', '\\n', '\\n', '  /* Access FAIL when:\\n', '   * 1. some bytes matched highest priority PMP, but not the entire transfer range OR\\n', '   * 2. pmpcfg.l is set AND privilegel level is S or U AND pmpcfg.rwx tests fail OR\\n', '   * 3. privilegel level is S or U AND no PMPs matched AND PMPs are implemented\\n', '   */\\n', '  assign exception_o = (~|pmp_match ? (st_prv_i != PRV_M) & (PMP_CNT > 0)          //Prv.Lvl != M-Mode, no PMP matched, but PMPs implemented -> FAIL\\n', '                                    : ~pmp_match_all[ matched_pmp ]     |\\n', '                                     (\\n', '                                      ((st_prv_i != PRV_M) | matched_pmpcfg.l ) &  //pmpcfg.l set or privilege level != M-mode\\n', '                                      ((~matched_pmpcfg.r & ~we             ) |    // read-access while not allowed          -> FAIL\\n', '                                       (~matched_pmpcfg.w &  we             ) |    // write-access while not allowed         -> FAIL\\n', '                                       (~matched_pmpcfg.x &  instruction_i  ) )    // instruction read, but not instruction  -> FAIL\\n', '                                     )\\n', '                       );\\n', 'endmodule\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Write Buffer                                                 //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2016-2018 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_wbuf #(\\n', '  parameter XLEN  = 32,\\n', '  parameter DEPTH = 8\\n', ')\\n', '(\\n', '  input                    rst_ni,\\n', '  input                    clk_i,\\n', ' \\n', '  //Downstream\\n', '  input                    mem_req_i,\\n', '  input      [XLEN   -1:0] mem_adr_i,\\n', '  input  biu_size_t        mem_size_i,\\n', '  input  biu_type_t        mem_type_i,\\n', '  input                    mem_lock_i,\\n', '  input  biu_prot_t        mem_prot_i,\\n', '  input                    mem_we_i,\\n', '  input      [XLEN   -1:0] mem_d_i,\\n', '  output reg [XLEN   -1:0] mem_q_o,\\n', '  output reg               mem_ack_o,\\n', '                           mem_err_o,\\n', '  input                    cacheflush_i,\\n', '\\n', '\\n', '  //Upstream\\n', '  output                   mem_req_o,     //memory request\\n', '  output     [XLEN   -1:0] mem_adr_o,     //memory address\\n', '  output biu_size_t        mem_size_o,    //transfer size\\n', '  output biu_type_t        mem_type_o,    //burst type\\n', '  output                   mem_lock_o,\\n', '  output biu_prot_t        mem_prot_o,\\n', '  output                   mem_we_o,      //write enable\\n', '  output     [XLEN   -1:0] mem_d_o,       //write data\\n', '  input      [XLEN   -1:0] mem_q_i,       //read data\\n', '  input                    mem_ack_i,\\n', '                           mem_err_i,\\n', '  output                   cacheflush_o\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Constants\\n', '  //\\n', '  localparam FIFO_DEPTH = 2**$clog2(DEPTH);\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Functions\\n', '  //\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Typedefs\\n', '  //\\n', '  typedef struct packed {\\n', '    logic [XLEN  -1:0] addr;\\n', '    logic [XLEN-  1:0] data;\\n', '    biu_size_t         size;\\n', '    biu_type_t         burst_type;\\n', '    logic              lock;\\n', '    biu_prot_t         prot;\\n', '    logic              we;\\n', '    logic              acked;     //already acknowledged?\\n', '    logic              flush;     //forward flush request to cache\\n', '  } fifo_struct;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  integer n;\\n', '\\n', '  /*\\n', '   * Input section\\n', '   */\\n', '  fifo_struct                    fifo_data[FIFO_DEPTH];\\n', '  logic [$clog2(FIFO_DEPTH)-1:0] fifo_wadr;\\n', '  logic                          fifo_we,\\n', '                                 fifo_re,\\n', '                                 fifo_empty,\\n', '                                 fifo_full;\\n', '\\n', '  logic                          we_ack;\\n', '  logic                          mem_we_ack;\\n', '\\n', '  logic                          access_pending;\\n', '  logic                          read_pending;\\n', '  logic                          mem_we_o_dly;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  /*\\n', '   * Memory Access Fifo -- This is the write buffer\\n', '   *\\n', '   * Dont block writes (holds multiple writes)\\n', '   * Block reads (holds 1 read)\\n', '   *\\n', '   * mem_ack immediately when write, upon transfer complete when read\\n', '   */\\n', '\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', \"    if (!rst_ni) fifo_wadr <= 'h0;\\n\", '    else\\n', '      case ({fifo_we,fifo_re})\\n', \"         2'b01  : fifo_wadr <= fifo_wadr -1;\\n\", \"         2'b10  : fifo_wadr <= fifo_wadr +1;\\n\", '         default: ;\\n', '      endcase\\n', '\\n', '\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', '    if (!rst_ni)\\n', \"      for (n=0;n<FIFO_DEPTH;n++) fifo_data[n] <= 'h0;\\n\", '    else\\n', '    case ({fifo_we,fifo_re})\\n', \"       2'b01  : begin\\n\", '                    for (n=0;n<FIFO_DEPTH-1;n++)\\n', '                      fifo_data[n] <= fifo_data[n+1];\\n', '\\n', \"                    fifo_data[FIFO_DEPTH-1] <= 'h0;\\n\", '                end\\n', \"       2'b10  : fifo_data[fifo_wadr] <= {mem_adr_i,\\n\", '                                         mem_d_i,\\n', '                                         mem_size_i,\\n', '                                         mem_type_i,\\n', '                                         mem_lock_i,\\n', '                                         mem_prot_i,\\n', '                                         mem_we_i,\\n', '                                         we_ack,      //locally generated\\n', '                                         cacheflush_i};\\n', \"       2'b11  : begin\\n\", '                    for (n=0;n<FIFO_DEPTH-1;n++)\\n', '                      fifo_data[n] <= fifo_data[n+1];\\n', '\\n', \"                    fifo_data[FIFO_DEPTH-1] <= 'h0;\\n\", '\\n', '                    fifo_data[fifo_wadr-1] <= {mem_adr_i,\\n', '                                               mem_d_i,\\n', '                                               mem_size_i,\\n', '                                               mem_type_i,\\n', '                                               mem_lock_i,\\n', '                                               mem_prot_i,\\n', '                                               mem_we_i,\\n', '                                               we_ack,    //locally generated\\n', '                                               cacheflush_i};\\n', '                end\\n', '       default: ;\\n', '    endcase\\n', '\\n', '\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', \"    if (!rst_ni)  fifo_full <= 1'b0;\\n\", '    else\\n', '      case ({fifo_we,fifo_re})\\n', \"         2'b01  : fifo_full <= 1'b0;\\n\", \"         2'b10  : fifo_full <= &fifo_wadr;\\n\", '         default: ;\\n', '      endcase\\n', '\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', \"    if (!rst_ni)  fifo_empty <= 1'b1;\\n\", '    else\\n', '      case ({fifo_we,fifo_re})\\n', \"         2'b01  : fifo_empty <= ~|fifo_wadr[$clog2(FIFO_DEPTH)-1:1] & fifo_wadr[0]; //--> fifo_wadr == 1\\n\", \"         2'b10  : fifo_empty <= 1'b0;\\n\", '         default: ;\\n', '      endcase\\n', '\\n', '\\n', '  /*\\n', '   * Control signals\\n', '   */\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', \"    if (!rst_ni) read_pending <= 1'b0;\\n\", '    else         read_pending <= (read_pending & ~mem_ack_o) | (mem_req_i & ~mem_we_i);\\n', '\\n', '\\n', '  assign we_ack = mem_req_i & mem_we_i & ~read_pending;\\n', '\\n', '  always @(posedge clk_i)\\n', '    mem_we_ack  <= we_ack;\\n', '\\n', '\\n', '  assign mem_q_o   = mem_q_i; //pass read data through\\n', '\\n', '  assign mem_ack_o = (~fifo_full &  mem_we_ack                          ) |\\n', '                     ( fifo_full &  fifo_re & fifo_data[FIFO_DEPTH-1].we) |\\n', '                     ( mem_ack_i & ~fifo_data[0].acked                  ) ;\\n', '\\n', '\\n', '  /*\\n', '   Write to FIFO when\\n', '   - access pending\\n', '   - pending accesses in FIFO\\n', '   - cacheflush (use FIFO to ensure cache-flush arrives in-order at the cache)\\n', '   otherwise, pass through to cache-section\\n', '   */\\n', '  assign fifo_we = access_pending & ( (mem_req_i & ~(fifo_empty & mem_ack_i)) );\\n', '  assign fifo_re = mem_ack_i & ~fifo_empty;                                     //ACK from cache section\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) access_pending <= 1'b0;\\n\", '    else         access_pending <= mem_req_o | (access_pending & ~mem_ack_i);\\n', '\\n', '\\n', '  assign mem_req_o   = ~access_pending ?  mem_req_i \\n', '                                       : (mem_req_i | ~fifo_empty) & mem_ack_i;\\n', '  assign mem_adr_o    = ~fifo_empty ? fifo_data[0].addr       : mem_adr_i;\\n', '  assign mem_size_o   = ~fifo_empty ? fifo_data[0].size       : mem_size_i;\\n', '  assign mem_type_o   = ~fifo_empty ? fifo_data[0].burst_type : mem_type_i;\\n', '  assign mem_lock_o   = ~fifo_empty ? fifo_data[0].lock       : mem_lock_i;\\n', '  assign mem_prot_o   = ~fifo_empty ? fifo_data[0].prot       : mem_prot_i;\\n', '  assign mem_we_o     = ~fifo_empty ? fifo_data[0].we         : mem_we_i;\\n', '  assign mem_d_o      = ~fifo_empty ? fifo_data[0].data       : mem_d_i;\\n', '\\n', '  assign cacheflush_o = ~fifo_empty ? fifo_data[0].flush      : cacheflush_i;\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', '    if (mem_req_o) mem_we_o_dly <= mem_we_o;\\n', 'endmodule\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Correlating Branch Prediction Unit                           //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2018 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', 'module riscv_bp #(\\n', '  parameter                       XLEN              = 32,\\n', \"  parameter  [XLEN          -1:0] PC_INIT           = 'h200,\\n\", '  parameter                       HAS_BPU           = 0,\\n', '  parameter                       HAS_RVC           = 0,\\n', '\\n', '  parameter                       BP_GLOBAL_BITS    = 2,\\n', '  parameter                       BP_LOCAL_BITS     = 10,\\n', '  parameter                       BP_LOCAL_BITS_LSB = HAS_RVC !=0 ? 1 : 2,\\n', '\\n', '  parameter                       TECHNOLOGY        = \"GENERIC\",\\n', '  parameter                       AVOID_X           = 0\\n', ')\\n', '(\\n', '  input                           rst_ni,\\n', '  input                           clk_i,\\n', ' \\n', '  //Read side\\n', '  input                           id_stall_i,\\n', '  input      [XLEN          -1:0] if_parcel_pc_i,\\n', '  input      [BP_GLOBAL_BITS-1:0] if_parcel_bp_history_i,\\n', '  output reg [               1:0] bp_bp_predict_o,\\n', '\\n', '\\n', '  //Write side\\n', '  input      [XLEN          -1:0] ex_pc_i,\\n', '  input      [BP_GLOBAL_BITS-1:0] bu_bp_history_i,      //branch history\\n', '  input      [               1:0] bu_bp_predict_i,      //prediction bits for branch\\n', '  input                           bu_bp_btaken_i,\\n', '  input                           bu_bp_update_i\\n', ');\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  localparam ADR_BITS     = BP_GLOBAL_BITS + BP_LOCAL_BITS;\\n', '  localparam MEMORY_DEPTH = 1 << ADR_BITS;\\n', '\\n', '  logic [ADR_BITS-1:0] radr,\\n', '                       wadr;\\n', '\\n', '  logic [XLEN    -1:0] if_parcel_pc_dly;\\n', '\\n', '  logic [         1:0] new_prediction;\\n', '  bit   [         1:0] current_prediction;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', '    if      (!rst_ni    ) if_parcel_pc_dly <= PC_INIT;\\n', '    else if (!id_stall_i) if_parcel_pc_dly <= if_parcel_pc_i;\\n', '\\n', '\\n', '  assign radr = id_stall_i ? {if_parcel_bp_history_i, if_parcel_pc_dly[BP_LOCAL_BITS_LSB +: BP_LOCAL_BITS]}\\n', '                           : {if_parcel_bp_history_i, if_parcel_pc_i  [BP_LOCAL_BITS_LSB +: BP_LOCAL_BITS]};\\n', '  assign wadr =              {bu_bp_history_i,        ex_pc_i         [BP_LOCAL_BITS_LSB +: BP_LOCAL_BITS]};\\n', '\\n', '\\n', '  /*\\n', '   *  Calculate new prediction bits\\n', '   *\\n', '   *  00<-->01<-->11<-->10\\n', '   */\\n', '  assign new_prediction[0] = bu_bp_predict_i[1] ^ bu_bp_btaken_i;\\n', '  assign new_prediction[1] = (bu_bp_predict_i[1] & ~bu_bp_predict_i[0]) | (bu_bp_btaken_i & bu_bp_predict_i[0]);\\n', '\\n', '  /*\\n', '   * Hookup 1R1W memory\\n', '   */\\n', '  rl_ram_1r1w #(\\n', '    .ABITS         ( ADR_BITS    ),\\n', '    .DBITS         ( 2           ),\\n', '    .TECHNOLOGY    ( TECHNOLOGY  ),\\n', '    .RW_CONTENTION ( \"DONT_CARE\" ) //it\\'s a prediction anyways ...\\n', '  )\\n', '  bp_ram_inst(\\n', '    .rst_ni  ( rst_ni             ),\\n', '    .clk_i   ( clk_i              ),\\n', ' \\n', '    //Write side\\n', '    .waddr_i ( wadr               ),\\n', '    .din_i   ( new_prediction     ),\\n', '    .we_i    ( bu_bp_update_i     ),\\n', \"    .be_i    ( 1'b1               ),\\n\", '\\n', '    //Read side\\n', '    .raddr_i ( radr               ),\\n', \"    .re_i    ( 1'b1               ),\\n\", '    .dout_o  ( current_prediction )\\n', '  );\\n', '\\n', 'generate\\n', '  //synopsys translate_off\\n', '  if (AVOID_X)\\n', '  begin\\n', '      always @(posedge clk_i)\\n', \"        if (!id_stall_i) bp_bp_predict_o <= (current_prediction == 2'bxx) ? $random : current_prediction;\\n\", '  end\\n', '  else\\n', '  //synopsys translate_on\\n', '  begin\\n', '      always @(posedge clk_i)\\n', '        if (!id_stall_i) bp_bp_predict_o <= current_prediction;\\n', '  end\\n', 'endgenerate\\n', '\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    CPU Core                                                     //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2018 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', 'module riscv_core\\n', 'import riscv_du_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', 'import riscv_opcodes_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter int        XLEN                  = 32,\\n', \"  parameter [XLEN-1:0] PC_INIT               = 'h200,\\n\", '  parameter int        HAS_USER              = 0,\\n', '  parameter int        HAS_SUPER             = 0,\\n', '  parameter int        HAS_HYPER             = 0,\\n', '  parameter int        HAS_BPU               = 1,\\n', '  parameter int        HAS_FPU               = 0,\\n', '  parameter int        HAS_MMU               = 0,\\n', '  parameter int        HAS_RVA               = 0,\\n', '  parameter int        HAS_RVB               = 0,\\n', '  parameter int        HAS_RVC               = 0,\\n', '  parameter int        HAS_RVM               = 0,\\n', '  parameter int        HAS_RVN               = 0,\\n', '  parameter int        HAS_RVP               = 0,\\n', '  parameter int        HAS_RVT               = 0,\\n', '  parameter int        IS_RV32E              = 0,\\n', '\\n', '  parameter int        RF_REGOUT             = 1,\\n', '  parameter int        MULT_LATENCY          = 1,\\n', '\\n', '  parameter int        BREAKPOINTS           = 3,\\n', '  parameter int        PMP_CNT               = 16,\\n', '\\n', '  parameter int        BP_GLOBAL_BITS        = 2,\\n', '  parameter int        BP_LOCAL_BITS         = 10,\\n', '  parameter int        RSB_DEPTH             = 0,\\n', '\\n', '  parameter string     TECHNOLOGY            = \"GENERIC\",\\n', '\\n', \"  parameter [XLEN-1:0] MNMIVEC_DEFAULT       = PC_INIT -'h004,\\n\", \"  parameter [XLEN-1:0] MTVEC_DEFAULT         = PC_INIT -'h040,\\n\", \"  parameter [XLEN-1:0] HTVEC_DEFAULT         = PC_INIT -'h080,\\n\", \"  parameter [XLEN-1:0] STVEC_DEFAULT         = PC_INIT -'h0C0,\\n\", \"  parameter [XLEN-1:0] UTVEC_DEFAULT         = PC_INIT -'h100,\\n\", '\\n', '  parameter int        JEDEC_BANK            = 10,\\n', \"  parameter int        JEDEC_MANUFACTURER_ID = 'h6e,\\n\", '\\n', '  parameter int        HARTID                = 0,\\n', '\\n', '  parameter int        PARCEL_SIZE           = 16,\\n', '  parameter int        MEM_STAGES            = 1    //Minimal 1, causes wb_stall\\n', '                                                    //no data cache: max 2: optimal, no wb_stall\\n', ')\\n', '(\\n', '  input  logic                                 rst_ni,   //Reset\\n', '  input  logic                                 clk_i,    //Clock\\n', '\\n', '  //Instruction Memory Access bus\\n', '  output logic          [XLEN            -1:0] imem_adr_o,\\n', '  output logic                                 imem_req_o,\\n', '  input  logic                                 imem_ack_i,\\n', '  output logic                                 imem_flush_o,\\n', '  input  logic          [XLEN            -1:0] imem_parcel_i,\\n', '  input  logic          [XLEN/PARCEL_SIZE-1:0] imem_parcel_valid_i,\\n', '  input  logic                                 imem_parcel_misaligned_i,\\n', '  input  logic                                 imem_parcel_page_fault_i,\\n', '  input  logic                                 imem_parcel_error_i,\\n', '\\n', '  //Data memory Access  bus\\n', '  output logic          [XLEN            -1:0] dmem_adr_o,\\n', '                                               dmem_d_o,\\n', '  input  logic          [XLEN            -1:0] dmem_q_i,\\n', '  output logic                                 dmem_we_o,\\n', '  output biu_size_t                            dmem_size_o,\\n', '  output logic                                 dmem_lock_o,\\n', '  output logic                                 dmem_req_o,\\n', '  input  logic                                 dmem_ack_i,\\n', '                                               dmem_err_i,\\n', '                                               dmem_misaligned_i,\\n', '                                               dmem_page_fault_i,\\n', '\\n', '  //cpu state\\n', '  output logic          [                 1:0] st_prv_o,\\n', '  output pmpcfg_t       [                15:0] st_pmpcfg_o,\\n', '  output logic [   15:0][XLEN            -1:0] st_pmpaddr_o,\\n', '\\n', '  output logic                                 cm_ic_invalidate_o,\\n', '  output logic                                 cm_dc_invalidate_o,\\n', '  output logic                                 cm_dc_clean_o,\\n', '\\n', '  //Interrupts\\n', '  input  logic                                 int_nmi_i,\\n', '                                               int_timer_i,\\n', '                                               int_software_i,\\n', '  input  logic          [                 3:0] int_external_i,\\n', '\\n', '  //Debug Interface\\n', '  input  logic                                 dbg_stall_i,\\n', '  input  logic                                 dbg_strb_i,\\n', '  input  logic                                 dbg_we_i,\\n', '  input  logic          [DBG_ADDR_SIZE   -1:0] dbg_addr_i,\\n', '  input  logic          [XLEN            -1:0] dbg_dati_i,\\n', '  output logic          [XLEN            -1:0] dbg_dato_o,\\n', '  output logic                                 dbg_ack_o,\\n', '  output logic                                 dbg_bp_o\\n', ');\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  logic [XLEN          -1:0] pd_nxt_pc,\\n', '                             bu_nxt_pc,\\n', '                             st_nxt_pc,\\n', '\\t\\t\\t     if_predict_pc,\\n', '                             if_nxt_pc,\\n', '\\t\\t\\t     if_pc,\\n', '                             pd_pc,\\n', '                             pd_rsb_pc,\\n', '                             id_pc,\\n', '                             id_rsb_pc,\\n', '                             ex_pc,\\n', '                             mem_pc [MEM_STAGES],\\n', '                             wb_pc;\\n', '\\n', '  instruction_t              if_nxt_insn,\\n', '                             if_insn,\\n', '                             pd_insn,\\n', '                             id_insn,\\n', '                             ex_insn,\\n', '                             mem_insn [MEM_STAGES],\\n', '                             wb_insn,\\n', '                             dwb_insn;\\n', '\\n', '  logic                      pd_flush,\\n', '                             bu_flush,\\n', '                             st_flush,\\n', '                             du_flush,\\n', '                             bu_cacheflush;\\n', '\\n', '  logic                      cm_ic_invalidate,\\n', '                             cm_dc_invalidate,\\n', '                             cm_dc_clean,\\n', '                             du_flush_cache;\\n', '\\n', '  logic                      id_stall,\\n', '                             pd_stall,\\n', '                             ex_stall,\\n', '                             mem_stall [MEM_STAGES +1],\\n', '                             wb_stall,\\n', '                             du_stall,\\n', '                             du_stall_if;\\n', '\\n', '  //Branch Prediction\\n', '  logic [               1:0] bp_bp_predict,\\n', '                             pd_bp_predict,\\n', '                             id_bp_predict,\\n', '                             bu_bp_predict;\\n', '\\n', '  logic                      pd_latch_nxt_pc;      //Yes, this is needed.\\n', '\\n', '  logic [BP_GLOBAL_BITS-1:0] bu_bp_history,        //Global BP history from BU\\n', '                             if_predict_history,   //Global history to BP (read)\\n', '                             if_bp_history,        //Global history to PD\\n', '                             pd_bp_history,\\n', '                             id_bp_history,\\n', '                             bu_bp_history_update; //Global history to BP (write)\\n', '  logic                      bu_bp_btaken,\\n', '                             bu_bp_update;\\n', '\\n', '  //Exceptions\\n', '  interrupts_t               st_interrupts;\\n', '  interrupts_exceptions_t    if_exceptions,\\n', '                             pd_exceptions,\\n', '\\t                     id_exceptions,\\n', '\\t\\t\\t     ex_exceptions,\\n', '\\t\\t\\t     mem_exceptions_dn [MEM_STAGES],\\n', '                             mem_exceptions_up [MEM_STAGES +1],\\n', '\\t\\t\\t     wb_exceptions;\\n', '\\n', '  //RF access\\n', '  rsd_t                      pd_rs1, \\n', '                             pd_rs2, \\n', '                             id_rs1,\\n', '                             id_rs2;\\n', '  rsd_t                      rf_src1,\\n', '                             rf_src2;\\n', '  logic [XLEN          -1:0] rf_srcv1,\\n', '                             rf_srcv2;\\n', '\\n', '\\n', '  //ALU signals\\n', '  logic [XLEN          -1:0] id_opA,\\n', '                             id_opB,\\n', '                             ex_r,\\n', '                             mem_r      [MEM_STAGES],\\n', '                             mem_memadr [MEM_STAGES],\\n', '                             wb_r,\\n', '\\t\\t\\t     wb_memq,\\n', '                             dwb_r;\\n', '\\n', '  logic                      id_userf_opA,\\n', '                             id_userf_opB,\\n', '                             id_bypex_opA,\\n', '                             id_bypex_opB;\\n', '\\n', '  //CPU state\\n', '  logic [               1:0] st_xlen;\\n', '  logic                      st_tvm,\\n', '                             st_tw,\\n', '                             st_tsr;\\n', '  logic [XLEN          -1:0] st_mcounteren,\\n', '                             st_scounteren;\\n', '  logic [              11:0] pd_csr_reg,\\n', '\\t                     ex_csr_reg;\\n', '  logic [XLEN          -1:0] ex_csr_wval,\\n', '                             st_csr_rval,\\n', '                             du_csr_rval;\\n', '  logic                      ex_csr_we;\\n', '\\n', '  //Write back\\n', '  rsd_t                      wb_dst;\\n', '  logic [               0:0] wb_we;\\n', '  logic [XLEN          -1:0] wb_badaddr;\\n', '\\n', '  //Debug\\n', '  logic                      du_latch_nxt_pc;\\n', '  logic                      du_re_rf,\\n', '                             du_we_rf,\\n', '                             du_we_frf,\\n', '                             du_re_csr,\\n', '                             du_we_csr,\\n', '                             du_we_pc;\\n', '  logic [DU_ADDR_SIZE  -1:0] du_addr;\\n', '  logic [XLEN          -1:0] du_dato,\\n', '                             du_dati_rf,\\n', '                             du_dati_frf;\\n', '  logic [              31:0] du_ie,\\n', '                             du_exceptions;\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  //cache management\\n', '  //flush = clean + invalidate\\n', '  assign cm_ic_invalidate_o = cm_ic_invalidate | du_flush_cache;\\n', '  assign cm_dc_invalidate_o = cm_dc_invalidate | du_flush_cache;\\n', '  assign cm_dc_clean_o      = cm_dc_clean      | du_flush_cache;\\n', '\\n', '\\n', '  /*\\n', '   * Instruction pipeline\\n', '   * insn (instruction + bubble) and exceptions move down\\n', '   * stalls move up\\n', '   */\\n', '\\n', '  /*\\n', '   * Instruction Fetch\\n', '   *\\n', '   * Calculate next Program Counter\\n', '   * Fetch next instruction\\n', '   */\\n', '  riscv_if #(\\n', '    .XLEN                     ( XLEN                     ),\\n', '    .PC_INIT                  ( PC_INIT                  ),\\n', '    .HAS_RVC                  ( HAS_RVC                  ),\\n', '    .BP_GLOBAL_BITS           ( BP_GLOBAL_BITS           ) )\\n', '  if_unit (\\n', '    .rst_ni                   ( rst_ni                   ),   //Reset\\n', '    .clk_i                    ( clk_i                    ),   //Clock\\n', '\\n', '    //To Instruction Memory\\n', '    .imem_adr_o               ( imem_adr_o               ),   //next Program Counter\\n', '    .imem_req_o               ( imem_req_o               ),   //request new parcel from BIU (cache/bus-interface)\\n', '    .imem_ack_i               ( imem_ack_i               ),   //BIU acknowledge\\n', '    .imem_flush_o             ( imem_flush_o             ),   //flush instruction fetch BIU (cache/bus-interface)\\n', '\\n', '    .imem_parcel_i            ( imem_parcel_i            ),\\n', '    .imem_parcel_valid_i      ( imem_parcel_valid_i      ),\\n', '    .imem_parcel_misaligned_i ( imem_parcel_misaligned_i ),\\n', '    .imem_parcel_page_fault_i ( imem_parcel_page_fault_i ),\\n', '    .imem_parcel_error_i      ( imem_parcel_error_i      ),\\n', '\\n', '    .bu_bp_history_i          ( bu_bp_history            ),\\n', '    .if_predict_history_o     ( if_predict_history       ),\\n', '    .if_bp_history_o          ( if_bp_history            ),\\n', '\\n', '    .if_predict_pc_o          ( if_predict_pc            ),\\n', '    .if_nxt_pc_o              ( if_nxt_pc                ),   //Program Counter for Branch Prediction\\n', '    .if_nxt_insn_o            ( if_nxt_insn              ),\\n', '    .if_pc_o                  ( if_pc                    ),   //Program Counter\\n', '    .if_insn_o                ( if_insn                  ),   //Instruction out\\n', '    .if_exceptions_o          ( if_exceptions            ),   //Exceptions\\n', '    .pd_exceptions_i          ( pd_exceptions            ),\\n', '    .id_exceptions_i          ( id_exceptions            ),\\n', '    .ex_exceptions_i          ( ex_exceptions            ),\\n', '    .mem_exceptions_i         ( mem_exceptions_up[0]     ),\\n', '    .wb_exceptions_i          ( wb_exceptions            ),\\n', '\\n', '    .pd_pc_i                  ( pd_pc                    ),\\n', '    .pd_stall_i               ( pd_stall                 ),\\n', '    .pd_flush_i               ( pd_flush                 ),\\n', '\\n', '    .bu_flush_i               ( bu_flush                 ),   //flush pipe & load new program counter\\n', '    .st_flush_i               ( st_flush                 ),\\n', '    .du_stall_i               ( du_stall_if              ),\\n', '    .du_flush_i               ( du_flush                 ),\\n', '    .du_we_pc_i               ( du_we_pc                 ),\\n', '    .du_dato_i                ( du_dato                  ),\\n', '    .du_latch_nxt_pc_i        ( du_latch_nxt_pc          ),\\n', '    .pd_latch_nxt_pc_i        ( pd_latch_nxt_pc          ),\\n', '    \\n', '    .pd_nxt_pc_i              ( pd_nxt_pc                ),   //Branch Prediction Next Program Counter    \\n', '    .bu_nxt_pc_i              ( bu_nxt_pc                ),   //Branch Unit Next Program Counter\\n', '    .st_nxt_pc_i              ( st_nxt_pc                ),   //State Next Program Counter\\n', '\\n', '    .st_xlen_i                ( st_xlen                  ) );\\n', '\\n', '\\n', '  /*\\n', '   * Pre-Decoder\\n', '   */\\n', '  riscv_pd #(\\n', '    .XLEN              ( XLEN                 ),\\n', '    .PC_INIT           ( PC_INIT              ),\\n', '    .HAS_RVC           ( HAS_RVC              ),\\n', '    .HAS_BPU           ( HAS_BPU              ),\\n', '    .BP_GLOBAL_BITS    ( BP_GLOBAL_BITS       ),\\n', '    .RSB_DEPTH         ( RSB_DEPTH            ) )\\n', '  pd_unit (\\n', '    .rst_ni            ( rst_ni               ),\\n', '    .clk_i             ( clk_i                ),\\n', '    \\n', '    .id_stall_i        ( id_stall             ),\\n', '    .pd_stall_o        ( pd_stall             ),\\n', '    .du_mode_i         ( du_stall_if          ),\\n', '    \\n', '    .bu_flush_i        ( bu_flush             ),\\n', '    .st_flush_i        ( st_flush             ),\\n', '    .pd_flush_o        ( pd_flush             ),\\n', '\\n', '    .pd_rs1_o          ( pd_rs1               ),\\n', '    .pd_rs2_o          ( pd_rs2               ),\\n', '\\n', '    .pd_csr_reg_o      ( pd_csr_reg           ),\\n', '  \\n', '    .if_bp_history_i   ( if_bp_history        ),\\n', '    .pd_bp_history_o   ( pd_bp_history        ),\\n', '    .bp_bp_predict_i   ( bp_bp_predict        ),\\n', '    .pd_bp_predict_o   ( pd_bp_predict        ),\\n', '    .pd_latch_nxt_pc_o ( pd_latch_nxt_pc      ),\\n', '\\n', '    .bu_nxt_pc_i       ( bu_nxt_pc            ),\\n', '    .st_nxt_pc_i       ( st_nxt_pc            ),\\n', '    .pd_nxt_pc_o       ( pd_nxt_pc            ),\\n', '    .pd_rsb_pc_o       ( pd_rsb_pc            ),\\n', '\\n', '    .if_pc_i           ( if_pc                ),\\n', '    .if_insn_i         ( if_insn              ),\\n', '    .id_insn_i         ( id_insn              ),\\n', '\\n', '    .pd_pc_o           ( pd_pc                ),\\n', '    .pd_insn_o         ( pd_insn              ),\\n', '\\n', '    .if_exceptions_i   ( if_exceptions        ),\\n', '    .pd_exceptions_o   ( pd_exceptions        ),\\n', '    .id_exceptions_i   ( id_exceptions        ),\\n', '    .ex_exceptions_i   ( ex_exceptions        ),\\n', '    .mem_exceptions_i  ( mem_exceptions_up[0] ),\\n', '    .wb_exceptions_i   ( wb_exceptions        ) );\\n', ' \\n', '\\n', '  /*\\n', '   * Instruction Decoder\\n', '   *\\n', '   * Data from RF/ROB is available here\\n', '   */\\n', '  riscv_id #(\\n', '    .XLEN             ( XLEN                 ),\\n', '    .PC_INIT          ( PC_INIT              ),\\n', '    .HAS_USER         ( HAS_USER             ),\\n', '    .HAS_SUPER        ( HAS_SUPER            ),\\n', '    .HAS_HYPER        ( HAS_HYPER            ),\\n', '    .HAS_RVA          ( HAS_RVA              ),\\n', '    .HAS_RVM          ( HAS_RVM              ),\\n', '    .HAS_RVC          ( HAS_RVC              ),\\n', '    .MULT_LATENCY     ( MULT_LATENCY         ),\\n', '    .RF_REGOUT        ( RF_REGOUT            ),\\n', '    .BP_GLOBAL_BITS   ( BP_GLOBAL_BITS       ),\\n', '    .RSB_DEPTH        ( RSB_DEPTH            ),\\n', '    .MEM_STAGES       ( MEM_STAGES           ) )\\n', '  id_unit (\\n', '    .rst_ni           ( rst_ni               ),\\n', '    .clk_i            ( clk_i                ),\\n', '\\n', '    .id_stall_o       ( id_stall             ),\\n', '    .ex_stall_i       ( ex_stall             ),\\n', '    .du_stall_i       ( du_stall             ),\\n', '\\n', '    .bu_flush_i       ( bu_flush             ),\\n', '    .st_flush_i       ( st_flush             ),\\n', '    .du_flush_i       ( du_flush             ),\\n', '\\n', '    .bu_nxt_pc_i      ( bu_nxt_pc            ),\\n', '    .if_nxt_pc_i      ( if_nxt_pc            ), \\n', '    .st_nxt_pc_i      ( st_nxt_pc            ),\\n', '\\n', '\\n', '    .pd_pc_i          ( pd_pc                ),\\n', '    .id_pc_o          ( id_pc                ),\\n', '    .pd_rsb_pc_i      ( pd_rsb_pc            ),\\n', '    .id_rsb_pc_o      ( id_rsb_pc            ),\\n', '\\n', '    .pd_bp_history_i  ( pd_bp_history        ),\\n', '    .id_bp_history_o  ( id_bp_history        ),\\n', '    .pd_bp_predict_i  ( pd_bp_predict        ),\\n', '    .id_bp_predict_o  ( id_bp_predict        ),\\n', '\\n', '\\n', '    .pd_insn_i        ( pd_insn              ),\\n', '    .id_insn_o        ( id_insn              ),\\n', '    .ex_insn_i        ( ex_insn              ),\\n', '    .mem_insn_i       ( mem_insn             ),\\n', '    .wb_insn_i        ( wb_insn              ),\\n', '    .dwb_insn_i       ( dwb_insn             ),\\n', '\\n', '    .st_interrupts_i  ( st_interrupts        ),\\n', '    .int_nmi_i        ( int_nmi_i            ),\\n', '    .pd_exceptions_i  ( pd_exceptions        ),\\n', '    .id_exceptions_o  ( id_exceptions        ),\\n', '    .ex_exceptions_i  ( ex_exceptions        ),\\n', '    .mem_exceptions_i ( mem_exceptions_up[0] ),\\n', '    .wb_exceptions_i  ( wb_exceptions        ),\\n', '\\n', '    .st_prv_i         ( st_prv_o             ),\\n', '    .st_xlen_i        ( st_xlen              ),\\n', '    .st_tvm_i         ( st_tvm               ),\\n', '    .st_tw_i          ( st_tw                ),\\n', '    .st_tsr_i         ( st_tsr               ),\\n', '    .st_mcounteren_i  ( st_mcounteren        ),\\n', '    .st_scounteren_i  ( st_scounteren        ),\\n', '\\n', '    .id_rs1_o         ( id_rs1               ),\\n', '    .id_rs2_o         ( id_rs2               ),\\n', '\\n', '    .id_opA_o         ( id_opA               ),\\n', '    .id_opB_o         ( id_opB               ),\\n', '    .id_userf_opA_o   ( id_userf_opA         ),\\n', '    .id_userf_opB_o   ( id_userf_opB         ),\\n', '    .id_bypex_opA_o   ( id_bypex_opA         ),\\n', '    .id_bypex_opB_o   ( id_bypex_opB         ),\\n', '\\n', '    .ex_r_i           ( ex_r                 ),\\n', '    .mem_r_i          ( mem_r                ),\\n', '    .wb_r_i           ( wb_r                 ),\\n', '    .wb_memq_i        ( wb_memq              ),\\n', '    .dwb_r_i          ( dwb_r                ) );\\n', '\\n', '\\n', '  /*\\n', '   * Execution units\\n', '   */\\n', '  riscv_ex #(\\n', '    .XLEN                   ( XLEN                 ),\\n', '    .PC_INIT                ( PC_INIT              ),\\n', '    .HAS_RVC                ( HAS_RVC              ),\\n', '    .HAS_RVA                ( HAS_RVA              ),\\n', '    .HAS_RVM                ( HAS_RVM              ),\\n', '    .MULT_LATENCY           ( MULT_LATENCY         ),\\n', '    .BP_GLOBAL_BITS         ( BP_GLOBAL_BITS       ),\\n', '    .RSB_DEPTH              ( RSB_DEPTH            ) )\\n', '  ex_units (\\n', '    .rst_ni                 ( rst_ni               ),\\n', '    .clk_i                  ( clk_i                ),\\n', '\\n', '    .mem_stall_i            ( mem_stall [0]        ),\\n', '    .ex_stall_o             ( ex_stall             ),\\n', '\\n', '    .id_pc_i                ( id_pc                ),\\n', '    .ex_pc_o                ( ex_pc                ),\\n', '    .bu_nxt_pc_o            ( bu_nxt_pc            ),\\n', '    .bu_flush_o             ( bu_flush             ),\\n', '    .id_rsb_pc_i            ( id_rsb_pc            ),\\n', '\\n', '    //cache management\\n', '    .cm_ic_invalidate_o     ( cm_ic_invalidate     ),\\n', '    .cm_dc_invalidate_o     ( cm_dc_invalidate     ),\\n', '    .cm_dc_clean_o          ( cm_dc_clean          ),\\n', '\\n', '    //branch (prediction)\\n', '    .id_bp_predict_i        ( id_bp_predict        ),\\n', '    .bu_bp_predict_o        ( bu_bp_predict        ),\\n', '    .id_bp_history_i        ( id_bp_history        ),\\n', '    .bu_bp_history_update_o ( bu_bp_history_update ),\\n', '    .bu_bp_history_o        ( bu_bp_history        ),\\n', '    .bu_bp_btaken_o         ( bu_bp_btaken         ),\\n', '    .bu_bp_update_o         ( bu_bp_update         ),\\n', '\\n', '    .id_insn_i              ( id_insn              ),\\n', '    .ex_insn_o              ( ex_insn              ),\\n', '\\n', '    .id_exceptions_i        ( id_exceptions        ),\\n', '    .ex_exceptions_o        ( ex_exceptions        ),\\n', '    .mem_exceptions_i       ( mem_exceptions_up[0] ),\\n', '    .wb_exceptions_i        ( wb_exceptions        ),\\n', '\\n', '    .id_userf_opA_i         ( id_userf_opA         ),\\n', '    .id_userf_opB_i         ( id_userf_opB         ),\\n', '    .id_bypex_opA_i         ( id_bypex_opA         ),\\n', '    .id_bypex_opB_i         ( id_bypex_opB         ),\\n', '    .id_opA_i               ( id_opA               ),\\n', '    .id_opB_i               ( id_opB               ),\\n', '\\n', '    .rf_srcv1_i             ( rf_srcv1             ),\\n', '    .rf_srcv2_i             ( rf_srcv2             ),\\n', '\\n', '    .ex_r_o                 ( ex_r                 ),\\n', '\\n', '    .ex_csr_reg_o           ( ex_csr_reg           ),\\n', '    .ex_csr_wval_o          ( ex_csr_wval          ),\\n', '    .ex_csr_we_o            ( ex_csr_we            ),\\n', '    .st_xlen_i              ( st_xlen              ),\\n', '    .st_flush_i             ( st_flush             ),\\n', '    .st_csr_rval_i          ( st_csr_rval          ),\\n', '\\n', '    .dmem_req_o             ( dmem_req_o           ),\\n', '    .dmem_lock_o            ( dmem_lock_o          ),\\n', '    .dmem_adr_o             ( dmem_adr_o           ),\\n', '    .dmem_size_o            ( dmem_size_o          ),\\n', '    .dmem_we_o              ( dmem_we_o            ),\\n', '    .dmem_d_o               ( dmem_d_o             ),\\n', '    .dmem_q_i               ( dmem_q_i             ),\\n', '    .dmem_ack_i             ( dmem_ack_i           ),\\n', '    .dmem_misaligned_i      ( dmem_misaligned_i    ),\\n', '    .dmem_page_fault_i      ( dmem_page_fault_i    ) );\\n', '\\n', '\\n', '  /*\\n', '   * Memory access\\n', '   */\\n', 'generate\\n', '  genvar n;\\n', '\\n', '  assign mem_stall        [MEM_STAGES] = wb_stall;\\n', '  assign mem_exceptions_up[MEM_STAGES] = wb_exceptions; //exceptions up the pipe\\n', '\\n', '  for (n=0; n < MEM_STAGES; n++)\\n', '    if (n==0)\\n', '    begin\\n', '        riscv_mem #(\\n', '          .XLEN                ( XLEN                   ),\\n', '          .PC_INIT             ( PC_INIT                ) )\\n', '        mem_unit   (\\n', '          .rst_ni              ( rst_ni                 ),\\n', '          .clk_i               ( clk_i                  ),\\n', '\\n', '          .mem_stall_i         ( mem_stall        [n+1] ), //this goes up the pipeline\\n', '          .mem_stall_o         ( mem_stall        [n  ] ),\\n', '\\n', '          .mem_pc_i            ( ex_pc                  ),\\n', '          .mem_pc_o            ( mem_pc           [n  ] ),\\n', '          .mem_insn_i          ( ex_insn                ),\\n', '          .mem_insn_o          ( mem_insn         [n  ] ),\\n', '\\n', '          .mem_exceptions_dn_i ( ex_exceptions          ),\\n', '          .mem_exceptions_dn_o ( mem_exceptions_dn[n  ] ),\\n', '\\t  .mem_exceptions_up_i ( mem_exceptions_up[n+1] ), //this goes up the pipeline\\n', '\\t  .mem_exceptions_up_o ( mem_exceptions_up[n  ] ),\\n', '\\n', '          .mem_r_i             ( ex_r                   ),\\n', '          .mem_r_o             ( mem_r            [n  ] ),\\n', '          .mem_memadr_i        ( dmem_adr_o             ),\\n', '          .mem_memadr_o        ( mem_memadr       [n  ] ) );\\n', '    end\\n', '    else\\n', '    begin\\n', '       riscv_mem #(\\n', '          .XLEN                ( XLEN                   ),\\n', '          .PC_INIT             ( PC_INIT                ) )\\n', '        mem_unit   (\\n', '          .rst_ni              ( rst_ni                 ),\\n', '          .clk_i               ( clk_i                  ),\\n', '\\n', '          .mem_stall_i         ( mem_stall        [n+1] ), //this goes up the pipeline\\n', '          .mem_stall_o         ( mem_stall        [n  ] ),\\n', '\\n', '          .mem_pc_i            ( mem_pc           [n-1] ),\\n', '          .mem_pc_o            ( mem_pc           [n  ] ),\\n', '          .mem_insn_i          ( mem_insn         [n-1] ),\\n', '          .mem_insn_o          ( mem_insn         [n  ] ),\\n', '\\n', '          .mem_exceptions_dn_i ( mem_exceptions_dn[n-1] ),\\n', '          .mem_exceptions_dn_o ( mem_exceptions_dn[n  ] ),\\n', '\\t  .mem_exceptions_up_i ( mem_exceptions_up[n+1] ), //this goes up the pipeline\\n', '\\t  .mem_exceptions_up_o ( mem_exceptions_up[n  ] ),\\n', '\\n', '          .mem_r_i             ( mem_r            [n-1] ),\\n', '          .mem_r_o             ( mem_r            [n  ] ),\\n', '          .mem_memadr_i        ( mem_memadr       [n-1] ),\\n', '          .mem_memadr_o        ( mem_memadr       [n  ] ) );\\n', '    end\\n', 'endgenerate\\n', '\\n', '\\n', '  /*\\n', '   * Memory acknowledge + Write Back unit\\n', '   */\\n', '  riscv_wb #(\\n', '    .XLEN              ( XLEN                             ),\\n', '    .PC_INIT           ( PC_INIT                          ) )\\n', '  wb_unit   (\\n', '    .rst_ni            ( rst_ni                           ),\\n', '    .clk_i             ( clk_i                            ),\\n', '    .mem_pc_i          ( mem_pc           [MEM_STAGES -1] ),\\n', '    .mem_insn_i        ( mem_insn         [MEM_STAGES -1] ),\\n', '    .mem_r_i           ( mem_r            [MEM_STAGES -1] ),\\n', '    .mem_exceptions_i  ( mem_exceptions_dn[MEM_STAGES -1] ),\\n', '    .mem_memadr_i      ( mem_memadr       [MEM_STAGES -1] ),\\n', '    .wb_pc_o           ( wb_pc                            ),\\n', '    .wb_stall_o        ( wb_stall                         ),\\n', '    .wb_insn_o         ( wb_insn                          ),\\n', '    .wb_exceptions_o   ( wb_exceptions                    ),\\n', '    .wb_badaddr_o      ( wb_badaddr                       ),\\n', '    .dmem_ack_i        ( dmem_ack_i                       ),\\n', '    .dmem_q_i          ( dmem_q_i                         ),\\n', '    .dmem_misaligned_i ( dmem_misaligned_i                ),\\n', '    .dmem_page_fault_i ( dmem_page_fault_i                ),\\n', '    .dmem_err_i        ( dmem_err_i                       ),\\n', '    .wb_dst_o          ( wb_dst                           ),\\n', '    .wb_r_o            ( wb_r                             ),\\n', '    .wb_memq_o         ( wb_memq                          ),\\n', '    .wb_we_o           ( wb_we                            ) );\\n', '\\n', '\\n', '  /*\\n', '  * Additional stage for RF_REGOUT=1\\n', '  * Simply delays WB outputs purely for bypass purposes\\n', '  */\\n', '  riscv_dwb #(\\n', '    .XLEN       ( XLEN       ),\\n', '    .PC_INIT    ( PC_INIT    ) )\\n', '  dwb_unit (\\n', '    .rst_ni     ( rst_ni     ),\\n', '    .clk_i      ( clk_i      ),\\n', '    .wb_insn_i  ( wb_insn    ),\\n', '    .wb_we_i    ( wb_we      ),\\n', '    .wb_r_i     ( wb_r       ),\\n', '    .dwb_insn_o ( dwb_insn   ),\\n', '    .dwb_r_o    ( dwb_r      ) );\\n', '\\n', '\\n', '  /*\\n', '   * Thread state\\n', '   */\\n', '  riscv_state1_10 #(\\n', '    .XLEN                  ( XLEN                  ),\\n', '    .PC_INIT               ( PC_INIT               ),\\n', '    .IS_RV32E              ( IS_RV32E              ),\\n', '\\n', '    .HAS_RVA               ( HAS_RVA               ),\\n', '    .HAS_RVB               ( HAS_RVB               ),\\n', '    .HAS_RVC               ( HAS_RVC               ),\\n', '    .HAS_FPU               ( HAS_FPU               ),\\n', '    .HAS_MMU               ( HAS_MMU               ),\\n', '    .HAS_RVN               ( HAS_RVN               ),\\n', '    .HAS_RVP               ( HAS_RVP               ),\\n', '    .HAS_RVT               ( HAS_RVT               ),\\n', '    .HAS_USER              ( HAS_USER              ),\\n', '    .HAS_SUPER             ( HAS_SUPER             ),\\n', '    .HAS_HYPER             ( HAS_HYPER             ),\\n', '\\n', '    .MNMIVEC_DEFAULT       ( MNMIVEC_DEFAULT       ),\\n', '    .MTVEC_DEFAULT         ( MTVEC_DEFAULT         ),\\n', '    .HTVEC_DEFAULT         ( HTVEC_DEFAULT         ),\\n', '    .STVEC_DEFAULT         ( STVEC_DEFAULT         ),\\n', '    .UTVEC_DEFAULT         ( UTVEC_DEFAULT         ),\\n', '\\n', '    .JEDEC_BANK            ( JEDEC_BANK            ),\\n', '    .JEDEC_MANUFACTURER_ID ( JEDEC_MANUFACTURER_ID ),\\n', '\\n', '    .PMP_CNT               ( PMP_CNT               ),\\n', '    .HARTID                ( HARTID                ) )\\n', '  cpu_state    (\\n', '    .rst_ni          ( rst_ni          ),\\n', '    .clk_i           ( clk_i           ),\\n', '\\n', '    .id_pc_i         ( id_pc           ),\\n', '    .id_insn_i       ( id_insn         ),\\n', '\\n', '    .bu_flush_i      ( bu_flush        ),\\n', '    .bu_nxt_pc_i     ( bu_nxt_pc       ),\\n', '    .st_flush_o      ( st_flush        ),\\n', '    .st_nxt_pc_o     ( st_nxt_pc       ),\\n', '\\n', '    .wb_pc_i         ( wb_pc           ),\\n', '    .wb_insn_i       ( wb_insn         ),\\n', '    .wb_exceptions_i ( wb_exceptions   ),\\n', '    .wb_badaddr_i    ( wb_badaddr      ),\\n', '\\n', '    .st_prv_o        ( st_prv_o        ),\\n', '    .st_xlen_o       ( st_xlen         ),\\n', '    .st_tvm_o        ( st_tvm          ),\\n', '    .st_tw_o         ( st_tw           ),\\n', '    .st_tsr_o        ( st_tsr          ),\\n', '    .st_mcounteren_o ( st_mcounteren   ),\\n', '    .st_scounteren_o ( st_scounteren   ),\\n', '    .st_pmpcfg_o     ( st_pmpcfg_o     ),\\n', '    .st_pmpaddr_o    ( st_pmpaddr_o    ),\\n', '\\n', '    .int_external_i  ( int_external_i  ),\\n', '    .int_timer_i     ( int_timer_i     ),\\n', '    .int_software_i  ( int_software_i  ),\\n', '    .st_int_o        ( st_interrupts   ),\\n', '\\n', '    .pd_stall_i      ( pd_stall        ),\\n', '    .id_stall_i      ( id_stall        ),\\n', '    .pd_csr_reg_i    ( pd_csr_reg      ),\\n', '    .ex_csr_reg_i    ( ex_csr_reg      ),\\n', '    .ex_csr_we_i     ( ex_csr_we       ),\\n', '    .ex_csr_wval_i   ( ex_csr_wval     ),\\n', '    .st_csr_rval_o   ( st_csr_rval     ),\\n', '\\n', '    .du_stall_i      ( du_stall        ),\\n', '    .du_flush_i      ( du_flush        ),\\n', '    .du_re_csr_i     ( du_re_csr       ),\\n', '    .du_we_csr_i     ( du_we_csr       ),\\n', '    .du_csr_rval_o   ( du_csr_rval     ),\\n', '    .du_dato_i       ( du_dato         ),\\n', '    .du_addr_i       ( du_addr         ),\\n', '    .du_ie_i         ( du_ie           ),\\n', '    .du_exceptions_o ( du_exceptions   ) );\\n', '\\n', '\\n', '  /*\\n', '   *  Integer Register File\\n', '   */\\n', '  assign rf_src1 = (RF_REGOUT > 0) ? pd_rs1 : id_rs1;\\n', '  assign rf_src2 = (RF_REGOUT > 0) ? pd_rs2 : id_rs2;\\n', '\\n', '  riscv_rf #(\\n', '    .XLEN        ( XLEN       ),\\n', '    .REGOUT      ( RF_REGOUT  ) )\\n', '  int_rf (\\n', '    .rst_ni      ( rst_ni     ),\\n', '    .clk_i       ( clk_i      ),\\n', '\\n', '    .rf_src1_i   ( rf_src1    ),\\n', '    .rf_src2_i   ( rf_src2    ),\\n', '    .rf_src1_q_o ( rf_srcv1   ),\\n', '    .rf_src2_q_o ( rf_srcv2   ),\\n', '\\n', '    .rf_dst_i    ( wb_dst     ),\\n', '    .rf_dst_d_i  ( wb_r       ),\\n', '    .rf_we_i     ( wb_we      ),\\n', '    .pd_stall_i  ( pd_stall   ),\\n', '    .id_stall_i  ( id_stall   ),\\n', '\\n', '    .du_re_rf_i  ( du_re_rf   ),\\n', '    .du_we_rf_i  ( du_we_rf   ),\\n', '    .du_d_i      ( du_dato    ),\\n', '    .du_rf_q_o   ( du_dati_rf ),\\n', '    .du_addr_i   ( du_addr    ) );\\n', '\\n', '\\n', '  /*\\n', '   * Branch Prediction Unit\\n', '   *\\n', '   * Get Branch Prediction for Next Program Counter\\n', '   */\\n', 'generate\\n', '  if (HAS_BPU == 0)\\n', '  begin\\n', \"      assign bp_bp_predict = 2'b00;\\n\", '  end\\n', '  else\\n', '    riscv_bp #(\\n', '      .XLEN                   ( XLEN                 ),\\n', '      .PC_INIT                ( PC_INIT              ),\\n', '      .HAS_RVC                ( HAS_RVC              ),\\n', '      .BP_GLOBAL_BITS         ( BP_GLOBAL_BITS       ),\\n', '      .BP_LOCAL_BITS          ( BP_LOCAL_BITS        ),\\n', '      .BP_LOCAL_BITS_LSB      ( 2                    ), \\n', '      .TECHNOLOGY             ( TECHNOLOGY           ) )\\n', '    bp_unit(\\n', '      .rst_ni                 ( rst_ni               ),\\n', '      .clk_i                  ( clk_i                ),\\n', '\\n', '      //read branch prediciton\\n', '      .id_stall_i             ( id_stall             ),\\n', '      .if_parcel_bp_history_i ( if_predict_history   ),\\n', '      .if_parcel_pc_i         ( if_predict_pc        ),\\n', '      .bp_bp_predict_o        ( bp_bp_predict        ),\\n', '\\n', '      //update branch prediction\\n', '      .ex_pc_i                ( ex_pc                ),\\n', '      .bu_bp_history_i        ( bu_bp_history_update ),\\n', '      .bu_bp_predict_i        ( bu_bp_predict        ),\\n', '      .bu_bp_btaken_i         ( bu_bp_btaken         ),\\n', '      .bu_bp_update_i         ( bu_bp_update         ) );\\n', 'endgenerate\\n', '\\n', '\\n', '  /*\\n', '   * Debug Unit\\n', '   */\\n', '  riscv_du #(\\n', '    .XLEN              ( XLEN                            ),\\n', '    .BREAKPOINTS       ( BREAKPOINTS                     ) )\\n', '  du_unit (\\n', '    .rst_ni            ( rst_ni                          ),\\n', '    .clk_i             ( clk_i                           ),\\n', '\\n', '    .dbg_stall_i       ( dbg_stall_i                     ),\\n', '    .dbg_strb_i        ( dbg_strb_i                      ),\\n', '    .dbg_we_i          ( dbg_we_i                        ),\\n', '    .dbg_addr_i        ( dbg_addr_i                      ),\\n', '    .dbg_d_i           ( dbg_dati_i                      ),\\n', '    .dbg_q_o           ( dbg_dato_o                      ),\\n', '    .dbg_ack_o         ( dbg_ack_o                       ),\\n', '    .dbg_bp_o          ( dbg_bp_o                        ),\\n', '\\n', '    .du_dbg_mode_o     (),  \\n', '    .du_stall_o        ( du_stall                        ),\\n', '    .du_stall_if_o     ( du_stall_if                     ),\\n', '\\n', '    .du_latch_nxt_pc_o ( du_latch_nxt_pc                 ),\\n', '    .du_flush_o        ( du_flush                        ),\\n', '    .du_flush_cache_o  ( du_flush_cache                  ),\\n', '    .du_re_rf_o        ( du_re_rf                        ),\\n', '    .du_we_rf_o        ( du_we_rf                        ),\\n', '    .du_we_frf_o       ( du_we_frf                       ),\\n', '    .du_re_csr_o       ( du_re_csr                       ),\\n', '    .du_we_csr_o       ( du_we_csr                       ),\\n', '    .du_we_pc_o        ( du_we_pc                        ),\\n', '    .du_addr_o         ( du_addr                         ),\\n', '    .du_d_o            ( du_dato                         ),\\n', '    .du_ie_o           ( du_ie                           ),\\n', '    .du_rf_q_i         ( du_dati_rf                      ),\\n', \"    .du_frf_q_i        ( {XLEN{1'b0}}                    ), //du_dati_frf     ),\\n\", '    .st_csr_q_i        ( du_csr_rval                     ),\\n', '    .if_nxt_pc_i       ( if_nxt_pc                       ),\\n', '    .bu_nxt_pc_i       ( bu_nxt_pc                       ),\\n', '    .if_pc_i           ( if_pc                           ),\\n', '    .pd_pc_i           ( pd_pc                           ),\\n', '    .id_pc_i           ( id_pc                           ),\\n', '    .ex_pc_i           ( ex_pc                           ),\\n', '    .wb_pc_i           ( wb_pc                           ),\\n', '    .bu_flush_i        ( bu_flush                        ),\\n', '    .st_flush_i        ( st_flush                        ),\\n', '\\n', '    .if_nxt_insn_i     ( if_nxt_insn                     ),\\n', '    .if_insn_i         ( if_insn                         ),\\n', '    .pd_insn_i         ( pd_insn                         ),\\n', '    .mem_insn_i        ( mem_insn         [MEM_STAGES-1] ),\\n', '    .mem_exceptions_i  ( mem_exceptions_dn[MEM_STAGES-1] ),\\n', '    .mem_memadr_i      ( mem_memadr       [MEM_STAGES-1] ),\\n', '    .wb_insn_i         ( wb_insn                         ),\\n', '    .dmem_ack_i        ( dmem_ack_i                      ),\\n', '    .ex_stall_i        ( ex_stall                        ),\\n', '\\n', '    .du_exceptions_i   ( du_exceptions                   ) );\\n', '\\n', 'endmodule\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Debug Unit                                                   //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_du\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', 'import riscv_du_pkg::*;\\n', '#(\\n', '  parameter XLEN           = 32,\\n', '  parameter BREAKPOINTS    = 3\\n', ')\\n', '(\\n', '  input                           rst_ni,\\n', '  input                           clk_i,\\n', '\\n', '   \\n', '  //Debug Port interface\\n', '  input                           dbg_stall_i,\\n', '  input                           dbg_strb_i,\\n', '  input                           dbg_we_i,\\n', '  input      [DBG_ADDR_SIZE -1:0] dbg_addr_i,\\n', '  input      [XLEN          -1:0] dbg_d_i,\\n', '  output reg [XLEN          -1:0] dbg_q_o,\\n', '  output reg                      dbg_ack_o,\\n', '  output reg                      dbg_bp_o,\\n', '  \\n', '\\n', '  //CPU signals\\n', '  output                          du_dbg_mode_o,\\n', '  output                          du_stall_o,\\n', '                                  du_stall_if_o,\\n', '\\n', '  output                          du_latch_nxt_pc_o,\\n', '  output                          du_flush_o,\\n', '  output                          du_flush_cache_o,\\n', '  output reg                      du_we_rf_o,\\n', '  output reg                      du_re_rf_o,\\n', '  output reg                      du_we_frf_o,\\n', '  output reg                      du_we_csr_o,\\n', '  output reg                      du_re_csr_o,\\n', '  output reg                      du_we_pc_o,\\n', '  output reg [DU_ADDR_SIZE  -1:0] du_addr_o,\\n', '  output reg [XLEN          -1:0] du_d_o,\\n', '  output     [              31:0] du_ie_o,\\n', '  input      [XLEN          -1:0] du_rf_q_i,\\n', '                                  du_frf_q_i,\\n', '                                  st_csr_q_i,\\n', '                                  if_nxt_pc_i,\\n', '                                  bu_nxt_pc_i,\\n', '                                  if_pc_i,\\n', '                                  pd_pc_i,\\n', '                                  id_pc_i,\\n', '                                  ex_pc_i,\\n', '                                  wb_pc_i,\\n', '  input                           bu_flush_i,\\n', '                                  st_flush_i,\\n', '\\n', '  input  instruction_t            if_nxt_insn_i,\\n', '                                  if_insn_i,\\n', '                                  pd_insn_i,\\n', '                                  mem_insn_i,\\n', \"                                  wb_insn_i, //only for 'dbg' signal\\n\", '\\n', '  input  interrupts_exceptions_t  mem_exceptions_i,\\n', '  input      [XLEN          -1:0] mem_memadr_i,\\n', '  input                           dmem_ack_i,\\n', '                                  ex_stall_i,\\n', '  //From state\\n', '  input      [              31:0] du_exceptions_i\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Constants\\n', '  //\\n', '\\n', '  typedef struct packed {\\n', '    logic       branch_break_ena; //each branch causes a switch to the debug environment\\n', '    logic       instr_break_ena;  //each executed instruction causes a switch to the debug environment (=single step)\\n', '  } dbg_ctrl_struct;\\n', '\\n', '  typedef struct packed {\\n', '    logic [MAX_BREAKPOINTS-1:0] bp_hit;           //15:8\\n', '    logic                       branch_break_hit; //1\\n', '    logic                       instr_break_hit;  //0\\n', '  } dbg_hit_struct;\\n', '\\n', '  typedef struct packed {\\n', '    logic [     2:0] cc;          //6:4\\n', '    logic            enabled;     //1\\n', '    logic            implemented; //0\\n', '  } bp_ctrl_struct;\\n', '\\n', '  typedef struct packed {\\n', '    bp_ctrl_struct   ctrl;\\n', '    logic [XLEN-1:0] data;\\n', '  } bp_struct;\\n', '\\n', '  typedef struct packed {\\n', '    dbg_ctrl_struct  ctrl;\\n', '    logic     [               31:0] ie;\\n', '    logic     [XLEN           -1:0] cause;\\n', '    dbg_hit_struct                  hit;\\n', '    bp_struct [MAX_BREAKPOINTS-1:0] bp;\\n', '  } dbg_struct;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  logic                                dbg_strb_i_dly,\\n', '                                       du_stall_dly,\\n', '                                       wb_dbg_dly;\\n', '\\t\\t\\t\\t       \\n', '  logic [DBG_ADDR_SIZE-1:DU_ADDR_SIZE] du_bank_addr;\\n', '  logic                                du_sel_internal,\\n', '                                       du_sel_gprs,\\n', '                                       du_sel_csrs;\\n', '  logic [                         4:0] du_re_csrs;\\n', '\\n', '  logic                                du_access,\\n', '                                       du_we;\\n', '  logic [                         2:0] du_ack;\\n', '\\n', '  logic                                du_we_internal;\\n', '  logic [XLEN                    -1:0] du_internal_regs;\\n', '\\n', '  dbg_struct                           dbg;\\n', '  logic                                bp_instr_hit,\\n', '                                       bp_branch_hit;\\n', '  logic [MAX_BREAKPOINTS         -1:0] bp_hit;\\n', '\\n', '  logic                                mem_read,\\n', '                                       mem_write;\\n', '\\n', '\\n', '  logic [XLEN                    -1:0] dpc; //debug program counter\\n', '\\n', '\\n', '  genvar n;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '  import riscv_state_pkg::*;\\n', '\\n', '  /*\\n', '   * Debugger Interface\\n', '   */\\n', '  // Decode incoming address\\n', '  assign du_bank_addr    = dbg_addr_i[DBG_ADDR_SIZE-1:DU_ADDR_SIZE];\\n', '  assign du_sel_internal = du_bank_addr == DBG_INTERNAL;\\n', '  assign du_sel_gprs     = du_bank_addr == DBG_GPRS;\\n', '  assign du_sel_csrs     = du_bank_addr == DBG_CSRS;\\n', '\\n', '\\n', '  //generate 1 cycle pulse strobe\\n', '  always @(posedge clk_i)\\n', '    dbg_strb_i_dly <= dbg_strb_i;\\n', '\\n', '\\n', '  //generate (write) access signals\\n', '  assign du_access = (dbg_strb_i & dbg_stall_i) | (dbg_strb_i & du_sel_internal);\\n', '  assign du_we     = du_access & ~dbg_strb_i_dly & dbg_we_i;\\n', '\\n', '\\n', '  // generate ACK\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', \"    if      (!rst_ni    ) du_ack <= 'h0;\\n\", \"    else if (!ex_stall_i) du_ack <= {3{du_access & ~dbg_ack_o}} & {1'b1,du_ack[2:1]};\\n\", '\\n', '  assign dbg_ack_o = du_ack[0];\\n', '\\n', '\\n', '  //actual BreakPoint signal\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', \"    if (!rst_ni) dbg_bp_o <= 'b0;\\n\", '    else         dbg_bp_o <= ~ex_stall_i & ~du_flush_o & ~st_flush_i & (|du_exceptions_i | |dbg.hit);\\n', '\\n', '\\n', '  /*\\n', '   * CPU Interface\\n', '   */\\n', '  // assign CPU signals\\n', '  assign du_stall_o    = dbg_stall_i;\\n', '  assign du_stall_if_o = dbg_stall_i | (|dbg.hit);\\n', '  \\n', '\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', \"    if (!rst_ni) du_stall_dly <= 1'b0;\\n\", '    else         du_stall_dly <= dbg_stall_i;\\n', '\\n', '\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', \"    if (!rst_ni) wb_dbg_dly <= 1'b0;\\n\", '    else         wb_dbg_dly <= wb_insn_i.dbg;\\n', '\\n', '\\n', '  assign du_latch_nxt_pc_o =  dbg_stall_i   & ~du_stall_dly; //Latch nxt-pc address while entering debug\\n', '  assign du_flush_cache_o  =  wb_insn_i.dbg & ~wb_dbg_dly;   //flush cache when stall exits CPU pipeline (i.e. all pending instructions executed)\\n', '  assign du_flush_o        = ~dbg_stall_i   &  du_stall_dly; // & |du_exceptions_i; //flush upon debug exit. Maybe program memory contents changed\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', '  begin\\n', '      du_addr_o      <=  dbg_addr_i[DU_ADDR_SIZE-1:0];\\n', '      du_d_o         <=  dbg_d_i;\\n', '\\n', \"      du_we_rf_o     <=  du_we & du_sel_gprs & (dbg_addr_i[11:8] == 4'h0); //(dbg_addr_i[DU_ADDR_SIZE-1:0] == DBG_GPR);\\n\", \"      du_we_frf_o    <=  du_we & du_sel_gprs & (dbg_addr_i[11:8] == 4'h1); //(dbg_addr_i[DU_ADDR_SIZE-1:0] == DBG_FPR);\\n\", '      du_we_internal <=  du_we & du_sel_internal;\\n', '      du_we_csr_o    <=  du_we & du_sel_csrs;\\n', '      du_we_pc_o     <=  du_we & du_sel_gprs & (dbg_addr_i[DU_ADDR_SIZE-1:0] == DBG_NPC);\\n', '  end\\n', '\\n', '  assign du_re_csr_o = dbg_strb_i & du_sel_csrs;\\n', \"  assign du_re_rf_o  = dbg_strb_i & du_sel_gprs & (dbg_addr_i[11:8] == 4'h0);\\n\", '  \\n', '\\n', '  // Return signals\\n', '\\n', '  always_comb\\n', '    case (du_addr_o)\\n', \"      DBG_CTRL   : du_internal_regs = { {XLEN- 2{1'b0}}, dbg.ctrl };\\n\", \"      DBG_HIT    : du_internal_regs = { {XLEN-16{1'b0}}, dbg.hit.bp_hit, 6'h0, dbg.hit.branch_break_hit, dbg.hit.instr_break_hit};\\n\", \"      DBG_IE     : du_internal_regs = { {XLEN-32{1'b0}}, dbg.ie};\\n\", \"      DBG_CAUSE  : du_internal_regs = { {XLEN-32{1'b0}}, dbg.cause};\\n\", '\\n', \"      DBG_BPCTRL0: du_internal_regs = { {XLEN- 7{1'b0}}, dbg.bp[0].ctrl.cc, 2'h0, dbg.bp[0].ctrl.enabled, dbg.bp[0].ctrl.implemented};\\n\", '      DBG_BPDATA0: du_internal_regs = dbg.bp[0].data;\\n', '\\n', \"      DBG_BPCTRL1: du_internal_regs = { {XLEN- 7{1'b0}}, dbg.bp[1].ctrl.cc, 2'h0, dbg.bp[1].ctrl.enabled, dbg.bp[1].ctrl.implemented};\\n\", '      DBG_BPDATA1: du_internal_regs = dbg.bp[1].data;\\n', '\\n', \"      DBG_BPCTRL2: du_internal_regs = { {XLEN- 7{1'b0}}, dbg.bp[2].ctrl.cc, 2'h0, dbg.bp[2].ctrl.enabled, dbg.bp[2].ctrl.implemented};\\n\", '      DBG_BPDATA2: du_internal_regs = dbg.bp[2].data;\\n', '\\n', \"      DBG_BPCTRL3: du_internal_regs = { {XLEN- 7{1'b0}}, dbg.bp[3].ctrl.cc, 2'h0, dbg.bp[3].ctrl.enabled, dbg.bp[3].ctrl.implemented};\\n\", '      DBG_BPDATA3: du_internal_regs = dbg.bp[3].data;\\n', '\\n', \"      DBG_BPCTRL4: du_internal_regs = { {XLEN- 7{1'b0}}, dbg.bp[4].ctrl.cc, 2'h0, dbg.bp[4].ctrl.enabled, dbg.bp[4].ctrl.implemented};\\n\", '      DBG_BPDATA4: du_internal_regs = dbg.bp[4].data;\\n', '\\n', \"      DBG_BPCTRL5: du_internal_regs = { {XLEN- 7{1'b0}}, dbg.bp[5].ctrl.cc, 2'h0, dbg.bp[5].ctrl.enabled, dbg.bp[5].ctrl.implemented};\\n\", '      DBG_BPDATA5: du_internal_regs = dbg.bp[5].data;\\n', '\\n', \"      DBG_BPCTRL6: du_internal_regs = { {XLEN- 7{1'b0}}, dbg.bp[6].ctrl.cc, 2'h0, dbg.bp[6].ctrl.enabled, dbg.bp[6].ctrl.implemented};\\n\", '      DBG_BPDATA6: du_internal_regs = dbg.bp[6].data;\\n', '\\n', \"      DBG_BPCTRL7: du_internal_regs = { {XLEN- 7{1'b0}}, dbg.bp[7].ctrl.cc, 2'h0, dbg.bp[7].ctrl.enabled, dbg.bp[7].ctrl.implemented};\\n\", '      DBG_BPDATA7: du_internal_regs = dbg.bp[7].data;\\n', '\\n', \"      default    : du_internal_regs = 'h0;\\n\", '    endcase\\n', '\\n', '  always @(posedge clk_i)\\n', '    casex (dbg_addr_i)\\n', \"       {DBG_INTERNAL,12'h???}: dbg_q_o <= du_internal_regs;\\n\", '       {DBG_GPRS    ,DBG_GPR}: dbg_q_o <= du_rf_q_i;\\n', '       {DBG_GPRS    ,DBG_FPR}: dbg_q_o <= du_frf_q_i;\\n', '       {DBG_GPRS    ,DBG_NPC}: dbg_q_o <= if_nxt_pc_i;\\n', '       {DBG_GPRS    ,DBG_PPC}: dbg_q_o <= dpc;\\n', \"       {DBG_CSRS    ,12'h???}: dbg_q_o <= st_csr_q_i;\\n\", \"       default               : dbg_q_o <= 'h0;\\n\", '    endcase\\n', '\\n', '\\n', '  /*\\n', '   * Registers\\n', '   */\\n', '\\n', '  //DBG CTRL\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', '    if (!rst_ni)\\n', '    begin\\n', \"        dbg.ctrl.instr_break_ena  <= 1'b0;\\n\", \"        dbg.ctrl.branch_break_ena <= 1'b0;\\n\", '    end\\n', '    else if (du_we_internal && du_addr_o == DBG_CTRL)\\n', '    begin\\n', '        dbg.ctrl.instr_break_ena  <= du_d_o[0];\\n', '        dbg.ctrl.branch_break_ena <= du_d_o[1];\\n', '    end\\n', '\\n', '\\n', '  //DBG HIT\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', '    if (!rst_ni)\\n', '    begin\\n', \"        dbg.hit.instr_break_hit  <= 1'b0;\\n\", \"        dbg.hit.branch_break_hit <= 1'b0;\\n\", '    end\\n', '    else if (du_we_internal && du_addr_o == DBG_HIT)\\n', '    begin\\n', '        dbg.hit.instr_break_hit  <= du_d_o[0];\\n', '        dbg.hit.branch_break_hit <= du_d_o[1];\\n', '    end\\n', '    else\\n', '    begin\\n', \"        if (bp_instr_hit ) dbg.hit.instr_break_hit  <= 1'b1;\\n\", \"        if (bp_branch_hit) dbg.hit.branch_break_hit <= 1'b1;\\n\", '    end\\n', '\\n', 'generate\\n', 'for (n=0; n<MAX_BREAKPOINTS; n++)\\n', 'begin: gen_bp_hits\\n', '\\n', '  if (n < BREAKPOINTS)\\n', '  begin\\n', '      always @(posedge clk_i,negedge rst_ni)\\n', \"        if      (!rst_ni                                ) dbg.hit.bp_hit[n] <= 1'b0;\\n\", '        else if ( du_we_internal && du_addr_o == DBG_HIT) dbg.hit.bp_hit[n] <= du_d_o[n +4];\\n', \"        else if ( bp_hit[n]                             ) dbg.hit.bp_hit[n] <= 1'b1;\\n\", '  end\\n', '  else //n >= BREAKPOINTS\\n', \"    assign dbg.hit.bp_hit[n] = 1'b0;\\n\", '\\n', 'end\\n', 'endgenerate\\n', '\\n', '\\n', '  //DBG PC\\n', '  //Stores the nxt_pc to execute\\n', '  //Debug Triggers are caught at different stages of the pipeline, thus need to\\n', '  //latch PC from different levels of the pipeline\\n', '  always @(posedge clk_i)\\n', '    if      (|du_exceptions_i) dpc <= wb_pc_i;\\n', '    else if ( bu_flush_i     ) dpc <= bu_nxt_pc_i; //when branch/jal(r) during single step\\n', '    else if ( bp_instr_hit   ) dpc <= if_nxt_pc_i;\\n', '    else if (|bp_hit         ) dpc <= id_pc_i;\\n', '    else if ( bp_branch_hit  ) dpc <= id_pc_i;\\n', '    else if ( du_latch_nxt_pc_o & ~|dbg.cause) dpc <= id_pc_i;\\n', '\\n', '\\n', '  //DBG IE\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', \"    if      (!rst_ni                               ) dbg.ie <= 'h0;\\n\", '    else if ( du_we_internal && du_addr_o == DBG_IE) dbg.ie <= du_d_o[31:0];\\n', '\\n', '\\n', '  //send to Thread-State\\n', '  assign du_ie_o = dbg.ie;\\n', '\\n', '\\n', '  //DBG CAUSE\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', \"    if (!rst_ni)                                        dbg.cause <= 'h0;\\n\", '    else if ( du_we_internal && du_addr_o == DBG_CAUSE) dbg.cause <= du_d_o;\\n', \"    else if ( du_flush_o & ~|du_exceptions_i          ) dbg.cause <= 'h0;\\n\", '    else if (|du_exceptions_i[15:0]) //traps\\n', '    begin\\n', '        casex (du_exceptions_i[15:0])\\n', \"          16'b????_????_????_???1 : dbg.cause <=  0;\\n\", \"          16'b????_????_????_??10 : dbg.cause <=  1;\\n\", \"          16'b????_????_????_?100 : dbg.cause <=  2;\\n\", \"          16'b????_????_????_1000 : dbg.cause <=  3;\\n\", \"          16'b????_????_???1_0000 : dbg.cause <=  4;\\n\", \"          16'b????_????_??10_0000 : dbg.cause <=  5;\\n\", \"          16'b????_????_?100_0000 : dbg.cause <=  6;\\n\", \"          16'b????_????_1000_0000 : dbg.cause <=  7;\\n\", \"          16'b????_???1_0000_0000 : dbg.cause <=  8;\\n\", \"          16'b????_??10_0000_0000 : dbg.cause <=  9;\\n\", \"          16'b????_?100_0000_0000 : dbg.cause <= 10;\\n\", \"          16'b????_1000_0000_0000 : dbg.cause <= 11;\\n\", \"          16'b???1_0000_0000_0000 : dbg.cause <= 12;\\n\", \"          16'b??10_0000_0000_0000 : dbg.cause <= 13;\\n\", \"          16'b?100_0000_0000_0000 : dbg.cause <= 14;\\n\", \"          16'b1000_0000_0000_0000 : dbg.cause <= 15;\\n\", '          default                 : dbg.cause <=  0;\\n', '        endcase\\n', '    end\\n', '    else if (|du_exceptions_i[31:16]) //Interrupts\\n', '    begin\\n', '        casex ( du_exceptions_i[31:16])\\n', \"          16'b????_????_????_???1 : dbg.cause <= ('h1 << (XLEN-1)) |  0;\\n\", \"          16'b????_????_????_??10 : dbg.cause <= ('h1 << (XLEN-1)) |  1;\\n\", \"          16'b????_????_????_?100 : dbg.cause <= ('h1 << (XLEN-1)) |  2;\\n\", \"          16'b????_????_????_1000 : dbg.cause <= ('h1 << (XLEN-1)) |  3;\\n\", \"          16'b????_????_???1_0000 : dbg.cause <= ('h1 << (XLEN-1)) |  4;\\n\", \"          16'b????_????_??10_0000 : dbg.cause <= ('h1 << (XLEN-1)) |  5;\\n\", \"          16'b????_????_?100_0000 : dbg.cause <= ('h1 << (XLEN-1)) |  6;\\n\", \"          16'b????_????_1000_0000 : dbg.cause <= ('h1 << (XLEN-1)) |  7;\\n\", \"          16'b????_???1_0000_0000 : dbg.cause <= ('h1 << (XLEN-1)) |  8;\\n\", \"          16'b????_??10_0000_0000 : dbg.cause <= ('h1 << (XLEN-1)) |  9;\\n\", \"          16'b????_?100_0000_0000 : dbg.cause <= ('h1 << (XLEN-1)) | 10;\\n\", \"          16'b????_1000_0000_0000 : dbg.cause <= ('h1 << (XLEN-1)) | 11;\\n\", \"          16'b???1_0000_0000_0000 : dbg.cause <= ('h1 << (XLEN-1)) | 12;\\n\", \"          16'b??10_0000_0000_0000 : dbg.cause <= ('h1 << (XLEN-1)) | 13;\\n\", \"          16'b?100_0000_0000_0000 : dbg.cause <= ('h1 << (XLEN-1)) | 14;\\n\", \"          16'b1000_0000_0000_0000 : dbg.cause <= ('h1 << (XLEN-1)) | 15;\\n\", \"          default                 : dbg.cause <= ('h1 << (XLEN-1)) |  0;\\n\", '        endcase\\n', '    end\\n', '   \\n', '\\n', '  //DBG BPCTRL / DBG BPDATA\\n', 'generate\\n', 'for (n=0; n<MAX_BREAKPOINTS; n++)\\n', 'begin: gen_bp\\n', '\\n', '  if (n < BREAKPOINTS)\\n', '  begin\\n', \"      assign dbg.bp[n].ctrl.implemented = 1'b1;\\n\", '\\n', '      always @(posedge clk_i,negedge rst_ni)\\n', '        if (!rst_ni)\\n', '        begin\\n', \"            dbg.bp[n].ctrl.enabled <= 'b0;\\n\", \"            dbg.bp[n].ctrl.cc      <= 'h0;\\n\", '        end\\n', '        else if (du_we_internal && du_addr_o == (DBG_BPCTRL0 + 2*n) )\\n', '        begin\\n', '            dbg.bp[n].ctrl.enabled <= du_d_o[1];\\n', '            dbg.bp[n].ctrl.cc      <= du_d_o[6:4];\\n', '        end\\n', '\\n', '      always @(posedge clk_i,negedge rst_ni)\\n', \"        if (!rst_ni) dbg.bp[n].data <= 'h0;\\n\", '        else if (du_we_internal && du_addr_o == (DBG_BPDATA0 + 2*n) ) dbg.bp[n].data <= du_d_o;\\n', '  end\\n', '  else\\n', '  begin\\n', \"      assign dbg.bp[n] = 'h0;\\n\", '  end\\n', '\\n', 'end\\n', 'endgenerate\\n', '\\n', '\\n', '\\n', '  /*\\n', '   * BreakPoints\\n', '   *\\n', '   * Combinatorial generation of break-point hit logic\\n', \"   * For actual registers see 'Registers' section\\n\", '   */\\n', '  assign bp_instr_hit  = dbg.ctrl.instr_break_ena  & ~if_nxt_insn_i.bubble;\\n', '  assign bp_branch_hit = dbg.ctrl.branch_break_ena & ~if_insn_i.bubble & (if_insn_i.instr.R.opcode == OPC_BRANCH);\\n', '\\n', '  //Memory access\\n', '  assign mem_read  = ~mem_exceptions_i.any & ~mem_insn_i.bubble & (mem_insn_i.instr.R.opcode == OPC_LOAD );\\n', '  assign mem_write = ~mem_exceptions_i.any & ~mem_insn_i.bubble & (mem_insn_i.instr.R.opcode == OPC_STORE);\\n', '\\n', 'generate\\n', 'for (n=0; n<MAX_BREAKPOINTS; n++)\\n', 'begin: gen_bp_hit\\n', '\\n', '  if (n < BREAKPOINTS)\\n', '  begin: gen_hit_logic\\n', '\\n', '      always_comb\\n', \"        if (!dbg.bp[n].ctrl.enabled || !dbg.bp[n].ctrl.implemented) bp_hit[n] = 1'b0;\\n\", '        else\\n', '          case (dbg.bp[n].ctrl.cc)\\n', '             BP_CTRL_CC_FETCH    : bp_hit[n] = (pd_pc_i      == dbg.bp[n].data) & ~bu_flush_i & ~st_flush_i;\\n', '             BP_CTRL_CC_LD_ADR   : bp_hit[n] = (mem_memadr_i == dbg.bp[n].data) & dmem_ack_i & mem_read;\\n', '             BP_CTRL_CC_ST_ADR   : bp_hit[n] = (mem_memadr_i == dbg.bp[n].data) & dmem_ack_i & mem_write;\\n', '             BP_CTRL_CC_LDST_ADR : bp_hit[n] = (mem_memadr_i == dbg.bp[n].data) & dmem_ack_i & (mem_read | mem_write);\\n', '/*\\n', '             BP_CTRL_CC_LD_ADR   : bp_hit[n] = (mem_adr == dbg.bp[n].data) & mem_req & ~mem_we;\\n', '             BP_CTRL_CC_ST_ADR   : bp_hit[n] = (mem_adr == dbg.bp[n].data) & mem_req &  mem_we;\\n', '             BP_CTRL_CC_LDST_ADR : bp_hit[n] = (mem_adr == dbg.bp[n].data) & mem_req;\\n', '*/\\n', \"             default             : bp_hit[n] = 1'b0;\\n\", '          endcase\\n', '\\n', '  end\\n', '  else //n >= BREAKPOINTS\\n', '  begin\\n', \"      assign bp_hit[n] = 1'b0;\\n\", '  end\\n', '\\n', 'end\\n', 'endgenerate\\n', '\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Post-Write Back                                              //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', '//Simply delay WriteBack output for Bypass purposes\\n', 'module riscv_dwb\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', '#(\\n', '  parameter            XLEN    = 32,\\n', \"  parameter [XLEN-1:0] PC_INIT = 'h200\\n\", ')\\n', '(\\n', '  input                  rst_ni,          //Reset\\n', '  input                  clk_i,           //Clock\\n', '  \\n', '  input  instruction_t   wb_insn_i,\\n', '  input                  wb_we_i,\\n', '  input      [XLEN -1:0] wb_r_i,\\n', '\\n', '  output instruction_t   dwb_insn_o,\\n', '  output reg [XLEN -1:0] dwb_r_o\\n', ');\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  //Instruction\\t\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if (!rst_ni) dwb_insn_o.instr <= INSTR_NOP;\\n', '    else         dwb_insn_o.instr <= wb_insn_i.instr;\\n', '\\n', '\\n', '  //Bubble\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) dwb_insn_o.bubble <= 1'b1;\\n\", '    else         dwb_insn_o.bubble <= ~wb_we_i;\\n', '\\n', '\\n', '  //DBG\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if   (!rst_ni) dwb_insn_o.dbg <= 1'b0;\\n\", '    else           dwb_insn_o.dbg <= wb_insn_i.dbg;\\n', '\\n', '\\n', '  //Result\\n', '  //Latch with wb_we_i to handle stalls\\n', '  always @(posedge clk_i)\\n', '    if (wb_we_i) dwb_r_o <= wb_r_i;\\n', '\\n', 'endmodule\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Execution Units (EX Stage)                                   //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2017-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_ex\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', 'import biu_constants_pkg::*;\\n', '#(\\n', '  parameter int        XLEN           = 32,\\n', \"  parameter [XLEN-1:0] PC_INIT        = 'h200,\\n\", '  parameter int        BP_GLOBAL_BITS = 2,\\n', '  parameter int        HAS_RVC        = 0,\\n', '  parameter int        HAS_RVA        = 0,\\n', '  parameter int        HAS_RVM        = 0,\\n', '  parameter int        MULT_LATENCY   = 0,\\n', '  parameter int        RSB_DEPTH      = 0\\n', ')\\n', '(\\n', '  input                           rst_ni,\\n', '  input                           clk_i,\\n', '\\n', '  input                           mem_stall_i,\\n', '  output                          ex_stall_o,\\n', '\\n', '  //Program counter\\n', '  input      [XLEN          -1:0] id_pc_i,\\n', '                                  id_rsb_pc_i,\\n', '  output reg [XLEN          -1:0] ex_pc_o,\\n', '                                  bu_nxt_pc_o,\\n', '  output                          bu_flush_o,\\n', '                                  cm_ic_invalidate_o,\\n', '                                  cm_dc_invalidate_o,\\n', '                                  cm_dc_clean_o,\\n', '  input      [               1:0] id_bp_predict_i,\\n', '  output     [               1:0] bu_bp_predict_o,\\n', '  input      [BP_GLOBAL_BITS-1:0] id_bp_history_i,\\n', '  output     [BP_GLOBAL_BITS-1:0] bu_bp_history_update_o,\\n', '                                  bu_bp_history_o,\\n', '  output                          bu_bp_btaken_o,\\n', '  output                          bu_bp_update_o,\\n', '\\n', '  //Instruction\\n', '  input  instruction_t            id_insn_i,\\n', '  output instruction_t            ex_insn_o,\\n', '\\n', '  input  interrupts_exceptions_t  id_exceptions_i,\\n', '  output interrupts_exceptions_t  ex_exceptions_o,\\n', '  input  interrupts_exceptions_t  mem_exceptions_i,\\n', '                                  wb_exceptions_i,\\n', '\\n', '  //from ID\\n', '  input                           id_userf_opA_i,\\n', '                                  id_userf_opB_i,\\n', '                                  id_bypex_opA_i,\\n', '                                  id_bypex_opB_i,\\n', '  input      [XLEN          -1:0] id_opA_i,\\n', '                                  id_opB_i,\\n', '\\n', '  //from RF\\n', '  input      [XLEN          -1:0] rf_srcv1_i,\\n', '                                  rf_srcv2_i,\\n', '\\n', '  //to MEM\\n', '  output reg [XLEN          -1:0] ex_r_o,\\n', '\\n', '  //To State\\n', '  output     [              11:0] ex_csr_reg_o,\\n', '  output     [XLEN          -1:0] ex_csr_wval_o,\\n', '  output                          ex_csr_we_o,\\n', '\\n', '  //From State\\n', '  input      [               1:0] st_xlen_i,\\n', '  input                           st_flush_i,\\n', '  input      [XLEN          -1:0] st_csr_rval_i, //TODO: read during ID\\n', '\\n', '  //To DCACHE/Memory\\n', '  output                          dmem_req_o,\\n', '  output                          dmem_lock_o,\\n', '  output     [XLEN          -1:0] dmem_adr_o,\\n', '  output     biu_size_t           dmem_size_o,\\n', '  output                          dmem_we_o,\\n', '  output     [XLEN          -1:0] dmem_d_o,\\n', '  input      [XLEN          -1:0] dmem_q_i,\\n', '  input                           dmem_ack_i,\\n', '                                  dmem_misaligned_i,\\n', '                                  dmem_page_fault_i\\n', ');\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '\\n', '  //Operand generation\\n', '  logic [XLEN          -1:0] opA,opB;\\n', '\\n', '  logic [XLEN          -1:0] alu_r,\\n', '                             lsu_r,\\n', '                             mul_r,\\n', '                             div_r;\\n', '\\n', '  //Pipeline Bubbles\\n', '  logic                      alu_bubble,\\n', '                             lsu_bubble,\\n', '                             bu_bubble,\\n', '                             mul_bubble,\\n', '                             div_bubble;\\n', '\\n', '  //Pipeline stalls\\n', '  logic                      lsu_stall,\\n', '                             mul_stall,\\n', '                             div_stall;\\n', '\\n', '  //Exceptions\\n', '  logic [EXCEPTION_SIZE-1:0] bu_exception;\\n', '  interrupts_exceptions_t    lsu_exceptions;\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  /*\\n', '   * Program Counter\\n', '   */\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if      (!rst_ni    ) ex_pc_o <= PC_INIT;\\n', '    else if (!ex_stall_o) ex_pc_o <= id_pc_i;\\n', '\\n', '\\n', '  /*\\n', '   * Instruction\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    if (!ex_stall_o) ex_insn_o.instr <= id_insn_i.instr;\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni    ) ex_insn_o.dbg <= 1'b0;\\n\", '    else if (!ex_stall_o) ex_insn_o.dbg <= id_insn_i.dbg;\\n', '    \\n', '\\n', '  /*\\n', '   * Bypasses\\n', '   */\\n', '  always_comb\\n', '    casex ( {id_userf_opA_i, id_bypex_opA_i})\\n', \"      2'b?1  : opA = ex_r_o;\\n\", \"      2'b10  : opA = rf_srcv1_i;\\n\", '      default: opA = id_opA_i;\\n', '    endcase\\n', '\\n', '  always_comb\\n', '    casex ( {id_userf_opB_i, id_bypex_opB_i})\\n', \"      2'b?1  : opB = ex_r_o;\\n\", \"      2'b10  : opB = rf_srcv2_i;\\n\", '      default: opB = id_opB_i;\\n', '    endcase\\n', '\\n', '\\n', '  /*\\n', '   * Execution Units\\n', '   */\\n', '  riscv_alu #(\\n', '    .XLEN             ( XLEN             ),\\n', '    .HAS_RVC          ( HAS_RVC          ))\\n', '  alu (\\n', '    .rst_ni           ( rst_ni           ),\\n', '    .clk_i            ( clk_i            ),\\n', '\\n', '    .ex_stall_i       ( ex_stall_o       ),\\n', '\\n', '    .id_pc_i          ( id_pc_i          ),\\n', '    .id_insn_i        ( id_insn_i        ),\\n', '\\n', '    .opA_i            ( opA              ),\\n', '    .opB_i            ( opB              ),\\n', '\\n', '    .ex_exceptions_i  ( ex_exceptions_o  ),\\n', '    .mem_exceptions_i ( mem_exceptions_i ),\\n', '    .wb_exceptions_i  ( wb_exceptions_i  ),\\n', '\\n', '    .alu_bubble_o     ( alu_bubble       ),\\n', '    .alu_r_o          ( alu_r            ),\\n', '\\n', '    .ex_csr_reg_o     ( ex_csr_reg_o     ),\\n', '    .ex_csr_wval_o    ( ex_csr_wval_o    ),\\n', '    .ex_csr_we_o      ( ex_csr_we_o      ),\\n', '\\n', '    .st_csr_rval_i    ( st_csr_rval_i    ),\\n', '    .st_xlen_i        ( st_xlen_i        ) );\\n', '\\n', '\\n', '  // Load-Store Unit\\n', '  riscv_lsu #(\\n', '    .XLEN              ( XLEN              ) )\\n', '  lsu (\\n', '    .rst_ni            ( rst_ni            ),\\n', '    .clk_i             ( clk_i             ),\\n', '\\n', '    .ex_stall_i        ( ex_stall_o        ),\\n', '    .lsu_stall_o       ( lsu_stall         ),\\n', '\\n', '    .id_insn_i         ( id_insn_i         ),\\n', '\\n', '    .lsu_bubble_o      ( lsu_bubble        ),\\n', '    .lsu_r_o           ( lsu_r             ),\\n', '\\n', '    .id_exceptions_i   ( id_exceptions_i   ),\\n', '    .ex_exceptions_i   ( ex_exceptions_o   ),\\n', '    .mem_exceptions_i  ( mem_exceptions_i  ),\\n', '    .wb_exceptions_i   ( wb_exceptions_i   ),\\n', '    .lsu_exceptions_o  ( lsu_exceptions    ),\\n', '\\n', '\\n', '    .opA_i             ( opA               ),\\n', '    .opB_i             ( opB               ),\\n', '\\n', '    .st_xlen_i         ( st_xlen_i         ),\\n', '\\n', '    .dmem_req_o        ( dmem_req_o        ),\\n', '    .dmem_lock_o       ( dmem_lock_o       ),\\n', '    .dmem_we_o         ( dmem_we_o         ),\\n', '    .dmem_size_o       ( dmem_size_o       ),\\n', '    .dmem_adr_o        ( dmem_adr_o        ),\\n', '    .dmem_d_o          ( dmem_d_o          ),\\n', '    .dmem_q_i          ( dmem_q_i          ),\\n', '    .dmem_ack_i        ( dmem_ack_i        ),\\n', '    .dmem_misaligned_i ( dmem_misaligned_i ),\\n', '    .dmem_page_fault_i ( dmem_page_fault_i ) );\\n', '\\n', '\\n', '  // Branch Unit\\n', '  riscv_bu #(\\n', '    .XLEN                   ( XLEN                   ),\\n', '    .HAS_RVC                ( HAS_RVC                ),\\n', '    .PC_INIT                ( PC_INIT                ),\\n', '    .BP_GLOBAL_BITS         ( BP_GLOBAL_BITS         ),\\n', '    .RSB_DEPTH              ( RSB_DEPTH              ) )\\n', '  bu (\\n', '    .rst_ni                 ( rst_ni                 ),\\n', '    .clk_i                  ( clk_i                  ),\\n', '\\n', '    .ex_stall_i             ( ex_stall_o             ),\\n', '    .st_flush_i             ( st_flush_i             ),\\n', '\\n', '    .bu_bubble_o            ( bu_bubble              ),\\n', '\\n', '    .id_pc_i                ( id_pc_i                ),\\n', '    .id_insn_i              ( id_insn_i              ),\\n', '    .id_rsb_pc_i            ( id_rsb_pc_i            ),\\n', '    .bu_nxt_pc_o            ( bu_nxt_pc_o            ),\\n', '    .bu_flush_o             ( bu_flush_o             ),\\n', '    .cm_ic_invalidate_o     ( cm_ic_invalidate_o     ),\\n', '    .cm_dc_invalidate_o     ( cm_dc_invalidate_o     ),\\n', '    .cm_dc_clean_o          ( cm_dc_clean_o          ),\\n', '\\n', '    .id_bp_predict_i        ( id_bp_predict_i        ),\\n', '    .bu_bp_predict_o        ( bu_bp_predict_o        ),\\n', '    .id_bp_history_i        ( id_bp_history_i        ),\\n', '    .bu_bp_history_update_o ( bu_bp_history_update_o ),\\n', '    .bu_bp_history_o        ( bu_bp_history_o        ),\\n', '    .bu_bp_btaken_o         ( bu_bp_btaken_o         ),\\n', '    .bu_bp_update_o         ( bu_bp_update_o         ),\\n', '\\n', '    .id_exceptions_i        ( id_exceptions_i        ),\\n', '    .ex_exceptions_i        ( ex_exceptions_o        ),\\n', '    .mem_exceptions_i       ( mem_exceptions_i       ),\\n', '    .wb_exceptions_i        ( wb_exceptions_i        ),\\n', '    .bu_exceptions_o        ( ex_exceptions_o        ),\\n', '\\n', '    .opA_i                  ( opA                    ),\\n', '    .opB_i                  ( opB                    ) );\\n', '\\n', '\\n', 'generate\\n', '  if (HAS_RVM != 0)\\n', '  begin\\n', '      riscv_mul #(\\n', '        .XLEN         ( XLEN         ),\\n', '        .MULT_LATENCY ( MULT_LATENCY ) )\\n', '      mul (\\n', '        .rst_ni       ( rst_ni       ),\\n', '        .clk_i        ( clk_i        ),\\n', '\\n', '        .mem_stall_i  ( mem_stall_i  ),\\n', '        .ex_stall_i   ( ex_stall_o   ),\\n', '        .mul_stall_o  ( mul_stall    ),\\n', '\\n', '        .id_insn_i    ( id_insn_i    ),\\n', '\\n', '        .opA_i        ( opA          ),\\n', '        .opB_i        ( opB          ),\\n', '\\n', '        .st_xlen_i    ( st_xlen_i    ),\\n', '\\n', '        .mul_bubble_o ( mul_bubble   ),\\n', '        .mul_r_o      ( mul_r        ) );\\n', '\\n', '\\n', '      riscv_div #(\\n', '        .XLEN         ( XLEN        ) )\\n', '      div (\\n', '        .rst_ni       ( rst_ni      ),\\n', '        .clk_i        ( clk_i       ),\\n', '\\n', '\\t.mem_stall_i  ( mem_stall_i ),\\n', '        .ex_stall_i   ( ex_stall_o  ),\\n', '        .div_stall_o  ( div_stall   ),\\n', '\\n', '        .id_insn_i    (id_insn_i    ),\\n', '\\n', '        .opA_i        ( opA         ),\\n', '        .opB_i        ( opB         ),\\n', '\\n', '        .st_xlen_i    ( st_xlen_i   ),\\n', '\\n', '        .div_bubble_o ( div_bubble  ),\\n', '        .div_r_o      ( div_r       ) );\\n', '  end\\n', '  else\\n', '  begin\\n', \"      assign mul_bubble = 1'b1;\\n\", \"      assign mul_r      =  'h0;\\n\", \"      assign mul_stall  = 1'b0;\\n\", '\\n', \"      assign div_bubble = 1'b1;\\n\", \"      assign div_r      =  'h0;\\n\", \"      assign div_stall  = 1'b0;\\n\", '  end\\n', 'endgenerate\\n', '\\n', '\\n', '  /*\\n', '   * Combine outputs into 1 single EX output\\n', '   */\\n', '\\n', '  assign ex_insn_o.bubble  =   alu_bubble & lsu_bubble & mul_bubble & div_bubble;\\n', '  assign ex_insn_o.retired = ~(alu_bubble & lsu_bubble & bu_bubble & mul_bubble & div_bubble);\\n', '  assign ex_stall_o        =   mem_stall_i | lsu_stall | mul_stall | div_stall;\\n', '\\n', '\\n', '  //result\\n', '  always_comb\\n', '    unique casex ( {mul_bubble,div_bubble,lsu_bubble} )\\n', \"      3'b110 : ex_r_o = lsu_r;\\n\", \"      3'b101 : ex_r_o = div_r;\\n\", \"      3'b011 : ex_r_o = mul_r;\\n\", '      default: ex_r_o = alu_r;\\n', '    endcase\\n', '\\n', 'endmodule \\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Instruction Decoder                                          //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '/*\\n', '  Changelog: 2017-02-28\\n', '             2017-03-01: Updates for 1.9.1 priv.spec\\n', '             2018-01-20: Updates for 1.10 priv.spec\\n', '             2021-10-12: Fixed missing stall\\n', '*/\\n', '\\n', 'module riscv_id\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', '#(\\n', '  parameter    int                  XLEN           = 32,\\n', \"  parameter    [XLEN          -1:0] PC_INIT        = 'h200,\\n\", '  parameter    int                  HAS_HYPER      = 0,\\n', '  parameter    int                  HAS_SUPER      = 0,\\n', '  parameter    int                  HAS_USER       = 0,\\n', '  parameter    int                  HAS_FPU        = 0,\\n', '  parameter    int                  HAS_RVA        = 0,\\n', '  parameter    int                  HAS_RVM        = 0,\\n', '  parameter    int                  HAS_RVC        = 0,\\n', '  parameter    int                  MULT_LATENCY   = 0,\\n', '  parameter    int                  RF_REGOUT      = 1,\\n', '  parameter    int                  BP_GLOBAL_BITS = 2,\\n', '  parameter    int                  RSB_DEPTH      = 0,\\n', '  parameter    int                  MEM_STAGES     = 1\\n', ')\\n', '(\\n', '  input                             rst_ni,\\n', '  input                             clk_i,\\n', '\\n', '  output reg                        id_stall_o,\\n', '  input                             ex_stall_i,\\n', '                                    du_stall_i,\\n', '\\n', '  input                             bu_flush_i,\\n', '                                    st_flush_i,\\n', '                                    du_flush_i,\\n', '\\n', '  input        [XLEN          -1:0] bu_nxt_pc_i,\\n', '                                    st_nxt_pc_i,\\n', '\\n', '\\n', '  //Program counter\\n', '  input        [XLEN          -1:0] pd_pc_i,\\n', '                                    pd_rsb_pc_i,\\n', '  input        [XLEN          -1:0] if_nxt_pc_i,\\n', '  output logic [XLEN          -1:0] id_pc_o,\\n', '                                    id_rsb_pc_o,\\n', '\\n', '  input        [BP_GLOBAL_BITS-1:0] pd_bp_history_i,\\n', '  output logic [BP_GLOBAL_BITS-1:0] id_bp_history_o,\\n', '  input        [               1:0] pd_bp_predict_i,\\n', '  output logic [               1:0] id_bp_predict_o,\\n', '\\n', '\\n', '  //Instruction\\n', '  input  instruction_t              pd_insn_i,\\n', '  output instruction_t              id_insn_o,\\n', '  input  instruction_t              ex_insn_i,\\n', '                                    mem_insn_i [MEM_STAGES],\\n', '                                    wb_insn_i,\\n', '                                    dwb_insn_i,\\n', '\\n', '  //Exceptions\\n', '  input  interrupts_t               st_interrupts_i,\\n', '  input                             int_nmi_i,\\n', '  input  interrupts_exceptions_t    pd_exceptions_i,\\n', '  output interrupts_exceptions_t    id_exceptions_o,\\n', '  input  interrupts_exceptions_t    ex_exceptions_i,\\n', '                                    mem_exceptions_i,\\n', '                                    wb_exceptions_i,\\n', '\\n', '\\n', '  //From State\\n', '  input        [              1:0] st_prv_i,\\n', '                                   st_xlen_i,\\n', '  input                            st_tvm_i,\\n', '                                   st_tw_i,\\n', '                                   st_tsr_i,\\n', '  input        [XLEN         -1:0] st_mcounteren_i,\\n', '                                   st_scounteren_i,\\n', '\\n', '\\n', '  //To RF\\n', '  output rsd_t                     id_rs1_o,\\n', '                                   id_rs2_o,\\n', '\\n', '  //To execution units\\n', '  output logic [XLEN         -1:0] id_opA_o,\\n', '                                   id_opB_o,\\n', '\\n', '  output logic                     id_userf_opA_o,\\n', '                                   id_userf_opB_o,\\n', '                                   id_bypex_opA_o,\\n', '                                   id_bypex_opB_o,\\n', '\\n', '  //from MEM/WB\\n', '  input        [XLEN         -1:0] ex_r_i,\\n', '                                   mem_r_i [MEM_STAGES],\\n', '                                   wb_r_i,\\n', '                                   wb_memq_i,\\n', '                                   dwb_r_i\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Functions\\n', '  //\\n', '\\n', '  /* Use result from a stage?\\n', \"   * 'x0' is used as a black hole. It should always be zero, but may contain\\n\", '   *  other values in the pipeline; therefore we check if rd is non-zero\\n', '   */\\n', '  function logic use_result;\\n', '    input rsd_t rs, rd;\\n', '    input logic valid;\\n', '\\n', '    use_result = (rs == rd ) & |rd  & valid;\\n', '  endfunction: use_result\\n', '\\n', '\\n', '  //next operand value, from lowest to highest priority\\n', '  function logic [XLEN-1:0] nxt_operand;\\n', '    input logic                  use_exr;\\n', '    input logic [MEM_STAGES-1:0] use_memr;\\n', '    input logic                  use_wbr;\\n', '    input logic [XLEN      -1:0] ex_r,\\n', '                                 mem_r     [MEM_STAGES],\\n', '                                 wb_memq,\\n', '                                 wb_r,\\n', '                                 dwb_r;\\n', '     input opcode_t              mem_opcode[MEM_STAGES];\\n', '\\n', '     //default value (lowest priority)\\n', '     nxt_operand = dwb_r;\\n', '\\n', '     //Write Back stage\\n', '     if (use_wbr) nxt_operand = wb_r;\\n', '\\n', '     //upper MEM_STAGES\\n', '     for (int n=MEM_STAGES-1; n >= 0; n--)\\n', '       if (n == MEM_STAGES-1)\\n', '       begin\\n', '           //last MEM_STAGE; latch results from memory upon LOAD\\n', '           if (use_memr[MEM_STAGES-1]) nxt_operand = mem_opcode[MEM_STAGES-1] == OPC_LOAD ? wb_memq : mem_r[MEM_STAGES-1];\\n', '       end\\n', '       else\\n', '       begin\\n', '           if (use_memr[n]) nxt_operand = mem_r[n];\\n', '       end\\n', '\\n', '     //lastly EX (highest priority)\\n', '     if (use_exr) nxt_operand = ex_r;\\n', '  endfunction: nxt_operand\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  genvar                  n;\\n', '\\n', '  logic                   has_rvc,\\n', '                          has_rsb;\\n', '\\n', '  logic                   id_bubble_r;\\n', '  logic                   multi_cycle_instruction;\\n', '  logic                   stalls,\\n', '                          flushes,\\n', '                          exceptions;\\n', '\\n', '  interrupts_exceptions_t my_exceptions;\\n', '\\n', '  //Immediates\\n', '  immI_t                  immI;\\n', '  immU_t                  immU;\\n', '  logic [XLEN       -1:0] ext_immI,\\n', '                          ext_immU;\\n', '\\n', '  //Opcodes\\n', '  opcR_t                  pd_opcR;\\n', '\\n', '  opcode_t                id_opcode,\\n', '                          ex_opcode,\\n', '                          mem_opcode  [MEM_STAGES],\\n', '                          wb_opcode,\\n', '                          dwb_opcode;\\n', '\\t    \\n', '  logic                   is_32bit_instruction;\\n', '\\n', '  logic                   xlen64,    //Is the CPU state set to RV64?\\n', '                          xlen32,    //Is the CPU state set to RV32?\\n', '                          has_fpu,\\n', '                          has_muldiv,\\n', '                          has_amo,\\n', '                          has_u,\\n', '                          has_s,\\n', '                          has_h;\\n', '\\n', '  rsd_t                   pd_rs1,\\n', '                          pd_rs2,\\n', '                          id_rd,\\n', '                          ex_rd,\\n', '                          mem_rd      [MEM_STAGES],\\n', '                          wb_rd,\\n', '                          dwb_rd;\\n', '\\n', '  logic                   can_bypex,\\n', '                          can_use_exr,\\n', '                          can_use_memr[MEM_STAGES],\\n', '                          can_use_wbr,\\n', '\\t\\t          can_use_dwbr;\\n', '\\n', '  logic                   use_rf_opA,\\n', '                          use_rf_opB,\\n', '                          use_exr_opA,\\n', '                          use_exr_opB;\\n', '  logic [MEM_STAGES-1:0]  use_memr_opA,\\n', '                          use_memr_opB;\\n', '  logic                   use_wbr_opA,\\n', '                          use_wbr_opB,\\n', '                          use_dwbr_opA,\\n', '                          use_dwbr_opB;\\n', '\\n', '  logic                   stall_ld_id,\\n', '                          stall_ld_ex;\\n', '  logic [MEM_STAGES-1:0]  stall_ld_mem;\\n', '\\n', '\\n', '  logic [XLEN       -1:0] nxt_opA,\\n', '\\t\\t          nxt_opB;\\n', '\\n', '  logic                   illegal_instr,\\n', '                          illegal_alu_instr,\\n', '                          illegal_lsu_instr,\\n', '                          illegal_muldiv_instr,\\n', '                          illegal_csr_rd,\\n', '                          illegal_csr_wr;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '  assign has_rvc = HAS_RVC != 0;\\n', '  assign has_rsb = RSB_DEPTH > 0;\\n', '  \\n', '\\n', '  /*\\n', '   * Program Counter\\n', '   */\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', '    if      (!rst_ni                   ) id_pc_o <= PC_INIT;\\n', '    else if ( st_flush_i               ) id_pc_o <= st_nxt_pc_i;\\n', '    else if ( bu_flush_i \\t       ) id_pc_o <= bu_nxt_pc_i; //Is this required?! \\n', '    else if ( du_flush_i \\t       ) id_pc_o <= if_nxt_pc_i;\\n', '    else if (!stalls   && !id_stall_o  ) id_pc_o <= pd_pc_i;\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', \"    if (!stalls && !id_stall_o) id_rsb_pc_o <= has_rsb ? pd_rsb_pc_i : {$bits(id_rsb_pc_o){1'b0}};\\n\", '\\n', '\\n', '  /*\\n', '   * Instruction\\n', '   *\\n', '   * TODO: push if-instr upon illegal-instruction\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    if (!stalls) id_insn_o.instr <= pd_insn_i.instr;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni) id_insn_o.dbg <= 1'b0;\\n\", '    else if (!stalls) id_insn_o.dbg <= pd_insn_i.dbg;\\n', '\\n', '\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', \"    if      (!rst_ni                  ) id_bubble_r <= 1'b1;\\n\", \"    else if ( bu_flush_i || st_flush_i) id_bubble_r <= 1'b1;\\n\", '    else if (!stalls                  ) id_bubble_r <= pd_insn_i.bubble | id_stall_o | my_exceptions.any;\\n', '\\n', '    \\n', '  //local stall\\n', '  assign stalls           = ex_stall_i;\\n', '  assign flushes          = bu_flush_i | st_flush_i;\\n', '  assign exceptions       = ex_exceptions_i.any | mem_exceptions_i.any | wb_exceptions_i.any;\\n', '  assign id_insn_o.bubble = stalls | flushes | exceptions | id_bubble_r;\\n', '\\n', '\\n', '  assign is_32bit_instruction = ~&pd_insn_i.instr[4:2] & &pd_insn_i.instr[1:0];\\n', '\\n', '  assign pd_opcR    = decode_opcR(pd_insn_i.instr);\\n', '\\n', '  assign id_opcode  = decode_opcode(id_insn_o.instr );\\n', '  assign ex_opcode  = decode_opcode(ex_insn_i.instr );\\n', 'generate\\n', '  for (n=0; n < MEM_STAGES; n++)\\n', '    assign mem_opcode[n] = decode_opcode(mem_insn_i[n].instr);\\n', 'endgenerate\\n', '  assign wb_opcode  = decode_opcode(wb_insn_i.instr );\\n', '  assign dwb_opcode = decode_opcode(dwb_insn_i.instr);\\n', '  assign id_rd      = decode_rd    (id_insn_o.instr );\\n', '  assign ex_rd      = decode_rd    (ex_insn_i.instr );\\n', 'generate\\n', '  for (n=0; n < MEM_STAGES; n++)\\n', '    assign mem_rd[n] = decode_rd   (mem_insn_i[n].instr);\\n', 'endgenerate\\n', '  assign wb_rd      = decode_rd    (wb_insn_i.instr );\\n', '  assign dwb_rd     = decode_rd    (dwb_insn_i.instr);\\n', '\\n', '  assign has_fpu    = (HAS_FPU    !=   0);\\n', '  assign has_muldiv = (HAS_RVM    !=   0);\\n', '  assign has_amo    = (HAS_RVA    !=   0);\\n', '  assign has_u      = (HAS_USER   !=   0);\\n', '  assign has_s      = (HAS_SUPER  !=   0);\\n', '  assign has_h      = (HAS_HYPER  !=   0);\\n', '\\n', '  assign xlen64     = st_xlen_i == RV64I;\\n', '  assign xlen32     = st_xlen_i == RV32I;\\n', '\\n', '\\n', '  //Branch Predict History\\n', '  always @(posedge clk_i)\\n', '    if (!stalls && !id_stall_o) id_bp_predict_o <= pd_bp_predict_i;\\n', '\\n', '\\n', '  /*\\n', '   * Exceptions\\n', '   */\\n', '  always_comb\\n', '    begin\\n', '        my_exceptions                                =  pd_exceptions_i;\\n', '\\n', '\\tmy_exceptions.interrupts                     =  {$bits(st_interrupts_i){~pd_insn_i.bubble}} & st_interrupts_i;\\n', '\\tmy_exceptions.nmi                            = ~pd_insn_i.bubble & int_nmi_i;\\n', '\\t\\n', '        my_exceptions.exceptions.illegal_instruction = ~pd_insn_i.bubble & (illegal_instr | pd_exceptions_i.exceptions.illegal_instruction);\\n', '        my_exceptions.exceptions.breakpoint          = ~pd_insn_i.bubble & (pd_insn_i.instr == EBREAK);\\n', '        my_exceptions.exceptions.umode_ecall         = ~pd_insn_i.bubble & (pd_insn_i.instr == ECALL ) & (st_prv_i == PRV_U) & has_u;\\n', '        my_exceptions.exceptions.smode_ecall         = ~pd_insn_i.bubble & (pd_insn_i.instr == ECALL ) & (st_prv_i == PRV_S) & has_s;\\n', '        my_exceptions.exceptions.hmode_ecall         = ~pd_insn_i.bubble & (pd_insn_i.instr == ECALL ) & (st_prv_i == PRV_H) & has_h;\\n', '        my_exceptions.exceptions.mmode_ecall         = ~pd_insn_i.bubble & (pd_insn_i.instr == ECALL ) & (st_prv_i == PRV_M);\\n', '\\n', '\\tmy_exceptions.any                            = |my_exceptions.exceptions | |my_exceptions.interrupts | int_nmi_i;\\n', '    end\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni                  ) id_exceptions_o <= 'h0;\\n\", \"    else if ( bu_flush_i || st_flush_i) id_exceptions_o <= 'h0;\\n\", '    else if (!stalls                  )\\n', \"        if ( id_stall_o) id_exceptions_o <= 'h0;\\n\", '        else             id_exceptions_o <= my_exceptions;\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', '    if (!stalls && !id_stall_o) id_bp_history_o <= pd_bp_history_i;\\n', '\\n', '\\n', '  /*\\n', '   * To Register File\\n', '   */\\n', '  //address into register file. Gets registered in memory\\n', '  assign id_rs1_o = decode_rs1(pd_insn_i.instr);\\n', '  assign id_rs2_o = decode_rs2(pd_insn_i.instr);\\n', '\\n', '  assign pd_rs1   = decode_rs1(pd_insn_i.instr);\\n', '  assign pd_rs2   = decode_rs2(pd_insn_i.instr);\\n', '\\n', '\\n', '  /*\\n', '   * Decode Immediates\\n', '   */\\n', '  assign immI = decode_immI(pd_insn_i.instr);\\n', '  assign immU = decode_immU(pd_insn_i.instr);\\n', '  assign ext_immI = { {XLEN-$bits(immI){immI[$left(immI,1)]}}, immI};\\n', '  assign ext_immU = { {XLEN-$bits(immU){immU[$left(immU,1)]}}, immU};\\n', '\\n', '\\n', '  /*\\n', '   * Create ALU operands\\n', '   * Feedback pipeline results here\\n', '   */\\n', '  assign use_rf_opA = ~(use_dwbr_opA | use_wbr_opA | |use_memr_opA | use_exr_opA);\\n', '  assign use_rf_opB = ~(use_dwbr_opB | use_wbr_opB | |use_memr_opB | use_exr_opB);\\n', ' \\n', '\\n', '  always @(posedge clk_i)\\n', '    if (!stalls)\\n', '    casex (pd_opcR.opcode)\\n', '      OPC_OP_IMM  : begin\\n', '                        id_userf_opA_o <= use_rf_opA;\\n', \"                        id_userf_opB_o <= 'b0;\\n\", '                    end\\n', '      OPC_AUIPC   : begin\\n', \"                        id_userf_opA_o <= 'b0;\\n\", \"                        id_userf_opB_o <= 'b0;\\n\", '                    end\\n', '      OPC_OP_IMM32: begin\\n', '                        id_userf_opA_o <= use_rf_opA;\\n', \"                        id_userf_opB_o <= 'b0;\\n\", '                    end\\n', '      OPC_OP      : begin\\n', '                        id_userf_opA_o <= use_rf_opA;\\n', '                        id_userf_opB_o <= use_rf_opB;\\n', '                    end\\n', '      OPC_LUI     : begin\\n', \"                        id_userf_opA_o <= 'b0;\\n\", \"                        id_userf_opB_o <= 'b0;\\n\", '                    end\\n', '      OPC_OP32    : begin\\n', '                        id_userf_opA_o <= use_rf_opA;\\n', '                        id_userf_opB_o <= use_rf_opB;\\n', '                    end\\n', '      OPC_BRANCH  : begin\\n', '                        id_userf_opA_o <= use_rf_opA;\\n', '                        id_userf_opB_o <= use_rf_opB;\\n', '                    end\\n', '      OPC_JALR    : begin\\n', '                        id_userf_opA_o <= use_rf_opA;\\n', \"                        id_userf_opB_o <= 'b0;\\n\", '                    end\\n', '      OPC_LOAD    : begin\\n', '                        id_userf_opA_o <= use_rf_opA;\\n', \"                        id_userf_opB_o <= 'b0;\\n\", '                    end\\n', '      OPC_STORE   : begin\\n', '                        id_userf_opA_o <= use_rf_opA;\\n', '                        id_userf_opB_o <= use_rf_opB;\\n', '                    end\\n', '      OPC_SYSTEM  : begin\\n', '                        id_userf_opA_o <= use_rf_opA;\\n', \"                        id_userf_opB_o <= 'b0;\\n\", '                    end\\n', '      default     : begin\\n', \"                        id_userf_opA_o <= 'b1;\\n\", \"                        id_userf_opB_o <= 'b1;\\n\", '                    end\\n', '    endcase\\n', '\\n', '\\n', '  assign nxt_opA = nxt_operand(use_exr_opA, use_memr_opA, use_wbr_opA,\\n', '                               ex_r_i, mem_r_i, wb_memq_i, wb_r_i, dwb_r_i,\\n', '                               mem_opcode);\\n', '  assign nxt_opB = nxt_operand(use_exr_opB, use_memr_opB, use_wbr_opB,\\n', '                               ex_r_i, mem_r_i, wb_memq_i, wb_r_i, dwb_r_i,\\n', '                               mem_opcode);\\n', '\\n', '  always @(posedge clk_i)\\n', '    if (!stalls)\\n', '    casex (pd_opcR.opcode)\\n', '      OPC_LOAD_FP : ;\\n', '      OPC_MISC_MEM: ;\\n', '      OPC_OP_IMM  : begin\\n', '                        id_opA_o <= nxt_opA;\\n', '                        id_opB_o <= ext_immI;\\n', '                    end\\n', '      OPC_AUIPC   : begin\\n', '                        id_opA_o <= pd_pc_i;\\n', '                        id_opB_o <= ext_immU;\\n', '                    end\\n', '      OPC_OP_IMM32: begin\\n', '                        id_opA_o <= nxt_opA;\\n', '                        id_opB_o <= ext_immI;\\n', '                    end\\n', '      OPC_LOAD    : begin\\n', '                        id_opA_o <= nxt_opA;\\n', '                        id_opB_o <= ext_immI;\\n', '                    end\\n', '      OPC_STORE   : begin\\n', '                        id_opA_o <= nxt_opA;\\n', '                        id_opB_o <= nxt_opB;\\n', '                    end\\n', '      OPC_STORE_FP: ;\\n', '      OPC_AMO     : ; \\n', '      OPC_OP      : begin\\n', '                        id_opA_o <= nxt_opA;\\n', '                        id_opB_o <= nxt_opB;\\n', '                    end\\n', '      OPC_LUI     : begin\\n', '                        id_opA_o <= 0;\\n', '                        id_opB_o <= ext_immU;\\n', '                    end\\n', '      OPC_OP32    : begin\\n', '                        id_opA_o <= nxt_opA;\\n', '                        id_opB_o <= nxt_opB;\\n', '                    end\\n', '      OPC_MADD    : ;\\n', '      OPC_MSUB    : ;\\n', '      OPC_NMSUB   : ;\\n', '      OPC_NMADD   : ;\\n', '      OPC_OP_FP   : ;\\n', '      OPC_BRANCH  : begin\\n', '                        id_opA_o <= nxt_opA;\\n', '                        id_opB_o <= nxt_opB;\\n', '                    end\\n', '      OPC_JALR    : begin\\n', '                        id_opA_o <= nxt_opA;\\n', '                        id_opB_o <= ext_immI;\\n', '                    end\\n', '      OPC_SYSTEM  : begin\\n', '                        id_opA_o <= nxt_opA;     //for CSRxx\\n', \"                        id_opB_o <= { {XLEN-$bits(pd_rs1){1'b0}},pd_rs1 }; //for CSRxxI\\n\", '                    end\\n', '      default     : begin\\n', \"                        id_opA_o <= 'hx;\\n\", \"                        id_opB_o <= 'hx;\\n\", '                    end\\n', '    endcase\\n', '\\n', '\\n', '\\n', '  /*\\n', '   * Bypasses\\n', '   */\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', \"    if (!rst_ni) multi_cycle_instruction <= 1'b0;\\n\", '    else if (!stalls)\\n', '    casex ( {xlen32,pd_opcR} )\\n', \"      {1'b?,MUL   } : multi_cycle_instruction <= MULT_LATENCY > 0 ? has_muldiv : 1'b0;\\n\", \"      {1'b?,MULH  } : multi_cycle_instruction <= MULT_LATENCY > 0 ? has_muldiv : 1'b0;\\n\", \"      {1'b0,MULW  } : multi_cycle_instruction <= MULT_LATENCY > 0 ? has_muldiv : 1'b0;\\n\", \"      {1'b?,MULHSU} : multi_cycle_instruction <= MULT_LATENCY > 0 ? has_muldiv : 1'b0;\\n\", \"      {1'b?,MULHU } : multi_cycle_instruction <= MULT_LATENCY > 0 ? has_muldiv : 1'b0;\\n\", \"      {1'b?,DIV   } : multi_cycle_instruction <= has_muldiv;\\n\", \"      {1'b0,DIVW  } : multi_cycle_instruction <= has_muldiv;\\n\", \"      {1'b?,DIVU  } : multi_cycle_instruction <= has_muldiv;\\n\", \"      {1'b0,DIVUW } : multi_cycle_instruction <= has_muldiv;\\n\", \"      {1'b?,REM   } : multi_cycle_instruction <= has_muldiv;\\n\", \"      {1'b0,REMW  } : multi_cycle_instruction <= has_muldiv;\\n\", \"      {1'b?,REMU  } : multi_cycle_instruction <= has_muldiv;\\n\", \"      {1'b0,REMUW } : multi_cycle_instruction <= has_muldiv;\\n\", \"      default       : multi_cycle_instruction <= 1'b0;\\n\", '    endcase\\n', '\\n', '\\n', '  //Check for each stage if the result should be used\\n', '  always_comb\\n', '    casex (id_opcode)\\n', '       OPC_LOAD    : can_bypex = ~id_insn_o.bubble;\\n', '       OPC_OP_IMM  : can_bypex = ~id_insn_o.bubble;\\n', '       OPC_AUIPC   : can_bypex = ~id_insn_o.bubble;\\n', '       OPC_OP_IMM32: can_bypex = ~id_insn_o.bubble;\\n', '       OPC_AMO     : can_bypex = ~id_insn_o.bubble;\\n', '       OPC_OP      : can_bypex = ~id_insn_o.bubble;\\n', '       OPC_LUI     : can_bypex = ~id_insn_o.bubble;\\n', '       OPC_OP32    : can_bypex = ~id_insn_o.bubble;\\n', '       OPC_JALR    : can_bypex = ~id_insn_o.bubble;\\n', '       OPC_JAL     : can_bypex = ~id_insn_o.bubble;\\n', '       OPC_SYSTEM  : can_bypex = ~id_insn_o.bubble; //TODO not ALL SYSTEM\\n', \"       default     : can_bypex = 1'b0;\\n\", '    endcase\\n', '\\n', '\\n', '  always_comb\\n', '    casex (ex_opcode)\\n', '       OPC_LOAD    : can_use_exr = ~ex_insn_i.bubble;\\n', '       OPC_OP_IMM  : can_use_exr = ~ex_insn_i.bubble;\\n', '       OPC_AUIPC   : can_use_exr = ~ex_insn_i.bubble;\\n', '       OPC_OP_IMM32: can_use_exr = ~ex_insn_i.bubble;\\n', '       OPC_AMO     : can_use_exr = ~ex_insn_i.bubble;\\n', '       OPC_OP      : can_use_exr = ~ex_insn_i.bubble;\\n', '       OPC_LUI     : can_use_exr = ~ex_insn_i.bubble;\\n', '       OPC_OP32    : can_use_exr = ~ex_insn_i.bubble;\\n', '       OPC_JALR    : can_use_exr = ~ex_insn_i.bubble;\\n', '       OPC_JAL     : can_use_exr = ~ex_insn_i.bubble;\\n', '       OPC_SYSTEM  : can_use_exr = ~ex_insn_i.bubble; //TODO not ALL SYSTEM\\n', \"       default     : can_use_exr = 1'b0;\\n\", '    endcase\\n', '\\n', '\\n', '  always_comb\\n', '    for (int n=0; n < MEM_STAGES; n++)\\n', '        casex (mem_opcode[n])\\n', '           OPC_LOAD    : can_use_memr[n] = ~mem_insn_i[n].bubble;\\n', '           OPC_OP_IMM  : can_use_memr[n] = ~mem_insn_i[n].bubble;\\n', '           OPC_AUIPC   : can_use_memr[n] = ~mem_insn_i[n].bubble;\\n', '           OPC_OP_IMM32: can_use_memr[n] = ~mem_insn_i[n].bubble;\\n', '           OPC_AMO     : can_use_memr[n] = ~mem_insn_i[n].bubble;\\n', '           OPC_OP      : can_use_memr[n] = ~mem_insn_i[n].bubble;\\n', '           OPC_LUI     : can_use_memr[n] = ~mem_insn_i[n].bubble;\\n', '           OPC_OP32    : can_use_memr[n] = ~mem_insn_i[n].bubble;\\n', '           OPC_JALR    : can_use_memr[n] = ~mem_insn_i[n].bubble;\\n', '           OPC_JAL     : can_use_memr[n] = ~mem_insn_i[n].bubble;\\n', '           OPC_SYSTEM  : can_use_memr[n] = ~mem_insn_i[n].bubble; //TODO not ALL SYSTEM\\n', \"           default     : can_use_memr[n] = 1'b0;\\n\", '        endcase\\n', '\\n', '\\n', '  always_comb\\n', '    casex (wb_opcode)\\n', '       OPC_LOAD    : can_use_wbr =  ~wb_insn_i.bubble;\\n', '       OPC_OP_IMM  : can_use_wbr =  ~wb_insn_i.bubble;\\n', '       OPC_AUIPC   : can_use_wbr =  ~wb_insn_i.bubble;\\n', '       OPC_OP_IMM32: can_use_wbr =  ~wb_insn_i.bubble;\\n', '       OPC_AMO     : can_use_wbr =  ~wb_insn_i.bubble;\\n', '       OPC_OP      : can_use_wbr =  ~wb_insn_i.bubble;\\n', '       OPC_LUI     : can_use_wbr =  ~wb_insn_i.bubble;\\n', '       OPC_OP32    : can_use_wbr =  ~wb_insn_i.bubble;\\n', '       OPC_JALR    : can_use_wbr =  ~wb_insn_i.bubble;\\n', '       OPC_JAL     : can_use_wbr =  ~wb_insn_i.bubble;\\n', '       OPC_SYSTEM  : can_use_wbr =  ~wb_insn_i.bubble; //TODO not ALL SYSTEM\\n', \"       default     : can_use_wbr = 1'b0;\\n\", '    endcase\\n', '\\n', '  always_comb\\n', '    casex (dwb_opcode)\\n', \"       OPC_LOAD    : can_use_dwbr =  (RF_REGOUT > 0) ? ~dwb_insn_i.bubble : 1'b0;\\n\", \"       OPC_OP_IMM  : can_use_dwbr =  (RF_REGOUT > 0) ? ~dwb_insn_i.bubble : 1'b0;\\n\", \"       OPC_AUIPC   : can_use_dwbr =  (RF_REGOUT > 0) ? ~dwb_insn_i.bubble : 1'b0;\\n\", \"       OPC_OP_IMM32: can_use_dwbr =  (RF_REGOUT > 0) ? ~dwb_insn_i.bubble : 1'b0;\\n\", \"       OPC_AMO     : can_use_dwbr =  (RF_REGOUT > 0) ? ~dwb_insn_i.bubble : 1'b0;\\n\", \"       OPC_OP      : can_use_dwbr =  (RF_REGOUT > 0) ? ~dwb_insn_i.bubble : 1'b0;\\n\", \"       OPC_LUI     : can_use_dwbr =  (RF_REGOUT > 0) ? ~dwb_insn_i.bubble : 1'b0;\\n\", \"       OPC_OP32    : can_use_dwbr =  (RF_REGOUT > 0) ? ~dwb_insn_i.bubble : 1'b0;\\n\", \"       OPC_JALR    : can_use_dwbr =  (RF_REGOUT > 0) ? ~dwb_insn_i.bubble : 1'b0;\\n\", \"       OPC_JAL     : can_use_dwbr =  (RF_REGOUT > 0) ? ~dwb_insn_i.bubble : 1'b0;\\n\", \"       OPC_SYSTEM  : can_use_dwbr =  (RF_REGOUT > 0) ? ~dwb_insn_i.bubble : 1'b0; //TODO not ALL SYSTEM\\n\", \"       default     : can_use_dwbr = 1'b0;\\n\", '    endcase\\n', '\\n', '\\n', '  /*\\n', '   set bypass switches\\n', '  */\\n', '  always_comb\\n', '    casex (pd_opcR.opcode)\\n', '      OPC_OP_IMM  : begin\\n', '                        use_exr_opA  = use_result(pd_rs1, ex_rd, can_use_exr);\\n', \"                        use_exr_opB  = 1'b0;\\n\", '\\n', '                        for (int n=0; n < MEM_STAGES; n++)\\n', '                        begin\\n', '                            use_memr_opA[n] = use_result(pd_rs1, mem_rd[n], can_use_memr[n]);\\n', \"                            use_memr_opB[n] = 1'b0;\\n\", '                        end\\n', '\\n', '                        use_wbr_opA  = use_result(pd_rs1, wb_rd, can_use_wbr);\\n', \"                        use_wbr_opB  = 1'b0;\\n\", '\\n', '                        use_dwbr_opA = use_result(pd_rs1, dwb_rd, can_use_dwbr);\\n', \"                        use_dwbr_opB = 1'b0;\\n\", '                    end\\n', '      OPC_OP_IMM32: begin\\n', '                        use_exr_opA  = use_result(pd_rs1, ex_rd, can_use_exr);\\n', \"                        use_exr_opB  = 1'b0;\\n\", '\\n', '                        for (int n=0; n < MEM_STAGES; n++)\\n', '                        begin\\n', '                            use_memr_opA[n] = use_result(pd_rs1, mem_rd[n], can_use_memr[n]);\\n', \"                            use_memr_opB[n] = 1'b0;\\n\", '                        end\\n', '\\n', '                        use_wbr_opA  = use_result(pd_rs1, wb_rd, can_use_wbr);\\n', \"                        use_wbr_opB  = 1'b0;\\n\", '\\n', '                        use_dwbr_opA = use_result(pd_rs1, dwb_rd, can_use_dwbr);\\n', \"                        use_dwbr_opB = 1'b0;\\n\", '                    end\\n', '      OPC_OP      : begin\\n', '                        use_exr_opA  = use_result(pd_rs1, ex_rd, can_use_exr);\\n', '                        use_exr_opB  = use_result(pd_rs2, ex_rd, can_use_exr);\\n', '\\n', '                        for (int n=0; n < MEM_STAGES; n++)\\n', '                        begin\\n', '                            use_memr_opA[n] = use_result(pd_rs1, mem_rd[n], can_use_memr[n]);\\n', '                            use_memr_opB[n] = use_result(pd_rs2, mem_rd[n], can_use_memr[n]);\\n', '                        end\\n', '\\n', '                        use_wbr_opA  = use_result(pd_rs1, wb_rd, can_use_wbr);\\n', '                        use_wbr_opB  = use_result(pd_rs2, wb_rd, can_use_wbr);\\n', '\\n', '                        use_dwbr_opA = use_result(pd_rs1, dwb_rd, can_use_dwbr);\\n', '                        use_dwbr_opB = use_result(pd_rs2, dwb_rd, can_use_dwbr);\\n', '                    end\\n', '      OPC_OP32    : begin\\n', '                        use_exr_opA  = use_result(pd_rs1, ex_rd, can_use_exr);\\n', '                        use_exr_opB  = use_result(pd_rs2, ex_rd, can_use_exr);\\n', '\\n', '                        for (int n=0; n < MEM_STAGES; n++)\\n', '                        begin\\n', '                            use_memr_opA[n] = use_result(pd_rs1, mem_rd[n], can_use_memr[n]);\\n', '                            use_memr_opB[n] = use_result(pd_rs2, mem_rd[n], can_use_memr[n]);\\n', '                        end\\n', '\\n', '                        use_wbr_opA  = use_result(pd_rs1, wb_rd, can_use_wbr);\\n', '                        use_wbr_opB  = use_result(pd_rs2, wb_rd, can_use_wbr);\\n', '\\n', '                        use_dwbr_opA = use_result(pd_rs1, dwb_rd, can_use_dwbr);\\n', '                        use_dwbr_opB = use_result(pd_rs2, dwb_rd, can_use_dwbr);\\n', '                    end\\n', '      OPC_BRANCH  : begin\\n', '                        use_exr_opA  = use_result(pd_rs1, ex_rd, can_use_exr);\\n', '                        use_exr_opB  = use_result(pd_rs2, ex_rd, can_use_exr);\\n', '\\n', '                        for (int n=0; n < MEM_STAGES; n++)\\n', '                        begin\\n', '                            use_memr_opA[n] = use_result(pd_rs1, mem_rd[n], can_use_memr[n]);\\n', '                            use_memr_opB[n] = use_result(pd_rs2, mem_rd[n], can_use_memr[n]);\\n', '                        end\\n', '\\n', '                        use_wbr_opA  = use_result(pd_rs1, wb_rd, can_use_wbr);\\n', '                        use_wbr_opB  = use_result(pd_rs2, wb_rd, can_use_wbr);\\n', '\\n', '                        use_dwbr_opA = use_result(pd_rs1, dwb_rd, can_use_dwbr);\\n', '                        use_dwbr_opB = use_result(pd_rs2, dwb_rd, can_use_dwbr);\\n', '                    end\\n', '      OPC_JALR    : begin\\n', '                        use_exr_opA  = use_result(pd_rs1, ex_rd, can_use_exr);\\n', \"                        use_exr_opB  = 1'b0;\\n\", '\\n', '                        for (int n=0; n < MEM_STAGES; n++)\\n', '                        begin\\n', '                            use_memr_opA[n] = use_result(pd_rs1, mem_rd[n], can_use_memr[n]);\\n', \"                            use_memr_opB[n] = 1'b0;\\n\", '                        end\\n', '\\n', '                        use_wbr_opA  = use_result(pd_rs1, wb_rd, can_use_wbr);\\n', \"                        use_wbr_opB  = 1'b0;\\n\", '\\n', '                        use_dwbr_opA = use_result(pd_rs1, dwb_rd, can_use_dwbr);\\n', \"                        use_dwbr_opB = 1'b0;\\n\", '                    end\\n', '     OPC_LOAD     : begin\\n', '                        use_exr_opA  = use_result(pd_rs1, ex_rd, can_use_exr);\\n', \"                        use_exr_opB  = 1'b0;\\n\", '\\n', '                        for (int n=0; n < MEM_STAGES; n++)\\n', '                        begin\\n', '                            use_memr_opA[n] = use_result(pd_rs1, mem_rd[n], can_use_memr[n]);\\n', \"                            use_memr_opB[n] = 1'b0;\\n\", '                        end\\n', '\\n', '                        use_wbr_opA  = use_result(pd_rs1, wb_rd, can_use_wbr);\\n', \"                        use_wbr_opB  = 1'b0;\\n\", '\\n', '                        use_dwbr_opA = use_result(pd_rs1, dwb_rd, can_use_dwbr);\\n', \"                        use_dwbr_opB = 1'b0;\\n\", '                    end\\n', '     OPC_STORE    : begin\\n', '                        use_exr_opA  = use_result(pd_rs1, ex_rd, can_use_exr);\\n', '                        use_exr_opB  = use_result(pd_rs2, ex_rd, can_use_exr);\\n', '\\n', '                        for (int n=0; n < MEM_STAGES; n++)\\n', '                        begin\\n', '                            use_memr_opA[n] = use_result(pd_rs1, mem_rd[n], can_use_memr[n]);\\n', '                            use_memr_opB[n] = use_result(pd_rs2, mem_rd[n], can_use_memr[n]);\\n', '                        end\\n', '\\n', '                        use_wbr_opA  = use_result(pd_rs1, wb_rd, can_use_wbr);\\n', '                        use_wbr_opB  = use_result(pd_rs2, wb_rd, can_use_wbr);\\n', '\\n', '                        use_dwbr_opA = use_result(pd_rs1, dwb_rd, can_use_dwbr);\\n', '                        use_dwbr_opB = use_result(pd_rs2, dwb_rd, can_use_dwbr);\\n', '                    end\\n', '     OPC_SYSTEM   : begin\\n', '                        use_exr_opA  = use_result(pd_rs1,  ex_rd, can_use_exr);\\n', \"                        use_exr_opB  = 1'b0;\\n\", '\\n', '                        for (int n=0; n < MEM_STAGES; n++)\\n', '                        begin\\n', '                            use_memr_opA[n] = use_result(pd_rs1, mem_rd[n], can_use_memr[n]);\\n', \"                            use_memr_opB[n] = 1'b0;\\n\", '                        end\\n', '\\n', '                        use_wbr_opA  = use_result(pd_rs1, wb_rd, can_use_wbr);\\n', \"                        use_wbr_opB  = 1'b0;\\n\", '\\n', '                        use_dwbr_opA = use_result(pd_rs1, dwb_rd, can_use_dwbr);\\n', \"                        use_dwbr_opB = 1'b0;\\n\", '                    end\\n', '      default     : begin\\n', \"                        use_exr_opA  = 1'b0;\\n\", \"                        use_exr_opB  = 1'b0;\\n\", '\\n', '                        for (int n=0; n < MEM_STAGES; n++)\\n', '                        begin\\n', \"                            use_memr_opA[n] = 1'b0;\\n\", \"                            use_memr_opB[n] = 1'b0;\\n\", '                        end\\n', '\\n', \"                        use_wbr_opA  = 1'b0;\\n\", \"                        use_wbr_opB  = 1'b0;\\n\", '\\n', \"                        use_dwbr_opA = 1'b0;\\n\", \"                        use_dwbr_opB = 1'b0;\\n\", '                    end\\n', '    endcase\\n', '\\n', '\\n', '  /*\\n', '  * Bypass EX for obvious reasons (no time to register results)\\n', '  */\\n', '  always @(posedge clk_i)\\n', '    if (!stalls)\\n', '    casex (pd_opcR.opcode)\\n', '      OPC_OP_IMM  : begin\\n', '                        id_bypex_opA_o  <= use_result(pd_rs1, id_rd, can_bypex);\\n', \"                        id_bypex_opB_o  <= 1'b0;\\n\", '                    end\\n', '      OPC_OP_IMM32: begin\\n', '                        id_bypex_opA_o  <= use_result(pd_rs1, id_rd, can_bypex);\\n', \"                        id_bypex_opB_o  <= 1'b0;\\n\", '                    end\\n', '      OPC_OP      : begin\\n', '                        id_bypex_opA_o  <= use_result(pd_rs1, id_rd, can_bypex);\\n', '                        id_bypex_opB_o  <= use_result(pd_rs2, id_rd, can_bypex);\\n', '                    end\\n', '      OPC_OP32    : begin\\n', '                        id_bypex_opA_o  <= use_result(pd_rs1, id_rd, can_bypex);\\n', '                        id_bypex_opB_o  <= use_result(pd_rs2, id_rd, can_bypex);\\n', '                    end\\n', '      OPC_BRANCH  : begin\\n', '                        id_bypex_opA_o  <= use_result(pd_rs1, id_rd, can_bypex);\\n', '                        id_bypex_opB_o  <= use_result(pd_rs2, id_rd, can_bypex);\\n', '                    end\\n', '      OPC_JALR    : begin\\n', '                        id_bypex_opA_o  <= use_result(pd_rs1, id_rd, can_bypex);\\n', \"                        id_bypex_opB_o  <= 1'b0;\\n\", '                    end\\n', '     OPC_LOAD     : begin\\n', '                        id_bypex_opA_o  <= use_result(pd_rs1, id_rd, can_bypex);\\n', \"                        id_bypex_opB_o  <= 1'b0;\\n\", '                    end\\n', '     OPC_STORE    : begin\\n', '                        id_bypex_opA_o  <= use_result(pd_rs1, id_rd, can_bypex);\\n', '                        id_bypex_opB_o  <= use_result(pd_rs2, id_rd, can_bypex);\\n', '                    end\\n', '     OPC_SYSTEM   : begin\\n', '                        id_bypex_opA_o  <= use_result(pd_rs1, id_rd, can_bypex);\\n', \"                        id_bypex_opB_o  <= 1'b0;\\n\", '                    end\\n', '      default     : begin\\n', \"                        id_bypex_opA_o  <= 1'b0;\\n\", \"                        id_bypex_opB_o  <= 1'b0;\\n\", '                    end\\n', '    endcase\\n', '\\n', '\\n', '  /*\\n', '   * Generate STALL\\n', '   */\\n', '  always_comb\\n', \"    if (id_opcode != OPC_LOAD || id_insn_o.bubble) stall_ld_id = 1'b0;\\n\", '    else\\n', '      casex (pd_opcR.opcode)\\n', '        OPC_OP_IMM  : stall_ld_id = (pd_rs1 == id_rd);\\n', '        OPC_OP_IMM32: stall_ld_id = (pd_rs1 == id_rd);\\n', '        OPC_OP      : stall_ld_id = (pd_rs1 == id_rd) | (pd_rs2 == id_rd);\\n', '        OPC_OP32    : stall_ld_id = (pd_rs1 == id_rd) | (pd_rs2 == id_rd);\\n', '        OPC_BRANCH  : stall_ld_id = (pd_rs1 == id_rd) | (pd_rs2 == id_rd);\\n', '        OPC_JALR    : stall_ld_id = (pd_rs1 == id_rd);\\n', '        OPC_LOAD    : stall_ld_id = (pd_rs1 == id_rd);\\n', '        OPC_STORE   : stall_ld_id = (pd_rs1 == id_rd) | (pd_rs2 == id_rd);\\n', '        OPC_SYSTEM  : stall_ld_id = (pd_rs1 == id_rd);\\n', \"        default     : stall_ld_id = 'b0;\\n\", '      endcase\\n', '\\n', '\\n', '  always_comb\\n', \"    if (ex_opcode != OPC_LOAD || ex_insn_i.bubble) stall_ld_ex = 1'b0;\\n\", '    else\\n', '      casex (pd_opcR.opcode)\\n', '        OPC_OP_IMM  : stall_ld_ex = (pd_rs1 == ex_rd);\\n', '        OPC_OP_IMM32: stall_ld_ex = (pd_rs1 == ex_rd);\\n', '        OPC_OP      : stall_ld_ex = (pd_rs1 == ex_rd) | (pd_rs2 == ex_rd);\\n', '        OPC_OP32    : stall_ld_ex = (pd_rs1 == ex_rd) | (pd_rs2 == ex_rd);\\n', '        OPC_BRANCH  : stall_ld_ex = (pd_rs1 == ex_rd) | (pd_rs2 == ex_rd);\\n', '        OPC_JALR    : stall_ld_ex = (pd_rs1 == ex_rd);\\n', '        OPC_LOAD    : stall_ld_ex = (pd_rs1 == ex_rd);\\n', '        OPC_STORE   : stall_ld_ex = (pd_rs1 == ex_rd) | (pd_rs2 == ex_rd);\\n', '        OPC_SYSTEM  : stall_ld_ex = (pd_rs1 == ex_rd);\\n', \"        default     : stall_ld_ex = 'b0;\\n\", '      endcase\\n', '\\n', '\\n', '  always_comb\\n', \"    if (MEM_STAGES == 1) stall_ld_mem[0] = 1'b0;\\n\", '    else\\n', '    begin\\n', '        for (int n=0; n < MEM_STAGES -1; n++)\\n', \"          if (mem_opcode[n] != OPC_LOAD || mem_insn_i[n].bubble) stall_ld_mem[n] = 1'b0;\\n\", '          else\\n', '            casex (pd_opcR.opcode)\\n', '              OPC_OP_IMM  : stall_ld_mem[n] = (pd_rs1 == mem_rd[n]);\\n', '              OPC_OP_IMM32: stall_ld_mem[n] = (pd_rs1 == mem_rd[n]);\\n', '              OPC_OP      : stall_ld_mem[n] = (pd_rs1 == mem_rd[n]) | (pd_rs2 == mem_rd[n]);\\n', '              OPC_OP32    : stall_ld_mem[n] = (pd_rs1 == mem_rd[n]) | (pd_rs2 == mem_rd[n]);\\n', '              OPC_BRANCH  : stall_ld_mem[n] = (pd_rs1 == mem_rd[n]) | (pd_rs2 == mem_rd[n]);\\n', '              OPC_JALR    : stall_ld_mem[n] = (pd_rs1 == mem_rd[n]);\\n', '              OPC_LOAD    : stall_ld_mem[n] = (pd_rs1 == mem_rd[n]);\\n', '              OPC_STORE   : stall_ld_mem[n] = (pd_rs1 == mem_rd[n]) | (pd_rs2 == mem_rd[n]);\\n', '              OPC_SYSTEM  : stall_ld_mem[n] = (pd_rs1 == mem_rd[n]);\\n', \"              default     : stall_ld_mem[n] = 'b0;\\n\", '            endcase\\n', '\\n', \"        stall_ld_mem[MEM_STAGES -1] = 1'b0;\\n\", '    end\\n', '\\n', '\\n', '  always_comb\\n', \"    if      (bu_flush_i || st_flush_i || du_flush_i) id_stall_o = 'b0;        //flush overrules stall\\n\", \"    else if (stalls                                ) id_stall_o =1'b1;// ~pd_insn_i.bubble; //TODO\\n\", '    else                                             id_stall_o = stall_ld_id | stall_ld_ex | |stall_ld_mem;\\n', '\\n', '\\n', '  /*\\n', '   * Generate Illegal Instruction\\n', '   */\\n', '  always_comb\\n', '    casex (pd_opcR.opcode)\\n', '      OPC_LOAD  : illegal_instr = illegal_lsu_instr;\\n', '      OPC_STORE : illegal_instr = illegal_lsu_instr;\\n', \"      default   : illegal_instr = illegal_alu_instr & (has_muldiv ? illegal_muldiv_instr : 1'b1);\\n\", '    endcase\\n', '\\n', '\\n', '  //ALU\\n', '  always_comb\\n', '    casex (pd_insn_i.instr)\\n', '       FENCE  : illegal_alu_instr = ~is_32bit_instruction;\\n', '       FENCE_I: illegal_alu_instr = ~is_32bit_instruction;\\n', '       ECALL  : illegal_alu_instr = ~is_32bit_instruction;\\n', '       EBREAK : illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n', '       URET   : illegal_alu_instr = ~is_32bit_instruction | ~has_u;\\n', '       SRET   : illegal_alu_instr = ~is_32bit_instruction | ~has_s | (st_prv_i <  PRV_S) | (st_prv_i == PRV_S && st_tsr_i);\\n', '       MRET   : illegal_alu_instr = ~is_32bit_instruction |          (st_prv_i != PRV_M);\\n', '       default:\\n', '            casex ( {xlen32,pd_opcR} )\\n', \"              {1'b?,LUI   }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"              {1'b?,AUIPC }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b?,JAL   }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"              {1'b?,JALR  }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"              {1'b?,BEQ   }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"              {1'b?,BNE   }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"              {1'b?,BLT   }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b?,BGE   }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b?,BLTU  }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b?,BGEU  }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b?,ADDI  }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"              {1'b?,ADD   }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"              {1'b0,ADDIW }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;                       //RV64\\n\", \"              {1'b0,ADDW  }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;                       //RV64\\n\", \"              {1'b?,SUB   }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"              {1'b0,SUBW  }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;                       //RV64\\n\", \"              {1'b?,XORI  }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b?,XOR   }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"              {1'b?,ORI   }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b?,OR    }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"              {1'b?,ANDI  }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"              {1'b?,AND   }: illegal_alu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"              {1'b?,SLLI  }: illegal_alu_instr =(~is_32bit_instruction & ~has_rvc) | (xlen32 & pd_opcR.funct7[0]);   //shamt[5] illegal for RV32\\n\", \"              {1'b?,SLL   }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b0,SLLIW }: illegal_alu_instr = ~is_32bit_instruction;                                  //RV64\\n\", \"              {1'b0,SLLW  }: illegal_alu_instr = ~is_32bit_instruction;                                  //RV64\\n\", \"              {1'b?,SLTI  }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b?,SLT   }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b?,SLTIU }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b?,SLTU  }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b?,SRLI  }: illegal_alu_instr =(~is_32bit_instruction & ~has_rvc) | (xlen32 & pd_opcR.funct7[0]);   //shamt[5] illegal for RV32\\n\", \"              {1'b?,SRL   }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b0,SRLIW }: illegal_alu_instr = ~is_32bit_instruction;                                  //RV64\\n\", \"              {1'b0,SRLW  }: illegal_alu_instr = ~is_32bit_instruction;                                  //RV64\\n\", \"              {1'b?,SRAI  }: illegal_alu_instr =(~is_32bit_instruction & ~has_rvc) | (xlen32 & pd_opcR.funct7[0]);   //shamt[5] illegal for RV32\\n\", \"              {1'b?,SRA   }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b0,SRAIW }: illegal_alu_instr = ~is_32bit_instruction;\\n\", \"              {1'b?,SRAW  }: illegal_alu_instr = ~is_32bit_instruction;\\n\", '  \\n', '              //system\\n', \"              {1'b?,CSRRW }: illegal_alu_instr = ~is_32bit_instruction | illegal_csr_rd |            illegal_csr_wr;\\n\", \"              {1'b?,CSRRS }: illegal_alu_instr = ~is_32bit_instruction | illegal_csr_rd | (|pd_rs1 & illegal_csr_wr) | ~is_32bit_instruction;\\n\", \"              {1'b?,CSRRC }: illegal_alu_instr = ~is_32bit_instruction | illegal_csr_rd | (|pd_rs1 & illegal_csr_wr) | ~is_32bit_instruction;\\n\", \"              {1'b?,CSRRWI}: illegal_alu_instr = ~is_32bit_instruction | illegal_csr_rd | (|pd_rs1 & illegal_csr_wr) | ~is_32bit_instruction;\\n\", \"              {1'b?,CSRRSI}: illegal_alu_instr = ~is_32bit_instruction | illegal_csr_rd | (|pd_rs1 & illegal_csr_wr) | ~is_32bit_instruction;\\n\", \"              {1'b?,CSRRCI}: illegal_alu_instr = ~is_32bit_instruction | illegal_csr_rd | (|pd_rs1 & illegal_csr_wr) | ~is_32bit_instruction;\\n\", '\\n', \"              default: illegal_alu_instr = 1'b1;\\n\", '            endcase\\n', '        endcase\\n', '\\n', '  //LSU\\n', '  always_comb\\n', '    casex ( {xlen32,has_amo,pd_opcR} )\\n', \"      {1'b?,1'b?,LB    }: illegal_lsu_instr = ~is_32bit_instruction;\\n\", \"      {1'b?,1'b?,LH    }: illegal_lsu_instr = ~is_32bit_instruction;\\n\", \"      {1'b?,1'b?,LW    }: illegal_lsu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"      {1'b0,1'b?,LD    }: illegal_lsu_instr = ~is_32bit_instruction & ~has_rvc;  //RV64\\n\", \"      {1'b?,1'b?,LBU   }: illegal_lsu_instr = ~is_32bit_instruction;\\n\", \"      {1'b?,1'b?,LHU   }: illegal_lsu_instr = ~is_32bit_instruction;\\n\", \"      {1'b0,1'b?,LWU   }: illegal_lsu_instr = ~is_32bit_instruction;  //RV64\\n\", \"      {1'b?,1'b?,SB    }: illegal_lsu_instr = ~is_32bit_instruction;\\n\", \"      {1'b?,1'b?,SH    }: illegal_lsu_instr = ~is_32bit_instruction;\\n\", \"      {1'b?,1'b?,SW    }: illegal_lsu_instr = ~is_32bit_instruction & ~has_rvc;\\n\", \"      {1'b0,1'b?,SD    }: illegal_lsu_instr = ~is_32bit_instruction & ~has_rvc;  //RV64\\n\", '\\n', '      //AMO\\n', \"      default           : illegal_lsu_instr = 1'b1;\\n\", '    endcase\\n', '\\n', '\\n', '  //MULDIV\\n', '  always_comb\\n', '    casex ( {xlen32,pd_opcR} )\\n', \"      {1'b?,MUL    }: illegal_muldiv_instr = ~is_32bit_instruction;\\n\", \"      {1'b?,MULH   }: illegal_muldiv_instr = ~is_32bit_instruction;\\n\", \"      {1'b0,MULW   }: illegal_muldiv_instr = ~is_32bit_instruction;  //RV64\\n\", \"      {1'b?,MULHSU }: illegal_muldiv_instr = ~is_32bit_instruction;\\n\", \"      {1'b?,MULHU  }: illegal_muldiv_instr = ~is_32bit_instruction;\\n\", \"      {1'b?,DIV    }: illegal_muldiv_instr = ~is_32bit_instruction;\\n\", \"      {1'b0,DIVW   }: illegal_muldiv_instr = ~is_32bit_instruction;  //RV64\\n\", \"      {1'b?,DIVU   }: illegal_muldiv_instr = ~is_32bit_instruction;\\n\", \"      {1'b0,DIVUW  }: illegal_muldiv_instr = ~is_32bit_instruction;  //RV64\\n\", \"      {1'b?,REM    }: illegal_muldiv_instr = ~is_32bit_instruction;\\n\", \"      {1'b0,REMW   }: illegal_muldiv_instr = ~is_32bit_instruction;  //RV64\\n\", \"      {1'b?,REMU   }: illegal_muldiv_instr = ~is_32bit_instruction;\\n\", \"      {1'b0,REMUW  }: illegal_muldiv_instr = ~is_32bit_instruction;\\n\", \"      default       : illegal_muldiv_instr = 1'b1;\\n\", '    endcase\\n', '\\n', '  /*\\n', '   * Check CSR accesses\\n', '   */\\n', '  always_comb\\n', '    case (pd_insn_i.instr[31:20])\\n', '      //User\\n', '      USTATUS   : illegal_csr_rd = ~has_u;\\n', '      UIE       : illegal_csr_rd = ~has_u;\\n', '      UTVEC     : illegal_csr_rd = ~has_u;\\n', '      USCRATCH  : illegal_csr_rd = ~has_u;\\n', '      UEPC      : illegal_csr_rd = ~has_u;\\n', '      UCAUSE    : illegal_csr_rd = ~has_u;\\n', '      UTVAL     : illegal_csr_rd = ~has_u;\\n', '      UIP       : illegal_csr_rd = ~has_u;\\n', '      FFLAGS    : illegal_csr_rd = ~has_fpu;\\n', '      FRM       : illegal_csr_rd = ~has_fpu;\\n', '      FCSR      : illegal_csr_rd = ~has_fpu;\\n', '      CYCLE     : illegal_csr_rd = ~has_u                                          |\\n', '                                   (~has_s & st_prv_i == PRV_U & ~st_mcounteren_i[CY]) |\\n', '                                   ( has_s & st_prv_i == PRV_S & ~st_mcounteren_i[CY]) |\\n', '                                   ( has_s & st_prv_i == PRV_U &  st_mcounteren_i[CY] & st_scounteren_i[CY]);\\n', \"      TIME      : illegal_csr_rd = 1'b1; //trap on reading TIME. Machine mode must access external timer\\n\", '      INSTRET   : illegal_csr_rd = ~has_u                                         |\\n', '                                   (~has_s & st_prv_i == PRV_U & ~st_mcounteren_i[IR]) |\\n', '                                   ( has_s & st_prv_i == PRV_S & ~st_mcounteren_i[IR]) |\\n', '                                   ( has_s & st_prv_i == PRV_U &  st_mcounteren_i[IR] & st_scounteren_i[IR]);\\n', '      CYCLEH    : illegal_csr_rd = ~has_u | ~xlen32                                |\\n', '                                   (~has_s & st_prv_i == PRV_U & ~st_mcounteren_i[CY]) |\\n', '                                   ( has_s & st_prv_i == PRV_S & ~st_mcounteren_i[CY]) |\\n', '                                   ( has_s & st_prv_i == PRV_U &  st_mcounteren_i[CY] & st_scounteren_i[CY]);\\n', \"      TIMEH     : illegal_csr_rd = 1'b1; //trap on reading TIMEH. Machine mode must access external timer\\n\", '      INSTRETH  : illegal_csr_rd = ~has_u | ~xlen32                                |\\n', '                                   (~has_s & st_prv_i == PRV_U & ~st_mcounteren_i[IR]) |\\n', '                                   ( has_s & st_prv_i == PRV_S & ~st_mcounteren_i[IR]) |\\n', '                                   ( has_s & st_prv_i == PRV_U &  st_mcounteren_i[IR] & st_scounteren_i[IR]);\\n', '      //TODO: hpmcounters\\n', '\\n', '      //Supervisor\\n', '      SSTATUS   : illegal_csr_rd = ~has_s               | (st_prv_i < PRV_S);\\n', '      SEDELEG   : illegal_csr_rd = ~has_s               | (st_prv_i < PRV_S);\\n', '      SIDELEG   : illegal_csr_rd = ~has_s               | (st_prv_i < PRV_S);\\n', '      SIE       : illegal_csr_rd = ~has_s               | (st_prv_i < PRV_S);\\n', '      STVEC     : illegal_csr_rd = ~has_s               | (st_prv_i < PRV_S);\\n', '      SSCRATCH  : illegal_csr_rd = ~has_s               | (st_prv_i < PRV_S);\\n', '      SEPC      : illegal_csr_rd = ~has_s               | (st_prv_i < PRV_S);\\n', '      SCAUSE    : illegal_csr_rd = ~has_s               | (st_prv_i < PRV_S);\\n', '      STVAL     : illegal_csr_rd = ~has_s               | (st_prv_i < PRV_S);\\n', '      SIP       : illegal_csr_rd = ~has_s               | (st_prv_i < PRV_S);\\n', '      SATP      : illegal_csr_rd = ~has_s               | (st_prv_i < PRV_S) | (st_prv_i == PRV_S && st_tvm_i);\\n', '\\n', '      //Hypervisor\\n', '/*\\n', '      HSTATUS   : illegal_csr_rd = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HEDELEG   : illegal_csr_rd = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HIDELEG   : illegal_csr_rd = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HIE       : illegal_csr_rd = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HTVEC     : illegal_csr_rd = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HSCRATCH  : illegal_csr_rd = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HEPC      : illegal_csr_rd = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HCAUSE    : illegal_csr_rd = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HTVAL     : illegal_csr_rd = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HIP       : illegal_csr_rd = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '*/\\n', '      //Machine\\n', '      MVENDORID : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MARCHID   : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MIMPID    : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MHARTID   : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MSTATUS   : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MISA      : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MEDELEG   : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MIDELEG   : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MIE       : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MTVEC     : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MCOUNTEREN: illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MSCRATCH  : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MEPC      : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MCAUSE    : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MTVAL     : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MIP       : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPCFG0   : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPCFG1   : illegal_csr_rd =          (XLEN > 32) | (st_prv_i < PRV_M);\\n', '      PMPCFG2   : illegal_csr_rd =          (XLEN > 64) | (st_prv_i < PRV_M);\\n', '      PMPCFG3   : illegal_csr_rd =          (XLEN > 32) | (st_prv_i < PRV_M);\\n', '      PMPADDR0  : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR1  : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR2  : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR3  : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR4  : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR5  : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR6  : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR7  : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR8  : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR9  : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR10 : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR11 : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR12 : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR13 : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR14 : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      PMPADDR15 : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '      MCYCLE    : illegal_csr_rd =                        (st_prv_i < PRV_M); \\n', '      MINSTRET  : illegal_csr_rd =                        (st_prv_i < PRV_M);\\n', '     //TODO: performance counters\\n', '      MCYCLEH   : illegal_csr_rd =          (XLEN > 32) | (st_prv_i < PRV_M);\\n', '      MINSTRETH : illegal_csr_rd =          (XLEN > 32) | (st_prv_i < PRV_M);\\n', '\\n', \"      default   : illegal_csr_rd = 1'b1;\\n\", '    endcase\\n', '\\n', '  always_comb\\n', '    case (pd_insn_i.instr[31:20])\\n', '      USTATUS   : illegal_csr_wr = ~has_u;\\n', '      UIE       : illegal_csr_wr = ~has_u;\\n', '      UTVEC     : illegal_csr_wr = ~has_u;\\n', '      USCRATCH  : illegal_csr_wr = ~has_u;\\n', '      UEPC      : illegal_csr_wr = ~has_u;\\n', '      UCAUSE    : illegal_csr_wr = ~has_u;\\n', '      UTVAL     : illegal_csr_wr = ~has_u;\\n', '      UIP       : illegal_csr_wr = ~has_u;\\n', '      FFLAGS    : illegal_csr_wr = ~has_fpu;\\n', '      FRM       : illegal_csr_wr = ~has_fpu;\\n', '      FCSR      : illegal_csr_wr = ~has_fpu;\\n', \"      CYCLE     : illegal_csr_wr = 1'b1; \\n\", \"      TIME      : illegal_csr_wr = 1'b1;\\n\", \"      INSTRET   : illegal_csr_wr = 1'b1;\\n\", '      //TODO:hpmcounters\\n', \"      CYCLEH    : illegal_csr_wr = 1'b1;\\n\", \"      TIMEH     : illegal_csr_wr = 1'b1;\\n\", \"      INSTRETH  : illegal_csr_wr = 1'b1;\\n\", '      //Supervisor\\n', '      SSTATUS   : illegal_csr_wr = ~has_s               | (st_prv_i < PRV_S);\\n', '      SEDELEG   : illegal_csr_wr = ~has_s               | (st_prv_i < PRV_S);\\n', '      SIDELEG   : illegal_csr_wr = ~has_s               | (st_prv_i < PRV_S);\\n', '      SIE       : illegal_csr_wr = ~has_s               | (st_prv_i < PRV_S);\\n', '      STVEC     : illegal_csr_wr = ~has_s               | (st_prv_i < PRV_S);\\n', '      SCOUNTEREN: illegal_csr_wr = ~has_s               | (st_prv_i < PRV_S);\\n', '      SSCRATCH  : illegal_csr_wr = ~has_s               | (st_prv_i < PRV_S);\\n', '      SEPC      : illegal_csr_wr = ~has_s               | (st_prv_i < PRV_S);\\n', '      SCAUSE    : illegal_csr_wr = ~has_s               | (st_prv_i < PRV_S);\\n', '      STVAL     : illegal_csr_wr = ~has_s               | (st_prv_i < PRV_S);\\n', '      SIP       : illegal_csr_wr = ~has_s               | (st_prv_i < PRV_S);\\n', '      SATP      : illegal_csr_wr = ~has_s               | (st_prv_i < PRV_S)  | (st_prv_i == PRV_S && st_tvm_i);\\n', '\\n', '     //Hypervisor\\n', '/*\\n', '      HSTATUS   : illegal_csr_wr = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HEDELEG   : illegal_csr_wr = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HIDELEG   : illegal_csr_wr = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HIE       : illegal_csr_wr = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HTVEC     : illegal_csr_wr = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HSCRATCH  : illegal_csr_wr = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HEPC      : illegal_csr_wr = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HCAUSE    : illegal_csr_wr = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HBADADDR  : illegal_csr_wr = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '      HIP       : illegal_csr_wr = (HAS_HYPER == 0)               | (st_prv_i < PRV_H);\\n', '*/\\n', '      //Machine\\n', \"      MVENDORID : illegal_csr_wr = 1'b1;\\n\", \"      MARCHID   : illegal_csr_wr = 1'b1;\\n\", \"      MIMPID    : illegal_csr_wr = 1'b1;\\n\", \"      MHARTID   : illegal_csr_wr = 1'b1;\\n\", '      MSTATUS   : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MISA      : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MEDELEG   : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MIDELEG   : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MIE       : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MTVEC     : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MNMIVEC   : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MCOUNTEREN: illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MSCRATCH  : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MEPC      : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MCAUSE    : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MTVAL     : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MIP       : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPCFG0   : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPCFG1   : illegal_csr_wr =          (XLEN > 32) | (st_prv_i < PRV_M);\\n', '      PMPCFG2   : illegal_csr_wr =          (XLEN > 64) | (st_prv_i < PRV_M);\\n', '      PMPCFG3   : illegal_csr_wr =          (XLEN > 32) | (st_prv_i < PRV_M);\\n', '      PMPADDR0  : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR1  : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR2  : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR3  : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR4  : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR5  : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR6  : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR7  : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR8  : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR9  : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR10 : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR11 : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR12 : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR13 : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR14 : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      PMPADDR15 : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '      MCYCLE    : illegal_csr_wr =                        (st_prv_i < PRV_M); \\n', '      MINSTRET  : illegal_csr_wr =                        (st_prv_i < PRV_M);\\n', '     //TODO: performance counters\\n', '      MCYCLEH   : illegal_csr_wr =          (XLEN > 32) | (st_prv_i < PRV_M);\\n', '      MINSTRETH : illegal_csr_wr =          (XLEN > 32) | (st_prv_i < PRV_M);\\n', '\\n', \"      default   : illegal_csr_wr = 1'b1;\\n\", '    endcase\\n', '\\n', 'endmodule\\n', '\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Instruction Fetch                                            //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_if\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', '#(\\n', '  parameter                           XLEN           = 32,\\n', \"  parameter    [XLEN            -1:0] PC_INIT        = 'h200,\\n\", '  parameter                           HAS_RVC        = 0,\\n', '  parameter                           BP_GLOBAL_BITS = 2,\\n', '\\n', '  localparam                          PARCEL_SIZE    = 16\\n', ')\\n', '(\\n', '  input                               rst_ni,                   //Reset\\n', '  input                               clk_i,                    //Clock\\n', '\\n', '  output logic [XLEN            -1:0] imem_adr_o,               //next Instruction Memory location\\n', '  output                              imem_req_o,               //request new parcel from BIU (cache/bus-interface)\\n', '  input                               imem_ack_i,               //acknowledge from BIU; send new imem_adr\\n', '  output                              imem_flush_o,             //flush instruction fetch BIU (cache/bus-interface)\\n', '\\n', '  input        [XLEN            -1:0] imem_parcel_i,\\n', '  input        [XLEN/PARCEL_SIZE-1:0] imem_parcel_valid_i,\\n', '  input                               imem_parcel_misaligned_i,\\n', '  input                               imem_parcel_page_fault_i,\\n', '  input                               imem_parcel_error_i,\\n', '\\n', '  input        [BP_GLOBAL_BITS  -1:0] bu_bp_history_i,          //Branch Predictor History\\n', '  output       [BP_GLOBAL_BITS  -1:0] if_predict_history_o,     //Predictor History to BP unit\\n', '  output reg   [BP_GLOBAL_BITS  -1:0] if_bp_history_o,          //Predictor History to PD\\n', '  output logic [XLEN            -1:0] if_predict_pc_o,          //Early program counters towards predictor\\n', '  output reg   [XLEN            -1:0] if_nxt_pc_o,              //Next Program Counter\\n', '                                      if_pc_o,                  //Program Counter\\n', '  output instruction_t                if_nxt_insn_o,\\n', '                                      if_insn_o,\\n', '  output interrupts_exceptions_t      if_exceptions_o,          //Interrupts and Exceptions\\n', '  input  interrupts_exceptions_t      pd_exceptions_i,\\n', '                                      id_exceptions_i,\\n', '                                      ex_exceptions_i,\\n', '                                      mem_exceptions_i,\\n', '                                      wb_exceptions_i,\\n', '\\n', '  input        [XLEN            -1:0] pd_pc_i,\\n', '  input                               pd_stall_i,\\n', '                                      pd_flush_i,\\n', '\\t                              pd_latch_nxt_pc_i,\\n', '\\n', '  input                               bu_flush_i,               //flush pipe & load new program counter\\n', '                                      st_flush_i,\\n', '\\n', '                                      du_stall_i,\\n', '                                      du_we_pc_i,\\n', '                                      du_latch_nxt_pc_i,\\n', '\\t                              du_flush_i,\\n', '  input        [XLEN            -1:0] du_dato_i,\\n', '\\n', '  input        [XLEN            -1:0] pd_nxt_pc_i,              //pre-decoder Next Program Counter\\n', '                                      bu_nxt_pc_i,              //Branch Unit Next Program Counter\\n', '                                      st_nxt_pc_i,              //State Next Program Counter\\n', '\\n', '  input        [                 1:0] st_xlen_i                 //Current XLEN setting\\n', ');\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Constants\\n', '  //\\n', '\\n', '  //Instruction address mask\\n', \"  localparam ADR_MASK = HAS_RVC != 0 ? {XLEN{1'b1}} << 1 : {XLEN{1'b1}} << 2;\\n\", '\\n', '  //HandLe up to 2 inflight instruction fetches\\n', '  localparam INFLIGHT_CNT   = 3;\\n', '\\n', '  //Queue depth, in parcels\\n', '  localparam QUEUE_DEPTH    = 3*INFLIGHT_CNT * XLEN/PARCEL_SIZE;\\n', '\\n', '  //Halt instruction fetches when FULL_THRESHOLD (in parcels) reached\\n', '  localparam FULL_THRESHOLD = QUEUE_DEPTH - (INFLIGHT_CNT+1)*XLEN/PARCEL_SIZE;\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Functions\\n', '  //\\n', '\\n', '\\n', '  //Illegal RVC opcode\\n', '  function automatic logic rvc_is_illegal;\\n', '    input logic       xlen128, xlen64, xlen32;\\n', '    input rvc_instr_t parcel;\\n', '\\n', '    //default value\\n', '    rvc_is_illegal = 0;\\n', '\\n', '    casex ( {xlen128, xlen64, xlen32, decode_rvc_opcA(parcel)} )\\n', '\\n', \"      {3'b???,C_LWSP}    : rvc_is_illegal = parcel.CI.rd == 0\\n\", \"                                          ? 1'b1                                       //reserved ILLEGAL\\n\", \"                                          : 1'b0;\\n\", '\\n', \"      {3'b??0,C_LDSP}    : rvc_is_illegal = parcel.CI.rd == 0\\n\", \"                                          ? 1'b1                                       //reserved ILLEGAL\\n\", \"                                          : 1'b0;\\n\", '\\n', \"    //{3'b1??,C_LQSP}\\n\", \"    //{3'b??1,C_FLWSP} F-only\\n\", \"    //{3'0b??,C_FLDSP} D-only\\n\", '\\n', \"      {3'b???,C_SWSP}    : rvc_is_illegal = 1'b0;\\n\", '\\n', \"      {3'b??0,C_SDSP}    : rvc_is_illegal = 1'b0;\\n\", '\\n', \"    //{3'b1??,C_SQSP}\\n\", \"    //{3'b??1,C_FSWSP}  F-only\\n\", \"    //{3'b0??,C_FSDSP}  D-only\\n\", '\\n', \"      {3'b???,C_LW}      : rvc_is_illegal = 1'b0;\\n\", '\\n', \"      {3'b??0,C_LD}      : rvc_is_illegal = 1'b0;\\n\", '\\n', \"    //{3'b1??,C_LQ}\\n\", \"    //{3'b??1,C_FLW} F-only\\n\", \"    //{3'b0??,C_FLD} D-only\\n\", '\\n', \"      {3'b???,C_SW}      : rvc_is_illegal = 1'b0;\\n\", '\\n', \"      {3'b??0,C_SD}      : rvc_is_illegal = 1'b0;\\n\", '\\n', \"    //{3'b1??,C_SQ}\\n\", \"    //{3'b??1,C_FSW} F-only\\n\", \"    //{3'b0??,C_FSD} D-only\\n\", ' \\n', \"      {3'b???,C_J}       : rvc_is_illegal = 1'b0;\\n\", '\\n', \"      {3'b??1,C_JAL}     : rvc_is_illegal = 1'b0;\\n\", '\\n', '      //C.JR and C.MV\\n', \"      {3'b???,C_JR}      : rvc_is_illegal = parcel.CR.rs2 != 0\\n\", \"\\t\\t\\t\\t          ? 1'b0\\n\", '                                          : parcel.CR.rd == 0\\n', \"\\t\\t\\t\\t          ? 1'b1\\n\", \"                                          : 1'b0;\\n\", '\\n', '      //C.JALR and and C.ADD and C.EBREAK\\n', \"      {3'b???,C_JALR}    : rvc_is_illegal = 1'b0;\\n\", '\\n', \"      {3'b???,C_BEQZ}    : rvc_is_illegal = 1'b0;\\n\", '\\n', \"      {3'b???,C_BNEZ}    : rvc_is_illegal = 1'b0;\\n\", '\\n', \"      {3'b???,C_LI}      : rvc_is_illegal = 1'b0;\\n\", '\\n', '      //C.LUI and C.ADDI16SP\\n', \"      {3'b???,C_ADDI16SP}: rvc_is_illegal = {parcel.CI.pos12,parcel.CI.pos6_2} == 0\\n\", \"                                          ? 1'b1\\n\", \"                                          : 1'b0;\\n\", '\\n', '      //C.NOP and C.ADDI\\n', \"      {3'b???,C_ADDI}    : rvc_is_illegal = 1'b0;\\n\", '\\n', \"      {3'b??0,C_ADDIW}   : rvc_is_illegal = parcel.CI.rd == 0\\n\", \"                                          ? 1'b1\\n\", \"                                          : 1'b0;\\n\", '\\n', \"      {3'b???,C_ADDI4SPN}: rvc_is_illegal = (parcel[12:5] == 5'h0)                     //nzuimm=0 is illegal\\n\", \"                                          ? 1'b1\\n\", \"                                          : 1'b0;\\n\", '\\n', \"      {3'b???,C_SLLI}    : rvc_is_illegal = 1'b0;\\n\", '\\n', \"      {3'b???,C_SRLI}    : rvc_is_illegal = 1'b0;\\n\", '\\n', \"      {3'b???,C_SRAI}    : rvc_is_illegal = 1'b0;\\n\", '\\n', \"      {3'b???,C_ANDI}    : rvc_is_illegal = 1'b0;\\n\", \"      {3'b???,C_AND}     : rvc_is_illegal = 1'b0;\\n\", \"      {3'b???,C_OR}      : rvc_is_illegal = 1'b0;\\n\", \"      {3'b???,C_XOR}     : rvc_is_illegal = 1'b0;\\n\", \"      {3'b???,C_SUB}     : rvc_is_illegal = 1'b0;\\n\", \"      {3'b??0,C_ADDW}    : rvc_is_illegal = 1'b0;\\n\", \"      {3'b??0,C_SUBW}    : rvc_is_illegal = 1'b0;\\n\", '\\n', \"      default            : rvc_is_illegal = 1'b1;\\n\", '    endcase\\n', '  endfunction: rvc_is_illegal;\\n', '\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '\\n', '  logic                   has_rvc,\\n', '                          xlen32,\\n', '                          xlen64,\\n', '                          xlen128;\\n', '\\n', '  logic                   flushes;\\n', '  logic                   ddu_we_pc,\\n', '                          du_we_pc_strb;\\n', '\\n', '\\n', '  //Parcel queue signals\\n', '  logic                   parcel_misaligned;\\n', '  logic                   parcel_page_fault;\\n', '  logic                   parcel_error;\\n', '  logic                   parcel_queue_full;\\n', '  logic                   parcel_queue_empty;\\n', '\\n', '  logic [            1:0] parcel_queue_rd;\\n', '\\n', '  logic                   parcel_valid;\\n', '  instr_t                 parcel34,            //parcels 3&4 from queue\\n', '                          parcel12,            //parcels 1&2 from queue\\n', '                          rv_instr;\\n', '  rvc_instr_t             rvc_parcel1,\\n', '                          rvc_parcel2;\\n', '  logic                   rvc_illegal;\\n', '\\n', '  interrupts_exceptions_t parcel_exceptions;\\n', '\\n', '\\n', '  //Instruction length decoding\\n', '  logic                   is_16bit_instruction;\\n', '  logic                   is_32bit_instruction;\\n', '//  logic             is_48bit_instruction;\\n', '//  logic             is_64bit_instruction;\\n', '\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '  assign has_rvc = (HAS_RVC != 0);\\n', '\\n', '\\n', '  //Create strobed PC write signal\\n', '  always @(posedge clk_i)\\n', '    ddu_we_pc <= du_we_pc_i;\\n', '\\n', '  assign du_we_pc_strb = du_we_pc_i & ~ddu_we_pc;\\n', '\\n', '  \\n', '  /*\\n', '   * Next Parcel\\n', '   * Ideally the CPU would issue a new PC and receive the instruction on the\\n', \"   * next cycle. Unfortunately that's not possible due to the registered\\n\", '   * (input and sometimes output) of new (FPGA) memories\\n', '   * Therefore we generated a linear stream of addresses and assume the\\n', '   * CPU executes sequentially (which is a fair assumption for a program)\\n', '   * The received parcels (unit of instruction size: 16bits) are pushed into\\n', '   *  a shift register, from which then the actual instructions are extracted\\n', '   *\\n', '   * A flush means the parcel shift register and the upstream bus interface\\n', '   * unit (BIU) must be flushed\\n', '   */\\n', '\\n', '  //All flush signals\\n', '  assign flushes = pd_flush_i | du_flush_i;\\n', '  assign xlen32  = st_xlen_i == RV32I;\\n', '  assign xlen64  = st_xlen_i == RV64I;\\n', '  assign xlen128 = st_xlen_i == RV128I;\\n', '\\n', '\\n', '  //request new parcel when parcel_queue not full and no flushes\\n', '  assign imem_req_o = ~parcel_queue_full & ~flushes & ~du_stall_i;\\n', '\\n', '\\n', '  //Instruction Memory Address generator\\n', '  //Branches can go to misaligned addresses, however next address is aligned\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if      (!rst_ni     ) imem_adr_o <= PC_INIT     & ADR_MASK;\\n', '    else if ( st_flush_i ) imem_adr_o <= st_nxt_pc_i & ADR_MASK;\\n', '    else if ( du_stall_i ) imem_adr_o <= if_nxt_pc_o & ADR_MASK;\\n', '    else if ( bu_flush_i ) imem_adr_o <= bu_nxt_pc_i & ADR_MASK;\\n', '    else\\n', '    begin\\n', '        if      ( pd_latch_nxt_pc_i        ) imem_adr_o <= pd_nxt_pc_i & ADR_MASK;\\n', \"        else if ( imem_req_o && imem_ack_i ) imem_adr_o <= (imem_adr_o + (XLEN/8)) & ( {XLEN{1'b1}} << $clog2(XLEN/8) );\\n\", '    end\\n', '\\n', '\\n', '  //Flush upper layer (memory BIU) \\n', '  assign imem_flush_o = flushes | pd_latch_nxt_pc_i | du_latch_nxt_pc_i;\\n', '\\n', '  \\n', '  /*\\n', '   * Received parcels are pushed into a parcel queue\\n', \"   * There's extra room in the queue to adjust for any\\n\", '   * pipeline stalls while parcels are in flight\\n', '   */\\n', '  riscv_parcel_queue #(\\n', '    .DEPTH                   ( QUEUE_DEPTH      ),\\n', '    .WR_PARCELS              ( XLEN/PARCEL_SIZE ),\\n', '    .RD_PARCELS              ( 4                ), //max 32bit instructions\\n', '    .ALMOST_EMPTY_THRESHOLD  ( 1                ), //must update for marco-fusion\\n', '    .ALMOST_FULL_THRESHOLD   ( FULL_THRESHOLD   )\\n', '  )\\n', '  parcel_queue_inst (\\n', '    .rst_ni              ( rst_ni                     ),\\n', '    .clk_i               ( clk_i                      ),\\n', '\\n', '    .flush_i             ( imem_flush_o               ),\\n', '\\n', '    .parcel_i            ( imem_parcel_i              ),\\n', '    .parcel_valid_i      ( imem_parcel_valid_i        ),\\n', '    .parcel_misaligned_i ( imem_parcel_misaligned_i   ),\\n', '    .parcel_page_fault_i ( imem_parcel_page_fault_i   ),\\n', '    .parcel_error_i      ( imem_parcel_error_i        ),\\n', '\\n', \"    .parcel_rd_i         ( {1'b0,parcel_queue_rd}     ),\\n\", '    .parcel_q_o          ( {parcel34,parcel12} ),\\n', '    .parcel_misaligned_o ( parcel_misaligned          ),\\n', '    .parcel_page_fault_o ( parcel_page_fault          ),\\n', '    .parcel_error_o      ( parcel_error               ),\\n', '\\n', '    //use almost_empty, because we (can) read more than 1 parcel (16bit) at a time\\n', '    .almost_empty_o      ( parcel_queue_empty         ),\\n', '    .almost_full_o       ( parcel_queue_full          ),\\n', '    .empty_o             (                            ),\\n', '    .full_o              (                            ) );\\n', ' \\n', '\\n', '  //queue points to valid parcel\\n', '  assign parcel_valid = ~parcel_queue_empty;\\n', '\\n', '\\n', '  //instruction lenght decoding\\n', '  assign is_16bit_instruction = ~&parcel12[1:0];\\n', '  assign is_32bit_instruction = ~&parcel12[4:2] & &parcel12[1:0];\\n', \"//  assign is_48bit_instruction =   parcel12[5:0] == 6'b011111;\\n\", \"//  assign is_64bit_instruction =   parcel12[6:0] == 7'b0111111;\\n\", '\\n', '\\n', '  //queue read signal\\n', '  assign parcel_queue_rd = {~pd_stall_i & ~du_stall_i & parcel_valid & is_32bit_instruction,\\n', '                            ~pd_stall_i & ~du_stall_i & parcel_valid & is_16bit_instruction};\\n', '\\n', '\\n', '  //assign parcel exception signals\\n', '  always_comb\\n', '  begin\\n', '      parcel_exceptions = 0;\\n', '      parcel_exceptions.exceptions.misaligned_instruction   = parcel_valid & parcel_misaligned;\\n', '      parcel_exceptions.exceptions.instruction_access_fault = parcel_valid & parcel_error;\\n', '      parcel_exceptions.exceptions.instruction_page_fault   = parcel_valid & parcel_page_fault;\\n', '\\n', '      parcel_exceptions.any                                 = |parcel_exceptions.exceptions;\\n', '  end\\n', '\\n', '  /*\\n', '   * Instruction Translation (RVC -> RV, op-fusion)\\n', '   */\\n', '\\n', '  //\\n', '  // Macro Fusion\\n', '  //\\n', '\\n', '  //                         f3  opcode(ADDI) opcode(AUIPC)\\n', \"  parameter AUIPC_ADDI = 17'b000_00100_11_____01101_11;\\n\", '//  always_comb\\n', '//    casex\\n', '//    endcase\\n', '\\n', '\\n', '  //\\n', '  //RVC\\n', '  //\\n', '  assign rvc_parcel1 = parcel12.instr[15: 0];\\n', '  assign rvc_parcel2 = parcel12.instr[31:16];\\n', '\\n', '\\n', '  //Instruction Bubble\\n', '  assign if_nxt_insn_o.bubble = flushes | ~parcel_valid;\\n', '\\n', '\\n', '   //RVC Illegal Instruction\\n', '  always_comb\\n', '    if (!has_rvc || !is_16bit_instruction)\\n', \"      rvc_illegal = 1'b0;\\n\", '    else\\n', '      rvc_illegal = rvc_is_illegal(xlen128, xlen64, xlen32, rvc_parcel1);\\n', '\\n', '/*\\t    \\n', '    casex ( {xlen128, xlen64, xlen32, decode_rvc_opcA(rvc_parcel1)} )\\n', '\\n', \"      {3'b???,C_LWSP}    : rvc_illegal = rvc_parcel1.CI.rd == 0\\n\", \"                                       ? 1'b1                                          //reserved ILLEGAL\\n\", \"                                       : 1'b0;\\n\", '\\n', \"      {3'b??0,C_LDSP}    : rvc_illegal = rvc_parcel1.CI.rd == 0\\n\", \"                                       ? 1'b1                                          //reserved ILLEGAL\\n\", \"                                       : 1'b0;\\n\", '\\n', \"    //{3'b1??,C_LQSP}\\n\", \"    //{3'b??1,C_FLWSP} F-only\\n\", \"    //{3'0b??,C_FLDSP} D-only\\n\", '\\n', \"      {3'b???,C_SWSP}    : rvc_illegal = 1'b0;\\n\", '\\n', \"      {3'b??0,C_SDSP}    : rvc_illegal = 1'b0;\\n\", '\\n', \"    //{3'b1??,C_SQSP}\\n\", \"    //{3'b??1,C_FSWSP}  F-only\\n\", \"    //{3'b0??,C_FSDSP}  D-only\\n\", '\\n', \"      {3'b???,C_LW}      : rvc_illegal = 1'b0;\\n\", '\\n', \"      {3'b??0,C_LD}      : rvc_illegal = 1'b0;\\n\", '\\n', \"    //{3'b1??,C_LQ}\\n\", \"    //{3'b??1,C_FLW} F-only\\n\", \"    //{3'b0??,C_FLD} D-only\\n\", '\\n', \"      {3'b???,C_SW}      : rvc_illegal = 1'b0;\\n\", '\\n', \"      {3'b??0,C_SD}      : rvc_illegal = 1'b0;\\n\", '\\n', \"    //{3'b1??,C_SQ}\\n\", \"    //{3'b??1,C_FSW} F-only\\n\", \"    //{3'b0??,C_FSD} D-only\\n\", ' \\n', \"      {3'b???,C_J}       : rvc_illegal = 1'b0;\\n\", '\\n', \"      {3'b??1,C_JAL}     : rvc_illegal = 1'b0;\\n\", '\\n', '      //C.JR and C.MV\\n', \"      {3'b???,C_JR}      : rvc_illegal = rvc_parcel1.CR.rs2 != 0\\n\", \"\\t\\t\\t\\t       ? 1'b0\\n\", '                                       : rvc_parcel1.CR.rd == 0\\n', \"\\t\\t\\t\\t       ? 1'b1\\n\", \"                                       : 1'b0;\\n\", '\\n', '      //C.JALR and and C.ADD and C.EBREAK\\n', \"      {3'b???,C_JALR}    : rvc_illegal = 1'b0;\\n\", '\\n', \"      {3'b???,C_BEQZ}    : rvc_illegal = 1'b0;\\n\", '\\n', \"      {3'b???,C_BNEZ}    : rvc_illegal = 1'b0;\\n\", '\\n', \"      {3'b???,C_LI}      : rvc_illegal = 1'b0;\\n\", '\\n', '      //C.LUI and C.ADDI16SP\\n', \"      {3'b???,C_ADDI16SP}: rvc_illegal = {rvc_parcel1.CI.pos12,rvc_parcel1.CI.pos6_2} == 0\\n\", \"                                       ? 1'b1\\n\", \"                                       : 1'b0;\\n\", '\\n', '      //C.NOP and C.ADDI\\n', \"      {3'b???,C_ADDI}    : rvc_illegal = 1'b0;\\n\", '\\n', \"      {3'b??0,C_ADDIW}   : rvc_illegal = rvc_parcel1.CI.rd == 0\\n\", \"                                       ? 1'b1\\n\", \"                                       : 1'b0;\\n\", '\\n', \"      {3'b???,C_ADDI4SPN}: rvc_illegal = (rvc_parcel1 == 16'h0)                         //All zeros is defined illegal\\n\", \"                                       ? 1'b1\\n\", \"                                       : 1'b0;\\n\", '\\n', \"      {3'b???,C_SLLI}    : rvc_illegal = 1'b0;\\n\", '\\n', \"      {3'b???,C_SRLI}    : rvc_illegal = 1'b0;\\n\", '\\n', \"      {3'b???,C_SRAI}    : rvc_illegal = 1'b0;\\n\", '\\n', \"      {3'b???,C_ANDI}    : rvc_illegal = 1'b0;\\n\", \"      {3'b???,C_AND}     : rvc_illegal = 1'b0;\\n\", \"      {3'b???,C_OR}      : rvc_illegal = 1'b0;\\n\", \"      {3'b???,C_XOR}     : rvc_illegal = 1'b0;\\n\", \"      {3'b???,C_SUB}     : rvc_illegal = 1'b0;\\n\", \"      {3'b??0,C_ADDW}    : rvc_illegal = 1'b0;\\n\", \"      {3'b??0,C_SUBW}    : rvc_illegal = 1'b0;\\n\", '\\n', \"      default            : rvc_illegal = 1'b1;\\n\", '    endcase\\n', '*/\\n', '\\n', '\\n', '  //Instruction conversion RVC-->RV\\n', '  always_comb\\n', '    if (has_rvc && is_16bit_instruction) //Convert RVC to RV\\n', '    casex ( {xlen128, xlen64, xlen32, decode_rvc_opcA(rvc_parcel1)} )\\n', '\\n', \"      {3'b???,C_LWSP}    : rv_instr = rvc_parcel1.CI.rd == 0\\n\", \"                                    ? {{XLEN-16{1'b0}},rvc_parcel1}                    //reserved ILLEGAL\\n\", '                                    : encode_I (LW,                                    //C.LWSP=lw rd,imm(x2)\\n', '                                                rvc_parcel1.CI.rd,\\n', \"                                                rsd_t'             ( 5'h2      ),      //x2\\n\", '                                                rvc_decode_immCIWSP(rvc_parcel1),\\n', '                                                rvc_parcel1.CI.size\\n', '                                               );\\n', '\\n', '\\n', \"      {3'b??0,C_LDSP}    : rv_instr = rvc_parcel1.CI.rd == 0\\n\", \"                                    ? {{XLEN-16{1'b0}},rvc_parcel1}                    //reserved ILLEGAL\\n\", '                                    : encode_I (LD,                                    //C.LDSP=ld rd,imm(x2)\\n', '                                                rvc_parcel1.CI.rd,\\n', \"                                                rsd_t'             ( 5'h2      ),\\n\", '                                                rvc_decode_immCIDSP(rvc_parcel1),      //x2\\n', '                                                rvc_parcel1.CI.size\\n', '                                               );\\n', '\\n', '\\n', \"    //{3'b1??,C_LQSP}\\n\", \"    //{3'b??1,C_FLWSP} F-only\\n\", \"    //{3'0b??,C_FLDSP} D-only\\n\", '\\n', \"      {3'b???,C_SWSP}    : rv_instr = encode_S (SW,                                    //C.SWSP=sw rs2,imm(x2)\\n\", \"                                                rsd_t'              ( 5'h2      ),     //x2\\n\", '                                                rvc_parcel1.CSS.rs2,\\n', '                                                rvc_decode_immCSSWSP(rvc_parcel1),\\n', '                                                rvc_parcel1.CSS.size\\n', '                                               );\\n', '\\n', '\\n', \"      {3'b??0,C_SDSP}    : rv_instr = encode_S(SD,                                     //C.SDSP=sd rs2,imm(x2)\\n\", \"                                               rsd_t'              ( 5'h2      ),      //x2\\n\", '                                               rvc_parcel1.CSS.rs2,\\n', '                                               rvc_decode_immCSSDSP(rvc_parcel1),\\n', '                                               rvc_parcel1.CSS.size\\n', '                                              );\\n', '\\n', '\\n', \"    //{3'b1??,C_SQSP}\\n\", \"    //{3'b??1,C_FSWSP}  F-only\\n\", \"    //{3'b0??,C_FSDSP}  D-only\\n\", '\\n', \"      {3'b???,C_LW}      : rv_instr = encode_I (LW,                                    //C.LW=lw rd',imm(rs1')\\n\", '                                                rvc_rsdp2rsd     (rvc_parcel1.CL.rd ),\\n', '                                                rvc_rsdp2rsd     (rvc_parcel1.CL.rs1),\\n', '\\t\\t\\t\\t\\t        rvc_decode_immCLW(rvc_parcel1       ),\\n', '                                                rvc_parcel1.CL.size\\n', '                                               );\\n', '\\n', '\\n', \"      {3'b??0,C_LD}      : rv_instr = encode_I (LD,                                    //C.LD=ld rd',imm(rs1')\\n\", '                                                rvc_rsdp2rsd     (rvc_parcel1.CL.rd ),\\n', '                                                rvc_rsdp2rsd     (rvc_parcel1.CL.rs1),\\n', '\\t\\t\\t\\t\\t        rvc_decode_immCLD(rvc_parcel1       ),\\n', '                                                rvc_parcel1.CL.size\\n', '                                               );\\n', '\\n', '\\n', \"    //{3'b1??,C_LQ}\\n\", \"    //{3'b??1,C_FLW} F-only\\n\", \"    //{3'b0??,C_FLD} D-only\\n\", '\\n', \"      {3'b???,C_SW}      : rv_instr = encode_S (SW,                                    //C.SW=sw rs2',imm(rs1')\\n\", '                                                rvc_rsdp2rsd     (rvc_parcel1.CS.rs1),\\n', '                                                rvc_rsdp2rsd     (rvc_parcel1.CS.rs2),\\n', '                                                rvc_decode_immCSW(rvc_parcel1       ),\\n', '                                                rvc_parcel1.CS.size\\n', '                                               );\\n', '\\n', '\\n', \"      {3'b??0,C_SD}      : rv_instr = encode_S (SD,                                    //C.SD=sd rs2',imm(rs1')\\n\", '                                                rvc_rsdp2rsd     (rvc_parcel1.CS.rs1),\\n', '                                                rvc_rsdp2rsd     (rvc_parcel1.CS.rs2),\\n', '                                                rvc_decode_immCSD(rvc_parcel1       ),\\n', '\\t\\t\\t\\t\\t        rvc_parcel1.CS.size\\n', '                                               );\\n', '\\n', '\\n', \"    //{3'b1??,C_SQ}\\n\", \"    //{3'b??1,C_FSW} F-only\\n\", \"    //{3'b0??,C_FSD} D-only\\n\", ' \\n', \"      {3'b???,C_J}       : rv_instr = encode_UJ(JAL,                                   //C.J=jal x0,imm\\n\", \"                                                rsd_t'          ( 5'h0      ),         //x0\\n\", '                                                rvc_decode_immCJ(rvc_parcel1),\\n', '                                                rvc_parcel1.CJ.size\\n', '                                               );\\n', '\\n', '\\n', \"      {3'b??1,C_JAL}     : rv_instr = encode_UJ(JAL,                                   //C.JAL=jal x1,imm\\n\", \"                                                rsd_t'          ( 5'h1      ),         //x1\\n\", '                                                rvc_decode_immCJ(rvc_parcel1),\\n', '                                                rvc_parcel1.CJ.size\\n', '                                               );\\n', '\\n', '      //C.JR and C.MV\\n', \"      {3'b???,C_JR}      : rv_instr = rvc_parcel1.CR.rs2 != 0\\n\", '\\t\\t\\t\\t    ? encode_R(ADD,                                    //C.MV=add rd,x0,rs2\\n', '                                               rvc_parcel1.CR.rd,                      //rd=x0-->hints\\n', \"                                               rsd_t' (5'h0),                          //x0\\n\", '                                               rvc_parcel1.CR.rs2,\\n', '                                               rvc_parcel1.CR.size\\n', '                                              )\\n', '                                    : rvc_parcel1.CR.rd == 0\\n', \"\\t\\t\\t\\t    ? {{XLEN-16{1'b0}},rvc_parcel1}                    //reserved ILLEGAL\\n\", '                                    : encode_I (JALR,                                  //C.JR=jalr x0, 0(rd)\\n', \"                                                rsd_t'(0),                             //x0\\n\", '\\t\\t\\t\\t\\t\\trvc_parcel1.CR.rd,\\n', \"\\t\\t\\t\\t\\t\\timmI_t'(0),                            //imm=0\\n\", '                                                rvc_parcel1.CR.size\\n', '                                               );\\n', '\\n', '\\n', '      //C.JALR and and C.ADD and C.EBREAK\\n', \"      {3'b???,C_JALR}    : rv_instr = rvc_parcel1.CR.rs2 != 0\\n\", '                                    ? encode_R(ADD,                                    //C.ADD=add rd,rd,rs2\\n', '                                               rvc_parcel1.CR.rd,                      //rd=x0-->hints\\n', '                                               rvc_parcel1.CR.rd,\\n', '                                               rvc_parcel1.CR.rs2,\\n', '                                               rvc_parcel1.CR.size\\n', '                                              )\\n', '                                    : rvc_parcel1.CR.rd != 0\\n', '                                    ? encode_I (JALR,                                  //C.JALR=jalr x1,0(rd)\\n', \"                                                rsd_t'(5'h1),                          //x1\\n\", '                                                rvc_parcel1.CR.rd,\\n', \"                                                immI_t'(0),                            //imm=0\\n\", '                                                rvc_parcel1.CJ.size\\n', '                                               )\\n', '                                    : EBREAK;                                          //C.EBREAK\\n', '\\n', '\\n', \"      {3'b???,C_BEQZ}    : rv_instr = encode_SB(BEQ,                                   //C.BEQZ=beq rs1',x0,imm\\n\", '                                                rvc_rsdp2rsd    ( rvc_parcel1.CB.rs1),\\n', \"                                                rsd_t'          ( 5'h0              ), //x0\\n\", '                                                rvc_decode_immCB(rvc_parcel1        ),\\n', '                                                rvc_parcel1.CB.size\\n', '                                               );\\n', '\\n', '\\n', \"      {3'b???,C_BNEZ}    : rv_instr = encode_SB(BNE,                                   //C.BNEZ=bne rs1',x0,imm\\n\", '                                                rvc_rsdp2rsd    ( rvc_parcel1.CB.rs1),\\n', \"                                                rsd_t'          ( 5'h0              ), //x0\\n\", '                                                rvc_decode_immCB(rvc_parcel1        ),\\n', '                                                rvc_parcel1.CB.size\\n', '                                               );\\n', '\\n', '\\n', \"      {3'b???,C_LI}      : rv_instr = encode_I (ADDI,                                  //C.LI=addi rd,x0,imm\\n\", '                                                rvc_parcel1.CI.rd,\\n', \"                                                rsd_t'          (5'h0        ),        //x0\\n\", '                                                rvc_decode_immCI(rvc_parcel1 ),\\n', '                                                rvc_parcel1.CI.size\\n', '                                               );\\n', '\\n', '      //C.LUI and C.ADDI16SP\\n', \"      {3'b???,C_ADDI16SP}: rv_instr = {rvc_parcel1.CI.pos12,rvc_parcel1.CI.pos6_2} == 0\\n\", \"                                    ? {{XLEN-16{1'b0}},rvc_parcel1}                    //reserved ILLEGAL\\n\", '                                    : rvc_parcel1.CI.rd == 2\\n', '                                    ? encode_I (ADDI,                                  //C.ADDI16SP=addi x2,x2,imm\\n', \"                                                rsd_t'           (5'h2        ),       //x2\\n\", \"                                                rsd_t'           (5'h2        ),       //x2\\n\", '                                                rvc_decode_immCI4(rvc_parcel1 ),\\n', '                                                rvc_parcel1.CI.size\\n', '                                               )\\n', '                                    : encode_U (LUI,                                   //C.LUI=lui rd,imm\\n', '                                                rvc_parcel1.CI.rd,                     //rd=x0-->hints\\n', '                                                rvc_decode_immCI12(rvc_parcel1),\\n', '                                                rvc_parcel1.CI.size\\n', '                                               );\\n', '\\n', '\\n', '      //C.NOP and C.ADDI\\n', \"      {3'b???,C_ADDI}    : rv_instr = rvc_parcel1.CI.rd == 0\\n\", '                                    ? NOP                                              //NOP\\n', '                                    : encode_I (ADDI,                                  //C.ADDI=addi rd,rd,imm\\n', '                                                rvc_parcel1.CI.rd,\\n', '                                                rvc_parcel1.CI.rd,\\n', '                                                rvc_decode_immCI(rvc_parcel1  ),       //imm=0-->hint\\n', '                                                rvc_parcel1.CI.size\\n', '                                               );\\n', '\\n', '\\n', \"      {3'b??0,C_ADDIW}   : rv_instr = rvc_parcel1.CI.rd == 0\\n\", \"                                    ? {{XLEN-16{1'b0}},rvc_parcel1}                    //reserved ILLEGAL\\n\", '                                    : encode_I (ADDIW,                                 //C.ADDIW=addiw rd,rd,imm\\n', '                                                rvc_parcel1.CI.rd,\\n', '                                                rvc_parcel1.CI.rd,\\n', '                                                rvc_decode_immCI(rvc_parcel1 ),\\n', '                                                rvc_parcel1.CI.size\\n', '                                               );\\n', '\\n', '\\n', \"      {3'b???,C_ADDI4SPN}: rv_instr = (rvc_parcel1 == 16'h0)                           //All zeros is defined illegal\\n\", \"                                    ? {{XLEN-16{1'b0}},rvc_parcel1}                    //illegal instruction (definition)\\n\", '                                    : encode_I (ADDI,\\n', '                                                rvc_rsdp2rsd     (rvc_parcel1.CIW.rd),\\n', \"                                                rsd_t'           (5'h2             ),  //x2\\n\", '                                                rvc_decode_immCIW(rvc_parcel1       ),\\n', '                                                rvc_parcel1.CIW.size\\n', '                                               );\\n', '\\n', '\\n', \"      {3'b???,C_SLLI}    : rv_instr = encode_Ishift(SLLI,                              //C.SLLI=slli rd,rd,imm\\n\", '                                               rvc_parcel1.CI.rd,\\n', '                                               rvc_parcel1.CI.rd,\\n', '                                               rvc_decode_immCI(rvc_parcel1 ),         //imm=0-->hint (RV32/64)\\n', '                                               rvc_parcel1.CI.size\\n', '                                              );\\n', '\\n', '\\n', \"      {3'b???,C_SRLI}    : rv_instr = encode_Ishift(SRLI,                              //C.SRLI=srli rd',rd',imm\\n\", '                                               rvc_rsdp2rsd     (rvc_parcel1.CIB.rd),\\n', '                                               rvc_rsdp2rsd     (rvc_parcel1.CIB.rd),\\n', '                                               rvc_decode_immCIB(rvc_parcel1       ),\\n', '                                               rvc_parcel1.CIB.size\\n', '                                              );\\n', '\\n', '\\n', \"      {3'b???,C_SRAI}    : rv_instr = encode_Ishift(SRAI,                              //C.SRAI=srai rd',rd',imm\\n\", '                                               rvc_rsdp2rsd     (rvc_parcel1.CIB.rd),\\n', '                                               rvc_rsdp2rsd     (rvc_parcel1.CIB.rd),\\n', '                                               rvc_decode_immCIB(rvc_parcel1       ),\\n', '                                               rvc_parcel1.CIB.size\\n', '                                              );\\n', '\\n', '\\n', \"      {3'b???,C_ANDI}    : rv_instr = encode_I(ANDI,                                   //C.ANDI=andi rd',rd',imm\\n\", '                                               rvc_rsdp2rsd     (rvc_parcel1.CIB.rd ),\\n', '                                               rvc_rsdp2rsd     (rvc_parcel1.CIB.rd ),\\n', '                                               rvc_decode_immCIB(rvc_parcel1        ),\\n', '                                               rvc_parcel1.CIB.size\\n', '                                              );\\n', '\\n', '\\n', \"      {3'b???,C_AND}     : rv_instr = encode_R(AND,                                    //C.AND=and rd',rd',rs2'\\n\", '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rd ),\\n', '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rd ),\\n', '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rs2),\\n', '                                               rvc_parcel1.CR.size\\n', '                                              );\\n', '\\n', '\\n', \"      {3'b???,C_OR}      : rv_instr = encode_R(OR,                                     //C.OR=or rd',rd',rs2'\\n\", '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rd ),\\n', '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rd ),\\n', '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rs2),\\n', '                                               rvc_parcel1.CR.size\\n', '                                              );\\n', '\\n', '\\n', \"      {3'b???,C_XOR}     : rv_instr = encode_R(XOR,                                    //C.XOR=xor rd',rd',rs2'\\n\", '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rd ),\\n', '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rd ),\\n', '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rs2),\\n', '                                               rvc_parcel1.CR.size\\n', '                                              );\\n', '\\n', '\\n', \"      {3'b???,C_SUB}     : rv_instr = encode_R(SUB,                                    //C.SUB=sub rd',rd',rs2'\\n\", '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rd ),\\n', '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rd ),\\n', '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rs2),\\n', '                                               rvc_parcel1.CR.size\\n', '                                              );\\n', '\\n', '\\n', \"      {3'b??0,C_ADDW}    : rv_instr = encode_R(ADDW,                                   //C.ADDW=addw rd',rd',rs2'\\n\", '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rd ),\\n', '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rd ),\\n', '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rs2),\\n', '                                               rvc_parcel1.CR.size\\n', '                                              );\\n', '\\n', '\\n', \"      {3'b??0,C_SUBW}    : rv_instr = encode_R(SUBW,                                   //C.SUBS=subw rd',rd',rs2'\\n\", '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rd ),\\n', '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rd ),\\n', '                                               rvc_rsdp2rsd (rvc_parcel1.CR.rs2),\\n', '                                               rvc_parcel1.CR.size\\n', '                                              );\\n', '\\n', '\\n', \"      default            : rv_instr = {{XLEN-16{1'b0}},rvc_parcel1};                    //ILLEGAL\\n\", '    endcase\\n', '    else    //32bit instructions\\n', '    case(parcel12)\\n', '      WFI    : rv_instr = NOP;            //Implement WFI as a nop \\n', '      default: rv_instr = parcel12;\\n', '    endcase\\n', '\\n', '\\n', '    assign if_nxt_insn_o.instr = rv_instr;\\n', '\\n', '\\n', '  /*\\n', '   * IF Outputs\\n', '   */\\n', '\\n', '\\n', '  //Next Program Counter\\n', '\\n', '  //Combinatorial to Predictor predict_pc is registered by the memory address\\n', '  //register. Then we can use registered output to reduce critical path\\n', '  always_comb\\n', '    if      ( st_flush_i        ) if_predict_pc_o = st_nxt_pc_i    & ADR_MASK;\\n', '    else if ( du_we_pc_strb     ) if_predict_pc_o = du_dato_i      & ADR_MASK; \\n', '    else if ( bu_flush_i        ) if_predict_pc_o = bu_nxt_pc_i    & ADR_MASK;\\n', '    else if ( pd_latch_nxt_pc_i ) if_predict_pc_o = pd_nxt_pc_i    & ADR_MASK; //pd_flush absolutely breaks the CPU here\\n', '    else if (!pd_stall_i           &&\\n', '\\t     !if_nxt_insn_o.bubble &&\\n', '\\t     !du_stall_i)\\n', '      if (is_16bit_instruction)   if_predict_pc_o = if_nxt_pc_o +2 & ADR_MASK;\\n', '      else                        if_predict_pc_o = if_nxt_pc_o +4 & ADR_MASK;\\n', '    else                          if_predict_pc_o = if_nxt_pc_o    & ADR_MASK;\\n', '\\n', '\\n', '  //BP history aligned with predict PC\\n', '  assign if_predict_history_o = bu_bp_history_i;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if (!rst_ni ) if_nxt_pc_o <= PC_INIT;\\n', '    else          if_nxt_pc_o <= if_predict_pc_o;\\n', '\\n', '\\n', '    \\n', '  //Current Program Counter\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if      (!rst_ni        ) if_pc_o <= PC_INIT;\\n', '    else if ( du_we_pc_strb ) if_pc_o <= du_dato_i;\\n', '    else if (!pd_stall_i &&\\n', '             !du_stall_i    ) if_pc_o <= if_nxt_pc_o;\\n', '\\n', '\\n', '  //Instruction\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if      (!rst_ni    ) if_insn_o.instr  <= NOP;\\n', '    else if (!pd_stall_i) if_insn_o.instr  <= if_nxt_insn_o.instr;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni               ) if_insn_o.bubble <= 1'b1;\\n\", \"    else if ( pd_flush_i           ) if_insn_o.bubble <= 1'b1;\\n\", \"    else if ( du_stall_i           ) if_insn_o.bubble <= 1'b1;\\n\", '    else if ( pd_exceptions_i.any  ||\\n', '\\t      id_exceptions_i.any  ||\\n', '\\t      ex_exceptions_i.any  ||\\n', '\\t      mem_exceptions_i.any ||\\n', \"\\t      wb_exceptions_i.any  ) if_insn_o.bubble <= 1'b1;\\n\", '    else if (!pd_stall_i)\\n', \"      if (pd_latch_nxt_pc_i)         if_insn_o.bubble <= 1'b1;\\n\", '      else                           if_insn_o.bubble <= if_nxt_insn_o.bubble;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) if_insn_o.dbg <= 1'b0;\\n\", '    else         if_insn_o.dbg <= du_stall_i;\\n', '\\n', '\\n', '  //exceptions\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni    ) if_exceptions_o <= {$bits(if_exceptions_o){1'b0}};\\n\", \"    else if ( pd_flush_i) if_exceptions_o <= {$bits(if_exceptions_o){1'b0}};\\n\", '    else if (!pd_stall_i)\\n', '    begin\\n', '        if_exceptions_o                                <= parcel_exceptions;\\n', '\\tif_exceptions_o.exceptions.illegal_instruction <= rvc_illegal & ~parcel_queue_empty;\\n', '    end\\n', '\\n', '\\n', '  //BP history\\n', '  always @(posedge clk_i)\\n', '    if (!pd_stall_i) if_bp_history_o <= bu_bp_history_i;\\n', 'endmodule\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Memory Unit (Mem Stage)                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2017-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', 'module riscv_mem\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', '#(\\n', '  parameter              XLEN    = 32,\\n', \"  parameter  [XLEN -1:0] PC_INIT = 'h200\\n\", ')\\n', '(\\n', '  input                          rst_ni,\\n', '  input                          clk_i,\\n', '\\n', '  input                          mem_stall_i,\\n', '  output                         mem_stall_o,\\n', '\\n', '  //Program counter\\n', '  input      [XLEN         -1:0] mem_pc_i,\\n', '  output reg [XLEN         -1:0] mem_pc_o,\\n', '\\n', '  //Instruction\\n', '  input  instruction_t           mem_insn_i,\\n', '  output instruction_t           mem_insn_o,\\n', '\\n', '  input  interrupts_exceptions_t mem_exceptions_dn_i,\\n', '  output interrupts_exceptions_t mem_exceptions_dn_o,\\n', '  input  interrupts_exceptions_t mem_exceptions_up_i,\\n', '  output interrupts_exceptions_t mem_exceptions_up_o,\\n', '\\n', ' \\n', '  //From upstream (EX)\\n', '  input      [XLEN         -1:0] mem_r_i,\\n', '                                 mem_memadr_i,\\n', '\\n', '  //To downstream (WB)\\n', '  output reg [XLEN         -1:0] mem_r_o,\\n', '  output reg [XLEN         -1:0] mem_memadr_o\\n', ');\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  /*\\n', '   * Program Counter\\n', '   */\\n', '  always @(posedge clk_i,negedge rst_ni)\\n', '    if      (!rst_ni     ) mem_pc_o <= PC_INIT;\\n', '    else if (!mem_stall_i) mem_pc_o <= mem_pc_i;\\n', '\\n', '  /*\\n', '   * Stall\\n', '   */\\n', '  assign mem_stall_o = mem_stall_i;\\n', '\\n', '  \\n', '  /*\\n', '   * Instruction\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    if (!mem_stall_i) mem_insn_o.instr <= mem_insn_i.instr;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni     ) mem_insn_o.dbg <= 1'b0;\\n\", '    else if (!mem_stall_i) mem_insn_o.dbg <= mem_insn_i.dbg;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni                 ) mem_insn_o.bubble <= 1'b1;\\n\", \"    else if ( mem_exceptions_up_i.any) mem_insn_o.bubble <= 1'b1;\\n\", '    else if (!mem_stall_i            ) mem_insn_o.bubble <= mem_insn_i.bubble;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni                 ) mem_insn_o.retired <= 'h0;\\n\", \"    else if ( mem_exceptions_up_i.any) mem_insn_o.retired <= 'h0;\\n\", '    else if (!mem_stall_i            ) mem_insn_o.retired <= mem_insn_i.retired;\\n', '\\n', '\\n', '  /*\\n', '   * Data\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    if (!mem_stall_i) mem_r_o <= mem_r_i;\\n', '\\n', '  always @(posedge clk_i)\\n', '    if (!mem_stall_i) mem_memadr_o <= mem_memadr_i;\\n', '\\n', '\\n', '  /*\\n', '   * Exception\\n', '   */\\n', '  assign mem_exceptions_up_o = mem_exceptions_dn_o | mem_exceptions_up_i;\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni                 ) mem_exceptions_dn_o <= 'h0;\\n\", \"    else if ( mem_exceptions_up_o.any) mem_exceptions_dn_o <= 'h0;\\n\", '    else if (!mem_stall_i            ) mem_exceptions_dn_o <= mem_exceptions_dn_i;\\n', '\\n', 'endmodule : riscv_mem\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Parcel Queue                                                 //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2021 ROA Logic BV                     //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '/* Parcel Queue\\n', ' * BIU pushes 16bit parcels and status signals into the queue\\n', ' * The parcel_valid vector indicates where valid parcels start.\\n', ' * This allows for offset parcels; e.g. due to 16b reads on 32b bus\\n', ' *\\n', ' * The instruction fetch unit pulls parcels from the queue, typically\\n', ' * one (16bit) or 2 (32bit) at a time\\n', ' *\\n', ' * The max number of parcels to push and pull is limited to 8 (128bits)\\n', ' *\\n', \" * 'almost_empty_o' is a user configurable 'empty' signal.\\n\", \" * 'almost_full_o' is a user configurable 'full' signal.\\n\", ' * Their thresholds are set by the ALMOST_EMPTY/FULL_THRESHOLD parameters\\n', ' *\\n', ' * ATTENTION: All output signals must be validated with empty_o\\n', ' */\\n', '\\n', 'module riscv_parcel_queue\\n', 'import riscv_opcodes_pkg::*;\\n', '#(\\n', '  parameter DEPTH                   = 2,    //number of parcels\\n', '  parameter WR_PARCELS              = 2,    //push max <n> parcels onto queue\\n', '  parameter RD_PARCELS              = 2,    //pull max <n> parcels from queue\\n', '  parameter ALMOST_EMPTY_THRESHOLD  = 0,\\n', '  parameter ALMOST_FULL_THRESHOLD   = DEPTH,\\n', '\\n', '  localparam PARCEL_SIZE            = 16,\\n', '  localparam WR_PARCEL_BITS         = WR_PARCELS * PARCEL_SIZE,\\n', '  localparam RD_PARCEL_BITS         = RD_PARCELS * PARCEL_SIZE\\n', ')\\n', '(\\n', '  input  logic                        rst_ni,         //asynchronous, active low reset\\n', '  input  logic                        clk_i,          //rising edge triggered clock\\n', '\\n', '  input  logic                        flush_i,        //flush all queue entries\\n', '\\n', '  //Queue Write\\n', '  input  logic [WR_PARCEL_BITS  -1:0] parcel_i,\\n', '  input  logic [WR_PARCELS      -1:0] parcel_valid_i, //parcel_valid has 1 valid bit per parcel\\n', '  input  logic                        parcel_misaligned_i,\\n', '  input  logic                        parcel_page_fault_i,\\n', '  input  logic                        parcel_error_i,\\n', '\\n', '  //Queue Read\\n', '  input  logic [$clog2(RD_PARCELS):0] parcel_rd_i,    //read <n> consecutive parcels\\n', '  output logic [RD_PARCEL_BITS  -1:0] parcel_q_o,\\n', '  output logic                        parcel_misaligned_o,\\n', '  output logic                        parcel_page_fault_o,\\n', '  output logic                        parcel_error_o,\\n', '\\n', '  //Status signals\\n', '  output logic                        empty_o,        //Queue is empty\\n', '                                      full_o,         //Queue is full\\n', '                                      almost_empty_o, //Programmable almost empty\\n', '                                      almost_full_o   //Programmable almost full\\n', ');\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Constants\\n', '  //\\n', '  localparam EMPTY_THRESHOLD = 1;\\n', '  localparam FULL_THRESHOLD  = DEPTH - WR_PARCELS;\\n', '  localparam ALMOST_EMPTY_THRESHOLD_CHECK = ALMOST_EMPTY_THRESHOLD <= 0     ? EMPTY_THRESHOLD : ALMOST_EMPTY_THRESHOLD +1;\\n', '  localparam ALMOST_FULL_THRESHOLD_CHECK  = ALMOST_FULL_THRESHOLD  >= DEPTH ? FULL_THRESHOLD  : ALMOST_FULL_THRESHOLD -2;\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Functions\\n', '  //\\n', '  function logic [$clog2(WR_PARCELS):0] align_cnt (input [WR_PARCELS-1:0] a);\\n', '    bit found_one;\\n', '\\n', '    found_one = 0;\\n', '    align_cnt = 0;\\n', '\\n', '    for (int n=0; n < WR_PARCELS; n++)\\n', '      if (!found_one)\\n', '       if (!a[n]) align_cnt++;\\n', '       else       found_one = 1;\\n', '  endfunction\\n', '\\n', '  function logic [$clog2(WR_PARCELS):0] count_ones (input [WR_PARCELS-1:0] a);\\n', '    count_ones = 0;\\n', '    for (int n=0; n < WR_PARCELS; n++) if (a[n]) count_ones++;\\n', '  endfunction\\n', '\\n', '  \\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Typedefs\\n', '  //\\n', '  typedef logic [15:0] parcel_t;\\n', '\\n', '  typedef struct packed {\\n', '    logic misaligned,\\n', '          page_fault,\\n', '\\t  error;\\n', '  } parcel_status_t;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '\\n', '  //parcel shift register\\n', '  parcel_t        [DEPTH                 -1:0] parcel_sr,\\n', '                                               nxt_parcel_sr ;\\n', '\\n', '  //parcel status shift register\\n', '  parcel_status_t [DEPTH                 -1:0] parcel_st_sr;\\n', '  parcel_status_t [DEPTH + RD_PARCELS    -1:0] nxt_parcel_st_sr;\\n', '\\n', '  logic           [WR_PARCEL_BITS        -1:0] align_parcel;\\n', '  logic           [$clog2(RD_PARCEL_BITS)  :0] rd_shift;\\n', '\\n', '  logic           [$clog2(DEPTH)           :0] wadr;\\n', '  logic           [$clog2(DEPTH)           :0] nxt_wadr;\\n', '\\n', '\\n', '  //////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  //align parcel / parcel_wr (remove invalid parcels)\\n', '  assign align_parcel = parcel_i >> align_cnt(parcel_valid_i) * PARCEL_SIZE;\\n', '\\n', '  /*\\n', '   * decode write location\\n', '   */\\n', '  assign nxt_wadr = wadr + count_ones(parcel_valid_i) - parcel_rd_i;\\n', '\\n', '\\n', '  //write pointer\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni ) wadr <= 'h0;\\n\", \"    else if ( flush_i) wadr <= 'h0;\\n\", '    else               wadr <= nxt_wadr;\\n', '\\n', '\\n', '  //how much should we shift for a read\\n', '  assign rd_shift = parcel_rd_i * PARCEL_SIZE;\\n', '\\n', '\\n', '  /*\\n', '   * Parcel Shift Register\\n', '   */\\n', '\\n', '  //next value of parcel shift register (like next state)\\n', '  always_comb\\n', '  begin\\n', '      //first store new value at next location\\n', '      nxt_parcel_sr = parcel_sr;\\n', '\\n', '      if (|parcel_valid_i)\\n', '        for (int n=0; n < WR_PARCELS; n++)\\n', '          nxt_parcel_sr[wadr + n] = align_parcel[n * PARCEL_SIZE +: PARCEL_SIZE];\\n', '\\n', '      // then shift out read parcels\\n', '      nxt_parcel_sr = nxt_parcel_sr >> rd_shift;\\n', '  end\\n', '\\n', '\\n', '  //decoder and shifter for simultaneous reading and writing\\n', '  always @(posedge clk_i)\\n', '    if (flush_i)\\n', '      for (int n = 0; n < DEPTH; n = n +2)\\n', '        parcel_sr[n +: 2] <= INSTR_NOP;\\n', '    else  parcel_sr <= nxt_parcel_sr;\\n', '\\n', '\\n', '  /*\\n', '   * Parcel Status Shift Register\\n', '   */\\n', '\\n', '  //next value of parcel status shift register (like next state)\\n', '  always_comb\\n', '  begin\\n', '      nxt_parcel_st_sr = parcel_st_sr;\\n', '      \\n', '      /* Store parcel status data\\n', \"       * Set status for all write parcels, because we don't\\n\", '       * know where an actual instruction starts/ends\\n', '       */\\n', '      for (int n=0; n < WR_PARCELS; n++)\\n', '      begin\\n', '          nxt_parcel_st_sr[wadr + n].misaligned = parcel_misaligned_i;\\n', '          nxt_parcel_st_sr[wadr + n].page_fault = parcel_page_fault_i;\\n', '          nxt_parcel_st_sr[wadr + n].error      = parcel_error_i;\\n', '      end\\n', '\\n', '      //shift out read parcels\\n', '      nxt_parcel_st_sr = nxt_parcel_st_sr >> rd_shift;\\n', '  end\\n', '\\n', '\\n', '  //decoder and shifter for simultaneous reading and writing\\n', '  always @(posedge clk_i)\\n', '    if (flush_i)\\n', '      for (int n = 0; n < DEPTH; n++)\\n', \"        parcel_st_sr[n] <= 'h0;\\n\", '    else  parcel_st_sr <= nxt_parcel_st_sr;\\n', '\\n', '\\n', '  /*\\n', '   * Assign outputs\\n', '   */\\n', '  assign parcel_q_o = parcel_sr[0 +: RD_PARCELS];\\n', '\\n', '\\n', \"  //status is only relevant for first parcel, because that's where the\\n\", '  //instruction starts\\n', '  assign parcel_misaligned_o = parcel_st_sr[0].misaligned;\\n', '  assign parcel_page_fault_o = parcel_st_sr[0].page_fault;\\n', '  assign parcel_error_o      = parcel_st_sr[0].error;\\n', '\\n', '\\n', '  /*\\n', '   * Status Flags\\n', '   */\\n', '\\n', '  //Queue Almost Empty\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni  ) almost_empty_o <= 1'b1;\\n\", \"    else if ( flush_i ) almost_empty_o <= 1'b1;\\n\", '    else                almost_empty_o <= nxt_wadr < ALMOST_EMPTY_THRESHOLD_CHECK;\\n', '\\n', '\\n', '  //Queue Empty\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni  ) empty_o <= 1'b1;\\n\", \"    else if ( flush_i ) empty_o <= 1'b1;\\n\", '    else                empty_o <= ~|nxt_wadr;\\n', '\\n', '\\n', '  //Queue Almost Full\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni  ) almost_full_o <= 1'b0;\\n\", \"    else if ( flush_i ) almost_full_o <= 1'b0;\\n\", '    else                almost_full_o <= nxt_wadr > ALMOST_FULL_THRESHOLD_CHECK;\\n', '\\n', '\\n', '  //Queue Full\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni  ) full_o <= 1'b0;\\n\", \"    else if ( flush_i ) full_o <= 1'b0;\\n\", '    else                full_o <= nxt_wadr > FULL_THRESHOLD;\\n', '\\n', 'endmodule\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Instruction Pre-Decoder                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', 'module riscv_pd\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', '#(\\n', '  parameter                       XLEN           = 32,\\n', \"  parameter  [XLEN          -1:0] PC_INIT        = 'h200,\\n\", '  parameter                       HAS_RVC        = 0,\\n', '  parameter                       HAS_BPU        = 0,\\n', '  parameter                       BP_GLOBAL_BITS = 2,\\n', '  parameter                       RSB_DEPTH      = 4\\n', ')\\n', '(\\n', '  input                           rst_ni,          //Reset\\n', '  input                           clk_i,           //Clock\\n', '  \\n', '  input                           id_stall_i,\\n', '  output                          pd_stall_o,\\n', '  input                           du_mode_i,\\n', '\\n', '  input                           bu_flush_i,      //flush pipe & load new program counter\\n', '                                  st_flush_i,\\n', '\\n', '  output                          pd_flush_o,\\n', '\\n', '  output rsd_t                    pd_rs1_o,\\n', '                                  pd_rs2_o,\\n', '\\n', '  output     [              11:0] pd_csr_reg_o,\\n', '\\n', '  input      [XLEN          -1:0] bu_nxt_pc_i,     //Branch Unit Next Program Counter\\n', '                                  st_nxt_pc_i,     //State Next Program Counter\\n', '  output reg [XLEN          -1:0] pd_nxt_pc_o,     //Branch Preditor Next Program Counter\\n', '  output reg                      pd_latch_nxt_pc_o,\\n', '\\n', '  input      [BP_GLOBAL_BITS-1:0] if_bp_history_i,\\n', '  output reg [BP_GLOBAL_BITS-1:0] pd_bp_history_o,\\n', '\\n', '  input      [               1:0] bp_bp_predict_i, //Branch Prediction bits\\n', '  output reg [               1:0] pd_bp_predict_o, //push down the pipe\\n', '\\n', '  input      [XLEN          -1:0] if_pc_i,\\n', '  output reg [XLEN          -1:0] pd_pc_o,\\n', '                                  pd_rsb_pc_o,\\n', '\\n', '  input  instruction_t            if_insn_i,\\n', '  output instruction_t            pd_insn_o,\\n', '  input  instruction_t            id_insn_i,\\n', '\\n', '  input  interrupts_exceptions_t  if_exceptions_i,\\n', '  output interrupts_exceptions_t  pd_exceptions_o,\\n', '  input  interrupts_exceptions_t  id_exceptions_i,\\n', '                                  ex_exceptions_i,\\n', '                                  mem_exceptions_i,\\n', '                                  wb_exceptions_i\\n', ');\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Constants\\n', '  //\\n', '\\n', '  //Instruction address mask\\n', \"  localparam ADR_MASK = HAS_RVC != 0 ? {XLEN{1'b1}} << 1 : {XLEN{1'b1}} << 2;\\n\", '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '\\n', '  //RSB\\n', '  logic             is_16bit_instruction;\\n', '  logic             has_rsb;\\n', '  logic [XLEN -1:0] rsb_nxt_pc,\\n', '                    rsb_predict_pc;\\n', '  logic             rsb_push,\\n', '                    rsb_pop,\\n', '                    rsb_empty;\\n', '\\n', '  rsd_t             rs1,\\n', '                    rd;\\n', '  logic             link_rs1,\\n', '                    link_rd,\\n', '                    decode_rsb_push,\\n', '                    decode_rsb_pop;\\n', '\\n', '\\n', '  //Immediates for branches and jumps\\n', '  immUJ_t           immUJ;\\n', '  immSB_t           immSB;\\n', '  logic [XLEN -1:0] ext_immUJ,\\n', '                    ext_immSB;\\n', '\\n', '\\n', '  logic [      1:0] branch_predicted;\\n', '\\n', '  logic             branch_taken,\\n', '                    stalled_branch;\\n', '\\n', '  logic             assert_local_stall;\\n', '  logic [      1:0] local_stall;\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  //for RSB\\n', '  assign is_16bit_instruction = ~&if_insn_i.instr[1:0];\\n', \"  assign rsb_nxt_pc           = if_pc_i + (is_16bit_instruction ? 'h2 : 'h4);\\n\", '  assign has_rsb              = RSB_DEPTH > 0;\\n', '  assign rs1                  = decode_rs1(if_insn_i.instr);\\n', '  assign rd                   = decode_rd (if_insn_i.instr);\\n', '  assign link_rs1             = (rs1 == 1) | (rs1 == 5); //x1/ra or x5/t0/ra2\\n', '  assign link_rd              = (rd  == 1) | (rd  == 5);\\n', '\\n', '  \\n', '  //All flush signals\\n', '  assign pd_flush_o = bu_flush_i | st_flush_i;\\n', '\\n', '\\n', '  //Stall when write-CSR\\n', '  //This can be more advanced, but who cares ... this is not critical\\n', '  //Two cycle stall to ensure data is written into CSR before it can be read\\n', '  always_comb\\n', '    casex ( decode_opcR(if_insn_i.instr) )\\n', '      CSRRW  : assert_local_stall <= ~if_insn_i.bubble;\\n', '      CSRRWI : assert_local_stall <= ~if_insn_i.bubble;\\n', '      CSRRS  : assert_local_stall <= ~if_insn_i.bubble & |decode_rs1 (if_insn_i.instr);\\n', '      CSRRSI : assert_local_stall <= ~if_insn_i.bubble & |decode_immI(if_insn_i.instr);\\n', '      CSRRC  : assert_local_stall <= ~if_insn_i.bubble & |decode_rs1 (if_insn_i.instr);\\n', '      CSRRCI : assert_local_stall <= ~if_insn_i.bubble & |decode_immI(if_insn_i.instr);\\n', \"      default: assert_local_stall <= 1'b0;\\n\", '    endcase\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni        ) local_stall <= 2'h0;\\n\", \"    else if ( local_stall[1]) local_stall <= 2'h0;\\n\", '    else if (!id_stall_i    )\\n', '    begin\\n', '        local_stall[0] <= assert_local_stall | local_stall[0];\\n', '        local_stall[1] <= local_stall[0];\\n', '    end\\n', '\\n', '  assign pd_stall_o = id_stall_i | local_stall[0];\\n', '\\n', '\\n', '  /*\\n', '   * To Register File (registered outputs)\\n', '   */\\n', '  //address into register file. Gets registered in memory\\n', '  assign pd_rs1_o = decode_rs1(if_insn_i.instr);\\n', '  assign pd_rs2_o = decode_rs2(if_insn_i.instr);\\n', '\\n', '\\n', '  /*\\n', '   * To State (CSR - registered output)\\n', '   */\\n', '  assign pd_csr_reg_o = if_insn_i.instr.I.imm;\\n', '\\n', '\\n', '  //Program counter\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if      (!rst_ni     ) pd_pc_o <= PC_INIT     & ADR_MASK;\\n', '    else if ( st_flush_i ) pd_pc_o <= st_nxt_pc_i & ADR_MASK;\\n', '    else if ( bu_flush_i ) pd_pc_o <= bu_nxt_pc_i & ADR_MASK;\\n', '    else if (!pd_stall_o ) pd_pc_o <= if_pc_i     & ADR_MASK;\\n', '\\n', '\\n', '  //Instruction\\t\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if      (!rst_ni    ) pd_insn_o.instr <= INSTR_NOP;\\n', '    else if (!id_stall_i) pd_insn_o.instr <= if_insn_i.instr;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni    ) pd_insn_o.dbg <= 1'b0;\\n\", '    else if (!id_stall_i) pd_insn_o.dbg <= if_insn_i.dbg;\\n', '    \\n', '\\n', '  //Bubble\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni              ) pd_insn_o.bubble <= 1'b1;\\n\", \"    else if ( pd_flush_o          ) pd_insn_o.bubble <= 1'b1;\\n\", '    else if ( id_exceptions_i.any  ||\\n', '              ex_exceptions_i.any  ||\\n', '              mem_exceptions_i.any ||\\n', \"              wb_exceptions_i.any ) pd_insn_o.bubble <= 1'b1;\\n\", '    else if (!id_stall_i)\\n', \"      if (local_stall) pd_insn_o.bubble <= 1'b1;\\n\", '      else             pd_insn_o.bubble <= if_insn_i.bubble;\\n', '\\n', '\\n', '  //Exceptions\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni     ) pd_exceptions_o <= 'h0;\\n\", \"    else if ( pd_flush_o ) pd_exceptions_o <= 'h0;\\n\", \"    else if ( pd_stall_o ) pd_exceptions_o <= 'h0;\\n\", '    else                   pd_exceptions_o <= if_exceptions_i;\\n', '\\n', '\\n', '  //Branch Predict History\\n', '  always @(posedge clk_i)\\n', '    if (!pd_stall_o) pd_bp_history_o <= if_bp_history_i;\\n', '\\n', '    \\n', '  /*\\n', '   * Branches & Jump\\n', '   */\\n', '\\n', '  //Instantiate RSB\\n', 'generate\\n', '  if (RSB_DEPTH > 0)\\n', '  begin: gen_rsb\\n', '\\n', '      riscv_rsb #(\\n', '        .XLEN    ( XLEN           ),\\n', '        .DEPTH   ( RSB_DEPTH      ) )\\n', '      rsb_inst (\\n', '        .rst_ni  ( rst_ni         ),\\n', '        .clk_i   ( clk_i          ),\\n', '\\t.ena_i   (!pd_stall_o     ),\\n', '        .d_i     ( rsb_nxt_pc     ),\\n', '        .q_o     ( rsb_predict_pc ),\\n', '        .push_i  ( rsb_push       ), //push stack, JAL(R) rd !=x0\\n', '        .pop_i   ( rsb_pop        ), //pop stack, RET\\n', '        .empty_o ( rsb_empty      ) );\\n', '\\n', '`ifdef RV12_RSB_LOGGER\\n', '      /* RSB logger\\n', '       */\\n', '//synopsys translate_off\\n', '      int fd;\\n', '      initial fd=$fopen($sformatf(\"%m_rsb.log\"), \"w\");\\n', '\\n', '      always @(posedge clk_i)\\n', '        if (!pd_stall_o)\\n', '        begin\\n', '            if (rsb_pop ) $fdisplay(fd, \"pop  %4s %2d %h %d %b\", rs1.name(), rs1, rsb_predict_pc, rsb_inst.cnt, rsb_empty);\\n', '            if (rsb_push) $fdisplay(fd, \"push %4s %2d %h %d\"   , rd.name(),  rd,  rsb_nxt_pc,     rsb_inst.cnt           );\\n', '        end\\n', '//synopsys translate_on\\n', '`endif\\n', '\\n', '  end\\n', 'endgenerate\\n', '\\n', '\\n', '  /* decode rbs_push/pop\\n', \"   * Hint are encoded in the 'rd' field; only push/pop RBS when rd=x1/x5\\n\", '   *\\n', '   * +-------+-------+--------+----------------+\\n', '   * |  rd   |  rs1  | rs1=rd | action         |\\n', '   * +-------+-------+--------+----------------+\\n', '   * | !link | !link |    -   | none           |\\n', '   * | !link |  link |    -   | pop            |\\n', '   * |  link | !link |    -   | push           |\\n', '   * |  link |  link |    0   | pop, then push |\\n', '   * |  link |  link |    1   | push           |\\n', '   * +-------+-------+--------+----------------+\\n', '   */\\n', '  always_comb\\n', '    unique casex ({link_rd, link_rs1, rs1==rd})\\n', \"      3'b00? :{decode_rsb_push, decode_rsb_pop} = 2'b00;\\n\", \"      3'b01? :{decode_rsb_push, decode_rsb_pop} = 2'b01;\\n\", \"      3'b10? :{decode_rsb_push, decode_rsb_pop} = 2'b10;\\n\", \"      3'b110 :{decode_rsb_push, decode_rsb_pop} = 2'b11;\\n\", \"      3'b111 :{decode_rsb_push, decode_rsb_pop} = 2'b10;\\n\", '    endcase\\n', '\\n', '\\n', '  //Immediates\\n', '  assign immUJ = decode_immUJ(if_insn_i.instr);\\n', '  assign immSB = decode_immSB(if_insn_i.instr);\\n', '  assign ext_immUJ = { {XLEN-$bits(immUJ){immUJ[$left(immUJ,1)]}}, immUJ};\\n', '  assign ext_immSB = { {XLEN-$bits(immSB){immSB[$left(immSB,1)]}}, immSB};\\n', '\\n', '\\n', '  // Branch and Jump prediction\\n', '  always_comb\\n', '    casex ( {du_mode_i, if_insn_i.bubble, decode_opcode(if_insn_i.instr)} )\\n', \"      {1'b0,1'b0,OPC_JAL   } : begin\\n\", \"                                   branch_taken     = 1'b1;\\n\", \"                                   branch_predicted = 2'b10;\\n\", '                                   rsb_push         = decode_rsb_push;\\n', '                                   rsb_pop          = decode_rsb_pop;\\n', '                                   pd_nxt_pc_o      = if_pc_i + ext_immUJ;\\n', '                               end\\n', '\\n', \"      {1'b0,1'b0,OPC_JALR  } : begin\\n\", \"                                   branch_taken     = has_rsb ? decode_rsb_pop : 1'b0;\\n\", \"                                   branch_predicted = 2'b00;\\n\", '                                   rsb_push         = decode_rsb_push;\\n', '                                   rsb_pop          = decode_rsb_pop;\\n', '                                   pd_nxt_pc_o      = rsb_predict_pc;\\n', '                               end\\n', '\\n', \"      {1'b0,1'b0,OPC_BRANCH} : begin\\n\", \"                                   //if this CPU has a Branch Predict Unit, then use it's prediction\\n\", '                                   //otherwise assume backwards jumps taken, forward jumps not taken\\n', '                                   branch_taken     = (HAS_BPU != 0) ? bp_bp_predict_i[1] : ext_immSB[31];\\n', \"                                   branch_predicted = (HAS_BPU != 0) ? bp_bp_predict_i    : {ext_immSB[31], 1'b0};\\n\", \"                                   rsb_push         = 1'b0;\\n\", \"                                   rsb_pop          = 1'b0;\\n\", '                                   pd_nxt_pc_o      = if_pc_i + ext_immSB;\\n', '                               end\\n', '\\n', '      default                : begin\\n', \"                                   branch_taken     = 1'b0;\\n\", \"                                   branch_predicted = 2'b00;\\n\", \"                                   rsb_push         = 1'b0;\\n\", \"                                   rsb_pop          = 1'b0;\\n\", \"                                   pd_nxt_pc_o      = 'hx;\\n\", '                               end\\n', '    endcase\\n', '\\n', '\\n', '  always @(posedge clk_i)\\n', \"    if (!pd_stall_o) pd_rsb_pc_o <= has_rsb ? rsb_predict_pc : {$bits(pd_rsb_pc_o){1'b0}};\\n\", '\\n', '\\n', '  always @(posedge clk_i)\\n', '    stalled_branch <= branch_taken & id_stall_i;\\n', '\\n', '\\n', '  //generate latch strobe\\n', '  assign pd_latch_nxt_pc_o = branch_taken & ~stalled_branch;\\n', '\\n', '\\n', '  //to Branch Prediction Unit\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni    ) pd_bp_predict_o <= 2'b00;\\n\", '    else if (!pd_stall_o) pd_bp_predict_o <= branch_predicted;\\n', '\\n', 'endmodule\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Register Stage                                               //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2021 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', 'module riscv_rf\\n', 'import riscv_opcodes_pkg::*;\\n', '#(\\n', '  parameter XLEN      = 32,\\n', '  parameter REGOUT    = 0\\n', ')\\n', '(\\n', '  input                      rst_ni,\\n', '  input                      clk_i,\\n', '\\n', '  //Register File read\\n', '  input        rsd_t         rf_src1_i,\\n', '  input        rsd_t         rf_src2_i,\\n', '  output logic [XLEN   -1:0] rf_src1_q_o,\\n', '  output logic [XLEN   -1:0] rf_src2_q_o,\\n', '\\n', '  //Register File write\\n', '  input        rsd_t         rf_dst_i,\\n', '  input        [XLEN   -1:0] rf_dst_d_i,\\n', '  input                      rf_we_i,\\n', '  input                      pd_stall_i,\\n', '                             id_stall_i,\\n', '\\n', '  //Debug Interface\\n', '  input                      du_re_rf_i,\\n', '                             du_we_rf_i,\\n', '  input        [XLEN   -1:0] du_d_i,   //output from debug unit\\n', '  output logic [XLEN   -1:0] du_rf_q_o,\\n', '  input        [       11:0] du_addr_i\\n', ');\\n', '\\n', '/////////////////////////////////////////////////////////////////\\n', '//\\n', '// Variables\\n', '//\\n', '\\n', '//Actual register file\\n', '//Need to figure out if an array of rsd_t is actually allowed\\n', 'logic [XLEN-1:0] rf [32];\\n', '\\n', 'rsd_t            src1,\\n', '                 src2;\\n', '\\n', '//read data from register file\\n', 'logic [XLEN-1:0] rfout1,\\n', '                 rfout2;\\n', '\\n', '//Exceptions\\n', 'logic            src1_is_x0,\\n', '\\t         src2_is_x0,\\n', '                 dst_is_src1,\\n', '                 dst_is_src2;\\n', 'logic [XLEN-1:0] dout1,\\n', '                 dout2;\\n', '\\n', 'logic            du_re_rf_dly;\\n', '\\n', '\\n', '/////////////////////////////////////////////////////////////////\\n', '//\\n', '// Module Body\\n', '//\\n', '\\n', '  //delay du_stall signal, to ensure src1 reaches RF before du_stall takes over\\n', '  always @(posedge clk_i)\\n', '    du_re_rf_dly <= du_re_rf_i;\\n', '\\n', '\\n', '  //Use traditional registered memory description to ensure that writes to RF\\n', '  //during a stall are handled\\n', '\\n', '  //register read port\\n', \"  always @(posedge clk_i) if      ( du_re_rf_i) src1 <= rsd_t'(du_addr_i[4:0]);\\n\", '                          else if (!pd_stall_i) src1 <= rf_src1_i;\\n', '  always @(posedge clk_i) if      (!pd_stall_i) src2 <= rf_src2_i;\\n', '\\n', '\\n', '  //RW contention\\n', '  assign dst_is_src1 = rf_dst_i == src1;\\n', '  assign dst_is_src2 = rf_dst_i == src2;\\n', '\\n', '\\n', '  //register file access\\n', '  assign rfout1 = rf[ src1 ];\\n', '  assign rfout2 = rf[ src2 ];\\n', '\\n', ' \\n', '  //got data from RAM, now handle X0\\n', '  always @(posedge clk_i) if (!pd_stall_i) src1_is_x0  <= ~|rf_src1_i;\\n', '  always @(posedge clk_i) if (!pd_stall_i) src2_is_x0  <= ~|rf_src2_i;\\n', '\\n', '  always_comb\\n', '    casex (src1_is_x0)\\n', \"      1'b1: dout1 = {XLEN{1'b0}};\\n\", \"      1'b0: dout1 = rfout1;\\n\", '    endcase\\n', '\\n', '  always_comb\\n', '    casex (src2_is_x0)\\n', \"      1'b1: dout2 = {XLEN{1'b0}};\\n\", \"      1'b0: dout2 = rfout2;\\n\", '    endcase\\n', '\\n', '\\n', '  if (REGOUT > 0)\\n', '  begin\\n', '      always @(posedge clk_i) if (!id_stall_i) rf_src1_q_o <= dout1;\\n', '      always @(posedge clk_i) if (!id_stall_i) rf_src2_q_o <= dout2;\\n', '  end\\n', '  else\\n', '  begin\\n', '      assign rf_src1_q_o = dout1;\\n', '      assign rf_src2_q_o = dout2;\\n', '  end\\n', '\\n', '\\n', '//Debug Unit output\\n', 'always @(posedge clk_i)\\n', \"  if (du_re_rf_dly) du_rf_q_o <= ~|src1 ? 'h0 : rfout1;\\n\", '\\n', '\\n', '\\n', '//Writes are synchronous\\n', '  always @(posedge clk_i)\\n', '    if      ( du_we_rf_i ) rf[ du_addr_i[4:0] ] <= du_d_i;\\n', '    else if ( rf_we_i    ) rf[ rf_dst_i       ] <= rf_dst_d_i;\\n', '\\n', 'endmodule\\n', '\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Return Stack Buffer                                          //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2022      ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', '\\n', \"/* Hint are encoded in the 'rd' field; only push/pop RBS when rd=x1/x5\\n\", ' * \\n', ' * +-------+-------+--------+----------------+\\n', ' * |  rd   |  rs1  | rs1=rd | action         |\\n', ' * +-------+-------+--------+----------------+\\n', ' * | !link | !link |    -   | none           |\\n', ' * | !link |  link |    -   | pop            |\\n', ' * |  link | !link |    -   | push           |\\n', ' * |  link |  link |    0   | pop, then push |\\n', ' * |  link |  link |    1   | push           |\\n', ' * +-------+-------+--------+----------------+\\n', ' */\\n', '\\n', '\\n', 'module riscv_rsb #(\\n', '  parameter XLEN  = 32,\\n', '  parameter DEPTH = 4\\n', ')\\n', '(\\n', '  input  logic            rst_ni,\\n', '  input  logic            clk_i,\\n', '  input  logic            ena_i,\\n', '\\n', '  input  logic [XLEN-1:0] d_i,\\n', '  output logic [XLEN-1:0] q_o,\\n', '  input  logic            push_i,\\n', '  input  logic            pop_i,\\n', '  output logic            empty_o\\n', ');\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  logic [XLEN           -1:0] stack [DEPTH];\\n', '  logic [XLEN           -1:0] last_value;\\n', '  logic [$clog2(DEPTH+1)-1:0] cnt;\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '\\n', '  /* Store last written value\\n', '   * When RSB is empty, return last written value\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    if (ena_i && push_i) last_value <= d_i;\\n', '\\n', '\\n', '  /*\\n', '   * Store last read value\\n', '   */\\n', '\\n', '  /* Actual stack\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    if (ena_i)\\n', '    unique case ({push_i, pop_i})\\n', \"      2'b01: for (int n=0; n < DEPTH-1; n++) stack[n] <= stack[n+1];\\n\", \"      2'b10: begin\\n\", '                 stack[0] <= d_i;\\n', '                 for (int n=1; n < DEPTH; n++) stack[n] <= stack[n-1];\\n', '             end\\n', \"      2'b11: stack[0] <= d_i;\\n\", \"      2'b00: ; //do nothing\\n\", '    endcase\\n', '\\n', '\\n', '  /* Assign output\\n', '   */ \\n', '  assign q_o = empty_o ? last_value : stack[0];\\n', '\\n', '\\n', '  /* Empty\\n', '   */\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) cnt <= 'h0;\\n\", '    else if (ena_i)\\n', '    unique case ({push_i, pop_i})\\n', \"      2'b01  : if (!empty_o    ) cnt <= cnt -1;\\n\", \"      2'b10  : if (cnt != DEPTH) cnt <= cnt +1;\\n\", '      default: ; //do nothing\\n', '    endcase\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if (!rst_ni) empty_o <= 1'b1;\\n\", '    else if (ena_i)\\n', '    unique case ({push_i, pop_i})\\n', \"      2'b01  : empty_o <= cnt==1;\\n\", \"      2'b10  : empty_o <= 1'b0;\\n\", '      default: ; //do nothing\\n', '    endcase\\n', '\\n', '\\n', 'endmodule\\n']"}
{"text": "['/////////////////////////////////////////////////////////////////\\n', '//                                                             //\\n', '//                                                             //\\n', '//    RISC-V                                                   //\\n', '//    (Thread) State (priv spec 1.9.1)                         //\\n', '//                                                             //\\n', '/////////////////////////////////////////////////////////////////\\n', '//                                                             //\\n', '//             Copyright (C) 2014-2017 ROA Logic BV            //\\n', '//             www.roalogic.com                                //\\n', '//                                                             //\\n', '//    Unless specifically agreed in writing, this software is  //\\n', '//  licensed under the RoaLogic Non-Commercial License         //\\n', '//  version-1.0 (the \"License\"), a copy of which is included   //\\n', '//  with this file or may be found on the RoaLogic website     //\\n', '//  http://www.roalogic.com. You may not use the file except   //\\n', '//  in compliance with the License.                            //\\n', '//                                                             //\\n', '//    THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY        //\\n', '//  EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                 //\\n', '//  See the License for permissions and limitations under the  //\\n', '//  License.                                                   //\\n', '//                                                             //\\n', '/////////////////////////////////////////////////////////////////\\n', '\\n', 'module riscv_state1_9 #(\\n', '  parameter            XLEN            = 32,\\n', '  parameter            FLEN            = 64, //floating point data length\\n', '  parameter            ILEN            = 32,\\n', \"  parameter [XLEN-1:0] PC_INIT         = 'h200,\\n\", '  parameter            EXCEPTION_SIZE  = 12,\\n', '\\n', '  parameter            IS_RV32E        = 0,\\n', '  parameter            HAS_N           = 0,\\n', '  parameter            HAS_RVC         = 0,\\n', '  parameter            HAS_FPU         = 0,\\n', '  parameter            HAS_DFPU        = 0,\\n', '  parameter            HAS_QFPU        = 0,\\n', '  parameter            HAS_MMU         = 0,\\n', '  parameter            HAS_RVM         = 0,\\n', '  parameter            HAS_RVA         = 0,\\n', '  parameter            HAS_BM          = 0,\\n', '  parameter            HAS_TMEM        = 0,\\n', '  parameter            HAS_SIMD        = 0,\\n', '  parameter            HAS_EXT         = 0,\\n', '\\n', '  parameter            HAS_USER        = 1,\\n', '  parameter            HAS_SUPER       = 1,\\n', '  parameter            HAS_HYPER       = 0,\\n', '\\n', \"  parameter            MNMIVEC_DEFAULT = PC_INIT -'h004,\\n\", \"  parameter            MTVEC_DEFAULT   = PC_INIT -'h040,\\n\", \"  parameter            HTVEC_DEFAULT   = PC_INIT -'h080,\\n\", \"  parameter            STVEC_DEFAULT   = PC_INIT -'h0C0,\\n\", \"  parameter            UTVEC_DEFAULT   = PC_INIT -'h100,\\n\", '\\n', \"  parameter            VENDORID        = 16'h0001,\\n\", '  parameter            ARCHID          = (1<<XLEN) | 12,\\n', \"  parameter            REVMAJOR        = 4'h0,\\n\", \"  parameter            REVMINOR        = 4'h0,\\n\", '\\n', '  parameter            HARTID          = 0      //hardware thread-id\\n', ')\\n', '(\\n', '  input                           rstn,\\n', '  input                           clk,\\n', '\\n', '  input      [XLEN          -1:0] id_pc,\\n', '  input                           id_bubble,\\n', '  input      [ILEN          -1:0] id_instr,\\n', '  input                           id_stall,\\n', '\\n', '  input                           bu_flush,\\n', '  input      [XLEN          -1:0] bu_nxt_pc,\\n', '  output reg                      st_flush,\\n', '  output reg [XLEN          -1:0] st_nxt_pc,\\n', '\\n', '  input      [XLEN          -1:0] wb_pc,\\n', '  input      [EXCEPTION_SIZE-1:0] wb_exception,\\n', '  input      [XLEN          -1:0] wb_badaddr,\\n', '\\n', '  output reg                      st_interrupt,\\n', '  output reg [               1:0] st_prv,\\n', '\\n', '  //interrupts (3=M-mode, 0=U-mode)\\n', '  input      [               3:0] ext_int,  //external interrupt (per privilege mode; determined by PIC)\\n', '  input                           ext_tint, //machine timer interrupt\\n', '                                  ext_sint, //machine software interrupt (for ipi)\\n', '  input                           ext_nmi,  //non-maskable interrupt\\n', '\\n', '  //CSR interface\\n', '  input      [              11:0] ex_csr_reg,\\n', '  input                           ex_csr_we,\\n', '  input      [XLEN          -1:0] ex_csr_wval,\\n', '  output reg [XLEN          -1:0] st_csr_rval,\\n', '\\n', '  //Debug interface\\n', '  input                           du_stall,\\n', '                                  du_flush,\\n', '                                  du_we_csr,\\n', '  input      [XLEN          -1:0] du_dato,   //output from debug unit\\n', '  input      [              11:0] du_addr,\\n', '  input      [              31:0] du_ie,\\n', '  output     [              31:0] du_exceptions\\n', ');\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  import riscv_pkg::*;\\n', '  import riscv_state_pkg::*;\\n', '\\n', '  /*\\n', '   * CSRs\\n', '   */\\n', '  typedef struct packed {\\n', '    /*\\n', '     * User\\n', '     */\\n', '    //Floating point registers\\n', '    fcsr_struct fcsr;\\n', '\\n', '    //User Counter/Timers\\n', '    timer_struct      cycle,   //timer for MCYCLE\\n', '                      instret; //instruction retire count for MINSTRET\\n', '\\n', '    //User trap setup\\n', '    logic  [XLEN-1:0] utvec;\\n', '\\n', '    //User trap handler\\n', '    logic  [XLEN-1:0] uscratch; //scratch register\\n', '    logic  [XLEN-1:0] uepc;     //exception program counter\\n', '    logic  [XLEN-1:0] ucause;   //trap cause\\n', '    logic  [XLEN-1:0] ubadaddr; //bad address\\n', '\\n', '\\n', '    /*\\n', '     * Supervisor\\n', '     */\\n', '    //Supervisor trap setup\\n', '    logic  [XLEN-1:0] stvec;    //trap handler base address\\n', '    logic  [XLEN-1:0] sedeleg;  //trap delegation register\\n', '\\n', '    //Supervisor trap handler\\n', '    logic  [XLEN-1:0] sscratch; //scratch register\\n', '    logic  [XLEN-1:0] sepc;     //exception program counter\\n', '    logic  [XLEN-1:0] scause;   //trap cause\\n', '    logic  [XLEN-1:0] sbadaddr; //bad address\\n', '\\n', '    //Supervisor protection and Translation\\n', '    logic  [XLEN-1:0] sptbr;    //Page-table base address\\n', '\\n', '\\n', '    /*\\n', '     * Hypervisor\\n', '     */\\n', '    //Hypervisor Trap Setup\\n', '    logic  [XLEN-1:0] htvec;    //trap handler base address\\n', '    logic  [XLEN-1:0] hedeleg;  //trap delegation register\\n', '\\n', '    //Hypervisor trap handler\\n', '    logic  [XLEN-1:0] hscratch; //scratch register\\n', '    logic  [XLEN-1:0] hepc;     //exception program counter\\n', '    logic  [XLEN-1:0] hcause;   //trap cause\\n', '    logic  [XLEN-1:0] hbadaddr; //bad address\\n', '\\n', '    //Hypervisor protection and Translation\\n', '    //TBD per spec v1.7, somewhat defined in 1.9, removed in 1.10?\\n', '      \\n', '\\n', '    /*\\n', '     * Machine\\n', '     */\\n', '    logic  [XLEN-1:0] mvendorid, //Vendor-ID\\n', '                      marchid,   //Architecture ID\\n', '                      mimpid;    //Revision number\\n', '    logic  [XLEN-1:0] mhartid;   //Hardware Thread ID\\n', '\\n', '    //Machine Trap Setup\\n', '    mstatus_struct    mstatus;  //status\\n', '    misa_struct       misa;     //Machine ISA\\n', '    logic  [XLEN-1:0] mnmivec;  //ROALOGIC NMI handler base address\\n', '    logic  [XLEN-1:0] mtvec;    //trap handler base address\\n', '    logic  [XLEN-1:0] medeleg,  //Exception delegation\\n', '                      mideleg;  //Interrupt delegation\\n', '    mie_struct        mie;      //interrupt enable\\n', '\\n', '    //Machine trap handler\\n', '    logic  [XLEN-1:0] mscratch; //scratch register\\n', '    logic  [XLEN-1:0] mepc;     //exception program counter\\n', '    logic  [XLEN-1:0] mcause;   //trap cause\\n', '    logic  [XLEN-1:0] mbadaddr; //bad address\\n', '    mip_struct        mip;      //interrupt pending\\n', '\\n', '    //Machine protection and Translation\\n', '    logic  [XLEN-1:0] mbase;    //Base\\n', '    logic  [XLEN-1:0] mbound;   //Bound\\n', '    logic  [XLEN-1:0] mibase;   //Instruction base\\n', '    logic  [XLEN-1:0] mibound;  //Instruction bound\\n', '    logic  [XLEN-1:0] mdbase;   //Data base\\n', '    logic  [XLEN-1:0] mdbound;  //Data bound\\n', '  } csr_struct;\\n', '  csr_struct csr;\\n', '\\n', '\\n', '  logic                      is_rv32,\\n', '                             is_rv32e,\\n', '                             is_rv64,\\n', '                             has_rvc,\\n', '                             has_fpu, has_dfpu, has_qfpu,\\n', '                             has_decfpu,\\n', '                             has_mmu,\\n', '                             has_muldiv,\\n', '                             has_amo,\\n', '                             has_bm,\\n', '                             has_tmem,\\n', '                             has_simd,\\n', '                             has_n,\\n', '                             has_u,\\n', '                             has_s,\\n', '                             has_h,\\n', '                             has_ext;\\n', '\\n', '  logic [XLEN          -1:0] mip,\\n', '                             mie,\\n', '                             mideleg,\\n', '                             medeleg;\\n', '\\n', '  logic                      take_interrupt;\\n', '\\n', '  logic [              11:0] st_int;\\n', '  logic [               3:0] interrupt_cause,\\n', '                             trap_cause;\\n', '\\n', '  //Mux for debug-unit\\n', '  logic [              11:0] csr_raddr; //CSR read address\\n', '  logic [XLEN          -1:0] csr_wval; //CSR write value\\n', '\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '  assign is_rv32   = (XLEN       ==  32);\\n', '  assign is_rv64   = (XLEN       ==  64);\\n', '  assign is_rv32e  = (IS_RV32E   !=   0) & is_rv32;\\n', '  assign has_n     = (HAS_N      !=   0) & has_u;\\n', '  assign has_u     = (HAS_USER   !=   0);\\n', '  assign has_s     = (HAS_SUPER  !=   0) & has_u;\\n', '  assign has_h     = (HAS_HYPER  !=   0) & has_s;\\n', '\\n', '  assign has_rvc   = (HAS_RVC    !=   0);\\n', '  assign has_fpu   = (HAS_FPU    !=   0);\\n', '  assign has_qfpu  = (FLEN       == 128) & has_fpu;\\n', '  assign has_dfpu  =((FLEN       ==  64) & has_fpu) | has_qfpu;\\n', \"  assign has_decfpu= 1'b0;\\n\", '  assign has_mmu   = (HAS_MMU    !=   0) & has_s;\\n', '  assign has_muldiv= (HAS_RVM    !=   0);\\n', '  assign has_amo   = (HAS_RVA    !=   0);\\n', '  assign has_bm    = (HAS_BM     !=   0);\\n', '  assign has_tmem  = (HAS_TMEM   !=   0);\\n', '  assign has_simd  = (HAS_SIMD   !=   0);\\n', '  assign has_ext   = (HAS_EXT    !=   0);\\n', '\\n', '  //Mux address/data for Debug-Unit access\\n', '  assign csr_raddr = du_stall ? du_addr : ex_csr_reg;\\n', '  assign csr_wval  = du_stall ? du_dato : ex_csr_wval;\\n', '\\n', '\\n', '\\n', '  /*\\n', '   * Priviliged Control Registers\\n', '   */\\n', '  \\n', '  //Read\\n', '  always_comb\\n', '    (* synthesis,parallel_case *)\\n', '    case (csr_raddr)\\n', '      //User\\n', \"      USTATUS   : st_csr_rval = {{XLEN-5{1'b0}},\\n\", '                                  csr.mstatus.upie,\\n', \"                                  3'h0,\\n\", '                                  csr.mstatus.uie};\\n', \"      UIE       : st_csr_rval = has_n ? csr.mie & 12'h111               : 'h0;\\n\", \"      UTVEC     : st_csr_rval = has_n ? csr.utvec                       : 'h0;\\n\", \"      USCRATCH  : st_csr_rval = has_n ? csr.uscratch                    : 'h0;\\n\", \"      UEPC      : st_csr_rval = has_n ? csr.uepc                        : 'h0;\\n\", \"      UCAUSE    : st_csr_rval = has_n ? csr.ucause                      : 'h0;\\n\", \"      UBADADDR  : st_csr_rval = has_n ? csr.ubadaddr                    : 'h0;\\n\", \"      UIP       : st_csr_rval = has_n ? csr.mip & csr.mideleg & 12'h111 : 'h0;\\n\", '\\n', \"      FFLAGS    : st_csr_rval = has_fpu ? { {XLEN-$bits(csr.fcsr.flags){1'b0}},csr.fcsr.flags } : 'h0;\\n\", \"      FRM       : st_csr_rval = has_fpu ? { {XLEN-$bits(csr.fcsr.rm   ){1'b0}},csr.fcsr.rm    } : 'h0;\\n\", \"      FCSR      : st_csr_rval = has_fpu ? { {XLEN-$bits(csr.fcsr      ){1'b0}},csr.fcsr       } : 'h0;\\n\", '      CYCLE     : st_csr_rval = csr.cycle[XLEN-1:0];\\n', '//      TIME      : st_csr_rval = csr.timer[XLEN-1:0];\\n', '      INSTRET   : st_csr_rval = csr.instret[XLEN-1:0];\\n', \"      CYCLEH    : st_csr_rval = is_rv32 ? csr.cycle.h   : 'h0;\\n\", \"//      TIMEH     : st_csr_rval = is_rv32 ? csr.timer.h   : 'h0;\\n\", \"      INSTRETH  : st_csr_rval = is_rv32 ? csr.instret.h : 'h0;\\n\", '\\n', '      //Supervisor\\n', '      SSTATUS   : st_csr_rval = { csr.mstatus.sd,\\n', \"                                  {XLEN-20{1'b0}},\\n\", '                                  csr.mstatus.pum,\\n', \"                                  1'b0,\\n\", '                                  csr.mstatus.xs,\\n', '                                  csr.mstatus.fs,\\n', \"                                  4'h0,\\n\", '                                  csr.mstatus.spp,\\n', \"                                  2'h0,\\n\", '                                  csr.mstatus.spie,\\n', '                                  csr.mstatus.upie,\\n', \"                                  2'h0,\\n\", '                                  csr.mstatus.sie,\\n', '                                  csr.mstatus.uie};\\n', \"      STVEC     : st_csr_rval = has_s ? csr.stvec                       : 'h0;\\n\", \"      SIE       : st_csr_rval = has_s ? csr.mie & 12'h333               : 'h0;\\n\", \"      SEDELEG   : st_csr_rval = has_s ? csr.sedeleg                     : 'h0;\\n\", \"      SIDELEG   : st_csr_rval = has_s ? csr.mideleg & 12'h111           : 'h0;\\n\", \"      SSCRATCH  : st_csr_rval = has_s ? csr.sscratch                    : 'h0;\\n\", \"      SEPC      : st_csr_rval = has_s ? csr.sepc                        : 'h0;\\n\", \"      SCAUSE    : st_csr_rval = has_s ? csr.scause                      : 'h0;\\n\", \"      SBADADDR  : st_csr_rval = has_s ? csr.sbadaddr                    : 'h0;\\n\", \"      SIP       : st_csr_rval = has_s ? csr.mip & csr.mideleg & 12'h333 : 'h0;\\n\", \"      SPTBR     : st_csr_rval = has_s ? has_mmu ? csr.sptbr : 'h0       : 'h0;\\n\", '\\n', '      //Hypervisor\\n', '      HSTATUS   : st_csr_rval = { csr.mstatus.sd,\\n', \"                                  {XLEN-20{1'b0}},\\n\", '                                  csr.mstatus.pum,\\n', \"                                  1'b0,\\n\", '                                  csr.mstatus.xs,\\n', '                                  csr.mstatus.fs,\\n', \"                                  2'h0,\\n\", '                                  csr.mstatus.hpp,\\n', '                                  csr.mstatus.spp,\\n', \"                                  1'h0,\\n\", '                                  csr.mstatus.hpie,\\n', '                                  csr.mstatus.spie,\\n', '                                  csr.mstatus.upie,\\n', \"                                  1'h0,\\n\", '                                  csr.mstatus.hie,\\n', '                                  csr.mstatus.sie,\\n', '                                  csr.mstatus.uie};\\n', \"      HTVEC     : st_csr_rval = has_h ? csr.htvec                       : 'h0;\\n\", \"      HIE       : st_csr_rval = has_h ? csr.mie & 12'h777               : 'h0;\\n\", \"      HEDELEG   : st_csr_rval = has_h ? csr.hedeleg                     : 'h0;\\n\", \"      HIDELEG   : st_csr_rval = has_h ? csr.mideleg & 12'h333           : 'h0;\\n\", \"      HSCRATCH  : st_csr_rval = has_h ? csr.hscratch                    : 'h0;\\n\", \"      HEPC      : st_csr_rval = has_h ? csr.hepc                        : 'h0;\\n\", \"      HCAUSE    : st_csr_rval = has_h ? csr.hcause                      : 'h0;\\n\", \"      HBADADDR  : st_csr_rval = has_h ? csr.hbadaddr                    : 'h0;\\n\", \"      HIP       : st_csr_rval = has_h ? csr.mip & csr.mideleg & 12'h777 : 'h0;\\n\", '\\n', '      //Machine\\n', \"      MISA      : st_csr_rval = {csr.misa.base, {XLEN-$bits(csr.misa){1'b0}}, csr.misa.extensions};\\n\", '      MVENDORID : st_csr_rval = csr.mvendorid;\\n', '      MARCHID   : st_csr_rval = csr.marchid;\\n', \"      MIMPID    : st_csr_rval = is_rv32 ? csr.mimpid : { {XLEN-$bits(csr.mimpid){1'b0}}, csr.mimpid };\\n\", '      MHARTID   : st_csr_rval = csr.mhartid;\\n', '      MSTATUS   : st_csr_rval = {csr.mstatus.sd,\\n', \"                                 {XLEN-30{1'b0}},\\n\", '                                 csr.mstatus.vm,\\n', \"                                 4'h0,\\n\", '                                 csr.mstatus.mxr,\\n', '                                 csr.mstatus.pum,\\n', '                                 csr.mstatus.mprv,\\n', '                                 csr.mstatus.xs,\\n', '                                 csr.mstatus.fs,\\n', '                                 csr.mstatus.mpp,\\n', '                                 csr.mstatus.hpp,\\n', '                                 csr.mstatus.spp,\\n', '                                 csr.mstatus.mpie,\\n', '                                 csr.mstatus.hpie,\\n', '                                 csr.mstatus.spie,\\n', '                                 csr.mstatus.upie,\\n', '                                 csr.mstatus.mie,\\n', '                                 csr.mstatus.hie,\\n', '                                 csr.mstatus.sie,\\n', '                                 csr.mstatus.uie};\\n', '      MTVEC     : st_csr_rval = csr.mtvec;\\n', '      MNMIVEC   : st_csr_rval = csr.mnmivec;\\n', '      MEDELEG   : st_csr_rval = csr.medeleg;\\n', '      MIDELEG   : st_csr_rval = csr.mideleg;\\n', \"      MIE       : st_csr_rval = csr.mie & 12'hFFF;\\n\", '      MSCRATCH  : st_csr_rval = csr.mscratch;\\n', '      MEPC      : st_csr_rval = csr.mepc;\\n', '      MCAUSE    : st_csr_rval = csr.mcause;\\n', '      MBADADDR  : st_csr_rval = csr.mbadaddr;\\n', '      MIP       : st_csr_rval = csr.mip;\\n', '      MBASE     : st_csr_rval = csr.mbase;\\n', '      MBOUND    : st_csr_rval = csr.mbound;\\n', '      MIBASE    : st_csr_rval = csr.mibase;\\n', '      MIBOUND   : st_csr_rval = csr.mibound;\\n', '      MDBASE    : st_csr_rval = csr.mdbase;\\n', '      MDBOUND   : st_csr_rval = csr.mdbound;\\n', '      MCYCLE    : st_csr_rval = csr.cycle[XLEN-1:0];\\n', '      MINSTRET  : st_csr_rval = csr.instret[XLEN-1:0];\\n', \"      MCYCLEH   : st_csr_rval = is_rv32 ? csr.cycle.h   : 'h0;\\n\", \"      MINSTRETH : st_csr_rval = is_rv32 ? csr.instret.h : 'h0;\\n\", '\\n', \"      default   : st_csr_rval = 32'h0;\\n\", '    endcase\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  // Machine registers\\n', '  //\\n', '  assign csr.misa.base       = is_rv64 ? RV64I : RV32I;\\n', \"  assign csr.misa.extensions =  '{u: has_u,      //supports user mode\\n\", '                                  s: has_s,      //supports supervisor mode\\n', '                                  h: has_h,      //supports hypervisor mode\\n', '                                  x: has_ext,\\n', '                                  t: has_tmem,\\n', '                                  p: has_simd,\\n', '                                  n: has_n,\\n', '                                  m: has_muldiv,\\n', '                                  l: has_decfpu,\\n', '                                  i: ~is_rv32e,\\n', '                                  e: is_rv32e, \\n', '                                  f: has_fpu,\\n', '                                  d: has_dfpu,\\n', '                                  q: has_qfpu,\\n', '                                  c: has_rvc,\\n', '                                  b: has_bm,\\n', '                                  a: has_amo,\\n', \"                                  default : 1'b0};\\n\", '\\n', '  assign csr.mvendorid    = VENDORID;\\n', '  assign csr.marchid      = ARCHID;\\n', \"  assign csr.mimpid[XLEN-1:16] = 'h0;\\n\", '  assign csr.mimpid[15:8] = REVMAJOR;\\n', '  assign csr.mimpid[ 7:0] = REVMINOR;\\n', '  assign csr.mhartid      = HARTID;\\n', '\\n', '  //mstatus\\n', '  assign csr.mstatus.sd = &csr.mstatus.fs | &csr.mstatus.xs;\\n', '\\n', '  always @(posedge clk,negedge rstn)\\n', '    if (!rstn)\\n', '    begin\\n', '        st_prv           <= PRV_M;    //start in machine mode\\n', '        st_nxt_pc        <= PC_INIT;\\n', \"        st_flush         <= 1'b1;\\n\", '\\n', '        csr.mstatus.vm   <= VM_MBARE;\\n', \"        csr.mstatus.mxr  <= 1'b0;\\n\", \"        csr.mstatus.pum  <= 1'b0;\\n\", \"        csr.mstatus.mprv <= 1'b0;\\n\", '        csr.mstatus.xs   <= {2{has_ext}};\\n', \"        csr.mstatus.fs   <= 2'b00;\\n\", '\\n', \"        csr.mstatus.mpp  <= 2'h3;\\n\", '        csr.mstatus.hpp  <= {2{has_h}};\\n', '        csr.mstatus.spp  <= has_s;\\n', \"        csr.mstatus.mpie <= 1'b0;\\n\", \"        csr.mstatus.hpie <= 1'b0;\\n\", \"        csr.mstatus.spie <= 1'b0;\\n\", \"        csr.mstatus.upie <= 1'b0;\\n\", \"        csr.mstatus.mie  <= 1'b0;\\n\", \"        csr.mstatus.hie  <= 1'b0;\\n\", \"        csr.mstatus.sie  <= 1'b0;\\n\", \"        csr.mstatus.uie  <= 1'b0;\\n\", '    end\\n', '    else\\n', '    begin\\n', \"        st_flush <= 1'b0;\\n\", '\\n', '        //write from ID, Machine Mode\\n', '        if ( (ex_csr_we && ex_csr_reg == MSTATUS && st_prv == PRV_M) ||\\n', '             (du_we_csr && du_addr    == MSTATUS)                     )\\n', '        begin\\n', '            csr.mstatus.vm    <= csr_wval[28:24];\\n', '            csr.mstatus.mxr   <= csr_wval[19];\\n', '            csr.mstatus.pum   <= csr_wval[18];\\n', '            csr.mstatus.mprv  <= csr_wval[17];\\n', \"            csr.mstatus.xs    <= has_ext ? csr_wval[16:15] : 2'b00; //TODO\\n\", \"            csr.mstatus.fs    <= has_fpu ? csr_wval[14:13] : 2'b00; //TODO\\n\", '\\n', '            csr.mstatus.mpp   <=         csr_wval[12:11];\\n', \"            csr.mstatus.hpp   <= has_h ? csr_wval[10:9] : 2'h0;\\n\", \"            csr.mstatus.spp   <= has_s ? csr_wval[   8] : 1'b0;\\n\", '            csr.mstatus.mpie  <=         csr_wval[   7];\\n', \"            csr.mstatus.hpie  <= has_h ? csr_wval[   6] : 1'b0;\\n\", \"            csr.mstatus.spie  <= has_s ? csr_wval[   5] : 1'b0;\\n\", \"            csr.mstatus.upie  <= has_n ? csr_wval[   4] : 1'b0;\\n\", '            csr.mstatus.mie   <=         csr_wval[   3];\\n', \"            csr.mstatus.hie   <= has_h ? csr_wval[   2] : 1'b0;\\n\", \"            csr.mstatus.sie   <= has_s ? csr_wval[   1] : 1'b0;\\n\", \"            csr.mstatus.uie   <= has_n ? csr_wval[   0] : 1'b0;\\n\", '        end\\n', '\\n', '        //Supervisor Mode access\\n', '        if (has_s)\\n', '        begin\\n', '            if ( (ex_csr_we && ex_csr_reg == SSTATUS && st_prv >= PRV_S) ||\\n', '                 (du_we_csr && du_addr    == SSTATUS)                     )\\n', '            begin\\n', '                csr.mstatus.pum  <= csr_wval[18]; \\n', \"                csr.mstatus.xs   <= has_ext ? csr_wval[16:15] : 2'b00; //TODO\\n\", \"                csr.mstatus.fs   <= has_fpu ? csr_wval[14:13] : 2'b00; //TODO\\n\", '\\n', '                csr.mstatus.spp  <= csr_wval[7];\\n', '                csr.mstatus.spie <= csr_wval[5];\\n', \"                csr.mstatus.upie <= has_n ? csr_wval[4] : 1'b0;\\n\", '                csr.mstatus.sie  <= csr_wval[1];\\n', '                csr.mstatus.uie  <= csr_wval[0];\\n', '            end\\n', '        end\\n', '\\n', '        //MRET,HRET,SRET,URET\\n', '        if (!id_bubble && !bu_flush && !du_stall)\\n', '        begin\\n', '            case (id_instr)\\n', '              //pop privilege stack\\n', '              MRET : begin\\n', '                         //set privilege level\\n', '                         st_prv    <= csr.mstatus.mpp;\\n', '                         st_nxt_pc <= csr.mepc;\\n', \"                         st_flush  <= 1'b1;\\n\", '\\n', '                         //set yIE\\n', '//                         csr.mstatus[csr.mstatus.mpp] <= csr.mstatus.mpie; <<<Quartus 16.1.2 barfs on this construct\\n', '                         case (csr.mstatus.hpp)\\n', '                           3: csr.mstatus[3] <= csr.mstatus.mpie;\\n', '                           2: csr.mstatus[2] <= csr.mstatus.mpie;\\n', '                           1: csr.mstatus[1] <= csr.mstatus.mpie;\\n', '                           0: csr.mstatus[0] <= csr.mstatus.mpie;\\n', '                         endcase\\n', '\\n', \"                         csr.mstatus.mpie <= 1'b1;\\n\", '                         csr.mstatus.mpp  <= has_u ? PRV_U : PRV_M;\\n', '                     end\\n', '              HRET : begin\\n', '                         //set privilege level\\n', '                         st_prv    <= csr.mstatus.hpp;\\n', '                         st_nxt_pc <= csr.hepc;\\n', \"                         st_flush  <= 1'b1;\\n\", '\\n', '                         //set yIE\\n', '//                         csr.mstatus[csr.mstatus.hpp] <= csr.mstatus.hpie; <<<Quartus 16.1.2 barfs on this construct\\n', '                         case (csr.mstatus.hpp)\\n', '                           3: csr.mstatus[3] <= csr.mstatus.hpie;\\n', '                           2: csr.mstatus[2] <= csr.mstatus.hpie;\\n', '                           1: csr.mstatus[1] <= csr.mstatus.hpie;\\n', '                           0: csr.mstatus[0] <= csr.mstatus.hpie;\\n', '                         endcase\\n', '\\n', \"                         csr.mstatus.hpie <= 1'b1;\\n\", '                         csr.mstatus.hpp  <= has_u ? PRV_U : PRV_M;\\n', '                     end\\n', '              SRET : begin\\n', '                         //set privilege level\\n', \"                         st_prv    <= {1'b0,csr.mstatus.spp};\\n\", '                         st_nxt_pc <= csr.sepc;\\n', \"                         st_flush  <= 1'b1;\\n\", '\\n', '                         //set yIE\\n', '//                         csr.mstatus[csr.mstatus.spp] <= csr.mstatus.spie; <<<Quartus 16.1.2 barfs on this construct\\n', '                         case(csr.mstatus.spp)\\n', '                            1: csr.mstatus[1] <= csr.mstatus.spie;\\n', '                            0: csr.mstatus[0] <= csr.mstatus.spie;\\n', '                         endcase\\n', '\\n', \"                         csr.mstatus.spie <= 1'b1;\\n\", \"                         csr.mstatus.spp  <= 1'b0; //has_u ? PRV_U : PRV_M; >>>Must have User-mode. SPP is only 1 bit\\n\", '                     end\\n', '              URET : begin\\n', '                         //set privilege level\\n', '                         st_prv    <= PRV_U;\\n', '                         st_nxt_pc <= csr.uepc;\\n', \"                         st_flush  <= 1'b1;\\n\", '\\n', '                         //set yIE\\n', \"                         csr.mstatus.uie  <= csr.mstatus.upie; //little bit silly ... should always be '1'\\n\", '\\n', \"                         csr.mstatus.upie <= 1'b1;\\n\", '                     end\\n', '            endcase\\n', '        end\\n', '\\n', '        //push privilege stack\\n', '        if (ext_nmi)\\n', '        begin\\n', '$display (\"NMI\");\\n', '            //NMI always at Machine-mode\\n', '            st_prv    <= PRV_M;\\n', '            st_nxt_pc <= csr.mnmivec;\\n', \"            st_flush  <= 1'b1;\\n\", '\\n', '            //store current state\\n', '            csr.mstatus.mpie <= csr.mstatus[st_prv];\\n', \"            csr.mstatus.mie  <= 1'b0;\\n\", '            csr.mstatus.mpp  <= st_prv;\\n', '        end\\n', '        else if (take_interrupt)\\n', '        begin\\n', '$display (\"take_interrupt\");\\n', '            st_flush  <= ~du_stall & ~du_flush;\\n', '\\n', '            //Check if interrupts are delegated\\n', \"            if (has_n && st_prv == PRV_U && ( st_int & csr.mideleg & 12'h111) )\\n\", '            begin\\n', '                st_prv    <= PRV_U;\\n', '                st_nxt_pc <= csr.utvec;\\n', '\\n', '                csr.mstatus.upie <= csr.mstatus[st_prv];\\n', \"                csr.mstatus.uie  <= 1'b0;\\n\", '            end\\n', \"            else if (has_s && st_prv >= PRV_S && (st_int & csr.mideleg & 12'h333) )\\n\", '            begin\\n', '                st_prv    <= PRV_S;\\n', '                st_nxt_pc <= csr.stvec;\\n', '\\n', '                csr.mstatus.spie <= csr.mstatus[st_prv];\\n', \"                csr.mstatus.sie  <= 1'b0;\\n\", '                csr.mstatus.spp  <= st_prv[0];\\n', '            end\\n', \"            else if (has_h && st_prv >= PRV_H && (st_int & csr.mideleg & 12'h777) )\\n\", '            begin\\n', '                st_prv    <= PRV_H;\\n', '                st_nxt_pc <= csr.htvec;\\n', '\\n', '                csr.mstatus.hpie <= csr.mstatus[st_prv];\\n', \"                csr.mstatus.hie  <= 1'b0;\\n\", '                csr.mstatus.hpp  <= st_prv;\\n', '            end\\n', '            else\\n', '            begin\\n', '                st_prv    <= PRV_M;\\n', '                st_nxt_pc <= csr.mtvec;\\n', '\\n', '                csr.mstatus.mpie <= csr.mstatus[st_prv];\\n', \"                csr.mstatus.mie  <= 1'b0;\\n\", '                csr.mstatus.mpp  <= st_prv;\\n', '            end\\n', '        end\\n', '        else if ( |(wb_exception & ~du_ie[15:0]) )\\n', '        begin\\n', '$display(\"exception\");\\n', \"            st_flush  <= 1'b1;\\n\", '\\n', '            if (has_n && st_prv == PRV_U && |(wb_exception & csr.medeleg))\\n', '            begin\\n', '                st_prv    <= PRV_U;\\n', '                st_nxt_pc <= csr.utvec;\\n', '\\n', '                csr.mstatus.upie <= csr.mstatus[st_prv];\\n', \"                csr.mstatus.uie  <= 1'b0;\\n\", '            end\\n', '            else if (has_s && st_prv >= PRV_S && |(wb_exception & csr.medeleg))\\n', '            begin\\n', '                st_prv    <= PRV_S;\\n', '                st_nxt_pc <= csr.stvec;\\n', '\\n', '                csr.mstatus.spie <= csr.mstatus[st_prv];\\n', \"                csr.mstatus.sie  <= 1'b0;\\n\", '                csr.mstatus.spp  <= st_prv[0];\\n', '\\n', '            end\\n', '            else if (has_h && st_prv >= PRV_H && |(wb_exception & csr.medeleg))\\n', '            begin\\n', '                st_prv    <= PRV_H;\\n', '                st_nxt_pc <= csr.htvec;\\n', '\\n', '                csr.mstatus.hpie <= csr.mstatus[st_prv];\\n', \"                csr.mstatus.hie  <= 1'b0;\\n\", '                csr.mstatus.hpp  <= st_prv;\\n', '            end\\n', '            else\\n', '            begin\\n', '                st_prv    <= PRV_M;\\n', '                st_nxt_pc <= csr.mtvec;\\n', '\\n', '                csr.mstatus.mpie <= csr.mstatus[st_prv];\\n', \"                csr.mstatus.mie  <= 1'b0;\\n\", '                csr.mstatus.mpp  <= st_prv;\\n', '            end\\n', '        end\\n', '    end\\n', '\\n', '\\n', '  /*\\n', '   * mcycle, minstret\\n', '   */\\n', 'generate\\n', '  if (XLEN==32)\\n', '  begin\\n', '      always @(posedge clk,negedge rstn)\\n', '      if (!rstn)\\n', '      begin\\n', \"          csr.cycle   <= 'h0;\\n\", \"          csr.instret <= 'h0;\\n\", '      end\\n', '      else\\n', '      begin\\n', '          //cycle always counts (thread active time)\\n', '          if      ( (ex_csr_we && ex_csr_reg == MCYCLE) ||\\n', '                    (du_we_csr && du_addr    == MCYCLE)  )\\n', '            csr.cycle.l <= csr_wval;\\n', '          else if ( (ex_csr_we && ex_csr_reg == MCYCLEH) ||\\n', '                    (du_we_csr && du_addr    == MCYCLEH)  )\\n', '            csr.cycle.h <= csr_wval;\\n', '          else\\n', \"            csr.cycle <= csr.cycle + 'h1;\\n\", '\\n', '          //User Mode instruction retire counter\\n', '          if      ( (ex_csr_we && ex_csr_reg == MINSTRET) ||\\n', '                    (du_we_csr && du_addr    == MINSTRET)  )\\n', '            csr.instret.l <= csr_wval;\\n', '          else if ( (ex_csr_we && ex_csr_reg == MINSTRETH) ||\\n', '                    (du_we_csr && du_addr    == MINSTRETH)  )\\n', '            csr.instret.h <= csr_wval;\\n', '          else if   (!id_stall && !bu_flush && !du_stall && st_prv == PRV_M)\\n', \"            csr.instret <= csr.instret + 'h1;\\n\", '      end\\n', '  end\\n', '  else //(XLEN > 32)\\n', '  begin\\n', '      always @(posedge clk,negedge rstn)\\n', '      if (!rstn)\\n', '      begin\\n', \"          csr.cycle   <= 'h0;\\n\", \"          csr.instret <= 'h0;\\n\", '      end\\n', '      else\\n', '      begin\\n', '          //cycle always counts (thread active time)\\n', '          if ( (ex_csr_we && ex_csr_reg == MCYCLE) ||\\n', '               (du_we_csr && du_addr    == MCYCLE)  )\\n', '            csr.cycle <= csr_wval;\\n', '          else\\n', \"            csr.cycle <= csr.cycle + 'h1;\\n\", '\\n', '          //User Mode instruction retire counter\\n', '          if ( (ex_csr_we && ex_csr_reg == MINSTRET) ||\\n', '               (du_we_csr && du_addr    == MINSTRET)  )\\n', '            csr.instret <= csr_wval;\\n', '          else if (!id_stall && !bu_flush && !du_stall && st_prv == PRV_M)\\n', \"            csr.instret <= csr.instret + 'h1;\\n\", '      end\\n', '  end\\n', 'endgenerate\\n', '\\n', '\\n', '  /*\\n', '   * mnmivec - RoaLogic Extension\\n', '   */\\n', '  always @(posedge clk,negedge rstn)\\n', '    if (!rstn)\\n', '      csr.mnmivec <= MNMIVEC_DEFAULT;\\n', '    else if ( (ex_csr_we && ex_csr_reg == MNMIVEC && st_prv == PRV_M) ||\\n', '              (du_we_csr && du_addr    == MNMIVEC)                     )\\n', \"      csr.mnmivec <= {csr_wval[XLEN-1:2],2'b00};\\n\", '\\n', '\\n', '  /*\\n', '   * mtvec\\n', '   */\\n', '  always @(posedge clk,negedge rstn)\\n', '    if (!rstn)\\n', '      csr.mtvec <= MTVEC_DEFAULT;\\n', '    else if ( (ex_csr_we && ex_csr_reg == MTVEC && st_prv == PRV_M) ||\\n', '              (du_we_csr && du_addr    == MTVEC)                     )\\n', \"      csr.mtvec <= {csr_wval[XLEN-1:2],2'b00};\\n\", '\\n', '\\n', '  /*\\n', '   * medeleg, mideleg\\n', '   */\\n', 'generate\\n', '  if (!HAS_HYPER && !HAS_SUPER && !HAS_USER)\\n', '  begin\\n', '      assign csr.medeleg = 0;\\n', '      assign csr.mideleg = 0;\\n', '  end\\n', '  else\\n', '  begin\\n', '      //medeleg\\n', '      always @(posedge clk,negedge rstn)\\n', '        if (!rstn)\\n', \"          csr.medeleg <= 'h0;\\n\", '        else if ( (ex_csr_we && ex_csr_reg == MEDELEG && st_prv == PRV_M) ||\\n', '                  (du_we_csr && du_addr    == MEDELEG)                     )\\n', \"          csr.medeleg <= csr_wval & 12'hFFF;\\n\", '\\n', '      //mideleg\\n', '      always @(posedge clk,negedge rstn)\\n', '        if (!rstn)\\n', \"          csr.mideleg <= 'h0;\\n\", '        else if ( (ex_csr_we && ex_csr_reg == MIDELEG && st_prv == PRV_M) ||\\n', '                  (du_we_csr && du_addr    == MIDELEG)                )\\n', \"          csr.mideleg <= csr_wval & 12'h777;\\n\", '        else if (has_h)\\n', '        begin\\n', '            if ( (ex_csr_we && ex_csr_reg == HIDELEG && st_prv >= PRV_H) ||\\n', '                 (du_we_csr && du_addr    == HIDELEG)                )\\n', '            begin\\n', '                csr.mideleg[SSI] <= has_s & csr_wval[SSI];\\n', '                csr.mideleg[USI] <= has_n & csr_wval[USI];\\n', '            end\\n', '        end\\n', '        else if (has_s)\\n', '        begin\\n', '            if ( (ex_csr_we && ex_csr_reg == SIDELEG && st_prv >= PRV_S) ||\\n', '                 (du_we_csr && du_addr    == SIDELEG)                )\\n', '            begin\\n', '                csr.mideleg[USI] <= has_n & csr_wval[USI];\\n', '            end\\n', '        end\\n', '  end\\n', 'endgenerate\\n', '\\n', '\\n', '  /*\\n', '   * mip\\n', '   */\\n', '  always @(posedge clk,negedge rstn)\\n', '    if (!rstn)\\n', \"      csr.mip <= 'h0;\\n\", '    else\\n', '    begin\\n', '        //external interrupts\\n', '        csr.mip.meip <= ext_int[PRV_M]; \\n', '        csr.mip.heip <= ext_int[PRV_H] & has_h;\\n', '        csr.mip.seip <= ext_int[PRV_S] & has_s;\\n', '        csr.mip.ueip <= ext_int[PRV_U] & has_n;\\n', ' \\n', '\\n', '        //timer interrupts\\n', '        csr.mip.mtip <= ext_tint;\\n', '        //may only be written by M-mode\\n', '        if ( (ex_csr_we & ex_csr_reg == MIP & st_prv == PRV_M) ||\\n', '             (du_we_csr & du_addr    == MIP)                  )\\n', '        begin\\n', '            csr.mip.htip <= csr_wval[HTI] & has_h;\\n', '            csr.mip.stip <= csr_wval[STI] & has_s;\\n', '            csr.mip.utip <= csr_wval[UTI] & has_n;\\n', '        end\\n', '\\n', '\\n', '        //software interrupts\\n', '        csr.mip.msip <= ext_sint;\\n', '        //Machine Mode write\\n', '        if ( (ex_csr_we && ex_csr_reg == MIP && st_prv == PRV_M) ||\\n', '             (du_we_csr && du_addr    == MIP)                   )\\n', '        begin\\n', '            csr.mip.hsip <= csr_wval[HSI] & has_h;\\n', '            csr.mip.ssip <= csr_wval[SSI] & has_s;\\n', '            csr.mip.usip <= csr_wval[USI] & has_n;\\n', '        end\\n', '        else if (has_h)\\n', '        begin\\n', '            //Hypervisor Mode write\\n', '            if ( (ex_csr_we && ex_csr_reg == HIP && st_prv >= PRV_H) ||\\n', '                 (du_we_csr && du_addr    == HIP)                   )\\n', '            begin\\n', '                csr.mip.hsip <= csr_wval[HSI] & csr.mideleg[HSI];\\n', '                csr.mip.ssip <= csr_wval[SSI] & csr.mideleg[SSI] & has_s;\\n', '                csr.mip.usip <= csr_wval[USI] & csr.mideleg[USI] & has_n;\\n', '            end\\n', '        end\\n', '        else if (has_s)\\n', '        begin\\n', '            //Supervisor Mode write\\n', '            if ( (ex_csr_we && ex_csr_reg == SIP && st_prv >= PRV_S) ||\\n', '                 (du_we_csr && du_addr    == SIP)                   )\\n', '            begin\\n', '                csr.mip.ssip <= csr_wval[SSI] & csr.mideleg[SSI];\\n', '                csr.mip.usip <= csr_wval[USI] & csr.mideleg[USI] & has_n;\\n', '            end\\n', '        end\\n', '        else if (has_n)\\n', '        begin\\n', '            //User Mode write\\n', '            if ( (ex_csr_we && ex_csr_reg == UIP) ||\\n', '                 (du_we_csr && du_addr    == UIP)  )\\n', '            begin\\n', '                csr.mip.usip <= csr_wval[USI] & csr.mideleg[USI];\\n', '            end\\n', '        end\\n', '    end\\n', '\\n', '\\n', '  /*\\n', '   * mie\\n', '   */\\n', '  always @(posedge clk,negedge rstn)\\n', '    if (!rstn)\\n', \"      csr.mie <= 'h0;\\n\", '    else if ( (ex_csr_we && ex_csr_reg == MIE && st_prv == PRV_M) ||\\n', '              (du_we_csr && du_addr    == MIE)                   )\\n', '    begin\\n', '        csr.mie.meie <= csr_wval[MEI];\\n', '        csr.mie.heie <= csr_wval[HEI] & has_h;\\n', '        csr.mie.seie <= csr_wval[SEI] & has_s;\\n', '        csr.mie.ueie <= csr_wval[UEI] & has_n;\\n', '        csr.mie.mtie <= csr_wval[MTI];\\n', '        csr.mie.htie <= csr_wval[HTI] & has_h;\\n', '        csr.mie.stie <= csr_wval[STI] & has_s;\\n', '        csr.mie.utie <= csr_wval[UTI] & has_n;\\n', '        csr.mie.msie <= csr_wval[MSI];\\n', '        csr.mie.hsie <= csr_wval[HSI] & has_h;\\n', '        csr.mie.ssie <= csr_wval[SSI] & has_s;\\n', '        csr.mie.usie <= csr_wval[USI] & has_n;\\n', '    end\\n', '    else if (has_h)\\n', '    begin\\n', '        if ( (ex_csr_we && ex_csr_reg == HIE && st_prv >= PRV_H) ||\\n', '             (du_we_csr && du_addr    == HIE)                   )\\n', '        begin\\n', '            csr.mie.heie <= csr_wval[HEI];\\n', '            csr.mie.seie <= csr_wval[SEI] & has_s;\\n', '            csr.mie.ueie <= csr_wval[UEI] & has_n;\\n', '            csr.mie.htie <= csr_wval[HTI];\\n', '            csr.mie.stie <= csr_wval[STI] & has_s;\\n', '            csr.mie.utie <= csr_wval[UTI] & has_n;\\n', '            csr.mie.hsie <= csr_wval[HSI];\\n', '            csr.mie.ssie <= csr_wval[SSI] & has_s;\\n', '            csr.mie.usie <= csr_wval[USI] & has_n;\\n', '        end\\n', '    end\\n', '    else if (has_s)\\n', '    begin\\n', '        if ( (ex_csr_we && ex_csr_reg == SIE && st_prv >= PRV_S) ||\\n', '             (du_we_csr && du_addr    == SIE)                   )\\n', '        begin\\n', '            csr.mie.seie <= csr_wval[SEI];\\n', '            csr.mie.ueie <= csr_wval[UEI] & has_n;\\n', '            csr.mie.stie <= csr_wval[STI];\\n', '            csr.mie.utie <= csr_wval[UTI] & has_n;\\n', '            csr.mie.ssie <= csr_wval[SSI];\\n', '            csr.mie.usie <= csr_wval[USI] & has_n;\\n', '        end\\n', '    end\\n', '   else if (has_n)\\n', '    begin\\n', '        if ( (ex_csr_we && ex_csr_reg == UIE) ||\\n', '             (du_we_csr && du_addr    == UIE)  )\\n', '        begin\\n', '            csr.mie.ueie <= csr_wval[UEI];\\n', '            csr.mie.utie <= csr_wval[UTI];\\n', '            csr.mie.usie <= csr_wval[USI];\\n', '        end\\n', '    end\\n', '\\n', '\\n', '  /*\\n', '   * mscratch\\n', '   */\\n', '  always @(posedge clk,negedge rstn)\\n', \"    if      (!rstn)                                                    csr.mscratch <= 'h0;\\n\", '    else if ( (ex_csr_we && ex_csr_reg == MSCRATCH && st_prv == PRV_M) ||\\n', '              (du_we_csr && du_addr    == MSCRATCH)                  ) csr.mscratch <= csr_wval;\\n', '\\n', '\\n', '  always_comb\\n', '    casex (wb_exception & ~du_ie[15:0])\\n', \"      12'b????_????_???1: trap_cause =  0;\\n\", \"      12'b????_????_??10: trap_cause =  1;\\n\", \"      12'b????_????_?100: trap_cause =  2;\\n\", \"      12'b????_????_1000: trap_cause =  3;\\n\", \"      12'b????_???1_0000: trap_cause =  4;\\n\", \"      12'b????_??10_0000: trap_cause =  5;\\n\", \"      12'b????_?100_0000: trap_cause =  6;\\n\", \"      12'b????_1000_0000: trap_cause =  7;\\n\", \"      12'b???1_0000_0000: trap_cause =  8;\\n\", \"      12'b??10_0000_0000: trap_cause =  9;\\n\", \"      12'b?100_0000_0000: trap_cause = 10;\\n\", \"      12'b1000_0000_0000: trap_cause = 11;\\n\", '      default           : trap_cause =  0;\\n', '    endcase\\n', '\\n', '\\n', '  //decode interrupts\\n', '  //priority external, software, timer\\n', '  assign st_int[CAUSE_MEINT] = ( ((st_prv < PRV_M) | (st_prv == PRV_M & csr.mstatus.mie)) & (csr.mip.meip & csr.mie.meie) );\\n', '  assign st_int[CAUSE_HEINT] = ( ((st_prv < PRV_H) | (st_prv == PRV_H & csr.mstatus.hie)) & (csr.mip.heip & csr.mie.heie) );\\n', '  assign st_int[CAUSE_SEINT] = ( ((st_prv < PRV_S) | (st_prv == PRV_S & csr.mstatus.sie)) & (csr.mip.seip & csr.mie.seie) );\\n', '  assign st_int[CAUSE_UEINT] = (                     (st_prv == PRV_U & csr.mstatus.uie)  & (csr.mip.ueip & csr.mie.ueie) );\\n', '\\n', '  assign st_int[CAUSE_MSINT] = ( ((st_prv < PRV_M) | (st_prv == PRV_M & csr.mstatus.mie)) & (csr.mip.msip & csr.mie.msie) ) & ~st_int[CAUSE_MEINT];\\n', '  assign st_int[CAUSE_HSINT] = ( ((st_prv < PRV_H) | (st_prv == PRV_H & csr.mstatus.hie)) & (csr.mip.hsip & csr.mie.hsie) ) & ~st_int[CAUSE_HEINT];\\n', '  assign st_int[CAUSE_SSINT] = ( ((st_prv < PRV_S) | (st_prv == PRV_S & csr.mstatus.sie)) & (csr.mip.ssip & csr.mie.ssie) ) & ~st_int[CAUSE_SEINT];\\n', '  assign st_int[CAUSE_USINT] = (                     (st_prv == PRV_U & csr.mstatus.uie)  & (csr.mip.usip & csr.mie.usie) ) & ~st_int[CAUSE_UEINT];\\n', '\\n', '  assign st_int[CAUSE_MTINT] = ( ((st_prv < PRV_M) | (st_prv == PRV_M & csr.mstatus.mie)) & (csr.mip.mtip & csr.mie.mtie) ) & ~(st_int[CAUSE_MEINT] | st_int[CAUSE_MSINT]);\\n', '  assign st_int[CAUSE_HTINT] = ( ((st_prv < PRV_H) | (st_prv == PRV_H & csr.mstatus.hie)) & (csr.mip.htip & csr.mie.htie) ) & ~(st_int[CAUSE_HEINT] | st_int[CAUSE_HSINT]);\\n', '  assign st_int[CAUSE_STINT] = ( ((st_prv < PRV_S) | (st_prv == PRV_S & csr.mstatus.sie)) & (csr.mip.stip & csr.mie.stie) ) & ~(st_int[CAUSE_SEINT] | st_int[CAUSE_SSINT]);\\n', '  assign st_int[CAUSE_UTINT] = (                     (st_prv == PRV_U & csr.mstatus.uie)  & (csr.mip.utip & csr.mie.utie) ) & ~(st_int[CAUSE_UEINT] | st_int[CAUSE_USINT]);\\n', '\\n', '\\n', '  //interrupt cause priority\\n', '  always_comb\\n', '    casex (st_int & ~du_ie[31:16])\\n', \"       12'h??1 : interrupt_cause = 0;\\n\", \"       12'h??2 : interrupt_cause = 1;\\n\", \"       12'h??4 : interrupt_cause = 2;\\n\", \"       12'h??8 : interrupt_cause = 3;\\n\", \"       12'h?10 : interrupt_cause = 4;\\n\", \"       12'h?20 : interrupt_cause = 5;\\n\", \"       12'h?40 : interrupt_cause = 6;\\n\", \"       12'h?80 : interrupt_cause = 7;\\n\", \"       12'h100 : interrupt_cause = 8;\\n\", \"       12'h200 : interrupt_cause = 9;\\n\", \"       12'h400 : interrupt_cause =10;\\n\", \"       12'h800 : interrupt_cause =11;\\n\", '       default : interrupt_cause = 0;\\n', '    endcase\\n', '\\n', '  assign take_interrupt = |(st_int & ~du_ie[31:16]);\\n', '\\n', '\\n', '  //for Debug Unit\\n', \"  assign du_exceptions = { {16-$bits(st_int){1'b0}}, st_int, {16-$bits(wb_exception){1'b0}}, wb_exception} & du_ie;\\n\", '\\n', '\\n', '  //Update mepc and mcause\\n', '  always @(posedge clk,negedge rstn)\\n', '    if (!rstn)\\n', '    begin\\n', \"        st_interrupt <= 'b0;\\n\", '\\n', \"        csr.mepc     <= 'h0;\\n\", \"        csr.hepc     <= 'h0;\\n\", \"        csr.sepc     <= 'h0;\\n\", \"        csr.uepc     <= 'h0;\\n\", '\\n', \"        csr.mcause   <= 'h0;\\n\", \"        csr.hcause   <= 'h0;\\n\", \"        csr.scause   <= 'h0;\\n\", \"        csr.ucause   <= 'h0;\\n\", '\\n', \"        csr.mbadaddr <= 'h0;\\n\", \"        csr.hbadaddr <= 'h0;\\n\", \"        csr.sbadaddr <= 'h0;\\n\", \"        csr.ubadaddr <= 'h0;\\n\", '    end\\n', '    else\\n', '    begin\\n', '        //Write access to regs (lowest priority)\\n', '        if ( (ex_csr_we && ex_csr_reg == MEPC && st_prv == PRV_M) ||\\n', '             (du_we_csr && du_addr    == MEPC)                  )\\n', \"          csr.mepc <= {csr_wval[XLEN-1:2], csr_wval[1] & has_rvc, 1'b0};\\n\", '\\n', '        if ( (ex_csr_we && ex_csr_reg == HEPC && st_prv >= PRV_H) ||\\n', '             (du_we_csr && du_addr    == HEPC)                  )\\n', \"          csr.hepc <= {csr_wval[XLEN-1:2], csr_wval[1] & has_rvc, 1'b0};\\n\", '\\n', '        if ( (ex_csr_we && ex_csr_reg == SEPC && st_prv >= PRV_S) ||\\n', '             (du_we_csr && du_addr    == SEPC)                  )\\n', \"          csr.sepc <= {csr_wval[XLEN-1:2], csr_wval[1] & has_rvc, 1'b0};\\n\", '\\n', '        if ( (ex_csr_we && ex_csr_reg == UEPC && st_prv >= PRV_U) ||\\n', '             (du_we_csr && du_addr    == UEPC)                  )\\n', \"          csr.uepc <= {csr_wval[XLEN-1:2], csr_wval[1] & has_rvc, 1'b0};\\n\", '\\n', '\\n', '        if ( (ex_csr_we && ex_csr_reg == MCAUSE && st_prv == PRV_M) ||\\n', '             (du_we_csr && du_addr    == MCAUSE)                  )\\n', '          csr.mcause <= csr_wval;\\n', '\\n', '        if ( (ex_csr_we && ex_csr_reg == HCAUSE && st_prv >= PRV_H) ||\\n', '             (du_we_csr && du_addr    == HCAUSE)                  )\\n', '          csr.hcause <= csr_wval;\\n', '\\n', '        if ( (ex_csr_we && ex_csr_reg == SCAUSE && st_prv >= PRV_S) ||\\n', '             (du_we_csr && du_addr    == SCAUSE)                  )\\n', '          csr.scause <= csr_wval;\\n', '\\n', '        if ( (ex_csr_we && ex_csr_reg == UCAUSE && st_prv >= PRV_U) ||\\n', '             (du_we_csr && du_addr    == UCAUSE)                  )\\n', '          csr.ucause <= csr_wval;\\n', '\\n', '\\n', '        if ( (ex_csr_we && ex_csr_reg == MBADADDR && st_prv == PRV_M) ||\\n', '             (du_we_csr && du_addr    == MBADADDR)                  )\\n', '          csr.mbadaddr <= csr_wval;\\n', '\\n', '        if ( (ex_csr_we && ex_csr_reg == HBADADDR && st_prv >= PRV_H) ||\\n', '             (du_we_csr && du_addr    == HBADADDR)                  )\\n', '          csr.hbadaddr <= csr_wval;\\n', '\\n', '        if ( (ex_csr_we && ex_csr_reg == SBADADDR && st_prv >= PRV_S) ||\\n', '             (du_we_csr && du_addr    == SBADADDR)                  )\\n', '          csr.sbadaddr <= csr_wval;\\n', '\\n', '        if ( (ex_csr_we && ex_csr_reg == UBADADDR && st_prv >= PRV_U) ||\\n', '             (du_we_csr && du_addr    == UBADADDR)                  )\\n', '          csr.ubadaddr <= csr_wval;\\n', '\\n', '\\n', '        /*\\n', '         * Handle exceptions\\n', '         */\\n', \"        st_interrupt <= 1'b0;\\n\", '\\n', '        //priority external interrupts, software interrupts, timer interrupts, traps\\n', \"        if (ext_nmi) //TODO: doesn't this cause a deadlock? Need to hold of NMI once handled\\n\", '        begin\\n', '            //NMI always at Machine Level\\n', \"            st_interrupt <= 1'b1;\\n\", '            csr.mepc     <= bu_flush ? bu_nxt_pc : id_pc;\\n', \"            csr.mcause   <= (1 << (XLEN-1)) | 'h0; //Implementation dependent. '0' indicates 'unknown cause'\\n\", '        end\\n', '        else if (take_interrupt)\\n', '        begin\\n', \"            st_interrupt <= 1'b1;\\n\", '\\n', '            //Check if interrupts are delegated\\n', \"            if (has_n && st_prv == PRV_U && ( st_int & csr.mideleg & 12'h111) )\\n\", '            begin\\n', '                csr.ucause <= (1 << (XLEN-1)) | interrupt_cause;\\n', '                csr.uepc   <= id_pc;\\n', '            end\\n', \"            else if (has_s && st_prv >= PRV_S && (st_int & csr.mideleg & 12'h333) )\\n\", '            begin\\n', '                csr.scause <= (1 << (XLEN-1)) | interrupt_cause;;\\n', '                csr.sepc   <= id_pc;\\n', '            end\\n', \"            else if (has_h && st_prv >= PRV_H && (st_int & csr.mideleg & 12'h777) )\\n\", '            begin\\n', '                csr.hcause <= (1 << (XLEN-1)) | interrupt_cause;;\\n', '                csr.hepc   <= id_pc;\\n', '            end\\n', '            else\\n', '            begin\\n', '                csr.mcause <= (1 << (XLEN-1)) | interrupt_cause;;\\n', '                csr.mepc   <= id_pc;\\n', '            end\\n', '        end\\n', '        else if (|(wb_exception & ~du_ie[15:0]))\\n', '        begin\\n', '            //Trap\\n', '            if (has_n && st_prv == PRV_U && |(wb_exception & csr.medeleg))\\n', '            begin\\n', '                csr.uepc   <= wb_pc;\\n', '                csr.ucause <= trap_cause;\\n', '            end\\n', '            else if (has_s && st_prv >= PRV_S && |(wb_exception & csr.medeleg))\\n', '            begin\\n', '                csr.sepc   <= wb_pc;\\n', '                csr.scause <= trap_cause;\\n', '                if (wb_exception[CAUSE_MISALIGNED_INSTRUCTION] || wb_exception[CAUSE_INSTRUCTION_ACCESS_FAULT] ||\\n', '                                                                  wb_exception[CAUSE_LOAD_ACCESS_FAULT       ] ||\\n', '                    wb_exception[CAUSE_MISALIGNED_STORE      ] || wb_exception[CAUSE_STORE_ACCESS_FAULT      ])\\n', '                csr.sbadaddr <= wb_badaddr;\\n', '            end\\n', '            else if (has_h && st_prv >= PRV_H && |(wb_exception & csr.medeleg))\\n', '            begin\\n', '                csr.hepc   <= wb_pc;\\n', '                csr.hcause <= trap_cause;\\n', '\\n', '                if (wb_exception[CAUSE_MISALIGNED_INSTRUCTION] || wb_exception[CAUSE_INSTRUCTION_ACCESS_FAULT] ||\\n', '                    wb_exception[CAUSE_MISALIGNED_LOAD       ] || wb_exception[CAUSE_LOAD_ACCESS_FAULT       ] ||\\n', '                    wb_exception[CAUSE_MISALIGNED_STORE      ] || wb_exception[CAUSE_STORE_ACCESS_FAULT      ])\\n', '                csr.hbadaddr <= wb_badaddr;\\n', '            end\\n', '            else\\n', '            begin\\n', '                csr.mepc   <= wb_pc;\\n', '                csr.mcause <= trap_cause;\\n', '\\n', '                if (wb_exception[CAUSE_MISALIGNED_INSTRUCTION] || wb_exception[CAUSE_INSTRUCTION_ACCESS_FAULT] ||\\n', '                    wb_exception[CAUSE_MISALIGNED_LOAD       ] || wb_exception[CAUSE_LOAD_ACCESS_FAULT       ] ||\\n', '                    wb_exception[CAUSE_MISALIGNED_STORE      ] || wb_exception[CAUSE_STORE_ACCESS_FAULT      ])\\n', '                csr.mbadaddr <= wb_badaddr;\\n', '            end\\n', '        end\\n', '     end\\n', '\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //Supervisor Registers\\n', '  //\\n', 'generate\\n', '  if (HAS_SUPER)\\n', '  begin\\n', '      //stvec\\n', '      always @(posedge clk,negedge rstn)\\n', '        if      (!rstn)\\n', '          csr.stvec <= STVEC_DEFAULT;\\n', '        else if ( (ex_csr_we && ex_csr_reg == STVEC && st_prv >= PRV_S) ||\\n', '                  (du_we_csr && du_addr    == STVEC)                     )\\n', \"          csr.stvec <= {csr_wval[XLEN-1:2],2'b00};\\n\", '\\n', '      //sedeleg\\n', '      always @(posedge clk,negedge rstn)\\n', '        if      (!rstn)\\n', \"          csr.sedeleg <= 'h0;\\n\", '        else if ( (ex_csr_we && ex_csr_reg == SEDELEG && st_prv >= PRV_S) ||\\n', '                  (du_we_csr && du_addr    == SEDELEG)                     )\\n', '          csr.sedeleg <= csr_wval & ((1<<CAUSE_UMODE_ECALL) | (1<<CAUSE_SMODE_ECALL));\\n', '\\n', '      //sscratch\\n', '      always @(posedge clk,negedge rstn)\\n', '        if      (!rstn)\\n', \"          csr.sscratch <= 'h0;\\n\", '        else if ( (ex_csr_we && ex_csr_reg == SSCRATCH && st_prv >= PRV_S) ||\\n', '                  (du_we_csr && du_addr    == SSCRATCH)                     )\\n', '          csr.sscratch <= csr_wval;\\n', '\\n', '      //sptbr\\n', '      always @(posedge clk,negedge rstn)\\n', '        if      (!rstn)\\n', \"          csr.sptbr <= 'h0;\\n\", '        else if ( (ex_csr_we && ex_csr_reg == SPTBR && st_prv >= PRV_S) ||\\n', '                  (du_we_csr && du_addr    == SPTBR)                     )\\n', '          csr.sptbr <= ex_csr_wval;\\n', '  end\\n', '  else //NO SUPERVISOR MODE\\n', '  begin\\n', \"      assign csr.stvec    = 'h0;\\n\", \"      assign csr.sedeleg  = 'h0;\\n\", \"      assign csr.sscratch = 'h0;\\n\", \"      assign csr.sptbr    = 'h0;\\n\", '  end\\n', 'endgenerate\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //User Registers\\n', '  //\\n', 'generate\\n', '  if (HAS_USER)\\n', '  begin\\n', '      //utvec\\n', '      always @(posedge clk,negedge rstn)\\n', '        if      (!rstn)\\n', '          csr.utvec <= UTVEC_DEFAULT;\\n', '        else if ( (ex_csr_we && ex_csr_reg == UTVEC) ||\\n', '                  (du_we_csr && du_addr    == UTVEC)  )\\n', \"          csr.utvec <= {csr_wval[XLEN-1:2],2'b00};\\n\", '\\n', '      //uscratch\\n', '      always @(posedge clk,negedge rstn)\\n', '        if      (!rstn)\\n', \"          csr.uscratch <= 'h0;\\n\", '        else if ( (ex_csr_we && ex_csr_reg == USCRATCH) ||\\n', '                  (du_we_csr && du_addr    == USCRATCH)  )\\n', '          csr.uscratch <= csr_wval;\\n', '\\n', '      //Floating point registers\\n', '      if (HAS_FPU)\\n', '      begin\\n', '          //TODO\\n', '      end\\n', '  end\\n', '  else //NO USER MODE\\n', '  begin\\n', \"      assign csr.utvec    = 'h0;\\n\", \"      assign csr.uscratch = 'h0;\\n\", \"      assign csr.fcsr     = 'h0;\\n\", '  end\\n', 'endgenerate\\n', '\\n', '\\n', 'endmodule \\n']"}
{"text": "['/////////////////////////////////////////////////////////////////////\\n', '//   ,------.                    ,--.                ,--.          //\\n', \"//   |  .--. ' ,---.  ,--,--.    |  |    ,---. ,---. `--' ,---.    //\\n\", \"//   |  '--'.'| .-. |' ,-.  |    |  |   | .-. | .-. |,--.| .--'    //\\n\", \"//   |  |\\\\  \\\\ ' '-' '\\\\ '-'  |    |  '--.' '-' ' '-' ||  |\\\\ `--.    //\\n\", \"//   `--' '--' `---'  `--`--'    `-----' `---' `-   /`--' `---'    //\\n\", \"//                                             `---'               //\\n\", '//    RISC-V                                                       //\\n', '//    Data Memory Access - Write Back                              //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '//                                                                 //\\n', '//             Copyright (C) 2014-2022 ROA Logic BV                //\\n', '//             www.roalogic.com                                    //\\n', '//                                                                 //\\n', '//     Unless specifically agreed in writing, this software is     //\\n', '//   licensed under the RoaLogic Non-Commercial License            //\\n', '//   version-1.0 (the \"License\"), a copy of which is included      //\\n', '//   with this file or may be found on the RoaLogic website        //\\n', '//   http://www.roalogic.com. You may not use the file except      //\\n', '//   in compliance with the License.                               //\\n', '//                                                                 //\\n', '//     THIS SOFTWARE IS PROVIDED \"AS IS\" AND WITHOUT ANY           //\\n', '//   EXPRESS OF IMPLIED WARRANTIES OF ANY KIND.                    //\\n', '//   See the License for permissions and limitations under the     //\\n', '//   License.                                                      //\\n', '//                                                                 //\\n', '/////////////////////////////////////////////////////////////////////\\n', '\\n', 'module riscv_wb\\n', 'import riscv_opcodes_pkg::*;\\n', 'import riscv_state_pkg::*;\\n', '#(\\n', '  parameter               XLEN    = 32,\\n', \"  parameter   [XLEN -1:0] PC_INIT = 'h200\\n\", ')\\n', '(\\n', '  input  logic                   rst_ni,        //Reset\\n', '  input  logic                   clk_i,         //Clock\\n', '\\n', '  output logic                   wb_stall_o,    //Stall on memory-wait\\n', '\\n', '  input  logic [XLEN       -1:0] mem_pc_i,\\n', '  output logic [XLEN       -1:0] wb_pc_o,\\n', '\\n', '  input  instruction_t           mem_insn_i,\\n', '  output instruction_t           wb_insn_o,\\n', '\\n', '  input  interrupts_exceptions_t mem_exceptions_i,\\n', '  output interrupts_exceptions_t wb_exceptions_o,\\n', '  output logic [XLEN       -1:0] wb_badaddr_o,\\n', '\\n', '  input  logic [XLEN       -1:0] mem_r_i,\\n', '                                 mem_memadr_i,\\n', '\\n', '  //From Memory System\\n', '  input  logic                   dmem_ack_i,\\n', '                                 dmem_err_i,\\n', '  input  logic [XLEN       -1:0] dmem_q_i,\\n', '  input  logic                   dmem_misaligned_i,\\n', '                                 dmem_page_fault_i,\\n', '\\n', '  //to ID for early feedback to EX\\n', '  output logic [XLEN       -1:0] wb_memq_o,\\n', '\\n', '  //To Register File\\n', '  output rsd_t                   wb_dst_o,\\n', '  output logic [XLEN       -1:0] wb_r_o,\\n', '  output logic                   wb_we_o\\n', ');\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Variables\\n', '  //\\n', '  opcR_t                  opcR;\\n', '  logic [            6:2] opcode;\\n', '  rsd_t                   dst;\\n', '\\n', '  interrupts_exceptions_t exceptions;\\n', '\\n', '`ifdef RV_NO_X_ON_LOAD\\n', '  bit   [XLEN       -1:0] dmem_q;\\n', '`else\\n', '  logic [XLEN       -1:0] dmem_q;\\n', '`endif\\n', '  logic [            7:0] m_qb;\\n', '  logic [           15:0] m_qh;\\n', '  logic [           31:0] m_qw;\\n', '\\n', '\\n', '  ////////////////////////////////////////////////////////////////\\n', '  //\\n', '  // Module Body\\n', '  //\\n', '\\n', '  /*\\n', '   * Program Counter\\n', '   */\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if      (!rst_ni    ) wb_pc_o <= PC_INIT;\\n', '    else if (!wb_stall_o) wb_pc_o <= mem_pc_i;\\n', '\\n', '\\n', '  /*\\n', '   * Instruction\\n', '   */\\n', '  always @(posedge clk_i)\\n', '    if (!wb_stall_o) wb_insn_o.instr <= mem_insn_i.instr;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni    ) wb_insn_o.dbg <= 1'b0;\\n\", '    else if (!wb_stall_o) wb_insn_o.dbg <= mem_insn_i.dbg;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni             ) wb_insn_o.bubble <= 1'b1;\\n\", \"    else if ( wb_exceptions_o.any) wb_insn_o.bubble <= 1'b1;\\n\", '    else if (!wb_stall_o         ) wb_insn_o.bubble <= mem_insn_i.bubble;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni             ) wb_insn_o.retired <= 'h0;\\n\", \"    else if ( wb_exceptions_o.any) wb_insn_o.retired <= 'h0;\\n\", \"    else if ( wb_stall_o         ) wb_insn_o.retired <= 'h0;\\n\", '    else                           wb_insn_o.retired <= mem_insn_i.retired;\\n', '\\n', '\\n', '  assign opcR = decode_opcR(mem_insn_i.instr);\\n', '  assign dst  = decode_rd(mem_insn_i.instr);\\n', '\\n', '\\n', '  /*\\n', '   * Exception\\n', '   */\\n', '  always_comb\\n', '    begin\\n', '        exceptions = mem_exceptions_i;\\n', '\\n', '        if (opcR.opcode == OPC_LOAD  && !mem_insn_i.bubble) exceptions.exceptions.misaligned_load    = dmem_misaligned_i;\\n', '        if (opcR.opcode == OPC_STORE && !mem_insn_i.bubble) exceptions.exceptions.misaligned_store   = dmem_misaligned_i;\\n', '        if (opcR.opcode == OPC_LOAD  && !mem_insn_i.bubble) exceptions.exceptions.load_access_fault  = dmem_err_i;\\n', '        if (opcR.opcode == OPC_STORE && !mem_insn_i.bubble) exceptions.exceptions.store_access_fault = dmem_err_i;\\n', '        if (opcR.opcode == OPC_LOAD  && !mem_insn_i.bubble) exceptions.exceptions.load_page_fault    = dmem_page_fault_i;\\n', '        if (opcR.opcode == OPC_STORE && !mem_insn_i.bubble) exceptions.exceptions.store_page_fault   = dmem_page_fault_i;\\n', '\\n', '        exceptions.any = |exceptions.exceptions | |exceptions.interrupts | exceptions.nmi;\\n', '    end\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni    ) wb_exceptions_o <= 'h0;\\n\", '    else if (!wb_stall_o) wb_exceptions_o <= exceptions;\\n', '\\n', '\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', '    if (!rst_ni)\\n', \"      wb_badaddr_o <= 'h0;\\n\", '    else if (exceptions.exceptions.misaligned_load    ||\\n', '             exceptions.exceptions.misaligned_store   ||\\n', '             exceptions.exceptions.load_access_fault  ||\\n', '             exceptions.exceptions.store_access_fault ||\\n', '             exceptions.exceptions.load_page_fault    ||\\n', '             exceptions.exceptions.store_page_fault   ||\\n', '             exceptions.exceptions.breakpoint         )\\n', '      wb_badaddr_o <= mem_memadr_i;\\n', '    else if (exceptions.exceptions.illegal_instruction)\\n', \"      wb_badaddr_o <= { {XLEN-$bits(mem_insn_i.instr){1'b0}}, mem_insn_i.instr};\\n\", '    else\\n', \"      wb_badaddr_o <= {XLEN{1'b0}}; //mem_pc_i;\\n\", '\\n', '\\n', '  /*\\n', '   * From Memory\\n', '   */\\n', '  always_comb\\n', '    casex ( {mem_insn_i.bubble,mem_exceptions_i.any, wb_exceptions_o.any, opcR.opcode} )\\n', \"      {3'b000,OPC_LOAD }: wb_stall_o = ~(dmem_ack_i | dmem_err_i | dmem_misaligned_i | dmem_page_fault_i);\\n\", \"      {3'b000,OPC_STORE}: wb_stall_o = ~(dmem_ack_i | dmem_err_i | dmem_misaligned_i | dmem_page_fault_i);\\n\", \"      default           : wb_stall_o = 1'b0;\\n\", '    endcase\\n', '\\n', '\\n', '  // data from memory\\n', \"  assign dmem_q = dmem_q_i; //convert (or not) 'xz'\\n\", '\\n', 'generate\\n', '  if (XLEN==64)\\n', '  begin\\n', '      logic [XLEN-1:0] m_qd;\\n', '\\n', '      assign m_qb = dmem_q >> (8* mem_memadr_i[2:0]);\\n', '      assign m_qh = dmem_q >> (8* mem_memadr_i[2:0]);\\n', '      assign m_qw = dmem_q >> (8* mem_memadr_i[2:0]);\\n', '      assign m_qd = dmem_q;\\n', '\\n', '      always_comb\\n', '        casex ( opcR )\\n', '          LB     : wb_memq_o = { {XLEN- 8{m_qb[ 7]}},m_qb};\\n', '          LH     : wb_memq_o = { {XLEN-16{m_qh[15]}},m_qh};\\n', '          LW     : wb_memq_o = { {XLEN-32{m_qw[31]}},m_qw};\\n', '          LD     : wb_memq_o = {                     m_qd};\\n', \"          LBU    : wb_memq_o = { {XLEN- 8{    1'b0}},m_qb};\\n\", \"          LHU    : wb_memq_o = { {XLEN-16{    1'b0}},m_qh};\\n\", \"          LWU    : wb_memq_o = { {XLEN-32{    1'b0}},m_qw};\\n\", \"          default: wb_memq_o = 'hx;\\n\", '        endcase\\n', '  end\\n', '  else\\n', '  begin\\n', '      assign m_qb = dmem_q >> (8* mem_memadr_i[1:0]);\\n', '      assign m_qh = dmem_q >> (8* mem_memadr_i[1:0]);\\n', '      assign m_qw = dmem_q;\\n', '\\n', '      always_comb\\n', '        casex ( opcR )\\n', '          LB     : wb_memq_o = { {XLEN- 8{m_qb[ 7]}},m_qb};\\n', '          LH     : wb_memq_o = { {XLEN-16{m_qh[15]}},m_qh};\\n', '          LW     : wb_memq_o = {                     m_qw};\\n', \"          LBU    : wb_memq_o = { {XLEN- 8{    1'b0}},m_qb};\\n\", \"          LHU    : wb_memq_o = { {XLEN-16{    1'b0}},m_qh};\\n\", \"          default: wb_memq_o = 'hx;\\n\", '        endcase\\n', '  end\\n', 'endgenerate\\n', '\\n', '\\n', '  /*\\n', '   * Register File Write Back\\n', '   */\\n', '  // Destination register\\n', '  always @(posedge clk_i)\\n', '    if (!wb_stall_o) wb_dst_o <= dst;\\n', '\\n', '\\n', '  // Result\\n', '  always @(posedge clk_i)\\n', '    if (!wb_stall_o)\\n', '      casex (opcR.opcode)\\n', '        OPC_LOAD: wb_r_o <= wb_memq_o;\\n', '        default : wb_r_o <= mem_r_i;\\n', '      endcase\\n', '\\n', '\\n', '  // Register File Write\\n', '  always @(posedge clk_i, negedge rst_ni)\\n', \"    if      (!rst_ni   ) wb_we_o <= 'b0;\\n\", \"    else if (exceptions.any || wb_exceptions_o.any) wb_we_o <= 'b0;\\n\", '    else casex (opcR.opcode)\\n', \"      OPC_MISC_MEM: wb_we_o <= 'b0;\\n\", '      OPC_LOAD    : wb_we_o <= ~mem_insn_i.bubble & |dst & ~wb_stall_o;\\n', \"      OPC_STORE   : wb_we_o <= 'b0;\\n\", \"      OPC_STORE_FP: wb_we_o <= 'b0;\\n\", \"      OPC_BRANCH  : wb_we_o <= 'b0;\\n\", \"//      OPC_SYSTEM  : wb_we <= 'b0;\\n\", '      default     : wb_we_o <= ~mem_insn_i.bubble & |dst;\\n', '    endcase\\n', '\\n', 'endmodule\\n', '\\n']"}
