{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n// $Id$\n//\n// Owner:\n// Function: AHB to AXI4 Bridge\n// Comments:\n//\n//********************************************************************************\nmodule ahb_to_axi4\nimport eh2_pkg::*;\n#(\n   TAG = 1,\n   `include \"eh2_param.vh\"\n)\n//   ,TAG  = 1)\n(\n   input                   clk,\n   input                   rst_l,\n   input                   scan_mode,\n   input                   bus_clk_en,\n   input                   clk_override,\n\n   // AXI signals\n   // AXI Write Channels\n   output logic            axi_awvalid,\n   input  logic            axi_awready,\n   output logic [TAG-1:0]  axi_awid,\n   output logic [31:0]     axi_awaddr,\n   output logic [2:0]      axi_awsize,\n   output logic [2:0]      axi_awprot,\n   output logic [7:0]      axi_awlen,\n   output logic [1:0]      axi_awburst,\n\n   output logic            axi_wvalid,\n   input  logic            axi_wready,\n   output logic [63:0]     axi_wdata,\n   output logic [7:0]      axi_wstrb,\n   output logic            axi_wlast,\n\n   input  logic            axi_bvalid,\n   output logic            axi_bready,\n   input  logic [1:0]      axi_bresp,\n   input  logic [TAG-1:0]  axi_bid,\n\n   // AXI Read Channels\n   output logic            axi_arvalid,\n   input  logic            axi_arready,\n   output logic [TAG-1:0]  axi_arid,\n   output logic [31:0]     axi_araddr,\n   output logic [2:0]      axi_arsize,\n   output logic [2:0]      axi_arprot,\n   output logic [7:0]      axi_arlen,\n   output logic [1:0]      axi_arburst,\n\n   input  logic            axi_rvalid,\n   output logic            axi_rready,\n   input  logic [TAG-1:0]  axi_rid,\n   input  logic [63:0]     axi_rdata,\n   input  logic [1:0]      axi_rresp,\n\n   // AHB-Lite signals\n   input logic [31:0]      ahb_haddr,     // ahb bus address\n   input logic [2:0]       ahb_hburst,    // tied to 0\n   input logic             ahb_hmastlock, // tied to 0\n   input logic [3:0]       ahb_hprot,     // tied to 4'b0011\n   input logic [2:0]       ahb_hsize,     // size of bus transaction (possible values 0,1,2,3)\n   input logic [1:0]       ahb_htrans,    // Transaction type (possible values 0,2 only right now)\n   input logic             ahb_hwrite,    // ahb bus write\n   input logic [63:0]      ahb_hwdata,    // ahb bus write data\n   input logic             ahb_hsel,      // this slave was selected\n   input logic             ahb_hreadyin,  // previous hready was accepted or not\n\n   output logic [63:0]      ahb_hrdata,      // ahb bus read data\n   output logic             ahb_hreadyout,   // slave ready to accept transaction\n   output logic             ahb_hresp        // slave response (high indicates erro)\n\n);\n\n   logic [7:0]       master_wstrb;\n\n typedef enum logic [1:0] {   IDLE   = 2'b00,    // Nothing in the buffer. No commands yet recieved\n                              WR     = 2'b01,    // Write Command recieved\n                              RD     = 2'b10,    // Read Command recieved\n                              PEND   = 2'b11     // Waiting on Read Data from core\n                            } state_t;\n   state_t      buf_state, buf_nxtstate;\n   logic        buf_state_en;\n\n   // Buffer signals (one entry buffer)\n   logic                    buf_read_error_in, buf_read_error;\n   logic [63:0]             buf_rdata;\n\n   logic                    ahb_hready;\n   logic                    ahb_hready_q;\n   logic [1:0]              ahb_htrans_in, ahb_htrans_q;\n   logic [2:0]              ahb_hsize_q;\n   logic                    ahb_hwrite_q;\n   logic [31:0]             ahb_haddr_q;\n   logic [63:0]             ahb_hwdata_q;\n   logic                    ahb_hresp_q;\n\n    //Miscellaneous signals\n   logic                    ahb_addr_in_dccm, ahb_addr_in_iccm, ahb_addr_in_pic;\n   logic                    ahb_addr_in_dccm_region_nc, ahb_addr_in_iccm_region_nc, ahb_addr_in_pic_region_nc;\n   // signals needed for the read data coming back from the core and to block any further commands as AHB is a blocking bus\n   logic                    buf_rdata_en;\n\n   logic                    ahb_addr_clk_en, buf_rdata_clk_en;\n   logic                    ahb_clk, ahb_addr_clk, buf_rdata_clk;\n   // Command buffer is the holding station where we convert to AXI and send to core\n   logic                    cmdbuf_wr_en, cmdbuf_rst;\n   logic                    cmdbuf_full;\n   logic                    cmdbuf_vld, cmdbuf_write;\n   logic [1:0]              cmdbuf_size;\n   logic [7:0]              cmdbuf_wstrb;\n   logic [31:0]             cmdbuf_addr;\n   logic [63:0]             cmdbuf_wdata;\n\n   logic                    bus_clk;\n\n// FSM to control the bus states and when to block the hready and load the command buffer\n   always_comb begin\n      buf_nxtstate      = IDLE;\n      buf_state_en      = 1'b0;\n      buf_rdata_en      = 1'b0;              // signal to load the buffer when the core sends read data back\n      buf_read_error_in = 1'b0;              // signal indicating that an error came back with the read from the core\n      cmdbuf_wr_en      = 1'b0;              // all clear from the gasket to load the buffer with the command for reads, command/dat for writes\n      case (buf_state)\n         IDLE: begin  // No commands recieved\n                  buf_nxtstate      = ahb_hwrite ? WR : RD;\n                  buf_state_en      = ahb_hready & ahb_htrans[1] & ahb_hsel;                 // only transition on a valid hrtans\n          end\n         WR: begin // Write command recieved last cycle\n                  buf_nxtstate      = (ahb_hresp | (ahb_htrans[1:0] == 2'b0) | ~ahb_hsel) ? IDLE : ahb_hwrite  ? WR : RD;\n                  buf_state_en      = (~cmdbuf_full | ahb_hresp) ;\n                  cmdbuf_wr_en      = ~cmdbuf_full & ~(ahb_hresp | ((ahb_htrans[1:0] == 2'b01) & ahb_hsel));   // Dont send command to the buffer in case of an error or when the master is not ready with the data now.\n         end\n         RD: begin // Read command recieved last cycle.\n                 buf_nxtstate      = ahb_hresp ? IDLE :PEND;                                       // If error go to idle, else wait for read data\n                 buf_state_en      = (~cmdbuf_full | ahb_hresp);                                   // only when command can go, or if its an error\n                 cmdbuf_wr_en      = ~ahb_hresp & ~cmdbuf_full;                                    // send command only when no error\n         end\n         PEND: begin // Read Command has been sent. Waiting on Data.\n                 buf_nxtstate      = IDLE;                                                          // go back for next command and present data next cycle\n                 buf_state_en      = axi_rvalid & ~cmdbuf_write;                                    // read data is back\n                 buf_rdata_en      = buf_state_en;                                                  // buffer the read data coming back from core\n                 buf_read_error_in = buf_state_en & |axi_rresp[1:0];                                // buffer error flag if return has Error ( ECC )\n         end\n     endcase\n   end // always_comb begin\n\n   rvdffs_fpga #($bits(state_t)) state_reg (.*, .din(buf_nxtstate), .dout({buf_state}), .en(buf_state_en), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk));\n\n   assign master_wstrb[7:0]   = ({8{ahb_hsize_q[2:0] == 3'b0}}  & (8'b1    << ahb_haddr_q[2:0])) |\n                                ({8{ahb_hsize_q[2:0] == 3'b1}}  & (8'b11   << ahb_haddr_q[2:0])) |\n                                ({8{ahb_hsize_q[2:0] == 3'b10}} & (8'b1111 << ahb_haddr_q[2:0])) |\n                                ({8{ahb_hsize_q[2:0] == 3'b11}} & 8'b1111_1111);\n\n   // AHB signals\n   assign ahb_hreadyout       = ahb_hresp ? (ahb_hresp_q & ~ahb_hready_q) :\n                                         ((~cmdbuf_full | (buf_state == IDLE)) & ~(buf_state == RD | buf_state == PEND)  & ~buf_read_error);\n\n   assign ahb_hready          = ahb_hreadyout & ahb_hreadyin;\n   assign ahb_htrans_in[1:0]  = {2{ahb_hsel}} & ahb_htrans[1:0];\n   assign ahb_hrdata[63:0]    = buf_rdata[63:0];\n   assign ahb_hresp        = ((ahb_htrans_q[1:0] != 2'b0) & (buf_state != IDLE)  &\n\n                             ((~(ahb_addr_in_dccm | ahb_addr_in_iccm)) |                                                                                   // request not for ICCM or DCCM\n                             ((ahb_addr_in_iccm | (ahb_addr_in_dccm &  ahb_hwrite_q)) & ~((ahb_hsize_q[1:0] == 2'b10) | (ahb_hsize_q[1:0] == 2'b11))) |    // ICCM Rd/Wr OR DCCM Wr not the right size\n                             ((ahb_hsize_q[2:0] == 3'h1) & ahb_haddr_q[0])   |                                                                             // HW size but unaligned\n                             ((ahb_hsize_q[2:0] == 3'h2) & (|ahb_haddr_q[1:0])) |                                                                          // W size but unaligned\n                             ((ahb_hsize_q[2:0] == 3'h3) & (|ahb_haddr_q[2:0])))) |                                                                        // DW size but unaligned\n                             buf_read_error |                                                                                                              // Read ECC error\n                             (ahb_hresp_q & ~ahb_hready_q);\n\n   // Buffer signals - needed for the read data and ECC error response\n   rvdff_fpga  #(.WIDTH(64)) buf_rdata_ff     (.din(axi_rdata[63:0]),   .dout(buf_rdata[63:0]), .clk(buf_rdata_clk), .clken(buf_rdata_clk_en), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(1))  buf_read_error_ff(.din(buf_read_error_in), .dout(buf_read_error),  .clk(bus_clk),       .clken(bus_clk_en),       .rawclk(clk), .*);          // buf_read_error will be high only one cycle\n\n   // All the Master signals are captured before presenting it to the command buffer. We check for Hresp before sending it to the cmd buffer.\n   rvdff_fpga #(.WIDTH(1))  hresp_ff  (.din(ahb_hresp),          .dout(ahb_hresp_q),       .clk(bus_clk),      .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))  hready_ff (.din(ahb_hready),         .dout(ahb_hready_q),      .clk(bus_clk),      .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(2))  htrans_ff (.din(ahb_htrans_in[1:0]), .dout(ahb_htrans_q[1:0]), .clk(bus_clk),      .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(3))  hsize_ff  (.din(ahb_hsize[2:0]),     .dout(ahb_hsize_q[2:0]),  .clk(ahb_addr_clk), .clken(ahb_addr_clk_en), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))  hwrite_ff (.din(ahb_hwrite),         .dout(ahb_hwrite_q),      .clk(ahb_addr_clk), .clken(ahb_addr_clk_en), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(32)) haddr_ff  (.din(ahb_haddr[31:0]),    .dout(ahb_haddr_q[31:0]), .clk(ahb_addr_clk), .clken(ahb_addr_clk_en), .rawclk(clk), .*);\n\n   // Address check  dccm\n   if (pt.DCCM_ENABLE == 1) begin: GenDCCM\n      rvrangecheck #(.CCM_SADR(pt.DCCM_SADR),\n                     .CCM_SIZE(pt.DCCM_SIZE)) addr_dccm_rangecheck (\n         .addr(ahb_haddr_q[31:0]),\n         .in_range(ahb_addr_in_dccm),\n         .in_region(ahb_addr_in_dccm_region_nc)\n      );\n   end else begin: GenNoDCCM\n      assign ahb_addr_in_dccm = '0;\n      assign ahb_addr_in_dccm_region_nc = '0;\n   end\n\n   // Address check  iccm\n   if (pt.ICCM_ENABLE == 1) begin: GenICCM\n      rvrangecheck #(.CCM_SADR(pt.ICCM_SADR),\n                     .CCM_SIZE(pt.ICCM_SIZE)) addr_iccm_rangecheck (\n         .addr(ahb_haddr_q[31:0]),\n         .in_range(ahb_addr_in_iccm),\n         .in_region(ahb_addr_in_iccm_region_nc)\n      );\n   end else begin: GenNoICCM\n      assign ahb_addr_in_iccm = '0;\n      assign ahb_addr_in_iccm_region_nc = '0;\n   end\n\n   // PIC memory address check\n   rvrangecheck #(.CCM_SADR(pt.PIC_BASE_ADDR),\n                  .CCM_SIZE(pt.PIC_SIZE)) addr_pic_rangecheck (\n      .addr(ahb_haddr_q[31:0]),\n      .in_range(ahb_addr_in_pic),\n      .in_region(ahb_addr_in_pic_region_nc)\n   );\n\n   // Command Buffer - Holding for the commands to be sent for the AXI. It will be converted to the AXI signals.\n   assign cmdbuf_rst         = (((axi_awvalid & axi_awready) | (axi_arvalid & axi_arready)) & ~cmdbuf_wr_en) | (ahb_hresp & ~cmdbuf_write);\n   assign cmdbuf_full        = (cmdbuf_vld & ~((axi_awvalid & axi_awready) | (axi_arvalid & axi_arready)));\n\n   rvdffsc_fpga #(.WIDTH(1))  cmdbuf_vldff      (.din(1'b1),              .dout(cmdbuf_vld),         .en(cmdbuf_wr_en), .clear(cmdbuf_rst), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga  #(.WIDTH(1))  cmdbuf_writeff    (.din(ahb_hwrite_q),      .dout(cmdbuf_write),       .en(cmdbuf_wr_en),                     .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga  #(.WIDTH(2))  cmdbuf_sizeff     (.din(ahb_hsize_q[1:0]),  .dout(cmdbuf_size[1:0]),   .en(cmdbuf_wr_en),                     .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga  #(.WIDTH(8))  cmdbuf_wstrbff    (.din(master_wstrb[7:0]), .dout(cmdbuf_wstrb[7:0]),  .en(cmdbuf_wr_en),                     .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffe       #(.WIDTH(32)) cmdbuf_addrff     (.din(ahb_haddr_q[31:0]), .dout(cmdbuf_addr[31:0]),  .en(cmdbuf_wr_en & bus_clk_en),        .clk(clk), .*);\n   rvdffe       #(.WIDTH(64)) cmdbuf_wdataff    (.din(ahb_hwdata[63:0]),  .dout(cmdbuf_wdata[63:0]), .en(cmdbuf_wr_en & bus_clk_en),        .clk(clk), .*);\n\n   // AXI Write Command Channel\n   assign axi_awvalid           = cmdbuf_vld & cmdbuf_write;\n   assign axi_awid[TAG-1:0]     = '0;\n   assign axi_awaddr[31:0]      = cmdbuf_addr[31:0];\n   assign axi_awsize[2:0]       = {1'b0, cmdbuf_size[1:0]};\n   assign axi_awprot[2:0]       = 3'b0;\n   assign axi_awlen[7:0]        = '0;\n   assign axi_awburst[1:0]      = 2'b01;\n   // AXI Write Data Channel - This is tied to the command channel as we only write the command buffer once we have the data.\n   assign axi_wvalid            = cmdbuf_vld & cmdbuf_write;\n   assign axi_wdata[63:0]       = cmdbuf_wdata[63:0];\n   assign axi_wstrb[7:0]        = cmdbuf_wstrb[7:0];\n   assign axi_wlast             = 1'b1;\n  // AXI Write Response - Always ready. AHB does not require a write response.\n   assign axi_bready            = 1'b1;\n   // AXI Read Channels\n   assign axi_arvalid           = cmdbuf_vld & ~cmdbuf_write;\n   assign axi_arid[TAG-1:0]     = '0;\n   assign axi_araddr[31:0]      = cmdbuf_addr[31:0];\n   assign axi_arsize[2:0]       = {1'b0, cmdbuf_size[1:0]};\n   assign axi_arprot            = 3'b0;\n   assign axi_arlen[7:0]        = '0;\n   assign axi_arburst[1:0]      = 2'b01;\n   // AXI Read Response Channel - Always ready as AHB reads are blocking and the the buffer is available for the read coming back always.\n   assign axi_rready            = 1'b1;\n\n   // Clock header logic\n   assign ahb_addr_clk_en = bus_clk_en & (ahb_hready & ahb_htrans[1]);\n   assign buf_rdata_clk_en    = bus_clk_en & buf_rdata_en;\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign bus_clk = 1'b0;\n   assign ahb_addr_clk = 1'b0;\n   assign buf_rdata_clk = 1'b0;\n`else\n   rvclkhdr bus_cgc       (.en(bus_clk_en),       .l1clk(bus_clk),       .*);\n   rvclkhdr ahb_addr_cgc  (.en(ahb_addr_clk_en),  .l1clk(ahb_addr_clk),  .*);\n   rvclkhdr buf_rdata_cgc (.en(buf_rdata_clk_en), .l1clk(buf_rdata_clk), .*);\n`endif\n\n`ifdef RV_ASSERT_ON\n   property ahb_error_protocol;\n      @(posedge bus_clk) (ahb_hready & ahb_hresp) |-> (~$past(ahb_hready) & $past(ahb_hresp));\n   endproperty\n   assert_ahb_error_protocol: assert property (ahb_error_protocol) else\n      $display(\"Bus Error with hReady isn't preceded with Bus Error without hready\");\n\n`endif\n\nendmodule // ahb_to_axi4"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n// Owner:\n// Function: AXI4 -> AHB Bridge\n// Comments:\n//\n//********************************************************************************\nmodule axi4_to_ahb\nimport eh2_pkg::*;\n#(parameter TAG  = 1,\n            NUM_THREADS = 1) (\n\n   input                   clk,\n   input                   free_clk,\n   input                   rst_l,\n   input                   scan_mode,\n   input                   bus_clk_en,\n   input                   clk_override,\n   input [NUM_THREADS-1:0] dec_tlu_force_halt,\n\n   // AXI signals\n   // AXI Write Channels\n   input  logic            axi_awvalid,\n   output logic            axi_awready,\n   input  logic [TAG-1:0]  axi_awid,\n   input  logic [31:0]     axi_awaddr,\n   input  logic [2:0]      axi_awsize,\n   input  logic [2:0]      axi_awprot,\n\n   input  logic            axi_wvalid,\n   output logic            axi_wready,\n   input  logic [63:0]     axi_wdata,\n   input  logic [7:0]      axi_wstrb,\n   input  logic            axi_wlast,\n\n   output logic            axi_bvalid,\n   input  logic            axi_bready,\n   output logic [1:0]      axi_bresp,\n   output logic [TAG-1:0]  axi_bid,\n\n   // AXI Read Channels\n   input  logic            axi_arvalid,\n   output logic            axi_arready,\n   input  logic [TAG-1:0]  axi_arid,\n   input  logic [31:0]     axi_araddr,\n   input  logic [2:0]      axi_arsize,\n   input  logic [2:0]      axi_arprot,\n\n   output logic            axi_rvalid,\n   input  logic            axi_rready,\n   output logic [TAG-1:0]  axi_rid,\n   output logic [63:0]     axi_rdata,\n   output logic [1:0]      axi_rresp,\n   output logic            axi_rlast,\n\n   // AHB-Lite signals\n   output logic [31:0]     ahb_haddr,       // ahb bus address\n   output logic [2:0]      ahb_hburst,      // tied to 0\n   output logic            ahb_hmastlock,   // tied to 0\n   output logic [3:0]      ahb_hprot,       // tied to 4'b0011\n   output logic [2:0]      ahb_hsize,       // size of bus transaction (possible values 0,1,2,3)\n   output logic [1:0]      ahb_htrans,      // Transaction type (possible values 0,2 only right now)\n   output logic            ahb_hwrite,      // ahb bus write\n   output logic [63:0]     ahb_hwdata,      // ahb bus write data\n\n   input logic [63:0]      ahb_hrdata,      // ahb bus read data\n   input logic             ahb_hready,      // slave ready to accept transaction\n   input logic             ahb_hresp        // slave response (high indicates erro)\n\n);\n\n   localparam ID   = 1;\n   localparam PRTY = 1;\n   typedef enum logic [2:0] {IDLE=3'b000, CMD_RD=3'b001, CMD_WR=3'b010, DATA_RD=3'b011, DATA_WR=3'b100, DONE=3'b101, STREAM_RD=3'b110, STREAM_ERR_RD=3'b111} state_t;\n   state_t buf_state, buf_nxtstate;\n\n   logic             slave_valid;\n   logic             slave_ready;\n   logic [TAG-1:0]   slave_tag;\n   logic [63:0]      slave_rdata;\n   logic [3:0]       slave_opc;\n\n   logic             wrbuf_en, wrbuf_data_en;\n   logic             wrbuf_cmd_sent, wrbuf_rst;\n   logic             wrbuf_vld;\n   logic             wrbuf_data_vld;\n   logic [TAG-1:0]   wrbuf_tag;\n   logic [2:0]       wrbuf_size;\n   logic [31:0]      wrbuf_addr;\n   logic [63:0]      wrbuf_data;\n   logic [7:0]       wrbuf_byteen;\n\n   logic             bus_write_clk_en;\n   logic             bus_clk, bus_write_clk;\n\n   logic             master_valid;\n   logic             master_ready;\n   logic [TAG-1:0]   master_tag;\n   logic [31:0]      master_addr;\n   logic [63:0]      master_wdata;\n   logic [2:0]       master_size;\n   logic [2:0]       master_opc;\n   logic [7:0]       master_byteen;\n\n   // Buffer signals (one entry buffer)\n   logic [31:0]                buf_addr;\n   logic [1:0]                 buf_size;\n   logic                       buf_write;\n   logic [7:0]                 buf_byteen;\n   logic                       buf_aligned;\n   logic [63:0]                buf_data;\n   logic [TAG-1:0]             buf_tag;\n\n   //Miscellaneous signals\n   logic                       buf_rst;\n   logic [TAG-1:0]             buf_tag_in;\n   logic [31:0]                buf_addr_in;\n   logic [7:0]                 buf_byteen_in;\n   logic [63:0]                buf_data_in;\n   logic                       buf_write_in;\n   logic                       buf_aligned_in;\n   logic [2:0]                 buf_size_in;\n\n   logic                       buf_state_en;\n   logic                       buf_wr_en;\n   logic                       buf_data_wr_en;\n   logic                       slvbuf_error_en;\n   logic                       wr_cmd_vld;\n\n   logic                       cmd_done_rst, cmd_done, cmd_doneQ;\n   logic                       trxn_done;\n   logic [2:0]                 buf_cmd_byte_ptr, buf_cmd_byte_ptrQ, buf_cmd_nxtbyte_ptr;\n   logic                       buf_cmd_byte_ptr_en;\n   logic                       found;\n\n   logic                       slave_valid_pre;\n   logic                       ahb_hready_q;\n   logic                       ahb_hresp_q;\n   logic [1:0]                 ahb_htrans_q;\n   logic                       ahb_hwrite_q;\n   logic [63:0]                ahb_hrdata_q;\n\n\n   logic                       slvbuf_write;\n   logic                       slvbuf_error;\n   logic [TAG-1:0]             slvbuf_tag;\n\n   logic                       slvbuf_error_in;\n   logic                       slvbuf_wr_en;\n   logic                       bypass_en;\n   logic                       rd_bypass_idle;\n\n   logic                       last_addr_en;\n   logic [31:0]                last_bus_addr;\n\n   // Clocks\n   logic                       buf_clken, slvbuf_clken;\n   logic                       ahbm_data_clken;\n\n   logic                       buf_clk, slvbuf_clk;\n   logic                       ahbm_clk;\n   logic                       ahbm_data_clk;\n\n   logic [NUM_THREADS-1:0]     dec_tlu_force_halt_bus, dec_tlu_force_halt_bus_ns, dec_tlu_force_halt_bus_q;\n\n   // Function to get the length from byte enable\n   function automatic logic [1:0] get_write_size;\n      input logic [7:0] byteen;\n\n      logic [1:0]       size;\n\n      size[1:0] = (2'b11 & {2{(byteen[7:0] == 8'hff)}}) |\n                  (2'b10 & {2{((byteen[7:0] == 8'hf0) | (byteen[7:0] == 8'h0f))}}) |\n                  (2'b01 & {2{((byteen[7:0] == 8'hc0) | (byteen[7:0] == 8'h30) | (byteen[7:0] == 8'h0c) | (byteen[7:0] == 8'h03))}});\n\n      return size[1:0];\n   endfunction // get_write_size\n\n   // Function to get the length from byte enable\n   function automatic logic [2:0] get_write_addr;\n      input logic [7:0] byteen;\n\n      logic [2:0]       addr;\n\n      addr[2:0] = (3'h0 & {3{((byteen[7:0] == 8'hff) | (byteen[7:0] == 8'h0f) | (byteen[7:0] == 8'h03))}}) |\n                  (3'h2 & {3{(byteen[7:0] == 8'h0c)}})                                                     |\n                  (3'h4 & {3{((byteen[7:0] == 8'hf0) | (byteen[7:0] == 8'h03))}})                          |\n                  (3'h6 & {3{(byteen[7:0] == 8'hc0)}});\n\n      return addr[2:0];\n   endfunction // get_write_addr\n\n   // Function to get the next byte pointer\n   function automatic logic [2:0] get_nxtbyte_ptr (logic [2:0] current_byte_ptr, logic [7:0] byteen, logic get_next);\n      logic [2:0] start_ptr;\n      logic       found;\n      found = '0;\n      //get_nxtbyte_ptr[2:0] = current_byte_ptr[2:0];\n      start_ptr[2:0] = get_next ? (current_byte_ptr[2:0] + 3'b1) : current_byte_ptr[2:0];\n      for (int j=0; j<8; j++) begin\n         if (~found) begin\n            get_nxtbyte_ptr[2:0] = 3'(j);\n            found |= (byteen[j] & (3'(j) >= start_ptr[2:0])) ;\n         end\n      end\n   endfunction // get_nextbyte_ptr\n\n   for (genvar i=0; i<NUM_THREADS; i++) begin\n   // Create bus synchronized version of force halt\n      assign dec_tlu_force_halt_bus[i] = dec_tlu_force_halt[i] | dec_tlu_force_halt_bus_q[i];\n      assign dec_tlu_force_halt_bus_ns[i] = ~bus_clk_en & dec_tlu_force_halt_bus[i];\n      rvdff  #(.WIDTH(1)) force_halt_busff(.din(dec_tlu_force_halt_bus_ns[i]), .dout(dec_tlu_force_halt_bus_q[i]), .clk(free_clk), .*);\n   end\n\n   // Write buffer\n   assign wrbuf_en       = axi_awvalid & axi_awready & master_ready;\n   assign wrbuf_data_en  = axi_wvalid & axi_wready & master_ready;\n   assign wrbuf_cmd_sent = master_valid & master_ready & (master_opc[2:1] == 2'b01);\n   assign wrbuf_rst      = (wrbuf_cmd_sent & ~wrbuf_en) | dec_tlu_force_halt_bus[wrbuf_tag[TAG-1]];\n\n   assign axi_awready = ~(wrbuf_vld & ~wrbuf_cmd_sent) & master_ready;\n   assign axi_wready  = ~(wrbuf_data_vld & ~wrbuf_cmd_sent) & master_ready;\n   assign axi_arready = ~(wrbuf_vld & wrbuf_data_vld) & master_ready;\n   assign axi_rlast   = 1'b1;\n\n   assign wr_cmd_vld          = (wrbuf_vld & wrbuf_data_vld);\n   assign master_valid        = wr_cmd_vld | axi_arvalid;\n   assign master_tag[TAG-1:0] = wr_cmd_vld ? wrbuf_tag[TAG-1:0] : axi_arid[TAG-1:0];\n   assign master_opc[2:0]     = wr_cmd_vld ? 3'b011 : 3'b0;\n   assign master_addr[31:0]   = wr_cmd_vld ? wrbuf_addr[31:0] : axi_araddr[31:0];\n   assign master_size[2:0]    = wr_cmd_vld ? wrbuf_size[2:0] : axi_arsize[2:0];\n   assign master_byteen[7:0]  = wrbuf_byteen[7:0];\n   assign master_wdata[63:0]  = wrbuf_data[63:0];\n\n   // AXI response channel signals\n   assign axi_bvalid       = slave_valid & slave_ready & slave_opc[3];\n   assign axi_bresp[1:0]   = slave_opc[0] ? 2'b10 : (slave_opc[1] ? 2'b11 : 2'b0);\n   assign axi_bid[TAG-1:0] = slave_tag[TAG-1:0];\n\n   assign axi_rvalid       = slave_valid & slave_ready & (slave_opc[3:2] == 2'b0);\n   assign axi_rresp[1:0]   = slave_opc[0] ? 2'b10 : (slave_opc[1] ? 2'b11 : 2'b0);\n   assign axi_rid[TAG-1:0] = slave_tag[TAG-1:0];\n   assign axi_rdata[63:0]  = slave_rdata[63:0];\n   assign slave_ready        = axi_bready & axi_rready;\n\n // FIFO state machine\n   always_comb begin\n      buf_nxtstate   = IDLE;\n      buf_state_en   = 1'b0;\n      buf_wr_en      = 1'b0;\n      buf_data_wr_en = 1'b0;\n      slvbuf_error_in   = 1'b0;\n      slvbuf_error_en   = 1'b0;\n      buf_write_in   = 1'b0;\n      cmd_done       = 1'b0;\n      trxn_done      = 1'b0;\n      buf_cmd_byte_ptr_en = 1'b0;\n      buf_cmd_byte_ptr[2:0] = '0;\n      slave_valid_pre   = 1'b0;\n      master_ready   = 1'b0;\n      ahb_htrans[1:0]  = 2'b0;\n      slvbuf_wr_en     = 1'b0;\n      bypass_en        = 1'b0;\n      rd_bypass_idle   = 1'b0;\n\n      case (buf_state)\n         IDLE: begin\n                  master_ready   = 1'b1;\n                  buf_write_in = (master_opc[2:1] == 2'b01);\n                  buf_nxtstate = buf_write_in ? CMD_WR : CMD_RD;\n                  buf_state_en = master_valid & master_ready;\n                  buf_wr_en    = buf_state_en;\n                  buf_data_wr_en = buf_state_en & (buf_nxtstate == CMD_WR);\n                  buf_cmd_byte_ptr_en   = buf_state_en;\n                  buf_cmd_byte_ptr[2:0] = buf_write_in ? get_nxtbyte_ptr(3'b0,buf_byteen_in[7:0],1'b0) : master_addr[2:0];\n                  bypass_en       = buf_state_en;\n                  rd_bypass_idle  = bypass_en & (buf_nxtstate == CMD_RD);\n                  ahb_htrans[1:0] = {2{bypass_en}} & 2'b10;\n          end\n         CMD_RD: begin\n                  buf_nxtstate    = (master_valid & (master_opc[2:0] == 3'b000))? STREAM_RD : DATA_RD;\n                  buf_state_en    = ahb_hready_q & (ahb_htrans_q[1:0] != 2'b0) & ~ahb_hwrite_q;\n                  cmd_done        = buf_state_en & ~master_valid;\n                  slvbuf_wr_en    = buf_state_en;\n                  master_ready  = buf_state_en & (buf_nxtstate == STREAM_RD);\n                  buf_wr_en       = master_ready;\n                  bypass_en       = master_ready & master_valid;\n                  buf_cmd_byte_ptr[2:0] = bypass_en ? master_addr[2:0] : buf_addr[2:0];\n                  ahb_htrans[1:0] = 2'b10 & {2{~buf_state_en | bypass_en}};\n         end\n         STREAM_RD: begin\n                  master_ready  =  (ahb_hready_q & ~ahb_hresp_q) & ~(master_valid & master_opc[2:1] == 2'b01);\n                  buf_wr_en       = (master_valid & master_ready & (master_opc[2:0] == 3'b000)); // update the fifo if we are streaming the read commands\n                  buf_nxtstate    = ahb_hresp_q ? STREAM_ERR_RD : (buf_wr_en ? STREAM_RD : DATA_RD);            // assuming that the master accpets the slave response right away.\n                  buf_state_en    = (ahb_hready_q | ahb_hresp_q);\n                  buf_data_wr_en  = buf_state_en;\n                  slvbuf_error_in = ahb_hresp_q;\n                  slvbuf_error_en = buf_state_en;\n                  slave_valid_pre  = buf_state_en & ~ahb_hresp_q;             // send a response right away if we are not going through an error response.\n                  cmd_done        = buf_state_en & ~master_valid;                     // last one of the stream should not send a htrans\n                  bypass_en       = master_ready & master_valid & (buf_nxtstate == STREAM_RD) & buf_state_en;\n                  buf_cmd_byte_ptr[2:0] = bypass_en ? master_addr[2:0] : buf_addr[2:0];\n                  ahb_htrans[1:0] = 2'b10 & {2{~((buf_nxtstate != STREAM_RD) & buf_state_en)}};\n                  slvbuf_wr_en    = buf_wr_en;                                         // shifting the contents from the buf to slv_buf for streaming cases\n         end // case: STREAM_RD\n         STREAM_ERR_RD: begin\n                  buf_nxtstate = DATA_RD;\n                  buf_state_en = ahb_hready_q & (ahb_htrans_q[1:0] != 2'b0) & ~ahb_hwrite_q;\n                  slave_valid_pre = buf_state_en;\n                  slvbuf_wr_en   = buf_state_en;     // Overwrite slvbuf with buffer\n                  buf_cmd_byte_ptr[2:0] = buf_addr[2:0];\n                  ahb_htrans[1:0] = 2'b10 & {2{~buf_state_en}};\n         end\n         DATA_RD: begin\n                  buf_nxtstate   = DONE;\n                  buf_state_en   = (ahb_hready_q | ahb_hresp_q);\n                  buf_data_wr_en = buf_state_en;\n                  slvbuf_error_in= ahb_hresp_q;\n                  slvbuf_error_en= buf_state_en;\n                  slvbuf_wr_en   = buf_state_en;\n\n         end\n         CMD_WR: begin\n                  buf_nxtstate = DATA_WR;\n                  trxn_done    = ahb_hready_q & ahb_hwrite_q & (ahb_htrans_q[1:0] != 2'b0);\n                  buf_state_en = trxn_done;\n                  buf_cmd_byte_ptr_en = buf_state_en;\n                  slvbuf_wr_en    = buf_state_en;\n                  buf_cmd_byte_ptr    = trxn_done ? get_nxtbyte_ptr(buf_cmd_byte_ptrQ[2:0],buf_byteen[7:0],1'b1) : buf_cmd_byte_ptrQ;\n                  cmd_done            = trxn_done & (buf_aligned | (buf_cmd_byte_ptrQ == 3'b111) |\n                                                     (buf_byteen[get_nxtbyte_ptr(buf_cmd_byte_ptrQ[2:0],buf_byteen[7:0],1'b1)] == 1'b0));\n                  ahb_htrans[1:0] = {2{~(cmd_done | cmd_doneQ)}} & 2'b10;\n         end\n         DATA_WR: begin\n                  buf_state_en = (cmd_doneQ & ahb_hready_q) | ahb_hresp_q;\n                  master_ready = buf_state_en & ~ahb_hresp_q & slave_ready;   // Ready to accept new command if current command done and no error\n                  buf_nxtstate = (ahb_hresp_q | ~slave_ready) ? DONE :\n                                  ((master_valid & master_ready) ? ((master_opc[2:1] == 2'b01) ? CMD_WR : CMD_RD) : IDLE);\n                  slvbuf_error_in = ahb_hresp_q;\n                  slvbuf_error_en = buf_state_en;\n\n                  buf_write_in = (master_opc[2:1] == 2'b01);\n                  buf_wr_en = buf_state_en & ((buf_nxtstate == CMD_WR) | (buf_nxtstate == CMD_RD));\n                  buf_data_wr_en = buf_wr_en;\n\n                  cmd_done     = (ahb_hresp_q | (ahb_hready_q & (ahb_htrans_q[1:0] != 2'b0) &\n                                 ((buf_cmd_byte_ptrQ == 3'b111) | (buf_byteen[get_nxtbyte_ptr(buf_cmd_byte_ptrQ[2:0],buf_byteen[7:0],1'b1)] == 1'b0))));\n                  bypass_en       = buf_state_en & buf_write_in & (buf_nxtstate == CMD_WR);   // Only bypass for writes for the time being\n                  ahb_htrans[1:0] = {2{(~(cmd_done | cmd_doneQ) | bypass_en)}} & 2'b10;\n                  slave_valid_pre  = buf_state_en & (buf_nxtstate != DONE);\n\n                  trxn_done = ahb_hready_q & ahb_hwrite_q & (ahb_htrans_q[1:0] != 2'b0);\n                  buf_cmd_byte_ptr_en = trxn_done | bypass_en;\n                  buf_cmd_byte_ptr = bypass_en ? get_nxtbyte_ptr(3'b0,buf_byteen_in[7:0],1'b0) :\n                                                 trxn_done ? get_nxtbyte_ptr(buf_cmd_byte_ptrQ[2:0],buf_byteen[7:0],1'b1) : buf_cmd_byte_ptrQ;\n            end\n         DONE: begin\n                  buf_nxtstate = IDLE;\n                  buf_state_en = slave_ready;\n                  slvbuf_error_en = 1'b1;\n                  slave_valid_pre = 1'b1;\n         end\n      endcase\n   end\n\n   assign buf_rst              = dec_tlu_force_halt_bus[buf_tag[TAG-1]];\n   assign cmd_done_rst         = slave_valid_pre;\n   assign buf_addr_in[31:3]    = master_addr[31:3];\n   assign buf_addr_in[2:0]     = (buf_aligned_in & (master_opc[2:1] == 2'b01)) ? get_write_addr(master_byteen[7:0]) : master_addr[2:0];\n   assign buf_tag_in[TAG-1:0]  = master_tag[TAG-1:0];\n   assign buf_byteen_in[7:0]   = wrbuf_byteen[7:0];\n   assign buf_data_in[63:0]    = (buf_state == DATA_RD) ? ahb_hrdata_q[63:0] : master_wdata[63:0];\n   assign buf_size_in[1:0]     = (buf_aligned_in & (master_size[1:0] == 2'b11) & (master_opc[2:1] == 2'b01)) ? get_write_size(master_byteen[7:0]) : master_size[1:0];\n   assign buf_aligned_in       = (master_opc[2:0] == 3'b0)    |   // reads are always aligned since they are either DW or sideeffects\n                                 (master_size[1:0] == 2'b0) |  (master_size[1:0] == 2'b01) | (master_size[1:0] == 2'b10) | // Always aligned for Byte/HW/Word since they can be only for non-idempotent. IFU/SB are always aligned\n                                 ((master_size[1:0] == 2'b11) &\n                                  ((master_byteen[7:0] == 8'h3)  | (master_byteen[7:0] == 8'hc)   | (master_byteen[7:0] == 8'h30) | (master_byteen[7:0] == 8'hc0) |\n                                   (master_byteen[7:0] == 8'hf)  | (master_byteen[7:0] == 8'hf0)  | (master_byteen[7:0] == 8'hff)));\n\n   // Generate the ahb signals\n   assign ahb_haddr[31:0] = bypass_en ? {master_addr[31:3],buf_cmd_byte_ptr[2:0]}  : {buf_addr[31:3],buf_cmd_byte_ptr[2:0]};\n   assign ahb_hsize[2:0]  = {3{ahb_htrans[1]}} & (bypass_en ? {1'b0, ({2{buf_aligned_in}} & buf_size_in[1:0])} :\n                                        {1'b0, ({2{buf_aligned}} & buf_size[1:0])});   // Send the full size for aligned trxn\n   assign ahb_hburst[2:0] = 3'b0;\n   assign ahb_hmastlock   = 1'b0;\n   assign ahb_hprot[3:0]  = {3'b001,~axi_arprot[2]};\n   assign ahb_hwrite      = bypass_en ? (master_opc[2:1] == 2'b01) : buf_write;\n   assign ahb_hwdata[63:0] = buf_data[63:0];\n\n   assign slave_valid          = slave_valid_pre;// & (~slvbuf_posted_write | slvbuf_error);\n   assign slave_opc[3:2]       = slvbuf_write ? 2'b11 : 2'b00;\n   assign slave_opc[1:0]       = {2{slvbuf_error}} & 2'b10;\n   assign slave_rdata[63:0]    = slvbuf_error ? {2{last_bus_addr[31:0]}} : ((buf_state == DONE) ? buf_data[63:0] : ahb_hrdata_q[63:0]);\n   assign slave_tag[TAG-1:0]   = slvbuf_tag[TAG-1:0];\n\n   assign last_addr_en = (ahb_htrans[1:0] != 2'b0) & ahb_hready & ahb_hwrite ;\n\n\n   rvdffsc_fpga #(.WIDTH(1))   wrbuf_vldff     (.din(1'b1),              .dout(wrbuf_vld),          .en(wr"}
{"text": "buf_en),      .clear(wrbuf_rst), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffsc_fpga #(.WIDTH(1))   wrbuf_data_vldff(.din(1'b1),              .dout(wrbuf_data_vld),     .en(wrbuf_data_en), .clear(wrbuf_rst), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga  #(.WIDTH(TAG)) wrbuf_tagff     (.din(axi_awid[TAG-1:0]), .dout(wrbuf_tag[TAG-1:0]), .en(wrbuf_en),                         .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga  #(.WIDTH(3))   wrbuf_sizeff    (.din(axi_awsize[2:0]),   .dout(wrbuf_size[2:0]),    .en(wrbuf_en),                         .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffe       #(.WIDTH(32))  wrbuf_addrff    (.din(axi_awaddr[31:0]),  .dout(wrbuf_addr[31:0]),   .en(wrbuf_en & bus_clk_en),            .clk(clk), .*);\n   rvdffe       #(.WIDTH(64))  wrbuf_dataff    (.din(axi_wdata[63:0]),   .dout(wrbuf_data[63:0]),   .en(wrbuf_data_en & bus_clk_en),       .clk(clk), .*);\n   rvdffs_fpga  #(.WIDTH(8))   wrbuf_byteenff  (.din(axi_wstrb[7:0]),    .dout(wrbuf_byteen[7:0]),  .en(wrbuf_data_en),                    .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n\n   rvdffs_fpga #(.WIDTH(32))   last_bus_addrff (.din(ahb_haddr[31:0]),   .dout(last_bus_addr[31:0]), .en(last_addr_en), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n\n   rvdffsc_fpga #(.WIDTH($bits(state_t))) buf_state_ff  (.din(buf_nxtstate),        .dout({buf_state}),      .en(buf_state_en), .clear(buf_rst), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(1))               buf_writeff   (.din(buf_write_in),        .dout(buf_write),        .en(buf_wr_en),                     .clk(buf_clk), .clken(buf_clken),  .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(TAG))             buf_tagff     (.din(buf_tag_in[TAG-1:0]), .dout(buf_tag[TAG-1:0]), .en(buf_wr_en),                     .clk(buf_clk), .clken(buf_clken),  .rawclk(clk), .*);\n   rvdffe      #(.WIDTH(32))              buf_addrff    (.din(buf_addr_in[31:0]),   .dout(buf_addr[31:0]),   .en(buf_wr_en & bus_clk_en),        .clk(clk), .*);\n   rvdffs_fpga #(.WIDTH(2))               buf_sizeff    (.din(buf_size_in[1:0]),    .dout(buf_size[1:0]),    .en(buf_wr_en),                     .clk(buf_clk), .clken(buf_clken),  .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(1))               buf_alignedff (.din(buf_aligned_in),      .dout(buf_aligned),      .en(buf_wr_en),                     .clk(buf_clk), .clken(buf_clken),  .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(8))               buf_byteenff  (.din(buf_byteen_in[7:0]),  .dout(buf_byteen[7:0]),  .en(buf_wr_en),                     .clk(buf_clk), .clken(buf_clken),  .rawclk(clk), .*);\n   rvdffe      #(.WIDTH(64))              buf_dataff    (.din(buf_data_in[63:0]),   .dout(buf_data[63:0]),   .en(buf_data_wr_en & bus_clk_en),   .clk(clk), .*);\n\n\n   rvdffs_fpga #(.WIDTH(1))   slvbuf_writeff  (.din(buf_write),        .dout(slvbuf_write),        .en(slvbuf_wr_en),    .clk(buf_clk), .clken(buf_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(TAG)) slvbuf_tagff    (.din(buf_tag[TAG-1:0]), .dout(slvbuf_tag[TAG-1:0]), .en(slvbuf_wr_en),    .clk(buf_clk), .clken(buf_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(1))   slvbuf_errorff  (.din(slvbuf_error_in),  .dout(slvbuf_error),        .en(slvbuf_error_en), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n\n   rvdffsc_fpga #(.WIDTH(1)) buf_cmd_doneff     (.din(1'b1),                  .dout(cmd_doneQ),              .en(cmd_done),            .clear(cmd_done_rst), .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(3))  buf_cmd_byte_ptrff (.din(buf_cmd_byte_ptr[2:0]), .dout(buf_cmd_byte_ptrQ[2:0]), .en(buf_cmd_byte_ptr_en),                       .clk(bus_clk), .clken(bus_clk_en), .rawclk(clk), .*);\n\n   rvdff_fpga #(.WIDTH(1))  hready_ff (.din(ahb_hready),       .dout(ahb_hready_q),       .clk(bus_clk),       .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(2))  htrans_ff (.din(ahb_htrans[1:0]),  .dout(ahb_htrans_q[1:0]),  .clk(bus_clk),       .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))  hwrite_ff (.din(ahb_hwrite),       .dout(ahb_hwrite_q),       .clk(bus_clk),       .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))  hresp_ff  (.din(ahb_hresp),        .dout(ahb_hresp_q),        .clk(bus_clk),       .clken(bus_clk_en),      .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(64)) hrdata_ff (.din(ahb_hrdata[63:0]), .dout(ahb_hrdata_q[63:0]), .clk(ahbm_data_clk), .clken(ahbm_data_clken), .rawclk(clk), .*);\n\n   // Clock headers\n   // clock enables for ahbm addr/data\n   assign buf_clken       = bus_clk_en & (buf_wr_en | slvbuf_wr_en | clk_override);\n   assign ahbm_data_clken = bus_clk_en & ((buf_state != IDLE) | clk_override);\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign bus_clk = 1'b0;\n   assign buf_clk = 1'b0;\n   assign ahbm_data_clk = 1'b0;\n`else\n   rvclkhdr bus_cgc       (.en(bus_clk_en),      .l1clk(bus_clk),       .*);\n   rvclkhdr buf_cgc       (.en(buf_clken),       .l1clk(buf_clk), .*);\n   rvclkhdr ahbm_data_cgc (.en(ahbm_data_clken), .l1clk(ahbm_data_clk), .*);\n`endif\n\n`ifdef RV_ASSERT_ON\n   property ahb_trxn_aligned;\n     @(posedge ahbm_clk) ahb_htrans[1]  |-> ((ahb_hsize[2:0] == 3'h0)                              |\n                                        ((ahb_hsize[2:0] == 3'h1) & (ahb_haddr[0] == 1'b0))   |\n                                        ((ahb_hsize[2:0] == 3'h2) & (ahb_haddr[1:0] == 2'b0)) |\n                                        ((ahb_hsize[2:0] == 3'h3) & (ahb_haddr[2:0] == 3'b0)));\n   endproperty\n   assert_ahb_trxn_aligned: assert property (ahb_trxn_aligned) else\n     $display(\"Assertion ahb_trxn_aligned failed: ahb_htrans=2'h%h, ahb_hsize=3'h%h, ahb_haddr=32'h%h\",ahb_htrans[1:0], ahb_hsize[2:0], ahb_haddr[31:0]);\n\n   property ahb_error_protocol;\n      @(posedge ahbm_clk) (ahb_hready & ahb_hresp) |-> (~$past(ahb_hready) & $past(ahb_hresp));\n   endproperty\n   assert_ahb_error_protocol: assert property (ahb_error_protocol) else\n      $display(\"Bus Error with hReady isn't preceded with Bus Error without hready\");\n`endif\n\nendmodule // axi4_to_ahb\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// all flops call the rvdff flop\n\n\nmodule rvdff #( parameter WIDTH=1 )\n   (\n     input logic [WIDTH-1:0] din,\n     input logic           clk,\n     input logic                   rst_l,\n\n     output logic [WIDTH-1:0] dout\n     );\n\n`ifdef RV_CLOCKGATE\n   always @(posedge tb_top.clk) begin\n      #0 $strobe(\"CG: %0t %m din %x dout %x clk %b width %d\",$time,din,dout,clk,WIDTH);\n   end\n`endif\n\n   always_ff @(posedge clk or negedge rst_l) begin\n      if (rst_l == 0)\n        dout[WIDTH-1:0] <= 0;\n      else\n        dout[WIDTH-1:0] <= din[WIDTH-1:0];\n   end\n\n\nendmodule\n\n// rvdff with 2:1 input mux to flop din iff sel==1\nmodule rvdffs #( parameter WIDTH=1 )\n   (\n     input logic [WIDTH-1:0] din,\n     input logic             en,\n     input logic           clk,\n     input logic                   rst_l,\n     output logic [WIDTH-1:0] dout\n     );\n\n   rvdff #(WIDTH) dffs (.din((en) ? din[WIDTH-1:0] : dout[WIDTH-1:0]), .*);\n\nendmodule\n\n// rvdff with en and clear\nmodule rvdffsc #( parameter WIDTH=1 )\n   (\n     input logic [WIDTH-1:0] din,\n     input logic             en,\n     input logic             clear,\n     input logic           clk,\n     input logic                   rst_l,\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic [WIDTH-1:0]          din_new;\n   assign din_new = {WIDTH{~clear}} & (en ? din[WIDTH-1:0] : dout[WIDTH-1:0]);\n   rvdff #(WIDTH) dffsc (.din(din_new[WIDTH-1:0]), .*);\n\nendmodule\n\n// _fpga versions\nmodule rvdff_fpga #( parameter WIDTH=1 )\n   (\n     input logic [WIDTH-1:0] din,\n     input logic           clk,\n     input logic           clken,\n     input logic           rawclk,\n     input logic           rst_l,\n\n     output logic [WIDTH-1:0] dout\n     );\n\n`ifdef RV_FPGA_OPTIMIZE\n   rvdffs #(WIDTH) dffs (.clk(rawclk), .en(clken), .*);\n`else\n   rvdff #(WIDTH)  dff (.*);\n`endif\n\nendmodule\n\n// rvdff with 2:1 input mux to flop din iff sel==1\nmodule rvdffs_fpga #( parameter WIDTH=1 )\n   (\n     input logic [WIDTH-1:0] din,\n     input logic             en,\n     input logic           clk,\n     input logic           clken,\n     input logic           rawclk,\n     input logic           rst_l,\n\n     output logic [WIDTH-1:0] dout\n     );\n\n`ifdef RV_FPGA_OPTIMIZE\n   rvdffs #(WIDTH)   dffs (.clk(rawclk), .en(clken & en), .*);\n`else\n   rvdffs #(WIDTH)   dffs (.*);\n`endif\n\nendmodule\n\n// rvdff with en and clear\nmodule rvdffsc_fpga #( parameter WIDTH=1 )\n   (\n     input logic [WIDTH-1:0] din,\n     input logic             en,\n     input logic             clear,\n     input logic             clk,\n     input logic             clken,\n     input logic             rawclk,\n     input logic             rst_l,\n\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic [WIDTH-1:0]          din_new;\n\n`ifdef RV_FPGA_OPTIMIZE\n   rvdffs  #(WIDTH)   dffs  (.clk(rawclk), .din(din[WIDTH-1:0] & {WIDTH{~clear}}),.en((en | clear) & clken), .*);\n`else\n   rvdffsc #(WIDTH)   dffsc (.*);\n`endif\n\nendmodule\n\n\nmodule rvdff4iee #( parameter WIDTH=64 )\n   (\n     input  logic [WIDTH-1:0] din,\n     input  logic       en,\n     input  logic           clk,\n     input  logic           rst_l,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   localparam LEFTMOST = int'(WIDTH/4);\n   localparam LEFT     = LEFTMOST;\n   localparam RIGHT    = LEFTMOST;\n   localparam RIGHTMOST = WIDTH - LEFTMOST - LEFT - RIGHT;\n\n   localparam LMMSB = WIDTH-1;\n   localparam LMLSB = LMMSB-LEFTMOST+1;\n   localparam LMSB = LMLSB-1;\n   localparam LLSB = LMLSB-LEFT;\n   localparam RMSB = LLSB-1;\n   localparam RLSB = LLSB-RIGHT;\n   localparam RMMSB = RLSB-1;\n   localparam RMLSB = RLSB-RIGHTMOST;\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH >= 32 && LEFTMOST >= 8 && LEFT >=8 && RIGHT >= 8 && RIGHTMOST >=8) begin: genblock\n`endif\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH)      dff   (.*, .din(din[WIDTH-1:0]), .dout(dout[WIDTH-1:0]));\n`else\n      rvdffiee #(LEFTMOST)   dff_leftmost  (.*, .din(din[LMMSB:LMLSB]), .dout(dout[LMMSB:LMLSB]));\n      rvdffiee #(LEFT)       dff_left      (.*, .din(din[LMSB:LLSB]),   .dout(dout[LMSB:LLSB])  );\n      rvdffiee #(RIGHT)      dff_right     (.*, .din(din[RMSB:RLSB]),   .dout(dout[RMSB:RLSB])  );\n      rvdffiee #(RIGHTMOST)  dff_rightmost (.*, .din(din[RMMSB:RMLSB]), .dout(dout[RMMSB:RMLSB]));\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdffe must be WIDTH >= 32 && LEFTMOST >= 8 && LEFT >=8 && RIGHT >= 8 && RIGHTMOST >=8\");\n`endif\n\nendmodule // rvdffe\n\n\n\n// specialty flop for power - ifu fetch buffers\n// rvdffe broken into 4 rvdffe's, equal width, each with own enable\nmodule rvdff4e #( parameter WIDTH=64 )\n   (\n     input  logic [WIDTH-1:0] din,\n     input  logic [3:0]     en,\n     input  logic           clk,\n     input  logic           rst_l,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   localparam LEFTMOST = int'(WIDTH/4);\n   localparam LEFT     = LEFTMOST;\n   localparam RIGHT    = LEFTMOST;\n   localparam RIGHTMOST = WIDTH - LEFTMOST - LEFT - RIGHT;\n\n   localparam LMMSB = WIDTH-1;\n   localparam LMLSB = LMMSB-LEFTMOST+1;\n   localparam LMSB = LMLSB-1;\n   localparam LLSB = LMLSB-LEFT;\n   localparam RMSB = LLSB-1;\n   localparam RLSB = LLSB-RIGHT;\n   localparam RMMSB = RLSB-1;\n   localparam RMLSB = RLSB-RIGHTMOST;\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH >= 32 && LEFTMOST >= 8 && LEFT >=8 && RIGHT >= 8 && RIGHTMOST >=8) begin: genblock\n`endif\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(LEFTMOST)   dff_leftmost  (.*, .din(din[LMMSB:LMLSB]), .dout(dout[LMMSB:LMLSB]),.en(en[3]));\n      rvdffs #(LEFT)       dff_left      (.*, .din(din[LMSB:LLSB]),   .dout(dout[LMSB:LLSB]),  .en(en[2]));\n      rvdffs #(RIGHT)      dff_right     (.*, .din(din[RMSB:RLSB]),   .dout(dout[RMSB:RLSB]),  .en(en[1]));\n      rvdffs #(RIGHTMOST)  dff_rightmost (.*, .din(din[RMMSB:RMLSB]), .dout(dout[RMMSB:RMLSB]),.en(en[0]));\n`else\n      rvdffe #(LEFTMOST)   dff_leftmost  (.*, .din(din[LMMSB:LMLSB]), .dout(dout[LMMSB:LMLSB]),.en(en[3]));\n      rvdffe #(LEFT)       dff_left      (.*, .din(din[LMSB:LLSB]),   .dout(dout[LMSB:LLSB]),  .en(en[2]));\n      rvdffe #(RIGHT)      dff_right     (.*, .din(din[RMSB:RLSB]),   .dout(dout[RMSB:RLSB]),  .en(en[1]));\n      rvdffe #(RIGHTMOST)  dff_rightmost (.*, .din(din[RMMSB:RMLSB]), .dout(dout[RMMSB:RMLSB]),.en(en[0]));\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdffe must be WIDTH >= 32 && LEFTMOST >= 8 && LEFT >=8 && RIGHT >= 8 && RIGHTMOST >=8\");\n`endif\n\nendmodule // rvdffe\n\n\nmodule rvdffe #( parameter WIDTH=1, OVERRIDE=0 )\n   (\n     input  logic [WIDTH-1:0] din,\n     input  logic           en,\n     input  logic           clk,\n     input  logic           rst_l,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic                      l1clk;\n\n`ifndef RV_PHYSICAL\n   if (WIDTH >= 8 || OVERRIDE==1) begin: genblock\n`endif\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .* );\n`else\n      rvclkhdr clkhdr ( .* );\n      rvdff #(WIDTH) dff (.*, .clk(l1clk));\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdffe width must be >= 8\");\n`endif\n\nendmodule // rvdffe\n\nmodule rvdffpcie #( parameter WIDTH=31 )\n   (\n     input  logic [WIDTH-1:0] din,\n     input  logic             clk,\n     input  logic             rst_l,\n     input  logic             en,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH == 31) begin: genblock\n`endif\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .* );\n`else\n\n      rvdfflie #(.WIDTH(WIDTH), .LEFT(19)) dff (.*);\n\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdffpc width must be 31\");\n`endif\nendmodule\n\n// format: { LEFT, EXTRA }\n// LEFT # of bits will be done with rvdffie, all else EXTRA with rvdffe\nmodule rvdfflie #( parameter WIDTH=16, LEFT=8 )\n   (\n     input  logic [WIDTH-1:0] din,\n     input  logic             clk,\n     input  logic             rst_l,\n     input  logic             en,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   localparam EXTRA = WIDTH-LEFT;\n\n   localparam LMSB = WIDTH-1;\n   localparam LLSB = LMSB-LEFT+1;\n   localparam XMSB = LLSB-1;\n   localparam XLSB = LLSB-EXTRA;\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH >= 16 && LEFT >= 8 && EXTRA >= 8) begin: genblock\n`endif\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .* );\n`else\n\n      rvdffiee #(LEFT)  dff_left  (.*, .din(din[LMSB:LLSB]), .dout(dout[LMSB:LLSB]));\n\n      rvdffe  #(EXTRA)  dff_extra (.*, .din(din[XMSB:XLSB]), .dout(dout[XMSB:XLSB]));\n\n\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdfflie musb be WIDTH >= 16 && LEFT >= 8 && EXTRA >= 8\");\n`endif\nendmodule\n\n// specialty flop for the inst buffers\n// format: { LEFT, PADLEFT, MIDDLE, PADRIGHT, RIGHT }\n// LEFT,MIDDLE # of bits will be done with rvdffie, PADLEFT, PADRIGHT rvdffe, RIGHT special rvdffe\nmodule rvdffibie #( parameter WIDTH=32, LEFT=8, PADLEFT=8, MIDDLE=8, PADRIGHT=8, RIGHT=8 )\n   (\n     input  logic [WIDTH-1:0] din,\n     input  logic             clk,\n     input  logic             rst_l,\n     input  logic             en,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   localparam LMSB = WIDTH-1;\n   localparam LLSB = LMSB-LEFT+1;\n   localparam PLMSB = LLSB-1;\n   localparam PLLSB = LLSB-PADLEFT;\n   localparam MMSB = PLLSB-1;\n   localparam MLSB = PLLSB-MIDDLE;\n   localparam PRMSB = MLSB-1;\n   localparam PRLSB = MLSB-PADRIGHT;\n   localparam RMSB = PRLSB-1;\n   localparam RLSB = PRLSB-RIGHT;\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH>=32 && LEFT>=8 && PADLEFT>=8 && MIDDLE>=8 && PADRIGHT>=8 && RIGHT >= 8) begin: genblock\n`endif\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .* );\n`else\n\n      rvdff2iee #(LEFT)     dff_left     (.*, .din(din[LMSB:LLSB]),   .dout(dout[LMSB:LLSB]));\n\n      rvdffe    #(PADLEFT)  dff_padleft  (.*, .din(din[PLMSB:PLLSB]), .dout(dout[PLMSB:PLLSB]));\n\n      rvdffe    #(MIDDLE)   dff_middle   (.*, .din(din[MMSB:MLSB]),   .dout(dout[MMSB:MLSB]), .en(en &  din[PLLSB]));  // prett[31:1]\n\n      rvdffe    #(PADRIGHT) dff_padright (.*, .din(din[PRMSB:PRLSB]), .dout(dout[PRMSB:PRLSB]));\n\n      rvdffe    #(RIGHT)    dff_right    (.*, .din(din[RMSB:RLSB]),   .dout(dout[RMSB:RLSB]), .en(en & ~din[PRLSB]));  // cinst\n\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdffibie must be WIDTH>=32 && LEFT>=8 && PADLEFT>=8 && MIDDLE>=8 && PADRIGHT>=8 && RIGHT >= 8\");\n`endif\nendmodule\n\n// specialty flop for power in the dest pkt flops\n// format: { LEFTMOST, LEFT, RIGHT, RIGHTMOST }\n// LEFTMOST,LEFT,RIGHT # of bits will be done with rvdffiee, all else RIGHTMOST with rvdffe\nmodule rvdffdpie #( parameter WIDTH=32, LEFTMOST=8, LEFT=8, RIGHT=8 )\n   (\n     input  logic [WIDTH-1:0] din,\n     input  logic             clk,\n     input  logic             rst_l,\n     input  logic             en,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   localparam RIGHTMOST = WIDTH-LEFTMOST-LEFT-RIGHT;\n\n   localparam LMMSB = WIDTH-1;\n   localparam LMLSB = LMMSB-LEFTMOST+1;\n   localparam LMSB = LMLSB-1;\n   localparam LLSB = LMLSB-LEFT;\n   localparam RMSB = LLSB-1;\n   localparam RLSB = LLSB-RIGHT;\n   localparam RMMSB = RLSB-1;\n   localparam RMLSB = RLSB-RIGHTMOST;\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH>=32 && LEFTMOST>=8 && LEFT>=8 && RIGHT>=8 && RIGHTMOST >= 8) begin: genblock\n`endif\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .* );\n`else\n\n      rvdffiee #(LEFTMOST)  dff_leftmost  (.*, .din(din[LMMSB:LMLSB]), .dout(dout[LMMSB:LMLSB]));\n\n      rvdffiee #(LEFT)      dff_left      (.*, .din(din[LMSB:LLSB]),   .dout(dout[LMSB:LLSB]));\n\n      rvdffiee #(RIGHT)     dff_right     (.*, .din(din[RMSB:RLSB]),   .dout(dout[RMSB:RLSB]));\n\n      rvdffe   #(RIGHTMOST) dff_rightmost (.*, .din(din[RMMSB:RMLSB]), .dout(dout[RMMSB:RMLSB]));\n\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdffdpie must be WIDTH>=32 && LEFTMOST>=8 && LEFT>=8 && RIGHT>=8 && RIGHTMOST >= 8\");\n`endif\nendmodule\n\n\n// special power flop for predict packet\n// format: { LEFT, PAD, RIGHT }\n// LEFT # of bits will be done with rvdffiee; LEFT,PAD with den; RIGHT with cen\nmodule rvdffppie #( parameter WIDTH=32, LEFT=8, RIGHT=8 )\n   (\n     input  logic [WIDTH-1:0] din,\n     input  logic             clk,\n     input  logic             rst_l,\n     input  logic             en,           // ctl enable\n     input  logic             den,          // data enable\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   localparam PAD = WIDTH-LEFT-RIGHT;\n\n   localparam LMSB = WIDTH-1;\n   localparam LLSB = LMSB-LEFT+1;\n   localparam PMSB = LLSB-1;\n   localparam PLSB = LLSB-PAD;\n   localparam RMSB = PLSB-1;\n   localparam RLSB = PLSB-RIGHT;\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH>=32 && LEFT>=8 && PAD>=8 && RIGHT>=8) begin: genblock\n`endif\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .* );\n`else\n      rvdffiee #(LEFT)   dff_left (.*, .din(din[LMSB:LLSB]), .dout(dout[LMSB:LLSB]), .en(den));\n\n      rvdffe   #(PAD)    dff_pad  (.*, .din(din[PMSB:PLSB]), .dout(dout[PMSB:PLSB]), .en(den));\n\n      rvdffe #(RIGHT)   dff_right (.*, .din(din[RMSB:RLSB]), .dout(dout[RMSB:RLSB]));\n\n\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdffppie must be WIDTH>=32 && LEFT>=8 && PAD>=8 && RIGHT>=8\");\n`endif\nendmodule\n\n\n\n\nmodule rvdffie #( parameter WIDTH=1, OVERRIDE=0 )\n   (\n     input  logic [WIDTH-1:0] din,\n\n     input  logic           clk,\n     input  logic           rst_l,\n     input  logic             scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic                      l1clk;\n   logic                      en;\n\n`ifndef RV_PHYSICAL\n   if (WIDTH >= 8 || OVERRIDE==1) begin: genblock\n`endif\n\n      assign en = |(din ^ dout);\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .* );\n`else\n      rvclkhdr clkhdr ( .* );\n      rvdff #(WIDTH) dff (.*, .clk(l1clk));\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n     $error(\"%m: rvdffie width must be >= 8\");\n`endif\n\nendmodule\n\n// ie flop but it has an .en input\nmodule rvdffiee #( parameter WIDTH=1, OVERRIDE=0 )\n   (\n     input  logic [WIDTH-1:0] din,\n\n     input  logic           clk,\n     input  logic           rst_l,\n     input  logic           scan_mode,\n     input  logic           en,\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic                      l1clk;\n   logic                      final_en;\n\n`ifndef RV_PHYSICAL\n   if (WIDTH >= 8 || OVERRIDE==1) begin: genblock\n`endif\n\n      assign final_en = (|(din ^ dout)) & en;\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .*, .en(final_en) );\n`else\n      rvdffe #(WIDTH) dff (.*,  .en(final_en));\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdffie width must be >= 8\");\n`endif\n\nendmodule\n\n// ie flop but it has an .en input\n// splits into 2 \"equal\" flops\nmodule rvdff2iee #( parameter WIDTH=16 )\n   (\n     input  logic [WIDTH-1:0] din,\n\n     input  logic           clk,\n     input  logic           rst_l,\n     input  logic           scan_mode,\n     input  logic           en,\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic                      l1clk;\n   logic                      final_en;\n\n   localparam LEFT = int'(WIDTH/2);\n   localparam RIGHT = WIDTH-LEFT;\n\n   localparam LMSB = WIDTH-1;\n   localparam LLSB = LMSB-LEFT+1;\n   localparam RMSB = LLSB-1;\n   localparam RLSB = LLSB-RIGHT;\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH >= 16 && LEFT>=8 && RIGHT>=8) begin: genblock\n`endif\n\n      assign final_en = (|(din ^ dout)) & en;\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .*, .en(final_en) );\n`else\n      rvdffe #(LEFT)  dff_left  (.*, .en(final_en), .din(din[LMSB:LLSB]), .dout(dout[LMSB:LLSB]));\n      rvdffe #(RIGHT) dff_right (.*, .en(final_en), .din(din[RMSB:RLSB]), .dout(dout[RMSB:RLSB]));\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdff2iee must be WIDTH >= 16 && LEFT>=8 && RIGHT>=8\");\n`endif\n\nendmodule\n\n// splits into 2 \"equal\" flops\nmodule rvdff2ie #( parameter WIDTH=16 )\n   (\n     input  logic [WIDTH-1:0] din,\n\n     input  logic           clk,\n     input  logic           rst_l,\n     input  logic           scan_mode,\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic                      l1clk;\n   logic                      final_en;\n\n   localparam LEFT = int'(WIDTH/2);\n   localparam RIGHT = WIDTH-LEFT;\n\n   localparam LMSB = WIDTH-1;\n   localparam LLSB = LMSB-LEFT+1;\n   localparam RMSB = LLSB-1;\n   localparam RLSB = LLSB-RIGHT;\n\n\n`ifndef RV_PHYSICAL\n   if (WIDTH >= 16 && LEFT>=8 && RIGHT>=8) begin: genblock\n`endif\n\n      assign final_en = |(din ^ dout);\n\n`ifdef RV_FPGA_OPTIMIZE\n      rvdffs #(WIDTH) dff ( .*, .en(final_en) );\n`else\n      rvdffe #(LEFT)  dff_left  (.*, .en(final_en), .din(din[LMSB:LLSB]), .dout(dout[LMSB:LLSB]));\n      rvdffe #(RIGHT) dff_right (.*, .en(final_en), .din(din[RMSB:RLSB]), .dout(dout[RMSB:RLSB]));\n`endif\n\n`ifndef RV_PHYSICAL\n   end\n   else\n      $error(\"%m: rvdff2ie must be WIDTH >= 16 && LEFT>=8 && RIGHT>=8\");\n`endif\n\nendmodule\n\nmodule rvsyncss #(parameter WIDTH = 251)\n   (\n     input  logic                 clk,\n     input  logic                 rst_l,\n     input  logic [WIDTH-1:0]     din,\n     output logic [WIDTH-1:0]     dout\n     );\n\n   logic [WIDTH-1:0]              din_ff1;\n\n   rvdff #(WIDTH) sync_ff1  (.*, .din (din[WIDTH-1:0]),     .dout(din_ff1[WIDTH-1:0]));\n   rvdff #(WIDTH) sync_ff2  (.*, .din (din_ff1[WIDTH-1:0]), .dout(dout[WIDTH-1:0]));\n\nendmodule // rvsyncss\n\nmodule rvsyncss_fpga #(parameter WIDTH = 251)\n   (\n     input  logic                 gw_clk,\n     input  logic                 rawclk,\n     input  logic                 clken,\n     input  logic                 rst_l,\n     input  logic [WIDTH-1:0]     din,\n     output logic [WIDTH-1:0]     dout\n     );\n\n   logic [WIDTH-1:0]              din_ff1;\n\n   rvdff_fpga #(WIDTH) sync_ff1  (.*, .clk(gw_clk), .rawclk(rawclk), .clken(clken), .din (din[WIDTH-1:0]),     .dout(din_ff1[WIDTH-1:0]));\n   rvdff_fpga #(WIDTH) sync_ff2  (.*, .clk(gw_clk), .rawclk(rawclk), .clken(clken), .din (din_ff1[WIDTH-1:0]), .dout(dout[WIDTH-1:0]));\n\nendmodule // rvsyncss\n\nmodule rvarbiter2_fpga\n  (\n   input  logic       [1:0] ready,\n   input  logic             shift,\n   input  logic             clk,\n   input  logic             rawclk,\n   input  logic             clken,\n   input  logic             rst_l,\n   input  logic             scan_mode,\n   output logic             tid\n   );\n\n   logic                    ready0, ready1, ready2;\n   logic                    favor_in, favor;\n\n   assign ready0 = ~(|ready[1:0]);\n\n   assign ready1 = ready[1] ^ ready[0];\n\n   assign ready2 = ready[1] & ready[0];\n\n   assign favor_in = (ready2 & ~favor) |\n                     (ready1 & ready[0]) |\n                     (ready0 & favor);\n\n   // only update if 2 ready threads\n   rvdffs_fpga #(1) favor_ff (.*, .en(shift & ready2), .clk(clk), .din(favor_in),  .dout(favor) );\n\n   // when to select tid 1\n   assign tid = (ready2 & favor) |\n                (ready[1] & ~ready[0]);\n\nendmodule\n\n\n`define RV_ARBITER2          \\\n   assign ready0 = ~(|ready[1:0]);           \\\n                                             \\\n   assign ready1 = ready[1] ^ ready[0];      \\\n                                             \\\n   assign ready2 = ready[1] & ready[0];      \\\n                                             \\\n   assign favor_in = (ready2 & ~favo"}
{"text": "r) |     \\\n                     (ready1 & ready[0]) |   \\\n                     (ready0 & favor);       \\\n                                             \\\n   // only update if 2 ready threads         \\\n   rvdffs #(.WIDTH(1)) favor_ff (.*, .en(shift & ready2), .clk(clk), .din(favor_in),  .dout(favor) );  \\\n                                             \\\n   // when to select tid 1                   \\\n   assign tid = (ready2 & favor) |           \\\n                (ready[1] & ~ready[0]);\n\n\nmodule rvarbiter2\n  (\n   input  logic       [1:0] ready,\n   input  logic             shift,\n   input  logic             clk,\n   input  logic             rst_l,\n   input  logic             scan_mode,\n   output logic             tid\n   );\n\n   logic                    ready0, ready1, ready2;\n   logic                    favor_in, favor;\n\n`RV_ARBITER2\n\nendmodule\n\n// bring out the favor bit as an output\nmodule rvarbiter2_pic\n  (\n   input  logic       [1:0] ready,\n   input  logic             shift,\n   input  logic             clk,\n   input  logic             rst_l,\n   input  logic             scan_mode,\n   output logic             tid,\n   output logic             favor\n   );\n\n   logic                    ready0, ready1, ready2;\n   logic                    favor_in;\n\n`RV_ARBITER2\n\nendmodule\n\n\n// .i 3\n// .o 5\n// .ilb ready[0] ready[1] favor\n// .ob i0_sel_i0_t1 i1_sel_i1[1] i1_sel_i0[1] i1_sel_i1[0] i1_sel_i0[0]\n//\n// .type fr\n//\n// 00 - - ----\n//\n// 01 - 1 1000\n//\n// 10 - 0 0010\n//\n// 11 0 0 0100\n//\n// 11 1 1 0001\n\n// .i 3\n// .o 1\n// .ilb favor_in i0_only_in[0] i0_only_in[1]\n// .ob favor_final\n//\n// .type fd\n//\n// 0 0 0  0\n// 0 0 1  1\n// 0 1 0  0\n// 0 1 1  0\n// 1 0 0  1\n// 1 0 1  1\n// 1 1 0  0\n// 1 1 1  1\n\nmodule rvarbiter2_smt\n  (\n   input  logic       [1:0] flush,\n   input  logic       [1:0] ready_in,\n   input  logic       [1:0] lsu_in,\n   input  logic       [1:0] mul_in,\n   input  logic       [1:0] i0_only_in,\n   input  logic       [1:0] thread_stall_in,\n   input  logic             force_favor_flip,\n   input  logic             shift,\n   input  logic             clk,\n   input  logic             rst_l,\n   input  logic             scan_mode,\n   output logic [1:0]       ready,\n   output logic             i0_sel_i0_t1,\n   output logic [1:0]       i1_sel_i1,\n   output logic [1:0]       i1_sel_i0\n   );\n\n   logic [1:0]              fready;\n   logic [1:0]              thread_cancel_in;\n   logic                    ready0, ready1, ready2;\n   logic                    favor_in, favor, favor_new, favor_final_raw, favor_final;\n   logic                    ready2_in;\n   logic                    lsu2_in;\n   logic                    mul2_in;\n   logic                    i0_only2_in;\n   logic [1:0]              eff_ready_in;\n   logic [1:0]              flush_ff;\n   logic                    update_favor_in, update_favor;\n\n\n   rvdff #(2) flushff (.*,\n                        .clk(clk),\n                        .din(flush[1:0]),\n                        .dout(flush_ff[1:0])\n                        );\n\n   // if thread is flushed take it out of arbitration right away\n   // if thread is stalled AND both threads ready make ready=0 for stall thread\n   assign eff_ready_in[1:0] = ready_in[1:0] & ~({2{ready_in[1]&ready_in[0]}} & thread_stall_in[1:0]) & ~flush[1:0] & ~flush_ff[1:0];\n\n\n   rvdff #(2) ready_ff (.*,\n                        .clk(clk),\n                        .din(eff_ready_in[1:0]),\n                        .dout(ready[1:0])\n                        );\n\n   // optimize for power: only update favor bit when you have to\n   assign update_favor_in = &eff_ready_in[1:0] & (lsu2_in | mul2_in | i0_only2_in);\n\n   rvdff #(1) update_favor_ff (.*,\n                        .clk(clk),\n                        .din(update_favor_in),\n                        .dout(update_favor)\n                        );\n\n\n   assign favor_in = (shift & (update_favor | force_favor_flip)) ? ~favor : favor;\n\n   // i0_only optimization : make i0_only favored if at all possible\n   assign favor_final_raw = (favor_in       & !i0_only_in[0]) |\n                            (!i0_only_in[0] &  i0_only_in[1]) |\n                            (favor_in       &  i0_only_in[1]);\n\n   assign favor_final = (force_favor_flip) ? favor_in : favor_final_raw;\n\n   rvdff #(1) favor_ff (.*, .clk(clk), .din(favor_final),  .dout(favor) );\n\n   // SMT optimization\n   assign ready2_in  = eff_ready_in[1] & eff_ready_in[0];\n   assign lsu2_in    = lsu_in[1] & lsu_in[0];\n   assign mul2_in    = mul_in[1] & mul_in[0];\n   assign i0_only2_in = i0_only_in[1] & i0_only_in[0];\n\n   // cancel non favored thread in the case of 2 muls or 2 load/stores\n   // this case won't happen if i0_only for one or more threads\n   assign thread_cancel_in[1:0] = { (lsu2_in | mul2_in) & ready2_in & ~favor_in,\n                                    (lsu2_in | mul2_in) & ready2_in &  favor_in  };\n   rvdff #(2) fready_ff (.*,\n                        .clk(clk),\n                        .din(eff_ready_in[1:0] & ~thread_cancel_in[1:0]),\n                        .dout(fready[1:0])\n                        );\n\n   assign i0_sel_i0_t1 = (fready[1]&favor) | (!fready[0]);\n\n   assign i1_sel_i1[1] = (!fready[0]);\n\n   assign i1_sel_i0[1] = (fready[0]&fready[1]&!favor);\n\n   assign i1_sel_i1[0] = (!fready[1]);\n\n   assign i1_sel_i0[0] = (fready[0]&fready[1]&favor);\n\n\n\nendmodule\n\n\nmodule rvlsadder\n  (\n    input logic [31:0] rs1,\n    input logic [11:0] offset,\n\n    output logic [31:0] dout\n    );\n\n   logic                cout;\n   logic                sign;\n\n   logic [31:12]        rs1_inc;\n   logic [31:12]        rs1_dec;\n\n   assign {cout,dout[11:0]} = {1'b0,rs1[11:0]} + {1'b0,offset[11:0]};\n\n   assign rs1_inc[31:12] = rs1[31:12] + 1;\n\n   assign rs1_dec[31:12] = rs1[31:12] - 1;\n\n   assign sign = offset[11];\n\n   assign dout[31:12] = ({20{  sign ^  ~cout}}  &     rs1[31:12]) |\n                        ({20{ ~sign &   cout}}  & rs1_inc[31:12]) |\n                        ({20{  sign &  ~cout}}  & rs1_dec[31:12]);\n\nendmodule // rvlsadder\n\n// assume we only maintain pc[31:1] in the pipe\n\nmodule rvbradder\n import eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n (\n    input [31:1] pc,\n    input [pt.BTB_TOFFSET_SIZE:1] offset,\n\n    output [31:1] dout\n    );\n\n   logic          cout;\n   logic          sign;\n\n   logic [31:pt.BTB_TOFFSET_SIZE+1]  pc_inc;\n   logic [31:pt.BTB_TOFFSET_SIZE+1]  pc_dec;\n\n   assign {cout,dout[pt.BTB_TOFFSET_SIZE:1]} = {1'b0,pc[pt.BTB_TOFFSET_SIZE:1]} + {1'b0,offset[pt.BTB_TOFFSET_SIZE:1]};\n\n   assign pc_inc[31:pt.BTB_TOFFSET_SIZE+1] = pc[31:pt.BTB_TOFFSET_SIZE+1] + 1;\n\n   assign pc_dec[31:pt.BTB_TOFFSET_SIZE+1] = pc[31:pt.BTB_TOFFSET_SIZE+1] - 1;\n\n   assign sign = offset[pt.BTB_TOFFSET_SIZE];\n\n\n   assign dout[31:pt.BTB_TOFFSET_SIZE+1] = ({31-pt.BTB_TOFFSET_SIZE{  sign ^  ~cout}} &      pc[31:pt.BTB_TOFFSET_SIZE+1]) |\n                                           ({31-pt.BTB_TOFFSET_SIZE{ ~sign &   cout}}  & pc_inc[31:pt.BTB_TOFFSET_SIZE+1]) |\n                                           ({31-pt.BTB_TOFFSET_SIZE{  sign &  ~cout}}  & pc_dec[31:pt.BTB_TOFFSET_SIZE+1]);\n\n\nendmodule // rvbradder\n\n\n// 2s complement circuit\nmodule rvtwoscomp #( parameter WIDTH=32 )\n   (\n     input logic [WIDTH-1:0] din,\n\n     output logic [WIDTH-1:0] dout\n     );\n\n   logic [WIDTH-1:1]          dout_temp;   // holding for all other bits except for the lsb. LSB is always din\n\n   genvar                     i;\n\n   for ( i = 1; i < WIDTH; i++ )  begin : flip_after_first_one\n      assign dout_temp[i] = (|din[i-1:0]) ? ~din[i] : din[i];\n   end : flip_after_first_one\n\n   assign dout[WIDTH-1:0]  = { dout_temp[WIDTH-1:1], din[0] };\n\nendmodule  // 2'scomp\n\n// find first\nmodule rvfindfirst1 #( parameter WIDTH=32, SHIFT=$clog2(WIDTH) )\n   (\n     input logic [WIDTH-1:0] din,\n\n     output logic [SHIFT-1:0] dout\n     );\n   logic                      done;\n\n   always_comb begin\n      dout[SHIFT-1:0] = {SHIFT{1'b0}};\n      done    = 1'b0;\n\n      for ( int i = WIDTH-1; i > 0; i-- )  begin : find_first_one\n         done |= din[i];\n         dout[SHIFT-1:0] += done ? 1'b0 : 1'b1;\n      end : find_first_one\n   end\nendmodule // rvfindfirst1\n\nmodule rvfindfirst1hot #( parameter WIDTH=32 )\n   (\n     input logic [WIDTH-1:0] din,\n\n     output logic [WIDTH-1:0] dout\n     );\n   logic                      done;\n\n   always_comb begin\n      dout[WIDTH-1:0] = {WIDTH{1'b0}};\n      done    = 1'b0;\n      for ( int i = 0; i < WIDTH; i++ )  begin : find_first_one\n         dout[i] = ~done & din[i];\n         done   |= din[i];\n      end : find_first_one\n   end\nendmodule // rvfindfirst1hot\n\n// mask and match function matches bits after finding the first 0 position\n// find first starting from LSB. Skip that location and match the rest of the bits\nmodule rvmaskandmatch #( parameter WIDTH=32 )\n   (\n     input  logic [WIDTH-1:0] mask,     // this will have the mask in the lower bit positions\n     input  logic [WIDTH-1:0] data,     // this is what needs to be matched on the upper bits with the mask's upper bits\n     input  logic             masken,   // when 1 : do mask. 0 : full match\n     output logic             match\n     );\n\n   logic [WIDTH-1:0]          matchvec;\n   logic                      masken_or_fullmask;\n\n   assign masken_or_fullmask = masken &  ~(&mask[WIDTH-1:0]);\n\n   assign matchvec[0]        = masken_or_fullmask | (mask[0] == data[0]);\n   genvar                     i;\n\n   for ( i = 1; i < WIDTH; i++ )  begin : match_after_first_zero\n      assign matchvec[i] = (&mask[i-1:0] & masken_or_fullmask) ? 1'b1 : (mask[i] == data[i]);\n   end : match_after_first_zero\n\n   assign match  = &matchvec[WIDTH-1:0];    // all bits either matched or were masked off\n\nendmodule // rvmaskandmatch\n\n\n// Check if the S_ADDR <= addr < E_ADDR\nmodule rvrangecheck  #(CCM_SADR = 32'h0,\n                       CCM_SIZE  = 128) (\n   input  logic [31:0]   addr,                             // Address to be checked for range\n   output logic          in_range,                            // S_ADDR <= start_addr < E_ADDR\n   output logic          in_region\n);\n\n   localparam REGION_BITS = 4;\n   localparam MASK_BITS = 10 + $clog2(CCM_SIZE);\n\n   logic [31:0]          start_addr;\n   logic [3:0]           region;\n\n   assign start_addr[31:0]        = CCM_SADR;\n   assign region[REGION_BITS-1:0] = start_addr[31:(32-REGION_BITS)];\n\n   assign in_region = (addr[31:(32-REGION_BITS)] == region[REGION_BITS-1:0]);\n   if (CCM_SIZE  == 48)\n    assign in_range  = (addr[31:MASK_BITS] == start_addr[31:MASK_BITS]) & ~(&addr[MASK_BITS-1 : MASK_BITS-2]);\n   else\n    assign in_range  = (addr[31:MASK_BITS] == start_addr[31:MASK_BITS]);\n\nendmodule  // rvrangechecker\n\n// 16 bit even parity generator\nmodule rveven_paritygen #(WIDTH = 16)  (\n                                         input  logic [WIDTH-1:0]  data_in,         // Data\n                                         output logic              parity_out       // generated even parity\n                                         );\n\n   assign  parity_out =  ^(data_in[WIDTH-1:0]) ;\n\nendmodule  // rveven_paritygen\n\nmodule rveven_paritycheck #(WIDTH = 16)  (\n                                           input  logic [WIDTH-1:0]  data_in,         // Data\n                                           input  logic              parity_in,\n                                           output logic              parity_err       // Parity error\n                                           );\n\n   assign  parity_err =  ^(data_in[WIDTH-1:0]) ^ parity_in ;\n\nendmodule  // rveven_paritycheck\n\nmodule rvecc_encode  (\n                      input [31:0] din,\n                      output [6:0] ecc_out\n                      );\nlogic [5:0] ecc_out_temp;\n\n   assign ecc_out_temp[0] = din[0]^din[1]^din[3]^din[4]^din[6]^din[8]^din[10]^din[11]^din[13]^din[15]^din[17]^din[19]^din[21]^din[23]^din[25]^din[26]^din[28]^din[30];\n   assign ecc_out_temp[1] = din[0]^din[2]^din[3]^din[5]^din[6]^din[9]^din[10]^din[12]^din[13]^din[16]^din[17]^din[20]^din[21]^din[24]^din[25]^din[27]^din[28]^din[31];\n   assign ecc_out_temp[2] = din[1]^din[2]^din[3]^din[7]^din[8]^din[9]^din[10]^din[14]^din[15]^din[16]^din[17]^din[22]^din[23]^din[24]^din[25]^din[29]^din[30]^din[31];\n   assign ecc_out_temp[3] = din[4]^din[5]^din[6]^din[7]^din[8]^din[9]^din[10]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25];\n   assign ecc_out_temp[4] = din[11]^din[12]^din[13]^din[14]^din[15]^din[16]^din[17]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25];\n   assign ecc_out_temp[5] = din[26]^din[27]^din[28]^din[29]^din[30]^din[31];\n\n   assign ecc_out[6:0] = {(^din[31:0])^(^ecc_out_temp[5:0]),ecc_out_temp[5:0]};\n\nendmodule // rvecc_encode\n\nmodule rvecc_decode  (\n                      input         en,\n                      input [31:0]  din,\n                      input [6:0]   ecc_in,\n                      input         sed_ded,\n                      output [31:0] dout,\n                      output [6:0]  ecc_out,\n                      output        single_ecc_error,\n                      output        double_ecc_error\n\n                      );\n\n   logic [6:0]                      ecc_check;\n   logic [38:0]                     error_mask;\n   logic [38:0]                     din_plus_parity, dout_plus_parity;\n\n   // Generate the ecc bits\n   assign ecc_check[0] = ecc_in[0]^din[0]^din[1]^din[3]^din[4]^din[6]^din[8]^din[10]^din[11]^din[13]^din[15]^din[17]^din[19]^din[21]^din[23]^din[25]^din[26]^din[28]^din[30];\n   assign ecc_check[1] = ecc_in[1]^din[0]^din[2]^din[3]^din[5]^din[6]^din[9]^din[10]^din[12]^din[13]^din[16]^din[17]^din[20]^din[21]^din[24]^din[25]^din[27]^din[28]^din[31];\n   assign ecc_check[2] = ecc_in[2]^din[1]^din[2]^din[3]^din[7]^din[8]^din[9]^din[10]^din[14]^din[15]^din[16]^din[17]^din[22]^din[23]^din[24]^din[25]^din[29]^din[30]^din[31];\n   assign ecc_check[3] = ecc_in[3]^din[4]^din[5]^din[6]^din[7]^din[8]^din[9]^din[10]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25];\n   assign ecc_check[4] = ecc_in[4]^din[11]^din[12]^din[13]^din[14]^din[15]^din[16]^din[17]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25];\n   assign ecc_check[5] = ecc_in[5]^din[26]^din[27]^din[28]^din[29]^din[30]^din[31];\n\n   // This is the parity bit\n   assign ecc_check[6] = ((^din[31:0])^(^ecc_in[6:0])) & ~sed_ded;\n\n   assign single_ecc_error = en & (ecc_check[6:0] != 0) & ecc_check[6];   // this will never be on for sed_ded\n   assign double_ecc_error = en & (ecc_check[6:0] != 0) & ~ecc_check[6];  // all errors in the sed_ded case will be recorded as DE\n\n   // Generate the mask for error correctiong\n   for (genvar i=1; i<40; i++) begin\n      assign error_mask[i-1] = (ecc_check[5:0] == i);\n   end\n\n   // Generate the corrected data\n   assign din_plus_parity[38:0] = {ecc_in[6], din[31:26], ecc_in[5], din[25:11], ecc_in[4], din[10:4], ecc_in[3], din[3:1], ecc_in[2], din[0], ecc_in[1:0]};\n\n   assign dout_plus_parity[38:0] = single_ecc_error ? (error_mask[38:0] ^ din_plus_parity[38:0]) : din_plus_parity[38:0];\n   assign dout[31:0]             = {dout_plus_parity[37:32], dout_plus_parity[30:16], dout_plus_parity[14:8], dout_plus_parity[6:4], dout_plus_parity[2]};\n   assign ecc_out[6:0]           = {(dout_plus_parity[38] ^ (ecc_check[6:0] == 7'b1000000)), dout_plus_parity[31], dout_plus_parity[15], dout_plus_parity[7], dout_plus_parity[3], dout_plus_parity[1:0]};\n\nendmodule // rvecc_decode\n\nmodule rvecc_encode_64  (\n                      input [63:0] din,\n                      output [6:0] ecc_out\n                      );\n  assign ecc_out[0] = din[0]^din[1]^din[3]^din[4]^din[6]^din[8]^din[10]^din[11]^din[13]^din[15]^din[17]^din[19]^din[21]^din[23]^din[25]^din[26]^din[28]^din[30]^din[32]^din[34]^din[36]^din[38]^din[40]^din[42]^din[44]^din[46]^din[48]^din[50]^din[52]^din[54]^din[56]^din[57]^din[59]^din[61]^din[63];\n\n   assign ecc_out[1] = din[0]^din[2]^din[3]^din[5]^din[6]^din[9]^din[10]^din[12]^din[13]^din[16]^din[17]^din[20]^din[21]^din[24]^din[25]^din[27]^din[28]^din[31]^din[32]^din[35]^din[36]^din[39]^din[40]^din[43]^din[44]^din[47]^din[48]^din[51]^din[52]^din[55]^din[56]^din[58]^din[59]^din[62]^din[63];\n\n   assign ecc_out[2] = din[1]^din[2]^din[3]^din[7]^din[8]^din[9]^din[10]^din[14]^din[15]^din[16]^din[17]^din[22]^din[23]^din[24]^din[25]^din[29]^din[30]^din[31]^din[32]^din[37]^din[38]^din[39]^din[40]^din[45]^din[46]^din[47]^din[48]^din[53]^din[54]^din[55]^din[56]^din[60]^din[61]^din[62]^din[63];\n\n   assign ecc_out[3] = din[4]^din[5]^din[6]^din[7]^din[8]^din[9]^din[10]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25]^din[33]^din[34]^din[35]^din[36]^din[37]^din[38]^din[39]^din[40]^din[49]^din[50]^din[51]^din[52]^din[53]^din[54]^din[55]^din[56];\n\n   assign ecc_out[4] = din[11]^din[12]^din[13]^din[14]^din[15]^din[16]^din[17]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25]^din[41]^din[42]^din[43]^din[44]^din[45]^din[46]^din[47]^din[48]^din[49]^din[50]^din[51]^din[52]^din[53]^din[54]^din[55]^din[56];\n\n   assign ecc_out[5] = din[26]^din[27]^din[28]^din[29]^din[30]^din[31]^din[32]^din[33]^din[34]^din[35]^din[36]^din[37]^din[38]^din[39]^din[40]^din[41]^din[42]^din[43]^din[44]^din[45]^din[46]^din[47]^din[48]^din[49]^din[50]^din[51]^din[52]^din[53]^din[54]^din[55]^din[56];\n\n   assign ecc_out[6] = din[57]^din[58]^din[59]^din[60]^din[61]^din[62]^din[63];\n\nendmodule // rvecc_encode_64\n\n\nmodule rvecc_decode_64  (\n                      input         en,\n                      input [63:0]  din,\n                      input [6:0]   ecc_in,\n                      output        ecc_error\n                      );\n\n   logic [6:0]                      ecc_check;\n\n   // Generate the ecc bits\n   assign ecc_check[0] = ecc_in[0]^din[0]^din[1]^din[3]^din[4]^din[6]^din[8]^din[10]^din[11]^din[13]^din[15]^din[17]^din[19]^din[21]^din[23]^din[25]^din[26]^din[28]^din[30]^din[32]^din[34]^din[36]^din[38]^din[40]^din[42]^din[44]^din[46]^din[48]^din[50]^din[52]^din[54]^din[56]^din[57]^din[59]^din[61]^din[63];\n\n   assign ecc_check[1] = ecc_in[1]^din[0]^din[2]^din[3]^din[5]^din[6]^din[9]^din[10]^din[12]^din[13]^din[16]^din[17]^din[20]^din[21]^din[24]^din[25]^din[27]^din[28]^din[31]^din[32]^din[35]^din[36]^din[39]^din[40]^din[43]^din[44]^din[47]^din[48]^din[51]^din[52]^din[55]^din[56]^din[58]^din[59]^din[62]^din[63];\n\n   assign ecc_check[2] = ecc_in[2]^din[1]^din[2]^din[3]^din[7]^din[8]^din[9]^din[10]^din[14]^din[15]^din[16]^din[17]^din[22]^din[23]^din[24]^din[25]^din[29]^din[30]^din[31]^din[32]^din[37]^din[38]^din[39]^din[40]^din[45]^din[46]^din[47]^din[48]^din[53]^din[54]^din[55]^din[56]^din[60]^din[61]^din[62]^din[63];\n\n   assign ecc_check[3] = ecc_in[3]^din[4]^din[5]^din[6]^din[7]^din[8]^din[9]^din[10]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25]^din[33]^din[34]^din[35]^din[36]^din[37]^din[38]^din[39]^din[40]^din[49]^din[50]^din[51]^din[52]^din[53]^din[54]^din[55]^din[56];\n\n   assign ecc_check[4] = ecc_in[4]^din[11]^din[12]^din[13]^din[14]^din[15]^din[16]^din[17]^din[18]^din[19]^din[20]^din[21]^din[22]^din[23]^din[24]^din[25]^din[41]^din[42]^din[43]^din[44]^din[45]^din[46]^din[47]^din[48]^din[49]^din[50]^din[51]^din[52]^din[53]^din[54]^din[55]^din[56];\n\n   assign ecc_check[5] = ecc_in[5]^din[26]^din[27]^din[28]^din[29]^din[30]^din[31]^din[32]^din[33]^din[34]^din[35]^din[36]^din[37]^din[38]^din[39]^din[40]^din[41]^din[42]^din[43]^din[44]^din[45]^din[46]^din[47]^din[48]^din[49]^din[50]^din[51]^din[52]^din[53]^din[54]^din[55]^din[56];\n\n   assign ecc_check[6] = ecc_in[6]^din[57]^din[58]^din[59]^din[60]^din[61]^din[62]^din[63];\n\n   assign ecc_error = en & (ecc_check[6:0] != 0);  // all errors in the sed_ded case will be recorded as DE\n\n endmodule // rvecc_decode_64\n\nmodule `TEC_RV_ICG (\n   input logic SE, EN, CK,\n   output Q\n   );\n\n   logic  en_ff /*verilator clock_enable*/;\n   logic  enable;\n\n   assign      enable = EN | SE;\n\n`ifdef VERILATOR\n   always_latch if(!CK) en_ff = enable;\n`else\n   always @(CK, enable) begin\n      if(!CK)\n        en_ff = enable;\n   end\n`endif\n   assign Q = CK & en_ff;\n\nendmodule\n\n`ifndef RV_FPGA_OPTIMIZE\nmodule rvclkhdr\n  (\n   input  logic en,\n   input  logic clk,\n   input  logic scan"}
{"text": "_mode,\n   output logic l1clk\n   );\n\n   logic   SE;\n   assign       SE = 0;\n\n   `TEC_RV_ICG clkhdr ( .*, .EN(en), .CK(clk), .Q(l1clk));\n\nendmodule // rvclkhdr\n`endif\n\nmodule rvoclkhdr\n  (\n   input  logic en,\n   input  logic clk,\n   input  logic scan_mode,\n   output logic l1clk\n   );\n\n   logic   SE;\n   assign       SE = 0;\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign l1clk = clk;\n`else\n   `TEC_RV_ICG clkhdr ( .*, .EN(en), .CK(clk), .Q(l1clk));\n`endif\n\nendmodule\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2018 Western Digital Corporation or it's affiliates.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//------------------------------------------------------------------------------------\n//\n//  Copyright Western Digital, 2019\n//  Owner : Alex Grobman\n//  Description:  \n//                This module Synchronizes the signals between JTAG (TCK) and\n//                processor (Core_clk)\n//\n//-------------------------------------------------------------------------------------\n\nmodule dmi_jtag_to_core_sync (\n// JTAG signals\ninput       rd_en,      // 1 bit  Read Enable from JTAG\ninput       wr_en,      // 1 bit  Write enable from JTAG\n\n// Processor Signals\ninput       rst_n,      // Core reset\ninput       clk,        // Core clock\n\noutput      reg_en,     // 1 bit  Write interface bit to Processor\noutput      reg_wr_en   // 1 bit  Write enable to Processor\n);\n  \nwire        c_rd_en;\nwire        c_wr_en;\nreg [2:0]   rden, wren;\n \n\n// Outputs\nassign reg_en    = c_wr_en | c_rd_en;\nassign reg_wr_en = c_wr_en;\n\n\n// synchronizers  \nalways @ ( posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        rden <= '0;\n        wren <= '0;\n    end\n    else begin\n        rden <= {rden[1:0], rd_en};\n        wren <= {wren[1:0], wr_en};\n    end\nend\n\nassign c_rd_en = rden[1] & ~rden[2];\nassign c_wr_en = wren[1] & ~wren[2];\n \n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2018 Western Digital Corporation or it's affiliates.\n// \n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n// \n// http://www.apache.org/licenses/LICENSE-2.0\n// \n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//------------------------------------------------------------------------------------\n//\n//  Copyright Western Digital, 2018\n//  Owner : Anusha Narayanamoorthy\n//  Description:  \n//                Wrapper module for JTAG_TAP and DMI synchronizer\n//\n//-------------------------------------------------------------------------------------\n\nmodule dmi_wrapper(\n\n  // JTAG signals\n  input              trst_n,              // JTAG reset\n  input              tck,                 // JTAG clock\n  input              tms,                 // Test mode select   \n  input              tdi,                 // Test Data Input\n  output             tdo,                 // Test Data Output           \n  output             tdoEnable,           // Test Data Output enable             \n\n  // Processor Signals\n  input              core_rst_n,          // Core reset                  \n  input              core_clk,            // Core clock                  \n  input [31:1]       jtag_id,             // JTAG ID\n  input [31:0]       rd_data,             // 32 bit Read data from  Processor                       \n  output [31:0]      reg_wr_data,         // 32 bit Write data to Processor                      \n  output [6:0]       reg_wr_addr,         // 7 bit reg address to Processor                   \n  output             reg_en,              // 1 bit  Read enable to Processor                                    \n  output             reg_wr_en,           // 1 bit  Write enable to Processor \n  output             dmi_hard_reset  \n);\n\n\n  \n\n\n  //Wire Declaration\n  wire                     rd_en;\n  wire                     wr_en;\n  wire                     dmireset;\n\n \n  //jtag_tap instantiation\n rvjtag_tap i_jtag_tap(\n   .trst(trst_n),                      // dedicated JTAG TRST (active low) pad signal or asynchronous active low power on reset\n   .tck(tck),                          // dedicated JTAG TCK pad signal\n   .tms(tms),                          // dedicated JTAG TMS pad signal\n   .tdi(tdi),                          // dedicated JTAG TDI pad signal\n   .tdo(tdo),                          // dedicated JTAG TDO pad signal\n   .tdoEnable(tdoEnable),              // enable for TDO pad\n   .wr_data(reg_wr_data),              // 32 bit Write data\n   .wr_addr(reg_wr_addr),              // 7 bit Write address\n   .rd_en(rd_en),                      // 1 bit  read enable\n   .wr_en(wr_en),                      // 1 bit  Write enable\n   .rd_data(rd_data),                  // 32 bit Read data\n   .rd_status(2'b0),\n   .idle(3'h0),                         // no need to wait to sample data\n   .dmi_stat(2'b0),                     // no need to wait or error possible\n   .version(4'h1),                      // debug spec 0.13 compliant\n   .jtag_id(jtag_id),\n   .dmi_hard_reset(dmi_hard_reset),\n   .dmi_reset(dmireset)\n);\n\n\n  // dmi_jtag_to_core_sync instantiation\n  dmi_jtag_to_core_sync i_dmi_jtag_to_core_sync(\n    .wr_en(wr_en),                          // 1 bit  Write enable\n    .rd_en(rd_en),                          // 1 bit  Read enable\n\n    .rst_n(core_rst_n),\n    .clk(core_clk),\n    .reg_en(reg_en),                          // 1 bit  Write interface bit\n    .reg_wr_en(reg_wr_en)                          // 1 bit  Write enable\n  );\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n// $Id$\n//\n// Function: Top level VEER core file to control the debug mode\n// Comments: Responsible to put the rest of the core in quiesce mode,\n//           Send the commands/address. sends WrData and Recieve read Data.\n//           And then Resume the core to do the normal mode\n// Author  :\n//********************************************************************************\nmodule eh2_dbg #(\n`include \"eh2_param.vh\"\n )(\n   // outputs to the core for command and data interface\n   output logic [31:0]                 dbg_cmd_addr,\n   output logic [31:0]                 dbg_cmd_wrdata,\n   output logic                        dbg_cmd_valid,\n   output logic                        dbg_cmd_tid,     // thread for debug register read\n   output logic                        dbg_cmd_write,   // 1: write command, 0: read_command\n   output logic [1:0]                  dbg_cmd_type,    // 0:gpr 1:csr 2: memory\n   output logic [1:0]                  dbg_cmd_size,    // size of the abstract mem access debug command\n   output logic                        dbg_core_rst_l,  // Debug reset\n\n   // inputs back from the core/dec\n   input logic [31:0]                  core_dbg_rddata,\n   input logic                         core_dbg_cmd_done, // This will be treated like a valid signal\n   input logic                         core_dbg_cmd_fail, // Exception during command run\n\n   // Signals to dma to get a bubble\n   output logic                        dbg_dma_bubble,   // Debug needs a bubble to send a valid\n   input  logic                        dma_dbg_ready,    // DMA is ready to accept debug request\n\n   // interface with the rest of the core to halt/resume handshaking\n   output logic [pt.NUM_THREADS-1:0]   dbg_halt_req, // This is a pulse\n   output logic [pt.NUM_THREADS-1:0]   dbg_resume_req, // Debug sends a resume requests. Pulse\n   input  logic [pt.NUM_THREADS-1:0]   dec_tlu_debug_mode,        // Core is in debug mode\n   input  logic [pt.NUM_THREADS-1:0]   dec_tlu_dbg_halted, // The core has finished the queiscing sequence. Core is halted now\n   input  logic [pt.NUM_THREADS-1:0]   dec_tlu_mpc_halted_only,   // Only halted due to MPC\n   input  logic [pt.NUM_THREADS-1:0]   dec_tlu_resume_ack, // core sends back an ack for the resume (pulse)\n   input  logic [pt.NUM_THREADS-1:0]   dec_tlu_mhartstart, // running harts\n\n   // inputs from the JTAG\n   input logic                         dmi_reg_en, // read or write\n   input logic [6:0]                   dmi_reg_addr, // address of DM register\n   input logic                         dmi_reg_wr_en, // write instruction\n   input logic [31:0]                  dmi_reg_wdata, // write data\n   // output\n   output logic [31:0]                 dmi_reg_rdata, // read data\n\n   // AXI Write Channels\n   output logic                        sb_axi_awvalid,\n   input  logic                        sb_axi_awready,\n   output logic [pt.SB_BUS_TAG-1:0]    sb_axi_awid,\n   output logic [31:0]                 sb_axi_awaddr,\n   output logic [3:0]                  sb_axi_awregion,\n   output logic [7:0]                  sb_axi_awlen,\n   output logic [2:0]                  sb_axi_awsize,\n   output logic [1:0]                  sb_axi_awburst,\n   output logic                        sb_axi_awlock,\n   output logic [3:0]                  sb_axi_awcache,\n   output logic [2:0]                  sb_axi_awprot,\n   output logic [3:0]                  sb_axi_awqos,\n\n   output logic                        sb_axi_wvalid,\n   input  logic                        sb_axi_wready,\n   output logic [63:0]                 sb_axi_wdata,\n   output logic [7:0]                  sb_axi_wstrb,\n   output logic                        sb_axi_wlast,\n\n   input  logic                        sb_axi_bvalid,\n   output logic                        sb_axi_bready,\n   input  logic [1:0]                  sb_axi_bresp,\n\n   // AXI Read Channels\n   output logic                        sb_axi_arvalid,\n   input  logic                        sb_axi_arready,\n   output logic [pt.SB_BUS_TAG-1:0]    sb_axi_arid,\n   output logic [31:0]                 sb_axi_araddr,\n   output logic [3:0]                  sb_axi_arregion,\n   output logic [7:0]                  sb_axi_arlen,\n   output logic [2:0]                  sb_axi_arsize,\n   output logic [1:0]                  sb_axi_arburst,\n   output logic                        sb_axi_arlock,\n   output logic [3:0]                  sb_axi_arcache,\n   output logic [2:0]                  sb_axi_arprot,\n   output logic [3:0]                  sb_axi_arqos,\n\n   input  logic                        sb_axi_rvalid,\n   output logic                        sb_axi_rready,\n   input  logic [63:0]                 sb_axi_rdata,\n   input  logic [1:0]                  sb_axi_rresp,\n\n   input logic                         dbg_bus_clk_en,\n\n   // general inputs\n   input logic                         clk,\n   input logic                         free_clk,\n   input logic                         rst_l,         // This includes both top rst and debug core rst\n   input logic                         dbg_rst_l,\n   input logic                         clk_override,\n   input logic                         scan_mode\n);\n\n\n   typedef enum logic [3:0] {IDLE=4'h0, HALTING=4'h1, HALTED=4'h2, CORE_CMD_START=4'h3, CORE_CMD_WAIT=4'h4, SB_CMD_START=4'h5, SB_CMD_SEND=4'h6, SB_CMD_RESP=4'h7, CMD_DONE=4'h8, RESUMING=4'h9} state_t;\n   typedef enum logic [3:0] {SBIDLE=4'h0, WAIT_RD=4'h1, WAIT_WR=4'h2, CMD_RD=4'h3, CMD_WR=4'h4, CMD_WR_ADDR=4'h5, CMD_WR_DATA=4'h6, RSP_RD=4'h7, RSP_WR=4'h8, DONE=4'h9} sb_state_t;\n\n   state_t [pt.NUM_THREADS-1:0]  dbg_state;\n   state_t [pt.NUM_THREADS-1:0]  dbg_nxtstate;\n   logic   [pt.NUM_THREADS-1:0]  dbg_state_en;\n   // these are the registers that the debug module implements\n   logic [31:0]  dmstatus_reg;        // [26:24]-dmerr, [17:16]-resume ack, [9:8]-halted, [3:0]-version\n   logic [31:0]  dmcontrol_reg;       // dmcontrol register has only 6 bits implemented. 31: haltreq, 30: resumereq, 29: haltreset, 28: ackhavereset, 1: ndmreset, 0: dmactive.\n   logic [31:0]  command_reg;\n   logic [31:0]  abstractcs_reg;      // bits implemted are [12] - busy and [10:8]= command error\n   logic [31:0]  hawindow_reg;\n   logic [31:0]  haltsum0_reg;\n   logic [31:0]  data0_reg;\n   logic [31:0]  data1_reg;\n\n   // data 0\n   logic [31:0]  data0_din;\n   logic         data0_reg_wren, data0_reg_wren0, data0_reg_wren1;\n   logic [pt.NUM_THREADS-1:0]  data0_reg_wren2;\n   // data 1\n   logic [31:0]  data1_din;\n   logic         data1_reg_wren, data1_reg_wren0, data1_reg_wren1;\n   // abstractcs\n   logic [pt.NUM_THREADS-1:0] abstractcs_busy;\n   logic [2:0]   abstractcs_error_din;\n   logic         abstractcs_error_sel0, abstractcs_error_sel1, abstractcs_error_sel2, abstractcs_error_sel3, abstractcs_error_sel4, abstractcs_error_sel5, abstractcs_error_sel6;\n   logic [pt.NUM_THREADS-1:0]  dbg_sb_bus_error;\n   // abstractauto\n   logic         abstractauto_reg_wren;\n   logic [1:0]   abstractauto_reg;\n   // dmcontrol\n   logic         resumereq;\n   logic         dmcontrol_wren, dmcontrol_wren_Q;\n   logic         dmcontrol_hasel_in, dmcontrol_hartsel_in;\n   // command\n   logic         execute_command_ns, execute_command;\n   logic         command_wren, command_regno_wren;\n   logic         command_transfer_din;\n   logic         command_postexec_din;\n   logic [31:0]  command_din;\n   logic [3:0]   dbg_cmd_addr_incr;\n   logic [31:0]  dbg_cmd_curr_addr;\n   logic [31:0]  dbg_cmd_next_addr;\n\n\n   // hawindow\n   logic         hawindow_wren;\n\n   // needed to send the read data back for dmi reads\n   logic [31:0]  dmi_reg_rdata_din;\n   logic [pt.NUM_THREADS-1:0] hart_sel;\n   logic [pt.NUM_THREADS-1:0] command_sel;\n   logic [pt.NUM_THREADS-1:0] dbg_halted;\n   logic [pt.NUM_THREADS-1:0] dbg_running;\n   logic [pt.NUM_THREADS-1:0] dbg_resumeack;\n   logic [pt.NUM_THREADS-1:0] dbg_havereset;\n   logic [pt.NUM_THREADS-1:0] dbg_unavailable;\n\n   sb_state_t    sb_state;\n   sb_state_t    sb_nxtstate;\n   logic         sb_state_en;\n\n   //System bus section\n   logic              sbcs_wren;\n   logic              sbcs_sbbusy_wren;\n   logic              sbcs_sbbusy_din;\n   logic              sbcs_sbbusyerror_wren;\n   logic              sbcs_sbbusyerror_din;\n\n   logic              sbcs_sberror_wren;\n   logic [2:0]        sbcs_sberror_din;\n   logic              sbcs_unaligned;\n   logic              sbcs_illegal_size;\n   logic [19:15]      sbcs_reg_int;\n\n   // data\n   logic              sbdata0_reg_wren0;\n   logic              sbdata0_reg_wren1;\n   logic              sbdata0_reg_wren;\n   logic [31:0]       sbdata0_din;\n\n   logic              sbdata1_reg_wren0;\n   logic              sbdata1_reg_wren1;\n   logic              sbdata1_reg_wren;\n   logic [31:0]       sbdata1_din;\n\n   logic              sbaddress0_reg_wren0;\n   logic              sbaddress0_reg_wren1;\n   logic              sbaddress0_reg_wren;\n   logic [31:0]       sbaddress0_reg_din;\n   logic [3:0]        sbaddress0_incr;\n   logic              sbreadonaddr_access;\n   logic              sbreadondata_access;\n   logic              sbdata0wr_access;\n\n   logic [pt.NUM_THREADS-1:0]  sb_abmem_cmd_done_in, sb_abmem_data_done_in;\n   logic [pt.NUM_THREADS-1:0]  sb_abmem_cmd_done_en, sb_abmem_data_done_en;\n   logic [pt.NUM_THREADS-1:0]  sb_abmem_cmd_done, sb_abmem_data_done;\n   logic [31:0]       abmem_addr;\n   logic              abmem_addr_in_dccm_region, abmem_addr_in_iccm_region, abmem_addr_in_pic_region;\n   logic              abmem_addr_core_local;\n   logic              abmem_addr_external;\n\n   logic              sb_cmd_pending, sb_abmem_cmd_pending;\n   logic              sb_abmem_cmd_write;\n   logic [2:0]        sb_abmem_cmd_size;\n   logic [31:0]       sb_abmem_cmd_addr;\n   logic [31:0]       sb_abmem_cmd_wdata;\n\n   logic [2:0]        sb_cmd_size;\n   logic [31:0]       sb_cmd_addr;\n   logic [63:0]       sb_cmd_wdata;\n\n   logic              sb_bus_cmd_read, sb_bus_cmd_write_addr, sb_bus_cmd_write_data;\n   logic              sb_bus_rsp_read, sb_bus_rsp_write;\n   logic              sb_bus_rsp_error;\n   logic [63:0]       sb_bus_rdata;\n\n   //registers\n   logic [31:0]       sbcs_reg;\n   logic [31:0]       sbaddress0_reg;\n   logic [31:0]       sbdata0_reg;\n   logic [31:0]       sbdata1_reg;\n\n   logic              dbg_dm_rst_l;\n   logic              rst_l_sync;\n\n   logic              sb_abmem_cmd_arvalid, sb_abmem_cmd_awvalid, sb_abmem_cmd_wvalid;\n   logic              sb_abmem_read_pend;\n   logic              sb_cmd_awvalid, sb_cmd_wvalid, sb_cmd_arvalid;\n   logic              sb_read_pend;\n   logic [31:0]       sb_axi_addr;\n   logic [63:0]       sb_axi_wrdata;\n   logic [2:0]        sb_axi_size;\n\n   //clken\n   logic              dbg_free_clken;\n   logic              dbg_free_clk;\n\n   logic              sb_free_clken;\n   logic              sb_free_clk;\n\n   logic              bus_clk;\n\n   // clocking\n   // used for the abstract commands.\n   always_comb begin\n      dbg_free_clken  = dmi_reg_en | clk_override;\n      for (int i=0; i<pt.NUM_THREADS; i++) begin\n         dbg_free_clken |= dec_tlu_dbg_halted[i] | dec_tlu_mpc_halted_only[i] | dec_tlu_debug_mode[i] | dbg_halt_req[i] | execute_command | dbg_state_en[i] | (dbg_state[i] != IDLE);\n      end\n   end\n\n   // used for the system bus\n   assign sb_free_clken = dmi_reg_en | execute_command | sb_state_en | (sb_state != SBIDLE) | clk_override;\n\n   rvoclkhdr dbg_free_cgc     (.en(dbg_free_clken), .l1clk(dbg_free_clk), .*);\n   rvoclkhdr sb_free_cgc     (.en(sb_free_clken), .l1clk(sb_free_clk), .*);\n\n   // end clocking section\n\n   // Reset logic\n   assign dbg_dm_rst_l = dbg_rst_l & (dmcontrol_reg[0] | scan_mode);\n   assign dbg_core_rst_l = ~dmcontrol_reg[1] | scan_mode;\n\n   // synchronize the rst\n   rvsyncss #(1) rstl_syncff (.din(rst_l), .dout(rst_l_sync), .clk(free_clk), .rst_l(dbg_rst_l));\n\n   // system bus register\n   // sbcs[31:29], sbcs - [22]:sbbusyerror, [21]: sbbusy, [20]:sbreadonaddr, [19:17]:sbaccess, [16]:sbautoincrement, [15]:sbreadondata, [14:12]:sberror, sbsize=32, 128=0, 64/32/16/8 are legal\n   assign        sbcs_reg[31:29] = 3'b1;\n   assign        sbcs_reg[28:23] = '0;\n   assign        sbcs_reg[19:15] = {sbcs_reg_int[19], ~sbcs_reg_int[18], sbcs_reg_int[17:15]};\n   assign        sbcs_reg[11:5]  = 7'h20;\n   assign        sbcs_reg[4:0]   = 5'b01111;\n   assign        sbcs_wren = (dmi_reg_addr ==  7'h38) & dmi_reg_en & dmi_reg_wr_en & (sb_state == SBIDLE); // & (sbcs_reg[14:12] == 3'b000);\n   assign        sbcs_sbbusyerror_wren = (sbcs_wren & dmi_reg_wdata[22]) |\n                                         (sbcs_reg[21] & dmi_reg_en & ((dmi_reg_wr_en & (dmi_reg_addr == 7'h39)) | (dmi_reg_addr == 7'h3c) | (dmi_reg_addr == 7'h3d)));\n   assign        sbcs_sbbusyerror_din = ~(sbcs_wren & dmi_reg_wdata[22]);   // Clear when writing one\n\n   rvdffs #(1) sbcs_sbbusyerror_reg  (.din(sbcs_sbbusyerror_din),  .dout(sbcs_reg[22]),    .en(sbcs_sbbusyerror_wren), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n   rvdffs #(1) sbcs_sbbusy_reg       (.din(sbcs_sbbusy_din),       .dout(sbcs_reg[21]),    .en(sbcs_sbbusy_wren),      .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n   rvdffs #(1) sbcs_sbreadonaddr_reg (.din(dmi_reg_wdata[20]),     .dout(sbcs_reg[20]),    .en(sbcs_wren),             .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n   rvdffs #(5) sbcs_misc_reg         (.din({dmi_reg_wdata[19],~dmi_reg_wdata[18],dmi_reg_wdata[17:15]}),\n                                      .dout(sbcs_reg_int[19:15]), .en(sbcs_wren),             .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n   rvdffs #(3) sbcs_error_reg        (.din(sbcs_sberror_din[2:0]), .dout(sbcs_reg[14:12]), .en(sbcs_sberror_wren),     .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n\n   assign sbcs_unaligned =    ((sbcs_reg[19:17] == 3'b001) &  sbaddress0_reg[0]) |\n                              ((sbcs_reg[19:17] == 3'b010) &  (|sbaddress0_reg[1:0])) |\n                              ((sbcs_reg[19:17] == 3'b011) &  (|sbaddress0_reg[2:0]));\n\n   assign sbcs_illegal_size = sbcs_reg[19];    // Anything bigger than 64 bits is illegal\n\n   assign sbaddress0_incr[3:0] = ({4{(sbcs_reg[19:17] == 3'h0)}} &  4'b0001) |\n                                 ({4{(sbcs_reg[19:17] == 3'h1)}} &  4'b0010) |\n                                 ({4{(sbcs_reg[19:17] == 3'h2)}} &  4'b0100) |\n                                 ({4{(sbcs_reg[19:17] == 3'h3)}} &  4'b1000);\n\n   // sbdata\n   assign        sbdata0_reg_wren0   = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h3c);   // write data only when single read is 0\n   assign        sbdata0_reg_wren1   = (sb_state == RSP_RD) & sb_state_en & ~sbcs_sberror_wren;\n   assign        sbdata0_reg_wren    = sbdata0_reg_wren0 | sbdata0_reg_wren1;\n\n   assign        sbdata1_reg_wren0   = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h3d);   // write data only when single read is 0;\n   assign        sbdata1_reg_wren1   = (sb_state == RSP_RD) & sb_state_en & ~sbcs_sberror_wren;\n   assign        sbdata1_reg_wren    = sbdata1_reg_wren0 | sbdata1_reg_wren1;\n\n   assign        sbdata0_din[31:0]   = ({32{sbdata0_reg_wren0}} & dmi_reg_wdata[31:0]) |\n                                       ({32{sbdata0_reg_wren1}} & sb_bus_rdata[31:0]);\n   assign        sbdata1_din[31:0]   = ({32{sbdata1_reg_wren0}} & dmi_reg_wdata[31:0]) |\n                                       ({32{sbdata1_reg_wren1}} & sb_bus_rdata[63:32]);\n\n   rvdffe #(32)    dbg_sbdata0_reg    (.*, .din(sbdata0_din[31:0]), .dout(sbdata0_reg[31:0]), .en(sbdata0_reg_wren), .rst_l(dbg_dm_rst_l));\n   rvdffe #(32)    dbg_sbdata1_reg    (.*, .din(sbdata1_din[31:0]), .dout(sbdata1_reg[31:0]), .en(sbdata1_reg_wren), .rst_l(dbg_dm_rst_l));\n\n    // sbaddress\n   assign        sbaddress0_reg_wren0   = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h39);\n   assign        sbaddress0_reg_wren    = sbaddress0_reg_wren0 | sbaddress0_reg_wren1;\n   assign        sbaddress0_reg_din[31:0]= ({32{sbaddress0_reg_wren0}} & dmi_reg_wdata[31:0]) |\n                                           ({32{sbaddress0_reg_wren1}} & (sbaddress0_reg[31:0] + {28'b0,sbaddress0_incr[3:0]}));\n   rvdffe #(32)    dbg_sbaddress0_reg    (.*, .din(sbaddress0_reg_din[31:0]), .dout(sbaddress0_reg[31:0]), .en(sbaddress0_reg_wren), .rst_l(dbg_dm_rst_l));\n\n   assign sbreadonaddr_access = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h39) & sbcs_reg[20];   // if readonaddr is set the next command will start upon writing of addr0\n   assign sbreadondata_access = dmi_reg_en & ~dmi_reg_wr_en & (dmi_reg_addr == 7'h3c) & sbcs_reg[15];  // if readondata is set the next command will start upon reading of data0\n   assign sbdata0wr_access  = dmi_reg_en &  dmi_reg_wr_en & (dmi_reg_addr == 7'h3c);                   // write to sbdata0 will start write command to system bus\n\n   // memory mapped registers\n   // dmcontrol register has only 6 bits implemented. 31: haltreq, 30: resumereq, 28: ackhavereset, 26: hasel, 6:hartsel, 1: ndmreset, 0: dmactive.\n   // rest all the bits are zeroed out\n   // dmactive flop is reset based on core rst_l, all other flops use dm_rst_l\n   assign dmcontrol_wren      = (dmi_reg_addr ==  7'h10) & dmi_reg_en & dmi_reg_wr_en;\n   assign dmcontrol_reg[29]   = '0;\n   assign dmcontrol_reg[27]   = '0;\n   assign dmcontrol_reg[25:17] = '0;\n   assign dmcontrol_reg[15:2]  = '0;\n   assign dmcontrol_hasel_in  = (pt.NUM_THREADS > 1) & dmi_reg_wdata[26];   // hasel tied to 0 for single thread\n   assign dmcontrol_hartsel_in = (pt.NUM_THREADS > 1) & dmi_reg_wdata[16];   // hartsel tied to 0 for single thread\n   assign resumereq           = dmcontrol_reg[30] & ~dmcontrol_reg[31] & dmcontrol_wren_Q;\n   rvdffs #(6) dmcontrolff (.din({dmi_reg_wdata[31:30],dmi_reg_wdata[28],dmcontrol_hasel_in,dmcontrol_hartsel_in,dmi_reg_wdata[1]}),\n                            .dout({dmcontrol_reg[31:30],dmcontrol_reg[28],dmcontrol_reg[26],dmcontrol_reg[16],dmcontrol_reg[1]}), .en(dmcontrol_wren), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n   rvdffs #(1) dmcontrol_dmactive_ff (.din(dmi_reg_wdata[0]), .dout(dmcontrol_reg[0]), .en(dmcontrol_wren), .rst_l(dbg_rst_l), .clk(dbg_free_clk));\n   rvdff  #(1) dmcontrol_wrenff(.din(dmcontrol_wren), .dout(dmcontrol_wren_Q), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n\n   // dmstatus register bits that are implemented\n   // [19:18]-havereset,[17:16]-resume ack, [15:14]-available, [9]-allhalted, [8]-anyhalted, [3:0]-version\n   // rest all the bits are zeroed out\n   assign dmstatus_reg[31:20] = '0;\n   assign dmstatus_reg[19]    = &(dbg_havereset[pt.NUM_THREADS-1:0] | ~hart_sel[pt.NUM_THREADS-1:0]);\n   assign dmstatus_reg[18]    = |(dbg_havereset[pt.NUM_THREADS-1:0] & hart_sel[pt.NUM_THREADS-1:0]);\n   assign dmstatus_reg[17]    = &(dbg_resumeack[pt.NUM_THREADS-1:0] | ~hart_sel[pt.NUM_THREADS-1:0]);\n   assign dmstatus_reg[16]    = |(dbg_resumeack[pt.NUM_THREADS-1:0] & hart_sel[pt.NUM_THREADS-1:0]);\n   assign dmstatus_reg[15:14] = '0;\n   assign dmstatus_reg[13]    = &(dbg_unavailable[pt.NUM_THREADS-1:0] | ~hart_sel[pt.NUM_THREADS-1:0]);\n   assign dmstatus_reg[12]    = |(dbg_unavailable[pt.NUM_THREADS-1:0] & hart_sel[pt.NUM_THREADS-1:0]);\n   assign dmstatus_reg[11]    = &(dbg_running[pt.NUM_THREADS-1:0] | ~hart_sel[pt.NUM_THREADS-1:0]);\n   assign dmstatus_reg[10]    = |(dbg_running[pt.NUM_THREADS-1:0] & hart_sel[pt.NUM_THREADS-1:0]);\n   assign dmstatus_reg[9]     = &(dbg_halted[pt."}
{"text": "NUM_THREADS-1:0] | ~hart_sel[pt.NUM_THREADS-1:0]);\n   assign dmstatus_reg[8]     = |(dbg_halted[pt.NUM_THREADS-1:0] & hart_sel[pt.NUM_THREADS-1:0]);\n   assign dmstatus_reg[7]     = '1;\n   assign dmstatus_reg[6:4]   = '0;\n   assign dmstatus_reg[3:0]   = 4'h2;\n\n   // haltsum0 register\n   assign haltsum0_reg[31:pt.NUM_THREADS] = '0;\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin: Gen_haltsum\n      assign haltsum0_reg[i]  = dbg_halted[i];\n   end\n\n   // abstractcs register\n   // bits implemted are [12] - busy and [10:8]= command error\n   assign        abstractcs_reg[31:13] = '0;\n   assign        abstractcs_reg[11]    = '0;\n   assign        abstractcs_reg[7:4]   = '0;\n   assign        abstractcs_reg[3:0]   = 4'h2;    // One data register\n\n\n   assign        abstractcs_error_sel0 = abstractcs_reg[12] & ~(|abstractcs_reg[10:8]) & dmi_reg_en & ((dmi_reg_wr_en & ((dmi_reg_addr == 7'h16) | (dmi_reg_addr == 7'h17)) | (dmi_reg_addr == 7'h18)) |\n                                                                                                       (dmi_reg_addr == 7'h4) | (dmi_reg_addr == 7'h5));\n   assign        abstractcs_error_sel1 = execute_command & ~(|abstractcs_reg[10:8]) &\n                                         ((~((command_reg[31:24] == 8'b0) | (command_reg[31:24] == 8'h2)))                      |   // Illegal command\n                                          (((command_reg[22:20] == 3'b011) | (command_reg[22])) & (command_reg[31:24] == 8'h2)) |   // Illegal abstract memory size (can't be DW or higher)\n                                          ((command_reg[22:20] != 3'b010) & ((command_reg[31:24] == 8'h0) & command_reg[17]))   |   // Illegal abstract reg size\n                                          ((command_reg[31:24] == 8'h0) & command_reg[18]));                                          //postexec for abstract register access\n   assign        abstractcs_error_sel2 = ((core_dbg_cmd_done & core_dbg_cmd_fail) |                   // exception from core\n                                          (execute_command & (command_reg[31:24] == 8'h0) &           // unimplemented regs\n                                                (((command_reg[15:12] == 4'h1) & (command_reg[11:5] != 0)) | (command_reg[15:13] != 0)))) & ~(|abstractcs_reg[10:8]);\n   assign        abstractcs_error_sel3 = execute_command & ~(|abstractcs_reg[10:8]) & ~(|(command_sel[pt.NUM_THREADS-1:0] & dbg_halted[pt.NUM_THREADS-1:0]));  //(dbg_state != HALTED);;\n   assign        abstractcs_error_sel4 = (|dbg_sb_bus_error[pt.NUM_THREADS-1:0]) & dbg_bus_clk_en & ~(|abstractcs_reg[10:8]);// sb bus error for abstract memory command\n   assign        abstractcs_error_sel5 = execute_command & (command_reg[31:24] == 8'h2) & ~(|abstractcs_reg[10:8]) &\n                                         (((command_reg[22:20] == 3'b001) & data1_reg[0]) | ((command_reg[22:20] == 3'b010) & (|data1_reg[1:0])));  //Unaligned address for abstract memory\n   assign        abstractcs_error_sel6 = (dmi_reg_addr ==  7'h16) & dmi_reg_en & dmi_reg_wr_en;\n\n   assign        abstractcs_error_din[2:0]  = abstractcs_error_sel0 ? 3'b001 :                  // writing command or abstractcs while a command was executing. Or accessing data0\n                                                 abstractcs_error_sel1 ? 3'b010 :               // writing a illegal command type to cmd field of command\n                                                    abstractcs_error_sel2 ? 3'b011 :            // exception while running command\n                                                       abstractcs_error_sel3 ? 3'b100 :         // writing a comnand when not in the halted state\n                                                          abstractcs_error_sel4 ? 3'b101 :      // Bus error\n                                                             abstractcs_error_sel5 ? 3'b111 :   // unaligned or illegal size abstract memory command\n                                                                abstractcs_error_sel6 ? (~dmi_reg_wdata[10:8] & abstractcs_reg[10:8]) :   //W1C\n                                                                                        abstractcs_reg[10:8];                             //hold\n\n   assign abstractcs_reg[12] = |abstractcs_busy[pt.NUM_THREADS-1:0];\n\n   rvdff  #(3) dmabstractcs_error_reg (.din(abstractcs_error_din[2:0]), .dout(abstractcs_reg[10:8]), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n\n    // abstract auto reg\n   assign abstractauto_reg_wren  = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h18) & ~abstractcs_reg[12];\n   rvdffs #(2) dbg_abstractauto_reg (.*, .din(dmi_reg_wdata[1:0]), .dout(abstractauto_reg[1:0]), .en(abstractauto_reg_wren), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n\n   // command register - implemented all the bits in this register\n   // command[16] = 1: write, 0: read\n   assign execute_command_ns = command_wren |\n                               (dmi_reg_en & ~abstractcs_reg[12] & (((dmi_reg_addr == 7'h4) & abstractauto_reg[0]) | ((dmi_reg_addr == 7'h5) & abstractauto_reg[1])));\n   always_comb begin\n      command_wren = 1'b0;\n      for (int i=0; i<pt.NUM_THREADS; i++) begin\n         command_wren |= ((dmi_reg_addr == 7'h17) & dmi_reg_en & dmi_reg_wr_en & command_sel[i]);\n      end\n   end\n   assign command_regno_wren = command_wren | ((command_reg[31:24] == 8'h0) & command_reg[19] & (dbg_state == CMD_DONE) & ~(|abstractcs_reg[10:8]));  // aarpostincrement\n   assign command_postexec_din = (dmi_reg_wdata[31:24] == 8'h0) & dmi_reg_wdata[18];\n   assign command_transfer_din = (dmi_reg_wdata[31:24] == 8'h0) & dmi_reg_wdata[17];\n   assign command_din[31:16] = {dmi_reg_wdata[31:24],1'b0,dmi_reg_wdata[22:19],command_postexec_din,command_transfer_din, dmi_reg_wdata[16]};\n   assign command_din[15:0] =  command_wren ? dmi_reg_wdata[15:0] : dbg_cmd_next_addr[15:0];\n   rvdff  #(1)  execute_commandff   (.*, .din(execute_command_ns), .dout(execute_command), .clk(dbg_free_clk), .rst_l(dbg_dm_rst_l));\n   rvdffe #(16) dmcommand_reg       (.*, .din(command_din[31:16]), .dout(command_reg[31:16]), .en(command_wren), .rst_l(dbg_dm_rst_l));\n   rvdffe #(16) dmcommand_regno_reg (.*, .din(command_din[15:0]),  .dout(command_reg[15:0]),  .en(command_regno_wren), .rst_l(dbg_dm_rst_l));\n\n   // hawindow reg\n   assign hawindow_wren = dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h15);\n   assign hawindow_reg[31:pt.NUM_THREADS] = '0;\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin: GenHAWindow\n      rvdffs #(1) dbg_hawindow_reg (.*, .din(dmi_reg_wdata[i]), .dout(hawindow_reg[i]), .en(hawindow_wren), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n   end\n\n   // data0 reg\n   always_comb begin\n      data0_reg_wren0 = 1'b0;\n      data0_reg_wren1 = 1'b0;\n      for (int i=0; i<pt.NUM_THREADS; i++) begin\n         data0_reg_wren0   |= (dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h4) & command_sel[i] & (dbg_state[i] == HALTED) & ~abstractcs_reg[12]);\n         data0_reg_wren1   |= (core_dbg_cmd_done & (dbg_state[i] == CORE_CMD_WAIT) & ~command_reg[16]);\n      end\n   end\n   assign data0_reg_wren    = data0_reg_wren0 | data0_reg_wren1 | (|data0_reg_wren2[pt.NUM_THREADS-1:0]);\n\n   assign data0_din[31:0]   = ({32{data0_reg_wren0}} & dmi_reg_wdata[31:0])   |\n                              ({32{data0_reg_wren1}} & core_dbg_rddata[31:0]) |\n                              ({32{|data0_reg_wren2}} & sb_bus_rdata[31:0]);\n\n   rvdffe #(32) dbg_data0_reg (.*, .din(data0_din[31:0]), .dout(data0_reg[31:0]), .en(data0_reg_wren), .rst_l(dbg_dm_rst_l));\n\n   // data 1\n   always_comb begin\n      data1_reg_wren0 = 1'b0;\n      data1_reg_wren1 = 1'b0;\n      for (int i=0; i<pt.NUM_THREADS; i++) begin\n         data1_reg_wren0   |= (dmi_reg_en & dmi_reg_wr_en & (dmi_reg_addr == 7'h5) & command_sel[i] & (dbg_state[i] == HALTED));\n         data1_reg_wren1   |= ((dbg_state[i] == CMD_DONE) & (command_reg[31:24] == 8'h2) & command_reg[19] & ~(|abstractcs_reg[10:8]));   // aampostincrement\n      end\n   end\n   assign data1_reg_wren    = data1_reg_wren0 | data1_reg_wren1;\n\n   assign data1_din[31:0]   = ({32{data1_reg_wren0}} & dmi_reg_wdata[31:0]) |\n                              ({32{data1_reg_wren1}} & dbg_cmd_next_addr[31:0]);\n\n   rvdffe #(32)    dbg_data1_reg    (.*, .din(data1_din[31:0]), .dout(data1_reg[31:0]), .en(data1_reg_wren), .rst_l(dbg_dm_rst_l));\n\n   // Generate the per thread sel and state\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n\n      logic [pt.NUM_THREADS-1:0] dbg_resumeack_wren, dbg_resumeack_din;\n      logic [pt.NUM_THREADS-1:0] dbg_haveresetn_wren, dbg_haveresetn;\n      logic [pt.NUM_THREADS-1:0] abstractcs_busy_wren, abstractcs_busy_din;\n\n      assign hart_sel[i] = (dmcontrol_reg[16] == 1'(i)) | (dmcontrol_reg[26] & hawindow_reg[i]);\n      assign command_sel[i] = (dmcontrol_reg[16] == 1'(i));\n\n      // Per thread halted/resumeack/havereset signal\n      assign dbg_resumeack_wren[i] = ((dbg_state[i] == RESUMING) & dec_tlu_resume_ack[i]) | (dbg_resumeack[i] & resumereq & dbg_halted[i] & hart_sel[i]);\n      assign dbg_resumeack_din[i]  = (dbg_state[i] == RESUMING) & dec_tlu_resume_ack[i];\n\n      assign dbg_haveresetn_wren[i] = (dmi_reg_addr == 7'h10) & dmi_reg_wdata[28] & dmi_reg_en & dmi_reg_wr_en & ((dmi_reg_wdata[16] == 1'(i)) | (dmi_reg_wdata[26] & hawindow_reg[i])) & dmcontrol_reg[0];\n      assign dbg_havereset[i]      = ~dbg_haveresetn[i];\n\n      assign dbg_unavailable[i] = ~rst_l_sync | dmcontrol_reg[1] | ~dec_tlu_mhartstart[i];\n      assign dbg_running[i]     = ~(dbg_unavailable[i] | dbg_halted[i]);\n\n      rvdff  #(1) dbg_halted_reg       (.din(dec_tlu_dbg_halted[i] & ~dec_tlu_mpc_halted_only[i]), .dout(dbg_halted[i]), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n      rvdffs #(1) dbg_resumeack_reg    (.din(dbg_resumeack_din[i]), .dout(dbg_resumeack[i]), .en(dbg_resumeack_wren[i]), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n      rvdffs #(1) dbg_haveresetn_reg   (.din(1'b1), .dout(dbg_haveresetn[i]), .en(dbg_haveresetn_wren[i]), .rst_l(rst_l), .clk(dbg_free_clk));\n      rvdffs #(1) abstractcs_busy_reg  (.din(abstractcs_busy_din[i]), .dout(abstractcs_busy[i]), .en(abstractcs_busy_wren[i]), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk));\n      rvdffs #($bits(state_t)) dbg_state_reg    (.din(dbg_nxtstate[i]), .dout({dbg_state[i]}), .en(dbg_state_en[i]), .rst_l(dbg_dm_rst_l & rst_l), .clk(dbg_free_clk));\n      rvdffs #(1) sb_abmem_cmd_doneff  (.din(sb_abmem_cmd_done_in[i]),  .dout(sb_abmem_cmd_done[i]),  .en(sb_abmem_cmd_done_en[i]),  .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk), .*);\n      rvdffs #(1) sb_abmem_data_doneff (.din(sb_abmem_data_done_in[i]), .dout(sb_abmem_data_done[i]), .en(sb_abmem_data_done_en[i]), .rst_l(dbg_dm_rst_l), .clk(dbg_free_clk), .*);\n\n      // FSM to control the debug mode entry, command send/recieve, and Resume flow.\n      always_comb begin\n         dbg_nxtstate[i]         = IDLE;\n         dbg_state_en[i]         = 1'b0;\n         abstractcs_busy_wren    = 1'b0;\n         abstractcs_busy_din     = 1'b0;\n         dbg_halt_req[i]   = dmcontrol_wren_Q & dmcontrol_reg[31] & hart_sel[i];      // single pulse output to the core. Need to drive every time this register is written since core might be halted due to MPC\n         dbg_resume_req[i] = 1'b0;                                                                        // single pulse output to the core\n         dbg_sb_bus_error[i]     = 1'b0;\n         data0_reg_wren2[i]      = 1'b0;\n         sb_abmem_cmd_done_in[i] = 1'b0;\n         sb_abmem_data_done_in[i]= 1'b0;\n         sb_abmem_cmd_done_en[i] = 1'b0;\n         sb_abmem_data_done_en[i]= 1'b0;\n\n\n         case (dbg_state[i])\n            IDLE: begin\n                     dbg_nxtstate[i]      = (dbg_halted[i] | dec_tlu_mpc_halted_only[i]) ? HALTED : HALTING;         // initiate the halt command to the core\n                     dbg_state_en[i]      = (dmcontrol_reg[31] & hart_sel[i]) | dbg_halted[i] | dec_tlu_mpc_halted_only[i];      // when the jtag writes the halt bit in the DM register, OR when the status indicates MPC halted\n                     dbg_halt_req[i]       = dmcontrol_reg[31] & hart_sel[i];      // only when jtag has written the halt_req bit in the control. Removed debug mode qualification during MPC changes\n            end\n            HALTING : begin\n                     dbg_nxtstate[i]      = HALTED;                                       // Goto HALTED once the core sends an ACK\n                     dbg_state_en[i]      = dbg_halted[i] | dec_tlu_mpc_halted_only[i];   // core indicates halted\n            end\n            HALTED: begin\n                     // wait for halted to go away before send to resume. Else start of new command\n                      dbg_nxtstate[i]      = dbg_halted[i] ? ((resumereq & hart_sel[i]) ? RESUMING :\n                                                                 (((command_reg[31:24] == 8'h2) & abmem_addr_external & hart_sel[i]) ? SB_CMD_START : CORE_CMD_START)) :\n                                                                                   ((dmcontrol_reg[31] & hart_sel[i]) ? HALTING : IDLE);       // This is MPC halted case\n                     dbg_state_en[i]      = (dbg_halted[i] & resumereq & hart_sel[i]) | (execute_command & command_sel[i]) | ~(dbg_halted[i] | dec_tlu_mpc_halted_only[i]);         // need to be exclusive ???\n                     abstractcs_busy_wren[i] = dbg_state_en[i] & ((dbg_nxtstate[i] == CORE_CMD_START) | (dbg_nxtstate[i] == SB_CMD_START));                      // write busy when a new command was written by jtag\n                     abstractcs_busy_din[i]  = 1'b1;\n                     dbg_resume_req[i] = dbg_state_en[i] & (dbg_nxtstate[i] == RESUMING);                       // single cycle pulse to core if resuming\n            end\n            CORE_CMD_START: begin\n                     // Don't execute the command if cmderror or transfer=0 for abstract register access\n                     dbg_nxtstate[i]      = ((|abstractcs_reg[10:8]) | ((command_reg[31:24] == 8'h0) & ~command_reg[17])) ? CMD_DONE : CORE_CMD_WAIT;     // new command sent to the core\n                     dbg_state_en[i]      = dbg_cmd_valid | (|abstractcs_reg[10:8]) | ((command_reg[31:24] == 8'h0) & ~command_reg[17]);\n            end\n            CORE_CMD_WAIT: begin\n                     dbg_nxtstate[i]      = CMD_DONE;\n                     dbg_state_en[i]      = core_dbg_cmd_done;                   // go to done state for one cycle after completing current command\n            end\n            SB_CMD_START: begin\n                     dbg_nxtstate[i]      = (|abstractcs_reg[10:8]) ? CMD_DONE : SB_CMD_SEND;\n                     dbg_state_en[i]      = (dbg_bus_clk_en & ~sb_cmd_pending) | (|abstractcs_reg[10:8]);\n            end\n            SB_CMD_SEND: begin\n                     sb_abmem_cmd_done_in[i]  = 1'b1;\n                     sb_abmem_data_done_in[i] = 1'b1;\n                     sb_abmem_cmd_done_en[i]  = (sb_bus_cmd_read | sb_bus_cmd_write_addr) & dbg_bus_clk_en;\n                     sb_abmem_data_done_en[i] = (sb_bus_cmd_read | sb_bus_cmd_write_data) & dbg_bus_clk_en;\n                     dbg_nxtstate[i]          = SB_CMD_RESP;\n                     dbg_state_en[i]          = (sb_abmem_cmd_done[i] | sb_abmem_cmd_done_en[i]) & (sb_abmem_data_done[i] | sb_abmem_data_done_en[i]) & dbg_bus_clk_en;\n            end\n            SB_CMD_RESP: begin\n                     dbg_nxtstate[i]         = CMD_DONE;\n                     dbg_state_en[i]         = (sb_bus_rsp_read | sb_bus_rsp_write) & dbg_bus_clk_en;\n                     dbg_sb_bus_error[i]     = (sb_bus_rsp_read | sb_bus_rsp_write) & sb_bus_rsp_error & dbg_bus_clk_en;\n                     data0_reg_wren2[i]      = dbg_state_en[i] & ~sb_abmem_cmd_write & ~dbg_sb_bus_error[i];\n            end\n            CMD_DONE: begin\n                     dbg_nxtstate[i]         = HALTED;\n                     dbg_state_en[i]         = 1'b1;\n                     abstractcs_busy_wren[i] = dbg_state_en[i];                    // remove the busy bit from the abstracts ( bit 12 )\n                     abstractcs_busy_din[i]  = 1'b0;\n                     sb_abmem_cmd_done_in[i] = 1'b0;\n                     sb_abmem_data_done_in[i]= 1'b0;\n                     sb_abmem_cmd_done_en[i] = 1'b1;\n                     sb_abmem_data_done_en[i]= 1'b1;\n            end\n            RESUMING : begin\n                     dbg_nxtstate[i]      = IDLE;\n                     dbg_state_en[i]      = dbg_resumeack[i];\n            end\n            default : begin\n                     dbg_nxtstate[i]         = IDLE;\n                     dbg_state_en[i]         = 1'b0;\n                     abstractcs_busy_wren[i] = 1'b0;\n                     abstractcs_busy_din[i]  = 1'b0;\n                     dbg_halt_req[i]         = 1'b0;         // single pulse output to the core\n                     dbg_resume_req[i]       = 1'b0;         // single pulse output to the core\n                     dbg_sb_bus_error[i]     = 1'b0;\n                     data0_reg_wren2[i]      = 1'b0;\n                     sb_abmem_cmd_done_in[i] = 1'b0;\n                     sb_abmem_data_done_in[i]= 1'b0;\n                     sb_abmem_cmd_done_en[i] = 1'b0;\n                     sb_abmem_data_done_en[i]= 1'b0;\n\n           end\n         endcase\n      end // always_comb begin\n   end // for (genvar i=0; i<pt.NUM_THREADS; i++)\n\n   assign dmi_reg_rdata_din[31:0] = ({32{dmi_reg_addr == 7'h4}}  & data0_reg[31:0])      |\n                                    ({32{dmi_reg_addr == 7'h5}}  & data1_reg[31:0])      |\n                                    ({32{dmi_reg_addr == 7'h10}} & {2'b0,dmcontrol_reg[29],1'b0,dmcontrol_reg[27:0]})  |  // Read0 to Write only bits\n                                    ({32{dmi_reg_addr == 7'h11}} & dmstatus_reg[31:0])   |\n                                    ({32{dmi_reg_addr == 7'h15}} & hawindow_reg[31:0]) |\n                                    ({32{dmi_reg_addr == 7'h16}} & abstractcs_reg[31:0]) |\n                                    ({32{dmi_reg_addr == 7'h17}} & command_reg[31:0])    |\n                                    ({32{dmi_reg_addr == 7'h18}} & {30'h0,abstractauto_reg[1:0]})    |\n                                    ({32{dmi_reg_addr == 7'h40}} & haltsum0_reg[31:0])   |\n                                    ({32{dmi_reg_addr == 7'h38}} & sbcs_reg[31:0])       |\n                                    ({32{dmi_reg_addr == 7'h39}} & sbaddress0_reg[31:0]) |\n                                    ({32{dmi_reg_addr == 7'h3c}} & sbdata0_reg[31:0])    |\n                                    ({32{dmi_reg_addr == 7'h3d}} & sbdata1_reg[31:0]);\n\n\n   // Ack will use the power on reset only otherwise there won't be any ack until dmactive is 1\n   rvdffe #(32)             dmi_rddata_reg   (.din(dmi_reg_rdata_din[31:0]), .dout(dmi_reg_rdata[31:0]), .en(dmi_reg_en), .rst_l(dbg_dm_rst_l), .clk(clk), .*);\n\n   assign abmem_addr[31:0]      = data1_reg[31:0];\n   assign abmem_addr_core_local = (abmem_addr_in_dccm_region | abmem_addr_in_iccm_region | abmem_addr_in_pic_region);\n   assign abmem_addr_external   = ~abmem_addr_core_local;\n\n   assign abmem_addr_in_dccm_region = (abmem_addr[31:28] == pt.DCCM_REGION) & pt.DCCM_ENABLE;\n   assign abmem_addr_in_iccm_region = (abmem_addr[31:28] == pt.ICCM_REGION) & pt.ICCM_ENABLE;\n   assign abmem_addr_in_pic_region  = (abmem_addr[31:28] == pt.PIC_REGION);\n\n   // interface for the core\n   assign dbg_cmd_addr[31:0]    = (command_reg[31:24] == 8'h2) ? data1_reg[31:0]  : {20'b0, command_reg[11:0]};\n   assign dbg_cmd_wrdata[31:0]  = data0_reg[31:0];\n   always_comb begin\n      dbg_cmd_valid = 1'b0;\n      for (int i=0; i<pt.NUM_THREADS; i++) begin\n         dbg_cmd_valid  |= (dbg_state[i] == CORE_CMD_START) & ~((|abstractcs_reg[10:8]) | ((command_reg[31:24] == 8'h0) & ~command_reg[17]) | ((command_reg[31:24] == 8'h2) & abmem_addr_external)) &\n                           ~((command_reg[31:24] == 8'h2) & ~dma_dbg_ready);\n      end\n   end\n   assign dbg_cmd_tid           = dmcontrol_reg[16];\n   assign dbg_cmd_write         = command_reg[16];\n   assign dbg_cmd_type[1:0]     = (command_"}
{"text": "reg[31:24] == 8'h2) ? 2'b10 : {1'b0, (command_reg[15:12] == 4'b0)};\n   assign dbg_cmd_size[1:0]     = command_reg[21:20];\n\n   assign dbg_cmd_addr_incr[3:0]  = (command_reg[31:24] == 8'h2) ? (4'h1 << sb_abmem_cmd_size[1:0]) : 4'h1;\n   assign dbg_cmd_curr_addr[31:0] = (command_reg[31:24] == 8'h2) ? data1_reg[31:0]  : {16'b0, command_reg[15:0]};\n   assign dbg_cmd_next_addr[31:0] = dbg_cmd_curr_addr[31:0] + {28'h0,dbg_cmd_addr_incr[3:0]};\n\n   // Ask DMA to stop taking bus trxns since debug memory request is done\n   always_comb begin\n      dbg_dma_bubble = 1'b0;\n      for (int i=0; i<pt.NUM_THREADS; i++) begin\n         dbg_dma_bubble     |= ((((dbg_state[i] == CORE_CMD_START) & ~(|abstractcs_reg[10:8])) | (dbg_state[i] == CORE_CMD_WAIT)) & (command_reg[31:24] == 8'h2));\n      end\n   end\n\n   assign sb_cmd_pending       = (sb_state == CMD_RD) | (sb_state == CMD_WR) | (sb_state == CMD_WR_ADDR) | (sb_state == CMD_WR_DATA) | (sb_state == RSP_RD) | (sb_state == RSP_WR);\n   assign sb_abmem_cmd_pending = (dbg_state == SB_CMD_START) | (dbg_state == SB_CMD_SEND) | (dbg_state== SB_CMD_RESP);\n\n  // system bus FSM\n  always_comb begin\n      sb_nxtstate            = SBIDLE;\n      sb_state_en            = 1'b0;\n      sbcs_sbbusy_wren       = 1'b0;\n      sbcs_sbbusy_din        = 1'b0;\n      sbcs_sberror_wren      = 1'b0;\n      sbcs_sberror_din[2:0]  = 3'b0;\n      sbaddress0_reg_wren1   = 1'b0;\n      case (sb_state)\n            SBIDLE: begin\n                     sb_nxtstate            = sbdata0wr_access ? WAIT_WR : WAIT_RD;\n                     sb_state_en            = (sbdata0wr_access | sbreadondata_access | sbreadonaddr_access) & ~(|sbcs_reg[14:12]) & ~sbcs_reg[22];\n                     sbcs_sbbusy_wren       = sb_state_en;                                                 // set the single read bit if it is a singlread command\n                     sbcs_sbbusy_din        = 1'b1;\n                     sbcs_sberror_wren      = sbcs_wren & (|dmi_reg_wdata[14:12]);                                            // write to clear the error bits\n                     sbcs_sberror_din[2:0]  = ~dmi_reg_wdata[14:12] & sbcs_reg[14:12];\n            end\n            WAIT_RD: begin\n                     sb_nxtstate           = (sbcs_unaligned | sbcs_illegal_size) ? DONE : CMD_RD;\n                     sb_state_en           = (dbg_bus_clk_en & ~sb_abmem_cmd_pending) | sbcs_unaligned | sbcs_illegal_size;\n                     sbcs_sberror_wren     = sbcs_unaligned | sbcs_illegal_size;\n                     sbcs_sberror_din[2:0] = sbcs_unaligned ? 3'b011 : 3'b100;\n            end\n            WAIT_WR: begin\n                     sb_nxtstate           = (sbcs_unaligned | sbcs_illegal_size) ? DONE : CMD_WR;\n                     sb_state_en           = (dbg_bus_clk_en & ~sb_abmem_cmd_pending) | sbcs_unaligned | sbcs_illegal_size;\n                     sbcs_sberror_wren     = sbcs_unaligned | sbcs_illegal_size;\n                     sbcs_sberror_din[2:0] = sbcs_unaligned ? 3'b011 : 3'b100;\n            end\n            CMD_RD : begin\n                     sb_nxtstate           = RSP_RD;\n                     sb_state_en           = sb_bus_cmd_read & dbg_bus_clk_en;\n            end\n            CMD_WR : begin\n                     sb_nxtstate           = (sb_bus_cmd_write_addr & sb_bus_cmd_write_data) ? RSP_WR : (sb_bus_cmd_write_data ? CMD_WR_ADDR : CMD_WR_DATA);\n                     sb_state_en           = (sb_bus_cmd_write_addr | sb_bus_cmd_write_data) & dbg_bus_clk_en;\n            end\n            CMD_WR_ADDR : begin\n                     sb_nxtstate           = RSP_WR;\n                     sb_state_en           = sb_bus_cmd_write_addr & dbg_bus_clk_en;\n            end\n            CMD_WR_DATA : begin\n                     sb_nxtstate           = RSP_WR;\n                     sb_state_en           = sb_bus_cmd_write_data & dbg_bus_clk_en;\n            end\n            RSP_RD: begin\n                     sb_nxtstate           = DONE;\n                     sb_state_en           = sb_bus_rsp_read & dbg_bus_clk_en;\n                     sbcs_sberror_wren     = sb_state_en & sb_bus_rsp_error;\n                     sbcs_sberror_din[2:0] = 3'b010;\n            end\n            RSP_WR: begin\n                     sb_nxtstate           = DONE;\n                     sb_state_en           = sb_bus_rsp_write & dbg_bus_clk_en;\n                     sbcs_sberror_wren     = sb_state_en & sb_bus_rsp_error;\n                     sbcs_sberror_din[2:0] = 3'b010;\n            end\n            DONE: begin\n                     sb_nxtstate            = SBIDLE;\n                     sb_state_en            = 1'b1;\n                     sbcs_sbbusy_wren       = 1'b1;                           // reset the single read\n                     sbcs_sbbusy_din        = 1'b0;\n                     sbaddress0_reg_wren1   = sbcs_reg[16] & (sbcs_reg[14:12] == 3'b0);    // auto increment was set and no error. Update to new address after completing the current command\n            end\n            default : begin\n                     sb_nxtstate            = SBIDLE;\n                     sb_state_en            = 1'b0;\n                     sbcs_sbbusy_wren       = 1'b0;\n                     sbcs_sbbusy_din        = 1'b0;\n                     sbcs_sberror_wren      = 1'b0;\n                     sbcs_sberror_din[2:0]  = 3'b0;\n                     sbaddress0_reg_wren1   = 1'b0;\n           end\n         endcase\n   end // always_comb begin\n\n   rvdffs #($bits(sb_state_t)) sb_state_reg (.din(sb_nxtstate), .dout({sb_state}), .en(sb_state_en), .rst_l(dbg_dm_rst_l), .clk(sb_free_clk));\n\n   assign sb_abmem_cmd_write      = command_reg[16];\n   assign sb_abmem_cmd_size[2:0]  = {1'b0, command_reg[21:20]};\n   assign sb_abmem_cmd_addr[31:0] = abmem_addr[31:0];\n   assign sb_abmem_cmd_wdata[31:0] = data0_reg[31:0];\n\n   assign sb_cmd_size[2:0]   = sbcs_reg[19:17];\n   assign sb_cmd_wdata[63:0] = {sbdata1_reg[31:0], sbdata0_reg[31:0]};\n   assign sb_cmd_addr[31:0]  = sbaddress0_reg[31:0];\n\n   always_comb begin\n      sb_abmem_cmd_awvalid = 1'b0;\n      sb_abmem_cmd_wvalid  = 1'b0;\n      sb_abmem_cmd_arvalid = 1'b0;\n      sb_abmem_read_pend   = 1'b0;\n      for (int i=0; i<pt.NUM_THREADS; i++) begin\n         sb_abmem_cmd_awvalid    |= (dbg_state[i] == SB_CMD_SEND) & sb_abmem_cmd_write & ~sb_abmem_cmd_done[i];\n         sb_abmem_cmd_wvalid     |= (dbg_state[i] == SB_CMD_SEND) & sb_abmem_cmd_write & ~sb_abmem_data_done[i];\n         sb_abmem_cmd_arvalid    |= (dbg_state[i] == SB_CMD_SEND) & ~sb_abmem_cmd_write & ~sb_abmem_cmd_done[i] & ~sb_abmem_data_done[i];\n         sb_abmem_read_pend      |= (dbg_state[i] == SB_CMD_RESP) & ~sb_abmem_cmd_write;\n      end\n   end\n\n   assign sb_cmd_awvalid     = ((sb_state == CMD_WR) | (sb_state == CMD_WR_ADDR));\n   assign sb_cmd_wvalid      = ((sb_state == CMD_WR) | (sb_state == CMD_WR_DATA));\n   assign sb_cmd_arvalid     = (sb_state == CMD_RD);\n   assign sb_read_pend       = (sb_state == RSP_RD);\n\n   assign sb_axi_size[2:0]    = (sb_abmem_cmd_awvalid | sb_abmem_cmd_wvalid | sb_abmem_cmd_arvalid | sb_abmem_read_pend) ? sb_abmem_cmd_size[2:0] : sb_cmd_size[2:0];\n   assign sb_axi_addr[31:0]   = (sb_abmem_cmd_awvalid | sb_abmem_cmd_wvalid | sb_abmem_cmd_arvalid | sb_abmem_read_pend) ? sb_abmem_cmd_addr[31:0] : sb_cmd_addr[31:0];\n   assign sb_axi_wrdata[63:0] = (sb_abmem_cmd_awvalid | sb_abmem_cmd_wvalid) ? {2{sb_abmem_cmd_wdata[31:0]}} : sb_cmd_wdata[63:0];\n\n   // Generic bus response signals\n   assign sb_bus_cmd_read       = sb_axi_arvalid & sb_axi_arready;\n   assign sb_bus_cmd_write_addr = sb_axi_awvalid & sb_axi_awready;\n   assign sb_bus_cmd_write_data = sb_axi_wvalid  & sb_axi_wready;\n\n   assign sb_bus_rsp_read  = sb_axi_rvalid & sb_axi_rready;\n   assign sb_bus_rsp_write = sb_axi_bvalid & sb_axi_bready;\n   assign sb_bus_rsp_error = (sb_bus_rsp_read & (|(sb_axi_rresp[1:0]))) | (sb_bus_rsp_write & (|(sb_axi_bresp[1:0])));\n\n   // AXI Request signals\n   assign sb_axi_awvalid              = sb_abmem_cmd_awvalid | sb_cmd_awvalid;\n   assign sb_axi_awaddr[31:0]         = sb_axi_addr[31:0];\n   assign sb_axi_awid[pt.SB_BUS_TAG-1:0] = '0;\n   assign sb_axi_awsize[2:0]          = sb_axi_size[2:0];\n   assign sb_axi_awprot[2:0]          = 3'b001;\n   assign sb_axi_awcache[3:0]         = 4'b1111;\n   assign sb_axi_awregion[3:0]        = sb_axi_addr[31:28];\n   assign sb_axi_awlen[7:0]           = '0;\n   assign sb_axi_awburst[1:0]         = 2'b01;\n   assign sb_axi_awqos[3:0]           = '0;\n   assign sb_axi_awlock               = '0;\n\n   assign sb_axi_wvalid       = sb_abmem_cmd_wvalid | sb_cmd_wvalid;\n   assign sb_axi_wdata[63:0]  = ({64{(sb_axi_size[2:0] == 3'h0)}} & {8{sb_axi_wrdata[7:0]}}) |\n                                ({64{(sb_axi_size[2:0] == 3'h1)}} & {4{sb_axi_wrdata[15:0]}}) |\n                                ({64{(sb_axi_size[2:0] == 3'h2)}} & {2{sb_axi_wrdata[31:0]}}) |\n                                ({64{(sb_axi_size[2:0] == 3'h3)}} & {sb_axi_wrdata[63:0]});\n   assign sb_axi_wstrb[7:0]   = ({8{(sb_axi_size[2:0] == 3'h0)}} & (8'h1 << sb_axi_addr[2:0])) |\n                                ({8{(sb_axi_size[2:0] == 3'h1)}} & (8'h3 << {sb_axi_addr[2:1],1'b0})) |\n                                ({8{(sb_axi_size[2:0] == 3'h2)}} & (8'hf << {sb_axi_addr[2],2'b0})) |\n                                ({8{(sb_axi_size[2:0] == 3'h3)}} & 8'hff);\n   assign sb_axi_wlast        = '1;\n\n   assign sb_axi_arvalid              = sb_abmem_cmd_arvalid | sb_cmd_arvalid;\n   assign sb_axi_araddr[31:0]         = sb_axi_addr[31:0];\n   assign sb_axi_arid[pt.SB_BUS_TAG-1:0] = '0;\n   assign sb_axi_arsize[2:0]          = sb_axi_size[2:0];\n   assign sb_axi_arprot[2:0]          = 3'b001;\n   assign sb_axi_arcache[3:0]         = 4'b0;\n   assign sb_axi_arregion[3:0]        = sb_axi_addr[31:28];\n   assign sb_axi_arlen[7:0]           = '0;\n   assign sb_axi_arburst[1:0]         = 2'b01;\n   assign sb_axi_arqos[3:0]           = '0;\n   assign sb_axi_arlock               = '0;\n\n   // AXI Response signals\n   assign sb_axi_bready = 1'b1;\n\n   assign sb_axi_rready = 1'b1;\n   assign sb_bus_rdata[63:0] = ({64{sb_axi_size == 3'h0}} & ((sb_axi_rdata[63:0] >>  8*sb_axi_addr[2:0]) & 64'hff))       |\n                               ({64{sb_axi_size == 3'h1}} & ((sb_axi_rdata[63:0] >> 16*sb_axi_addr[2:1]) & 64'hffff))    |\n                               ({64{sb_axi_size == 3'h2}} & ((sb_axi_rdata[63:0] >> 32*sb_axi_addr[2]) & 64'hffff_ffff)) |\n                               ({64{sb_axi_size == 3'h3}} & sb_axi_rdata[63:0]);\n\n\n`ifdef RV_ASSERT_ON\n// assertion.\n//  when the resume_ack is asserted then the dec_tlu_dbg_halted should be 0\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n      dm_check_resume_and_halted: assert property (@(posedge clk)  disable iff(~rst_l) (~dec_tlu_resume_ack[i] | ~dec_tlu_dbg_halted[i]));\n\n      assert_b2b_haltreq: assert property (@(posedge clk) disable iff (~rst_l) (##1 dbg_halt_req[i] |=> ~dbg_halt_req[i]));\n      assert_halt_resume_onehot: assert #0 ($onehot0({dbg_halt_req[i], dbg_resume_req[i]}));\n   end\n\n`endif\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// dec: decode unit - decode, bypassing, ARF, interrupts\n//\n//********************************************************************************\n//\n// Function: Decode\n// Comments: Decode, dependency scoreboard, ARF\n//\n// A -> D -> EX1 ... WB\n//\n//********************************************************************************\n\nmodule eh2_dec\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n   input logic clk,\n   input logic free_clk,\n   input logic free_l2clk,\n   input logic [pt.NUM_THREADS-1:0] active_thread_l2clk,\n\n   output logic         dec_i0_secondary_d,             // I0 Secondary ALU at  D-stage.  Used for clock gating\n   output logic         dec_i0_secondary_e1,            // I0 Secondary ALU at E1-stage.  Used for clock gating\n   output logic         dec_i0_secondary_e2,            // I0 Secondary ALU at E2-stage.  Used for clock gating\n\n   output logic         dec_i1_secondary_d,             // I1 Secondary ALU at  D-stage.  Used for clock gating\n   output logic         dec_i1_secondary_e1,            // I1 Secondary ALU at E1-stage.  Used for clock gating\n   output logic         dec_i1_secondary_e2,            // I1 Secondary ALU at E2-stage.  Used for clock gating\n\n   output logic         dec_i0_branch_d,                // I0 Branch at  D-stage.  Used for clock gating\n   output logic         dec_i0_branch_e1,               // I0 Branch at E1-stage.  Used for clock gating\n   output logic         dec_i0_branch_e2,               // I0 Branch at E2-stage.  Used for clock gating\n   output logic         dec_i0_branch_e3,               // I0 Branch at E3-stage.  Used for clock gating\n\n   output logic         dec_i1_branch_d,                // I1 Branch at  D-stage.  Used for clock gating\n   output logic         dec_i1_branch_e1,               // I1 Branch at E1-stage.  Used for clock gating\n   output logic         dec_i1_branch_e2,               // I1 Branch at E2-stage.  Used for clock gating\n   output logic         dec_i1_branch_e3,               // I1 Branch at E3-stage.  Used for clock gating\n\n   output logic dec_i0_pc4_e4,\n   output logic dec_i1_pc4_e4,\n\n   output logic dec_tlu_core_empty,\n   output logic dec_div_cancel,       // cancel divide operation\n\n   output logic [pt.NUM_THREADS-1:0]         dec_i1_cancel_e1,\n\n// fast interrupt\n   output logic dec_extint_stall,\n   input logic lsu_fastint_stall_any,\n\n   input logic [31:0] lsu_rs1_dc1,\n\n   output logic [pt.NUM_THREADS-1:0] dec_pause_state_cg,             // to top for active state clock gating\n\n   input logic rst_l,                        // reset, active low\n   input logic [31:1] rst_vec,               // reset vector, from core pins\n\n   input logic        nmi_int,               // NMI pin\n   input logic [31:1] nmi_vec,               // NMI vector, from pins\n\n   input logic  [pt.NUM_THREADS-1:0] i_cpu_halt_req,              // Asynchronous Halt request to CPU\n   input logic  [pt.NUM_THREADS-1:0] i_cpu_run_req,               // Asynchronous Restart request to CPU\n\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_mhartstart, // thread 1 hartstart\n   output logic [pt.NUM_THREADS-1:0] o_cpu_halt_status, // PMU interface, halted\n   output logic [pt.NUM_THREADS-1:0] o_cpu_halt_ack,              // Halt request ack\n   output logic [pt.NUM_THREADS-1:0] o_cpu_run_ack,               // Run request ack\n   output logic [pt.NUM_THREADS-1:0] o_debug_mode_status,         // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_force_halt,\n\n   input logic [31:4]     core_id, // Core ID\n\n\n   // external MPC halt/run interface\n   input logic  [pt.NUM_THREADS-1:0] mpc_debug_halt_req, // Async halt request\n   input logic  [pt.NUM_THREADS-1:0] mpc_debug_run_req, // Async run request\n   input logic  [pt.NUM_THREADS-1:0] mpc_reset_run_req, // Run/halt after reset\n   output logic [pt.NUM_THREADS-1:0] mpc_debug_halt_ack, // Halt ack\n   output logic [pt.NUM_THREADS-1:0] mpc_debug_run_ack, // Run ack\n   output logic [pt.NUM_THREADS-1:0] debug_brkpt_status, // debug breakpoint\n\n   input logic       exu_pmu_i0_br_misp,     // slot 0 branch misp\n   input logic       exu_pmu_i0_br_ataken,   // slot 0 branch actual taken\n   input logic       exu_pmu_i0_pc4,         // slot 0 4 byte branch\n   input logic       exu_pmu_i1_br_misp,     // slot 1 branch misp\n   input logic       exu_pmu_i1_br_ataken,   // slot 1 branch actual taken\n   input logic       exu_pmu_i1_pc4,         // slot 1 4 byte branch\n\n\n   input logic                                 lsu_nonblock_load_valid_dc1,      // valid nonblock load at dc3\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]   lsu_nonblock_load_tag_dc1,        // -> corresponding tag\n   input logic                                 lsu_nonblock_load_inv_dc2,       // invalidate request for nonblock load dc2\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]   lsu_nonblock_load_inv_tag_dc2,   // -> corresponding tag\n   input logic                                 lsu_nonblock_load_inv_dc5,        // invalidate request for nonblock load dc5\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]   lsu_nonblock_load_inv_tag_dc5,    // -> corresponding tag\n   input logic                                 lsu_nonblock_load_data_valid,     // valid nonblock load data back\n   input logic                                 lsu_nonblock_load_data_tid,\n   input logic                                 lsu_nonblock_load_data_error,     // nonblock load bus error\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]   lsu_nonblock_load_data_tag,       // -> corresponding tag\n   input logic [31:0]                          lsu_nonblock_load_data,           // nonblock load data\n\n   input logic [pt.NUM_THREADS-1:0] lsu_pmu_load_external_dc3,\n   input logic [pt.NUM_THREADS-1:0] lsu_pmu_store_external_dc3,\n   input logic [pt.NUM_THREADS-1:0] lsu_pmu_misaligned_dc3,\n   input logic [pt.NUM_THREADS-1:0] lsu_pmu_bus_trxn,\n   input logic [pt.NUM_THREADS-1:0] lsu_pmu_bus_busy,\n   input logic [pt.NUM_THREADS-1:0] lsu_pmu_bus_misaligned,\n   input logic [pt.NUM_THREADS-1:0] lsu_pmu_bus_error,\n\n\n   input logic       dma_pmu_dccm_read,          // DMA DCCM read\n   input logic       dma_pmu_dccm_write,         // DMA DCCM write\n   input logic       dma_pmu_any_read,           // DMA read\n   input logic       dma_pmu_any_write,          // DMA write\n\n   input logic [pt.NUM_THREADS-1:0][1:0] ifu_pmu_instr_aligned,\n   input logic [pt.NUM_THREADS-1:0]      ifu_pmu_align_stall,\n\n   input logic [pt.NUM_THREADS-1:0] ifu_pmu_fetch_stall,\n\n   input logic [pt.NUM_THREADS-1:0] ifu_pmu_ic_miss,\n   input logic [pt.NUM_THREADS-1:0] ifu_pmu_ic_hit,\n   input logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_error,\n   input logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_busy,\n   input logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_trxn,\n\n   input logic [3:0]  lsu_trigger_match_dc4,\n   input logic        dbg_cmd_valid,   // debugger abstract command valid\n   input logic        dbg_cmd_tid,     // thread for debug register read\n   input logic        dbg_cmd_write,   // command is a write\n   input logic  [1:0] dbg_cmd_type,    // command type\n   input logic [31:0] dbg_cmd_addr,    // command address\n   input logic  [1:0] dbg_cmd_wrdata,  // command write data, for fence/fence_i\n\n\n   input logic [pt.NUM_THREADS-1:0] [1:0]  ifu_i0_icaf_type,                           // Instruction 0 access fault type\n   input logic [pt.NUM_THREADS-1:0]      ifu_i0_icaf,          // icache access fault\n   input logic [pt.NUM_THREADS-1:0]      ifu_i0_icaf_second,   // i0 has access fault on second 2B of 4B inst\n   input logic [pt.NUM_THREADS-1:0]      ifu_i0_dbecc,         // icache/iccm double-bit error\n\n\n   input logic [pt.NUM_THREADS-1:0]  lsu_idle_any,                          // lsu idle: if fence instr & ~lsu_idle then stall decode\n   input logic [pt.NUM_THREADS-1:0]  lsu_load_stall_any,                    // stall any load  at decode\n   input logic [pt.NUM_THREADS-1:0]  lsu_store_stall_any,                   // stall any store at decode\n   input logic [pt.NUM_THREADS-1:0]  lsu_amo_stall_any,         // This is for blocking amo\n\n   input eh2_br_pkt_t [pt.NUM_THREADS-1:0] i0_brp,              // branch packet\n   input eh2_br_pkt_t [pt.NUM_THREADS-1:0] i1_brp,\n   input logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifu_i0_bp_index, // BP index\n   input logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]           ifu_i0_bp_fghr, // BP FGHR\n   input logic [pt.NUM_THREADS-1:0] [pt.BTB_BTAG_SIZE-1:0]          ifu_i0_bp_btag, // BP tag\n   input logic [pt.NUM_THREADS-1:0] [pt.BTB_TOFFSET_SIZE-1:0]          ifu_i0_bp_toffset, // BP tag\n   input logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifu_i1_bp_index, // BP index\n   input logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]           ifu_i1_bp_fghr, // BP FGHR\n   input logic [pt.NUM_THREADS-1:0] [pt.BTB_BTAG_SIZE-1:0]          ifu_i1_bp_btag, // BP tag\n   input logic [pt.NUM_THREADS-1:0] [pt.BTB_TOFFSET_SIZE-1:0]          ifu_i1_bp_toffset, // BP tag\n\n   input logic [pt.NUM_THREADS-1:0] [$clog2(pt.BTB_SIZE)-1:0] ifu_i0_bp_fa_index,\n   input logic [pt.NUM_THREADS-1:0] [$clog2(pt.BTB_SIZE)-1:0] ifu_i1_bp_fa_index,\n\n   input    eh2_lsu_error_pkt_t lsu_error_pkt_dc3, // LSU exception/error packet\n   input logic         lsu_single_ecc_error_incr,     // Increment the ecc error counter\n\n   input logic [pt.NUM_THREADS-1:0] lsu_imprecise_error_store_any,\n   input logic [pt.NUM_THREADS-1:0] lsu_imprecise_error_load_any,\n   input logic [pt.NUM_THREADS-1:0][31:0]  lsu_imprecise_error_addr_any,   // LSU imprecise bus error address\n\n\n   input logic [pt.NUM_THREADS-1:0]      exu_flush_final,            // Pipe is being flushed this cycle\n   input logic [pt.NUM_THREADS-1:0]      exu_i0_flush_final,         // I0 flush to DEC\n   input logic [pt.NUM_THREADS-1:0]      exu_i1_flush_final,         // I1 flush to DEC\n   input logic [pt.NUM_THREADS-1:0]      exu_i0_flush_lower_e4,        // to TLU - lower branch flush\n   input logic [pt.NUM_THREADS-1:0]      exu_i1_flush_lower_e4,        // to TLU - lower branch flush\n\n   input logic [31:1] exu_i0_flush_path_e4, // pipe 0 correct path for mp, merge with lower path\n   input logic [31:1] exu_i1_flush_path_e4, // pipe 1 correct path for mp, merge with lower path\n\n   input logic         exu_div_wren,        // final div write enable to GPR\n   input logic [31:0]  exu_div_result,      // final div result\n\n   input logic [31:0] exu_mul_result_e3,    // 32b mul result\n\n   input logic [31:0] exu_i0_csr_rs1_e1,       // rs1 for csr instruction\n\n   input logic [31:0] lsu_result_dc3,       // load result\n   input logic [31:0] lsu_result_corr_dc4, // load result - corrected data for writing gprs; not for bypassing\n\n   input logic        lsu_sc_success_dc5,   // store conditional matched ( 1 = success, which means the GPR should write 0 )\n   input logic        dma_dccm_stall_any,   // stall any load/store at decode, pmu event\n   input logic        dma_iccm_stall_any,   // iccm stalled, pmu event\n\n   input logic [31:1] lsu_fir_addr, // Fast int address\n   input logic [1:0]  lsu_fir_error, // Fast int lookup error\n\n   input logic       iccm_dma_sb_error,     // ICCM DMA single bit error\n\n   input logic [pt.NUM_THREADS-1:0][31:1] exu_npc_e4,           // next PC\n\n   input logic [31:0] exu_i0_result_e1,     // alu result e1\n   input logic [31:0] exu_i1_result_e1,\n\n   input logic [31:0] exu_i0_result_e4,     // alu result e4\n   input logic [31:0] exu_i1_result_e4,\n\n\n   input logic [pt.NUM_THREADS-1:0]       ifu_i0_valid, ifu_i1_valid,    // fetch valids to instruction buffer\n   input logic [pt.NUM_THREADS-1:0] [31:0]  ifu_i0_instr, ifu_i1_instr,    // fetch inst's to instruction buffer\n   input logic [pt.NUM_THREADS-1:0] [31:1]  ifu_i0_pc, ifu_i1_pc,          // pc's for instruction buffer\n   input logic [pt.NUM_THREADS-1:0]         ifu_i0_pc4, ifu_i1_pc4,        // indication of 4B or 2B for corresponding inst\n\n   input eh2_predecode_pkt_t  [pt.NUM_THREADS-1:0] ifu_i0_predecode,\n   input eh2_predecode_pkt_t  [pt.NUM_THREADS-1:0] ifu_i1_predecode,\n\n   input logic  [31:1] exu_i0_pc_e1,                  // pc's for e1 from the alu's\n   input logic  [31:1] exu_i1_pc_e1,\n\n   input logic [pt.NUM_THREADS-1:0] timer_int,                             // Timer interrupt pending (from pin)\n   input logic [pt.NUM_THREADS-1:0] soft_int,                             // Software interrupt pending (from pin)\n\n   input logic [pt.NUM_THREADS-1:0]       mexintpend,                      // External interrupt pending\n   input logic [pt.NUM_THREADS-1:0] [7:0] pic_claimid,                     // PIC claimid\n   input logic [pt.NUM_THREADS-1:0] [3:0] pic_pl,                          // PIC priv level\n   input logic [pt.NUM_THREADS-1:0]       mhwakeup,                        // High priority wakeup\n\n   output logic [pt.NUM_THREADS-1:0][3:0] dec_tlu_meicurpl,               // to PIC, Current priv level\n   output logic [pt.NUM_THREADS-1:0][3:0] dec_tlu_meipt,                  // to PIC\n   output logic [31:2] dec_tlu_meihap, // Fast ext int base\n\n   input logic [70:0] ifu_ic_debug_rd_data,           // diagnostic icache read data\n   input logic ifu_ic_debug_rd_data_valid,            // diagnostic icache read data valid\n   output eh2_cache_debug_pkt_t dec_tlu_ic_diag_pkt,      // packet of DICAWICS, DICAD0/1, DICAGO info for icache diagnostics\n\n\n// Debug start\n   input logic [pt.NUM_THREADS-1:0] dbg_halt_req,                 // DM requests a halt\n   input logic [pt.NUM_THREADS-1:0] dbg_resume_req,               // DM requests a resume\n\n   input logic [pt.NUM_THREADS-1:0] ifu_miss_state_idle,\n   input logic [pt.NUM_THREADS-1:0] ifu_ic_error_start,\n   input logic [pt.NUM_THREADS-1:0] ifu_iccm_rd_ecc_single_err,\n\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_dbg_halted,          // Core is halted and ready for debug command\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_debug_mode,          // Core is in debug mode\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_resume_ack,          // Resume acknowledge\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_mpc_halted_only,     // Core is halted only due to MPC\n\n   output logic dec_debug_wdata_rs1_d,       // insert debug write data into rs1 at decode\n\n   output logic [31:0] dec_dbg_rddata,       // debug command read data\n\n   output logic dec_dbg_cmd_done,            // abstract command is done\n   output logic dec_dbg_cmd_fail,            // abstract command failed (illegal reg address)\n   output logic dec_dbg_cmd_tid,             // Tid for debug abstract command response\n\n   output eh2_trigger_pkt_t  [pt.NUM_THREADS-1:0][3:0] trigger_pkt_any, // info needed by debug trigger blocks\n// Debug end\n\n   // branch info from pipe0 for errors or counter updates\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_i0_br_index_e4,   // index\n   input logic [1:0]  exu_i0_br_hist_e4,                             // history\n   input logic        exu_i0_br_bank_e4,                             // bank\n   input logic        exu_i0_br_error_e4,                            // error\n   input logic        exu_i0_br_start_error_e4,                      // start error\n   input logic        exu_i0_br_valid_e4,                            // valid\n   input logic        exu_i0_br_mp_e4,                               // mispredict\n   input logic        exu_i0_br_middle_e4,                           // middle of bank\n   input logic [pt.BHT_GHR_SIZE-1:0] exu_i0_br_fghr_e4,              // FGHR when predicted\n\n   // branch info from pipe1 for errors or counter updates\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_i1_br_index_e4,   // index\n   input logic [1:0]  exu_i1_br_hist_e4,                             // history\n   input logic        exu_i1_br_bank_e4,                             // bank\n   input logic        exu_i1_br_error_e4,                            // error\n   input logic        exu_i1_br_start_error_e4,                      // start error\n   input logic        exu_i1_br_valid_e4,                            // valid\n   input logic        exu_i1_br_mp_e4,                               // mispredict\n   input logic        exu_i1_br_middle_e4,                           // middle of bank\n   input logic [pt.BHT_GHR_SIZE-1:0] exu_i1_br_fghr_e4,              // FGHR when predicted\n\n\n   input logic        exu_i1_br_way_e4,             // way hit or repl\n   input logic        exu_i0_br_way_e4,             // way hit or repl\n\n   output logic [31:0] gpr_i0_rs1_d,               // gpr rs1 data\n   output logic [31:0] gpr_i0_rs2_d,               // gpr rs2 data\n   output logic [31:0] gpr_i1_rs1_d,\n   output logic [31:0] gpr_i1_rs2_d,\n\n   output logic [31:0] dec_i0_immed_d,              // immediate data\n   output logic [31:0] dec_i1_immed_d,\n\n   output logic [pt.BTB_TOFFSET_SIZE:1] dec_i0_br_immed_d,           // br immediate data\n   output logic [pt.BTB_TOFFSET_SIZE:1] dec_i1_br_immed_d,\n\n   output        eh2_alu_pkt_t i0_ap,                   // alu packet\n   output        eh2_alu_pkt_t i1_ap,\n\n   output logic          dec_i0_alu_decode_d,       // alu schedule on primary alu\n   output logic          dec_i1_alu_decode_d,\n\n   output logic          dec_i0_select_pc_d,        // select pc onto rs1 for jal's\n   output logic          dec_i1_select_pc_d,\n\n   output logic [31:1] dec_i0_pc_d, dec_i1_pc_d,    // pc's at decode\n   output logic         dec_i0_rs1_bypass_en_d,     // rs1 bypass enable\n   output logic         dec_i0_rs2_bypass_en_d,     // rs2 bypass enable\n   output logic         dec_i1_rs1_bypass_en_d,\n   output logic         dec_i1_rs2_bypass_en_d,\n\n   output logic [31:0] i0_rs1_bypass_data_d,       // rs1 bypass data\n   output logic [31:0] i0_rs2_bypass_data_d,       // rs2 bypass data\n   output logic [31:0] i1_rs1_bypass_data_d,\n   output logic [31:0] i1_rs2_bypass_data_d,\n   output logic [pt.NUM_THREADS-1:0]        dec_ib3_valid_d,           // ib3 buffer valid\n   output logic [pt.NUM_THREADS-1:0]        dec_ib2_valid_d,           // ib2 buffer valid\n\n   output eh2_lsu_pkt_t    lsu_p,                      // lsu packet\n   output eh2_mul_pkt_t    mul_p,                      // mul packet\n   output eh2_div_pkt_t    div_p,                      // div packet\n\n   output logic [11:0] dec_lsu_offset_d,           // 12b offset for load/store addresses\n   output logic        dec_i0_lsu_d,               // is load/store\n   output logic        dec_i1_lsu_d,\n\n   output logic [pt.NUM_THREADS-1:0]       flush_final_e3,             // final flush\n   output logic [pt.NUM_THREADS-1:0]       i0_flush_final_e3,          // final flush from i0\n\n   output logic        dec_i0_csr_ren_d,              // csr read enable\n\n   output logic        dec_tlu_i0_kill_writeb_wb,  // I0 is flushed, don't writeback any results to arch state\n   output logic        dec_tlu_i1_kill_writeb_wb,  // I1 is flushed, don't writeback any results to arch state\n\n   output logic        dec_i0_mul_d,               // chose which gpr value to use\n   output logic        dec_i1_mul_d,\n   output logic        dec_i0_div_d,               // chose which gpr value to use\n\n   output logic        dec_i1_valid_e1,            // i1 valid at e1 stage\n\n   output logic [pt.NUM_THREADS-1:0][31:1] pred_correct_npc_e2, // npc e2 if the prediction is correct\n\n   output logic        dec_i0_rs1_bypass_en_e3,    // rs1 bypa"}
{"text": "ss enable e3\n   output logic        dec_i0_rs2_bypass_en_e3,    // rs2 bypass enable e3\n   output logic        dec_i1_rs1_bypass_en_e3,\n   output logic        dec_i1_rs2_bypass_en_e3,\n   output logic [31:0] i0_rs1_bypass_data_e3,      // rs1 bypass data e3\n   output logic [31:0] i0_rs2_bypass_data_e3,      // rs2 bypass data e3\n   output logic [31:0] i1_rs1_bypass_data_e3,\n   output logic [31:0] i1_rs2_bypass_data_e3,\n   output logic        dec_i0_sec_decode_e3,       // secondary decode e3\n   output logic        dec_i1_sec_decode_e3,\n   output logic [31:1] dec_i0_pc_e3,               // pc at e3\n   output logic [31:1] dec_i1_pc_e3,\n\n   output logic        dec_i0_rs1_bypass_en_e2,    // rs1 bypass enable e2\n   output logic        dec_i0_rs2_bypass_en_e2,    // rs2 bypass enable e2\n   output logic        dec_i1_rs1_bypass_en_e2,\n   output logic        dec_i1_rs2_bypass_en_e2,\n   output logic [31:0] i0_rs1_bypass_data_e2,      // rs1 bypass data e2\n   output logic [31:0] i0_rs2_bypass_data_e2,      // rs2 bypass data e2\n   output logic [31:0] i1_rs1_bypass_data_e2,\n   output logic [31:0] i1_rs2_bypass_data_e2,\n\n   output eh2_br_tlu_pkt_t dec_tlu_br0_wb_pkt,         // slot 0 branch predictor update packet\n   output eh2_br_tlu_pkt_t dec_tlu_br1_wb_pkt,         // slot 1 branch predictor update packet\n   output logic [pt.BHT_GHR_SIZE-1:0] dec_tlu_br0_fghr_wb, // fghr to bp\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br0_index_wb, // bp index\n   output logic [pt.BHT_GHR_SIZE-1:0] dec_tlu_br1_fghr_wb, // fghr to bp\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br1_index_wb, // bp index\n\n   output logic [$clog2(pt.BTB_SIZE)-1:0] dec_fa_error_index, // Fully associt btb error index\n\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt0, // toggles when pipe0 perf counter 0 has an event inc\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt1, // toggles when pipe0 perf counter 1 has an event inc\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt2, // toggles when pipe0 perf counter 2 has an event inc\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt3, // toggles when pipe0 perf counter 3 has an event inc\n\n\n\n   output eh2_predict_pkt_t  i0_predict_p_d,           // prediction packet to alus\n   output eh2_predict_pkt_t  i1_predict_p_d,\n   output logic [pt.BHT_GHR_SIZE-1:0] i0_predict_fghr_d,                // DEC predict fghr\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i0_predict_index_d,     // DEC predict index\n   output logic [pt.BTB_BTAG_SIZE-1:0] i0_predict_btag_d,               // DEC predict branch tgt\n   output logic [pt.BTB_TOFFSET_SIZE-1:0] i0_predict_toffset_d,               // DEC predict branch tgt\n   output logic [pt.BHT_GHR_SIZE-1:0] i1_predict_fghr_d,                // DEC predict fghr\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i1_predict_index_d,     // DEC predict index\n   output logic [pt.BTB_BTAG_SIZE-1:0] i1_predict_btag_d,               // DEC predict branch tgt\n   output logic [pt.BTB_TOFFSET_SIZE-1:0] i1_predict_toffset_d,               // DEC predict branch tgt\n\n\n   output logic [31:0] i0_result_e4_eff,           // alu result e4\n   output logic [31:0] i1_result_e4_eff,\n\n   output   logic dec_tlu_i0_valid_e4,             // slot 0 instruction is valid at e4\n   output   logic dec_tlu_i1_valid_e4,             // slot 1 instruction is valid at e4, implies i0_valid_e4\n\n   output logic [31:0] i0_result_e2,               // i0 result data e2\n   output logic [31:0] dec_tlu_mrac_ff,            // CSR for memory region control\n\n   output logic [4:1] dec_i0_data_en,              // clock-gate control logic\n   output logic [4:1] dec_i0_ctl_en,\n   output logic [4:1] dec_i1_data_en,\n   output logic [4:1] dec_i1_ctl_en,\n\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_lr_reset_wb, // Reset the reservation on certain events\n\n   input logic [pt.NUM_THREADS-1:0] [15:0] ifu_i0_cinst,                  // 16b compressed instruction\n   input logic [pt.NUM_THREADS-1:0] [15:0] ifu_i1_cinst,\n\n   output eh2_trace_pkt_t  [pt.NUM_THREADS-1:0] trace_rv_trace_pkt,             // trace packet\n\n   // feature disable from mfdc\n   output logic  dec_tlu_external_ldfwd_disable, // disable external load forwarding\n   output logic  dec_tlu_sideeffect_posted_disable, // disable posted writes to side-effect address\n   output logic  dec_tlu_core_ecc_disable,           // disable core ECC\n   output logic  dec_tlu_bpred_disable,              // disable branch prediction\n   output logic  dec_tlu_wb_coalescing_disable,      // disable writebuffer coalescing\n   output logic [2:0]  dec_tlu_dma_qos_prty,         // DMA QoS priority coming from MFDC [18:16]\n   output logic [pt.NUM_THREADS-1:0]      dec_tlu_i0_commit_cmt,        // goes to IFU for commit 1 instruction in the FSM\n   // clock gating overrides from mcgc\n   output logic  dec_tlu_misc_clk_override,          // override misc clock domain gating\n   output logic  dec_tlu_exu_clk_override,           // override exu clock domain gating\n   output logic  dec_tlu_ifu_clk_override,           // override fetch clock domain gating\n   output logic  dec_tlu_lsu_clk_override,           // override load/store clock domain gating\n   output logic  dec_tlu_bus_clk_override,           // override bus clock domain gating\n   output logic  dec_tlu_pic_clk_override,           // override PIC clock domain gating\n   output logic  dec_tlu_picio_clk_override,         // override PIC clock domain gating\n   output logic  dec_tlu_dccm_clk_override,          // override DCCM clock domain gating\n   output logic  dec_tlu_icm_clk_override,           // override ICCM clock domain gating\n\n   output logic dec_i0_tid_e4, // needed to maintain RS in BP\n   output logic dec_i1_tid_e4,\n\n   output logic [pt.NUM_THREADS-1:0] [31:1] dec_tlu_flush_path_wb,  // flush pc\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_lower_wb, // commit has a flush (exception, int, mispredict at e4)\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_mp_wb,    // commit has a flush (mispredict at e4)\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_lower_wb1,\n\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_noredir_wb , // Tell fetch to idle on this flush\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_leak_one_wb, // single step\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_err_wb, // iside perr/ecc rfpc\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_fence_i_wb,     // flush is a fence_i rfnpc, flush icache\n\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_btb_write_kill, // Kill writes while working on forward progress after a branch error\n   //\n   input  logic        scan_mode\n\n   );\n\n   localparam GPR_BANKS = 1;\n   localparam GPR_BANKS_LOG2 = (GPR_BANKS == 1) ? 1 : $clog2(GPR_BANKS);\n\n   logic [pt.NUM_THREADS-1:0] dec_tlu_flush_pause_wb;\n   logic [pt.NUM_THREADS-1:0] dec_tlu_wr_pause_wb;\n\n\n   logic  dec_tlu_dec_clk_override; // to and from dec blocks\n   logic  clk_override;\n\n   logic               dec_ib1_valid_d;\n   logic               dec_ib0_valid_d;\n\n\n   logic [pt.NUM_THREADS-1:0][1:0] dec_pmu_instr_decoded;\n   logic [pt.NUM_THREADS-1:0]      dec_pmu_decode_stall;\n   logic [pt.NUM_THREADS-1:0]      dec_pmu_presync_stall;\n   logic [pt.NUM_THREADS-1:0]      dec_pmu_postsync_stall;\n\n   logic        dec_i0_rs1_en_d;\n   logic        dec_i0_rs2_en_d;\n\n   logic [4:0]  dec_i0_rs1_d;\n   logic [4:0]  dec_i0_rs2_d;\n\n\n   logic        dec_i1_rs1_en_d;\n   logic        dec_i1_rs2_en_d;\n\n   logic [4:0]  dec_i1_rs1_d;\n   logic [4:0]  dec_i1_rs2_d;\n\n\n   logic [31:0] dec_i0_instr_d, dec_i1_instr_d;\n\n   logic  dec_tlu_pipelining_disable;\n   logic  dec_tlu_dual_issue_disable;\n   logic  dec_tlu_trace_disable;\n\n   logic [4:0]  dec_i0_waddr_wb;\n   logic        dec_i0_wen_wb;\n   logic        dec_i0_tid_wb;\n   logic [31:0] dec_i0_wdata_wb;\n\n   logic [4:0]  dec_i1_waddr_wb;\n   logic        dec_i1_wen_wb;\n   logic        dec_i1_tid_wb;\n   logic [31:0] dec_i1_wdata_wb;\n\n   logic        dec_i0_csr_wen_wb;      // csr write enable at wb\n   logic [11:0] dec_i0_csr_rdaddr_d;      // read address for csr\n   logic [11:0] dec_i0_csr_wraddr_wb;      // write address for csryes\n   logic        dec_i0_csr_is_mcpc_e4;\n\n   logic [31:0] dec_i0_csr_wrdata_wb;    // csr write data at wb\n\n   logic [31:0] dec_i0_csr_rddata_d;    // csr read data at wb\n   logic        dec_i0_csr_legal_d;            // csr indicates legal operation\n   logic        dec_i0_csr_global_d;\n\n   logic        dec_i0_csr_wen_unq_d;       // valid csr with write - for csr legal\n   logic        dec_i0_csr_any_unq_d;       // valid csr - for csr legal\n\n\n   logic [pt.NUM_THREADS-1:0] dec_csr_stall_int_ff; // csr is mie/mstatus\n   logic                      dec_csr_nmideleg_e4;  // csr is mnmipdel\n\n\n   eh2_trap_pkt_t dec_tlu_packet_e4;\n\n   logic                        dec_i0_debug_valid_d;\n   logic                        dec_i1_debug_valid_d;\n\n   logic                        dec_i0_pc4_d, dec_i1_pc4_d;\n   logic [pt.NUM_THREADS-1:0]   dec_tlu_presync_d;\n   logic [pt.NUM_THREADS-1:0]   dec_tlu_postsync_d;\n   logic [pt.NUM_THREADS-1:0]   dec_tlu_debug_stall;   // stall decode while waiting on core to empty\n\n   logic [pt.NUM_THREADS-1:0][31:0] dec_illegal_inst;\n\n\n   logic                      dec_i0_icaf_d;\n   logic [1:0]                dec_i0_icaf_type_d;\n   logic                      dec_i0_icaf_second_d;\n\n   logic                      dec_i1_icaf_d;\n\n   logic                      dec_i0_dbecc_d;\n   logic                      dec_i1_dbecc_d;\n\n   logic                      dec_i0_decode_d;\n   logic                      dec_i1_decode_d;\n\n   logic [3:0]                dec_i0_trigger_match_d;\n   logic [3:0]                dec_i1_trigger_match_d;\n\n\n   logic                      dec_debug_fence_d;\n\n   logic [pt.NUM_THREADS-1:0]                 dec_nonblock_load_wen;\n   logic [pt.NUM_THREADS-1:0][4:0]            dec_nonblock_load_waddr;\n\n   eh2_br_pkt_t dec_i0_brp;\n   eh2_br_pkt_t dec_i1_brp;\n\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_i0_bp_index;\n   logic [pt.BHT_GHR_SIZE-1:0] dec_i0_bp_fghr;\n   logic [pt.BTB_BTAG_SIZE-1:0] dec_i0_bp_btag;\n   logic [pt.BTB_TOFFSET_SIZE-1:0] dec_i0_bp_toffset;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_i1_bp_index;\n   logic [pt.BHT_GHR_SIZE-1:0] dec_i1_bp_fghr;\n   logic [pt.BTB_BTAG_SIZE-1:0] dec_i1_bp_btag;\n   logic [pt.BTB_TOFFSET_SIZE-1:0] dec_i1_bp_toffset;\n\n   logic [$clog2(pt.BTB_SIZE)-1:0] dec_i0_bp_fa_index;\n\n\n   logic [pt.NUM_THREADS-1:0] dec_pause_state;          // core in pause state\n\n\n   logic [15:0] dec_i0_cinst_d;\n   logic [15:0] dec_i1_cinst_d;\n\n   eh2_predecode_pkt_t dec_i0_predecode;\n   eh2_predecode_pkt_t dec_i1_predecode;\n\n   logic [31:0]               dec_i0_inst_wb1;\n   logic [31:0]               dec_i1_inst_wb1;\n   logic [31:1]               dec_i0_pc_wb1;\n   logic [31:1]               dec_i1_pc_wb1;\n   logic [pt.NUM_THREADS-1:0] dec_tlu_i1_valid_wb1, dec_tlu_i0_valid_wb1,  dec_tlu_int_valid_wb1;\n   logic [pt.NUM_THREADS-1:0] [4:0] dec_tlu_exc_cause_wb1;\n   logic [pt.NUM_THREADS-1:0] [31:0] dec_tlu_mtval_wb1;\n   logic [pt.NUM_THREADS-1:0]   dec_tlu_i0_exc_valid_wb1, dec_tlu_i1_exc_valid_wb1;\n\n   logic dec_i0_tid_d;\n   logic dec_i1_tid_d;\n\n\n   logic [1:0] [31:0] gpr_i0rs1_d;               // gpr rs1 data\n   logic [1:0] [31:0] gpr_i0rs2_d;               // gpr rs2 data\n   logic [1:0] [31:0] gpr_i1rs1_d;\n   logic [1:0] [31:0] gpr_i1rs2_d;\n\n   logic [31:1] dec_tlu_i0_pc_e4;                // pc e4\n   logic [31:1] dec_tlu_i1_pc_e4;\n   logic        dec_i0_debug_valid_wb;\n\n\n   assign clk_override = dec_tlu_dec_clk_override;\n\n\n   assign dec_dbg_rddata[31:0] = (dec_i0_debug_valid_wb) ? dec_i0_wdata_wb[31:0] : '0;\n\n// multithreaded signals\n\n   logic [pt.NUM_THREADS-1:0] ib3_valid_d;               // ib3 valid\n   logic [pt.NUM_THREADS-1:0] ib2_valid_d;               // ib2 valid\n   logic [pt.NUM_THREADS-1:0] ib1_valid_d;               // ib1 valid\n   logic [pt.NUM_THREADS-1:0] ib0_valid_d;               // ib0 valid\n   logic [pt.NUM_THREADS-1:0] ib0_valid_in;              // ib0 valid cycle before decode\n   logic [pt.NUM_THREADS-1:0] ib0_lsu_in;              // ib0 lsu cycle before decode\n   logic [pt.NUM_THREADS-1:0] ib0_mul_in;              // ib0 mul cycle before decode\n   logic [pt.NUM_THREADS-1:0] ib0_i0_only_in;          // ib0 i0_only cycle before decode\n\n   logic [pt.NUM_THREADS-1:0] [31:0] i0_instr_d;         // i0 inst at decode\n   logic [pt.NUM_THREADS-1:0] [31:0] i1_instr_d;         // i1 inst at decode\n   logic [pt.NUM_THREADS-1:0] [31:1] i0_pc_d;            // i0 pc at decode\n   logic [pt.NUM_THREADS-1:0] [31:1] i1_pc_d;\n   logic [pt.NUM_THREADS-1:0] i0_pc4_d;                  // i0 is 4B inst else 2B\n   logic [pt.NUM_THREADS-1:0] i1_pc4_d;\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i0_bp_index;            // i0 branch index\n   logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]           i0_bp_fghr; // BP FGHR\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_BTAG_SIZE-1:0]          i0_bp_btag; // BP tag\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_TOFFSET_SIZE-1:0]       i0_bp_toffset; // BP tag\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i1_bp_index;            // i0 branch index\n   logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]           i1_bp_fghr; // BP FGHR\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_BTAG_SIZE-1:0]          i1_bp_btag; // BP tag\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_TOFFSET_SIZE-1:0]       i1_bp_toffset; // BP tag\n   logic [pt.NUM_THREADS-1:0] i0_icaf_d;                 // i0 instruction access fault at decode\n   logic [pt.NUM_THREADS-1:0] i1_icaf_d;\n   logic [pt.NUM_THREADS-1:0] i0_icaf_second_d;              // i0 instruction access fault at decode for f1 fetch group\n   logic [pt.NUM_THREADS-1:0] i0_dbecc_d;                // i0 double-bit error at decode\n   logic [pt.NUM_THREADS-1:0] i1_dbecc_d;\n   logic [pt.NUM_THREADS-1:0] debug_wdata_rs1_d;         // put debug write data onto rs1 source: machine is halted\n   logic [pt.NUM_THREADS-1:0] debug_fence_d;             // debug fence inst\n   logic [pt.NUM_THREADS-1:0] i0_debug_valid_d;             // debug fence inst\n   logic [pt.NUM_THREADS-1:0] [15:0] i0_cinst_d;         // 16b compress inst at decode\n   logic [pt.NUM_THREADS-1:0] [15:0] i1_cinst_d;\n   logic [pt.NUM_THREADS-1:0] [1:0] i0_icaf_type_d;\n\n   logic [pt.NUM_THREADS-1:0][$clog2(pt.BTB_SIZE)-1:0] i0_bp_fa_index;\n\n   eh2_br_pkt_t [pt.NUM_THREADS-1:0] i0_br_p;                 // i0 branch packet at decode\n   eh2_br_pkt_t [pt.NUM_THREADS-1:0] i1_br_p;\n\n   eh2_predecode_pkt_t [pt.NUM_THREADS-1:0] i0_predecode_p;                 // i0 branch packet at decode\n   eh2_predecode_pkt_t [pt.NUM_THREADS-1:0] i1_predecode_p;\n\n   logic [pt.NUM_THREADS-1:0]         ready_in,ready;\n   logic [pt.NUM_THREADS-1:0]         lsu_in, mul_in, i0_only_in;\n   logic [pt.NUM_THREADS-1:0]         dec_thread_stall_in;\n   logic [pt.NUM_THREADS-1:0]         dec_tlu_flush_extint;\n\n   logic [4:0] div_waddr_wb;\n   logic       div_tid_wb;\n\n   logic       dec_div_active;    // non-block divide is active\n   logic       dec_div_tid;       // non-block divide tid\n\n   logic       dec_force_favor_flip_d;\n\n   logic       active_clk;\n\n\n\n\n   rvoclkhdr activeclk (.*, .en(1'b1), .l1clk(active_clk));\n\n\n  for (genvar i=0; i<pt.NUM_THREADS; i++) begin : ib\n\n\n     eh2_dec_ib_ctl #(.pt(pt)) instbuff (.clk               (active_thread_l2clk[i]),\n                                          .tid               (1'(i)            ),\n                                          .ifu_i0_valid      (ifu_i0_valid[i]),\n                                          .ifu_i1_valid      (ifu_i1_valid[i]),\n                                          .ifu_i0_icaf       (ifu_i0_icaf[i]),\n                                          .ifu_i0_icaf_type  (ifu_i0_icaf_type[i]),\n                                          .ifu_i0_icaf_second (ifu_i0_icaf_second[i]),\n                                          .ifu_i0_dbecc      (ifu_i0_dbecc[i]),\n                                          .ifu_i0_instr      (ifu_i0_instr[i]),\n                                          .ifu_i1_instr      (ifu_i1_instr[i]),\n                                          .ifu_i0_pc         (ifu_i0_pc[i]),\n                                          .ifu_i1_pc         (ifu_i1_pc[i]),\n                                          .ifu_i0_pc4        (ifu_i0_pc4[i]),\n                                          .ifu_i1_pc4        (ifu_i1_pc4[i]),\n                                          .ifu_i0_predecode  (ifu_i0_predecode[i]),\n                                          .ifu_i1_predecode  (ifu_i1_predecode[i]),\n                                          .i0_brp            (i0_brp[i]),\n                                          .i1_brp            (i1_brp[i]),\n                                          .ifu_i0_bp_index   (ifu_i0_bp_index[i]),\n                                          .ifu_i0_bp_fghr    (ifu_i0_bp_fghr[i]),\n                                          .ifu_i0_bp_btag    (ifu_i0_bp_btag[i]),\n                                          .ifu_i0_bp_fa_index(ifu_i0_bp_fa_index[i]),\n                                          .ifu_i0_bp_toffset    (ifu_i0_bp_toffset[i]),\n                                          .ifu_i1_bp_index   (ifu_i1_bp_index[i]),\n                                          .ifu_i1_bp_fghr    (ifu_i1_bp_fghr[i]),\n                                          .ifu_i1_bp_btag    (ifu_i1_bp_btag[i]),\n                                          .ifu_i1_bp_fa_index(ifu_i1_bp_fa_index[i]),\n                                          .ifu_i1_bp_toffset    (ifu_i1_bp_toffset[i]),\n                                          .ifu_i0_cinst      (ifu_i0_cinst[i]),\n                                          .ifu_i1_cinst      (ifu_i1_cinst[i]),\n\n                                          .dec_i1_cancel_e1  (dec_i1_cancel_e1[i]),\n                                          .exu_flush_final   (exu_flush_final[i]),\n                                          .ib3_valid_d       (ib3_valid_d[i]   ),\n                                          .ib2_valid_d       (ib2_valid_d[i]   ),\n                                          .ib1_valid_d       (ib1_valid_d[i]   ),\n                                          .ib0_valid_d       (ib0_valid_d[i]   ),\n                                          .ib0_valid_in      (ib0_valid_in[i]  ),\n                                          .ib0_lsu_in        (ib0_lsu_in[i]    ),\n                                          .ib0_mul_in        (ib0_mul_in[i]    ),\n                                          .ib0_i0_only_in    (ib0_i0_only_in[i]),\n                                          .i0_instr_d        (i0_instr_d[i]    ),\n                                          .i1_instr_d        (i1_instr_d[i]    ),\n                                          .i0_debug_valid_d  (i0_debug_valid_d[i]),\n                                          .i0_pc_d           (i0_pc_d[i]       ),\n                                          .i1_pc_d           (i1_pc_d[i]       ),\n                                          .i0_pc4_d          (i0_pc4_d[i]      ),\n                                          .i1_pc4_d          (i1_pc4_d[i]      ),\n                                          .i0_bp_index       (i0_bp_index[i]   ),\n                                          .i0_bp_fghr        (i0_bp_fghr[i]    ),\n                                          .i0_bp_btag        (i0_bp_btag[i]    ),\n                                          .i0_bp_fa_index    (i0_bp_fa_index[i]),\n                                          .i0_bp_toffset     (i0_bp_toffset[i] ),\n                                          .i1_bp_index       (i1_bp_index[i]   ),\n                                          .i1_bp_fghr        (i1_bp_fghr[i]    ),\n                                          .i1_bp_btag        (i1_bp_btag[i]    ),\n                                          .i1_bp_toffset     (i1_bp_toffset[i] ),\n                                          .i0_icaf_d         (i0_icaf_d[i]     ),\n             "}
{"text": "                             .i1_icaf_d         (i1_icaf_d[i]     ),\n                                          .i0_icaf_second_d  (i0_icaf_second_d[i]  ),\n                                          .i0_dbecc_d        (i0_dbecc_d[i]    ),\n                                          .i1_dbecc_d        (i1_dbecc_d[i]    ),\n                                          .debug_wdata_rs1_d (debug_wdata_rs1_d[i]),\n                                          .debug_fence_d     (debug_fence_d[i] ),\n                                          .i0_cinst_d        (i0_cinst_d[i]    ),\n                                          .i1_cinst_d        (i1_cinst_d[i]    ),\n                                          .i0_icaf_type_d    (i0_icaf_type_d[i]),\n                                          .i0_br_p           (i0_br_p[i]       ),\n                                          .i1_br_p           (i1_br_p[i]       ),\n                                          .i0_predecode      (i0_predecode_p[i]),\n                                          .i1_predecode      (i1_predecode_p[i]),\n                                          .*);\n\n\n  end // block: ib\n\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin : arf\n\n      eh2_dec_gpr_ctl #(.pt(pt)) arf (.*,\n                                       .clk (active_thread_l2clk[i]),\n                                       .tid (1'(i)),\n\n                                       .rtid0(dec_i0_tid_d),\n                                       .rtid1(dec_i0_tid_d),\n                                       .rtid2(dec_i1_tid_d),\n                                       .rtid3(dec_i1_tid_d),\n\n                                       // inputs\n                                       .raddr0(dec_i0_rs1_d[4:0]), .rden0(dec_i0_rs1_en_d),\n                                       .raddr1(dec_i0_rs2_d[4:0]), .rden1(dec_i0_rs2_en_d),\n                                       .raddr2(dec_i1_rs1_d[4:0]), .rden2(dec_i1_rs1_en_d),\n                                       .raddr3(dec_i1_rs2_d[4:0]), .rden3(dec_i1_rs2_en_d),\n\n                                       .wtid0(dec_i0_tid_wb),              .waddr0(dec_i0_waddr_wb[4:0]),            .wen0(dec_i0_wen_wb),            .wd0(dec_i0_wdata_wb[31:0]),\n                                       .wtid1(dec_i1_tid_wb),              .waddr1(dec_i1_waddr_wb[4:0]),            .wen1(dec_i1_wen_wb),            .wd1(dec_i1_wdata_wb[31:0]),\n                                       .wtid2(lsu_nonblock_load_data_tid), .waddr2(dec_nonblock_load_waddr[i][4:0]), .wen2(dec_nonblock_load_wen[i]), .wd2(lsu_nonblock_load_data[31:0]),\n                                       .wtid3(div_tid_wb),                 .waddr3(div_waddr_wb[4:0]),               .wen3(exu_div_wren),             .wd3(exu_div_result[31:0]),\n\n                                       // outputs\n                                       .rd0(gpr_i0rs1_d[i]), .rd1(gpr_i0rs2_d[i]),\n                                       .rd2(gpr_i1rs1_d[i]), .rd3(gpr_i1rs2_d[i])\n                                       );\n\n\n   end // block: arf\n\n\n\n\n   assign ready_in[pt.NUM_THREADS-1:0] = ib0_valid_in[pt.NUM_THREADS-1:0];\n   assign lsu_in[pt.NUM_THREADS-1:0] = ib0_lsu_in[pt.NUM_THREADS-1:0];\n   assign mul_in[pt.NUM_THREADS-1:0] = ib0_mul_in[pt.NUM_THREADS-1:0];\n   assign i0_only_in[pt.NUM_THREADS-1:0] = ib0_i0_only_in[pt.NUM_THREADS-1:0];\n\n   logic i0_sel_i0_t1_d;\n   logic [1:0] i1_sel_i0_d, i1_sel_i1_d;\n\n\n   if (pt.NUM_THREADS == 1) begin: genst\n      assign gpr_i0_rs1_d[31:0] = gpr_i0rs1_d[0];\n      assign gpr_i0_rs2_d[31:0] = gpr_i0rs2_d[0];\n      assign gpr_i1_rs1_d[31:0] = gpr_i1rs1_d[0];\n      assign gpr_i1_rs2_d[31:0] = gpr_i1rs2_d[0];\n\n      assign dec_i0_tid_d = 1'b0;\n      assign dec_i1_tid_d = 1'b0;\n\n      assign ready[0] = 1'b1;\n\n      assign i0_sel_i0_t1_d = 1'b0;\n      assign i1_sel_i0_d[1:0] = 2'b00;\n      assign i1_sel_i1_d[1:0] = 2'b01;\n\n   end\n\n   else begin: genmt\n\n      assign gpr_i0_rs1_d[31:0] = gpr_i0rs1_d[1] | gpr_i0rs1_d[0];\n      assign gpr_i0_rs2_d[31:0] = gpr_i0rs2_d[1] | gpr_i0rs2_d[0];\n      assign gpr_i1_rs1_d[31:0] = gpr_i1rs1_d[1] | gpr_i1rs1_d[0];\n      assign gpr_i1_rs2_d[31:0] = gpr_i1rs2_d[1] | gpr_i1rs2_d[0];\n\n\n\n      rvarbiter2_smt dec_arbiter (\n                                  .clk(active_clk),\n                                  .flush(exu_flush_final[1:0]),\n                                  .shift(dec_i0_decode_d),\n                                  .ready_in(ready_in[1:0]),\n                                  .lsu_in(lsu_in[1:0]),\n                                  .mul_in(mul_in[1:0]),\n                                  .i0_only_in(i0_only_in[1:0]),\n                                  .thread_stall_in(dec_thread_stall_in[1:0]),\n                                  .force_favor_flip(dec_force_favor_flip_d),\n                                  .ready(ready[1:0]),\n                                  .i0_sel_i0_t1(i0_sel_i0_t1_d),\n                                  .i1_sel_i0(i1_sel_i0_d[1:0]),\n                                  .i1_sel_i1(i1_sel_i1_d[1:0]),\n                                  .*\n                                  );\n\n      assign dec_i0_tid_d = i0_sel_i0_t1_d;\n\n      assign dec_i1_tid_d = i1_sel_i1_d[1] | i1_sel_i0_d[1];\n   end\n\n//   end // block: genmt\n\n\n   // send to aligner\n   assign dec_ib3_valid_d[pt.NUM_THREADS-1:0]       = ib3_valid_d[pt.NUM_THREADS-1:0];\n   assign dec_ib2_valid_d[pt.NUM_THREADS-1:0]       = ib2_valid_d[pt.NUM_THREADS-1:0];\n\n   assign dec_ib0_valid_d       = ib0_valid_d[dec_i0_tid_d] & ready[dec_i0_tid_d]     ;\n   assign dec_i0_instr_d        = i0_instr_d[dec_i0_tid_d]        ;\n   assign dec_i0_pc_d           = i0_pc_d[dec_i0_tid_d]           ;\n   assign dec_i0_pc4_d          = i0_pc4_d[dec_i0_tid_d]          ;\n   assign dec_i0_bp_index       = i0_bp_index[dec_i0_tid_d]       ;\n   assign dec_i0_bp_fghr        = i0_bp_fghr[dec_i0_tid_d]        ;\n   assign dec_i0_bp_btag        = i0_bp_btag[dec_i0_tid_d]        ;\n   assign dec_i0_bp_toffset     = i0_bp_toffset[dec_i0_tid_d]        ;\n   assign dec_i0_icaf_d         = i0_icaf_d[dec_i0_tid_d]         ;\n   assign dec_i0_icaf_second_d  = i0_icaf_second_d[dec_i0_tid_d]      ;\n   assign dec_i0_dbecc_d        = i0_dbecc_d[dec_i0_tid_d]        ;\n   assign dec_i0_cinst_d        = i0_cinst_d[dec_i0_tid_d]        ;\n   assign dec_i0_icaf_type_d    = i0_icaf_type_d[dec_i0_tid_d]    ;\n   assign dec_i0_brp            = i0_br_p[dec_i0_tid_d]           ;\n   assign dec_i0_predecode      = i0_predecode_p[dec_i0_tid_d]           ;\n\n   assign dec_i0_debug_valid_d  = i0_debug_valid_d[dec_i0_tid_d] ;\n\n   assign dec_i0_bp_fa_index    = i0_bp_fa_index[dec_i0_tid_d];\n\n   assign dec_debug_wdata_rs1_d = debug_wdata_rs1_d[dec_i0_tid_d] ;\n   assign dec_debug_fence_d     = debug_fence_d[dec_i0_tid_d]     ;\n\n   // only SMT is supported for threading\n   if (pt.NUM_THREADS==2 )  begin\n\n      // pipe is flushed; should not need ready[]\n      assign dec_i1_debug_valid_d  = (i1_sel_i0_d[0] & i0_debug_valid_d[0]) |\n                                     (i1_sel_i0_d[1] & i0_debug_valid_d[1]);\n\n      assign dec_ib1_valid_d       = (i1_sel_i0_d[0] & ib0_valid_d[0] & ready[0]) |\n                                     (i1_sel_i1_d[0] & ib1_valid_d[0] & ready[0]) |\n                                     (i1_sel_i0_d[1] & ib0_valid_d[1] & ready[1]) |\n                                     (i1_sel_i1_d[1] & ib1_valid_d[1] & ready[1]);\n\n\n      assign dec_i1_instr_d        = ({32{i1_sel_i0_d[0]}} & i0_instr_d[0]) |\n                                     ({32{i1_sel_i1_d[0]}} & i1_instr_d[0]) |\n                                     ({32{i1_sel_i0_d[1]}} & i0_instr_d[1]) |\n                                     ({32{i1_sel_i1_d[1]}} & i1_instr_d[1]);\n\n      assign dec_i1_pc_d           = ({31{i1_sel_i0_d[0]}} & i0_pc_d[0]) |\n                                     ({31{i1_sel_i1_d[0]}} & i1_pc_d[0]) |\n                                     ({31{i1_sel_i0_d[1]}} & i0_pc_d[1]) |\n                                     ({31{i1_sel_i1_d[1]}} & i1_pc_d[1]);\n\n      assign dec_i1_pc4_d          = (i1_sel_i0_d[0] & i0_pc4_d[0]) |\n                                     (i1_sel_i1_d[0] & i1_pc4_d[0]) |\n                                     (i1_sel_i0_d[1] & i0_pc4_d[1]) |\n                                     (i1_sel_i1_d[1] & i1_pc4_d[1]);\n\n\n      assign dec_i1_bp_index           = ({pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1{i1_sel_i0_d[0]}} & i0_bp_index[0]) |\n                                         ({pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1{i1_sel_i1_d[0]}} & i1_bp_index[0]) |\n                                         ({pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1{i1_sel_i0_d[1]}} & i0_bp_index[1]) |\n                                         ({pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1{i1_sel_i1_d[1]}} & i1_bp_index[1]);\n\n      assign dec_i1_bp_fghr            = ({pt.BHT_GHR_SIZE{i1_sel_i0_d[0]}} & i0_bp_fghr[0]) |\n                                         ({pt.BHT_GHR_SIZE{i1_sel_i1_d[0]}} & i1_bp_fghr[0]) |\n                                         ({pt.BHT_GHR_SIZE{i1_sel_i0_d[1]}} & i0_bp_fghr[1]) |\n                                         ({pt.BHT_GHR_SIZE{i1_sel_i1_d[1]}} & i1_bp_fghr[1]);\n\n      assign dec_i1_bp_btag            = ({pt.BTB_BTAG_SIZE{i1_sel_i0_d[0]}} & i0_bp_btag[0]) |\n                                         ({pt.BTB_BTAG_SIZE{i1_sel_i1_d[0]}} & i1_bp_btag[0]) |\n                                         ({pt.BTB_BTAG_SIZE{i1_sel_i0_d[1]}} & i0_bp_btag[1]) |\n                                         ({pt.BTB_BTAG_SIZE{i1_sel_i1_d[1]}} & i1_bp_btag[1]);\n\n      assign dec_i1_bp_toffset            = ({pt.BTB_TOFFSET_SIZE{i1_sel_i0_d[0]}} & i0_bp_toffset[0]) |\n                                         ({pt.BTB_TOFFSET_SIZE{i1_sel_i1_d[0]}} & i1_bp_toffset[0]) |\n                                         ({pt.BTB_TOFFSET_SIZE{i1_sel_i0_d[1]}} & i0_bp_toffset[1]) |\n                                         ({pt.BTB_TOFFSET_SIZE{i1_sel_i1_d[1]}} & i1_bp_toffset[1]);\n\n      assign dec_i1_icaf_d          = (i1_sel_i0_d[0] & i0_icaf_d[0]) |\n                                      (i1_sel_i1_d[0] & i1_icaf_d[0]) |\n                                      (i1_sel_i0_d[1] & i0_icaf_d[1]) |\n                                      (i1_sel_i1_d[1] & i1_icaf_d[1]);\n\n      assign dec_i1_dbecc_d          = (i1_sel_i0_d[0] & i0_dbecc_d[0]) |\n                                       (i1_sel_i1_d[0] & i1_dbecc_d[0]) |\n                                       (i1_sel_i0_d[1] & i0_dbecc_d[1]) |\n                                       (i1_sel_i1_d[1] & i1_dbecc_d[1]);\n\n      assign dec_i1_cinst_d         = ({16{i1_sel_i0_d[0]}} & i0_cinst_d[0]) |\n                                      ({16{i1_sel_i1_d[0]}} & i1_cinst_d[0]) |\n                                      ({16{i1_sel_i0_d[1]}} & i0_cinst_d[1]) |\n                                      ({16{i1_sel_i1_d[1]}} & i1_cinst_d[1]);\n\n      assign dec_i1_brp                 = ({$bits(eh2_br_pkt_t){i1_sel_i0_d[0]}} & i0_br_p[0]) |\n                                          ({$bits(eh2_br_pkt_t){i1_sel_i1_d[0]}} & i1_br_p[0]) |\n                                          ({$bits(eh2_br_pkt_t){i1_sel_i0_d[1]}} & i0_br_p[1]) |\n                                          ({$bits(eh2_br_pkt_t){i1_sel_i1_d[1]}} & i1_br_p[1]);\n\n      assign dec_i1_predecode                 = ({$bits(eh2_predecode_pkt_t){i1_sel_i0_d[0]}} & i0_predecode_p[0]) |\n                                                ({$bits(eh2_predecode_pkt_t){i1_sel_i1_d[0]}} & i1_predecode_p[0]) |\n                                                ({$bits(eh2_predecode_pkt_t){i1_sel_i0_d[1]}} & i0_predecode_p[1]) |\n                                                ({$bits(eh2_predecode_pkt_t){i1_sel_i1_d[1]}} & i1_predecode_p[1]);\n\n   end\n   else begin\n      assign dec_i1_debug_valid_d  = '0;   // for 1 thread cannot have debug commands in i1\n\n      assign dec_ib1_valid_d       = ib1_valid_d[dec_i1_tid_d] & ready[dec_i1_tid_d];\n      assign dec_i1_instr_d        = i1_instr_d[dec_i1_tid_d]        ;\n      assign dec_i1_pc_d           = i1_pc_d[dec_i1_tid_d]           ;\n      assign dec_i1_pc4_d          = i1_pc4_d[dec_i1_tid_d]          ;\n      assign dec_i1_bp_index       = i1_bp_index[dec_i1_tid_d]       ;\n      assign dec_i1_bp_fghr        = i1_bp_fghr[dec_i1_tid_d]        ;\n      assign dec_i1_bp_btag        = i1_bp_btag[dec_i1_tid_d]        ;\n      assign dec_i1_bp_toffset     = i1_bp_toffset[dec_i1_tid_d]     ;\n      assign dec_i1_icaf_d         = i1_icaf_d[dec_i1_tid_d]         ;\n      assign dec_i1_dbecc_d        = i1_dbecc_d[dec_i1_tid_d]        ;\n      assign dec_i1_cinst_d        = i1_cinst_d[dec_i1_tid_d]        ;\n      assign dec_i1_brp            = i1_br_p[dec_i1_tid_d]           ;\n      assign dec_i1_predecode      = i1_predecode_p[dec_i1_tid_d]    ;\n\n\n   end\n\n\n   eh2_dec_decode_ctl #(.pt(pt)) decode (\n                                          .*);\n\n   eh2_dec_tlu_top #(.pt(pt)) tlu (.*);\n\n\n// Trigger\n\n   eh2_dec_trigger #(.pt(pt)) dec_trigger (.*);\n\n\n\n\n// trace\n   // also need retires_p==2\n     for (genvar i=0; i<pt.NUM_THREADS; i++) begin : tracep\n\n        assign trace_rv_trace_pkt[i].trace_rv_i_insn_ip    = { dec_i1_inst_wb1[31:0],     dec_i0_inst_wb1[31:0] };\n        assign trace_rv_trace_pkt[i].trace_rv_i_address_ip = { dec_i1_pc_wb1[31:1], 1'b0, dec_i0_pc_wb1[31:1], 1'b0 };\n\n        assign trace_rv_trace_pkt[i].trace_rv_i_valid_ip =     {\n                                                                                           dec_tlu_i1_valid_wb1[i] | dec_tlu_i1_exc_valid_wb1[i],\n                                                                dec_tlu_int_valid_wb1[i] | dec_tlu_i0_valid_wb1[i] | dec_tlu_i0_exc_valid_wb1[i]\n                                                                };\n        assign trace_rv_trace_pkt[i].trace_rv_i_exception_ip = {dec_tlu_i1_exc_valid_wb1[i],\n                                                                dec_tlu_int_valid_wb1[i] | dec_tlu_i0_exc_valid_wb1[i]};\n\n        assign trace_rv_trace_pkt[i].trace_rv_i_ecause_ip =     dec_tlu_exc_cause_wb1[i][4:0];  // replicate across ports\n        assign trace_rv_trace_pkt[i].trace_rv_i_interrupt_ip = {1'b0, dec_tlu_int_valid_wb1[i]};\n        assign trace_rv_trace_pkt[i].trace_rv_i_tval_ip =    dec_tlu_mtval_wb1[i][31:0];        // replicate across ports\n     end\n\n\n// end trace\n\nendmodule // dec\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2019 Western Digital Corporation or it's affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n//********************************************************************************\n// eh2_dec_csr.sv\n//\n//\n// Function: CSR decodes\n//********************************************************************************\n\n\nmodule eh2_dec_csr\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n\n\ninput logic [11:0] dec_csr_rdaddr_d,\ninput logic dec_csr_any_unq_d,\ninput logic dec_csr_wen_unq_d,\ninput logic dec_tlu_dbg_halted,\n\noutput logic dec_csr_legal_d,\noutput logic tlu_presync_d,\noutput logic tlu_postsync_d,\n\noutput eh2_csr_tlu_pkt_t tlu_csr_pkt_d\n);\n\n\n// file \"csrdecode\" is human readable file that has all of the CSR decodes defined and is part of git repo\n// modify this file as needed\n\n// to generate all the equations below from \"csrdecode\" except legal equation:\n// 1) coredecode -in csrdecode > corecsrdecode.e\n// 2) espresso -Dso -oeqntott corecsrdecode.e | addassign  > csrequations\n\n// to generate the legal CSR equation below:\n// 1) coredecode -in csrdecode -legal > csrlegal.e\n// 2) espresso -Dso -oeqntott csrlegal.e | addassign  > csrlegal_equation\n\n// coredecode -in csrdecode > corecsrdecode.e; espresso -Dso -oeqntott corecsrdecode.e | addassign  > csrequations; coredecode -in csrdecode -legal > csrlegal.e; espresso -Dso -oeqntott csrlegal.e | addassign  > csrlegal_equation\n\n\n// insert \"csrequations\" here\nlogic csr_misa;\nlogic csr_mvendorid;\nlogic csr_marchid;\nlogic csr_mimpid;\nlogic csr_mhartid;\nlogic csr_mstatus;\nlogic csr_mtvec;\nlogic csr_mip;\nlogic csr_mie;\nlogic csr_mcyclel;\nlogic csr_mcycleh;\nlogic csr_minstretl;\nlogic csr_minstreth;\nlogic csr_mscratch;\nlogic csr_mepc;\nlogic csr_mcause;\nlogic csr_mscause;\nlogic csr_mtval;\nlogic csr_mrac;\nlogic csr_dmst;\nlogic csr_mdseac;\nlogic csr_meihap;\nlogic csr_meivt;\nlogic csr_meipt;\nlogic csr_meicurpl;\nlogic csr_meicidpl;\nlogic csr_dcsr;\nlogic csr_mcgc;\nlogic csr_mfdc;\nlogic csr_dpc;\nlogic csr_mtsel;\nlogic csr_mtdata1;\nlogic csr_mtdata2;\nlogic csr_mhpmc3;\nlogic csr_mhpmc4;\nlogic csr_mhpmc5;\nlogic csr_mhpmc6;\nlogic csr_mhpmc3h;\nlogic csr_mhpmc4h;\nlogic csr_mhpmc5h;\nlogic csr_mhpmc6h;\nlogic csr_mhpme3;\nlogic csr_mhpme4;\nlogic csr_mhpme5;\nlogic csr_mhpme6;\nlogic csr_mitctl0;\nlogic csr_mitctl1;\nlogic csr_mitb0;\nlogic csr_mitb1;\nlogic csr_mitcnt0;\nlogic csr_mitcnt1;\nlogic csr_perfva;\nlogic csr_perfvb;\nlogic csr_perfvc;\nlogic csr_perfvd;\nlogic csr_perfve;\nlogic csr_perfvf;\nlogic csr_perfvg;\nlogic csr_perfvh;\nlogic csr_perfvi;\nlogic csr_mpmc;\nlogic csr_mcpc;\nlogic csr_meicpct;\nlogic csr_mdeau;\nlogic csr_micect;\nlogic csr_miccmect;\nlogic csr_mdccmect;\nlogic csr_mcountinhibit;\nlogic csr_mfdht;\nlogic csr_mfdhs;\nlogic csr_dicawics;\nlogic csr_dicad0h;\nlogic csr_dicad0;\nlogic csr_dicad1;\nlogic csr_dicago;\nlogic csr_mhartnum;\nlogic csr_mhartstart;\nlogic csr_mnmipdel;\nlogic valid_only;\nlogic presync;\nlogic postsync;\nlogic glob;\n//logic ooat;\n\nlogic conditionally_illegal, valid_csr;\nlogic legal;\n\nassign csr_misa = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]);\n\nassign csr_mvendorid = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_marchid = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mimpid = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_mhartid = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[2]);\n\nassign csr_mstatus = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mtvec = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]);\n\nassign csr_mip = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[2]);\n\nassign csr_mie = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mcyclel = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]);\n\nassign csr_mcycleh = (dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]);\n\nassign csr_minstretl = (!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_minstreth = (!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mscratch = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mepc = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mcause = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mscause = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_mtval = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mrac = (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]);\n\nassign csr_dmst = (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]);\n\nassign csr_mdseac = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]);\n\nassign csr_meihap = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[3]);\n\nassign csr_meivt = (!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]);\n\nassign csr_meipt = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_meicurpl = (!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]);\n\nassign csr_meicidpl = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_dcsr = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mcgc = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mfdc = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_dpc = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[0]);\n\nassign csr_mtsel = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mtdata1 = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[0]);\n\nassign csr_mtdata2 = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[1]);\n\nassign csr_mhpmc3 = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc4 = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc5 = (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc6 = (!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc3h = (dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc4h = (dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc5h = (dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mhpmc6h = (dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mhpme3 = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mhpme4 = (dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]);\n\nassign csr_mhpme5 = (dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_mhpme6 = (dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]);\n\nassign csr_mitctl0 = (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mitctl1 = (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[3]\n    &dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_mitb0 = (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]);\n\nassign csr_mitb1 = (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]\n    &dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mitcnt0 = (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mitcnt1 = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_mpmc = (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]);\n\nassign csr_mcpc = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]);\n\nassign csr_meicpct = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mdeau = (!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[3]);\n\nassign csr_micect = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_miccmect = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[0]);\n\nassign csr_mdccmect = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]);\n\nassign csr_mcountinhibit = (!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[0]);\n\nassign csr_mfdht = (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n    &dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_mfdhs = (dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[0]);\n\nassign csr_dicawics = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]);\n\nassign csr_dicad0h = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]\n    &dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]);\n\nassign csr_dicad0 = (dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]\n    &dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_dicad1 = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign csr_dicago = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]);\n\nassign csr_mhartnum = (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[2]);\n\nassign csr_mhartstart = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]);\n\nassign csr_mnmipdel = (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]);\n\nassign presync = (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]) | (dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]) | (dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]);\n\nassign postsync = (dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[2]\n    &dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]) | (\n    !dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[1]\n    &dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[1]) | (!dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]) | (\n    dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]);\n\nassign glob = (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[2]) | (dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]) | (\n    dec_csr_rdaddr_d[10]&!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[2]) | (dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]);\n\n   // insert \"csrlegal_equation\" here\nassign legal = (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]) | (!dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[0]) | (\n    dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n    &dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]\n    &dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]) | (\n    !dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[2]\n    &!dec_csr_rdaddr_d[1]) | (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[2]) | (!dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]) | (dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]\n    &!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&dec_csr_rdaddr_d[1]) | (!dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[1]&dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]\n    &dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[1]) | (\n    !dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &dec_csr_rdaddr_d[2]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[2]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&dec_csr_rdaddr_d[1]) | (\n    dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]\n    "}
{"text": "&!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[1]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]) | (\n    !dec_csr_rdaddr_d[11]&dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]\n    &dec_csr_rdaddr_d[8]&dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]\n    &dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[2]&!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]\n    &dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &!dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[2]) | (\n    dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &dec_csr_rdaddr_d[7]&dec_csr_rdaddr_d[6]&!dec_csr_rdaddr_d[5]\n    &!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]&!dec_csr_rdaddr_d[1]\n    &!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[7]\n    &!dec_csr_rdaddr_d[5]&!dec_csr_rdaddr_d[4]&!dec_csr_rdaddr_d[3]\n    &!dec_csr_rdaddr_d[1]&!dec_csr_rdaddr_d[0]) | (!dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[3]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[3]) | (!dec_csr_rdaddr_d[11]\n    &!dec_csr_rdaddr_d[10]&dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]\n    &!dec_csr_rdaddr_d[7]&!dec_csr_rdaddr_d[6]&dec_csr_rdaddr_d[5]\n    &dec_csr_rdaddr_d[4]) | (dec_csr_rdaddr_d[11]&!dec_csr_rdaddr_d[10]\n    &dec_csr_rdaddr_d[9]&dec_csr_rdaddr_d[8]&!dec_csr_rdaddr_d[6]\n    &!dec_csr_rdaddr_d[5]&dec_csr_rdaddr_d[4]);\n\n\n\n//\n   assign tlu_presync_d = presync & dec_csr_any_unq_d & ~dec_csr_wen_unq_d;\n   assign tlu_postsync_d = postsync & dec_csr_any_unq_d;\n\n   // allow individual configuration of these features\n   assign conditionally_illegal = ((csr_mitcnt0 | csr_mitcnt1 | csr_mitb0 | csr_mitb1 | csr_mitctl0 | csr_mitctl1) & !pt.TIMER_LEGAL_EN) |\n                                  (csr_meicpct & pt.FAST_INTERRUPT_REDIRECT);\n\n   assign valid_csr = ( legal &\n                        // not a debug only csr during running mode\n                        (~(csr_dcsr | csr_dpc | csr_dmst | csr_dicawics | csr_dicad0 | csr_dicad0h | csr_dicad1 | csr_dicago) | dec_tlu_dbg_halted) &\n                        // not conditionally illegal based on configuration\n                        ~conditionally_illegal\n                        );\n\n   assign dec_csr_legal_d = ( dec_csr_any_unq_d &\n                              valid_csr &          // of a valid CSR\n                              ~(dec_csr_wen_unq_d & (csr_mvendorid | csr_marchid | csr_mimpid | csr_mhartid |\n                                                     csr_mdseac | csr_meihap | csr_mhartnum)) // that's not a write to a RO CSR\n                              );\n\n\n\n   assign tlu_csr_pkt_d.csr_misa = csr_misa;\n   assign tlu_csr_pkt_d.csr_mvendorid = csr_mvendorid;\n   assign tlu_csr_pkt_d.csr_marchid = csr_marchid;\n   assign tlu_csr_pkt_d.csr_mimpid = csr_mimpid;\n   assign tlu_csr_pkt_d.csr_mhartid = csr_mhartid;\n   assign tlu_csr_pkt_d.csr_mstatus = csr_mstatus;\n   assign tlu_csr_pkt_d.csr_mtvec = csr_mtvec;\n   assign tlu_csr_pkt_d.csr_mip = csr_mip;\n   assign tlu_csr_pkt_d.csr_mie = csr_mie;\n   assign tlu_csr_pkt_d.csr_mcyclel = csr_mcyclel;\n   assign tlu_csr_pkt_d.csr_mcycleh = csr_mcycleh;\n   assign tlu_csr_pkt_d.csr_minstretl = csr_minstretl;\n   assign tlu_csr_pkt_d.csr_minstreth = csr_minstreth;\n   assign tlu_csr_pkt_d.csr_mscratch = csr_mscratch;\n   assign tlu_csr_pkt_d.csr_mepc = csr_mepc;\n   assign tlu_csr_pkt_d.csr_mcause = csr_mcause;\n   assign tlu_csr_pkt_d.csr_mscause = csr_mscause;\n   assign tlu_csr_pkt_d.csr_mtval = csr_mtval;\n   assign tlu_csr_pkt_d.csr_mrac = csr_mrac;\n   assign tlu_csr_pkt_d.csr_dmst = csr_dmst;\n   assign tlu_csr_pkt_d.csr_mdseac = csr_mdseac;\n   assign tlu_csr_pkt_d.csr_meihap = csr_meihap;\n   assign tlu_csr_pkt_d.csr_meivt = csr_meivt;\n   assign tlu_csr_pkt_d.csr_meipt = csr_meipt;\n   assign tlu_csr_pkt_d.csr_meicurpl = csr_meicurpl;\n   assign tlu_csr_pkt_d.csr_meicidpl = csr_meicidpl;\n   assign tlu_csr_pkt_d.csr_dcsr = csr_dcsr;\n   assign tlu_csr_pkt_d.csr_mcgc = csr_mcgc;\n   assign tlu_csr_pkt_d.csr_mfdc = csr_mfdc;\n   assign tlu_csr_pkt_d.csr_dpc = csr_dpc;\n   assign tlu_csr_pkt_d.csr_mtsel = csr_mtsel;\n   assign tlu_csr_pkt_d.csr_mtdata1 = csr_mtdata1;\n   assign tlu_csr_pkt_d.csr_mtdata2 = csr_mtdata2;\n   assign tlu_csr_pkt_d.csr_mhpmc3 = csr_mhpmc3;\n   assign tlu_csr_pkt_d.csr_mhpmc4 = csr_mhpmc4;\n   assign tlu_csr_pkt_d.csr_mhpmc5 = csr_mhpmc5;\n   assign tlu_csr_pkt_d.csr_mhpmc6 = csr_mhpmc6;\n   assign tlu_csr_pkt_d.csr_mhpmc3h = csr_mhpmc3h;\n   assign tlu_csr_pkt_d.csr_mhpmc4h = csr_mhpmc4h;\n   assign tlu_csr_pkt_d.csr_mhpmc5h = csr_mhpmc5h;\n   assign tlu_csr_pkt_d.csr_mhpmc6h = csr_mhpmc6h;\n   assign tlu_csr_pkt_d.csr_mhpme3 = csr_mhpme3;\n   assign tlu_csr_pkt_d.csr_mhpme4 = csr_mhpme4;\n   assign tlu_csr_pkt_d.csr_mhpme5 = csr_mhpme5;\n   assign tlu_csr_pkt_d.csr_mhpme6 = csr_mhpme6;\n   assign tlu_csr_pkt_d.csr_mitctl0 = csr_mitctl0;\n   assign tlu_csr_pkt_d.csr_mitctl1 = csr_mitctl1;\n   assign tlu_csr_pkt_d.csr_mitb0 = csr_mitb0;\n   assign tlu_csr_pkt_d.csr_mitb1 = csr_mitb1;\n   assign tlu_csr_pkt_d.csr_mitcnt0 = csr_mitcnt0;\n   assign tlu_csr_pkt_d.csr_mitcnt1 = csr_mitcnt1;\n   assign tlu_csr_pkt_d.csr_mpmc = csr_mpmc;\n   assign tlu_csr_pkt_d.csr_mcountinhibit = csr_mcountinhibit;\n   assign tlu_csr_pkt_d.csr_mcpc = csr_mcpc;\n   assign tlu_csr_pkt_d.csr_meicpct = csr_meicpct;\n   assign tlu_csr_pkt_d.csr_mdeau = csr_mdeau;\n   assign tlu_csr_pkt_d.csr_micect = csr_micect;\n   assign tlu_csr_pkt_d.csr_miccmect = csr_miccmect;\n   assign tlu_csr_pkt_d.csr_mdccmect = csr_mdccmect;\n   assign tlu_csr_pkt_d.csr_dicawics = csr_dicawics;\n   assign tlu_csr_pkt_d.csr_dicad0h = csr_dicad0h;\n   assign tlu_csr_pkt_d.csr_dicad0 = csr_dicad0;\n   assign tlu_csr_pkt_d.csr_dicad1 = csr_dicad1;\n   assign tlu_csr_pkt_d.csr_dicago = csr_dicago;\n   assign tlu_csr_pkt_d.csr_mfdht = csr_mfdht;\n   assign tlu_csr_pkt_d.csr_mfdhs = csr_mfdhs;\n   assign tlu_csr_pkt_d.csr_mhartnum = csr_mhartnum;\n   assign tlu_csr_pkt_d.csr_mhartstart = csr_mhartstart;\n   assign tlu_csr_pkt_d.csr_mnmipdel = csr_mnmipdel;\n   assign tlu_csr_pkt_d.valid_only = valid_only;\n   assign tlu_csr_pkt_d.presync = presync;\n   assign tlu_csr_pkt_d.postsync = postsync;\n   assign tlu_csr_pkt_d.glob = glob;\n   assign tlu_csr_pkt_d.legal = legal;\n\nendmodule"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nmodule eh2_dec_decode_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n   input logic [pt.NUM_THREADS-1:0] active_thread_l2clk,\n\n   input dec_i0_debug_valid_d,\n   input dec_i1_debug_valid_d,\n\n   input logic dec_i0_csr_global_d,\n\n   input eh2_predecode_pkt_t dec_i0_predecode,\n   input eh2_predecode_pkt_t dec_i1_predecode,\n\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_force_halt, // invalidate nonblock load cam on a force halt event\n\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_debug_stall, // stall decode while waiting on core to empty\n\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_flush_extint,\n\n   input logic dec_i0_tid_d,\n   input logic dec_i1_tid_d,\n\n   output logic dec_i0_pc4_e4,\n   output logic dec_i1_pc4_e4,\n\n   output logic         dec_i0_debug_valid_wb,\n\n   output logic         dec_i0_secondary_d,   // for power\n   output logic         dec_i0_secondary_e1,\n   output logic         dec_i0_secondary_e2,\n\n   output logic         dec_i1_secondary_d,\n   output logic         dec_i1_secondary_e1,\n   output logic         dec_i1_secondary_e2,\n\n   output logic         dec_i0_branch_d,\n   output logic         dec_i0_branch_e1,\n   output logic         dec_i0_branch_e2,\n   output logic         dec_i0_branch_e3,\n\n   output logic         dec_i1_branch_d,\n   output logic         dec_i1_branch_e1,\n   output logic         dec_i1_branch_e2,\n   output logic         dec_i1_branch_e3,\n\n   output logic dec_div_cancel,       // cancel divide operation\n\n   output logic dec_extint_stall,\n\n   input logic [15:0] dec_i0_cinst_d,         // 16b compressed instruction\n   input logic [15:0] dec_i1_cinst_d,\n\n   output logic [31:0] dec_i0_inst_wb1,       // 32b instruction at wb+1 for trace encoder\n   output logic [31:0] dec_i1_inst_wb1,\n\n   output logic [31:1] dec_i0_pc_wb1,         // 31b pc at wb+1 for trace encoder\n   output logic [31:1] dec_i1_pc_wb1,\n\n\n   output logic [pt.NUM_THREADS-1:0] dec_i1_cancel_e1,\n\n   input logic [31:0] lsu_rs1_dc1,\n\n   input logic                                lsu_nonblock_load_valid_dc1,     // valid nonblock load at dc3\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_tag_dc1,       // -> corresponding tag\n   input logic                                lsu_nonblock_load_inv_dc2,       // invalidate request for nonblock load dc2\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_inv_tag_dc2,   // -> corresponding tag\n   input logic                                lsu_nonblock_load_inv_dc5,       // invalidate request for nonblock load dc5\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_inv_tag_dc5,   // -> corresponding tag\n   input logic                                lsu_nonblock_load_data_valid,    // valid nonblock load data back\n   input logic                                lsu_nonblock_load_data_error,    // nonblock load bus error\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_data_tag,      // -> corresponding tag\n   input logic                                lsu_nonblock_load_data_tid,\n\n\n   input logic [31:0]                         lsu_nonblock_load_data,          // nonblock load data\n\n   input logic [3:0] dec_i0_trigger_match_d,          // i0 decode trigger matches\n   input logic [3:0] dec_i1_trigger_match_d,          // i1 decode trigger matches\n\n   input logic [pt.NUM_THREADS-1:0]           dec_tlu_wr_pause_wb,                   // pause instruction at wb\n\n   input logic dec_tlu_pipelining_disable,            // pipeline disable - presync, i0 decode only\n   input logic dec_tlu_dual_issue_disable,            // i0 decode only\n   input logic dec_tlu_trace_disable,                 // trace disable\n\n   input logic [3:0]  lsu_trigger_match_dc4,          // lsu trigger matches\n\n   input logic[pt.NUM_THREADS-1:0] lsu_pmu_misaligned_dc3,                // perf mon: load/store misalign\n\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_flush_leak_one_wb,             // leak1 instruction\n\n   input logic dec_debug_fence_d,                     // debug fence instruction\n\n   input logic [1:0] dbg_cmd_wrdata,                  // disambiguate fence, fence_i\n\n   input logic dec_i0_icaf_d,                         // icache access fault\n   input logic dec_i1_icaf_d,\n   input logic dec_i0_icaf_second_d,                      // i0 instruction access fault at decode for second 2B of 4B inst\n   input logic [1:0] dec_i0_icaf_type_d,              // i0 instruction access fault type\n\n   input logic dec_i0_dbecc_d,                        // icache/iccm double-bit error\n   input logic dec_i1_dbecc_d,\n\n   input eh2_br_pkt_t dec_i0_brp,                         // branch packet\n   input eh2_br_pkt_t dec_i1_brp,\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_i0_bp_index,            // i0 branch index\n   input logic [pt.BHT_GHR_SIZE-1:0] dec_i0_bp_fghr, // BP FGHR\n   input logic [pt.BTB_BTAG_SIZE-1:0] dec_i0_bp_btag, // BP tag\n   input logic [pt.BTB_TOFFSET_SIZE-1:0] dec_i0_bp_toffset, // BP tag\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_i1_bp_index,            // i0 branch index\n   input logic [pt.BHT_GHR_SIZE-1:0] dec_i1_bp_fghr, // BP FGHR\n   input logic [pt.BTB_BTAG_SIZE-1:0] dec_i1_bp_btag, // BP tag\n   input logic [pt.BTB_TOFFSET_SIZE-1:0] dec_i1_bp_toffset, // BP tag\n\n   input logic [$clog2(pt.BTB_SIZE)-1:0] dec_i0_bp_fa_index,          // Fully associt btb index (only care about i0 for errors)\n\n   input logic [pt.NUM_THREADS-1:0]  lsu_idle_any,                          // lsu idle: if fence instr & ~lsu_idle then stall decode\n   input logic [pt.NUM_THREADS-1:0]  lsu_load_stall_any,                    // stall any load  at decode\n   input logic [pt.NUM_THREADS-1:0]  lsu_store_stall_any,                   // stall any store at decode\n   input logic [pt.NUM_THREADS-1:0]  lsu_amo_stall_any,         // This is for blocking amo\n\n   input logic dma_dccm_stall_any,                    // stall any load/store at decode\n\n   input logic exu_div_wren,                          // div finish this cycle\n\n   input logic dec_tlu_i0_kill_writeb_wb,    // I0 is flushed, don't writeback any results to arch state\n   input logic dec_tlu_i1_kill_writeb_wb,    // I1 is flushed, don't writeback any results to arch state\n\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_flush_lower_wb,          // trap lower flush\n\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_flush_pause_wb,          // don't clear pause state on initial lower flush\n\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_presync_d,               // CSR read needs to be presync'd\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_postsync_d,              // CSR ops that need to be postsync'd\n\n   input logic [31:0] exu_mul_result_e3,        // multiply result\n\n   input logic dec_i0_pc4_d,               // inst is 4B inst else 2B\n   input logic dec_i1_pc4_d,\n\n\n\n   input logic [31:0] lsu_result_dc3,      // load result\n   input logic [31:0] lsu_result_corr_dc4, // load result - corrected data for writing gprs; not for bypassing\n\n   input logic        lsu_sc_success_dc5,   // store conditional matched ( 1 = success, which means the GPR should write 0 )\n\n   input logic [pt.NUM_THREADS-1:0] exu_i0_flush_final,         // lower flush or i0 flush at e2\n   input logic [pt.NUM_THREADS-1:0] exu_i1_flush_final,         // lower flush or i1 flush at e2\n\n\n   input logic [31:1] exu_i0_pc_e1,        // pcs at e1\n   input logic [31:1] exu_i1_pc_e1,\n\n   input logic [31:0] dec_i0_instr_d,      // inst at decode\n   input logic [31:0] dec_i1_instr_d,\n\n   input logic  dec_ib0_valid_d,          // inst valid at decode\n   input logic  dec_ib1_valid_d,\n\n   input logic [31:0] exu_i0_result_e1,    // from primary alu's\n   input logic [31:0] exu_i1_result_e1,\n\n   input logic [31:0] exu_i0_result_e4,    // from secondary alu's\n   input logic [31:0] exu_i1_result_e4,\n\n   input logic  clk,                       // for rvdffe's\n   input logic active_clk,\n\n   input logic  free_l2clk,\n\n   input logic  clk_override,              // test stuff\n   input logic  rst_l,\n\n\n   output logic         dec_i0_rs1_en_d,   // rs1 enable at decode\n   output logic         dec_i0_rs2_en_d,\n\n   output logic [4:0] dec_i0_rs1_d,        // rs1 logical source\n   output logic [4:0] dec_i0_rs2_d,\n\n   output logic dec_i0_tid_e4, // needed to maintain RS in BP\n   output logic dec_i1_tid_e4,\n\n   output logic [31:0] dec_i0_immed_d,     // 32b immediate data decode\n\n   output logic          dec_i1_rs1_en_d,\n   output logic          dec_i1_rs2_en_d,\n\n   output logic [4:0]  dec_i1_rs1_d,\n   output logic [4:0]  dec_i1_rs2_d,\n\n\n\n   output logic [31:0] dec_i1_immed_d,\n\n   output logic [pt.BTB_TOFFSET_SIZE:1] dec_i0_br_immed_d,    // 12b branch immediate\n   output logic [pt.BTB_TOFFSET_SIZE:1] dec_i1_br_immed_d,\n\n   output eh2_alu_pkt_t i0_ap,                   // alu packets\n   output eh2_alu_pkt_t i1_ap,\n\n   output logic          dec_i0_decode_d,    // i0 decode\n   output logic          dec_i1_decode_d,\n\n   output logic          dec_i0_alu_decode_d,   // decode to primary alu's\n   output logic          dec_i1_alu_decode_d,\n\n\n   output logic [31:0] i0_rs1_bypass_data_d,    // i0 rs1 bypass data\n   output logic [31:0] i0_rs2_bypass_data_d,    // i0 rs2 bypass data\n   output logic [31:0] i1_rs1_bypass_data_d,\n   output logic [31:0] i1_rs2_bypass_data_d,\n\n\n   output logic [4:0]  dec_i0_waddr_wb,         // i0 logical source to write to gpr's\n   output logic          dec_i0_wen_wb,         // i0 write enable\n   output logic          dec_i0_tid_wb,         // i0 write tid\n   output logic [31:0] dec_i0_wdata_wb,         // i0 write data\n\n   output logic [4:0]  dec_i1_waddr_wb,\n   output logic          dec_i1_wen_wb,\n   output logic          dec_i1_tid_wb,\n   output logic [31:0] dec_i1_wdata_wb,\n\n   output logic          dec_i0_select_pc_d,    // i0 select pc for rs1 - branches\n   output logic          dec_i1_select_pc_d,\n\n   output logic dec_i0_rs1_bypass_en_d,         // i0 rs1 bypass enable\n   output logic dec_i0_rs2_bypass_en_d,         // i0 rs2 bypass enable\n   output logic dec_i1_rs1_bypass_en_d,\n   output logic dec_i1_rs2_bypass_en_d,\n\n   output eh2_lsu_pkt_t    lsu_p,                   // load/store packet\n\n   output eh2_mul_pkt_t    mul_p,                   // multiply packet\n\n   output eh2_div_pkt_t    div_p,                   // divide packet\n   output logic             div_tid_wb,              // DIV write tid     to GPR\n   output logic [4:0]       div_waddr_wb,            // DIV write address to GPR\n\n   output logic [11:0] dec_lsu_offset_d,\n   output logic        dec_i0_lsu_d,        // chose which gpr value to use\n   output logic        dec_i1_lsu_d,\n   output logic        dec_i0_mul_d,        // chose which gpr value to use\n   output logic        dec_i1_mul_d,\n\n   output logic        dec_i0_div_d,        // chose which gpr value to use\n\n   output logic [pt.NUM_THREADS-1:0]       flush_final_e3,      // flush final at e3: i0  or i1\n   output logic [pt.NUM_THREADS-1:0]       i0_flush_final_e3,   // i0 flush final at e3\n\n// CSR interface\n   input logic [31:0]  dec_i0_csr_rddata_d,    // csr read data at wb\n   input logic         dec_i0_csr_legal_d,            // csr indicates legal operation\n   input logic [31:0]  exu_i0_csr_rs1_e1,      // rs1 for csr instr\n\n\n   output logic        dec_i0_csr_ren_d,       // valid csr decode\n   output logic        dec_i0_csr_wen_unq_d,       // valid csr with write - for csr legal\n   output logic        dec_i0_csr_any_unq_d,       // valid csr - for csr legal\n   output logic        dec_i0_csr_wen_wb,      // csr write enable at wb\n   output logic [11:0] dec_i0_csr_rdaddr_d,      // read address for csr\n   output logic [11:0] dec_i0_csr_wraddr_wb,     // write address for csr\n   output logic [31:0] dec_i0_csr_wrdata_wb,   // csr write data at wb\n   output logic        dec_i0_csr_is_mcpc_e4,     // csr address is to MCPC\n\n   output logic [pt.NUM_THREADS-1:0] dec_csr_stall_int_ff, // csr is mie/mstatus\n\n   output logic dec_csr_nmideleg_e4, // csr is mnmipdel\n\n// end CSR interface\n\n   output              dec_tlu_i0_valid_e4,  // i0 valid inst at e4\n   output              dec_tlu_i1_valid_e4,\n\n   output              eh2_trap_pkt_t dec_tlu_packet_e4,   // trap packet\n\n   output logic [31:1] dec_tlu_i0_pc_e4,  // i0 trap pc\n   output logic [31:1] dec_tlu_i1_pc_e4,\n\n\n   output logic [pt.NUM_THREADS-1:0][31:0] dec_illegal_inst,\n\n   output logic        dec_i1_valid_e1,         // i1 valid e1\n\n   output logic [pt.NUM_THREADS-1:0][31:1] pred_correct_npc_e2, // npc e2 if the prediction is correct\n\n   output logic        dec_i0_rs1_bypass_en_e3, // i0 rs1 bypass enables e3\n   output logic        dec_i0_rs2_bypass_en_e3, // i1 rs1 bypass enables e3\n   output logic        dec_i1_rs1_bypass_en_e3,\n   output logic        dec_i1_rs2_bypass_en_e3,\n   output logic [31:0] i0_rs1_bypass_data_e3,   // i0 rs1 bypass data e3\n   output logic [31:0] i0_rs2_bypass_data_e3,   // i1 rs1 bypass data e3\n   output logic [31:0] i1_rs1_bypass_data_e3,\n   output logic [31:0] i1_rs2_bypass_data_e3,\n   output logic        dec_i0_sec_decode_e3,    // i0 secondary alu e3\n   output logic        dec_i1_sec_decode_e3,    // i1 secondary alu e3\n   output logic [31:1] dec_i0_pc_e3,            // i0 pc e3\n   output logic [31:1] dec_i1_pc_e3,            // i1 pc e3\n\n   output logic        dec_i0_rs1_bypass_en_e2, // i0 rs1 bypass enable e2\n   output logic        dec_i0_rs2_bypass_en_e2, // i0 rs2 bypass enable e2\n   output logic        dec_i1_rs1_bypass_en_e2,\n   output logic        dec_i1_rs2_bypass_en_e2,\n   output logic [31:0] i0_rs1_bypass_data_e2,   // i0 rs1 bypass data e2\n   output logic [31:0] i0_rs2_bypass_data_e2,   // i0 rs2 bypass data e2\n   output logic [31:0] i1_rs1_bypass_data_e2,\n   output logic [31:0] i1_rs2_bypass_data_e2,\n\n   output eh2_predict_pkt_t  i0_predict_p_d,        // i0 predict packet decode\n   output eh2_predict_pkt_t  i1_predict_p_d,\n   output logic [pt.BHT_GHR_SIZE-1:0]           i0_predict_fghr_d, // i0 predict fghr\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i0_predict_index_d, // i0 predict index\n   output logic [pt.BTB_BTAG_SIZE-1:0]          i0_predict_btag_d, // i0_predict branch tag\n   output logic [pt.BTB_TOFFSET_SIZE-1:0]       i0_predict_toffset_d, // i0_predict branch tag\n\n   output logic [pt.BHT_GHR_SIZE-1:0]           i1_predict_fghr_d, // i1 predict fghr\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i1_predict_index_d, // i1 predict index\n   output logic [pt.BTB_BTAG_SIZE-1:0]          i1_predict_btag_d, // i1_predict branch tag\n   output logic [pt.BTB_TOFFSET_SIZE-1:0]       i1_predict_toffset_d, // i1_predict branch tag\n\n   output logic [$clog2(pt.BTB_SIZE)-1:0] dec_fa_error_index, // Fully associt btb error index\n\n   output logic [31:0] i0_result_e4_eff,        // i0 e4 result\n   output logic [31:0] i1_result_e4_eff,\n   output logic [31:0] i0_result_e2,            // i0 result e2\n\n   output logic [4:1] dec_i0_data_en,           // clock-gating logic\n   output logic [4:1] dec_i0_ctl_en,\n   output logic [4:1] dec_i1_data_en,\n   output logic [4:1] dec_i1_ctl_en,\n\n   output logic [pt.NUM_THREADS-1:0][1:0] dec_pmu_instr_decoded,    // number of instructions decode this cycle encoded\n\n   output logic [pt.NUM_THREADS-1:0]   dec_pmu_decode_stall,     // decode is stalled\n\n   output logic [pt.NUM_THREADS-1:0]      dec_pmu_presync_stall,    // decode has presync stall\n   output logic [pt.NUM_THREADS-1:0]      dec_pmu_postsync_stall,   // decode has postsync stall\n\n   output logic [pt.NUM_THREADS-1:0]      dec_nonblock_load_wen,        // write enable for nonblock load\n   output logic [pt.NUM_THREADS-1:0][4:0] dec_nonblock_load_waddr,      // logical write addr for nonblock load\n\n\n   output logic [pt.NUM_THREADS-1:0]      dec_pause_state,              // core in pause state\n   output logic [pt.NUM_THREADS-1:0]      dec_pause_state_cg,           // core in pause state for clock-gating\n\n   output logic [pt.NUM_THREADS-1:0]      dec_thread_stall_in,       // thread is known to stall next cycle - eg pause\n\n   output logic        dec_div_active,     // non-block divide is active\n   output logic        dec_div_tid,        // non-block divide tid\n\n   output logic        dec_force_favor_flip_d,\n\n   input  logic        scan_mode\n   );\n\n\n\n\n   eh2_dec_pkt_t i0_dp_raw, i0_dp;\n   eh2_dec_pkt_t i1_dp_raw, i1_dp;\n\n\n\n   logic [31:0]        i0, i1;\n   logic               i0_valid_d, i1_valid_d;\n\n   logic [31:0]        i0_result_e1, i1_result_e1;\n   logic [31:0]                      i1_result_e2;\n   logic [31:0]        i0_result_e3, i1_result_e3;\n   logic [31:0]        i0_result_e4, i1_result_e4;\n   logic [31:0]        i0_result_wb, i1_result_wb;\n\n   logic [31:1]        i0_pc_e1, i1_pc_e1;\n   logic [31:1]        i0_pc_e2, i1_pc_e2;\n   logic [31:1]        i0_pc_e3, i1_pc_e3;\n   logic [31:1]        i0_pc_e4, i1_pc_e4;\n\n   logic [9:0]         i0_rs1bypass, i0_rs2bypass;\n   logic [9:0]         i1_rs1bypass, i1_rs2bypass;\n\n   logic               i0_jalimm20, i1_jalimm20;\n   logic               i0_uiimm20, i1_uiimm20;\n\n   logic               lsu_decode_d;\n   logic [31:0]        i0_immed_d;\n   logic [31:0]        i1_immed_d;\n   logic               i0_presync;\n   logic               i0_postsync;\n\n   logic [pt.NUM_THREADS-1:0]    presync_stall;\n   logic [pt.NUM_THREADS-1:0]    postsync_stall_in, postsync_stall;\n   logic [pt.NUM_THREADS-1:0]    base_postsync_stall_in, base_postsync_stall;\n   logic [pt.NUM_THREADS-1:0]    jal_postsync_stall_in, jal_postsync_stall;\n   logic [pt.NUM_THREADS-1:0]    prior_inflight, prior_inflight_e1e3, prior_inflight_e1e4, prior_inflight_wb;\n   logic [pt.NUM_THREADS-1:0]    prior_csr_write, prior_csr_write_e1e4;\n   logic                         prior_any_csr_write_any_thread, prior_any_csr_write_any_thread_e1e4;\n\n   logic     i0_csr_clr_d, i0_csr_set_d, i0_csr_write_d;\n\n   logic        i0_csr_clr_e1,i0_csr_set_e1,i0_csr_write_e1,i0_csr_imm_e1;\n\n   logic [31:0] i0_csr_mask_e1;\n   logic [31:0] i0_write_csr_data_e1;\n\n   logic [pt.NUM_THREADS-1:0][31:0] write_csr_data_in;\n   logic [pt.NUM_THREADS-1:0][31:0] write_csr_data;\n   logic [pt.NUM_THREADS-1:0]       csr_data_wen;\n\n   logic [4:0]         i0_csrimm_e1;\n   logic [31:0]        i0_csr_rddata_e1;\n\n   logic               i1_load_block_d;\n   logic               i1_mul_block_d, i1_mul_block_thread_1cycle_d;\n   logic               i1_load2_block_d;\n   logic               i1_mul2_block_d;\n   logic               mul_decode_d;\n\n   logic               i0_legal, i1_legal;\n\n   logic [pt.NUM_THREADS-1:0]         shift_illegal;\n   logic [pt.NUM_THREADS-1:0]         illegal_inst_en;\n   logic [pt.NUM_THREADS-1:0]         illegal_lockout_in, illegal_lockout;\n\n   logic               i0_legal_decode_d, i1_legal_decode_d;\n\n   logic [31:0]        i0_result_e3_final, i1_result_e3_final;\n   logic [31:0]        i0_result_wb_raw,   i1_result_wb_raw;\n\n   logic [pt.NUM_THREADS-1:0][pt.BTB_TOFFSET_SIZE:1]        last_br_immed_d, last_br_immed_e1, last_br_immed_e2;\n   logic [pt.NUM_THREADS-1:0][31:1]        last_pc_e2;\n\n   logic        i1_depend_i0_d;\n   logic        i0_rs1_depend_i0_e1, i0_rs1_depend_i0_e2, i0_rs1_depend_i0_e3, i0_rs1_depend_i0_e4, i0_rs1_depend_i0_wb;\n   logic        i0_rs1_depend_i1_e1, i0_rs1_depend_i1_e2, i0_rs1_depend_i1_e3, i0_rs1_depend_i1_e4, i0_rs1_depend_i1_wb;\n   logic        i0_rs2_depend_i0_e1, i0_rs2_depend_i0_e2, i0_rs2_depend_i0_e3, i0_rs2_depend_i0_e4, i0_r"}
{"text": "s2_depend_i0_wb;\n   logic        i0_rs2_depend_i1_e1, i0_rs2_depend_i1_e2, i0_rs2_depend_i1_e3, i0_rs2_depend_i1_e4, i0_rs2_depend_i1_wb;\n   logic        i1_rs1_depend_i0_e1, i1_rs1_depend_i0_e2, i1_rs1_depend_i0_e3, i1_rs1_depend_i0_e4, i1_rs1_depend_i0_wb;\n   logic        i1_rs1_depend_i1_e1, i1_rs1_depend_i1_e2, i1_rs1_depend_i1_e3, i1_rs1_depend_i1_e4, i1_rs1_depend_i1_wb;\n   logic        i1_rs2_depend_i0_e1, i1_rs2_depend_i0_e2, i1_rs2_depend_i0_e3, i1_rs2_depend_i0_e4, i1_rs2_depend_i0_wb;\n   logic        i1_rs2_depend_i1_e1, i1_rs2_depend_i1_e2, i1_rs2_depend_i1_e3, i1_rs2_depend_i1_e4, i1_rs2_depend_i1_wb;\n   logic        i1_rs1_depend_i0_d, i1_rs2_depend_i0_d;\n\n   logic        i0_secondary_d, i1_secondary_d;\n   logic        i0_secondary_block_d, i1_secondary_block_d;\n   logic        non_block_case_d;\n   logic        i0_div_decode_d;\n   logic [31:0] i0_result_e4_final, i1_result_e4_final;\n   logic        i0_load_block_d;\n   logic        i0_mul_block_d, i0_mul_block_thread_1cycle_d;\n   logic [3:0]  i0_rs1_depth_d, i0_rs2_depth_d;\n   logic [3:0]  i1_rs1_depth_d, i1_rs2_depth_d;\n\n   logic        i0_rs1_match_e1_e2, i0_rs1_match_e1_e3;\n   logic        i0_rs2_match_e1_e2, i0_rs2_match_e1_e3;\n   logic        i1_rs1_match_e1_e2, i1_rs1_match_e1_e3;\n   logic        i1_rs2_match_e1_e2, i1_rs2_match_e1_e3;\n\n   logic        i0_amo_stall_d, i1_amo_stall_d;\n   logic        i0_load_stall_d,  i1_load_stall_d;\n   logic        i0_store_stall_d, i1_store_stall_d;\n\n   logic        i0_predict_nt, i0_predict_t;\n   logic        i1_predict_nt, i1_predict_t;\n\n   logic        i0_notbr_error, i0_br_toffset_error;\n   logic        i1_notbr_error, i1_br_toffset_error;\n   logic        i0_ret_error,   i1_ret_error;\n   logic        i0_br_error, i1_br_error;\n   logic        i0_br_error_all, i1_br_error_all;\n   logic [pt.BTB_TOFFSET_SIZE-1:0] i0_br_offset, i1_br_offset;\n\n   logic [20:1] i0_pcall_imm, i1_pcall_imm;    // predicted jal's\n   logic        i0_pcall_raw,   i1_pcall_raw;\n   logic        i0_pcall_case,  i1_pcall_case;\n   logic        i0_pcall,  i1_pcall;\n\n   logic        i0_pja_raw,   i1_pja_raw;\n   logic        i0_pja_case,  i1_pja_case;\n   logic        i0_pja,  i1_pja;\n\n   logic        i0_pret_case, i1_pret_case;\n   logic        i0_pret_raw, i0_pret;\n   logic        i1_pret_raw, i1_pret;\n\n   logic        i0_jal, i1_jal;  // jal's that are not predicted\n\n\n   logic        i0_predict_br, i1_predict_br;\n\n   logic [31:0] i1_result_wb_eff, i0_result_wb_eff;\n   logic [2:0]  i1rs1_intra, i1rs2_intra;\n   logic        i1_rs1_intra_bypass, i1_rs2_intra_bypass;\n   logic        store_data_bypass_c1, store_data_bypass_c2;\n   logic [1:0]  store_data_bypass_e4_c1, store_data_bypass_e4_c2, store_data_bypass_e4_c3;\n   logic        store_data_bypass_i0_e2_c2;\n\n   eh2_class_pkt_t i0_rs1_class_d, i0_rs2_class_d;\n   eh2_class_pkt_t i1_rs1_class_d, i1_rs2_class_d;\n\n   eh2_class_pkt_t i0_dc, i0_e1c, i0_e2c, i0_e3c, i0_e4c, i0_wbc;\n   eh2_class_pkt_t i1_dc, i1_e1c, i1_e2c, i1_e3c, i1_e4c, i1_wbc;\n\n\n   logic i0_rs1_match_e1, i0_rs1_match_e2, i0_rs1_match_e3;\n   logic i1_rs1_match_e1, i1_rs1_match_e2, i1_rs1_match_e3;\n   logic i0_rs2_match_e1, i0_rs2_match_e2, i0_rs2_match_e3;\n   logic i1_rs2_match_e1, i1_rs2_match_e2, i1_rs2_match_e3;\n\n   logic       i0_secondary_stall_d;\n\n   logic       i0_ap_pc2, i0_ap_pc4;\n   logic       i1_ap_pc2, i1_ap_pc4;\n\n   logic        i0_rd_en_d;\n   logic        i1_rd_en_d;\n\n   logic        load_ldst_bypass_c1;\n   logic        load_mul_rs1_bypass_e1;\n   logic        load_mul_rs2_bypass_e1;\n\n   logic [pt.NUM_THREADS-1:0] leak1_i0_stall_in, leak1_i0_stall;\n   logic [pt.NUM_THREADS-1:0] leak1_i1_stall_in, leak1_i1_stall;\n   logic [pt.NUM_THREADS-1:0] leak1_mode;\n\n   logic        i0_csr_write_only_d;\n\n   logic        i0_any_csr_d;\n\n\n   logic [5:0] i0_pipe_en;\n   logic       i0_e1_ctl_en, i0_e2_ctl_en, i0_e3_ctl_en, i0_e4_ctl_en, i0_wb_ctl_en;\n   logic       i0_e1_data_en, i0_e2_data_en, i0_e3_data_en, i0_e4_data_en, i0_wb_data_en, i0_wb1_data_en;\n\n   logic [5:0] i1_pipe_en;\n   logic       i1_e1_ctl_en, i1_e2_ctl_en, i1_e3_ctl_en, i1_e4_ctl_en, i1_wb_ctl_en;\n   logic       i1_e1_data_en, i1_e2_data_en, i1_e3_data_en, i1_e4_data_en, i1_wb_data_en, i1_wb1_data_en;\n\n   logic debug_fence_i;\n   logic debug_fence;\n\n   logic i0_csr_write;\n\n   logic i0_instr_error;\n   logic i0_icaf_d;\n   logic i1_icaf_d;\n\n   logic i0_not_alu_eff, i1_not_alu_eff;\n\n   logic [pt.NUM_THREADS-1:0]   clear_pause;\n   logic [pt.NUM_THREADS-1:0]   pause_state_in, pause_state;\n   logic [pt.NUM_THREADS-1:0]   pause_stall;\n\n   logic [31:1] i1_pc_wb;\n\n   logic        i0_brp_valid;\n\n   logic [pt.NUM_THREADS-1:0]   lsu_idle;\n   logic        i0_csr_read_e1;\n   logic        i0_block_d;\n   logic        i1_block_d;\n\n\n   eh2_inst_pkt_t                  i0_itype, i1_itype;\n\n   logic                            i0_br_unpred, i1_br_unpred;\n   logic [pt.NUM_THREADS-1:0]       flush_final_lower, flush_final_upper_e2;\n\n   eh2_reg_pkt_t                   i0r, i1r;\n   logic                            i1_cancel_d, i1_cancel_e1;\n\n   logic [4:0]                      nonblock_load_rd;\n   logic                            nonblock_load_tid_dc1;\n   logic                            i1_wen_wb, i0_wen_wb;\n\n   logic [pt.NUM_THREADS-1:0] [4:0] cam_nonblock_load_waddr;\n   logic [pt.NUM_THREADS-1:0]       cam_nonblock_load_wen;\n   logic [pt.NUM_THREADS-1:0]       cam_i0_nonblock_load_stall;\n   logic [pt.NUM_THREADS-1:0]       cam_i1_nonblock_load_stall;\n   logic [pt.NUM_THREADS-1:0]       cam_i0_load_kill_wen;\n   logic [pt.NUM_THREADS-1:0]       cam_i1_load_kill_wen;\n\n   logic [pt.NUM_THREADS-1:0]       tlu_wr_pause_wb1;\n   logic [pt.NUM_THREADS-1:0]       tlu_wr_pause_wb2;\n\n   logic                            debug_fence_raw;\n   eh2_trap_pkt_t                  dt, e1t_in, e1t, e2t_in, e2t, e3t_in, e3t, e4t_ff, e4t;\n\n\n   logic [31:0]        i0_inst_d, i1_inst_d;\n   logic [31:0]        i0_inst_e1, i1_inst_e1;\n   logic [31:0]        i0_inst_e2, i1_inst_e2;\n   logic [31:0]        i0_inst_e3, i1_inst_e3;\n   logic [31:0]        i0_inst_e4, i1_inst_e4;\n   logic [31:0]        i0_inst_wb, i1_inst_wb;\n   logic [31:0]        i0_inst_wb1,i1_inst_wb1;\n\n   eh2_dest_pkt_t     dd, e1d, e2d, e3d, e4d, wbd;\n   eh2_class_pkt_t    i0_e4c_in, i1_e4c_in;\n   eh2_dest_pkt_t     e1d_in, e2d_in, e3d_in, e4d_in;\n\n   logic [31:1] i0_pc_wb, i0_pc_wb1;\n   logic [31:1]           i1_pc_wb1;\n\n   logic [pt.NUM_THREADS-1:0][31:0] illegal_inst;\n\n   logic [pt.NUM_THREADS-1:0] i1_flush_final_e3;\n   logic [pt.NUM_THREADS-1:0] i0_flush_final_e4;\n\n   logic i1_block_same_thread_d;\n\n   logic [pt.NUM_THREADS-1:0] flush_lower_wb;\n\n   logic [pt.NUM_THREADS-1:0] flush_extint;\n\n   logic i0_csr_update_e1;\n\n   logic [pt.NUM_THREADS-1:0]       csr_update_e1;\n   logic [pt.NUM_THREADS-1:0][31:0] write_csr_data_e1;\n   logic [pt.NUM_THREADS-1:0][31:0] write_csr_data_wb;\n\n   logic i0_csr_legal_d;\n\n   logic lsu_tid_e3;\n\n   logic div_stall;\n   logic div_tid;\n\n   logic div_active, div_active_in;\n   logic div_valid;\n   logic [4:0] div_rd;\n   logic i0_nonblock_div_stall, i1_nonblock_div_stall;\n   logic div_e1_to_wb;\n   logic div_flush;\n   logic nonblock_div_cancel;\n\n   logic i0_div_prior_div_stall;\n\n   logic i1_secondary_block_thread_1cycle_d, i0_secondary_block_thread_1cycle_d;\n   logic i1_secondary_block_thread_2cycle_d, i0_secondary_block_thread_2cycle_d;\n   logic i0_secondary_stall_1cycle_d, i0_secondary_stall_2cycle_d;\n   logic i0_secondary_stall_thread_1cycle_d, i0_secondary_stall_thread_2cycle_d;\n\n   logic i1_br_error_fast, i0_br_error_fast;\n\n   logic i0_atomic_legal;\n   logic i1_atomic_legal;\n\n   logic i0_bitmanip_zbb_legal;\n   logic i0_bitmanip_zbs_legal;\n   logic i0_bitmanip_zbe_legal;\n   logic i0_bitmanip_zbc_legal;\n   logic i0_bitmanip_zbp_legal;\n   logic i0_bitmanip_zbr_legal;\n   logic i0_bitmanip_zbf_legal;\n   logic i0_bitmanip_zba_legal;\n   logic i0_bitmanip_zbb_zbp_legal;\n   logic i0_bitmanip_zbp_zbe_zbf_legal;\n   logic i0_bitmanip_zbb_zbp_zbe_zbf_legal;\n   logic i0_bitmanip_legal;\n   logic i1_bitmanip_zbb_legal;\n   logic i1_bitmanip_zbs_legal;\n   logic i1_bitmanip_zbe_legal;\n   logic i1_bitmanip_zbc_legal;\n   logic i1_bitmanip_zbp_legal;\n   logic i1_bitmanip_zbr_legal;\n   logic i1_bitmanip_zbf_legal;\n   logic i1_bitmanip_zba_legal;\n   logic i1_bitmanip_zbb_zbp_legal;\n   logic i1_bitmanip_zbp_zbe_zbf_legal;\n   logic i1_bitmanip_zbb_zbp_zbe_zbf_legal;\n   logic i1_bitmanip_legal;\n\n   logic i0_legal_except_csr;\n\n   logic [pt.NUM_THREADS-1:0] flush_all;\n   logic [pt.NUM_THREADS-1:0] smt_secondary_stall_in, smt_secondary_stall, smt_secondary_stall_raw;\n   logic [pt.NUM_THREADS-1:0] set_smt_presync_stall;\n   logic [pt.NUM_THREADS-1:0] smt_presync_stall_in, smt_presync_stall, smt_presync_stall_raw;\n   logic [pt.NUM_THREADS-1:0] set_smt_csr_write_stall;\n   logic [pt.NUM_THREADS-1:0] smt_csr_write_stall_in, smt_csr_write_stall, smt_csr_write_stall_raw;\n\n   logic [pt.NUM_THREADS-1:0] set_smt_atomic_stall;\n   logic [pt.NUM_THREADS-1:0] smt_atomic_stall_in, smt_atomic_stall, smt_atomic_stall_raw;\n\n   logic [pt.NUM_THREADS-1:0] set_smt_div_stall;\n   logic [pt.NUM_THREADS-1:0] smt_div_stall_in, smt_div_stall, smt_div_stall_raw;\n\n   logic [pt.NUM_THREADS-1:0] set_smt_nonblock_load_stall;\n   logic [pt.NUM_THREADS-1:0] smt_nonblock_load_stall_in, smt_nonblock_load_stall, smt_nonblock_load_stall_raw;\n   logic [pt.NUM_THREADS-1:0] cam_nonblock_load_stall;\n\n   logic nonblock_load_tid_dc2, nonblock_load_tid_dc5, i0_rs1_nonblock_load_bypass_en_d, i0_rs2_nonblock_load_bypass_en_d, i1_rs1_nonblock_load_bypass_en_d, i1_rs2_nonblock_load_bypass_en_d;\n\n   typedef struct packed {\n                          logic csr_read_stall;\n                          logic extint_stall;\n                          logic i1_cancel_e1_stall;\n                          logic pause_stall;\n                          logic leak1_stall;\n                          logic debug_stall;\n                          logic postsync_stall;\n                          logic presync_stall;\n                          logic wait_lsu_idle_stall;\n                          logic nonblock_load_stall;\n                          logic nonblock_div_stall;\n                          logic prior_div_stall;\n                          logic load_stall;\n                          logic store_stall;\n                          logic amo_stall;\n                          logic load_block;\n                          logic mul_block;\n                          logic secondary_block;\n                          logic secondary_stall;\n                          } i0_block_pkt_t;\n\n    typedef struct packed {\n                           logic debug_valid_stall;\n                           logic nonblock_load_stall;\n                           logic wait_lsu_idle_stall;\n                           logic extint_stall;\n                           logic i1_cancel_e1_stall;\n                           logic pause_stall;\n                           logic debug_stall;\n                           logic postsync_stall;\n                           logic presync_stall;\n                           logic nonblock_div_stall;\n                           logic load_stall;\n                           logic store_stall;\n                           logic amo_stall;\n                           logic load_block;\n                           logic mul_block;\n                           logic load2_block;\n                           logic mul2_block;\n                           logic secondary_block;\n                           logic leak1_stall;\n                           logic i0_only_block;\n                           logic icaf_block;\n                           logic block_same_thread;\n                           } i1_block_pkt_t;\n\n\n   i0_block_pkt_t i0blockp;\n   i1_block_pkt_t i1blockp;\n\n   logic i1_depend_i0_case_d;\n\n   logic i0_debug_valid_wb, i0_debug_valid_e4, i0_debug_valid_e3, i0_debug_valid_e2, i0_debug_valid_e1;\n\n   logic i1_pc4_e1, i0_pc4_e1;\n   logic i1_pc4_e2, i0_pc4_e2;\n   logic i1_pc4_e3, i0_pc4_e3;\n\n\n// branch prediction\n\n   // in leak1_mode, ignore any predictions for i0, treat branch as if we haven't seen it before\n   // in leak1 mode, also ignore branch errors for i0\n   // qual i0_brp_valid with icaf; no need to qual i1_brp_valid since it wont decode if icaf\n   assign i0_brp_valid = dec_i0_brp.valid & ~leak1_mode[dd.i0tid] & ~i0_icaf_d;\n\n\nalways_comb begin\n   i0_predict_p_d = '0;\n\n   i0_predict_index_d[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = '0;\n   i0_predict_btag_d[pt.BTB_BTAG_SIZE-1:0]           = '0;\n   i0_predict_toffset_d[pt.BTB_TOFFSET_SIZE-1:0]     = '0;\n   i0_predict_fghr_d[pt.BHT_GHR_SIZE-1:0]            = '0;\n\n   if (dec_i0_branch_d) begin\n\n      i0_predict_p_d.pcall  =  i0_pcall;  // dont mark as pcall if branch error\n      i0_predict_p_d.pja    =  i0_pja;\n      i0_predict_p_d.pret   =  i0_pret;\n      i0_predict_p_d.prett[31:1] = dec_i0_brp.prett[31:1];\n      i0_predict_p_d.pc4 = dec_i0_pc4_d;\n      i0_predict_p_d.hist[1:0] = dec_i0_brp.hist[1:0];\n      i0_predict_p_d.valid = i0_brp_valid & i0_legal_decode_d;\n      i0_predict_p_d.br_error = i0_br_error & i0_legal_decode_d & ~leak1_mode[dd.i0tid];\n      i0_predict_p_d.br_start_error = dec_i0_brp.br_start_error & i0_legal_decode_d & ~leak1_mode[dd.i0tid];\n      i0_predict_p_d.bank = dec_i0_brp.bank;\n      i0_predict_p_d.way = dec_i0_brp.way;\n\n      i0_predict_index_d[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] =  dec_i0_bp_index;\n      i0_predict_btag_d[pt.BTB_BTAG_SIZE-1:0]           =  dec_i0_bp_btag[pt.BTB_BTAG_SIZE-1:0];\n      i0_predict_toffset_d[pt.BTB_TOFFSET_SIZE-1:0]     =      i0_br_offset[pt.BTB_TOFFSET_SIZE-1:0];\n      i0_predict_fghr_d[pt.BHT_GHR_SIZE-1:0]            =  dec_i0_bp_fghr[pt.BHT_GHR_SIZE-1:0];\n\n   end // if (dec_i0_branch_d)\nend // always_comb begin\n\n\n\n   assign      i0_notbr_error = i0_brp_valid & ~(i0_dp_raw.condbr | i0_pcall_raw | i0_pja_raw | i0_pret_raw);\n\n   // no toffset error for a pret\n   assign      i0_br_toffset_error = i0_brp_valid & dec_i0_brp.hist[1] & (dec_i0_bp_toffset[pt.BTB_TOFFSET_SIZE-1:0] != i0_br_offset[pt.BTB_TOFFSET_SIZE-1:0]) & !i0_pret_raw;\n   assign      i0_ret_error = i0_brp_valid & (dec_i0_brp.ret ^ i0_pret_raw);\n   assign      i0_br_error =  dec_i0_brp.br_error | i0_notbr_error | i0_br_toffset_error | i0_ret_error;\n\n   assign      i0_br_error_all = (i0_br_error | dec_i0_brp.br_start_error) & ~leak1_mode[dd.i0tid];\n\n   assign      i0_br_error_fast = (dec_i0_brp.br_error | dec_i0_brp.br_start_error) & ~leak1_mode[dd.i0tid];\n\n   // errors go to i0 only\n  if(pt.BTB_FULLYA) begin\n      logic [pt.NUM_THREADS-1:0] i0_btb_error_found, i0_btb_error_found_f;\n      logic [pt.NUM_THREADS-1:0] [$clog2(pt.BTB_SIZE)-1:0] i0_fa_error_index_ns, dec_i0_fa_error_index;\n\n     for (genvar k=0; k<pt.NUM_THREADS; k++) begin : fa_error_index\n\n      assign i0_btb_error_found[k] = (dd.i0tid == k) & (i0_br_error_all | i0_btb_error_found_f[k]) & ~dec_tlu_flush_lower_wb[k];\n      assign i0_fa_error_index_ns[k] = ((dd.i0tid == k) & i0_br_error_all & ~i0_btb_error_found_f[k]) ? dec_i0_bp_fa_index : dec_i0_fa_error_index[k];\n\n      rvdff #($clog2(pt.BTB_SIZE)+1) btberrorfa_f   (.*, .clk(active_clk),\n                                                         .din({i0_btb_error_found[k],    i0_fa_error_index_ns[k]}),\n                                                         .dout({i0_btb_error_found_f[k], dec_i0_fa_error_index[k]}));\n\n     end\n\n     assign dec_fa_error_index = |dec_tlu_flush_lower_wb ? dec_i0_fa_error_index[wbd.i0tid] : '0;\n\n\n   end\n   else\n     assign dec_fa_error_index = 'b0;\n\n   always_comb begin\n      i1_predict_p_d = '0;\n\n      i1_predict_index_d[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = '0;\n      i1_predict_btag_d[pt.BTB_BTAG_SIZE-1:0]           = '0;\n      i1_predict_toffset_d[pt.BTB_TOFFSET_SIZE-1:0]     = '0;\n      i1_predict_fghr_d[pt.BHT_GHR_SIZE-1:0]            = '0;\n\n      if (dec_i1_branch_d) begin\n\n         i1_predict_p_d.pcall  =  i1_pcall;\n         i1_predict_p_d.pja    =  i1_pja;\n         i1_predict_p_d.pret   =  i1_pret;\n         i1_predict_p_d.prett[31:1] = dec_i1_brp.prett[31:1];\n         i1_predict_p_d.pc4 = dec_i1_pc4_d;\n         i1_predict_p_d.hist[1:0] = dec_i1_brp.hist[1:0];\n         i1_predict_p_d.valid = dec_i1_brp.valid & i1_legal_decode_d;\n         i1_predict_p_d.br_error = i1_br_error & i1_legal_decode_d;\n         i1_predict_p_d.br_start_error = dec_i1_brp.br_start_error & i1_legal_decode_d;\n         i1_predict_p_d.bank = dec_i1_brp.bank;\n         i1_predict_p_d.way = dec_i1_brp.way;\n\n         i1_predict_index_d[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] =  dec_i1_bp_index;\n         i1_predict_btag_d[pt.BTB_BTAG_SIZE-1:0]           =  dec_i1_bp_btag[pt.BTB_BTAG_SIZE-1:0];\n         i1_predict_toffset_d[pt.BTB_TOFFSET_SIZE-1:0]     =      i1_br_offset[pt.BTB_TOFFSET_SIZE-1:0];\n         i1_predict_fghr_d[pt.BHT_GHR_SIZE-1:0]            =  dec_i1_bp_fghr[pt.BHT_GHR_SIZE-1:0];\n      end // if (dec_i1_branch_d)\n   end // always_comb begin\n\n\n   assign      i1_notbr_error = dec_i1_brp.valid & ~(i1_dp_raw.condbr | i1_pcall_raw | i1_pja_raw | i1_pret_raw);\n\n\n   assign      i1_br_toffset_error = dec_i1_brp.valid & dec_i1_brp.hist[1] & (dec_i1_bp_toffset[pt.BTB_TOFFSET_SIZE-1:0] != i1_br_offset[pt.BTB_TOFFSET_SIZE-1:0]) & !i1_pret_raw;\n   assign      i1_ret_error = dec_i1_brp.valid & (dec_i1_brp.ret ^ i1_pret_raw);\n   assign      i1_br_error = dec_i1_brp.br_error | i1_notbr_error | i1_br_toffset_error | i1_ret_error;\n\n   assign      i1_br_error_all = (i1_br_error | dec_i1_brp.br_start_error);\n\n   assign      i1_br_error_fast = (dec_i1_brp.br_error | dec_i1_brp.br_start_error);\n\n\n\n   //   end\n\n   // on br error turn anything into a nop\n   // on i0 instruction fetch access fault turn anything into a nop\n   // nop =>   alu rs1 imm12 rd lor\n\n   assign i0_icaf_d = dec_i0_icaf_d | dec_i0_dbecc_d;\n   assign i1_icaf_d = dec_i1_icaf_d | dec_i1_dbecc_d;\n\n\n   assign i0_instr_error = i0_icaf_d;\n\n   always_comb begin\n      i0_dp = i0_dp_raw;\n\n      if (i0_br_error_fast | i0_instr_error) begin\n         i0_dp = '0;\n         i0_dp.alu = 1'b1;\n         i0_dp.rs1 = 1'b1;\n         i0_dp.rs2 = 1'b1;\n         i0_dp.lor = 1'b1;\n         i0_dp.legal = 1'b1;\n      end\n\n      i1_dp = i1_dp_raw;\n\n      if (i1_br_error_fast) begin\n         i1_dp = '0;\n         i1_dp.alu = 1'b1;\n         i1_dp.rs1 = 1'b1;\n         i1_dp.rs2 = 1'b1;\n         i1_dp.lor = 1'b1;\n         i1_dp.legal = 1'b1;\n      end\n\n   end\n\n\n   assign flush_lower_wb[pt.NUM_THREADS-1:0] = dec_tlu_flush_lower_wb[pt.NUM_THREADS-1:0];\n\n\n   assign i0[31:0] = dec_i0_instr_d[31:0];\n\n   assign i1[31:0] = dec_i1_instr_d[31:0];\n\n   assign dec_i0_select_pc_d = i0_dp.pc;\n   assign dec_i1_select_pc_d = i1_dp.pc;\n\n   // branches that can be predicted\n\n   assign i0_predict_br =  i0_dp.condbr | i0_pcall | i0_pja | i0_pret;\n   assign i1_predict_br =  i1_dp.condbr | i1_pcall | i1_pja | i1_pret;\n\n   assign i0_predict_nt = ~(dec_i0_brp.hist[1] & i0_brp_valid) & i0_predict_br;\n   assign i0_predict_t  =  (dec_i0_brp.hist[1] & i0_brp_valid) & i0_predict_br;\n\n   always_comb begin\n      i0_ap = '0;\n\n      i0_ap.tid = dd.i0tid;\n\n      if (i0_dp.legal & i0_dp.alu & i0_valid_d) begin\n         i0_ap.add =    i0_dp.add;\n         i0_ap.sub =    i0_dp.sub;\n         i0_ap.land =   i0_dp.land;\n         i0_ap.lor =    i0_dp.lor;\n         i0_ap.lxor =   i0_dp.lxor;\n         i0_ap.sll =    i0_dp.sll;\n         i0_ap.srl =    i0_dp.srl;\n         i0_ap.sra =    i0_dp.sra;\n         i0_ap.slt =    i0_dp.slt;\n         i0_ap.unsign = i0_dp.unsign;\n         i0_ap.beq =    i0_dp.beq;\n         i0_ap.bne =    i0_dp.bne;\n         i0_ap.blt =    i0_dp.blt;\n         i0_ap.bge =    i0_dp.bge;\n\n         i0_ap.clz     =  i0_dp.clz;\n         i0_ap.ctz     =  i0_dp.ctz;\n         i0_ap.cpop    =  i0_dp.cpop;\n         i0_ap.sext_b  =  i0_dp.sext_b;\n         i0_ap.sext_h  =  i0_dp.sext_h;\n         i0_ap.sh1add  =  i0_dp.sh1add;\n         i0_ap.sh2add  =  i0_dp.sh2add;\n         i0_ap.sh3add  =  i0_dp.sh3add;\n         i0_ap.zba     =  i0_dp.zba;\n         i0_ap.min     =  i0_dp.min;\n         i0_ap.max     =  i0_dp.max"}
{"text": ";\n         i0_ap.pack    =  i0_dp.pack;\n         i0_ap.packu   =  i0_dp.packu;\n         i0_ap.packh   =  i0_dp.packh;\n         i0_ap.rol     =  i0_dp.rol;\n         i0_ap.ror     =  i0_dp.ror;\n         i0_ap.grev    =  i0_dp.grev;\n         i0_ap.gorc    =  i0_dp.gorc;\n         i0_ap.zbb     =  i0_dp.zbb;\n         i0_ap.bset    =  i0_dp.bset;\n         i0_ap.bclr    =  i0_dp.bclr;\n         i0_ap.binv    =  i0_dp.binv;\n         i0_ap.bext    =  i0_dp.bext;\n\n         i0_ap.csr_write = i0_csr_write_only_d;\n         i0_ap.csr_imm = i0_dp.csr_imm;\n\n\n         i0_ap.jal    =  i0_jal;\n\n\n         i0_ap.predict_nt = i0_predict_nt;\n         i0_ap.predict_t  = i0_predict_t;\n\n      end // if (dec_i0_decode_d & i0_dp.alu)\n   end // always_comb begin\n\n\n   assign i0_ap_pc2 = ~dec_i0_pc4_d;\n   assign i0_ap_pc4 =  dec_i0_pc4_d;\n\n   assign i1_predict_nt = ~(dec_i1_brp.hist[1] & dec_i1_brp.valid) & i1_predict_br;\n   assign i1_predict_t  =  (dec_i1_brp.hist[1] & dec_i1_brp.valid) & i1_predict_br;\n\n   always_comb begin\n      i1_ap = '0;\n\n      i1_ap.tid = dd.i1tid;\n\n      if (i1_dp.legal & i1_dp.alu & i1_valid_d) begin\n\n         i1_ap.add =    i1_dp.add;\n         i1_ap.sub =    i1_dp.sub;\n         i1_ap.land =   i1_dp.land;\n         i1_ap.lor =    i1_dp.lor;\n         i1_ap.lxor =   i1_dp.lxor;\n         i1_ap.sll =    i1_dp.sll;\n         i1_ap.srl =    i1_dp.srl;\n         i1_ap.sra =    i1_dp.sra;\n         i1_ap.slt =    i1_dp.slt;\n         i1_ap.unsign = i1_dp.unsign;\n         i1_ap.beq =    i1_dp.beq;\n         i1_ap.bne =    i1_dp.bne;\n         i1_ap.blt =    i1_dp.blt;\n         i1_ap.bge =    i1_dp.bge;\n\n         i1_ap.clz     =  i1_dp.clz;\n         i1_ap.ctz     =  i1_dp.ctz;\n         i1_ap.cpop    =  i1_dp.cpop;\n         i1_ap.sext_b  =  i1_dp.sext_b;\n         i1_ap.sext_h  =  i1_dp.sext_h;\n         i1_ap.sh1add  =  i1_dp.sh1add;\n         i1_ap.sh2add  =  i1_dp.sh2add;\n         i1_ap.sh3add  =  i1_dp.sh3add;\n         i1_ap.zba     =  i1_dp.zba;\n         i1_ap.min     =  i1_dp.min;\n         i1_ap.max     =  i1_dp.max;\n         i1_ap.pack    =  i1_dp.pack;\n         i1_ap.packu   =  i1_dp.packu;\n         i1_ap.packh   =  i1_dp.packh;\n         i1_ap.rol     =  i1_dp.rol;\n         i1_ap.ror     =  i1_dp.ror;\n         i1_ap.grev    =  i1_dp.grev;\n         i1_ap.gorc    =  i1_dp.gorc;\n         i1_ap.zbb     =  i1_dp.zbb;\n         i1_ap.bset    =  i1_dp.bset;\n         i1_ap.bclr    =  i1_dp.bclr;\n         i1_ap.binv    =  i1_dp.binv;\n         i1_ap.bext    =  i1_dp.bext;\n\n         i1_ap.csr_write = 1'b0;\n         i1_ap.csr_imm   = 1'b0;\n\n         i1_ap.jal    =    i1_jal;\n\n\n         i1_ap.predict_nt = i1_predict_nt;\n         i1_ap.predict_t  = i1_predict_t;\n\n      end // if (dec_i1_decode_d & i1_dp.alu)\n   end // always_comb begin\n\n\n   assign i1_ap_pc2 = ~dec_i1_pc4_d;\n   assign i1_ap_pc4 =  dec_i1_pc4_d;\n\n   assign i1_cancel_d = i0_dp.load & i1_depend_i0_d & i1_legal_decode_d & ~i0_br_error_all & ~i1_br_error_all;  // no decode if flush\n\n\n\n   rvdffie #(pt.NUM_THREADS+18) misc1ff\n     ( .*,\n       .din({ i1_cancel_d,  dec_tlu_flush_extint[pt.NUM_THREADS-1:0], dec_i0_csr_ren_d,   i0_csr_clr_d,  i0_csr_set_d,  i0_csr_write_d,  i0_dp.csr_imm, div_active_in,\n              dec_i0_debug_valid_d, i0_debug_valid_e1, i0_debug_valid_e2, i0_debug_valid_e3, i0_debug_valid_e4,\n              dec_i0_branch_d, dec_i0_branch_e1, dec_i0_branch_e2, dec_i1_branch_d, dec_i1_branch_e1, dec_i1_branch_e2}),\n       .dout({i1_cancel_e1,         flush_extint[pt.NUM_THREADS-1:0],     i0_csr_read_e1, i0_csr_clr_e1, i0_csr_set_e1, i0_csr_write_e1, i0_csr_imm_e1, div_active,\n              i0_debug_valid_e1,    i0_debug_valid_e2, i0_debug_valid_e3, i0_debug_valid_e4, i0_debug_valid_wb,\n              dec_i0_branch_e1, dec_i0_branch_e2, dec_i0_branch_e3, dec_i1_branch_e1, dec_i1_branch_e2, dec_i1_branch_e3})\n       );\n\n   assign dec_i0_debug_valid_wb = i0_debug_valid_wb;\n\n   always_comb begin\n\n      dec_i1_cancel_e1 = '0;\n\n      dec_i1_cancel_e1[e1d.i1tid] = ~(((lsu_rs1_dc1[31:28]==pt.DCCM_REGION) & pt.DCCM_ENABLE) | lsu_rs1_dc1[31:28]==pt.PIC_REGION) & i1_cancel_e1 &\n                                    ~flush_final_e3[e1d.i1tid] &\n                                    ~flush_lower_wb[e1d.i1tid];\n   end\n\n// START: non block load cam logic\n\n   assign nonblock_load_rd[4:0] = (e1d.i0load) ? e1d.i0rd[4:0] : e1d.i1rd[4:0];  // rd data\n   // threaded\n   assign nonblock_load_tid_dc1 = e1d.lsu_tid;\n   assign nonblock_load_tid_dc2 = e2d.lsu_tid;\n   assign nonblock_load_tid_dc5 = wbd.lsu_tid;\n\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin : cam\n\n      eh2_dec_cam #(.pt(pt)) cam (\n                        .tid                     (1'(i)),\n                        .clk                     (active_thread_l2clk[i]),\n                        .flush                   (flush_all[i]),\n                        .dec_tlu_force_halt      (dec_tlu_force_halt[i]),\n                        .nonblock_load_waddr     (cam_nonblock_load_waddr[i]   ),\n                        .nonblock_load_wen       (cam_nonblock_load_wen[i]     ),\n                        .i0_nonblock_load_stall  (cam_i0_nonblock_load_stall[i]),\n                        .i1_nonblock_load_stall  (cam_i1_nonblock_load_stall[i]),\n                        .i0_load_kill_wen        (cam_i0_load_kill_wen[i]      ),\n                        .i1_load_kill_wen        (cam_i1_load_kill_wen[i]      ),\n                        .nonblock_load_stall     (cam_nonblock_load_stall[i]   ),\n                        .*\n                        );\n\n   end\n\n\n   assign dec_nonblock_load_waddr[pt.NUM_THREADS-1:0]  = cam_nonblock_load_waddr[pt.NUM_THREADS-1:0];\n   assign dec_nonblock_load_wen[pt.NUM_THREADS-1:0]    = cam_nonblock_load_wen[pt.NUM_THREADS-1:0];\n\n// END non block load cam logic\n\n// pmu start\n\n   assign i0_br_unpred = (i0_dp.condbr | i0_dp.jal) & ~i0_predict_br;\n   assign i1_br_unpred = (i1_dp.condbr | i1_dp.jal) & ~i1_predict_br;\n\n   // the classes must be mutually exclusive with one another\n\n   always_comb begin\n      i0_itype = NULL;\n      i1_itype = NULL;\n\n      if (i0_legal_decode_d & ~i0_br_error_all) begin\n         if (i0_dp.mul)                  i0_itype = MUL;\n         if (i0_dp.load)                 i0_itype = LOAD;\n         if (i0_dp.store)                i0_itype = STORE;\n         if (i0_dp.pm_alu)               i0_itype = ALU;\n         if (i0_dp.zbb | i0_dp.zbs |\n             i0_dp.zbe | i0_dp.zbc |\n             i0_dp.zbp | i0_dp.zbr |\n             i0_dp.zbf | i0_dp.zba)\n                                          i0_itype = BITMANIPU;\n         if (i0_dp.atomic & ~(i0_dp.lr |  i0_dp.sc))\n                                          i0_itype = ATOMIC;\n         if (i0_dp.lr)                    i0_itype = LR;\n         if (i0_dp.sc)                    i0_itype = SC;\n         if ( dec_i0_csr_ren_d & ~dec_i0_csr_wen_unq_d)     i0_itype = CSRREAD;\n         if (~dec_i0_csr_ren_d &  dec_i0_csr_wen_unq_d)     i0_itype = CSRWRITE;\n         if ( dec_i0_csr_ren_d &  dec_i0_csr_wen_unq_d)     i0_itype = CSRRW;\n         if (i0_dp.ebreak)                i0_itype = EBREAK;\n         if (i0_dp.ecall)                 i0_itype = ECALL;\n         if (i0_dp.fence) i0_itype = FENCE;\n         if (i0_dp.fence_i)               i0_itype = FENCEI;  // fencei will set this even with fence attribute\n         if (i0_dp.mret)                  i0_itype = MRET;\n         if (i0_dp.condbr)                i0_itype = CONDBR;\n         if (i0_dp.jal)                   i0_itype = JAL;\n      end\n\n      if (i1_legal_decode_d & ~i1_br_error_all) begin\n         if (i1_dp.ebreak)               i1_itype = EBREAK;   // this is based on doing SMT\n         if (i1_dp.ecall)                i1_itype = ECALL;\n         if (i1_dp.mret)                 i1_itype = MRET;\n\n         if (i1_dp.mul)                  i1_itype = MUL;\n         if (i1_dp.load)                 i1_itype = LOAD;\n         if (i1_dp.store)                i1_itype = STORE;\n         if (i1_dp.pm_alu)               i1_itype = ALU;\n         if (i1_dp.condbr)               i1_itype = CONDBR;\n         if (i1_dp.jal)                  i1_itype = JAL;\n         if (i1_dp.zbb | i1_dp.zbs |\n             i1_dp.zbe | i1_dp.zbc |\n             i1_dp.zbp | i1_dp.zbr |\n             i1_dp.zbf | i1_dp.zba)\n                                         i1_itype = BITMANIPU;\n         if (i1_dp.atomic & ~(i1_dp.lr | i1_dp.sc))\n                                         i1_itype = ATOMIC;\n         if (i1_dp.lr)                   i1_itype = LR;\n         if (i1_dp.sc)                   i1_itype = SC;\n      end\n   end\n\n\n// end pmu\n\n   eh2_dec_dec_ctl i0_dec (.inst(i0[31:0]),.predecode(dec_i0_predecode),.out(i0_dp_raw));\n\n   eh2_dec_dec_ctl i1_dec (.inst(i1[31:0]),.predecode(dec_i1_predecode),.out(i1_dp_raw));\n\n// genvar the flops\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n\n\n      rvdffie #(8) bundle1_ff (.*,\n                               .clk(free_l2clk),\n                               .din({lsu_idle_any[i],leak1_i1_stall_in[i],leak1_i0_stall_in[i],dec_tlu_wr_pause_wb[i], tlu_wr_pause_wb1[i],pause_state_in[i],smt_secondary_stall_in[i], smt_presync_stall_in[i]}),\n                               .dout({lsu_idle[i],   leak1_i1_stall[i],   leak1_i0_stall[i],      tlu_wr_pause_wb1[i],tlu_wr_pause_wb2[i],pause_state[i],   smt_secondary_stall_raw[i],smt_presync_stall_raw[i]})\n                               );\n\n\n      rvdffie #(10) bundle2_ff (.*,\n                                .clk(free_l2clk),\n                                .din( {smt_csr_write_stall_in[i],smt_atomic_stall_in[i],smt_div_stall_in[i],smt_nonblock_load_stall_in[i],illegal_lockout_in[i],\n                                       base_postsync_stall_in[i],jal_postsync_stall_in[i],exu_i0_flush_final[i],exu_i1_flush_final[i],i0_flush_final_e3[i]}),\n                                .dout({smt_csr_write_stall_raw[i],smt_atomic_stall_raw[i],smt_div_stall_raw[i],smt_nonblock_load_stall_raw[i],illegal_lockout[i],\n                                       base_postsync_stall[i],jal_postsync_stall[i],i0_flush_final_e3[i],i1_flush_final_e3[i],i0_flush_final_e4[i]})\n                                );\n\n   end\n\n// thread the leak1 logic\n// leak1 needed for debug single-step\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n\n      assign leak1_i1_stall_in[i] = (dec_tlu_flush_leak_one_wb[i] | (leak1_i1_stall[i] & ~flush_lower_wb[i]));\n\n      assign leak1_mode[i] = leak1_i1_stall[i];\n\n      assign leak1_i0_stall_in[i] = ((dec_i0_decode_d & (dd.i0tid == i) & leak1_i1_stall[i]) | (leak1_i0_stall[i] & ~flush_lower_wb[i]));\n\n\n   end\n\n\n   // 12b jal's can be predicted - these are calls\n\n   assign i0_pcall_imm[20:1] = {i0[31],i0[19:12],i0[20],i0[30:21]};\n\n   assign i1_pcall_imm[20:1] = {i1[31],i1[19:12],i1[20],i1[30:21]};\n\n\n   // if the btb toffset size is set to 12, clip here\nif(pt.BTB_TOFFSET_SIZE==12) begin\n   logic        i0_pcall_12b_offset, i1_pcall_12b_offset;\n   assign i0_pcall_12b_offset = (i0_pcall_imm[12]) ? (i0_pcall_imm[20:13] == 8'hff) : (i0_pcall_imm[20:13] == 8'h0);\n   assign i0_pcall_case  = i0_pcall_12b_offset & i0_dp_raw.imm20 &  (i0r.rd[4:0] == 5'd1 | i0r.rd[4:0] == 5'd5);\n   assign i0_pja_case    = i0_pcall_12b_offset & i0_dp_raw.imm20 & ~(i0r.rd[4:0] == 5'd1 | i0r.rd[4:0] == 5'd5);\n\n   assign i1_pcall_12b_offset = (i1_pcall_imm[12]) ? (i1_pcall_imm[20:13] == 8'hff) : (i1_pcall_imm[20:13] == 8'h0);\n   assign i1_pcall_case  = i1_pcall_12b_offset & i1_dp_raw.imm20 &  (i1r.rd[4:0] == 5'd1 | i1r.rd[4:0] == 5'd5);\n   assign i1_pja_case    = i1_pcall_12b_offset & i1_dp_raw.imm20 & ~(i1r.rd[4:0] == 5'd1 | i1r.rd[4:0] == 5'd5);\nend\nelse begin\n   assign i0_pcall_case  = i0_dp_raw.imm20 &  (i0r.rd[4:0] == 5'd1 | i0r.rd[4:0] == 5'd5);\n   assign i0_pja_case    = i0_dp_raw.imm20 & ~(i0r.rd[4:0] == 5'd1 | i0r.rd[4:0] == 5'd5);\n\n   assign i1_pcall_case  = i1_dp_raw.imm20 &  (i1r.rd[4:0] == 5'd1 | i1r.rd[4:0] == 5'd5);\n   assign i1_pja_case    = i1_dp_raw.imm20 & ~(i1r.rd[4:0] == 5'd1 | i1r.rd[4:0] == 5'd5);\n\nend\n\n\n   assign i0_pcall_raw = i0_dp_raw.jal &   i0_pcall_case;   // this includes ja\n   assign i0_pcall     = i0_dp.jal     &   i0_pcall_case;\n\n   assign i1_pcall_raw = i1_dp_raw.jal &   i1_pcall_case;\n   assign i1_pcall     = i1_dp.jal     &   i1_pcall_case;\n\n   assign i0_pja_raw = i0_dp_raw.jal &   i0_pja_case;\n   assign i0_pja     = i0_dp.jal     &   i0_pja_case;\n\n   assign i1_pja_raw = i1_dp_raw.jal &   i1_pja_case;\n   assign i1_pja     = i1_dp.jal     &   i1_pja_case;\n\n   assign i0_br_offset[pt.BTB_TOFFSET_SIZE-1:0] = (i0_pcall_raw | i0_pja_raw) ? i0_pcall_imm[pt.BTB_TOFFSET_SIZE:1] : { {pt.BTB_TOFFSET_SIZE-11{i0[31]}},i0[7],i0[30:25],i0[11:8]};\n   assign i1_br_offset[pt.BTB_TOFFSET_SIZE-1:0] = (i1_pcall_raw | i1_pja_raw) ? i1_pcall_imm[pt.BTB_TOFFSET_SIZE:1] : { {pt.BTB_TOFFSET_SIZE-11{i1[31]}},i1[7],i1[30:25],i1[11:8]};\n\n   assign i0_pret_case = (i0_dp_raw.jal & i0_dp_raw.imm12 & (i0r.rd[4:0] == 5'b0) & (i0r.rs1[4:0] == 5'd1 | i0r.rs1[4:0] == 5'd5));  // jalr with rd==0, rs1==1 or rs1==5 is a ret\n   assign i1_pret_case = (i1_dp_raw.jal & i1_dp_raw.imm12 & (i1r.rd[4:0] == 5'b0) & (i1r.rs1[4:0] == 5'd1 | i1r.rs1[4:0] == 5'd5));  // jalr with rd==0, rs1==1 or rs1==5 is a ret\n\n   assign i0_pret_raw = i0_dp_raw.jal &   i0_pret_case;\n   assign i0_pret    = i0_dp.jal     &   i0_pret_case;\n\n   assign i1_pret_raw = i1_dp_raw.jal &   i1_pret_case;\n   assign i1_pret     = i1_dp.jal     &   i1_pret_case;\n\n   assign i0_jal    = i0_dp.jal  &  ~i0_pcall_case & ~i0_pja_case & ~i0_pret_case;\n   assign i1_jal    = i1_dp.jal  &  ~i1_pcall_case & ~i1_pja_case & ~i1_pret_case;\n\n   // lsu stuff\n   // load/store mutually exclusive\n   assign dec_lsu_offset_d[11:0] =\n                                   ({12{~dec_extint_stall &  i0_dp.lsu & i0_dp.load}} &               i0[31:20]) |\n                                   ({12{~dec_extint_stall & ~i0_dp.lsu & i1_dp.lsu & i1_dp.load}} &   i1[31:20]) |\n                                   ({12{~dec_extint_stall &  i0_dp.lsu & i0_dp.store}} &             {i0[31:25],i0[11:7]}) |\n                                   ({12{~dec_extint_stall & ~i0_dp.lsu & i1_dp.lsu & i1_dp.store}} & {i1[31:25],i1[11:7]});\n\n\n\n   assign dec_i0_lsu_d = i0_dp.lsu;\n   assign dec_i1_lsu_d = i1_dp.lsu;\n\n   assign dec_i0_mul_d = i0_dp.mul;\n   assign dec_i1_mul_d = i1_dp.mul;\n\n   assign dec_i0_div_d = i0_dp.div;\n\n\n   always_comb begin\n      div_p = '0;\n      if (i0_dp.legal && i0_dp.div && i0_valid_d) begin\n         div_p.valid  =  i0_div_decode_d;\n         div_p.unsign =  i0_dp.unsign;\n         div_p.rem    =  i0_dp.rem;\n         div_p.tid    =  dd.i0tid;\n      end\n   end\n\n\n\n   always_comb begin\n      mul_p = '0;\n      if ((i0_dp.legal && i0_dp.mul && i0_valid_d) || (i1_dp.legal && i1_dp.mul && i1_valid_d)) begin\n         mul_p.valid = mul_decode_d;\n\n         mul_p.rs1_sign    =   (i0_dp.mul) ? i0_dp.rs1_sign     :   i1_dp.rs1_sign;\n         mul_p.rs2_sign    =   (i0_dp.mul) ? i0_dp.rs2_sign     :   i1_dp.rs2_sign;\n         mul_p.low         =   (i0_dp.mul) ? i0_dp.low          :   i1_dp.low;\n         mul_p.bcompress   =   (i0_dp.mul) ? i0_dp.bcompress    :   i1_dp.bcompress;\n         mul_p.bdecompress =   (i0_dp.mul) ? i0_dp.bdecompress  :   i1_dp.bdecompress;\n         mul_p.clmul       =   (i0_dp.mul) ? i0_dp.clmul        :   i1_dp.clmul;\n         mul_p.clmulh      =   (i0_dp.mul) ? i0_dp.clmulh       :   i1_dp.clmulh;\n         mul_p.clmulr      =   (i0_dp.mul) ? i0_dp.clmulr       :   i1_dp.clmulr;\n         mul_p.grev        =   (i0_dp.mul) ? i0_dp.grev         :   i1_dp.grev;\n         mul_p.gorc        =   (i0_dp.mul) ? i0_dp.gorc         :   i1_dp.gorc;\n         mul_p.shfl        =   (i0_dp.mul) ? i0_dp.shfl         :   i1_dp.shfl;\n         mul_p.unshfl      =   (i0_dp.mul) ? i0_dp.unshfl       :   i1_dp.unshfl;\n         mul_p.xperm_n     =   (i0_dp.mul) ? i0_dp.xperm_n      :   i1_dp.xperm_n;\n         mul_p.xperm_b     =   (i0_dp.mul) ? i0_dp.xperm_b      :   i1_dp.xperm_b;\n         mul_p.xperm_h     =   (i0_dp.mul) ? i0_dp.xperm_h      :   i1_dp.xperm_h;\n         mul_p.crc32_b     =   (i0_dp.mul) ? i0_dp.crc32_b      :   i1_dp.crc32_b;\n         mul_p.crc32_h     =   (i0_dp.mul) ? i0_dp.crc32_h      :   i1_dp.crc32_h;\n         mul_p.crc32_w     =   (i0_dp.mul) ? i0_dp.crc32_w      :   i1_dp.crc32_w;\n         mul_p.crc32c_b    =   (i0_dp.mul) ? i0_dp.crc32c_b     :   i1_dp.crc32c_b;\n         mul_p.crc32c_h    =   (i0_dp.mul) ? i0_dp.crc32c_h     :   i1_dp.crc32c_h;\n         mul_p.crc32c_w    =   (i0_dp.mul) ? i0_dp.crc32c_w     :   i1_dp.crc32c_w;\n         mul_p.bfp         =   (i0_dp.mul) ? i0_dp.bfp          :   i1_dp.bfp;\n\n         mul_p.load_mul_rs1_bypass_e1 = load_mul_rs1_bypass_e1;\n         mul_p.load_mul_rs2_bypass_e1 = load_mul_rs2_bypass_e1;\n      end // if (mul_decode_d)\n   end // always_comb begin\n\n\n\n   assign dec_extint_stall = |flush_extint[pt.NUM_THREADS-1:0];\n\n`ifdef RV_ASSERT_ON\n   assert_dec_flush_extint_onehot:          assert #0 ($onehot0(dec_tlu_flush_extint[pt.NUM_THREADS-1:0]));\n`endif\n\n\n   always_comb  begin\n      lsu_p = '0;\n\n      if (dec_extint_stall) begin\n         lsu_p.load = 1'b1;\n         lsu_p.word = 1'b1;\n         lsu_p.fast_int = 1'b1;\n         lsu_p.valid = 1'b1;\n         lsu_p.tid = ~flush_extint[0];\n      end\n      else begin\n\n         lsu_p.atomic             = (i0_dp.lsu) ? i0_dp.atomic  :   i1_dp.atomic;\n         lsu_p.atomic_instr[4:0]  = (i0_dp.atomic) ? i0[31:27] : (i1_dp.atomic) ?  i1[31:27] : '0;\n         lsu_p.lr                 = (i0_dp.lsu) ? i0_dp.lr      :   i1_dp.lr;\n         lsu_p.sc                 = (i0_dp.lsu) ? i0_dp.sc      :   i1_dp.sc;\n\n         lsu_p.tid = (i0_dp.lsu) ?  dd.i0tid : dd.i1tid;\n\n         lsu_p.pipe = ~i0_dp.lsu;\n\n         lsu_p.load =    (i0_dp.lsu) ? i0_dp.load :   i1_dp.load;\n\n         lsu_p.store =   (i0_dp.lsu) ? i0_dp.store :  i1_dp.store;\n         lsu_p.by =      (i0_dp.lsu) ? i0_dp.by :     i1_dp.by;\n         lsu_p.half =    (i0_dp.lsu) ? i0_dp.half :   i1_dp.half;\n\n         lsu_p.word =    (i0_dp.lsu) ? (i0_dp.lsu & i0_dp.word) : (i1_dp.lsu & i1_dp.word);\n\n         lsu_p.stack   = (i0_dp.lsu) ? (i0r.rs1[4:0]==5'd2) : (i1r.rs1[4:0]==5'd2);   // stack reference\n\n         lsu_p.store_data_bypass_i0_e2_c2   = store_data_bypass_i0_e2_c2;  // has priority over all else\n         lsu_p.load_ldst_bypass_c1          = load_ldst_bypass_c1       ;\n         lsu_p.store_data_bypass_c1         = store_data_bypass_c1 & ~store_data_bypass_i0_e2_c2;\n         lsu_p.store_data_bypass_c2         = store_data_bypass_c2 & ~store_data_bypass_i0_e2_c2;\n         lsu_p.store_data_bypass_e4_c1[1:0] = store_data_bypass_e4_c1[1:0] & ~{2{store_data_bypass_i0_e2_c2}};\n         lsu_p.store_data_bypass_e4_c2[1:0] = store_data_bypass_e4_c2[1:0] & ~{2{store_data_bypass_i0_e2_c2}};\n         lsu_p.store_data_bypass_e4_c3[1:0] = store_data_bypass_e4_c3[1:0] & ~{2{store_data_bypass_i0_e2_c2}};\n\n         lsu_p.unsign = (i0_dp.lsu) ? i0_dp.unsign : i1_dp.unsign;\n\n         lsu_p.valid = lsu_decode_d;\n\n      end\n\n   end\n\n\n\n\n   // defined register packet\n\n   assign i0r.rs1[4:0] = i0[19:15];\n   assign i0r.rs2[4:0] = i0[24:20];\n   assign i0r.rd[4:0] = i0[11:7];\n\n   assign i1r.rs1[4:0] = i1[19:15];\n   assign i1r.rs2[4:0] = i1[24:20];\n   assign i1r.rd[4:0] = i1[11:7];\n\n\n   assign dec_i0_rs1_en_d = i0_dp.rs1 & (i0r.rs1[4:0] != 5'd0) & i0_valid_d;  // if rs1_en=0 then read will be all 0's\n   assign dec_i0_rs2_en_d = i0_dp.rs2 & (i0r.rs2[4:0] != 5'd0) & i0_valid_d;\n   assign i0_rd_en_d      =  i0_dp.rd & (i0r.rd[4:0] != 5'd0)  & i0_valid_d;\n\n   assign dec_i0_rs1_d[4:0] = i0r.rs1[4:0];\n   assign dec_i0_rs2_d[4:0] = i0r.rs2[4:0];\n\n\n   assign i0_jalimm20 = i0_dp.jal & i0_dp.imm20;   // jal\n   assign i1_jalimm20 = i1_dp.jal & i1_dp.imm20;\n\n\n   assign i0_uiimm20 = ~i0_dp.jal & i0_dp.imm20;\n   assign i1_uiimm20 = ~i1_dp.jal & i1_dp.imm20;\n\n\n   // csr logic\n\n   assign dec_i0_csr_ren_d = i0_dp.csr_read & i0_legal_decode_d & ~i0_br_error_all;\n\n   assign i0_csr_clr_d =   i0_dp.csr_clr   & i0_legal_decode_d & ~i0_br_error_all;\n   assign i0_csr_set_d   = i0_dp.csr_set   & i0_legal_decode_d & ~i0_br_error_all;\n   as"}
{"text": "sign i0_csr_write_d = i0_csr_write    & i0_legal_decode_d & ~i0_br_error_all;\n\n   assign i0_csr_write_only_d = i0_csr_write & ~i0_dp.csr_read;\n\n   assign dec_i0_csr_wen_unq_d = (i0_dp.csr_clr | i0_dp.csr_set | i0_csr_write) & i0_valid_d;   // for csr legal, can't write read-only csr\n\n   assign dec_i0_csr_any_unq_d = i0_any_csr_d & i0_valid_d;\n\n\n   assign dec_i0_csr_rdaddr_d[11:0] = {12{(i0_dp.csr_read | i0_dp.csr_write) & i0_valid_d}} & i0[31:20];\n   assign dec_i0_csr_wraddr_wb[11:0] = {12{wbd.i0csrwen & wbd.i0valid}} & wbd.i0csrwaddr[11:0];\n\n   assign dec_i0_csr_is_mcpc_e4 = (e4d.i0csrwaddr[11:0] == 12'h7c2);\n\n   // make sure csr doesn't write same cycle as flush_lower_wb\n   // also use valid so it's flushable\n   assign dec_i0_csr_wen_wb = wbd.i0csrwen & wbd.i0valid & ~dec_tlu_i0_kill_writeb_wb;\n\n   // If we are writing MIE or MSTATUS, hold off the external interrupt for a cycle on the write.\n   // this assumes CSRs only done in i0 pipe\n   // Note: WB kill only applies if E4 has the same tid\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n\n      assign dec_csr_stall_int_ff[i] = (i==e4d.i0tid) & ((e4d.i0csrwaddr[11:0] == 12'h300) | (e4d.i0csrwaddr[11:0] == 12'h304)) & e4d.i0csrwen & e4d.i0valid & (~dec_tlu_i0_kill_writeb_wb | (e4d.i0tid != wbd.i0tid));\n\n   end\n\n   // tell tlu when the nmipdelegate csr is being written\n   assign dec_csr_nmideleg_e4 = (e4d.i0csrwaddr[11:0] == 12'h7fe) & e4d.i0csrwen & e4d.i0valid & ~dec_tlu_i0_kill_writeb_wb & ~flush_lower_wb[e4d.i0tid];\n\n   // perform the update operation if any for i0 pipe\n\n\n   rvdffe #(37) i0_csr_data_e1ff (.*, .en(i0_e1_data_en & dec_i0_csr_ren_d), .din( {dec_i0_csr_rddata_d[31:0],i0[19:15]}), .dout({i0_csr_rddata_e1[31:0],i0_csrimm_e1[4:0]}));\n\n\n   assign i0_csr_mask_e1[31:0] = ({32{ i0_csr_imm_e1}} & {27'b0,i0_csrimm_e1[4:0]}) |\n                              ({32{~i0_csr_imm_e1}} &  exu_i0_csr_rs1_e1[31:0]);\n\n\n   assign i0_write_csr_data_e1[31:0] = ({32{i0_csr_clr_e1}}   & (i0_csr_rddata_e1[31:0] & ~i0_csr_mask_e1[31:0])) |\n                                       ({32{i0_csr_set_e1}}   & (i0_csr_rddata_e1[31:0] |  i0_csr_mask_e1[31:0])) |\n                                       ({32{i0_csr_write_e1}} & (                          i0_csr_mask_e1[31:0]));\n\n\n   // clock-gating for pause state\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n\n      assign dec_pause_state_cg[i] = pause_state[i] & ~tlu_wr_pause_wb1[i] & ~tlu_wr_pause_wb2[i];\n\n   end\n\n\n   assign dec_pause_state[pt.NUM_THREADS-1:0] = pause_state[pt.NUM_THREADS-1:0];\n\n\n\n// csr complex logic - only 1 csr read/write can go down the pipe per thread and each with be presync/postsync\n\n\n   assign i0_csr_update_e1 = (i0_csr_clr_e1  | i0_csr_set_e1 | i0_csr_write_e1) & i0_csr_read_e1;\n\n\n   // it is illegal for 2 csr read/writes for same thread in same cycle\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n\n      assign csr_update_e1[i] = (e1d.i0tid==i) & i0_csr_update_e1;\n\n\n      assign write_csr_data_e1[i] = i0_write_csr_data_e1[31:0];\n\n\n      // need to qualify this more - i0 pause\n\n      assign write_csr_data_wb[i] = dec_i0_csr_wrdata_wb[31:0];\n\n      assign clear_pause[i] = (flush_lower_wb[i] & ~dec_tlu_flush_pause_wb[i]) |\n                              (pause_state[i] & (write_csr_data[i][31:1] == 31'b0));        // if 0 or 1 then exit pause state - 1 cycle pause\n\n      assign pause_state_in[i] = (dec_tlu_wr_pause_wb[i] | pause_state[i]) & ~clear_pause[i];\n\n\n      assign csr_data_wen[i] = csr_update_e1[i] | dec_tlu_wr_pause_wb[i] | pause_state[i];\n\n      assign write_csr_data_in[i][31:0] = (pause_state[i])               ? (write_csr_data[i][31:0] - 32'b1) :\n                                          (dec_tlu_wr_pause_wb[i]) ?  write_csr_data_wb[i][31:0] : write_csr_data_e1[i][31:0];\n\n      // will hold until write-back at which time the CSR will be updated while GPR is possibly written with prior CSR\n      rvdffe #(32) write_csr_ff (.*, .clk(free_l2clk), .en(csr_data_wen[i]), .din(write_csr_data_in[i][31:0]), .dout(write_csr_data[i][31:0]));\n\n      assign pause_stall[i] = pause_state[i];\n\n   end\n\n\n   // for csr write only data is produced by the alu\n   assign dec_i0_csr_wrdata_wb[31:0] = (wbd.i0csrwonly & wbd.i0valid) ? i0_result_wb[31:0] : (wbd.i0csrwen & wbd.i0valid) ? write_csr_data[wbd.i0tid][31:0] : '0;\n\n\n// read the csr value through rs2 immed port\n   assign dec_i0_immed_d[31:0] = ({32{ i0_dp.csr_read}} & dec_i0_csr_rddata_d[31:0]) |\n                                 ({32{~i0_dp.csr_read}} & i0_immed_d[31:0]);\n\n// end csr stuff\n\n   assign     i0_immed_d[31:0] = ({32{i0_dp.imm12}} &   { {20{i0[31]}},i0[31:20] }) |  // jalr\n                                 ({32{i0_dp.shimm5}} &    {27'b0, i0[24:20]}) |\n                                 ({32{i0_jalimm20}} &   { {12{i0[31]}},i0[19:12],i0[20],i0[30:21],1'b0}) |\n                                 ({32{i0_uiimm20}}  &     {i0[31:12],12'b0 }) |\n                                 ({32{i0_csr_write_only_d & i0_dp.csr_imm}} & {27'b0,i0[19:15]});  // for csr's that only write csr, dont read csr\n\n\n   // all conditional branches are currently predict_nt\n   // change this to generate the sequential address for all other cases for NPC requirements at commit\n   assign dec_i0_br_immed_d[pt.BTB_TOFFSET_SIZE:1] = (i0_ap.predict_nt & ~i0_dp.jal) ? i0_br_offset[pt.BTB_TOFFSET_SIZE-1:0] : {{pt.BTB_TOFFSET_SIZE-2{1'b0}},i0_ap_pc4,i0_ap_pc2};\n\n\n   assign dec_i1_rs1_en_d = i1_dp.rs1 & (i1r.rs1[4:0] != 5'd0) & i1_valid_d;\n   assign dec_i1_rs2_en_d = i1_dp.rs2 & (i1r.rs2[4:0] != 5'd0) & i1_valid_d;\n   assign i1_rd_en_d      = i1_dp.rd  & (i1r.rd[4:0] != 5'd0)  & i1_valid_d;\n\n   assign dec_i1_rs1_d[4:0] = i1r.rs1[4:0];\n   assign dec_i1_rs2_d[4:0] = i1r.rs2[4:0];\n\n\n   assign i1_immed_d[31:0] = ({32{i1_dp.imm12}} &   { {20{i1[31]}},i1[31:20] }) |\n                             ({32{i1_dp.shimm5}} &    {27'b0, i1[24:20]}) |\n                             ({32{i1_jalimm20}} &   { {12{i1[31]}},i1[19:12],i1[20],i1[30:21],1'b0}) |\n                             ({32{i1_uiimm20}}  &     {i1[31:12],12'b0 });\n\n\n   assign dec_i1_immed_d[31:0] = i1_immed_d[31:0];\n\n\n   // jal is always +2 or +4\n   assign dec_i1_br_immed_d[pt.BTB_TOFFSET_SIZE:1] = (i1_ap.predict_nt & ~i1_dp.jal) ? i1_br_offset[pt.BTB_TOFFSET_SIZE-1:0] : {{pt.BTB_TOFFSET_SIZE-2{1'b0}},i1_ap_pc4,i1_ap_pc2};\n\n\n\n\n   assign i0_valid_d = dec_ib0_valid_d;\n   assign i1_valid_d = dec_ib1_valid_d;\n\n   assign i0_amo_stall_d =   i0_dp.atomic & lsu_amo_stall_any[dd.i0tid];\n   assign i1_amo_stall_d =   i1_dp.atomic & lsu_amo_stall_any[dd.i1tid];\n\n   assign i0_load_stall_d = (i0_dp.load) & (lsu_load_stall_any[dd.i0tid] | dma_dccm_stall_any);\n   assign i1_load_stall_d = (i1_dp.load) & (lsu_load_stall_any[dd.i1tid] | dma_dccm_stall_any);\n\n   assign i0_store_stall_d =  i0_dp.store & (lsu_store_stall_any[dd.i0tid] | dma_dccm_stall_any);\n   assign i1_store_stall_d =  i1_dp.store & (lsu_store_stall_any[dd.i1tid] | dma_dccm_stall_any);\n\n   assign i1_depend_i0_d = ((dec_i1_rs1_en_d & i0_dp.rd & (i1r.rs1[4:0] == i0r.rd[4:0])) |\n                            (dec_i1_rs2_en_d & i0_dp.rd & (i1r.rs2[4:0] == i0r.rd[4:0])))  & (dd.i0tid == dd.i1tid);\n\n\n\n   assign i1_load2_block_d = i1_dp.lsu & i0_dp.lsu;\n\n\n\n// some CSR reads need to be presync'd\n   assign i0_presync = i0_dp.presync | dec_tlu_presync_d[dd.i0tid] | debug_fence_i | debug_fence_raw | dec_tlu_pipelining_disable;  // both fence's presync\n\n// some CSR writes need to be postsync'd\n   assign i0_postsync = i0_dp.postsync | dec_tlu_postsync_d[dd.i0tid] | debug_fence_i | // only fence_i postsync\n                        (i0_csr_write_only_d & (i0[31:20] == 12'h7c2));   // wr_pause must postsync\n\n   assign i1_mul2_block_d  = i1_dp.mul & i0_dp.mul;\n\n\n// debug fence csr\n\n   assign debug_fence_i     = dec_debug_fence_d & dbg_cmd_wrdata[0];\n   assign debug_fence_raw   = dec_debug_fence_d & dbg_cmd_wrdata[1];\n\n   assign debug_fence = debug_fence_raw | debug_fence_i;    // fence_i causes a fence\n\n\n   assign i0_csr_write = i0_dp.csr_write & ~dec_debug_fence_d;\n\n\n// end debug\n\n\n\n\nalways_comb begin\n   i0blockp.csr_read_stall      = (i0_dp.csr_read & (dec_i0_csr_global_d ? prior_any_csr_write_any_thread : prior_csr_write[dd.i0tid])); // no csr bypass\n   i0blockp.extint_stall        = (dec_extint_stall & i0_dp.lsu);     // 1 external interrupt per cycle, block both threads\n   i0blockp.i1_cancel_e1_stall  = dec_i1_cancel_e1[dd.i0tid];                              // block i0 if same tid as i1_cancel_e1\n   i0blockp.pause_stall         = pause_stall[dd.i0tid];\n   i0blockp.leak1_stall         = leak1_i0_stall[dd.i0tid];                                // need 1 inst for debug single step\n   i0blockp.debug_stall         = dec_tlu_debug_stall[dd.i0tid];                           // stop decode for db-halt request\n   i0blockp.postsync_stall      = postsync_stall[dd.i0tid];\n   i0blockp.presync_stall       = presync_stall[dd.i0tid];\n   i0blockp.wait_lsu_idle_stall = ((i0_dp.fence | debug_fence | i0_dp.atomic) & ~lsu_idle[dd.i0tid]);   // fences only go out as i0 - presync'd\n   i0blockp.nonblock_load_stall = cam_i0_nonblock_load_stall[dd.i0tid];\n   i0blockp.nonblock_div_stall  = i0_nonblock_div_stall;\n   i0blockp.prior_div_stall     = i0_div_prior_div_stall;\n   i0blockp.load_stall          = i0_load_stall_d ;\n   i0blockp.store_stall         = i0_store_stall_d;\n   i0blockp.amo_stall           = i0_amo_stall_d  ;\n   i0blockp.load_block          = i0_load_block_d ;\n   i0blockp.mul_block           = i0_mul_block_d      ;\n   i0blockp.secondary_block     = i0_secondary_block_d;\n   i0blockp.secondary_stall     = i0_secondary_stall_d;\n\n   i1blockp.debug_valid_stall    = dec_i1_debug_valid_d;                     // debug insts must go out as i0\n   i1blockp.nonblock_load_stall  = cam_i1_nonblock_load_stall[dd.i1tid];\n   i1blockp.wait_lsu_idle_stall  = i1_dp.atomic & ~lsu_idle[dd.i1tid];       // allow atomics to go out as i1 unless lsu is not idle\n   i1blockp.extint_stall         = dec_extint_stall & i1_dp.lsu;             // 1 external interrupt per cycle, block both threads\n   i1blockp.i1_cancel_e1_stall   = dec_i1_cancel_e1[dd.i1tid];               // block i1 if same tid as i1_cancel_e1\n   i1blockp.pause_stall          = pause_stall[dd.i1tid];\n   i1blockp.debug_stall          = dec_tlu_debug_stall[dd.i1tid];\n   i1blockp.postsync_stall       = postsync_stall[dd.i1tid];\n   i1blockp.presync_stall        = presync_stall[dd.i1tid];\n   i1blockp.nonblock_div_stall   = i1_nonblock_div_stall;\n   i1blockp.load_stall           = i1_load_stall_d;\n   i1blockp.store_stall          = i1_store_stall_d;\n   i1blockp.amo_stall            = i1_amo_stall_d ;\n   i1blockp.load_block           = i1_load_block_d;\n   i1blockp.mul_block            = i1_mul_block_d;\n   i1blockp.load2_block          = i1_load2_block_d;                         // thread independent; back-to-back load's at decode\n   i1blockp.mul2_block           = i1_mul2_block_d;                          // thread independent\n   i1blockp.secondary_block      = i1_secondary_block_d;                     // threaded; secondary alu data not ready and op is not alu\n   i1blockp.leak1_stall          = leak1_i1_stall[dd.i1tid];\n   i1blockp.i0_only_block        = i1_dp.i0_only;\n   i1blockp.icaf_block           = i1_icaf_d;\n   i1blockp.block_same_thread    = i1_block_same_thread_d & (dd.i0tid == dd.i1tid);\n\n\nend\n\n\n   assign i0_div_prior_div_stall = i0_dp.div & div_stall;\n\n   assign i0_block_d = (|i0blockp);\n\n   assign i1_block_d = (|i1blockp);\n\n   assign i1_depend_i0_case_d = (i1_depend_i0_d & ~non_block_case_d & ~store_data_bypass_i0_e2_c2);\n\n\n   assign i1_block_same_thread_d =  i0_jal |               // all the i1 block cases for ST - none of these valid for MT\n\n                                    i0_presync |\n                                    i0_postsync |\n\n                                    i0_dp.csr_read  |      // thread independent\n                                    i0_dp.csr_write |\n\n                                    dec_tlu_dual_issue_disable |\n\n                                    i1_depend_i0_case_d |\n                                    i0_icaf_d ;             // dont allow i1 decode if icaf in i0\n\n\n\n\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n      assign dec_thread_stall_in[i] =\n                                     // exact 1 cycle stall\n                                      (i0_valid_d & i0_mul_block_thread_1cycle_d & (dd.i0tid==i)) |\n                                      (i1_valid_d & i1_mul_block_thread_1cycle_d & (dd.i1tid==i) & (dd.i0tid!=dd.i1tid)) |\n\n                                     // exact 1 cycle stall\n                                      (i0_valid_d & i0_secondary_stall_thread_1cycle_d & (dd.i0tid==i)) |\n                                      (i0_valid_d & i0_secondary_block_thread_1cycle_d & (dd.i0tid==i)) |\n                                      (i1_valid_d & i1_secondary_block_thread_1cycle_d & (dd.i1tid==i) & (dd.i0tid!=dd.i1tid)) |\n\n                                     // exact 2 cycle stall\n                                      smt_secondary_stall[i]           |\n\n                                      smt_csr_write_stall_in[i]        |\n\n                                      smt_atomic_stall_in[i]           |\n\n                                      smt_div_stall_in[i]              |\n\n                                      pause_state_in[i]                |\n                                      postsync_stall_in[i]             |\n                                      smt_presync_stall_in[i]          |\n\n                                      smt_nonblock_load_stall[i];  // for nonblock load stalls\n\n\n   end\n\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n\n      assign flush_all[i] = flush_lower_wb[i] | flush_final_e3[i];\n\n      // secondary smt optimizations\n      assign smt_secondary_stall_in[i] = ((i0_valid_d & i0_secondary_stall_thread_2cycle_d & (dd.i0tid==i)) |\n                                          (i0_valid_d & i0_secondary_block_thread_2cycle_d & (dd.i0tid==i)) |\n                                          (i1_valid_d & i1_secondary_block_thread_2cycle_d & (dd.i1tid==i) & (dd.i0tid!=dd.i1tid))) & ~flush_all[i];\n\n\n      // asserted for exactly 2 cycles\n      assign smt_secondary_stall[i] = (smt_secondary_stall_in[i] | smt_secondary_stall_raw[i]) & ~flush_all[i];\n\n      // presync smt optimizations\n      assign set_smt_presync_stall[i] = i0_valid_d & i0_presync & prior_inflight_e1e4[i] & (dd.i0tid==i) & ~flush_all[i];\n\n      assign smt_presync_stall_in[i] =  set_smt_presync_stall[i] | smt_presync_stall[i];\n\n\n\n      assign smt_presync_stall[i] = smt_presync_stall_raw[i] & prior_inflight_e1e4[i] & ~flush_all[i];\n\n      // csr_write smt optimizations\n      assign set_smt_csr_write_stall[i] = i0_valid_d & i0_dp.csr_read & ~dec_i0_csr_global_d & prior_csr_write_e1e4[i] & (dd.i0tid==i) & ~flush_all[i];\n\n      assign smt_csr_write_stall_in[i] =  set_smt_csr_write_stall[i] | smt_csr_write_stall[i];\n\n\n      assign smt_csr_write_stall[i] = smt_csr_write_stall_raw[i] & prior_csr_write_e1e4[i] & ~flush_all[i];\n\n      // atomic smt optimizations\n      assign set_smt_atomic_stall[i] = i0_valid_d & (i0_dp.fence | i0_dp.atomic) & ~lsu_idle[i] & (dd.i0tid==i) & ~flush_all[i];\n\n      assign smt_atomic_stall_in[i] =  set_smt_atomic_stall[i] | smt_atomic_stall[i];\n\n\n      assign smt_atomic_stall[i] = smt_atomic_stall_raw[i] & ~lsu_idle[i] & ~flush_all[i];\n\n      // div smt optimizations\n      assign set_smt_div_stall[i] =\n                                    ((i0_valid_d & i0_dp.div & div_valid   & (dd.i0tid==i) & (dd.i0tid==div_tid)) |\n                                     (i1_valid_d & i1_dp.div & div_valid   & (dd.i1tid==i) & (dd.i1tid==div_tid) & (dd.i0tid!=dd.i1tid)) |\n                                     (i0_valid_d  & i0_nonblock_div_stall  & (dd.i0tid==i))  |\n                                     (i1_valid_d  & i1_nonblock_div_stall  & (dd.i1tid==i) & (dd.i0tid!=dd.i1tid))) & ~flush_all[i];\n\n      assign smt_div_stall_in[i] =  set_smt_div_stall[i] | smt_div_stall[i];\n\n\n      assign smt_div_stall[i] = smt_div_stall_raw[i] & div_valid & ~flush_all[i];\n\n\n      // nonblock load optimizations\n      assign set_smt_nonblock_load_stall[i] = i0_valid_d & cam_i0_nonblock_load_stall[i] & (dd.i0tid==i) & ~flush_all[i];\n\n      assign smt_nonblock_load_stall_in[i] =  set_smt_nonblock_load_stall[i] | smt_nonblock_load_stall[i];\n\n\n      assign smt_nonblock_load_stall[i] = smt_nonblock_load_stall_raw[i] & cam_nonblock_load_stall[i] & ~flush_all[i];\n\n   end\n\n\n\n   // all legals go here\n\n\n   assign i0_any_csr_d = i0_dp.csr_read | i0_csr_write;\n\n   assign i0_csr_legal_d = dec_i0_csr_legal_d;\n\n\n   if (pt.ATOMIC_ENABLE == 0)\n     begin\n       assign i0_atomic_legal      =  ~(i0_dp.atomic);\n       assign i1_atomic_legal      =  ~(i1_dp.atomic);\n     end\n   else\n     begin\n       assign i0_atomic_legal      =  1'b1;\n       assign i1_atomic_legal      =  1'b1;\n     end\n\n\n   if       (pt.BITMANIP_ZBB == 1)\n     begin\n       assign i0_bitmanip_zbb_legal      =  1'b1;\n       assign i1_bitmanip_zbb_legal      =  1'b1;\n     end\n   else\n     begin\n       assign i0_bitmanip_zbb_legal      = ~(i0_dp.zbb & ~i0_dp.zbp);\n       assign i1_bitmanip_zbb_legal      = ~(i1_dp.zbb & ~i1_dp.zbp);\n     end\n\n\n   if       (pt.BITMANIP_ZBS == 1)\n     begin\n       assign i0_bitmanip_zbs_legal      =  1'b1;\n       assign i1_bitmanip_zbs_legal      =  1'b1;\n     end\n   else\n     begin\n       assign i0_bitmanip_zbs_legal      = ~i0_dp.zbs;\n       assign i1_bitmanip_zbs_legal      = ~i1_dp.zbs;\n     end\n\n\n   if       (pt.BITMANIP_ZBE == 1)\n     begin\n       assign i0_bitmanip_zbe_legal      =  1'b1;\n       assign i1_bitmanip_zbe_legal      =  1'b1;\n     end\n   else\n     begin\n       assign i0_bitmanip_zbe_legal      = ~(i0_dp.zbe & ~i0_dp.zbp & ~i0_dp.zbf);\n       assign i1_bitmanip_zbe_legal      = ~(i1_dp.zbe & ~i1_dp.zbp & ~i1_dp.zbf);\n     end\n\n\n   if       (pt.BITMANIP_ZBC == 1)\n     begin\n       assign i0_bitmanip_zbc_legal      =  1'b1;\n       assign i1_bitmanip_zbc_legal      =  1'b1;\n     end\n   else\n     begin\n       assign i0_bitmanip_zbc_legal      = ~i0_dp.zbc;\n       assign i1_bitmanip_zbc_legal      = ~i1_dp.zbc;\n     end\n\n\n   if       (pt.BITMANIP_ZBP == 1)\n     begin\n       assign i0_bitmanip_zbp_legal      =  1'b1;\n       assign i1_bitmanip_zbp_legal      =  1'b1;\n     end\n   else\n     begin\n       assign i0_bitmanip_zbp_legal      = ~(i0_dp.zbp & ~i0_dp.zbb & ~i0_dp.zbe & ~i0_dp.zbf);\n       assign i1_bitmanip_zbp_legal      = ~(i1_dp.zbp & ~i1_dp.zbb & ~i1_dp.zbe & ~i1_dp.zbf);\n     end\n\n\n   if       (pt.BITMANIP_ZBR == 1)\n     begin\n       assign i0_bitmanip_zbr_legal      =  1'b1;\n       assign i1_bitmanip_zbr_legal      =  1'b1;\n     end\n   else\n     begin\n       assign i0_bitmanip_zbr_legal      = ~i0_dp.zbr;\n       assign i1_bitmanip_zbr_legal      = ~i1_dp.zbr;\n     end\n\n\n   if       (pt.BITMANIP_ZBF == 1)\n     begin\n       assign i0_bitmanip_zbf_legal      =  1'b1;\n       assign i1_bitmanip_zbf_legal      =  1'b1;\n     end\n   else\n     begin\n       assign i0_bitmanip_zbf_legal      = ~(i0_dp.zbf & ~i0_dp.zbp & ~i0_dp.zbe);\n       assign i1_bitmanip_zbf_legal      = ~(i1_dp.zbf & ~i1_dp.zbp & ~i1_dp.zbe);\n     end\n\n\n   if (pt.BITMANIP_ZBA == 1)\n     begin\n       assign i0_bitmanip_zba_legal      =  1'b1;\n       assign i1_bitmanip_zba_legal      =  1'b1;\n     end\n   else\n     begin\n       assign i0_bitmanip_zba_legal      = ~i0_dp.zba;\n       assign i1_bitmanip_zba_legal      = ~i1_dp.zba;\n     end\n\n\n   if     ( (pt.BITMANIP_ZBB == 1) | (pt.BITMANIP_ZBP == 1) )\n     begin\n       assign i0_bitmanip_zbb_zbp_legal  =  1'b1;\n       assign i1_bitmanip_zbb_zbp_legal  =  1'b1;\n     end\n   else\n     begin\n       assign i0_bitmanip_zbb_zbp_legal  = ~(i0_dp.zbb & i0_dp.zbp & ~i0_dp.zbf);                                          // added ~ZBF to exclude ZEXT.H\n       assign i1_bitmanip_zbb_zbp_legal  = ~(i1_dp.zbb & i1_dp.zbp & ~i1_dp.zbf);                                          // added ~ZBF to exclude ZEXT.H\n     end\n\n\n "}
{"text": "  if     ( (pt.BITMANIP_ZBP == 1) | (pt.BITMANIP_ZBE == 1)  | (pt.BITMANIP_ZBF == 1))\n     begin\n       assign i0_bitmanip_zbp_zbe_zbf_legal      =  1'b1;\n       assign i1_bitmanip_zbp_zbe_zbf_legal      =  1'b1;\n     end\n   else\n     begin\n       assign i0_bitmanip_zbp_zbe_zbf_legal      = ~(i0_dp.zbp & i0_dp.zbe &  i0_dp.zbf & ~i0_dp.zbb);                     // added ~ZBB to exclude ZEXT.H\n       assign i1_bitmanip_zbp_zbe_zbf_legal      = ~(i1_dp.zbp & i1_dp.zbe &  i1_dp.zbf & ~i1_dp.zbb);                     // added ~ZBB to exclude ZEXT.H\n     end\n\n\n   if     ( (pt.BITMANIP_ZBB == 1) | (pt.BITMANIP_ZBP == 1) | (pt.BITMANIP_ZBE == 1)  | (pt.BITMANIP_ZBF == 1))\n     begin\n       assign i0_bitmanip_zbb_zbp_zbe_zbf_legal  =  1'b1;\n       assign i1_bitmanip_zbb_zbp_zbe_zbf_legal  =  1'b1;\n     end\n   else\n     begin\n       assign i0_bitmanip_zbb_zbp_zbe_zbf_legal  = ~(i0_dp.zbp & i0_dp.zbe &  i0_dp.zbf &  i0_dp.zbb);                     // added only for ZEXT.H\n       assign i1_bitmanip_zbb_zbp_zbe_zbf_legal  = ~(i1_dp.zbp & i1_dp.zbe &  i1_dp.zbf &  i1_dp.zbb);                     // added only for ZEXT.H\n     end\n\n\n\n   assign i0_bitmanip_legal =  i0_bitmanip_zbb_legal & i0_bitmanip_zbs_legal & i0_bitmanip_zbe_legal & i0_bitmanip_zbc_legal & i0_bitmanip_zbp_legal & i0_bitmanip_zbr_legal & i0_bitmanip_zbf_legal & i0_bitmanip_zba_legal & i0_bitmanip_zbb_zbp_legal & i0_bitmanip_zbp_zbe_zbf_legal & i0_bitmanip_zbb_zbp_zbe_zbf_legal;\n\n   assign i1_bitmanip_legal =  i1_bitmanip_zbb_legal & i1_bitmanip_zbs_legal & i1_bitmanip_zbe_legal & i1_bitmanip_zbc_legal & i1_bitmanip_zbp_legal & i1_bitmanip_zbr_legal & i1_bitmanip_zbf_legal & i1_bitmanip_zba_legal & i1_bitmanip_zbb_zbp_legal & i1_bitmanip_zbp_zbe_zbf_legal & i1_bitmanip_zbb_zbp_zbe_zbf_legal;\n\n\n\n   assign i0_legal = i0_dp.legal & (~i0_any_csr_d | i0_csr_legal_d) & i0_bitmanip_legal & i0_atomic_legal;\n\n   assign i0_legal_except_csr = i0_dp.legal & i0_bitmanip_legal & i0_atomic_legal;\n\n   assign i1_legal = i1_dp.legal            & i1_bitmanip_legal & i1_atomic_legal;\n\n\n   // illegal inst handling\n\n   assign i0_inst_d[31:0] = (dec_i0_pc4_d) ? i0[31:0] : {16'b0, dec_i0_cinst_d[15:0] };\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin : illegal\n\n      assign shift_illegal[i] = dec_i0_decode_d & ~i0_legal & (i == dd.i0tid);\n\n      assign illegal_inst_en[i] = shift_illegal[i] & ~illegal_lockout[i];\n\n      assign illegal_lockout_in[i] = (shift_illegal[i] | illegal_lockout[i]) & ~flush_final_e3[i];\n\n\n      rvdffe #(32) illegal_any_ff  (.*,\n                                    .en(illegal_inst_en[i]),\n                                    .din(i0_inst_d[31:0]),\n                                    .dout(illegal_inst[i][31:0]));\n\n\n   end\n\n   assign dec_illegal_inst[pt.NUM_THREADS-1:0] = illegal_inst[pt.NUM_THREADS-1:0];\n\n\n\n\n\n   // allow illegals to flow down the pipe\n   assign dec_i0_decode_d = i0_valid_d & ~i0_block_d & ~flush_lower_wb[dd.i0tid] & ~flush_final_e3[dd.i0tid];\n\n   // define i0 legal decode\n   assign i0_legal_decode_d = dec_i0_decode_d & i0_legal;\n\n\n   // Case where t0 in i0 has illegal and it affects t1 in i1 for bypass\n\n   // For timing only consider i0_legal without csr considerations - also does not include all br error cases\n\n   assign dec_i1_decode_d = (dd.i0tid==dd.i1tid) ? (dec_i0_decode_d & i0_legal_except_csr & i1_valid_d & i1_legal & ~i1_block_d & ~flush_lower_wb[dd.i1tid] & ~flush_final_e3[dd.i1tid]) :\n                                                   (                  i0_legal_except_csr & i1_valid_d & i1_legal & ~i1_block_d & ~flush_lower_wb[dd.i1tid] & ~flush_final_e3[dd.i1tid]);\n\n\n   assign i1_legal_decode_d = dec_i1_decode_d & i1_legal;\n\n   assign dec_force_favor_flip_d = i0_valid_d & i1_valid_d & (dd.i0tid ^ dd.i1tid) & (~i1_legal | i1_icaf_d | leak1_i1_stall[dd.i1tid] | dec_i1_debug_valid_d);  // force favor bit flip\n\n\n   // performance monitor signals\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n      assign dec_pmu_instr_decoded[i][1:0] = { dec_i1_decode_d & (dd.i1tid==i), dec_i0_decode_d & (dd.i0tid==i) };\n   end\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n      assign dec_pmu_decode_stall[i] = ((i == dd.i0tid) & i0_valid_d & ~dec_i0_decode_d) |\n                                       ((i == dd.i1tid) & i1_valid_d & ~dec_i1_decode_d & (dd.i0tid!=dd.i1tid));\n\n\n      assign dec_pmu_postsync_stall[i] = ((i == dd.i0tid) & i0_valid_d & postsync_stall[i]) |\n                                         ((i == dd.i1tid) & i1_valid_d & postsync_stall[i] & (dd.i0tid!=dd.i1tid));\n\n      assign dec_pmu_presync_stall[i] = ((i == dd.i0tid) & i0_valid_d & presync_stall[i]) |\n                                        ((i == dd.i1tid) & i1_valid_d & presync_stall[i] & (dd.i0tid!=dd.i1tid));\n\n   end\n\n\n   // thread presyncs and postsyncs\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n      // lets make ebreak, ecall, mret postsync, so break sync into pre and post\n\n      assign presync_stall[i] = i0_valid_d & i0_presync & (dd.i0tid==i) & prior_inflight[i];\n\n      // illegals will postsync\n      assign base_postsync_stall_in[i] =  (dec_i0_decode_d & (dd.i0tid == i) & (i0_postsync | ~i0_legal))  |\n                                          (base_postsync_stall[i] & prior_inflight_e1e4[i]);\n\n\n      // jal's will flush, so postsync\n      // can't stall more than e1e3 or else delay correct path after jal mispredict\n      assign jal_postsync_stall_in[i] = (dec_i0_decode_d & (dd.i0tid == i) & i0_jal)  |\n                                        (dec_i1_decode_d & (dd.i1tid == i) & i1_jal ) |\n                                        (jal_postsync_stall[i] & prior_inflight_e1e3[i]);\n\n\n\n      assign postsync_stall_in[i] = base_postsync_stall_in[i] | jal_postsync_stall_in[i];\n\n      assign postsync_stall[i] = base_postsync_stall[i] | jal_postsync_stall[i];\n\n\n      assign prior_inflight_e1e3[i] =    |{ e1d.i0valid & (e1d.i0tid == i),\n                                            e2d.i0valid & (e2d.i0tid == i),\n                                            e3d.i0valid & (e3d.i0tid == i),\n                                            e1d.i1valid & (e1d.i1tid == i),\n                                            e2d.i1valid & (e2d.i1tid == i),\n                                            e3d.i1valid & (e3d.i1tid == i)\n                                            };\n\n      assign prior_inflight_e1e4[i] =    |{ prior_inflight_e1e3[i],\n                                            e4d.i0valid & (e4d.i0tid == i),\n                                            e4d.i1valid & (e4d.i1tid == i)\n                                            };\n\n\n      assign prior_inflight_wb[i] =            |{\n                                                 wbd.i0valid & (wbd.i0tid == i),\n                                                 wbd.i1valid & (wbd.i1tid == i)\n                                                 };\n\n\n      assign prior_inflight[i] = prior_inflight_e1e4[i] | prior_inflight_wb[i];\n\n\n      // block reads if there is a prior csr write in the pipeline\n\n      assign prior_csr_write_e1e4[i] = (e1d.i0csrwonly & (e1d.i0tid==i)) |\n                                       (e2d.i0csrwonly & (e2d.i0tid==i)) |\n                                       (e3d.i0csrwonly & (e3d.i0tid==i)) |\n                                       (e4d.i0csrwonly & (e4d.i0tid==i));\n\n      assign prior_csr_write[i] = prior_csr_write_e1e4[i] |\n                                  (wbd.i0csrwonly & (wbd.i0tid==i));\n\n\n\n   end\n\n   assign prior_any_csr_write_any_thread_e1e4 = (e1d.i0csrwen) |\n                                                (e2d.i0csrwen) |\n                                                (e3d.i0csrwen) |\n                                                (e4d.i0csrwen);\n\n   assign prior_any_csr_write_any_thread = prior_any_csr_write_any_thread_e1e4 |\n                                           (wbd.i0csrwen);\n\n\n   assign dec_i0_alu_decode_d = i0_legal_decode_d & i0_dp.alu & ~i0_secondary_d & ~i0_br_error_all;\n   assign dec_i1_alu_decode_d = i1_legal_decode_d & i1_dp.alu & ~i1_secondary_d & ~i1_br_error_all;\n\n   assign lsu_decode_d = (i0_legal_decode_d & i0_dp.lsu & ~i0_br_error_all) |\n                         (i1_legal_decode_d & i1_dp.lsu & ~i1_br_error_all);\n\n   assign mul_decode_d = (i0_legal_decode_d & i0_dp.mul & ~i0_br_error_all) |\n                         (i1_legal_decode_d & i1_dp.mul & ~i1_br_error_all);\n\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n\n\n      assign flush_final_e3[i] = i0_flush_final_e3[i] | i1_flush_final_e3[i];\n\n   end\n\n\n// scheduling logic for primary and secondary alu's\n\n   assign i0_rs1_depend_i0_e1 = dec_i0_rs1_en_d & e1d.i0v & (e1d.i0rd[4:0] == i0r.rs1[4:0]) & (e1d.i0tid == dd.i0tid);\n   assign i0_rs1_depend_i0_e2 = dec_i0_rs1_en_d & e2d.i0v & (e2d.i0rd[4:0] == i0r.rs1[4:0]) & (e2d.i0tid == dd.i0tid);\n   assign i0_rs1_depend_i0_e3 = dec_i0_rs1_en_d & e3d.i0v & (e3d.i0rd[4:0] == i0r.rs1[4:0]) & (e3d.i0tid == dd.i0tid);\n   assign i0_rs1_depend_i0_e4 = dec_i0_rs1_en_d & e4d.i0v & (e4d.i0rd[4:0] == i0r.rs1[4:0]) & (e4d.i0tid == dd.i0tid);\n   assign i0_rs1_depend_i0_wb = dec_i0_rs1_en_d & wbd.i0v & (wbd.i0rd[4:0] == i0r.rs1[4:0]) & (wbd.i0tid == dd.i0tid);\n\n   assign i0_rs1_depend_i1_e1 = dec_i0_rs1_en_d & e1d.i1v & (e1d.i1rd[4:0] == i0r.rs1[4:0]) & (e1d.i1tid == dd.i0tid);\n   assign i0_rs1_depend_i1_e2 = dec_i0_rs1_en_d & e2d.i1v & (e2d.i1rd[4:0] == i0r.rs1[4:0]) & (e2d.i1tid == dd.i0tid);\n   assign i0_rs1_depend_i1_e3 = dec_i0_rs1_en_d & e3d.i1v & (e3d.i1rd[4:0] == i0r.rs1[4:0]) & (e3d.i1tid == dd.i0tid);\n   assign i0_rs1_depend_i1_e4 = dec_i0_rs1_en_d & e4d.i1v & (e4d.i1rd[4:0] == i0r.rs1[4:0]) & (e4d.i1tid == dd.i0tid);\n   assign i0_rs1_depend_i1_wb = dec_i0_rs1_en_d & wbd.i1v & (wbd.i1rd[4:0] == i0r.rs1[4:0]) & (wbd.i1tid == dd.i0tid);\n\n   assign i0_rs2_depend_i0_e1 = dec_i0_rs2_en_d & e1d.i0v & (e1d.i0rd[4:0] == i0r.rs2[4:0]) & (e1d.i0tid == dd.i0tid);\n   assign i0_rs2_depend_i0_e2 = dec_i0_rs2_en_d & e2d.i0v & (e2d.i0rd[4:0] == i0r.rs2[4:0]) & (e2d.i0tid == dd.i0tid);\n   assign i0_rs2_depend_i0_e3 = dec_i0_rs2_en_d & e3d.i0v & (e3d.i0rd[4:0] == i0r.rs2[4:0]) & (e3d.i0tid == dd.i0tid);\n   assign i0_rs2_depend_i0_e4 = dec_i0_rs2_en_d & e4d.i0v & (e4d.i0rd[4:0] == i0r.rs2[4:0]) & (e4d.i0tid == dd.i0tid);\n   assign i0_rs2_depend_i0_wb = dec_i0_rs2_en_d & wbd.i0v & (wbd.i0rd[4:0] == i0r.rs2[4:0]) & (wbd.i0tid == dd.i0tid);\n\n   assign i0_rs2_depend_i1_e1 = dec_i0_rs2_en_d & e1d.i1v & (e1d.i1rd[4:0] == i0r.rs2[4:0]) & (e1d.i1tid == dd.i0tid);\n   assign i0_rs2_depend_i1_e2 = dec_i0_rs2_en_d & e2d.i1v & (e2d.i1rd[4:0] == i0r.rs2[4:0]) & (e2d.i1tid == dd.i0tid);\n   assign i0_rs2_depend_i1_e3 = dec_i0_rs2_en_d & e3d.i1v & (e3d.i1rd[4:0] == i0r.rs2[4:0]) & (e3d.i1tid == dd.i0tid);\n   assign i0_rs2_depend_i1_e4 = dec_i0_rs2_en_d & e4d.i1v & (e4d.i1rd[4:0] == i0r.rs2[4:0]) & (e4d.i1tid == dd.i0tid);\n   assign i0_rs2_depend_i1_wb = dec_i0_rs2_en_d & wbd.i1v & (wbd.i1rd[4:0] == i0r.rs2[4:0]) & (wbd.i1tid == dd.i0tid);\n\n\n   assign i1_rs1_depend_i0_e1 = dec_i1_rs1_en_d & e1d.i0v & (e1d.i0rd[4:0] == i1r.rs1[4:0]) & (e1d.i0tid == dd.i1tid);\n   assign i1_rs1_depend_i0_e2 = dec_i1_rs1_en_d & e2d.i0v & (e2d.i0rd[4:0] == i1r.rs1[4:0]) & (e2d.i0tid == dd.i1tid);\n   assign i1_rs1_depend_i0_e3 = dec_i1_rs1_en_d & e3d.i0v & (e3d.i0rd[4:0] == i1r.rs1[4:0]) & (e3d.i0tid == dd.i1tid);\n   assign i1_rs1_depend_i0_e4 = dec_i1_rs1_en_d & e4d.i0v & (e4d.i0rd[4:0] == i1r.rs1[4:0]) & (e4d.i0tid == dd.i1tid);\n   assign i1_rs1_depend_i0_wb = dec_i1_rs1_en_d & wbd.i0v & (wbd.i0rd[4:0] == i1r.rs1[4:0]) & (wbd.i0tid == dd.i1tid);\n\n   assign i1_rs1_depend_i1_e1 = dec_i1_rs1_en_d & e1d.i1v & (e1d.i1rd[4:0] == i1r.rs1[4:0]) & (e1d.i1tid == dd.i1tid);\n   assign i1_rs1_depend_i1_e2 = dec_i1_rs1_en_d & e2d.i1v & (e2d.i1rd[4:0] == i1r.rs1[4:0]) & (e2d.i1tid == dd.i1tid);\n   assign i1_rs1_depend_i1_e3 = dec_i1_rs1_en_d & e3d.i1v & (e3d.i1rd[4:0] == i1r.rs1[4:0]) & (e3d.i1tid == dd.i1tid);\n   assign i1_rs1_depend_i1_e4 = dec_i1_rs1_en_d & e4d.i1v & (e4d.i1rd[4:0] == i1r.rs1[4:0]) & (e4d.i1tid == dd.i1tid);\n   assign i1_rs1_depend_i1_wb = dec_i1_rs1_en_d & wbd.i1v & (wbd.i1rd[4:0] == i1r.rs1[4:0]) & (wbd.i1tid == dd.i1tid);\n\n   assign i1_rs2_depend_i0_e1 = dec_i1_rs2_en_d & e1d.i0v & (e1d.i0rd[4:0] == i1r.rs2[4:0]) & (e1d.i0tid == dd.i1tid);\n   assign i1_rs2_depend_i0_e2 = dec_i1_rs2_en_d & e2d.i0v & (e2d.i0rd[4:0] == i1r.rs2[4:0]) & (e2d.i0tid == dd.i1tid);\n   assign i1_rs2_depend_i0_e3 = dec_i1_rs2_en_d & e3d.i0v & (e3d.i0rd[4:0] == i1r.rs2[4:0]) & (e3d.i0tid == dd.i1tid);\n   assign i1_rs2_depend_i0_e4 = dec_i1_rs2_en_d & e4d.i0v & (e4d.i0rd[4:0] == i1r.rs2[4:0]) & (e4d.i0tid == dd.i1tid);\n   assign i1_rs2_depend_i0_wb = dec_i1_rs2_en_d & wbd.i0v & (wbd.i0rd[4:0] == i1r.rs2[4:0]) & (wbd.i0tid == dd.i1tid);\n\n   assign i1_rs2_depend_i1_e1 = dec_i1_rs2_en_d & e1d.i1v & (e1d.i1rd[4:0] == i1r.rs2[4:0]) & (e1d.i1tid == dd.i1tid);\n   assign i1_rs2_depend_i1_e2 = dec_i1_rs2_en_d & e2d.i1v & (e2d.i1rd[4:0] == i1r.rs2[4:0]) & (e2d.i1tid == dd.i1tid);\n   assign i1_rs2_depend_i1_e3 = dec_i1_rs2_en_d & e3d.i1v & (e3d.i1rd[4:0] == i1r.rs2[4:0]) & (e3d.i1tid == dd.i1tid);\n   assign i1_rs2_depend_i1_e4 = dec_i1_rs2_en_d & e4d.i1v & (e4d.i1rd[4:0] == i1r.rs2[4:0]) & (e4d.i1tid == dd.i1tid);\n   assign i1_rs2_depend_i1_wb = dec_i1_rs2_en_d & wbd.i1v & (wbd.i1rd[4:0] == i1r.rs2[4:0]) & (wbd.i1tid == dd.i1tid);\n\n// define bypasses for e2 stage - 1 is youngest\n\n   assign dd.i0rs1bype2[1:0] = {  i0_dp.alu & i0_rs1_depth_d[3:0] == 4'd5 & i0_rs1_class_d.sec,\n                                  i0_dp.alu & i0_rs1_depth_d[3:0] == 4'd6 & i0_rs1_class_d.sec };\n\n   assign dd.i0rs2bype2[1:0] = {  i0_dp.alu & i0_rs2_depth_d[3:0] == 4'd5 & i0_rs2_class_d.sec,\n                                  i0_dp.alu & i0_rs2_depth_d[3:0] == 4'd6 & i0_rs2_class_d.sec };\n\n   assign dd.i1rs1bype2[1:0] = {  i1_dp.alu & i1_rs1_depth_d[3:0] == 4'd5 & i1_rs1_class_d.sec,\n                                  i1_dp.alu & i1_rs1_depth_d[3:0] == 4'd6 & i1_rs1_class_d.sec };\n\n   assign dd.i1rs2bype2[1:0] = {  i1_dp.alu & i1_rs2_depth_d[3:0] == 4'd5 & i1_rs2_class_d.sec,\n                                  i1_dp.alu & i1_rs2_depth_d[3:0] == 4'd6 & i1_rs2_class_d.sec };\n\n\n   assign i1_result_wb_eff[31:0] = i1_result_wb[31:0];\n\n   assign i0_result_wb_eff[31:0] = i0_result_wb[31:0];\n\n\n   assign i0_rs1_bypass_data_e2[31:0] = ({32{e2d.i0rs1bype2[1]}} & i1_result_wb_eff[31:0]) |\n                                        ({32{e2d.i0rs1bype2[0]}} & i0_result_wb_eff[31:0]);\n\n   assign i0_rs2_bypass_data_e2[31:0] = ({32{e2d.i0rs2bype2[1]}} & i1_result_wb_eff[31:0]) |\n                                        ({32{e2d.i0rs2bype2[0]}} & i0_result_wb_eff[31:0]);\n\n   assign i1_rs1_bypass_data_e2[31:0] = ({32{e2d.i1rs1bype2[1]}} & i1_result_wb_eff[31:0]) |\n                                        ({32{e2d.i1rs1bype2[0]}} & i0_result_wb_eff[31:0]);\n\n   assign i1_rs2_bypass_data_e2[31:0] = ({32{e2d.i1rs2bype2[1]}} & i1_result_wb_eff[31:0]) |\n                                        ({32{e2d.i1rs2bype2[0]}} & i0_result_wb_eff[31:0]);\n\n\n   assign dec_i0_rs1_bypass_en_e2 = |e2d.i0rs1bype2[1:0];\n   assign dec_i0_rs2_bypass_en_e2 = |e2d.i0rs2bype2[1:0];\n   assign dec_i1_rs1_bypass_en_e2 = |e2d.i1rs1bype2[1:0];\n   assign dec_i1_rs2_bypass_en_e2 = |e2d.i1rs2bype2[1:0];\n\n\n// define bypasses for e3 stage before secondary alu's\n\n\n   assign i1_rs1_depend_i0_d = dec_i1_rs1_en_d & i0_dp.rd & (i1r.rs1[4:0] == i0r.rd[4:0]) & (dd.i1tid == dd.i0tid);\n   assign i1_rs2_depend_i0_d = dec_i1_rs2_en_d & i0_dp.rd & (i1r.rs2[4:0] == i0r.rd[4:0]) & (dd.i1tid == dd.i0tid);\n\n\n// i0\n   assign dd.i0rs1bype3[3:0] = { i0_dp.alu & i0_rs1_depth_d[3:0]==4'd1 & (i0_rs1_class_d.sec | i0_rs1_class_d.load | i0_rs1_class_d.mul),\n                                 i0_dp.alu & i0_rs1_depth_d[3:0]==4'd2 & (i0_rs1_class_d.sec | i0_rs1_class_d.load | i0_rs1_class_d.mul),\n                                 i0_dp.alu & i0_rs1_depth_d[3:0]==4'd3 & (i0_rs1_class_d.sec | i0_rs1_class_d.load | i0_rs1_class_d.mul),\n                                 i0_dp.alu & i0_rs1_depth_d[3:0]==4'd4 & (i0_rs1_class_d.sec | i0_rs1_class_d.load | i0_rs1_class_d.mul) };\n\n   assign dd.i0rs2bype3[3:0] = { i0_dp.alu & i0_rs2_depth_d[3:0]==4'd1 & (i0_rs2_class_d.sec | i0_rs2_class_d.load | i0_rs2_class_d.mul),\n                                 i0_dp.alu & i0_rs2_depth_d[3:0]==4'd2 & (i0_rs2_class_d.sec | i0_rs2_class_d.load | i0_rs2_class_d.mul),\n                                 i0_dp.alu & i0_rs2_depth_d[3:0]==4'd3 & (i0_rs2_class_d.sec | i0_rs2_class_d.load | i0_rs2_class_d.mul),\n                                 i0_dp.alu & i0_rs2_depth_d[3:0]==4'd4 & (i0_rs2_class_d.sec | i0_rs2_class_d.load | i0_rs2_class_d.mul) };\n\n// i1\n\n   assign i1rs1_intra[2:0] = {   i1_dp.alu & i0_dp.alu  & i1_rs1_depend_i0_d,\n                                 i1_dp.alu & i0_dp.mul  & i1_rs1_depend_i0_d,\n                                 i1_dp.alu & i0_dp.load & i1_rs1_depend_i0_d\n                                 };\n\n   assign i1rs2_intra[2:0] = {   i1_dp.alu & i0_dp.alu  & i1_rs2_depend_i0_d,\n                                 i1_dp.alu & i0_dp.mul  & i1_rs2_depend_i0_d,\n                                 i1_dp.alu & i0_dp.load & i1_rs2_depend_i0_d\n                                 };\n\n   assign i1_rs1_intra_bypass = |i1rs1_intra[2:0];\n\n   assign i1_rs2_intra_bypass = |i1rs2_intra[2:0];\n\n\n   assign dd.i1rs1bype3[6:0] = { i1rs1_intra[2:0],\n                                 i1_dp.alu & i1_rs1_depth_d[3:0]==4'd1 & (i1_rs1_class_d.sec | i1_rs1_class_d.load | i1_rs1_class_d.mul) & ~i1_rs1_intra_bypass,\n                                 i1_dp.alu & i1_rs1_depth_d[3:0]==4'd2 & (i1_rs1_class_d.sec | i1_rs1_class_d.load | i1_rs1_class_d.mul) & ~i1_rs1_intra_bypass,\n                                 i1_dp.alu & i1_rs1_depth_d[3:0]==4'd3 & (i1_rs1_class_d.sec | i1_rs1_class_d.load | i1_rs1_class_d.mul) & ~i1_rs1_intra_bypass,\n                                 i1_dp.alu & i1_rs1_depth_d[3:0]==4'd4 & (i1_rs1_class_d.sec | i1_rs1_class_d.load | i1_rs1_class_d.mul) & ~i1_rs1_intra_bypass };\n\n   assign dd.i1rs2bype3[6:0] = { i1rs2_intra[2:0],\n                                 i1_dp.alu & i1_rs2_depth_d[3:0]==4'd1 & (i1_rs2_class_d.sec | i1_rs2_class_d.load | i1_rs2_class_d.mul) & ~i1_rs2_intra_bypass,\n                                 i1_dp.alu & i1_rs2_depth_d[3:0]==4'd2 & (i1_rs2_class_d.sec | i1_rs2_class_d.load | i1_rs2_class_d.mul) & ~i1_rs2_intra_bypass,\n                                 i1_dp.alu & i1_rs2_depth_d[3:0]==4'd3 & (i1_rs2_class_d.sec | i1_rs2_class_d.load | i1_rs2_class_d.mul) & ~i1_rs2_intra_bypass,\n                                 i1_dp.alu & i1_rs2_depth_d[3:0]==4'd4 & (i1_rs2_class_d.sec | i1_rs2_class_d.load | i1_rs2_class_d.mul) & ~i1_rs2_intra_bypass };\n\n\n\n\n   assign dec_i0_rs1_bypass_en_e3 = |e3d.i0rs1bype3[3:0];\n   assign dec_i0_rs2_bypass_en_e3 = |e3d.i0rs2bype3[3:0];\n   assign dec_i1_rs1_bypass_en_e3 = |e3d.i1rs1bype3[6:0];\n   assign dec_i1_rs2_bypass_en_e3 = |e3d.i1rs2bype3[6:0];\n\n\n\n   assign i1_result_e4_eff[31:0] = i1_result_e4_final[31:0];\n\n   assign i0_result_e4_eff[31:0] = i0_result_e4_final[31:0];\n\n\n   assign i0_rs1_bypass_data_e3[31:0] = ({32{e3d.i0rs1bype3[3]}} & i1_result_e4_eff[31:0]) |\n                                        ({32{e3d.i0rs1bype3[2]}} & i0_result_e4_eff[31:0]) |\n                                        ({32{e3d.i0rs1bype3[1]}} & i1_result_wb_eff[31:0]) |\n                                        ({32{e3d.i0rs1bype3[0]}} & i0_result_wb_eff[31:0]);\n\n   assign i0_rs2_bypass_data_e3[31:0] = ({32{e3d.i0rs2bype3[3]}} & i1_result_e4_eff[31:0]) |\n                                        ({32{e3d.i0rs2bype3[2]}} & i0_result_e4_eff[31:0]) |\n                                        ({32{e3d.i0rs2bype3[1]}} & i1_result_wb_eff[31:0]) |\n                                        ({32{e3d.i0rs2bype3[0]}} & i0_result_wb_eff[31:0]);\n\n   assign i1_rs1_bypass_data_e3[31:0] = ({32{e3d.i1rs1bype3[6]}} & i0_result_e3[31:0]) |\n                                        ({32{e3d.i1rs1bype3[5]}} & exu_mul_result_e3[31:0]) |\n                "}
{"text": "                        ({32{e3d.i1rs1bype3[4]}} & lsu_result_dc3[31:0]) |\n                                        ({32{e3d.i1rs1bype3[3]}} & i1_result_e4_eff[31:0]) |\n                                        ({32{e3d.i1rs1bype3[2]}} & i0_result_e4_eff[31:0]) |\n                                        ({32{e3d.i1rs1bype3[1]}} & i1_result_wb_eff[31:0]) |\n                                        ({32{e3d.i1rs1bype3[0]}} & i0_result_wb_eff[31:0]);\n\n\n   assign i1_rs2_bypass_data_e3[31:0] = ({32{e3d.i1rs2bype3[6]}} & i0_result_e3[31:0]) |\n                                        ({32{e3d.i1rs2bype3[5]}} & exu_mul_result_e3[31:0]) |\n                                        ({32{e3d.i1rs2bype3[4]}} & lsu_result_dc3[31:0]) |\n                                        ({32{e3d.i1rs2bype3[3]}} & i1_result_e4_eff[31:0]) |\n                                        ({32{e3d.i1rs2bype3[2]}} & i0_result_e4_eff[31:0]) |\n                                        ({32{e3d.i1rs2bype3[1]}} & i1_result_wb_eff[31:0]) |\n                                        ({32{e3d.i1rs2bype3[0]}} & i0_result_wb_eff[31:0]);\n\n\n\n// order the producers as follows:  i1_e1 - 1, i0_e1 - 2, i1_e2 - 3, ..., i1_wb - 9, i0_wb - 10\n\n\n   assign {i0_rs1_class_d, i0_rs1_depth_d[3:0]} =\n                                                  (i0_rs1_depend_i1_e1) ? { i1_e1c, 4'd1 } :\n                                                  (i0_rs1_depend_i0_e1) ? { i0_e1c, 4'd2 } :\n                                                  (i0_rs1_depend_i1_e2) ? { i1_e2c, 4'd3 } :\n                                                  (i0_rs1_depend_i0_e2) ? { i0_e2c, 4'd4 } :\n                                                  (i0_rs1_depend_i1_e3) ? { i1_e3c, 4'd5 } :\n                                                  (i0_rs1_depend_i0_e3) ? { i0_e3c, 4'd6 } :\n                                                  (i0_rs1_depend_i1_e4) ? { i1_e4c, 4'd7 } :\n                                                  (i0_rs1_depend_i0_e4) ? { i0_e4c, 4'd8 } :\n                                                  (i0_rs1_depend_i1_wb) ? { i1_wbc, 4'd9 } :\n                                                  (i0_rs1_depend_i0_wb) ? { i0_wbc, 4'd10 } : '0;\n\n   assign {i0_rs2_class_d, i0_rs2_depth_d[3:0]} =\n                                                  (i0_rs2_depend_i1_e1) ? { i1_e1c, 4'd1 } :\n                                                  (i0_rs2_depend_i0_e1) ? { i0_e1c, 4'd2 } :\n                                                  (i0_rs2_depend_i1_e2) ? { i1_e2c, 4'd3 } :\n                                                  (i0_rs2_depend_i0_e2) ? { i0_e2c, 4'd4 } :\n                                                  (i0_rs2_depend_i1_e3) ? { i1_e3c, 4'd5 } :\n                                                  (i0_rs2_depend_i0_e3) ? { i0_e3c, 4'd6 } :\n                                                  (i0_rs2_depend_i1_e4) ? { i1_e4c, 4'd7 } :\n                                                  (i0_rs2_depend_i0_e4) ? { i0_e4c, 4'd8 } :\n                                                  (i0_rs2_depend_i1_wb) ? { i1_wbc, 4'd9 } :\n                                                  (i0_rs2_depend_i0_wb) ? { i0_wbc, 4'd10 } : '0;\n\n   assign {i1_rs1_class_d, i1_rs1_depth_d[3:0]} =\n                                                  (i1_rs1_depend_i1_e1) ? { i1_e1c, 4'd1 } :\n                                                  (i1_rs1_depend_i0_e1) ? { i0_e1c, 4'd2 } :\n                                                  (i1_rs1_depend_i1_e2) ? { i1_e2c, 4'd3 } :\n                                                  (i1_rs1_depend_i0_e2) ? { i0_e2c, 4'd4 } :\n                                                  (i1_rs1_depend_i1_e3) ? { i1_e3c, 4'd5 } :\n                                                  (i1_rs1_depend_i0_e3) ? { i0_e3c, 4'd6 } :\n                                                  (i1_rs1_depend_i1_e4) ? { i1_e4c, 4'd7 } :\n                                                  (i1_rs1_depend_i0_e4) ? { i0_e4c, 4'd8 } :\n                                                  (i1_rs1_depend_i1_wb) ? { i1_wbc, 4'd9 } :\n                                                  (i1_rs1_depend_i0_wb) ? { i0_wbc, 4'd10 } : '0;\n\n   assign {i1_rs2_class_d, i1_rs2_depth_d[3:0]} =\n                                                  (i1_rs2_depend_i1_e1) ? { i1_e1c, 4'd1 } :\n                                                  (i1_rs2_depend_i0_e1) ? { i0_e1c, 4'd2 } :\n                                                  (i1_rs2_depend_i1_e2) ? { i1_e2c, 4'd3 } :\n                                                  (i1_rs2_depend_i0_e2) ? { i0_e2c, 4'd4 } :\n                                                  (i1_rs2_depend_i1_e3) ? { i1_e3c, 4'd5 } :\n                                                  (i1_rs2_depend_i0_e3) ? { i0_e3c, 4'd6 } :\n                                                  (i1_rs2_depend_i1_e4) ? { i1_e4c, 4'd7 } :\n                                                  (i1_rs2_depend_i0_e4) ? { i0_e4c, 4'd8 } :\n                                                  (i1_rs2_depend_i1_wb) ? { i1_wbc, 4'd9 } :\n                                                  (i1_rs2_depend_i0_wb) ? { i0_wbc, 4'd10 } : '0;\n\n\n   assign i0_rs1_match_e1 = (i0_rs1_depth_d[3:0] == 4'd1 |\n                             i0_rs1_depth_d[3:0] == 4'd2);\n\n   assign i0_rs1_match_e2 = (i0_rs1_depth_d[3:0] == 4'd3 |\n                             i0_rs1_depth_d[3:0] == 4'd4);\n\n   assign i0_rs1_match_e3 = (i0_rs1_depth_d[3:0] == 4'd5 |\n                             i0_rs1_depth_d[3:0] == 4'd6);\n\n   assign i0_rs2_match_e1 = (i0_rs2_depth_d[3:0] == 4'd1 |\n                             i0_rs2_depth_d[3:0] == 4'd2);\n\n   assign i0_rs2_match_e2 = (i0_rs2_depth_d[3:0] == 4'd3 |\n                             i0_rs2_depth_d[3:0] == 4'd4);\n\n   assign i0_rs2_match_e3 = (i0_rs2_depth_d[3:0] == 4'd5 |\n                             i0_rs2_depth_d[3:0] == 4'd6);\n\n   assign i0_rs1_match_e1_e2 = i0_rs1_match_e1 | i0_rs1_match_e2;\n   assign i0_rs1_match_e1_e3 = i0_rs1_match_e1 | i0_rs1_match_e2 | i0_rs1_match_e3;\n\n   assign i0_rs2_match_e1_e2 = i0_rs2_match_e1 | i0_rs2_match_e2;\n   assign i0_rs2_match_e1_e3 = i0_rs2_match_e1 | i0_rs2_match_e2 | i0_rs2_match_e3;\n\n\n   // smt optimization stalls\n\n   assign i0_secondary_block_thread_1cycle_d = (~i0_dp.alu & i0_rs1_class_d.sec & i0_rs1_match_e2) |\n                                               (~i0_dp.alu & i0_rs2_class_d.sec & i0_rs2_match_e2 & ~i0_dp.store);\n\n   assign i1_secondary_block_thread_1cycle_d = (~i1_dp.alu & i1_rs1_class_d.sec & i1_rs1_match_e2) |\n                                               (~i1_dp.alu & i1_rs2_class_d.sec & i1_rs2_match_e2 & ~i1_dp.store);\n\n   assign i0_secondary_block_thread_2cycle_d = (~i0_dp.alu & i0_rs1_class_d.sec & i0_rs1_match_e1) |\n                                               (~i0_dp.alu & i0_rs2_class_d.sec & i0_rs2_match_e1 & ~i0_dp.store);\n\n   assign i1_secondary_block_thread_2cycle_d = (~i1_dp.alu & i1_rs1_class_d.sec & i1_rs1_match_e1) |\n                                               (~i1_dp.alu & i1_rs2_class_d.sec & i1_rs2_match_e1 & ~i1_dp.store);\n\n   assign i0_secondary_stall_1cycle_d = (i0_dp.alu & (i0_rs1_class_d.load | i0_rs1_class_d.mul) & i0_rs1_match_e1) |\n                                        (i0_dp.alu & (i0_rs2_class_d.load | i0_rs2_class_d.mul) & i0_rs2_match_e1) |\n                                        (i0_dp.alu & i0_rs1_class_d.sec & i0_rs1_match_e2) |\n                                        (i0_dp.alu & i0_rs2_class_d.sec & i0_rs2_match_e2);\n\n   assign i0_secondary_stall_2cycle_d = (i0_dp.alu & i0_rs1_class_d.sec & i0_rs1_match_e1) |\n                                        (i0_dp.alu & i0_rs2_class_d.sec & i0_rs2_match_e1);\n\n   assign i0_secondary_stall_thread_1cycle_d = (i0_dp.alu & i1_rs1_depend_i0_d & ~i1_dp.alu & i0_secondary_stall_1cycle_d) |\n                                               (i0_dp.alu & i1_rs2_depend_i0_d & ~i1_dp.alu & ~i1_dp.store & i0_secondary_stall_1cycle_d);\n\n   assign i0_secondary_stall_thread_2cycle_d = (i0_dp.alu & i1_rs1_depend_i0_d & ~i1_dp.alu & i0_secondary_stall_2cycle_d) |\n                                               (i0_dp.alu & i1_rs2_depend_i0_d & ~i1_dp.alu & ~i1_dp.store & i0_secondary_stall_2cycle_d);\n   // end\n\n   assign i0_secondary_d = (i0_dp.alu & (i0_rs1_class_d.load | i0_rs1_class_d.mul) & i0_rs1_match_e1_e2) |\n                           (i0_dp.alu & (i0_rs2_class_d.load | i0_rs2_class_d.mul) & i0_rs2_match_e1_e2) |\n                           (i0_dp.alu & i0_rs1_class_d.sec & i0_rs1_match_e1_e3) |\n                           (i0_dp.alu & i0_rs2_class_d.sec & i0_rs2_match_e1_e3);\n\n  // stall i0 until it's not a secondary for performance\n   assign i0_secondary_stall_d = (i0_dp.alu & i1_rs1_depend_i0_d & ~i1_dp.alu & i0_secondary_d) |\n                                 (i0_dp.alu & i1_rs2_depend_i0_d & ~i1_dp.alu & ~i1_dp.store & i0_secondary_d);\n\n   assign i1_rs1_match_e1 = (i1_rs1_depth_d[3:0] == 4'd1 |\n                             i1_rs1_depth_d[3:0] == 4'd2);\n\n   assign i1_rs1_match_e2 = (i1_rs1_depth_d[3:0] == 4'd3 |\n                             i1_rs1_depth_d[3:0] == 4'd4);\n\n   assign i1_rs1_match_e3 = (i1_rs1_depth_d[3:0] == 4'd5 |\n                             i1_rs1_depth_d[3:0] == 4'd6);\n\n   assign i1_rs2_match_e1 = (i1_rs2_depth_d[3:0] == 4'd1 |\n                             i1_rs2_depth_d[3:0] == 4'd2);\n\n   assign i1_rs2_match_e2 = (i1_rs2_depth_d[3:0] == 4'd3 |\n                             i1_rs2_depth_d[3:0] == 4'd4);\n\n   assign i1_rs2_match_e3 = (i1_rs2_depth_d[3:0] == 4'd5 |\n                             i1_rs2_depth_d[3:0] == 4'd6);\n\n   assign i1_rs1_match_e1_e2 = i1_rs1_match_e1 | i1_rs1_match_e2;\n   assign i1_rs1_match_e1_e3 = i1_rs1_match_e1 | i1_rs1_match_e2 | i1_rs1_match_e3;\n\n   assign i1_rs2_match_e1_e2 = i1_rs2_match_e1 | i1_rs2_match_e2;\n   assign i1_rs2_match_e1_e3 = i1_rs2_match_e1 | i1_rs2_match_e2 | i1_rs2_match_e3;\n\n\n\n\n   assign i1_secondary_d = (i1_dp.alu & (i1_rs1_class_d.load | i1_rs1_class_d.mul) & i1_rs1_match_e1_e2) |\n                           (i1_dp.alu & (i1_rs2_class_d.load | i1_rs2_class_d.mul) & i1_rs2_match_e1_e2) |\n                           (i1_dp.alu & (i1_rs1_class_d.sec) & i1_rs1_match_e1_e3) |\n                           (i1_dp.alu & (i1_rs2_class_d.sec) & i1_rs2_match_e1_e3) |\n                           (non_block_case_d & i1_depend_i0_d);\n\n\n\n   assign store_data_bypass_i0_e2_c2 = i0_dp.alu & ~i0_secondary_d & i1_rs2_depend_i0_d & ~i1_rs1_depend_i0_d & i1_dp.store;\n\n   assign non_block_case_d = (i1_dp.alu & i0_dp.load) |\n                             (i1_dp.alu & i0_dp.mul);\n\n\n   assign store_data_bypass_c2        =  (             i0_dp.store & (i0_rs2_depth_d[3:0] == 4'd1) & i0_rs2_class_d.load) |\n                                         (             i0_dp.store & (i0_rs2_depth_d[3:0] == 4'd2) & i0_rs2_class_d.load) |\n                                         (~i0_dp.lsu & i1_dp.store & (i1_rs2_depth_d[3:0] == 4'd1) & i1_rs2_class_d.load) |\n                                         (~i0_dp.lsu & i1_dp.store & (i1_rs2_depth_d[3:0] == 4'd2) & i1_rs2_class_d.load);\n\n   assign store_data_bypass_c1        =  (             i0_dp.store & (i0_rs2_depth_d[3:0] == 4'd3) & i0_rs2_class_d.load) |\n                                         (             i0_dp.store & (i0_rs2_depth_d[3:0] == 4'd4) & i0_rs2_class_d.load) |\n                                         (~i0_dp.lsu & i1_dp.store & (i1_rs2_depth_d[3:0] == 4'd3) & i1_rs2_class_d.load) |\n                                         (~i0_dp.lsu & i1_dp.store & (i1_rs2_depth_d[3:0] == 4'd4) & i1_rs2_class_d.load);\n\nif (pt.LOAD_TO_USE_PLUS1 == 1)\n begin\n   assign load_ldst_bypass_c1        =  (             (i0_dp.load | i0_dp.store) & (i0_rs1_depth_d[3:0] == 4'd5) & i0_rs1_class_d.load) |\n                                        (             (i0_dp.load | i0_dp.store) & (i0_rs1_depth_d[3:0] == 4'd6) & i0_rs1_class_d.load) |\n                                        (~i0_dp.lsu & (i1_dp.load | i1_dp.store) & (i1_rs1_depth_d[3:0] == 4'd5) & i1_rs1_class_d.load) |\n                                        (~i0_dp.lsu & (i1_dp.load | i1_dp.store) & (i1_rs1_depth_d[3:0] == 4'd6) & i1_rs1_class_d.load);\n end\nelse\n begin\n   assign load_ldst_bypass_c1        =  (             (i0_dp.load | i0_dp.store) & (i0_rs1_depth_d[3:0] == 4'd3) & i0_rs1_class_d.load) |\n                                        (             (i0_dp.load | i0_dp.store) & (i0_rs1_depth_d[3:0] == 4'd4) & i0_rs1_class_d.load) |\n                                        (~i0_dp.lsu & (i1_dp.load | i1_dp.store) & (i1_rs1_depth_d[3:0] == 4'd3) & i1_rs1_class_d.load) |\n                                        (~i0_dp.lsu & (i1_dp.load | i1_dp.store) & (i1_rs1_depth_d[3:0] == 4'd4) & i1_rs1_class_d.load);\n end\n\n   assign load_mul_rs1_bypass_e1     =  (             (i0_dp.mul) & (i0_rs1_depth_d[3:0] == 4'd3) & i0_rs1_class_d.load) |\n                                        (             (i0_dp.mul) & (i0_rs1_depth_d[3:0] == 4'd4) & i0_rs1_class_d.load) |\n                                        (~i0_dp.mul & (i1_dp.mul) & (i1_rs1_depth_d[3:0] == 4'd3) & i1_rs1_class_d.load) |\n                                        (~i0_dp.mul & (i1_dp.mul) & (i1_rs1_depth_d[3:0] == 4'd4) & i1_rs1_class_d.load);\n\n   assign load_mul_rs2_bypass_e1     =  (             (i0_dp.mul) & (i0_rs2_depth_d[3:0] == 4'd3) & i0_rs2_class_d.load) |\n                                        (             (i0_dp.mul) & (i0_rs2_depth_d[3:0] == 4'd4) & i0_rs2_class_d.load) |\n                                        (~i0_dp.mul & (i1_dp.mul) & (i1_rs2_depth_d[3:0] == 4'd3) & i1_rs2_class_d.load) |\n                                        (~i0_dp.mul & (i1_dp.mul) & (i1_rs2_depth_d[3:0] == 4'd4) & i1_rs2_class_d.load);\n\n\n   assign store_data_bypass_e4_c3[1] = ( ~i0_dp.lsu & i1_dp.store & (i1_rs2_depth_d[3:0] == 4'd1) & i1_rs2_class_d.sec ) |\n                                       (              i0_dp.store & (i0_rs2_depth_d[3:0] == 4'd1) & i0_rs2_class_d.sec );\n\n   assign store_data_bypass_e4_c3[0] = ( ~i0_dp.lsu & i1_dp.store & (i1_rs2_depth_d[3:0] == 4'd2) & i1_rs2_class_d.sec ) |\n                                       (              i0_dp.store & (i0_rs2_depth_d[3:0] == 4'd2) & i0_rs2_class_d.sec );\n\n   assign store_data_bypass_e4_c2[1] = ( ~i0_dp.lsu & i1_dp.store & (i1_rs2_depth_d[3:0] == 4'd3) & i1_rs2_class_d.sec ) |\n                                       (              i0_dp.store & (i0_rs2_depth_d[3:0] == 4'd3) & i0_rs2_class_d.sec );\n\n   assign store_data_bypass_e4_c2[0] = ( ~i0_dp.lsu & i1_dp.store & (i1_rs2_depth_d[3:0] == 4'd4) & i1_rs2_class_d.sec ) |\n                                       (              i0_dp.store & (i0_rs2_depth_d[3:0] == 4'd4) & i0_rs2_class_d.sec );\n\n\n   assign store_data_bypass_e4_c1[1] = ( ~i0_dp.lsu & i1_dp.store & (i1_rs2_depth_d[3:0] == 4'd5) & i1_rs2_class_d.sec ) |\n                                       (              i0_dp.store & (i0_rs2_depth_d[3:0] == 4'd5) & i0_rs2_class_d.sec );\n\n   assign store_data_bypass_e4_c1[0] = ( ~i0_dp.lsu & i1_dp.store & (i1_rs2_depth_d[3:0] == 4'd6) & i1_rs2_class_d.sec ) |\n                                       (              i0_dp.store & (i0_rs2_depth_d[3:0] == 4'd6) & i0_rs2_class_d.sec );\n\n\n\n   assign i0_not_alu_eff = ~i0_dp.alu;\n   assign i1_not_alu_eff = ~i1_dp.alu;\n\n// stores will bypass load data in the lsu pipe\nif (pt.LOAD_TO_USE_PLUS1 == 1)\n begin\n   assign i0_load_block_d = (i0_not_alu_eff & i0_rs1_class_d.load & i0_rs1_match_e1                            ) |\n                            (i0_not_alu_eff & i0_rs1_class_d.load & i0_rs1_match_e2 & ~i0_dp.mul               ) | // can bypass load to address of load/store\n                            (i0_not_alu_eff & i0_rs2_class_d.load & i0_rs2_match_e1 & ~i0_dp.store             ) |\n                            (i0_not_alu_eff & i0_rs2_class_d.load & i0_rs2_match_e2 & ~i0_dp.store & ~i0_dp.mul);\n\n   assign i1_load_block_d = (i1_not_alu_eff & i1_rs1_class_d.load & i1_rs1_match_e1                            ) |\n                            (i1_not_alu_eff & i1_rs1_class_d.load & i1_rs1_match_e2 & ~i1_dp.mul               ) |\n                            (i1_not_alu_eff & i1_rs2_class_d.load & i1_rs2_match_e1 & ~i1_dp.store             ) |\n                            (i1_not_alu_eff & i1_rs2_class_d.load & i1_rs2_match_e2 & ~i1_dp.store & ~i1_dp.mul);\n end\nelse\n begin\n   assign i0_load_block_d = (i0_not_alu_eff & i0_rs1_class_d.load & i0_rs1_match_e1                                          ) |\n                            (i0_not_alu_eff & i0_rs1_class_d.load & i0_rs1_match_e2 & ~i0_dp.load & ~i0_dp.store & ~i0_dp.mul) | // can bypass load to address of load/store\n                            (i0_not_alu_eff & i0_rs2_class_d.load & i0_rs2_match_e1 &               ~i0_dp.store             ) |\n                            (i0_not_alu_eff & i0_rs2_class_d.load & i0_rs2_match_e2 &               ~i0_dp.store & ~i0_dp.mul);\n\n   assign i1_load_block_d = (i1_not_alu_eff & i1_rs1_class_d.load & i1_rs1_match_e1                                          ) |\n                            (i1_not_alu_eff & i1_rs1_class_d.load & i1_rs1_match_e2 & ~i1_dp.load & ~i1_dp.store & ~i1_dp.mul) |\n                            (i1_not_alu_eff & i1_rs2_class_d.load & i1_rs2_match_e1 &               ~i1_dp.store             ) |\n                            (i1_not_alu_eff & i1_rs2_class_d.load & i1_rs2_match_e2 &               ~i1_dp.store & ~i1_dp.mul);\n end\n\n   assign i0_mul_block_thread_1cycle_d        = (i0_not_alu_eff & i0_rs1_class_d.mul & i0_rs1_match_e1) |\n                                                (i0_not_alu_eff & i0_rs2_class_d.mul & i0_rs2_match_e1);\n\n   assign i0_mul_block_d        = (i0_not_alu_eff & i0_rs1_class_d.mul & i0_rs1_match_e1_e2) |\n                                  (i0_not_alu_eff & i0_rs2_class_d.mul & i0_rs2_match_e1_e2);\n\n   assign i1_mul_block_thread_1cycle_d        = (i1_not_alu_eff & i1_rs1_class_d.mul & i1_rs1_match_e1) |\n                                                (i1_not_alu_eff & i1_rs2_class_d.mul & i1_rs2_match_e1);\n\n   assign i1_mul_block_d       = (i1_not_alu_eff & i1_rs1_class_d.mul & i1_rs1_match_e1_e2) |\n                                 (i1_not_alu_eff & i1_rs2_class_d.mul & i1_rs2_match_e1_e2);\n\n\n   assign i0_secondary_block_d = (~i0_dp.alu & i0_rs1_class_d.sec & i0_rs1_match_e1_e3) |\n                                 (~i0_dp.alu & i0_rs2_class_d.sec & i0_rs2_match_e1_e3 & ~i0_dp.store);\n\n   assign i1_secondary_block_d = (~i1_dp.alu & i1_rs1_class_d.sec & i1_rs1_match_e1_e3) |\n                                 (~i1_dp.alu & i1_rs2_class_d.sec & i1_rs2_match_e1_e3 & ~i1_dp.store);\n\n   assign dec_tlu_i0_valid_e4 =  e4d.i0valid & ~flush_lower_wb[e4d.i0tid];\n   assign dec_tlu_i1_valid_e4 =  e4d.i1valid & ~flush_lower_wb[e4d.i1tid];\n\n\n\n   assign dt.i0legal               =  i0_legal_decode_d;\n   assign dt.i0icaf                =  i0_icaf_d & i0_legal_decode_d;            // dbecc is icaf exception\n   assign dt.i0icaf_type[1:0]      =  dec_i0_icaf_type_d[1:0];\n   assign dt.i0icaf_second         =  dec_i0_icaf_second_d & i0_legal_decode_d;     // this includes icaf and dbecc\n   assign dt.i0fence_i             = (i0_dp.fence_i | debug_fence_i) & i0_legal_decode_d & ~i0_br_error_all;\n\n\n   assign dt.i0tid = dd.i0tid;\n   assign dt.i1tid = dd.i1tid;\n\n   assign dt.pmu_i0_itype = i0_itype;\n   assign dt.pmu_i1_itype = i1_itype;\n   assign dt.pmu_i0_br_unpred = i0_br_unpred;\n   assign dt.pmu_i1_br_unpred = i1_br_unpred;\n\n   assign dt.lsu_pipe0 = i0_legal_decode_d & ~lsu_p.pipe & ~i0_br_error_all;\n\n   assign dt.pmu_divide = i0_dp.div;\n\n   // written later in the pipe\n   assign dt.pmu_lsu_misaligned = 1'b0;\n\n   assign dt.i0trigger[3:0] = dec_i0_trigger_match_d[3:0] & {4{dec_i0_decode_d}};\n   assign dt.i1trigger[3:0] = dec_i1_trigger_match_d[3:0] & {4{i1_legal_decode_d}};\n\n   rvdfflie #( .WIDTH($bits(eh2_trap_pkt_t)),.LEFT(17) ) trap_e1ff (.*, .en(i0_e1_ctl_en | i1_e1_ctl_en), .din( dt),  .dout(e1t));\n\n  always_comb begin\n      e1t_in = e1t;\n      e1t_in.i0trigger[3:0] = e1t.i0tr"}
{"text": "igger & ~{4{flush_final_e3[e1t.i0tid]}};\n      e1t_in.i1trigger[3:0] = e1t.i1trigger & ~{4{flush_final_e3[e1t.i1tid] | dec_i1_cancel_e1[e1t.i1tid]}};\n   end\n\n   rvdfflie #( .WIDTH($bits(eh2_trap_pkt_t)),.LEFT(17) ) trap_e2ff (.*, .en(i0_e2_ctl_en | i1_e2_ctl_en), .din(e1t_in),  .dout(e2t));\n\n   always_comb begin\n      e2t_in = e2t;\n      e2t_in.i0trigger[3:0] = e2t.i0trigger & ~{4{flush_final_e3[e2t.i0tid] | flush_lower_wb[e2t.i0tid]}};\n      e2t_in.i1trigger[3:0] = e2t.i1trigger & ~{4{flush_final_e3[e2t.i1tid] | flush_lower_wb[e2t.i1tid]}};\n   end\n\n   rvdfflie  #(.WIDTH($bits(eh2_trap_pkt_t)),.LEFT(17) ) trap_e3ff (.*, .en(i0_e3_ctl_en | i1_e3_ctl_en), .din(e2t_in),  .dout(e3t));\n\n   assign lsu_tid_e3 = e3t.lsu_pipe0 ? e3t.i0tid : e3t.i1tid;\n\n    always_comb begin\n      e3t_in = e3t;\n\n       e3t_in.pmu_lsu_misaligned = lsu_pmu_misaligned_dc3[lsu_tid_e3];   // only valid if a load/store is valid in e3 stage\n\n       if (flush_lower_wb[e3t.i0tid]) begin\n          e3t_in.i0legal = '0;\n          e3t_in.i0icaf = '0;\n          e3t_in.i0icaf_type = '0;\n          e3t_in.i0icaf_second = '0;\n          e3t_in.i0fence_i = '0;\n          e3t_in.i0trigger = '0;\n          e3t_in.pmu_i0_br_unpred = '0;\n          e3t_in.pmu_i0_itype = eh2_inst_pkt_t'(0);\n       end\n\n       if (flush_lower_wb[e3t.i1tid]) begin\n          e3t_in.i1trigger = '0;\n          e3t_in.pmu_i1_br_unpred = '0;\n          e3t_in.pmu_i1_itype = eh2_inst_pkt_t'(0);\n       end\n\n\n   end\n\n\n   rvdfflie #( .WIDTH($bits(eh2_trap_pkt_t)),.LEFT(17) ) trap_e4ff (.*, .en(i0_e4_ctl_en | i1_e4_ctl_en), .din(e3t_in),  .dout(e4t_ff));\n\n    always_comb begin\n       e4t = e4t_ff;\n\n       e4t.i0trigger[3:0] = ({4{ (e4d.i0load | e4d.i0store)}} & lsu_trigger_match_dc4[3:0]) | e4t.i0trigger[3:0];\n\n       e4t.i1trigger[3:0] = ~{4{(e4t.i0tid==e4t.i1tid) & i0_flush_final_e4[e4t.i0tid]}} & (({4{~(e4d.i0load | e4d.i0store)}} & lsu_trigger_match_dc4[3:0]) | e4t.i1trigger[3:0]);\n\n\n       if (flush_lower_wb[e4t.i0tid]) begin\n          e4t.i0legal = '0;\n          e4t.i0icaf = '0;\n          e4t.i0icaf_type = '0;\n          e4t.i0icaf_second = '0;\n          e4t.i0fence_i = '0;\n          e4t.i0trigger = '0;\n          e4t.pmu_i0_br_unpred = '0;\n          e4t.pmu_i0_itype = eh2_inst_pkt_t'(0);\n       end\n\n       if (flush_lower_wb[e4t.i1tid]) begin\n          e4t.i1trigger = '0;\n          e4t.pmu_i1_br_unpred = '0;\n          e4t.pmu_i1_itype = eh2_inst_pkt_t'(0);\n       end\n\n\n    end\n\n\n   always_comb begin\n\n      dec_tlu_packet_e4 = e4t;\n\n   end\n   assign dec_i0_tid_e4 = e4t.i0tid;\n   assign dec_i1_tid_e4 = e4t.i1tid;\n\n\n\n// end tlu stuff\n   assign i0_dc.mul   = i0_dp.mul  & i0_legal_decode_d & ~i0_br_error_all;\n   assign i0_dc.load  = i0_dp.load & i0_legal_decode_d & ~i0_br_error_all;\n   assign i0_dc.sec   = i0_dp.alu  &  i0_secondary_d   & i0_legal_decode_d & ~i0_br_error_all;\n   assign i0_dc.alu   = i0_dp.alu  & ~i0_secondary_d   & i0_legal_decode_d & ~i0_br_error_all;\n\n\n   assign i0_e4c_in = i0_e3c;\n\n\n\n   assign i1_dc.mul   = i1_dp.mul  & i1_legal_decode_d & ~i1_br_error_all;\n   assign i1_dc.load  = i1_dp.load & i1_legal_decode_d & ~i1_br_error_all;\n   assign i1_dc.sec   = i1_dp.alu  &  i1_secondary_d   & i1_legal_decode_d & ~i1_br_error_all;\n   assign i1_dc.alu   = i1_dp.alu  & ~i1_secondary_d   & i1_legal_decode_d & ~i1_br_error_all;\n\n\n   assign i1_e4c_in = i1_e3c;\n\n   rvdffe #( $bits(eh2_class_pkt_t)*2 + 2 ) e1c_ff (.*, .en(i0_e1_ctl_en|i1_e1_ctl_en), .din({i0_dc,    i1_dc,dec_i0_pc4_d,dec_i1_pc4_d}),  .dout({i0_e1c,i1_e1c,    i0_pc4_e1,    i1_pc4_e1}));\n   rvdffe #( $bits(eh2_class_pkt_t)*2 + 2 ) e2c_ff (.*, .en(i0_e2_ctl_en|i1_e2_ctl_en), .din({i0_e1c,   i1_e1c,   i0_pc4_e1,   i1_pc4_e1}), .dout({i0_e2c,i1_e2c,    i0_pc4_e2,    i1_pc4_e2}));\n   rvdffe #( $bits(eh2_class_pkt_t)*2 + 2 ) e3c_ff (.*, .en(i0_e3_ctl_en|i1_e3_ctl_en), .din({i0_e2c,   i1_e2c,   i0_pc4_e2,   i1_pc4_e2}), .dout({i0_e3c,i1_e3c,    i0_pc4_e3,    i1_pc4_e3}));\n   rvdffe #( $bits(eh2_class_pkt_t)*2 + 2 ) e4c_ff (.*, .en(i0_e4_ctl_en|i1_e4_ctl_en), .din({i0_e4c_in,i1_e4c_in,i0_pc4_e3,   i1_pc4_e3}), .dout({i0_e4c,i1_e4c,dec_i0_pc4_e4,dec_i1_pc4_e4}));\n\n   rvdffe #( $bits(eh2_class_pkt_t)*2     ) wbc_ff (.*, .en(i0_wb_ctl_en|i1_wb_ctl_en), .din({i0_e4c,i1_e4c}),                           .dout({i0_wbc,i1_wbc}));\n\n\n   assign dd.i0rd[4:0] = i0r.rd[4:0];\n   assign dd.i0v = i0_rd_en_d & i0_legal_decode_d & ~i0_br_error_all;\n   assign dd.i0valid =  dec_i0_decode_d;  // has final flush in it\n   assign dd.i0tid   =  dec_i0_tid_d;\n\n   assign dd.i0mul  = i0_dp.mul    & i0_legal_decode_d & ~i0_br_error_all;\n   assign dd.i0load  = i0_dp.load  & i0_legal_decode_d & ~i0_br_error_all;\n   assign dd.i0store = i0_dp.store & i0_legal_decode_d & ~i0_br_error_all;\n   assign dd.i0sc    = i0_dp.sc    & i0_legal_decode_d & ~i0_br_error_all;\n   assign dd.i0div = i0_div_decode_d;\n   assign dd.i0secondary = i0_secondary_d & i0_legal_decode_d & ~i0_br_error_all;\n\n   assign dd.lsu_tid = (i0_dp.lsu) ? dd.i0tid : dd.i1tid;\n\n\n   assign dd.i1rd[4:0]   = i1r.rd[4:0];\n   assign dd.i1v         = i1_rd_en_d & i1_legal_decode_d & ~i1_br_error_all;\n   assign dd.i1valid     = i1_legal_decode_d;\n   assign dd.i1tid       = dec_i1_tid_d;\n\n   assign dd.i1mul       = i1_dp.mul;\n   assign dd.i1load      = i1_dp.load;\n   assign dd.i1store     = i1_dp.store;\n   assign dd.i1sc        = i1_dp.sc;\n   assign dd.i1secondary = i1_secondary_d & i1_legal_decode_d & ~i1_br_error_all;\n\n   assign dd.i0csrwen = dec_i0_csr_wen_unq_d & i0_legal_decode_d & ~i0_br_error_all;\n\n   assign dd.i0csrwonly = i0_csr_write_only_d & i0_legal_decode_d & ~i0_br_error_all;\n   assign dd.i0csrwaddr[11:0] = (dd.i0csrwen & i0_legal_decode_d) ? i0[31:20] : '0;  // csr write address for rd==0 case\n\n   assign dec_i0_secondary_d = dd.i0secondary;\n   assign dec_i1_secondary_d = dd.i1secondary;\n\n   assign dec_i0_branch_d = i0_dp.condbr | i0_dp.jal | i0_br_error_all;\n   assign dec_i1_branch_d = i1_dp.condbr | i1_dp.jal | i1_br_error_all;\n\n\n\n   assign i0_pipe_en[5] = dec_i0_decode_d;\n\n   rvdff  #(3) i0cg0ff (.*, .clk(active_clk), .din(i0_pipe_en[5:3]), .dout(i0_pipe_en[4:2]));\n   rvdff  #(2) i0cg1ff (.*, .clk(active_clk), .din(i0_pipe_en[2:1]), .dout(i0_pipe_en[1:0]));\n\n\n   assign i0_e1_ctl_en = (|i0_pipe_en[5:4] | clk_override);\n   assign i0_e2_ctl_en = (|i0_pipe_en[4:3] | clk_override);\n   assign i0_e3_ctl_en = (|i0_pipe_en[3:2] | clk_override);\n   assign i0_e4_ctl_en = (|i0_pipe_en[2:1] | clk_override);\n   assign i0_wb_ctl_en = (|i0_pipe_en[1:0] | clk_override);\n\n   assign i0_e1_data_en = (i0_pipe_en[5] | clk_override);\n   assign i0_e2_data_en = (i0_pipe_en[4] | clk_override);\n   assign i0_e3_data_en = (i0_pipe_en[3] | clk_override);\n   assign i0_e4_data_en = (i0_pipe_en[2] | clk_override);\n   assign i0_wb_data_en = (i0_pipe_en[1] | clk_override);\n   assign i0_wb1_data_en = (i0_pipe_en[0] | clk_override);\n\n   assign dec_i0_data_en[4:1] = {i0_e1_data_en, i0_e2_data_en, i0_e3_data_en, i0_e4_data_en};\n   assign dec_i0_ctl_en[4:1]  = {i0_e1_ctl_en,  i0_e2_ctl_en,  i0_e3_ctl_en,  i0_e4_ctl_en};\n\n\n   assign i1_pipe_en[5] = dec_i1_decode_d;\n\n   rvdff  #(3) i1cg0ff (.*, .clk(active_clk), .din(i1_pipe_en[5:3]), .dout(i1_pipe_en[4:2]));\n   rvdff  #(2) i1cg1ff (.*, .clk(active_clk), .din(i1_pipe_en[2:1]), .dout(i1_pipe_en[1:0]));\n\n\n   assign i1_e1_ctl_en = (|i1_pipe_en[5:4] | clk_override);\n   assign i1_e2_ctl_en = (|i1_pipe_en[4:3] | clk_override);\n   assign i1_e3_ctl_en = (|i1_pipe_en[3:2] | clk_override);\n   assign i1_e4_ctl_en = (|i1_pipe_en[2:1] | clk_override);\n   assign i1_wb_ctl_en = (|i1_pipe_en[1:0] | clk_override);\n\n   assign i1_e1_data_en = (i1_pipe_en[5] | clk_override);\n   assign i1_e2_data_en = (i1_pipe_en[4] | clk_override);\n   assign i1_e3_data_en = (i1_pipe_en[3] | clk_override);\n   assign i1_e4_data_en = (i1_pipe_en[2] | clk_override);\n   assign i1_wb_data_en = (i1_pipe_en[1] | clk_override);\n   assign i1_wb1_data_en = (i1_pipe_en[0] | clk_override);\n\n   assign dec_i1_data_en[4:1] = {i1_e1_data_en, i1_e2_data_en, i1_e3_data_en, i1_e4_data_en};\n   assign dec_i1_ctl_en[4:1]  = {i1_e1_ctl_en,  i1_e2_ctl_en,  i1_e3_ctl_en,  i1_e4_ctl_en};\n\n   rvdffdpie #( .WIDTH($bits(eh2_dest_pkt_t)), .LEFTMOST(17),.LEFT(12),.RIGHT(18) ) e1ff (.*, .en(i0_e1_ctl_en | i1_e1_ctl_en), .din(dd),  .dout(e1d));\n\n   always_comb begin\n      e1d_in = e1d;\n\n      e1d_in.i0div =        e1d.i0div       & ~div_flush;\n\n      e1d_in.i0v =          e1d.i0v         & ~flush_final_e3[e1d.i0tid];\n      e1d_in.i1v =          e1d.i1v         & ~flush_final_e3[e1d.i1tid] & ~dec_i1_cancel_e1[e1d.i1tid];\n      e1d_in.i0valid =      e1d.i0valid     & ~flush_final_e3[e1d.i0tid];\n      e1d_in.i1valid =      e1d.i1valid     & ~flush_final_e3[e1d.i1tid] & ~dec_i1_cancel_e1[e1d.i1tid];\n      e1d_in.i0secondary =  e1d.i0secondary & ~flush_final_e3[e1d.i0tid];\n      e1d_in.i1secondary =  e1d.i1secondary & ~flush_final_e3[e1d.i1tid] & ~dec_i1_cancel_e1[e1d.i1tid];\n   end\n\n   assign dec_i1_valid_e1 = e1d.i1valid & ~dec_i1_cancel_e1[e1d.i1tid];\n\n   assign dec_i0_secondary_e1 = e1d.i0secondary;\n   assign dec_i1_secondary_e1 = e1d.i1secondary;\n\n   rvdffdpie #( .WIDTH($bits(eh2_dest_pkt_t)), .LEFTMOST(17),.LEFT(12),.RIGHT(18) ) e2ff (.*, .en(i0_e2_ctl_en | i1_e2_ctl_en), .din(e1d_in), .dout(e2d));\n\n   always_comb begin\n      e2d_in = e2d;\n\n      e2d_in.i0div =       e2d.i0div       & ~div_flush;\n\n      e2d_in.i0v =         e2d.i0v         & ~flush_final_e3[e2d.i0tid] & ~flush_lower_wb[e2d.i0tid];\n      e2d_in.i1v =         e2d.i1v         & ~flush_final_e3[e2d.i1tid] & ~flush_lower_wb[e2d.i1tid];\n      e2d_in.i0valid =     e2d.i0valid     & ~flush_final_e3[e2d.i0tid] & ~flush_lower_wb[e2d.i0tid];\n      e2d_in.i1valid =     e2d.i1valid     & ~flush_final_e3[e2d.i1tid] & ~flush_lower_wb[e2d.i1tid];\n      e2d_in.i0secondary = e2d.i0secondary & ~flush_final_e3[e2d.i0tid] & ~flush_lower_wb[e2d.i0tid];\n      e2d_in.i1secondary = e2d.i1secondary & ~flush_final_e3[e2d.i1tid] & ~flush_lower_wb[e2d.i1tid];\n\n   end\n\n   assign dec_i0_secondary_e2 = e2d.i0secondary;\n   assign dec_i1_secondary_e2 = e2d.i1secondary;\n\n   rvdffdpie #( .WIDTH($bits(eh2_dest_pkt_t)), .LEFTMOST(17),.LEFT(12),.RIGHT(18) ) e3ff (.*, .en(i0_e3_ctl_en | i1_e3_ctl_en), .din(e2d_in), .dout(e3d));\n\n   always_comb begin\n      e3d_in = e3d;\n\n      e3d_in.i0div =       e3d.i0div       & ~div_flush;\n\n      e3d_in.i0v = e3d.i0v                              & ~flush_lower_wb[e3d.i0tid];\n      e3d_in.i0valid = e3d.i0valid                      & ~flush_lower_wb[e3d.i0tid];\n\n      e3d_in.i0secondary = e3d.i0secondary              & ~flush_lower_wb[e3d.i0tid];\n\n      e3d_in.i1v = e3d.i1v         & ~((e3d.i0tid==e3d.i1tid) & i0_flush_final_e3[e3d.i1tid]) & ~flush_lower_wb[e3d.i1tid];\n      e3d_in.i1valid = e3d.i1valid & ~((e3d.i0tid==e3d.i1tid) & i0_flush_final_e3[e3d.i1tid]) & ~flush_lower_wb[e3d.i1tid];\n\n      e3d_in.i1secondary = e3d.i1secondary & ~((e3d.i0tid==e3d.i1tid) & i0_flush_final_e3[e3d.i1tid]) & ~flush_lower_wb[e3d.i1tid];\n   end\n\n\n   assign dec_i0_sec_decode_e3 = e3d.i0secondary & ~flush_lower_wb[e3d.i0tid];\n   assign dec_i1_sec_decode_e3 = e3d.i1secondary & ~((e3d.i0tid==e3d.i1tid) & i0_flush_final_e3[e3d.i1tid]) & ~flush_lower_wb[e3d.i1tid];\n\n   rvdffdpie #( .WIDTH($bits(eh2_dest_pkt_t)), .LEFTMOST(17),.LEFT(12),.RIGHT(18) ) e4ff (.*, .en(i0_e4_ctl_en | i1_e4_ctl_en), .din(e3d_in), .dout(e4d));\n\n   always_comb begin\n      e4d_in = e4d;\n\n\n      e4d_in.i0div =       e4d.i0div       & ~div_flush;\n\n      e4d_in.i0v =     (e4d.i0v                  & ~flush_lower_wb[e4d.i0tid]);\n\n      e4d_in.i0valid = (e4d.i0valid              & ~flush_lower_wb[e4d.i0tid]);\n\n      e4d_in.i0secondary = e4d.i0secondary & ~flush_lower_wb[e4d.i0tid];\n\n      e4d_in.i1v = e4d.i1v                 & ~flush_lower_wb[e4d.i1tid];\n      e4d_in.i1valid = e4d.i1valid         & ~flush_lower_wb[e4d.i1tid];\n      e4d_in.i1secondary = e3d.i1secondary & ~flush_lower_wb[e4d.i1tid];\n   end\n\n   rvdffdpie #( .WIDTH($bits(eh2_dest_pkt_t)), .LEFTMOST(17),.LEFT(12),.RIGHT(18) ) wbff (.*, .en(i0_wb_ctl_en | i1_wb_ctl_en), .din(e4d_in), .dout(wbd));\n\n   assign dec_i0_waddr_wb[4:0] = wbd.i0rd[4:0];\n\n   // squash same write, take last write assuming we don't kill the I1 write for some reason.\n   // threaded\n   assign     i0_wen_wb = wbd.i0v & ~(~dec_tlu_i1_kill_writeb_wb & ~cam_i1_load_kill_wen[wbd.i1tid] & wbd.i0v & wbd.i1v & (wbd.i0rd[4:0] == wbd.i1rd[4:0]) & (wbd.i0tid == wbd.i1tid)) & ~dec_tlu_i0_kill_writeb_wb;\n\n   assign dec_i0_wen_wb = i0_wen_wb & ~wbd.i0div & ~cam_i0_load_kill_wen[wbd.i0tid];  // don't write a nonblock load 1st time down the pipe\n\n   assign dec_i0_wdata_wb[31:0] = i0_result_wb[31:0];\n\n   assign dec_i0_tid_wb = wbd.i0tid;\n\n   assign dec_i1_waddr_wb[4:0] = wbd.i1rd[4:0];\n\n   assign     i1_wen_wb = wbd.i1v & ~dec_tlu_i1_kill_writeb_wb;\n   assign dec_i1_wen_wb = i1_wen_wb & ~cam_i1_load_kill_wen[wbd.i1tid];\n\n   assign dec_i1_wdata_wb[31:0] = i1_result_wb[31:0];\n\n   assign dec_i1_tid_wb = wbd.i1tid;\n\n\n// divides are i0 only; flush_upper cases\n\n   assign div_flush = (e1d.i0div & e1d.i0valid & e1d.i0rd[4:0]==5'b0) |\n                      (e1d.i0div & e1d.i0valid & (flush_lower_wb[e1d.i0tid] | flush_final_e3[e1d.i0tid])) |\n                      (e2d.i0div & e2d.i0valid & (flush_lower_wb[e2d.i0tid] | flush_final_e3[e2d.i0tid])) |\n                      (e3d.i0div & e3d.i0valid &  flush_lower_wb[e3d.i0tid]) |\n                      (e4d.i0div & e4d.i0valid &  flush_lower_wb[e4d.i0tid]) |\n                      (wbd.i0div & wbd.i0valid & dec_tlu_i0_kill_writeb_wb);\n\n// divide stuff\n   assign div_e1_to_wb = (e1d.i0div & e1d.i0valid) |\n                         (e2d.i0div & e2d.i0valid) |\n                         (e3d.i0div & e3d.i0valid) |\n                         (e4d.i0div & e4d.i0valid) |\n                         (wbd.i0div & wbd.i0valid);\n\n   assign div_active_in = i0_div_decode_d | (div_active & ~exu_div_wren & ~nonblock_div_cancel);\n\n\n   assign dec_div_active = div_active;\n   assign dec_div_tid = div_tid;\n\n   assign div_stall = div_active;\n   assign div_valid = div_active;\n\n// nonblocking div scheme\n\n// divides must go down as i0; i1 will not go same cycle if dependent on i0 and same tid as i0 div\n\n// after div reaches wb if any inst writes to same dest on subsequent cycles and same tid as div then div is canceled\n\n   assign i0_nonblock_div_stall  = (dec_i0_rs1_en_d & (dd.i0tid == div_tid) & div_valid & (div_rd[4:0] == i0r.rs1[4:0])) |\n                                   (dec_i0_rs2_en_d & (dd.i0tid == div_tid) & div_valid & (div_rd[4:0] == i0r.rs2[4:0]));\n\n   assign i1_nonblock_div_stall  = (dec_i1_rs1_en_d & (dd.i1tid == div_tid) & div_valid & (div_rd[4:0] == i1r.rs1[4:0])) |\n                                   (dec_i1_rs2_en_d & (dd.i1tid == div_tid) & div_valid & (div_rd[4:0] == i1r.rs2[4:0]));\n\n// cancel if any younger inst committing this cycle to same dest as nonblock divide\n   assign nonblock_div_cancel = (div_valid & div_flush) |\n                                (div_valid & ~div_e1_to_wb & (wbd.i0rd[4:0] == div_rd[4:0]) & (wbd.i0tid == div_tid) & i0_wen_wb) |\n                                (div_valid & ~div_e1_to_wb & (wbd.i1rd[4:0] == div_rd[4:0]) & (wbd.i1tid == div_tid) & i1_wen_wb) |\n                                (div_valid & wbd.i0div & wbd.i0valid & (wbd.i0rd[4:0] == wbd.i1rd[4:0]) & (wbd.i0tid == wbd.i1tid) & i1_wen_wb);\n\n\n   assign dec_div_cancel = nonblock_div_cancel;\n\n   assign i0_div_decode_d = i0_legal_decode_d & i0_dp.div & ~i0_br_error_all;\n\n   rvdffe #(.WIDTH(6),.OVERRIDE(1)) divff (.*, .en(i0_div_decode_d), .din({i0r.rd[4:0],dd.i0tid}), .dout({div_rd[4:0],div_tid}));\n\n   assign div_waddr_wb[4:0] = div_rd[4:0];\n   assign div_tid_wb        = div_tid;\n\n   assign i0_result_e1[31:0] = exu_i0_result_e1[31:0];\n   assign i1_result_e1[31:0] = exu_i1_result_e1[31:0];\n\n   // pipe the results down the pipe\n   // i0 has i0csrwen and debug instructions\n   rvdffe #(32) i0e2resultff (.*, .en(i0_e2_data_en & (e1d.i0v | e1d.i0csrwen | i0_debug_valid_e1)),  .din(i0_result_e1[31:0]), .dout(i0_result_e2[31:0]));\n   rvdffe #(32) i1e2resultff (.*, .en(i1_e2_data_en &  e1d.i1v),                                      .din(i1_result_e1[31:0]), .dout(i1_result_e2[31:0]));\n\n   rvdffe #(32) i0e3resultff (.*, .en(i0_e3_data_en & (e2d.i0v | e2d.i0csrwen | i0_debug_valid_e2)),  .din(i0_result_e2[31:0]), .dout(i0_result_e3[31:0]));\n   rvdffe #(32) i1e3resultff (.*, .en(i1_e3_data_en &  e2d.i1v),                                      .din(i1_result_e2[31:0]), .dout(i1_result_e3[31:0]));\n\n   assign i0_result_e3_final[31:0] = (e3d.i0v & e3d.i0load) ? lsu_result_dc3[31:0] : (e3d.i0v & e3d.i0mul) ? exu_mul_result_e3[31:0] : i0_result_e3[31:0];\n\n   assign i1_result_e3_final[31:0] = (e3d.i1v & e3d.i1load) ? lsu_result_dc3[31:0] : (e3d.i1v & e3d.i1mul) ? exu_mul_result_e3[31:0] : i1_result_e3[31:0];\n\n   rvdffe #(32) i0e4resultff (.*, .en(i0_e4_data_en & (e3d.i0v | e3d.i0csrwen | i0_debug_valid_e3)),   .din(i0_result_e3_final[31:0]), .dout(i0_result_e4[31:0]));\n   rvdffe #(32) i1e4resultff (.*, .en(i1_e4_data_en & e3d.i1v),                                        .din(i1_result_e3_final[31:0]), .dout(i1_result_e4[31:0]));\n\n   assign i0_result_e4_final[31:0] =\n                                     (          e4d.i0secondary) ? exu_i0_result_e4[31:0] : (e4d.i0v & e4d.i0load) ? lsu_result_corr_dc4[31:0] : i0_result_e4[31:0];\n\n   assign i1_result_e4_final[31:0] =\n                                     (e4d.i1v & e4d.i1secondary) ? exu_i1_result_e4[31:0] : (e4d.i1v & e4d.i1load) ? lsu_result_corr_dc4[31:0] : i1_result_e4[31:0];\n\n   rvdffe #(32) i0wbresultff (.*, .en(i0_wb_data_en  & (e4d.i0v | e4d.i0csrwen | i0_debug_valid_e4)),  .din(i0_result_e4_final[31:0]), .dout(i0_result_wb_raw[31:0]));\n   rvdffe #(32) i1wbresultff (.*, .en(i1_wb_data_en & e4d.i1v),                                        .din(i1_result_e4_final[31:0]), .dout(i1_result_wb_raw[31:0]));\n\n   assign i0_result_wb[31:0] = (wbd.i0sc) ? {31'b0, ~lsu_sc_success_dc5} : i0_result_wb_raw[31:0];\n\n   assign i1_result_wb[31:0] = (wbd.i1sc) ? {31'b0, ~lsu_sc_success_dc5} : i1_result_wb_raw[31:0];\n\n\n   logic trace_enable;\n\n   assign trace_enable = ~dec_tlu_trace_disable;\n\n   rvdffe #(32) i0e1instff  (.*, .en(i0_e1_data_en & trace_enable),  .din(i0_inst_d[31:0] ), .dout(i0_inst_e1[31:0]));\n   rvdffe #(32) i0e2instff  (.*, .en(i0_e2_data_en & trace_enable),  .din(i0_inst_e1[31:0]), .dout(i0_inst_e2[31:0]));\n   rvdffe #(32) i0e3instff  (.*, .en(i0_e3_data_en & trace_enable),  .din(i0_inst_e2[31:0]), .dout(i0_inst_e3[31:0]));\n   rvdffe #(32) i0e4instff  (.*, .en(i0_e4_data_en & trace_enable),  .din(i0_inst_e3[31:0]), .dout(i0_inst_e4[31:0]));\n   rvdffe #(32) i0wbinstff  (.*, .en(i0_wb_data_en & trace_enable),  .din(i0_inst_e4[31:0]), .dout(i0_inst_wb[31:0] ));\n   rvdffe #(32) i0wb1instff (.*, .en(i0_wb1_data_en & trace_enable), .din(i0_inst_wb[31:0]), .dout(i0_inst_wb1[31:0]));\n\n   assign i1_inst_d[31:0] = (dec_i1_pc4_d) ? i1[31:0] : {16'b0, dec_i1_cinst_d[15:0] };\n\n   rvdffe #(32) i1e1instff  (.*, .en(i1_e1_data_en & trace_enable), .din(i1_inst_d[31:0]),  .dout(i1_inst_e1[31:0]));\n   rvdffe #(32) i1e2instff  (.*, .en(i1_e2_data_en & trace_enable), .din(i1_inst_e1[31:0]), .dout(i1_inst_e2[31:0]));\n   rvdffe #(32) i1e3instff  (.*, .en(i1_e3_data_en & trace_enable), .din(i1_inst_e2[31:0]), .dout(i1_inst_e3[31:0]));\n   rvdffe #(32) i1e4instff  (.*, .en(i1_e4_data_en & trace_enable), .din(i1_inst_e3[31:0]), .dout(i1_inst_e4[31:0]));\n   rvdffe #(32) i1wbinstff  (.*, .en(i1_wb_data_en & trace_enable), .din(i1_inst_e4[31:0]), .dout(i1_inst_wb[31:0]));\n   rvdffe #(32) i1wb1instff (.*, .en(i1_wb1_data_en & trace_enable),.din(i1_inst_wb[31:0]), .dout(i1_inst_wb1[31:0]));\n\n   assign dec_i0_inst_wb1[31:0] = i0_inst_wb1[31:0];\n   assign dec_i1_inst_wb1[31:0] = i1_inst_wb1[31:0];\n\n   rvdffe #(31) i0wbpcff  (.*, .en(i0_wb_data_en  & trace_enable), .din(dec_tlu_i0_pc_e4[31:1]), .dout(i0_pc_wb[31:1]));\n   rvdffe #(31) i0wb1pcff (.*, .en(i0_wb1_data_en & trace_enable), .din(i0_pc_wb[31:1]),         .dout(i0_pc_wb1[31:1]));\n\n"}
{"text": "   rvdffe #(31) i1wb1pcff (.*, .en(i1_wb1_data_en & trace_enable), .din(i1_pc_wb[31:1]),         .dout(i1_pc_wb1[31:1]));\n\n   assign dec_i0_pc_wb1[31:1] = i0_pc_wb1[31:1];\n   assign dec_i1_pc_wb1[31:1] = i1_pc_wb1[31:1];\n\n\n   // needed for debug triggers\n   rvdffe #(31) i1wbpcff (.*, .en(i1_wb_data_en & trace_enable), .din(dec_tlu_i1_pc_e4[31:1]), .dout(i1_pc_wb[31:1]));\n\n   // pipe the pc's down the pipe\n   assign i0_pc_e1[31:1] = exu_i0_pc_e1[31:1];\n   assign i1_pc_e1[31:1] = exu_i1_pc_e1[31:1];\n\n   rvdffpcie #(31) i0e2pcff (.*, .en(i0_e2_data_en), .din(i0_pc_e1[31:1]), .dout(i0_pc_e2[31:1]));\n   rvdffpcie #(31) i0e3pcff (.*, .en(i0_e3_data_en), .din(i0_pc_e2[31:1]), .dout(i0_pc_e3[31:1]));\n   rvdffpcie #(31) i0e4pcff (.*, .en(i0_e4_data_en), .din(i0_pc_e3[31:1]), .dout(i0_pc_e4[31:1]));\n   rvdffpcie #(31) i1e2pcff (.*, .en(i1_e2_data_en), .din(i1_pc_e1[31:1]), .dout(i1_pc_e2[31:1]));\n   rvdffpcie #(31) i1e3pcff (.*, .en(i1_e3_data_en), .din(i1_pc_e2[31:1]), .dout(i1_pc_e3[31:1]));\n   rvdffpcie #(31) i1e4pcff (.*, .en(i1_e4_data_en), .din(i1_pc_e3[31:1]), .dout(i1_pc_e4[31:1]));\n\n   // to exu\n   assign dec_i0_pc_e3[31:1] = i0_pc_e3[31:1];\n   assign dec_i1_pc_e3[31:1] = i1_pc_e3[31:1];\n\n   // to tlu\n   assign dec_tlu_i0_pc_e4[31:1] = i0_pc_e4[31:1];\n   assign dec_tlu_i1_pc_e4[31:1] = i1_pc_e4[31:1];\n\n   // generate the correct npc for correct br predictions\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n\n      assign last_br_immed_d[i][pt.BTB_TOFFSET_SIZE:1] = (i1_legal_decode_d & (dd.i1tid==i)) ?\n                                                         ((i1_ap.predict_nt)                 ? {{pt.BTB_TOFFSET_SIZE-2{1'b0}},i1_ap_pc4,i1_ap_pc2} :  (i1_ap.predict_t)                  ? i1_br_offset[pt.BTB_TOFFSET_SIZE-1:0] : '0 ) :\n                                                         ((i0_ap.predict_nt & (dd.i0tid==i)) ? {{pt.BTB_TOFFSET_SIZE-2{1'b0}},i0_ap_pc4,i0_ap_pc2} : ((i0_ap.predict_t & (dd.i0tid==i))  ? i0_br_offset[pt.BTB_TOFFSET_SIZE-1:0] : '0 ));\n\n      rvdffe #(pt.BTB_TOFFSET_SIZE) e1brpcff (.*, .en(i0_e1_data_en | i1_e1_data_en), .din(last_br_immed_d[i][pt.BTB_TOFFSET_SIZE:1] ), .dout(last_br_immed_e1[i][pt.BTB_TOFFSET_SIZE:1]));\n      rvdffe #(pt.BTB_TOFFSET_SIZE) e2brpcff (.*, .en(i0_e2_data_en | i1_e2_data_en), .din(last_br_immed_e1[i][pt.BTB_TOFFSET_SIZE:1]), .dout(last_br_immed_e2[i][pt.BTB_TOFFSET_SIZE:1]));\n\n\n      assign last_pc_e2[i][31:1] = (e2d.i1valid & (e2d.i1tid==i) & dec_i1_branch_e2) ? i1_pc_e2[31:1] : (dec_i0_branch_e2) ? i0_pc_e2[31:1] : '0;\n\n      rvbradder ibradder_correct (\n                                  .pc(last_pc_e2[i][31:1]),\n                                  .offset(last_br_immed_e2[i][pt.BTB_TOFFSET_SIZE:1]),\n                                  .dout(pred_correct_npc_e2[i][31:1])\n                                  );\n\n\n   end\n\n\n\n   assign i0_rs1_nonblock_load_bypass_en_d  = dec_i0_rs1_en_d & dec_nonblock_load_wen[dd.i0tid] & (dec_nonblock_load_waddr[dd.i0tid][4:0] == i0r.rs1[4:0]);\n   assign i0_rs2_nonblock_load_bypass_en_d  = dec_i0_rs2_en_d & dec_nonblock_load_wen[dd.i0tid] & (dec_nonblock_load_waddr[dd.i0tid][4:0] == i0r.rs2[4:0]);\n   assign i1_rs1_nonblock_load_bypass_en_d  = dec_i1_rs1_en_d & dec_nonblock_load_wen[dd.i1tid] & (dec_nonblock_load_waddr[dd.i1tid][4:0] == i1r.rs1[4:0]);\n   assign i1_rs2_nonblock_load_bypass_en_d  = dec_i1_rs2_en_d & dec_nonblock_load_wen[dd.i1tid] & (dec_nonblock_load_waddr[dd.i1tid][4:0] == i1r.rs2[4:0]);\n\n   // bit 9 is priority match, bit 0 lowest priority, i1_e1, i0_e1, i1_e2, ... i1_wb, i0_wb\n\n   assign i0_rs1bypass[9:0] = {   i0_rs1_depth_d[3:0] == 4'd1  &  i0_rs1_class_d.alu,\n                                  i0_rs1_depth_d[3:0] == 4'd2  &  i0_rs1_class_d.alu,\n                                  i0_rs1_depth_d[3:0] == 4'd3  &  i0_rs1_class_d.alu,\n                                  i0_rs1_depth_d[3:0] == 4'd4  &  i0_rs1_class_d.alu,\n                                  i0_rs1_depth_d[3:0] == 4'd5  & (i0_rs1_class_d.alu | i0_rs1_class_d.load | i0_rs1_class_d.mul),\n                                  i0_rs1_depth_d[3:0] == 4'd6  & (i0_rs1_class_d.alu | i0_rs1_class_d.load | i0_rs1_class_d.mul),\n                                  i0_rs1_depth_d[3:0] == 4'd7  & (i0_rs1_class_d.alu | i0_rs1_class_d.load | i0_rs1_class_d.mul | i0_rs1_class_d.sec),\n                                  i0_rs1_depth_d[3:0] == 4'd8  & (i0_rs1_class_d.alu | i0_rs1_class_d.load | i0_rs1_class_d.mul | i0_rs1_class_d.sec),\n                                  i0_rs1_depth_d[3:0] == 4'd9  & (i0_rs1_class_d.alu | i0_rs1_class_d.load | i0_rs1_class_d.mul | i0_rs1_class_d.sec),\n                                  i0_rs1_depth_d[3:0] == 4'd10 & (i0_rs1_class_d.alu | i0_rs1_class_d.load | i0_rs1_class_d.mul | i0_rs1_class_d.sec) };\n\n\n   assign i0_rs2bypass[9:0] = {   i0_rs2_depth_d[3:0] == 4'd1  &  i0_rs2_class_d.alu,\n                                  i0_rs2_depth_d[3:0] == 4'd2  &  i0_rs2_class_d.alu,\n                                  i0_rs2_depth_d[3:0] == 4'd3  &  i0_rs2_class_d.alu,\n                                  i0_rs2_depth_d[3:0] == 4'd4  &  i0_rs2_class_d.alu,\n                                  i0_rs2_depth_d[3:0] == 4'd5  & (i0_rs2_class_d.alu | i0_rs2_class_d.load | i0_rs2_class_d.mul),\n                                  i0_rs2_depth_d[3:0] == 4'd6  & (i0_rs2_class_d.alu | i0_rs2_class_d.load | i0_rs2_class_d.mul),\n                                  i0_rs2_depth_d[3:0] == 4'd7  & (i0_rs2_class_d.alu | i0_rs2_class_d.load | i0_rs2_class_d.mul | i0_rs2_class_d.sec),\n                                  i0_rs2_depth_d[3:0] == 4'd8  & (i0_rs2_class_d.alu | i0_rs2_class_d.load | i0_rs2_class_d.mul | i0_rs2_class_d.sec),\n                                  i0_rs2_depth_d[3:0] == 4'd9  & (i0_rs2_class_d.alu | i0_rs2_class_d.load | i0_rs2_class_d.mul | i0_rs2_class_d.sec),\n                                  i0_rs2_depth_d[3:0] == 4'd10 & (i0_rs2_class_d.alu | i0_rs2_class_d.load | i0_rs2_class_d.mul | i0_rs2_class_d.sec) };\n\n\n   assign i1_rs1bypass[9:0] = {   i1_rs1_depth_d[3:0] == 4'd1  &  i1_rs1_class_d.alu,\n                                  i1_rs1_depth_d[3:0] == 4'd2  &  i1_rs1_class_d.alu,\n                                  i1_rs1_depth_d[3:0] == 4'd3  &  i1_rs1_class_d.alu,\n                                  i1_rs1_depth_d[3:0] == 4'd4  &  i1_rs1_class_d.alu,\n                                  i1_rs1_depth_d[3:0] == 4'd5  & (i1_rs1_class_d.alu | i1_rs1_class_d.load | i1_rs1_class_d.mul),\n                                  i1_rs1_depth_d[3:0] == 4'd6  & (i1_rs1_class_d.alu | i1_rs1_class_d.load | i1_rs1_class_d.mul),\n                                  i1_rs1_depth_d[3:0] == 4'd7  & (i1_rs1_class_d.alu | i1_rs1_class_d.load | i1_rs1_class_d.mul | i1_rs1_class_d.sec),\n                                  i1_rs1_depth_d[3:0] == 4'd8  & (i1_rs1_class_d.alu | i1_rs1_class_d.load | i1_rs1_class_d.mul | i1_rs1_class_d.sec),\n                                  i1_rs1_depth_d[3:0] == 4'd9  & (i1_rs1_class_d.alu | i1_rs1_class_d.load | i1_rs1_class_d.mul | i1_rs1_class_d.sec),\n                                  i1_rs1_depth_d[3:0] == 4'd10 & (i1_rs1_class_d.alu | i1_rs1_class_d.load | i1_rs1_class_d.mul | i1_rs1_class_d.sec) };\n\n\n   assign i1_rs2bypass[9:0] = {   i1_rs2_depth_d[3:0] == 4'd1  &  i1_rs2_class_d.alu,\n                                  i1_rs2_depth_d[3:0] == 4'd2  &  i1_rs2_class_d.alu,\n                                  i1_rs2_depth_d[3:0] == 4'd3  &  i1_rs2_class_d.alu,\n                                  i1_rs2_depth_d[3:0] == 4'd4  &  i1_rs2_class_d.alu,\n                                  i1_rs2_depth_d[3:0] == 4'd5  & (i1_rs2_class_d.alu | i1_rs2_class_d.load | i1_rs2_class_d.mul),\n                                  i1_rs2_depth_d[3:0] == 4'd6  & (i1_rs2_class_d.alu | i1_rs2_class_d.load | i1_rs2_class_d.mul),\n                                  i1_rs2_depth_d[3:0] == 4'd7  & (i1_rs2_class_d.alu | i1_rs2_class_d.load | i1_rs2_class_d.mul | i1_rs2_class_d.sec),\n                                  i1_rs2_depth_d[3:0] == 4'd8  & (i1_rs2_class_d.alu | i1_rs2_class_d.load | i1_rs2_class_d.mul | i1_rs2_class_d.sec),\n                                  i1_rs2_depth_d[3:0] == 4'd9  & (i1_rs2_class_d.alu | i1_rs2_class_d.load | i1_rs2_class_d.mul | i1_rs2_class_d.sec),\n                                  i1_rs2_depth_d[3:0] == 4'd10 & (i1_rs2_class_d.alu | i1_rs2_class_d.load | i1_rs2_class_d.mul | i1_rs2_class_d.sec) };\n\n   assign dec_i0_rs1_bypass_en_d = (|i0_rs1bypass[9:0]) | i0_rs1_nonblock_load_bypass_en_d;\n   assign dec_i0_rs2_bypass_en_d = (|i0_rs2bypass[9:0]) | i0_rs2_nonblock_load_bypass_en_d;\n   assign dec_i1_rs1_bypass_en_d = (|i1_rs1bypass[9:0]) | i1_rs1_nonblock_load_bypass_en_d;\n   assign dec_i1_rs2_bypass_en_d = (|i1_rs2bypass[9:0]) | i1_rs2_nonblock_load_bypass_en_d;\n\n   assign i0_rs1_bypass_data_d[31:0] = ({32{i0_rs1bypass[9]}} & i1_result_e1[31:0]) |\n                                       ({32{i0_rs1bypass[8]}} & i0_result_e1[31:0]) |\n                                       ({32{i0_rs1bypass[7]}} & i1_result_e2[31:0]) |\n                                       ({32{i0_rs1bypass[6]}} & i0_result_e2[31:0]) |\n                                       ({32{i0_rs1bypass[5]}} & i1_result_e3_final[31:0]) |\n                                       ({32{i0_rs1bypass[4]}} & i0_result_e3_final[31:0]) |\n                                       ({32{i0_rs1bypass[3]}} & i1_result_e4_final[31:0]) |\n                                       ({32{i0_rs1bypass[2]}} & i0_result_e4_final[31:0]) |\n                                       ({32{i0_rs1bypass[1]}} & i1_result_wb[31:0]) |\n                                       ({32{i0_rs1bypass[0]}} & i0_result_wb[31:0]) |\n                                       ({32{~(|i0_rs1bypass[9:0])}} & lsu_nonblock_load_data[31:0]);\n\n\n   assign i0_rs2_bypass_data_d[31:0] = ({32{i0_rs2bypass[9]}} & i1_result_e1[31:0]) |\n                                       ({32{i0_rs2bypass[8]}} & i0_result_e1[31:0]) |\n                                       ({32{i0_rs2bypass[7]}} & i1_result_e2[31:0]) |\n                                       ({32{i0_rs2bypass[6]}} & i0_result_e2[31:0]) |\n                                       ({32{i0_rs2bypass[5]}} & i1_result_e3_final[31:0]) |\n                                       ({32{i0_rs2bypass[4]}} & i0_result_e3_final[31:0]) |\n                                       ({32{i0_rs2bypass[3]}} & i1_result_e4_final[31:0]) |\n                                       ({32{i0_rs2bypass[2]}} & i0_result_e4_final[31:0]) |\n                                       ({32{i0_rs2bypass[1]}} & i1_result_wb[31:0]) |\n                                       ({32{i0_rs2bypass[0]}} & i0_result_wb[31:0]) |\n                                       ({32{~(|i0_rs2bypass[9:0])}} & lsu_nonblock_load_data[31:0]);\n\n   assign i1_rs1_bypass_data_d[31:0] = ({32{i1_rs1bypass[9]}} & i1_result_e1[31:0]) |\n                                       ({32{i1_rs1bypass[8]}} & i0_result_e1[31:0]) |\n                                       ({32{i1_rs1bypass[7]}} & i1_result_e2[31:0]) |\n                                       ({32{i1_rs1bypass[6]}} & i0_result_e2[31:0]) |\n                                       ({32{i1_rs1bypass[5]}} & i1_result_e3_final[31:0]) |\n                                       ({32{i1_rs1bypass[4]}} & i0_result_e3_final[31:0]) |\n                                       ({32{i1_rs1bypass[3]}} & i1_result_e4_final[31:0]) |\n                                       ({32{i1_rs1bypass[2]}} & i0_result_e4_final[31:0]) |\n                                       ({32{i1_rs1bypass[1]}} & i1_result_wb[31:0]) |\n                                       ({32{i1_rs1bypass[0]}} & i0_result_wb[31:0]) |\n                                       ({32{~(|i1_rs1bypass[9:0])}} & lsu_nonblock_load_data[31:0]);\n\n\n   assign i1_rs2_bypass_data_d[31:0] = ({32{i1_rs2bypass[9]}} & i1_result_e1[31:0]) |\n                                       ({32{i1_rs2bypass[8]}} & i0_result_e1[31:0]) |\n                                       ({32{i1_rs2bypass[7]}} & i1_result_e2[31:0]) |\n                                       ({32{i1_rs2bypass[6]}} & i0_result_e2[31:0]) |\n                                       ({32{i1_rs2bypass[5]}} & i1_result_e3_final[31:0]) |\n                                       ({32{i1_rs2bypass[4]}} & i0_result_e3_final[31:0]) |\n                                       ({32{i1_rs2bypass[3]}} & i1_result_e4_final[31:0]) |\n                                       ({32{i1_rs2bypass[2]}} & i0_result_e4_final[31:0]) |\n                                       ({32{i1_rs2bypass[1]}} & i1_result_wb[31:0]) |\n                                       ({32{i1_rs2bypass[0]}} & i0_result_wb[31:0]) |\n                                       ({32{~(|i1_rs2bypass[9:0])}} & lsu_nonblock_load_data[31:0]);\n\n\n\n\nendmodule\n\nmodule eh2_dec_cam\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)  (\n   input logic  clk,\n   input logic  scan_mode,\n   input logic  rst_l,\n\n   input logic  active_clk,\n\n   input logic flush,\n   input logic  tid,\n\n   input logic dec_tlu_i0_kill_writeb_wb,\n   input logic dec_tlu_i1_kill_writeb_wb,\n\n   input logic dec_tlu_force_halt,\n\n   input logic                                lsu_nonblock_load_data_tid,\n\n   input eh2_dest_pkt_t dd,\n   input eh2_dest_pkt_t wbd,\n   input eh2_reg_pkt_t i0r,\n   input eh2_reg_pkt_t i1r,\n\n   input logic                                lsu_nonblock_load_valid_dc1,     // valid nonblock load at dc3\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_tag_dc1,       // -> corresponding tag\n\n   input logic                                lsu_nonblock_load_inv_dc2,       // invalidate request for nonblock load dc2\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_inv_tag_dc2,   // -> corresponding tag\n\n   input logic                                lsu_nonblock_load_inv_dc5,       // invalidate request for nonblock load dc5\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_inv_tag_dc5,   // -> corresponding tag\n\n   input logic                                lsu_nonblock_load_data_valid,    // valid nonblock load data back\n   input logic                                lsu_nonblock_load_data_error,    // nonblock load bus error\n   input logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_data_tag,      // -> corresponding tag\n\n\n   input logic [4:0] nonblock_load_rd,\n   input logic       nonblock_load_tid_dc1,\n   input logic       nonblock_load_tid_dc2,\n   input logic       nonblock_load_tid_dc5,\n\n   input logic       dec_i0_rs1_en_d,\n   input logic       dec_i0_rs2_en_d,\n   input logic       dec_i1_rs1_en_d,\n   input logic       dec_i1_rs2_en_d,\n\n   input logic       i1_wen_wb,\n   input logic       i0_wen_wb,\n\n   output logic [4:0] nonblock_load_waddr,\n   output logic       nonblock_load_wen,\n\n   output logic       i0_nonblock_load_stall,\n   output logic       i1_nonblock_load_stall,\n   output logic       i0_load_kill_wen,\n   output logic       i1_load_kill_wen,\n   output logic      nonblock_load_stall\n   );\n\n   localparam NBLOAD_SIZE     = pt.LSU_NUM_NBLOAD;\n   localparam NBLOAD_SIZE_MSB = int'(pt.LSU_NUM_NBLOAD)-1;\n   localparam NBLOAD_TAG_MSB  = pt.LSU_NUM_NBLOAD_WIDTH-1;\n\n   logic                     cam_write,     cam_inv_dc2_reset,     cam_inv_dc5_reset,     cam_data_reset;\n   logic [NBLOAD_TAG_MSB:0]  cam_write_tag, cam_inv_dc2_reset_tag, cam_inv_dc5_reset_tag, cam_data_reset_tag;\n   logic [NBLOAD_SIZE_MSB:0] cam_wen;\n\n   logic [NBLOAD_TAG_MSB:0]  load_data_tag;\n   logic [NBLOAD_SIZE_MSB:0] nonblock_load_write;\n   logic i1_nonblock_boundary_stall, i0_nonblock_boundary_stall;\n\n   logic nonblock_load_valid_dc2_raw, nonblock_load_valid_dc2, nonblock_load_valid_dc3, nonblock_load_valid_dc4;\n\n   logic found;\n   logic cam_reset_same_dest_wb;\n   logic nonblock_load_valid_wb;\n   logic i0_nonblock_load_match;\n   logic [NBLOAD_SIZE_MSB:0] cam_inv_dc2_reset_val, cam_inv_dc5_reset_val, cam_data_reset_val;\n   logic                     nonblock_load_cancel;\n\n   eh2_load_cam_pkt_t [NBLOAD_SIZE_MSB:0] cam;\n   eh2_load_cam_pkt_t [NBLOAD_SIZE_MSB:0] cam_in;\n   eh2_load_cam_pkt_t [NBLOAD_SIZE_MSB:0] cam_raw;\n\n\n   always_comb begin\n      found = 0;\n      for (int i=0; i<NBLOAD_SIZE; i++) begin\n         if (~found) begin\n            if (~cam[i].valid) begin\n               cam_wen[i] = cam_write;  // cam_write is threaded\n               found = 1'b1;\n            end\n            else begin\n             cam_wen[i] = 0;\n            end\n         end\n         else\n             cam_wen[i] = 0;\n      end\n   end\n\n\n   // threaded\n   assign cam_reset_same_dest_wb = wbd.i0v & wbd.i1v & (wbd.i0rd[4:0] == wbd.i1rd[4:0]) & (wbd.i0tid == tid) & (wbd.i1tid == tid) &\n                                   wbd.i0load & nonblock_load_valid_wb & ~dec_tlu_i0_kill_writeb_wb & ~dec_tlu_i1_kill_writeb_wb;\n\n   // threaded\n   assign cam_write          = lsu_nonblock_load_valid_dc1 & (nonblock_load_tid_dc1 == tid);\n\n   assign cam_write_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_tag_dc1[NBLOAD_TAG_MSB:0];\n\n   // threaded\n   assign cam_inv_dc2_reset                       = lsu_nonblock_load_inv_dc2 & (nonblock_load_tid_dc2 == tid);\n\n   assign cam_inv_dc2_reset_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_inv_tag_dc2[NBLOAD_TAG_MSB:0];\n\n   // threaded\n   assign cam_inv_dc5_reset                       = (lsu_nonblock_load_inv_dc5 & (nonblock_load_tid_dc5 == tid)) |\n                                                     cam_reset_same_dest_wb;\n\n   assign cam_inv_dc5_reset_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_inv_tag_dc5[NBLOAD_TAG_MSB:0];\n\n   // threaded\n   assign cam_data_reset          = (lsu_nonblock_load_data_valid | lsu_nonblock_load_data_error) & (lsu_nonblock_load_data_tid == tid);\n\n   assign cam_data_reset_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_data_tag[NBLOAD_TAG_MSB:0];\n\n   // checks\n\n`ifdef RV_ASSERT_ON\n   assert_dec_data_valid_data_error_onehot: assert #0 ($onehot0({lsu_nonblock_load_data_valid,lsu_nonblock_load_data_error}));\n   assert_dec_cam_dc2_inv_reset_onehot:     assert #0 ($onehot0(cam_inv_dc2_reset_val[NBLOAD_SIZE_MSB:0]));\n   assert_dec_cam_dc5_inv_reset_onehot:     assert #0 ($onehot0(cam_inv_dc5_reset_val[NBLOAD_SIZE_MSB:0]));\n   assert_dec_cam_data_reset_onehot:        assert #0 ($onehot0(cam_data_reset_val[NBLOAD_SIZE_MSB:0]));\n`endif\n\n   // all these signals are threaded\n\n    // case of multiple loads to same dest ie. x1 ... you have to invalidate the older one\n\n   for (genvar i=0; i<NBLOAD_SIZE; i++) begin : cam_array\n\n      assign cam_inv_dc2_reset_val[i] = cam_inv_dc2_reset   & (cam_inv_dc2_reset_tag[NBLOAD_TAG_MSB:0]  == cam[i].tag[NBLOAD_TAG_MSB:0]) & cam[i].valid;\n\n      assign cam_inv_dc5_reset_val[i] = cam_inv_dc5_reset   & (cam_inv_dc5_reset_tag[NBLOAD_TAG_MSB:0]  == cam[i].tag[NBLOAD_TAG_MSB:0]) & cam[i].valid;\n\n      assign cam_data_reset_val[i] = cam_data_reset & (cam_data_reset_tag[NBLOAD_TAG_MSB:0] == cam_raw[i].tag[NBLOAD_TAG_MSB:0]) & cam_raw[i].valid;\n\n      always_comb begin\n\n         cam[i] = cam_raw[i];\n\n         if (pt.LOAD_TO_USE_BUS_PLUS1==0 & cam_data_reset_val[i])\n           cam[i].valid = 1'b0;\n\n         cam_in[i] = cam[i];\n\n         if (cam_wen[i]) begin\n            cam_in[i].valid    = 1'b1;\n            cam_in[i].stall    = 1'b0;\n            cam_in[i].wb       = 1'b0;\n            cam_in[i].tag[NBLOAD_TAG_MSB:0] = cam_write_tag[NBLOAD_TAG_MSB:0];\n            cam_in[i].rd[4:0]  = nonblock_load_rd[4:0];\n         end\n         else if ( (cam_inv_dc2_reset_val[i]) |\n                   (cam_inv_dc5_reset_val[i]) |\n                   (pt.LOAD_TO_USE_BUS_PLUS1==1 & cam_data_reset_val[i]) |\n                   (i0_wen_wb & (wbd.i0rd[4:0] == cam[i].rd[4:0]) & (wbd.i0tid == tid) & cam[i].wb) |\n                   (i1_wen_wb & (wbd.i1rd[4:0] == cam[i].rd[4:0]) & (wbd.i1tid == tid) & cam[i].wb) )\n           cam_in[i].valid = 1'b0;\n\n         // nonblock_load_valid_wb is threaded\n         if (nonblock_load_valid_wb & (lsu_nonblock_load_inv_tag_dc5[NBLOAD_TAG_MSB:0]==cam[i].tag[NBLOAD_TAG_MSB:0]) & cam[i].valid)\n           cam_in[i].wb = 1'b1;\n\n         // force debug halt forces cam valids to 0; "}
{"text": "highest priority\n         if (dec_tlu_force_halt)\n           cam_in[i].valid = 1'b0;\n\n         // smt optimization\n         if (flush)\n           cam_in[i].stall = 1'b0;\n         else if ((dec_i0_rs1_en_d & (dd.i0tid == tid) & cam[i].valid & (cam[i].rd[4:0] == i0r.rs1[4:0])) |\n                  (dec_i0_rs2_en_d & (dd.i0tid == tid) & cam[i].valid & (cam[i].rd[4:0] == i0r.rs2[4:0])))\n           cam_in[i].stall = 1'b1;\n\n      end // always_comb begin\n\n      rvdffie #( $bits(eh2_load_cam_pkt_t) ) cam_ff (.*, .din(cam_in[i]), .dout(cam_raw[i]));\n\n      // not threaded\n      assign nonblock_load_write[i] = (load_data_tag[NBLOAD_TAG_MSB:0] == cam_raw[i].tag[NBLOAD_TAG_MSB:0]) & cam_raw[i].valid;\n\n   end : cam_array\n\n   assign load_data_tag[NBLOAD_TAG_MSB:0] = lsu_nonblock_load_data_tag[NBLOAD_TAG_MSB:0];\n\n`ifdef RV_ASSERT_ON\n   assert_dec_cam_nonblock_load_write_onehot:   assert #0 ($onehot0(nonblock_load_write[NBLOAD_SIZE_MSB:0]));\n`endif\n\n\n   assign nonblock_load_cancel = ((wbd.i0rd[4:0] == nonblock_load_waddr[4:0]) & (wbd.i0tid == tid) & (wbd.i0tid == lsu_nonblock_load_data_tid) & i0_wen_wb) |    // cancel if any younger inst (including another nonblock) committing this cycle\n                                 ((wbd.i1rd[4:0] == nonblock_load_waddr[4:0]) & (wbd.i1tid == tid) & (wbd.i1tid == lsu_nonblock_load_data_tid) & i1_wen_wb);\n\n   // threaded\n   assign nonblock_load_wen = lsu_nonblock_load_data_valid & (lsu_nonblock_load_data_tid == tid) & |nonblock_load_write[NBLOAD_SIZE_MSB:0] & ~nonblock_load_cancel;\n\n   always_comb begin\n      nonblock_load_waddr[4:0] = '0;\n\n      nonblock_load_stall = '0;\n\n      i0_nonblock_load_stall = i0_nonblock_boundary_stall;\n      i1_nonblock_load_stall = i1_nonblock_boundary_stall;\n\n      for (int i=0; i<NBLOAD_SIZE; i++) begin\n         nonblock_load_waddr[4:0] |= ({5{nonblock_load_write[i] & (lsu_nonblock_load_data_tid == tid)}} & cam[i].rd[4:0]);\n\n         // threaded\n         i0_nonblock_load_stall |= dec_i0_rs1_en_d & (dd.i0tid == tid) & cam[i].valid & (cam[i].rd[4:0] == i0r.rs1[4:0]);\n         i0_nonblock_load_stall |= dec_i0_rs2_en_d & (dd.i0tid == tid) & cam[i].valid & (cam[i].rd[4:0] == i0r.rs2[4:0]);\n\n         i1_nonblock_load_stall |= dec_i1_rs1_en_d & (dd.i1tid == tid) & cam[i].valid & (cam[i].rd[4:0] == i1r.rs1[4:0]);\n         i1_nonblock_load_stall |= dec_i1_rs2_en_d & (dd.i1tid == tid) & cam[i].valid & (cam[i].rd[4:0] == i1r.rs2[4:0]);\n\n         nonblock_load_stall |= (cam_in[i].valid & cam[i].stall);\n      end\n   end\n\n   // cam_write is threaded\n   assign i0_nonblock_boundary_stall = ((nonblock_load_rd[4:0]==i0r.rs1[4:0]) & (dd.i0tid == tid) & cam_write & dec_i0_rs1_en_d) |\n                                       ((nonblock_load_rd[4:0]==i0r.rs2[4:0]) & (dd.i0tid == tid) & cam_write & dec_i0_rs2_en_d);\n\n   assign i1_nonblock_boundary_stall = ((nonblock_load_rd[4:0]==i1r.rs1[4:0]) & (dd.i1tid == tid) & cam_write & dec_i1_rs1_en_d) |\n                                       ((nonblock_load_rd[4:0]==i1r.rs2[4:0]) & (dd.i1tid == tid) & cam_write & dec_i1_rs2_en_d);\n\n// don't writeback a nonblock load\n\n   // cam write is threaded\n   rvdff #(1) e2nbloadff (.*, .clk(active_clk), .din(cam_write),  .dout(nonblock_load_valid_dc2_raw) );\n\n   // cam_inv_dc2_reset is threaded\n   assign nonblock_load_valid_dc2 = nonblock_load_valid_dc2_raw & ~cam_inv_dc2_reset;\n\n   rvdff #(1) e3nbloadff (.*, .clk(active_clk), .din(    nonblock_load_valid_dc2),  .dout(nonblock_load_valid_dc3) );\n   rvdff #(1) e4nbloadff (.*, .clk(active_clk), .din(    nonblock_load_valid_dc3),  .dout(nonblock_load_valid_dc4) );\n   rvdff #(1) wbnbloadff (.*, .clk(active_clk), .din(    nonblock_load_valid_dc4),  .dout(nonblock_load_valid_wb) );\n\n   // illegal for i0load and i1load same time - even with threads\n   assign i0_load_kill_wen = nonblock_load_valid_wb &  wbd.i0load;\n   assign i1_load_kill_wen = nonblock_load_valid_wb &  wbd.i1load;\n\nendmodule\n\n\n// file \"decode\" is human readable file that has all of the instruction decodes defined and is part of git repo\n// modify this file as needed\n\n// to generate all the equations below from \"decode\" except legal equation:\n\n// 1) coredecode -in decode > coredecode.e\n\n// 2) espresso -Dso -oeqntott coredecode.e | addassign -pre out.  > equations\n\n// to generate the legal (32b instruction is legal) equation below:\n\n// 1) coredecode -in decode -legal > legal.e\n\n// 2) espresso -Dso -oeqntott legal.e | addassign -pre out. > legal_equation\n\n// the following predecodes are done in eh2_ifu_aln_ctl - full decodes - .type fd (not .type fr)\n// DO NOT regenerate these decodes here\n//\n// assign out.lsu = predecode.lsu;\n//\n// assign out.mul = predecode.mul;\n//\n// assign out.i0_only = predecode.i0_only;\n//\n// assign out.legal = predecode.legal1 | predecode.legal2 | predecode.legal3 | predecode.legal4;\n\nmodule eh2_dec_dec_ctl\nimport eh2_pkg::*;\n  (\n   input logic [31:0] inst,\n   input eh2_predecode_pkt_t predecode,\n\n   output eh2_dec_pkt_t out\n   );\n\n   logic [31:0] i;\n\n\nassign i[31:0] = inst[31:0];\n\n// predecodes done in eh2_ifu_aln_ctl - do not overwrite - full decodes .type fd\n\nassign out.lsu = predecode.lsu;\n\nassign out.mul = predecode.mul;\n\nassign out.i0_only = predecode.i0_only;\n\nassign out.legal = predecode.legal1 | predecode.legal2 | predecode.legal3 | predecode.legal4;\n\n// end predecodes\n\n// general decode equations\n\nassign out.alu = (!i[5]&i[2]) | (i[30]&i[24]&i[23]&!i[22]&!i[21]&!i[20]&i[14]&!i[5]\n    &i[4]) | (i[30]&!i[27]&!i[24]&i[4]) | (!i[30]&!i[25]&i[13]&i[12]) | (\n    !i[29]&!i[27]&!i[5]&i[4]) | (!i[29]&!i[25]&!i[13]&!i[12]&i[4]) | (\n    i[27]&i[25]&i[14]&i[4]) | (i[29]&i[27]&!i[14]&i[12]&i[4]) | (!i[27]\n    &i[14]&!i[5]&i[4]) | (i[30]&!i[29]&!i[13]&i[4]) | (!i[27]&!i[25]&i[5]\n    &i[4]) | (i[13]&!i[5]&i[4]) | (!i[3]&i[2]) | (i[6]) | (!i[30]&i[29]\n    &!i[24]&!i[23]&i[22]&i[21]&i[20]&!i[5]&i[4]) | (!i[12]&!i[5]&i[4]);\n\nassign out.rs1 = (!i[13]&i[11]&!i[2]) | (!i[6]&i[5]&i[3]) | (!i[13]&i[10]&!i[2]) | (\n    i[19]&i[13]&!i[2]) | (!i[13]&i[9]&!i[2]) | (i[18]&i[13]&!i[2]) | (\n    !i[13]&i[8]&!i[2]) | (i[17]&i[13]&!i[2]) | (!i[13]&i[7]&!i[2]) | (\n    i[16]&i[13]&!i[2]) | (i[15]&i[13]&!i[2]) | (!i[4]&!i[2]) | (!i[14]\n    &!i[13]&i[6]&!i[3]) | (!i[6]&!i[2]);\n\nassign out.rs2 = (i[27]&!i[6]&i[5]&i[3]) | (!i[28]&!i[6]&i[5]&i[3]) | (i[5]&!i[4]\n    &!i[2]) | (!i[6]&i[5]&!i[2]);\n\nassign out.imm12 = (!i[4]&!i[3]&i[2]) | (i[13]&!i[5]&i[4]&!i[2]) | (!i[13]&!i[12]\n    &i[6]&i[4]) | (!i[12]&!i[5]&i[4]&!i[2]);\n\nassign out.rd = (!i[5]&!i[2]) | (i[5]&i[2]) | (i[4]);\n\nassign out.shimm5 = (!i[29]&!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (i[27]&!i[13]&i[12]\n    &!i[5]&i[4]&!i[2]) | (i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\nassign out.imm20 = (i[6]&i[3]) | (i[4]&i[2]);\n\nassign out.pc = (!i[5]&!i[3]&i[2]) | (i[6]&i[3]);\n\nassign out.load = (!i[28]&!i[6]&i[5]&i[3]) | (!i[27]&!i[6]&i[5]&i[3]) | (!i[5]&!i[4]\n    &!i[2]);\n\nassign out.store = (i[27]&!i[6]&i[5]&i[3]) | (!i[28]&!i[6]&i[5]&i[3]) | (!i[6]&i[5]\n    &!i[4]&!i[2]);\n\nassign out.add = (!i[14]&!i[13]&!i[12]&!i[5]&i[4]) | (!i[5]&!i[3]&i[2]) | (!i[30]\n    &!i[25]&!i[14]&!i[13]&!i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.sub = (i[30]&!i[14]&!i[12]&!i[6]&i[5]&i[4]&!i[2]) | (!i[29]&!i[25]&!i[14]\n    &i[13]&!i[6]&i[4]&!i[2]) | (i[27]&i[25]&i[14]&!i[6]&i[5]&!i[2]) | (\n    !i[14]&i[13]&!i[5]&i[4]&!i[2]) | (i[6]&!i[4]&!i[2]);\n\nassign out.land = (!i[27]&!i[25]&i[14]&i[13]&i[12]&!i[6]&!i[2]) | (i[14]&i[13]&i[12]\n    &!i[5]&!i[2]);\n\nassign out.lor = (!i[5]&i[3]) | (!i[29]&!i[27]&!i[25]&i[14]&i[13]&!i[12]&i[4]&!i[2]) | (\n    i[5]&i[4]&i[2]) | (!i[12]&i[6]&i[4]) | (i[13]&i[6]&i[4]) | (i[14]\n    &i[13]&!i[12]&!i[5]&!i[2]) | (i[7]&i[6]&i[4]) | (i[8]&i[6]&i[4]) | (\n    i[9]&i[6]&i[4]) | (i[10]&i[6]&i[4]) | (i[11]&i[6]&i[4]);\n\nassign out.lxor = (!i[29]&!i[27]&!i[25]&i[14]&!i[13]&!i[12]&i[4]&!i[2]) | (i[14]\n    &!i[13]&!i[12]&!i[5]&i[4]&!i[2]);\n\nassign out.sll = (!i[29]&!i[27]&!i[25]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.sra = (i[30]&!i[29]&!i[27]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.srl = (!i[30]&!i[27]&!i[25]&i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.slt = (!i[29]&!i[25]&!i[14]&i[13]&!i[6]&i[4]&!i[2]) | (!i[14]&i[13]&!i[5]\n    &i[4]&!i[2]);\n\nassign out.unsign = (i[31]&i[30]&!i[6]&i[3]) | (!i[14]&i[13]&i[12]&!i[5]&!i[2]) | (\n    i[14]&!i[5]&!i[4]) | (i[13]&i[6]&!i[4]&!i[2]) | (i[25]&i[14]&i[12]\n    &!i[6]&i[5]&!i[2]) | (!i[25]&!i[14]&i[13]&i[12]&!i[6]&!i[2]);\n\nassign out.condbr = (i[6]&!i[4]&!i[2]);\n\nassign out.beq = (!i[14]&!i[12]&i[6]&!i[4]&!i[2]);\n\nassign out.bne = (!i[14]&i[12]&i[6]&!i[4]&!i[2]);\n\nassign out.bge = (i[14]&i[12]&i[5]&!i[4]&!i[2]);\n\nassign out.blt = (i[14]&!i[12]&i[5]&!i[4]&!i[2]);\n\nassign out.jal = (i[6]&i[2]);\n\nassign out.by = (!i[13]&!i[12]&!i[6]&!i[4]&!i[2]);\n\nassign out.half = (i[12]&!i[6]&!i[4]&!i[2]);\n\nassign out.word = (i[13]&!i[6]&!i[4]);\n\nassign out.csr_read = (i[13]&i[6]&i[4]) | (i[7]&i[6]&i[4]) | (i[8]&i[6]&i[4]) | (\n    i[9]&i[6]&i[4]) | (i[10]&i[6]&i[4]) | (i[11]&i[6]&i[4]);\n\nassign out.csr_clr = (i[15]&i[13]&i[12]&i[6]&i[4]) | (i[16]&i[13]&i[12]&i[6]&i[4]) | (\n    i[17]&i[13]&i[12]&i[6]&i[4]) | (i[18]&i[13]&i[12]&i[6]&i[4]) | (\n    i[19]&i[13]&i[12]&i[6]&i[4]);\n\nassign out.csr_set = (i[15]&!i[12]&i[6]&i[4]) | (i[16]&!i[12]&i[6]&i[4]) | (i[17]\n    &!i[12]&i[6]&i[4]) | (i[18]&!i[12]&i[6]&i[4]) | (i[19]&!i[12]&i[6]\n    &i[4]);\n\nassign out.csr_write = (!i[13]&i[12]&i[6]&i[4]);\n\nassign out.csr_imm = (i[14]&!i[13]&i[6]&i[4]) | (i[15]&i[14]&i[6]&i[4]) | (i[16]\n    &i[14]&i[6]&i[4]) | (i[17]&i[14]&i[6]&i[4]) | (i[18]&i[14]&i[6]&i[4]) | (\n    i[19]&i[14]&i[6]&i[4]);\n\nassign out.presync = (!i[6]&i[3]) | (!i[13]&i[7]&i[6]&i[4]) | (!i[13]&i[8]&i[6]&i[4]) | (\n    !i[13]&i[9]&i[6]&i[4]) | (!i[13]&i[10]&i[6]&i[4]) | (!i[13]&i[11]\n    &i[6]&i[4]) | (i[15]&i[13]&i[6]&i[4]) | (i[16]&i[13]&i[6]&i[4]) | (\n    i[17]&i[13]&i[6]&i[4]) | (i[18]&i[13]&i[6]&i[4]) | (i[19]&i[13]&i[6]\n    &i[4]);\n\nassign out.postsync = (i[12]&!i[5]&i[3]) | (!i[22]&!i[13]&!i[12]&i[6]&i[4]) | (\n    i[28]&i[27]&!i[6]&i[3]) | (!i[13]&i[7]&i[6]&i[4]) | (!i[13]&i[8]&i[6]\n    &i[4]) | (!i[13]&i[9]&i[6]&i[4]) | (!i[13]&i[10]&i[6]&i[4]) | (!i[13]\n    &i[11]&i[6]&i[4]) | (i[15]&i[13]&i[6]&i[4]) | (i[16]&i[13]&i[6]&i[4]) | (\n    i[17]&i[13]&i[6]&i[4]) | (i[18]&i[13]&i[6]&i[4]) | (i[19]&i[13]&i[6]\n    &i[4]);\n\nassign out.ebreak = (!i[22]&i[20]&!i[13]&!i[12]&i[6]&i[4]);\n\nassign out.ecall = (!i[21]&!i[20]&!i[13]&!i[12]&i[6]&i[4]);\n\nassign out.mret = (i[29]&!i[13]&!i[12]&i[6]&i[4]);\n\nassign out.rs1_sign = (!i[27]&i[25]&!i[14]&i[13]&!i[12]&!i[6]&i[5]&i[4]&!i[2]) | (\n    !i[27]&i[25]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.rs2_sign = (!i[27]&i[25]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.low = (i[25]&!i[14]&!i[13]&!i[12]&i[5]&i[4]&!i[2]);\n\nassign out.div = (!i[27]&i[25]&i[14]&!i[6]&i[5]&!i[2]);\n\nassign out.rem = (!i[27]&i[25]&i[14]&i[13]&!i[6]&i[5]&!i[2]);\n\nassign out.fence = (!i[5]&i[3]);\n\nassign out.fence_i = (i[12]&!i[5]&i[3]);\n\nassign out.clz = (i[29]&!i[27]&!i[24]&!i[22]&!i[21]&!i[20]&!i[14]&!i[13]&i[12]&!i[5]\n    &i[4]&!i[2]);\n\nassign out.ctz = (i[29]&!i[27]&!i[24]&!i[22]&i[20]&!i[14]&!i[13]&i[12]&!i[5]&i[4]\n    &!i[2]);\n\nassign out.cpop = (i[29]&!i[27]&!i[24]&i[21]&!i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\nassign out.sext_b = (i[29]&!i[27]&i[22]&!i[20]&!i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\nassign out.sext_h = (i[29]&!i[27]&i[22]&i[20]&!i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\nassign out.min = (i[27]&i[25]&i[14]&!i[13]&!i[6]&i[5]&!i[2]);\n\nassign out.max = (i[27]&i[25]&i[14]&i[13]&!i[6]&i[5]&!i[2]);\n\nassign out.pack = (!i[30]&!i[29]&i[27]&!i[25]&!i[13]&!i[12]&i[5]&i[4]&!i[2]);\n\nassign out.packu = (i[30]&i[27]&!i[13]&!i[12]&i[5]&i[4]&!i[2]);\n\nassign out.packh = (!i[30]&i[27]&!i[25]&i[13]&i[12]&!i[6]&i[5]&!i[2]);\n\nassign out.rol = (i[29]&!i[27]&!i[14]&i[12]&!i[6]&i[5]&i[4]&!i[2]);\n\nassign out.ror = (i[29]&!i[27]&i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.zbb = (!i[30]&!i[29]&i[27]&!i[24]&!i[23]&!i[22]&!i[21]&!i[20]&!i[13]\n    &!i[12]&i[5]&i[4]&!i[2]) | (i[29]&!i[27]&!i[24]&!i[13]&i[12]&!i[5]\n    &i[4]&!i[2]) | (i[29]&!i[27]&i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (\n    i[30]&!i[27]&i[14]&!i[12]&!i[6]&i[5]&!i[2]) | (i[30]&!i[27]&i[13]\n    &!i[6]&i[5]&i[4]&!i[2]) | (i[29]&!i[27]&i[12]&!i[6]&i[5]&i[4]&!i[2]) | (\n    !i[30]&i[29]&!i[24]&!i[23]&i[22]&i[21]&i[20]&i[14]&!i[13]&i[12]&!i[5]\n    &i[4]&!i[2]) | (i[30]&i[29]&i[24]&i[23]&!i[22]&!i[21]&!i[20]&i[14]\n    &!i[13]&i[12]&!i[5]&i[4]&!i[2]) | (i[27]&i[25]&i[14]&!i[6]&i[5]&!i[2]);\n\nassign out.bset = (!i[30]&i[29]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.bclr = (i[30]&!i[29]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.binv = (i[30]&i[29]&i[27]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.bext = (i[30]&!i[29]&i[27]&i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.zbs = (i[29]&i[27]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]) | (i[30]&!i[29]\n    &i[27]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.bcompress = (!i[30]&!i[29]&i[27]&!i[25]&i[13]&!i[12]&!i[6]&i[5]&i[4]&!i[2]);\n\nassign out.bdecompress = (i[30]&i[27]&i[13]&!i[12]&!i[6]&i[5]&i[4]&!i[2]);\n\nassign out.zbe = (i[30]&i[27]&i[14]&i[13]&!i[12]&!i[6]&i[5]&!i[2]) | (!i[30]&i[27]\n    &!i[25]&i[13]&i[12]&!i[6]&i[5]&!i[2]) | (!i[30]&!i[29]&i[27]&!i[25]\n    &!i[12]&!i[6]&i[5]&i[4]&!i[2]);\n\nassign out.clmul = (i[27]&i[25]&!i[14]&!i[13]&!i[6]&i[5]&i[4]&!i[2]);\n\nassign out.clmulh = (i[27]&!i[14]&i[13]&i[12]&!i[6]&i[5]&!i[2]);\n\nassign out.clmulr = (i[27]&i[25]&!i[14]&!i[12]&!i[6]&i[5]&i[4]&!i[2]);\n\nassign out.zbc = (i[27]&i[25]&!i[14]&!i[6]&i[5]&i[4]&!i[2]);\n\nassign out.grev = (i[30]&i[29]&i[27]&i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.gorc = (!i[30]&i[29]&i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.shfl = (!i[30]&!i[29]&i[27]&!i[25]&!i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.unshfl = (!i[30]&!i[29]&i[27]&!i[25]&i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.xperm_n = (i[29]&i[27]&!i[14]&!i[12]&!i[6]&i[5]&i[4]&!i[2]);\n\nassign out.xperm_b = (i[29]&i[27]&!i[13]&!i[12]&i[5]&i[4]&!i[2]);\n\nassign out.xperm_h = (i[29]&i[27]&i[14]&i[13]&!i[6]&i[5]&!i[2]);\n\nassign out.zbp = (i[30]&!i[27]&!i[14]&i[12]&!i[6]&i[5]&i[4]&!i[2]) | (!i[30]&i[27]\n    &!i[25]&i[13]&i[12]&!i[6]&i[5]&!i[2]) | (i[30]&!i[27]&i[13]&!i[6]\n    &i[5]&i[4]&!i[2]) | (i[27]&!i[25]&!i[13]&!i[12]&i[5]&i[4]&!i[2]) | (\n    i[30]&i[14]&!i[13]&!i[12]&i[5]&i[4]&!i[2]) | (i[29]&i[27]&!i[12]&!i[6]\n    &i[5]&i[4]&!i[2]) | (!i[30]&!i[29]&i[27]&!i[25]&!i[13]&i[12]&!i[6]\n    &i[4]&!i[2]) | (i[29]&i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[2]);\n\nassign out.crc32_b = (i[29]&!i[27]&i[24]&!i[23]&!i[21]&!i[20]&!i[14]&!i[13]&i[12]\n    &!i[5]&i[4]&!i[2]);\n\nassign out.crc32_h = (i[29]&!i[27]&i[24]&!i[23]&i[20]&!i[14]&!i[13]&i[12]&!i[5]&i[4]\n    &!i[2]);\n\nassign out.crc32_w = (i[29]&!i[27]&i[24]&!i[23]&i[21]&!i[14]&!i[13]&i[12]&!i[5]&i[4]\n    &!i[2]);\n\nassign out.crc32c_b = (i[29]&!i[27]&i[23]&!i[21]&!i[20]&!i[14]&!i[13]&i[12]&!i[5]\n    &i[4]&!i[2]);\n\nassign out.crc32c_h = (i[29]&!i[27]&i[23]&i[20]&!i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\nassign out.crc32c_w = (i[29]&!i[27]&i[23]&i[21]&!i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\nassign out.zbr = (i[29]&!i[27]&i[24]&!i[14]&!i[13]&i[12]&!i[5]&i[4]&!i[2]);\n\nassign out.bfp = (i[30]&i[27]&i[13]&i[12]&!i[6]&i[5]&!i[2]);\n\nassign out.zbf = (!i[30]&!i[29]&i[27]&!i[25]&!i[13]&!i[12]&i[5]&i[4]&!i[2]) | (\n    i[27]&!i[25]&i[13]&i[12]&!i[6]&i[5]&!i[2]);\n\nassign out.sh1add = (i[29]&!i[27]&!i[14]&!i[12]&!i[6]&i[5]&i[4]&!i[2]);\n\nassign out.sh2add = (i[29]&!i[27]&i[14]&!i[13]&!i[12]&i[5]&i[4]&!i[2]);\n\nassign out.sh3add = (i[29]&!i[27]&i[14]&i[13]&!i[6]&i[5]&!i[2]);\n\nassign out.zba = (i[29]&!i[27]&!i[12]&!i[6]&i[5]&i[4]&!i[2]);\n\nassign out.pm_alu = (i[28]&i[20]&!i[13]&!i[12]&i[4]) | (!i[30]&!i[29]&!i[27]&!i[25]\n    &!i[6]&i[4]) | (!i[29]&!i[27]&!i[25]&!i[13]&i[12]&!i[6]&i[4]) | (\n    !i[29]&!i[27]&!i[25]&!i[14]&!i[6]&i[4]) | (i[13]&!i[5]&i[4]) | (i[4]\n    &i[2]) | (!i[12]&!i[5]&i[4]);\n\nassign out.atomic = (!i[6]&i[5]&i[3]);\n\nassign out.lr = (i[28]&!i[27]&!i[6]&i[3]);\n\nassign out.sc = (i[28]&i[27]&!i[6]&i[3]);\n\n\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmodule eh2_dec_gpr_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n )  (\n    input logic       tid,\n\n    input logic [4:0] raddr0,  // logical read addresses\n    input logic [4:0] raddr1,\n    input logic [4:0] raddr2,\n    input logic [4:0] raddr3,\n\n    input logic       rtid0,   // read tids\n    input logic       rtid1,\n    input logic       rtid2,\n    input logic       rtid3,\n\n    input logic       rden0,   // read enables\n    input logic       rden1,\n    input logic       rden2,\n    input logic       rden3,\n\n    input logic [4:0] waddr0,  // logical write addresses\n    input logic [4:0] waddr1,\n    input logic [4:0] waddr2,\n    input logic [4:0] waddr3,\n\n    input logic wtid0,         // write tids\n    input logic wtid1,\n    input logic wtid2,\n    input logic wtid3,\n\n    input logic wen0,          // write enables\n    input logic wen1,\n    input logic wen2,\n    input logic wen3,\n\n    input logic [31:0] wd0,    // write data\n    input logic [31:0] wd1,\n    input logic [31:0] wd2,\n    input logic [31:0] wd3,\n\n    input logic       clk,\n    input logic       rst_l,\n\n    output logic [31:0] rd0,   // read data\n    output logic [31:0] rd1,\n    output logic [31:0] rd2,\n    output logic [31:0] rd3,\n\n    input  logic        scan_mode\n);\n\n   logic [31:1] [31:0] gpr_out;     // 31 x 32 bit GPRs\n   logic [31:1] [31:0] gpr_in;\n   logic [31:1] w0v,w1v,w2v,w3v;\n   logic [31:1] gpr_wr_en;\n\n   // GPR Write Enables\n   assign gpr_wr_en[31:1] = (w0v[31:1] | w1v[31:1] | w2v[31:1] | w3v[31:1]);\n   for ( genvar j=1; j<32; j++ )  begin : gpr\n      rvdffe #(32) gprff (.*, .en(gpr_wr_en[j]), .din(gpr_in[j][31:0]), .dout(gpr_out[j][31:0]));\n   end : gpr\n\n// the read out\n   always_comb begin\n      rd0[31:0] = 32'b0;\n      rd1[31:0] = 32'b0;\n      rd2[31:0] = 32'b0;\n      rd3[31:0] = 32'b0;\n      w0v[31:1] = 31'b0;\n      w1v[31:1] = 31'b0;\n      w2v[31:1] = 31'b0;\n      w3v[31:1] = 31'b0;\n      gpr_in[31:1] = '0;\n\n      // GPR Read logic\n      for (int j=1; j<32; j++ )  begin\n         rd0[31:0] |= ({32{rden0 & (rtid0 == tid) & (raddr0[4:0]== 5'(j))}} & gpr_out[j][31:0]);\n         rd1[31:0] |= ({32{rden1 & (rtid1 == tid) & (raddr1[4:0]== 5'(j))}} & gpr_out[j][31:0]);\n         rd2[31:0] |= ({32{rden2 & (rtid2 == tid) & (raddr2[4:0]== 5'(j))}} & gpr_out[j][31:0]);\n         rd3[31:0] |= ({32{rden3 & (rtid3 == tid) & (raddr3[4:0]== 5'(j))}} & gpr_out[j][31:0]);\n     end\n\n     // GPR Write logic\n     for (int j=1; j<32; j++ )  begin\n         w0v[j]     = wen0  & (wtid0 == tid) & (waddr0[4:0]== 5'(j) );\n         w1v[j]     = wen1  & (wtid1 == tid) & (waddr1[4:0]== 5'(j) );\n         w2v[j]     = wen2  & (wtid2 == tid) & (waddr2[4:0]== 5'(j) );\n         w3v[j]     = wen3  & (wtid3 == tid) & (waddr3[4:0]== 5'(j) );\n         gpr_in[j]  = ({32{w0v[j]}} & wd0[31:0]) |\n                      ({32{w1v[j]}} & wd1[31:0]) |\n                      ({32{w2v[j]}} & wd2[31:0]) |\n                      ({32{w3v[j]}} & wd3[31:0]);\n     end\n   end // always_comb begin\n\n`ifdef RV_ASSERT_ON\n\n   logic write_collision_unused;\n\n   assign write_collision_unused = ( (w0v[31:1] == w1v[31:1]) & wen0 & wen1 & (wtid0==tid) & (wtid1==tid) ) |\n                                   ( (w0v[31:1] == w2v[31:1]) & wen0 & wen2 & (wtid0==tid) & (wtid2==tid) ) |\n                                   ( (w0v[31:1] == w3v[31:1]) & wen0 & wen3 & (wtid0==tid) & (wtid3==tid) ) |\n                                   ( (w1v[31:1] == w2v[31:1]) & wen1 & wen2 & (wtid1==tid) & (wtid2==tid) ) |\n                                   ( (w1v[31:1] == w3v[31:1]) & wen1 & wen3 & (wtid1==tid) & (wtid3==tid) ) |\n                                   ( (w2v[31:1] == w3v[31:1]) & wen2 & wen3 & (wtid2==tid) & (wtid3==tid ));\n\n   // asserting that no 2 ports will write to the same gpr simultaneously\n   assert_multiple_wen_to_same_gpr: assert #0 (~( write_collision_unused ) );\n\n`endif\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nmodule eh2_dec_ib_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n   input logic   active_clk,                    // free clk\n\n   input logic   tid,                           // thread id\n\n\n   input logic   dec_i0_tid_d,                  // tid selected for decode this cycle\n   input logic   dec_i1_tid_d,                  // tid selected for decode this cycle\n\n\n   input logic                 dbg_cmd_valid,  // valid dbg cmd\n   input logic                 dbg_cmd_tid,    // dbg tid\n\n   input logic                 dbg_cmd_write,  // dbg cmd is write\n   input logic [1:0]           dbg_cmd_type,   // dbg type\n   input logic [31:0]          dbg_cmd_addr,   // expand to 31:0\n\n   input logic exu_flush_final,                // all flush sources: primary/secondary alu's, trap\n\n   input logic dec_i1_cancel_e1,\n\n\n   input eh2_br_pkt_t i0_brp,                      // i0 branch packet from aligner\n   input eh2_br_pkt_t i1_brp,\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifu_i0_bp_index, // BP index\n   input logic [pt.BHT_GHR_SIZE-1:0] ifu_i0_bp_fghr, // BP FGHR\n   input logic [pt.BTB_BTAG_SIZE-1:0] ifu_i0_bp_btag, // BP tag\n   input logic [pt.BTB_TOFFSET_SIZE-1:0] ifu_i0_bp_toffset, // BP tag\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifu_i1_bp_index, // BP index\n   input logic [pt.BHT_GHR_SIZE-1:0] ifu_i1_bp_fghr, // BP FGHR\n   input logic [pt.BTB_BTAG_SIZE-1:0] ifu_i1_bp_btag, // BP tag\n   input logic [pt.BTB_TOFFSET_SIZE-1:0] ifu_i1_bp_toffset, // BP tag\n\n   input logic [$clog2(pt.BTB_SIZE)-1:0] ifu_i0_bp_fa_index,\n   input logic [$clog2(pt.BTB_SIZE)-1:0] ifu_i1_bp_fa_index,\n\n   input logic   ifu_i0_pc4,                   // i0 is 4B inst else 2B\n   input logic   ifu_i1_pc4,\n\n   input eh2_predecode_pkt_t  ifu_i0_predecode,\n   input eh2_predecode_pkt_t  ifu_i1_predecode,\n\n   input logic   ifu_i0_valid,                 // i0 valid from ifu\n   input logic   ifu_i1_valid,\n\n   input logic [1:0]  ifu_i0_icaf_type,        // Instruction 0 access fault type\n\n   input logic   ifu_i0_icaf,                  // i0 instruction access fault\n   input logic   ifu_i0_icaf_second,           // i0 has access fault on second 2B of 4B inst\n   input logic   ifu_i0_dbecc,                 // i0 double-bit error\n\n   input logic [31:0]  ifu_i0_instr,           // i0 instruction from the aligner\n   input logic [31:0]  ifu_i1_instr,\n\n   input logic [31:1]  ifu_i0_pc,              // i0 pc from the aligner\n   input logic [31:1] ifu_i1_pc,\n\n   input logic   dec_i0_decode_d,              // i0 decode\n   input logic   dec_i1_decode_d,\n\n\n   input logic   rst_l,                        // test stuff\n   input logic   clk,\n\n   output logic ib3_valid_d,               // ib3 valid\n   output logic ib2_valid_d,               // ib2 valid\n   output logic ib1_valid_d,               // ib1 valid\n   output logic ib0_valid_d,               // ib0 valid\n\n   output logic ib0_valid_in,              // ib0 valid cycle before decode\n   output logic ib0_lsu_in,                // lsu cycle before decode\n   output logic ib0_mul_in,                // mul cycle before decode\n   output logic ib0_i0_only_in,            // i0_only cycle before decode\n\n   output logic [31:0] i0_instr_d,         // i0 inst at decode\n   output logic [31:0] i1_instr_d,         // i1 inst at decode\n\n   output logic [31:1] i0_pc_d,            // i0 pc at decode\n   output logic [31:1] i1_pc_d,\n\n   output logic i0_pc4_d,                  // i0 is 4B inst else 2B\n   output logic i1_pc4_d,\n\n   output eh2_br_pkt_t i0_br_p,                 // i0 branch packet at decode\n   output eh2_br_pkt_t i1_br_p,\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i0_bp_index,   // i0 branch index\n   output logic [pt.BHT_GHR_SIZE-1:0]           i0_bp_fghr,    // BP FGHR\n   output logic [pt.BTB_BTAG_SIZE-1:0]          i0_bp_btag,    // BP tag\n   output logic [pt.BTB_TOFFSET_SIZE-1:0]       i0_bp_toffset, // BP tag\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i1_bp_index,   // i0 branch index\n   output logic [pt.BHT_GHR_SIZE-1:0]           i1_bp_fghr,    // BP FGHR\n   output logic [pt.BTB_BTAG_SIZE-1:0]          i1_bp_btag,    // BP tag\n   output logic [pt.BTB_TOFFSET_SIZE-1:0]       i1_bp_toffset, // BP tag\n\n   output logic [$clog2(pt.BTB_SIZE)-1:0] i0_bp_fa_index,\n\n   output logic i0_icaf_d,                 // i0 instruction access fault at decode\n   output logic i1_icaf_d,\n\n   output logic i0_icaf_second_d,          // i0 instruction access fault at decode for second 2B of 4B inst\n\n   output logic i0_dbecc_d,                // i0 double-bit error at decode\n   output logic i1_dbecc_d,\n   output logic debug_wdata_rs1_d,         // put debug write data onto rs1 source: machine is halted\n\n   output logic debug_fence_d,             // debug fence inst\n\n   output logic i0_debug_valid_d,          // i0 is valid debug inst\n\n   input logic [15:0] ifu_i0_cinst,        // 16b compressed inst from aligner\n   input logic [15:0] ifu_i1_cinst,\n\n   output logic [15:0] i0_cinst_d,         // 16b compress inst at decode\n   output logic [15:0] i1_cinst_d,\n\n   output eh2_predecode_pkt_t i0_predecode,\n   output eh2_predecode_pkt_t i1_predecode,\n\n   output logic [1:0] i0_icaf_type_d,\n\n   input  logic scan_mode\n\n   );\n\n   logic         flush_final;\n\n   logic [3:0]   ibval_in, ibval;\n\n   logic         write_i1_ib3, write_i0_ib3;\n   logic         write_i1_ib2, write_i0_ib2;\n   logic         write_i1_ib1, write_i0_ib1;\n   logic         write_i0_ib0;\n\n   logic         shift2, shift1, shift0;\n\n   logic         shift_ib1_ib0, shift_ib2_ib1, shift_ib3_ib2;\n   logic         shift_ib2_ib0;\n   logic         shift_ib3_ib1;\n\n\n   logic         ifu_i0_val, ifu_i1_val;\n   logic         debug_valid;\n   logic [4:0]   dreg;\n   logic [11:0]  dcsr;\n   logic [31:0]  ib0_debug_in;\n\n   logic         debug_read;\n   logic         debug_write;\n   logic         debug_read_gpr;\n   logic         debug_write_gpr;\n   logic         debug_read_csr;\n   logic         debug_write_csr;\n   logic [3:0]   ibvalid;\n\n   logic [3:0]   i0_wen;\n   logic [3:1]   i1_wen;\n   logic [3:0]   shift_ibval;\n   logic [3:0]   ibwrite;\n\n   logic         i1_cancel_e1;\n\n   logic                       debug_fence_in;\n   logic [1:0]   align_val;\n\n   localparam BRWIDTH = pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1+pt.BHT_GHR_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_TOFFSET_SIZE+($clog2(pt.BTB_SIZE) * pt.BTB_FULLYA);\n\n   logic [BRWIDTH-1:0]  bp3_in, bp3_final, bp3,\n                        bp2_in, bp2_final, bp2,\n                        bp1_in, bp1_final, bp1,\n                        bp0_in, bp0_final, bp0, bpsave;\n\n\n   logic [BRWIDTH-1:0] ifu_i0_brdata, ifu_i1_brdata;\n\n   logic                       i0_decode_d;\n   logic                       i1_decode_d;\n\n   eh2_ib_pkt_t ib3_in, ib3_final, ib3;\n   eh2_ib_pkt_t ib2_in, ib2_final, ib2;\n   eh2_ib_pkt_t ib1_in, ib1_final, ib1_final_in, ib1;\n   eh2_ib_pkt_t ib0_in, ib0_final, ib0_final_in, ib0, ib0_raw, ibsave;\n\n   logic                       debug_valid_d;\n   logic mul_in, lsu_in, i0_only_in;\n\n   eh2_ib_pkt_t ifu_i0_ibp, ifu_i1_ibp;\n\n   rvdff #(1) flush_upperff (.*, .clk(active_clk), .din(exu_flush_final), .dout(flush_final));\n\n\n   assign i1_cancel_e1 = dec_i1_cancel_e1;\n\n   assign ibvalid[3:0] = ibval[3:0] | i0_wen[3:0] | {i1_wen[3:1],1'b0};\n\n   assign ibval_in[3:0] = (({4{shift0}} & ((i1_cancel_e1) ? {ibval[2:0],1'b1} : ibvalid[3:0] )) |\n                           ({4{shift1}} & {1'b0, ibvalid[3:1]}) |\n                           ({4{shift2}} & {2'b0, ibvalid[3:2]})) & ~{4{flush_final}};\n\n   rvdff #(4) ibvalff (.*, .clk(active_clk), .din(ibval_in[3:0]), .dout(ibval[3:0]));\n\n\n   assign align_val[1:0] = {ifu_i1_valid,ifu_i0_valid};\n\n\n// only valid if there is room\n// no room if i1_cancel_e1\n\n   assign ifu_i0_val = align_val[0] & ~ibval[3] & ~i1_cancel_e1 & ~flush_final;\n   assign ifu_i1_val = align_val[1] & ~ibval[2] & ~i1_cancel_e1 & ~flush_final;\n\n\n   // the write signals take into account i1_cancel_e1\n   assign i0_wen[0] = ~ibval[0]             & (ifu_i0_val | debug_valid);\n   assign i0_wen[1] =  ibval[0] & ~ibval[1] & ifu_i0_val;\n   assign i0_wen[2] =  ibval[1] & ~ibval[2] & ifu_i0_val;\n   assign i0_wen[3] =  ibval[2] & ~ibval[3] & ifu_i0_val;\n\n   assign i1_wen[1] = ~ibval[0]             & ifu_i1_val;\n   assign i1_wen[2] =  ibval[0] & ~ibval[1] & ifu_i1_val;\n   assign i1_wen[3] =  ibval[1] & ~ibval[2] & ifu_i1_val;\n\n\n   assign ifu_i0_ibp.cinst         = ifu_i0_cinst;\n   assign ifu_i0_ibp.predecode     = ifu_i0_predecode;\n   assign ifu_i0_ibp.icaf_type     = ifu_i0_icaf_type;\n   assign ifu_i0_ibp.icaf_second       = ifu_i0_icaf_second;\n   assign ifu_i0_ibp.dbecc         = ifu_i0_dbecc;\n   assign ifu_i0_ibp.icaf          = ifu_i0_icaf;\n   assign ifu_i0_ibp.pc            = ifu_i0_pc;\n   assign ifu_i0_ibp.pc4           = ifu_i0_pc4;\n   assign ifu_i0_ibp.brp           = i0_brp;\n   assign ifu_i0_ibp.inst          = ifu_i0_instr;\n\n   assign ifu_i1_ibp.cinst         = ifu_i1_cinst;\n   assign ifu_i1_ibp.predecode     = ifu_i1_predecode;\n   assign ifu_i1_ibp.icaf_type     = '0;\n   assign ifu_i1_ibp.icaf_second       = '0;\n   assign ifu_i1_ibp.dbecc         = '0;\n   assign ifu_i1_ibp.icaf          = '0;\n   assign ifu_i1_ibp.pc            = ifu_i1_pc;\n   assign ifu_i1_ibp.pc4           = ifu_i1_pc4;\n   assign ifu_i1_ibp.brp           = i1_brp;\n   assign ifu_i1_ibp.inst          = ifu_i1_instr;\n\n\n// GPR accesses\n\n// put reg to read on rs1\n// read ->   or %x0,  %reg,%x0      {000000000000,reg[4:0],110000000110011}\n\n// put write data on rs1\n// write ->  or %reg, %x0, %x0      {00000000000000000110,reg[4:0],0110011}\n\n\n// CSR accesses\n// csr is of form rd, csr, rs1\n\n// read  -> csrrs %x0, %csr, %x0     {csr[11:0],00000010000001110011}\n\n// put write data on rs1\n// write -> csrrw %x0, %csr, %x0     {csr[11:0],00000001000001110011}\n\n// abstract memory command not done here\n   assign debug_valid = dbg_cmd_valid & (dbg_cmd_type[1:0] != 2'h2) & (dbg_cmd_tid == tid);\n\n\n   assign debug_read  = debug_valid & ~dbg_cmd_write;\n   assign debug_write = debug_valid &  dbg_cmd_write;\n\n   assign debug_read_gpr  = debug_read  & (dbg_cmd_type[1:0]==2'h0);\n   assign debug_write_gpr = debug_write & (dbg_cmd_type[1:0]==2'h0);\n   assign debug_read_csr  = debug_read  & (dbg_cmd_type[1:0]==2'h1);\n   assign debug_write_csr = debug_write & (dbg_cmd_type[1:0]==2'h1);\n\n   assign dreg[4:0]  = dbg_cmd_addr[4:0];\n   assign dcsr[11:0] = dbg_cmd_addr[11:0];\n\n\n   assign ib0_debug_in[31:0] = ({32{debug_read_gpr}}  & {12'b000000000000,dreg[4:0],15'b110000000110011}) |\n                               ({32{debug_write_gpr}} & {20'b00000000000000000110,dreg[4:0],7'b0110011}) |\n                               ({32{debug_read_csr}}  & {dcsr[11:0],20'b00000010000001110011}) |\n                               ({32{debug_write_csr}} & {dcsr[11:0],20'b00000001000001110011});\n\n\n   // for MT, need to hold this until thread decodes, other thread can be running\n   rvdffs #(1) debug_wdata_rs1ff (.*, .clk(active_clk), .en(ibwrite[0]), .din(debug_write_gpr | debug_write_csr), .dout(debug_wdata_rs1_d));\n\n\n   // special fence csr for use only in debug mode\n\n\n   assign debug_fence_in = debug_write_csr & (dcsr[11:0] == 12'h7c4);\n\n   rvdffs #(1) debug_fence_ff (.*,  .clk(active_clk), .en(ibwrite[0]), .din(debug_fence_in),  .dout(debug_fence_d));\n\n   rvdffs #(1) debug_valid_ff (.*,  .clk(active_clk), .en(ibwrite[0]), .din(debug_valid),     .dout(debug_valid_d));\n\n   assign i0_debug_valid_d = debug_valid_d & ibval[0];\n\n   assign ib3_in = ({$bits(eh2_ib_pkt_t){write_i0_ib3}} & ifu_i0_ibp) |\n                   ({$bits(eh2_ib_pkt_t){write_i1_ib3}} & ifu_i1_ibp);\n\n   assign ib3_final = (i1_cancel_e1) ? ib2 : ib3_in;\n\n   rvdffibie #(.WIDTH($bits(eh2_ib_pkt_t)),.LEFT(24),.PADLEFT(13),.MIDDLE(31),.PADRIGHT(47),.RIGHT(16)) ib3ff (.*, .en(ibwrite[3]), .din(ib3_final), .dout(ib3));\n\n   assign ib2_in = ({$bits(eh2_ib_pkt_t){write_i0_ib2}} & ifu_i0_ibp) |\n                   ({$bits(eh2_ib_pkt_t){write_i1_ib2}} & ifu_i1_ibp) |\n                   ({$bits(eh2_ib_pkt_t){shift_ib3_ib2}} & ib3);\n\n   assign ib2_final = (i1_cancel_e1) ? ib1 : ib2_in;\n\n   rvdffibie #(.WIDTH($bits(eh2_ib_pkt_t)),.LEFT(24),.PADLEFT(13),.MIDDLE(31),.PADRIGHT(47),.RIGHT(16)) ib2ff (.*, .en(ibwrite[2]), .din(ib2_final), .dout(ib2));\n\n   assign ib1_in = ({$bits(eh2_ib_pkt_t){write_i0_ib1}} & ifu_i0_ibp) |\n                   ({$bits(eh2_ib_pkt_t){write_i1_ib1}} & ifu_i1_ibp) |\n                   ({$bits(eh2_ib_pkt_t){shift_ib2_ib1}} & ib2) |\n                   ({$bits(eh2_ib_pkt_t){shift_ib3_ib1}} & ib3);\n\n   assign ib1_final = (i1_cancel_e1) ? ib0 : ib1_in;\n\n   assign ib1_final_in = (ibwrite[1]) ? ib1_final : ib1;\n\n   rvdffibie #(.WIDTH($bits(eh2_ib_pkt_t)),.LEFT(24),.PADLEFT(13),.MIDDLE(31),.PADRIGHT(47),.RIGHT(16)) ib1ff (.*, .en(ibwrite[1]), .din(ib1_final), .dout(ib1));\n\n   assign ib0_raw = ({$bits(eh2_ib_pkt_t){write_i0_ib0}} & ifu_i0_ibp) |\n                    ({$bits(eh2_ib_pkt_t){shift_ib1_ib0}} & ib1) |\n                    ({$bits(eh2_ib_pkt_t){shift_ib2_ib0}} & ib2);\n   always_comb begin\n      ib0_in = ib0_raw;\n\n      if (debug_valid) begin\n         ib0_in.inst = ib0_debug_in[31:0];\n         ib0_in.predecode = '0;\n         ib0_in.dbecc = '0;\n         ib0_in.icaf = '0;\n         ib0_in.icaf_second = '0;\n         ib0_in.brp.valid = '0;\n         ib0_in.brp.br_error = '0;\n         ib0_in.brp.br_start_error = '0;\n\n         ib0_in.predecode.legal1=1'b1;\n         ib0_in.predecode.i0_only=1'b1;\n\n      end\n   end\n\n   // timing optimization\n\n   assign lsu_in = (write_i0_ib0 & ifu_i0_predecode.lsu) |\n                   (shift_ib1_ib0 & ib1.predecode.lsu) |\n                   (shift_ib2_ib0 & ib2.predecode.lsu) |\n                   (~write_i0_ib0 & ~shift_ib1_ib0 & ~shift_ib2_ib0 & ib0.predecode.lsu);\n\n   assign mul_in = (write_i0_ib0 & ifu_i0_predecode.mul) |\n                   (shift_ib1_ib0 & ib1.predecode.mul) |\n                   (shift_ib2_ib0 & ib2.predecode.mul) |\n                   (~write_i0_ib0 & ~shift_ib1_ib0 & ~shift_ib2_ib0 & ib0.predecode.mul);\n\n   assign i0_only_in = (write_i0_ib0 & ifu_i0_predecode.i0_only) |\n                       (shift_ib1_ib0 & ib1.predecode.i0_only) |\n                       (shift_ib2_ib0 & ib2.predecode.i0_only) |\n                       (~write_i0_ib0 & ~shift_ib1_ib0 & ~shift_ib2_ib0 & ib0.predecode.i0_only);\n\n   // end timing\n\n   assign ib0_final = (i1_cancel_e1) ? ibsave : ib0_in;\n\n   assign ib0_final_in = (ibwrite[0]) ? ib0_final : ib0;\n\n   rvdffibie #(.WIDTH($bits(eh2_ib_pkt_t)),.LEFT(24),.PADLEFT(13),.MIDDLE(31),.PADRIGHT(47),.RIGHT(16)) ib0ff (.*, .en(ibwrite[0]), .din(ib0_final), .dout(ib0));\n\n   assign i0_cinst_d[15:0] = ib0.cinst;\n\n   assign i1_cinst_d[15:0] = ib1.cinst;\n\n   assign i0_predecode = ib0.predecode;\n   assign i1_predecode = ib1.predecode;\n\n   assign  ib0_lsu_in = lsu_in;\n   assign  ib0_mul_in = mul_in;\n   assign  ib0_i0_only_in = i0_only_in;\n\n   assign i0_icaf_type_d[1:0] = ib0.icaf_type;\n\n   assign i0_icaf_second_d = ib0.icaf_second;\n\n   assign i1_dbecc_d = ib1.dbecc;\n   assign i0_dbecc_d = ib0.dbecc;\n\n   assign i1_icaf_d = ib1.icaf;\n   assign i0_icaf_d = ib0.icaf;\n\n   assign i1_pc_d[31:1] = ib1.pc;\n   assign i0_pc_d[31:1] = ib0.pc;\n\n   assign i1_pc4_d = ib1.pc4;\n   assign i0_pc4_d = ib0.pc4;\n\n   assign i1_instr_d[31:0] = ib1.inst;\n   assign i0_instr_d[31:0] = ib0.inst;\n\n   assign i1_br_p = ib1.brp;\n   assign i0_br_p = ib0.brp;\n\n\n   assign ibwrite[3:0] = {  write_i0_ib3 | write_i1_ib3                                 | i1_cancel_e1,\n                            write_i0_ib2 | write_i1_ib2 | shift_ib3_ib2                 | i1_cancel_e1,\n                            write_i0_ib1 | write_i1_ib1 | shift_ib2_ib1 | shift_ib3_ib1 | i1_cancel_e1,\n                            write_i0_ib0 | shift_ib1_ib0 | shift_ib2_ib0                | i1_cancel_e1\n                            };\n\n\n   // branch prediction\n\n   if(pt.BTB_FULLYA) begin\n      assign ifu_i0_brdata = {ifu_i0_bp_fa_index, ifu_i0_bp_index, ifu_i0_bp_fghr, ifu_i0_bp_btag, ifu_i0_bp_toffset};\n      assign ifu_i1_brdata = {ifu_i1_bp_fa_index, ifu_i1_bp_index, ifu_i1_bp_fghr, ifu_i1_bp_btag, ifu_i1_bp_toffset};\n   end\n   else begin\n      assign ifu_i0_brdata = {ifu_i0_bp_index, ifu_i0_bp_fghr, ifu_i0_bp_btag, ifu_i0_bp_toffset};\n      assign ifu_i1_brdata = {ifu_i1_bp_index, ifu_i1_bp_fghr, ifu_i1_bp_btag, ifu_i1_bp_toffset};\n   end\n\n   assign bp3_in = ({BRWIDTH{write_i0_ib3}} & ifu_i0_brdata) |\n                   ({BRWIDTH{write_i1_ib3}} & ifu_i1_brdata);\n\n   assign bp3_final = (i1_cancel_e1) ? bp2 : bp3_in;\n\n   rvdffe #(BRWIDTH) bp3indexff (.*, .en(ibwrite[3]), .din(bp3_final), .dout(bp3));\n\n\n   assign bp2_in = ({BRWIDTH{write_i0_ib2}} & ifu_i0_brdata) |\n                   ({BRWIDTH{write_i1_ib2}} & ifu_i1_brdata) |\n                   ({BRWIDTH{shift_ib3_ib2}} & bp3);\n\n   assign bp2_final = (i1_cancel_e1) ? bp1 : bp2_in;\n\n\n   rvdffe #(BRWIDTH) bp2indexff (.*, .en(ibwrite[2]), .din(bp2_final), .dout(bp2));\n\n   assign bp1_in = ({BRWIDTH{write_i0_ib1}} & ifu_i0_brdata) |\n                   ({BRWIDTH{write_i1_ib1}} & ifu_i1_brdata) |\n                   ({BRWIDTH{shift_ib2_ib1}} & bp2) |\n                   ({BRWIDTH{shift_ib3_ib1}} & bp3);\n\n   assign bp1_final = (i1_cancel_e1) ? bp0 : bp1_in;\n\n   rvdffe #(BRWIDTH) bp1indexff (.*, .en(ibwrite[1]), .din(bp1_final), .dout(bp1));\n\n   assign bp0_in = ({BRWIDTH{write_i0_ib0}} & ifu_i0_brdata) |\n                   ({BRWIDTH{shift_ib1_ib0}} & bp1) |\n                   ({BRWIDTH{shift_ib2_ib0}} & bp2);\n\n   assign bp0_final = (i1_cancel_e1) ? bpsave : bp0_in;\n\n   rvdffe #(BRWIDTH) bp0indexff (.*, .en(ibwrite[0]), .din(bp0_final), .dout(bp0));\n\n   if(pt.BTB_FULLYA) begin\n      logic [$clog2(pt.BTB_SIZE)-1:0] i1_bp_fa_index_unused;\n      assign {i1_bp_fa_index_unused, i1_bp_index, i1_bp_fghr, i1_bp_btag, i1_bp_toffset} = bp1;\n      assign {i0_bp_fa_index, i0_bp_index, i0_bp_fghr, i0_bp_btag, i0_bp_toffset} = bp0;\n   end\n   else begin\n      assign {i1_bp_index, i1_bp_fghr, i1_bp_btag, i1_bp_toffset} = bp1;\n      assign {i0_bp_index, i0_bp_fghr, i0_bp_btag, i0_bp_toffset} = bp0;\n      assign i0_bp_fa_index = '0;\n   end\n\n\n   // decode, align get the raw valid signals\n   // aligner gets ib3,ib2 to make decisions on\n   assign ib3_valid_d = ibval[3];\n   assign ib2_valid_d = ibval[2];\n   assign ib1_valid_d = ibval[1];\n   assign ib0_valid_d = ibval[0];\n\n   assign ib0_valid_in = ibval_in[0];\n\n   assign i0_decode_d = dec_i0_decode_d & (tid == dec_i0_tid_d);\n   assign i1_decode_d = dec_i1_decode_d & (tid == dec_i1_tid_d);\n\n   assign shift1 = i0_decode_d ^ i1_decode_d;\n\n   assign shift2 = i0_decode_d & i1_decode_d;\n\n   assign shift0 = ~shift1 & ~shift2;\n\n// save off prior i1 on shift2\n\n   rvdffibie #(.WIDTH($bits(eh2_ib_pkt_t)),.LEFT(24),.PADLEFT(13),.MIDDLE(31),.PADRIGHT(47),.RIGHT(16)) ibsaveff (.*, .en(shift2), .din(ib1),    .dout(ibsave));\n\n   rvdffe #(BRWIDTH)         bpsaveindexff (.*, .en(shift2), .din(bp1),  .dout(bpsave));\n\n\n   // compute shifted ib valids to determine where to write\n  assign shift_ibval[3:0] = ({4{shift1}} & {1'b0, ibval[3:1] }) |\n                             ({4{shift2}} & {2'b0, ibval[3:2]}) |\n                             ({4{shift0}} & ibval[3:0]);\n\n   assign write_i0_ib0 = ~shift_ibval[0]                & (ifu_i0_val | debug_valid);\n   assign write_i0_ib1 =  shift_ibval[0] & ~shift_ibval[1] & ifu_i0_val;\n   assign write_i0_ib2 =  shift_ibval[1] & ~shift_ibval[2] & ifu_i0_val;\n   assign"}
{"text": " write_i0_ib3 =  shift_ibval[2] & ~shift_ibval[3] & ifu_i0_val;\n\n   assign write_i1_ib1 = ~shift_ibval[0]                & ifu_i1_val;\n   assign write_i1_ib2 =  shift_ibval[0] & ~shift_ibval[1] & ifu_i1_val;\n   assign write_i1_ib3 =  shift_ibval[1] & ~shift_ibval[2] & ifu_i1_val;\n\n\n   assign shift_ib1_ib0 = shift1 & ibval[1];\n   assign shift_ib2_ib1 = shift1 & ibval[2];\n   assign shift_ib3_ib2 = shift1 & ibval[3];\n\n   assign shift_ib2_ib0 = shift2 & ibval[2];\n   assign shift_ib3_ib1 = shift2 & ibval[3];\n\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2019 Western Digital Corporation or it's affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n//********************************************************************************\n// eh2_dec_tlu_ctl.sv\n//\n//\n// Function: CSRs, flushing, exceptions, interrupts\n// Comments:\n//\n//********************************************************************************\n\nmodule eh2_dec_tlu_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n   input logic clk,\n   input logic free_clk,\n   input logic active_clk,\n   input logic free_l2clk,\n   input logic rst_l,\n   input logic scan_mode,\n   input logic mytid, // tid of this instance\n\n\n   input logic tlu_select_tid, // selected tid for fast int\n\n   input logic dec_tlu_dec_clk_override,\n\n   input logic [31:1] rst_vec, // reset vector, from core pins\n   input logic        nmi_int_sync, // nmi pin\n   input logic [31:1] nmi_vec, // nmi vector\n   input logic  i_cpu_halt_req,    // Asynchronous Halt request to CPU\n   input logic  i_cpu_run_req,     // Asynchronous Restart request to CPU\n   input logic mhartstart_csr,    // Start valid\n\n   input logic lsu_fastint_stall_any,   // needed by lsu for 2nd pass of dma with ecc correction, stall next cycle\n\n   // perf counter inputs\n   input logic [1:0] ifu_pmu_instr_aligned,   // aligned instructions\n   input logic       ifu_pmu_align_stall,  // aligner stalled\n   input logic       ifu_pmu_fetch_stall, // fetch unit stalled\n   input logic       ifu_pmu_ic_miss, // icache miss\n   input logic       ifu_pmu_ic_hit, // icache hit\n   input logic       ifu_pmu_bus_error, // Instruction side bus error\n   input logic       ifu_pmu_bus_busy, // Instruction side bus busy\n   input logic       ifu_pmu_bus_trxn, // Instruction side bus transaction\n   input logic [1:0] dec_pmu_instr_decoded, // decoded instructions\n   input logic       dec_pmu_decode_stall, // decode stall\n   input logic       dec_pmu_presync_stall, // decode stall due to presync'd inst\n   input logic       dec_pmu_postsync_stall,// decode stall due to postsync'd inst\n   input logic       lsu_store_stall_any,    // SB or WB is full, stall decode\n   input logic       dma_dccm_stall_any,     // DMA stall of lsu\n   input logic       dma_iccm_stall_any,     // DMA stall of ifu\n   input logic       exu_pmu_i0_br_misp,     // pipe 0 branch misp\n   input logic       exu_pmu_i0_br_ataken,   // pipe 0 branch actual taken\n   input logic       exu_pmu_i0_pc4,         // pipe 0 4 byte branch\n   input logic       exu_pmu_i1_br_misp,     // pipe 1 branch misp\n   input logic       exu_pmu_i1_br_ataken,   // pipe 1 branch actual taken\n   input logic       exu_pmu_i1_pc4,         // pipe 1 4 byte branch\n   input logic       lsu_pmu_bus_trxn,       // D side bus transaction\n   input logic       lsu_pmu_bus_misaligned, // D side bus misaligned\n   input logic       lsu_pmu_bus_error,      // D side bus error\n   input logic       lsu_pmu_bus_busy,       // D side bus busy\n   input logic       lsu_pmu_load_external_dc3, // D side bus load\n   input logic       lsu_pmu_store_external_dc3, // D side bus store\n   input logic       dma_pmu_dccm_read,          // DMA DCCM read\n   input logic       dma_pmu_dccm_write,         // DMA DCCM write\n   input logic       dma_pmu_any_read,           // DMA read\n   input logic       dma_pmu_any_write,          // DMA write\n\n   input logic dec_tlu_br0_error_e4,\n   input logic dec_tlu_br0_start_error_e4,\n   input logic dec_tlu_br1_error_e4,\n   input logic dec_tlu_br1_start_error_e4,\n\n   input logic [31:1] lsu_fir_addr, // Fast int address\n   input logic [1:0]  lsu_fir_error, // Fast int lookup error\n\n   input logic mice_ce_req,\n   input logic miccme_ce_req,\n   input logic mdccme_ce_req,\n\n   input logic dec_tlu_trace_disable,\n\n   input logic [5:0] mfdht, // halt timeout threshold\n\n   input    eh2_lsu_error_pkt_t lsu_error_pkt_dc3, // lsu precise exception/error packet\n\n   input logic dec_pause_state, // Pause counter not zero\n   input logic         lsu_imprecise_error_store_any,      // store bus error\n   input logic         lsu_imprecise_error_load_any,      // store bus error\n   input logic [31:0]  lsu_imprecise_error_addr_any, // store bus error address\n\n   input logic        dec_i0_csr_wen_unq_d,       // valid csr with write - for csr legal\n   input logic        dec_i0_csr_any_unq_d,       // valid csr - for csr legal\n   input logic        dec_i0_csr_wen_wb,      // csr write enable at wb\n   input logic [11:0] dec_i0_csr_rdaddr_d,      // read address for csr\n   input logic [11:0] dec_i0_csr_wraddr_wb,      // write address for csr\n   input logic [31:0] dec_i0_csr_wrdata_wb,   // csr write data at wb\n   input logic        dec_i0_csr_is_mcpc_e4,     // csr address is to MCPC\n\n   input logic        dec_csr_stall_int_ff, // csr is mie/mstatus\n\n   input eh2_csr_tlu_pkt_t tlu_i0_csr_pkt_d, // csr decodes for i0\n\n   input logic dec_tlu_i0_valid_e4, // pipe 0 op at e4 is valid\n   input logic dec_tlu_i1_valid_e4, // pipe 1 op at e4 is valid\n\n   input logic [31:1] exu_npc_e4, // for NPC tracking\n   input logic exu_i0_flush_lower_e4,       // pipe 0 branch mp flush\n   input logic exu_i1_flush_lower_e4,       // pipe 1 branch mp flush\n   input logic [31:1] exu_i0_flush_path_e4, // pipe 0 correct path for mp, merge with lower path\n   input logic [31:1] exu_i1_flush_path_e4, // pipe 1 correct path for mp, merge with lower path\n\n   input logic [31:1] dec_tlu_i0_pc_e4, // for PC/NPC tracking\n   input logic [31:1] dec_tlu_i1_pc_e4, // for PC/NPC tracking\n\n   input eh2_trap_pkt_t dec_tlu_packet_e4, // exceptions known at decode\n\n   input logic [31:0] dec_illegal_inst, // For mtval\n   input logic        dec_i0_decode_d,  // decode valid, used for clean icache diagnostics\n\n   // branch info from pipe0 for errors or counter updates\n   input logic        exu_i0_br_error_e4, // error\n   input logic        exu_i0_br_start_error_e4, // start error\n   input logic        exu_i0_br_mp_e4, // mispredict\n   // branch info from pipe1 for errors or counter updates\n   input logic        exu_i1_br_error_e4, // error\n   input logic        exu_i1_br_start_error_e4, // start error\n\n   input  logic dbg_halt_req, // DM requests a halt\n   input  logic dbg_resume_req, // DM requests a resume\n   input  logic ifu_miss_state_idle, // I-side miss buffer empty\n   input  logic lsu_idle_any, // lsu is idle\n   input  logic dec_div_active, // oop divide is active\n\n   input logic  ifu_ic_error_start,     // IC single bit error\n   input logic  ifu_iccm_rd_ecc_single_err, // ICCM single bit error\n\n   input logic [70:0] ifu_ic_debug_rd_data, // diagnostic icache read data\n   input logic ifu_ic_debug_rd_data_valid, // diagnostic icache read data valid\n\n   input logic [7:0] pic_claimid, // pic claimid for csr\n   input logic [3:0] pic_pl, // pic priv level for csr\n   input logic       mhwakeup, // high priority external int, wakeup if halted\n\n   input logic mexintpend, // external interrupt pending\n   input logic timer_int, // timer interrupt pending\n   input logic soft_int, // software interrupt pending\n\n   input logic [31:4]     core_id, // Core ID\n\n   input logic mpc_debug_halt_req, // Async halt request\n   input logic mpc_debug_run_req, // Async run request\n   input logic mpc_reset_run_req, // Run/halt after reset\n\n   // Debug start\n   output logic dec_dbg_cmd_done, // abstract command done\n   output logic dec_dbg_cmd_fail, // abstract command failed\n   output logic dec_tlu_flush_noredir_wb , // Tell fetch to idle on this flush\n   output logic dec_tlu_dbg_halted, // Core is halted and ready for debug command\n   output logic dec_tlu_debug_mode, // Core is in debug mode\n   output logic dec_tlu_resume_ack, // Resume acknowledge\n   output logic dec_tlu_debug_stall, // stall decode while waiting on core to empty\n   output logic dec_tlu_flush_leak_one_wb, // single step\n   output logic dec_tlu_flush_err_wb, // iside perr/ecc rfpc\n   output logic tlu_mpc_halted_only, // Core is halted only due to MPC\n   output eh2_trigger_pkt_t  [3:0] tlu_trigger_pkt_any, // trigger info for trigger blocks\n   output eh2_cache_debug_pkt_t dec_tlu_ic_diag_pkt, // packet of DICAWICS, DICAD0/1, DICAGO info for icache diagnostics\n\n   output logic tlu_fast_ext_int_ready, // ready for fast int arb\n\n   output logic dec_tlu_force_halt, // halt has been forced\n   // Debug end\n\n   output logic dec_tlu_core_empty,\n\n   output logic dec_tlu_flush_extint, // fast ext int started\n   output logic [31:2] dec_tlu_meihap, // meihap for fast int\n\n   output logic o_cpu_halt_status, // PMU interface, halted\n   output logic o_cpu_halt_ack, // halt req ack\n   output logic o_cpu_run_ack, // run req ack\n   output logic o_debug_mode_status, // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n\n   // external MPC halt/run interface\n   output logic mpc_debug_halt_ack, // Halt ack\n   output logic mpc_debug_run_ack, // Run ack\n   output logic debug_brkpt_status, // debug breakpoint\n\n   output logic [3:0] tlu_meicurpl, // to PIC\n   output logic [3:0] tlu_meipt, // to PIC\n\n   output logic [31:0] csr_rddata_d,      // csr read data at wb\n\n   output logic tlu_i0_kill_writeb_wb,    // I0 is flushed, don't writeback any results to arch state\n   output logic tlu_i1_kill_writeb_wb,    // I1 is flushed, don't writeback any results to arch state\n\n   output logic dec_tlu_flush_lower_wb,       // commit has a flush (exception, int, mispredict at e4)\n   output logic dec_tlu_flush_mp_wb,          // flush is due to e4 mp\n   output logic [31:1] dec_tlu_flush_path_wb, // flush pc\n\n   output logic dec_tlu_flush_lower_wb1,\n   output logic dec_tlu_fence_i_wb,           // flush is a fence_i rfnpc, flush icache\n\n   output logic tlu_i0_commit_cmt,        // goes to IFU for commit 1 instruction in the FSM\n\n   output logic tlu_wr_pause_wb,           // CSR write to pause reg is at WB.\n   output logic tlu_flush_pause_wb,        // Flush is due to pause\n\n   output logic tlu_lr_reset_wb, // Reset the reservation on certain events\n\n   output logic tlu_i0_valid_wb1,  // pipe 0 valid\n   output logic tlu_i1_valid_wb1,  // pipe 1 valid\n   output logic tlu_i0_exc_valid_wb1, // pipe 0 exception valid\n   output logic tlu_i1_exc_valid_wb1, // pipe 1 exception valid\n   output logic tlu_int_valid_wb1, // pipe 2 int valid\n\n   output logic [4:0] tlu_exc_cause_wb1, // exception or int cause\n   output logic [31:0] tlu_mtval_wb1, // MTVAL value\n\n   output logic [1:0] tlu_perfcnt0, // toggles when pipe0 perf counter 0 has an event inc\n   output logic [1:0] tlu_perfcnt1, // toggles when pipe0 perf counter 1 has an event inc\n   output logic [1:0] tlu_perfcnt2, // toggles when pipe0 perf counter 2 has an event inc\n   output logic [1:0] tlu_perfcnt3, // toggles when pipe0 perf counter 3 has an event inc\n\n   output logic tlu_btb_write_kill, // kill writes until forward progress is made\n\n   output logic ic_perr_wb,\n   output logic iccm_sbecc_wb,\n   output logic allow_dbg_halt_csr_write,\n   output logic dec_i0_csr_wen_wb_mod // don't write csr if trigger kills it\n   )\n;\n\n   logic         clk_override, e4e5_int_clk, nmi_fir_type, nmi_lsu_load_type, nmi_lsu_store_type, nmi_int_detected_f, nmi_lsu_load_type_f,\n                 nmi_fir_type_f, nmi_lsu_store_type_f, dbg_cmd_done_ns, i_cpu_run_req_d1_raw, debug_mode_status,\n                 i0_mp_e4, i1_mp_e4, sel_npc_e4, sel_npc_wb, ce_int, mtval_capture_lsu_wb, wr_mdeau_wb,\n                 nmi_in_debug_mode, dpc_capture_npc, dpc_capture_pc, tdata_load, tdata_opcode, tdata_action, perfcnt_halted,\n                 tlu_i0_valid_e4, tlu_i1_valid_e4, tdata_chain, tdata_kill_write;\n\n   eh2_trap_pkt_t  tlu_packet_e4;\n   eh2_lsu_error_pkt_t lsu_error_pkt_e4, lsu_error_pkt_dc4;\n   eh2_csr_tlu_pkt_t csr_rd;\n\n   logic reset_delayed, reset_detect, reset_detected, reset_allowed, reset_delayed_f;\n   logic wr_mstatus_wb, wr_mtvec_wb, wr_mie_wb, wr_mcyclel_wb, wr_mcycleh_wb,\n         wr_minstretl_wb, wr_minstreth_wb, wr_mscratch_wb, wr_mepc_wb, wr_mcause_wb, wr_mscause_wb, wr_mtval_wb,\n         wr_meihap_wb, wr_meicurpl_wb, wr_meipt_wb, wr_dcsr_wb, wr_mfdhs_wb,\n         wr_dpc_wb, wr_meicidpl_wb, wr_meivt_wb, wr_meicpct_wb,\n         wr_mhpme3_wb, wr_mhpme4_wb, wr_mhpme5_wb, wr_mhpme6_wb;\n   logic wr_mpmc_wb;\n   logic [1:1] mpmc_b_ns, mpmc, mpmc_b;\n   logic [1:0] mfdhs_ns, mfdhs;\n   logic [31:0] force_halt_ctr, force_halt_ctr_f;\n   logic        force_halt;\n   logic set_mie_pmu_fw_halt;\n   logic wr_mcountinhibit_wb;\n   logic [6:0] mcountinhibit;\n   logic wr_mtsel_wb, wr_mtdata1_t0_wb, wr_mtdata1_t1_wb, wr_mtdata1_t2_wb, wr_mtdata1_t3_wb, wr_mtdata2_t0_wb, wr_mtdata2_t1_wb, wr_mtdata2_t2_wb, wr_mtdata2_t3_wb;\n   logic [31:0] mtdata2_t0, mtdata2_t1, mtdata2_t2, mtdata2_t3, mtdata2_tsel_out, mtdata1_tsel_out;\n   logic [9:0]  mtdata1_t0_ns, mtdata1_t0, mtdata1_t1_ns, mtdata1_t1, mtdata1_t2_ns, mtdata1_t2, mtdata1_t3_ns, mtdata1_t3;\n   logic [9:0] tdata_wrdata_wb;\n   logic [1:0] mtsel_ns, mtsel;\n   logic tlu_i0_kill_writeb_e4, tlu_i1_kill_writeb_e4;\n   logic [1:0]  mstatus_ns, mstatus;\n   logic mstatus_mie_ns;\n   logic [30:0] mtvec_ns, mtvec;\n   logic [15:2] dcsr_ns, dcsr;\n   logic [5:0] mip_ns, mip;\n   logic [5:0] mie_ns, mie;\n   logic [31:0] mcyclel_ns, mcyclel;\n   logic [31:0] mcycleh_ns, mcycleh;\n   logic [31:0] minstretl_ns, minstretl;\n   logic [31:0] minstreth_ns, minstreth;\n   logic [31:0] mscratch;\n   logic [31:0] mhpmc3, mhpmc3_ns, mhpmc4, mhpmc4_ns, mhpmc5, mhpmc5_ns, mhpmc6, mhpmc6_ns;\n   logic [31:0] mhpmc3h, mhpmc3h_ns, mhpmc4h, mhpmc4h_ns, mhpmc5h, mhpmc5h_ns, mhpmc6h, mhpmc6h_ns;\n   logic [9:0]  mhpme3, mhpme4, mhpme5, mhpme6;\n   logic [9:2] meihap;\n   logic [31:10] meivt;\n   logic [3:0] meicurpl_ns, meicurpl;\n   logic [3:0] meicidpl_ns, meicidpl;\n   logic [3:0] meipt_ns, meipt;\n   logic [31:0] mdseac;\n   logic mdseac_locked_ns, mdseac_locked_f, mdseac_en, nmi_lsu_detected;\n   logic        wr_dicawics_wb, wr_dicad0_wb, wr_dicad0h_wb, wr_dicad1_wb;\n   logic [31:0] dicad0_ns, dicad0, dicad0h_ns, dicad0h, dicad1;\n   logic [31:1] mepc_ns, mepc;\n   logic [31:1] dpc_ns, dpc;\n   logic [31:0] mcause_ns, mcause;\n   logic [3:0] mscause_ns, mscause, mscause_type, ifu_mscause;\n   logic [31:0] mtval_ns, mtval;\n   logic       mret_wb;\n   logic dec_pause_state_f, tlu_wr_pause_wb_f, pause_expired_e4, pause_expired_wb;\n   logic       tlu_flush_lower_e4, tlu_flush_lower_wb, tlu_flush_lower_wb1, tlu_flush_mp_e4;\n   logic [31:1] tlu_flush_path_e4, tlu_flush_path_wb;\n   logic i0_valid_wb, i1_valid_wb;\n   logic [5:1] vectored_cause;\n   logic [31:2] vectored_path;\n   logic [31:1] interrupt_path;\n   logic [16:0] dicawics_ns, dicawics;\n   logic [6:0]  dicad1_ns, dicad1_raw;\n\n   logic        ebreak_e4, ebreak_to_debug_mode_e4, ecall_e4, illegal_e4, illegal_e4_qual, mret_e4, inst_acc_e4, fence_i_e4,\n                ic_perr_e4, iccm_sbecc_e4, ebreak_to_debug_mode_wb, kill_ebreak_count_wb, inst_acc_second_e4;\n   logic        ebreak_wb, ecall_wb, illegal_wb,  illegal_raw_wb, inst_acc_wb, inst_acc_second_wb, fence_i_wb;\n   logic ce_int_ready, ext_int_ready, timer_int_ready, soft_int_ready, int_timer0_int_ready, int_timer1_int_ready, mhwakeup_ready,\n         take_ext_int, take_ce_int, take_timer_int, take_soft_int, take_int_timer0_int, take_int_timer1_int, take_nmi, take_nmi_wb, int_timer0_int_possible, int_timer1_int_possible;\n   logic i0_exception_valid_e4, interrupt_valid, i0_exception_valid_wb, interrupt_valid_wb, exc_or_int_valid, exc_or_int_valid_wb;\n   logic synchronous_flush_e4;\n   logic [4:0] exc_cause_e4, exc_cause_wb;\n   logic [1:0] lsu_fir_error_d1;\n   logic        mcyclel_cout, mcyclel_cout_f, mcyclela_cout;\n   logic [31:0] mcyclel_inc;\n   logic        mcycleh_cout_nc;\n   logic [31:0] mcycleh_inc;\n   logic        minstretl_cout, minstretl_cout_f, minstret_enable, minstretl_couta, minstretl_cout_ns;\n   logic [31:0] minstretl_inc, minstretl_read;\n   logic        minstreth_cout_nc;\n   logic [31:0] minstreth_inc, minstreth_read;\n   logic [31:1] pc_e4, pc_wb, npc_e4, npc_wb;\n   logic        mtval_capture_pc_wb, mtval_capture_inst_wb, mtval_clear_wb, mtval_capture_pc_plus2_wb;\n   logic rfpc_i0_e4, rfpc_i1_e4;\n   logic lsu_i0_rfnpc_dc4, lsu_i1_rfnpc_dc4;\n   logic lsu_i0_exc_dc4, lsu_i1_exc_dc4, lsu_i0_exc_dc4_raw, lsu_i1_exc_dc4_raw, lsu_exc_ma_dc4, lsu_exc_acc_dc4, lsu_exc_st_dc4,\n         lsu_exc_valid_e4, lsu_exc_valid_e4_raw, lsu_exc_valid_wb, lsu_i0_exc_wb,\n         block_interrupts ;\n   logic tlu_i1_commit_cmt;\n\n   logic request_debug_mode_e4, request_debug_mode_wb, request_debug_mode_done, request_debug_mode_done_f;\n\n    logic take_halt, halt_taken, halt_taken_f, internal_dbg_halt_mode, dbg_tlu_halted_f, take_reset,\n         dbg_tlu_halted, core_empty, lsu_idle_any_f, ifu_miss_state_idle_f, resume_ack_ns,\n         debug_halt_req_f, debug_resume_req_f_raw, debug_resume_req_f, enter_debug_halt_req, dcsr_single_step_done, dcsr_single_step_done_f,\n         debug_halt_req_d1, debug_halt_req_ns, dcsr_single_step_running, dcsr_single_step_running_f, internal_dbg_halt_timers;\n\n logic [3:0] i0_trigger_e4, i1_trigger_e4, trigger_action, trigger_enabled,\n               i0_trigger_chain_masked_e4, i1_trigger_chain_masked_e4;\n   logic [2:0] trigger_chain;\n   logic       i0_trigger_hit_e4, i0_trigger_hit_raw_e4, i0_trigger_action_e4,\n               trigger_hit_e4, trigger_hit_wb, i0_trigger_hit_wb,\n               mepc_trigger_hit_sel_pc_e4, i0_trigger_set_hit_e4, i1_trigger_set_hit_e4,\n               mepc_trigger_hit_sel_pc_wb;\n   logic       i1_trigger_hit_e4, i1_trigger_hit_raw_e4, i1_trigger_action_e4;\n   logic [3:0] update_hit_bit_e4, update_hit_bit_wb, i0_iside_trigger_has_pri_e4, i1_iside_trigger_has_pri_e4,\n               i0_lsu_trigger_has_pri_e4, i1_lsu_trigger_has_pri_e4;\n   logic cpu_halt_status, cpu_halt_ack, cpu_run_ack, ext_halt_pulse, i_cpu_halt_req_d1, i_cpu_run_req_d1;\n\n   logic inst_acc_e4_raw, trigger_hit_dmode_e4, trigger_hit_dmode_wb, trigger_hit_for_dscr_cause_wb;\n   logic i_cpu_halt_req_sync_qual, i_cpu_run_req_sync_qual, pmu_fw_halt_req_ns, pmu_fw_halt_req_f, int_timer_stalled,\n         fw_halt_req, enter_pmu_fw_halt_req, pmu_fw_tlu_halted, pmu_fw_tlu_halted_f, internal_pmu_fw_halt_mode,\n         internal_pmu_fw_halt_mode_f, int_timer0_int_hold, int_timer1_int_hold, int_timer0_int_hold_f, int_timer1_int_hold_f;\n   logic nmi_int_delayed, nmi_int_detected;\n   logic [3:0] trigger_execute, trigger_data, trigger_store;\n\n   // internal timer, isolated for size reasons\n   logic [31:0] dec_timer_rddata_d;\n   logic  dec_timer_read_d;\n   logic       dec_timer_t0_pulse, dec_timer_t1_pulse;\n   logic dec_tlu_pmu_fw_halted;\n\n   // new from lx2, review\n   logic mpc_run_state_ns, debug_brkpt_status_ns, mpc_debug_halt_ack_ns, mpc_debug_run_ack_ns, dbg_halt_state_ns, dbg_run_state_ns,\n         dbg_halt_state_f, mpc_debug_halt_req_sync_f, mpc_debug_run_req_sync_f, mpc_halt_state_f, mpc_halt_state_ns, mpc_run_state_f, debug_brkpt_status_f,\n         mpc_debug_halt_ack_f, mpc_debug_run_ack_f, dbg_run_state_f, mpc_debug_halt_req_sync_pulse,\n         mpc_debug_run_req_sync_pulse, debug_brkpt_valid, debug_halt_req, debug_resume_req, dec_tlu_mpc_halted_only_ns;\n   logic take_ext_int_start, ext_int_freeze, take_ext_int_start_d1, take_ext_int_start_d2, ignore_ext_int_due_to_lsu_stall,\n         take_ext_int_start_d3, take_ext_int_start_d4, take_ext_int_start_d5, take_ext_int_start_d6, ext_int_freeze_d1;\n   logic mcause_sel_nmi_store, mcause_sel_nmi_load, mcause_sel_nmi_ext;\n   logic [1:0] mcaus"}
{"text": "e_fir_error_type;\n   logic dbg_halt_req_held_ns, dbg_halt_req_held, dbg_halt_req_final;\n   logic i0tid_wb, iccm_repair_state_ns, iccm_repair_state_d1, iccm_repair_state_rfnpc;\n   logic [3:0][1:0] mhpmc_inc_e4, mhpmc_inc_wb;\n   logic [3:0][9:0] mhpme_vec;\n   logic            mhpmc3_wr_en0, mhpmc3_wr_en1, mhpmc3_wr_en;\n   logic            mhpmc4_wr_en0, mhpmc4_wr_en1, mhpmc4_wr_en;\n   logic            mhpmc5_wr_en0, mhpmc5_wr_en1, mhpmc5_wr_en;\n   logic            mhpmc6_wr_en0, mhpmc6_wr_en1, mhpmc6_wr_en;\n   logic            mhpmc3h_wr_en0, mhpmc3h_wr_en;\n   logic            mhpmc4h_wr_en0, mhpmc4h_wr_en;\n   logic            mhpmc5h_wr_en0, mhpmc5h_wr_en;\n   logic            mhpmc6h_wr_en0, mhpmc6h_wr_en;\n   logic            tlu_commit_lsu_op_e4, zero_event_wb;\n   logic [63:0]     mhpmc3_incr, mhpmc4_incr, mhpmc5_incr, mhpmc6_incr;\n   logic [9:0] event_wb;\n   logic [3:0] perfcnt_during_sleep;\n\n   logic icache_rd_valid, icache_wr_valid, icache_rd_valid_f, icache_wr_valid_f;\n\n   logic [4:0] tlu_exc_cause_wb1_raw, tlu_exc_cause_wb2;\n   logic tlu_int_valid_wb2;\n\nif (pt.ICACHE_ECC == 1) begin\n   logic [3:0] dicad1_raw, dicad1_ns;\nend\nelse begin\n   logic [6:0] dicad1_raw, dicad1_ns;\nend\n   logic enter_debug_halt_req_le, dcsr_cause_upgradeable;\n   logic [8:6] dcsr_cause;\n   logic pc0_valid_e4, pc1_valid_e4;\n   logic sel_exu_npc_e4, sel_flush_npc_e4, sel_i0_npc_e4;\n   logic minstret_enable_f;\n   logic i0_valid_no_ebreak_ecall_wb;\n   logic mcyclel_cout_in;\n   logic [3:0] lsu_error_mscause_wb;\n   logic [1:0] icaf_type_wb;\n   logic [31:0] lsu_error_pkt_addr_dc4, lsu_error_pkt_addr_wb;\n   logic        iside_oop_rfpc;\n   logic i0_problem_kills_i1_trigger;\n   logic lsu_pmu_load_external_dc4, lsu_pmu_store_external_dc4;\n   logic e4_valid, e5_valid, e4e5_valid, internal_dbg_halt_mode_f, internal_dbg_halt_mode_f2, internal_dbg_halt_mode_f3;\n   logic lsu_e3_e4_clk, lsu_e4_e5_clk;\n   logic csr_wr_clk;\n   logic timer_int_sync, soft_int_sync, i_cpu_halt_req_sync, i_cpu_run_req_sync, mpc_debug_halt_req_sync, mpc_debug_run_req_sync, mpc_debug_halt_req_sync_raw;\n   logic take_halt_f, ifu_ic_error_start_d1, ifu_iccm_rd_ecc_single_err_d1, sel_fir_addr, sel_hold_npc_e4, tlu_dcsr_ss;\n   logic tlu_int_valid_wb1_raw;\n   logic dbg_halt_req_no_start, dbg_halt_req_no_start_f;\n\n   logic tlu_btb_write_kill_ns;\n\n     eh2_dec_timer_ctl #(.pt(pt)) int_timers(.*);\n   // end of internal timers\n\n   assign clk_override           = dec_tlu_dec_clk_override;\n   // Async inputs to the core have to be sync'd to the core clock.\n   rvsyncss #(6) syncro_ff(.*,\n                           .clk(free_clk),\n                           .din ({timer_int,      soft_int,      i_cpu_halt_req,      i_cpu_run_req,      mpc_debug_halt_req,          mpc_debug_run_req}),\n                           .dout({timer_int_sync, soft_int_sync, i_cpu_halt_req_sync, i_cpu_run_req_sync, mpc_debug_halt_req_sync_raw, mpc_debug_run_req_sync}));\n\n\n   always_comb begin\n      tlu_packet_e4 = dec_tlu_packet_e4;\n      lsu_error_pkt_e4 = lsu_error_pkt_dc4;\n      tlu_i0_valid_e4 = dec_tlu_i0_valid_e4;\n      tlu_i1_valid_e4 = dec_tlu_i1_valid_e4;\n\n      if(dec_tlu_packet_e4.i0tid != mytid) begin\n         tlu_packet_e4.i0legal = 'b0;\n         tlu_packet_e4.i0icaf = 'b0;\n         tlu_packet_e4.i0icaf_type = 'b0;\n         tlu_packet_e4.i0icaf_second = 'b0;\n         tlu_packet_e4.i0fence_i = 'b0;\n         tlu_packet_e4.i0trigger = 'b0;\n         tlu_packet_e4.pmu_i0_br_unpred = '0;\n         tlu_packet_e4.pmu_i0_itype = NULL;\n         tlu_packet_e4.pmu_divide = 'b0;\n         tlu_i0_valid_e4 = 'b0;\n      end\n      if(dec_tlu_packet_e4.i1tid != mytid) begin\n         tlu_packet_e4.i1trigger = 'b0;\n         tlu_packet_e4.pmu_i1_br_unpred = '0;\n         tlu_packet_e4.pmu_i1_itype = NULL;\n         tlu_i1_valid_e4 = 'b0;\n      end\n\n      // lsu is in pipe0, and the tids match\n      if( ( dec_tlu_packet_e4.lsu_pipe0 & (dec_tlu_packet_e4.i0tid == mytid)) |\n          (~dec_tlu_packet_e4.lsu_pipe0 & (dec_tlu_packet_e4.i1tid == mytid)) ) begin\n\n         tlu_packet_e4.pmu_lsu_misaligned = dec_tlu_packet_e4.pmu_lsu_misaligned;\n         lsu_error_pkt_e4.exc_valid = lsu_error_pkt_dc4.exc_valid;\n         lsu_error_pkt_e4.single_ecc_error = lsu_error_pkt_dc4.single_ecc_error;\n\n      end\n      else begin\n         tlu_packet_e4.pmu_lsu_misaligned = 'b0;\n         lsu_error_pkt_e4.exc_valid = 'b0;\n         lsu_error_pkt_e4.single_ecc_error = 'b0;\n      end\n\n   end\n\n\n   // for CSRs that have inpipe writes only\n\n   rvoclkhdr csrwr_wb_cgc ( .en(dec_i0_csr_wen_wb_mod | clk_override), .l1clk(csr_wr_clk), .* );\n   rvoclkhdr lsu_e3_e4_cgc ( .en(lsu_error_pkt_dc3.exc_valid | lsu_error_pkt_dc4.exc_valid | lsu_error_pkt_dc3.single_ecc_error |\n                                lsu_error_pkt_dc4.single_ecc_error | clk_override), .l1clk(lsu_e3_e4_clk), .* );\n   rvoclkhdr lsu_e4_e5_cgc ( .en(lsu_error_pkt_dc4.exc_valid | lsu_exc_valid_wb | clk_override), .l1clk(lsu_e4_e5_clk), .* );\n\n   assign e4_valid = tlu_i0_valid_e4 | tlu_i1_valid_e4;\n   assign e4e5_valid = e4_valid | e5_valid;\n\n   rvoclkhdr e4e5_int_cgc ( .clk(free_l2clk), .en(e4e5_valid | internal_dbg_halt_mode_f | i_cpu_run_req_d1 | interrupt_valid | interrupt_valid_wb |\n                               reset_allowed | pause_expired_e4 | pause_expired_wb | iccm_sbecc_e4 | iccm_sbecc_wb | ic_perr_e4 |\n                               ic_perr_wb |clk_override), .l1clk(e4e5_int_clk), .* );\n\n   rvdffie #(23)  bundle_freeff (.*,   .clk(free_l2clk),\n                                 .din ({nmi_int_sync, nmi_int_detected, nmi_fir_type, nmi_lsu_load_type, nmi_lsu_store_type,\n                                        1'b1, reset_detect, reset_delayed,\n                                        ifu_ic_error_start, ifu_iccm_rd_ecc_single_err, mdseac_locked_ns,\n                                        internal_dbg_halt_mode_f2, internal_dbg_halt_mode_f, force_halt,\n                                        iccm_repair_state_ns, internal_dbg_halt_mode,\n                                        tlu_flush_lower_e4, tlu_flush_lower_wb, tlu_flush_mp_e4, tlu_i0_kill_writeb_e4, tlu_i1_kill_writeb_e4,\n                                        lsu_pmu_load_external_dc3, lsu_pmu_store_external_dc3}),\n                                 .dout({nmi_int_delayed, nmi_int_detected_f, nmi_fir_type_f, nmi_lsu_load_type_f, nmi_lsu_store_type_f,\n                                        reset_detect, reset_detected, reset_delayed_f,\n                                        ifu_ic_error_start_d1, ifu_iccm_rd_ecc_single_err_d1, mdseac_locked_f,\n                                        internal_dbg_halt_mode_f3, internal_dbg_halt_mode_f2, dec_tlu_force_halt,\n                                        iccm_repair_state_d1, internal_dbg_halt_mode_f,\n                                        tlu_flush_lower_wb, tlu_flush_lower_wb1, dec_tlu_flush_mp_wb, tlu_i0_kill_writeb_wb, tlu_i1_kill_writeb_wb,\n                                        lsu_pmu_load_external_dc4, lsu_pmu_store_external_dc4}));\n\n   rvdff #(2) free_ff (.*, .clk(active_clk), .din({dec_tlu_packet_e4.i0tid, e4_valid }), .dout({i0tid_wb, e5_valid }));\n\n   assign reset_delayed = (reset_detect ^ reset_detected) | (reset_delayed_f & ~dec_tlu_flush_lower_wb);\n   assign reset_allowed = reset_delayed & mhartstart_csr;\n\n   // Filter subsequent bus errors after the first, until the lock on MDSEAC is cleared\n   assign nmi_lsu_detected = ~mdseac_locked_f & (lsu_imprecise_error_load_any | lsu_imprecise_error_store_any) & ~nmi_fir_type;\n\n   assign nmi_int_detected = (nmi_int_sync & ~nmi_int_delayed) | nmi_lsu_detected | (nmi_int_detected_f & ~take_nmi_wb) | nmi_fir_type;\n   // if the first nmi is a lsu type, note it. If there's already an nmi pending, ignore\n   assign nmi_lsu_load_type = (nmi_lsu_detected & lsu_imprecise_error_load_any & ~(nmi_int_detected_f & ~take_nmi_wb)) | (nmi_lsu_load_type_f & ~take_nmi_wb);\n   assign nmi_lsu_store_type = (nmi_lsu_detected & lsu_imprecise_error_store_any & ~(nmi_int_detected_f & ~take_nmi_wb)) | (nmi_lsu_store_type_f & ~take_nmi_wb);\n   assign nmi_fir_type = (take_ext_int_start_d6 & |lsu_fir_error[1:0]) & ~nmi_int_detected_f;\n\nlocalparam MSTATUS_MIE   = 0;\nlocalparam MIP_MCEIP     = 5;\nlocalparam MIP_MITIP0    = 4;\nlocalparam MIP_MITIP1    = 3;\nlocalparam MIP_MEIP      = 2;\nlocalparam MIP_MTIP      = 1;\nlocalparam MIP_MSIP      = 0;\n\nlocalparam MIE_MCEIE     = 5;\nlocalparam MIE_MITIE0    = 4;\nlocalparam MIE_MITIE1    = 3;\nlocalparam MIE_MEIE      = 2;\nlocalparam MIE_MTIE      = 1;\nlocalparam MIE_MSIE      = 0;\n\nlocalparam DCSR_EBREAKM  = 15;\nlocalparam DCSR_STEPIE   = 11;\nlocalparam DCSR_STOPC    = 10;\nlocalparam DCSR_STEP     = 2;\n   // ----------------------------------------------------------------------\n   // MPC halt\n   // - can interact with debugger halt and v-v\n\n   // fast ints in progress have priority\n   assign mpc_debug_halt_req_sync = mpc_debug_halt_req_sync_raw & ~ext_int_freeze_d1;\n\n   //hold dbg request when hart isn't started\n   assign dbg_halt_req_no_start = (dbg_halt_req | dbg_halt_req_no_start_f) & ~mhartstart_csr;\n\n    rvdffie #(11)  mpvhalt_ff (.*, .clk(free_l2clk),\n                                 .din({dbg_halt_req_no_start,\n                                       mpc_debug_halt_req_sync, mpc_debug_run_req_sync & debug_mode_status,\n                                       mpc_halt_state_ns, mpc_run_state_ns, debug_brkpt_status_ns,\n                                       mpc_debug_halt_ack_ns, mpc_debug_run_ack_ns,\n                                       dbg_halt_state_ns, dbg_run_state_ns,\n                                       dec_tlu_mpc_halted_only_ns}),\n                                .dout({dbg_halt_req_no_start_f,\n                                       mpc_debug_halt_req_sync_f, mpc_debug_run_req_sync_f,\n                                       mpc_halt_state_f, mpc_run_state_f, debug_brkpt_status_f,\n                                       mpc_debug_halt_ack_f, mpc_debug_run_ack_f,\n                                       dbg_halt_state_f, dbg_run_state_f,\n                                       tlu_mpc_halted_only}));\n\n   // turn level sensitive requests into pulses\n   assign mpc_debug_halt_req_sync_pulse = mpc_debug_halt_req_sync & ~mpc_debug_halt_req_sync_f;\n   assign mpc_debug_run_req_sync_pulse = mpc_debug_run_req_sync & ~mpc_debug_run_req_sync_f;\n\n   // states\n   assign mpc_halt_state_ns = (mpc_halt_state_f | mpc_debug_halt_req_sync_pulse | (reset_allowed & ~mpc_reset_run_req)) & ~mpc_debug_run_req_sync;\n   assign mpc_run_state_ns = (mpc_run_state_f | (mpc_debug_run_req_sync_pulse & ~mpc_debug_run_ack_f)) & (internal_dbg_halt_mode_f & ~dcsr_single_step_running_f);\n\n   // note, MPC halt can allow the jtag debugger to just start sending commands. When that happens, set the interal debugger halt state to prevent\n   // MPC run from starting the core.\n\n   assign dbg_halt_state_ns = (dbg_halt_state_f | (dbg_halt_req_final | dcsr_single_step_done_f | trigger_hit_dmode_wb | ebreak_to_debug_mode_wb)) & ~dbg_resume_req;\n   assign dbg_run_state_ns = (dbg_run_state_f | dbg_resume_req) & (internal_dbg_halt_mode_f & ~dcsr_single_step_running_f);\n\n   // tell dbg we are only MPC halted\n   assign dec_tlu_mpc_halted_only_ns = ~dbg_halt_state_f & mpc_halt_state_f;\n\n   // this asserts from detection of bkpt until after we leave debug mode\n   assign debug_brkpt_valid = ebreak_to_debug_mode_wb | trigger_hit_dmode_wb;\n   assign debug_brkpt_status_ns = (debug_brkpt_valid | debug_brkpt_status_f) & (internal_dbg_halt_mode & ~dcsr_single_step_running_f);\n\n   // acks back to interface\n   assign mpc_debug_halt_ack_ns =(mpc_halt_state_f & internal_dbg_halt_mode_f & mpc_debug_halt_req_sync & core_empty) | (mpc_debug_halt_ack_f & mpc_debug_halt_req_sync);\n   assign mpc_debug_run_ack_ns = (mpc_debug_run_req_sync & ~internal_dbg_halt_mode & ~mpc_debug_halt_req_sync) | (mpc_debug_run_ack_f & mpc_debug_run_req_sync) ;\n\n   // Pins\n   assign mpc_debug_halt_ack = mpc_debug_halt_ack_f;\n   assign mpc_debug_run_ack = mpc_debug_run_ack_f;\n   assign debug_brkpt_status = debug_brkpt_status_f;\n\n   // DBG halt req is a pulse, fast ext int in progress has priority\n   assign dbg_halt_req_held_ns = ((dbg_halt_req | dbg_halt_req_held)  & mhartstart_csr) & ext_int_freeze_d1;\n   assign dbg_halt_req_final = ((dbg_halt_req | dbg_halt_req_held | dbg_halt_req_no_start_f) & mhartstart_csr) & ~ext_int_freeze_d1;\n\n   // combine MPC and DBG halt requests\n   assign debug_halt_req = (dbg_halt_req_final | mpc_debug_halt_req_sync | (reset_allowed & ~mpc_reset_run_req)) & ~internal_dbg_halt_mode_f & ~ext_int_freeze_d1;\n\n   assign debug_resume_req = ~debug_resume_req_f &  // squash back to back resumes\n                             ((mpc_run_state_ns & ~dbg_halt_state_ns) |  // MPC run req\n                              (dbg_run_state_ns & ~mpc_halt_state_ns)); // dbg request is a pulse\n\n\n   // HALT\n\n   // dbg/pmu/fw requests halt, service as soon as lsu is not blocking interrupts\n   assign take_halt = (debug_halt_req_f | pmu_fw_halt_req_f) & ~synchronous_flush_e4 & ~mret_e4 & ~halt_taken_f & ~dec_tlu_flush_noredir_wb & ~take_reset;\n\n   // hold after we take a halt, so we don't keep taking halts\n   assign halt_taken = (dec_tlu_flush_noredir_wb & ~tlu_flush_pause_wb & ~take_ext_int_start_d1) | (halt_taken_f & ~dbg_tlu_halted_f & ~pmu_fw_tlu_halted_f & ~interrupt_valid_wb);\n\n   // After doing halt flush (RFNPC) wait until core is idle before asserting a particular halt mode\n   // It takes a cycle for mb_empty to assert after a fetch, take_halt covers that cycle\n   assign core_empty = force_halt |\n                       (lsu_idle_any & lsu_idle_any_f & ifu_miss_state_idle & ifu_miss_state_idle_f & ~debug_halt_req & ~debug_halt_req_d1 & ~dec_div_active);\n   assign dec_tlu_core_empty = core_empty;\n\n//--------------------------------------------------------------------------------\n// Debug start\n//\n\n   assign enter_debug_halt_req = (~internal_dbg_halt_mode_f & debug_halt_req) | dcsr_single_step_done_f | trigger_hit_dmode_wb | ebreak_to_debug_mode_wb;\n\n   // dbg halt state active from request until non-step resume\n   assign internal_dbg_halt_mode = debug_halt_req_ns | (internal_dbg_halt_mode_f & ~(debug_resume_req_f & ~dcsr[DCSR_STEP]));\n   // dbg halt can access csrs as long as we are not stepping\n   assign allow_dbg_halt_csr_write = internal_dbg_halt_mode_f & ~dcsr_single_step_running_f;\n\n\n   // hold debug_halt_req_ns high until we enter debug halt\n   assign debug_halt_req_ns = enter_debug_halt_req | (debug_halt_req_f & ~dbg_tlu_halted);\n\n   assign dbg_tlu_halted = (debug_halt_req_f & core_empty & halt_taken) | (dbg_tlu_halted_f & ~debug_resume_req_f);\n\n   assign resume_ack_ns = (debug_resume_req_f & dbg_tlu_halted_f & dbg_run_state_ns);\n\n   assign dcsr_single_step_done = tlu_i0_valid_e4 & ~dec_tlu_dbg_halted & dcsr[DCSR_STEP] & ~rfpc_i0_e4;\n\n   assign dcsr_single_step_running = (debug_resume_req_f & dcsr[DCSR_STEP]) | (dcsr_single_step_running_f & ~dcsr_single_step_done_f);\n\n   assign dbg_cmd_done_ns = tlu_i0_valid_e4 & dec_tlu_dbg_halted;\n\n   // used to hold off commits after an in-pipe debug mode request (triggers, DCSR)\n   assign request_debug_mode_e4 = (trigger_hit_dmode_e4 | ebreak_to_debug_mode_e4) | (request_debug_mode_wb & ~dec_tlu_flush_lower_wb);\n\n   assign request_debug_mode_done = (request_debug_mode_wb | request_debug_mode_done_f) & ~dbg_tlu_halted_f;\n\n    rvdffie #(22)  halt_ff (.*, .clk(free_l2clk), .din({halt_taken, take_halt, lsu_idle_any, ifu_miss_state_idle, dbg_tlu_halted,\n                                  resume_ack_ns, dbg_cmd_done_ns, debug_halt_req_ns, debug_resume_req, trigger_hit_dmode_e4,\n                                  dcsr_single_step_done, debug_halt_req,  update_hit_bit_e4[3:0], tlu_wr_pause_wb, dec_pause_state,\n                                  request_debug_mode_e4, request_debug_mode_done, dcsr_single_step_running, dbg_halt_req_held_ns}),\n                           .dout({halt_taken_f, take_halt_f, lsu_idle_any_f, ifu_miss_state_idle_f, dbg_tlu_halted_f,\n                                  dec_tlu_resume_ack, dec_dbg_cmd_done, debug_halt_req_f, debug_resume_req_f_raw, trigger_hit_dmode_wb,\n                                  dcsr_single_step_done_f, debug_halt_req_d1, update_hit_bit_wb[3:0], tlu_wr_pause_wb_f, dec_pause_state_f,\n                                  request_debug_mode_wb, request_debug_mode_done_f, dcsr_single_step_running_f, dbg_halt_req_held}));\n\n   // MPC run collides with DBG halt, fix it here\n   assign debug_resume_req_f = debug_resume_req_f_raw & ~dbg_halt_req;\n\n   assign dec_tlu_debug_stall = debug_halt_req_f;\n   assign dec_tlu_dbg_halted = dbg_tlu_halted_f;\n   assign dec_tlu_debug_mode = internal_dbg_halt_mode_f;\n   assign dec_tlu_pmu_fw_halted = pmu_fw_tlu_halted_f;\n\n   // kill fetch redirection on flush if going to halt, or if there's a fence during db-halt\n   assign dec_tlu_flush_noredir_wb = take_halt_f | (fence_i_wb & internal_dbg_halt_mode_f) | tlu_flush_pause_wb | (trigger_hit_wb & trigger_hit_dmode_wb) | take_ext_int_start_d1;\n   assign dec_tlu_flush_extint = take_ext_int_start_d1;\n\n   // 1 cycle after writing the PAUSE counter, flush with noredir to idle F1-D.\n   assign tlu_flush_pause_wb = tlu_wr_pause_wb_f & ~interrupt_valid_wb;\n\n   // detect end of pause counter and rfpc\n   assign pause_expired_e4 = ~dec_pause_state & dec_pause_state_f &\n                             ~(ext_int_ready | ce_int_ready | timer_int_ready | soft_int_ready | int_timer0_int_hold_f | int_timer1_int_hold_f | nmi_int_detected | ext_int_freeze_d1) &\n                             ~interrupt_valid_wb & ~debug_halt_req_f & ~pmu_fw_halt_req_f & ~halt_taken_f;\n\n   assign dec_tlu_flush_leak_one_wb = dec_tlu_flush_lower_wb & ~dec_tlu_flush_noredir_wb & ( (dcsr[DCSR_STEP] & (dec_tlu_resume_ack | dcsr_single_step_running)) |\n                                                                                             iccm_sbecc_wb);\n   assign dec_tlu_flush_err_wb = dec_tlu_flush_lower_wb & (ic_perr_wb | iccm_sbecc_wb);\n\n   // If DM attempts to access an illegal CSR, send cmd_fail back\n   assign dec_dbg_cmd_fail = illegal_raw_wb & dec_dbg_cmd_done;\n\n\n   //--------------------------------------------------------------------------------\n   //--------------------------------------------------------------------------------\n   // Triggers\n   //\nlocalparam MTDATA1_DMODE             = 9;\nlocalparam MTDATA1_SEL   = 7;\nlocalparam MTDATA1_ACTION            = 6;\nlocalparam MTDATA1_CHAIN             = 5;\nlocalparam MTDATA1_MATCH             = 4;\nlocalparam MTDATA1_M_ENABLED         = 3;\nlocalparam MTDATA1_EXE   = 2;\nlocalparam MTDATA1_ST    = 1;\nlocalparam MTDATA1_LD    = 0;\n\n   // Prioritize trigger hits with other exceptions.\n   //\n   // Trigger should have highest priority except:\n   // - trigger is an execute-data and there is an inst_access exception (lsu triggers won't fire, inst. is nop'd by decode)\n   // - trigger is a store-data and there is a lsu_acc_exc or lsu_ma_exc.\n   assign trigger_execute[3:0] = {mtdata1_t3[MTDATA1_EXE], mtdata1_t2[MTDATA1_EXE], mtdata1_t1[MTDATA1_EXE], mtdata1_t0[MTDATA1_EXE]};\n   assign trigger_data[3:0] = {mtdata1_t3[MTDATA1_SEL], mtdata1_t2[MTDATA1_SEL], mtdata1_t1[MTDATA1_SEL], mtdata1_t0[MTDATA1_SEL]};\n   assign trigger_store[3:0] = {mtdata1_t3[MTDATA1_ST], mtdata1_t2[MTDATA1_ST], mtdata1_t1[MTDATA1_ST], mtdata1_t0[MTDATA1_ST]};\n\n   // testing proxy until RV debug committee figures out how to prevent triggers from firing inside exception handlers.\n   // MSTATUS[MIE] needs to be on to take triggers unless the action is trigger to debug mode.\n   assign trigger_enabled[3:0] = {(mtdata1_t3[MTDATA1_ACTION] | mstatus[MSTATUS_MIE]) & mtdata1_t3[MTDATA1_M_ENABLED],\n                                  (mtdata1_t2[MTDATA1_ACTION] | mstatus[MSTATUS_MIE]) & mtdata1_t2[MTDATA1_M_ENABLED],\n                                  (mtdata1_t1[MTDATA1_ACTION] | mstatus[MSTATUS_MIE]) & mtdata1_t1[MTDATA1_M_ENABLED],\n                                  (mtdata1_t0[MTDATA1_ACTION] | mstatus["}
{"text": "MSTATUS_MIE]) & mtdata1_t0[MTDATA1_M_ENABLED]};\n\n   // iside exceptions are always in i0\n   assign i0_iside_trigger_has_pri_e4[3:0] = ~( (trigger_execute[3:0] & trigger_data[3:0] & {4{inst_acc_e4_raw}}) | // exe-data with inst_acc\n                                                ({4{exu_i0_br_error_e4 | exu_i0_br_start_error_e4 | ic_perr_e4 | iccm_sbecc_e4}}));              // branch error in i0\n\n   assign i1_iside_trigger_has_pri_e4[3:0] = ~( ({4{exu_i1_br_error_e4 | exu_i1_br_start_error_e4 | ic_perr_e4 | iccm_sbecc_e4}}) ); // branch error in i1\n\n   // lsu excs have to line up with their respective triggers since the lsu op can be in either i0 or i1 but not both\n   assign i0_lsu_trigger_has_pri_e4[3:0] = ~(trigger_store[3:0] & trigger_data[3:0] & {4{lsu_i0_exc_dc4_raw}});\n   assign i1_lsu_trigger_has_pri_e4[3:0] = ~(trigger_store[3:0] & trigger_data[3:0] & {4{lsu_i1_exc_dc4_raw}});\n\n   assign i0_trigger_e4[3:0] = {4{tlu_i0_valid_e4}} & tlu_packet_e4.i0trigger[3:0] & i0_iside_trigger_has_pri_e4[3:0] & i0_lsu_trigger_has_pri_e4[3:0] & trigger_enabled[3:0];\n   assign i1_trigger_e4[3:0] = {4{tlu_i1_valid_e4}} & tlu_packet_e4.i1trigger[3:0] & i1_iside_trigger_has_pri_e4[3:0] & i1_lsu_trigger_has_pri_e4[3:0] & trigger_enabled[3:0];\n\n\n   assign trigger_chain[2:0] = {mtdata1_t2[MTDATA1_CHAIN], mtdata1_t1[MTDATA1_CHAIN], mtdata1_t0[MTDATA1_CHAIN]};\n\n   // chaining can mask raw trigger info\n   assign i0_trigger_chain_masked_e4[3:0] = {i0_trigger_e4[3] & (~trigger_chain[2] | i0_trigger_e4[2]),\n                                             i0_trigger_e4[2] & (~trigger_chain[2] | i0_trigger_e4[3]),\n                                             i0_trigger_e4[1] & (~trigger_chain[0] | i0_trigger_e4[0]),\n                                             i0_trigger_e4[0] & (~trigger_chain[0] | i0_trigger_e4[1])};\n\n   assign i1_trigger_chain_masked_e4[3:0] = {i1_trigger_e4[3] & (~trigger_chain[2] | i1_trigger_e4[2]),\n                                             i1_trigger_e4[2] & (~trigger_chain[2] | i1_trigger_e4[3]),\n                                             i1_trigger_e4[1] & (~trigger_chain[0] | i1_trigger_e4[0]),\n                                             i1_trigger_e4[0] & (~trigger_chain[0] | i1_trigger_e4[1])};\n\n   // This is the highest priority by this point.\n   assign i0_trigger_hit_raw_e4 = |i0_trigger_chain_masked_e4[3:0];\n   assign i1_trigger_hit_raw_e4 = |i1_trigger_chain_masked_e4[3:0];\n\n   assign i0_problem_kills_i1_trigger = (~tlu_i0_commit_cmt | exu_i0_br_mp_e4 | lsu_i0_rfnpc_dc4) & tlu_i0_valid_e4;\n   // Qual trigger hits\n   assign i0_trigger_hit_e4 = ~(dec_tlu_flush_lower_wb | dec_tlu_dbg_halted) & i0_trigger_hit_raw_e4;\n   assign i1_trigger_hit_e4 = ~(dec_tlu_flush_lower_wb | dec_tlu_dbg_halted | i0_problem_kills_i1_trigger) & i1_trigger_hit_raw_e4;\n\n   // Actions include breakpoint, or dmode. Dmode is only possible if the DMODE bit is set.\n   // Otherwise, take a breakpoint.\n   assign trigger_action[3:0] = {mtdata1_t3[MTDATA1_ACTION] & mtdata1_t3[MTDATA1_DMODE],\n                                 mtdata1_t2[MTDATA1_ACTION] & mtdata1_t2[MTDATA1_DMODE] & ~mtdata1_t2[MTDATA1_CHAIN],\n                                 mtdata1_t1[MTDATA1_ACTION] & mtdata1_t1[MTDATA1_DMODE],\n                                 mtdata1_t0[MTDATA1_ACTION] & mtdata1_t0[MTDATA1_DMODE] & ~mtdata1_t0[MTDATA1_CHAIN]};\n\n   // this is needed to set the HIT bit in the triggers\n   assign i0_trigger_set_hit_e4 = |i0_trigger_e4[3:0] & ~(dec_tlu_flush_lower_wb | dec_tlu_dbg_halted | rfpc_i0_e4);\n   assign i1_trigger_set_hit_e4 = |i1_trigger_e4[3:0] & ~(dec_tlu_flush_lower_wb | dec_tlu_dbg_halted | i0_problem_kills_i1_trigger | rfpc_i1_e4);\n\n   assign update_hit_bit_e4[3:0] = ({4{i0_trigger_set_hit_e4}} & {i0_trigger_chain_masked_e4[3], i0_trigger_e4[2], i0_trigger_chain_masked_e4[1], i0_trigger_e4[0]} ) |\n                                   ({4{i1_trigger_set_hit_e4}} & {i1_trigger_chain_masked_e4[3], i1_trigger_e4[2], i1_trigger_chain_masked_e4[1], i1_trigger_e4[0]} );\n\n   // action, 1 means dmode. Simultaneous triggers with at least 1 set for dmode force entire action to dmode.\n   assign i0_trigger_action_e4 = |(i0_trigger_chain_masked_e4[3:0] & trigger_action[3:0]);\n   assign i1_trigger_action_e4 = |(i1_trigger_chain_masked_e4[3:0] & trigger_action[3:0]);\n\n   assign trigger_hit_e4 = i0_trigger_hit_e4 | i1_trigger_hit_e4;\n   assign trigger_hit_dmode_e4 = (i0_trigger_hit_e4 & i0_trigger_action_e4) | (i1_trigger_hit_e4 & ~i0_trigger_hit_e4 & i1_trigger_action_e4);\n\n   assign mepc_trigger_hit_sel_pc_e4 = trigger_hit_e4 & ~trigger_hit_dmode_e4;\n\n\n//\n// Debug end\n//--------------------------------------------------------------------------------\n\n   //----------------------------------------------------------------------\n   //\n   // Commit\n   //\n   //----------------------------------------------------------------------\n\n\n\n   //--------------------------------------------------------------------------------\n   // External halt (not debug halt)\n   // - Fully interlocked handshake\n   // i_cpu_halt_req  ____|--------------|_______________\n   // core_empty      ---------------|___________\n   // o_cpu_halt_ack  _________________|----|__________\n   // o_cpu_halt_status _______________|---------------------|_________\n   // i_cpu_run_req                              ______|----------|____\n   // o_cpu_run_ack                              ____________|------|________\n   //\n\n\n   // debug mode has priority, ignore PMU/FW halt/run while in debug mode\n   assign i_cpu_halt_req_sync_qual = i_cpu_halt_req_sync & ~dec_tlu_debug_mode & ~ext_int_freeze_d1;\n   assign i_cpu_run_req_sync_qual = i_cpu_run_req_sync & ~dec_tlu_debug_mode & pmu_fw_tlu_halted_f & ~ext_int_freeze_d1;\n\n   rvdffie #(10) exthaltff (.*, .clk(free_l2clk), .din({i_cpu_halt_req_sync_qual, i_cpu_run_req_sync_qual,   cpu_halt_status,\n                                                   cpu_halt_ack,   cpu_run_ack, internal_pmu_fw_halt_mode,\n                                                   pmu_fw_halt_req_ns, pmu_fw_tlu_halted,\n                                                   int_timer0_int_hold, int_timer1_int_hold}),\n                                            .dout({i_cpu_halt_req_d1,        i_cpu_run_req_d1_raw,      o_cpu_halt_status,\n                                                   o_cpu_halt_ack, o_cpu_run_ack, internal_pmu_fw_halt_mode_f,\n                                                   pmu_fw_halt_req_f, pmu_fw_tlu_halted_f,\n                                                   int_timer0_int_hold_f, int_timer1_int_hold_f}));\n\n   // only happens if we aren't in dgb_halt\n   assign ext_halt_pulse = i_cpu_halt_req_sync_qual & ~i_cpu_halt_req_d1;\n\n   assign enter_pmu_fw_halt_req =  ext_halt_pulse | fw_halt_req;\n\n   assign pmu_fw_halt_req_ns = (enter_pmu_fw_halt_req | (pmu_fw_halt_req_f & ~pmu_fw_tlu_halted)) & ~debug_halt_req_f;\n\n   assign internal_pmu_fw_halt_mode = pmu_fw_halt_req_ns | (internal_pmu_fw_halt_mode_f & ~i_cpu_run_req_d1 & ~debug_halt_req_f);\n\n   // debug halt has priority\n   assign pmu_fw_tlu_halted = ((pmu_fw_halt_req_f & core_empty & halt_taken) | (pmu_fw_tlu_halted_f & ~i_cpu_run_req_d1)) & ~debug_halt_req_f;\n\n   assign cpu_halt_ack = (i_cpu_halt_req_d1 & pmu_fw_tlu_halted_f) | (o_cpu_halt_ack & i_cpu_halt_req_sync);\n   assign cpu_halt_status = ((pmu_fw_tlu_halted_f & ~i_cpu_run_req_d1) | (o_cpu_halt_status & ~i_cpu_run_req_d1)) & ~internal_dbg_halt_mode_f;\n   assign cpu_run_ack = (~pmu_fw_tlu_halted_f & i_cpu_run_req_sync) | (o_cpu_halt_status & i_cpu_run_req_d1_raw) | (o_cpu_run_ack & i_cpu_run_req_sync);\n   assign debug_mode_status = internal_dbg_halt_mode_f;\n   assign o_debug_mode_status = debug_mode_status;\n\n\n`ifdef RV_ASSERT_ON\n  assert_commit_while_halted: assert #0 (~((tlu_i0_commit_cmt | tlu_i1_commit_cmt) & o_cpu_halt_status)) else $display(\"ERROR: Commiting while cpu_halt_status asserted!\");\n  assert_flush_while_fastint: assert #0 (~((take_ext_int_start_d1 | take_ext_int_start_d2| take_ext_int_start_d3| take_ext_int_start_d4| take_ext_int_start_d5) & tlu_flush_lower_e4)) else $display(\"ERROR: TLU Flushing inside fast interrupt procedure!\");\n\n  assert_double_ras_case: assert #0 (~( iside_oop_rfpc & (lsu_i0_rfnpc_dc4 | lsu_i1_rfnpc_dc4) & (|tlu_packet_e4.i0trigger[3:0]))) else $display(\"ERROR: DOUBLE RAS WITH TRIGGER, IGNORE TEST\");\n`endif\n\n   // high priority interrupts can wakeup from external halt, so can unmasked timer interrupts\n   assign i_cpu_run_req_d1 = i_cpu_run_req_d1_raw | ((nmi_int_detected | timer_int_ready | soft_int_ready | int_timer0_int_hold_f | int_timer1_int_hold_f | (mhwakeup & mhwakeup_ready)) & o_cpu_halt_status & ~i_cpu_halt_req_d1);\n\n   //--------------------------------------------------------------------------------\n   //--------------------------------------------------------------------------------\n\n   // LSU exceptions (LSU responsible for prioritizing simultaneous cases)\n\n   rvdff #( $bits(eh2_lsu_error_pkt_t) ) lsu_error_dc4ff (.*, .clk(lsu_e3_e4_clk), .din(lsu_error_pkt_dc3),  .dout(lsu_error_pkt_dc4));\n\n\n   assign lsu_error_pkt_addr_dc4[31:0] = lsu_error_pkt_e4.addr[31:0];\n   rvdff #(38) lsu_error_wbff (.*, .clk(lsu_e4_e5_clk), .din({lsu_error_pkt_addr_dc4[31:0], lsu_exc_valid_e4, lsu_i0_exc_dc4, lsu_error_pkt_e4.mscause[3:0]}),\n                                                       .dout({lsu_error_pkt_addr_wb[31:0], lsu_exc_valid_wb, lsu_i0_exc_wb, lsu_error_mscause_wb[3:0]}));\n\n\n   // lsu exception is valid unless it's in pipe1 and there was a rfpc_i0_e4, brmp, or an iside exception in pipe0.\n   assign lsu_exc_valid_e4_raw = lsu_error_pkt_e4.exc_valid & ~(~tlu_packet_e4.lsu_pipe0 & (rfpc_i0_e4 | i0_exception_valid_e4 | exu_i0_br_mp_e4)) & ~dec_tlu_flush_lower_wb;\n\n   assign lsu_i0_exc_dc4_raw =  lsu_error_pkt_e4.exc_valid & tlu_packet_e4.lsu_pipe0;\n   assign lsu_i1_exc_dc4_raw = lsu_error_pkt_e4.exc_valid &  ~tlu_packet_e4.lsu_pipe0;\n   assign lsu_i0_exc_dc4 = lsu_i0_exc_dc4_raw & lsu_exc_valid_e4_raw & ~i0_trigger_hit_e4 & ~iside_oop_rfpc;\n   assign lsu_i1_exc_dc4 = lsu_i1_exc_dc4_raw & lsu_exc_valid_e4_raw & ~trigger_hit_e4 & ~iside_oop_rfpc;\n   assign lsu_exc_valid_e4 = lsu_i0_exc_dc4 | lsu_i1_exc_dc4;\n\n   assign lsu_exc_ma_dc4 = (lsu_i0_exc_dc4 | lsu_i1_exc_dc4) & ~lsu_error_pkt_e4.exc_type;\n   assign lsu_exc_acc_dc4 = (lsu_i0_exc_dc4 | lsu_i1_exc_dc4) & lsu_error_pkt_e4.exc_type;\n   assign lsu_exc_st_dc4 = (lsu_i0_exc_dc4 | lsu_i1_exc_dc4) & lsu_error_pkt_e4.inst_type;\n\n\n   // Single bit ECC errors on loads are RFNPC corrected, with the corrected data written to the GPR.\n   // LSU turns the load into a store and patches the data in the DCCM\n   assign lsu_i0_rfnpc_dc4 = tlu_i0_valid_e4 & tlu_packet_e4.lsu_pipe0 & (~lsu_error_pkt_e4.inst_type | lsu_error_pkt_e4.amo_valid) &\n                             lsu_error_pkt_e4.single_ecc_error & ~i0_trigger_hit_e4;\n   assign lsu_i1_rfnpc_dc4 = tlu_i1_valid_e4 &  ~tlu_packet_e4.lsu_pipe0 & (~lsu_error_pkt_e4.inst_type | lsu_error_pkt_e4.amo_valid) &\n                             lsu_error_pkt_e4.single_ecc_error & ~i0_trigger_hit_e4 & ~i1_trigger_hit_e4;\n\n\n\n   //  Final commit valids\n   assign tlu_i0_commit_cmt = tlu_i0_valid_e4 &\n                              ~rfpc_i0_e4 &\n                              ~lsu_i0_exc_dc4 &\n                              ~inst_acc_e4 &\n                              ~dec_tlu_dbg_halted &\n                              ~request_debug_mode_wb &\n                              ~i0_trigger_hit_e4;\n\n   assign tlu_i1_commit_cmt = tlu_i1_valid_e4 &\n                              ~rfpc_i0_e4 & ~rfpc_i1_e4 &\n                              ~exu_i0_br_mp_e4 &\n                              ~lsu_i0_exc_dc4  & ~lsu_i1_exc_dc4 &\n                              ~lsu_i0_rfnpc_dc4 &\n                              ~inst_acc_e4 &\n                              ~request_debug_mode_wb &\n                              ~i0_trigger_hit_e4 & ~i1_trigger_hit_e4;\n\n   // unified place to manage the killing of arch state writebacks\n   assign tlu_i0_kill_writeb_e4 = (rfpc_i0_e4 | lsu_i0_exc_dc4 | inst_acc_e4 | (illegal_e4 & dec_tlu_dbg_halted) | i0_trigger_hit_e4) & tlu_i0_valid_e4;\n   assign tlu_i1_kill_writeb_e4 = (rfpc_i1_e4 | lsu_i1_exc_dc4 | i1_trigger_hit_e4 | ((ic_perr_e4 | iccm_sbecc_e4) & ~ext_int_freeze_d1) |\n                                   ((rfpc_i0_e4 | exu_i0_br_mp_e4 | i0_trigger_hit_e4 |\n                                     lsu_i0_rfnpc_dc4 | lsu_i0_exc_dc4 | inst_acc_e4 |\n                                     (illegal_e4 & dec_tlu_dbg_halted)) & tlu_i0_valid_e4)) & tlu_i1_valid_e4;\n\n   // refetch PC, microarch flush\n   // ic errors only in pipe0\n   assign rfpc_i0_e4 = ((tlu_i0_valid_e4 & ~tlu_flush_lower_wb & (exu_i0_br_error_e4 | exu_i0_br_start_error_e4)) |\n                       ((ic_perr_e4 | iccm_sbecc_e4) & ~ext_int_freeze_d1)) &\n                       ~i0_trigger_hit_e4 &\n                       ~lsu_i0_rfnpc_dc4;\n   assign rfpc_i1_e4 = tlu_i1_valid_e4 & ~tlu_flush_lower_wb & ~i0_exception_valid_e4 & ~exu_i0_br_mp_e4 & ~lsu_i0_exc_dc4 & ~lsu_i0_rfnpc_dc4 &\n                       ~(exu_i0_br_error_e4 | exu_i0_br_start_error_e4 | ic_perr_e4 | iccm_sbecc_e4) &\n                       (exu_i1_br_error_e4 | exu_i1_br_start_error_e4) &\n                       ~trigger_hit_e4;\n\n   if(pt.NUM_THREADS>1) begin\n      // Sharing a BTB between threads leads to a corner case where 1 thread has a branch error to the same index/offset that the other thread is using to predict a loop.\n      // To ensure forward progress on the thread with the error, the other thread has to be prevented from writing the BTB until forward progress is made or we halt\n      assign tlu_btb_write_kill_ns = ( ((rfpc_i0_e4 & (exu_i0_br_error_e4 | exu_i0_br_start_error_e4)) | // I0 RFPC due to branch error\n                                        (rfpc_i1_e4 & (exu_i1_br_error_e4 | exu_i1_br_start_error_e4)) | // I1 RFPC due to branch error\n                                        // Hold\n                                        tlu_btb_write_kill) &\n                                       // clears\n                                       ~(tlu_i0_commit_cmt | tlu_i1_commit_cmt | // clear due to commit\n                                         internal_pmu_fw_halt_mode_f |  // clear due to PMU/FW halt\n                                         internal_dbg_halt_mode_f // clear due to debug halt\n                                         )\n                                       );\n   end // if (pt.NUM_THREADS>1)\n   else\n     assign tlu_btb_write_kill_ns = 1'b0;\n\n\n   // From the indication of a iccm single bit error until the first commit or flush, maintain a repair state. In the repair state, rfnpc i0 commits.\n   assign iccm_repair_state_ns = iccm_sbecc_wb | (iccm_repair_state_d1 & ~dec_tlu_flush_lower_wb);\n\n   // this is a flush of last resort, meaning only assert it if there is no other flush happening.\n   assign iccm_repair_state_rfnpc = ((tlu_i0_commit_cmt &\n                                    ~(ebreak_e4 | ecall_e4 | mret_e4 | take_reset | illegal_e4 | dec_i0_csr_is_mcpc_e4)) | tlu_i1_commit_cmt) & iccm_repair_state_d1;\n\n   assign iside_oop_rfpc = (ifu_ic_error_start_d1 | ifu_iccm_rd_ecc_single_err_d1) & (~internal_dbg_halt_mode_f | dcsr_single_step_running) & ~internal_pmu_fw_halt_mode_f;\n\n   // only expect these in pipe 0\n   assign       ebreak_e4    =  (tlu_packet_e4.pmu_i0_itype == EBREAK)  & tlu_i0_valid_e4 & ~i0_trigger_hit_e4 & ~dcsr[DCSR_EBREAKM] & ~iside_oop_rfpc;\n   assign       ecall_e4     =  (tlu_packet_e4.pmu_i0_itype == ECALL)   & tlu_i0_valid_e4 & ~i0_trigger_hit_e4 & ~iside_oop_rfpc;\n   assign       illegal_e4   =  ~tlu_packet_e4.i0legal   & tlu_i0_valid_e4 & ~i0_trigger_hit_e4 & ~iside_oop_rfpc;\n   assign       mret_e4      =  (tlu_packet_e4.pmu_i0_itype == MRET)    & tlu_i0_valid_e4 & ~i0_trigger_hit_e4 & ~iside_oop_rfpc;\n   // fence_i includes debug only fence_i's\n   assign       fence_i_e4   =  tlu_packet_e4.i0fence_i & tlu_i0_valid_e4 & ~i0_trigger_hit_e4 & ~iside_oop_rfpc; //| csr_fence_i_wb;\n   assign       ic_perr_e4    =  ifu_ic_error_start_d1 & ~ext_int_freeze_d1 & ~dec_tlu_flush_lower_wb & (~internal_dbg_halt_mode_f | dcsr_single_step_running) & ~internal_pmu_fw_halt_mode_f;\n   assign       iccm_sbecc_e4 =  ifu_iccm_rd_ecc_single_err_d1 & ~ext_int_freeze_d1 & ~dec_tlu_flush_lower_wb & (~internal_dbg_halt_mode_f | dcsr_single_step_running) & ~internal_pmu_fw_halt_mode_f;\n   assign       inst_acc_e4_raw  =  tlu_packet_e4.i0icaf & tlu_i0_valid_e4;\n   assign       inst_acc_e4 = inst_acc_e4_raw & ~rfpc_i0_e4 & ~i0_trigger_hit_e4;\n   assign       inst_acc_second_e4 = tlu_packet_e4.i0icaf_second;\n\n   assign       ebreak_to_debug_mode_e4 = (tlu_packet_e4.pmu_i0_itype == EBREAK)  & tlu_i0_valid_e4 & ~i0_trigger_hit_e4 & dcsr[DCSR_EBREAKM] & ~iside_oop_rfpc;\n\n   assign illegal_e4_qual = illegal_e4 & ~dec_tlu_dbg_halted;\n\n   rvdffie #(11)  exctype_wb_ff (.*,\n                                .din({ebreak_e4, ebreak_to_debug_mode_e4, illegal_e4,  ecall_e4,\n                                      illegal_e4_qual,  inst_acc_e4, inst_acc_second_e4, fence_i_e4, mret_e4,\n                                      tlu_packet_e4.i0icaf_type[1:0]}),\n                               .dout({ebreak_wb, ebreak_to_debug_mode_wb, illegal_raw_wb, ecall_wb,\n                                      illegal_wb,       inst_acc_wb, inst_acc_second_wb, fence_i_wb, mret_wb,\n                                      icaf_type_wb[1:0]}));\n\n   assign dec_tlu_fence_i_wb = fence_i_wb;\n\n   // Reset the reservation in LSU for mret, exceptions, ints, halts, resumes.\n   assign tlu_lr_reset_wb = mret_wb | exc_or_int_valid_wb | take_halt_f | debug_resume_req_f | (i_cpu_run_req_d1 & pmu_fw_tlu_halted_f);\n\n   //\n   // Exceptions\n   //\n   // - MEPC <- PC\n   // - PC <- MTVEC, assert flush_lower\n   // - MCAUSE <- cause\n   // - MSCAUSE <- secondary cause\n   // - MTVAL <-\n   // - MPIE <- MIE\n   // - MIE <- 0\n   //\n   assign i0_exception_valid_e4 = (ebreak_e4 | ecall_e4 | illegal_e4 | inst_acc_e4) & ~rfpc_i0_e4 & ~dec_tlu_dbg_halted;\n\n   // Cause:\n   //\n   // 0x2 : illegal\n   // 0x3 : breakpoint\n   // 0xb : Environment call M-mode\n\n\n   assign exc_cause_e4[4:0] = ( ({5{take_ext_int}}        & 5'h0b) |\n                                ({5{take_timer_int}}      & 5'h07) |\n                                ({5{take_soft_int}}       & 5'h03) |\n                                ({5{take_int_timer0_int}} & 5'h1d) |\n                                ({5{take_int_timer1_int}} & 5'h1c) |\n                                ({5{take_ce_int}}         & 5'h1e) |\n                                ({5{illegal_e4}}          & 5'h02) |\n                                ({5{ecall_e4}}            & 5'h0b) |\n                                ({5{inst_acc_e4}}         & 5'h01) |\n                                ({5{ebreak_e4 | trigger_hit_e4}}        & 5'h03) |\n                                ({5{lsu_exc_ma_dc4 & ~lsu_exc_st_dc4}}  & 5'h04) |\n                                ({5{lsu_exc_acc_dc4 & ~lsu_exc_st_dc4}} & 5'h05) |\n                                ({5{lsu_exc_ma_dc4 & lsu_exc_st_dc4}}   & 5'h06) |\n                                ({5{lsu_exc_acc_dc4 & lsu_exc_st_dc4}}  & 5'h07)\n                                ) & ~{5{take_nmi}};\n\n   //\n   // Interrupts\n   //\n   // Priv spec 1.10, 3.1.14\n   // \"Multiple simultaneous interrupts and traps at the same privilege level are handled in the following\n   // decreasing priority order: external interrupts, software interrupts, timer interrupts, then finally any\n   // synchronous traps.\"\n   //\n   // For above purposes, exceptions that are committed have already happened and will cause an int at E4 to wait a cycle\n   // or more if MSTATUS[MIE] is cleared.\n   //\n   // -in priority order, highest to lowest\n   // -single cycle window where a csr write to MIE/MSTATUS is at E4 when the other conditions for externals are met.\n   //  Hold off externals for a cycle to make sure we are consistent with what was just written\n   assign mhwakeup_ready =  ~dec_csr_stall_int_ff & mstatu"}
{"text": "s_mie_ns & mip[MIP_MEIP]   & mie_ns[MIE_MEIE];\n   assign ext_int_ready   = ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[MIP_MEIP]   & mie_ns[MIE_MEIE] & ~ignore_ext_int_due_to_lsu_stall;\n   assign ce_int_ready    = ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[MIP_MCEIP]  & mie_ns[MIE_MCEIE];\n   assign soft_int_ready  = ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[MIP_MSIP]   & mie_ns[MIE_MSIE];\n   assign timer_int_ready = ~dec_csr_stall_int_ff & mstatus_mie_ns & mip[MIP_MTIP]   & mie_ns[MIE_MTIE];\n\n   // MIP for internal timers pulses for 1 clock, resets the timer counter. Mip won't hold past the various stall conditions.\n   assign int_timer0_int_possible = mstatus_mie_ns & mie_ns[MIE_MITIE0];\n   assign int_timer0_int_ready = mip[MIP_MITIP0] & int_timer0_int_possible;\n   assign int_timer1_int_possible = mstatus_mie_ns & mie_ns[MIE_MITIE1];\n   assign int_timer1_int_ready = mip[MIP_MITIP1] & int_timer1_int_possible;\n\n   // Internal timers pulse and reset. If core is PMU/FW halted, the pulse will cause an exit from halt, but won't stick around\n   // Make it sticky, also for 1 cycle stall conditions.\n   assign int_timer_stalled = dec_csr_stall_int_ff | synchronous_flush_e4 | exc_or_int_valid_wb | mret_wb | mret_e4;\n\n   assign int_timer0_int_hold = (int_timer0_int_ready & (pmu_fw_tlu_halted_f | int_timer_stalled)) | (int_timer0_int_possible & int_timer0_int_hold_f & ~interrupt_valid & ~take_ext_int_start & ~internal_dbg_halt_mode_f);\n   assign int_timer1_int_hold = (int_timer1_int_ready & (pmu_fw_tlu_halted_f | int_timer_stalled)) | (int_timer1_int_possible & int_timer1_int_hold_f & ~interrupt_valid & ~take_ext_int_start & ~internal_dbg_halt_mode_f);\n\n\n   // mispredicts use exu flush bus with sram timing, otherwise mux into tlu flush bus\n   assign i0_mp_e4 = exu_i0_flush_lower_e4 & ~(exu_i0_br_error_e4 | exu_i0_br_start_error_e4 | ic_perr_e4 | iccm_sbecc_e4) & ~i0_trigger_hit_e4;\n   assign i1_mp_e4 = exu_i1_flush_lower_e4 & ~(exu_i1_br_error_e4 | exu_i1_br_start_error_e4 | ic_perr_e4 | iccm_sbecc_e4) & ~trigger_hit_e4 & ~lsu_i0_rfnpc_dc4;\n\n   assign internal_dbg_halt_timers = ~mhartstart_csr | (internal_dbg_halt_mode_f & ~dcsr_single_step_running);\n\n   // Prioritize externals\n   assign block_interrupts = ( (internal_dbg_halt_mode & (~dcsr_single_step_running | tlu_i0_valid_e4)) | // No ints in db-halt unless we are single stepping\n                               internal_pmu_fw_halt_mode | i_cpu_halt_req_d1 |// No ints in PMU/FW halt. First we exit halt\n                               take_nmi | // NMI is top priority\n                               ebreak_to_debug_mode_e4 | // Heading to debug mode, hold off ints\n                               synchronous_flush_e4 | // exception flush this cycle\n                               exc_or_int_valid_wb | // ext/int past cycle (need time for MIE to update)\n                               mret_wb | // mret (need time for MIE to update)\n                               mret_e4 | // mret in progress, for cases were ISR enables ints before mret\n                               ext_int_freeze_d1 // fast interrupt in progress\n                               );\n\nif (pt.FAST_INTERRUPT_REDIRECT) begin\n\n      rvdffie #(9)  fastint_ff (.*, .clk(free_l2clk),\n                                .din({take_ext_int_start,    take_ext_int_start_d1, take_ext_int_start_d2, take_ext_int_start_d3,\n                                      take_ext_int_start_d4, take_ext_int_start_d5, ext_int_freeze, lsu_fir_error[1:0]}),\n                               .dout({take_ext_int_start_d1, take_ext_int_start_d2, take_ext_int_start_d3, take_ext_int_start_d4,\n                                      take_ext_int_start_d5, take_ext_int_start_d6, ext_int_freeze_d1, lsu_fir_error_d1[1:0]}));\n\n   assign tlu_fast_ext_int_ready = ext_int_ready & ~block_interrupts;\n   assign take_ext_int_start = tlu_fast_ext_int_ready & (tlu_select_tid == mytid);\n\n   assign ext_int_freeze = take_ext_int_start | take_ext_int_start_d1 | take_ext_int_start_d2 | take_ext_int_start_d3 |\n                            take_ext_int_start_d4 | take_ext_int_start_d5 | take_ext_int_start_d6;\n   assign take_ext_int = take_ext_int_start_d6 & ~|lsu_fir_error[1:0];\n\n   assign ignore_ext_int_due_to_lsu_stall = lsu_fastint_stall_any;\n\nend\nelse begin\n   assign take_ext_int_start = 1'b0;\n   assign ext_int_freeze = 1'b0;\n   assign ext_int_freeze_d1 = 1'b0;\n   assign take_ext_int_start_d1 = 1'b0;\n   assign take_ext_int_start_d2 = 1'b0;\n   assign take_ext_int_start_d3 = 1'b0;\n   assign take_ext_int_start_d4 = 1'b0;\n   assign take_ext_int_start_d5 = 1'b0;\n   assign take_ext_int_start_d6 = 1'b0;\n   assign lsu_fir_error_d1[1:0] = 2'b0;\n   assign ignore_ext_int_due_to_lsu_stall = 1'b0;\n   assign tlu_fast_ext_int_ready = 1'b0;\n\n   assign take_ext_int = ext_int_ready & ~block_interrupts;\nend\n\n\n\n   assign take_ce_int  = ce_int_ready & ~ext_int_ready & ~block_interrupts;\n   assign take_soft_int = soft_int_ready & ~ext_int_ready & ~ce_int_ready & ~block_interrupts;\n   assign take_timer_int = timer_int_ready & ~soft_int_ready & ~ext_int_ready & ~ce_int_ready & ~block_interrupts;\n   assign take_int_timer0_int = (int_timer0_int_ready | int_timer0_int_hold_f) & int_timer0_int_possible &\n                                ~dec_csr_stall_int_ff & ~timer_int_ready & ~soft_int_ready & ~ext_int_ready & ~ce_int_ready & ~block_interrupts;\n   assign take_int_timer1_int = (int_timer1_int_ready | int_timer1_int_hold_f) & int_timer1_int_possible &\n                                ~dec_csr_stall_int_ff & ~(int_timer0_int_ready | int_timer0_int_hold_f) & ~timer_int_ready &\n                                ~soft_int_ready & ~ext_int_ready & ~ce_int_ready & ~block_interrupts;\n\n   assign take_reset = reset_allowed & mpc_reset_run_req;\n   assign take_nmi = nmi_int_detected & ~internal_pmu_fw_halt_mode &\n                     (~internal_dbg_halt_mode | (dcsr_single_step_running_f & dcsr[DCSR_STEPIE] & ~tlu_i0_valid_e4 & ~dcsr_single_step_done_f)) &\n                     ~synchronous_flush_e4 & ~mret_e4 & ~take_reset & ~ebreak_to_debug_mode_e4 & (~ext_int_freeze_d1 | (take_ext_int_start_d6 & |lsu_fir_error[1:0]));\n\n   assign interrupt_valid = take_ext_int | take_timer_int | take_soft_int | take_nmi | take_ce_int | take_int_timer0_int | take_int_timer1_int;\n\n\n   // Compute interrupt path:\n   // If vectored async is set in mtvec, flush path for interrupts is MTVEC + (4 * CAUSE);\n   assign vectored_cause[5:1]  = exc_cause_e4[4:0];\n   assign vectored_path[31:2]  = mtvec[30:1] + {25'b0, vectored_cause[5:1]};\n   assign interrupt_path[31:1] = take_nmi ? nmi_vec[31:1] : ((mtvec[0] == 1'b1) ? {vectored_path[31:2], 1'b0} : {mtvec[30:1], 1'b0});\n\n   assign sel_npc_e4 = lsu_i0_rfnpc_dc4 | (lsu_i1_rfnpc_dc4 & tlu_i1_commit_cmt) | fence_i_e4 | iccm_repair_state_rfnpc | (i_cpu_run_req_d1 & ~interrupt_valid) | (rfpc_i0_e4 & ~tlu_i0_valid_e4);\n   assign sel_npc_wb = (i_cpu_run_req_d1 & pmu_fw_tlu_halted_f) | pause_expired_e4;\n\n   assign sel_fir_addr = take_ext_int_start_d6 & ~|lsu_fir_error[1:0];\n\n   assign synchronous_flush_e4 = i0_exception_valid_e4 | // exception\n                                 i0_mp_e4 | i1_mp_e4 |  // mispredict\n                                 rfpc_i0_e4 | rfpc_i1_e4 | // rfpc\n                                 lsu_exc_valid_e4 |  // lsu exception in either pipe 0 or pipe 1\n                                 fence_i_e4 |  // fence, a rfnpc\n                                 lsu_i0_rfnpc_dc4 | lsu_i1_rfnpc_dc4 |\n                                 iccm_repair_state_rfnpc | // Iccm sb ecc\n                                 debug_resume_req_f | // resume from debug halt, fetch the dpc\n                                 sel_npc_wb |  // resume from pmu/fw halt, or from pause and fetch the NPC\n                                 tlu_wr_pause_wb | // flush at start of pause\n                                 trigger_hit_e4; // trigger hit, ebreak or goto debug mode\n\n   assign tlu_flush_lower_e4 = interrupt_valid | mret_e4 | synchronous_flush_e4 | take_halt | take_reset | take_ext_int_start;\n\n   assign tlu_flush_path_e4[31:1] = take_reset ? rst_vec[31:1] :\n\n                                     (({31{sel_fir_addr}} & lsu_fir_addr[31:1]) |\n                                      ({31{~take_nmi & i0_mp_e4}} & exu_i0_flush_path_e4[31:1]) |\n                                      ({31{~take_nmi & ~i0_mp_e4 & i1_mp_e4 & ~rfpc_i0_e4 & ~lsu_i0_exc_dc4}} & exu_i1_flush_path_e4[31:1]) |\n                                      ({31{~take_nmi & sel_npc_e4}} & npc_e4[31:1]) |\n                                      ({31{~take_nmi & rfpc_i0_e4 & tlu_i0_valid_e4 & ~sel_npc_e4}} & dec_tlu_i0_pc_e4[31:1]) |\n                                      ({31{~take_nmi & rfpc_i1_e4}} & dec_tlu_i1_pc_e4[31:1]) |\n                                      ({31{interrupt_valid & ~sel_fir_addr}} & interrupt_path[31:1]) |\n                                      ({31{(i0_exception_valid_e4 | lsu_exc_valid_e4 |\n                                            (trigger_hit_e4 & ~trigger_hit_dmode_e4)) & ~interrupt_valid & ~sel_fir_addr}} & {mtvec[30:1],1'b0}) |\n                                      ({31{~take_nmi & mret_e4 & ~wr_mepc_wb}} & mepc[31:1]) |\n                                      ({31{~take_nmi & debug_resume_req_f}} & dpc[31:1]) |\n                                      ({31{~take_nmi & sel_npc_wb}} & npc_wb[31:1]) |\n                                      ({31{~take_nmi & mret_e4 & wr_mepc_wb}} & dec_i0_csr_wrdata_wb[31:1]) );\n\n   assign tlu_flush_mp_e4 = ~take_nmi & (i0_mp_e4 | (i1_mp_e4 & ~rfpc_i0_e4 & ~lsu_i0_exc_dc4));\n\n   rvdffe #(31)  flush_lower_ff (.*, .clk(free_l2clk), .en(tlu_flush_lower_e4),\n                                 .din({tlu_flush_path_e4[31:1]}),\n                                 .dout({tlu_flush_path_wb[31:1]}));\n\n   assign dec_tlu_flush_lower_wb = tlu_flush_lower_wb ;\n   assign dec_tlu_flush_path_wb[31:1] = tlu_flush_path_wb[31:1];\n\n   assign dec_tlu_flush_lower_wb1 = tlu_flush_lower_wb1 ;\n\n   // this is used to capture mepc, etc.\n   assign exc_or_int_valid = lsu_exc_valid_e4 | i0_exception_valid_e4 | interrupt_valid | (trigger_hit_e4 & ~trigger_hit_dmode_e4);\n\n   rvdff #(17)  excinfo_wb_ff (.*, .clk(e4e5_int_clk),\n                                .din({ic_perr_e4, iccm_sbecc_e4, interrupt_valid, i0_exception_valid_e4, exc_or_int_valid,\n                                      exc_cause_e4[4:0], tlu_i0_commit_cmt & ~illegal_e4, tlu_i1_commit_cmt,\n                                       mepc_trigger_hit_sel_pc_e4, trigger_hit_e4, i0_trigger_hit_e4,\n                                      take_nmi, pause_expired_e4 }),\n                               .dout({ic_perr_wb, iccm_sbecc_wb, interrupt_valid_wb, i0_exception_valid_wb, exc_or_int_valid_wb,\n                                      exc_cause_wb[4:0], i0_valid_wb, i1_valid_wb,\n                                       mepc_trigger_hit_sel_pc_wb, trigger_hit_wb, i0_trigger_hit_wb,\n                                      take_nmi_wb, pause_expired_wb}));\n\n   //----------------------------------------------------------------------\n   //\n   // CSRs\n   //\n   //----------------------------------------------------------------------\n\n\n   // ----------------------------------------------------------------------\n   // MISA (RO)\n   //  [31:30] XLEN - implementation width, 2'b01 - 32 bits\n   //  [12]    M    - integer mul/div\n   //  [8]     I    - RV32I\n   //  [2]     C    - Compressed extension\n   //  [0]     A    - Atomic extension\n   localparam MISA          = 12'h301;\n\n   // MVENDORID, MARCHID, MIMPID, MHARTID\n   localparam MVENDORID     = 12'hf11;\n   localparam MARCHID       = 12'hf12;\n   localparam MIMPID        = 12'hf13;\n   localparam MHARTID       = 12'hf14;\n\n\n   // ----------------------------------------------------------------------\n   // MSTATUS (RW)\n   // [12:11] MPP  : Prior priv level, always 2'b11, not flopped\n   // [7]     MPIE : Int enable previous [1]\n   // [3]     MIE  : Int enable          [0]\n   localparam MSTATUS       = 12'h300;\n\n\n   //When executing a MRET instruction, supposing MPP holds the value 3, MIE\n   //is set to MPIE; the privilege mode is changed to 3; MPIE is set to 1; and MPP is set to 3\n   assign dec_i0_csr_wen_wb_mod = dec_i0_csr_wen_wb & ~trigger_hit_wb & (mytid == i0tid_wb);\n   assign wr_mstatus_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MSTATUS);\n\n    // set this even if we don't go to fwhalt due to debug halt. We committed the inst, so ...\n   assign set_mie_pmu_fw_halt = ~mpmc_b_ns[1] & wr_mpmc_wb & dec_i0_csr_wrdata_wb[0] & ~internal_dbg_halt_mode_f3;\n\n   assign mstatus_ns[1:0] = ( ({2{~wr_mstatus_wb & exc_or_int_valid_wb}} & {(mstatus[MSTATUS_MIE] | set_mie_pmu_fw_halt), 1'b0}) |\n                              ({2{ wr_mstatus_wb & exc_or_int_valid_wb}} & {dec_i0_csr_wrdata_wb[3], 1'b0}) |\n                              ({2{mret_wb & ~exc_or_int_valid_wb}} & {1'b1, mstatus[1]}) |\n                              ({2{set_mie_pmu_fw_halt & ~exc_or_int_valid_wb}} & {mstatus[1], 1'b1}) |\n                              ({2{wr_mstatus_wb & ~exc_or_int_valid_wb}} & {dec_i0_csr_wrdata_wb[7], dec_i0_csr_wrdata_wb[3]}) |\n                              ({2{~wr_mstatus_wb & ~exc_or_int_valid_wb & ~mret_wb & ~set_mie_pmu_fw_halt}} & mstatus[1:0]) );\n\n   // gate MIE if we are single stepping and DCSR[STEPIE] is off\n   assign mstatus_mie_ns = mstatus_ns[MSTATUS_MIE] & (~dcsr_single_step_running_f | dcsr[DCSR_STEPIE]);\n\n   // ----------------------------------------------------------------------\n   // MTVEC (RW)\n   // [31:2] BASE : Trap vector base address\n   // [1] - Reserved, not implemented, reads zero\n   // [0]  MODE : 0 = Direct, 1 = Asyncs are vectored to BASE + (4 * CAUSE)\n   localparam MTVEC         = 12'h305;\n\n   assign wr_mtvec_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MTVEC);\n   assign mtvec_ns[30:0] = {dec_i0_csr_wrdata_wb[31:2], dec_i0_csr_wrdata_wb[0]} ;\n   rvdffe #(31)  mtvec_ff (.*, .en(wr_mtvec_wb), .din(mtvec_ns[30:0]), .dout(mtvec[30:0]));\n\n   // ----------------------------------------------------------------------\n   // MIP (RW)\n   //\n   // [30] MCEIP  : (RO) M-Mode Correctable Error interrupt pending\n   // [29] MITIP0 : (RO) M-Mode Internal Timer0 interrupt pending\n   // [28] MITIP1 : (RO) M-Mode Internal Timer1 interrupt pending\n   // [11] MEIP   : (RO) M-Mode external interrupt pending\n   // [7]  MTIP   : (RO) M-Mode timer interrupt pending\n   // [3]  MSIP   : (RO) M-Mode software interrupt pending\n   localparam MIP           = 12'h344;\n\n   assign ce_int = (mdccme_ce_req | miccme_ce_req | mice_ce_req);\n\n   assign mip_ns[5:0] = {ce_int, dec_timer_t0_pulse, dec_timer_t1_pulse, mexintpend, timer_int_sync, soft_int_sync};\n\n   // ----------------------------------------------------------------------\n   // MIE (RW)\n   // [30] MCEIE  : (RO) M-Mode Correctable Error interrupt enable\n   // [29] MITIE0 : (RO) M-Mode Internal Timer0 interrupt enable\n   // [28] MITIE1 : (RO) M-Mode Internal Timer1 interrupt enable\n   // [11] MEIE   : (RW) M-Mode external interrupt enable\n   // [7]  MTIE   : (RW) M-Mode timer interrupt enable\n   // [3]  MSIE   : (RW) M-Mode software interrupt enable\n   localparam MIE           = 12'h304;\n\n   assign wr_mie_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MIE);\n   assign mie_ns[5:0] = wr_mie_wb ? {dec_i0_csr_wrdata_wb[30:28], dec_i0_csr_wrdata_wb[11], dec_i0_csr_wrdata_wb[7], dec_i0_csr_wrdata_wb[3]} : mie[5:0];\n   rvdff #(6)  mie_ff (.*, .clk(csr_wr_clk), .din(mie_ns[5:0]), .dout(mie[5:0]));\n\n\n   // ----------------------------------------------------------------------\n   // MCYCLEL (RW)\n   // [31:0] : Lower Cycle count\n\n   localparam MCYCLEL       = 12'hb00;\n\n   assign kill_ebreak_count_wb = ebreak_to_debug_mode_wb & dcsr[DCSR_STOPC];\n\n   assign wr_mcyclel_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MCYCLEL);\n\n   assign mcyclel_cout_in = ~(kill_ebreak_count_wb | (dec_tlu_dbg_halted & dcsr[DCSR_STOPC]) |\n                              dec_tlu_pmu_fw_halted | mcountinhibit[0] | ~mhartstart_csr);\n\n   // split for power\n   assign {mcyclela_cout, mcyclel_inc[7:0]}  = mcyclel[7:0] +  {7'b0, 1'b1};\n   assign {mcyclel_cout,  mcyclel_inc[31:8]} = mcyclel[31:8] + {23'b0, mcyclela_cout};\n\n   assign mcyclel_ns[31:0] = wr_mcyclel_wb ? dec_i0_csr_wrdata_wb[31:0] : mcyclel_inc[31:0];\n\n   rvdffe #(24) mcyclel_bff      (.*, .clk(free_l2clk), .en(wr_mcyclel_wb | (mcyclela_cout & mcyclel_cout_in)),    .din(mcyclel_ns[31:8]), .dout(mcyclel[31:8]));\n   rvdffe #(8)  mcyclel_aff      (.*, .clk(free_l2clk), .en(wr_mcyclel_wb | mcyclel_cout_in),  .din(mcyclel_ns[7:0]),  .dout(mcyclel[7:0]));\n\n   // ----------------------------------------------------------------------\n   // MCYCLEH (RW)\n   // [63:32] : Higher Cycle count\n   // Chained with mcyclel. Note: mcyclel overflow due to a mcycleh write gets ignored.\n\n   localparam MCYCLEH       = 12'hb80;\n\n   assign wr_mcycleh_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MCYCLEH);\n\n   assign {mcycleh_cout_nc, mcycleh_inc[31:0]} = mcycleh[31:0] + {31'b0, mcyclel_cout_f};\n   assign mcycleh_ns[31:0] = wr_mcycleh_wb ? dec_i0_csr_wrdata_wb[31:0] : mcycleh_inc[31:0];\n\n   rvdffe #(32)  mcycleh_ff (.*, .clk(free_l2clk), .en(wr_mcycleh_wb | mcyclel_cout_f), .din(mcycleh_ns[31:0]), .dout(mcycleh[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MINSTRETL (RW)\n   // [31:0] : Lower Instruction retired count\n   // From the spec \"Some CSRs, such as the instructions retired counter, instret, may be modified as side effects\n   // of instruction execution. In these cases, if a CSR access instruction reads a CSR, it reads the\n   // value prior to the execution of the instruction. If a CSR access instruction writes a CSR, the\n   // update occurs after the execution of the instruction. In particular, a value written to instret by\n   // one instruction will be the value read by the following instruction (i.e., the increment of instret\n   // caused by the first instruction retiring happens before the write of the new value).\"\n   localparam MINSTRETL     = 12'hb02;\n\n   assign i0_valid_no_ebreak_ecall_wb = i0_valid_wb & ~(ebreak_wb | ecall_wb | ebreak_to_debug_mode_wb) & ~mcountinhibit[2];\n\n   assign wr_minstretl_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MINSTRETL);\n\n   assign {minstretl_couta, minstretl_inc[7:0]} = minstretl[7:0] + {7'b0,i0_valid_no_ebreak_ecall_wb} + {7'b0,i1_valid_wb & ~mcountinhibit[2]};\n   assign {minstretl_cout, minstretl_inc[31:8]} = minstretl[31:8] + {23'b0, minstretl_couta};\n\n   assign minstret_enable = (i0_valid_no_ebreak_ecall_wb | i1_valid_wb);\n\n   assign minstretl_cout_ns = minstretl_cout & ~wr_minstreth_wb & ~dec_tlu_dbg_halted;\n\n   assign minstretl_ns[31:0] = wr_minstretl_wb ? dec_i0_csr_wrdata_wb[31:0] : minstretl_inc[31:0];\n   rvdffe #(24)  minstretl_bff (.*, .en(wr_minstretl_wb | (minstretl_couta & minstret_enable)),\n                                .din(minstretl_ns[31:8]), .dout(minstretl[31:8]));\n   rvdffe #(8)   minstretl_aff (.*, .en(minstret_enable | wr_minstretl_wb),\n                                .din(minstretl_ns[7:0]),  .dout(minstretl[7:0]));\n\n\n   assign minstretl_read[31:0] = minstretl[31:0];\n   // ----------------------------------------------------------------------\n   // MINSTRETH (RW)\n   // [63:32] : Higher Instret count\n   // Chained with minstretl. Note: minstretl overflow due to a minstreth write gets ignored.\n\n   localparam MINSTRETH     = 12'hb82;\n\n   assign wr_minstreth_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MINSTRETH);\n\n   assign {minstreth_cout_nc, minstreth_inc[31:0]} = minstreth[31:0] + {31'b0, minstretl_cout_f};\n   assign minstreth_ns[31:0] = wr_minstreth_wb ? dec_i0_csr_wrdata_wb[31:0] : minstreth_inc[31:0];\n   rvdffe #(32)  minstreth_ff (.*, .en((minstret_enable_f & minstretl_cout_f) | wr_minstreth_wb), .din(minstreth_ns[31:0]), .dout(minstreth[31:0]));\n\n   assign minstreth_read[31:0] = minstreth_inc[31:0];\n\n   // ------------------------------------"}
{"text": "----------------------------------\n   // MSCRATCH (RW)\n   // [31:0] : Scratch register\n   localparam MSCRATCH      = 12'h340;\n\n   assign wr_mscratch_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MSCRATCH);\n\n   rvdffe #(32)  mscratch_ff (.*, .en(wr_mscratch_wb), .din(dec_i0_csr_wrdata_wb[31:0]), .dout(mscratch[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MEPC (RW)\n   // [31:1] : Exception PC\n   localparam MEPC          = 12'h341;\n\n   // NPC\n\n   assign sel_exu_npc_e4 = ~dec_tlu_dbg_halted & ~tlu_flush_lower_wb & (tlu_i0_valid_e4 | tlu_i1_valid_e4) & ~(tlu_i1_valid_e4 & (lsu_i0_rfnpc_dc4 | iccm_sbecc_e4 | ic_perr_e4));\n   assign sel_i0_npc_e4 = ~dec_tlu_dbg_halted & ~tlu_flush_lower_wb & tlu_i0_valid_e4 & lsu_i0_rfnpc_dc4 & tlu_i1_valid_e4;\n   assign sel_flush_npc_e4 = ~dec_tlu_dbg_halted & tlu_flush_lower_wb & ~dec_tlu_flush_noredir_wb;\n   assign sel_hold_npc_e4 = ~sel_exu_npc_e4 & ~sel_flush_npc_e4 & ~sel_i0_npc_e4;\n\n\n   assign npc_e4[31:1] = ( ({31{sel_exu_npc_e4}} & exu_npc_e4[31:1]) |\n                           ({31{sel_i0_npc_e4}} & dec_tlu_i1_pc_e4[31:1]) |\n                           ({31{~mpc_reset_run_req & reset_allowed}} & rst_vec[31:1]) | // init to reset vector for mpc halt on reset case\n                           ({31{(sel_flush_npc_e4)}} & tlu_flush_path_wb[31:1]) |\n                           ({31{(sel_hold_npc_e4)}} & npc_wb[31:1]) );\n\n   rvdffpcie #(31)  npwbc_ff (.*, .en(sel_exu_npc_e4 | sel_flush_npc_e4 | reset_allowed), .din(npc_e4[31:1]), .dout(npc_wb[31:1]));\n\n   // PC has to be captured for exceptions and interrupts. For MRET, we could execute it and then take an\n   // interrupt before the next instruction.\n   assign pc0_valid_e4 = ~dec_tlu_dbg_halted & tlu_i0_valid_e4;\n   assign pc1_valid_e4 = ~dec_tlu_dbg_halted & tlu_i1_valid_e4 & ~lsu_i0_exc_dc4 & ~rfpc_i0_e4 & ~inst_acc_e4 & ~i0_trigger_hit_e4;\n\n   assign pc_e4[31:1] = ( ({31{ pc0_valid_e4 & ~pc1_valid_e4}} & dec_tlu_i0_pc_e4[31:1]) |\n                          ({31{ pc1_valid_e4}} & dec_tlu_i1_pc_e4[31:1]) |\n                          ({31{~pc0_valid_e4 & ~pc1_valid_e4}} & pc_wb[31:1]));\n\n   rvdffpcie #(31)  pwbc_ff (.*, .en(pc0_valid_e4 | pc1_valid_e4), .din(pc_e4[31:1]), .dout(pc_wb[31:1]));\n\n   assign wr_mepc_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MEPC);\n\n   assign mepc_ns[31:1] = ( ({31{i0_exception_valid_wb | lsu_exc_valid_wb | mepc_trigger_hit_sel_pc_wb}} & pc_wb[31:1]) |\n                            ({31{interrupt_valid_wb}} & npc_wb[31:1]) |\n                            ({31{wr_mepc_wb & ~exc_or_int_valid_wb}} & dec_i0_csr_wrdata_wb[31:1]) |\n                            ({31{~wr_mepc_wb & ~exc_or_int_valid_wb}} & mepc[31:1]) );\n\n\n   rvdffe #(31)  mepc_ff (.*, .en(i0_exception_valid_wb | lsu_exc_valid_wb | mepc_trigger_hit_sel_pc_wb | interrupt_valid_wb | wr_mepc_wb), .din(mepc_ns[31:1]), .dout(mepc[31:1]));\n\n   // ----------------------------------------------------------------------\n   // MCAUSE (RW)\n   // [31:0] : Exception Cause\n   localparam MCAUSE        = 12'h342;\n\n   assign wr_mcause_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MCAUSE);\n   assign mcause_sel_nmi_store = exc_or_int_valid_wb & take_nmi_wb & nmi_lsu_store_type_f;\n   assign mcause_sel_nmi_load = exc_or_int_valid_wb & take_nmi_wb & nmi_lsu_load_type_f;\n   assign mcause_sel_nmi_ext = exc_or_int_valid_wb & take_nmi_wb & nmi_fir_type_f;\n\n\n   assign mcause_fir_error_type[1:0] = {&lsu_fir_error_d1[1:0], lsu_fir_error_d1[1] & ~lsu_fir_error_d1[0]};\n\n   assign mcause_ns[31:0] = ( ({32{mcause_sel_nmi_store}} & {32'hf000_0000}) |\n                              ({32{mcause_sel_nmi_load}} & {32'hf000_0001}) |\n                              ({32{mcause_sel_nmi_ext}} & {28'hf000_100, 2'b0, mcause_fir_error_type[1:0]}) |\n                              ({32{exc_or_int_valid_wb & ~take_nmi_wb}} & {interrupt_valid_wb, 26'b0, exc_cause_wb[4:0]}) |\n                              ({32{wr_mcause_wb & ~exc_or_int_valid_wb}} & dec_i0_csr_wrdata_wb[31:0]) |\n                              ({32{~wr_mcause_wb & ~exc_or_int_valid_wb}} & mcause[31:0]) );\n\n   rvdffe #(32)  mcause_ff (.*, .en(exc_or_int_valid_wb | wr_mcause_wb), .din(mcause_ns[31:0]), .dout(mcause[31:0]));\n   // ----------------------------------------------------------------------\n   // MSCAUSE (RW)\n   // [2:0] : Secondary exception Cause\n   localparam MSCAUSE       = 12'h7ff;\n\n   assign wr_mscause_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MSCAUSE);\n   assign ifu_mscause[3:0]  =  (icaf_type_wb[1:0] == 2'b00) ? 4'b1001 :\n                               {2'b00 , icaf_type_wb[1:0]} ;\n\n\n   assign mscause_type[3:0] = ( ({4{lsu_exc_valid_wb}} & lsu_error_mscause_wb[3:0]) |\n                                ({4{trigger_hit_wb}} & 4'b0001) |\n                                ({4{ebreak_wb}} & 4'b0010) |\n                                ({4{inst_acc_wb}} & ifu_mscause[3:0])\n                                );\n\n\n   assign mscause_ns[3:0] = ( ({4{exc_or_int_valid_wb}} & mscause_type[3:0]) |\n                              ({4{ wr_mscause_wb & ~exc_or_int_valid_wb}} & dec_i0_csr_wrdata_wb[3:0]) |\n                              ({4{~wr_mscause_wb & ~exc_or_int_valid_wb}} & mscause[3:0])\n                             );\n\n   rvdff #(4)  mscause_ff (.*, .clk(e4e5_int_clk), .din(mscause_ns[3:0]), .dout(mscause[3:0]));\n\n   // ----------------------------------------------------------------------\n   // MTVAL (RW)\n   // [31:0] : Exception address if relevant\n   localparam MTVAL         = 12'h343;\n\n   assign wr_mtval_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MTVAL);\n   assign mtval_capture_pc_wb = exc_or_int_valid_wb & (ebreak_wb | (inst_acc_wb & ~inst_acc_second_wb) | mepc_trigger_hit_sel_pc_wb) & ~take_nmi_wb;\n   assign mtval_capture_pc_plus2_wb = exc_or_int_valid_wb & (inst_acc_wb & inst_acc_second_wb) & ~take_nmi_wb;\n   assign mtval_capture_inst_wb = exc_or_int_valid_wb & illegal_wb & ~take_nmi_wb;\n   assign mtval_capture_lsu_wb = exc_or_int_valid_wb & lsu_exc_valid_wb & ~take_nmi_wb;\n   assign mtval_clear_wb = exc_or_int_valid_wb & ~mtval_capture_pc_wb & ~mtval_capture_inst_wb & ~mtval_capture_lsu_wb & ~mepc_trigger_hit_sel_pc_wb;\n\n\n   assign mtval_ns[31:0] = (({32{mtval_capture_pc_wb}} & {pc_wb[31:1], 1'b0}) |\n                            ({32{mtval_capture_pc_plus2_wb}} & {pc_wb[31:1] + 31'b1, 1'b0}) |\n                            ({32{mtval_capture_inst_wb}} & dec_illegal_inst[31:0]) |\n                            ({32{mtval_capture_lsu_wb}} & lsu_error_pkt_addr_wb[31:0]) |\n                            ({32{wr_mtval_wb & ~interrupt_valid_wb}} & dec_i0_csr_wrdata_wb[31:0]) |\n                            ({32{~take_nmi_wb & ~wr_mtval_wb & ~mtval_capture_pc_wb & ~mtval_capture_inst_wb & ~mtval_clear_wb & ~mtval_capture_lsu_wb}} & mtval[31:0]) );\n\n\n   rvdffe #(32)  mtval_ff (.*, .en(tlu_flush_lower_wb | wr_mtval_wb), .din(mtval_ns[31:0]), .dout(mtval[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MCPC (RW) Pause counter\n   // [31:0] : Reads 0x0, decs in the wb register in decode_ctl\n\n   localparam MCPC          = 12'h7c2;\n   assign tlu_wr_pause_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MCPC) & ~interrupt_valid_wb & ~ext_int_freeze_d1;\n   // ----------------------------------------------------------------------\n   // MDEAU (WAR0)\n   // [31:0] : Dbus Error Address Unlock register\n   //\n   localparam MDEAU         = 12'hbc0;\n\n   assign wr_mdeau_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MDEAU);\n\n\n   // ----------------------------------------------------------------------\n   // MDSEAC (R)\n   // [31:0] : Dbus Store Error Address Capture register\n   //\n   localparam MDSEAC        = 12'hfc0;\n\n   // only capture error bus if the MDSEAC reg is not locked\n   assign mdseac_locked_ns = mdseac_en | (mdseac_locked_f & ~wr_mdeau_wb);\n\n   assign mdseac_en = (lsu_imprecise_error_store_any | lsu_imprecise_error_load_any) & ~nmi_int_detected_f & ~mdseac_locked_f;\n\n   rvdffe #(32)  mdseac_ff (.*, .en(mdseac_en), .din(lsu_imprecise_error_addr_any[31:0]), .dout(mdseac[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MPMC (R0W1)\n   // [0:0] : FW halt\n   //\n   localparam MPMC          = 12'h7c6;\n   assign wr_mpmc_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MPMC);\n\n   // allow the cycle of the dbg halt flush that contains the wr_mpmc_wb to\n   // set the mstatus bit potentially, use delayed version of internal dbg halt.\n   // Kill the req when we commit the fwhalt csr write and take an int\n   assign fw_halt_req = wr_mpmc_wb & dec_i0_csr_wrdata_wb[0] & ~internal_dbg_halt_mode_f3 & ~ext_int_freeze_d1 & ~interrupt_valid_wb;\n\n   assign mpmc_b_ns[1] = wr_mpmc_wb ? ~dec_i0_csr_wrdata_wb[1] : ~mpmc[1];\n   rvdff #(1)  mpmc_ff (.*, .clk(csr_wr_clk), .din(mpmc_b_ns[1]), .dout(mpmc_b[1]));\n   assign mpmc[1] = ~mpmc_b[1];\n\n   // ----------------------------------------------------------------------\n   // MEIVT (External Interrupt Vector Table (R/W))\n   // [31:10]: Base address (R/W)\n   // [9:0]  : Reserved, reads 0x0\n   localparam MEIVT         = 12'hbc8;\n\n   assign wr_meivt_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MEIVT);\n\n   rvdffe #(22)  meivt_ff (.*, .en(wr_meivt_wb), .din(dec_i0_csr_wrdata_wb[31:10]), .dout(meivt[31:10]));\n\n   // ----------------------------------------------------------------------\n   // MEIHAP (External Interrupt Handler Access Pointer (R))\n   // [31:10]: Base address (R/W)\n   // [9:2]  : ClaimID (R)\n   // [1:0]  : Reserved, 0x0\n   localparam MEIHAP        = 12'hfc8;\n\n   assign wr_meihap_wb = wr_meicpct_wb;\n\n   rvdffe #(8)  meihap_ff (.*, .clk(free_l2clk), .en(wr_meihap_wb), .din(pic_claimid[7:0]), .dout(meihap[9:2]));\n   assign dec_tlu_meihap[31:2] = {meivt[31:10], meihap[9:2]};\n\n   // ----------------------------------------------------------------------\n   // MEICURPL (R/W)\n   // [31:4] : Reserved (read 0x0)\n   // [3:0]  : CURRPRI - Priority level of current interrupt service routine (R/W)\n   localparam MEICURPL      = 12'hbcc;\n\n   assign wr_meicurpl_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MEICURPL);\n   assign meicurpl_ns[3:0] = wr_meicurpl_wb ? dec_i0_csr_wrdata_wb[3:0] : meicurpl[3:0];\n\n   rvdff #(4)  meicurpl_ff (.*, .clk(csr_wr_clk), .din(meicurpl_ns[3:0]), .dout(meicurpl[3:0]));\n\n   // PIC needs this reg\n   assign tlu_meicurpl[3:0] = meicurpl[3:0];\n\n\n   // ----------------------------------------------------------------------\n   // MEICIDPL (R/W)\n   // [31:4] : Reserved (read 0x0)\n   // [3:0]  : External Interrupt Claim ID's Priority Level Register\n   localparam MEICIDPL      = 12'hbcb;\n\n   assign wr_meicidpl_wb = (dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MEICIDPL)) | take_ext_int_start;\n\n   assign meicidpl_ns[3:0] = wr_meicpct_wb ? pic_pl[3:0] : (wr_meicidpl_wb ? dec_i0_csr_wrdata_wb[3:0] : meicidpl[3:0]);\n\n\n   // ----------------------------------------------------------------------\n   // MEICPCT (Capture CLAIMID in MEIHAP and PL in MEICIDPL\n   // [31:1] : Reserved (read 0x0)\n   // [0]    : Capture (W1, Read 0)\n   localparam MEICPCT       = 12'hbca;\n\n   assign wr_meicpct_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MEICPCT) | take_ext_int_start;\n\n   // ----------------------------------------------------------------------\n   // MEIPT (External Interrupt Priority Threshold)\n   // [31:4] : Reserved (read 0x0)\n   // [3:0]  : PRITHRESH\n   localparam MEIPT         = 12'hbc9;\n\n   assign wr_meipt_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MEIPT);\n   assign meipt_ns[3:0] = wr_meipt_wb ? dec_i0_csr_wrdata_wb[3:0] : meipt[3:0];\n\n\n   // to PIC\n   assign tlu_meipt[3:0] = meipt[3:0];\n   // ----------------------------------------------------------------------\n   // DCSR (R/W) (Only accessible in debug mode)\n   // [31:28] : xdebugver (hard coded to 0x4) RO\n   // [27:16] : 0x0, reserved\n   // [15]    : ebreakm\n   // [14]    : 0x0, reserved\n   // [13]    : ebreaks (0x0 for this core)\n   // [12]    : ebreaku (0x0 for this core)\n   // [11]    : stepie\n   // [10]    : stopcount\n   // [9]     : 0x0 //stoptime\n   // [8:6]   : cause (RO)\n   // [5:4]   : 0x0, reserved\n   // [3]     : nmip\n   // [2]     : step\n   // [1:0]   : prv (0x3 for this core)\n   //\n   localparam DCSR          = 12'h7b0;\n\n   // RV has clarified that 'priority 4' in the spec means top priority.\n   // 4. single step. 3. Debugger request. 2. Ebreak. 1. Trigger.\n\n   // RV debug spec indicates a cause priority change for trigger hits during single step.\n   assign trigger_hit_for_dscr_cause_wb = trigger_hit_dmode_wb | (trigger_hit_wb & dcsr_single_step_done_f);\n\n   assign dcsr_cause[8:6] = ( ({3{dcsr_single_step_done_f & ~ebreak_to_debug_mode_wb & ~trigger_hit_for_dscr_cause_wb & ~debug_halt_req}} & 3'b100) |\n                              ({3{debug_halt_req & ~ebreak_to_debug_mode_wb & ~trigger_hit_for_dscr_cause_wb}} &  3'b011) |\n                              ({3{ebreak_to_debug_mode_wb & ~trigger_hit_for_dscr_cause_wb}} &  3'b001) |\n                              ({3{trigger_hit_for_dscr_cause_wb}} & 3'b010));\n\n   assign wr_dcsr_wb = allow_dbg_halt_csr_write & dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == DCSR);\n\n\n\n  // Multiple halt enter requests can happen before we are halted.\n  // We have to continue to upgrade based on dcsr_cause priority but we can't downgrade.\n   assign dcsr_cause_upgradeable = internal_dbg_halt_mode_f & (dcsr[8:6] == 3'b011);\n   assign enter_debug_halt_req_le = enter_debug_halt_req & (~dbg_tlu_halted | dcsr_cause_upgradeable);\n\n   assign nmi_in_debug_mode = nmi_int_detected_f & internal_dbg_halt_mode_f;\n   assign dcsr_ns[15:2] = enter_debug_halt_req_le ? {dcsr[15:9], dcsr_cause[8:6], dcsr[5:2]} :\n                          (wr_dcsr_wb ? {dec_i0_csr_wrdata_wb[15], 3'b0, dec_i0_csr_wrdata_wb[11:10], 1'b0, dcsr[8:6], 2'b00, nmi_in_debug_mode | dcsr[3], dec_i0_csr_wrdata_wb[2]} :\n                           {dcsr[15:4], nmi_in_debug_mode, dcsr[2]});\n\n   rvdffe #(14)  dcsr_ff (.*, .clk(free_l2clk), .en(enter_debug_halt_req_le | wr_dcsr_wb | internal_dbg_halt_mode | take_nmi_wb), .din(dcsr_ns[15:2]), .dout(dcsr[15:2]));\n\n   assign tlu_dcsr_ss = dcsr[2];\n\n   // ----------------------------------------------------------------------\n   // DPC (R/W) (Only accessible in debug mode)\n   // [31:0] : Debug PC\n   localparam DPC           = 12'h7b1;\n\n   assign wr_dpc_wb = allow_dbg_halt_csr_write & dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == DPC);\n   assign dpc_capture_npc = dbg_tlu_halted & ~dbg_tlu_halted_f & ~request_debug_mode_done_f;\n   assign dpc_capture_pc = request_debug_mode_wb;\n\n   assign dpc_ns[31:1] = ( ({31{~dpc_capture_pc & ~dpc_capture_npc & wr_dpc_wb}} & dec_i0_csr_wrdata_wb[31:1]) |\n                           ({31{dpc_capture_pc}} & pc_wb[31:1]) |\n                           ({31{~dpc_capture_pc & dpc_capture_npc}} & npc_wb[31:1]) );\n\n   rvdffe #(31)  dpc_ff (.*, .en(wr_dpc_wb | dpc_capture_pc | dpc_capture_npc), .din(dpc_ns[31:1]), .dout(dpc[31:1]));\n\n\n    // ----------------------------------------------------------------------\n   // DICAWICS (R/W) (Only accessible in debug mode)\n   // [31:25] : Reserved\n   // [24]    : Array select, 0 is data, 1 is tag\n   // [23:22] : Reserved\n   // [21:20] : Way select\n   // [19:17] : Reserved\n   // [16:3]  : Index\n   // [2:0]   : Reserved\n   localparam DICAWICS      = 12'h7c8;\n\n   assign dicawics_ns[16:0] = {dec_i0_csr_wrdata_wb[24], dec_i0_csr_wrdata_wb[21:20], dec_i0_csr_wrdata_wb[16:3]};\n   assign wr_dicawics_wb = allow_dbg_halt_csr_write & dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == DICAWICS);\n\n   rvdffe #(17)  dicawics_ff (.*, .en(wr_dicawics_wb), .din(dicawics_ns[16:0]), .dout(dicawics[16:0]));\n\n   // ----------------------------------------------------------------------\n   // DICAD0 (R/W) (Only accessible in debug mode)\n   //\n   // If dicawics[array] is 0\n   // [31:0]  : inst data\n   //\n   // If dicawics[array] is 1\n   // [31:16] : Tag\n   // [15:7]  : Reserved\n   // [6:4]   : LRU\n   // [3:1]   : Reserved\n   // [0]     : Valid\n   localparam DICAD0        = 12'h7c9;\n\n   assign dicad0_ns[31:0] = wr_dicad0_wb ? dec_i0_csr_wrdata_wb[31:0] : ifu_ic_debug_rd_data[31:0];\n\n   assign wr_dicad0_wb = allow_dbg_halt_csr_write & dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == DICAD0);\n\n   rvdffe #(32)  dicad0_ff (.*, .en(wr_dicad0_wb | ifu_ic_debug_rd_data_valid), .din(dicad0_ns[31:0]), .dout(dicad0[31:0]));\n\n   // ----------------------------------------------------------------------\n   // DICAD0H (R/W) (Only accessible in debug mode)\n   //\n   // If dicawics[array] is 0\n   // [63:32]  : inst data\n   //\n   localparam DICAD0H       = 12'h7cc;\n\n   assign dicad0h_ns[31:0] = wr_dicad0h_wb ? dec_i0_csr_wrdata_wb[31:0] : ifu_ic_debug_rd_data[63:32];\n\n   assign wr_dicad0h_wb = allow_dbg_halt_csr_write & dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == DICAD0H);\n\n   rvdffe #(32)  dicad0h_ff (.*, .en(wr_dicad0h_wb | ifu_ic_debug_rd_data_valid), .din(dicad0h_ns[31:0]), .dout(dicad0h[31:0]));\n\n\n\nif (pt.ICACHE_ECC == 1) begin\n   // ----------------------------------------------------------------------\n   // DICAD1 (R/W) (Only accessible in debug mode)\n   // [6:0]     : ECC\n   localparam DICAD1        = 12'h7ca;\n\n   assign dicad1_ns[6:0] = wr_dicad1_wb ? dec_i0_csr_wrdata_wb[6:0] : ifu_ic_debug_rd_data[70:64];\n\n   assign wr_dicad1_wb = allow_dbg_halt_csr_write & dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == DICAD1);\n\n   rvdffe #(.WIDTH(7), .OVERRIDE(1))  dicad1_ff (.*, .clk(free_l2clk), .en(wr_dicad1_wb | ifu_ic_debug_rd_data_valid), .din(dicad1_ns[6:0]), .dout(dicad1_raw[6:0]));\n\n   assign dicad1[31:0] = {25'b0, dicad1_raw[6:0]};\nend\nelse begin\n   // ----------------------------------------------------------------------\n   // DICAD1 (R/W) (Only accessible in debug mode)\n   // [3:0]     : Parity\n   localparam DICAD1        = 12'h7ca;\n\n   assign dicad1_ns[3:0] = wr_dicad1_wb ? dec_i0_csr_wrdata_wb[3:0] : ifu_ic_debug_rd_data[67:64];\n\n   assign wr_dicad1_wb = allow_dbg_halt_csr_write & dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == DICAD1);\n\n   rvdffs #(4)  dicad1_ff (.*, .clk(active_clk), .en(wr_dicad1_wb | ifu_ic_debug_rd_data_valid), .din(dicad1_ns[3:0]), .dout(dicad1_raw[3:0]));\n\n   assign dicad1[31:0] = {28'b0, dicad1_raw[3:0]};\nend\n   // ----------------------------------------------------------------------\n   // DICAGO (R/W) (Only accessible in debug mode)\n   // [0]     : Go\n   localparam DICAGO        = 12'h7cb;\n\nif (pt.ICACHE_ECC == 1) begin\n   assign dec_tlu_ic_diag_pkt.icache_wrdata[70:0] = {      dicad1[6:0], dicad0h[31:0], dicad0[31:0]};\nend\nelse begin\n   assign dec_tlu_ic_diag_pkt.icache_wrdata[70:0] = {3'b0, dicad1[3:0], dicad0h[31:0], dicad0[31:0]};\nend\n   assign dec_tlu_ic_diag_pkt.icache_dicawics[16:0] = dicawics[16:0];\n\n   assign icache_rd_valid = allow_dbg_halt_csr_write & dec_i0_csr_any_unq_d & dec_i0_decode_d & ~dec_i0_csr_wen_unq_d & (dec_i0_csr_rdaddr_d[11:0] == DICAGO);\n   assign icache_wr_valid = allow_dbg_halt_csr_write & dec_i0_csr_any_unq_d & dec_i0_decode_d & dec_i0_csr_wen_unq_d & (dec_i0_csr_rdaddr_d[11:0] == DICAGO);\n\n   assign dec_tlu_ic_diag_pkt.icache_rd_valid = icache_rd_valid_f;\n   assign dec_tlu_ic_diag_pkt.icache_wr_valid = icache_wr_valid_f;\n\n   // ----------------------------------------------------------------------\n   // MTSEL (R/W)\n   // [1:0] : Trigger select : 00, 01, 10 are data/address triggers. 11 is inst count\n   localparam MTSEL         = 12'h7a0;\n\n   assign wr_mtsel_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MTSEL);\n   assign mtsel_ns[1:0] = wr_mtsel_wb ? {dec_i0_csr_wrdata_wb[1:0]} : mtsel[1:0];\n\n   rvdff #(2)  mtsel_ff (.*, .clk(csr_wr_clk), .din(mtsel_ns[1:0]), .dout(mtsel[1:0]));\n\n   // ----------------------------------------------------------------------\n   // MTDATA1 (R/W)\n   // [31:0] : Trigger Da"}
{"text": "ta 1\n   localparam MTDATA1       = 12'h7a1;\n\n   // for triggers 0, 1, 2 and 3 aka Match Control\n   // [31:28] : type, hard coded to 0x2\n   // [27]    : dmode\n   // [26:21] : hard coded to 0x1f\n   // [20]    : hit\n   // [19]    : select (0 - address, 1 - data)\n   // [18]    : timing, always 'before', reads 0x0\n   // [17:12] : action, bits  [17:13] not implemented and reads 0x0\n   // [11]    : chain\n   // [10:7]  : match, bits [10:8] not implemented and reads 0x0\n   // [6]     : M\n   // [5:3]   : not implemented, reads 0x0\n   // [2]     : execute\n   // [1]     : store\n   // [0]     : load\n   //\n   // decoder ring\n   // [27]    : => 9\n   // [20]    : => 8\n   // [19]    : => 7\n   // [12]    : => 6\n   // [11]    : => 5\n   // [7]     : => 4\n   // [6]     : => 3\n   // [2]     : => 2\n   // [1]     : => 1\n   // [0]     : => 0\n\n\n   // don't allow setting load-data.\n   assign tdata_load = dec_i0_csr_wrdata_wb[0] & ~dec_i0_csr_wrdata_wb[19];\n   // don't allow setting execute-data.\n   assign tdata_opcode = dec_i0_csr_wrdata_wb[2] & ~dec_i0_csr_wrdata_wb[19];\n   // don't allow clearing DMODE and action=1\n   assign tdata_action = (dec_i0_csr_wrdata_wb[27] & dbg_tlu_halted_f) & dec_i0_csr_wrdata_wb[12];\n\n   // Chain bit has conditions: WARL for triggers without chains. Force to zero if dmode is 0 but next trigger dmode is 1.\n   assign tdata_chain = mtsel[0] ? 1'b0 : // triggers 1 and 3 chain bit is always zero\n                        mtsel[1] ?  dec_i0_csr_wrdata_wb[11] & ~(mtdata1_t3[MTDATA1_DMODE] & ~dec_i0_csr_wrdata_wb[27]) : // trigger 2\n                                    dec_i0_csr_wrdata_wb[11] & ~(mtdata1_t1[MTDATA1_DMODE] & ~dec_i0_csr_wrdata_wb[27]);  // trigger 0\n\n   // Kill mtdata1 write if dmode=1 but prior trigger has dmode=0/chain=1. Only applies to T1 and T3\n   assign tdata_kill_write = mtsel[1] ? dec_i0_csr_wrdata_wb[27] & (~mtdata1_t2[MTDATA1_DMODE] & mtdata1_t2[MTDATA1_CHAIN]) : // trigger 3\n                                        dec_i0_csr_wrdata_wb[27] & (~mtdata1_t0[MTDATA1_DMODE] & mtdata1_t0[MTDATA1_CHAIN]) ; // trigger 1\n\n   assign tdata_wrdata_wb[9:0]  = {dec_i0_csr_wrdata_wb[27] & dbg_tlu_halted_f,\n                                   dec_i0_csr_wrdata_wb[20:19],\n                                   tdata_action,\n                                   tdata_chain,\n                                   dec_i0_csr_wrdata_wb[7:6],\n                                   tdata_opcode,\n                                   dec_i0_csr_wrdata_wb[1],\n                                   tdata_load};\n\n   // If the DMODE bit is set, tdata1 can only be updated in debug_mode\n   assign wr_mtdata1_t0_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MTDATA1) & (mtsel[1:0] == 2'b0) & (~mtdata1_t0[MTDATA1_DMODE] | dbg_tlu_halted_f);\n   assign mtdata1_t0_ns[9:0] = wr_mtdata1_t0_wb ? tdata_wrdata_wb[9:0] :\n                                {mtdata1_t0[9], update_hit_bit_wb[0] | mtdata1_t0[8], mtdata1_t0[7:0]};\n\n   assign wr_mtdata1_t1_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MTDATA1) & (mtsel[1:0] == 2'b01) & (~mtdata1_t1[MTDATA1_DMODE] | dbg_tlu_halted_f) & ~tdata_kill_write;\n   assign mtdata1_t1_ns[9:0] = wr_mtdata1_t1_wb ? tdata_wrdata_wb[9:0] :\n                                {mtdata1_t1[9], update_hit_bit_wb[1] | mtdata1_t1[8], mtdata1_t1[7:0]};\n\n   assign wr_mtdata1_t2_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MTDATA1) & (mtsel[1:0] == 2'b10) & (~mtdata1_t2[MTDATA1_DMODE] | dbg_tlu_halted_f);\n   assign mtdata1_t2_ns[9:0] = wr_mtdata1_t2_wb ? tdata_wrdata_wb[9:0] :\n                                {mtdata1_t2[9], update_hit_bit_wb[2] | mtdata1_t2[8], mtdata1_t2[7:0]};\n\n   assign wr_mtdata1_t3_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MTDATA1) & (mtsel[1:0] == 2'b11) & (~mtdata1_t3[MTDATA1_DMODE] | dbg_tlu_halted_f) & ~tdata_kill_write;\n   assign mtdata1_t3_ns[9:0] = wr_mtdata1_t3_wb ? tdata_wrdata_wb[9:0] :\n                                {mtdata1_t3[9], update_hit_bit_wb[3] | mtdata1_t3[8], mtdata1_t3[7:0]};\n\n\n   rvdffe #(10)  mtdata1_t0_ff (.*, .en((trigger_enabled[0] | wr_mtdata1_t0_wb)), .din(mtdata1_t0_ns[9:0]), .dout(mtdata1_t0[9:0]));\n   rvdffe #(10)  mtdata1_t1_ff (.*, .en((trigger_enabled[1] | wr_mtdata1_t1_wb)), .din(mtdata1_t1_ns[9:0]), .dout(mtdata1_t1[9:0]));\n   rvdffe #(10)  mtdata1_t2_ff (.*, .en((trigger_enabled[2] | wr_mtdata1_t2_wb)), .din(mtdata1_t2_ns[9:0]), .dout(mtdata1_t2[9:0]));\n   rvdffe #(10)  mtdata1_t3_ff (.*, .en((trigger_enabled[3] | wr_mtdata1_t3_wb)), .din(mtdata1_t3_ns[9:0]), .dout(mtdata1_t3[9:0]));\n\n   assign mtdata1_tsel_out[31:0] = ( ({32{(mtsel[1:0] == 2'b00)}} & {4'h2, mtdata1_t0[9], 6'b011111, mtdata1_t0[8:7], 6'b0, mtdata1_t0[6:5], 3'b0, mtdata1_t0[4:3], 3'b0, mtdata1_t0[2:0]}) |\n                                     ({32{(mtsel[1:0] == 2'b01)}} & {4'h2, mtdata1_t1[9], 6'b011111, mtdata1_t1[8:7], 6'b0, mtdata1_t1[6:5], 3'b0, mtdata1_t1[4:3], 3'b0, mtdata1_t1[2:0]}) |\n                                     ({32{(mtsel[1:0] == 2'b10)}} & {4'h2, mtdata1_t2[9], 6'b011111, mtdata1_t2[8:7], 6'b0, mtdata1_t2[6:5], 3'b0, mtdata1_t2[4:3], 3'b0, mtdata1_t2[2:0]}) |\n                                     ({32{(mtsel[1:0] == 2'b11)}} & {4'h2, mtdata1_t3[9], 6'b011111, mtdata1_t3[8:7], 6'b0, mtdata1_t3[6:5], 3'b0, mtdata1_t3[4:3], 3'b0, mtdata1_t3[2:0]}));\n\n   assign tlu_trigger_pkt_any[0].select = mtdata1_t0[MTDATA1_SEL];\n   assign tlu_trigger_pkt_any[0].match = mtdata1_t0[MTDATA1_MATCH];\n   assign tlu_trigger_pkt_any[0].store = mtdata1_t0[MTDATA1_ST];\n   assign tlu_trigger_pkt_any[0].load = mtdata1_t0[MTDATA1_LD];\n   assign tlu_trigger_pkt_any[0].execute = mtdata1_t0[MTDATA1_EXE];\n   assign tlu_trigger_pkt_any[0].m = mtdata1_t0[MTDATA1_M_ENABLED];\n\n   assign tlu_trigger_pkt_any[1].select = mtdata1_t1[MTDATA1_SEL];\n   assign tlu_trigger_pkt_any[1].match = mtdata1_t1[MTDATA1_MATCH];\n   assign tlu_trigger_pkt_any[1].store = mtdata1_t1[MTDATA1_ST];\n   assign tlu_trigger_pkt_any[1].load = mtdata1_t1[MTDATA1_LD];\n   assign tlu_trigger_pkt_any[1].execute = mtdata1_t1[MTDATA1_EXE];\n   assign tlu_trigger_pkt_any[1].m = mtdata1_t1[MTDATA1_M_ENABLED];\n\n   assign tlu_trigger_pkt_any[2].select = mtdata1_t2[MTDATA1_SEL];\n   assign tlu_trigger_pkt_any[2].match = mtdata1_t2[MTDATA1_MATCH];\n   assign tlu_trigger_pkt_any[2].store = mtdata1_t2[MTDATA1_ST];\n   assign tlu_trigger_pkt_any[2].load = mtdata1_t2[MTDATA1_LD];\n   assign tlu_trigger_pkt_any[2].execute = mtdata1_t2[MTDATA1_EXE];\n   assign tlu_trigger_pkt_any[2].m = mtdata1_t2[MTDATA1_M_ENABLED];\n\n   assign tlu_trigger_pkt_any[3].select = mtdata1_t3[MTDATA1_SEL];\n   assign tlu_trigger_pkt_any[3].match = mtdata1_t3[MTDATA1_MATCH];\n   assign tlu_trigger_pkt_any[3].store = mtdata1_t3[MTDATA1_ST];\n   assign tlu_trigger_pkt_any[3].load = mtdata1_t3[MTDATA1_LD];\n   assign tlu_trigger_pkt_any[3].execute = mtdata1_t3[MTDATA1_EXE];\n   assign tlu_trigger_pkt_any[3].m = mtdata1_t3[MTDATA1_M_ENABLED];\n\n\n\n\n\n   // ----------------------------------------------------------------------\n   // MTDATA2 (R/W)\n   // [31:0] : Trigger Data 2\n   localparam MTDATA2       = 12'h7a2;\n\n   // If the DMODE bit is set, tdata2 can only be updated in debug_mode\n   assign wr_mtdata2_t0_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MTDATA2) & (mtsel[1:0] == 2'b0)  & (~mtdata1_t0[MTDATA1_DMODE] | dbg_tlu_halted_f);\n   assign wr_mtdata2_t1_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MTDATA2) & (mtsel[1:0] == 2'b01) & (~mtdata1_t1[MTDATA1_DMODE] | dbg_tlu_halted_f);\n   assign wr_mtdata2_t2_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MTDATA2) & (mtsel[1:0] == 2'b10) & (~mtdata1_t2[MTDATA1_DMODE] | dbg_tlu_halted_f);\n   assign wr_mtdata2_t3_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MTDATA2) & (mtsel[1:0] == 2'b11) & (~mtdata1_t3[MTDATA1_DMODE] | dbg_tlu_halted_f);\n\n   rvdffe #(32)  mtdata2_t0_ff (.*, .en(wr_mtdata2_t0_wb), .din(dec_i0_csr_wrdata_wb[31:0]), .dout(mtdata2_t0[31:0]));\n   rvdffe #(32)  mtdata2_t1_ff (.*, .en(wr_mtdata2_t1_wb), .din(dec_i0_csr_wrdata_wb[31:0]), .dout(mtdata2_t1[31:0]));\n   rvdffe #(32)  mtdata2_t2_ff (.*, .en(wr_mtdata2_t2_wb), .din(dec_i0_csr_wrdata_wb[31:0]), .dout(mtdata2_t2[31:0]));\n   rvdffe #(32)  mtdata2_t3_ff (.*, .en(wr_mtdata2_t3_wb), .din(dec_i0_csr_wrdata_wb[31:0]), .dout(mtdata2_t3[31:0]));\n\n   assign mtdata2_tsel_out[31:0] = ( ({32{(mtsel[1:0] == 2'b00)}} & mtdata2_t0[31:0]) |\n                                     ({32{(mtsel[1:0] == 2'b01)}} & mtdata2_t1[31:0]) |\n                                     ({32{(mtsel[1:0] == 2'b10)}} & mtdata2_t2[31:0]) |\n                                     ({32{(mtsel[1:0] == 2'b11)}} & mtdata2_t3[31:0]));\n\n   assign tlu_trigger_pkt_any[0].tdata2[31:0] = mtdata2_t0[31:0];\n   assign tlu_trigger_pkt_any[1].tdata2[31:0] = mtdata2_t1[31:0];\n   assign tlu_trigger_pkt_any[2].tdata2[31:0] = mtdata2_t2[31:0];\n   assign tlu_trigger_pkt_any[3].tdata2[31:0] = mtdata2_t3[31:0];\n\n\n   //----------------------------------------------------------------------\n   // Performance Monitor Counters section starts\n   //----------------------------------------------------------------------\n   localparam MHPME_NOEVENT             = 10'd0;\n   localparam MHPME_CLK_ACTIVE          = 10'd1; // OOP - out of pipe\n   localparam MHPME_ICACHE_HIT          = 10'd2; // OOP\n   localparam MHPME_ICACHE_MISS         = 10'd3; // OOP\n   localparam MHPME_INST_COMMIT         = 10'd4;\n   localparam MHPME_INST_COMMIT_16B     = 10'd5;\n   localparam MHPME_INST_COMMIT_32B     = 10'd6;\n   localparam MHPME_INST_ALIGNED        = 10'd7; // OOP\n   localparam MHPME_INST_DECODED        = 10'd8; // OOP\n   localparam MHPME_INST_MUL            = 10'd9;\n   localparam MHPME_INST_DIV            = 10'd10;\n   localparam MHPME_INST_LOAD           = 10'd11;\n   localparam MHPME_INST_STORE          = 10'd12;\n   localparam MHPME_INST_MALOAD         = 10'd13;\n   localparam MHPME_INST_MASTORE        = 10'd14;\n   localparam MHPME_INST_ALU            = 10'd15;\n   localparam MHPME_INST_CSRREAD        = 10'd16;\n   localparam MHPME_INST_CSRRW          = 10'd17;\n   localparam MHPME_INST_CSRWRITE       = 10'd18;\n   localparam MHPME_INST_EBREAK         = 10'd19;\n   localparam MHPME_INST_ECALL          = 10'd20;\n   localparam MHPME_INST_FENCE          = 10'd21;\n   localparam MHPME_INST_FENCEI         = 10'd22;\n   localparam MHPME_INST_MRET           = 10'd23;\n   localparam MHPME_INST_BRANCH         = 10'd24;\n   localparam MHPME_BRANCH_MP           = 10'd25;\n   localparam MHPME_BRANCH_TAKEN        = 10'd26;\n   localparam MHPME_BRANCH_NOTP         = 10'd27;\n   localparam MHPME_FETCH_STALL         = 10'd28; // OOP\n   localparam MHPME_ALGNR_STALL         = 10'd29; // OOP\n   localparam MHPME_DECODE_STALL        = 10'd30; // OOP\n   localparam MHPME_POSTSYNC_STALL      = 10'd31; // OOP\n   localparam MHPME_PRESYNC_STALL       = 10'd32; // OOP\n   localparam MHPME_LSU_SB_WB_STALL     = 10'd34; // OOP\n   localparam MHPME_DMA_DCCM_STALL      = 10'd35; // OOP\n   localparam MHPME_DMA_ICCM_STALL      = 10'd36; // OOP\n   localparam MHPME_EXC_TAKEN           = 10'd37;\n   localparam MHPME_TIMER_INT_TAKEN     = 10'd38;\n   localparam MHPME_EXT_INT_TAKEN       = 10'd39;\n   localparam MHPME_FLUSH_LOWER         = 10'd40;\n   localparam MHPME_BR_ERROR            = 10'd41;\n   localparam MHPME_IBUS_TRANS          = 10'd42; // OOP\n   localparam MHPME_DBUS_TRANS          = 10'd43; // OOP\n   localparam MHPME_DBUS_MA_TRANS       = 10'd44; // OOP\n   localparam MHPME_IBUS_ERROR          = 10'd45; // OOP\n   localparam MHPME_DBUS_ERROR          = 10'd46; // OOP\n   localparam MHPME_IBUS_STALL          = 10'd47; // OOP\n   localparam MHPME_DBUS_STALL          = 10'd48; // OOP\n   localparam MHPME_INT_DISABLED        = 10'd49; // OOP\n   localparam MHPME_INT_STALLED         = 10'd50; // OOP\n   localparam MHPME_INST_AMO            = 10'd51;\n   localparam MHPME_INST_LR             = 10'd52;\n   localparam MHPME_INST_SC             = 10'd53;\n   localparam MHPME_INST_BITMANIP       = 10'd54;\n   localparam MHPME_DBUS_LOAD           = 10'd55;\n   localparam MHPME_DBUS_STORE          = 10'd56;\n   // Counts even during sleep state\n   localparam MHPME_SLEEP_CYC           = 10'd512; // OOP\n   localparam MHPME_DMA_READ_ALL        = 10'd513; // OOP\n   localparam MHPME_DMA_WRITE_ALL       = 10'd514; // OOP\n   localparam MHPME_DMA_READ_DCCM       = 10'd515; // OOP\n   localparam MHPME_DMA_WRITE_DCCM      = 10'd516; // OOP\n\n   // Pack the event selects into a vector for genvar\n   assign mhpme_vec[0][9:0] = mhpme3[9:0];\n   assign mhpme_vec[1][9:0] = mhpme4[9:0];\n   assign mhpme_vec[2][9:0] = mhpme5[9:0];\n   assign mhpme_vec[3][9:0] = mhpme6[9:0];\n\n   assign tlu_commit_lsu_op_e4 = (tlu_i0_commit_cmt &  tlu_packet_e4.lsu_pipe0  & ~illegal_e4) |\n                                 (tlu_i1_commit_cmt & ~tlu_packet_e4.lsu_pipe0) ;\n   // only consider committed itypes\n   eh2_inst_pkt_t pmu_i0_itype_qual ;\n   eh2_inst_pkt_t pmu_i1_itype_qual ;\n   assign pmu_i0_itype_qual[4:0] = tlu_packet_e4.pmu_i0_itype[4:0] & {5{tlu_i0_commit_cmt}};\n   assign pmu_i1_itype_qual[4:0] = tlu_packet_e4.pmu_i1_itype[4:0] & {5{tlu_i1_commit_cmt}};\n\n   // Generate the muxed incs for all counters based on event type\n   for (genvar i=0 ; i < 4; i++) begin\n      assign mhpmc_inc_e4[i][1:0] =  {2{~mcountinhibit[i+3]}} &\n           (\n             ({2{(mhpme_vec[i][9:0] == MHPME_CLK_ACTIVE      )}} & 2'b01) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_ICACHE_HIT      )}} & {1'b0, ifu_pmu_ic_hit}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_ICACHE_MISS     )}} & {1'b0, ifu_pmu_ic_miss}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_COMMIT     )}} & {tlu_i1_commit_cmt, tlu_i0_commit_cmt & ~illegal_e4}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_COMMIT_16B )}} & {tlu_i1_commit_cmt & ~exu_pmu_i1_pc4,\n                                                                     tlu_i0_commit_cmt & ~exu_pmu_i0_pc4 & ~illegal_e4}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_COMMIT_32B )}} & {tlu_i1_commit_cmt &  exu_pmu_i1_pc4,\n                                                                     tlu_i0_commit_cmt &  exu_pmu_i0_pc4 & ~illegal_e4}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_ALIGNED    )}} & ifu_pmu_instr_aligned[1:0])  |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_DECODED    )}} & dec_pmu_instr_decoded[1:0])  |\n             ({2{(mhpme_vec[i][9:0] == MHPME_ALGNR_STALL     )}} & {1'b0,ifu_pmu_align_stall})  |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DECODE_STALL    )}} & {1'b0,dec_pmu_decode_stall}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_MUL        )}} & {(pmu_i1_itype_qual == MUL),     (pmu_i0_itype_qual == MUL)})     |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_DIV        )}} & {1'b0, tlu_packet_e4.pmu_divide & tlu_i0_commit_cmt & ~illegal_e4})     |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_LOAD       )}} & {(pmu_i1_itype_qual == LOAD),    (pmu_i0_itype_qual == LOAD)})    |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_STORE      )}} & {(pmu_i1_itype_qual == STORE),   (pmu_i0_itype_qual == STORE)})   |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_MALOAD     )}} & {(pmu_i1_itype_qual == LOAD),    (pmu_i0_itype_qual == LOAD)} &\n                                                                      {2{tlu_packet_e4.pmu_lsu_misaligned}})    |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_MASTORE    )}} & {(pmu_i1_itype_qual == STORE),   (pmu_i0_itype_qual == STORE)} &\n                                                                      {2{tlu_packet_e4.pmu_lsu_misaligned}})    |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_ALU        )}} & {(pmu_i1_itype_qual == ALU),     (pmu_i0_itype_qual == ALU)})     |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_CSRREAD    )}} & {1'b0, (pmu_i0_itype_qual == CSRREAD)}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_CSRWRITE   )}} & {1'b0, (pmu_i0_itype_qual == CSRWRITE)})|\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_CSRRW      )}} & {1'b0, (pmu_i0_itype_qual == CSRRW)})   |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_EBREAK     )}} & {1'b0, (pmu_i0_itype_qual == EBREAK)})  |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_ECALL      )}} & {1'b0, (pmu_i0_itype_qual == ECALL)})   |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_FENCE      )}} & {(pmu_i1_itype_qual == FENCE),   (pmu_i0_itype_qual == FENCE)})   |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_FENCEI     )}} & {1'b0, (pmu_i0_itype_qual == FENCEI)})  |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_MRET       )}} & {1'b0, (pmu_i0_itype_qual == MRET)})    |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_BRANCH     )}} & {((pmu_i1_itype_qual == CONDBR) | (pmu_i1_itype_qual == JAL)),\n                                                                     ((pmu_i0_itype_qual == CONDBR) | (pmu_i0_itype_qual == JAL))})   |\n             ({2{(mhpme_vec[i][9:0] == MHPME_BRANCH_MP       )}} & {exu_pmu_i1_br_misp & tlu_i1_commit_cmt,\n                                                                     exu_pmu_i0_br_misp & tlu_i0_commit_cmt & ~illegal_e4}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_BRANCH_TAKEN    )}} & {exu_pmu_i1_br_ataken & tlu_i1_commit_cmt,\n                                                                     exu_pmu_i0_br_ataken & tlu_i0_commit_cmt & ~illegal_e4}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_BRANCH_NOTP     )}} & {tlu_packet_e4.pmu_i1_br_unpred & tlu_i1_commit_cmt,\n                                                                     tlu_packet_e4.pmu_i0_br_unpred & tlu_i0_commit_cmt & ~illegal_e4}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_FETCH_STALL     )}} & {1'b0, ifu_pmu_fetch_stall}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_ALGNR_STALL     )}} & {1'b0, ifu_pmu_align_stall}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DECODE_STALL    )}} & {1'b0, dec_pmu_decode_stall}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_POSTSYNC_STALL  )}} & {1'b0,dec_pmu_postsync_stall}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_PRESYNC_STALL   )}} & {1'b0,dec_pmu_presync_stall}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_LSU_SB_WB_STALL )}} & {1'b0, lsu_store_stall_any}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DMA_DCCM_STALL  )}} & {1'b0, dma_dccm_stall_any}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DMA_ICCM_STALL  )}} & {1'b0, dma_iccm_stall_any}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_EXC_TAKEN       )}} & {1'b0, (i0_exception_valid_e4 | trigger_hit_e4 | lsu_exc_valid_e4)}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_TIMER_INT_TAKEN )}} & {1'b0, take_timer_int | take_int_timer0_int | take_int_timer1_int}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_EXT_INT_TAKEN   )}} & {1'b0, take_ext_int}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_FLUSH_LOWER     )}} & {1'b0, tlu_flush_lower_e4}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_BR_ERROR        )}} & {(dec_tlu_br1_error_e4 | dec_tlu_br1_start_error_e4) & rfpc_i1_e4,\n                                                                     (dec_tlu_br0_error_e4 | dec_tlu_br0_start_error_e4) & rfpc_i0_e4}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_IBUS_TRANS      )}} & {1'b0, ifu_pmu_bus_trxn}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DBUS_TRANS      )}} & {1'b0, lsu_pmu_bus_trxn}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DBUS_MA_TRANS   )}} & {1'b0, lsu_pmu_bus_misaligned}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_IBUS_ERROR      )}} & {1'b0, ifu_pmu_bus_error}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DBUS_ERROR      )}} & {1'b0, lsu_pmu_bus_error}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_IBUS_STALL      )}} & {1'b0, ifu_pmu_bus_busy}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DBUS_STALL      )}} & {1'b0, lsu_pmu_bus_busy}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INT_DISABLED    )}} & {1'b0, ~mstatus[MSTATUS_MIE]}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INT_STALLED     )}} & {1'b0, ~mstatus[MSTATUS_MI"}
{"text": "E] & |(mip[5:0] & mie[5:0])}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_AMO        )}} & {(pmu_i1_itype_qual == ATOMIC),    (pmu_i0_itype_qual == ATOMIC)}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_LR         )}} & {(pmu_i1_itype_qual == LR),    (pmu_i0_itype_qual == LR)}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_SC         )}} & {(pmu_i1_itype_qual == SC),    (pmu_i0_itype_qual == SC)}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_INST_BITMANIP     )}} & {(pmu_i1_itype_qual == BITMANIPU),    (pmu_i0_itype_qual == BITMANIPU)}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DBUS_LOAD       )}} & {1'b0, tlu_commit_lsu_op_e4 & lsu_pmu_load_external_dc4 }) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DBUS_STORE      )}} & {1'b0, tlu_commit_lsu_op_e4 & lsu_pmu_store_external_dc4}) |\n             // These count even during sleep\n             ({2{(mhpme_vec[i][9:0] == MHPME_SLEEP_CYC       )}} & {1'b0, dec_tlu_pmu_fw_halted}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DMA_READ_ALL    )}} & {1'b0, dma_pmu_any_read}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DMA_WRITE_ALL   )}} & {1'b0, dma_pmu_any_write}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DMA_READ_DCCM   )}} & {1'b0, dma_pmu_dccm_read}) |\n             ({2{(mhpme_vec[i][9:0] == MHPME_DMA_WRITE_DCCM  )}} & {1'b0, dma_pmu_dccm_write})\n             );\n   end\n\n   rvdffie #(20) bundle_ff (.*, .clk(free_l2clk),\n                           .din({tlu_btb_write_kill_ns, mstatus_ns[1:0], mip_ns[5:0], mcyclel_cout & ~wr_mcycleh_wb & mcyclel_cout_in,\n                                 minstret_enable, minstretl_cout_ns,\n                                 meicidpl_ns[3:0], meipt_ns[3:0]\n                                 }),\n                           .dout({tlu_btb_write_kill, mstatus[1:0], mip[5:0], mcyclel_cout_f,\n                                  minstret_enable_f, minstretl_cout_f,\n                                  meicidpl[3:0], meipt[3:0]\n                                  }));\n\n   rvdffie #(12) bundle2_ff (.*, .clk(free_l2clk),\n                           .din({mfdhs_ns[1:0],\n                                 icache_rd_valid, icache_wr_valid,\n                                 mhpmc_inc_e4[0][1:0],  mhpmc_inc_e4[1][1:0], mhpmc_inc_e4[2][1:0], mhpmc_inc_e4[3][1:0] }),\n                           .dout({mfdhs[1:0],\n                                  icache_rd_valid_f, icache_wr_valid_f,\n                                  mhpmc_inc_wb[0][1:0], mhpmc_inc_wb[1][1:0], mhpmc_inc_wb[2][1:0], mhpmc_inc_wb[3][1:0]}));\n\n\n   assign perfcnt_halted = ((dec_tlu_dbg_halted & dcsr[DCSR_STOPC]) | dec_tlu_pmu_fw_halted);\n   assign perfcnt_during_sleep[3:0] = {4{~(dec_tlu_dbg_halted & dcsr[DCSR_STOPC])}} &\n                                      {mhpme_vec[3][9],mhpme_vec[2][9],mhpme_vec[1][9],mhpme_vec[0][9]};\n\n\n\n   assign tlu_perfcnt0[1:0] = mhpmc_inc_wb[0][1:0] & ~{2{perfcnt_halted & ~perfcnt_during_sleep[0]}};\n   assign tlu_perfcnt1[1:0] = mhpmc_inc_wb[1][1:0] & ~{2{perfcnt_halted & ~perfcnt_during_sleep[1]}};\n   assign tlu_perfcnt2[1:0] = mhpmc_inc_wb[2][1:0] & ~{2{perfcnt_halted & ~perfcnt_during_sleep[2]}};\n   assign tlu_perfcnt3[1:0] = mhpmc_inc_wb[3][1:0] & ~{2{perfcnt_halted & ~perfcnt_during_sleep[3]}};\n\n   // ----------------------------------------------------------------------\n   // MHPMC3H(RW), MHPMC3(RW)\n   // [63:32][31:0] : Hardware Performance Monitor Counter 3\n   localparam MHPMC3        = 12'hB03;\n   localparam MHPMC3H       = 12'hB83;\n\n   assign mhpmc3_wr_en0 = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MHPMC3);\n   assign mhpmc3_wr_en1 = (~perfcnt_halted | perfcnt_during_sleep[0]) & (|(mhpmc_inc_wb[0][1:0]));\n   assign mhpmc3_wr_en  = mhpmc3_wr_en0 | mhpmc3_wr_en1;\n   assign mhpmc3_incr[63:0] = {mhpmc3h[31:0],mhpmc3[31:0]} + {63'b0,mhpmc_inc_wb[0][1]} + {63'b0,mhpmc_inc_wb[0][0]};\n   assign mhpmc3_ns[31:0] = mhpmc3_wr_en0 ? dec_i0_csr_wrdata_wb[31:0] : mhpmc3_incr[31:0];\n   rvdffe #(32)  mhpmc3_ff (.*, .clk(free_l2clk), .en(mhpmc3_wr_en), .din(mhpmc3_ns[31:0]), .dout(mhpmc3[31:0]));\n\n   assign mhpmc3h_wr_en0 = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MHPMC3H);\n   assign mhpmc3h_wr_en  = mhpmc3h_wr_en0 | mhpmc3_wr_en1;\n   assign mhpmc3h_ns[31:0] = mhpmc3h_wr_en0 ? dec_i0_csr_wrdata_wb[31:0] : mhpmc3_incr[63:32];\n   rvdffe #(32)  mhpmc3h_ff (.*, .clk(free_l2clk), .en(mhpmc3h_wr_en), .din(mhpmc3h_ns[31:0]), .dout(mhpmc3h[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MHPMC4H(RW), MHPMC4(RW)\n   // [63:32][31:0] : Hardware Performance Monitor Counter 4\n   localparam MHPMC4        = 12'hB04;\n   localparam MHPMC4H       = 12'hB84;\n\n   assign mhpmc4_wr_en0 = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MHPMC4);\n   assign mhpmc4_wr_en1 = (~perfcnt_halted | perfcnt_during_sleep[1]) & (|(mhpmc_inc_wb[1][1:0]));\n   assign mhpmc4_wr_en  = mhpmc4_wr_en0 | mhpmc4_wr_en1;\n   assign mhpmc4_incr[63:0] = {mhpmc4h[31:0],mhpmc4[31:0]} + {63'b0,mhpmc_inc_wb[1][1]} + {63'b0,mhpmc_inc_wb[1][0]};\n   assign mhpmc4_ns[31:0] = mhpmc4_wr_en0 ? dec_i0_csr_wrdata_wb[31:0] : mhpmc4_incr[31:0];\n   rvdffe #(32)  mhpmc4_ff (.*, .clk(free_l2clk), .en(mhpmc4_wr_en), .din(mhpmc4_ns[31:0]), .dout(mhpmc4[31:0]));\n\n   assign mhpmc4h_wr_en0 = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MHPMC4H);\n   assign mhpmc4h_wr_en  = mhpmc4h_wr_en0 | mhpmc4_wr_en1;\n   assign mhpmc4h_ns[31:0] = mhpmc4h_wr_en0 ? dec_i0_csr_wrdata_wb[31:0] : mhpmc4_incr[63:32];\n   rvdffe #(32)  mhpmc4h_ff (.*, .clk(free_l2clk), .en(mhpmc4h_wr_en), .din(mhpmc4h_ns[31:0]), .dout(mhpmc4h[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MHPMC5H(RW), MHPMC5(RW)\n   // [63:32][31:0] : Hardware Performance Monitor Counter 5\n   localparam MHPMC5        = 12'hB05;\n   localparam MHPMC5H       = 12'hB85;\n\n   assign mhpmc5_wr_en0 = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MHPMC5);\n   assign mhpmc5_wr_en1 = (~perfcnt_halted | perfcnt_during_sleep[2]) & (|(mhpmc_inc_wb[2][1:0]));\n   assign mhpmc5_wr_en  = mhpmc5_wr_en0 | mhpmc5_wr_en1;\n   assign mhpmc5_incr[63:0] = {mhpmc5h[31:0],mhpmc5[31:0]} + {63'b0,mhpmc_inc_wb[2][1]} + {63'b0,mhpmc_inc_wb[2][0]};\n   assign mhpmc5_ns[31:0] = mhpmc5_wr_en0 ? dec_i0_csr_wrdata_wb[31:0] : mhpmc5_incr[31:0];\n   rvdffe #(32)  mhpmc5_ff (.*, .clk(free_l2clk), .en(mhpmc5_wr_en), .din(mhpmc5_ns[31:0]), .dout(mhpmc5[31:0]));\n\n   assign mhpmc5h_wr_en0 = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MHPMC5H);\n   assign mhpmc5h_wr_en  = mhpmc5h_wr_en0 | mhpmc5_wr_en1;\n   assign mhpmc5h_ns[31:0] = mhpmc5h_wr_en0 ? dec_i0_csr_wrdata_wb[31:0] : mhpmc5_incr[63:32];\n   rvdffe #(32)  mhpmc5h_ff (.*, .clk(free_l2clk), .en(mhpmc5h_wr_en), .din(mhpmc5h_ns[31:0]), .dout(mhpmc5h[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MHPMC6H(RW), MHPMC6(RW)\n   // [63:32][31:0] : Hardware Performance Monitor Counter 6\n   localparam MHPMC6        = 12'hB06;\n   localparam MHPMC6H       = 12'hB86;\n\n   assign mhpmc6_wr_en0 = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MHPMC6);\n   assign mhpmc6_wr_en1 = (~perfcnt_halted | perfcnt_during_sleep[3]) & (|(mhpmc_inc_wb[3][1:0]));\n   assign mhpmc6_wr_en  = mhpmc6_wr_en0 | mhpmc6_wr_en1;\n   assign mhpmc6_incr[63:0] = {mhpmc6h[31:0],mhpmc6[31:0]} + {63'b0,mhpmc_inc_wb[3][1]} + {63'b0,mhpmc_inc_wb[3][0]};\n   assign mhpmc6_ns[31:0] = mhpmc6_wr_en0 ? dec_i0_csr_wrdata_wb[31:0] : mhpmc6_incr[31:0];\n   rvdffe #(32)  mhpmc6_ff (.*, .clk(free_l2clk), .en(mhpmc6_wr_en), .din(mhpmc6_ns[31:0]), .dout(mhpmc6[31:0]));\n\n   assign mhpmc6h_wr_en0 = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MHPMC6H);\n   assign mhpmc6h_wr_en  = mhpmc6h_wr_en0 | mhpmc6_wr_en1;\n   assign mhpmc6h_ns[31:0] = mhpmc6h_wr_en0 ? dec_i0_csr_wrdata_wb[31:0] : mhpmc6_incr[63:32];\n   rvdffe #(32)  mhpmc6h_ff (.*, .clk(free_l2clk), .en(mhpmc6h_wr_en), .din(mhpmc6h_ns[31:0]), .dout(mhpmc6h[31:0]));\n\n   // ----------------------------------------------------------------------\n   // MHPME3(RW)\n   // [9:0] : Hardware Performance Monitor Event 3\n   localparam MHPME3        = 12'h323;\n\n   // we only have events 0-56, 512-516, not 33, HPME* are WARL so zero otherwise\n   assign zero_event_wb = ( (dec_i0_csr_wrdata_wb[9:0] > 10'd516) |\n                            (|dec_i0_csr_wrdata_wb[31:10]) |\n                            ((dec_i0_csr_wrdata_wb[9:0] < 10'd512) & (dec_i0_csr_wrdata_wb[9:0] > 10'd56)) |\n                            (dec_i0_csr_wrdata_wb[9:0] == 10'd33)\n                           );\n\n   assign event_wb[9:0] =  zero_event_wb ? '0 : dec_i0_csr_wrdata_wb[9:0];\n\n   assign wr_mhpme3_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MHPME3);\n\n   rvdffe #(10)  mhpme3_ff (.*, .en(wr_mhpme3_wb), .din(event_wb[9:0]), .dout(mhpme3[9:0]));\n   // ----------------------------------------------------------------------\n   // MHPME4(RW)\n   // [9:0] : Hardware Performance Monitor Event 4\n   localparam MHPME4        = 12'h324;\n\n   assign wr_mhpme4_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MHPME4);\n\n   rvdffe #(10)  mhpme4_ff (.*, .en(wr_mhpme4_wb), .din(event_wb[9:0]), .dout(mhpme4[9:0]));\n   // ----------------------------------------------------------------------\n   // MHPME5(RW)\n   // [9:0] : Hardware Performance Monitor Event 5\n   localparam MHPME5        = 12'h325;\n\n   assign wr_mhpme5_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MHPME5);\n\n   rvdffe #(10)  mhpme5_ff (.*, .en(wr_mhpme5_wb), .din(event_wb[9:0]), .dout(mhpme5[9:0]));\n   // ----------------------------------------------------------------------\n   // MHPME6(RW)\n   // [9:0] : Hardware Performance Monitor Event 6\n   localparam MHPME6        = 12'h326;\n\n   assign wr_mhpme6_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MHPME6);\n\n   rvdffe #(10)  mhpme6_ff (.*, .en(wr_mhpme6_wb), .din(event_wb[9:0]), .dout(mhpme6[9:0]));\n\n   // MCOUNTINHIBIT(RW)\n   // [31:7] : Reserved, read 0x0\n   // [6]    : HPM6 disable\n   // [5]    : HPM5 disable\n   // [4]    : HPM4 disable\n   // [3]    : HPM3 disable\n   // [2]    : MINSTRET disable\n   // [1]    : reserved, read 0x0\n   // [0]    : MCYCLE disable\n\n   localparam MCOUNTINHIBIT             = 12'h320;\n\n   assign wr_mcountinhibit_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MCOUNTINHIBIT);\n\n   rvdffs #(6)  mcountinhibit_ff (.*, .clk(csr_wr_clk), .en(wr_mcountinhibit_wb), .din({dec_i0_csr_wrdata_wb[6:2], dec_i0_csr_wrdata_wb[0]}), .dout({mcountinhibit[6:2], mcountinhibit[0]}));\n   assign mcountinhibit[1] = 1'b0;\n\n   // ----------------------------------------------------------------------\n   // MFDHS(RW)\n   // [1] : LSU operation pending when debug halt threshold reached\n   // [0] : IFU operation pending when debug halt threshold reached\n\n   localparam MFDHS         = 12'h7cf;\n\n   assign wr_mfdhs_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MFDHS);\n\n   assign mfdhs_ns[1:0] = wr_mfdhs_wb ? dec_i0_csr_wrdata_wb[1:0] : ((dbg_tlu_halted & ~dbg_tlu_halted_f) ? {~lsu_idle_any_f, ~ifu_miss_state_idle_f} : mfdhs[1:0]);\n\n\n   assign force_halt_ctr[31:0] = debug_halt_req_f ? (force_halt_ctr_f[31:0] + 32'b1) : (dbg_tlu_halted_f ? 32'b0 : force_halt_ctr_f[31:0]);\n\n\n   rvdfflie #(.WIDTH(32),.LEFT(20))  forcehaltctr_ff (.*, .en(mfdht[0]), .din(force_halt_ctr[31:0]), .dout(force_halt_ctr_f[31:0]));\n\n   assign force_halt = mfdht[0] & |(force_halt_ctr_f[31:0] & (32'hffffffff << mfdht[5:1]));\n\n   //----------------------------------------------------------------------\n   // Performance Monitor Counters section ends\n   //----------------------------------------------------------------------\n   // ----------------------------------------------------------------------\n\n\n   //--------------------------------------------------------------------------------\n   // trace (1 per thread eventually?!)\n   //--------------------------------------------------------------------------------\n   logic tracef_en;\n   assign tracef_en = (i0_valid_wb | i1_valid_wb | exc_or_int_valid_wb | interrupt_valid_wb | tlu_i0_valid_wb1 | tlu_i1_valid_wb1 |\n                       tlu_i0_exc_valid_wb1 | tlu_i1_exc_valid_wb1 | tlu_int_valid_wb1_raw | tlu_int_valid_wb2) & ~dec_tlu_trace_disable;\n\n   rvdffe #(16)  traceff (.*, .clk(free_l2clk), .en(tracef_en),\n                        .din ({i0_valid_wb, i1_valid_wb,\n                               i0_exception_valid_wb | lsu_i0_exc_wb | (i0_trigger_hit_wb & ~trigger_hit_dmode_wb),\n                               ~(i0_exception_valid_wb | lsu_i0_exc_wb | i0_trigger_hit_wb) & exc_or_int_valid_wb & ~interrupt_valid_wb,\n                               exc_cause_wb[4:0],\n                               interrupt_valid_wb,\n                               tlu_exc_cause_wb1_raw[4:0],\n                               tlu_int_valid_wb1_raw}),\n                        .dout({tlu_i0_valid_wb1, tlu_i1_valid_wb1,\n                               tlu_i0_exc_valid_wb1, tlu_i1_exc_valid_wb1,\n                               tlu_exc_cause_wb1_raw[4:0],\n                               tlu_int_valid_wb1_raw,\n                               tlu_exc_cause_wb2[4:0],\n                               tlu_int_valid_wb2\n                               }));\n\n   // skid buffer for ints, reduces trace port count by 1\n   assign tlu_exc_cause_wb1[4:0] =  tlu_int_valid_wb2 ? tlu_exc_cause_wb2[4:0] : tlu_exc_cause_wb1_raw[4:0];\n   assign tlu_int_valid_wb1 = tlu_int_valid_wb2;\n\n   assign tlu_mtval_wb1  = mtval[31:0];\n\n   // end trace\n   //--------------------------------------------------------------------------------\n\n\n   // ----------------------------------------------------------------------\n   // CSR read mux\n   // ----------------------------------------------------------------------\n\n\n   assign csr_rd = tlu_i0_csr_pkt_d;\n\n//   for( genvar i=0; i<2 ; i++) begin: CSR_rd_mux\n   assign csr_rddata_d[31:0] = (  ({32{csr_rd.csr_mhartid}}   & {core_id[31:4], 3'b0, mytid}) |\n                                  ({32{csr_rd.csr_mstatus}}   & {19'b0, 2'b11, 3'b0, mstatus[1], 3'b0, mstatus[0], 3'b0}) |\n                                  ({32{csr_rd.csr_mtvec}}     & {mtvec[30:1], 1'b0, mtvec[0]}) |\n                                  ({32{csr_rd.csr_mip}}       & {1'b0, mip[5:3], 16'b0, mip[2], 3'b0, mip[1], 3'b0, mip[0], 3'b0}) |\n                                  ({32{csr_rd.csr_mie}}       & {1'b0, mie[5:3], 16'b0, mie[2], 3'b0, mie[1], 3'b0, mie[0], 3'b0}) |\n                                  ({32{csr_rd.csr_mcyclel}}   & mcyclel[31:0]) |\n                                  ({32{csr_rd.csr_mcycleh}}   & mcycleh_inc[31:0]) |\n                                  ({32{csr_rd.csr_minstretl}} & minstretl_read[31:0]) |\n                                  ({32{csr_rd.csr_minstreth}} & minstreth_read[31:0]) |\n                                  ({32{csr_rd.csr_mscratch}}  & mscratch[31:0]) |\n                                  ({32{csr_rd.csr_mepc}}      & {mepc[31:1], 1'b0}) |\n                                  ({32{csr_rd.csr_mcause}}    & mcause[31:0]) |\n                                  ({32{csr_rd.csr_mscause}}   & {28'b0, mscause[3:0]}) |\n                                  ({32{csr_rd.csr_mtval}}     & mtval[31:0]) |\n                                  ({32{csr_rd.csr_mdseac}}    & mdseac[31:0]) |\n                                  ({32{csr_rd.csr_meivt}}     & {meivt[31:10], 10'b0}) |\n                                  ({32{csr_rd.csr_meihap}}    & {meivt[31:10], meihap[9:2], 2'b0}) |\n                                  ({32{csr_rd.csr_meicurpl}}  & {28'b0, meicurpl[3:0]}) |\n                                  ({32{csr_rd.csr_meicidpl}}  & {28'b0, meicidpl[3:0]}) |\n                                  ({32{csr_rd.csr_meipt}}     & {28'b0, meipt[3:0]}) |\n                                  ({32{csr_rd.csr_dcsr}}      & {16'h4000, dcsr[15:2], 2'b11}) |\n                                  ({32{csr_rd.csr_dpc}}       & {dpc[31:1], 1'b0}) |\n                                  ({32{csr_rd.csr_mtsel}}     & {30'b0, mtsel[1:0]}) |\n                                  ({32{csr_rd.csr_mtdata1}}   & {mtdata1_tsel_out[31:0]}) |\n                                  ({32{csr_rd.csr_mtdata2}}   & {mtdata2_tsel_out[31:0]}) |\n                                  ({32{csr_rd.csr_mhpmc3}}    & mhpmc3[31:0]) |\n                                  ({32{csr_rd.csr_mhpmc4}}    & mhpmc4[31:0]) |\n                                  ({32{csr_rd.csr_mhpmc5}}    & mhpmc5[31:0]) |\n                                  ({32{csr_rd.csr_mhpmc6}}    & mhpmc6[31:0]) |\n                                  ({32{csr_rd.csr_mhpmc3h}}   & mhpmc3h[31:0]) |\n                                  ({32{csr_rd.csr_mhpmc4h}}   & mhpmc4h[31:0]) |\n                                  ({32{csr_rd.csr_mhpmc5h}}   & mhpmc5h[31:0]) |\n                                  ({32{csr_rd.csr_mhpmc6h}}   & mhpmc6h[31:0]) |\n                                  ({32{csr_rd.csr_mhpme3}}    & {22'b0,mhpme3[9:0]}) |\n                                  ({32{csr_rd.csr_mhpme4}}    & {22'b0,mhpme4[9:0]}) |\n                                  ({32{csr_rd.csr_mhpme5}}    & {22'b0,mhpme5[9:0]}) |\n                                  ({32{csr_rd.csr_mhpme6}}    & {22'b0,mhpme6[9:0]}) |\n                                  ({32{csr_rd.csr_mcountinhibit}} & {25'b0, mcountinhibit[6:0]}) |\n                                  ({32{csr_rd.csr_mpmc}}      & {30'b0, mpmc[1], 1'b0}) |\n                                  ({32{csr_rd.csr_dicad0}}    & dicad0[31:0]) |\n                                  ({32{csr_rd.csr_dicad0h}}   & dicad0h[31:0]) |\n                                  ({32{csr_rd.csr_dicad1}}    & dicad1[31:0]) |\n                                  ({32{csr_rd.csr_dicawics}}  & {7'b0, dicawics[16], 2'b0, dicawics[15:14], 3'b0, dicawics[13:0], 3'b0}) |\n                                  ({32{csr_rd.csr_mfdhs}}     & {30'b0, mfdhs[1:0]}) |\n                                  ({32{dec_timer_read_d}} & dec_timer_rddata_d[31:0])\n                                  );\n//   end // block: CSR_rd_mux\n\nendmodule // eh2_dec_tlu_ctl\n\nmodule eh2_dec_timer_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n   input logic clk,\n   input logic free_l2clk,\n   input logic csr_wr_clk,\n   input logic rst_l,\n   input logic        dec_i0_csr_wen_wb_mod,      // csr write enable at wb\n\n   input logic [11:0] dec_i0_csr_wraddr_wb,      // write address for csr\n   input logic [31:0] dec_i0_csr_wrdata_wb,   // csr write data at wb\n\n   input eh2_csr_tlu_pkt_t csr_rd, // csr decodes\n\n   input logic dec_pause_state, // Paused\n   input logic dec_tlu_pmu_fw_halted, // pmu/fw halted\n   input logic internal_dbg_halt_timers, // debug halted\n\n   output logic [31:0] dec_timer_rddata_d, // timer CSR read data\n   output logic   dec_timer_read_d, // timer CSR address match\n   output logic        dec_timer_t0_pulse, // timer0 int\n   output logic        dec_timer_t1_pulse, // timer1 int\n\n   input  logic        scan_mode\n   );\n   localparam MITCTL_ENABLE             = 0;\n   localparam MITCTL_ENABLE_HALTED      = 1;\n   localparam MITCTL_ENABLE_PAUSED      = 2;\n\n   logic [31:0] mitcnt0_ns, mitcnt0, mitcnt1_ns, mitcnt1, mitb0, mitb1, mitb0_b, mitb1_b, mitcnt0_inc, mitcnt1_inc;\n   logic [2:0] mitctl0_ns, mitctl0;\n   logic [3:0] mitctl1_ns, mitctl1;\n   logic wr_mitcnt0_wb, wr_mitcnt1_wb, wr_mitb0_wb, wr_mitb1_wb, wr_mitctl0_wb, wr_mitctl1_wb;\n   logic mitcnt0_inc_ok, mitcnt1_inc_ok;\n   logic mitcnt0_inc_cout, mitcnt1_inc_cout;\n\n logic mit0_match_ns;\n logic mit1_match_ns;\n logic mitctl0_0_b_ns;\n logic mitctl0_0_b;\n logic mitctl1_0_b_ns;\n logic mitctl1_0_b;\n   logic mit0_match_d1;\n\n   if(pt.TIMER_LEGAL_EN) begin : internal_timers\n\n   assign mit0_match_ns = (mitcnt0[31:0] >= mitb0[31:0]);\n   assign mit1_match_ns = (mitcnt1[31:0] >= mitb1[31:0]);\n\n   assign dec_timer_t0_pulse = mit0_match_ns;\n   assign dec_timer_t1_pulse = mit1_match_ns;\n   // ----------------------------------------------------------------------\n   // MITCNT0 (RW)\n   // [31:0] : Internal Timer Counter 0\n\n   localparam MITCNT0       = 1"}
{"text": "2'h7d2;\n\n   assign wr_mitcnt0_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MITCNT0);\n\n   assign mitcnt0_inc_ok = mitctl0[MITCTL_ENABLE] & (~dec_pause_state | mitctl0[MITCTL_ENABLE_PAUSED]) & (~dec_tlu_pmu_fw_halted | mitctl0[MITCTL_ENABLE_HALTED]) & ~internal_dbg_halt_timers;\n\n   assign {mitcnt0_inc_cout, mitcnt0_inc[7:0]} = mitcnt0[7:0] + {7'b0, 1'b1};\n   assign mitcnt0_inc[31:8] = mitcnt0[31:8] + {23'b0, mitcnt0_inc_cout};\n\n   assign mitcnt0_ns[31:0] = wr_mitcnt0_wb ? dec_i0_csr_wrdata_wb[31:0] : mit0_match_ns ? 'b0 : mitcnt0_inc[31:0];\n\n   rvdffe #(24) mitcnt0_ffb      (.*, .clk(free_l2clk), .en(wr_mitcnt0_wb | (mitcnt0_inc_ok & mitcnt0_inc_cout) | mit0_match_ns), .din(mitcnt0_ns[31:8]), .dout(mitcnt0[31:8]));\n   rvdffe #(8)  mitcnt0_ffa      (.*, .clk(free_l2clk), .en(wr_mitcnt0_wb | mitcnt0_inc_ok | mit0_match_ns),                       .din(mitcnt0_ns[7:0]), .dout(mitcnt0[7:0]));\n\n   // ----------------------------------------------------------------------\n   // MITCNT1 (RW)\n   // [31:0] : Internal Timer Counter 0\n\n   localparam MITCNT1       = 12'h7d5;\n\n   assign wr_mitcnt1_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MITCNT1);\n\n   assign mitcnt1_inc_ok = mitctl1[MITCTL_ENABLE] &\n                           (~dec_pause_state | mitctl1[MITCTL_ENABLE_PAUSED]) &\n                           (~dec_tlu_pmu_fw_halted | mitctl1[MITCTL_ENABLE_HALTED]) &\n                           ~internal_dbg_halt_timers &\n                           (~mitctl1[3] | mit0_match_ns);\n\n   // only inc MITCNT1 if not cascaded with 0, or if 0 overflows\n   assign {mitcnt1_inc_cout, mitcnt1_inc[7:0]} = mitcnt1[7:0] + {7'b0, 1'b1};\n   assign mitcnt1_inc[31:8] = mitcnt1[31:8] + {23'b0, mitcnt1_inc_cout};\n\n   assign mitcnt1_ns[31:0]  = wr_mitcnt1_wb ? dec_i0_csr_wrdata_wb[31:0] : mit1_match_ns ? 'b0 : mitcnt1_inc[31:0];\n\n   rvdffe #(24) mitcnt1_ffb      (.*, .clk(free_l2clk), .en(wr_mitcnt1_wb | (mitcnt1_inc_ok & mitcnt1_inc_cout) | mit1_match_ns), .din(mitcnt1_ns[31:8]), .dout(mitcnt1[31:8]));\n   rvdffe #(8)  mitcnt1_ffa      (.*, .clk(free_l2clk), .en(wr_mitcnt1_wb | mitcnt1_inc_ok | mit1_match_ns),                       .din(mitcnt1_ns[7:0]), .dout(mitcnt1[7:0]));\n\n   // ----------------------------------------------------------------------\n   // MITB0 (RW)\n   // [31:0] : Internal Timer Bound 0\n\n   localparam MITB0         = 12'h7d3;\n\n   assign wr_mitb0_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MITB0);\n\n   rvdffe #(32) mitb0_ff      (.*, .en(wr_mitb0_wb), .din(~dec_i0_csr_wrdata_wb[31:0]), .dout(mitb0_b[31:0]));\n   assign mitb0[31:0] = ~mitb0_b[31:0];\n\n   // ----------------------------------------------------------------------\n   // MITB1 (RW)\n   // [31:0] : Internal Timer Bound 1\n\n   localparam MITB1         = 12'h7d6;\n\n   assign wr_mitb1_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MITB1);\n\n   rvdffe #(32) mitb1_ff      (.*, .en(wr_mitb1_wb), .din(~dec_i0_csr_wrdata_wb[31:0]), .dout(mitb1_b[31:0]));\n   assign mitb1[31:0] = ~mitb1_b[31:0];\n\n   // ----------------------------------------------------------------------\n   // MITCTL0 (RW) Internal Timer Ctl 0\n   // [31:3] : Reserved, reads 0x0\n   // [2]    : Enable while PAUSEd\n   // [1]    : Enable while HALTed\n   // [0]    : Enable (resets to 0x1)\n\n   localparam MITCTL0       = 12'h7d4;\n\n   assign wr_mitctl0_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MITCTL0);\n   assign mitctl0_ns[2:0] = wr_mitctl0_wb ? {dec_i0_csr_wrdata_wb[2:0]} : {mitctl0[2:0]};\n\n   assign mitctl0_0_b_ns = ~mitctl0_ns[0];\n   rvdffs #(3) mitctl0_ff      (.*, .clk(csr_wr_clk), .en(wr_mitctl0_wb), .din({mitctl0_ns[2:1], mitctl0_0_b_ns}), .dout({mitctl0[2:1], mitctl0_0_b}));\n   assign mitctl0[0] = ~mitctl0_0_b;\n\n   // ----------------------------------------------------------------------\n   // MITCTL1 (RW) Internal Timer Ctl 1\n   // [31:4] : Reserved, reads 0x0\n   // [3]    : Cascade\n   // [2]    : Enable while PAUSEd\n   // [1]    : Enable while HALTed\n   // [0]    : Enable (resets to 0x1)\n\n   localparam MITCTL1       = 12'h7d7;\n\n   assign wr_mitctl1_wb = dec_i0_csr_wen_wb_mod & (dec_i0_csr_wraddr_wb[11:0] == MITCTL1);\n   assign mitctl1_ns[3:0] = wr_mitctl1_wb ? {dec_i0_csr_wrdata_wb[3:0]} : {mitctl1[3:0]};\n\n   assign mitctl1_0_b_ns = ~mitctl1_ns[0];\n   rvdffs #(5) mitctl1_ff      (.*, .clk(csr_wr_clk), .en(wr_mitctl1_wb), .din({mitctl1_ns[3:1], mitctl1_0_b_ns, mit0_match_ns}), .dout({mitctl1[3:1], mitctl1_0_b, mit0_match_d1}));\n   assign mitctl1[0] = ~mitctl1_0_b;\n\n   assign dec_timer_read_d = csr_rd.csr_mitcnt1 |\n                             csr_rd.csr_mitcnt0 |\n                             csr_rd.csr_mitb1 |\n                             csr_rd.csr_mitb0 |\n                             csr_rd.csr_mitctl0 |\n                             csr_rd.csr_mitctl1;\n\n   assign dec_timer_rddata_d[31:0] = ( ({32{csr_rd.csr_mitcnt0}}      & mitcnt0[31:0]) |\n                                       ({32{csr_rd.csr_mitcnt1}}      & mitcnt1[31:0]) |\n                                       ({32{csr_rd.csr_mitb0}}        & mitb0[31:0]) |\n                                       ({32{csr_rd.csr_mitb1}}        & mitb1[31:0]) |\n                                       ({32{csr_rd.csr_mitctl0}}      & {29'b0, mitctl0[2:0]}) |\n                                       ({32{csr_rd.csr_mitctl1}}      & {28'b0, mitctl1[3:0]})\n                                       );\n   end // block: internal_timers\n   else begin\n      assign dec_timer_rddata_d[31:0] = 32'b0;\n      assign dec_timer_read_d = 1'b0;\n      assign dec_timer_t0_pulse = 1'b0;\n      assign dec_timer_t1_pulse = 1'b0;\n   end // else: !if(pt.TIMER_LEGAL_EN)\n\nendmodule // dec_timer_ctl\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2021 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\n//********************************************************************************\n// eh2_dec_tlu_top.sv\n//\n//\n// Function: Global CSRs, Commit/WB, thread management\n// Comments:\n//\n//********************************************************************************\n\nmodule eh2_dec_tlu_top\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n   input logic clk,\n   input logic free_clk,\n   input logic active_clk,\n   input logic free_l2clk,\n   input logic [pt.NUM_THREADS-1:0] active_thread_l2clk,\n   input logic rst_l,\n   input logic scan_mode,\n\n   input logic [31:1] rst_vec, // reset vector, from core pins\n   input logic        nmi_int, // nmi pin\n   input logic [31:1] nmi_vec, // nmi vector\n   input logic  [pt.NUM_THREADS-1:0] i_cpu_halt_req,    // Asynchronous Halt request to CPU\n   input logic  [pt.NUM_THREADS-1:0] i_cpu_run_req,     // Asynchronous Restart request to CPU\n\n   input logic lsu_fastint_stall_any,   // needed by lsu for 2nd pass of dma with ecc correction, stall next cycle\n   output logic dec_tlu_core_empty,\n\n   // perf counter inputs\n   input logic [pt.NUM_THREADS-1:0][1:0] dec_pmu_instr_decoded,  // perf mon - decoded inst count\n   input logic [pt.NUM_THREADS-1:0]    dec_pmu_decode_stall,     // perf mon - decode stall count\n   input logic [pt.NUM_THREADS-1:0]    dec_pmu_presync_stall,    // perf mon - presync stall count\n   input logic [pt.NUM_THREADS-1:0]    dec_pmu_postsync_stall,   // perf mon - postsync stall count\n   input logic [pt.NUM_THREADS-1:0][1:0] ifu_pmu_instr_aligned,  // perf mon - inst aligned count\n   input logic [pt.NUM_THREADS-1:0]      ifu_pmu_align_stall,    // perf mon - aligner stall count\n   input logic [pt.NUM_THREADS-1:0]  lsu_pmu_load_external_dc3,  // perf mon - load count\n   input logic [pt.NUM_THREADS-1:0]  lsu_pmu_store_external_dc3, // perf mon - store count\n   input logic [pt.NUM_THREADS-1:0]  lsu_pmu_bus_trxn,           // perf mon - bus transaction count\n   input logic [pt.NUM_THREADS-1:0]  lsu_pmu_bus_busy,           // perf mon - bus busy count\n   input logic [pt.NUM_THREADS-1:0]  lsu_pmu_bus_misaligned,     // perf mon - bus misalign count\n   input logic [pt.NUM_THREADS-1:0]  lsu_pmu_bus_error,          // perf mon - bus error count\n   input logic [pt.NUM_THREADS-1:0] ifu_pmu_ic_miss,               // IC miss event\n   input logic [pt.NUM_THREADS-1:0] ifu_pmu_ic_hit,                // IC hit event\n   input logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_error,             // Bus error event\n   input logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_busy,              // Bus busy event\n   input logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_trxn,              // Bus transaction\n   input logic [pt.NUM_THREADS-1:0] ifu_pmu_fetch_stall, // perf mon - fetch stall count\n   input logic       exu_pmu_i0_br_misp,     // pipe 0 branch misp\n   input logic       exu_pmu_i0_br_ataken,   // pipe 0 branch actual taken\n   input logic       exu_pmu_i0_pc4,         // pipe 0 4 byte branch\n   input logic       exu_pmu_i1_br_misp,     // pipe 1 branch misp\n   input logic       exu_pmu_i1_br_ataken,   // pipe 1 branch actual taken\n   input logic       exu_pmu_i1_pc4,         // pipe 1 4 byte branch\n   input logic       [pt.NUM_THREADS-1:0] lsu_store_stall_any,    // SB or WB is full, stall decode\n   input logic       dma_dccm_stall_any,     // DMA stall of lsu\n   input logic       dma_iccm_stall_any,     // DMA stall of ifu\n   input logic       dma_pmu_dccm_read,          // DMA DCCM read\n   input logic       dma_pmu_dccm_write,         // DMA DCCM write\n   input logic       dma_pmu_any_read,           // DMA read\n   input logic       dma_pmu_any_write,          // DMA write\n\n\n   input logic [31:1] lsu_fir_addr, // Fast int address\n   input logic [1:0]  lsu_fir_error, // Fast int lookup error\n\n   input logic       iccm_dma_sb_error,      // I side dma single bit error\n   input logic       lsu_single_ecc_error_incr,     // Increment the ecc error counter\n\n   input eh2_trap_pkt_t dec_tlu_packet_e4, // exceptions known at decode (contains info for both pipes)\n   input eh2_lsu_error_pkt_t lsu_error_pkt_dc3, // lsu precise exception/error packet\n\n   input logic [pt.NUM_THREADS-1:0] dec_pause_state, // Pause counter not zero\n   input logic [pt.NUM_THREADS-1:0] lsu_imprecise_error_store_any,      // store bus error\n   input logic [pt.NUM_THREADS-1:0] lsu_imprecise_error_load_any,      // store bus error\n   input logic [pt.NUM_THREADS-1:0][31:0]  lsu_imprecise_error_addr_any,   // LSU imprecise bus error address\n\n   input logic dec_i0_tid_d, // pipe0 tid at decode\n\n   input logic        dec_i0_csr_wen_unq_d,       // valid csr with write - for csr legal\n   input logic        dec_i0_csr_any_unq_d,       // valid csr - for csr legal\n   input logic        dec_i0_csr_wen_wb,      // csr write enable at wb\n   input logic [11:0] dec_i0_csr_rdaddr_d,      // read address for csr\n   input logic [11:0] dec_i0_csr_wraddr_wb,      // write address for csr\n   input logic [31:0] dec_i0_csr_wrdata_wb,   // csr write data at wb\n   input logic        dec_i0_csr_is_mcpc_e4,     // csr address is to MCPC\n\n   input logic [pt.NUM_THREADS-1:0] dec_csr_stall_int_ff, // csr is mie/mstatus\n   input logic dec_csr_nmideleg_e4, // csr is mnmipdel\n\n   input logic dec_tlu_i0_valid_e4, // pipe 0 op at e4 is valid\n   input logic dec_tlu_i1_valid_e4, // pipe 1 op at e4 is valid\n\n   input logic [pt.NUM_THREADS-1:0] [31:1] exu_npc_e4, // for NPC tracking\n\n   input logic [pt.NUM_THREADS-1:0] exu_i0_flush_lower_e4,       // pipe 0 branch mp flush\n   input logic [pt.NUM_THREADS-1:0] exu_i1_flush_lower_e4,       // pipe 1 branch mp flush\n   input logic [31:1] exu_i0_flush_path_e4, // pipe 0 correct path for mp, merge with lower path\n   input logic [31:1] exu_i1_flush_path_e4, // pipe 1 correct path for mp, merge with lower path\n\n   input logic [31:1] dec_tlu_i0_pc_e4, // for PC/NPC tracking\n   input logic [31:1] dec_tlu_i1_pc_e4, // for PC/NPC tracking\n\n\n   input logic [pt.NUM_THREADS-1:0] [31:0] dec_illegal_inst, // For mtval\n   input logic        dec_i0_decode_d,  // decode valid, used for clean icache diagnostics\n\n   // branch info from pipe0 for errors or counter updates\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_i0_br_index_e4, // index\n   input logic [1:0]  exu_i0_br_hist_e4, // history\n   input logic        exu_i0_br_bank_e4, // bank\n   input logic        exu_i0_br_error_e4, // error\n   input logic        exu_i0_br_start_error_e4, // start error\n   input logic        exu_i0_br_valid_e4, // valid\n   input logic        exu_i0_br_mp_e4, // mispredict\n   input logic        exu_i0_br_middle_e4, // middle of bank\n   input logic [pt.BHT_GHR_SIZE-1:0] exu_i0_br_fghr_e4, // FGHR when predicted\n\n   // branch info from pipe1 for errors or counter updates\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_i1_br_index_e4, // index\n   input logic [1:0]  exu_i1_br_hist_e4, // history\n   input logic        exu_i1_br_bank_e4, // bank\n   input logic        exu_i1_br_error_e4, // error\n   input logic        exu_i1_br_start_error_e4, // start error\n   input logic        exu_i1_br_valid_e4, // valid\n   input logic        exu_i1_br_mp_e4, // mispredict\n   input logic        exu_i1_br_middle_e4, // middle of bank\n   input logic [pt.BHT_GHR_SIZE-1:0]  exu_i1_br_fghr_e4, // FGHR when predicted\n\n   input logic        exu_i1_br_way_e4, // way hit or repl\n   input logic        exu_i0_br_way_e4, // way hit or repl\n\n   input  logic [pt.NUM_THREADS-1:0] dbg_halt_req, // DM requests a halt\n   input  logic [pt.NUM_THREADS-1:0] dbg_resume_req, // DM requests a resume\n   input  logic [pt.NUM_THREADS-1:0] ifu_miss_state_idle, // I-side miss buffer empty\n   input  logic [pt.NUM_THREADS-1:0] lsu_idle_any, // lsu is idle\n   input  logic                      dec_div_active, // oop divide is active\n   input  logic                      dec_div_tid,    // oop divide tid\n\n   input logic  [pt.NUM_THREADS-1:0] ifu_ic_error_start,     // IC single bit error\n   input logic  [pt.NUM_THREADS-1:0] ifu_iccm_rd_ecc_single_err, // ICCM single bit error\n\n   input logic [70:0] ifu_ic_debug_rd_data, // diagnostic icache read data\n   input logic ifu_ic_debug_rd_data_valid, // diagnostic icache read data valid\n\n   input logic [pt.NUM_THREADS-1:0] [7:0] pic_claimid, // pic claimid for csr\n   input logic [pt.NUM_THREADS-1:0] [3:0] pic_pl, // pic priv level for csr\n   input logic [pt.NUM_THREADS-1:0]       mhwakeup, // high priority external int, wakeup if halted\n\n   input logic [pt.NUM_THREADS-1:0] mexintpend, // external interrupt pending\n   input logic [pt.NUM_THREADS-1:0] timer_int, // timer interrupt pending\n   input logic [pt.NUM_THREADS-1:0] soft_int,                             // Software interrupt pending (from pin)\n\n   input logic [31:4]     core_id, // Core ID\n\n   // external MPC halt/run interface\n   input logic [pt.NUM_THREADS-1:0] mpc_debug_halt_req, // Async halt request\n   input logic [pt.NUM_THREADS-1:0] mpc_debug_run_req, // Async run request\n   input logic [pt.NUM_THREADS-1:0] mpc_reset_run_req, // Run/halt after reset\n\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_dbg_halted, // Core is halted and ready for debug command\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_debug_mode, // Core is in debug mode\n   output logic dec_dbg_cmd_done, // abstract command done\n   output logic dec_dbg_cmd_fail, // abstract command failed\n   output logic dec_dbg_cmd_tid,  // Tid for debug abstract command response\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_resume_ack, // Resume acknowledge\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_debug_stall, // stall decode while waiting on core to empty\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_mpc_halted_only, // Core is halted only due to MPC\n   output eh2_trigger_pkt_t [pt.NUM_THREADS-1:0] [3:0] trigger_pkt_any, // trigger info for trigger blocks\n\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_mhartstart, // thread 1 hartstart\n   output logic [pt.NUM_THREADS-1:0] o_cpu_halt_status, // PMU interface, halted\n   output logic [pt.NUM_THREADS-1:0] o_cpu_halt_ack, // halt req ack\n   output logic [pt.NUM_THREADS-1:0] o_cpu_run_ack, // run req ack\n   output logic [pt.NUM_THREADS-1:0] o_debug_mode_status, // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_force_halt, // forcing debug halt\n\n   output eh2_cache_debug_pkt_t dec_tlu_ic_diag_pkt, // packet of DICAWICS, DICAD0/1, DICAGO info for icache diagnostics\n\n   output logic [31:2] dec_tlu_meihap, // meihap for fast int\n\n   // external MPC halt/run interface\n   output logic [pt.NUM_THREADS-1:0] mpc_debug_halt_ack, // Halt ack\n   output logic [pt.NUM_THREADS-1:0] mpc_debug_run_ack, // Run ack\n   output logic [pt.NUM_THREADS-1:0] debug_brkpt_status, // debug breakpoint\n\n   output logic [pt.NUM_THREADS-1:0] [3:0] dec_tlu_meicurpl, // to PIC\n   output logic [pt.NUM_THREADS-1:0] [3:0] dec_tlu_meipt, // to PIC\n\n   output eh2_br_tlu_pkt_t dec_tlu_br0_wb_pkt, // branch pkt to bp\n   output eh2_br_tlu_pkt_t dec_tlu_br1_wb_pkt, // branch pkt to bp\n   output logic [pt.BHT_GHR_SIZE-1:0] dec_tlu_br0_fghr_wb, // fghr to bp\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br0_index_wb, // bp index\n   output logic [pt.BHT_GHR_SIZE-1:0] dec_tlu_br1_fghr_wb, // fghr to bp\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br1_index_wb, // bp index\n\n   output logic [31:0] dec_i0_csr_rddata_d,      // csr read data at d\n   output logic dec_i0_csr_legal_d,              // csr indicates legal operation\n   output logic dec_i0_csr_global_d,             // global csr\n\n   output logic dec_tlu_i0_kill_writeb_wb,    // I0 is flushed, don't writeback any results to arch state\n   output logic dec_tlu_i1_kill_writeb_wb,    // I1 is flushed, don't writeback any results to arch state\n\n\n   output logic [pt.NUM_THREADS-1:0] [31:1] dec_tlu_flush_path_wb,  // flush pc\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_lower_wb, // commit has a flush (exception, int, mispredict at e4)\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_mp_wb, // commit has a flush (mispredict at e4)\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_lower_wb1, // commit has a flush (exception, int, mispredict at e4)\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_noredir_wb , // Tell fetch to idle on this flush\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_leak_one_wb, // single step\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_err_wb, // iside perr/ecc rfpc\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_extint, // fast ext int started\n   output logic [pt.NUM_THREADS-1:0]        dec_tlu_fence_i_wb,     // flush is a fence_i rfnpc, flush icache\n\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_presync_d,            // CSR read needs to be presync'd\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_postsync_d,           // CSR needs to be presync'd\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_i0_commit_cmt,        // goes to IFU for commit 1 instruction in the FSM\n   output logic [31:0] dec_tlu_mrac_ff,        // CSR for memory region control\n\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_wr_pause_wb,           // CSR write to pause reg is at WB.\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_flush_pause_wb,        // Flush is due to pause\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_lr_reset_wb, // Reset the reservation on certain events\n\n   // trace interface.\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_i0_valid_wb1,  // pipe 0 valid\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_i1_valid_wb1,  // pipe 1 valid\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_i0_exc_valid_wb1, // pipe 0 exception valid\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_i1_exc_valid_wb1, // pipe 1 exception valid\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_int_valid_wb1, // pipe 0 int valid\n   output logic [pt.NUM_THREADS-1:0] [4:0] dec_tlu_exc_cause_wb1, // exception or int cause\n   output logic [pt.NUM_THREADS-1:0] [31:0] dec_tlu_mtval_wb1, // MTVAL value\n\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt0, // toggles when pipe0 perf counter 0 has an event inc\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt1, // toggles when pipe0 perf counter 1 has an event inc\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt2, // toggles when pipe0 perf counter 2 has an event inc\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt3, // toggles when pipe0 perf counter 3 has an event inc\n\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_btb_write_kill, // Kill writes while working on forward progress after a branch error\n\n   // feature disable from mfdc\n   output logic  dec_tlu_external_ldfwd_disable, // disable external load forwarding\n   output logic  dec_tlu_sideeffect_posted_disable, // disable posted writes to side-effect address\n   output logic  dec_tlu_dual_issue_disable, // disable dual issue\n   output logic  dec_tlu_core_ecc_disable, // disable core ECC\n   output logic  dec_tlu_bpred_disable,           // disable branch prediction\n   output logic  dec_tlu_wb_coalescing_disable,   // disable writebuffer coalescing\n   output logic  dec_tlu_pipelining_disable,      // disable pipelining\n   output logic  dec_tlu_trace_disable,           // disable trace\n   output logic [2:0]  dec_tlu_dma_qos_prty,    // DMA QoS priority coming from MFDC [18:16]\n\n   // clock gating overrides from mcgc\n   output logic  dec_tlu_misc_clk_override, // override misc clock domain gating\n   output logic  dec_tlu_dec_clk_override,  // override decode clock domain gating\n   output logic  dec_tlu_exu_clk_override,  // override exu clock domain gating\n   output logic  dec_tlu_ifu_clk_override,  // override fetch clock domain gating\n   output logic  dec_tlu_lsu_clk_override,  // override load/store clock domain gating\n   output logic  dec_tlu_bus_clk_override,  // override bus clock domain gating\n   output logic  dec_tlu_pic_clk_override,  // override PIC clock domain gating\n   output logic  dec_tlu_picio_clk_override,// override PIC clock domain gating\n   output logic  dec_tlu_dccm_clk_override, // override DCCM clock domain gating\n   output logic  dec_tlu_icm_clk_override   // override ICCM clock domain gating\n\n   );\n\n\n   eh2_cache_debug_pkt_t [pt.NUM_THREADS-1:0] dec_tlu_ic_diag_pkt_thr;\n   logic nmi_int_sync, nmi_int_sync_raw;\n   logic                      tlu_select_tid, tlu_select_tid_f, tlu_select_tid_f2, i0tid_wb, i1tid_wb, dec_i0_csr_tid_halted;\n   logic [pt.NUM_THREADS-1:0] tlu_i0_valid_wb1, tlu_i1_valid_wb1, tlu_i0_exc_valid_wb1, tlu_i1_exc_valid_wb1, tlu_int_valid_wb1,\n                              debug_brkpt_status_thr, mpc_debug_halt_ack_thr, mpc_debug_run_ack_thr, o_cpu_run_ack_thr,\n                              o_cpu_halt_ack_thr, o_debug_mode_status_thr, br0_error_e4_thr,\n                              br1_error_e4_thr, br0_start_error_e4_thr, br1_start_error_e4_thr, br0_mp_e4_thr,\n                              pmu_i0_br_misp_thr, pmu_i0_br_ataken_thr, pmu_i0_pc4_thr, pmu_i1_br_misp_thr,\n                              pmu_i1_br_ataken_thr, pmu_i1_pc4_thr, tlu_i0_kill_writeb_wb_thr, tlu_i1_kill_writeb_wb_thr,\n                              dec_i0_csr_wen_wb_mod_thr, allow_dbg_halt_csr_write_thr, ic_perr_wb_thr, iccm_sbecc_wb_thr,\n                              dec_tlu_dbg_halted_thr, dec_tlu_br0_error_e4_thr,\n                              dec_tlu_br1_error_e4_thr, dec_tlu_br0_start_error_e4_thr, dec_tlu_br1_start_error_e4_thr,\n                              tlu_i0_commit_cmt_thr, tlu_mpc_halted_only_thr, tlu_debug_stall_thr, dec_dbg_cmd_done_thr, dec_tlu_core_empty_thr,\n                              dec_dbg_cmd_fail_thr, dec_tlu_debug_mode_thr, dec_tlu_resume_ack_thr, tlu_fast_ext_int_ready;\n   logic dec_tlu_br0_error_e4, dec_tlu_br0_start_error_e4, dec_tlu_br0_v_e4;\n   logic dec_tlu_br1_error_e4, dec_tlu_br1_start_error_e4, dec_tlu_br1_v_e4;\n   logic [pt.NUM_THREADS-1:0] [4:0] tlu_exc_cause_wb1;\n   logic [pt.NUM_THREADS-1:0] [31:0] tlu_mtval_wb1, csr_rddata_d;\n   logic [pt.NUM_THREADS-1:0] [31:2] dec_tlu_meihap_thr;\n\n   logic        wr_mcgc_wb, wr_mfdc_wb, wr_mrac_wb, wr_mfdht_wb,\n                wr_micect_wb, wr_miccmect_wb, miccmect_cout_nc,\n                micect_cout_nc, wr_mdccmect_wb, mdccmect_cout_nc, wr_mhartstart_wb, wr_mnmipdel_wb,\n                ignore_mnmipdel_wr, mnmipdel0_b, ic_perr_wb_all, iccm_sbecc_wb_all, dec_i0_tid_d_f;\n   logic [5:0] mfdht, mfdht_ns;\n   logic [9:0]  mcgc, mcgc_ns, mcgc_int;\n   logic [11:0] mfdc_ns, mfdc_int;\n   logic [18:0] mfdc;\n   logic [31:0] mrac_in, mrac;\n   logic [31:0] micect_ns, micect, miccmect_ns,\n                miccmect, mdccmect_ns, mdccmect, thread_csr_data_d;\n   logic [26:0] miccmect_inc, micect_inc, mdccmect_inc;\n   logic        mice_ce_req, miccme_ce_req, mdccme_ce_req;\n   logic [1:1]  mhartstart_ns;\n   logic [1:0]  mnmipdel_ns, mnmipdel, mhartstart;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br0_addr_e4, dec_tlu_br1_addr_e4;\n   logic        dec_tlu_br0_bank_e4, dec_tlu_br1_bank_e4;\n   logic         lsu_single_ecc_error_wb_ns;\n   logic [31:27] csr_sat;\n   logic [1:0] mhartnums;\n   logic       tlu_i0_presync_d, tlu_i0_postsync_d, lsu_single_ecc_error_wb;\n   logic       bp_i0_e4_en, bp_i1_e4_en;\n\n   assign dec_tlu_debug_mode[pt.NUM_THREADS-1:0] = dec_tlu_debug_mode_thr[pt.NUM_THREADS-1:0];\n   assign "}
{"text": "dec_tlu_dbg_halted[pt.NUM_THREADS-1:0] = dec_tlu_dbg_halted_thr[pt.NUM_THREADS-1:0];\n   assign dec_tlu_mpc_halted_only[pt.NUM_THREADS-1:0] = tlu_mpc_halted_only_thr[pt.NUM_THREADS-1:0];\n   assign dec_tlu_resume_ack[pt.NUM_THREADS-1:0] = dec_tlu_resume_ack_thr[pt.NUM_THREADS-1:0];\n\n   eh2_csr_tlu_pkt_t tlu_i0_csr_pkt_d;\n\n\n   assign dec_i0_csr_tid_halted = dec_tlu_dbg_halted_thr[dec_i0_tid_d];\n\n   eh2_dec_csr i0_csr_decoder(.dec_csr_rdaddr_d(dec_i0_csr_rdaddr_d[11:0]),\n                               .dec_csr_any_unq_d(dec_i0_csr_any_unq_d),\n                               .dec_csr_wen_unq_d(dec_i0_csr_wen_unq_d),\n                               .dec_tlu_dbg_halted(dec_i0_csr_tid_halted),\n                               // outputs\n                               .tlu_csr_pkt_d(tlu_i0_csr_pkt_d),\n                               .dec_csr_legal_d(dec_i0_csr_legal_d),\n                               .tlu_presync_d(tlu_i0_presync_d),\n                               .tlu_postsync_d(tlu_i0_postsync_d)\n                               );\n\n   assign dec_tlu_mhartstart[0] = mhartstart[0];\n\n   // convert pipe signals to thread signals. SMT-ready\nif(pt.NUM_THREADS > 1) begin : pipe2thr\n   assign br0_error_e4_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i0tid, exu_i0_br_error_e4);\n   assign br1_error_e4_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i1tid, exu_i1_br_error_e4);\n   assign br0_mp_e4_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i0tid, exu_i0_br_mp_e4);\n   assign br0_start_error_e4_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i0tid, exu_i0_br_start_error_e4);\n   assign br1_start_error_e4_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i1tid, exu_i1_br_start_error_e4);\n   assign pmu_i0_br_misp_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i0tid, exu_pmu_i0_br_misp);\n   assign pmu_i0_br_ataken_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i0tid, exu_pmu_i0_br_ataken);\n   assign pmu_i0_pc4_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i0tid, exu_pmu_i0_pc4);\n   assign pmu_i1_br_misp_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i1tid, exu_pmu_i1_br_misp);\n   assign pmu_i1_br_ataken_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i1tid, exu_pmu_i1_br_ataken);\n   assign pmu_i1_pc4_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i1tid, exu_pmu_i1_pc4);\n   assign dec_tlu_br0_error_e4_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i0tid, dec_tlu_br0_error_e4);\n   assign dec_tlu_br1_error_e4_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i1tid, dec_tlu_br1_error_e4);\n   assign dec_tlu_br0_start_error_e4_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i0tid, dec_tlu_br0_start_error_e4);\n   assign dec_tlu_br1_start_error_e4_thr[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_tlu_packet_e4.i1tid, dec_tlu_br1_start_error_e4);\n\n\n   assign dec_tlu_presync_d[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_i0_tid_d, tlu_i0_presync_d);\n   assign dec_tlu_postsync_d[pt.NUM_THREADS-1:0] = pipe_to_thr(dec_i0_tid_d, tlu_i0_postsync_d);\n\n   assign dec_tlu_mhartstart[1] = mhartstart[1];\n\n   if(pt.FAST_INTERRUPT_REDIRECT)\n     rvarbiter2 fastint_arbiter (\n                                     .clk(free_clk),\n                                     .ready(tlu_fast_ext_int_ready[1:0]),\n                                     .tid  (tlu_select_tid),\n                                     .shift(&tlu_fast_ext_int_ready[1:0]),\n                                     .*\n                                     );\n   else\n     assign tlu_select_tid = 1'b0;\n\n\nend\nelse begin\n   assign tlu_select_tid = 1'b0;\n   assign br0_error_e4_thr[pt.NUM_THREADS-1:0] = exu_i0_br_error_e4;\n   assign br1_error_e4_thr[pt.NUM_THREADS-1:0] = exu_i1_br_error_e4;\n   assign br0_mp_e4_thr[pt.NUM_THREADS-1:0] = exu_i0_br_mp_e4;\n   assign br0_start_error_e4_thr[pt.NUM_THREADS-1:0] = exu_i0_br_start_error_e4;\n   assign br1_start_error_e4_thr[pt.NUM_THREADS-1:0] = exu_i1_br_start_error_e4;\n   assign pmu_i0_br_misp_thr[pt.NUM_THREADS-1:0] = exu_pmu_i0_br_misp;\n   assign pmu_i0_br_ataken_thr[pt.NUM_THREADS-1:0] = exu_pmu_i0_br_ataken;\n   assign pmu_i0_pc4_thr[pt.NUM_THREADS-1:0] = exu_pmu_i0_pc4;\n   assign pmu_i1_br_misp_thr[pt.NUM_THREADS-1:0] = exu_pmu_i1_br_misp;\n   assign pmu_i1_br_ataken_thr[pt.NUM_THREADS-1:0] = exu_pmu_i1_br_ataken;\n   assign pmu_i1_pc4_thr[pt.NUM_THREADS-1:0] = exu_pmu_i1_pc4;\n   assign dec_tlu_br0_error_e4_thr[pt.NUM_THREADS-1:0] = dec_tlu_br0_error_e4;\n   assign dec_tlu_br1_error_e4_thr[pt.NUM_THREADS-1:0] = dec_tlu_br1_error_e4;\n   assign dec_tlu_br0_start_error_e4_thr[pt.NUM_THREADS-1:0] = dec_tlu_br0_start_error_e4;\n   assign dec_tlu_br1_start_error_e4_thr[pt.NUM_THREADS-1:0] = dec_tlu_br1_start_error_e4;\n\n   assign dec_tlu_presync_d[pt.NUM_THREADS-1:0] = tlu_i0_presync_d;\n   assign dec_tlu_postsync_d[pt.NUM_THREADS-1:0] = tlu_i0_postsync_d;\nend // else: !if(pt.NUM_THREADS > 1)\n\n\n   function [1:0] pipe_to_thr;\n      input tid;\n      input signal;\n      begin\n         pipe_to_thr[0] = signal & ~tid;\n         pipe_to_thr[1] = signal & tid;\n      end\n   endfunction //\n\n   rvsyncss #(1) syncro_ff(.*,\n                           .clk(free_clk),\n                           .din ({nmi_int    }),\n                           .dout({nmi_int_sync_raw}));\n\n   // If SW is writing the nmipdel register, hold off nmis for a cycle\n   assign nmi_int_sync = nmi_int_sync_raw & ~dec_csr_nmideleg_e4;\n\n   // ================================================================================\n   // TID CSRs, Int, PC/NPC, Flush, FW HALT, Pause, Internal timers\n   // ================================================================================\n     for (genvar i=0; i<pt.NUM_THREADS; i++) begin : tlumt\n        eh2_dec_tlu_ctl #(.pt(pt)) tlu (//inputs\n                                         .clk           (active_thread_l2clk[i]),\n                                         .mytid               (1'(i)),\n                                         .exu_i0_flush_path_e4(exu_i0_flush_path_e4[31:1] & {31{exu_i0_flush_lower_e4[i]}}),\n                                         .exu_i1_flush_path_e4(exu_i1_flush_path_e4[31:1] & {31{exu_i1_flush_lower_e4[i]}}),\n                                         .dec_div_active(dec_div_active & (dec_div_tid == i)),\n                                         .i_cpu_run_req(i_cpu_run_req[i] & mhartstart[i]),\n                                         .i_cpu_halt_req(i_cpu_halt_req[i] & mhartstart[i]),\n                                         .mpc_debug_halt_req(mpc_debug_halt_req[i] & mhartstart[i]),\n                                         .mpc_debug_run_req(mpc_debug_run_req[i] & mhartstart[i]),\n                                         .mpc_reset_run_req(mpc_reset_run_req[i]),\n                                         .dbg_halt_req(dbg_halt_req[i]),\n                                         .dbg_resume_req(dbg_resume_req[i] & mhartstart[i]),\n                                         .exu_npc_e4(exu_npc_e4[i]),\n                                         .lsu_store_stall_any(lsu_store_stall_any[i]),\n                                         .dec_tlu_br0_error_e4(dec_tlu_br0_error_e4_thr[i]),\n                                         .dec_tlu_br1_error_e4(dec_tlu_br1_error_e4_thr[i]),\n                                         .dec_tlu_br0_start_error_e4(dec_tlu_br0_start_error_e4_thr[i]),\n                                         .dec_tlu_br1_start_error_e4(dec_tlu_br1_start_error_e4_thr[i]),\n                                         .ifu_pmu_fetch_stall(ifu_pmu_fetch_stall[i]),\n                                         .timer_int(timer_int[i]),\n                                         .soft_int(soft_int[i]),\n                                         .mexintpend(mexintpend[i]),\n                                         .mhartstart_csr(mhartstart[i]),\n                                         .ifu_miss_state_idle(ifu_miss_state_idle[i]),\n                                         .dec_illegal_inst(dec_illegal_inst[i]),\n                                         .lsu_imprecise_error_store_any(lsu_imprecise_error_store_any[i]),\n                                         .lsu_imprecise_error_load_any(lsu_imprecise_error_load_any[i]),\n                                         .lsu_imprecise_error_addr_any(lsu_imprecise_error_addr_any[i]),\n                                         .dec_pause_state(dec_pause_state[i]),\n                                         .nmi_int_sync(nmi_int_sync & mnmipdel_ns[i]),\n                                         .exu_i0_flush_lower_e4(exu_i0_flush_lower_e4[i]),\n                                         .exu_i1_flush_lower_e4(exu_i1_flush_lower_e4[i]),\n                                         .lsu_idle_any(lsu_idle_any[i]),\n                                         .ifu_ic_error_start(ifu_ic_error_start[i]),\n                                         .ifu_iccm_rd_ecc_single_err(ifu_iccm_rd_ecc_single_err[i]),\n                                         .lsu_pmu_load_external_dc3(lsu_pmu_load_external_dc3[i]),\n                                         .lsu_pmu_store_external_dc3(lsu_pmu_store_external_dc3[i]),\n                                         .lsu_pmu_bus_trxn(lsu_pmu_bus_trxn[i]),\n                                         .lsu_pmu_bus_busy(lsu_pmu_bus_busy[i]),\n                                         .lsu_pmu_bus_misaligned(lsu_pmu_bus_misaligned[i]),\n                                         .lsu_pmu_bus_error(lsu_pmu_bus_error[i]),\n                                         .dec_pmu_instr_decoded(dec_pmu_instr_decoded[i]),\n                                         .dec_pmu_decode_stall(dec_pmu_decode_stall[i]),\n                                         .dec_pmu_presync_stall(dec_pmu_presync_stall[i]),\n                                         .dec_pmu_postsync_stall(dec_pmu_postsync_stall[i]),\n                                         .ifu_pmu_instr_aligned(ifu_pmu_instr_aligned[i]),\n                                         .ifu_pmu_align_stall(ifu_pmu_align_stall[i]),\n                                         .ifu_pmu_ic_miss(ifu_pmu_ic_miss[i]),\n                                         .ifu_pmu_ic_hit(ifu_pmu_ic_hit[i]),\n                                         .ifu_pmu_bus_error(ifu_pmu_bus_error[i]),\n                                         .ifu_pmu_bus_busy(ifu_pmu_bus_busy[i]),\n                                         .ifu_pmu_bus_trxn(ifu_pmu_bus_trxn[i]),\n                                         .dec_csr_stall_int_ff(dec_csr_stall_int_ff[i]),\n                                         .pic_claimid(pic_claimid[i]),\n                                         .pic_pl(pic_pl[i]),\n                                         .mhwakeup(mhwakeup[i]),\n                                         .exu_i0_br_start_error_e4(br0_start_error_e4_thr[i]),\n                                         .exu_i1_br_start_error_e4(br1_start_error_e4_thr[i]),\n                                         .exu_i0_br_error_e4(br0_error_e4_thr[i]),\n                                         .exu_i1_br_error_e4(br1_error_e4_thr[i]),\n                                         .exu_i0_br_mp_e4(br0_mp_e4_thr[i]),\n                                         .exu_pmu_i0_br_misp(pmu_i0_br_misp_thr[i]),\n                                         .exu_pmu_i0_br_ataken(pmu_i0_br_ataken_thr[i]),\n                                         .exu_pmu_i0_pc4(pmu_i0_pc4_thr[i]),\n                                         .exu_pmu_i1_br_misp(pmu_i1_br_misp_thr[i]),\n                                         .exu_pmu_i1_br_ataken(pmu_i1_br_ataken_thr[i]),\n                                         .exu_pmu_i1_pc4(pmu_i1_pc4_thr[i]),\n                                         //outputs\n                                         .tlu_perfcnt0(dec_tlu_perfcnt0[i]),\n                                         .tlu_perfcnt1(dec_tlu_perfcnt1[i]),\n                                         .tlu_perfcnt2(dec_tlu_perfcnt2[i]),\n                                         .tlu_perfcnt3(dec_tlu_perfcnt3[i]),\n                                         .dec_tlu_force_halt(dec_tlu_force_halt[i]),\n                                         .dec_tlu_ic_diag_pkt(dec_tlu_ic_diag_pkt_thr[i]),\n                                         .tlu_fast_ext_int_ready(tlu_fast_ext_int_ready[i]),\n                                         .tlu_i0_commit_cmt(tlu_i0_commit_cmt_thr[i]),\n                                         .tlu_i0_valid_wb1(dec_tlu_i0_valid_wb1[i]),\n                                         .tlu_i1_valid_wb1(dec_tlu_i1_valid_wb1[i]),\n                                         .tlu_i0_exc_valid_wb1(dec_tlu_i0_exc_valid_wb1[i]),\n                                         .tlu_i1_exc_valid_wb1(dec_tlu_i1_exc_valid_wb1[i]),\n                                         .tlu_int_valid_wb1(dec_tlu_int_valid_wb1[i]),\n                                         .tlu_exc_cause_wb1(dec_tlu_exc_cause_wb1[i]),\n                                         .tlu_mtval_wb1(dec_tlu_mtval_wb1[i]),\n                                         .tlu_wr_pause_wb(dec_tlu_wr_pause_wb[i]),\n                                         .tlu_flush_pause_wb(dec_tlu_flush_pause_wb[i]),\n                                         .tlu_lr_reset_wb(dec_tlu_lr_reset_wb[i]),\n                                         .tlu_meicurpl(dec_tlu_meicurpl[i]),\n                                         .debug_brkpt_status(debug_brkpt_status[i]),\n                                         .mpc_debug_halt_ack(mpc_debug_halt_ack[i]),\n                                         .mpc_debug_run_ack(mpc_debug_run_ack[i]),\n                                         .o_cpu_halt_status(o_cpu_halt_status[i]),\n                                         .o_cpu_halt_ack(o_cpu_halt_ack[i]),\n                                         .o_cpu_run_ack(o_cpu_run_ack[i]),\n                                         .o_debug_mode_status(o_debug_mode_status[i]),\n                                         .tlu_trigger_pkt_any(trigger_pkt_any[i]),\n                                         .csr_rddata_d(csr_rddata_d[i]),\n                                         .dec_tlu_meihap(dec_tlu_meihap_thr[i]),\n                                         .tlu_meipt(dec_tlu_meipt[i]),\n                                         .tlu_i0_kill_writeb_wb(tlu_i0_kill_writeb_wb_thr[i]),\n                                         .tlu_i1_kill_writeb_wb(tlu_i1_kill_writeb_wb_thr[i]),\n                                         .dec_i0_csr_wen_wb_mod(dec_i0_csr_wen_wb_mod_thr[i]),\n                                         .allow_dbg_halt_csr_write(allow_dbg_halt_csr_write_thr[i]),\n                                         .ic_perr_wb(ic_perr_wb_thr[i]),\n                                         .iccm_sbecc_wb(iccm_sbecc_wb_thr[i]),\n                                         .dec_tlu_debug_stall(dec_tlu_debug_stall[i]),\n                                         .tlu_mpc_halted_only(tlu_mpc_halted_only_thr[i]),\n                                         .tlu_btb_write_kill(dec_tlu_btb_write_kill[i]),\n                                         .dec_tlu_core_empty(dec_tlu_core_empty_thr[i]),\n                                         .dec_dbg_cmd_done(dec_dbg_cmd_done_thr[i]),\n                                         .dec_dbg_cmd_fail(dec_dbg_cmd_fail_thr[i]),\n                                         .dec_tlu_debug_mode(dec_tlu_debug_mode_thr[i]),\n                                         .dec_tlu_resume_ack(dec_tlu_resume_ack_thr[i]),\n                                         .dec_tlu_flush_path_wb(dec_tlu_flush_path_wb[i]),\n                                         .dec_tlu_flush_lower_wb(dec_tlu_flush_lower_wb[i]),\n                                         .dec_tlu_flush_mp_wb(dec_tlu_flush_mp_wb[i]),\n                                         .dec_tlu_flush_lower_wb1(dec_tlu_flush_lower_wb1[i]),\n                                         .dec_tlu_flush_noredir_wb(dec_tlu_flush_noredir_wb[i]),\n                                         .dec_tlu_flush_leak_one_wb(dec_tlu_flush_leak_one_wb[i]),\n                                         .dec_tlu_flush_err_wb(dec_tlu_flush_err_wb[i]),\n                                         .dec_tlu_flush_extint(dec_tlu_flush_extint[i]),\n                                         .dec_tlu_fence_i_wb(dec_tlu_fence_i_wb[i]),\n                                         .dec_tlu_dbg_halted(dec_tlu_dbg_halted_thr[i]),\n                                         .*);\n     end\n\n   assign dec_tlu_meihap = dec_tlu_meihap_thr[tlu_select_tid_f2];\n\n   assign dec_tlu_ic_diag_pkt = dec_tlu_ic_diag_pkt_thr[dec_i0_tid_d_f];\n\n   // tid specific signals to pipe specific conversion\n   assign dec_tlu_i0_kill_writeb_wb = |tlu_i0_kill_writeb_wb_thr[pt.NUM_THREADS-1:0];\n   assign dec_tlu_i1_kill_writeb_wb = |tlu_i1_kill_writeb_wb_thr[pt.NUM_THREADS-1:0];\n   assign dec_tlu_i0_commit_cmt[pt.NUM_THREADS-1:0] = tlu_i0_commit_cmt_thr[pt.NUM_THREADS-1:0];\n\n\n   assign dec_tlu_core_empty = &dec_tlu_core_empty_thr[pt.NUM_THREADS-1:0];\n\n   assign dec_dbg_cmd_tid = ~dec_dbg_cmd_done_thr[0];\n   assign dec_dbg_cmd_done = |dec_dbg_cmd_done_thr[pt.NUM_THREADS-1:0];\n   assign dec_dbg_cmd_fail = |dec_dbg_cmd_fail_thr[pt.NUM_THREADS-1:0];\n   assign ic_perr_wb_all = |ic_perr_wb_thr[pt.NUM_THREADS-1:0];\n   assign iccm_sbecc_wb_all = |iccm_sbecc_wb_thr[pt.NUM_THREADS-1:0];\n\n\n   // ================================================================================\n   // Commit\n   // ================================================================================\n   // Branch prediction updating\n\n   assign dec_tlu_br0_addr_e4[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = exu_i0_br_index_e4[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n   assign dec_tlu_br0_bank_e4 = exu_i0_br_bank_e4;\n   assign dec_tlu_br1_addr_e4[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = exu_i1_br_index_e4[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n   assign dec_tlu_br1_bank_e4 = exu_i1_br_bank_e4;\n\n   // go ahead and repair the branch error on other flushes, doesn't have to be the rfpc flush\n   assign dec_tlu_br0_error_e4 = exu_i0_br_error_e4 & dec_tlu_i0_valid_e4 & ~dec_tlu_flush_lower_wb[dec_tlu_packet_e4.i0tid];\n   assign dec_tlu_br0_start_error_e4 = exu_i0_br_start_error_e4 & dec_tlu_i0_valid_e4 & ~dec_tlu_flush_lower_wb[dec_tlu_packet_e4.i0tid];\n   assign dec_tlu_br0_v_e4 = exu_i0_br_valid_e4 & dec_tlu_i0_valid_e4 & ~dec_tlu_flush_lower_wb[dec_tlu_packet_e4.i0tid] & ~exu_i0_br_mp_e4;\n\n   assign dec_tlu_br1_error_e4 = exu_i1_br_error_e4 & dec_tlu_i1_valid_e4 & ~dec_tlu_flush_lower_wb[dec_tlu_packet_e4.i1tid] & ~br0_mp_e4_thr[dec_tlu_packet_e4.i1tid];\n   assign dec_tlu_br1_start_error_e4 = exu_i1_br_start_error_e4 & dec_tlu_i1_valid_e4 & ~dec_tlu_flush_lower_wb[dec_tlu_packet_e4.i1tid] & ~br0_mp_e4_thr[dec_tlu_packet_e4.i1tid];\n   assign dec_tlu_br1_v_e4 = exu_i1_br_valid_e4 & ~dec_tlu_flush_lower_wb[dec_tlu_packet_e4.i1tid] & dec_tlu_i1_valid_e4 & ~br0_mp_e4_thr[dec_tlu_packet_e4.i1tid] & ~exu_i1_br_mp_e4;\n\n   // has to be free clock, active is too slow for tid pick on fast ints out of sleep\n     rvdff #(5)   tidff (.*,  .clk(free_clk),\n                         .din({tlu_select_tid,\n                               tlu_select_tid_f,\n                               dec_tlu_packet_e4.i0tid,\n                               dec_tlu_packet_e4.i1tid,\n                               dec_i0_tid_d}),\n                         .dout({tlu_select_tid_f,\n                                tlu_select_tid_f2,\n                                i0tid_wb,\n                                i1tid_wb,\n                                dec_i0_tid_d_f}));\n\n\n   assign bp_i0_e4_en = |({dec_tlu_br0_error_e4, dec_tlu_br0_start_error_e4, dec_tlu_br0_v_e4} ^\n                          {dec_tlu_br0_wb_pkt.br_error, dec_tlu_br0_wb_pkt.br_start_error, dec_tlu_br0_wb_pkt.valid});\n\n   assign bp_i1_e4_en = |({dec_tlu_br1_error_e4, dec_tlu_br1_start_error_e4, dec_tlu_br1_v_e4} ^\n                          {dec_tlu_br1_wb_pkt.br_error, dec_tlu_br1_wb_pkt.br_start_error, dec_tlu_br1_wb_pkt.valid});\n\n   rvdffe #(8+pt.BHT_GHR_SIZE+$bits(dec_tlu_br0_addr_e4[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO])) bp_i0wb_ff (.*, .en(bp_"}
{"text": "i0_e4_en),\n                            .din({exu_i0_br_fghr_e4[pt.BHT_GHR_SIZE-1:0],\n                                  dec_tlu_br0_addr_e4[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],\n                                  exu_i0_br_hist_e4[1:0],\n                                  dec_tlu_br0_error_e4,\n                                  dec_tlu_br0_start_error_e4,\n                                  dec_tlu_br0_v_e4,\n                                  dec_tlu_br0_bank_e4,\n                                  exu_i0_br_way_e4,\n                                  exu_i0_br_middle_e4\n                                  }),\n                           .dout({dec_tlu_br0_fghr_wb[pt.BHT_GHR_SIZE-1:0],\n                                  dec_tlu_br0_index_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],\n                                  dec_tlu_br0_wb_pkt.hist[1:0],\n                                  dec_tlu_br0_wb_pkt.br_error,\n                                  dec_tlu_br0_wb_pkt.br_start_error,\n                                  dec_tlu_br0_wb_pkt.valid,\n                                  dec_tlu_br0_wb_pkt.bank,\n                                  dec_tlu_br0_wb_pkt.way,\n                                  dec_tlu_br0_wb_pkt.middle\n                                  }));\n   rvdffe #(8+pt.BHT_GHR_SIZE+$bits(dec_tlu_br1_addr_e4[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO])) bp_i1wb_ff (.*, .en(bp_i1_e4_en),\n                            .din({exu_i1_br_fghr_e4[pt.BHT_GHR_SIZE-1:0],\n                                  dec_tlu_br1_addr_e4[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],\n                                  exu_i1_br_hist_e4[1:0],\n                                  dec_tlu_br1_error_e4,\n                                  dec_tlu_br1_start_error_e4,\n                                  dec_tlu_br1_v_e4,\n                                  dec_tlu_br1_bank_e4,\n                                  exu_i1_br_way_e4,\n                                  exu_i1_br_middle_e4\n                                  }),\n                           .dout({dec_tlu_br1_fghr_wb[pt.BHT_GHR_SIZE-1:0],\n                                  dec_tlu_br1_index_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],\n                                  dec_tlu_br1_wb_pkt.hist[1:0],\n                                  dec_tlu_br1_wb_pkt.br_error,\n                                  dec_tlu_br1_wb_pkt.br_start_error,\n                                  dec_tlu_br1_wb_pkt.valid,\n                                  dec_tlu_br1_wb_pkt.bank,\n                                  dec_tlu_br1_wb_pkt.way,\n                                  dec_tlu_br1_wb_pkt.middle\n                                  }));\n\n   assign dec_tlu_br0_wb_pkt.tid = i0tid_wb;\n   assign dec_tlu_br1_wb_pkt.tid = i1tid_wb;\n\n   // ================================================================================\n   // Global core CSRs\n   // ================================================================================\n\n   // ----------------------------------------------------------------------\n   // MCGC (RW) Clock gating control\n   // [31:10] : Reserved, reads 0x0\n   // [9]    : picio_clk_override\n   // [8]    : misc_clk_override\n   // [7]    : dec_clk_override\n   // [6]    : exu_clk_override\n   // [5]    : ifu_clk_override\n   // [4]    : lsu_clk_override\n   // [3]    : bus_clk_override\n   // [2]    : pic_clk_override\n   // [1]    : dccm_clk_override\n   // [0]    : icm_clk_override\n   //\n   localparam MCGC          = 12'h7f8;\n   assign wr_mcgc_wb = dec_i0_csr_wen_wb_mod_thr[i0tid_wb] & (dec_i0_csr_wraddr_wb[11:0] == MCGC);\n\n   assign mcgc_ns[9:0] = wr_mcgc_wb ? {~dec_i0_csr_wrdata_wb[9], dec_i0_csr_wrdata_wb[8:0]} : mcgc_int[9:0];\n   rvdffe #(10)  mcgc_ff (.*, .en(wr_mcgc_wb), .din(mcgc_ns[9:0]), .dout(mcgc_int[9:0]));\n\n   assign mcgc[9:0] = {~mcgc_int[9], mcgc_int[8:0]};\n\n   assign dec_tlu_picio_clk_override= mcgc[9];\n   assign dec_tlu_misc_clk_override = mcgc[8];\n   assign dec_tlu_dec_clk_override  = mcgc[7];\n   assign dec_tlu_exu_clk_override  = mcgc[6];\n   assign dec_tlu_ifu_clk_override  = mcgc[5];\n   assign dec_tlu_lsu_clk_override  = mcgc[4];\n   assign dec_tlu_bus_clk_override  = mcgc[3];\n   assign dec_tlu_pic_clk_override  = mcgc[2];\n   assign dec_tlu_dccm_clk_override = mcgc[1];\n   assign dec_tlu_icm_clk_override  = mcgc[0];\n\n   // ----------------------------------------------------------------------\n   // MFDC (RW) Feature Disable Control\n   // [31:19] : Reserved, reads 0x0\n   // [18:16] : DMA QoS Prty\n   // [15:12] : Reserved, reads 0x0\n   // [11]   : Disable external load forwarding\n   // [10]   : Disable dual issue\n   // [9]    : Unused, reads 0x0\n   // [8]    : Disable core ecc\n   // [7]    : Unused, reads 0x0\n   // [6]    : Disable side effect posting\n   // [5:4]  : Unused, reads 0x0\n   // [3]    : Disable branch prediction and return stack\n   // [2]    : Disable write buffer coalescing\n   // [1]    : Unused, reads 0x0\n   // [0]    : Disable pipelining - Enable single instruction execution\n   //\n   localparam MFDC          = 12'h7f9;\n\n   assign wr_mfdc_wb = dec_i0_csr_wen_wb_mod_thr[i0tid_wb] & (dec_i0_csr_wraddr_wb[11:0] == MFDC);\n\n   rvdffe #(12)  mfdc_ff (.*, .en(wr_mfdc_wb), .din(mfdc_ns[11:0]), .dout(mfdc_int[11:0]));\n\n\n   // flip poweron value of bit 6 for AXI build\n   if (pt.BUILD_AXI4 == 1) begin\n         assign mfdc_ns[11:0] = {~dec_i0_csr_wrdata_wb[18:16], dec_i0_csr_wrdata_wb[12], dec_i0_csr_wrdata_wb[11:8], ~dec_i0_csr_wrdata_wb[6],\n                                 dec_i0_csr_wrdata_wb[3:2], dec_i0_csr_wrdata_wb[0]};\n         assign mfdc[18:0] = {~mfdc_int[11:9], 3'b0, mfdc_int[8], mfdc_int[7:4], 1'b0, ~mfdc_int[3], 2'b0,\n                              mfdc_int[2:1], 1'b0, mfdc_int[0]};\n   end\n   else begin\n         assign mfdc_ns[11:0] = {~dec_i0_csr_wrdata_wb[18:16],dec_i0_csr_wrdata_wb[12:8], dec_i0_csr_wrdata_wb[6],\n                                 dec_i0_csr_wrdata_wb[3:2], dec_i0_csr_wrdata_wb[0]};\n         assign mfdc[18:0] = {~mfdc_int[11:9], 3'b0, mfdc_int[8:4], 1'b0, mfdc_int[3], 2'b0,\n                              mfdc_int[2:1], 1'b0, mfdc_int[0]};\n   end\n\n   assign dec_tlu_dma_qos_prty[2:0] = mfdc[18:16];\n   assign dec_tlu_trace_disable = mfdc[12];\n   assign dec_tlu_external_ldfwd_disable = mfdc[11];\n   assign dec_tlu_dual_issue_disable = mfdc[10];\n   assign dec_tlu_core_ecc_disable = mfdc[8];\n   assign dec_tlu_sideeffect_posted_disable = mfdc[6];\n   assign dec_tlu_bpred_disable = mfdc[3];\n   assign dec_tlu_wb_coalescing_disable = mfdc[2];\n   assign dec_tlu_pipelining_disable = mfdc[0];\n\n   // ----------------------------------------------------------------------\n   // MRAC (RW)\n   // [31:0] : Region Access Control Register, 16 regions, {side_effect, cachable} pairs\n   localparam MRAC          = 12'h7c0;\n\n   assign wr_mrac_wb = dec_i0_csr_wen_wb_mod_thr[i0tid_wb] & (dec_i0_csr_wraddr_wb[11:0] == MRAC);\n\n   // prevent pairs of 0x11, side_effect and cacheable\n   assign mrac_in[31:0] = {dec_i0_csr_wrdata_wb[31], dec_i0_csr_wrdata_wb[30] & ~dec_i0_csr_wrdata_wb[31],\n                           dec_i0_csr_wrdata_wb[29], dec_i0_csr_wrdata_wb[28] & ~dec_i0_csr_wrdata_wb[29],\n                           dec_i0_csr_wrdata_wb[27], dec_i0_csr_wrdata_wb[26] & ~dec_i0_csr_wrdata_wb[27],\n                           dec_i0_csr_wrdata_wb[25], dec_i0_csr_wrdata_wb[24] & ~dec_i0_csr_wrdata_wb[25],\n                           dec_i0_csr_wrdata_wb[23], dec_i0_csr_wrdata_wb[22] & ~dec_i0_csr_wrdata_wb[23],\n                           dec_i0_csr_wrdata_wb[21], dec_i0_csr_wrdata_wb[20] & ~dec_i0_csr_wrdata_wb[21],\n                           dec_i0_csr_wrdata_wb[19], dec_i0_csr_wrdata_wb[18] & ~dec_i0_csr_wrdata_wb[19],\n                           dec_i0_csr_wrdata_wb[17], dec_i0_csr_wrdata_wb[16] & ~dec_i0_csr_wrdata_wb[17],\n                           dec_i0_csr_wrdata_wb[15], dec_i0_csr_wrdata_wb[14] & ~dec_i0_csr_wrdata_wb[15],\n                           dec_i0_csr_wrdata_wb[13], dec_i0_csr_wrdata_wb[12] & ~dec_i0_csr_wrdata_wb[13],\n                           dec_i0_csr_wrdata_wb[11], dec_i0_csr_wrdata_wb[10] & ~dec_i0_csr_wrdata_wb[11],\n                           dec_i0_csr_wrdata_wb[9], dec_i0_csr_wrdata_wb[8] & ~dec_i0_csr_wrdata_wb[9],\n                           dec_i0_csr_wrdata_wb[7], dec_i0_csr_wrdata_wb[6] & ~dec_i0_csr_wrdata_wb[7],\n                           dec_i0_csr_wrdata_wb[5], dec_i0_csr_wrdata_wb[4] & ~dec_i0_csr_wrdata_wb[5],\n                           dec_i0_csr_wrdata_wb[3], dec_i0_csr_wrdata_wb[2] & ~dec_i0_csr_wrdata_wb[3],\n                           dec_i0_csr_wrdata_wb[1], dec_i0_csr_wrdata_wb[0] & ~dec_i0_csr_wrdata_wb[1]};\n\n   rvdffe #(32)  mrac_ff (.*, .en(wr_mrac_wb), .din(mrac_in[31:0]), .dout(mrac[31:0]));\n\n   // drive to LSU/IFU\n   assign dec_tlu_mrac_ff[31:0] = mrac[31:0];\n   // ----------------------------------------------------------------------\n   // MICECT (I-Cache error counter/threshold)\n   // [31:27] : Icache parity error threshold\n   // [26:0]  : Icache parity error count\n   localparam MICECT        = 12'h7f0;\n\n   assign csr_sat[31:27] = (dec_i0_csr_wrdata_wb[31:27] > 5'd26) ? 5'd26 : dec_i0_csr_wrdata_wb[31:27];\n\n   assign wr_micect_wb = dec_i0_csr_wen_wb_mod_thr[i0tid_wb] & (dec_i0_csr_wraddr_wb[11:0] == MICECT);\n   assign {micect_cout_nc, micect_inc[26:0]} = micect[26:0] + {26'b0, ic_perr_wb_all};\n   assign micect_ns =  wr_micect_wb ? {csr_sat[31:27], dec_i0_csr_wrdata_wb[26:0]} : {micect[31:27], micect_inc[26:0]};\n\n   rvdffe #(32)  micect_ff (.*, .en(wr_micect_wb | ic_perr_wb_all), .din(micect_ns[31:0]), .dout(micect[31:0]));\n\n   assign mice_ce_req = |({32'hffffffff << micect[31:27]} & {5'b0, micect[26:0]});\n\n   // ----------------------------------------------------------------------\n   // MICCMECT (ICCM error counter/threshold)\n   // [31:27] : ICCM parity error threshold\n   // [26:0]  : ICCM parity error count\n   localparam MICCMECT      = 12'h7f1;\n\n   assign wr_miccmect_wb = dec_i0_csr_wen_wb_mod_thr[i0tid_wb] & (dec_i0_csr_wraddr_wb[11:0] == MICCMECT);\n   assign {miccmect_cout_nc, miccmect_inc[26:0]} = miccmect[26:0] + {26'b0, iccm_sbecc_wb_all | iccm_dma_sb_error};\n   assign miccmect_ns =  wr_miccmect_wb ? {csr_sat[31:27], dec_i0_csr_wrdata_wb[26:0]} : {miccmect[31:27], miccmect_inc[26:0]};\n\n   rvdffe #(32)  miccmect_ff (.*, .clk(free_l2clk), .en(wr_miccmect_wb | iccm_sbecc_wb_all | iccm_dma_sb_error), .din(miccmect_ns[31:0]), .dout(miccmect[31:0]));\n\n   assign miccme_ce_req = |({32'hffffffff << miccmect[31:27]} & {5'b0, miccmect[26:0]});\n\n   // ----------------------------------------------------------------------\n   // MDCCMECT (DCCM error counter/threshold)\n   // [31:27] : DCCM parity error threshold\n   // [26:0]  : DCCM parity error count\n   localparam MDCCMECT      = 12'h7f2;\n\n   assign lsu_single_ecc_error_wb_ns = lsu_single_ecc_error_incr;\n   rvdff #(1) lsu_dccm_errorff (.*, .clk(free_clk), .din({lsu_single_ecc_error_wb_ns}),\n                                                   .dout({lsu_single_ecc_error_wb}));\n\n   assign wr_mdccmect_wb = dec_i0_csr_wen_wb_mod_thr[i0tid_wb] & (dec_i0_csr_wraddr_wb[11:0] == MDCCMECT);\n   assign {mdccmect_cout_nc, mdccmect_inc[26:0]} = mdccmect[26:0] + {26'b0, lsu_single_ecc_error_wb};\n   assign mdccmect_ns =  wr_mdccmect_wb ? {csr_sat[31:27], dec_i0_csr_wrdata_wb[26:0]} : {mdccmect[31:27], mdccmect_inc[26:0]};\n\n   rvdffe #(32)  mdccmect_ff (.*, .clk(free_l2clk), .en(wr_mdccmect_wb | lsu_single_ecc_error_wb), .din(mdccmect_ns[31:0]), .dout(mdccmect[31:0]));\n\n   assign mdccme_ce_req = |({32'hffffffff << mdccmect[31:27]} & {5'b0, mdccmect[26:0]});\n\n   // ----------------------------------------------------------------------\n   // MFDHT (Force Debug Halt Threshold)\n   // [5:1] : Halt timeout threshold (power of 2)\n   //   [0] : Halt timeout enabled\n   localparam MFDHT         = 12'h7ce;\n\n   assign wr_mfdht_wb = dec_i0_csr_wen_wb_mod_thr[i0tid_wb] & (dec_i0_csr_wraddr_wb[11:0] == MFDHT);\n\n   assign mfdht_ns[5:0] = wr_mfdht_wb ? dec_i0_csr_wrdata_wb[5:0] : mfdht[5:0];\n\n   rvdff #(6)  mfdht_ff (.*, .clk(active_clk), .din(mfdht_ns[5:0]), .dout(mfdht[5:0]));\n\n\n   // ----------------------------------------------------------------------\n   // MHARTSTART (Write 1 only)\n   // [31:2] : Reserved\n   // [1]    : Start thread 1\n   // [0]    : Start thread 0 (Resets to 0x1)\n   localparam MHARTSTART    = 12'h7fc;\n\n   assign wr_mhartstart_wb = dec_i0_csr_wen_wb_mod_thr[i0tid_wb] & (dec_i0_csr_wraddr_wb[11:0] == MHARTSTART);\n\n   if (pt.NUM_THREADS > 1)\n     assign mhartstart_ns[1] =  wr_mhartstart_wb ? (dec_i0_csr_wrdata_wb[1] | mhartstart[1]) : mhartstart[1];\n   else\n     assign mhartstart_ns[1] =  'b0;\n\n   rvdff #(1)  mhartstart_ff (.*, .clk(active_clk), .din(mhartstart_ns[1]), .dout(mhartstart[1]));\n   assign mhartstart[0] = 1'b1;\n\n   // ----------------------------------------------------------------------\n   // MNMIPDEL (Legal values: 01, 10, 11.\n   // [31:2] : Reserved\n   // [1]    : Delegate NMI pin to thread 1\n   // [0]    : Delegate NMI pin to thread 0 (Resets to 0x1)\n   localparam MNMIPDEL      = 12'h7fe;\n\n   assign wr_mnmipdel_wb = dec_i0_csr_wen_wb_mod_thr[i0tid_wb] & (dec_i0_csr_wraddr_wb[11:0] == MNMIPDEL);\n\n   if(pt.NUM_THREADS == 1)\n     assign ignore_mnmipdel_wr = 1'b1;\n   else\n     assign ignore_mnmipdel_wr = &(~dec_i0_csr_wrdata_wb[1:0]);\n\n   assign mnmipdel_ns[1:0] =  (wr_mnmipdel_wb & ~ignore_mnmipdel_wr) ? dec_i0_csr_wrdata_wb[1:0] : mnmipdel[1:0];\n\n   rvdff #(2)  mnmipdel_ff (.*, .clk(active_clk), .din({mnmipdel_ns[1], ~mnmipdel_ns[0]}), .dout({mnmipdel[1], mnmipdel0_b}));\n   assign mnmipdel[0] = ~mnmipdel0_b;\n\n\n   // Thread mux, if required\n   if (pt.NUM_THREADS > 1) begin: tlutop\n      assign thread_csr_data_d[31:0] = ( ({32{~dec_i0_tid_d}} & csr_rddata_d[0]) |\n                                         ({32{ dec_i0_tid_d}} & csr_rddata_d[1]) );\n      assign mhartnums[1:0] = 2'b10;\n   end\n   else begin\n      assign thread_csr_data_d[31:0] =  csr_rddata_d[dec_i0_tid_d];\n      assign mhartnums[1:0] = 2'b01;\n   end\n   assign dec_i0_csr_global_d = tlu_i0_csr_pkt_d.glob;\n\n   // Final CSR mux\n   assign dec_i0_csr_rddata_d[31:0] = ( // global csrs\n                                     ({32{tlu_i0_csr_pkt_d.csr_misa}}       & ((pt.ATOMIC_ENABLE==0)?32'h40001104:32'h40001105)) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_mvendorid}}  & 32'h00000045) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_marchid}}    & 32'h00000011) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_mimpid}}     & 32'h3) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_mhartnum}}   & {30'h0, mhartnums[1:0]}) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_mrac}}       & mrac[31:0]) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_mcgc}}       & {22'b0, mcgc[9:0]}) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_mfdc}}       & {13'b0, mfdc[18:0]}) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_micect}}     & {micect[31:0]}) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_miccmect}}   & {miccmect[31:0]}) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_mdccmect}}   & {mdccmect[31:0]}) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_mfdht  }}    & {26'b0, mfdht[5:0]}) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_mhartstart}} & {30'b0, mhartstart[1:0]}) |\n                                     ({32{tlu_i0_csr_pkt_d.csr_mnmipdel}}   & {30'b0, mnmipdel[1:0]}) |\n                                     // threaded csrs\n                                     ({32{~tlu_i0_csr_pkt_d.glob}} & thread_csr_data_d[31:0])\n                                     );\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: DEC Trigger Logic\n// Comments:\n//\n//********************************************************************************\nmodule eh2_dec_trigger\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n) (\n\n   input eh2_trigger_pkt_t [pt.NUM_THREADS-1:0] [3:0] trigger_pkt_any,           // Packet from tlu. 'select':0-pc,1-Opcode  'Execute' needs to be set for dec triggers to fire. 'match'-1 do mask, 0: full match\n   input logic [31:1]                                   dec_i0_pc_d,                    // i0 pc\n   input logic [31:1]                                   dec_i1_pc_d,                    // i1 pc\n   input eh2_alu_pkt_t                                 i0_ap,                          // alu packet\n   input eh2_alu_pkt_t                                 i1_ap,                          // alu packet\n\n   output logic [3:0] dec_i0_trigger_match_d,\n   output logic [3:0] dec_i1_trigger_match_d\n);\n\n   logic [3:0][31:0]  dec_i0_match_data;\n   logic [3:0]        dec_i0_trigger_data_match;\n   logic [3:0][31:0]  dec_i1_match_data;\n   logic [3:0]        dec_i1_trigger_data_match;\n\n   for (genvar i=0; i<4; i++) begin\n      assign dec_i0_match_data[i][31:0] = ({32{~trigger_pkt_any[i0_ap.tid][i].select & trigger_pkt_any[i0_ap.tid][i].execute}} & {dec_i0_pc_d[31:1], trigger_pkt_any[i0_ap.tid][i].tdata2[0]}); // select=0; do a PC match\n\n      assign dec_i1_match_data[i][31:0] = ({32{~trigger_pkt_any[i1_ap.tid][i].select & trigger_pkt_any[i1_ap.tid][i].execute}} & {dec_i1_pc_d[31:1], trigger_pkt_any[i1_ap.tid][i].tdata2[0]} );// select=0; do a PC match\n\n      rvmaskandmatch trigger_i0_match (.mask(trigger_pkt_any[i0_ap.tid][i].tdata2[31:0]), .data(dec_i0_match_data[i][31:0]), .masken(trigger_pkt_any[i0_ap.tid][i].match), .match(dec_i0_trigger_data_match[i]));\n      rvmaskandmatch trigger_i1_match (.mask(trigger_pkt_any[i1_ap.tid][i].tdata2[31:0]), .data(dec_i1_match_data[i][31:0]), .masken(trigger_pkt_any[i1_ap.tid][i].match), .match(dec_i1_trigger_data_match[i]));\n\n      assign dec_i0_trigger_match_d[i] = trigger_pkt_any[i0_ap.tid][i].execute & trigger_pkt_any[i0_ap.tid][i].m & dec_i0_trigger_data_match[i];\n      assign dec_i1_trigger_match_d[i] = trigger_pkt_any[i1_ap.tid][i].execute & trigger_pkt_any[i1_ap.tid][i].m & dec_i1_trigger_data_match[i];\n   end\n\nendmodule // eh2_dec_trigger\n\n"}
{"text": "//`ifndef  EH2_DEF_SV\n//`define  EH2_DEF_SV\n\npackage eh2_pkg;\n// performance monitor stuff\ntypedef struct packed {\n                       logic [1:0] trace_rv_i_valid_ip;\n                       logic [63:0] trace_rv_i_insn_ip;\n                       logic [63:0] trace_rv_i_address_ip;\n                       logic [1:0] trace_rv_i_exception_ip;\n                       logic [4:0] trace_rv_i_ecause_ip;\n                       logic [1:0] trace_rv_i_interrupt_ip;\n                       logic [31:0] trace_rv_i_tval_ip;\n                       } eh2_trace_pkt_t;\n\n\ntypedef enum logic [2:0] {\n                          ERR_IDLE   = 3'b000,\n                          IC_WFF     = 3'b001,\n                          ECC_WFF    = 3'b010,\n                          ECC_CORR   = 3'b011,\n                          DMA_SB_ERR = 3'b100\n                         } eh2_perr_state_t;\n\n\ntypedef enum logic [1:0] {\n                          ERR_STOP_IDLE   = 2'b00,\n                          ERR_FETCH1      = 2'b01,\n                          ERR_FETCH2      = 2'b10,\n                          ERR_STOP_FETCH  = 2'b11\n                         } eh2_err_stop_state_t;\n\n\ntypedef enum logic [4:0] {\n                         NULL     = 5'b00000,\n                         MUL      = 5'b00001,\n                         LOAD     = 5'b00010,\n                         STORE    = 5'b00011,\n                         ALU      = 5'b00100,\n                         CSRREAD  = 5'b00101,\n                         CSRWRITE = 5'b00110,\n                         CSRRW    = 5'b00111,\n                         EBREAK   = 5'b01000,\n                         ECALL    = 5'b01001,\n                         FENCE    = 5'b01010,\n                         FENCEI   = 5'b01011,\n                         MRET     = 5'b01100,\n                         CONDBR   = 5'b01101,\n                         JAL      = 5'b01110,\n                         BITMANIPU   = 5'b01111,\n                         ATOMIC   = 5'b10000,\n                         LR       = 5'b10001,\n                         SC       = 5'b10010\n                          } eh2_inst_pkt_t;\n\ntypedef struct packed {\n                       logic valid;\n                       logic wb;\n                       logic stall;\n                       logic [2:0] tag;\n                       logic [4:0] rd;\n                       } eh2_load_cam_pkt_t;\n\ntypedef struct packed {\n                       logic pc0_call;\n                       logic pc0_ret;\n                       logic pc0_pc4;\n                       logic pc1_call;\n                       logic pc1_ret;\n                       logic pc1_pc4;\n                       } eh2_rets_pkt_t;\n\ntypedef struct packed {\n                       logic ret;\n                       logic [31:1] prett;  // predicted ret target\n                       logic br_error;\n                       logic br_start_error;\n                       logic bank;\n                       logic valid;\n                       logic [1:0] hist;\n                       logic way;\n                       } eh2_br_pkt_t;\n\ntypedef struct packed {\n                       logic lsu;\n                       logic mul;\n                       logic i0_only;\n                       logic legal1;\n                       logic legal2;\n                       logic legal3;\n                       logic legal4;\n                       } eh2_predecode_pkt_t;\n\n\ntypedef struct packed {\n                        logic  [1:0]         icaf_type;\n                        logic                icaf_second;\n                        logic                dbecc;\n                        logic                icaf;\n                        logic [31:1]         pc;\n                        eh2_br_pkt_t         brp;\n                        logic [31:0]         inst;\n                        eh2_predecode_pkt_t predecode;\n                        logic                pc4;\n                        logic [15:0]         cinst;\n                       } eh2_ib_pkt_t;\n\ntypedef struct packed {\n                       logic valid;\n                       logic [1:0] hist;\n                       logic br_error;\n                       logic br_start_error;\n                       logic bank;\n                       logic way;\n                       logic middle;\n                       logic tid;\n                       } eh2_br_tlu_pkt_t;\n\ntypedef struct packed {// data bits - upper 19b not likely to change\n                       logic [31:1] prett;\n                       logic boffset;\n                       logic [1:0] hist;\n                       logic bank;\n                       logic way;\n                       // ctl bits\n                       logic ataken;\n                       logic valid;\n                       logic pc4;\n                       logic misp;\n                       logic br_error;\n                       logic br_start_error;\n                       logic pcall;\n                       logic pret;\n                       logic pja;\n                       } eh2_predict_pkt_t;\n\ntypedef struct packed {\n                       // bits not likely to change for power\n                       logic           i0icaf;\n                       logic [1:0]     i0icaf_type;\n                       logic           i0icaf_second;\n                       logic           i0fence_i;\n                       logic [3:0]     i0trigger;\n                       logic [3:0]     i1trigger;\n                       logic           pmu_i0_br_unpred;     // pmu\n                       logic           pmu_i1_br_unpred;     // pmu\n                       logic           pmu_divide;\n                       logic           pmu_lsu_misaligned;\n                       // bits likely to change for power\n                       logic           i0legal;\n                       logic           i0tid;\n                       logic           i1tid;\n                       logic           lsu_pipe0;\n                       eh2_inst_pkt_t pmu_i0_itype;        // pmu - instruction type\n                       eh2_inst_pkt_t pmu_i1_itype;        // pmu - instruction type\n                       } eh2_trap_pkt_t;\n\ntypedef struct packed {\n                       // bits unlikely to change\n                       logic i0sc;\n                       logic i0div;\n                       logic i0csrwen;\n                       logic i0csrwonly;\n                       logic i1sc;\n                       logic [11:0] i0csrwaddr;\n                       // less likely to toggle\n                       logic [1:0] i0rs1bype2;\n                       logic [1:0] i0rs2bype2;\n                       logic [3:0] i0rs1bype3;\n                       logic [3:0] i0rs2bype3;\n                       // less likely to toggle\n                       logic [1:0] i1rs1bype2;\n                       logic [1:0] i1rs2bype2;\n                       logic [6:0] i1rs1bype3;\n                       logic [6:0] i1rs2bype3;\n                       // bits likely to change\n                       logic [4:0] i0rd;\n                       logic i0mul;\n                       logic i0load;\n                       logic i0store;\n                       logic i0v;\n                       logic i0valid;\n                       logic i0secondary;\n                       logic i0tid;\n                       logic [4:0] i1rd;\n                       logic i1mul;\n                       logic i1load;\n                       logic i1store;\n                       logic i1v;\n                       logic i1valid;\n                       logic i1tid;\n                       logic i1secondary;\n                       logic           lsu_tid;\n                       } eh2_dest_pkt_t;\n\ntypedef struct packed {\n                       logic mul;\n                       logic load;\n                       logic sec;\n                       logic alu;\n                       } eh2_class_pkt_t;\n\ntypedef struct packed {\n                       logic [4:0] rs1;\n                       logic [4:0] rs2;\n                       logic [4:0] rd;\n                       } eh2_reg_pkt_t;\n\n\ntypedef struct packed {\n                       // unlikely to change\n                       logic clz;\n                       logic ctz;\n                       logic cpop;\n                       logic sext_b;\n                       logic sext_h;\n                       logic min;\n                       logic max;\n                       logic pack;\n                       logic packu;\n                       logic packh;\n                       logic rol;\n                       logic ror;\n                       logic grev;\n                       logic gorc;\n                       logic zbb;\n                       logic bset;\n                       logic bclr;\n                       logic binv;\n                       logic bext;\n                       logic sh1add;\n                       logic sh2add;\n                       logic sh3add;\n                       logic zba;\n                       // likely to change\n                       logic land;\n                       logic lor;\n                       logic lxor;\n                       logic sll;\n                       logic srl;\n                       logic sra;\n                       logic beq;\n                       logic bne;\n                       logic blt;\n                       logic bge;\n                       logic add;\n                       logic sub;\n                       logic slt;\n                       logic unsign;\n                       logic jal;\n                       logic predict_t;\n                       logic predict_nt;\n                       logic csr_write;\n                       logic csr_imm;\n                       logic tid;\n                       } eh2_alu_pkt_t;\n\ntypedef struct packed {\n                       // unlikely to change\n                       logic atomic;               // this is atomic instruction\n                       logic atomic64;\n                       logic fast_int;\n                       logic barrier;\n                       logic lr;\n                       logic sc;\n                       logic [4:0] atomic_instr;   // this will be decoded to get which of the amo instruction lsu is doing\n                       logic dma;               // dma pkt\n                       // may change\n                       logic by;\n                       logic half;\n                       logic word;\n                       logic dword;\n                       logic load;\n                       logic store;\n                       logic pipe;   // which pipe is load/store\n                       logic unsign;\n/* verilator lint_off SYMRSVDWORD */\n                       logic stack;\n/* verilator lint_on SYMRSVDWORD */\n                       logic tid;\n                       logic store_data_bypass_c1;\n                       logic load_ldst_bypass_c1;\n                       logic store_data_bypass_c2;\n                       logic store_data_bypass_i0_e2_c2;\n                       logic [1:0] store_data_bypass_e4_c1;\n                       logic [1:0] store_data_bypass_e4_c2;\n                       logic [1:0] store_data_bypass_e4_c3;\n                       logic valid;\n                       } eh2_lsu_pkt_t;\n\ntypedef struct packed {\n                      logic exc_valid;\n                      logic single_ecc_error;\n                      logic inst_type;   //0: Load, 1: Store\n                      logic amo_valid;\n                      logic exc_type;    //0: MisAligned, 1: Access Fault\n                      logic [3:0] mscause;\n                      logic [31:0] addr;\n                      } eh2_lsu_error_pkt_t;\n\ntypedef struct packed {\n                       logic clz;\n                       logic ctz;\n                       logic cpop;\n                       logic sext_b;\n                       logic sext_h;\n                       logic min;\n                       logic max;\n                       logic pack;\n                       logic packu;\n                       logic packh;\n                       logic rol;\n                       logic ror;\n                       logic grev;\n                       logic gorc;\n                       logic zbb;\n                       logic bset;\n                       logic bclr;\n                       logic binv;\n                       logic bext;\n                       logic zbs;\n                       logic bcompress;\n                       logic bdecompress;\n                       logic zbe;\n                       logic clmul;\n                       logic clmulh;\n                       logic clmulr;\n                       logic zbc;\n                       logic shfl;\n                       logic unshfl;\n                       logic xperm_n;\n                       logic xperm_b;\n                       logic xperm_h;\n                       logic zbp;\n                       logic crc32_b;\n                       logic crc32_h;\n                       logic crc32_w;\n                       logic crc32c_b;\n                       logic crc32c_h;\n                       logic crc32c_w;\n                       logic zbr;\n                       logic bfp;\n                       logic zbf;\n                       logic sh1add;\n                       logic sh2add;\n                       logic sh3add;\n                       logic zba;\n                       logic alu;\n                       logic atomic;\n                       logic lr;\n                       logic sc;\n                       logic rs1;\n                       logic rs2;\n                       logic imm12;\n                       logic rd;\n                       logic shimm5;\n                       logic imm20;\n                       logic pc;\n                       logic load;\n                       logic store;\n                       logic lsu;\n                       logic add;\n                       logic sub;\n                       logic land;\n                       logic lor;\n                       logic lxor;\n                       logic sll;\n                       logic sra;\n                       logic srl;\n                       logic slt;\n                       logic unsign;\n                       logic condbr;\n                       logic beq;\n                       logic bne;\n                       logic bge;\n                       logic blt;\n                       logic jal;\n                       logic by;\n                       logic half;\n                       logic word;\n                       logic csr_read;\n                       logic csr_clr;\n                       logic csr_set;\n                       logic csr_write;\n                       logic csr_imm;\n                       logic presync;\n                       logic postsync;\n                       logic ebreak;\n                       logic ecall;\n                       logic mret;\n                       logic mul;\n                       logic rs1_sign;\n                       logic rs2_sign;\n                       logic low;\n                       logic div;\n                       logic rem;\n                       logic fence;\n                       logic fence_i;\n                       logic pm_alu;\n                       logic i0_only;\n                       logic legal;\n                       } eh2_dec_pkt_t;\n\n\ntypedef struct packed {\n                       logic valid;\n                       logic rs1_sign;\n                       logic rs2_sign;\n                       logic low;\n                       logic load_mul_rs1_bypass_e1;\n                       logic load_mul_rs2_bypass_e1;\n                       logic bcompress;\n                       logic bdecompress;\n                       logic clmul;\n                       logic clmulh;\n                       logic clmulr;\n                       logic grev;\n                       logic gorc;\n                       logic shfl;\n                       logic unshfl;\n                       logic crc32_b;\n                       logic crc32_h;\n                       logic crc32_w;\n                       logic crc32c_b;\n                       logic crc32c_h;\n                       logic crc32c_w;\n                       logic bfp;\n                       logic xperm_n;\n                       logic xperm_b;\n                       logic xperm_h;\n                       } eh2_mul_pkt_t;\n\ntypedef struct packed {\n                       logic valid;\n                       logic unsign;\n                       logic rem;\n                       logic tid;\n                       } eh2_div_pkt_t;\n\ntypedef struct packed {\n                       logic        TEST1;\n                       logic        RME;\n                       logic [3:0]  RM;\n\n                       logic        LS;\n                       logic        DS;\n                       logic        SD;\n                       logic        TEST_RNM;\n                       logic        BC1;\n                       logic        BC2;\n                      } eh2_ccm_ext_in_pkt_t;\n\ntypedef struct packed {\n                       logic        TEST1;\n                       logic        RME;\n                       logic [3:0]  RM;\n                       logic        LS;\n                       logic        DS;\n                       logic        SD;\n                       logic        TEST_RNM;\n                       logic        BC1;\n                       logic        BC2;\n                      } eh2_dccm_ext_in_pkt_t;\n\n\ntypedef struct packed {\n                       logic        TEST1;\n                       logic        RME;\n                       logic [3:0]  RM;\n                       logic        LS;\n                       logic        DS;\n                       logic        SD;\n                       logic        TEST_RNM;\n                       logic        BC1;\n                       logic        BC2;\n                      } eh2_ic_data_ext_in_pkt_t;\n\n\ntypedef struct packed {\n                       logic        TEST1;\n                       logic        RME;\n                       logic [3:0]  RM;\n                       logic        LS;\n                       logic        DS;\n                       logic        SD;\n                       logic        TEST_RNM;\n                       logic        BC1;\n                       logic        BC2;\n                      } eh2_ic_tag_ext_in_pkt_t;\n\n\ntypedef struct packed {\n                        logic        select;\n                        logic        match;\n                        logic        store;\n                        logic        load;\n                        logic        execute;\n                        logic        m;\n                        logic [31:0] tdata2;\n            } eh2_trigger_pkt_t;\n\n\ntypedef struct packed {\n                        logic [70:0]  icache_wrdata;\n                        logic [16:0]  icache_dicawics;\n                        logic         icache_rd_valid;\n                        logic         icache_wr_valid;\n            } eh2_cache_debug_pkt_t;\n\ntypedef struct packed {\n                       logic [3:0] wayhit_f1;\n                       logic [3:0] wayhit_p1_f1;\n                       logic [1:0] tag_match_way0_f1;\n                       logic [1:0] tag_match_way0_p1_f1;\n                       logic [3:0] tag_match_vway1_expanded_f1;\n                       } eh2_btb_sram_pkt;\n\ntypedef struct packed {\n                       logic csr_misa;\n                       logic csr_mvendorid;\n                       logic csr_marchid;\n                       logic csr_mimpid;\n                       logic csr_mhartid;\n                       logic csr_mstatus;\n                       logic csr_mtvec;\n                       logic csr_mip;\n                       logic csr_mie;\n                       logic csr_mcyclel;\n                       logic csr_mcycleh;\n                       logic csr_minstretl;\n                       logic csr_minstreth;\n                       logic csr_mscratch;\n                       logic csr_mepc;\n                       logic csr_mcause;\n                       logic csr_mscause;\n                       logic csr_mtval;\n                       log"}
{"text": "ic csr_mrac;\n                       logic csr_dmst;\n                       logic csr_mdseac;\n                       logic csr_meihap;\n                       logic csr_meivt;\n                       logic csr_meipt;\n                       logic csr_meicurpl;\n                       logic csr_meicidpl;\n                       logic csr_dcsr;\n                       logic csr_mcgc;\n                       logic csr_mfdc;\n                       logic csr_dpc;\n                       logic csr_mtsel;\n                       logic csr_mtdata1;\n                       logic csr_mtdata2;\n                       logic csr_mhpmc3;\n                       logic csr_mhpmc4;\n                       logic csr_mhpmc5;\n                       logic csr_mhpmc6;\n                       logic csr_mhpmc3h;\n                       logic csr_mhpmc4h;\n                       logic csr_mhpmc5h;\n                       logic csr_mhpmc6h;\n                       logic csr_mhpme3;\n                       logic csr_mhpme4;\n                       logic csr_mhpme5;\n                       logic csr_mhpme6;\n                       logic csr_mitctl0;\n                       logic csr_mitctl1;\n                       logic csr_mitb0;\n                       logic csr_mitb1;\n                       logic csr_mitcnt0;\n                       logic csr_mitcnt1;\n                       logic csr_mpmc;\n                       logic csr_mcpc;\n                       logic csr_meicpct;\n                       logic csr_mdeau;\n                       logic csr_micect;\n                       logic csr_miccmect;\n                       logic csr_mdccmect;\n                       logic csr_dicawics;\n                       logic csr_dicad0h;\n                       logic csr_dicad0;\n                       logic csr_dicad1;\n                       logic csr_dicago;\n                       logic csr_mfdht;\n                       logic csr_mfdhs;\n                       logic csr_mcountinhibit;\n                       logic csr_mhartnum;\n                       logic csr_mhartstart;\n                       logic csr_mnmipdel;\n                       logic valid_only;\n                       logic presync;\n                       logic postsync;\n                       logic glob;\n                       logic legal;\n                       } eh2_csr_tlu_pkt_t;\n\n\nendpackage // eh2_pkg\n//`endif\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n// Function: Top level VEER core file\n// Comments:\n//\n//********************************************************************************\n\nmodule eh2_dma_ctrl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n )(\n   input logic         clk,\n   input logic         free_clk,\n   input logic         rst_l,\n   input logic         dma_bus_clk_en, // slave bus clock enable\n   input logic         clk_override,\n   input logic         scan_mode,\n\n   // Debug signals\n   input logic [31:0]  dbg_cmd_addr,\n   input logic [31:0]  dbg_cmd_wrdata,\n   input logic         dbg_cmd_valid,\n   input logic         dbg_cmd_write, // 1: write command, 0: read_command\n   input logic [1:0]   dbg_cmd_type, // 0:gpr 1:csr 2: memory\n   input logic [1:0]   dbg_cmd_size, // size of the abstract mem access debug command\n\n   input  logic        dbg_dma_bubble,   // Debug needs a bubble to send a valid\n   output logic        dma_dbg_ready,    // DMA is ready to accept debug request\n\n   output logic        dma_dbg_cmd_done,\n   output logic        dma_dbg_cmd_fail,\n   output logic [31:0] dma_dbg_rddata,\n\n   // Core side signals\n   output logic        dma_dccm_req,  // DMA dccm request (only one of dccm/iccm will be set)\n   output logic        dma_dccm_spec_req,  // DMA dccm spec request (this is need for eh2 plus1)\n   output logic        dma_iccm_req,  // DMA iccm request\n   output logic        dma_mem_addr_in_dccm,  // DMA address is in dccm\n   output logic [2:0]  dma_mem_tag,   // DMA Buffer entry number\n   output logic [31:0] dma_mem_addr,  // DMA request address\n   output logic [2:0]  dma_mem_sz,    // DMA request size\n   output logic        dma_mem_write, // DMA write to dccm/iccm\n   output logic [63:0] dma_mem_wdata, // DMA write data\n\n   input logic         dccm_dma_rvalid,    // dccm data valid for DMA read\n   input logic         dccm_dma_ecc_error, // ECC error on DMA read\n   input logic [2:0]   dccm_dma_rtag,      // Tag of the DMA req\n   input logic [63:0]  dccm_dma_rdata,     // dccm data for DMA read\n   input logic         iccm_dma_rvalid,    // iccm data valid for DMA read\n   input logic         iccm_dma_ecc_error, // ECC error on DMA read\n   input logic [2:0]   iccm_dma_rtag,      // Tag of the DMA req\n   input logic [63:0]  iccm_dma_rdata,     // iccm data for DMA read\n\n   output logic        dma_active,         // DMA is busy\n   output logic        dma_dccm_stall_any, // stall dccm pipe (bubble) so that DMA can proceed\n   output logic        dma_iccm_stall_any, // stall iccm pipe (bubble) so that DMA can proceed\n   input logic         dccm_ready, // dccm ready to accept DMA request\n   input logic         iccm_ready, // iccm ready to accept DMA request\n   input logic [2:0]   dec_tlu_dma_qos_prty,    // DMA QoS priority coming from MFDC [18:15]\n\n   // PMU signals\n   output logic        dma_pmu_dccm_read,\n   output logic        dma_pmu_dccm_write,\n   output logic        dma_pmu_any_read,\n   output logic        dma_pmu_any_write,\n\n   // AXI Write Channels\n   input  logic                        dma_axi_awvalid,\n   output logic                        dma_axi_awready,\n   input  logic [pt.DMA_BUS_TAG-1:0]   dma_axi_awid,\n   input  logic [31:0]                 dma_axi_awaddr,\n   input  logic [2:0]                  dma_axi_awsize,\n\n\n   input  logic                        dma_axi_wvalid,\n   output logic                        dma_axi_wready,\n   input  logic [63:0]                 dma_axi_wdata,\n   input  logic [7:0]                  dma_axi_wstrb,\n\n   output logic                        dma_axi_bvalid,\n   input  logic                        dma_axi_bready,\n   output logic [1:0]                  dma_axi_bresp,\n   output logic [pt.DMA_BUS_TAG-1:0]   dma_axi_bid,\n\n   // AXI Read Channels\n   input  logic                        dma_axi_arvalid,\n   output logic                        dma_axi_arready,\n   input  logic [pt.DMA_BUS_TAG-1:0]   dma_axi_arid,\n   input  logic [31:0]                 dma_axi_araddr,\n   input  logic [2:0]                  dma_axi_arsize,\n\n   output logic                        dma_axi_rvalid,\n   input  logic                        dma_axi_rready,\n   output logic [pt.DMA_BUS_TAG-1:0]   dma_axi_rid,\n   output logic [63:0]                 dma_axi_rdata,\n   output logic [1:0]                  dma_axi_rresp,\n   output logic                        dma_axi_rlast\n);\n\n\n   localparam DEPTH = pt.DMA_BUF_DEPTH;\n   localparam DEPTH_PTR = $clog2(DEPTH);\n   localparam NACK_COUNT = 7;\n\n   logic [DEPTH-1:0]        fifo_valid;\n   logic [DEPTH-1:0][1:0]   fifo_error;\n   logic [DEPTH-1:0]        fifo_dccm_valid;\n   logic [DEPTH-1:0]        fifo_iccm_valid;\n   logic [DEPTH-1:0]        fifo_error_bus;\n   logic [DEPTH-1:0]        fifo_rpend;\n   logic [DEPTH-1:0]        fifo_done;      // DMA trxn is done in core\n   logic [DEPTH-1:0]        fifo_done_bus;  // DMA trxn is done in core but synced to bus clock\n   logic [DEPTH-1:0][31:0]  fifo_addr;\n   logic [DEPTH-1:0][2:0]   fifo_sz;\n   logic [DEPTH-1:0][7:0]   fifo_byteen;\n   logic [DEPTH-1:0]        fifo_write;\n   logic [DEPTH-1:0]        fifo_posted_write;\n   logic [DEPTH-1:0]        fifo_dbg;\n   logic [DEPTH-1:0][63:0]  fifo_data;\n   logic [DEPTH-1:0][pt.DMA_BUS_TAG-1:0]  fifo_tag;\n   logic [DEPTH-1:0][pt.DMA_BUS_ID-1:0]   fifo_mid;\n   logic [DEPTH-1:0][pt.DMA_BUS_PRTY-1:0] fifo_prty;\n\n   logic [DEPTH-1:0]        fifo_cmd_en;\n   logic [DEPTH-1:0]        fifo_data_en;\n   logic [DEPTH-1:0]        fifo_data_bus_en;\n   logic [DEPTH-1:0]        fifo_pend_en;\n   logic [DEPTH-1:0]        fifo_done_en;\n   logic [DEPTH-1:0]        fifo_done_bus_en;\n   logic [DEPTH-1:0]        fifo_error_en;\n   logic [DEPTH-1:0]        fifo_error_bus_en;\n   logic [DEPTH-1:0]        fifo_reset;\n   logic [DEPTH-1:0][1:0]   fifo_error_in;\n   logic [DEPTH-1:0][63:0]  fifo_data_in;\n\n   logic                    fifo_write_in;\n   logic                    fifo_posted_write_in;\n   logic                    fifo_dbg_in;\n   logic [31:0]             fifo_addr_in;\n   logic [2:0]              fifo_sz_in;\n   logic [7:0]              fifo_byteen_in;\n\n   logic [DEPTH_PTR-1:0]    RspPtr, NxtRspPtr;\n   logic [DEPTH_PTR-1:0]    WrPtr, NxtWrPtr;\n   logic [DEPTH_PTR-1:0]    RdPtr, NxtRdPtr;\n   logic                    WrPtrEn, RdPtrEn, RspPtrEn;\n\n   logic [1:0]              dma_dbg_sz;\n   logic [1:0]              dma_dbg_addr;\n   logic [31:0]             dma_dbg_mem_rddata;\n   logic [31:0]             dma_dbg_mem_wrdata;\n   logic                    dma_dbg_cmd_error;\n   logic                    dma_dbg_cmd_done_q;\n\n   logic                    fifo_full, fifo_full_spec, fifo_empty;\n   logic                    dma_address_error, dma_alignment_error;\n   logic [3:0]              num_fifo_vld;\n   logic                    dma_mem_req_spec, dma_mem_req;\n   logic [7:0]              dma_mem_byteen;\n   logic [31:0]             dma_mem_addr_int;\n   logic [2:0]              dma_mem_sz_int;\n   logic                    dma_mem_addr_in_iccm;\n   logic                    dma_mem_addr_in_pic;\n   logic                    dma_mem_addr_in_pic_region_nc;\n   logic                    dma_mem_addr_in_dccm_region_nc;\n   logic                    dma_mem_addr_in_iccm_region_nc;\n\n   logic [2:0]              dma_nack_count, dma_nack_count_d, dma_nack_count_csr;\n\n   logic                    dma_buffer_c1_clken;\n   logic                    dma_free_clken;\n   logic                    dma_buffer_c1_clk;\n   logic                    dma_free_clk;\n   logic                    dma_bus_clk;\n\n   logic                    bus_rsp_valid, bus_rsp_sent;\n   logic                    bus_cmd_valid, bus_cmd_sent;\n   logic                    bus_cmd_read, bus_cmd_write, bus_cmd_posted_write;\n   logic [7:0]              bus_cmd_byteen;\n   logic [2:0]              bus_cmd_sz;\n   logic [31:0]             bus_cmd_addr;\n   logic [63:0]             bus_cmd_wdata;\n   logic [pt.DMA_BUS_TAG-1:0]  bus_cmd_tag;\n   logic [pt.DMA_BUS_ID-1:0]   bus_cmd_mid;\n   logic [pt.DMA_BUS_PRTY-1:0] bus_cmd_prty;\n   logic                    bus_posted_write_done;\n\n   logic                    fifo_full_spec_bus;\n   logic                    dbg_dma_bubble_bus;\n   logic                    dbg_mem_cmd_valid;\n   logic                    dma_fifo_ready;\n\n   logic                       wrbuf_en, wrbuf_data_en;\n   logic                       wrbuf_cmd_sent, wrbuf_rst, wrbuf_data_rst;\n   logic                       wrbuf_vld, wrbuf_data_vld;\n   logic [pt.DMA_BUS_TAG-1:0]  wrbuf_tag;\n   logic [2:0]                 wrbuf_sz;\n   logic [31:0]                wrbuf_addr;\n   logic [63:0]                wrbuf_data;\n   logic [7:0]                 wrbuf_byteen;\n\n   logic                       rdbuf_en;\n   logic                       rdbuf_cmd_sent, rdbuf_rst;\n   logic                       rdbuf_vld;\n   logic [pt.DMA_BUS_TAG-1:0]  rdbuf_tag;\n   logic [2:0]                 rdbuf_sz;\n   logic [31:0]                rdbuf_addr;\n\n   logic                       axi_mstr_prty_in, axi_mstr_prty_en;\n   logic                       axi_mstr_priority;\n   logic                       axi_mstr_sel;\n\n   logic                       axi_rsp_valid, axi_rsp_sent;\n   logic                       axi_rsp_write;\n   logic [pt.DMA_BUS_TAG-1:0]  axi_rsp_tag;\n   logic [1:0]                 axi_rsp_error;\n   logic [63:0]                axi_rsp_rdata;\n\n   logic                       axi_rsp_posted_write;\n\n   //------------------------LOGIC STARTS HERE---------------------------------\n\n   // FIFO inputs\n   assign dbg_mem_cmd_valid     = dbg_cmd_valid & dbg_cmd_type[1];\n   assign fifo_addr_in[31:0]    = dbg_mem_cmd_valid ? dbg_cmd_addr[31:0] : bus_cmd_addr[31:0];\n   assign fifo_byteen_in[7:0]   = dbg_mem_cmd_valid ? (8'h0f << 4*dbg_cmd_addr[2]) : bus_cmd_byteen[7:0];\n   assign fifo_sz_in[2:0]       = dbg_mem_cmd_valid ? {1'b0,dbg_cmd_size[1:0]} : bus_cmd_sz[2:0];\n   assign fifo_write_in         = dbg_mem_cmd_valid ? dbg_cmd_write : bus_cmd_write;\n   assign fifo_posted_write_in  = ~dbg_mem_cmd_valid & bus_cmd_posted_write;\n   assign fifo_dbg_in           = dbg_mem_cmd_valid;\n\n   for (genvar i=0 ;i<DEPTH; i++) begin: GenFifo\n      assign fifo_cmd_en[i]   = ((bus_cmd_sent & dma_bus_clk_en) | dbg_mem_cmd_valid) & (i == WrPtr[DEPTH_PTR-1:0]);\n      assign fifo_data_en[i] = (((bus_cmd_sent & fifo_write_in & dma_bus_clk_en) | (dbg_mem_cmd_valid & dbg_cmd_write))  & (i == WrPtr[DEPTH_PTR-1:0])) |\n                               ((dma_address_error | dma_alignment_error) & (i == RdPtr[DEPTH_PTR-1:0])) |\n                               (dccm_dma_rvalid & (i == DEPTH_PTR'(dccm_dma_rtag[2:0]))) |\n                               (iccm_dma_rvalid & (i == DEPTH_PTR'(iccm_dma_rtag[2:0])));\n      assign fifo_pend_en[i] = (dma_dccm_req | dma_iccm_req) & ~dma_mem_write & (i == RdPtr[DEPTH_PTR-1:0]);\n      assign fifo_error_en[i] = ((dma_address_error | dma_alignment_error | dma_dbg_cmd_error) & (i == RdPtr[DEPTH_PTR-1:0])) |\n                                ((dccm_dma_rvalid & dccm_dma_ecc_error) & (i == DEPTH_PTR'(dccm_dma_rtag[2:0]))) |\n                                ((iccm_dma_rvalid & iccm_dma_ecc_error) & (i == DEPTH_PTR'(iccm_dma_rtag[2:0])));\n      assign fifo_error_bus_en[i] = (((|fifo_error_in[i][1:0]) & fifo_error_en[i]) | (|fifo_error[i])) & dma_bus_clk_en;\n      assign fifo_done_en[i] = ((|fifo_error[i] | fifo_error_en[i] | ((dma_dccm_req | dma_iccm_req) & dma_mem_write)) & (i == RdPtr[DEPTH_PTR-1:0])) |\n                               (dccm_dma_rvalid & (i == DEPTH_PTR'(dccm_dma_rtag[2:0]))) |\n                               (iccm_dma_rvalid & (i == DEPTH_PTR'(iccm_dma_rtag[2:0])));\n      assign fifo_done_bus_en[i] = (fifo_done_en[i] | fifo_done[i]) & dma_bus_clk_en;\n      assign fifo_reset[i] = (((bus_rsp_sent | bus_posted_write_done) & dma_bus_clk_en) | dma_dbg_cmd_done) & (i == RspPtr[DEPTH_PTR-1:0]);\n      assign fifo_error_in[i]   = (dccm_dma_rvalid & (i == DEPTH_PTR'(dccm_dma_rtag[2:0]))) ? {1'b0,dccm_dma_ecc_error} : (iccm_dma_rvalid & (i == DEPTH_PTR'(iccm_dma_rtag[2:0]))) ? {1'b0,iccm_dma_ecc_error}  :\n                                                                                                                {(dma_address_error | dma_alignment_error | dma_dbg_cmd_error), dma_alignment_error};\n      assign fifo_data_in[i]   = (fifo_error_en[i] & (|fifo_error_in[i])) ? {32'b0,fifo_addr[i]} :\n                                                        ((dccm_dma_rvalid & (i == DEPTH_PTR'(dccm_dma_rtag[2:0])))  ? dccm_dma_rdata[63:0] : (iccm_dma_rvalid & (i == DEPTH_PTR'(iccm_dma_rtag[2:0]))) ? iccm_dma_rdata[63:0] :\n                                                                                                                                                       (dbg_mem_cmd_valid ? {2{dma_dbg_mem_wrdata[31:0]}} : bus_cmd_wdata[63:0]));\n\n      rvdffsc #(1) fifo_valid_dff (.din(1'b1), .dout(fifo_valid[i]), .en(fifo_cmd_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n      rvdffsc #(2) fifo_error_dff (.din(fifo_error_in[i]), .dout(fifo_error[i]), .en(fifo_error_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n      rvdffsc #(1) fifo_error_bus_dff (.din(1'b1), .dout(fifo_error_bus[i]), .en(fifo_error_bus_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n      rvdffsc #(1) fifo_rpend_dff (.din(1'b1), .dout(fifo_rpend[i]), .en(fifo_pend_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n      rvdffsc #(1) fifo_done_dff (.din(1'b1), .dout(fifo_done[i]), .en(fifo_done_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n      rvdffsc #(1) fifo_done_bus_dff (.din(1'b1), .dout(fifo_done_bus[i]), .en(fifo_done_bus_en[i]), .clear(fifo_reset[i]), .clk(dma_free_clk), .*);\n      rvdffe  #(32) fifo_addr_dff (.din(fifo_addr_in[31:0]), .dout(fifo_addr[i]), .en(fifo_cmd_en[i]), .*);\n      rvdffs  #(3) fifo_sz_dff (.din(fifo_sz_in[2:0]), .dout(fifo_sz[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffs  #(8) fifo_byteen_dff (.din(fifo_byteen_in[7:0]), .dout(fifo_byteen[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffs  #(1) fifo_write_dff (.din(fifo_write_in), .dout(fifo_write[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffs  #(1) fifo_posted_write_dff (.din(fifo_posted_write_in), .dout(fifo_posted_write[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffs  #(1) fifo_dbg_dff (.din(fifo_dbg_in), .dout(fifo_dbg[i]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffe  #(64) fifo_data_dff (.din(fifo_data_in[i]), .dout(fifo_data[i]), .en(fifo_data_en[i]), .*);\n      rvdffs  #(pt.DMA_BUS_TAG) fifo_tag_dff(.din(bus_cmd_tag[pt.DMA_BUS_TAG-1:0]), .dout(fifo_tag[i][pt.DMA_BUS_TAG-1:0]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffs  #(pt.DMA_BUS_ID) fifo_mid_dff(.din(bus_cmd_mid[pt.DMA_BUS_ID-1:0]), .dout(fifo_mid[i][pt.DMA_BUS_ID-1:0]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n      rvdffs  #(pt.DMA_BUS_PRTY) fifo_prty_dff(.din(bus_cmd_prty[pt.DMA_BUS_PRTY-1:0]), .dout(fifo_prty[i][pt.DMA_BUS_PRTY-1:0]), .en(fifo_cmd_en[i]), .clk(dma_buffer_c1_clk), .*);\n   end\n\n   // Pointer logic\n   assign NxtWrPtr[DEPTH_PTR-1:0] = (WrPtr[DEPTH_PTR-1:0] == (DEPTH-1)) ? '0 : WrPtr[DEPTH_PTR-1:0] + 1'b1;\n   assign NxtRdPtr[DEPTH_PTR-1:0] = (RdPtr[DEPTH_PTR-1:0] == (DEPTH-1)) ? '0 : RdPtr[DEPTH_PTR-1:0] + 1'b1;\n   assign NxtRspPtr[DEPTH_PTR-1:0] = (RspPtr[DEPTH_PTR-1:0] == (DEPTH-1)) ? '0 : RspPtr[DEPTH_PTR-1:0] + 1'b1;\n\n   assign WrPtrEn = |fifo_cmd_en[DEPTH-1:0];\n   assign RdPtrEn = dma_dccm_req | dma_iccm_req | (dma_address_error | dma_alignment_error | dma_dbg_cmd_error);\n   assign RspPtrEn = (dma_dbg_cmd_done | (bus_rsp_sent | bus_posted_write_done) & dma_bus_clk_en);\n\n   rvdffs #(DEPTH_PTR) WrPtr_dff(.din(NxtWrPtr[DEPTH_PTR-1:0]), .dout(WrPtr[DEPTH_PTR-1:0]), .en(WrPtrEn), .clk(dma_free_clk), .*);\n   rvdffs #(DEPTH_PTR) RdPtr_dff(.din(NxtRdPtr[DEPTH_PTR-1:0]), .dout(RdPtr[DEPTH_PTR-1:0]), .en(RdPtrEn), .clk(dma_free_clk), .*);\n   rvdffs #(DEPTH_PTR) RspPtr_dff(.din(NxtRspPtr[DEPTH_PTR-1:0]), .dout(RspPtr[DEPTH_PTR-1:0]), .en(RspPtrEn), .clk(dma_free_clk), .*);\n\n   // Miscellaneous signals\n   assign fifo_full = fifo_full_spec_bus;\n\n   always_comb begin\n      num_fifo_vld[3:0] = {3'b0,bus_cmd_sent} - {3'b0,bus_rsp_sent};\n      for (int i=0; i<DEPTH; i++) begin\n         num_fifo_vld[3:0] += {3'b0,fifo_valid[i]};\n      end\n   end\n   assign fifo_full_spec          = (num_fifo_vld[3:0] >= DEPTH);\n\n   assign dma_fifo_ready   = ~(fifo_full | dbg_dma_bubble_bus);\n\n   // Error logic\n   assign dma_address_error = fifo_valid[RdPtr] & ~fifo_done[RdPtr] & ~fifo_dbg[RdPtr] & (~(dma_mem_addr_in_dccm | dma_mem_addr_in_iccm));    // request not for ICCM or DCCM\n   assign dma_alignment_error = fifo_valid[RdPtr] & ~fifo_done[RdPtr] & ~fifo_dbg[RdPtr] & ~dma_address_error &\n                                (((dma_mem_sz_int[2:0] == 3'h1) & dma_mem_addr_int[0])                                                       |    // HW size but unaligned\n                                 ((dma_mem_sz_int[2:0] == 3'h2) & (|dma_mem_addr_int[1:0]))                                                  |    // W size but unaligned\n                                 ((dma_mem_sz_int[2:0] == 3'h3) & (|dma_mem_addr_int[2:0]))                                                  |    // DW size but unaligned\n                                 (dma_mem_addr_in_iccm & ~((dma_mem_sz_int[1:0] == 2'b10) | (dma_mem_sz_int[1:0] == 2'b11)))                 |    // ICCM access not word size\n                                 (dma_mem_addr_in_dccm & dma_mem_write & ~((dma_mem_sz_int[1:0] == 2'b10) | (dma_mem_sz_int[1:0] == 2'b11))) |    // DCCM write not word size\n                                 (dma_mem_write & (dma_mem_sz_int[2:0] == 3'h2) & (dma_mem_byteen[dma_mem_addr_int[2:0]+:4] != 4'hf))        |    // Write byte enables not aligned for word store\n                                 (dma_mem_write & (dma_mem_sz_int[2:0] == 3'h3) & ~((dma_mem_byteen[7:0] == 8'h0f) | (dma_mem_byteen[7:0] == 8'hf0) | (dma_mem_byteen[7:0] == 8'hff)))); // Write byte enables not aligned for dword store\n\n   //Dbg outputs\n   assign dma_dbg_ready    = fifo_empty & dbg_dma_bubble;\n   assign dma_dbg_cmd_done = (fifo_valid[RspPtr] & fifo_dbg[RspPtr] & fifo_done[RspPtr]);\n   assign dma_dbg_cmd_fail     = (|fifo_error[RspPtr] & dma_dbg_cmd_done);\n\n   assign dma_dbg_sz[1:0]          = fifo_sz[RspPtr][1:0];\n   assign dma_dbg_addr[1:0]        = fifo_addr[RspPtr][1:0];\n   assign dma_dbg_mem_rddata[31:0] = fifo_addr[RspPtr][2] ? fifo_data[RspPtr][63:32] : fifo_data[RspPtr][31:0];\n   assign dma_dbg_rddata[31:0]     = ({32{(dma_dbg_sz[1:0] == 2'h0)}} & ((dma_dbg_mem_rddata[31:0] >> 8*dma_dbg_addr[1:0]) & 32'hff)) |\n                                     ({32{(dma_dbg_sz[1:0] == 2'h1)}} & ((dma_dbg_mem_rddata[31:0] >> 16*dma_dbg_addr[1]) & 32'hffff)) |\n                                     ({32{(dma_dbg_sz[1:0] == 2'h2)}} & dma_dbg_mem_rddata[31:0]);\n\n   assign dma_dbg_cmd_error = fifo_valid[RdPtr] & ~fifo_done[RdPtr] & fifo_dbg[RdPtr] &\n                                 ((~(dma_mem_addr_in_dccm | dma_mem_addr_in_iccm | dma_mem_addr_in_pic)) |             // Address outside of ICCM/DCCM/PIC\n                                  ((dma_mem_addr_in_iccm | dma_mem_addr_in_pic) & (dma_mem_sz_int[1:0] != 2'b10)));    // Only word accesses allowed for ICCM/"}
{"text": "PIC\n\n   assign dma_dbg_mem_wrdata[31:0] = ({32{dbg_cmd_size[1:0] == 2'h0}} & {4{dbg_cmd_wrdata[7:0]}}) |\n                                     ({32{dbg_cmd_size[1:0] == 2'h1}} & {2{dbg_cmd_wrdata[15:0]}}) |\n                                     ({32{dbg_cmd_size[1:0] == 2'h2}} & dbg_cmd_wrdata[31:0]);\n\n   // Block the decode if fifo full\n   assign dma_dccm_stall_any = dma_mem_req_spec & (dma_mem_addr_in_dccm | dma_mem_addr_in_pic) & (dma_nack_count >= dma_nack_count_csr) & ~dccm_ready;\n   assign dma_iccm_stall_any = dma_mem_req_spec & dma_mem_addr_in_iccm & (dma_nack_count >= dma_nack_count_csr);\n\n   // Used to indicate ready to debug\n   assign fifo_empty     = ~((|fifo_valid[DEPTH-1:0]) | bus_cmd_sent);\n\n   // Nack counter, stall the lsu pipe if 7 nacks\n   assign dma_nack_count_csr[2:0] = dec_tlu_dma_qos_prty[2:0];\n   assign dma_nack_count_d[2:0] = (dma_nack_count[2:0] >= dma_nack_count_csr[2:0]) ? ({3{~(dma_dccm_req | dma_iccm_req)}} & dma_nack_count[2:0]) :\n                                                                                    (dma_mem_req & ~(dma_dccm_req | dma_iccm_req)) ? (dma_nack_count[2:0] + 1'b1) : 3'b0;\n\n   rvdffs #(3) nack_count_dff(.din(dma_nack_count_d[2:0]), .dout(dma_nack_count[2:0]), .en(dma_mem_req), .clk(dma_free_clk), .*);\n\n   // Core outputs\n   assign dma_mem_req_spec     = fifo_valid[RdPtr] & ~fifo_rpend[RdPtr] & ~fifo_done[RdPtr];\n   assign dma_mem_req         = dma_mem_req_spec & ~(dma_address_error | dma_alignment_error | dma_dbg_cmd_error);\n   assign dma_dccm_req        = dma_mem_req & (dma_mem_addr_in_dccm | dma_mem_addr_in_pic) & dccm_ready;\n   assign dma_dccm_spec_req   = dma_mem_req_spec & ~dma_mem_addr_in_iccm & dccm_ready;   // dma_mem_addr_in_iccm=0 for eh2_plus1 when ICCM doesn't exist\n   assign dma_iccm_req        = dma_mem_req & dma_mem_addr_in_iccm & iccm_ready;\n   assign dma_mem_tag[2:0]    = 3'(RdPtr);\n   assign dma_mem_addr_int[31:0] = fifo_addr[RdPtr];\n   assign dma_mem_sz_int[2:0] = fifo_sz[RdPtr];\n   assign dma_mem_addr[31:0]  = (dma_mem_write & ~fifo_dbg[RdPtr] & (dma_mem_byteen[7:0] == 8'hf0)) ? {dma_mem_addr_int[31:3],1'b1,dma_mem_addr_int[1:0]} : dma_mem_addr_int[31:0];\n   assign dma_mem_sz[2:0]     = (dma_mem_write & ~fifo_dbg[RdPtr] & ((dma_mem_byteen[7:0] == 8'h0f) | (dma_mem_byteen[7:0] == 8'hf0))) ? 3'h2 : dma_mem_sz_int[2:0];\n   assign dma_mem_byteen[7:0] = fifo_byteen[RdPtr];\n   assign dma_mem_write       = fifo_write[RdPtr];\n   assign dma_mem_wdata[63:0] = fifo_data[RdPtr];\n\n   // PMU outputs\n   assign dma_pmu_dccm_read   = dma_dccm_req & ~dma_mem_write;\n   assign dma_pmu_dccm_write  = dma_dccm_req & dma_mem_write;\n   assign dma_pmu_any_read    = (dma_dccm_req | dma_iccm_req) & ~dma_mem_write;\n   assign dma_pmu_any_write   = (dma_dccm_req | dma_iccm_req) & dma_mem_write;\n\n   // Address check  dccm\n   if (pt.DCCM_ENABLE) begin\n      rvrangecheck #(.CCM_SADR(pt.DCCM_SADR),\n                     .CCM_SIZE(pt.DCCM_SIZE)) addr_dccm_rangecheck (\n         .addr(dma_mem_addr[31:0]),\n         .in_range(dma_mem_addr_in_dccm),\n         .in_region(dma_mem_addr_in_dccm_region_nc)\n      );\n   end\n   else begin\n      assign dma_mem_addr_in_dccm = 1'b0;\n      assign dma_mem_addr_in_dccm_region_nc = 1'b0;\n   end // else: !if(pt.DCCM_ENABLE)\n\n   // Address check  iccm\n   if (pt.ICCM_ENABLE) begin\n      rvrangecheck #(.CCM_SADR(pt.ICCM_SADR),\n                     .CCM_SIZE(pt.ICCM_SIZE)) addr_iccm_rangecheck (\n         .addr(dma_mem_addr[31:0]),\n         .in_range(dma_mem_addr_in_iccm),\n         .in_region(dma_mem_addr_in_iccm_region_nc)\n      );\n   end\n   else  begin\n      assign dma_mem_addr_in_iccm = '0;\n      assign dma_mem_addr_in_iccm_region_nc = '0;\n   end // else: !if(pt.ICCM_ENABLE)\n\n\n   // PIC memory address check\n   rvrangecheck #(.CCM_SADR(pt.PIC_BASE_ADDR),\n                  .CCM_SIZE(pt.PIC_SIZE)) addr_pic_rangecheck (\n      .addr(dma_mem_addr[31:0]),\n      .in_range(dma_mem_addr_in_pic),\n      .in_region(dma_mem_addr_in_pic_region_nc)\n    );\n\n\n   // Inputs\n   rvdff_fpga #(1) fifo_full_bus_ff     (.din(fifo_full_spec),    .dout(fifo_full_spec_bus),     .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdff_fpga #(1) dbg_dma_bubble_ff    (.din(dbg_dma_bubble),    .dout(dbg_dma_bubble_bus),     .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdff      #(1) dma_dbg_cmd_doneff   (.din(dma_dbg_cmd_done),  .dout(dma_dbg_cmd_done_q),     .clk(free_clk), .*);\n\n   // Clock Gating logic\n   assign dma_buffer_c1_clken = (bus_cmd_valid & dma_bus_clk_en) | dbg_mem_cmd_valid | clk_override;\n   assign dma_free_clken = (bus_cmd_valid | bus_rsp_valid | dbg_mem_cmd_valid | dma_dbg_cmd_done | dma_dbg_cmd_done_q | (|fifo_valid[DEPTH-1:0]) | clk_override);\n\n   rvoclkhdr dma_buffer_c1cgc ( .en(dma_buffer_c1_clken), .l1clk(dma_buffer_c1_clk), .* );\n   rvoclkhdr dma_free_cgc (.en(dma_free_clken), .l1clk(dma_free_clk), .*);\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign dma_bus_clk = 1'b0;\n`else\n   rvclkhdr  dma_bus_cgc (.en(dma_bus_clk_en), .l1clk(dma_bus_clk), .*);\n`endif\n\n   // Write channel buffer\n   assign wrbuf_en       = dma_axi_awvalid & dma_axi_awready;\n   assign wrbuf_data_en  = dma_axi_wvalid & dma_axi_wready;\n   assign wrbuf_cmd_sent = bus_cmd_sent & bus_cmd_write;\n   assign wrbuf_rst      = wrbuf_cmd_sent & ~wrbuf_en;\n   assign wrbuf_data_rst = wrbuf_cmd_sent & ~wrbuf_data_en;\n\n   rvdffsc_fpga  #(.WIDTH(1))              wrbuf_vldff       (.din(1'b1), .dout(wrbuf_vld),      .en(wrbuf_en),      .clear(wrbuf_rst),      .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffsc_fpga  #(.WIDTH(1))              wrbuf_data_vldff  (.din(1'b1), .dout(wrbuf_data_vld), .en(wrbuf_data_en), .clear(wrbuf_data_rst), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga   #(.WIDTH(pt.DMA_BUS_TAG)) wrbuf_tagff       (.din(dma_axi_awid[pt.DMA_BUS_TAG-1:0]), .dout(wrbuf_tag[pt.DMA_BUS_TAG-1:0]), .en(wrbuf_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga   #(.WIDTH(3))              wrbuf_szff        (.din(dma_axi_awsize[2:0]),  .dout(wrbuf_sz[2:0]),     .en(wrbuf_en),                  .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffe        #(.WIDTH(32))             wrbuf_addrff      (.din(dma_axi_awaddr[31:0]), .dout(wrbuf_addr[31:0]),  .en(wrbuf_en & dma_bus_clk_en), .*);\n   rvdffe        #(.WIDTH(64))             wrbuf_dataff      (.din(dma_axi_wdata[63:0]),  .dout(wrbuf_data[63:0]),  .en(wrbuf_data_en & dma_bus_clk_en), .*);\n   rvdffs_fpga   #(.WIDTH(8))              wrbuf_byteenff    (.din(dma_axi_wstrb[7:0]),   .dout(wrbuf_byteen[7:0]), .en(wrbuf_data_en),             .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n\n   // Read channel buffer\n   assign rdbuf_en    = dma_axi_arvalid & dma_axi_arready;\n   assign rdbuf_cmd_sent = bus_cmd_sent & ~bus_cmd_write;\n   assign rdbuf_rst   = rdbuf_cmd_sent & ~rdbuf_en;\n\n   rvdffsc_fpga  #(.WIDTH(1))              rdbuf_vldff  (.din(1'b1), .dout(rdbuf_vld), .en(rdbuf_en), .clear(rdbuf_rst), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga   #(.WIDTH(pt.DMA_BUS_TAG)) rdbuf_tagff  (.din(dma_axi_arid[pt.DMA_BUS_TAG-1:0]), .dout(rdbuf_tag[pt.DMA_BUS_TAG-1:0]), .en(rdbuf_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffs_fpga   #(.WIDTH(3))              rdbuf_szff   (.din(dma_axi_arsize[2:0]),  .dout(rdbuf_sz[2:0]),    .en(rdbuf_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n   rvdffe       #(.WIDTH(32))              rdbuf_addrff (.din(dma_axi_araddr[31:0]), .dout(rdbuf_addr[31:0]), .en(rdbuf_en & dma_bus_clk_en), .*);\n\n   assign dma_axi_awready = ~(wrbuf_vld & ~wrbuf_cmd_sent);\n   assign dma_axi_wready  = ~(wrbuf_data_vld & ~wrbuf_cmd_sent);\n   assign dma_axi_arready = ~(rdbuf_vld & ~rdbuf_cmd_sent);\n\n   //Generate a single request from read/write channel\n   assign bus_cmd_valid                     = (wrbuf_vld & wrbuf_data_vld) | rdbuf_vld;\n   assign bus_cmd_sent                      = bus_cmd_valid & dma_fifo_ready;\n   assign bus_cmd_write                     = axi_mstr_sel;\n   assign bus_cmd_posted_write              = '0;\n   assign bus_cmd_addr[31:0]                = axi_mstr_sel ? wrbuf_addr[31:0] : rdbuf_addr[31:0];\n   assign bus_cmd_sz[2:0]                   = axi_mstr_sel ? wrbuf_sz[2:0] : rdbuf_sz[2:0];\n   assign bus_cmd_wdata[63:0]               = wrbuf_data[63:0];\n   assign bus_cmd_byteen[7:0]               = wrbuf_byteen[7:0];\n   assign bus_cmd_tag[pt.DMA_BUS_TAG-1:0]   = axi_mstr_sel ? wrbuf_tag[pt.DMA_BUS_TAG-1:0] : rdbuf_tag[pt.DMA_BUS_TAG-1:0];\n   assign bus_cmd_mid[pt.DMA_BUS_ID-1:0]    = '0;\n   assign bus_cmd_prty[pt.DMA_BUS_PRTY-1:0] = '0;\n\n   // Sel=1 -> write has higher priority\n   assign axi_mstr_sel     = (wrbuf_vld & wrbuf_data_vld & rdbuf_vld) ? axi_mstr_priority : (wrbuf_vld & wrbuf_data_vld);\n   assign axi_mstr_prty_in = ~axi_mstr_priority;\n   assign axi_mstr_prty_en = bus_cmd_sent;\n   rvdffs_fpga #(.WIDTH(1)) mstr_prtyff(.din(axi_mstr_prty_in), .dout(axi_mstr_priority), .en(axi_mstr_prty_en), .clk(dma_bus_clk), .clken(dma_bus_clk_en), .rawclk(clk), .*);\n\n   assign axi_rsp_valid                   = fifo_valid[RspPtr] & ~fifo_dbg[RspPtr] & fifo_done_bus[RspPtr];\n   assign axi_rsp_rdata[63:0]             = fifo_data[RspPtr];\n   assign axi_rsp_write                   = fifo_write[RspPtr];\n   assign axi_rsp_posted_write            = axi_rsp_write & fifo_posted_write[RspPtr];\n   assign axi_rsp_error[1:0]              = fifo_error[RspPtr][0] ? 2'b10 : (fifo_error[RspPtr][1] ? 2'b11 : 2'b0);\n   assign axi_rsp_tag[pt.DMA_BUS_TAG-1:0] = fifo_tag[RspPtr];\n\n   // AXI response channel signals\n   assign dma_axi_bvalid                  = axi_rsp_valid & axi_rsp_write;\n   assign dma_axi_bresp[1:0]              = axi_rsp_error[1:0];\n   assign dma_axi_bid[pt.DMA_BUS_TAG-1:0] = axi_rsp_tag[pt.DMA_BUS_TAG-1:0];\n\n   assign dma_axi_rvalid                  = axi_rsp_valid & ~axi_rsp_write;\n   assign dma_axi_rresp[1:0]              = axi_rsp_error;\n   assign dma_axi_rdata[63:0]             = axi_rsp_rdata[63:0];\n   assign dma_axi_rlast                   = 1'b1;\n   assign dma_axi_rid[pt.DMA_BUS_TAG-1:0] = axi_rsp_tag[pt.DMA_BUS_TAG-1:0];\n\n   assign bus_posted_write_done = 1'b0;\n   assign bus_rsp_valid      = (dma_axi_bvalid | dma_axi_rvalid);\n   assign bus_rsp_sent       = (dma_axi_bvalid & dma_axi_bready) | (dma_axi_rvalid & dma_axi_rready);\n   assign dma_active  = wrbuf_vld | rdbuf_vld | (|fifo_valid[DEPTH-1:0]);\n\n\n`ifdef RV_ASSERT_ON\n\n   for (genvar i=0; i<DEPTH; i++) begin\n      assert_fifo_done_and_novalid: assert #0 (~fifo_done[i] | fifo_valid[i]);\n   end\n\n     // Assertion to check awready stays stable during entire bus clock\n    property dma_axi_awready_stable;\n        @(posedge clk) disable iff(~rst_l)  (dma_axi_awready != $past(dma_axi_awready)) |-> $past(dma_bus_clk_en);\n     endproperty\n     assert_dma_axi_awready_stable: assert property (dma_axi_awready_stable) else\n        $display(\"DMA AXI awready changed in middle of bus clock\");\n\n     // Assertion to check wready stays stable during entire bus clock\n    property dma_axi_wready_stable;\n        @(posedge clk) disable iff(~rst_l)  (dma_axi_wready != $past(dma_axi_wready)) |-> $past(dma_bus_clk_en);\n     endproperty\n     assert_dma_axi_wready_stable: assert property (dma_axi_wready_stable) else\n        $display(\"DMA AXI wready changed in middle of bus clock\");\n\n     // Assertion to check arready stays stable during entire bus clock\n    property dma_axi_arready_stable;\n        @(posedge clk) disable iff(~rst_l)  (dma_axi_arready != $past(dma_axi_arready)) |-> $past(dma_bus_clk_en);\n     endproperty\n     assert_dma_axi_arready_stable: assert property (dma_axi_arready_stable) else\n        $display(\"DMA AXI arready changed in middle of bus clock\");\n\n     // Assertion to check bvalid stays stable during entire bus clock\n    property dma_axi_bvalid_stable;\n        @(posedge clk) disable iff(~rst_l)  (dma_axi_bvalid != $past(dma_axi_bvalid)) |-> $past(dma_bus_clk_en);\n     endproperty\n     assert_dma_axi_bvalid_stable: assert property (dma_axi_bvalid_stable) else\n        $display(\"DMA AXI bvalid changed in middle of bus clock\");\n\n     // Assertion to check bid stays stable during entire bus clock\n     property dma_axi_bid_stable;\n        @(posedge clk) disable iff(~rst_l)  (dma_axi_bvalid & (dma_axi_bid[pt.DMA_BUS_TAG-1:0] != $past(dma_axi_bid[pt.DMA_BUS_TAG-1:0]))) |-> $past(dma_bus_clk_en);\n     endproperty\n     assert_dma_axi_bid_stable: assert property (dma_axi_bid_stable) else\n        $display(\"DMA AXI bid changed in middle of bus clock\");\n\n     // Assertion to check bresp stays stable during entire bus clock\n     property dma_axi_bresp_stable;\n        @(posedge clk) disable iff(~rst_l)  (dma_axi_bvalid & (dma_axi_bresp[1:0] != $past(dma_axi_bresp[1:0]))) |-> $past(dma_bus_clk_en);\n     endproperty\n     assert_dma_axi_bresp_stable: assert property (dma_axi_bresp_stable) else\n        $display(\"DMA AXI bresp changed in middle of bus clock\");\n\n     // Assertion to check rvalid stays stable during entire bus clock\n     property dma_axi_rvalid_stable;\n        @(posedge clk) disable iff(~rst_l)  (dma_axi_rvalid != $past(dma_axi_rvalid)) |-> $past(dma_bus_clk_en);\n     endproperty\n     assert_dma_axi_rvalid_stable: assert property (dma_axi_rvalid_stable) else\n        $display(\"DMA AXI rvalid changed in middle of bus clock\");\n\n     // Assertion to check rid stays stable during entire bus clock\n     property dma_axi_rid_stable;\n        @(posedge clk) disable iff(~rst_l)  (dma_axi_rvalid & (dma_axi_rid[pt.DMA_BUS_TAG-1:0] != $past(dma_axi_rid[pt.DMA_BUS_TAG-1:0]))) |-> $past(dma_bus_clk_en);\n     endproperty\n     assert_dma_axi_rid_stable: assert property (dma_axi_rid_stable) else\n        $display(\"DMA AXI rid changed in middle of bus clock\");\n\n     // Assertion to check rresp stays stable during entire bus clock\n     property dma_axi_rresp_stable;\n        @(posedge clk) disable iff(~rst_l)  (dma_axi_rvalid & (dma_axi_rresp[1:0] != $past(dma_axi_rresp[1:0]))) |-> $past(dma_bus_clk_en);\n     endproperty\n     assert_dma_axi_rresp_stable: assert property (dma_axi_rresp_stable) else\n        $display(\"DMA AXI rresp changed in middle of bus clock\");\n\n     // Assertion to check rdata stays stable during entire bus clock\n     property dma_axi_rdata_stable;\n        @(posedge clk) disable iff(~rst_l)  (dma_axi_rvalid & (dma_axi_rdata[63:0] != $past(dma_axi_rdata[63:0]))) |-> $past(dma_bus_clk_en);\n     endproperty\n     assert_dma_axi_rdata_stable: assert property (dma_axi_rdata_stable) else\n        $display(\"DMA AXI rdata changed in middle of bus clock\");\n\n`endif\n\nendmodule // eh2_dma_ctrl\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nmodule eh2_exu\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n\n   input logic                                   clk,                          // Top level clock\n   input logic [pt.NUM_THREADS-1:0]              active_thread_l2clk,\n   input logic                                   clk_override,                 // Override multiply clock enables\n   input logic                                   rst_l,                        // Reset\n   input logic                                   scan_mode,                    // Scan control\n\n   input logic                                   dec_i0_secondary_d,           // I0 Secondary ALU at  D-stage.  Used for clock gating\n   input logic                                   dec_i0_secondary_e1,          // I0 Secondary ALU at E1-stage.  Used for clock gating\n   input logic                                   dec_i0_secondary_e2,          // I0 Secondary ALU at E2-stage.  Used for clock gating\n\n   input logic                                   dec_i1_secondary_d,           // I1 Secondary ALU at  D-stage.  Used for clock gating\n   input logic                                   dec_i1_secondary_e1,          // I1 Secondary ALU at E1-stage.  Used for clock gating\n   input logic                                   dec_i1_secondary_e2,          // I1 Secondary ALU at E2-stage.  Used for clock gating\n\n   input logic                                   dec_i0_branch_d,              // I0 Branch at  D-stage.  Used for clock gating\n   input logic                                   dec_i0_branch_e1,             // I0 Branch at E1-stage.  Used for clock gating\n   input logic                                   dec_i0_branch_e2,             // I0 Branch at E2-stage.  Used for clock gating\n   input logic                                   dec_i0_branch_e3,             // I0 Branch at E3-stage.  Used for clock gating\n\n   input logic                                   dec_i1_branch_d,              // I0 Branch at  D-stage.  Used for clock gating\n   input logic                                   dec_i1_branch_e1,             // I0 Branch at E1-stage.  Used for clock gating\n   input logic                                   dec_i1_branch_e2,             // I0 Branch at E2-stage.  Used for clock gating\n   input logic                                   dec_i1_branch_e3,             // I0 Branch at E3-stage.  Used for clock gating\n\n   input logic                                   dec_i0_pc4_e4,                // I0 PC4 to PMU\n   input logic                                   dec_i1_pc4_e4,                // I1 PC4 to PMU\n\n   input logic                                   dec_extint_stall,             // External interrupt mux select\n   input logic                      [31:2]       dec_tlu_meihap,               // External interrupt mux data\n\n   input logic [4:1]                             dec_i0_data_en,               // Slot I0 clock enable {e1, e2, e3    }, one cycle pulse\n   input logic [4:1]                             dec_i0_ctl_en,                // Slot I0 clock enable {e1, e2, e3, e4}, two cycle pulse\n   input logic [4:1]                             dec_i1_data_en,               // Slot I1 clock enable {e1, e2, e3    }, one cycle pulse\n   input logic [4:1]                             dec_i1_ctl_en,                // Slot I1 clock enable {e1, e2, e3, e4}, two cycle pulse\n\n   input logic                                   dec_debug_wdata_rs1_d,        // Debug select to primary I0 RS1\n\n   input logic [31:0]                            dbg_cmd_wrdata,               // Debug data   to primary I0 RS1\n\n   input logic [31:0]                            lsu_result_dc3,               // Load result\n\n   input eh2_predict_pkt_t                      i0_predict_p_d,               // DEC branch predict packet\n   input eh2_predict_pkt_t                      i1_predict_p_d,               // DEC branch predict packet\n   input logic [pt.BHT_GHR_SIZE-1:0]             i0_predict_fghr_d,            // DEC predict fghr\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]   i0_predict_index_d,           // DEC predict index\n   input logic [pt.BTB_BTAG_SIZE-1:0]            i0_predict_btag_d,            // DEC predict branch tag\n   input logic [pt.BTB_TOFFSET_SIZE-1:0]         i0_predict_toffset_d,         // DEC predict branch toffset\n   input logic [pt.BHT_GHR_SIZE-1:0]             i1_predict_fghr_d,            // DEC predict fghr\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]   i1_predict_index_d,           // DEC predict index\n   input logic [pt.BTB_BTAG_SIZE-1:0]            i1_predict_btag_d,            // DEC predict branch tag\n   input logic [pt.BTB_TOFFSET_SIZE-1:0]         i1_predict_toffset_d,         // DEC predict branch toffset\n\n   input logic                                   dec_i0_rs1_bypass_en_e2,      // DEC bypass bus select for E2 stage\n   input logic                                   dec_i0_rs2_bypass_en_e2,      // DEC bypass bus select for E2 stage\n   input logic                                   dec_i1_rs1_bypass_en_e2,      // DEC bypass bus select for E2 stage\n   input logic                                   dec_i1_rs2_bypass_en_e2,      // DEC bypass bus select for E2 stage\n   input logic [31:0]                            i0_rs1_bypass_data_e2,        // DEC bypass bus\n   input logic [31:0]                            i0_rs2_bypass_data_e2,        // DEC bypass bus\n   input logic [31:0]                            i1_rs1_bypass_data_e2,        // DEC bypass bus\n   input logic [31:0]                            i1_rs2_bypass_data_e2,        // DEC bypass bus\n\n   input logic                                   dec_i0_rs1_bypass_en_e3,      // DEC bypass bus select for E3 stage\n   input logic                                   dec_i0_rs2_bypass_en_e3,      // DEC bypass bus select for E3 stage\n   input logic                                   dec_i1_rs1_bypass_en_e3,      // DEC bypass bus select for E3 stage\n   input logic                                   dec_i1_rs2_bypass_en_e3,      // DEC bypass bus select for E3 stage\n   input logic [31:0]                            i0_rs1_bypass_data_e3,        // DEC bypass bus\n   input logic [31:0]                            i0_rs2_bypass_data_e3,        // DEC bypass bus\n   input logic [31:0]                            i1_rs1_bypass_data_e3,        // DEC bypass bus\n   input logic [31:0]                            i1_rs2_bypass_data_e3,        // DEC bypass bus\n\n   input logic                                   dec_i0_sec_decode_e3,         // Secondary ALU valid\n   input logic                                   dec_i1_sec_decode_e3,         // Secondary ALU valid\n   input logic [31:1]                            dec_i0_pc_e3,                 // Secondary ALU PC\n   input logic [31:1]                            dec_i1_pc_e3,                 // Secondary ALU PC\n\n   input logic [pt.NUM_THREADS-1:0][31:1]        pred_correct_npc_e2,          // npc e2 if the prediction is correct\n\n   input logic                                   dec_i1_valid_e1,              // I1 valid E1\n\n   input logic                                   dec_i0_mul_d,                 // Select for Multiply GPR value\n   input logic                                   dec_i1_mul_d,                 // Select for Multiply GPR value\n\n   input logic                                   dec_i0_div_d,                 // Select for Divide GPR value\n   input logic                                   dec_div_cancel,               // Cancel divide operation due to write-after-write\n\n   input logic [31:0]                            gpr_i0_rs1_d,                 // DEC data gpr\n   input logic [31:0]                            gpr_i0_rs2_d,                 // DEC data gpr\n   input logic [31:0]                            dec_i0_immed_d,               // DEC data immediate\n\n   input logic [31:0]                            gpr_i1_rs1_d,                 // DEC data gpr\n   input logic [31:0]                            gpr_i1_rs2_d,                 // DEC data gpr\n   input logic [31:0]                            dec_i1_immed_d,               // DEC data immediate\n\n   input logic [31:0]                            i0_rs1_bypass_data_d,         // DEC bypass data\n   input logic [31:0]                            i0_rs2_bypass_data_d,         // DEC bypass data\n   input logic [31:0]                            i1_rs1_bypass_data_d,         // DEC bypass data\n   input logic [31:0]                            i1_rs2_bypass_data_d,         // DEC bypass data\n\n   input logic [pt.BTB_TOFFSET_SIZE:1]           dec_i0_br_immed_d,            // Branch immediate\n   input logic [pt.BTB_TOFFSET_SIZE:1]           dec_i1_br_immed_d,            // Branch immediate\n\n   input logic                                   dec_i0_lsu_d,                 // Bypass control for LSU operand bus\n   input logic                                   dec_i1_lsu_d,                 // Bypass control for LSU operand bus\n\n   input logic                                   dec_i0_csr_ren_d,             // Clear I0 RS1 primary\n\n   input eh2_alu_pkt_t                          i0_ap,                        // DEC alu {valid,predecodes}\n   input eh2_alu_pkt_t                          i1_ap,                        // DEC alu {valid,predecodes}\n\n   input eh2_mul_pkt_t                          mul_p,                        // DEC {valid, operand signs, low, operand bypass}\n   input eh2_div_pkt_t                          div_p,                        // DEC {valid, unsigned, rem}\n\n   input logic                                   dec_i0_alu_decode_d,          // Valid to Primary ALU\n   input logic                                   dec_i1_alu_decode_d,          // Valid to Primary ALU\n\n   input logic                                   dec_i0_select_pc_d,           // PC select to RS1\n   input logic                                   dec_i1_select_pc_d,           // PC select to RS1\n\n   input logic [31:1]                            dec_i0_pc_d,                  // I0 Instruction PC\n   input logic [31:1]                            dec_i1_pc_d,                  // I1 Instruction PC\n\n   input logic                                   dec_i0_rs1_bypass_en_d,       // DEC bypass select\n   input logic                                   dec_i0_rs2_bypass_en_d,       // DEC bypass select\n   input logic                                   dec_i1_rs1_bypass_en_d,       // DEC bypass select\n   input logic                                   dec_i1_rs2_bypass_en_d,       // DEC bypass select\n\n   input logic [pt.NUM_THREADS-1:0]              dec_tlu_flush_lower_wb,       // Flush divide and secondary ALUs\n   input logic [pt.NUM_THREADS-1:0] [31:1]       dec_tlu_flush_path_wb,        // Redirect target\n\n   input logic                                   dec_tlu_i0_valid_e4,          // Valid for GHR\n   input logic                                   dec_tlu_i1_valid_e4,          // Valid for GHR\n\n\n\n   output logic [31:0]                           exu_i0_result_e1,             // Primary ALU result to DEC\n   output logic [31:0]                           exu_i1_result_e1,             // Primary ALU result to DEC\n   output logic [31:1]                           exu_i0_pc_e1,                 // Primary PC  result to DEC\n   output logic [31:1]                           exu_i1_pc_e1,                 // Primary PC  result to DEC\n\n   output logic [31:0]                           exu_i0_result_e4,             // Secondary ALU result\n   output logic [31:0]                           exu_i1_result_e4,             // Secondary ALU result\n\n   output logic [31:0]                           exu_lsu_rs1_d,                // LSU operand\n   output logic [31:0]                           exu_lsu_rs2_d,                // LSU operand\n\n   output logic [31:0]                           exu_i0_csr_rs1_e1,            // RS1 source for a CSR instruction\n\n   output logic [pt.NUM_THREADS-1:0]             exu_flush_final,              // Pipe is being flushed this cycle\n   output logic [pt.NUM_THREADS-1:0]             exu_i0_flush_final,           // I0 flush to DEC\n   output logic [pt.NUM_THREADS-1:0]             exu_i1_flush_final,           // I1 flush to DEC\n\n\n   output logic [pt.NUM_THREADS-1:0][31:1]       exu_flush_path_final,         // Target for the oldest flush source\n\n   output logic [pt.NUM_THREADS-1:0]             exu_flush_final_early,        // Pipe is being flushed this cycle\n   output logic [pt.NUM_THREADS-1:0][31:1]       exu_flush_path_final_early,   // Target for the oldest flush source\n\n   output logic [31:0]                           exu_mul_result_e3,            // Multiply result\n\n   output logic [31:0]                           exu_div_result,               // Divide result\n   output logic                                  exu_div_wren,                 // Divide write enable to GPR\n   output logic [pt.NUM_THREADS-1:0] [31:1]      exu_npc_e4,                   // Divide NPC\n\n   output logic [pt.NUM_THREADS-1:0]             exu_i0_flush_lower_e4,        // to TLU - lower branch flush\n   output logic [pt.NUM_THREADS-1:0]             exu_i1_flush_lower_e4,        // to TLU - lower branch flush\n\n   output logic [31:1]                           exu_i0_flush_path_e4,         // to TLU - lower branch flush path\n   output logic [31:1]                           exu_i1_flush_path_e4,         // to TLU - lower branch flush path\n\n\n\n   output eh2_predict_pkt_t [pt.NUM_THREADS-1:0]                    exu_mp_pkt,      // to IFU_DP - final mispredict\n   output logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]           exu_mp_eghr,     // to IFU_DP - for bht write\n   output logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]           exu_mp_fghr,     // to IFU_DP - fghr repair value\n   output logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_mp_index,    // to IFU_DP - misprecict index\n   output logic [pt.NUM_THREADS-1:0] [pt.BTB_BTAG_SIZE-1:0]          exu_mp_btag,     // to IFU_DP - mispredict tag\n   output logic [pt.NUM_THREADS-1:0] [pt.BTB_TOFFSET_SIZE-1:0]       exu_mp_toffset,  // to IFU_DP - mispredict toffset\n\n\n   output logic [1:0]                            exu_i0_br_hist_e4,            // to DEC  I0 branch history\n   output logic                                  exu_i0_br_bank_e4,            // to DEC  I0 branch bank\n   output logic                                  exu_i0_br_error_e4,           // to DEC  I0 branch error\n   output logic                                  exu_i0_br_start_error_e4,     // to DEC  I0 branch start error\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  exu_i0_br_index_e4,           // to DEC  I0 branch index\n   output logic                                  exu_i0_br_valid_e4,           // to DEC  I0 branch valid\n   output logic                                  exu_i0_br_mp_e4,              // to DEC  I0 branch mispredict\n   output logic                                  exu_i0_br_way_e4,             // to DEC  I0 branch way\n   output logic                                  exu_i0_br_middle_e4,          // to DEC  I0 branch middle\n   output logic [pt.BHT_GHR_SIZE-1:0]            exu_i0_br_fghr_e4,            // to DEC  I0 branch fghr\n   output logic                                  exu_i0_br_ret_e4,             // to DEC  I0 branch return\n   output logic                                  exu_i0_br_call_e4,            // to DEC  I0 branch call\n\n   output logic [1:0]                            exu_i1_br_hist_e4,            // to DEC  I1 branch history\n   output logic                                  exu_i1_br_bank_e4,            // to DEC  I1 branch bank\n   output logic                                  exu_i1_br_error_e4,           // to DEC  I1 branch error\n   output logic                                  exu_i1_br_start_error_e4,     // to DEC  I1 branch start error\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  exu_i1_br_index_e4,           // to DEC  I1 branch index\n   output logic                                  exu_i1_br_valid_e4,           // to DEC  I1 branch valid\n   output logic                                  exu_i1_br_mp_e4,              // to DEC  I1 branch mispredict\n   output logic                                  exu_i1_br_way_e4,             // to DEC  I1 branch way\n   output logic                                  exu_i1_br_middle_e4,          // to DEC  I1 branch middle\n   output logic [pt.BHT_GHR_SIZE-1:0]            exu_i1_br_fghr_e4,            // to DEC  I1 branch fghr\n   output logic                                  exu_i1_br_ret_e4,             // to DEC  I1 branch return\n   output logic                                  exu_i1_br_call_e4,            // to DEC  I1 branch call\n\n   output logic                                  exu_pmu_i0_br_misp,           // to PMU - I0 E4 branch mispredict\n   output logic                                  exu_pmu_i0_br_ataken,         // to PMU - I0 E4 taken\n   output logic                                  exu_pmu_i0_pc4,               // to PMU - I0 E4 PC\n   output logic                                  exu_pmu_i1_br_misp,           // to PMU - I1 E4 branch mispredict\n   output logic                                  exu_pmu_i1_br_ataken,         // to PMU - I1 E4 taken\n   output logic                                  exu_pmu_i1_pc4                // to PMU - I1 E4 PC\n   );\n\n\n   logic [31:0]                      i0_rs1_d,i0_rs2_d,i1_rs1_d,i1_rs2_d;\n\n   logic [pt.NUM_THREADS-1:0]        i0_flush_upper_e1, i1_flush_upper_e1;\n\n   logic [31:1]                      i0_flush_path_e1;\n   logic [31:1]                      i1_flush_path_e1;\n\n   logic [31:0]                      i0_rs1_final_d;\n\n   logic [31:0]                      mul_rs1_d, mul_rs2_d;\n\n   logic [31:0]                      div_rs1_d, div_rs2_d;\n\n   logic                             i1_valid_e2;\n\n   logic [31:0]                      i0_rs1_e1, i0_rs2_e1;\n   logic [31:0]                      i0_rs1_e2, i0_rs2_e2;\n   logic [31:0]                      i0_rs1_e3, i0_rs2_e3;\n   logic [pt.BTB_TOFFSET_SIZE:1]     i0_br_immed_e1, i0_br_immed_e2, i0_br_immed_e3;\n\n   logic [31:0]                      i1_rs1_e1, i1_rs2_e1;\n   logic [31:0]                      i1_rs1_e2, i1_rs2_e2;\n   logic [31:0]                      i1_rs1_e3, i1_rs2_e3;\n\n   logic [pt.BTB_TOFFSET_SIZE:1]     i1_br_immed_e1, i1_br_immed_e2, i1_br_immed_e3;\n\n   logic [31:0]                      i0_rs1_e2_final, i0_rs2_e2_final;\n   logic [31:0]                      i1_rs1_e2_final, i1_rs2_e2_final;\n   logic [31:0]                      i0_rs1_e3_final, i0_rs2_e3_final;\n   logic [31:0]                      i1_rs1_e3_final, i1_rs2_e3_final;\n   logic [31:1]                      i0_alu_pc_unused, i1_alu_pc_unused;\n   logic [pt.NUM_THREADS-1:0]        i0_flush_upper_e2, i1_flush_upper_e2;\n   logic                             i1_valid_e3, i1_valid_e4;\n   logic [pt.NUM_THREADS-1:0] [31:1] pred_correct_npc_e3, pred_correct_npc_e4;\n   logic [pt.NUM_THREADS-1:0]        i0_flush_upper_e3;\n   logic [pt.NUM_THREADS-1:0]        i0_flush_upper_e4;\n   logic                             i1_pred_correct_upper_e1, i0_pred_correct_upper_e1;\n   logic                             i1_pred_correct_upper_e2, i0_pred_correct_upper_e2;\n   logic                             i1_pred_correct_upper_e3, i0_pred_correct_upper_e3;\n   logic                             i1_pred_correct_upper_e4, i0_pred_correct_upper_e4;\n   logic             "}
{"text": "                i1_pred_correct_lower_e4, i0_pred_correct_lower_e4;\n\n   logic [pt.NUM_THREADS-1:0]        i1_valid_e4_eff;\n   logic                             i1_sec_decode_e4, i0_sec_decode_e4;\n   logic                             i1_pred_correct_e4_eff, i0_pred_correct_e4_eff;\n   logic [31:1]                      i1_flush_path_e4_eff, i0_flush_path_e4_eff;\n   logic [31:1]                      i1_flush_path_upper_e2, i0_flush_path_upper_e2;\n   logic [31:1]                      i1_flush_path_upper_e3, i0_flush_path_upper_e3;\n   logic [31:1]                      i1_flush_path_upper_e4, i0_flush_path_upper_e4;\n\n   eh2_alu_pkt_t                    i0_ap_e1, i0_ap_e2, i0_ap_e3, i0_ap_e4;\n   eh2_alu_pkt_t                    i1_ap_e1, i1_ap_e2, i1_ap_e3, i1_ap_e4;\n\n   logic                             i0_e1_data_en, i0_e2_data_en, i0_e3_data_en, i0_e4_data_en;\n   logic                             i0_e1_ctl_en,  i0_e2_ctl_en,  i0_e3_ctl_en,  i0_e4_ctl_en;\n\n   logic                             i1_e1_data_en, i1_e2_data_en, i1_e3_data_en, i1_e4_data_en;\n   logic                             i1_e1_ctl_en,  i1_e2_ctl_en,  i1_e3_ctl_en,  i1_e4_ctl_en;\n\n   localparam PREDPIPESIZE = pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1+pt.BHT_GHR_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_TOFFSET_SIZE;\n   logic [PREDPIPESIZE-1:0]          i0_predpipe_d, i0_predpipe_e1, i0_predpipe_e2, i0_predpipe_e3, i0_predpipe_e4;\n   logic [PREDPIPESIZE-1:0]          i1_predpipe_d, i1_predpipe_e1, i1_predpipe_e2, i1_predpipe_e3, i1_predpipe_e4;\n\n   logic                             i0_taken_e1, i1_taken_e1, dec_i0_alu_decode_e1, dec_i1_alu_decode_e1;\n   logic [pt.NUM_THREADS-1:0]        flush_final_f;\n\n   eh2_predict_pkt_t                i0_predict_p_e1, i0_predict_p_e4;\n   eh2_predict_pkt_t                i1_predict_p_e1, i1_predict_p_e4;\n\n   eh2_predict_pkt_t                i0_pp_e2, i0_pp_e3, i0_pp_e4_in;\n   eh2_predict_pkt_t                i1_pp_e2, i1_pp_e3, i1_pp_e4_in;\n   eh2_predict_pkt_t                i0_predict_newp_d, i1_predict_newp_d;\n\n\n   logic [pt.NUM_THREADS-1:0]                        i0_valid_e1, i1_valid_e1;\n   logic [pt.NUM_THREADS-1:0]                        i0_valid_e4, i1_pred_valid_e4;\n   logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]  ghr_e1_ns, ghr_e1;\n   logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]  ghr_e4_ns, ghr_e4;\n   logic [pt.NUM_THREADS-1:0]                        fp_enable, fp_enable_ff;\n   logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]  after_flush_eghr;\n   logic [pt.NUM_THREADS-1:0] [PREDPIPESIZE-1:0]     final_predpipe_mp, final_predpipe_mp_ff;\n   eh2_predict_pkt_t [pt.NUM_THREADS-1:0]           final_predict_mp;\n   logic [pt.NUM_THREADS-1:0] [31:1]                 flush_path_e2;\n\n\n\n\n   assign i0_rs1_d[31:0]       = ({32{~dec_i0_rs1_bypass_en_d}} & ((dec_debug_wdata_rs1_d) ? dbg_cmd_wrdata[31:0] : gpr_i0_rs1_d[31:0])) |\n                                 ({32{~dec_i0_rs1_bypass_en_d   & dec_i0_select_pc_d}} & { dec_i0_pc_d[31:1], 1'b0}) |    // for jal's\n                                 ({32{ dec_i0_rs1_bypass_en_d}} & i0_rs1_bypass_data_d[31:0]);\n\n\n   assign i0_rs1_final_d[31:0] =  {32{~dec_i0_csr_ren_d}}       & i0_rs1_d[31:0];\n\n   assign i0_rs2_d[31:0]       = ({32{~dec_i0_rs2_bypass_en_d}} & gpr_i0_rs2_d[31:0]        ) |\n                                 ({32{~dec_i0_rs2_bypass_en_d}} & dec_i0_immed_d[31:0]      ) |\n                                 ({32{ dec_i0_rs2_bypass_en_d}} & i0_rs2_bypass_data_d[31:0]);\n\n   assign i1_rs1_d[31:0]       = ({32{~dec_i1_rs1_bypass_en_d}} & gpr_i1_rs1_d[31:0]) |\n                                 ({32{~dec_i1_rs1_bypass_en_d   & dec_i1_select_pc_d}} & { dec_i1_pc_d[31:1], 1'b0}) |  // pc orthogonal with rs1\n                                 ({32{ dec_i1_rs1_bypass_en_d}} & i1_rs1_bypass_data_d[31:0]);\n\n\n   assign i1_rs2_d[31:0]       = ({32{~dec_i1_rs2_bypass_en_d}} & gpr_i1_rs2_d[31:0]        ) |\n                                 ({32{~dec_i1_rs2_bypass_en_d}} & dec_i1_immed_d[31:0]      ) |\n                                 ({32{ dec_i1_rs2_bypass_en_d}} & i1_rs2_bypass_data_d[31:0]);\n\n\n   assign exu_lsu_rs1_d[31:0]  = ({32{ ~dec_i0_rs1_bypass_en_d &  dec_i0_lsu_d & ~dec_extint_stall               }} & gpr_i0_rs1_d[31:0]        ) |\n                                 ({32{ ~dec_i1_rs1_bypass_en_d & ~dec_i0_lsu_d & ~dec_extint_stall & dec_i1_lsu_d}} & gpr_i1_rs1_d[31:0]        ) |\n                                 ({32{  dec_i0_rs1_bypass_en_d &  dec_i0_lsu_d & ~dec_extint_stall               }} & i0_rs1_bypass_data_d[31:0]) |\n                                 ({32{  dec_i1_rs1_bypass_en_d & ~dec_i0_lsu_d & ~dec_extint_stall & dec_i1_lsu_d}} & i1_rs1_bypass_data_d[31:0]) |\n                                 ({32{                                            dec_extint_stall               }} & {dec_tlu_meihap[31:2],2'b0});\n\n   assign exu_lsu_rs2_d[31:0]  = ({32{ ~dec_i0_rs2_bypass_en_d &  dec_i0_lsu_d & ~dec_extint_stall               }} & gpr_i0_rs2_d[31:0]        ) |\n                                 ({32{ ~dec_i1_rs2_bypass_en_d & ~dec_i0_lsu_d & ~dec_extint_stall & dec_i1_lsu_d}} & gpr_i1_rs2_d[31:0]        ) |\n                                 ({32{  dec_i0_rs2_bypass_en_d &  dec_i0_lsu_d & ~dec_extint_stall               }} & i0_rs2_bypass_data_d[31:0]) |\n                                 ({32{  dec_i1_rs2_bypass_en_d & ~dec_i0_lsu_d & ~dec_extint_stall & dec_i1_lsu_d}} & i1_rs2_bypass_data_d[31:0]);\n\n\n   assign mul_rs1_d[31:0]      = ({32{ ~dec_i0_rs1_bypass_en_d &  dec_i0_mul_d               }} & gpr_i0_rs1_d[31:0]        ) |\n                                 ({32{ ~dec_i1_rs1_bypass_en_d & ~dec_i0_mul_d & dec_i1_mul_d}} & gpr_i1_rs1_d[31:0]        ) |\n                                 ({32{  dec_i0_rs1_bypass_en_d &  dec_i0_mul_d               }} & i0_rs1_bypass_data_d[31:0]) |\n                                 ({32{  dec_i1_rs1_bypass_en_d & ~dec_i0_mul_d & dec_i1_mul_d}} & i1_rs1_bypass_data_d[31:0]);\n\n   assign mul_rs2_d[31:0]      = ({32{ ~dec_i0_rs2_bypass_en_d &  dec_i0_mul_d               }} & {27'b0,dec_i0_immed_d[4:0]}) |\n                                 ({32{ ~dec_i1_rs2_bypass_en_d & ~dec_i0_mul_d & dec_i1_mul_d}} & {27'b0,dec_i1_immed_d[4:0]}) |\n                                 ({32{ ~dec_i0_rs2_bypass_en_d &  dec_i0_mul_d               }} & gpr_i0_rs2_d[31:0]         ) |\n                                 ({32{ ~dec_i1_rs2_bypass_en_d & ~dec_i0_mul_d & dec_i1_mul_d}} & gpr_i1_rs2_d[31:0]         ) |\n                                 ({32{  dec_i0_rs2_bypass_en_d &  dec_i0_mul_d               }} & i0_rs2_bypass_data_d[31:0] ) |\n                                 ({32{  dec_i1_rs2_bypass_en_d & ~dec_i0_mul_d & dec_i1_mul_d}} & i1_rs2_bypass_data_d[31:0] );\n\n\n\n   assign div_rs1_d[31:0]      = ({32{ ~dec_i0_rs1_bypass_en_d &  dec_i0_div_d               }} & gpr_i0_rs1_d[31:0]) |\n                                 ({32{  dec_i0_rs1_bypass_en_d &  dec_i0_div_d               }} & i0_rs1_bypass_data_d[31:0]);\n\n   assign div_rs2_d[31:0]      = ({32{ ~dec_i0_rs2_bypass_en_d &  dec_i0_div_d               }} & gpr_i0_rs2_d[31:0]) |\n                                 ({32{  dec_i0_rs2_bypass_en_d &  dec_i0_div_d               }} & i0_rs2_bypass_data_d[31:0]);\n\n\n\n   assign {i0_e1_data_en, i0_e2_data_en, i0_e3_data_en, i0_e4_data_en}  = dec_i0_data_en[4:1];\n   assign {i0_e1_ctl_en,  i0_e2_ctl_en,  i0_e3_ctl_en,  i0_e4_ctl_en }  = dec_i0_ctl_en[4:1];\n\n   assign {i1_e1_data_en, i1_e2_data_en, i1_e3_data_en, i1_e4_data_en}  = dec_i1_data_en[4:1];\n   assign {i1_e1_ctl_en,  i1_e2_ctl_en,  i1_e3_ctl_en,  i1_e4_ctl_en }  = dec_i1_ctl_en[4:1];\n\n\n\n\n   rvdffe #(32) i0_csr_rs1_ff (.*, .clk(clk), .en(i0_e1_data_en & dec_i0_csr_ren_d), .din(i0_rs1_d[31:0]), .dout(exu_i0_csr_rs1_e1[31:0]));\n\n\n   eh2_exu_mul_ctl #(.pt(pt)) mul_e1    (.*,\n                          .clk_override  ( clk_override                             ),   // I\n                          .mp            ( mul_p                                    ),   // I\n                          .a             ( mul_rs1_d[31:0]                          ),   // I\n                          .b             ( mul_rs2_d[31:0]                          ),   // I\n                          .out           ( exu_mul_result_e3[31:0]                  ));  // O\n\n\n   eh2_exu_div_ctl #(.pt(pt)) div_e1    (.*,\n                          .cancel        ( dec_div_cancel                           ),   // I\n                          .dp            ( div_p                                    ),   // I\n                          .dividend      ( div_rs1_d[31:0]                          ),   // I\n                          .divisor       ( div_rs2_d[31:0]                          ),   // I\n                          .finish_dly    ( exu_div_wren                             ),   // O\n                          .out           ( exu_div_result[31:0]                     ));  // O\n\n\n   always_comb begin\n      i0_predict_newp_d         = i0_predict_p_d;\n      i0_predict_newp_d.boffset = dec_i0_pc_d[1];  // from the start of inst\n      i0_predict_newp_d.bank    = i0_predict_p_d.bank;\n\n      i1_predict_newp_d         = i1_predict_p_d;\n      i1_predict_newp_d.boffset = dec_i1_pc_d[1];\n      i1_predict_newp_d.bank    = i1_predict_p_d.bank;\n\n   end\n\n\n\n\n   eh2_exu_alu_ctl #(.pt(pt)) i0_alu_e1 (.*,\n                          .b_enable      ( dec_i0_branch_d                          ),   // I\n                          .c_enable      ( i0_e1_ctl_en                             ),   // I\n                          .d_enable      ( i0_e1_data_en                            ),   // I\n                          .predict_p     ( i0_predict_newp_d                        ),   // I\n                          .valid         ( dec_i0_alu_decode_d                      ),   // I\n                          .flush         ( exu_flush_final                          ),   // I\n                          .a             ( i0_rs1_final_d[31:0]                     ),   // I\n                          .b             ( i0_rs2_d[31:0]                           ),   // I\n                          .pc            ( dec_i0_pc_d[31:1]                        ),   // I\n                          .brimm         ( dec_i0_br_immed_d[pt.BTB_TOFFSET_SIZE:1] ),   // I\n                          .ap_in_tid     ( i0_ap.tid                                ),   // I\n                          .ap            ( i0_ap_e1                                 ),   // I\n                          .out           ( exu_i0_result_e1[31:0]                   ),   // O\n                          .flush_upper   ( i0_flush_upper_e1                        ),   // O\n                          .flush_path    ( i0_flush_path_e1[31:1]                   ),   // O\n                          .predict_p_ff  ( i0_predict_p_e1                          ),   // O\n                          .pc_ff         ( exu_i0_pc_e1[31:1]                       ),   // O\n                          .pred_correct  ( i0_pred_correct_upper_e1                 ));  // O\n\n\n   eh2_exu_alu_ctl #(.pt(pt)) i1_alu_e1 (.*,\n                          .b_enable      ( dec_i1_branch_d                          ),   // I\n                          .c_enable      ( i1_e1_ctl_en                             ),   // I\n                          .d_enable      ( i1_e1_data_en                            ),   // I\n                          .predict_p     ( i1_predict_newp_d                        ),   // I\n                          .valid         ( dec_i1_alu_decode_d                      ),   // I\n                          .flush         ( exu_flush_final                          ),   // I\n                          .a             ( i1_rs1_d[31:0]                           ),   // I\n                          .b             ( i1_rs2_d[31:0]                           ),   // I\n                          .pc            ( dec_i1_pc_d[31:1]                        ),   // I\n                          .brimm         ( dec_i1_br_immed_d[pt.BTB_TOFFSET_SIZE:1] ),   // I\n                          .ap_in_tid     ( i1_ap.tid                                ),   // I\n                          .ap            ( i1_ap_e1                                 ),   // I\n                          .out           ( exu_i1_result_e1[31:0]                   ),   // O\n                          .flush_upper   ( i1_flush_upper_e1                        ),   // O\n                          .flush_path    ( i1_flush_path_e1[31:1]                   ),   // O\n                          .predict_p_ff  ( i1_predict_p_e1                          ),   // O\n                          .pc_ff         ( exu_i1_pc_e1[31:1]                       ),   // O\n                          .pred_correct  ( i1_pred_correct_upper_e1                 ));  // O\n\n\n\n   assign i0_predpipe_d[PREDPIPESIZE-1:0] = {i0_predict_fghr_d, i0_predict_index_d, i0_predict_btag_d, i0_predict_toffset_d};\n   assign i1_predpipe_d[PREDPIPESIZE-1:0] = {i1_predict_fghr_d, i1_predict_index_d, i1_predict_btag_d, i1_predict_toffset_d};\n\n\n   rvdffppie #(.WIDTH($bits(eh2_predict_pkt_t)),.LEFT(19),.RIGHT(9))  i0_pp_e2_ff         (.*, .clk(clk), .en ( i0_e2_ctl_en ), .den(i0_e2_data_en & dec_i0_branch_e1), .din( i0_predict_p_e1 ),  .dout( i0_pp_e2       ) );\n   rvdffppie #(.WIDTH($bits(eh2_predict_pkt_t)),.LEFT(19),.RIGHT(9))  i0_pp_e3_ff         (.*, .clk(clk), .en ( i0_e3_ctl_en ), .den(i0_e3_data_en & dec_i0_branch_e2), .din( i0_pp_e2        ),  .dout( i0_pp_e3       ) );\n   rvdffppie #(.WIDTH($bits(eh2_predict_pkt_t)),.LEFT(19),.RIGHT(9))  i1_pp_e2_ff         (.*, .clk(clk), .en ( i1_e2_ctl_en ), .den(i1_e2_data_en & dec_i1_branch_e1), .din( i1_predict_p_e1 ),  .dout( i1_pp_e2       ) );\n   rvdffppie #(.WIDTH($bits(eh2_predict_pkt_t)),.LEFT(19),.RIGHT(9))  i1_pp_e3_ff         (.*, .clk(clk), .en ( i1_e3_ctl_en ), .den(i1_e3_data_en & dec_i1_branch_e2), .din( i1_pp_e2        ),  .dout( i1_pp_e3       ) );\n\n\n   rvdffe #(PREDPIPESIZE)                                   i0_predpipe_e1_ff   (.*, .clk(clk), .en ( i0_e1_data_en & dec_i0_branch_d ),  .din( i0_predpipe_d   ),  .dout( i0_predpipe_e1 ) );\n   rvdffe #(PREDPIPESIZE)                                   i0_predpipe_e2_ff   (.*, .clk(clk), .en ( i0_e2_data_en & dec_i0_branch_e1),  .din( i0_predpipe_e1  ),  .dout( i0_predpipe_e2 ) );\n   rvdffe #(PREDPIPESIZE)                                   i0_predpipe_e3_ff   (.*, .clk(clk), .en ( i0_e3_data_en & dec_i0_branch_e2),  .din( i0_predpipe_e2  ),  .dout( i0_predpipe_e3 ) );\n   rvdffe #(PREDPIPESIZE)                                   i0_predpipe_e4_ff   (.*, .clk(clk), .en ( i0_e4_ctl_en  & dec_i0_branch_e3),  .din( i0_predpipe_e3  ),  .dout( i0_predpipe_e4 ) );\n\n   rvdffe #(PREDPIPESIZE)                                   i1_predpipe_e1_ff   (.*, .clk(clk), .en ( i1_e1_data_en & dec_i1_branch_d ),  .din( i1_predpipe_d   ),  .dout( i1_predpipe_e1 ) );\n   rvdffe #(PREDPIPESIZE)                                   i1_predpipe_e2_ff   (.*, .clk(clk), .en ( i1_e2_data_en & dec_i1_branch_e1),  .din( i1_predpipe_e1  ),  .dout( i1_predpipe_e2 ) );\n   rvdffe #(PREDPIPESIZE)                                   i1_predpipe_e3_ff   (.*, .clk(clk), .en ( i1_e3_data_en & dec_i1_branch_e2),  .din( i1_predpipe_e2  ),  .dout( i1_predpipe_e3 ) );\n   rvdffe #(PREDPIPESIZE)                                   i1_predpipe_e4_ff   (.*, .clk(clk), .en ( i1_e4_ctl_en  & dec_i1_branch_e3),  .din( i1_predpipe_e3  ),  .dout( i1_predpipe_e4 ) );\n\n\n   assign exu_pmu_i0_br_misp   = i0_predict_p_e4.misp;\n   assign exu_pmu_i0_br_ataken = i0_predict_p_e4.ataken;\n   assign exu_pmu_i0_pc4       = dec_i0_pc4_e4;\n   assign exu_pmu_i1_br_misp   = i1_predict_p_e4.misp;\n   assign exu_pmu_i1_br_ataken = i1_predict_p_e4.ataken;\n   assign exu_pmu_i1_pc4       = dec_i1_pc4_e4;\n\n\n\n   assign i0_pp_e4_in = i0_pp_e3;\n   assign i1_pp_e4_in = i1_pp_e3;\n\n   rvdfflie #(.WIDTH($bits(eh2_alu_pkt_t)),.LEFT(25)) i0_ap_e1_ff (.*,  .clk(clk), .en(i0_e1_data_en), .din(i0_ap),   .dout(i0_ap_e1) );\n   rvdfflie #(.WIDTH($bits(eh2_alu_pkt_t)),.LEFT(25)) i0_ap_e2_ff (.*,  .clk(clk), .en(i0_e2_data_en), .din(i0_ap_e1),.dout(i0_ap_e2) );\n   rvdfflie #(.WIDTH($bits(eh2_alu_pkt_t)),.LEFT(25)) i0_ap_e3_ff (.*,  .clk(clk), .en(i0_e3_data_en), .din(i0_ap_e2),.dout(i0_ap_e3) );\n   rvdfflie #(.WIDTH($bits(eh2_alu_pkt_t)),.LEFT(25)) i0_ap_e4_ff (.*,  .clk(clk), .en(i0_e4_data_en), .din(i0_ap_e3),.dout(i0_ap_e4) );\n\n   rvdfflie #(.WIDTH($bits(eh2_alu_pkt_t)),.LEFT(25)) i1_ap_e1_ff (.*,  .clk(clk), .en(i1_e1_data_en), .din(i1_ap),   .dout(i1_ap_e1) );\n   rvdfflie #(.WIDTH($bits(eh2_alu_pkt_t)),.LEFT(25)) i1_ap_e2_ff (.*,  .clk(clk), .en(i1_e2_data_en), .din(i1_ap_e1),.dout(i1_ap_e2) );\n   rvdfflie #(.WIDTH($bits(eh2_alu_pkt_t)),.LEFT(25)) i1_ap_e3_ff (.*,  .clk(clk), .en(i1_e3_data_en), .din(i1_ap_e2),.dout(i1_ap_e3) );\n   rvdfflie #(.WIDTH($bits(eh2_alu_pkt_t)),.LEFT(25)) i1_ap_e4_ff (.*,  .clk(clk), .en(i1_e4_data_en), .din(i1_ap_e3),.dout(i1_ap_e4) );\n\n\n\n   rvdffe #(64+pt.BTB_TOFFSET_SIZE) i0_src_e1_ff (.*, .clk(clk),\n                            .en  (i0_e1_data_en & dec_i0_secondary_d),\n                            .din ({i0_rs1_d [31:0], i0_rs2_d [31:0], dec_i0_br_immed_d [pt.BTB_TOFFSET_SIZE:1]}),\n                            .dout({i0_rs1_e1[31:0], i0_rs2_e1[31:0],     i0_br_immed_e1[pt.BTB_TOFFSET_SIZE:1]}));\n\n   rvdffe #(64+pt.BTB_TOFFSET_SIZE) i0_src_e2_ff (.*, .clk(clk),\n                            .en  (i0_e2_data_en & dec_i0_secondary_e1),\n                            .din( {i0_rs1_e1[31:0], i0_rs2_e1[31:0], i0_br_immed_e1[pt.BTB_TOFFSET_SIZE:1]}),\n                            .dout({i0_rs1_e2[31:0], i0_rs2_e2[31:0], i0_br_immed_e2[pt.BTB_TOFFSET_SIZE:1]}));\n\n   rvdffe #(64+pt.BTB_TOFFSET_SIZE) i0_src_e3_ff (.*, .clk(clk),\n                            .en  (i0_e3_data_en & dec_i0_secondary_e2),\n                            .din( {i0_rs1_e2_final[31:0], i0_rs2_e2_final[31:0], i0_br_immed_e2[pt.BTB_TOFFSET_SIZE:1]}),\n                            .dout({i0_rs1_e3[31:0],       i0_rs2_e3[31:0],       i0_br_immed_e3[pt.BTB_TOFFSET_SIZE:1]}));\n\n\n\n   rvdffe #(64+pt.BTB_TOFFSET_SIZE) i1_src_e1_ff (.*, .clk(clk),\n                            .en  (i1_e1_data_en & dec_i1_secondary_d),\n                            .din ({i1_rs1_d [31:0], i1_rs2_d [31:0], dec_i1_br_immed_d [pt.BTB_TOFFSET_SIZE:1]}),\n                            .dout({i1_rs1_e1[31:0], i1_rs2_e1[31:0],     i1_br_immed_e1[pt.BTB_TOFFSET_SIZE:1]}));\n\n   rvdffe #(64+pt.BTB_TOFFSET_SIZE) i1_src_e2_ff (.*, .clk(clk),\n                            .en  (i1_e2_data_en & dec_i1_secondary_e1),\n                            .din ({i1_rs1_e1[31:0], i1_rs2_e1[31:0], i1_br_immed_e1[pt.BTB_TOFFSET_SIZE:1]}),\n                            .dout({i1_rs1_e2[31:0], i1_rs2_e2[31:0], i1_br_immed_e2[pt.BTB_TOFFSET_SIZE:1]}));\n\n   rvdffe #(64+pt.BTB_TOFFSET_SIZE) i1_src_e3_ff (.*, .clk(clk),\n                            .en  (i1_e3_data_en & dec_i1_secondary_e2),\n                            .din ({i1_rs1_e2_final[31:0], i1_rs2_e2_final[31:0], i1_br_immed_e2[pt.BTB_TOFFSET_SIZE:1]}),\n                            .dout({i1_rs1_e3[31:0],       i1_rs2_e3[31:0],       i1_br_immed_e3[pt.BTB_TOFFSET_SIZE:1]}));\n\n\n\n\n   assign i0_rs1_e2_final[31:0] = (dec_i0_rs1_bypass_en_e2) ? i0_rs1_bypass_data_e2[31:0] : i0_rs1_e2[31:0];\n   assign i0_rs2_e2_final[31:0] = (dec_i0_rs2_bypass_en_e2) ? i0_rs2_bypass_data_e2[31:0] : i0_rs2_e2[31:0];\n   assign i1_rs1_e2_final[31:0] = (dec_i1_rs1_bypass_en_e2) ? i1_rs1_bypass_data_e2[31:0] : i1_rs1_e2[31:0];\n   assign i1_rs2_e2_final[31:0] = (dec_i1_rs2_bypass_en_e2) ? i1_rs2_bypass_data_e2[31:0] : i1_rs2_e2[31:0];\n\n\n   assign i0_rs1_e3_final[31:0] = (dec_i0_rs1_bypass_en_e3) ? i0_rs1_bypass_data_e3[31:0] : i0_rs1_e3[31:0];\n   assign i0_rs2_e3_final[31:0] = (dec_i0_rs2_bypass_en_e3) ? i0_rs2_bypass_data_e3[31:0] : i0_rs2_e3[31:0];\n   assign i1_rs1_e3_final[31:0] = (dec_i1_rs1_bypass_en_e3) ? i1_rs1_bypass_data_e3[31:0] : i1_rs1_e3[31:0];\n   assign i1_rs2_e3_final[31:0] = (dec_i1_rs2_bypass_en_e3) ? i1_rs2_bypass_data_e3[31:0] : i1_rs2_e3[31:0];\n\n\n\n   assign i0_taken_e1  = (i0_predict_p_e"}
{"text": "1.ataken & dec_i0_alu_decode_e1) | (i0_predict_p_e1.hist[1] & ~dec_i0_alu_decode_e1);\n   assign i1_taken_e1  = (i1_predict_p_e1.ataken & dec_i1_alu_decode_e1) | (i1_predict_p_e1.hist[1] & ~dec_i1_alu_decode_e1);\n\n\n\n\n\n   eh2_exu_alu_ctl #(.pt(pt)) i0_alu_e4 (.*,\n                          .b_enable      ( dec_i0_branch_e3                         ),   // I\n                          .c_enable      ( i0_e4_ctl_en                             ),   // I\n                          .d_enable      ( i0_e4_data_en                            ),   // I\n                          .predict_p     ( i0_pp_e4_in                              ),   // I\n                          .valid         ( dec_i0_sec_decode_e3                     ),   // I\n                          .flush         ( dec_tlu_flush_lower_wb                   ),   // I\n                          .a             ( i0_rs1_e3_final[31:0]                    ),   // I\n                          .b             ( i0_rs2_e3_final[31:0]                    ),   // I\n                          .pc            ( dec_i0_pc_e3[31:1]                       ),   // I\n                          .brimm         ( i0_br_immed_e3[pt.BTB_TOFFSET_SIZE:1]    ),   // I\n                          .ap_in_tid     ( i0_ap_e3.tid                             ),   // I\n                          .ap            ( i0_ap_e4                                 ),   // I\n                          .out           ( exu_i0_result_e4[31:0]                   ),   // O\n                          .flush_upper   ( exu_i0_flush_lower_e4                    ),   // O\n                          .flush_path    ( exu_i0_flush_path_e4[31:1]               ),   // O\n                          .predict_p_ff  ( i0_predict_p_e4                          ),   // O\n                          .pc_ff         ( i0_alu_pc_unused[31:1]                   ),   // O\n                          .pred_correct  ( i0_pred_correct_lower_e4                 ));  // O\n\n\n   eh2_exu_alu_ctl #(.pt(pt)) i1_alu_e4 (.*,\n                          .b_enable      ( dec_i1_branch_e3                         ),   // I\n                          .c_enable      ( i1_e4_ctl_en                             ),   // I\n                          .d_enable      ( i1_e4_data_en                            ),   // I\n                          .predict_p     ( i1_pp_e4_in                              ),   // I\n                          .valid         ( dec_i1_sec_decode_e3                     ),   // I\n                          .flush         ( dec_tlu_flush_lower_wb                   ),   // I\n                          .a             ( i1_rs1_e3_final[31:0]                    ),   // I\n                          .b             ( i1_rs2_e3_final[31:0]                    ),   // I\n                          .pc            ( dec_i1_pc_e3[31:1]                       ),   // I\n                          .brimm         ( i1_br_immed_e3[pt.BTB_TOFFSET_SIZE:1]    ),   // I\n                          .ap_in_tid     ( i1_ap_e3.tid                             ),   // I\n                          .ap            ( i1_ap_e4                                 ),   // I\n                          .out           ( exu_i1_result_e4[31:0]                   ),   // O\n                          .flush_upper   ( exu_i1_flush_lower_e4                    ),   // O\n                          .flush_path    ( exu_i1_flush_path_e4[31:1]               ),   // O\n                          .predict_p_ff  ( i1_predict_p_e4                          ),   // O\n                          .pc_ff         ( i1_alu_pc_unused[31:1]                   ),   // O\n                          .pred_correct  ( i1_pred_correct_lower_e4                 ));  // O\n\n\n   assign exu_i0_br_hist_e4[1:0]               =  i0_predict_p_e4.hist[1:0];\n   assign exu_i0_br_bank_e4                    =  i0_predict_p_e4.bank;\n   assign exu_i0_br_error_e4                   =  i0_predict_p_e4.br_error;\n   assign exu_i0_br_middle_e4                  =  i0_predict_p_e4.pc4 ^ i0_predict_p_e4.boffset;\n   assign exu_i0_br_start_error_e4             =  i0_predict_p_e4.br_start_error;\n\n   assign exu_i0_br_valid_e4                   =  i0_predict_p_e4.valid;\n   assign exu_i0_br_mp_e4                      =  i0_predict_p_e4.misp; // needed to squash i1 error\n   assign exu_i0_br_ret_e4                     =  i0_predict_p_e4.pret;\n   assign exu_i0_br_call_e4                    =  i0_predict_p_e4.pcall;\n   assign exu_i0_br_way_e4                     =  i0_predict_p_e4.way;\n\n   assign {exu_i0_br_fghr_e4[pt.BHT_GHR_SIZE-1:0],\n           exu_i0_br_index_e4[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]} =  i0_predpipe_e4[PREDPIPESIZE-1:pt.BTB_BTAG_SIZE+pt.BTB_TOFFSET_SIZE];\n\n   assign exu_i1_br_hist_e4[1:0]               =  i1_predict_p_e4.hist[1:0];\n   assign exu_i1_br_bank_e4                    =  i1_predict_p_e4.bank;\n   assign exu_i1_br_middle_e4                  =  i1_predict_p_e4.pc4 ^ i1_predict_p_e4.boffset;\n   assign exu_i1_br_error_e4                   =  i1_predict_p_e4.br_error;\n\n   assign exu_i1_br_start_error_e4             =  i1_predict_p_e4.br_start_error;\n   assign exu_i1_br_valid_e4                   =  i1_predict_p_e4.valid;\n   assign exu_i1_br_mp_e4                      =  i1_predict_p_e4.misp;\n   assign exu_i1_br_way_e4                     =  i1_predict_p_e4.way;\n   assign exu_i1_br_ret_e4                     =  i1_predict_p_e4.pret;\n   assign exu_i1_br_call_e4                    =  i1_predict_p_e4.pcall;\n\n   assign {exu_i1_br_fghr_e4[pt.BHT_GHR_SIZE-1:0],\n           exu_i1_br_index_e4[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]} =  i1_predpipe_e4[PREDPIPESIZE-1:pt.BTB_BTAG_SIZE+pt.BTB_TOFFSET_SIZE];\n\n\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n\n      assign fp_enable[i]                             = (exu_i0_flush_lower_e4[i]) | (exu_i1_flush_lower_e4[i]) |\n                                                        (i0_flush_upper_e1[i])     | (i1_flush_upper_e1[i]);\n\n      assign final_predict_mp[i]                      = (exu_i0_flush_lower_e4[i])  ?  i0_predict_p_e4 :\n                                                        (exu_i1_flush_lower_e4[i])  ?  i1_predict_p_e4 :\n                                                        (i0_flush_upper_e1[i])      ?  i0_predict_p_e1 :\n                                                        (i1_flush_upper_e1[i])      ?  i1_predict_p_e1 : '0;\n\n      assign final_predpipe_mp[i][PREDPIPESIZE-1:0]   = (exu_i0_flush_lower_e4[i])  ?  i0_predpipe_e4  :\n                                                        (exu_i1_flush_lower_e4[i])  ?  i1_predpipe_e4  :\n                                                        (i0_flush_upper_e1[i])      ?  i0_predpipe_e1  :\n                                                        (i1_flush_upper_e1[i])      ?  i1_predpipe_e1  : '0;\n\n\n      assign after_flush_eghr[i][pt.BHT_GHR_SIZE-1:0] = (i0_flush_upper_e2[i] | i1_flush_upper_e2[i] & ~dec_tlu_flush_lower_wb[i]) ? ghr_e1[i][pt.BHT_GHR_SIZE-1:0] : ghr_e4[i][pt.BHT_GHR_SIZE-1:0];\n\n      assign exu_mp_fghr[i][pt.BHT_GHR_SIZE-1:0]      =  after_flush_eghr[i][pt.BHT_GHR_SIZE-1:0];     // fghr repair value\n\n      assign {exu_mp_index[i][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],\n              exu_mp_btag[i][pt.BTB_BTAG_SIZE-1:0],\n              exu_mp_toffset[i][pt.BTB_TOFFSET_SIZE-1:0]}   =  final_predpipe_mp_ff[i][PREDPIPESIZE-pt.BHT_GHR_SIZE-1:0];\n      assign  exu_mp_eghr[i][pt.BHT_GHR_SIZE-1:0]     =  final_predpipe_mp_ff[i][PREDPIPESIZE-1:pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+pt.BTB_BTAG_SIZE+pt.BTB_TOFFSET_SIZE+1]; // mp ghr for bht write\n\n\n     // E1 GHR - fill in the ptaken for secondary branches.\n\n      assign i0_valid_e1[i]  = ~exu_flush_final[i] & (i0_ap_e1.tid==i) & ~flush_final_f[i] & (i0_predict_p_e1.valid | i0_predict_p_e1.misp);\n      assign i1_valid_e1[i]  = ~exu_flush_final[i] & (i1_ap_e1.tid==i) & ~flush_final_f[i] & (i1_predict_p_e1.valid | i1_predict_p_e1.misp) & ~(i0_flush_upper_e1[i]);\n\n      assign ghr_e1_ns[i][pt.BHT_GHR_SIZE-1:0]  = ({pt.BHT_GHR_SIZE{ dec_tlu_flush_lower_wb[i]}}                                                                  &  ghr_e4[i][pt.BHT_GHR_SIZE-1:0]) |\n                                                  ({pt.BHT_GHR_SIZE{~dec_tlu_flush_lower_wb[i] & ~i0_valid_e1[i] &  ~i1_valid_e1[i]}}                             &  ghr_e1[i][pt.BHT_GHR_SIZE-1:0]) |\n                                                  ({pt.BHT_GHR_SIZE{~dec_tlu_flush_lower_wb[i] & ~i0_valid_e1[i] &   i1_valid_e1[i] & ~i0_predict_p_e1.br_error}} & {ghr_e1[i][pt.BHT_GHR_SIZE-2:0], i1_taken_e1}) |\n                                                  ({pt.BHT_GHR_SIZE{~dec_tlu_flush_lower_wb[i] &  i0_valid_e1[i] & (~i1_valid_e1[i] |  i0_predict_p_e1.misp   )}} & {ghr_e1[i][pt.BHT_GHR_SIZE-2:0], i0_taken_e1}) |\n                                                  ({pt.BHT_GHR_SIZE{~dec_tlu_flush_lower_wb[i] &  i0_valid_e1[i] &   i1_valid_e1[i] & ~i0_predict_p_e1.misp    }} & {ghr_e1[i][pt.BHT_GHR_SIZE-3:0], i0_taken_e1, i1_taken_e1});\n\n\n      // E4 GHR - the ataken is filled in by e1 stage if e1 stage executes the branch, otherwise by e4 stage.\n      assign i0_valid_e4[i]                     =  dec_tlu_i0_valid_e4 & (i0_ap_e4.tid==i) & ((i0_predict_p_e4.valid) | i0_predict_p_e4.misp);\n      assign i1_pred_valid_e4[i]                =  dec_tlu_i1_valid_e4 & (i1_ap_e4.tid==i) & ((i1_predict_p_e4.valid) | i1_predict_p_e4.misp) & ~i0_flush_upper_e4[i];\n      assign ghr_e4_ns[i][pt.BHT_GHR_SIZE-1:0]  = ({pt.BHT_GHR_SIZE{ i0_valid_e4[i] & (i0_predict_p_e4.misp |     ~i1_pred_valid_e4[i])}} & {ghr_e4[i][pt.BHT_GHR_SIZE-2:0], i0_predict_p_e4.ataken}) |\n                                                  ({pt.BHT_GHR_SIZE{ i0_valid_e4[i] & ~i0_predict_p_e4.misp &      i1_pred_valid_e4[i]}}  & {ghr_e4[i][pt.BHT_GHR_SIZE-3:0], i0_predict_p_e4.ataken, i1_predict_p_e4.ataken}) |\n                                                  ({pt.BHT_GHR_SIZE{~i0_valid_e4[i] & ~i0_predict_p_e4.br_error &  i1_pred_valid_e4[i]}}  & {ghr_e4[i][pt.BHT_GHR_SIZE-2:0], i1_predict_p_e4.ataken}) |\n                                                  ({pt.BHT_GHR_SIZE{~i0_valid_e4[i] &                             ~i1_pred_valid_e4[i]}}  &  ghr_e4[i][pt.BHT_GHR_SIZE-1:0]);\n\n\n\n      rvdfflie #(.WIDTH($bits(eh2_predict_pkt_t)),.LEFT(24)) predict_mp_ff     (.*, .clk(active_thread_l2clk[i]), .en(fp_enable[i] | fp_enable_ff[i]), .din(final_predict_mp [i]),                .dout(exu_mp_pkt[i]));\n      rvdffe #(PREDPIPESIZE)                                  predictpipe_mp_ff (.*, .clk(active_thread_l2clk[i]), .en(fp_enable[i] | fp_enable_ff[i]), .din(final_predpipe_mp[i]),                .dout(final_predpipe_mp_ff[i]));\n\n\n\n      assign flush_path_e2[i][31:1]           = (i0_flush_upper_e2[i])       ?  i0_flush_path_upper_e2[31:1]    :  i1_flush_path_upper_e2[31:1];\n\n      // quiet this bus when there are no flushes\n      assign exu_flush_path_final[i][31:1]    = (dec_tlu_flush_lower_wb[i])                     ?  dec_tlu_flush_path_wb[i][31:1]  :\n                                                ((i0_flush_upper_e2[i] | i1_flush_upper_e2[i])  ?  flush_path_e2[i][31:1]          : '0);\n\n\n\n      assign exu_i0_flush_final[i]         =    dec_tlu_flush_lower_wb[i] | i0_flush_upper_e2[i];\n      assign exu_i1_flush_final[i]         =    dec_tlu_flush_lower_wb[i] | i1_flush_upper_e2[i];\n      assign exu_flush_final[i]            =    dec_tlu_flush_lower_wb[i] | i0_flush_upper_e2[i]  | i1_flush_upper_e2[i];\n\n      rvdffie #(6+pt.BHT_GHR_SIZE+pt.BHT_GHR_SIZE,1)  i_misc_thr_ff  (.*, .clk(clk),\n                                                                      .din ({exu_flush_final[i]  , fp_enable[i]        , ghr_e1_ns[i][pt.BHT_GHR_SIZE-1:0], ghr_e4_ns[i][pt.BHT_GHR_SIZE-1:0],\n                                                                             i0_flush_upper_e1[i], i1_flush_upper_e1[i], i0_flush_upper_e2[i]             , i0_flush_upper_e3[i]  }),\n                                                                      .dout({flush_final_f[i]    , fp_enable_ff[i]     , ghr_e1[i][pt.BHT_GHR_SIZE-1:0]   , ghr_e4[i][pt.BHT_GHR_SIZE-1:0]   ,\n                                                                             i0_flush_upper_e2[i], i1_flush_upper_e2[i], i0_flush_upper_e3[i]             , i0_flush_upper_e4[i] }));\n\n\n      logic [pt.NUM_THREADS-1:0] [31:1] flush_path_e1, flush_path_e4, flush_path_wb;\n      if(pt.BTB_USE_SRAM) begin\n         assign flush_path_e1[i][31:1]           = (i0_flush_upper_e1[i])       ?  i0_flush_path_e1[31:1]     :  i1_flush_path_e1[31:1];\n         assign flush_path_e4[i][31:1]           = (exu_i0_flush_lower_e4[i])         ?  exu_i0_flush_path_e4[31:1] :  exu_i1_flush_path_e4[31:1];\n\n         // SRAM BTB arch moves flushes to BF stage, but only mispredicts. TLU flushes are still a cycle later\n         assign exu_flush_path_final_early[i][31:1]    =  (exu_i0_flush_lower_e4[i] | exu_i1_flush_lower_e4[i])     ?  flush_path_e4[i][31:1]  :\n                                                         ((i0_flush_upper_e1[i] | i1_flush_upper_e1[i]) ?  flush_path_e1[i][31:1]   : '0);\n         assign exu_flush_final_early[i]            =    exu_i0_flush_lower_e4[i] | exu_i1_flush_lower_e4[i] | i0_flush_upper_e1[i]  | i1_flush_upper_e1[i];\n      end\n      else begin\n         assign exu_flush_path_final_early[i][31:1] =    '0;\n         assign exu_flush_final_early[i]            =    '0;\n      end\n\n\n   rvdffpcie #(31) i_pred_correct_npc_e3 (.*, .clk(clk),\n                                    .en  ( i0_e3_data_en | i1_e3_data_en),\n                                    .din ( pred_correct_npc_e2[i]       ),\n                                    .dout( pred_correct_npc_e3[i]       ));\n\n   rvdffpcie #(31) i_pred_correct_npc_e4 (.*, .clk(clk),\n                                    .en  ( i0_e4_data_en | i1_e4_data_en),\n                                    .din ( pred_correct_npc_e3[i]       ),\n                                    .dout( pred_correct_npc_e4[i]       ));\n\n   end\n\n\n\n\n\n\n   rvdffpcie #(31) i0_upper_flush_e2_ff  (.*, .clk(clk),\n                                    .en  ( i0_e2_data_en                ),\n                                    .din ( i0_flush_path_e1[31:1]       ),\n                                    .dout( i0_flush_path_upper_e2[31:1] ));\n\n   rvdffpcie #(31) i0_upper_flush_e3_ff  (.*, .clk(clk),\n                                    .en  ( i0_e3_data_en                ),\n                                    .din ( i0_flush_path_upper_e2[31:1] ),\n                                    .dout( i0_flush_path_upper_e3[31:1] ));\n\n   rvdffpcie #(31) i0_upper_flush_e4_ff  (.*, .clk(clk),\n                                    .en  ( i0_e4_data_en                ),\n                                    .din ( i0_flush_path_upper_e3[31:1] ),\n                                    .dout( i0_flush_path_upper_e4[31:1] ));\n\n\n   rvdffpcie #(31) i1_upper_flush_e2_ff  (.*, .clk(clk),\n                                    .en  ( i1_e2_data_en                ),\n                                    .din ( i1_flush_path_e1[31:1]       ),\n                                    .dout( i1_flush_path_upper_e2[31:1] ));\n\n   rvdffpcie #(31) i1_upper_flush_e3_ff  (.*, .clk(clk                  ),\n                                    .en  ( i1_e3_data_en                ),\n                                    .din ( i1_flush_path_upper_e2[31:1] ),\n                                    .dout( i1_flush_path_upper_e3[31:1] ));\n\n   rvdffpcie #(31) i1_upper_flush_e4_ff  (.*, .clk(clk),\n                                    .en  ( i1_e4_data_en                ),\n                                    .din ( i1_flush_path_upper_e3[31:1] ),\n                                    .dout( i1_flush_path_upper_e4[31:1] ));\n\n\n   // npc for commit\n   rvdffie #(13) i_misc_ff              (.*, .clk (clk),\n                                         .din ({i1_pred_correct_upper_e1,i0_pred_correct_upper_e1,\n                                                i1_pred_correct_upper_e2,i0_pred_correct_upper_e2,\n                                                i1_pred_correct_upper_e3,i0_pred_correct_upper_e3,\n                                                dec_i0_alu_decode_d     , dec_i1_alu_decode_d,\n                                                dec_i1_valid_e1,          i1_valid_e2             , i1_valid_e3,\n                                                dec_i0_sec_decode_e3    , dec_i1_sec_decode_e3    }),\n                                         .dout({i1_pred_correct_upper_e2,i0_pred_correct_upper_e2,\n                                                i1_pred_correct_upper_e3,i0_pred_correct_upper_e3,\n                                                i1_pred_correct_upper_e4,i0_pred_correct_upper_e4,\n                                                dec_i0_alu_decode_e1    , dec_i1_alu_decode_e1,\n                                                i1_valid_e2             , i1_valid_e3             , i1_valid_e4,\n                                                i0_sec_decode_e4        , i1_sec_decode_e4        }));\n\n\n   assign i1_pred_correct_e4_eff     = (i1_sec_decode_e4) ? i1_pred_correct_lower_e4 : i1_pred_correct_upper_e4;\n   assign i0_pred_correct_e4_eff     = (i0_sec_decode_e4) ? i0_pred_correct_lower_e4 : i0_pred_correct_upper_e4;\n\n   assign i1_flush_path_e4_eff[31:1] = (i1_sec_decode_e4) ? exu_i1_flush_path_e4[31:1] : i1_flush_path_upper_e4[31:1];\n   assign i0_flush_path_e4_eff[31:1] = (i0_sec_decode_e4) ? exu_i0_flush_path_e4[31:1] : i0_flush_path_upper_e4[31:1];\n\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n     assign i1_valid_e4_eff[i]  =  i1_valid_e4 & (i1_ap_e4.tid==i) & ~((i0_sec_decode_e4 & (i0_ap_e4.tid==i)) ?  exu_i0_flush_lower_e4[i]  :  i0_flush_upper_e4[i]);\n\n     assign exu_npc_e4[i][31:1] = (i1_valid_e4_eff[i]) ? ((i1_pred_correct_e4_eff & (i1_ap_e4.tid==i)) ? pred_correct_npc_e4[i][31:1] : i1_flush_path_e4_eff[31:1]) :\n                                                         ((i0_pred_correct_e4_eff & (i0_ap_e4.tid==i)) ? pred_correct_npc_e4[i][31:1] : i0_flush_path_e4_eff[31:1]);\n   end\n\n\nendmodule // exu\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nmodule eh2_exu_alu_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n   input  logic                          clk,               // Top level clock\n   input  logic                          rst_l,             // Reset\n   input  logic                          scan_mode,         // Scan control\n\n   input  logic [pt.NUM_THREADS-1:0]     flush,             // Flush pipeline\n   input  logic                          b_enable,          // Clock enable - branch\n   input  logic                          c_enable,          // Clock enable - control\n   input  logic                          d_enable,          // Clock enable - data\n   input  logic                          valid,             // Valid\n   input  logic                          ap_in_tid,         // predecodes\n   input  eh2_alu_pkt_t                 ap,                // predecodes\n   input  logic [31:0]                   a,                 // A operand\n   input  logic [31:0]                   b,                 // B operand\n   input  logic [31:1]                   pc,                // for pc=pc+2,4 calculations\n   input  eh2_predict_pkt_t             predict_p,         // Predicted branch structure\n   input  logic [pt.BTB_TOFFSET_SIZE:1]  brimm,             // Branch offset\n\n\n   output logic [31:0]                   out,               // final result\n   output logic [pt.NUM_THREADS-1:0]     flush_upper,       // Branch flush\n   output logic [31:1]                   flush_path,        // Branch flush PC\n   output logic [31:1]                   pc_ff,             // flopped PC\n   output logic                          pred_correct,      // NPC control\n   output eh2_predict_pkt_t             predict_p_ff       // Predicted branch structure\n  );\n\n\n   logic        [31:0]                   zba_a_ff;\n   logic        [31:0]                   aout;\n   logic                                 cout,ov,neg;\n   logic        [31:0]                   lout;\n   logic        [31:0]                   sout;\n   logic                                 sel_shift,sel_adder;\n   logic                                 slt_one;\n   logic                                 actual_taken;\n   logic signed [31:0]                   a_ff;\n   logic        [31:0]                   b_ff;\n   logic        [pt.BTB_TOFFSET_SIZE:1]  brimm_ff;\n   logic        [31:1]                   pcout;\n   logic                                 valid_ff;\n   logic                                 cond_mispredict;\n   logic                                 target_mispredict;\n   logic                                 eq, ne, lt, ge;\n   eh2_predict_pkt_t                    pp_ff;\n   logic                                 any_jal;\n   logic        [1:0]                    newhist;\n   logic                                 sel_pc;\n   logic        [31:0]                   csr_write_data;\n\n\n\n\n   // *** Start - BitManip ***\n\n   // Zbb\n   logic                  ap_clz;\n   logic                  ap_ctz;\n   logic                  ap_cpop;\n   logic                  ap_sext_b;\n   logic                  ap_sext_h;\n   logic                  ap_min;\n   logic                  ap_max;\n   logic                  ap_rol;\n   logic                  ap_ror;\n   logic                  ap_rev8;\n   logic                  ap_orc_b;\n   logic                  ap_zbb;\n\n   // Zbs\n   logic                  ap_bset;\n   logic                  ap_bclr;\n   logic                  ap_binv;\n   logic                  ap_bext;\n\n   // Zbp\n   logic                  ap_pack;\n   logic                  ap_packu;\n   logic                  ap_packh;\n\n   // Zba\n   logic                  ap_sh1add;\n   logic                  ap_sh2add;\n   logic                  ap_sh3add;\n   logic                  ap_zba;\n\n\n\n   if (pt.BITMANIP_ZBB == 1)\n     begin\n       assign ap_clz          =  ap.clz;\n       assign ap_ctz          =  ap.ctz;\n       assign ap_cpop         =  ap.cpop;\n       assign ap_sext_b       =  ap.sext_b;\n       assign ap_sext_h       =  ap.sext_h;\n       assign ap_min          =  ap.min;\n       assign ap_max          =  ap.max;\n     end\n   else\n     begin\n       assign ap_clz          =  1'b0;\n       assign ap_ctz          =  1'b0;\n       assign ap_cpop         =  1'b0;\n       assign ap_sext_b       =  1'b0;\n       assign ap_sext_h       =  1'b0;\n       assign ap_min          =  1'b0;\n       assign ap_max          =  1'b0;\n     end\n\n\n   if ( (pt.BITMANIP_ZBB == 1) | (pt.BITMANIP_ZBP == 1) )\n     begin\n       assign ap_rol          =  ap.rol;\n       assign ap_ror          =  ap.ror;\n       assign ap_rev8         =  ap.grev & (b_ff[4:0] == 5'b11000);\n       assign ap_orc_b        =  ap.gorc & (b_ff[4:0] == 5'b00111);\n       assign ap_zbb          =  ap.zbb;\n     end\n   else\n     begin\n       assign ap_rol          =  1'b0;\n       assign ap_ror          =  1'b0;\n       assign ap_rev8         =  1'b0;\n       assign ap_orc_b        =  1'b0;\n       assign ap_zbb          =  1'b0;\n     end\n\n\n   if (pt.BITMANIP_ZBS == 1)\n     begin\n       assign ap_bset         =  ap.bset;\n       assign ap_bclr         =  ap.bclr;\n       assign ap_binv         =  ap.binv;\n       assign ap_bext         =  ap.bext;\n     end\n   else\n     begin\n       assign ap_bset         =  1'b0;\n       assign ap_bclr         =  1'b0;\n       assign ap_binv         =  1'b0;\n       assign ap_bext         =  1'b0;\n     end\n\n\n   if (pt.BITMANIP_ZBP == 1)\n     begin\n       assign ap_packu        =  ap.packu;\n     end\n   else\n     begin\n       assign ap_packu        =  1'b0;\n     end\n\n\n   if ( (pt.BITMANIP_ZBB == 1) | (pt.BITMANIP_ZBP == 1) | (pt.BITMANIP_ZBE == 1) | (pt.BITMANIP_ZBF == 1) )\n     begin\n       assign ap_pack         =  ap.pack;\n       assign ap_packh        =  ap.packh;\n     end\n   else\n     begin\n       assign ap_pack         =  1'b0;\n       assign ap_packh        =  1'b0;\n     end\n\n\n   if (pt.BITMANIP_ZBA == 1)\n     begin\n       assign ap_sh1add       =  ap.sh1add;\n       assign ap_sh2add       =  ap.sh2add;\n       assign ap_sh3add       =  ap.sh3add;\n       assign ap_zba          =  ap.zba;\n     end\n   else\n     begin\n       assign ap_sh1add       =  1'b0;\n       assign ap_sh2add       =  1'b0;\n       assign ap_sh3add       =  1'b0;\n       assign ap_zba          =  1'b0;\n     end\n\n\n\n\n   // *** End   - BitManip ***\n\n\n\n   rvdffie  #(1,1)                     validff         (.*, .clk(clk),                               .din(valid & ~flush[ap_in_tid]),    .dout(valid_ff));\n   rvdffe #(32)                        aff             (.*, .clk(clk),        .en(d_enable & valid), .din(a[31:0]),                      .dout(a_ff[31:0]));\n   rvdffe #(32)                        bff             (.*, .clk(clk),        .en(d_enable & valid), .din(b[31:0]),                      .dout(b_ff[31:0]));\n   rvdffpcie #(31)                     pcff            (.*, .clk(clk),        .en(d_enable),         .din(pc[31:1]),                     .dout(pc_ff[31:1]));   // all PCs run through here\n   rvdffe #(pt.BTB_TOFFSET_SIZE)       brimmff         (.*, .clk(clk),        .en(d_enable),         .din(brimm[pt.BTB_TOFFSET_SIZE:1]), .dout(brimm_ff[pt.BTB_TOFFSET_SIZE:1]));\n   rvdffppie #(.WIDTH($bits(eh2_predict_pkt_t)),.LEFT(19),.RIGHT(9)) predictpacketff (.*, .clk(clk), .en(c_enable), .den(b_enable & d_enable),  .din(predict_p),  .dout(pp_ff));\n\n\n   // immediates are just muxed into rs2\n\n   // add    =>  add=1;\n   // sub    =>  add=1; sub=1;\n\n   // slt    =>  slt\n\n   // lui    =>  lctl=2; or x0, imm20 previously << 12\n   // auipc  =>  add;   add pc, imm20 previously << 12\n\n   // beq    =>  bctl=4; add; add x0, pc, sext(offset[12:1])\n   // bne    =>  bctl=3; add; add x0, pc, sext(offset[12:1])\n   // blt    =>  bctl=2; add; add x0, pc, sext(offset[12:1])\n   // bge    =>  bctl=1; add; add x0, pc, sext(offset[12:1])\n\n   // jal    =>  rs1=pc {pc[31:1],1'b0},  rs2=sext(offset20:1]);   rd=pc+[2,4]\n   // jalr   =>  rs1=rs1,                 rs2=sext(offset20:1]);   rd=pc+[2,4]\n\n\n\n   assign zba_a_ff[31:0]      = ( {32{ ap_sh1add}} & {a_ff[30:0],1'b0} ) |\n                                ( {32{ ap_sh2add}} & {a_ff[29:0],2'b0} ) |\n                                ( {32{ ap_sh3add}} & {a_ff[28:0],3'b0} ) |\n                                ( {32{~ap_zba   }} &  a_ff[31:0]       );\n\n\n   logic        [31:0]    bm;\n\n   assign bm[31:0]            = ( ap.sub )  ?  ~b_ff[31:0]  :  b_ff[31:0];\n\n   assign {cout, aout[31:0]}  = {1'b0, zba_a_ff[31:0]} + {1'b0, bm[31:0]} + {32'b0, ap.sub};\n\n   assign ov                  = (~a_ff[31] & ~bm[31] &  aout[31]) |\n                                ( a_ff[31] &  bm[31] & ~aout[31] );\n\n   assign lt                  = (~ap.unsign & (neg ^ ov)) |\n                                ( ap.unsign & ~cout);\n\n   assign eq                  = (a_ff[31:0] == b_ff[31:0]);\n   assign ne                  = ~eq;\n   assign neg                 =  aout[31];\n   assign ge                  = ~lt;\n\n   assign lout[31:0]          =  ( {32{ap.land & ~ap_zbb}} &  a_ff[31:0] &  b_ff[31:0]  ) |\n                                 ( {32{ap.lor  & ~ap_zbb}} & (a_ff[31:0] |  b_ff[31:0]) ) |\n                                 ( {32{ap.lxor & ~ap_zbb}} & (a_ff[31:0] ^  b_ff[31:0]) ) |\n                                 ( {32{ap.land &  ap_zbb}} &  a_ff[31:0] & ~b_ff[31:0]  ) |\n                                 ( {32{ap.lor  &  ap_zbb}} & (a_ff[31:0] | ~b_ff[31:0]) ) |\n                                 ( {32{ap.lxor &  ap_zbb}} & (a_ff[31:0] ^ ~b_ff[31:0]) );\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  ROL,ROR      * * * * * * * * * * * * * * * * * *\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  ZBEXT        * * * * * * * * * * * * * * * * * *\n\n   logic        [5:0]     shift_amount;\n   logic        [31:0]    shift_mask;\n   logic        [62:0]    shift_extend;\n   logic        [62:0]    shift_long;\n\n\n   assign shift_amount[5:0]            = ( { 6{ap.sll}}   & (6'd32 - {1'b0,b_ff[4:0]}) ) |   // [5] unused\n                                         ( { 6{ap.srl}}   &          {1'b0,b_ff[4:0]}  ) |\n                                         ( { 6{ap.sra}}   &          {1'b0,b_ff[4:0]}  ) |\n                                         ( { 6{ap_rol}}   & (6'd32 - {1'b0,b_ff[4:0]}) ) |\n                                         ( { 6{ap_ror}}   &          {1'b0,b_ff[4:0]}  ) |\n                                         ( { 6{ap_bext}}  &          {1'b0,b_ff[4:0]}  );\n\n\n   assign shift_mask[31:0]             = ( 32'hffffffff << ({5{ap.sll}} & b_ff[4:0]) );\n\n\n   assign shift_extend[31:0]           =  a_ff[31:0];\n\n   assign shift_extend[62:32]          = ( {31{ap.sra}} & {31{a_ff[31]}} ) |\n                                         ( {31{ap.sll}} &     a_ff[30:0] ) |\n                                         ( {31{ap_rol}} &     a_ff[30:0] ) |\n                                         ( {31{ap_ror}} &     a_ff[30:0] );\n\n\n   assign shift_long[62:0]    = ( shift_extend[62:0] >> shift_amount[4:0] );   // 62-32 unused\n\n   assign sout[31:0]          =   shift_long[31:0] & shift_mask[31:0];\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  CLZ,CTZ      * * * * * * * * * * * * * * * * * *\n\n   logic                  bitmanip_clz_ctz_sel;\n   logic        [31:0]    bitmanip_a_reverse_ff;\n   logic        [31:0]    bitmanip_lzd_ff;\n   logic        [5:0]     bitmanip_dw_lzd_enc;\n   logic        [5:0]     bitmanip_clz_ctz_result;\n\n   assign bitmanip_clz_ctz_sel         =  ap_clz | ap_ctz;\n\n   assign bitmanip_a_reverse_ff[31:0]  = {a_ff[0],  a_ff[1],  a_ff[2],  a_ff[3],  a_ff[4],  a_ff[5],  a_ff[6],  a_ff[7],\n                                          a_ff[8],  a_ff[9],  a_ff[10], a_ff[11], a_ff[12], a_ff[13], a_ff[14], a_ff[15],\n                                          a_ff[16], a_ff[17], a_ff[18], a_ff[19], a_ff[20], a_ff[21], a_ff[22], a_ff[23],\n                                          a_ff[24], a_ff[25], a_ff[26], a_ff[27], a_ff[28], a_ff[29], a_ff[30], a_ff[31]};\n\n   assign bitmanip_lzd_ff[31:0]        = ( {32{ap_clz}} & a_ff[31:0]                 ) |\n                                         ( {32{ap_ctz}} & bitmanip_a_reverse_ff[31:0]);\n\n   logic        [31:0]    bitmanip_lzd_os;\n   integer                bitmanip_clzctz_i;\n   logic                  found;\n\n   always_comb\n     begin\n        bitmanip_lzd_os[31:0]   =  bitmanip_lzd_ff[31:0];\n        bitmanip_dw_lzd_enc[5:0]=  6'b0;\n        found = 1'b0;\n\n        for (int bitmanip_clzctz_i=0; bitmanip_clzctz_i<32 && found==0; bitmanip_clzctz_i++) begin\n           if (bitmanip_lzd_os[31] == 1'b0) begin\n              bitmanip_dw_lzd_enc[5:0]=  bitmanip_dw_lzd_enc[5:0] + 6'b00_0001;\n              bitmanip_lzd_os[31:0]   =  bitmanip_lzd_os[31:0] << 1;\n           end\n           else\n              found=1'b1;\n        end\n     end\n\n\n   assign bitmanip_clz_ctz_result[5:0] = {6{bitmanip_clz_ctz_sel}} & {bitmanip_dw_lzd_enc[5],( {5{~bitmanip_dw_lzd_enc[5]}} & bitmanip_dw_lzd_enc[4:0] )};\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  CPOP         * * * * * * * * * * * * * * * * * *\n\n   logic        [5:0]     bitmanip_cpop;\n   logic        [5:0]     bitmanip_cpop_result;\n\n\n   integer                bitmanip_cpop_i;\n\n   always_comb\n     begin\n       bitmanip_cpop[5:0]               =  6'b0;\n\n       for (bitmanip_cpop_i=0; bitmanip_cpop_i<32; bitmanip_cpop_i++)\n         begin\n            bitmanip_cpop[5:0]          =  bitmanip_cpop[5:0] + {5'b0,a_ff[bitmanip_cpop_i]};\n         end      // FOR    bitmanip_cpop_i\n     end          // ALWAYS_COMB\n\n\n   assign bitmanip_cpop_result[5:0]    =  {6{ap_cpop}} & bitmanip_cpop[5:0];\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  SEXT_B,SEXT_H  * * * * * * * * * * * * * * * * *\n\n   logic       [31:0]     bitmanip_sext_result;\n\n   assign bitmanip_sext_result[31:0]   = ( {32{ap_sext_b}} & { {24{a_ff[7]}} ,a_ff[7:0]  } ) |\n                                         ( {32{ap_sext_h}} & { {16{a_ff[15]}},a_ff[15:0] } );\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  MIN,MAX,MINU,MAXU  * * * * * * * * * * * * * * *\n\n   logic                  bitmanip_minmax_sel;\n   logic        [31:0]    bitmanip_minmax_result;\n\n   assign bitmanip_minmax_sel          =  ap_min | ap_max;\n\n   logic                  bitmanip_minmax_sel_a;\n\n   assign bitmanip_minmax_sel_a        =  ge  ^ ap_min;\n\n   assign bitmanip_minmax_result[31:0] = ({32{bitmanip_minmax_sel &  bitmanip_minmax_sel_a}}  &  a_ff[31:0]) |\n                                         ({32{bitmanip_minmax_sel & ~bitmanip_minmax_sel_a}}  &  b_ff[31:0]);\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  PACK, PACKU, PACKH * * * * * * * * * * * * * * *\n\n   logic        [31:0]    bitmanip_pack_result;\n   logic        [31:0]    bitmanip_packu_result;\n   logic        [31:0]    bitmanip_packh_result;\n\n   assign bitmanip_pack_result[31:0]   = {32{ap_pack}}  & {b_ff[15:0], a_ff[15:0]};\n   assign bitmanip_packu_result[31:0]  = {32{ap_packu}} & {b_ff[31:16],a_ff[31:16]};\n   assign bitmanip_packh_result[31:0]  = {32{ap_packh}} & {16'b0,b_ff[7:0],a_ff[7:0]};\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  REV8   * * * * * * * * * * * * * * * * * * * * *\n\n   logic        [31:0]    bitmanip_rev8_result;\n   logic        [31:0]    bitmanip_orc_b_result;\n\n   assign bitmanip_rev8_result[31:0]   = {32{ap_rev8}}  & {a_ff[7:0],a_ff[15:8],a_ff[23:16],a_ff[31:24]};\n\n\n// uint32_t gorc32(uint32_t rs1, uint32_t rs2)\n// {\n//      uint32_t x = rs1;\n//      int shamt = rs2 & 31;                                                        ORC.B\n//      if (shamt &  1) x |= ((x & 0x55555555) <<  1) | ((x & 0xAAAAAAAA) >>  1);      1\n//      if (shamt &  2) x |= ((x & 0x33333333) <<  2) | ((x & 0xCCCCCCCC) >>  2);      1\n//      if (shamt &  4) x |= ((x & 0x0F0F0F0F) <<  4) | ((x & 0xF0F0F0F0) >>  4);      1\n//      if (shamt &  8) x |= ((x & 0x00FF00FF) <<  8) | ((x & 0xFF00FF00) >>  8);      0\n//      if (shamt & 16) x |= ((x & 0x0000FFFF) << 16) | ((x & 0xFFFF0000) >> 16);      0\n//      return x;\n// }\n\n\n// BEFORE              31  ,   30  ,   29  ,   28  ,    27  ,   26,     25,     24\n// shamt[0]  b =    a31|a30,a31|a30,a29|a28,a29|a28, a27|a26,a27|a26,a25|a24,a25|a24\n// shamt[1]  c =    b31|b29,b30|b28,b31|b29,b30|b28, b27|b25,b26|b24,b27|b25,b26|b24\n// shamt[2]  d =    c31|c27,c30|c26,c29|c25,c28|c24, c31|c27,c30|c26,c29|c25,c28|c24\n//\n// Expand d31 =        c31         |         c27;\n//            =   b31   |   b29    |    b27   |   b25;\n//            = a31|a30 | a29|a28  |  a27|a26 | a25|a24\n\n   assign bitmanip_orc_b_result[31:0]  = {32{ap_orc_b}} & { {8{| a_ff[31:24]}}, {8{| a_ff[23:16]}}, {8{| a_ff[15:8]}}, {8{| a_ff[7:0]}} };\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  ZBSET, ZBCLR, ZBINV  * * * * * * * * * * * * * *\n\n   logic        [31:0]    bitmanip_sb_1hot;\n   logic        [31:0]    bitmanip_sb_data;\n\n   assign bitmanip_sb_1hot[31:0]       = ( 32'h00000001 << b_ff[4:0] );\n\n   assign bitmanip_sb_data[31:0]       = ( {32{ap_bset}} & ( a_ff[31:0] |  bitmanip_sb_1hot[31:0]) ) |\n                                         ( {32{ap_bclr}} & ( a_ff[31:0] & ~bitmanip_sb_1hot[31:0]) ) |\n                                         ( {32{ap_binv}} & ( a_ff[31:0] ^  bitmanip_sb_1hot[31:0]) );\n\n\n\n\n\n\n\n\n\n   assign sel_shift           =  ap.sll  | ap.srl | ap.sra | ap_rol | ap_ror;\n   assign sel_adder           = (ap.add  | ap.sub | ap_zba) & ~ap.slt & ~ap_min & ~ap_max;\n   assign sel_pc              =  ap.jal  | pp_ff.pcall | pp_ff.pja | pp_ff.pret;\n   assign csr_write_data[31:0]= (ap.csr_imm)  ?  b_ff[31:0]  :  a_ff[31:0];\n\n   assign slt_one             =  ap.slt & lt;\n\n\n\n   assign out[31:0]           =                        lout[31:0]             |\n                                ({32{sel_shift}}    &  sout[31:0]           ) |\n                                ({32{sel_adder}}    &  aout[31:0]           ) |\n                                ({32{sel_pc}}       & {pcout[31:1],1'b0}    ) |\n                                ({32{ap.csr_write}} &  csr_write_data[31:0] ) |\n                                                      {31'b0, slt_one}        |\n                                ({32{ap_bext}}      & {31'b0, sout[0]}      ) |\n                                                      {26'b0, bitmanip_clz_ctz_result[5:0]} |\n                                                      {26'b0, bitmanip_cpop_result[5:0]}    |\n                                                       bitmanip_sext_result[31:0]    |\n                                                       bitmanip_minmax_result[31:0]  |\n                                                       bitmanip_pack_result[31:0]    |\n                                                       bitmanip_packu_result[31:0]   |\n                                                       bitmanip_packh_result[31:0]   |\n                                                       bitmanip_rev8_result[31:0]    |\n                                                       bitmanip_orc_b_result[31:0]   |\n                                                       bitmanip_sb_data[31:0];\n\n\n\n   // *** branch handling ***\n\n   assign any_jal             =  ap.jal      |\n                                 pp_ff.pcall |\n                                 pp_ff.pja   |\n                                 pp_ff.pret;\n\n   assign actual_taken        = (ap.beq & eq) |\n                                (ap.bne & ne) |\n                                (ap.blt & lt) |\n                                (ap.bge & ge) |\n     "}
{"text": "                            any_jal;\n\n   // for a conditional br pcout[] will be the opposite of the branch prediction\n   // for jal or pcall, it will be the link address pc+2 or pc+4\n\n   rvbradder ibradder (\n                     .pc     ( pc_ff[31:1]    ),\n                     .offset ( brimm_ff[pt.BTB_TOFFSET_SIZE:1] ),\n                     .dout   ( pcout[31:1]    ));\n\n\n   // pred_correct is for the npc logic\n   // pred_correct indicates not to use the flush_path\n   // for any_jal pred_correct==0\n\n   assign pred_correct        = (ap.predict_nt & ~actual_taken & ~any_jal) |\n                                (ap.predict_t  &  actual_taken & ~any_jal);\n\n\n   // for any_jal adder output is the flush path\n   assign flush_path[31:1]    = (any_jal) ? aout[31:1] : pcout[31:1];\n\n\n   // pcall and pret are included here\n   assign cond_mispredict     = (ap.predict_t  & ~actual_taken) |\n                                (ap.predict_nt &  actual_taken);\n\n\n   // target mispredicts on ret's\n\n   assign target_mispredict   =  pp_ff.pret & (pp_ff.prett[31:1] != aout[31:1]);\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n     assign flush_upper[i]    = ( ap.jal | cond_mispredict | target_mispredict) & valid_ff & (i == ap.tid) & ~flush[i];\n   end\n\n\n   // .i 3\n   // .o 2\n   // .ilb hist[1] hist[0] taken\n   // .ob newhist[1] newhist[0]\n   // .type fd\n   //\n   // 00 0 01\n   // 01 0 01\n   // 10 0 00\n   // 11 0 10\n   // 00 1 10\n   // 01 1 00\n   // 10 1 11\n   // 11 1 11\n\n   assign newhist[1]          = ( pp_ff.hist[1] &  pp_ff.hist[0]) | (~pp_ff.hist[0] & actual_taken);\n   assign newhist[0]          = (~pp_ff.hist[1] & ~actual_taken)  | ( pp_ff.hist[1] & actual_taken);\n\n   always_comb begin\n      predict_p_ff            =  pp_ff;\n\n      predict_p_ff.misp       = ( valid_ff )  ? ( (cond_mispredict | target_mispredict) & ~flush[ap.tid] )  :  pp_ff.misp;\n      predict_p_ff.ataken     = ( valid_ff )  ?  actual_taken  :  pp_ff.ataken;\n      predict_p_ff.hist[1]    = ( valid_ff )  ?  newhist[1]    :  pp_ff.hist[1];\n      predict_p_ff.hist[0]    = ( valid_ff )  ?  newhist[0]    :  pp_ff.hist[0];\n\n   end\n\n\n\nendmodule // eh2_exu_alu_ctl\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nmodule eh2_exu_div_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n   input logic           clk,                       // Top level clock\n   input logic           rst_l,                     // Reset\n   input logic           scan_mode,                 // Scan mode\n\n   input eh2_div_pkt_t  dp,                        // valid, sign, rem\n   input logic  [31:0]   dividend,                  // Numerator\n   input logic  [31:0]   divisor,                   // Denominator\n\n   input logic           cancel,                    // Cancel divide\n\n\n   output logic          finish_dly,                // Finish to match data\n   output logic [31:0]   out                        // Result\n  );\n\n   logic [31:0]          out_raw;\n\n\n\n   assign out[31:0] = {32{finish_dly}} & out_raw[31:0];     // Qualification added to quiet result bus while divide is iterating\n\n\n\n   if (pt.DIV_NEW == 0)\n      begin\n        eh2_exu_div_existing_1bit_cheapshortq   i_existing_1bit_div_cheapshortq (\n            .clk              ( clk                      ),   // I\n            .rst_l            ( rst_l                    ),   // I\n            .scan_mode        ( scan_mode                ),   // I\n            .cancel           ( cancel                   ),   // I\n            .valid_in         ( dp.valid                 ),   // I\n            .signed_in        (~dp.unsign                ),   // I\n            .rem_in           ( dp.rem                   ),   // I\n            .dividend_in      ( dividend[31:0]           ),   // I\n            .divisor_in       ( divisor[31:0]            ),   // I\n            .valid_out        ( finish_dly               ),   // O\n            .data_out         ( out_raw[31:0]            ));  // O\n      end\n\n\n   if ( (pt.DIV_NEW == 1) & (pt.DIV_BIT == 1) )\n      begin\n        eh2_exu_div_new_1bit_fullshortq         i_new_1bit_div_fullshortq  (\n            .clk              ( clk                      ),   // I\n            .rst_l            ( rst_l                    ),   // I\n            .scan_mode        ( scan_mode                ),   // I\n            .cancel           ( cancel                   ),   // I\n            .valid_in         ( dp.valid                 ),   // I\n            .signed_in        (~dp.unsign                ),   // I\n            .rem_in           ( dp.rem                   ),   // I\n            .dividend_in      ( dividend[31:0]           ),   // I\n            .divisor_in       ( divisor[31:0]            ),   // I\n            .valid_out        ( finish_dly               ),   // O\n            .data_out         ( out_raw[31:0]            ));  // O\n      end\n\n\n   if ( (pt.DIV_NEW == 1) & (pt.DIV_BIT == 2) )\n      begin\n        eh2_exu_div_new_2bit_fullshortq         i_new_2bit_div_fullshortq  (\n            .clk              ( clk                      ),   // I\n            .rst_l            ( rst_l                    ),   // I\n            .scan_mode        ( scan_mode                ),   // I\n            .cancel           ( cancel                   ),   // I\n            .valid_in         ( dp.valid                 ),   // I\n            .signed_in        (~dp.unsign                ),   // I\n            .rem_in           ( dp.rem                   ),   // I\n            .dividend_in      ( dividend[31:0]           ),   // I\n            .divisor_in       ( divisor[31:0]            ),   // I\n            .valid_out        ( finish_dly               ),   // O\n            .data_out         ( out_raw[31:0]            ));  // O\n      end\n\n\n   if ( (pt.DIV_NEW == 1) & (pt.DIV_BIT == 3) )\n      begin\n        eh2_exu_div_new_3bit_fullshortq         i_new_3bit_div_fullshortq  (\n            .clk              ( clk                      ),   // I\n            .rst_l            ( rst_l                    ),   // I\n            .scan_mode        ( scan_mode                ),   // I\n            .cancel           ( cancel                   ),   // I\n            .valid_in         ( dp.valid                 ),   // I\n            .signed_in        (~dp.unsign                ),   // I\n            .rem_in           ( dp.rem                   ),   // I\n            .dividend_in      ( dividend[31:0]           ),   // I\n            .divisor_in       ( divisor[31:0]            ),   // I\n            .valid_out        ( finish_dly               ),   // O\n            .data_out         ( out_raw[31:0]            ));  // O\n      end\n\n\n   if ( (pt.DIV_NEW == 1) & (pt.DIV_BIT == 4) )\n      begin\n        eh2_exu_div_new_4bit_fullshortq         i_new_4bit_div_fullshortq  (\n            .clk              ( clk                      ),   // I\n            .rst_l            ( rst_l                    ),   // I\n            .scan_mode        ( scan_mode                ),   // I\n            .cancel           ( cancel                   ),   // I\n            .valid_in         ( dp.valid                 ),   // I\n            .signed_in        (~dp.unsign                ),   // I\n            .rem_in           ( dp.rem                   ),   // I\n            .dividend_in      ( dividend[31:0]           ),   // I\n            .divisor_in       ( divisor[31:0]            ),   // I\n            .valid_out        ( finish_dly               ),   // O\n            .data_out         ( out_raw[31:0]            ));  // O\n      end\n\n\n\nendmodule // eh2_exu_div_ctl\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nmodule eh2_exu_div_existing_1bit_cheapshortq\n  (\n   input  logic            clk,                       // Top level clock\n   input  logic            rst_l,                     // Reset\n   input  logic            scan_mode,                 // Scan mode\n\n   input  logic            cancel,                    // Flush pipeline\n   input  logic            valid_in,\n   input  logic            signed_in,\n   input  logic            rem_in,\n   input  logic [31:0]     dividend_in,\n   input  logic [31:0]     divisor_in,\n\n   output logic            valid_out,\n   output logic [31:0]     data_out\n  );\n\n\n   logic         div_clken;\n   logic         run_in, run_state;\n   logic [5:0]   count_in, count;\n   logic [32:0]  m_ff;\n   logic         qff_enable;\n   logic         aff_enable;\n   logic [32:0]  q_in, q_ff;\n   logic [32:0]  a_in, a_ff;\n   logic [32:0]  m_eff;\n   logic [32:0]  a_shift;\n   logic         dividend_neg_ff, divisor_neg_ff;\n   logic [31:0]  dividend_comp;\n   logic [31:0]  dividend_eff;\n   logic [31:0]  q_ff_comp;\n   logic [31:0]  q_ff_eff;\n   logic [31:0]  a_ff_comp;\n   logic [31:0]  a_ff_eff;\n   logic         sign_ff, sign_eff;\n   logic         rem_ff;\n   logic         add;\n   logic [32:0]  a_eff;\n   logic [64:0]  a_eff_shift;\n   logic         rem_correct;\n   logic         valid_ff_x;\n   logic         valid_x;\n   logic         finish;\n   logic         finish_ff;\n\n   logic         smallnum_case_e1, smallnum_case_e2, smallnum_case_e3, smallnum_case_e4, smallnum_case_wb;\n   logic [3:0]   smallnum, smallnum_in, smallnum_ff;\n   logic         m_already_comp;\n\n   logic [4:0]   a_cls;\n   logic [4:0]   b_cls;\n   logic [5:0]   shortq_shift;\n   logic [5:0]   shortq_shift_ff;\n   logic [5:0]   shortq;\n   logic         shortq_enable;\n   logic         shortq_enable_ff;\n   logic [32:0]  short_dividend;\n   logic [3:0]   shortq_raw;\n   logic [3:0]   shortq_shift_xx;\n\n\n\n   rvdffe #(18) i_misc_ff         (.*, .clk(clk), .en(div_clken), .din ({valid_in & ~cancel,\n                                                                         finish   & ~cancel,\n                                                                         run_in,\n                                                                         count_in[5:0],\n                                                                         shortq_enable,\n                                                                         shortq_shift[3:0],\n                                                                         (valid_in & dividend_in[31]) | (~valid_in & dividend_neg_ff),\n                                                                         (valid_in & divisor_in[31] ) | (~valid_in & divisor_neg_ff ),\n                                                                         (valid_in & sign_eff       ) | (~valid_in & sign_ff        ),\n                                                                         (valid_in & rem_in         ) | (~valid_in & rem_ff         )} ),\n                                                                  .dout({valid_ff_x,\n                                                                         finish_ff,\n                                                                         run_state,\n                                                                         count[5:0],\n                                                                         shortq_enable_ff,\n                                                                         shortq_shift_xx[3:0],\n                                                                         dividend_neg_ff,\n                                                                         divisor_neg_ff,\n                                                                         sign_ff,\n                                                                         rem_ff}) );\n\n   rvdffe #(8)  smallnumff        (.*, .clk(clk), .en(div_clken), .din ({smallnum_case_e1 & ~cancel,\n                                                                         smallnum_case_e2 & ~cancel,\n                                                                         smallnum_case_e3 & ~cancel,\n                                                                         smallnum_case_e4 & ~cancel,\n                                                                         smallnum_in[3:0]}),\n                                                                  .dout({smallnum_case_e2,\n                                                                         smallnum_case_e3,\n                                                                         smallnum_case_e4,\n                                                                         smallnum_case_wb,\n                                                                         smallnum_ff[3:0]}));\n\n   rvdffe #(33) mff               (.*, .clk(clk), .en(valid_in),     .din({signed_in & divisor_in[31], divisor_in[31:0]}),   .dout(m_ff[32:0]));\n   rvdffe #(33) qff               (.*, .clk(clk), .en(qff_enable),   .din(q_in[32:0]),                                       .dout(q_ff[32:0]));\n   rvdffe #(33) aff               (.*, .clk(clk), .en(aff_enable),   .din(a_in[32:0]),                                       .dout(a_ff[32:0]));\n\n   rvtwoscomp #(32) i_dividend_comp (.din(q_ff[31:0]),    .dout(dividend_comp[31:0]));\n   rvtwoscomp #(32) i_q_ff_comp     (.din(q_ff[31:0]),    .dout(q_ff_comp[31:0]));\n   rvtwoscomp #(32) i_a_ff_comp     (.din(a_ff[31:0]),    .dout(a_ff_comp[31:0]));\n\n\n   assign valid_x                 = valid_ff_x & ~cancel;\n\n\n   // START - short circuit logic for small numbers {{\n\n   // small number divides - any 4b / 4b is done in 1 cycle (divisor != 0)\n   // to generate espresso equations:\n   // 1.  smalldiv > smalldiv.e\n   // 2.  espresso -Dso -oeqntott smalldiv.e | addassign > smalldiv\n\n   // smallnum case does not cover divide by 0\n   assign smallnum_case_e1        = ((q_ff[31:4] == 28'b0) & (m_ff[31:4] == 28'b0) & (m_ff[31:0] != 32'b0) & ~rem_ff & valid_x) |\n                                    ((q_ff[31:0] == 32'b0) &                         (m_ff[31:0] != 32'b0) & ~rem_ff & valid_x);\n\n\n   assign smallnum[3]             = ( q_ff[3] &                                  ~m_ff[3] & ~m_ff[2] & ~m_ff[1]           );\n\n\n   assign smallnum[2]             = ( q_ff[3] &                                  ~m_ff[3] & ~m_ff[2] &            ~m_ff[0]) |\n                                    ( q_ff[2] &                                  ~m_ff[3] & ~m_ff[2] & ~m_ff[1]           ) |\n                                    ( q_ff[3] &  q_ff[2] &                       ~m_ff[3] & ~m_ff[2]                      );\n\n\n   assign smallnum[1]             = ( q_ff[2] &                                  ~m_ff[3] & ~m_ff[2] &            ~m_ff[0]) |\n                                    (                       q_ff[1] &            ~m_ff[3] & ~m_ff[2] & ~m_ff[1]           ) |\n                                    ( q_ff[3] &                                  ~m_ff[3] &            ~m_ff[1] & ~m_ff[0]) |\n                                    ( q_ff[3] & ~q_ff[2] &                       ~m_ff[3] & ~m_ff[2] &  m_ff[1] &  m_ff[0]) |\n                                    (~q_ff[3] &  q_ff[2] &  q_ff[1] &            ~m_ff[3] & ~m_ff[2]                      ) |\n                                    ( q_ff[3] &  q_ff[2] &                       ~m_ff[3] &                       ~m_ff[0]) |\n                                    ( q_ff[3] &  q_ff[2] &                       ~m_ff[3] &  m_ff[2] & ~m_ff[1]           ) |\n                                    ( q_ff[3] &             q_ff[1] & ~m_ff[3] &                       ~m_ff[1]           ) |\n                                    ( q_ff[3] &  q_ff[2] &  q_ff[1] &            ~m_ff[3] &  m_ff[2]                      );\n\n\n   assign smallnum[0]             = (            q_ff[2] &  q_ff[1] &  q_ff[0] & ~m_ff[3] &            ~m_ff[1]           ) |\n                                    ( q_ff[3] & ~q_ff[2] &  q_ff[0] &            ~m_ff[3] &             m_ff[1] &  m_ff[0]) |\n                                    (            q_ff[2] &                       ~m_ff[3] &            ~m_ff[1] & ~m_ff[0]) |\n                                    (                       q_ff[1] &            ~m_ff[3] & ~m_ff[2] &            ~m_ff[0]) |\n                                    (                                  q_ff[0] & ~m_ff[3] & ~m_ff[2] & ~m_ff[1]           ) |\n                                    (~q_ff[3] &  q_ff[2] & ~q_ff[1] &            ~m_ff[3] & ~m_ff[2] &  m_ff[1] &  m_ff[0]) |\n                                    (~q_ff[3] &  q_ff[2] &  q_ff[1] &            ~m_ff[3] &                       ~m_ff[0]) |\n                                    ( q_ff[3] &                                             ~m_ff[2] & ~m_ff[1] & ~m_ff[0]) |\n                                    ( q_ff[3] & ~q_ff[2] &                       ~m_ff[3] &  m_ff[2] &  m_ff[1]           ) |\n                                    (~q_ff[3] &  q_ff[2] &  q_ff[1] &            ~m_ff[3] &  m_ff[2] & ~m_ff[1]           ) |\n                                    (~q_ff[3] &  q_ff[2] &             q_ff[0] & ~m_ff[3] &            ~m_ff[1]           ) |\n                                    ( q_ff[3] & ~q_ff[2] & ~q_ff[1] &            ~m_ff[3] &  m_ff[2] &             m_ff[0]) |\n                                    (           ~q_ff[2] &  q_ff[1] &  q_ff[0] & ~m_ff[3] & ~m_ff[2]                      ) |\n                                    ( q_ff[3] &  q_ff[2] &                                             ~m_ff[1] & ~m_ff[0]) |\n                                    ( q_ff[3] &             q_ff[1] &                       ~m_ff[2] &            ~m_ff[0]) |\n                                    (~q_ff[3] &  q_ff[2] &  q_ff[1] &  q_ff[0] & ~m_ff[3] &  m_ff[2]                      ) |\n                                    ( q_ff[3] &  q_ff[2] &                        m_ff[3] & ~m_ff[2]                      ) |\n                                    ( q_ff[3] &             q_ff[1] &             m_ff[3] & ~m_ff[2] & ~m_ff[1]           ) |\n                                    ( q_ff[3] &                        q_ff[0] &            ~m_ff[2] & ~m_ff[1]           ) |\n                                    ( q_ff[3] &            ~q_ff[1] &            ~m_ff[3] &  m_ff[2] &  m_ff[1] &  m_ff[0]) |\n                                    ( q_ff[3] &  q_ff[2] &  q_ff[1] &             m_ff[3] &                       ~m_ff[0]) |\n                                    ( q_ff[3] &  q_ff[2] &  q_ff[1] &             m_ff[3] &            ~m_ff[1]           ) |\n                                    ( q_ff[3] &  q_ff[2] &             q_ff[0] &  m_ff[3] &            ~m_ff[1]           ) |\n                                    ( q_ff[3] & ~q_ff[2] &  q_ff[1] &            ~m_ff[3] &             m_ff[1]           ) |\n                                    ( q_ff[3] &             q_ff[1] &  q_ff[0] &            ~m_ff[2]                      ) |\n                                    ( q_ff[3] &  q_ff[2] &  q_ff[1] &  q_ff[0] &  m_ff[3]                                 );\n\n   assign smallnum_in[3:0]        = ({4{ smallnum_case_e1}} & smallnum[3:0]   ) |\n                                    ({4{~smallnum_case_e1}} & smallnum_ff[3:0]);\n\n\n   // END   - short circuit logic for small numbers }}\n\n\n   // *** Start Short Q *** {{\n\n   assign short_dividend[31:0]    =  q_ff[31:0];\n   assign short_dividend[32]      =  sign_ff & q_ff[31];\n\n\n   //    A       B\n   //   210     210    SH\n   //   ---     ---    --\n   //   1xx     000     0\n   //   1xx     001     8\n   //   1xx     01x    16\n   //   1xx     1xx    24\n   //   01x     000     8\n   //   01x     001    16\n   //   01x     01x    24\n   //   01x     1xx    32\n   //   001     000    16\n   //   001     001    24\n   //   001     01x    32\n   //   001     1xx    32\n   //   000     000    24\n   //   000     001    32\n   //   000     01x    32\n   //   000     1xx    32\n\n   assign a_cls[4:3]              =  2'b0;\n   assign a_cls[2]                =  (~short_dividend[32] & (short_dividend[31:24] != {8{1'b0}})) | ( short_dividend[32] & (short_dividend[31:23] != {9{1'b1}}));\n   assign a_cls[1]                =  (~short_dividend[32] & (short_dividend[23:16] != {8{1'b0}})) | ( short_dividend[32] & (short_dividend[22:15] != {8{1'b1}}));\n   assign a_cls[0]                =  (~short_dividend[32] & (short_dividend[15:08] != {8{1'b0}})) | ( short_dividend[32] & (short_dividend[14:07] != {8{1'b1}}));\n\n   assign b_cls[4:3]              =  2'b0;\n   assign b_cls[2]                =  (~m_ff[32]           & (          m_ff[31:24] != {8{1'b0}})) | ( m_ff[32]           & (          m_ff[31:24] != {8{1'b1}}));\n   assign b_cls[1]                =  (~m_ff[32]           & (          m_ff[23:16] != {8{1'b0}})) | ( m_ff[32]           & (          m_ff[23:16] != {8{1'b1}}));\n   assign b_cls[0]                =  (~m_ff[32]           & (          m_ff[15:08] != {8{1'b0}})) | ( m_ff[32]           & (          m_ff[15:08] != {8{1'b1}}));\n\n   assign shortq_raw[3]           = ( (a_cls[2:1] == 2'b01 ) & (b_cls[2]   == 1'b1  ) ) |   // Shift by 32\n                                    ( (a_cls[2:0] == 3'b001) & (b_cls[2]   == 1'b1  ) ) |\n                                    ( (a_cls[2:0] == 3'b000) & (b_cls[2]   == 1'b1  ) ) |\n                                    ( (a_cls[2:0] == 3'b001) & (b_cls[2:1] == 2'b01 ) ) |\n                                    ( (a_cls[2:0] == 3'b000) & (b_cls[2:1] == 2'b01 ) ) |\n                                    ( (a_cls[2:0] == 3'b000) & (b_cls[2:0] == 3'b001) );\n\n   assign shortq_raw[2]           = ( (a_cls[2]   == 1'b1  ) & (b_cls[2]   == 1'b1  ) ) |   // Shift by 24\n                                    ( (a_cls[2:1] == 2'b01 ) & (b_cls[2:1] == 2'b01 ) ) |\n                                    ( (a_cls[2:0] == 3'b001) & (b_cls[2:0] == 3'b001) ) |\n                                    ( (a_cls[2:0] == 3'b000) & (b_cls[2:0] == 3'b000) );\n\n   assign shortq_raw[1]           = ( (a_cls[2]   == 1'b1  ) & (b_cls[2:1] == 2"}
{"text": "'b01 ) ) |   // Shift by 16\n                                    ( (a_cls[2:1] == 2'b01 ) & (b_cls[2:0] == 3'b001) ) |\n                                    ( (a_cls[2:0] == 3'b001) & (b_cls[2:0] == 3'b000) );\n\n   assign shortq_raw[0]           = ( (a_cls[2]   == 1'b1  ) & (b_cls[2:0] == 3'b001) ) |   // Shift by  8\n                                    ( (a_cls[2:1] == 2'b01 ) & (b_cls[2:0] == 3'b000) );\n\n\n   assign shortq_enable           =  valid_ff_x & (m_ff[31:0] != 32'b0) & (shortq_raw[3:0] != 4'b0) & ~smallnum_case_e1;\n\n   assign shortq_shift[3:0]       = ({4{shortq_enable}} & shortq_raw[3:0]);\n\n   assign shortq[5:0]             =  6'b0;\n   assign shortq_shift[5:4]       =  2'b0;\n   assign shortq_shift_ff[5]      =  1'b0;\n\n   assign shortq_shift_ff[4:0]    = ({5{shortq_shift_xx[3]}} & 5'b1_1110) |   // 31 -> 30 required for nonblocking div so finish is no faster than E4\n                                    ({5{shortq_shift_xx[2]}} & 5'b1_1000) |   // 24\n                                    ({5{shortq_shift_xx[1]}} & 5'b1_0000) |   // 16\n                                    ({5{shortq_shift_xx[0]}} & 5'b0_1000);    //  8\n\n   // *** End   Short Q *** }}\n\n\n\n\n   assign div_clken               =  valid_in | run_state | finish | finish_ff;\n\n   assign run_in                  = (valid_in | run_state) & ~finish & ~cancel;\n\n   assign count_in[5:0]           = {6{run_state & ~finish & ~cancel & ~shortq_enable}} & (count[5:0] + {1'b0,shortq_shift_ff[4:0]} + 6'd1);\n\n\n   assign finish                  = (smallnum_case_e4 | ((~rem_ff) ? (count[5:0] == 6'd32) : (count[5:0] == 6'd33)));\n\n   assign valid_out               =  finish_ff & ~cancel;\n\n   assign sign_eff                =  signed_in & (divisor_in[31:0] != 32'b0);\n\n\n   assign q_in[32:0]              = ({33{~run_state                                   }} &  {1'b0,dividend_in[31:0]}) |\n                                    ({33{ run_state &  (valid_ff_x | shortq_enable_ff)}} &  ({dividend_eff[31:0], ~a_in[32]} << shortq_shift_ff[4:0])) |\n                                    ({33{ run_state & ~(valid_ff_x | shortq_enable_ff)}} &  {q_ff[31:0], ~a_in[32]});\n\n   assign qff_enable              =  valid_in | (run_state & ~shortq_enable);\n\n\n\n\n   assign dividend_eff[31:0]      = (sign_ff & dividend_neg_ff) ? dividend_comp[31:0] : q_ff[31:0];\n\n\n   assign m_eff[32:0]             = ( add ) ? m_ff[32:0] : ~m_ff[32:0];\n\n   assign a_eff_shift[64:0]       = {33'b0, dividend_eff[31:0]} << shortq_shift_ff[4:0];\n\n   assign a_eff[32:0]             = ({33{ rem_correct                    }} &  a_ff[32:0]            ) |\n                                    ({33{~rem_correct & ~shortq_enable_ff}} & {a_ff[31:0], q_ff[32]} ) |\n                                    ({33{~rem_correct &  shortq_enable_ff}} &  a_eff_shift[64:32]    );\n\n   assign a_shift[32:0]           = {33{run_state}} & a_eff[32:0];\n\n   assign a_in[32:0]              = {33{run_state}} & (a_shift[32:0] + m_eff[32:0] + {32'b0,~add});\n\n   assign aff_enable              =  valid_in | (run_state & ~shortq_enable & (count[5:0]!=6'd33)) | rem_correct;\n\n\n   assign m_already_comp          = (divisor_neg_ff & sign_ff);\n\n   // if m already complemented, then invert operation add->sub, sub->add\n   assign add                     = (a_ff[32] | rem_correct) ^ m_already_comp;\n\n   assign rem_correct             = (count[5:0] == 6'd33) & rem_ff & a_ff[32];\n\n\n\n   assign q_ff_eff[31:0]          = (sign_ff & (dividend_neg_ff ^ divisor_neg_ff)) ? q_ff_comp[31:0] : q_ff[31:0];\n\n   assign a_ff_eff[31:0]          = (sign_ff &  dividend_neg_ff) ? a_ff_comp[31:0] : a_ff[31:0];\n\n   assign data_out[31:0]          = ({32{ smallnum_case_wb          }} & {28'b0, smallnum_ff[3:0]}) |\n                                    ({32{                     rem_ff}} &  a_ff_eff[31:0]          ) |\n                                    ({32{~smallnum_case_wb & ~rem_ff}} &  q_ff_eff[31:0]          );\n\n\n\n\nendmodule // eh2_exu_div_existing_1bit_cheapshortq\n\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nmodule eh2_exu_div_new_1bit_fullshortq\n  (\n   input  logic            clk,                       // Top level clock\n   input  logic            rst_l,                     // Reset\n   input  logic            scan_mode,                 // Scan mode\n\n   input  logic            cancel,                    // Flush pipeline\n   input  logic            valid_in,\n   input  logic            signed_in,\n   input  logic            rem_in,\n   input  logic [31:0]     dividend_in,\n   input  logic [31:0]     divisor_in,\n\n   output logic            valid_out,\n   output logic [31:0]     data_out\n  );\n\n\n   logic                   valid_ff_in, valid_ff;\n   logic                   finish_raw, finish, finish_ff;\n   logic                   running_state;\n   logic                   misc_enable;\n   logic        [2:0]      control_in, control_ff;\n   logic                   dividend_sign_ff, divisor_sign_ff, rem_ff;\n   logic                   count_enable;\n   logic        [6:0]      count_in, count_ff;\n\n   logic                   smallnum_case;\n   logic        [3:0]      smallnum;\n\n   logic                   a_enable, a_shift;\n   logic        [31:0]     a_in, a_ff;\n\n   logic                   b_enable, b_twos_comp;\n   logic        [32:0]     b_in, b_ff;\n\n   logic        [31:0]     q_in, q_ff;\n\n   logic                   rq_enable, r_sign_sel, r_restore_sel, r_adder_sel;\n   logic        [31:0]     r_in, r_ff;\n\n   logic                   twos_comp_q_sel, twos_comp_b_sel;\n   logic        [31:0]     twos_comp_in, twos_comp_out;\n\n   logic                   quotient_set;\n   logic        [32:0]     adder_out;\n\n   logic        [63:0]     ar_shifted;\n   logic        [5:0]      shortq;\n   logic        [4:0]      shortq_shift;\n   logic        [4:0]      shortq_shift_ff;\n   logic                   shortq_neg_or_zero;\n   logic                   shortq_enable;\n   logic                   shortq_enable_ff;\n   logic        [32:0]     shortq_dividend;\n\n   logic                   by_zero_case;\n\n   logic         [4:1]     special_in;\n   logic         [4:1]     special_ff;\n\n\n\n   rvdffe #(22) i_misc_ff        (.*, .clk(clk), .en(misc_enable),  .din ({valid_ff_in, control_in[2:0], count_in[6:0], special_in[4:1], shortq_enable,    shortq_shift[4:0],    finish   }),\n                                                                    .dout({valid_ff,    control_ff[2:0], count_ff[6:0], special_ff[4:1], shortq_enable_ff, shortq_shift_ff[4:0], finish_ff}) );\n\n   rvdffe #(32) i_a_ff           (.*, .clk(clk), .en(a_enable),     .din(a_in[31:0]),    .dout(a_ff[31:0]));\n   rvdffe #(33) i_b_ff           (.*, .clk(clk), .en(b_enable),     .din(b_in[32:0]),    .dout(b_ff[32:0]));\n   rvdffe #(32) i_r_ff           (.*, .clk(clk), .en(rq_enable),    .din(r_in[31:0]),    .dout(r_ff[31:0]));\n   rvdffe #(32) i_q_ff           (.*, .clk(clk), .en(rq_enable),    .din(q_in[31:0]),    .dout(q_ff[31:0]));\n\n\n\n   assign special_in[4:1]        = {special_ff[3] & ~cancel,\n                                    special_ff[2] & ~cancel,\n                                    special_ff[1] & ~cancel,\n                                    (smallnum_case | by_zero_case) & ~cancel};\n\n   assign valid_ff_in            =  valid_in  & ~cancel;\n\n   assign control_in[2]          = (~valid_in & control_ff[2]) | (valid_in & signed_in  & dividend_in[31]);\n   assign control_in[1]          = (~valid_in & control_ff[1]) | (valid_in & signed_in  &  divisor_in[31]);\n   assign control_in[0]          = (~valid_in & control_ff[0]) | (valid_in & rem_in);\n\n   assign dividend_sign_ff       =  control_ff[2];\n   assign divisor_sign_ff        =  control_ff[1];\n   assign rem_ff                 =  control_ff[0];\n\n\n   assign by_zero_case           =  valid_ff & (b_ff[31:0] == 32'b0);\n\n   assign misc_enable            =  valid_in | valid_ff | cancel | running_state | finish_ff;\n   assign running_state          = (| count_ff[6:0]) | shortq_enable_ff;\n   assign finish_raw             =   special_ff[3] |\n                                    (count_ff[6:0] == 7'd32);\n\n\n   assign finish                 =  finish_raw & ~cancel;\n   assign count_enable           = (valid_ff | running_state) & ~finish & ~finish_ff & ~cancel & ~shortq_enable;\n   assign count_in[6:0]          = {7{count_enable}} & (count_ff[6:0] + {6'b0,1'b1} + {2'b0,shortq_shift_ff[4:0]});\n\n\n   assign a_enable               =  valid_in | running_state;\n   assign a_shift                =  running_state & ~shortq_enable_ff;\n\n   assign ar_shifted[63:0]       = { {32{dividend_sign_ff}} , a_ff[31:0]} << shortq_shift_ff[4:0];\n\n   assign a_in[31:0]             = ( {32{~a_shift & ~shortq_enable_ff}} &  dividend_in[31:0] ) |\n                                   ( {32{ a_shift                    }} & {a_ff[30:0],1'b0}  ) |\n                                   ( {32{            shortq_enable_ff}} &  ar_shifted[31:0]  );\n\n\n\n   assign b_enable               =    valid_in | b_twos_comp;\n   assign b_twos_comp            =    valid_ff & ~(dividend_sign_ff ^ divisor_sign_ff);\n\n   assign b_in[32:0]             = ( {33{~b_twos_comp}} & { (signed_in & divisor_in[31]),divisor_in[31:0] } ) |\n                                   ( {33{ b_twos_comp}} & {~divisor_sign_ff,twos_comp_out[31:0] } );\n\n\n   assign rq_enable              = (valid_in | valid_ff | running_state) & ~(| special_ff[3:1]);\n   assign r_sign_sel             =  valid_ff      &  dividend_sign_ff & ~by_zero_case;\n   assign r_restore_sel          =  running_state & ~quotient_set & ~shortq_enable_ff;\n   assign r_adder_sel            =  running_state &  quotient_set & ~shortq_enable_ff;\n\n\n   assign r_in[31:0]             = ( {32{r_sign_sel      }} &  32'hffffffff          ) |\n                                   ( {32{r_restore_sel   }} & {r_ff[30:0] ,a_ff[31]} ) |\n                                   ( {32{r_adder_sel     }} &  adder_out[31:0]       ) |\n                                   ( {32{shortq_enable_ff}} &  ar_shifted[63:32]     ) |\n                                   ( {32{by_zero_case    }} &  a_ff[31:0]            );\n\n\n   assign q_in[31:0]             = ( {32{~valid_ff       }} & {q_ff[30:0], quotient_set}  ) |\n                                   ( {32{ smallnum_case  }} & {28'b0     , smallnum[3:0]} ) |\n                                   ( {32{ by_zero_case   }} & {32{1'b1}}                  );\n\n\n\n   assign adder_out[32:0]        = {r_ff[31:0],a_ff[31]} + {b_ff[32:0] };\n\n\n   assign quotient_set           = (~adder_out[32] ^ dividend_sign_ff) | ( (a_ff[30:0] == 31'b0) & (adder_out[32:0] == 33'b0) );\n\n\n\n   assign twos_comp_b_sel        =  valid_ff           & ~(dividend_sign_ff ^ divisor_sign_ff);\n   assign twos_comp_q_sel        = ~valid_ff & ~rem_ff &  (dividend_sign_ff ^ divisor_sign_ff) & ~special_ff[4];\n\n   assign twos_comp_in[31:0]     = ( {32{twos_comp_q_sel}} & q_ff[31:0] ) |\n                                   ( {32{twos_comp_b_sel}} & b_ff[31:0] );\n\n   rvtwoscomp #(32) i_twos_comp  (.din(twos_comp_in[31:0]), .dout(twos_comp_out[31:0]));\n\n\n\n   assign valid_out              =  finish_ff & ~cancel;\n\n   assign data_out[31:0]         = ( {32{~rem_ff & ~twos_comp_q_sel}} & q_ff[31:0]          ) |\n                                   ( {32{ rem_ff                   }} & r_ff[31:0]          ) |\n                                   ( {32{           twos_comp_q_sel}} & twos_comp_out[31:0] );\n\n\n\n\n   // *** *** *** START : SMALLNUM {{\n\n   assign smallnum_case          = ( (a_ff[31:4]  == 28'b0) & (b_ff[31:4] == 28'b0) & ~by_zero_case & ~rem_ff & valid_ff & ~cancel) |\n                                   ( (a_ff[31:0]  == 32'b0) &                         ~by_zero_case & ~rem_ff & valid_ff & ~cancel);\n\n   assign smallnum[3]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           );\n\n   assign smallnum[2]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] & ~b_ff[2]                      );\n\n   assign smallnum[1]            = (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                                  ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &            ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2]                      );\n\n   assign smallnum[0]            = (            a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &             a_ff[0] & ~b_ff[3] &             b_ff[1] &  b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                                  a_ff[0] & ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] & ~a_ff[1] &            ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &                                             ~b_ff[2] & ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] &  b_ff[2] &  b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &             a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] & ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &             b_ff[0]) |\n                                   (           ~a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                                             ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] &             a_ff[1] &                       ~b_ff[2] &            ~b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &  b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                        b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &             a_ff[1] &             b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                        a_ff[0] &            ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &            ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &             a_ff[0] &  b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &  a_ff[1] &            ~b_ff[3] &             b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &  a_ff[0] &            ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] &  b_ff[3]                                 );\n\n   // *** *** *** END   : SMALLNUM }}\n\n\n\n\n   // *** *** *** Start : Short Q {{\n\n   assign shortq_dividend[32:0]   = {dividend_sign_ff,a_ff[31:0]};\n\n\n   parameter shortq_a_width = 33;\n   parameter shortq_b_width = 33;\n\n   logic [5:0]  dw_a_enc;\n   logic [5:0]  dw_b_enc;\n   logic [6:0]  dw_shortq_raw;\n\n\n   eh2_exu_div_cls i_a_cls  (\n       .operand  ( shortq_dividend[32:0]  ),\n       .cls      ( dw_a_enc[4:0]          ));\n\n   eh2_exu_div_cls i_b_cls  (\n       .operand  ( b_ff[32:0]             ),\n       .cls      ( dw_b_enc[4:0]          ));\n\n   assign dw_a_enc[5]             =  1'b0;\n   assign dw_b_enc[5]             =  1'b0;\n\n\n   assign dw_shortq_raw[6:0]      =  {1'b0,dw_b_enc[5:0]} - {1'b0,dw_a_enc[5:0]} + 7'd1;\n   assign shortq_neg_or_zero      =  dw_shortq_raw[6] | (dw_shortq_raw[5:0] == 6'b0);\n   assign shortq[5:0]             =  shortq_neg_or_zero  ?  6'd1  :  dw_shortq_raw[5:0];   // 1 is minimum SHORTQ otherwise WB too early\n\n   assign shortq_enable           =  valid_ff & ~shortq[5] & ~(shortq[4:1] ==  4'b1111) & ~cancel;\n\n   assign shortq_shift[4:0]       = ~shortq_enable     ?  5'd0  :  (5'b11111 - shortq[4:0]);\n\n   // *** *** *** End   : Short Q }}\n\n\n\n\n\nendmodule // eh2_exu_div_new_1bit_fullshortq\n\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nmodule eh2_exu_div_new_2bit_fullshortq\n  (\n   input  logic            clk,                       // Top level clock\n   input  logic            rst_l,                     // Reset\n   input  logic            scan_mode,                 // Scan mode\n\n   input  logic            cancel,                    // Flush pipeline\n   input  logic            valid_in,\n   input  logic            signed_in,\n   input  logic            rem_in,\n   input  logic [31:0]     dividend_in,\n   input  logic [31:0]     divisor_in,\n\n   output logic            valid_out,\n   output logic [31:0]     data_out\n  );\n\n\n   logic                   valid_ff_in, valid_ff;\n   logic                   finish_raw, finish, finish_ff;\n   logic                   running_state;\n   logic                   misc_enable;\n   logic        [2:0]      control_in, control_ff;\n   logic                   dividend_sign_ff, divisor_sign_ff, rem_ff;\n   logic                   count_enable;\n   logic        [6:0]      count_in, count_ff;\n\n   logic                   smallnum_case;\n   logic        [3:0]      smallnum;\n\n   logic                   a_enable, a_shift;\n   logic        [31:0]     a_in, a_ff;\n\n   logic                   b_enable, b_twos_comp;\n   logic        [32:0]     b_in;\n   logic        [34:0]     b_ff;\n\n   logic        [31:0]     q_in, q_ff;\n\n   logic                   rq_enable, r_sign_sel, r_restore_sel, r_adder1_sel, r_adder2_sel, r_adder3_sel;\n   logic        [31:0]     r_in, r_ff;\n\n   logic                   twos_comp_q_sel, twos_comp_b_sel;\n   logic        [31:0]     twos_comp_in, twos_comp_out;\n\n   logic        [3:1]      quotient_raw;\n   logic        [1:0]      quotient_new;\n   logic        [32:0]     adder1_out;\n   logic        [33:0]     adder2_out;\n   logic        [34:0]     adder3_out;\n\n   logic        [63:0]     ar_shifted;\n   logic        [5:0]      shortq;\n   logic        [4:0]      shortq_shift;\n   logic        [4:1]      shortq_shift_ff;\n   logic                   shortq_neg_or_zero;\n   logic                   shortq_enable;\n   logic                   shortq_enable_ff;\n   logic        [32:0]     shortq_dividend;\n\n   logic                   by_zero_case;\n\n   logic "}
{"text": "        [4:1]     special_in;\n   logic         [4:1]     special_ff;\n\n\n\n   rvdffe #(21) i_misc_ff        (.*, .clk(clk), .en(misc_enable),  .din ({valid_ff_in, control_in[2:0], count_in[6:0], special_in[4:1], shortq_enable,    shortq_shift[4:1],    finish   }),\n                                                                    .dout({valid_ff,    control_ff[2:0], count_ff[6:0], special_ff[4:1], shortq_enable_ff, shortq_shift_ff[4:1], finish_ff}) );\n\n   rvdffe #(32) i_a_ff           (.*, .clk(clk), .en(a_enable),     .din(a_in[31:0]),    .dout(a_ff[31:0]));\n   rvdffe #(33) i_b_ff           (.*, .clk(clk), .en(b_enable),     .din(b_in[32:0]),    .dout(b_ff[32:0]));\n   rvdffe #(32) i_r_ff           (.*, .clk(clk), .en(rq_enable),    .din(r_in[31:0]),    .dout(r_ff[31:0]));\n   rvdffe #(32) i_q_ff           (.*, .clk(clk), .en(rq_enable),    .din(q_in[31:0]),    .dout(q_ff[31:0]));\n\n\n\n   assign special_in[4:1]        = {special_ff[3] & ~cancel,\n                                    special_ff[2] & ~cancel,\n                                    special_ff[1] & ~cancel,\n                                    (smallnum_case | by_zero_case) & ~cancel};\n\n   assign valid_ff_in            =  valid_in  & ~cancel;\n\n   assign control_in[2]          = (~valid_in & control_ff[2]) | (valid_in & signed_in  & dividend_in[31]);\n   assign control_in[1]          = (~valid_in & control_ff[1]) | (valid_in & signed_in  &  divisor_in[31]);\n   assign control_in[0]          = (~valid_in & control_ff[0]) | (valid_in & rem_in);\n\n   assign dividend_sign_ff       =  control_ff[2];\n   assign divisor_sign_ff        =  control_ff[1];\n   assign rem_ff                 =  control_ff[0];\n\n\n   assign by_zero_case           =  valid_ff & (b_ff[31:0] == 32'b0);\n\n   assign misc_enable            =  valid_in | valid_ff | cancel | running_state | finish_ff;\n   assign running_state          = (| count_ff[6:0]) | shortq_enable_ff;\n   assign finish_raw             =   special_ff[3] |\n                                    (count_ff[6:0] == 7'd32);\n\n\n   assign finish                 =  finish_raw & ~cancel;\n   assign count_enable           = (valid_ff | running_state) & ~finish & ~finish_ff & ~cancel & ~shortq_enable;\n   assign count_in[6:0]          = {7{count_enable}} & (count_ff[6:0] + {5'b0,2'b10} + {2'b0,shortq_shift_ff[4:1],1'b0});\n\n\n   assign a_enable               =  valid_in | running_state;\n   assign a_shift                =  running_state & ~shortq_enable_ff;\n\n   assign ar_shifted[63:0]       = { {32{dividend_sign_ff}} , a_ff[31:0]} << {shortq_shift_ff[4:1],1'b0};\n\n   assign a_in[31:0]             = ( {32{~a_shift & ~shortq_enable_ff}} &  dividend_in[31:0] ) |\n                                   ( {32{ a_shift                    }} & {a_ff[29:0],2'b0}  ) |\n                                   ( {32{            shortq_enable_ff}} &  ar_shifted[31:0]  );\n\n\n\n   assign b_enable               =    valid_in | b_twos_comp;\n   assign b_twos_comp            =    valid_ff & ~(dividend_sign_ff ^ divisor_sign_ff);\n\n   assign b_in[32:0]             = ( {33{~b_twos_comp}} & { (signed_in & divisor_in[31]),divisor_in[31:0] } ) |\n                                   ( {33{ b_twos_comp}} & {~divisor_sign_ff,twos_comp_out[31:0] } );\n\n\n   assign rq_enable              = (valid_in | valid_ff | running_state) & ~(| special_ff[3:1]);\n   assign r_sign_sel             =  valid_ff      &  dividend_sign_ff & ~by_zero_case;\n   assign r_restore_sel          =  running_state & (quotient_new[1:0] == 2'b00) & ~shortq_enable_ff;\n   assign r_adder1_sel           =  running_state & (quotient_new[1:0] == 2'b01) & ~shortq_enable_ff;\n   assign r_adder2_sel           =  running_state & (quotient_new[1:0] == 2'b10) & ~shortq_enable_ff;\n   assign r_adder3_sel           =  running_state & (quotient_new[1:0] == 2'b11) & ~shortq_enable_ff;\n\n\n   assign r_in[31:0]             = ( {32{r_sign_sel      }} &  32'hffffffff             ) |\n                                   ( {32{r_restore_sel   }} & {r_ff[29:0] ,a_ff[31:30]} ) |\n                                   ( {32{r_adder1_sel    }} &  adder1_out[31:0]         ) |\n                                   ( {32{r_adder2_sel    }} &  adder2_out[31:0]         ) |\n                                   ( {32{r_adder3_sel    }} &  adder3_out[31:0]         ) |\n                                   ( {32{shortq_enable_ff}} &  ar_shifted[63:32]        ) |\n                                   ( {32{by_zero_case    }} &  a_ff[31:0]               );\n\n\n   assign q_in[31:0]             = ( {32{~valid_ff       }} & {q_ff[29:0], quotient_new[1:0]} ) |\n                                   ( {32{ smallnum_case  }} & {28'b0     , smallnum[3:0]}     ) |\n                                   ( {32{ by_zero_case   }} & {32{1'b1}}                      );\n\n\n   assign b_ff[34:33]            = {b_ff[32],b_ff[32]};\n\n\n   assign adder1_out[32:0]       = {         r_ff[30:0],a_ff[31:30]}  +  b_ff[32:0];\n   assign adder2_out[33:0]       = {         r_ff[31:0],a_ff[31:30]}  + {b_ff[32:0],1'b0};\n   assign adder3_out[34:0]       = {r_ff[31],r_ff[31:0],a_ff[31:30]}  + {b_ff[33:0],1'b0}  +  b_ff[34:0];\n\n\n   assign quotient_raw[1]        = (~adder1_out[32] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder1_out[32:0] == 33'b0) );\n   assign quotient_raw[2]        = (~adder2_out[33] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder2_out[33:0] == 34'b0) );\n   assign quotient_raw[3]        = (~adder3_out[34] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder3_out[34:0] == 35'b0) );\n\n   assign quotient_new[1]        = quotient_raw[3] |  quotient_raw[2];\n   assign quotient_new[0]        = quotient_raw[3] |(~quotient_raw[2] & quotient_raw[1]);\n\n\n   assign twos_comp_b_sel        =  valid_ff           & ~(dividend_sign_ff ^ divisor_sign_ff);\n   assign twos_comp_q_sel        = ~valid_ff & ~rem_ff &  (dividend_sign_ff ^ divisor_sign_ff) & ~special_ff[4];\n\n   assign twos_comp_in[31:0]     = ( {32{twos_comp_q_sel}} & q_ff[31:0] ) |\n                                   ( {32{twos_comp_b_sel}} & b_ff[31:0] );\n\n   rvtwoscomp #(32) i_twos_comp  (.din(twos_comp_in[31:0]), .dout(twos_comp_out[31:0]));\n\n\n\n   assign valid_out              =  finish_ff & ~cancel;\n\n   assign data_out[31:0]         = ( {32{~rem_ff & ~twos_comp_q_sel}} & q_ff[31:0]          ) |\n                                   ( {32{ rem_ff                   }} & r_ff[31:0]          ) |\n                                   ( {32{           twos_comp_q_sel}} & twos_comp_out[31:0] );\n\n\n\n\n   // *** *** *** START : SMALLNUM {{\n\n   assign smallnum_case          = ( (a_ff[31:4]  == 28'b0) & (b_ff[31:4] == 28'b0) & ~by_zero_case & ~rem_ff & valid_ff & ~cancel) |\n                                   ( (a_ff[31:0]  == 32'b0) &                         ~by_zero_case & ~rem_ff & valid_ff & ~cancel);\n\n   assign smallnum[3]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           );\n\n   assign smallnum[2]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] & ~b_ff[2]                      );\n\n   assign smallnum[1]            = (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                                  ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &            ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2]                      );\n\n   assign smallnum[0]            = (            a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &             a_ff[0] & ~b_ff[3] &             b_ff[1] &  b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                                  a_ff[0] & ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] & ~a_ff[1] &            ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &                                             ~b_ff[2] & ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] &  b_ff[2] &  b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &             a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] & ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &             b_ff[0]) |\n                                   (           ~a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                                             ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] &             a_ff[1] &                       ~b_ff[2] &            ~b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &  b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                        b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &             a_ff[1] &             b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                        a_ff[0] &            ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &            ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &             a_ff[0] &  b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &  a_ff[1] &            ~b_ff[3] &             b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &  a_ff[0] &            ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] &  b_ff[3]                                 );\n\n   // *** *** *** END   : SMALLNUM }}\n\n\n\n\n   // *** *** *** Start : Short Q {{\n\n   assign shortq_dividend[32:0]   = {dividend_sign_ff,a_ff[31:0]};\n\n\n   parameter shortq_a_width = 33;\n   parameter shortq_b_width = 33;\n\n   logic [5:0]  dw_a_enc;\n   logic [5:0]  dw_b_enc;\n   logic [6:0]  dw_shortq_raw;\n\n\n   eh2_exu_div_cls i_a_cls  (\n       .operand  ( shortq_dividend[32:0]  ),\n       .cls      ( dw_a_enc[4:0]          ));\n\n   eh2_exu_div_cls i_b_cls  (\n       .operand  ( b_ff[32:0]             ),\n       .cls      ( dw_b_enc[4:0]          ));\n\n   assign dw_a_enc[5]             =  1'b0;\n   assign dw_b_enc[5]             =  1'b0;\n\n\n   assign dw_shortq_raw[6:0]      =  {1'b0,dw_b_enc[5:0]} - {1'b0,dw_a_enc[5:0]} + 7'd1;\n   assign shortq_neg_or_zero      =  dw_shortq_raw[6] | (dw_shortq_raw[5:1] == 5'b0);      // Also includes 1\n   assign shortq[5:0]             =  shortq_neg_or_zero  ?  6'd2  :  dw_shortq_raw[5:0];   // 2 is minimum SHORTQ otherwise WB too early\n\n   assign shortq_enable           =  valid_ff & ~shortq[5] & ~(shortq[4:1] ==  4'b1111) & ~cancel;\n\n   assign shortq_shift[4:0]       = ~shortq_enable     ?  5'd0  :  (5'b11111 - shortq[4:0]);   // [0] is unused\n\n   // *** *** *** End   : Short Q }}\n\n\n\n\n\nendmodule // eh2_exu_div_new_2bit_fullshortq\n\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nmodule eh2_exu_div_new_3bit_fullshortq\n  (\n   input  logic            clk,                       // Top level clock\n   input  logic            rst_l,                     // Reset\n   input  logic            scan_mode,                 // Scan mode\n\n   input  logic            cancel,                    // Flush pipeline\n   input  logic            valid_in,\n   input  logic            signed_in,\n   input  logic            rem_in,\n   input  logic [31:0]     dividend_in,\n   input  logic [31:0]     divisor_in,\n\n   output logic            valid_out,\n   output logic [31:0]     data_out\n  );\n\n\n   logic                   valid_ff_in, valid_ff;\n   logic                   finish_raw, finish, finish_ff;\n   logic                   running_state;\n   logic                   misc_enable;\n   logic        [2:0]      control_in, control_ff;\n   logic                   dividend_sign_ff, divisor_sign_ff, rem_ff;\n   logic                   count_enable;\n   logic        [6:0]      count_in, count_ff;\n\n   logic                   smallnum_case;\n   logic        [3:0]      smallnum;\n\n   logic                   a_enable, a_shift;\n   logic        [32:0]     a_in, a_ff;\n\n   logic                   b_enable, b_twos_comp;\n   logic        [32:0]     b_in;\n   logic        [36:0]     b_ff;\n\n   logic        [31:0]     q_in, q_ff;\n\n   logic                   rq_enable;\n   logic                   r_sign_sel;\n   logic                   r_restore_sel;\n   logic                   r_adder1_sel, r_adder2_sel, r_adder3_sel, r_adder4_sel, r_adder5_sel, r_adder6_sel, r_adder7_sel;\n   logic        [32:0]     r_in, r_ff;\n\n   logic                   twos_comp_q_sel, twos_comp_b_sel;\n   logic        [31:0]     twos_comp_in, twos_comp_out;\n\n   logic        [7:1]      quotient_raw;\n   logic        [2:0]      quotient_new;\n   logic        [33:0]     adder1_out;\n   logic        [34:0]     adder2_out;\n   logic        [35:0]     adder3_out;\n   logic        [36:0]     adder4_out;\n   logic        [36:0]     adder5_out;\n   logic        [36:0]     adder6_out;\n   logic        [36:0]     adder7_out;\n\n   logic        [65:0]     ar_shifted;\n   logic        [5:0]      shortq;\n   logic        [4:0]      shortq_shift;\n   logic        [4:0]      shortq_decode;\n   logic        [4:0]      shortq_shift_ff;\n   logic                   shortq_enable;\n   logic                   shortq_enable_ff;\n   logic        [32:0]     shortq_dividend;\n\n   logic                   by_zero_case;\n\n   logic         [4:1]     special_in;\n   logic         [4:1]     special_ff;\n\n\n\n   rvdffe #(22) i_misc_ff        (.*, .clk(clk), .en(misc_enable),  .din ({valid_ff_in, control_in[2:0], count_in[6:0], special_in[4:1], shortq_enable,    shortq_shift[4:0],    finish   }),\n                                                                    .dout({valid_ff,    control_ff[2:0], count_ff[6:0], special_ff[4:1], shortq_enable_ff, shortq_shift_ff[4:0], finish_ff}) );\n\n   rvdffe #(33) i_a_ff           (.*, .clk(clk), .en(a_enable),     .din(a_in[32:0]),    .dout(a_ff[32:0]));\n   rvdffe #(33) i_b_ff           (.*, .clk(clk), .en(b_enable),     .din(b_in[32:0]),    .dout(b_ff[32:0]));\n   rvdffe #(33) i_r_ff           (.*, .clk(clk), .en(rq_enable),    .din(r_in[32:0]),    .dout(r_ff[32:0]));\n   rvdffe #(32) i_q_ff           (.*, .clk(clk), .en(rq_enable),    .din(q_in[31:0]),    .dout(q_ff[31:0]));\n\n\n\n   assign special_in[4:1]        = {special_ff[3] & ~cancel,\n                                    special_ff[2] & ~cancel,\n                                    special_ff[1] & ~cancel,\n                                    (smallnum_case | by_zero_case) & ~cancel};\n\n   assign valid_ff_in            =  valid_in  & ~cancel;\n\n   assign control_in[2]          = (~valid_in & control_ff[2]) | (valid_in & signed_in  & dividend_in[31]);\n   assign control_in[1]          = (~valid_in & control_ff[1]) | (valid_in & signed_in  &  divisor_in[31]);\n   assign control_in[0]          = (~valid_in & control_ff[0]) | (valid_in & rem_in);\n\n   assign dividend_sign_ff       =  control_ff[2];\n   assign divisor_sign_ff        =  control_ff[1];\n   assign rem_ff                 =  control_ff[0];\n\n\n   assign by_zero_case           =  valid_ff & (b_ff[31:0] == 32'b0);\n\n   assign misc_enable            =  valid_in | valid_ff | cancel | running_state | finish_ff;\n   assign running_state          = (| count_ff[6:0]) | shortq_enable_ff;\n   assign finish_raw             =   special_ff[3] |\n                                    (count_ff[6:0] == 7'd33);\n\n\n   assign finish                 =  finish_raw & ~cancel;\n   assign count_enable           = (valid_ff | running_state) & ~finish & ~finish_ff & ~cancel & ~shortq_enable;\n   assign count_in[6:0]          = {7{count_enable}} & (count_ff[6:0] + {5'b0,2'b11} + {2'b0,shortq_shift_ff[4:0]});\n\n\n   assign a_enable               =  valid_in | running_state;\n   assign a_shift                =  running_state & ~shortq_enable_ff;\n\n   assign ar_shifted[65:0]       = { {33{dividend_sign_ff}} , a_ff[32:0]} << {shortq_shift_ff[4:0]};\n\n   assign a_in[32:0]             = ( {33{~a_shift & ~shortq_enable_ff}} & {signed_in & dividend_in[31],dividend_in[31:0]} ) |\n                                   ( {33{ a_shift                    }} & {a_ff[29:0],3'b0}  ) |\n                                   ( {33{            shortq_enable_ff}} &  ar_shifted[32:0]  );\n\n\n\n   assign b_enable               =    valid_in | b_twos_comp;\n   assign b_twos_comp            =    valid_ff & ~(dividend_sign_ff ^ divisor_sign_ff);\n\n   assign b_in[32:0]             = ( {33{~b_twos_comp}} & { (signed_in & divisor_in[31]),divisor_in[31:0] } ) |\n                                   ( {33{ b_twos_comp}} & {~divisor_sign_ff,twos_comp_out[31:0] } );\n\n\n   assign rq_enable              = (valid_in | valid_ff | running_state) & ~(| special_ff[3:1]);\n   assign r_sign_sel             =  valid_ff      &  dividend_sign_ff & ~by_zero_case;\n   assign r_restore_sel          =  running_state & (quotient_new[2:0] == 3'b000) & ~shortq_enable_ff;\n   assign r_adder1_sel           =  running_state & (quotient_new[2:0] == 3'b001) & ~shortq_enable_ff;\n   assign r_adder2_sel           =  running_state & (quotient_new[2:0] == 3'b010) & ~shortq_enable_ff;\n   assign r_adder3_sel           =  running_state & (quotient_new[2:0] == 3'b011) & ~shortq_enable_ff;\n   assign r_adder4_sel           =  running_state & (quotient_new[2:0] == 3'b100) & ~shortq_enable_ff;\n   assign r_adder5_sel           =  running_state & (quotient_new[2:0] == 3'b101) & ~shortq_enable_ff;\n   assign r_adder6_sel           =  running_state & (quotient_new[2:0] == 3'b110) & ~shortq_enable_ff;\n   assign r_adder7_sel           =  running_state & (quotient_new[2:0] == 3'b111) & ~shortq_enable_ff;\n\n\n   assign r_in[32:0]             = ( {33{r_sign_sel      }} & {33{1'b1}}               ) |\n                                   ( {33{r_restore_sel   }} & {r_ff[29:0] ,a_ff[32:30]} ) |\n                                   ( {33{r_adder1_sel    }} &  adder1_out[32:0]         ) |\n                    "}
{"text": "               ( {33{r_adder2_sel    }} &  adder2_out[32:0]         ) |\n                                   ( {33{r_adder3_sel    }} &  adder3_out[32:0]         ) |\n                                   ( {33{r_adder4_sel    }} &  adder4_out[32:0]         ) |\n                                   ( {33{r_adder5_sel    }} &  adder5_out[32:0]         ) |\n                                   ( {33{r_adder6_sel    }} &  adder6_out[32:0]         ) |\n                                   ( {33{r_adder7_sel    }} &  adder7_out[32:0]         ) |\n                                   ( {33{shortq_enable_ff}} &  ar_shifted[65:33]        ) |\n                                   ( {33{by_zero_case    }} & {1'b0,a_ff[31:0]}         );\n\n\n   assign q_in[31:0]             = ( {32{~valid_ff     }} & {q_ff[28:0], quotient_new[2:0]} ) |\n                                   ( {32{ smallnum_case}} & {28'b0     , smallnum[3:0]}     ) |\n                                   ( {32{ by_zero_case }} & {32{1'b1}}                      );\n\n\n   assign b_ff[36:33]            = {b_ff[32],b_ff[32],b_ff[32],b_ff[32]};\n\n\n   assign adder1_out[33:0]       = {         r_ff[30:0],a_ff[32:30]}  +   b_ff[33:0];\n   assign adder2_out[34:0]       = {         r_ff[31:0],a_ff[32:30]}  +  {b_ff[33:0],1'b0};\n   assign adder3_out[35:0]       = {         r_ff[32:0],a_ff[32:30]}  +  {b_ff[34:0],1'b0}  +   b_ff[35:0];\n   assign adder4_out[36:0]       = {r_ff[32],r_ff[32:0],a_ff[32:30]}  +  {b_ff[34:0],2'b0};\n   assign adder5_out[36:0]       = {r_ff[32],r_ff[32:0],a_ff[32:30]}  +  {b_ff[34:0],2'b0}  +   b_ff[36:0];\n   assign adder6_out[36:0]       = {r_ff[32],r_ff[32:0],a_ff[32:30]}  +  {b_ff[34:0],2'b0}  +  {b_ff[35:0],1'b0};\n   assign adder7_out[36:0]       = {r_ff[32],r_ff[32:0],a_ff[32:30]}  +  {b_ff[34:0],2'b0}  +  {b_ff[35:0],1'b0}  +  b_ff[36:0];\n\n   assign quotient_raw[1]        = (~adder1_out[33] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder1_out[33:0] == 34'b0) );\n   assign quotient_raw[2]        = (~adder2_out[34] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder2_out[34:0] == 35'b0) );\n   assign quotient_raw[3]        = (~adder3_out[35] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder3_out[35:0] == 36'b0) );\n   assign quotient_raw[4]        = (~adder4_out[36] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder4_out[36:0] == 37'b0) );\n   assign quotient_raw[5]        = (~adder5_out[36] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder5_out[36:0] == 37'b0) );\n   assign quotient_raw[6]        = (~adder6_out[36] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder6_out[36:0] == 37'b0) );\n   assign quotient_raw[7]        = (~adder7_out[36] ^ dividend_sign_ff) | ( (a_ff[29:0] == 30'b0) & (adder7_out[36:0] == 37'b0) );\n\n   assign quotient_new[2]        = quotient_raw[7] |   quotient_raw[6] | quotient_raw[5]  |   quotient_raw[4];\n   assign quotient_new[1]        = quotient_raw[7] |   quotient_raw[6] |                    (~quotient_raw[4] & quotient_raw[3]) | (~quotient_raw[3] & quotient_raw[2]);\n   assign quotient_new[0]        = quotient_raw[7] | (~quotient_raw[6] & quotient_raw[5]) | (~quotient_raw[4] & quotient_raw[3]) | (~quotient_raw[2] & quotient_raw[1]);\n\n\n   assign twos_comp_b_sel        =  valid_ff           & ~(dividend_sign_ff ^ divisor_sign_ff);\n   assign twos_comp_q_sel        = ~valid_ff & ~rem_ff &  (dividend_sign_ff ^ divisor_sign_ff) & ~special_ff[4];\n\n   assign twos_comp_in[31:0]     = ( {32{twos_comp_q_sel}} & q_ff[31:0] ) |\n                                   ( {32{twos_comp_b_sel}} & b_ff[31:0] );\n\n   rvtwoscomp #(32) i_twos_comp  (.din(twos_comp_in[31:0]), .dout(twos_comp_out[31:0]));\n\n\n\n   assign valid_out              =  finish_ff & ~cancel;\n\n   assign data_out[31:0]         = ( {32{~rem_ff & ~twos_comp_q_sel}} & q_ff[31:0]          ) |\n                                   ( {32{ rem_ff                   }} & r_ff[31:0]          ) |\n                                   ( {32{           twos_comp_q_sel}} & twos_comp_out[31:0] );\n\n\n\n\n   // *** *** *** START : SMALLNUM {{\n\n   assign smallnum_case          = ( (a_ff[31:4]  == 28'b0) & (b_ff[31:4] == 28'b0) & ~by_zero_case & ~rem_ff & valid_ff & ~cancel & 1'b0) |\n                                   ( (a_ff[31:0]  == 32'b0) &                         ~by_zero_case & ~rem_ff & valid_ff & ~cancel & 1'b0);\n\n   assign smallnum[3]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           );\n\n   assign smallnum[2]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] & ~b_ff[2]                      );\n\n   assign smallnum[1]            = (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                                  ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &            ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2]                      );\n\n   assign smallnum[0]            = (            a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &             a_ff[0] & ~b_ff[3] &             b_ff[1] &  b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                                  a_ff[0] & ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] & ~a_ff[1] &            ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &                                             ~b_ff[2] & ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] &  b_ff[2] &  b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &             a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] & ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &             b_ff[0]) |\n                                   (           ~a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                                             ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] &             a_ff[1] &                       ~b_ff[2] &            ~b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &  b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                        b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &             a_ff[1] &             b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                        a_ff[0] &            ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &            ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &             a_ff[0] &  b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &  a_ff[1] &            ~b_ff[3] &             b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &  a_ff[0] &            ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] &  b_ff[3]                                 );\n\n   // *** *** *** END   : SMALLNUM }}\n\n\n\n\n   // *** *** *** Start : Short Q {{\n\n   assign shortq_dividend[32:0]   = {dividend_sign_ff,a_ff[31:0]};\n\n\n   parameter shortq_a_width = 33;\n   parameter shortq_b_width = 33;\n\n   logic [5:0]  dw_a_enc;\n   logic [5:0]  dw_b_enc;\n   logic [6:0]  dw_shortq_raw;\n\n\n   eh2_exu_div_cls i_a_cls  (\n       .operand  ( shortq_dividend[32:0]  ),\n       .cls      ( dw_a_enc[4:0]          ));\n\n   eh2_exu_div_cls i_b_cls  (\n       .operand  ( b_ff[32:0]             ),\n       .cls      ( dw_b_enc[4:0]          ));\n\n   assign dw_a_enc[5]             =  1'b0;\n   assign dw_b_enc[5]             =  1'b0;\n\n\n   assign dw_shortq_raw[6:0]      =  {1'b0,dw_b_enc[5:0]} - {1'b0,dw_a_enc[5:0]} + 7'd1;\n   assign shortq[5:0]             =  dw_shortq_raw[6]    ?  6'd0  :  dw_shortq_raw[5:0];\n\n   assign shortq_enable           =  valid_ff & ~shortq[5] & ~(shortq[4:2] ==  3'b111) & ~cancel;\n\n   assign shortq_decode[4:0]      = ( {5{shortq[4:0] == 5'd31}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd30}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd29}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd28}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd27}} & 5'd03) |\n                                    ( {5{shortq[4:0] == 5'd26}} & 5'd06) |\n                                    ( {5{shortq[4:0] == 5'd25}} & 5'd06) |\n                                    ( {5{shortq[4:0] == 5'd24}} & 5'd06) |\n                                    ( {5{shortq[4:0] == 5'd23}} & 5'd09) |\n                                    ( {5{shortq[4:0] == 5'd22}} & 5'd09) |\n                                    ( {5{shortq[4:0] == 5'd21}} & 5'd09) |\n                                    ( {5{shortq[4:0] == 5'd20}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd19}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd18}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd17}} & 5'd15) |\n                                    ( {5{shortq[4:0] == 5'd16}} & 5'd15) |\n                                    ( {5{shortq[4:0] == 5'd15}} & 5'd15) |\n                                    ( {5{shortq[4:0] == 5'd14}} & 5'd18) |\n                                    ( {5{shortq[4:0] == 5'd13}} & 5'd18) |\n                                    ( {5{shortq[4:0] == 5'd12}} & 5'd18) |\n                                    ( {5{shortq[4:0] == 5'd11}} & 5'd21) |\n                                    ( {5{shortq[4:0] == 5'd10}} & 5'd21) |\n                                    ( {5{shortq[4:0] == 5'd09}} & 5'd21) |\n                                    ( {5{shortq[4:0] == 5'd08}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd07}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd06}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd05}} & 5'd27) |\n                                    ( {5{shortq[4:0] == 5'd04}} & 5'd27) |\n                                    ( {5{shortq[4:0] == 5'd03}} & 5'd27) |\n                                    ( {5{shortq[4:0] == 5'd02}} & 5'd27) |  // Using 30 will violate the minimum latency required\n                                    ( {5{shortq[4:0] == 5'd01}} & 5'd27) |  // Using 30 will violate the minimum latency required\n                                    ( {5{shortq[4:0] == 5'd00}} & 5'd27);   // Using 30 will violate the minimum latency required\n\n\n   assign shortq_shift[4:0]       = ~shortq_enable     ?  5'd0  :  shortq_decode[4:0];\n\n   // *** *** *** End   : Short Q }}\n\n\n\n\n\nendmodule // eh2_exu_div_new_3bit_fullshortq\n\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nmodule eh2_exu_div_new_4bit_fullshortq\n  (\n   input  logic            clk,                       // Top level clock\n   input  logic            rst_l,                     // Reset\n   input  logic            scan_mode,                 // Scan mode\n\n   input  logic            cancel,                    // Flush pipeline\n   input  logic            valid_in,\n   input  logic            signed_in,\n   input  logic            rem_in,\n   input  logic [31:0]     dividend_in,\n   input  logic [31:0]     divisor_in,\n\n   output logic            valid_out,\n   output logic [31:0]     data_out\n  );\n\n\n   logic                   valid_ff_in, valid_ff;\n   logic                   finish_raw, finish, finish_ff;\n   logic                   running_state;\n   logic                   misc_enable;\n   logic         [2:0]     control_in, control_ff;\n   logic                   dividend_sign_ff, divisor_sign_ff, rem_ff;\n   logic                   count_enable;\n   logic         [6:0]     count_in, count_ff;\n\n   logic                   smallnum_case;\n   logic         [3:0]     smallnum;\n\n   logic                   a_enable, a_shift;\n   logic        [31:0]     a_in, a_ff;\n\n   logic                   b_enable, b_twos_comp;\n   logic        [32:0]     b_in;\n   logic        [37:0]     b_ff;\n\n   logic        [31:0]     q_in, q_ff;\n\n   logic                   rq_enable;\n   logic                   r_sign_sel;\n   logic                   r_restore_sel;\n   logic                   r_adder01_sel, r_adder02_sel, r_adder03_sel;\n   logic                   r_adder04_sel, r_adder05_sel, r_adder06_sel, r_adder07_sel;\n   logic                   r_adder08_sel, r_adder09_sel, r_adder10_sel, r_adder11_sel;\n   logic                   r_adder12_sel, r_adder13_sel, r_adder14_sel, r_adder15_sel;\n   logic        [32:0]     r_in, r_ff;\n\n   logic                   twos_comp_q_sel, twos_comp_b_sel;\n   logic        [31:0]     twos_comp_in, twos_comp_out;\n\n   logic        [15:1]     quotient_raw;\n   logic         [3:0]     quotient_new;\n   logic        [34:0]     adder01_out;\n   logic        [35:0]     adder02_out;\n   logic        [36:0]     adder03_out;\n   logic        [37:0]     adder04_out;\n   logic        [37:0]     adder05_out;\n   logic        [37:0]     adder06_out;\n   logic        [37:0]     adder07_out;\n   logic        [37:0]     adder08_out;\n   logic        [37:0]     adder09_out;\n   logic        [37:0]     adder10_out;\n   logic        [37:0]     adder11_out;\n   logic        [37:0]     adder12_out;\n   logic        [37:0]     adder13_out;\n   logic        [37:0]     adder14_out;\n   logic        [37:0]     adder15_out;\n\n   logic        [64:0]     ar_shifted;\n   logic         [5:0]     shortq;\n   logic         [4:0]     shortq_shift;\n   logic         [4:0]     shortq_decode;\n   logic         [4:0]     shortq_shift_ff;\n   logic                   shortq_enable;\n   logic                   shortq_enable_ff;\n   logic        [32:0]     shortq_dividend;\n\n   logic                   by_zero_case;\n\n   logic         [4:1]     special_in;\n   logic         [4:1]     special_ff;\n\n\n\n   rvdffe #(22) i_misc_ff        (.*, .clk(clk), .en(misc_enable),  .din ({valid_ff_in, control_in[2:0], count_in[6:0], special_in[4:1], shortq_enable,    shortq_shift[4:0],    finish   }),\n                                                                    .dout({valid_ff,    control_ff[2:0], count_ff[6:0], special_ff[4:1], shortq_enable_ff, shortq_shift_ff[4:0], finish_ff}) );\n\n   rvdffe #(32) i_a_ff           (.*, .clk(clk), .en(a_enable),     .din(a_in[31:0]),    .dout(a_ff[31:0]));\n   rvdffe #(33) i_b_ff           (.*, .clk(clk), .en(b_enable),     .din(b_in[32:0]),    .dout(b_ff[32:0]));\n   rvdffe #(33) i_r_ff           (.*, .clk(clk), .en(rq_enable),    .din(r_in[32:0]),    .dout(r_ff[32:0]));\n   rvdffe #(32) i_q_ff           (.*, .clk(clk), .en(rq_enable),    .din(q_in[31:0]),    .dout(q_ff[31:0]));\n\n\n\n   assign special_in[4:1]        = {special_ff[3] & ~cancel,\n                                    special_ff[2] & ~cancel,\n                                    special_ff[1] & ~cancel,\n                                    (smallnum_case | by_zero_case) & ~cancel};\n\n   assign valid_ff_in            =  valid_in  & ~cancel;\n\n   assign control_in[2]          = (~valid_in & control_ff[2]) | (valid_in & signed_in  & dividend_in[31]);\n   assign control_in[1]          = (~valid_in & control_ff[1]) | (valid_in & signed_in  &  divisor_in[31]);\n   assign control_in[0]          = (~valid_in & control_ff[0]) | (valid_in & rem_in);\n\n   assign dividend_sign_ff       =  control_ff[2];\n   assign divisor_sign_ff        =  control_ff[1];\n   assign rem_ff                 =  control_ff[0];\n\n\n   assign by_zero_case           =  valid_ff & (b_ff[31:0] == 32'b0);\n\n   assign misc_enable            =  valid_in | valid_ff | cancel | running_state | finish_ff;\n   assign running_state          = (| count_ff[6:0]) | shortq_enable_ff;\n   assign finish_raw             =   special_ff[3] |\n                                    (count_ff[6:0] == 7'd32);\n\n\n   assign finish                 =  finish_raw & ~cancel;\n   assign count_enable           = (valid_ff | running_state) & ~finish & ~finish_ff & ~cancel & ~shortq_enable;\n   assign count_in[6:0]          = {7{count_enable}} & (count_ff[6:0] + 7'd4 + {2'b0,shortq_shift_ff[4:0]});\n\n\n   assign a_enable               =  valid_in | running_state;\n   assign a_shift                =  running_state & ~shortq_enable_ff;\n\n   assign ar_shifted[64:0]       = { {33{dividend_sign_ff}} , a_ff[31:0]} << {shortq_shift_ff[4:0]};\n\n   assign a_in[31:0]             = ( {32{~a_shift & ~shortq_enable_ff}} &  dividend_in[31:0] ) |\n                                   ( {32{ a_shift                    }} & {a_ff[27:0],4'b0}  ) |\n                                   ( {32{            shortq_enable_ff}} &  ar_shifted[31:0]  );\n\n\n\n   assign b_enable               =    valid_in | b_twos_comp;\n   assign b_twos_comp            =    valid_ff & ~(dividend_sign_ff ^ divisor_sign_ff);\n\n   assign b_in[32:0]             = ( {33{~b_twos_comp}} & { (signed_in & divisor_in[31]),divisor_in[31:0] } ) |\n                                   ( {33{ b_twos_comp}} & {~divisor_sign_ff,twos_comp_out[31:0] } );\n\n\n   assign rq_enable              =  valid_in | valid_ff | running_state & ~(| special_ff[3:1]);\n   assign r_sign_sel             =  valid_ff      &  dividend_sign_ff & ~by_zero_case;\n   assign r_restore_sel          =  running_state & (quotient_new[3:0] == 4'd00) & ~shortq_enable_ff;\n   assign r_adder01_sel          =  running_state & (quotient_new[3:0] == 4'd01) & ~shortq_enable_ff;\n   assign r_adder02_sel          =  running_state & (quotient_new[3:0] == 4'd02) & ~shortq_enable_ff;\n   assign r_adder03_sel          =  running_state & (quotient_new[3:0] == 4'd03) & ~shortq_enable_ff;\n   assign r_adder04_sel          =  running_state & (quotient_new[3:0] == 4'd04) & ~shortq_enable_ff;\n   assign r_adder05_sel          =  running_state & (quotient_new[3:0] == 4'd05) & ~shortq_enable_ff;\n   assign r_adder06_sel          =  running_state & (quotient_new[3:0] == 4'd06) & ~shortq"}
{"text": "_enable_ff;\n   assign r_adder07_sel          =  running_state & (quotient_new[3:0] == 4'd07) & ~shortq_enable_ff;\n   assign r_adder08_sel          =  running_state & (quotient_new[3:0] == 4'd08) & ~shortq_enable_ff;\n   assign r_adder09_sel          =  running_state & (quotient_new[3:0] == 4'd09) & ~shortq_enable_ff;\n   assign r_adder10_sel          =  running_state & (quotient_new[3:0] == 4'd10) & ~shortq_enable_ff;\n   assign r_adder11_sel          =  running_state & (quotient_new[3:0] == 4'd11) & ~shortq_enable_ff;\n   assign r_adder12_sel          =  running_state & (quotient_new[3:0] == 4'd12) & ~shortq_enable_ff;\n   assign r_adder13_sel          =  running_state & (quotient_new[3:0] == 4'd13) & ~shortq_enable_ff;\n   assign r_adder14_sel          =  running_state & (quotient_new[3:0] == 4'd14) & ~shortq_enable_ff;\n   assign r_adder15_sel          =  running_state & (quotient_new[3:0] == 4'd15) & ~shortq_enable_ff;\n\n   assign r_in[32:0]             = ( {33{r_sign_sel      }} & {33{1'b1}}               ) |\n                                   ( {33{r_restore_sel   }} & {r_ff[28:0],a_ff[31:28]} ) |\n                                   ( {33{r_adder01_sel   }} &  adder01_out[32:0]       ) |\n                                   ( {33{r_adder02_sel   }} &  adder02_out[32:0]       ) |\n                                   ( {33{r_adder03_sel   }} &  adder03_out[32:0]       ) |\n                                   ( {33{r_adder04_sel   }} &  adder04_out[32:0]       ) |\n                                   ( {33{r_adder05_sel   }} &  adder05_out[32:0]       ) |\n                                   ( {33{r_adder06_sel   }} &  adder06_out[32:0]       ) |\n                                   ( {33{r_adder07_sel   }} &  adder07_out[32:0]       ) |\n                                   ( {33{r_adder08_sel   }} &  adder08_out[32:0]       ) |\n                                   ( {33{r_adder09_sel   }} &  adder09_out[32:0]       ) |\n                                   ( {33{r_adder10_sel   }} &  adder10_out[32:0]       ) |\n                                   ( {33{r_adder11_sel   }} &  adder11_out[32:0]       ) |\n                                   ( {33{r_adder12_sel   }} &  adder12_out[32:0]       ) |\n                                   ( {33{r_adder13_sel   }} &  adder13_out[32:0]       ) |\n                                   ( {33{r_adder14_sel   }} &  adder14_out[32:0]       ) |\n                                   ( {33{r_adder15_sel   }} &  adder15_out[32:0]       ) |\n                                   ( {33{shortq_enable_ff}} &  ar_shifted[64:32]       ) |\n                                   ( {33{by_zero_case    }} & {1'b0,a_ff[31:0]}        );\n\n\n   assign q_in[31:0]             = ( {32{~valid_ff     }} & {q_ff[27:0], quotient_new[3:0]} ) |\n                                   ( {32{ smallnum_case}} & {28'b0     , smallnum[3:0]}     ) |\n                                   ( {32{ by_zero_case }} & {32{1'b1}}                      );\n\n\n   assign b_ff[37:33]            = {b_ff[32],b_ff[32],b_ff[32],b_ff[32],b_ff[32]};\n\n\n   assign adder01_out[34:0]      = {         r_ff[30:0],a_ff[31:28]}  +                                                                   b_ff[34:0];\n   assign adder02_out[35:0]      = {         r_ff[31:0],a_ff[31:28]}  +                                             {b_ff[34:0],1'b0};\n   assign adder03_out[36:0]      = {         r_ff[32:0],a_ff[31:28]}  +                                             {b_ff[35:0],1'b0}  +  b_ff[36:0];\n   assign adder04_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +                       {b_ff[35:0],2'b0};\n   assign adder05_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +                       {b_ff[35:0],2'b0}  +                        b_ff[37:0];\n   assign adder06_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +                       {b_ff[35:0],2'b0}  +  {b_ff[36:0],1'b0};\n   assign adder07_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +                       {b_ff[35:0],2'b0}  +  {b_ff[36:0],1'b0}  +  b_ff[37:0];\n   assign adder08_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0};\n   assign adder09_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +                                              b_ff[37:0];\n   assign adder10_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +                        {b_ff[36:0],1'b0};\n   assign adder11_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +                        {b_ff[36:0],1'b0}  +  b_ff[37:0];\n   assign adder12_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +  {b_ff[35:0],2'b0};\n   assign adder13_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +  {b_ff[35:0],2'b0}  +                        b_ff[37:0];\n   assign adder14_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +  {b_ff[35:0],2'b0}  +  {b_ff[36:0],1'b0};\n   assign adder15_out[37:0]      = {r_ff[32],r_ff[32:0],a_ff[31:28]}  +  {b_ff[34:0],3'b0} +  {b_ff[35:0],2'b0}  +  {b_ff[36:0],1'b0}  +  b_ff[37:0];\n\n   assign quotient_raw[01]       = (~adder01_out[34] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder01_out[34:0] == 35'b0) );\n   assign quotient_raw[02]       = (~adder02_out[35] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder02_out[35:0] == 36'b0) );\n   assign quotient_raw[03]       = (~adder03_out[36] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder03_out[36:0] == 37'b0) );\n   assign quotient_raw[04]       = (~adder04_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder04_out[37:0] == 38'b0) );\n   assign quotient_raw[05]       = (~adder05_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder05_out[37:0] == 38'b0) );\n   assign quotient_raw[06]       = (~adder06_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder06_out[37:0] == 38'b0) );\n   assign quotient_raw[07]       = (~adder07_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder07_out[37:0] == 38'b0) );\n   assign quotient_raw[08]       = (~adder08_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder08_out[37:0] == 38'b0) );\n   assign quotient_raw[09]       = (~adder09_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder09_out[37:0] == 38'b0) );\n   assign quotient_raw[10]       = (~adder10_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder10_out[37:0] == 38'b0) );\n   assign quotient_raw[11]       = (~adder11_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder11_out[37:0] == 38'b0) );\n   assign quotient_raw[12]       = (~adder12_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder12_out[37:0] == 38'b0) );\n   assign quotient_raw[13]       = (~adder13_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder13_out[37:0] == 38'b0) );\n   assign quotient_raw[14]       = (~adder14_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder14_out[37:0] == 38'b0) );\n   assign quotient_raw[15]       = (~adder15_out[37] ^ dividend_sign_ff) | ( (a_ff[27:0] == 28'b0) & (adder15_out[37:0] == 38'b0) );\n\n\n   assign quotient_new[0]        = ( quotient_raw[15:01] == 15'b000_0000_0000_0001 ) |  //  1\n                                   ( quotient_raw[15:03] == 13'b000_0000_0000_01   ) |  //  3\n                                   ( quotient_raw[15:05] == 11'b000_0000_0001      ) |  //  5\n                                   ( quotient_raw[15:07] ==  9'b000_0000_01        ) |  //  7\n                                   ( quotient_raw[15:09] ==  7'b000_0001           ) |  //  9\n                                   ( quotient_raw[15:11] ==  5'b000_01             ) |  // 11\n                                   ( quotient_raw[15:13] ==  3'b001                ) |  // 13\n                                   ( quotient_raw[   15] ==  1'b1                  );   // 15\n\n   assign quotient_new[1]        = ( quotient_raw[15:02] == 14'b000_0000_0000_001  ) |  //  2\n                                   ( quotient_raw[15:03] == 13'b000_0000_0000_01   ) |  //  3\n                                   ( quotient_raw[15:06] == 10'b000_0000_001       ) |  //  6\n                                   ( quotient_raw[15:07] ==  9'b000_0000_01        ) |  //  7\n                                   ( quotient_raw[15:10] ==  6'b000_001            ) |  // 10\n                                   ( quotient_raw[15:11] ==  5'b000_01             ) |  // 11\n                                   ( quotient_raw[15:14] ==  2'b01                 ) |  // 14\n                                   ( quotient_raw[   15] ==  1'b1                  );   // 15\n\n   assign quotient_new[2]        = ( quotient_raw[15:04] == 12'b000_0000_0000_1    ) |  //  4\n                                   ( quotient_raw[15:05] == 11'b000_0000_0001      ) |  //  5\n                                   ( quotient_raw[15:06] == 10'b000_0000_001       ) |  //  6\n                                   ( quotient_raw[15:07] ==  9'b000_0000_01        ) |  //  7\n                                   ( quotient_raw[15:12] ==  4'b000_1              ) |  // 12\n                                   ( quotient_raw[15:13] ==  3'b001                ) |  // 13\n                                   ( quotient_raw[15:14] ==  2'b01                 ) |  // 14\n                                   ( quotient_raw[   15] ==  1'b1                  );   // 15\n\n   assign quotient_new[3]        = ( quotient_raw[15:08] ==  8'b000_0000_1         ) |  //  8\n                                   ( quotient_raw[15:09] ==  7'b000_0001           ) |  //  9\n                                   ( quotient_raw[15:10] ==  6'b000_001            ) |  // 10\n                                   ( quotient_raw[15:11] ==  5'b000_01             ) |  // 11\n                                   ( quotient_raw[15:12] ==  4'b000_1              ) |  // 12\n                                   ( quotient_raw[15:13] ==  3'b001                ) |  // 13\n                                   ( quotient_raw[15:14] ==  2'b01                 ) |  // 14\n                                   ( quotient_raw[   15] ==  1'b1                  );   // 15\n\n\n   assign twos_comp_b_sel        =  valid_ff           & ~(dividend_sign_ff ^ divisor_sign_ff);\n   assign twos_comp_q_sel        = ~valid_ff & ~rem_ff &  (dividend_sign_ff ^ divisor_sign_ff) & ~special_ff[4];\n\n   assign twos_comp_in[31:0]     = ( {32{twos_comp_q_sel}} & q_ff[31:0] ) |\n                                   ( {32{twos_comp_b_sel}} & b_ff[31:0] );\n\n   rvtwoscomp #(32) i_twos_comp  (.din(twos_comp_in[31:0]), .dout(twos_comp_out[31:0]));\n\n\n\n   assign valid_out              =  finish_ff & ~cancel;\n\n   assign data_out[31:0]         = ( {32{~rem_ff & ~twos_comp_q_sel}} & q_ff[31:0]          ) |\n                                   ( {32{ rem_ff                   }} & r_ff[31:0]          ) |\n                                   ( {32{           twos_comp_q_sel}} & twos_comp_out[31:0] );\n\n\n\n\n   // *** *** *** START : SMALLNUM {{\n\n   assign smallnum_case          = ( (a_ff[31:4]  == 28'b0) & (b_ff[31:4] == 28'b0) & ~by_zero_case & ~rem_ff & valid_ff & ~cancel & 1'b0) |\n                                   ( (a_ff[31:0]  == 32'b0) &                         ~by_zero_case & ~rem_ff & valid_ff & ~cancel & 1'b0);\n\n   assign smallnum[3]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           );\n\n   assign smallnum[2]            = ( a_ff[3] &                                  ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] & ~b_ff[2]                      );\n\n   assign smallnum[1]            = (            a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                                  ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &                       ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &            ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2]                      );\n\n   assign smallnum[0]            = (            a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &             a_ff[0] & ~b_ff[3] &             b_ff[1] &  b_ff[0]) |\n                                   (            a_ff[2] &                       ~b_ff[3] &            ~b_ff[1] & ~b_ff[0]) |\n                                   (                       a_ff[1] &            ~b_ff[3] & ~b_ff[2] &            ~b_ff[0]) |\n                                   (                                  a_ff[0] & ~b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] & ~a_ff[1] &            ~b_ff[3] & ~b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &                                             ~b_ff[2] & ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] & ~a_ff[2] &                       ~b_ff[3] &  b_ff[2] &  b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &            ~b_ff[3] &  b_ff[2] & ~b_ff[1]           ) |\n                                   (~a_ff[3] &  a_ff[2] &             a_ff[0] & ~b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] & ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &             b_ff[0]) |\n                                   (           ~a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                                             ~b_ff[1] & ~b_ff[0]) |\n                                   ( a_ff[3] &             a_ff[1] &                       ~b_ff[2] &            ~b_ff[0]) |\n                                   (~a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] & ~b_ff[3] &  b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &                        b_ff[3] & ~b_ff[2]                      ) |\n                                   ( a_ff[3] &             a_ff[1] &             b_ff[3] & ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &                        a_ff[0] &            ~b_ff[2] & ~b_ff[1]           ) |\n                                   ( a_ff[3] &            ~a_ff[1] &            ~b_ff[3] &  b_ff[2] &  b_ff[1] &  b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &                       ~b_ff[0]) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &             b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] &  a_ff[2] &             a_ff[0] &  b_ff[3] &            ~b_ff[1]           ) |\n                                   ( a_ff[3] & ~a_ff[2] &  a_ff[1] &            ~b_ff[3] &             b_ff[1]           ) |\n                                   ( a_ff[3] &             a_ff[1] &  a_ff[0] &            ~b_ff[2]                      ) |\n                                   ( a_ff[3] &  a_ff[2] &  a_ff[1] &  a_ff[0] &  b_ff[3]                                 );\n\n   // *** *** *** END   : SMALLNUM }}\n\n\n\n\n   // *** *** *** Start : Short Q {{\n\n   assign shortq_dividend[32:0]   = {dividend_sign_ff,a_ff[31:0]};\n\n\n   parameter shortq_a_width = 33;\n   parameter shortq_b_width = 33;\n\n   logic [5:0]  dw_a_enc;\n   logic [5:0]  dw_b_enc;\n   logic [6:0]  dw_shortq_raw;\n\n\n   eh2_exu_div_cls i_a_cls  (\n       .operand  ( shortq_dividend[32:0]  ),\n       .cls      ( dw_a_enc[4:0]          ));\n\n   eh2_exu_div_cls i_b_cls  (\n       .operand  ( b_ff[32:0]             ),\n       .cls      ( dw_b_enc[4:0]          ));\n\n   assign dw_a_enc[5]             =  1'b0;\n   assign dw_b_enc[5]             =  1'b0;\n\n\n   assign dw_shortq_raw[6:0]      =  {1'b0,dw_b_enc[5:0]} - {1'b0,dw_a_enc[5:0]} + 7'd1;\n   assign shortq[5:0]             =  dw_shortq_raw[6]  ?  6'd0  :  dw_shortq_raw[5:0];\n\n   assign shortq_enable           =  valid_ff & ~shortq[5] & ~(shortq[4:2] ==  3'b111) & ~cancel;\n\n   assign shortq_decode[4:0]      = ( {5{shortq[4:0] == 5'd31}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd30}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd29}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd28}} & 5'd00) |\n                                    ( {5{shortq[4:0] == 5'd27}} & 5'd04) |\n                                    ( {5{shortq[4:0] == 5'd26}} & 5'd04) |\n                                    ( {5{shortq[4:0] == 5'd25}} & 5'd04) |\n                                    ( {5{shortq[4:0] == 5'd24}} & 5'd04) |\n                                    ( {5{shortq[4:0] == 5'd23}} & 5'd08) |\n                                    ( {5{shortq[4:0] == 5'd22}} & 5'd08) |\n                                    ( {5{shortq[4:0] == 5'd21}} & 5'd08) |\n                                    ( {5{shortq[4:0] == 5'd20}} & 5'd08) |\n                                    ( {5{shortq[4:0] == 5'd19}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd18}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd17}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd16}} & 5'd12) |\n                                    ( {5{shortq[4:0] == 5'd15}} & 5'd16) |\n                                    ( {5{shortq[4:0] == 5'd14}} & 5'd16) |\n                                    ( {5{shortq[4:0] == 5'd13}} & 5'd16) |\n                                    ( {5{shortq[4:0] == 5'd12}} & 5'd16) |\n                                    ( {5{shortq[4:0] == 5'd11}} & 5'd20) |\n                                    ( {5{shortq[4:0] == 5'd10}} & 5'd20) |\n                                    ( {5{shortq[4:0] == 5'd09}} & 5'd20) |\n                                    ( {5{shortq[4:0] == 5'd08}} & 5'd20) |\n                                    ( {5{shortq[4:0] == 5'd07}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd06}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd05}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd04}} & 5'd24) |\n                                    ( {5{shortq[4:0] == 5'd03}} & 5'd24) |  // Using 28 will violate the minimum latency required\n                                    ( {5{shortq[4:0] == 5'd02}} & 5'd24) |  // Using 28 will violate the minimum latency required\n                                    ( {5{shortq[4:0] == 5'd01}} & 5'd24) |  // Using 28 will violate the minimum latency required\n                                    ( {5{shortq[4:0] == 5'd00}} & 5'd24);   // Using 28 will violate the minimum latency required\n\n\n   assign shortq_shift[4:0]       = ~shortq_enable     ?  5'd0  :  shortq_decode[4:0];\n\n   // *** *** *** End   : Short Q }}\n\n\n\n\n\nendmodule // eh2_exu_div_new_4bit_fullshortq\n\n\n\n\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *\nmodule eh2_exu_div_cls\n  (\n   input  logic [32:0] operand,\n\n   output logic [4:0]  cls                  "}
{"text": "// Count leading sign bits - \"n\" format ignoring [32]\n   );\n\n\n   logic [4:0]   cls_zeros;\n   logic [4:0]   cls_ones;\n\n\nassign cls_zeros[4:0]             = ({5{operand[31]    ==  {           1'b1} }} & 5'd00) |\n                                    ({5{operand[31:30] ==  {{ 1{1'b0}},1'b1} }} & 5'd01) |\n                                    ({5{operand[31:29] ==  {{ 2{1'b0}},1'b1} }} & 5'd02) |\n                                    ({5{operand[31:28] ==  {{ 3{1'b0}},1'b1} }} & 5'd03) |\n                                    ({5{operand[31:27] ==  {{ 4{1'b0}},1'b1} }} & 5'd04) |\n                                    ({5{operand[31:26] ==  {{ 5{1'b0}},1'b1} }} & 5'd05) |\n                                    ({5{operand[31:25] ==  {{ 6{1'b0}},1'b1} }} & 5'd06) |\n                                    ({5{operand[31:24] ==  {{ 7{1'b0}},1'b1} }} & 5'd07) |\n                                    ({5{operand[31:23] ==  {{ 8{1'b0}},1'b1} }} & 5'd08) |\n                                    ({5{operand[31:22] ==  {{ 9{1'b0}},1'b1} }} & 5'd09) |\n                                    ({5{operand[31:21] ==  {{10{1'b0}},1'b1} }} & 5'd10) |\n                                    ({5{operand[31:20] ==  {{11{1'b0}},1'b1} }} & 5'd11) |\n                                    ({5{operand[31:19] ==  {{12{1'b0}},1'b1} }} & 5'd12) |\n                                    ({5{operand[31:18] ==  {{13{1'b0}},1'b1} }} & 5'd13) |\n                                    ({5{operand[31:17] ==  {{14{1'b0}},1'b1} }} & 5'd14) |\n                                    ({5{operand[31:16] ==  {{15{1'b0}},1'b1} }} & 5'd15) |\n                                    ({5{operand[31:15] ==  {{16{1'b0}},1'b1} }} & 5'd16) |\n                                    ({5{operand[31:14] ==  {{17{1'b0}},1'b1} }} & 5'd17) |\n                                    ({5{operand[31:13] ==  {{18{1'b0}},1'b1} }} & 5'd18) |\n                                    ({5{operand[31:12] ==  {{19{1'b0}},1'b1} }} & 5'd19) |\n                                    ({5{operand[31:11] ==  {{20{1'b0}},1'b1} }} & 5'd20) |\n                                    ({5{operand[31:10] ==  {{21{1'b0}},1'b1} }} & 5'd21) |\n                                    ({5{operand[31:09] ==  {{22{1'b0}},1'b1} }} & 5'd22) |\n                                    ({5{operand[31:08] ==  {{23{1'b0}},1'b1} }} & 5'd23) |\n                                    ({5{operand[31:07] ==  {{24{1'b0}},1'b1} }} & 5'd24) |\n                                    ({5{operand[31:06] ==  {{25{1'b0}},1'b1} }} & 5'd25) |\n                                    ({5{operand[31:05] ==  {{26{1'b0}},1'b1} }} & 5'd26) |\n                                    ({5{operand[31:04] ==  {{27{1'b0}},1'b1} }} & 5'd27) |\n                                    ({5{operand[31:03] ==  {{28{1'b0}},1'b1} }} & 5'd28) |\n                                    ({5{operand[31:02] ==  {{29{1'b0}},1'b1} }} & 5'd29) |\n                                    ({5{operand[31:01] ==  {{30{1'b0}},1'b1} }} & 5'd30) |\n                                    ({5{operand[31:00] ==  {{31{1'b0}},1'b1} }} & 5'd31) |\n                                    ({5{operand[31:00] ==  {{32{1'b0}}     } }} & 5'd00);    // Don't care case as it will be handled as special case\n\n\nassign cls_ones[4:0]              = ({5{operand[31:30] ==  {{ 1{1'b1}},1'b0} }} & 5'd00) |\n                                    ({5{operand[31:29] ==  {{ 2{1'b1}},1'b0} }} & 5'd01) |\n                                    ({5{operand[31:28] ==  {{ 3{1'b1}},1'b0} }} & 5'd02) |\n                                    ({5{operand[31:27] ==  {{ 4{1'b1}},1'b0} }} & 5'd03) |\n                                    ({5{operand[31:26] ==  {{ 5{1'b1}},1'b0} }} & 5'd04) |\n                                    ({5{operand[31:25] ==  {{ 6{1'b1}},1'b0} }} & 5'd05) |\n                                    ({5{operand[31:24] ==  {{ 7{1'b1}},1'b0} }} & 5'd06) |\n                                    ({5{operand[31:23] ==  {{ 8{1'b1}},1'b0} }} & 5'd07) |\n                                    ({5{operand[31:22] ==  {{ 9{1'b1}},1'b0} }} & 5'd08) |\n                                    ({5{operand[31:21] ==  {{10{1'b1}},1'b0} }} & 5'd09) |\n                                    ({5{operand[31:20] ==  {{11{1'b1}},1'b0} }} & 5'd10) |\n                                    ({5{operand[31:19] ==  {{12{1'b1}},1'b0} }} & 5'd11) |\n                                    ({5{operand[31:18] ==  {{13{1'b1}},1'b0} }} & 5'd12) |\n                                    ({5{operand[31:17] ==  {{14{1'b1}},1'b0} }} & 5'd13) |\n                                    ({5{operand[31:16] ==  {{15{1'b1}},1'b0} }} & 5'd14) |\n                                    ({5{operand[31:15] ==  {{16{1'b1}},1'b0} }} & 5'd15) |\n                                    ({5{operand[31:14] ==  {{17{1'b1}},1'b0} }} & 5'd16) |\n                                    ({5{operand[31:13] ==  {{18{1'b1}},1'b0} }} & 5'd17) |\n                                    ({5{operand[31:12] ==  {{19{1'b1}},1'b0} }} & 5'd18) |\n                                    ({5{operand[31:11] ==  {{20{1'b1}},1'b0} }} & 5'd19) |\n                                    ({5{operand[31:10] ==  {{21{1'b1}},1'b0} }} & 5'd20) |\n                                    ({5{operand[31:09] ==  {{22{1'b1}},1'b0} }} & 5'd21) |\n                                    ({5{operand[31:08] ==  {{23{1'b1}},1'b0} }} & 5'd22) |\n                                    ({5{operand[31:07] ==  {{24{1'b1}},1'b0} }} & 5'd23) |\n                                    ({5{operand[31:06] ==  {{25{1'b1}},1'b0} }} & 5'd24) |\n                                    ({5{operand[31:05] ==  {{26{1'b1}},1'b0} }} & 5'd25) |\n                                    ({5{operand[31:04] ==  {{27{1'b1}},1'b0} }} & 5'd26) |\n                                    ({5{operand[31:03] ==  {{28{1'b1}},1'b0} }} & 5'd27) |\n                                    ({5{operand[31:02] ==  {{29{1'b1}},1'b0} }} & 5'd28) |\n                                    ({5{operand[31:01] ==  {{30{1'b1}},1'b0} }} & 5'd29) |\n                                    ({5{operand[31:00] ==  {{31{1'b1}},1'b0} }} & 5'd30) |\n                                    ({5{operand[31:00] ==  {{32{1'b1}}     } }} & 5'd31);\n\n\nassign cls[4:0]                   =  operand[32]  ?  cls_ones[4:0]  :  cls_zeros[4:0];\n\nendmodule // eh2_exu_div_cls\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n\nmodule eh2_exu_mul_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n   input logic          clk,              // Top level clock\n   input logic          clk_override,     // Override clock enables\n   input logic          rst_l,            // Reset\n   input logic          scan_mode,        // Scan mode\n\n   input logic [31:0]   a,                // A operand\n   input logic [31:0]   b,                // B operand\n\n   input logic [31:0]   lsu_result_dc3,   // Load result used in E1 bypass\n\n   input eh2_mul_pkt_t mp,               // valid, rs1_sign, rs2_sign, low, load_mul_rs1_bypass_e1, load_mul_rs2_bypass_e1, bitmanip controls\n\n\n   output logic [31:0]  out               // Result\n\n   );\n\n\n   eh2_mul_pkt_t       mp_e1, mp_e2;\n   logic                valid_e1, valid_e2;\n   logic                mul_c1_e1_clken,   mul_c1_e2_clken,   mul_c1_e3_clken;\n   logic                exu_mul_c1_e1_clk, exu_mul_c1_e2_clk, exu_mul_c1_e3_clk;\n\n   logic        [31:0]  a_ff_e1, a_e1;\n   logic        [31:0]  b_ff_e1, b_e1;\n   logic                rs1_sign_e1, rs1_neg_e1;\n   logic                rs2_sign_e1, rs2_neg_e1;\n   logic signed [32:0]  a_ff_e2, b_ff_e2;\n   logic        [63:0]  prod_e3;\n   logic                low_e2, low_e3;\n\n\n   // *** Start - BitManip ***\n\n   logic                bitmanip_sel_e2;\n   logic                bitmanip_sel_e3;\n   logic        [31:0]  bitmanip_e2;\n   logic        [31:0]  bitmanip_e3;\n\n\n   // ZBE\n   logic                ap_bcompress_e2;\n   logic                ap_bdecompress_e2;\n\n   // ZBC\n   logic                ap_clmul_e2;\n   logic                ap_clmulh_e2;\n   logic                ap_clmulr_e2;\n\n   // ZBP\n   logic                ap_grev_e2;\n   logic                ap_gorc_e2;\n   logic                ap_shfl_e2;\n   logic                ap_unshfl_e2;\n   logic                ap_xperm_n_e2;\n   logic                ap_xperm_b_e2;\n   logic                ap_xperm_h_e2;\n\n   // ZBR\n   logic                ap_crc32_b_e2;\n   logic                ap_crc32_h_e2;\n   logic                ap_crc32_w_e2;\n   logic                ap_crc32c_b_e2;\n   logic                ap_crc32c_h_e2;\n   logic                ap_crc32c_w_e2;\n\n   // ZBF\n   logic                ap_bfp_e2;\n\n\n   if (pt.BITMANIP_ZBE == 1)\n     begin\n       assign ap_bcompress_e2   =  mp_e2.bcompress;\n       assign ap_bdecompress_e2 =  mp_e2.bdecompress;\n     end\n   else\n     begin\n       assign ap_bcompress_e2   =  1'b0;\n       assign ap_bdecompress_e2 =  1'b0;\n     end\n\n   if (pt.BITMANIP_ZBC == 1)\n     begin\n       assign ap_clmul_e2     =  mp_e2.clmul;\n       assign ap_clmulh_e2    =  mp_e2.clmulh;\n       assign ap_clmulr_e2    =  mp_e2.clmulr;\n     end\n   else\n     begin\n       assign ap_clmul_e2     =  1'b0;\n       assign ap_clmulh_e2    =  1'b0;\n       assign ap_clmulr_e2    =  1'b0;\n     end\n\n   if (pt.BITMANIP_ZBP == 1)\n     begin\n       assign ap_grev_e2      =  mp_e2.grev;\n       assign ap_gorc_e2      =  mp_e2.gorc;\n       assign ap_shfl_e2      =  mp_e2.shfl;\n       assign ap_unshfl_e2    =  mp_e2.unshfl;\n       assign ap_xperm_n_e2   =  mp_e2.xperm_n;\n       assign ap_xperm_b_e2   =  mp_e2.xperm_b;\n       assign ap_xperm_h_e2   =  mp_e2.xperm_h;\n     end\n   else\n     begin\n       assign ap_grev_e2      =  1'b0;\n       assign ap_gorc_e2      =  1'b0;\n       assign ap_shfl_e2      =  1'b0;\n       assign ap_unshfl_e2    =  1'b0;\n       assign ap_xperm_n_e2   =  1'b0;\n       assign ap_xperm_b_e2   =  1'b0;\n       assign ap_xperm_h_e2   =  1'b0;\n     end\n\n   if (pt.BITMANIP_ZBR == 1)\n     begin\n       assign ap_crc32_b_e2   =  mp_e2.crc32_b;\n       assign ap_crc32_h_e2   =  mp_e2.crc32_h;\n       assign ap_crc32_w_e2   =  mp_e2.crc32_w;\n       assign ap_crc32c_b_e2  =  mp_e2.crc32c_b;\n       assign ap_crc32c_h_e2  =  mp_e2.crc32c_h;\n       assign ap_crc32c_w_e2  =  mp_e2.crc32c_w;\n     end\n   else\n     begin\n       assign ap_crc32_b_e2   =  1'b0;\n       assign ap_crc32_h_e2   =  1'b0;\n       assign ap_crc32_w_e2   =  1'b0;\n       assign ap_crc32c_b_e2  =  1'b0;\n       assign ap_crc32c_h_e2  =  1'b0;\n       assign ap_crc32c_w_e2  =  1'b0;\n     end\n\n   if (pt.BITMANIP_ZBF == 1)\n     begin\n       assign ap_bfp_e2       =  mp_e2.bfp;\n     end\n   else\n     begin\n       assign ap_bfp_e2       =  1'b0;\n     end\n\n\n   // *** End   - BitManip ***\n\n\n\n   // --------------------------- Clock gating   ----------------------------------\n\n   // C1 clock enables\n   assign mul_c1_e1_clken        = (mp.valid | clk_override);\n   assign mul_c1_e2_clken        = (valid_e1 | clk_override);\n   assign mul_c1_e3_clken        = (valid_e2 | clk_override);\n\n   // C1 - 1 clock pulse for data\n   rvoclkhdr exu_mul_c1e1_cgc    (.*, .en(mul_c1_e1_clken),   .l1clk(exu_mul_c1_e1_clk));\n   rvoclkhdr exu_mul_c1e2_cgc    (.*, .en(mul_c1_e2_clken),   .l1clk(exu_mul_c1_e2_clk));\n   rvoclkhdr exu_mul_c1e3_cgc    (.*, .en(mul_c1_e3_clken),   .l1clk(exu_mul_c1_e3_clk));\n\n\n   // --------------------------- Input flops    ----------------------------------\n\n   rvdffie #(2,1)                   valid_ff      (.*, .din({mp.valid,valid_e1}),       .dout({valid_e1,valid_e2}),  .clk(clk));\n   rvdff  #($bits(eh2_mul_pkt_t))  mp_e1_ff      (.*, .din(mp),                        .dout(mp_e1),                .clk(exu_mul_c1_e1_clk));\n   rvdff  #(32)                     a_e1_ff       (.*, .din(a[31:0]),                   .dout(a_ff_e1[31:0]),        .clk(exu_mul_c1_e1_clk));\n   rvdff  #(32)                     b_e1_ff       (.*, .din(b[31:0]),                   .dout(b_ff_e1[31:0]),        .clk(exu_mul_c1_e1_clk));\n\n\n   // --------------------------- E1 Logic Stage ----------------------------------\n\n   assign rs1_sign_e1            =  mp_e1.rs1_sign;\n   assign rs2_sign_e1            =  mp_e1.rs2_sign;\n\n   assign a_e1[31:0]             = (mp_e1.load_mul_rs1_bypass_e1)  ?  lsu_result_dc3[31:0]  :  a_ff_e1[31:0];\n   assign b_e1[31:0]             = (mp_e1.load_mul_rs2_bypass_e1)  ?  lsu_result_dc3[31:0]  :  b_ff_e1[31:0];\n\n   assign rs1_neg_e1             =  rs1_sign_e1 & a_e1[31];\n   assign rs2_neg_e1             =  rs2_sign_e1 & b_e1[31];\n\n\n   rvdff  #($bits(eh2_mul_pkt_t))  mp_e2_ff      (.*, .din(mp_e1),                     .dout(mp_e2),             .clk(exu_mul_c1_e2_clk));\n\n   rvdff  #(33)                     a_e2_ff       (.*, .din({rs1_neg_e1, a_e1[31:0]}),  .dout(a_ff_e2[32:0]),     .clk(exu_mul_c1_e2_clk));\n   rvdff  #(33)                     b_e2_ff       (.*, .din({rs2_neg_e1, b_e1[31:0]}),  .dout(b_ff_e2[32:0]),     .clk(exu_mul_c1_e2_clk));\n\n\n   logic signed [65:0]  prod_e2;\n\n   assign prod_e2[65:0]          =  a_ff_e2  *  b_ff_e2;\n\n\n   rvdff  #(1)                      low_e3_ff     (.*, .din(mp_e2.low),                 .dout(low_e3),            .clk(exu_mul_c1_e3_clk));\n   rvdff  #(64)                     prod_e3_ff    (.*, .din(prod_e2[63:0]),             .dout(prod_e3[63:0]),     .clk(exu_mul_c1_e3_clk));\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  BCOMPRESS, BDECOMPRESS * * * * * * * * * * * * *\n\n\n   // *** BCOMPRESS == \"gather\"  ***\n\n   logic        [31:0]    bcompress_e2;\n   logic                  bcompress_test_bit_e2;\n   integer                bcompress_i, bcompress_j;\n\n\n   always_comb\n     begin\n\n       bcompress_j                      =      0;\n       bcompress_test_bit_e2            =   1'b0;\n       bcompress_e2[31:0]               =  32'b0;\n\n       for (bcompress_i=0; bcompress_i<32; bcompress_i++)\n         begin\n             bcompress_test_bit_e2      =  b_ff_e2[bcompress_i];\n             if (bcompress_test_bit_e2)\n               begin\n                  bcompress_e2[bcompress_j]  =  a_ff_e2[bcompress_i];\n                  bcompress_j           =  bcompress_j + 1;\n               end  // IF  bcompress_test_bit\n         end        // FOR bcompress_i\n     end            // ALWAYS_COMB\n\n\n\n   // *** BDECOMPRESS == \"scatter\" ***\n\n   logic        [31:0]    bdecompress_e2;\n   logic                  bdecompress_test_bit_e2;\n   integer                bdecompress_i, bdecompress_j;\n\n\n   always_comb\n     begin\n\n       bdecompress_j                      =      0;\n       bdecompress_test_bit_e2            =   1'b0;\n       bdecompress_e2[31:0]               =  32'b0;\n\n       for (bdecompress_i=0; bdecompress_i<32; bdecompress_i++)\n         begin\n             bdecompress_test_bit_e2      =  b_ff_e2[bdecompress_i];\n             if (bdecompress_test_bit_e2)\n               begin\n                  bdecompress_e2[bdecompress_i]  =  a_ff_e2[bdecompress_j];\n                  bdecompress_j           =  bdecompress_j + 1;\n               end  // IF  bdecompress_test_bit\n         end        // FOR bdecompress_i\n     end            // ALWAYS_COMB\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  CLMUL, CLMULH, CLMULR  * * * * * * * * * * * * *\n\n   logic        [62:0]    clmul_raw_e2;\n\n\n   assign clmul_raw_e2[62:0]     = ( {63{b_ff_e2[00]}} & {31'b0,a_ff_e2[31:0]      } ) ^\n                                   ( {63{b_ff_e2[01]}} & {30'b0,a_ff_e2[31:0], 1'b0} ) ^\n                                   ( {63{b_ff_e2[02]}} & {29'b0,a_ff_e2[31:0], 2'b0} ) ^\n                                   ( {63{b_ff_e2[03]}} & {28'b0,a_ff_e2[31:0], 3'b0} ) ^\n                                   ( {63{b_ff_e2[04]}} & {27'b0,a_ff_e2[31:0], 4'b0} ) ^\n                                   ( {63{b_ff_e2[05]}} & {26'b0,a_ff_e2[31:0], 5'b0} ) ^\n                                   ( {63{b_ff_e2[06]}} & {25'b0,a_ff_e2[31:0], 6'b0} ) ^\n                                   ( {63{b_ff_e2[07]}} & {24'b0,a_ff_e2[31:0], 7'b0} ) ^\n                                   ( {63{b_ff_e2[08]}} & {23'b0,a_ff_e2[31:0], 8'b0} ) ^\n                                   ( {63{b_ff_e2[09]}} & {22'b0,a_ff_e2[31:0], 9'b0} ) ^\n                                   ( {63{b_ff_e2[10]}} & {21'b0,a_ff_e2[31:0],10'b0} ) ^\n                                   ( {63{b_ff_e2[11]}} & {20'b0,a_ff_e2[31:0],11'b0} ) ^\n                                   ( {63{b_ff_e2[12]}} & {19'b0,a_ff_e2[31:0],12'b0} ) ^\n                                   ( {63{b_ff_e2[13]}} & {18'b0,a_ff_e2[31:0],13'b0} ) ^\n                                   ( {63{b_ff_e2[14]}} & {17'b0,a_ff_e2[31:0],14'b0} ) ^\n                                   ( {63{b_ff_e2[15]}} & {16'b0,a_ff_e2[31:0],15'b0} ) ^\n                                   ( {63{b_ff_e2[16]}} & {15'b0,a_ff_e2[31:0],16'b0} ) ^\n                                   ( {63{b_ff_e2[17]}} & {14'b0,a_ff_e2[31:0],17'b0} ) ^\n                                   ( {63{b_ff_e2[18]}} & {13'b0,a_ff_e2[31:0],18'b0} ) ^\n                                   ( {63{b_ff_e2[19]}} & {12'b0,a_ff_e2[31:0],19'b0} ) ^\n                                   ( {63{b_ff_e2[20]}} & {11'b0,a_ff_e2[31:0],20'b0} ) ^\n                                   ( {63{b_ff_e2[21]}} & {10'b0,a_ff_e2[31:0],21'b0} ) ^\n                                   ( {63{b_ff_e2[22]}} & { 9'b0,a_ff_e2[31:0],22'b0} ) ^\n                                   ( {63{b_ff_e2[23]}} & { 8'b0,a_ff_e2[31:0],23'b0} ) ^\n                                   ( {63{b_ff_e2[24]}} & { 7'b0,a_ff_e2[31:0],24'b0} ) ^\n                                   ( {63{b_ff_e2[25]}} & { 6'b0,a_ff_e2[31:0],25'b0} ) ^\n                                   ( {63{b_ff_e2[26]}} & { 5'b0,a_ff_e2[31:0],26'b0} ) ^\n                                   ( {63{b_ff_e2[27]}} & { 4'b0,a_ff_e2[31:0],27'b0} ) ^\n                                   ( {63{b_ff_e2[28]}} & { 3'b0,a_ff_e2[31:0],28'b0} ) ^\n                                   ( {63{b_ff_e2[29]}} & { 2'b0,a_ff_e2[31:0],29'b0} ) ^\n                                   ( {63{b_ff_e2[30]}} & { 1'b0,a_ff_e2[31:0],30'b0} ) ^\n                                   ( {63{b_ff_e2[31]}} & {      a_ff_e2[31:0],31'b0} );\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  GREV         * * * * * * * * * * * * * * * * * *\n\n   // uint32_t grev32(uint32_t rs1, uint32_t rs2)\n   // {\n   //     uint32_t x = rs1;\n   //     int shamt = rs2 & 31;\n   //\n   //     if (shamt &  1)  x = ( (x & 0x55555555) <<  1) | ( (x & 0xAAAAAAAA) >>  1);\n   //     if (shamt &  2)  x = ( (x & 0x33333333) <<  2) | ( (x & 0xCCCCCCCC) >>  2);\n   //     if (shamt &  4)  x = ( (x & 0x0F0F0F0F) <<  4) | ( (x & 0xF0F0F0F0) >>  4);\n   //     if (shamt &  8)  x = ( (x & 0x00FF00FF) <<  8) | ( (x & 0xFF00FF00) >>  8);\n   //     if (shamt & 16)  x = ( (x & 0x0000FFFF) << 16) | ( (x & 0xFFFF0000) >> 16);\n   //\n   //     return x;\n   //  }\n\n\n   logic        [31:0]    grev1_e2;\n   logic        [31:0]    grev2_e2;\n   logic        [31:0]    grev4_e2;\n   logic        [31:0]    grev8_e2;\n   logic        [31:0]    grev_e2;\n\n\n   assign grev1_e2[31:0]      = (b_ff_e2[0])  ?  {a_ff_e2[30],a_ff_e2[31],a_ff_e2[28],a_ff_e2[29],a_ff_e2[26],a_ff_e2[27],a_ff_e2[24],a_ff_e2[25],\n                                                  a_ff_e2[22],a_ff_e2[23],a_ff_e2[20],a_ff_e2[21],a_ff_e2[18],a_ff_e2[19],a_ff_e2[16],a_ff_e2[17],\n                                                  a_ff_e2[14],a_ff_e2[15],a_ff_e2[12],a_ff_e2[13],a_ff_e2[10],a_ff_e2[11],a_ff_e2[08],a_ff_e2[09],\n                                                  a_ff_e2[06],a_ff_e2[07],a_ff_e2[04],a_ff_e2[05],a_ff_e2[02],a_ff_e2[03],a_ff_e2[00],a_ff_e2[01]}  :  a_ff_e2[31:0];\n\n   assign grev2_e2[31:0]      = (b_ff_e2[1])  ?  {grev1_e2[29:28],grev1_e2[31:30],grev1_e2[25:24],grev1_e2[27:26],\n                                                  grev1_e2[21:20],grev1_e2[23:22],grev1_e2[17:16],grev1_e2[19:18],\n                                                  grev1_e2[13:12],grev1_e2[15:14],grev1_e2[09:08],grev1_e2[11:10],\n                                                  grev1_e2[05:04],grev1_e2[07:06],grev1_e2[01:00],grev1_e2[03:02]}  :  grev1_e2[31:0];\n\n   assign grev4_e2[31:0]      = (b_ff_e2[2])  ?  {grev2_e2[27:24],grev2_e2[31:28],grev2_e2[19:16],grev2_e2[23:20],\n                                                  grev2_e2[11:08],grev2_e2[15:12],grev2_e2[03:00],grev2_e2[07:04]}  :  grev2_e2[31:0];\n\n   assign grev8_e2[31:0]      = (b_ff_e2[3])  ?  {grev4_e2[23:16],grev4_e2[31:24],grev4_e2[07:00],grev4_e2[15:08]}  :  grev4_e2[31:0];\n\n   assign grev_e2[31:0]       = (b_ff_e2[4])  ?  {grev8_e2[15:00],grev8_e2[31:16]}  :  grev8_e2[31:0];\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  GORC         * * * * * * * * * * * * * * * * * *\n\n   // uint32_t gorc32(uint32_t rs1, uint32_t rs2)\n   // {\n   //     uint32_t x = rs1;\n   //     int shamt = rs2 & 31;\n   //\n   //     if (shamt &  1)  x |= ( (x & 0x55555555) <<  1) | ( (x & 0xAAAAAAAA) >>  1);\n   //     if (shamt &  2)  x |= ( (x & 0x33333333) <<  2) | ( (x & 0xCCCCCCCC) >>  2);\n   //     if (shamt &  4)  x |= ( (x & 0x0F0F0F0F) <<  4) | ( (x & 0xF0F0F0F0) >>  4);\n   //     if (shamt &  8)  x |= ( (x & 0x00FF00FF) <<  8) | ( (x & 0xFF00FF00) >>  8);\n   //     if (shamt & 16)  x |= ( (x & 0x0000FFFF) << 16) | ( (x & 0xFFFF0000) >> 16);\n   //\n   //     return x;\n   //  }\n\n\n   logic        [31:0]    gorc1_e2;\n   logic        [31:0]    gorc2_e2;\n   logic        [31:0]    gorc4_e2;\n   logic        [31:0]    gorc8_e2;\n   logic        [31:0]    gorc_e2;\n\n\n   assign gorc1_e2[31:0]      = ( {32{b_ff_e2[0]}} & {a_ff_e2[30],a_ff_e2[31],a_ff_e2[28],a_ff_e2[29],a_ff_e2[26],a_ff_e2[27],a_ff_e2[24],a_ff_e2[25],\n                                                      a_ff_e2[22],a_ff_e2[23],a_ff_e2[20],a_ff_e2[21],a_ff_e2[18],a_ff_e2[19],a_ff_e2[16],a_ff_e2[17],\n                                                      a_ff_e2[14],a_ff_e2[15],a_ff_e2[12],a_ff_e2[13],a_ff_e2[10],a_ff_e2[11],a_ff_e2[08],a_ff_e2[09],\n                                                      a_ff_e2[06],a_ff_e2[07],a_ff_e2[04],a_ff_e2[05],a_ff_e2[02],a_ff_e2[03],a_ff_e2[00],a_ff_e2[01]} ) | a_ff_e2[31:0];\n\n   assign gorc2_e2[31:0]      = ( {32{b_ff_e2[1]}} & {gorc1_e2[29:28],gorc1_e2[31:30],gorc1_e2[25:24],gorc1_e2[27:26],\n                                                      gorc1_e2[21:20],gorc1_e2[23:22],gorc1_e2[17:16],gorc1_e2[19:18],\n                                                      gorc1_e2[13:12],gorc1_e2[15:14],gorc1_e2[09:08],gorc1_e2[11:10],\n                                                      gorc1_e2[05:04],gorc1_e2[07:06],gorc1_e2[01:00],gorc1_e2[03:02]} ) | gorc1_e2[31:0];\n\n   assign gorc4_e2[31:0]      = ( {32{b_ff_e2[2]}} & {gorc2_e2[27:24],gorc2_e2[31:28],gorc2_e2[19:16],gorc2_e2[23:20],\n                                                      gorc2_e2[11:08],gorc2_e2[15:12],gorc2_e2[03:00],gorc2_e2[07:04]} ) | gorc2_e2[31:0];\n\n   assign gorc8_e2[31:0]      = ( {32{b_ff_e2[3]}} & {gorc4_e2[23:16],gorc4_e2[31:24],gorc4_e2[07:00],gorc4_e2[15:08]} ) | gorc4_e2[31:0];\n\n   assign gorc_e2[31:0]       = ( {32{b_ff_e2[4]}} & {gorc8_e2[15:00],gorc8_e2[31:16]} ) | gorc8_e2[31:0];\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  SHFL, UNSHLF * * * * * * * * * * * * * * * * * *\n\n   // uint32_t shuffle32_stage (uint32_t src, uint32_t maskL, uint32_t maskR, int N)\n   // {\n   //     uint32_t x  = src & ~(maskL | maskR);\n   //     x          |= ((src << N) & maskL) | ((src >> N) & maskR);\n   //     return x;\n   // }\n   //\n   //\n   //\n   // uint32_t shfl32(uint32_t rs1, uint32_t rs2)\n   // {\n   //     uint32_t x = rs1;\n   //     int shamt = rs2 & 15\n   //\n   //     if (shamt & 8)  x = shuffle32_stage(x, 0x00ff0000, 0x0000ff00, 8);\n   //     if (shamt & 4)  x = shuffle32_stage(x, 0x0f000f00, 0x00f000f0, 4);\n   //     if (shamt & 2)  x = shuffle32_stage(x, 0x30303030, 0xc0c0c0c0, 2);\n   //     if (shamt & 1)  x = shuffle32_stage(x, 0x44444444, 0x22222222, 1);\n   //\n   //     return x;\n   // }\n\n\n   logic        [31:0]    shfl8_e2;\n   logic        [31:0]    shfl4_e2;\n   logic        [31:0]    shfl2_e2;\n   logic        [31:0]    shfl_e2;\n\n\n\n   assign shfl8_e2[31:0]      = (b_ff_e2[3])  ?  {a_ff_e2[31:24],a_ff_e2[15:08],a_ff_e2[23:16],a_ff_e2[07:00]}      :  a_ff_e2[31:0];\n\n   assign shfl4_e2[31:0]      = (b_ff_e2[2])  ?  {shfl8_e2[31:28],shfl8_e2[23:20],shfl8_e2[27:24],shfl8_e2[19:16],\n                                                  shfl8_e2[15:12],shfl8_e2[07:04],shfl8_e2[11:08],shfl8_e2[03:00]}  :  shfl8_e2[31:0];\n\n   assign shfl2_e2[31:0]      = (b_ff_e2[1])  ?  {shfl4_e2[31:30],shfl4_e2[27:26],shfl4_e2[29:28],shfl4_e2[25:24],\n                                                  shfl4_e2[23:22],shfl4_e2[19:18],shfl4_e2[21:20],shfl4_e2[17:16],\n                                                  shfl4_e2[15:14],shfl4_e2[11:10],shfl4_e2[13:12],shfl4_e2[09:08],\n                                                  shfl4_e2[07:06],shfl4_e2[03:02],shfl4_e2[05:04],shfl4_e2[01:00]}  :  shfl4_e2[31:0];\n\n   assign shfl_e2[31:0]       = (b_ff_e2[0])  ?  {shfl2_e2[31],shfl2_e2[29],shfl2_e2[30],shfl2_e2[28],shfl2_e2[27],shfl2_e2[25],shfl2_e2[26],shfl2_e2[24],\n                                                  shfl2_e2[23],shfl2_e2[21],shfl2_e2[22],shfl2_e2[20],shfl2_e2[19],shfl2_e2[17],shfl2_e2[18],shfl2_e2[16],\n                                                  shfl2_e2[15],shfl2_e2[13],shfl2_e2[14],shfl2_e2[12],shfl2_e2[11],shfl2_e2[09],shfl2_e2[10],shfl2_e2[08],\n                                                  shfl2_e2[07],shfl2_e2[05],shfl2_e2[06],shfl2_e2[04],shfl2_e2[03],shfl2_e2[01],shfl2_e2[02],shfl2_e2[00]}  :  shfl2_e2[31:0];\n\n\n\n\n   // uint32_t unshfl32(uint32_t rs1, uint32_t rs2)\n   // {\n   //     uint32_t x = rs1;\n   //     int shamt = rs2 & 15\n   //\n   //     if (shamt & 1)  x = shuffle32_stage(x, 0x44444444, 0x22222222, 1);\n   //     if (shamt & 2)  x = shuffle"}
{"text": "32_stage(x, 0x30303030, 0xc0c0c0c0, 2);\n   //     if (shamt & 4)  x = shuffle32_stage(x, 0x0f000f00, 0x00f000f0, 4);\n   //     if (shamt & 8)  x = shuffle32_stage(x, 0x00ff0000, 0x0000ff00, 8);\n   //\n   //     return x;\n   // }\n\n\n   logic        [31:0]    unshfl1_e2;\n   logic        [31:0]    unshfl2_e2;\n   logic        [31:0]    unshfl4_e2;\n   logic        [31:0]    unshfl_e2;\n\n\n   assign unshfl1_e2[31:0]    = (b_ff_e2[0])  ?  {a_ff_e2[31],a_ff_e2[29],a_ff_e2[30],a_ff_e2[28],a_ff_e2[27],a_ff_e2[25],a_ff_e2[26],a_ff_e2[24],\n                                                  a_ff_e2[23],a_ff_e2[21],a_ff_e2[22],a_ff_e2[20],a_ff_e2[19],a_ff_e2[17],a_ff_e2[18],a_ff_e2[16],\n                                                  a_ff_e2[15],a_ff_e2[13],a_ff_e2[14],a_ff_e2[12],a_ff_e2[11],a_ff_e2[09],a_ff_e2[10],a_ff_e2[08],\n                                                  a_ff_e2[07],a_ff_e2[05],a_ff_e2[06],a_ff_e2[04],a_ff_e2[03],a_ff_e2[01],a_ff_e2[02],a_ff_e2[00]}  :  a_ff_e2[31:0];\n\n   assign unshfl2_e2[31:0]    = (b_ff_e2[1])  ?  {unshfl1_e2[31:30],unshfl1_e2[27:26],unshfl1_e2[29:28],unshfl1_e2[25:24],\n                                                  unshfl1_e2[23:22],unshfl1_e2[19:18],unshfl1_e2[21:20],unshfl1_e2[17:16],\n                                                  unshfl1_e2[15:14],unshfl1_e2[11:10],unshfl1_e2[13:12],unshfl1_e2[09:08],\n                                                  unshfl1_e2[07:06],unshfl1_e2[03:02],unshfl1_e2[05:04],unshfl1_e2[01:00]}  :  unshfl1_e2[31:0];\n\n   assign unshfl4_e2[31:0]    = (b_ff_e2[2])  ?  {unshfl2_e2[31:28],unshfl2_e2[23:20],unshfl2_e2[27:24],unshfl2_e2[19:16],\n                                                  unshfl2_e2[15:12],unshfl2_e2[07:04],unshfl2_e2[11:08],unshfl2_e2[03:00]}  :  unshfl2_e2[31:0];\n\n   assign unshfl_e2[31:0]     = (b_ff_e2[3])  ?  {unshfl4_e2[31:24],unshfl4_e2[15:08],unshfl4_e2[23:16],unshfl4_e2[07:00]}  :  unshfl4_e2[31:0];\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  CRC32, CRC32c  * * * * * * * * * * * * * * * * *\n\n   // ***  computed from   https: //crccalc.com  ***\n   //\n   // \"a\" is 8'h61 = 8'b0110_0001    (8'h61 ^ 8'hff = 8'h9e)\n   //\n   // Input must first be XORed with 32'hffff_ffff\n   //\n   //\n   // CRC32\n   //\n   // Input    Output        Input      Output\n   // -----   --------      --------   --------\n   // \"a\"     e8b7be43      ffffff9e   174841bc\n   // \"aa\"    078a19d7      ffff9e9e   f875e628\n   // \"aaaa\"  ad98e545      9e9e9e9e   5267a1ba\n   //\n   //\n   //\n   // CRC32c\n   //\n   // Input    Output        Input      Output\n   // -----   --------      --------   --------\n   // \"a\"     c1d04330      ffffff9e   3e2fbccf\n   // \"aa\"    f1f2dac2      ffff9e9e   0e0d253d\n   // \"aaaa\"  6a52eeb0      9e9e9e9e   95ad114f\n\n\n   logic                  crc32_all_e2;\n   logic        [31:0]    crc32_poly_rev;\n   logic        [31:0]    crc32c_poly_rev;\n   integer                crc32_bi,   crc32_hi,   crc32_wi,   crc32c_bi,   crc32c_hi,   crc32c_wi;\n   logic        [31:0]    crc32_b_e2, crc32_h_e2, crc32_w_e2, crc32c_b_e2, crc32c_h_e2, crc32c_w_e2;\n\n\n   assign crc32_all_e2           =  ap_crc32_b_e2  | ap_crc32_h_e2  | ap_crc32_w_e2 | ap_crc32c_b_e2 | ap_crc32c_h_e2 | ap_crc32c_w_e2;\n\n   assign crc32_poly_rev[31:0]   =  32'hEDB88320;    // bit reverse of 32'h04C11DB7\n   assign crc32c_poly_rev[31:0]  =  32'h82F63B78;    // bit reverse of 32'h1EDC6F41\n\n\n   always_comb\n     begin\n       crc32_b_e2[31:0]          =  a_ff_e2[31:0];\n\n       for (crc32_bi=0; crc32_bi<8; crc32_bi++)\n         begin\n            crc32_b_e2[31:0]     = (crc32_b_e2[31:0] >> 1) ^ (crc32_poly_rev[31:0] & {32{crc32_b_e2[0]}});\n         end      // FOR    crc32_bi\n     end          // ALWAYS_COMB\n\n\n   always_comb\n     begin\n       crc32_h_e2[31:0]          =  a_ff_e2[31:0];\n\n       for (crc32_hi=0; crc32_hi<16; crc32_hi++)\n         begin\n            crc32_h_e2[31:0]     = (crc32_h_e2[31:0] >> 1) ^ (crc32_poly_rev[31:0] & {32{crc32_h_e2[0]}});\n         end      // FOR    crc32_hi\n     end          // ALWAYS_COMB\n\n\n   always_comb\n     begin\n       crc32_w_e2[31:0]          =  a_ff_e2[31:0];\n\n       for (crc32_wi=0; crc32_wi<32; crc32_wi++)\n         begin\n            crc32_w_e2[31:0]     = (crc32_w_e2[31:0] >> 1) ^ (crc32_poly_rev[31:0] & {32{crc32_w_e2[0]}});\n         end      // FOR    crc32_wi\n     end          // ALWAYS_COMB\n\n\n\n\n   always_comb\n     begin\n       crc32c_b_e2[31:0]         =  a_ff_e2[31:0];\n\n       for (crc32c_bi=0; crc32c_bi<8; crc32c_bi++)\n         begin\n            crc32c_b_e2[31:0]    = (crc32c_b_e2[31:0] >> 1) ^ (crc32c_poly_rev[31:0] & {32{crc32c_b_e2[0]}});\n         end      // FOR    crc32c_bi\n     end          // ALWAYS_COMB\n\n\n   always_comb\n     begin\n       crc32c_h_e2[31:0]         =  a_ff_e2[31:0];\n\n       for (crc32c_hi=0; crc32c_hi<16; crc32c_hi++)\n         begin\n            crc32c_h_e2[31:0]    = (crc32c_h_e2[31:0] >> 1) ^ (crc32c_poly_rev[31:0] & {32{crc32c_h_e2[0]}});\n         end      // FOR    crc32c_hi\n     end          // ALWAYS_COMB\n\n\n   always_comb\n     begin\n       crc32c_w_e2[31:0]         =  a_ff_e2[31:0];\n\n       for (crc32c_wi=0; crc32c_wi<32; crc32c_wi++)\n         begin\n            crc32c_w_e2[31:0]    = (crc32c_w_e2[31:0] >> 1) ^ (crc32c_poly_rev[31:0] & {32{crc32c_w_e2[0]}});\n         end      // FOR    crc32c_wi\n     end          // ALWAYS_COMB\n\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  BFP          * * * * * * * * * * * * * * * * * *\n\n   // uint_xlen_t bfp(uint_xlen_t rs1, uint_xlen_t rs2)\n   // {\n   //    uint_xlen_t cfg = rs2 >> (XLEN/2);\n   //    if ((cfg >> 30) == 2) cfg = cfg >> 16;\n   //    int len          = (cfg >> 8) & (XLEN/2-1);\n   //    int off          = cfg & (XLEN-1);\n   //    len              = len ? len : XLEN/2;\n   //    uint_xlen_t mask = slo(0, len) << off;\n   //    uint_xlen_t data = rs2 << off;\n   //    return (data & mask) | (rs1 & ~mask);\n\n   logic        [4:0]     bfp_len_e2;\n   logic        [4:0]     bfp_off_e2;\n   logic        [31:0]    bfp_len_mask_e2_;\n   logic        [31:0]    bfp_off_mask_e2_;\n   logic        [15:0]    bfp_preshift_data_e2;\n   logic        [31:0]    bfp_shift_data_e2;\n   logic        [31:0]    bfp_shift_mask_e2;\n   logic        [31:0]    bfp_result_e2;\n\n\n   assign bfp_len_e2[3:0]            =  b_ff_e2[27:24];\n   assign bfp_len_e2[4]              = (bfp_len_e2[3:0] == 4'b0);   // If LEN field is zero, then LEN=16\n   assign bfp_off_e2[4:0]            =  b_ff_e2[20:16];\n\n   assign bfp_len_mask_e2_[31:0]     =  32'hffff_ffff  <<  bfp_len_e2[4:0];\n   assign bfp_off_mask_e2_[31:0]     =  32'hffff_ffff  <<  bfp_off_e2[4:0];\n   assign bfp_preshift_data_e2[15:0] =  b_ff_e2[15:0] & ~bfp_len_mask_e2_[15:0];\n\n   assign bfp_shift_data_e2[31:0]    = {16'b0,bfp_preshift_data_e2[15:0]}  <<  bfp_off_e2[4:0];\n   assign bfp_shift_mask_e2[31:0]    = (bfp_len_mask_e2_[31:0]             <<  bfp_off_e2[4:0]) | ~bfp_off_mask_e2_[31:0];\n\n   assign bfp_result_e2[31:0]        = bfp_shift_data_e2[31:0] | (a_ff_e2[31:0] & bfp_shift_mask_e2[31:0]);\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  XPERM          * * * * * * * * * * * * * * * * *\n\n// These instructions operate on nibbles/bytes/half-words/words.\n// rs1 is a vector of data words and rs2 is a vector of indices into rs1.\n// The result of the instruction is the vector rs2 with each element replaced by the corresponding data word from rs1,\n// or zero then the index in rs2 is out of bounds.\n//\n//   uint_xlen_t xperm(uint_xlen_t rs1, uint_xlen_t rs2, int sz_log2)\n//   {\n//       uint_xlen_t r = 0;\n//       uint_xlen_t sz = 1LL << sz_log2;\n//       uint_xlen_t mask = (1LL << sz) - 1;\n//       for (int i = 0; i < XLEN; i += sz)\n//           { uint_xlen_t pos = ((rs2 >> i) & mask) << sz_log2;\n//             if (pos < XLEN)\n//                 r |= ((rs1 >> pos) & mask) << i;\n//           }\n//       return r;\n//   }\n//\n// uint_xlen_t xperm_n (uint_xlen_t rs1, uint_xlen_t rs2) { return xperm(rs1, rs2, 2); }\n// uint_xlen_t xperm_b (uint_xlen_t rs1, uint_xlen_t rs2) { return xperm(rs1, rs2, 3); }\n// uint_xlen_t xperm_h (uint_xlen_t rs1, uint_xlen_t rs2) { return xperm(rs1, rs2, 4); }\n// uint_xlen_t xperm_w (uint_xlen_t rs1, uint_xlen_t rs2) { return xperm(rs1, rs2, 5); }   Not part of RV32\n//\n// The xperm.[nbhw] instructions can be implemented with an XLEN/4-lane nibble-wide crossbarswitch.\n\n\n   logic        [31:0]    xperm_n_e2;\n   logic        [31:0]    xperm_b_e2;\n   logic        [31:0]    xperm_h_e2;\n\n   assign xperm_n_e2[03:00]      =  { 4{    ~b_ff_e2[03]     }} & ( (a_ff_e2[31:0] >> {b_ff_e2[02:00],2'b0}) &     4'hf );   // This is a 8:1 mux with qualified selects\n   assign xperm_n_e2[07:04]      =  { 4{    ~b_ff_e2[07]     }} & ( (a_ff_e2[31:0] >> {b_ff_e2[06:04],2'b0}) &     4'hf );\n   assign xperm_n_e2[11:08]      =  { 4{    ~b_ff_e2[11]     }} & ( (a_ff_e2[31:0] >> {b_ff_e2[10:08],2'b0}) &     4'hf );\n   assign xperm_n_e2[15:12]      =  { 4{    ~b_ff_e2[15]     }} & ( (a_ff_e2[31:0] >> {b_ff_e2[14:12],2'b0}) &     4'hf );\n   assign xperm_n_e2[19:16]      =  { 4{    ~b_ff_e2[19]     }} & ( (a_ff_e2[31:0] >> {b_ff_e2[18:16],2'b0}) &     4'hf );\n   assign xperm_n_e2[23:20]      =  { 4{    ~b_ff_e2[23]     }} & ( (a_ff_e2[31:0] >> {b_ff_e2[22:20],2'b0}) &     4'hf );\n   assign xperm_n_e2[27:24]      =  { 4{    ~b_ff_e2[27]     }} & ( (a_ff_e2[31:0] >> {b_ff_e2[26:24],2'b0}) &     4'hf );\n   assign xperm_n_e2[31:28]      =  { 4{    ~b_ff_e2[31]     }} & ( (a_ff_e2[31:0] >> {b_ff_e2[30:28],2'b0}) &     4'hf );\n\n   assign xperm_b_e2[07:00]      =  { 8{ ~(| b_ff_e2[07:02]) }} & ( (a_ff_e2[31:0] >> {b_ff_e2[01:00],3'b0}) &    8'hff );   // This is a 4:1 mux with qualified selects\n   assign xperm_b_e2[15:08]      =  { 8{ ~(| b_ff_e2[15:10]) }} & ( (a_ff_e2[31:0] >> {b_ff_e2[09:08],3'b0}) &    8'hff );\n   assign xperm_b_e2[23:16]      =  { 8{ ~(| b_ff_e2[23:18]) }} & ( (a_ff_e2[31:0] >> {b_ff_e2[17:16],3'b0}) &    8'hff );\n   assign xperm_b_e2[31:24]      =  { 8{ ~(| b_ff_e2[31:26]) }} & ( (a_ff_e2[31:0] >> {b_ff_e2[25:24],3'b0}) &    8'hff );\n\n   assign xperm_h_e2[15:00]      =  {16{ ~(| b_ff_e2[15:01]) }} & ( (a_ff_e2[31:0] >> {b_ff_e2[00]   ,4'b0}) & 16'hffff );   // This is a 2:1 mux with qualified selects\n   assign xperm_h_e2[31:16]      =  {16{ ~(| b_ff_e2[31:17]) }} & ( (a_ff_e2[31:0] >> {b_ff_e2[16]   ,4'b0}) & 16'hffff );\n\n\n\n\n\n   // * * * * * * * * * * * * * * * * * *  BitManip  :  Common logic * * * * * * * * * * * * * * * * * *\n\n\n   assign bitmanip_sel_e2        =  ap_bcompress_e2 | ap_bdecompress_e2 | ap_clmul_e2 | ap_clmulh_e2 | ap_clmulr_e2 | ap_grev_e2 | ap_gorc_e2 | ap_shfl_e2 | ap_unshfl_e2 | crc32_all_e2 | ap_bfp_e2 | ap_xperm_n_e2 | ap_xperm_b_e2 | ap_xperm_h_e2;\n\n   assign bitmanip_e2[31:0]      = ( {32{ap_bcompress_e2}}   &       bcompress_e2[31:0]   ) |\n                                   ( {32{ap_bdecompress_e2}} &       bdecompress_e2[31:0] ) |\n                                   ( {32{ap_clmul_e2}}       &       clmul_raw_e2[31:0]   ) |\n                                   ( {32{ap_clmulh_e2}}      & {1'b0,clmul_raw_e2[62:32]} ) |\n                                   ( {32{ap_clmulr_e2}}      &       clmul_raw_e2[62:31]  ) |\n                                   ( {32{ap_grev_e2}}        &       grev_e2[31:0]        ) |\n                                   ( {32{ap_gorc_e2}}        &       gorc_e2[31:0]        ) |\n                                   ( {32{ap_shfl_e2}}        &       shfl_e2[31:0]        ) |\n                                   ( {32{ap_unshfl_e2}}      &       unshfl_e2[31:0]      ) |\n                                   ( {32{ap_crc32_b_e2}}     &       crc32_b_e2[31:0]     ) |\n                                   ( {32{ap_crc32_h_e2}}     &       crc32_h_e2[31:0]     ) |\n                                   ( {32{ap_crc32_w_e2}}     &       crc32_w_e2[31:0]     ) |\n                                   ( {32{ap_crc32c_b_e2}}    &       crc32c_b_e2[31:0]    ) |\n                                   ( {32{ap_crc32c_h_e2}}    &       crc32c_h_e2[31:0]    ) |\n                                   ( {32{ap_crc32c_w_e2}}    &       crc32c_w_e2[31:0]    ) |\n                                   ( {32{ap_bfp_e2}}         &       bfp_result_e2[31:0]  ) |\n                                   ( {32{ap_xperm_n_e2}}     &       xperm_n_e2[31:0]     ) |\n                                   ( {32{ap_xperm_b_e2}}     &       xperm_b_e2[31:0]     ) |\n                                   ( {32{ap_xperm_h_e2}}     &       xperm_h_e2[31:0]     );\n\n\n\n   rvdff  #(33)                     i_bitmanip_ff (.*, .din({bitmanip_sel_e2,bitmanip_e2[31:0]}),   .dout({bitmanip_sel_e3,bitmanip_e3[31:0]}),   .clk(exu_mul_c1_e3_clk));\n\n\n\n\n   assign out[31:0]              =  ( {32{~bitmanip_sel_e3 & ~low_e3}} & prod_e3[63:32]    ) |\n                                    ( {32{~bitmanip_sel_e3 &  low_e3}} & prod_e3[31:0]     ) |\n                                                                         bitmanip_e3[31:0];\n\n\n\n\nendmodule // eh2_exu_mul_ctl\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n//********************************************************************************\n// Function: Top level file for Icache, Fetch, Branch prediction & Aligner\n// BFF -> F1 -> F2 -> A\n//********************************************************************************\n\nmodule eh2_ifu\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n   input logic clk,\n   input logic active_clk,\n   input logic [pt.NUM_THREADS-1:0] active_thread_l2clk,\n   input logic clk_override,\n   input logic rst_l,\n\n\n   input logic [pt.NUM_THREADS-1:0]        dec_i1_cancel_e1,\n\n   input logic [pt.NUM_THREADS-1:0]        dec_ib3_valid_d,           // ib3 buffer valid\n   input logic [pt.NUM_THREADS-1:0]        dec_ib2_valid_d,           // ib2 buffer valid\n\n   input logic dec_i0_tid_e4, // needed to maintain RS in BP\n   input logic dec_i1_tid_e4,\n\n   input logic        exu_i0_br_ret_e4,  // i0 branch commit is a ret\n   input logic        exu_i1_br_ret_e4,  // i1 branch commit is a ret\n   input logic        exu_i0_br_call_e4, // i0 branch commit is a call\n   input logic        exu_i1_br_call_e4, // i1 branch commit is a call\n\n   input logic [pt.NUM_THREADS-1:0][31:1] exu_flush_path_final, // flush fetch address\n   input logic [pt.NUM_THREADS-1:0][31:1] dec_tlu_flush_path_wb, // flush fetch address\n\n   input logic [pt.NUM_THREADS-1:0]             exu_flush_final_early,              // Pipe is being flushed this cycle\n   input logic [pt.NUM_THREADS-1:0][31:1]       exu_flush_path_final_early,         // Target for the oldest flush source\n\n`ifdef REAL_COMM_RS\n   input logic        exu_flush_upper_e2,    // flush upper, either i0 or i1\n`endif\n   input logic [31:0]  dec_tlu_mrac_ff ,// Side_effect , cacheable for each region\n\n   input logic                         dec_tlu_bpred_disable, // disable all branch prediction\n   input logic                         dec_tlu_core_ecc_disable,  // disable ecc checking and flagging\n\n   input logic [pt.NUM_THREADS-1:0]    dec_tlu_btb_write_kill, // Kill writes while working on forward progress after a branch error\n\n// Threaded signals\n\n   input logic [pt.NUM_THREADS-1:0]        exu_flush_final,\n   input logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_err_wb , // flush due to parity error.\n   input logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_noredir_wb, // don't fetch, validated with exu_flush_final\n   input logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_lower_wb, //\n   input logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_mp_wb,\n   input logic [pt.NUM_THREADS-1:0]        dec_tlu_fence_i_wb, //\n   input logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_leak_one_wb, // ignore bp for leak one fetches\n   input logic [pt.NUM_THREADS-1:0]        dec_tlu_force_halt , // force halt.\n\n  //-------------------------- IFU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            ifu_axi_awvalid,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_awid,\n   output logic [31:0]                     ifu_axi_awaddr,\n   output logic [3:0]                      ifu_axi_awregion,\n   output logic [7:0]                      ifu_axi_awlen,\n   output logic [2:0]                      ifu_axi_awsize,\n   output logic [1:0]                      ifu_axi_awburst,\n   output logic                            ifu_axi_awlock,\n   output logic [3:0]                      ifu_axi_awcache,\n   output logic [2:0]                      ifu_axi_awprot,\n   output logic [3:0]                      ifu_axi_awqos,\n\n   output logic                            ifu_axi_wvalid,\n   output logic [63:0]                     ifu_axi_wdata,\n   output logic [7:0]                      ifu_axi_wstrb,\n   output logic                            ifu_axi_wlast,\n\n   output logic                            ifu_axi_bready,\n\n   // AXI Read Channels\n   output logic                            ifu_axi_arvalid,\n   input  logic                            ifu_axi_arready,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_arid,\n   output logic [31:0]                     ifu_axi_araddr,\n   output logic [3:0]                      ifu_axi_arregion,\n   output logic [7:0]                      ifu_axi_arlen,\n   output logic [2:0]                      ifu_axi_arsize,\n   output logic [1:0]                      ifu_axi_arburst,\n   output logic                            ifu_axi_arlock,\n   output logic [3:0]                      ifu_axi_arcache,\n   output logic [2:0]                      ifu_axi_arprot,\n   output logic [3:0]                      ifu_axi_arqos,\n\n   input  logic                            ifu_axi_rvalid,\n   output logic                            ifu_axi_rready,\n   input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_rid,\n   input  logic [63:0]                     ifu_axi_rdata,\n   input  logic [1:0]                      ifu_axi_rresp,\n\n\n   input  logic                         ifu_bus_clk_en,\n\n   input  logic                      dma_iccm_req,\n   input  logic [2:0]                dma_mem_tag,\n   input  logic [31:0]               dma_mem_addr,\n   input  logic [2:0]                dma_mem_sz,\n   input  logic                      dma_mem_write,\n   input  logic [63:0]               dma_mem_wdata,\n   input  logic                      dma_iccm_stall_any,\n\n\n   output logic                      iccm_dma_ecc_error,\n   output logic                      iccm_dma_rvalid,\n   output logic [2:0]                iccm_dma_rtag,\n   output logic [63:0]               iccm_dma_rdata,\n   output logic                      iccm_ready,\n\n   output logic [pt.NUM_THREADS-1:0][1:0] ifu_pmu_instr_aligned,\n   output logic [pt.NUM_THREADS-1:0]      ifu_pmu_align_stall,\n\n   output logic [pt.NUM_THREADS-1:0] ifu_pmu_fetch_stall,\n\n//   I$ & ITAG Ports\n   output logic [31:1]               ic_rw_addr,         // Read/Write addresss to the Icache.\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_wr_en,           // Icache write enable, when filling the Icache.\n   output logic                      ic_rd_en,           // Icache read  enable.\n\n   output logic [pt.ICACHE_BANKS_WAY-1:0] [70:0]               ic_wr_data,           // Data to fill to the Icache. With ECC\n   input  logic [63:0]               ic_rd_data ,          // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [70:0]               ic_debug_rd_data ,    // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [25:0]               ictag_debug_rd_data,  // Debug icache tag.\n   output logic [70:0]               ic_debug_wr_data,     // Debug wr cache.\n   output logic [70:0]               ifu_ic_debug_rd_data, // debug data read\n\n   input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_eccerr,    //\n   input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_parerr,\n\n\n\n   output logic [63:0]               ic_premux_data,     // Premux data to be muxed with each way of the Icache.\n   output logic                      ic_sel_premux_data, // Select the premux data.\n\n   output logic [pt.ICACHE_INDEX_HI:3]  ic_debug_addr,      // Read/Write addresss to the Icache.\n   output logic                         ic_debug_rd_en,     // Icache debug rd\n   output logic                         ic_debug_wr_en,     // Icache debug wr\n   output logic                         ic_debug_tag_array, // Debug tag array\n   output logic [pt.ICACHE_NUM_WAYS-1:0]ic_debug_way,       // Debug way. Rd or Wr.\n\n\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_tag_valid,       // Valid bits when accessing the Icache. One valid bit per way. F2 stage\n\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]                ic_rd_hit,          // Compare hits from Icache tags. Per way.  F2 stage\n   input  logic                      ic_tag_perr,        // Icache Tag parity error\n\n\n   // ICCM ports\n   output logic [pt.ICCM_BITS-1:1]   iccm_rw_addr,                        // ICCM read/write address.\n   output logic [pt.NUM_THREADS-1:0] iccm_buf_correct_ecc_thr,            // ICCM is doing a single bit error correct cycle\n   output logic                      iccm_stop_fetch,                     // We have fetched 4 bytes. Dont consider any hits for lru replacements\n   output logic                      iccm_correction_state,               // We are under a correction - This is needed to guard replacements when hit\n   output logic                      iccm_corr_scnd_fetch,                // dont match on middle bank when under correction\n\n   output logic                      ifc_select_tid_f1,  // Thread reading ICCM. Used for error redundancy logic\n   output logic                      iccm_wren,          // ICCM write enable (through the DMA)\n   output logic                      iccm_rden,          // ICCM read enable.\n   output logic [77:0]               iccm_wr_data,       // ICCM write data.\n   output logic [2:0]                iccm_wr_size,       // ICCM write location within DW.\n\n   input  logic [63:0]               iccm_rd_data,       // Data read from ICCM.\n   input  logic [116:0]              iccm_rd_data_ecc,   // Data read from ICCM.\n\n\n\n   // BTB ports\n   input eh2_btb_sram_pkt btb_sram_pkt,\n\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank0_rd_data_f1,\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank1_rd_data_f1,\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank2_rd_data_f1,\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank3_rd_data_f1,\n   output logic                         btb_wren,\n   output logic                         btb_rden,\n   output logic [1:0] [pt.BTB_ADDR_HI:1] btb_rw_addr,  // per bank\n   output logic [1:0] [pt.BTB_ADDR_HI:1] btb_rw_addr_f1,  // per bank\n   output logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]         btb_sram_wr_data,\n   output logic [1:0] [pt.BTB_BTAG_SIZE-1:0] btb_sram_rd_tag_f1,\n\n   output logic [pt.NUM_THREADS-1:0] ifu_pmu_ic_miss,               // IC miss event\n   output logic [pt.NUM_THREADS-1:0] ifu_pmu_ic_hit,                // IC hit event\n   output logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_error,             // Bus error event\n   output logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_busy,              // Bus busy event\n   output logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_trxn,              // Bus transaction\n\n   output logic  [pt.NUM_THREADS-1:0] ifu_i0_valid,        // Instruction 0 valid. From Aligner to Decode\n   output logic  [pt.NUM_THREADS-1:0] ifu_i1_valid,        // Instruction 1 valid. From Aligner to Decode\n   output logic  [pt.NUM_THREADS-1:0] ifu_i0_icaf,         // Instruction 0 access fault. From Aligner to Decode\n\n   output logic  [pt.NUM_THREADS-1:0] [1:0]  ifu_i0_icaf_type, // Instruction 0 access fault type\n\n   output logic  [pt.NUM_THREADS-1:0] ifu_i0_icaf_second,      // Instruction 0 has access fault on second 2B of 4B inst\n   output logic  [pt.NUM_THREADS-1:0] ifu_i0_dbecc,        // Instruction 0 has double bit ecc error\n   output logic                     iccm_dma_sb_error,   // Single Bit ECC error from a DMA access\n   output logic  [pt.NUM_THREADS-1:0] [31:0] ifu_i0_instr,   // Instruction 0 . From Aligner to Decode\n   output logic  [pt.NUM_THREADS-1:0] [31:0] ifu_i1_instr,   // Instruction 1 . From Aligner to Decode\n   output logic  [pt.NUM_THREADS-1:0] [31:1] ifu_i0_pc,      // Instruction 0 pc. From Aligner to Decode\n   output logic  [pt.NUM_THREADS-1:0] [31:1] ifu_i1_pc,      // Instruction 1 pc. From Aligner to Decode\n   output logic  [pt.NUM_THREADS-1:0] ifu_i0_pc4,           // Instruction 0 is 4 byte. From Aligner to Decode\n   output logic  [pt.NUM_THREADS-1:0] ifu_i1_pc4,           // Instruction 1 is 4 byte. From Aligner to Decode\n   output eh2_predecode_pkt_t  [pt.NUM_THREADS-1:0] ifu_i0_predecode,\n   output eh2_predecode_pkt_t  [pt.NUM_THREADS-1:0] ifu_i1_predecode,\n\n   output eh2_br_pkt_t [pt.NUM_THREADS-1:0] i0_brp,           // Instruction 0 branch packet. From Aligner to Decode\n   output eh2_br_pkt_t [pt.NUM_THREADS-1:0] i1_brp,           // Instruction 1 branch packet. From Aligner to Decode\n   output logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifu_i0_bp_index, // BP index\n   output logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]           ifu_i0_bp_fghr, // BP FGHR\n   output logic [pt.NUM_THREADS-1:0] [pt.BTB_BTAG_SIZE-1:0]          ifu_i0_bp_btag, // BP tag\n   output logic [pt.NUM_THREADS-1:0] [pt.BTB_TOFFSET_SIZE-1:0]       ifu_i0_bp_toffset, // BP offset\n\n   output logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifu_i1_bp_index, // BP index\n   output logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]           ifu_i1_bp_fghr, // BP FGHR\n   output logic [pt.NUM_THREADS-1:0] [pt.BTB_BTAG_SIZE-1:0]          ifu_i1_bp_btag, // BP tag\n   output logic [pt.NUM_THREADS-1:0] [pt.BTB_TOFFSET_SIZE-1:0]       ifu_i1_bp_toffset, // BP offset\n\n   output logic [pt.NUM_THREADS-1:0] [$clog2(pt.BTB_SIZE)-1:0] ifu_i0_bp_fa_index,\n   output logic [pt.NUM_THREADS-1:0] [$clog2(pt.BTB_SIZE)-1:0] ifu_i1_bp_fa_index,\n\n   input eh2_predict_pkt_t [pt.NUM_THREADS-1:0]                    exu_mp_pkt, // mispredict packet\n   input [pt.NUM_THREADS-1:0][pt.BTB_TOFFSET_SIZE-1:0] exu_mp_toffset, // target offset\n   input logic [pt.NUM_THREADS-1:0][pt.BHT_GHR_SIZE-1:0]            exu_mp_eghr, // execute ghr\n   input logic [pt.NUM_THREADS-1:0][pt.BHT_GHR_SIZE-1:0]            exu_mp_fghr,                    // Mispredict fghr\n   input logic [pt.NUM_THREADS-1:0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  exu_mp_index,         // Mispredict index\n   input logic [pt.NUM_THREADS-1:0][pt.BTB_BTAG_SIZE-1:0]           exu_mp_btag,                   // Mispredict btag\n\n   input eh2_br_tlu_pkt_t                     dec_tlu_br0_wb_pkt, // slot0 update/error pkt\n   input eh2_br_tlu_pkt_t                     dec_tlu_br1_wb_pkt, // slot1 update/error pkt\n   input logic [pt.BHT_GHR_SIZE-1:0]           dec_tlu_br0_fghr_wb, // fghr to bp\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br0_index_wb, // bp index\n   input logic [pt.BHT_GHR_SIZE-1:0]           dec_tlu_br1_fghr_wb, // fghr to bp\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br1_index_wb, // bp index\n\n   input [pt.NUM_THREADS-1:0] dec_tlu_i0_commit_cmt,\n\n   input logic [$clog2(pt.BTB_SIZE)-1:0] dec_fa_error_index, // Fully associt btb error index\n\n   output logic [pt.NUM_THREADS-1:0] [15:0] ifu_i0_cinst,\n   output logic [pt.NUM_THREADS-1:0] [15:0] ifu_i1_cinst,\n\n\n/// Icache debug\n   input  eh2_cache_debug_pkt_t        dec_tlu_ic_diag_pkt ,\n   output logic                    ifu_ic_debug_rd_data_valid,\n\n\n// Icache/ICCM errors\n   output logic [pt.NUM_THREADS-1:0]  ifu_miss_state_idle,          // I-side miss buffer empty\n   output logic [pt.NUM_THREADS-1:0]  ifu_ic_error_start,           // IC single bit error\n   output logic [pt.NUM_THREADS-1:0]  ifu_iccm_rd_ecc_single_err,   // ICCM single bit error\n\n\n   input logic scan_mode\n   );\n\n   localparam TAGWIDTH = 2 ;\n   localparam IDWIDTH  = 2 ;\n\n   logic                   ifc_fetch_uncacheable_f1;\n\n   logic [3:0]   ifu_fetch_val;  // valids on a 2B boundary, left justified [7] implies valid fetch\n   logic [31:1]  ifu_fetch_pc;   // starting pc of fetch\n\n   logic [31:1] ifc_fetch_addr_bf, ifc_fetch_addr_f1, ifc_fetch_addr_f2;\n\n   logic [pt.NUM_THREADS-1:0]   ic_write_stall_thr;\n   logic        ic_dma_active;\n   logic        ifc_dma_access_ok;\n   logic        ifc_iccm_access_f1;\n   logic        ifc_region_acc_fault_f1;\n   logic  [3:0] ic_access_fault_f2;\n   logic  [1:0] ic_access_fault_type_f2;// Access fault type\n   logic [pt.NUM_THREADS-1:0]   ifu_ic_mb_empty_thr;\n   logic [pt.NUM_THREADS-1:0]   ic_crit_wd_rdy_thr;\n   logic [3:0]   ic_fetch_val_f2;\n   logic [63:0]  ic_data_f2;\n   logic [63:0]  ifu_fetch_data;\n   logic         ifc_fetch_req_bf, ifc_fetch_req_f1_raw, ifc_fetch_req_f1, ifc_fetch_req_f2;\n   logic         iccm_rd_ecc_single_err;  // This fetch has an iccm single error.\n   logic [3:0]   iccm_rd_ecc_double_err;  // This fetch has an iccm double error.\n   logic [pt.NUM_THREADS-1:0]         ifu_async_error_start;\n\n   logic ifu_fetch_tid;\n   logic ic_hit_f2;\n\n\n   // fetch control\n   logic [pt.NUM_THREADS-1:0] [31:1] fetch_addr_bf, fetch_addr_f1, fetch_addr_f2; // fetch address\n   logic [pt.NUM_THREADS-1:0] fetch_uncacheable_f1, fetch_req_bf, fetch_req_f1, fetch_req_f1_raw, fetch_req_f2,\n                              iccm_access_f1, region_acc_fault_f1, dma_access_ok,\n                              ifc_ready;\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] fetch_btb_rd_addr_f1; // btb read hash\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] fetch_btb_rd_addr_p1_f1; // btb read hash\n\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifc_fetch_btb_rd_addr_f1; // btb read hash\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifc_fetch_btb_rd_addr_p1_f1; // btb read hash\n\n   logic [pt.NUM_THREADS-1:0] fb_consume1;                                   // Consumed one buffer. To fetch control fetch for buffer mass balance\n   logic [pt.NUM_THREADS-1:0] fb_consume2;                                   // Consumed two buffers.To fetch control fetch for buffer mass balance\n\nlogic [pt.NUM_THREADS-1:0] dec_tlu_i0_commit_cmt_thr;\nlogic  fetch_tid_f1 ;\n   logic [pt.NUM_THREADS-1:0] i0_valid;                                      // Instruction 0 is valid\n   logic [pt.NUM_THREADS-1:0] i1_valid;                                      // Instruction 1 is valid\n   logic [pt.NUM_THREADS-1:0] i0_icaf;                                       // Instruction 0 has access fault\n   logic [pt.NUM_THREADS-1:0] [1:0]  i0_icaf_type;                           // Instruction 0 access fault type\n   logic [pt.NUM_THREADS-1:0] i0_icaf_second;                                // Instruction 0 has access fault on second 2B of 4B inst\n   logic [pt.NUM_THREADS-1:0] i0_dbecc;                                      // Instruction 0 has double bit ecc error\n   logic [pt.NUM_THREADS-1:0] [31:0] i0_instr;                               // Instruction 0\n   logic [pt.NUM_THREADS-1:0] [31:0] i1_instr;                               // Instruction 1\n   logic [pt.NUM_THREADS-1:0] [31:1] i0_pc;                                  // Instruction 0 PC\n   logic [pt.NUM_THREADS-1:0] [31:1] i1_pc;                                  // Instruction 1 PC\n   logic [pt.NUM_THREADS-1:0] i0_pc4;\n   logic [pt.NUM_THREADS-1:0] i1_pc4;\n   eh2_predecode_pkt_t [pt.NUM_THREADS-1:0] i0_predecode;\n   eh2_predecode_pkt_t [pt.NUM_THREADS-1:0] i1_predecode;\n   eh2_br_pkt_t [pt.NUM_THREADS-1:0] i0_br_p;                                    // Branch packet for I0.\n   eh2_br_pkt_t [pt.NUM_THREADS-1:0] i1_br_p;                                    // Branch packet for I1.\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_TOFFSET_SIZE-1:0] i0_bp_toffset; // target offset\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_TOFFSET_SIZE-1:0] i1_bp_toffset; // target offset\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  i0_bp_index;  // BP index\n   logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]            i0_bp_fghr;   // BP FGHR\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_BTAG_SIZE-1:0]           i0_bp_btag;   // BP tag\n\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  i1_bp_index;  // BP index\n   logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE"}
{"text": "-1:0]            i1_bp_fghr;   // BP FGHR\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_BTAG_SIZE-1:0]           i1_bp_btag;   // BP tag\n\n   logic [pt.NUM_THREADS-1:0] [$clog2(pt.BTB_SIZE)-1:0] i0_bp_fa_index, i1_bp_fa_index;\n   logic [3:0] [$clog2(pt.BTB_SIZE)-1:0]    ifu_bp_fa_index_f2;\n\n\n   logic [pt.NUM_THREADS-1:0] [1:0] pmu_instr_aligned;                       // number of inst aligned this cycle\n   logic [pt.NUM_THREADS-1:0]       pmu_align_stall;                         // aligner stalled this cycle\n   logic [pt.NUM_THREADS-1:0] [15:0] i0_cinst;                               // 16b compress inst for i0\n   logic [pt.NUM_THREADS-1:0] [15:0] i1_cinst;                               // 16b compress inst for i1\n   logic [3:0]  ifu_bp_way_f2; // way indication; right justified\n   logic  ifu_bp_kill_next_f2; // kill next fetch; taken target found\n   logic [31:1] ifu_bp_btb_target_f2; //  predicted target PC\n   logic [3:1]  ifu_bp_inst_mask_f2; // tell ic which valids to kill because of a taken branch; right justified\n\n   logic [3:0]  ifu_bp_hist1_f2; // history counters for all 4 potential branches; right justified\n   logic [3:0]  ifu_bp_hist0_f2; // history counters for all 4 potential branches; right justified\n   logic [pt.BTB_TOFFSET_SIZE-1:0] ifu_bp_poffset_f2; // predicted target\n   logic [3:0]  ifu_bp_ret_f2; // predicted ret ; right justified\n   logic [3:0]  ifu_bp_pc4_f2; // pc4 indication; right justified\n   logic [3:0]  ifu_bp_valid_f2; // branch valid, right justified\n   logic [pt.BHT_GHR_SIZE-1:0] ifu_bp_fghr_f2;\n\n   logic btb_wr_stall, ifc_select_tid_bf;\n\n     for (genvar i=0; i<pt.NUM_THREADS; i++) begin : ifc\n\n        eh2_ifu_ifc_ctl #(.pt(pt)) ifc (.clk           (active_thread_l2clk[i]),\n                                         .tid               (1'(i)),\n                                         .ic_write_stall(ic_write_stall_thr[i] | btb_wr_stall),\n                                         .ifu_ic_mb_empty(ifu_ic_mb_empty_thr[i]),\n                                         .ic_crit_wd_rdy(ic_crit_wd_rdy_thr[i]),\n                                         .ifu_fb_consume1(fb_consume1[i]),\n                                         .ifu_fb_consume2(fb_consume2[i]),\n                                         .dec_tlu_flush_noredir_wb(dec_tlu_flush_noredir_wb[i]),\n                                         .dec_tlu_flush_lower_wb(dec_tlu_flush_lower_wb[i]),\n                                         .dec_tlu_flush_mp_wb(dec_tlu_flush_mp_wb[i]),\n                                         .dec_tlu_flush_path_wb(dec_tlu_flush_path_wb[i]),\n                                         .exu_flush_final(exu_flush_final[i]),\n                                         .exu_flush_path_final(exu_flush_path_final[i]),\n                                         .exu_flush_final_early(exu_flush_final_early[i]),\n                                         .exu_flush_path_final_early(exu_flush_path_final_early[i]),\n\n                                         .fetch_uncacheable_f1(fetch_uncacheable_f1[i]),\n                                         .fetch_addr_bf(fetch_addr_bf[i]),\n                                         .fetch_addr_f1(fetch_addr_f1[i]),\n                                         .fetch_req_bf(fetch_req_bf[i]),\n                                         .fetch_addr_f2(fetch_addr_f2[i]),\n                                         .fetch_req_f1(fetch_req_f1[i]),\n                                         .fetch_req_f1_raw(fetch_req_f1_raw[i]),\n                                         .fetch_req_f2(fetch_req_f2[i]),\n                                         .pmu_fetch_stall(ifu_pmu_fetch_stall[i]),\n                                         .iccm_access_f1(iccm_access_f1[i]),\n                                         .region_acc_fault_f1(region_acc_fault_f1[i]),\n                                         .dma_access_ok(dma_access_ok[i]),\n                                         .ready(ifc_ready[i]),\n                                         .fetch_btb_rd_addr_f1(fetch_btb_rd_addr_f1[i]),\n                                         .fetch_btb_rd_addr_p1_f1(fetch_btb_rd_addr_p1_f1[i]),\n                                         .*\n                                         );\n\n     end // block: ifc\n   logic [1:0] f1lost, f1lost_f, f1lost_set;\n   logic       dma_iccm_stall_any_f, ifc_both_ready_f1;\n\n\n   if (pt.NUM_THREADS == 2) begin: genmtifc\n\n      // SRAM arbs in BF to set up to the SRAM address flop. This causes problems with perf and fairness though. Fix below.\n      if(pt.BTB_USE_SRAM) begin\n        rvarbiter2 ifc_arbiter (\n                                .clk(active_clk),\n                                .ready(ifc_ready[1:0]),\n                                .tid  (ifc_select_tid_bf),\n                                .shift(ifc_fetch_req_bf & ~f1lost_f[ifc_select_tid_bf]),\n                                .*\n                                );\n\n         assign ifc_fetch_req_bf = fetch_req_bf[ifc_select_tid_bf];\n\n         // Track if we lose the pipeline while there was contention. Adjust the arb lru to compensate.\n         assign f1lost_set[0] = ifc_both_ready_f1 & fetch_req_f1_raw[0] & (ic_write_stall_thr[0] | ic_dma_active | dma_iccm_stall_any_f);\n         assign f1lost_set[1] = ifc_both_ready_f1 & fetch_req_f1_raw[1] & (ic_write_stall_thr[1] | ic_dma_active | dma_iccm_stall_any_f);\n\n         // set when we lose due to IC/ICCM issues, clear when we successfully fetch (raw and qual'd match)\n         assign f1lost[1:0] = f1lost_set[1:0] | (f1lost_f[1:0] & ~(fetch_req_f1_raw[1:0] & fetch_req_f1[1:0]));\n\n         rvdff #(5) tid_ff (.*, .clk(active_clk),\n                            .din({f1lost[1:0], ifc_select_tid_bf, dma_iccm_stall_any, &ifc_ready[1:0]}),\n                            .dout({f1lost_f[1:0], ifc_select_tid_f1, dma_iccm_stall_any_f, ifc_both_ready_f1}));\n      end\n      else begin // not sram\n        rvarbiter2 ifc_arbiter (\n                                .clk(active_clk),\n                                .ready(ifc_ready[1:0]),\n                                .tid  (ifc_select_tid_f1),\n                                .shift(ifc_fetch_req_f1),\n                                .*\n                             );\n         assign ifc_fetch_req_bf = '0;\n         assign ifc_select_tid_bf = 1'b0;\n      end // else: !if(pt.BTB_USE_SRAM)\n   end\n   else begin\n      assign ifc_select_tid_f1 = 1'b0;\n      assign ifc_select_tid_bf = 1'b0;\n   end\n\n\n   assign ifc_fetch_uncacheable_f1 = fetch_uncacheable_f1[ifc_select_tid_f1];\n   assign ifc_fetch_addr_f1[31:1]  = fetch_addr_f1[ifc_select_tid_f1];\n   assign ifc_fetch_addr_bf[31:1]  = fetch_addr_bf[ifc_select_tid_bf];\n   assign ifc_fetch_req_f1 = fetch_req_f1[ifc_select_tid_f1];\n   assign ifc_fetch_req_f1_raw = fetch_req_f1_raw[ifc_select_tid_f1];\n\n   assign ifc_fetch_btb_rd_addr_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = fetch_btb_rd_addr_f1[ifc_select_tid_f1];\n   assign ifc_fetch_btb_rd_addr_p1_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = fetch_btb_rd_addr_p1_f1[ifc_select_tid_f1];\n\n   assign ifc_iccm_access_f1 = iccm_access_f1[ifc_select_tid_f1];\n   assign ifc_region_acc_fault_f1 = region_acc_fault_f1[ifc_select_tid_f1];\n\n   assign ifc_fetch_req_f2 = fetch_req_f2[ifu_fetch_tid];\n\n   assign ifc_dma_access_ok = &dma_access_ok[pt.NUM_THREADS-1:0];\n\n\n   // SRAM BTB hookup\n   logic btb_sram_rw;\n   logic [1:0] [pt.BTB_ADDR_HI:1]        btb_sram_rw_addr, btb_sram_rw_addr_f1;\n\n   assign btb_wren = btb_sram_rw;\n   assign btb_rden = ~btb_sram_rw;\n\n   assign btb_rw_addr[0][pt.BTB_ADDR_HI:1] = btb_sram_rw_addr[0];\n   assign btb_rw_addr[1][pt.BTB_ADDR_HI:1] = btb_sram_rw_addr[1];\n\n   assign btb_rw_addr_f1[0][pt.BTB_ADDR_HI:1] = btb_sram_rw_addr_f1[0];\n   assign btb_rw_addr_f1[1][pt.BTB_ADDR_HI:1] = btb_sram_rw_addr_f1[1];\n\n   // branch predictor\n   eh2_ifu_bp_ctl #(.pt(pt)) bp (.*);\n\n\n\n   assign ifu_fetch_data[63:0]  = ic_data_f2[63:0];\n   assign ifu_fetch_val[3:0]    = ic_fetch_val_f2[3:0];\n\n   // aligner\n\n   // multithreaded signals\n\n\n\n  for (genvar i=0; i<pt.NUM_THREADS; i++) begin : aln\n\n     eh2_ifu_aln_ctl #(.pt(pt)) aln (.clk               (active_thread_l2clk[i]),\n                                      .ifu_fetch_val           ((ifu_fetch_tid==1'(i))?ifu_fetch_val[3:0]:4'b0),\n                                      .ifu_fetch_data          ((ifu_fetch_tid==1'(i))?ifu_fetch_data[63:0]:64'b0),\n                                      .ifu_fetch_pc            (fetch_addr_f2[i][31:1]),\n                                      .ifu_bp_fghr_f2          ((ifu_fetch_tid==1'(i))?ifu_bp_fghr_f2[pt.BHT_GHR_SIZE-1:0]:{pt.BHT_GHR_SIZE{1'b0}}),\n                                      .ifu_bp_btb_target_f2    ((ifu_fetch_tid==1'(i))?ifu_bp_btb_target_f2[31:1]:31'b0),\n                                      .ifu_bp_poffset_f2       ((ifu_fetch_tid==1'(i))?ifu_bp_poffset_f2[pt.BTB_TOFFSET_SIZE-1:0]:{pt.BTB_TOFFSET_SIZE{1'b0}}),\n                                      .ifu_bp_hist0_f2         ((ifu_fetch_tid==1'(i))?ifu_bp_hist0_f2[3:0]:4'b0),\n                                      .ifu_bp_hist1_f2         ((ifu_fetch_tid==1'(i))?ifu_bp_hist1_f2[3:0]:4'b0),\n                                      .ifu_bp_pc4_f2           ((ifu_fetch_tid==1'(i))?ifu_bp_pc4_f2[3:0]:4'b0),\n                                      .ifu_bp_way_f2           ((ifu_fetch_tid==1'(i))?ifu_bp_way_f2[3:0]:4'b0),\n                                      .ifu_bp_valid_f2         ((ifu_fetch_tid==1'(i))?ifu_bp_valid_f2[3:0]:4'b0),\n                                      .ifu_bp_ret_f2           ((ifu_fetch_tid==1'(i))?ifu_bp_ret_f2[3:0]:4'b0),\n                                      .iccm_rd_ecc_double_err  ((ifu_fetch_tid==1'(i))?iccm_rd_ecc_double_err[3:0]:4'b0),\n                                      .ic_access_fault_f2      ((ifu_fetch_tid==1'(i))?ic_access_fault_f2[3:0]:4'b0),\n                                      .ic_access_fault_type_f2 ((ifu_fetch_tid==1'(i))?ic_access_fault_type_f2[1:0]:2'b0),\n\n                                      .ifu_async_error_start   (ifu_async_error_start[i]),\n\n                                      .dec_i1_cancel_e1  (dec_i1_cancel_e1[i]),\n                                      .dec_ib3_valid_d   (dec_ib3_valid_d[i]),\n                                      .dec_ib2_valid_d   (dec_ib2_valid_d[i]),\n                                      .exu_flush_final   (exu_flush_final[i]),\n                                      .i0_valid          (i0_valid[i]),\n                                      .i1_valid          (i1_valid[i]),\n                                      .i0_icaf           (i0_icaf[i]),\n                                      .i0_icaf_type      (i0_icaf_type[i]),\n                                      .i0_icaf_second    (i0_icaf_second[i]),\n                                      .i0_dbecc          (i0_dbecc[i]),\n                                      .i0_instr          (i0_instr[i]),\n                                      .i1_instr          (i1_instr[i]),\n                                      .i0_pc             (i0_pc[i]),\n                                      .i1_pc             (i1_pc[i]),\n                                      .i0_pc4            (i0_pc4[i]),\n                                      .i1_pc4            (i1_pc4[i]),\n                                      .i0_predecode      (i0_predecode[i]),\n                                      .i1_predecode      (i1_predecode[i]),\n                                      .fb_consume1       (fb_consume1[i]),\n                                      .fb_consume2       (fb_consume2[i]),\n                                      .i0_br_p           (i0_br_p[i]),\n                                      .i1_br_p           (i1_br_p[i]),\n                                      .i0_bp_index       (i0_bp_index[i]),\n                                      .i0_bp_toffset     (i0_bp_toffset[i]),\n                                      .i0_bp_fghr        (i0_bp_fghr[i]),\n                                      .i0_bp_btag        (i0_bp_btag[i]),\n                                      .i1_bp_index       (i1_bp_index[i]),\n                                      .i1_bp_toffset     (i1_bp_toffset[i]),\n                                      .i1_bp_fghr        (i1_bp_fghr[i]),\n                                      .i1_bp_btag        (i1_bp_btag[i]),\n                                      .i0_bp_fa_index(i0_bp_fa_index[i]),\n                                      .i1_bp_fa_index(i1_bp_fa_index[i]),\n                                      .pmu_instr_aligned (pmu_instr_aligned[i]),\n                                      .pmu_align_stall   (pmu_align_stall[i]),\n                                      .i0_cinst          (i0_cinst[i]),\n                                      .i1_cinst          (i1_cinst[i]),\n                                      .*);\n  end\n\n\n\n\n\n\n      assign dec_tlu_i0_commit_cmt_thr[pt.NUM_THREADS-1:0] =   dec_tlu_i0_commit_cmt[pt.NUM_THREADS-1:0] ;\n\n      assign ifu_i0_valid [pt.NUM_THREADS-1:0] =     i0_valid[pt.NUM_THREADS-1:0];\n      assign ifu_i1_valid [pt.NUM_THREADS-1:0] =     i1_valid[pt.NUM_THREADS-1:0];\n      assign ifu_i0_icaf  [pt.NUM_THREADS-1:0] =     i0_icaf[pt.NUM_THREADS-1:0];\n      assign ifu_i0_icaf_type [pt.NUM_THREADS-1:0] = i0_icaf_type[pt.NUM_THREADS-1:0];\n      assign ifu_i0_icaf_second   [pt.NUM_THREADS-1:0] = i0_icaf_second[pt.NUM_THREADS-1:0];\n      assign ifu_i0_dbecc [pt.NUM_THREADS-1:0] =     i0_dbecc[pt.NUM_THREADS-1:0];\n      assign ifu_i0_instr [pt.NUM_THREADS-1:0] =     i0_instr[pt.NUM_THREADS-1:0];\n      assign ifu_i1_instr [pt.NUM_THREADS-1:0] =     i1_instr[pt.NUM_THREADS-1:0];\n      assign ifu_i0_pc    [pt.NUM_THREADS-1:0] =     i0_pc[pt.NUM_THREADS-1:0];\n      assign ifu_i1_pc    [pt.NUM_THREADS-1:0] =     i1_pc[pt.NUM_THREADS-1:0];\n      assign ifu_i0_pc4   [pt.NUM_THREADS-1:0] =     i0_pc4[pt.NUM_THREADS-1:0];\n      assign ifu_i1_pc4   [pt.NUM_THREADS-1:0] =     i1_pc4[pt.NUM_THREADS-1:0];\n      assign ifu_i0_predecode [pt.NUM_THREADS-1:0] = i0_predecode[pt.NUM_THREADS-1:0];\n      assign ifu_i1_predecode [pt.NUM_THREADS-1:0] = i1_predecode[pt.NUM_THREADS-1:0];\n      assign i0_brp [pt.NUM_THREADS-1:0] =           i0_br_p[pt.NUM_THREADS-1:0];\n      assign i1_brp [pt.NUM_THREADS-1:0] =           i1_br_p[pt.NUM_THREADS-1:0];\n      assign ifu_i0_bp_index [pt.NUM_THREADS-1:0] =  i0_bp_index[pt.NUM_THREADS-1:0];\n      assign ifu_i0_bp_fghr  [pt.NUM_THREADS-1:0] =  i0_bp_fghr[pt.NUM_THREADS-1:0];\n      assign ifu_i0_bp_btag  [pt.NUM_THREADS-1:0] =  i0_bp_btag[pt.NUM_THREADS-1:0];\n      assign ifu_i0_bp_toffset [pt.NUM_THREADS-1:0] =  i0_bp_toffset[pt.NUM_THREADS-1:0];\n      assign ifu_i1_bp_index [pt.NUM_THREADS-1:0] =  i1_bp_index[pt.NUM_THREADS-1:0];\n      assign ifu_i1_bp_fghr  [pt.NUM_THREADS-1:0] =  i1_bp_fghr[pt.NUM_THREADS-1:0];\n      assign ifu_i1_bp_btag  [pt.NUM_THREADS-1:0] =  i1_bp_btag[pt.NUM_THREADS-1:0];\n      assign ifu_i1_bp_toffset [pt.NUM_THREADS-1:0] =  i1_bp_toffset[pt.NUM_THREADS-1:0];\n      assign ifu_i0_cinst [pt.NUM_THREADS-1:0] =     i0_cinst[pt.NUM_THREADS-1:0];\n      assign ifu_i1_cinst [pt.NUM_THREADS-1:0] =     i1_cinst[pt.NUM_THREADS-1:0];\n\n     assign  ifu_i0_bp_fa_index[pt.NUM_THREADS-1:0] =  i0_bp_fa_index[pt.NUM_THREADS-1:0];\n     assign  ifu_i1_bp_fa_index[pt.NUM_THREADS-1:0] =  i1_bp_fa_index[pt.NUM_THREADS-1:0];\n\n\n   assign ifu_pmu_instr_aligned[pt.NUM_THREADS-1:0] = pmu_instr_aligned[pt.NUM_THREADS-1:0];\n\n   assign ifu_pmu_align_stall[pt.NUM_THREADS-1:0] = pmu_align_stall[pt.NUM_THREADS-1:0];\n\n   assign fetch_tid_f1 = ifc_select_tid_f1;\n\n\n   // icache\n   eh2_ifu_mem_ctl #(.pt(pt)) mem_ctl\n     (.*,\n      .fetch_addr_f1         (ifc_fetch_addr_f1),\n      .fetch_tid_f2          (ifu_fetch_tid),\n      .dec_tlu_i0_commit_cmt (dec_tlu_i0_commit_cmt_thr)\n      );\n\n\n\n   // Performance debug info\n   //\n   //\n`ifdef DUMP_BTB_ON\n\n `define DEC `CPU_TOP.dec\n `define EXU `CPU_TOP.exu\n\n   logic exu_mp_valid; // conditional branch mispredict\n   logic exu_mp_way; // conditional branch mispredict\n   logic exu_mp_ataken; // direction is actual taken\n   logic exu_mp_boffset; // branch offsett\n   logic exu_mp_pc4; // branch is a 4B inst\n   logic exu_mp_call; // branch is a call inst\n   logic exu_mp_ret; // branch is a ret inst\n   logic exu_mp_ja; // branch is a jump always\n   logic exu_mp_bank; // write bank; based on branch PC[3:2]\n   logic [1:0] exu_mp_hist; // new history\n   logic [11:0] exu_mp_tgt; // target offset\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_mp_addr; // BTB/BHT address\n   logic [3:0] ic_rd_hit_f2;\n   logic [1:0] tmp_bnk;\n   logic [31:0] mppc_ns0, mppc0;\n   logic [31:0] mppc_ns1, mppc1;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] btb_rd_addr_f2, btb_rd_addr_p1_f2;\n   logic [pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] bht_rd_addr_f2, bht_rd_addr_p1_f2;\n   logic                                 i;\n\n   eh2_btb_addr_hash #(.pt(pt)) f2hash(.pc(bp.ifc_fetch_addr_f2[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(btb_rd_addr_f2[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n   logic use_p1;\n   assign use_p1 = (bp.fetch_start_f2[1] & bp.vwayhit_f2[3]) | (bp.fetch_start_f2[2] & |bp.vwayhit_f2[3:2]) | (bp.fetch_start_f2[3] & |bp.vwayhit_f2[3:1]) ;\n\n   assign mppc_ns0[0] = 1'b0;\n   assign mppc_ns1[0] = 1'b0;\n\n   rvdff #(36)  mdseal_ff (.*, .clk(active_clk), .din({mppc_ns0[31:0], mem_ctl.ic_rd_hit[3:0]}), .dout({mppc0[31:0],ic_rd_hit_f2[3:0]}));\n   rvdff #(32)  mdseal1_ff (.*, .clk(active_clk), .din({mppc_ns1[31:0]}), .dout({mppc1[31:0]}));\n   logic [31:0] i0_pc_wb, i1_pc_wb;\n   assign i0_pc_wb[0] = 1'b0;\n   assign i1_pc_wb[0] = 1'b0;\n\n   rvdff #(62)  e4pc (.*, .clk(active_clk), .din({`DEC.dec_tlu_i0_pc_e4[31:1],`DEC.dec_tlu_i1_pc_e4[31:1]}), .dout({i0_pc_wb[31:1], i1_pc_wb[31:1]}));\n   rvdff #(2*(pt.BHT_ADDR_HI-pt.BHT_ADDR_LO+1))  bhtff (.*, .clk(active_clk), .din({bp.bht_rd_addr_f1, bp.bht_rd_addr_p1_f1}), .dout({bht_rd_addr_f2, bht_rd_addr_p1_f2}));\n\n   assign tmp_bnk[1:0] = encode4_2(bp.btb_sel_f2[3:0]);\n   logic [31:1] flush_path_i0_wb,flush_path_i1_wb;\n   assign flush_path_i0_wb[31:1] = exu_flush_path_final[`DEC.tlu.i0tid_wb][31:1];\n   assign flush_path_i1_wb[31:1] = exu_flush_path_final[`DEC.tlu.i1tid_wb][31:1];\n\n   always @(negedge clk) begin\n      if(`DEC.tlu.tlumt[0].tlu.mcyclel[31:0] == 32'h0000_0010) begin\n         $display(\"BTB_CONFIG: %d\",pt.BTB_ARRAY_DEPTH*4);\n         `ifndef BP_NOGSHARE\n         $display(\"BHT_CONFIG: %d gshare: 1\",pt.BHT_ARRAY_DEPTH*4);\n         `else\n         $display(\"BHT_CONFIG: %d gshare: 0\",pt.BHT_ARRAY_DEPTH*4);\n         `endif\n         $display(\"RS_CONFIG: %d\", pt.RET_STACK_SIZE);\n      end\n\n\n      mppc_ns0[31:1] = `EXU.i0_flush_upper_e1[0] ? `DEC.decode.i0_pc_e1[31:1] :\n                      (`EXU.i1_flush_upper_e1[0] ? `DEC.decode.i1_pc_e1[31:1] :\n                       (`EXU.exu_i0_flush_lower_e4[0] ?  `DEC.decode.i0_pc_e4[31:1] :  `DEC.decode.i1_pc_e4[31:1]));\n\n\n      if(exu_flush_final[0] & ~(dec_tlu_br0_wb_pkt.br_error | dec_tlu_br0_wb_pkt.br_start_error | dec_tlu_br1_wb_pkt.br_error | dec_tlu_br1_wb_pkt.br_start_error) & (exu_mp_pkt[0].misp | exu_mp_pkt[0].ataken))\n        $display(\"%7d BTB_MP[T0]  : index: %0h bank: %0h call: %b ret: %b ataken: %b hist: %h valid: %b tag: %h targ: %h eghr: %b pred: %b ghr_index: %h brpc: %h way: %h\",\n                 `DEC.tlu.tlumt[0].tlu.mcyclel[31:0]+32'ha, exu_mp_index[0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO], exu_mp_pkt[0].bank, exu_mp_pkt[0].pcall, exu_mp_pkt[0].pret,\n                 exu_mp_pkt[0].ataken, exu_mp_pkt[0].hist[1:0],\n                 exu_mp_pkt[0].misp, exu_mp_btag[0][pt.BTB_BTAG_SIZE-1:0], {exu_flush_path_final[0][31:1], 1'b0}, exu_mp_eghr[0][pt.BHT_GHR_SIZE-1:0], exu_mp_pkt[0].misp,\n                 bp.mp_hashed[0], mppc0[31:0], exu_mp_pkt[0].way);\n      for(int i = 0; i < 4; i++) begin\n         if(ifu_bp_valid_f2[i] & ifc_fetch_req_f2)\n           $display(\"%7d BTB_HIT[T%b] : index: %0h bank: %0h call: %b ret: %b taken: %b strength: %b tag: %h targ: %0h ghr: %4b ghr_index: %h way: %h\",\n                    `DEC.tlu.tlumt[0].tlu.mcyclel[31:0]+32'ha, bp.ifc_select_tid_f2, btb_rd_addr_f2[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],encode4_2(bp.btb_sel_f2[3:0]), bp.btb_rd_call_f2, b"}
{"text": "p.btb_rd_ret_f2,\n                    ifu_bp_hist1_f2[tmp_bnk], ifu_bp_hist0_f2[tmp_bnk], bp.fetch_rd_tag_f2[pt.BTB_BTAG_SIZE-1:0], {ifu_bp_btb_target_f2[31:1], 1'b0},\n                    bp.fghr[0][pt.BHT_GHR_SIZE-1:0], use_p1 ? bht_rd_addr_p1_f2 : bht_rd_addr_f2, ifu_bp_way_f2[tmp_bnk]);\n      end\n\n\n         mppc_ns1[31:1] = `EXU.i0_flush_upper_e1[1] ? `DEC.decode.i0_pc_e1[31:1] :\n                         (`EXU.i1_flush_upper_e1[1] ? `DEC.decode.i1_pc_e1[31:1] :\n                          (`EXU.exu_i0_flush_lower_e4[1] ?  `DEC.decode.i0_pc_e4[31:1] :  `DEC.decode.i1_pc_e4[31:1]));\n\n\n         if(exu_flush_final[1] & ~(dec_tlu_br0_wb_pkt.br_error | dec_tlu_br0_wb_pkt.br_start_error | dec_tlu_br1_wb_pkt.br_error | dec_tlu_br1_wb_pkt.br_start_error) & (exu_mp_pkt[1].misp | exu_mp_pkt[1].ataken))\n           $display(\"%7d BTB_MP[T1]  : index: %0h bank: %0h call: %b ret: %b ataken: %b hist: %h valid: %b tag: %h targ: %h eghr: %b pred: %b ghr_index: %h brpc: %h way: %h\",\n                    `DEC.tlu.tlumt[0].tlu.mcyclel[31:0]+32'ha, exu_mp_index[1][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO], exu_mp_pkt[1].bank, exu_mp_pkt[1].pcall, exu_mp_pkt[1].pret,\n                    exu_mp_pkt[1].ataken, exu_mp_pkt[1].hist[1:0],\n                    exu_mp_pkt[1].misp, exu_mp_btag[1][pt.BTB_BTAG_SIZE-1:0], {exu_flush_path_final[1][31:1], 1'b0}, exu_mp_eghr[1][pt.BHT_GHR_SIZE-1:0], exu_mp_pkt[1].misp,\n                    bp.mp_hashed[1], mppc1[31:0], exu_mp_pkt[1].way);\n\n      if(dec_tlu_br0_wb_pkt.valid & ~(dec_tlu_br0_wb_pkt.br_error | dec_tlu_br0_wb_pkt.br_start_error))\n        $display(\"%7d BTB_UPD0[T%b]: ghr_index: %0h bank: %0h hist: %h  way: %h brpc: %h\",\n                 `DEC.tlu.tlumt[0].tlu.mcyclel[31:0]+32'ha,`DEC.tlu.i0tid_wb, bp.br0_hashed_wb[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO],{dec_tlu_br0_wb_pkt.bank,dec_tlu_br0_wb_pkt.middle},\n                 dec_tlu_br0_wb_pkt.hist, dec_tlu_br0_wb_pkt.way, i0_pc_wb);\n      if(dec_tlu_br1_wb_pkt.valid & ~(dec_tlu_br1_wb_pkt.br_error | dec_tlu_br1_wb_pkt.br_start_error))\n        $display(\"%7d BTB_UPD1[T%b]: ghr_index: %0h bank: %0h hist: %h  way: %h brpc: %h\",\n                 `DEC.tlu.tlumt[0].tlu.mcyclel[31:0]+32'ha,`DEC.tlu.i1tid_wb,bp.br1_hashed_wb[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO],{dec_tlu_br1_wb_pkt.bank,dec_tlu_br1_wb_pkt.middle},\n                 dec_tlu_br1_wb_pkt.hist, dec_tlu_br1_wb_pkt.way, i1_pc_wb);\n      if(dec_tlu_br0_wb_pkt.br_error | dec_tlu_br0_wb_pkt.br_start_error)\n        $display(\"%7d BTB_ERR0[T%b]: index: %0h bank: %0h start: %b rfpc: %h way: %h\",\n                 `DEC.tlu.tlumt[0].tlu.mcyclel[31:0]+32'ha,`DEC.tlu.i0tid_wb,dec_tlu_br0_index_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],dec_tlu_br0_wb_pkt.bank, dec_tlu_br0_wb_pkt.br_start_error,\n                 {flush_path_i0_wb, 1'b0}, dec_tlu_br0_wb_pkt.way);\n      if(dec_tlu_br1_wb_pkt.br_error | dec_tlu_br1_wb_pkt.br_start_error)\n        $display(\"%7d BTB_ERR1[T%b]: index: %0h bank: %0h start: %b rfpc: %h way: %h\",\n                 `DEC.tlu.tlumt[0].tlu.mcyclel[31:0]+32'ha,`DEC.tlu.i1tid_wb,dec_tlu_br1_index_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],dec_tlu_br1_wb_pkt.bank, dec_tlu_br1_wb_pkt.br_start_error,\n                 {flush_path_i1_wb, 1'b0}, dec_tlu_br1_wb_pkt.way);\n   end // always @ (negedge clk)\n      function [1:0] encode4_2;\n      input [3:0] in;\n\n      encode4_2[1] = in[3] | in[2];\n      encode4_2[0] = in[3] | in[1];\n\n   endfunction\n`endif\nendmodule // ifu\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n//********************************************************************************\n// Function: Instruction aligner\n//********************************************************************************\nmodule eh2_ifu_aln_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n\n   input logic        dec_i1_cancel_e1,\n\n   input logic        ifu_async_error_start,                       // ecc/parity related errors with current fetch - not sent down the pipe\n\n   input logic [3:0]  iccm_rd_ecc_double_err,                      // This fetch has a double ICCM ecc  error.\n\n   input logic [3:0]  ic_access_fault_f2,                          // Instruction access fault for the current fetch.\n   input logic [1:0]  ic_access_fault_type_f2,                     // Instruction access fault types\n\n   input logic [pt.BHT_GHR_SIZE-1:0]  ifu_bp_fghr_f2,              // fetch GHR\n   input logic [31:1] ifu_bp_btb_target_f2,                        //  predicted RET target\n   input logic [pt.BTB_TOFFSET_SIZE-1:0] ifu_bp_poffset_f2,        //  predicted target offset\n\n   input logic [3:0]  ifu_bp_hist0_f2,                             // history counters for all 4 potential branches, bit 1, right justified\n   input logic [3:0]  ifu_bp_hist1_f2,                             // history counters for all 4 potential branches, bit 1, right justified\n   input logic [3:0]  ifu_bp_pc4_f2,                               // pc4 indication, right justified\n\n   input logic [3:0] [$clog2(pt.BTB_SIZE)-1:0]    ifu_bp_fa_index_f2, // predicted branch index (fully associative option)\n\n   input logic [3:0]  ifu_bp_way_f2,                               // way indication, right justified\n\n   input logic [3:0]  ifu_bp_valid_f2,                             // branch valid, right justified\n   input logic [3:0]  ifu_bp_ret_f2,                               // predicted ret indication, right justified\n\n   input logic exu_flush_final,                                    // Flush from the pipeline.\n\n   input logic dec_ib3_valid_d,                                    // valids for top 2 instruction buffers at decode\n   input logic dec_ib2_valid_d,\n\n\n   input logic [63:0] ifu_fetch_data,                              // fetch data in memory format - not right justified\n\n   input logic [3:0]   ifu_fetch_val,                              // valids on a 2B boundary, right justified\n   input logic [31:1]  ifu_fetch_pc,                               // starting pc of fetch\n\n\n   input logic   rst_l,\n   input logic   clk,\n   input logic   active_clk,\n\n   output logic i0_valid,                                      // Instruction 0 is valid\n   output logic i1_valid,                                      // Instruction 1 is valid\n   output logic i0_icaf,                                       // Instruction 0 has access fault\n   output logic i0_icaf_second,                                // Instruction has access fault / double ecc error on last 2 bytes of 4B inst - no error on 1st 2 bytes\n   output logic [1:0]  i0_icaf_type,                           // Instruction 0 access fault type\n\n   output logic i0_dbecc,                                      // Instruction 0 has double bit ecc error\n   output logic [31:0] i0_instr,                               // Instruction 0\n   output logic [31:0] i1_instr,                               // Instruction 1\n   output logic [31:1] i0_pc,                                  // Instruction 0 PC\n   output logic [31:1] i1_pc,                                  // Instruction 1 PC\n   output logic i0_pc4,\n   output logic i1_pc4,\n   output eh2_predecode_pkt_t i0_predecode,\n   output eh2_predecode_pkt_t i1_predecode,\n\n   output logic fb_consume1,                                   // Consumed one buffer. To fetch control fetch for buffer mass balance\n   output logic fb_consume2,                                   // Consumed two buffers.To fetch control fetch for buffer mass balance\n\n   output eh2_br_pkt_t i0_br_p,                               // Branch packet for I0.\n   output eh2_br_pkt_t i1_br_p,                               // Branch packet for I1.\n\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  i0_bp_index,  // BP index\n   output logic [pt.BHT_GHR_SIZE-1:0]            i0_bp_fghr,   // BP FGHR\n   output logic [pt.BTB_BTAG_SIZE-1:0]           i0_bp_btag,   // BP tag\n   output logic [pt.BTB_TOFFSET_SIZE-1:0]        i0_bp_toffset,// BP toffset\n   output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  i1_bp_index,  // BP index\n   output logic [pt.BHT_GHR_SIZE-1:0]            i1_bp_fghr,   // BP FGHR\n   output logic [pt.BTB_BTAG_SIZE-1:0]           i1_bp_btag,   // BP tag\n   output logic [pt.BTB_TOFFSET_SIZE-1:0]        i1_bp_toffset,// BP toffset\n\n   output logic [$clog2(pt.BTB_SIZE)-1:0] i0_bp_fa_index,\n   output logic [$clog2(pt.BTB_SIZE)-1:0] i1_bp_fa_index,\n\n   output logic [1:0] pmu_instr_aligned,                       // number of inst aligned this cycle\n   output logic       pmu_align_stall,                         // aligner stalled this cycle\n\n   output logic [15:0] i0_cinst,                               // 16b compress inst for i0\n   output logic [15:0] i1_cinst,                               // 16b compress inst for i1\n\n   input  logic    scan_mode\n\n\n   );\n\n   logic [31:0]    i1instr, i0instr;\n   logic [31:1]    i1pc,    i0pc;\n   logic [15:0]    i1cinst, i0cinst;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  i1_bpindex,    i0_bpindex;\n   logic [pt.BHT_GHR_SIZE-1:0]            i1_bpfghr,     i0_bpfghr;\n   logic [pt.BTB_BTAG_SIZE-1:0]           i1_bpbtag,     i0_bpbtag;\n   logic [pt.BTB_TOFFSET_SIZE-1:0]        i1_bptoffset,  i0_bptoffset;\n\n   eh2_br_pkt_t i1_brp, i0_brp;\n\n   logic         ifvalid;\n   logic         shift_f1_f0, shift_f2_f0, shift_f2_f1;\n   logic         fetch_to_f0, fetch_to_f1, fetch_to_f2;\n\n   logic [3:0]   f3val_in, f3val;\n   logic [3:0]   f2val_in, f2val;\n   logic [3:0]   f1val_in, f1val;\n   logic [3:0]   f0val_in, f0val;\n\n   logic [3:0]   sf1val, sf0val;\n\n   logic [63:0]  f3data_in, f3data;\n   logic [63:0]  f2data_in, f2data;\n   logic [63:0]  f1data_in, f1data, sf1data;\n   logic [63:0]  f0data_in, f0data, sf0data;\n\n   logic [63:0]  aligndata;\n   logic         first4B, first2B;\n   logic         second4B, second2B;\n\n   logic         third4B, third2B;\n   logic [31:0]  uncompress0, uncompress1, uncompress2;\n   logic         ibuffer_room1_more;\n   logic         ibuffer_room2_more;\n   logic         i1_shift;\n   logic         shift_2B, shift_4B, shift_6B, shift_8B;\n   logic         f1_shift_2B, f1_shift_4B, f1_shift_6B;\n   logic         f2_valid, sf1_valid, sf0_valid;\n\n   logic [31:0]  ifirst, isecond, ithird;\n   logic [31:1]  f0pc_plus1, f0pc_plus2, f0pc_plus3, f0pc_plus4;\n   logic [31:1]  f1pc_plus1, f1pc_plus2, f1pc_plus3;\n   logic [3:0]   alignval;\n   logic [31:1]  firstpc, secondpc, thirdpc, fourthpc;\n\n   logic [pt.BTB_TOFFSET_SIZE-1:0]  f1poffset;\n   logic [pt.BTB_TOFFSET_SIZE-1:0]  f0poffset;\n   logic [pt.BHT_GHR_SIZE-1:0]  f1fghr;\n   logic [pt.BHT_GHR_SIZE-1:0]  f0fghr;\n   logic [3:0]   f1hist1;\n   logic [3:0]   f0hist1;\n   logic [3:0]   f1hist0;\n   logic [3:0]   f0hist0;\n\n   logic [3:0][$clog2(pt.BTB_SIZE)-1:0]           f0index, f1index, alignindex;\n\n   logic [1:0]                                    f1ictype;\n   logic [1:0]                                    f0ictype;\n\n   logic [3:0]   f1icaf;\n   logic [3:0]   f0icaf;\n   logic [3:0]   f1dbecc;\n   logic [3:0]   f0dbecc;\n   logic [3:0]   f1pc4;\n   logic [3:0]   f0pc4;\n\n   logic [3:0]   f1ret;\n   logic [3:0]   f0ret;\n   logic [3:0]   f1way;\n   logic [3:0]   f0way;\n\n\n   logic [3:0]   f1brend;\n   logic [3:0]   f0brend;\n\n   logic [3:0]   alignbrend;\n   logic [3:0]   alignpc4;\n\n   logic [3:0]   alignret;\n   logic [3:0]   alignway;\n   logic [3:0]   alignhist1;\n\n   logic [3:0]   alignhist0;\n   logic [3:1]   alignfromf1;\n   logic         i0_ends_f1, i1_ends_f1;\n   logic         i0_br_start_error, i1_br_start_error;\n\n   logic [31:1]  f1prett;\n   logic [31:1]  f0prett;\n\n   logic [3:0]   aligndbecc;\n   logic [3:0]   alignicaf;\n   logic         i0_brp_pc4, i1_brp_pc4;\n\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] firstpc_hash, secondpc_hash, thirdpc_hash, fourthpc_hash;\n\n   logic f2_wr_en;\n   logic f0_shift_wr_en;\n   logic f1_shift_wr_en;\n\n   logic [1:0] wrptr, wrptr_in;\n   logic [1:0] rdptr, rdptr_in;\n   logic [3:0] qwen;\n   logic [1:0]   first_offset, second_offset;\n   logic [1:0]   q3off_eff, q3off_in, q3off;\n   logic [1:0]   q2off_eff, q2off_in, q2off;\n   logic [1:0]   q1off_eff, q1off_in, q1off;\n   logic [1:0]   q0off_eff, q0off_in, q0off;\n   logic         f0_shift_2B, f0_shift_4B, f0_shift_6B;\n\n   logic [1:0]   q0ptr;\n   logic [3:0]   q0sel;\n\n   logic [1:0]   q1ptr;\n   logic [3:0]   q1sel;\n\n   logic [3:0]   qren;\n\n   logic         consume_fb1, consume_fb0;\n   logic [1:0]   icaf_eff;\n\n\n   logic [3:0]   fetch_val;\n\n   logic         error_stall_in, error_stall;\n   localparam MHI   = 32+pt.BTB_TOFFSET_SIZE+pt.BHT_GHR_SIZE;\n   localparam MSIZE = 33+pt.BTB_TOFFSET_SIZE+pt.BHT_GHR_SIZE;\n\n   logic [MHI:0] misc_data_in, misc3, misc2, misc1, misc0;\n   logic [MHI:0] misc1eff, misc0eff;\n\n   localparam FA_INDEX_SZ=$clog2(pt.BTB_SIZE);\n   localparam BRDATA_SIZE=32+($clog2(pt.BTB_SIZE)*4*pt.BTB_FULLYA);\n   localparam BRDATA_WIDTH = 8+($clog2(pt.BTB_SIZE)*pt.BTB_FULLYA);\n\n   logic [BRDATA_SIZE-1:0] brdata_in, brdata3, brdata2, brdata1, brdata0;\n   logic [BRDATA_SIZE-1:0] brdata1eff, brdata0eff;\n   logic [BRDATA_SIZE-1:0] brdata1final, brdata0final;\n   logic  i1_icaf;\n   logic  i1_dbecc;\n   logic [31:0] i0,i1;\n   logic [pt.BTB_BTAG_SIZE-1:0] firstbrtag_hash, secondbrtag_hash, thirdbrtag_hash, fourthbrtag_hash;\n\n   logic                        shift_f3_f2, shift_f3_f1;\n   logic                        fetch_to_f3;\n   logic                        f3_wr_en;\n   logic                        f3_valid;\n\n   logic                        i0_shift;\n\n   assign f3_wr_en = fetch_to_f3;\n\n   assign f2_wr_en = fetch_to_f2 | shift_f3_f2;\n\n   assign f0_shift_wr_en = (fetch_to_f0 | shift_f2_f0 | shift_f1_f0 | shift_2B | shift_4B | shift_6B | shift_8B);\n\n   assign f1_shift_wr_en = (fetch_to_f1 | shift_f3_f1 | shift_f2_f1 | f1_shift_2B | f1_shift_4B | f1_shift_6B);\n\n   assign fetch_val[3:0] = ifu_fetch_val[3:0];\n\n   assign error_stall_in = (error_stall | ifu_async_error_start) & ~exu_flush_final;\n\n   rvdffie #(13) bundle1ff   (.*,\n                              .din({ error_stall_in,wrptr_in[1:0],rdptr_in[1:0],q3off_in[1:0],q2off_in[1:0],q1off_in[1:0],q0off_in[1:0]}),\n                              .dout({error_stall,   wrptr[1:0],   rdptr[1:0],   q3off[1:0],   q2off[1:0],   q1off[1:0],   q0off[1:0]})\n\n                              );\n\n\n   rvdff #(8) bundle2ff   (.*,\n                              .clk(active_clk),\n                              .din({ f3val_in[3:0],f2val_in[3:0]}),\n                              .dout({f3val[3:0],   f2val[3:0]})\n                              );\n\n   rvdff #(8) bundle3ff   (.*,\n                              .clk(active_clk),\n                              .din({ f1val_in[3:0],f0val_in[3:0]}),\n                              .dout({f1val[3:0],   f0val[3:0]})\n                              );\n\n\n   // new queue control logic\n\n   assign wrptr_in[1:0] =  (({2{wrptr[1:0]==2'b00 & ifvalid}} & 2'b01) |\n                            ({2{wrptr[1:0]==2'b01 & ifvalid}} & 2'b10) |\n                            ({2{wrptr[1:0]==2'b10 & ifvalid}} & 2'b11) |\n                            ({2{wrptr[1:0]==2'b11 & ifvalid}} & 2'b00) |\n                            ({2{~ifvalid}} & wrptr[1:0])) & ~{2{exu_flush_final}};\n\n\n   assign rdptr_in[1:0] =  (({2{rdptr[1:0]==2'b00 & fb_consume1}} & 2'b01) |\n                            ({2{rdptr[1:0]==2'b01 & fb_consume1}} & 2'b10) |\n                            ({2{rdptr[1:0]==2'b10 & fb_consume1}} & 2'b11) |\n                            ({2{rdptr[1:0]==2'b11 & fb_consume1}} & 2'b00) |\n                            ({2{rdptr[1:0]==2'b00 & fb_consume2}} & 2'b10) |\n                            ({2{rdptr[1:0]==2'b01 & fb_consume2}} & 2'b11) |\n                            ({2{rdptr[1:0]==2'b10 & fb_consume2}} & 2'b00) |\n                            ({2{rdptr[1:0]==2'b11 & fb_consume2}} & 2'b01) |\n                            ({2{~fb_consume1&~fb_consume2}} & rdptr[1:0])) & ~{2{exu_flush_final}};\n\n\n   assign qren[3:0] = { rdptr[1:0]==2'b11,\n                        rdptr[1:0]==2'b10,\n                        rdptr[1:0]==2'b01,\n                        rdptr[1:0]==2'b00\n                        };\n\n   assign qwen[3:0] = { wrptr[1:0]==2'b11 & ifvalid,\n                        wrptr[1:0]==2'b10 & ifvalid,\n                        wrptr[1:0]==2'b01 & ifvalid,\n                        wrptr[1:0]==2'b00 & ifvalid\n                        };\n\n\n   assign first_offset[1:0]  = {f0_shift_6B|f0_shift_4B,  f0_shift_6B|f0_shift_2B };\n\n   assign second_offset[1:0] = {f1_shift_6B|f1_shift_4B,  f1_shift_6B|f1_shift_2B };\n\n\n   assign q3off_eff[1:0] = (rdptr[1:0]==2'd3) ? (q3off[1:0] + first_offset[1:0])  :\n                           (rdptr[1:0]==2'd2) ? (q3off[1:0] + second_offset[1:0]) :\n                                                 q3off[1:0];\n\n   assign q3off_in[1:0] = (qwen[3]) ? {2'b0} : q3off_eff[1:0];\n\n\n   assign q2off_eff[1:0] = (rdptr[1:0]==2'd2) ? (q2off[1:0] + first_offset[1:0])  :\n                           (rdptr[1:0]==2'd1) ? (q2off[1:0] + second_offset[1:0]) :\n                                                 q2off[1:0];\n\n   assign q2off_in[1:0] = (qwen[2]) ? {2'b0} : q2off_eff[1:0];\n\n\n   assign q1off_eff[1:0] = (rdptr[1:0]==2'd1) ? (q1off[1:0] + first_offset[1:0])  :\n                           (rdptr[1:0]==2'd0) ? (q1off[1:0] + second_offset[1:0]) :\n                                                 q1off[1:0];\n\n\n   assign q1off_in[1:0] = (qwen[1]) ? {2'b0} : q1off_eff[1:0];\n\n\n\n   assign q0off_eff[1:0] = (rdptr[1:0]==2'd0) ? (q0off[1:0] + first_offset[1:0])  :\n                           (rdptr[1:0]==2'd3) ? (q0off[1:0] + second_offset[1:0]) :\n                                                 q0off[1:0];\n\n\n   assign q0off_in[1:0] = (qwen[0]) ? {2'b0} : q0off_eff[1:0];\n\n\n\n\n   assign q0ptr[1:0] = (({2{rdptr[1:0]==2'b00}} & q0off[1:0]) |\n                        ({2{rdptr[1:0]==2'b01}} & q1off[1:0]) |\n                        ({2{rdptr[1:0]==2'b10}} & q2off[1:0]) |\n                        ({2{rdptr[1:0]==2'b11}} & q3off[1:0]));\n\n   assign q1ptr[1:0] = (({2{rdptr[1:0]==2'b00}} & q1off[1:0]) |\n                        ({2{rdptr[1:0]==2'b01}} & q2off[1:0]) |\n                        ({2{rdptr[1:0]==2'b10}} & q3off[1:0]) |\n                        ({2{rdptr[1:0]==2'b11}} & q0off[1:0]));\n\n   assign q0sel[3:0] = {\n                         q0ptr[1:0]==2'b11,\n                         q0ptr[1:0]==2'b10,\n                         q0ptr[1:0]==2'b01,\n                         q0ptr[1:0]==2'b00\n                         };\n\n   assign q1sel[3:0] = {\n                         q1ptr[1:0]==2'b11,\n                         q1ptr[1:0]==2'b10,\n                         q1ptr[1:0]==2'b01,\n                         q1ptr[1:0]==2'b00\n                         };\n\n   // end new queue control logic\n\n\n   // misc data that is associated with each fetch buffer\n\n\n   assign misc_data_in[MHI:0] = {\n                                  ic_access_fault_type_f2[1:0],\n                                  ifu_bp_btb_target_f2[31:1],\n                                  ifu_bp_poffset_f2[pt.BTB_TOFFSET_SIZE-1:0],\n                                  ifu_bp_fghr_f2[pt.BHT_GHR_SIZE-1:0]\n                                  };\n\n   rvdffe #(MSIZE) misc3ff (.*, .en(qwen[3]), .din(misc_data_in[MHI:0]), .dout(misc3[MHI:0]));\n   rvdffe #(MSIZE) misc2ff (.*, .en(qwen[2]), .din(misc_data_in[MHI:0]), .dout(misc2[MHI:0]));\n   rvdffe #(MSIZE) misc1ff (.*, .en(qwen[1]), .din(misc_data_in[MHI:0]), .dout(misc1[MHI:0]));\n   rvdffe #(MSIZE) misc0ff (.*, .en(qwen[0]), .din(misc_data_in[MHI:0]), .dout(misc0[MHI:0]));\n\n\n   assign {misc1eff[MHI:0],misc0eff[MHI:0]} = (({MSIZE*2{qren[0]}} & {misc1[MHI:0],misc0[MHI:0]}) |\n                                               ({MSIZE*2{qren[1]}} & {misc2[MHI:0],misc1[MHI:0]}) |\n                                               ({MSIZE*2{qren[2]}} & {misc3[MHI:0],misc2[MHI:0]}) |\n                                               ({MSIZE*2{qren[3]}} & {misc0[MHI:0],misc3[MHI:0]}));\n\n   assign {\n            f1ictype[1:0],\n            f1prett[31:1],\n            f1poffset[pt.BTB_TOFFSET_SIZE-1:0],\n            f1fghr[pt.BHT_GHR_SIZE-1:0]\n            } = misc1eff[MHI:0];\n\n   assign {\n            f0ictype[1:0],\n            f0prett[31:1],\n            f0poffset[pt.BTB_TOFFSET_SIZE-1:0],\n            f0fghr[pt.BHT_GHR_SIZE-1:0]\n            } = misc0eff[MHI:0];\n\n\n   if(pt.BTB_FULLYA) begin\n\n      assign brdata_in[BRDATA_SIZE-1:0] =\n             {\n              iccm_rd_ecc_double_err[3],ic_access_fault_f2[3],ifu_bp_fa_index_f2[3], ifu_bp_hist1_f2[3],ifu_bp_hist0_f2[3],ifu_bp_pc4_f2[3],ifu_bp_way_f2[3],ifu_bp_valid_f2[3],ifu_bp_ret_f2[3],\n              iccm_rd_ecc_double_err[2],ic_access_fault_f2[2],ifu_bp_fa_index_f2[2], ifu_bp_hist1_f2[2],ifu_bp_hist0_f2[2],ifu_bp_pc4_f2[2],ifu_bp_way_f2[2],ifu_bp_valid_f2[2],ifu_bp_ret_f2[2],\n              iccm_rd_ecc_double_err[1],ic_access_fault_f2[1],ifu_bp_fa_index_f2[1], ifu_bp_hist1_f2[1],ifu_bp_hist0_f2[1],ifu_bp_pc4_f2[1],ifu_bp_way_f2[1],ifu_bp_valid_f2[1],ifu_bp_ret_f2[1],\n              iccm_rd_ecc_double_err[0],ic_access_fault_f2[0],ifu_bp_fa_index_f2[0], ifu_bp_hist1_f2[0],ifu_bp_hist0_f2[0],ifu_bp_pc4_f2[0],ifu_bp_way_f2[0],ifu_bp_valid_f2[0],ifu_bp_ret_f2[0]\n              };\n\n      assign {\n              f0dbecc[3],f0icaf[3],f0index[3],f0hist1[3],f0hist0[3],f0pc4[3],f0way[3],f0brend[3],f0ret[3],\n              f0dbecc[2],f0icaf[2],f0index[2],f0hist1[2],f0hist0[2],f0pc4[2],f0way[2],f0brend[2],f0ret[2],\n              f0dbecc[1],f0icaf[1],f0index[1],f0hist1[1],f0hist0[1],f0pc4[1],f0way[1],f0brend[1],f0ret[1],\n              f0dbecc[0],f0icaf[0],f0index[0],f0hist1[0],f0hist0[0],f0pc4[0],f0way[0],f0brend[0],f0ret[0]\n              } = brdata0final[BRDATA_SIZE-1:0];\n\n      assign {\n              f1dbecc[3],f1icaf[3],f1index[3],f1hist1[3],f1hist0[3],f1pc4[3],f1way[3],f1brend[3],f1ret[3],\n              f1dbecc[2],f1icaf[2],f1index[2],f1hist1[2],f1hist0[2],f1pc4[2],f1way[2],f1brend[2],f1ret[2],\n              f1dbecc[1],f1icaf[1],f1index[1],f1hist1[1],f1hist0[1],f1pc4[1],f1way[1],f1brend[1],f1ret[1],\n              f1dbecc[0],f1icaf[0],f1index[0],f1hist1[0],f1hist0[0],f1pc4[0],f1way[0],f1brend[0],f1ret[0]\n              } = brdata1final[BRDATA_SIZE-1:0];\n\n   end\n   else begin\n\n   assign brdata_in[BRDATA_SIZE-1:0] = {\n                              iccm_rd_ecc_double_err[3],ic_access_fault_f2[3],ifu_bp_hist1_f2[3],ifu_bp_hist0_f2[3],ifu_bp_pc4_f2[3],ifu_bp_way_f2[3],ifu_bp_valid_f2[3],ifu_bp_ret_f2[3],\n                              iccm_rd_ecc_double_err[2],ic_access_fault_f2[2],ifu_bp_hist1_f2[2],ifu_bp_hist0_f2[2],ifu_bp_pc4_f2[2],ifu_bp_way_f2[2],ifu_bp_valid_f2[2],ifu_bp_ret_f2[2],\n                              iccm_rd_ecc_double_err[1],ic_access_fault_f2[1],ifu_bp_hist1_f2[1],ifu_bp_hist0_f2[1],ifu_bp_pc4_f2[1],ifu_bp_way_f2[1],ifu_bp_valid_f2[1],ifu_bp_ret_f2[1],\n                              iccm_rd_ecc_double_err[0],ic_access_fault_f2[0],ifu_bp_his"}
{"text": "t1_f2[0],ifu_bp_hist0_f2[0],ifu_bp_pc4_f2[0],ifu_bp_way_f2[0],ifu_bp_valid_f2[0],ifu_bp_ret_f2[0]\n                              };\n\n\n   assign {\n            f0dbecc[3],f0icaf[3],f0hist1[3],f0hist0[3],f0pc4[3],f0way[3],f0brend[3],f0ret[3],\n            f0dbecc[2],f0icaf[2],f0hist1[2],f0hist0[2],f0pc4[2],f0way[2],f0brend[2],f0ret[2],\n            f0dbecc[1],f0icaf[1],f0hist1[1],f0hist0[1],f0pc4[1],f0way[1],f0brend[1],f0ret[1],\n            f0dbecc[0],f0icaf[0],f0hist1[0],f0hist0[0],f0pc4[0],f0way[0],f0brend[0],f0ret[0]\n            } = brdata0final[BRDATA_SIZE-1:0];\n\n   assign {\n            f1dbecc[3],f1icaf[3],f1hist1[3],f1hist0[3],f1pc4[3],f1way[3],f1brend[3],f1ret[3],\n            f1dbecc[2],f1icaf[2],f1hist1[2],f1hist0[2],f1pc4[2],f1way[2],f1brend[2],f1ret[2],\n            f1dbecc[1],f1icaf[1],f1hist1[1],f1hist0[1],f1pc4[1],f1way[1],f1brend[1],f1ret[1],\n            f1dbecc[0],f1icaf[0],f1hist1[0],f1hist0[0],f1pc4[0],f1way[0],f1brend[0],f1ret[0]\n            } = brdata1final[BRDATA_SIZE-1:0];\n   end\n\n   rvdffe #(BRDATA_SIZE) brdata3ff (.*, .en(qwen[3]), .din(brdata_in[BRDATA_SIZE-1:0]), .dout(brdata3[BRDATA_SIZE-1:0]));\n   rvdffe #(BRDATA_SIZE) brdata2ff (.*, .en(qwen[2]), .din(brdata_in[BRDATA_SIZE-1:0]), .dout(brdata2[BRDATA_SIZE-1:0]));\n   rvdffe #(BRDATA_SIZE) brdata1ff (.*, .en(qwen[1]), .din(brdata_in[BRDATA_SIZE-1:0]), .dout(brdata1[BRDATA_SIZE-1:0]));\n   rvdffe #(BRDATA_SIZE) brdata0ff (.*, .en(qwen[0]), .din(brdata_in[BRDATA_SIZE-1:0]), .dout(brdata0[BRDATA_SIZE-1:0]));\n\n   assign {brdata1eff[BRDATA_SIZE-1:0],brdata0eff[BRDATA_SIZE-1:0]} = (({BRDATA_SIZE*2{qren[0]}} & {brdata1[BRDATA_SIZE-1:0],brdata0[BRDATA_SIZE-1:0]}) |\n                                                                       ({BRDATA_SIZE*2{qren[1]}} & {brdata2[BRDATA_SIZE-1:0],brdata1[BRDATA_SIZE-1:0]}) |\n                                                                       ({BRDATA_SIZE*2{qren[2]}} & {brdata3[BRDATA_SIZE-1:0],brdata2[BRDATA_SIZE-1:0]}) |\n                                                                       ({BRDATA_SIZE*2{qren[3]}} & {brdata0[BRDATA_SIZE-1:0],brdata3[BRDATA_SIZE-1:0]}));\n\n\n   assign brdata0final[BRDATA_SIZE-1:0] = (({BRDATA_SIZE{q0sel[0]}} & {                       brdata0eff[BRDATA_SIZE-1:0*BRDATA_WIDTH]}) |\n                                           ({BRDATA_SIZE{q0sel[1]}} & {{1*BRDATA_WIDTH{1'b0}},brdata0eff[BRDATA_SIZE-1:1*BRDATA_WIDTH]}) |\n                                           ({BRDATA_SIZE{q0sel[2]}} & {{2*BRDATA_WIDTH{1'b0}},brdata0eff[BRDATA_SIZE-1:2*BRDATA_WIDTH]}) |\n                                           ({BRDATA_SIZE{q0sel[3]}} & {{3*BRDATA_WIDTH{1'b0}},brdata0eff[BRDATA_SIZE-1:3*BRDATA_WIDTH]}));\n\n\n   assign brdata1final[BRDATA_SIZE-1:0] = (({BRDATA_SIZE{q1sel[0]}} & {                       brdata1eff[BRDATA_SIZE-1:0*BRDATA_WIDTH]}) |\n                                           ({BRDATA_SIZE{q1sel[1]}} & {{1*BRDATA_WIDTH{1'b0}},brdata1eff[BRDATA_SIZE-1:1*BRDATA_WIDTH]}) |\n                                           ({BRDATA_SIZE{q1sel[2]}} & {{2*BRDATA_WIDTH{1'b0}},brdata1eff[BRDATA_SIZE-1:2*BRDATA_WIDTH]}) |\n                                           ({BRDATA_SIZE{q1sel[3]}} & {{3*BRDATA_WIDTH{1'b0}},brdata1eff[BRDATA_SIZE-1:3*BRDATA_WIDTH]}));\n\n\n\n   // possible states of { sf0_valid, sf1_valid, f2_valid, f3_valid }\n\n   // 0001 illegal\n   // 1010 illegal\n   // 1011 illegal\n   // 1001 illegal\n   // 0101 illegal\n   // 1101 illegal\n\n   // 0000 if->f0\n\n   // 1000 if->f1\n\n   // 0100 f1->f0, if->f1\n\n   // 0110 f1->f0, f2->f1, if->f2\n\n   // 0111 f1->f0, f2->f1, f3->f2, if->f3\n\n   // 1100 if->f2\n\n   // 1110 if->f3\n\n   // 0010 if->f1, f2->f0\n\n   // 0011 if->f2, f2->f0, f3->f1\n\n   // 1111 !if, no shift\n\n   assign shift_f1_f0 =  ~sf0_valid & sf1_valid;\n\n   assign shift_f2_f0 =  ~sf0_valid & ~sf1_valid & f2_valid;\n\n   assign shift_f3_f1 =  ~sf0_valid & ~sf1_valid & f2_valid & f3_valid;\n\n   assign shift_f2_f1 =  ~sf0_valid & sf1_valid & f2_valid;\n\n   assign shift_f3_f2 =  ~sf0_valid & sf1_valid & f2_valid & f3_valid;\n\n   assign fetch_to_f0 =  ~sf0_valid & ~sf1_valid & ~f2_valid & ~f3_valid & ifvalid;\n\n   assign fetch_to_f1 =  (~sf0_valid & ~sf1_valid &  f2_valid & ~f3_valid & ifvalid)  |\n                         (~sf0_valid &  sf1_valid & ~f2_valid & ~f3_valid & ifvalid)  |\n                         ( sf0_valid & ~sf1_valid & ~f2_valid & ~f3_valid & ifvalid);\n\n   assign fetch_to_f2 =  (~sf0_valid &  sf1_valid &  f2_valid & ~f3_valid & ifvalid)  |\n                         ( sf0_valid &  sf1_valid & ~f2_valid & ~f3_valid & ifvalid)  |\n                         (~sf0_valid & ~sf1_valid &  f2_valid &  f3_valid & ifvalid);\n\n   assign fetch_to_f3 =  (~sf0_valid &  sf1_valid &  f2_valid &  f3_valid & ifvalid) |\n                         ( sf0_valid &  sf1_valid &  f2_valid & ~f3_valid & ifvalid);\n   // valids\n\n   assign f3_valid = f3val[0];\n\n   assign f2_valid = f2val[0];\n\n   assign sf1_valid = sf1val[0];\n\n   assign sf0_valid = sf0val[0];\n\n   // interface to fetch\n\n   assign consume_fb0 = ~sf0val[0] & f0val[0];\n\n   assign consume_fb1 = ~sf1val[0] & f1val[0];\n\n   assign fb_consume1 = consume_fb0 & ~consume_fb1 & ~exu_flush_final;\n\n   assign fb_consume2 = consume_fb0 &  consume_fb1 & ~exu_flush_final;\n\n   assign ifvalid = fetch_val[0];\n\n\n\n   // f0 valid states\n   //\n   // 11111111\n   // 11111110\n   // 11111100\n   // 11111000\n   // 11110000\n\n   // 11100000\n   // 11000000\n   // 10000000\n   // 00000000\n\n\n\n   logic [31:1] q3pc, q2pc, q1pc, q0pc;\n\n   rvdffe #(31)           q3pcff        (.*, .clk(clk), .en(qwen[3]),        .din(ifu_fetch_pc[31:1]),     .dout(q3pc[31:1]));\n   rvdffe #(31)           q2pcff        (.*, .clk(clk), .en(qwen[2]),        .din(ifu_fetch_pc[31:1]),     .dout(q2pc[31:1]));\n   rvdffe #(31)           q1pcff        (.*, .clk(clk), .en(qwen[1]),        .din(ifu_fetch_pc[31:1]),     .dout(q1pc[31:1]));\n   rvdffe #(31)           q0pcff        (.*, .clk(clk), .en(qwen[0]),        .din(ifu_fetch_pc[31:1]),     .dout(q0pc[31:1]));\n\n   logic [31:1] q0pceff, q0pcfinal;\n   logic [31:1] q1pceff, q1pcfinal;\n\n   assign {q1pceff[31:1],q0pceff[31:1]} = (({62{qren[0]}} & {q1pc[31:1],q0pc[31:1]}) |\n                                           ({62{qren[1]}} & {q2pc[31:1],q1pc[31:1]}) |\n                                           ({62{qren[2]}} & {q3pc[31:1],q2pc[31:1]}) |\n                                           ({62{qren[3]}} & {q0pc[31:1],q3pc[31:1]}));\n\n   assign q0pcfinal[31:1]      = ({31{q0sel[0]}} & ( q0pceff[31:1])) |\n                                 ({31{q0sel[1]}} & ( q0pceff[31:1] + 31'd1)) |\n                                 ({31{q0sel[2]}} & ( q0pceff[31:1] + 31'd2)) |\n                                 ({31{q0sel[3]}} & ( q0pceff[31:1] + 31'd3));\n\n   assign q1pcfinal[31:1]      = ({31{q1sel[0]}} & ( q1pceff[31:1])) |\n                                 ({31{q1sel[1]}} & ( q1pceff[31:1] + 31'd1)) |\n                                 ({31{q1sel[2]}} & ( q1pceff[31:1] + 31'd2)) |\n                                 ({31{q1sel[3]}} & ( q1pceff[31:1] + 31'd3));\n\n   // on flush_final all valids go to 0\n\n   // no clock-gating on the valids\n\n   assign f3val_in[3:0] = (({4{fetch_to_f3}} & fetch_val[3:0]) |\n                           ({4{~fetch_to_f3&~shift_f3_f1&~shift_f3_f2}} & f3val[3:0])) & ~{4{exu_flush_final}};\n\n\n   assign f2val_in[3:0] = (({4{fetch_to_f2}} & fetch_val[3:0]) |\n                           ({4{shift_f3_f2}} & f3val[3:0]) |\n                           ({4{~fetch_to_f2&~shift_f3_f2&~shift_f2_f1&~shift_f2_f0}} & f2val[3:0])) & ~{4{exu_flush_final}};\n\n\n   assign sf1val[3:0] = ({4{f1_shift_2B}} & {1'b0,f1val[3:1]}) |\n                        ({4{f1_shift_4B}} & {2'b0,f1val[3:2]}) |\n                        ({4{f1_shift_6B}} & {3'b0,f1val[3:3]}) |\n                        ({4{~f1_shift_2B&~f1_shift_4B&~f1_shift_6B}} & f1val[3:0]);\n\n   assign f1val_in[3:0] = (({4{fetch_to_f1}} & fetch_val[3:0]) |\n                           ({4{shift_f3_f1}} & f3val[3:0]) |\n                           ({4{shift_f2_f1}} & f2val[3:0]) |\n                           ({4{~fetch_to_f1&~shift_f3_f1&~shift_f2_f1&~shift_f1_f0}} & sf1val[3:0])) & ~{4{exu_flush_final}};\n\n\n\n   assign sf0val[3:0] = ({4{shift_2B}} & {1'b0,f0val[3:1]}) |\n                        ({4{shift_4B}} & {2'b0,f0val[3:2]}) |\n                        ({4{shift_6B}} & {3'b0,f0val[3:3]}) |\n                        ({4{~shift_2B&~shift_4B&~shift_6B&~shift_8B}} & f0val[3:0]);\n\n   assign f0val_in[3:0] = (({4{fetch_to_f0}} & fetch_val[3:0]) |\n                           ({4{shift_f2_f0}} & f2val[3:0]) |\n                           ({4{shift_f1_f0}} & sf1val[3:0]) |\n                           ({4{~fetch_to_f0&~shift_f2_f0&~shift_f1_f0}} & sf0val[3:0])) & ~{4{exu_flush_final}};\n\n\n\n// fifo implementation of the fetch data for timing of predecodes\n\n   assign f3data_in[63:0] = ifu_fetch_data[63:0];\n\n   rvdffe #(64) f3dataff (.*, .en(f3_wr_en), .din(f3data_in[63:0]), .dout(f3data[63:0]));\n\n   assign f2data_in[63:0] = (fetch_to_f2) ? ifu_fetch_data[63:0] : f3data[63:0];\n\n   rvdffe #(64) f2dataff (.*, .en(f2_wr_en), .din(f2data_in[63:0]), .dout(f2data[63:0]));\n\n   assign sf1data[63:0] = ({64{f1_shift_2B}} & {16'b0,f1data[63:16]}) |\n                          ({64{f1_shift_4B}} & {32'b0,f1data[63:32]}) |\n                          ({64{f1_shift_6B}} & {48'b0,f1data[63:48]}) |\n                          ({64{~f1_shift_2B & ~f1_shift_4B & ~f1_shift_6B}} & f1data[63:0]);\n\n   assign f1data_in[63:0] = (fetch_to_f1) ? ifu_fetch_data[63:0] : (shift_f2_f1) ? f2data[63:0] : (shift_f3_f1) ? f3data[63:0] : sf1data[63:0];\n\n   rvdff4e #(64) f1dataff (.*, .en({4{f1_shift_wr_en}} & f1val_in[3:0]), .din(f1data_in[63:0]), .dout(f1data[63:0]));\n\n   assign sf0data[63:0] = ({64{shift_2B}} & {16'b0,f0data[63:16]}) |\n                          ({64{shift_4B}} & {32'b0,f0data[63:32]}) |\n                          ({64{shift_6B}} & {48'b0,f0data[63:48]});\n\n\n   assign f0data_in[63:0] = (fetch_to_f0) ? ifu_fetch_data[63:0] : (shift_f1_f0) ? sf1data[63:0] : (shift_f2_f0) ? f2data[63:0] : sf0data[63:0];\n\n   rvdff4e #(64) f0dataff (.*, .en({4{fetch_to_f0 | shift_f2_f0 | shift_f1_f0 | shift_2B | shift_4B | shift_6B}} & f0val_in[3:0]), .din(f0data_in[63:0]), .dout(f0data[63:0]));\n\n\n   assign aligndata[63:0] = ({64{(f0val[3])}} &                  {f0data[4*16-1:0]}) |\n                            ({64{(f0val[2]&~f0val[3])}} &        {f1data[1*16-1:0],f0data[3*16-1:0]}) |\n                            ({64{(f0val[1]&~f0val[2])}} &        {f1data[2*16-1:0],f0data[2*16-1:0]}) |\n                            ({64{(f0val[0]&~f0val[1])}} &        {f1data[3*16-1:0],f0data[1*16-1:0]});\n\n   assign alignval[3:0] =   ({4{(f0val[3])}} &                   4'b1111) |\n                            ({4{(f0val[2]&~f0val[3])}} &        {f1val[0],3'b111}) |\n                            ({4{(f0val[1]&~f0val[2])}} &        {f1val[1:0],2'b11}) |\n                            ({4{(f0val[0]&~f0val[1])}} &        {f1val[2:0],1'b1});\n\n   assign alignicaf[3:0] =   ({4{(f0val[3])}} &                    f0icaf[3:0]) |\n                             ({4{(f0val[2]&~f0val[3])}} &         {f1icaf[0],  f0icaf[2:0]}) |\n                             ({4{(f0val[1]&~f0val[2])}} &         {f1icaf[1:0],f0icaf[1:0]}) |\n                             ({4{(f0val[0]&~f0val[1])}} &         {f1icaf[2:0],f0icaf[0]});\n\n   assign aligndbecc[3:0] =   ({4{(f0val[3])}} &                   f0dbecc[3:0]) |\n                              ({4{(f0val[2]&~f0val[3])}} &        {f1dbecc[0],  f0dbecc[2:0]}) |\n                              ({4{(f0val[1]&~f0val[2])}} &        {f1dbecc[1:0],f0dbecc[1:0]}) |\n                              ({4{(f0val[0]&~f0val[1])}} &        {f1dbecc[2:0],f0dbecc[0]});\n\n   // for branch prediction\n   assign alignbrend[3:0] =   ({4{(f0val[3])}} &                   f0brend[3:0]) |\n                              ({4{(f0val[2]&~f0val[3])}} &        {f1brend[0],  f0brend[2:0]}) |\n                              ({4{(f0val[1]&~f0val[2])}} &        {f1brend[1:0],f0brend[1:0]}) |\n                              ({4{(f0val[0]&~f0val[1])}} &        {f1brend[2:0],f0brend[0]});\n\n   assign alignpc4[3:0] =   ({4{(f0val[3])}} &                   f0pc4[3:0]) |\n                            ({4{(f0val[2]&~f0val[3])}} &        {f1pc4[0],  f0pc4[2:0]}) |\n                            ({4{(f0val[1]&~f0val[2])}} &        {f1pc4[1:0],f0pc4[1:0]}) |\n                            ({4{(f0val[0]&~f0val[1])}} &        {f1pc4[2:0],f0pc4[0]});\n   if(pt.BTB_FULLYA)\n     assign alignindex[3:0] =   ({4*$clog2(pt.BTB_SIZE){(f0val[3])}} &                   f0index[3:0]) |\n                                ({4*$clog2(pt.BTB_SIZE){(f0val[2]&~f0val[3])}} &        {f1index[0],f0index[2:0]}) |\n                                ({4*$clog2(pt.BTB_SIZE){(f0val[1]&~f0val[2])}} &        {f1index[1:0],f0index[1:0]}) |\n                                ({4*$clog2(pt.BTB_SIZE){(f0val[0]&~f0val[1])}} &        {f1index[2:0],f0index[0]});\n\n\n   assign alignret[3:0] =   ({4{(f0val[3])}} &                   f0ret[3:0]) |\n                            ({4{(f0val[2]&~f0val[3])}} &        {f1ret[0],  f0ret[2:0]}) |\n                            ({4{(f0val[1]&~f0val[2])}} &        {f1ret[1:0],f0ret[1:0]}) |\n                            ({4{(f0val[0]&~f0val[1])}} &        {f1ret[2:0],f0ret[0]});\n\n   assign alignway[3:0] =   ({4{(f0val[3])}} &                   f0way[3:0]) |\n                            ({4{(f0val[2]&~f0val[3])}} &        {f1way[0],  f0way[2:0]}) |\n                            ({4{(f0val[1]&~f0val[2])}} &        {f1way[1:0],f0way[1:0]}) |\n                            ({4{(f0val[0]&~f0val[1])}} &        {f1way[2:0],f0way[0]});\n\n   assign alignhist1[3:0] =   ({4{(f0val[3])}} &                   f0hist1[3:0]) |\n                              ({4{(f0val[2]&~f0val[3])}} &        {f1hist1[0],  f0hist1[2:0]}) |\n                              ({4{(f0val[1]&~f0val[2])}} &        {f1hist1[1:0],f0hist1[1:0]}) |\n                              ({4{(f0val[0]&~f0val[1])}} &        {f1hist1[2:0],f0hist1[0]});\n\n   assign alignhist0[3:0] =   ({4{(f0val[3])}} &                   f0hist0[3:0]) |\n                              ({4{(f0val[2]&~f0val[3])}} &        {f1hist0[0],f0hist0[2:0]}) |\n                              ({4{(f0val[1]&~f0val[2])}} &        {f1hist0[1:0],f0hist0[1:0]}) |\n                              ({4{(f0val[0]&~f0val[1])}} &        {f1hist0[2:0],f0hist0[0]});\n\n   assign alignfromf1[3:1] =     ({3{(f0val[3])}} &                   3'b0) |\n                                 ({3{(f0val[2]&~f0val[3])}} &        {1'b1,2'b0}) |\n                                 ({3{(f0val[1]&~f0val[2])}} &        {2'b11,1'b0}) |\n                                 ({3{(f0val[0]&~f0val[1])}} &        {3'b111});\n\n\n\n   assign { secondpc[31:1],\n            thirdpc[31:1],\n            fourthpc[31:1] } =   ({3*31{(f0val[3])}}           & {31'(q0pcfinal[31:1] + 31'd1), 31'(q0pcfinal[31:1] + 31'd2), 31'(q0pcfinal[31:1] + 31'd3)}) |\n                                 ({3*31{(f0val[2]&~f0val[3])}} & {31'(q0pcfinal[31:1] + 31'd1), 31'(q0pcfinal[31:1] + 31'd2),     q1pcfinal[31:1]}) |\n                                 ({3*31{(f0val[1]&~f0val[2])}} & {31'(q0pcfinal[31:1] + 31'd1),     q1pcfinal[31:1],          31'(q1pcfinal[31:1] + 31'd1)})   |\n                                 ({3*31{(f0val[0]&~f0val[1])}} & {    q1pcfinal[31:1],          31'(q1pcfinal[31:1] + 31'd1), 31'(q1pcfinal[31:1] + 31'd2)});\n\n\n   assign i0pc[31:1] = q0pcfinal[31:1];\n\n   assign firstpc[31:1] = q0pcfinal[31:1];\n\n   assign i1pc[31:1] = (first2B) ? secondpc[31:1] : thirdpc[31:1];\n\n   assign i0_pc[31:1] = (i0_shift) ? i0pc : '0;\n   assign i1_pc[31:1] = (i1_shift) ? i1pc : '0;\n\n   assign i0_pc4 = first4B;\n\n   assign i1_pc4 = (first2B & second4B) |\n                   (first4B & third4B);\n\n\n\n   assign i0cinst[15:0] = (i0_pc4) ? '0 : aligndata[15:0];\n   assign i1cinst[15:0] = (i1_pc4) ? '0 : (first4B) ? aligndata[47:32] : aligndata[31:16];\n\n   assign i0_cinst[15:0] = (i0_shift) ? i0cinst : '0;\n   assign i1_cinst[15:0] = (i1_shift) ? i1cinst : '0;\n\n\n   // check on 16B boundaries\n   //\n   assign first4B = aligndata[16*0+1:16*0] == 2'b11;\n   assign first2B = ~first4B;\n\n   assign second4B = aligndata[16*1+1:16*1] == 2'b11;\n   assign second2B = ~second4B;\n\n   assign third4B = aligndata[16*2+1:16*2] == 2'b11;\n   assign third2B = ~third4B;\n\n\n   assign i0_valid = ((first4B & alignval[1]) |\n                      (first2B & alignval[0])) & ~exu_flush_final;\n\n\n   assign i1_valid = ((first4B & third4B & alignval[3])  |\n                      (first4B & third2B & alignval[2])  |\n                      (first2B & second4B & alignval[2]) |\n                      (first2B & second2B & alignval[1])) & ~exu_flush_final & ~i1_icaf & ~i1_dbecc;\n\n   // inst access fault on any byte of inst results in access fault for the inst\n   assign i0_icaf = ((first4B & (|alignicaf[1:0])) |\n                     (first2B &   alignicaf[0])) & ~exu_flush_final;\n\n   // restrict icaf and dbecc to be i0 only\n   assign i0_icaf_type[1:0] = (first4B & ~f0val[1] & f0val[0] & ~alignicaf[0] & ~aligndbecc[0]) ? f1ictype[1:0] : f0ictype[1:0];\n\n   assign icaf_eff[1:0] = alignicaf[1:0] | aligndbecc[1:0];\n\n   assign i0_icaf_second = first4B & ~icaf_eff[0] & icaf_eff[1];\n\n\n   assign i1_icaf = ((first4B & third4B &  (|alignicaf[3:2])) |\n                     (first4B & third2B &    alignicaf[2])    |\n                     (first2B & second4B & (|alignicaf[2:1])) |\n                     (first2B & second2B &   alignicaf[1])) & ~exu_flush_final;\n\n\n   assign i0_dbecc = ((first4B & (|aligndbecc[1:0])) |\n                      (first2B &   aligndbecc[0])) & ~exu_flush_final;\n\n   assign i1_dbecc = ((first4B & third4B &  (|aligndbecc[3:2])) |\n                      (first4B & third2B &    aligndbecc[2])    |\n                      (first2B & second4B & (|aligndbecc[2:1])) |\n                      (first2B & second2B &   aligndbecc[1])) & ~exu_flush_final;\n\n\n\n   // big endian 4B instructions\n\n   assign ifirst[31:0] =  aligndata[2*16-1:0*16];\n\n   assign isecond[31:0] = aligndata[3*16-1:1*16];\n\n   assign ithird[31:0] =  aligndata[4*16-1:2*16];\n\n\n\n   assign i0instr[31:0] = ({32{first4B}} & ifirst[31:0]) |\n                           ({32{first2B}} & uncompress0[31:0]);\n\n\n   assign i1instr[31:0] = ({32{first4B & third4B}} & ithird[31:0]) |\n                           ({32{first4B & third2B}} & uncompress2[31:0]) |\n                           ({32{first2B & second4B}} & isecond[31:0]) |\n                           ({32{first2B & second2B}} & uncompress1[31:0]);\n\n   assign i0_instr[31:0] = (i0_shift) ? i0instr : '0;\n   assign i1_instr[31:0] = (i1_shift) ? i1instr : '0;\n\n\n// file \"decode\" is human readable file that has all of the instruction decodes defined and is part of git repo\n// modify this file as needed\n\n// to generate the equations below from \"decode\"\n\n// 1) coredecode -in decode > coredecode.e\n\n// 2) change '.type fr' to '.type fd'   ---> type fd is a full decode among off/on set\n\n// 3) espresso -Dso -oeqntott coredecode.e | addassign  > equations\n\n\n\n   assign i0[31:0] = i0instr[31:0];\n   assign i1[31:0] = i1instr[31:0];\n\n   eh2_ifu_predecode_ctl i0_pred (.inst(i0[31:0]),.predecode(i0_predecode));\n   eh2_ifu_predecode_ctl i1_pred (.inst(i1[31:0]),.predecode(i1_predecode));\n\n\n\n   // if you detect br does not start on instruction boundary\n\n   eh2_btb_addr_hash #(.pt(pt)) firsthash(.pc(firstpc[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(firstpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n   eh2_btb_addr_hash #(.pt(pt)) secondhash(.pc(secondpc[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(secondpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n   eh2_btb_addr_hash #(.pt(pt)) thirdhash(.pc(thirdpc[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(thirdpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n   eh2_btb_addr_hash #(.pt(pt)) fourthhash(.pc(fourthpc[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(fourthpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n\nif(pt.BTB_FULLYA) begin\n   assign firstbrtag_hash = firstpc;\n   assign secondbrtag_hash = secondpc;\n   assign thirdbrtag_hash = thirdpc;\n   assign fourthbrtag_hash = fourthpc;\nend\nelse begin"}
{"text": "\n\nif(pt.BTB_BTAG_FOLD) begin : btbfold\n   eh2_btb_tag_hash_fold #(.pt(pt)) first_brhash (.pc(firstpc [pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]), .hash(firstbrtag_hash[pt.BTB_BTAG_SIZE-1:0]));\n   eh2_btb_tag_hash_fold #(.pt(pt)) second_brhash(.pc(secondpc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]), .hash(secondbrtag_hash[pt.BTB_BTAG_SIZE-1:0]));\n   eh2_btb_tag_hash_fold #(.pt(pt)) third_brhash (.pc(thirdpc [pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]), .hash(thirdbrtag_hash[pt.BTB_BTAG_SIZE-1:0]));\n   eh2_btb_tag_hash_fold #(.pt(pt)) fourth_brhash(.pc(fourthpc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]), .hash(fourthbrtag_hash[pt.BTB_BTAG_SIZE-1:0]));\nend\n   else begin\n   eh2_btb_tag_hash #(.pt(pt)) first_brhash (.pc(firstpc [pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]), .hash(firstbrtag_hash[pt.BTB_BTAG_SIZE-1:0]));\n   eh2_btb_tag_hash #(.pt(pt)) second_brhash(.pc(secondpc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]), .hash(secondbrtag_hash[pt.BTB_BTAG_SIZE-1:0]));\n   eh2_btb_tag_hash #(.pt(pt)) third_brhash (.pc(thirdpc [pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]), .hash(thirdbrtag_hash[pt.BTB_BTAG_SIZE-1:0]));\n   eh2_btb_tag_hash #(.pt(pt)) fourth_brhash(.pc(fourthpc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]), .hash(fourthbrtag_hash[pt.BTB_BTAG_SIZE-1:0]));\nend\n\nend\n\n   // start_indexing - you want pc to be based on where the end of branch is prediction\n   // normal indexing pc based that's incorrect now for pc4 cases it's pc4 + 2\n\n   always_comb begin\n\n      i0_brp = '0;\n\n      i0_br_start_error = (first4B & alignval[1] & alignbrend[0]);\n\n      i0_brp.valid = (first2B & alignbrend[0]) |\n                     (first4B & alignbrend[1]) |\n                     i0_br_start_error;\n\n      i0_brp_pc4 = (first2B & alignpc4[0]) |\n                   (first4B & alignpc4[1]);\n\n      i0_brp.ret = (first2B & alignret[0]) |\n                   (first4B & alignret[1]);\n\n\n      i0_brp.way = (first2B | alignbrend[0]) ? alignway[0] : alignway[1];\n\n      i0_brp.hist[1] = (first2B & alignhist1[0]) |\n                       (first4B & alignhist1[1]);\n\n      i0_brp.hist[0] = (first2B & alignhist0[0]) |\n                       (first4B & alignhist0[1]);\n\n      i0_ends_f1 = (first4B & alignfromf1[1]);\n\n\n      i0_brp.prett[31:1] = (~i0_brp.ret) ? '0 : (i0_ends_f1) ? f1prett[31:1] : f0prett[31:1];\n\n      i0_brp.br_start_error = i0_br_start_error;\n\n\n      i0_brp.bank = (first2B | alignbrend[0]) ? firstpc[2] :\n                    secondpc[2];\n\n\n      i0_brp.br_error = (i0_brp.valid &  i0_brp_pc4 &  first2B) |\n                        (i0_brp.valid & ~i0_brp_pc4 &  first4B);\n\n      i1_brp = '0;\n\n      i1_br_start_error = (first2B & second4B & alignval[2] & alignbrend[1]) |\n                          (first4B & third4B  & alignval[3] & alignbrend[2]);\n\n      i1_brp.valid = (first4B & third2B & alignbrend[2]) |\n                     (first4B & third4B & alignbrend[3]) |\n                     (first2B & second2B & alignbrend[1]) |\n                     (first2B & second4B & alignbrend[2]) |\n                     i1_br_start_error;\n\n      i1_brp_pc4 = (first4B & third2B & alignpc4[2]) |\n                   (first4B & third4B & alignpc4[3]) |\n                   (first2B & second2B & alignpc4[1]) |\n                   (first2B & second4B & alignpc4[2]);\n\n      i1_brp.ret = (first4B & third2B & alignret[2]) |\n                   (first4B & third4B & alignret[3]) |\n                   (first2B & second2B & alignret[1]) |\n                   (first2B & second4B & alignret[2]);\n\n      i1_brp.way = (first4B & third2B                   & alignway[2] ) |\n                   (first4B & third4B &  alignbrend[2]  & alignway[2] ) |\n                   (first4B & third4B & ~alignbrend[2]  & alignway[3] ) |\n                   (first2B & second2B                  & alignway[1] ) |\n                   (first2B & second4B &  alignbrend[1] & alignway[1] ) |\n                   (first2B & second4B & ~alignbrend[1] & alignway[2] );\n\n      i1_brp.hist[1] = (first4B & third2B & alignhist1[2]) |\n                       (first4B & third4B & alignhist1[3]) |\n                       (first2B & second2B & alignhist1[1]) |\n                       (first2B & second4B & alignhist1[2]);\n\n      i1_brp.hist[0] = (first4B & third2B & alignhist0[2]) |\n                       (first4B & third4B & alignhist0[3]) |\n                       (first2B & second2B & alignhist0[1]) |\n                       (first2B & second4B & alignhist0[2]);\n\n      i1_ends_f1 = (first4B & third2B & alignfromf1[2]) |\n                   (first4B & third4B & alignfromf1[3]) |\n                   (first2B & second2B & alignfromf1[1]) |\n                   (first2B & second4B & alignfromf1[2]);\n\n\n      i1_brp.prett[31:1] = (~i1_brp.ret) ? '0 : (i1_ends_f1) ? f1prett[31:1] : f0prett[31:1];\n\n      i1_brp.br_start_error = i1_br_start_error;\n\n\n      i1_brp.bank = ({{first4B & third2B }}                  & thirdpc[2] ) |\n                    ({{first4B & third4B &  alignbrend[2] }} & thirdpc[2] ) |\n                    ({{first4B & third4B & ~alignbrend[2] }} & fourthpc[2] ) |\n                    ({{first2B & second2B}}                  & secondpc[2] ) |\n                    ({{first2B & second4B &  alignbrend[1]}} & secondpc[2] ) |\n                    ({{first2B & second4B & ~alignbrend[1]}} & thirdpc[2] );\n\n      i1_brp.br_error = (i1_brp.valid &  i1_brp_pc4 & first4B & third2B ) |\n                        (i1_brp.valid & ~i1_brp_pc4 & first4B & third4B ) |\n                        (i1_brp.valid &  i1_brp_pc4 & first2B & second2B) |\n                        (i1_brp.valid & ~i1_brp_pc4 & first2B & second4B);\n\n      if(pt.BTB_FULLYA)  begin\n         i0_bp_fa_index = ({FA_INDEX_SZ{first2B}} & alignindex[0]) |\n                          ({FA_INDEX_SZ{first4B}} & alignindex[1]);\n\n         i1_bp_fa_index = ({FA_INDEX_SZ{first4B & third2B }} & alignindex[2]) |\n                          ({FA_INDEX_SZ{first4B & third4B }} & alignindex[3]) |\n                          ({FA_INDEX_SZ{first2B & second2B}} & alignindex[1]) |\n                          ({FA_INDEX_SZ{first2B & second4B}} & alignindex[2]);\n      end\n      else begin\n         i0_bp_fa_index = '0;\n         i1_bp_fa_index = '0;\n      end\n\n\n   end // always_comb begin\n\n   assign i0_br_p = (i0_shift) ? i0_brp : '0;\n   assign i1_br_p = (i1_shift) ? i1_brp : '0;\n\n\n   assign i0_bpfghr[pt.BHT_GHR_SIZE-1:0] = (i0_ends_f1) ? f1fghr[pt.BHT_GHR_SIZE-1:0] : f0fghr[pt.BHT_GHR_SIZE-1:0];\n   assign i1_bpfghr[pt.BHT_GHR_SIZE-1:0] = (i1_ends_f1) ? f1fghr[pt.BHT_GHR_SIZE-1:0] : f0fghr[pt.BHT_GHR_SIZE-1:0];\n\n   assign i0_bptoffset[pt.BTB_TOFFSET_SIZE-1:0] = (i0_ends_f1) ? f1poffset[pt.BTB_TOFFSET_SIZE-1:0] : f0poffset[pt.BTB_TOFFSET_SIZE-1:0];\n   assign i1_bptoffset[pt.BTB_TOFFSET_SIZE-1:0] = (i1_ends_f1) ? f1poffset[pt.BTB_TOFFSET_SIZE-1:0] : f0poffset[pt.BTB_TOFFSET_SIZE-1:0];\n\n   assign i0_bpindex[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = (first2B | alignbrend[0]) ? firstpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]:\n                                                                                  secondpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n   assign i0_bpbtag[pt.BTB_BTAG_SIZE-1:0] = (first2B | alignbrend[0]) ? firstbrtag_hash[pt.BTB_BTAG_SIZE-1:0]:\n                                                                       secondbrtag_hash[pt.BTB_BTAG_SIZE-1:0];\n\n\n   assign i1_bpindex[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = ({pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1{first4B & third2B }}                  & thirdpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ) |\n                                                    ({pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1{first4B & third4B &  alignbrend[2] }} & thirdpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ) |\n                                                    ({pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1{first4B & third4B & ~alignbrend[2] }} & fourthpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ) |\n                                                    ({pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1{first2B & second2B}}                  & secondpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ) |\n                                                    ({pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1{first2B & second4B &  alignbrend[1]}} & secondpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ) |\n                                                    ({pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1{first2B & second4B & ~alignbrend[1]}} & thirdpc_hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] );\n\n   assign i1_bpbtag[pt.BTB_BTAG_SIZE-1:0] = ({pt.BTB_BTAG_SIZE{first4B & third2B }}                  &  thirdbrtag_hash[pt.BTB_BTAG_SIZE-1:0] ) |\n                                           ({pt.BTB_BTAG_SIZE{first4B & third4B &  alignbrend[2] }} &  thirdbrtag_hash[pt.BTB_BTAG_SIZE-1:0] ) |\n                                           ({pt.BTB_BTAG_SIZE{first4B & third4B & ~alignbrend[2] }} & fourthbrtag_hash[pt.BTB_BTAG_SIZE-1:0] ) |\n                                           ({pt.BTB_BTAG_SIZE{first2B & second2B}}                  & secondbrtag_hash[pt.BTB_BTAG_SIZE-1:0] ) |\n                                           ({pt.BTB_BTAG_SIZE{first2B & second4B &  alignbrend[1]}} & secondbrtag_hash[pt.BTB_BTAG_SIZE-1:0] ) |\n                                           ({pt.BTB_BTAG_SIZE{first2B & second4B & ~alignbrend[1]}} &  thirdbrtag_hash[pt.BTB_BTAG_SIZE-1:0] );\n\n   assign i0_bp_fghr[pt.BHT_GHR_SIZE-1:0]            = (i0_shift) ? i0_bpfghr : '0;\n   assign i0_bp_toffset[pt.BTB_TOFFSET_SIZE-1:0]     = (i0_shift) ? i0_bptoffset : '0;\n   assign i0_bp_index[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = (i0_shift) ? i0_bpindex : '0;\n   assign i0_bp_btag[pt.BTB_BTAG_SIZE-1:0]           = (i0_shift) ? i0_bpbtag : '0;\n\n   assign i1_bp_fghr[pt.BHT_GHR_SIZE-1:0]            = (i1_shift) ? i1_bpfghr : '0;\n   assign i1_bp_toffset[pt.BTB_TOFFSET_SIZE-1:0]     = (i1_shift) ? i1_bptoffset : '0;\n   assign i1_bp_index[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = (i1_shift) ? i1_bpindex : '0;\n   assign i1_bp_btag[pt.BTB_BTAG_SIZE-1:0]           = (i1_shift) ? i1_bpbtag : '0;\n\n\n   // decompress\n\n   eh2_ifu_compress_ctl compress0 (.din((first2B) ? aligndata[15:0]  : '0), .dout(uncompress0[31:0]) );\n\n   eh2_ifu_compress_ctl compress1 (.din((second2B)? aligndata[31:16] : '0), .dout(uncompress1[31:0]) );\n\n   eh2_ifu_compress_ctl compress2 (.din((third2B) ? aligndata[47:32] : '0), .dout(uncompress2[31:0]) );\n\n\n`ifdef RV_ASSERT_ON\n   assert_valid_consistency: assert #0 (~( i1_valid & ~i0_valid ) );\n   assert_shift_consistency: assert #0 (~( i1_shift & ~i0_shift ) );\n`endif\n\n   assign i0_shift = i0_valid & ibuffer_room1_more & ~error_stall;\n\n   assign i1_shift = i1_valid & ibuffer_room2_more & ~error_stall;\n\n   assign ibuffer_room1_more = ~dec_ib3_valid_d & ~dec_i1_cancel_e1;\n   assign ibuffer_room2_more = ~dec_ib2_valid_d & ~dec_i1_cancel_e1;\n\n   assign pmu_instr_aligned[1:0] = { i1_shift, i0_shift };\n\n   assign pmu_align_stall = i0_valid & ~ibuffer_room1_more;\n\n   // compute how many bytes are being shifted from f0\n\n   assign shift_2B = i0_shift & ~i1_shift & first2B;\n\n\n   assign shift_4B = (i0_shift & ~i1_shift & first4B) |\n                     (i0_shift &  i1_shift & first2B & second2B);\n\n   assign shift_6B = (i0_shift &  i1_shift & first2B & second4B) |\n                     (i0_shift &  i1_shift & first4B & third2B);\n\n   assign shift_8B = i0_shift &  i1_shift & first4B & third4B;\n\n   // exact equations for the queue logic\n   assign f0_shift_2B = (shift_2B & f0val[0]) |\n                        ((shift_4B | shift_6B | shift_8B) & f0val[0] & ~f0val[1]);\n\n   assign f0_shift_4B = (shift_4B & f0val[1]) |\n                        ((shift_6B & shift_8B) & f0val[1] & ~f0val[2]);\n\n\n   assign f0_shift_6B = (shift_6B & f0val[2]) |\n                        (shift_8B & f0val[2] & ~f0val[3]);\n\n   //assign f0_shift_8B =  shift_8B & f0val[3];\n\n\n\n   // f0 valid states\n   //\n   // 11111111\n   // 11111110\n   // 11111100\n   // 11111000\n   // 11110000\n\n   // 11100000\n   // 11000000\n   // 10000000\n   // 00000000\n\n   assign f1_shift_2B = (f0val[2] & ~f0val[3] & shift_8B) |\n                        (f0val[1] & ~f0val[2] & shift_6B) |\n                        (f0val[0] & ~f0val[1] & shift_4B);\n\n   assign f1_shift_4B = (f0val[1] & ~f0val[2] & shift_8B) |\n                        (f0val[0] & ~f0val[1] & shift_6B);\n\n   assign f1_shift_6B = (f0val[0] & ~f0val[1] & shift_8B);\n\n\n\nendmodule\n\nmodule eh2_ifu_predecode_ctl\nimport eh2_pkg::*;\n  (\n   input logic [31:0] inst,\n\n   output eh2_predecode_pkt_t predecode\n   );\n\n   logic [31:0] i;\n\n   assign i[31:0] = inst[31:0];\n\n\n\n// full decode\nassign predecode.lsu = (!i[31]&!i[30]&!i[29]&!i[24]&!i[23]&!i[22]&!i[21]&!i[20]&!i[14]\n    &i[13]&!i[12]&!i[6]&i[5]&!i[4]&i[3]&i[2]&i[1]&i[0]) | (!i[31]&!i[30]\n    &!i[29]&i[27]&!i[14]&i[13]&!i[12]&!i[6]&i[5]&!i[4]&i[3]&i[2]&i[1]\n    &i[0]) | (!i[28]&!i[27]&!i[14]&i[13]&!i[12]&!i[6]&i[5]&!i[4]&i[3]\n    &i[2]&i[1]&i[0]) | (!i[13]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n    !i[14]&!i[13]&!i[6]&!i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[14]&!i[12]\n    &!i[6]&!i[4]&!i[3]&!i[2]&i[1]&i[0]);\n\nassign predecode.mul = (!i[31]&!i[29]&!i[28]&i[27]&!i[26]&!i[25]&i[14]&i[13]&!i[12]&!i[6]\n    &i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[28]&i[27]&!i[26]\n    &!i[25]&i[14]&!i[13]&i[12]&!i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n    !i[31]&i[29]&!i[28]&i[27]&!i[26]&!i[25]&!i[23]&!i[20]&i[14]&!i[13]\n    &i[12]&!i[6]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&i[29]&!i[28]&i[27]\n    &!i[26]&!i[25]&!i[21]&i[20]&i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[3]&!i[2]\n    &i[1]&i[0]) | (!i[31]&i[29]&!i[28]&i[27]&!i[26]&!i[25]&!i[24]&!i[22]\n    &i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&i[30]\n    &i[29]&!i[28]&i[27]&!i[26]&!i[25]&i[22]&i[14]&!i[13]&i[12]&!i[6]&i[4]\n    &!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&!i[28]&i[27]&!i[26]\n    &!i[14]&!i[13]&i[12]&!i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]\n    &i[29]&!i[28]&i[27]&!i[26]&!i[25]&i[24]&i[21]&i[14]&!i[13]&i[12]&!i[6]\n    &i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&!i[30]&i[29]&!i[28]&i[27]\n    &!i[26]&!i[25]&i[23]&i[14]&!i[13]&i[12]&!i[6]&i[4]&!i[3]&!i[2]&i[1]\n    &i[0]) | (!i[31]&!i[30]&i[29]&!i[28]&i[27]&!i[26]&!i[25]&i[14]&!i[12]\n    &!i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&!i[28]\n    &!i[26]&i[25]&!i[14]&i[13]&!i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n    !i[31]&i[30]&i[29]&!i[28]&!i[27]&!i[26]&!i[25]&i[24]&!i[22]&!i[20]\n    &!i[14]&!i[13]&i[12]&!i[6]&!i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n    !i[31]&i[30]&i[29]&!i[28]&!i[27]&!i[26]&!i[25]&i[24]&!i[22]&!i[21]\n    &!i[14]&!i[13]&i[12]&!i[6]&!i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n    !i[31]&!i[30]&!i[29]&!i[28]&!i[27]&!i[26]&i[25]&!i[14]&!i[6]&i[5]\n    &i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&!i[30]&i[29]&!i[28]&i[27]\n    &!i[26]&!i[25]&i[13]&!i[12]&!i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n    !i[31]&i[30]&!i[29]&!i[28]&i[27]&!i[26]&!i[25]&i[14]&i[13]&!i[6]&i[5]\n    &i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&!i[28]&i[27]\n    &!i[26]&!i[25]&!i[24]&!i[13]&i[12]&!i[6]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n    !i[31]&i[29]&!i[28]&i[27]&!i[26]&!i[25]&i[14]&!i[13]&i[12]&!i[6]&i[5]\n    &i[4]&!i[3]&!i[2]&i[1]&i[0]);\n\nassign predecode.i0_only = (!i[31]&!i[30]&!i[29]&!i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]\n    &!i[22]&!i[21]&!i[20]&!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[13]\n    &!i[11]&!i[10]&!i[9]&!i[8]&!i[7]&!i[6]&!i[5]&!i[4]&i[3]&i[2]&i[1]\n    &i[0]) | (!i[31]&!i[30]&i[29]&i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]\n    &!i[22]&i[21]&!i[20]&!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[11]\n    &!i[10]&!i[9]&!i[8]&!i[7]&i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n    !i[31]&!i[30]&!i[29]&!i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]&!i[22]\n    &!i[21]&!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[11]&!i[10]&!i[9]\n    &!i[8]&!i[7]&i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&!i[30]\n    &!i[29]&!i[28]&!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[13]&!i[12]\n    &!i[11]&!i[10]&!i[9]&!i[8]&!i[7]&!i[6]&!i[5]&!i[4]&i[3]&i[2]&i[1]\n    &i[0]) | (!i[31]&!i[30]&!i[29]&!i[24]&!i[23]&!i[22]&!i[21]&!i[20]\n    &!i[14]&i[13]&!i[12]&!i[6]&i[5]&!i[4]&i[3]&i[2]&i[1]&i[0]) | (!i[31]\n    &!i[30]&!i[29]&!i[28]&!i[27]&!i[26]&i[25]&i[14]&!i[6]&i[5]&i[4]&!i[3]\n    &!i[2]&i[1]&i[0]) | (!i[28]&!i[27]&!i[14]&i[13]&!i[12]&!i[6]&i[5]\n    &!i[4]&i[3]&i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&i[27]&!i[14]\n    &i[13]&!i[12]&!i[6]&i[5]&!i[4]&i[3]&i[2]&i[1]&i[0]) | (i[12]&i[6]\n    &i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (i[13]&i[6]&i[5]&i[4]&!i[3]&!i[2]\n    &i[1]&i[0]);\n\n// split the legal equation in 4 more or less equal parts\n\nassign predecode.legal1 = (!i[31]&!i[30]&i[29]&i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]\n    &!i[22]&i[21]&!i[20]&!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[11]\n    &!i[10]&!i[9]&!i[8]&!i[7]&i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n    !i[31]&!i[30]&!i[29]&i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]&i[22]\n    &!i[21]&i[20]&!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[11]&!i[10]\n    &!i[9]&!i[8]&!i[7]&i[6]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]\n    &!i[30]&!i[29]&!i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]&!i[22]&!i[21]\n    &!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[11]&!i[10]&!i[9]&!i[8]\n    &!i[7]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&i[30]&i[29]&!i[28]\n    &!i[26]&!i[25]&i[24]&!i[22]&!i[20]&!i[6]&!i[5]&i[4]&!i[3]&i[1]&i[0]) | (\n    !i[31]&i[30]&i[29]&!i[28]&!i[26]&!i[25]&i[24]&!i[22]&!i[21]&!i[6]\n    &!i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&i[30]&i[29]&!i[28]&!i[26]\n    &!i[25]&!i[23]&!i[22]&!i[20]&!i[6]&!i[5]&i[4]&!i[3]&i[1]&i[0]);\n\nassign predecode.legal2 = (!i[31]&i[30]&i[29]&!i[28]&!i[26]&!i[25]&!i[24]&!i[23]&!i[21]&!i[6]\n    &!i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&!i[28]&!i[26]\n    &i[25]&i[13]&!i[6]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&!i[28]&i[27]&!i[26]\n    &!i[25]&!i[24]&!i[6]&!i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&!i[30]\n    &i[29]&!i[28]&!i[26]&!i[25]&i[13]&!i[12]&!i[6]&i[4]&!i[3]&i[1]&i[0]) | (\n    !i[31]&!i[29]&!i[28]&!i[27]&!i[26]&!i[25]&!i[13]&!i[12]&!i[6]&i[4]\n    &!i[3]&i[1]&i[0]) | (!i[31]&i[30]&!i[28]&!i[26]&!i[25]&i[14]&!i[6]\n    &!i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&!i[28]&!i[26]\n    &!i[13]&i[12]&i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]\n    &!i[28]&!i[27]&!i[26]&!i[25]&!i[6]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]\n    &i[30]&i[29]&!i[28]&!i[26]&!i[25]&!i[13]&i[12]&i[5]&i[4]&!i[3]&!i[2]\n    &i[1]&i[0]) | (!i[31]&i[30]&!i[28]&i[27]&!i[26]&!i[25]&!i[13]&i[12]\n    &!i[6]&i[4]&!i[3]&i[1]&i[0]);\n\nassign predecode.legal3 = (!i[31]&!i[29]&!i[28]&!i[26]&!i[25]\n    &i[14]&!i[6]&i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]&i[29]&!i[28]&i[27]\n    &!i[26]&!i[25]&!i[13]&i[12]&!i[6]&i[4]&!i[3]&i[1]&i[0]) | (!i[31]\n    &!i[30]&!i[29]&!i[28]&!i[27]&!i[26]&!i[6]&i[5]&i[4]&!i[3]&i[1]&i[0]) | (\n    !i[31]&!i[30]&!i[29]&!i[28]&!i[26]&i[14]&!i[6]&i[5]&i[4]&!i[3]&i[1]\n    &i[0]) | (!i[14]&!i[13]&!i[12]&i[6]&i[5]&!i[4]&!i[3]&i[1]&i[0]) | (\n    i[14]&i[6]&i[5]&!i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[14]&!i[13]&i[5]\n    &!i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[12]&!i[6]&!i[5]&i[4]&!i[3]&i[1]\n    &i[0]) | (!i[13]&i[12]&i[6]&i[5]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]\n    &!i[30]&!i[29]&!i[28]&!i[27]&!i[26]&!i[25]&!i[24]&!i[23]&!i[22]&!i[21]\n    &!i[20]&!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[13]&!i[11]&!i[10]\n    &!i[9]&!i[8]&!i[7]&!i[6]&!i[5]&!i[4]&i[3]&i[2]&i[1]&i[0]);\n\nassign predecode.legal4 = (!i[31]&!i[30]&!i[29]&!i[28]&!i[19]&!i[18]&!i[17]&!i[16]&!i[15]&!i[14]&!i[13]\n    &!i[12]&!i[11]&!i[10]&!i[9]&!i[8]&!i[7]&!i[6]&!i[5]&!i[4]&i[3]&i[2]\n    &i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&!i[24]&!i[23]&!i[22]&!i[21]&!i[20]\n    &!i[14]&i[13]&!i[12]&i[5]&!i[4]&i[3]&i[2]&i[1]&i[0]) | (!i[28]&!i[27]\n    &!i[14]&i[13]&!i[12]&i[5]&!i[4]&i[3]&i[2]&i[1]&i[0]) | (i[13]&i[6]\n    &i[5]&i[4]&!i[3]&!i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[29]&i[27]&!i[14]\n    &i[13]&!i[12]&i[5]&!i[4]&i[3]&i[2]&i[1]&i[0]) | (!i[31]&!i[30]&!i[28]\n    &!i[26]&!i[25]&i[14]&!i[12]&!i[6]&i[4]&!i[3]&i[1]&i[0]) | (i[6]&i[5]\n    "}
{"text": "&!i[4]&i[3]&i[2]&i[1]&i[0]) | (!i[14]&!i[12]&!i[6]&!i[4]&!i[3]&!i[2]\n    &i[1]&i[0]) | (!i[13]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]&i[0]) | (\n    i[13]&!i[6]&!i[5]&i[4]&!i[3]&i[1]&i[0]) | (!i[6]&i[4]&!i[3]&i[2]&i[1]\n    &i[0]);\n\n\n\nendmodule\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n//********************************************************************************\n// Function: Branch predictor\n// Comments:\n//\n//\n//********************************************************************************\n\nmodule eh2_ifu_bp_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n\n   input logic clk,\n   input logic active_clk,\n   input logic rst_l,\n\n   input logic ifc_select_tid_f1, // TID at F1\n   input logic ic_hit_f2,      // Icache hit, enables F2 address capture\n\n   input logic [31:1] ifc_fetch_addr_bf, // look up btb address\n   input [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifc_fetch_btb_rd_addr_f1, // btb read hash\n   input [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifc_fetch_btb_rd_addr_p1_f1, // btb read hash\n   input logic [31:1] ifc_fetch_addr_f1, // look up btb address\n   input logic ifc_fetch_req_f1,  // F1 valid\n   input logic ifc_fetch_req_f2,  // F2 valid\n\n   input eh2_br_tlu_pkt_t dec_tlu_br0_wb_pkt, // BP commit update packet, includes errors\n   input eh2_br_tlu_pkt_t dec_tlu_br1_wb_pkt, // BP commit update packet, includes errors\n   input logic [pt.BHT_GHR_SIZE-1:0] dec_tlu_br0_fghr_wb, // fghr to bp\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br0_index_wb, // bp index\n   input logic [pt.BHT_GHR_SIZE-1:0] dec_tlu_br1_fghr_wb, // fghr to bp\n   input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br1_index_wb, // bp index\n\n   input logic [$clog2(pt.BTB_SIZE)-1:0] dec_fa_error_index, // Fully associt btb error index\n\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_flush_lower_wb, // used to move EX4 RS to EX1 and F\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_flush_leak_one_wb, // don't hit for leak one fetches\n\n   input logic dec_tlu_bpred_disable, // disable all branch prediction\n\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_btb_write_kill, // Kill writes while working on forward progress after a branch error\n\n   input logic        exu_i0_br_ret_e4, // EX4 ret stack update\n   input logic        exu_i1_br_ret_e4, // EX4 ret stack update\n   input logic        exu_i0_br_call_e4, // EX4 ret stack update\n   input logic        exu_i1_br_call_e4, // EX4 ret stack update\n   input logic dec_i0_tid_e4, // needed to maintain RS in BP\n   input logic dec_i1_tid_e4,\n\n   input logic [pt.NUM_THREADS-1:0][31:1] exu_flush_path_final, // flush fetch address\n\n   input eh2_predict_pkt_t [pt.NUM_THREADS-1:0] exu_mp_pkt, // mispredict packet(s)\n   input logic [pt.NUM_THREADS-1:0][pt.BTB_TOFFSET_SIZE-1:0] exu_mp_toffset, // target offset\n\n   input logic [pt.NUM_THREADS-1:0][pt.BHT_GHR_SIZE-1:0] exu_mp_eghr, // execute ghr (for patching fghr)\n   input logic [pt.NUM_THREADS-1:0][pt.BHT_GHR_SIZE-1:0] exu_mp_fghr,                    // Mispredict fghr\n   input logic [pt.NUM_THREADS-1:0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_mp_index,         // Mispredict index\n   input logic [pt.NUM_THREADS-1:0][pt.BTB_BTAG_SIZE-1:0] exu_mp_btag,                   // Mispredict btag\n\n   input logic [pt.NUM_THREADS-1:0] exu_flush_final, // all flushes\n\n   // For sram btb\n   output logic                                              btb_sram_rw,\n   output logic [1:0] [pt.BTB_ADDR_HI:1]                     btb_sram_rw_addr,\n   output logic [1:0] [pt.BTB_ADDR_HI:1]                     btb_sram_rw_addr_f1,\n   output logic [1:0] [pt.BTB_BTAG_SIZE-1:0]                 btb_sram_rd_tag_f1,\n   output logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0] btb_sram_wr_data,\n\n   output logic btb_wr_stall, // simul MPs, stall fetch for 2 cycles\n   input eh2_btb_sram_pkt btb_sram_pkt,\n\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank0_rd_data_f1,\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank1_rd_data_f1,\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank2_rd_data_f1,\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank3_rd_data_f1,\n\n\n   // end sram btb ports\n\n   output logic ifu_bp_kill_next_f2, // kill next fetch, taken target found\n   output logic [31:1] ifu_bp_btb_target_f2, //  predicted target PC\n   output logic [3:1] ifu_bp_inst_mask_f2, // tell ic which valids to kill because of a taken branch, right justified\n\n   output logic [pt.BHT_GHR_SIZE-1:0] ifu_bp_fghr_f2, // fetch ghr\n\n   output logic [3:0] ifu_bp_way_f2, // way\n   output logic [3:0] ifu_bp_ret_f2, // predicted ret\n   output logic [3:0] ifu_bp_hist1_f2, // history counters for all 4 potential branches, bit 1, right justified\n   output logic [3:0] ifu_bp_hist0_f2, // history counters for all 4 potential branches, bit 0, right justified\n   output logic [pt.BTB_TOFFSET_SIZE-1:0] ifu_bp_poffset_f2, // predicted target\n   output logic [3:0] ifu_bp_pc4_f2, // pc4 indication, right justified\n   output logic [3:0] ifu_bp_valid_f2, // branch valid, right justified\n\n   output logic [3:0] [$clog2(pt.BTB_SIZE)-1:0]    ifu_bp_fa_index_f2, // predicted branch index (fully associative option)\n\n   input  logic       scan_mode\n   );\n\n   localparam  BTB_DWIDTH =  pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5;\n   localparam  BTB_DWIDTH_TOP =  int'(pt.BTB_TOFFSET_SIZE)+int'(pt.BTB_BTAG_SIZE)+4;\n`define RV_TAG BTB_DWIDTH-1:BTB_DWIDTH-pt.BTB_BTAG_SIZE\n\n   localparam BTB_FA_INDEX = $clog2(pt.BTB_SIZE)-1;\n   localparam FA_CMP_LOWER = $clog2(pt.ICACHE_LN_SZ);\n   localparam FA_TAG_END_UPPER= 5+int'(pt.BTB_TOFFSET_SIZE)+int'(FA_CMP_LOWER)-1; // must cast to int or vcs build fails\n   localparam FA_TAG_START_LOWER = 3+int'(pt.BTB_TOFFSET_SIZE)+int'(FA_CMP_LOWER);\n   localparam FA_TAG_END_LOWER = 5+int'(pt.BTB_TOFFSET_SIZE);\n   localparam PC4=4;\n   localparam BOFF=3;\n   localparam CALL=2;\n   localparam RET=1;\n   localparam BV=0;\n\n   localparam LRU_SIZE=pt.BTB_ARRAY_DEPTH;\n   localparam NUM_BHT_LOOP = (pt.BHT_ARRAY_DEPTH > 16 ) ? 16 : pt.BHT_ARRAY_DEPTH;\n   localparam NUM_BHT_LOOP_INNER_HI =  (pt.BHT_ARRAY_DEPTH > 16 ) ? pt.BHT_ADDR_LO+3 : pt.BHT_ADDR_HI;\n   localparam NUM_BHT_LOOP_OUTER_LO =  (pt.BHT_ARRAY_DEPTH > 16 ) ? pt.BHT_ADDR_LO+4 : pt.BHT_ADDR_LO;\n   localparam BHT_NO_ADDR_MATCH     =  (pt.BHT_ARRAY_DEPTH <= 16 );\n\n   logic [31:1]       ifc_fetch_addr_f2; // to tgt calc\n\n   logic [pt.NUM_THREADS-1:0] exu_mp_valid_write, middle_of_bank;\n   logic [pt.NUM_THREADS-1:0] exu_mp_ataken;\n   logic [pt.NUM_THREADS-1:0] exu_mp_valid; // conditional branch mispredict\n   logic [pt.NUM_THREADS-1:0] exu_mp_boffset; // branch offsett\n   logic [pt.NUM_THREADS-1:0] exu_mp_pc4; // branch is a 4B inst\n   logic [pt.NUM_THREADS-1:0] exu_mp_call; // branch is a call inst\n   logic [pt.NUM_THREADS-1:0] exu_mp_ret; // branch is a ret inst\n   logic [pt.NUM_THREADS-1:0] exu_mp_ja; // branch is a jump always\n   logic [pt.NUM_THREADS-1:0] exu_mp_bank; // write bank; based on branch PC[3:2]\n   logic [pt.NUM_THREADS-1:0] [1:0] exu_mp_hist; // new history\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_TOFFSET_SIZE-1:0] exu_mp_tgt; // target offset\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_mp_addr; // BTB/BHT address\n\n   logic [1:0] [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0] btb_wr_data;\n\n   logic                                   dec_tlu_br0_v_wb; // WB stage history update\n   logic [1:0]                             dec_tlu_br0_hist_wb; // new history\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br0_addr_wb; // addr\n   logic                                   dec_tlu_br0_bank_wb; // write bank; based on branch PC[3:2]\n   logic                                   dec_tlu_br0_error_wb; // error; invalidate bank\n   logic                                   dec_tlu_br0_start_error_wb; // error; invalidate all 4 banks in fg\n\n   logic                                   dec_tlu_br1_v_wb; // WB stage history update\n   logic [1:0]                             dec_tlu_br1_hist_wb; // new history\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br1_addr_wb; // addr\n   logic                                   dec_tlu_br1_bank_wb; // write bank; based on branch PC[3:2]\n   logic                                   dec_tlu_br1_error_wb; // error\n   logic                                   dec_tlu_br1_start_error_wb; // error; invalidate all 4 banks in fg\n\n   logic [1:0]        use_mp_way, use_mp_way_p1;\n   logic [pt.NUM_THREADS-1:0] [pt.RET_STACK_SIZE-1:0][31:0] rets_out, rets_in;\n   logic [pt.NUM_THREADS-1:0] [pt.RET_STACK_SIZE-1:0]   rsenable;\n   logic                                ifc_select_tid_f2;\n\n   logic [pt.NUM_THREADS-1:0][pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] mp_hashed;\n   logic [pt.BTB_TOFFSET_SIZE-1:0]       btb_rd_tgt_f2;\n   logic              btb_rd_pc4_f2,  btb_rd_call_f2, btb_rd_ret_f2;\n   logic [2:1]        bp_total_branch_offset_f2;\n\n   logic [31:1]       bp_btb_target_adder_f2;\n   logic [31:1]       bp_rs_call_target_f2;\n   logic [pt.NUM_THREADS-1:0]         rs_push, rs_pop, rs_hold, rs_push_mp, rs_pop_mp, fetch_mp_collision_f1, fetch_mp_collision_f2,fetch_mp_collision_p1_f1, fetch_mp_collision_p1_f2;\n   logic [pt.NUM_THREADS-1:0][pt.BTB_BTAG_SIZE-1:0] btb_wr_tag;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] btb_rd_addr_f1, btb_rd_addr_p1_f1, btb_rd_addr_f2, btb_rd_addr_p1_f2;\n   logic [pt.BTB_BTAG_SIZE-1:0] fetch_rd_tag_f1, fetch_rd_tag_p1_f1, fetch_rd_tag_f2, fetch_rd_tag_p1_f2;\n   logic [1:0]         btb_wr_en_error_way0, btb_wr_en_error_way1;\n\n   logic [pt.BTB_BTAG_SIZE-1:0] fetch_rd_tag_bf, fetch_rd_tag_p1_bf;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] btb_rd_addr_bf, btb_rd_addr_p1_bf;\n   logic btb_sram_wr_t0, btb_sram_wr_t1;\n   logic [pt.BTB_ADDR_HI:1] btb_sram_wr_addr, btb_sram_wr_addr_f1;\n   logic [1:0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] btb_sram_rd_index, btb_sram_rd_index_f1;\n\n   logic [pt.NUM_THREADS-1:0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] btb_wr_addr;\n\n\n   logic               dec_tlu_error_wb, dec_tlu_all_banks_error_wb, dec_tlu_br0_middle_wb, dec_tlu_br1_middle_wb;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]        btb_error_addr_wb;\n   logic               dec_tlu_error_bank_wb;\n   logic branch_error_collision_f1, branch_error_collision_p1_f1;\n\n   logic [2:0] fgmask_f2;\n   logic [1:0] branch_error_bank_conflict_f1, branch_error_bank_conflict_f2;\n   logic [pt.BHT_GHR_SIZE-1:0] merged_ghr;\n   logic [pt.NUM_THREADS-1:0][pt.BHT_GHR_SIZE-1:0] fghr_ns, fghr;\n   logic [2:0] num_valids;\n   logic [LRU_SIZE-1:0] btb_lru_b0_f, btb_lru_b0_hold, btb_lru_b0_ns, btb_lru_b1_f, btb_lru_b1_hold, btb_lru_b1_ns,\n                        fetch_wrindex_dec, fetch_wrindex_p1_dec, fetch_wrlru_b0, fetch_wrlru_b1, fetch_wrlru_p1_b0,\n                        fetch_wrlru_p1_b1, wr0_b0w0, wr0_b0w1, wr0_b1w0, wr0_b1w1, wr1_b0w0, wr1_b0w1, wr1_b1w0, wr1_b1w1;\n\n   logic [pt.NUM_THREADS-1:0][LRU_SIZE-1:0] mp_wrindex_dec, mp_wrlru_b0, mp_wrlru_b1;\n   logic [1:0]          btb_lru_rd_f2, btb_lru_rd_p1_f2,lru_update_valid_f2, lru_update_valid_p1_f2;\n\n   logic [1:0] tag_match_way0_f2, tag_match_way1_f2;\n   logic [3:0] way_raw, bht_dir_f2, btb_sel_f2, wayhit_f2, vwayhit_f2, wayhit_p1_f2;\n   logic [3:0] btb_sel_mask_f2, bht_valid_f2, bht_force_taken_f2;\n\n   logic [pt.NUM_THREADS-1:0] leak_one_f1, leak_one_f2, exu_mp_way, exu_mp_way_f;\n   logic ifc_fetch_req_f2_raw;\n\n   logic [LRU_SIZE-1:0][BTB_DWIDTH-1:0]  btb_bank0_rd_data_way0_out ;\n   logic [LRU_SIZE-1:0][BTB_DWIDTH-1:0]  btb_bank1_rd_data_way0_out ;\n\n   logic [LRU_SIZE-1:0][BTB_DWIDTH-1:0]  btb_bank0_rd_data_way1_out ;\n   logic [LRU_SIZE-1:0][BTB_DWIDTH-1:0]  btb_bank1_rd_data_way1_out ;\n\n   logic                [BTB_DWIDTH-1:0] btb_bank0_rd_data_way0_f2_in ;\n   logic                [BTB_DWIDTH-1:0] btb_bank1_rd_data_way0_f2_in ;\n   logic                [BTB_DWIDTH-1:0] btb_bank0_rd_data_way1_f2_in ;\n   logic                [BTB_DWIDTH-1:0] btb_bank1_rd_data_way1_f2_in ;\n\n   logic                [BTB_DWIDTH-1:0] btb_bank0_rd_data_way0_p1_f2_in ;\n   logic                [BTB_DWIDTH-1:0] btb_bank1_rd_data_way0_p1_f2_in ;\n   logic                [BTB_DWIDTH-1:0] btb_bank0_rd_data_way1_p1_f2_in ;\n   logic                [BTB_DWIDTH-1:0] btb_bank1_rd_data_way1_p1_f2_in ;\n\n\n   logic                [BTB_DWIDTH-1:0] btb_bank0_rd_data_way0_f2, btb_bank0_rd_data_way0_p1_f2;\n   logic                [BTB_DWIDTH-1:0] btb_bank1_rd_data_way0_f2, btb_bank1_rd_data_way0_p1_f2;\n\n   logic                [BTB_DWIDTH-1:0] btb_bank0_rd_data_way1_f2, btb_bank0_rd_data_way1_p1_f2;\n   logic                [BTB_DWIDTH-1:0] btb_bank1_rd_data_way1_f2, btb_bank1_rd_data_way1_p1_f2;\n   logic                [BTB_DWIDTH-1:0] btb_vbank0_rd_data_f2, btb_vbank1_rd_data_f2, btb_vbank2_rd_data_f2, btb_vbank3_rd_data_f2;\n\n   logic                                         final_h;\n   logic                                         btb_fg_crossing_f2;\n\n\n   logic [1:0]                                   bht_vbank0_rd_data_f2, bht_vbank1_rd_data_f2, bht_vbank2_rd_data_f2, bht_vbank3_rd_data_f2,\n                                                 branch_error_bank_conflict_p1_f1, branch_error_bank_conflict_p1_f2, tag_match_way0_p1_f2, tag_match_way1_p1_f2;\n\n   logic [3:0]                                   btb_vlru_rd_f2, fetch_start_f2, tag_match_vway1_expanded_f2, tag_match_way0_expanded_p1_f2, tag_match_way1_expanded_p1_f2;\n   logic [31:3] fetch_addr_p1_f1, fetch_addr_p1_f2;\n\n   logic dec_tlu_br0_way_wb, dec_tlu_br1_way_wb, dec_tlu_way_wb, dec_tlu_way_wb_f;\n\n   logic                [BTB_DWIDTH-1:0] btb_bank0e_rd_data_f2, btb_bank0e_rd_data_p1_f2;\n   logic                [BTB_DWIDTH-1:0] btb_bank1e_rd_data_f2, btb_bank1e_rd_data_p1_f2;\n\n   logic                [BTB_DWIDTH-1:0] btb_bank0o_rd_data_f2, btb_bank0o_rd_data_p1_f2;\n   logic                [BTB_DWIDTH-1:0] btb_bank1o_rd_data_f2;\n\n   logic [3:0] tag_match_way0_expanded_f2, tag_match_way1_expanded_f2;\n\n\n   logic [1:0] bht_bank0_rd_data_f2 ;\n   logic [1:0] bht_bank1_rd_data_f2 ;\n   logic [1:0] bht_bank2_rd_data_f2 ;\n   logic [1:0] bht_bank3_rd_data_f2 ;\n   logic [1:0] bht_bank0_rd_data_p1_f2 ;\n   logic [1:0] bht_bank1_rd_data_p1_f2 ;\n   logic [1:0] bht_bank2_rd_data_p1_f2 ;\n   logic [pt.NUM_THREADS-1:0][1:0] bht_wr_data0_thr, mp_bank_decoded, mp_bank_decoded_f;\n   logic [1:0] bht_wr_data0, bht_wr_data1, bht_wr_data2, bht_wr_data3;\n   logic [pt.NUM_THREADS-1:0][3:0] bht_wr_en0_thr;\n   logic [3:0]                     bht_wr_en0, bht_wr_en1, bht_wr_en2, bht_wr_en3;\n   logic [3:0] [(pt.BHT_ARRAY_DEPTH/NUM_BHT_LOOP)-1:0][NUM_BHT_LOOP-1:0][1:0]      bht_bank_wr_data ;\n   logic [3:0] [pt.BHT_ARRAY_DEPTH-1:0] [1:0]                bht_bank_rd_data_out ;\n   logic [1:0]                                                bht_bank0_rd_data_f2_in, bht_bank1_rd_data_f2_in, bht_bank2_rd_data_f2_in, bht_bank3_rd_data_f2_in;\n   logic [1:0]                                                bht_bank0_rd_data_p1_f2_in, bht_bank1_rd_data_p1_f2_in, bht_bank2_rd_data_p1_f2_in;\n   logic [3:0] [(pt.BHT_ARRAY_DEPTH/NUM_BHT_LOOP)-1:0]                 bht_bank_clken ;\n   logic [3:0] [(pt.BHT_ARRAY_DEPTH/NUM_BHT_LOOP)-1:0]                 bht_bank_clk   ;\n   logic [3:0] [(pt.BHT_ARRAY_DEPTH/NUM_BHT_LOOP)-1:0][NUM_BHT_LOOP-1:0]           bht_bank_sel   ;\n\n   logic [pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] bht_rd_addr_f1, bht_rd_addr_p1_f1, bht_wr_addr0, bht_wr_addr1, bht_wr_addr2, bht_wr_addr3;\n\n   logic [pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] br0_hashed_wb, br1_hashed_wb, bht_rd_addr_hashed_f1, bht_rd_addr_hashed_p1_f1;\n   logic [pt.NUM_THREADS-1:0] rs_overpop_correct, rsoverpop_valid_ns, rsoverpop_valid_f;\n   logic [pt.NUM_THREADS-1:0] [31:0] rsoverpop_ns, rsoverpop_f;\n   logic [pt.NUM_THREADS-1:0] rsunderpop_valid_ns, rsunderpop_valid_f, rs_underpop_correct,\n                              exu_i0_br_call_e4_thr, exu_i1_br_call_e4_thr, exu_i0_br_ret_e4_thr, exu_i1_br_ret_e4_thr;\n   logic [31:3] adder_pc_in_f2;\n   logic [pt.NUM_THREADS-1:0][31:3] ifc_fetch_adder_prior;\n   logic [3:0] bloc_f2;\n   logic use_fa_plus, btb_sram_rw_f1;\n   logic [3:0] hist0_raw, hist1_raw, pc4_raw, pret_raw;\n   logic [pt.BTB_TOFFSET_SIZE+4:1] btb_sel_data_f2;\n   logic eoc_near;\n   logic [3:1] eoc_mask;\n   logic mp_collision, mp_collision_winner_tid, mp_bht_collision, mp_bht_collision_winner_tid;\n   logic [pt.NUM_THREADS-1:0] fetch_req_val_f2;\n   logic[3:1] btb_vmask_f2;\n   logic [3:1] btb_vmask_raw_f2;\n\n\n   assign dec_tlu_br0_v_wb = dec_tlu_br0_wb_pkt.valid;\n   assign dec_tlu_br0_hist_wb[1:0]  = dec_tlu_br0_wb_pkt.hist[1:0];\n   assign dec_tlu_br0_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = dec_tlu_br0_index_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n   assign dec_tlu_br0_bank_wb  = dec_tlu_br0_wb_pkt.bank;\n   assign dec_tlu_br0_error_wb = dec_tlu_br0_wb_pkt.br_error;\n   assign dec_tlu_br0_middle_wb = dec_tlu_br0_wb_pkt.middle;\n   assign dec_tlu_br0_way_wb = dec_tlu_br0_wb_pkt.way;\n   assign dec_tlu_br0_start_error_wb = dec_tlu_br0_wb_pkt.br_start_error;\n\n   assign dec_tlu_br1_v_wb = dec_tlu_br1_wb_pkt.valid;\n   assign dec_tlu_br1_hist_wb[1:0]  = dec_tlu_br1_wb_pkt.hist[1:0];\n   assign dec_tlu_br1_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = dec_tlu_br1_index_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n   assign dec_tlu_br1_bank_wb  = dec_tlu_br1_wb_pkt.bank;\n   assign dec_tlu_br1_middle_wb = dec_tlu_br1_wb_pkt.middle;\n   assign dec_tlu_br1_error_wb = dec_tlu_br1_wb_pkt.br_error;\n   assign dec_tlu_br1_way_wb = dec_tlu_br1_wb_pkt.way;\n   assign dec_tlu_br1_start_error_wb = dec_tlu_br1_wb_pkt.br_start_error;\n\n\n\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] t0_error_lockout_index_ns, t1_error_lockout_index_ns, t0_error_lockout_index, t1_error_lockout_index;\n   logic error_mp_collision, dec_tlu_error_tid;\n\n\n   // ----------------------------------------------------------------------\n   // READ\n   // ----------------------------------------------------------------------\n\n   // hash the incoming fetch PC, first guess at hashing algorithm\n\n   // 2way SA\n   // Index is hi:3\n   //\n   if (pt.NUM_THREADS == 1) begin\n      assign btb_wr_data[1] = '0;\n   end\n\n   logic [31:3] fetch_addr_p1_bf;\n   assign fetch_addr_p1_bf[31:3] = ifc_fetch_addr_bf[31:3] + 29'b1;\n   eh2_btb_addr_hash #(.pt(pt)) f1hash(.pc(ifc_fetch_addr_bf[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(btb_rd_addr_bf[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n   eh2_btb_addr_hash #(.pt(pt)) f1hash_p1(.pc(fetch_addr_p1_bf[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(btb_rd_addr_p1_bf[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n\n\n\n   assign fetch_addr_p1_f1[31:3] = ifc_fetch_addr_f1[31:3] + 29'b1;\n\n   // Timing\n   assign btb_rd_addr_f1 = ifc_fetch_btb_rd_addr_f1;\n   assign btb_rd_addr_p1_f1 = ifc_fetch_btb_rd_addr_p1_f1;\n\n\n   // Put the table below in a file and run espresso to generate the btb_sel_f2 and btb_vmask_raw_f2 equations\n   // espresso -oeqntott -eeat <file> | addassign\n   //\n   // .i 4\n   // .o 7\n   // .ilb bht_dir_f2[3] bht_dir_f2[2] bht_dir_f2[1] bht_dir_f2[0]\n   // .ob btb_sel_f2[3] btb_sel_f2[2] btb_sel_f2[1] btb_sel_f2[0] btb_vmask_raw_f2[3] btb_vmask_raw_f2[2] btb_vmask_raw_f2[1]\n   // .type fr\n   // ##dir[3:0] sel[3:0] mask[3:1]\n   //   ---1 0001 000\n   //   --10 0010 001\n   //   -100 0100 010\n   //   1000 1000 100\n   //\n\nassign btb_sel_f2[3] = (~bht_dir_f2[2] & ~bht_dir_f2[1] & ~bht_dir_f2[0]);\n\nassign btb_sel_f2[2] = (bht_dir_f2[2] & ~bht_dir_f2[1] & ~bht_dir_f2[0]);\n\nassign btb_sel_f2[1] = (bht_dir_f2[1] & ~bht_dir_f2[0]);\n\nassign btb_sel_f2[0] = (bht_dir_f2[0]);\n\nassign btb_vmask_raw_f2[3] = (~bht_dir_f2[2] & ~bht_dir_f2[1] & ~bht_dir_f2[0]);\n\nassign btb_vmask_raw_f2[2] = (bht_dir_f2[2] & ~b"}
{"text": "ht_dir_f2[1] & ~bht_dir_f2[0]);\n\nassign btb_vmask_raw_f2[1] = (bht_dir_f2[1] & ~bht_dir_f2[0]);\n\n   // vmask[0] is always 1\n   assign btb_vmask_f2[3:1] = { btb_vmask_raw_f2[3],\n                               |btb_vmask_raw_f2[3:2],\n                               |btb_vmask_raw_f2[3:1]};\n\n\n   assign fetch_start_f2[3:0] = decode2_4(ifc_fetch_addr_f2[2:1]);\n\n   rvdff #(2) fetch_ff (.*, .clk(active_clk),\n                         .din({dec_tlu_way_wb, ifc_fetch_req_f1}),\n                        .dout({dec_tlu_way_wb_f, ifc_fetch_req_f2_raw}));\n\n\n   eh2_predict_pkt_t exu_mp_pkt_t1_f;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_mp_index_t1_f;\n   logic [pt.BTB_BTAG_SIZE-1:0]          exu_mp_btag_t1_f;\n   logic [pt.BTB_TOFFSET_SIZE-1:0]       exu_mp_toffset_t1_f;\n\n\nif(pt.BTB_USE_SRAM) begin\n   //--------------------------------------------------------------------------------\n   // BTB SRAM support\n\n   // MP stalls fetching to allow write. Multiple thread MPs stalls for multiple cycles\n   //\n   // Handle T0/T1 simul followed by T0/T1 simul\n\n   rvdffe #($bits(eh2_btb_sram_pkt)) srampkt (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_sram_pkt),\n                    .dout       ({wayhit_f2[3:0], wayhit_p1_f2[3:0],tag_match_way0_f2[1:0],tag_match_way0_p1_f2[1:0], tag_match_vway1_expanded_f2[3:0]}));\n   rvdffe #(BTB_DWIDTH) btb_vbank0_data_out (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_vbank0_rd_data_f1[BTB_DWIDTH-1:0]),\n                    .dout       (btb_vbank0_rd_data_f2[BTB_DWIDTH-1:0]));\n   rvdffe #(BTB_DWIDTH) btb_vbank1_data_out (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_vbank1_rd_data_f1[BTB_DWIDTH-1:0]),\n                    .dout       (btb_vbank1_rd_data_f2[BTB_DWIDTH-1:0]));\n   rvdffe #(BTB_DWIDTH) btb_vbank2_data_out (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_vbank2_rd_data_f1[BTB_DWIDTH-1:0]),\n                    .dout       (btb_vbank2_rd_data_f2[BTB_DWIDTH-1:0]));\n   rvdffe #(BTB_DWIDTH) btb_vbank3_data_out (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_vbank3_rd_data_f1[BTB_DWIDTH-1:0]),\n                    .dout       (btb_vbank3_rd_data_f2[BTB_DWIDTH-1:0]));\n\n   rvdff #(pt.BTB_ADDR_HI+1) stallff (.*, .clk(active_clk),\n                         .din({btb_sram_wr_addr[pt.BTB_ADDR_HI:1], btb_sram_rw}),\n                        .dout({btb_sram_wr_addr_f1[pt.BTB_ADDR_HI:1], btb_sram_rw_f1}));\n\n   assign btb_wr_stall = btb_sram_rw_f1;\n\n\n   assign btb_sram_wr_t0 = exu_mp_pkt[0].misp & ~exu_mp_pkt[0].valid & ~leak_one_f2[0] & ~dec_tlu_error_wb & ~dec_tlu_bpred_disable & ~error_mp_collision;\n\n\nlogic btb_delayed_wr_t1;\n   if(pt.NUM_THREADS > 1) begin\n      logic btb_delayed_wr_t1_ns, btb_delayed_wr_t1_raw;\n\n      // flop T1s mp info if there's a simultaneous MP on both threads\n      rvdffe #($bits(eh2_predict_pkt_t)+pt.BTB_ADDR_HI+1-pt.BTB_ADDR_LO+pt.BTB_BTAG_SIZE+pt.BTB_TOFFSET_SIZE) btb_mpt1_info (.*,\n                             .en(btb_delayed_wr_t1_ns),\n                             .din        ({exu_mp_pkt[1], exu_mp_index[1], exu_mp_btag[1], exu_mp_toffset[1]}),\n                             .dout       ({exu_mp_pkt_t1_f, exu_mp_index_t1_f, exu_mp_btag_t1_f, exu_mp_toffset_t1_f}));\n\n\n      // MPs from both threads simultaneously need to stall and write back to back, assuming they aren't to the same branch\n      assign btb_delayed_wr_t1_ns = btb_sram_wr_t0 & btb_sram_wr_t1;\n\n      assign btb_sram_wr_t1 = exu_mp_pkt[1].misp & ~exu_mp_pkt[1].valid & ~leak_one_f2[1] & ~dec_tlu_error_wb & ~dec_tlu_bpred_disable & ~error_mp_collision;\n\n      // Write address mux. T0 has priority, but T1 will be written next if there's a simultaneous MP without a collision.\n      // Note that mp_index bit 3 is really PC[3] used for the bank select. Not included in index hash.\n      // Collisions drop T1 update.\n      // Note, using delayed mp_pkt interface from flop BTB for simplicity. Could flop locally instead.\n      assign btb_sram_wr_addr[pt.BTB_ADDR_HI:1] = dec_tlu_error_wb ? {btb_error_addr_wb, dec_tlu_error_bank_wb, dec_tlu_way_wb} :\n                                                  btb_sram_wr_t0 ?  // T0 MP\n                                                  {exu_mp_index[0], exu_mp_pkt[0].bank, exu_mp_pkt[0].way} :\n                                                  btb_delayed_wr_t1 ? // T1 MP delayed because there was also a T0 MP\n                                                  {exu_mp_index_t1_f, exu_mp_pkt_t1_f.bank, exu_mp_pkt_t1_f.way} :\n                                                  // T1 MP\n                                                  {exu_mp_index[1], exu_mp_pkt[1].bank, exu_mp_pkt[1].way} ;\n\n\n      assign btb_sram_wr_data[BTB_DWIDTH-1:0] = btb_sram_wr_t0 ? btb_wr_data[0] :\n                                                btb_delayed_wr_t1 ? {exu_mp_btag_t1_f[pt.BTB_BTAG_SIZE-1:0], exu_mp_toffset_t1_f[pt.BTB_TOFFSET_SIZE-1:0],\n                                                                          exu_mp_pkt_t1_f.pc4, exu_mp_pkt_t1_f.boffset, exu_mp_pkt_t1_f.pcall | exu_mp_pkt_t1_f.pja,\n                                                                          exu_mp_pkt_t1_f.pret | exu_mp_pkt_t1_f.pja, ~dec_tlu_error_wb} :\n                                                btb_wr_data[1];\n\n      rvdff #(1) simul_ff (.*, .clk(active_clk),\n                           .din({btb_delayed_wr_t1_ns}),\n                           .dout({btb_delayed_wr_t1_raw}));\n\n      assign btb_delayed_wr_t1 = (btb_delayed_wr_t1_raw & ~mp_collision) | dec_tlu_error_wb;\n\n   end\n   else begin\n      assign btb_sram_wr_t1 = '0;\n      assign btb_delayed_wr_t1 = '0;\n      // Note that mp_index bit 3 is really PC[3] used for the bank select. Not included in index hash.\n      assign btb_sram_wr_addr[pt.BTB_ADDR_HI:1] = dec_tlu_error_wb ? {btb_error_addr_wb, dec_tlu_error_bank_wb, dec_tlu_way_wb} :\n                                                  {exu_mp_index[0], exu_mp_pkt[0].bank, exu_mp_pkt[0].way};\n\n      assign btb_sram_wr_data[BTB_DWIDTH-1:0] = btb_wr_data[0];\n   end\n\n   assign btb_sram_rw = btb_sram_wr_t0 | btb_sram_wr_t1 | btb_delayed_wr_t1 | dec_tlu_error_wb;\n\n\n\n   // index 1 bit 3 contains the original bit 3, not the inc'd. index 1 bit 3 is only used for bank ordering in the sram muxing code.\n   assign btb_sram_rd_index[0] =  ifc_fetch_addr_bf[3] ? btb_rd_addr_p1_bf[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] : btb_rd_addr_bf[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n   assign btb_sram_rd_index[1] = ~ifc_fetch_addr_bf[3] ? {btb_rd_addr_p1_bf[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1], ifc_fetch_addr_bf[3]} : btb_rd_addr_bf[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n\n   assign btb_sram_rw_addr[0] = btb_sram_rw ? {btb_sram_wr_addr[pt.BTB_ADDR_HI:1]} :\n                                {btb_sram_rd_index[0], ifc_fetch_addr_bf[2:1]};\n   assign btb_sram_rw_addr[1] = btb_sram_rw ? {btb_sram_wr_addr[pt.BTB_ADDR_HI:1]} :\n                                {btb_sram_rd_index[1], ifc_fetch_addr_bf[2:1]};\n\n   // for timing, don't use bf read address for valids\n   assign btb_sram_rd_index_f1[0] =  ifc_fetch_addr_f1[3] ?\n                                     ifc_fetch_btb_rd_addr_p1_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] :\n                                     ifc_fetch_btb_rd_addr_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n   assign btb_sram_rd_index_f1[1] = ~ifc_fetch_addr_f1[3] ?\n                                    {ifc_fetch_btb_rd_addr_p1_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1], ifc_fetch_addr_f1[3]} :\n                                    ifc_fetch_btb_rd_addr_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n   assign btb_sram_rw_addr_f1[0] = btb_sram_rw_f1 ? {btb_sram_wr_addr_f1[pt.BTB_ADDR_HI:1]} :\n                                   {btb_sram_rd_index_f1[0], ifc_fetch_addr_f1[2:1]};\n   assign btb_sram_rw_addr_f1[1] = btb_sram_rw_f1 ? {btb_sram_wr_addr_f1[pt.BTB_ADDR_HI:1]} :\n                                   {btb_sram_rd_index_f1[1], ifc_fetch_addr_f1[2:1]};\n\n   assign btb_sram_rd_tag_f1[0] =  fetch_rd_tag_f1[pt.BTB_BTAG_SIZE-1:0];\n   assign btb_sram_rd_tag_f1[1] =  fetch_rd_tag_p1_f1[pt.BTB_BTAG_SIZE-1:0];\n\n   //--------------------------------------------------------------------------------\nend // if (pt.BTB_USE_SRAM)\n\nelse begin\n   assign btb_wr_stall = '0;\n   assign btb_sram_rw = '0;\n   // Errors colliding with fetches must kill the btb/bht hit.\n\n   assign branch_error_collision_f1 = dec_tlu_error_wb & (btb_error_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == btb_rd_addr_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]);\n   assign branch_error_collision_p1_f1 = dec_tlu_error_wb & (btb_error_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == btb_rd_addr_p1_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]);\n\n   assign branch_error_bank_conflict_f1[1:0] = {2{branch_error_collision_f1}} & (decode1_2(dec_tlu_error_bank_wb) | {2{dec_tlu_all_banks_error_wb}});\n   assign branch_error_bank_conflict_p1_f1[1:0] = {2{branch_error_collision_p1_f1}} & (decode1_2(dec_tlu_error_bank_wb) | {2{dec_tlu_all_banks_error_wb}});\n\n   rvdff #(4) coll_ff (.*, .clk(active_clk),\n                         .din({branch_error_bank_conflict_f1[1:0], branch_error_bank_conflict_p1_f1[1:0]}),\n                        .dout({branch_error_bank_conflict_f2[1:0], branch_error_bank_conflict_p1_f2[1:0]}));\n\n   if(!pt.BTB_FULLYA) begin\n\n\n   // 2 -way SA, figure out the way hit and mux accordingly\n   assign tag_match_way0_f2[1:0] = {btb_bank1_rd_data_way0_f2[BV] & (btb_bank1_rd_data_way0_f2[`RV_TAG] == fetch_rd_tag_f2[pt.BTB_BTAG_SIZE-1:0]),\n                                    btb_bank0_rd_data_way0_f2[BV] & (btb_bank0_rd_data_way0_f2[`RV_TAG] == fetch_rd_tag_f2[pt.BTB_BTAG_SIZE-1:0])} &\n                                   ~({2{~dec_tlu_way_wb_f}} & branch_error_bank_conflict_f2[1:0]) & {2{ifc_fetch_req_f2_raw & ~leak_one_f2[ifc_select_tid_f2]}};\n\n   assign tag_match_way1_f2[1:0] = {btb_bank1_rd_data_way1_f2[BV] & (btb_bank1_rd_data_way1_f2[`RV_TAG] == fetch_rd_tag_f2[pt.BTB_BTAG_SIZE-1:0]),\n                                    btb_bank0_rd_data_way1_f2[BV] & (btb_bank0_rd_data_way1_f2[`RV_TAG] == fetch_rd_tag_f2[pt.BTB_BTAG_SIZE-1:0])} &\n                                   ~({2{dec_tlu_way_wb_f}} & branch_error_bank_conflict_f2[1:0]) & {2{ifc_fetch_req_f2_raw & ~leak_one_f2[ifc_select_tid_f2]}};\n\n\n   assign tag_match_way0_p1_f2[1:0] = {btb_bank1_rd_data_way0_p1_f2[BV] & (btb_bank1_rd_data_way0_p1_f2[`RV_TAG] == fetch_rd_tag_p1_f2[pt.BTB_BTAG_SIZE-1:0]),\n                                       btb_bank0_rd_data_way0_p1_f2[BV] & (btb_bank0_rd_data_way0_p1_f2[`RV_TAG] == fetch_rd_tag_p1_f2[pt.BTB_BTAG_SIZE-1:0])} &\n                                      ~({2{~dec_tlu_way_wb_f}} & branch_error_bank_conflict_p1_f2[1:0]) & {2{ifc_fetch_req_f2_raw & ~leak_one_f2[ifc_select_tid_f2]}};\n\n   assign tag_match_way1_p1_f2[1:0] = {btb_bank1_rd_data_way1_p1_f2[BV] & (btb_bank1_rd_data_way1_p1_f2[`RV_TAG] == fetch_rd_tag_p1_f2[pt.BTB_BTAG_SIZE-1:0]),\n                                       btb_bank0_rd_data_way1_p1_f2[BV] & (btb_bank0_rd_data_way1_p1_f2[`RV_TAG] == fetch_rd_tag_p1_f2[pt.BTB_BTAG_SIZE-1:0])} &\n                                      ~({2{dec_tlu_way_wb_f}} & branch_error_bank_conflict_p1_f2[1:0]) & {2{ifc_fetch_req_f2_raw & ~leak_one_f2[ifc_select_tid_f2]}};\n\n\n   // Both ways could hit, use the offset bit to reorder\n\n   assign tag_match_way0_expanded_f2[3:0] = {tag_match_way0_f2[1] &  (btb_bank1_rd_data_way0_f2[BOFF] ^ btb_bank1_rd_data_way0_f2[PC4]),\n                                             tag_match_way0_f2[1] & ~(btb_bank1_rd_data_way0_f2[BOFF] ^ btb_bank1_rd_data_way0_f2[PC4]),\n                                             tag_match_way0_f2[0] &  (btb_bank0_rd_data_way0_f2[BOFF] ^ btb_bank0_rd_data_way0_f2[PC4]),\n                                             tag_match_way0_f2[0] & ~(btb_bank0_rd_data_way0_f2[BOFF] ^ btb_bank0_rd_data_way0_f2[PC4])};\n\n   assign tag_match_way1_expanded_f2[3:0] = {tag_match_way1_f2[1] &  (btb_bank1_rd_data_way1_f2[BOFF] ^ btb_bank1_rd_data_way1_f2[PC4]),\n                                             tag_match_way1_f2[1] & ~(btb_bank1_rd_data_way1_f2[BOFF] ^ btb_bank1_rd_data_way1_f2[PC4]),\n                                             tag_match_way1_f2[0] &  (btb_bank0_rd_data_way1_f2[BOFF] ^ btb_bank0_rd_data_way1_f2[PC4]),\n                                             tag_match_way1_f2[0] & ~(btb_bank0_rd_data_way1_f2[BOFF] ^ btb_bank0_rd_data_way1_f2[PC4])};\n\n   assign tag_match_way0_expanded_p1_f2[3:0] = {tag_match_way0_p1_f2[1] &  (btb_bank1_rd_data_way0_p1_f2[BOFF] ^ btb_bank1_rd_data_way0_p1_f2[PC4]),\n                                                tag_match_way0_p1_f2[1] & ~(btb_bank1_rd_data_way0_p1_f2[BOFF] ^ btb_bank1_rd_data_way0_p1_f2[PC4]),\n                                                tag_match_way0_p1_f2[0] &  (btb_bank0_rd_data_way0_p1_f2[BOFF] ^ btb_bank0_rd_data_way0_p1_f2[PC4]),\n                                                tag_match_way0_p1_f2[0] & ~(btb_bank0_rd_data_way0_p1_f2[BOFF] ^ btb_bank0_rd_data_way0_p1_f2[PC4])};\n\n   assign tag_match_way1_expanded_p1_f2[3:0] = {tag_match_way1_p1_f2[1] &  (btb_bank1_rd_data_way1_p1_f2[BOFF] ^ btb_bank1_rd_data_way1_p1_f2[PC4]),\n                                                tag_match_way1_p1_f2[1] & ~(btb_bank1_rd_data_way1_p1_f2[BOFF] ^ btb_bank1_rd_data_way1_p1_f2[PC4]),\n                                                tag_match_way1_p1_f2[0] &  (btb_bank0_rd_data_way1_p1_f2[BOFF] ^ btb_bank0_rd_data_way1_p1_f2[PC4]),\n                                                tag_match_way1_p1_f2[0] & ~(btb_bank0_rd_data_way1_p1_f2[BOFF] ^ btb_bank0_rd_data_way1_p1_f2[PC4])};\n\n   assign wayhit_f2[3:0] = tag_match_way0_expanded_f2[3:0] | tag_match_way1_expanded_f2[3:0];\n   assign wayhit_p1_f2[3:0] = tag_match_way0_expanded_p1_f2[3:0] | tag_match_way1_expanded_p1_f2[3:0];\n\n   assign btb_bank1o_rd_data_f2[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_f2[3]}} & btb_bank1_rd_data_way0_f2[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{tag_match_way1_expanded_f2[3]}} & btb_bank1_rd_data_way1_f2[BTB_DWIDTH-1:0]) );\n   assign btb_bank1e_rd_data_f2[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_f2[2]}} & btb_bank1_rd_data_way0_f2[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{tag_match_way1_expanded_f2[2]}} & btb_bank1_rd_data_way1_f2[BTB_DWIDTH-1:0]) );\n\n   assign btb_bank0o_rd_data_f2[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_f2[1]}} & btb_bank0_rd_data_way0_f2[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{tag_match_way1_expanded_f2[1]}} & btb_bank0_rd_data_way1_f2[BTB_DWIDTH-1:0]) );\n   assign btb_bank0e_rd_data_f2[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_f2[0]}} & btb_bank0_rd_data_way0_f2[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{tag_match_way1_expanded_f2[0]}} & btb_bank0_rd_data_way1_f2[BTB_DWIDTH-1:0]) );\n\n\n   assign btb_bank1e_rd_data_p1_f2[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_p1_f2[2]}} & btb_bank1_rd_data_way0_p1_f2[BTB_DWIDTH-1:0]) |\n                                                        ({BTB_DWIDTH{tag_match_way1_expanded_p1_f2[2]}} & btb_bank1_rd_data_way1_p1_f2[BTB_DWIDTH-1:0]) );\n   assign btb_bank0o_rd_data_p1_f2[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_p1_f2[1]}} & btb_bank0_rd_data_way0_p1_f2[BTB_DWIDTH-1:0]) |\n                                                        ({BTB_DWIDTH{tag_match_way1_expanded_p1_f2[1]}} & btb_bank0_rd_data_way1_p1_f2[BTB_DWIDTH-1:0]) );\n   assign btb_bank0e_rd_data_p1_f2[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_p1_f2[0]}} & btb_bank0_rd_data_way0_p1_f2[BTB_DWIDTH-1:0]) |\n                                                        ({BTB_DWIDTH{tag_match_way1_expanded_p1_f2[0]}} & btb_bank0_rd_data_way1_p1_f2[BTB_DWIDTH-1:0]) );\n\n   // virtual bank order\n\n   assign btb_vbank0_rd_data_f2[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{fetch_start_f2[0]}} &  btb_bank0e_rd_data_f2[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f2[1]}} &  btb_bank0o_rd_data_f2[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f2[2]}} &  btb_bank1e_rd_data_f2[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f2[3]}} &  btb_bank1o_rd_data_f2[BTB_DWIDTH-1:0]) );\n   assign btb_vbank1_rd_data_f2[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{fetch_start_f2[0]}} &  btb_bank0o_rd_data_f2[BTB_DWIDTH-1:0]) |\n                                                            ({BTB_DWIDTH{fetch_start_f2[1]}} &  btb_bank1e_rd_data_f2[BTB_DWIDTH-1:0]) |\n                                                            ({BTB_DWIDTH{fetch_start_f2[2]}} &  btb_bank1o_rd_data_f2[BTB_DWIDTH-1:0]) |\n                                                            ({BTB_DWIDTH{fetch_start_f2[3]}} &  btb_bank0e_rd_data_p1_f2[BTB_DWIDTH-1:0]) );\n   assign btb_vbank2_rd_data_f2[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{fetch_start_f2[0]}} &  btb_bank1e_rd_data_f2[BTB_DWIDTH-1:0]) |\n                                                            ({BTB_DWIDTH{fetch_start_f2[1]}} &  btb_bank1o_rd_data_f2[BTB_DWIDTH-1:0]) |\n                                                            ({BTB_DWIDTH{fetch_start_f2[2]}} &  btb_bank0e_rd_data_p1_f2[BTB_DWIDTH-1:0]) |\n                                                            ({BTB_DWIDTH{fetch_start_f2[3]}} &  btb_bank0o_rd_data_p1_f2[BTB_DWIDTH-1:0]) );\n   assign btb_vbank3_rd_data_f2[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{fetch_start_f2[0]}} &  btb_bank1o_rd_data_f2[BTB_DWIDTH-1:0]) |\n                                                            ({BTB_DWIDTH{fetch_start_f2[1]}} &  btb_bank0e_rd_data_p1_f2[BTB_DWIDTH-1:0]) |\n                                                            ({BTB_DWIDTH{fetch_start_f2[2]}} &  btb_bank0o_rd_data_p1_f2[BTB_DWIDTH-1:0]) |\n                                                            ({BTB_DWIDTH{fetch_start_f2[3]}} &  btb_bank1e_rd_data_p1_f2[BTB_DWIDTH-1:0]) );\n\n   assign tag_match_vway1_expanded_f2[3:0] = ( ({4{fetch_start_f2[0]}} & {tag_match_way1_expanded_f2[3:0]}) |\n                                               ({4{fetch_start_f2[1]}} & {tag_match_way1_expanded_p1_f2[0], tag_match_way1_expanded_f2[3:1]}) |\n                                               ({4{fetch_start_f2[2]}} & {tag_match_way1_expanded_p1_f2[1:0], tag_match_way1_expanded_f2[3:2]}) |\n                                               ({4{fetch_start_f2[3]}} & {tag_match_way1_expanded_p1_f2[2:0], tag_match_way1_expanded_f2[3]}) );\n   end // else: !if(pt.BTB_USE_SRAM)\nend\n   // --------------------------------------------------------------------------------\n   // --------------------------------------------------------------------------------\n   // update lru\n   // mp\n\n   assign fetch_req_val_f2[0] = ifc_fetch_req_f2_raw & ~leak_one_f2[0] & ~ifc_select_tid_f2;\n   if(pt.NUM_THREADS > 1) begin\n\n      assign fetch_req_val_f2[1] = ifc_fetch_req_f2_raw & ~leak_one_f2[1] &  ifc_select_tid_f2;\n\n      // Simultaneous MPs to the same btb entry or bht entry can occur. Arb.\n      assign mp_collision = exu_mp_valid[0] & exu_mp_valid[1] & ({exu_mp_addr[0], exu_mp_way[0], exu_mp_bank[0]} == {exu_mp_addr[1], exu_mp_way[1], exu_mp_bank[1]});\n\n      rvarbiter2 mp_arbiter (\n                             .clk(active_clk),\n                             .ready(exu_mp_valid[1:0] & {2{mp_collision}}),\n                             .tid  (mp_collision_winner_tid),\n                             .shift(mp_collision),\n                             .*);\n      assign mp_bht_collision = exu_mp_valid[0] & exu_mp_valid[1] & (mp_hashed[0] == mp_hashed[1]);\n\n      rvarbiter2 mp_bht_arbiter (\n                             .clk(active_clk),\n                             .ready(exu_mp_valid[1:0] & {2{mp_bht_collision}}),\n                             .tid  (mp_bht_collision_winner_tid),\n                 "}
{"text": "            .shift(mp_bht_collision),\n                           .*\n                             );\n\n      if(!pt.BTB_FULLYA) begin  //\n\n         // cross thread error/mp to the same index can livelock until loop is complete, fix by ignoring btb write until other thread makes forward progress\n         assign dec_tlu_error_tid = (dec_tlu_br0_error_wb | dec_tlu_br0_start_error_wb) ? dec_tlu_br0_wb_pkt.tid : dec_tlu_br1_wb_pkt.tid;\n\n         assign t0_error_lockout_index_ns[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = (dec_tlu_error_wb & ~dec_tlu_error_tid) ?\n                                                                           btb_error_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] : t0_error_lockout_index[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n         assign t1_error_lockout_index_ns[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = (dec_tlu_error_wb &  dec_tlu_error_tid) ?\n                                                                           btb_error_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] : t1_error_lockout_index[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n         rvdffie #(.WIDTH(2*(pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1)), .OVERRIDE(1)) errorindx (.*, .din({t0_error_lockout_index_ns, t1_error_lockout_index_ns}),\n                                                                                             .dout({t0_error_lockout_index,    t1_error_lockout_index}));\n\n         assign error_mp_collision = ((exu_mp_index[0] == t1_error_lockout_index) & dec_tlu_btb_write_kill[1]) |\n                                     ((exu_mp_index[1] == t0_error_lockout_index) & dec_tlu_btb_write_kill[0]);\n         //\n\n\n      assign btb_lru_b0_hold[LRU_SIZE-1:0] = ~mp_wrlru_b0[0][LRU_SIZE-1:0] & ~mp_wrlru_b0[1][LRU_SIZE-1:0] & ~fetch_wrlru_b0[LRU_SIZE-1:0] & ~fetch_wrlru_p1_b0[LRU_SIZE-1:0];\n      assign btb_lru_b1_hold[LRU_SIZE-1:0] = ~mp_wrlru_b1[0][LRU_SIZE-1:0] & ~mp_wrlru_b1[1][LRU_SIZE-1:0] & ~fetch_wrlru_b1[LRU_SIZE-1:0] & ~fetch_wrlru_p1_b1[LRU_SIZE-1:0];\n      assign btb_lru_b0_ns[LRU_SIZE-1:0] = ( (btb_lru_b0_hold[LRU_SIZE-1:0] & btb_lru_b0_f[LRU_SIZE-1:0]) |\n                                             (mp_wrlru_b0[0][LRU_SIZE-1:0] & {LRU_SIZE{~exu_mp_way[0]}}) |\n                                             (mp_wrlru_b0[1][LRU_SIZE-1:0] & {LRU_SIZE{~exu_mp_way[1]}}) |\n                                             (fetch_wrlru_b0[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_f2[0]}}) |\n                                             (fetch_wrlru_p1_b0[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_p1_f2[0]}}) );\n\n      assign btb_lru_b1_ns[LRU_SIZE-1:0] = ( (btb_lru_b1_hold[LRU_SIZE-1:0] & btb_lru_b1_f[LRU_SIZE-1:0]) |\n                                             (mp_wrlru_b1[0][LRU_SIZE-1:0] & {LRU_SIZE{~exu_mp_way[0]}}) |\n                                             (mp_wrlru_b1[1][LRU_SIZE-1:0] & {LRU_SIZE{~exu_mp_way[1]}}) |\n                                             (fetch_wrlru_b1[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_f2[1]}}) |\n                                             (fetch_wrlru_p1_b1[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_p1_f2[1]}}) );\n\n      // Forward the mp lru information to the fetch, avoids multiple way hits later\n      assign use_mp_way[1:0] = ({2{fetch_mp_collision_f2[0]}} & mp_bank_decoded_f[0][1:0]) | ({2{fetch_mp_collision_f2[1]}} & mp_bank_decoded_f[1][1:0]);\n      assign use_mp_way_p1[1:0] = ({2{fetch_mp_collision_p1_f2[0]}} & mp_bank_decoded_f[0][1:0]) | ({2{fetch_mp_collision_p1_f2[1]}} & mp_bank_decoded_f[1][1:0]);\n\n      assign btb_lru_rd_f2[0] = use_mp_way[0] ? (fetch_mp_collision_f2[0] ? exu_mp_way_f[0] : exu_mp_way_f[1]) : |(fetch_wrindex_dec[LRU_SIZE-1:0] & btb_lru_b0_f[LRU_SIZE-1:0]);\n      assign btb_lru_rd_f2[1] = use_mp_way[1] ? (fetch_mp_collision_f2[0] ? exu_mp_way_f[0] : exu_mp_way_f[1]) : |(fetch_wrindex_dec[LRU_SIZE-1:0] & btb_lru_b1_f[LRU_SIZE-1:0]);\n\n      assign btb_lru_rd_p1_f2[0] = use_mp_way_p1[0] ? (fetch_mp_collision_p1_f2[0] ? exu_mp_way_f[0] : exu_mp_way_f[1]) : |(fetch_wrindex_p1_dec[LRU_SIZE-1:0] & btb_lru_b0_f[LRU_SIZE-1:0]);\n      assign btb_lru_rd_p1_f2[1] = use_mp_way_p1[1] ? (fetch_mp_collision_p1_f2[0] ? exu_mp_way_f[0] : exu_mp_way_f[1]):  |(fetch_wrindex_p1_dec[LRU_SIZE-1:0] & btb_lru_b1_f[LRU_SIZE-1:0]);\n      end // if (!pt.BTB_FULLYA)\n\n\n      else\n        assign error_mp_collision = 'b0;\n\n   end // if (pt.NUM_THREADS > 1)\n\n   else begin\n      assign mp_collision = 'b0;\n      assign mp_collision_winner_tid = 'b0;\n      assign mp_bht_collision = 'b0;\n      assign mp_bht_collision_winner_tid = 'b0;\n      assign error_mp_collision = 'b0;\n\n      if(!pt.BTB_FULLYA) begin  //\n\n      assign btb_lru_b0_hold[LRU_SIZE-1:0] = ~mp_wrlru_b0[0][LRU_SIZE-1:0] & ~fetch_wrlru_b0[LRU_SIZE-1:0] & ~fetch_wrlru_p1_b0[LRU_SIZE-1:0];\n      assign btb_lru_b1_hold[LRU_SIZE-1:0] = ~mp_wrlru_b1[0][LRU_SIZE-1:0] & ~fetch_wrlru_b1[LRU_SIZE-1:0] & ~fetch_wrlru_p1_b1[LRU_SIZE-1:0];\n      assign btb_lru_b0_ns[LRU_SIZE-1:0] = ( (btb_lru_b0_hold[LRU_SIZE-1:0] & btb_lru_b0_f[LRU_SIZE-1:0]) |\n                                             (mp_wrlru_b0[0][LRU_SIZE-1:0] & {LRU_SIZE{~exu_mp_way}}) |\n                                             (fetch_wrlru_b0[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_f2[0]}}) |\n                                             (fetch_wrlru_p1_b0[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_p1_f2[0]}}) );\n\n      assign btb_lru_b1_ns[LRU_SIZE-1:0] = ( (btb_lru_b1_hold[LRU_SIZE-1:0] & btb_lru_b1_f[LRU_SIZE-1:0]) |\n                                             (mp_wrlru_b1[0][LRU_SIZE-1:0] & {LRU_SIZE{~exu_mp_way}}) |\n                                             (fetch_wrlru_b1[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_f2[1]}}) |\n                                             (fetch_wrlru_p1_b1[LRU_SIZE-1:0] & {LRU_SIZE{tag_match_way0_p1_f2[1]}}) );\n\n      assign use_mp_way[1:0] = ({2{fetch_mp_collision_f2[0]}} & mp_bank_decoded_f[0][1:0]);\n      assign use_mp_way_p1[1:0] = ({2{fetch_mp_collision_p1_f2[0]}} & mp_bank_decoded_f[0][1:0]);\n\n      assign btb_lru_rd_f2[0] = use_mp_way[0] ? exu_mp_way_f[0] : |(fetch_wrindex_dec[LRU_SIZE-1:0] & btb_lru_b0_f[LRU_SIZE-1:0]);\n      assign btb_lru_rd_f2[1] = use_mp_way[1] ? exu_mp_way_f[0] : |(fetch_wrindex_dec[LRU_SIZE-1:0] & btb_lru_b1_f[LRU_SIZE-1:0]);\n\n      assign btb_lru_rd_p1_f2[0] = use_mp_way_p1[0] ? exu_mp_way_f[0] : |(fetch_wrindex_p1_dec[LRU_SIZE-1:0] & btb_lru_b0_f[LRU_SIZE-1:0]);\n      assign btb_lru_rd_p1_f2[1] = use_mp_way_p1[1] ? exu_mp_way_f[0] : |(fetch_wrindex_p1_dec[LRU_SIZE-1:0] & btb_lru_b1_f[LRU_SIZE-1:0]);\n      end\n   end\n\n   genvar     j, i;\n\n   if(!pt.BTB_FULLYA) begin;    //\n\n   // fetch\n   assign fetch_wrindex_dec[LRU_SIZE-1:0] = {{LRU_SIZE-1{1'b0}},1'b1} <<  btb_rd_addr_f2[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n   assign fetch_wrindex_p1_dec[LRU_SIZE-1:0] = {{LRU_SIZE-1{1'b0}},1'b1} <<  btb_rd_addr_p1_f2[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n\n   assign lru_update_valid_f2[1:0] = {((wayhit_f2[2] & btb_sel_mask_f2[2]) | (wayhit_f2[3] & btb_sel_mask_f2[3])) & ifc_fetch_req_f2 & ~leak_one_f2[ifc_select_tid_f2],\n                                      ((wayhit_f2[0] & btb_sel_mask_f2[0]) | (wayhit_f2[1] & btb_sel_mask_f2[1])) & ifc_fetch_req_f2 & ~leak_one_f2[ifc_select_tid_f2]};\n\n   assign lru_update_valid_p1_f2[1:0] = {((wayhit_p1_f2[2] & btb_sel_mask_f2[2]) | (wayhit_p1_f2[3] & btb_sel_mask_f2[3])) & ifc_fetch_req_f2 & ~leak_one_f2[ifc_select_tid_f2],\n                                         ((wayhit_p1_f2[0] & btb_sel_mask_f2[0]) | (wayhit_p1_f2[1] & btb_sel_mask_f2[1])) & ifc_fetch_req_f2 & ~leak_one_f2[ifc_select_tid_f2]};\n\n   assign fetch_wrlru_b0[LRU_SIZE-1:0] = fetch_wrindex_dec[LRU_SIZE-1:0] &\n                                         {LRU_SIZE{lru_update_valid_f2[0]}};\n   assign fetch_wrlru_b1[LRU_SIZE-1:0] = fetch_wrindex_dec[LRU_SIZE-1:0] &\n                                         {LRU_SIZE{lru_update_valid_f2[1]}};\n\n   assign fetch_wrlru_p1_b0[LRU_SIZE-1:0] = fetch_wrindex_p1_dec[LRU_SIZE-1:0] &\n                                         {LRU_SIZE{lru_update_valid_p1_f2[0]}};\n   assign fetch_wrlru_p1_b1[LRU_SIZE-1:0] = fetch_wrindex_p1_dec[LRU_SIZE-1:0] &\n                                         {LRU_SIZE{lru_update_valid_p1_f2[1]}};\n\n   // rotated\n   assign btb_vlru_rd_f2[3:0] = ( ({4{fetch_start_f2[0]}} & {btb_lru_rd_f2[1], btb_lru_rd_f2[1], btb_lru_rd_f2[0], btb_lru_rd_f2[0]}) |\n                                  ({4{fetch_start_f2[1]}} & {btb_lru_rd_p1_f2[0], btb_lru_rd_f2[1], btb_lru_rd_f2[1], btb_lru_rd_f2[0]}) |\n                                  ({4{fetch_start_f2[2]}} & {btb_lru_rd_p1_f2[0], btb_lru_rd_p1_f2[0], btb_lru_rd_f2[1], btb_lru_rd_f2[1]}) |\n                                  ({4{fetch_start_f2[3]}} & {btb_lru_rd_p1_f2[1], btb_lru_rd_p1_f2[0], btb_lru_rd_p1_f2[0], btb_lru_rd_f2[1]}));\n\n   end\n   // Detect end of cache line and mask as needed\n   assign eoc_near = &ifc_fetch_addr_f2[pt.ICACHE_BEAT_ADDR_HI:3];\n   assign eoc_mask[3:1] = {3{~eoc_near}} | {ifc_fetch_addr_f2[2:1] == 2'b0,\n                                            ~ifc_fetch_addr_f2[2],\n                                            |(~ifc_fetch_addr_f2[2:1])};\n\nif(!pt.BTB_FULLYA) begin\n   assign vwayhit_f2[3:0] = ( ({4{fetch_start_f2[0]}} & {wayhit_f2[3:0]}) |\n                              ({4{fetch_start_f2[1]}} & {wayhit_p1_f2[0], wayhit_f2[3:1]}) |\n                              ({4{fetch_start_f2[2]}} & {wayhit_p1_f2[1:0], wayhit_f2[3:2]}) |\n                              ({4{fetch_start_f2[3]}} & {wayhit_p1_f2[2:0], wayhit_f2[3]}) ) & {eoc_mask[3:1], 1'b1};\n\n   assign way_raw[3:0] =  tag_match_vway1_expanded_f2[3:0] | (~vwayhit_f2[3:0] & btb_vlru_rd_f2[3:0]);\n\n   // a valid taken target needs to kill the next fetch as we compute the target address\n   assign ifu_bp_kill_next_f2 = |(vwayhit_f2[3:0] & hist1_raw[3:0]) & ifc_fetch_req_f2 & ~leak_one_f2[ifc_select_tid_f2] & ~dec_tlu_bpred_disable;\n\n   rvdffe #(LRU_SIZE*2) btb_lru_ff (.*, .en(ifc_fetch_req_f2 | (|exu_mp_valid[pt.NUM_THREADS-1:0])),\n                                    .din({btb_lru_b0_ns[(LRU_SIZE)-1:0],\n                                          btb_lru_b1_ns[(LRU_SIZE)-1:0]}),\n                                   .dout({btb_lru_b0_f[(LRU_SIZE)-1:0],\n                                          btb_lru_b1_f[(LRU_SIZE)-1:0]}));\nend\n\n\n   // --------------------------------------------------------------------------------\n   // --------------------------------------------------------------------------------\n\n   // mux out critical hit bank for pc computation\n   // This is only useful for the first taken branch in the fetch group\n\n   assign btb_rd_tgt_f2[pt.BTB_TOFFSET_SIZE-1:0] = btb_sel_data_f2[pt.BTB_TOFFSET_SIZE+4:5];\n   assign btb_rd_pc4_f2       = btb_sel_data_f2[4];\n   assign btb_rd_call_f2      = btb_sel_data_f2[2];\n   assign btb_rd_ret_f2       = btb_sel_data_f2[1];\n\n   assign btb_sel_data_f2[pt.BTB_TOFFSET_SIZE+4:1] = ( ({pt.BTB_TOFFSET_SIZE+4{btb_sel_f2[3]}} & btb_vbank3_rd_data_f2[pt.BTB_TOFFSET_SIZE+4:1]) |\n                                                       ({pt.BTB_TOFFSET_SIZE+4{btb_sel_f2[2]}} & btb_vbank2_rd_data_f2[pt.BTB_TOFFSET_SIZE+4:1]) |\n                                                       ({pt.BTB_TOFFSET_SIZE+4{btb_sel_f2[1]}} & btb_vbank1_rd_data_f2[pt.BTB_TOFFSET_SIZE+4:1]) |\n                                                       ({pt.BTB_TOFFSET_SIZE+4{btb_sel_f2[0]}} & btb_vbank0_rd_data_f2[pt.BTB_TOFFSET_SIZE+4:1]) );\n\n\n\n\n   // Don't put calls/rets/ja in the predictor, force the bht taken instead\n   assign bht_force_taken_f2[3:0] = {(btb_vbank3_rd_data_f2[CALL] | btb_vbank3_rd_data_f2[RET]),\n                                     (btb_vbank2_rd_data_f2[CALL] | btb_vbank2_rd_data_f2[RET]),\n                                     (btb_vbank1_rd_data_f2[CALL] | btb_vbank1_rd_data_f2[RET]),\n                                     (btb_vbank0_rd_data_f2[CALL] | btb_vbank0_rd_data_f2[RET])};\n\n\n   // taken and valid, otherwise, branch errors must clear the bht\n   assign bht_valid_f2[3:0] = vwayhit_f2[3:0];\n\n   assign bht_vbank0_rd_data_f2[1:0] = ( ({2{fetch_start_f2[0]}} & bht_bank0_rd_data_f2[1:0]) |\n                                         ({2{fetch_start_f2[1]}} & bht_bank1_rd_data_f2[1:0]) |\n                                         ({2{fetch_start_f2[2]}} & bht_bank2_rd_data_f2[1:0]) |\n                                         ({2{fetch_start_f2[3]}} & bht_bank3_rd_data_f2[1:0]) );\n\n   assign bht_vbank1_rd_data_f2[1:0] = ( ({2{fetch_start_f2[0]}} & bht_bank1_rd_data_f2[1:0]) |\n                                         ({2{fetch_start_f2[1]}} & bht_bank2_rd_data_f2[1:0]) |\n                                         ({2{fetch_start_f2[2]}} & bht_bank3_rd_data_f2[1:0]) |\n                                         ({2{fetch_start_f2[3]}} & bht_bank0_rd_data_p1_f2[1:0]) );\n\n   assign bht_vbank2_rd_data_f2[1:0] = ( ({2{fetch_start_f2[0]}} & bht_bank2_rd_data_f2[1:0]) |\n                                         ({2{fetch_start_f2[1]}} & bht_bank3_rd_data_f2[1:0]) |\n                                         ({2{fetch_start_f2[2]}} & bht_bank0_rd_data_p1_f2[1:0]) |\n                                         ({2{fetch_start_f2[3]}} & bht_bank1_rd_data_p1_f2[1:0]) );\n\n   assign bht_vbank3_rd_data_f2[1:0] = ( ({2{fetch_start_f2[0]}} & bht_bank3_rd_data_f2[1:0]) |\n                                         ({2{fetch_start_f2[1]}} & bht_bank0_rd_data_p1_f2[1:0]) |\n                                         ({2{fetch_start_f2[2]}} & bht_bank1_rd_data_p1_f2[1:0]) |\n                                         ({2{fetch_start_f2[3]}} & bht_bank2_rd_data_p1_f2[1:0]) );\n\n\n   assign bht_dir_f2[3:0] = {(bht_force_taken_f2[3] | bht_vbank3_rd_data_f2[1]) & bht_valid_f2[3],\n                             (bht_force_taken_f2[2] | bht_vbank2_rd_data_f2[1]) & bht_valid_f2[2],\n                             (bht_force_taken_f2[1] | bht_vbank1_rd_data_f2[1]) & bht_valid_f2[1],\n                             (bht_force_taken_f2[0] | bht_vbank0_rd_data_f2[1]) & bht_valid_f2[0]};\n\n   assign ifu_bp_inst_mask_f2[3:1] = ( ({3{ ifu_bp_kill_next_f2}} & btb_vmask_f2[3:1]) |\n                                       ({3{~ifu_bp_kill_next_f2}} & 3'b111) );\n\n\n\n   // Branch prediction info is sent with the 2byte lane associated with the end of the branch.\n   // Cases\n   //       BANK1         BANK0\n   // -------------------------------\n   // |      :       |      :       |\n   // -------------------------------\n   //         <------------>                   : PC4 branch, offset, should be in B1 (indicated on [2])\n   //                <------------>            : PC4 branch, no offset, indicate PC4, VALID, HIST on [1]\n   //                       <------------>     : PC4 branch, offset, indicate PC4, VALID, HIST on [0]\n   //                <------>                  : PC2 branch, offset, indicate VALID, HIST on [1]\n   //                       <------>           : PC2 branch, no offset, indicate VALID, HIST on [0]\n   //\n\n\n\n   assign hist1_raw[3:0] = bht_force_taken_f2[3:0] | {bht_vbank3_rd_data_f2[1],\n                                                      bht_vbank2_rd_data_f2[1],\n                                                      bht_vbank1_rd_data_f2[1],\n                                                      bht_vbank0_rd_data_f2[1]};\n\n   assign hist0_raw[3:0] = {bht_vbank3_rd_data_f2[0],\n                            bht_vbank2_rd_data_f2[0],\n                            bht_vbank1_rd_data_f2[0],\n                            bht_vbank0_rd_data_f2[0]};\n\n\n   assign pc4_raw[3:0] = {vwayhit_f2[3] & btb_vbank3_rd_data_f2[PC4],\n                          vwayhit_f2[2] & btb_vbank2_rd_data_f2[PC4],\n                          vwayhit_f2[1] & btb_vbank1_rd_data_f2[PC4],\n                          vwayhit_f2[0] & btb_vbank0_rd_data_f2[PC4]};\n\n   assign pret_raw[3:0] = {vwayhit_f2[3] & ~btb_vbank3_rd_data_f2[CALL] & btb_vbank3_rd_data_f2[RET],\n                           vwayhit_f2[2] & ~btb_vbank2_rd_data_f2[CALL] & btb_vbank2_rd_data_f2[RET],\n                           vwayhit_f2[1] & ~btb_vbank1_rd_data_f2[CALL] & btb_vbank1_rd_data_f2[RET],\n                           vwayhit_f2[0] & ~btb_vbank0_rd_data_f2[CALL] & btb_vbank0_rd_data_f2[RET]};\n\n   // GHR\n\n   // Figure out how many valid branches are in the fetch group\n   assign fgmask_f2[2] = (~ifc_fetch_addr_f2[1]) | (~ifc_fetch_addr_f2[2]);\n   assign fgmask_f2[1] = (~ifc_fetch_addr_f2[2]);\n   assign fgmask_f2[0] = (~ifc_fetch_addr_f2[2] & ~ifc_fetch_addr_f2[1]);\n\n   assign btb_sel_mask_f2[3:0] = {btb_sel_f2[3],\n                                  |btb_sel_f2[3:2] & fgmask_f2[2],\n                                  |btb_sel_f2[3:1] & fgmask_f2[1],\n                                  |btb_sel_f2[3:0] & fgmask_f2[0]};\n\n  // count the valids with masking based on first taken\n   assign num_valids[2:0] = countones(bht_valid_f2[3:0]);\n\n   // Note that the following property holds\n   // P: prior ghr, H: history bit of last valid branch in line (could be 1 or 0)\n   // Num valid branches   What lowest bits of new GHR must be\n   // 4                    000H\n   // 3                    P00H\n   // 2                    PP0H\n   // 1                    PPPH\n   // 0                    PPPP\n\n   assign final_h = |(btb_sel_f2[3:0] & bht_dir_f2[3:0]);\n\n   if(pt.BHT_GHR_SIZE==3) begin : fghr_shift\n      assign merged_ghr[pt.BHT_GHR_SIZE-1:0] = ( ({pt.BHT_GHR_SIZE{num_valids[2:0] >= 3'h3}} & {2'b0, final_h}) | // 00H\n                                                 ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h2}} & {fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-3:0], 1'b0, final_h}) | // P0H\n                                                 ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h1}} & {fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-2:0], final_h}) | // PPH\n                                                 ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h0}} & {fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-1:0]}) ); // PPP\n   end\n   else if(pt.BHT_GHR_SIZE==4) begin\n      assign merged_ghr[pt.BHT_GHR_SIZE-1:0] = ( ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h4}} & {3'b0, final_h}) | // 000H\n                                                 ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h3}} & {fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-4:0], 2'b0, final_h}) | // P00H\n                                                 ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h2}} & {fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-3:0], 1'b0, final_h}) | // PP0H\n                                                 ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h1}} & {fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-2:0], final_h}) | // PPPH\n                                                 ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h0}} & {fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-1:0]}) ); // PPPP\n      end\n   else begin\n      assign merged_ghr[pt.BHT_GHR_SIZE-1:0] = ( ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h4}} & {fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-5:0], 3'b0, final_h}) | // 000H\n                                                 ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h3}} & {fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-4:0], 2'b0, final_h}) | // P00H\n                                                 ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h2}} & {fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-3:0], 1'b0, final_h}) | // PP0H\n                                                 ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h1}} & {fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-2:0], final_h}) | // PPPH\n                                                 ({pt.BHT_GHR_SIZE{num_valids[2:0] == 3'h0}} & {fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-1:0]}) ); // PPPP\n   end\n\n\n   for (i=0; i<pt.NUM_THREADS; i++) begin : fghrmaint\n\n      assign exu_mp_valid[i] = exu_mp_pkt[i].misp & ~leak_one_f2[ifc_select_tid_f2] & ~dec_tlu_error_wb; // conditional branch mispredict, unless there was a simul error\n      assign exu_mp_boffset[i] = exu_mp_pkt[i].boffset;  // branch offset\n      assign exu_mp_pc4[i] = exu_mp_pkt[i].pc4;  // branch is a 4B inst\n      assign exu_mp_call[i] = exu_mp_pkt[i].pcall;  // branch is a call inst\n      assign exu_mp_ret[i] = exu_mp_pkt[i].pret;  // branch is a ret inst\n      assign exu_mp_ja[i] = exu_mp_pkt[i].pja;  /"}
{"text": "/ branch is a jump always\n      assign exu_mp_way[i] = exu_mp_pkt[i].way;  // repl way\n      assign exu_mp_hist[i][1:0] = exu_mp_pkt[i].hist[1:0];  // new history\n      assign exu_mp_tgt[i][pt.BTB_TOFFSET_SIZE-1:0]  = exu_mp_toffset[i][pt.BTB_TOFFSET_SIZE-1:0] ;  // target offset\n      assign exu_mp_bank[i]  = exu_mp_pkt[i].bank ;  // write bank = exu_mp_pkt[i].;  based on branch PC[3:2]\n      assign exu_mp_ataken[i] = exu_mp_pkt[i].ataken;\n      assign exu_mp_addr[i][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]  = exu_mp_index[i][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ;  // BTB/BHT address\n\n      assign btb_wr_tag[i][pt.BTB_BTAG_SIZE-1:0] = exu_mp_btag[i][pt.BTB_BTAG_SIZE-1:0];\n\n      assign exu_mp_valid_write[i] = exu_mp_valid[i] & ~exu_mp_pkt[i].valid & exu_mp_ataken[i] & (~mp_collision | (i == mp_collision_winner_tid));\n      assign btb_wr_addr[i][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = dec_tlu_error_wb ? btb_error_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] : exu_mp_addr[i][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n      assign btb_wr_data[i][BTB_DWIDTH-1:0] = {btb_wr_tag[i][pt.BTB_BTAG_SIZE-1:0], exu_mp_tgt[i][pt.BTB_TOFFSET_SIZE-1:0],\n                                                exu_mp_pc4[i], exu_mp_boffset[i], exu_mp_call[i] | exu_mp_ja[i],\n                                                exu_mp_ret[i] | exu_mp_ja[i], ~dec_tlu_error_wb & ~error_mp_collision} ;\n\n\n      assign fghr_ns[i][pt.BHT_GHR_SIZE-1:0] = ( ({pt.BHT_GHR_SIZE{exu_flush_final[i]}} & exu_mp_fghr[i][pt.BHT_GHR_SIZE-1:0]) |\n                                                 ({pt.BHT_GHR_SIZE{~exu_flush_final[i] & fetch_req_val_f2[i]}} & merged_ghr[pt.BHT_GHR_SIZE-1:0]) |\n                                                 ({pt.BHT_GHR_SIZE{~exu_flush_final[i] & ~fetch_req_val_f2[i]}} & fghr[i][pt.BHT_GHR_SIZE-1:0]));\n\n      rvdff #(pt.BHT_GHR_SIZE) fetchghr (.*, .clk(active_clk), .din(fghr_ns[i][pt.BHT_GHR_SIZE-1:0]), .dout(fghr[i][pt.BHT_GHR_SIZE-1:0]));\n\n      eh2_btb_ghr_hash #(.pt(pt)) mpghrhs  (.hashin(exu_mp_addr[i][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]),\n                                             .ghr(exu_mp_eghr[i][pt.BHT_GHR_SIZE-1:0]),\n                                             .hash(mp_hashed[i][pt.BHT_ADDR_HI:pt.BHT_ADDR_LO]));\n\n\n      assign middle_of_bank[i] = exu_mp_pc4[i] ^ exu_mp_boffset[i];\n      assign bht_wr_en0_thr[i][3:0] = {4{exu_mp_valid[i] & ~exu_mp_call[i] & ~exu_mp_ret[i] & ~exu_mp_ja[i]}} & decode2_4({exu_mp_bank[i], middle_of_bank[i]});\n      // Experiments show this is the best priority scheme for same bank/index writes at the same time.\n      assign bht_wr_data0_thr[i] = exu_mp_hist[i]; // lowest priority\n\n      if(!pt.BTB_FULLYA) begin\n\n      assign mp_bank_decoded[i][1:0] = decode1_2(exu_mp_bank[i]);\n      // create a onehot lru write vector\n      assign mp_wrindex_dec[i][LRU_SIZE-1:0] = {{LRU_SIZE-1{1'b0}},1'b1} <<  exu_mp_addr[i][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n      assign mp_wrlru_b0[i][LRU_SIZE-1:0] = mp_wrindex_dec[i][LRU_SIZE-1:0] & {LRU_SIZE{mp_bank_decoded[i][0] & exu_mp_valid[i] & (~mp_collision | (i == mp_collision_winner_tid))}};\n      assign mp_wrlru_b1[i][LRU_SIZE-1:0] = mp_wrindex_dec[i][LRU_SIZE-1:0] & {LRU_SIZE{mp_bank_decoded[i][1] & exu_mp_valid[i] & (~mp_collision | (i == mp_collision_winner_tid))}};\n\n\n      // MP/Fetch collision\n      assign fetch_mp_collision_f1[i] = ( (exu_mp_btag[i][pt.BTB_BTAG_SIZE-1:0] == fetch_rd_tag_f1[pt.BTB_BTAG_SIZE-1:0]) &\n                                          exu_mp_valid[i] & ifc_fetch_req_f1 & (~mp_collision | (i == mp_collision_winner_tid)) &\n                                          (exu_mp_addr[i][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == btb_rd_addr_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO])\n                                          );\n      assign fetch_mp_collision_p1_f1[i] = ( (exu_mp_btag[i][pt.BTB_BTAG_SIZE-1:0] == fetch_rd_tag_p1_f1[pt.BTB_BTAG_SIZE-1:0]) &\n                                             exu_mp_valid[i] & ifc_fetch_req_f1 & (~mp_collision | (i == mp_collision_winner_tid)) &\n                                             (exu_mp_addr[i][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == btb_rd_addr_p1_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO])\n                                             );\n\n   rvdff #(5) mpcoll_ff (.*, .clk(active_clk),\n                          .din({fetch_mp_collision_f1[i], fetch_mp_collision_p1_f1[i], mp_bank_decoded[i][1:0], exu_mp_way[i]}),\n                         .dout({fetch_mp_collision_f2[i], fetch_mp_collision_p1_f2[i], mp_bank_decoded_f[i][1:0], exu_mp_way_f[i]}));\n         end\n   end\n\n   assign ifu_bp_fghr_f2[pt.BHT_GHR_SIZE-1:0] = fghr[ifc_select_tid_f2][pt.BHT_GHR_SIZE-1:0];\n\n\n   assign ifu_bp_way_f2[3:0] = way_raw[3:0];\n   assign ifu_bp_hist1_f2[3:0]    = hist1_raw[3:0];\n   assign ifu_bp_hist0_f2[3:0]    = hist0_raw[3:0];\n   assign ifu_bp_pc4_f2[3:0]     = pc4_raw[3:0];\n   assign ifu_bp_valid_f2[3:0]   = vwayhit_f2[3:0] & ~{4{dec_tlu_bpred_disable}};\n   assign ifu_bp_ret_f2[3:0]     = pret_raw[3:0];\n\n\n   // compute target\n   // Form the fetch group offset based on the btb hit location and the location of the branch within the 4 byte chunk\n\n//  .i 9\n//  .o 5\n//  .ilb bht_dir_f2[3] bht_dir_f2[2] bht_dir_f2[1] bht_dir_f2[0] fetch_start_f2[3] fetch_start_f2[2] fetch_start_f2[1] fetch_start_f2[0] btb_rd_pc4_f2\n//  .ob bloc_f2[3] bloc_f2[2] bloc_f2[1] bloc_f2[0] use_fa_plus\n//  .type fr\n//\n//\n//  ## rotdir[3:0]  fs   pc4  off fapl\n//    ---1          0001 -  0001  0\n//    --10          0001 -  0010  0\n//    -100          0001 -  0100  0\n//    1000          0001 -  1000  0\n//\n//    ---1          0010 -  0010  0\n//    --10          0010 -  0100  0\n//    -100          0010 -  1000  0\n//    1000          0010 0  0001  1\n//    1000          0010 1  0001  0\n//\n//    ---1          0100 -  0100  0\n//    --10          0100 -  1000  0\n//    -100          0100 0  0001  1\n//    -100          0100 1  0001  0\n//    1000          0100 -  0010  1\n//\n//    ---1          1000 -  1000  0\n//    --10          1000 0  0001  1\n//    --10          1000 1  0001  0\n//    -100          1000 -  0010  1\n//    1000          1000 -  0100  1\n\nassign bloc_f2[3] = (!bht_dir_f2[2]&!bht_dir_f2[1]&!bht_dir_f2[0]\n    &fetch_start_f2[0]) | (bht_dir_f2[2]&!bht_dir_f2[1]&!bht_dir_f2[0]\n    &fetch_start_f2[1]) | (bht_dir_f2[1]&!bht_dir_f2[0]&fetch_start_f2[2]) | (\n    bht_dir_f2[0]&fetch_start_f2[3]);\n\nassign bloc_f2[2] = (bht_dir_f2[2]&!bht_dir_f2[1]&!bht_dir_f2[0]\n    &fetch_start_f2[0]) | (!bht_dir_f2[2]&!bht_dir_f2[1]&!bht_dir_f2[0]\n    &fetch_start_f2[3]) | (bht_dir_f2[1]&!bht_dir_f2[0]&fetch_start_f2[1]) | (\n    bht_dir_f2[0]&fetch_start_f2[2]);\n\nassign bloc_f2[1] = (!bht_dir_f2[2]&!bht_dir_f2[1]&!bht_dir_f2[0]\n    &fetch_start_f2[2]) | (bht_dir_f2[2]&!bht_dir_f2[1]&!bht_dir_f2[0]\n    &fetch_start_f2[3]) | (bht_dir_f2[1]&!bht_dir_f2[0]&fetch_start_f2[0]) | (\n    bht_dir_f2[0]&fetch_start_f2[1]);\n\nassign bloc_f2[0] = (!bht_dir_f2[2]&!bht_dir_f2[1]&!bht_dir_f2[0]\n    &fetch_start_f2[1]) | (bht_dir_f2[2]&!bht_dir_f2[1]&!bht_dir_f2[0]\n    &fetch_start_f2[2]) | (bht_dir_f2[1]&!bht_dir_f2[0]&fetch_start_f2[3]) | (\n    bht_dir_f2[0]&fetch_start_f2[0]);\n\nassign use_fa_plus = (!bht_dir_f2[2]&!bht_dir_f2[1]&!bht_dir_f2[0]\n    &fetch_start_f2[1]&!btb_rd_pc4_f2) | (!bht_dir_f2[1]&!bht_dir_f2[0]\n    &fetch_start_f2[2]&!btb_rd_pc4_f2) | (!bht_dir_f2[0]\n    &fetch_start_f2[3]&!btb_rd_pc4_f2) | (!bht_dir_f2[2]&!bht_dir_f2[1]\n    &!bht_dir_f2[0]&fetch_start_f2[3]) | (!bht_dir_f2[2]&!bht_dir_f2[1]\n    &!bht_dir_f2[0]&fetch_start_f2[2]) | (bht_dir_f2[2]&!bht_dir_f2[1]\n    &!bht_dir_f2[0]&fetch_start_f2[3]);\n\n\n\n    assign btb_fg_crossing_f2 = fetch_start_f2[0] & btb_sel_f2[0] & btb_rd_pc4_f2;\n\n   wire [1:0] btb_sel_f2_enc, btb_sel_f2_enc_shift;\n   assign btb_sel_f2_enc[1:0] = encode4_2(bloc_f2[3:0]);\n   assign btb_sel_f2_enc_shift[1:0] = encode4_2({bloc_f2[0],bloc_f2[3:1]});\n\n   assign bp_total_branch_offset_f2[2:1] =  (({2{ btb_rd_pc4_f2}} &  btb_sel_f2_enc_shift[1:0]) |\n                                             ({2{~btb_rd_pc4_f2}} &  btb_sel_f2_enc[1:0]) |\n                                             ({2{btb_fg_crossing_f2}}));\n\n\n   rvdffpcie #(31) faddrf2raw_ff (.*, .en(ifc_fetch_req_f1), .din(ifc_fetch_addr_f1[31:1]), .dout(ifc_fetch_addr_f2[31:1]));\n\n   rvdfflie #(.WIDTH(2*(pt.BTB_ADDR_HI-2) + 29), .LEFT(20)) faddr_p1_f2ff (.*, .en(ifc_fetch_req_f1), .din({fetch_addr_p1_f1[31:3],\n                                                                btb_rd_addr_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],\n                                                                btb_rd_addr_p1_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]\n                                                                }),\n                                                         .dout({fetch_addr_p1_f2[31:3],\n                                                                btb_rd_addr_f2[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO],\n                                                                btb_rd_addr_p1_f2[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]\n                                                                }));\n\n   assign ifu_bp_poffset_f2[pt.BTB_TOFFSET_SIZE-1:0] = btb_rd_tgt_f2[pt.BTB_TOFFSET_SIZE-1:0];\n\n   assign adder_pc_in_f2[31:3] = ( ({29{ use_fa_plus}} & fetch_addr_p1_f2[31:3]) |\n                                   ({29{ btb_fg_crossing_f2}} & ifc_fetch_adder_prior[ifc_select_tid_f2][31:3]) |\n                                   ({29{~btb_fg_crossing_f2 & ~use_fa_plus}} & ifc_fetch_addr_f2[31:3]));\n\n   rvbradder predtgt_addr (.pc({adder_pc_in_f2[31:3], bp_total_branch_offset_f2[2:1]}),\n                         .offset(btb_rd_tgt_f2[pt.BTB_TOFFSET_SIZE-1:0]),\n                         .dout(bp_btb_target_adder_f2[31:1])\n                         );\n   // mux in the return stack address here for a predicted return, if it is valid\n   // if no btb kill, quite the bus to 0\n   assign ifu_bp_btb_target_f2[31:1] = ( ({31{btb_rd_ret_f2 & ~btb_rd_call_f2 & rets_out[ifc_select_tid_f2][0][0] & ifu_bp_kill_next_f2}} & rets_out[ifc_select_tid_f2][0][31:1]) |\n                                         ({31{~(btb_rd_ret_f2 & ~btb_rd_call_f2 & rets_out[ifc_select_tid_f2][0][0]) & ifu_bp_kill_next_f2}} & bp_btb_target_adder_f2[31:1]) );\n\n\n\n   // ----------------------------------------------------------------------\n   // Return Stack\n   // ----------------------------------------------------------------------\n\n   rvbradder rs_addr (.pc({adder_pc_in_f2[31:3], bp_total_branch_offset_f2[2:1]}),\n                      .offset({ {pt.BTB_TOFFSET_SIZE-2{1'b0}}, btb_rd_pc4_f2, ~btb_rd_pc4_f2}),\n                      .dout(bp_rs_call_target_f2[31:1])\n                      );\n\n   // Calls/Rets are always taken, so there shouldn't be a push and pop in the same fetch group\n\n\n   for (genvar tid=0; tid < pt.NUM_THREADS; tid++) begin: rs_thr\n\n      // set on leak one, hold until next flush without leak one\n      assign leak_one_f1[tid] = (dec_tlu_flush_leak_one_wb[tid] & dec_tlu_flush_lower_wb[tid]) | (leak_one_f2[tid] & ~dec_tlu_flush_lower_wb[tid]);\n\n   rvdff #(1) leak_ff (.*, .clk(active_clk),\n                         .din({leak_one_f1[tid]}),\n                        .dout({leak_one_f2[tid]}));\n\n`ifdef RS_COMMIT_EN\n      assign rs_overpop_correct[tid] = rsoverpop_valid_f[tid] & exu_flush_final[tid] & ~exu_mp_ret[tid];\n      assign rs_underpop_correct[tid] = rsunderpop_valid_f[tid] & exu_flush_final[tid] & ~exu_mp_call[tid];\n\n      assign exu_i0_br_call_e4_thr[tid] = exu_i0_br_call_e4 & (tid == dec_i0_tid_e4);\n      assign exu_i1_br_call_e4_thr[tid] = exu_i1_br_call_e4 & (tid == dec_i1_tid_e4);\n      assign exu_i0_br_ret_e4_thr[tid] = exu_i0_br_ret_e4 & (tid == dec_i0_tid_e4);\n      assign exu_i1_br_ret_e4_thr[tid] = exu_i1_br_ret_e4 & (tid == dec_i1_tid_e4);\n\n      assign rsunderpop_valid_ns[tid] = (rs_push[tid] | (rsunderpop_valid_f[tid] & ~(exu_i0_br_call_e4_thr[tid] | exu_i1_br_call_e4_thr[tid]))) & ~exu_flush_final[tid];\n      assign rsoverpop_valid_ns[tid] = (rs_pop[tid] | (rsoverpop_valid_f[tid] & ~(exu_i0_br_ret_e4_thr[tid] | exu_i1_br_ret_e4_thr[tid]))) & ~exu_flush_final[tid];\n      assign rsoverpop_ns[tid][31:0] = ( ({32{rs_pop[tid]}}  & rets_out[tid][0][31:0]) |\n                                         ({32{~rs_pop[tid]}} & rsoverpop_f[tid][31:0]) );\n\n      rvdff #(34) retoverpop_ff (.*, .clk(active_clk), .din({rsunderpop_valid_ns[tid], rsoverpop_valid_ns[tid], rsoverpop_ns[tid][31:0]}), .dout({rsunderpop_valid_f[tid], rsoverpop_valid_f[tid], rsoverpop_f[tid][31:0]}));\n`else\n      assign rs_overpop_correct[tid] = 1'b0;\n      assign rs_underpop_correct[tid] = 1'b0;\n      assign rsoverpop_f[tid][31:0]  = 'b0;\n`endif // !`ifdef RS_COMMIT_EN\n\n\nlogic [31:1] rs_push_addr;\n\n`ifdef RS_MP_PP\n      assign rs_push_addr[31:1] = rs_push_mp ? (exu_flush_path_final[tid][31:1] - {{19{exu_mp_toffset[tid][11]}}, exu_mp_toffset[tid]} + {exu_mp_pc4[tid], ~exu_mp_pc4[tid]}) : bp_rs_call_target_f2[31:1];\n      assign rs_push_mp[tid] = exu_mp_valid[tid] & exu_mp_call[tid] & ~exu_mp_ret[tid];\n      assign rs_pop_mp[tid] = exu_mp_valid[tid] & ~exu_mp_call[tid] & exu_mp_ret[tid] & (rets_out[tid][0][31:1] == exu_flush_path_final[tid][31:1]);\n`else\n      assign rs_push_addr[31:1] = bp_rs_call_target_f2[31:1];\n      assign rs_push_mp[tid] = '0;\n      assign rs_pop_mp[tid] = '0;\n`endif\n\n      assign rs_push[tid] = ((btb_rd_call_f2 & ~btb_rd_ret_f2 & ifu_bp_kill_next_f2 & fetch_req_val_f2[tid]) | (rs_overpop_correct[tid] & ~rs_underpop_correct[tid]) | rs_push_mp[tid]);\n      assign rs_pop[tid] = ((btb_rd_ret_f2 & ~btb_rd_call_f2 & ifu_bp_kill_next_f2 & fetch_req_val_f2[tid]) | (rs_underpop_correct[tid] & ~rs_overpop_correct[tid]) | rs_pop_mp[tid]);\n      assign rs_hold[tid] = ~rs_push[tid] & ~rs_pop[tid] & ~rs_overpop_correct[tid] & ~rs_underpop_correct[tid];\n\n      // Fetch based\n      assign rets_in[tid][0][31:0] = ( ({32{rs_overpop_correct[tid] & rs_underpop_correct[tid]}} & rsoverpop_f[tid][31:0]) |\n                                       ({32{rs_push[tid] & rs_overpop_correct[tid]}} & rsoverpop_f[tid][31:0]) |\n                                       ({32{rs_push[tid] & ~rs_overpop_correct[tid]}} & {rs_push_addr[31:1], 1'b1}) |\n                                       ({32{rs_pop[tid]}}  & rets_out[tid][1][31:0]) );\n\n      assign rsenable[tid][0] = ~rs_hold[tid];\n\n      for (genvar i=0; i<pt.RET_STACK_SIZE; i++) begin : retstack\n\n         // for the last entry in the stack, we don't have a pop position\n         if(i==pt.RET_STACK_SIZE-1) begin\n            assign rets_in[tid][i][31:0] = rets_out[tid][i-1][31:0];\n            assign rsenable[tid][i] = rs_push[tid];\n         end\n         else if(i>0) begin\n            assign rets_in[tid][i][31:0] = ( ({32{rs_push[tid]}} & rets_out[tid][i-1][31:0]) |\n                                             ({32{rs_pop[tid]}}  & rets_out[tid][i+1][31:0]) );\n            assign rsenable[tid][i] = rs_push[tid] | rs_pop[tid];\n         end\n         rvdffe #(32) rets_ff (.*, .en(rsenable[tid][i]), .din(rets_in[tid][i][31:0]), .dout(rets_out[tid][i][31:0]));\n\n      end : retstack\n\n\n\n   end // block: rs_thr\n\n\n   // ----------------------------------------------------------------------\n   // WRITE\n   // ----------------------------------------------------------------------\n\n\n   assign dec_tlu_error_wb = dec_tlu_br0_start_error_wb | dec_tlu_br0_error_wb | dec_tlu_br1_start_error_wb | dec_tlu_br1_error_wb;\n   assign dec_tlu_all_banks_error_wb = dec_tlu_br0_start_error_wb | (~dec_tlu_br0_error_wb & dec_tlu_br1_start_error_wb);\n\n   assign dec_tlu_error_bank_wb = (dec_tlu_br0_error_wb | dec_tlu_br0_start_error_wb) ? dec_tlu_br0_bank_wb : dec_tlu_br1_bank_wb;\n   assign btb_error_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = (dec_tlu_br0_error_wb | dec_tlu_br0_start_error_wb) ? dec_tlu_br0_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] : dec_tlu_br1_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO];\n\n   assign dec_tlu_way_wb = (dec_tlu_br0_error_wb | dec_tlu_br0_start_error_wb) ? dec_tlu_br0_way_wb : dec_tlu_br1_way_wb;\n\n   if(!pt.BTB_FULLYA) begin\n\n\nif (pt.BTB_BTAG_FOLD) begin : btbfold\n   eh2_btb_tag_hash_fold #(.pt(pt)) rdtagf1(.hash(fetch_rd_tag_f1[pt.BTB_BTAG_SIZE-1:0]),\n                                             .pc({ifc_fetch_addr_f1[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]}));\n   eh2_btb_tag_hash_fold #(.pt(pt)) rdtagp1f1(.hash(fetch_rd_tag_p1_f1[pt.BTB_BTAG_SIZE-1:0]),\n                                               .pc({fetch_addr_p1_f1[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]}));\nend\n   else begin\n   eh2_btb_tag_hash #(.pt(pt)) rdtagf1(.hash(fetch_rd_tag_f1[pt.BTB_BTAG_SIZE-1:0]),\n                                        .pc({ifc_fetch_addr_f1[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]}));\n   eh2_btb_tag_hash #(.pt(pt)) rdtagp1f1(.hash(fetch_rd_tag_p1_f1[pt.BTB_BTAG_SIZE-1:0]),\n                                          .pc({fetch_addr_p1_f1[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1]}));\nend\n\n   rvdffe #(.WIDTH(2*pt.BTB_BTAG_SIZE+1), .OVERRIDE(1)) rdtagf (.*,\n                                                                .en(ifc_fetch_req_f1),\n                                                                .din({ifc_select_tid_f1, fetch_rd_tag_f1[pt.BTB_BTAG_SIZE-1:0], fetch_rd_tag_p1_f1[pt.BTB_BTAG_SIZE-1:0]}),\n                                                                .dout({ifc_select_tid_f2, fetch_rd_tag_f2[pt.BTB_BTAG_SIZE-1:0], fetch_rd_tag_p1_f2[pt.BTB_BTAG_SIZE-1:0]}));\n\nend\n   else begin\n   rvdff #(.WIDTH(1)) rdtagf (.*, .clk(active_clk),\n                              .din({ifc_select_tid_f1}),\n                              .dout({ifc_select_tid_f2}));\n\n   end // else: !if(!pt.BTB_FULLYA)\n\n\n\n\n      assign bht_wr_en0 = bht_wr_en0_thr[0];\n      assign bht_wr_data0 = bht_wr_data0_thr[0];\n   rvdffe #(29) faddrf2_ff (.*, .en(ifc_fetch_req_f2 & ~ifu_bp_kill_next_f2 & ic_hit_f2 & ~ifc_select_tid_f2), .din(ifc_fetch_addr_f2[31:3]), .dout(ifc_fetch_adder_prior[0][31:3]));\n\n\n\n   if(pt.NUM_THREADS > 1) begin\n\n      rvdffe #(29) faddrf2__t1ff (.*, .en(ifc_fetch_req_f2 & ~ifu_bp_kill_next_f2 & ic_hit_f2 & ifc_select_tid_f2), .din(ifc_fetch_addr_f2[31:3]), .dout(ifc_fetch_adder_prior[1][31:3]));\n      assign bht_wr_en3 = bht_wr_en0_thr[1];\n      assign bht_wr_data3 = bht_wr_data0_thr[1];\n      assign bht_wr_addr3[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = mp_hashed[1][pt.BHT_ADDR_HI:pt.BHT_ADDR_LO];\n\n\n   end // if (pt.NUM_THREADS > 1)\n   else begin\n      assign bht_wr_en3 = 'b0;\n      assign bht_wr_data3 = 'b0;\n      assign bht_wr_addr3[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = 'b0;\n   end\n\n\n   assign bht_wr_en1[3:0] = {4{dec_tlu_br1_v_wb}} & decode2_4({dec_tlu_br1_bank_wb, dec_tlu_br1_middle_wb});\n   assign bht_wr_en2[3:0] = {4{dec_tlu_br0_v_wb}} & decode2_4({dec_tlu_br0_bank_wb, dec_tlu_br0_middle_wb});\n\n   assign bht_wr_data1[1:0] = dec_tlu_br1_hist_wb[1:0];\n   assign bht_wr_data2[1:0] = dec_tlu_br0_hist_wb[1:0]; // highest priority\n\n\n\n   eh2_btb_ghr_hash #(.pt(pt)) br0ghrhs  (.hashin(dec_tlu_br0_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]),\n                                           .ghr({dec_tlu_br0_fghr_wb[pt.BHT_GHR_SIZE-1:0]}),\n                                           .hash(br0_hashed_wb[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO]));\n   eh2_btb_ghr_hash #(.pt(pt)) br1ghrhs  (.hashin(dec_tlu_br1_addr_wb[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]),\n                                           .ghr({dec_tlu_br1_fghr_wb[pt.BHT_GHR_SIZE-1:0]}),\n                                           .hash(br1_hashed_wb[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO]));\n   eh2_btb_ghr_hash #(.pt(pt)) fghrhs    (.hashin(btb_rd_addr_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]),\n                                           .ghr({fghr_ns[ifc_select_tid_f1][pt.BHT_GHR_SIZE-1:0]}),\n                                           .hash(bht_rd_addr_hashed_f1[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO]));\n   eh2_btb_ghr_hash #(.pt(pt)) fghrhs_p1 (.hashin(btb_rd_addr_p1_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]),\n                                           .ghr({fghr_ns[ifc_select_tid_f1][pt.BHT_GHR_SIZE-1:0]}),\n                                  "}
{"text": "         .hash(bht_rd_addr_hashed_p1_f1[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO]));\n\n   assign bht_wr_addr0[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = mp_hashed[0][pt.BHT_ADDR_HI:pt.BHT_ADDR_LO];\n   assign bht_wr_addr1[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = br1_hashed_wb[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO];\n   assign bht_wr_addr2[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = br0_hashed_wb[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO];\n   assign bht_rd_addr_f1[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = bht_rd_addr_hashed_f1[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO];\n   assign bht_rd_addr_p1_f1[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = bht_rd_addr_hashed_p1_f1[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO];\n\n\nif(!pt.BTB_USE_SRAM) begin\n\n   assign btb_wr_en_error_way0[1:0] = ( ({2{~dec_tlu_way_wb & dec_tlu_error_wb & ~dec_tlu_all_banks_error_wb}} & decode1_2(dec_tlu_error_bank_wb)) |\n                                        ({2{~dec_tlu_way_wb & dec_tlu_all_banks_error_wb}}));\n\n   assign btb_wr_en_error_way1[1:0] = ( ({2{dec_tlu_way_wb & dec_tlu_error_wb & ~dec_tlu_all_banks_error_wb}} & decode1_2(dec_tlu_error_bank_wb)) |\n                                        ({2{dec_tlu_way_wb & dec_tlu_all_banks_error_wb}}));\n\n\n   // ----------------------------------------------------------------------\n   // Structures. Using FLOPS\n   // ----------------------------------------------------------------------\n   // BTB\n   // Entry -> tag[pt.BTB_BTAG_SIZE-1:0], toffset[pt.BTB_TOFFSET_SIZE-1:0], pc4, boffset, call, ret, valid\n\n    for (j=0 ; j<LRU_SIZE ; j++) begin : BTB_FLOPS\n\n      // Way 0\n       assign wr0_b0w0[j] = (btb_wr_addr[0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == j) & (~mp_collision | ~mp_collision_winner_tid) &\n                            ((~exu_mp_bank[0] & ~exu_mp_way[0] & exu_mp_valid_write[0]) | btb_wr_en_error_way0[0]);\n       assign wr0_b0w1[j] = (btb_wr_addr[0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == j) & (~mp_collision | ~mp_collision_winner_tid) &\n                            ((~exu_mp_bank[0] &  exu_mp_way[0] & exu_mp_valid_write[0]) | btb_wr_en_error_way1[0]);\n       assign wr0_b1w0[j] = (btb_wr_addr[0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == j) & (~mp_collision | ~mp_collision_winner_tid) &\n                            ((exu_mp_bank[0] & ~exu_mp_way[0] & exu_mp_valid_write[0]) | btb_wr_en_error_way0[1]);\n       assign wr0_b1w1[j] = (btb_wr_addr[0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == j) & (~mp_collision | ~mp_collision_winner_tid) &\n                            ((exu_mp_bank[0] &  exu_mp_way[0] & exu_mp_valid_write[0]) | btb_wr_en_error_way1[1]);\n\n       if (pt.NUM_THREADS > 1) begin\n       assign wr1_b0w0[j] = (btb_wr_addr[1][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == j) & (~mp_collision | mp_collision_winner_tid) &\n                            ((~exu_mp_bank[1] & ~exu_mp_way[1] & exu_mp_valid_write[1]) | btb_wr_en_error_way0[0]);\n       assign wr1_b0w1[j] = (btb_wr_addr[1][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == j) & (~mp_collision | mp_collision_winner_tid) &\n                            ((~exu_mp_bank[1] &  exu_mp_way[1] & exu_mp_valid_write[1]) | btb_wr_en_error_way1[0]);\n       assign wr1_b1w0[j] = (btb_wr_addr[1][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == j) & (~mp_collision | mp_collision_winner_tid) &\n                             ((exu_mp_bank[1] & ~exu_mp_way[1] & exu_mp_valid_write[1]) | btb_wr_en_error_way0[1]);\n       assign wr1_b1w1[j] = (btb_wr_addr[1][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == j) & (~mp_collision | mp_collision_winner_tid) &\n                             ((exu_mp_bank[1] &  exu_mp_way[1] & exu_mp_valid_write[1]) | btb_wr_en_error_way1[1]);\n\n\n       end\n       else begin\n          assign wr1_b0w0[j] = 'b0;\n          assign wr1_b0w1[j] = 'b0;\n          assign wr1_b1w0[j] = 'b0;\n          assign wr1_b1w1[j] = 'b0;\n       end\n\n          rvdffe #(BTB_DWIDTH) btb_bank0_way0 (.*,\n                    .en   (wr0_b0w0[j] | wr1_b0w0[j]),\n                    .din  (wr0_b0w0[j] ? btb_wr_data[0][BTB_DWIDTH-1:0] : btb_wr_data[1][BTB_DWIDTH-1:0]),\n                    .dout (btb_bank0_rd_data_way0_out[j]));\n\n          rvdffe #(BTB_DWIDTH) btb_bank1_way0 (.*,\n                    .en   (wr0_b1w0[j] | wr1_b1w0[j]),\n                    .din  (wr0_b1w0[j] ? btb_wr_data[0][BTB_DWIDTH-1:0] : btb_wr_data[1][BTB_DWIDTH-1:0]),\n                    .dout (btb_bank1_rd_data_way0_out[j]));\n\n      // Way 1\n          rvdffe #(BTB_DWIDTH) btb_bank0_way1 (.*,\n                    .en   (wr0_b0w1[j] | wr1_b0w1[j]),\n                    .din  (wr0_b0w1[j] ? btb_wr_data[0][BTB_DWIDTH-1:0] : btb_wr_data[1][BTB_DWIDTH-1:0]),\n                    .dout (btb_bank0_rd_data_way1_out[j]));\n\n          rvdffe #(BTB_DWIDTH) btb_bank1_way1 (.*,\n                    .en   (wr0_b1w1[j] | wr1_b1w1[j]),\n                    .din  (wr0_b1w1[j] ? btb_wr_data[0][BTB_DWIDTH-1:0] : btb_wr_data[1][BTB_DWIDTH-1:0]),\n                    .dout (btb_bank1_rd_data_way1_out[j]));\n\n    end\n\n   rvdffe #(BTB_DWIDTH) btb_bank0_way0_data_out (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_bank0_rd_data_way0_f2_in[BTB_DWIDTH-1:0]),\n                    .dout       (btb_bank0_rd_data_way0_f2   [BTB_DWIDTH-1:0]));\n\n   rvdffe #(BTB_DWIDTH) btb_bank1_way0_data_out (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_bank1_rd_data_way0_f2_in[BTB_DWIDTH-1:0]),\n                    .dout       (btb_bank1_rd_data_way0_f2   [BTB_DWIDTH-1:0]));\n\n   rvdffe #(BTB_DWIDTH) btb_bank0_way1_data_out (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_bank0_rd_data_way1_f2_in[BTB_DWIDTH-1:0]),\n                    .dout       (btb_bank0_rd_data_way1_f2   [BTB_DWIDTH-1:0]));\n\n   rvdffe #(BTB_DWIDTH) btb_bank1_way1_data_out (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_bank1_rd_data_way1_f2_in[BTB_DWIDTH-1:0]),\n                    .dout       (btb_bank1_rd_data_way1_f2   [BTB_DWIDTH-1:0]));\n\n\n   rvdffe #(BTB_DWIDTH) btb_bank0_way0_p1_data_out (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_bank0_rd_data_way0_p1_f2_in[BTB_DWIDTH-1:0]),\n                    .dout       (btb_bank0_rd_data_way0_p1_f2   [BTB_DWIDTH-1:0]));\n\n   rvdffe #(BTB_DWIDTH) btb_bank1_way0_p1_data_out (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_bank1_rd_data_way0_p1_f2_in[BTB_DWIDTH-1:0]),\n                    .dout       (btb_bank1_rd_data_way0_p1_f2   [BTB_DWIDTH-1:0]));\n\n   rvdffe #(BTB_DWIDTH) btb_bank0_way1_p1_data_out (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_bank0_rd_data_way1_p1_f2_in[BTB_DWIDTH-1:0]),\n                    .dout       (btb_bank0_rd_data_way1_p1_f2   [BTB_DWIDTH-1:0]));\n\n   rvdffe #(BTB_DWIDTH) btb_bank1_way1_p1_data_out (.*,\n                    .en(ifc_fetch_req_f1),\n                    .din        (btb_bank1_rd_data_way1_p1_f2_in[BTB_DWIDTH-1:0]),\n                    .dout       (btb_bank1_rd_data_way1_p1_f2   [BTB_DWIDTH-1:0]));\n\n\n    always_comb begin : BTB_rd_mux\n        btb_bank0_rd_data_way0_f2_in[BTB_DWIDTH-1:0] = '0 ;\n        btb_bank1_rd_data_way0_f2_in[BTB_DWIDTH-1:0] = '0 ;\n        btb_bank0_rd_data_way1_f2_in[BTB_DWIDTH-1:0] = '0 ;\n        btb_bank1_rd_data_way1_f2_in[BTB_DWIDTH-1:0] = '0 ;\n        btb_bank0_rd_data_way0_p1_f2_in[BTB_DWIDTH-1:0] = '0 ;\n        btb_bank1_rd_data_way0_p1_f2_in[BTB_DWIDTH-1:0] = '0 ;\n        btb_bank0_rd_data_way1_p1_f2_in[BTB_DWIDTH-1:0] = '0 ;\n        btb_bank1_rd_data_way1_p1_f2_in[BTB_DWIDTH-1:0] = '0 ;\n\n        for (int j=0; j< LRU_SIZE; j++) begin\n          if (btb_rd_addr_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == (pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1)'(j)) begin\n\n           btb_bank0_rd_data_way0_f2_in[BTB_DWIDTH-1:0] =  btb_bank0_rd_data_way0_out[j];\n           btb_bank1_rd_data_way0_f2_in[BTB_DWIDTH-1:0] =  btb_bank1_rd_data_way0_out[j];\n\n           btb_bank0_rd_data_way1_f2_in[BTB_DWIDTH-1:0] =  btb_bank0_rd_data_way1_out[j];\n           btb_bank1_rd_data_way1_f2_in[BTB_DWIDTH-1:0] =  btb_bank1_rd_data_way1_out[j];\n\n          end\n        end\n        for (int j=0; j< LRU_SIZE; j++) begin\n          if (btb_rd_addr_p1_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] == (pt.BTB_ADDR_HI-pt.BTB_ADDR_LO+1)'(j)) begin\n\n           btb_bank0_rd_data_way0_p1_f2_in[BTB_DWIDTH-1:0] =  btb_bank0_rd_data_way0_out[j];\n           btb_bank1_rd_data_way0_p1_f2_in[BTB_DWIDTH-1:0] =  btb_bank1_rd_data_way0_out[j];\n\n           btb_bank0_rd_data_way1_p1_f2_in[BTB_DWIDTH-1:0] =  btb_bank0_rd_data_way1_out[j];\n           btb_bank1_rd_data_way1_p1_f2_in[BTB_DWIDTH-1:0] =  btb_bank1_rd_data_way1_out[j];\n\n          end\n        end\n    end\nend // if (!pt.BTB_USE_SRAM)\n\n   // FULLYA - relocate after all the merging\n      if(pt.BTB_FULLYA) begin : fa\n\n         logic found1, found2, hit0, hit1, hit2, hit3, hit0_other, hit1_other, hit2_other, hit3_other, multihit;\n         logic btb_used_reset, write_used;\n         logic [$clog2(pt.BTB_SIZE)-1:0] btb_fa_wr_addr0, btb_fa_wr_addr1, hit0_index, hit1_index, hit2_index, hit3_index;\n         logic [$clog2(pt.BTB_SIZE)-1:0] hit0_other_index, hit1_other_index, hit2_other_index, hit3_other_index;\n\n         logic [pt.BTB_SIZE-1:0]         btb_tag_hit, btb_offset_0, btb_offset_1, btb_offset_2, btb_offset_3, btb_used_ns, btb_used,\n                                         btb_offset_0_f2, btb_offset_1_f2, btb_offset_2_f2, btb_offset_3_f2, wr0_en, wr1_en, wr_cleanup,\n                                         fa_fetch_mp_collision_f1, btb_upper_hit, btb_used_clr;\n         logic [pt.BTB_SIZE-1:0][BTB_DWIDTH-1:0] btbdata;\n\n         // Fully Associative tag hash uses bits 31:3. Bits 2:1 are the offset bits used for the 4 tag comp banks\n         // Full tag used to speed up lookup. There is one 31:3 cmp per entry, and 4 2:1 cmps per entry.\n\n         logic [FA_CMP_LOWER-1:1]  ifc_fetch_addr_p1_f1, ifc_fetch_addr_p2_f1, ifc_fetch_addr_p3_f1;\n\n\n         assign ifc_fetch_addr_p1_f1[FA_CMP_LOWER-1:1] = ifc_fetch_addr_f1[FA_CMP_LOWER-1:1] + 1'b1;\n         assign ifc_fetch_addr_p2_f1[FA_CMP_LOWER-1:1] = ifc_fetch_addr_f1[FA_CMP_LOWER-1:1] + 2'b10;\n         assign ifc_fetch_addr_p3_f1[FA_CMP_LOWER-1:1] = ifc_fetch_addr_f1[FA_CMP_LOWER-1:1] + 2'b11;\n\n      rvdffe #(4*pt.BTB_SIZE) btb_hitsf2 (.*, .clk(clk),\n                                          .en  (ifc_fetch_req_f1),\n                                          .din ({btb_offset_0, btb_offset_1, btb_offset_2, btb_offset_3}),\n                                          .dout({btb_offset_0_f2, btb_offset_1_f2, btb_offset_2_f2, btb_offset_3_f2}));\n\n      always_comb begin\n         btb_vbank0_rd_data_f2 = '0;\n         btb_vbank1_rd_data_f2 = '0;\n         btb_vbank2_rd_data_f2 = '0;\n         btb_vbank3_rd_data_f2 = '0;\n         btb_tag_hit = '0;\n         btb_upper_hit = '0;\n         btb_offset_0 = '0;\n         btb_offset_1 = '0;\n         btb_offset_2 = '0;\n         btb_offset_3 = '0;\n\n         found1 = 1'b0;\n         found2 = 1'b0;\n         hit0 = 1'b0;\n         hit1 = 1'b0;\n         hit2 = 1'b0;\n         hit3 = 1'b0;\n         hit0_index = '0;\n         hit1_index = '0;\n         hit2_index = '0;\n         hit3_index = '0;\n         hit0_other = 1'b0;\n         hit1_other = 1'b0;\n         hit2_other = 1'b0;\n         hit3_other = 1'b0;\n         hit0_other_index = '0;\n         hit1_other_index = '0;\n         hit2_other_index = '0;\n         hit3_other_index = '0;\n         btb_fa_wr_addr0 = '0;\n         btb_fa_wr_addr1 = '0;\n         fa_fetch_mp_collision_f1 = '0;\n\n         for(int i=0; i<pt.BTB_SIZE; i++) begin\n            // Break the cmp into chunks for lower area.\n            // Chunk1: FA 31:6 or 31:5 depending on icache line size\n            // Chunk2: FA 5:1 or 4:1 depending on icache line size\n            btb_upper_hit[i] = (btbdata[i][BTB_DWIDTH_TOP:FA_TAG_END_UPPER] == ifc_fetch_addr_f1[31:FA_CMP_LOWER]) & btbdata[i][0] & ~wr0_en[i] & ~wr1_en[i];\n            btb_offset_0[i] = (btbdata[i][FA_TAG_START_LOWER:FA_TAG_END_LOWER] == ifc_fetch_addr_f1[FA_CMP_LOWER-1:1]) & btb_upper_hit[i];\n            btb_offset_1[i] = (btbdata[i][FA_TAG_START_LOWER:FA_TAG_END_LOWER] == ifc_fetch_addr_p1_f1[FA_CMP_LOWER-1:1]) & btb_upper_hit[i];\n            btb_offset_2[i] = (btbdata[i][FA_TAG_START_LOWER:FA_TAG_END_LOWER] == ifc_fetch_addr_p2_f1[FA_CMP_LOWER-1:1]) & btb_upper_hit[i];\n            btb_offset_3[i] = (btbdata[i][FA_TAG_START_LOWER:FA_TAG_END_LOWER] == ifc_fetch_addr_p3_f1[FA_CMP_LOWER-1:1]) & btb_upper_hit[i];\n\n            if(~hit0) begin\n               if(btb_offset_0_f2[i]) begin\n                  hit0_index[BTB_FA_INDEX:0] = (BTB_FA_INDEX+1)'(i);\n                  // hit unless we are also writing this entry at the same time\n                  hit0 = 1'b1;\n               end\n            end\n            else if(~hit0_other) begin // find multihit\n               if(btb_offset_0_f2[i]) begin\n                  hit0_other_index[BTB_FA_INDEX:0] = (BTB_FA_INDEX+1)'(i);\n                  hit0_other = 1'b1;\n               end\n            end\n\n            if(~hit1) begin\n               if(btb_offset_1_f2[i]) begin\n                  hit1_index[BTB_FA_INDEX:0] = (BTB_FA_INDEX+1)'(i);\n                  hit1 = 1'b1;\n               end\n            end\n            else if(~hit1_other) begin // multihit\n               if(btb_offset_1_f2[i]) begin\n                  hit1_other_index[BTB_FA_INDEX:0] = (BTB_FA_INDEX+1)'(i);\n                  hit1_other = 1'b1;\n               end\n            end\n\n            if(~hit2) begin\n               if(btb_offset_2_f2[i]) begin\n                  hit2_index[BTB_FA_INDEX:0] = (BTB_FA_INDEX+1)'(i);\n                  hit2 = 1'b1;\n               end\n            end\n            else if(~hit2_other) begin // multihit\n               if(btb_offset_2_f2[i]) begin\n                  hit2_other_index[BTB_FA_INDEX:0] = (BTB_FA_INDEX+1)'(i);\n                  hit2_other = 1'b1;\n               end\n            end\n\n            if(~hit3) begin\n               if(btb_offset_3_f2[i]) begin\n                  hit3_index[BTB_FA_INDEX:0] = (BTB_FA_INDEX+1)'(i);\n                  hit3 = 1'b1;\n               end\n            end\n            else if(~hit3_other) begin // multihit\n               if(btb_offset_3_f2[i]) begin\n                  hit3_other_index[BTB_FA_INDEX:0] = (BTB_FA_INDEX+1)'(i);\n                  hit3_other = 1'b1;\n               end\n            end\n\n            // Mux out the 4 potential branches\n            if(btb_offset_0_f2[i] == 1'b1)\n              btb_vbank0_rd_data_f2[BTB_DWIDTH-1:0] = btbdata[i];\n            if(btb_offset_1_f2[i] == 1'b1)\n              btb_vbank1_rd_data_f2[BTB_DWIDTH-1:0] = btbdata[i];\n            if(btb_offset_2_f2[i] == 1'b1)\n              btb_vbank2_rd_data_f2[BTB_DWIDTH-1:0] = btbdata[i];\n            if(btb_offset_3_f2[i] == 1'b1)\n              btb_vbank3_rd_data_f2[BTB_DWIDTH-1:0] = btbdata[i];\n\n            // find the first zero from bit zero in the used vector, this is the write address\n            if(~found1) begin\n               if(~btb_used[i]) begin\n                  btb_fa_wr_addr0[BTB_FA_INDEX:0] = i[BTB_FA_INDEX:0];\n                  found1 = 1'b1;\n               end\n            end\n            // find the second zero from bit zero in the used vector, this is the write address for the\n            // case where both threads MP at the same time.\n            else if(~found2) begin\n               if(~btb_used[i]) begin\n                  btb_fa_wr_addr1[BTB_FA_INDEX:0] = i[BTB_FA_INDEX:0];\n                  found2 = 1'b1;\n               end\n            end\n\n         end\n      end // always_comb begin\n\n\n   assign vwayhit_f2[3:0] = {hit3, hit2, hit1, hit0} & {eoc_mask[3:1], 1'b1};\n\n   // a valid taken target needs to kill the next fetch as we compute the target address\n   assign ifu_bp_kill_next_f2 = |(vwayhit_f2[3:0] & hist1_raw[3:0]) & ifc_fetch_req_f2 & ~leak_one_f2[ifc_select_tid_f2] & ~dec_tlu_bpred_disable;\n\n   // way bit is reused as the predicted bit\n   assign way_raw[3:0] =  vwayhit_f2[3:0];\n\n   for (j=0 ; j<pt.BTB_SIZE ; j++) begin : BTB_FAFLOPS\n\n      assign wr0_en[j] = ((btb_fa_wr_addr0[BTB_FA_INDEX:0] == j) & (exu_mp_valid_write[0] & ~exu_mp_pkt[0].way)) |\n                         ((dec_fa_error_index == j) & dec_tlu_error_wb);\n      if(pt.NUM_THREADS>1)\n        assign wr1_en[j] = ((btb_fa_wr_addr1[BTB_FA_INDEX:0] == j) & (exu_mp_valid_write[1] & ~exu_mp_pkt[1].way)) |\n                           ((dec_fa_error_index == j) & dec_tlu_error_wb);\n      else\n        assign wr1_en[j] = '0;\n\n      assign wr_cleanup[j] = (hit0_other & (hit0_other_index[BTB_FA_INDEX:0] == (BTB_FA_INDEX+1)'(j))) |\n                             (hit1_other & (hit1_other_index[BTB_FA_INDEX:0] == (BTB_FA_INDEX+1)'(j))) |\n                             (hit2_other & (hit2_other_index[BTB_FA_INDEX:0] == (BTB_FA_INDEX+1)'(j))) |\n                             (hit3_other & (hit3_other_index[BTB_FA_INDEX:0] == (BTB_FA_INDEX+1)'(j))) ;\n\n      rvdffe #(BTB_DWIDTH) btb_fa (.*, .clk(clk),\n                                            .en  (wr0_en[j] | wr1_en[j] | wr_cleanup[j]),\n                                            .din (wr_cleanup[j] ? '0 : wr0_en[j] ? btb_wr_data[0][BTB_DWIDTH-1:0] : btb_wr_data[1][BTB_DWIDTH-1:0]),\n                                            .dout(btbdata[j]));\n   end\n\n   assign ifu_bp_fa_index_f2[3] = hit3 ? hit3_index : '0;\n   assign ifu_bp_fa_index_f2[2] = hit2 ? hit2_index : '0;\n   assign ifu_bp_fa_index_f2[1] = hit1 ? hit1_index : '0;\n   assign ifu_bp_fa_index_f2[0] = hit0 ? hit0_index : '0;\n\n   assign multihit = hit0_other | hit1_other | hit2_other | hit3_other;\n   if(pt.NUM_THREADS>1) begin\n     // need room for 2 for worst case MP on both threads at limit\n      assign btb_used_reset = &btb_used[pt.BTB_SIZE-2:0];\n      assign btb_used_clr[pt.BTB_SIZE-1:0] = ~(({pt.BTB_SIZE{hit0_other}} & (32'b1 << hit0_other_index[BTB_FA_INDEX:0])) |\n                                               ({pt.BTB_SIZE{hit1_other}} & (32'b1 << hit1_other_index[BTB_FA_INDEX:0])) |\n                                               ({pt.BTB_SIZE{hit2_other}} & (32'b1 << hit2_other_index[BTB_FA_INDEX:0])) |\n                                               ({pt.BTB_SIZE{hit3_other}} & (32'b1 << hit3_other_index[BTB_FA_INDEX:0])) ) & btb_used[pt.BTB_SIZE-1:0];\n\n      assign btb_used_ns[pt.BTB_SIZE-1:0] = ({pt.BTB_SIZE{vwayhit_f2[3]}} & (32'b1 << hit3_index[BTB_FA_INDEX:0])) |\n                                            ({pt.BTB_SIZE{vwayhit_f2[2]}} & (32'b1 << hit2_index[BTB_FA_INDEX:0])) |\n                                            ({pt.BTB_SIZE{vwayhit_f2[1]}} & (32'b1 << hit1_index[BTB_FA_INDEX:0])) |\n                                            ({pt.BTB_SIZE{vwayhit_f2[0]}} & (32'b1 << hit0_index[BTB_FA_INDEX:0])) |\n                                            ({pt.BTB_SIZE{exu_mp_valid_write[0] & ~exu_mp_pkt[0].way & ~dec_tlu_error_wb}} & (32'b1 << btb_fa_wr_addr0[BTB_FA_INDEX:0])) |\n                                            ({pt.BTB_SIZE{exu_mp_valid_write[1] & ~exu_mp_pkt[1].way & ~dec_tlu_error_wb}} & (32'b1 << btb_fa_wr_addr1[BTB_FA_INDEX:0])) |\n                                            ({pt.BTB_SIZE{btb_used_reset}} & {pt.BTB_SIZE{1'b0}}) |\n                                            ({pt.BTB_SIZE{~btb_used_reset & dec_tlu_error_wb}} & (btb_used_clr[pt.BTB_SIZE-1:0] & ~(32'b1 << dec_fa_error_index[BTB_FA_INDEX:0]))) |\n                                            (~{pt.BTB_SIZE{btb_used_reset | dec_tlu_error_wb}} & btb_used_clr[pt.BTB_SIZE-1:0]);\n\n      assign write_used = btb_used_reset | ifu_bp_kill_next_f2 | exu_mp_valid_write[0] | exu_mp_valid_write[1] | dec_tlu_error_wb | multihit;\n   end\n   else begin\n      assign btb_used_reset = &btb_used[pt.BTB_SIZE-1:0];\n      assign btb_used_clr[pt.BTB_SIZE-1:0] = ~(({pt.BTB_SIZE{hit0_other}} & (32'b1 << hit0_other_index[BTB_FA_INDEX:0])) |\n                                               ({pt.BTB_SIZE{hit1_other}} & (32'b1 << hit1_other_index[BTB_FA_INDEX:0])) |\n                                               ({pt.BTB_SIZE{hit2_other}} & (32'b1 << hit2_other_index[BTB_FA_INDEX:0])) |\n                                               ({pt.BTB_SIZE{hit3_other}} & (32'b1 << hit3_ot"}
{"text": "her_index[BTB_FA_INDEX:0])) ) & btb_used[pt.BTB_SIZE-1:0];\n      assign btb_used_ns[pt.BTB_SIZE-1:0] = ({pt.BTB_SIZE{vwayhit_f2[3]}} & (32'b1 << hit3_index[BTB_FA_INDEX:0])) |\n                                            ({pt.BTB_SIZE{vwayhit_f2[2]}} & (32'b1 << hit2_index[BTB_FA_INDEX:0])) |\n                                            ({pt.BTB_SIZE{vwayhit_f2[1]}} & (32'b1 << hit1_index[BTB_FA_INDEX:0])) |\n                                            ({pt.BTB_SIZE{vwayhit_f2[0]}} & (32'b1 << hit0_index[BTB_FA_INDEX:0])) |\n                                            ({pt.BTB_SIZE{exu_mp_valid_write[0] & ~exu_mp_pkt[0].way & ~dec_tlu_error_wb}} & (32'b1 << btb_fa_wr_addr0[BTB_FA_INDEX:0])) |\n                                            ({pt.BTB_SIZE{btb_used_reset}} & {pt.BTB_SIZE{1'b0}}) |\n                                            ({pt.BTB_SIZE{~btb_used_reset & dec_tlu_error_wb}} & (btb_used_clr[pt.BTB_SIZE-1:0] & ~(32'b1 << dec_fa_error_index[BTB_FA_INDEX:0]))) |\n                                            (~{pt.BTB_SIZE{btb_used_reset | dec_tlu_error_wb}} & btb_used_clr[pt.BTB_SIZE-1:0]);\n\n      assign write_used = btb_used_reset | ifu_bp_kill_next_f2 | exu_mp_valid_write[0] | dec_tlu_error_wb | multihit;\n   end\n\n   rvdffe #(pt.BTB_SIZE) btb_usedf (.*, .clk(clk),\n                    .en  (write_used),\n                    .din (btb_used_ns[pt.BTB_SIZE-1:0]),\n                    .dout(btb_used[pt.BTB_SIZE-1:0]));\n\n\nend // block: fa\n\n\n\n\n   //-----------------------------------------------------------------------------\n   // BHT\n   // 2 bit Entry -> direction, strength\n   //\n   //-----------------------------------------------------------------------------\n\n   for ( i=0; i<4; i++) begin : BANKS\n     for (genvar k=0 ; k < (pt.BHT_ARRAY_DEPTH)/NUM_BHT_LOOP ; k++) begin : BHT_CLK_GROUP\n     assign bht_bank_clken[i][k]  = (bht_wr_en0[i] & ((bht_wr_addr0[pt.BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) |  BHT_NO_ADDR_MATCH)) |\n                                    (bht_wr_en1[i] & ((bht_wr_addr1[pt.BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) |  BHT_NO_ADDR_MATCH)) |\n                                    (bht_wr_en2[i] & ((bht_wr_addr2[pt.BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) |  BHT_NO_ADDR_MATCH)) |\n                                    (bht_wr_en3[i] & ((bht_wr_addr3[pt.BHT_ADDR_HI: NUM_BHT_LOOP_OUTER_LO]==k) |  BHT_NO_ADDR_MATCH));\n\n `ifndef RV_FPGA_OPTIMIZE\n    rvclkhdr bht_bank_grp_cgc ( .en(bht_bank_clken[i][k]), .l1clk(bht_bank_clk[i][k]), .* );\n`endif\n     for (j=0 ; j<NUM_BHT_LOOP ; j++) begin : BHT_FLOPS\n\n        wire[3:0] wr_sel = {\n                             bht_wr_en3[i] && bht_wr_addr3 == (j+16*k),\n                             bht_wr_en2[i] && bht_wr_addr2 == (j+16*k),\n                             bht_wr_en1[i] && bht_wr_addr1 == (j+16*k),\n                             bht_wr_en0[i] && bht_wr_addr0 == (j+16*k)\n                            };\n\n        wire[1:0] wdata  = wr_sel[2] ? bht_wr_data2[1:0] :\n                           wr_sel[1] ? bht_wr_data1[1:0] :\n                            // wr_en0 is thread 0, wr_en3 is thread 1. Consider collisions and kill t0 if t1 wins arb\n                           (wr_sel[0] & (~mp_bht_collision | ~mp_bht_collision_winner_tid))\n                                     ? bht_wr_data0[1:0] : bht_wr_data3[1:0];\n\n          rvdffs_fpga #(2) bht_bank (.*,\n                                     .clk        (bht_bank_clk[i][k]),\n                                     .rawclk     (clk),\n                                     .en         (|wr_sel),\n                                     .clken      (bht_bank_clken[i][k]),\n                                     .din        (wdata),\n                                     .dout       (bht_bank_rd_data_out[i][(16*k)+j]));\n\n\n\n     end // block: BHT_FLOPS\n     end // block: BHT_CLK_GROUP\n   end // block: BANKS\n\n    always_comb begin : BHT_rd_mux\n     bht_bank0_rd_data_f2_in[1:0] = '0 ;\n     bht_bank1_rd_data_f2_in[1:0] = '0 ;\n     bht_bank2_rd_data_f2_in[1:0] = '0 ;\n     bht_bank3_rd_data_f2_in[1:0] = '0 ;\n     bht_bank0_rd_data_p1_f2_in[1:0] = '0 ;\n     bht_bank1_rd_data_p1_f2_in[1:0] = '0 ;\n     bht_bank2_rd_data_p1_f2_in[1:0] = '0 ;\n     for (int j=0; j< pt.BHT_ARRAY_DEPTH; j++) begin\n       if (bht_rd_addr_f1[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] == (pt.BHT_ADDR_HI-pt.BHT_ADDR_LO+1)'(j)) begin\n         bht_bank0_rd_data_f2_in[1:0] = bht_bank_rd_data_out[0][j];\n         bht_bank1_rd_data_f2_in[1:0] = bht_bank_rd_data_out[1][j];\n         bht_bank2_rd_data_f2_in[1:0] = bht_bank_rd_data_out[2][j];\n         bht_bank3_rd_data_f2_in[1:0] = bht_bank_rd_data_out[3][j];\n       end\n       if (bht_rd_addr_p1_f1[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] == (pt.BHT_ADDR_HI-pt.BHT_ADDR_LO+1)'(j)) begin\n         bht_bank0_rd_data_p1_f2_in[1:0] = bht_bank_rd_data_out[0][j];\n         bht_bank1_rd_data_p1_f2_in[1:0] = bht_bank_rd_data_out[1][j];\n         bht_bank2_rd_data_p1_f2_in[1:0] = bht_bank_rd_data_out[2][j];\n       end\n      end\n    end // block: BHT_rd_mux\n\n\n\n   rvdffe #(14) bht_dataoutf (.*, .en         (ifc_fetch_req_f1),\n                                 .din        ({bht_bank0_rd_data_f2_in[1:0],\n                                               bht_bank1_rd_data_f2_in[1:0],\n                                               bht_bank2_rd_data_f2_in[1:0],\n                                               bht_bank3_rd_data_f2_in[1:0],\n                                               bht_bank0_rd_data_p1_f2_in[1:0],\n                                               bht_bank1_rd_data_p1_f2_in[1:0],\n                                               bht_bank2_rd_data_p1_f2_in[1:0]\n                                               }),\n                                 .dout       ({bht_bank0_rd_data_f2   [1:0],\n                                               bht_bank1_rd_data_f2   [1:0],\n                                               bht_bank2_rd_data_f2   [1:0],\n                                               bht_bank3_rd_data_f2   [1:0],\n                                               bht_bank0_rd_data_p1_f2   [1:0],\n                                               bht_bank1_rd_data_p1_f2   [1:0],\n                                               bht_bank2_rd_data_p1_f2   [1:0]\n                                               }));\n\n\n\n\n     function [2:0] encode8_3;\n      input [7:0] in;\n\n      encode8_3[2] = |in[7:4];\n      encode8_3[1] = in[7] | in[6] | in[3] | in[2];\n      encode8_3[0] = in[7] | in[5] | in[3] | in[1];\n\n   endfunction\n     function [1:0] encode4_2;\n      input [3:0] in;\n\n      encode4_2[1] = in[3] | in[2];\n      encode4_2[0] = in[3] | in[1];\n\n   endfunction\n   function [7:0] decode3_8;\n      input [2:0] in;\n\n      decode3_8[7] =  in[2] &  in[1] &  in[0];\n      decode3_8[6] =  in[2] &  in[1] & ~in[0];\n      decode3_8[5] =  in[2] & ~in[1] &  in[0];\n      decode3_8[4] =  in[2] & ~in[1] & ~in[0];\n      decode3_8[3] = ~in[2] &  in[1] &  in[0];\n      decode3_8[2] = ~in[2] &  in[1] & ~in[0];\n      decode3_8[1] = ~in[2] & ~in[1] &  in[0];\n      decode3_8[0] = ~in[2] & ~in[1] & ~in[0];\n\n   endfunction\n   function [3:0] decode2_4;\n      input [1:0] in;\n\n      decode2_4[3] =  in[1] &  in[0];\n      decode2_4[2] =  in[1] & ~in[0];\n      decode2_4[1] = ~in[1] &  in[0];\n      decode2_4[0] = ~in[1] & ~in[0];\n\n   endfunction\n   function [1:0] decode1_2;\n      input  in;\n\n      decode1_2[1] = in;\n      decode1_2[0] = ~in;\n\n   endfunction\n\n   function [2:0] countones;\n      input [3:0] valid;\n\n      begin\n\ncountones[2:0] = {2'b0, valid[3]} +\n                 {2'b0, valid[2]} +\n                 {2'b0, valid[1]} +\n                 {2'b0, valid[0]};\n      end\n   endfunction\n   function [2:0] newlru; // updated lru\n      input [2:0] lru;// current lru\n      input [1:0] used;// hit way\n      begin\nnewlru[2] = (lru[2] & ~used[0]) | (~used[1] & ~used[0]);\nnewlru[1] = (~used[1] & ~used[0]) | (used[0]);\nnewlru[0] = (~lru[2] & lru[1] & ~used[1] & ~used[0]) | (~lru[1] & ~lru[0] & used[0]) | (\n    ~lru[2] & lru[0] & used[0]) | (lru[0] & ~used[1] & ~used[0]);\n      end\n   endfunction //\n\n   function [1:0] lru2way; // new repl way taking invalid ways into account\n      input [2:0] lru; // current lru\n      input [2:0] v; // current way valids\n      begin\n         lru2way[1] = (~lru[2] & lru[1] & ~lru[0] & v[1] & v[0]) | (lru[2] & lru[0] & v[1] & v[0]) | (~v[2] & v[1] & v[0]);\n         lru2way[0] = (lru[2] & ~lru[0] & v[2] & v[0]) | (~v[1] & v[0]);\n      end\n   endfunction\n`undef TAG\nendmodule // eh2_ifu_bp_ctl\n\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or it's affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n//********************************************************************************\n// Branch Target Buffer (BTB) SRAM\n//********************************************************************************\nmodule eh2_ifu_btb_mem\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n )(\n   input logic                                        clk,\n   input logic                                        active_clk,\n   input logic                                        rst_l,\n   input logic                                        clk_override,\n\n   input  eh2_ccm_ext_in_pkt_t   [1:0] btb_ext_in_pkt,\n\n   input logic                         btb_wren,\n   input logic                         btb_rden,\n   input logic [1:0] [pt.BTB_ADDR_HI:1] btb_rw_addr,  // per bank read addr, bank0 has write addr\n   input logic [1:0] [pt.BTB_ADDR_HI:1] btb_rw_addr_f1,  // per bank read addr, bank0 has write addr\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]         btb_sram_wr_data,\n   input logic [1:0] [pt.BTB_BTAG_SIZE-1:0] btb_sram_rd_tag_f1,\n\n\n   output eh2_btb_sram_pkt btb_sram_pkt,\n\n   output logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank0_rd_data_f1,\n   output logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank1_rd_data_f1,\n   output logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank2_rd_data_f1,\n   output logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank3_rd_data_f1,\n\n   input  logic                                       scan_mode\n\n);\n\n   localparam BTB_DWIDTH =  pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5;\n\n`define RV_TAG BTB_DWIDTH-1:BTB_DWIDTH-pt.BTB_BTAG_SIZE\n   localparam PC4=4;\n   localparam BOFF=3;\n   localparam BV=0;\n\n   logic [1:0][1:0] [2*BTB_DWIDTH-1:0] btb_rd_data, btb_rd_data_raw;\n\n   logic [BTB_DWIDTH-1:0]          btb_bank0e_rd_data_f1, btb_bank0e_rd_data_p1_f1;\n   logic [BTB_DWIDTH-1:0]          btb_bank1e_rd_data_f1, btb_bank1e_rd_data_p1_f1;\n   logic [BTB_DWIDTH-1:0]          btb_bank0o_rd_data_f1, btb_bank0o_rd_data_p1_f1;\n   logic [BTB_DWIDTH-1:0]          btb_bank1o_rd_data_f1;\n   logic [BTB_DWIDTH-1:0]          btb_bank0_rd_data_way0_f1, btb_bank0_rd_data_way0_p1_f1;\n   logic [BTB_DWIDTH-1:0]          btb_bank1_rd_data_way0_f1, btb_bank1_rd_data_way0_p1_f1;\n   logic [BTB_DWIDTH-1:0]          btb_bank0_rd_data_way1_f1, btb_bank0_rd_data_way1_p1_f1;\n   logic [BTB_DWIDTH-1:0]          btb_bank1_rd_data_way1_f1, btb_bank1_rd_data_way1_p1_f1;\n\n   logic [(4*BTB_DWIDTH)-1:0]      btb_bit_en_vec;\n   logic       wr_way0_en, wr_way1_en, btb_rden_f1, btb_wren_f1, btb_sram_wr_datav_f1;\n\n   logic [3:0]  tag_match_way0_expanded_f1, tag_match_way1_expanded_f1,\n                tag_match_way0_expanded_p1_f1, tag_match_way1_expanded_p1_f1;\n   logic [1:0]  tag_match_way0_f1, tag_match_way0_p1_f1,\n                tag_match_way1_f1, tag_match_way1_p1_f1;\n   logic [pt.BTB_BTAG_SIZE-1:0] fetch_rd_tag_f1, fetch_rd_tag_p1_f1;\n   logic [1:0]                  wren_bank;\n\n   logic [3:0] fetch_start_f1;\n   logic [3:0] btb_rd0_valid, btb_rd1_valid;\n   logic [pt.BTB_SIZE-1:0] btb_write_entry, btb_valid_ns, btb_valid;\n\n   assign fetch_start_f1[3:0] = (4'b1 << btb_rw_addr_f1[1][2:1]);\n\n   // ----------------------------------------------------------------------\n   // READ\n   // ----------------------------------------------------------------------\n\n   //\n   //\n   // Addresses\n   // [N:4] index hash of fetch addess [31:4]+1\n   // [N:4] index hash\n   // [3] bank bit\n   // [2:1] fetch start\n   //\n\n   // Map sram output to flop naming convention, ugh\n   assign btb_bank0_rd_data_way0_f1    = btb_rw_addr_f1[1][3] ? {btb_rd_data[1][0][BTB_DWIDTH-1:1], btb_rd1_valid[0]} :\n                                         {btb_rd_data[0][0][BTB_DWIDTH-1:1], btb_rd0_valid[0]};\n   assign btb_bank0_rd_data_way1_f1    = btb_rw_addr_f1[1][3] ? {btb_rd_data[1][0][(2*BTB_DWIDTH)-1:BTB_DWIDTH+1], btb_rd1_valid[1]} :\n                                         {btb_rd_data[0][0][(2*BTB_DWIDTH)-1:BTB_DWIDTH+1], btb_rd0_valid[1]};\n   assign btb_bank1_rd_data_way0_f1    = btb_rw_addr_f1[1][3] ? {btb_rd_data[1][1][BTB_DWIDTH-1:1], btb_rd1_valid[2]} :\n                                         {btb_rd_data[0][1][BTB_DWIDTH-1:1], btb_rd0_valid[2]};\n   assign btb_bank1_rd_data_way1_f1    = btb_rw_addr_f1[1][3] ? {btb_rd_data[1][1][(2*BTB_DWIDTH)-1:BTB_DWIDTH+1], btb_rd1_valid[3]} :\n                                         {btb_rd_data[0][1][(2*BTB_DWIDTH)-1:BTB_DWIDTH+1], btb_rd0_valid[3]};\n   assign btb_bank0_rd_data_way0_p1_f1 = btb_rw_addr_f1[1][3] ? {btb_rd_data[0][0][BTB_DWIDTH-1:1], btb_rd0_valid[0]} :\n                                         {btb_rd_data[1][0][BTB_DWIDTH-1:1], btb_rd1_valid[0]};\n   assign btb_bank0_rd_data_way1_p1_f1 = btb_rw_addr_f1[1][3] ? {btb_rd_data[0][0][(2*BTB_DWIDTH)-1:BTB_DWIDTH+1], btb_rd0_valid[1]} :\n                                         {btb_rd_data[1][0][(2*BTB_DWIDTH)-1:BTB_DWIDTH+1], btb_rd1_valid[1]};\n   assign btb_bank1_rd_data_way0_p1_f1 = btb_rw_addr_f1[1][3] ? {btb_rd_data[0][1][BTB_DWIDTH-1:1], btb_rd0_valid[2]} :\n                                         {btb_rd_data[1][1][BTB_DWIDTH-1:1], btb_rd1_valid[2]};\n   assign btb_bank1_rd_data_way1_p1_f1 = btb_rw_addr_f1[1][3] ? {btb_rd_data[0][1][(2*BTB_DWIDTH)-1:BTB_DWIDTH+1], btb_rd0_valid[3]} :\n                                         {btb_rd_data[1][1][(2*BTB_DWIDTH)-1:BTB_DWIDTH+1], btb_rd1_valid[3]};\n\n   // 2 -way SA, figure out the way hit and mux accordingly\n   assign tag_match_way0_f1[1:0] = {btb_bank1_rd_data_way0_f1[BV] & (btb_bank1_rd_data_way0_f1[`RV_TAG] == btb_sram_rd_tag_f1[0][pt.BTB_BTAG_SIZE-1:0]),\n                                    btb_bank0_rd_data_way0_f1[BV] & (btb_bank0_rd_data_way0_f1[`RV_TAG] == btb_sram_rd_tag_f1[0][pt.BTB_BTAG_SIZE-1:0])} &\n                                   {2{btb_rden_f1}};\n\n   assign tag_match_way1_f1[1:0] = {btb_bank1_rd_data_way1_f1[BV] & (btb_bank1_rd_data_way1_f1[`RV_TAG] == btb_sram_rd_tag_f1[0][pt.BTB_BTAG_SIZE-1:0]),\n                                    btb_bank0_rd_data_way1_f1[BV] & (btb_bank0_rd_data_way1_f1[`RV_TAG] == btb_sram_rd_tag_f1[0][pt.BTB_BTAG_SIZE-1:0])} &\n                                   {2{btb_rden_f1}};\n\n\n   assign tag_match_way0_p1_f1[1:0] = {btb_bank1_rd_data_way0_p1_f1[BV] & (btb_bank1_rd_data_way0_p1_f1[`RV_TAG] == btb_sram_rd_tag_f1[1][pt.BTB_BTAG_SIZE-1:0]),\n                                       btb_bank0_rd_data_way0_p1_f1[BV] & (btb_bank0_rd_data_way0_p1_f1[`RV_TAG] == btb_sram_rd_tag_f1[1][pt.BTB_BTAG_SIZE-1:0])} &\n                                      {2{btb_rden_f1}};\n\n   assign tag_match_way1_p1_f1[1:0] = {btb_bank1_rd_data_way1_p1_f1[BV] & (btb_bank1_rd_data_way1_p1_f1[`RV_TAG] == btb_sram_rd_tag_f1[1][pt.BTB_BTAG_SIZE-1:0]),\n                                       btb_bank0_rd_data_way1_p1_f1[BV] & (btb_bank0_rd_data_way1_p1_f1[`RV_TAG] == btb_sram_rd_tag_f1[1][pt.BTB_BTAG_SIZE-1:0])} &\n                                      {2{btb_rden_f1}};\n\n\n   // Both ways could hit, use the offset bit to reorder\n\n   assign tag_match_way0_expanded_f1[3:0] = {tag_match_way0_f1[1] &  (btb_bank1_rd_data_way0_f1[BOFF] ^ btb_bank1_rd_data_way0_f1[PC4]),\n                                             tag_match_way0_f1[1] & ~(btb_bank1_rd_data_way0_f1[BOFF] ^ btb_bank1_rd_data_way0_f1[PC4]),\n                                             tag_match_way0_f1[0] &  (btb_bank0_rd_data_way0_f1[BOFF] ^ btb_bank0_rd_data_way0_f1[PC4]),\n                                             tag_match_way0_f1[0] & ~(btb_bank0_rd_data_way0_f1[BOFF] ^ btb_bank0_rd_data_way0_f1[PC4])};\n\n   assign tag_match_way1_expanded_f1[3:0] = {tag_match_way1_f1[1] &  (btb_bank1_rd_data_way1_f1[BOFF] ^ btb_bank1_rd_data_way1_f1[PC4]),\n                                             tag_match_way1_f1[1] & ~(btb_bank1_rd_data_way1_f1[BOFF] ^ btb_bank1_rd_data_way1_f1[PC4]),\n                                             tag_match_way1_f1[0] &  (btb_bank0_rd_data_way1_f1[BOFF] ^ btb_bank0_rd_data_way1_f1[PC4]),\n                                             tag_match_way1_f1[0] & ~(btb_bank0_rd_data_way1_f1[BOFF] ^ btb_bank0_rd_data_way1_f1[PC4])};\n\n   assign tag_match_way0_expanded_p1_f1[3:0] = {tag_match_way0_p1_f1[1] &  (btb_bank1_rd_data_way0_p1_f1[BOFF] ^ btb_bank1_rd_data_way0_p1_f1[PC4]),\n                                                tag_match_way0_p1_f1[1] & ~(btb_bank1_rd_data_way0_p1_f1[BOFF] ^ btb_bank1_rd_data_way0_p1_f1[PC4]),\n                                                tag_match_way0_p1_f1[0] &  (btb_bank0_rd_data_way0_p1_f1[BOFF] ^ btb_bank0_rd_data_way0_p1_f1[PC4]),\n                                                tag_match_way0_p1_f1[0] & ~(btb_bank0_rd_data_way0_p1_f1[BOFF] ^ btb_bank0_rd_data_way0_p1_f1[PC4])};\n\n   assign tag_match_way1_expanded_p1_f1[3:0] = {tag_match_way1_p1_f1[1] &  (btb_bank1_rd_data_way1_p1_f1[BOFF] ^ btb_bank1_rd_data_way1_p1_f1[PC4]),\n                                                tag_match_way1_p1_f1[1] & ~(btb_bank1_rd_data_way1_p1_f1[BOFF] ^ btb_bank1_rd_data_way1_p1_f1[PC4]),\n                                                tag_match_way1_p1_f1[0] &  (btb_bank0_rd_data_way1_p1_f1[BOFF] ^ btb_bank0_rd_data_way1_p1_f1[PC4]),\n                                                tag_match_way1_p1_f1[0] & ~(btb_bank0_rd_data_way1_p1_f1[BOFF] ^ btb_bank0_rd_data_way1_p1_f1[PC4])};\n\n   assign btb_sram_pkt.wayhit_f1[3:0] = tag_match_way0_expanded_f1[3:0] | tag_match_way1_expanded_f1[3:0];\n   assign btb_sram_pkt.wayhit_p1_f1[3:0] = tag_match_way0_expanded_p1_f1[3:0] | tag_match_way1_expanded_p1_f1[3:0];\n   assign btb_sram_pkt.tag_match_way0_f1[1:0] = tag_match_way0_f1[1:0];\n   assign btb_sram_pkt.tag_match_way0_p1_f1[1:0] = tag_match_way0_p1_f1[1:0];\n   assign btb_sram_pkt.tag_match_vway1_expanded_f1[3:0] = ( ({4{fetch_start_f1[0]}} & {tag_match_way1_expanded_f1[3:0]}) |\n                                                            ({4{fetch_start_f1[1]}} & {tag_match_way1_expanded_p1_f1[0], tag_match_way1_expanded_f1[3:1]}) |\n                                                            ({4{fetch_start_f1[2]}} & {tag_match_way1_expanded_p1_f1[1:0], tag_match_way1_expanded_f1[3:2]}) |\n                                                            ({4{fetch_start_f1[3]}} & {tag_match_way1_expanded_p1_f1[2:0], tag_match_way1_expanded_f1[3]}) );\n\n   assign btb_bank1o_rd_data_f1[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_f1[3]}} & btb_bank1_rd_data_way0_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{tag_match_way1_expanded_f1[3]}} & btb_bank1_rd_data_way1_f1[BTB_DWIDTH-1:0]) );\n   assign btb_bank1e_rd_data_f1[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_f1[2]}} & btb_bank1_rd_data_way0_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{tag_match_way1_expanded_f1[2]}} & btb_bank1_rd_data_way1_f1[BTB_DWIDTH-1:0]) );\n\n   assign btb_bank0o_rd_data_f1[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_f1[1]}} & btb_bank0_rd_data_way0_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{tag_match_way1_expanded_f1[1]}} & btb_bank0_rd_data_way1_f1[BTB_DWIDTH-1:0]) );\n   assign btb_bank0e_rd_data_f1[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_f1[0]}} & btb_bank0_rd_data_way0_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{tag_match_way1_expanded_f1[0]}} & btb_bank0_rd_data_way1_f1[BTB_DWIDTH-1:0]) );\n\n\n   assign btb_bank1e_rd_data_p1_f1[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_p1_f1[2]}} & btb_bank1_rd_data_way0_p1_f1[BTB_DWIDTH-1:0]) |\n                                                        ({BTB_DWIDTH{tag_match_way1_expanded_p1_f1[2]}} & btb_bank1_rd_data_way1_p1_f1[BTB_DWIDTH-1:0]) );\n   assign btb_bank0o_rd_data_p1_f1[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_p1_f1[1]}} & btb_bank0_rd_data_way0_p1_f1[BTB_DWIDTH-1:0]) |\n                                                        ({BTB_DWIDTH{tag_match_way1_expanded_p1_f1[1]}} & btb_bank0_rd_data_way1_p1_f1[BTB_DWIDTH-1:0]) );\n   assign btb_bank0e_rd_data_p1_f1[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{tag_match_way0_expanded_p1_f1[0]}} & btb_bank0_rd_data_way0_p1_f1[BTB_DWIDTH-1:0]) |\n                                                        ({BTB_DWIDTH{tag_match_way1_expanded_p1_f1[0]}} & btb_bank0_rd_data_way1_p1_f1[BTB_DWIDTH-1:0]) );\n\n\n   // virtual bank order, final 4 branches\n\n   assign btb_vbank0_rd_data_f1[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{fetch_start_f1[0]}} &  btb_bank0e_rd_data_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f1[1]}} &  btb_bank0o_rd_data_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f1[2]}} &  btb_bank1e_rd_data_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f1[3]}} &  btb_bank1o_rd_data_f1[BTB_DWIDTH-1:0]) );\n   assign btb_vbank1_rd_data_f1[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{fetch_start_f1[0]}} &  btb_bank0o_rd_data_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f1[1]}} &  btb_bank1e_rd_data_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f1[2]}} &  btb_bank1o_rd_data_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f1[3]}} &  btb_bank0e_rd_data_p1_f1[BTB_DWIDTH-1:0]) );\n   assign btb_vbank2_rd_data_f1[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{fetch_start_f1[0]}} &  btb_bank1e_rd_data_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f1[1]}} &  btb_bank1o_rd_data_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f1[2]}} &  btb_bank0e_rd_data_p1_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f1[3]}} &  btb_bank0o_rd_data_p1_f1[BTB_DWIDTH-1:0]) );\n   assign btb_vbank3_rd_data_f1[BTB_DWIDTH-1:0] = ( ({BTB_DWIDTH{fetch_start_f1[0]}} &  btb_bank1o_rd_data_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f1[1]}} &  btb_bank0e_rd_data_p1_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f1[2]}} &  btb_bank0o_rd_data_p1_f1[BTB_DWIDTH-1:0]) |\n                                                     ({BTB_DWIDTH{fetch_start_f1[3]}} &  btb_bank1e_rd_data_p1_f1[BTB_DWIDTH-1:0]) );\n\n   // ----------------------------------------------------------------------\n   // WRITE\n   // ----------------------------------------------------------------------\n\n   // only write sram if validating entry\n   assign wren_bank[1:0] = {btb_wren & btb_rw_addr[0][3] & btb_sram_wr_data[0], btb_wren & ~btb_rw_addr[0][3] & btb_sram_wr_data[0]};\n\n   assign wr_way0_en = btb_wren & ~btb_rw_addr[0][1];\n   assign wr_way1_en = btb_wren &  btb_rw_addr[0][1];\n   // Way 0, addr 0\n   assign btb_bit_en_vec[BTB_DWIDTH-1:0]              = {BTB_DWIDTH{wr_way0_en & ~btb_rw_addr[0][2]}};\n   // Way 1, addr 0\n   assign btb_bit_en_vec[2*BTB_DWIDTH-1:BTB_DWIDTH]   = {BTB_DWIDTH{wr_way1_en & ~btb_rw_addr[0][2]}};\n   // Way 0, addr 4\n   assign btb_bit_en_vec[3*BTB_DWIDTH-1:2*BTB_DWIDTH] = {BTB_DWIDTH{wr_way0_en & btb_rw_addr[0][2]}};\n   // Way 1, addr 4\n   assign btb_bit_en_vec[4*BTB_DWIDTH-1:3*BTB_DWIDTH] = {BTB_DWIDTH{wr_way1_en & btb_rw_addr[0][2]}};\n\n\n   // Valid bit (F1)\n   assign btb_write_entry[pt.BTB_SIZE-1:0] = ({{pt.BTB_SIZE-1{1'b0}},1'b1} << btb_rw_addr_f1[0]);\n   assign btb_valid_ns[pt.BTB_SIZE-1:0] = (btb_wren_f1 & btb_sram_wr_datav_f1) ?\n                                          (btb_valid[pt.BTB_SIZE-1:0] | btb_write_entry[pt.BTB_SIZE-1:0]) :\n                                          ((btb_wren_f1 & ~btb_sram_wr_datav_f1) ? (btb_valid[pt.BTB_SIZE-1:0] & ~btb_write_entry[pt.BTB_SIZE-1:0]) :\n                                           btb_valid[pt.BTB_SIZE-1:0]);\n   rvdffe #(pt.BTB_SIZE) btb_valid_ff (.*, .clk(clk),\n                                         .en(btb_wren_f1),\n                                         .din  (btb_valid_ns[pt.BTB_SIZE-1:0]),\n                                         .dout (btb_valid[pt.BTB_SIZE-1:0]));\n\n   assign btb_rd0_valid[3] = btb_rden_f1 & btb_valid[{btb_rw_addr_f1[0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1],3'b011}];\n   assign btb_rd0_valid[2] = btb_rden_f1 & btb_valid[{btb_rw_addr_f1[0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1],3'b010}];\n   assign btb_rd0_valid[1] = btb_rden_f1 & btb_valid[{btb_rw_addr_f1[0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1],3'b001}];\n   assign btb_rd0_valid[0] = btb_rden_f1 & btb_valid[{btb_rw_addr_f1[0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1],3'b000}];\n\n   assign btb_rd1_valid[3] = btb_rden_f1 & btb_valid[{btb_rw_addr_f1[1][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1],3'b111}];\n   assign btb_rd1_valid[2] = btb_rden_f1 & btb_valid[{btb_rw_addr_f1[1][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1],3'b110}];\n   assign btb_rd1_valid[1] = btb_rden_f1 & btb_valid[{btb_rw_addr_f1[1][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1],3'b101}];\n   assign btb_rd1_valid[0] = btb_rden_f1 & btb_valid[{btb_rw_addr_f1[1][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1],3'b100}];\n\n   rvdff #(3) btb_rwdv_ff (.*, .clk(active_clk),\n                           .din  ({btb_rden, btb_wren, btb_sram_wr_data[0]}),\n                           .dout ({btb_rden_f1, btb_wren_f1, btb_sram_wr_datav_f1}));\n   // ----------------------------------------------------------------------\n   // SRAMS\n   // ----------------------------------------------------------------------\n\n   logic [1:0][1:0][pt.BTB_NUM_BYPASS_WIDTH-1:0]  wrptr_in, wrptr;\n\n   logic [1:0][1:0] btb_b_read_en, btb_b_write_en, btb_bank_way_clken_final;\n\n   logic [1:0][1:0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1] btb_b_rw_addr;\n\n   logic [1:0][1:0]                                   any_addr_match, any_bypass;\n\n   logic [1:0][1:0][pt.BTB_NUM_BYPASS-1:0]           btb_b_addr_match, btb_b_clear_en, sel_bypass, write_bypass_en;\n   logic [1:0][1:0][pt.BTB_NUM_BYPASS-1:0]           write_bypass_en_ff, index_valid, sel_bypass_ff;\n\n   logic [1:0][1:0][pt.BTB_NUM_BYPASS-1:0][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1] wb_index_hold;\n\n   logic [1:0][1:0][pt.BTB_NUM_BYPASS-1:0][2*BTB_DWIDTH-1:0] wb_dout_hold;\n\n   logic [1:0][1:0][2*BTB_DWIDTH-1:0]                sel_bypass_data;\n\n\n`define EH2_BTB_SRAM(depth,width,bank,way)                                                                                          \\\n           ram_be_``depth``x``width btb_bank``bank``_``way (                                                                         \\\n                            // Primary ports                                                                                         \\\n                            .CLK     (clk),                                                                                          \\\n                            .ME      (btb_bank_way_clken_final[i][j]),                                                               \\\n                            .WE      (wren_bank[i]),                                                                                 \\\n                            .WEM     (btb_bit_en_vec[(j+1)*2*BTB_D"}
{"text": "WIDTH-1:j*2*BTB_DWIDTH]),                                          \\\n                            .ADR     (btb_rw_addr[i][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1]), // This is 9:4 (bit 3 used as bank bit)      \\\n                            .D       ({2{btb_sram_wr_data[pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]}}),                            \\\n                            .Q       (btb_rd_data_raw[i][j]),                                                                        \\\n                            .ROP (),                                                                                                 \\\n                            // These are used by SoC                                                                                 \\\n                            .TEST1   (btb_ext_in_pkt[i].TEST1),                                                                      \\\n                            .RME     (btb_ext_in_pkt[i].RME),                                                                        \\\n                            .RM      (btb_ext_in_pkt[i].RM),                                                                         \\\n                            .LS      (btb_ext_in_pkt[i].LS),                                                                         \\\n                            .DS      (btb_ext_in_pkt[i].DS),                                                                         \\\n                            .SD      (btb_ext_in_pkt[i].SD) ,                                                                        \\\n                            .TEST_RNM(btb_ext_in_pkt[i].TEST_RNM),                                                                   \\\n                            .BC1     (btb_ext_in_pkt[i].BC1),                                                                        \\\n                            .BC2     (btb_ext_in_pkt[i].BC2)                                                                         \\\n                            );                                                                                                       \\\n                                                                                                                                     \\\nif (pt.BTB_BYPASS_ENABLE == 1) begin                                                                                      \\\n                 assign wrptr_in[i][j] = (wrptr[i][j] == (pt.BTB_NUM_BYPASS-1)) ? '0 : (wrptr[i][j] + 1'd1);              \\\n                 rvdffs  #(pt.BTB_NUM_BYPASS_WIDTH)  wrptr_ff(.*, .clk(active_clk),  .en(|write_bypass_en[i][j]), .din (wrptr_in[i][j]), .dout(wrptr[i][j])) ;     \\\n                                                                                                                          \\\n                 assign btb_b_read_en[i][j]              =  ~wren_bank[i];                              \\\n                 assign btb_b_write_en[i][j]             =  wren_bank[i];                              \\\n                 assign btb_bank_way_clken_final[i][j]   =  ~(|sel_bypass[i][j]);                         \\\n                 assign btb_b_rw_addr[i][j]              =  btb_rw_addr[i][pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1];              \\\n                 always_comb begin                                                                                        \\\n                    any_addr_match[i][j] = '0;                                                                            \\\n                    for (int l=0; l<pt.BTB_NUM_BYPASS; l++) begin                                                         \\\n                       any_addr_match[i][j] |= btb_b_addr_match[i][j][l];                                                 \\\n                    end                                                                                                   \\\n                 end                                                                                                      \\\n                // it is an error to ever have 2 entries with the same index and both valid                               \\\n                for (genvar l=0; l<pt.BTB_NUM_BYPASS; l++) begin: BYPASS                                                  \\\n                   // full match up to bit 31                                                                             \\\n                   assign btb_b_addr_match[i][j][l] = (wb_index_hold[i][j][l] ==  btb_b_rw_addr[i][j]) & index_valid[i][j][l];            \\\n                   assign btb_b_clear_en[i][j][l]   = btb_b_write_en[i][j] &   btb_b_addr_match[i][j][l];                                 \\\n                   assign sel_bypass[i][j][l]       = btb_b_read_en[i][j]  &   btb_b_addr_match[i][j][l] ;                                \\\n                                                                                                                                          \\\n                   assign write_bypass_en[i][j][l]  = btb_b_read_en[i][j]  &  ~any_addr_match[i][j] & (wrptr[i][j] == l);                 \\\n                                                                                                                                          \\\n                   rvdff  #(1)  write_bypass_ff (.*, .clk(active_clk), .din(write_bypass_en[i][j][l]), .dout(write_bypass_en_ff[i][j][l])) ;        \\\n                   rvdffs #(1)  index_val_ff    (.*, .clk(active_clk), .en(write_bypass_en[i][j][l] | btb_b_clear_en[i][j][l]),                     \\\n                                                                       .din(~btb_b_clear_en[i][j][l]), .dout(index_valid[i][j][l])) ;               \\\n                   rvdff  #(1)  sel_hold_ff     (.*, .clk(active_clk), .din(sel_bypass[i][j][l]),      .dout(sel_bypass_ff[i][j][l])) ;             \\\n                   rvdffe #(.WIDTH(pt.BTB_ADDR_HI-pt.BTB_ADDR_LO), .OVERRIDE(1)) btb_addr_index    (.*, .en(write_bypass_en[i][j][l]),                                    \\\n                                                                       .din (btb_b_rw_addr[i][j]),     .dout(wb_index_hold[i][j][l]));              \\\n                   rvdffe #(2*BTB_DWIDTH) rd_data_hold_ff  (.*,        .en(write_bypass_en_ff[i][j][l]),                                            \\\n                                                                       .din (btb_rd_data_raw[i][j]),  .dout(wb_dout_hold[i][j][l]));           \\\n                end                                                                                                                       \\\n                always_comb begin                                                                                                         \\\n                 any_bypass[i][j] = '0;                                                                                                   \\\n                 sel_bypass_data[i][j] = '0;                                                                                              \\\n                 for (int l=0; l<pt.BTB_NUM_BYPASS; l++) begin                                                                            \\\n                    any_bypass[i][j]      |=  sel_bypass_ff[i][j][l];                                                                     \\\n                    sel_bypass_data[i][j] |= (sel_bypass_ff[i][j][l]) ? wb_dout_hold[i][j][l] : '0;                                       \\\n                 end                                                                                                                      \\\n                 btb_rd_data[i][j]  = any_bypass[i][j] ?  sel_bypass_data[i][j] : btb_rd_data_raw[i][j]  ;                                \\\n                 end                                                                                                                      \\\n             end                                                                                                                          \\\n             else begin                                                                                                                   \\\n                 assign btb_rd_data[i][j]  =   btb_rd_data_raw[i][j];                                                                     \\\n                 assign btb_bank_way_clken_final[i][j]   =  1'b1;                                                                         \\\n             end\n\n\n\n   for (genvar i=0; i<2; i++) begin: BANKS\n         for (genvar j=0; j<2; j++) begin: WAYS\n            if      (pt.BTB_SIZE==4096) begin\n              `EH2_BTB_SRAM(512,60,i,j)\n            end\n            else if (pt.BTB_SIZE==2048) begin\n              `EH2_BTB_SRAM(256,60,i,j)\n            end\n            else if (pt.BTB_SIZE==1024) begin\n              `EH2_BTB_SRAM(128,60,i,j)\n            end\n            else if (pt.BTB_SIZE==512) begin\n              `EH2_BTB_SRAM(64,60,i,j)\n            end\n            else if (pt.BTB_SIZE==256) begin\n              `EH2_BTB_SRAM(32,62,i,j)\n            end\n         end\n   end\n\n`undef TAG\nendmodule // eh2_ifu_btb_mem\n\n\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n// purpose of this file is to convert 16b RISCV compressed instruction into 32b equivalent\n\nmodule eh2_ifu_compress_ctl\nimport eh2_pkg::*;\n  (\n   input  logic [15:0] din,\n   output logic [31:0] dout\n   );\n\n\n   logic        legal;\n\n   logic [15:0]  i;\n\n   logic [31:0]  o,l1,l2,l3;\n\n\n   assign i[15:0] = din[15:0];\n\n\n   logic [4:0]   rs2d,rdd,rdpd,rs2pd;\n\nlogic rdrd;\nlogic rdrs1;\nlogic rs2rs2;\nlogic rdprd;\nlogic rdprs1;\nlogic rs2prs2;\nlogic rs2prd;\nlogic uimm9_2;\nlogic ulwimm6_2;\nlogic ulwspimm7_2;\nlogic rdeq2;\nlogic rdeq1;\nlogic rs1eq2;\nlogic sbroffset8_1;\nlogic simm9_4;\nlogic simm5_0;\nlogic sjaloffset11_1;\nlogic sluimm17_12;\nlogic uimm5_0;\nlogic uswimm6_2;\nlogic uswspimm7_2;\n\n\n\n   // form the opcodes\n\n   // formats\n   //\n   // c.add rd 11:7 rs2  6:2\n   // c.and rdp 9:7 rs2p 4:2\n   //\n   // add rs2 24:20 rs1 19:15  rd 11:7\n\n   assign rs2d[4:0] = i[6:2];\n\n   assign rdd[4:0] = i[11:7];\n\n   assign rdpd[4:0] = {2'b01, i[9:7]};\n\n   assign rs2pd[4:0] = {2'b01, i[4:2]};\n\n\n\n   // merge in rd, rs1, rs2\n\n\n   // rd\n   assign l1[6:0] = o[6:0];\n\n   assign l1[11:7] = o[11:7] |\n                     ({5{rdrd}} & rdd[4:0]) |\n                     ({5{rdprd}} & rdpd[4:0]) |\n                     ({5{rs2prd}} & rs2pd[4:0]) |\n                     ({5{rdeq1}} & 5'd1) |\n                     ({5{rdeq2}} & 5'd2);\n\n\n   // rs1\n   assign l1[14:12] = o[14:12];\n   assign l1[19:15] = o[19:15] |\n                      ({5{rdrs1}} & rdd[4:0]) |\n                      ({5{rdprs1}} & rdpd[4:0]) |\n                      ({5{rs1eq2}} & 5'd2);\n\n\n   // rs2\n   assign l1[24:20] = o[24:20] |\n                      ({5{rs2rs2}} & rs2d[4:0]) |\n                      ({5{rs2prs2}} & rs2pd[4:0]);\n\n   assign l1[31:25] = o[31:25];\n\n   logic [5:0] simm5d;\n   logic [9:2] uimm9d;\n\n   logic [9:4] simm9d;\n   logic [6:2] ulwimm6d;\n   logic [7:2] ulwspimm7d;\n   logic [5:0] uimm5d;\n   logic [20:1] sjald;\n\n   logic [31:12] sluimmd;\n\n   // merge in immediates + jal offset\n\n   assign simm5d[5:0] = { i[12], i[6:2] };\n\n   assign uimm9d[9:2] = { i[10:7], i[12:11], i[5], i[6] };\n\n   assign simm9d[9:4] = { i[12], i[4:3], i[5], i[2], i[6] };\n\n   assign ulwimm6d[6:2] = { i[5], i[12:10], i[6] };\n\n   assign ulwspimm7d[7:2] = { i[3:2], i[12], i[6:4] };\n\n   assign uimm5d[5:0] = { i[12], i[6:2] };\n\n   assign sjald[11:1] = { i[12], i[8], i[10:9], i[6], i[7], i[2], i[11], i[5:4], i[3] };\n\n   assign sjald[20:12] =  {9{i[12]}};\n\n\n\n   assign sluimmd[31:12] = { {15{i[12]}}, i[6:2] };\n\n\n   assign l2[31:20] = ( l1[31:20] ) |\n                      ( {12{simm5_0}}   &  {{7{simm5d[5]}},simm5d[4:0]} ) |\n                      ( {12{uimm9_2}}   &  {2'b0,uimm9d[9:2],2'b0} ) |\n                      ( {12{simm9_4}}   &   {{3{simm9d[9]}},simm9d[8:4],4'b0} ) |\n                      ( {12{ulwimm6_2}} &   {5'b0,ulwimm6d[6:2],2'b0} ) |\n                      ( {12{ulwspimm7_2}}  & {4'b0,ulwspimm7d[7:2],2'b0} ) |\n                      ( {12{uimm5_0}}      &    {6'b0,uimm5d[5:0]} ) |\n                      ( {12{sjaloffset11_1}} &  {sjald[20],sjald[10:1],sjald[11]} ) |\n                      ( {12{sluimm17_12}}    &  sluimmd[31:20] );\n\n\n\n   assign l2[19:12] = ( l1[19:12] ) |\n                      ( {8{sjaloffset11_1}} & sjald[19:12] ) |\n                      ( {8{sluimm17_12}} & sluimmd[19:12] );\n\n\n   assign l2[11:0] = l1[11:0];\n\n\n   // merge in branch offset and store immediates\n\n   logic [8:1]   sbr8d;\n   logic [6:2]   uswimm6d;\n   logic [7:2]   uswspimm7d;\n\n\n   assign sbr8d[8:1] =   { i[12], i[6], i[5], i[2], i[11], i[10], i[4], i[3] };\n\n   assign uswimm6d[6:2] = { i[5], i[12:10], i[6] };\n\n   assign uswspimm7d[7:2] = { i[8:7], i[12:9] };\n\n   assign l3[31:25] = ( l2[31:25] ) |\n                      ( {7{sbroffset8_1}} & { {4{sbr8d[8]}},sbr8d[7:5] } ) |\n                      ( {7{uswimm6_2}}    & { 5'b0, uswimm6d[6:5] } ) |\n                      ( {7{uswspimm7_2}} & { 4'b0, uswspimm7d[7:5] } );\n\n\n   assign l3[24:12] = l2[24:12];\n\n   assign l3[11:7] = ( l2[11:7] ) |\n                     ( {5{sbroffset8_1}} & { sbr8d[4:1], sbr8d[8] } ) |\n                     ( {5{uswimm6_2}} & { uswimm6d[4:2], 2'b0 } ) |\n                     ( {5{uswspimm7_2}} & { uswspimm7d[4:2], 2'b0 } );\n\n   assign l3[6:0] = l2[6:0];\n\n\n   assign dout[31:0] = l3[31:0] & {32{legal}};\n\n\n// file \"cdecode\" is human readable file that has all of the compressed instruction decodes defined and is part of git repo\n// modify this file as needed\n\n// to generate all the equations below from \"cdecode\" except legal equation:\n\n// 1) coredecode -in cdecode > cdecode.e\n\n// 2) espresso -Dso -oeqntott cdecode.e | addassign > compress_equations\n\n// to generate the legal (16b compressed instruction is legal)  equation below:\n\n// 1) coredecode -in cdecode -legal > clegal.e\n\n// 2) espresso -Dso -oeqntott clegal.e | addassign > clegal_equation\n\n\n\n\n\n// espresso decodes\nassign rdrd = (!i[14]&i[6]&i[1]) | (!i[15]&i[14]&i[11]&i[0]) | (!i[14]&i[5]&i[1]) | (\n    !i[15]&i[14]&i[10]&i[0]) | (!i[14]&i[4]&i[1]) | (!i[15]&i[14]&i[9]\n    &i[0]) | (!i[14]&i[3]&i[1]) | (!i[15]&i[14]&!i[8]&i[0]) | (!i[14]\n    &i[2]&i[1]) | (!i[15]&i[14]&i[7]&i[0]) | (!i[15]&i[1]) | (!i[15]\n    &!i[13]&i[0]);\n\nassign rdrs1 = (!i[14]&i[12]&i[11]&i[1]) | (!i[14]&i[12]&i[10]&i[1]) | (!i[14]\n    &i[12]&i[9]&i[1]) | (!i[14]&i[12]&i[8]&i[1]) | (!i[14]&i[12]&i[7]\n    &i[1]) | (!i[14]&!i[12]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]\n    &i[12]&i[6]&i[1]) | (!i[14]&i[12]&i[5]&i[1]) | (!i[14]&i[12]&i[4]\n    &i[1]) | (!i[14]&i[12]&i[3]&i[1]) | (!i[14]&i[12]&i[2]&i[1]) | (\n    !i[15]&!i[14]&!i[13]&i[0]) | (!i[15]&!i[14]&i[1]);\n\nassign rs2rs2 = (i[15]&i[6]&i[1]) | (i[15]&i[5]&i[1]) | (i[15]&i[4]&i[1]) | (\n    i[15]&i[3]&i[1]) | (i[15]&i[2]&i[1]) | (i[15]&i[14]&i[1]);\n\nassign rdprd = (i[15]&!i[14]&!i[13]&i[0]);\n\nassign rdprs1 = (i[15]&!i[13]&i[0]) | (i[15]&i[14]&i[0]) | (i[14]&!i[1]&!i[0]);\n\nassign rs2prs2 = (i[15]&!i[14]&!i[13]&i[11]&i[10]&i[0]) | (i[15]&!i[1]&!i[0]);\n\nassign rs2prd = (!i[15]&!i[1]&!i[0]);\n\nassign uimm9_2 = (!i[14]&!i[1]&!i[0]);\n\nassign ulwimm6_2 = (!i[15]&i[14]&!i[1]&!i[0]);\n\nassign ulwspimm7_2 = (!i[15]&i[14]&i[1]);\n\nassign rdeq2 = (!i[15]&i[14]&i[13]&!i[11]&!i[10]&!i[9]&i[8]&!i[7]);\n\nassign rdeq1 = (!i[14]&i[12]&i[11]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]\n    &i[12]&i[10]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[9]\n    &!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[8]&!i[6]&!i[5]\n    &!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[7]&!i[6]&!i[5]&!i[4]&!i[3]\n    &!i[2]&i[1]) | (!i[15]&!i[14]&i[13]);\n\nassign rs1eq2 = (!i[15]&i[14]&i[13]&!i[11]&!i[10]&!i[9]&i[8]&!i[7]) | (i[14]\n    &i[1]) | (!i[14]&!i[1]&!i[0]);\n\nassign sbroffset8_1 = (i[15]&i[14]&i[0]);\n\nassign simm9_4 = (!i[15]&i[14]&i[13]&!i[11]&!i[10]&!i[9]&i[8]&!i[7]);\n\nassign simm5_0 = (!i[14]&!i[13]&i[11]&!i[10]&i[0]) | (!i[15]&!i[13]&i[0]);\n\nassign sjaloffset11_1 = (!i[14]&i[13]);\n\nassign sluimm17_12 = (!i[15]&i[14]&i[13]&i[7]) | (!i[15]&i[14]&i[13]&!i[8]) | (\n    !i[15]&i[14]&i[13]&i[9]) | (!i[15]&i[14]&i[13]&i[10]) | (!i[15]&i[14]\n    &i[13]&i[11]);\n\nassign uimm5_0 = (i[15]&!i[14]&!i[13]&!i[11]&i[0]) | (!i[15]&!i[14]&i[1]);\n\nassign uswimm6_2 = (i[15]&!i[1]&!i[0]);\n\nassign uswspimm7_2 = (i[15]&i[14]&i[1]);\n\nassign o[31]  = 1'b0;\n\nassign o[30] = (i[15]&!i[14]&!i[13]&i[10]&!i[6]&!i[5]&i[0]) | (i[15]&!i[14]\n    &!i[13]&!i[11]&i[10]&i[0]);\n\nassign o[29]  = 1'b0;\n\nassign o[28]  = 1'b0;\n\nassign o[27]  = 1'b0;\n\nassign o[26]  = 1'b0;\n\nassign o[25]  = 1'b0;\n\nassign o[24]  = 1'b0;\n\nassign o[23]  = 1'b0;\n\nassign o[22]  = 1'b0;\n\nassign o[21]  = 1'b0;\n\nassign o[20] = (!i[14]&i[12]&!i[11]&!i[10]&!i[9]&!i[8]&!i[7]&!i[6]&!i[5]&!i[4]\n    &!i[3]&!i[2]&i[1]);\n\nassign o[19]  = 1'b0;\n\nassign o[18]  = 1'b0;\n\nassign o[17]  = 1'b0;\n\nassign o[16]  = 1'b0;\n\nassign o[15]  = 1'b0;\n\nassign o[14] = (i[15]&!i[14]&!i[13]&!i[11]&i[0]) | (i[15]&!i[14]&!i[13]&!i[10]\n    &i[0]) | (i[15]&!i[14]&!i[13]&i[6]&i[0]) | (i[15]&!i[14]&!i[13]&i[5]\n    &i[0]);\n\nassign o[13] = (i[15]&!i[14]&!i[13]&i[11]&!i[10]&i[0]) | (i[15]&!i[14]&!i[13]\n    &i[11]&i[6]&i[0]) | (i[14]&!i[0]);\n\nassign o[12] = (i[15]&!i[14]&!i[13]&i[6]&i[5]&i[0]) | (i[15]&!i[14]&!i[13]&!i[11]\n    &i[0]) | (i[15]&!i[14]&!i[13]&!i[10]&i[0]) | (!i[15]&!i[14]&i[1]) | (\n    i[15]&i[14]&i[13]);\n\nassign o[11]  = 1'b0;\n\nassign o[10]  = 1'b0;\n\nassign o[9]  = 1'b0;\n\nassign o[8]  = 1'b0;\n\nassign o[7]  = 1'b0;\n\nassign o[6] = (i[15]&!i[14]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&!i[0]) | (!i[14]&i[13]) | (\n    i[15]&i[14]&i[0]);\n\nassign o[5] = (i[15]&!i[0]) | (i[15]&i[11]&i[10]) | (i[13]&!i[8]) | (i[13]&i[7]) | (\n    i[13]&i[9]) | (i[13]&i[10]) | (i[13]&i[11]) | (!i[14]&i[13]) | (\n    i[15]&i[14]);\n\nassign o[4] = (!i[14]&!i[11]&!i[10]&!i[9]&!i[8]&!i[7]&!i[0]) | (!i[15]&!i[14]\n    &!i[0]) | (!i[14]&i[6]&!i[0]) | (!i[15]&i[14]&i[0]) | (!i[14]&i[5]\n    &!i[0]) | (!i[14]&i[4]&!i[0]) | (!i[14]&!i[13]&i[0]) | (!i[14]&i[3]\n    &!i[0]) | (!i[14]&i[2]&!i[0]);\n\nassign o[3] = (!i[14]&i[13]);\n\nassign o[2] = (!i[14]&i[12]&i[11]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]\n    &i[12]&i[10]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[9]\n    &!i[6]&!i[5]&!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[8]&!i[6]&!i[5]\n    &!i[4]&!i[3]&!i[2]&i[1]) | (!i[14]&i[12]&i[7]&!i[6]&!i[5]&!i[4]&!i[3]\n    &!i[2]&i[1]) | (i[15]&!i[14]&!i[12]&!i[6]&!i[5]&!i[4]&!i[3]&!i[2]\n    &!i[0]) | (!i[15]&i[13]&!i[8]) | (!i[15]&i[13]&i[7]) | (!i[15]&i[13]\n    &i[9]) | (!i[15]&i[13]&i[10]) | (!i[15]&i[13]&i[11]) | (!i[14]&i[13]);\n\n// 32b instruction has lower two bits 2'b11\n\nassign o[1]  = 1'b1;\n\nassign o[0]  = 1'b1;\n\nassign legal = (!i[13]&!i[12]&i[11]&i[1]&!i[0]) | (!i[13]&!i[12]&i[6]&i[1]&!i[0]) | (\n    !i[15]&!i[13]&i[11]&!i[1]) | (!i[13]&!i[12]&i[5]&i[1]&!i[0]) | (\n    !i[13]&!i[12]&i[10]&i[1]&!i[0]) | (!i[15]&!i[13]&i[6]&!i[1]) | (\n    i[15]&!i[12]&!i[1]&i[0]) | (!i[13]&!i[12]&i[9]&i[1]&!i[0]) | (!i[12]\n    &i[6]&!i[1]&i[0]) | (!i[15]&!i[13]&i[5]&!i[1]) | (!i[13]&!i[12]&i[8]\n    &i[1]&!i[0]) | (!i[12]&i[5]&!i[1]&i[0]) | (!i[15]&!i[13]&i[10]&!i[1]) | (\n    !i[13]&!i[12]&i[7]&i[1]&!i[0]) | (i[12]&i[11]&!i[10]&!i[1]&i[0]) | (\n    !i[15]&!i[13]&i[9]&!i[1]) | (!i[13]&!i[12]&i[4]&i[1]&!i[0]) | (i[13]\n    &i[12]&!i[1]&i[0]) | (!i[15]&!i[13]&i[8]&!i[1]) | (!i[13]&!i[12]&i[3]\n    &i[1]&!i[0]) | (i[13]&i[4]&!i[1]&i[0]) | (!i[13]&!i[12]&i[2]&i[1]\n    &!i[0]) | (!i[15]&!i[13]&i[7]&!i[1]) | (i[13]&i[3]&!i[1]&i[0]) | (\n    i[13]&i[2]&!i[1]&i[0]) | (i[14]&!i[13]&!i[1]) | (!i[14]&!i[12]&!i[1]\n    &i[0]) | (i[15]&!i[13]&i[12]&i[1]&!i[0]) | (!i[15]&!i[13]&!i[12]&i[1]\n    &!i[0]) | (!i[15]&!i[13]&i[12]&!i[1]) | (i[14]&!i[13]&!i[0]);\n\n\n\n\nendmodule\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n//********************************************************************************\n// Icache closely coupled memory --- ICCM\n//********************************************************************************\nmodule eh2_ifu_iccm_mem\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n )(\n   input logic                                        clk,\n   input logic                                        active_clk,\n   input logic                                        rst_l,\n   input logic                                        clk_override,\n\n   input logic                                        ifc_select_tid_f1,\n   input logic                                        iccm_wren,\n   input logic                                        iccm_rden,\n   input logic [pt.ICCM_BITS-1:1]                     iccm_rw_addr,\n   input logic [pt.NUM_THREADS-1:0]                   iccm_buf_correct_ecc_thr,            // ICCM is doing a single bit error correct cycle\n   input logic                                        iccm_correction_state,               // We are under a correction - This is needed to guard replacements when hit\n   input logic                                        iccm_stop_fetch,                     // We have fetched more than needed for 4 bytes. Need to squash any further hits for plru updates\n   input logic                                        iccm_corr_scnd_fetch,                // dont match on middle bank when under correction\n\n   input logic [2:0]                                  iccm_wr_size,\n   input logic [77:0]                                 iccm_wr_data,\n\n\n   input  eh2_ccm_ext_in_pkt_t   [pt.ICCM_NUM_BANKS-1:0] iccm_ext_in_pkt,\n\n   output logic [63:0]                                iccm_rd_data,\n   output logic [116:0]                               iccm_rd_data_ecc,\n   input  logic                                       scan_mode\n\n);\n   logic [pt.ICCM_NUM_BANKS-1:0]                                        wren_bank;\n   logic [pt.ICCM_NUM_BANKS-1:0]                                        rden_bank;\n   logic [pt.ICCM_NUM_BANKS-1:0]                                        iccm_clken;\n   logic [pt.ICCM_NUM_BANKS-1:0] [pt.ICCM_BITS-1:pt.ICCM_BANK_INDEX_LO] addr_bank;\n\n   logic [pt.ICCM_NUM_BANKS-1:0] [38:0] iccm_bank_dout, iccm_bank_dout_fn;\n   logic [pt.ICCM_NUM_BANKS-1:0] [38:0] iccm_bank_wr_data;\n   logic [pt.ICCM_BITS-1:1]             addr_hi_bank;\n   logic [pt.ICCM_BITS-1:1]             addr_md_bank;\n   logic [pt.ICCM_BANK_HI : 2]          iccm_rd_addr_hi_q;\n   logic [pt.ICCM_BANK_HI : 2]          iccm_rd_addr_md_q;\n   logic [pt.ICCM_BANK_HI : 1]          iccm_rd_addr_lo_q;\n   logic             [95:0]             iccm_rd_data_pre;\n   logic             [63:0]             iccm_data;\n   logic [pt.ICCM_NUM_BANKS-1:0] [38:0] iccm_bank_wr_data_vec;\n\n\n   // logic to handle hard persisten faults\n   logic [pt.NUM_THREADS-1:0][1:0] [pt.ICCM_BITS-1:2]        redundant_address;\n   logic [pt.NUM_THREADS-1:0][1:0] [38:0]                    redundant_data;\n   logic [pt.NUM_THREADS-1:0][1:0]                           redundant_valid;\n   logic [pt.NUM_THREADS-1:0][pt.ICCM_NUM_BANKS-1:0]         sel_red1, sel_red0, sel_red1_q, sel_red0_q;\n   logic [pt.NUM_THREADS-1:0][pt.ICCM_NUM_BANKS-1:0]         sel_red1_lru, sel_red0_lru;\n\n   logic [pt.NUM_THREADS-1:0][38:0]                          redundant_data0_in, redundant_data1_in;\n   logic [pt.NUM_THREADS-1:0]                                redundant_lru, redundant_lru_in, redundant_lru_en;\n   logic [pt.NUM_THREADS-1:0]                                redundant_data0_en;\n   logic [pt.NUM_THREADS-1:0]                                redundant_data1_en;\n   logic [pt.NUM_THREADS-1:0]                                r0_addr_en, r1_addr_en;\n\n   assign addr_hi_bank[pt.ICCM_BITS-1 :1] = iccm_rw_addr[pt.ICCM_BITS-1 : 1] + 2'b11;\n   assign addr_md_bank[pt.ICCM_BITS-1: 1] = iccm_rw_addr[pt.ICCM_BITS-1 : 1] + 2'b10;\n\n   for (genvar i=0; i<pt.ICCM_NUM_BANKS/2; i++) begin: mem_bank_data\n      assign iccm_bank_wr_data_vec[(2*i)]   = iccm_wr_data[38:0];\n      assign iccm_bank_wr_data_vec[(2*i)+1] = iccm_wr_data[77:39];\n   end\n\n   for (genvar i=0; i<pt.ICCM_NUM_BANKS; i++) begin: mem_bank\n      assign wren_bank[i]         = iccm_wren & ((iccm_rw_addr[pt.ICCM_BANK_HI:2] == i) | ((addr_hi_bank[pt.ICCM_BANK_HI:2] == i) & (iccm_wr_size[1:0] == 2'b11)));\n      assign iccm_bank_wr_data[i] = iccm_bank_wr_data_vec[i];\n      assign rden_bank[i]         = iccm_rden & ((iccm_rw_addr[pt.ICCM_BANK_HI:2] == i) | (iccm_rw_addr[pt.ICCM_BANK_HI:2] == 2'(i-1)) | (addr_hi_bank[pt.ICCM_BANK_HI:2] == i) | (addr_md_bank[pt.ICCM_BANK_HI:2] == i));\n      assign iccm_clken[i]        =  wren_bank[i] | rden_bank[i] | clk_override;\n      assign addr_bank[i][pt.ICCM_BITS-1 : pt.ICCM_BANK_INDEX_LO] = wren_bank[i] ? iccm_rw_addr[pt.ICCM_BITS-1 : pt.ICCM_BANK_INDEX_LO] :\n                                                                                      ((addr_hi_bank[pt.ICCM_BANK_HI:2] == i) ?\n                                                                                                    addr_hi_bank[pt.ICCM_BITS-1 : pt.ICCM_BANK_INDEX_LO] :\n                                                                                                    (addr_md_bank[pt.ICCM_BANK_HI:2] == i) ? addr_md_bank[pt.ICCM_BITS-1 : pt.ICCM_BANK_INDEX_LO] :\n                                                                                                                                             iccm_rw_addr[pt.ICCM_BITS-1 : pt.ICCM_BANK_INDEX_LO]);\n\n\n `ifdef VERILATOR\n\n    eh2_ram #(.depth(1<<pt.ICCM_INDEX_BITS), .width(39)) iccm_bank (\n                                     // Primary ports\n                                     .ME(iccm_clken[i]),\n                                     .CLK(clk),\n                                     .WE(wren_bank[i]),\n                                     .ADR(addr_bank[i]),\n                                     .D(iccm_bank_wr_data[i][38:0]),\n                                     .Q(iccm_bank_dout[i][38:0]),\n                                     .ROP ( ),\n                                     // These are used by SoC\n                                     .TEST1(iccm_ext_in_pkt[i].TEST1),\n                                     .RME(iccm_ext_in_pkt[i].RME),\n                                     .RM(iccm_ext_in_pkt[i].RM),\n                                     .LS(iccm_ext_in_pkt[i].LS),\n                                     .DS(iccm_ext_in_pkt[i].DS),\n                                     .SD(iccm_ext_in_pkt[i].SD) ,\n                                     .TEST_RNM(iccm_ext_in_pkt[i].TEST_RNM),\n                                     .BC1(iccm_ext_in_pkt[i].BC1),\n                                     .BC2(iccm_ext_in_pkt[i].BC2)\n\n                                      );\n `else\n     if (pt.ICCM_INDEX_BITS == 6 ) begin : iccm\n               ram_64x39 iccm_bank (\n                                     // Primary ports\n                                     .ME(iccm_clken[i]),\n                                     .CLK(clk),\n                                     .WE(wren_bank[i]),\n                                     .ADR(addr_bank[i]),\n                                     .D(iccm_bank_wr_data[i][38:0]),\n                                     .Q(iccm_bank_dout[i][38:0]),\n                                     .ROP ( ),\n                                     // These are used by SoC\n                                     .TEST1(iccm_ext_in_pkt[i].TEST1),\n                                     .RME(iccm_ext_in_pkt[i].RME),\n                                     .RM(iccm_ext_in_pkt[i].RM),\n                                     .LS(iccm_ext_in_pkt[i].LS),\n                                     .DS(iccm_ext_in_pkt[i].DS),\n                                     .SD(iccm_ext_in_pkt[i].SD) ,\n                                     .TEST_RNM(iccm_ext_in_pkt[i].TEST_RNM),\n                                     .BC1(iccm_ext_in_pkt[i].BC1),\n                                     .BC2(iccm_ext_in_pkt[i].BC2)\n\n                                      );\n     end // block: iccm\n\n   else if (pt.ICCM_INDEX_BITS == 7 ) begin : iccm\n               ram_128x39 iccm_bank (\n                                     // Primary ports\n                                     .ME(iccm_clken[i]),\n                                     .CLK(clk),\n                                     .WE(wren_bank[i]),\n                                     .ADR(addr_bank[i]),\n                                     .D(iccm_bank_wr_data[i][38:0]),\n                                     .Q(iccm_bank_dout[i][38:0]),\n                                     .ROP ( ),\n                                     // These are used by SoC\n                                     .TEST1(iccm_ext_in_pkt[i].TEST1),\n                                     .RME(iccm_ext_in_pkt[i].RME),\n                                     .RM(iccm_ext_in_pkt[i].RM),\n                                     .LS(iccm_ext_in_pkt[i].LS),\n                                     .DS(iccm_ext_in_pkt[i].DS),\n                                     .SD(iccm_ext_in_pkt[i].SD) ,\n                                     .TEST_RNM(iccm_ext_in_pkt[i].TEST_RNM),\n                                     .BC1(iccm_ext_in_pkt[i].BC1),\n                                     .BC2(iccm_ext_in_pkt[i].BC2)\n\n                                      );\n     end // block: iccm\n\n     else if (pt.ICCM_INDEX_BITS == 8 ) begin : iccm\n               ram_256x39 iccm_bank (\n                                     // Primary ports\n                                     .ME(iccm_clken[i]),\n                                     .CLK(clk),\n                                     .WE(wren_bank[i]),\n                                     .ADR(addr_bank[i]),\n                                     .D(iccm_bank_wr_data[i][38:0]),\n                                     .Q(iccm_bank_dout[i][38:0]),\n                                     .ROP ( ),\n                                     // These are used by SoC\n                                     .TEST1(iccm_ext_in_pkt[i].TEST1),\n                                     .RME(iccm_ext_in_pkt[i].RME),\n                                     .RM(iccm_ext_in_pkt[i].RM),\n                                     .LS(iccm_ext_in_pkt[i].LS),\n                                     .DS(iccm_ext_in_pkt[i].DS),\n                                     .SD(iccm_ext_in_pkt[i].SD) ,\n                                     .TEST_RNM(iccm_ext_in_pkt[i].TEST_RNM),\n                                     .BC1(iccm_ext_in_pkt[i].BC1),\n                                     .BC2(iccm_ext_in_pkt[i].BC2)\n\n                                      );\n     end // block: iccm\n     else if (pt.ICCM_INDEX_BITS == 9 ) begin : iccm\n               ram_512x39 iccm_bank (\n                                     // Primary ports\n                                     .ME(iccm_clken[i]),\n                                     .CLK(clk),\n                                     .WE(wren_bank[i]),\n                                     .ADR(addr_bank[i]),\n                                     .D(iccm_bank_wr_data[i][38:0]),\n                                     .Q(iccm_bank_dout[i][38:0]),\n                                     .ROP ( ),\n                                     // These are used by SoC\n                                     .TEST1(iccm_ext_in_pkt[i].TEST1),\n                                     .RME(iccm_ext_in_pkt[i].RME),\n                                     .RM(iccm_ext_in_pkt[i].RM),\n                                     .LS(iccm_ext_in_pkt[i].LS),\n                                     .DS(iccm_ext_in_pkt[i].DS),\n                                     .SD(iccm_ext_in_pkt[i].SD) ,\n                                     .TEST_RNM(iccm_ext_in_pkt[i].TEST_RNM),\n                                     .BC1(iccm_ext_in_pkt[i].BC1),\n                                     .BC2(iccm_ext_in_pkt[i].BC2)\n\n                                      );\n     end // block: iccm\n     else if (pt.ICCM_INDEX_BITS == 10 ) begin : iccm\n               ram_1024x39 iccm_bank (\n                                     // Primary ports\n                                     .ME(iccm_clken[i]),\n                                     .CLK(clk),\n                                     .WE(wren_bank[i]),\n                                     .ADR(addr_bank[i]),\n                                     .D(iccm_bank_wr_data[i][38:0]),\n                                     .Q(iccm_bank_dout[i][38:0]),\n                                     .ROP ( ),\n                                     // These are used by SoC\n                                     .TEST1(iccm_ext_in_pkt[i].TEST1),\n                                     .RME(iccm_ext_in_pkt[i].RME),\n                                     .RM(iccm_ext_in_pkt[i].RM),\n                                     .LS(iccm_ext_in_pkt[i].LS),\n                                     .DS(iccm_ext_in_pkt[i].DS),\n                                     .SD(iccm_ext_in_pkt[i].SD) ,\n                                     .TEST_RNM(iccm_ext_in_pkt[i].TEST_RNM),\n                                     .BC1(iccm_ext_in_pkt[i].BC1),\n                                     .BC2(iccm_ext_in_pkt[i].BC2)\n\n                                      );\n     end // block: iccm\n     else if (pt.ICCM_INDEX_BITS == 11 ) begin : iccm\n               ram_2048x39 iccm_bank (\n                                     // Primary ports\n                                     .ME(iccm_clken[i]),\n                                     .CLK(clk),\n                                     .WE(wren_bank[i]),\n                                     .ADR(addr_bank[i]),\n                                     .D(iccm_bank_wr_data[i][38:0]),\n                                     .Q(iccm_bank_dout[i][38:0]),\n                                     .ROP ( ),\n                                     // These are used by SoC\n                                     .TEST1(iccm_ext_in_pkt[i].TEST1),\n                                     .RME(iccm_ext_in_pkt[i].RME),\n                                     .RM(iccm_ext_in_pkt[i].RM),\n                                     .LS(iccm_ext_in_pkt[i].LS),\n                                     .DS(iccm_ext_in_pkt[i].DS),\n                                     .SD(iccm_ext_in_pkt[i].SD) ,\n                                     .TEST_RNM(iccm_ext_in_pkt[i].TEST_RNM),\n                                     .BC1(iccm_ext_in_pkt[i].BC1),\n                                     .BC2(iccm_ext_in_pkt[i].BC2)\n\n                                      );\n     end // block: iccm\n     else if (pt.ICCM_INDEX_BITS == 12 ) begin : iccm\n               ram_4096x39 iccm_bank (\n                                     // Primary ports\n                                     .ME(iccm_clken[i]),\n                                     .CLK(clk),\n                                     .WE(wren_bank[i]),\n                                     .ADR(addr_bank[i]),\n                                     .D(iccm_bank_wr_data[i][38:0]),\n                                     .Q(iccm_bank_dout[i][38:0]),\n                                     .ROP ( ),\n                                     // These are used by SoC\n                                     .TEST1(iccm_ext_in_pkt[i].TEST1),\n                                     .RME(iccm_ext_in_pkt[i].RME),\n                                     .RM(iccm_ext_in_pkt[i].RM),\n                                     .LS(iccm_ext_in_pkt[i].LS),\n                                     .DS(iccm_ext_in_pkt[i].DS),\n                                     .SD(iccm_ext_in_pkt[i].SD) ,\n                                     .TEST_RNM(iccm_ext_in_pkt[i].TEST_RNM),\n                                     .BC1(iccm_ext_in_pkt[i].BC1),\n                                     .BC2(iccm_ext_in_pkt[i].BC2)\n\n                                      );\n     end // block: iccm\n     else if (pt.ICCM_INDEX_BITS == 13 ) begin : iccm\n               ram_8192x39 iccm_bank (\n                                     // Primary ports\n                                     .ME(iccm_clken[i]),\n                                     .CLK(clk),\n                                     .WE(wren_bank[i]),\n                                     .ADR(addr_bank[i]),\n                                     .D(iccm_bank_wr_data[i][38:0]),\n                                     .Q(iccm_bank_dout[i][38:0]),\n                                     .ROP ( ),\n                                     // These are used by SoC\n                                     .TEST1(iccm_ext_in_pkt[i].TEST1),\n                                     .RME(iccm_ext_in_pkt[i].RME),\n                                     .RM(iccm_ext_in_pkt[i].RM),\n                                     .LS(iccm_ext_in_pkt[i].LS),\n                                     .DS(iccm_ext_in_pkt[i].DS),\n                                     .SD(iccm_ext_in_pkt[i].SD) ,\n                                     .TEST_RNM(iccm_ext_in_pkt[i].TEST_RNM),\n                                     .BC1(iccm_ext_in_pkt[i].BC1),\n                                     .BC2(iccm_ext_in_pkt[i].BC2)\n\n                                      );\n     end // block: iccm\n     else if (pt.ICCM_INDEX_BITS == 14 ) begin : iccm\n               ram_16384x39 iccm_bank (\n                                     // Primary ports\n                                     .ME(iccm_clken[i]),\n                                     .CLK(clk),\n                                     .WE(wren_bank[i]),\n                                     .ADR(addr_bank[i]),\n                                     .D(iccm_bank_wr_data[i][38:0]),\n                                     .Q(iccm_bank_dout[i][38:0]),\n                                     .ROP ( ),\n                                     // These are used by SoC\n                                     .TEST1(iccm_ext_in_pkt[i].TEST1),\n                                     .RME(iccm_ext_in_pkt[i].RME),\n                                     .RM(iccm_ext_in_pkt[i].RM),\n                                     .LS(iccm_ext_in_pkt[i].LS),\n                                     .DS(iccm_ext_in_pkt[i].DS),\n                                     .SD(iccm_ext_in_pkt[i].SD) ,\n                                     .TEST_RNM(iccm_ext_in_pkt[i].TEST_RNM),\n                                     .BC1(iccm_ext_in_pkt[i].BC1),\n                                     .BC2(iccm_ext_in_pkt[i].BC2)\n\n                                      );\n     end // block: iccm\n     else begin : iccm\n               ram_32768x39 iccm_bank (\n                                     // Primary ports\n                                     .ME(iccm_clken[i]),\n                                     .CLK(clk),\n                                     .WE(wren_bank[i]),\n                                     .ADR(addr_bank[i]),\n                                     .D(iccm_bank_wr_data[i][38:0]),\n                                     .Q(iccm_bank_dout[i][38:0]),\n                                     .ROP ( ),\n                                     // These are used by SoC\n                                     .TEST1(iccm_ext_in_pkt[i].TEST1),\n                                     .RME(iccm_ext_in_pkt[i].RME),\n                                     .RM(iccm_ext_in_pkt[i].RM),\n                                     .LS(iccm_ext_in_pkt[i].LS),\n     "}
{"text": "                                .DS(iccm_ext_in_pkt[i].DS),\n                                     .SD(iccm_ext_in_pkt[i].SD) ,\n                                     .TEST_RNM(iccm_ext_in_pkt[i].TEST_RNM),\n                                     .BC1(iccm_ext_in_pkt[i].BC1),\n                                     .BC2(iccm_ext_in_pkt[i].BC2)\n\n                                      );\n     end // block: iccm\n `endif // VERILATOR\n  if (pt.NUM_THREADS > 1) begin: more_than_1\n        // T0\n        assign sel_red1[0][i]  = (redundant_valid[0][1] & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[0][1][pt.ICCM_BITS-1:2]) & (iccm_rw_addr[3:2] == i)) |\n                                                           ((addr_md_bank[pt.ICCM_BITS-1:2] == redundant_address[0][1][pt.ICCM_BITS-1:2]) & (addr_md_bank[3:2] == i))  |\n                                                           ((addr_hi_bank[pt.ICCM_BITS-1:2] == redundant_address[0][1][pt.ICCM_BITS-1:2]) & (addr_hi_bank[3:2] == i)))) & ~ifc_select_tid_f1;\n\n        assign sel_red0[0][i]  = (redundant_valid[0][0] & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[0][0][pt.ICCM_BITS-1:2]) & (iccm_rw_addr[3:2] == i)) |\n                                                           ((addr_md_bank[pt.ICCM_BITS-1:2] == redundant_address[0][0][pt.ICCM_BITS-1:2]) & (addr_md_bank[3:2] == i)) |\n                                                           ((addr_hi_bank[pt.ICCM_BITS-1:2] == redundant_address[0][0][pt.ICCM_BITS-1:2]) & (addr_hi_bank[3:2] == i)))) & ~ifc_select_tid_f1;\n\n        assign sel_red1_lru[0][i]  = (redundant_valid[0][1] & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[0][1][pt.ICCM_BITS-1:2])  & (iccm_rw_addr[3:2] == i)) |\n                                                               ((addr_md_bank[pt.ICCM_BITS-1:2] == redundant_address[0][1][pt.ICCM_BITS-1:2]) & (addr_md_bank[3:2] == i) & ~iccm_corr_scnd_fetch)  |\n                                                               ((addr_hi_bank[pt.ICCM_BITS-1:2] == redundant_address[0][1][pt.ICCM_BITS-1:2]) & (addr_hi_bank[3:2] == i) & ~iccm_correction_state))) & ~ifc_select_tid_f1;\n\n        assign sel_red0_lru[0][i]  = (redundant_valid[0][0] & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[0][0][pt.ICCM_BITS-1:2]) & (iccm_rw_addr[3:2] == i)) |\n                                                               ((addr_md_bank[pt.ICCM_BITS-1:2] == redundant_address[0][0][pt.ICCM_BITS-1:2]) & (addr_md_bank[3:2] == i) & ~iccm_corr_scnd_fetch) |\n                                                               ((addr_hi_bank[pt.ICCM_BITS-1:2] == redundant_address[0][0][pt.ICCM_BITS-1:2]) & (addr_hi_bank[3:2] == i) & ~iccm_correction_state))) & ~ifc_select_tid_f1;\n\n        // T1\n        assign sel_red1[pt.NUM_THREADS-1][i]  = (redundant_valid[pt.NUM_THREADS-1][1] & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2]) & (iccm_rw_addr[3:2] == i)) |\n                                                                                         ((addr_md_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2]) & (addr_md_bank[3:2] == i))  |\n                                                                                         ((addr_hi_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2]) & (addr_hi_bank[3:2] == i)))) &  ifc_select_tid_f1;\n\n        assign sel_red0[pt.NUM_THREADS-1][i]  = (redundant_valid[pt.NUM_THREADS-1][0] & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]) & (iccm_rw_addr[3:2] == i)) |\n                                                                                         ((addr_md_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]) & (addr_md_bank[3:2] == i)) |\n                                                                                         ((addr_hi_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]) & (addr_hi_bank[3:2] == i)))) &  ifc_select_tid_f1;\n\n        assign sel_red1_lru[pt.NUM_THREADS-1][i]  = (redundant_valid[pt.NUM_THREADS-1][1] & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2])  & (iccm_rw_addr[3:2] == i)) |\n                                                                                             ((addr_md_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2]) & (addr_md_bank[3:2] == i) & ~iccm_corr_scnd_fetch)  |\n                                                                                             ((addr_hi_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2]) & (addr_hi_bank[3:2] == i) & ~iccm_correction_state))) &  ifc_select_tid_f1;\n\n        assign sel_red0_lru[pt.NUM_THREADS-1][i]  = (redundant_valid[pt.NUM_THREADS-1][0] & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]) & (iccm_rw_addr[3:2] == i)) |\n                                                                                             ((addr_md_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]) & (addr_md_bank[3:2] == i) & ~iccm_corr_scnd_fetch) |\n                                                                                             ((addr_hi_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]) & (addr_hi_bank[3:2] == i) & ~iccm_correction_state))) &  ifc_select_tid_f1;\n\n        rvdff #(1) t0_selred0  (.*,\n                        .clk(active_clk),\n                        .din(sel_red0[0][i]),\n                        .dout(sel_red0_q[0][i]));\n\n        rvdff #(1) t0_selred1  (.*,\n                        .clk(active_clk),\n                        .din(sel_red1[0][i]),\n                        .dout(sel_red1_q[0][i]));\n\n        rvdff #(1) t1_selred0  (.*,\n                        .clk(active_clk),\n                        .din(sel_red0[pt.NUM_THREADS-1][i]),\n                        .dout(sel_red0_q[pt.NUM_THREADS-1][i]));\n\n        rvdff #(1) t1_selred1  (.*,\n                        .clk(active_clk),\n                        .din(sel_red1[pt.NUM_THREADS-1][i]),\n                        .dout(sel_red1_q[pt.NUM_THREADS-1][i]));\n\n       // muxing out the memory data with the redundant data if the address matches\n         assign iccm_bank_dout_fn[i][38:0] = ({39{sel_red1_q[0][i]}}                 & redundant_data[0][1][38:0]) |                                 // T0 , redundant data 1\n                                             ({39{sel_red0_q[0][i]}}                 & redundant_data[0][0][38:0]) |                                 // T0 , redundant data 0\n                                             ({39{sel_red1_q[pt.NUM_THREADS-1][i]}}  & redundant_data[pt.NUM_THREADS-1][1][38:0]) |                  // T1 , redundant data 1\n                                             ({39{sel_red0_q[pt.NUM_THREADS-1][i]}}  & redundant_data[pt.NUM_THREADS-1][0][38:0]) |                  // T1 , redundant data 0\n                                             ({39{~sel_red0_q[0][i] & ~sel_red1_q[0][i] &\n                                                  ~sel_red0_q[pt.NUM_THREADS-1][i] & ~sel_red1_q[pt.NUM_THREADS-1][i]}} & iccm_bank_dout[i][38:0]);// Bank data\n\n  end\n  else begin: one_th\n        // T0\n        assign sel_red1[pt.NUM_THREADS-1][i]  = (redundant_valid[pt.NUM_THREADS-1][1] & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2]) & (iccm_rw_addr[3:2] == i)) |\n                                                                       ((addr_md_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2]) & (addr_md_bank[3:2] == i))  |\n                                                                       ((addr_hi_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2]) & (addr_hi_bank[3:2] == i)))) &  ~ifc_select_tid_f1;\n\n        assign sel_red0[pt.NUM_THREADS-1][i]  = (redundant_valid[pt.NUM_THREADS-1][0] & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]) & (iccm_rw_addr[3:2] == i)) |\n                                                                       ((addr_md_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]) & (addr_md_bank[3:2] == i)) |\n                                                                       ((addr_hi_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]) & (addr_hi_bank[3:2] == i)))) &  ~ifc_select_tid_f1;\n\n        assign sel_red1_lru[pt.NUM_THREADS-1][i]  = (redundant_valid[pt.NUM_THREADS-1][1] & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2])  & (iccm_rw_addr[3:2] == i)) |\n                                                                           ((addr_md_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2]) & (addr_md_bank[3:2] == i) & ~iccm_corr_scnd_fetch)  |\n                                                                           ((addr_hi_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2]) & (addr_hi_bank[3:2] == i) & ~iccm_correction_state))) &  ~ifc_select_tid_f1;\n\n        assign sel_red0_lru[pt.NUM_THREADS-1][i]  = (redundant_valid[pt.NUM_THREADS-1][0] & (((iccm_rw_addr[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]) & (iccm_rw_addr[3:2] == i)) |\n                                                                           ((addr_md_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]) & (addr_md_bank[3:2] == i) & ~iccm_corr_scnd_fetch) |\n                                                                           ((addr_hi_bank[pt.ICCM_BITS-1:2] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]) & (addr_hi_bank[3:2] == i) & ~iccm_correction_state))) &  ~ifc_select_tid_f1;\n\n        rvdff #(1) t0_selred0  (.*,\n                        .clk(active_clk),\n                        .din(sel_red0[pt.NUM_THREADS-1][i]),\n                        .dout(sel_red0_q[pt.NUM_THREADS-1][i]));\n\n        rvdff #(1) t0_selred1  (.*,\n                        .clk(active_clk),\n                        .din(sel_red1[pt.NUM_THREADS-1][i]),\n                        .dout(sel_red1_q[pt.NUM_THREADS-1][i]));\n\n       // muxing out the memory data with the redundant data if the address matches\n         assign iccm_bank_dout_fn[i][38:0] = ({39{sel_red1_q[pt.NUM_THREADS-1][i]}}  & redundant_data[pt.NUM_THREADS-1][1][38:0]) |                  // T0 , redundant data 1\n                                             ({39{sel_red0_q[pt.NUM_THREADS-1][i]}}  & redundant_data[pt.NUM_THREADS-1][0][38:0]) |                  // T0 , redundant data 0\n                                             ({39{ ~sel_red0_q[pt.NUM_THREADS-1][i] & ~sel_red1_q[pt.NUM_THREADS-1][i]}} & iccm_bank_dout[i][38:0]);// Bank data\n\n  end\n\n   end : mem_bank\n// This section does the redundancy for tolerating single bit errors\n// 2x 39 bit data values with address[hi:2] and a valid bit is needed to CAM and sub out the reads/writes to the particular locations\n// Also a LRU flop is kept to decide which of the redundant element to replace.\nif (pt.NUM_THREADS > 1) begin: more_than_1\n//////////////////////////\n/// T0 T0 T0  T0 T0 T0 //\n//////////////////////////\n\n   assign r0_addr_en[0]        = ~redundant_lru[0] & iccm_buf_correct_ecc_thr[0];\n   assign r1_addr_en[0]        =  redundant_lru[0] & iccm_buf_correct_ecc_thr[0];\n\n   assign redundant_lru_en[0]  = iccm_buf_correct_ecc_thr[0] | (((|sel_red0_lru[0][pt.ICCM_NUM_BANKS-1:0]) | (|sel_red1_lru[0][pt.ICCM_NUM_BANKS-1:0])) & iccm_rden & iccm_correction_state & ~iccm_stop_fetch & ~ifc_select_tid_f1);\n   assign redundant_lru_in[0]  = iccm_buf_correct_ecc_thr[0] ? ~redundant_lru[0] : (|sel_red0_lru[0][pt.ICCM_NUM_BANKS-1:0]) ? 1'b1 : 1'b0;\n\n   rvdffs #(1) t0_red_lru  (.*,                               // LRU flop for the redundant replacements\n                   .clk(active_clk),\n                   .en(redundant_lru_en[0]),\n                   .din(redundant_lru_in[0]),\n                   .dout(redundant_lru[0]));\n\n    rvdffs #(pt.ICCM_BITS-2) t0_r0_address  (.*,                 // Redundant Row 0 address\n                   .clk(active_clk),\n                   .en(r0_addr_en[0]),\n                   .din(iccm_rw_addr[pt.ICCM_BITS-1:2]),\n                   .dout(redundant_address[0][0][pt.ICCM_BITS-1:2]));\n\n   rvdffs #(pt.ICCM_BITS-2) t0_r1_address  (.*,                   // Redundant Row 0 address\n                   .clk(active_clk),\n                   .en(r1_addr_en[0]),\n                   .din(iccm_rw_addr[pt.ICCM_BITS-1:2]),\n                   .dout(redundant_address[0][1][pt.ICCM_BITS-1:2]));\n\n    rvdffs #(1) t0_r0_valid  (.*,\n                   .clk(active_clk),                                  // Redundant Row 0 Valid\n                   .en(r0_addr_en[0]),\n                   .din(1'b1),\n                   .dout(redundant_valid[0][0]));\n\n   rvdffs #(1) t0_r1_valid  (.*,                                   // Redundant Row 1 Valid\n                   .clk(active_clk),\n                   .en(r1_addr_en[0]),\n                   .din(1'b1),\n                   .dout(redundant_valid[0][1]));\n\n\n   // We will have to update the Redundant copies in addition to the memory on subsequent writes to this memory location.\n   // The data gets updated on : 1) correction cycle, 2) Future writes - this could be W writes from DMA ( match up till addr[2]) or DW writes ( match till address[3])\n   // The data to pick also depends on the current address[2], size and the addr[2] stored in the address field of the redundant flop. Correction cycle is always W write and the data is splat on both legs, so choosing lower Word\n\n    assign redundant_data0_en[0]      = ((iccm_rw_addr[pt.ICCM_BITS-1:3] == redundant_address[0][0][pt.ICCM_BITS-1:3]) & ((iccm_rw_addr[2] == redundant_address[0][0][2]) | (iccm_wr_size[1:0] == 2'b11)) & redundant_valid[0][0] & iccm_wren) |\n                                                        (~redundant_lru[0] & iccm_buf_correct_ecc_thr[0]);\n\n    assign redundant_data0_in[0][38:0] = (((iccm_rw_addr[2] == redundant_address[0][0][2]) & iccm_rw_addr[2]) | (redundant_address[0][0][2] & (iccm_wr_size[1:0] == 2'b11))) ? iccm_wr_data[77:39]  : iccm_wr_data[38:0];\n\n    rvdffs #(39) t0_r0_data  (.*,                                 // Redundant Row 1 data\n                   .clk(active_clk),\n                   .en(redundant_data0_en[0]),\n                   .din(redundant_data0_in[0][38:0]),\n                   .dout(redundant_data[0][0][38:0]));\n\n   assign redundant_data1_en[0]      =  ((iccm_rw_addr[pt.ICCM_BITS-1:3] == redundant_address[0][1][pt.ICCM_BITS-1:3]) & ((iccm_rw_addr[2] == redundant_address[0][1][2]) | (iccm_wr_size[1:0] == 2'b11)) & redundant_valid[0][1] & iccm_wren) |\n                                                          (redundant_lru[0] & iccm_buf_correct_ecc_thr[0]);\n\n   assign redundant_data1_in[0][38:0] = (((iccm_rw_addr[2] == redundant_address[0][1][2]) & iccm_rw_addr[2]) | (redundant_address[0][1][2] & (iccm_wr_size[1:0] == 2'b11))) ? iccm_wr_data[77:39]  : iccm_wr_data[38:0];\n\n    rvdffs #(39) t0_r1_data  (.*,                                  // Redundant Row 1 data\n                   .clk(active_clk),\n                   .en(redundant_data1_en[0]),\n                   .din(redundant_data1_in[0][38:0]),\n                   .dout(redundant_data[0][1][38:0]));\n\n\n//////////////////////////\n/// T1 T1 T1  T1 T1 T1  //\n//////////////////////////\n\n   assign r0_addr_en[pt.NUM_THREADS-1]        = ~redundant_lru[pt.NUM_THREADS-1] & iccm_buf_correct_ecc_thr[pt.NUM_THREADS-1];\n   assign r1_addr_en[pt.NUM_THREADS-1]        =  redundant_lru[pt.NUM_THREADS-1] & iccm_buf_correct_ecc_thr[pt.NUM_THREADS-1];\n\n   assign redundant_lru_en[pt.NUM_THREADS-1]  = iccm_buf_correct_ecc_thr[pt.NUM_THREADS-1] | (((|sel_red0_lru[pt.NUM_THREADS-1][pt.ICCM_NUM_BANKS-1:0]) | (|sel_red1_lru[pt.NUM_THREADS-1][pt.ICCM_NUM_BANKS-1:0])) & iccm_rden & iccm_correction_state & ~iccm_stop_fetch & ifc_select_tid_f1);\n   assign redundant_lru_in[pt.NUM_THREADS-1]  = iccm_buf_correct_ecc_thr[pt.NUM_THREADS-1] ? ~redundant_lru[pt.NUM_THREADS-1] : (|sel_red0_lru[pt.NUM_THREADS-1][pt.ICCM_NUM_BANKS-1:0]) ? 1'b1 : 1'b0;\n\n   rvdffs #(1) t1_red_lru  (.*,                               // LRU flop for the redundant replacements\n                   .clk(active_clk),\n                   .en(redundant_lru_en[pt.NUM_THREADS-1]),\n                   .din(redundant_lru_in[pt.NUM_THREADS-1]),\n                   .dout(redundant_lru[pt.NUM_THREADS-1]));\n\n    rvdffs #(pt.ICCM_BITS-2) t1_r0_address  (.*,                 // Redundant Row 0 address\n                   .clk(active_clk),\n                   .en(r0_addr_en[pt.NUM_THREADS-1]),\n                   .din(iccm_rw_addr[pt.ICCM_BITS-1:2]),\n                   .dout(redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]));\n\n   rvdffs #(pt.ICCM_BITS-2) t1_r1_address  (.*,                   // Redundant Row 0 address\n                   .clk(active_clk),\n                   .en(r1_addr_en[pt.NUM_THREADS-1]),\n                   .din(iccm_rw_addr[pt.ICCM_BITS-1:2]),\n                   .dout(redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2]));\n\n    rvdffs #(1) t1_r0_valid  (.*,\n                   .clk(active_clk),                                  // Redundant Row 0 Valid\n                   .en(r0_addr_en[pt.NUM_THREADS-1]),\n                   .din(1'b1),\n                   .dout(redundant_valid[pt.NUM_THREADS-1][0]));\n\n   rvdffs #(1) t1_r1_valid  (.*,                                   // Redundant Row 1 Valid\n                   .clk(active_clk),\n                   .en(r1_addr_en[pt.NUM_THREADS-1]),\n                   .din(1'b1),\n                   .dout(redundant_valid[pt.NUM_THREADS-1][1]));\n\n\n   // We will have to update the Redundant copies in addition to the memory on subsequent writes to this memory location.\n   // The data gets updated on : 1) correction cycle, 2) Future writes - this could be W writes from DMA ( match up till addr[2]) or DW writes ( match till address[3])\n   // The data to pick also depends on the current address[2], size and the addr[2] stored in the address field of the redundant flop. Correction cycle is always W write and the data is splat on both legs, so choosing lower Word\n\n    assign redundant_data0_en[pt.NUM_THREADS-1]      = ((iccm_rw_addr[pt.ICCM_BITS-1:3] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:3]) & ((iccm_rw_addr[2] == redundant_address[pt.NUM_THREADS-1][0][2]) | (iccm_wr_size[1:0] == 2'b11)) & redundant_valid[pt.NUM_THREADS-1][0] & iccm_wren) |\n                                                        (~redundant_lru[pt.NUM_THREADS-1] & iccm_buf_correct_ecc_thr[pt.NUM_THREADS-1]);\n\n    assign redundant_data0_in[pt.NUM_THREADS-1][38:0] = (((iccm_rw_addr[2] == redundant_address[pt.NUM_THREADS-1][0][2]) & iccm_rw_addr[2]) | (redundant_address[pt.NUM_THREADS-1][0][2] & (iccm_wr_size[1:0] == 2'b11))) ? iccm_wr_data[77:39]  : iccm_wr_data[38:0];\n\n    rvdffs #(39) t1_r0_data  (.*,                                 // Redundant Row 1 data\n                   .clk(active_clk),\n                   .en(redundant_data0_en[pt.NUM_THREADS-1]),\n                   .din(redundant_data0_in[pt.NUM_THREADS-1][38:0]),\n                   .dout(redundant_data[pt.NUM_THREADS-1][0][38:0]));\n\n   assign redundant_data1_en[pt.NUM_THREADS-1]      =  ((iccm_rw_addr[pt.ICCM_BITS-1:3] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:3]) & ((iccm_rw_addr[2] == redundant_address[pt.NUM_THREADS-1][1][2]) | (iccm_wr_size[1:0] == 2'b11)) & redundant_valid[pt.NUM_THREADS-1][1] & iccm_wren) |\n                                                          (redundant_lru[pt.NUM_THREADS-1] & iccm_buf_correct_ecc_thr[pt.NUM_THREADS-1]);\n\n   assign redundant_data1_in[pt.NUM_THREADS-1][38:0] = (((iccm_rw_addr[2] == redundant_address[pt.NUM_THR"}
{"text": "EADS-1][1][2]) & iccm_rw_addr[2]) | (redundant_address[pt.NUM_THREADS-1][1][2] & (iccm_wr_size[1:0] == 2'b11))) ? iccm_wr_data[77:39]  : iccm_wr_data[38:0];\n\n    rvdffs #(39) t1_r1_data  (.*,                                  // Redundant Row 1 data\n                   .clk(active_clk),\n                   .en(redundant_data1_en[pt.NUM_THREADS-1]),\n                   .din(redundant_data1_in[pt.NUM_THREADS-1][38:0]),\n                   .dout(redundant_data[pt.NUM_THREADS-1][1][38:0]));\nend\nelse begin: one_th\n//// T0 ONLY\n   assign r0_addr_en[pt.NUM_THREADS-1]        = ~redundant_lru[pt.NUM_THREADS-1] & iccm_buf_correct_ecc_thr[pt.NUM_THREADS-1];\n   assign r1_addr_en[pt.NUM_THREADS-1]        =  redundant_lru[pt.NUM_THREADS-1] & iccm_buf_correct_ecc_thr[pt.NUM_THREADS-1];\n\n   assign redundant_lru_en[pt.NUM_THREADS-1]  = iccm_buf_correct_ecc_thr[pt.NUM_THREADS-1:0] | (((|sel_red0_lru[pt.NUM_THREADS-1][pt.ICCM_NUM_BANKS-1:0]) | (|sel_red1_lru[pt.NUM_THREADS-1][pt.ICCM_NUM_BANKS-1:0])) & iccm_rden & iccm_correction_state & ~iccm_stop_fetch);\n   assign redundant_lru_in[pt.NUM_THREADS-1]  = iccm_buf_correct_ecc_thr[pt.NUM_THREADS-1:0] ? ~redundant_lru[pt.NUM_THREADS-1] : (|sel_red0_lru[pt.NUM_THREADS-1][pt.ICCM_NUM_BANKS-1:0]) ? 1'b1 : 1'b0;\n\n   rvdffs #(pt.NUM_THREADS) red_lru  (.*,                               // LRU flop for the redundant replacements\n                   .clk(active_clk),\n                   .en(redundant_lru_en[pt.NUM_THREADS-1]),\n                   .din(redundant_lru_in[pt.NUM_THREADS-1]),\n                   .dout(redundant_lru[pt.NUM_THREADS-1]));\n\n    rvdffs #(pt.ICCM_BITS-2) r0_address  (.*,                 // Redundant Row 0 address\n                   .clk(active_clk),\n                   .en(r0_addr_en[pt.NUM_THREADS-1]),\n                   .din(iccm_rw_addr[pt.ICCM_BITS-1:2]),\n                   .dout(redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:2]));\n\n   rvdffs #(pt.ICCM_BITS-2) r1_address  (.*,                   // Redundant Row 0 address\n                   .clk(active_clk),\n                   .en(r1_addr_en[pt.NUM_THREADS-1]),\n                   .din(iccm_rw_addr[pt.ICCM_BITS-1:2]),\n                   .dout(redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:2]));\n\n    rvdffs #(1) r0_valid  (.*,\n                   .clk(active_clk),                                  // Redundant Row 0 Valid\n                   .en(r0_addr_en[pt.NUM_THREADS-1]),\n                   .din(1'b1),\n                   .dout(redundant_valid[pt.NUM_THREADS-1][0]));\n\n   rvdffs #(1) r1_valid  (.*,                                   // Redundant Row 1 Valid\n                   .clk(active_clk),\n                   .en(r1_addr_en[pt.NUM_THREADS-1]),\n                   .din(1'b1),\n                   .dout(redundant_valid[pt.NUM_THREADS-1][1]));\n\n\n   // We will have to update the Redundant copies in addition to the memory on subsequent writes to this memory location.\n   // The data gets updated on : 1) correction cycle, 2) Future writes - this could be W writes from DMA ( match up till addr[2]) or DW writes ( match till address[3])\n   // The data to pick also depends on the current address[2], size and the addr[2] stored in the address field of the redundant flop. Correction cycle is always W write and the data is splat on both legs, so choosing lower Word\n\n    assign redundant_data0_en[pt.NUM_THREADS-1]      = ((iccm_rw_addr[pt.ICCM_BITS-1:3] == redundant_address[pt.NUM_THREADS-1][0][pt.ICCM_BITS-1:3]) & ((iccm_rw_addr[2] == redundant_address[pt.NUM_THREADS-1][0][2]) | (iccm_wr_size[1:0] == 2'b11)) & redundant_valid[pt.NUM_THREADS-1][0] & iccm_wren) |\n                                                        (~redundant_lru[pt.NUM_THREADS-1] & iccm_buf_correct_ecc_thr[pt.NUM_THREADS-1]);\n\n    assign redundant_data0_in[pt.NUM_THREADS-1][38:0] = (((iccm_rw_addr[2] == redundant_address[pt.NUM_THREADS-1][0][2]) & iccm_rw_addr[2]) | (redundant_address[pt.NUM_THREADS-1][0][2] & (iccm_wr_size[1:0] == 2'b11))) ? iccm_wr_data[77:39]  : iccm_wr_data[38:0];\n\n    rvdffs #(39) r0_data  (.*,                                 // Redundant Row 1 data\n                   .clk(active_clk),\n                   .en(redundant_data0_en[pt.NUM_THREADS-1]),\n                   .din(redundant_data0_in[pt.NUM_THREADS-1][38:0]),\n                   .dout(redundant_data[pt.NUM_THREADS-1][0][38:0]));\n\n   assign redundant_data1_en[pt.NUM_THREADS-1]      =  ((iccm_rw_addr[pt.ICCM_BITS-1:3] == redundant_address[pt.NUM_THREADS-1][1][pt.ICCM_BITS-1:3]) & ((iccm_rw_addr[2] == redundant_address[pt.NUM_THREADS-1][1][2]) | (iccm_wr_size[1:0] == 2'b11)) & redundant_valid[pt.NUM_THREADS-1][1] & iccm_wren) |\n                                                          (redundant_lru[pt.NUM_THREADS-1] & iccm_buf_correct_ecc_thr[pt.NUM_THREADS-1]);\n\n   assign redundant_data1_in[pt.NUM_THREADS-1][38:0] = (((iccm_rw_addr[2] == redundant_address[pt.NUM_THREADS-1][1][2]) & iccm_rw_addr[2]) | (redundant_address[pt.NUM_THREADS-1][1][2] & (iccm_wr_size[1:0] == 2'b11))) ? iccm_wr_data[77:39]  : iccm_wr_data[38:0];\n\n    rvdffs #(39) r1_data  (.*,                                  // Redundant Row 1 data\n                   .clk(active_clk),\n                   .en(redundant_data1_en[pt.NUM_THREADS-1]),\n                   .din(redundant_data1_in[pt.NUM_THREADS-1][38:0]),\n                   .dout(redundant_data[pt.NUM_THREADS-1][1][38:0]));\nend\n\n   rvdffs  #(pt.ICCM_BANK_HI)   rd_addr_lo_ff (.*, .clk(active_clk), .din(iccm_rw_addr [pt.ICCM_BANK_HI:1]), .dout(iccm_rd_addr_lo_q[pt.ICCM_BANK_HI:1]), .en(1'b1));   // bit 0 of address is always 0\n   rvdffs  #(pt.ICCM_BANK_BITS) rd_addr_md_ff (.*, .clk(active_clk), .din(addr_md_bank[pt.ICCM_BANK_HI:2]),  .dout(iccm_rd_addr_md_q[pt.ICCM_BANK_HI:2]), .en(1'b1));\n   rvdffs  #(pt.ICCM_BANK_BITS) rd_addr_hi_ff (.*, .clk(active_clk), .din(addr_hi_bank[pt.ICCM_BANK_HI:2]),  .dout(iccm_rd_addr_hi_q[pt.ICCM_BANK_HI:2]), .en(1'b1));\n\n   assign iccm_rd_data_pre[95:0] = {iccm_bank_dout_fn[iccm_rd_addr_hi_q][31:0], iccm_bank_dout_fn[iccm_rd_addr_md_q][31:0], iccm_bank_dout_fn[iccm_rd_addr_lo_q[pt.ICCM_BANK_HI:2]][31:0]};\n   assign iccm_data[63:0]        = 64'({16'b0, (iccm_rd_data_pre[95:0] >> (16*iccm_rd_addr_lo_q[1]))});\n   assign iccm_rd_data[63:0]    = iccm_data[63:0];\n   assign iccm_rd_data_ecc[116:0]= {iccm_bank_dout_fn[iccm_rd_addr_hi_q][38:0], iccm_bank_dout_fn[iccm_rd_addr_md_q][38:0], iccm_bank_dout_fn[iccm_rd_addr_lo_q[pt.ICCM_BANK_HI:2]][38:0]};\n\nendmodule // ifu_iccm_mem\n\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n////////////////////////////////////////////////////\n//   ICACHE DATA & TAG MODULE WRAPPER              //\n/////////////////////////////////////////////////////\nmodule eh2_ifu_ic_mem\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n )\n  (\n\n      input logic                                   clk,\n      input logic                                   active_clk,\n      input logic                                   rst_l,\n      input logic                                   clk_override,\n      input logic                                   dec_tlu_core_ecc_disable,\n\n      input logic [31:1]                            ic_rw_addr,\n      input logic [pt.ICACHE_NUM_WAYS-1:0]          ic_wr_en  ,         // Which way to write\n      input logic                                   ic_rd_en  ,         // Read enable\n       input logic [pt.ICACHE_INDEX_HI:3]           ic_debug_addr,      // Read/Write addresss to the Icache.\n      input logic                                   ic_debug_rd_en,     // Icache debug rd\n      input logic                                   ic_debug_wr_en,     // Icache debug wr\n      input logic                                   ic_debug_tag_array, // Debug tag array\n      input logic [pt.ICACHE_NUM_WAYS-1:0]          ic_debug_way,       // Debug way. Rd or Wr.\n      input logic [63:0]                            ic_premux_data,     // Premux data to be muxed with each way of the Icache.\n      input logic                                   ic_sel_premux_data, // Select the pre_muxed data\n\n      input  logic [pt.ICACHE_BANKS_WAY-1:0][70:0]  ic_wr_data,         // Data to fill to the Icache. With ECC\n      output logic [63:0]                           ic_rd_data ,        // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n      output logic [70:0]                           ic_debug_rd_data ,  // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n      output logic [25:0]                           ictag_debug_rd_data,// Debug icache tag.\n      input logic  [70:0]                           ic_debug_wr_data,   // Debug wr cache.\n\n      output logic [pt.ICACHE_BANKS_WAY-1:0]        ic_eccerr,                 // ecc error per bank\n      output logic [pt.ICACHE_BANKS_WAY-1:0]        ic_parerr,                 // ecc error per bank\n      input logic [pt.ICACHE_NUM_WAYS-1:0]          ic_tag_valid,              // Valid from the I$ tag valid outside (in flops).\n\n      input eh2_ic_data_ext_in_pkt_t [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] ic_data_ext_in_pkt,   // this is being driven by the top level for soc testing/etc\n      input eh2_ic_tag_ext_in_pkt_t  [pt.ICACHE_NUM_WAYS-1:0]                          ic_tag_ext_in_pkt,\n\n      output logic [pt.ICACHE_NUM_WAYS-1:0]         ic_rd_hit,   // ic_rd_hit[3:0]\n      output logic                                  ic_tag_perr, // Tag Parity error\n      input  logic                                  scan_mode\n      ) ;\n\n\n   EH2_IC_TAG #(.pt(pt)) ic_tag_inst\n          (\n           .*,\n           .ic_wr_en     (ic_wr_en[pt.ICACHE_NUM_WAYS-1:0]),\n           .ic_debug_addr(ic_debug_addr[pt.ICACHE_INDEX_HI:3]),\n           .ic_rw_addr   (ic_rw_addr[31:3])\n           ) ;\n\n   EH2_IC_DATA #(.pt(pt)) ic_data_inst\n          (\n           .*,\n           .ic_wr_en     (ic_wr_en[pt.ICACHE_NUM_WAYS-1:0]),\n           .ic_debug_addr(ic_debug_addr[pt.ICACHE_INDEX_HI:3]),\n           .ic_rw_addr   (ic_rw_addr[31:1])\n           ) ;\n\n endmodule\n\n\n/////////////////////////////////////////////////\n////// ICACHE DATA MODULE    ////////////////////\n/////////////////////////////////////////////////\nmodule EH2_IC_DATA\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n )\n     (\n      input logic clk,\n      input logic active_clk,\n      input logic rst_l,\n      input logic clk_override,\n\n\n      input logic [31:1]  ic_rw_addr,\n      input logic [pt.ICACHE_NUM_WAYS-1:0]ic_wr_en,\n      input logic                          ic_rd_en,           // Read enable\n\n      input  logic [pt.ICACHE_BANKS_WAY-1:0][70:0]    ic_wr_data,         // Data to fill to the Icache. With ECC\n      output logic [63:0]                             ic_rd_data ,                                 // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n      input  logic [70:0]                             ic_debug_wr_data,   // Debug wr cache.\n      output logic [70:0]                             ic_debug_rd_data ,  // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n      output logic [pt.ICACHE_BANKS_WAY-1:0] ic_parerr,\n      output logic [pt.ICACHE_BANKS_WAY-1:0] ic_eccerr,    // ecc error per bank\n      input logic [pt.ICACHE_INDEX_HI:3]     ic_debug_addr,     // Read/Write addresss to the Icache.\n      input logic                            ic_debug_rd_en,      // Icache debug rd\n      input logic                            ic_debug_wr_en,      // Icache debug wr\n      input logic                            ic_debug_tag_array,  // Debug tag array\n      input logic [pt.ICACHE_NUM_WAYS-1:0]   ic_debug_way,        // Debug way. Rd or Wr.\n      input logic [63:0]                     ic_premux_data,      // Premux data to be muxed with each way of the Icache.\n      input logic                            ic_sel_premux_data,  // Select the pre_muxed data\n\n      input logic [pt.ICACHE_NUM_WAYS-1:0]ic_rd_hit,\n      input eh2_ic_data_ext_in_pkt_t  [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] ic_data_ext_in_pkt,   // this is being driven by the top level for soc testing/etc\n      input  logic                         scan_mode\n\n      ) ;\n\n\n   logic [pt.ICACHE_TAG_INDEX_LO-1:1]                                             ic_rw_addr_ff;\n   logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_WAYS-1:0]                        ic_b_sb_wren;    //bank x ways\n   logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_WAYS-1:0]                        ic_b_sb_rden;    //bank x ways\n   logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_rden;       //bank\n   logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_rden_ff;    //bank\n   logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_debug_sel_sb;\n\n\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][70:0]                  wb_dout ;       //  ways x bank\n   logic [pt.ICACHE_BANKS_WAY-1:0][70:0]                                          ic_sb_wr_data, ic_bank_wr_data, wb_dout_ecc_bank, wb_dout_ecc_bank_ff;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [141:0]                                         wb_dout_way, wb_dout_way_pre, wb_dout_way_with_premux;\n   logic [141:0]                                                                  wb_dout_ecc;\n\n   logic [pt.ICACHE_BANKS_WAY-1:0]                                                bank_check_en;\n   logic [pt.ICACHE_BANKS_WAY-1:0]                                                bank_check_en_ff;\n\n\n   logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_WAYS-1:0]                        ic_bank_way_clken;     // bank x way clk enables\n   logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_bank_way_clken_final;  // ;\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                        ic_bank_way_clken_final_up;  // ;\n\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                                 ic_debug_rd_way_en;    // debug wr_way\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                                 ic_debug_rd_way_en_ff; // debug wr_way\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                                 ic_debug_wr_way_en;    // debug wr_way\n   logic [pt.ICACHE_INDEX_HI:1]                                                   ic_rw_addr_q;\n   logic [pt.ICACHE_BANKS_WAY-1:0] [pt.ICACHE_INDEX_HI : pt.ICACHE_DATA_INDEX_LO] ic_rw_addr_bank_q;\n   logic [pt.ICACHE_TAG_LO-1 : pt.ICACHE_DATA_INDEX_LO]                           ic_rw_addr_q_inc;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                                 ic_rd_hit_q;\n\n\n\n      logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_sram_en;\n      logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_read_en;\n      logic [pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_write_en;\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0] [31 : pt.ICACHE_DATA_INDEX_LO]  wb_index_hold;\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 write_bypass_en;     //bank\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 write_bypass_en_ff;  //bank\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 index_valid;  //bank\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 ic_b_clear_en;\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 ic_b_addr_match;\n      logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 ic_b_addr_match_index_only;\n\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_sram_en_up;\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_read_en_up;\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                                                ic_b_write_en_up;\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0] [31 : pt.ICACHE_DATA_INDEX_LO]  wb_index_hold_up;\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 write_bypass_en_up;     //bank\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 write_bypass_en_ff_up;  //bank\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 index_valid_up;  //bank\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 ic_b_clear_en_up;\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 ic_b_addr_match_up;\n      logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                                 ic_b_addr_match_index_only_up;\n\n\n   logic [pt.ICACHE_BANKS_WAY-1:0]                 [31 : pt.ICACHE_DATA_INDEX_LO] ic_b_rw_addr;\n   logic [pt.ICACHE_BANKS_WAY-1:0]                 [31 : pt.ICACHE_DATA_INDEX_LO] ic_b_rw_addr_index_only;\n\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                 [31 : pt.ICACHE_DATA_INDEX_LO] ic_b_rw_addr_up;\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                 [31 : pt.ICACHE_DATA_INDEX_LO] ic_b_rw_addr_index_only_up;\n\n\n\n   logic                                                                          ic_rd_en_with_debug;\n   logic                                                                          ic_rw_addr_wrap, ic_cacheline_wrap_ff;\n\n   logic                                                                          ic_debug_rd_en_ff;\n\n\n//-----------------------------------------------------------\n// ----------- Logic section starts here --------------------\n//-----------------------------------------------------------\n   assign  ic_debug_rd_way_en[pt.ICACHE_NUM_WAYS-1:0] =  {pt.ICACHE_NUM_WAYS{ic_debug_rd_en & ~ic_debug_tag_array}} & ic_debug_way[pt.ICACHE_NUM_WAYS-1:0] ;\n   assign  ic_debug_wr_way_en[pt.ICACHE_NUM_WAYS-1:0] =  {pt.ICACHE_NUM_WAYS{ic_debug_wr_en & ~ic_debug_tag_array}} & ic_debug_way[pt.ICACHE_NUM_WAYS-1:0] ;\n\n   always_comb begin : clkens\n      ic_bank_way_clken   = '0;\n\n      for ( int i=0; i<pt.ICACHE_BANKS_WAY; i++) begin: wr_ens\n       ic_b_sb_wren[i]        =  ic_wr_en[pt.ICACHE_NUM_WAYS-1:0]  |\n                                       (ic_debug_wr_way_en[pt.ICACHE_NUM_WAYS-1:0] & {pt.ICACHE_NUM_WAYS{ic_debug_addr[pt.ICACHE_BANK_HI : pt.ICACHE_BANK_LO] == i}}) ;\n       ic_debug_sel_sb[i]     = (ic_debug_addr[pt.ICACHE_BANK_HI : pt.ICACHE_BANK_LO] == i );\n       ic_sb_wr_data[i]       = (ic_debug_sel_sb[i] & ic_debug_wr_en) ? ic_debug_wr_data : ic_bank_wr_data[i] ;\n       ic_b_rden[i]           =  ic_rd_en_with_debug & ( ( ~ic_rw_addr_q[pt.ICACHE_BANK_HI] & (i==0)) |\n                                                         (( ic_rw_addr_q[pt.ICACHE_BANK_HI] & ic_rw_addr_q[2:1] != 2'b00) & (i==0)) |\n                                                         (  ic_rw_addr_q[pt.ICACHE_BANK_HI] & (i==1)) |\n                                                         ((~ic_rw_addr_q[pt.ICACHE_BANK_HI] & ic_rw_addr_q[2:1] != 2'b00) & (i==1)) ) ;\n\n\n\n       ic_b_sb_rden[i]        =  {pt.ICACHE_NUM_WAYS{ic_b_rden[i]}}   ;\n\n\n       for ( int j=0; j<pt.ICACHE_NUM_WAYS; j++) begin: way_clkens\n         ic_bank_way_clken[i][j] |= ic_b_sb_rden[i][j] | clk_override | ic_b_sb_wren[i][j];\n       end\n     end // block: wr_ens\n   end // block: clkens\n\n// bank read enables\n  assign ic_rd_en_with_debug                          = ((ic_rd_en   | ic_debug_rd_en ) & ~(|ic_wr_en));\n  assign ic_rw_addr_q[pt.ICACHE_INDEX_HI:1] = (ic_debug_rd_en | ic_debug_wr_en) ?\n                                              {ic_debug_addr[pt.ICACHE_INDEX_HI:3],2'b0} :\n                                              ic_rw_addr[pt.ICACHE_INDEX_HI:1] ;\n\n   assign ic_rw_addr_q_inc[pt.ICACHE_TAG_LO-1:pt.ICACHE_DATA_INDEX_LO] = ic_rw_addr_q[pt.ICACHE_TAG_LO-1 : pt.ICACHE_DATA_INDEX_LO] + 1 ;\n   assign ic_rw_addr_wrap                                        = ic_rw_addr_q[pt.ICACHE_BANK_HI] & ic_rd_en_with_debug & ~(|ic_wr_en[pt.ICACHE_NUM_WAYS-1:0]);\n   assign ic_cacheline_wrap_ff                                   = ic_rw_addr_ff[pt.ICACHE_TAG_INDEX_LO-1:pt.ICACHE_BANK_LO] == {(pt.ICACHE_TAG_INDEX_LO - pt.ICACHE_BANK_LO){1'b1}};\n\n\n   assign ic_rw_addr_bank_q[0] = ~ic_rw_addr_wrap ? ic_rw_addr_q[pt.ICACHE_INDEX_HI:pt.ICACHE_DATA_INDEX_LO] : {ic_rw_addr_q[pt.ICACHE_INDEX_HI: pt.ICACHE_TAG_INDEX_LO] , ic_rw_addr_q_inc[pt.ICACHE_TAG_INDEX_LO-1: pt.ICACHE_DATA_INDEX_LO] } ;\n   assign ic_rw_addr_bank_q[1] = ic_rw_addr_q[pt.ICACHE_INDEX_HI:pt.ICACHE_DATA_INDEX_LO];\n\n\n   rvdff #((pt.ICACHE_BANKS_WAY )) rd_b_en_ff (.*,\n                                               .clk(active_clk),\n                                               .din ({ic_b_rden[pt.ICACHE_BANKS_WAY-1:0]}),\n                                               .dout({ic_b_rden_ff[pt.ICACHE_BANKS_WAY-1:0]})\n                                               ) ;\n\n\n\n   rvdff #((pt.ICACHE_TAG_INDEX_LO - 1)) adr_ff (.*,\n                                                 .clk(active_clk),\n                                                 .din ({ic_rw_addr_q[pt.ICACHE_TAG_INDEX_LO-1:1]}),\n                                                 .dout({ic_rw_addr_ff[pt.ICACHE_TAG_INDEX_LO-1:1]})\n);\n\n   rvdff #(1+pt.ICACHE_NUM_WAYS) debug_rd_wy_ff (.*,\n                                                 .clk(active_clk),\n                                                 .din ({ic_debug_rd_way_en[pt.ICACHE_NUM_WAYS-1:0], ic_debug_rd_en}),\n                                                 .dout({ic_debug_rd_way_en_ff[pt.ICACHE_NUM_WAYS-1:0], ic_debug_rd_en_ff})\n                                                 );\n\n if (pt.ICACHE_WAYPACK == 0 ) begin : PACKED_0\n\n\n\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS_WIDTH-1:0] wrptr_up;\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS_WIDTH-1:0] wrptr_in_up;\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]       sel_bypass_up;\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]       sel_bypass_ff_up;\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0][(71*pt.ICACHE_NUM_WAYS)-1:0]    sel_bypass_data_up;\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                                 any_bypass_up;\n    logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]                                 any_addr_match_up;\n\n`define EH2_IC_DATA_SRAM(depth,width)                                                                               \\\n           ram_``depth``x``width ic_bank_sb_way_data (                                                               \\\n                                     .ME(ic_bank_way_clken_final_up[i][k]),                                          \\\n                                     .WE (ic_b_sb_wren[k][i]),                                                       \\\n                                     .D  (ic_sb_wr_data[k][``width-1:0]),                                            \\\n                                     .ADR(ic_rw_addr_bank_q[k][pt.ICACHE_INDEX_HI:pt.ICACHE_DATA_INDEX_LO]),         \\\n                                     .Q  (wb_dout_pre_up[i][k]),                                                     \\\n                                     .CLK (clk),                                                                     \\\n                                     .ROP ( ),                                                                       \\\n                                     .TEST1(ic_data_ext_in_pkt[i][k].TEST1),                                         \\\n                                     .RME(ic_data_ext_in_pkt[i][k].RME),                                             \\\n                                     .RM(ic_data_ext_in_pkt[i][k].RM),                                               \\\n                                                                                                                     \\\n                                     .LS(ic_data_ext_in_pkt[i][k].LS),                                               \\\n                                     .DS(ic_data_ext_in_pkt[i][k].DS),                                               \\\n                                     .SD(ic_data_ext_in_pkt[i][k].SD),                                               \\\n                                                                                                                     \\\n                                     .TEST_RNM(ic_data_ext_in_pkt[i][k].TEST_RNM),                                   \\\n                                     .BC1(ic_data_ext_in_pkt[i][k].BC1),                                             \\\n                                     .BC2(ic_data_ext_in_pkt[i][k].BC2)                                              \\\n                                    );  \\\nif (pt.ICACHE_BYPASS_ENABLE == 1) begin \\\n                 assign wrptr_in_up[i][k] = (wrptr_up[i][k] == (pt.ICACHE_NUM_BYPASS-1)) ? '0 : (wrptr_up[i][k] + 1'd1);                                    \\\n                 rvdffs  #(pt.ICACHE_NUM_BYPASS_WIDTH)  wrptr_ff(.*, .clk(active_clk),  .en(|write_bypass_en_up[i][k]), .din (wrptr_in_up[i][k]), .dout(wrptr_up[i][k])) ;     \\\n                 assign ic_b_sram_en_up[i][k]              = ic_bank_way_clken[k][i];         "}
{"text": "                    \\\n                 assign ic_b_read_en_up[i][k]              =  ic_b_sram_en_up[i][k]  &  ic_b_sb_rden[k][i];       \\\n                 assign ic_b_write_en_up[i][k]             =  ic_b_sram_en_up[i][k] &   ic_b_sb_wren[k][i];       \\\n                 assign ic_bank_way_clken_final_up[i][k]   =  ic_b_sram_en_up[i][k] &    ~(|sel_bypass_up[i][k]); \\\n                 assign ic_b_rw_addr_up[i][k] = {ic_rw_addr[31:pt.ICACHE_INDEX_HI+1],ic_rw_addr_bank_q[k]};       \\\n                 assign ic_b_rw_addr_index_only_up[i][k] = {ic_rw_addr_bank_q[k]};                                \\\n                 always_comb begin                                                                                \\\n                    any_addr_match_up[i][k] = '0;                                                                 \\\n                    for (int l=0; l<pt.ICACHE_NUM_BYPASS; l++) begin                                              \\\n                       any_addr_match_up[i][k] |= ic_b_addr_match_up[i][k][l];                                    \\\n                    end                                                                                           \\\n                 end                                                                                              \\\n                // it is an error to ever have 2 entries with the same index and both valid                       \\\n                for (genvar l=0; l<pt.ICACHE_NUM_BYPASS; l++) begin: BYPASS                                       \\\n                   // full match up to bit 31                                                                     \\\n                   assign ic_b_addr_match_up[i][k][l] = (wb_index_hold_up[i][k][l] ==  ic_b_rw_addr_up[i][k]) & index_valid_up[i][k][l];            \\\n                   assign ic_b_addr_match_index_only_up[i][k][l] = (wb_index_hold_up[i][k][l][pt.ICACHE_INDEX_HI:pt.ICACHE_DATA_INDEX_LO] ==  ic_b_rw_addr_index_only_up[i][k]) & index_valid_up[i][k][l];            \\\n                                                                                                                                                    \\\n                   assign ic_b_clear_en_up[i][k][l]   = ic_b_write_en_up[i][k] &   ic_b_addr_match_index_only_up[i][k][l];                                     \\\n                                                                                                                                                    \\\n                   assign sel_bypass_up[i][k][l]      = ic_b_read_en_up[i][k]  &   ic_b_addr_match_up[i][k][l] ;                                    \\\n                                                                                                                                                    \\\n                   assign write_bypass_en_up[i][k][l] = ic_b_read_en_up[i][k]  &  ~any_addr_match_up[i][k] & (wrptr_up[i][k] == l);                 \\\n                                                                                                                                                    \\\n                   rvdff  #(1)  write_bypass_ff (.*, .clk(active_clk),                                                                 .din(write_bypass_en_up[i][k][l]), .dout(write_bypass_en_ff_up[i][k][l])) ; \\\n                   rvdffs #(1)  index_val_ff    (.*, .clk(active_clk), .en(write_bypass_en_up[i][k][l] | ic_b_clear_en_up[i][k][l]),   .din(~ic_b_clear_en_up[i][k][l]),  .dout(index_valid_up[i][k][l])) ;       \\\n                   rvdff  #(1)  sel_hold_ff     (.*, .clk(active_clk),                                                                 .din(sel_bypass_up[i][k][l]),      .dout(sel_bypass_ff_up[i][k][l])) ;     \\\n                   rvdffe #((31-pt.ICACHE_DATA_INDEX_LO+1)) ic_addr_index    (.*, .en(write_bypass_en_up[i][k][l]),    .din (ic_b_rw_addr_up[i][k]), .dout(wb_index_hold_up[i][k][l]));         \\\n                   rvdffe #(``width)                             rd_data_hold_ff  (.*, .en(write_bypass_en_ff_up[i][k][l]), .din (wb_dout_pre_up[i][k][``width-1:0]),  .dout(wb_dout_hold_up[i][k][l]));     \\\n                end                                                                                                                       \\\n                always_comb begin                                                                                                         \\\n                 any_bypass_up[i][k] = '0;                                                                                                \\\n                 sel_bypass_data_up[i][k] = '0;                                                                                           \\\n                 for (int l=0; l<pt.ICACHE_NUM_BYPASS; l++) begin                                                                         \\\n                    any_bypass_up[i][k]      |=  sel_bypass_ff_up[i][k][l];                                                               \\\n                    sel_bypass_data_up[i][k] |= (sel_bypass_ff_up[i][k][l]) ? wb_dout_hold_up[i][k][l] : '0;                              \\\n                 end                                                                                                                      \\\n                 wb_dout[i][k]   =   any_bypass_up[i][k] ?  sel_bypass_data_up[i][k] :  wb_dout_pre_up[i][k] ;                            \\\n                 end                                                                                                                      \\\n             end                                                                                                                          \\\n             else begin                                                                                                                   \\\n                 assign wb_dout[i][k]                      =   wb_dout_pre_up[i][k] ;                                                     \\\n                 assign ic_bank_way_clken_final_up[i][k]   =  ic_bank_way_clken[k][i];                                                      \\\n             end\n\n\n\n\n\n   for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: WAYS\n      for (genvar k=0; k<pt.ICACHE_BANKS_WAY; k++) begin: BANKS_WAY   // 16B subbank\n      if (pt.ICACHE_ECC) begin : ECC1\n        logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] [71-1:0]        wb_dout_pre_up;           // data and its bit enables\n        logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] [pt.ICACHE_NUM_BYPASS-1:0] [71-1:0]  wb_dout_hold_up;\n\n        if ($clog2(pt.ICACHE_DATA_DEPTH) == 13 )   begin : size_8192\n           `EH2_IC_DATA_SRAM(8192,71)\n        end\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 12 )   begin : size_4096\n           `EH2_IC_DATA_SRAM(4096,71)\n        end\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 11 ) begin : size_2048\n           `EH2_IC_DATA_SRAM(2048,71)\n        end\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 10 ) begin : size_1024\n           `EH2_IC_DATA_SRAM(1024,71)\n        end\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 9 ) begin : size_512\n           `EH2_IC_DATA_SRAM(512,71)\n        end\n         else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 8 ) begin : size_256\n           `EH2_IC_DATA_SRAM(256,71)\n         end\n         else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 7 ) begin : size_128\n           `EH2_IC_DATA_SRAM(128,71)\n         end\n         else  begin : size_64\n           `EH2_IC_DATA_SRAM(64,71)\n         end\n      end // if (pt.ICACHE_ECC)\n\n     else  begin  : ECC0\n        logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] [68-1:0]        wb_dout_pre_up;           // data and its bit enables\n        logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] [pt.ICACHE_NUM_BYPASS-1:0] [68-1:0]  wb_dout_hold_up;\n        if ($clog2(pt.ICACHE_DATA_DEPTH) == 13 )   begin : size_8192\n           `EH2_IC_DATA_SRAM(8192,68)\n        end\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 12 )   begin : size_4096\n           `EH2_IC_DATA_SRAM(4096,68)\n        end\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 11 ) begin : size_2048\n           `EH2_IC_DATA_SRAM(2048,68)\n        end\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 10 ) begin : size_1024\n           `EH2_IC_DATA_SRAM(1024,68)\n        end\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 9 ) begin : size_512\n           `EH2_IC_DATA_SRAM(512,68)\n        end\n         else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 8 ) begin : size_256\n           `EH2_IC_DATA_SRAM(256,68)\n         end\n         else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 7 ) begin : size_128\n           `EH2_IC_DATA_SRAM(128,68)\n         end\n         else  begin : size_64\n           `EH2_IC_DATA_SRAM(64,68)\n         end\n      end // else: !if(pt.ICACHE_ECC)\n      end // block: BANKS_WAY\n   end // block: WAYS\n\n end // block: PACKED_0\n\n // WAY PACKED\n else begin : PACKED_1\n\n    logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS_WIDTH-1:0] wrptr;\n    logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS_WIDTH-1:0] wrptr_in;\n    logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                       sel_bypass;\n    logic [pt.ICACHE_BANKS_WAY-1:0][pt.ICACHE_NUM_BYPASS-1:0]                       sel_bypass_ff;\n\n\n    logic [pt.ICACHE_BANKS_WAY-1:0][(71*pt.ICACHE_NUM_WAYS)-1:0]  sel_bypass_data;\n    logic [pt.ICACHE_BANKS_WAY-1:0]                               any_bypass;\n    logic [pt.ICACHE_BANKS_WAY-1:0]                               any_addr_match;\n\n\n// SRAM macros\n\n`define EH2_PACKED_IC_DATA_SRAM(depth,width,waywidth)                                                                                                 \\\n            ram_be_``depth``x``width  ic_bank_sb_way_data (                                                                                           \\\n                            .CLK   (clk),                                                                                                             \\\n                            .WE    (|ic_b_sb_wren[k]),                                                    // OR of all the ways in the bank           \\\n                            .WEM   (ic_b_sb_bit_en_vec[k]),                                               // 284 bits of bit enables                  \\\n                            .D     ({pt.ICACHE_NUM_WAYS{ic_sb_wr_data[k][``waywidth-1:0]}}),                                                          \\\n                            .ADR   (ic_rw_addr_bank_q[k][pt.ICACHE_INDEX_HI:pt.ICACHE_DATA_INDEX_LO]),                                                \\\n                            .Q     (wb_packeddout_pre[k]),                                                                                            \\\n                            .ME    (|ic_bank_way_clken_final[k]),                                                                                     \\\n                            .ROP   ( ),                                                                                                               \\\n                            .TEST1  (ic_data_ext_in_pkt[0][k].TEST1),                                                                                 \\\n                            .RME   (ic_data_ext_in_pkt[0][k].RME),                                                                                    \\\n                            .RM    (ic_data_ext_in_pkt[0][k].RM),                                                                                     \\\n                                                                                                                                                      \\\n                            .LS    (ic_data_ext_in_pkt[0][k].LS),                                                                                     \\\n                            .DS    (ic_data_ext_in_pkt[0][k].DS),                                                                                     \\\n                            .SD    (ic_data_ext_in_pkt[0][k].SD),                                                                                     \\\n                                                                                                                                                      \\\n                            .TEST_RNM (ic_data_ext_in_pkt[0][k].TEST_RNM),                                                                            \\\n                            .BC1      (ic_data_ext_in_pkt[0][k].BC1),                                                                                 \\\n                            .BC2      (ic_data_ext_in_pkt[0][k].BC2)                                                                                  \\\n                           );                                                                                                                         \\\n                                                                                                                                                      \\\n              if (pt.ICACHE_BYPASS_ENABLE == 1) begin                                                                                                                                                 \\\n                                                                                                                                                                                                      \\\n                 assign wrptr_in[k] = (wrptr[k] == (pt.ICACHE_NUM_BYPASS-1)) ? '0 : (wrptr[k] + 1'd1);                                                                                                \\\n                                                                                                                                                                                                      \\\n                 rvdffs  #(pt.ICACHE_NUM_BYPASS_WIDTH)  wrptr_ff(.*, .clk(active_clk), .en(|write_bypass_en[k]), .din (wrptr_in[k]), .dout(wrptr[k])) ;                                               \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_sram_en[k]              = |ic_bank_way_clken[k];                                                                                                                         \\\n                                                                                                                                                                                                      \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_read_en[k]              =  ic_b_sram_en[k] &   (|ic_b_sb_rden[k]);                                                                                                       \\\n                 assign ic_b_write_en[k]             =  ic_b_sram_en[k] &   (|ic_b_sb_wren[k]);                                                                                                       \\\n                 assign ic_bank_way_clken_final[k]   =  ic_b_sram_en[k] &    ~(|sel_bypass[k]);                                                                                                       \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_rw_addr[k] = {ic_rw_addr[31:pt.ICACHE_INDEX_HI+1],ic_rw_addr_bank_q[k]};                                                                                                 \\\n                 assign ic_b_rw_addr_index_only[k] = {ic_rw_addr_bank_q[k]};                                                                                                  \\\n                                                                                                                                                                                                      \\\n                 always_comb begin                                                                                                                                                                    \\\n                    any_addr_match[k] = '0;                                                                                                                                                           \\\n                                                                                                                                                                                                      \\\n                    for (int l=0; l<pt.ICACHE_NUM_BYPASS; l++) begin                                                                                                                                  \\\n                       any_addr_match[k] |= ic_b_addr_match[k][l];                                                                                                                                    \\\n                    end                                                                                                                                                                               \\\n                 end                                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                // it is an error to ever have 2 entries with the same index and both valid                                                                                                           \\\n                for (genvar l=0; l<pt.ICACHE_NUM_BYPASS; l++) begin: BYPASS                                                                                                                           \\\n                                                                                                                                                                                                      \\\n                   // full match up to bit 31                                                                                                                                                         \\\n                   assign ic_b_addr_match[k][l] = (wb_index_hold[k][l] ==  ic_b_rw_addr[k]) & index_valid[k][l];                                                                                      \\\n                   assign ic_b_addr_match_index_only[k][l] = (wb_index_hold[k][l][pt.ICACHE_INDEX_HI:pt.ICACHE_DATA_INDEX_LO] ==  ic_b_rw_addr_index_only[k]) & index_valid[k][l];                                                                                    \\\n                                                                                                                                                                                                      \\\n                   assign ic_b_clear_en[k][l]   = ic_b_write_en[k] &   ic_b_addr_match_index_only[k][l];                                                                                              \\\n                                                                                                                                                                                                      \\\n                   assign sel_bypass[k][l]      = ic_b_read_en[k]  &   ic_b_addr_match[k][l] ;                                                                                                        \\\n                                                                                                                                                                                                  "}
{"text": "    \\\n                   assign write_bypass_en[k][l] = ic_b_read_en[k]  &  ~any_addr_match[k] & (wrptr[k] == l);                                                                                           \\\n                                                                                                                                                                                                      \\\n                   rvdff  #(1)  write_bypass_ff (.*, .clk(active_clk),                                                     .din(write_bypass_en[k][l]), .dout(write_bypass_en_ff[k][l])) ;            \\\n                   rvdffs #(1)  index_val_ff    (.*, .clk(active_clk), .en(write_bypass_en[k][l] | ic_b_clear_en[k][l]),   .din(~ic_b_clear_en[k][l]),  .dout(index_valid[k][l])) ;                   \\\n                   rvdff  #(1)  sel_hold_ff     (.*, .clk(active_clk),                                                     .din(sel_bypass[k][l]),      .dout(sel_bypass_ff[k][l])) ;                 \\\n                                                                                                                                                                                                      \\\n                   rvdffe #((31-pt.ICACHE_DATA_INDEX_LO+1)) ic_addr_index    (.*, .en(write_bypass_en[k][l]),    .din (ic_b_rw_addr[k]),      .dout(wb_index_hold[k][l]));                            \\\n                   rvdffe #((``waywidth*pt.ICACHE_NUM_WAYS))        rd_data_hold_ff  (.*, .en(write_bypass_en_ff[k][l]), .din (wb_packeddout_pre[k]), .dout(wb_packeddout_hold[k][l]));               \\\n                                                                                                                                                                                                      \\\n                end // block: BYPASS                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                always_comb begin                                                                                                                                                                     \\\n                 any_bypass[k] = '0;                                                                                                                                                                  \\\n                 sel_bypass_data[k] = '0;                                                                                                                                                             \\\n                                                                                                                                                                                                      \\\n                 for (int l=0; l<pt.ICACHE_NUM_BYPASS; l++) begin                                                                                                                                     \\\n                    any_bypass[k]      |=  sel_bypass_ff[k][l];                                                                                                                                       \\\n                      sel_bypass_data[k] |= (sel_bypass_ff[k][l]) ? wb_packeddout_hold[k][l] : '0;                                                                                                    \\\n                 end                                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                   wb_packeddout[k]   =   any_bypass[k] ?  sel_bypass_data[k] :  wb_packeddout_pre[k] ;                                                                                               \\\n                end // always_comb begin                                                                                                                                                              \\\n                                                                                                                                                                                                      \\\n             end // if (pt.ICACHE_BYPASS_ENABLE == 1)                                                                                                                                                 \\\n             else begin                                                                                                                                                                               \\\n                 assign wb_packeddout[k]   =   wb_packeddout_pre[k] ;                                                                                                                                 \\\n                 assign ic_bank_way_clken_final[k]   =  |ic_bank_way_clken[k];                                                                                                                        \\\n             end\n\n // generate IC DATA PACKED SRAMS for 2/4 ways\n  for (genvar k=0; k<pt.ICACHE_BANKS_WAY; k++) begin: BANKS_WAY   // 16B subbank\n     if (pt.ICACHE_ECC) begin : ECC1\n        logic [pt.ICACHE_BANKS_WAY-1:0] [(71*pt.ICACHE_NUM_WAYS)-1:0]        wb_packeddout, ic_b_sb_bit_en_vec, wb_packeddout_pre;           // data and its bit enables\n\n        logic [pt.ICACHE_BANKS_WAY-1:0] [pt.ICACHE_NUM_BYPASS-1:0] [(71*pt.ICACHE_NUM_WAYS)-1:0]  wb_packeddout_hold;\n\n        for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: BITEN\n           assign ic_b_sb_bit_en_vec[k][(71*i)+70:71*i] = {71{ic_b_sb_wren[k][i]}};\n        end\n\n        // SRAMS with ECC (single/double detect; no correct)\n        if ($clog2(pt.ICACHE_DATA_DEPTH) == 13 )   begin : size_8192\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(8192,284,71)    // 64b data + 7b ecc\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(8192,142,71)\n           end // block: WAYS\n        end // block: size_8192\n\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 12 )   begin : size_4096\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(4096,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(4096,142,71)\n           end // block: WAYS\n        end // block: size_4096\n\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 11 ) begin : size_2048\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(2048,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(2048,142,71)\n           end // block: WAYS\n        end // block: size_2048\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 10 ) begin : size_1024\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(1024,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(1024,142,71)\n           end // block: WAYS\n        end // block: size_1024\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 9 ) begin : size_512\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(512,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(512,142,71)\n           end // block: WAYS\n        end // block: size_512\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 8 ) begin : size_256\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(256,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(256,142,71)\n           end // block: WAYS\n        end // block: size_256\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 7 ) begin : size_128\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(128,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(128,142,71)\n           end // block: WAYS\n        end // block: size_128\n\n        else  begin : size_64\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(64,284,71)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(64,142,71)\n           end // block: WAYS\n        end // block: size_64\n\n\n       for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: WAYS\n          assign wb_dout[i][k][70:0]  = wb_packeddout[k][(71*i)+70:71*i];\n       end : WAYS\n\n       end // if (pt.ICACHE_ECC)\n\n\n     else  begin  : ECC0\n        logic [pt.ICACHE_BANKS_WAY-1:0] [(68*pt.ICACHE_NUM_WAYS)-1:0]        wb_packeddout, ic_b_sb_bit_en_vec, wb_packeddout_pre;           // data and its bit enables\n\n        logic [pt.ICACHE_BANKS_WAY-1:0] [pt.ICACHE_NUM_BYPASS-1:0] [(68*pt.ICACHE_NUM_WAYS)-1:0]  wb_packeddout_hold;\n\n        for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: BITEN\n           assign ic_b_sb_bit_en_vec[k][(68*i)+67:68*i] = {68{ic_b_sb_wren[k][i]}};\n        end\n\n        // SRAMs with parity\n        if ($clog2(pt.ICACHE_DATA_DEPTH) == 13 )   begin : size_8192\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(8192,272,68)    // 64b data + 4b parity\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(8192,136,68)\n           end // block: WAYS\n        end // block: size_8192\n\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 12 )   begin : size_4096\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(4096,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(4096,136,68)\n           end // block: WAYS\n        end // block: size_4096\n\n        else if ($clog2(pt.ICACHE_DATA_DEPTH) == 11 ) begin : size_2048\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(2048,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(2048,136,68)\n           end // block: WAYS\n        end // block: size_2048\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 10 ) begin : size_1024\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(1024,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(1024,136,68)\n           end // block: WAYS\n        end // block: size_1024\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 9 ) begin : size_512\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(512,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(512,136,68)\n           end // block: WAYS\n        end // block: size_512\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 8 ) begin : size_256\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(256,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(256,136,68)\n           end // block: WAYS\n        end // block: size_256\n\n        else if ( $clog2(pt.ICACHE_DATA_DEPTH) == 7 ) begin : size_128\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(128,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(128,136,68)\n           end // block: WAYS\n        end // block: size_128\n\n        else  begin : size_64\n           if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(64,272,68)\n           end // block: WAYS\n           else   begin : WAYS\n              `EH2_PACKED_IC_DATA_SRAM(64,136,68)\n           end // block: WAYS\n        end // block: size_64\n\n       for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: WAYS\n          assign wb_dout[i][k][67:0]  = wb_packeddout[k][(68*i)+67:68*i];\n       end\n     end // block: ECC0\n     end // block: BANKS_WAY\n end // block: PACKED_1\n\n\n\n\n\n\n\n   assign ic_rd_hit_q[pt.ICACHE_NUM_WAYS-1:0] = ic_debug_rd_en_ff ? ic_debug_rd_way_en_ff[pt.ICACHE_NUM_WAYS-1:0] : ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0] ;\n\n\n if ( pt.ICACHE_ECC == 1) begin : ECC1_MUX\n   assign ic_bank_wr_data[1][70:0] = ic_wr_data[1][70:0];\n   assign ic_bank_wr_data[0][70:0] = ic_wr_data[0][70:0];\n\n    always_comb begin : rd_mux\n      wb_dout_way_pre[pt.ICACHE_NUM_WAYS-1:0] = '0;\n\n      for ( int i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : num_ways\n        for ( int j=0; j<pt.ICACHE_BANKS_WAY; j++) begin : banks\n         wb_dout_way_pre[i][70:0]      |=  ({71{(ic_rw_addr_ff[pt.ICACHE_BANK_HI : pt.ICACHE_BANK_LO] == (pt.ICACHE_BANK_BITS)'(j))}}   &  wb_dout[i][j]);\n         wb_dout_way_pre[i][141 : 71]  |=  ({71{(ic_rw_addr_ff[pt.ICACHE_BANK_HI : pt.ICACHE_BANK_LO] == (pt.ICACHE_BANK_BITS)'(j-1))}} &  wb_dout[i][j]);\n        end\n      end\n    end\n\n    for ( genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : num_ways_mux1\n      assign wb_dout_way[i][63:0] = (ic_rw_addr_ff[2:1] == 2'b00) ? wb_dout_way_pre[i][63:0]   :\n                                    (ic_rw_addr_ff[2:1] == 2'b01) ?{wb_dout_way_pre[i][86:71], wb_dout_way_pre[i][63:16]} :\n                                    (ic_rw_addr_ff[2:1] == 2'b10) ?{wb_dout_way_pre[i][102:71],wb_dout_way_pre[i][63:32]} :\n                                                                   {wb_dout_way_pre[i][119:71],wb_dout_way_pre[i][63:48]};\n\n      assign wb_dout_way_with_premux[i][63:0]  =  ic_sel_premux_data ? ic_premux_data[63:0] : wb_dout_way[i][63:0] ;\n   end\n\n   always_comb begin : rd_out\n      ic_debug_rd_data[70:0]     = '0;\n      ic_rd_data[63:0]           = '0;\n      wb_dout_ecc[141:0]         = '0;\n      for ( int i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : num_ways_mux2\n         ic_rd_data[63:0]       |= ({64{ic_rd_hit_q[i] | ic_sel_premux_data}}) &  wb_dout_way_with_premux[i][63:0];\n         ic_debug_rd_data[70:0] |= ({71{ic_rd_hit_q[i] & ic_debug_rd_en_ff }}) &  wb_dout_way_pre[i][70:0];\n         wb_dout_ecc[141:0]     |= {142{ic_rd_hit_q[i]}}  & wb_dout_way_pre[i];\n      end\n   end\n\n\n for (genvar i=0; i < pt.ICACHE_BANKS_WAY ; i++) begin : ic_ecc_error\n    assign bank_check_en[i]    = |ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0] & ((i==0) | (~ic_cacheline_wrap_ff & (ic_b_rden_ff[pt.ICACHE_BANKS_WAY-1:0] == {pt.ICACHE_BANKS_WAY{1'b1}})));  // always check the lower address bank, and drop the upper a\n    assign wb_dout_ecc_bank[i] = wb_dout_ecc[(71*i)+70:(71*i)];\n\n   rvdff #(1) encod_en_ff (.*,\n                           .clk(active_clk),\n                           .din (bank_check_en[i]),\n                           .dout(bank_check_en_ff[i])\n                           );\n\n   rvdffe #(71) bank_data_ff (.*,\n                             .en  (bank_check_en[i]),\n                             .din (wb_dout_ecc_bank[i][70:0]),\n                             .dout(wb_dout_ecc_bank_ff[i][70:0])\n                             );\n\n   rvecc_decode_64  ecc_decode_64 (\n                                   .en               (bank_check_en_ff[i]),\n                                   .din              ((bank_check_en_ff[i])?wb_dout_ecc_bank_ff[i][63:0]:64'd0),                  // [134:71],  [63:0]\n                                   .ecc_in           ((bank_check_en_ff[i])?wb_dout_ecc_bank_ff[i][70:64]:7'd0),               // [141:135] [70:64]\n                                   .ecc_error        (ic_eccerr[i])\n                                   );\n\n   // or the sb and db error detects into 1 signal called aligndataperr[i] where i corresponds to 2B position\n  end // block: ic_ecc_error\n\n  assign  ic_parerr[pt.ICACHE_BANKS_WAY-1:0]  = '0 ;\nend // if ( pt.ICACHE_ECC )\n\nelse  begin : ECC0_MUX\n   assign ic_bank_wr_data[1][70:0] = ic_wr_data[1][70:0];\n   assign ic_bank_wr_data[0][70:0] = ic_wr_data[0][70:0];\n\n   always_comb begin : rd_mux\n      wb_dout_way_pre[pt.ICACHE_NUM_WAYS-1:0] = '0;\n\n   for ( int i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : num_ways\n     for ( int j=0; j<pt.ICACHE_BANKS_WAY; j++) begin : banks\n         wb_dout_way_pre[i][67:0]         |=  ({68{(ic_rw_addr_ff[pt.ICACHE_BANK_HI : pt.ICACHE_BANK_LO] == (pt.ICACHE_BANK_BITS)'(j))}}   &  wb_dout[i][j][67:0]);\n         wb_dout_way_pre[i][135 : 68]     |=  ({68{(ic_rw_addr_ff[pt.ICACHE_BANK_HI : pt.ICACHE_BANK_LO] == (pt.ICACHE_BANK_BITS)'(j-1))}} &  wb_dout[i][j][67:0]);\n      end\n     end\n   end\n   for ( genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : num_ways_mux1\n      assign wb_dout_way[i][63:0] = (ic_rw_addr_ff[2:1] == 2'b00) ? wb_dout_way_pre[i][63:0]   :\n                                    (ic_rw_addr_ff[2:1] == 2'b01) ?{wb_dout_way_pre[i][83:68],  wb_dout_way_pre[i][63:16]} :\n                                    (ic_rw_addr_ff[2:1] == 2'b10) ?{wb_dout_way_pre[i][99:68],  wb_dout_way_pre[i][63:32]} :\n                                                                   {wb_dout_way_pre[i][115:68], wb_dout_way_pre[i][63:48]};\n\n      assign wb_dout_way_with_premux[i][63:0]      =  ic_sel_premux_data ? ic_premux_data[63:0]  : wb_dout_way[i][63:0] ;\n   end\n\n   always_comb begin : rd_out\n      ic_rd_data[63:0]   = '0;\n      ic_debug_rd_data[70:0]   = '0;\n      wb_dout_ecc[135:0] = '0;\n\n      for ( int i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : num_ways_mux2\n         ic_rd_data[63:0]   |= ({64{ic_rd_hit_q[i] | ic_sel_premux_data}} &  wb_dout_way_with_premux[i][63:0]);\n         ic_debug_rd_data[70:0] |= ({71{ic_rd_hit_q[i]}}) & {3'b0,wb_dout_way_pre[i][67:0]};\n         wb_dout_ecc[135:0] |= {136{ic_rd_hit_q[i]}}  & wb_dout_way_pre[i][135:0];\n      end\n   end\n\n   assign wb_dout_ecc_bank[0] =  wb_dout_ecc[67:0];\n   assign wb_dout_ecc_bank[1] =  wb_dout_ecc[135:68];\n\n   logic [pt.ICACHE_BANKS_WAY-1:0][3:0] ic_parerr_bank;\n\n  for (genvar i=0; i < pt.ICACHE_BANKS_WAY ; i++) begin : ic_par_error\n      assign bank_check_en[i]    = |ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0] & ((i==0) | (~ic_cacheline_wrap_ff & (ic_b_rden_ff[pt.ICACHE_BANKS_WAY-1:0] == {pt.ICACHE_BANKS_WAY{1'b1}})));  // always check the lower address bank, and drop the upper a\n\n      rvdff #(1) encod_en_ff (.*,\n                              .clk(active_clk),\n                              .din (bank_check_en[i]),\n                              .dout(bank_check_en_ff[i])\n                              );\n\n      rvdffe #(68) bank_data_ff (.*,\n                                .en  (bank_check_en[i]),\n                                .din (wb_dout_ecc_bank[i][67:0]),\n                                .dout(wb_dout_ecc_bank_ff[i][67:0])\n                                );\n\n     for (genvar j=0; j<4; j++)  begin : parity\n      rveven_paritycheck pchk (\n                           .data_in   (wb_dout_ecc_bank_ff[i][16*(j+1)-1: 16*j]),\n                           .parity_in (wb_dout_ecc_bank_ff[i][64+j]),\n                           .parity_err(ic_parerr_bank[i][j])\n                           );\n        end\n  end\n\n     assign ic_parerr[1] = |ic_parerr_bank[1][3:0] & bank_check_en_ff[1];\n     assign ic_parerr[0] = |ic_parerr_bank[0][3:0] & bank_check_en_ff[0];\n     assign ic_eccerr [pt.ICACHE_BANKS_WAY-1:0] = '0 ;\n\nend // else: !if( pt.ICACHE_ECC )\n\n\nendmodule // EH2_IC_DATA\n\n//=============================================================================================================================================================\n///\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\ END OF IC DATA MODULE \\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/"}
{"text": "\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\/\n//\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\n//=============================================================================================================================================================\n\n/////////////////////////////////////////////////\n////// ICACHE TAG MODULE     ////////////////////\n/////////////////////////////////////////////////\nmodule EH2_IC_TAG\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n )\n     (\n      input logic                                               clk,\n      input logic                                               active_clk,\n      input logic                                               rst_l,\n      input logic                                               clk_override,\n      input logic                                               dec_tlu_core_ecc_disable,\n\n\n      input logic [31:3]                                        ic_rw_addr,\n\n\n      input logic [pt.ICACHE_NUM_WAYS-1:0]                     ic_wr_en,  // way\n      input logic [pt.ICACHE_NUM_WAYS-1:0]                     ic_tag_valid,\n      input logic                                              ic_rd_en,\n\n      input logic [pt.ICACHE_INDEX_HI:3]                       ic_debug_addr,      // Read/Write addresss to the Icache.\n      input logic                                              ic_debug_rd_en,     // Icache debug rd\n      input logic                                              ic_debug_wr_en,     // Icache debug wr\n      input logic                                              ic_debug_tag_array, // Debug tag array\n      input logic [pt.ICACHE_NUM_WAYS-1:0]                     ic_debug_way,       // Debug way. Rd or Wr.\n      input eh2_ic_tag_ext_in_pkt_t   [pt.ICACHE_NUM_WAYS-1:0]ic_tag_ext_in_pkt,\n\n      output logic [25:0]                                       ictag_debug_rd_data,\n      input  logic [70:0]                                       ic_debug_wr_data,   // Debug wr cache.\n\n      output logic [pt.ICACHE_NUM_WAYS-1:0]                    ic_rd_hit,\n      output logic                                              ic_tag_perr,\n      input  logic                                              scan_mode\n   ) ;\n\n\n   logic [pt.ICACHE_NUM_WAYS-1:0] [25:0]                           ic_tag_data_raw;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [25:0]                           ic_tag_data_raw_ff;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [25:0]                           ic_tag_data_raw_pre;\n\n\n   logic [pt.ICACHE_NUM_WAYS-1:0] [32:pt.ICACHE_TAG_LO]            w_tout;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [32:pt.ICACHE_TAG_LO]            w_tout_ff;\n\n   logic [25:0]                                 ic_tag_wr_data ;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [31:0]                           ic_tag_corrected_data_unc;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [06:0]                           ic_tag_corrected_ecc_unc;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_single_ecc_error;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_double_ecc_error;\n   logic [6:0]                                  ic_tag_ecc;\n\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_way_perr ;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_debug_rd_way_en ;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_debug_rd_way_en_ff ;\n\n   logic [pt.ICACHE_INDEX_HI: pt.ICACHE_TAG_INDEX_LO] ic_rw_addr_q;\n   logic [31:pt.ICACHE_DATA_INDEX_LO]              ic_rw_addr_ff;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_wren;          // way\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_wren_q;        // way\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_rden_q;        // way\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_clken;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_debug_wr_way_en;   // debug wr_way\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                  ic_tag_valid_ff;\n   logic                                                           ic_rd_en_ff;\n   logic                                                           ic_rd_en_ff2;\n   logic                                                           ic_wr_en_ff;     // OR of the wr_en\n\n   logic                                                           ic_tag_parity;\n\n   logic                                                           ecc_decode_enable;\n\n   assign ecc_decode_enable = ~dec_tlu_core_ecc_disable & ic_rd_en_ff2;\n\n\n   assign  ic_tag_wren [pt.ICACHE_NUM_WAYS-1:0]  = ic_wr_en[pt.ICACHE_NUM_WAYS-1:0] & {pt.ICACHE_NUM_WAYS{(ic_rw_addr[pt.ICACHE_BEAT_ADDR_HI:4] == {pt.ICACHE_BEAT_BITS-1{1'b1}})}} ;\n   assign  ic_tag_clken[pt.ICACHE_NUM_WAYS-1:0]  = {pt.ICACHE_NUM_WAYS{ic_rd_en | clk_override}} | ic_wr_en[pt.ICACHE_NUM_WAYS-1:0] | ic_debug_wr_way_en[pt.ICACHE_NUM_WAYS-1:0] | ic_debug_rd_way_en[pt.ICACHE_NUM_WAYS-1:0];\n\n   rvdff #(32-pt.ICACHE_TAG_LO) adr_ff (.*,\n                                        .clk(active_clk),\n                                        .din ({ic_rw_addr[31:pt.ICACHE_TAG_LO]}),\n                                        .dout({ic_rw_addr_ff[31:pt.ICACHE_TAG_LO]})\n                                        );\n\n   rvdff #(pt.ICACHE_NUM_WAYS) tg_val_ff (.*,\n                                          .clk(active_clk),\n                                          .din ((ic_tag_valid[pt.ICACHE_NUM_WAYS-1:0] & {pt.ICACHE_NUM_WAYS{~ic_wr_en_ff}})),\n                                          .dout(ic_tag_valid_ff[pt.ICACHE_NUM_WAYS-1:0])\n                                          );\n\n   localparam PAD_BITS = 21 - (32 - pt.ICACHE_TAG_LO);  // sizing for a max tag width.\n\n   // tags\n   assign  ic_debug_rd_way_en[pt.ICACHE_NUM_WAYS-1:0] =  {pt.ICACHE_NUM_WAYS{ic_debug_rd_en & ic_debug_tag_array}} & ic_debug_way[pt.ICACHE_NUM_WAYS-1:0] ;\n   assign  ic_debug_wr_way_en[pt.ICACHE_NUM_WAYS-1:0] =  {pt.ICACHE_NUM_WAYS{ic_debug_wr_en & ic_debug_tag_array}} & ic_debug_way[pt.ICACHE_NUM_WAYS-1:0] ;\n\n   assign  ic_tag_wren_q[pt.ICACHE_NUM_WAYS-1:0]  =  ic_tag_wren[pt.ICACHE_NUM_WAYS-1:0] | ic_debug_wr_way_en[pt.ICACHE_NUM_WAYS-1:0]   ;\n   assign  ic_tag_rden_q[pt.ICACHE_NUM_WAYS-1:0]  =  ({pt.ICACHE_NUM_WAYS{ic_rd_en }}  | ic_debug_rd_way_en[pt.ICACHE_NUM_WAYS-1:0] ) &  {pt.ICACHE_NUM_WAYS{~(|ic_wr_en)  & ~ic_debug_wr_en}};\n\n\nif (pt.ICACHE_TAG_LO == 11) begin: SMALLEST\n if (pt.ICACHE_ECC) begin : ECC1_W\n           rvecc_encode  tag_ecc_encode (\n                                  .din    ({{pt.ICACHE_TAG_LO{1'b0}}, ic_rw_addr[31:pt.ICACHE_TAG_LO]}),\n                                  .ecc_out({ ic_tag_ecc[6:0]}));\n\n   assign  ic_tag_wr_data[25:0] = (ic_debug_wr_en & ic_debug_tag_array) ?\n                                  {ic_debug_wr_data[68:64], ic_debug_wr_data[31:11]} :\n                                  {ic_tag_ecc[4:0], ic_rw_addr[31:pt.ICACHE_TAG_LO]} ;\n end\n\n else begin : ECC0_W\n           rveven_paritygen #(32-pt.ICACHE_TAG_LO) pargen  (.data_in   (ic_rw_addr[31:pt.ICACHE_TAG_LO]),\n                                                 .parity_out(ic_tag_parity));\n\n   assign  ic_tag_wr_data[21:0] = (ic_debug_wr_en & ic_debug_tag_array) ?\n                                  {ic_debug_wr_data[64], ic_debug_wr_data[31:11]} :\n                                  {ic_tag_parity, ic_rw_addr[31:pt.ICACHE_TAG_LO]} ;\n end // else: !if(pt.ICACHE_ECC)\n\nend // block: SMALLEST\n\n\nelse begin: OTHERS\n  if(pt.ICACHE_ECC) begin : ECC1_W\n           rvecc_encode  tag_ecc_encode (\n                                  .din    ({{pt.ICACHE_TAG_LO{1'b0}}, ic_rw_addr[31:pt.ICACHE_TAG_LO]}),\n                                  .ecc_out({ ic_tag_ecc[6:0]}));\n\n   assign  ic_tag_wr_data[25:0] = (ic_debug_wr_en & ic_debug_tag_array) ?\n                                  {ic_debug_wr_data[68:64],ic_debug_wr_data[31:11]} :\n                                  {ic_tag_ecc[4:0], {PAD_BITS{1'b0}},ic_rw_addr[31:pt.ICACHE_TAG_LO]} ;\n\n  end\n  else  begin : ECC0_W\n   logic   ic_tag_parity ;\n           rveven_paritygen #(32-pt.ICACHE_TAG_LO) pargen  (.data_in   (ic_rw_addr[31:pt.ICACHE_TAG_LO]),\n                                                 .parity_out(ic_tag_parity));\n   assign  ic_tag_wr_data[21:0] = (ic_debug_wr_en & ic_debug_tag_array) ?\n                                  {ic_debug_wr_data[64], ic_debug_wr_data[31:11]} :\n                                  {ic_tag_parity, {PAD_BITS{1'b0}},ic_rw_addr[31:pt.ICACHE_TAG_LO]} ;\n  end // else: !if(pt.ICACHE_ECC)\n\nend // block: OTHERS\n\n\n    assign ic_rw_addr_q[pt.ICACHE_INDEX_HI: pt.ICACHE_TAG_INDEX_LO] = (ic_debug_rd_en | ic_debug_wr_en) ?\n                                                ic_debug_addr[pt.ICACHE_INDEX_HI: pt.ICACHE_TAG_INDEX_LO] :\n                                                ic_rw_addr[pt.ICACHE_INDEX_HI: pt.ICACHE_TAG_INDEX_LO] ;\n\n   rvdff #(pt.ICACHE_NUM_WAYS) tag_rd_wy_ff (.*,\n                                             .clk(active_clk),\n                                             .din ({ic_debug_rd_way_en[pt.ICACHE_NUM_WAYS-1:0]}),\n                                             .dout({ic_debug_rd_way_en_ff[pt.ICACHE_NUM_WAYS-1:0]})\n                                             );\n\n   rvdff #(1) rden_ff (.*,\n                       .clk(active_clk),\n                       .din (ic_rd_en),\n                       .dout(ic_rd_en_ff)\n                       );\n\n   rvdff #(1) rden_ff2 (.*,\n                        .clk(active_clk),\n                        .din (ic_rd_en_ff),\n                        .dout(ic_rd_en_ff2)\n                        );\n\n   rvdff #(1) ic_we_ff (.*,\n                        .clk(active_clk),\n                        .din (|ic_wr_en[pt.ICACHE_NUM_WAYS-1:0]),\n                        .dout(ic_wr_en_ff)\n                        );\n\n\n\n\n\nif (pt.ICACHE_WAYPACK == 0 ) begin : PACKED_0\n\n   logic [pt.ICACHE_NUM_WAYS-1:0] ic_b_sram_en;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                                                               ic_b_read_en;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                                                               ic_b_write_en;\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_TAG_NUM_BYPASS-1:0] [pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO]   wb_index_hold;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                               [pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO]   ic_b_rw_addr;\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 write_bypass_en;     //bank\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 write_bypass_en_ff;  //bank\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 index_valid;  //bank\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 ic_b_clear_en;\n   logic [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 ic_b_addr_match;\n\n\n\n\n    logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_NUM_BYPASS_WIDTH-1:0] wrptr;\n    logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_NUM_BYPASS_WIDTH-1:0] wrptr_in;\n    logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_NUM_BYPASS-1:0]       sel_bypass;\n    logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_NUM_BYPASS-1:0]       sel_bypass_ff;\n\n\n\n    logic [pt.ICACHE_NUM_WAYS-1:0][25:0]  sel_bypass_data;\n    logic [pt.ICACHE_NUM_WAYS-1:0]        any_bypass;\n    logic [pt.ICACHE_NUM_WAYS-1:0]        any_addr_match;\n    logic [pt.ICACHE_NUM_WAYS-1:0]        ic_tag_clken_final;\n\n      `define EH2_IC_TAG_SRAM(depth,width)                                                                                                      \\\n                                  ram_``depth``x``width  ic_way_tag (                                                                           \\\n                                .ME(ic_tag_clken_final[i]),                                                                                     \\\n                                .WE (ic_tag_wren_q[i]),                                                                                         \\\n                                .D  (ic_tag_wr_data[``width-1:0]),                                                                              \\\n                                .ADR(ic_rw_addr_q[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]),                                                  \\\n                                .Q  (ic_tag_data_raw_pre[i][``width-1:0]),                                                                      \\\n                                .CLK (clk),                                                                                                     \\\n                                .ROP ( ),                                                                                                       \\\n                                                                                                                                                \\\n                                .TEST1(ic_tag_ext_in_pkt[i].TEST1),                                                                             \\\n                                .RME(ic_tag_ext_in_pkt[i].RME),                                                                                 \\\n                                .RM(ic_tag_ext_in_pkt[i].RM),                                                                                   \\\n                                                                                                                                                \\\n                                .LS(ic_tag_ext_in_pkt[i].LS),                                                                                   \\\n                                .DS(ic_tag_ext_in_pkt[i].DS),                                                                                   \\\n                                .SD(ic_tag_ext_in_pkt[i].SD),                                                                                   \\\n                                                                                                                                                \\\n                                .TEST_RNM(ic_tag_ext_in_pkt[i].TEST_RNM),                                                                       \\\n                                .BC1(ic_tag_ext_in_pkt[i].BC1),                                                                                 \\\n                                .BC2(ic_tag_ext_in_pkt[i].BC2)                                                                                  \\\n                                                                                                                                                \\\n                               );                                                                                                               \\\n                                                                                                                                                \\\n                                                                                                                                                \\\n                                                                                                                                                \\\n                                                                                                                                                \\\n              if (pt.ICACHE_TAG_BYPASS_ENABLE == 1) begin                                                                                                                                             \\\n                                                                                                                                                                                                      \\\n                 assign wrptr_in[i] = (wrptr[i] == (pt.ICACHE_TAG_NUM_BYPASS-1)) ? '0 : (wrptr[i] + 1'd1);                                                                                            \\\n                                                                                                                                                                                                      \\\n                 rvdffs  #(pt.ICACHE_TAG_NUM_BYPASS_WIDTH)  wrptr_ff(.*, .clk(active_clk), .en(|write_bypass_en[i]), .din (wrptr_in[i]), .dout(wrptr[i])) ;                                           \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_sram_en[i]              = ic_tag_clken[i];                                                                                                                               \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_read_en[i]              =  ic_b_sram_en[i]  &  (ic_tag_rden_q[i]);                                                                                                       \\\n                 assign ic_b_write_en[i]             =  ic_b_sram_en[i] &   (ic_tag_wren_q[i]);                                                                                                       \\\n                 assign ic_tag_clken_final[i]        =  ic_b_sram_en[i] &    ~(|sel_bypass[i]);                                                                                                       \\\n                                                                                                                                                                                                      \\\n                 // LSB is pt.ICACHE_TAG_INDEX_LO]                                                                                                                                                    \\\n                 assign ic_b_rw_addr[i] = {ic_rw_addr_q};                                                                                                                                             \\\n                                                                                                                                                                                                      \\\n                 always_comb begin                                                                                                                                                                    \\\n                    any_addr_match[i] = '0;                                                                                                                                                           \\\n                                                                                                                                                                                                      \\\n                    for (int l=0; l<pt.ICACHE_TAG_NUM_BYPASS; l++) begin                                                                                                                              \\\n                       any_addr_match[i] |= (ic_b_addr_match[i][l] & index_valid[i][l]);                                                                                                              \\\n                    end                                                                                                                                                                               \\\n                 end                                                                        "}
{"text": "                                                                                                          \\\n                                                                                                                                                                                                      \\\n                // it is an error to ever have 2 entries with the same index and both valid                                                                                                           \\\n                for (genvar l=0; l<pt.ICACHE_TAG_NUM_BYPASS; l++) begin: BYPASS                                                                                                                       \\\n                                                                                                                                                                                                      \\\n                   assign ic_b_addr_match[i][l] = (wb_index_hold[i][l] ==  ic_b_rw_addr[i]) & index_valid[i][l];                                                                                      \\\n                                                                                                                                                                                                      \\\n                   assign ic_b_clear_en[i][l]   = ic_b_write_en[i] &   ic_b_addr_match[i][l];                                                                                                         \\\n                                                                                                                                                                                                      \\\n                   assign sel_bypass[i][l]      = ic_b_read_en[i]  &   ic_b_addr_match[i][l] ;                                                                                                        \\\n                                                                                                                                                                                                      \\\n                   assign write_bypass_en[i][l] = ic_b_read_en[i]  &  ~any_addr_match[i] & (wrptr[i] == l);                                                                                           \\\n                                                                                                                                                                                                      \\\n                   rvdff  #(1)  write_bypass_ff (.*, .clk(active_clk),                                                     .din(write_bypass_en[i][l]), .dout(write_bypass_en_ff[i][l])) ;            \\\n                   rvdffs #(1)  index_val_ff    (.*, .clk(active_clk), .en(write_bypass_en[i][l] | ic_b_clear_en[i][l]),         .din(~ic_b_clear_en[i][l]),  .dout(index_valid[i][l])) ;             \\\n                   rvdff  #(1)  sel_hold_ff     (.*, .clk(active_clk),                                                     .din(sel_bypass[i][l]),      .dout(sel_bypass_ff[i][l])) ;                 \\\n                                                                                                                                                                                                      \\\n                   rvdffs #((pt.ICACHE_INDEX_HI-pt.ICACHE_TAG_INDEX_LO+1))  ic_addr_index      (.*, .clk(active_clk), .en(write_bypass_en[i][l]),    .din (ic_b_rw_addr[i]),               .dout(wb_index_hold[i][l]));   \\\n                   rvdffe #(``width)                                          rd_data_hold_ff  (.*, .en(write_bypass_en_ff[i][l]), .din (ic_tag_data_raw_pre[i][``width-1:0]), .dout(wb_dout_hold[i][l]));            \\\n                                                                                                                                                                                                      \\\n                end // block: BYPASS                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                always_comb begin                                                                                                                                                                     \\\n                 any_bypass[i] = '0;                                                                                                                                                                  \\\n                 sel_bypass_data[i] = '0;                                                                                                                                                             \\\n                                                                                                                                                                                                      \\\n                 for (int l=0; l<pt.ICACHE_TAG_NUM_BYPASS; l++) begin                                                                                                                                 \\\n                    any_bypass[i]      |=  sel_bypass_ff[i][l];                                                                                                                                       \\\n                    sel_bypass_data[i] |= (sel_bypass_ff[i][l]) ? wb_dout_hold[i][l] : '0;                                                                                                            \\\n                 end                                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                   ic_tag_data_raw[i]   =   any_bypass[i] ?  sel_bypass_data[i] :  ic_tag_data_raw_pre[i] ;                                                                                           \\\n                end // always_comb begin                                                                                                                                                              \\\n                                                                                                                                                                                                      \\\n             end // if (pt.ICACHE_BYPASS_ENABLE == 1)                                                                                                                                                 \\\n             else begin                                                                                                                                                                               \\\n                 assign ic_tag_data_raw[i]   =   ic_tag_data_raw_pre[i] ;                                                                                                                             \\\n                 assign ic_tag_clken_final[i]       =   ic_tag_clken[i];                                                                                                                              \\\n             end\n   for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: WAYS\n\n\n   if (pt.ICACHE_ECC) begin  : ECC1\n      logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_NUM_BYPASS-1:0][25 :0] wb_dout_hold;\n\n      if (pt.ICACHE_TAG_DEPTH == 32)   begin : size_32\n                 `EH2_IC_TAG_SRAM(32,26)\n      end // if (pt.ICACHE_TAG_DEPTH == 32)\n      if (pt.ICACHE_TAG_DEPTH == 64)   begin : size_64\n                 `EH2_IC_TAG_SRAM(64,26)\n      end // if (pt.ICACHE_TAG_DEPTH == 64)\n      if (pt.ICACHE_TAG_DEPTH == 128)   begin : size_128\n                 `EH2_IC_TAG_SRAM(128,26)\n      end // if (pt.ICACHE_TAG_DEPTH == 128)\n       if (pt.ICACHE_TAG_DEPTH == 256)   begin : size_256\n                 `EH2_IC_TAG_SRAM(256,26)\n       end // if (pt.ICACHE_TAG_DEPTH == 256)\n       if (pt.ICACHE_TAG_DEPTH == 512)   begin : size_512\n                 `EH2_IC_TAG_SRAM(512,26)\n       end // if (pt.ICACHE_TAG_DEPTH == 512)\n       if (pt.ICACHE_TAG_DEPTH == 1024)   begin : size_1024\n                 `EH2_IC_TAG_SRAM(1024,26)\n       end // if (pt.ICACHE_TAG_DEPTH == 1024)\n       if (pt.ICACHE_TAG_DEPTH == 2048)   begin : size_2048\n                 `EH2_IC_TAG_SRAM(2048,26)\n       end // if (pt.ICACHE_TAG_DEPTH == 2048)\n       if (pt.ICACHE_TAG_DEPTH == 4096)   begin  : size_4096\n                 `EH2_IC_TAG_SRAM(4096,26)\n       end // if (pt.ICACHE_TAG_DEPTH == 4096)\n\n\n         assign w_tout[i][31:pt.ICACHE_TAG_LO] = ic_tag_data_raw[i][31-pt.ICACHE_TAG_LO:0] ;\n         assign w_tout[i][32]                  =  1'b0 ; // Unused in this context\n\n\n      rvdffe #(26) tg_data_raw_ff (.*,\n                                   .en(ic_rd_en_ff),\n                                   .din ({ic_tag_data_raw[i][25:0]}),\n                                   .dout({ic_tag_data_raw_ff[i][25:0]})\n                                   );\n\n\n      rvecc_decode  ecc_decode (\n                                .en(ecc_decode_enable),\n                                .sed_ded ( 1'b1 ),                                      // 1 : means only detection\n                                .din(   (ecc_decode_enable)?{11'b0,ic_tag_data_raw_ff[i][20:0]}:32'd0),\n                                .ecc_in((ecc_decode_enable)?{2'b0, ic_tag_data_raw_ff[i][25:21]}:7'd0),\n                                .dout(ic_tag_corrected_data_unc[i][31:0]),\n                                .ecc_out(ic_tag_corrected_ecc_unc[i][6:0]),\n                                .single_ecc_error(ic_tag_single_ecc_error[i]),\n                                .double_ecc_error(ic_tag_double_ecc_error[i]));\n\n        assign ic_tag_way_perr[i]= ic_tag_single_ecc_error[i] | ic_tag_double_ecc_error[i]  ;\n      end\n      else  begin : ECC0\n\n\n      logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_NUM_BYPASS-1:0][21 :0] wb_dout_hold;\n      assign ic_tag_data_raw_pre[i][25:22] = '0 ;\n\n      if (pt.ICACHE_TAG_DEPTH == 32)   begin : size_32\n                 `EH2_IC_TAG_SRAM(32,22)\n      end // if (pt.ICACHE_TAG_DEPTH == 32)\n      if (pt.ICACHE_TAG_DEPTH == 64)   begin : size_64\n                 `EH2_IC_TAG_SRAM(64,22)\n      end // if (pt.ICACHE_TAG_DEPTH == 64)\n      if (pt.ICACHE_TAG_DEPTH == 128)   begin : size_128\n                 `EH2_IC_TAG_SRAM(128,22)\n      end // if (pt.ICACHE_TAG_DEPTH == 128)\n       if (pt.ICACHE_TAG_DEPTH == 256)   begin : size_256\n                 `EH2_IC_TAG_SRAM(256,22)\n       end // if (pt.ICACHE_TAG_DEPTH == 256)\n       if (pt.ICACHE_TAG_DEPTH == 512)   begin : size_512\n                 `EH2_IC_TAG_SRAM(512,22)\n       end // if (pt.ICACHE_TAG_DEPTH == 512)\n       if (pt.ICACHE_TAG_DEPTH == 1024)   begin : size_1024\n                 `EH2_IC_TAG_SRAM(1024,22)\n       end // if (pt.ICACHE_TAG_DEPTH == 1024)\n       if (pt.ICACHE_TAG_DEPTH == 2048)   begin : size_2048\n                 `EH2_IC_TAG_SRAM(2048,22)\n       end // if (pt.ICACHE_TAG_DEPTH == 2048)\n       if (pt.ICACHE_TAG_DEPTH == 4096)   begin  : size_4096\n                 `EH2_IC_TAG_SRAM(4096,22)\n       end // if (pt.ICACHE_TAG_DEPTH == 4096)\n\n\n         assign w_tout[i][31:pt.ICACHE_TAG_LO] = ic_tag_data_raw[i][31-pt.ICACHE_TAG_LO:0] ;\n         assign w_tout[i][32]                  = ic_tag_data_raw[i][21] ;\n\n         rvdff #(33-pt.ICACHE_TAG_LO) tg_data_raw_ff (.*,\n                                                      .clk(active_clk),\n                                                      .din (w_tout[i][32:pt.ICACHE_TAG_LO]),\n                                                      .dout(w_tout_ff[i][32:pt.ICACHE_TAG_LO])\n                                                      );\n\n         rveven_paritycheck #(32-pt.ICACHE_TAG_LO) parcheck(.data_in   (w_tout_ff[i][31:pt.ICACHE_TAG_LO]),\n                                                   .parity_in (w_tout_ff[i][32]),\n                                                   .parity_err(ic_tag_way_perr[i]));\n      end // else: !if(pt.ICACHE_ECC)\n\n   end // block: WAYS\nend // block: PACKED_0\n\n   // WAY PACKED\nelse begin : PACKED_1\n\n   logic                                                                                ic_b_sram_en;\n   logic                                                                                ic_b_read_en;\n   logic                                                                                ic_b_write_en;\n   logic [pt.ICACHE_TAG_NUM_BYPASS-1:0] [pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO]   wb_index_hold;\n   logic                                [pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO]   ic_b_rw_addr;\n   logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 write_bypass_en;     //bank\n   logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 write_bypass_en_ff;  //bank\n   logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 index_valid;  //bank\n   logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 ic_b_clear_en;\n   logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]                                                 ic_b_addr_match;\n\n\n\n\n    logic [pt.ICACHE_TAG_NUM_BYPASS_WIDTH-1:0]  wrptr;\n    logic [pt.ICACHE_TAG_NUM_BYPASS_WIDTH-1:0]  wrptr_in;\n    logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]        sel_bypass;\n    logic [pt.ICACHE_TAG_NUM_BYPASS-1:0]        sel_bypass_ff;\n\n\n\n    logic [(26*pt.ICACHE_NUM_WAYS)-1:0]  sel_bypass_data;\n    logic                                any_bypass;\n    logic                                any_addr_match;\n    logic                                ic_tag_clken_final;\n\n`define EH2_IC_TAG_PACKED_SRAM(depth,width)                                                               \\\n                  ram_be_``depth``x``width  ic_way_tag (                                                   \\\n                                .ME  ( ic_tag_clken_final),                                                \\\n                                .WE  (|ic_tag_wren_q[pt.ICACHE_NUM_WAYS-1:0]),                             \\\n                                .WEM (ic_tag_wren_biten_vec[``width-1:0]),                                 \\\n                                                                                                           \\\n                                .D   ({pt.ICACHE_NUM_WAYS{ic_tag_wr_data[``width/pt.ICACHE_NUM_WAYS-1:0]}}), \\\n                                .ADR (ic_rw_addr_q[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]),            \\\n                                .Q   (ic_tag_data_raw_packed_pre[``width-1:0]),                            \\\n                                .CLK (clk),                                                                \\\n                                .ROP ( ),                                                                  \\\n                                                                                                           \\\n                                .TEST1     (ic_tag_ext_in_pkt[0].TEST1),                                   \\\n                                .RME      (ic_tag_ext_in_pkt[0].RME),                                      \\\n                                .RM       (ic_tag_ext_in_pkt[0].RM),                                       \\\n                                                                                                           \\\n                                .LS       (ic_tag_ext_in_pkt[0].LS),                                       \\\n                                .DS       (ic_tag_ext_in_pkt[0].DS),                                       \\\n                                .SD       (ic_tag_ext_in_pkt[0].SD),                                       \\\n                                                                                                           \\\n                                .TEST_RNM (ic_tag_ext_in_pkt[0].TEST_RNM),                                 \\\n                                .BC1      (ic_tag_ext_in_pkt[0].BC1),                                      \\\n                                .BC2      (ic_tag_ext_in_pkt[0].BC2)                                       \\\n                                                                                                           \\\n                               );                                                                          \\\n                                                                                                           \\\n              if (pt.ICACHE_TAG_BYPASS_ENABLE == 1) begin                                                                                                                                             \\\n                                                                                                                                                                                                      \\\n                 assign wrptr_in = (wrptr == (pt.ICACHE_TAG_NUM_BYPASS-1)) ? '0 : (wrptr + 1'd1);                                                                                                     \\\n                                                                                                                                                                                                      \\\n                 rvdffs  #(pt.ICACHE_TAG_NUM_BYPASS_WIDTH)  wrptr_ff(.*, .clk(active_clk), .en(|write_bypass_en), .din (wrptr_in), .dout(wrptr)) ;                                                                    \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_sram_en              = |ic_tag_clken;                                                                                                                                    \\\n                                                                                                                                                                                                      \\\n                 assign ic_b_read_en              =  ic_b_sram_en  &  (|ic_tag_rden_q);                                                                                                               \\\n                 assign ic_b_write_en             =  ic_b_sram_en &   (|ic_tag_wren_q);                                                                                                               \\\n                 assign ic_tag_clken_final        =  ic_b_sram_en &    ~(|sel_bypass);                                                                                                                \\\n                                                                                                                                                                                                      \\\n                 // LSB is pt.ICACHE_TAG_INDEX_LO]                                                                                                                                                    \\\n                 assign ic_b_rw_addr = {ic_rw_addr_q};                                                                                                                                                \\\n                                                                                                                                                                                                      \\\n                 always_comb begin                                                                                                        "}
{"text": "                                                            \\\n                    any_addr_match = '0;                                                                                                                                                              \\\n                                                                                                                                                                                                      \\\n                    for (int l=0; l<pt.ICACHE_TAG_NUM_BYPASS; l++) begin                                                                                                                              \\\n                       any_addr_match |= ic_b_addr_match[l];                                                                                                                                          \\\n                    end                                                                                                                                                                               \\\n                 end                                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                // it is an error to ever have 2 entries with the same index and both valid                                                                                                           \\\n                for (genvar l=0; l<pt.ICACHE_TAG_NUM_BYPASS; l++) begin: BYPASS                                                                                                                       \\\n                                                                                                                                                                                                      \\\n                   assign ic_b_addr_match[l] = (wb_index_hold[l] ==  ic_b_rw_addr) & index_valid[l];                                                                                                  \\\n                                                                                                                                                                                                      \\\n                   assign ic_b_clear_en[l]   = ic_b_write_en &   ic_b_addr_match[l];                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                   assign sel_bypass[l]      = ic_b_read_en  &   ic_b_addr_match[l] ;                                                                                                                 \\\n                                                                                                                                                                                                      \\\n                   assign write_bypass_en[l] = ic_b_read_en  &  ~any_addr_match & (wrptr == l);                                                                                                       \\\n                                                                                                                                                                                                      \\\n                   rvdff  #(1)  write_bypass_ff (.*, .clk(active_clk),                                                     .din(write_bypass_en[l]), .dout(write_bypass_en_ff[l])) ;                                  \\\n                   rvdffs #(1)  index_val_ff    (.*, .clk(active_clk), .en(write_bypass_en[l] | ic_b_clear_en[l]),         .din(~ic_b_clear_en[l]),  .dout(index_valid[l])) ;                                         \\\n                   rvdff  #(1)  sel_hold_ff     (.*, .clk(active_clk),                                                     .din(sel_bypass[l]),      .dout(sel_bypass_ff[l])) ;                                               \\\n                                                                                                                                                                                                      \\\n                   rvdffs #((pt.ICACHE_INDEX_HI-pt.ICACHE_TAG_INDEX_LO+1))  ic_addr_index    (.*, .clk(active_clk), .en(write_bypass_en[l]),    .din (ic_b_rw_addr),               .dout(wb_index_hold[l]));          \\\n                   rvdffe #(``width)                                        rd_data_hold_ff  (.*, .en(write_bypass_en_ff[l]), .din (ic_tag_data_raw_packed_pre[``width-1:0]), .dout(wb_packeddout_hold[l]));          \\\n                                                                                                                                                                                                      \\\n                end // block: BYPASS                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                always_comb begin                                                                                                                                                                     \\\n                 any_bypass = '0;                                                                                                                                                                     \\\n                 sel_bypass_data = '0;                                                                                                                                                                \\\n                                                                                                                                                                                                      \\\n                 for (int l=0; l<pt.ICACHE_TAG_NUM_BYPASS; l++) begin                                                                                                                                 \\\n                    any_bypass      |=  sel_bypass_ff[l];                                                                                                                                             \\\n                    sel_bypass_data |= (sel_bypass_ff[l]) ? wb_packeddout_hold[l] : '0;                                                                                                               \\\n                 end                                                                                                                                                                                  \\\n                                                                                                                                                                                                      \\\n                   ic_tag_data_raw_packed   =   any_bypass ?  sel_bypass_data :  ic_tag_data_raw_packed_pre ;                                                                                         \\\n                end // always_comb begin                                                                                                                                                              \\\n                                                                                                                                                                                                      \\\n             end // if (pt.ICACHE_BYPASS_ENABLE == 1)                                                                                                                                                 \\\n             else begin                                                                                                                                                                               \\\n                 assign ic_tag_data_raw_packed   =   ic_tag_data_raw_packed_pre ;                                                                                                                     \\\n                 assign ic_tag_clken_final       =  |ic_tag_clken;                                                                                                                                    \\\n             end\n\n   if (pt.ICACHE_ECC) begin  : ECC1\n    logic [(26*pt.ICACHE_NUM_WAYS)-1 :0]  ic_tag_data_raw_packed, ic_tag_wren_biten_vec, ic_tag_data_raw_packed_pre;           // data and its bit enables\n    logic [pt.ICACHE_TAG_NUM_BYPASS-1:0][(26*pt.ICACHE_NUM_WAYS)-1 :0] wb_packeddout_hold;\n    for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: BITEN\n        assign ic_tag_wren_biten_vec[(26*i)+25:26*i] = {26{ic_tag_wren_q[i]}};\n     end\n      if (pt.ICACHE_TAG_DEPTH == 32)   begin : size_32\n        if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(32,104)\n        end // block: WAYS\n      else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(32,52)\n        end // block: WAYS\n      end // if (pt.ICACHE_TAG_DEPTH == 32\n\n      if (pt.ICACHE_TAG_DEPTH == 64)   begin : size_64\n        if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(64,104)\n        end // block: WAYS\n      else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(64,52)\n        end // block: WAYS\n      end // block: size_64\n\n      if (pt.ICACHE_TAG_DEPTH == 128)   begin : size_128\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(128,104)\n      end // block: WAYS\n      else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(128,52)\n      end // block: WAYS\n\n      end // block: size_128\n\n      if (pt.ICACHE_TAG_DEPTH == 256)   begin : size_256\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(256,104)\n        end // block: WAYS\n       else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(256,52)\n        end // block: WAYS\n      end // block: size_256\n\n      if (pt.ICACHE_TAG_DEPTH == 512)   begin : size_512\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(512,104)\n        end // block: WAYS\n       else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(512,52)\n        end // block: WAYS\n      end // block: size_512\n\n      if (pt.ICACHE_TAG_DEPTH == 1024)   begin : size_1024\n         if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(1024,104)\n        end // block: WAYS\n       else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(1024,52)\n        end // block: WAYS\n      end // block: size_1024\n\n      if (pt.ICACHE_TAG_DEPTH == 2048)   begin : size_2048\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(2048,104)\n        end // block: WAYS\n       else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(2048,52)\n        end // block: WAYS\n      end // block: size_2048\n\n      if (pt.ICACHE_TAG_DEPTH == 4096)   begin  : size_4096\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(4096,104)\n        end // block: WAYS\n       else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(4096,52)\n        end // block: WAYS\n      end // block: size_4096\n\n\n        for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin\n          assign ic_tag_data_raw[i]  = ic_tag_data_raw_packed[(26*i)+25:26*i];\n          assign w_tout[i][31:pt.ICACHE_TAG_LO] = ic_tag_data_raw[i][31-pt.ICACHE_TAG_LO:0] ;\n          assign w_tout[i][32]                  =  1'b0 ; // Unused in this context\n\n           rvdffe #(26) tg_data_raw_ff (.*,\n                                        .en  (ic_rd_en_ff),\n                                        .din ({ic_tag_data_raw[i][25:0]}),\n                                        .dout({ic_tag_data_raw_ff[i][25:0]})\n                                        );\n\n\n           rvecc_decode  ecc_decode (\n                                     .en(ecc_decode_enable),\n                                     .sed_ded ( 1'b1 ),                                      // 1 : means only detection\n                                     .din(   (ecc_decode_enable)?{11'b0,ic_tag_data_raw_ff[i][20:0]}:32'd0),\n                                     .ecc_in((ecc_decode_enable)?{2'b0, ic_tag_data_raw_ff[i][25:21]}:7'd0),\n                                     .dout(ic_tag_corrected_data_unc[i][31:0]),\n                                     .ecc_out(ic_tag_corrected_ecc_unc[i][6:0]),\n                                     .single_ecc_error(ic_tag_single_ecc_error[i]),\n                                     .double_ecc_error(ic_tag_double_ecc_error[i]));\n\n\n           assign ic_tag_way_perr[i]= ic_tag_single_ecc_error[i] | ic_tag_double_ecc_error[i]  ;\n\n        end // for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++)\n\n   end // block: ECC1\n\n\n   else  begin : ECC0\n\n    logic [(22*pt.ICACHE_NUM_WAYS)-1 :0]  ic_tag_data_raw_packed, ic_tag_wren_biten_vec, ic_tag_data_raw_packed_pre;           // data and its bit enables\n    logic [pt.ICACHE_TAG_NUM_BYPASS-1:0][(22*pt.ICACHE_NUM_WAYS)-1 :0] wb_packeddout_hold;\n    for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin: BITEN\n        assign ic_tag_wren_biten_vec[(22*i)+21:22*i] = {22{ic_tag_wren_q[i]}};\n     end\n      if (pt.ICACHE_TAG_DEPTH == 32)   begin : size_32\n        if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(32,88)\n        end // block: WAYS\n      else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(32,44)\n        end // block: WAYS\n      end // if (pt.ICACHE_TAG_DEPTH == 32\n\n      if (pt.ICACHE_TAG_DEPTH == 64)   begin : size_64\n        if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(64,88)\n        end // block: WAYS\n      else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(64,44)\n        end // block: WAYS\n      end // block: size_64\n\n      if (pt.ICACHE_TAG_DEPTH == 128)   begin : size_128\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(128,88)\n      end // block: WAYS\n      else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(128,44)\n      end // block: WAYS\n\n      end // block: size_128\n\n      if (pt.ICACHE_TAG_DEPTH == 256)   begin : size_256\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(256,88)\n        end // block: WAYS\n       else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(256,44)\n        end // block: WAYS\n      end // block: size_256\n\n      if (pt.ICACHE_TAG_DEPTH == 512)   begin : size_512\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(512,88)\n        end // block: WAYS\n       else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(512,44)\n        end // block: WAYS\n      end // block: size_512\n\n      if (pt.ICACHE_TAG_DEPTH == 1024)   begin : size_1024\n         if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(1024,88)\n        end // block: WAYS\n       else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(1024,44)\n        end // block: WAYS\n      end // block: size_1024\n\n      if (pt.ICACHE_TAG_DEPTH == 2048)   begin : size_2048\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(2048,88)\n        end // block: WAYS\n       else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(2048,44)\n        end // block: WAYS\n      end // block: size_2048\n\n      if (pt.ICACHE_TAG_DEPTH == 4096)   begin  : size_4096\n       if (pt.ICACHE_NUM_WAYS == 4) begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(4096,88)\n        end // block: WAYS\n       else begin : WAYS\n                 `EH2_IC_TAG_PACKED_SRAM(4096,44)\n        end // block: WAYS\n      end // block: size_4096\n\n\n      for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : WAYS\n          assign ic_tag_data_raw[i]  = ic_tag_data_raw_packed[(22*i)+21:22*i];\n          assign w_tout[i][31:pt.ICACHE_TAG_LO] = ic_tag_data_raw[i][31-pt.ICACHE_TAG_LO:0] ;\n          assign w_tout[i][32]                 = ic_tag_data_raw[i][21] ;\n\n          rvdff #(33-pt.ICACHE_TAG_LO) tg_data_raw_ff (.*,\n                                                       .clk(active_clk),\n                                                       .din (w_tout[i][32:pt.ICACHE_TAG_LO]),\n                                                       .dout(w_tout_ff[i][32:pt.ICACHE_TAG_LO])\n                                                       );\n\n          rveven_paritycheck #(32-pt.ICACHE_TAG_LO) parcheck(.data_in   (w_tout_ff[i][31:pt.ICACHE_TAG_LO]),\n                                                   .parity_in (w_tout_ff[i][32]),\n                                                   .parity_err(ic_tag_way_perr[i]));\n      end // block: WAYS\n\n\n\n   end // block: ECC0\nend // block: PACKED_1\n\n\n   always_comb begin : tag_rd_out\n      ictag_debug_rd_data[25:0] = '0;\n      for ( int j=0; j<pt.ICACHE_NUM_WAYS; j++) begin: debug_rd_out\n         ictag_debug_rd_data[25:0] |=  pt.ICACHE_ECC ? ({26{ic_debug_rd_way_en_ff[j]}} & ic_tag_data_raw[j] ) : {4'b0, ({22{ic_debug_rd_way_en_ff[j]}} & ic_tag_data_raw[j][21:0])};\n      end\n   end\n\n\n   for ( genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin : ic_rd_hit_loop\n      assign ic_rd_hit[i] = (w_tout[i][31:pt.ICACHE_TAG_LO] == ic_rw_addr_ff[31:pt.ICACHE_TAG_LO]) & ic_tag_valid[i] & ~ic_wr_en_ff;\n   end\n\n   assign  ic_tag_perr  = | (ic_tag_way_perr[pt.ICACHE_NUM_WAYS-1:0] & ic_tag_valid_ff[pt.ICACHE_NUM_WAYS-1:0] ) ;\nendmodule // EH2_IC_TAG\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// eh2_ifu_ifc_ctl.sv\n// Function: Fetch pipe control\n//\n// Comments:\n//********************************************************************************\n\nmodule eh2_ifu_ifc_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n   input logic clk,\n   input logic active_clk,\n\n   input logic rst_l, // reset enable, from core pin\n   input logic scan_mode, // scan\n\n   input logic ic_hit_f2,      // Icache hit\n   input logic ic_crit_wd_rdy, // Crit word ready to be forwarded\n   input logic ifu_ic_mb_empty, // Miss buffer empty\n\n   input logic ifu_fb_consume1,  // Aligner consumed 1 fetch buffer\n   input logic ifu_fb_consume2,  // Aligner consumed 2 fetch buffers\n\n   input logic dec_tlu_flush_noredir_wb, // Don't fetch on flush\n   input logic dec_tlu_flush_mp_wb,\n   input logic dec_tlu_flush_lower_wb, // Flush\n   input logic exu_flush_final, // FLush\n   input logic [31:1] exu_flush_path_final, // Flush path\n   input logic [31:1] dec_tlu_flush_path_wb, // Flush path\n\n   input logic exu_flush_final_early, // FLush\n   input logic [31:1] exu_flush_path_final_early, // Flush path\n\n   input logic ifu_bp_kill_next_f2, // kill next fetch, taken target found\n   input logic [31:1] ifu_bp_btb_target_f2, //  predicted target PC\n\n   input logic ic_dma_active, // IC DMA active, stop fetching\n   input logic ic_write_stall, // IC is writing, stop fetching\n   input logic dma_iccm_stall_any, // force a stall in the fetch pipe for DMA ICCM access\n\n   input logic [31:0]  dec_tlu_mrac_ff ,   // side_effect and cacheable for each region\n\n   input logic tid,\n   input logic ifc_select_tid_f1,\n\n   output logic  fetch_uncacheable_f1, // fetch to uncacheable address as determined by MRAC\n\n   output logic [31:1] fetch_addr_f1, // fetch addr F1\n   output logic [31:1] fetch_addr_bf, // fetch addr F1\n   output logic [31:1] fetch_addr_f2,\n\n   output [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] fetch_btb_rd_addr_f1, // btb read hash\n   output [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] fetch_btb_rd_addr_p1_f1, // btb read hash\n\n   output logic  fetch_req_bf,\n   output logic  fetch_req_f1,  // fetch request valid F1\n   output logic  fetch_req_f1_raw, // for clock-gating in mem_ctl\n   output logic  fetch_req_f2,  // fetch request valid F2\n\n   output logic  pmu_fetch_stall, // pmu event measuring fetch stall\n\n   output logic  iccm_access_f1, // fetch to ICCM region\n   output logic  region_acc_fault_f1, // fetch access fault\n   output logic  dma_access_ok, // fetch is not accessing the ICCM, DMA can proceed\n   output logic  ready // ready to fetch\n   );\n\n\n   logic [31:1]  miss_addr, ifc_fetch_addr_f1_raw;\n   logic [31:3]  fetch_addr_next;\n   logic [31:1]  miss_addr_ns;\n   logic [4:0]   cacheable_select;\n   logic [4:0]   fb_write_f1, fb_write_ns;\n\n   logic         fb_full_f1_ns, fb_full_f1;\n   logic         fb_right, fb_right2, fb_right3, fb_left, wfm, fetch_ns, fetch, idle;\n   logic         fetch_req_f2_ns, fetch_req_f1_raw_unqual;\n   logic         missff_en;\n   logic         fetch_crit_word, ic_crit_wd_rdy_f, ic_crit_wd_rdy_d1, fetch_crit_word_d1, fetch_crit_word_d2, my_bp_kill_next_f2;\n   logic         sel_last_addr_bf, sel_miss_addr_bf, sel_btb_addr_bf, sel_next_addr_bf;\n   logic         miss_f2, miss_a;\n   logic         flush_fb, dma_iccm_stall_any_f;\n   logic         mb_empty_mod, goto_idle, leave_idle;\n   logic         ic_crit_wd_rdy_mod;\n   logic         miss_sel_flush;\n   logic         miss_sel_f2;\n   logic         miss_sel_f1;\n   logic         miss_sel_bf;\n   logic         fetch_bf_en;\n   logic         ifc_fetch_req_f2_raw;\n   logic         line_wrap, lost_arb;\n   logic [2:1]   fetch_addr_next_2_1;\n\n   logic         fetch_req_f1_won;\n   logic         iccm_acc_in_range_f1;\n   logic         iccm_acc_in_region_f1;\n   logic [31:1]  exu_flush_path_final_early_f;\n\n   if (pt.ICCM_ENABLE == 1)\n     begin\n        logic iccm_acc_in_region_f1;\n        logic iccm_acc_in_range_f1;\n     end\n   logic dma_stall, kill_fetch;\n\n   // FSM assignment\n    typedef enum logic [1:0] { IDLE  = 2'b00,\n                               FETCH = 2'b01,\n                               STALL = 2'b10,\n                               WFM   = 2'b11 } state_t ;\n   state_t state      ;\n   state_t next_state ;\n\n   assign dma_stall = ic_dma_active | dma_iccm_stall_any_f;\n\n\n   rvdff #(2) ran_ff (.*, .clk(active_clk), .din({dma_iccm_stall_any, miss_f2}), .dout({dma_iccm_stall_any_f, miss_a}));\n\n   // If crit word fetch is blocked, try again\n   assign ic_crit_wd_rdy_mod = ic_crit_wd_rdy_f & ~((fetch_crit_word_d2 | ic_write_stall) & ~fetch_req_f2);\n\n   // For Ifills, we fetch the critical word. Needed for perf and for rom bypass\n   assign fetch_crit_word = ic_crit_wd_rdy_mod & ~ic_crit_wd_rdy_d1 & ~flush_fb & ~ic_write_stall;\n   assign my_bp_kill_next_f2 = ifu_bp_kill_next_f2 & ifc_fetch_req_f2_raw;\n   assign missff_en = flush_fb | (~ic_hit_f2 & fetch_req_f2) | fetch_crit_word_d1 | my_bp_kill_next_f2 | (fetch_req_f2 & ~fetch_req_f1_won & ~fetch_crit_word_d2);\n   assign miss_sel_f2 = ~flush_fb & ~ic_hit_f2 & fetch_req_f2;\n   assign miss_sel_f1 = ~flush_fb & ~miss_sel_f2 & ~fetch_req_f1_won & fetch_req_f2 & ~fetch_crit_word_d2 & ~my_bp_kill_next_f2;\n   assign miss_sel_bf = ~miss_sel_f2 & ~miss_sel_f1 & ~miss_sel_flush;\n\n   // pcie too much pressure\n   rvdffe #(31) faddmiss_ff (.*, .en(missff_en), .din(miss_addr_ns[31:1]), .dout(miss_addr[31:1]));\n\n\n   // Fetch address mux\n   // - flush\n   // - Miss *or* flush during WFM (icache miss buffer is blocking)\n   // - Sequential\n\nlogic dec_tlu_flush_noredir_wb_f, flush_noredir, ic_crit_wd_rdy_qual, flush_lower_qual;\n   logic [31:1] fetch_addr_bf_pre;\nif(pt.BTB_USE_SRAM) begin\n\n   // hold the early flush path\n   rvdffe #(31) faddmiss_ff (.*, .en(exu_flush_final_early), .din(exu_flush_path_final_early[31:1]), .dout(exu_flush_path_final_early_f[31:1]));\n   assign flush_lower_qual = dec_tlu_flush_lower_wb & ~dec_tlu_flush_mp_wb;\n   assign flush_fb = exu_flush_final | flush_lower_qual;\n   assign sel_last_addr_bf =  (flush_fb & ~fetch_req_f1_won) | (~fetch_req_f1_won & ~my_bp_kill_next_f2 & fetch_req_f2);\n   assign sel_miss_addr_bf =  ~(flush_fb & ~fetch_req_f1_won) & ~fetch_req_f1_won & ~my_bp_kill_next_f2 & ~fetch_req_f2;\n   assign sel_btb_addr_bf  =  my_bp_kill_next_f2;\n   assign sel_next_addr_bf =  fetch_req_f1_won;\n\n   assign miss_sel_flush = flush_fb & (((wfm | idle) & ~fetch_crit_word_d1)  | dma_stall | ic_write_stall | lost_arb);\n\n   assign fetch_addr_bf_pre[31:1] = (({31{ flush_lower_qual}} & dec_tlu_flush_path_wb[31:1]) | // Flush path\n                                     ({31{~flush_lower_qual & sel_miss_addr_bf}} & miss_addr[31:1]) | // MISS path\n                                     ({31{~flush_lower_qual & sel_btb_addr_bf}} & {ifu_bp_btb_target_f2[31:1]})| // BTB target\n                                     ({31{~flush_lower_qual & sel_last_addr_bf}} & {fetch_addr_f1[31:1]})| // Last cycle\n                                     ({31{~flush_lower_qual & sel_next_addr_bf}} & {fetch_addr_next[31:3],fetch_addr_next_2_1[2:1]})); // SEQ path\n\n   assign fetch_addr_bf[31:1] = ({31{ exu_flush_final_early}} & exu_flush_path_final_early[31:1]) |\n                                ({31{~exu_flush_final_early}} & fetch_addr_bf_pre[31:1]) ;\n\n   assign miss_addr_ns[31:1] = ( ({31{miss_sel_flush}} & (flush_lower_qual ? dec_tlu_flush_path_wb[31:1] : exu_flush_path_final_early_f[31:1])) |\n                                 ({31{miss_sel_f2}} & fetch_addr_f2[31:1]) |\n                                 ({31{miss_sel_f1}} & fetch_addr_f1[31:1]) |\n                                 ({31{miss_sel_bf}} & fetch_addr_bf_pre[31:1]));\n\n   assign fetch_addr_f1[31:1] = ifc_fetch_addr_f1_raw[31:1];\n\n   assign ic_crit_wd_rdy_qual = ic_crit_wd_rdy & ~dec_tlu_flush_noredir_wb;\n\n   rvdff #(5) iccrit_ff (.*, .clk(active_clk), .din({dec_tlu_flush_noredir_wb, ic_crit_wd_rdy_qual, ic_crit_wd_rdy_mod, fetch_crit_word,    fetch_crit_word_d1}),\n                                              .dout({dec_tlu_flush_noredir_wb_f, ic_crit_wd_rdy_f, ic_crit_wd_rdy_d1,  fetch_crit_word_d1, fetch_crit_word_d2}));\n\n   assign fetch = state == FETCH ;\n   assign fetch_req_bf = (fetch | fetch_crit_word);\n   assign fetch_bf_en = (fetch | fetch_crit_word | exu_flush_final_early | exu_flush_final | flush_lower_qual);\n   assign flush_noredir = dec_tlu_flush_noredir_wb | dec_tlu_flush_noredir_wb_f;\n   assign kill_fetch = flush_lower_qual;\n\nend\nelse begin // NOT SRAM\n   assign flush_fb = exu_flush_final;\n   // tlu flush and exu mispredict flush are combined when not using srams for the btb\n   assign miss_sel_flush = exu_flush_final & (((wfm | idle) & ~fetch_crit_word_d1)  | dma_stall | ic_write_stall | lost_arb);\n   assign sel_last_addr_bf = ~miss_sel_flush & ~fetch_req_f1_won & fetch_req_f2 & ~my_bp_kill_next_f2;\n   assign sel_miss_addr_bf = ~miss_sel_flush & ~my_bp_kill_next_f2 & ~fetch_req_f1_won & ~fetch_req_f2;\n   assign sel_btb_addr_bf  = ~miss_sel_flush & my_bp_kill_next_f2;\n   assign sel_next_addr_bf = ~miss_sel_flush & fetch_req_f1_won;\n   assign fetch_addr_bf[31:1] = ( ({31{miss_sel_flush}} &  exu_flush_path_final[31:1]) | // FLUSH path\n                                  ({31{sel_miss_addr_bf}} & miss_addr[31:1]) | // MISS path\n                                  ({31{sel_btb_addr_bf}} & {ifu_bp_btb_target_f2[31:1]})| // BTB target\n                                  ({31{sel_last_addr_bf}} & {fetch_addr_f1[31:1]})| // Last cycle\n                                  ({31{sel_next_addr_bf}} & {fetch_addr_next[31:3],fetch_addr_next_2_1[2:1]})); // SEQ path\n\n   assign miss_addr_ns[31:1] = ( ({31{miss_sel_flush}} & exu_flush_path_final[31:1]) |\n                                 ({31{miss_sel_f2}} & fetch_addr_f2[31:1]) |\n                                 ({31{miss_sel_f1}} & fetch_addr_f1[31:1]) |\n                                 ({31{miss_sel_bf}} & fetch_addr_bf[31:1]));\n\n   assign fetch_addr_f1[31:1] = ( ({31{exu_flush_final}} & exu_flush_path_final[31:1]) |\n                                  ({31{~exu_flush_final}} & ifc_fetch_addr_f1_raw[31:1]));\n   rvdff #(3) iccrit_ff (.*, .clk(active_clk), .din({ic_crit_wd_rdy_mod, fetch_crit_word,    fetch_crit_word_d1}),\n                                              .dout({ic_crit_wd_rdy_d1,  fetch_crit_word_d1, fetch_crit_word_d2}));\n   assign ic_crit_wd_rdy_f = ic_crit_wd_rdy;\n   assign fetch_req_bf = (fetch_ns | fetch_crit_word);\n   assign fetch_bf_en = (fetch_ns | fetch_crit_word);\n   assign flush_noredir = dec_tlu_flush_noredir_wb;\n   assign kill_fetch = '0;\n\n\nend // else: !if(pt.BTB_USE_SRAM)\n\n   assign fetch_addr_next[31:3] = fetch_addr_f1[31:3] + 29'b1;\n\n   assign line_wrap = (fetch_addr_next[pt.ICACHE_TAG_INDEX_LO] ^ fetch_addr_f1[pt.ICACHE_TAG_INDEX_LO]);\n// For verilator.... jb\n   assign fetch_addr_next_2_1[2:1] = line_wrap ? 2'b0 : fetch_addr_f1[2:1];\n\n\n   assign miss_f2 = fetch_req_f2 & ~ic_hit_f2;\n\n\n   // Halt flushes and takes us to IDLE\n   assign goto_idle = flush_fb & dec_tlu_flush_noredir_wb;\n   // If we're in IDLE, and we get a flush, goto FETCH\n   assign leave_idle = flush_fb & ~dec_tlu_flush_noredir_wb & idle;\n   assign mb_empty_mod = (ifu_ic_mb_empty | flush_fb) & ~dma_stall & ~miss_f2 & ~miss_a;\n\n\n//.i 6\n//.o 2\n//.ilb state[1] state[0] miss_f2 mb_empty_mod  goto_idle leave_idle\n//.ob next_state[1] next_state[0]\n//.type fr\n//\n//# fetch 01, stall 10, wfm 11, idle 00\n//-- --1- 00\n//00 --00 00\n//00 --01 01\n//\n//01 1-0- 11\n//01 0-0- 01\n//\n//11 -10- 01\n//11 -00- 11\n\n   assign next_state[1] = state_t'((~state[1] & state[0] & miss_f2 & ~goto_idle) |\n                          (state[1] & ~mb_empty_mod & ~goto_idle));\n\n   assign next_state[0] = state_t'((~goto_idle & leave_idle) | (state[0] & ~goto_idle));\n\n\n   // model fb write logic to mass balance the fetch buffers\n   assign fb_right = (~ifu_fb_consume1 & ~ifu_fb_consume2 & miss_f2) |  // F2 cache miss, repair mass balance\n                     ( ifu_fb_consume1 & ~ifu_fb_consume2 & ~fetch_req_f1_won & ~miss_f2) | // Consumed and no new fetch\n                      (ifu_fb_consume2 &  fetch_req_f1_won & ~miss_f2); // Consumed 2 and new fetch\n\n\n   assign fb_right2 = (ifu_fb_consume1 & ~ifu_fb_consume2 & miss_f2) | // consume 1 and miss 1\n                      (ifu_fb_consume2 & ~fetch_req_f1_won); // Consumed 2 and no new fetch\n\n   assign fb_right3 = (ifu_fb_consume2 & miss_f2); // consume 2 and miss\n\n   assign fb_left = fetch_req_f1_won & ~(ifu_fb_consume1 | ifu_fb_consume2) & ~miss_f2;\n\n   assign fb_write_ns[4:0] = ( ({5{(flush_fb & ~fetch_req_f1_won)}} & 5'b00001) |\n                               ({5{(flush_fb & fetch_req_f1_won)}} & 5'b00010) |\n                               ({5{~flush_fb & fb_right }} & {1'b0, fb_write_f1[4:1]}) |\n                               ({5{~flush_fb & fb_right2}} & {2'b0, fb_write_f1[4:2]}) |\n                               ({5{~flush_fb & fb_right3}} & {3'b0, fb_write_f1[4:3]}  ) |\n                               ({5{~flush_fb & fb_left  }} & {fb_write_f1[3:0], 1'b0}) |\n                               ({5{~flush_fb & ~fb_right & ~fb_right2 & ~fb_left & ~fb_right3}}  & fb_write_f1[4:0]));\n\n\n   assign fb_full_f1_ns = fb_write_ns[4];\n\n   assign idle     = state      == IDLE  ;\n   assign wfm      = state      == WFM   ;\n   assign fetch_ns = next_state == FETCH ;\n\n   rvdff #(2) fsm_ff (.*, .clk(active_clk), .din({next_state[1:0]}), .dout({state[1:0]}));\n   rvdff #(6) fbwrite_ff (.*, .clk(active_clk), .din({fb_full_f1_ns, fb_write_ns[4:0]}), .dout({fb_full_f1, fb_write_f1[4:0]}));\n\nif(pt.NUM_THREADS > 1) begin : ignoreconsume\n   assign pmu_fetch_stall = wfm |\n                                (fetch_req_f1_raw &\n                                ( (fb_full_f1 & ~(flush_fb)) |\n                                  dma_stall));\n   // BTB hit kills this fetch\n   assign fetch_req_f1 = ( fetch_req_f1_raw &\n                           ~kill_fetch &\n                           ~my_bp_kill_next_f2 &\n                           ~(fb_full_f1 & ~(flush_fb)) &\n                           ~dma_stall &\n                           ~ic_write_stall &\n                           ~flush_noredir );\n\nend // block: ignoreconsume\nelse begin\n   assign pmu_fetch_stall = wfm |\n                                (fetch_req_f1_raw &\n                                ( (fb_full_f1 & ~(ifu_fb_consume2 | ifu_fb_consume1 | flush_fb)) |\n                                  dma_stall));\n   // BTB hit kills this fetch\n   assign fetch_req_f1 = ( fetch_req_f1_raw &\n                           ~kill_fetch &\n                           ~my_bp_kill_next_f2 &\n                           ~(fb_full_f1 & ~(ifu_fb_consume2 | ifu_fb_consume1 | flush_fb)) &\n                           ~dma_stall &\n                           ~ic_write_stall &\n                           ~flush_noredir );\nend\n\n   if(pt.BTB_USE_SRAM) begin\n      assign ready = fetch_req_bf &\n                     ~(fb_full_f1 & ~(ifu_fb_consume2 | ifu_fb_consume1 | flush_fb));\n   end\n   else\n     assign ready = fetch_req_f1;\n\n   assign fetch_req_f1_won = fetch_req_f1 & ~(tid ^ ifc_select_tid_f1);\n   assign lost_arb = tid ^ ifc_select_tid_f1;\n   // kill F2 request if we flush or if the prior fetch missed the cache/mem\n   assign fetch_req_f2_ns = fetch_req_f1_won & ~miss_f2 & ~miss_a;\n\n   rvdff #(2) req_ff (.*, .clk(active_clk), .din({fetch_req_bf, fetch_req_f2_ns}), .dout({fetch_req_f1_raw_unqual, ifc_fetch_req_f2_raw}));\n   assign fetch_req_f1_raw = fetch_req_f1_raw_unqual & ~miss_a;\n\n   assign fetch_req_f2 = ifc_fetch_req_f2_raw & ~flush_fb;\n\n   // this flop needs a delayed clock *if* using SRAM btb\n   rvdffe #(31) faddrf1_ff  (.*, .en(fetch_bf_en), .din(fetch_addr_bf[31:1]), .dout(ifc_fetch_addr_f1_raw[31:1]));\n\n   rvdffpcie #(31) faddrf2_ff (.*,  .en(fetch_req_f1_won), .din(fetch_addr_f1[31:1]), .dout(fetch_addr_f2[31:1]));\n\n   // timing fix attempt\n   logic [31:3] fetch_addr_p1_f1;\n   eh2_btb_addr_hash #(.pt(pt)) f1hash(.pc(fetch_addr_f1[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(fetch_btb_rd_addr_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n   assign fetch_addr_p1_f1[31:3] = fetch_addr_f1[31:3] + 29'b1;\n   eh2_btb_addr_hash #(.pt(pt)) f1hash_p1(.pc(fetch_addr_p1_f1[pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO]), .hash(fetch_btb_rd_addr_p1_f1[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO]));\n\n\n\nif (pt.ICCM_ENABLE == 1)\n begin\n   rvrangecheck #( .CCM_SADR    (pt.ICCM_SADR),\n                   .CCM_SIZE    (pt.ICCM_SIZE) ) iccm_rangecheck (\n                                                                     .addr     ({fetch_addr_f1[31:1],1'b0}) ,\n                                                                     .in_range (iccm_acc_in_range_f1) ,\n                                                                     .in_region(iccm_acc_in_region_f1)\n                                                                     );\n\n   assign iccm_access_f1 = iccm_acc_in_range_f1 ;\n\n\n   assign region_acc_fault_f1 = ~iccm_acc_in_range_f1 & iccm_acc_in_region_f1 ;\n\n    if(pt.NUM_THREADS > 1) begin\n   assign dma_access_ok = ( (~iccm_access_f1 |\n                                 (fb_full_f1) |\n                                 wfm |\n                                 idle ) & ~flush_fb) |\n                              dma_iccm_stall_any_f;\n    end\n    else begin\n   assign dma_access_ok = ( (~iccm_access_f1 |\n                                 (fb_full_f1 & ~(ifu_fb_consume2 | ifu_fb_consume1)) |\n                                 wfm |\n                                 idle ) & ~flush_fb) |\n                              dma_iccm_stall_any_f;\n       end\n\n end\nelse\n begin\n   assign iccm_access_f1 = 1'b0 ;\n   assign dma_access_ok  = 1'b0 ;\n   assign region_acc_fault_f1  = 1'b0 ;\n end\n\n\n   assign cacheable_select[4:0]    =  {fetch_addr_f1[31:28] , 1'b0 } ;\n   assign fetch_uncacheable_f1 =  ~dec_tlu_mrac_ff[cacheable_select]  ; // bit 0 of each region description is the cacheable bit\n\nendmodule // eh2_ifu_ifc_ctl\n\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n\n//********************************************************************************\n// Function: Icache , iccm  control\n// BFF -> F1 -> F2 -> A\n//********************************************************************************\n\nmodule eh2_ifu_mem_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n )\n  (\n   input logic clk,\n   input logic active_clk,\n   input logic [pt.NUM_THREADS-1:0] active_thread_l2clk,\n   input logic rst_l,\n\n   input logic  [pt.NUM_THREADS-1:0] exu_flush_final,               // Flush from the pipeline.\n   input logic  [pt.NUM_THREADS-1:0] dec_tlu_flush_lower_wb,        // Flush from the pipeline.\n   input logic  [pt.NUM_THREADS-1:0] dec_tlu_flush_err_wb,          // Flush from the pipeline due to perr.\n   input logic  [pt.NUM_THREADS-1:0] dec_tlu_force_halt,            // force halt\n\n   input logic [31:1]                fetch_addr_f1,                 // Fetch Address byte aligned always.      F1 stage.\n   input logic                       fetch_tid_f1,\n   input logic                       ifc_fetch_uncacheable_f1,      // The fetch request is uncacheable space. F1 stage\n   input logic                       ifc_fetch_req_f1,              // Fetch request. Comes with the address.  F1 stage\n   input logic                       ifc_fetch_req_f1_raw,          // Fetch request without some qualifications. Used for clock-gating. F1 stage\n   input logic                       ifc_iccm_access_f1,            // This request is to the ICCM. Do not generate misses to the bus.\n   input logic                       ifc_region_acc_fault_f1,       // Access fault. in ICCM region but offset is outside defined ICCM.\n   input logic                       ifc_dma_access_ok,             // It is OK to give dma access to the ICCM. (ICCM is not busy this cycle).\n   input logic  [pt.NUM_THREADS-1:0] dec_tlu_fence_i_wb,            // Fence.i instruction is committing. Clear all Icache valids.\n   input logic                       ifu_bp_kill_next_f2,           // Branch is predicted taken. Kill the fetch next cycle.\n   input logic   [3:0]               ifu_fetch_val,                 // valids on a 2B boundary\n   input logic   [3:1]               ifu_bp_inst_mask_f2,            // tell ic which valids to kill because of a taken branch, right justified\n\n   output logic [pt.NUM_THREADS-1:0] ifu_ic_mb_empty_thr,           // Continue with normal fetching. This does not mean that miss is finished.\n   output logic                      ic_dma_active  ,               // In the middle of servicing dma request to ICCM. Do not make any new requests.\n   output logic [pt.NUM_THREADS-1:0] ic_write_stall_thr,            // Stall fetch the cycle we are writing the cache.\n\n\n   output logic [pt.NUM_THREADS-1:0]  ifu_miss_state_idle,          // I-side miss buffer empty\n   output logic [pt.NUM_THREADS-1:0]  ifu_ic_error_start,           // IC single bit error\n   output logic [pt.NUM_THREADS-1:0]  ifu_iccm_rd_ecc_single_err,   // ICCM single bit error\n\n   output logic [pt.NUM_THREADS-1:0] ifu_pmu_ic_miss,               // IC miss event\n   output logic [pt.NUM_THREADS-1:0] ifu_pmu_ic_hit,                // IC hit event\n   output logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_error,             // Bus error event\n   output logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_busy,              // Bus busy event\n   output logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_trxn,              // Bus transaction\n\n  //-------------------------- IFU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            ifu_axi_awvalid,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_awid,\n   output logic [31:0]                     ifu_axi_awaddr,\n   output logic [3:0]                      ifu_axi_awregion,\n   output logic [7:0]                      ifu_axi_awlen,\n   output logic [2:0]                      ifu_axi_awsize,\n   output logic [1:0]                      ifu_axi_awburst,\n   output logic                            ifu_axi_awlock,\n   output logic [3:0]                      ifu_axi_awcache,\n   output logic [2:0]                      ifu_axi_awprot,\n   output logic [3:0]                      ifu_axi_awqos,\n\n   output logic                            ifu_axi_wvalid,\n   output logic [63:0]                     ifu_axi_wdata,\n   output logic [7:0]                      ifu_axi_wstrb,\n   output logic                            ifu_axi_wlast,\n\n   output logic                            ifu_axi_bready,\n\n   // AXI Read Channels\n   output logic                            ifu_axi_arvalid,\n   input  logic                            ifu_axi_arready,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_arid,\n   output logic [31:0]                     ifu_axi_araddr,\n   output logic [3:0]                      ifu_axi_arregion,\n   output logic [7:0]                      ifu_axi_arlen,\n   output logic [2:0]                      ifu_axi_arsize,\n   output logic [1:0]                      ifu_axi_arburst,\n   output logic                            ifu_axi_arlock,\n   output logic [3:0]                      ifu_axi_arcache,\n   output logic [2:0]                      ifu_axi_arprot,\n   output logic [3:0]                      ifu_axi_arqos,\n\n   input  logic                            ifu_axi_rvalid,\n   output logic                            ifu_axi_rready,\n   input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_rid,\n   input  logic [63:0]                     ifu_axi_rdata,\n   input  logic [1:0]                      ifu_axi_rresp,\n\n   input  logic                      ifu_bus_clk_en,\n\n\n   input  logic                      dma_iccm_req,      //  dma iccm command (read or write)\n   input  logic [31:0]               dma_mem_addr,      //  dma address\n   input  logic [2:0]                dma_mem_sz,        //  size\n   input  logic                      dma_mem_write,     //  write\n   input  logic [63:0]               dma_mem_wdata,     //  write data\n   input  logic [2:0]                dma_mem_tag,       //  DMA Buffer entry number\n\n   output logic                      iccm_dma_ecc_error,//   Data read from iccm has an ecc error\n   output logic                      iccm_dma_rvalid,   //   Data read from iccm is valid\n   output logic [63:0]               iccm_dma_rdata,    //   dma data read from iccm\n   output logic [2:0]                iccm_dma_rtag,     //   Tag of the DMA req\n   output logic                      iccm_ready,        //   iccm ready to accept new command.\n\n\n//   I$ & ITAG Ports\n   output logic [31:1]               ic_rw_addr,         // Read/Write addresss to the Icache.\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_wr_en,           // Icache write enable, when filling the Icache.\n   output logic                      ic_rd_en,           // Icache read  enable.\n\n   output logic [pt.ICACHE_BANKS_WAY-1:0] [70:0]               ic_wr_data,           // Data to fill to the Icache. With ECC\n   input  logic [63:0]               ic_rd_data ,          // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [70:0]               ic_debug_rd_data ,    // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [25:0]               ictag_debug_rd_data,  // Debug icache tag.\n   output logic [70:0]               ic_debug_wr_data,     // Debug wr cache.\n   output logic [70:0]               ifu_ic_debug_rd_data, // debug data read\n\n\n   input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_eccerr,    //\n   input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_parerr,\n\n   output logic [pt.ICACHE_INDEX_HI:3]               ic_debug_addr,      // Read/Write addresss to the Icache.\n   output logic                      ic_debug_rd_en,     // Icache debug rd\n   output logic                      ic_debug_wr_en,     // Icache debug wr\n   output logic                      ic_debug_tag_array, // Debug tag array\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_debug_way,       // Debug way. Rd or Wr.\n\n\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                ic_tag_valid,       // Valid bits when accessing the Icache. One valid bit per way. F2 stage\n\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]                ic_rd_hit,          // Compare hits from Icache tags. Per way.  F2 stage\n   input  logic                      ic_tag_perr,        // Icache Tag parity error\n\n   // ICCM ports\n   output logic [pt.ICCM_BITS-1:1]   iccm_rw_addr,       // ICCM read/write address.\n   output logic                      iccm_wren,          // ICCM write enable (through the DMA)\n   output logic                      iccm_rden,          // ICCM read enable.\n   output logic [77:0]               iccm_wr_data,       // ICCM write data.\n   output logic [2:0]                iccm_wr_size,       // ICCM write location within DW.\n\n   input  logic [63:0]               iccm_rd_data,       // Data read from ICCM.\n   input  logic [116:0]              iccm_rd_data_ecc,   // Data + ECC read from ICCM.\n\n   // IFU control signals\n   output logic                      ic_hit_f2,              // Hit in Icache(if Icache access) or ICCM access( ICCM always has ic_hit_f2)\n   output logic [pt.NUM_THREADS-1:0] ic_crit_wd_rdy_thr,     //\n   output logic  [3:0]               ic_access_fault_f2,     // Access fault (bus error or ICCM access in region but out of offset range).\n   output logic  [1:0]               ic_access_fault_type_f2,// Access fault type\n   output logic                      iccm_rd_ecc_single_err, // This fetch has a single ICCM ecc  error.\n   output logic  [3:0]               iccm_rd_ecc_double_err, // This fetch has a double ICCM ecc  error.\n   output logic [pt.NUM_THREADS-1:0] ifu_async_error_start,  // The or of the async errors of single bit ecc and all icache errors\n   output logic                      iccm_dma_sb_error,      // Single Bit ECC error from a DMA access\n\n   output logic [3:0]                ic_fetch_val_f2,        // valid bytes for fetch. To the Aligner.\n   output logic [63:0]               ic_data_f2,             // Data read from Icache or ICCM. To the Aligner.\n   output logic                      fetch_tid_f2,\n\n   output logic [63:0]               ic_premux_data,         // Premuxed data to be muxed with Icache data\n   output logic                      ic_sel_premux_data,     // Select premux data.\n\n/////  Debug\n   input  eh2_cache_debug_pkt_t     dec_tlu_ic_diag_pkt ,       // Icache/tag debug read/write packet\n   input  logic [pt.NUM_THREADS-1:0] dec_tlu_i0_commit_cmt,\n   input  logic                      dec_tlu_core_ecc_disable,   // disable the ecc checking and flagging\n   output logic                      ifu_ic_debug_rd_data_valid, // debug data valid.\n   output logic [pt.NUM_THREADS-1:0] iccm_buf_correct_ecc_thr,\n   output logic                      iccm_correction_state,\n   output logic                      iccm_stop_fetch,\n   output logic                      iccm_corr_scnd_fetch,\n   input  logic         scan_mode\n   );\n\n// copied from the global.h for reference\n//localparam ICACHE_NUM_BEATS     = (ICACHE_LN_SZ == 64) ? 8 : 4;\n//localparam ICACHE_BEAT_BITS     = (ICACHE_LN_SZ == 64) ? 3 : 2;\n//localparam ICACHE_SCND_LAST     = (ICACHE_LN_SZ == 64) ? 6 : 2;\n//localparam ICACHE_BEAT_ADDR_HI  = (ICACHE_LN_SZ == 64) ? 5 : 4;\n\n\n//  Create different defines for ICACHE and ICCM enable combinations\n\n localparam   NUM_OF_BEATS = 8 ;\n\n\n\n   logic [31:3]    ifu_ic_req_addr_f2;\n   logic           bus_ifu_wr_en_ff_q  ;\n   logic           bus_ifu_wr_en_ff_wo_err  ;\n\n   logic [pt.ICACHE_NUM_WAYS-1:0]     bus_ic_wr_en ;\n\n   logic           reset_tag_valid_for_miss  ;\n\n\n\n   logic [pt.ICACHE_STATUS_BITS-1:0]             way_status_hit_new;\n   logic [pt.ICACHE_STATUS_BITS-1:0]             way_status_wr_w_debug;\n   logic                                         ifc_dma_access_q_ok;\n   logic                                         ifc_iccm_access_f2 ;\n   logic [3:0]                                   ifc_bus_acc_fault_f2;\n   logic                                         fetch_req_f2_qual   ;\n   logic                                         ic_valid ;\n   logic                                         ic_valid_ff;\n   logic                                         ic_valid_w_debug;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                 ifu_tag_wren,ifu_tag_wren_ff, ifu_tag_miss_wren;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                 ic_debug_tag_wr_en;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                 ifu_tag_wren_w_debug;\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]              ifu_ic_rw_int_addr_w_debug ;\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]              ifu_status_wr_addr_w_debug ;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                 ic_debug_way_ff;\n   logic                                                          ic_debug_rd_en_ff   ;\n   logic                                                          debug_c1_clken;\n   logic                                                          debug_c1_clk;\n   logic [pt.ICACHE_BEAT_ADDR_HI:1]                               vaddr_f2 ;\n   logic [127:0]                                                  ic_final_data;\n   logic [pt.ICACHE_STATUS_BITS-1:0]                              way_status_wr_ff ;\n   logic [pt.ICACHE_STATUS_BITS-1:0]                              way_status_up_ff ;\n   logic                                                          way_status_wr_en_ff ;\n   logic [pt.ICACHE_TAG_DEPTH-1:0][pt.ICACHE_STATUS_BITS-1:0]     way_status_out ;\n   logic [1:0]                                                    ic_debug_way_enc;\n   logic [63:0]                                                   ic_rd_data_only;\n   logic                                                          way_status_up_en;\n   logic                                                          way_status_wr_en;\n   logic                                                          sel_byp_data;\n   logic                                                          sel_ic_data;\n   logic                                                          sel_ic_data_ff;\n   logic                                                          sel_iccm_data;\n   logic                                                          ic_rd_parity_final_err;\n   logic                                                          way_status_wr_en_w_debug;\n   logic                                                          ic_debug_tag_val_rd_out;\n   logic                                                          ic_debug_ict_array_sel_in;\n   logic                                                          ic_debug_ict_array_sel_ff;\n   logic                                                          debug_data_clk;\n   logic                                                          debug_data_clken;\n   logic                                                          ifu_bus_rvalid_unq_ff    ;\n   logic                                                          ifu_bus_arready_unq_ff    ;\n   logic                                                          ifu_bus_arready_unq       ;\n   logic [63:0]                                                   ifu_bus_rdata_ff        ;\n   logic [pt.ICCM_BITS-1:2]                                       iccm_ecc_corr_index_ff;\n   logic [pt.ICCM_BITS-1:2]                                       iccm_ecc_corr_index_in;\n   logic [38:0]                                                   iccm_ecc_corr_data_ff;\n   logic                                                          dma_sb_err_state;\n   logic                                                          dma_sb_err_state_ff;\n   logic                                                          iccm_rd_ecc_single_err_ff   ;\n   logic                                                          busclk;\n   logic                                                          bus_ifu_bus_clk_en_ff;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                 bus_wren            ;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                 bus_wren_last       ;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                 wren_reset_miss      ;\n   logic                                                          ifc_dma_access_ok_d;\n   logic                                                          ifc_dma_access_ok_prev;\n   logic                                                          ifc_region_acc_fault_memory;\n   logic                                                          ifc_region_acc_okay;\n   logic                                                          ifc_region_acc_fault_memory_f2;\n   logic  [pt.NUM_THREADS-1:0]                                    flush_final_f2;\n\n\n   logic  [pt.ICACHE_STATUS_BITS-1:0]                             way_status;\n   logic  [pt.ICACHE_STATUS_BITS-1:0]                             way_status_rep_new;\n   logic  [pt.ICACHE_STATUS_BITS-1:0]                             way_status_wr;\n   logic  [pt.ICACHE_STATUS_BITS-1:0]                             way_status_up;\n   logic                                                          ifc_region_acc_fault_f2;\n   logic                                                          ifc_region_acc_fault_only_f2;\n   logic  [31:1]                                                  ifu_fetch_addr_int_f2 ;\n   logic                                                          reset_all_tags;\n   logic                                                          reset_all_tags_ff;\n   logic [pt.IFU_BUS_TAG-1:0]                                     ifu_bus_rid_ff;\n   logic                                                          fetch_req_icache_f2;\n   logic                                                          fetch_req_iccm_f2;\n   logic                                                          fetch_uncacheable_ff;\n   logic                                                          ifu_bus_rvalid           ;\n   logic                                                          ifu_bus_rvalid_ff        ;\n   logic                                                          ifu_bus_arvalid_ff        ;\n   logic                                                          ifu_bus_arvalid           ;\n   logic                                                          ifu_bus_miss_thr_ff ;\n   logic                                                          ifu_bus_arready_ff        ;\n   logic                                                          ifu_bus_arready           ;\n   logic [1:0]                                                    ifu_bus_rresp_ff          ;\n   logic                                                          ifu_bus_rsp_valid ;\n   logic                                                          ifu_bus_rsp_ready ;\n   logic [pt.IFU_BUS_TAG-1:0]                                     ifu_bus_rsp_tag;\n   logic [63:0]                                                   ifu_bus_rsp_rdata;\n   logic [1:0]                                                    ifu_bus_rsp_opc;\n   logic                                                          ifu_bus_rsp_tid;\n   logic                                                          iccm_error_start;     // start the error fsm\n   logic                                                          bus_"}
{"text": "ifu_bus_clk_en ;\n   logic                                                          ifu_bus_cmd_valid ;\n   logic                                                          ifu_bus_cmd_ready ;\n   logic                                                          ifc_region_acc_fault_final_f1;\n   logic  [pt.ICACHE_STATUS_BITS-1:0]                             way_status_mb_wr_ff;\n   logic  [pt.ICACHE_STATUS_BITS-1:0]                             way_status_mb_ms_ff;\n   logic  [pt.ICACHE_NUM_WAYS-1:0]                                tagv_mb_wr_ff;\n   logic  [pt.ICACHE_NUM_WAYS-1:0]                                tagv_mb_ms_ff;\n   logic                                                          ifu_byp_data_err_new;\n   logic  [3:0]                                                   ifu_byp_data_err_f2;\n   logic                                                          ifu_wr_cumulative_err_data;\n   logic                                                          ic_act_miss_f2;\n   logic                                                          ic_act_hit_f2;\n   logic                                                          ic_act_hit_f2_ff;\n   logic                                                          ifc_fetch_req_f2;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                 replace_way_mb_wr_any;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                                 replace_way_mb_ms_any;\n   logic                                                          last_beat;\n   logic [31:1]                                                   ifu_ic_rw_int_addr ;\n   logic [79:0]                                                   ic_byp_data_only_new;\n   logic [01:0]                                                   ifu_first_err_addr_2_1_f2;\n   logic                                                          ic_byp_hit_f2 ;\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]              ifu_ic_rw_int_addr_ff ;\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]              ifu_status_wr_addr_ff ;\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]              ifu_status_up_addr_ff ;\n   logic                                                          reset_ic_in ;\n   logic                                                          reset_ic_ff ;\n   logic [31:1]                                                   ifu_status_up_addr;\n   logic [31:1]                                                   ifu_status_wr_addr;\n   logic                                                          iccm_correct_ecc     ;\n   logic                                                          bus_cmd_sent           ;\n   logic                                                          bus_last_data_beat     ;\n   logic                                                          miss_pending     ;\n   logic [31:0]                                                   iccm_corrected_data_f2_mux;\n   logic [06:0]                                                   iccm_corrected_ecc_f2_mux;\n   logic [3:0]                                                    iccm_rd_ecc_double_err_pre;\n\n\n   logic  [63:0]                                                  ic_miss_buff_half;\n\n   logic [pt.NUM_THREADS-1:0]                                     scnd_miss_req_ff2_thr;\n   logic [pt.NUM_THREADS-1:0]                                     scnd_miss_req_thr;\n   logic [pt.NUM_THREADS-1:0]                                     perr_state_wff_thr;\n   logic [1:0]                                                    scnd_miss_req_other_thr;\n   logic                                                          ic_write_stall;\n\n///////// FOR THREADING //////////////////////////\n///////// FOR THREADING //////////////////////////\n///////// FOR THREADING //////////////////////////\n///////// FOR THREADING //////////////////////////\n   logic selected_miss_thr ;\n   logic selected_miss_thr_tmp ;\n   logic bus_thread_en;\n   logic rsp_tid_ff ;\n   logic flush_ic_err_tid ;\n   logic fetch_tid_f2_p1;     // f3 tid\n   logic fetch_tid_f2_p2;     // f4 tid\n\n   logic [2:0]                    iccm_ecc_word_enable;\n   logic                          reset_all_tags_in ;\n   logic [pt.ICACHE_NUM_WAYS-1:0] ic_tag_valid_unq;\n   logic [pt.NUM_THREADS-1:0]     ic_act_miss_f2_thr;\n   logic [pt.NUM_THREADS-1:0]     ic_act_hit_f2_thr;\n   logic [pt.NUM_THREADS-1:0]     ifc_bus_acc_fault_f2_thr;\n   logic [pt.NUM_THREADS-1:0]     bus_cmd_sent_thr;\n   logic [pt.NUM_THREADS-1:0]     miss_pending_thr;\n   logic [pt.NUM_THREADS-1:0]     ifu_pmu_ic_miss_in;               // IC miss event\n   logic [pt.NUM_THREADS-1:0]     ifu_pmu_ic_hit_in;                // IC hit event\n   logic [pt.NUM_THREADS-1:0]     ifu_pmu_bus_error_in;             // Bus error event\n   logic [pt.NUM_THREADS-1:0]     ifu_pmu_bus_busy_in;              // Bus busy event\n   logic [pt.NUM_THREADS-1:0]     ifu_pmu_bus_trxn_in;              // Bus transaction\n\n   logic [pt.NUM_THREADS-1:0] fetch_tid_dec_f1 ;\n   logic [pt.NUM_THREADS-1:0] fetch_tid_dec_f2 ;\n\n   logic [pt.NUM_THREADS-1:0]                                             ic_dma_active_thr;\n   logic [pt.NUM_THREADS-1:0]                                             iccm_stop_fetch_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ic_write_stall_self_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ic_write_stall_other_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ic_rd_en_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ic_real_rd_wp_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ifu_miss_state_idle_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ifu_miss_state_pre_crit_ff_thr;\n   logic [pt.NUM_THREADS-1:0] [pt.ICACHE_NUM_WAYS-1:0]                    ic_wr_en_thr;\n   logic [pt.NUM_THREADS-1:0] [31:3]                                      ifu_ic_req_addr_f2_thr;\n   logic [pt.NUM_THREADS-1:0]                                             reset_tag_valid_for_miss_thr;\n   logic [pt.NUM_THREADS-1:0]  [63:0]                                     ic_miss_buff_half_thr;\n   logic [pt.NUM_THREADS-1:0]                                             sel_byp_data_thr;\n   logic [pt.NUM_THREADS-1:0]                                             sel_ic_data_thr;\n   logic [pt.NUM_THREADS-1:0] [pt.ICACHE_BEAT_BITS-1:0]                   bus_new_rd_addr_count_thr;\n   logic [pt.NUM_THREADS-1:0] [pt.ICACHE_BEAT_BITS-1:0]                   bus_rd_addr_count_thr;\n   logic [pt.NUM_THREADS-1:0] [pt.ICACHE_NUM_WAYS-1:0]                    perr_err_inv_way_thr;\n   logic [pt.NUM_THREADS-1:0] [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] perr_ic_index_ff_thr;\n   logic [pt.NUM_THREADS-1:0]                                             perr_sel_invalidate_thr;\n   logic [pt.NUM_THREADS-1:0]                                             bus_ifu_wr_en_ff_q_thr;\n   logic [pt.NUM_THREADS-1:0]                                             bus_ifu_wr_en_ff_wo_err_thr;\n   logic [pt.NUM_THREADS-1:0]                                             iccm_correction_state_thr;\n   logic [pt.NUM_THREADS-1:0]                                             iccm_corr_scnd_fetch_thr;\n\n   eh2_perr_state_t     [pt.NUM_THREADS-1:0]                             perr_state_thr;\n   eh2_err_stop_state_t [pt.NUM_THREADS-1:0]                              err_stop_state_thr;\n   eh2_err_stop_state_t [pt.NUM_THREADS-1:0]                              err_stop_state_thr_ff;\n   logic [pt.NUM_THREADS-1:0]                                             perr_state_idle_thr;\n\n\n   logic [pt.NUM_THREADS-1:0]  [pt.ICACHE_STATUS_BITS-1:0]                way_status_mb_ff_thr;\n   logic [pt.NUM_THREADS-1:0]  [pt.ICACHE_NUM_WAYS-1:0]                   tagv_mb_ff_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ifu_byp_data_err_new_thr;\n   logic [pt.NUM_THREADS-1:0]  [3:0]                                      ifu_byp_data_err_f2_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ifu_wr_cumulative_err_data_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ic_act_hit_f2_ff_thr;\n   logic [pt.NUM_THREADS-1:0]                                             fetch_f1_f2_c1_clk_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ifc_fetch_req_f2_thr;\n   logic [pt.NUM_THREADS-1:0]                                             last_beat_thr;\n   logic [pt.NUM_THREADS-1:0] [31:1]                                      ifu_ic_rw_int_addr_thr;\n   logic [pt.NUM_THREADS-1:0] [79:0]                                      ic_byp_data_only_new_thr;\n   logic [pt.NUM_THREADS-1:0] [01:0]                                      ifu_first_err_addr_2_1_f2_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ic_byp_hit_f2_thr;\n   logic [pt.NUM_THREADS-1:0]                                             reset_ic_in_thr;\n   logic [pt.NUM_THREADS-1:0]                                             reset_ic_ff_thr;\n   logic [pt.NUM_THREADS-1:0] [31:1]                                      ifu_status_up_addr_thr;\n   logic [pt.NUM_THREADS-1:0] [31:1]                                      ifu_status_wr_addr_thr;\n   logic [pt.NUM_THREADS-1:0]                                             iccm_correct_ecc_thr;\n   logic [pt.NUM_THREADS-1:0]                                             bus_last_data_beat_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ic_hit_f2_thr;\n   logic [pt.NUM_THREADS-1:0]                                             ifu_bus_cmd_valid_thr;\n   logic [pt.NUM_THREADS-1:0]                                             miss_done_thr;\n   logic [pt.NUM_THREADS-1:0]                                             address_match_thr;\n   logic [pt.NUM_THREADS-1:0] [31:1]                                      miss_address_thr;\n\n   logic [1:0]                miss_done_other;\n   logic [1:0]                address_match_other;\n   logic [1:0] [31:1]         miss_address_other;\n\n   logic [1:0]                ifu_bus_cmd_valid_thr_in ;\n   logic [pt.NUM_THREADS-1:0] selected_miss_thr_ff;\n   logic [1:0]                selected_miss_thr_in, rsp_miss_thr;\n   logic                       arbitter_toggle_en;\n   logic                      ic_wr_tid_ff;\n   logic                       ic_reset_tid;\n\n   logic [pt.NUM_THREADS-1:0] [pt.ICCM_BITS-1:2]                          iccm_ecc_corr_index_ff_thr;\n   logic [pt.NUM_THREADS-1:0] [38:0]                                      iccm_ecc_corr_data_ff_thr;\n   logic [pt.NUM_THREADS-1:0]                                             dma_sb_err_state_thr;\n   logic                      flush_err_tid0_wb;\n   logic                      flush_err_tid0_wb1;\n   logic                      flush_err_tid0_wb2;\n   logic                      select_t0_iccm_corr_index;\n\n   logic        perr_state_idle;\n\n   eh2_err_stop_state_t err_stop_state;\n   logic [pt.ICACHE_BEAT_BITS-1:0]                     bus_rd_addr_count ;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                      perr_err_inv_way;\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]   perr_ic_index_ff;\n   logic                                               perr_sel_invalidate;\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]   ifu_tag_miss_addr_f2_p1;         // This is to invalidate the correct index because we saw a miss in F2 1 cycle back\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]   ifu_tag_miss_addr_f2_p2;         // This is to invalidate the correct index because we saw a miss in F2 2 cycle back\n\n   logic [2:0]    iccm_single_ecc_error;\n   logic          dma_iccm_req_f2 ;\n\n   logic ic_rd_en_ff ;\n   logic tag_err_qual_in ;\n   logic tag_err_qual ;\n\n   logic two_byte_instr_f2;\n   logic iccm_dma_active;\n   logic way_status_up_en_ff;\n\n\n\n///////// FOR THREADING //////////////////////////\n///////// FOR THREADING //////////////////////////\n///////// FOR THREADING //////////////////////////\n\n   eh2_perr_state_t perr_state;\n// ---- Clock gating section -----\n// c1 clock enables\n\nassign debug_c1_clken        = ic_debug_rd_en | ic_debug_wr_en ;\n`ifdef RV_FPGA_OPTIMIZE\n   assign debug_c1_clk      = 1'b0;\n`else\n   rvclkhdr debug_c1_cgc         ( .en(debug_c1_clken),          .l1clk(debug_c1_clk), .* );\n`endif\n\n\n\n// ------ end clock gating section ------------------------\n\n   assign iccm_dma_sb_error  = (|iccm_single_ecc_error[2:0] )  & dma_iccm_req_f2 ;\n  if (pt.NUM_THREADS > 1) begin: more_than_1\n   assign ifu_async_error_start[0]                 =  (iccm_rd_ecc_single_err & ~fetch_tid_f2) | ((|ifu_ic_error_start) & ~fetch_tid_f2_p1) ;\n   assign ifu_async_error_start[pt.NUM_THREADS-1]  =  (iccm_rd_ecc_single_err &  fetch_tid_f2) | ((|ifu_ic_error_start) &  fetch_tid_f2_p1) ;\n  end\n  else begin: one_th\n   assign ifu_async_error_start[pt.NUM_THREADS-1]  =  (iccm_rd_ecc_single_err &  ~fetch_tid_f2) | ((|ifu_ic_error_start) &  ~fetch_tid_f2_p1) ;\n end\n\n\n\n   // NOTE: Cacheline size is 16 bytes in this example.\n   // Tag     Index  Bank Offset\n   // [31:16] [15:5] [4]  [3:0]\n\n\n   assign fetch_req_icache_f2   = ifc_fetch_req_f2 & ~ifc_iccm_access_f2 & ~ifc_region_acc_fault_f2;\n   assign fetch_req_iccm_f2     = ifc_fetch_req_f2 &  ifc_iccm_access_f2;\n\n\n\n   rvdffie #(8) bundle1_ff (.*,\n                            .din( {fetch_tid_f1,fetch_tid_f2,   fetch_tid_f2_p1,ifu_bus_rsp_tid,ifc_fetch_uncacheable_f1,ifc_iccm_access_f1,ifc_region_acc_fault_final_f1,ifc_region_acc_fault_f1}),\n                            .dout({fetch_tid_f2,fetch_tid_f2_p1,fetch_tid_f2_p2,rsp_tid_ff,         fetch_uncacheable_ff,ifc_iccm_access_f2,ifc_region_acc_fault_f2,      ifc_region_acc_fault_only_f2})\n                            );\n\n\n   rvdffpcie #(31) ifu_fetch_addr_f2_ff (.*,\n                                         .en(ifc_fetch_req_f1),\n                                         .din ({fetch_addr_f1[31:1]}),\n                                         .dout({ifu_fetch_addr_int_f2[31:1]})\n                                         );\n\n   assign vaddr_f2[pt.ICACHE_BEAT_ADDR_HI:1] = ifu_fetch_addr_int_f2[pt.ICACHE_BEAT_ADDR_HI:1] ;\n\n\n\n\n\n  assign ic_rw_addr[31:1]      = ifu_ic_rw_int_addr[31:1] ;\n\n\nif (pt.ICACHE_ECC == 1) begin: icache_ecc_1\n   logic [6:0]       ic_wr_ecc;\n   logic [6:0]       ic_miss_buff_ecc;\n   logic [141:0]     ic_wr_16bytes_data ;\n   logic [70:0]      ifu_ic_debug_rd_data_in   ;\n\n                rvecc_encode_64  ic_ecc_encode_64_bus (\n                           .din    (ifu_bus_rdata_ff[63:0]),\n                           .ecc_out(ic_wr_ecc[6:0]));\n                rvecc_encode_64  ic_ecc_encode_64_buff (\n                           .din    (ic_miss_buff_half[63:0]),\n                           .ecc_out(ic_miss_buff_ecc[6:0]));\n\n   assign ic_rd_data_only[63:0]= {ic_rd_data[63:0]} ;\n   for (genvar i=0; i < pt.ICACHE_BANKS_WAY ; i++) begin : ic_wr_data_loop\n      assign ic_wr_data[i][70:0]  =  ic_wr_16bytes_data[((71*i)+70): (71*i)];\n   end\n\n\n   assign ic_debug_wr_data[70:0]   = {dec_tlu_ic_diag_pkt.icache_wrdata[70:0]} ;\n\n  rvdff #(($bits(eh2_err_stop_state_t))*(pt.NUM_THREADS)) err_stop_stateff (.*, .clk(active_clk),\n                    .din ( err_stop_state_thr ),\n                    .dout( err_stop_state_thr_ff ));\n\n\n  if (pt.NUM_THREADS > 1) begin: more_than_1_th\n    assign ifu_ic_error_start[pt.NUM_THREADS-1:0]           = {((((|ic_eccerr[pt.ICACHE_BANKS_WAY-1:0]) & ic_act_hit_f2_ff )  | ic_rd_parity_final_err) & ~exu_flush_final[1] & fetch_tid_f2_p1 &  ~perr_state_wff_thr[1] & ~(err_stop_state_thr_ff[1] == 2'b11)) ,\n                                                               ((((|ic_eccerr[pt.ICACHE_BANKS_WAY-1:0]) & ic_act_hit_f2_ff)  | ic_rd_parity_final_err) & ~exu_flush_final[0] & ~fetch_tid_f2_p1 &  ~perr_state_wff_thr[0] & ~(err_stop_state_thr_ff[0] == 2'b11))};\n  end  else begin: one_thr\nassign ifu_ic_error_start[pt.NUM_THREADS-1:0]           = {((((|ic_eccerr[pt.ICACHE_BANKS_WAY-1:0]) & ic_act_hit_f2_ff)  | ic_rd_parity_final_err) ) & ~exu_flush_final[0] & ~perr_state_wff_thr[pt.NUM_THREADS-1:0] & ~(err_stop_state_thr_ff[pt.NUM_THREADS-1] == 2'b11)}   ;\n  end\n\n\n  assign ifu_ic_debug_rd_data_in[70:0] = ic_debug_ict_array_sel_ff ? {2'b0,ictag_debug_rd_data[25:21],32'b0,ictag_debug_rd_data[20:0],{7-pt.ICACHE_STATUS_BITS{1'b0}}, way_status[pt.ICACHE_STATUS_BITS-1:0],3'b0,ic_debug_tag_val_rd_out} :\n                                                                     ic_debug_rd_data[70:0];\n\n  rvdffe #(71) ifu_debug_data_ff (.*,\n                                  .en (debug_data_clken),\n                                  .din ({\n                                         ifu_ic_debug_rd_data_in[70:0]\n                                         }),\n                                  .dout({\n                                         ifu_ic_debug_rd_data[70:0]\n                                         })\n                                  );\n\n\n  assign ic_wr_16bytes_data[141:0] =  ifu_bus_rid_ff[0] ? {ic_wr_ecc[6:0] , ifu_bus_rdata_ff[63:0] ,  ic_miss_buff_ecc[6:0] , ic_miss_buff_half[63:0] } :\n                                                        {ic_miss_buff_ecc[6:0] ,  ic_miss_buff_half[63:0] , ic_wr_ecc[6:0] , ifu_bus_rdata_ff[63:0] } ;\n\n\nend\nelse begin : icache_parity_1\n  logic [3:0]   ic_wr_parity;\n   logic [3:0]   ic_miss_buff_parity;\n   logic [135:0] ic_wr_16bytes_data ;\n   logic [70:0]  ifu_ic_debug_rd_data_in   ;\n    for (genvar i=0 ; i < 4 ; i++) begin : DATA_PGEN\n       rveven_paritygen #(16) par_bus  (.data_in   (ifu_bus_rdata_ff[((16*i)+15):(16*i)]),\n                                      .parity_out(ic_wr_parity[i]));\n       rveven_paritygen #(16) par_buff  (.data_in   (ic_miss_buff_half[((16*i)+15):(16*i)]),\n                                      .parity_out(ic_miss_buff_parity[i]));\n    end\n\n   assign ic_rd_data_only[63:0]  = {ic_rd_data[63:0]} ;\n\n   for (genvar i=0; i < pt.ICACHE_BANKS_WAY ; i++) begin : ic_wr_data_loop\n      assign ic_wr_data[i][70:0]  =  { 3'b0, ic_wr_16bytes_data[((68*i)+67): (68*i)] };\n   end\n\n\n\n\n\n   assign ic_debug_wr_data[70:0]   = {dec_tlu_ic_diag_pkt.icache_wrdata[70:0]} ;\n\n    if (pt.NUM_THREADS > 1) begin: more_than_1_th\n      assign ifu_ic_error_start[pt.NUM_THREADS-1:0]           = {((((|ic_parerr[pt.ICACHE_BANKS_WAY-1:0]) & ic_act_hit_f2_ff)  | ic_rd_parity_final_err) &  fetch_tid_f2_p1) ,\n                                                                 ((((|ic_parerr[pt.ICACHE_BANKS_WAY-1:0]) & ic_act_hit_f2_ff)  | ic_rd_parity_final_err) & ~fetch_tid_f2_p1)};\n    end  else begin: one_thr\n      assign ifu_ic_error_start[pt.NUM_THREADS-1:0]           = {((((|ic_parerr[pt.ICACHE_BANKS_WAY-1:0]) & ic_act_hit_f2_ff)  | ic_rd_parity_final_err) ) }   ;\n    end\n\n   assign ifu_ic_debug_rd_data_in[70:0] = ic_debug_ict_array_sel_ff ? {6'b0,ictag_debug_rd_data[21],32'b0,ictag_debug_rd_data[20:0],{7-pt.ICACHE_STATUS_BITS{1'b0}},way_status[pt.ICACHE_STATUS_BITS-1:0],3'b0,ic_debug_tag_val_rd_out} :\n                                                                      ic_debug_rd_data[70:0] ;\n\n   rvdffe #(71) ifu_debug_data_ff (.*, .en (debug_data_clken),\n                    .din ({\n                           ifu_ic_debug_rd_data_in[70:0]\n                          }),\n                    .dout({\n                           ifu_ic_debug_rd_data[70:0]\n                           }));\n\n   assign ic_wr_16bytes_data[135:0] =  ifu_bus_rid_ff[0] ? {ic_wr_parity[3:0] , ifu_bus_rdata_ff[63:0] ,  ic_miss_buff_parity[3:0] , ic_miss_buff_half[63:0] } :\n                                                        {ic_miss_buff_parity[3:0] ,  ic_miss_buff_half[63:0] , ic_wr_parity[3:0] , ifu_bus_rdata_ff[63:0] } ;\n\nend\n\n\n\n  rvdff #(1) sel_ic_ff (.*, .clk(active_clk), .din({sel_ic_data}), .dout({sel_ic_data_ff}));\n\n if (pt.ICCM_ICACHE==1) begin: iccm_icache\n  assign sel_iccm_data    =  fetch_req_iccm_f2  ;\n\n  assign ic_final_data[63:0]  = ({64{sel_byp_data | sel_iccm_data | sel_ic_data}} & {ic_rd_data_only[63:0]} ) ;\n\n  assign ic_premux_data[63:0] = ({64{sel_byp_data }} & ic_byp_data_only_n"}
{"text": "ew[63:0]) |\n                                ({64{sel_iccm_data}} & iccm_rd_data[63:0]);\n\n  assign ic_sel_premux_data = sel_iccm_data | sel_byp_data ;\n end\n\nif (pt.ICCM_ONLY == 1 ) begin: iccm_only\n  assign sel_iccm_data    =  fetch_req_iccm_f2  ;\n  assign ic_final_data[63:0]  = ({64{sel_byp_data }} & {ic_byp_data_only_new[63:0]} ) |\n                                ({64{sel_iccm_data}} & iccm_rd_data[63:0]);\n  assign ic_premux_data = '0 ;\n  assign ic_sel_premux_data = '0 ;\nend\n\nif (pt.ICACHE_ONLY == 1 ) begin: icache_only\n  assign ic_final_data[63:0]  = ({64{sel_byp_data | sel_ic_data}} & {ic_rd_data_only[63:0]} ) ;\n  assign ic_premux_data[63:0] = ({64{sel_byp_data }} & {ic_byp_data_only_new[63:0]} ) ;\n  assign ic_sel_premux_data =  sel_byp_data ;\nend\n\n\nif (pt.NO_ICCM_NO_ICACHE == 1 ) begin: no_iccm_no_icache\n  assign ic_final_data[63:0]  = ({64{sel_byp_data }} & {ic_byp_data_only_new[63:0]} ) ;\n  assign ic_premux_data = 0 ;\n  assign ic_sel_premux_data = '0 ;\nend\n\n  assign ifc_bus_acc_fault_f2[3:0]   =  {4{ic_byp_hit_f2}} & ifu_byp_data_err_f2[3:0] ;\n  assign ic_data_f2[63:0]       = ic_final_data[63:0];\n\n\nrvdff #(pt.NUM_THREADS) flush_final_ff (.*, .clk(active_clk), .din({exu_flush_final}), .dout({flush_final_f2}));\nassign fetch_req_f2_qual       = ic_hit_f2 & ~exu_flush_final[fetch_tid_f2];\nassign ic_access_fault_f2[3:0]  = ({4{ifc_region_acc_fault_f2}} | ifc_bus_acc_fault_f2[3:0])  & {4{~exu_flush_final[fetch_tid_f2]}};\nassign ic_access_fault_type_f2[1:0] = |iccm_rd_ecc_double_err         ? 2'b01 :\n                                      ifc_region_acc_fault_only_f2   ? 2'b10 :\n                                      ifc_region_acc_fault_memory_f2 ? 2'b11 :  2'b00 ;\n\n\n// right justified\nassign ic_fetch_val_f2[3] = fetch_req_f2_qual & ifu_bp_inst_mask_f2[3] & ~((vaddr_f2[pt.ICACHE_BEAT_ADDR_HI:3] == {pt.ICACHE_BEAT_ADDR_HI-2{1'b1}}) & (vaddr_f2[2:1] != 2'b00)) & (err_stop_state == ERR_STOP_IDLE);\nassign ic_fetch_val_f2[2] = fetch_req_f2_qual & ifu_bp_inst_mask_f2[2] & ~(vaddr_f2[pt.ICACHE_BEAT_ADDR_HI:2]  == {pt.ICACHE_BEAT_ADDR_HI-1{1'b1}}) & (err_stop_state == ERR_STOP_IDLE);\nassign ic_fetch_val_f2[1] = fetch_req_f2_qual & ifu_bp_inst_mask_f2[1] & ~(vaddr_f2[pt.ICACHE_BEAT_ADDR_HI:1]  == {pt.ICACHE_BEAT_ADDR_HI{1'b1}})   & ((err_stop_state == ERR_STOP_IDLE) | (err_stop_state == ERR_FETCH1)) ;\nassign ic_fetch_val_f2[0] = fetch_req_f2_qual & (err_stop_state != ERR_STOP_FETCH);\n\nassign two_byte_instr_f2    =  (ic_data_f2[1:0] != 2'b11 )  ;\n/////////////////////////////////////////////////////////////////////////////////////\n// Parity checking logic for Icache logic.                                         //\n/////////////////////////////////////////////////////////////////////////////////////\n\nassign ic_rd_parity_final_err = ic_tag_perr & sel_ic_data_ff  & tag_err_qual  ; // & ic_rd_en_ff & ifc_fetch_req_f2  & ~(ifc_region_acc_fault_memory_f2 | ifc_region_acc_fault_only_f2) ;\n\nassign tag_err_qual_in = ic_rd_en_ff & ifc_fetch_req_f2  & ~(ifc_region_acc_fault_memory_f2 | ifc_region_acc_fault_only_f2) ;\nassign bus_ifu_bus_clk_en =  ifu_bus_clk_en ;\n\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign busclk = 1'b0;\n`else\n   rvclkhdr bus_clk_f(.en(bus_ifu_bus_clk_en), .l1clk(busclk), .*);\n`endif\n\n\n   rvdff #(1)           bus_clken_ff     (.*, .clk(active_clk), .din(bus_ifu_bus_clk_en), .dout(bus_ifu_bus_clk_en_ff));\n   rvdff #(1)           ic_rd_enff       (.*, .clk(active_clk), .din(ic_rd_en), .dout(ic_rd_en_ff));\n   rvdff #(1)           tag_errq         (.*, .clk(active_clk), .din(tag_err_qual_in), .dout(tag_err_qual));\n\n\n\n    // AXI command signals\n    //  Read Channel\n    assign ifu_axi_arvalid               =  ifu_bus_cmd_valid ;\n    assign ifu_axi_arid[pt.IFU_BUS_TAG-1:0] = (pt.ICACHE_BEAT_BITS == 2) ?  ((pt.IFU_BUS_TAG)'({selected_miss_thr,1'b0, bus_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0]})) & ({pt.IFU_BUS_TAG{ifu_bus_cmd_valid}}):\n                                                                            ((pt.IFU_BUS_TAG)'({selected_miss_thr,bus_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0]})) & ({pt.IFU_BUS_TAG{ifu_bus_cmd_valid}});\n    assign ifu_axi_araddr[31:0]          =   {ifu_ic_req_addr_f2[31:3],3'b0} & {32{ifu_bus_cmd_valid}} ;\n    assign ifu_axi_arsize[2:0]           =  3'b011;\n    assign ifu_axi_arprot[2:0]           = 3'b101;\n    assign ifu_axi_arcache[3:0]          = 4'b1111;\n    assign ifu_axi_arregion[3:0]         = ifu_ic_req_addr_f2[31:28];\n    assign ifu_axi_arlen[7:0]            = '0;\n    assign ifu_axi_arburst[1:0]          = 2'b01;\n    assign ifu_axi_arqos[3:0]            = '0;\n    assign ifu_axi_arlock                = '0;\n    assign ifu_axi_rready                = 1'b1;\n\n    //  Write Channel\n    assign ifu_axi_awvalid                  = '0 ;\n    assign ifu_axi_awid[pt.IFU_BUS_TAG-1:0] = '0 ;\n    assign ifu_axi_awaddr[31:0]             = '0 ;\n    assign ifu_axi_awsize[2:0]              = '0 ;\n    assign ifu_axi_awprot[2:0]              = '0;\n    assign ifu_axi_awcache[3:0]             = '0 ;\n    assign ifu_axi_awregion[3:0]            = '0 ;\n    assign ifu_axi_awlen[7:0]               = '0;\n    assign ifu_axi_awburst[1:0]             = '0 ;\n    assign ifu_axi_awqos[3:0]               = '0;\n    assign ifu_axi_awlock                   = '0;\n\n    assign ifu_axi_wvalid                =  '0;\n    assign ifu_axi_wstrb[7:0]            =  '0;\n    assign ifu_axi_wdata[63:0]           =  '0;\n    assign ifu_axi_wlast                 =  '0;\n    assign ifu_axi_bready                =  '0;\n\n\n\n   assign ifu_bus_arready_unq       =   ifu_axi_arready ;\n   assign ifu_bus_arvalid           =   ifu_axi_arvalid ;\n   rvdff_fpga #(1)               bus_rdy_ff      (.*, .clk(busclk),  .clken(bus_ifu_bus_clk_en), .rawclk(clk), .din(ifu_bus_arready_unq),            .dout(ifu_bus_arready_unq_ff));\n   rvdff_fpga #(1)               bus_rsp_vld_ff  (.*, .clk(busclk),  .clken(bus_ifu_bus_clk_en), .rawclk(clk), .din(ifu_axi_rvalid),                 .dout(ifu_bus_rvalid_unq_ff));\n   rvdff_fpga #(1)               bus_cmd_ff      (.*, .clk(busclk),  .clken(bus_ifu_bus_clk_en), .rawclk(clk), .din(ifu_bus_arvalid),                .dout(ifu_bus_arvalid_ff));\n   rvdff_fpga #(2)               bus_rsp_cmd_ff  (.*, .clk(busclk),  .clken(bus_ifu_bus_clk_en), .rawclk(clk), .din(ifu_axi_rresp[1:0]),             .dout(ifu_bus_rresp_ff[1:0]));\n   rvdff_fpga #(pt.IFU_BUS_TAG)  bus_rsp_tag_ff  (.*, .clk(busclk),  .clken(bus_ifu_bus_clk_en), .rawclk(clk), .din(ifu_axi_rid[pt.IFU_BUS_TAG-1:0]),.dout(ifu_bus_rid_ff[pt.IFU_BUS_TAG-1:0]));\n   rvdffe #(64)                  bus_data_ff     (.*, .clk(clk),     .din(ifu_axi_rdata[63:0]),            .dout(ifu_bus_rdata_ff[63:0]), .en(ifu_bus_clk_en & ifu_axi_rvalid));\n\n   assign ifu_bus_cmd_ready = ifu_axi_arready ;\n   assign ifu_bus_rsp_valid = ifu_axi_rvalid ;\n   assign ifu_bus_rsp_ready = ifu_axi_rready ;\n   assign ifu_bus_rsp_tag[pt.IFU_BUS_TAG-1:0] = ifu_axi_rid[pt.IFU_BUS_TAG-1:0] ;\n   assign ifu_bus_rsp_rdata[63:0] = ifu_axi_rdata[63:0] ;\n   assign ifu_bus_rsp_opc[1:0] = {ifu_axi_rresp[1:0]} ;\n   assign ifu_bus_rsp_tid  = ifu_bus_rsp_tag[pt.IFU_BUS_TAG-1] & ifu_bus_rsp_valid;\n\n\n\n   assign ifu_bus_rvalid            =  ifu_bus_rsp_valid       & bus_ifu_bus_clk_en ;\n\n   assign ifu_bus_arready_ff         =  ifu_bus_arready_unq_ff & bus_ifu_bus_clk_en_ff ;\n   assign ifu_bus_arready            =  ifu_bus_arready_unq    & bus_ifu_bus_clk_en    ;\n\n   assign ifu_bus_rvalid_ff          =  ifu_bus_rvalid_unq_ff  & bus_ifu_bus_clk_en_ff ;\n\n// DMA\n   // Making sure that the dma_access is allowed when we have 2 back to back dma_access_ok. Also gating with current state == idle\n   assign ifc_dma_access_ok_d  = ifc_dma_access_ok &  ~iccm_correct_ecc & ~iccm_dma_sb_error;\n   assign ifc_dma_access_q_ok  = ifc_dma_access_ok &  ~iccm_correct_ecc & ifc_dma_access_ok_prev &  perr_state_idle  & ~iccm_dma_sb_error;\n   assign iccm_ready           = ifc_dma_access_q_ok ;\n   rvdff #(1)  dma_req_ff      (.*, .clk(active_clk), .din (dma_iccm_req),       .dout(dma_iccm_req_f2));\n   rvdff #(1)  dma_ok_prev_ff  (.*, .clk(active_clk), .din(ifc_dma_access_ok_d), .dout(ifc_dma_access_ok_prev));\n\n    if (pt.ICCM_ENABLE == 1 ) begin: iccm_enabled\n         logic  [31:0] dma_mem_addr_ff  ;\n         logic  iccm_dma_rden    ;\n\n         logic  ic_dma_active_in;\n         logic  iccm_dma_ecc_error_in;\n         logic  [13:0] dma_mem_ecc;\n         logic  [63:0] iccm_dma_rdata_in;\n         logic  [31:0] iccm_dma_rdata_1_muxed;\n         logic [2:0] [31:0] iccm_corrected_data;\n         logic [2:0] [06:0] iccm_corrected_ecc;\n         logic [2:0]   dma_mem_tag_ff;\n\n         logic [3:0]        iccm_double_ecc_error;\n\n\n         logic [pt.ICCM_BITS-1:2]       iccm_rw_addr_f2;\n\n         logic              iccm_dma_rvalid_in;\n         logic [116:0]      iccm_rdmux_data;\n         logic [1:0]        dma_mem_sz_ff;\n\n\n        logic [5:0] ic_fetch_val_int_f2;\n        logic [5:0] ic_fetch_val_shift_right;\n        logic [2:0] iccm_dma_rd_en;\n\n\n\n         assign ic_dma_active_in   =  ifc_dma_access_q_ok  & dma_iccm_req ;\n         assign iccm_wren          =  (ifc_dma_access_q_ok & dma_iccm_req &  dma_mem_write) | iccm_correct_ecc;\n         assign iccm_rden          =  (ifc_dma_access_q_ok & dma_iccm_req & ~dma_mem_write) | (ifc_iccm_access_f1 & ifc_fetch_req_f1);\n         assign iccm_dma_rden      =  (ifc_dma_access_q_ok & dma_iccm_req & ~dma_mem_write)                     ;\n         assign iccm_wr_size[2:0]  =  {3{dma_iccm_req}}    & dma_mem_sz[2:0] ;\n\n         rvecc_encode  iccm_ecc_encode0 (\n                           .din(dma_mem_wdata[31:0]),\n                           .ecc_out(dma_mem_ecc[6:0]));\n\n         rvecc_encode  iccm_ecc_encode1 (\n                           .din(dma_mem_wdata[63:32]),\n                           .ecc_out(dma_mem_ecc[13:7]));\n\n        assign iccm_wr_data[77:0]   =  (iccm_correct_ecc & ~(ifc_dma_access_q_ok & dma_iccm_req)) ?  {iccm_ecc_corr_data_ff[38:0], iccm_ecc_corr_data_ff[38:0]} :\n                                       {dma_mem_ecc[13:7],dma_mem_wdata[63:32], dma_mem_ecc[6:0],dma_mem_wdata[31:0]};\n\n         assign iccm_dma_rdata_1_muxed[31:0] = dma_mem_addr_ff[2] ?  iccm_corrected_data[0][31:0] : iccm_corrected_data[1][31:0] ;\n         assign iccm_dma_rdata_in[63:0]      = iccm_dma_ecc_error_in ? {2{dma_mem_addr_ff[31:0]}} : {iccm_dma_rdata_1_muxed[31:0], iccm_corrected_data[0]};\n         assign iccm_dma_ecc_error_in   =   |(iccm_double_ecc_error[1:0]);\n\n         rvdff #(3)           dma_tag_ff1      (.*, .clk(active_clk), .din(dma_mem_tag[2:0]),        .dout(dma_mem_tag_ff[2:0]));\n         rvdff #(3)           dma_tag_ff2      (.*, .clk(active_clk), .din(dma_mem_tag_ff[2:0]),     .dout(iccm_dma_rtag[2:0]));\n         rvdff #(1)           ccm_rdy_in_ff    (.*, .clk(active_clk), .din(iccm_dma_rden),           .dout(iccm_dma_rvalid_in));\n         rvdff #(2)           ccm_sz_ff        (.*, .clk(active_clk), .din(dma_mem_sz[1:0]),         .dout(dma_mem_sz_ff[1:0]));\n         rvdff #(1)           ccm_rdy_ff       (.*, .clk(active_clk), .din(iccm_dma_rvalid_in),      .dout(iccm_dma_rvalid));\n         rvdff #(1)           ccm_err_ff       (.*, .clk(active_clk), .din(iccm_dma_ecc_error_in),   .dout(iccm_dma_ecc_error));\n         rvdff #(1)           dma_active_ff    (.*, .clk(active_clk), .din(ic_dma_active_in),        .dout(iccm_dma_active));\n\n         rvdffe #(32)         dma_addr_ff      (.*, .din(dma_mem_addr[31:0]),      .dout(dma_mem_addr_ff[31:0]), .en(dma_iccm_req));\n         rvdffe #(64)         dma_data_ff      (.*, .din(iccm_dma_rdata_in[63:0]), .dout(iccm_dma_rdata[63:0]), .en(dma_iccm_req_f2));\n\n         assign iccm_rw_addr[pt.ICCM_BITS-1:1]    = (  ifc_dma_access_q_ok & dma_iccm_req  & ~iccm_correct_ecc) ? dma_mem_addr[pt.ICCM_BITS-1:1] :\n                                                 (~(ifc_dma_access_q_ok & dma_iccm_req) &  iccm_correct_ecc) ? {iccm_ecc_corr_index_ff[pt.ICCM_BITS-1:2],1'b0} : fetch_addr_f1[pt.ICCM_BITS-1:1] ;\n\n\n\n\n/////////////////////////////////////////////////////////////////////////////////////\n// ECC checking logic for ICCM data.                                               //\n/////////////////////////////////////////////////////////////////////////////////////\n\n  assign ic_fetch_val_int_f2[5:0]      = {2'b00, ic_fetch_val_f2[3:0]};\n  assign ic_fetch_val_shift_right[5:0] = {ic_fetch_val_int_f2 << ifu_fetch_addr_int_f2[1] } ;\n  assign iccm_dma_rd_en[2:0]           = ({1'b0 , (dma_mem_sz_ff[1:0] == 2'b11) , 1'b1 } & {3{iccm_dma_rvalid_in}}) ;\n\n   assign iccm_rdmux_data[116:0] = iccm_rd_data_ecc[116:0];\n   for (genvar i=0; i < 3 ; i++) begin : ICCM_ECC_CHECK\n      assign iccm_ecc_word_enable[i] = ((|ic_fetch_val_shift_right[(2*i+1):(2*i)] & ~exu_flush_final[fetch_tid_f2] & sel_iccm_data) | iccm_dma_rd_en[i]) & ~dec_tlu_core_ecc_disable;\n   rvecc_decode  ecc_decode (\n                           .en(iccm_ecc_word_enable[i]),\n                           .sed_ded ( 1'b0 ),    // 1 : means only detection\n                           .din(iccm_rdmux_data[(39*i+31):(39*i)]),\n                           .ecc_in(iccm_rdmux_data[(39*i+38):(39*i+32)]),\n                           .dout(iccm_corrected_data[i][31:0]),\n                           .ecc_out(iccm_corrected_ecc[i][6:0]),\n                           .single_ecc_error(iccm_single_ecc_error[i]),\n                           .double_ecc_error(iccm_double_ecc_error[i]));\n  end\n    assign iccm_rd_ecc_single_err  = (|iccm_single_ecc_error[2:0]) & ifc_iccm_access_f2 & ifc_fetch_req_f2;\n  if (pt.NUM_THREADS > 1) begin: more_than_1_th\n    assign ifu_iccm_rd_ecc_single_err[pt.NUM_THREADS-1:0]  = {((|iccm_single_ecc_error[2:0]) & ifc_iccm_access_f2 & ifc_fetch_req_f2 &  fetch_tid_f2),\n                                                              ((|iccm_single_ecc_error[2:0]) & ifc_iccm_access_f2 & ifc_fetch_req_f2 & ~fetch_tid_f2)};\n  end  else begin: one_thr\n    assign ifu_iccm_rd_ecc_single_err[pt.NUM_THREADS-1:0]  = ((|iccm_single_ecc_error[2:0]) & ifc_iccm_access_f2 & ifc_fetch_req_f2 );\n  end\n\n  assign iccm_rd_ecc_double_err_pre [2:0] = iccm_double_ecc_error[2:0]  & {3{ifc_iccm_access_f2}};\n\n  assign iccm_rd_ecc_double_err[3:0]  =   ~ifu_fetch_addr_int_f2[1]  ?   {iccm_rd_ecc_double_err_pre[1], iccm_rd_ecc_double_err_pre[1], iccm_rd_ecc_double_err_pre[0], iccm_rd_ecc_double_err_pre[0]}  :\n                                                                         {iccm_rd_ecc_double_err_pre[2], iccm_rd_ecc_double_err_pre[1], iccm_rd_ecc_double_err_pre[1], iccm_rd_ecc_double_err_pre[0]}  ;\n\n\n\n  assign iccm_corrected_data_f2_mux[31:0] = iccm_single_ecc_error[0] ? iccm_corrected_data[0] : iccm_single_ecc_error[1] ? iccm_corrected_data[1] : iccm_corrected_data[2];\n  assign iccm_corrected_ecc_f2_mux[6:0]   = iccm_single_ecc_error[0] ? iccm_corrected_ecc[0]  : iccm_single_ecc_error[1] ? iccm_corrected_ecc[1]  : iccm_corrected_ecc[2];\n\n  assign iccm_error_start                =  iccm_rd_ecc_single_err;\n  assign iccm_ecc_corr_index_in[pt.ICCM_BITS-1:2] = iccm_single_ecc_error[0] ? iccm_rw_addr_f2[pt.ICCM_BITS-1:2] : iccm_single_ecc_error[1] ? (iccm_rw_addr_f2[pt.ICCM_BITS-1:2] + 1'b1) : (iccm_rw_addr_f2[pt.ICCM_BITS-1:2] + 2'b10);\n\n   rvdff #(pt.ICCM_BITS-2)   iccm_index_f2 (.*, .clk(active_clk), .din(iccm_rw_addr[pt.ICCM_BITS-1:2]),           .dout(iccm_rw_addr_f2[pt.ICCM_BITS-1:2]));\n\n\n     end else begin : iccm_disabled\n         assign iccm_dma_rvalid = 1'b0 ;\n         assign iccm_dma_ecc_error = 1'b0 ;\n         assign iccm_dma_rdata[63:0] = '0 ;\n         assign iccm_single_ecc_error = '0 ;\n         assign iccm_dma_rtag[2:0] = '0;\n\n         assign iccm_rd_ecc_single_err                   = 1'b0 ;\n         assign ifu_iccm_rd_ecc_single_err               =  '0;\n         assign iccm_rd_ecc_double_err[3:0]                   = '0 ;\n         assign iccm_rd_ecc_single_err_ff                = 1'b0 ;\n         assign iccm_error_start                         = 1'b0;\n         assign iccm_ecc_corr_index_in[pt.ICCM_BITS-1:2] = '0;\n         assign iccm_corrected_data_f2_mux[31:0]         = '0;\n         assign iccm_corrected_ecc_f2_mux[6:0]           = '0;\n\n    end\n\n   assign reset_all_tags_in =  |dec_tlu_fence_i_wb[pt.NUM_THREADS-1:0] ;\n   rvdff #(1) reset_all_tag_ff  (.*, .clk(active_clk),  .din(reset_all_tags_in), .dout(reset_all_tags));\n   rvdff #(1) reset_all_tag_ff2 (.*, .clk(active_clk),  .din(reset_all_tags),    .dout(reset_all_tags_ff));\n\n///////////////////////////////////////////////////////////////\n// Icache status and LRU\n///////////////////////////////////////////////////////////////\nif (pt.ICACHE_ENABLE == 1 ) begin: icache_enabled\n   logic [(pt.ICACHE_TAG_DEPTH/8)-1 : 0] way_status_clken;\n   logic [(pt.ICACHE_TAG_DEPTH/8)-1 : 0] way_status_clk;\n   logic [pt.ICACHE_NUM_WAYS-1:0] [pt.ICACHE_TAG_DEPTH-1:0]      ic_tag_valid_out ;\n   logic [(pt.ICACHE_TAG_DEPTH/32)-1:0] [pt.ICACHE_NUM_WAYS-1:0] tag_valid_clken ;\n   logic [(pt.ICACHE_TAG_DEPTH/32)-1:0] [pt.ICACHE_NUM_WAYS-1:0] tag_valid_clk   ;\n   assign  ic_valid  = ~ifu_wr_cumulative_err_data & ~(reset_ic_in | reset_ic_ff | reset_all_tags | reset_all_tags_ff) ;\n\n   assign ifu_status_wr_addr_w_debug[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] = ((ic_debug_rd_en | ic_debug_wr_en ) & ic_debug_tag_array) ?\n                                                                           ic_debug_addr[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] :\n                                                                           ifu_status_wr_addr[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO];\n\n    // need to flop the index for the tag that missed\n    rvdff #(pt.ICACHE_INDEX_HI - pt.ICACHE_TAG_INDEX_LO + 1) ifu_tag_miss_addr_f2_p2_ff (.*,\n                                                                              .clk (active_clk),\n                                                                              .din (ifu_tag_miss_addr_f2_p1[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]),\n                                                                              .dout(ifu_tag_miss_addr_f2_p2[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]));\n\n\n   // status\n         rvdff #(pt.ICACHE_TAG_LO-pt.ICACHE_TAG_INDEX_LO) status_wr_addr_ff (.*,  .clk(active_clk), .din(ifu_status_wr_addr_w_debug[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]),\n                   .dout(ifu_status_wr_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]));\n\n         rvdff #(pt.ICACHE_TAG_LO-pt.ICACHE_TAG_INDEX_LO) status_up_addr_ff (.*,  .clk(active_clk), .din(ifu_status_up_addr[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]),\n                   .dout(ifu_status_up_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]));\n\n         assign way_status_wr_en_w_debug = way_status_wr_en | (ic_debug_wr_en  & ic_debug_tag_array);\n         rvdff #(1) status_wren_ff (.*, .clk(active_clk),  .din(way_status_wr_en_w_debug), .dout(way_status_wr_en_ff));\n         rvdff #(1) status_upen_ff (.*, .clk(active_clk),  .din(way_status_up_en), .dout(way_status_up_en_ff));\n\n         assign way_status_wr_w_debug[pt.ICACHE_STATUS_BITS-1:0]  = (ic_debug_wr_en  & ic_debug_tag_array) ? (pt.ICACHE_STATUS_BITS == 1) ? ic_debug_wr_data[4] : ic_debug_wr_data[6:4] :\n                                                way_status_wr[pt.ICACHE_STATUS_BITS-1:0] ;\n         rvdff #(pt.ICACHE_STATUS_BITS) status_wr_data_ff (.*,  .clk(active_clk), .din(way_status_wr_w_debug[pt.ICACHE_STATUS_BITS-1:0]), .dout(way_status_wr_ff[pt.ICACHE_STATUS_BITS-1:0]));\n         rvdff #(pt.ICACHE_STATUS_BITS) status_up_data_ff (.*,  .clk(active_clk), .din(way_status_up[pt.ICACHE_STATUS_BITS-1:0]), .dout(way_status_up_ff[pt.ICACHE_STATUS_BITS-1:0]));\n\n\n   for (genvar i=0 ; i<pt.ICACHE_TAG_DEPTH/8 ; i++) begin : CLK_GRP_WAY_STATUS\n      assign way_status_clken[i] = ( (ifu_status_wr_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO+3] == i && way_status_wr_en_ff) |\n                                     (ifu_status_up_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO+3] == i && way_status_up_en_ff) ) ;\n\n   `ifdef RV_FPGA_OPTIMIZE\n      assign way_status_clk[i] = 1'b0;\n   `else\n      rvcl"}
{"text": "khdr way_status_cgc ( .en(way_status_clken[i]),   .l1clk(way_status_clk[i]), .* );\n   `endif\n\n      for (genvar j=0 ; j<8 ; j++) begin : WAY_STATUS\n         rvdffs_fpga #(pt.ICACHE_STATUS_BITS) ic_way_status (.*,\n                   .clk(way_status_clk[i]),\n                   .clken(way_status_clken[i]),\n                   .rawclk(clk),\n                   .en( ((ifu_status_wr_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] == (j | i<<3)) & way_status_wr_en_ff) |\n                        ((ifu_status_up_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] == (j | i<<3)) & way_status_up_en_ff)),\n                   .din(((ifu_status_wr_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] == (j | i<<3)) & way_status_wr_en_ff) ?\n                                     way_status_wr_ff[pt.ICACHE_STATUS_BITS-1:0] :\n                                     way_status_up_ff[pt.ICACHE_STATUS_BITS-1:0]),\n                   .dout(way_status_out[8*i+j]));\n      end  // WAY_STATUS\n   end  // CLK_GRP_WAY_STATUS\n\n  always_comb begin : way_status_out_mux\n      way_status[pt.ICACHE_STATUS_BITS-1:0] = '0 ;\n      for (int j=0; j< pt.ICACHE_TAG_DEPTH; j++) begin : status_mux_loop\n        if (ifu_ic_rw_int_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] == (pt.ICACHE_TAG_LO-pt.ICACHE_TAG_INDEX_LO)'(j)) begin : mux_out\n         way_status[pt.ICACHE_STATUS_BITS-1:0] =  way_status_out[j];\n        end\n      end\n  end\n\n   assign ifu_ic_rw_int_addr_w_debug[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] = ((ic_debug_rd_en | ic_debug_wr_en ) & ic_debug_tag_array) ?\n                                                                        ic_debug_addr[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] :\n                                                                        ifu_ic_rw_int_addr[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO];\n\n         rvdff #(pt.ICACHE_NUM_WAYS) miss_way_ff (.*,\n                                                  .clk(active_clk),\n                                                  .din (wren_reset_miss  [pt.ICACHE_NUM_WAYS-1:0]),\n                                                  .dout(ifu_tag_miss_wren[pt.ICACHE_NUM_WAYS-1:0]));\n\n\n         rvdff #(pt.ICACHE_TAG_LO-pt.ICACHE_TAG_INDEX_LO) tag_addr_ff (.*, .clk(active_clk),\n                   .din(ifu_ic_rw_int_addr_w_debug[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]),\n                   .dout(ifu_ic_rw_int_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]));\n\n         assign ifu_tag_wren_w_debug[pt.ICACHE_NUM_WAYS-1:0] = ifu_tag_wren[pt.ICACHE_NUM_WAYS-1:0] | ic_debug_tag_wr_en[pt.ICACHE_NUM_WAYS-1:0] ;\n\n         rvdff #(pt.ICACHE_NUM_WAYS) tag_v_we_ff (.*, .clk(active_clk),\n                   .din (ifu_tag_wren_w_debug[pt.ICACHE_NUM_WAYS-1:0]),\n                   .dout(ifu_tag_wren_ff[pt.ICACHE_NUM_WAYS-1:0]));\n\n         assign ic_valid_w_debug = (ic_debug_wr_en & ic_debug_tag_array) ? ic_debug_wr_data[0] : ic_valid;\n\n         rvdff #(1) tag_v_ff (.*, .clk(active_clk),\n                   .din(ic_valid_w_debug),\n                   .dout(ic_valid_ff));\n\n\n   for (genvar i=0 ; i<pt.ICACHE_TAG_DEPTH/32 ; i++) begin : CLK_GRP_TAG_VALID\n      for (genvar j=0; j<pt.ICACHE_NUM_WAYS; j++) begin : way_clken\n      if (pt.ICACHE_TAG_DEPTH == 32 ) begin\n        assign tag_valid_clken[i][j] =  ifu_tag_wren_ff[j] | perr_err_inv_way[j] | ifu_tag_miss_wren[j] | reset_all_tags;\n      end else begin\n         assign tag_valid_clken[i][j] = (((ifu_ic_rw_int_addr_ff [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO+5] == i ) &  ifu_tag_wren_ff[j] )     |                  // filling this index\n                                        ((perr_ic_index_ff       [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO+5] == i ) &  perr_err_inv_way[j])     |                  // error in this index\n                                        ((ifu_tag_miss_addr_f2_p2[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO+5] == i ) &  ifu_tag_miss_wren[j])    | reset_all_tags); // miss on this index or reset\n      end\n\n     `ifdef RV_FPGA_OPTIMIZE\n        assign tag_valid_clk[i][j] = 1'b0;\n     `else\n      rvclkhdr way_status_cgc ( .en(tag_valid_clken[i][j]),   .l1clk(tag_valid_clk[i][j]), .* );\n     `endif\n\n\n      for (genvar k=0 ; k<32 ; k++) begin : TAG_VALID\n         rvdffsc_fpga #(1) ic_way_tagvalid_dup (.*,\n                   .clk(tag_valid_clk[i][j]),\n                   .clken(tag_valid_clken[i][j]),\n                   .rawclk(clk),\n                   .en   (((ifu_ic_rw_int_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]   == (k + 32*i)) & ifu_tag_wren_ff[j] )),            // only when we are filling\n                   .clear(((perr_ic_index_ff     [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]   == (k + 32*i)) & perr_err_inv_way[j])    |         // parity errors need to clear the tag valid\n                          ((ifu_tag_miss_addr_f2_p2[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] == (k + 32*i)) & ifu_tag_miss_wren[j])   |         // tag miss needs to clear the tag valid\n                          reset_all_tags),                                                                                                          // reset_all tags\n                   .din  (ic_valid_ff ),\n                   .dout (ic_tag_valid_out[j][32*i+k]));\n      end\n      end\n   end\n\n\n  always_comb begin : tag_valid_out_mux\n      ic_tag_valid_unq[pt.ICACHE_NUM_WAYS-1:0] = '0;\n      for (int j=0; j< pt.ICACHE_TAG_DEPTH; j++) begin : tag_valid_loop\n        if (ifu_ic_rw_int_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] == (pt.ICACHE_TAG_LO-pt.ICACHE_TAG_INDEX_LO)'(j)) begin : valid_out\n           for ( int k=0; k<pt.ICACHE_NUM_WAYS; k++) begin\n             ic_tag_valid_unq[k] |= ic_tag_valid_out[k][j];\n        end\n      end\n      end\n  end\n//   four-way set associative - three bits\n//   each bit represents one branch point in a binary decision tree; let 1\n//   represent that the left side has been referenced more recently than the\n//   right side, and 0 vice-versa\n//\n//              are all 4 ways valid?\n//                   /       \\\n//                  |        no, use an invalid way.\n//                  |\n//                  |\n//             bit_0 == 0?             state | replace      ref to | next state\n//               /       \\             ------+--------      -------+-----------\n//              y         n             x00  |  way_0      way_0 |    _11\n//             /           \\            x10  |  way_1      way_1 |    _01\n//      bit_1 == 0?    bit_2 == 0?      0x1  |  way_2      way_2 |    1_0\n//        /    \\          /    \\        1x1  |  way_3      way_3 |    0_0\n//       y      n        y      n\n//      /        \\      /        \\        ('x' means don't care       ('_' means unchanged)\n//    way_0    way_1  way_2     way_3      don't care)\n\n   if (pt.ICACHE_NUM_WAYS == 4) begin: four_way_plru\n   assign replace_way_mb_wr_any[3] = ( way_status_mb_wr_ff[2]  & way_status_mb_wr_ff[0] & (&tagv_mb_wr_ff[3:0])) |\n                                  (~tagv_mb_wr_ff[3]& tagv_mb_wr_ff[2] &  tagv_mb_wr_ff[1] &  tagv_mb_wr_ff[0]) ;\n   assign replace_way_mb_wr_any[2] = (~way_status_mb_wr_ff[2]  & way_status_mb_wr_ff[0] & (&tagv_mb_wr_ff[3:0])) |\n                                  (~tagv_mb_wr_ff[2]& tagv_mb_wr_ff[1] &  tagv_mb_wr_ff[0]) ;\n   assign replace_way_mb_wr_any[1] = ( way_status_mb_wr_ff[1] & ~way_status_mb_wr_ff[0] & (&tagv_mb_wr_ff[3:0])) |\n                                  (~tagv_mb_wr_ff[1]& tagv_mb_wr_ff[0] ) ;\n   assign replace_way_mb_wr_any[0] = (~way_status_mb_wr_ff[1] & ~way_status_mb_wr_ff[0] & (&tagv_mb_wr_ff[3:0])) |\n                                  (~tagv_mb_wr_ff[0] ) ;\n\n   assign replace_way_mb_ms_any[3] = ( way_status_mb_ms_ff[2]  & way_status_mb_ms_ff[0] & (&tagv_mb_ms_ff[3:0])) |\n                                  (~tagv_mb_ms_ff[3]& tagv_mb_ms_ff[2] &  tagv_mb_ms_ff[1] &  tagv_mb_ms_ff[0]) ;\n   assign replace_way_mb_ms_any[2] = (~way_status_mb_ms_ff[2]  & way_status_mb_ms_ff[0] & (&tagv_mb_ms_ff[3:0])) |\n                                  (~tagv_mb_ms_ff[2]& tagv_mb_ms_ff[1] &  tagv_mb_ms_ff[0]) ;\n   assign replace_way_mb_ms_any[1] = ( way_status_mb_ms_ff[1] & ~way_status_mb_ms_ff[0] & (&tagv_mb_ms_ff[3:0])) |\n                                  (~tagv_mb_ms_ff[1]& tagv_mb_ms_ff[0] ) ;\n   assign replace_way_mb_ms_any[0] = (~way_status_mb_ms_ff[1] & ~way_status_mb_ms_ff[0] & (&tagv_mb_ms_ff[3:0])) |\n                                  (~tagv_mb_ms_ff[0] ) ;\n\n   assign way_status_hit_new[pt.ICACHE_STATUS_BITS-1:0] = ({3{ic_rd_hit[0]}} & {way_status[2] , 1'b1 , 1'b1}) |\n                                   ({3{ic_rd_hit[1]}} & {way_status[2] , 1'b0 , 1'b1}) |\n                                   ({3{ic_rd_hit[2]}} & {1'b1 ,way_status[1]  , 1'b0}) |\n                                   ({3{ic_rd_hit[3]}} & {1'b0 ,way_status[1]  , 1'b0}) ;\n\n  assign way_status_rep_new[pt.ICACHE_STATUS_BITS-1:0] = ({3{replace_way_mb_wr_any[0]}} & {way_status_mb_wr_ff[2] , 1'b1 , 1'b1}) |\n                                   ({3{replace_way_mb_wr_any[1]}} & {way_status_mb_wr_ff[2] , 1'b0 , 1'b1}) |\n                                   ({3{replace_way_mb_wr_any[2]}} & {1'b1 ,way_status_mb_wr_ff[1]  , 1'b0}) |\n                                   ({3{replace_way_mb_wr_any[3]}} & {1'b0 ,way_status_mb_wr_ff[1]  , 1'b0}) ;\n  end\n   else begin : two_ways_plru\n      assign replace_way_mb_wr_any[0]                      = (~way_status_mb_wr_ff  & tagv_mb_wr_ff[0] & tagv_mb_wr_ff[1]) | ~tagv_mb_wr_ff[0];\n      assign replace_way_mb_wr_any[1]                      = ( way_status_mb_wr_ff  & tagv_mb_wr_ff[0] & tagv_mb_wr_ff[1]) | ~tagv_mb_wr_ff[1] & tagv_mb_wr_ff[0];\n\n      assign replace_way_mb_ms_any[0]                      = (~way_status_mb_ms_ff  & tagv_mb_ms_ff[0] & tagv_mb_ms_ff[1]) | ~tagv_mb_ms_ff[0];\n      assign replace_way_mb_ms_any[1]                      = ( way_status_mb_ms_ff  & tagv_mb_ms_ff[0] & tagv_mb_ms_ff[1]) | ~tagv_mb_ms_ff[1] & tagv_mb_ms_ff[0];\n\n      assign way_status_hit_new[pt.ICACHE_STATUS_BITS-1:0] = ic_rd_hit[0];\n      assign way_status_rep_new[pt.ICACHE_STATUS_BITS-1:0] = replace_way_mb_wr_any[0];\n\n   end\n\n  // Make sure to select the way_status_hit_new even when in hit_under_miss.\n  assign way_status_wr[pt.ICACHE_STATUS_BITS-1:0]     = (bus_ifu_wr_en_ff_q  & last_beat)  ? way_status_rep_new[pt.ICACHE_STATUS_BITS-1:0] :\n                                                          way_status_hit_new[pt.ICACHE_STATUS_BITS-1:0] ;\n\n  assign way_status_up[pt.ICACHE_STATUS_BITS-1:0]     = way_status_hit_new[pt.ICACHE_STATUS_BITS-1:0] ;\n\n\n  assign way_status_wr_en  = (bus_ifu_wr_en_ff_q  & last_beat)  ;\n  assign way_status_up_en  =  ic_act_hit_f2;\n\n   for (genvar i=0; i<pt.ICACHE_NUM_WAYS; i++) begin  : bus_wren_loop\n      assign bus_wren[i]           = bus_ifu_wr_en_ff_q & replace_way_mb_wr_any[i] & miss_pending ;\n      assign bus_wren_last[i]      = bus_ifu_wr_en_ff_wo_err & replace_way_mb_wr_any[i] & miss_pending & bus_last_data_beat;\n      assign ifu_tag_wren[i]       = bus_wren_last[i];                                                                           // Only for tag writes when there is a fill\n      assign wren_reset_miss[i]    = replace_way_mb_ms_any[i] & reset_tag_valid_for_miss ;\n\n   end\n   assign bus_ic_wr_en[pt.ICACHE_NUM_WAYS-1:0] = bus_wren[pt.ICACHE_NUM_WAYS-1:0];\n\n\nend else begin: icache_disabled\n   assign ic_tag_valid_unq[pt.ICACHE_NUM_WAYS-1:0]         = '0;\n   assign way_status[pt.ICACHE_STATUS_BITS-1:0]            = '0;\n   assign replace_way_mb_wr_any[pt.ICACHE_NUM_WAYS-1:0]    = '0;\n   assign replace_way_mb_ms_any[pt.ICACHE_NUM_WAYS-1:0]    = '0;\n   assign way_status_hit_new[pt.ICACHE_STATUS_BITS-1:0]    = '0;\n   assign way_status_rep_new[pt.ICACHE_STATUS_BITS-1:0]    = '0;\n   assign way_status_wr[pt.ICACHE_STATUS_BITS-1:0]         = '0;\n   assign way_status_up[pt.ICACHE_STATUS_BITS-1:0]         = '0;\n   assign way_status_up_en                                 = '0;\n   assign way_status_wr_en                                 = '0;\n   assign bus_wren[pt.ICACHE_NUM_WAYS-1:0]                 = '0;\nend\n\n\n   assign ic_tag_valid[pt.ICACHE_NUM_WAYS-1:0] = ic_tag_valid_unq[pt.ICACHE_NUM_WAYS-1:0]   & {pt.ICACHE_NUM_WAYS{(~fetch_uncacheable_ff & ifc_fetch_req_f2) }} ;\n   assign ic_debug_tag_val_rd_out           = |(ic_tag_valid_unq[pt.ICACHE_NUM_WAYS-1:0] &  ic_debug_way_ff[pt.ICACHE_NUM_WAYS-1:0]   & {pt.ICACHE_NUM_WAYS{ic_debug_rd_en_ff}}) ;\n///////////////////////////////////////////\n// PMU signals\n///////////////////////////////////////////\n\n assign ifu_pmu_ic_miss_in   = ic_act_miss_f2_thr[pt.NUM_THREADS-1:0] ;\n assign ifu_pmu_ic_hit_in    = ic_act_hit_f2_thr[pt.NUM_THREADS-1:0]  ;\n assign ifu_pmu_bus_error_in = ifc_bus_acc_fault_f2_thr[pt.NUM_THREADS-1:0];\n assign ifu_pmu_bus_trxn_in  = bus_cmd_sent_thr[pt.NUM_THREADS-1:0] ;\n assign ifu_pmu_bus_busy_in  = {pt.NUM_THREADS{ifu_bus_arvalid_ff & ~ifu_bus_arready_ff}} & miss_pending_thr[pt.NUM_THREADS-1:0] ;\n\n   rvdff #(5*pt.NUM_THREADS) ifu_pmu_sigs_ff (.*,\n                    .clk (active_clk),\n                    .din ({ifu_pmu_ic_miss_in[pt.NUM_THREADS-1:0],\n                           ifu_pmu_ic_hit_in[pt.NUM_THREADS-1:0],\n                           ifu_pmu_bus_error_in[pt.NUM_THREADS-1:0],\n                           ifu_pmu_bus_busy_in[pt.NUM_THREADS-1:0],\n                           ifu_pmu_bus_trxn_in[pt.NUM_THREADS-1:0]\n                          }),\n                    .dout({ifu_pmu_ic_miss[pt.NUM_THREADS-1:0],\n                           ifu_pmu_ic_hit[pt.NUM_THREADS-1:0],\n                           ifu_pmu_bus_error[pt.NUM_THREADS-1:0],\n                           ifu_pmu_bus_busy[pt.NUM_THREADS-1:0],\n                           ifu_pmu_bus_trxn[pt.NUM_THREADS-1:0]\n                           }));\n\n\n///////////////////////////////////////////////////////\n// Cache debug logic                                 //\n///////////////////////////////////////////////////////\nassign ic_debug_addr[pt.ICACHE_INDEX_HI:3] = dec_tlu_ic_diag_pkt.icache_dicawics[pt.ICACHE_INDEX_HI-3:0] ;\nassign ic_debug_way_enc[01:00]             = dec_tlu_ic_diag_pkt.icache_dicawics[15:14] ;\n\n\nassign ic_debug_tag_array       = dec_tlu_ic_diag_pkt.icache_dicawics[16] ;\nassign ic_debug_rd_en           = dec_tlu_ic_diag_pkt.icache_rd_valid ;\nassign ic_debug_wr_en           = dec_tlu_ic_diag_pkt.icache_wr_valid ;\n\n\nassign ic_debug_way[pt.ICACHE_NUM_WAYS-1:0]        = {(ic_debug_way_enc[1:0] == 2'b11),\n                                                      (ic_debug_way_enc[1:0] == 2'b10),\n                                                      (ic_debug_way_enc[1:0] == 2'b01),\n                                                      (ic_debug_way_enc[1:0] == 2'b00) };\n\nassign ic_debug_tag_wr_en[pt.ICACHE_NUM_WAYS-1:0] = {pt.ICACHE_NUM_WAYS{ic_debug_wr_en & ic_debug_tag_array}} & ic_debug_way[pt.ICACHE_NUM_WAYS-1:0] ;\n\nassign ic_debug_ict_array_sel_in      =  ic_debug_rd_en & ic_debug_tag_array ;\n\nrvdff_fpga #(01+pt.ICACHE_NUM_WAYS) ifu_debug_sel_ff (.*, .clk (debug_c1_clk),\n                    .clken(debug_c1_clken), .rawclk(clk),\n                    .din ({ic_debug_ict_array_sel_in,\n                           ic_debug_way[pt.ICACHE_NUM_WAYS-1:0]\n                          }),\n                    .dout({ic_debug_ict_array_sel_ff,\n                           ic_debug_way_ff[pt.ICACHE_NUM_WAYS-1:0]\n                           }));\n\n\nrvdff #(1) ifu_debug_rd_en_ff (.*,.clk(active_clk),\n                    .din ({\n                           ic_debug_rd_en\n                          }),\n                    .dout({\n                           ic_debug_rd_en_ff\n                           }));\n\n\nassign debug_data_clken  =  ic_debug_rd_en_ff;\nrvdff #(1) ifu_debug_valid_ff (.*, .clk(active_clk),\n                    .din ({\n                           ic_debug_rd_en_ff\n                          }),\n                    .dout({\n                           ifu_ic_debug_rd_data_valid\n                           }));\n\n\n\n// memory protection  - equation to look identical to the LSU equation\n   assign ifc_region_acc_okay = (~(|{pt.INST_ACCESS_ENABLE0,pt.INST_ACCESS_ENABLE1,pt.INST_ACCESS_ENABLE2,pt.INST_ACCESS_ENABLE3,pt.INST_ACCESS_ENABLE4,pt.INST_ACCESS_ENABLE5,pt.INST_ACCESS_ENABLE6,pt.INST_ACCESS_ENABLE7})) |\n                               (pt.INST_ACCESS_ENABLE0 & (({fetch_addr_f1[31:1],1'b0} | pt.INST_ACCESS_MASK0)) == (pt.INST_ACCESS_ADDR0 | pt.INST_ACCESS_MASK0)) |\n                               (pt.INST_ACCESS_ENABLE1 & (({fetch_addr_f1[31:1],1'b0} | pt.INST_ACCESS_MASK1)) == (pt.INST_ACCESS_ADDR1 | pt.INST_ACCESS_MASK1)) |\n                               (pt.INST_ACCESS_ENABLE2 & (({fetch_addr_f1[31:1],1'b0} | pt.INST_ACCESS_MASK2)) == (pt.INST_ACCESS_ADDR2 | pt.INST_ACCESS_MASK2)) |\n                               (pt.INST_ACCESS_ENABLE3 & (({fetch_addr_f1[31:1],1'b0} | pt.INST_ACCESS_MASK3)) == (pt.INST_ACCESS_ADDR3 | pt.INST_ACCESS_MASK3)) |\n                               (pt.INST_ACCESS_ENABLE4 & (({fetch_addr_f1[31:1],1'b0} | pt.INST_ACCESS_MASK4)) == (pt.INST_ACCESS_ADDR4 | pt.INST_ACCESS_MASK4)) |\n                               (pt.INST_ACCESS_ENABLE5 & (({fetch_addr_f1[31:1],1'b0} | pt.INST_ACCESS_MASK5)) == (pt.INST_ACCESS_ADDR5 | pt.INST_ACCESS_MASK5)) |\n                               (pt.INST_ACCESS_ENABLE6 & (({fetch_addr_f1[31:1],1'b0} | pt.INST_ACCESS_MASK6)) == (pt.INST_ACCESS_ADDR6 | pt.INST_ACCESS_MASK6)) |\n                               (pt.INST_ACCESS_ENABLE7 & (({fetch_addr_f1[31:1],1'b0} | pt.INST_ACCESS_MASK7)) == (pt.INST_ACCESS_ADDR7 | pt.INST_ACCESS_MASK7));\n\n   assign ifc_region_acc_fault_memory   =  ~ifc_iccm_access_f1 & ~ifc_region_acc_okay & ifc_fetch_req_f1;\n\n   assign ifc_region_acc_fault_final_f1 = ifc_region_acc_fault_f1 | ifc_region_acc_fault_memory;\n\n   rvdff #(1) region_acc_mem_ff (.*,.clk(active_clk),\n                    .din ({\n                           ifc_region_acc_fault_memory\n                          }),\n                    .dout({\n                           ifc_region_acc_fault_memory_f2\n                           }));\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////// THREADING  SIGNALS //////////////////////////////////////////\n///////////////////////////////////// THREADING  SIGNALS //////////////////////////////////////////\n///////////////////////////////////// THREADING  SIGNALS //////////////////////////////////////////\n///////////////////////////////////// THREADING  SIGNALS //////////////////////////////////////////\n///////////////////////////////////// THREADING  SIGNALS //////////////////////////////////////////\n///////////////////////////////////// THREADING  SIGNALS //////////////////////////////////////////\n///////////////////////////////////// THREADING  SIGNALS //////////////////////////////////////////\n///////////////////////////////////// THREADING  SIGNALS //////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nassign  fetch_tid_dec_f1[pt.NUM_THREADS-1:0] = {fetch_tid_f1,~fetch_tid_f1};\nassign  fetch_tid_dec_f2[pt.NUM_THREADS-1:0] = {fetch_tid_f2,~fetch_tid_f2};\n\n\n\n  if (pt.NUM_THREADS > 1) begin: mt1t\n   assign ic_reset_tid   =  ((fetch_tid_f2_p1 & ~scnd_miss_req_ff2_thr[0] & ~ifu_miss_state_pre_crit_ff_thr[0]) |\n                             (scnd_miss_req_ff2_thr[pt.NUM_THREADS-1]     & ~ifu_miss_state_pre_crit_ff_thr[0]) |\n                              ifu_miss_state_pre_crit_ff_thr[pt.NUM_THREADS-1]);\n    assign  ic_write_stall_thr[pt.NUM_THREADS-1:0]   =   { (ic_write_stall_self_thr[1] | ic_write_stall_other_thr[0]) , (ic_write_stall_self_thr[0] | ic_write_stall_other_thr[1] ) } ;\n  end else begin : onet\n   assign ic_reset_tid   = 1'b0 ;\n    assign  ic_write_stall_thr[pt.NUM_THREADS-1:0]   =   ic_write_stall_self_thr[pt.NUM_THREADS-1:0]   ;\n  end\n\n   assign ifu_bus_cmd_valid_thr_in[1:0] = (pt.NUM_THREADS==1) ? {1'b0 , ifu_bus_cmd_valid_thr[0]} : ifu_bus_cmd_valid_thr[pt.NUM_THREADS-1:0];\n   assign miss_done_other[1:0]      "}
{"text": "    = (pt.NUM_THREADS==1) ? 2'b11                             : {miss_done_thr[0],     miss_done_thr[pt.NUM_THREADS-1]};\n   assign address_match_other[1:0]      = (pt.NUM_THREADS==1) ? 2'b0                              : {address_match_thr[0], address_match_thr[pt.NUM_THREADS-1]};\n   assign miss_address_other[1:0]       = (pt.NUM_THREADS==1) ? '0                                : {miss_address_thr[0],  miss_address_thr[pt.NUM_THREADS-1]};\n   assign selected_miss_thr_in[1:0]     = (pt.NUM_THREADS==1) ? 2'b11                             : {selected_miss_thr, ~selected_miss_thr};\n   assign rsp_miss_thr[1:0]             = (pt.NUM_THREADS==1) ? 2'b11                             : {ifu_bus_rid_ff[pt.IFU_BUS_TAG-1], ~ifu_bus_rid_ff[pt.IFU_BUS_TAG-1]};\n   assign flush_err_tid0_wb             = dec_tlu_flush_err_wb[0]  ;\n   assign scnd_miss_req_other_thr[1:0]  = (pt.NUM_THREADS==1) ? 2'b00                             : {scnd_miss_req_thr[0], scnd_miss_req_thr[pt.NUM_THREADS-1]};\n   rvdff #(1) err_tid_wb1 (.*,.clk(active_clk),\n                               .din ( flush_err_tid0_wb      ),\n                               .dout( flush_err_tid0_wb1      ));\n\n   rvdff #(1) err_tid_wb2 (.*,.clk(active_clk),\n                               .din ( flush_err_tid0_wb1      ),\n                               .dout( flush_err_tid0_wb2      ));\n\n   assign arbitter_toggle_en            = ifu_bus_arready_unq & bus_ifu_bus_clk_en;\n   assign ic_wr_tid_ff                  = ic_write_stall ? rsp_tid_ff : fetch_tid_f1;\n\n   rvarbiter2_fpga miss_thr_arb (.*,\n                         .ready (ifu_bus_cmd_valid_thr_in[1:0]),\n                         .shift (arbitter_toggle_en),\n                         .clk   (busclk),\n                         .clken (bus_ifu_bus_clk_en),\n                         .rawclk (clk),\n                         .tid   (selected_miss_thr_tmp));     // This needs to be updated only based on the thread being accepted\n\n   assign bus_thread_en = arbitter_toggle_en |  (ifu_bus_cmd_valid_thr_in[1] ^ ifu_bus_cmd_valid_thr_in[0]);\n\n   rvdffs_fpga #(1) miss_thread_bus (.clk(busclk),  .clken(bus_ifu_bus_clk_en), .rawclk(clk),  .din(selected_miss_thr_tmp), .dout(selected_miss_thr), .en(bus_thread_en),   .*);\n\n\n  assign ifu_miss_state_idle                                        =     ifu_miss_state_idle_thr;\n\n    assign  ic_dma_active                                                 =     |ic_dma_active_thr;\n    assign  iccm_stop_fetch                                               =     |iccm_stop_fetch_thr;\n\n    assign  ic_write_stall                                                =     |ic_write_stall_other_thr;\n\n    assign  ic_rd_en                                                      =     ic_rd_en_thr[fetch_tid_f1];\n    assign  reset_tag_valid_for_miss                                      =     reset_tag_valid_for_miss_thr[ic_reset_tid];\n\n    assign  ic_wr_en[pt.ICACHE_NUM_WAYS-1:0]                              =     ic_wr_en_thr[rsp_tid_ff][pt.ICACHE_NUM_WAYS-1:0];\n    assign  ifu_bus_cmd_valid                                             =     ifu_bus_cmd_valid_thr[selected_miss_thr]  ;\n    assign  bus_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0]                    =     bus_rd_addr_count_thr[selected_miss_thr];\n\n    assign  ifu_ic_req_addr_f2[31:3]                                      =     ifu_ic_req_addr_f2_thr[selected_miss_thr];\n    assign  ic_miss_buff_half[63:0]                                       =     ic_miss_buff_half_thr[rsp_tid_ff];\n    assign  sel_byp_data                                                  =     sel_byp_data_thr[fetch_tid_f2];\n    assign  sel_ic_data                                                   =     sel_ic_data_thr[fetch_tid_f2];\n    assign  miss_pending                                                  =     miss_pending_thr[rsp_tid_ff];\n\n    assign  perr_err_inv_way[pt.ICACHE_NUM_WAYS-1:0]                      =     perr_err_inv_way_thr[flush_ic_err_tid][pt.ICACHE_NUM_WAYS-1:0];\n    assign  perr_ic_index_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]   =     perr_ic_index_ff_thr[flush_ic_err_tid][pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO];\n    assign  ifu_tag_miss_addr_f2_p1[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]  =    ifu_ic_rw_int_addr_thr[ic_reset_tid][pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO];\n    assign  perr_sel_invalidate                                           =     perr_sel_invalidate_thr[flush_ic_err_tid];\n    assign  bus_ifu_wr_en_ff_q                                            =     bus_ifu_wr_en_ff_q_thr[rsp_tid_ff];\n    assign  bus_ifu_wr_en_ff_wo_err                                       =     bus_ifu_wr_en_ff_wo_err_thr[rsp_tid_ff];\n    assign  iccm_correction_state                                         =     iccm_correction_state_thr[fetch_tid_f1];\n    assign  iccm_corr_scnd_fetch                                          =     iccm_corr_scnd_fetch_thr[fetch_tid_f1];\n    assign  perr_state                                                    =     perr_state_thr[fetch_tid_f1] ;\n    assign  perr_state_idle                                               =     &perr_state_idle_thr ;\n    assign  err_stop_state                                                =     err_stop_state_thr[fetch_tid_f2]     ;\n\n\n    assign  way_status_mb_wr_ff[pt.ICACHE_STATUS_BITS-1:0]                =     way_status_mb_ff_thr[rsp_tid_ff][pt.ICACHE_STATUS_BITS-1:0];\n    assign  way_status_mb_ms_ff[pt.ICACHE_STATUS_BITS-1:0]                =     way_status_mb_ff_thr[ic_reset_tid][pt.ICACHE_STATUS_BITS-1:0];\n    assign  tagv_mb_wr_ff[pt.ICACHE_NUM_WAYS-1:0]                         =     tagv_mb_ff_thr[rsp_tid_ff][pt.ICACHE_NUM_WAYS-1:0];\n    assign  tagv_mb_ms_ff[pt.ICACHE_NUM_WAYS-1:0]                         =     tagv_mb_ff_thr[ic_reset_tid][pt.ICACHE_NUM_WAYS-1:0];\n\n    assign  ifu_byp_data_err_new                                          =     ifu_byp_data_err_new_thr[fetch_tid_f2];\n    assign  ifu_byp_data_err_f2                                           =     ifu_byp_data_err_f2_thr[fetch_tid_f2];\n    assign  ifu_wr_cumulative_err_data                                    =     ifu_wr_cumulative_err_data_thr[rsp_tid_ff];\n    assign  ic_act_hit_f2                                                 =     ic_act_hit_f2_thr[fetch_tid_f2];\n    assign  ic_act_hit_f2_ff                                              =     ic_act_hit_f2_ff_thr[fetch_tid_f2_p1];\n    assign  ifc_fetch_req_f2                                              =     ifc_fetch_req_f2_thr[fetch_tid_f2];\n    assign  last_beat                                                     =     last_beat_thr[rsp_tid_ff];\n    assign  ifu_ic_rw_int_addr [31:1]                                     =     ifu_ic_rw_int_addr_thr[ic_wr_tid_ff][31:1];\n    assign  ic_byp_data_only_new[79:0]                                    =     ic_byp_data_only_new_thr[fetch_tid_f2][79:0];\n    assign  ifu_first_err_addr_2_1_f2[1:0]                                =     ifu_first_err_addr_2_1_f2_thr[fetch_tid_f2][1:0];\n    assign  ic_byp_hit_f2                                                 =     ic_byp_hit_f2_thr[fetch_tid_f2];\n    assign  reset_ic_in                                                   =     reset_ic_in_thr[rsp_tid_ff];\n    assign  reset_ic_ff                                                   =     reset_ic_ff_thr[rsp_tid_ff];\n\n    assign  bus_cmd_sent                                                  =     bus_cmd_sent_thr[selected_miss_thr];\n    assign  bus_last_data_beat                                            =     bus_last_data_beat_thr[rsp_tid_ff];\n    assign  ic_hit_f2                                                     =     ic_hit_f2_thr[fetch_tid_f2];\n    assign  ic_act_miss_f2                                                =     ic_act_miss_f2_thr[fetch_tid_f2];\n\n  assign ifc_bus_acc_fault_f2_thr[pt.NUM_THREADS-1:0]   =  ic_byp_hit_f2_thr[pt.NUM_THREADS-1:0] & ifu_byp_data_err_new_thr[pt.NUM_THREADS-1:0] ;\n\n    assign  ifu_status_up_addr[31:1]                                      =     ifu_status_up_addr_thr[fetch_tid_f2][31:1];\n    assign  ifu_status_wr_addr[31:1]                                      =     ifu_status_wr_addr_thr[rsp_tid_ff][31:1];\n    assign  iccm_correct_ecc                                              =     |iccm_correct_ecc_thr[pt.NUM_THREADS-1:0];\n    assign flush_ic_err_tid =  (pt.NUM_THREADS > 1) &  dec_tlu_flush_err_wb[pt.NUM_THREADS-1] &  perr_state_wff_thr[pt.NUM_THREADS-1]  ;\n\n    assign  select_t0_iccm_corr_index                                     =     flush_err_tid0_wb1 & iccm_correct_ecc_thr[0] ;\n    assign  iccm_ecc_corr_index_ff[pt.ICCM_BITS-1:2]                      =     dma_sb_err_state_ff ?  iccm_ecc_corr_index_ff_thr[fetch_tid_f2_p2] : select_t0_iccm_corr_index ? iccm_ecc_corr_index_ff_thr[0] :\n                                                                                                                                                                                 iccm_ecc_corr_index_ff_thr[pt.NUM_THREADS-1];\n    assign  iccm_ecc_corr_data_ff[38:0]                                   =     dma_sb_err_state_ff ?  iccm_ecc_corr_data_ff_thr [fetch_tid_f2_p2] : select_t0_iccm_corr_index ? iccm_ecc_corr_data_ff_thr[0]:\n                                                                                                                                                                       iccm_ecc_corr_data_ff_thr[pt.NUM_THREADS-1];\n    assign  dma_sb_err_state                                              =     dma_sb_err_state_thr[fetch_tid_f2_p1];\n   rvdff #(1)  sb_err_ff    (.*, .clk(active_clk), .din (dma_sb_err_state), .dout(dma_sb_err_state_ff));\n\n\n   rvdff #(pt.NUM_THREADS)  select_miss_thr_ff    (.*, .clk(active_clk), .din (selected_miss_thr_in[pt.NUM_THREADS-1:0]), .dout(selected_miss_thr_ff[pt.NUM_THREADS-1:0]));\n\n\n for (genvar i=0 ;  i < pt.NUM_THREADS ; i++) begin : THREADS\n    eh2_ifu_mem_ctl_thr #(.pt(pt))  ifu_mem_ctl_thr_inst (.*,\n   .tid                                         (1'(i)),\n   .scan_mode                                   ( scan_mode ) ,\n   .clk                                         ( active_thread_l2clk[i] ) ,\n   .rst_l                                       ( rst_l ) ,\n   .ifu_bus_clk_en                              ( ifu_bus_clk_en ) ,\n\n   .fetch_tid_f1                                ( fetch_tid_dec_f1[i]),\n   .fetch_tid_f2                                ( fetch_tid_dec_f2[i]),\n   .dec_tlu_flush_err_wb                        ( dec_tlu_flush_err_wb[i] ) ,\n   .dec_tlu_force_halt                          ( dec_tlu_force_halt[i] ) ,\n   .dec_tlu_flush_lower_wb                      ( dec_tlu_flush_lower_wb[i] ) ,\n   .exu_flush_final                             ( exu_flush_final[i] ) ,\n   .flush_final_f2                              ( flush_final_f2[i]) ,\n   .two_byte_instr_f2                           ( two_byte_instr_f2) ,\n\n   .ifu_bp_kill_next_f2                         ( ifu_bp_kill_next_f2 ) ,\n   .ifc_fetch_req_f1                            ( ifc_fetch_req_f1 ) ,\n   .ifc_fetch_req_f1_raw                        ( ifc_fetch_req_f1_raw ) ,\n   .ifc_fetch_uncacheable_f1                    ( ifc_fetch_uncacheable_f1 ) ,\n   .ic_rd_hit                                   ( ic_rd_hit ) ,\n   .fetch_addr_f1                               ( fetch_addr_f1 ) ,\n   .iccm_dma_sb_error                           ( iccm_dma_sb_error ) ,\n   .ic_error_start                              ( ifu_ic_error_start[i] ) ,\n   .dec_tlu_i0_commit_cmt                       ( dec_tlu_i0_commit_cmt[i] ) ,\n   .ifu_fetch_val                               ( ifu_fetch_val[1:0] ) ,\n   .ifc_iccm_access_f1                          ( ifc_iccm_access_f1 ) ,\n   .dec_tlu_fence_i_wb                          ( dec_tlu_fence_i_wb[i] ) ,\n   .bus_ic_wr_en                                ( bus_ic_wr_en ) ,\n\n   .scnd_miss_req_other                         ( scnd_miss_req_other_thr[i] ),    // This is other guys output and this thread's input\n   .address_match_other                         ( address_match_other[i]),         //  Primary miss address for the other thread\n   .miss_address_other                          ( miss_address_other[i]),          //  Primary miss address for the other thread\n   .miss_done_other                             ( miss_done_other[i]),             //  Primary miss done\n   .way_status                                  ( way_status ) ,\n   .way_status_rep_new                          ( way_status_rep_new ) ,\n   .ifc_region_acc_fault_f2                     ( ifc_region_acc_fault_f2 ) ,\n   .ifu_fetch_addr_int_f2                       ( ifu_fetch_addr_int_f2 ) ,\n   .reset_all_tags                              ( reset_all_tags ) ,\n   .ifu_bus_rid_ff                              ( ifu_bus_rid_ff ) ,\n   .fetch_req_icache_f2                         ( fetch_req_icache_f2 ) ,\n   .fetch_req_iccm_f2                           ( fetch_req_iccm_f2 ) ,\n   .ifu_bus_rvalid                              ( ifu_bus_rvalid ) ,\n   .ifu_bus_rvalid_ff                           ( ifu_bus_rvalid_ff ) ,\n   .ifu_bus_arvalid_ff                          ( ifu_bus_arvalid_ff ) ,\n   .ifu_bus_arvalid                             ( ifu_bus_arvalid    ) ,\n   .ifu_bus_arready                             ( ifu_bus_arready    ) ,\n   .ifu_bus_rresp_ff                            ( ifu_bus_rresp_ff ) ,\n   .ifu_selected_miss_thr                       ( selected_miss_thr_in[i] ),\n   .rsp_miss_thr_ff                             ( rsp_miss_thr[i] ),\n   .ifu_bus_rsp_valid                           ( ifu_bus_rsp_valid ) ,\n   .ifu_bus_rsp_ready                           ( ifu_bus_rsp_ready ) ,\n   .ifu_bus_rsp_tag                             ( ifu_bus_rsp_tag ) ,\n   .ifu_bus_rsp_rdata                           ( ifu_bus_rsp_rdata ) ,\n   .ifu_bus_rsp_opc                             ( ifu_bus_rsp_opc ) ,\n   .iccm_error_start                            ( iccm_error_start ) ,\n   .bus_ifu_bus_clk_en                          ( bus_ifu_bus_clk_en ) ,\n   .ifu_bus_cmd_ready                           ( ifu_bus_cmd_ready ) ,\n   .ifc_region_acc_fault_final_f1               ( ifc_region_acc_fault_final_f1 ) ,\n   .ic_tag_valid                                ( ic_tag_valid ) ,\n   .replace_way_mb_any                          ( replace_way_mb_wr_any ) ,\n   .ifu_ic_rw_int_addr_ff                       ( ifu_ic_rw_int_addr_ff ) ,\n   .iccm_ecc_corr_index_in                      ( iccm_ecc_corr_index_in ) ,\n   .iccm_corrected_data_f2_mux                  (iccm_corrected_data_f2_mux),\n   .iccm_corrected_ecc_f2_mux                   (iccm_corrected_ecc_f2_mux),\n\n// outputs\n   .iccm_ecc_corr_index_ff                      (iccm_ecc_corr_index_ff_thr[i]),\n   .iccm_ecc_corr_data_ff                       (iccm_ecc_corr_data_ff_thr[i]),\n   .dma_sb_err_state                            (dma_sb_err_state_thr[i]),\n\n   .miss_done                                   ( miss_done_thr[i] ) ,\n   .address_match                               ( address_match_thr[i] ) ,\n   .miss_address                                ( miss_address_thr[i]),          //  Primary miss address for the other thread\n   .ifu_bus_cmd_valid                           ( ifu_bus_cmd_valid_thr[i] ) ,\n   .iccm_buf_correct_ecc                        ( iccm_buf_correct_ecc_thr[i] ) ,\n   .ifu_ic_mb_empty                             ( ifu_ic_mb_empty_thr[i] ) ,\n   .ic_dma_active                               ( ic_dma_active_thr[i] ) ,\n   .iccm_stop_fetch                             ( iccm_stop_fetch_thr[i] ) ,\n   .ic_write_stall_self                         ( ic_write_stall_self_thr[i] ) ,\n   .ic_write_stall_other                        ( ic_write_stall_other_thr[i] ) ,\n   .ic_rd_en                                    ( ic_rd_en_thr[i] ) ,\n   .ic_real_rd_wp                               ( ic_real_rd_wp_thr[i] ) ,\n   .ifu_miss_state_idle                         ( ifu_miss_state_idle_thr[i] ) ,\n   .ifu_miss_state_pre_crit_ff                  ( ifu_miss_state_pre_crit_ff_thr[i] ) ,\n   .ic_crit_wd_rdy                              ( ic_crit_wd_rdy_thr[i]   ) ,\n   .ic_wr_en                                    ( ic_wr_en_thr[i] ) ,\n   .ifu_ic_req_addr_f2                          ( ifu_ic_req_addr_f2_thr[i] ) ,\n   .reset_tag_valid_for_miss                    ( reset_tag_valid_for_miss_thr[i] ) ,\n   .ic_miss_buff_half                           ( ic_miss_buff_half_thr[i] ) ,\n   .sel_byp_data                                ( sel_byp_data_thr[i] ) ,\n   .sel_ic_data                                 ( sel_ic_data_thr[i] ) ,\n   .miss_pending                                ( miss_pending_thr[i] ) ,\n   .bus_rd_addr_count                           ( bus_rd_addr_count_thr[i] ) ,\n   .perr_err_inv_way                            ( perr_err_inv_way_thr[i] ) ,\n   .perr_ic_index_ff                            ( perr_ic_index_ff_thr[i] ) ,\n   .perr_sel_invalidate                         ( perr_sel_invalidate_thr[i] ) ,\n   .bus_ifu_wr_en_ff_q                          ( bus_ifu_wr_en_ff_q_thr[i] ) ,\n   .bus_ifu_wr_en_ff_wo_err                     ( bus_ifu_wr_en_ff_wo_err_thr[i] ) ,\n   .iccm_correction_state                       ( iccm_correction_state_thr[i] ) ,\n   .iccm_corr_scnd_fetch                        ( iccm_corr_scnd_fetch_thr[i] ) ,\n\n   .perr_state                                  ( perr_state_thr[i] ) ,\n   .perr_state_idle                             ( perr_state_idle_thr[i] ) ,\n   .perr_state_wff                              ( perr_state_wff_thr[i] ) ,\n   .err_stop_state                              ( err_stop_state_thr[i] ) ,\n\n   .scnd_miss_req_ff2                           ( scnd_miss_req_ff2_thr[i] ),\n   .scnd_miss_req                               ( scnd_miss_req_thr[i] ),         // This is my output\n   .way_status_mb_ff                            ( way_status_mb_ff_thr[i] ) ,\n   .tagv_mb_ff                                  ( tagv_mb_ff_thr[i] ) ,\n   .ifu_byp_data_err_new                        ( ifu_byp_data_err_new_thr[i] ) ,\n   .ifu_byp_data_err_f2                         ( ifu_byp_data_err_f2_thr[i] ) ,\n   .ifu_wr_cumulative_err_data                  ( ifu_wr_cumulative_err_data_thr[i] ) ,\n   .ic_act_hit_f2                               ( ic_act_hit_f2_thr[i] ) ,\n   .ic_act_hit_f2_ff                            ( ic_act_hit_f2_ff_thr[i] ) ,\n   .ifc_fetch_req_f2                            ( ifc_fetch_req_f2_thr[i] ) ,\n   .last_beat                                   ( last_beat_thr[i] ) ,\n   .ifu_ic_rw_int_addr                          ( ifu_ic_rw_int_addr_thr[i]  ) ,\n   .ic_byp_data_only_new                        ( ic_byp_data_only_new_thr[i] ) ,\n   .ifu_first_err_addr_2_1_f2                   ( ifu_first_err_addr_2_1_f2_thr[i] ) ,\n   .ic_byp_hit_f2                               ( ic_byp_hit_f2_thr[i]  ) ,\n   .reset_ic_in                                 ( reset_ic_in_thr[i]  ) ,\n   .reset_ic_ff                                 ( reset_ic_ff_thr[i]  ) ,\n   .ifu_status_up_addr                          ( ifu_status_up_addr_thr[i] ) ,\n   .ifu_status_wr_addr                          ( ifu_status_wr_addr_thr[i] ) ,\n   .iccm_correct_ecc                            ( iccm_correct_ecc_thr[i] ) ,\n   .bus_cmd_sent                                ( bus_cmd_sent_thr[i] ) ,\n   .bus_last_data_beat                          ( bus_last_data_beat_thr[i] ) ,\n   .ic_hit_f2                                   ( ic_hit_f2_thr[i] ) ,\n   .ic_act_miss_f2                              ( ic_act_miss_f2_thr[i])\n\n\n);\n\nend // THREADS\n\n\nendmodule  // eh2_ifu_mem_ctl\n\n\n\nmodule eh2_ifu_mem_ctl_thr\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n )\n  (\n    input logic                                 tid,\n    input logic                                 scan_mode ,\n    input logic                                clk,\n    input logic rst_l,\n    input logic busclk,\n    input logic ifu_bus_clk_en,\n\n   input logic                                   fetch_tid_f1,                  //\n   input logic                                   fetch_tid_f2,                  //\n   input logic                                   ifu_bp_"}
{"text": "kill_next_f2,           // Branch is predicted taken. Kill the fetch next cycle.\n   input logic                                   ifc_fetch_req_f1,              //\n   input logic                                   ifc_fetch_req_f1_raw,          //\n   input logic                                   exu_flush_final    ,           //\n   input  logic                                  flush_final_f2,         //\n   input  logic                                  two_byte_instr_f2,         //\n   input logic                                   ifc_fetch_uncacheable_f1,      //\n   input logic [pt.ICACHE_NUM_WAYS-1:0]          ic_rd_hit,          // Compare hits from Icache tags. Per way.  F2 stage\n   input logic [31:1]                            fetch_addr_f1,                 // Fetch Address byte aligned always.      F1 stage.\n   input logic                                   iccm_dma_sb_error,      // Single Bit ECC error from a DMA access\n   input logic                                   ic_error_start,         // This has any I$ errors ( data/tag/ecc/parity )\n   input logic                                   dec_tlu_flush_lower_wb,        // Flush from the pipeline.\n   input logic                                   dec_tlu_i0_commit_cmt,        //\n   input logic   [1:0]                           ifu_fetch_val,                 // valids on a 2B boundary\n   input logic                                   ifc_iccm_access_f1,        //\n   input logic                                   dec_tlu_fence_i_wb,        //\n   input logic                                   dec_tlu_flush_err_wb,          // Flush from the pipeline due to perr.\n   input logic                                   dec_tlu_force_halt ,\n   input logic [pt.ICACHE_NUM_WAYS-1:0]          bus_ic_wr_en ,\n\n   input  logic                                  selected_miss_thr,       // for incrementing counter\n   input  logic [31:1]                           miss_address_other,          //  Primary miss address for the other thread\n   input  logic                                  miss_done_other ,         //  Primary miss done\n   input  logic                                  scnd_miss_req_other,      // Other thread did a secondary miss... needed to detect and make the miss state transition to PRE_CRI\n   input  logic                                  address_match_other ,        //  Primary miss done\n   input  logic  [pt.ICACHE_STATUS_BITS-1:0]     way_status,\n   input  logic  [pt.ICACHE_STATUS_BITS-1:0]     way_status_rep_new,\n   input  logic                                  ifc_region_acc_fault_f2,\n   input  logic  [31:1]                          ifu_fetch_addr_int_f2 ,\n   input  logic                                  reset_all_tags,\n   input  logic [pt.IFU_BUS_TAG-1:0]             ifu_bus_rid_ff,\n   input  logic                                  fetch_req_icache_f2,\n   input  logic                                  fetch_req_iccm_f2,\n   input  logic                                  ifu_bus_rvalid           ,\n   input  logic                                  ifu_bus_rvalid_ff        ,\n   input  logic                                  ifu_bus_arvalid_ff        ,\n   input  logic                                  ifu_bus_arvalid           ,\n   input  logic                                  ifu_bus_arready           ,\n   input  logic [1:0]                            ifu_bus_rresp_ff          ,\n   input  logic                                  ifu_bus_rsp_valid ,\n   input  logic                                  ifu_bus_rsp_ready ,\n   input  logic                                  ifu_selected_miss_thr   ,\n   input  logic                                  rsp_miss_thr_ff,\n   input  logic [pt.IFU_BUS_TAG-1:0]             ifu_bus_rsp_tag,\n   input  logic [63:0]                           ifu_bus_rsp_rdata,\n   input  logic [1:0]                            ifu_bus_rsp_opc,\n   input  logic                                  iccm_error_start,     // start the error fsm\n   input  logic                                  bus_ifu_bus_clk_en ,\n   input  logic                                  ifu_bus_cmd_ready ,\n   input  logic                                  ifc_region_acc_fault_final_f1,\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]         ic_tag_valid,       // Valid bits when accessing the Icache. One valid bit per way. F2 stage\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]         replace_way_mb_any,\n   input  logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] ifu_ic_rw_int_addr_ff ,\n   input  logic                                  iccm_rd_ecc_single_err,\n\n\n\n\n\n   input logic [31:0]                                      iccm_corrected_data_f2_mux,\n   input logic [06:0]                                      iccm_corrected_ecc_f2_mux ,\n   input logic [pt.ICCM_BITS-1:2]                          iccm_ecc_corr_index_in,\n\n   output logic [pt.ICCM_BITS-1:2]                          iccm_ecc_corr_index_ff,\n   output logic [38:0]                                      iccm_ecc_corr_data_ff,\n   output logic                                             dma_sb_err_state,\n\n\n   output logic                                             ifu_bus_cmd_valid ,\n\n   output logic [31:1]                                      miss_address,                  //  Primary miss address for this thread.\n   output logic                                             miss_done,                     //  Primary miss done\n   output logic                                             address_match,                 //  miss-address match against primary miss-buffer address\n   output logic                                             iccm_buf_correct_ecc,          //\n   output logic                                             ifu_ic_mb_empty,               // Continue with normal fetching. This does not mean that miss is finished.\n   output logic                                             ic_dma_active  ,               // In the middle of servicing dma request to ICCM. Do not make any new requests.\n   output logic                                             ic_write_stall_self,           // Stall fetch the cycle we are writing the cache.\n   output logic                                             ic_write_stall_other,          // Stall fetch the cycle we are writing the cache.\n   output logic                                             ic_rd_en,                      // Icache read  enable.\n   output logic                                             ic_real_rd_wp,                 // Icache read  enable.\n   output logic                                             ifu_miss_state_idle,           // No icache misses are outstanding.\n   output logic                                             ifu_miss_state_pre_crit_ff,    // In PRE_CRIRT_BYP state delayed.\n   output logic                                             ic_crit_wd_rdy  ,\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                    ic_wr_en,           // Icache write enable, when filling the Icache.\n   output logic [31:3]                                      ifu_ic_req_addr_f2,\n   output logic                                             reset_tag_valid_for_miss  ,\n   output logic  [63:0]                                     ic_miss_buff_half,\n   output logic                                             sel_byp_data  ,\n   output logic                                             sel_ic_data,\n   output logic                                             miss_pending,\n   output logic [pt.ICACHE_BEAT_BITS-1:0]                   bus_rd_addr_count,\n   output logic [pt.ICACHE_NUM_WAYS-1:0]                    perr_err_inv_way,\n   output logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] perr_ic_index_ff,\n   output logic                                             perr_sel_invalidate,\n   output logic                                             bus_ifu_wr_en_ff_q  ,\n   output logic                                             bus_ifu_wr_en_ff_wo_err  ,\n   output logic                                             iccm_correction_state,\n   output logic                                             iccm_stop_fetch,\n   output logic                                             iccm_corr_scnd_fetch,\n\n   output                                                   perr_state_idle,\n   output                                                   perr_state_wff,\n   output eh2_perr_state_t                                 perr_state,\n   output eh2_err_stop_state_t                             err_stop_state,\n\n   output logic                                             scnd_miss_req_ff2,\n   output logic                                             scnd_miss_req,\n   output logic  [pt.ICACHE_STATUS_BITS-1:0]                way_status_mb_ff,\n   output logic  [pt.ICACHE_NUM_WAYS-1:0]                   tagv_mb_ff,\n   output logic                                             ifu_byp_data_err_new,\n   output logic  [3:0]                                      ifu_byp_data_err_f2,\n   output logic                                             ifu_wr_cumulative_err_data,\n   output logic                                             ic_act_hit_f2,\n   output logic                                             ic_act_hit_f2_ff,\n   output logic                                             ifc_fetch_req_f2,\n   output logic                                             last_beat,\n   output logic [31:1]                                      ifu_ic_rw_int_addr ,\n   output logic [79:0]                                      ic_byp_data_only_new,\n   output logic [1:0]                                       ifu_first_err_addr_2_1_f2 ,\n   output logic                                             ic_byp_hit_f2 ,\n   output logic                                             reset_ic_in ,\n   output logic                                             reset_ic_ff ,\n   output logic [31:1]                                      ifu_status_up_addr,\n   output logic [31:1]                                      ifu_status_wr_addr,\n   output logic                                             iccm_correct_ecc     ,\n   output logic                                             bus_cmd_sent           ,\n   output logic                                             bus_last_data_beat  ,\n   output logic                                             ic_hit_f2,              // Hit in Icache(if Icache access) or ICCM access( ICCM always has ic_hit_f2)\n   output logic                                             ic_act_miss_f2          // Actual miss\n\n) ;\n/////////////////////////////////////Threaded ///////////////////////////////////////////\n/////////////////////////////////////Threaded ///////////////////////////////////////////\n/////////////////////////////////////Threaded ///////////////////////////////////////////\n/////////////////////////////////////Threaded ///////////////////////////////////////////\n/////////////////////////////////////Threaded ///////////////////////////////////////////\n/////////////////////////////////////Threaded ///////////////////////////////////////////\n/////////////////////////////////////Threaded ///////////////////////////////////////////\n/////////////////////////////////////Threaded ///////////////////////////////////////////\n/////////////////////////////////////Threaded ///////////////////////////////////////////\n\n\n   typedef enum logic [3:0] {IDLE=4'b0000, CRIT_BYP_OK=4'b0001, HIT_U_MISS=4'b0010, MISS_WAIT=4'b0011,CRIT_WRD_RDY=4'b0100,SCND_MISS=4'b0101,STREAM=4'b0110,STALL_SCND_MISS=4'b0111, DUPL_MISS_WAIT=4'b1000, PRE_CRIT_BYP=4'b1001} miss_state_t;\n    miss_state_t miss_state, miss_nxtstate;\n\n    eh2_perr_state_t  perr_nxtstate;\n\n   eh2_err_stop_state_t  err_stop_nxtstate;\n   logic   err_stop_state_en ;\n   logic   err_stop_fetch ;\n   logic   ifu_bp_hit_taken_q_f2 ;\n   logic   fetch_req_icache_tid_f2 ;\n   logic   fetch_req_iccm_tid_f2 ;\n\n   logic [pt.ICACHE_STATUS_BITS-1:0]             way_status_mb_in;\n   logic [pt.ICACHE_NUM_WAYS-1:0]                tagv_mb_in;\n   logic           ifu_wr_cumulative_err;\n   logic           ifu_wr_data_comb_err ;\n   logic           ifu_wr_data_comb_err_ff;\n   logic           scnd_miss_index_match ;\n   logic           ic_miss_under_miss_f2;\n   logic           ic_ignore_2nd_miss_f2;\n   logic [31:1]    imb_in , imb_ff  ;\n   logic [31:pt.ICACHE_BEAT_ADDR_HI+1]    miss_addr_in , miss_addr  ;\n   logic           miss_wrap_f2 ;\n   logic           ifc_fetch_req_f2_raw;\n   logic           ifc_fetch_req_qual_f1 ;\n   logic           reset_beat_cnt  ;\n   logic [pt.ICACHE_BEAT_BITS-1:0]      req_addr_count ;\n   logic [pt.ICACHE_BEAT_ADDR_HI:3]     ic_req_addr_bits_hi_3 ;\n   logic [pt.ICACHE_BEAT_ADDR_HI:3]     ic_wr_addr_bits_hi_3 ;\n   logic           crit_wd_byp_ok_ff ;\n   logic   [79:0]  ic_byp_data_only_pre_new;\n   logic           fetch_f1_f2_c1_clken ;\n   logic           sel_mb_addr ;\n   logic           sel_mb_status_addr ;\n   logic           sel_mb_addr_ff ;\n   logic           ic_iccm_hit_f2;\n   logic           ic_act_miss_f2_delayed;\n   logic           ic_act_miss_f2_raw;\n   logic           bus_ifu_wr_data_error;\n   logic         bus_ifu_wr_data_error_ff;\n   logic         last_data_recieved_in ;\n   logic         last_data_recieved_ff ;\n   logic [pt.ICACHE_NUM_BEATS-1:0]    write_fill_data;\n   logic [pt.ICACHE_NUM_BEATS-1:0]    wr_data_c1_clk;\n   logic [pt.ICACHE_NUM_BEATS-1:0]    ic_miss_buff_data_valid_in;\n   logic [pt.ICACHE_NUM_BEATS-1:0]    ic_miss_buff_data_valid;\n   logic [pt.ICACHE_NUM_BEATS-1:0]    ic_miss_buff_data_error_in;\n   logic [pt.ICACHE_NUM_BEATS-1:0]    ic_miss_buff_data_error;\n   logic [pt.ICACHE_BEAT_ADDR_HI:1]   byp_fetch_index;\n   logic [pt.ICACHE_BEAT_ADDR_HI:2]   byp_fetch_index_0;\n   logic [pt.ICACHE_BEAT_ADDR_HI:2]   byp_fetch_index_1;\n   logic [pt.ICACHE_BEAT_ADDR_HI:3]   byp_fetch_index_inc;\n   logic [pt.ICACHE_BEAT_ADDR_HI:2]   byp_fetch_index_inc_0;\n   logic [pt.ICACHE_BEAT_ADDR_HI:2]   byp_fetch_index_inc_1;\n   logic          miss_buff_hit_unq_f2 ;\n   logic          stream_hit_f2 ;\n   logic          stream_miss_f2 ;\n   logic          stream_eol_f2 ;\n   logic          crit_byp_hit_f2 ;\n\n   logic [pt.IFU_BUS_TAG-2:0] other_tag ;\n   logic [(2*pt.ICACHE_NUM_BEATS)-1:0] [31:0] ic_miss_buff_data;\n   logic        scnd_miss_req_q;\n   logic        scnd_miss_req_in;\n   logic                                dma_sb_err_state_ff;\n   logic                                perr_state_en;\n   logic                                miss_state_en;\n   logic        busclk_reset;\n   logic        bus_inc_data_beat_cnt     ;\n   logic        bus_reset_data_beat_cnt   ;\n   logic        bus_hold_data_beat_cnt    ;\n\n   logic        bus_inc_cmd_beat_cnt     ;\n   logic        bus_reset_cmd_beat_cnt_0   ;\n   logic        bus_reset_cmd_beat_cnt_secondlast   ;\n   logic        bus_hold_cmd_beat_cnt    ;\n   logic        bus_cmd_beat_en;\n\n   logic [pt.ICACHE_BEAT_BITS-1:0]  bus_new_data_beat_count  ;\n   logic [pt.ICACHE_BEAT_BITS-1:0]  bus_data_beat_count      ;\n\n   logic [pt.ICACHE_BEAT_BITS-1:0]  bus_new_cmd_beat_count  ;\n\n   logic        bus_inc_rd_addr_cnt  ;\n   logic        bus_set_rd_addr_cnt  ;\n   logic        bus_reset_rd_addr_cnt;\n   logic        bus_hold_rd_addr_cnt ;\n\n   logic [pt.ICACHE_BEAT_BITS-1:0]  bus_new_rd_addr_count;\n   logic   second_half_available ;\n   logic   write_ic_16_bytes ;\n   logic   ic_miss_under_miss_killf1_f2;\n   logic           bus_ifu_wr_en     ;\n   logic           bus_ifu_wr_en_ff  ;\n   logic           uncacheable_miss_ff;\n   logic           ic_crit_wd_rdy_new_ff;\n   logic [pt.ICACHE_BEAT_BITS-1:0]                   bus_cmd_beat_count ;\n   logic           miss_done_other_ff;\n   logic           uncacheable_miss_in ;\n   logic           bus_cmd_req_in ;\n   logic    sel_hold_imb     ;\n\n   logic         sel_hold_imb_scnd;\n   logic  [31:1] imb_scnd_in;\n   logic  [31:1] imb_scnd_ff;\n   logic         uncacheable_miss_scnd_in ;\n   logic         uncacheable_miss_scnd_ff ;\n\n   logic  [pt.ICACHE_NUM_WAYS-1:0] tagv_mb_scnd_in;\n   logic  [pt.ICACHE_NUM_WAYS-1:0] tagv_mb_scnd_ff;\n\n   logic  [pt.ICACHE_STATUS_BITS-1:0] way_status_mb_scnd_in;\n   logic  [pt.ICACHE_STATUS_BITS-1:0] way_status_mb_scnd_ff;\n\n   logic [63:0]       ic_miss_buff_data_in;\n   logic   [pt.ICACHE_BEAT_ADDR_HI:1]  bypass_index;\n   logic   [pt.ICACHE_BEAT_ADDR_HI:3]  bypass_index_5_3_inc;\n   logic   bypass_data_ready_in;\n   logic   ic_crit_wd_rdy_new_in;\n   logic                                               perr_sb_write_status   ;\n   logic [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]   perr_ic_index_ff0;\n   logic                                               ifc_bus_ic_req_ff_in;\n   logic                                               bus_cmd_req_hold ;\n   logic                                               mb_ff_en;\n   logic [1:0]                                         ifu_fetch_val_q_f2;\n   logic                                               busclk_force ;\n   logic                                               ifc_fetch_req_tid_q_f1;\n   logic                                               ifc_fetch_req_tid_q_f1_raw;\n\n   logic                                               active_clk;\n\n   logic mb_idle;\n\n   rvoclkhdr activeclk (.*, .en(1'b1), .l1clk(active_clk));\n\n   // BUS LOGIC\n   assign ifc_fetch_req_tid_q_f1      =   ifc_fetch_req_f1     & fetch_tid_f1 ;\n   assign ifc_fetch_req_tid_q_f1_raw  =   ifc_fetch_req_f1_raw & fetch_tid_f1 ;\n\n   assign fetch_f1_f2_c1_clken  = ifc_fetch_req_tid_q_f1_raw | ifc_fetch_req_f2 | miss_pending | exu_flush_final | scnd_miss_req | reset_all_tags;\n   // C1 - 1 clock pulse for data\n   logic                                             fetch_f1_f2_c1_clk;\n`ifdef RV_FPGA_OPTIMIZE\n   assign fetch_f1_f2_c1_clk = 1'b0;\n`else\n   rvclkhdr fetch_f1_f2_c1_cgc   ( .en(fetch_f1_f2_c1_clken),     .l1clk(fetch_f1_f2_c1_clk), .* );\n`endif\n\n\n   assign ifu_bp_hit_taken_q_f2 = ifu_bp_kill_next_f2 & ic_hit_f2 ;\n\n\n   assign miss_done      = ( bus_ifu_wr_en_ff  & last_beat) |   (miss_state ==  DUPL_MISS_WAIT);   // Duplicate miss state should also say miss_done as we dont to lock up both threads on this state\n   assign address_match  = (miss_address_other[pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO] == imb_ff[pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO] ) & ((miss_state != IDLE) | ic_act_miss_f2_raw)  &  ~uncacheable_miss_ff ;\n\n   //////////////////////////////////// Create Miss State Machine ///////////////////////\n   //                                   Create Miss State Machine                      //\n   //                                   Create Miss State Machine                      //\n   //                                   Create Miss State Machine                      //\n   //////////////////////////////////// Create Miss State Machine ///////////////////////\n   // FIFO state machine\n   always_comb begin : MISS_SM\n      miss_nxtstate   = IDLE;\n      miss_state_en   = 1'b0;\n      case (miss_state)\n         IDLE: begin : idle\n                  miss_nxtstate = ( exu_flush_final                                  ) ? HIT_U_MISS :\n                                  ( address_match_other & ~uncacheable_miss_ff) ? DUPL_MISS_WAIT : (scnd_miss_req_other) ? PRE_CRIT_BYP : CRIT_BYP_OK ;\n                  miss_state_en = ic_act_miss_f2_raw  & ~dec_tlu_force_halt;\n         end\n         PRE_CRIT_BYP : begin : pre_crit_byp\n                  miss_nxtstate =  dec_tlu_force_halt ? IDLE : exu_flush_final ? HIT_U_MISS : CRIT_BYP_OK ;\n                  miss_state_en =  1'b1;\n         end\n         DUPL_MISS_WAIT: begin : dupl_miss_wait\n                  miss_nxtstate =  IDLE ;\n                  miss_state_en =  exu_flush_final | miss_done_other | miss_done_other_ff | dec_tlu_force_halt;\n         end\n         CRIT_BYP_OK: begin : crit_byp_ok\n                  miss_nxtstate = (dec_tlu_force_halt ) ?                                                                               IDLE :\n                                  ( ic_byp_hit_f2 &  (last_data_recieved_ff | (bus_ifu_wr_en_ff & last_beat)) &  uncacheable_miss_ff) ? IDLE :\n                                  ( ic_byp_hit_f2 &  ~last_data_recieved"}
{"text": "_ff                                   &  uncacheable_miss_ff) ? MISS_WAIT :\n                                  (~ic_byp_hit_f2 &  ~exu_flush_final &  (bus_ifu_wr_en_ff & last_beat)       &  uncacheable_miss_ff) ? CRIT_WRD_RDY :\n                                  (                                      (bus_ifu_wr_en_ff & last_beat)       & ~uncacheable_miss_ff) ? IDLE :\n                                  ( ic_byp_hit_f2  &  ~exu_flush_final & ~(bus_ifu_wr_en_ff & last_beat)      & ~ifu_bp_hit_taken_q_f2   & ~uncacheable_miss_ff) ? STREAM :\n                                  ( bus_ifu_wr_en_ff &  ~exu_flush_final & ~(bus_ifu_wr_en_ff & last_beat)    & ~ifu_bp_hit_taken_q_f2   & ~uncacheable_miss_ff) ? STREAM :\n                                  (~ic_byp_hit_f2  &  ~exu_flush_final &  (bus_ifu_wr_en_ff & last_beat)      & ~uncacheable_miss_ff) ? IDLE :\n                                  ( (exu_flush_final | ifu_bp_hit_taken_q_f2)  & ~(bus_ifu_wr_en_ff & last_beat)                      ) ? HIT_U_MISS : IDLE;\n                  miss_state_en =  dec_tlu_force_halt | exu_flush_final | ic_byp_hit_f2 | ifu_bp_hit_taken_q_f2 | (bus_ifu_wr_en_ff & last_beat) | (bus_ifu_wr_en_ff & ~uncacheable_miss_ff)  ;\n         end\n         CRIT_WRD_RDY: begin : crit_wrd_rdy\n                  miss_nxtstate =  IDLE ;\n                  miss_state_en =  exu_flush_final | flush_final_f2 | ic_byp_hit_f2 | dec_tlu_force_halt   ;\n         end\n         STREAM: begin : stream\n                  miss_nxtstate =  ((exu_flush_final | ifu_bp_hit_taken_q_f2  | stream_eol_f2 ) & ~(bus_ifu_wr_en_ff & last_beat) & ~dec_tlu_force_halt) ? HIT_U_MISS  : IDLE ;\n                  miss_state_en =    exu_flush_final | ifu_bp_hit_taken_q_f2  | stream_eol_f2   |  (bus_ifu_wr_en_ff & last_beat) | dec_tlu_force_halt ;\n         end\n         MISS_WAIT: begin : miss_wait\n                  miss_nxtstate =  (exu_flush_final & ~(bus_ifu_wr_en_ff & last_beat) & ~dec_tlu_force_halt) ? HIT_U_MISS  : IDLE ;\n                  miss_state_en =   exu_flush_final | (bus_ifu_wr_en_ff & last_beat) | dec_tlu_force_halt ;\n         end\n         HIT_U_MISS: begin : hit_u_miss\n                  miss_nxtstate =  ic_miss_under_miss_f2 & ~(bus_ifu_wr_en_ff & last_beat) & ~dec_tlu_force_halt & ~address_match_other ? SCND_MISS :\n                                   ic_miss_under_miss_f2 & ~(bus_ifu_wr_en_ff & last_beat) & ~dec_tlu_force_halt &  address_match_other ? STALL_SCND_MISS :\n                                   ic_ignore_2nd_miss_f2 & ~(bus_ifu_wr_en_ff & last_beat) & ~dec_tlu_force_halt ? STALL_SCND_MISS : IDLE  ;\n                  miss_state_en = (bus_ifu_wr_en_ff & last_beat) | ic_miss_under_miss_f2 | ic_ignore_2nd_miss_f2 | dec_tlu_force_halt;\n         end\n         SCND_MISS: begin : scnd_miss  // If the bus has returned last beat and it is not my thread in f2, will need to wait and sync back for invalidations and stuff to work\n            miss_nxtstate   =  dec_tlu_force_halt ? IDLE  :\n                               exu_flush_final ?  ((bus_ifu_wr_en_ff & last_beat) ? IDLE : HIT_U_MISS) : address_match_other ? DUPL_MISS_WAIT : CRIT_BYP_OK;\n                  miss_state_en   = (bus_ifu_wr_en_ff & last_beat) | exu_flush_final | dec_tlu_force_halt;\n         end\n         STALL_SCND_MISS: begin : stall_scnd_miss\n                  miss_nxtstate   = dec_tlu_force_halt ? IDLE :\n                                    exu_flush_final ?  ((bus_ifu_wr_en_ff & last_beat) ? IDLE : HIT_U_MISS) : IDLE;\n                  miss_state_en   = (bus_ifu_wr_en_ff & last_beat) | exu_flush_final | dec_tlu_force_halt;\n         end\n\n         default: begin : def_case\n                  miss_nxtstate   = IDLE;\n                  miss_state_en   = 1'b0;\n         end\n      endcase\n   end\n   rvdffs #(($bits(miss_state_t))) miss_state_ff (.clk(active_clk), .din(miss_nxtstate), .dout({miss_state}), .en(miss_state_en),   .*);\n\n\n\n   assign miss_pending       =  (miss_state != IDLE) ;\n   assign crit_wd_byp_ok_ff  =  (miss_state == CRIT_BYP_OK) | ((miss_state == CRIT_WRD_RDY) & ~flush_final_f2);\n   assign sel_hold_imb       =  (miss_pending & ~(bus_ifu_wr_en_ff & last_beat) & ~((miss_state == CRIT_WRD_RDY) & exu_flush_final) &\n                              ~((miss_state == CRIT_WRD_RDY) & crit_byp_hit_f2) )| ic_act_miss_f2_raw |\n                                (miss_pending & (miss_nxtstate == CRIT_WRD_RDY)) ;\n\n\n\n   assign sel_hold_imb_scnd                                =((miss_state == SCND_MISS) | ic_miss_under_miss_f2) & ~(exu_flush_final & ~(bus_ifu_wr_en_ff & last_beat)) ;\n   assign way_status_mb_scnd_in[pt.ICACHE_STATUS_BITS-1:0] = (miss_state == SCND_MISS) ? way_status_mb_scnd_ff[pt.ICACHE_STATUS_BITS-1:0] : {way_status[pt.ICACHE_STATUS_BITS-1:0]} ;\n   assign tagv_mb_scnd_in[pt.ICACHE_NUM_WAYS-1:0]          = (miss_state == SCND_MISS) ? (tagv_mb_scnd_ff[pt.ICACHE_NUM_WAYS-1:0] &  {pt.ICACHE_NUM_WAYS{~reset_all_tags}})        : ({ic_tag_valid[pt.ICACHE_NUM_WAYS-1:0]} & {pt.ICACHE_NUM_WAYS{~reset_all_tags}});\n   assign uncacheable_miss_scnd_in   = sel_hold_imb_scnd ? uncacheable_miss_scnd_ff : ifc_fetch_uncacheable_f1 ;\n\n\n   rvdff_fpga #(1)  unc_miss_scnd_ff                         (.*, .clk(fetch_f1_f2_c1_clk), .clken(fetch_f1_f2_c1_clken), .rawclk(clk),  .din (uncacheable_miss_scnd_in), .dout(uncacheable_miss_scnd_ff));\n\n   rvdffpcie  #(31) imb_f2_scnd_ff                           (.*, .en(fetch_f1_f2_c1_clken), .din ({imb_scnd_in[31:1]}), .dout({imb_scnd_ff[31:1]}));\n\n   rvdff_fpga #(pt.ICACHE_STATUS_BITS)  mb_rep_wayf2_scnd_ff (.*, .clk(fetch_f1_f2_c1_clk), .clken(fetch_f1_f2_c1_clken), .rawclk(clk),  .din ({way_status_mb_scnd_in[pt.ICACHE_STATUS_BITS-1:0]}), .dout({way_status_mb_scnd_ff[pt.ICACHE_STATUS_BITS-1:0]}));\n   rvdff_fpga #(pt.ICACHE_NUM_WAYS)     mb_tagv_scnd_ff      (.*, .clk(fetch_f1_f2_c1_clk), .clken(fetch_f1_f2_c1_clken), .rawclk(clk),  .din ({tagv_mb_scnd_in[pt.ICACHE_NUM_WAYS-1:0]}), .dout({tagv_mb_scnd_ff[pt.ICACHE_NUM_WAYS-1:0]}));\n\n   assign  fetch_req_icache_tid_f2  = fetch_req_icache_f2 & fetch_tid_f2 ;\n   assign  fetch_req_iccm_tid_f2    = fetch_req_iccm_f2   & fetch_tid_f2 ;\n   assign ifu_fetch_val_q_f2[1:0]   = ifu_fetch_val[1:0] & {2{fetch_tid_f2}} ;\n\n   assign ic_req_addr_bits_hi_3[pt.ICACHE_BEAT_ADDR_HI:3] = req_addr_count[pt.ICACHE_BEAT_BITS-1:0] ;\n   assign ic_wr_addr_bits_hi_3[pt.ICACHE_BEAT_ADDR_HI:3]  = ifu_bus_rid_ff[pt.ICACHE_BEAT_BITS-1:0] & {pt.ICACHE_BEAT_BITS{bus_ifu_wr_en_ff}};\n\n   assign ic_iccm_hit_f2        = fetch_req_iccm_tid_f2  &  (~miss_pending | (miss_state==HIT_U_MISS) | (miss_state==STREAM)) ;\n   assign ic_byp_hit_f2         = (crit_byp_hit_f2 | stream_hit_f2)  & fetch_req_icache_tid_f2 &  miss_pending  ;\n   assign ic_act_hit_f2         = (|ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0]) & fetch_req_icache_tid_f2 & ~reset_all_tags & (~miss_pending | (miss_state==HIT_U_MISS)) & ~sel_mb_addr_ff ;\n   assign ic_act_miss_f2_raw    = (((~(|ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0]) | reset_all_tags) & fetch_req_icache_tid_f2 & ~miss_pending & ~ifc_region_acc_fault_f2) | scnd_miss_req)  ;\n   assign ic_act_miss_f2        = ic_act_miss_f2_raw & (miss_nxtstate != DUPL_MISS_WAIT);\n   assign ic_miss_under_miss_f2 = (~(|ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0]) | reset_all_tags) & fetch_req_icache_tid_f2 & (miss_state == HIT_U_MISS) &\n                                   (imb_ff[31:pt.ICACHE_TAG_INDEX_LO] != ifu_fetch_addr_int_f2[31:pt.ICACHE_TAG_INDEX_LO]) & ~uncacheable_miss_ff & ~sel_mb_addr_ff & ~ifc_region_acc_fault_f2 ;\n\n  assign ic_ignore_2nd_miss_f2  = (~(|ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0]) | reset_all_tags) & fetch_req_icache_tid_f2 & (miss_state == HIT_U_MISS) &\n                                   ((imb_ff[31:pt.ICACHE_TAG_INDEX_LO] == ifu_fetch_addr_int_f2[31:pt.ICACHE_TAG_INDEX_LO])  |   uncacheable_miss_ff) ;\n\n\n   assign ic_miss_under_miss_killf1_f2 = (~(|ic_rd_hit[pt.ICACHE_NUM_WAYS-1:0]) | reset_all_tags | sel_mb_addr_ff ) & fetch_req_icache_tid_f2 & (miss_state == HIT_U_MISS) ;\n\n   assign scnd_miss_index_match  =  (imb_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO] == imb_scnd_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]) & scnd_miss_req & ~ifu_wr_cumulative_err_data;\n   assign way_status_mb_in[pt.ICACHE_STATUS_BITS-1:0] = (scnd_miss_req & ~scnd_miss_index_match) ? way_status_mb_scnd_ff[pt.ICACHE_STATUS_BITS-1:0] :\n                                                        (scnd_miss_req &  scnd_miss_index_match) ? way_status_rep_new[pt.ICACHE_STATUS_BITS-1:0] :\n                                                         miss_pending                            ? way_status_mb_ff[pt.ICACHE_STATUS_BITS-1:0] :\n                                                                                                  {way_status[pt.ICACHE_STATUS_BITS-1:0]} ;\n   assign tagv_mb_in[pt.ICACHE_NUM_WAYS-1:0]          = scnd_miss_req ? ((tagv_mb_scnd_ff[pt.ICACHE_NUM_WAYS-1:0] & {pt.ICACHE_NUM_WAYS{~reset_all_tags}}) | ({pt.ICACHE_NUM_WAYS {scnd_miss_index_match}} & replace_way_mb_any[pt.ICACHE_NUM_WAYS-1:0] &  {pt.ICACHE_NUM_WAYS{~reset_all_tags}})) :\n                                                         miss_pending ? tagv_mb_ff[pt.ICACHE_NUM_WAYS-1:0]  : ({ic_tag_valid[pt.ICACHE_NUM_WAYS-1:0]} & {pt.ICACHE_NUM_WAYS{~reset_all_tags}}) ;\n\n   assign uncacheable_miss_in   = scnd_miss_req ? uncacheable_miss_scnd_ff : sel_hold_imb ? uncacheable_miss_ff : ifc_fetch_uncacheable_f1 ;\n   assign imb_in[31:1]          = scnd_miss_req ? imb_scnd_ff[31:1]        : sel_hold_imb ? imb_ff[31:1] : {fetch_addr_f1[31:1]} ;\n   assign imb_scnd_in[31:1]     = sel_hold_imb_scnd ? imb_scnd_ff[31:1] : {fetch_addr_f1[31:1]} ;\n   assign mb_ff_en              = fetch_tid_f1 | scnd_miss_req;\n\n   assign reset_ic_in           = miss_pending  &  ~scnd_miss_req_q & (reset_all_tags |  reset_ic_ff) ;\n\n   rvdff #(1)  act_hit_ff (.*, .clk(active_clk), .din (ic_act_hit_f2), .dout(ic_act_hit_f2_ff));\n   rvdff #(1)  reset_ic_f2 (.*, .clk(active_clk), .din (reset_ic_in), .dout(reset_ic_ff));\n   rvdff #(1)  miss_dn_ff (.*, .clk(active_clk), .din (miss_done_other), .dout(miss_done_other_ff));\n\n\n   rvdff_fpga #(1)  unc_miss_ff      (.*, .clk(fetch_f1_f2_c1_clk),  .clken(fetch_f1_f2_c1_clken), .rawclk(clk),  .din (uncacheable_miss_in), .dout(uncacheable_miss_ff));\n\n   rvdffpcie #(31) imb_f2_ff         (.*,  .en(fetch_f1_f2_c1_clken & mb_ff_en), .din ({imb_in[31:1]}), .dout({imb_ff[31:1]}));   // update the miss buffer only when my thread misses\n\n\n// Add miss address.\n   assign miss_addr_in[31:pt.ICACHE_BEAT_ADDR_HI+1]      = (~miss_pending                    ) ? imb_ff[31:pt.ICACHE_BEAT_ADDR_HI+1] :\n                                                           (                scnd_miss_req_q  ) ? imb_scnd_ff[31:pt.ICACHE_BEAT_ADDR_HI+1] : miss_addr[31:pt.ICACHE_BEAT_ADDR_HI+1] ;\n\n   rvdfflie #(.WIDTH(31-pt.ICACHE_BEAT_ADDR_HI),.LEFT(31-pt.ICACHE_BEAT_ADDR_HI-8)) miss_f_ff       (.*, .en(bus_ifu_bus_clk_en | ic_act_miss_f2 | dec_tlu_force_halt), .din ({miss_addr_in[31:pt.ICACHE_BEAT_ADDR_HI+1]}), .dout({miss_addr[31:pt.ICACHE_BEAT_ADDR_HI+1]}));\n\n\n\n\n\n   rvdff_fpga #(pt.ICACHE_STATUS_BITS)  mb_rep_wayf2_ff (.*, .clk(fetch_f1_f2_c1_clk),  .clken(fetch_f1_f2_c1_clken), .rawclk(clk),  .din ({way_status_mb_in[pt.ICACHE_STATUS_BITS-1:0]}), .dout({way_status_mb_ff[pt.ICACHE_STATUS_BITS-1:0]}));\n   rvdff_fpga#(pt.ICACHE_NUM_WAYS)      mb_tagv_ff      (.*, .clk(fetch_f1_f2_c1_clk),  .clken(fetch_f1_f2_c1_clken), .rawclk(clk),  .din ({tagv_mb_in[pt.ICACHE_NUM_WAYS-1:0]}), .dout({tagv_mb_ff[pt.ICACHE_NUM_WAYS-1:0]}));\n\n\n   assign ifc_fetch_req_qual_f1  = ifc_fetch_req_tid_q_f1  & ~((miss_state == CRIT_WRD_RDY) & flush_final_f2) & ~stream_miss_f2 & ~ic_miss_under_miss_killf1_f2 ;\n   rvdff #(1) fetch_req_f2_ff  (.*, .clk(active_clk),  .din(ifc_fetch_req_qual_f1), .dout(ifc_fetch_req_f2_raw));\n\n   assign ifc_fetch_req_f2       = ifc_fetch_req_f2_raw & ~exu_flush_final ;\n\n   logic ifu_miss_state_pre_crit;\n   assign ifu_ic_mb_empty          = (((miss_state == HIT_U_MISS) | (miss_state == STREAM)) & ~(bus_ifu_wr_en_ff & last_beat)) |  ~miss_pending ;\n   assign ifu_miss_state_idle      = (miss_state == IDLE) ;\n   assign ifu_miss_state_pre_crit  = (miss_state == PRE_CRIT_BYP) ;\n   rvdff #(1) precrit_byp_ff         (.*, .clk(active_clk),  .din (ifu_miss_state_pre_crit), .dout(ifu_miss_state_pre_crit_ff));\n\n   assign sel_mb_addr  = ((miss_pending & write_ic_16_bytes & ~uncacheable_miss_ff) | reset_tag_valid_for_miss) ;\n   assign ifu_ic_rw_int_addr[31:1] = ({31{ sel_mb_addr}}  &  {imb_ff[31:pt.ICACHE_BEAT_ADDR_HI+1] , ic_wr_addr_bits_hi_3[pt.ICACHE_BEAT_ADDR_HI:3] , imb_ff[2:1]})  |\n                                     ({31{~sel_mb_addr}}  &  fetch_addr_f1[31:1] )   ;\n\n   assign sel_mb_status_addr  = ((miss_pending & write_ic_16_bytes & ~uncacheable_miss_ff & last_beat & bus_ifu_wr_en_ff_q) | reset_tag_valid_for_miss) ;\n   assign ifu_status_wr_addr[31:1] = {imb_ff[31:pt.ICACHE_BEAT_ADDR_HI+1], ic_wr_addr_bits_hi_3[pt.ICACHE_BEAT_ADDR_HI:3], imb_ff[2:1]};\n   assign ifu_status_up_addr[31:1] = ifu_fetch_addr_int_f2[31:1];\n\n\n\n\n   assign ifu_ic_req_addr_f2[31:3]  = {miss_addr[31:pt.ICACHE_BEAT_ADDR_HI+1] , ic_req_addr_bits_hi_3[pt.ICACHE_BEAT_ADDR_HI:3] };\n  // Please keep this for reference\n  assign  miss_address[31:1]  = (((miss_state==HIT_U_MISS)  & ~(bus_ifu_wr_en_ff & last_beat))) | (miss_state == SCND_MISS) ? imb_scnd_ff[31:1] : imb_ff[31:1] ;\n\n  rvdff #(1) sel_mb_ff (.*, .clk(active_clk),  .din (sel_mb_addr), .dout(sel_mb_addr_ff));\n\n/////////////////////////////////////////////////////////////////////////////////////\n//  Create full buffer...                                                          //\n/////////////////////////////////////////////////////////////////////////////////////\n     assign ic_miss_buff_data_in[63:0] = ifu_bus_rsp_rdata[63:0];\n\n     for (genvar i=0; i<pt.ICACHE_NUM_BEATS; i++) begin :  wr_flop\n       assign write_fill_data[i]        =   bus_ifu_wr_en & (  (pt.IFU_BUS_TAG-1)'(i)  == ifu_bus_rsp_tag[pt.IFU_BUS_TAG-2:0]);\n\n       rvdffe #(32) byp_data_0_ff (.*,\n                 .en (write_fill_data[i]),\n                 .din (ic_miss_buff_data_in[31:0]),\n                 .dout(ic_miss_buff_data[i*2][31:0]));\n\n       rvdffe #(32) byp_data_1_ff (.*,\n                 .en (write_fill_data[i]),\n                 .din (ic_miss_buff_data_in[63:32]),\n                 .dout(ic_miss_buff_data[i*2+1][31:0]));\n\n        assign ic_miss_buff_data_valid_in[i]  = write_fill_data[i] ? 1'b1  : (ic_miss_buff_data_valid[i]  & ~ic_act_miss_f2) ;\n        rvdff #(1) byp_data_valid_ff (.*,\n                  .clk (active_clk),\n                  .din (ic_miss_buff_data_valid_in[i]),\n                  .dout(ic_miss_buff_data_valid[i]));\n\n        assign ic_miss_buff_data_error_in[i]  = write_fill_data[i] ? bus_ifu_wr_data_error  : (ic_miss_buff_data_error[i]  & ~ic_act_miss_f2) ;\n        rvdff #(1) byp_data_error_ff (.*,\n                  .clk (active_clk),\n                  .din (ic_miss_buff_data_error_in[i] ),\n                  .dout(ic_miss_buff_data_error[i]));\n     end\n\n/////////////////////////////////////////////////////////////////////////////////////\n// New bypass ready                                                                //\n/////////////////////////////////////////////////////////////////////////////////////\n\n   assign bypass_index[pt.ICACHE_BEAT_ADDR_HI:1]         = imb_ff[pt.ICACHE_BEAT_ADDR_HI:1] ;\n   assign bypass_index_5_3_inc[pt.ICACHE_BEAT_ADDR_HI:3] = bypass_index[pt.ICACHE_BEAT_ADDR_HI:3] + 1 ;\n\n   assign bypass_data_ready_in = ((ic_miss_buff_data_valid_in[bypass_index[pt.ICACHE_BEAT_ADDR_HI:3]]                                                    & (bypass_index[2:1] == 2'b00)))   |\n                                 ((ic_miss_buff_data_valid_in[bypass_index[pt.ICACHE_BEAT_ADDR_HI:3]] & ic_miss_buff_data_valid_in[bypass_index_5_3_inc[pt.ICACHE_BEAT_ADDR_HI:3]] & (bypass_index[2:1] != 2'b00))) |\n                                 ((ic_miss_buff_data_valid_in[bypass_index[pt.ICACHE_BEAT_ADDR_HI:3]] & (bypass_index[pt.ICACHE_BEAT_ADDR_HI:3] == {pt.ICACHE_BEAT_ADDR_HI{1'b1}})))   ;\n\n\n\n   assign    ic_crit_wd_rdy_new_in = ( bypass_data_ready_in & crit_wd_byp_ok_ff   &  uncacheable_miss_ff &  ~exu_flush_final ) |\n                                     ( (miss_state==STREAM) & crit_wd_byp_ok_ff   & ~uncacheable_miss_ff &  ~exu_flush_final & ~ifu_bp_hit_taken_q_f2) |\n                                     (ic_crit_wd_rdy_new_ff & ~fetch_req_icache_tid_f2 & crit_wd_byp_ok_ff    &  ~exu_flush_final) ;\n\n   rvdff #(1)           crit_wd_new_ff      (.*, .clk(active_clk),  .din(ic_crit_wd_rdy_new_in),   .dout(ic_crit_wd_rdy_new_ff));\n\n  assign byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:1]          =    ifu_fetch_addr_int_f2[pt.ICACHE_BEAT_ADDR_HI:1]       ;\n  assign byp_fetch_index_0[pt.ICACHE_BEAT_ADDR_HI:2]        =   {ifu_fetch_addr_int_f2[pt.ICACHE_BEAT_ADDR_HI:3],1'b0} ;\n  assign byp_fetch_index_1[pt.ICACHE_BEAT_ADDR_HI:2]        =   {ifu_fetch_addr_int_f2[pt.ICACHE_BEAT_ADDR_HI:3],1'b1} ;\n  assign byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]      =    ifu_fetch_addr_int_f2[pt.ICACHE_BEAT_ADDR_HI:3]+1'b1 ;\n  assign byp_fetch_index_inc_0[pt.ICACHE_BEAT_ADDR_HI:2]    =   {byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3], 1'b0} ;\n  assign byp_fetch_index_inc_1[pt.ICACHE_BEAT_ADDR_HI:2]    =   {byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3], 1'b1} ;\n\n  assign  ifu_byp_data_err_new = (~ifu_fetch_addr_int_f2[2] & ~ifu_fetch_addr_int_f2[1] &   (                                                                                           ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] )) |\n                                 (~ifu_fetch_addr_int_f2[2] &  ifu_fetch_addr_int_f2[1] &   ((~miss_wrap_f2 & ic_miss_buff_data_error[byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]]) | ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] )) |\n                                 ( ifu_fetch_addr_int_f2[2] & ~ifu_fetch_addr_int_f2[1] &   ((~miss_wrap_f2 & ic_miss_buff_data_error[byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]]) | ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] )) |\n                                 ( ifu_fetch_addr_int_f2[2] &  ifu_fetch_addr_int_f2[1] &   ((~miss_wrap_f2 & ic_miss_buff_data_error[byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]]) | ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] )) ;\n\n\n  assign ifu_byp_data_err_f2[3:0]  =                                                              (ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] )  ? 4'b1111 :\n                                      (~ifu_fetch_addr_int_f2[2] & ~ifu_fetch_addr_int_f2[1] &   ~(ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] ) & (~miss_wrap_f2 & ic_miss_buff_data_error[byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]])) ? 4'b0000 :\n                                      (~ifu_fetch_addr_int_f2[2] &  ifu_fetch_addr_int_f2[1] &   ~(ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] ) & (~miss_wrap_f2 & ic_miss_buff_data_error[byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]])) ? 4'b1000 :\n                                      ( ifu_fetch_addr_int_f2[2] & ~ifu_fetch_addr_int_f2[1] &   ~(ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] ) & (~miss_wrap_f2 & ic_miss_buff_data_error[byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]])) ? 4'b1100 :\n                                      ( ifu_fetch_addr_int_f2[2] &  ifu_fetch_addr_int_f2[1] &   ~(ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] ) & (~miss_wrap_f2 & ic_miss_buff_data_error[byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]])) ? 4'b1110 : 4'b0000;\n\n\n\n\n\n  assign ifu_first_err_addr_2_1_f2[1:0]  =  ic_miss_buff_data_error[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] ?  ifu_fetch_addr_int_f2[2:1] : 2'b00 ;\n  assign mb_idle = (miss_state==IDLE);\n  assign ic_byp_data_only_pre_new[79:0] =  ({80{~ifu_fetch_addr_int_f2[2] & ~mb_idle}} &   {ic_miss_buff_data[byp_fetch_index_inc_0][15:0],ic_miss_buff_data[byp_fetch_index_1][31:0]     , ic_miss_bu"}
{"text": "ff_data[byp_fetch_index_0][31:0]}) |\n                                           ({80{ ifu_fetch_addr_int_f2[2] & ~mb_idle}} &   {ic_miss_buff_data[byp_fetch_index_inc_1][15:0],ic_miss_buff_data[byp_fetch_index_inc_0][31:0] , ic_miss_buff_data[byp_fetch_index_1][31:0]}) ;\n\n  assign ic_byp_data_only_new[79:0]      = mb_idle ? '0 : ~ifu_fetch_addr_int_f2[1] ? {ic_byp_data_only_pre_new[79:0]} :\n                                                                      {16'b0,ic_byp_data_only_pre_new[79:16]} ;\n\n  assign miss_wrap_f2      =  (imb_ff[pt.ICACHE_TAG_INDEX_LO] != ifu_fetch_addr_int_f2[pt.ICACHE_TAG_INDEX_LO] ) ;\n\n  assign miss_buff_hit_unq_f2  = ((ic_miss_buff_data_valid[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]]                                                     & (byp_fetch_index[2:1] == 2'b00)) |\n                                 ((ic_miss_buff_data_valid[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] & ic_miss_buff_data_valid[byp_fetch_index_inc[pt.ICACHE_BEAT_ADDR_HI:3]] & (byp_fetch_index[2:1]!= 2'b00))) |\n                                 ((ic_miss_buff_data_valid[byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3]] & (byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:3] == {pt.ICACHE_BEAT_BITS{1'b1}})))) & fetch_tid_f2   ;\n\n  logic  previous_state_is_stream;\n  rvdff  #((1))  prev_st_strm_ff  (.clk(active_clk), .din((miss_state==STREAM)),   .dout(previous_state_is_stream),   .*);\n  assign stream_hit_f2     =  (miss_buff_hit_unq_f2 & ~miss_wrap_f2 ) & ((miss_state==STREAM) | ((miss_state==IDLE) & previous_state_is_stream)) ;\n  assign stream_miss_f2    = ~(miss_buff_hit_unq_f2 & ~miss_wrap_f2 ) & ((miss_state==STREAM) | ((miss_state==IDLE) & previous_state_is_stream)) & ifc_fetch_req_f2 ;\n  assign stream_eol_f2     =  (byp_fetch_index[pt.ICACHE_BEAT_ADDR_HI:2] == {pt.ICACHE_BEAT_BITS+1{1'b1}}) & ifc_fetch_req_f2 & stream_hit_f2;\n\n  assign crit_byp_hit_f2   =  (miss_buff_hit_unq_f2 ) & ((miss_state == CRIT_WRD_RDY) | (miss_state==CRIT_BYP_OK)) ;\n\n/////////////////////////////////////////////////////////////////////////////////////\n// Figure out if you have the data to write.                                       //\n/////////////////////////////////////////////////////////////////////////////////////\n\nassign other_tag[pt.IFU_BUS_TAG-2:0] = {ifu_bus_rid_ff[pt.IFU_BUS_TAG-2:1] , ~ifu_bus_rid_ff[0] } ;\nassign second_half_available      = ic_miss_buff_data_valid[other_tag] ;\nassign write_ic_16_bytes          = second_half_available & bus_ifu_wr_en_ff ;\nassign ic_miss_buff_half[63:0]    = {ic_miss_buff_data[{other_tag,1'b1}],ic_miss_buff_data[{other_tag,1'b0}] } ;\n\n\n\n\n\n   rvdff  #(pt.ICACHE_INDEX_HI-pt.ICACHE_TAG_INDEX_LO+1) perr_dat_ff0    (.clk(active_clk), .din(ifu_ic_rw_int_addr_ff[pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]), .dout(perr_ic_index_ff0[pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO]),  .*);\n   rvdffs #(pt.ICACHE_INDEX_HI-pt.ICACHE_TAG_INDEX_LO+1) perr_dat_ff1    (.clk(active_clk), .din(perr_ic_index_ff0    [pt.ICACHE_INDEX_HI:pt.ICACHE_TAG_INDEX_LO]), .dout(perr_ic_index_ff[pt.ICACHE_INDEX_HI : pt.ICACHE_TAG_INDEX_LO]), .en(perr_sb_write_status),  .*);\n\n   assign perr_err_inv_way[pt.ICACHE_NUM_WAYS-1:0]   =  {pt.ICACHE_NUM_WAYS{perr_sel_invalidate}} ;\n   assign iccm_correct_ecc     = (perr_state == ECC_CORR);\n   assign dma_sb_err_state     = (perr_state == DMA_SB_ERR);\n   assign perr_state_idle      = (perr_state == ERR_IDLE);\n   assign perr_state_wff       = (perr_state == IC_WFF);\n   assign iccm_buf_correct_ecc = iccm_correct_ecc & ~dma_sb_err_state_ff;\n    rvdff  #((1))  dma_sb_err_ff  (.clk(active_clk), .din(dma_sb_err_state),   .dout(dma_sb_err_state_ff),   .*);\n\n   //////////////////////////////////// Create Parity Error State Machine ///////////////////////\n   //                                   Create Parity Error State Machine                      //\n   //                                   Create Parity Error State Machine                      //\n   //                                   Create Parity Error State Machine                      //\n   //////////////////////////////////// Create Parity Error State Machine ///////////////////////\n   // FIFO state machine\n   always_comb begin  : ERROR_SM\n      perr_nxtstate            = ERR_IDLE;\n      perr_state_en            = 1'b0;\n      perr_sb_write_status     = 1'b0;\n      perr_sel_invalidate      = 1'b0;\n\n      case (perr_state)\n         ERR_IDLE: begin : err_idle\n                  perr_nxtstate         =  iccm_dma_sb_error ? DMA_SB_ERR : (ic_error_start & ~dec_tlu_flush_lower_wb) ? IC_WFF : ECC_WFF;\n                  perr_state_en         =  ((((iccm_error_start  & ~dec_tlu_flush_lower_wb) | iccm_dma_sb_error) & fetch_tid_f2)  | (ic_error_start & ~dec_tlu_flush_lower_wb))& ~dec_tlu_force_halt;\n                  perr_sb_write_status  =  perr_state_en;\n         end\n         IC_WFF: begin : icache_wff    // All the I$ data and/or Tag errors ( parity/ECC ) will come to this state\n                  perr_nxtstate       =  ERR_IDLE ;\n                  perr_state_en       =  dec_tlu_flush_lower_wb | dec_tlu_force_halt;\n                  perr_sel_invalidate =  (dec_tlu_flush_err_wb &  dec_tlu_flush_lower_wb);\n         end\n         ECC_WFF: begin : ecc_wff\n                  perr_nxtstate       =  ((~dec_tlu_flush_err_wb &  dec_tlu_flush_lower_wb ) | dec_tlu_force_halt ) ? ERR_IDLE : ECC_CORR ;\n                  perr_state_en       =  dec_tlu_flush_lower_wb | dec_tlu_force_halt;\n         end\n         DMA_SB_ERR : begin : dma_sb_ecc\n                 perr_nxtstate       = dec_tlu_force_halt ? ERR_IDLE : ECC_CORR;\n                 perr_state_en       = 1'b1;\n         end\n         ECC_CORR: begin : ecc_corr\n                  perr_nxtstate       =  ERR_IDLE  ;\n                  perr_state_en       =   1'b1   ;\n         end\n         default: begin : def_case\n                  perr_nxtstate            = ERR_IDLE;\n                  perr_state_en            = 1'b0;\n                  perr_sb_write_status     = 1'b0;\n                  perr_sel_invalidate      = 1'b0;\n         end\n      endcase\n   end\n   rvdffs #(($bits(eh2_perr_state_t))) perr_state_ff (.clk(active_clk), .din(perr_nxtstate), .dout({perr_state}), .en(perr_state_en),   .*);\n\n   //////////////////////////////////// Create stop fetch State Machine /////////////////////////\n   //////////////////////////////////// Create stop fetch State Machine /////////////////////////\n   //////////////////////////////////// Create stop fetch State Machine /////////////////////////\n   //////////////////////////////////// Create stop fetch State Machine /////////////////////////\n   //////////////////////////////////// Create stop fetch State Machine /////////////////////////\n   always_comb begin  : ERROR_STOP_FETCH\n      err_stop_nxtstate            = ERR_STOP_IDLE;\n      err_stop_state_en            = 1'b0;\n      err_stop_fetch               = 1'b0;\n      iccm_correction_state        = 1'b0;\n      iccm_corr_scnd_fetch         = 1'b0;\n\n      case (err_stop_state)\n         ERR_STOP_IDLE: begin : err_stop_idle\n                  err_stop_nxtstate         =  ERR_FETCH1;\n                  err_stop_state_en         =  dec_tlu_flush_err_wb & (perr_state == ECC_WFF) & ~dec_tlu_force_halt;\n         end\n         ERR_FETCH1: begin : err_fetch1    // All the I$ data and/or Tag errors ( parity/ECC ) will come to this state\n                  err_stop_nxtstate       =  (dec_tlu_flush_lower_wb  | dec_tlu_i0_commit_cmt | iccm_rd_ecc_single_err | dec_tlu_force_halt) ? ERR_STOP_IDLE :\n                                                                                                                ((ifu_fetch_val_q_f2[1:0] == 2'b11) | (ifu_fetch_val_q_f2[0] & two_byte_instr_f2))  ?  ERR_STOP_FETCH : ifu_fetch_val_q_f2[0] ? ERR_FETCH2 :  ERR_FETCH1;\n                  err_stop_state_en       =   dec_tlu_flush_lower_wb  | dec_tlu_i0_commit_cmt | ifu_fetch_val_q_f2[0] | ifu_bp_hit_taken_q_f2 | dec_tlu_force_halt;\n                  err_stop_fetch          =   ((ifu_fetch_val_q_f2[1:0] == 2'b11) | (ifu_fetch_val_q_f2[0] & two_byte_instr_f2)) & ~((exu_flush_final & ~dec_tlu_flush_err_wb) | dec_tlu_i0_commit_cmt);\n                  iccm_correction_state   = 1'b1;\n                  iccm_corr_scnd_fetch    = err_stop_state_en  & (err_stop_nxtstate  ==  ERR_FETCH2);\n        end\n         ERR_FETCH2: begin : err_fetch2    // All the I$ data and/or Tag errors ( parity/ECC ) will come to this state\n                  err_stop_nxtstate       = (dec_tlu_flush_lower_wb | dec_tlu_i0_commit_cmt | iccm_rd_ecc_single_err | dec_tlu_force_halt) ? ERR_STOP_IDLE : ifu_fetch_val_q_f2[0] ?  ERR_STOP_FETCH : ERR_FETCH2;\n                  err_stop_state_en       =  dec_tlu_flush_lower_wb | dec_tlu_i0_commit_cmt | ifu_fetch_val_q_f2[0]  | dec_tlu_force_halt;\n                  err_stop_fetch          =  ifu_fetch_val_q_f2[0] & ~exu_flush_final & ~dec_tlu_i0_commit_cmt & ~dec_tlu_flush_lower_wb;\n                  iccm_correction_state   = 1'b1;\n                  iccm_corr_scnd_fetch    = 1'b1;\n         end\n         ERR_STOP_FETCH: begin : ecc_wff\n                  err_stop_nxtstate       = ((dec_tlu_flush_lower_wb & ~dec_tlu_flush_err_wb) | dec_tlu_i0_commit_cmt | dec_tlu_force_halt | (dec_tlu_flush_err_wb & (perr_state == IC_WFF))) ? ERR_STOP_IDLE : dec_tlu_flush_err_wb ? ERR_FETCH1 : ERR_STOP_FETCH ;\n                  err_stop_state_en       =  dec_tlu_flush_lower_wb  |  dec_tlu_i0_commit_cmt | dec_tlu_force_halt  ;\n                  err_stop_fetch          = 1'b1;\n                  iccm_correction_state   = 1'b1;\n\n         end\n         default: begin : def_case\n                  err_stop_nxtstate       = ERR_STOP_IDLE;\n                  err_stop_state_en       = 1'b0;\n                  err_stop_fetch          = 1'b0 ;\n                  iccm_correction_state   = 1'b0;\n\n         end\n      endcase\n   end\n   rvdffs #(($bits(eh2_err_stop_state_t))) err_stop_state_ff (.clk(active_clk), .din(err_stop_nxtstate), .dout({err_stop_state}), .en(err_stop_state_en),   .*);\n\n   // Create write signals so we can write to the miss-buffer directly from the bus.\n   assign bus_cmd_sent               = ifu_bus_arvalid     & ifu_bus_arready   & miss_pending & ifu_selected_miss_thr & ~dec_tlu_force_halt;\n   assign bus_inc_data_beat_cnt      = bus_ifu_wr_en_ff       & ~bus_last_data_beat & ~dec_tlu_force_halt;\n   assign bus_reset_data_beat_cnt    = ic_act_miss_f2         | (bus_ifu_wr_en_ff &  bus_last_data_beat) | dec_tlu_force_halt;\n   assign bus_hold_data_beat_cnt     = ~bus_inc_data_beat_cnt & ~bus_reset_data_beat_cnt ;\n\n   assign bus_new_data_beat_count[pt.ICACHE_BEAT_BITS-1:0] = ({pt.ICACHE_BEAT_BITS{bus_reset_data_beat_cnt}} & (pt.ICACHE_BEAT_BITS)'(0)) |\n                                                             ({pt.ICACHE_BEAT_BITS{bus_inc_data_beat_cnt}}   & (bus_data_beat_count[pt.ICACHE_BEAT_BITS-1:0] + {{pt.ICACHE_BEAT_BITS-1{1'b0}},1'b1})) |\n                                                             ({pt.ICACHE_BEAT_BITS{bus_hold_data_beat_cnt}}  &  bus_data_beat_count[pt.ICACHE_BEAT_BITS-1:0]);\n\n   rvdff #(pt.ICACHE_BEAT_BITS)  bus_mb_beat_count_ff (.*, .clk(active_clk), .din ({bus_new_data_beat_count[pt.ICACHE_BEAT_BITS-1:0]}), .dout({bus_data_beat_count[pt.ICACHE_BEAT_BITS-1:0]}));\n\n   assign last_data_recieved_in =  (bus_ifu_wr_en_ff &  bus_last_data_beat & ~scnd_miss_req) | (last_data_recieved_ff & ~ic_act_miss_f2) ;\n   rvdff #(1)  last_beat_ff (.*, .clk(active_clk), .din (last_data_recieved_in), .dout(last_data_recieved_ff));\n\n\n// Request Address Count\n   assign bus_inc_rd_addr_cnt     = bus_cmd_sent  ;\n   assign bus_set_rd_addr_cnt     = ic_act_miss_f2 | scnd_miss_req_ff2;\n   assign bus_hold_rd_addr_cnt    = ~bus_inc_rd_addr_cnt &  ~bus_set_rd_addr_cnt;\n\n\n   assign bus_new_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0] = (~miss_pending                    ) ? imb_ff[pt.ICACHE_BEAT_ADDR_HI:3] :\n                                                           (                scnd_miss_req_q  ) ? imb_scnd_ff[pt.ICACHE_BEAT_ADDR_HI:3] :\n                                                           ( bus_cmd_sent                    ) ? (bus_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0] + 3'b001) :\n                                                                                                  bus_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0];\n\n   rvdff_fpga #(pt.ICACHE_BEAT_BITS)  bus_rd_addr_ff (.*,  .clk(busclk_reset),  .clken(bus_ifu_bus_clk_en | ic_act_miss_f2 | dec_tlu_force_halt), .rawclk(clk), .din ({bus_new_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0]}), .dout({bus_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0]}));\n\n\n\n// command beat Count\n   assign bus_inc_cmd_beat_cnt              =  ifu_bus_cmd_valid    &  ifu_bus_cmd_ready & miss_pending & (selected_miss_thr == tid) & ~dec_tlu_force_halt;\n   assign bus_reset_cmd_beat_cnt_0          =  (ic_act_miss_f2       & ~uncacheable_miss_in) | dec_tlu_force_halt ;\n   assign bus_reset_cmd_beat_cnt_secondlast =  (ic_act_miss_f2       &  uncacheable_miss_in)                      ;\n   assign bus_hold_cmd_beat_cnt             = ~bus_inc_cmd_beat_cnt & ~(ic_act_miss_f2 | scnd_miss_req | dec_tlu_force_halt) ;\n   assign bus_cmd_beat_en                   = bus_inc_cmd_beat_cnt | ic_act_miss_f2 | dec_tlu_force_halt;\n\n   assign bus_new_cmd_beat_count[pt.ICACHE_BEAT_BITS-1:0] =  ({pt.ICACHE_BEAT_BITS{bus_reset_cmd_beat_cnt_0}}       & (pt.ICACHE_BEAT_BITS)'(0) ) |\n                                                          ({pt.ICACHE_BEAT_BITS{bus_reset_cmd_beat_cnt_secondlast}} & (pt.ICACHE_BEAT_BITS)'(pt.ICACHE_SCND_LAST)) |\n                                                          ({pt.ICACHE_BEAT_BITS{bus_inc_cmd_beat_cnt}}              & (bus_cmd_beat_count[pt.ICACHE_BEAT_BITS-1:0] + {{pt.ICACHE_BEAT_BITS-1{1'b0}}, 1'b1})) |\n                                                          ({pt.ICACHE_BEAT_BITS{bus_hold_cmd_beat_cnt}}             &  bus_cmd_beat_count[pt.ICACHE_BEAT_BITS-1:0]) ;\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign busclk_reset = 1'b0;\n`else\n   rvclkhdr bus_clk_reset(.en(bus_ifu_bus_clk_en | ic_act_miss_f2 | dec_tlu_force_halt),\n                   .l1clk(busclk_reset), .*);\n`endif\n\n\n\n\n   rvdffs_fpga #(pt.ICACHE_BEAT_BITS)  bus_cmd_beat_ff (.*, .clk(busclk_reset),  .clken(bus_ifu_bus_clk_en | ic_act_miss_f2 | dec_tlu_force_halt), .rawclk(clk), .en (bus_cmd_beat_en), .din ({bus_new_cmd_beat_count[pt.ICACHE_BEAT_BITS-1:0]}),\n                    .dout({bus_cmd_beat_count[pt.ICACHE_BEAT_BITS-1:0]}));\n\n   assign    req_addr_count[pt.ICACHE_BEAT_BITS-1:0]    = bus_rd_addr_count[pt.ICACHE_BEAT_BITS-1:0] ;\n\n\n\n    assign bus_last_data_beat     =  uncacheable_miss_ff ? (bus_data_beat_count[pt.ICACHE_BEAT_BITS-1:0] == {{pt.ICACHE_BEAT_BITS-1{1'b0}},1'b1}) : (&bus_data_beat_count[pt.ICACHE_BEAT_BITS-1:0]);\n\n   assign  bus_ifu_wr_en            =  ifu_bus_rvalid     & miss_pending & (ifu_bus_rsp_tag[pt.IFU_BUS_TAG-1] == tid);\n   assign  bus_ifu_wr_en_ff         =  ifu_bus_rvalid_ff  & miss_pending & rsp_miss_thr_ff;\n   assign  bus_ifu_wr_en_ff_q       =  ifu_bus_rvalid_ff  & miss_pending & rsp_miss_thr_ff & ~uncacheable_miss_ff & ~(|ifu_bus_rresp_ff[1:0]) & write_ic_16_bytes; // qualify with no-error conditions ;\n   assign  bus_ifu_wr_en_ff_wo_err  =  ifu_bus_rvalid_ff  & miss_pending & rsp_miss_thr_ff & ~uncacheable_miss_ff;\n\n\n   rvdff #(1)  act_miss_ff (.*, .clk(active_clk), .din (ic_act_miss_f2), .dout(ic_act_miss_f2_delayed));\n   assign    reset_tag_valid_for_miss = ((ic_act_miss_f2_delayed & (miss_state == CRIT_BYP_OK)) | ifu_miss_state_pre_crit_ff) & ~uncacheable_miss_ff  ;\n   assign    bus_ifu_wr_data_error    = |ifu_bus_rsp_opc[1:0]  &  ifu_bus_rvalid     & miss_pending & (ifu_bus_rsp_tag[pt.IFU_BUS_TAG-1] == tid);\n   assign    bus_ifu_wr_data_error_ff = |ifu_bus_rresp_ff[1:0] &  ifu_bus_rvalid_ff  & miss_pending & rsp_miss_thr_ff;\n\n\n   assign ic_crit_wd_rdy   =  ic_crit_wd_rdy_new_in | ic_crit_wd_rdy_new_ff;\n   assign last_beat        =  bus_last_data_beat & bus_ifu_wr_en_ff;\n   assign reset_beat_cnt    = bus_reset_data_beat_cnt ;\n\n   assign ic_hit_f2             =  ic_act_hit_f2 |\n                                   ic_byp_hit_f2 |\n                                   ic_iccm_hit_f2 |\n                                   (ifc_region_acc_fault_f2 & ifc_fetch_req_f2 & ~((miss_state == CRIT_BYP_OK) | (miss_state == DUPL_MISS_WAIT) | (miss_state == PRE_CRIT_BYP)));\n\n\n  assign ifu_wr_data_comb_err       =  bus_ifu_wr_data_error_ff ;\n  assign ifu_wr_cumulative_err      = (ifu_wr_data_comb_err | ifu_wr_data_comb_err_ff) & ~reset_beat_cnt;\n  assign ifu_wr_cumulative_err_data =  ifu_wr_data_comb_err | ifu_wr_data_comb_err_ff ;\n\n  rvdff #(1) cumul_err_ff (.*, .clk(active_clk),  .din (ifu_wr_cumulative_err), .dout(ifu_wr_data_comb_err_ff));\n\n\n   assign   ic_rd_en    =  (ifc_fetch_req_tid_q_f1 & ~ifc_fetch_uncacheable_f1 & ~ifc_iccm_access_f1 ) |\n                           (exu_flush_final  & ~ifc_fetch_uncacheable_f1 & ~ifc_iccm_access_f1 )     ;\n\n   assign  ic_real_rd_wp  =  (ifc_fetch_req_tid_q_f1 &  ~ifc_iccm_access_f1  &  ~ifc_region_acc_fault_final_f1 & ~dec_tlu_fence_i_wb & ~stream_miss_f2 & ~ic_act_miss_f2 &\n                               ~ic_miss_under_miss_killf1_f2 &\n                               ~(((miss_state == STREAM) & ~miss_state_en) |\n                              ((miss_state == CRIT_BYP_OK) & ~miss_state_en & ~(miss_nxtstate == MISS_WAIT)) |\n                              ((miss_state == MISS_WAIT) & ~miss_state_en) |\n                              ((miss_state == STALL_SCND_MISS) & ~miss_state_en)  |\n                              ((miss_state == CRIT_WRD_RDY) & ~miss_state_en)  |\n                              ((miss_nxtstate == STREAM) &  miss_state_en)  |\n                              ((miss_nxtstate == DUPL_MISS_WAIT) &  miss_state_en)  |\n                              ((miss_state == SCND_MISS) & ~miss_state_en))) |\n                          (ifc_fetch_req_tid_q_f1 &  ~ifc_iccm_access_f1  &  ~ifc_region_acc_fault_final_f1 & ~dec_tlu_fence_i_wb & ~stream_miss_f2 & exu_flush_final);\n\n\n\n\n\n    assign ic_wr_en[pt.ICACHE_NUM_WAYS-1:0] = bus_ic_wr_en[pt.ICACHE_NUM_WAYS-1:0] & {pt.ICACHE_NUM_WAYS{write_ic_16_bytes}};\n   assign ic_write_stall_self              =  write_ic_16_bytes &  ~(((miss_state== CRIT_BYP_OK) & ~(bus_ifu_wr_en_ff & last_beat & ~uncacheable_miss_ff))) &\n                                                                   ~(((miss_state==STREAM)       & ~(bus_ifu_wr_en_ff & last_beat & ~uncacheable_miss_ff) & ~(exu_flush_final | ifu_bp_hit_taken_q_f2 | stream_eol_f2)));\n   assign ic_write_stall_other             =  write_ic_16_bytes & ~uncacheable_miss_ff;   // if this thread is writing - it must block the other thread from accessing the cache.\n\n\n    assign iccm_stop_fetch = (err_stop_state == ERR_STOP_FETCH) | err_stop_fetch;\n    assign ic_dma_active   = iccm_correct_ecc | (perr_state == DMA_SB_ERR) |\n                             dec_tlu_flush_err_wb; // The last term is to give a error-correction a chance to finish before refetch starts\n\n    assign scnd_miss_req_in     = ifu_bus_rsp_valid & bus_ifu_bus_clk_en & ifu_bus_rsp_ready & (ifu_bus_rsp_tag[pt.IFU_BUS_TAG-1] == tid) &\n                                 (&bus_new_data_beat_count[pt.ICACHE_BEAT_BITS-1:0]) &\n                                 ~uncacheable_miss_ff &  ((miss_state == SCND_MISS) | (miss_nxtstate == SCND_MISS)) & ~exu_flush_final;\n\n   rvdff #(1)           scnd_mss_req_ff  (.*, .clk(active_clk), .din(scnd_miss_req_in),   .dout(scnd_miss_req_q));\n   rvdff #(1)           scnd_mss_req_ff2 (.*, .clk(active_clk), .din(scnd_miss_req),      .dout(scnd_miss_req_ff2));\n   assign  scnd_miss_req = scnd_miss_req_q & ~exu_flush_final;\n\n  assign sel_byp_data     =  (ic_crit_wd_rdy_new_ff | (miss_state == STREAM) | (miss_state == CRIT_BYP_OK)) ; // & ~ifu_byp_data_err_new;\n  assign sel_ic_data      = ~(ic_crit_wd_rdy_new_ff | (miss_state == STREAM) | (miss_state == CRIT_BYP_OK) | (miss_state == DUPL_MISS_WAIT)) & ~fetch_req_iccm_tid_f2 ;\n\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign busclk_force = 1'b0;\n`else\n   rvclkhdr bus_clk(.en(bus_ifu_bu"}
{"text": "s_clk_en | dec_tlu_force_halt), .l1clk(busclk_force), .*);\n`endif\n\n\n   assign  ifc_bus_ic_req_ff_in  = (ic_act_miss_f2 | bus_cmd_req_hold | ifu_bus_cmd_valid) & ~dec_tlu_force_halt & ~((bus_cmd_beat_count== {pt.ICACHE_BEAT_BITS{1'b1}}) & ifu_bus_cmd_valid & ifu_bus_cmd_ready & miss_pending & (selected_miss_thr == tid));\n   rvdff_fpga #(1) bus_ic_req_ff2(.*, .clk(busclk_force),  .clken(bus_ifu_bus_clk_en | dec_tlu_force_halt), .rawclk(clk),  .din(ifc_bus_ic_req_ff_in), .dout(ifu_bus_cmd_valid));\n\n   assign    bus_cmd_req_in  = (ic_act_miss_f2 | bus_cmd_req_hold) & ~bus_cmd_sent & ~dec_tlu_force_halt  ; // hold until first command sent\n   // changes for making the bus blocking\n   rvdff #(1)  bus_cmd_req_ff  (.*,  .clk(active_clk), .din(bus_cmd_req_in), .dout(bus_cmd_req_hold));\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////\n\n   logic              iccm_ecc_write_status     ;\n   logic              iccm_rd_ecc_single_err_hold_in ;\n   logic              iccm_rd_ecc_single_err_ff;\n\n   assign iccm_ecc_write_status           = (((iccm_rd_ecc_single_err & ~iccm_rd_ecc_single_err_ff)  & ~exu_flush_final & fetch_tid_f2) | (iccm_dma_sb_error & fetch_tid_f2));\n   assign iccm_rd_ecc_single_err_hold_in  =   ((iccm_rd_ecc_single_err & fetch_tid_f2) | iccm_rd_ecc_single_err_ff) & ~exu_flush_final ;\n\n   rvdff  #((1))             ecc_rr_ff     (.clk(active_clk),     .din(iccm_rd_ecc_single_err_hold_in),           .dout(iccm_rd_ecc_single_err_ff),               .*);\n   rvdffs #((32))            ecc_dat0_ff   (.clk(active_clk),     .din(iccm_corrected_data_f2_mux[31:0]),         .dout(iccm_ecc_corr_data_ff[31:0]),             .en(iccm_ecc_write_status),  .*);\n   rvdffs #((7))             ecc_dat1_ff   (.clk(active_clk),     .din(iccm_corrected_ecc_f2_mux[6:0]),           .dout(iccm_ecc_corr_data_ff[38:32]),            .en(iccm_ecc_write_status),  .*);\n   rvdffs #((pt.ICCM_BITS-2))ecc_ind0_ff   (.clk(active_clk),     .din(iccm_ecc_corr_index_in[pt.ICCM_BITS-1:2]), .dout(iccm_ecc_corr_index_ff[pt.ICCM_BITS-1:2]),.en(iccm_ecc_write_status),  .*);\n\n\n\n\n\n\n\n\n\n\n\n///////////////////////////////////// END END Threaded ///////////////////////////////////////////\n///////////////////////////////////// END END Threaded ///////////////////////////////////////////\n///////////////////////////////////// END END Threaded ///////////////////////////////////////////\n///////////////////////////////////// END END Threaded ///////////////////////////////////////////\n///////////////////////////////////// END END Threaded ///////////////////////////////////////////\n///////////////////////////////////// END END Threaded ///////////////////////////////////////////\n///////////////////////////////////// END END Threaded ///////////////////////////////////////////\n///////////////////////////////////// END END Threaded ///////////////////////////////////////////\n///////////////////////////////////// END END Threaded ///////////////////////////////////////////\n\nendmodule // eh2_ifu_mem_ctl_thr\n\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\nmodule eh2_ifu_tb_memread;\n\n   logic [15:0] compressed [0:128000]; // vector of compressed instructions\n   logic [31:0] expected [0:128000];   // vector of correspoding expected instruction\n\n\n   logic        rst_l;\n   logic        clk;\n\n   int          clk_count;\n\n\n\n   logic [31:0] expected_val;\n   logic [15:0] compressed_din;\n\n   logic [31:0] actual;\n\n   logic        error;\n\n   integer      i;\n   initial begin\n\n      clk=0;\n      rst_l=0;\n\n      // initialize the reads and populate the istruction arrays\n      $readmemh (\"left64k\", compressed );\n      $readmemh (\"right64k\", expected );\n\n      $dumpfile (\"top.vcd\");\n      $dumpvars;\n      $dumpon;\n\n   end\n\n   always #50 clk =~clk;\n\n   always @(posedge clk) begin\n      clk_count = clk_count +1;\n      if (clk_count>=1 & clk_count<=3) rst_l <= 1'b0;\n      else rst_l <= 1'b1;\n\n      if (clk_count > 3) begin\n\n         compressed_din[15:0] <= compressed[clk_count-3]; // c.mv\n         expected_val[31:0] <= expected[clk_count-3];\n\n      end\n\n      if (clk_count == 65000) begin\n         $dumpoff;\n         $finish;\n      end\n   end // always @ (posedge clk)\n\n   always @(negedge clk) begin\n      if (clk_count > 3 & error) begin\n         $display(\"clock: %d compressed %h error actual %h expected %h\",clk_count,compressed_din,actual,expected_val);\n      end\n   end\n\n\n   eh2_ifu_compress_ctl align (.*,.din(compressed_din[15:0]),.dout(actual[31:0]));\n\n   assign error = actual[31:0] != expected_val[31:0];\n\n\nendmodule // eh2_ifu_tb_memread\n"}
{"text": "module eh2_btb_tag_hash #(\n`include \"eh2_param.vh\"\n ) (\n                       input logic [pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1] pc,\n                       output logic [pt.BTB_BTAG_SIZE-1:0] hash\n                       );\n\n    assign hash = {(pc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE+1] ^\n                   pc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+1] ^\n                   pc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1])};\nendmodule\n\nmodule eh2_btb_tag_hash_fold  #(\n`include \"eh2_param.vh\"\n )(\n                       input logic [pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1] pc,\n                       output logic [pt.BTB_BTAG_SIZE-1:0] hash\n                       );\n\n    assign hash = {(\n                   pc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE+1] ^\n                   pc[pt.BTB_ADDR_HI+pt.BTB_BTAG_SIZE:pt.BTB_ADDR_HI+1])};\n\nendmodule\n\nmodule eh2_btb_addr_hash  #(\n`include \"eh2_param.vh\"\n )(\n                        input logic [pt.BTB_INDEX3_HI:pt.BTB_INDEX1_LO] pc,\n                        output logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] hash\n                        );\n\n\nif(pt.BTB_FOLD2_INDEX_HASH) begin : fold2\n   assign hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = pc[pt.BTB_INDEX1_HI:pt.BTB_INDEX1_LO] ^\n                                                pc[pt.BTB_INDEX3_HI:pt.BTB_INDEX3_LO];\nend\n   else begin\n\n      // overload bit pc[3] onto last bit of hash for sram case\n      if(pt.BTB_USE_SRAM) begin\n        assign hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO+1] = pc[pt.BTB_INDEX1_HI:pt.BTB_INDEX1_LO+1] ^\n                                                       pc[pt.BTB_INDEX2_HI:pt.BTB_INDEX2_LO] ^\n                                                       pc[pt.BTB_INDEX3_HI:pt.BTB_INDEX3_LO];\n         assign hash[3] = pc[3];\n      end\n\n      else\n\n        assign hash[pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] = pc[pt.BTB_INDEX1_HI:pt.BTB_INDEX1_LO] ^\n                                                     pc[pt.BTB_INDEX2_HI:pt.BTB_INDEX2_LO] ^\n                                                     pc[pt.BTB_INDEX3_HI:pt.BTB_INDEX3_LO];\nend\n\nendmodule\n\n\nmodule eh2_btb_ghr_hash  #(\n`include \"eh2_param.vh\"\n )(\n                       input logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] hashin,\n                       input logic [pt.BHT_GHR_SIZE-1:0] ghr,\n                       output logic [pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] hash\n                       );\n\n   if(pt.BHT_GHR_HASH_1) begin : ghrhash_cfg1\n     assign hash[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = { ghr[pt.BHT_GHR_SIZE-1:pt.BTB_INDEX1_HI-2], hashin[pt.BTB_INDEX1_HI:3]^ghr[pt.BTB_INDEX1_HI-3:0]};\n//     assign hash[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = {ghr[8:7], hashin[pt.BTB_INDEX1_HI:3]^ghr[6:0]};\n   end\n   else begin : ghrhash_cfg2\n// this makes more sense but is lower perf on dhrystone\n//     assign hash[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = { hashin[pt.BHT_GHR_SIZE+2:3]^ghr[pt.BHT_GHR_SIZE-1:0]};\n     assign hash[pt.BHT_ADDR_HI:pt.BHT_ADDR_LO] = { hashin[pt.BHT_GHR_SIZE+2:5]^ghr[pt.BHT_GHR_SIZE-1:2], ghr[1:0]};\n   end\n\n\nendmodule\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Function: Top level file for load store unit\n// Comments:\n//\n//\n// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n//\n//********************************************************************************\n\nmodule eh2_lsu\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)(\n\n   input logic [31:0]                      i0_result_e4_eff, // I0 e4 result for e4 -> dc3 store forwarding\n   input logic [31:0]                      i1_result_e4_eff, // I1 e4 result for e4 -> dc3 store forwarding\n   input logic [31:0]                      i0_result_e2,     // I0 e2 result for e2 -> dc2 store forwarding\n\n   input logic [pt.NUM_THREADS-1:0]        flush_final_e3,            // I0/I1 flush in e3\n   input logic [pt.NUM_THREADS-1:0]        i0_flush_final_e3,         // I0 flush in e3\n   input logic [pt.NUM_THREADS-1:0]        dec_tlu_flush_lower_wb,    // I0/I1 writeback flush. This is used to flush the old packets only\n   input logic                             dec_tlu_i0_kill_writeb_wb, // I0 is flushed, don't writeback any results to arch state\n   input logic                             dec_tlu_i1_kill_writeb_wb, // I1 is flushed, don't writeback any results to arch state\n   input logic [pt.NUM_THREADS-1:0]        dec_tlu_lr_reset_wb,\n   input logic [pt.NUM_THREADS-1:0]        dec_tlu_force_halt,\n\n   input logic                             dec_tlu_external_ldfwd_disable,     // disable load to load forwarding for externals\n   input logic                             dec_tlu_wb_coalescing_disable,      // disable the write buffer coalesce\n   input logic                             dec_tlu_sideeffect_posted_disable,  // disable posted writes to sideeffect addr to the bus\n   input logic                             dec_tlu_core_ecc_disable,           // disable the generation of the ecc\n\n   input logic [31:0]                      exu_lsu_rs1_d,      // address rs operand\n   input logic [31:0]                      exu_lsu_rs2_d,      // store data\n   input logic [11:0]                      dec_lsu_offset_d,   // address offset operand\n\n   input                                   eh2_lsu_pkt_t lsu_p,     // lsu control packet\n   input logic [31:0]                      dec_tlu_mrac_ff,     // CSR for memory region control\n\n   output logic [31:0]                     lsu_result_dc3,      // lsu load data\n   output logic [31:0]                     lsu_result_corr_dc4, // This is the ECC corrected data going to RF\n   output logic                            lsu_fastint_stall_any, // Stall fast interrupts at decode-1\n   output logic                            lsu_sc_success_dc5,  // the store condition result ( 1 :\n\n   output logic [pt.NUM_THREADS-1:0]       lsu_store_stall_any, // This is for blocking stores in the decode\n   output logic [pt.NUM_THREADS-1:0]       lsu_load_stall_any,  // This is for blocking loads in the decode\n   output logic [pt.NUM_THREADS-1:0]       lsu_amo_stall_any,   // This is for blocking amo in the decode\n   output logic [pt.NUM_THREADS-1:0]       lsu_idle_any,        // This is used to enter halt mode. Exclude DMA\n   output logic                            lsu_active,          // Used for clock gating\n\n   output logic [31:1]                     lsu_fir_addr,        // fast interrupt address\n   output logic [1:0]                      lsu_fir_error,       // Error during fast interrupt lookup\n\n   output eh2_lsu_error_pkt_t             lsu_error_pkt_dc3,             // lsu exception packet\n   output logic                            lsu_single_ecc_error_incr,     // Increment the ecc error counter\n   output logic [pt.NUM_THREADS-1:0]       lsu_imprecise_error_load_any,  // bus load imprecise error\n   output logic [pt.NUM_THREADS-1:0]       lsu_imprecise_error_store_any, // bus store imprecise error\n   output logic [pt.NUM_THREADS-1:0][31:0] lsu_imprecise_error_addr_any,  // bus store imprecise error address\n\n   // Non-blocking loads\n   output logic                                lsu_nonblock_load_valid_dc1,    // there is an external load -> put in the cam\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_tag_dc1,      // the tag of the external non block load\n   output logic                                lsu_nonblock_load_inv_dc2,      // Invalidate the non-block load bcoz of memory forwarding\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_inv_tag_dc2,\n   output logic                                lsu_nonblock_load_inv_dc5,      // invalidate signal for the cam entry for non block loads\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_inv_tag_dc5,  // tag of the enrty which needs to be invalidated\n   output logic                                lsu_nonblock_load_data_valid,   // the non block is valid - sending information back to the cam\n   output logic                                lsu_nonblock_load_data_error,   // non block load has an error\n   output logic                               lsu_nonblock_load_data_tid,      // tid for nonblock load return\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]  lsu_nonblock_load_data_tag,     // the tag of the non block load sending the data/error\n   output logic [31:0]                         lsu_nonblock_load_data,         // Data of the non block load\n\n   output logic [pt.NUM_THREADS-1:0]       lsu_pmu_load_external_dc3,      // PMU : Load to the bus\n   output logic [pt.NUM_THREADS-1:0]       lsu_pmu_store_external_dc3,     // PMU : Load to the bus\n   output logic [pt.NUM_THREADS-1:0]       lsu_pmu_misaligned_dc3,         // PMU : misaligned\n   output logic [pt.NUM_THREADS-1:0]       lsu_pmu_bus_trxn,               // PMU : bus transaction\n   output logic [pt.NUM_THREADS-1:0]       lsu_pmu_bus_misaligned,         // PMU : misaligned access going to the bus\n   output logic [pt.NUM_THREADS-1:0]       lsu_pmu_bus_error,              // PMU : bus sending error back\n   output logic [pt.NUM_THREADS-1:0]       lsu_pmu_bus_busy,               // PMU : bus is not ready\n\n   output logic [31:0]                     lsu_rs1_dc1,\n\n   // Trigger signals\n   input eh2_trigger_pkt_t [pt.NUM_THREADS-1:0][3:0] trigger_pkt_any, // Trigger info from the decode\n   output logic [3:0]                      lsu_trigger_match_dc4,                    // lsu trigger hit (one bit per trigger)\n\n   // DCCM ports\n   output logic                            dccm_wren,       // DCCM write enable\n   output logic                            dccm_rden,       // DCCM read enable\n   output logic [pt.DCCM_BITS-1:0]         dccm_wr_addr_lo, // DCCM write address low bankd\n   output logic [pt.DCCM_BITS-1:0]         dccm_wr_addr_hi, // DCCM write address low bankd\n   output logic [pt.DCCM_BITS-1:0]         dccm_rd_addr_lo, // DCCM read address low bank\n   output logic [pt.DCCM_BITS-1:0]         dccm_rd_addr_hi, // DCCM read address hi bank (hi and low same if aligned read)\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_lo, // DCCM write data for hi bank\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_hi, // DCCM write data for hi bank\n\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]   dccm_rd_data_lo, // DCCM read data low bank\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]   dccm_rd_data_hi, // DCCM read data hi bank\n\n   // PIC ports\n   output logic                            picm_wren,        // PIC memory write enable\n   output logic                            picm_rden,        // PIC memory read enable\n   output logic                            picm_mken,        // Need to read the mask for stores to determine which bits to write/forward\n   output logic                            picm_rd_thr,      // PICM read thread\n   output logic [31:0]                     picm_rdaddr,      // PIC memory address\n   output logic [31:0]                     picm_wraddr,      // PIC memory address\n   output logic [31:0]                     picm_wr_data,     // PIC memory write data\n   input logic [31:0]                      picm_rd_data,     // PIC memory read/mask data\n\n   //-------------------------- LSU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            lsu_axi_awvalid,\n   input  logic                            lsu_axi_awready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_awid,\n   output logic [31:0]                     lsu_axi_awaddr,\n   output logic [3:0]                      lsu_axi_awregion,\n   output logic [7:0]                      lsu_axi_awlen,\n   output logic [2:0]                      lsu_axi_awsize,\n   output logic [1:0]                      lsu_axi_awburst,\n   output logic                            lsu_axi_awlock,\n   output logic [3:0]                      lsu_axi_awcache,\n   output logic [2:0]                      lsu_axi_awprot,\n   output logic [3:0]                      lsu_axi_awqos,\n\n   output logic                            lsu_axi_wvalid,\n   input  logic                            lsu_axi_wready,\n   output logic [63:0]                     lsu_axi_wdata,\n   output logic [7:0]                      lsu_axi_wstrb,\n   output logic                            lsu_axi_wlast,\n\n   input  logic                            lsu_axi_bvalid,\n   output logic                            lsu_axi_bready,\n   input  logic [1:0]                      lsu_axi_bresp,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_bid,\n\n   // AXI Read Channels\n   output logic                            lsu_axi_arvalid,\n   input  logic                            lsu_axi_arready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_arid,\n   output logic [31:0]                     lsu_axi_araddr,\n   output logic [3:0]                      lsu_axi_arregion,\n   output logic [7:0]                      lsu_axi_arlen,\n   output logic [2:0]                      lsu_axi_arsize,\n   output logic [1:0]                      lsu_axi_arburst,\n   output logic                            lsu_axi_arlock,\n   output logic [3:0]                      lsu_axi_arcache,\n   output logic [2:0]                      lsu_axi_arprot,\n   output logic [3:0]                      lsu_axi_arqos,\n\n   input  logic                            lsu_axi_rvalid,\n   output logic                            lsu_axi_rready,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_rid,\n   input  logic [63:0]                     lsu_axi_rdata,\n   input  logic [1:0]                      lsu_axi_rresp,\n   input  logic                            lsu_axi_rlast,\n\n   input logic                             lsu_bus_clk_en,    // external drives a clock_en to control bus ratio\n\n   // DMA slave\n   input logic                             dma_dccm_req,       // DMA read/write to dccm\n   input logic                             dma_dccm_spec_req,  // DMA spec_read/write to dccm\n   input logic                             dma_mem_addr_in_dccm,   // DMA address is in dccm\n   input logic [2:0]                       dma_mem_tag,        // DMA request tag\n   input logic [31:0]                      dma_mem_addr,       // DMA address\n   input logic [2:0]                       dma_mem_sz,         // DMA access size\n   input logic                             dma_mem_write,      // DMA access is a write\n   input logic [63:0]                      dma_mem_wdata,      // DMA write data\n\n   output logic                            dccm_dma_rvalid,     // lsu data valid for DMA dccm read\n   output logic                            dccm_dma_ecc_error,  // DMA load had ecc error\n   output logic [2:0]                      dccm_dma_rtag,       // DMA return tag\n   output logic [63:0]                     dccm_dma_rdata,      // lsu data for DMA dccm read\n   output logic                            dccm_ready,          // lsu ready for DMA access\n\n   input logic                             clk_override,        // Disable clock gating\n   input logic                             scan_mode,           // scan\n   input logic                             clk,\n   input logic                             active_clk,\n   input logic                             free_clk,\n   input logic [pt.NUM_THREADS-1:0]        active_thread_l2clk, // Per thread l2 clock\n   input logic                             rst_l\n\n   );\n\n   logic [31:0] lsu_addr_dc1;\n   logic        lsu_dccm_rden_dc3;\n   logic [31:0] store_data_dc3;\n   logic [31:0] store_data_pre_dc3;\n   logic [31:0] store_ecc_data_hi_dc3;          // final store data either from store_data or SEC DCCM readout - not STBUF FWD\n   logic [31:0] store_ecc_data_lo_dc3;\n   logic [pt.DCCM_DATA_WIDTH-1:0] sec_data_hi_dc3;\n   logic [pt.DCCM_DATA_WIDTH-1:0] sec_data_lo_dc3;\n   logic        disable_ecc_check_lo_dc3;\n   logic        disable_ecc_check_hi_dc3;\n\n   logic [pt.DCCM_DATA_WIDTH-1:0] sec_data_hi_dc5, sec_data_lo_dc5;\n\n   logic        ld_single_ecc_error_dc3, ld_single_ecc_error_dc5, ld_single_ecc_error_dc5_ff;\n   logic        ld_single_ecc_error_lo_dc5_ff, ld_single_ecc_error_hi_dc5_ff;\n   logic        single_ecc_error_hi_dc3, single_ecc_error_lo_dc3;\n   logic        single_ecc_error_hi_dc4, single_ecc_error_lo_dc4;\n   logic        single_ecc_error_hi_dc5, single_ecc_error_lo_dc5;\n   logic        lsu_single_ecc_error_dc3, lsu_single_ecc_error_dc5;\n   logic        lsu_double_ecc_error_dc3, lsu_double_ecc_error_dc5;\n   logic        access_fault_dc3;\n   logic        misaligned_fault_dc3;\n\n   logic [31:0] dccm_data_hi_dc3;\n   logic [31:0] dccm_data_lo_dc3;\n   logic [31:0] dccm_datafn_hi_dc5;\n   logic [31:0] dccm_datafn_lo_dc5;\n   logic [6:0]  dccm_data_ecc_hi_dc3;\n   logic [6:0]  dccm_data_ecc_lo_dc3;\n   logic [63:0] store_data_ext_dc3, store_data_ext_dc4, store_data_ext_dc5;\n\n   logic [31:0] lsu_dccm_data_dc3;\n   logic [31:0] lsu_dccm_data_corr_dc3;\n   logic [31:0] picm_mask_data_dc3;\n   logic [31:0] picm_rd_data_dc3;\n\n   logic [31:0] lsu_addr_dc2, lsu_addr_dc3, lsu_addr_dc4, lsu_addr_dc5;\n   logic [31:0] end_addr_dc1, end_addr_dc2, end_addr_dc3, end_addr_dc4, end_addr_dc5;\n   logic        core_ldst_dual_dc1;\n   logic        ldst_dual_dc2, ldst_dual_dc3, ldst_dual_dc4, ldst_dual_dc5;\n\n\n   eh2_lsu_pkt_t  lsu_pkt_dc1_pre, lsu_pkt_dc1, lsu_pkt_dc2, lsu_pkt_dc3, lsu_pkt_dc4, lsu_pkt_dc5;\n\n   // Store Buffer signals\n   logic        store_stbuf_reqvld_dc5;\n   logic        lsu_commit_dc5;\n\n   logic        addr_in_dccm_region_dc1;     // address in dccm region\n   logic        addr_in_dccm_dc1, addr_in_dccm_dc2, addr_in_dccm_dc3, addr_in_dccm_dc4, addr_in_dccm_dc5;\n   logic        addr_in_pic_dc1, addr_in_pic_dc2, addr_in_pic_dc3, addr_in_pic_dc4, addr_in_pic_dc5;\n   logic        addr_external_dc1, addr_external_dc3;\n\n   logic                          stbuf_reqvld_any;\n   logic                          stbuf_reqvld_flushed_any;\n   logic [pt.LSU_SB_BITS-1:0]     stbuf_addr_any;\n   logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_data_any;\n\n   logic                          lsu_cmpen_dc2;\n   logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_fwddata_hi_dc3;\n   logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_fwddata_lo_dc3;\n   logic [pt.DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_hi_dc3;\n   logic [pt.DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_lo_dc3;\n\n   logic                          picm_fwd_en_dc2;\n   logic [31:0]                   picm_fwd_data_dc2;\n\n   logic                       lsu_stbuf_commit_any;\n   logic [pt.NUM_THREADS-1:0]  lsu_stbuf_empty_any;   // This is for blocking loads\n   logic [pt.NUM_THREADS-1:0]  lsu_stbuf_full_any;\n\n    // Bus signals\n   logic        lsu_busreq_dc1, lsu_busreq_dc2, lsu_busreq_dc3, lsu_busreq_dc4, lsu_busreq_dc5;\n   logic [pt.NUM_THREADS-1:0]  lsu_bus_idle_any;\n   logic [pt.NUM_THREADS-1:0]  lsu_bus_buffer_pend_any;\n   logic [pt.NUM_THREADS-1:0]  lsu_bus_buffer_empty_any;\n   logic [pt.NUM_THREADS-1:0]  lsu_bus_buffer_full_any;\n   logic [pt.NUM_THREADS-1:0]  dec_tlu_force_halt_bus;           // Bus synchronized version of force halt\n   logic [31:0] bus_read_data_dc3;\n\n   logic [pt.NUM_THREADS-1:0]  flush_dc2_up, flush_dc3, flush_dc4, flush_dc5;\n   logic        is_sideeffects_dc2, is_sideeffects_dc3;\n   logic        ldst_nodma_dc2todc5;\n   logic        dma_dccm_wen, dma_dccm_spec_wen, dma_pic_wen;\n   logic [2:0]  dma_mem_tag_dc1, dma_mem_tag_dc2, dma_mem_tag_dc3;\n   logic [31:0] dma_start_addr_dc1, dma_end_addr_dc1;\n   logic [31:0] dma_dccm_wdata_hi, dma_dccm_wdata_lo;\n\n   // Clocks\n   logic        lsu_busm_clken;\n   logic [pt.NUM_THREADS-1:0] lsu_bus_obuf_c1_clken;\n   logic        lsu_c1_dc1_clk, lsu_c1_dc2_clk, lsu_c1_dc3_clk, lsu_c1_dc4_clk, lsu_c1_dc5_clk;\n   logic        lsu_c2_dc1_clk, lsu_c2_dc2_clk, lsu_c2_dc3_clk, lsu_c2_dc4_clk, lsu_c2_dc5_clk;\n   logic        lsu_c1_dc1_clken, lsu_c1_dc2_clken, lsu_c1_dc3_clken, lsu_c1_dc4_clken, lsu_c1_dc5_clken;\n\n   logic        lsu_store_c1_dc1_clk, lsu_store_c1_dc2_clk, lsu_store_c1_dc3_clk;\n   logic        lsu_dccm_c1_dc3_clk, lsu_pic_c1_dc3_clk;\n   logic        lsu_stbuf_c1_clk;\n   logic        lsu_free_c2_clk;\n\n   logic [pt.NUM_THREADS-1:0] lsu_bus_ibuf_c1_clk, lsu_bus_obuf_c1_clk, lsu_bus_buf_c1_clk;\n   logic                      lsu_busm_clk;\n\n   logic [31:0]                 amo_data_dc3;\n   logic [pt.NUM_THREADS-1:0]   lr_vld;            // needed for clk gating\n\n   logic        lsu_raw_fwd_lo_dc3, lsu_raw_fwd_hi_dc3;\n   logic        lsu_raw_fwd_lo_dc4, lsu_raw_fwd_hi_dc4;\n   logic        lsu_raw_fwd_lo_dc5, lsu_raw_fwd_hi_dc5;\n\n   logic        picm_wren_notdma;\n\n   eh2_lsu_lsc_ctl #(.pt(pt)) lsu_lsc_ctl(.*);\n\n   // Ready to accept dma trxns\n   // There can't be any inpipe forwarding from non-dma packet to dma packet since they can be flushed so we can't have ld/st in dc3-dc5 when dma is in dc2\n   assign ldst_nodma_dc2todc5 = (lsu_pkt_dc2.valid & ~lsu_pkt_dc2.dma & (addr_in_dccm_dc2 | addr_in_pic_dc2) & lsu_pkt_dc2.store) |\n                                (lsu_pkt_dc3.valid & ~lsu_pkt_dc3.dma & (addr_in_dccm_dc3 | addr_in_pic_dc3) & lsu_pkt_dc3.store) |\n                                (lsu_pkt_dc4.valid & ~lsu_pkt_dc4.dma & (addr_in_dccm_dc4 | addr_in_pic_dc4) & lsu_pkt_dc4.store);\n   assign dccm_ready = ~(picm_wren_notdma | lsu_pkt_dc1_pre.valid | ldst_nodma_dc2todc5 | ld_single_ecc_error_dc5_ff);\n   assign dma_mem_tag_dc1[2:0] = dma_mem_tag[2:0];\n\n   assign dma_pic_wen  = dma_dccm_req & dma_mem_write & ~dma_mem_addr_in_dccm;\n   assign dma_dccm_wen = dma_dccm_req & dma_mem_write & dma_mem_addr_in_dccm & dma_mem_sz[1];\n   assign dma_dccm_spec_wen = dma_dccm_spec_req & dma_mem_write & dma_mem_sz[1];\n   assign dma_start_addr_dc1[31:0] = dma_mem_addr[31:0];\n   assign dma_end_addr_dc1[31:3]   = dma_mem_addr[31:3];\n   assign dma_end_addr_dc1[2:0]    = (dma_mem_sz[2:0] == 3'b11) ? 3'b100 : dma_mem_addr[2:0];\n    assign {dma_dccm_wdata_hi[31:0], dma_dccm_wdata_lo[31:0]} = dma_mem_wdata[63:0] >> {dma_mem_addr[2:0], 3'b000};   // Shift the dma data to lower bits to make it consistent to lsu stores\n\n   // Generate per cycle flush signals\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin: GenFlushLoop\n      assign flush_dc2_up[i] = flush_final_e3[i] | dec_tlu_flush_lower_wb[i];\n      assign flush_dc3[i]    = (flush_final_e3[i] & i0_flush_final_e3[i]) | dec_tlu_flush_lower_wb[i];\n      assign flush_dc4[i]    = dec_tlu_flush_lower_wb[i];\n      assign flush_dc5[i]    = ((dec_tlu_i0_kill_writeb_wb & ~lsu_pkt_dc5.pipe) | (dec_tlu_i1_kill_writeb_wb & lsu_pkt_dc5.pipe)) & (lsu_pkt_dc5.tid == i);\n   end\n\n   assign lsu_fastint_stall_any = ld_single_ecc_error_dc3;\n\n   // Dual l"}
{"text": "d-st\n   assign ldst_dual_dc2          = (lsu_addr_dc2[2] != end_addr_dc2[2]);\n   assign ldst_dual_dc3          = (lsu_addr_dc3[2] != end_addr_dc3[2]);\n   assign ldst_dual_dc4          = (lsu_addr_dc4[2] != end_addr_dc4[2]);\n   assign ldst_dual_dc5          = (lsu_addr_dc5[2] != end_addr_dc5[2]);\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin: GenThreadLoop\n      // block stores in decode  - for either bus or stbuf reasons\n      // block for sc/amo since stores does read modify write so they are similar to load\n      assign lsu_store_stall_any[i] = (lsu_pkt_dc1.valid & (lsu_pkt_dc1.sc | (lsu_pkt_dc1.atomic & lsu_pkt_dc1.store))) |\n                                      (lsu_pkt_dc2.valid & (lsu_pkt_dc2.sc | (lsu_pkt_dc2.atomic & lsu_pkt_dc2.store))) |\n                                      (lsu_pkt_dc3.valid & (lsu_pkt_dc3.sc | (lsu_pkt_dc3.atomic & lsu_pkt_dc3.store))) |\n                                      lsu_stbuf_full_any[i] | lsu_bus_buffer_full_any[i] | ld_single_ecc_error_dc5;\n      // block the atomic (including lr/sc). We need to block lr/sc as well for ECC case (Store on T0 followed by lr/sr on T1 with ECC error)\n      assign lsu_amo_stall_any[i]   = (lsu_pkt_dc1.valid & lsu_pkt_dc1.store & (lsu_pkt_dc1.tid != i)) |\n                                      (lsu_pkt_dc2.valid & lsu_pkt_dc2.store & (lsu_pkt_dc2.tid != i)) |\n                                      (lsu_pkt_dc3.valid & lsu_pkt_dc3.store & (lsu_pkt_dc3.tid != i));\n      assign lsu_load_stall_any[i]  = (lsu_pkt_dc1.valid & (lsu_pkt_dc1.sc | (lsu_pkt_dc1.atomic & lsu_pkt_dc1.store))) |\n                                      (lsu_pkt_dc2.valid & (lsu_pkt_dc2.sc | (lsu_pkt_dc2.atomic & lsu_pkt_dc2.store))) |\n                                      (lsu_pkt_dc3.valid & (lsu_pkt_dc3.sc | (lsu_pkt_dc3.atomic & lsu_pkt_dc3.store))) |\n                                      lsu_bus_buffer_full_any[i] | ld_single_ecc_error_dc5;\n\n      // lsu halt idle. This is used for entering the halt mode\n      // Indicates non-idle if there is a instruction valid in dc1-dc5 or read/write buffers are non-empty since they can come with error\n      // We don't need store buffer here since it's commit state\n      assign lsu_idle_any[i] = ~((lsu_pkt_dc1.valid & ~lsu_pkt_dc1.dma & (lsu_pkt_dc1.tid == 1'(i))) |\n                                 (lsu_pkt_dc2.valid & ~lsu_pkt_dc2.dma & (lsu_pkt_dc2.tid == 1'(i))) |\n                                 (lsu_pkt_dc3.valid & ~lsu_pkt_dc3.dma & (lsu_pkt_dc3.tid == 1'(i))) |\n                                 (lsu_pkt_dc4.valid & ~lsu_pkt_dc4.dma & (lsu_pkt_dc4.tid == 1'(i))) |\n                                 (lsu_pkt_dc5.valid & ~lsu_pkt_dc5.dma & (lsu_pkt_dc5.tid == 1'(i)))) &\n                                 lsu_bus_idle_any[i] & lsu_bus_buffer_empty_any[i];\n   end\n\n   assign  lsu_active = (lsu_pkt_dc1.valid | lsu_pkt_dc2.valid | lsu_pkt_dc3.valid | lsu_pkt_dc4.valid | lsu_pkt_dc5.valid) |\n                        ~(&lsu_bus_idle_any[pt.NUM_THREADS-1:0]) | ~(&lsu_bus_buffer_empty_any[pt.NUM_THREADS-1:0]) |\n                        ld_single_ecc_error_dc5_ff;\n\n   assign  lsu_raw_fwd_lo_dc3 = (|stbuf_fwdbyteen_lo_dc3[pt.DCCM_BYTE_WIDTH-1:0]);\n   assign  lsu_raw_fwd_hi_dc3 = (|stbuf_fwdbyteen_hi_dc3[pt.DCCM_BYTE_WIDTH-1:0]);\n\n   assign store_data_dc3[31:0] = (picm_mask_data_dc3[31:0] | {32{~addr_in_pic_dc3}}) &\n                                 ((lsu_pkt_dc3.store_data_bypass_e4_c3[1]) ? i1_result_e4_eff[31:0] :\n                                  (lsu_pkt_dc3.store_data_bypass_e4_c3[0]) ? i0_result_e4_eff[31:0] : store_data_pre_dc3[31:0]);\n\n   // Instantiate the store buffer\n   assign store_stbuf_reqvld_dc5 = lsu_pkt_dc5.valid & (~lsu_pkt_dc5.sc | lsu_sc_success_dc5 | (lsu_single_ecc_error_dc5 & ~lsu_raw_fwd_lo_dc5)) & addr_in_dccm_dc5 &\n                                   (((lsu_pkt_dc5.store | (lsu_pkt_dc5.atomic & ~lsu_pkt_dc5.lr)) & lsu_commit_dc5) |\n                                    (lsu_pkt_dc5.dma & lsu_pkt_dc5.store & (lsu_pkt_dc5.by | lsu_pkt_dc5.half) & ~lsu_double_ecc_error_dc5));\n\n   // Disable Forwarding for now\n   assign lsu_cmpen_dc2 = lsu_pkt_dc2.valid & (lsu_pkt_dc2.load | lsu_pkt_dc2.store | lsu_pkt_dc1.atomic) & (addr_in_dccm_dc2 | addr_in_pic_dc2);\n\n   // Bus signals\n   assign lsu_busreq_dc1 = lsu_pkt_dc1_pre.valid & ((lsu_pkt_dc1_pre.load | lsu_pkt_dc1_pre.store) & addr_external_dc1) & ~flush_dc2_up[lsu_pkt_dc1_pre.tid] & ~lsu_pkt_dc1_pre.fast_int;\n\n   // PMU signals\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin: GenPMU\n      assign lsu_pmu_misaligned_dc3[i]     = lsu_pkt_dc3.valid & ~lsu_pkt_dc3.dma & ((lsu_pkt_dc3.half & lsu_addr_dc3[0]) | (lsu_pkt_dc3.word & (|lsu_addr_dc3[1:0]))) & (i == lsu_pkt_dc3.tid);\n      assign lsu_pmu_load_external_dc3[i]  = lsu_pkt_dc3.valid & ~lsu_pkt_dc3.dma & lsu_pkt_dc3.load & addr_external_dc3 & (i == lsu_pkt_dc3.tid);\n      assign lsu_pmu_store_external_dc3[i] = lsu_pkt_dc3.valid & ~lsu_pkt_dc3.dma & lsu_pkt_dc3.store & addr_external_dc3 & (i == lsu_pkt_dc3.tid);\n   end\n\n   if (pt.ATOMIC_ENABLE == 1) begin: GenAMO\n      eh2_lsu_amo #(.pt(pt))  lsu_amo (.*);\n   end\n   else begin: GenNoAMO\n      assign amo_data_dc3[31:0] = '0;\n   end\n\n   eh2_lsu_dccm_ctl #(.pt(pt)) dccm_ctl (\n      .lsu_addr_dc1(lsu_addr_dc1[31:0]),\n      .end_addr_dc1(end_addr_dc1[31:0]),\n      .lsu_addr_dc3(lsu_addr_dc3[31:0]),\n      .lsu_addr_dc4(lsu_addr_dc4[31:0]),\n      .lsu_addr_dc5(lsu_addr_dc5[31:0]),\n\n      .end_addr_dc2(end_addr_dc2[31:0]),\n      .end_addr_dc3(end_addr_dc3[31:0]),\n      .end_addr_dc4(end_addr_dc4[31:0]),\n      .end_addr_dc5(end_addr_dc5[31:0]),\n      .*\n   );\n\n   eh2_lsu_stbuf #(.pt(pt)) stbuf(\n      .lsu_addr_dc1(lsu_addr_dc1[pt.LSU_SB_BITS-1:0]),\n      .end_addr_dc1(end_addr_dc1[pt.LSU_SB_BITS-1:0]),\n\n      .*\n\n   );\n\n   eh2_lsu_ecc #(.pt(pt)) ecc (\n      .lsu_addr_dc3(lsu_addr_dc3[pt.DCCM_BITS-1:0]),\n      .end_addr_dc3(end_addr_dc3[pt.DCCM_BITS-1:0]),\n      .*\n   );\n\n   eh2_lsu_trigger #(.pt(pt)) trigger (\n      .store_data_dc3(store_data_dc3[31:0]),\n      .*\n   );\n\n   // Clk domain\n   eh2_lsu_clkdomain #(.pt(pt)) clkdomain (.*);\n\n   // Bus interface\n   eh2_lsu_bus_intf #(.pt(pt)) bus_intf (\n      .lsu_addr_dc2(lsu_addr_dc2[31:0] & {32{lsu_busreq_dc2}}),\n      .lsu_addr_dc3(lsu_addr_dc3[31:0] & {32{lsu_busreq_dc3}}),\n      .lsu_addr_dc4(lsu_addr_dc4[31:0] & {32{lsu_busreq_dc4}}),\n      .lsu_addr_dc5(lsu_addr_dc5[31:0] & {32{lsu_busreq_dc5}}),\n\n      .end_addr_dc2(end_addr_dc2[31:0] & {32{lsu_busreq_dc2}}),\n      .end_addr_dc3(end_addr_dc3[31:0] & {32{lsu_busreq_dc3}}),\n      .end_addr_dc4(end_addr_dc4[31:0] & {32{lsu_busreq_dc4}}),\n      .end_addr_dc5(end_addr_dc5[31:0] & {32{lsu_busreq_dc5}}),\n\n      .store_data_ext_dc3(store_data_ext_dc3[63:0] & {64{lsu_busreq_dc3}}),\n      .store_data_ext_dc4(store_data_ext_dc4[63:0] & {64{lsu_busreq_dc4}}),\n      .store_data_ext_dc5(store_data_ext_dc5[63:0] & {64{lsu_busreq_dc5}}),\n\n      .*\n   );\n\n   //Flops\n   rvdff #(1) single_ecc_err_hidc4  (.*, .din(single_ecc_error_hi_dc3),     .dout(single_ecc_error_hi_dc4), .clk(lsu_c2_dc4_clk));\n   rvdff #(1) single_ecc_err_hidc5  (.*, .din(single_ecc_error_hi_dc4),     .dout(single_ecc_error_hi_dc5), .clk(lsu_c2_dc5_clk));\n   rvdff #(1) single_ecc_err_lodc4  (.*, .din(single_ecc_error_lo_dc3),     .dout(single_ecc_error_lo_dc4), .clk(lsu_c2_dc4_clk));\n   rvdff #(1) single_ecc_err_lodc5  (.*, .din(single_ecc_error_lo_dc4),     .dout(single_ecc_error_lo_dc5), .clk(lsu_c2_dc5_clk));\n\n   rvdff #(3) dma_mem_tag_dc2ff    (.*, .din(dma_mem_tag_dc1[2:0]),         .dout(dma_mem_tag_dc2[2:0]),     .clk(lsu_c2_dc2_clk));\n   rvdff #(3) dma_mem_tag_dc3ff    (.*, .din(dma_mem_tag_dc2[2:0]),         .dout(dma_mem_tag_dc3[2:0]),     .clk(lsu_c2_dc3_clk));\n\n   rvdff #(2) lsu_raw_fwd_dc4_ff    (.*, .din({lsu_raw_fwd_hi_dc3, lsu_raw_fwd_lo_dc3}),     .dout({lsu_raw_fwd_hi_dc4, lsu_raw_fwd_lo_dc4}),     .clk(lsu_c2_dc4_clk));\n   rvdff #(2) lsu_raw_fwd_dc5_ff    (.*, .din({lsu_raw_fwd_hi_dc4, lsu_raw_fwd_lo_dc4}),     .dout({lsu_raw_fwd_hi_dc5, lsu_raw_fwd_lo_dc5}),     .clk(lsu_c2_dc5_clk));\n\n`ifdef RV_ASSERT_ON\n   logic [8:0] store_data_bypass_sel;\n   assign store_data_bypass_sel[8:0] =  {lsu_p.store_data_bypass_c1,\n                                         lsu_p.store_data_bypass_c2,\n                                         lsu_p.store_data_bypass_i0_e2_c2,\n                                         lsu_p.store_data_bypass_e4_c1[1:0],\n                                         lsu_p.store_data_bypass_e4_c2[1:0],\n                                         lsu_p.store_data_bypass_e4_c3[1:0]} & {9{lsu_p.valid}};\n   assert_store_data_bypass_onehot: assert #0 ($onehot0(store_data_bypass_sel[8:0]));\n\n   property exception_no_lsu_flush;\n      logic    tid;\n      @(posedge clk)  disable iff(~rst_l) (lsu_error_pkt_dc3.exc_valid, tid = lsu_pkt_dc3.tid) |-> ##[1:2] (flush_dc4[tid] | flush_dc5[tid]);\n   endproperty\n   assert_exception_no_lsu_flush: assert property (exception_no_lsu_flush) else\n      $display(\"No flush within 2 cycles of exception\");\n\n   // offset should be zero for fast interrupt\n   property offset_0_fastint;\n      @(posedge clk) disable iff(~rst_l) (lsu_p.valid & lsu_p.fast_int) |-> (dec_lsu_offset_d[11:0] == 12'b0);\n   endproperty\n   assert_offset_0_fastint: assert property (offset_0_fastint) else\n      $display(\"dec_tlu_offset_d not zero for fast interrupt redirect\");\n\n   // fastint_stall should cause load/store stall next cycle\n   property fastint_stall_imply_loadstore_stall;\n      @(posedge clk) disable iff(~rst_l) lsu_fastint_stall_any |-> ##2 (~ld_single_ecc_error_dc5 | (|(lsu_load_stall_any[pt.NUM_THREADS-1:0] | lsu_store_stall_any[pt.NUM_THREADS-1:0])));\n   endproperty\n   assert_fastint_stall_imply_loadstore_stall: assert property (fastint_stall_imply_loadstore_stall) else\n      $display(\"fastint_stall should be followed by lsu_load/store_stall_any\");\n\n  // Atomic needs to preserve memory ordering(aq/rl attributes are assumed) so lsu_idle needs to be high when atomics are dispatched to lsu\n  property atomic_notidle;\n     logic     tid;\n     @(posedge clk) disable iff (~rst_l) ((lsu_p.valid & lsu_p.atomic), tid = lsu_p.tid) |-> lsu_idle_any[tid];\n  endproperty\n  assert_atomic_notidle: assert property (atomic_notidle) else\n     $display(\"LSU not idle but Atomic instruction (AMO/LR/SC) in decode\");\n\n`endif\n\nendmodule : eh2_lsu\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: Checks the memory map for the address\n// Comments:\n//\n//********************************************************************************\nmodule eh2_lsu_addrcheck\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)(\n   input logic              lsu_c2_dc2_clk,       // clock\n   input logic              lsu_c2_dc3_clk,\n   input logic              clk_override,\n   input logic              clk,\n   input logic              rst_l,                       // reset\n\n   input logic [31:0]       start_addr_dc1,              // start address for lsu\n   input logic [31:0]       end_addr_dc1,                // end address for lsu\n   input logic [31:0]       start_addr_dc2,              // start address for lsu\n   input logic [31:0]       end_addr_dc2,                // end address for lsu\n   input logic [31:0]       rs1_dc1,\n   input eh2_lsu_pkt_t     lsu_pkt_dc1,                 // packet in dc1\n   input eh2_lsu_pkt_t     lsu_pkt_dc2,                 // packet in dc1\n\n   input logic [31:0]  dec_tlu_mrac_ff,           // CSR read\n\n   output logic        is_sideeffects_dc2,          // is sideffects space\n   output logic        is_sideeffects_dc3,\n   output logic        addr_in_dccm_region_dc1,     // address in dccm region\n   output logic        addr_in_dccm_dc1,            // address in dccm\n   output logic        addr_in_pic_dc1,             // address in pic\n   output logic        addr_external_dc1,           // address in external\n   output logic        addr_external_dc2,           // address in external\n\n   output logic        access_fault_dc2,            // access fault\n   output logic        misaligned_fault_dc2,        // misaligned\n   output logic [3:0]  exc_mscause_dc2,             // Exception cause\n\n   output logic        fir_dccm_access_error_dc2,   // Fast interrupt dccm access error\n   output logic        fir_nondccm_access_error_dc2,// Fast interrupt dccm access error\n\n   input  logic        scan_mode\n);\n\n\n   logic        is_sideeffects_dc1, is_aligned_dc2;\n   logic        start_addr_in_dccm_dc1, end_addr_in_dccm_dc1;\n   logic        start_addr_in_dccm_region_dc1, end_addr_in_dccm_region_dc1;\n   logic        start_addr_in_pic_dc1, end_addr_in_pic_dc1;\n   logic        start_addr_in_pic_region_dc1, end_addr_in_pic_region_dc1;\n   logic        addr_in_pic_region_dc1;\n   logic        start_addr_in_dccm_dc2, end_addr_in_dccm_dc2;\n   logic        start_addr_in_pic_dc2, end_addr_in_pic_dc2;\n   logic        start_addr_in_dccm_region_dc2, end_addr_in_dccm_region_dc2;\n   logic        start_addr_in_pic_region_dc2, end_addr_in_pic_region_dc2;\n   logic        addr_in_dccm_dc2, addr_in_pic_dc2;\n   logic [3:0]  rs1_region_dc1, rs1_region_dc2;              // region from the rs operand of the agu\n   logic [4:0]  csr_idx;\n   logic        addr_in_iccm;\n   logic        start_addr_dccm_or_pic_dc2;\n   logic        base_reg_dccm_or_pic_dc1, base_reg_dccm_or_pic_dc2;\n   logic        unmapped_access_fault_dc2, mpu_access_fault_dc2, picm_access_fault_dc2, regpred_access_fault_dc2, amo_access_fault_dc2;\n   logic        regcross_misaligned_fault_dc2, sideeffect_misaligned_fault_dc2;\n   logic [3:0]  access_fault_mscause_dc2;\n   logic [3:0]  misaligned_fault_mscause_dc2;\n   logic        non_dccm_access_ok;\n\n   if (pt.DCCM_ENABLE == 1) begin: Gen_dccm_enable\n      // Start address check\n      rvrangecheck #(.CCM_SADR(pt.DCCM_SADR),\n                     .CCM_SIZE(pt.DCCM_SIZE)) start_addr_dccm_rangecheck (\n         .addr(start_addr_dc1[31:0]),\n         .in_range(start_addr_in_dccm_dc1),\n         .in_region(start_addr_in_dccm_region_dc1)\n      );\n\n      // End address check\n      rvrangecheck #(.CCM_SADR(pt.DCCM_SADR),\n                     .CCM_SIZE(pt.DCCM_SIZE)) end_addr_dccm_rangecheck (\n         .addr(end_addr_dc1[31:0]),\n         .in_range(end_addr_in_dccm_dc1),\n         .in_region(end_addr_in_dccm_region_dc1)\n      );\n   end else begin: Gen_dccm_disable // block: Gen_dccm_enable\n      assign start_addr_in_dccm_dc1 = '0;\n      assign start_addr_in_dccm_region_dc1 = '0;\n      assign end_addr_in_dccm_dc1 = '0;\n      assign end_addr_in_dccm_region_dc1 = '0;\n   end\n\n   // ICCM region check\n   if (pt.ICCM_ENABLE == 1) begin : check_iccm\n     assign addr_in_iccm =  (start_addr_dc2[31:28] == pt.ICCM_REGION);\n   end\n   else begin\n     assign addr_in_iccm = 1'b0;\n   end\n\n   // PIC memory check\n   // Start address check\n   rvrangecheck #(.CCM_SADR(pt.PIC_BASE_ADDR),\n                  .CCM_SIZE(pt.PIC_SIZE)) start_addr_pic_rangecheck (\n      .addr(start_addr_dc1[31:0]),\n      .in_range(start_addr_in_pic_dc1),\n      .in_region(start_addr_in_pic_region_dc1)\n   );\n\n   // End address check\n   rvrangecheck #(.CCM_SADR(pt.PIC_BASE_ADDR),\n                  .CCM_SIZE(pt.PIC_SIZE)) end_addr_pic_rangecheck (\n      .addr(end_addr_dc1[31:0]),\n      .in_range(end_addr_in_pic_dc1),\n      .in_region(end_addr_in_pic_region_dc1)\n   );\n\n   assign rs1_region_dc1[3:0] = rs1_dc1[31:28];\n   assign start_addr_dccm_or_pic_dc2  = start_addr_in_dccm_region_dc2 | start_addr_in_pic_region_dc2;\n   assign base_reg_dccm_or_pic_dc1    = ((rs1_region_dc1[3:0] == pt.DCCM_REGION) & pt.DCCM_ENABLE) | (rs1_region_dc1[3:0] == pt.PIC_REGION);\n\n   assign addr_in_dccm_region_dc1 = (rs1_region_dc1[3:0] == pt.DCCM_REGION) & pt.DCCM_ENABLE;  // We don't need to look at final address since lsu will take an exception if final region is different\n   assign addr_in_pic_region_dc1  = (rs1_region_dc1[3:0] == pt.PIC_REGION);   // We don't need to look at final address since lsu will take an exception if final region is different\n   assign addr_in_dccm_dc1        = (start_addr_in_dccm_dc1 & end_addr_in_dccm_dc1);\n   assign addr_in_pic_dc1         = (start_addr_in_pic_dc1 & end_addr_in_pic_dc1);\n\n   assign addr_in_dccm_dc2        = (start_addr_in_dccm_dc2 & end_addr_in_dccm_dc2);\n   assign addr_in_pic_dc2         = (start_addr_in_pic_dc2 & end_addr_in_pic_dc2);\n\n   assign addr_external_dc1  = ~(addr_in_dccm_region_dc1 | addr_in_pic_region_dc1);  // look at the region based on rs1_dc1 for timing since this goes to busreq -> nbload_dc1 -> instbuf\n   assign addr_external_dc2  = ~(start_addr_in_dccm_region_dc2 | start_addr_in_pic_region_dc2);  // look at the region based on rs1_dc1 for timing since this goes to busreq -> nbload_dc1 -> instbuf\n   assign csr_idx[4:0]       = {start_addr_dc2[31:28], 1'b1};\n   assign is_sideeffects_dc2 = dec_tlu_mrac_ff[csr_idx] & ~(start_addr_in_dccm_region_dc2 | start_addr_in_pic_region_dc2 | addr_in_iccm);  //every region has the 2 LSB indicating ( 1: sideeffects/no_side effects, and 0: cacheable ). Ignored in internal regions\n   assign is_aligned_dc2    = (lsu_pkt_dc2.word & (start_addr_dc2[1:0] == 2'b0)) |\n                              (lsu_pkt_dc2.half & (start_addr_dc2[0] == 1'b0)) |\n                              lsu_pkt_dc2.by;\n\n   assign non_dccm_access_ok = (~(|{pt.DATA_ACCESS_ENABLE0,pt.DATA_ACCESS_ENABLE1,pt.DATA_ACCESS_ENABLE2,pt.DATA_ACCESS_ENABLE3,pt.DATA_ACCESS_ENABLE4,pt.DATA_ACCESS_ENABLE5,pt.DATA_ACCESS_ENABLE6,pt.DATA_ACCESS_ENABLE7})) |\n                               (((pt.DATA_ACCESS_ENABLE0 & ((start_addr_dc2[31:0] | pt.DATA_ACCESS_MASK0)) == (pt.DATA_ACCESS_ADDR0 | pt.DATA_ACCESS_MASK0)) |\n                                 (pt.DATA_ACCESS_ENABLE1 & ((start_addr_dc2[31:0] | pt.DATA_ACCESS_MASK1)) == (pt.DATA_ACCESS_ADDR1 | pt.DATA_ACCESS_MASK1)) |\n                                 (pt.DATA_ACCESS_ENABLE2 & ((start_addr_dc2[31:0] | pt.DATA_ACCESS_MASK2)) == (pt.DATA_ACCESS_ADDR2 | pt.DATA_ACCESS_MASK2)) |\n                                 (pt.DATA_ACCESS_ENABLE3 & ((start_addr_dc2[31:0] | pt.DATA_ACCESS_MASK3)) == (pt.DATA_ACCESS_ADDR3 | pt.DATA_ACCESS_MASK3)) |\n                                 (pt.DATA_ACCESS_ENABLE4 & ((start_addr_dc2[31:0] | pt.DATA_ACCESS_MASK4)) == (pt.DATA_ACCESS_ADDR4 | pt.DATA_ACCESS_MASK4)) |\n                                 (pt.DATA_ACCESS_ENABLE5 & ((start_addr_dc2[31:0] | pt.DATA_ACCESS_MASK5)) == (pt.DATA_ACCESS_ADDR5 | pt.DATA_ACCESS_MASK5)) |\n                                 (pt.DATA_ACCESS_ENABLE6 & ((start_addr_dc2[31:0] | pt.DATA_ACCESS_MASK6)) == (pt.DATA_ACCESS_ADDR6 | pt.DATA_ACCESS_MASK6)) |\n                                 (pt.DATA_ACCESS_ENABLE7 & ((start_addr_dc2[31:0] | pt.DATA_ACCESS_MASK7)) == (pt.DATA_ACCESS_ADDR7 | pt.DATA_ACCESS_MASK7)))   &\n                                ((pt.DATA_ACCESS_ENABLE0 & ((end_addr_dc2[31:0]   | pt.DATA_ACCESS_MASK0)) == (pt.DATA_ACCESS_ADDR0 | pt.DATA_ACCESS_MASK0)) |\n                                 (pt.DATA_ACCESS_ENABLE1 & ((end_addr_dc2[31:0]   | pt.DATA_ACCESS_MASK1)) == (pt.DATA_ACCESS_ADDR1 | pt.DATA_ACCESS_MASK1)) |\n                                 (pt.DATA_ACCESS_ENABLE2 & ((end_addr_dc2[31:0]   | pt.DATA_ACCESS_MASK2)) == (pt.DATA_ACCESS_ADDR2 | pt.DATA_ACCESS_MASK2)) |\n                                 (pt.DATA_ACCESS_ENABLE3 & ((end_addr_dc2[31:0]   | pt.DATA_ACCESS_MASK3)) == (pt.DATA_ACCESS_ADDR3 | pt.DATA_ACCESS_MASK3)) |\n                                 (pt.DATA_ACCESS_ENABLE4 & ((end_addr_dc2[31:0]   | pt.DATA_ACCESS_MASK4)) == (pt.DATA_ACCESS_ADDR4 | pt.DATA_ACCESS_MASK4)) |\n                                 (pt.DATA_ACCESS_ENABLE5 & ((end_addr_dc2[31:0]   | pt.DATA_ACCESS_MASK5)) == (pt.DATA_ACCESS_ADDR5 | pt.DATA_ACCESS_MASK5)) |\n                                 (pt.DATA_ACCESS_ENABLE6 & ((end_addr_dc2[31:0]   | pt.DATA_ACCESS_MASK6)) == (pt.DATA_ACCESS_ADDR6 | pt.DATA_ACCESS_MASK6)) |\n                                 (pt.DATA_ACCESS_ENABLE7 & ((end_addr_dc2[31:0]   | pt.DATA_ACCESS_MASK7)) == (pt.DATA_ACCESS_ADDR7 | pt.DATA_ACCESS_MASK7))));\n\n   // Access fault logic\n   // 0. Unmapped local memory fault: Addr in dccm region but not in dccm offset OR Addr in picm region but not in picm offset OR DCCM -> PIC cross when DCCM/PIC in same region\n   // 1. Uncorrectable (double bit) ECC error\n   // 3. MPU access fault: Address is not in a populated non-dccm region\n   // 5. Region prediction access fault: Base Address in DCCM/PIC and Final address in non-DCCM/non-PIC region or vice versa\n   // 6. Ld/St access to picm are not word aligned or word size\n\n   assign regpred_access_fault_dc2  = (start_addr_dccm_or_pic_dc2 ^ base_reg_dccm_or_pic_dc2);                            // 5. Region prediction access fault: Base Address in DCCM/PIC and Final address in non-DCCM/non-PIC region or vice versa\n   assign picm_access_fault_dc2     = (addr_in_pic_dc2 & ((start_addr_dc2[1:0] != 2'b0) | ~lsu_pkt_dc2.word));    // 6. Ld/St access to picm are not word aligned or word size\n   assign amo_access_fault_dc2      =  (lsu_pkt_dc2.atomic & (start_addr_dc2[1:0] != 2'b0))                     | // 7. AMO are not word aligned OR AMO address not in dccm region\n                                       (lsu_pkt_dc2.valid & lsu_pkt_dc2.atomic & ~addr_in_dccm_dc2);\n\n   if (pt.DCCM_ENABLE & (pt.DCCM_REGION == pt.PIC_REGION)) begin\n      assign unmapped_access_fault_dc2 = ((start_addr_in_dccm_region_dc2 & ~(start_addr_in_dccm_dc2 | start_addr_in_pic_dc2)) |   // 0. Addr in dccm/pic region but not in dccm/pic offset\n                                        (end_addr_in_dccm_region_dc2 & ~(end_addr_in_dccm_dc2 | end_addr_in_pic_dc2))         |   // 0. Addr in dccm/pic region but not in dccm/pic offset\n                                        (start_addr_in_dccm_dc2 & end_addr_in_pic_dc2)                                        |   // 0. DCCM -> PIC cross when DCCM/PIC in same region\n                                        (start_addr_in_pic_dc2  & end_addr_in_dccm_dc2));                                         // 0. DCCM -> PIC cross when DCCM/PIC in same region\n      assign mpu_access_fault_dc2      = (~start_addr_in_dccm_region_dc2 & ~non_dccm_access_ok);                                  // 3. Address is not in a populated non-dccm region\n   end else begin\n      assign unmapped_access_fault_dc2 = ((start_addr_in_dccm_region_dc2 & ~start_addr_in_dccm_dc2)                            |   // 0. Addr in dccm region but not in dccm offset\n                                        (end_addr_in_dccm_region_dc2 & ~end_addr_in_dccm_dc2)                                  |   // 0. Addr in dccm region but not in dccm offset\n                                        (start_addr_in_pic_region_dc2 & ~start_addr_in_pic_dc2)                                |   // 0. Addr in picm region but not in picm offset\n                                        (end_addr_in_pic_region_dc2 & ~end_addr_in_pic_dc2));                                      // 9. Addr in picm region but not in picm offset\n      assign mpu_access_fault_dc2      = (~start_addr_in_pic_region_dc2 & ~start_addr_in_dccm_region_dc2 & ~non_dccm_access_ok);   // 3. Address is not in a populated non-dccm region\n   end\n\n   assign access_fault_dc2 = (unmapped_access_fault_dc2 | mpu_access_fault_dc2 | picm_access_fault_dc2 |\n                              regpred_access_fault_dc2 | amo_access_fault_dc2) & lsu_pkt_dc2.valid & ~lsu_pkt_dc2.dma;\n   assign access_fault_mscause_dc2[3:0] = unmapped_access_fault_dc2 ? 4'h2 : mpu_access_fault_dc2 ? 4'h3 : regpred_access_fault_dc2 ? 4'h5 : picm_access_fault_dc2 ? 4'h6 : amo_access_fault_dc2 ? 4'h7 : 4'h0;\n\n   // Misaligned happens due to 2 reasons (Atomic instructions (LR/SC/AMO) will never take misaligned as per spec)\n   // 0. Region cross\n   // 1. sideeffects access which are not aligned\n   assign regcross_misaligned_fault_dc2 = (start_addr_dc2[31:28] != end_addr_dc2[31:28]);\n   assign sideeffect_misaligned_fault_dc2 = (is_sideeffects_dc2 & ~is_aligned_dc2);\n   assign misaligned_fault_dc2 = (regcross_misaligned_fault_dc2 | (sideeffect_misaligned_fault_dc2 & addr_external_dc2)) & lsu_pkt_dc2.valid & ~lsu_pkt_dc2.dma & ~lsu_pkt_dc2.atomic;\n   assign misaligned_fault_mscause_dc2[3:0] = regcross_misaligned_fault_dc2 ? 4'h2 : sideeffect_misaligned_fault_dc2 ? 4'h1 : 4'h0;//sideeffect_misaligned_fault_dc2;\n\n   assign exc_mscause_dc2[3:0] = misaligned_fault_dc2 ? misaligned_fault_mscause_dc2[3:0] : access_fault_mscause_dc2[3:0];\n\n   // Fast interrupt error logic\n   assign fir_dccm_access_error_dc2    = ((start_addr_in_dccm_region_dc2 & ~start_addr_in_dccm_dc2) |\n                                          (end_addr_in_dccm_region_dc2   & ~end_addr_in_dccm_dc2)) & lsu_pkt_dc2.valid & lsu_pkt_dc2.fast_int;\n   assign fir_nondccm_access_error_dc2 = ~(start_addr_in_dccm_region_dc2 & end_addr_in_dccm_region_dc2) & lsu_pkt_dc2.valid & lsu_pkt_dc2.fast_int;\n\n\n   rvdff #(.WIDTH(1)) base_reg_dccmorpic_dc2ff       (.din(base_reg_dccm_or_pic_dc1),      .dout(base_reg_dccm_or_pic_dc2),      .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(.WIDTH(1)) start_addr_in_dccm_dc2ff       (.din(start_addr_in_dccm_dc1),        .dout(start_addr_in_dccm_dc2),        .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(.WIDTH(1)) end_addr_in_dccm_dc2ff         (.din(end_addr_in_dccm_dc1),          .dout(end_addr_in_dccm_dc2),          .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(.WIDTH(1)) start_addr_in_pic_dc2ff        (.din(start_addr_in_pic_dc1),         .dout(start_addr_in_pic_dc2),         .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(.WIDTH(1)) end_addr_in_pic_dc2ff          (.din(end_addr_in_pic_dc1),           .dout(end_addr_in_pic_dc2),           .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(.WIDTH(1)) start_addr_in_dccm_region_dc2ff(.din(start_addr_in_dccm_region_dc1), .dout(start_addr_in_dccm_region_dc2), .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(.WIDTH(1)) start_addr_in_pic_region_dc2ff (.din(start_addr_in_pic_region_dc1),  .dout(start_addr_in_pic_region_dc2),  .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(.WIDTH(1)) end_addr_in_dccm_region_dc2ff  (.din(end_addr_in_dccm_region_dc1),   .dout(end_addr_in_dccm_region_dc2),   .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(.WIDTH(1)) end_addr_in_pic_region_dc2ff   (.din(end_addr_in_pic_region_dc1),    .dout(end_addr_in_pic_region_dc2),    .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(.WIDTH(1)) is_sideeffects_dc3ff           (.din(is_sideeffects_dc2),            .dout(is_sideeffects_dc3),            .clk(lsu_c2_dc3_clk), .*);\n\nendmodule // lsu_addrcheck\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: Checks the memory map for the address\n// Comments:\n//\n//********************************************************************************\nmodule eh2_lsu_amo\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)(\n\n   input eh2_lsu_pkt_t  lsu_pkt_dc3,                 // packet in dc3\n   input logic           addr_in_pic_dc3,\n   input logic  [31:0]   lsu_dccm_data_corr_dc3,      // Operand 1 for the ALU\n   input logic  [31:0]   store_data_dc3,              // Store_Data Operand\n\n   output logic [31:0]   amo_data_dc3                 // Final AMO result to go down the store path\n\n);\n\n// this section does the decode of the type of AMO in dc3.\n\n   logic               amo_sc_dc3;\n\n\n   logic         amo_add_dc3;\n   logic         amo_max_dc3;\n   logic         amo_maxu_dc3;\n   logic         amo_min_dc3;\n   logic         amo_minu_dc3;\n   logic         amo_minmax_sel_dc3;\n   logic [31:0]  amo_minmax_dc3;\n   logic         amo_xor_dc3;\n   logic         amo_or_dc3;\n   logic         amo_and_dc3;\n   logic         amo_swap_dc3;\n\n   logic         logic_sel;\n   logic [31:0]  logical_out;\n   logic [31:0]  sum_out;\n\n   logic [31:0]  store_datafn_dc3;\n\n   logic [31:0]  amo_operand1, amo_operand2;\n   logic [31:0]  amo_operand2_inv;\n\n   //------------------------------------------------------------------------------------------------------------\n   //----------------------------------------Logic starts here---------------------------------------------------\n   //------------------------------------------------------------------------------------------------------------\n\n   // decode the instruction type\n   assign amo_sc_dc3     = lsu_pkt_dc3.valid & lsu_pkt_dc3.atomic & (lsu_pkt_dc3.atomic_instr[4:0] == 5'd3);\n\n   assign amo_add_dc3    = lsu_pkt_dc3.valid & lsu_pkt_dc3.atomic & (lsu_pkt_dc3.atomic_instr[4:0] == 5'd0);\n   assign amo_max_dc3    = lsu_pkt_dc3.valid & lsu_pkt_dc3.atomic & (lsu_pkt_dc3.atomic_instr[4:0] == 5'd20);\n   assign amo_maxu_dc3   = lsu_pkt_dc3.valid & lsu_pkt_dc3.atomic & (lsu_pkt_dc3.atomic_instr[4:0] == 5'd28);\n   assign amo_min_dc3    = lsu_pkt_dc3.valid & lsu_pkt_dc3.atomic & (lsu_pkt_dc3.atomic_instr[4:0] == 5'd16);\n   assign amo_minu_dc3   = lsu_pkt_dc3.valid & lsu_pkt_dc3.atomic & (lsu_pkt_dc3.atomic_instr[4:0] == 5'd24);\n   assign amo_xor_dc3    = lsu_pkt_dc3.valid & lsu_pkt_dc3.atomic & (lsu_pkt_dc3.atomic_instr[4:0] == 5'd4);\n   assign amo_or_dc3     = lsu_pkt_dc3.valid & lsu_pkt_dc3.atomic & (lsu_pkt_dc3.atomic_instr[4:0] == 5'd8);\n   assign amo_and_dc3    = lsu_pkt_dc3.valid & lsu_pkt_dc3.atomic & (lsu_pkt_dc3.atomic_instr[4:0] == 5'd12);\n   assign amo_swap_dc3   = lsu_pkt_dc3.valid & lsu_pkt_dc3.atomic & (lsu_pkt_dc3.atomic_instr[4:0] == 5'd1);\n\n   assign amo_minmax_sel_dc3 =  amo_max_dc3 | amo_maxu_dc3 | amo_min_dc3 | amo_minu_dc3;\n   assign logic_sel          =  amo_and_dc3 | amo_or_dc3   | amo_xor_dc3;\n\n   assign amo_operand1[31:0] = {32{lsu_pkt_dc3.valid & lsu_pkt_dc3.atomic}} & lsu_dccm_data_corr_dc3[31:0];\n   assign amo_operand2[31:0] = {32{lsu_pkt_dc3.valid & lsu_pkt_dc3.atomic}} & store_data_dc3[31:0];\n\n\n   // logical\n   assign logical_out[31:0] =  ( {32{amo_and_dc3}} & (amo_operand1[31:0] & amo_operand2[31:0]) ) |\n                               ( {32{amo_or_dc3}}  & (amo_operand1[31:0] | amo_operand2[31:0]) ) |\n                               ( {32{amo_xor_dc3}} & (amo_operand1[31:0] ^ amo_operand2[31:0]) );\n   // adder\n\n   logic         lsu_result_lt_storedata;\n   logic         cout;\n\n\n   // ADD\n   assign amo_operand2_inv[31:0]  =  amo_add_dc3 ? amo_operand2[31:0] : ~amo_operand2[31:0];\n   assign {cout, sum_out[31:0]}   = {1'b0, amo_operand1[31:0]} + {1'b0, amo_operand2_inv[31:0]} + {32'b0, ~amo_add_dc3};\n\n\n   // Min/Max/Minu/Maxu\n   assign lsu_result_lt_storedata = (~cout & (lsu_pkt_dc3.unsign | ~(amo_operand1[31] ^amo_operand2[31]))) |    // either doing unsigned math or signed with same polarity\n                                    (amo_operand1[31] & ~amo_operand2[31] & ~lsu_pkt_dc3.unsign);\n\n   assign amo_minmax_dc3[31:0]    = ({32{(amo_max_dc3 | amo_maxu_dc3) &  lsu_result_lt_storedata}}  & amo_operand2[31:0]) |  // MAX if store_data >  result\n                                    ({32{(amo_max_dc3 | amo_maxu_dc3) & ~lsu_result_lt_storedata}}  & amo_operand1[31:0]) |  // MAX if store_data <= result\n                                    ({32{(amo_min_dc3 | amo_minu_dc3) & ~lsu_result_lt_storedata}}  & amo_operand2[31:0]) |  // MIN if store_data >  result\n                                    ({32{(amo_min_dc3 | amo_minu_dc3) &  lsu_result_lt_storedata}}  & amo_operand1[31:0]);   // MIN if store_data <= result\n\n  // final result\n   assign amo_data_dc3[31:0]      = ({32{logic_sel}}                 & logical_out[31:0])    |  // for the AND/OR/XOR\n                                    ({32{amo_add_dc3}}               & sum_out[31:0])        |  // for ADD\n                                    ({32{amo_minmax_sel_dc3}}        & amo_minmax_dc3[31:0]) |  // for Min/Max/Minu/Maxu\n                                    ({32{amo_swap_dc3 | amo_sc_dc3}} & amo_operand2[31:0]);     // for SWAP need to store the store data value to the location\n\nendmodule // lsu_amo\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: lsu interface with interface queue\n// Comments:\n//\n//********************************************************************************\n\nmodule eh2_lsu_bus_buffer\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)(\n   input logic                          clk,\n   input logic                          rst_l,\n   input logic                          scan_mode,\n   input logic                          dec_tlu_external_ldfwd_disable,     // disable load to load forwarding for externals\n   input logic                          dec_tlu_sideeffect_posted_disable,  // disable posted writes to sideeffect addr to the bus\n   input logic                          dec_tlu_wb_coalescing_disable,      // disable write buffer coalescing\n   input logic                          bus_coalescing_disable,\n   input logic                          dec_tlu_force_halt,\n\n   // various clocks needed for the bus reads and writes\n   input logic                          lsu_c2_dc2_clk,\n   input logic                          lsu_c2_dc3_clk,\n   input logic                          lsu_c2_dc4_clk,\n   input logic                          lsu_c2_dc5_clk,\n\n   input logic                          lsu_busm_clken,\n   input logic                          lsu_bus_obuf_c1_clken,\n   input logic                          lsu_bus_ibuf_c1_clk,\n   input logic                          lsu_bus_obuf_c1_clk,\n   input logic                          lsu_bus_buf_c1_clk,\n   input logic                          lsu_free_c2_clk,\n   input logic                          lsu_busm_clk,\n\n\n   input                                eh2_lsu_pkt_t lsu_pkt_dc1_pre,   // lsu packet flowing down the pipe\n   input                                eh2_lsu_pkt_t lsu_pkt_dc2,       // lsu packet flowing down the pipe\n   input                                eh2_lsu_pkt_t lsu_pkt_dc3,       // lsu packet flowing down the pipe\n   input                                eh2_lsu_pkt_t lsu_pkt_dc4,       // lsu packet flowing down the pipe\n   input                                eh2_lsu_pkt_t lsu_pkt_dc5,       // lsu packet flowing down the pipe\n\n   input logic                          tid,\n   input logic                          bus_tid,\n   input logic [31:0]                   lsu_addr_dc2,                     // lsu address flowing down the pipe\n   input logic [31:0]                   end_addr_dc2,                     // lsu address flowing down the pipe\n   input logic [31:0]                   lsu_addr_dc5,                     // lsu address flowing down the pipe\n   input logic [31:0]                   end_addr_dc5,                     // lsu address flowing down the pipe\n\n   input logic [3:0]                    ldst_byteen_hi_dc5,\n   input logic [3:0]                    ldst_byteen_lo_dc5,\n   input logic [31:0]                   store_data_hi_dc5,\n   input logic [31:0]                   store_data_lo_dc5,\n\n   input logic                          ldst_samedw_dc5,                  // Hi/Lo are within same dw\n   input logic                          is_aligned_dc5,                   // Aligned load/store\n   input logic                          no_word_merge_dc5,                // dc5 store doesn't need to wait in ibuf since it will not coalesce\n   input logic                          no_dword_merge_dc5,               // dc5 store doesn't need to wait in ibuf since it will not coalesce\n   input logic                          lsu_busreq_dc1,                   // bus request is in dc2\n   input logic                          lsu_busreq_dc2,                   // bus request is in dc2\n   input logic                          lsu_busreq_dc3,                   // bus request is in dc3\n   input logic                          lsu_busreq_dc4,                   // bus request is in dc4\n   input logic                          lsu_busreq_dc5,                   // bus request is in dc5\n   input logic                          ld_full_hit_dc2,                  // load can get all its byte from a write buffer entry\n   input logic                          lsu_commit_dc5,                   // lsu instruction in dc5 commits\n   input logic                          is_sideeffects_dc5,               // lsu attribute is side_effects\n   input logic                          ldst_dual_dc1,                    // load/store is unaligned at 32 bit boundary\n   input logic                          ldst_dual_dc2,                    // load/store is unaligned at 32 bit boundary\n   input logic                          ldst_dual_dc3,                    // load/store is unaligned at 32 bit boundary\n   input logic                          ldst_dual_dc4,                    // load/store is unaligned at 32 bit boundary\n   input logic                          ldst_dual_dc5,                    // load/store is unaligned at 32 bit boundary\n\n   input logic [7:0]                    ldst_byteen_ext_dc2,\n\n   input logic                          lsu_bus_cntr_overflow,\n   input logic                          bus_cmd_sent, bus_cmd_ready,\n   input logic                          bus_wcmd_sent, bus_wdata_sent,\n   input logic                          bus_rsp_read, bus_rsp_write,\n   input logic [pt.LSU_BUS_TAG-1:0]     bus_rsp_read_tag, bus_rsp_write_tag,\n   input logic                          bus_rsp_read_tid, bus_rsp_write_tid,\n   input logic                          bus_rsp_read_error, bus_rsp_write_error,\n   input logic [63:0]                   bus_rsp_rdata,\n\n   input logic                          bus_rsp_valid_q,\n   input logic                          bus_rsp_ready_q,\n   input logic                          bus_rsp_write_q,\n   input logic                          bus_rsp_error_q,\n   input logic                          bus_rsp_write_tid_q,\n   input logic [63:0]                   bus_rsp_rdata_q,\n\n   output logic                         bus_addr_match_pending,\n   output logic                         lsu_bus_buffer_pend_any,          // bus buffer has a pending bus entry\n   output logic                         lsu_bus_buffer_full_any,          // bus buffer is full\n   output logic                         lsu_bus_buffer_empty_any,         // bus buffer is empty\n   input logic                          lsu_bus_idle_any,                 // No pending responses from the bus\n\n   output logic [3:0]                   ld_byte_hit_buf_lo, ld_byte_hit_buf_hi,    // Byte enables for forwarding data\n   output logic [31:0]                  ld_fwddata_buf_lo, ld_fwddata_buf_hi,      // load forwarding data\n\n   output logic                         lsu_imprecise_error_load_any,     // imprecise load bus error\n   output logic                         lsu_imprecise_error_store_any,    // imprecise store bus error\n   output logic [31:0]                  lsu_imprecise_error_addr_any,     // address of the imprecise error\n\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] WrPtr0_dc1, WrPtr0_dc2, WrPtr0_dc5,\n\n   // Output buffer signals\n   output logic                               obuf_valid,\n   output logic                               obuf_nosend,\n   output logic                               obuf_write,\n   output logic                               obuf_sideeffect,\n   output logic [31:0]                        obuf_addr,\n   output logic [63:0]                        obuf_data,\n   output logic [1:0]                         obuf_sz,\n   output logic [7:0]                         obuf_byteen,\n   output logic                               obuf_cmd_done, obuf_data_done,\n   output logic [pt.LSU_BUS_TAG-1:0]          obuf_tag0,\n   output logic                               obuf_nxtready,\n\n   // Non-blocking loads\n   input  logic                               lsu_nonblock_load_data_tid,      // Final tid for nonblock response to dec\n   output logic                               lsu_nonblock_load_data_ready,    // Per tid ready signal\n   output logic                               lsu_nonblock_load_data_valid,    // the non block is valid - sending information back to the cam\n   output logic                               lsu_nonblock_load_data_error,    // non block load has an error\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_data_tag,      // the tag of the non block load sending the data/error\n   output logic [31:0]                        lsu_nonblock_load_data,          // Data of the non block load\n\n   input logic                           lsu_bus_clk_en,\n   input logic                           lsu_bus_clk_en_q\n\n);\n\n   // For Ld: IDLE -> WAIT -> CMD -> RESP -> DONE -> IDLE\n   // For St: IDLE -> WAIT -> CMD -> RESP(?) -> IDLE\n   typedef enum logic [2:0] {IDLE=3'b000, WAIT=3'b001, CMD=3'b010, RESP=3'b011, DONE_PARTIAL=3'b100, DONE_WAIT=3'b101, DONE=3'b110} state_t;\n\n   localparam DEPTH     = pt.LSU_NUM_NBLOAD;\n   localparam DEPTH_LOG2 = pt.LSU_NUM_NBLOAD_WIDTH;\n   localparam TIMER     = 8;   // This can be only power of 2\n   localparam TIMER_LOG2 = (TIMER < 2) ? 1 : $clog2(TIMER);\n   localparam TIMER_MAX = (TIMER == 0) ? TIMER_LOG2'(0) : TIMER_LOG2'(TIMER - 1);  // Maximum value of timer\n\n   logic [3:0]                          ldst_byteen_hi_dc2, ldst_byteen_lo_dc2;\n   logic [DEPTH-1:0]                    ld_addr_hitvec_lo, ld_addr_hitvec_hi;\n   logic [3:0][DEPTH-1:0]               ld_byte_hitvec_lo, ld_byte_hitvec_hi;\n   logic [3:0][DEPTH-1:0]               ld_byte_hitvecfn_lo, ld_byte_hitvecfn_hi;\n\n   logic                                ld_addr_ibuf_hit_lo, ld_addr_ibuf_hit_hi;\n   logic [3:0]                          ld_byte_ibuf_hit_lo, ld_byte_ibuf_hit_hi;\n\n   logic [31:0]                         lsu_nonblock_load_data_hi, lsu_nonblock_load_data_lo, lsu_nonblock_data_unalgn;\n   logic [1:0]                          lsu_nonblock_addr_offset;\n   logic [1:0]                          lsu_nonblock_sz;\n   logic                                lsu_nonblock_load_rtn_valid;\n   logic                                lsu_nonblock_unsign, lsu_nonblock_dual;\n   logic [DEPTH_LOG2-1:0]               lsu_imprecise_error_load_tag;\n   logic [pt.LSU_BUS_TAG-1:0]           lsu_imprecise_error_store_tag;\n\n   logic [DEPTH-1:0]                    CmdPtr0Dec, CmdPtr1Dec;\n   logic [DEPTH-1:0]                    RspPtrDec;\n   logic [DEPTH_LOG2-1:0]               CmdPtr0, CmdPtr1;\n   logic [DEPTH_LOG2-1:0]               RspPtr;\n   logic [DEPTH_LOG2-1:0]               WrPtr0_dc3, WrPtr0_dc4;\n   logic [DEPTH_LOG2-1:0]               WrPtr1_dc1, WrPtr1_dc2, WrPtr1_dc3, WrPtr1_dc4, WrPtr1_dc5;\n   logic                                found_wrptr0, found_wrptr1, found_cmdptr0, found_cmdptr1;\n   logic [3:0]                          buf_numvld_any, buf_numvld_wrcmd_any, buf_numvld_pend_any, buf_numvld_cmd_any;\n   logic                                any_done_wait_state, any_done_state;\n   logic                                bus_sideeffect_pend;\n\n   // Bus buffer signals\n   state_t [DEPTH-1:0]                  buf_state;\n   logic   [DEPTH-1:0][1:0]             buf_sz;\n   logic   [DEPTH-1:0][31:0]            buf_addr;\n   logic   [DEPTH-1:0][3:0]             buf_byteen;\n   logic   [DEPTH-1:0]                  buf_sideeffect;\n   logic   [DEPTH-1:0]                  buf_write;\n   logic   [DEPTH-1:0]                  buf_unsign;\n   logic   [DEPTH-1:0]                  buf_dual;\n   logic   [DEPTH-1:0]                  buf_samedw;\n   logic   [DEPTH-1:0]                  buf_nomerge;\n   logic   [DEPTH-1:0]                  buf_dualhi;\n   logic   [DEPTH-1:0][DEPTH_LOG2-1:0]  buf_dualtag;\n   logic   [DEPTH-1:0]                  buf_ldfwd;\n   logic   [DEPTH-1:0][DEPTH_LOG2-1:0]  buf_ldfwdtag;\n   logic   [DEPTH-1:0]                  buf_error;\n   logic   [DEPTH-1:0][31:0]            buf_data;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_age, buf_age_younger;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_rspage, buf_rsp_pickage;\n\n   state_t [DEPTH-1:0]                  buf_nxtstate;\n   logic   [DEPTH-1:0]                  buf_rst;\n   logic   [DEPTH-1:0]                  buf_state_en;\n   logic   [DEPTH-1:0]                  buf_cmd_state_bus_en;\n   logic   [DEPTH-1:0]                  buf_resp_state_bus_en;\n   logic   [DEPTH-1:0]                  buf_state_bus_en;\n   logic   [DEPTH-1:0]                  buf_dual_in;\n   logic   [DEPTH-1:0]                  buf_samedw_in;\n   logic   [DEPTH-1:0]                  buf_nomerge_in;\n   logic   [DEPTH-1:0]                  buf_sideeffect_in;\n   logic   [DEPTH-1:0]                  buf_unsign_in;\n   logic   [DEPTH-1:0][1:0]             buf_sz_in;\n   logic   [DEPTH-1:0]                  buf_write_in;\n   logic   [DEPTH-1:0]                  buf_wr_en;\n   logic   [DEPTH-1:0]                  buf_dualhi_in;\n   logic   [DEPTH-1:0][DEPTH_LOG2-1:0]  buf_dualtag_in;\n   logic   [DEPTH-1:0]                  buf_ldfwd_en;\n   logic   [DEPTH-1:0]                  buf_ldfwd_in;\n   logic   [DEPTH-1:0][DEPTH_LOG2-1:0]  buf_ldfwdtag_in;\n   logic   [DEPTH-1:0][3:0]             buf_byteen_in;\n   logic   [DEPTH-1:0][31:0]            buf_addr_in;\n   logic   [DEPTH-1:0][31:0]            buf_data_in;\n   logic   [DEPTH-1:0]                  buf_error_en;\n   logic   [DEPTH-1:0]                  buf_data_en;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_age_set;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_age_in;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_ageQ;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_rspage_set;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_rspage_in;\n   logic   [DEPTH-1:0][DEPTH-1:0]       buf_rspageQ;\n\n   // Input buffer signals\n   logic                               ibuf_valid;\n   logic                               ibuf_dual;\n   logic                               ibuf_samedw;\n   logic                               ibuf_nomerge;\n   logic [DEPTH_LOG2-1:0]              ibuf_tag;\n   logic [DEPTH_LOG2-1:0]              ibuf_dualtag;\n   logic                               ibuf_sideeffect;\n   logic                               ibuf_unsign;\n   logic                               ibuf_write;\n   logic [1:0]                         ibuf_sz;\n   logic [3:0]                         ibuf_byteen;\n   logic [31:0]                        ibuf_addr;\n   logic [31:0]                        ibuf_data;\n   logic [TIMER_LOG2-1:0]              ibuf_timer;\n\n   logic                               ibuf_byp;\n   logic                               ibuf_wr_en;\n   logic                               ibuf_rst;\n   logic                               ibuf_force_drain;\n   logic                               ibuf_drain_vld;\n   logic [DEPTH-1:0]                   ibuf_drainvec_vld;\n   logic [DEPTH_LOG2-1:0]              ibuf_tag_in;\n   logic [DEPTH_LOG2-1:0]              ibuf_dualtag_in;\n   logic [1:0]                         ibuf_sz_in;\n   logic [31:0]                        ibuf_addr_in;\n   logic [3:0]                         ibuf_byteen_in;\n   logic [31:0]                        ibuf_data_in;\n   logic [TIMER_LOG2-1:0]              ibuf_timer_in;\n   logic [3:0]                         ibuf_byteen_out;\n   logic [31:0]                        ibuf_data_out;\n   logic                               ibuf_merge_en, ibuf_merge_in;\n\n   // Output buffer signals\n   logic                               obuf_merge;\n   logic                               obuf_rdrsp_pend;\n   logic [pt.LSU_BUS_TAG-1:0]          obuf_tag1;\n   logic [pt.LSU_BUS_TAG-1:0]          obuf_rdrsp_tag;\n\n   logic                               ibuf_buf_byp;\n   logic                               obuf_force_wr_en;\n   logic                               obuf_wr_wait;\n   logic                               obuf_wr_en, obuf_wr_enQ;\n   logic                               obuf_rst;\n   logic                               obuf_write_in;\n   logic                               obuf_nosend_in;\n   logic                               obuf_rdrsp_pend_in;\n   logic                               obuf_rdrsp_pend_en;\n   logic                               obuf_sideeffect_in;\n   logic                               obuf_aligned_in;\n   logic [31:0]                        obuf_addr_in;\n   logic [63:0]                        obuf_data_in;\n   logic [1:0]                         obuf_sz_in;\n   logic [7:0]                         obuf_byteen_in;\n   logic                               obuf_cmd_done_in, obuf_data_done_in;\n   logic                               obuf_merge_in;\n   logic [pt.LSU_BUS_TAG-1:0]          obuf_tag0_in;\n   logic [pt.LSU_BUS_TAG-1:0]          obuf_tag1_in;\n   logic [pt.LSU_BUS_TAG-1:0]          obuf_rdrsp_tag_in;\n\n   logic                               obuf_merge_en;\n   logic [TIMER_LOG2-1:0]              obuf_wr_timer, obuf_wr_timer_in;\n   logic [7:0]                         obuf_byteen0_in, obuf_byteen1_in;\n   logic [63:0]                        obuf_data0_in, obuf_data1_in;\n\n   // Function to do 8 to 3 bit encoding\n   function automatic logic [2:0] f_Enc8to3;\n      input logic [7:0] Dec_value;\n\n      logic [2:0]       Enc_value;\n      Enc_value[0] = Dec_value[1] | Dec_value[3] | Dec_value[5] | Dec_value[7];\n      Enc_value[1] = Dec_value[2] | Dec_value[3] | Dec_value[6] | Dec_value[7];\n      Enc_value[2] = Dec_value[4] | Dec_value[5] | Dec_value[6] | Dec_value[7];\n\n      return Enc_value[2:0];\n   endfunction // f_Enc8to3\n\n   //------------------------------------------------------------------------------------------------------------\n   //----------------------------------------Logic starts here---------------------------------------------------\n   //------------------------------------------------------------------------------------------------------------\n\n   //------------------------------------------------------------------------------\n   // Load forwarding logic start\n   //------------------------------------------------------------------------------\n\n   // Buffer hit logic for bus load forwarding\n   assign ldst_byteen_hi_dc2[3:0]   = ldst_byteen_ext_dc2[7:4];\n   assign ldst_byteen_lo_dc2[3:0]   = ldst_byteen_ext_dc2[3:0];\n   for (genvar i=0; i<DEPTH; i++) begin\n      // We can't forward from RESP for ahb since multiple writes to the same address can be in RESP and we can't find out their age\n      assign ld_addr_hitvec_lo[i] = (lsu_addr_dc2[31:2] == buf_addr[i][31:2]) & buf_write[i] & ((buf_state[i] == WAIT) | (buf_state[i] == CMD)) & (lsu_pkt_dc2.tid ~^ tid) & lsu_busreq_dc2;\n      assign ld_addr_hitvec_hi[i] = (end_addr_dc2[31:2] == buf_addr[i][31:2]) & buf_write[i] & ((buf_state[i] == WAIT) | (buf_state[i] == CMD)) & (lsu_pkt_dc2.tid ~^ tid) & lsu_busreq_dc2;\n   end\n\n   for (genvar j=0; j<4; j++) begin\n     assign ld_byte_hit_buf_lo[j] = |(ld_byte_hitvecfn_lo[j]) | ld_byte_ibuf_hit_lo[j];\n     assign ld_byte_hit_buf_hi[j] = |(ld_byte_hitvecfn_hi[j]) | ld_byte_ibuf_hit_hi[j];\n     for (genvar i=0; i<DEPTH; i++) begin\n         assign ld_byte_hitvec_lo[j][i] = ld_addr_hitvec_lo[i] & buf_byteen[i][j] & ldst_byteen_lo_dc2[j];\n         assign ld_byte_hitvec_hi[j][i] = ld_addr_hitvec_hi[i] & buf_byteen[i][j] & ldst_byteen_hi_dc2[j];\n\n         assign ld_byte_hitvecfn_lo[j][i] = ld_byte_hitvec_lo[j][i] & ~(|(ld_byte_hitvec_lo[j] & buf_age_younger[i])) & ~ld_byte_ibuf_hit_lo[j];  // Kill the byte enable if younger entry exists or byte exists in ibuf\n         assign ld_byte_hitvecfn_hi[j][i] = ld_byte_hitvec_hi[j][i] & ~(|(ld_byte_hitvec_hi[j] & buf_age_younger[i])) & ~ld_byte_ibuf_hit_hi[j];  // Kill th"}
{"text": "e byte enable if younger entry exists or byte exists in ibuf\n      end\n   end\n\n   // Hit in the ibuf\n   assign ld_addr_ibuf_hit_lo = (lsu_addr_dc2[31:2] == ibuf_addr[31:2]) & (lsu_pkt_dc2.tid ~^ tid) & ibuf_write & ibuf_valid & lsu_busreq_dc2;\n   assign ld_addr_ibuf_hit_hi = (end_addr_dc2[31:2] == ibuf_addr[31:2]) & (lsu_pkt_dc2.tid ~^ tid) & ibuf_write & ibuf_valid & lsu_busreq_dc2;\n\n   for (genvar i=0; i<4; i++) begin\n      assign ld_byte_ibuf_hit_lo[i] = ld_addr_ibuf_hit_lo & ibuf_byteen[i] & ldst_byteen_lo_dc2[i];\n      assign ld_byte_ibuf_hit_hi[i] = ld_addr_ibuf_hit_hi & ibuf_byteen[i] & ldst_byteen_hi_dc2[i];\n   end\n\n   always_comb begin\n      ld_fwddata_buf_lo[31:0] = {{8{ld_byte_ibuf_hit_lo[3]}},{8{ld_byte_ibuf_hit_lo[2]}},{8{ld_byte_ibuf_hit_lo[1]}},{8{ld_byte_ibuf_hit_lo[0]}}} & ibuf_data[31:0];\n      ld_fwddata_buf_hi[31:0] = {{8{ld_byte_ibuf_hit_hi[3]}},{8{ld_byte_ibuf_hit_hi[2]}},{8{ld_byte_ibuf_hit_hi[1]}},{8{ld_byte_ibuf_hit_hi[0]}}} & ibuf_data[31:0];\n      for (int i=0; i<DEPTH; i++) begin\n         ld_fwddata_buf_lo[7:0]   |= {8{ld_byte_hitvecfn_lo[0][i]}} & buf_data[i][7:0];\n         ld_fwddata_buf_lo[15:8]  |= {8{ld_byte_hitvecfn_lo[1][i]}} & buf_data[i][15:8];\n         ld_fwddata_buf_lo[23:16] |= {8{ld_byte_hitvecfn_lo[2][i]}} & buf_data[i][23:16];\n         ld_fwddata_buf_lo[31:24] |= {8{ld_byte_hitvecfn_lo[3][i]}} & buf_data[i][31:24];\n\n         ld_fwddata_buf_hi[7:0]   |= {8{ld_byte_hitvecfn_hi[0][i]}} & buf_data[i][7:0];\n         ld_fwddata_buf_hi[15:8]  |= {8{ld_byte_hitvecfn_hi[1][i]}} & buf_data[i][15:8];\n         ld_fwddata_buf_hi[23:16] |= {8{ld_byte_hitvecfn_hi[2][i]}} & buf_data[i][23:16];\n         ld_fwddata_buf_hi[31:24] |= {8{ld_byte_hitvecfn_hi[3][i]}} & buf_data[i][31:24];\n      end\n   end\n\n   //------------------------------------------------------------------------------\n   // Load forwarding logic end\n   //------------------------------------------------------------------------------\n\n   //------------------------------------------------------------------------------\n   // Input buffer logic starts here\n   //------------------------------------------------------------------------------\n\n   assign ibuf_byp   = lsu_busreq_dc5 & ((lsu_pkt_dc5.load | no_word_merge_dc5) & ~ibuf_valid);    // Bypass if ibuf is empty and it's a load or no merge possible\n   assign ibuf_wr_en = lsu_busreq_dc5 & lsu_commit_dc5 & (lsu_pkt_dc5.tid ~^ tid) & ~ibuf_byp;\n   assign ibuf_rst   = (ibuf_drain_vld & ~ibuf_wr_en) | dec_tlu_force_halt;\n   assign ibuf_force_drain = lsu_busreq_dc2 & ~lsu_busreq_dc3 & ~lsu_busreq_dc4 & ~lsu_busreq_dc5 & ibuf_valid & (lsu_pkt_dc2.load | (ibuf_addr[31:2] != lsu_addr_dc2[31:2]));  // Move the ibuf to buf if there is a non-colaescable ld/st in dc2 but nothing in dc3/dc4/dc5\n   assign ibuf_drain_vld = ibuf_valid & (((ibuf_wr_en | (ibuf_timer == TIMER_MAX)) & ~(ibuf_merge_en & ibuf_merge_in)) | ibuf_byp | ibuf_force_drain | ibuf_sideeffect | ~ibuf_write | bus_coalescing_disable);\n   assign ibuf_tag_in[DEPTH_LOG2-1:0] = (ibuf_merge_en & ibuf_merge_in) ? ibuf_tag[DEPTH_LOG2-1:0] : (ldst_dual_dc5 ? WrPtr1_dc5 : WrPtr0_dc5);\n   assign ibuf_dualtag_in[DEPTH_LOG2-1:0] = WrPtr0_dc5;\n   assign ibuf_sz_in[1:0]   = {lsu_pkt_dc5.word, lsu_pkt_dc5.half}; // NOTE: Make sure lsu_pkt_dc3/dc4 are flopped in case of freeze (except the valid)\n   assign ibuf_addr_in[31:0] = ldst_dual_dc5 ? end_addr_dc5[31:0] : lsu_addr_dc5[31:0];\n   assign ibuf_byteen_in[3:0] = (ibuf_merge_en & ibuf_merge_in) ? (ibuf_byteen[3:0] | ldst_byteen_lo_dc5[3:0]) : (ldst_dual_dc5 ? ldst_byteen_hi_dc5[3:0] : ldst_byteen_lo_dc5[3:0]);\n   for (genvar i=0; i<4; i++) begin\n      assign ibuf_data_in[(8*i)+7:(8*i)] = (ibuf_merge_en & ibuf_merge_in) ? (ldst_byteen_lo_dc5[i] ? store_data_lo_dc5[(8*i)+7:(8*i)] : ibuf_data[(8*i)+7:(8*i)]) :\n                                                                             (ldst_dual_dc5 ? store_data_hi_dc5[(8*i)+7:(8*i)] : store_data_lo_dc5[(8*i)+7:(8*i)]);\n   end\n   assign ibuf_timer_in = ibuf_wr_en ? '0 : (ibuf_timer < TIMER_MAX) ? (ibuf_timer + 1'b1) : ibuf_timer;\n\n   assign ibuf_merge_en = lsu_busreq_dc5 & lsu_commit_dc5 & (lsu_pkt_dc5.tid ~^ tid) & lsu_pkt_dc5.store &\n                          ibuf_valid & ibuf_write & (lsu_addr_dc5[31:2] == ibuf_addr[31:2]) & ~is_sideeffects_dc5 & ~bus_coalescing_disable;\n   assign ibuf_merge_in = ~ldst_dual_dc5;   // If it's a unaligned store, merge needs to happen on the way out of ibuf\n\n   // ibuf signals going to bus buffer after merging\n   for (genvar i=0; i<4; i++) begin\n      assign ibuf_byteen_out[i] = (ibuf_merge_en & ~ibuf_merge_in) ? (ibuf_byteen[i] | ldst_byteen_lo_dc5[i]) : ibuf_byteen[i];\n      assign ibuf_data_out[(8*i)+7:(8*i)] = (ibuf_merge_en & ~ibuf_merge_in) ? (ldst_byteen_lo_dc5[i] ? store_data_lo_dc5[(8*i)+7:(8*i)] : ibuf_data[(8*i)+7:(8*i)]) :\n                                                                                                        ibuf_data[(8*i)+7:(8*i)];\n   end\n\n   rvdffsc #(.WIDTH(1))              ibuf_valid_ff     (.din(1'b1),                        .dout(ibuf_valid),      .en(ibuf_wr_en), .clear(ibuf_rst), .clk(lsu_free_c2_clk), .*);\n   rvdffs  #(.WIDTH(DEPTH_LOG2))     ibuf_tagff        (.din(ibuf_tag_in),                 .dout(ibuf_tag),        .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(DEPTH_LOG2))     ibuf_dualtagff    (.din(ibuf_dualtag_in),             .dout(ibuf_dualtag),    .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(1))              ibuf_dualff       (.din(ldst_dual_dc5),               .dout(ibuf_dual),       .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(1))              ibuf_samedwff     (.din(ldst_samedw_dc5),             .dout(ibuf_samedw),     .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(1))              ibuf_nomergeff    (.din(no_dword_merge_dc5),          .dout(ibuf_nomerge),    .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(1))              ibuf_sideeffectff (.din(is_sideeffects_dc5),          .dout(ibuf_sideeffect), .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(1))              ibuf_unsignff     (.din(lsu_pkt_dc5.unsign),          .dout(ibuf_unsign),     .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(1))              ibuf_writeff      (.din(lsu_pkt_dc5.store),           .dout(ibuf_write),      .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffs  #(.WIDTH(2))              ibuf_szff         (.din(ibuf_sz_in[1:0]),             .dout(ibuf_sz),         .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffe  #(.WIDTH(32))             ibuf_addrff       (.din(ibuf_addr_in[31:0]),          .dout(ibuf_addr),       .en(ibuf_wr_en),                                              .*);\n   rvdffs  #(.WIDTH(4))              ibuf_byteenff     (.din(ibuf_byteen_in[3:0]),         .dout(ibuf_byteen),     .en(ibuf_wr_en),                   .clk(lsu_bus_ibuf_c1_clk), .*);\n   rvdffe  #(.WIDTH(32))             ibuf_dataff       (.din(ibuf_data_in[31:0]),          .dout(ibuf_data),       .en(ibuf_wr_en),                                              .*);\n   rvdff   #(.WIDTH(TIMER_LOG2))     ibuf_timerff      (.din(ibuf_timer_in),               .dout(ibuf_timer),                                         .clk(lsu_free_c2_clk),     .*);\n\n   //------------------------------------------------------------------------------\n   // Input buffer logic ends here\n   //------------------------------------------------------------------------------\n\n\n   //------------------------------------------------------------------------------\n   // Output buffer logic starts here\n   //------------------------------------------------------------------------------\n   assign obuf_wr_wait = (buf_numvld_wrcmd_any[3:0] == 4'b1) & (buf_numvld_cmd_any[3:0] == 4'b1) & (obuf_wr_timer != TIMER_MAX) &\n                         ~bus_coalescing_disable & ~buf_nomerge[CmdPtr0] & ~buf_sideeffect[CmdPtr0] & ~obuf_force_wr_en;\n   assign obuf_wr_timer_in = obuf_wr_en ? 3'b0: (((buf_numvld_cmd_any > 4'b0) & (obuf_wr_timer < TIMER_MAX)) ? (obuf_wr_timer + 1'b1) : obuf_wr_timer);\n   assign obuf_force_wr_en = lsu_busreq_dc2 & ~lsu_busreq_dc3 & ~lsu_busreq_dc4 & ~lsu_busreq_dc5 & ~ibuf_valid & (buf_numvld_cmd_any[3:0] == 4'b1) & (lsu_addr_dc2[31:2] != buf_addr[CmdPtr0][31:2]);   // Entry in dc2 can't merge with entry going to obuf and there is no entry in between\n   assign ibuf_buf_byp = ibuf_byp & (buf_numvld_pend_any[3:0] == 4'b0) & (~lsu_pkt_dc5.store | no_dword_merge_dc5);\n\n   assign obuf_wr_en = ((ibuf_buf_byp & lsu_commit_dc5 & (lsu_pkt_dc5.tid ~^ tid) & ~(is_sideeffects_dc5 & bus_sideeffect_pend)) |\n                        ((buf_state[CmdPtr0] == CMD) & found_cmdptr0 & ~buf_cmd_state_bus_en[CmdPtr0] & ~(buf_sideeffect[CmdPtr0] & bus_sideeffect_pend) &\n                         (~(buf_dual[CmdPtr0] & buf_samedw[CmdPtr0] & ~buf_write[CmdPtr0]) | found_cmdptr1 | buf_nomerge[CmdPtr0] | obuf_force_wr_en))) &\n                       ((bus_cmd_ready & (bus_tid == tid)) | ~obuf_valid | obuf_nosend) & ~obuf_wr_wait & ~lsu_bus_cntr_overflow & ~bus_addr_match_pending & lsu_bus_clk_en;\n   assign obuf_nxtready = obuf_wr_en;   // obuf will be valid next cycle\n   assign obuf_rst   = (((bus_cmd_sent & (bus_tid == tid)) | (obuf_valid & obuf_nosend)) & ~obuf_wr_en & lsu_bus_clk_en) | dec_tlu_force_halt;\n   assign obuf_write_in = ibuf_buf_byp ? lsu_pkt_dc5.store : buf_write[CmdPtr0];\n   assign obuf_sideeffect_in = ibuf_buf_byp ? is_sideeffects_dc5 : buf_sideeffect[CmdPtr0];\n   assign obuf_addr_in[31:0] = ibuf_buf_byp ? lsu_addr_dc5[31:0] : buf_addr[CmdPtr0];\n   assign obuf_sz_in[1:0]    = ibuf_buf_byp ? {lsu_pkt_dc5.word, lsu_pkt_dc5.half} : buf_sz[CmdPtr0];\n   assign obuf_aligned_in    = ibuf_buf_byp ? is_aligned_dc5 : ((obuf_sz_in[1:0] == 2'b0) |\n                                                                (obuf_sz_in[0] & ~obuf_addr_in[0]) |\n                                                                (obuf_sz_in[1] & ~(|obuf_addr_in[1:0])));\n   assign obuf_merge_in      = obuf_merge_en;\n   assign obuf_tag0_in[pt.LSU_BUS_TAG-1:0] = ibuf_buf_byp ? (pt.LSU_BUS_TAG)'(WrPtr0_dc5) : (pt.LSU_BUS_TAG)'(CmdPtr0);\n   assign obuf_tag1_in[pt.LSU_BUS_TAG-1:0] = ibuf_buf_byp ? (pt.LSU_BUS_TAG)'(WrPtr1_dc5) : (pt.LSU_BUS_TAG)'(CmdPtr1);\n\n   assign obuf_cmd_done_in    = ~(obuf_wr_en | obuf_rst) & (obuf_cmd_done | (bus_wcmd_sent & (bus_tid == tid)));\n   assign obuf_data_done_in   = ~(obuf_wr_en | obuf_rst) & (obuf_data_done | (bus_wdata_sent & (bus_tid == tid)));\n   assign obuf_rdrsp_pend_in  = ((~(obuf_wr_en & ~obuf_nosend_in) & obuf_rdrsp_pend & ~(bus_rsp_read & (bus_rsp_read_tid == tid) & (bus_rsp_read_tag == obuf_rdrsp_tag))) |\n                                 ((bus_cmd_sent & ~obuf_write & (bus_tid == tid)))) & ~dec_tlu_force_halt ;\n   assign obuf_rdrsp_pend_en  = dec_tlu_force_halt | lsu_bus_clk_en;\n   assign obuf_rdrsp_tag_in[pt.LSU_BUS_TAG-1:0] = (bus_cmd_sent & ~obuf_write & (bus_tid == tid)) ? obuf_tag0[pt.LSU_BUS_TAG-1:0] : obuf_rdrsp_tag[pt.LSU_BUS_TAG-1:0];\n\n   assign obuf_nosend_in      = (obuf_addr_in[31:3] == obuf_addr[31:3]) & obuf_aligned_in & ~obuf_sideeffect & ~obuf_write & ~obuf_write_in & ~dec_tlu_external_ldfwd_disable &\n                                ((obuf_valid & ~obuf_nosend) | (obuf_rdrsp_pend & ~(bus_rsp_read & (bus_rsp_read_tid == tid) & (bus_rsp_read_tag == obuf_rdrsp_tag))));\n\n   assign obuf_byteen0_in[7:0] = ibuf_buf_byp ? (lsu_addr_dc5[2] ? {ldst_byteen_lo_dc5[3:0],4'b0} : {4'b0,ldst_byteen_lo_dc5[3:0]}) :\n                                                (buf_addr[CmdPtr0][2] ? {buf_byteen[CmdPtr0],4'b0} : {4'b0,buf_byteen[CmdPtr0]});\n   assign obuf_byteen1_in[7:0] = ibuf_buf_byp ? (end_addr_dc5[2] ? {ldst_byteen_hi_dc5[3:0],4'b0} : {4'b0,ldst_byteen_hi_dc5[3:0]}) :\n                                                (buf_addr[CmdPtr1][2] ? {buf_byteen[CmdPtr1],4'b0} : {4'b0,buf_byteen[CmdPtr1]});\n   assign obuf_data0_in[63:0]  = ibuf_buf_byp ? (lsu_addr_dc5[2] ? {store_data_lo_dc5[31:0],32'b0} : {32'h0,store_data_lo_dc5[31:0]}) :\n                                                (buf_addr[CmdPtr0][2] ? {buf_data[CmdPtr0],32'b0} : {32'h0,buf_data[CmdPtr0]});\n   assign obuf_data1_in[63:0]  = ibuf_buf_byp ? (end_addr_dc5[2] ? {store_data_hi_dc5[31:0],32'b0} :{32'b0,store_data_hi_dc5[31:0]}) :\n                                                (buf_addr[CmdPtr1][2] ? {buf_data[CmdPtr1],32'b0} : {32'b0,buf_data[CmdPtr1]});\n   for (genvar i=0 ;i<8; i++) begin\n      assign obuf_byteen_in[i]           = obuf_byteen0_in[i] | (obuf_merge_en & obuf_byteen1_in[i]);\n      assign obuf_data_in[(8*i)+7:(8*i)] = (obuf_merge_en & obuf_byteen1_in[i]) ? obuf_data1_in[(8*i)+7:(8*i)] : obuf_data0_in[(8*i)+7:(8*i)];\n   end\n\n   // No store obuf merging for AXI since all stores are sent non-posted. Can't track the second id right now\n   assign obuf_merge_en = ((CmdPtr0 != CmdPtr1) & found_cmdptr0 & found_cmdptr1 & (buf_state[CmdPtr0] == CMD) & (buf_state[CmdPtr1] == CMD) &\n                           ~buf_cmd_state_bus_en[CmdPtr0] & ~buf_sideeffect[CmdPtr0] &\n                           ((buf_write[CmdPtr0] & buf_write[CmdPtr1] & (buf_addr[CmdPtr0][31:3] == buf_addr[CmdPtr1][31:3]) & ~bus_coalescing_disable & !pt.BUILD_AXI_NATIVE) |\n                            (~buf_write[CmdPtr0] & buf_dual[CmdPtr0] & ~buf_dualhi[CmdPtr0] & buf_samedw[CmdPtr0]))) |  // CmdPtr0/CmdPtr1 are for same load which is within a DW\n                          (ibuf_buf_byp & ldst_samedw_dc5 & ldst_dual_dc5);\n\n   rvdff_fpga  #(.WIDTH(1))              obuf_wren_ff      (.din(obuf_wr_en),                  .dout(obuf_wr_enQ),                                        .clk(lsu_busm_clk),        .clken(lsu_busm_clken), .rawclk(clk),        .*);\n   rvdffsc     #(.WIDTH(1))              obuf_valid_ff     (.din(1'b1),                        .dout(obuf_valid),      .en(obuf_wr_en), .clear(obuf_rst), .clk(lsu_free_c2_clk),                                                  .*);\n   rvdffs      #(.WIDTH(1))              obuf_nosend_ff    (.din(obuf_nosend_in),              .dout(obuf_nosend),     .en(obuf_wr_en),                   .clk(lsu_free_c2_clk),                                                  .*);\n   rvdffs      #(.WIDTH(1))              obuf_rdrsp_pend_ff(.din(obuf_rdrsp_pend_in),          .dout(obuf_rdrsp_pend), .en(obuf_rdrsp_pend_en),           .clk(lsu_free_c2_clk),                                                  .*);\n   rvdff_fpga  #(.WIDTH(1))              obuf_cmd_done_ff  (.din(obuf_cmd_done_in),            .dout(obuf_cmd_done),                                      .clk(lsu_busm_clk),        .clken(lsu_busm_clken),        .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(1))              obuf_data_done_ff (.din(obuf_data_done_in),           .dout(obuf_data_done),                                     .clk(lsu_busm_clk),        .clken(lsu_busm_clken),        .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(pt.LSU_BUS_TAG)) obuf_rdrsp_tagff  (.din(obuf_rdrsp_tag_in),           .dout(obuf_rdrsp_tag),                                     .clk(lsu_busm_clk),        .clken(lsu_busm_clken),        .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(pt.LSU_BUS_TAG)) obuf_tag0ff       (.din(obuf_tag0_in),                .dout(obuf_tag0),       .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(pt.LSU_BUS_TAG)) obuf_tag1ff       (.din(obuf_tag1_in),                .dout(obuf_tag1),       .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(1))              obuf_mergeff      (.din(obuf_merge_in),               .dout(obuf_merge),      .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(1))              obuf_writeff      (.din(obuf_write_in),               .dout(obuf_write),      .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(1))              obuf_sideeffectff (.din(obuf_sideeffect_in),          .dout(obuf_sideeffect), .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(2))              obuf_szff         (.din(obuf_sz_in[1:0]),             .dout(obuf_sz),         .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffs_fpga #(.WIDTH(8))              obuf_byteenff     (.din(obuf_byteen_in[7:0]),         .dout(obuf_byteen),     .en(obuf_wr_en),                   .clk(lsu_bus_obuf_c1_clk), .clken(lsu_bus_obuf_c1_clken), .rawclk(clk), .*);\n   rvdffe     #(.WIDTH(32))              obuf_addrff       (.din(obuf_addr_in[31:0]),          .dout(obuf_addr),       .en(obuf_wr_en),                                                                                           .*);\n   rvdffe     #(.WIDTH(64))              obuf_dataff       (.din(obuf_data_in[63:0]),          .dout(obuf_data),       .en(obuf_wr_en),                                                                                           .*);\n   rvdff_fpga #(.WIDTH(TIMER_LOG2))      obuf_timerff      (.din(obuf_wr_timer_in),            .dout(obuf_wr_timer),                                      .clk(lsu_busm_clk),        .clken(lsu_busm_clken), .rawclk(clk),        .*);\n\n   //------------------------------------------------------------------------------\n   // Output buffer logic ends here\n   //------------------------------------------------------------------------------\n\n   // Find the entry to allocate and entry to send\n   always_comb begin\n      WrPtr0_dc1[DEPTH_LOG2-1:0] = '0;\n      WrPtr1_dc1[DEPTH_LOG2-1:0] = '0;\n      found_wrptr0  = '0;\n      found_wrptr1  = '0;\n\n      // Find first write pointer\n      for (int i=0; i<DEPTH; i++) begin\n         if (~found_wrptr0) begin\n            WrPtr0_dc1[DEPTH_LOG2-1:0] = DEPTH_LOG2'(i);\n            found_wrptr0 = (buf_state[i] == IDLE) & ~((ibuf_valid & (ibuf_tag == DEPTH_LOG2'(i)))                                               |\n                                                      (lsu_busreq_dc2 & (lsu_pkt_dc2.tid ~^ tid) & ((WrPtr0_dc2 == DEPTH_LOG2'(i)) | (ldst_dual_dc2 & (WrPtr1_dc2 == DEPTH_LOG2'(i))))) |\n                                                      (lsu_busreq_dc3 & (lsu_pkt_dc3.tid ~^ tid) & ((WrPtr0_dc3 == DEPTH_LOG2'(i)) | (ldst_dual_dc3 & (WrPtr1_dc3 == DEPTH_LOG2'(i))))) |\n                                                      (lsu_busreq_dc4 & (lsu_pkt_dc4.tid ~^ tid) & ((WrPtr0_dc4 == DEPTH_LOG2'(i)) | (ldst_dual_dc4 & (WrPtr1_dc4 == DEPTH_LOG2'(i))))) |\n                                                      (lsu_busreq_dc5 & (lsu_pkt_dc5.tid ~^ tid) & ((WrPtr0_dc5 == DEPTH_LOG2'(i)) | (ldst_dual_dc5 & (WrPtr1_dc5 == DEPTH_LOG2'(i))))));\n         end\n      end\n\n      // Find second write pointer\n      for (int i=0; i<DEPTH; i++) begin\n         if (~found_wrptr1) begin\n            WrPtr1_dc1[DEPTH_LOG2-1:0] = DEPTH_LOG2'(i);\n            found_wrptr1 = (buf_state[i] == IDLE) & ~((ibuf_valid & (ibuf_tag == DEPTH_LOG2'(i)))                                               |\n                                                      (lsu_busreq_dc1 & (lsu_pkt_dc1_pre.tid ~^ tid) & (WrPtr0_dc1 == DEPTH_LOG2'(i)))                                         |\n                                                      (lsu_busreq_dc2 & (lsu_pkt_dc2.tid ~^ tid) & ((WrPtr0_dc2 == DEPTH_LOG2'(i)) | (ldst_dual_dc2 & (WrPtr1_dc2 == DEPTH_LOG2'(i))))) |\n                                                      (lsu_busreq_dc3 & (lsu_pkt_dc3.tid ~^ tid) & ((WrPtr0_dc3 == DEPTH_LOG2'(i)) | (ldst_dual_dc3 & (WrPtr1_dc3 == DEPTH_LOG2'(i))))) |\n               "}
{"text": "                                       (lsu_busreq_dc4 & (lsu_pkt_dc4.tid ~^ tid) & ((WrPtr0_dc4 == DEPTH_LOG2'(i)) | (ldst_dual_dc4 & (WrPtr1_dc4 == DEPTH_LOG2'(i))))) |\n                                                      (lsu_busreq_dc5 & (lsu_pkt_dc5.tid ~^ tid) & ((WrPtr0_dc5 == DEPTH_LOG2'(i)) | (ldst_dual_dc5 & (WrPtr1_dc5 == DEPTH_LOG2'(i))))));\n         end\n      end\n   end\n\n   // Get the command ptr\n   for (genvar i=0; i<DEPTH; i++) begin\n      // These should be one-hot\n      assign CmdPtr0Dec[i] = ~(|buf_age[i]) & (buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i];\n      assign CmdPtr1Dec[i] = ~(|(buf_age[i] & ~CmdPtr0Dec)) & ~CmdPtr0Dec[i] & (buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i];\n      assign RspPtrDec[i]  = ~(|buf_rsp_pickage[i]) & (buf_state[i] == DONE_WAIT);\n   end\n\n   assign found_cmdptr0 = |CmdPtr0Dec;\n   assign found_cmdptr1 = |CmdPtr1Dec;\n   assign CmdPtr0 = f_Enc8to3(8'(CmdPtr0Dec[DEPTH-1:0]));\n   assign CmdPtr1 = f_Enc8to3(8'(CmdPtr1Dec[DEPTH-1:0]));\n   assign RspPtr  = f_Enc8to3(8'(RspPtrDec[DEPTH-1:0]));\n\n   // Age vector\n   for (genvar i=0; i<DEPTH; i++) begin: GenAgeVec\n      for (genvar j=0; j<DEPTH; j++) begin\n         assign buf_age_set[i][j] = ((buf_state[i] == IDLE) & buf_state_en[i]) &\n                                           (((buf_state[j] == WAIT) | ((buf_state[j] == CMD) & ~buf_cmd_state_bus_en[j]))            |       // Set age bit for older entries\n                                            (ibuf_drain_vld & lsu_busreq_dc5 & (ibuf_byp | ldst_dual_dc5) & (lsu_pkt_dc5.tid ~^ tid) & (DEPTH_LOG2'(i) == WrPtr0_dc5) & (DEPTH_LOG2'(j) == ibuf_tag))  |       // Set case for dual lo\n                                            (ibuf_byp & lsu_busreq_dc5 & ldst_dual_dc5 & (lsu_pkt_dc5.tid ~^ tid) & (DEPTH_LOG2'(i) == WrPtr1_dc5) & (DEPTH_LOG2'(j) == WrPtr0_dc5)));\n         assign buf_age_in[i][j] = buf_age_set[i][j] | buf_age[i][j];\n         assign buf_age[i][j]    = buf_ageQ[i][j] & ~((buf_state[j] == CMD) & buf_cmd_state_bus_en[j]) & ~dec_tlu_force_halt;  // Reset case\n\n         assign buf_age_younger[i][j] = (i == j) ? 1'b0: (~buf_age[i][j] & (buf_state[j] != IDLE));   // Younger entries\n      end\n   end\n\n   // Age vector for responses\n   for (genvar i=0; i<DEPTH; i++) begin: GenRspAgeVec\n      for (genvar j=0; j<DEPTH; j++) begin\n         assign buf_rspage_set[i][j] = ((buf_state[i] == IDLE) & buf_state_en[i]) &\n                                           (~((buf_state[j] == IDLE) | (buf_state[j] == DONE))                                         |       // Set age bit for older entries\n                                            (ibuf_drain_vld & lsu_busreq_dc5 & (ibuf_byp | ldst_dual_dc5) & (lsu_pkt_dc5.tid ~^ tid) & (DEPTH_LOG2'(i) == WrPtr0_dc5) & (DEPTH_LOG2'(j) == ibuf_tag))  |       // Set case for dual lo\n                                            (ibuf_byp & lsu_busreq_dc5 & ldst_dual_dc5 & (lsu_pkt_dc5.tid ~^ tid) & (DEPTH_LOG2'(i) == WrPtr1_dc5) & (DEPTH_LOG2'(j) == WrPtr0_dc5)));\n         assign buf_rspage_in[i][j] = buf_rspage_set[i][j] | buf_rspage[i][j];\n         assign buf_rspage[i][j]    = buf_rspageQ[i][j] & ~((buf_state[j] == DONE) | (buf_state[j] == IDLE)) & ~dec_tlu_force_halt;  // Reset case\n         assign buf_rsp_pickage[i][j] = buf_rspageQ[i][j] & (buf_state[j] == DONE_WAIT);\n     end\n   end\n\n   //------------------------------------------------------------------------------\n   // Buffer logic\n   //------------------------------------------------------------------------------\n   for (genvar i=0; i<DEPTH; i++) begin\n\n      assign ibuf_drainvec_vld[i] = (ibuf_drain_vld & (i == ibuf_tag));\n      assign buf_byteen_in[i]     = ibuf_drainvec_vld[i] ? ibuf_byteen_out[3:0] : ((ibuf_byp & ldst_dual_dc5 & (i == WrPtr1_dc5)) ? ldst_byteen_hi_dc5[3:0] : ldst_byteen_lo_dc5[3:0]);\n      assign buf_addr_in[i]       = ibuf_drainvec_vld[i] ? ibuf_addr[31:0] : ((ibuf_byp & ldst_dual_dc5 & (i == WrPtr1_dc5)) ? end_addr_dc5[31:0] : lsu_addr_dc5[31:0]);\n      assign buf_dual_in[i]       = ibuf_drainvec_vld[i] ? ibuf_dual : ldst_dual_dc5;\n      assign buf_samedw_in[i]     = ibuf_drainvec_vld[i] ? ibuf_samedw : ldst_samedw_dc5;\n      assign buf_nomerge_in[i]    = ibuf_drainvec_vld[i] ? (ibuf_nomerge | ibuf_force_drain) : no_dword_merge_dc5;\n      assign buf_dualhi_in[i]     = ibuf_drainvec_vld[i] ? ibuf_dual : (ibuf_byp & ldst_dual_dc5 & (i == WrPtr1_dc5));   // If it's dual, ibuf will always have the high\n      assign buf_dualtag_in[i]    = ibuf_drainvec_vld[i] ? ibuf_dualtag : ((ibuf_byp & ldst_dual_dc5 & (i == WrPtr1_dc5)) ? WrPtr0_dc5 : WrPtr1_dc5);\n      assign buf_sideeffect_in[i] = ibuf_drainvec_vld[i] ? ibuf_sideeffect : is_sideeffects_dc5;\n      assign buf_unsign_in[i]     = ibuf_drainvec_vld[i] ? ibuf_unsign : lsu_pkt_dc5.unsign;\n      assign buf_sz_in[i]         = ibuf_drainvec_vld[i] ? ibuf_sz : {lsu_pkt_dc5.word, lsu_pkt_dc5.half};\n      assign buf_write_in[i]      = ibuf_drainvec_vld[i] ? ibuf_write : lsu_pkt_dc5.store;\n\n\n      // Buffer entry state machine\n      always_comb begin\n         buf_nxtstate[i]          = IDLE;\n         buf_state_en[i]          = '0;\n         buf_resp_state_bus_en[i] = '0;\n         buf_state_bus_en[i]      = '0;\n         buf_wr_en[i]             = '0;\n         buf_data_in[i]           = '0;\n         buf_data_en[i]           = '0;\n         buf_error_en[i]          = '0;\n         buf_rst[i]               = dec_tlu_force_halt;\n         buf_ldfwd_en[i]          = dec_tlu_force_halt;\n         buf_ldfwd_in[i]          = '0;\n         buf_ldfwdtag_in[i]       = '0;\n\n         case (buf_state[i])\n            IDLE: begin\n                     buf_nxtstate[i] = lsu_bus_clk_en ? CMD : WAIT;\n                     buf_state_en[i] = (lsu_busreq_dc5 & lsu_commit_dc5 & (lsu_pkt_dc5.tid ~^ tid) & (((ibuf_byp | ldst_dual_dc5) & ~ibuf_merge_en & (i == WrPtr0_dc5)) | (ibuf_byp & ldst_dual_dc5 & (i == WrPtr1_dc5)))) |\n                                       (ibuf_drain_vld & (i == ibuf_tag));\n                     buf_wr_en[i]    = buf_state_en[i];\n                     buf_data_en[i]  = buf_state_en[i];\n                     buf_data_in[i]   = (ibuf_drain_vld & (i == ibuf_tag)) ? ibuf_data_out[31:0] : store_data_lo_dc5[31:0];\n                     buf_cmd_state_bus_en[i]  = '0;\n            end\n            WAIT: begin\n                     buf_nxtstate[i] = CMD;\n                     buf_state_en[i] = lsu_bus_clk_en;\n                     buf_cmd_state_bus_en[i]  = '0;\n            end\n            CMD: begin\n                     buf_nxtstate[i]          = dec_tlu_force_halt ? IDLE :\n                                                      (obuf_nosend & bus_rsp_read & (bus_rsp_read_tid == tid) & (bus_rsp_read_tag == obuf_rdrsp_tag)) ? DONE_WAIT : RESP;\n                     buf_cmd_state_bus_en[i]  = ((obuf_tag0 == i) | (obuf_merge & (obuf_tag1 == i))) & obuf_valid & obuf_wr_enQ;  // Just use the recently written obuf_valid\n                     buf_state_bus_en[i]      = buf_cmd_state_bus_en[i];\n                     buf_state_en[i]          = (buf_state_bus_en[i] & lsu_bus_clk_en) | dec_tlu_force_halt;\n                     buf_ldfwd_in[i]          = 1'b1;\n                     buf_ldfwd_en[i]          = buf_state_en[i] & ~buf_write[i] & obuf_nosend & ~dec_tlu_force_halt;\n                     buf_ldfwdtag_in[i]       = DEPTH_LOG2'(obuf_rdrsp_tag[pt.LSU_BUS_TAG-2:0]);\n                     buf_data_en[i]           = buf_state_bus_en[i] & lsu_bus_clk_en & obuf_nosend & bus_rsp_read;\n                     buf_error_en[i]          = buf_state_bus_en[i] & lsu_bus_clk_en & obuf_nosend & bus_rsp_read_error & (bus_rsp_read_tid == tid) & (bus_rsp_read_tag == obuf_rdrsp_tag);\n                     buf_data_in[i]           = buf_error_en[i] ? bus_rsp_rdata[31:0] : (buf_addr[i][2] ? bus_rsp_rdata[63:32] : bus_rsp_rdata[31:0]);\n           end\n            RESP: begin\n                     buf_nxtstate[i]           = (dec_tlu_force_halt | (buf_write[i] & ~(pt.BUILD_AXI_NATIVE & bus_rsp_write_error))) ? IDLE :    // Side-effect writes will be non-posted\n                                                      (buf_dual[i] & ~buf_samedw[i] & ~buf_write[i] & (buf_state[buf_dualtag[i]] != DONE_PARTIAL)) ? DONE_PARTIAL : // Goto DONE_PARTIAL if this is the first return of dual\n                                                           (buf_ldfwd[i] | any_done_wait_state | (any_done_state & (lsu_nonblock_load_data_tid^tid)) |\n                                                            (buf_dual[i] & ~buf_samedw[i] & ~buf_write[i] & buf_ldfwd[buf_dualtag[i]] &\n                                                             (buf_state[buf_dualtag[i]] == DONE_PARTIAL) & (any_done_wait_state | (any_done_state & (lsu_nonblock_load_data_tid^tid))))) ? DONE_WAIT : DONE;\n                     buf_resp_state_bus_en[i]  = (bus_rsp_write & (bus_rsp_write_tid == tid) & (bus_rsp_write_tag == (pt.LSU_BUS_TAG)'(i))) |\n                                                 (bus_rsp_read  & (bus_rsp_read_tid == tid)  & ((bus_rsp_read_tag == (pt.LSU_BUS_TAG)'(i)) |\n                                                                                                (buf_ldfwd[i] & (bus_rsp_read_tag == (pt.LSU_BUS_TAG)'(buf_ldfwdtag[i]))) |\n                                                                                                (buf_dual[i] & buf_dualhi[i] & ~buf_write[i] & buf_samedw[i] & (bus_rsp_read_tag == (pt.LSU_BUS_TAG)'(buf_dualtag[i])))));\n                     buf_state_bus_en[i]       = buf_resp_state_bus_en[i];\n                     buf_state_en[i]           = (buf_state_bus_en[i] & lsu_bus_clk_en) | dec_tlu_force_halt;\n                     buf_data_en[i]            = buf_state_bus_en[i] & bus_rsp_read & lsu_bus_clk_en;\n                      // Need to capture the error for stores as well for AXI\n                     buf_error_en[i]           = buf_state_bus_en[i] & lsu_bus_clk_en & ((bus_rsp_read_error  & (bus_rsp_read_tid == tid)  & (bus_rsp_read_tag  == (pt.LSU_BUS_TAG)'(i))) |\n                                                                                         (bus_rsp_read_error  & (bus_rsp_read_tid == tid)  & buf_ldfwd[i] & (bus_rsp_read_tag == (pt.LSU_BUS_TAG)'(buf_ldfwdtag[i]))) |\n                                                                                         (bus_rsp_write_error & (bus_rsp_write_tid == tid) & pt.BUILD_AXI_NATIVE & (bus_rsp_write_tag == (pt.LSU_BUS_TAG)'(i))));\n                     buf_data_in[i][31:0]      = (buf_state_en[i] & ~buf_error_en[i]) ? (buf_addr[i][2] ? bus_rsp_rdata[63:32] : bus_rsp_rdata[31:0]) : bus_rsp_rdata[31:0];\n                     buf_cmd_state_bus_en[i]  = '0;\n            end\n            DONE_PARTIAL: begin   // Other part of dual load hasn't returned\n                     buf_nxtstate[i]           = dec_tlu_force_halt ? IDLE : (buf_ldfwd[i] | buf_ldfwd[buf_dualtag[i]] | any_done_wait_state | (any_done_state & (lsu_nonblock_load_data_tid^tid))) ? DONE_WAIT : DONE;\n                     buf_state_bus_en[i]       = bus_rsp_read & (bus_rsp_read_tid == tid) & ((bus_rsp_read_tag == (pt.LSU_BUS_TAG)'(buf_dualtag[i])) |\n                                                                                             (buf_ldfwd[buf_dualtag[i]] & (bus_rsp_read_tag == (pt.LSU_BUS_TAG)'(buf_ldfwdtag[buf_dualtag[i]]))));\n                     buf_state_en[i]           = (buf_state_bus_en[i] & lsu_bus_clk_en) | dec_tlu_force_halt;\n                     buf_cmd_state_bus_en[i]  = '0;\n            end\n            DONE_WAIT: begin  // WAIT state if there are multiple outstanding nb returns\n                      buf_nxtstate[i]           = dec_tlu_force_halt ? IDLE : DONE;\n                      buf_state_en[i]           = (((RspPtr == DEPTH_LOG2'(i)) | (buf_dual[i] & (buf_dualtag[i] == RspPtr))) & ((lsu_nonblock_load_data_tid == tid) | ~any_done_state)) | dec_tlu_force_halt;\n                      buf_cmd_state_bus_en[i]  = '0;\n            end\n            DONE: begin\n                     buf_nxtstate[i]           = IDLE;\n                     buf_rst[i]                = buf_write[i] | ((lsu_nonblock_load_data_valid | lsu_nonblock_load_data_error) & (lsu_nonblock_load_data_tid == tid));\n                     buf_state_en[i]           = buf_rst[i] | dec_tlu_force_halt;\n                     buf_ldfwd_in[i]           = 1'b0;\n                     buf_ldfwd_en[i]           = buf_state_en[i];\n                     buf_cmd_state_bus_en[i]  = '0;\n            end\n            default : begin\n                     buf_nxtstate[i]          = IDLE;\n                     buf_state_en[i]          = '0;\n                     buf_cmd_state_bus_en[i]  = '0;\n                     buf_resp_state_bus_en[i] = '0;\n                     buf_state_bus_en[i]      = '0;\n                     buf_wr_en[i]             = '0;\n                     buf_data_in[i]           = '0;\n                     buf_data_en[i]           = '0;\n                     buf_error_en[i]          = '0;\n                     buf_rst[i]               = '0;\n            end\n         endcase\n      end\n\n      rvdffs  #(.WIDTH($bits(state_t))) buf_state_ff     (.din(buf_nxtstate[i]),             .dout({buf_state[i]}),    .en(buf_state_en[i]),                                        .clk(lsu_bus_buf_c1_clk), .*);\n      rvdff   #(.WIDTH(DEPTH))          buf_ageff        (.din(buf_age_in[i]),               .dout(buf_ageQ[i]),                                                                    .clk(lsu_bus_buf_c1_clk), .*);\n      rvdff   #(.WIDTH(DEPTH))          buf_rspageff     (.din(buf_rspage_in[i]),            .dout(buf_rspageQ[i]),                                                                 .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(DEPTH_LOG2))     buf_dualtagff    (.din(buf_dualtag_in[i]),           .dout(buf_dualtag[i]),    .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_dualff       (.din(buf_dual_in[i]),              .dout(buf_dual[i]),       .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_samedwff     (.din(buf_samedw_in[i]),            .dout(buf_samedw[i]),     .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_nomergeff    (.din(buf_nomerge_in[i]),           .dout(buf_nomerge[i]),    .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_dualhiff     (.din(buf_dualhi_in[i]),            .dout(buf_dualhi[i]),     .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_ldfwdff      (.din(buf_ldfwd_in[i]),             .dout(buf_ldfwd[i]),      .en(buf_ldfwd_en[i]),                                        .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(DEPTH_LOG2))     buf_ldfwdtagff   (.din(buf_ldfwdtag_in[i]),          .dout(buf_ldfwdtag[i]),   .en(buf_ldfwd_en[i]),                                        .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_sideeffectff (.din(buf_sideeffect_in[i]),        .dout(buf_sideeffect[i]), .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_unsignff     (.din(buf_unsign_in[i]),            .dout(buf_unsign[i]),     .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(1))              buf_writeff      (.din(buf_write_in[i]),             .dout(buf_write[i]),      .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffs  #(.WIDTH(2))              buf_szff         (.din(buf_sz_in[i]),                .dout(buf_sz[i]),         .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffe  #(.WIDTH(32))             buf_addrff       (.din(buf_addr_in[i][31:0]),        .dout(buf_addr[i]),       .en(buf_wr_en[i]),                                                                     .*);\n      rvdffs  #(.WIDTH(4))              buf_byteenff     (.din(buf_byteen_in[i][3:0]),       .dout(buf_byteen[i]),     .en(buf_wr_en[i]),                                           .clk(lsu_bus_buf_c1_clk), .*);\n      rvdffe  #(.WIDTH(32))             buf_dataff       (.din(buf_data_in[i][31:0]),        .dout(buf_data[i]),       .en(buf_data_en[i]),                                                                   .*);\n      rvdffsc #(.WIDTH(1))              buf_errorff      (.din(1'b1),                        .dout(buf_error[i]),      .en(buf_error_en[i]),                    .clear(buf_rst[i]), .clk(lsu_bus_buf_c1_clk), .*);\n\n   end\n\n   // buffer full logic\n   always_comb begin\n      buf_numvld_any[3:0] =  ({3'b0,(lsu_pkt_dc1_pre.valid & (lsu_pkt_dc1_pre.tid ~^ tid))} << (lsu_pkt_dc1_pre.valid & ldst_dual_dc1)) +\n                             ({3'b0,(lsu_busreq_dc2 & (lsu_pkt_dc2.tid ~^ tid))} << (lsu_busreq_dc2 & ldst_dual_dc2)) +\n                             ({3'b0,(lsu_busreq_dc3 & (lsu_pkt_dc3.tid ~^ tid))} << (lsu_busreq_dc3 & ldst_dual_dc3)) +\n                             ({3'b0,(lsu_busreq_dc4 & (lsu_pkt_dc4.tid ~^ tid))} << (lsu_busreq_dc4 & ldst_dual_dc4)) +\n                             ({3'b0,(lsu_busreq_dc5 & (lsu_pkt_dc5.tid ~^ tid))} << (lsu_busreq_dc5 & ldst_dual_dc5)) +\n                             {3'b0,ibuf_valid};\n      buf_numvld_wrcmd_any[3:0] = 4'b0;\n      buf_numvld_cmd_any[3:0] = 4'b0;\n      buf_numvld_pend_any[3:0] = 4'b0;\n      any_done_wait_state = 1'b0;\n      any_done_state = 1'b0;\n      for (int i=0; i<DEPTH; i++) begin\n         buf_numvld_any[3:0] += {3'b0, (buf_state[i] != IDLE)};\n         buf_numvld_wrcmd_any[3:0] += {3'b0, (buf_write[i] & (buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i])};\n         buf_numvld_cmd_any[3:0]   += {3'b0, ((buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i])};\n         buf_numvld_pend_any[3:0]   += {3'b0, ((buf_state[i] == WAIT) | ((buf_state[i] == CMD) & ~buf_cmd_state_bus_en[i]))};\n         any_done_wait_state |= (buf_state[i] == DONE_WAIT);\n         any_done_state      |= (buf_state[i] == DONE);\n      end\n   end\n\n   assign lsu_bus_buffer_pend_any = (buf_numvld_pend_any != 0);\n   assign lsu_bus_buffer_full_any = (buf_numvld_any[3:0] >= (DEPTH-1));\n   assign lsu_bus_buffer_empty_any = ~(|buf_state[DEPTH-1:0]) & ~ibuf_valid & ~obuf_valid;\n\n   // Non blocking ports\n   always_comb begin\n      lsu_nonblock_load_data_ready   = '0;\n      lsu_nonblock_load_rtn_valid    = '0;\n      lsu_nonblock_load_data_error   = '0;\n      lsu_nonblock_load_data_tag[DEPTH_LOG2-1:0] = '0;\n      lsu_nonblock_load_data_lo[31:0] = '0;\n      lsu_nonblock_load_data_hi[31:0] = '0;\n      for (int i=0; i<DEPTH; i++) begin\n          lsu_nonblock_load_data_ready         |= (buf_state[i] == DONE) & ~(pt.BUILD_AXI_NATIVE & buf_write[i]);\n          lsu_nonblock_load_data_error         |= (buf_state[i] == DONE) & buf_error[i] & ~buf_write[i];\n          lsu_nonblock_load_data_tag[DEPTH_LOG2-1:0]   |= DEPTH_LOG2'(i) & {DEPTH_LOG2{(~buf_write[i] & (buf_state[i] == DONE) & (~buf_dual[i] | ~buf_dualhi[i]))}};\n          lsu_nonblock_load_data_lo[31:0]      |= buf_data[i][31:0] & {32{(~buf_write[i] & (buf_state[i] == DONE) & (~buf_dual[i] | ~buf_dualhi[i]))}};\n          lsu_nonblock_load_data_hi[31:0]      |= buf_data[i][31:0] & {32{(~buf_write[i] & (buf_state[i] == DONE) & (buf_dual[i] & buf_dualhi[i]))}};\n      end\n   end\n\n   assign lsu_nonblock_addr_offset[1:0] = buf_addr[lsu_nonblock_load_data_tag][1:0];\n   assign lsu_nonblock_sz[1:0]          = buf_sz[lsu_nonblock_load_data_tag][1:0];\n   assign lsu_nonblock_unsign           = buf_unsign[lsu_nonblock_load_data_tag];\n   assign lsu_nonblock_dual             = buf_dual[lsu_nonblock_load_data_tag];\n   assign lsu_nonblock_data_unalgn[31:0] = 32'({lsu_nonblock_load_data_hi[31:0], lsu_nonbl"}
{"text": "ock_load_data_lo[31:0]} >> 8*lsu_nonblock_addr_offset[1:0]);\n\n   assign lsu_nonblock_load_data_valid = lsu_nonblock_load_data_ready & ~lsu_nonblock_load_data_error;\n   assign lsu_nonblock_load_data = ({32{ lsu_nonblock_unsign & (lsu_nonblock_sz[1:0] == 2'b00)}} & {24'b0,lsu_nonblock_data_unalgn[7:0]}) |\n                                   ({32{ lsu_nonblock_unsign & (lsu_nonblock_sz[1:0] == 2'b01)}} & {16'b0,lsu_nonblock_data_unalgn[15:0]}) |\n                                   ({32{~lsu_nonblock_unsign & (lsu_nonblock_sz[1:0] == 2'b00)}} & {{24{lsu_nonblock_data_unalgn[7]}}, lsu_nonblock_data_unalgn[7:0]}) |\n                                   ({32{~lsu_nonblock_unsign & (lsu_nonblock_sz[1:0] == 2'b01)}} & {{16{lsu_nonblock_data_unalgn[15]}},lsu_nonblock_data_unalgn[15:0]}) |\n                                   ({32{(lsu_nonblock_sz[1] == 1'b1)}} & lsu_nonblock_data_unalgn[31:0]);\n\n   // Determine if there is a pending return to sideeffect load/store\n   always_comb begin\n      bus_sideeffect_pend = obuf_valid & obuf_sideeffect & dec_tlu_sideeffect_posted_disable;\n      for (int i=0; i<DEPTH; i++) begin\n         bus_sideeffect_pend |= ((buf_state[i] == RESP) & buf_sideeffect[i] & dec_tlu_sideeffect_posted_disable);\n      end\n   end\n\n   // We have no ordering rules for AXI. Need to check outstanding trxns to same address for AXI\n   always_comb begin\n      bus_addr_match_pending = '0;\n      for (int i=0; i<DEPTH; i++) begin\n         bus_addr_match_pending |= (pt.BUILD_AXI_NATIVE & obuf_valid & (obuf_addr[31:3] == buf_addr[i][31:3]) & (buf_state[i] == RESP) & ~((obuf_tag0 == (pt.LSU_BUS_TAG)'(i)) | (obuf_merge & (obuf_tag1 == (pt.LSU_BUS_TAG)'(i)))));\n      end\n   end\n\n   always_comb begin\n      lsu_imprecise_error_store_any = '0;\n      lsu_imprecise_error_store_tag = '0;\n      for (int i=0; i<DEPTH; i++) begin\n         lsu_imprecise_error_store_any |= lsu_bus_clk_en_q & (buf_state[i] == DONE) & buf_error[i] & buf_write[i];\n         lsu_imprecise_error_store_tag |= DEPTH_LOG2'(i) & {DEPTH_LOG2{((buf_state[i] == DONE) & buf_error[i] & buf_write[i])}};\n      end\n   end\n   assign lsu_imprecise_error_load_any       = lsu_nonblock_load_data_error & (lsu_nonblock_load_data_tid == tid) & ~lsu_imprecise_error_store_any;   // This is to make sure we send only one imprecise error for loads\n   assign lsu_imprecise_error_addr_any[31:0] = lsu_imprecise_error_store_any ? buf_addr[lsu_imprecise_error_store_tag] : buf_addr[lsu_nonblock_load_data_tag];\n\n   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr0_dc2ff (.din(WrPtr0_dc1), .dout(WrPtr0_dc2), .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr0_dc3ff (.din(WrPtr0_dc2), .dout(WrPtr0_dc3), .clk(lsu_c2_dc3_clk), .*);\n   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr0_dc4ff (.din(WrPtr0_dc3), .dout(WrPtr0_dc4), .clk(lsu_c2_dc4_clk), .*);\n   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr0_dc5ff (.din(WrPtr0_dc4), .dout(WrPtr0_dc5), .clk(lsu_c2_dc5_clk), .*);\n   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr1_dc2ff (.din(WrPtr1_dc1), .dout(WrPtr1_dc2), .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr1_dc3ff (.din(WrPtr1_dc2), .dout(WrPtr1_dc3), .clk(lsu_c2_dc3_clk), .*);\n   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr1_dc4ff (.din(WrPtr1_dc3), .dout(WrPtr1_dc4), .clk(lsu_c2_dc4_clk), .*);\n   rvdff #(.WIDTH(DEPTH_LOG2)) lsu_WrPtr1_dc5ff (.din(WrPtr1_dc4), .dout(WrPtr1_dc5), .clk(lsu_c2_dc5_clk), .*);\n\n`ifdef RV_ASSERT_ON\n\n   for (genvar i=0; i<4; i++) begin: GenByte\n      assert_ld_byte_hitvecfn_lo_onehot: assert #0 ($onehot0(ld_byte_hitvecfn_lo[i][DEPTH-1:0]));\n      assert_ld_byte_hitvecfn_hi_onehot: assert #0 ($onehot0(ld_byte_hitvecfn_hi[i][DEPTH-1:0]));\n   end\n\n   for (genvar i=0; i<DEPTH; i++) begin: GenAssertAge\n      assert_bufempty_agevec: assert #0 (~(lsu_bus_buffer_empty_any & |(buf_age[i])));\n   end\n\n   assert_CmdPtr0Dec_onehot: assert #0 ($onehot0(CmdPtr0Dec[DEPTH-1:0] & ~{DEPTH{dec_tlu_force_halt}}));\n   assert_CmdPtr1Dec_onehot: assert #0 ($onehot0(CmdPtr1Dec[DEPTH-1:0] & ~{DEPTH{dec_tlu_force_halt}}));\n\n   property obuf_nosend_sideeffect;\n      @(posedge clk) disable iff (~rst_l) (obuf_valid & obuf_nosend) |-> ~obuf_sideeffect;\n   endproperty\n   assert_obuf_nosend_sideeffect: assert property (obuf_nosend_sideeffect) else\n      $display(\"obuf_nosend set for sideeffect address\");\n\n`endif\n\nendmodule // lsu_bus_buffer\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: lsu interface with interface queue\n// Comments:\n//\n//********************************************************************************\nmodule eh2_lsu_bus_intf\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)(\n   input logic                          clk,\n   input logic                          clk_override,\n   input logic [pt.NUM_THREADS-1:0]     active_thread_l2clk,  // per thread l2 clock\n   input logic                          rst_l,\n   input logic                          scan_mode,\n   input logic                          dec_tlu_external_ldfwd_disable,     // disable load to load forwarding for externals\n   input logic                          dec_tlu_wb_coalescing_disable,      // disable write buffer coalescing\n   input logic                          dec_tlu_sideeffect_posted_disable,  // disable posted writes to sideeffect addr to the bus\n\n   // various clocks needed for the bus reads and writes\n   input logic [pt.NUM_THREADS-1:0]     lsu_bus_obuf_c1_clken,\n   input logic                          lsu_busm_clken,\n   input logic                          lsu_c1_dc3_clk,\n   input logic                          lsu_c1_dc4_clk,\n   input logic                          lsu_c1_dc5_clk,\n   input logic                          lsu_c2_dc2_clk,\n   input logic                          lsu_c2_dc3_clk,\n   input logic                          lsu_c2_dc4_clk,\n   input logic                          lsu_c2_dc5_clk,\n\n   input logic [pt.NUM_THREADS-1:0]     lsu_bus_ibuf_c1_clk,\n   input logic [pt.NUM_THREADS-1:0]     lsu_bus_obuf_c1_clk,\n   input logic [pt.NUM_THREADS-1:0]     lsu_bus_buf_c1_clk,\n   input logic                          lsu_free_c2_clk,\n   input logic                          active_clk,\n   input logic                          lsu_busm_clk,\n\n   input logic                          lsu_busreq_dc1,                   // bus request is in dc2\n\n   input                                eh2_lsu_pkt_t lsu_pkt_dc1_pre,        // lsu packet flowing down the pipe\n   input                                eh2_lsu_pkt_t lsu_pkt_dc2,            // lsu packet flowing down the pipe\n   input                                eh2_lsu_pkt_t lsu_pkt_dc3,            // lsu packet flowing down the pipe\n   input                                eh2_lsu_pkt_t lsu_pkt_dc4,            // lsu packet flowing down the pipe\n   input                                eh2_lsu_pkt_t lsu_pkt_dc5,            // lsu packet flowing down the pipe\n\n   input logic [31:0]                   lsu_addr_dc2,                     // lsu address flowing down the pipe\n   input logic [31:0]                   lsu_addr_dc3,                     // lsu address flowing down the pipe\n   input logic [31:0]                   lsu_addr_dc4,                     // lsu address flowing down the pipe\n   input logic [31:0]                   lsu_addr_dc5,                     // lsu address flowing down the pipe\n\n   input logic [31:0]                   end_addr_dc2,                     // lsu address flowing down the pipe\n   input logic [31:0]                   end_addr_dc3,                     // lsu address flowing down the pipe\n   input logic [31:0]                   end_addr_dc4,                     // lsu address flowing down the pipe\n   input logic [31:0]                   end_addr_dc5,                     // lsu address flowing down the pipe\n\n   input logic [63:0]                   store_data_ext_dc3,               // store data flowing down the pipe\n   input logic [63:0]                   store_data_ext_dc4,               // store data flowing down the pipe\n   input logic [63:0]                   store_data_ext_dc5,               // store data flowing down the pipe\n   input logic [pt.NUM_THREADS-1:0]     dec_tlu_force_halt,\n\n   input logic                          core_ldst_dual_dc1,               // core ld/st is dual\n   input logic                          ldst_dual_dc2, ldst_dual_dc3, ldst_dual_dc4, ldst_dual_dc5,\n   input logic                          lsu_commit_dc5,                   // lsu instruction in dc5 commits\n   input logic                          is_sideeffects_dc2,               // lsu attribute is side_effects\n   input logic                          is_sideeffects_dc3,               // lsu attribute is side_effects\n   input logic [pt.NUM_THREADS-1:0]     flush_dc2_up,                     // flush\n   input logic [pt.NUM_THREADS-1:0]     flush_dc3,                        // flush\n   input logic [pt.NUM_THREADS-1:0]     flush_dc4,                        // flush\n\n   output logic                         lsu_busreq_dc2, lsu_busreq_dc3, lsu_busreq_dc4, lsu_busreq_dc5,\n   output logic [pt.NUM_THREADS-1:0]    dec_tlu_force_halt_bus,           // Bus synchronized version of force halt\n   output logic [pt.NUM_THREADS-1:0]    lsu_bus_idle_any,                 // No pending responses from the bus\n   output logic [pt.NUM_THREADS-1:0]    lsu_bus_buffer_pend_any,          // bus buffer has a pending bus entry\n   output logic [pt.NUM_THREADS-1:0]    lsu_bus_buffer_full_any,          // write buffer is full\n   output logic [pt.NUM_THREADS-1:0]    lsu_bus_buffer_empty_any,         // write buffer is empty\n   output logic [31:0]                  bus_read_data_dc3,                   // the bus return data\n\n   output logic [pt.NUM_THREADS-1:0]         lsu_imprecise_error_load_any,     // imprecise load bus error\n   output logic [pt.NUM_THREADS-1:0]         lsu_imprecise_error_store_any,    // imprecise store bus error\n   output logic [pt.NUM_THREADS-1:0][31:0]   lsu_imprecise_error_addr_any,     // address of the imprecise error\n\n   // Non-blocking loads\n   output logic                               lsu_nonblock_load_valid_dc1,     // there is an external load -> put in the cam\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_tag_dc1,       // the tag of the external non block load\n   output logic                               lsu_nonblock_load_inv_dc2,       // Invalidate the non-block load bcoz of memory forwarding\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_inv_tag_dc2,\n   output logic                               lsu_nonblock_load_inv_dc5,       // invalidate signal for the cam entry for non block loads\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_inv_tag_dc5,   // tag of the enrty which needs to be invalidated\n   output logic                               lsu_nonblock_load_data_valid,    // the non block is valid - sending information back to the cam\n   output logic                               lsu_nonblock_load_data_error,    // non block load has an error\n   output logic                               lsu_nonblock_load_data_tid,      // tid for nonblock load return\n   output logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0] lsu_nonblock_load_data_tag,      // the tag of the non block load sending the data/error\n   output logic [31:0]                        lsu_nonblock_load_data,          // Data of the non block load\n\n   // PMU events\n   output logic [pt.NUM_THREADS-1:0]    lsu_pmu_bus_trxn,\n   output logic [pt.NUM_THREADS-1:0]    lsu_pmu_bus_misaligned,\n   output logic [pt.NUM_THREADS-1:0]    lsu_pmu_bus_error,\n   output logic [pt.NUM_THREADS-1:0]    lsu_pmu_bus_busy,\n\n   //-------------------------- LSU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                         lsu_axi_awvalid,\n   input  logic                         lsu_axi_awready,\n   output logic [pt.LSU_BUS_TAG-1:0]    lsu_axi_awid,\n   output logic [31:0]                  lsu_axi_awaddr,\n   output logic [3:0]                   lsu_axi_awregion,\n   output logic [7:0]                   lsu_axi_awlen,\n   output logic [2:0]                   lsu_axi_awsize,\n   output logic [1:0]                   lsu_axi_awburst,\n   output logic                         lsu_axi_awlock,\n   output logic [3:0]                   lsu_axi_awcache,\n   output logic [2:0]                   lsu_axi_awprot,\n   output logic [3:0]                   lsu_axi_awqos,\n\n   output logic                         lsu_axi_wvalid,\n   input  logic                         lsu_axi_wready,\n   output logic [63:0]                  lsu_axi_wdata,\n   output logic [7:0]                   lsu_axi_wstrb,\n   output logic                         lsu_axi_wlast,\n\n   input  logic                         lsu_axi_bvalid,\n   output logic                         lsu_axi_bready,\n   input  logic [1:0]                   lsu_axi_bresp,\n   input  logic [pt.LSU_BUS_TAG-1:0]    lsu_axi_bid,\n\n   // AXI Read Channels\n   output logic                         lsu_axi_arvalid,\n   input  logic                         lsu_axi_arready,\n   output logic [pt.LSU_BUS_TAG-1:0]    lsu_axi_arid,\n   output logic [31:0]                  lsu_axi_araddr,\n   output logic [3:0]                   lsu_axi_arregion,\n   output logic [7:0]                   lsu_axi_arlen,\n   output logic [2:0]                   lsu_axi_arsize,\n   output logic [1:0]                   lsu_axi_arburst,\n   output logic                         lsu_axi_arlock,\n   output logic [3:0]                   lsu_axi_arcache,\n   output logic [2:0]                   lsu_axi_arprot,\n   output logic [3:0]                   lsu_axi_arqos,\n\n   input  logic                         lsu_axi_rvalid,\n   output logic                         lsu_axi_rready,\n   input  logic [pt.LSU_BUS_TAG-1:0]    lsu_axi_rid,\n   input  logic [63:0]                  lsu_axi_rdata,\n   input  logic [1:0]                   lsu_axi_rresp,\n\n   input logic                          lsu_bus_clk_en\n\n);\n\n   logic              lsu_bus_clk_en_q;\n   logic              ldst_dual_dc1;\n   logic              ldst_samedw_dc5, is_aligned_dc5;\n\n   logic [3:0]        ldst_byteen_dc2, ldst_byteen_dc3, ldst_byteen_dc4, ldst_byteen_dc5;\n   logic [7:0]        ldst_byteen_ext_dc2, ldst_byteen_ext_dc3, ldst_byteen_ext_dc4, ldst_byteen_ext_dc5;\n   logic [3:0]        ldst_byteen_hi_dc2, ldst_byteen_hi_dc3, ldst_byteen_hi_dc4, ldst_byteen_hi_dc5;\n   logic [3:0]        ldst_byteen_lo_dc2, ldst_byteen_lo_dc3, ldst_byteen_lo_dc4, ldst_byteen_lo_dc5;\n   logic              is_sideeffects_dc4, is_sideeffects_dc5;\n\n   logic [31:0]       store_data_hi_dc3, store_data_hi_dc4, store_data_hi_dc5;\n   logic [31:0]       store_data_lo_dc3, store_data_lo_dc4, store_data_lo_dc5;\n\n   logic              addr_match_dw_lo_dc5_dc4, addr_match_dw_lo_dc5_dc3, addr_match_dw_lo_dc5_dc2;\n   logic              addr_match_word_lo_dc5_dc4, addr_match_word_lo_dc5_dc3, addr_match_word_lo_dc5_dc2;\n   logic              no_word_merge_dc5, no_dword_merge_dc5;\n\n   logic              ld_addr_dc3hit_lo_lo, ld_addr_dc3hit_hi_lo, ld_addr_dc3hit_lo_hi, ld_addr_dc3hit_hi_hi;\n   logic              ld_addr_dc4hit_lo_lo, ld_addr_dc4hit_hi_lo, ld_addr_dc4hit_lo_hi, ld_addr_dc4hit_hi_hi;\n   logic              ld_addr_dc5hit_lo_lo, ld_addr_dc5hit_hi_lo, ld_addr_dc5hit_lo_hi, ld_addr_dc5hit_hi_hi;\n\n   logic [3:0]        ld_byte_dc3hit_lo_lo, ld_byte_dc3hit_hi_lo, ld_byte_dc3hit_lo_hi, ld_byte_dc3hit_hi_hi;\n   logic [3:0]        ld_byte_dc4hit_lo_lo, ld_byte_dc4hit_hi_lo, ld_byte_dc4hit_lo_hi, ld_byte_dc4hit_hi_hi;\n   logic [3:0]        ld_byte_dc5hit_lo_lo, ld_byte_dc5hit_hi_lo, ld_byte_dc5hit_lo_hi, ld_byte_dc5hit_hi_hi;\n\n   logic [3:0]        ld_byte_hit_lo, ld_byte_dc3hit_lo, ld_byte_dc4hit_lo, ld_byte_dc5hit_lo;\n   logic [3:0]        ld_byte_hit_hi, ld_byte_dc3hit_hi, ld_byte_dc4hit_hi, ld_byte_dc5hit_hi;\n\n   logic [31:0]       ld_fwddata_dc3pipe_lo, ld_fwddata_dc4pipe_lo, ld_fwddata_dc5pipe_lo;\n   logic [31:0]       ld_fwddata_dc3pipe_hi, ld_fwddata_dc4pipe_hi, ld_fwddata_dc5pipe_hi;\n\n   logic [pt.NUM_THREADS-1:0][3:0]   ld_byte_hit_buf_lo, ld_byte_hit_buf_hi;\n   logic [pt.NUM_THREADS-1:0][31:0]  ld_fwddata_buf_lo, ld_fwddata_buf_hi;\n\n   logic [31:0]       ld_fwddata_lo, ld_fwddata_hi;\n   logic [31:0]       ld_fwddata_dc2, ld_fwddata_dc3;\n\n   logic              ld_full_hit_hi_dc2, ld_full_hit_lo_dc2;\n   logic              ld_full_hit_dc2;\n\n   logic [pt.NUM_THREADS-1:0][pt.LSU_NUM_NBLOAD_WIDTH-1:0] WrPtr0_dc1, WrPtr0_dc2, WrPtr0_dc5;\n\n   logic [63:32]     ld_fwddata_dc2_nc;\n\n   logic             bus_tid, nxt_bus_tid, bus_tid_en;\n\n   // Output buffer signals\n   logic [pt.NUM_THREADS-1:0]                     obuf_valid;\n   logic [pt.NUM_THREADS-1:0]                     obuf_nosend;\n   logic [pt.NUM_THREADS-1:0]                     obuf_write;\n   logic [pt.NUM_THREADS-1:0]                     obuf_sideeffect;\n   logic [pt.NUM_THREADS-1:0][31:0]               obuf_addr;\n   logic [pt.NUM_THREADS-1:0][63:0]               obuf_data;\n   logic [pt.NUM_THREADS-1:0][1:0]                obuf_sz;\n   logic [pt.NUM_THREADS-1:0][7:0]                obuf_byteen;\n   logic [pt.NUM_THREADS-1:0]                     obuf_cmd_done, obuf_data_done;\n   logic [pt.NUM_THREADS-1:0][pt.LSU_BUS_TAG-1:0] obuf_tag0;\n   logic [pt.NUM_THREADS-1:0]                     obuf_nxtready;\n\n   logic                                lsu_nonblock_load_valid_dc2, lsu_nonblock_load_valid_dc3, lsu_nonblock_load_valid_dc4,lsu_nonblock_load_valid_dc5;\n   logic [pt.NUM_THREADS-1:0]           bus_pend_trxn_en;\n   logic [pt.NUM_THREADS-1:0][7:0]      bus_pend_trxn, bus_pend_trxn_ns, bus_pend_trxnQ;\n   logic [pt.NUM_THREADS-1:0]           lsu_bus_cntr_overflow;\n\n   logic [pt.NUM_THREADS-1:0]           bus_addr_match_pending;\n   logic                                bus_cmd_valid, bus_cmd_sent, bus_cmd_ready;\n   logic                                bus_wcmd_sent, bus_wdata_sent;\n\n   logic                                bus_rsp_read, bus_rsp_write;\n   logic                                bus_rsp_tid;\n   logic [pt.LSU_BUS_TAG-1:0]           bus_rsp_read_tag, bus_rsp_write_tag;\n   logic                                bus_rsp_read_tid, bus_rsp_write_tid;\n   logic                                bus_rsp_read_error, bus_rsp_write_error;\n   logic [63:0]                         bus_rsp_rdata;\n\n   logic                                bus_rsp_valid_q, bus_rsp_ready_q, bus_rsp_write_q, bus_rsp_error_q;\n   logic                                bus_rsp_write_tid_q;\n   logic [63:0]                         bus_rsp_rdata_q;\n\n   logic [pt.NUM_THREADS-1:0] tid_bus_buffer_pend_any;\n\n   logic [pt.NUM_THREADS-1:0][31:0] tid_imprecise_error_addr_any;     // address of the imprecise error\n\n   // Non-blocking loads\n   logic [pt.NUM_THREADS-1:0]                              tid_nonblock_load_data_ready;\n   logic [pt.NUM_THREADS-1:0]                              tid_nonblock_load_data_valid;\n   logic [pt.NUM_THREADS-1:0]                              tid_nonblock_load_data_error;\n   logic [pt.NUM_THREADS-1:0][pt.LSU_NUM_NBLOAD_WIDTH-1:0] tid_nonblock_load_data_tag;\n   logic [pt.NUM_THREADS-1:0][31:0]                        tid_nonblock_load_data;\n\n   logic                                                   bus_coalescing_disable;\n\n   logic                   lsu_axi_awvalid_q, lsu_axi_awready_q;\n   logic                   lsu_axi_wvalid_q, lsu_axi_wready_q;\n   logic                   lsu_axi_arvalid_q, lsu_axi_arready_q;\n   logic                   lsu_axi_bvalid_q, lsu_axi_bready_q;\n   logic                   lsu_axi_rvalid_q, lsu_axi_rready_q;\n   logic [pt.LSU_BUS_TAG-1:0] lsu_axi_bid_q, lsu_axi_rid_q;\n   logic [1:0]             lsu_axi_bresp_q, lsu_axi_rresp_q;\n   logic [63:0]            lsu_axi_rdata_q;\n\n   //------------------------------------------------------------------------------------------------------------\n   //----------------------------------------Logic starts here---------------------------------------------------\n   //------------------------------------------------------------------------------------------------------------\n\n   assign bus_coalescing_disable = dec_tlu_wb_coalescing_disable | pt.BUILD_AHB_LITE;  // No coalescing for ahb\n\n   assign ldst_byteen_dc2[3:0] = ({4{lsu_pkt_dc2.by}}   & 4'b0001) |\n                                 ({4{lsu_pkt_dc2.half}} & 4'b0011) |\n                                 ({4{lsu_pkt_dc2.word | lsu_pkt_dc2.dword}} & 4'b1111);\n   assign ldst_dual_dc1   = core_ldst_dual_dc1;\n   assign ldst_samedw_dc5 = (lsu_addr_dc5[3] == end_addr_dc5[3]);\n   assign is_aligned_dc5    = (lsu_pkt_dc5.word & (lsu_addr_dc5[1:0] == 2'b0)) |\n                              (lsu_pkt_dc5.half & (lsu_addr_dc5[0] == 1'b0)) |\n                              lsu_pkt_dc5.by;\n\n   // Logic to determine if dc5 store can be coalesced or not with younger stores. Bypass ibuf if cannot colaesced\n   assign addr_match_dw_lo_dc5_dc4 = (lsu_addr_dc5[31:3] == lsu_addr_dc4[31:3]);\n   assign addr_match_dw_lo_dc5_dc3 = (lsu_addr_dc5[31:3] == lsu_addr_dc3[31:3]);\n   assign addr_match_dw_lo_dc5_dc2 = (lsu_addr_dc5[31:3] == lsu_addr_dc2[31:3]);\n\n   assign addr_match_word_lo_dc5_dc4 = addr_match_dw_lo_dc5_dc4 & ~(lsu_addr_dc5[2]^lsu_addr_dc4[2]);\n   assign addr_match_word_lo_dc5_dc3 = addr_match_dw_lo_dc5_dc3 & ~(lsu_addr_dc5[2]^lsu_addr_dc3[2]);\n   assign addr_match_word_lo_dc5_dc2 = addr_match_dw_lo_dc5_dc2 & ~(lsu_addr_dc5[2]^lsu_addr_dc2[2]);\n\n   assign no_word_merge_dc5  = lsu_busreq_dc5 & ~ldst_dual_dc5 &\n                               ((lsu_busreq_dc4 & (lsu_pkt_dc4.tid ~^ lsu_pkt_dc5.tid) & (lsu_pkt_dc4.load | ~addr_match_word_lo_dc5_dc4)) |\n                                (lsu_busreq_dc3 & (lsu_pkt_dc3.tid ~^ lsu_pkt_dc5.tid) & ~(lsu_busreq_dc4 & (lsu_pkt_dc4.tid ~^ lsu_pkt_dc5.tid)) & (lsu_pkt_dc3.load | ~addr_match_word_lo_dc5_dc3)) |\n                                (lsu_busreq_dc2 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc5.tid) & ~(lsu_busreq_dc3 & (lsu_pkt_dc3.tid ~^ lsu_pkt_dc5.tid)) & ~(lsu_busreq_dc4 & (lsu_pkt_dc4.tid ~^ lsu_pkt_dc5.tid)) & (lsu_pkt_dc2.load | ~addr_match_word_lo_dc5_dc2)));\n\n   assign no_dword_merge_dc5  = lsu_busreq_dc5 & ~ldst_dual_dc5 &\n                                ((lsu_busreq_dc4 & (lsu_pkt_dc4.tid ~^ lsu_pkt_dc5.tid) & (lsu_pkt_dc4.load | ~addr_match_dw_lo_dc5_dc4)) |\n                                 (lsu_busreq_dc3 & (lsu_pkt_dc3.tid ~^ lsu_pkt_dc5.tid) & ~(lsu_busreq_dc4 & (lsu_pkt_dc4.tid ~^ lsu_pkt_dc5.tid)) & (lsu_pkt_dc3.load | ~addr_match_dw_lo_dc5_dc3)) |\n                                 (lsu_busreq_dc2 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc5.tid) & ~(lsu_busreq_dc3 & (lsu_pkt_dc3.tid ~^ lsu_pkt_dc5.tid))  & ~(lsu_busreq_dc4 & (lsu_pkt_dc4.tid ~^ lsu_pkt_dc5.tid))  & (lsu_pkt_dc2.load | ~addr_match_dw_lo_dc5_dc2)));\n\n   // Create Hi/Lo signals\n   assign ldst_byteen_ext_dc2[7:0] = {4'b0,ldst_byteen_dc2[3:0]} << lsu_addr_dc2[1:0];\n   assign ldst_byteen_ext_dc3[7:0] = {4'b0,ldst_byteen_dc3[3:0]} << lsu_addr_dc3[1:0];\n   assign ldst_byteen_ext_dc4[7:0] = {4'b0,ldst_byteen_dc4[3:0]} << lsu_addr_dc4[1:0];\n   assign ldst_byteen_ext_dc5[7:0] = {4'b0,ldst_byteen_dc5[3:0]} << lsu_addr_dc5[1:0];\n\n   assign ldst_byteen_hi_dc2[3:0]   = ldst_byteen_ext_dc2[7:4];\n   assign ldst_byteen_lo_dc2[3:0]   = ldst_byteen_ext_dc2[3:0];\n   assign ldst_byteen_hi_dc3[3:0]   = ldst_byteen_ext_dc3[7:4];\n   assign ldst_byteen_lo_dc3[3:0]   = ldst_byteen_ext_dc3[3:0];\n   assign ldst_byteen_hi_dc4[3:0]   = ldst_byteen_ext_dc4[7:4];\n   assign ldst_byteen_lo_dc4[3:0]   = ldst_byteen_ext_dc4[3:0];\n   assign ldst_byteen_hi_dc5[3:0]   = ldst_byteen_ext_dc5[7:4];\n   assign ldst_byteen_lo_dc5[3:0]   = ldst_byteen_ext_dc5[3:0];\n\n   assign store_data_hi_dc3[31:0]   = store_data_ext_dc3[63:32];\n   assign"}
{"text": " store_data_lo_dc3[31:0]   = store_data_ext_dc3[31:0];\n   assign store_data_hi_dc4[31:0]   = store_data_ext_dc4[63:32];\n   assign store_data_lo_dc4[31:0]   = store_data_ext_dc4[31:0];\n   assign store_data_hi_dc5[31:0]   = store_data_ext_dc5[63:32];\n   assign store_data_lo_dc5[31:0]   = store_data_ext_dc5[31:0];\n\n   assign ld_addr_dc3hit_lo_lo = (lsu_addr_dc2[31:2] == lsu_addr_dc3[31:2]) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store & lsu_busreq_dc2 & lsu_busreq_dc3 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc3.tid);\n   assign ld_addr_dc3hit_lo_hi = (end_addr_dc2[31:2] == lsu_addr_dc3[31:2]) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store & lsu_busreq_dc2 & lsu_busreq_dc3 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc3.tid);\n   assign ld_addr_dc3hit_hi_lo = (lsu_addr_dc2[31:2] == end_addr_dc3[31:2]) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store & lsu_busreq_dc2 & lsu_busreq_dc3 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc3.tid);\n   assign ld_addr_dc3hit_hi_hi = (end_addr_dc2[31:2] == end_addr_dc3[31:2]) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store & lsu_busreq_dc2 & lsu_busreq_dc3 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc3.tid);\n\n   assign ld_addr_dc4hit_lo_lo = (lsu_addr_dc2[31:2] == lsu_addr_dc4[31:2]) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & lsu_busreq_dc2 & lsu_busreq_dc4 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc4.tid);\n   assign ld_addr_dc4hit_lo_hi = (end_addr_dc2[31:2] == lsu_addr_dc4[31:2]) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & lsu_busreq_dc2 & lsu_busreq_dc4 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc4.tid);\n   assign ld_addr_dc4hit_hi_lo = (lsu_addr_dc2[31:2] == end_addr_dc4[31:2]) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & lsu_busreq_dc2 & lsu_busreq_dc4 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc4.tid);\n   assign ld_addr_dc4hit_hi_hi = (end_addr_dc2[31:2] == end_addr_dc4[31:2]) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & lsu_busreq_dc2 & lsu_busreq_dc4 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc4.tid);\n\n   assign ld_addr_dc5hit_lo_lo = (lsu_addr_dc2[31:2] == lsu_addr_dc5[31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.store & lsu_busreq_dc2 & lsu_busreq_dc5 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc5.tid);\n   assign ld_addr_dc5hit_lo_hi = (end_addr_dc2[31:2] == lsu_addr_dc5[31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.store & lsu_busreq_dc2 & lsu_busreq_dc5 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc5.tid);\n   assign ld_addr_dc5hit_hi_lo = (lsu_addr_dc2[31:2] == end_addr_dc5[31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.store & lsu_busreq_dc2 & lsu_busreq_dc5 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc5.tid);\n   assign ld_addr_dc5hit_hi_hi = (end_addr_dc2[31:2] == end_addr_dc5[31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.store & lsu_busreq_dc2 & lsu_busreq_dc5 & (lsu_pkt_dc2.tid ~^ lsu_pkt_dc5.tid);\n\n   for (genvar i=0; i<4; i++) begin\n      assign ld_byte_dc3hit_lo_lo[i] = ld_addr_dc3hit_lo_lo & ldst_byteen_lo_dc3[i] & ldst_byteen_lo_dc2[i];\n      assign ld_byte_dc3hit_lo_hi[i] = ld_addr_dc3hit_lo_hi & ldst_byteen_lo_dc3[i] & ldst_byteen_hi_dc2[i];\n      assign ld_byte_dc3hit_hi_lo[i] = ld_addr_dc3hit_hi_lo & ldst_byteen_hi_dc3[i] & ldst_byteen_lo_dc2[i];\n      assign ld_byte_dc3hit_hi_hi[i] = ld_addr_dc3hit_hi_hi & ldst_byteen_hi_dc3[i] & ldst_byteen_hi_dc2[i];\n\n      assign ld_byte_dc4hit_lo_lo[i] = ld_addr_dc4hit_lo_lo & ldst_byteen_lo_dc4[i] & ldst_byteen_lo_dc2[i];\n      assign ld_byte_dc4hit_lo_hi[i] = ld_addr_dc4hit_lo_hi & ldst_byteen_lo_dc4[i] & ldst_byteen_hi_dc2[i];\n      assign ld_byte_dc4hit_hi_lo[i] = ld_addr_dc4hit_hi_lo & ldst_byteen_hi_dc4[i] & ldst_byteen_lo_dc2[i];\n      assign ld_byte_dc4hit_hi_hi[i] = ld_addr_dc4hit_hi_hi & ldst_byteen_hi_dc4[i] & ldst_byteen_hi_dc2[i];\n\n      assign ld_byte_dc5hit_lo_lo[i] = ld_addr_dc5hit_lo_lo & ldst_byteen_lo_dc5[i] & ldst_byteen_lo_dc2[i];\n      assign ld_byte_dc5hit_lo_hi[i] = ld_addr_dc5hit_lo_hi & ldst_byteen_lo_dc5[i] & ldst_byteen_hi_dc2[i];\n      assign ld_byte_dc5hit_hi_lo[i] = ld_addr_dc5hit_hi_lo & ldst_byteen_hi_dc5[i] & ldst_byteen_lo_dc2[i];\n      assign ld_byte_dc5hit_hi_hi[i] = ld_addr_dc5hit_hi_hi & ldst_byteen_hi_dc5[i] & ldst_byteen_hi_dc2[i];\n\n      assign ld_byte_hit_lo[i] = ld_byte_dc3hit_lo_lo[i] | ld_byte_dc3hit_hi_lo[i] |\n                                 ld_byte_dc4hit_lo_lo[i] | ld_byte_dc4hit_hi_lo[i] |\n                                 ld_byte_dc5hit_lo_lo[i] | ld_byte_dc5hit_hi_lo[i] |\n                                 ld_byte_hit_buf_lo[lsu_pkt_dc2.tid][i];\n\n      assign ld_byte_hit_hi[i] = ld_byte_dc3hit_lo_hi[i] | ld_byte_dc3hit_hi_hi[i] |\n                                 ld_byte_dc4hit_lo_hi[i] | ld_byte_dc4hit_hi_hi[i] |\n                                 ld_byte_dc5hit_lo_hi[i] | ld_byte_dc5hit_hi_hi[i] |\n                                 ld_byte_hit_buf_hi[lsu_pkt_dc2.tid][i];\n\n\n      assign ld_byte_dc3hit_lo[i] = ld_byte_dc3hit_lo_lo[i] | ld_byte_dc3hit_hi_lo[i];\n      assign ld_byte_dc4hit_lo[i] = ld_byte_dc4hit_lo_lo[i] | ld_byte_dc4hit_hi_lo[i];\n      assign ld_byte_dc5hit_lo[i] = ld_byte_dc5hit_lo_lo[i] | ld_byte_dc5hit_hi_lo[i];\n\n      assign ld_byte_dc3hit_hi[i] = ld_byte_dc3hit_lo_hi[i] | ld_byte_dc3hit_hi_hi[i];\n      assign ld_byte_dc4hit_hi[i] = ld_byte_dc4hit_lo_hi[i] | ld_byte_dc4hit_hi_hi[i];\n      assign ld_byte_dc5hit_hi[i] = ld_byte_dc5hit_lo_hi[i] | ld_byte_dc5hit_hi_hi[i];\n\n      assign ld_fwddata_dc3pipe_lo[(8*i)+7:(8*i)] = ({8{ld_byte_dc3hit_lo_lo[i]}} & store_data_lo_dc3[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_dc3hit_hi_lo[i]}} & store_data_hi_dc3[(8*i)+7:(8*i)]);\n      assign ld_fwddata_dc4pipe_lo[(8*i)+7:(8*i)] = ({8{ld_byte_dc4hit_lo_lo[i]}} & store_data_lo_dc4[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_dc4hit_hi_lo[i]}} & store_data_hi_dc4[(8*i)+7:(8*i)]);\n      assign ld_fwddata_dc5pipe_lo[(8*i)+7:(8*i)] = ({8{ld_byte_dc5hit_lo_lo[i]}} & store_data_lo_dc5[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_dc5hit_hi_lo[i]}} & store_data_hi_dc5[(8*i)+7:(8*i)]);\n\n      assign ld_fwddata_dc3pipe_hi[(8*i)+7:(8*i)] = ({8{ld_byte_dc3hit_lo_hi[i]}} & store_data_lo_dc3[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_dc3hit_hi_hi[i]}} & store_data_hi_dc3[(8*i)+7:(8*i)]);\n      assign ld_fwddata_dc4pipe_hi[(8*i)+7:(8*i)] = ({8{ld_byte_dc4hit_lo_hi[i]}} & store_data_lo_dc4[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_dc4hit_hi_hi[i]}} & store_data_hi_dc4[(8*i)+7:(8*i)]);\n      assign ld_fwddata_dc5pipe_hi[(8*i)+7:(8*i)] = ({8{ld_byte_dc5hit_lo_hi[i]}} & store_data_lo_dc5[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_dc5hit_hi_hi[i]}} & store_data_hi_dc5[(8*i)+7:(8*i)]);\n\n      // Final muxing between dc3/dc4/dc5\n      assign ld_fwddata_lo[(8*i)+7:(8*i)] = ld_byte_dc3hit_lo[i]    ? ld_fwddata_dc3pipe_lo[(8*i)+7:(8*i)] :\n                                            ld_byte_dc4hit_lo[i]    ? ld_fwddata_dc4pipe_lo[(8*i)+7:(8*i)] :\n                                            ld_byte_dc5hit_lo[i]    ? ld_fwddata_dc5pipe_lo[(8*i)+7:(8*i)] :\n                                                                      ld_fwddata_buf_lo[lsu_pkt_dc2.tid][(8*i)+7:(8*i)];\n\n      assign ld_fwddata_hi[(8*i)+7:(8*i)] = ld_byte_dc3hit_hi[i]    ? ld_fwddata_dc3pipe_hi[(8*i)+7:(8*i)] :\n                                            ld_byte_dc4hit_hi[i]    ? ld_fwddata_dc4pipe_hi[(8*i)+7:(8*i)] :\n                                            ld_byte_dc5hit_hi[i]    ? ld_fwddata_dc5pipe_hi[(8*i)+7:(8*i)] :\n                                                                      ld_fwddata_buf_hi[lsu_pkt_dc2.tid][(8*i)+7:(8*i)];\n\n   end\n\n   always_comb begin\n      ld_full_hit_lo_dc2 = 1'b1;\n      ld_full_hit_hi_dc2 = 1'b1;\n      for (int i=0; i<4; i++) begin\n         ld_full_hit_lo_dc2 &= (ld_byte_hit_lo[i] | ~ldst_byteen_lo_dc2[i]);\n         ld_full_hit_hi_dc2 &= (ld_byte_hit_hi[i] | ~ldst_byteen_hi_dc2[i]);\n      end\n   end\n\n   // This will be high if all the bytes of load hit the stores in pipe/write buffer (dc3/dc4/dc5/wrbuf)\n   assign ld_full_hit_dc2 = ld_full_hit_lo_dc2 & ld_full_hit_hi_dc2 & lsu_busreq_dc2 & lsu_pkt_dc2.load & ~is_sideeffects_dc2;\n   assign {ld_fwddata_dc2_nc[63:32], ld_fwddata_dc2[31:0]} = {ld_fwddata_hi[31:0], ld_fwddata_lo[31:0]} >> (8*lsu_addr_dc2[1:0]);\n   assign bus_read_data_dc3[31:0]                          = ld_fwddata_dc3[31:0];\n\n   // Non blocking ports\n   assign lsu_nonblock_load_valid_dc1 = lsu_busreq_dc1 & lsu_pkt_dc1_pre.valid & lsu_pkt_dc1_pre.load & ~flush_dc2_up[lsu_pkt_dc1_pre.tid];\n   assign lsu_nonblock_load_tag_dc1[pt.LSU_NUM_NBLOAD_WIDTH-1:0] = WrPtr0_dc1[lsu_pkt_dc1_pre.tid][pt.LSU_NUM_NBLOAD_WIDTH-1:0];\n   assign lsu_nonblock_load_inv_dc2 = lsu_nonblock_load_valid_dc2 & ld_full_hit_dc2;\n   assign lsu_nonblock_load_inv_tag_dc2[pt.LSU_NUM_NBLOAD_WIDTH-1:0] = WrPtr0_dc2[lsu_pkt_dc2.tid][pt.LSU_NUM_NBLOAD_WIDTH-1:0];\n   assign lsu_nonblock_load_inv_dc5 = lsu_nonblock_load_valid_dc5 & ~lsu_commit_dc5;\n   assign lsu_nonblock_load_inv_tag_dc5[pt.LSU_NUM_NBLOAD_WIDTH-1:0] = WrPtr0_dc5[lsu_pkt_dc5.tid][pt.LSU_NUM_NBLOAD_WIDTH-1:0];      // dc5 tag needs to be accurate even if there is no invalidate\n\n   // Generic bus signals\n   assign bus_cmd_ready                      = obuf_write[bus_tid] ? ((obuf_cmd_done[bus_tid] | obuf_data_done[bus_tid]) ? (obuf_cmd_done[bus_tid] ? lsu_axi_wready : lsu_axi_awready) : (lsu_axi_awready & lsu_axi_wready)) : lsu_axi_arready;\n   assign bus_cmd_valid                      = lsu_axi_awvalid | lsu_axi_wvalid | lsu_axi_arvalid;\n   assign bus_wcmd_sent                      = lsu_axi_awvalid & lsu_axi_awready;\n   assign bus_wdata_sent                     = lsu_axi_wvalid & lsu_axi_wready;\n   assign bus_cmd_sent                       = ((obuf_cmd_done[bus_tid] | bus_wcmd_sent) & (obuf_data_done[bus_tid] | bus_wdata_sent)) | (lsu_axi_arvalid & lsu_axi_arready);\n\n   assign bus_rsp_read                       = lsu_axi_rvalid & lsu_axi_rready;\n   assign bus_rsp_write                      = lsu_axi_bvalid & lsu_axi_bready;\n   assign bus_rsp_read_tag[pt.LSU_BUS_TAG-1:0]  = lsu_axi_rid[pt.LSU_BUS_TAG-2:0];\n   assign bus_rsp_write_tag[pt.LSU_BUS_TAG-1:0] = lsu_axi_bid[pt.LSU_BUS_TAG-2:0];\n   assign bus_rsp_write_error                = bus_rsp_write & (lsu_axi_bresp[1:0] != 2'b0);\n   assign bus_rsp_read_error                 = bus_rsp_read  & (lsu_axi_rresp[1:0] != 2'b0);\n   assign bus_rsp_rdata[63:0]                = lsu_axi_rdata[63:0];\n   assign bus_rsp_read_tid                   = lsu_axi_rid[pt.LSU_BUS_TAG-1];\n   assign bus_rsp_write_tid                  = lsu_axi_bid[pt.LSU_BUS_TAG-1];\n\n   assign bus_rsp_write_tid_q                = lsu_axi_bid_q[pt.LSU_BUS_TAG-1];\n\n   // AXI command signals\n   assign lsu_axi_awvalid               = obuf_valid[bus_tid] & obuf_write[bus_tid] & ~obuf_cmd_done[bus_tid] & ~bus_addr_match_pending[bus_tid];\n   assign lsu_axi_awid[pt.LSU_BUS_TAG-1:0] = (pt.LSU_BUS_TAG)'({bus_tid,obuf_tag0[bus_tid][pt.LSU_BUS_TAG-2:0]});\n   assign lsu_axi_awaddr[31:0]          = obuf_sideeffect[bus_tid] ? obuf_addr[bus_tid][31:0] : {obuf_addr[bus_tid][31:3],3'b0};\n   assign lsu_axi_awsize[2:0]           = obuf_sideeffect[bus_tid] ? {1'b0, obuf_sz[bus_tid][1:0]} : 3'b011;\n   assign lsu_axi_awprot[2:0]           = 3'b001;\n   assign lsu_axi_awcache[3:0]          = obuf_sideeffect[bus_tid]? 4'b0 : 4'b1111;\n   assign lsu_axi_awregion[3:0]         = obuf_addr[bus_tid][31:28];\n   assign lsu_axi_awlen[7:0]            = '0;\n   assign lsu_axi_awburst[1:0]          = 2'b01;\n   assign lsu_axi_awqos[3:0]            = '0;\n   assign lsu_axi_awlock                = '0;\n\n   assign lsu_axi_wvalid                = obuf_valid[bus_tid] & obuf_write[bus_tid] & ~obuf_data_done[bus_tid] & ~bus_addr_match_pending[bus_tid];\n   assign lsu_axi_wstrb[7:0]            = obuf_byteen[bus_tid][7:0] & {8{obuf_write[bus_tid]}};\n   assign lsu_axi_wdata[63:0]           = obuf_data[bus_tid][63:0];\n   assign lsu_axi_wlast                 = '1;\n\n   assign lsu_axi_arvalid               = obuf_valid[bus_tid] & ~obuf_nosend[bus_tid] & ~obuf_write[bus_tid] & ~bus_addr_match_pending[bus_tid];\n   assign lsu_axi_arid[pt.LSU_BUS_TAG-1:0] = (pt.LSU_BUS_TAG)'({bus_tid,obuf_tag0[bus_tid][pt.LSU_BUS_TAG-2:0]});\n   assign lsu_axi_araddr[31:0]          = obuf_sideeffect[bus_tid] ? obuf_addr[bus_tid][31:0] : {obuf_addr[bus_tid][31:3],3'b0};\n   assign lsu_axi_arsize[2:0]           = obuf_sideeffect[bus_tid] ? {1'b0, obuf_sz[bus_tid][1:0]} : 3'b011;\n   assign lsu_axi_arprot[2:0]           = 3'b001;\n   assign lsu_axi_arcache[3:0]          = obuf_sideeffect[bus_tid] ? 4'b0 : 4'b1111;\n   assign lsu_axi_arregion[3:0]         = obuf_addr[bus_tid][31:28];\n   assign lsu_axi_arlen[7:0]            = '0;\n   assign lsu_axi_arburst[1:0]          = 2'b01;\n   assign lsu_axi_arqos[3:0]            = '0;\n   assign lsu_axi_arlock                = '0;\n\n   assign lsu_axi_bready = 1;\n   assign lsu_axi_rready = 1;\n\n   // Count the number of pending trxns for fence\n   assign bus_pend_trxnQ[pt.NUM_THREADS-1:0]    = '0;\n   assign bus_pend_trxn[pt.NUM_THREADS-1:0]     = '0;\n   assign bus_pend_trxn_en[pt.NUM_THREADS-1:0]  = 1'b0;\n   assign lsu_bus_cntr_overflow[pt.NUM_THREADS-1:0] = '0;\n   assign lsu_bus_idle_any[pt.NUM_THREADS-1:0]  = {pt.NUM_THREADS{1'b1}};\n   assign dec_tlu_force_halt_bus[pt.NUM_THREADS-1:0] = 2'h0;\n\n   // PMU signals\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin: GenPMU\n      assign lsu_pmu_bus_trxn[i]       = ((lsu_axi_awvalid & lsu_axi_awready) | (lsu_axi_wvalid & lsu_axi_wready) | (lsu_axi_arvalid & lsu_axi_arready)) & (i == bus_tid);\n      assign lsu_pmu_bus_misaligned[i] = lsu_busreq_dc5 & ldst_dual_dc5 & lsu_commit_dc5 & (i == lsu_pkt_dc5.tid);\n      assign lsu_pmu_bus_error[i]      = lsu_imprecise_error_load_any[i] | lsu_imprecise_error_store_any[i];\n      assign lsu_pmu_bus_busy[i]       = ((lsu_axi_awvalid & ~lsu_axi_awready) | (lsu_axi_wvalid & ~lsu_axi_wready) | (lsu_axi_arvalid & ~lsu_axi_arready)) & (i == bus_tid);\n   end\n\n   rvdff_fpga #(.WIDTH(1))               lsu_axi_awvalid_ff (.din(lsu_axi_awvalid),                .dout(lsu_axi_awvalid_q),                .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))               lsu_axi_awready_ff (.din(lsu_axi_awready),                .dout(lsu_axi_awready_q),                .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))               lsu_axi_wvalid_ff  (.din(lsu_axi_wvalid),                 .dout(lsu_axi_wvalid_q),                 .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))               lsu_axi_wready_ff  (.din(lsu_axi_wready),                 .dout(lsu_axi_wready_q),                 .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))               lsu_axi_arvalid_ff (.din(lsu_axi_arvalid),                .dout(lsu_axi_arvalid_q),                .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga #(.WIDTH(1))               lsu_axi_arready_ff (.din(lsu_axi_arready),                .dout(lsu_axi_arready_q),                .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n\n   rvdff_fpga  #(.WIDTH(1))              lsu_axi_bvalid_ff  (.din(lsu_axi_bvalid),                 .dout(lsu_axi_bvalid_q),                 .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(1))              lsu_axi_bready_ff  (.din(lsu_axi_bready),                 .dout(lsu_axi_bready_q),                 .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(2))              lsu_axi_bresp_ff   (.din(lsu_axi_bresp[1:0]),             .dout(lsu_axi_bresp_q[1:0]),             .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(pt.LSU_BUS_TAG)) lsu_axi_bid_ff     (.din(lsu_axi_bid[pt.LSU_BUS_TAG-1:0]),.dout(lsu_axi_bid_q[pt.LSU_BUS_TAG-1:0]),.clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdffe      #(.WIDTH(64))             lsu_axi_rdata_ff   (.din(lsu_axi_rdata[63:0]),            .dout(lsu_axi_rdata_q[63:0]),            .en((lsu_axi_rvalid | clk_override) & lsu_bus_clk_en), .*);\n\n   rvdff_fpga  #(.WIDTH(1))              lsu_axi_rvalid_ff  (.din(lsu_axi_rvalid),                 .dout(lsu_axi_rvalid_q),                 .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(1))              lsu_axi_rready_ff  (.din(lsu_axi_rready),                 .dout(lsu_axi_rready_q),                 .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(2))              lsu_axi_rresp_ff   (.din(lsu_axi_rresp[1:0]),             .dout(lsu_axi_rresp_q[1:0]),             .clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n   rvdff_fpga  #(.WIDTH(pt.LSU_BUS_TAG)) lsu_axi_rid_ff     (.din(lsu_axi_rid[pt.LSU_BUS_TAG-1:0]),.dout(lsu_axi_rid_q[pt.LSU_BUS_TAG-1:0]),.clk(lsu_busm_clk), .clken(lsu_busm_clken), .rawclk(clk), .*);\n\n   // Per thread bus buffer\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin: GenThreadLoop\n      // Read/Write Buffer\n      eh2_lsu_bus_buffer #(.pt(pt)) bus_buffer (\n         .tid(1'(i)),\n         .clk(active_thread_l2clk[i]),\n         .lsu_bus_obuf_c1_clken(lsu_bus_obuf_c1_clken[i]),\n         .lsu_bus_ibuf_c1_clk(lsu_bus_ibuf_c1_clk[i]),\n         .lsu_bus_buf_c1_clk(lsu_bus_buf_c1_clk[i]),\n         .lsu_bus_obuf_c1_clk(lsu_bus_obuf_c1_clk[i]),\n         .dec_tlu_force_halt(dec_tlu_force_halt[i]),\n         .lsu_bus_cntr_overflow(lsu_bus_cntr_overflow[i]),\n         .lsu_bus_idle_any(lsu_bus_idle_any[i]),\n\n         .bus_addr_match_pending(bus_addr_match_pending[i]),\n         .lsu_bus_buffer_pend_any(lsu_bus_buffer_pend_any[i]),\n         .lsu_bus_buffer_full_any(lsu_bus_buffer_full_any[i]),\n         .lsu_bus_buffer_empty_any(lsu_bus_buffer_empty_any[i]),\n\n         .ld_byte_hit_buf_lo(ld_byte_hit_buf_lo[i]),\n         .ld_byte_hit_buf_hi(ld_byte_hit_buf_hi[i]),\n         .ld_fwddata_buf_lo(ld_fwddata_buf_lo[i]),\n         .ld_fwddata_buf_hi(ld_fwddata_buf_hi[i]),\n\n         .lsu_imprecise_error_load_any(lsu_imprecise_error_load_any[i]),\n         .lsu_imprecise_error_store_any(lsu_imprecise_error_store_any[i]),\n         .lsu_imprecise_error_addr_any(lsu_imprecise_error_addr_any[i]),\n\n         .WrPtr0_dc1(WrPtr0_dc1[i]),\n         .WrPtr0_dc2(WrPtr0_dc2[i]),\n         .WrPtr0_dc5(WrPtr0_dc5[i]),\n\n         .obuf_valid(obuf_valid[i]),\n         .obuf_nosend(obuf_nosend[i]),\n         .obuf_write(obuf_write[i]),\n         .obuf_sideeffect(obuf_sideeffect[i]),\n         .obuf_addr(obuf_addr[i]),\n         .obuf_data(obuf_data[i]),\n         .obuf_sz(obuf_sz[i]),\n         .obuf_byteen(obuf_byteen[i]),\n         .obuf_cmd_done(obuf_cmd_done[i]),\n         .obuf_data_done(obuf_data_done[i]),\n         .obuf_tag0(obuf_tag0[i]),\n         .obuf_nxtready(obuf_nxtready[i]),\n\n         .lsu_nonblock_load_data_ready(tid_nonblock_load_data_ready[i]),\n         .lsu_nonblock_load_data_valid(tid_nonblock_load_data_valid[i]),\n         .lsu_nonblock_load_data_error(tid_nonblock_load_data_error[i]),\n         .lsu_nonblock_load_data_tag(tid_nonblock_load_data_tag[i]),\n         .lsu_nonblock_load_data(tid_nonblock_load_data[i]),\n\n         .*\n      );\n   end\n\n   always_comb begin\n      lsu_nonblock_load_data_valid = '0;\n      lsu_nonblock_load_data_error = '0;\n      lsu_nonblock_load_data_tag   = '0;\n      lsu_nonblock_load_data       = '0;\n      for (int i=0; i<pt.NUM_THREADS; i++) begin\n         lsu_nonblock_load_data_valid |= (tid_nonblock_load_data_valid[i] & (lsu_nonblock_load_data_tid == i));\n         lsu_nonblock_load_data_error |= (tid_nonblock_load_data_error[i] & (lsu_nonblock_load_data_tid == i));\n         lsu_nonblock_load_data_tag   |= {(pt.LSU_NUM_NBLOAD_WIDTH){lsu_nonblock_load_data_tid == i}} & tid_nonblock_load_data_tag[i];\n         lsu_nonblock_load_data       |= {32{lsu_nonblock_load_data_tid == i}} & tid_nonblock_load_data[i];\n      end\n   end\n\n   // Thread arbitration logic for bus tid\n   if (pt.NUM_THREADS == 2) begin: GenMT\n      assign nxt_bus_tid = bus_tid ? (~(obuf_nxtrea"}
{"text": "dy[0] | obuf_valid[0]) & obuf_nxtready[1]) :\n                                     (~obuf_nxtready[0] | (obuf_nxtready[1] | obuf_valid[1]));\n      assign bus_tid_en  = bus_cmd_sent | (~bus_cmd_valid & (obuf_nxtready[0] | obuf_nxtready[1]) & ~obuf_nxtready[bus_tid]) | (~obuf_valid[bus_tid] & obuf_valid[~bus_tid]);\n      rvdffs_fpga #(.WIDTH(1)) bus_tidff (.din(nxt_bus_tid), .dout(bus_tid), .en(bus_tid_en), .clk(lsu_busm_clk), .clken(lsu_bus_clk_en & bus_tid_en), .rawclk(clk), .*);\n   end else begin: GenST\n      assign bus_tid = 1'b0;\n   end\n\n   // Thread arbitration logic for nonblock tid\n   if (pt.NUM_THREADS == 2) begin: GenNBTID_MT\n      rvarbiter2 nbtid_arbiter (\n         .clk(active_clk),\n         .ready(tid_nonblock_load_data_ready[1:0]),\n         .shift(lsu_nonblock_load_data_valid | lsu_nonblock_load_data_error),\n         .tid  (lsu_nonblock_load_data_tid),   //output\n         .*\n      );\n   end else begin: GenNBTID_ST\n      assign lsu_nonblock_load_data_tid = '0;\n   end\n\n   // Fifo flops\n   rvdffe #(.WIDTH(32)) lsu_fwddata_dc3ff (.din(ld_fwddata_dc2[31:0]), .dout(ld_fwddata_dc3[31:0]), .en((lsu_pkt_dc2.valid & lsu_pkt_dc2.load & lsu_busreq_dc2) | clk_override), .*);\n\n   rvdff #(.WIDTH(1)) clken_ff (.din(lsu_bus_clk_en), .dout(lsu_bus_clk_en_q), .clk(active_clk), .*);\n\n   rvdff #(.WIDTH(1)) is_sideeffects_dc4ff (.din(is_sideeffects_dc3), .dout(is_sideeffects_dc4), .clk(lsu_c1_dc4_clk), .*);\n   rvdff #(.WIDTH(1)) is_sideeffects_dc5ff (.din(is_sideeffects_dc4), .dout(is_sideeffects_dc5), .clk(lsu_c1_dc5_clk), .*);\n\n   rvdff #(4) lsu_byten_dc3ff (.*, .din(ldst_byteen_dc2[3:0]), .dout(ldst_byteen_dc3[3:0]), .clk(lsu_c1_dc3_clk));\n   rvdff #(4) lsu_byten_dc4ff (.*, .din(ldst_byteen_dc3[3:0]), .dout(ldst_byteen_dc4[3:0]), .clk(lsu_c1_dc4_clk));\n   rvdff #(4) lsu_byten_dc5ff (.*, .din(ldst_byteen_dc4[3:0]), .dout(ldst_byteen_dc5[3:0]), .clk(lsu_c1_dc5_clk));\n\n   rvdff #(.WIDTH(1)) lsu_busreq_dc2ff (.din(lsu_busreq_dc1), .dout(lsu_busreq_dc2), .clk(lsu_c2_dc2_clk), .*);  // Don't want dc2 to dc3 propagation during freeze. Maybe used freeze gate\n   rvdff #(.WIDTH(1)) lsu_busreq_dc3ff (.din(lsu_busreq_dc2 & ~ld_full_hit_dc2), .dout(lsu_busreq_dc3), .clk(lsu_c2_dc3_clk), .*);  // Don't want dc2 to dc3 propagation during freeze. Maybe used freeze gated clock\n   rvdff #(.WIDTH(1)) lsu_busreq_dc4ff (.din(lsu_busreq_dc3 & ~flush_dc3[lsu_pkt_dc3.tid]),      .dout(lsu_busreq_dc4), .clk(lsu_c2_dc4_clk), .*);\n   rvdff #(.WIDTH(1)) lsu_busreq_dc5ff (.din(lsu_busreq_dc4 & ~flush_dc4[lsu_pkt_dc4.tid]),      .dout(lsu_busreq_dc5), .clk(lsu_c2_dc5_clk), .*);\n\n   rvdff #(.WIDTH(1)) lsu_nonblock_load_valid_dc2ff  (.din(lsu_nonblock_load_valid_dc1),  .dout(lsu_nonblock_load_valid_dc2), .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(.WIDTH(1)) lsu_nonblock_load_valid_dc3ff  (.din(lsu_nonblock_load_valid_dc2),  .dout(lsu_nonblock_load_valid_dc3), .clk(lsu_c2_dc3_clk), .*);\n   rvdff #(.WIDTH(1)) lsu_nonblock_load_valid_dc4ff  (.din(lsu_nonblock_load_valid_dc3),  .dout(lsu_nonblock_load_valid_dc4), .clk(lsu_c2_dc4_clk), .*);\n   rvdff #(.WIDTH(1)) lsu_nonblock_load_valid_dc5ff  (.din(lsu_nonblock_load_valid_dc4),  .dout(lsu_nonblock_load_valid_dc5), .clk(lsu_c2_dc5_clk), .*);\n\n`ifdef RV_ASSERT_ON\n\n     // Assertion to check AXI write address is aligned to size\n     property lsu_axi_awaddr_aligned;\n       @(posedge lsu_busm_clk) disable iff(~rst_l) lsu_axi_awvalid |-> ((lsu_axi_awsize[2:0] == 3'h0)                                   |\n                                                                        ((lsu_axi_awsize[2:0] == 3'h1) & (lsu_axi_awaddr[0] == 1'b0))   |\n                                                                        ((lsu_axi_awsize[2:0] == 3'h2) & (lsu_axi_awaddr[1:0] == 2'b0)) |\n                                                                        ((lsu_axi_awsize[2:0] == 3'h3) & (lsu_axi_awaddr[2:0] == 3'b0)));\n     endproperty\n     assert_lsu_axi_awaddr_aligned: assert property (lsu_axi_awaddr_aligned) else\n       $display(\"Assertion lsu_axi_awaddr_aligned failed: lsu_axi_awvalid=1'b%b, lsu_axi_awsize=3'h%h, lsu_axi_awaddr=32'h%h\",lsu_axi_awvalid, lsu_axi_awsize[2:0], lsu_axi_awaddr[31:0]);\n     // Assertion to check awvalid stays stable during entire bus clock\n\n     // Assertion to check AXI read address is aligned to size\n     property lsu_axi_araddr_aligned;\n       @(posedge lsu_busm_clk) disable iff(~rst_l) lsu_axi_awvalid |-> ((lsu_axi_arsize[2:0] == 3'h0)                                   |\n                                                                        ((lsu_axi_arsize[2:0] == 3'h1) & (lsu_axi_araddr[0] == 1'b0))   |\n                                                                        ((lsu_axi_arsize[2:0] == 3'h2) & (lsu_axi_araddr[1:0] == 2'b0)) |\n                                                                        ((lsu_axi_arsize[2:0] == 3'h3) & (lsu_axi_araddr[2:0] == 3'b0)));\n     endproperty\n     assert_lsu_axi_araddr_aligned: assert property (lsu_axi_araddr_aligned) else\n       $display(\"Assertion lsu_axi_araddr_aligned failed: lsu_axi_awvalid=1'b%b, lsu_axi_awsize=3'h%h, lsu_axi_araddr=32'h%h\",lsu_axi_awvalid, lsu_axi_awsize[2:0], lsu_axi_araddr[31:0]);\n\n     // Assertion to check awvalid stays stable during entire bus clock\n    property lsu_axi_awvalid_stable;\n        @(posedge clk) disable iff(~rst_l)  (lsu_axi_awvalid != $past(lsu_axi_awvalid)) |-> ($past(lsu_bus_clk_en) | (|dec_tlu_force_halt[pt.NUM_THREADS-1:0]));\n     endproperty\n     assert_lsu_axi_awvalid_stable: assert property (lsu_axi_awvalid_stable) else\n        $display(\"LSU AXI awvalid changed in middle of bus clock\");\n\n     // Assertion to check awid stays stable during entire bus clock\n     property lsu_axi_awid_stable;\n        @(posedge clk) disable iff(~rst_l)  (lsu_axi_awvalid & (lsu_axi_awid[pt.LSU_BUS_TAG-1:0] != $past(lsu_axi_awid[pt.LSU_BUS_TAG-1:0]))) |-> $past(lsu_bus_clk_en);\n     endproperty\n     assert_lsu_axi_awid_stable: assert property (lsu_axi_awid_stable) else\n        $display(\"LSU AXI awid changed in middle of bus clock\");\n\n     // Assertion to check awaddr stays stable during entire bus clock\n     property lsu_axi_awaddr_stable;\n        @(posedge clk) disable iff(~rst_l)  (lsu_axi_awvalid & (lsu_axi_awaddr[31:0] != $past(lsu_axi_awaddr[31:0]))) |-> $past(lsu_bus_clk_en);\n     endproperty\n     assert_lsu_axi_awaddr_stable: assert property (lsu_axi_awaddr_stable) else\n        $display(\"LSU AXI awaddr changed in middle of bus clock\");\n\n     // Assertion to check awsize stays stable during entire bus clock\n     property lsu_axi_awsize_stable;\n        @(posedge clk) disable iff(~rst_l)  (lsu_axi_awvalid & (lsu_axi_awsize[2:0] != $past(lsu_axi_awsize[2:0]))) |-> $past(lsu_bus_clk_en);\n     endproperty\n     assert_lsu_axi_awsize_stable: assert property (lsu_axi_awsize_stable) else\n        $display(\"LSU AXI awsize changed in middle of bus clock\");\n\n     // Assertion to check wstrb stays stable during entire bus clock\n     property lsu_axi_wstrb_stable;\n        @(posedge clk) disable iff(~rst_l)  (lsu_axi_wvalid & (lsu_axi_wstrb[7:0] != $past(lsu_axi_wstrb[7:0]))) |-> $past(lsu_bus_clk_en);\n     endproperty\n     assert_lsu_axi_wstrb_stable: assert property (lsu_axi_wstrb_stable) else\n        $display(\"LSU AXI wstrb changed in middle of bus clock\");\n\n     // Assertion to check wdata stays stable during entire bus clock\n     property lsu_axi_wdata_stable;\n        @(posedge clk) disable iff(~rst_l)  (lsu_axi_wvalid & (lsu_axi_wdata[63:0] != $past(lsu_axi_wdata[63:0]))) |-> $past(lsu_bus_clk_en);\n     endproperty\n     assert_lsu_axi_wdata_stable: assert property (lsu_axi_wdata_stable) else\n        $display(\"LSU AXI command wdata changed in middle of bus clock\");\n\n     // Assertion to check awvalid stays stable during entire bus clock\n     property lsu_axi_arvalid_stable;\n        @(posedge clk) disable iff(~rst_l)  (lsu_axi_arvalid != $past(lsu_axi_arvalid)) |-> ($past(lsu_bus_clk_en) | (|dec_tlu_force_halt[pt.NUM_THREADS-1:0]));\n     endproperty\n     assert_lsu_axi_arvalid_stable: assert property (lsu_axi_arvalid_stable) else\n        $display(\"LSU AXI awvalid changed in middle of bus clock\");\n\n     // Assertion to check awid stays stable during entire bus clock\n     property lsu_axi_arid_stable;\n        @(posedge clk) disable iff(~rst_l)  (lsu_axi_arvalid & (lsu_axi_arid[pt.LSU_BUS_TAG-1:0] != $past(lsu_axi_arid[pt.LSU_BUS_TAG-1:0]))) |-> $past(lsu_bus_clk_en);\n     endproperty\n     assert_lsu_axi_arid_stable: assert property (lsu_axi_arid_stable) else\n        $display(\"LSU AXI awid changed in middle of bus clock\");\n\n     // Assertion to check awaddr stays stable during entire bus clock\n     property lsu_axi_araddr_stable;\n        @(posedge clk) disable iff(~rst_l)  (lsu_axi_arvalid & (lsu_axi_araddr[31:0] != $past(lsu_axi_araddr[31:0]))) |-> $past(lsu_bus_clk_en);\n     endproperty\n     assert_lsu_axi_araddr_stable: assert property (lsu_axi_araddr_stable) else\n        $display(\"LSU AXI awaddr changed in middle of bus clock\");\n\n     // Assertion to check awsize stays stable during entire bus clock\n     property lsu_axi_arsize_stable;\n        @(posedge clk) disable iff(~rst_l)  (lsu_axi_arvalid & (lsu_axi_arsize[2:0] != $past(lsu_axi_arsize[2:0]))) |-> $past(lsu_bus_clk_en);\n     endproperty\n     assert_lsu_axi_arsize_stable: assert property (lsu_axi_arsize_stable) else\n        $display(\"LSU AXI awsize changed in middle of bus clock\");\n\n`endif\n\nendmodule // lsu_bus_intf\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: Clock Generation Block\n// Comments: All the clocks are generate here\n//\n// //********************************************************************************\n\n\nmodule eh2_lsu_clkdomain\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)(\n   input logic      clk,                               // clock\n   input logic      active_clk,                        // clock\n   input logic [pt.NUM_THREADS-1:0]  active_thread_l2clk,  // per thread l2 clock\n   input logic      rst_l,                             // reset\n\n   // Inputs\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_force_halt,\n   input logic      clk_override,                      // chciken bit to turn off clock gating\n   input logic      addr_in_dccm_dc2,                  // address in dccm\n   input logic      addr_in_pic_dc2,                   // address is in pic\n   input logic      dma_dccm_req,                      // dma is active\n   input logic      dma_mem_write,                     // dma write is active\n   input logic      store_stbuf_reqvld_dc5,            // allocating in to the store queue\n   input logic [pt.NUM_THREADS-1:0]lr_vld,             // needed for clk gating\n\n\n   input logic      stbuf_reqvld_any,                  // stbuf is draining\n   input logic      stbuf_reqvld_flushed_any,          // stbuf is flushed\n   input logic      lsu_busreq_dc5,                    // busreq in dc5\n   input logic [pt.NUM_THREADS-1:0] lsu_bus_idle_any,\n   input logic [pt.NUM_THREADS-1:0] lsu_bus_buffer_pend_any,           // bus buffer has a pending bus entry\n   input logic [pt.NUM_THREADS-1:0] lsu_bus_buffer_empty_any,          // external bus buffer is empty\n   input logic [pt.NUM_THREADS-1:0] lsu_stbuf_empty_any,               // stbuf is empty\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_force_halt_bus,           // Bus synchronized version of force halt\n\n   input logic      lsu_bus_clk_en,               // bus clock enable\n\n   input eh2_lsu_pkt_t  lsu_p,                             // lsu packet in decode\n   input eh2_lsu_pkt_t  lsu_pkt_dc1,                       // lsu packet in dc1\n   input eh2_lsu_pkt_t  lsu_pkt_dc2,                       // lsu packet in dc2\n   input eh2_lsu_pkt_t  lsu_pkt_dc3,                       // lsu packet in dc3\n   input eh2_lsu_pkt_t  lsu_pkt_dc4,                       // lsu packet in dc4\n   input eh2_lsu_pkt_t  lsu_pkt_dc5,                       // lsu packet in dc5\n\n   // Outputs\n   output logic [pt.NUM_THREADS-1:0] lsu_bus_obuf_c1_clken,\n   output logic     lsu_busm_clken,\n\n   output logic     lsu_c1_dc1_clk,                    // dc3 pipe single pulse clock\n   output logic     lsu_c1_dc2_clk,                    // dc3 pipe single pulse clock\n   output logic     lsu_c1_dc3_clk,                    // dc3 pipe single pulse clock\n   output logic     lsu_c1_dc4_clk,                    // dc4 pipe single pulse clock\n   output logic     lsu_c1_dc5_clk,                    // dc5 pipe single pulse clock\n\n   output logic     lsu_c2_dc1_clk,                    // dc3 pipe double pulse clock\n   output logic     lsu_c2_dc2_clk,                    // dc3 pipe double pulse clock\n   output logic     lsu_c2_dc3_clk,                    // dc3 pipe double pulse clock\n   output logic     lsu_c2_dc4_clk,                    // dc4 pipe double pulse clock\n   output logic     lsu_c2_dc5_clk,                    // dc5 pipe double pulse clock\n\n  output logic      lsu_c1_dc1_clken,       // clock\n  output logic      lsu_c1_dc2_clken,       // clock\n  output logic      lsu_c1_dc3_clken,\n  output logic      lsu_c1_dc4_clken,\n  output logic      lsu_c1_dc5_clken,\n\n   output logic     lsu_store_c1_dc1_clk,              // store in dc1\n   output logic     lsu_store_c1_dc2_clk,              // store in dc2\n   output logic     lsu_store_c1_dc3_clk,              // store in dc3\n\n\n   output logic     lsu_dccm_c1_dc3_clk,               // dccm clock\n   output logic     lsu_pic_c1_dc3_clk,                // pic clock\n\n   output logic     lsu_stbuf_c1_clk,\n   output logic [pt.NUM_THREADS-1:0]  lsu_bus_obuf_c1_clk,               // ibuf clock\n   output logic [pt.NUM_THREADS-1:0]  lsu_bus_ibuf_c1_clk,               // ibuf clock\n   output logic [pt.NUM_THREADS-1:0]  lsu_bus_buf_c1_clk,                // ibuf clock\n   output logic     lsu_busm_clk,                      // bus clock\n\n   output logic     lsu_free_c2_clk,\n\n   input  logic     scan_mode\n);\n\n   logic lsu_c2_dc1_clken,       lsu_c2_dc2_clken,       lsu_c2_dc3_clken,       lsu_c2_dc4_clken,       lsu_c2_dc5_clken;\n   logic lsu_c1_dc1_clken_q,     lsu_c1_dc2_clken_q,     lsu_c1_dc3_clken_q,     lsu_c1_dc4_clken_q,     lsu_c1_dc5_clken_q;\n   logic lsu_store_c1_dc1_clken, lsu_store_c1_dc2_clken, lsu_store_c1_dc3_clken;\n\n   logic lsu_stbuf_c1_clken;\n   logic [pt.NUM_THREADS-1:0] lsu_bus_ibuf_c1_clken, lsu_bus_buf_c1_clken;\n\n   logic lsu_dccm_c1_dc3_clken, lsu_pic_c1_dc3_clken;\n\n   logic lsu_free_c1_clken, lsu_free_c1_clken_q, lsu_free_c2_clken;\n\n   //-------------------------------------------------------------------------------------------\n   // Clock Enable logic\n   //-------------------------------------------------------------------------------------------\n\n   // Also use the flopped clock enable. We want to turn on the clocks from dc1->dc5 even if there is a freeze\n   assign lsu_c1_dc1_clken = lsu_p.valid | clk_override;\n   assign lsu_c1_dc2_clken = lsu_pkt_dc1.valid | dma_dccm_req | lsu_c1_dc1_clken_q | clk_override;\n   assign lsu_c1_dc3_clken = lsu_pkt_dc2.valid | lsu_c1_dc2_clken_q | clk_override;\n   assign lsu_c1_dc4_clken = lsu_pkt_dc3.valid | lsu_c1_dc3_clken_q | clk_override;\n   assign lsu_c1_dc5_clken = lsu_pkt_dc4.valid | lsu_c1_dc4_clken_q | clk_override;\n\n   assign lsu_c2_dc1_clken = lsu_c1_dc1_clken | lsu_c1_dc1_clken_q | clk_override;\n   assign lsu_c2_dc2_clken = lsu_c1_dc2_clken | lsu_c1_dc2_clken_q | clk_override;\n   assign lsu_c2_dc3_clken = lsu_c1_dc3_clken | lsu_c1_dc3_clken_q | clk_override;\n   assign lsu_c2_dc4_clken = lsu_c1_dc4_clken | lsu_c1_dc4_clken_q | clk_override;\n   assign lsu_c2_dc5_clken = lsu_c1_dc5_clken | lsu_c1_dc5_clken_q | clk_override;\n\n   assign lsu_store_c1_dc1_clken = ((lsu_c1_dc1_clken & (lsu_p.store | lsu_p.atomic )) | clk_override);\n   assign lsu_store_c1_dc2_clken = ((lsu_c1_dc2_clken & (lsu_pkt_dc1.store | dma_mem_write | lsu_pkt_dc1.atomic)) | clk_override);\n   assign lsu_store_c1_dc3_clken = ((lsu_c1_dc3_clken & (lsu_pkt_dc2.store | lsu_pkt_dc2.atomic)) | clk_override);\n\n\n   assign lsu_stbuf_c1_clken = store_stbuf_reqvld_dc5 | stbuf_reqvld_any | stbuf_reqvld_flushed_any | clk_override;\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin: GenBufClkEn\n      assign lsu_bus_ibuf_c1_clken[i] = (lsu_busreq_dc5 & (lsu_pkt_dc5.tid == i)) | clk_override;\n      assign lsu_bus_obuf_c1_clken[i] = (lsu_bus_buffer_pend_any[i] | (lsu_busreq_dc5 & (lsu_pkt_dc5.tid == i)) | clk_override) & lsu_bus_clk_en;\n      assign lsu_bus_buf_c1_clken[i]  = ~lsu_bus_buffer_empty_any[i] | (lsu_busreq_dc5 & (lsu_pkt_dc5.tid == i)) | dec_tlu_force_halt | clk_override;\n\n      rvoclkhdr lsu_bus_ibuf_c1_cgc ( .en(lsu_bus_ibuf_c1_clken[i]), .l1clk(lsu_bus_ibuf_c1_clk[i]), .clk(active_thread_l2clk[i]), .* );\n      rvoclkhdr lsu_bus_buf_c1_cgc  ( .en(lsu_bus_buf_c1_clken[i]),  .l1clk(lsu_bus_buf_c1_clk[i]), .clk(active_thread_l2clk[i]), .* );\n`ifdef RV_FPGA_OPTIMIZE\n      assign lsu_bus_obuf_c1_clk[i] = 1'b0;\n`else\n      rvclkhdr  lsu_bus_obuf_c1_cgc ( .en(lsu_bus_obuf_c1_clken[i]), .l1clk(lsu_bus_obuf_c1_clk[i]), .clk(active_thread_l2clk[i]), .* );\n`endif\n   end\n\n   assign lsu_dccm_c1_dc3_clken = ((lsu_c1_dc3_clken & addr_in_dccm_dc2) | clk_override);\n   assign lsu_pic_c1_dc3_clken  = ((lsu_c1_dc3_clken & addr_in_pic_dc2) | clk_override);\n\n   assign lsu_free_c1_clken =  lsu_p.valid | lsu_pkt_dc1.valid | lsu_pkt_dc2.valid | lsu_pkt_dc3.valid | lsu_pkt_dc4.valid | lsu_pkt_dc5.valid | (|lr_vld[pt.NUM_THREADS-1:0]) |\n                              ~(&lsu_bus_buffer_empty_any[pt.NUM_THREADS-1:0]) | ~(&lsu_stbuf_empty_any[pt.NUM_THREADS-1:0]) | clk_override;\n   assign lsu_free_c2_clken = lsu_free_c1_clken | lsu_free_c1_clken_q | clk_override;\n\n    // Flops\n   rvdff #(1) lsu_free_c1_clkenff (.din(lsu_free_c1_clken), .dout(lsu_free_c1_clken_q), .clk(active_clk), .*);\n\n   rvdff #(1) lsu_c1_dc1_clkenff (.din(lsu_c1_dc1_clken), .dout(lsu_c1_dc1_clken_q), .clk(active_clk), .*);\n   rvdff #(1) lsu_c1_dc2_clkenff (.din(lsu_c1_dc2_clken), .dout(lsu_c1_dc2_clken_q), .clk(active_clk), .*);\n   rvdff #(1) lsu_c1_dc3_clkenff (.din(lsu_c1_dc3_clken), .dout(lsu_c1_dc3_clken_q), .clk(active_clk), .*);\n   rvdff #(1) lsu_c1_dc4_clkenff (.din(lsu_c1_dc4_clken), .dout(lsu_c1_dc4_clken_q), .clk(active_clk), .*);\n   rvdff #(1) lsu_c1_dc5_clkenff (.din(lsu_c1_dc5_clken), .dout(lsu_c1_dc5_clken_q), .clk(active_clk), .*);\n\n   // Clock Headers\n   rvoclkhdr lsu_c1dc1_cgc ( .en(lsu_c1_dc1_clken), .l1clk(lsu_c1_dc1_clk), .* );\n   rvoclkhdr lsu_c1dc2_cgc ( .en(lsu_c1_dc2_clken), .l1clk(lsu_c1_dc2_clk), .* );\n   rvoclkhdr lsu_c1dc3_cgc ( .en(lsu_c1_dc3_clken), .l1clk(lsu_c1_dc3_clk), .* );\n   rvoclkhdr lsu_c1dc4_cgc ( .en(lsu_c1_dc4_clken), .l1clk(lsu_c1_dc4_clk), .* );\n   rvoclkhdr lsu_c1dc5_cgc ( .en(lsu_c1_dc5_clken), .l1clk(lsu_c1_dc5_clk), .* );\n\n   rvoclkhdr lsu_c2dc1_cgc ( .en(lsu_c2_dc1_clken), .l1clk(lsu_c2_dc1_clk), .* );\n   rvoclkhdr lsu_c2dc2_cgc ( .en(lsu_c2_dc2_clken), .l1clk(lsu_c2_dc2_clk), .* );\n   rvoclkhdr lsu_c2dc3_cgc ( .en(lsu_c2_dc3_clken), .l1clk(lsu_c2_dc3_clk), .* );\n   rvoclkhdr lsu_c2dc4_cgc ( .en(lsu_c2_dc4_clken), .l1clk(lsu_c2_dc4_clk), .* );\n   rvoclkhdr lsu_c2dc5_cgc ( .en(lsu_c2_dc5_clken), .l1clk(lsu_c2_dc5_clk), .* );\n\n   rvoclkhdr lsu_store_c1dc1_cgc (.en(lsu_store_c1_dc1_clken), .l1clk(lsu_store_c1_dc1_clk), .*);\n   rvoclkhdr lsu_store_c1dc2_cgc (.en(lsu_store_c1_dc2_clken), .l1clk(lsu_store_c1_dc2_clk), .*);\n   rvoclkhdr lsu_store_c1dc3_cgc (.en(lsu_store_c1_dc3_clken), .l1clk(lsu_store_c1_dc3_clk), .*);\n\n   rvoclkhdr lsu_stbuf_c1_cgc ( .en(lsu_stbuf_c1_clken), .l1clk(lsu_stbuf_c1_clk), .* );\n\n   assign lsu_busm_clken = (~(&lsu_bus_buffer_empty_any[pt.NUM_THREADS-1:0]) | ~(&lsu_bus_idle_any[pt.NUM_THREADS-1:0]) | (|dec_tlu_force_halt_bus[pt.NUM_THREADS-1:0]) | lsu_busreq_dc5 | clk_override) & lsu_bus_clk_en;\n\n`ifdef RV_FPGA_OPTIMIZE\n   assign lsu_busm_clk = 1'b0;\n`else\n   rvclkhdr lsu_busm_cgc (.en(lsu_busm_clken), .l1clk(lsu_busm_clk), .*);\n`endif\n   rvoclkhdr lsu_dccm_c1dc3_cgc (.en(lsu_dccm_c1_dc3_clken), .l1clk(lsu_dccm_c1_dc3_clk), .*);\n   rvoclkhdr lsu_pic_c1dc3_cgc (.en(lsu_pic_c1_dc3_clken), .l1clk(lsu_pic_c1_dc3_clk), .*);\n\n   rvoclkhdr lsu_free_cgc (.en(lsu_free_c2_clken), .l1clk(lsu_free_c2_clk), .*);\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: DCCM for LSU pipe\n// Comments: Single ported memory\n//\n//\n// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n//\n// //********************************************************************************\n\nmodule eh2_lsu_dccm_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n  (\n\n   input logic                             clk,\n   input logic                             clk_override,        // Disable clock gating\n   input logic                             lsu_free_c2_clk,\n   input logic                             lsu_dccm_c1_dc3_clk,\n   input logic                             lsu_c2_dc2_clk,\n   input logic                             lsu_c2_dc3_clk,\n   input logic                             lsu_pic_c1_dc3_clk,\n\n   input logic                             rst_l,\n\n   input                                   eh2_lsu_pkt_t lsu_pkt_dc5,     // lsu packets\n   input                                   eh2_lsu_pkt_t lsu_pkt_dc4,     // lsu packets\n   input                                   eh2_lsu_pkt_t lsu_pkt_dc3,     // lsu packets\n   input                                   eh2_lsu_pkt_t lsu_pkt_dc2,     // lsu packets\n   input                                   eh2_lsu_pkt_t lsu_pkt_dc1,\n   input                                   eh2_lsu_pkt_t lsu_pkt_dc1_pre,\n   input logic                             addr_in_dccm_region_dc1,     // address in dccm region\n   input logic                             addr_in_dccm_dc1,          // address maps to dccm\n   input logic                             addr_in_pic_dc1,           // address maps to pic\n   input logic                             addr_in_pic_dc3,           // address maps to pic\n   input logic                             addr_in_dccm_dc2, addr_in_dccm_dc3, addr_in_dccm_dc4, addr_in_dccm_dc5,\n   input logic                             addr_in_pic_dc5,\n   input logic                             lsu_raw_fwd_lo_dc5, lsu_raw_fwd_hi_dc5,\n   input logic                             ldst_dual_dc2, ldst_dual_dc3, ldst_dual_dc4,\n\n   input logic                             dma_pic_wen,\n   input logic                             dma_dccm_wen,\n   input logic                             dma_dccm_spec_wen,\n   input logic                             dma_dccm_spec_req,\n   input logic                             dma_mem_write,\n   input logic [2:0]                       dma_mem_sz,\n   input logic [31:0]                      dma_mem_addr,\n   input logic [63:0]                      dma_mem_wdata,\n   input logic [2:0]                       dma_mem_tag_dc3,\n\n   input logic [31:0]                      lsu_addr_dc1,              // starting byte address for loads\n   input logic [31:0]                      lsu_addr_dc2,              // starting byte address for loads\n   input logic [31:0]                      lsu_addr_dc3,              // starting byte address for loads\n   input logic [31:0]                      lsu_addr_dc4,              // starting byte address for loads\n   input logic [31:0]                      lsu_addr_dc5,              // starting byte address for loads\n\n   input logic [31:0]                      end_addr_dc1,\n   input logic [31:0]                      end_addr_dc2,\n   input logic [31:0]                      end_addr_dc3,\n   input logic [31:0]                      end_addr_dc4,\n   input logic [31:0]                      end_addr_dc5,\n\n   input logic                             stbuf_reqvld_any,          // write enable\n   input logic [pt.LSU_SB_BITS-1:0]        stbuf_addr_any,            // stbuf address (aligned)\n\n   input logic [pt.DCCM_DATA_WIDTH-1:0]   stbuf_data_any,            // the read out from stbuf\n   input logic [pt.DCCM_DATA_WIDTH-1:0]   stbuf_fwddata_hi_dc3,      // stbuf fowarding to load\n   input logic [pt.DCCM_DATA_WIDTH-1:0]   stbuf_fwddata_lo_dc3,      // stbuf fowarding to load\n   input logic [pt.DCCM_BYTE_WIDTH-1:0]   stbuf_fwdbyteen_hi_dc3,    // stbuf fowarding to load\n   input logic [pt.DCCM_BYTE_WIDTH-1:0]   stbuf_fwdbyteen_lo_dc3,    // stbuf fowarding to load\n   input logic                            picm_fwd_en_dc2,\n   input logic [31:0]                     picm_fwd_data_dc2,\n\n   input logic                            lsu_commit_dc5,\n   input logic                            lsu_sc_success_dc5,        // the store condition result\n   input logic                            lsu_double_ecc_error_dc3,  // lsu has a DED\n   input logic                            lsu_double_ecc_error_dc5,  // lsu has a DED\n   input logic                            single_ecc_error_hi_dc3,   // Single bit ECC error on hi data\n   input logic                            single_ecc_error_lo_dc3,   // Single bit ECC error on lo data\n   input logic                            single_ecc_error_hi_dc4,   // Single bit ECC error on hi data\n   input logic                            single_ecc_error_lo_dc4,   // Single bit ECC error on lo data\n   input logic                            single_ecc_error_hi_dc5,   // Single bit ECC error on hi data\n   input logic                            single_ecc_error_lo_dc5,   // Single bit ECC error on lo data\n   input logic [pt.DCCM_DATA_WIDTH-1:0]   sec_data_hi_dc3,\n   input logic [pt.DCCM_DATA_WIDTH-1:0]   sec_data_lo_dc3,\n\n   input logic [pt.DCCM_DATA_WIDTH-1:0]   store_ecc_data_hi_dc3,   // store data\n   input logic [pt.DCCM_DATA_WIDTH-1:0]   store_ecc_data_lo_dc3,   // store data\n   input logic [31:0]                     amo_data_dc3,\n   output logic [pt.DCCM_DATA_WIDTH-1:0]  dccm_data_hi_dc3,          // data from the dccm\n   output logic [pt.DCCM_DATA_WIDTH-1:0]  dccm_data_lo_dc3,          // data from the dccm\n   output logic [pt.DCCM_DATA_WIDTH-1:0]  dccm_datafn_hi_dc5,        // data from the dccm\n   output logic [pt.DCCM_DATA_WIDTH-1:0]  dccm_datafn_lo_dc5,        // data from the dccm\n   output logic [pt.DCCM_ECC_WIDTH-1:0]   dccm_data_ecc_hi_dc3,      // data from the dccm + ecc\n   output logic [pt.DCCM_ECC_WIDTH-1:0]   dccm_data_ecc_lo_dc3,\n   output logic [63:0]                    store_data_ext_dc3, store_data_ext_dc4, store_data_ext_dc5,   // goes to the stbuf/busbuf for load-store fwdding\n   output logic                           disable_ecc_check_lo_dc3,\n   output logic                           disable_ecc_check_hi_dc3,\n   output logic                           ld_single_ecc_error_dc3,\n   output logic                           ld_single_ecc_error_dc5,\n   output logic                           ld_single_ecc_error_dc5_ff,\n   output logic                           ld_single_ecc_error_lo_dc5_ff,\n   output logic                           ld_single_ecc_error_hi_dc5_ff,\n\n   output logic [pt.DCCM_DATA_WIDTH-1:0]  sec_data_hi_dc5,          // load single error corrected hi data\n   output logic [pt.DCCM_DATA_WIDTH-1:0]  sec_data_lo_dc5,          // load single error corrected lo data\n\n   output logic [pt.DCCM_DATA_WIDTH-1:0]  lsu_dccm_data_dc3,        // right justified, ie load byte will have data at 7:0\n   output logic [pt.DCCM_DATA_WIDTH-1:0]  lsu_dccm_data_corr_dc3,   // right justified, ie load byte will have data at 7:0\n   output logic [31:0]                    picm_mask_data_dc3,        // pic data to stbuf\n   output logic [31:0]                    picm_rd_data_dc3,          // pic read data in dc3\n   output logic                           lsu_stbuf_commit_any,      // stbuf wins the dccm port or is to pic\n   output logic                           lsu_dccm_rden_dc3,         // dccm read\n\n   output logic                           dccm_dma_rvalid,           // dccm serviving the dma load\n   output logic                           dccm_dma_ecc_error,        // DMA load had ecc error\n   output logic [2:0]                     dccm_dma_rtag,             // DCCM return tag\n   output logic [63:0]                    dccm_dma_rdata,            // dccm data to dma request\n\n   // DCCM ports\n   output logic                           dccm_wren,                // dccm interface -- write\n   output logic                           dccm_rden,                // dccm interface -- write\n   output logic [pt.DCCM_BITS-1:0]        dccm_wr_addr_lo,          // dccm interface -- wr addr for lo bankd\n   output logic [pt.DCCM_BITS-1:0]        dccm_wr_addr_hi,          // dccm interface -- wr addr for hi bankd\n   output logic [pt.DCCM_BITS-1:0]        dccm_rd_addr_lo,          // dccm interface -- read address for lo bank\n   output logic [pt.DCCM_BITS-1:0]        dccm_rd_addr_hi,          // dccm interface -- read address for hi bank\n\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_lo,          // dccm read data back from the dccm\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_hi,          // dccm read data back from the dccm\n\n   // PIC ports\n   output logic                            picm_wren_notdma,          // write to pic\n   output logic                            picm_wren,          // write to pic\n   output logic                            picm_rden,          // read to pick\n   output logic                            picm_mken,          // write to pic need a mask\n   output logic                            picm_rd_thr,        // PICM read thread\n   output logic [31:0]                     picm_rdaddr,        // address for pic access - shared between reads and write\n   output logic [31:0]                     picm_wraddr,        // address for pic access - shared between reads and write\n   output logic [31:0]                     picm_wr_data,       // write data\n   input logic [31:0]                      picm_rd_data,       // read data\n\n   input logic                             scan_mode           // scan mode\n);\n\n   localparam DCCM_WIDTH_BITS = $clog2(pt.DCCM_BYTE_WIDTH);\n\n   logic                        lsu_dccm_rden_dc1, lsu_dccm_rden_dc2, disable_ecc_check_lo_dc2, disable_ecc_check_hi_dc2;\n   logic                        lsu_dccm_wren_dc1, lsu_dccm_wren_spec_dc1;\n   logic [pt.DCCM_DATA_WIDTH-1:0]  store_data_hi_dc4, store_data_lo_dc4, dccm_data_lo_dc4_in, dccm_data_hi_dc4_in, dccm_data_lo_dc5_in, dccm_data_hi_dc5_in, store_data_lo_dc5, store_data_hi_dc5;\n   logic [63:0]  dccm_dout_dc3, dccm_corr_dout_dc3;\n   logic [63:0]  stbuf_fwddata_dc3;\n   logic [7:0]   stbuf_fwdbyteen_dc3;\n   logic [63:0]  lsu_rdata_dc3, lsu_rdata_corr_dc3;\n   logic [31:0]  picm_rd_data_dc2;\n   logic [31:0]  picm_rd_dataQ;\n   logic [63:32] lsu_dccm_data_dc3_nc, lsu_dccm_data_corr_dc3_nc;\n\n   logic         dccm_wr_bypass_c1_c2_hi, dccm_wr_bypass_c1_c3_hi, dccm_wr_bypass_c1_c4_hi, dccm_wr_bypass_c1_c5_hi;\n   logic         dccm_wr_bypass_c1_c2_lo, dccm_wr_bypass_c1_c3_lo, dccm_wr_bypass_c1_c4_lo, dccm_wr_bypass_c1_c5_lo;\n   logic         ld_single_ecc_error_lo_dc5, ld_single_ecc_error_hi_dc5;\n   logic         ld_single_ecc_error_lo_dc5_ns, ld_single_ecc_error_hi_dc5_ns;\n   logic         ld_single_ecc_error_dc4;\n   logic         lsu_double_ecc_error_dc5_ff;\n   logic         lsu_stbuf_ecc_block;\n   logic [pt.DCCM_BITS-1:0] ld_sec_addr_lo_dc5_ff, ld_sec_addr_hi_dc5_ff;\n\n   logic [7:0]   ldst_byteen_dc2, ldst_byteen_dc3, ldst_byteen_dc4, ldst_byteen_dc5;\n   logic [7:0]   ldst_byteen_ext_dc2, ldst_byteen_ext_dc3, ldst_byteen_ext_dc4, ldst_byteen_ext_dc5;\n   logic [31:0]  store_data_hi_dc3, store_data_lo_dc3;\n\n   logic         dccm_data_lo_dc3_clken, dccm_data_hi_dc3_clken;\n   logic         dccm_data_lo_dc4_clken, dccm_data_hi_dc4_clken;\n   logic         dccm_data_lo_dc5_clken, dccm_data_hi_dc5_clken;\n\n   logic         kill_ecc_corr_lo_dc5;\n   logic         kill_ecc_corr_hi_dc5;\n\n   //------------------------------------------------------------------------------------------------------------\n   //----------------------------------------Logic starts here---------------------------------------------------\n   //------------------------------------------------------------------------------------------------------------\n\n   assign dccm_dma_rvalid      = lsu_pkt_dc3.valid & lsu_pkt_dc3.load & lsu_pkt_dc3.dma;\n   assign dccm_dma_ecc_error   = lsu_double_ecc_error_dc3;\n   assign dccm_dma_rtag[2:0]   = dma_mem_tag_dc3[2:0];\n   assign dccm_dma_rdata[63:0] = addr_in_pic_dc3 ? {2{picm_rd_data_dc3[31:0]}} : ldst_dual_dc3 ? lsu_rdata_corr_dc3[63:0] : {2{lsu_rdata_corr_dc3[31:0]}};\n\n   assign {lsu_dccm_data_dc3_nc[63:32], lsu_dccm_data_dc3[31:0]} = lsu_rdata_dc3[63:0] >> 8*lsu_addr_dc3[1:0];\n   assign {lsu_dccm_data_corr_dc3_nc[63:32], lsu_dccm_data_corr_dc3[31:0]} = lsu_rdata_corr_dc3[63:0] >> 8*lsu_addr_dc3[1:0];\n\n   assign dccm_dout_dc3[63:0]      = {dccm_data_hi_dc3[pt.DCCM_DATA_WIDTH-1:0], dccm_data_lo_dc3[pt.DCCM_DATA_WIDTH-1:0]};\n   assign dccm_corr_dout_dc3[63:0] = {sec_data_hi_dc3[pt.DCCM_DATA_WIDTH-1:0], sec_data_lo_dc3[pt.DCCM_DATA_WIDTH-1:0]};\n   assign stbuf_fwddata_dc3[63:0]  = {stbuf_fwddata_hi_dc3[pt.DCCM_DATA_WIDTH-1:0], stbuf_fwddata_lo_dc3[pt.DCCM_DATA_WIDTH-1:0]};\n   assign stbuf_fwdbyteen_dc3[7:0] = {stbuf_fwdbyteen_hi_dc3[pt.DCCM_BYTE_WIDTH-1:0], stbuf_fwdbyteen_lo_dc3[pt.DCCM_BYTE_WIDTH-1:0]};\n\n   for (genvar i=0; i<8; i++) begin: GenLoop\n      assign lsu_rdata_dc3[(8*i)+7:8*i] = stbuf_fwdbyteen_dc3[i] ? stbuf_fwddata_dc3[(8*i)+7:8*i] : dccm_dout_dc3[(8*i)+7:8*i];\n      assign lsu_rdata_corr_dc3[(8*i)+7:8*i] = stbuf_fwdbyteen_dc3[i] ? stbuf_fwddata_dc3[(8*i)+7:8*i] : dccm_corr_dout_dc3[(8*i)+7:8*i];\n   end\n\n   assign kill_ecc_corr_lo_dc5 = (((lsu_addr_dc1[pt.DCCM_BITS-1:2] == lsu_addr_dc5[pt.DCCM_BITS-1:2]) | (end_addr_dc1[pt.DCCM_BITS-1:2] == lsu_addr_dc5[pt.DCCM_BITS-1:2])) & lsu_pkt_dc1.valid & lsu_pkt_dc1.store & lsu_pkt_dc1.dma & addr_in_dccm_dc1) |\n                                 (((lsu_addr_dc2[pt.DCCM_BITS-1:2] == lsu_addr_dc5[pt.DCCM_BITS-1:2]) | (end_addr_dc2[pt.DCCM_BITS-1:2] == lsu_addr_dc5[pt.DCCM_BITS-1:2])) & lsu_pkt_dc2.valid & lsu_pkt_dc2.store & lsu_pkt_dc2.dma & addr_in_dccm_dc2) |\n                                 (((lsu_addr_dc3[pt.DCCM_BITS-1:2] == lsu_addr_dc5[pt.DCCM_BITS-1:2]) | (end_addr_dc3[pt.DCCM_BITS-1:2] == lsu_addr_dc5[pt.DCCM_BITS-1:2])) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store & lsu_pkt_dc3.dma & addr_in_dccm_dc3) |\n                                 (((lsu_addr_dc4[pt.DCCM_BITS-1:2] == lsu_addr_dc5[pt.DCCM_BITS-1:2]) | (end_addr_dc4[pt.DCCM_BITS-1:2] == lsu_addr_dc5[pt.DCCM_BITS-1:2])) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & lsu_pkt_dc4.dma & addr_in_dccm_dc4);\n\n   assign kill_ecc_corr_hi_dc5 = (((lsu_addr_dc1[pt.DCCM_BITS-1:2] == end_addr_dc5[pt.DCCM_BITS-1:2]) | (end_addr_dc1[pt.DCCM_BITS-1:2] == end_addr_dc5[pt.DCCM_BITS-1:2])) & lsu_pkt_dc1.valid & lsu_pkt_dc1.store & lsu_pkt_dc1.dma & addr_in_dccm_dc1) |\n                                 (((lsu_addr_dc2[pt.DCCM_BITS-1:2] == end_addr_dc5[pt.DCCM_BITS-1:2]) | (end_addr_dc2[pt.DCCM_BITS-1:2] == end_addr_dc5[pt.DCCM_BITS-1:2])) & lsu_pkt_dc2.valid & lsu_pkt_dc2.store & lsu_pkt_dc2.dma & addr_in_dccm_dc2) |\n                                 (((lsu_addr_dc3[pt.DCCM_BITS-1:2] == end_addr_dc5[pt.DCCM_BITS-1:2]) | (end_addr_dc3[pt.DCCM_BITS-1:2] == end_addr_dc5[pt.DCCM_BITS-1:2])) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store & lsu_pkt_dc3.dma & addr_in_dccm_dc3) |\n                                 (((lsu_addr_dc4[pt.DCCM_BITS-1:2] == end_addr_dc5[pt.DCCM_BITS-1:2]) | (end_addr_dc4[pt.DCCM_BITS-1:2] == end_addr_dc5[pt.DCCM_BITS-1:2])) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & lsu_pkt_dc4.dma & addr_in_dccm_dc4);\n\n   assign ld_single_ecc_error_lo_dc5 = (lsu_commit_dc5 | lsu_pkt_dc5.dma) & (lsu_pkt_dc5.load | lsu_pkt_dc5.lr) & single_ecc_error_lo_dc5 & ~lsu_raw_fwd_lo_dc5;\n   assign ld_single_ecc_error_hi_dc5 = (lsu_commit_dc5 | lsu_pkt_dc5.dma) & (lsu_pkt_dc5.load | lsu_pkt_dc5.lr) & single_ecc_error_hi_dc5 & ~lsu_raw_fwd_hi_dc5;\n   assign ld_single_ecc_error_dc3    = (lsu_pkt_dc3.load | lsu_pkt_dc3.lr) & (single_ecc_error_lo_dc3 | single_ecc_error_hi_dc3);  // This is for blocking fast interrupt at decode-1\n   assign ld_single_ecc_error_dc4    = (lsu_pkt_dc4.load | lsu_pkt_dc4.lr) & (single_ecc_error_lo_dc4 | single_ecc_error_hi_dc4);  // This is for blocking load/store/dma at decode\n   assign ld_single_ecc_error_dc5    = (ld_single_ecc_error_lo_dc5 | ld_single_ecc_error_hi_dc5) & ~lsu_double_ecc_error_dc5;    // This doesn't have kill_ecc due to spyglass\n   assign ld_single_ecc_error_lo_dc5_ns = ld_single_ecc_error_lo_dc5 & ~kill_ecc_corr_lo_dc5;\n   assign ld_single_ecc_error_hi_dc5_ns = ld_single_ecc_error_hi_dc5 & ~kill_ecc_corr_hi_dc5;\n\n   assign ld_single_ecc_error_dc5_ff = (ld_single_ecc_error_lo_dc5_ff | ld_single_ecc_error_hi_dc5_ff) & ~lsu_double_ecc_error_dc5_ff;\n\n   assign sec_data_hi_dc5[pt.DCCM_DATA_WIDTH-1:0] = store_data_hi_dc5[pt.DCCM_DATA_WIDTH-1:0];\n   assign sec_data_lo_dc5[pt.DCCM_DATA_WIDTH-1:0] = store_data_lo_dc5[pt.DCCM_DATA_WIDTH-1:0];\n\n   // This is needed to avoid losing store on false sharing within a word.\n   assign lsu_stbuf_ecc_block = ld_single_ecc_error_dc3 | ld_single_ecc_error_dc4 | ld_single_ecc_error_dc5;\n   assign lsu_stbuf_commit_any = stbuf_reqvld_any & ~lsu_stbuf_ecc_block &\n                                 ((~(lsu_dccm_rden_dc1 | lsu_dccm_wren_spec_dc1 | ld_single_ecc_error_dc5_ff)) |\n                                  (lsu_dccm_rden_dc1 & (~((stbuf_addr_any[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS] == lsu_addr_dc1[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]) |\n                                                              (stbuf_addr_any[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS] == end_addr_dc1[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS])))));\n\n   // No need to read for aligned word/dword stores since ECC will come by new data completely\n   // read enable is speculative for timing reasons\n   assign lsu_dccm_rden_dc1 = (lsu_pkt_dc1_pre.valid & (lsu_pkt_dc1_pre.load | lsu_pkt_dc1_pre.atomic | (lsu_pkt_dc1_pre.store & (~(lsu_pkt_dc1_pre.word | lsu_pkt_dc1_pre.dword) | (lsu_addr_dc1[1:0] != 2'b0)))) & addr_in_dccm_region_dc1) |\n                              (dma_dccm_spec_req & (~dma_mem_write | ~(|dma_mem_sz[2:1])));   // Read based on speculation is fine\n\n   // DMA will read/write in decode stage\n   assign lsu_dccm_wren_dc1 = dma_dccm_wen;\n   assign lsu_dccm_wren_spec_dc1 = dma_dccm_spec_wen;\n\n   // DCCM inputs\n   assign dccm_wren                             = lsu_stbuf_commit_any | ld_single_ecc_error_dc5_ff | lsu_dccm_wren_dc1;\n   assign dccm_rden                             = lsu_dccm_rden_dc1;\n   assign dccm_wr_addr_lo[pt.DCCM_BITS-1:0]     = lsu_dccm_wren_spec_dc1 ? lsu_addr_dc1[pt.DCCM_BITS-1:0] :\n                                                  (ld_single_ecc_error_dc5_ff ? (ld_single_ecc_error_lo_dc5_ff ? ld_sec_addr_lo_dc5_ff[pt.DCCM_BITS-1:0] : ld_sec_addr_hi_dc5_ff[pt.DCCM_BITS-1:0]) : stbuf_addr_any[pt.DCCM_BITS-1:0]);\n   assign dccm_wr_addr_hi[pt.DCCM_BITS-1:0]     = lsu_dccm_wren_spec_dc1 ? end_addr_dc1[pt.DCCM_BITS-1:0] :\n                                                  (ld_single_ecc_error_dc5_ff ? (ld_single_ecc_error_hi_dc5_ff ? ld_sec_addr_hi_dc5_ff[pt.DCCM_BITS-1:0] : ld_sec_addr_lo_dc5_ff[pt.DCCM_BITS-1:0]) : stbuf_addr_any[pt.DCCM_BITS-1:0]);\n   assign dccm_rd_addr_lo[pt.DCCM_BITS-1:0]     = lsu_addr_dc1[pt.DCCM_BITS-1:0];\n   assign dccm_rd_addr_hi[pt.DCCM_BITS-1:0]     = end_addr_dc1[pt.DCCM_BITS-1:0];\n\n   // DCCM outputs\n    assign ldst_byteen_dc2[7:0] = ({8{lsu_pkt_dc2.by}}    & 8'b0000_0001) |\n                                  ({8{lsu_pkt_dc2.half}}  & 8'b0000_0011) |\n                                  ({8{"}
{"text": "lsu_pkt_dc2.word}}  & 8'b0000_1111) |\n                                  ({8{lsu_pkt_dc2.dword}} & 8'b1111_1111);\n\n   assign ldst_byteen_dc3[7:0] = ({8{lsu_pkt_dc3.by}}    & 8'b0000_0001) |\n                                 ({8{lsu_pkt_dc3.half}}  & 8'b0000_0011) |\n                                 ({8{lsu_pkt_dc3.word}}  & 8'b0000_1111) |\n                                 ({8{lsu_pkt_dc3.dword}} & 8'b1111_1111);\n\n  assign ldst_byteen_dc4[7:0] =  ({8{lsu_pkt_dc4.by}}    & 8'b0000_0001) |\n                                 ({8{lsu_pkt_dc4.half}}  & 8'b0000_0011) |\n                                 ({8{lsu_pkt_dc4.word}}  & 8'b0000_1111) |\n                                 ({8{lsu_pkt_dc4.dword}} & 8'b1111_1111);\n\n  assign ldst_byteen_dc5[7:0] =  ({8{lsu_pkt_dc5.by}}    & 8'b0000_0001) |\n                                 ({8{lsu_pkt_dc5.half}}  & 8'b0000_0011) |\n                                 ({8{lsu_pkt_dc5.word}}  & 8'b0000_1111) |\n                                 ({8{lsu_pkt_dc5.dword}} & 8'b1111_1111);\n\n   assign ldst_byteen_ext_dc2[7:0] = ldst_byteen_dc2[7:0] << lsu_addr_dc2[1:0];      // The packet in dc2\n   assign ldst_byteen_ext_dc3[7:0] = ldst_byteen_dc3[7:0] << lsu_addr_dc3[1:0];\n   assign ldst_byteen_ext_dc4[7:0] = ldst_byteen_dc4[7:0] << lsu_addr_dc4[1:0];\n   assign ldst_byteen_ext_dc5[7:0] = ldst_byteen_dc5[7:0] << lsu_addr_dc5[1:0];\n\n   assign dccm_wr_bypass_c1_c2_lo   = (stbuf_addr_any[pt.DCCM_BITS-1:2] == lsu_addr_dc2[pt.DCCM_BITS-1:2]) & addr_in_dccm_dc2;\n   assign dccm_wr_bypass_c1_c2_hi   = (stbuf_addr_any[pt.DCCM_BITS-1:2] == end_addr_dc2[pt.DCCM_BITS-1:2]) & addr_in_dccm_dc2 & ~lsu_pkt_dc2.sc;   // SC always aligned and upper 32 bits are used for ECC corrected data\n\n   assign dccm_wr_bypass_c1_c3_lo   = (stbuf_addr_any[pt.DCCM_BITS-1:2] == lsu_addr_dc3[pt.DCCM_BITS-1:2]) & addr_in_dccm_dc3;\n   assign dccm_wr_bypass_c1_c3_hi   = (stbuf_addr_any[pt.DCCM_BITS-1:2] == end_addr_dc3[pt.DCCM_BITS-1:2]) & addr_in_dccm_dc3 & ~lsu_pkt_dc3.sc;   // SC always aligned and upper 32 bits are used for ECC corrected data\n\n   assign dccm_wr_bypass_c1_c4_lo   = (stbuf_addr_any[pt.DCCM_BITS-1:2] == lsu_addr_dc4[pt.DCCM_BITS-1:2]) & addr_in_dccm_dc4;\n   assign dccm_wr_bypass_c1_c4_hi   = (stbuf_addr_any[pt.DCCM_BITS-1:2] == end_addr_dc4[pt.DCCM_BITS-1:2]) & addr_in_dccm_dc4 & ~lsu_pkt_dc4.sc;   // SC always aligned and upper 32 bits are used for ECC corrected data\n\n   assign dccm_wr_bypass_c1_c5_lo   = (stbuf_addr_any[pt.DCCM_BITS-1:2] == lsu_addr_dc5[pt.DCCM_BITS-1:2]) & addr_in_dccm_dc5;\n   assign dccm_wr_bypass_c1_c5_hi   = (stbuf_addr_any[pt.DCCM_BITS-1:2] == end_addr_dc5[pt.DCCM_BITS-1:2]) & addr_in_dccm_dc5 & ~lsu_pkt_dc5.sc;   // SC always aligned and upper 32 bits are used for ECC corrected data\n\n   // For SC conditional, hi data is used for ecc corrected data since in case of sc fail we just need to write corrected data.\n   assign store_data_lo_dc3[31:0]= (lsu_pkt_dc3.atomic & ~lsu_pkt_dc3.lr & ~lsu_pkt_dc3.sc) ? amo_data_dc3[31:0] : store_ecc_data_lo_dc3[31:0];\n   assign store_data_hi_dc3[31:0]= (lsu_pkt_dc3.atomic & ~lsu_pkt_dc3.lr & ~lsu_pkt_dc3.sc) ? amo_data_dc3[31:0] : (lsu_pkt_dc3.atomic & lsu_pkt_dc3.sc) ? sec_data_lo_dc3[31:0] : store_ecc_data_hi_dc3[31:0];\n\n   // Timing fix for EH2_plus1. DCCM read data comes out in 2 cycles\n   if (pt.LOAD_TO_USE_PLUS1 == 1) begin: GenL2U_1\n      logic lsu_stbuf_commit_any_Q;\n      logic dccm_wr_bypass_c1_c2_lo_Q, dccm_wr_bypass_c1_c2_hi_Q;\n      logic [31:0] stbuf_data_any_Q;\n\n      for (genvar i=0; i<4; i++) begin: Gen_dccm_data\n         assign dccm_data_lo_dc3[(8*i)+7:(8*i)]     = dccm_rd_data_lo[(8*i)+7:(8*i)];\n         assign dccm_data_hi_dc3[(8*i)+7:(8*i)]     = dccm_rd_data_hi[(8*i)+7:(8*i)];\n\n         assign dccm_data_lo_dc4_in[(8*i)+7:(8*i)]  = (lsu_stbuf_commit_any &  dccm_wr_bypass_c1_c3_lo & ~ldst_byteen_ext_dc3[i]) ? stbuf_data_any[(8*i)+7:(8*i)] :\n                                                                          (lsu_stbuf_commit_any_Q & dccm_wr_bypass_c1_c2_lo_Q & ~ldst_byteen_ext_dc3[i]) ? stbuf_data_any_Q[(8*i)+7:(8*i)] : store_data_lo_dc3[(8*i)+7:(8*i)];\n         assign dccm_data_hi_dc4_in[(8*i)+7:(8*i)]  = (lsu_stbuf_commit_any &  dccm_wr_bypass_c1_c3_hi & ~ldst_byteen_ext_dc3[i+4]) ? stbuf_data_any[(8*i)+7:(8*i)] :\n                                                                          (lsu_stbuf_commit_any_Q & dccm_wr_bypass_c1_c2_hi_Q & ~ldst_byteen_ext_dc3[i+4]) ? stbuf_data_any_Q[(8*i)+7:(8*i)] : store_data_hi_dc3[(8*i)+7:(8*i)];\n      end\n\n      assign dccm_data_ecc_lo_dc3[pt.DCCM_ECC_WIDTH-1:0] = dccm_rd_data_lo[pt.DCCM_FDATA_WIDTH-1:pt.DCCM_DATA_WIDTH];\n      assign dccm_data_ecc_hi_dc3[pt.DCCM_ECC_WIDTH-1:0] = dccm_rd_data_hi[pt.DCCM_FDATA_WIDTH-1:pt.DCCM_DATA_WIDTH];\n\n      rvdff #(1) stbuf_commit_ff (.din(lsu_stbuf_commit_any), .dout(lsu_stbuf_commit_any_Q), .clk(lsu_c2_dc3_clk), .*);\n      rvdff #(1) dccm_wr_bypass_c1_c2_loff (.din(dccm_wr_bypass_c1_c2_lo), .dout(dccm_wr_bypass_c1_c2_lo_Q), .clk(lsu_c2_dc3_clk), .*);\n      rvdff #(1) dccm_wr_bypass_c1_c2_hiff (.din(dccm_wr_bypass_c1_c2_hi), .dout(dccm_wr_bypass_c1_c2_hi_Q), .clk(lsu_c2_dc3_clk), .*);\n      rvdffe #(32) stbuf_data_anyff (.din(stbuf_data_any[31:0]), .dout(stbuf_data_any_Q[31:0]), .en(lsu_stbuf_commit_any | clk_override), .*);\n\n   end else begin: GenL2U_0\n      logic [pt.DCCM_DATA_WIDTH-1:0]  dccm_data_hi_dc2, dccm_data_lo_dc2;\n      logic [pt.DCCM_ECC_WIDTH-1:0]   dccm_data_ecc_hi_dc2, dccm_data_ecc_lo_dc2;\n\n      for (genvar i=0; i<4; i++) begin: Gen_dccm_data\n         assign dccm_data_lo_dc2[(8*i)+7:(8*i)]     = (lsu_stbuf_commit_any &  lsu_pkt_dc2.store & dccm_wr_bypass_c1_c2_lo & ~ldst_byteen_ext_dc2[i])   ? stbuf_data_any[(8*i)+7:(8*i)] : dccm_rd_data_lo[(8*i)+7:(8*i)]; // for ld choose dccm_out\n         assign dccm_data_hi_dc2[(8*i)+7:(8*i)]     = (lsu_stbuf_commit_any &  lsu_pkt_dc2.store & dccm_wr_bypass_c1_c2_hi & ~ldst_byteen_ext_dc2[i+4]) ? stbuf_data_any[(8*i)+7:(8*i)] : dccm_rd_data_hi[(8*i)+7:(8*i)]; // for ld this is used for ecc\n\n         assign dccm_data_lo_dc4_in[(8*i)+7:(8*i)]  = (lsu_stbuf_commit_any &  dccm_wr_bypass_c1_c3_lo & ~ldst_byteen_ext_dc3[i])   ? stbuf_data_any[(8*i)+7:(8*i)] : store_data_lo_dc3[(8*i)+7:(8*i)];\n         assign dccm_data_hi_dc4_in[(8*i)+7:(8*i)]  = (lsu_stbuf_commit_any &  dccm_wr_bypass_c1_c3_hi & ~ldst_byteen_ext_dc3[i+4]) ? stbuf_data_any[(8*i)+7:(8*i)] : store_data_hi_dc3[(8*i)+7:(8*i)];\n      end\n\n      assign dccm_data_ecc_lo_dc2[pt.DCCM_ECC_WIDTH-1:0] = dccm_rd_data_lo[pt.DCCM_FDATA_WIDTH-1:pt.DCCM_DATA_WIDTH];\n      assign dccm_data_ecc_hi_dc2[pt.DCCM_ECC_WIDTH-1:0] = dccm_rd_data_hi[pt.DCCM_FDATA_WIDTH-1:pt.DCCM_DATA_WIDTH];\n\n      assign dccm_data_lo_dc3_clken = (lsu_pkt_dc2.valid & addr_in_dccm_dc2) | clk_override;\n      assign dccm_data_hi_dc3_clken = (dccm_data_lo_dc3_clken & ldst_dual_dc2) | clk_override;\n\n      rvdffe #(pt.DCCM_DATA_WIDTH + pt.DCCM_ECC_WIDTH) dccm_data_hi_dc3ff (.din({dccm_data_hi_dc2[pt.DCCM_DATA_WIDTH-1:0],dccm_data_ecc_hi_dc2[pt.DCCM_ECC_WIDTH-1:0]}),\n                                                                           .dout({dccm_data_hi_dc3[pt.DCCM_DATA_WIDTH-1:0],dccm_data_ecc_hi_dc3[pt.DCCM_ECC_WIDTH-1:0]}), .en(dccm_data_hi_dc3_clken), .*);\n      rvdffe #(pt.DCCM_DATA_WIDTH + pt.DCCM_ECC_WIDTH) dccm_data_lo_dc3ff (.din({dccm_data_lo_dc2[pt.DCCM_DATA_WIDTH-1:0],dccm_data_ecc_lo_dc2[pt.DCCM_ECC_WIDTH-1:0]}),\n                                                                           .dout({dccm_data_lo_dc3[pt.DCCM_DATA_WIDTH-1:0],dccm_data_ecc_lo_dc3[pt.DCCM_ECC_WIDTH-1:0]}), .en(dccm_data_lo_dc3_clken), .*);\n\n   end\n\n\n   for (genvar i=0; i<4; i++) begin: Gen_dccm_data_dc4_dc5\n      assign dccm_data_lo_dc5_in[(8*i)+7:(8*i)]  = (lsu_stbuf_commit_any &  dccm_wr_bypass_c1_c4_lo & ~ldst_byteen_ext_dc4[i])   ? stbuf_data_any[(8*i)+7:(8*i)] : store_data_lo_dc4[(8*i)+7:(8*i)];\n      assign dccm_data_hi_dc5_in[(8*i)+7:(8*i)]  = (lsu_stbuf_commit_any &  dccm_wr_bypass_c1_c4_hi & ~ldst_byteen_ext_dc4[i+4]) ? stbuf_data_any[(8*i)+7:(8*i)] : store_data_hi_dc4[(8*i)+7:(8*i)];\n\n      // This is store buffer write data\n      assign dccm_datafn_lo_dc5[(8*i)+7:(8*i)]   = (lsu_stbuf_commit_any &  dccm_wr_bypass_c1_c5_lo & ~ldst_byteen_ext_dc5[i]) ? stbuf_data_any[(8*i)+7:(8*i)] :\n                                                                                 (lsu_pkt_dc5.atomic & lsu_pkt_dc5.sc & ~lsu_sc_success_dc5) ? store_data_hi_dc5[(8*i)+7:(8*i)] : store_data_lo_dc5[(8*i)+7:(8*i)];\n      assign dccm_datafn_hi_dc5[(8*i)+7:(8*i)]   = (lsu_stbuf_commit_any &  dccm_wr_bypass_c1_c5_hi & ~ldst_byteen_ext_dc5[i+4]) ? stbuf_data_any[(8*i)+7:(8*i)] : store_data_hi_dc5[(8*i)+7:(8*i)];\n   end // for (genvar i=0; i<BYTE_WIDTH; i++)\n\n   // Need to disable ecc correction since data is being forwarded for store (ECC is from RAM but data from forwarding path so they are out of sync).\n   assign disable_ecc_check_lo_dc2 = lsu_stbuf_commit_any & lsu_pkt_dc2.store & dccm_wr_bypass_c1_c2_lo;\n   assign disable_ecc_check_hi_dc2 = lsu_stbuf_commit_any & lsu_pkt_dc2.store & dccm_wr_bypass_c1_c2_hi;\n\n   // PIC signals. PIC ignores the lower 2 bits of address since PIC memory registers are 32-bits\n   assign picm_wren_notdma   = (lsu_pkt_dc5.valid & lsu_pkt_dc5.store & addr_in_pic_dc5 & lsu_commit_dc5);\n   assign picm_wren          = (lsu_pkt_dc5.valid & lsu_pkt_dc5.store & addr_in_pic_dc5 & lsu_commit_dc5) | dma_pic_wen;\n   assign picm_rden          = lsu_pkt_dc1.valid & lsu_pkt_dc1.load  & addr_in_pic_dc1;\n   assign picm_mken          = lsu_pkt_dc1.valid & lsu_pkt_dc1.store & addr_in_pic_dc1;  // Get the mask for stores\n   assign picm_rd_thr        = lsu_pkt_dc1.tid;\n   assign picm_rdaddr[31:0]  = lsu_addr_dc1[31:0];\n   assign picm_wraddr[31:0]  = dma_pic_wen ? dma_mem_addr[31:0] : lsu_addr_dc5[31:0];\n   assign picm_wr_data[31:0] = dma_pic_wen ? dma_mem_wdata[31:0] : store_data_lo_dc5[31:0];\n\n   // getting raw store data back for bus\n   assign store_data_ext_dc3[63:0] = {store_ecc_data_hi_dc3[31:0], store_ecc_data_lo_dc3[31:0]};   // We don't need AMO here since this is used for fwding and there can't be a load behind AMO\n   assign store_data_ext_dc4[63:0] = {store_data_hi_dc4[31:0], store_data_lo_dc4[31:0]};\n   assign store_data_ext_dc5[63:0] = {store_data_hi_dc5[31:0], store_data_lo_dc5[31:0]};\n\n   // Flops\n   assign picm_mask_data_dc3[31:0] = picm_rd_dataQ[31:0];   // Can't use picm_rd_data_dc3 since we don't need forward data here (this is mask)\n   assign picm_rd_data_dc2 = picm_fwd_en_dc2 ? picm_fwd_data_dc2[31:0] : picm_rd_data[31:0];\n   rvdff #(32) picm_data_ff    (.*, .din(picm_rd_data_dc2[31:0]), .dout(picm_rd_data_dc3[31:0]), .clk(lsu_pic_c1_dc3_clk));\n   rvdff #(32) picm_rd_data_ff (.*, .din(picm_rd_data[31:0]),     .dout(picm_rd_dataQ[31:0]),    .clk(lsu_pic_c1_dc3_clk));\n\n   assign dccm_data_lo_dc4_clken = (lsu_pkt_dc3.valid & (lsu_pkt_dc3.store | ld_single_ecc_error_dc3)) | clk_override;\n   assign dccm_data_hi_dc4_clken = (dccm_data_lo_dc4_clken & (ldst_dual_dc3 | lsu_pkt_dc3.atomic)) | clk_override;\n\n   assign dccm_data_lo_dc5_clken = (lsu_pkt_dc4.valid & (lsu_pkt_dc4.store | ld_single_ecc_error_dc4)) | clk_override;\n   assign dccm_data_hi_dc5_clken = (dccm_data_lo_dc5_clken & (ldst_dual_dc4 | lsu_pkt_dc4.atomic)) | clk_override;\n\n   rvdffe #(pt.DCCM_DATA_WIDTH) dccm_data_hi_dc4ff (.*, .din(dccm_data_hi_dc4_in[pt.DCCM_DATA_WIDTH-1:0]), .dout(store_data_hi_dc4[pt.DCCM_DATA_WIDTH-1:0]), .en(dccm_data_hi_dc4_clken));\n   rvdffe #(pt.DCCM_DATA_WIDTH) dccm_data_lo_dc4ff (.*, .din(dccm_data_lo_dc4_in[pt.DCCM_DATA_WIDTH-1:0]), .dout(store_data_lo_dc4[pt.DCCM_DATA_WIDTH-1:0]), .en(dccm_data_lo_dc4_clken));\n\n   rvdffe #(pt.DCCM_DATA_WIDTH) dccm_data_hi_dc5ff (.*, .din(dccm_data_hi_dc5_in[pt.DCCM_DATA_WIDTH-1:0]), .dout(store_data_hi_dc5[pt.DCCM_DATA_WIDTH-1:0]), .en(dccm_data_hi_dc5_clken));\n   rvdffe #(pt.DCCM_DATA_WIDTH) dccm_data_lo_dc5ff (.*, .din(dccm_data_lo_dc5_in[pt.DCCM_DATA_WIDTH-1:0]), .dout(store_data_lo_dc5[pt.DCCM_DATA_WIDTH-1:0]), .en(dccm_data_lo_dc5_clken));\n\n   if (pt.DCCM_ENABLE == 1) begin: Gen_dccm_enable\n      rvdff #(1) dccm_rden_dc2ff (.*, .din(lsu_dccm_rden_dc1), .dout(lsu_dccm_rden_dc2), .clk(lsu_c2_dc2_clk));\n      rvdff #(1) dccm_rden_dc3ff (.*, .din(lsu_dccm_rden_dc2), .dout(lsu_dccm_rden_dc3), .clk(lsu_c2_dc3_clk));\n\n      rvdff #(1) ecc_disable_hi_dc3ff (.*, .din(disable_ecc_check_hi_dc2),    .dout(disable_ecc_check_hi_dc3),    .clk(lsu_dccm_c1_dc3_clk));\n      rvdff #(1) ecc_disable_lo_dc3ff (.*, .din(disable_ecc_check_lo_dc2),    .dout(disable_ecc_check_lo_dc3),    .clk(lsu_dccm_c1_dc3_clk));\n\n      // ECC correction flops since dccm write happens next cycle\n      // We are writing to dccm in dc5+1 for ecc correction since fast_int needs to be blocked in decode - 2.\n      rvdff #(1) lsu_double_ecc_error_dc5ff     (.*, .din(lsu_double_ecc_error_dc5),   .dout(lsu_double_ecc_error_dc5_ff),   .clk(lsu_free_c2_clk));\n      rvdff #(1) ld_single_ecc_error_hi_dc5ff   (.*, .din(ld_single_ecc_error_hi_dc5_ns), .dout(ld_single_ecc_error_hi_dc5_ff), .clk(lsu_free_c2_clk));\n      rvdff #(1) ld_single_ecc_error_lo_dc5ff   (.*, .din(ld_single_ecc_error_lo_dc5_ns), .dout(ld_single_ecc_error_lo_dc5_ff), .clk(lsu_free_c2_clk));\n      rvdffe #(pt.DCCM_BITS) ld_sec_addr_hi_rff (.*, .din(end_addr_dc5[pt.DCCM_BITS-1:0]), .dout(ld_sec_addr_hi_dc5_ff[pt.DCCM_BITS-1:0]), .en(ld_single_ecc_error_dc5 | clk_override), .clk(clk));\n      rvdffe #(pt.DCCM_BITS) ld_sec_addr_lo_rff (.*, .din(lsu_addr_dc5[pt.DCCM_BITS-1:0]), .dout(ld_sec_addr_lo_dc5_ff[pt.DCCM_BITS-1:0]), .en(ld_single_ecc_error_dc5 | clk_override), .clk(clk));\n\n   end else begin: Gen_dccm_disable\n      assign lsu_dccm_rden_dc2 = '0;\n      assign lsu_dccm_rden_dc3 = '0;\n      assign disable_ecc_check_lo_dc3 = 1'b1;\n      assign disable_ecc_check_hi_dc3 = 1'b1;\n\n      assign lsu_double_ecc_error_dc5_ff = '0;\n      assign ld_single_ecc_error_lo_dc5_ff = '0;\n      assign ld_single_ecc_error_hi_dc5_ff = '0;\n      assign ld_sec_addr_lo_dc5_ff[pt.DCCM_BITS-1:0] = '0;\n      assign ld_sec_addr_hi_dc5_ff[pt.DCCM_BITS-1:0] = '0;\n   end\n\n`ifdef RV_ASSERT_ON\n\n   assert_dccm_rden_wren_onehot: assert #0 ($onehot0({lsu_dccm_wren_spec_dc1, lsu_dccm_rden_dc1}));\n\n`endif\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: DCCM for LSU pipe\n// Comments: Single ported memory\n//\n//\n// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n//\n// //********************************************************************************\n\n\n`define EH2_LOCAL_DCCM_RAM_TEST_PORTS    .TEST1(dccm_ext_in_pkt[i].TEST1),                      \\\n                                     .RME(dccm_ext_in_pkt[i].RME),                      \\\n                                     .RM(dccm_ext_in_pkt[i].RM),                        \\\n                                     .LS(dccm_ext_in_pkt[i].LS),                        \\\n                                     .DS(dccm_ext_in_pkt[i].DS),                        \\\n                                     .SD(dccm_ext_in_pkt[i].SD),                        \\\n                                     .TEST_RNM(dccm_ext_in_pkt[i].TEST_RNM),            \\\n                                     .BC1(dccm_ext_in_pkt[i].BC1),                      \\\n                                     .BC2(dccm_ext_in_pkt[i].BC2),                      \\\n\n\n\nmodule eh2_lsu_dccm_mem\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n )(\n   input logic         clk,                                             // clock\n   input logic         active_clk,                                        // clock\n   input logic         rst_l,\n   input logic         clk_override,                                    // clock override\n\n   input logic         dccm_wren,                                       // write enable\n   input logic         dccm_rden,                                       // read enable\n   input logic [pt.DCCM_BITS-1:0]  dccm_wr_addr_lo,                     // write address\n   input logic [pt.DCCM_BITS-1:0]  dccm_wr_addr_hi,                     // write address\n   input logic [pt.DCCM_BITS-1:0]  dccm_rd_addr_lo,                     // read address\n   input logic [pt.DCCM_BITS-1:0]  dccm_rd_addr_hi,                     // read address for the upper bank in case of a misaligned access\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_lo,              // write data\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_hi,              // write data\n   input eh2_dccm_ext_in_pkt_t  [pt.DCCM_NUM_BANKS-1:0] dccm_ext_in_pkt,    // the dccm packet from the soc\n\n   output logic [pt.DCCM_FDATA_WIDTH-1:0] dccm_rd_data_lo,              // read data from the lo bank\n   output logic [pt.DCCM_FDATA_WIDTH-1:0] dccm_rd_data_hi,              // read data from the hi bank\n\n   input  logic         scan_mode\n);\n\n\n   localparam DCCM_WIDTH_BITS = $clog2(pt.DCCM_BYTE_WIDTH);\n   localparam DCCM_INDEX_BITS = (pt.DCCM_BITS - pt.DCCM_BANK_BITS - pt.DCCM_WIDTH_BITS);\n   localparam DCCM_INDEX_DEPTH = (((pt.DCCM_SIZE)*1024)>>($clog2(pt.DCCM_BYTE_WIDTH)))>>$clog2((pt.DCCM_NUM_BANKS));  // Depth of memory bank\n\n\n   logic [pt.DCCM_NUM_BANKS-1:0]                                        wren_bank;\n   logic [pt.DCCM_NUM_BANKS-1:0]                                        rden_bank;\n   logic [pt.DCCM_NUM_BANKS-1:0] [pt.DCCM_BITS-1:(pt.DCCM_BANK_BITS+2)] addr_bank;\n   logic [pt.DCCM_BITS-1:(pt.DCCM_BANK_BITS+DCCM_WIDTH_BITS)]           rd_addr_even, rd_addr_odd;\n   logic                                                                rd_unaligned, wr_unaligned;\n   logic [pt.DCCM_NUM_BANKS-1:0] [pt.DCCM_FDATA_WIDTH-1:0]              dccm_bank_dout;\n   logic [pt.DCCM_FDATA_WIDTH-1:0]                                      wrdata;\n\n   logic [pt.DCCM_NUM_BANKS-1:0][pt.DCCM_FDATA_WIDTH-1:0]               wr_data_bank;\n\n   logic [pt.DCCM_NUM_BANKS-1:0]                                        dccm_rd_data_bank_hi, dccm_rd_data_bank_lo;\n\n   logic [(DCCM_WIDTH_BITS+pt.DCCM_BANK_BITS-1):DCCM_WIDTH_BITS]        dccm_rd_addr_lo_q;\n   logic [(DCCM_WIDTH_BITS+pt.DCCM_BANK_BITS-1):DCCM_WIDTH_BITS]        dccm_rd_addr_hi_q;\n\n   logic [pt.DCCM_NUM_BANKS-1:0]                                        dccm_clken;\n\n   logic                                                                dccm_rd_addr_lo_q2;\n   logic                                                                dccm_rd_addr_hi_q2;\n\n\n   assign rd_unaligned = (dccm_rd_addr_lo[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS] != dccm_rd_addr_hi[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]);\n   assign wr_unaligned = (dccm_wr_addr_lo[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS] != dccm_wr_addr_hi[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]);\n\n\n   // 8 Banks, 16KB each (2048 x 72)\n   for (genvar i=0; i<pt.DCCM_NUM_BANKS; i++) begin: mem_bank\n      assign  wren_bank[i]        = dccm_wren & ((dccm_wr_addr_hi[2+:pt.DCCM_BANK_BITS] == i) | (dccm_wr_addr_lo[2+:pt.DCCM_BANK_BITS] == i));\n      assign  rden_bank[i]        = dccm_rden & ((dccm_rd_addr_hi[2+:pt.DCCM_BANK_BITS] == i) | (dccm_rd_addr_lo[2+:pt.DCCM_BANK_BITS] == i));\n      assign  addr_bank[i][(pt.DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] = rden_bank[i] ? (((dccm_rd_addr_hi[2+:pt.DCCM_BANK_BITS] == i) & rd_unaligned) ?\n                                                                                                        dccm_rd_addr_hi[(pt.DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] :\n                                                                                                        dccm_rd_addr_lo[(pt.DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS]) :\n                                                                                                  (((dccm_wr_addr_hi[2+:pt.DCCM_BANK_BITS] == i) & wr_unaligned) ?\n                                                                                                        dccm_wr_addr_hi[(pt.DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS] :\n                                                                                                        dccm_wr_addr_lo[(pt.DCCM_BANK_BITS+DCCM_WIDTH_BITS)+:DCCM_INDEX_BITS]);\n\n\n      assign wr_data_bank[i]     = ((dccm_wr_addr_hi[2+:pt.DCCM_BANK_BITS] == i) & wr_unaligned) ? dccm_wr_data_hi[pt.DCCM_FDATA_WIDTH-1:0] : dccm_wr_data_lo[pt.DCCM_FDATA_WIDTH-1:0];\n\n      // clock gating section\n      assign  dccm_clken[i] = (wren_bank[i] | rden_bank[i] | clk_override) ;\n      // end clock gating section\n\n`ifdef VERILATOR\n        eh2_ram #(DCCM_INDEX_DEPTH,39)  ram (\n                                  // Primary ports\n                                  .ME(dccm_clken[i]),\n                                  .CLK(clk),\n                                  .WE(wren_bank[i]),\n                                  .ADR(addr_bank[i]),\n                                  .D(wr_data_bank[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                  .Q(dccm_bank_dout[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                  .ROP ( ),\n                                  // These are used by SoC\n                                  `EH2_LOCAL_DCCM_RAM_TEST_PORTS\n                                  .*\n                                  );\n\n`else\n      if (DCCM_INDEX_DEPTH == 32768) begin : dccm\n         ram_32768x39  dccm_bank (\n                                  // Primary ports\n                                  .ME(dccm_clken[i]),\n                                  .CLK(clk),\n                                  .WE(wren_bank[i]),\n                                  .ADR(addr_bank[i]),\n                                  .D(wr_data_bank[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                  .Q(dccm_bank_dout[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                  .ROP ( ),\n                                  // These are used by SoC\n                                  `EH2_LOCAL_DCCM_RAM_TEST_PORTS\n                                  .*\n                                  );\n      end\n      else if (DCCM_INDEX_DEPTH == 16384) begin : dccm\n         ram_16384x39  dccm_bank (\n                                  // Primary ports\n                                  .ME(dccm_clken[i]),\n                                  .CLK(clk),\n                                  .WE(wren_bank[i]),\n                                  .ADR(addr_bank[i]),\n                                  .D(wr_data_bank[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                  .Q(dccm_bank_dout[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                  .ROP ( ),\n                                  // These are used by SoC\n                                  `EH2_LOCAL_DCCM_RAM_TEST_PORTS\n                                  .*\n                                  );\n      end\n      else if (DCCM_INDEX_DEPTH == 8192) begin : dccm\n         ram_8192x39  dccm_bank (\n                                 // Primary ports\n                                 .ME(dccm_clken[i]),\n                                 .CLK(clk),\n                                 .WE(wren_bank[i]),\n                                 .ADR(addr_bank[i]),\n                                 .D(wr_data_bank[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                 .Q(dccm_bank_dout[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                 .ROP ( ),\n                                 // These are used by SoC\n                                 `EH2_LOCAL_DCCM_RAM_TEST_PORTS\n                                 .*\n                                 );\n      end\n      else if (DCCM_INDEX_DEPTH == 4096) begin : dccm\n         ram_4096x39  dccm_bank (\n                                 // Primary ports\n                                 .ME(dccm_clken[i]),\n                                 .CLK(clk),\n                                 .WE(wren_bank[i]),\n                                 .ADR(addr_bank[i]),\n                                 .D(wr_data_bank[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                 .Q(dccm_bank_dout[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                 .ROP ( ),\n                                 // These are used by SoC\n                                 `EH2_LOCAL_DCCM_RAM_TEST_PORTS\n                                 .*\n                                 );\n      end\n      else if (DCCM_INDEX_DEPTH == 3072) begin : dccm\n         ram_3072x39  dccm_bank (\n                                 // Primary ports\n                                 .ME(dccm_clken[i]),\n                                 .CLK(clk),\n                                 .WE(wren_bank[i]),\n                                 .ADR(addr_bank[i]),\n                                 .D(wr_data_bank[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                 .Q(dccm_bank_dout[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                 .ROP ( ),\n                                 // These are used by SoC\n                                 `EH2_LOCAL_DCCM_RAM_TEST_PORTS\n                                 .*\n                                 );\n      end\n      else if (DCCM_INDEX_DEPTH == 2048) begin : dccm\n         ram_2048x39  dccm_bank (\n                                 // Primary ports\n                                 .ME(dccm_clken[i]),\n                                 .CLK(clk),\n                                 .WE(wren_bank[i]),\n                                 .ADR(addr_bank[i]),\n                                 .D(wr_data_bank[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                 .Q(dccm_bank_dout[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                 .ROP ( ),\n                                 // These are used by SoC\n                                 `EH2_LOCAL_DCCM_RAM_TEST_PORTS\n                                 .*\n                                 );\n      end\n      else if (DCCM_INDEX_DEPTH == 1024) begin : dccm\n         ram_1024x39  dccm_bank (\n                                 // Primary ports\n                                 .ME(dccm_clken[i]),\n                                 .CLK(clk),\n                                 .WE(wren_bank[i]),\n                                 .ADR(addr_bank[i]),\n                                 .D(wr_data_bank[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                 .Q(dccm_bank_dout[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                 .ROP ( ),\n                                 // These are used by SoC\n                                 `EH2_LOCAL_DCCM_RAM_TEST_PORTS\n                                 .*\n                                 );\n      end\n      else if (DCCM_INDEX_DEPTH == 512) begin : dccm\n         ram_512x39  dccm_bank (\n                                // Primary ports\n                                .ME(dccm_clken[i]),\n                                .CLK(clk),\n                                .WE(wren_bank[i]),\n                                .ADR(addr_bank[i]),\n                                .D(wr_data_bank[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                .Q(dccm_bank_dout[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                .ROP ( ),\n                                // These are used by SoC\n                                `EH2_LOCAL_DCCM_RAM_TEST_PORTS\n                                .*\n                                );\n      end\n      else if (DCCM_INDEX_DEPTH == 256) begin : dccm\n         ram_256x39  dccm_bank (\n                                // Primary ports\n                                .ME(dccm_clken[i]),\n                                .CLK(clk),\n                                .WE(wren_bank[i]),\n                                .ADR(addr_bank[i]),\n                                .D(wr_data_bank[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                .Q(dccm_bank_dout[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                .ROP ( ),\n                                // These are used by SoC\n                                `EH2_LOCAL_DCCM_RAM_TEST_PORTS\n                                .*\n                                );\n      end\n      else if (DCCM_INDEX_DEPTH == 128) begin : dccm\n         ram_128x39  dccm_bank (\n                                // Primary ports\n                                .ME(dccm_clken[i]),\n                                .CLK(clk),\n                                .WE(wren_bank[i]),\n                                .ADR(addr_bank[i]),\n                                .D(wr_data_bank[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                .Q(dccm_bank_dout[i][pt.DCCM_FDATA_WIDTH-1:0]),\n                                .ROP ( ),\n                                // These are used by SoC\n                                `EH2_LOCAL_DCCM_RAM_TEST_PORTS\n                                .*\n                                );\n      end\n`endif // VERILATOR\n   end : mem_bank\n\n   // Flops\n   rvdffs  #(pt.DCCM_BANK_BITS) rd_addr_lo_ff (.*, .din(dccm_rd_addr_lo[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]), .dout(dccm_rd_addr_lo_q[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]), .en(1'b1), .clk(active_clk));\n   rvdffs  #(pt.DCCM_BANK_BITS) rd_addr_hi_ff (.*, .din(dccm_rd_addr_hi[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]), .dout(dccm_rd_addr_hi_q[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]), .en(1'b1), .clk(active_clk));\n\n   // For Plus1 --> Read data comes out 2 cycle after dccm_rden since we need to flop the bank data and then mux between the banks\n   if (pt.LOAD_TO_USE_PLUS1 == 1) begin: GenL2U_1\n      logic                                                          dccm_rden_q;\n      logic [pt.DCCM_NUM_BANKS-1:0] [pt.DCCM_FDATA_WIDTH-1:0]        dccm_bank_dout_q;\n      logic [(DCCM_WIDTH_BITS+pt.DCCM_BANK_BITS-1):DCCM_WIDTH_BITS]  dccm_rd_addr_lo_q2;\n      logic [(DCCM_WIDTH_BITS+pt.DCCM_BANK_BITS-1):DCCM_WIDTH_BITS]  dccm_rd_addr_hi_q2;\n\n      // Mux out the read data\n      assign dccm_rd_data_lo[pt.DCCM_FDATA_WIDTH-1:0]  = dccm_bank_dout_q[dccm_rd_addr_lo_q2[pt.DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]][pt.DCCM_FDATA_WIDTH-1:0];\n      assign dccm_rd_data_hi[pt.DCCM_FDATA_WIDTH-1:0]  = dccm_bank_dout_q[dccm_rd_addr_hi_q2[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]][pt.DCCM_FDATA_WIDTH-1:0];\n\n      for (genvar i=0; i<pt.DCCM_NUM_BANKS; i++) begin: GenBanks\n         rvdffe #(pt.DCCM_FDATA_WIDTH) dccm_bank_dout_ff(.*, .din(dccm_bank_dout[i]), .dout(dccm_bank_dout_q[i]), .en(dccm_rden_q | clk_override));\n      end\n\n      rvdff  #(1)                  dccm_rden_ff  (.*, .din(dccm_rden), .dout(dccm_rden_q), .clk(active_clk));\n      rvdffs  #(pt.DCCM_BANK_BITS) rd_addr_lo_ff (.*, .din(dccm_rd_addr_lo_q[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]), .dout(dccm_rd_addr_lo_q2[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]), .en(1'b1), .clk(active_clk));\n      rvdffs  #(pt.DCCM_BANK_BITS) rd_addr_hi_ff (.*, .din(dccm_rd_addr_hi_q[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]), .dout(dccm_rd_addr_hi_q2[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]), .en(1'b1), .clk(active_clk));\n   end else begin\n      // mux out the read data\n      assign dccm_rd_data_lo[pt.DCCM_FDATA_WIDTH-1:0]  = dccm_bank_dout[dccm_rd_addr_lo_q[pt.DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]][pt.DCCM_FDATA_WIDTH-1:0];\n      assign dccm_rd_data_hi[pt.DCCM_FDATA_WIDTH-1:0]  = dccm_bank_dout[dccm_rd_addr_hi_q[DCCM_WIDTH_BITS+:pt.DCCM_BANK_BITS]][pt.DCCM_FDATA_WIDTH-1:0];\n\n      assign dccm_rd_addr_lo_q2 = '0;\n      assign dccm_rd_addr_hi_q2 = '0;\n   end\n`undef EH2_LOCAL_DCCM_RAM_TEST_PORTS\n\nendmodule // eh2_lsu_dccm_mem\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: Top level file for load store unit\n// Comments:\n//\n//\n// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n//\n//********************************************************************************\nmodule eh2_lsu_ecc\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n(\n\n   input logic                          clk,\n   input logic                          clk_override,        // Disable clock gating\n   input logic                          scan_mode,             // scan mode\n   input logic                          rst_l,\n   input eh2_lsu_pkt_t                 lsu_pkt_dc3,        // packet in dc3\n   input logic                          lsu_dccm_rden_dc3,  // dccm rden\n   input logic                          addr_in_dccm_dc3,   // address in dccm\n   input logic [pt.DCCM_BITS-1:0]       lsu_addr_dc3,    // start address\n   input logic [pt.DCCM_BITS-1:0]       end_addr_dc3,    // end address\n   input logic [31:0]                   store_data_dc3,  // store data\n   input logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_data_any,\n\n   input logic [pt.DCCM_DATA_WIDTH-1:0] dccm_data_hi_dc3,     // raw data from mem\n   input logic [pt.DCCM_DATA_WIDTH-1:0] dccm_data_lo_dc3,     // raw data from mem\n   input logic [pt.DCCM_ECC_WIDTH-1:0]  dccm_data_ecc_hi_dc3, // ecc read out from mem\n   input logic [pt.DCCM_ECC_WIDTH-1:0]  dccm_data_ecc_lo_dc3, // ecc read out from mem\n\n   input logic  [pt.DCCM_DATA_WIDTH-1:0] sec_data_hi_dc5,\n   input logic  [pt.DCCM_DATA_WIDTH-1:0] sec_data_lo_dc5,\n\n   input logic                           ld_single_ecc_error_dc5,      // ld has a single ecc error\n   input logic                           ld_single_ecc_error_dc5_ff,   // ld has a single ecc error\n   input logic                           ld_single_ecc_error_lo_dc5_ff,   // ld has a single ecc error\n   input logic                           ld_single_ecc_error_hi_dc5_ff,   // ld has a single ecc error\n   input logic                           dec_tlu_core_ecc_disable,     // disables the ecc computation and error flagging\n   input logic                           disable_ecc_check_lo_dc3,\n   input logic                           disable_ecc_check_hi_dc3,\n   input logic                           misaligned_fault_dc3,\n   input logic                           access_fault_dc3,\n\n   input logic                           dma_dccm_spec_wen,\n   input logic  [31:0]                   dma_dccm_wdata_lo,\n   input logic  [31:0]                   dma_dccm_wdata_hi,\n\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_hi,\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_lo,\n\n   output logic [pt.DCCM_DATA_WIDTH-1:0] sec_data_hi_dc3,\n   output logic [pt.DCCM_DATA_WIDTH-1:0] sec_data_lo_dc3,\n\n   output logic [pt.DCCM_DATA_WIDTH-1:0] store_ecc_data_hi_dc3,  // final store data either from stbuf or SEC DCCM readout\n   output logic [pt.DCCM_DATA_WIDTH-1:0] store_ecc_data_lo_dc3,\n\n   output logic                          single_ecc_error_hi_dc3,                   // sec detected\n   output logic                          single_ecc_error_lo_dc3,                   // sec detected on lower dccm bank\n   output logic                          lsu_single_ecc_error_dc3,                  // or of the 2\n   output logic                          lsu_double_ecc_error_dc3                   // double error detected\n\n );\n\n   logic        double_ecc_error_hi_dc3, double_ecc_error_lo_dc3;\n   logic [pt.DCCM_ECC_WIDTH-1:0]  dccm_wdata_ecc_hi_any, dccm_wdata_ecc_lo_any;\n\n   logic        ldst_dual_dc3;\n   logic        is_ldst_dc3;\n   logic        is_ldst_hi_dc3, is_ldst_lo_dc3;\n   logic [7:0]  ldst_byteen_dc3;\n   logic [7:0]  store_byteen_dc3;\n   logic [7:0]  store_byteen_ext_dc3;\n   logic [pt.DCCM_BYTE_WIDTH-1:0]       store_byteen_hi_dc3, store_byteen_lo_dc3;\n\n   logic [55:0] store_data_ext_dc3;\n   logic [pt.DCCM_DATA_WIDTH-1:0]  store_data_hi_dc3, store_data_lo_dc3;\n   logic [6:0]                  ecc_out_hi_nc, ecc_out_lo_nc;\n\n   logic                       single_ecc_error_hi_raw_dc3, single_ecc_error_lo_raw_dc3;\n   logic  [pt.DCCM_DATA_WIDTH-1:0] sec_data_hi_dc5_ff, sec_data_lo_dc5_ff;\n\n   //------------------------------------------------------------------------------------------------------------\n   //----------------------------------------Logic starts here---------------------------------------------------\n   //------------------------------------------------------------------------------------------------------------\n\n   assign ldst_dual_dc3 = (lsu_addr_dc3[2] != end_addr_dc3[2]);\n   assign is_ldst_dc3 = lsu_pkt_dc3.valid & (lsu_pkt_dc3.load | lsu_pkt_dc3.store) & addr_in_dccm_dc3 & lsu_dccm_rden_dc3;\n   assign is_ldst_lo_dc3 = is_ldst_dc3 & ~(dec_tlu_core_ecc_disable | disable_ecc_check_lo_dc3);\n   assign is_ldst_hi_dc3 = is_ldst_dc3 & (ldst_dual_dc3 | lsu_pkt_dc3.dma) & ~(dec_tlu_core_ecc_disable | disable_ecc_check_hi_dc3);\n\n   assign ldst_byteen_dc3[7:0] = ({8{lsu_pkt_dc3.by}}   & 8'b0000_0001) |\n                                 ({8{lsu_pkt_dc3.half}} & 8'b0000_0011) |\n                                 ({8{lsu_pkt_dc3.word}} & 8'b0000_1111) |\n                                 ({8{lsu_pkt_dc3.dword}} & 8'b1111_1111);\n   assign store_byteen_dc3[7:0] = ldst_byteen_dc3[7:0] & {8{~lsu_pkt_dc3.load}};\n\n   assign store_byteen_ext_dc3[7:0] = store_byteen_dc3[7:0] << lsu_addr_dc3[1:0];\n   assign store_byteen_hi_dc3[pt.DCCM_BYTE_WIDTH-1:0] = store_byteen_ext_dc3[7:4];\n   assign store_byteen_lo_dc3[pt.DCCM_BYTE_WIDTH-1:0] = store_byteen_ext_dc3[3:0];\n\n   assign store_data_ext_dc3[55:0] = {24'b0,store_data_dc3[31:0]} << {lsu_addr_dc3[1:0], 3'b000};\n   assign store_data_hi_dc3[pt.DCCM_DATA_WIDTH-1:0]  = {8'b0,store_data_ext_dc3[55:32]};\n   assign store_data_lo_dc3[pt.DCCM_DATA_WIDTH-1:0]  = store_data_ext_dc3[31:0];\n\n\n   // Merge store data and sec data\n   // This is used for loads as well for ecc error case. store_byteen will be 0 for loads\n   for (genvar i=0; i<pt.DCCM_BYTE_WIDTH; i++) begin\n      assign store_ecc_data_hi_dc3[(8*i)+7:(8*i)] = store_byteen_hi_dc3[i]  ? store_data_hi_dc3[(8*i)+7:(8*i)] : ({8{addr_in_dccm_dc3}} & sec_data_hi_dc3[(8*i)+7:(8*i)]);\n      assign store_ecc_data_lo_dc3[(8*i)+7:(8*i)] = store_byteen_lo_dc3[i]  ? store_data_lo_dc3[(8*i)+7:(8*i)] : ({8{addr_in_dccm_dc3}} & sec_data_lo_dc3[(8*i)+7:(8*i)]);\n   end\n\n   assign dccm_wr_data_lo[pt.DCCM_DATA_WIDTH-1:0] = dma_dccm_spec_wen ? dma_dccm_wdata_lo[pt.DCCM_DATA_WIDTH-1:0] :\n                                                    (ld_single_ecc_error_dc5_ff ? (ld_single_ecc_error_lo_dc5_ff ? sec_data_lo_dc5_ff[pt.DCCM_DATA_WIDTH-1:0] : sec_data_hi_dc5_ff[pt.DCCM_DATA_WIDTH-1:0]) : stbuf_data_any[pt.DCCM_DATA_WIDTH-1:0]);\n   assign dccm_wr_data_hi[pt.DCCM_DATA_WIDTH-1:0] = dma_dccm_spec_wen ? dma_dccm_wdata_hi[pt.DCCM_DATA_WIDTH-1:0] :\n                                                    (ld_single_ecc_error_dc5_ff ? (ld_single_ecc_error_hi_dc5_ff ? sec_data_hi_dc5_ff[pt.DCCM_DATA_WIDTH-1:0] : sec_data_lo_dc5_ff[pt.DCCM_DATA_WIDTH-1:0]) : stbuf_data_any[pt.DCCM_DATA_WIDTH-1:0]);\n\n   assign dccm_wr_data_lo[pt.DCCM_FDATA_WIDTH-1:pt.DCCM_DATA_WIDTH] = dccm_wdata_ecc_lo_any[pt.DCCM_ECC_WIDTH-1:0];\n   assign dccm_wr_data_hi[pt.DCCM_FDATA_WIDTH-1:pt.DCCM_DATA_WIDTH] = dccm_wdata_ecc_hi_any[pt.DCCM_ECC_WIDTH-1:0];\n\n   if (pt.DCCM_ENABLE == 1) begin: Gen_dccm_enable\n      //Detect/Repair for Hi/Lo\n      rvecc_decode lsu_ecc_decode_hi (\n         // Inputs\n         .en(is_ldst_hi_dc3),\n         .sed_ded (1'b0),    // 1 : means only detection\n         .din(dccm_data_hi_dc3[pt.DCCM_DATA_WIDTH-1:0]),\n         .ecc_in(dccm_data_ecc_hi_dc3[pt.DCCM_ECC_WIDTH-1:0]),\n         // Outputs\n         .dout(sec_data_hi_dc3[pt.DCCM_DATA_WIDTH-1:0]),\n         .ecc_out (ecc_out_hi_nc[6:0]),\n         .single_ecc_error(single_ecc_error_hi_raw_dc3),\n         .double_ecc_error(double_ecc_error_hi_dc3),\n         .*\n      );\n\n      rvecc_decode lsu_ecc_decode_lo (\n         // Inputs\n         .en(is_ldst_lo_dc3),\n         .sed_ded (1'b0),    // 1 : means only detection\n         .din(dccm_data_lo_dc3[pt.DCCM_DATA_WIDTH-1:0] ),\n         .ecc_in(dccm_data_ecc_lo_dc3[pt.DCCM_ECC_WIDTH-1:0]),\n         // Outputs\n         .dout(sec_data_lo_dc3[pt.DCCM_DATA_WIDTH-1:0]),\n         .ecc_out (ecc_out_lo_nc[6:0]),\n         .single_ecc_error(single_ecc_error_lo_raw_dc3),\n         .double_ecc_error(double_ecc_error_lo_dc3),\n         .*\n      );\n\n      rvecc_encode lsu_ecc_encode_hi (\n         //Inputs\n         .din(dccm_wr_data_hi[pt.DCCM_DATA_WIDTH-1:0]),\n         //Outputs\n         .ecc_out(dccm_wdata_ecc_hi_any[pt.DCCM_ECC_WIDTH-1:0]),\n         .*\n      );\n      rvecc_encode lsu_ecc_encode_lo (\n         //Inputs\n         .din(dccm_wr_data_lo[pt.DCCM_DATA_WIDTH-1:0]),\n         //Outputs\n         .ecc_out(dccm_wdata_ecc_lo_any[pt.DCCM_ECC_WIDTH-1:0]),\n         .*\n      );\n\n      assign single_ecc_error_hi_dc3  = single_ecc_error_hi_raw_dc3 & ldst_dual_dc3 & ~(misaligned_fault_dc3 | access_fault_dc3);\n      assign single_ecc_error_lo_dc3  = single_ecc_error_lo_raw_dc3 & ~(misaligned_fault_dc3 | access_fault_dc3);\n      assign lsu_single_ecc_error_dc3 = single_ecc_error_hi_dc3 | single_ecc_error_lo_dc3;\n      assign lsu_double_ecc_error_dc3 = (double_ecc_error_hi_dc3 & ldst_dual_dc3) | double_ecc_error_lo_dc3;\n\n      rvdffe #(.WIDTH(pt.DCCM_DATA_WIDTH)) sec_data_hi_dc5plus1ff (.din(sec_data_hi_dc5[pt.DCCM_DATA_WIDTH-1:0]), .dout(sec_data_hi_dc5_ff[pt.DCCM_DATA_WIDTH-1:0]), .en(ld_single_ecc_error_dc5 | clk_override), .clk(clk), .*);\n      rvdffe #(.WIDTH(pt.DCCM_DATA_WIDTH)) sec_data_lo_dc5plus1ff (.din(sec_data_lo_dc5[pt.DCCM_DATA_WIDTH-1:0]), .dout(sec_data_lo_dc5_ff[pt.DCCM_DATA_WIDTH-1:0]), .en(ld_single_ecc_error_dc5 | clk_override), .clk(clk), .*);\n\n   end else begin: Gen_dccm_disable // block: Gen_dccm_enable\n      assign sec_data_hi_dc3[pt.DCCM_DATA_WIDTH-1:0] = '0;\n      assign sec_data_lo_dc3[pt.DCCM_DATA_WIDTH-1:0] = '0;\n      assign single_ecc_error_hi_dc3 = '0;\n      assign double_ecc_error_hi_dc3 = '0;\n      assign single_ecc_error_lo_dc3 = '0;\n      assign double_ecc_error_lo_dc3 = '0;\n      assign lsu_single_ecc_error_dc3 = '0;\n      assign lsu_double_ecc_error_dc3 = '0;\n      assign sec_data_lo_dc5_ff[pt.DCCM_DATA_WIDTH-1:0] = '0;\n      assign sec_data_hi_dc5_ff[pt.DCCM_DATA_WIDTH-1:0] = '0;\n\n   end\n\n\nendmodule // lsu_ecc\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: LSU control\n// Comments:\n//\n//\n// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n//\n//********************************************************************************\nmodule eh2_lsu_lsc_ctl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)(\n   input logic                   scan_mode,\n   input logic                   clk_override,\n   input logic                   rst_l,\n\n   input logic                   clk,\n   input logic                   lsu_c1_dc1_clk,\n   input logic                   lsu_c1_dc2_clk,\n   input logic                   lsu_c1_dc3_clk,\n   input logic                   lsu_c1_dc4_clk,\n   input logic                   lsu_c1_dc5_clk,\n\n   input logic                   lsu_c1_dc1_clken,       // clock\n   input logic                   lsu_c1_dc2_clken,       // clock\n   input logic                   lsu_c1_dc3_clken,\n   input logic                   lsu_c1_dc4_clken,\n   input logic                   lsu_c1_dc5_clken,\n\n   input logic                   lsu_c2_dc1_clk,       // clock\n   input logic                   lsu_c2_dc2_clk,       // clock\n   input logic                   lsu_c2_dc3_clk,\n   input logic                   lsu_c2_dc4_clk,\n   input logic                   lsu_c2_dc5_clk,\n\n   input logic                   lsu_free_c2_clk,\n\n   input logic                   lsu_store_c1_dc1_clk,\n   input logic                   lsu_store_c1_dc2_clk,\n   input logic                   lsu_store_c1_dc3_clk,\n\n   input logic [31:0]            i0_result_e4_eff,\n   input logic [31:0]            i1_result_e4_eff,\n   input logic [31:0]            i0_result_e2,\n   input logic [31:0]            exu_lsu_rs1_d, // address\n   input logic [31:0]            exu_lsu_rs2_d, // store data\n   input logic [11:0]            dec_lsu_offset_d,\n   input logic [31:0]            dec_tlu_mrac_ff,           // CSR read\n\n   input eh2_lsu_pkt_t          lsu_p,                     // lsu control packet\n   input logic                    ldst_dual_dc2, ldst_dual_dc3, ldst_dual_dc4, ldst_dual_dc5,\n   input logic                   lsu_single_ecc_error_dc3,\n   input logic                   lsu_double_ecc_error_dc3,\n   output logic                  access_fault_dc3,\n   output logic                  misaligned_fault_dc3,\n   output logic                  lsu_single_ecc_error_dc5,\n   output logic                  lsu_double_ecc_error_dc5,\n\n   input logic [pt.NUM_THREADS-1:0] flush_dc2_up,\n   input logic [pt.NUM_THREADS-1:0] flush_dc3,\n   input logic [pt.NUM_THREADS-1:0] flush_dc4,\n   input logic [pt.NUM_THREADS-1:0] flush_dc5,\n   input logic [pt.NUM_THREADS-1:0] dec_tlu_lr_reset_wb,\n\n   input  logic [31:0]           lsu_dccm_data_dc3,\n   input  logic [31:0]           lsu_dccm_data_corr_dc3,\n   input  logic [31:0]           picm_rd_data_dc3,\n   input  logic [31:0]           bus_read_data_dc3,\n   output logic [31:0]           lsu_result_dc3,\n   output logic [31:0]           lsu_result_corr_dc4,   // This is the ECC corrected data going to RF\n   output logic [31:0]           lsu_rs1_dc1,\n\n   // lsu address down the pipe\n   output logic [31:0]           lsu_addr_dc1,\n   output logic [31:0]           lsu_addr_dc2,\n   output logic [31:0]           lsu_addr_dc3,\n   output logic [31:0]           lsu_addr_dc4,\n   output logic [31:0]           lsu_addr_dc5,\n\n   output logic [31:0]           end_addr_dc1,\n   output logic [31:0]           end_addr_dc2,\n   output logic [31:0]           end_addr_dc3,\n   output logic [31:0]           end_addr_dc4,\n   output logic [31:0]           end_addr_dc5,\n\n   // store data down the pipe\n   output logic [31:0]           store_data_pre_dc3,\n\n   //output logic                  lsu_exc_dc2,\n   output logic                  lsu_single_ecc_error_incr,\n   output eh2_lsu_error_pkt_t   lsu_error_pkt_dc3,\n\n   output logic [31:1]           lsu_fir_addr,        // fast interrupt address\n   output logic [1:0]            lsu_fir_error,       // Error during fast interrupt lookup\n\n   output logic                  core_ldst_dual_dc1,\n   output logic                  is_sideeffects_dc2,\n   output logic                  is_sideeffects_dc3,\n   output logic                  lsu_commit_dc5,\n\n   // address in dccm/pic/external per pipe stage\n   output logic                  addr_in_dccm_region_dc1,     // address in dccm region\n   output logic                  addr_in_dccm_dc1,\n   output logic                  addr_in_dccm_dc2,\n   output logic                  addr_in_dccm_dc3,\n   output logic                  addr_in_dccm_dc4,\n   output logic                  addr_in_dccm_dc5,\n\n   output logic                  addr_in_pic_dc1,\n   output logic                  addr_in_pic_dc2,\n   output logic                  addr_in_pic_dc3,\n   output logic                  addr_in_pic_dc4,\n   output logic                  addr_in_pic_dc5,\n\n   output eh2_lsu_pkt_t         lsu_pkt_dc1_pre,\n   output eh2_lsu_pkt_t         lsu_pkt_dc1,\n   output eh2_lsu_pkt_t         lsu_pkt_dc2,\n   output eh2_lsu_pkt_t         lsu_pkt_dc3,\n   output eh2_lsu_pkt_t         lsu_pkt_dc4,\n   output eh2_lsu_pkt_t         lsu_pkt_dc5,\n\n   output logic                  addr_external_dc1,\n   output logic                  addr_external_dc3,\n   output logic                  lsu_sc_success_dc5,\n   output logic [pt.NUM_THREADS-1:0]            lr_vld,   // needed for clk gating\n\n   // DMA slave\n   input logic                   dma_dccm_req,\n   input logic [31:0]            dma_start_addr_dc1,\n   input logic [31:0]            dma_end_addr_dc1,\n   input logic [31:0]            dma_dccm_wdata_lo,   // This has both dccm/pic data\n   input logic [2:0]             dma_mem_sz,\n   input logic                   dma_mem_write,\n   input logic                   dma_mem_addr_in_dccm\n);\n\n   localparam THREADS          = pt.NUM_THREADS;\n\n   logic [31:3]        end_addr_pre_dc2, end_addr_pre_dc3, end_addr_pre_dc4, end_addr_pre_dc5;\n   logic [31:0]        core_start_addr_dc1;\n   logic [31:0]        core_end_addr_dc1;\n   logic [31:0]        lsu_rs1_d;\n   logic [11:0]        lsu_offset_d;\n   logic [31:0]        rs1_dc1;\n   logic [11:0]        offset_dc1;\n   logic [11:0]        lsu_offset_dc1;\n   logic [12:0]        end_addr_offset_dc1;\n   logic [31:0]        lsu_ld_datafn_dc3;\n   logic [31:0]        lsu_ld_datafn_corr_dc3;\n   logic [2:0]         addr_offset_dc1;\n\n   logic               ldst_dual_dc1;\n   logic               core_addr_in_dccm_dc1, core_addr_in_pic_dc1, core_addr_external_dc1;\n   logic               addr_external_dc2;\n   logic               access_fault_dc2, misaligned_fault_dc2;\n   logic [3:0]         exc_mscause_dc1, exc_mscause_dc2, exc_mscause_dc3;\n   logic               lsu_single_ecc_error_dc4;\n   logic               lsu_double_ecc_error_dc4;\n\n   logic [31:0]        store_data_d;\n   logic [31:0]        store_data_dc1;\n   logic [31:0]        store_data_pre_dc2;\n   logic [31:0]        store_data_dc2_in;\n   logic [31:0]        store_data_dc2;\n   logic [31:0]        rs1_dc1_raw;\n   logic [31:0]        offset32_dc1;\n\n   eh2_lsu_pkt_t      dma_pkt_dc1;\n   eh2_lsu_pkt_t      lsu_pkt_dc1_in, lsu_pkt_dc2_in, lsu_pkt_dc3_in, lsu_pkt_dc4_in, lsu_pkt_dc5_in;\n\n   logic               fir_dccm_access_error_dc2, fir_nondccm_access_error_dc2;\n   logic               fir_dccm_access_error_dc3, fir_nondccm_access_error_dc3;\n   logic [1:0]         lsu_fir_error_dc3;\n\n   logic [31:0]        lsu_result_corr_dc3;\n   logic [THREADS-1:0] lr_reset;   // set and reset logic\n\n\n   //------------------------------------------------------------------------------------------------------------\n   //----------------------------------------Logic starts here---------------------------------------------------\n   //------------------------------------------------------------------------------------------------------------\n\n   if (pt.LOAD_TO_USE_PLUS1 == 1) begin: GenL2U_1\n      assign lsu_rs1_d[31:0] = lsu_pkt_dc1_in.load_ldst_bypass_c1 ? lsu_result_dc3[31:0] :  exu_lsu_rs1_d[31:0];\n      assign rs1_dc1[31:0]   = rs1_dc1_raw[31:0];\n   end else begin: GenL2U_0\n      assign lsu_rs1_d[31:0] = exu_lsu_rs1_d[31:0];\n      assign rs1_dc1[31:0]   = (lsu_pkt_dc1_pre.load_ldst_bypass_c1) ? lsu_result_dc3[31:0] : rs1_dc1_raw[31:0];\n   end\n\n   assign lsu_rs1_dc1[31:0] = rs1_dc1[31:0];\n\n   // Premux the rs1/offset for dma\n   assign lsu_offset_dc1[11:0] = offset_dc1[11:0] & ~{12{lsu_pkt_dc1_pre.atomic}};\n\n   rvdff #(32) rs1ff    (.*, .din(lsu_rs1_d[31:0]),    .dout(rs1_dc1_raw[31:0]), .clk(lsu_c1_dc1_clk));\n   rvdff #(12) offsetff (.*, .din(dec_lsu_offset_d[11:0]), .dout(offset_dc1[11:0]),  .clk(lsu_c1_dc1_clk));\n\n    assign offset32_dc1[31:0] =  { {20{lsu_offset_dc1[11]}},lsu_offset_dc1[11:0]};\n\n   assign core_start_addr_dc1[31:0] =  rs1_dc1[31:0] + offset32_dc1[31:0];\n   assign core_end_addr_dc1[31:0]   = rs1_dc1[31:0] + {{19{end_addr_offset_dc1[12]}},end_addr_offset_dc1[12:0]};\n\n\n   // Module to generate the memory map of the address\n   eh2_lsu_addrcheck #(.pt(pt)) addrcheck (\n                  .start_addr_dc1(core_start_addr_dc1[31:0]),\n                  .end_addr_dc1(core_end_addr_dc1[31:0]),\n                  .start_addr_dc2(lsu_addr_dc2[31:0]),\n                  .end_addr_dc2(end_addr_dc2[31:0]),\n                  .addr_in_dccm_dc1(core_addr_in_dccm_dc1),\n                  .addr_in_pic_dc1(core_addr_in_pic_dc1),\n                  .addr_external_dc1(core_addr_external_dc1),\n                  .*\n  );\n\n   // Calculate start/end address for load/store\n   assign addr_offset_dc1[2:0]      = ({3{lsu_pkt_dc1_pre.half}} & 3'b01) | ({3{lsu_pkt_dc1_pre.word}} & 3'b11) | ({3{lsu_pkt_dc1_pre.dword}} & 3'b111);\n   assign end_addr_offset_dc1[12:0] = {lsu_offset_dc1[11],lsu_offset_dc1[11:0]} + {9'b0,addr_offset_dc1[2:0]};\n   assign end_addr_dc1[31:0]        = lsu_pkt_dc1_pre.valid ? core_end_addr_dc1[31:0] : dma_end_addr_dc1[31:0];\n   assign lsu_addr_dc1[31:0]        = lsu_pkt_dc1_pre.valid ? core_start_addr_dc1[31:0] : dma_start_addr_dc1[31:0];   // absence load/store all 0's\n\n   assign addr_in_dccm_dc1 = lsu_pkt_dc1_pre.valid ? core_addr_in_dccm_dc1 : dma_mem_addr_in_dccm;\n   assign addr_in_pic_dc1  = lsu_pkt_dc1_pre.valid ? core_addr_in_pic_dc1 : ~dma_mem_addr_in_dccm;\n   assign addr_external_dc1 = lsu_pkt_dc1_pre.valid & core_addr_external_dc1;\n   assign core_ldst_dual_dc1 = core_start_addr_dc1[2] != core_end_addr_dc1[2];\n   assign ldst_dual_dc1   = lsu_addr_dc1[2] != end_addr_dc1[2];\n\n   // Goes to TLU to increment the ECC error counter\n   assign lsu_single_ecc_error_incr = (lsu_single_ecc_error_dc5 & ~lsu_double_ecc_error_dc5) & (lsu_commit_dc5 | lsu_pkt_dc5.dma) & lsu_pkt_dc5.valid;\n\n   // Generate exception packet\n   assign lsu_error_pkt_dc3.exc_valid = (access_fault_dc3 | misaligned_fault_dc3 | lsu_double_ecc_error_dc3) & lsu_pkt_dc3.valid & ~lsu_pkt_dc3.dma & ~flush_dc3[lsu_pkt_dc3.tid] & ~lsu_pkt_dc3.fast_int;\n   assign lsu_error_pkt_dc3.single_ecc_error = lsu_single_ecc_error_dc3 & ~lsu_error_pkt_dc3.exc_valid & ~lsu_pkt_dc3.dma & ~lsu_pkt_dc3.fast_int;   // This is used for rfnpc. Suppress single bit error if there is a fault/dma/fastint\n   assign lsu_error_pkt_dc3.inst_type = lsu_pkt_dc3.store;   // AMO should be store\n   assign lsu_error_pkt_dc3.amo_valid = lsu_pkt_dc3.atomic & ~(lsu_pkt_dc3.lr | lsu_pkt_dc3.sc);\n   assign lsu_error_pkt_dc3.exc_type  = ~misaligned_fault_dc3;\n   assign lsu_error_pkt_dc3.mscause[3:0] = (lsu_double_ecc_error_dc3 & ~misaligned_fault_dc3 & ~access_fault_dc3) ? 4'h1 : exc_mscause_dc3[3:0];\n   assign lsu_error_pkt_dc3.addr[31:0] = lsu_addr_dc3[31:0] & {32{lsu_error_pkt_dc3.exc_valid | lsu_error_pkt_dc3.single_ecc_error}};\n\n   //Create DMA packet\n   always_comb begin\n      dma_pkt_dc1 = '0;\n      dma_pkt_dc1.valid   = dma_dccm_req;\n      dma_pkt_dc1.dma     = 1'b1;\n      dma_pkt_dc1.store   = dma_mem_write;\n      dma_pkt_dc1.load    = ~dma_mem_write;\n      dma_pkt_dc1.by      = (dma_mem_sz[2:0] == 3'b0);\n      dma_pkt_dc1.half    = (dma_mem_sz[2:0] == 3'b1);\n      dma_pkt_dc1.word    = (dma_mem_sz[2:0] == 3'b10);\n      dma_pkt_dc1.dword   = (dma_mem_sz[2:0] == 3'b11);\n   end\n\n   always_comb begin\n      lsu_pkt_dc1_in = lsu_p;\n      lsu_pkt_dc1    = dma_dccm_req ? dma_pkt_dc1 : lsu_pkt_dc1_pre;\n      lsu_pkt_dc2_in = lsu_pkt_dc1;\n      lsu_pkt_dc3_in = lsu_pkt_dc2;\n      lsu_pkt_dc4_in = lsu_pkt_dc3;\n      lsu_pkt_dc5_in = lsu_pkt_dc4;\n\n      lsu_pkt_dc1_in.valid = lsu_p.valid & ~(flush_dc2_up[lsu_p.tid] & ~lsu_p.fast_int);\n      lsu_pkt_dc2_in.valid = (lsu_pkt_dc1.valid & ~flush_dc2_up[lsu_pkt_dc1.tid]) | dma_dccm_req;\n      lsu_pkt_dc3_in.valid = lsu_pkt_dc2.valid & ~(flush_dc2_up[lsu_pkt_dc2.tid] & ~lsu_pkt_dc2.dma);\n      lsu_pkt_dc4_in.valid = lsu_pkt_dc3.valid & ~(flush_dc3[lsu_pkt_dc3.tid] & ~lsu_pkt_dc3.dma);\n      lsu_pkt_dc5_in.valid = lsu_pkt_dc4.valid & ~(flush_dc4[lsu_pkt_dc4.tid] & ~lsu_pkt_dc4.dma);\n   end\n\n   assign lsu_ld_datafn_dc3[31:0] = ({32{addr_external_dc3}} & bus_read_data_dc3) |\n                                    ({32{addr_in_pic_dc3}}   & picm_rd_data_dc3)  |\n                                    ({32{addr_in_dccm_dc3}}  & lsu_dccm_data_dc3);\n\n   assign lsu_ld_datafn_corr_dc3[31:0] = ({32{addr_external_dc3}} & bus_read_data_dc3) |\n                                         ({32{addr_in_pic_dc3}}   & picm_rd_data_dc3)  |\n                                         ({32{addr_in_dccm_dc3}}  & lsu_dccm_data_corr_dc3);\n\n   // this result must look at prior stores and merge them in. Qualified with valid for power\n   assign lsu_result_dc3[31:0] = ({32{lsu_pkt_dc3.valid & lsu_pkt_dc3.load &  lsu_pkt_dc3.unsign & lsu_pkt_dc3.by  }} & {24'b0,lsu_ld_datafn_dc3[7:0]}) |\n                                 ({32{lsu_pkt_dc3.valid & lsu_pkt_dc3.load &  lsu_pkt_dc3.unsign & lsu_pkt_dc3.half}} & {16'b0,lsu_ld_datafn_dc3[15:0]}) |\n                                 ({32{lsu_pkt_dc3.valid & lsu_pkt_dc3.load & ~lsu_pkt_dc3.unsign & lsu_pkt_dc3.by  }} & {{24{  lsu_ld_datafn_dc3[7]}}, lsu_ld_datafn_dc3[7:0]}) |\n                                 ({32{lsu_pkt_dc3.valid & lsu_pkt_dc3.load & ~lsu_pkt_dc3.unsign & lsu_pkt_dc3.half}} & {{16{  lsu_ld_datafn_dc3[15]}},lsu_ld_datafn_dc3[15:0]}) |\n                                 ({32{lsu_pkt_dc3.valid & lsu_pkt_dc3.load & lsu_pkt_dc3.word}} &                       lsu_ld_datafn_dc3[31:0]);\n\n   assign lsu_result_corr_dc3[31:0] = ({32{ lsu_pkt_dc3.unsign & lsu_pkt_dc3.by  }} & {24'b0,lsu_ld_datafn_corr_dc3[7:0]}) |\n                                      ({32{ lsu_pkt_dc3.unsign & lsu_pkt_dc3.half}} & {16'b0,lsu_ld_datafn_corr_dc3[15:0]}) |\n                                      ({32{~lsu_pkt_dc3.unsign & lsu_pkt_dc3.by  }} & {{24{  lsu_ld_datafn_corr_dc3[7]}}, lsu_ld_datafn_corr_dc3[7:0]}) |\n                                      ({32{~lsu_pkt_dc3.unsign & lsu_pkt_dc3.half}} & {{16{  lsu_ld_datafn_corr_dc3[15]}},lsu_ld_datafn_corr_dc3[15:0]}) |\n                                      ({32{lsu_pkt_dc3.word}} &                       lsu_ld_datafn_corr_dc3[31:0]);\n\n   assign lsu_fir_addr[31:1]     = lsu_result_corr_dc4[31:1] & {31{lsu_pkt_dc4.valid & lsu_pkt_dc4.fast_int}};\n   assign lsu_fir_error_dc3[1:0] = fir_nondccm_access_error_dc3 ? 2'b11 : (fir_dccm_access_error_dc3 ? 2'b10 : ((lsu_pkt_dc3.fast_int & lsu_double_ecc_error_dc3) ? 2'b01 : 2'b00));\n\n   // Interrupt as a flush source allows the WB to occur\n   assign lsu_commit_dc5 = lsu_pkt_dc5.valid & (lsu_pkt_dc5.store | lsu_pkt_dc5.load | lsu_pkt_dc5.atomic) & ~flush_dc5[lsu_pkt_dc5.tid] & ~lsu_pkt_dc5.dma;\n\n   assign store_data_d[31:0] = exu_lsu_rs2_d[31:0];\n\n   //assign store_data_dc2_in[63:32] = store_data_dc1[63:32];\n   assign store_data_dc2_in[31:0] = dma_dccm_req ? dma_dccm_wdata_lo[31:0] :                      // PIC writes from DMA still happens in dc5 since we need to read mask\n                                    (lsu_pkt_dc1.store_data_bypass_c1) ? lsu_result_dc3[31:0] :\n                                    (lsu_pkt_dc1.store_data_bypass_e4_c1[1]) ? i1_result_e4_eff[31:0] :\n                                    (lsu_pkt_dc1.store_data_bypass_e4_c1[0]) ? i0_result_e4_eff[31:0] : store_data_dc1[31:0];\n\n   //assign store_data_dc2[63:32] = store_data_pre_dc2[63:32];\n   assign store_data_dc2[31:0] = (lsu_pkt_dc2.store_data_bypass_i0_e2_c2) ? i0_result_e2[31:0]     :\n                                 (lsu_pkt_dc2.store_data_bypass_c2)       ? lsu_result_dc3[31:0]   :\n                                 (lsu_pkt_dc2.store_data_bypass_e4_c2[1]) ? i1_result_e4_eff[31:0] :\n                                 (lsu_pkt_dc2.store_data_bypass_e4_c2[0]) ? i0_result_e4_eff[31:0] : store_data_pre_dc2[31:0];\n\n\n   // Flops\n   rvdffe #(32) lsu_result_corr_dc4ff (.*, .din(lsu_result_corr_dc3[31:0]), .dout(lsu_result_corr_dc4[31:0]), .en((lsu_pkt_dc3.valid & lsu_pkt_dc3.load) | clk_override));\n\n   // C2 clock for valid and C1 for other bits of packet\n   rvdff #(1) lsu_pkt_vlddc1ff (.*, .din(lsu_pkt_dc1_in.valid), .dout(lsu_pkt_dc1_pre.valid), .clk(lsu_c2_dc1_clk));\n   rvdff #(1) lsu_pkt_vlddc2ff (.*, .din(lsu_pkt_dc2_in.valid), .dout(lsu_pkt_dc2.valid), .clk(lsu_c2_dc2_clk));\n   rvdff #(1) lsu_pkt_vlddc3ff (.*, .din(lsu_pkt_dc3_in.valid), .dout(lsu_pkt_dc3.valid), .clk(lsu_c2_dc3_clk));\n   rvdff #(1) lsu_pkt_vlddc4ff (.*, .din(lsu_pkt_dc4_in.valid), .dout(lsu_pkt_dc4.valid), .clk(lsu_c2_dc4_clk));\n   rvdff #(1) lsu_pkt_vlddc5ff (.*, .din(lsu_pkt_dc5_in.valid), .dout(lsu_pkt_dc5.valid), .clk(lsu_c2_dc5_clk));\n\n   rvdfflie #(.WIDTH($bits(eh2_lsu_pkt_t)-1),.LEFT(12)) lsu_pkt_dc1ff (.*, .din(lsu_pkt_dc1_in[$bits(eh2_lsu_pkt_t)-1:1]), .dout(lsu_pkt_dc1_pre[$bits(eh2_lsu_pkt_t)-1:1]), .en(lsu_c1_dc1_clken));\n   rvdfflie #(.WIDTH($bits(eh2_lsu_pkt_t)-1),.LEFT(12)) lsu_pkt_dc2ff (.*, .din(lsu_pkt_dc2_in[$bits(eh2_lsu_pkt_t)-1:1]), .dout(lsu_pkt_dc2[$bits(eh2_lsu_pkt_t)-1:1]),     .en(lsu_c1_dc2_clken));\n   rvdfflie #(.WIDTH($bits(eh2_lsu_pkt_t)-1),.LEFT(12)) lsu_pkt_dc3ff (.*, .din(lsu_pkt_dc3_in[$bits(eh2_lsu_pkt_t)-1:1]), .dout(lsu_pkt_dc3[$bits(eh2_lsu_pkt_t)-1:1]),     .en(lsu_c1_dc3_clken));\n   rvdfflie #(.WIDTH($bits(eh2_lsu_pkt_t)-1),.LEFT(12)) lsu_pkt_dc4ff (.*, .din(lsu_pkt_dc4_in[$bits(eh2_lsu_pkt_t)-1:1]), .dout(lsu_pkt_dc4[$bits(eh2_lsu_pkt_t)-1:1]),     .en(lsu_c1_dc4_clken));\n   rvdfflie #(.WIDTH($bits(eh2_lsu_pkt_t)-1),.LEFT(12)) lsu_pkt_dc5ff (.*, .din(lsu_pkt_dc5_in[$bits(eh2_lsu_pkt_t)-1:1]), .dout(lsu_pkt_dc5[$bits(eh2_lsu_pkt_t)-1:1]),     .en(lsu_c1_dc5_clken));\n\n   rvdff #(32) sddc1ff (.*, .din(store_data_d[31:0]),      .dout(store_data_dc1[31:0]),     .clk(lsu_store_c1_dc1_clk));\n   rvdff #(32) sddc2ff (.*, .din(store_data_dc2_in[31:0]), .dout(store_data_pre_dc2[31:0]), .clk(lsu_store_c1_dc2_clk));\n   rvdff #(32) sddc3ff (.*, .din(store_data_dc2[31:0]),    .dout(store_data_pre_dc3[31:0]), .clk(lsu_store_c1_dc3_clk));\n\n   rvdff #(32) sadc2ff  (.*, .din(lsu_addr_dc1[31:0]),      .dout(lsu_addr_dc2[31:0]),       .clk(lsu_c1_dc2_clk));\n   rvdff #(32) sadc3ff  (.*, .din(lsu_addr_dc2[31:0]),      .dout(lsu_addr_dc3[31:0]),       .clk(lsu_c1_dc3_clk));\n   rvdff #(32) sadc4ff  (.*, .din(lsu_addr_dc3[31:0]),      .dout(lsu_addr_dc4[31:0]),       .clk(lsu_c1_dc4_clk));\n   rvdff #(32) sadc5ff  (.*, .din(lsu_addr_dc4[31:0]),      .dout(lsu_addr_dc5[31:0]),       .clk(lsu_c1_dc5_clk));\n\n   assign end_addr_dc2[31:3] = ldst_dual_dc2 ? end_addr_pre_dc2[31:3] : lsu_addr_dc2[31:3];       // This is for power "}
{"text": "saving\n   assign end_addr_dc3[31:3] = ldst_dual_dc3 ? end_addr_pre_dc3[31:3] : lsu_addr_dc3[31:3];       // This is for power saving\n   assign end_addr_dc4[31:3] = ldst_dual_dc4 ? end_addr_pre_dc4[31:3] : lsu_addr_dc4[31:3];       // This is for power saving\n   assign end_addr_dc5[31:3] = ldst_dual_dc5 ? end_addr_pre_dc5[31:3] : lsu_addr_dc5[31:3];       // This is for power saving\n\n   rvdffe #(29) end_addr_hi_dc2ff (.*, .din(end_addr_dc1[31:3]),    .dout(end_addr_pre_dc2[31:3]), .en(lsu_pkt_dc1.valid & ldst_dual_dc1));\n   rvdffe #(29) end_addr_hi_dc3ff (.*, .din(end_addr_dc2[31:3]),    .dout(end_addr_pre_dc3[31:3]), .en(lsu_pkt_dc2.valid & ldst_dual_dc2));\n   rvdffe #(29) end_addr_hi_dc4ff (.*, .din(end_addr_dc3[31:3]),    .dout(end_addr_pre_dc4[31:3]), .en(lsu_pkt_dc3.valid & ldst_dual_dc3));\n   rvdffe #(29) end_addr_hi_dc5ff (.*, .din(end_addr_dc4[31:3]),    .dout(end_addr_pre_dc5[31:3]), .en(lsu_pkt_dc4.valid & ldst_dual_dc4));\n\n   rvdff #(3) end_addr_lo_dc2ff (.*, .din(end_addr_dc1[2:0]),    .dout(end_addr_dc2[2:0]), .clk(lsu_c1_dc2_clk));\n   rvdff #(3) end_addr_lo_dc3ff (.*, .din(end_addr_dc2[2:0]),    .dout(end_addr_dc3[2:0]), .clk(lsu_c1_dc3_clk));\n   rvdff #(3) end_addr_lo_dc4ff (.*, .din(end_addr_dc3[2:0]),    .dout(end_addr_dc4[2:0]), .clk(lsu_c1_dc4_clk));\n   rvdff #(3) end_addr_lo_dc5ff (.*, .din(end_addr_dc4[2:0]),    .dout(end_addr_dc5[2:0]), .clk(lsu_c1_dc5_clk));\n\n   rvdff #(1) addr_in_dccm_dc2ff(.din(addr_in_dccm_dc1), .dout(addr_in_dccm_dc2), .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(1) addr_in_dccm_dc3ff(.din(addr_in_dccm_dc2), .dout(addr_in_dccm_dc3), .clk(lsu_c2_dc3_clk), .*);\n   rvdff #(1) addr_in_dccm_dc4ff(.din(addr_in_dccm_dc3), .dout(addr_in_dccm_dc4), .clk(lsu_c2_dc4_clk), .*);\n   rvdff #(1) addr_in_dccm_dc5ff(.din(addr_in_dccm_dc4), .dout(addr_in_dccm_dc5), .clk(lsu_c2_dc5_clk), .*);\n\n   rvdff #(1) addr_in_pic_dc2ff(.din(addr_in_pic_dc1), .dout(addr_in_pic_dc2), .clk(lsu_c2_dc2_clk), .*);\n   rvdff #(1) addr_in_pic_dc3ff(.din(addr_in_pic_dc2), .dout(addr_in_pic_dc3), .clk(lsu_c2_dc3_clk), .*);\n   rvdff #(1) addr_in_pic_dc4ff(.din(addr_in_pic_dc3), .dout(addr_in_pic_dc4), .clk(lsu_c2_dc4_clk), .*);\n   rvdff #(1) addr_in_pic_dc5ff(.din(addr_in_pic_dc4), .dout(addr_in_pic_dc5), .clk(lsu_c2_dc5_clk), .*);\n\n   rvdff #(1) addr_external_dc3ff(.din(addr_external_dc2), .dout(addr_external_dc3), .clk(lsu_c2_dc3_clk), .*);\n\n   rvdff #(1) access_fault_dc3ff     (.din(access_fault_dc2),     .dout(access_fault_dc3),     .clk(lsu_c2_dc3_clk), .*);\n   rvdff #(1) misaligned_fault_dc3ff (.din(misaligned_fault_dc2), .dout(misaligned_fault_dc3), .clk(lsu_c2_dc3_clk), .*);\n   rvdff #(4) exc_mscause_dc3ff      (.din(exc_mscause_dc2[3:0]), .dout(exc_mscause_dc3[3:0]), .clk(lsu_c2_dc3_clk), .*);\n\n   rvdff #(1) lsu_single_ecc_error_dc4ff (.*, .din(lsu_single_ecc_error_dc3), .dout(lsu_single_ecc_error_dc4), .clk(lsu_c2_dc4_clk));\n   rvdff #(1) lsu_single_ecc_error_dc5ff (.*, .din(lsu_single_ecc_error_dc4), .dout(lsu_single_ecc_error_dc5), .clk(lsu_c2_dc5_clk));\n   rvdff #(1) lsu_double_ecc_error_dc4ff (.*, .din(lsu_double_ecc_error_dc3), .dout(lsu_double_ecc_error_dc4), .clk(lsu_c2_dc4_clk));\n   rvdff #(1) lsu_double_ecc_error_dc5ff (.*, .din(lsu_double_ecc_error_dc4), .dout(lsu_double_ecc_error_dc5), .clk(lsu_c2_dc5_clk));\n\n   rvdff #(1) fir_dccm_access_error_dc3ff    (.din(fir_dccm_access_error_dc2),    .dout(fir_dccm_access_error_dc3),    .clk(lsu_c2_dc3_clk), .*);\n   rvdff #(1) fir_nondccm_access_error_dc3ff (.din(fir_nondccm_access_error_dc2), .dout(fir_nondccm_access_error_dc3), .clk(lsu_c2_dc3_clk), .*);\n   rvdff #(2) fir_error_dc4ff                (.din(lsu_fir_error_dc3[1:0]),       .dout(lsu_fir_error[1:0]),           .clk(lsu_c2_dc4_clk), .*);\n\n   // Load Reservation\n   // when the LR commits - it will set a valid and its address [31:2] for its own thread's LR\n   // the Reset conditions are :\n   // Same Thread : 1) Any Store Conditional - match or not is not relevant\n   //               2) Entering Debug,\n   //               3) Leaving Debug,\n   //               4) Mret, Interrup or Exception\n   //\n   // Other Thread :1) Store or AMO to this location ( 31:2 match )\n   if (pt.ATOMIC_ENABLE == 1) begin: GenAtomic\n      logic [THREADS-1:0] [31:2] lr_addr;   // Per Thread LR stations\n      logic [THREADS-1:0]        lr_wr_en;   // set and reset logic\n      logic                      tid_dc5;\n      logic [THREADS-1:0]        lsu_sc_success_vec_dc5;\n\n      assign tid_dc5 = lsu_pkt_dc5.tid;\n      always_comb  begin : store_cond\n        lsu_sc_success_vec_dc5[THREADS-1:0] = '0;\n        for (int i=0; i < THREADS; i++ ) begin\n        lsu_sc_success_vec_dc5[i] = (i == tid_dc5) & (lsu_addr_dc5[31:2] == lr_addr[i][31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.sc & lr_vld[i];\n        end\n      end : store_cond\n\n      assign lsu_sc_success_dc5 = |lsu_sc_success_vec_dc5[THREADS-1:0];\n\n      for (genvar i=0; i<THREADS; i++) begin\n         assign lr_wr_en[i] =  ( i == tid_dc5 )  & lsu_commit_dc5 & lsu_pkt_dc5.lr;\n         assign lr_reset[i] =  (( i == tid_dc5 ) & (lsu_commit_dc5 & lsu_pkt_dc5.sc))                                               |        // same thread cases. One signal from tlu covers the non-lsu cases\n                               (i != tid_dc5     & (lsu_commit_dc5 & lsu_pkt_dc5.store & (~lsu_pkt_dc5.sc | lsu_sc_success_dc5) & ((lsu_addr_dc5[31:2] == lr_addr[i][31:2]) | (end_addr_dc5[31:2] == lr_addr[i][31:2])))) |        // other thread case - any update to this location\n                               dec_tlu_lr_reset_wb[i]                                                                               |        // Reset from dec\n                               (lsu_pkt_dc5.valid & lsu_pkt_dc5.dma  & lsu_pkt_dc5.store & (lsu_addr_dc5[31:3] == lr_addr[i][31:3]) & (lsu_pkt_dc5.dword | (lsu_addr_dc5[2] == lr_addr[i][2])));  // DMA store case\n         rvdffsc #(.WIDTH(1))  lr_vldff   (.din(1'b1),               .dout(lr_vld[i]),  .en(lr_wr_en[i]), .clear(lr_reset[i]), .clk(lsu_free_c2_clk), .*);\n         rvdffe  #(.WIDTH(30)) lr_address (.din(lsu_addr_dc5[31:2]), .dout(lr_addr[i]), .en(lr_wr_en[i]),                                             .*);\n      end\n   end // block: GenAtomic\n   else begin: GenNoAtomic\n      assign lsu_sc_success_dc5 = 1'b0;\n      assign lr_vld[pt.NUM_THREADS-1:0] = '0;\n   end\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n// $Id$\n//\n// Owner:\n// Function: Store Buffer\n// Comments: Dual writes and single drain\n//\n// DC1 -> DC2 -> DC3 -> DC4 (Commit)\n//\n// //********************************************************************************\nmodule eh2_lsu_stbuf\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n(\n   input logic                          clk,                                // core clock\n   input logic                          rst_l,                              // reset\n   input logic                          clk_override,\n   input  logic                         scan_mode,\n\n   input logic                          lsu_c1_dc3_clk,                     // lsu pipe clock\n\n   input logic                          lsu_stbuf_c1_clk,                   // stbuf clock\n   input logic                          lsu_free_c2_clk,                    // free clk\n\n   // Store Buffer input\n   input logic                          store_stbuf_reqvld_dc5,             // core instruction goes to stbuf\n   input logic                          core_ldst_dual_dc1,                 // core ld/st is dual\n   input logic                          ldst_dual_dc2, ldst_dual_dc3, ldst_dual_dc4, ldst_dual_dc5,\n   input logic                          addr_in_dccm_dc2,                   // address is in dccm\n   input logic                          addr_in_dccm_dc3,                   // address is in dccm\n   input logic                          addr_in_dccm_dc4,                   // address is in dccm\n   input logic                          addr_in_dccm_dc5,                   // address is in dccm\n   input logic                          addr_in_pic_dc2,                    // address in pic\n   input logic [pt.DCCM_DATA_WIDTH-1:0] dccm_datafn_hi_dc5,                 // data from the dccm\n   input logic [pt.DCCM_DATA_WIDTH-1:0] dccm_datafn_lo_dc5,                 // data from the dccm\n   input logic [63:0]                   store_data_ext_dc3, store_data_ext_dc4, store_data_ext_dc5,   // goes to the stbuf for load-store fwdding\n\n   input logic                          lsu_commit_dc5,                     // lsu commits\n\n   // Store Buffer output\n   output logic                          stbuf_reqvld_any,                  // stbuf is draining\n   output logic                          stbuf_reqvld_flushed_any,          // stbuf is flushed\n   output logic [pt.LSU_SB_BITS-1:0]     stbuf_addr_any,                    // address\n   output logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_data_any,                    // stbuf data\n\n   input  logic                          lsu_stbuf_commit_any,              // pop the stbuf as it commite\n   output logic [pt.NUM_THREADS-1:0]     lsu_stbuf_empty_any,               // stbuf is empty\n   output logic [pt.NUM_THREADS-1:0]     lsu_stbuf_full_any,                // stbuf is full\n\n   input logic [pt.LSU_SB_BITS-1:0]      lsu_addr_dc1,                      // lsu address\n   input logic [31:0]                    lsu_addr_dc2,\n   input logic [31:0]                    lsu_addr_dc3,\n   input logic [31:0]                    lsu_addr_dc4,\n   input logic [31:0]                    lsu_addr_dc5,\n\n   input logic [pt.LSU_SB_BITS-1:0]      end_addr_dc1,                      // lsu end addrress - needed to check unaligned\n   input logic [31:0]                    end_addr_dc2,\n   input logic [31:0]                    end_addr_dc3,\n   input logic [31:0]                    end_addr_dc4,\n   input logic [31:0]                    end_addr_dc5,\n\n   // Forwarding signals\n   input logic                           lsu_cmpen_dc2,                       // needed for forwarding stbuf - load\n   input eh2_lsu_pkt_t                  lsu_pkt_dc1_pre,\n   input eh2_lsu_pkt_t                  lsu_pkt_dc2,\n   input eh2_lsu_pkt_t                  lsu_pkt_dc3,\n   input eh2_lsu_pkt_t                  lsu_pkt_dc4,\n   input eh2_lsu_pkt_t                  lsu_pkt_dc5,\n\n   output logic                          picm_fwd_en_dc2,\n   output logic [31:0]                   picm_fwd_data_dc2,\n\n   output logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_fwddata_hi_dc3,     // stbuf data\n   output logic [pt.DCCM_DATA_WIDTH-1:0] stbuf_fwddata_lo_dc3,\n   output logic [pt.DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_hi_dc3,\n   output logic [pt.DCCM_BYTE_WIDTH-1:0] stbuf_fwdbyteen_lo_dc3\n\n);\n\n   localparam DEPTH      = pt.LSU_STBUF_DEPTH;\n   localparam DATA_WIDTH = pt.DCCM_DATA_WIDTH;\n   localparam BYTE_WIDTH = pt.DCCM_BYTE_WIDTH;\n   localparam DEPTH_LOG2 = $clog2(DEPTH);\n\n   // These are the fields in the store queue\n   logic [DEPTH-1:0]                     stbuf_vld;\n   logic [DEPTH-1:0]                     stbuf_dma_kill;\n   logic [DEPTH-1:0][pt.LSU_SB_BITS-1:0] stbuf_addr;\n   logic [DEPTH-1:0][BYTE_WIDTH-1:0]     stbuf_byteen;\n   logic [DEPTH-1:0][DATA_WIDTH-1:0]     stbuf_data;\n   logic [DEPTH-1:0]                     stbuf_tid;\n\n   logic [DEPTH-1:0]                     sel_lo;\n   logic [DEPTH-1:0]                     stbuf_wr_en;\n   logic [DEPTH-1:0]                     stbuf_dma_kill_en;\n   logic [DEPTH-1:0]                     stbuf_reset;\n   logic [DEPTH-1:0][pt.LSU_SB_BITS-1:0] stbuf_addrin;\n   logic [DEPTH-1:0][DATA_WIDTH-1:0]     stbuf_datain;\n   logic [DEPTH-1:0][BYTE_WIDTH-1:0]     stbuf_byteenin;\n\n   logic [7:0]                        store_byteen_ext_dc5;\n   logic [BYTE_WIDTH-1:0]             store_byteen_hi_dc5;\n   logic [BYTE_WIDTH-1:0]             store_byteen_lo_dc5;\n\n   logic                              WrPtrEn, RdPtrEn;\n   logic [DEPTH_LOG2-1:0]             WrPtr, RdPtr;\n   logic [DEPTH_LOG2-1:0]             NxtWrPtr, NxtRdPtr;\n   logic [DEPTH_LOG2-1:0]             WrPtrPlus1, WrPtrPlus2, RdPtrPlus1;\n   logic                              ldst_dual_dc1;\n   logic                              isst_nodma_dc1;\n   logic                              dccm_st_nodma_dc2, dccm_st_nodma_dc3, dccm_st_nodma_dc4, dccm_st_nodma_dc5;\n\n   logic [3:0]                        stbuf_total_specvld_any;\n   logic [pt.NUM_THREADS-1:0][3:0]    stbuf_numvld_any, stbuf_specvld_any, stbuf_specvld_anyQ, stbuf_tidvld_any;\n   logic [pt.NUM_THREADS-1:0][1:0]    stbuf_specvld_dc1, stbuf_specvld_dc2, stbuf_specvld_dc3, stbuf_specvld_dc4, stbuf_specvld_dc5;\n\n   logic                              cmpen_hi_dc2, cmpen_lo_dc2;\n\n   logic [pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]  cmpaddr_hi_dc2, cmpaddr_lo_dc2;\n\n   logic                              stbuf_fwddata_lo_en, stbuf_fwddata_hi_en;\n   // variables to detect matching from the store queue\n   logic [DEPTH-1:0]                  stbuf_match_hi, stbuf_match_lo;\n   logic [DEPTH-1:0][BYTE_WIDTH-1:0]  stbuf_fwdbyteenvec_hi, stbuf_fwdbyteenvec_lo;\n   logic [DEPTH-1:0][DATA_WIDTH-1:0]  stbuf_fwddatavec_hi, stbuf_fwddatavec_lo;\n   logic [DATA_WIDTH-1:0]             stbuf_fwddata_hi_dc2, stbuf_fwddata_lo_dc2;\n   logic [DATA_WIDTH-1:0]             stbuf_fwddata_hi_fn_dc2, stbuf_fwddata_lo_fn_dc2;\n   logic [BYTE_WIDTH-1:0]             stbuf_fwdbyteen_hi_dc2, stbuf_fwdbyteen_lo_dc2;\n   logic [BYTE_WIDTH-1:0]             stbuf_fwdbyteen_hi_fn_dc2, stbuf_fwdbyteen_lo_fn_dc2;\n   // logic to detect matching from the pipe - needed for store - load forwarding\n   logic [BYTE_WIDTH-1:0]             ld_byte_dc3hit_lo_lo, ld_byte_dc3hit_hi_lo, ld_byte_dc3hit_lo_hi, ld_byte_dc3hit_hi_hi;\n   logic [BYTE_WIDTH-1:0]             ld_byte_dc4hit_lo_lo, ld_byte_dc4hit_hi_lo, ld_byte_dc4hit_lo_hi, ld_byte_dc4hit_hi_hi;\n   logic [BYTE_WIDTH-1:0]             ld_byte_dc5hit_lo_lo, ld_byte_dc5hit_hi_lo, ld_byte_dc5hit_lo_hi, ld_byte_dc5hit_hi_hi;\n\n   logic [BYTE_WIDTH-1:0]             ld_byte_hit_lo, ld_byte_dc3hit_lo, ld_byte_dc4hit_lo, ld_byte_dc5hit_lo;\n   logic [BYTE_WIDTH-1:0]             ld_byte_hit_hi, ld_byte_dc3hit_hi, ld_byte_dc4hit_hi, ld_byte_dc5hit_hi;\n\n   logic                              ld_addr_dc3hit_lo_lo, ld_addr_dc3hit_hi_lo, ld_addr_dc3hit_lo_hi, ld_addr_dc3hit_hi_hi;\n   logic                              ld_addr_dc4hit_lo_lo, ld_addr_dc4hit_hi_lo, ld_addr_dc4hit_lo_hi, ld_addr_dc4hit_hi_hi;\n   logic                              ld_addr_dc5hit_lo_lo, ld_addr_dc5hit_hi_lo, ld_addr_dc5hit_lo_hi, ld_addr_dc5hit_hi_hi;\n\n   logic [BYTE_WIDTH-1:0]             ldst_byteen_hi_dc3, ldst_byteen_hi_dc4, ldst_byteen_hi_dc5;\n   logic [BYTE_WIDTH-1:0]             ldst_byteen_lo_dc3, ldst_byteen_lo_dc4, ldst_byteen_lo_dc5;\n   logic [7:0]                        ldst_byteen_dc3, ldst_byteen_dc4, ldst_byteen_dc5;\n   logic [7:0]                        ldst_byteen_ext_dc3, ldst_byteen_ext_dc4, ldst_byteen_ext_dc5;\n\n   // store data flowing down the pipe\n   logic [31:0]                       store_data_hi_dc3,  store_data_hi_dc4,  store_data_hi_dc5, store_ecc_datafn_hi_dc5;\n   logic [31:0]                       store_data_lo_dc3,  store_data_lo_dc4,  store_data_lo_dc5, store_ecc_datafn_lo_dc5;\n   // fwd data through the pipe\n   logic [31:0]                       ld_fwddata_dc3pipe_lo, ld_fwddata_dc4pipe_lo, ld_fwddata_dc5pipe_lo;\n   logic [31:0]                       ld_fwddata_dc3pipe_hi, ld_fwddata_dc4pipe_hi, ld_fwddata_dc5pipe_hi;\n   logic [DEPTH-1:0]                  store_matchvec_lo_dc5, store_matchvec_hi_dc5;\n   logic                              store_coalesce_lo_dc5, store_coalesce_hi_dc5;\n\n   // needed for tid match in the pipe - only used for RAW and if incase the TB cant avoid true sharing\n   logic                              tid_match_c2c3, tid_match_c2c4, tid_match_c2c5;\n\n   //------------------------------------------------------------------------------------------------------------\n   //----------------------------------------Logic starts here---------------------------------------------------\n   //------------------------------------------------------------------------------------------------------------\n\n   // ------------ START REMOVE ------------------\n   // ------------ NEEDED FOR VERIF PROBE  -------\n   // --------------------------------------------\n   logic [7:0]            store_byteen_ext_dc3, ldst_byteen_tmp_dc3;\n   logic [pt.DCCM_BYTE_WIDTH-1:0] stbuf_byteen_any;\n\n    assign ldst_byteen_tmp_dc3[7:0] = ({8{lsu_pkt_dc3.by}}   & 8'b0000_0001) |\n                                      ({8{lsu_pkt_dc3.half}} & 8'b0000_0011) |\n                                      ({8{lsu_pkt_dc3.word}} & 8'b0000_1111) |\n                                      ({8{lsu_pkt_dc3.dword}} & 8'b1111_1111);\n   assign store_byteen_ext_dc3[7:0] = ldst_byteen_tmp_dc3[7:0] << lsu_addr_dc3[1:0];\n\n   assign stbuf_byteen_any[BYTE_WIDTH-1:0] = stbuf_byteen[RdPtr][BYTE_WIDTH-1:0];    // Not needed as we always write all the bytes\n   // - -------------------- END REMOVE ---------------------\n\n   //----------------------------------------\n   // Logic starts\n\n   // tid match in pipe\n   assign tid_match_c2c3      = (lsu_pkt_dc2.tid == lsu_pkt_dc3.tid);\n   assign tid_match_c2c4      = (lsu_pkt_dc2.tid == lsu_pkt_dc4.tid);\n   assign tid_match_c2c5      = (lsu_pkt_dc2.tid == lsu_pkt_dc5.tid);\n\n   // Create high/low byte enables\n   assign store_byteen_ext_dc5[7:0]           = ldst_byteen_dc5[7:0] << lsu_addr_dc5[1:0];\n   assign store_byteen_hi_dc5[BYTE_WIDTH-1:0] = store_byteen_ext_dc5[7:4];\n   assign store_byteen_lo_dc5[BYTE_WIDTH-1:0] = store_byteen_ext_dc5[3:0];\n\n   assign RdPtrPlus1[DEPTH_LOG2-1:0]     = (RdPtr[DEPTH_LOG2-1:0] == (DEPTH -1)) ? {DEPTH_LOG2{1'b0}}           : RdPtr[DEPTH_LOG2-1:0] + 1'b1;\n   assign WrPtrPlus1[DEPTH_LOG2-1:0]     = (WrPtr[DEPTH_LOG2-1:0] == (DEPTH -1)) ? {DEPTH_LOG2{1'b0}}           : WrPtr[DEPTH_LOG2-1:0] + 1'b1;\n   assign WrPtrPlus2[DEPTH_LOG2-1:0]     = (WrPtr[DEPTH_LOG2-1:0] == (DEPTH -1)) ? {{DEPTH_LOG2-1{1'b0}}, 1'b1} : (WrPtr[DEPTH_LOG2-1:0] == DEPTH-2) ? {DEPTH_LOG2{1'b0}} : WrPtr[DEPTH_LOG2-1:0] + 2'b10;\n\n   // ecc error on both hi/lo\n   assign ldst_dual_dc1          = core_ldst_dual_dc1;\n\n   // Merge store data and sec data\n   for (genvar i=0; i<pt.DCCM_BYTE_WIDTH; i++) begin\n      assign store_ecc_datafn_hi_dc5[(8*i)+7:(8*i)] = dccm_datafn_hi_dc5[(8*i)+7:(8*i)];\n      assign store_ecc_datafn_lo_dc5[(8*i)+7:(8*i)] = dccm_datafn_lo_dc5[(8*i)+7:(8*i)];\n   end\n\n  // Store Buffer coalescing\n   for (genvar i=0; i<DEPTH; i++) begin: FindMatchEntry\n       assign store_matchvec_lo_dc5[i] = (stbuf_addr[i][pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == lsu_addr_dc5[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) & stbuf_vld[i] & ~stbuf_dma_kill[i] & lsu_commit_dc5 & ~stbuf_reset[i];\n       assign store_matchvec_hi_dc5[i] = (stbuf_addr[i][pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == end_addr_dc5[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) & stbuf_vld[i] & ~stbuf_dma_kill[i] & lsu_commit_dc5 & ldst_dual_dc5 & ~stbuf_reset[i];\n   end: FindMatchEntry\n\n   assign store_coalesce_lo_dc5 = |store_matchvec_lo_dc5[DEPTH-1:0];\n   assign store_coalesce_hi_dc5 = |store_matchvec_hi_dc5[DEPTH-1:0];\n\n   // Allocate new in this entry if :\n   // 1. wrptr, single allocate, lo did not coalesce\n   // 2. wrptr, double allocate, lo ^ hi coalesced\n   // 3. wrptr + 1, double alloacte, niether lo or hi coalesced\n   // Also update if there is a hi or a lo coalesce to this entry\n   // Store Buffer instantiation\n   for (genvar i=0; i<DEPTH; i++) begin: GenStBuf\n      assign stbuf_wr_en[i] = store_stbuf_reqvld_dc5 & (\n                                ( (i == WrPtr[DEPTH_LOG2-1:0])      &  ~store_coalesce_lo_dc5)   |                                             // Allocate : new Lo\n                                ( (i == WrPtr[DEPTH_LOG2-1:0])      &  ldst_dual_dc5 & ~store_coalesce_hi_dc5) |                               // Allocate : only 1 new Write Either\n                                ( (i == WrPtrPlus1[DEPTH_LOG2-1:0]) &  ldst_dual_dc5 & ~(store_coalesce_lo_dc5 | store_coalesce_hi_dc5)) |     // Allocate2 : 2 new so Write Hi\n                                store_matchvec_lo_dc5[i] | store_matchvec_hi_dc5[i]);                                                          // Coalesced Write Lo or Hi\n      assign stbuf_reset[i] = (lsu_stbuf_commit_any | stbuf_reqvld_flushed_any) & (i == RdPtr[DEPTH_LOG2-1:0]);\n\n      // Mux select for start/end address\n      assign sel_lo[i]                         = ((~ldst_dual_dc5 | store_stbuf_reqvld_dc5) & (i == WrPtr[DEPTH_LOG2-1:0]) & ~store_coalesce_lo_dc5) |   // lo allocated new entry\n                                                 store_matchvec_lo_dc5[i];                                                                                                           // lo coalesced in to this entry\n      assign stbuf_addrin[i][pt.LSU_SB_BITS-1:0]  = sel_lo[i] ? lsu_addr_dc5[pt.LSU_SB_BITS-1:0]       : end_addr_dc5[pt.LSU_SB_BITS-1:0];\n      assign stbuf_byteenin[i][BYTE_WIDTH-1:0] = sel_lo[i] ? (stbuf_byteen[i][BYTE_WIDTH-1:0] | store_byteen_lo_dc5[BYTE_WIDTH-1:0])          : (stbuf_byteen[i][BYTE_WIDTH-1:0] | store_byteen_hi_dc5[BYTE_WIDTH-1:0]);\n      assign stbuf_datain[i][7:0]              = sel_lo[i] ? ((~stbuf_byteen[i][0] | store_byteen_lo_dc5[0]) ? store_ecc_datafn_lo_dc5[7:0]   : stbuf_data[i][7:0])    :\n                                                             ((~stbuf_byteen[i][0] | store_byteen_hi_dc5[0]) ? store_ecc_datafn_hi_dc5[7:0]   : stbuf_data[i][7:0]);\n      assign stbuf_datain[i][15:8]             = sel_lo[i] ? ((~stbuf_byteen[i][1] | store_byteen_lo_dc5[1]) ? store_ecc_datafn_lo_dc5[15:8]  : stbuf_data[i][15:8])    :\n                                                             ((~stbuf_byteen[i][1] | store_byteen_hi_dc5[1]) ? store_ecc_datafn_hi_dc5[15:8]  : stbuf_data[i][15:8]);\n      assign stbuf_datain[i][23:16]            = sel_lo[i] ? ((~stbuf_byteen[i][2] | store_byteen_lo_dc5[2]) ? store_ecc_datafn_lo_dc5[23:16] : stbuf_data[i][23:16])    :\n                                                             ((~stbuf_byteen[i][2] | store_byteen_hi_dc5[2]) ? store_ecc_datafn_hi_dc5[23:16] : stbuf_data[i][23:16]);\n      assign stbuf_datain[i][31:24]            = sel_lo[i] ? ((~stbuf_byteen[i][3] | store_byteen_lo_dc5[3]) ? store_ecc_datafn_lo_dc5[31:24] : stbuf_data[i][31:24])    :\n                                                             ((~stbuf_byteen[i][3] | store_byteen_hi_dc5[3]) ? store_ecc_datafn_hi_dc5[31:24] : stbuf_data[i][31:24]);\n\n      rvdffsc #(.WIDTH(1))              stbuf_vldff    (.din(1'b1),                                .dout(stbuf_vld[i]),                      .en(stbuf_wr_en[i]),       .clear(stbuf_reset[i]), .clk(lsu_free_c2_clk),  .*);\n      rvdffsc #(.WIDTH(1))              stbuf_killff   (.din(1'b1),                                .dout(stbuf_dma_kill[i]),                 .en(stbuf_dma_kill_en[i]), .clear(stbuf_reset[i]), .clk(lsu_free_c2_clk),  .*);\n      rvdffe  #(.WIDTH(pt.LSU_SB_BITS)) stbuf_addrff   (.din(stbuf_addrin[i][pt.LSU_SB_BITS-1:0]), .dout(stbuf_addr[i][pt.LSU_SB_BITS-1:0]), .en(stbuf_wr_en[i]),                                                       .*);\n      rvdffsc #(.WIDTH(BYTE_WIDTH))     stbuf_byteenff (.din(stbuf_byteenin[i][BYTE_WIDTH-1:0]),   .dout(stbuf_byteen[i][BYTE_WIDTH-1:0]),   .en(stbuf_wr_en[i]),       .clear(stbuf_reset[i]), .clk(lsu_stbuf_c1_clk), .*);\n      rvdffe  #(.WIDTH(DATA_WIDTH))     stbuf_dataff   (.din(stbuf_datain[i][DATA_WIDTH-1:0]),     .dout(stbuf_data[i][DATA_WIDTH-1:0]),     .en(stbuf_wr_en[i]),                                                       .*);\n      rvdffsc #(.WIDTH(1))              stbuf_tidff    (.din(lsu_pkt_dc5.tid),                     .dout(stbuf_tid[i]),                      .en(stbuf_wr_en[i]),       .clear(stbuf_reset[i]), .clk(lsu_free_c2_clk),  .*);\n   end\n   // Store Buffer drain logic\n   assign stbuf_reqvld_flushed_any            = stbuf_vld[RdPtr] & stbuf_dma_kill[RdPtr];\n   assign stbuf_reqvld_any                    = stbuf_vld[RdPtr] & ~stbuf_dma_kill[RdPtr] & ~(|stbuf_dma_kill_en[DEPTH-1:0]);  // Don't drain if some kill bit is being set this cycle\n   assign stbuf_addr_any[pt.LSU_SB_BITS-1:0]  = stbuf_addr[RdPtr][pt.LSU_SB_BITS-1:0];\n   assign stbuf_data_any[DATA_WIDTH-1:0]      = stbuf_data[RdPtr][DATA_WIDTH-1:0];\n\n   // Update the RdPtr/WrPtr logic\n   assign WrPtrEn                  = (store_stbuf_reqvld_dc5  & ~ldst_dual_dc5 & ~(store_coalesce_hi_dc5 | store_coalesce_lo_dc5))  |  // writing 1 and did not coalesce\n                                     (store_stbuf_reqvld_dc5  &  ldst_dual_dc5 & ~(store_coalesce_hi_dc5 & store_coalesce_lo_dc5));    // writing 2 and atleast 1 did not coalesce\n   assign NxtWrPtr[DEPTH_LOG2-1:0] = (store_stbuf_reqvld_dc5 & ldst_dual_dc5 & ~(store_coalesce_hi_dc5 | store_coalesce_lo_dc5)) ? WrPtrPlus2[DEPTH_LOG2-1:0] : WrPtrPlus1[DEPTH_LOG2-1:0];\n   assign RdPtrEn                  = lsu_stbuf_commit_any | stbuf_reqvld_flushed_any;\n   assign NxtRdPtr[DEPTH_LOG2-1:0] = RdPtrPlus1[DEPTH_LOG2-1:0];\n\n   always_comb begin\n      stbuf_numvld_any[pt.NUM_THREADS-1:0] = '0;\n      for (int i=0; i<pt.NUM_THREADS; i++) begin\n         for (int j=0; j<DEPTH; j++) begin\n            stbuf_numvld_any[i][3:0] += {3'b0, (stbuf_vld[j] & (stbuf_tid[j] == 1'(i)))};\n         end\n      end\n   end\n\n   assign isst_nodma_dc1 = lsu_pkt_dc1_pre.valid & lsu_pkt_dc1_pre.store;\n   assign dccm_st_nodma_dc2 = lsu_pkt_dc2.valid & lsu_pkt_dc2.store & ~lsu_pkt_dc2.dma & addr_in_dccm_dc2;\n   assign dccm_st_nodma_dc3 = lsu_pkt_dc3.valid & lsu_pkt_dc3.store & ~lsu_pkt_dc3.dma & addr_in_dccm_dc3;\n   assign dccm_st_nodma_dc4 = lsu_pkt_dc4.valid & lsu_pkt_dc4.store & ~lsu_pkt_dc4.dma & addr_in_dccm_dc"}
{"text": "4;\n   assign dccm_st_nodma_dc5 = lsu_pkt_dc5.valid & lsu_pkt_dc5.store & ~lsu_pkt_dc5.dma & addr_in_dccm_dc5;\n\n   for (genvar i=0; i <pt.NUM_THREADS; i++) begin\n       assign stbuf_specvld_dc1[i][1:0] = {1'b0,(isst_nodma_dc1    & (lsu_pkt_dc1_pre.tid == 1'(i)))} << (isst_nodma_dc1    & ldst_dual_dc1);    // Gate dual with isldst to avoid X propagation\n       assign stbuf_specvld_dc2[i][1:0] = {1'b0,(dccm_st_nodma_dc2 & (lsu_pkt_dc2.tid == 1'(i)))}     << (dccm_st_nodma_dc2 & ldst_dual_dc2);\n       assign stbuf_specvld_dc3[i][1:0] = {1'b0,(dccm_st_nodma_dc3 & (lsu_pkt_dc3.tid == 1'(i)))}     << (dccm_st_nodma_dc3 & ldst_dual_dc3);\n       assign stbuf_specvld_dc4[i][1:0] = {1'b0,(dccm_st_nodma_dc4 & (lsu_pkt_dc4.tid == 1'(i)))}     << (dccm_st_nodma_dc4 & ldst_dual_dc4);\n       assign stbuf_specvld_dc5[i][1:0] = {1'b0,(dccm_st_nodma_dc5 & (lsu_pkt_dc5.tid == 1'(i)))}     << (dccm_st_nodma_dc5 & ldst_dual_dc5);\n       assign stbuf_specvld_any[i][3:0] = stbuf_numvld_any[i][3:0] +  {2'b0, stbuf_specvld_dc1[i][1:0]} + {2'b0, stbuf_specvld_dc2[i][1:0]} +\n                                          {2'b0, stbuf_specvld_dc3[i][1:0]} + {2'b0, stbuf_specvld_dc4[i][1:0]} + {2'b0, stbuf_specvld_dc5[i][1:0]} -\n                                          {3'b0, ((lsu_stbuf_commit_any | stbuf_reqvld_flushed_any) & (stbuf_tid[RdPtr] == 1'(i)))};\n\n       assign stbuf_tidvld_any[i][3:0] = stbuf_specvld_anyQ[i][3:0] + {2'b0,stbuf_specvld_dc1[i][1:0]};\n\n       // Full 1. Thread has it's max entries 2. Total entries are max entries\n       assign lsu_stbuf_full_any[i]     = ((pt.NUM_THREADS > 1) & (stbuf_tidvld_any[i][3:0] >= (DEPTH - 2))) | (stbuf_total_specvld_any[3:0] > (DEPTH - 2));\n       assign lsu_stbuf_empty_any[i]    = (stbuf_numvld_any[i][3:0] == 4'b0);\n\n      rvdff #(.WIDTH(4)) stbuf_specvldff (.din(stbuf_specvld_any[i][3:0]), .dout(stbuf_specvld_anyQ[i][3:0]), .clk(lsu_free_c2_clk), .*);\n   end\n\n   // Total consumed entries\n   always_comb begin\n      stbuf_total_specvld_any[3:0] = '0;\n      for (int i=0; i<pt.NUM_THREADS; i++) begin\n         stbuf_total_specvld_any[3:0] += stbuf_tidvld_any[i][3:0];\n      end\n   end\n\n   // Load forwarding logic from the store queue\n   assign cmpen_hi_dc2                                     = lsu_cmpen_dc2 & ldst_dual_dc2;\n   assign cmpaddr_hi_dc2[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] = end_addr_dc2[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)];\n\n   assign cmpen_lo_dc2                                     = lsu_cmpen_dc2;\n   assign cmpaddr_lo_dc2[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] = lsu_addr_dc2[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)];\n\n   always_comb begin: GenLdFwd\n      stbuf_fwdbyteen_hi_dc2[BYTE_WIDTH-1:0]   = '0;\n      stbuf_fwdbyteen_lo_dc2[BYTE_WIDTH-1:0]   = '0;\n\n      for (int i=0; i<DEPTH; i++) begin\n         stbuf_match_hi[i] = (stbuf_addr[i][pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == cmpaddr_hi_dc2[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) & stbuf_vld[i] & ~stbuf_dma_kill[i] & addr_in_dccm_dc2;\n         stbuf_match_lo[i] = (stbuf_addr[i][pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)] == cmpaddr_lo_dc2[pt.LSU_SB_BITS-1:$clog2(BYTE_WIDTH)]) & stbuf_vld[i] & ~stbuf_dma_kill[i] &  addr_in_dccm_dc2;\n\n         // Kill the store buffer entry if there is a dma store since it already updated the dccm\n         stbuf_dma_kill_en[i] = (stbuf_match_hi[i] | stbuf_match_lo[i]) & lsu_pkt_dc2.valid & lsu_pkt_dc2.dma & lsu_pkt_dc2.store;\n\n         for (int j=0; j<BYTE_WIDTH; j++) begin\n            stbuf_fwdbyteenvec_hi[i][j] = stbuf_match_hi[i] & stbuf_byteen[i][j] & stbuf_vld[i];\n            stbuf_fwdbyteen_hi_dc2[j]  |= stbuf_fwdbyteenvec_hi[i][j];\n\n            stbuf_fwdbyteenvec_lo[i][j] = stbuf_match_lo[i] & stbuf_byteen[i][j] & stbuf_vld[i];\n            stbuf_fwdbyteen_lo_dc2[j]  |= stbuf_fwdbyteenvec_lo[i][j];\n         end\n      end\n   end // block: GenLdFwd\n\n   always_comb begin : Finaldata\n     stbuf_fwddata_hi_dc2[31:0]   = '0;\n     stbuf_fwddata_lo_dc2[31:0]   = '0;\n     for (int i=0; i<DEPTH; i++) begin\n         stbuf_fwddata_hi_dc2[31:0] |= {32{stbuf_match_hi[i]}} & stbuf_data[i][31:0];\n         stbuf_fwddata_lo_dc2[31:0] |= {32{stbuf_match_lo[i]}} & stbuf_data[i][31:0];\n      end\n   end\n\n   // Create Hi/Lo signals - needed for the pipe forwarding\n   assign ldst_byteen_dc3[7:0] = ({8{lsu_pkt_dc3.by}}    & 8'b0000_0001) |\n                                 ({8{lsu_pkt_dc3.half}}  & 8'b0000_0011) |\n                                 ({8{lsu_pkt_dc3.word}}  & 8'b0000_1111) |\n                                 ({8{lsu_pkt_dc3.dword}} & 8'b1111_1111);\n\n  assign ldst_byteen_dc4[7:0] =  ({8{lsu_pkt_dc4.by}}    & 8'b0000_0001) |\n                                 ({8{lsu_pkt_dc4.half}}  & 8'b0000_0011) |\n                                 ({8{lsu_pkt_dc4.word}}  & 8'b0000_1111) |\n                                 ({8{lsu_pkt_dc4.dword}} & 8'b1111_1111);\n\n  assign ldst_byteen_dc5[7:0] =  ({8{lsu_pkt_dc5.by}}    & 8'b0000_0001) |\n                                 ({8{lsu_pkt_dc5.half}}  & 8'b0000_0011) |\n                                 ({8{lsu_pkt_dc5.word}}  & 8'b0000_1111) |\n                                 ({8{lsu_pkt_dc5.dword}} & 8'b1111_1111);\n\n   assign ldst_byteen_ext_dc3[7:0] = ldst_byteen_dc3[7:0] << lsu_addr_dc3[1:0];\n   assign ldst_byteen_ext_dc4[7:0] = ldst_byteen_dc4[7:0] << lsu_addr_dc4[1:0];\n   assign ldst_byteen_ext_dc5[7:0] = ldst_byteen_dc5[7:0] << lsu_addr_dc5[1:0];\n\n   assign store_data_hi_dc3[31:0]   = store_data_ext_dc3[63:32];\n   assign store_data_lo_dc3[31:0]   = store_data_ext_dc3[31:0];\n   assign store_data_hi_dc4[31:0]   = store_data_ext_dc4[63:32];\n   assign store_data_lo_dc4[31:0]   = store_data_ext_dc4[31:0];\n   assign store_data_hi_dc5[31:0]   = store_data_ext_dc5[63:32];\n   assign store_data_lo_dc5[31:0]   = store_data_ext_dc5[31:0];\n\n   assign ldst_byteen_hi_dc3[3:0]   = ldst_byteen_ext_dc3[7:4];\n   assign ldst_byteen_lo_dc3[3:0]   = ldst_byteen_ext_dc3[3:0];\n   assign ldst_byteen_hi_dc4[3:0]   = ldst_byteen_ext_dc4[7:4];\n   assign ldst_byteen_lo_dc4[3:0]   = ldst_byteen_ext_dc4[3:0];\n   assign ldst_byteen_hi_dc5[3:0]   = ldst_byteen_ext_dc5[7:4];\n   assign ldst_byteen_lo_dc5[3:0]   = ldst_byteen_ext_dc5[3:0];\n\n   assign ld_addr_dc3hit_lo_lo = (lsu_addr_dc2[31:2] == lsu_addr_dc3[31:2]) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store  & ~lsu_pkt_dc3.dma & tid_match_c2c3;\n   assign ld_addr_dc3hit_lo_hi = (end_addr_dc2[31:2] == lsu_addr_dc3[31:2]) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store  & ~lsu_pkt_dc3.dma & tid_match_c2c3;\n   assign ld_addr_dc3hit_hi_lo = (lsu_addr_dc2[31:2] == end_addr_dc3[31:2]) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store  & ~lsu_pkt_dc3.dma & ldst_dual_dc3 & tid_match_c2c3;\n   assign ld_addr_dc3hit_hi_hi = (end_addr_dc2[31:2] == end_addr_dc3[31:2]) & lsu_pkt_dc3.valid & lsu_pkt_dc3.store  & ~lsu_pkt_dc3.dma & ldst_dual_dc3 & tid_match_c2c3;\n\n   assign ld_addr_dc4hit_lo_lo = (lsu_addr_dc2[31:2] == lsu_addr_dc4[31:2]) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & ~lsu_pkt_dc4.dma & tid_match_c2c4;\n   assign ld_addr_dc4hit_lo_hi = (end_addr_dc2[31:2] == lsu_addr_dc4[31:2]) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & ~lsu_pkt_dc4.dma & tid_match_c2c4;\n   assign ld_addr_dc4hit_hi_lo = (lsu_addr_dc2[31:2] == end_addr_dc4[31:2]) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & ~lsu_pkt_dc4.dma & ldst_dual_dc4 & tid_match_c2c4;\n   assign ld_addr_dc4hit_hi_hi = (end_addr_dc2[31:2] == end_addr_dc4[31:2]) & lsu_pkt_dc4.valid & lsu_pkt_dc4.store & ~lsu_pkt_dc4.dma & ldst_dual_dc4 & tid_match_c2c4;\n\n   assign ld_addr_dc5hit_lo_lo = (lsu_addr_dc2[31:2] == lsu_addr_dc5[31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.store & ~lsu_pkt_dc5.dma & tid_match_c2c5;\n   assign ld_addr_dc5hit_lo_hi = (end_addr_dc2[31:2] == lsu_addr_dc5[31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.store & ~lsu_pkt_dc5.dma & tid_match_c2c5;\n   assign ld_addr_dc5hit_hi_lo = (lsu_addr_dc2[31:2] == end_addr_dc5[31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.store & ~lsu_pkt_dc5.dma & ldst_dual_dc5 & tid_match_c2c5;\n   assign ld_addr_dc5hit_hi_hi = (end_addr_dc2[31:2] == end_addr_dc5[31:2]) & lsu_pkt_dc5.valid & lsu_pkt_dc5.store & ~lsu_pkt_dc5.dma & ldst_dual_dc5 & tid_match_c2c5;\n\n   for (genvar i=0; i<BYTE_WIDTH; i++) begin\n      assign ld_byte_dc3hit_lo_lo[i] = ld_addr_dc3hit_lo_lo & ldst_byteen_lo_dc3[i];\n      assign ld_byte_dc3hit_lo_hi[i] = ld_addr_dc3hit_lo_hi & ldst_byteen_lo_dc3[i];\n      assign ld_byte_dc3hit_hi_lo[i] = ld_addr_dc3hit_hi_lo & ldst_byteen_hi_dc3[i];\n      assign ld_byte_dc3hit_hi_hi[i] = ld_addr_dc3hit_hi_hi & ldst_byteen_hi_dc3[i];\n\n      assign ld_byte_dc4hit_lo_lo[i] = ld_addr_dc4hit_lo_lo & ldst_byteen_lo_dc4[i];\n      assign ld_byte_dc4hit_lo_hi[i] = ld_addr_dc4hit_lo_hi & ldst_byteen_lo_dc4[i];\n      assign ld_byte_dc4hit_hi_lo[i] = ld_addr_dc4hit_hi_lo & ldst_byteen_hi_dc4[i];\n      assign ld_byte_dc4hit_hi_hi[i] = ld_addr_dc4hit_hi_hi & ldst_byteen_hi_dc4[i];\n\n      assign ld_byte_dc5hit_lo_lo[i] = ld_addr_dc5hit_lo_lo & ldst_byteen_lo_dc5[i];\n      assign ld_byte_dc5hit_lo_hi[i] = ld_addr_dc5hit_lo_hi & ldst_byteen_lo_dc5[i];\n      assign ld_byte_dc5hit_hi_lo[i] = ld_addr_dc5hit_hi_lo & ldst_byteen_hi_dc5[i];\n      assign ld_byte_dc5hit_hi_hi[i] = ld_addr_dc5hit_hi_hi & ldst_byteen_hi_dc5[i];\n\n      assign ld_byte_dc3hit_lo[i] = ld_byte_dc3hit_lo_lo[i] | ld_byte_dc3hit_hi_lo[i];\n      assign ld_byte_dc4hit_lo[i] = ld_byte_dc4hit_lo_lo[i] | ld_byte_dc4hit_hi_lo[i];\n      assign ld_byte_dc5hit_lo[i] = ld_byte_dc5hit_lo_lo[i] | ld_byte_dc5hit_hi_lo[i];\n\n      assign ld_byte_dc3hit_hi[i] = ld_byte_dc3hit_lo_hi[i] | ld_byte_dc3hit_hi_hi[i];\n      assign ld_byte_dc4hit_hi[i] = ld_byte_dc4hit_lo_hi[i] | ld_byte_dc4hit_hi_hi[i];\n      assign ld_byte_dc5hit_hi[i] = ld_byte_dc5hit_lo_hi[i] | ld_byte_dc5hit_hi_hi[i];\n\n      assign ld_fwddata_dc3pipe_lo[(8*i)+7:(8*i)] = ({8{ld_byte_dc3hit_lo_lo[i]}} & store_data_lo_dc3[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_dc3hit_hi_lo[i]}} & store_data_hi_dc3[(8*i)+7:(8*i)]);\n      assign ld_fwddata_dc4pipe_lo[(8*i)+7:(8*i)] = ({8{ld_byte_dc4hit_lo_lo[i]}} & store_data_lo_dc4[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_dc4hit_hi_lo[i]}} & store_data_hi_dc4[(8*i)+7:(8*i)]);\n      assign ld_fwddata_dc5pipe_lo[(8*i)+7:(8*i)] = ({8{ld_byte_dc5hit_lo_lo[i]}} & store_data_lo_dc5[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_dc5hit_hi_lo[i]}} & store_data_hi_dc5[(8*i)+7:(8*i)]);\n\n      assign ld_fwddata_dc3pipe_hi[(8*i)+7:(8*i)] = ({8{ld_byte_dc3hit_lo_hi[i]}} & store_data_lo_dc3[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_dc3hit_hi_hi[i]}} & store_data_hi_dc3[(8*i)+7:(8*i)]);\n      assign ld_fwddata_dc4pipe_hi[(8*i)+7:(8*i)] = ({8{ld_byte_dc4hit_lo_hi[i]}} & store_data_lo_dc4[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_dc4hit_hi_hi[i]}} & store_data_hi_dc4[(8*i)+7:(8*i)]);\n      assign ld_fwddata_dc5pipe_hi[(8*i)+7:(8*i)] = ({8{ld_byte_dc5hit_lo_hi[i]}} & store_data_lo_dc5[(8*i)+7:(8*i)]) |\n                                                    ({8{ld_byte_dc5hit_hi_hi[i]}} & store_data_hi_dc5[(8*i)+7:(8*i)]);\n\n      assign ld_byte_hit_lo[i] = ld_byte_dc3hit_lo_lo[i] | ld_byte_dc3hit_hi_lo[i] |\n                                 ld_byte_dc4hit_lo_lo[i] | ld_byte_dc4hit_hi_lo[i] |\n                                 ld_byte_dc5hit_lo_lo[i] | ld_byte_dc5hit_hi_lo[i];\n\n      assign ld_byte_hit_hi[i] = ld_byte_dc3hit_lo_hi[i] | ld_byte_dc3hit_hi_hi[i] |\n                                 ld_byte_dc4hit_lo_hi[i] | ld_byte_dc4hit_hi_hi[i] |\n                                 ld_byte_dc5hit_lo_hi[i] | ld_byte_dc5hit_hi_hi[i];\n\n      assign stbuf_fwdbyteen_hi_fn_dc2[i] = ld_byte_hit_hi[i] | stbuf_fwdbyteen_hi_dc2[i];\n      assign stbuf_fwdbyteen_lo_fn_dc2[i] = ld_byte_hit_lo[i] | stbuf_fwdbyteen_lo_dc2[i];\n      // Pipe vs Store Queue priority\n      assign stbuf_fwddata_lo_fn_dc2[(8*i)+7:(8*i)] = ld_byte_dc3hit_lo[i]    ? ld_fwddata_dc3pipe_lo[(8*i)+7:(8*i)] :\n                                                      ld_byte_dc4hit_lo[i]    ? ld_fwddata_dc4pipe_lo[(8*i)+7:(8*i)] :\n                                                      ld_byte_dc5hit_lo[i]    ? ld_fwddata_dc5pipe_lo[(8*i)+7:(8*i)] :\n                                                      stbuf_fwddata_lo_dc2[(8*i)+7:(8*i)];\n      // Pipe vs Store Queue priority\n      assign stbuf_fwddata_hi_fn_dc2[(8*i)+7:(8*i)] = ld_byte_dc3hit_hi[i]    ? ld_fwddata_dc3pipe_hi[(8*i)+7:(8*i)] :\n                                                      ld_byte_dc4hit_hi[i]    ? ld_fwddata_dc4pipe_hi[(8*i)+7:(8*i)] :\n                                                      ld_byte_dc5hit_hi[i]    ? ld_fwddata_dc5pipe_hi[(8*i)+7:(8*i)] :\n                                                      stbuf_fwddata_hi_dc2[(8*i)+7:(8*i)];\n   end\n\n   // PIC forwarding from dc3/dc4/dc5 -> dc2\n   assign picm_fwd_en_dc2         = addr_in_pic_dc2 & (|stbuf_fwdbyteen_lo_fn_dc2[3:0]);\n   assign picm_fwd_data_dc2[31:0] = stbuf_fwddata_lo_fn_dc2[31:0];\n\n   assign stbuf_fwddata_lo_en = (|(stbuf_fwdbyteen_lo_fn_dc2[BYTE_WIDTH-1:0])) | clk_override;\n   assign stbuf_fwddata_hi_en = (|(stbuf_fwdbyteen_hi_fn_dc2[BYTE_WIDTH-1:0])) | clk_override;\n\n   // Flops\n   rvdffs #(.WIDTH(DEPTH_LOG2)) WrPtrff                 (.din(NxtWrPtr[DEPTH_LOG2-1:0]),                  .dout(WrPtr[DEPTH_LOG2-1:0]),                 .en(WrPtrEn),  .clk(lsu_stbuf_c1_clk), .*);\n   rvdffs #(.WIDTH(DEPTH_LOG2)) RdPtrff                 (.din(NxtRdPtr[DEPTH_LOG2-1:0]),                  .dout(RdPtr[DEPTH_LOG2-1:0]),                 .en(RdPtrEn),  .clk(lsu_stbuf_c1_clk), .*);\n\n   rvdff #(.WIDTH(BYTE_WIDTH)) stbuf_fwdbyteen_hi_dc3ff (.din(stbuf_fwdbyteen_hi_fn_dc2[BYTE_WIDTH-1:0]), .dout(stbuf_fwdbyteen_hi_dc3[BYTE_WIDTH-1:0]),               .clk(lsu_c1_dc3_clk),   .*);\n   rvdff #(.WIDTH(BYTE_WIDTH)) stbuf_fwdbyteen_lo_dc3ff (.din(stbuf_fwdbyteen_lo_fn_dc2[BYTE_WIDTH-1:0]), .dout(stbuf_fwdbyteen_lo_dc3[BYTE_WIDTH-1:0]),               .clk(lsu_c1_dc3_clk),   .*);\n\n   rvdffe #(.WIDTH(DATA_WIDTH)) stbuf_fwddata_hi_dc3ff   (.din(stbuf_fwddata_hi_fn_dc2[DATA_WIDTH-1:0]),  .dout(stbuf_fwddata_hi_dc3[DATA_WIDTH-1:0]),  .en(stbuf_fwddata_hi_en),   .*);\n   rvdffe #(.WIDTH(DATA_WIDTH)) stbuf_fwddata_lo_dc3ff   (.din(stbuf_fwddata_lo_fn_dc2[DATA_WIDTH-1:0]),  .dout(stbuf_fwddata_lo_dc3[DATA_WIDTH-1:0]),  .en(stbuf_fwddata_lo_en),   .*);\n\nendmodule\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n//\n// Owner:\n// Function: LSU Trigger logic\n// Comments:\n//\n//********************************************************************************\nmodule eh2_lsu_trigger\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)(\n   input logic                    scan_mode,\n   input logic                    rst_l,\n   input logic                    clk_override,\n   input logic                    clk,\n   input eh2_trigger_pkt_t [pt.NUM_THREADS-1:0][3:0] trigger_pkt_any, // Trigger info from the decode\n   input eh2_lsu_pkt_t           lsu_pkt_dc3,            // lsu packet\n   input eh2_lsu_pkt_t           lsu_pkt_dc4,            // lsu packet\n   input logic [31:0]             lsu_addr_dc4,           // address\n   input logic [31:0]             store_data_dc3,         // store data\n   input logic [31:0]             amo_data_dc3,\n\n   output logic [3:0]             lsu_trigger_match_dc4   // match result\n);\n\n   eh2_trigger_pkt_t  [3:0]        trigger_tid_pkt_any;\n   logic              trigger_enable;             // Trigger enable. Used to bus quiescing\n   logic [31:0]       ldst_addr_trigger_dc4;\n   logic [31:0]       trigger_store_data_dc3;\n   logic [31:0]       store_data_trigger_dc3;\n   logic [31:0]       store_data_trigger_dc4;\n   logic [3:0][31:0]  lsu_match_data;\n   logic [3:0]        lsu_trigger_data_match;\n\n   // Generate the trigger enable\n   always_comb begin\n      trigger_enable = 1'b0;\n      for (int i=0; i<pt.NUM_THREADS; i++) begin\n         for (int j=0; j<4; j++) begin\n            trigger_enable |= trigger_pkt_any[i][j].m;\n         end\n      end\n   end\n\n   assign trigger_store_data_dc3[31:0] = (lsu_pkt_dc3.atomic ? amo_data_dc3[31:0] : store_data_dc3[31:0]) & {32{trigger_enable}};\n   assign store_data_trigger_dc3[31:0] = { ({16{lsu_pkt_dc3.word | lsu_pkt_dc3.dword}} & trigger_store_data_dc3[31:16]), ({8{(lsu_pkt_dc3.half | lsu_pkt_dc3.word | lsu_pkt_dc3.dword)}} & trigger_store_data_dc3[15:8]), trigger_store_data_dc3[7:0]};\n\n   assign ldst_addr_trigger_dc4[31:0] = lsu_addr_dc4[31:0] & {32{trigger_enable}};\n\n   rvdffe #(32) store_data_trigger_ff   (.*, .din(store_data_trigger_dc3[31:0]),  .dout(store_data_trigger_dc4[31:0]), .en((lsu_pkt_dc3.valid & lsu_pkt_dc3.store & trigger_enable) | clk_override));\n\n   for (genvar i=0; i<4; i++) begin\n      assign trigger_tid_pkt_any[i]    = trigger_pkt_any[lsu_pkt_dc4.tid][i];\n      assign lsu_match_data[i][31:0]   = ({32{~trigger_tid_pkt_any[i].select                               }} & ldst_addr_trigger_dc4[31:0]) |\n                                         ({32{ trigger_tid_pkt_any[i].select & trigger_tid_pkt_any[i].store}} & store_data_trigger_dc4[31:0]);\n\n      rvmaskandmatch trigger_match     (.mask(trigger_tid_pkt_any[i].tdata2[31:0]), .data(lsu_match_data[i][31:0]), .masken(trigger_tid_pkt_any[i].match), .match(lsu_trigger_data_match[i]));\n\n      assign lsu_trigger_match_dc4[i]  = lsu_pkt_dc4.valid & ~lsu_pkt_dc4.dma &\n                                         ((trigger_tid_pkt_any[i].store & lsu_pkt_dc4.store) | (trigger_tid_pkt_any[i].load & lsu_pkt_dc4.load & ~lsu_pkt_dc4.store & ~trigger_tid_pkt_any[i].select)) &\n                                         lsu_trigger_data_match[i];\n   end\n\nendmodule // lsu_trigger\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\nmodule eh2_mem\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n)\n(\n   input logic         clk,\n   input logic         rst_l,\n   input logic         dccm_clk_override,\n   input logic         icm_clk_override,\n   input logic         dec_tlu_core_ecc_disable,\n   input logic         btb_clk_override,\n\n   //DCCM ports\n   input logic         dccm_wren,\n   input logic         dccm_rden,\n   input logic [pt.DCCM_BITS-1:0]  dccm_wr_addr_lo,\n   input logic [pt.DCCM_BITS-1:0]  dccm_wr_addr_hi,\n   input logic [pt.DCCM_BITS-1:0]  dccm_rd_addr_lo,\n   input logic [pt.DCCM_BITS-1:0]  dccm_rd_addr_hi,\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_lo,\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_hi,\n\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_lo,\n   output logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_hi,\n\n   input eh2_dccm_ext_in_pkt_t  [pt.DCCM_NUM_BANKS-1:0] dccm_ext_in_pkt,\n\n   //ICCM ports\n   input eh2_ccm_ext_in_pkt_t   [pt.ICCM_NUM_BANKS/4-1:0][1:0][1:0]  iccm_ext_in_pkt,\n\n   input logic [pt.ICCM_BITS-1:1]  iccm_rw_addr,\n   input logic [pt.NUM_THREADS-1:0]iccm_buf_correct_ecc_thr,            // ICCM is doing a single bit error correct cycle\n   input logic                     iccm_correction_state,               // We are under a correction - This is needed to guard replacements when hit\n   input logic                     iccm_stop_fetch,                     // Squash any lru updates on the red hits as we have fetched ahead\n   input logic                     iccm_corr_scnd_fetch,                // dont match on middle bank when under correction\n\n\n   input logic         ifc_select_tid_f1,\n   input logic         iccm_wren,\n   input logic         iccm_rden,\n   input logic [2:0]   iccm_wr_size,\n   input logic [77:0]  iccm_wr_data,\n\n   output logic [63:0]  iccm_rd_data,\n   output logic [116:0] iccm_rd_data_ecc,\n   // Icache and Itag Ports\n   input  logic [31:1]  ic_rw_addr,\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]   ic_tag_valid,\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]          ic_wr_en  ,         // Which way to write\n   input  logic         ic_rd_en,\n   input  logic [63:0]  ic_premux_data,     // Premux data to be muxed with each way of the Icache.\n   input  logic         ic_sel_premux_data, // Premux data sel\n\n   input eh2_ic_data_ext_in_pkt_t   [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0]         ic_data_ext_in_pkt,\n   input eh2_ic_tag_ext_in_pkt_t    [pt.ICACHE_NUM_WAYS-1:0]              ic_tag_ext_in_pkt,\n\n   input logic [pt.ICACHE_BANKS_WAY-1:0] [70:0]               ic_wr_data,           // Data to fill to the Icache. With ECC\n   output logic [63:0]               ic_rd_data ,          // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   output logic [70:0]               ic_debug_rd_data ,    // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   output logic [25:0]               ictag_debug_rd_data,  // Debug icache tag.\n   input  logic [70:0]               ic_debug_wr_data,     // Debug wr cache.\n\n\n   input logic [pt.ICACHE_INDEX_HI:3]           ic_debug_addr,      // Read/Write addresss to the Icache.\n   input  logic                                 ic_debug_rd_en,     // Icache debug rd\n   input  logic                                 ic_debug_wr_en,     // Icache debug wr\n   input  logic                                 ic_debug_tag_array, // Debug tag array\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]        ic_debug_way,       // Debug way. Rd or Wr.\n\n\n   output  logic [pt.ICACHE_BANKS_WAY-1:0]       ic_eccerr,\n   output  logic [pt.ICACHE_BANKS_WAY-1:0]       ic_parerr,\n\n\n   output logic [pt.ICACHE_NUM_WAYS-1:0]   ic_rd_hit,\n   output logic         ic_tag_perr,        // Icache Tag parity error\n\n   // BTB ports\n input eh2_ccm_ext_in_pkt_t   [1:0] btb_ext_in_pkt,\n\n input logic                         btb_wren,\n input logic                         btb_rden,\n input logic [1:0] [pt.BTB_ADDR_HI:1] btb_rw_addr,  // per bank\n input logic [1:0] [pt.BTB_ADDR_HI:1] btb_rw_addr_f1,  // per bank\n input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]         btb_sram_wr_data,\n input logic [1:0] [pt.BTB_BTAG_SIZE-1:0] btb_sram_rd_tag_f1,\n\n output eh2_btb_sram_pkt btb_sram_pkt,\n\n output logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank0_rd_data_f1,\n output logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank1_rd_data_f1,\n output logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank2_rd_data_f1,\n output logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank3_rd_data_f1,\n\n input  logic         scan_mode\n);\n\n   logic  active_clk;\n   rvoclkhdr active_cg   ( .en(1'b1),         .l1clk(active_clk), .* );\n\n   // DCCM Instantiation\n   if (pt.DCCM_ENABLE == 1) begin: Gen_dccm_enable\n      eh2_lsu_dccm_mem #(.pt(pt)) dccm (\n         .clk_override(dccm_clk_override),\n         .*\n      );\n   end else begin: Gen_dccm_disable\n      assign dccm_rd_data_lo = '0;\n      assign dccm_rd_data_hi = '0;\n   end\n\nif (pt.ICACHE_ENABLE == 1) begin : icache\n   eh2_ifu_ic_mem #(.pt(pt)) icm  (\n      .clk_override(icm_clk_override),\n      .*\n   );\nend\nelse begin\n   assign   ic_rd_hit[3:0] = '0;\n   assign   ic_tag_perr    = '0 ;\n   assign   ic_rd_data  = '0 ;\n   assign   ictag_debug_rd_data  = '0 ;\nend\n\nif (pt.ICCM_ENABLE == 1) begin : iccm\n   eh2_ifu_iccm_mem  #(.pt(pt)) iccm (.*,\n                  .clk_override(icm_clk_override),\n                  .iccm_rw_addr(iccm_rw_addr[pt.ICCM_BITS-1:1]),\n                  .iccm_rd_data(iccm_rd_data[63:0])\n                   );\nend\nelse  begin\n   assign iccm_rd_data     = '0 ;\n   assign iccm_rd_data_ecc = '0 ;\nend\n\n// BTB sram\nif (pt.BTB_USE_SRAM == 1) begin : btb\n   eh2_ifu_btb_mem #(.pt(pt)) btb  (\n      .clk_override(btb_clk_override),\n      .*\n   );\nend\n\n\nendmodule\n"}
{"text": "//********************************************************************************\n// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n//********************************************************************************\n\n//********************************************************************************\n// Function: Programmable Interrupt Controller\n// Comments:\n//********************************************************************************\n\nmodule eh2_pic_ctrl\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n )\n                  (\n\n                     input  logic                   clk,                  // Core clock\n                     input  logic                   free_clk,             // free clock\n                     input  logic                   rst_l,                // Reset for all flops\n                     input  logic                   clk_override,         // Clock over-ride for gating\n                     input  logic                   io_clk_override,      // PIC IO  Clock over-ride for gating\n\n                     input  logic [pt.NUM_THREADS-1:0] o_cpu_halt_status, // PMU interface, halted\n\n                     input  logic [pt.PIC_TOTAL_INT_PLUS1-1:0]   extintsrc_req,  // Interrupt requests\n                     input  logic [31:0]            picm_rdaddr,          // Address of the register\n                     input  logic [31:0]            picm_wraddr,          // Address of the register\n                     input  logic [31:0]            picm_wr_data,         // Data to be written to the register\n                     input  logic                   picm_wren,            // Write enable to the register\n                     input  logic                   picm_rden,            // Read enable for the register\n                     input  logic                   picm_rd_thr,          // Reading thread\n                     input  logic                   picm_mken,            // Read the Mask for the register\n\n                     input  logic [pt.NUM_THREADS-1:0] [3:0]             dec_tlu_meicurpl,           // Current Priority Level\n                     input  logic [pt.NUM_THREADS-1:0] [3:0]             dec_tlu_meipt,              // Current Priority Threshold\n\n                     output logic [pt.NUM_THREADS-1:0]                   mexintpend_out,           // External Inerrupt request to the core\n                     output logic [pt.NUM_THREADS-1:0] [7:0]             claimid_out,              // Claim Id of the requested interrupt\n                     output logic [pt.NUM_THREADS-1:0] [3:0]             pl_out,                   // Priority level of the requested interrupt\n                     output logic [pt.NUM_THREADS-1:0]                   mhwakeup_out,             // Wake-up interrupt request\n\n                     output logic [31:0]            picm_rd_data,         // Read data of the register\n                     input  logic                   scan_mode             // scan mode\n\n);\n\nlocalparam NUM_LEVELS            = $clog2(pt.PIC_TOTAL_INT_PLUS1);\nlocalparam INTPRIORITY_BASE_ADDR = pt.PIC_BASE_ADDR ;\nlocalparam INTPEND_BASE_ADDR     = pt.PIC_BASE_ADDR + 32'h00001000 ;\nlocalparam INTPEND_THR_BASE_ADDR = pt.PIC_BASE_ADDR + 32'h00001800 ;\nlocalparam INTENABLE_BASE_ADDR   = pt.PIC_BASE_ADDR + 32'h00002000 ;\nlocalparam EXT_INTR_PIC_CONFIG   = pt.PIC_BASE_ADDR + 32'h00003000 ;\nlocalparam EXT_INTR_GW_CONFIG    = pt.PIC_BASE_ADDR + 32'h00004000 ;\nlocalparam EXT_INTR_GW_CLEAR     = pt.PIC_BASE_ADDR + 32'h00005000 ;\nlocalparam EXT_INTR_DELG_REG     = pt.PIC_BASE_ADDR + 32'h00006000 ;\n\n\nlocalparam INTPEND_SIZE          = (pt.PIC_TOTAL_INT_PLUS1 < 32)  ? 32  :\n                                   (pt.PIC_TOTAL_INT_PLUS1 < 64)  ? 64  :\n                                   (pt.PIC_TOTAL_INT_PLUS1 < 128) ? 128 :\n                                   (pt.PIC_TOTAL_INT_PLUS1 < 256) ? 256 :\n                                   (pt.PIC_TOTAL_INT_PLUS1 < 512) ? 512 :  1024 ;\n\nlocalparam INT_GRPS              =   INTPEND_SIZE / 32 ;\nlocalparam INTPRIORITY_BITS      =  4 ;\nlocalparam ID_BITS               =  8 ;\nlocalparam int GW_CONFIG[pt.PIC_TOTAL_INT_PLUS1-1:0] = '{default:0} ;\n\nlocalparam INT_ENABLE_GRPS       =   (pt.PIC_TOTAL_INT_PLUS1 - 1)  / 4 ;\n\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]           intenable_clk_enable ;\nlogic [INT_ENABLE_GRPS:0]                    intenable_clk_enable_grp ;\nlogic [INT_ENABLE_GRPS:0]                    gw_clk ;\n\nlogic [pt.NUM_THREADS-1:0]                   mexintpend_ff;           // External Inerrupt request to the core\nlogic [pt.NUM_THREADS-1:0]  [7:0]            claimid_ff;              // Claim Id of the requested interrupt\nlogic [pt.NUM_THREADS-1:0]  [3:0]            pl_ff;                   // Priority level of the requested interrupt\nlogic [pt.NUM_THREADS-1:0]                   mhwakeup_ff;             // Wake-up interrupt request\n\nlogic [pt.NUM_THREADS-1:0]                   mexintpend;\nlogic [pt.NUM_THREADS-1:0] [7:0]             claimid;\nlogic [pt.NUM_THREADS-1:0] [3:0]             pl;\nlogic [pt.NUM_THREADS-1:0]                   mhwakeup;\n\n\nlogic  addr_intpend_base_match;\nlogic  addr_intpend_thr_base_match;\n\nlogic  raddr_config_pic_match ;\nlogic  raddr_intenable_base_match;\nlogic  raddr_delg_base_match;\nlogic  raddr_intpriority_base_match;\nlogic  raddr_config_gw_base_match ;\n\nlogic  waddr_config_pic_match ;\nlogic  waddr_intpriority_base_match;\nlogic  waddr_intenable_base_match;\nlogic  waddr_delg_base_match;\nlogic  waddr_config_gw_base_match ;\nlogic  addr_clear_gw_base_match ;\n\nlogic  mexintpend_in;\nlogic  mhwakeup_in ;\nlogic  intpend_reg_read ;\nlogic  intpend_thr_reg_read ;\n\nlogic [31:0]                                 picm_rd_data_in, intpend_rd_out, intpend_thr_rd_out;\nlogic                                        intenable_rd_out ;\nlogic                                        delg_rd_out ;\nlogic [INTPRIORITY_BITS-1:0]                 intpriority_rd_out;\nlogic [1:0]                                  gw_config_rd_out;\n\nlogic [INTPRIORITY_BITS-1:0] meipt_inv , meicurpl_inv , meicurpl, meipt;\n\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0] [INTPRIORITY_BITS-1:0] intpriority_reg;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0] [INTPRIORITY_BITS-1:0] intpriority_reg_inv;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        intpriority_reg_we;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        intpriority_reg_re;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        delg_thr_match;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0] [1:0]                  gw_config_reg;\n\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        intenable_reg;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        intenable_reg_we;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        intenable_reg_re;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        delg_reg;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        delg_reg_we;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        delg_reg_re;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        gw_config_reg_we;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        gw_config_reg_re;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        gw_clear_reg_we;\n\nlogic [INTPEND_SIZE-1:0]                     intpend_reg_extended;\nlogic [INTPEND_SIZE-1:0]                     thr_mx_intpend_reg_extended;\n\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0] [INTPRIORITY_BITS-1:0] intpend_w_prior_en;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0] [ID_BITS-1:0]          intpend_id;\nlogic [INTPRIORITY_BITS-1:0]                 maxint;\nlogic [INTPRIORITY_BITS-1:0]                 selected_int_priority;\nlogic [INT_GRPS-1:0] [31:0]                  intpend_rd_part_out ;\nlogic [INT_GRPS-1:0] [31:0]                  intpend_thr_rd_part_out ;\n\nlogic                                        curr_int_tid;\nlogic                                        curr_int_tid_ff;\nlogic                                        curr_int_tid_final;\nlogic                                        curr_int_tid_final_in;\nlogic                                        config_reg;\nlogic                                        intpriord;\nlogic                                        config_reg_we ;\nlogic                                        config_reg_re ;\nlogic                                        config_reg_in ;\nlogic                                        prithresh_reg_write , prithresh_reg_read;\nlogic                                        intpriority_reg_read ;\nlogic                                        intenable_reg_read   ;\nlogic                                        gw_config_reg_read   ;\nlogic                                        picm_wren_ff , picm_rden_ff ;\nlogic                                        picm_rd_thr_ff;\nlogic [31:0]                                 picm_raddr_ff;\nlogic [31:0]                                 picm_waddr_ff;\nlogic [31:0]                                 picm_wr_data_ff;\nlogic [3:0]                                  mask;\nlogic                                        picm_mken_ff;\nlogic [ID_BITS-1:0]                          claimid_in ;\nlogic [INTPRIORITY_BITS-1:0]                 pl_in ;\nlogic [INTPRIORITY_BITS-1:0]                 pl_in_q ;\n\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        extintsrc_req_sync;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        extintsrc_req_gw;\nlogic [pt.PIC_TOTAL_INT_PLUS1-1:0]                        thr_mx_intpend_reg;\nlogic                                                     picm_bypass_ff;\nlogic                                                     delg_reg_read;\n\nlogic [(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2)):0] [INTPRIORITY_BITS-1:0] l2_intpend_w_prior_en_ff;\nlogic [(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2)):0] [ID_BITS-1:0]          l2_intpend_id_ff;\nlogic [NUM_LEVELS:NUM_LEVELS/2] [(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2))+1:0] [INTPRIORITY_BITS-1:0] levelx_intpend_w_prior_en;\nlogic [NUM_LEVELS:NUM_LEVELS/2] [(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2))+1:0] [ID_BITS-1:0]          levelx_intpend_id;\n\n// clkens\n   logic                                     pic_raddr_c1_clken;\n   logic                                     pic_waddr_c1_clken;\n   logic                                     pic_data_c1_clken;\n   logic                                     pic_pri_c1_clken;\n   logic                                     pic_int_c1_clken;\n   logic                                     pic_del_c1_clken;\n   logic                                     gw_config_c1_clken;\n\n// clocks\n   logic                                     pic_raddr_c1_clk;\n   logic                                     pic_data_c1_clk;\n   logic                                     pic_pri_c1_clk;\n   logic                                     pic_int_c1_clk;\n   logic                                     pic_del_c1_clk;\n   logic                                     gw_config_c1_clk;\n   logic                                     nxt_thr;\n\n\n\n\n// ---- Clock gating section ------\n// c1 clock enables\n   assign pic_raddr_c1_clken  = picm_mken | picm_rden | clk_override;\n   assign pic_data_c1_clken   = picm_wren | clk_override;\n   assign pic_pri_c1_clken    = (waddr_intpriority_base_match & picm_wren_ff)  | (raddr_intpriority_base_match & picm_rden_ff) | clk_override;\n   assign pic_int_c1_clken    = (waddr_intenable_base_match   & picm_wren_ff)  | (raddr_intenable_base_match   & picm_rden_ff) | clk_override;\n   assign gw_config_c1_clken  = (waddr_config_gw_base_match   & picm_wren_ff)  | (raddr_config_gw_base_match   & picm_rden_ff) | clk_override;\n\n   // C1 - 1 clock pulse for data\n   rvoclkhdr pic_addr_c1_cgc   ( .en(pic_raddr_c1_clken),  .l1clk(pic_raddr_c1_clk), .* );\n   rvoclkhdr pic_data_c1_cgc   ( .en(pic_data_c1_clken),   .l1clk(pic_data_c1_clk), .* );\n   rvoclkhdr pic_pri_c1_cgc    ( .en(pic_pri_c1_clken),    .l1clk(pic_pri_c1_clk),  .* );\n   rvoclkhdr pic_int_c1_cgc    ( .en(pic_int_c1_clken),    .l1clk(pic_int_c1_clk),  .* );\n   rvoclkhdr gw_config_c1_cgc  ( .en(gw_config_c1_clken),  .l1clk(gw_config_c1_clk),  .* );\n\n// ------ end clock gating section ------------------------\n\nassign raddr_intenable_base_match   = (picm_raddr_ff[31:NUM_LEVELS+2] == INTENABLE_BASE_ADDR[31:NUM_LEVELS+2]) ;\nassign raddr_intpriority_base_match = (picm_raddr_ff[31:NUM_LEVELS+2] == INTPRIORITY_BASE_ADDR[31:NUM_LEVELS+2]) ;\nassign raddr_config_gw_base_match   = (picm_raddr_ff[31:NUM_LEVELS+2] == EXT_INTR_GW_CONFIG[31:NUM_LEVELS+2]) ;\nassign raddr_config_pic_match       = (picm_raddr_ff[31:0]            == EXT_INTR_PIC_CONFIG[31:0]) ;\n\nassign addr_intpend_base_match      = (picm_raddr_ff[31:6]            == INTPEND_BASE_ADDR[31:6]) ;\n\nassign waddr_config_pic_match       = (picm_waddr_ff[31:0]            == EXT_INTR_PIC_CONFIG[31:0]) ;\nassign addr_clear_gw_base_match     = (picm_waddr_ff[31:NUM_LEVELS+2] == EXT_INTR_GW_CLEAR[31:NUM_LEVELS+2]) ;\nassign waddr_intpriority_base_match = (picm_waddr_ff[31:NUM_LEVELS+2] == INTPRIORITY_BASE_ADDR[31:NUM_LEVELS+2]) ;\nassign waddr_intenable_base_match   = (picm_waddr_ff[31:NUM_LEVELS+2] == INTENABLE_BASE_ADDR[31:NUM_LEVELS+2]) ;\nassign waddr_config_gw_base_match   = (picm_waddr_ff[31:NUM_LEVELS+2] == EXT_INTR_GW_CONFIG[31:NUM_LEVELS+2]) ;\n\nif (pt.NUM_THREADS > 1 ) begin:  gt_1_thr\n   assign pic_del_c1_clken    = (waddr_delg_base_match        & picm_wren_ff)  | (raddr_delg_base_match        & picm_rden_ff) | clk_override;\n   rvoclkhdr pic_del_c1_cgc    ( .en(pic_del_c1_clken),    .l1clk(pic_del_c1_clk),  .* );\n   assign raddr_delg_base_match        = (picm_raddr_ff[31:NUM_LEVELS+2] == EXT_INTR_DELG_REG[31:NUM_LEVELS+2]) ;\n   assign waddr_delg_base_match        = (picm_waddr_ff[31:NUM_LEVELS+2] == EXT_INTR_DELG_REG[31:NUM_LEVELS+2]) ;\n   assign addr_intpend_thr_base_match  = (picm_raddr_ff[31:6]            == INTPEND_THR_BASE_ADDR[31:6]) ;\nend else begin: one_t\n   assign raddr_delg_base_match = 1'b0 ;\n   assign waddr_delg_base_match = 1'b0 ;\n   assign pic_del_c1_clk = 1'b0  ;\n   assign addr_intpend_thr_base_match  = 1'b0;\nend\n\n   assign picm_bypass_ff = picm_rden_ff & picm_wren_ff & ( picm_raddr_ff[31:0] == picm_waddr_ff[31:0] );    // pic writes and reads to same address together\n\n\nrvdff #(32) picm_radd_flop  (.*, .din (picm_rdaddr),        .dout(picm_raddr_ff),         .clk(pic_raddr_c1_clk));\nrvdff #(32) picm_wadd_flop  (.*, .din (picm_wraddr),        .dout(picm_waddr_ff),         .clk(pic_data_c1_clk));\nrvdff  #(1) picm_wre_flop   (.*, .din (picm_wren),          .dout(picm_wren_ff),          .clk(free_clk));\nrvdff  #(1) picm_rde_flop   (.*, .din (picm_rden),          .dout(picm_rden_ff),          .clk(free_clk));\nrvdff  #(1) picm_rdt_flop   (.*, .din (picm_rd_thr),        .dout(picm_rd_thr_ff),        .clk(free_clk));\nrvdff  #(1) picm_mke_flop   (.*, .din (picm_mken),          .dout(picm_mken_ff),          .clk(free_clk));\nrvdff #(32) picm_dat_flop   (.*, .din (picm_wr_data[31:0]), .dout(picm_wr_data_ff[31:0]), .clk(pic_data_c1_clk));\n\n\n\n   if (pt.NUM_THREADS==1)\n     assign curr_int_tid = '0;\n   else begin\n\n      logic ready_pulse;\n      logic [2:0] ready_cnt_in, ready_cnt;\n      logic [1:0] ready;\n      logic [1:0] active_thread;\n      logic       active1;\n      logic       active2;\n      logic       favor;\n      logic       tid;\n\n\n      assign ready_pulse = ready_cnt[2:0] == 3'b111;\n\n      assign ready_cnt_in[2:0] = (ready_pulse) ? '0 : ready_cnt[2:0] + 3'b1;\n\n      rvdff #(3) ready_cntff (.*, .din(ready_cnt_in[2:0]), .dout(ready_cnt[2:0]), .clk(free_clk));\n\n\n      assign active_thread[1:0] = (~o_cpu_halt_status[1:0] | {2{io_clk_override}});\n      assign active1            = ^active_thread[1:0] ;\n      assign active2            = &active_thread[1:0] ;\n\n\n\n      assign ready[1:0] = (active2) ? 2'b11 :\n                          (active1 & ~ready_pulse) ?  active_thread[1:0] :\n                          (active1 &  ready_pulse) ? ~active_thread[1:0] :\n                          {2{ready_pulse}};\n\n\n      rvarbiter2_pic pic_arbiter (.*,\n                                  .clk(free_clk),\n                                  .shift(1'b1),\n                                  .tid(tid),\n                                  .favor(favor)\n                                  );\n\n      assign curr_int_tid = (|ready[1:0]) ? tid : favor;\n\n   end\n\n\n   rvdff  #(1) curr_thr_ff   (.*, .din (curr_int_tid),     .dout(curr_int_tid_ff),          .clk(free_clk));\n\nif (pt.PIC_2CYCLE == 1) begin : pic2cyle\n   assign curr_int_tid_final_in = curr_int_tid_ff ;\n   rvdff  #(1) curr_thr_ff2  (.*, .din (curr_int_tid_ff),  .dout(curr_int_tid_final),          .clk(free_clk));\nend else begin: not_pic2cycle\n   assign curr_int_tid_final_in = curr_int_tid ;\n   assign curr_int_tid_final = curr_int_tid_ff ;\nend\n\n\n\n\ngenvar i ;\ngenvar p ;\nfor (p=0; p<=INT_ENABLE_GRPS ; p++) begin  : IO_CLK_GRP\nwire grp_clk, grp_clken;\n\n    assign grp_clken = |intenable_clk_enable[(p==INT_ENABLE_GRPS?pt.PIC_TOTAL_INT_PLUS1-1:p*4+3) : p*4] | io_clk_override;\n\n  `ifndef RV_FPGA_OPTIMIZE\n    rvclkhdr intenable_c1_cgc( .en(grp_clken),  .l1clk(grp_clk), .* );\n  `else\n    assign gw_clk[p] = 1'b0 ;\n  `endif\n\n\n    for(genvar i= (p==0 ? 1: 0); i< (p==INT_ENABLE_GRPS ? pt.PIC_TOTAL_INT_PLUS1-p*4 :4); i++) begin : GW\n        eh2_configurable_gw gw_inst(\n             .*,\n            .gw_clk(grp_clk),\n            .rawclk(clk),\n            .clken (grp_clken),\n            .extintsrc_req(extintsrc_req[i+p*4]) ,\n            .meigwctrl_polarity(gw_config_reg[i+p*4][0]) ,\n            .meigwctrl_type(gw_config_reg[i+p*4][1]) ,\n            .meigwclr(gw_clear_reg_we[i+p*4]) ,\n            .extintsrc_req_config(extintsrc_req_gw[i+p*4])\n        );\n    end\nend\n\nfor (i=0; i<pt.PIC_TOTAL_INT_PLUS1 ; i++) begin  : SETREG\n\n if (i > 0 ) begin : NON_ZERO_INT\n     assign intpriority_reg_we[i] =  waddr_intpriority_base_match & (picm_waddr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff;\n     assign intpriority_reg_re[i] =  raddr_intpriority_base_match & (picm_raddr_ff[NUM_LEVELS+1:2] == i) & picm_rden_ff;\n\n     assign intenable_reg_we[i]   =  waddr_intenable_base_match   & (picm_waddr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff;\n     assign intenable_reg_re[i]   =  raddr_intenable_base_match   & (picm_raddr_ff[NUM_LEVELS+1:2] == i) & picm_rden_ff;\n\n     if (pt.NUM_THREADS > 1 ) begin:   gt_1_thr\n          assign delg_reg_we[i]   =  waddr_delg_base_match   & (picm_waddr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff;\n          assign delg_reg_re[i]   =  raddr_delg_base_match   & (picm_raddr_ff[NUM_LEVELS+1:2] == i) & picm_rden_ff;\n          rvdffs #(1)                 delg_ff        (.*, .en( delg_reg_we[i]),        .din (picm_wr_data_ff[0]),                    .dout(delg_reg[i]),        .clk(pic_del_c1_clk));\n     end else begin: one_t\n          assign delg_reg_re[i] = 1'b0 ;\n          assign delg_reg_we[i] = 1'b0 ;\n          assign delg_reg[i]    = 1'b0;\n     end\n\n\n     assign gw_config_reg_we[i]   =  waddr_config_gw_base_match   & (picm_waddr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff;\n     assign gw_config_reg_re[i]   =  raddr_config_gw_base_match   & (picm_raddr_ff[NUM_LEVELS+1:2] == i) & picm_rden_ff;\n\n     assign gw_clear_reg_we[i]    =  addr_clear_gw_base_match     & (picm_waddr_ff[NUM_LEVELS+1:2] == i) & picm_wren_ff ;\n\n     rvdffs #(INTPRIORITY_BITS) intpriority_ff  (.*, .en( intpriority_reg_we[i]), .din (picm_wr_data_ff[INTPRIORITY_BITS-1:0]), .dout(intpriority_reg[i]), .clk(pic_pri_c1_clk));\n     rvdffs #(1)                 intenable_ff   (.*, .en( intenable_reg_we[i]),   .din (picm_"}
{"text": "wr_data_ff[0]),                    .dout(intenable_reg[i]),   .clk(pic_int_c1_clk));\n     rvdffs #(2)                 gw_config_ff   (.*, .en( gw_config_reg_we[i]),   .din (picm_wr_data_ff[1:0]),                  .dout(gw_config_reg[i]),   .clk(gw_config_c1_clk));\n\n     assign intenable_clk_enable[i]  =  gw_config_reg[i][1] | intenable_reg_we[i] | intenable_reg[i] | gw_clear_reg_we[i] ;\n\n\n end else begin : INT_ZERO\n     assign intpriority_reg_we[i] =  1'b0 ;\n     assign intpriority_reg_re[i] =  1'b0 ;\n     assign intenable_reg_we[i]   =  1'b0 ;\n     assign intenable_reg_re[i]   =  1'b0 ;\n     assign delg_reg_re[i]        =  1'b0 ;\n     assign delg_reg_we[i]        =  1'b0 ;\n     assign gw_config_reg_we[i]   =  1'b0 ;\n     assign gw_config_reg_re[i]   =  1'b0 ;\n     assign gw_clear_reg_we[i]    =  1'b0 ;\n\n     assign gw_config_reg[i]    = '0 ;\n\n     assign intpriority_reg[i] = {INTPRIORITY_BITS{1'b0}} ;\n     assign intenable_reg[i]   = 1'b0 ;\n     assign delg_reg[i]        = 1'b0 ;\n     assign extintsrc_req_gw[i] = 1'b0 ;\n     assign extintsrc_req_sync[i]    = 1'b0 ;\n     assign intenable_clk_enable[i] = 1'b0;\n end\n\n\n    assign intpriority_reg_inv[i] =  intpriord ? ~intpriority_reg[i] : intpriority_reg[i] ;\n    assign delg_thr_match[i]      =  (delg_reg[i] &  curr_int_tid) |   (~delg_reg[i] & ~curr_int_tid) ;\n\n    assign intpend_w_prior_en[i]  =  {INTPRIORITY_BITS{(extintsrc_req_gw[i] & intenable_reg[i] & delg_thr_match[i])}} & intpriority_reg_inv[i] ;\n    assign intpend_id[i]          =  i ;\nend\n\n\n        assign pl_in[INTPRIORITY_BITS-1:0]                  =      selected_int_priority[INTPRIORITY_BITS-1:0] ;\n\n\n genvar l, m , j, k;\n\nif (pt.PIC_2CYCLE == 1) begin : genblock\n        logic [NUM_LEVELS/2:0] [pt.PIC_TOTAL_INT_PLUS1+2:0] [INTPRIORITY_BITS-1:0] level_intpend_w_prior_en;\n        logic [NUM_LEVELS/2:0] [pt.PIC_TOTAL_INT_PLUS1+2:0] [ID_BITS-1:0]          level_intpend_id;\n\n        assign level_intpend_w_prior_en[0][pt.PIC_TOTAL_INT_PLUS1+2:0] = {4'b0,4'b0,4'b0,intpend_w_prior_en[pt.PIC_TOTAL_INT_PLUS1-1:0]} ;\n        assign level_intpend_id[0][pt.PIC_TOTAL_INT_PLUS1+2:0]         = {8'b0,8'b0,8'b0,intpend_id[pt.PIC_TOTAL_INT_PLUS1-1:0]} ;\n\n\n        assign levelx_intpend_w_prior_en[NUM_LEVELS/2][(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2))+1:0] = {{1*INTPRIORITY_BITS{1'b0}},l2_intpend_w_prior_en_ff[(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2)):0]} ;\n        assign levelx_intpend_id[NUM_LEVELS/2][(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2))+1:0]         = {{1*ID_BITS{1'b1}},l2_intpend_id_ff[(pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2)):0]} ;\n///  Do the prioritization of the interrupts here  ////////////\n for (l=0; l<NUM_LEVELS/2 ; l++) begin : TOP_LEVEL\n    for (m=0; m<=(pt.PIC_TOTAL_INT_PLUS1)/(2**(l+1)) ; m++) begin : COMPARE\n       if ( m == (pt.PIC_TOTAL_INT_PLUS1)/(2**(l+1))) begin\n            assign level_intpend_w_prior_en[l+1][m+1] = '0 ;\n            assign level_intpend_id[l+1][m+1]         = '0 ;\n       end\n       eh2_cmp_and_mux  #(.ID_BITS(ID_BITS),\n                      .INTPRIORITY_BITS(INTPRIORITY_BITS)) cmp_l1 (\n                      .a_id(level_intpend_id[l][2*m]),\n                      .a_priority(level_intpend_w_prior_en[l][2*m]),\n                      .b_id(level_intpend_id[l][2*m+1]),\n                      .b_priority(level_intpend_w_prior_en[l][2*m+1]),\n                      .out_id(level_intpend_id[l+1][m]),\n                      .out_priority(level_intpend_w_prior_en[l+1][m])) ;\n\n    end\n end\n\n        for (i=0; i<=pt.PIC_TOTAL_INT_PLUS1/2**(NUM_LEVELS/2) ; i++) begin : MIDDLE_FLOPS\n\n           rvdffie #(INTPRIORITY_BITS+ID_BITS) level2_intpend_reg  (.*,\n                                                                    .din ({level_intpend_w_prior_en[NUM_LEVELS/2][i], level_intpend_id[NUM_LEVELS/2][i]}),\n                                                                    .dout({l2_intpend_w_prior_en_ff[i],               l2_intpend_id_ff[i]})\n                                                                    );\n        end\n\n for (j=NUM_LEVELS/2; j<NUM_LEVELS ; j++) begin : BOT_LEVELS\n    for (k=0; k<=(pt.PIC_TOTAL_INT_PLUS1)/(2**(j+1)) ; k++) begin : COMPARE\n       if ( k == (pt.PIC_TOTAL_INT_PLUS1)/(2**(j+1))) begin\n            assign levelx_intpend_w_prior_en[j+1][k+1] = '0 ;\n            assign levelx_intpend_id[j+1][k+1]         = '0 ;\n       end\n            eh2_cmp_and_mux  #(.ID_BITS(ID_BITS),\n                        .INTPRIORITY_BITS(INTPRIORITY_BITS))\n                 cmp_l1 (\n                        .a_id(levelx_intpend_id[j][2*k]),\n                        .a_priority(levelx_intpend_w_prior_en[j][2*k]),\n                        .b_id(levelx_intpend_id[j][2*k+1]),\n                        .b_priority(levelx_intpend_w_prior_en[j][2*k+1]),\n                        .out_id(levelx_intpend_id[j+1][k]),\n                        .out_priority(levelx_intpend_w_prior_en[j+1][k])) ;\n    end\n  end\n\n        assign claimid_in[ID_BITS-1:0]                      =      levelx_intpend_id[NUM_LEVELS][0] ;   // This is the last level output\n        assign selected_int_priority[INTPRIORITY_BITS-1:0]  =      levelx_intpend_w_prior_en[NUM_LEVELS][0] ;\nend\nelse begin : genblock\n\n        logic [NUM_LEVELS:0] [pt.PIC_TOTAL_INT_PLUS1+1:0] [INTPRIORITY_BITS-1:0] level_intpend_w_prior_en;\n        logic [NUM_LEVELS:0] [pt.PIC_TOTAL_INT_PLUS1+1:0] [ID_BITS-1:0]          level_intpend_id;\n\n        assign level_intpend_w_prior_en[0][pt.PIC_TOTAL_INT_PLUS1+1:0] = {{2*INTPRIORITY_BITS{1'b0}},intpend_w_prior_en[pt.PIC_TOTAL_INT_PLUS1-1:0]} ;\n        assign level_intpend_id[0][pt.PIC_TOTAL_INT_PLUS1+1:0] = {{2*ID_BITS{1'b1}},intpend_id[pt.PIC_TOTAL_INT_PLUS1-1:0]} ;\n\n///  Do the prioritization of the interrupts here  ////////////\n// genvar l, m , j, k;  already declared outside ifdef\n for (l=0; l<NUM_LEVELS ; l++) begin : LEVEL\n    for (m=0; m<=(pt.PIC_TOTAL_INT_PLUS1)/(2**(l+1)) ; m++) begin : COMPARE\n       if ( m == (pt.PIC_TOTAL_INT_PLUS1)/(2**(l+1))) begin\n            assign level_intpend_w_prior_en[l+1][m+1] = '0 ;\n            assign level_intpend_id[l+1][m+1]         = '0 ;\n       end\n       eh2_cmp_and_mux  #(.ID_BITS(ID_BITS),\n                      .INTPRIORITY_BITS(INTPRIORITY_BITS)) cmp_l1 (\n                      .a_id(level_intpend_id[l][2*m]),\n                      .a_priority(level_intpend_w_prior_en[l][2*m]),\n                      .b_id(level_intpend_id[l][2*m+1]),\n                      .b_priority(level_intpend_w_prior_en[l][2*m+1]),\n                      .out_id(level_intpend_id[l+1][m]),\n                      .out_priority(level_intpend_w_prior_en[l+1][m])) ;\n\n    end\n end\n        assign claimid_in[ID_BITS-1:0]                      =      level_intpend_id[NUM_LEVELS][0] ;   // This is the last level output\n        assign selected_int_priority[INTPRIORITY_BITS-1:0]  =      level_intpend_w_prior_en[NUM_LEVELS][0] ;\n\nend\n\n\n\n///////////////////////////////////////////////////////////////////////\n// Config Reg`\n///////////////////////////////////////////////////////////////////////\nassign config_reg_we               =  waddr_config_pic_match & picm_wren_ff;\nassign config_reg_re               =  raddr_config_pic_match & picm_rden_ff;\n\nassign config_reg_in  =  picm_wr_data_ff[0] ;   //\nrvdffs #(1) config_reg_ff  (.*, .clk(free_clk), .en(config_reg_we), .din (config_reg_in), .dout(config_reg));\n\nassign intpriord  = config_reg ;\n\n\n//////////////////////////////////////////////////////////////////////////\n// Send the interrupt to the core if it is above the thresh-hold\n//////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n/// ClaimId  Reg and Corresponding PL\n///////////////////////////////////////////////////////////\nassign pl_in_q[INTPRIORITY_BITS-1:0] = intpriord ? ~pl_in : pl_in ;\n\nif (pt.NUM_THREADS > 1 ) begin:   more_than_1_thr\n\n//  Per thread hold flops\n\n  rvdffe  #(.WIDTH(1),.OVERRIDE(1))                mexintpend_fl_thr0  (.*, .din (mexintpend_in ), .dout(mexintpend[0]), .en(~curr_int_tid_final_in));\n  rvdffe  #(.WIDTH(1),.OVERRIDE(1))                mexintpend_fl_thr1  (.*, .din (mexintpend_in ), .dout(mexintpend[1]), .en( curr_int_tid_final_in));\n\n  rvdffe  #(.WIDTH(INTPRIORITY_BITS),.OVERRIDE(1)) pl_fl_thr0      (.*, .din (pl_in_q[INTPRIORITY_BITS-1:0]), .dout(pl[0][INTPRIORITY_BITS-1:0]), .en(~curr_int_tid_final_in));\n  rvdffe  #(.WIDTH(INTPRIORITY_BITS),.OVERRIDE(1)) pl_fl_thr1      (.*, .din (pl_in_q[INTPRIORITY_BITS-1:0]), .dout(pl[1][INTPRIORITY_BITS-1:0]), .en( curr_int_tid_final_in));\n\n  rvdffe  #(.WIDTH(ID_BITS),.OVERRIDE(1))          claimid_fl_thr0 (.*, .din (claimid_in[ID_BITS-1:00]),      .dout(claimid[0][ID_BITS-1:00]), .en(~curr_int_tid_final_in));\n  rvdffe  #(.WIDTH(ID_BITS),.OVERRIDE(1))          claimid_fl_thr1 (.*, .din (claimid_in[ID_BITS-1:00]),      .dout(claimid[1][ID_BITS-1:00]), .en( curr_int_tid_final_in));\n\n  rvdffe  #(.WIDTH(1),.OVERRIDE(1))                wake_up_ff_thr0      (.*, .din (mhwakeup_in),    .dout(mhwakeup[0]),       .en(~curr_int_tid_final_in));\n  rvdffe  #(.WIDTH(1),.OVERRIDE(1))                wake_up_ff_thr1      (.*, .din (mhwakeup_in),    .dout(mhwakeup[1]),       .en( curr_int_tid_final_in));\n\n///////\n\n\n  rvdffie #(2*ID_BITS)          claimid_ff_f2     (.*, .din (claimid),      .dout(claimid_ff) );\n  rvdff   #(2*INTPRIORITY_BITS) pl_ff_f2          (.*, .din (pl),           .dout(pl_ff), .clk(free_clk));\n  rvdff   #(2)                  mexintpend_ff_f2  (.*, .clk(free_clk),      .din (mexintpend[1:0]), .dout(mexintpend_ff[1:0]));\n  rvdff   #(2)                  wake_up_ff_f2     (.*, .clk(free_clk),      .din (mhwakeup[1:0]),   .dout(mhwakeup_ff[1:0]));\n\n  assign claimid_out[0]  =  curr_int_tid_final ?  claimid_ff[0] : claimid[0] ;\n  assign claimid_out[1]  = ~curr_int_tid_final ?  claimid_ff[1] : claimid[1] ;\n\n  assign  pl_out[0]      =  curr_int_tid_final ?  pl_ff[0]: pl[0];\n  assign  pl_out[1]      = ~curr_int_tid_final ?  pl_ff[1]: pl[1];\n\n  assign  mexintpend_out[0]      =  curr_int_tid_final ?  mexintpend_ff[0] : mexintpend[0] ;\n  assign  mexintpend_out[1]      = ~curr_int_tid_final ?  mexintpend_ff[1] : mexintpend[1] ;\n\n  assign mhwakeup_out[0] =    curr_int_tid_final ?   mhwakeup_ff[0] : mhwakeup[0] ;\n  assign mhwakeup_out[1] =   ~curr_int_tid_final ?   mhwakeup_ff[1] : mhwakeup[1] ;\n\n  assign meipt    =  curr_int_tid_final_in ? dec_tlu_meipt[1]    : dec_tlu_meipt[0] ;\n  assign meicurpl =  curr_int_tid_final_in ? dec_tlu_meicurpl[1] : dec_tlu_meicurpl[0] ;\n\nend else begin : one_thread\n\n  rvdff   #(1)                mexintpend_fl (.*,  .din (mexintpend_in),                 .dout(mexintpend), .clk(free_clk));\n  rvdffie #(ID_BITS)          claimid_fl    (.*,  .din (claimid_in[ID_BITS-1:00]),      .dout(claimid) );\n  rvdff   #(INTPRIORITY_BITS) pl_fl         (.*,  .din (pl_in_q[INTPRIORITY_BITS-1:0]), .dout(pl),         .clk(free_clk));\n  rvdff   #(1)                wake_up_ff    (.*,  .din (mhwakeup_in),                   .dout(mhwakeup),   .clk(free_clk));\n\n\n  assign claimid_out[pt.NUM_THREADS-1:0]    = claimid[pt.NUM_THREADS-1:0];\n  assign pl_out[pt.NUM_THREADS-1:0]         = pl[pt.NUM_THREADS-1:0] ;\n  assign mexintpend_out[pt.NUM_THREADS-1:0] = mexintpend[pt.NUM_THREADS-1:0] ;\n  assign mhwakeup_out[pt.NUM_THREADS-1:0]   = mhwakeup[pt.NUM_THREADS-1:0] ;\n\n  assign meipt    =  dec_tlu_meipt[0] ;\n  assign meicurpl =  dec_tlu_meicurpl[0] ;\n\nend\n\nassign meipt_inv[INTPRIORITY_BITS-1:0]    = intpriord ? ~meipt[INTPRIORITY_BITS-1:0]    : meipt[INTPRIORITY_BITS-1:0] ;\nassign meicurpl_inv[INTPRIORITY_BITS-1:0] = intpriord ? ~meicurpl[INTPRIORITY_BITS-1:0] : meicurpl[INTPRIORITY_BITS-1:0] ;\nassign mexintpend_in = (( selected_int_priority[INTPRIORITY_BITS-1:0] > meipt_inv[INTPRIORITY_BITS-1:0]) &\n                        ( selected_int_priority[INTPRIORITY_BITS-1:0] > meicurpl_inv[INTPRIORITY_BITS-1:0]) );\n\nassign maxint[INTPRIORITY_BITS-1:0]      =  intpriord ? 0 : 15 ;\nassign mhwakeup_in = ( pl_in_q[INTPRIORITY_BITS-1:0] == maxint) ;\n\n\n\n//////////////////////////////////////////////////////////////////////////\n//  Reads of register.\n//  1- intpending\n//////////////////////////////////////////////////////////////////////////\n\nassign intpend_reg_read     =  addr_intpend_base_match      & picm_rden_ff ;\nassign intpend_thr_reg_read =  addr_intpend_thr_base_match  & picm_rden_ff ;\nassign intpriority_reg_read =  raddr_intpriority_base_match & picm_rden_ff;\nassign intenable_reg_read   =  raddr_intenable_base_match   & picm_rden_ff;\nassign delg_reg_read        =  raddr_delg_base_match        & picm_rden_ff;\nassign gw_config_reg_read   =  raddr_config_gw_base_match   & picm_rden_ff;\n\nassign thr_mx_intpend_reg[pt.PIC_TOTAL_INT_PLUS1-1:0]   = picm_rd_thr_ff ? {(extintsrc_req_gw[pt.PIC_TOTAL_INT_PLUS1-1:0] &  delg_reg[pt.PIC_TOTAL_INT_PLUS1-1:0]) } :\n                                                                           {(extintsrc_req_gw[pt.PIC_TOTAL_INT_PLUS1-1:0] & ~delg_reg[pt.PIC_TOTAL_INT_PLUS1-1:0]) } ;\n\nassign intpend_reg_extended[INTPEND_SIZE-1:0]       = {{INTPEND_SIZE-pt.PIC_TOTAL_INT_PLUS1{1'b0}},extintsrc_req_gw[pt.PIC_TOTAL_INT_PLUS1-1:0]} ;\nassign thr_mx_intpend_reg_extended[INTPEND_SIZE-1:0]= {{INTPEND_SIZE-pt.PIC_TOTAL_INT_PLUS1{1'b0}},thr_mx_intpend_reg[pt.PIC_TOTAL_INT_PLUS1-1:0]} ;\n\n   for (i=0; i<(INT_GRPS); i++) begin\n            assign intpend_rd_part_out[i]     =  (({32{intpend_reg_read     &  (picm_raddr_ff[5:2] == i)}}) & intpend_reg_extended[((32*i)+31):(32*i)]) ;\n            assign intpend_thr_rd_part_out[i] =  (({32{intpend_thr_reg_read &  (picm_raddr_ff[5:2] == i)}}) & thr_mx_intpend_reg_extended[((32*i)+31):(32*i)]) ;\n   end\n\n   always_comb begin : INTPEND_RD\n         intpend_rd_out =  '0 ;\n         intpend_thr_rd_out =  '0 ;\n         for (int i=0; i<INT_GRPS; i++) begin\n               intpend_rd_out     |=  intpend_rd_part_out[i] ;\n               intpend_thr_rd_out |=  intpend_thr_rd_part_out[i] ;\n         end\n   end\n\n   always_comb begin : INTEN_RD\n         intenable_rd_out =  '0 ;\n         delg_rd_out =  '0 ;\n         intpriority_rd_out =  '0 ;\n         gw_config_rd_out =  '0 ;\n         for (int i=0; i<pt.PIC_TOTAL_INT_PLUS1; i++) begin\n              if (intenable_reg_re[i]) begin\n               intenable_rd_out    =  intenable_reg[i]  ;\n              end\n              if (delg_reg_re[i]) begin\n               delg_rd_out    =  delg_reg[i]  ;\n              end\n              if (intpriority_reg_re[i]) begin\n               intpriority_rd_out  =  intpriority_reg[i] ;\n              end\n              if (gw_config_reg_re[i]) begin\n               gw_config_rd_out  =  gw_config_reg[i] ;\n              end\n         end\n   end\n\n\n assign picm_rd_data_in[31:0] = ({32{intpend_reg_read      }} &   intpend_rd_out                                                    ) |\n                                ({32{intpend_thr_reg_read  }} &   intpend_thr_rd_out                                                ) |\n                                ({32{intpriority_reg_read  }} &  {{32-INTPRIORITY_BITS{1'b0}}, intpriority_rd_out                 } ) |\n                                ({32{intenable_reg_read    }} &  {31'b0 , intenable_rd_out                                        } ) |\n                                ({32{delg_reg_read         }} &  {31'b0 , delg_rd_out                                             } ) |\n                                ({32{gw_config_reg_read    }} &  {30'b0 , gw_config_rd_out                                        } ) |\n                                ({32{config_reg_re         }} &  {31'b0 , config_reg                                              } ) |\n                                ({32{picm_mken_ff & mask[3]}} &  {30'b0 , 2'b11                                                   } ) |\n                                ({32{picm_mken_ff & mask[2]}} &  {31'b0 , 1'b1                                                    } ) |\n                                ({32{picm_mken_ff & mask[1]}} &  {28'b0 , 4'b1111                                                 } ) |\n                                ({32{picm_mken_ff & mask[0]}} &   32'b0                                                             ) ;\n\n\nassign picm_rd_data[31:0] = picm_bypass_ff ? picm_wr_data_ff[31:0] : picm_rd_data_in[31:0] ;\n\nlogic [14:0] address;\n\nassign address[14:0] = picm_raddr_ff[14:0];\n\n`include \"pic_map_auto.h\"\n\nendmodule\n\n\nmodule eh2_cmp_and_mux #(parameter ID_BITS=8,\n                               INTPRIORITY_BITS = 4)\n                    (\n                        input  logic [ID_BITS-1:0]       a_id,\n                        input  logic [INTPRIORITY_BITS-1:0] a_priority,\n\n                        input  logic [ID_BITS-1:0]       b_id,\n                        input  logic [INTPRIORITY_BITS-1:0] b_priority,\n\n                        output logic [ID_BITS-1:0]       out_id,\n                        output logic [INTPRIORITY_BITS-1:0] out_priority\n\n                    );\n\nlogic   a_is_lt_b ;\n\nassign  a_is_lt_b  = ( a_priority[INTPRIORITY_BITS-1:0] < b_priority[INTPRIORITY_BITS-1:0] ) ;\n\nassign  out_id[ID_BITS-1:0]                = a_is_lt_b ? b_id[ID_BITS-1:0] :\n                                                         a_id[ID_BITS-1:0] ;\nassign  out_priority[INTPRIORITY_BITS-1:0] = a_is_lt_b ? b_priority[INTPRIORITY_BITS-1:0] :\n                                                         a_priority[INTPRIORITY_BITS-1:0] ;\nendmodule // cmp_and_mux\n\n\nmodule eh2_configurable_gw (\n                             input logic gw_clk,\n                             input logic rawclk,\n                             input logic clken,\n                             input logic rst_l,\n                             input logic extintsrc_req,\n                             input logic meigwctrl_polarity ,\n                             input logic meigwctrl_type ,\n                             input logic meigwclr ,\n\n                             output logic extintsrc_req_config\n                            );\n\n  logic  gw_int_pending_in, gw_int_pending, extintsrc_req_sync;\n\n  rvsyncss_fpga  #(1) sync_inst (\n      .dout        (extintsrc_req_sync),\n      .din         (extintsrc_req),\n      .*) ;\n  assign gw_int_pending_in =  (extintsrc_req_sync ^ meigwctrl_polarity) | (gw_int_pending & ~meigwclr) ;\n rvdff_fpga #(1) int_pend_ff        (.*, .clk(gw_clk), .rawclk(rawclk), .clken(clken), .din (gw_int_pending_in),     .dout(gw_int_pending));\n\n\n  assign extintsrc_req_config =  meigwctrl_type ? ((extintsrc_req_sync ^  meigwctrl_polarity) | gw_int_pending) : (extintsrc_req_sync ^  meigwctrl_polarity) ;\n\nendmodule // configurable_gw\n\n\n\n\n\n\n\n\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n// Function: Top level VEER core file\n// Comments:\n//\n//********************************************************************************\nmodule eh2_veer\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n) (\n   input logic                  clk,\n   input logic                  rst_l,\n   input logic                  dbg_rst_l,  // DM reset\n   input logic [31:1]           rst_vec,\n   input logic                  nmi_int,\n   input logic [31:1]           nmi_vec,\n\n   output logic                 core_rst_l,   // This is \"rst_l | dbg_rst_l\"\n   output logic                 active_l2clk,\n   output logic                 free_l2clk,\n\n   output logic [pt.NUM_THREADS-1:0] [63:0] trace_rv_i_insn_ip,\n   output logic [pt.NUM_THREADS-1:0] [63:0] trace_rv_i_address_ip,\n   output logic [pt.NUM_THREADS-1:0] [1:0]  trace_rv_i_valid_ip,\n   output logic [pt.NUM_THREADS-1:0] [1:0]  trace_rv_i_exception_ip,\n   output logic [pt.NUM_THREADS-1:0] [4:0]  trace_rv_i_ecause_ip,\n   output logic [pt.NUM_THREADS-1:0] [1:0]  trace_rv_i_interrupt_ip,\n   output logic [pt.NUM_THREADS-1:0] [31:0] trace_rv_i_tval_ip,\n\n   output logic                 dccm_clk_override,\n   output logic                 icm_clk_override,\n   output logic                 dec_tlu_core_ecc_disable,\n   output logic                 btb_clk_override,\n\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_mhartstart, // running harts\n\n   // external halt/run interface\n   input logic  [pt.NUM_THREADS-1:0] i_cpu_halt_req,    // Asynchronous Halt request to CPU\n   input logic  [pt.NUM_THREADS-1:0] i_cpu_run_req,     // Asynchronous Restart request to CPU\n   output logic [pt.NUM_THREADS-1:0] o_cpu_halt_status, // PMU interface, halted\n   output logic [pt.NUM_THREADS-1:0] o_cpu_halt_ack,    // Core Acknowledge to Halt request\n   output logic [pt.NUM_THREADS-1:0] o_cpu_run_ack,     // Core Acknowledge to run request\n   output logic [pt.NUM_THREADS-1:0] o_debug_mode_status, // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n\n   input logic [31:4]     core_id, // Core ID\n\n   // external MPC halt/run interface\n   input logic  [pt.NUM_THREADS-1:0] mpc_debug_halt_req, // Async halt request\n   input logic  [pt.NUM_THREADS-1:0] mpc_debug_run_req, // Async run request\n   input logic  [pt.NUM_THREADS-1:0] mpc_reset_run_req, // Run/halt after reset\n   output logic [pt.NUM_THREADS-1:0] mpc_debug_halt_ack, // Halt ack\n   output logic [pt.NUM_THREADS-1:0] mpc_debug_run_ack, // Run ack\n   output logic [pt.NUM_THREADS-1:0] debug_brkpt_status, // debug breakpoint\n\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt0, // toggles when pipe0 perf counter 0 has an event inc\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt1, // toggles when pipe0 perf counter 1 has an event inc\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt2, // toggles when pipe0 perf counter 2 has an event inc\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt3, // toggles when pipe0 perf counter 3 has an event inc\n\n   // DCCM ports\n   output logic                           dccm_wren,\n   output logic                           dccm_rden,\n   output logic [pt.DCCM_BITS-1:0]        dccm_wr_addr_lo,\n   output logic [pt.DCCM_BITS-1:0]        dccm_wr_addr_hi,\n   output logic [pt.DCCM_BITS-1:0]        dccm_rd_addr_lo,\n   output logic [pt.DCCM_BITS-1:0]        dccm_rd_addr_hi,\n   output logic [pt.DCCM_FDATA_WIDTH-1:0] dccm_wr_data_lo,\n   output logic [pt.DCCM_FDATA_WIDTH-1:0] dccm_wr_data_hi,\n\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_lo,\n   input logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_hi,\n\n   // ICCM ports\n   output logic [pt.ICCM_BITS-1:1]  iccm_rw_addr,\n   output logic [pt.NUM_THREADS-1:0]iccm_buf_correct_ecc_thr,            // ICCM is doing a single bit error correct cycle\n   output logic                     iccm_correction_state,               // We are under a correction - This is needed to guard replacements when hit\n   output logic                     iccm_stop_fetch,                     // The fetch needs to be ignored for replacement hit purposes\n   output logic                     iccm_corr_scnd_fetch,                // dont match on middle bank when under correction\n   output logic                  ifc_select_tid_f1,\n   output logic                  iccm_wren,\n   output logic                  iccm_rden,\n   output logic [2:0]            iccm_wr_size,\n   output logic [77:0]           iccm_wr_data,\n\n   input  logic [63:0]           iccm_rd_data,\n   input  logic [116:0]          iccm_rd_data_ecc,\n\n   // ICache , ITAG  ports\n   output logic [31:1]           ic_rw_addr,\n   output logic [pt.ICACHE_NUM_WAYS-1:0]            ic_tag_valid,\n   output logic [pt.ICACHE_NUM_WAYS-1:0]          ic_wr_en  ,         // Which way to write\n   output logic                  ic_rd_en,\n\n   output logic [pt.ICACHE_BANKS_WAY-1:0] [70:0]               ic_wr_data,           // Data to fill to the Icache. With ECC\n   input  logic [63:0]               ic_rd_data ,          // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [70:0]               ic_debug_rd_data ,    // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   input  logic [25:0]               ictag_debug_rd_data,  // Debug icache tag.\n   output logic [70:0]               ic_debug_wr_data,     // Debug wr cache.\n\n   input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_eccerr,    //\n   input  logic [pt.ICACHE_BANKS_WAY-1:0] ic_parerr,\n\n\n   output logic [63:0]               ic_premux_data,     // Premux data to be muxed with each way of the Icache.\n   output logic                      ic_sel_premux_data, // Select premux data\n\n\n   output logic [pt.ICACHE_INDEX_HI:3]            ic_debug_addr,      // Read/Write addresss to the Icache.\n   output logic                      ic_debug_rd_en,     // Icache debug rd\n   output logic                      ic_debug_wr_en,     // Icache debug wr\n   output logic                      ic_debug_tag_array, // Debug tag array\n   output logic [pt.ICACHE_NUM_WAYS-1:0]          ic_debug_way,       // Debug way. Rd or Wr.\n\n\n   input  logic [pt.ICACHE_NUM_WAYS-1:0]            ic_rd_hit,\n   input  logic                  ic_tag_perr,        // Icache Tag parity error\n\n// BTB ports\n   input eh2_btb_sram_pkt btb_sram_pkt,\n\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank0_rd_data_f1,\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank1_rd_data_f1,\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank2_rd_data_f1,\n   input logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]      btb_vbank3_rd_data_f1,\n\n   output logic                         btb_wren,\n   output logic                         btb_rden,\n   output logic [1:0] [pt.BTB_ADDR_HI:1] btb_rw_addr,  // per bank\n   output logic [1:0] [pt.BTB_ADDR_HI:1] btb_rw_addr_f1,  // per bank\n   output logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0]         btb_sram_wr_data,\n   output logic [1:0] [pt.BTB_BTAG_SIZE-1:0] btb_sram_rd_tag_f1,\n\n\n   //-------------------------- LSU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            lsu_axi_awvalid,\n   input  logic                            lsu_axi_awready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_awid,\n   output logic [31:0]                     lsu_axi_awaddr,\n   output logic [3:0]                      lsu_axi_awregion,\n   output logic [7:0]                      lsu_axi_awlen,\n   output logic [2:0]                      lsu_axi_awsize,\n   output logic [1:0]                      lsu_axi_awburst,\n   output logic                            lsu_axi_awlock,\n   output logic [3:0]                      lsu_axi_awcache,\n   output logic [2:0]                      lsu_axi_awprot,\n   output logic [3:0]                      lsu_axi_awqos,\n\n   output logic                            lsu_axi_wvalid,\n   input  logic                            lsu_axi_wready,\n   output logic [63:0]                     lsu_axi_wdata,\n   output logic [7:0]                      lsu_axi_wstrb,\n   output logic                            lsu_axi_wlast,\n\n   input  logic                            lsu_axi_bvalid,\n   output logic                            lsu_axi_bready,\n   input  logic [1:0]                      lsu_axi_bresp,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_bid,\n\n   // AXI Read Channels\n   output logic                            lsu_axi_arvalid,\n   input  logic                            lsu_axi_arready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_arid,\n   output logic [31:0]                     lsu_axi_araddr,\n   output logic [3:0]                      lsu_axi_arregion,\n   output logic [7:0]                      lsu_axi_arlen,\n   output logic [2:0]                      lsu_axi_arsize,\n   output logic [1:0]                      lsu_axi_arburst,\n   output logic                            lsu_axi_arlock,\n   output logic [3:0]                      lsu_axi_arcache,\n   output logic [2:0]                      lsu_axi_arprot,\n   output logic [3:0]                      lsu_axi_arqos,\n\n   input  logic                            lsu_axi_rvalid,\n   output logic                            lsu_axi_rready,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_rid,\n   input  logic [63:0]                     lsu_axi_rdata,\n   input  logic [1:0]                      lsu_axi_rresp,\n   input  logic                            lsu_axi_rlast,\n\n   //-------------------------- IFU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            ifu_axi_awvalid,\n   input  logic                            ifu_axi_awready,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_awid,\n   output logic [31:0]                     ifu_axi_awaddr,\n   output logic [3:0]                      ifu_axi_awregion,\n   output logic [7:0]                      ifu_axi_awlen,\n   output logic [2:0]                      ifu_axi_awsize,\n   output logic [1:0]                      ifu_axi_awburst,\n   output logic                            ifu_axi_awlock,\n   output logic [3:0]                      ifu_axi_awcache,\n   output logic [2:0]                      ifu_axi_awprot,\n   output logic [3:0]                      ifu_axi_awqos,\n\n   output logic                            ifu_axi_wvalid,\n   input  logic                            ifu_axi_wready,\n   output logic [63:0]                     ifu_axi_wdata,\n   output logic [7:0]                      ifu_axi_wstrb,\n   output logic                            ifu_axi_wlast,\n\n   input  logic                            ifu_axi_bvalid,\n   output logic                            ifu_axi_bready,\n   input  logic [1:0]                      ifu_axi_bresp,\n   input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_bid,\n\n   // AXI Read Channels\n   output logic                            ifu_axi_arvalid,\n   input  logic                            ifu_axi_arready,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_arid,\n   output logic [31:0]                     ifu_axi_araddr,\n   output logic [3:0]                      ifu_axi_arregion,\n   output logic [7:0]                      ifu_axi_arlen,\n   output logic [2:0]                      ifu_axi_arsize,\n   output logic [1:0]                      ifu_axi_arburst,\n   output logic                            ifu_axi_arlock,\n   output logic [3:0]                      ifu_axi_arcache,\n   output logic [2:0]                      ifu_axi_arprot,\n   output logic [3:0]                      ifu_axi_arqos,\n\n   input  logic                            ifu_axi_rvalid,\n   output logic                            ifu_axi_rready,\n   input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_rid,\n   input  logic [63:0]                     ifu_axi_rdata,\n   input  logic [1:0]                      ifu_axi_rresp,\n   input  logic                            ifu_axi_rlast,\n\n   //-------------------------- SB AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            sb_axi_awvalid,\n   input  logic                            sb_axi_awready,\n   output logic [pt.SB_BUS_TAG-1:0]        sb_axi_awid,\n   output logic [31:0]                     sb_axi_awaddr,\n   output logic [3:0]                      sb_axi_awregion,\n   output logic [7:0]                      sb_axi_awlen,\n   output logic [2:0]                      sb_axi_awsize,\n   output logic [1:0]                      sb_axi_awburst,\n   output logic                            sb_axi_awlock,\n   output logic [3:0]                      sb_axi_awcache,\n   output logic [2:0]                      sb_axi_awprot,\n   output logic [3:0]                      sb_axi_awqos,\n\n   output logic                            sb_axi_wvalid,\n   input  logic                            sb_axi_wready,\n   output logic [63:0]                     sb_axi_wdata,\n   output logic [7:0]                      sb_axi_wstrb,\n   output logic                            sb_axi_wlast,\n\n   input  logic                            sb_axi_bvalid,\n   output logic                            sb_axi_bready,\n   input  logic [1:0]                      sb_axi_bresp,\n   input  logic [pt.SB_BUS_TAG-1:0]        sb_axi_bid,\n\n   // AXI Read Channels\n   output logic                            sb_axi_arvalid,\n   input  logic                            sb_axi_arready,\n   output logic [pt.SB_BUS_TAG-1:0]        sb_axi_arid,\n   output logic [31:0]                     sb_axi_araddr,\n   output logic [3:0]                      sb_axi_arregion,\n   output logic [7:0]                      sb_axi_arlen,\n   output logic [2:0]                      sb_axi_arsize,\n   output logic [1:0]                      sb_axi_arburst,\n   output logic                            sb_axi_arlock,\n   output logic [3:0]                      sb_axi_arcache,\n   output logic [2:0]                      sb_axi_arprot,\n   output logic [3:0]                      sb_axi_arqos,\n\n   input  logic                            sb_axi_rvalid,\n   output logic                            sb_axi_rready,\n   input  logic [pt.SB_BUS_TAG-1:0]        sb_axi_rid,\n   input  logic [63:0]                     sb_axi_rdata,\n   input  logic [1:0]                      sb_axi_rresp,\n   input  logic                            sb_axi_rlast,\n\n   //-------------------------- DMA AXI signals--------------------------\n   // AXI Write Channels\n   input  logic                         dma_axi_awvalid,\n   output logic                         dma_axi_awready,\n   input  logic [pt.DMA_BUS_TAG-1:0]    dma_axi_awid,\n   input  logic [31:0]                  dma_axi_awaddr,\n   input  logic [2:0]                   dma_axi_awsize,\n   input  logic [2:0]                   dma_axi_awprot,\n   input  logic [7:0]                   dma_axi_awlen,\n   input  logic [1:0]                   dma_axi_awburst,\n\n\n   input  logic                         dma_axi_wvalid,\n   output logic                         dma_axi_wready,\n   input  logic [63:0]                  dma_axi_wdata,\n   input  logic [7:0]                   dma_axi_wstrb,\n   input  logic                         dma_axi_wlast,\n\n   output logic                         dma_axi_bvalid,\n   input  logic                         dma_axi_bready,\n   output logic [1:0]                   dma_axi_bresp,\n   output logic [pt.DMA_BUS_TAG-1:0]    dma_axi_bid,\n\n   // AXI Read Channels\n   input  logic                         dma_axi_arvalid,\n   output logic                         dma_axi_arready,\n   input  logic [pt.DMA_BUS_TAG-1:0]    dma_axi_arid,\n   input  logic [31:0]                  dma_axi_araddr,\n   input  logic [2:0]                   dma_axi_arsize,\n   input  logic [2:0]                   dma_axi_arprot,\n   input  logic [7:0]                   dma_axi_arlen,\n   input  logic [1:0]                   dma_axi_arburst,\n\n   output logic                         dma_axi_rvalid,\n   input  logic                         dma_axi_rready,\n   output logic [pt.DMA_BUS_TAG-1:0]    dma_axi_rid,\n   output logic [63:0]                  dma_axi_rdata,\n   output logic [1:0]                   dma_axi_rresp,\n   output logic                         dma_axi_rlast,\n\n    //// AHB LITE BUS\n   output logic [31:0]           haddr,\n   output logic [2:0]            hburst,\n   output logic                  hmastlock,\n   output logic [3:0]            hprot,\n   output logic [2:0]            hsize,\n   output logic [1:0]            htrans,\n   output logic                  hwrite,\n\n   input  logic [63:0]           hrdata,\n   input  logic                  hready,\n   input  logic                  hresp,\n\n   // LSU AHB Master\n   output logic [31:0]          lsu_haddr,\n   output logic [2:0]           lsu_hburst,\n   output logic                 lsu_hmastlock,\n   output logic [3:0]           lsu_hprot,\n   output logic [2:0]           lsu_hsize,\n   output logic [1:0]           lsu_htrans,\n   output logic                 lsu_hwrite,\n   output logic [63:0]          lsu_hwdata,\n\n   input  logic [63:0]          lsu_hrdata,\n   input  logic                 lsu_hready,\n   input  logic                 lsu_hresp,\n\n   //System Bus Debug Master\n   output logic [31:0]          sb_haddr,\n   output logic [2:0]           sb_hburst,\n   output logic                 sb_hmastlock,\n   output logic [3:0]           sb_hprot,\n   output logic [2:0]           sb_hsize,\n   output logic [1:0]           sb_htrans,\n   output logic                 sb_hwrite,\n   output logic [63:0]          sb_hwdata,\n\n   input  logic [63:0]          sb_hrdata,\n   input  logic                 sb_hready,\n   input  logic                 sb_hresp,\n\n   // DMA Slave\n   input logic [31:0]            dma_haddr,\n   input logic [2:0]             dma_hburst,\n   input logic                   dma_hmastlock,\n   input logic [3:0]             dma_hprot,\n   input logic [2:0]             dma_hsize,\n   input logic [1:0]             dma_htrans,\n   input logic                   dma_hwrite,\n   input logic [63:0]            dma_hwdata,\n   input logic                   dma_hreadyin,\n   input logic                   dma_hsel,\n\n   output  logic [63:0]          dma_hrdata,\n   output  logic                 dma_hreadyout,\n   output  logic                 dma_hresp,\n\n   input   logic                 lsu_bus_clk_en,\n   input   logic                 ifu_bus_clk_en,\n   input   logic                 dbg_bus_clk_en,\n   input   logic                 dma_bus_clk_en,\n\n   //DMI signals\n   input logic                   dmi_reg_en,                // access enable\n   input logic [6:0]             dmi_reg_addr,              // DM register address\n   input logic                   dmi_reg_wr_en,             // write enable\n   input logic [31:0]            dmi_reg_wdata,             // write data\n   output logic [31:0]           dmi_reg_rdata,             // read data\n\n   input logic [pt.PIC_TOTAL_INT:1] extintsrc_req,\n   input logic [pt.NUM_THREADS-1:0] timer_int,              // Timer interrupt pending (from pin)\n   input logic [pt.NUM_THREADS-1:0] soft_int,               // Software interrupt pending (from pin)\n   input logic                      scan_mode\n);\n\n\n\n   logic [63:0]                  hwdata_nc;\n\n   logic                         lsu_axi_awready_ahb;\n   logic                         lsu_axi_wready_ahb;\n "}
{"text": "  logic                         lsu_axi_bvalid_ahb;\n   logic                         lsu_axi_bready_ahb;\n   logic [1:0]                   lsu_axi_bresp_ahb;\n   logic [pt.LSU_BUS_TAG-1:0]    lsu_axi_bid_ahb;\n   logic                         lsu_axi_arready_ahb;\n   logic                         lsu_axi_rvalid_ahb;\n   logic [pt.LSU_BUS_TAG-1:0]    lsu_axi_rid_ahb;\n   logic [63:0]                  lsu_axi_rdata_ahb;\n   logic [1:0]                   lsu_axi_rresp_ahb;\n   logic                         lsu_axi_rlast_ahb;\n\n   logic                         lsu_axi_awready_int;\n   logic                         lsu_axi_wready_int;\n   logic                         lsu_axi_bvalid_int;\n   logic                         lsu_axi_bready_int;\n   logic [1:0]                   lsu_axi_bresp_int;\n   logic [pt.LSU_BUS_TAG-1:0]    lsu_axi_bid_int;\n   logic                         lsu_axi_arready_int;\n   logic                         lsu_axi_rvalid_int;\n   logic [pt.LSU_BUS_TAG-1:0]    lsu_axi_rid_int;\n   logic [63:0]                  lsu_axi_rdata_int;\n   logic [1:0]                   lsu_axi_rresp_int;\n   logic                         lsu_axi_rlast_int;\n\n   logic                         ifu_axi_awready_ahb;\n   logic                         ifu_axi_wready_ahb;\n   logic                         ifu_axi_bvalid_ahb;\n   logic                         ifu_axi_bready_ahb;\n   logic [1:0]                   ifu_axi_bresp_ahb;\n   logic [pt.IFU_BUS_TAG-1:0]    ifu_axi_bid_ahb;\n   logic                         ifu_axi_arready_ahb;\n   logic                         ifu_axi_rvalid_ahb;\n   logic [pt.IFU_BUS_TAG-1:0]    ifu_axi_rid_ahb;\n   logic [63:0]                  ifu_axi_rdata_ahb;\n   logic [1:0]                   ifu_axi_rresp_ahb;\n   logic                         ifu_axi_rlast_ahb;\n\n   logic                         ifu_axi_awready_int;\n   logic                         ifu_axi_wready_int;\n   logic                         ifu_axi_bvalid_int;\n   logic                         ifu_axi_bready_int;\n   logic [1:0]                   ifu_axi_bresp_int;\n   logic [pt.IFU_BUS_TAG-1:0]    ifu_axi_bid_int;\n   logic                         ifu_axi_arready_int;\n   logic                         ifu_axi_rvalid_int;\n   logic [pt.IFU_BUS_TAG-1:0]    ifu_axi_rid_int;\n   logic [63:0]                  ifu_axi_rdata_int;\n   logic [1:0]                   ifu_axi_rresp_int;\n   logic                         ifu_axi_rlast_int;\n\n   logic                         sb_axi_awready_ahb;\n   logic                         sb_axi_wready_ahb;\n   logic                         sb_axi_bvalid_ahb;\n   logic                         sb_axi_bready_ahb;\n   logic [1:0]                   sb_axi_bresp_ahb;\n   logic [pt.SB_BUS_TAG-1:0]     sb_axi_bid_ahb;\n   logic                         sb_axi_arready_ahb;\n   logic                         sb_axi_rvalid_ahb;\n   logic [pt.SB_BUS_TAG-1:0]     sb_axi_rid_ahb;\n   logic [63:0]                  sb_axi_rdata_ahb;\n   logic [1:0]                   sb_axi_rresp_ahb;\n   logic                         sb_axi_rlast_ahb;\n\n   logic                         sb_axi_awready_int;\n   logic                         sb_axi_wready_int;\n   logic                         sb_axi_bvalid_int;\n   logic                         sb_axi_bready_int;\n   logic [1:0]                   sb_axi_bresp_int;\n   logic [pt.SB_BUS_TAG-1:0]     sb_axi_bid_int;\n   logic                         sb_axi_arready_int;\n   logic                         sb_axi_rvalid_int;\n   logic [pt.SB_BUS_TAG-1:0]     sb_axi_rid_int;\n   logic [63:0]                  sb_axi_rdata_int;\n   logic [1:0]                   sb_axi_rresp_int;\n   logic                         sb_axi_rlast_int;\n\n   logic                         dma_axi_awvalid_ahb;\n   logic [pt.DMA_BUS_TAG-1:0]    dma_axi_awid_ahb;\n   logic [31:0]                  dma_axi_awaddr_ahb;\n   logic [2:0]                   dma_axi_awsize_ahb;\n   logic [2:0]                   dma_axi_awprot_ahb;\n   logic [7:0]                   dma_axi_awlen_ahb;\n   logic [1:0]                   dma_axi_awburst_ahb;\n   logic                         dma_axi_wvalid_ahb;\n   logic [63:0]                  dma_axi_wdata_ahb;\n   logic [7:0]                   dma_axi_wstrb_ahb;\n   logic                         dma_axi_wlast_ahb;\n   logic                         dma_axi_bready_ahb;\n   logic                         dma_axi_arvalid_ahb;\n   logic [pt.DMA_BUS_TAG-1:0]    dma_axi_arid_ahb;\n   logic [31:0]                  dma_axi_araddr_ahb;\n   logic [2:0]                   dma_axi_arsize_ahb;\n   logic [2:0]                   dma_axi_arprot_ahb;\n   logic [7:0]                   dma_axi_arlen_ahb;\n   logic [1:0]                   dma_axi_arburst_ahb;\n   logic                         dma_axi_rready_ahb;\n\n   logic                         dma_axi_awvalid_int;\n   logic [pt.DMA_BUS_TAG-1:0]    dma_axi_awid_int;\n   logic [31:0]                  dma_axi_awaddr_int;\n   logic [2:0]                   dma_axi_awsize_int;\n   logic [2:0]                   dma_axi_awprot_int;\n   logic [7:0]                   dma_axi_awlen_int;\n   logic [1:0]                   dma_axi_awburst_int;\n   logic                         dma_axi_wvalid_int;\n   logic [63:0]                  dma_axi_wdata_int;\n   logic [7:0]                   dma_axi_wstrb_int;\n   logic                         dma_axi_wlast_int;\n   logic                         dma_axi_bready_int;\n   logic                         dma_axi_arvalid_int;\n   logic [pt.DMA_BUS_TAG-1:0]    dma_axi_arid_int;\n   logic [31:0]                  dma_axi_araddr_int;\n   logic [2:0]                   dma_axi_arsize_int;\n   logic [2:0]                   dma_axi_arprot_int;\n   logic [7:0]                   dma_axi_arlen_int;\n   logic [1:0]                   dma_axi_arburst_int;\n   logic                         dma_axi_rready_int;\n\n   //----------------------------------------------------------------------\n   //\n   //----------------------------------------------------------------------\n\n   logic [pt.NUM_THREADS-1:0][1:0] ifu_pmu_instr_aligned;\n   logic [pt.NUM_THREADS-1:0]      ifu_pmu_align_stall;\n\n   logic [pt.NUM_THREADS-1:0]  ifu_miss_state_idle;          // I-side miss buffer empty\n   logic [pt.NUM_THREADS-1:0]  ifu_ic_error_start;           // IC single bit error\n   logic [pt.NUM_THREADS-1:0]  ifu_iccm_rd_ecc_single_err;   // ICCM single bit error\n\n// Icache debug\n   logic [70:0]                  ifu_ic_debug_rd_data;\n\n   logic ifu_ic_debug_rd_data_valid; // diagnostic icache read data valid\n   eh2_cache_debug_pkt_t dec_tlu_ic_diag_pkt; // packet of DICAWICS, DICAD0/1, DICAGO info for icache diagnostics\n   logic [pt.NUM_THREADS-1:0] dec_tlu_i0_commit_cmt;\n\n   logic  [31:0] gpr_i0_rs1_d;\n   logic  [31:0] gpr_i0_rs2_d;\n   logic  [31:0] gpr_i1_rs1_d;\n   logic  [31:0] gpr_i1_rs2_d;\n\n   logic [31:0] i0_rs1_bypass_data_d;\n   logic [31:0] i0_rs2_bypass_data_d;\n   logic [31:0] i1_rs1_bypass_data_d;\n   logic [31:0] i1_rs2_bypass_data_d;\n   logic [31:0] exu_i0_result_e1, exu_i1_result_e1;\n   logic [31:1] exu_i0_pc_e1;\n   logic [31:1] exu_i1_pc_e1;  // from the primary alu's\n   logic [pt.NUM_THREADS-1:0] [31:1] exu_npc_e4;\n\n   eh2_alu_pkt_t  i0_ap, i1_ap;\n\n   // Trigger signals\n   eh2_trigger_pkt_t [pt.NUM_THREADS-1:0][3:0]     trigger_pkt_any;\n   logic [3:0]             lsu_trigger_match_dc4;\n   logic [pt.NUM_THREADS-1:0] dec_ib3_valid_d, dec_ib2_valid_d;\n\n   logic [31:0] dec_i0_immed_d;\n   logic [31:0] dec_i1_immed_d;\n\n   logic [pt.BTB_TOFFSET_SIZE:1] dec_i0_br_immed_d;\n   logic [pt.BTB_TOFFSET_SIZE:1] dec_i1_br_immed_d;\n\n   logic         dec_i0_select_pc_d;\n   logic         dec_i1_select_pc_d;\n\n   logic [31:1] dec_i0_pc_d, dec_i1_pc_d;\n   logic        dec_i0_rs1_bypass_en_d;\n   logic        dec_i0_rs2_bypass_en_d;\n   logic        dec_i1_rs1_bypass_en_d;\n   logic        dec_i1_rs2_bypass_en_d;\n\n\n   logic         dec_i0_alu_decode_d;\n   logic         dec_i1_alu_decode_d;\n\n   logic [pt.NUM_THREADS-1:0]         ifu_i0_valid, ifu_i1_valid;\n   logic [pt.NUM_THREADS-1:0] [31:0]  ifu_i0_instr, ifu_i1_instr;\n   logic [pt.NUM_THREADS-1:0] [31:1]  ifu_i0_pc, ifu_i1_pc;\n   logic [31:2]  dec_tlu_meihap; // Fast ext int base\n\n   logic [pt.NUM_THREADS-1:0]   flush_final_e3;             // final flush\n   logic [pt.NUM_THREADS-1:0]   i0_flush_final_e3;          // final flush from i0\n\n   logic [pt.NUM_THREADS-1:0]   exu_flush_final_early;              // Pipe is being flushed this cycle\n   logic [pt.NUM_THREADS-1:0][31:1] exu_flush_path_final_early;         // Target for the oldest flush source\n\n   logic [pt.NUM_THREADS-1:0] [31:1] exu_flush_path_final;\n\n   logic [31:0] exu_lsu_rs1_d;\n   logic [31:0] exu_lsu_rs2_d;\n\n\n   eh2_lsu_pkt_t    lsu_p;\n\n   logic [11:0] dec_lsu_offset_d;\n   logic        dec_i0_lsu_d;       // chose which gpr value to use\n   logic        dec_i1_lsu_d;\n\n   logic [pt.NUM_THREADS-1:0] dec_tlu_force_halt;\n\n   logic [31:0]  lsu_result_dc3;\n   logic [31:0]  lsu_result_corr_dc4;\n   logic         lsu_sc_success_dc5;\n   logic         lsu_single_ecc_error_incr;     // Increment the ecc error counter\n   eh2_lsu_error_pkt_t lsu_error_pkt_dc3;\n   logic [pt.NUM_THREADS-1:0]        lsu_imprecise_error_load_any;\n   logic [pt.NUM_THREADS-1:0]        lsu_imprecise_error_store_any;\n   logic [pt.NUM_THREADS-1:0][31:0]  lsu_imprecise_error_addr_any;\n   logic         lsu_fastint_stall_any;     // Stall fast interrupts at decode-1\n\n   logic [pt.NUM_THREADS-1:0] lsu_amo_stall_any;         // This is for blocking amo\n   logic [pt.NUM_THREADS-1:0] lsu_load_stall_any;        // This is for blocking loads\n   logic [pt.NUM_THREADS-1:0] lsu_store_stall_any;       // This is for blocking stores\n   logic [pt.NUM_THREADS-1:0] lsu_idle_any;              // This is used to enter halt mode. Exclude DMA\n\n   logic [31:1]  lsu_fir_addr;              // fast interrupt address\n   logic [1:0]   lsu_fir_error;             // Error during fast interrupt lookup\n\n   // Non-blocking loads\n   logic                                  lsu_nonblock_load_valid_dc1;\n   logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]    lsu_nonblock_load_tag_dc1;\n   logic                                  lsu_nonblock_load_inv_dc2;\n   logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]    lsu_nonblock_load_inv_tag_dc2;\n   logic                                  lsu_nonblock_load_inv_dc5;\n   logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]    lsu_nonblock_load_inv_tag_dc5;\n   logic                                  lsu_nonblock_load_data_valid;\n   logic                                  lsu_nonblock_load_data_error;\n   logic                                  lsu_nonblock_load_data_tid;\n   logic [pt.LSU_NUM_NBLOAD_WIDTH-1:0]    lsu_nonblock_load_data_tag;\n   logic [31:0]                           lsu_nonblock_load_data;\n\n\n   logic [pt.NUM_THREADS-1:0] [31:1]      dec_tlu_flush_path_wb;  // flush pc\n   logic [pt.NUM_THREADS-1:0]             dec_tlu_flush_mp_wb; // commit has a flush (mispredict at e4)\n   logic [pt.NUM_THREADS-1:0]             dec_tlu_flush_lower_wb; // commit has a flush (exception; int; mispredict at e4)\n   logic [pt.NUM_THREADS-1:0]             dec_tlu_flush_lower_wb1; // commit has a flush (exception; int; mispredict at e4)\n   logic [pt.NUM_THREADS-1:0]             dec_tlu_flush_noredir_wb ; // Tell fetch to idle on this flush\n   logic [pt.NUM_THREADS-1:0]             dec_tlu_flush_leak_one_wb; // single step\n   logic [pt.NUM_THREADS-1:0]             dec_tlu_flush_err_wb; // iside perr/ecc rfpc\n   logic [pt.NUM_THREADS-1:0]             dec_tlu_fence_i_wb;     // flush is a fence_i rfnpc, flush icache\n\n\n   logic        dec_i0_csr_ren_d;\n\n   logic [31:0] exu_i0_csr_rs1_e1;\n\n   logic        dec_tlu_i0_kill_writeb_wb;    // I0 is flushed, don't writeback any results to arch state\n   logic        dec_tlu_i1_kill_writeb_wb;    // I1 is flushed, don't writeback any results to arch state\n\n   logic dec_tlu_i0_valid_e4;\n   logic dec_tlu_i1_valid_e4;\n   logic [31:0] dec_tlu_mrac_ff;        // CSR for memory region control\n   logic [pt.NUM_THREADS-1:0] dec_tlu_lr_reset_wb; // Reset the reservation on certain events\n\n\n   logic [pt.NUM_THREADS-1:0] ifu_i0_pc4, ifu_i1_pc4;\n\n   eh2_predecode_pkt_t  [pt.NUM_THREADS-1:0] ifu_i0_predecode;\n   eh2_predecode_pkt_t  [pt.NUM_THREADS-1:0] ifu_i1_predecode;\n\n\n\n   eh2_mul_pkt_t  mul_p;\n\n   logic [31:0] exu_mul_result_e3;\n\n   logic dec_i0_mul_d;\n   logic dec_i1_mul_d;\n\n   eh2_div_pkt_t  div_p;\n\n   logic        exu_div_wren;\n   logic [31:0] exu_div_result;\n\n   logic dec_i0_div_d;\n\n   logic        dec_i1_valid_e1;\n\n   logic [pt.NUM_THREADS-1:0][31:1] pred_correct_npc_e2; // npc e2 if the prediction is correct\n\n   logic [31:0] exu_i0_result_e4;\n   logic [31:0] exu_i1_result_e4;\n\n   logic        dec_i0_rs1_bypass_en_e3;\n   logic        dec_i0_rs2_bypass_en_e3;\n   logic        dec_i1_rs1_bypass_en_e3;\n   logic        dec_i1_rs2_bypass_en_e3;\n   logic [31:0] i0_rs1_bypass_data_e3;\n   logic [31:0] i0_rs2_bypass_data_e3;\n   logic [31:0] i1_rs1_bypass_data_e3;\n   logic [31:0] i1_rs2_bypass_data_e3;\n   logic        dec_i0_sec_decode_e3;\n   logic        dec_i1_sec_decode_e3;\n   logic [31:1] dec_i0_pc_e3;\n   logic [31:1] dec_i1_pc_e3;\n\n   logic        dec_i0_rs1_bypass_en_e2;\n   logic        dec_i0_rs2_bypass_en_e2;\n   logic        dec_i1_rs1_bypass_en_e2;\n   logic        dec_i1_rs2_bypass_en_e2;\n   logic [31:0] i0_rs1_bypass_data_e2;\n   logic [31:0] i0_rs2_bypass_data_e2;\n   logic [31:0] i1_rs1_bypass_data_e2;\n   logic [31:0] i1_rs2_bypass_data_e2;\n\n   logic [31:1] exu_i0_flush_path_e4;\n   logic [31:1] exu_i1_flush_path_e4;\n\n   eh2_br_tlu_pkt_t dec_tlu_br0_wb_pkt;\n   eh2_br_tlu_pkt_t dec_tlu_br1_wb_pkt;\n\n   eh2_predict_pkt_t [pt.NUM_THREADS-1:0]                    exu_mp_pkt;\n   logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]           exu_mp_eghr;\n   logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]           exu_mp_fghr;\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_mp_index;\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_BTAG_SIZE-1:0]          exu_mp_btag;\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_TOFFSET_SIZE-1:0]       exu_mp_toffset;\n\n   logic [pt.BHT_GHR_SIZE-1:0]  exu_i0_br_fghr_e4;\n   logic [1:0]  exu_i0_br_hist_e4;\n   logic        exu_i0_br_bank_e4;\n   logic        exu_i0_br_error_e4;\n   logic        exu_i0_br_start_error_e4;\n   logic        exu_i0_br_valid_e4;\n   logic        exu_i0_br_mp_e4;\n   logic        exu_i0_br_ret_e4;\n   logic        exu_i0_br_call_e4;\n   logic        exu_i0_br_middle_e4;\n   logic [pt.BHT_GHR_SIZE-1:0]  exu_i1_br_fghr_e4;\n   logic dec_i0_tid_e4;\n   logic dec_i1_tid_e4;\n\n   logic [1:0]  exu_i1_br_hist_e4;\n   logic        exu_i1_br_bank_e4;\n   logic        exu_i1_br_error_e4;\n   logic        exu_i1_br_start_error_e4;\n   logic        exu_i1_br_valid_e4;\n   logic        exu_i1_br_mp_e4;\n   logic        exu_i1_br_ret_e4;\n   logic        exu_i1_br_call_e4;\n   logic        exu_i1_br_middle_e4;\n   logic        exu_i0_br_way_e4;\n   logic        exu_i1_br_way_e4;\n\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_i0_br_index_e4;\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] exu_i1_br_index_e4;\n\n   logic        dma_dccm_req;\n   logic        dma_dccm_spec_req;\n   logic        dma_iccm_req;\n   logic        dma_mem_addr_in_dccm;\n   logic [2:0]  dma_mem_tag;\n   logic [31:0] dma_mem_addr;\n   logic [2:0]  dma_mem_sz;\n   logic        dma_mem_write;\n   logic [63:0] dma_mem_wdata;\n\n   logic        dccm_dma_rvalid;\n   logic        dccm_dma_ecc_error;\n   logic [2:0]  dccm_dma_rtag;\n   logic [63:0] dccm_dma_rdata;\n   logic        iccm_dma_rvalid;\n   logic        iccm_dma_ecc_error;\n   logic [2:0]  iccm_dma_rtag;\n   logic [63:0] iccm_dma_rdata;\n\n   logic        dma_dccm_stall_any;       // Stall the ld/st in decode if asserted\n   logic        dma_iccm_stall_any;       // Stall the fetch\n   logic        dccm_ready;\n   logic        iccm_ready;\n\n   logic        dma_pmu_dccm_read;\n   logic        dma_pmu_dccm_write;\n   logic        dma_pmu_any_read;\n   logic        dma_pmu_any_write;\n\n   logic [31:0] i0_result_e4_eff;\n   logic [31:0] i1_result_e4_eff;\n\n   logic [31:0] i0_result_e2;\n\n   logic [pt.NUM_THREADS-1:0] [1:0]  ifu_i0_icaf_type;\n   logic [pt.NUM_THREADS-1:0]        ifu_i0_icaf;\n   logic [pt.NUM_THREADS-1:0]        ifu_i0_icaf_second;\n   logic [pt.NUM_THREADS-1:0]        ifu_i0_dbecc;\n   logic                           iccm_dma_sb_error;\n\n   logic [pt.NUM_THREADS-1:0] dec_i1_cancel_e1;\n\n   eh2_br_pkt_t [pt.NUM_THREADS-1:0] i0_brp;\n   eh2_br_pkt_t [pt.NUM_THREADS-1:0] i1_brp;\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] ifu_i0_bp_index, ifu_i1_bp_index;\n   logic [pt.NUM_THREADS-1:0] [pt.BHT_GHR_SIZE-1:0]           ifu_i0_bp_fghr, ifu_i1_bp_fghr;\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_BTAG_SIZE-1:0]          ifu_i0_bp_btag, ifu_i1_bp_btag;\n   logic [pt.NUM_THREADS-1:0] [pt.BTB_TOFFSET_SIZE-1:0]       ifu_i0_bp_toffset, ifu_i1_bp_toffset;\n\n   logic [pt.NUM_THREADS-1:0] [$clog2(pt.BTB_SIZE)-1:0] ifu_i0_bp_fa_index, ifu_i1_bp_fa_index;\n   logic [$clog2(pt.BTB_SIZE)-1:0] dec_fa_error_index; // Fully associt btb error index\n\n   eh2_predict_pkt_t  i0_predict_p_d;\n   eh2_predict_pkt_t  i1_predict_p_d;\n\n   logic [pt.BHT_GHR_SIZE-1:0]           i0_predict_fghr_d, i1_predict_fghr_d;       // DEC predict fghr\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] i0_predict_index_d, i1_predict_index_d;     // DEC predict index\n   logic [pt.BTB_BTAG_SIZE-1:0]          i0_predict_btag_d, i1_predict_btag_d;       // DEC predict branch tag\n   logic [pt.BTB_TOFFSET_SIZE-1:0]          i0_predict_toffset_d, i1_predict_toffset_d;       // DEC predict branch tag\n\n   logic [pt.BHT_GHR_SIZE-1:0]           dec_tlu_br0_fghr_wb;  // fghr to bp\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br0_index_wb; // bp index\n   logic [pt.BHT_GHR_SIZE-1:0]           dec_tlu_br1_fghr_wb;  // fghr to bp\n   logic [pt.BTB_ADDR_HI:pt.BTB_ADDR_LO] dec_tlu_br1_index_wb; // bp index\n\n      // PIC ports\n   logic                  picm_rd_thr;\n   logic                  picm_wren;\n   logic                  picm_rden;\n   logic                  picm_mken;\n   logic [31:0]           picm_rdaddr;\n   logic [31:0]           picm_wraddr;\n   logic [31:0]           picm_wr_data;\n   logic [31:0]           picm_rd_data;\n\n   logic [pt.NUM_THREADS-1:0]  dec_tlu_btb_write_kill;\n\n   logic  dec_tlu_external_ldfwd_disable;\n   logic  dec_tlu_bpred_disable;\n   logic  dec_tlu_wb_coalescing_disable;\n   logic  dec_tlu_sideeffect_posted_disable;\n   logic [2:0] dec_tlu_dma_qos_prty;\n\n   // clock gating overrides from mcgc\n   logic  dec_tlu_misc_clk_override;\n   logic  dec_tlu_exu_clk_override;\n   logic  dec_tlu_ifu_clk_override;\n   logic  dec_tlu_lsu_clk_override;\n   logic  dec_tlu_bus_clk_override;\n   logic  dec_tlu_pic_clk_override;\n   logic  dec_tlu_picio_clk_override;\n   logic  dec_tlu_dccm_clk_override;\n   logic  dec_tlu_icm_clk_override;\n\n   // -----------------------DEBUG  START -------------------------------\n\n   logic [31:0]            dbg_cmd_addr;              // the address of the debug command to used by the core\n   logic [31:0]            dbg_cmd_wrdata;            // If the debug command is a write command, this has the data to be written to the CSR/GPR\n   logic                   dbg_cmd_valid;             // commad is being driven by the dbg module. One pulse. Only dirven when core_halted has been seen\n   logic                   dbg_cmd_tid;               // thread for debug register read\n   logic                   dbg_cmd_write;             // 1: write command; 0: read_command\n   logic [1:0]             dbg_cmd_type;              // 0:gpr 1:csr 2: memory\n   logic [1:0]             dbg_cmd_size;              // size of the abstract mem access debug command\n   logic [pt.NUM_THREADS-1:0] dbg_halt_req;           // Sticky signal indicating that the debug module wants to start the entering of debug mode ( start the halting sequence )\n   logic [pt.NUM_THREADS-1:0] dbg_resume_req;         // Sticky signal indicating that the debug module wants to resume from debug mode\n   logic                   dbg_core_rst_l;            // Core reset from DM\n\n   logic                   core_dbg_cmd_done;         // Final muxed cmd done to debu"}
{"text": "g\n   logic                   core_dbg_cmd_fail;         // Final muxed cmd done to debug\n   logic [31:0]            core_dbg_rddata;           // Final muxed cmd done to debug\n\n   logic                   dma_dbg_cmd_done;          // Abstarct memory command sent to dma is done\n   logic                   dma_dbg_cmd_fail;          // Abstarct memory command sent to dma failed\n   logic [31:0]            dma_dbg_rddata;            // Read data for abstract memory access\n\n   logic                   dbg_dma_bubble;            // Debug needs a bubble to send a valid\n   logic                   dma_dbg_ready;             // DMA is ready to accept debug request\n\n   logic [31:0]            dec_dbg_rddata;            // The core drives this data ( intercepts the pipe and sends it here )\n   logic                   dec_dbg_cmd_done;          // This will be treated like a valid signal\n   logic                   dec_dbg_cmd_fail;          // Abstract command failed\n   logic                   dec_dbg_cmd_tid;           // Tid of abstract command response\n   logic [pt.NUM_THREADS-1:0] dec_tlu_mpc_halted_only;   // Only halted due to MPC\n   logic [pt.NUM_THREADS-1:0] dec_tlu_dbg_halted;        // The core has finished the queiscing sequence. Sticks this signal high\n   logic [pt.NUM_THREADS-1:0] dec_tlu_resume_ack;\n   logic [pt.NUM_THREADS-1:0] dec_tlu_debug_mode;        // Core is in debug mode\n   logic                   dec_debug_wdata_rs1_d;\n\n   logic [4:1]             dec_i0_data_en;\n   logic [4:1]             dec_i0_ctl_en;\n   logic [4:1]             dec_i1_data_en;\n   logic [4:1]             dec_i1_ctl_en;\n\n   // PMU Signals\n   logic                   exu_pmu_i0_br_misp;\n   logic                   exu_pmu_i0_br_ataken;\n   logic                   exu_pmu_i0_pc4;\n   logic                   exu_pmu_i1_br_misp;\n   logic                   exu_pmu_i1_br_ataken;\n   logic                   exu_pmu_i1_pc4;\n\n   logic [pt.NUM_THREADS-1:0]  lsu_pmu_load_external_dc3;\n   logic [pt.NUM_THREADS-1:0]  lsu_pmu_store_external_dc3;\n   logic [pt.NUM_THREADS-1:0]  lsu_pmu_misaligned_dc3;\n   logic [pt.NUM_THREADS-1:0]  lsu_pmu_bus_trxn;\n   logic [pt.NUM_THREADS-1:0]  lsu_pmu_bus_misaligned;\n   logic [pt.NUM_THREADS-1:0]  lsu_pmu_bus_error;\n   logic [pt.NUM_THREADS-1:0]  lsu_pmu_bus_busy;\n\n   logic [pt.NUM_THREADS-1:0] ifu_pmu_fetch_stall;\n\n   logic [pt.NUM_THREADS-1:0] ifu_pmu_ic_miss;               // IC miss event\n   logic [pt.NUM_THREADS-1:0] ifu_pmu_ic_hit;                // IC hit event\n   logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_error;             // Bus error event\n   logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_busy;              // Bus busy event\n   logic [pt.NUM_THREADS-1:0] ifu_pmu_bus_trxn;              // Bus transaction\n\n   logic                      active_state;\n   logic                      free_clk, active_clk;\n   logic [pt.NUM_THREADS-1:0] dec_pause_state_cg;\n\n\n   logic [pt.NUM_THREADS-1:0] [15:0]            ifu_i0_cinst;\n   logic [pt.NUM_THREADS-1:0] [15:0]            ifu_i1_cinst;\n\n   logic [31:0]                  lsu_rs1_dc1;\n\n   logic                         dec_extint_stall;\n\n   eh2_trace_pkt_t  [pt.NUM_THREADS-1:0] trace_rv_trace_pkt;\n\n   logic [pt.NUM_THREADS-1:0]    exu_flush_final;            // Pipe is being flushed this cycle\n   logic [pt.NUM_THREADS-1:0]    exu_i0_flush_final;         // I0 flush to DEC\n   logic [pt.NUM_THREADS-1:0]    exu_i1_flush_final;         // I1 flush to DEC\n\n   logic [pt.NUM_THREADS-1:0]    exu_i0_flush_lower_e4;        // to TLU - lower branch flush\n   logic [pt.NUM_THREADS-1:0]    exu_i1_flush_lower_e4;        // to TLU - lower branch flush\n\n   logic                         dec_div_cancel;             // cancel divide operation\n\n   logic [pt.NUM_THREADS-1:0] [7:0]  pic_claimid;\n   logic [pt.NUM_THREADS-1:0] [3:0]  pic_pl, dec_tlu_meicurpl, dec_tlu_meipt;\n   logic [pt.NUM_THREADS-1:0]        mexintpend;\n   logic [pt.NUM_THREADS-1:0]        mhwakeup;\n\n\n   logic        dma_active;\n\n\n// 2nd level clock headers\n\n   logic [pt.NUM_THREADS-1:0] pause_state;\n   logic [pt.NUM_THREADS-1:0] halt_state;\n   logic [pt.NUM_THREADS-1:0] active_thread;\n   logic [pt.NUM_THREADS-1:0] active_thread_l2clk;\n\n   logic        dec_tlu_core_empty;\n\n   logic        active_raw_state;\n   logic        active_raw_l2clk;\n\n   logic        lsu_active;\n\n   logic        dec_i0_secondary_d;\n   logic        dec_i0_secondary_e1;\n   logic        dec_i0_secondary_e2;\n\n   logic        dec_i1_secondary_d;\n   logic        dec_i1_secondary_e1;\n   logic        dec_i1_secondary_e2;\n\n   logic        dec_i0_branch_d;\n   logic        dec_i0_branch_e1;\n   logic        dec_i0_branch_e2;\n   logic        dec_i0_branch_e3;\n\n   logic        dec_i1_branch_d;\n   logic        dec_i1_branch_e1;\n   logic        dec_i1_branch_e2;\n   logic        dec_i1_branch_e3;\n\n   logic        dec_i0_pc4_e4;\n   logic        dec_i1_pc4_e4;\n\n\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin\n\n      assign pause_state[i] = dec_pause_state_cg[i] & ~(dma_active | lsu_active) & dec_tlu_core_empty;\n      assign halt_state[i] = o_cpu_halt_status[i] & ~(dma_active | lsu_active);\n\n      assign active_thread[i] = (~(halt_state[i] | pause_state[i]) | dec_tlu_flush_lower_wb[i] | dec_tlu_flush_lower_wb1[i])  | dec_tlu_misc_clk_override;\n\n      rvoclkhdr act_cg   ( .clk(clk), .en(active_thread[i]),         .l1clk(active_thread_l2clk[i]), .* );\n   end\n\n   if (pt.NUM_THREADS == 1) begin\n\n      assign active_state = (~(halt_state[0] | pause_state[0]) | (|dec_tlu_flush_lower_wb) | (|dec_tlu_flush_lower_wb1))  | dec_tlu_misc_clk_override;\n\n   end else begin\n\n      assign active_state = (~( (halt_state[1] | pause_state[1]) & (halt_state[0] | pause_state[0])) | (|dec_tlu_flush_lower_wb) | (|dec_tlu_flush_lower_wb1))  | dec_tlu_misc_clk_override;\n   end\n\n\n   rvoclkhdr free_cg2   ( .clk(clk), .en(1'b1),         .l1clk(free_l2clk), .* );\n   rvoclkhdr active_cg2 ( .clk(clk), .en(active_state), .l1clk(active_l2clk), .* );\n\n   rvoclkhdr free_cg1     ( .clk(free_l2clk),     .en(1'b1), .l1clk(free_clk), .* );\n   rvoclkhdr active_cg1   ( .clk(active_l2clk),   .en(1'b1), .l1clk(active_clk), .* );\n\n\n   assign        dccm_clk_override = dec_tlu_dccm_clk_override;   // dccm memory\n   assign        icm_clk_override = dec_tlu_icm_clk_override;     // icache/iccm memory\n   assign        btb_clk_override = dec_tlu_ifu_clk_override;\n\n\n   assign core_dbg_cmd_done = dma_dbg_cmd_done | dec_dbg_cmd_done;\n   assign core_dbg_cmd_fail = dma_dbg_cmd_fail | dec_dbg_cmd_fail;\n   assign core_dbg_rddata[31:0] = dma_dbg_cmd_done ? dma_dbg_rddata[31:0] : dec_dbg_rddata[31:0];\n\n   eh2_dbg #(.pt(pt)) dbg (\n                            .rst_l(core_rst_l),\n                            .clk(free_l2clk),\n                            .clk_override(dec_tlu_misc_clk_override),\n\n                            // AXI signals\n                            .sb_axi_awready(sb_axi_awready_int),\n                            .sb_axi_wready(sb_axi_wready_int),\n                            .sb_axi_bvalid(sb_axi_bvalid_int),\n                            .sb_axi_bresp(sb_axi_bresp_int[1:0]),\n\n                            .sb_axi_arready(sb_axi_arready_int),\n                            .sb_axi_rvalid(sb_axi_rvalid_int),\n                            .sb_axi_rdata(sb_axi_rdata_int[63:0]),\n                            .sb_axi_rresp(sb_axi_rresp_int[1:0]),\n\n                            .*\n                            );\n\n\n   // -----------------   DEBUG END -----------------------------\n\n   assign core_rst_l = rst_l & (dbg_core_rst_l | scan_mode);\n\n   // fetch\n   eh2_ifu #(.pt(pt)) ifu (\n                            .clk(active_l2clk),\n                            .clk_override(dec_tlu_ifu_clk_override),\n                            .rst_l(core_rst_l),\n\n                            // AXI signals\n                            .ifu_axi_arready(ifu_axi_arready_int),\n                            .ifu_axi_rvalid(ifu_axi_rvalid_int),\n                            .ifu_axi_rid(ifu_axi_rid_int[pt.IFU_BUS_TAG-1:0]),\n                            .ifu_axi_rdata(ifu_axi_rdata_int[63:0]),\n                            .ifu_axi_rresp(ifu_axi_rresp_int[1:0]),\n\n                            .*\n                            );\n\n\n\n   eh2_dec #(.pt(pt)) dec (\n                            .clk(active_l2clk),\n                            .dbg_cmd_wrdata(dbg_cmd_wrdata[1:0]),\n                            .rst_l(core_rst_l),\n                            .*\n                            );\n\n   eh2_exu #(.pt(pt)) exu (\n                            .clk(active_l2clk),\n                            .clk_override(dec_tlu_exu_clk_override),\n                            .rst_l(core_rst_l),\n                            .*\n                            );\n\n   eh2_lsu #(.pt(pt)) lsu (\n                            .clk(active_l2clk),\n                            .clk_override(dec_tlu_lsu_clk_override),\n                            .rst_l(core_rst_l),\n\n                            // AXI signals\n                            .lsu_axi_awready(lsu_axi_awready_int),\n                            .lsu_axi_wready(lsu_axi_wready_int),\n                            .lsu_axi_bvalid(lsu_axi_bvalid_int),\n                            .lsu_axi_bid(lsu_axi_bid_int[pt.LSU_BUS_TAG-1:0]),\n                            .lsu_axi_bresp(lsu_axi_bresp_int[1:0]),\n\n                            .lsu_axi_arready(lsu_axi_arready_int),\n                            .lsu_axi_rvalid(lsu_axi_rvalid_int),\n                            .lsu_axi_rid(lsu_axi_rid_int[pt.LSU_BUS_TAG-1:0]),\n                            .lsu_axi_rdata(lsu_axi_rdata_int[63:0]),\n                            .lsu_axi_rresp(lsu_axi_rresp_int[1:0]),\n                            .lsu_axi_rlast(lsu_axi_rlast_int),\n\n                            .*\n                            );\n\n   eh2_pic_ctrl #(.pt(pt))  pic_ctrl_inst (\n                                            .clk(free_l2clk),\n                                            .clk_override(dec_tlu_pic_clk_override),\n                                            .io_clk_override(dec_tlu_picio_clk_override),\n                                            .picm_mken (picm_mken),\n                                            .extintsrc_req({extintsrc_req[pt.PIC_TOTAL_INT:1],1'b0}),\n                                            .pl_out(pic_pl),\n                                            .claimid_out(pic_claimid),\n                                            .mexintpend_out(mexintpend),\n                                            .mhwakeup_out(mhwakeup),\n                                            .rst_l(core_rst_l),\n                                            .*);\n\n   eh2_dma_ctrl #(.pt(pt)) dma_ctrl (\n                                      .clk(free_l2clk),\n                                      .rst_l(core_rst_l),\n                                      .clk_override(dec_tlu_misc_clk_override),\n\n                                      // AXI signals\n                                      .dma_axi_awvalid(dma_axi_awvalid_int),\n                                      .dma_axi_awid(dma_axi_awid_int[pt.DMA_BUS_TAG-1:0]),\n                                      .dma_axi_awaddr(dma_axi_awaddr_int[31:0]),\n                                      .dma_axi_awsize(dma_axi_awsize_int[2:0]),\n                                      .dma_axi_wvalid(dma_axi_wvalid_int),\n                                      .dma_axi_wdata(dma_axi_wdata_int[63:0]),\n                                      .dma_axi_wstrb(dma_axi_wstrb_int[7:0]),\n                                      .dma_axi_bready(dma_axi_bready_int),\n\n                                      .dma_axi_arvalid(dma_axi_arvalid_int),\n                                      .dma_axi_arid(dma_axi_arid_int[pt.DMA_BUS_TAG-1:0]),\n                                      .dma_axi_araddr(dma_axi_araddr_int[31:0]),\n                                      .dma_axi_arsize(dma_axi_arsize_int[2:0]),\n                                      .dma_axi_rready(dma_axi_rready_int),\n\n                                      .*\n   );\n\n   if (pt.BUILD_AHB_LITE == 1) begin: Gen_AXI_To_AHB\n\n      // AXI4 -> AHB Gasket for LSU\n      axi4_to_ahb #(.NUM_THREADS(pt.NUM_THREADS),\n                    .TAG(pt.LSU_BUS_TAG)) lsu_axi4_to_ahb (\n         .clk(free_l2clk),\n         .free_clk(free_clk),\n         .rst_l(core_rst_l),\n         .clk_override(dec_tlu_bus_clk_override),\n         .bus_clk_en(lsu_bus_clk_en),\n         .dec_tlu_force_halt(dec_tlu_force_halt),\n\n         // AXI Write Channels\n         .axi_awvalid(lsu_axi_awvalid),\n         .axi_awready(lsu_axi_awready_ahb),\n         .axi_awid(lsu_axi_awid[pt.LSU_BUS_TAG-1:0]),\n         .axi_awaddr(lsu_axi_awaddr[31:0]),\n         .axi_awsize(lsu_axi_awsize[2:0]),\n         .axi_awprot(lsu_axi_awprot[2:0]),\n\n         .axi_wvalid(lsu_axi_wvalid),\n         .axi_wready(lsu_axi_wready_ahb),\n         .axi_wdata(lsu_axi_wdata[63:0]),\n         .axi_wstrb(lsu_axi_wstrb[7:0]),\n         .axi_wlast(lsu_axi_wlast),\n\n         .axi_bvalid(lsu_axi_bvalid_ahb),\n         .axi_bready(lsu_axi_bready),\n         .axi_bresp(lsu_axi_bresp_ahb[1:0]),\n         .axi_bid(lsu_axi_bid_ahb[pt.LSU_BUS_TAG-1:0]),\n\n         // AXI Read Channels\n         .axi_arvalid(lsu_axi_arvalid),\n         .axi_arready(lsu_axi_arready_ahb),\n         .axi_arid(lsu_axi_arid[pt.LSU_BUS_TAG-1:0]),\n         .axi_araddr(lsu_axi_araddr[31:0]),\n         .axi_arsize(lsu_axi_arsize[2:0]),\n         .axi_arprot(lsu_axi_arprot[2:0]),\n\n         .axi_rvalid(lsu_axi_rvalid_ahb),\n         .axi_rready(lsu_axi_rready),\n         .axi_rid(lsu_axi_rid_ahb[pt.LSU_BUS_TAG-1:0]),\n         .axi_rdata(lsu_axi_rdata_ahb[63:0]),\n         .axi_rresp(lsu_axi_rresp_ahb[1:0]),\n         .axi_rlast(lsu_axi_rlast_ahb),\n\n         // AHB-LITE signals\n         .ahb_haddr(lsu_haddr[31:0]),\n         .ahb_hburst(lsu_hburst),\n         .ahb_hmastlock(lsu_hmastlock),\n         .ahb_hprot(lsu_hprot[3:0]),\n         .ahb_hsize(lsu_hsize[2:0]),\n         .ahb_htrans(lsu_htrans[1:0]),\n         .ahb_hwrite(lsu_hwrite),\n         .ahb_hwdata(lsu_hwdata[63:0]),\n\n         .ahb_hrdata(lsu_hrdata[63:0]),\n         .ahb_hready(lsu_hready),\n         .ahb_hresp(lsu_hresp),\n\n         .*\n      );\n\n      axi4_to_ahb #(.NUM_THREADS(pt.NUM_THREADS),\n                    .TAG(pt.IFU_BUS_TAG)) ifu_axi4_to_ahb (\n         .clk(free_l2clk),\n         .free_clk(free_clk),\n         .rst_l(core_rst_l),\n         .clk_override(dec_tlu_bus_clk_override),\n         .bus_clk_en(ifu_bus_clk_en),\n         .dec_tlu_force_halt(dec_tlu_force_halt),\n\n          // AHB-Lite signals\n         .ahb_haddr(haddr[31:0]),\n         .ahb_hburst(hburst),\n         .ahb_hmastlock(hmastlock),\n         .ahb_hprot(hprot[3:0]),\n         .ahb_hsize(hsize[2:0]),\n         .ahb_htrans(htrans[1:0]),\n         .ahb_hwrite(hwrite),\n         .ahb_hwdata(hwdata_nc[63:0]),\n\n         .ahb_hrdata(hrdata[63:0]),\n         .ahb_hready(hready),\n         .ahb_hresp(hresp),\n\n         // AXI Write Channels\n         .axi_awvalid(ifu_axi_awvalid),\n         .axi_awready(ifu_axi_awready_ahb),\n         .axi_awid(ifu_axi_awid[pt.IFU_BUS_TAG-1:0]),\n         .axi_awaddr(ifu_axi_awaddr[31:0]),\n         .axi_awsize(ifu_axi_awsize[2:0]),\n         .axi_awprot(ifu_axi_awprot[2:0]),\n\n         .axi_wvalid(ifu_axi_wvalid),\n         .axi_wready(ifu_axi_wready_ahb),\n         .axi_wdata(ifu_axi_wdata[63:0]),\n         .axi_wstrb(ifu_axi_wstrb[7:0]),\n         .axi_wlast(ifu_axi_wlast),\n\n         .axi_bvalid(ifu_axi_bvalid_ahb),\n         .axi_bready(1'b1),\n         .axi_bresp(ifu_axi_bresp_ahb[1:0]),\n         .axi_bid(ifu_axi_bid_ahb[pt.IFU_BUS_TAG-1:0]),\n\n         // AXI Read Channels\n         .axi_arvalid(ifu_axi_arvalid),\n         .axi_arready(ifu_axi_arready_ahb),\n         .axi_arid(ifu_axi_arid[pt.IFU_BUS_TAG-1:0]),\n         .axi_araddr(ifu_axi_araddr[31:0]),\n         .axi_arsize(ifu_axi_arsize[2:0]),\n         .axi_arprot(ifu_axi_arprot[2:0]),\n\n         .axi_rvalid(ifu_axi_rvalid_ahb),\n         .axi_rready(ifu_axi_rready),\n         .axi_rid(ifu_axi_rid_ahb[pt.IFU_BUS_TAG-1:0]),\n         .axi_rdata(ifu_axi_rdata_ahb[63:0]),\n         .axi_rresp(ifu_axi_rresp_ahb[1:0]),\n         .axi_rlast(ifu_axi_rlast_ahb),\n         .*\n      );\n\n      // AXI4 -> AHB Gasket for System Bus\n      axi4_to_ahb #(.NUM_THREADS(pt.NUM_THREADS),\n                    .TAG(pt.SB_BUS_TAG)) sb_axi4_to_ahb (\n         .clk_override(dec_tlu_bus_clk_override),\n         .rst_l(dbg_rst_l),\n         .clk(free_l2clk),\n         .free_clk(free_clk),\n         .bus_clk_en(dbg_bus_clk_en),\n         .dec_tlu_force_halt({pt.NUM_THREADS{1'b0}}),\n\n         // AXI Write Channels\n         .axi_awvalid(sb_axi_awvalid),\n         .axi_awready(sb_axi_awready_ahb),\n         .axi_awid(sb_axi_awid[pt.SB_BUS_TAG-1:0]),\n         .axi_awaddr(sb_axi_awaddr[31:0]),\n         .axi_awsize(sb_axi_awsize[2:0]),\n         .axi_awprot(sb_axi_awprot[2:0]),\n\n         .axi_wvalid(sb_axi_wvalid),\n         .axi_wready(sb_axi_wready_ahb),\n         .axi_wdata(sb_axi_wdata[63:0]),\n         .axi_wstrb(sb_axi_wstrb[7:0]),\n         .axi_wlast(sb_axi_wlast),\n\n         .axi_bvalid(sb_axi_bvalid_ahb),\n         .axi_bready(sb_axi_bready),\n         .axi_bresp(sb_axi_bresp_ahb[1:0]),\n         .axi_bid(sb_axi_bid_ahb[pt.SB_BUS_TAG-1:0]),\n\n         // AXI Read Channels\n         .axi_arvalid(sb_axi_arvalid),\n         .axi_arready(sb_axi_arready_ahb),\n         .axi_arid(sb_axi_arid[pt.SB_BUS_TAG-1:0]),\n         .axi_araddr(sb_axi_araddr[31:0]),\n         .axi_arsize(sb_axi_arsize[2:0]),\n         .axi_arprot(sb_axi_arprot[2:0]),\n\n         .axi_rvalid(sb_axi_rvalid_ahb),\n         .axi_rready(sb_axi_rready),\n         .axi_rid(sb_axi_rid_ahb[pt.SB_BUS_TAG-1:0]),\n         .axi_rdata(sb_axi_rdata_ahb[63:0]),\n         .axi_rresp(sb_axi_rresp_ahb[1:0]),\n         .axi_rlast(sb_axi_rlast_ahb),\n\n         // AHB-LITE signals\n         .ahb_haddr(sb_haddr[31:0]),\n         .ahb_hburst(sb_hburst),\n         .ahb_hmastlock(sb_hmastlock),\n         .ahb_hprot(sb_hprot[3:0]),\n         .ahb_hsize(sb_hsize[2:0]),\n         .ahb_htrans(sb_htrans[1:0]),\n         .ahb_hwrite(sb_hwrite),\n         .ahb_hwdata(sb_hwdata[63:0]),\n\n         .ahb_hrdata(sb_hrdata[63:0]),\n         .ahb_hready(sb_hready),\n         .ahb_hresp(sb_hresp),\n\n         .*\n      );\n\n      //AHB -> AXI4 Gasket for DMA\n      ahb_to_axi4 #(.pt(pt),\n                    .TAG(pt.DMA_BUS_TAG)) dma_ahb_to_axi4 (\n         .clk_override(dec_tlu_bus_clk_override),\n         .rst_l(core_rst_l),\n         .clk(free_l2clk),\n         .bus_clk_en(dma_bus_clk_en),\n\n         // AXI Write Channels\n         .axi_awvalid(dma_axi_awvalid_ahb),\n         .axi_awready(dma_axi_awready),\n         .axi_awid(dma_axi_awid_ahb[pt.DMA_BUS_TAG-1:0]),\n         .axi_awaddr(dma_axi_awaddr_ahb[31:0]),\n         .axi_awsize(dma_axi_awsize_ahb[2:0]),\n         .axi_awprot(dma_axi_awprot_ahb[2:0]),\n         .axi_awlen(dma_axi_awlen_ahb[7:0]),\n         .axi_awburst(dma_axi_awburst_ahb[1:0]),\n\n         .axi_wvalid(dma_axi_wvalid_ahb),\n         .axi_wready(dma_axi_wready),\n         .axi_wdata(dma_axi_wdata_ahb[63:0]),\n         .axi_wstrb(dma_axi_wstrb_ahb[7:0]),\n         .axi_wlast(dma_axi_wlast_ahb),\n\n         .axi_bvalid(dma_axi_bvalid),\n         .axi_bready(dma_axi_bready_ahb),\n         .axi_bresp(dma_axi_bresp[1:0]),\n         .axi_bid(dma_axi_bid[pt.DMA_BUS_TAG-1:0]),\n\n         // AXI Read Channels\n         .axi_arvalid(dma_axi_arvalid_ahb),\n         .axi_arready(dma_axi_arready),\n         .axi_arid(dma_axi_arid_ahb[pt.DMA_BUS_TAG-1:0]),\n         .axi_araddr(dma_axi_araddr_ahb[31:0]),\n         .axi_arsize(dma_axi_arsize_ahb[2:0]),\n         .axi_arprot(dma_axi_arprot_ahb[2:0]),\n         .axi_arlen(dma_axi_arlen_ahb[7:0]),\n         .axi_arburst(dma_axi_arburst_ahb[1:0]),\n\n         .axi_rvalid(dma_axi_rvalid),\n         .axi_rready(dma_axi_rready_ahb),\n         .axi_rid(dma_axi_rid[pt.DMA_BUS_TAG-1:0]),\n         .axi_rdata(dma_axi_rdata[63:0]),\n         .axi_rresp(dma_axi_rresp[1:0]),\n\n          // AHB signals\n         .ahb_haddr(dma_haddr[31:0]),\n         .ahb_hburst(dma_hburst),\n         .ahb_hmastlock(dma_hmastlock),\n         .ahb_hprot(dma_"}
{"text": "hprot[3:0]),\n         .ahb_hsize(dma_hsize[2:0]),\n         .ahb_htrans(dma_htrans[1:0]),\n         .ahb_hwrite(dma_hwrite),\n         .ahb_hwdata(dma_hwdata[63:0]),\n\n         .ahb_hrdata(dma_hrdata[63:0]),\n         .ahb_hreadyout(dma_hreadyout),\n         .ahb_hresp(dma_hresp),\n         .ahb_hreadyin(dma_hreadyin),\n         .ahb_hsel(dma_hsel),\n         .*\n      );\n\n   end\n\n   // Drive the final AXI inputs\n   assign lsu_axi_awready_int                 = pt.BUILD_AHB_LITE ? lsu_axi_awready_ahb : lsu_axi_awready;\n   assign lsu_axi_wready_int                  = pt.BUILD_AHB_LITE ? lsu_axi_wready_ahb : lsu_axi_wready;\n   assign lsu_axi_bvalid_int                  = pt.BUILD_AHB_LITE ? lsu_axi_bvalid_ahb : lsu_axi_bvalid;\n   assign lsu_axi_bready_int                  = pt.BUILD_AHB_LITE ? lsu_axi_bready_ahb : lsu_axi_bready;\n   assign lsu_axi_bresp_int[1:0]              = pt.BUILD_AHB_LITE ? lsu_axi_bresp_ahb[1:0] : lsu_axi_bresp[1:0];\n   assign lsu_axi_bid_int[pt.LSU_BUS_TAG-1:0] = pt.BUILD_AHB_LITE ? lsu_axi_bid_ahb[pt.LSU_BUS_TAG-1:0] : lsu_axi_bid[pt.LSU_BUS_TAG-1:0];\n   assign lsu_axi_arready_int                 = pt.BUILD_AHB_LITE ? lsu_axi_arready_ahb : lsu_axi_arready;\n   assign lsu_axi_rvalid_int                  = pt.BUILD_AHB_LITE ? lsu_axi_rvalid_ahb : lsu_axi_rvalid;\n   assign lsu_axi_rid_int[pt.LSU_BUS_TAG-1:0] = pt.BUILD_AHB_LITE ? lsu_axi_rid_ahb[pt.LSU_BUS_TAG-1:0] : lsu_axi_rid[pt.LSU_BUS_TAG-1:0];\n   assign lsu_axi_rdata_int[63:0]             = pt.BUILD_AHB_LITE ? lsu_axi_rdata_ahb[63:0] : lsu_axi_rdata[63:0];\n   assign lsu_axi_rresp_int[1:0]              = pt.BUILD_AHB_LITE ? lsu_axi_rresp_ahb[1:0] : lsu_axi_rresp[1:0];\n   assign lsu_axi_rlast_int                   = pt.BUILD_AHB_LITE ? lsu_axi_rlast_ahb : lsu_axi_rlast;\n\n   assign ifu_axi_awready_int                 = pt.BUILD_AHB_LITE ? ifu_axi_awready_ahb : ifu_axi_awready;\n   assign ifu_axi_wready_int                  = pt.BUILD_AHB_LITE ? ifu_axi_wready_ahb : ifu_axi_wready;\n   assign ifu_axi_bvalid_int                  = pt.BUILD_AHB_LITE ? ifu_axi_bvalid_ahb : ifu_axi_bvalid;\n   assign ifu_axi_bready_int                  = pt.BUILD_AHB_LITE ? ifu_axi_bready_ahb : ifu_axi_bready;\n   assign ifu_axi_bresp_int[1:0]              = pt.BUILD_AHB_LITE ? ifu_axi_bresp_ahb[1:0] : ifu_axi_bresp[1:0];\n   assign ifu_axi_bid_int[pt.IFU_BUS_TAG-1:0] = pt.BUILD_AHB_LITE ? ifu_axi_bid_ahb[pt.IFU_BUS_TAG-1:0] : ifu_axi_bid[pt.IFU_BUS_TAG-1:0];\n   assign ifu_axi_arready_int                 = pt.BUILD_AHB_LITE ? ifu_axi_arready_ahb : ifu_axi_arready;\n   assign ifu_axi_rvalid_int                  = pt.BUILD_AHB_LITE ? ifu_axi_rvalid_ahb : ifu_axi_rvalid;\n   assign ifu_axi_rid_int[pt.IFU_BUS_TAG-1:0] = pt.BUILD_AHB_LITE ? ifu_axi_rid_ahb[pt.IFU_BUS_TAG-1:0] : ifu_axi_rid[pt.IFU_BUS_TAG-1:0];\n   assign ifu_axi_rdata_int[63:0]             = pt.BUILD_AHB_LITE ? ifu_axi_rdata_ahb[63:0] : ifu_axi_rdata[63:0];\n   assign ifu_axi_rresp_int[1:0]              = pt.BUILD_AHB_LITE ? ifu_axi_rresp_ahb[1:0] : ifu_axi_rresp[1:0];\n   assign ifu_axi_rlast_int                   = pt.BUILD_AHB_LITE ? ifu_axi_rlast_ahb : ifu_axi_rlast;\n\n   assign sb_axi_awready_int                  = pt.BUILD_AHB_LITE ? sb_axi_awready_ahb : sb_axi_awready;\n   assign sb_axi_wready_int                   = pt.BUILD_AHB_LITE ? sb_axi_wready_ahb : sb_axi_wready;\n   assign sb_axi_bvalid_int                   = pt.BUILD_AHB_LITE ? sb_axi_bvalid_ahb : sb_axi_bvalid;\n   assign sb_axi_bready_int                   = pt.BUILD_AHB_LITE ? sb_axi_bready_ahb : sb_axi_bready;\n   assign sb_axi_bresp_int[1:0]               = pt.BUILD_AHB_LITE ? sb_axi_bresp_ahb[1:0] : sb_axi_bresp[1:0];\n   assign sb_axi_bid_int[pt.SB_BUS_TAG-1:0]   = pt.BUILD_AHB_LITE ? sb_axi_bid_ahb[pt.SB_BUS_TAG-1:0] : sb_axi_bid[pt.SB_BUS_TAG-1:0];\n   assign sb_axi_arready_int                  = pt.BUILD_AHB_LITE ? sb_axi_arready_ahb : sb_axi_arready;\n   assign sb_axi_rvalid_int                   = pt.BUILD_AHB_LITE ? sb_axi_rvalid_ahb : sb_axi_rvalid;\n   assign sb_axi_rid_int[pt.SB_BUS_TAG-1:0]   = pt.BUILD_AHB_LITE ? sb_axi_rid_ahb[pt.SB_BUS_TAG-1:0] : sb_axi_rid[pt.SB_BUS_TAG-1:0];\n   assign sb_axi_rdata_int[63:0]              = pt.BUILD_AHB_LITE ? sb_axi_rdata_ahb[63:0] : sb_axi_rdata[63:0];\n   assign sb_axi_rresp_int[1:0]               = pt.BUILD_AHB_LITE ? sb_axi_rresp_ahb[1:0] : sb_axi_rresp[1:0];\n   assign sb_axi_rlast_int                    = pt.BUILD_AHB_LITE ? sb_axi_rlast_ahb : sb_axi_rlast;\n\n   assign dma_axi_awvalid_int                  = pt.BUILD_AHB_LITE ? dma_axi_awvalid_ahb : dma_axi_awvalid;\n   assign dma_axi_awid_int[pt.DMA_BUS_TAG-1:0] = pt.BUILD_AHB_LITE ? dma_axi_awid_ahb[pt.DMA_BUS_TAG-1:0] : dma_axi_awid[pt.DMA_BUS_TAG-1:0];\n   assign dma_axi_awaddr_int[31:0]             = pt.BUILD_AHB_LITE ? dma_axi_awaddr_ahb[31:0] : dma_axi_awaddr[31:0];\n   assign dma_axi_awsize_int[2:0]              = pt.BUILD_AHB_LITE ? dma_axi_awsize_ahb[2:0] : dma_axi_awsize[2:0];\n   assign dma_axi_awprot_int[2:0]              = pt.BUILD_AHB_LITE ? dma_axi_awprot_ahb[2:0] : dma_axi_awprot[2:0];\n   assign dma_axi_awlen_int[7:0]               = pt.BUILD_AHB_LITE ? dma_axi_awlen_ahb[7:0] : dma_axi_awlen[7:0];\n   assign dma_axi_awburst_int[1:0]             = pt.BUILD_AHB_LITE ? dma_axi_awburst_ahb[1:0] : dma_axi_awburst[1:0];\n   assign dma_axi_wvalid_int                   = pt.BUILD_AHB_LITE ? dma_axi_wvalid_ahb : dma_axi_wvalid;\n   assign dma_axi_wdata_int[63:0]              = pt.BUILD_AHB_LITE ? dma_axi_wdata_ahb[63:0] : dma_axi_wdata;\n   assign dma_axi_wstrb_int[7:0]               = pt.BUILD_AHB_LITE ? dma_axi_wstrb_ahb[7:0] : dma_axi_wstrb[7:0];\n   assign dma_axi_wlast_int                    = pt.BUILD_AHB_LITE ? dma_axi_wlast_ahb : dma_axi_wlast;\n   assign dma_axi_bready_int                   = pt.BUILD_AHB_LITE ? dma_axi_bready_ahb : dma_axi_bready;\n   assign dma_axi_arvalid_int                  = pt.BUILD_AHB_LITE ? dma_axi_arvalid_ahb : dma_axi_arvalid;\n   assign dma_axi_arid_int[pt.DMA_BUS_TAG-1:0] = pt.BUILD_AHB_LITE ? dma_axi_arid_ahb[pt.DMA_BUS_TAG-1:0] : dma_axi_arid[pt.DMA_BUS_TAG-1:0];\n   assign dma_axi_araddr_int[31:0]             = pt.BUILD_AHB_LITE ? dma_axi_araddr_ahb[31:0] : dma_axi_araddr[31:0];\n   assign dma_axi_arsize_int[2:0]              = pt.BUILD_AHB_LITE ? dma_axi_arsize_ahb[2:0] : dma_axi_arsize[2:0];\n   assign dma_axi_arprot_int[2:0]              = pt.BUILD_AHB_LITE ? dma_axi_arprot_ahb[2:0] : dma_axi_arprot[2:0];\n   assign dma_axi_arlen_int[7:0]               = pt.BUILD_AHB_LITE ? dma_axi_arlen_ahb[7:0] : dma_axi_arlen[7:0];\n   assign dma_axi_arburst_int[1:0]             = pt.BUILD_AHB_LITE ? dma_axi_arburst_ahb[1:0] : dma_axi_arburst[1:0];\n   assign dma_axi_rready_int                   = pt.BUILD_AHB_LITE ? dma_axi_rready_ahb : dma_axi_rready;\n\n   if  (pt.BUILD_AHB_LITE == 1) begin\n   `ifdef RV_ASSERT_ON\n      property ahb_trxn_aligned;\n        @(posedge clk) disable iff(~rst_l) (lsu_htrans[1:0] != 2'b0)  |-> ((lsu_hsize[2:0] == 3'h0)                              |\n                                                                           ((lsu_hsize[2:0] == 3'h1) & (lsu_haddr[0] == 1'b0))   |\n                                                                           ((lsu_hsize[2:0] == 3'h2) & (lsu_haddr[1:0] == 2'b0)) |\n                                                                           ((lsu_hsize[2:0] == 3'h3) & (lsu_haddr[2:0] == 3'b0)));\n      endproperty\n      assert_ahb_trxn_aligned: assert property (ahb_trxn_aligned) else\n        $display(\"Assertion ahb_trxn_aligned failed: lsu_htrans=2'h%h, lsu_hsize=3'h%h, lsu_haddr=32'h%h\",lsu_htrans[1:0], lsu_hsize[2:0], lsu_haddr[31:0]);\n\n      property dma_trxn_aligned;\n        @(posedge clk) disable iff(~rst_l) (dma_htrans[1:0] != 2'b0)  |-> ((dma_hsize[2:0] == 3'h0)                              |\n                                                                           ((dma_hsize[2:0] == 3'h1) & (dma_haddr[0] == 1'b0))   |\n                                                                           ((dma_hsize[2:0] == 3'h2) & (dma_haddr[1:0] == 2'b0)) |\n                                                                           ((dma_hsize[2:0] == 3'h3) & (dma_haddr[2:0] == 3'b0)));\n      endproperty\n\n`endif\n   end // if (pt.BUILD_AHB_LITE == 1)\n\n\n\n      // unpack packet\n      // also need retires_p==3\n\n   for (genvar i=0; i<pt.NUM_THREADS; i++) begin : trace_rewire\n\n      assign trace_rv_i_insn_ip[i][63:0]     = trace_rv_trace_pkt[i].trace_rv_i_insn_ip[63:0];\n      assign trace_rv_i_address_ip[i][63:0]  = trace_rv_trace_pkt[i].trace_rv_i_address_ip[63:0];\n      assign trace_rv_i_valid_ip[i][1:0]     = trace_rv_trace_pkt[i].trace_rv_i_valid_ip[1:0];\n      assign trace_rv_i_exception_ip[i][1:0] = trace_rv_trace_pkt[i].trace_rv_i_exception_ip[1:0];\n      assign trace_rv_i_ecause_ip[i][4:0]    = trace_rv_trace_pkt[i].trace_rv_i_ecause_ip[4:0];\n      assign trace_rv_i_interrupt_ip[i][1:0] = trace_rv_trace_pkt[i].trace_rv_i_interrupt_ip[1:0];\n      assign trace_rv_i_tval_ip[i][31:0]     = trace_rv_trace_pkt[i].trace_rv_i_tval_ip[31:0];\n   end\n\n\nendmodule // eh2_veer\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n//********************************************************************************\n// $Id$\n//\n// Function: Top wrapper file with eh2_veer/mem instantiated inside\n// Comments:\n//\n//********************************************************************************\nmodule eh2_veer_wrapper\nimport eh2_pkg::*;\n#(\n`include \"eh2_param.vh\"\n) (\n   input logic                       clk,\n   input logic                       rst_l,\n   input logic                       dbg_rst_l,\n   input logic [31:1]                rst_vec,\n   input logic                       nmi_int,\n   input logic [31:1]                nmi_vec,\n   input logic [31:1]                jtag_id,\n\n\n   output logic [pt.NUM_THREADS-1:0] [63:0] trace_rv_i_insn_ip,\n   output logic [pt.NUM_THREADS-1:0] [63:0] trace_rv_i_address_ip,\n   output logic [pt.NUM_THREADS-1:0] [1:0]  trace_rv_i_valid_ip,\n   output logic [pt.NUM_THREADS-1:0] [1:0]  trace_rv_i_exception_ip,\n   output logic [pt.NUM_THREADS-1:0] [4:0]  trace_rv_i_ecause_ip,\n   output logic [pt.NUM_THREADS-1:0] [1:0]  trace_rv_i_interrupt_ip,\n   output logic [pt.NUM_THREADS-1:0] [31:0] trace_rv_i_tval_ip,\n\n   // Bus signals\n\n`ifdef RV_BUILD_AXI4\n   //-------------------------- LSU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            lsu_axi_awvalid,\n   input  logic                            lsu_axi_awready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_awid,\n   output logic [31:0]                     lsu_axi_awaddr,\n   output logic [3:0]                      lsu_axi_awregion,\n   output logic [7:0]                      lsu_axi_awlen,\n   output logic [2:0]                      lsu_axi_awsize,\n   output logic [1:0]                      lsu_axi_awburst,\n   output logic                            lsu_axi_awlock,\n   output logic [3:0]                      lsu_axi_awcache,\n   output logic [2:0]                      lsu_axi_awprot,\n   output logic [3:0]                      lsu_axi_awqos,\n\n   output logic                            lsu_axi_wvalid,\n   input  logic                            lsu_axi_wready,\n   output logic [63:0]                     lsu_axi_wdata,\n   output logic [7:0]                      lsu_axi_wstrb,\n   output logic                            lsu_axi_wlast,\n\n   input  logic                            lsu_axi_bvalid,\n   output logic                            lsu_axi_bready,\n   input  logic [1:0]                      lsu_axi_bresp,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_bid,\n\n   // AXI Read Channels\n   output logic                            lsu_axi_arvalid,\n   input  logic                            lsu_axi_arready,\n   output logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_arid,\n   output logic [31:0]                     lsu_axi_araddr,\n   output logic [3:0]                      lsu_axi_arregion,\n   output logic [7:0]                      lsu_axi_arlen,\n   output logic [2:0]                      lsu_axi_arsize,\n   output logic [1:0]                      lsu_axi_arburst,\n   output logic                            lsu_axi_arlock,\n   output logic [3:0]                      lsu_axi_arcache,\n   output logic [2:0]                      lsu_axi_arprot,\n   output logic [3:0]                      lsu_axi_arqos,\n\n   input  logic                            lsu_axi_rvalid,\n   output logic                            lsu_axi_rready,\n   input  logic [pt.LSU_BUS_TAG-1:0]       lsu_axi_rid,\n   input  logic [63:0]                     lsu_axi_rdata,\n   input  logic [1:0]                      lsu_axi_rresp,\n   input  logic                            lsu_axi_rlast,\n\n   //-------------------------- IFU AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            ifu_axi_awvalid,\n   input  logic                            ifu_axi_awready,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_awid,\n   output logic [31:0]                     ifu_axi_awaddr,\n   output logic [3:0]                      ifu_axi_awregion,\n   output logic [7:0]                      ifu_axi_awlen,\n   output logic [2:0]                      ifu_axi_awsize,\n   output logic [1:0]                      ifu_axi_awburst,\n   output logic                            ifu_axi_awlock,\n   output logic [3:0]                      ifu_axi_awcache,\n   output logic [2:0]                      ifu_axi_awprot,\n   output logic [3:0]                      ifu_axi_awqos,\n\n   output logic                            ifu_axi_wvalid,\n   input  logic                            ifu_axi_wready,\n   output logic [63:0]                     ifu_axi_wdata,\n   output logic [7:0]                      ifu_axi_wstrb,\n   output logic                            ifu_axi_wlast,\n\n   input  logic                            ifu_axi_bvalid,\n   output logic                            ifu_axi_bready,\n   input  logic [1:0]                      ifu_axi_bresp,\n   input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_bid,\n\n   // AXI Read Channels\n   output logic                            ifu_axi_arvalid,\n   input  logic                            ifu_axi_arready,\n   output logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_arid,\n   output logic [31:0]                     ifu_axi_araddr,\n   output logic [3:0]                      ifu_axi_arregion,\n   output logic [7:0]                      ifu_axi_arlen,\n   output logic [2:0]                      ifu_axi_arsize,\n   output logic [1:0]                      ifu_axi_arburst,\n   output logic                            ifu_axi_arlock,\n   output logic [3:0]                      ifu_axi_arcache,\n   output logic [2:0]                      ifu_axi_arprot,\n   output logic [3:0]                      ifu_axi_arqos,\n\n   input  logic                            ifu_axi_rvalid,\n   output logic                            ifu_axi_rready,\n   input  logic [pt.IFU_BUS_TAG-1:0]       ifu_axi_rid,\n   input  logic [63:0]                     ifu_axi_rdata,\n   input  logic [1:0]                      ifu_axi_rresp,\n   input  logic                            ifu_axi_rlast,\n\n   //-------------------------- SB AXI signals--------------------------\n   // AXI Write Channels\n   output logic                            sb_axi_awvalid,\n   input  logic                            sb_axi_awready,\n   output logic [pt.SB_BUS_TAG-1:0]        sb_axi_awid,\n   output logic [31:0]                     sb_axi_awaddr,\n   output logic [3:0]                      sb_axi_awregion,\n   output logic [7:0]                      sb_axi_awlen,\n   output logic [2:0]                      sb_axi_awsize,\n   output logic [1:0]                      sb_axi_awburst,\n   output logic                            sb_axi_awlock,\n   output logic [3:0]                      sb_axi_awcache,\n   output logic [2:0]                      sb_axi_awprot,\n   output logic [3:0]                      sb_axi_awqos,\n\n   output logic                            sb_axi_wvalid,\n   input  logic                            sb_axi_wready,\n   output logic [63:0]                     sb_axi_wdata,\n   output logic [7:0]                      sb_axi_wstrb,\n   output logic                            sb_axi_wlast,\n\n   input  logic                            sb_axi_bvalid,\n   output logic                            sb_axi_bready,\n   input  logic [1:0]                      sb_axi_bresp,\n   input  logic [pt.SB_BUS_TAG-1:0]        sb_axi_bid,\n\n   // AXI Read Channels\n   output logic                            sb_axi_arvalid,\n   input  logic                            sb_axi_arready,\n   output logic [pt.SB_BUS_TAG-1:0]        sb_axi_arid,\n   output logic [31:0]                     sb_axi_araddr,\n   output logic [3:0]                      sb_axi_arregion,\n   output logic [7:0]                      sb_axi_arlen,\n   output logic [2:0]                      sb_axi_arsize,\n   output logic [1:0]                      sb_axi_arburst,\n   output logic                            sb_axi_arlock,\n   output logic [3:0]                      sb_axi_arcache,\n   output logic [2:0]                      sb_axi_arprot,\n   output logic [3:0]                      sb_axi_arqos,\n\n   input  logic                            sb_axi_rvalid,\n   output logic                            sb_axi_rready,\n   input  logic [pt.SB_BUS_TAG-1:0]        sb_axi_rid,\n   input  logic [63:0]                     sb_axi_rdata,\n   input  logic [1:0]                      sb_axi_rresp,\n   input  logic                            sb_axi_rlast,\n\n   //-------------------------- DMA AXI signals--------------------------\n   // AXI Write Channels\n   input  logic                         dma_axi_awvalid,\n   output logic                         dma_axi_awready,\n   input  logic [pt.DMA_BUS_TAG-1:0]    dma_axi_awid,\n   input  logic [31:0]                  dma_axi_awaddr,\n   input  logic [2:0]                   dma_axi_awsize,\n   input  logic [2:0]                   dma_axi_awprot,\n   input  logic [7:0]                   dma_axi_awlen,\n   input  logic [1:0]                   dma_axi_awburst,\n\n\n   input  logic                         dma_axi_wvalid,\n   output logic                         dma_axi_wready,\n   input  logic [63:0]                  dma_axi_wdata,\n   input  logic [7:0]                   dma_axi_wstrb,\n   input  logic                         dma_axi_wlast,\n\n   output logic                         dma_axi_bvalid,\n   input  logic                         dma_axi_bready,\n   output logic [1:0]                   dma_axi_bresp,\n   output logic [pt.DMA_BUS_TAG-1:0]    dma_axi_bid,\n\n   // AXI Read Channels\n   input  logic                         dma_axi_arvalid,\n   output logic                         dma_axi_arready,\n   input  logic [pt.DMA_BUS_TAG-1:0]    dma_axi_arid,\n   input  logic [31:0]                  dma_axi_araddr,\n   input  logic [2:0]                   dma_axi_arsize,\n   input  logic [2:0]                   dma_axi_arprot,\n   input  logic [7:0]                   dma_axi_arlen,\n   input  logic [1:0]                   dma_axi_arburst,\n\n   output logic                         dma_axi_rvalid,\n   input  logic                         dma_axi_rready,\n   output logic [pt.DMA_BUS_TAG-1:0]    dma_axi_rid,\n   output logic [63:0]                  dma_axi_rdata,\n   output logic [1:0]                   dma_axi_rresp,\n   output logic                         dma_axi_rlast,\n\n`endif\n\n\n`ifdef RV_BUILD_AHB_LITE\n //// AHB LITE BUS\n   output logic [31:0]               haddr,\n   output logic [2:0]                hburst,\n   output logic                      hmastlock,\n   output logic [3:0]                hprot,\n   output logic [2:0]                hsize,\n   output logic [1:0]                htrans,\n   output logic                      hwrite,\n\n   input logic [63:0]                hrdata,\n   input logic                       hready,\n   input logic                       hresp,\n\n   // LSU AHB Master\n   output logic [31:0]               lsu_haddr,\n   output logic [2:0]                lsu_hburst,\n   output logic                      lsu_hmastlock,\n   output logic [3:0]                lsu_hprot,\n   output logic [2:0]                lsu_hsize,\n   output logic [1:0]                lsu_htrans,\n   output logic                      lsu_hwrite,\n   output logic [63:0]               lsu_hwdata,\n\n   input logic [63:0]                lsu_hrdata,\n   input logic                       lsu_hready,\n   input logic                       lsu_hresp,\n   // Debug Syster Bus AHB\n   output logic [31:0]               sb_haddr,\n   output logic [2:0]                sb_hburst,\n   output logic                      sb_hmastlock,\n   output logic [3:0]                sb_hprot,\n   output logic [2:0]                sb_hsize,\n   output logic [1:0]                sb_htrans,\n   output logic                      sb_hwrite,\n   output logic [63:0]               sb_hwdata,\n\n   input  logic [63:0]               sb_hrdata,\n   input  logic                      sb_hready,\n   input  logic                      sb_hresp,\n\n   // DMA Slave\n   input logic                       dma_hsel,\n   input logic [31:0]                dma_haddr,\n   input logic [2:0]                 dma_hburst,\n   input logic                       dma_hmastlock,\n   input logic [3:0]                 dma_hprot,\n   input logic [2:0]                 dma_hsize,\n   input logic [1:0]                 dma_htrans,\n   input logic                       dma_hwrite,\n   input logic [63:0]                dma_hwdata,\n   input logic                       dma_hreadyin,\n\n   output logic [63:0]               dma_hrdata,\n   output logic                      dma_hreadyout,\n   output logic                      dma_hresp,\n\n`endif\n\n\n   // clk ratio signals\n   input logic                       lsu_bus_clk_en, // Clock ratio b/w cpu core clk & AHB master interface\n   input logic                       ifu_bus_clk_en, // Clock ratio b/w cpu core clk & AHB master interface\n   input logic                       dbg_bus_clk_en, // Clock ratio b/w cpu core clk & AHB master interface\n   input logic                       dma_bus_clk_en, // Clock ratio b/w cpu core clk & AHB slave interface\n\n // all of these test inputs are brought to top-level; must be tied off based on usage by physical design (ie. icache or not, iccm or not, dccm or not)\n\n   input                             eh2_dccm_ext_in_pkt_t  [pt.DCCM_NUM_BANKS-1:0] dccm_ext_in_pkt,\n   input                             eh2_ccm_ext_in_pkt_t  [pt.ICCM_NUM_BANKS/4-1:0][1:0][1:0] iccm_ext_in_pkt,\n   input                             eh2_ccm_ext_in_pkt_t  [1:0] btb_ext_in_pkt,\n   input                             eh2_ic_data_ext_in_pkt_t  [pt.ICACHE_NUM_WAYS-1:0][pt.ICACHE_BANKS_WAY-1:0] ic_data_ext_in_pkt,\n   input                             eh2_ic_tag_ext_in_pkt_t   [pt.ICACHE_NUM_WAYS-1:0]                        ic_tag_ext_in_pkt,\n\n   input logic [pt.NUM_THREADS-1:0]  timer_int,\n   input logic [pt.NUM_THREADS-1:0]  soft_int,\n   input logic [pt.PIC_TOTAL_INT:1] extintsrc_req,\n\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt0,                  // toggles when perf counter 0 has an event inc\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt1,                  // toggles when perf counter 1 has an event inc\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt2,                  // toggles when perf counter 2 has an event inc\n   output logic [pt.NUM_THREADS-1:0] [1:0] dec_tlu_perfcnt3,                  // toggles when perf counter 3 has an event inc\n\n   // ports added by the soc team\n   input logic                       jtag_tck,    // JTAG clk\n   input logic                       jtag_tms,    // JTAG TMS\n   input logic                       jtag_tdi,    // JTAG tdi\n   input logic                       jtag_trst_n, // JTAG Reset\n   output logic                      jtag_tdo,    // JTAG TDO\n\n   input logic [31:4]     core_id, // Core ID\n\n\n   // external MPC halt/run interface\n   input logic  [pt.NUM_THREADS-1:0] mpc_debug_halt_req, // Async halt request\n   input logic  [pt.NUM_THREADS-1:0] mpc_debug_run_req,  // Async run request\n   input logic  [pt.NUM_THREADS-1:0] mpc_reset_run_req,  // Run/halt after reset\n   output logic [pt.NUM_THREADS-1:0] mpc_debug_halt_ack, // Halt ack\n   output logic [pt.NUM_THREADS-1:0] mpc_debug_run_ack,  // Run ack\n   output logic [pt.NUM_THREADS-1:0] debug_brkpt_status, // debug breakpoint\n\n   output logic [pt.NUM_THREADS-1:0] dec_tlu_mhartstart, // running harts\n\n   input logic          [pt.NUM_THREADS-1:0]         i_cpu_halt_req,      // Async halt req to CPU\n   output logic         [pt.NUM_THREADS-1:0]         o_cpu_halt_ack,      // core response to halt\n   output logic         [pt.NUM_THREADS-1:0]         o_cpu_halt_status,   // 1'b1 indicates core is halted\n   output logic         [pt.NUM_THREADS-1:0]         o_debug_mode_status, // Core to the PMU that core is in debug mode. When core is in debug mode, the PMU should refrain from sendng a halt or run request\n   input logic          [pt.NUM_THREADS-1:0]         i_cpu_run_req, // Async restart req to CPU\n   output logic         [pt.NUM_THREADS-1:0]         o_cpu_run_ack, // Core response to run req\n   input logic                       scan_mode, // To enable scan mode\n   input logic                       mbist_mode // to enable mbist\n);\n\n   // DCCM ports\n   logic         dccm_wren;\n   logic         dccm_rden;\n   logic [pt.DCCM_BITS-1:0]  dccm_wr_addr_lo;\n   logic [pt.DCCM_BITS-1:0]  dccm_wr_addr_hi;\n   logic [pt.DCCM_BITS-1:0]  dccm_rd_addr_lo;\n   logic [pt.DCCM_BITS-1:0]  dccm_rd_addr_hi;\n   logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_lo;\n   logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_wr_data_hi;\n\n   logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_lo;\n   logic [pt.DCCM_FDATA_WIDTH-1:0]  dccm_rd_data_hi;\n\n   // PIC ports\n\n   // Icache & Itag ports\n   logic [31:1]  ic_rw_addr;\n   logic [pt.ICACHE_NUM_WAYS-1:0]   ic_wr_en  ;     // Which way to write\n   logic         ic_rd_en ;\n\n\n   logic [pt.ICACHE_NUM_WAYS-1:0]   ic_tag_valid;   // Valid from the I$ tag valid outside (in flops).\n\n   logic [pt.ICACHE_NUM_WAYS-1:0]   ic_rd_hit;\n   logic         ic_tag_perr;    // Ic tag parity error\n\n   logic [pt.ICACHE_INDEX_HI:3]  ic_debug_addr;      // Read/Write addresss to the Icache.\n   logic         ic_debug_rd_en;     // Icache debug rd\n   logic         ic_debug_wr_en;     // Icache debug wr\n   logic         ic_debug_tag_array; // Debug tag array\n   logic [pt.ICACHE_NUM_WAYS-1:0]   ic_debug_way;       // Debug way. Rd or Wr.\n\n   logic [pt.ICACHE_BANKS_WAY-1:0] [70:0] ic_wr_data;           // Data to fill to the Icache. With ECC\n   logic [63:0]                           ic_rd_data;          // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   logic [70:0]                           ic_debug_rd_data;    // Data read from Icache. 2x64bits + parity bits. F2 stage. With ECC\n   logic [25:0]                           ictag_debug_rd_data;  // Debug icache tag.\n   logic [70:0]                           ic_debug_wr_data;     // Debug wr cache.\n   logic [pt.ICACHE_BANKS_WAY-1:0]        ic_eccerr;\n    //\n   logic [pt.ICACHE_BANKS_WAY-1:0]        ic_parerr;\n\n\n   logic [63:0]  ic_premux_data;\n   logic         ic_sel_premux_data;\n\n   // ICCM ports\n   logic [pt.ICCM_BITS-1:1]  iccm_rw_addr;\n   logic [pt.NUM_THREADS-1:0]iccm_buf_correct_ecc_thr;                // ICCM is doing a single bit error correct cycle\n   logic                     iccm_correction_state, iccm_corr_scnd_fetch;\n   logic                     iccm_stop_fetch;                     // ICCM hits need to ignored for replacement purposes as we have fetched ahead.. dont want to stop fetch through dma_active as it causes timing issues there\n\n   logic           ifc_select_tid_f1;\n   logic           iccm_wren;\n   logic           iccm_rden;\n   logic [2:0]     iccm_wr_size;\n   logic [77:0]    iccm_wr_data;\n   logic [63:0]    iccm_rd_data;\n   logic [116:0]   iccm_rd_data_ecc;\n\n   // BTB\n   eh2_btb_sram_pkt btb_sram_pkt;\n   logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0] btb_vbank0_rd_data_f1;\n   logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0] btb_vbank1_rd_data_f1;\n   logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0] btb_vbank2_rd_data_f1;\n   logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0] btb_vbank3_rd_data_f1;\n   logic                                              btb_wren;\n   logic                                              btb_rden;\n   logic [1:0] [pt.BTB_ADDR_HI:1]             btb_rw_addr;  // per bank\n   logic [1:0] ["}
{"text": "pt.BTB_ADDR_HI:1]             btb_rw_addr_f1;  // per bank\n   logic [pt.BTB_TOFFSET_SIZE+pt.BTB_BTAG_SIZE+5-1:0] btb_sram_wr_data;\n   logic [1:0] [pt.BTB_BTAG_SIZE-1:0]                 btb_sram_rd_tag_f1;\n\n   logic           active_l2clk;\n   logic           free_l2clk;\n\n   logic        core_rst_l;     // Core reset including rst_l and dbg_rst_l\n\n   logic        dccm_clk_override;\n   logic        icm_clk_override;\n   logic        dec_tlu_core_ecc_disable;\n   logic        btb_clk_override;\n\n   // DMI signals\n   logic                   dmi_reg_en;                // read or write\n   logic [6:0]             dmi_reg_addr;              // address of DM register\n   logic                   dmi_reg_wr_en;             // write enable\n   logic [31:0]            dmi_reg_wdata;             // write data\n   logic [31:0]            dmi_reg_rdata;             // read data\n\n   // zero out the signals not presented at the wrapper instantiation level\n`ifdef RV_BUILD_AXI4\n\n //// AHB LITE BUS\n   logic [31:0]                 haddr;\n   logic [2:0]                  hburst;\n   logic                        hmastlock;\n   logic [3:0]                  hprot;\n   logic [2:0]                  hsize;\n   logic [1:0]                  htrans;\n   logic                        hwrite;\n\n   logic [63:0]                 hrdata;\n   logic                        hready;\n   logic                        hresp;\n\n   // LSU AHB Master\n   logic [31:0]                 lsu_haddr;\n   logic [2:0]                  lsu_hburst;\n   logic                        lsu_hmastlock;\n   logic [3:0]                  lsu_hprot;\n   logic [2:0]                  lsu_hsize;\n   logic [1:0]                  lsu_htrans;\n   logic                        lsu_hwrite;\n   logic [63:0]                 lsu_hwdata;\n\n   logic [63:0]                 lsu_hrdata;\n   logic                        lsu_hready;\n   logic                        lsu_hresp;\n\n   // Debug Syster Bus AHB\n   logic [31:0]                 sb_haddr;\n   logic [2:0]                  sb_hburst;\n   logic                        sb_hmastlock;\n   logic [3:0]                  sb_hprot;\n   logic [2:0]                  sb_hsize;\n   logic [1:0]                  sb_htrans;\n   logic                        sb_hwrite;\n   logic [63:0]                 sb_hwdata;\n\n   logic [63:0]                 sb_hrdata;\n   logic                        sb_hready;\n   logic                        sb_hresp;\n\n   // DMA Slave\n   logic                        dma_hsel;\n   logic [31:0]                 dma_haddr;\n   logic [2:0]                  dma_hburst;\n   logic                        dma_hmastlock;\n   logic [3:0]                  dma_hprot;\n   logic [2:0]                  dma_hsize;\n   logic [1:0]                  dma_htrans;\n   logic                        dma_hwrite;\n   logic [63:0]                 dma_hwdata;\n   logic                        dma_hreadyin;\n\n   logic [63:0]                 dma_hrdata;\n   logic                        dma_hreadyout;\n   logic                        dma_hresp;\n\n   // IFU\n   assign  hrdata[63:0]                           = '0;\n   assign  hready                                 = '0;\n   assign  hresp                                  = '0;\n   // LSU\n   assign  lsu_hrdata[63:0]                       = '0;\n   assign  lsu_hready                             = '0;\n   assign  lsu_hresp                              = '0;\n   // SB\n   assign  sb_hrdata[63:0]                        = '0;\n   assign  sb_hready                              = '0;\n   assign  sb_hresp                               = '0;\n\n   // DMA\n   assign  dma_hsel                               = '0;\n   assign  dma_haddr[31:0]                        = '0;\n   assign  dma_hburst[2:0]                        = '0;\n   assign  dma_hmastlock                          = '0;\n   assign  dma_hprot[3:0]                         = '0;\n   assign  dma_hsize[2:0]                         = '0;\n   assign  dma_htrans[1:0]                        = '0;\n   assign  dma_hwrite                             = '0;\n   assign  dma_hwdata[63:0]                       = '0;\n   assign  dma_hreadyin                           = '0;\n\n`endif //  `ifdef RV_BUILD_AXI4\n\n\n`ifdef RV_BUILD_AHB_LITE\n   logic                           lsu_axi_awvalid;\n   logic                           lsu_axi_awready;\n   logic [pt.LSU_BUS_TAG-1:0]      lsu_axi_awid;\n   logic [31:0]                    lsu_axi_awaddr;\n   logic [3:0]                     lsu_axi_awregion;\n   logic [7:0]                     lsu_axi_awlen;\n   logic [2:0]                     lsu_axi_awsize;\n   logic [1:0]                     lsu_axi_awburst;\n   logic                           lsu_axi_awlock;\n   logic [3:0]                     lsu_axi_awcache;\n   logic [2:0]                     lsu_axi_awprot;\n   logic [3:0]                     lsu_axi_awqos;\n\n   logic                           lsu_axi_wvalid;\n   logic                           lsu_axi_wready;\n   logic [63:0]                    lsu_axi_wdata;\n   logic [7:0]                     lsu_axi_wstrb;\n   logic                           lsu_axi_wlast;\n\n   logic                           lsu_axi_bvalid;\n   logic                           lsu_axi_bready;\n   logic [1:0]                     lsu_axi_bresp;\n   logic [pt.LSU_BUS_TAG-1:0]      lsu_axi_bid;\n\n   // AXI Read Channels\n   logic                           lsu_axi_arvalid;\n   logic                           lsu_axi_arready;\n   logic [pt.LSU_BUS_TAG-1:0]      lsu_axi_arid;\n   logic [31:0]                    lsu_axi_araddr;\n   logic [3:0]                     lsu_axi_arregion;\n   logic [7:0]                     lsu_axi_arlen;\n   logic [2:0]                     lsu_axi_arsize;\n   logic [1:0]                     lsu_axi_arburst;\n   logic                           lsu_axi_arlock;\n   logic [3:0]                     lsu_axi_arcache;\n   logic [2:0]                     lsu_axi_arprot;\n   logic [3:0]                     lsu_axi_arqos;\n\n   logic                           lsu_axi_rvalid;\n   logic                           lsu_axi_rready;\n   logic [pt.LSU_BUS_TAG-1:0]      lsu_axi_rid;\n   logic [63:0]                    lsu_axi_rdata;\n   logic [1:0]                     lsu_axi_rresp;\n   logic                           lsu_axi_rlast;\n\n   //-------------------------- IFU AXI signals--------------------------\n   // AXI Write Channels\n   logic                           ifu_axi_awvalid;\n   logic                           ifu_axi_awready;\n   logic [pt.IFU_BUS_TAG-1:0]      ifu_axi_awid;\n   logic [31:0]                    ifu_axi_awaddr;\n   logic [3:0]                     ifu_axi_awregion;\n   logic [7:0]                     ifu_axi_awlen;\n   logic [2:0]                     ifu_axi_awsize;\n   logic [1:0]                     ifu_axi_awburst;\n   logic                           ifu_axi_awlock;\n   logic [3:0]                     ifu_axi_awcache;\n   logic [2:0]                     ifu_axi_awprot;\n   logic [3:0]                     ifu_axi_awqos;\n\n   logic                           ifu_axi_wvalid;\n   logic                           ifu_axi_wready;\n   logic [63:0]                    ifu_axi_wdata;\n   logic [7:0]                     ifu_axi_wstrb;\n   logic                           ifu_axi_wlast;\n\n   logic                           ifu_axi_bvalid;\n   logic                           ifu_axi_bready;\n   logic [1:0]                     ifu_axi_bresp;\n   logic [pt.IFU_BUS_TAG-1:0]      ifu_axi_bid;\n\n   // AXI Read Channels\n   logic                           ifu_axi_arvalid;\n   logic                           ifu_axi_arready;\n   logic [pt.IFU_BUS_TAG-1:0]      ifu_axi_arid;\n   logic [31:0]                    ifu_axi_araddr;\n   logic [3:0]                     ifu_axi_arregion;\n   logic [7:0]                     ifu_axi_arlen;\n   logic [2:0]                     ifu_axi_arsize;\n   logic [1:0]                     ifu_axi_arburst;\n   logic                           ifu_axi_arlock;\n   logic [3:0]                     ifu_axi_arcache;\n   logic [2:0]                     ifu_axi_arprot;\n   logic [3:0]                     ifu_axi_arqos;\n\n   logic                           ifu_axi_rvalid;\n   logic                           ifu_axi_rready;\n   logic [pt.IFU_BUS_TAG-1:0]      ifu_axi_rid;\n   logic [63:0]                    ifu_axi_rdata;\n   logic [1:0]                     ifu_axi_rresp;\n   logic                           ifu_axi_rlast;\n\n   //-------------------------- SB AXI signals--------------------------\n   // AXI Write Channels\n   logic                           sb_axi_awvalid;\n   logic                           sb_axi_awready;\n   logic [pt.SB_BUS_TAG-1:0]       sb_axi_awid;\n   logic [31:0]                    sb_axi_awaddr;\n   logic [3:0]                     sb_axi_awregion;\n   logic [7:0]                     sb_axi_awlen;\n   logic [2:0]                     sb_axi_awsize;\n   logic [1:0]                     sb_axi_awburst;\n   logic                           sb_axi_awlock;\n   logic [3:0]                     sb_axi_awcache;\n   logic [2:0]                     sb_axi_awprot;\n   logic [3:0]                     sb_axi_awqos;\n\n   logic                           sb_axi_wvalid;\n   logic                           sb_axi_wready;\n   logic [63:0]                    sb_axi_wdata;\n   logic [7:0]                     sb_axi_wstrb;\n   logic                           sb_axi_wlast;\n\n   logic                           sb_axi_bvalid;\n   logic                           sb_axi_bready;\n   logic [1:0]                     sb_axi_bresp;\n   logic [pt.SB_BUS_TAG-1:0]       sb_axi_bid;\n\n   // AXI Read Channels\n   logic                           sb_axi_arvalid;\n   logic                           sb_axi_arready;\n   logic [pt.SB_BUS_TAG-1:0]       sb_axi_arid;\n   logic [31:0]                    sb_axi_araddr;\n   logic [3:0]                     sb_axi_arregion;\n   logic [7:0]                     sb_axi_arlen;\n   logic [2:0]                     sb_axi_arsize;\n   logic [1:0]                     sb_axi_arburst;\n   logic                           sb_axi_arlock;\n   logic [3:0]                     sb_axi_arcache;\n   logic [2:0]                     sb_axi_arprot;\n   logic [3:0]                     sb_axi_arqos;\n\n   logic                           sb_axi_rvalid;\n   logic                           sb_axi_rready;\n   logic [pt.SB_BUS_TAG-1:0]       sb_axi_rid;\n   logic [63:0]                    sb_axi_rdata;\n   logic [1:0]                     sb_axi_rresp;\n   logic                           sb_axi_rlast;\n\n   //-------------------------- DMA AXI signals--------------------------\n   // AXI Write Channels\n   logic                           dma_axi_awvalid;\n   logic                           dma_axi_awready;\n   logic [pt.DMA_BUS_TAG-1:0]      dma_axi_awid;\n   logic [31:0]                    dma_axi_awaddr;\n   logic [2:0]                     dma_axi_awsize;\n   logic [2:0]                     dma_axi_awprot;\n   logic [7:0]                     dma_axi_awlen;\n   logic [1:0]                     dma_axi_awburst;\n\n\n   logic                           dma_axi_wvalid;\n   logic                           dma_axi_wready;\n   logic [63:0]                    dma_axi_wdata;\n   logic [7:0]                     dma_axi_wstrb;\n   logic                           dma_axi_wlast;\n\n   logic                           dma_axi_bvalid;\n   logic                           dma_axi_bready;\n   logic [1:0]                     dma_axi_bresp;\n   logic [pt.DMA_BUS_TAG-1:0]      dma_axi_bid;\n\n   // AXI Read Channels\n   logic                           dma_axi_arvalid;\n   logic                           dma_axi_arready;\n   logic [pt.DMA_BUS_TAG-1:0]      dma_axi_arid;\n   logic [31:0]                    dma_axi_araddr;\n   logic [2:0]                     dma_axi_arsize;\n   logic [2:0]                     dma_axi_arprot;\n   logic [7:0]                     dma_axi_arlen;\n   logic [1:0]                     dma_axi_arburst;\n\n   logic                           dma_axi_rvalid;\n   logic                           dma_axi_rready;\n   logic [pt.DMA_BUS_TAG-1:0]      dma_axi_rid;\n   logic [63:0]                    dma_axi_rdata;\n   logic [1:0]                     dma_axi_rresp;\n   logic                           dma_axi_rlast;\n\n   // LSU AXI\n   assign lsu_axi_awready                         = '0;\n   assign lsu_axi_wready                          = '0;\n   assign lsu_axi_bvalid                          = '0;\n   assign lsu_axi_bresp[1:0]                      = '0;\n   assign lsu_axi_bid[pt.LSU_BUS_TAG-1:0]         = '0;\n\n   assign lsu_axi_arready                         = '0;\n   assign lsu_axi_rvalid                          = '0;\n   assign lsu_axi_rid[pt.LSU_BUS_TAG-1:0]         = '0;\n   assign lsu_axi_rdata[63:0]                     = '0;\n   assign lsu_axi_rresp[1:0]                      = '0;\n   assign lsu_axi_rlast                           = '0;\n\n   // IFU AXI\n   assign ifu_axi_awready                         = '0;\n   assign ifu_axi_wready                          = '0;\n   assign ifu_axi_bvalid                          = '0;\n   assign ifu_axi_bresp[1:0]                      = '0;\n   assign ifu_axi_bid[pt.IFU_BUS_TAG-1:0]         = '0;\n\n   assign ifu_axi_arready                         = '0;\n   assign ifu_axi_rvalid                          = '0;\n   assign ifu_axi_rid[pt.IFU_BUS_TAG-1:0]         = '0;\n   assign ifu_axi_rdata[63:0]                     = '0;\n   assign ifu_axi_rresp[1:0]                      = '0;\n   assign ifu_axi_rlast                           = '0;\n\n   // Debug AXI\n   assign sb_axi_awready                          = '0;\n   assign sb_axi_wready                           = '0;\n   assign sb_axi_bvalid                           = '0;\n   assign sb_axi_bresp[1:0]                       = '0;\n   assign sb_axi_bid[pt.SB_BUS_TAG-1:0]           = '0;\n\n   assign sb_axi_arready                          = '0;\n   assign sb_axi_rvalid                           = '0;\n   assign sb_axi_rid[pt.SB_BUS_TAG-1:0]           = '0;\n   assign sb_axi_rdata[63:0]                      = '0;\n   assign sb_axi_rresp[1:0]                       = '0;\n   assign sb_axi_rlast                            = '0;\n\n   // DMA AXI\n   assign  dma_axi_awvalid = '0;\n   assign  dma_axi_awid[pt.DMA_BUS_TAG-1:0]       = '0;\n   assign  dma_axi_awaddr[31:0]                   = '0;\n   assign  dma_axi_awsize[2:0]                    = '0;\n   assign  dma_axi_awprot[2:0]                    = '0;\n   assign  dma_axi_awlen[7:0]                     = '0;\n   assign  dma_axi_awburst[1:0]                   = '0;\n\n   assign  dma_axi_wvalid                         = '0;\n   assign  dma_axi_wdata[63:0]                    = '0;\n   assign  dma_axi_wstrb[7:0]                     = '0;\n   assign  dma_axi_wlast                          = '0;\n\n   assign  dma_axi_bready                         = '0;\n\n   assign  dma_axi_arvalid                        = '0;\n   assign  dma_axi_arid[pt.DMA_BUS_TAG-1:0]       = '0;\n   assign  dma_axi_araddr[31:0]                   = '0;\n   assign  dma_axi_arsize[2:0]                    = '0;\n   assign  dma_axi_arprot[2:0]                    = '0;\n   assign  dma_axi_arlen[7:0]                     = '0;\n   assign  dma_axi_arburst[1:0]                   = '0;\n\n   assign  dma_axi_rready                         = '0;\n\n`endif //  `ifdef RV_BUILD_AHB_LITE\n\n   dmi_wrapper  dmi_wrapper (\n\n    // JTAG signals\n        .jtag_id        (jtag_id),          // JTAG ID\n        .trst_n         (jtag_trst_n),      // JTAG reset\n        .tck            (jtag_tck),         // JTAG clock\n        .tms            (jtag_tms),         // Test mode select\n        .tdi            (jtag_tdi),         // Test Data Input\n        .tdo            (jtag_tdo),         // Test Data Output\n        .tdoEnable      (),                 // Test Data Output enable, NC\n\n    // Processor Signals\n        .core_rst_n     (dbg_rst_l),        // DM reset, active low\n        .core_clk       (clk),              // Core clock\n        .rd_data        (dmi_reg_rdata),    // Read data from  Processor\n        .reg_wr_data    (dmi_reg_wdata),    // Write data to Processor\n        .reg_wr_addr    (dmi_reg_addr),     // Write address to Processor\n        .reg_en         (dmi_reg_en),       // access enable\n        .reg_wr_en      (dmi_reg_wr_en),    // Write enable to Processor\n        .dmi_hard_reset ()                  // hard reset of the DTM, NC\n    );\n\n   // Instantiate the eh2_veer core\n   eh2_veer #(.pt(pt)) veer (\n                                .*\n                               );\n\n   // Instantiate the mem\n   eh2_mem #(.pt(pt)) mem (\n        .clk(active_l2clk),\n        .rst_l(core_rst_l),\n        .*\n        );\n\n`ifdef RV_ASSERT_ON\ninitial begin\n    $assertoff(0, veer);\n    @ (negedge clk) $asserton(0, veer);\nend\n`endif\n\nendmodule\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2020 Western Digital Corporation or its affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n`define EH2_LOCAL_RAM_TEST_IO          \\\ninput logic WE,              \\\ninput logic ME,              \\\ninput logic CLK,             \\\ninput logic TEST1,           \\\ninput logic RME,             \\\ninput logic  [3:0] RM,       \\\ninput logic LS,              \\\ninput logic DS,              \\\ninput logic SD,              \\\ninput logic TEST_RNM,        \\\ninput logic BC1,             \\\ninput logic BC2,             \\\noutput logic ROP\n\n\n// behavior to be replaced by actual SRAM in VLE\n\n`define EH2_RAM(depth, width)              \\\nmodule ram_``depth``x``width(               \\\n   input logic [$clog2(depth)-1:0] ADR,     \\\n   input logic [(width-1):0] D,             \\\n   output logic [(width-1):0] Q,            \\\n    `EH2_LOCAL_RAM_TEST_IO                 \\\n);                                          \\\nreg [(width-1):0] ram_core [(depth-1):0];   \\\n`ifdef GTLSIM                               \\\ninteger i;                                  \\\ninitial begin                               \\\n   for (i=0; i<depth; i=i+1)                \\\n     ram_core[i] = '0;                      \\\nend                                         \\\n`endif                                      \\\nalways @(posedge CLK) begin                 \\\n`ifdef GTLSIM                               \\\n   if (ME && WE)       ram_core[ADR] <= D;        \\\n`else                                       \\\n   if (ME && WE) begin ram_core[ADR] <= D; Q <= 'x; end  \\\n`endif                                      \\\n   if (ME && ~WE) Q <= ram_core[ADR];       \\\nend                                         \\\n                                            \\\nassign ROP = ME;                            \\\n                                            \\\n//initial $display(\"%m D=%b, A=%b\",D,ADR);\\\nendmodule\n\n`define EH2_RAM_BE(depth, width)           \\\nmodule ram_be_``depth``x``width(            \\\n   input logic [$clog2(depth)-1:0] ADR,     \\\n   input logic [(width-1):0] D, WEM,        \\\n   output logic [(width-1):0] Q,            \\\n    `EH2_LOCAL_RAM_TEST_IO                 \\\n);                                          \\\nreg [(width-1):0] ram_core [(depth-1):0];   \\\n`ifdef GTLSIM                               \\\ninteger i;                                  \\\ninitial begin                               \\\n   for (i=0; i<depth; i=i+1)                \\\n     ram_core[i] = '0;                      \\\nend                                         \\\n`endif                                      \\\nalways @(posedge CLK) begin                 \\\n`ifdef GTLSIM                               \\\n   if (ME && WE)       ram_core[ADR] <= D & WEM | ~WEM & ram_core[ADR];      \\\n`else                                       \\\n   if (ME && WE) begin ram_core[ADR] <= D & WEM | ~WEM & ram_core[ADR]; Q <= 'x; end  \\\n`endif                                      \\\n   if (ME && ~WE) Q <= ram_core[ADR];          \\\nend                                         \\\n                                            \\\nassign ROP = ME;                            \\\n                                            \\\n//initial $display(\"%m D=%b, A=%b\",D,ADR);\\\nendmodule\n\n// parameterizable RAM for verilator sims\nmodule eh2_ram #(depth=2, width=1) (\ninput logic [$clog2(depth)-1:0] ADR,\ninput logic [(width-1):0] D,\noutput logic [(width-1):0] Q,\n `EH2_LOCAL_RAM_TEST_IO\n);\nreg [(width-1):0] ram_core [(depth-1):0];\n\nalways @(posedge CLK) begin\n`ifdef GTLSIM\n   if (ME && WE)       ram_core[ADR] <= D;\n`else\n   if (ME && WE) begin ram_core[ADR] <= D; Q <= 'x; end\n`endif\n   if (ME && ~WE) Q <= ram_core[ADR];\nend\nendmodule\n\n`EH2_RAM(32768, 39)\n`EH2_RAM(16384, 39)\n`EH2_RAM(8192, 39)\n`EH2_RAM(4096, 39)\n`EH2_RAM(3072, 39)\n`EH2_RAM(2048, 39)\n`EH2_RAM(1536, 39)//need this for the 48KB DCCM option)\n`EH2_RAM(1024, 39)\n`EH2_RAM(768, 39)\n`EH2_RAM(512, 39)\n`EH2_RAM(256, 39)\n`EH2_RAM(128, 39)\n`EH2_RAM(1024, 20)\n`EH2_RAM(512, 20)\n`EH2_RAM(256, 20)\n`EH2_RAM(128, 20)\n`EH2_RAM(64, 20)\n`EH2_RAM(4096, 34)\n`EH2_RAM(2048, 34)\n`EH2_RAM(1024, 34)\n`EH2_RAM(512, 34)\n`EH2_RAM(256, 34)\n`EH2_RAM(128, 34)\n`EH2_RAM(64, 34)\n`EH2_RAM(8192, 68)\n`EH2_RAM(4096, 68)\n`EH2_RAM(2048, 68)\n`EH2_RAM(1024, 68)\n`EH2_RAM(512, 68)\n`EH2_RAM(256, 68)\n`EH2_RAM(128, 68)\n`EH2_RAM(64, 68)\n`EH2_RAM(8192, 71)\n`EH2_RAM(4096, 71)\n`EH2_RAM(2048, 71)\n`EH2_RAM(1024, 71)\n`EH2_RAM(512, 71)\n`EH2_RAM(256, 71)\n`EH2_RAM(128, 71)\n`EH2_RAM(64, 71)\n`EH2_RAM(4096, 42)\n`EH2_RAM(2048, 42)\n`EH2_RAM(1024, 42)\n`EH2_RAM(512, 42)\n`EH2_RAM(256, 42)\n`EH2_RAM(128, 42)\n`EH2_RAM(64, 42)\n`EH2_RAM(4096, 22)\n`EH2_RAM(2048, 22)\n`EH2_RAM(1024, 22)\n`EH2_RAM(512, 22)\n`EH2_RAM(256, 22)\n`EH2_RAM(128, 22)\n`EH2_RAM(64, 22)\n`EH2_RAM(1024, 26)\n`EH2_RAM(4096, 26)\n`EH2_RAM(2048, 26)\n`EH2_RAM(512, 26)\n`EH2_RAM(256, 26)\n`EH2_RAM(128, 26)\n`EH2_RAM(64, 26)\n`EH2_RAM(32, 26)\n`EH2_RAM(32, 22)\n`EH2_RAM_BE(8192, 142)\n`EH2_RAM_BE(4096, 142)\n`EH2_RAM_BE(2048, 142)\n`EH2_RAM_BE(1024, 142)\n`EH2_RAM_BE(512, 142)\n`EH2_RAM_BE(256, 142)\n`EH2_RAM_BE(128, 142)\n`EH2_RAM_BE(64, 142)\n`EH2_RAM_BE(8192, 284)\n`EH2_RAM_BE(4096, 284)\n`EH2_RAM_BE(2048, 284)\n`EH2_RAM_BE(1024, 284)\n`EH2_RAM_BE(512, 284)\n`EH2_RAM_BE(256, 284)\n`EH2_RAM_BE(128, 284)\n`EH2_RAM_BE(64, 284)\n`EH2_RAM_BE(8192, 136)\n`EH2_RAM_BE(4096, 136)\n`EH2_RAM_BE(2048, 136)\n`EH2_RAM_BE(1024, 136)\n`EH2_RAM_BE(512, 136)\n`EH2_RAM_BE(256, 136)\n`EH2_RAM_BE(128, 136)\n`EH2_RAM_BE(64, 136)\n`EH2_RAM_BE(8192, 272)\n`EH2_RAM_BE(4096, 272)\n`EH2_RAM_BE(2048, 272)\n`EH2_RAM_BE(1024, 272)\n`EH2_RAM_BE(512, 272)\n`EH2_RAM_BE(256, 272)\n`EH2_RAM_BE(128, 272)\n`EH2_RAM_BE(64, 272)\n`EH2_RAM_BE(4096, 52)\n`EH2_RAM_BE(2048, 52)\n`EH2_RAM_BE(1024, 52)\n`EH2_RAM_BE(512, 52)\n`EH2_RAM_BE(256, 52)\n`EH2_RAM_BE(128, 52)\n`EH2_RAM_BE(64, 52)\n`EH2_RAM_BE(4096, 104)\n`EH2_RAM_BE(2048, 104)\n`EH2_RAM_BE(1024, 104)\n`EH2_RAM_BE(512, 104)\n`EH2_RAM_BE(256, 104)\n`EH2_RAM_BE(128, 104)\n`EH2_RAM_BE(64, 104)\n`EH2_RAM_BE(4096, 88)\n`EH2_RAM_BE(2048, 88)\n`EH2_RAM_BE(1024, 88)\n`EH2_RAM_BE(512, 88)\n`EH2_RAM_BE(256, 88)\n`EH2_RAM_BE(128, 88)\n`EH2_RAM_BE(64, 88)\n`EH2_RAM_BE(4096, 44)\n`EH2_RAM_BE(2048, 44)\n`EH2_RAM_BE(1024, 44)\n`EH2_RAM_BE(512, 44)\n`EH2_RAM_BE(256, 44)\n`EH2_RAM_BE(128, 44)\n`EH2_RAM_BE(64, 44)\n\n`EH2_RAM_BE(32, 124)\n`EH2_RAM_BE(64, 120)\n`EH2_RAM_BE(128, 120)\n`EH2_RAM_BE(256, 120)\n`EH2_RAM_BE(512, 120)\n`EH2_RAM_BE(32, 62)\n`EH2_RAM_BE(64, 60)\n`EH2_RAM_BE(128, 60)\n`EH2_RAM_BE(256, 60)\n`EH2_RAM_BE(512, 60)\n\n`undef EH2_RAM\n`undef EH2_RAM_BE\n`undef EH2_LOCAL_RAM_TEST_IO\n\n\n"}
{"text": "// SPDX-License-Identifier: Apache-2.0\n// Copyright 2019 Western Digital Corporation or it's affiliates.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License\n\nmodule rvjtag_tap #(\nparameter AWIDTH = 7\n)\n(\ninput               trst,\ninput               tck,\ninput               tms,\ninput               tdi,\noutput   reg        tdo,\noutput              tdoEnable,\n\noutput [31:0]       wr_data,\noutput [AWIDTH-1:0] wr_addr,\noutput              wr_en,\noutput              rd_en,\n\ninput   [31:0]      rd_data,\ninput   [1:0]       rd_status,\n\noutput  reg         dmi_reset,\noutput  reg         dmi_hard_reset,\n\ninput   [2:0]       idle,\ninput   [1:0]       dmi_stat,\n/*\n--  revisionCode        : 4'h0;\n--  manufacturersIdCode : 11'h45;\n--  deviceIdCode        : 16'h0001;\n--  order MSB .. LSB -> [4 bit version or revision] [16 bit part number] [11 bit manufacturer id] [value of 1'b1 in LSB]\n*/\ninput   [31:1]      jtag_id,\ninput   [3:0]       version\n);\n\nlocalparam USER_DR_LENGTH = AWIDTH + 34;\n\n\nreg [USER_DR_LENGTH-1:0] sr, nsr, dr;\n\n///////////////////////////////////////////////////////\n//                      Tap controller\n///////////////////////////////////////////////////////\nlogic[3:0] state, nstate;\nlogic [4:0] ir;\nwire jtag_reset;\nwire shift_dr;\nwire pause_dr;\nwire update_dr;\nwire capture_dr;\nwire shift_ir;\nwire pause_ir ;\nwire update_ir ;\nwire capture_ir;\nwire[1:0] dr_en;\nwire devid_sel;\nwire [5:0] abits;\n\nassign abits = AWIDTH[5:0];\n\n\nlocalparam TEST_LOGIC_RESET_STATE = 0;\nlocalparam RUN_TEST_IDLE_STATE    = 1;\nlocalparam SELECT_DR_SCAN_STATE   = 2;\nlocalparam CAPTURE_DR_STATE       = 3;\nlocalparam SHIFT_DR_STATE         = 4;\nlocalparam EXIT1_DR_STATE         = 5;\nlocalparam PAUSE_DR_STATE         = 6;\nlocalparam EXIT2_DR_STATE         = 7;\nlocalparam UPDATE_DR_STATE        = 8;\nlocalparam SELECT_IR_SCAN_STATE   = 9;\nlocalparam CAPTURE_IR_STATE       = 10;\nlocalparam SHIFT_IR_STATE         = 11;\nlocalparam EXIT1_IR_STATE         = 12;\nlocalparam PAUSE_IR_STATE         = 13;\nlocalparam EXIT2_IR_STATE         = 14;\nlocalparam UPDATE_IR_STATE        = 15;\n\nalways_comb  begin\n    nstate = state;\n    case(state)\n    TEST_LOGIC_RESET_STATE: nstate = tms ? TEST_LOGIC_RESET_STATE : RUN_TEST_IDLE_STATE;\n    RUN_TEST_IDLE_STATE:    nstate = tms ? SELECT_DR_SCAN_STATE   : RUN_TEST_IDLE_STATE;\n    SELECT_DR_SCAN_STATE:   nstate = tms ? SELECT_IR_SCAN_STATE   : CAPTURE_DR_STATE;\n    CAPTURE_DR_STATE:       nstate = tms ? EXIT1_DR_STATE         : SHIFT_DR_STATE;\n    SHIFT_DR_STATE:         nstate = tms ? EXIT1_DR_STATE         : SHIFT_DR_STATE;\n    EXIT1_DR_STATE:         nstate = tms ? UPDATE_DR_STATE        : PAUSE_DR_STATE;\n    PAUSE_DR_STATE:         nstate = tms ? EXIT2_DR_STATE         : PAUSE_DR_STATE;\n    EXIT2_DR_STATE:         nstate = tms ? UPDATE_DR_STATE        : SHIFT_DR_STATE;\n    UPDATE_DR_STATE:        nstate = tms ? SELECT_DR_SCAN_STATE   : RUN_TEST_IDLE_STATE;\n    SELECT_IR_SCAN_STATE:   nstate = tms ? TEST_LOGIC_RESET_STATE : CAPTURE_IR_STATE;\n    CAPTURE_IR_STATE:       nstate = tms ? EXIT1_IR_STATE         : SHIFT_IR_STATE;\n    SHIFT_IR_STATE:         nstate = tms ? EXIT1_IR_STATE         : SHIFT_IR_STATE;\n    EXIT1_IR_STATE:         nstate = tms ? UPDATE_IR_STATE        : PAUSE_IR_STATE;\n    PAUSE_IR_STATE:         nstate = tms ? EXIT2_IR_STATE         : PAUSE_IR_STATE;\n    EXIT2_IR_STATE:         nstate = tms ? UPDATE_IR_STATE        : SHIFT_IR_STATE;\n    UPDATE_IR_STATE:        nstate = tms ? SELECT_DR_SCAN_STATE   : RUN_TEST_IDLE_STATE;\n    default:                nstate = TEST_LOGIC_RESET_STATE;\n    endcase\nend\n\nalways @ (posedge tck or negedge trst) begin\n    if(!trst) state <= TEST_LOGIC_RESET_STATE;\n    else state <= nstate;\nend\n\nassign jtag_reset = state == TEST_LOGIC_RESET_STATE;\nassign shift_dr   = state == SHIFT_DR_STATE;\nassign pause_dr   = state == PAUSE_DR_STATE;\nassign update_dr  = state == UPDATE_DR_STATE;\nassign capture_dr = state == CAPTURE_DR_STATE;\nassign shift_ir   = state == SHIFT_IR_STATE;\nassign pause_ir   = state == PAUSE_IR_STATE;\nassign update_ir  = state == UPDATE_IR_STATE;\nassign capture_ir = state == CAPTURE_IR_STATE;\n\nassign tdoEnable = shift_dr | shift_ir;\n\n///////////////////////////////////////////////////////\n//                      IR register\n///////////////////////////////////////////////////////\n\nalways @ (negedge tck or negedge trst) begin\n   if (!trst) ir <= 5'b1;\n   else begin\n      if (jtag_reset) ir <= 5'b1;\n      else if (update_ir) ir <= (sr[4:0] == '0) ? 5'h1f :sr[4:0];\n   end\nend\n\n\nassign devid_sel  = ir == 5'b00001;\nassign dr_en[0]   = ir == 5'b10000;\nassign dr_en[1]   = ir == 5'b10001;\n\n///////////////////////////////////////////////////////\n//                      Shift register\n///////////////////////////////////////////////////////\nalways @ (posedge tck or negedge trst) begin\n    if(!trst)begin\n        sr <= '0;\n    end\n    else begin\n        sr <= nsr;\n    end\nend\n\n// SR next value\nalways_comb begin\n    nsr = sr;\n    case(1)\n    shift_dr:   begin\n                    case(1)\n                    dr_en[1]:   nsr = {tdi, sr[USER_DR_LENGTH-1:1]};\n\n                    dr_en[0],\n                    devid_sel:  nsr = {{USER_DR_LENGTH-32{1'b0}},tdi, sr[31:1]};\n                    default:    nsr = {{USER_DR_LENGTH-1{1'b0}},tdi}; // bypass\n                    endcase\n                end\n    capture_dr: begin\n                    nsr[0] = 1'b0;\n                    case(1)\n                    dr_en[0]:   nsr = {{USER_DR_LENGTH-15{1'b0}}, idle, dmi_stat, abits, version};\n                    dr_en[1]:   nsr = {{AWIDTH{1'b0}}, rd_data, rd_status};\n                    devid_sel:  nsr = {{USER_DR_LENGTH-32{1'b0}}, jtag_id, 1'b1};\n                    endcase\n                end\n    shift_ir:   nsr = {{USER_DR_LENGTH-5{1'b0}},tdi, sr[4:1]};\n    capture_ir: nsr = {{USER_DR_LENGTH-1{1'b0}},1'b1};\n    endcase\nend\n\n// TDO retiming\nalways @ (negedge tck ) tdo <= sr[0];\n\n// DMI CS register\nalways @ (posedge tck or negedge trst) begin\n    if(!trst) begin\n        dmi_hard_reset <= 1'b0;\n        dmi_reset      <= 1'b0;\n    end\n    else if (update_dr & dr_en[0]) begin\n        dmi_hard_reset <= sr[17];\n        dmi_reset      <= sr[16];\n    end\n    else begin\n        dmi_hard_reset <= 1'b0;\n        dmi_reset      <= 1'b0;\n    end\nend\n\n// DR register\nalways @ (posedge tck or negedge trst) begin\n    if(!trst)\n        dr <=  '0;\n    else begin\n        if (update_dr & dr_en[1])\n            dr <= sr;\n        else\n            dr <= {dr[USER_DR_LENGTH-1:2],2'b0};\n    end\nend\n\nassign {wr_addr, wr_data, wr_en, rd_en} = dr;\n\n\n\n\nendmodule\n"}
