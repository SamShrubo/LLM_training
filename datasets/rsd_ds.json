{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Axi4LiteControlMemoryIF\n//\n\nimport BasicTypes::*;\nimport MemoryTypes::*;\n\ninterface Axi4LiteControlMemoryIF();\n\n    // Global Clock Signal\n    logic S_AXI_ACLK;\n    // Global Reset Signal. This Signal is Active LOW\n    logic S_AXI_ARESETN;\n    // Write address (issued by master, acceped by Slave)\n    logic [PS_PL_MEMORY_ADDR_BIT_SIZE-1 : 0] S_AXI_AWADDR;\n    // Write channel Protection type. This signal indicates the\n        // privilege and security level of the transaction, and whether\n        // the transaction is a data access or an instruction access.\n    logic [2 : 0] S_AXI_AWPROT;\n    // Write address valid. This signal indicates that the master signaling\n        // valid write address and control information.\n    logic  S_AXI_AWVALID;\n    // Write address ready. This signal indicates that the slave is ready\n        // to accept an address and associated control signals.\n    logic  S_AXI_AWREADY;\n    // Write data (issued by master, acceped by Slave) \n    logic [PS_PL_MEMORY_DATA_BIT_SIZE-1 : 0] S_AXI_WDATA;\n    // Write strobes. This signal indicates which byte lanes hold\n        // valid data. There is one write strobe bit for each eight\n        // bits of the write data bus.    \n    logic [(PS_PL_MEMORY_DATA_BIT_SIZE/8)-1 : 0] S_AXI_WSTRB;\n    // Write valid. This signal indicates that valid write\n        // data and strobes are available.\n    logic  S_AXI_WVALID;\n    // Write ready. This signal indicates that the slave\n        // can accept the write data.\n    logic  S_AXI_WREADY;\n    // Write response. This signal indicates the status\n        // of the write transaction.\n    logic [1 : 0] S_AXI_BRESP;\n    // Write response valid. This signal indicates that the channel\n        // is signaling a valid write response.\n    logic  S_AXI_BVALID;\n    // Response ready. This signal indicates that the master\n        // can accept a write response.\n    logic  S_AXI_BREADY;\n    // Read address (issued by master, acceped by Slave)\n    logic [PS_PL_MEMORY_ADDR_BIT_SIZE-1 : 0] S_AXI_ARADDR;\n    // Protection type. This signal indicates the privilege\n        // and security level of the transaction, and whether the\n        // transaction is a data access or an instruction access.\n    logic [2 : 0] S_AXI_ARPROT;\n    // Read address valid. This signal indicates that the channel\n        // is signaling valid read address and control information.\n    logic  S_AXI_ARVALID;\n    // Read address ready. This signal indicates that the slave is\n        // ready to accept an address and associated control signals.\n    logic  S_AXI_ARREADY;\n    // Read data (issued by slave)\n    logic [PS_PL_MEMORY_DATA_BIT_SIZE-1 : 0] S_AXI_RDATA;\n    // Read response. This signal indicates the status of the\n        // read transfer.\n    logic [1 : 0] S_AXI_RRESP;\n    // Read valid. This signal indicates that the channel is\n        // signaling the required read data.\n    logic  S_AXI_RVALID;\n    // Read ready. This signal indicates that the master can\n        // accept the read data and response information.\n    logic  S_AXI_RREADY;\n\n    modport Axi4Lite(\n    input\n        S_AXI_ACLK,\n        S_AXI_ARESETN,\n        S_AXI_AWADDR,\n        S_AXI_AWPROT,\n        S_AXI_AWVALID,\n    output\n        S_AXI_AWREADY,\n    input\n        S_AXI_WDATA,\n        S_AXI_WSTRB,\n        S_AXI_WVALID,\n    output\n        S_AXI_WREADY,\n        S_AXI_BRESP,\n        S_AXI_BVALID,\n    input\n        S_AXI_BREADY,\n        S_AXI_ARADDR,\n        S_AXI_ARPROT,\n        S_AXI_ARVALID,\n    output\n        S_AXI_ARREADY,\n        S_AXI_RDATA,\n        S_AXI_RRESP,\n        S_AXI_RVALID,\n    input\n        S_AXI_RREADY\n    );\n\n    modport Axi4LiteWrite(\n    input\n        S_AXI_ACLK,\n        S_AXI_ARESETN,\n        S_AXI_AWADDR,\n        S_AXI_AWPROT,\n        S_AXI_AWVALID,\n    output\n        S_AXI_AWREADY,\n    input\n        S_AXI_WDATA,\n        S_AXI_WSTRB,\n        S_AXI_WVALID,\n    output\n        S_AXI_WREADY,\n        S_AXI_BRESP,\n        S_AXI_BVALID,\n    input\n        S_AXI_BREADY\n    );\n\n    modport Axi4LiteRead(\n    input\n        S_AXI_ACLK,\n        S_AXI_ARESETN,\n        S_AXI_ARADDR,\n        S_AXI_ARPROT,\n        S_AXI_ARVALID,\n    output\n        S_AXI_ARREADY,\n        S_AXI_RDATA,\n        S_AXI_RRESP,\n        S_AXI_RVALID,\n    input\n        S_AXI_RREADY\n    );\n\nendinterface : Axi4LiteControlMemoryIF\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n\n// `timescale 1 ns / 1 ps\n\n`include \"SysDeps/XilinxMacros.vh\"\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport MemoryTypes::*;\nimport IO_UnitTypes::*;\n\nmodule Axi4LitePlToPsControlRegister\n(\n  Axi4LiteControlRegisterIF.Axi4LiteRead port,\n\n  input\n    logic we,\n    SerialDataPath wv,\n    PC_Path lastCommittedPC\n);\n\n    // AXI4LITE signals\n    logic [`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1: 0] axi_araddr;\n    logic axi_arready;\n    logic [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1: 0] axi_rdata;\n    logic [1: 0] axi_rresp;\n    logic axi_rvalid;\n\n\n    // Example-specific design signals\n    // local parameter for addressing 32 bit / 64 bit `PS_PL_CTRL_REG_DATA_BIT_SIZE\n    // PS_PL_MEMORY_ADDR_LSB is used for addressing 32/64 bit registers/memories\n    // PS_PL_MEMORY_ADDR_LSB = 2 for 32 bits (n downto 2)\n    // PS_PL_MEMORY_ADDR_LSB = 3 for 64 bits (n downto 3)\n    // localparam integer PS_PL_MEMORY_ADDR_LSB = (`PS_PL_CTRL_REG_DATA_BIT_SIZE/32) + 1;\n    // localparam integer OPT_MEM_ADDR_BITS = 4;\n    logic slv_reg_rden;\n\n\n    // Control register\n    logic [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1: 0] mem [`PS_PL_CTRL_REG_SIZE];\n\n    logic push;\n    logic pop;\n    logic full;\n    logic empty;\n    logic [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1: 0] headData;\n\n    // I/O Connections assignments\n\n    assign port.S_AXI_ARREADY = axi_arready;\n    assign port.S_AXI_RDATA   = axi_rdata;\n    assign port.S_AXI_RRESP   = axi_rresp;\n    assign port.S_AXI_RVALID  = axi_rvalid;  \n\n    // Implement axi_arready generation\n    // axi_arready is asserted for one port.S_AXI_ACLK clock cycle when\n    // port.S_AXI_ARVALID is asserted. axi_awready is \n    // de-asserted when reset (active low) is asserted. \n    // The read address is also latched when port.S_AXI_ARVALID is \n    // asserted. axi_araddr is reset to zero on reset assertion.\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_arready <= 1'b0;\n          axi_araddr  <= 32'b0;\n        end \n      else\n        begin    \n          if (~axi_arready && port.S_AXI_ARVALID)\n            begin\n              // indicates that the slave has acceped the valid read address\n              axi_arready <= 1'b1;\n              // Read address latching\n              axi_araddr  <= port.S_AXI_ARADDR;\n            end\n          else\n            begin\n              axi_arready <= 1'b0;\n            end\n        end \n    end       \n\n    // Implement axi_arvalid generation\n    // axi_rvalid is asserted for one port.S_AXI_ACLK clock cycle when both \n    // port.S_AXI_ARVALID and axi_arready are asserted. The slave registers \n    // data are available on the axi_rdata bus at this instance. The \n    // assertion of axi_rvalid marks the validity of read data on the \n    // bus and axi_rresp indicates the status of read transaction.axi_rvalid \n    // is deasserted on reset (active low). axi_rresp and axi_rdata are \n    // cleared to zero on reset (active low). \n\n    \n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_rvalid  <= 0;\n          axi_rresp   <= 0;\n        end \n      else\n        begin    \n          if (axi_arready && port.S_AXI_ARVALID && ~axi_rvalid)\n            begin\n              // Valid read data is available at the read data bus\n              axi_rvalid <= 1'b1;\n              axi_rresp  <= 2'b0; // 'OKAY' response\n            end   \n          else if (axi_rvalid && port.S_AXI_RREADY)\n            begin\n              // Read data is accepted by the master\n              axi_rvalid <= 1'b0;\n            end                \n        end\n    end    \n\n    // Implement memory mapped register select and read logic generation\n    // Slave register read enable is asserted when valid address is available\n    // and the slave is ready to accept the read address.\n    assign slv_reg_rden = axi_arready & port.S_AXI_ARVALID & ~axi_rvalid;\n\n    // Output register or memory read data\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_rdata  <= 0;\n        end \n      else\n        begin    \n          // When there is a valid read address (port.S_AXI_ARVALID) with \n          // acceptance of read address by the slave (axi_arready), \n          // output the read dada \n          if (slv_reg_rden)\n            begin\n              axi_rdata <= mem[axi_araddr[`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1:`PS_PL_CTRL_REG_ADDR_LSB]];     // register read data\n            end   \n        end\n    end    \n\n    assign pop = (axi_rvalid && \n                  port.S_AXI_RREADY &&\n                  (axi_araddr[`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1:`PS_PL_CTRL_REG_ADDR_LSB] == 1) &&\n                  ~empty) ? 1'd1 : 1'd0;\n\n    assign push = we & ~full;\n\n    logic [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1: 0] committedInstCnt;\n    PC_Path prevLastCommittedPC;\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n        if ( port.S_AXI_ARESETN == 1'b0 ) begin\n            prevLastCommittedPC <= '0;\n        end\n        else begin\n            prevLastCommittedPC <= lastCommittedPC;\n        end\n    end\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n        if ( port.S_AXI_ARESETN == 1'b0 ) begin\n            committedInstCnt <= '0;\n        end\n        else if (prevLastCommittedPC != lastCommittedPC) begin\n            committedInstCnt <= committedInstCnt + 1;\n        end\n        else begin\n            committedInstCnt <= committedInstCnt;\n        end\n    end\n    \n    ControlQueue controlQueue ( \n        .clk        ( port.S_AXI_ACLK ),\n        .rst        ( ~port.S_AXI_ARESETN ),\n        .push       ( push ),\n        .pop        ( pop ),\n        .pushedData ( wv ),\n        .full       ( full ),\n        .empty      ( empty ),\n        .headData   ( headData )\n    );\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n        mem[0]  <= empty;\n        mem[1]  <= headData;\n        mem[2]  <= full;\n        mem[3]  <= wv;\n        mem[4]  <= lastCommittedPC;\n        mem[5]  <= committedInstCnt;\n    end\n\n\n    // BlockDualPortRAM #( \n    //     .ENTRY_NUM(PS_PL_MEMORY_SIZE), \n    //     .ENTRY_BIT_SIZE(`PS_PL_CTRL_REG_DATA_BIT_SIZE)\n    // ) ram ( \n    //     port.S_AXI_ACLK,\n    //     slv_reg_wren,\n    //     axi_awaddr[PS_PL_MEMORY_ADDR_BIT_SIZE-1:PS_PL_MEMORY_ADDR_LSB],\n    //     port.S_AXI_WDATA,\n    //     axi_araddr[PS_PL_MEMORY_ADDR_BIT_SIZE-1:PS_PL_MEMORY_ADDR_LSB],\n    //     reg_data_out\n    // );\n\nendmodule : Axi4LitePlToPsControlRegister\n\n\nmodule Axi4LitePsToPlControlRegister\n(\n  Axi4LiteControlRegisterIF.Axi4Lite port,\n\n  output\n    AddrPath memory_addr,\n    MemoryEntryDataPath memory_data,\n    logic memory_we,\n    logic done // program load is done\n);\n\n    localparam WORD_NUM = MEMORY_ENTRY_BIT_NUM/`PS_PL_CTRL_REG_DATA_BIT_SIZE;\n    localparam WORD_NUM_BIT_SIZE = $clog2(WORD_NUM);\n    \n    localparam FULL_OFFSET             = 0;\n    localparam MEMORY_WORDCOUNT_OFFSET = 3;\n    localparam EMPTY_OFFSET            = 4;\n    localparam POPED_DATACOUNT_OFFSET  = 5;\n\n    localparam PUSHED_DATA_OFFSET      = 0;\n    localparam MEMORY_ADDR_OFFSET      = 1;\n    localparam PROGRAM_WORDSIZE_OFFSET = 2;\n    localparam RSD_RUN_OFFSET          = 6;\n\n    // AXI4LITE signals\n    logic [`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1: 0] axi_awaddr;\n    logic axi_awready;\n    logic axi_wready;\n    logic [1 : 0] axi_bresp;\n    logic axi_bvalid;\n    logic [`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1: 0] axi_araddr;\n    logic axi_arready;\n    logic [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1: 0] axi_rdata;\n    logic [1 : 0] axi_rresp;\n    logic axi_rvalid;\n\n    // Example-specific design signals\n    // local parameter for addressing 32 bit / 64 bit `PS_PL_CTRL_REG_DATA_BIT_SIZE\n    // `PS_PL_CTRL_REG_ADDR_LSB is used for addressing 32/64 bit registers/memories\n    // `PS_PL_CTRL_REG_ADDR_LSB = 2 for 32 bits (n downto 2)\n    // `PS_PL_CTRL_REG_ADDR_LSB = 3 for 64 bits (n downto 3)\n    // localparam integer `PS_PL_CTRL_REG_ADDR_LSB = (`PS_PL_CTRL_REG_DATA_BIT_SIZE/32) + 1;\n    // localparam integer OPT_MEM_ADDR_BITS = 4;\n    logic slv_reg_rden;\n    logic slv_reg_wren;\n    logic [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1:0] reg_data_out;\n    logic aw_en;\n\n    logic pop;\n    logic full;\n    logic empty;\n    logic [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1: 0] headData;\n\n    logic push;\n    logic [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1: 0] pushedData;\n\n    logic [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1: 0] memory_wordcount;\n    logic [WORD_NUM_BIT_SIZE-1:0]             poped_datacount;\n\n    // Control register\n    logic [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1: 0] mem [`PS_PL_CTRL_REG_SIZE];\n\n    // I/O Connections assignments\n\n    assign port.S_AXI_AWREADY = axi_awready;\n    assign port.S_AXI_WREADY  = axi_wready;\n    assign port.S_AXI_BRESP   = axi_bresp;\n    assign port.S_AXI_BVALID  = axi_bvalid;\n    assign port.S_AXI_ARREADY = axi_arready;\n    assign port.S_AXI_RDATA   = axi_rdata;\n    assign port.S_AXI_RRESP   = axi_rresp;\n    assign port.S_AXI_RVALID  = axi_rvalid;\n    // Implement axi_awready generation\n    // axi_awready is asserted for one port.S_AXI_ACLK clock cycle when both\n    // port.S_AXI_AWVALID and port.S_AXI_WVALID are asserted. axi_awready is\n    // de-asserted when reset is low.\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_awready <= 1'b0;\n          aw_en <= 1'b1;\n        end \n      else\n        begin    \n          if (~axi_awready && port.S_AXI_AWVALID && port.S_AXI_WVALID && aw_en)\n            begin\n              // slave is ready to accept write address when \n              // there is a valid write address and write data\n              // on the write address and data bus. This design \n              // expects no outstanding transactions. \n              axi_awready <= 1'b1;\n              aw_en <= 1'b0;\n            end\n            else if (port.S_AXI_BREADY && axi_bvalid)\n                begin\n                  aw_en <= 1'b1;\n                  axi_awready <= 1'b0;\n                end\n          else           \n            begin\n              axi_awready <= 1'b0;\n            end\n        end \n    end       \n\n    // Implement axi_awaddr latching\n    // This process is used to latch the address when both \n    // port.S_AXI_AWVALID and port.S_AXI_WVALID are valid. \n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_awaddr <= 0;\n        end \n      else\n        begin    \n          if (~axi_awready && port.S_AXI_AWVALID && port.S_AXI_WVALID && aw_en)\n            begin\n              // Write Address latching \n              axi_awaddr <= port.S_AXI_AWADDR;\n            end\n        end \n    end       \n\n    // Implement axi_wready generation\n    // axi_wready is asserted for one port.S_AXI_ACLK clock cycle when both\n    // port.S_AXI_AWVALID and port.S_AXI_WVALID are asserted. axi_wready is \n    // de-asserted when reset is low. \n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_wready <= 1'b0;\n        end \n      else\n        begin    \n          if (~axi_wready && port.S_AXI_WVALID && port.S_AXI_AWVALID && aw_en )\n            begin\n              // slave is ready to accept write data when \n              // there is a valid write address and write data\n              // on the write address and data bus. This design \n              // expects no outstanding transactions. \n              axi_wready <= 1'b1;\n            end\n          else\n            begin\n              axi_wready <= 1'b0;\n            end\n        end \n    end       \n\n    // Implement memory mapped register select and write logic generation\n    // The write data is accepted and written to memory mapped registers when\n    // axi_awready, port.S_AXI_WVALID, axi_wready and port.S_AXI_WVALID are asserted. Write strobes are used to\n    // select byte enables of slave registers while writing.\n    // These registers are cleared when reset (active low) is applied.\n    // Slave register write enable is asserted when valid address and data are available\n    // and the slave is ready to accept the write address and write data.\n    assign slv_reg_wren = axi_wready && port.S_AXI_WVALID && axi_awready && port.S_AXI_AWVALID;\n\n\n    // Implement write response logic generation\n    // The write response and response valid signals are asserted by the slave \n    // when axi_wready, port.S_AXI_WVALID, axi_wready and port.S_AXI_WVALID are asserted.  \n    // This marks the acceptance of address and indicates the status of \n    // write transaction.\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_bvalid  <= 0;\n          axi_bresp   <= 2'b0;\n        end \n      else\n        begin    \n          if (axi_awready && port.S_AXI_AWVALID && ~axi_bvalid && axi_wready && port.S_AXI_WVALID)\n            begin\n              // indicates a valid write response is available\n              axi_bvalid <= 1'b1;\n              axi_bresp  <= 2'b0; // 'OKAY' response \n            end                   // work error responses in future\n          else\n            begin\n              if (port.S_AXI_BREADY && axi_bvalid) \n                //check if bready is asserted while bvalid is high) \n                //(there is a possibility that bready is always asserted high)   \n                begin\n                  axi_bvalid <= 1'b0; \n                end  \n            end\n        end\n    end   \n\n    // Implement axi_arready generation\n    // axi_arready is asserted for one port.S_AXI_ACLK clock cycle when\n    // port.S_AXI_ARVALID is asserted. axi_awready is \n    // de-asserted when reset (active low) is asserted. \n    // The read address is also latched when port.S_AXI_ARVALID is \n    // asserted. axi_araddr is reset to zero on reset assertion.\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_arready <= 1'b0;\n          axi_araddr  <= 32'b0;\n        end \n      else\n        begin    \n          if (~axi_arready && port.S_AXI_ARVALID)\n            begin\n              // indicates that the slave has acceped the valid read address\n              axi_arready <= 1'b1;\n              // Read address latching\n              axi_araddr  <= port.S_AXI_ARADDR;\n            end\n          else\n            begin\n              axi_arready <= 1'b0;\n            end\n        end \n    end       \n\n    // Implement axi_arvalid generation\n    // axi_rvalid is asserted for one port.S_AXI_ACLK clock cycle when both \n    // port.S_AXI_ARVALID and axi_arready are asserted. The slave registers \n    // data are available on the axi_rdata bus at this instance. The \n    // assertion of axi_rvalid marks the validity of read data on the \n    // bus and axi_rresp indicates the status of read transaction.axi_rvalid \n    // is deasserted on reset (active low). axi_rresp and axi_rdata are \n    // cleared to zero on reset (active low). \n\n    \n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_rvalid  <= 0;\n          axi_rresp   <= 0;\n        end \n      else\n        begin    \n          if (axi_arready && port.S_AXI_ARVALID && ~axi_rvalid)\n            begin\n              // Valid read data is available at the read data bus\n              axi_rvalid <= 1'b1;\n              axi_rresp   <= 2'b0; // 'OKAY' response\n            end   \n          else if (axi_rvalid && port.S_AXI_RREADY)\n            begin\n              // Read data is accepted by the master\n              axi_rvalid <= 1'b0;\n            end                \n        end\n    end    \n\n    // Implement memory mapped register select and read logic generation\n    // Slave register read enable is asserted when valid address is available\n    // and the slave is ready to accept the read address.\n    assign slv_reg_rden = axi_arready & port.S_AXI_ARVALID & ~axi_rvalid;\n\n    // Output register or memory read data\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_rdata  <= 0;\n        end \n      else\n        begin    \n          // When there is a valid read address (port.S_AXI_ARVALID) with \n          // acceptance of read address by the slave (axi_arready), \n          // output the read dada \n          if (slv_reg_rden)\n            begin\n              axi_rdata <= reg_data_out;     // register read data\n            end   \n        end\n    end    \n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n        if (~port.S_AXI_ARESETN) begin\n            for (int i=0;i<`PS_PL_CTRL_REG_SIZE;i++) begin\n                if (i == PROGRAM_WORDSIZE_OFFSET) begin\n                    mem[i] <= {`PS_PL_CTRL_REG_DATA_BIT_SIZE{1'd1}};\n                end\n                else begin\n                    mem[i] <= 0;\n                end\n            end\n        end\n        else if (slv_reg_wren) begin\n            mem[axi_awaddr[`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1:`PS_PL_CTRL_REG_ADDR_LSB]] <= port.S_AXI_WDATA;\n        end\n    end\n\n    always_comb\n    begin\n        if (axi_araddr[`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1:`PS_PL_CTRL_REG_ADDR_LSB] == FULL_OFFSET) begin\n            reg_data_out = {{(`PS_PL_CTRL_REG_DATA_BIT_SIZE-1){1'd0}}, full};\n        end\n        else if (axi_araddr[`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1:`PS_PL_CTRL_REG_ADDR_LSB] == MEMORY_WORDCOUNT_OFFSET) begin\n            reg_data_out = memory_wordcount;\n        end\n        else if (axi_araddr[`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1:`PS_PL_CTRL_REG_ADDR_LSB] == EMPTY_OFFSET) begin\n            reg_data_out = {{(`PS_PL_CTRL_REG_DATA_BIT_SIZE-1){1'd0}}, empty};\n        end\n        else if (axi_araddr[`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1:`PS_PL_CTRL_REG_ADDR_LSB] == POPED_DATACOUNT_OFFSET) begin\n            reg_data_out = {{(`PS_PL_CTRL_REG_DATA_BIT_SIZE-WORD_NUM_BIT_SIZE){1'd0}}, poped_datacount};\n        end\n        else begin\n            reg_data_out = mem[axi_araddr[`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1:`PS_PL_CTRL_REG_ADDR_LSB]];\n        end\n    end\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n        if (~port.S_AXI_ARESETN) begin\n            pushedData <= 0;\n            push       <= 0;\n        end\n        else begin\n            pushedData <= port.S_AXI_WDATA;\n            push       <= \n                (slv_reg_wren && \n                 (axi_awaddr[`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1:`PS_PL_CTRL_REG_ADDR_LSB] == PUSHED_DATA_OFFSET)) ? 1 : 0;\n        end\n    end\n\n    generate\n    if (ADDR_WIDTH>`PS_PL_CTRL_REG_DATA_BIT_SIZE) begin\n        assign memory_addr = {{(ADDR_WIDTH-`PS_PL_CTRL_REG_DATA_BIT_SIZE){1'd0}}, mem[MEMORY_ADDR_OFFSET]};\n    end\n    else if (ADDR_WIDTH==`PS_PL_CTRL_REG_DATA_BIT_SIZE) begin\n        assign memory_addr = mem[MEMORY_ADDR_OFFSET];\n    end\n    else begin\n        assign memory_addr = mem[MEMORY_ADDR_OFFSET][ADDR_WIDTH-1:0];\n    end\n    endgenerate\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n        if (~port.S_AXI_ARESETN) begin\n            memory_data     <= 0;\n            poped_datacount <= 0;\n        end\n        else if (pop) begin\n            memory_data     <= {memory_data[MEMORY_ENTRY_BIT_NUM-`PS_PL_CTRL_REG_DATA_BIT_SIZE-1:0], headData};\n            if (poped_datacount == (WORD_NUM-1)) begin\n                poped_datacount <= 0;\n            end\n            else begin\n                poped_datacount <= poped_datacount + 1;\n            end\n        end\n    end\n\n    assign pop = ~empty;\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n        if (~port.S_AXI_ARESETN) begin\n            memory_we        <= 0;\n            memory_wordcount <= 0;\n        end\n        else if ((poped_datacount == (WORD_NUM-1)) && pop) begin\n            memory_we        <= 1;\n            memory_wordcount <= memory_wordcount + 1;\n        end\n        else begin\n            memory_we        <= 0;\n        end\n    end\n\n`ifdef RSD_U"}
{"text": "SE_PROGRAM_LOADER\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n        if (~port.S_AXI_ARESETN) begin\n            done <= 0;\n        end\n        else if (memory_wordcount >= mem[PROGRAM_WORDSIZE_OFFSET]) begin\n            done <= 1;\n        end\n    end\n`else \n    assign done = mem[RSD_RUN_OFFSET][0];\n`endif\n\n    ControlQueue controlQueue ( \n        .clk        ( port.S_AXI_ACLK ),\n        .rst        ( ~port.S_AXI_ARESETN ),\n        .push       ( push ),\n        .pop        ( pop ),\n        .pushedData ( pushedData ),\n        .full       ( full ),\n        .empty      ( empty ),\n        .headData   ( headData )\n    );\n\nendmodule : Axi4LitePsToPlControlRegister\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Axi4LiteControlRegisterIF\n//\n\n`include \"SysDeps/XilinxMacros.vh\"\n\nimport BasicTypes::*;\nimport MemoryTypes::*;\n\ninterface Axi4LiteControlRegisterIF;\n\n    // Global Clock Signal\n    logic S_AXI_ACLK;\n    // Global Reset Signal. This Signal is Active LOW\n    logic S_AXI_ARESETN;\n    // Write address (issued by master, acceped by Slave)\n    logic [`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1 : 0] S_AXI_AWADDR;\n    // Write channel Protection type. This signal indicates the\n        // privilege and security level of the transaction, and whether\n        // the transaction is a data access or an instruction access.\n    logic [`PS_PL_CTRL_REG_AWPROT_WIDTH-1 : 0] S_AXI_AWPROT;\n    // Write address valid. This signal indicates that the master signaling\n        // valid write address and control information.\n    logic  S_AXI_AWVALID;\n    // Write address ready. This signal indicates that the slave is ready\n        // to accept an address and associated control signals.\n    logic  S_AXI_AWREADY;\n    // Write data (issued by master, acceped by Slave) \n    logic [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1 : 0] S_AXI_WDATA;\n    // Write strobes. This signal indicates which byte lanes hold\n        // valid data. There is one write strobe bit for each eight\n        // bits of the write data bus.    \n    logic [`PS_PL_CTRL_REG_WSTRB_WIDTH-1 : 0] S_AXI_WSTRB;\n    // Write valid. This signal indicates that valid write\n        // data and strobes are available.\n    logic  S_AXI_WVALID;\n    // Write ready. This signal indicates that the slave\n        // can accept the write data.\n    logic  S_AXI_WREADY;\n    // Write response. This signal indicates the status\n        // of the write transaction.\n    logic [`PS_PL_CTRL_REG_BRESP_WIDTH-1 : 0] S_AXI_BRESP;\n    // Write response valid. This signal indicates that the channel\n        // is signaling a valid write response.\n    logic  S_AXI_BVALID;\n    // Response ready. This signal indicates that the master\n        // can accept a write response.\n    logic  S_AXI_BREADY;\n    // Read address (issued by master, acceped by Slave)\n    logic [`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1 : 0] S_AXI_ARADDR;\n    // Protection type. This signal indicates the privilege\n        // and security level of the transaction, and whether the\n        // transaction is a data access or an instruction access.\n    logic [`PS_PL_CTRL_REG_ARPROT_WIDTH-1 : 0] S_AXI_ARPROT;\n    // Read address valid. This signal indicates that the channel\n        // is signaling valid read address and control information.\n    logic  S_AXI_ARVALID;\n    // Read address ready. This signal indicates that the slave is\n        // ready to accept an address and associated control signals.\n    logic  S_AXI_ARREADY;\n    // Read data (issued by slave)\n    logic [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1 : 0] S_AXI_RDATA;\n    // Read response. This signal indicates the status of the\n        // read transfer.\n    logic [`PS_PL_CTRL_REG_RRESP_WIDTH-1 : 0] S_AXI_RRESP;\n    // Read valid. This signal indicates that the channel is\n        // signaling the required read data.\n    logic  S_AXI_RVALID;\n    // Read ready. This signal indicates that the master can\n        // accept the read data and response information.\n    logic  S_AXI_RREADY;\n\n    modport Axi4Lite(\n    input\n        S_AXI_ACLK,\n        S_AXI_ARESETN,\n        S_AXI_AWADDR,\n        S_AXI_AWPROT,\n        S_AXI_AWVALID,\n    output\n        S_AXI_AWREADY,\n    input\n        S_AXI_WDATA,\n        S_AXI_WSTRB,\n        S_AXI_WVALID,\n    output\n        S_AXI_WREADY,\n        S_AXI_BRESP,\n        S_AXI_BVALID,\n    input\n        S_AXI_BREADY,\n        S_AXI_ARADDR,\n        S_AXI_ARPROT,\n        S_AXI_ARVALID,\n    output\n        S_AXI_ARREADY,\n        S_AXI_RDATA,\n        S_AXI_RRESP,\n        S_AXI_RVALID,\n    input\n        S_AXI_RREADY\n    );\n\n    modport Axi4LiteWrite(\n    input\n        S_AXI_ACLK,\n        S_AXI_ARESETN,\n        S_AXI_AWADDR,\n        S_AXI_AWPROT,\n        S_AXI_AWVALID,\n    output\n        S_AXI_AWREADY,\n    input\n        S_AXI_WDATA,\n        S_AXI_WSTRB,\n        S_AXI_WVALID,\n    output\n        S_AXI_WREADY,\n        S_AXI_BRESP,\n        S_AXI_BVALID,\n    input\n        S_AXI_BREADY\n    );\n\n    modport Axi4LiteRead(\n    input\n        S_AXI_ACLK,\n        S_AXI_ARESETN,\n        S_AXI_ARADDR,\n        S_AXI_ARPROT,\n        S_AXI_ARVALID,\n    output\n        S_AXI_ARREADY,\n        S_AXI_RDATA,\n        S_AXI_RRESP,\n        S_AXI_RVALID,\n    input\n        S_AXI_RREADY\n    );\n\nendinterface : Axi4LiteControlRegisterIF\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n\n// `timescale 1 ns / 1 ps\n\nimport BasicTypes::*;\nimport MemoryTypes::*;\n\nmodule Axi4LiteDualPortBlockRAM\n(\n    Axi4LiteControlMemoryIF.Axi4Lite port\n);\n\n    // AXI4LITE signals\n    logic [PS_PL_MEMORY_ADDR_BIT_SIZE-1 : 0] axi_awaddr;\n    logic axi_awready;\n    logic axi_wready;\n    logic [1 : 0] axi_bresp;\n    logic axi_bvalid;\n    logic [PS_PL_MEMORY_ADDR_BIT_SIZE-1 : 0] axi_araddr;\n    logic axi_arready;\n    logic [DATA_WIDTH-1 : 0] axi_rdata;\n    logic [1 : 0] axi_rresp;\n    logic axi_rvalid;\n    logic axi_reading;\n\n\n    // Example-specific design signals\n    // local parameter for addressing 32 bit / 64 bit DATA_WIDTH\n    // PS_PL_MEMORY_ADDR_LSB is used for addressing 32/64 bit registers/memories\n    // PS_PL_MEMORY_ADDR_LSB = 2 for 32 bits (n downto 2)\n    // PS_PL_MEMORY_ADDR_LSB = 3 for 64 bits (n downto 3)\n    // localparam integer PS_PL_MEMORY_ADDR_LSB = (DATA_WIDTH/32) + 1;\n    // localparam integer OPT_MEM_ADDR_BITS = 4;\n    logic slv_reg_rden;\n    logic slv_reg_wren;\n    logic [DATA_WIDTH-1:0] reg_data_out;\n    logic aw_en;\n\n    // I/O Connections assignments\n\n    assign port.S_AXI_AWREADY = axi_awready;\n    assign port.S_AXI_WREADY  = axi_wready;\n    assign port.S_AXI_BRESP      = axi_bresp;\n    assign port.S_AXI_BVALID  = axi_bvalid;\n    assign port.S_AXI_ARREADY = axi_arready;\n    assign port.S_AXI_RDATA      = axi_rdata;\n    assign port.S_AXI_RRESP      = axi_rresp;\n    assign port.S_AXI_RVALID  = axi_rvalid;\n    // Implement axi_awready generation\n    // axi_awready is asserted for one port.S_AXI_ACLK clock cycle when both\n    // port.S_AXI_AWVALID and port.S_AXI_WVALID are asserted. axi_awready is\n    // de-asserted when reset is low.\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_awready <= 1'b0;\n          aw_en <= 1'b1;\n        end \n      else\n        begin    \n          if (~axi_awready && port.S_AXI_AWVALID && port.S_AXI_WVALID && aw_en)\n            begin\n              // slave is ready to accept write address when \n              // there is a valid write address and write data\n              // on the write address and data bus. This design \n              // expects no outstanding transactions. \n              axi_awready <= 1'b1;\n              aw_en <= 1'b0;\n            end\n            else if (port.S_AXI_BREADY && axi_bvalid)\n                begin\n                  aw_en <= 1'b1;\n                  axi_awready <= 1'b0;\n                end\n          else           \n            begin\n              axi_awready <= 1'b0;\n            end\n        end \n    end       \n\n    // Implement axi_awaddr latching\n    // This process is used to latch the address when both \n    // port.S_AXI_AWVALID and port.S_AXI_WVALID are valid. \n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_awaddr <= 0;\n        end \n      else\n        begin    \n          if (~axi_awready && port.S_AXI_AWVALID && port.S_AXI_WVALID && aw_en)\n            begin\n              // Write Address latching \n              axi_awaddr <= port.S_AXI_AWADDR;\n            end\n        end \n    end       \n\n    // Implement axi_wready generation\n    // axi_wready is asserted for one port.S_AXI_ACLK clock cycle when both\n    // port.S_AXI_AWVALID and port.S_AXI_WVALID are asserted. axi_wready is \n    // de-asserted when reset is low. \n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_wready <= 1'b0;\n        end \n      else\n        begin    \n          if (~axi_wready && port.S_AXI_WVALID && port.S_AXI_AWVALID && aw_en )\n            begin\n              // slave is ready to accept write data when \n              // there is a valid write address and write data\n              // on the write address and data bus. This design \n              // expects no outstanding transactions. \n              axi_wready <= 1'b1;\n            end\n          else\n            begin\n              axi_wready <= 1'b0;\n            end\n        end \n    end       \n\n    // Implement memory mapped register select and write logic generation\n    // The write data is accepted and written to memory mapped registers when\n    // axi_awready, port.S_AXI_WVALID, axi_wready and port.S_AXI_WVALID are asserted. Write strobes are used to\n    // select byte enables of slave registers while writing.\n    // These registers are cleared when reset (active low) is applied.\n    // Slave register write enable is asserted when valid address and data are available\n    // and the slave is ready to accept the write address and write data.\n    assign slv_reg_wren = axi_wready && port.S_AXI_WVALID && axi_awready && port.S_AXI_AWVALID;\n\n\n    // Implement write response logic generation\n    // The write response and response valid signals are asserted by the slave \n    // when axi_wready, port.S_AXI_WVALID, axi_wready and port.S_AXI_WVALID are asserted.  \n    // This marks the acceptance of address and indicates the status of \n    // write transaction.\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_bvalid  <= 0;\n          axi_bresp   <= 2'b0;\n        end \n      else\n        begin    \n          if (axi_awready && port.S_AXI_AWVALID && ~axi_bvalid && axi_wready && port.S_AXI_WVALID)\n            begin\n              // indicates a valid write response is available\n              axi_bvalid <= 1'b1;\n              axi_bresp  <= 2'b0; // 'OKAY' response \n            end                   // work error responses in future\n          else\n            begin\n              if (port.S_AXI_BREADY && axi_bvalid) \n                //check if bready is asserted while bvalid is high) \n                //(there is a possibility that bready is always asserted high)   \n                begin\n                  axi_bvalid <= 1'b0; \n                end  \n            end\n        end\n    end   \n\n    // Implement axi_arready generation\n    // axi_arready is asserted for one port.S_AXI_ACLK clock cycle when\n    // port.S_AXI_ARVALID is asserted. axi_awready is \n    // de-asserted when reset (active low) is asserted. \n    // The read address is also latched when port.S_AXI_ARVALID is \n    // asserted. axi_araddr is reset to zero on reset assertion.\n\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_arready <= 1'b0;\n          axi_araddr  <= 32'b0;\n        end \n      else\n        begin    \n          if (~axi_arready && port.S_AXI_ARVALID)\n            begin\n              // indicates that the slave has acceped the valid read address\n              axi_arready <= 1'b1;\n              // Read address latching\n              axi_araddr  <= port.S_AXI_ARADDR;\n            end\n          else\n            begin\n              axi_arready <= 1'b0;\n            end\n        end \n    end       \n\n    // Implement axi_arvalid generation\n    // axi_rvalid is asserted for one port.S_AXI_ACLK clock cycle when both \n    // port.S_AXI_ARVALID and axi_arready are asserted. The slave registers \n    // data are available on the axi_rdata bus at this instance. The \n    // assertion of axi_rvalid marks the validity of read data on the \n    // bus and axi_rresp indicates the status of read transaction.axi_rvalid \n    // is deasserted on reset (active low). axi_rresp and axi_rdata are \n    // cleared to zero on reset (active low). \n\n    \n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_rvalid  <= 0;\n          axi_rresp   <= 0;\n          axi_reading <= 0;\n        end \n      else\n        begin    \n          if (axi_arready && port.S_AXI_ARVALID && ~axi_rvalid && -axi_reading)\n            begin\n              // Valid read data is available at the read data bus\n              //axi_rvalid <= 1'b1;\n              axi_rresp   <= 2'b0; // 'OKAY' response\n              axi_reading <= 1'b1;\n            end   \n          else if (axi_reading)\n              begin\n              axi_rvalid  <= 1'b1;\n              axi_reading <= 1'b0;\n            end\n          else if (axi_rvalid && port.S_AXI_RREADY)\n            begin\n              // Read data is accepted by the master\n              axi_rvalid <= 1'b0;\n            end                \n        end\n    end    \n\n    // Implement memory mapped register select and read logic generation\n    // Slave register read enable is asserted when valid address is available\n    // and the slave is ready to accept the read address.\n    assign slv_reg_rden = axi_reading;\n\n    // Output register or memory read data\n    always_ff @( posedge port.S_AXI_ACLK )\n    begin\n      if ( port.S_AXI_ARESETN == 1'b0 )\n        begin\n          axi_rdata  <= 0;\n        end \n      else\n        begin    \n          // When there is a valid read address (port.S_AXI_ARVALID) with \n          // acceptance of read address by the slave (axi_arready), \n          // output the read dada \n          if (slv_reg_rden)\n            begin\n              axi_rdata <= reg_data_out;     // register read data\n            end   \n        end\n    end    \n\n    BlockDualPortRAM #( \n        .INDEX_BIT_SIZE(PS_PL_MEMORY_SIZE), \n        .ENTRY_BIT_SIZE(DATA_WIDTH)\n    ) ram ( \n        port.S_AXI_ACLK,\n        slv_reg_wren,\n        axi_awaddr[PS_PL_MEMORY_ADDR_BIT_SIZE-1:PS_PL_MEMORY_ADDR_LSB],\n        port.S_AXI_WDATA,\n        axi_araddr[PS_PL_MEMORY_ADDR_BIT_SIZE-1:PS_PL_MEMORY_ADDR_LSB],\n        reg_data_out\n    );\n\nendmodule : Axi4LiteDualPortBlockRAM\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n\n// `timescale 1 ns / 1 ps\n\n`include \"BasicMacros.sv\"\n`include \"SysDeps/XilinxMacros.vh\"\n\nimport BasicTypes::*;\nimport MemoryTypes::*;\nimport CacheSystemTypes::*;\n\nmodule Axi4Memory\n(\nAxi4MemoryIF.Axi4 port,\ninput\n    AddrPath memAccessAddr,\n    MemoryEntryDataPath memAccessWriteData,\n    logic memAccessRE,\n    logic memAccessWE,\noutput\n    logic memAccessReadBusy,    // \u30e1\u30e2\u30ea\u30ea\u30fc\u30c9\u30a2\u30af\u30bb\u30b9\u8981\u6c42\u3092\u53d7\u3051\u4ed8\u3051\u3089\u308c\u306a\u3044\n    logic memAccessWriteBusy,    // \u30e1\u30e2\u30ea\u30e9\u30a4\u30c8\u30a2\u30af\u30bb\u30b9\u8981\u6c42\u3092\u53d7\u3051\u4ed8\u3051\u3089\u308c\u306a\u3044\n    MemAccessSerial nextMemReadSerial, // RSD\u306e\u6b21\u306e\u8aad\u307f\u51fa\u3057\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb(id)\n    MemWriteSerial nextMemWriteSerial, // RSD\u306e\u6b21\u306e\u66f8\u304d\u8fbc\u307f\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb(id)\n    logic memReadDataReady, // TRUE\u306a\u3089\u3001\u30e1\u30e2\u30ea\u306e\u8aad\u51fa\u3057\u30c7\u30fc\u30bf\u3042\u308a\n    MemoryEntryDataPath memReadData, // \u30e1\u30e2\u30ea\u306e\u8aad\u51fa\u3057\u30c7\u30fc\u30bf\n    MemAccessSerial memReadSerial, // \u30e1\u30e2\u30ea\u306e\u8aad\u307f\u51fa\u3057\u30c7\u30fc\u30bf\u306e\u30b7\u30ea\u30a2\u30eb\n    MemAccessResponse memAccessResponse // \u30e1\u30e2\u30ea\u66f8\u304d\u8fbc\u307f\u5b8c\u4e86\u901a\u77e5\n);\n\n    // RD/WR addr must be buffered for the correct operation.\n    logic [`MEMORY_AXI4_ADDR_BIT_SIZE-1:0] next_addr;\n\n    always_ff @(posedge port.M_AXI_ACLK) begin\n        if (port.M_AXI_ARESETN == 0) begin\n            next_addr <= '0;\n        end\n        else begin\n            next_addr <= memAccessAddr[`MEMORY_AXI4_ADDR_BIT_SIZE-1:0];\n        end\n    end\n\n    // function called clogb2 that returns an integer which has the\n    //value of the ceiling of the log base 2\n\n      // function called clogb2 that returns an integer which has the \n      // value of the ceiling of the log base 2.                      \n      function automatic integer clogb2 (input integer bit_depth);              \n      begin                                                           \n        for(clogb2=0; bit_depth>0; clogb2=clogb2+1)                   \n          bit_depth = bit_depth >> 1;                                 \n        end                                                           \n      endfunction                                                     \n\n    // The burst length of AXI4\n    // RSD\u306e\u30e1\u30e2\u30ea\u30a2\u30af\u30bb\u30b9\u5358\u4f4d\u306f\u30ad\u30e3\u30c3\u30b7\u30e5\u30e9\u30a4\u30f3\u5e45\u5358\u4f4d\u306a\u306e\u3067\uff0c\u305d\u308c\u3092AXI4\u30d0\u30b9\u306e\u30c7\u30fc\u30bf\u5e45\u3067\u5272\u3063\u305f\u6570\n    localparam MEMORY_AXI4_BURST_LEN = MEMORY_ENTRY_BIT_NUM/`MEMORY_AXI4_DATA_BIT_NUM;\n\n    // C_TRANSACTIONS_NUM is the width of the index counter for \n    // number of write or read transaction.\n     localparam integer C_TRANSACTIONS_NUM = clogb2(MEMORY_AXI4_BURST_LEN-1);\n\n    // Burst length for transactions, in `MEMORY_AXI4_DATA_BIT_NUMs.\n    // Non-2^n lengths will eventually cause bursts across 4K address boundaries.\n     localparam integer C_MASTER_LENGTH    = 12;\n    // total number of burst transfers is master length divided by burst length and burst size\n     localparam integer C_NO_BURSTS_REQ = C_MASTER_LENGTH-clogb2((MEMORY_AXI4_BURST_LEN * `MEMORY_AXI4_DATA_BIT_NUM /8)-1);\n    // Example State machine to initialize counter, initialize write transactions, \n    // initialize read transactions and comparison of read data with the \n    // written data words.\n    parameter [1:0] IDLE = 2'b00, // This state initiates AXI4Lite transaction \n            // after the state machine changes state to INIT_WRITE \n            // when there is 0 to 1 transition on INIT_AXI_TXN\n        INIT_WRITE   = 2'b01, // This state initializes write transaction,\n            // once writes are done, the state machine \n            // changes state to INIT_READ \n        INIT_READ = 2'b10, // This state initializes read transaction\n            // once reads are done, the state machine \n            // changes state to INIT_COMPARE \n        INIT_COMPARE = 2'b11; // This state issues the status of comparison \n            // of the written data with the read data    \n\n     reg [1:0] mst_exec_state;\n\n    // AXI4LITE signals\n    //AXI4 internal temp signals\n    // reg [`MEMORY_AXI4_ADDR_BIT_SIZE-1 : 0]     axi_awaddr;\n    logic [`MEMORY_AXI4_ADDR_BIT_SIZE-1 : 0]     axi_awaddr;\n    // reg      axi_awvalid;\n    logic axi_awvalid;\n    //reg [`MEMORY_AXI4_DATA_BIT_NUM-1 : 0]     axi_wdata;\n    logic [`MEMORY_AXI4_DATA_BIT_NUM-1 : 0]     axi_wdata;\n    reg      axi_wlast;\n    reg      axi_wvalid;\n    reg      axi_bready;\n    //reg [`MEMORY_AXI4_ADDR_BIT_SIZE-1 : 0]     axi_araddr;\n    logic [`MEMORY_AXI4_ADDR_BIT_SIZE-1 : 0]     axi_araddr;\n    reg      axi_arvalid;\n    reg      axi_rready;\n    //write beat count in a burst\n    reg [C_TRANSACTIONS_NUM : 0]     write_index;\n    //read beat count in a burst\n    reg [C_TRANSACTIONS_NUM : 0]     read_index;\n    //size of MEMORY_AXI4_BURST_LEN length burst in bytes\n    wire [C_TRANSACTIONS_NUM+2 : 0]     burst_size_bytes;\n    //The burst counters are used to track the number of burst transfers of MEMORY_AXI4_BURST_LEN burst length needed to transfer 2^C_MASTER_LENGTH bytes of data.\n    reg [C_NO_BURSTS_REQ : 0]     write_burst_counter;\n    reg [C_NO_BURSTS_REQ : 0]     read_burst_counter;\n    reg      start_single_burst_write;\n    reg      start_single_burst_read;\n    reg      writes_done;\n    reg      reads_done;\n    reg      error_reg;\n    // reg      compare_done;\n    reg      read_mismatch;\n    reg      burst_write_active;\n    reg      burst_read_active;\n    reg [`MEMORY_AXI4_DATA_BIT_NUM-1 : 0]     expected_rdata;\n    //Interface response error flags\n    wire      write_resp_error;\n    wire      read_resp_error;\n    wire      wnext;\n    wire      rnext;\n    reg      init_txn_ff;\n    reg      init_txn_ff2;\n    reg      init_txn_edge;\n    wire      init_txn_pulse;\n\n//\n// --- memoryReadReqIDFreeList\n//\n    // Read\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u305f\u3081\u306e\u5b9a\u7fa9\n    // 1\u306a\u3089\u4f7f\u7528\u6e08\u307freadReqID\u3092push\u3059\u308b\n    logic pushFreeReadReqID;\n    logic [`MEMORY_AXI4_READ_ID_WIDTH-1: 0] pushedFreeReadReqID;\n    // 1\u306a\u3089\u30d5\u30ea\u30fc\u306ereadReqID\u3092pop\u3059\u308b\n    logic popFreeReadReqID;\n    logic [`MEMORY_AXI4_READ_ID_WIDTH-1: 0] popedFreeReadReqID;\n    // 1\u306a\u3089memoryReadReqIDFreeList\u304cfull\n    logic readReqIDFreeListFull;\n    // 1\u306a\u3089memoryReadReqIDFreeList\u304c\u7a7a\n    logic readReqIDFreeListEmpty;\n\n    // memoryReadReqQueue\u306bpush\u3059\u308bmemoryReadReq\n    MemoryReadReq pushedMemoryReadReq;\n    // 1\u306a\u3089memoryReadReqQueue\u306bpush\u3059\u308b\n    logic pushMemoryReadReq;\n    // 1\u306a\u3089memoryReadReqQueue\u304b\u3089pop\u3059\u308b\n    logic popMemoryReadReq;\n    // 1\u306a\u3089memoryReadReqQueue\u304cfull\n    logic memoryReadReqQueueFull;\n    // 1\u306a\u3089memoryReadReqQueue\u304c\u7a7a\n    logic memoryReadReqQueueEmpty;\n    // memoryReadReqQueue\u306e\u5148\u982d\u306b\u3042\u308bmemoryReadReq\n    MemoryReadReq popedMemoryReadReq;\n\n    //\n    MemoryEntryDataPath nextMemoryReadData;\n    logic memoryReadDataTableWE;\n    logic [`MEMORY_AXI4_READ_ID_WIDTH-1: 0] memoryReadDataID;\n    MemoryEntryDataPath memoryReadData;\n    \n\n//\n// --- memoryReadReqIDFreeList\n//\n    FreeList #(\n        .SIZE(`MEMORY_AXI4_READ_ID_NUM),\n        .ENTRY_WIDTH(`MEMORY_AXI4_READ_ID_WIDTH)\n    ) memoryReadReqIDFreeList ( \n        .clk(port.M_AXI_ACLK),\n        .rst(~port.M_AXI_ARESETN),\n        .push(pushFreeReadReqID),\n        .pop(popFreeReadReqID),\n        .pushedData(pushedFreeReadReqID),\n        .full(readReqIDFreeListFull),\n        .empty(readReqIDFreeListEmpty),\n        .headData(popedFreeReadReqID)\n    );\n\n    // \u5229\u7528\u53ef\u80fd\u306areadReqID\u304c\u306a\u3051\u308c\u3070\u65b0\u3057\u3044\u30ea\u30fc\u30c9\u30ea\u30af\u30a8\u30b9\u30c8\u306f\u53d7\u3051\u4ed8\u3051\u3089\u308c\u306a\u3044\n    assign memAccessReadBusy = readReqIDFreeListEmpty;\n\n    // \u30e1\u30e2\u30ea\u304b\u3089\u306e\u30c7\u30fc\u30bf\u306e\u8aad\u307f\u51fa\u3057\u304c\u5b8c\u4e86\u3057\uff0ccore\u306b\u30c7\u30fc\u30bf\u3092\u9001\u3063\u305f\u3089\u5bfe\u5fdc\u3059\u308bID\u306f\u30d5\u30ea\u30fc\u306b\u306a\u308b\n    assign pushFreeReadReqID = memReadDataReady;\n    assign pushedFreeReadReqID = memoryReadDataID;\n\n    // \u5229\u7528\u53ef\u80fd\u306areadReqID\u304c\u3042\u308a\uff0c\u304b\u3064\u30ea\u30fc\u30c9\u8981\u6c42\u304ccore\u304b\u3089\u6765\u3066\u3044\u305f\u3089\u65b0\u3057\u3044readReqID\u3092pop\u3059\u308b\n    assign popFreeReadReqID = (~readReqIDFreeListEmpty && memAccessRE) ? 1'd1 : 1'd0;\n\n    // \u6b21\u306eRSD\u306e\u30ea\u30fc\u30c9\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb\u306fFreelist\u306e\u5148\u982d\u306b\u3042\u308b\n    assign nextMemReadSerial = popedFreeReadReqID;\n\n//\n// --- memoryReadReqQueue\n//\n    MemoryReadReqQueue memoryReadReqQueue ( \n        .clk(port.M_AXI_ACLK),\n        .rst(~port.M_AXI_ARESETN),\n        .push(pushMemoryReadReq),\n        .pop(popMemoryReadReq),\n        .pushedData(pushedMemoryReadReq),\n        .full(memoryReadReqQueueFull),\n        .empty(memoryReadReqQueueEmpty),\n        .headData(popedMemoryReadReq)\n    );\n\n    // freelist\u304b\u3089pop\u3055\u308c\u305freadReqID\u3092memoryReadReqQueue\u306b\u5165\u529b\u3059\u308b\n    assign pushedMemoryReadReq.id = popedFreeReadReqID;\n\n    // core\u304b\u3089\u306e\u30ea\u30fc\u30c9\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u30a2\u30c9\u30ec\u30b9\u3092memoryReadReqQueue\u306b\u5165\u529b\u3059\u308b\n    assign pushedMemoryReadReq.addr = memAccessAddr[`MEMORY_AXI4_ADDR_BIT_SIZE-1:0];\n\n    // freelist\u304b\u3089readReqID\u304cpop\u3055\u308c\u305f\u5834\u5408\uff0ccore\u304b\u3089\u30ea\u30af\u30a8\u30b9\u30c8\u304c\u6765\u3066\u3044\u3066\uff0c\u304b\u3064\u53d7\u4ed8\u53ef\u80fd\u3067\u3042\u308b\u3053\u3068\u3092\u610f\u5473\u3057\u3066\u3044\u308b\u306e\u3067push\n    assign pushMemoryReadReq = popFreeReadReqID;\n\n    // \u30ea\u30af\u30a8\u30b9\u30c8\u30ad\u30e5\u30fc\u306b\u30ea\u30af\u30a8\u30b9\u30c8\u304c\u5b58\u5728\u3057\uff0c\u304b\u3064\u305d\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u30cf\u30f3\u30c9\u30b7\u30a7\u30a4\u30af\u306b\u3088\u3063\u3066\u30e1\u30e2\u30ea\u306b\u4f1d\u9054\u3067\u304d\u305f\u5834\u5408\u305d\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u3092pop\u3059\u308b\n    assign popMemoryReadReq = (~memoryReadReqQueueEmpty && port.M_AXI_ARREADY && axi_arvalid) ? 1'd1 : 1'd0;\n\n//\n// --- memoryReadDataTable\n//\n    DistributedDualPortRAM #( \n        .ENTRY_NUM(`MEMORY_AXI4_READ_ID_NUM), \n        .ENTRY_BIT_SIZE(MEMORY_ENTRY_BIT_NUM)\n    ) memoryReadDataTable ( \n        .clk(port.M_AXI_ACLK),\n        .we(memoryReadDataTableWE),\n        .wa(memoryReadDataID),\n        .wv(nextMemoryReadData),\n        .ra(memoryReadDataID),\n        .rv(memoryReadData)\n    );\n\n    // \u30e1\u30e2\u30ea\u304b\u3089\u30c7\u30fc\u30bf\u3092\u53d7\u3051\u53d6\u3063\u305f\u3089\u30c6\u30fc\u30d6\u30eb\u5185\u306e\u30c7\u30fc\u30bf\u3092\u66f4\u65b0\n    assign memoryReadDataTableWE = (port.M_AXI_RVALID && axi_rready) ? 1'd1: 1'd0;\n    // memoryReadDataTable\u306e\u30a2\u30c9\u30ec\u30b9\u306f\u30e1\u30e2\u30ea\u304b\u3089\u5c4a\u3044\u305f\u30c7\u30fc\u30bf\u306eID\n    assign memoryReadDataID = port.M_AXI_RID;\n    // \u30c7\u30fc\u30bf\u304c\u30e1\u30e2\u30ea\u304b\u3089\u5c4a\u3044\u305f\u3089\uff0c\u30c6\u30fc\u30d6\u30eb\u306e\u30a8\u30f3\u30c8\u30ea\u306e\u4e0a\u4f4d\u30d3\u30c3\u30c8\u306b\u633f\u5165\u3059\u308b\n    generate \n        if (MEMORY_ENTRY_BIT_NUM == `MEMORY_AXI4_DATA_BIT_NUM) begin\n            assign nextMemoryReadData = port.M_AXI_RDATA;\n        end\n        else begin\n            assign nextMemoryReadData = {port.M_AXI_RDATA, memoryReadData[MEMORY_ENTRY_BIT_NUM-1: `MEMORY_AXI4_DATA_BIT_NUM]};\n        end\n    endgenerate\n\n    // \u30d0\u30fc\u30b9\u30c8\u8ee2\u9001\u304c\u7d42\u308f\u3063\u305f\u3089\u305d\u306e\u30a8\u30f3\u30c8\u30ea\u306f\u30c7\u30fc\u30bf\u306e\u53d7\u4fe1\u304c\u5b8c\u4e86\u3057\u305f\u306e\u3067core\u306b\u30c7\u30fc\u30bf\u3092\u9001\u308b\uff0e\n    assign memReadDataReady = (port.M_AXI_RVALID && axi_rready && port.M_AXI_RLAST) ? 1'd1 : 1'd0;\n    assign memReadData = nextMemoryReadData;\n    assign memReadSerial = memoryReadDataID;\n  \n\n//\n// --- definition for AXI4 write\n//\n    // memoryReadReqQueue\u306bpush\u3059\u308bmemoryReadReq\n    MemoryEntryDataPath pushedMemoryWriteData;\n    // 1\u306a\u3089memoryReadReqQueue\u306bpush\u3059\u308b\n    logic pushMemoryWriteData;\n    // 1\u306a\u3089memoryReadReqQueue\u304b\u3089pop\u3059\u308b\n    logic popMemoryWriteData;\n    // 1\u306a\u3089memoryReadReqQueue\u304cfull\n    logic memoryWriteDataQueueFull;\n    // 1\u306a\u3089memoryReadReqQueue\u304c\u7a7a\n    logic memoryWriteDataQueueEmpty;\n    // memoryReadReqQueue\u306e\u5148\u982d\u306b\u3042\u308bmemoryReadReq\n    MemoryEntryDataPath popedMemoryWriteData;\n    // memoryReadReqQueue\u306e\u30dd\u30a4\u30f3\u30bf\n    MemWriteSerial memoryWriteDataQueueHeadPtr;\n    MemWriteSerial memoryWriteDataQueueTailPtr;\n    // \u30b7\u30d5\u30c8\u3059\u308b\u305f\u3081\u306e\u30c7\u30fc\u30bf\u30d0\u30c3\u30d5\u30a1\n    MemoryEntryDataPath memoryWriteData;\n\n//\n// --- memoryReadReqQueue\n//\n    MemoryWriteDataQueue memoryWriteDataQueue ( \n        .clk(port.M_AXI_ACLK),\n        .rst(~port.M_AXI_ARESETN),\n        .push(pushMemoryWriteData),\n        .pop(popMemoryWriteData),\n        .pushedData(pushedMemoryWriteData),\n        .full(memoryWriteDataQueueFull),\n        .empty(memoryWriteDataQueueEmpty),\n        .headData(popedMemoryWriteData),\n        .headPtr(memoryWriteDataQueueHeadPtr),\n        .tailPtr(memoryWriteDataQueueTailPtr)\n    );\n\n    // \u30e1\u30e2\u30ea\u304c\u30e9\u30a4\u30c8\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u53d7\u3051\u5165\u308c\u53ef\u80fd\u3067\uff0c\u304b\u3064core\u304c\u30e9\u30a4\u30c8\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u9001\u4fe1\u3057\u305f\u3089\u30ad\u30e5\u30fc\u306b\u30c7\u30fc\u30bf\u3092\u5165\u308c\u308b\n    assign pushMemoryWriteData = (memAccessWE && port.M_AXI_AWREADY && ~memoryWriteDataQueueFull) ? 1'd1 : 1'd0;\n\n    // core\u304b\u3089\u306e\u30c7\u30fc\u30bf\u3092memoryWriteDataQueue\u306bpush\u3059\u308b\n    assign pushedMemoryWriteData = memAccessWriteData;\n\n    // head\u30c7\u30fc\u30bf\u306e\u66f8\u304d\u8fbc\u307f\u304c\u5b8c\u4e86\u3057\u305f\u3089pop\u3059\u308b\n    assign popMemoryWriteData = (port.M_AXI_BVALID && axi_bready) ? 1'd1 : 1'd0;\n                              //(port.M_AXI_BVALID && axi_bready && (memoryWriteDataQueueHeadPtr == port.M_AXI_BID)) ? 1'd1 : 1'd0;\n\n    // \u30e1\u30e2\u30ea\u304c\u30e9\u30a4\u30c8\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u53d7\u3051\u5165\u308c\u4e0d\u53ef\u80fd\u304b\uff0cmemoryWriteDataQueue\u304c\u30d5\u30eb\u306a\u3089\u65b0\u3057\u3044\u30ea\u30af\u30a8\u30b9\u30c8\u306f\u53d7\u4ed8\u4e0d\u53ef\u80fd\n    assign memAccessWriteBusy = (~port.M_AXI_AWREADY || memoryWriteDataQueueFull) ? 1'd1 : 1'd0;\n\n    // AXI\u30d0\u30b9\u304b\u3089\u66f8\u304d\u8fbc\u307f\u5b8c\u4e86\u5fdc\u7b54\u304c\u304d\u305f\u3089\uff0cRSD\u306b\u901a\u77e5\u3059\u308b\n    assign memAccessResponse.valid = (port.M_AXI_BVALID && axi_bready) ? 1'd1 : 1'd0;\n    assign memAccessResponse.serial = port.M_AXI_BID;\n\n    // RSD\u304b\u3089\u306e\u30e9\u30a4\u30c8\u8981\u6c42\u3092\u5165\u308c\u308bmemoryWriteDataQueue\u306e\u30a8\u30f3\u30c8\u30ea\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u304c\u305d\u306e\u8981\u6c42\u306e\u30b7\u30ea\u30a2\u30eb\u306b\u306a\u308b\uff0e\n    assign nextMemWriteSerial = memoryWriteDataQueueTailPtr;\n\n//\n// --- axi4 signals\n//\n    // \u30ea\u30fc\u30c9\u8981\u6c42\u30a2\u30c9\u30ec\u30b9\u306fmemoryReadReqQueue\u306e\u5148\u982d\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u306b\u5165\u3063\u3066\u3044\u308b\uff0e\n    assign axi_araddr = popedMemoryReadReq.addr;\n\n    // core\u304b\u3089\u306e\u30e9\u30a4\u30c8\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u30d0\u30b9\u306b\u51fa\u529b\u3059\u308b\n    assign axi_awvalid = memAccessWE;\n\n    // core\u304b\u3089\u306e\u30e9\u30a4\u30c8\u30ea\u30af\u30a8\u30b9\u30c8\u3068\u540c\u6642\u306b\u304f\u308b\u30a2\u30c9\u30ec\u30b9\u3092\u30d0\u30b9\u306b\u51fa\u529b\u3059\u308b\n    assign axi_awaddr = memAccessAddr[`MEMORY_AXI4_ADDR_BIT_SIZE-1:0];\n\n    // I/O Connections assignments\n\n    //I/O Connections. Write Address (AW)\n    // \u5bfe\u5fdc\u3059\u308b\u30c7\u30fc\u30bf\u3092memoryWriteDataQueue\u306bpush\u3059\u308b\u30dd\u30a4\u30f3\u30bf\u304cID\u3068\u306a\u308b\n    assign port.M_AXI_AWID    = memoryWriteDataQueueTailPtr;//'b0;\n    //The AXI address is a concatenation of the target base address + active offset range\n    assign port.M_AXI_AWADDR    = `MEMORY_AXI4_BASE_ADDR + axi_awaddr;\n    //Burst LENgth is number of transaction beats, minus 1\n    assign port.M_AXI_AWLEN    = MEMORY_AXI4_BURST_LEN - 1;\n    //Size should be `MEMORY_AXI4_DATA_BIT_NUM, in 2^SIZE bytes, otherwise narrow bursts are used\n    assign port.M_AXI_AWSIZE    = clogb2((`MEMORY_AXI4_DATA_BIT_NUM/8)-1);\n    //INCR burst type is usually used, except for keyhole bursts\n    // Burst type (AWBURST) is INCR (2'b01). \n    assign port.M_AXI_AWBURST    = 2'b01;\n    // AXI4 does NOT support locked transactions.\n    assign port.M_AXI_AWLOCK    = 1'b0;\n    //Update value to 4'b0011 if coherent accesses to be used via the Zynq ACP port. Not Allocated, Modifiable, not Bufferable. Not Bufferable since this example is meant to test memory, not intermediate cache. \n    assign port.M_AXI_AWCACHE    = 4'b0010;\n    assign port.M_AXI_AWPROT    = 3'h0;\n    assign port.M_AXI_AWQOS    = 4'h0;\n    // AWUSER is ignored with HP0~3. It should be set appropriately with ACP ports.\n    assign port.M_AXI_AWUSER    = 'b1;\n    assign port.M_AXI_AWVALID    = axi_awvalid;\n    //Write Data(W)\n    assign port.M_AXI_WDATA    = axi_wdata;\n    //All bursts are complete and aligned in this example\n    assign port.M_AXI_WSTRB    = {(`MEMORY_AXI4_DATA_BIT_NUM/8){1'b1}};\n    assign port.M_AXI_WLAST    = axi_wlast;\n    // WUSER is ignored.\n    assign port.M_AXI_WUSER    = 'b0;\n    assign port.M_AXI_WVALID    = axi_wvalid;\n    //Write Response (B)\n    assign port.M_AXI_BREADY    = axi_bready;\n    //Read Address (AR)\n    // memoryReadReqQueue\u306e\u5148\u982d\u306b\u767a\u884c\u3059\u308b\u30ea\u30fc\u30c9\u30ea\u30af\u30a8\u30b9\u30c8\u306eid\u304c\u5165\u3063\u3066\u3044\u308b\n    assign port.M_AXI_ARID    = popedMemoryReadReq.id;//'b0;\n    assign port.M_AXI_ARADDR    = `MEMORY_AXI4_BASE_ADDR + axi_araddr;\n    //Burst LENgth is number of transaction beats, minus 1\n    assign port.M_AXI_ARLEN    = MEMORY_AXI4_BURST_LEN - 1;\n    //Size should be `MEMORY_AXI4_DATA_BIT_NUM, in 2^n bytes, otherwise narrow bursts are used\n    assign port.M_AXI_ARSIZE    = clogb2((`MEMORY_AXI4_DATA_BIT_NUM/8)-1);\n    //INCR burst type is usually used, except for keyhole bursts\n    // Burst type (ARBURST) is INCR (2'b01). \n    assign port.M_AXI_ARBURST    = 2'b01;\n    // AXI4 does NOT support locked transactions.\n    assign port.M_AXI_ARLOCK    = 1'b0;\n    //Update value to 4'b0011 if coherent accesses to be used via the Zynq ACP port. Not Allocated, Modifiable, not Bufferable. Not Bufferable since this example is meant to test memory, not intermediate cache. \n    assign port.M_AXI_ARCACHE    = 4'b0010;\n    assign port.M_AXI_ARPROT    = 3'h0;\n    assign port.M_AXI_ARQOS    = 4'h0;\n    // ARUSER is ignored with HP0~3. It should be set appropriately with ACP ports.\n    assign port.M_AXI_ARUSER    = 'b1;\n    assign port.M_AXI_ARVALID    = axi_arvalid;\n    //Read and Read Response (R)\n    assign port.M_AXI_RREADY    = axi_rready;\n    //Example design I/O\n    // assign TXN_DONE    = compare_done;\n    //Burst size in bytes\n    assign burst_size_bytes    = MEMORY_AXI4_BURST_LEN * `MEMORY_AXI4_DATA_BIT_NUM/8;\n    // assign init_txn_pulse    = (!init_txn_ff2) && init_txn_ff;\n\n\n    // //Generate a pulse to initiate AXI transaction.\n    // always_ff @(posedge port.M_AXI_ACLK)                                              \n    //   begin                                                                        \n    //     // Initiates AXI transaction delay    \n    //     if (port.M_AXI_ARESETN == 0 )                                                   \n    //       begin                                                                    \n    //         init_txn_ff <= 1'b0;                                                   \n    //         init_txn_ff2 <= 1'b0;                                                   \n    //       end                                                                               \n    //     else                                                                       \n    //       begin  \n    //         init_txn_ff <= INIT_AXI_TXN;\n    //         init_txn_ff2 <= init_txn_ff;                                                                 \n    //       end                                                                      \n    //   end     \n\n\n    //--------------------\n    //Write Address Channel\n    //--------------------\n\n    // The purpose of the write address channel is to request the address and \n    // command information for the entire transaction.  It is a single beat\n    // of information.\n\n    // The AXI4 Write address channel in this example will continue to initiate\n    // write commands as fast as it is allowed by the slave/interconnect.\n    // The address will be incremented on each accepted address transaction,\n    // by burst_size_byte to point to the next address. \n\n      // always_ff @(posedge port.M_AXI_ACLK)                                   \n      // begin                                                                \n                                                                           \n      //   if (port.M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 )                                           \n      //     begin                                                            \n      //       axi_awvalid <= 1'b0;                                           \n      //     end                                                              \n      //   // If previously not valid , start next transaction                \n      //   else if (~axi_awvalid && start_single_burst_write)                 \n      //     begin                                                            \n      //       axi_awvalid <= 1'b1;                                           \n      //     end                                                              \n      //   /* Once asserted, VALIDs cannot be deasserted, so axi_awvalid      \n      //   must wait until transaction is accepted */                         \n      //   else if (port.M_AXI_AWREADY && axi_awvalid)                             \n      //     begin                                                            \n      //       axi_awvalid <= 1'b0;                                           \n      //     end                                                              \n      //   else                                                               \n      //     axi_awvalid <= axi_awvalid;                                      \n      //   end                                                                \n                                                                           \n                                                                           \n    // Next address after AWREADY indicates previous address acceptance    \n      // always_ff @(posedge port.M_AXI_ACLK)                                         \n      // begin                                                                \n      //   if (port.M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1)                                            \n      //     begin                                                            \n      //       axi_awaddr <= 'b0;                                             \n      //     end                                                              \n      //   else if (port.M_AXI_AWREADY && axi_awvalid)                             \n      //     begin                                                            \n      //       axi_awaddr <= next_addr;                   \n      //     end                                                              \n      //   else                                                               \n      //     axi_awaddr <= axi_awaddr;           "}
{"text": "                             \n      //   end                                                                \n\n\n    //--------------------\n    //Write Data Channel\n    //--------------------\n\n    //The write data will continually try to push write data across the interface.\n\n    //The amount of data accepted will depend on the AXI slave and the AXI\n    //Interconnect settings, such as if there are FIFOs enabled in interconnect.\n\n    //Note that there is no explicit timing relationship to the write address channel.\n    //The write channel has its own throttling flag, separate from the AW channel.\n\n    //Synchronization between the channels must be determined by the user.\n\n    //The simpliest but lowest performance would be to only issue one address write\n    //and write data burst at a time.\n\n    //In this example they are kept in sync by using the same address increment\n    //and burst sizes. Then the AW and W channels have their transactions measured\n    //with threshold counters as part of the user logic, to make sure neither \n    //channel gets too far ahead of each other.\n\n    //Forward movement occurs when the write channel is valid and ready\n\n      assign wnext = port.M_AXI_WREADY & axi_wvalid;                                   \n                                                                                        \n    // WVALID logic, similar to the axi_awvalid always block above                      \n      always_ff @(posedge port.M_AXI_ACLK)                                                      \n      begin                                                                             \n        if (port.M_AXI_ARESETN == 0 )                                                        \n          begin                                                                         \n            axi_wvalid <= 1'b0;                                                         \n          end                                                                           \n        // If previously not valid, start next transaction                              \n        else if (~axi_wvalid && start_single_burst_write)                               \n          begin                                                                         \n            axi_wvalid <= 1'b1;                                                         \n          end                                                                           \n        /* If WREADY and too many writes, throttle WVALID                               \n        Once asserted, VALIDs cannot be deasserted, so WVALID                           \n        must wait until burst is complete with WLAST */                                 \n        else if (wnext && axi_wlast)                                                    \n          axi_wvalid <= 1'b0;                                                           \n        else                                                                            \n          axi_wvalid <= axi_wvalid;                                                     \n      end                                                                               \n                                                                                        \n                                                                                        \n    //WLAST generation on the MSB of a counter underflow                                \n    // WVALID logic, similar to the axi_awvalid always block above                      \n      always_ff @(posedge port.M_AXI_ACLK)                                                      \n      begin                                                                             \n        if (port.M_AXI_ARESETN == 0 )                                                        \n          begin                                                                         \n            axi_wlast <= 1'b0;                                                          \n          end                                                                           \n        // axi_wlast is asserted when the write index                                   \n        // count reaches the penultimate count to synchronize                           \n        // with the last write data when write_index is b1111                           \n        // else if (&(write_index[C_TRANSACTIONS_NUM-1:1])&& ~write_index[0] && wnext)  \n        else if (((write_index == MEMORY_AXI4_BURST_LEN-2 && MEMORY_AXI4_BURST_LEN >= 2) && wnext) || (MEMORY_AXI4_BURST_LEN == 1 ))\n          begin                                                                         \n            axi_wlast <= 1'b1;                                                          \n          end                                                                           \n        // Deassrt axi_wlast when the last write data has been                          \n        // accepted by the slave with a valid response                                  \n        else if (wnext)                                                                 \n          axi_wlast <= 1'b0;                                                            \n        else if (axi_wlast && MEMORY_AXI4_BURST_LEN == 1)                                   \n          axi_wlast <= 1'b0;                                                            \n        else                                                                            \n          axi_wlast <= axi_wlast;                                                       \n      end                                                                               \n                                                                                        \n                                                                                        \n    /* Burst length counter. Uses extra counter register bit to indicate terminal       \n     count to reduce decode logic */                                                    \n      always_ff @(posedge port.M_AXI_ACLK)                                                      \n      begin                                                                             \n        if (port.M_AXI_ARESETN == 0 || start_single_burst_write == 1'b1)    \n          begin                                                                         \n            write_index <= 0;                                                           \n          end                                                                           \n        else if (wnext && (write_index != MEMORY_AXI4_BURST_LEN-1))                         \n          begin                                                                         \n            write_index <= write_index + 1;                                             \n          end                                                                           \n        else                                                                            \n          write_index <= write_index;                                                   \n      end                                                                               \n\n    generate \n        // \u30d0\u30fc\u30b9\u30c8\u8ee2\u9001\u306e\u305f\u3081\u66f8\u304d\u8fbc\u307f\u30c7\u30fc\u30bf\u30921\u8ee2\u9001\u3054\u3068\u306b\u30b7\u30d5\u30c8\u3057\u3066\u3044\u304f\n        if (MEMORY_ENTRY_BIT_NUM == `MEMORY_AXI4_DATA_BIT_NUM) begin\n            always_ff @(posedge port.M_AXI_ACLK)                                                      \n            begin                                                                             \n                if (port.M_AXI_ARESETN == 0)                                                         \n                memoryWriteData <= '0;                                                                                                                \n                else if (start_single_burst_write)                                                                            \n                // \u30d0\u30fc\u30b9\u30c8\u8ee2\u9001\u958b\u59cb\u6642\u306bmemoryWriteDataQueue\u306e\u5148\u982d\u306e\u30c7\u30fc\u30bf\u3092\u30b3\u30d4\u30fc\u3059\u308b\n                memoryWriteData <= popedMemoryWriteData;\n                else if (wnext)\n                // 1\u30ef\u30fc\u30c9(AXI\u30d0\u30b9\u5e45\u5358\u4f4d)\u306e\u9001\u4fe1\u304c\u7d42\u308f\u3063\u305f\u3089\u9001\u4fe1\u3059\u308b\u30c7\u30fc\u30bf\u3092\u30b7\u30d5\u30c8\u3059\u308b\n                memoryWriteData <= memoryWriteData;\n            end         \n        end\n        else begin\n            always_ff @(posedge port.M_AXI_ACLK)                                                      \n            begin                                                                             \n                if (port.M_AXI_ARESETN == 0)                                                         \n                memoryWriteData <= '0;                                                                                                                \n                else if (start_single_burst_write)                                                                            \n                // \u30d0\u30fc\u30b9\u30c8\u8ee2\u9001\u958b\u59cb\u6642\u306bmemoryWriteDataQueue\u306e\u5148\u982d\u306e\u30c7\u30fc\u30bf\u3092\u30b3\u30d4\u30fc\u3059\u308b\n                memoryWriteData <= popedMemoryWriteData;\n                else if (wnext)\n                // 1\u30ef\u30fc\u30c9(AXI\u30d0\u30b9\u5e45\u5358\u4f4d)\u306e\u9001\u4fe1\u304c\u7d42\u308f\u3063\u305f\u3089\u9001\u4fe1\u3059\u308b\u30c7\u30fc\u30bf\u3092\u30b7\u30d5\u30c8\u3059\u308b\n                memoryWriteData <= {{`MEMORY_AXI4_DATA_BIT_NUM{1'd0}}, memoryWriteData[MEMORY_ENTRY_BIT_NUM-1:`MEMORY_AXI4_DATA_BIT_NUM]};\n            end         \n        end\n    endgenerate \n    \n      assign axi_wdata = memoryWriteData[`MEMORY_AXI4_DATA_BIT_NUM-1: 0]; \n                                                                                        \n    // /* Write Data Generator                                                             \n    //  Data pattern is only a simple incrementing count from 0 for each burst  */         \n    //   always_ff @(posedge port.M_AXI_ACLK)                                                      \n    //   begin                                                                             \n    //     if (port.M_AXI_ARESETN == 0)                                                         \n    //       axi_wdata <= '0;                                                             \n    //     // //else if (wnext && axi_wlast)                                                  \n    //     // //  axi_wdata <= 'b0;                                                           \n    //     // else if (wnext)                                                                 \n    //     //   axi_wdata <= axi_wdata + 1;                                                   \n    //     else                                                                            \n    //       axi_wdata <= memoryWriteData[`MEMORY_AXI4_DATA_BIT_NUM-1: 0];                                                       \n    //   end                                                                             \n\n      always_ff @(posedge port.M_AXI_ACLK)                                                      \n      begin    \n        if (port.M_AXI_ARESETN == 0) begin\n          start_single_burst_write <= 1'b0; \n        end\n        if (~start_single_burst_write && ~burst_write_active && ~memoryWriteDataQueueEmpty)                       \n          begin                                                                                     \n            start_single_burst_write <= 1'b1;                                                       \n          end                                                                                       \n        else                                                                                        \n          begin                                                                                     \n            start_single_burst_write <= 1'b0; //Negate to generate a pulse                          \n          end   \n      end\n\n    //----------------------------\n    //Write Response (B) Channel\n    //----------------------------\n\n    //The write response channel provides feedback that the write has committed\n    //to memory. BREADY will occur when all of the data and the write address\n    //has arrived and been accepted by the slave.\n\n    //The write issuance (number of outstanding write addresses) is started by \n    //the Address Write transfer, and is completed by a BREADY/BRESP.\n\n    //While negating BREADY will eventually throttle the AWREADY signal, \n    //it is best not to throttle the whole data channel this way.\n\n    //The BRESP bit [1] is used indicate any errors from the interconnect or\n    //slave for the entire write burst. This example will capture the error \n    //into the ERROR output. \n\n      always_ff @(posedge port.M_AXI_ACLK)                                     \n      begin                                                                 \n        if (port.M_AXI_ARESETN == 0)                                            \n          begin                                                             \n            axi_bready <= 1'b0;                                             \n          end                                                               \n        // accept/acknowledge bresp with axi_bready by the master           \n        // when port.M_AXI_BVALID is asserted by slave                           \n        else if (port.M_AXI_BVALID && ~axi_bready)                               \n          begin                                                             \n            axi_bready <= 1'b1;                                             \n          end                                                               \n        // deassert after one clock cycle                                   \n        else if (axi_bready)                                                \n          begin                                                             \n            axi_bready <= 1'b0;                                             \n          end                                                               \n        // retain the previous value                                        \n        else                                                                \n          axi_bready <= axi_bready;                                         \n      end                                                                   \n                                                                            \n                                                                            \n    //Flag any write response errors                                        \n      assign write_resp_error = axi_bready & port.M_AXI_BVALID & port.M_AXI_BRESP[1]; \n\n\n    //----------------------------\n    //Read Address Channel\n    //----------------------------\n\n    //The Read Address Channel (AW) provides a similar function to the\n    //Write Address channel- to provide the tranfer qualifiers for the burst.\n\n    //In this example, the read address increments in the same\n    //manner as the write address channel.\n\n      always_ff @(posedge port.M_AXI_ACLK)                                 \n      begin                                                              \n                                                                         \n        if (port.M_AXI_ARESETN == 0)                                         \n          begin                                                          \n            axi_arvalid <= 1'b0;                                         \n          end                                                            \n        // If previously not valid , start next transaction \n        // memoryReadReqQueue\u304c\u7a7a\u3067\u306a\u3044\u5834\u5408\uff0c\u9001\u4fe1\u3059\u3079\u304d\u30ea\u30af\u30a8\u30b9\u30c8\u304c\u3042\u308b\u306e\u3067\u9001\u4fe1\u3059\u308b\n        else if (~axi_arvalid && ~memoryReadReqQueueEmpty)                \n          begin                                                          \n            axi_arvalid <= 1'b1;                                         \n          end                                                            \n        else if (port.M_AXI_ARREADY && axi_arvalid)                           \n          begin                                                          \n            axi_arvalid <= 1'b0;                                         \n          end                                                            \n        else                                                             \n          axi_arvalid <= axi_arvalid;                                    \n      end                                                                \n                                                   \n\n    // // Next address after ARREADY indicates previous address acceptance  \n    //   always_ff @(posedge port.M_AXI_ACLK)                                       \n    //   begin                                                              \n    //     if (port.M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1)                                          \n    //       begin                                                          \n    //         axi_araddr <= 'b0;                                           \n    //       end                                                            \n    //     else if (port.M_AXI_ARREADY && axi_arvalid)                           \n    //       begin                                                          \n    //         axi_araddr <= next_addr;                 \n    //       end                                                            \n    //     else                                                             \n    //       axi_araddr <= axi_araddr;                                      \n    //   end                                                                \n\n\n    //--------------------------------\n    //Read Data (and Response) Channel\n    //--------------------------------\n\n     // Forward movement occurs when the channel is valid and ready   \n      //assign rnext = port.M_AXI_RVALID && axi_rready;                            \n                                                                            \n                                                                            \n    // // Burst length counter. Uses extra counter register bit to indicate    \n    // // terminal count to reduce decode logic                                \n    //   always_ff @(posedge port.M_AXI_ACLK)                                          \n    //   begin                                                                 \n    //     if (port.M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 || start_single_burst_read)                  \n    //       begin                                                             \n    //         read_index <= 0;                                                \n    //       end                                                               \n    //     else if (rnext && (read_index != MEMORY_AXI4_BURST_LEN-1))              \n    //       begin                                                             \n    //         read_index <= read_index + 1;                                   \n    //       end                                                               \n    //     else                                                                \n    //       read_index <= read_index;                                         \n    //   end                                                                   \n                                                                            \n                                                                            \n    /*                                                                      \n     The Read Data channel returns the results of the read request          \n                                                                            \n     In this example the data checker is always able to accept              \n     more data, so no need to throttle the RREADY signal                    \n     */                                                                     \n      always_ff @(posedge port.M_AXI_ACLK)                                          \n      begin                                                                 \n        if (port.M_AXI_ARESETN == 0)                  \n          begin                                                             \n            axi_rready <= 1'b0;                                             \n          end                                                               \n        // accept/acknowledge rdata/rresp with a"}
{"text": "xi_rready by the master     \n        // when port.M_AXI_RVALID is asserted by slave                           \n        else if (port.M_AXI_RVALID)                       \n          begin                                      \n             if (port.M_AXI_RLAST && axi_rready)          \n              begin                                  \n                axi_rready <= 1'b0;                  \n              end                                    \n             else                                    \n               begin                                 \n                 axi_rready <= 1'b1;                 \n               end                                   \n          end                                        \n        // retain the previous value                 \n      end                                            \n                                                                            \n    // //Check received read data against data generator                       \n    //   always_ff @(posedge port.M_AXI_ACLK)                                          \n    //   begin                                                                 \n    //     if (port.M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1)                   \n    //       begin                                                             \n    //         read_mismatch <= 1'b0;                                          \n    //       end                                                               \n    //     //Only check data when RVALID is active                             \n    //     else if (rnext && (port.M_AXI_RDATA != expected_rdata))                  \n    //       begin                                                             \n    //         read_mismatch <= 1'b1;                                          \n    //       end                                                               \n    //     else                                                                \n    //       read_mismatch <= 1'b0;                                            \n    //   end                                                                   \n                                                                            \n    //Flag any read response errors                                         \n      assign read_resp_error = axi_rready & port.M_AXI_RVALID & port.M_AXI_RRESP[1];  \n\n\n    //----------------------------------------\n    //Example design read check data generator\n    //-----------------------------------------\n\n    //Generate expected read data to check against actual read data\n\n      // always_ff @(posedge port.M_AXI_ACLK)                     \n      // begin                                                  \n      //   if (port.M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1)// || port.M_AXI_RLAST)             \n      //       expected_rdata <= 'b1;                            \n      //   else if (port.M_AXI_RVALID && axi_rready)                  \n      //       expected_rdata <= expected_rdata + 1;             \n      //   else                                                  \n      //       expected_rdata <= expected_rdata;                 \n      // end                                                    \n\n\n    //----------------------------------\n    //Example design error register\n    //----------------------------------\n\n    //Register and hold any data mismatches, or read/write interface errors \n\n      always_ff @(posedge port.M_AXI_ACLK)                                 \n      begin                                                              \n        if (port.M_AXI_ARESETN == 0)                                          \n          begin                                                          \n            error_reg <= 1'b0;                                           \n          end                                                            \n        else if (write_resp_error || read_resp_error)   \n          begin                                                          \n            error_reg <= 1'b1;                                           \n          end                                                            \n        else                                                             \n          error_reg <= error_reg;                                        \n      end                                                                \n\n\n    // //--------------------------------\n    // //Example design throttling\n    // //--------------------------------\n\n    // // For maximum port throughput, this user example code will try to allow\n    // // each channel to run as independently and as quickly as possible.\n\n    // // However, there are times when the flow of data needs to be throtted by\n    // // the user application. This example application requires that data is\n    // // not read before it is written and that the write channels do not\n    // // advance beyond an arbitrary threshold (say to prevent an \n    // // overrun of the current read address by the write address).\n\n    // // From AXI4 Specification, 13.13.1: \"If a master requires ordering between \n    // // read and write transactions, it must ensure that a response is received \n    // // for the previous transaction before issuing the next transaction.\"\n\n    // // This example accomplishes this user application throttling through:\n    // // -Reads wait for writes to fully complete\n    // // -Address writes wait when not read + issued transaction counts pass \n    // // a parameterized threshold\n    // // -Writes wait when a not read + active data burst count pass \n    // // a parameterized threshold\n\n    //  // write_burst_counter counter keeps track with the number of burst transaction initiated            \n    //  // against the number of burst transactions the master needs to initiate                                   \n    //   always_ff @(posedge port.M_AXI_ACLK)                                                                              \n    //   begin                                                                                                     \n    //     if (port.M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1 )                                                                                 \n    //       begin                                                                                                 \n    //         write_burst_counter <= 'b0;                                                                         \n    //       end                                                                                                   \n    //     else if (port.M_AXI_AWREADY && axi_awvalid)                                                                  \n    //       begin                                                                                                 \n    //         if (write_burst_counter[C_NO_BURSTS_REQ] == 1'b0)                                                   \n    //           begin                                                                                             \n    //             write_burst_counter <= write_burst_counter + 1'b1;                                              \n    //             //write_burst_counter[C_NO_BURSTS_REQ] <= 1'b1;                                                 \n    //           end                                                                                               \n    //       end                                                                                                   \n    //     else                                                                                                    \n    //       write_burst_counter <= write_burst_counter;                                                           \n    //   end                                                                                                       \n                                                                                                                \n    //  // read_burst_counter counter keeps track with the number of burst transaction initiated                   \n    //  // against the number of burst transactions the master needs to initiate                                   \n    //   always_ff @(posedge port.M_AXI_ACLK)                                                                              \n    //   begin                                                                                                     \n    //     if (port.M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1)                                                                                 \n    //       begin                                                                                                 \n    //         read_burst_counter <= 'b0;                                                                          \n    //       end                                                                                                   \n    //     else if (port.M_AXI_ARREADY && axi_arvalid)                                                                  \n    //       begin                                                                                                 \n    //         if (read_burst_counter[C_NO_BURSTS_REQ] == 1'b0)                                                    \n    //           begin                                                                                             \n    //             read_burst_counter <= read_burst_counter + 1'b1;                                                \n    //             //read_burst_counter[C_NO_BURSTS_REQ] <= 1'b1;                                                  \n    //           end                                                                                               \n    //       end                                                                                                   \n    //     else                                                                                                    \n    //       read_burst_counter <= read_burst_counter;                                                             \n    //   end                                                                                                       \n                                                                                                                \n                                                                                                                \n    //   //implement master command interface state machine                                                        \n                                                                                                                \n    //   always_ff @ ( posedge port.M_AXI_ACLK)                                                                            \n    //   begin                                                                                                     \n    //     if (port.M_AXI_ARESETN == 1'b0 )                                                                             \n    //       begin                                                                                                 \n    //         // reset condition                                                                                  \n    //         // All the signals are assigned default values under reset condition                                \n    //         mst_exec_state      <= IDLE;                                                                \n    //         start_single_burst_write <= 1'b0;                                                                   \n    //         start_single_burst_read  <= 1'b0;                                                                   \n    //         compare_done      <= 1'b0;                                                                          \n    //         ERROR <= 1'b0;   \n    //       end                                                                                                   \n    //     else                                                                                                    \n    //       begin                                                                                                 \n                                                                                                                \n    //         // state transition                                                                                 \n    //         case (mst_exec_state)                                                                               \n                                                                                                                \n    //           IDLE:                                                                                     \n    //             // This state is responsible to wait for user defined C_M_START_COUNT                           \n    //             // number of clock cycles.                                                                      \n    //             if ( init_txn_pulse == 1'b1)                                                      \n    //               begin                                                                                         \n    //                 mst_exec_state  <= INIT_WRITE;                                                              \n    //                 ERROR <= 1'b0;\n    //                 compare_done <= 1'b0;\n    //               end                                                                                           \n    //             else                                                                                            \n    //               begin                                                                                         \n    //                 mst_exec_state  <= IDLE;                                                            \n    //               end                                                                                           \n                                                                                                                \n    //           INIT_WRITE:                                                                                       \n    //             // This state is responsible to issue start_single_write pulse to                               \n    //             // initiate a write transaction. Write transactions will be                                     \n    //             // issued until burst_write_active signal is asserted.                                          \n    //             // write controller                                                                             \n    //             if (writes_done)                                                                                \n    //               begin                                                                                         \n    //                 mst_exec_state <= INIT_READ;//                                                              \n    //               end                                                                                           \n    //             else                                                                                            \n    //               begin                                                                                         \n    //                 mst_exec_state  <= INIT_WRITE;                                                              \n                                                                                                                \n    //                 if (~axi_awvalid && ~start_single_burst_write && ~burst_write_active)                       \n    //                   begin                                                                                     \n    //                     start_single_burst_write <= 1'b1;                                                       \n    //                   end                                                                                       \n    //                 else                                                                                        \n    //                   begin                                                                                     \n    //                     start_single_burst_write <= 1'b0; //Negate to generate a pulse                          \n    //                   end                                                                                       \n    //               end                                                                                           \n                                                                                                                \n    //           INIT_READ:                                                                                        \n    //             // This state is responsible to issue start_single_read pulse to                                \n    //             // initiate a read transaction. Read transactions will be                                       \n    //             // issued until burst_read_active signal is asserted.                                           \n    //             // read controller                                                                              \n    //             if (reads_done)                                                                                 \n    //               begin                                                                                         \n    //                 mst_exec_state <= INIT_COMPARE;                                                             \n    //               end                                                                                           \n    //             else                                                                                            \n    //               begin                                                                                         \n    //                 mst_exec_state  <= INIT_READ;                                                               \n                                                                                                                \n    //                 if (~axi_arvalid && ~burst_read_active && ~start_single_burst_read)                         \n    //                   begin                                                                                     \n    //                     start_single_burst_read <= 1'b1;                                                        \n    //                   end                                                                                       \n    //                else                                                                                         \n    //                  begin                                                                                      \n    //                    start_single_burst_read <= 1'b0; //Negate to generate a pulse                            \n    //                  end                                                                                        \n    //               end                                                                                           \n                                                                                                                \n    //           INIT_COMPARE:                                                                                     \n    //             // This state is responsible to issue the state of comparison                                   \n    //             // of written data with the read data. If no error flags are set,                               \n    //             // compare_done signal will be asseted to indicate success.                                     \n    //             //if (~error_reg)                                                                 "}
{"text": "              \n    //             begin                                                                                           \n    //               ERROR <= error_reg;\n    //               mst_exec_state <= IDLE;                                                               \n    //               compare_done <= 1'b1;                                                                         \n    //             end                                                                                             \n    //           default :                                                                                         \n    //             begin                                                                                           \n    //               mst_exec_state  <= IDLE;                                                              \n    //             end                                                                                             \n    //         endcase                                                                                             \n    //       end                                                                                                   \n    //   end //MASTER_EXECUTION_PROC                                                                               \n                                                                                                                \n                                                                                                                \n      // burst_write_active signal is asserted when there is a burst write transaction                          \n      // is initiated by the assertion of start_single_burst_write. burst_write_active                          \n      // signal remains asserted until the burst write is accepted by the slave                                 \n      always_ff @(posedge port.M_AXI_ACLK)                                                                              \n      begin                                                                                                     \n        if (port.M_AXI_ARESETN == 0)                                                                                 \n          burst_write_active <= 1'b0;                                                                           \n                                                                                                                \n        //The burst_write_active is asserted when a write burst transaction is initiated                        \n        else if (start_single_burst_write)                                                                      \n          burst_write_active <= 1'b1;                                                                           \n        else if (port.M_AXI_BVALID && axi_bready)                                                                    \n          burst_write_active <= 0;                                                                              \n      end                                                                                                       \n                                                                                                                \n    //  // Check for last write completion.                                                                        \n                                                                                                                \n    //  // This logic is to qualify the last write count with the final write                                      \n    //  // response. This demonstrates how to confirm that a write has been                                        \n    //  // committed.                                                                                              \n                                                                                                                \n    //   always_ff @(posedge port.M_AXI_ACLK)                                                                              \n    //   begin                                                                                                     \n    //     if (port.M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1)                                                                                 \n    //       writes_done <= 1'b0;                                                                                  \n                                                                                                                \n    //     //The writes_done should be associated with a bready response                                           \n    //     //else if (port.M_AXI_BVALID && axi_bready && (write_burst_counter == {(C_NO_BURSTS_REQ-1){1}}) && axi_wlast)\n    //     else if (port.M_AXI_BVALID && (write_burst_counter[C_NO_BURSTS_REQ]) && axi_bready)                          \n    //       writes_done <= 1'b1;                                                                                  \n    //     else                                                                                                    \n    //       writes_done <= writes_done;                                                                           \n    //     end                                                                                                     \n                                                                                                                \n    //   // burst_read_active signal is asserted when there is a burst write transaction                           \n    //   // is initiated by the assertion of start_single_burst_write. start_single_burst_read                     \n    //   // signal remains asserted until the burst read is accepted by the master                                 \n    //   always_ff @(posedge port.M_AXI_ACLK)                                                                              \n    //   begin                                                                                                     \n    //     if (port.M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1)                                                                                 \n    //       burst_read_active <= 1'b0;                                                                            \n                                                                                                                \n    //     //The burst_write_active is asserted when a write burst transaction is initiated                        \n    //     else if (start_single_burst_read)                                                                       \n    //       burst_read_active <= 1'b1;                                                                            \n    //     else if (port.M_AXI_RVALID && axi_rready && port.M_AXI_RLAST)                                                     \n    //       burst_read_active <= 0;                                                                               \n    //     end                                                                                                     \n                                                                                                                \n                                                                                                                \n    //  // Check for last read completion.                                                                         \n                                                                                                                \n    //  // This logic is to qualify the last read count with the final read                                        \n    //  // response. This demonstrates how to confirm that a read has been                                         \n    //  // committed.                                                                                              \n                                                                                                                \n    //   always_ff @(posedge port.M_AXI_ACLK)                                                                              \n    //   begin                                                                                                     \n    //     if (port.M_AXI_ARESETN == 0 || init_txn_pulse == 1'b1)                                                                                 \n    //       reads_done <= 1'b0;                                                                                   \n                                                                                                                \n    //     //The reads_done should be associated with a rready response                                            \n    //     //else if (port.M_AXI_BVALID && axi_bready && (write_burst_counter == {(C_NO_BURSTS_REQ-1){1}}) && axi_wlast)\n    //     else if (port.M_AXI_RVALID && axi_rready && (read_index == MEMORY_AXI4_BURST_LEN-1) && (read_burst_counter[C_NO_BURSTS_REQ]))\n    //       reads_done <= 1'b1;                                                                                   \n    //     else                                                                                                    \n    //       reads_done <= reads_done;                                                                             \n    //     end                                                                                                     \n\n    // Add user logic here\n\n    // User logic ends\n\n    // The data width of AXI4 bus and memory access serial must be the same value\n    `RSD_STATIC_ASSERT(\n        `MEMORY_AXI4_READ_ID_WIDTH == MEM_ACCESS_SERIAL_BIT_SIZE, \n        (\"The data width of AXI4 read ID(%x) and memory access serial(%x) are not matched.\", \n          `MEMORY_AXI4_READ_ID_WIDTH, MEM_ACCESS_SERIAL_BIT_SIZE)\n    );\n\n    `RSD_STATIC_ASSERT(\n        `MEMORY_AXI4_WRITE_ID_WIDTH == MEM_WRITE_SERIAL_BIT_SIZE, \n        (\"The data width of AXI4 write ID(%x) and memory write serial(%x) are not matched.\", \n          `MEMORY_AXI4_WRITE_ID_WIDTH, MEM_WRITE_SERIAL_BIT_SIZE)\n    );\n\n    endmodule\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Axi4MemoryIF\n//\n\n`include \"SysDeps/XilinxMacros.vh\"\n\nimport BasicTypes::*;\nimport MemoryTypes::*;\nimport CacheSystemTypes::*;\n\ninterface Axi4MemoryIF;\n\n    // // Initiate AXI transactions\n    // input wire  INIT_AXI_TXN;\n    // // Asserts when transaction is complete\n    // output wire  TXN_DONE;\n    // // Asserts when ERROR is detected\n    // output reg  ERROR;\n    // Global Clock Signal.\n    logic  M_AXI_ACLK;\n    // Global Reset Singal. This Signal is Active Low\n    logic  M_AXI_ARESETN;\n    // Master Interface Write Address ID\n    logic [`MEMORY_AXI4_WRITE_ID_WIDTH-1 : 0] M_AXI_AWID;\n    // Master Interface Write Address\n    logic [`MEMORY_AXI4_ADDR_BIT_SIZE-1 : 0] M_AXI_AWADDR;\n    // Burst length. The burst length gives the exact number of transfers in a burst\n    logic [`MEMORY_AXI4_AWLEN_WIDTH-1 : 0] M_AXI_AWLEN;\n    // Burst size. This signal indicates the size of each transfer in the burst\n    logic [`MEMORY_AXI4_AWSIZE_WIDTH-1 : 0] M_AXI_AWSIZE;\n    // Burst type. The burst type and the size information; \n    // determine how the address for each transfer within the burst is calculated.\n    logic [`MEMORY_AXI4_AWBURST_WIDTH-1 : 0] M_AXI_AWBURST;\n    // Lock type. Provides additional information about the\n    // atomic characteristics of the transfer.\n    logic  M_AXI_AWLOCK;\n    // Memory type. This signal indicates how transactions\n    // are required to progress through a system.\n    logic [`MEMORY_AXI4_AWCACHE_WIDTH-1 : 0] M_AXI_AWCACHE;\n    // Protection type. This signal indicates the privilege\n    // and security level of the transaction; and whether\n    // the transaction is a data access or an instruction access.\n    logic [`MEMORY_AXI4_AWPROT_WIDTH-1 : 0] M_AXI_AWPROT;\n    // Quality of Service; QoS identifier sent for each write transaction.\n    logic [`MEMORY_AXI4_AWQOS_WIDTH-1 : 0] M_AXI_AWQOS;\n    // Optional User-defined signal in the write address channel.\n    logic [`MEMORY_AXI4_AWUSER_WIDTH-1 : 0] M_AXI_AWUSER;\n    // Write address valid. This signal indicates that\n    // the channel is signaling valid write address and control information.\n    logic  M_AXI_AWVALID;\n    // Write address ready. This signal indicates that\n    // the slave is ready to accept an address and associated control signals\n    logic  M_AXI_AWREADY;\n    // Master Interface Write Data.\n    logic [`MEMORY_AXI4_DATA_BIT_NUM-1 : 0] M_AXI_WDATA;\n    // Write strobes. This signal indicates which byte\n    // lanes hold valid data. There is one write strobe\n    // bit for each eight bits of the write data bus.\n    logic [`MEMORY_AXI4_WSTRB_WIDTH-1 : 0] M_AXI_WSTRB;\n    // Write last. This signal indicates the last transfer in a write burst.\n    logic  M_AXI_WLAST;\n    // Optional User-defined signal in the write data channel.\n    logic [`MEMORY_AXI4_WUSER_WIDTH-1 : 0] M_AXI_WUSER;\n    // Write valid. This signal indicates that valid write\n    // data and strobes are available\n    logic  M_AXI_WVALID;\n    // Write ready. This signal indicates that the slave\n    // can accept the write data.\n    logic  M_AXI_WREADY;\n    // Master Interface Write Response.\n    logic [`MEMORY_AXI4_WRITE_ID_WIDTH-1 : 0] M_AXI_BID;\n    // Write response. This signal indicates the status of the write transaction.\n    logic [`MEMORY_AXI4_BRESP_WIDTH-1 : 0] M_AXI_BRESP;\n    // Optional User-defined signal in the write response channel\n    logic [`MEMORY_AXI4_BUSER_WIDTH-1 : 0] M_AXI_BUSER;\n    // Write response valid. This signal indicates that the\n    // channel is signaling a valid write response.\n    logic  M_AXI_BVALID;\n    // Response ready. This signal indicates that the master\n    // can accept a write response.\n    logic  M_AXI_BREADY;\n    // Master Interface Read Address.\n    logic [`MEMORY_AXI4_READ_ID_WIDTH-1 : 0] M_AXI_ARID;\n    // Read address. This signal indicates the initial\n    // address of a read burst transaction.\n    logic [`MEMORY_AXI4_ADDR_BIT_SIZE-1 : 0] M_AXI_ARADDR;\n    // Burst length. The burst length gives the exact number of transfers in a burst\n    logic [`MEMORY_AXI4_ARLEN_WIDTH-1 : 0] M_AXI_ARLEN;\n    // Burst size. This signal indicates the size of each transfer in the burst\n    logic [`MEMORY_AXI4_ARSIZE_WIDTH-1 : 0] M_AXI_ARSIZE;\n    // Burst type. The burst type and the size information; \n    // determine how the address for each transfer within the burst is calculated.\n    logic [`MEMORY_AXI4_ARBURST_WIDTH-1 : 0] M_AXI_ARBURST;\n    // Lock type. Provides additional information about the\n    // atomic characteristics of the transfer.\n    logic  M_AXI_ARLOCK;\n    // Memory type. This signal indicates how transactions\n    // are required to progress through a system.\n    logic [`MEMORY_AXI4_ARCACHE_WIDTH-1 : 0] M_AXI_ARCACHE;\n    // Protection type. This signal indicates the privilege\n    // and security level of the transaction; and whether\n    // the transaction is a data access or an instruction access.\n    logic [`MEMORY_AXI4_ARPROT_WIDTH-1 : 0] M_AXI_ARPROT;\n    // Quality of Service; QoS identifier sent for each read transaction\n    logic [`MEMORY_AXI4_ARQOS_WIDTH-1 : 0] M_AXI_ARQOS;\n    // Optional User-defined signal in the read address channel.\n    logic [`MEMORY_AXI4_ARUSER_WIDTH-1 : 0] M_AXI_ARUSER;\n    // Write address valid. This signal indicates that\n    // the channel is signaling valid read address and control information\n    logic  M_AXI_ARVALID;\n    // Read address ready. This signal indicates that\n    // the slave is ready to accept an address and associated control signals\n    logic  M_AXI_ARREADY;\n    // Read ID tag. This signal is the identification tag\n    // for the read data group of signals generated by the slave.\n    logic [`MEMORY_AXI4_READ_ID_WIDTH-1 : 0] M_AXI_RID;\n    // Master Read Data\n    logic [`MEMORY_AXI4_DATA_BIT_NUM-1 : 0] M_AXI_RDATA;\n    // Read response. This signal indicates the status of the read transfer\n    logic [`MEMORY_AXI4_RRESP_WIDTH-1 : 0] M_AXI_RRESP;\n    // Read last. This signal indicates the last transfer in a read burst\n    logic  M_AXI_RLAST;\n    // Optional User-defined signal in the read address channel.\n    logic [`MEMORY_AXI4_RUSER_WIDTH-1 : 0] M_AXI_RUSER;\n    // Read valid. This signal indicates that the channel\n    // is signaling the required read data.\n    logic  M_AXI_RVALID;\n    // Read ready. This signal indicates that the master can\n    // accept the read data and response information.\n    logic  M_AXI_RREADY;\n\n    modport Axi4(\n    input \n        M_AXI_ACLK,\n        M_AXI_ARESETN,\n    output\n        M_AXI_AWID,\n        M_AXI_AWADDR,\n        M_AXI_AWLEN,\n        M_AXI_AWSIZE,\n        M_AXI_AWBURST,\n        M_AXI_AWLOCK,\n        M_AXI_AWCACHE,\n        M_AXI_AWPROT,\n        M_AXI_AWQOS,\n        M_AXI_AWUSER,\n        M_AXI_AWVALID,\n    input\n        M_AXI_AWREADY,\n    output\n        M_AXI_WDATA,\n        M_AXI_WSTRB,\n        M_AXI_WLAST,\n        M_AXI_WUSER,\n        M_AXI_WVALID,\n    input\n        M_AXI_WREADY,\n        M_AXI_BID,\n        M_AXI_BRESP,\n        M_AXI_BUSER,\n        M_AXI_BVALID,\n    output\n        M_AXI_BREADY,\n        M_AXI_ARID,\n        M_AXI_ARADDR,\n        M_AXI_ARLEN,\n        M_AXI_ARSIZE,\n        M_AXI_ARBURST,\n        M_AXI_ARLOCK,\n        M_AXI_ARCACHE,\n        M_AXI_ARPROT,\n        M_AXI_ARQOS,\n        M_AXI_ARUSER,\n        M_AXI_ARVALID,\n    input\n        M_AXI_ARREADY,\n        M_AXI_RID,\n        M_AXI_RDATA,\n        M_AXI_RRESP,\n        M_AXI_RLAST,\n        M_AXI_RUSER,\n        M_AXI_RVALID,\n    output\n        M_AXI_RREADY\n    );\n\n    modport Axi4Write(\n    input \n        M_AXI_ACLK,\n        M_AXI_ARESETN,\n    output\n        M_AXI_AWID,\n        M_AXI_AWADDR,\n        M_AXI_AWLEN,\n        M_AXI_AWSIZE,\n        M_AXI_AWBURST,\n        M_AXI_AWLOCK,\n        M_AXI_AWCACHE,\n        M_AXI_AWPROT,\n        M_AXI_AWQOS,\n        M_AXI_AWUSER,\n        M_AXI_AWVALID,\n    input\n        M_AXI_AWREADY,\n    output\n        M_AXI_WDATA,\n        M_AXI_WSTRB,\n        M_AXI_WLAST,\n        M_AXI_WUSER,\n        M_AXI_WVALID,\n    input\n        M_AXI_WREADY,\n        M_AXI_BID,\n        M_AXI_BRESP,\n        M_AXI_BUSER,\n        M_AXI_BVALID,\n    output\n        M_AXI_BREADY\n    );\n\n    modport Axi4Read(\n    input \n        M_AXI_ACLK,\n        M_AXI_ARESETN,\n    output\n        M_AXI_ARID,\n        M_AXI_ARADDR,\n        M_AXI_ARLEN,\n        M_AXI_ARSIZE,\n        M_AXI_ARBURST,\n        M_AXI_ARLOCK,\n        M_AXI_ARCACHE,\n        M_AXI_ARPROT,\n        M_AXI_ARQOS,\n        M_AXI_ARUSER,\n        M_AXI_ARVALID,\n    input\n        M_AXI_ARREADY,\n        M_AXI_RID,\n        M_AXI_RDATA,\n        M_AXI_RRESP,\n        M_AXI_RLAST,\n        M_AXI_RUSER,\n        M_AXI_RVALID,\n    output\n        M_AXI_RREADY\n    );\n\nendinterface : Axi4MemoryIF\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n\n\n// On each clock edge, it evaluates \"exp\" and if its result is false, it shows \"msg\".\n// You can use a formatted string with parentheses in \"msg\" as follows:\n// `RSD_ASSERT_CLK_FMT(clk, some_expression, (\"%d\", i))\n/*\n`define RSD_ASSERT_CLK_FMT(clk, exp, msg) \\\n    assert property (@(posedge clk) (exp)) \\\n        else $error msg;\n*/\n\n`ifdef RSD_SYNTHESIS\n    // These macros are disabled in synthesys\n    `define RSD_ASSERT_CLK_FMT(clk, exp, msg) \n    `define RSD_ASSERT_CLK(clk, exp, msg) \n`else\n    `define RSD_ASSERT_CLK_FMT(clk, exp, msg) \\\n        always @(posedge clk) begin \\\n            if (!(exp)) begin \\\n                $display msg; \\\n            end \\\n        end \n    `define RSD_ASSERT_CLK(clk, exp, msg) `RSD_ASSERT_CLK_FMT(clk, exp, (msg))\n`endif\n\n// RSD_STATIC_ASSERT_FMT must be used from outside always_comb/always_ff blocks.\n`define RSD_STATIC_ASSERT_FMT(exp, msg) \\\n    generate \\\n        if (!(exp)) begin \\\n            RSD_STATIC_ASSERT_FAILED non_existing_module(); \\\n        end \\\n    endgenerate \\\n\n//$error msg; \\\n\n`define RSD_STATIC_ASSERT(exp, msg) `RSD_STATIC_ASSERT_FMT(exp, (msg))\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\npackage BasicTypes;\n\nimport MicroArchConf::*;\n\n\nlocalparam TRUE  = 1'b1;\nlocalparam FALSE = 1'b0;\n\n// SID\nlocalparam OP_SERIAL_WIDTH = 10;\ntypedef logic [OP_SERIAL_WIDTH-1:0] OpSerial;\n\n// Byte\nlocalparam BYTE_WIDTH = 8; // 1\u30d0\u30a4\u30c8\u306e\u30d3\u30c3\u30c8\u5e45\ntypedef logic [ BYTE_WIDTH-1:0 ] BytePath;\n\n// Instruction width\nlocalparam INSN_WIDTH = 32;\ntypedef logic [INSN_WIDTH-1:0] InsnPath;\n\nlocalparam INSN_BYTE_WIDTH = INSN_WIDTH / BYTE_WIDTH;\nlocalparam INSN_ADDR_BIT_WIDTH = $clog2(INSN_BYTE_WIDTH);\n\n// Address\nlocalparam ADDR_WIDTH = 32;\nlocalparam ADDR_WIDTH_BIT_SIZE = $clog2(ADDR_WIDTH);\nlocalparam ADDR_BYTE_WIDTH = ADDR_WIDTH / BYTE_WIDTH;\ntypedef logic [ADDR_WIDTH-1:0] AddrPath;\n\n// Data width\nlocalparam DATA_WIDTH = 32;\nlocalparam DATA_BYTE_WIDTH = DATA_WIDTH / BYTE_WIDTH;\nlocalparam DATA_BYTE_WIDTH_BIT_SIZE = $clog2(DATA_BYTE_WIDTH);\ntypedef logic [DATA_WIDTH-1:0] DataPath;\ntypedef logic signed [DATA_WIDTH-1:0] SignedDataPath;\nlocalparam DATA_MASK = 32'hffffffff;\nlocalparam DATA_ZERO = 32'h00000000;\n\n// Vector Data width\nlocalparam VEC_WIDTH = 128;\nlocalparam VEC_WORD_WIDTH = VEC_WIDTH / DATA_WIDTH;\nlocalparam VEC_BYTE_WIDTH = VEC_WIDTH / BYTE_WIDTH;\nlocalparam VEC_BYTE_WIDTH_BIT_SIZE = $clog2(VEC_BYTE_WIDTH);\nlocalparam VEC_ADDR_MASK = 32'hfffffff0; // \u4e0b\u4f4dVEC_BYTE_WIDTH_BIT_SIZE\u30d3\u30c3\u30c8\u304c0\ntypedef logic [VEC_WIDTH-1:0] VectorPath;\n\n//\n// --- Register File\n//\n\n// Logical register number width\nlocalparam LSCALAR_NUM = 32;\nlocalparam LSCALAR_NUM_BIT_WIDTH = $clog2( LSCALAR_NUM );\ntypedef logic [LSCALAR_NUM_BIT_WIDTH-1:0] LScalarRegNumPath;\n\n// Physical register number width\nlocalparam PSCALAR_NUM = CONF_PSCALAR_NUM;\nlocalparam PSCALAR_NUM_BIT_WIDTH = $clog2( PSCALAR_NUM );\ntypedef logic [PSCALAR_NUM_BIT_WIDTH-1:0] PScalarRegNumPath;\n\n// Logical fp register number width\nlocalparam LSCALAR_FP_NUM = 32;\nlocalparam LSCALAR_FP_NUM_BIT_WIDTH = $clog2( LSCALAR_FP_NUM );\ntypedef logic [LSCALAR_FP_NUM_BIT_WIDTH-1:0] LScalarFPRegNumPath;\n\n// Physical fp register number width\nlocalparam PSCALAR_FP_NUM = CONF_PSCALAR_FP_NUM;\nlocalparam PSCALAR_FP_NUM_BIT_WIDTH = $clog2( PSCALAR_FP_NUM );\ntypedef logic [PSCALAR_FP_NUM_BIT_WIDTH-1:0] PScalarFPRegNumPath;\n\n// Logical general register ( scalar int register + fp register) number width\nlocalparam LREG_NUM = LSCALAR_NUM + LSCALAR_FP_NUM;\nlocalparam LREG_NUM_BIT_WIDTH = $clog2( LREG_NUM );\ntypedef struct packed { // LRegNumPath\n`ifdef RSD_MARCH_FP_PIPE\n    logic isFP; // If TRUE, the register is for FP.\n    logic [ LREG_NUM_BIT_WIDTH-2:0 ] regNum;\n`else\n    logic [ LREG_NUM_BIT_WIDTH-1:0 ] regNum;\n`endif\n} LRegNumPath;\n\n// Physical general register ( scalar int register + fp register ) number width\n`ifdef RSD_MARCH_FP_PIPE\nlocalparam PREG_NUM = PSCALAR_NUM + PSCALAR_FP_NUM;\nlocalparam PREG_NUM_BIT_WIDTH = $clog2( PREG_NUM );\ntypedef struct packed { // PRegNumPath\n    logic isFP; // If TRUE, the register is for FP.\n    logic [ PREG_NUM_BIT_WIDTH-2:0 ] regNum;\n} PRegNumPath;\n`else\nlocalparam PREG_NUM = PSCALAR_NUM;\nlocalparam PREG_NUM_BIT_WIDTH = $clog2( PREG_NUM );\ntypedef struct packed { // PRegNumPath\n    logic [ PREG_NUM_BIT_WIDTH-1:0 ] regNum;\n} PRegNumPath;\n`endif\n\n\n//\n// --- Pipeline\n//\n\n// Fetch width\nlocalparam FETCH_WIDTH = CONF_FETCH_WIDTH;\nlocalparam FETCH_WIDTH_BIT_SIZE = $clog2( FETCH_WIDTH ); // log2(FETCH_WIDTH)\ntypedef logic [ FETCH_WIDTH_BIT_SIZE-1:0 ] FetchLaneIndexPath;\n\n// Decode width\nlocalparam DECODE_WIDTH = FETCH_WIDTH;\nlocalparam DECODE_WIDTH_BIT_SIZE = FETCH_WIDTH_BIT_SIZE; // log2(DECODE_WIDTH)\ntypedef logic [ DECODE_WIDTH_BIT_SIZE-1:0 ] DecodeLaneIndexPath;\n\n// Rename width\nlocalparam RENAME_WIDTH = FETCH_WIDTH;\nlocalparam RENAME_WIDTH_BIT_SIZE = FETCH_WIDTH_BIT_SIZE; // log2(RENAME_WIDTH)\ntypedef logic [ RENAME_WIDTH_BIT_SIZE-1:0 ] RenameLaneIndexPath;\ntypedef logic unsigned [ $clog2(RENAME_WIDTH):0 ] RenameLaneCountPath;\n\n// Dispatch width\nlocalparam DISPATCH_WIDTH = FETCH_WIDTH;\nlocalparam DISPATCH_WIDTH_BIT_SIZE = FETCH_WIDTH_BIT_SIZE; // log2(DISPATCH_WIDTH)\ntypedef logic [ DISPATCH_WIDTH_BIT_SIZE-1:0 ] DispatchLaneIndexPath;\n\n// Issue width\nlocalparam INT_ISSUE_WIDTH = CONF_INT_ISSUE_WIDTH;\nlocalparam INT_ISSUE_WIDTH_BIT_SIZE = 1; // log2(INT_ISSUE_WIDTH)\ntypedef logic [ INT_ISSUE_WIDTH_BIT_SIZE-1:0 ] IntIssueLaneIndexPath;\ntypedef logic unsigned [ $clog2(INT_ISSUE_WIDTH):0 ] IntIssueLaneCountPath;\n\nlocalparam MULDIV_ISSUE_WIDTH = 1;\nlocalparam MULDIV_STAGE_DEPTH = 3;\n\nlocalparam COMPLEX_ISSUE_WIDTH = CONF_COMPLEX_ISSUE_WIDTH;\nlocalparam COMPLEX_ISSUE_WIDTH_BIT_SIZE = 1; // log2(COMPLEX_ISSUE_WIDTH)\ntypedef logic [ COMPLEX_ISSUE_WIDTH_BIT_SIZE-1:0 ] ComplexIssueLaneIndexPath;\ntypedef logic unsigned [ $clog2(COMPLEX_ISSUE_WIDTH):0 ] ComplexIssueLaneCountPath;\n\nlocalparam LOAD_ISSUE_WIDTH = CONF_LOAD_ISSUE_WIDTH;\nlocalparam STORE_ISSUE_WIDTH = CONF_STORE_ISSUE_WIDTH;\nlocalparam MEM_ISSUE_WIDTH = CONF_MEM_ISSUE_WIDTH;\nlocalparam STORE_ISSUE_LANE_BEGIN = CONF_STORE_ISSUE_LANE_BEGIN;   // Load and store share the same lanes\n\n\nlocalparam MEM_ISSUE_WIDTH_BIT_SIZE = 1; // log2(MEM_ISSUE_WIDTH)\ntypedef logic [ MEM_ISSUE_WIDTH_BIT_SIZE-1:0 ] MemIssueLaneIndexPath;\ntypedef logic unsigned [ $clog2(MEM_ISSUE_WIDTH):0 ] MemIssueLaneCountPath;\n\nlocalparam FP_DIVSQRT_ISSUE_WIDTH = 1;\nlocalparam FP_ISSUE_WIDTH = CONF_FP_ISSUE_WIDTH;\nlocalparam FP_ISSUE_WIDTH_BIT_SIZE = (FP_ISSUE_WIDTH == 1) ? 1 : $clog2(FP_ISSUE_WIDTH);\n`ifdef RSD_MARCH_FP_PIPE\ntypedef logic [ FP_ISSUE_WIDTH_BIT_SIZE-1:0 ] FPIssueLaneIndexPath;\ntypedef logic unsigned [ $clog2(FP_ISSUE_WIDTH):0 ] FPIssueLaneCountPath;\n`endif\n\nlocalparam ISSUE_WIDTH = INT_ISSUE_WIDTH + COMPLEX_ISSUE_WIDTH + MEM_ISSUE_WIDTH + FP_ISSUE_WIDTH;\nlocalparam ISSUE_WIDTH_BIT_SIZE = $clog2(ISSUE_WIDTH); // log2(ISSUE_WIDTH)\ntypedef logic [ ISSUE_WIDTH_BIT_SIZE-1:0 ] IssueLaneIndexPath;\ntypedef logic unsigned [ ISSUE_WIDTH_BIT_SIZE:0 ] IssueLaneCountPath;\n\n// Commit width\nlocalparam COMMIT_WIDTH = CONF_COMMIT_WIDTH;     //must be more than RENAME_WIDTH for recovery\nlocalparam COMMIT_WIDTH_BIT_SIZE = $clog2(COMMIT_WIDTH); // log2(COMMIT_WIDTH)\ntypedef logic [ COMMIT_WIDTH_BIT_SIZE-1:0 ] CommitLaneIndexPath;\ntypedef logic unsigned [ COMMIT_WIDTH_BIT_SIZE:0 ] CommitLaneCountPath;\n\n\n// Complex Pipeline depth\nlocalparam COMPLEX_EXEC_STAGE_DEPTH = 3;\n\n// FP Pipeline depth\nlocalparam FP_EXEC_STAGE_DEPTH = 5;\n\n//\n// --- Op\n//\ntypedef struct packed // OpSrc\n{\n    PRegNumPath phySrcRegNumA;\n    PRegNumPath phySrcRegNumB;\n`ifdef RSD_MARCH_FP_PIPE\n    PRegNumPath phySrcRegNumC;\n`endif\n} OpSrc;\n\ntypedef struct packed // OpDst\n{\n    logic writeReg;\n    PRegNumPath phyDstRegNum;\n} OpDst;\n\n\n//\n// --- Physical register data\n//\nlocalparam PREG_DATA_WIDTH = DATA_WIDTH + 1; // +1 is for a valid flag.\ntypedef struct packed \n{\n    logic valid;\n    DataPath data;\n} PRegDataPath;\n\n//\n// --- Shifter\n//\nlocalparam SHIFTER_WIDTH = 12;\nlocalparam RISCV_SHIFTER_WIDTH = 30;\ntypedef logic [ RISCV_SHIFTER_WIDTH-1:0 ] ShifterPath;\n\nlocalparam SHIFT_AMOUNT_BIT_SIZE = 5;\ntypedef logic [SHIFT_AMOUNT_BIT_SIZE-1:0] ShiftAmountPath;\n\n//\n// --- Interrupt\n//\nlocalparam RSD_EXTERNAL_INTERRUPT_CODE_WIDTH = 5;\ntypedef logic [RSD_EXTERNAL_INTERRUPT_CODE_WIDTH-1:0] ExternalInterruptCodePath;\n\n\nendpackage\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Branch predictor -- 2bc.\n//\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport FetchUnitTypes::*;\n\nfunction automatic PHT_IndexPath ToPHT_Index_Local(PC_Path addr);\n    return\n        addr[\n            PHT_ENTRY_NUM_BIT_WIDTH + INSN_ADDR_BIT_WIDTH - 1: \n            INSN_ADDR_BIT_WIDTH\n        ];\nendfunction\n\nmodule Bimodal(\n    NextPCStageIF.BranchPredictor port,\n    FetchStageIF.BranchPredictor next\n);\n\n    PC_Path pcIn;\n\n    logic brPredTaken;\n\n    // PHT control logic\n    logic phtWE[INT_ISSUE_WIDTH];\n    PHT_IndexPath phtWA[INT_ISSUE_WIDTH];\n    PHT_EntryPath phtWV[INT_ISSUE_WIDTH];\n    PHT_EntryPath phtPrevValue[INT_ISSUE_WIDTH];\n\n    // Read port need for branch predict and update counter.\n    PHT_IndexPath phtRA[FETCH_WIDTH];\n    PHT_EntryPath phtRV[FETCH_WIDTH];\n\n    // assert when misprediction occured.\n    logic mispred;\n\n    logic pushPhtQueue, popPhtQueue;\n    logic full, empty;\n\n    PhtQueueEntry phtQueue[PHT_QUEUE_SIZE];\n    PhtQueuePointerPath headPtr, tailPtr;\n\n    logic updatePht;\n\n\n    // the body of PHT.\n    generate\n        BlockMultiBankRAM #(\n            .ENTRY_NUM( PHT_ENTRY_NUM ),\n            .ENTRY_BIT_SIZE( $bits( PHT_EntryPath ) ),\n            .READ_NUM( FETCH_WIDTH ),\n            .WRITE_NUM( INT_ISSUE_WIDTH )\n        ) \n        pht( \n            .clk(port.clk),\n            .we(phtWE),\n            .wa(phtWA),\n            .wv(phtWV),\n            .ra(phtRA),\n            .rv(phtRV)\n        );\n\n        QueuePointer #(\n            .SIZE( PHT_QUEUE_SIZE )\n        )\n        phtQueuePointer(\n            .clk(port.clk),\n            .rst(port.rst),\n            .push(pushPhtQueue),\n            .pop(popPhtQueue),\n            .full(full),\n            .empty(empty),\n            .headPtr(headPtr),\n            .tailPtr(tailPtr)    \n        );\n    endgenerate\n    \n    \n    // Counter for reset sequence.\n    PHT_IndexPath resetIndex;\n    always_ff @(posedge port.clk) begin\n        if(port.rstStart) begin\n            resetIndex <= 0;\n        end\n        else begin\n            resetIndex <= resetIndex + 1;\n        end\n    end\n\n    always_ff @(posedge port.clk) begin\n        // Push Pht Queue\n        if (port.rst) begin\n            phtQueue[resetIndex % PHT_QUEUE_SIZE].phtWA <= '0;\n            phtQueue[resetIndex % PHT_QUEUE_SIZE].phtWV <= PHT_ENTRY_MAX / 2 + 1;\n        end\n        else if (pushPhtQueue) begin\n            phtQueue[headPtr].phtWA <= phtWA[INT_ISSUE_WIDTH-1];\n            phtQueue[headPtr].phtWV <= phtWV[INT_ISSUE_WIDTH-1];\n        end\n    end\n\n\n    always_comb begin\n    \n        pcIn = port.predNextPC;\n\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            next.phtPrevValue[i] = phtRV[i];\n\n            // Predict directions (Check the MSB).\n            brPredTaken =\n                phtRV[i][PHT_ENTRY_WIDTH - 1] && next.btbHit[i];\n            next.brPredTaken[i] = brPredTaken;\n\n            if (brPredTaken) begin\n                // If brPred is taken, next instruction don't be executed.\n                break;\n            end\n        end\n\n        // Negate first. (to discard the result of previous cycle)\n        for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n            phtWE[i] = FALSE;\n            updatePht = FALSE;\n            pushPhtQueue = FALSE;\n        end\n\n        for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n            // When branch instruction is executed, update PHT.\n            if (updatePht) begin\n                pushPhtQueue = port.brResult[i].valid;\n            end\n            else begin\n                phtWE[i] = port.brResult[i].valid;\n                updatePht |= phtWE[i];\n            end\n\n            phtWA[i] = ToPHT_Index_Local(port.brResult[i].brAddr);\n\n            mispred = port.brResult[i].mispred && port.brResult[i].valid;\n            \n            // Counter's value.\n            phtPrevValue[i] = port.brResult[i].phtPrevValue; \n            \n            // Update PHT's counter (saturated up/down counter).\n            if (port.brResult[i].execTaken) begin\n                phtWV[i] = (phtPrevValue[i] == PHT_ENTRY_MAX) ? \n                    PHT_ENTRY_MAX : phtPrevValue[i] + 1;\n            end\n            else begin\n                phtWV[i] = (phtPrevValue[i] == 0) ? \n                    0 : phtPrevValue[i] - 1;\n            end\n\n            // When miss prediction is occured, recovory history.\n            if (mispred) begin\n                break;\n            end\n        end\n\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            // Read PHT entry for next cycle (use PC).\n            phtRA[i] = ToPHT_Index_Local(pcIn + i*INSN_BYTE_WIDTH);\n        end\n\n\n        // Pop PHT Queue\n        if (!empty && !updatePht) begin\n            popPhtQueue = TRUE;\n            phtWE[0] = TRUE;\n            phtWA[0] = phtQueue[tailPtr].phtWA;\n            phtWV[0] = phtQueue[tailPtr].phtWV;\n        end \n        else begin\n            popPhtQueue = FALSE;\n        end\n\n        // In reset sequence, the write port 0 is used for initializing, and \n        // the other write ports are disabled.\n        if (port.rst) begin\n            for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n                phtWE[i] = (i == 0) ? TRUE : FALSE;\n                phtWA[i] = resetIndex;\n                phtWV[i] = PHT_ENTRY_MAX / 2 + 1;\n            end\n\n            // To avoid writing to the same bank (avoid error message)\n            for (int i = 0; i < FETCH_WIDTH; i++) begin\n                phtRA[i] = i;\n            end\n\n            pushPhtQueue = FALSE;\n            popPhtQueue = FALSE;\n        end\n    end\n\n\nendmodule : Bimodal\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Bit counter unit (Process CLZ instruction)\n//\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\n\n// \u30d3\u30c3\u30c8\u30fb\u30ab\u30a6\u30f3\u30bf\n// \u30c7\u30fc\u30bf\u306e\u4e0a\u4f4d\u304b\u30890\u304c\u9023\u7d9a\u3057\u3066\u3044\u308b\u30d3\u30c3\u30c8\u306e\u6570\u3092\u51fa\u529b\nmodule BitCounter(\ninput\n    DataPath fuOpA_In,\noutput\n    DataPath dataOut\n);\n    DataPath count;\n    \n    always_comb begin\n        for ( count = 0; count < DATA_WIDTH; count++ ) begin\n            if ( fuOpA_In[ DATA_WIDTH - count - 1 ] == TRUE )\n                break;\n        end\n        dataOut = count;\n    end\n\nendmodule : BitCounter\n\n// \u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5316\u3055\u308c\u305f\u30d3\u30c3\u30c8\u30fb\u30ab\u30a6\u30f3\u30bf\n// PIPELINE_DEPTH\u306f2\u4ee5\u4e0a\u3067\u306a\u3051\u308c\u3070\u306a\u3089\u306a\u3044\nmodule PipelinedBitCounter#( \n    parameter PIPELINE_DEPTH = 3\n)(\ninput\n    clk, rst, stall,\n    DataPath fuOpA_In,\noutput\n    DataPath dataOut\n);\n    DataPath pipeReg[ PIPELINE_DEPTH-1 ]; // synthesis syn_pipeline = 1\n    DataPath count;\n    \n    always_comb begin\n        for ( count = 0; count < DATA_WIDTH; count++ ) begin\n            if ( fuOpA_In[ DATA_WIDTH - count - 1 ] == TRUE )\n                break;\n        end\n        dataOut = pipeReg[ PIPELINE_DEPTH-2 ];\n    end\n\n    always_ff @(posedge clk) begin\n        if ( rst ) begin\n            for ( int i = 0; i < PIPELINE_DEPTH-1; i++)\n                pipeReg[i] <= '0;\n        end\n        else if ( stall ) begin\n            for ( int i = 0; i < PIPELINE_DEPTH-1; i++)\n                pipeReg[i] <= pipeReg[i];\n        end\n        else begin\n            pipeReg[0] <= count;\n            for ( int i = 1; i < PIPELINE_DEPTH-1; i++)\n                pipeReg[i] <= pipeReg[i-1];\n        end\n    end\n\nendmodule : PipelinedBitCounter\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Branch predictor\n//\n\nimport BasicTypes::*;\nimport FetchUnitTypes::*;\n\n`define USE_GSHARE\n\nmodule BranchPredictor(\n    NextPCStageIF.BranchPredictor port,\n    FetchStageIF.BranchPredictor next,\n    ControllerIF.BranchPredictor ctrl\n);\n\n`ifdef USE_GSHARE\n    Gshare predictor( port, next, ctrl );\n`else\n    Bimodal predictor( port, next );\n`endif\n\nendmodule : BranchPredictor\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Branch target buffer\n//\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport FetchUnitTypes::*;\n\nmodule BTB(\n    NextPCStageIF.BTB port,\n    FetchStageIF.BTB next\n);\n\n    // BTB access\n    logic btbWE[INT_ISSUE_WIDTH];\n    BTB_IndexPath btbWA[INT_ISSUE_WIDTH];\n    BTB_Entry btbWV[INT_ISSUE_WIDTH];\n    BTB_IndexPath btbRA[FETCH_WIDTH];\n    BTB_Entry btbRV[FETCH_WIDTH];\n    \n    // Output\n    PC_Path btbOut[FETCH_WIDTH];\n    logic btbHit[FETCH_WIDTH];\n    logic readIsCondBr[FETCH_WIDTH];\n    \n    PC_Path pcIn;\n    \n    PC_Path [FETCH_WIDTH-1 : 0] tagReg;\n    PC_Path [FETCH_WIDTH-1 : 0] nextTagReg;\n    \n    logic pushBtbQueue, popBtbQueue;\n    logic full, empty;\n\n    BTBQueueEntry btbQueue[BTB_QUEUE_SIZE];\n    BTBQueuePointerPath headPtr, tailPtr;\n\n    logic updateBtb;\n\n    generate\n        BlockMultiBankRAM #(\n            .ENTRY_NUM( BTB_ENTRY_NUM ),\n            .ENTRY_BIT_SIZE( $bits( BTB_Entry ) ),\n            .READ_NUM( FETCH_WIDTH ),\n            .WRITE_NUM( INT_ISSUE_WIDTH )\n        ) \n        btbEntryArray( \n            .clk(port.clk),\n            .we(btbWE),\n            .wa(btbWA),\n            .wv(btbWV),\n            .ra(btbRA),\n            .rv(btbRV)\n        );\n\n        QueuePointer #(\n            .SIZE( BTB_QUEUE_SIZE )\n        )\n        btbQueuePointer(\n            .clk(port.clk),\n            .rst(port.rst),\n            .push(pushBtbQueue),\n            .pop(popBtbQueue),\n            .full(full),\n            .empty(empty),\n            .headPtr(headPtr),\n            .tailPtr(tailPtr)    \n        );\n    endgenerate\n    \n    \n    // Counter for reset sequence.\n    BTB_IndexPath resetIndex;\n    always_ff @(posedge port.clk) begin\n        if(port.rstStart) begin\n            resetIndex <= 0;\n        end\n        else begin\n            resetIndex <= resetIndex + 1;\n        end\n        \n        if (port.rst) begin\n            tagReg <= '0;\n        end\n        else begin\n            tagReg <= nextTagReg;\n        end\n    end\n\n    always_ff @(posedge port.clk) begin\n        // Push btb Queue\n        if (port.rst) begin\n            btbQueue[resetIndex % BTB_QUEUE_SIZE].btbWA <= '0;\n            btbQueue[resetIndex % BTB_QUEUE_SIZE].btbWV <= '0;\n        end\n        else if (pushBtbQueue) begin\n            btbQueue[headPtr].btbWA <= btbWA[INT_ISSUE_WIDTH-1];\n            btbQueue[headPtr].btbWV <= btbWV[INT_ISSUE_WIDTH-1];\n        end \n    end\n\n\n    always_comb begin\n        \n        pcIn = port.predNextPC;\n        \n        // Address inputs for read entry.\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            btbRA[i] = ToBTB_Index(pcIn + i*INSN_BYTE_WIDTH);\n            nextTagReg[i] = pcIn + i*INSN_BYTE_WIDTH;\n        end\n            \n        // Make logic for using at other module.\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            btbHit[i] = btbRV[i].valid && (btbRV[i].tag == ToBTB_Tag(tagReg[i]));\n            btbOut[i] = ToRawAddrFromBTB_Addr(btbRV[i].data, tagReg[i]);\n            readIsCondBr[i] = btbRV[i].isCondBr;\n        end\n\n        for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n            btbWE[i] = FALSE;\n        end\n        updateBtb = FALSE;\n        pushBtbQueue = FALSE;\n\n        // Write to BTB.\n        for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n            // Make BTB entry when branch is Taken.\n            if (updateBtb) begin\n                pushBtbQueue = port.brResult[i].valid && port.brResult[i].execTaken;\n            end\n            else begin\n                btbWE[i] = port.brResult[i].valid && port.brResult[i].execTaken;\n                updateBtb |= btbWE[i];\n            end\n\n            btbWA[i] = ToBTB_Index(port.brResult[i].brAddr);\n            btbWV[i].tag = ToBTB_Tag(port.brResult[i].brAddr);\n            btbWV[i].data = ToBTB_Addr(port.brResult[i].nextAddr);\n            btbWV[i].valid = TRUE;\n            btbWV[i].isCondBr = port.brResult[i].isCondBr;\n        end\n\n        // Pop btb Queue\n        if (!empty && !updateBtb) begin\n            popBtbQueue = TRUE;\n            btbWE[0] = TRUE;\n            btbWA[0] = btbQueue[tailPtr].btbWA;\n            btbWV[0] = btbQueue[tailPtr].btbWV;\n        end \n        else begin\n            popBtbQueue = FALSE;\n        end\n\n        \n        // In reset sequence, the write port 0 is used for initializing, and \n        // the other write ports are disabled.\n        if (port.rst) begin\n            for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n                btbWE[i] = (i == 0) ? TRUE : FALSE;\n                btbWA[i] = resetIndex;\n                btbWV[i].tag = 0;\n                btbWV[i].data = 0;\n                btbWV[i].valid = FALSE;\n            end\n\n            // To avoid writing to the same bank (avoid error message)\n            for (int i = 0; i < FETCH_WIDTH; i++) begin\n                btbRA[i] = i;\n            end\n            \n            pushBtbQueue = FALSE;\n            popBtbQueue = FALSE;\n        end\n\n        next.readIsCondBr = readIsCondBr;\n        next.btbOut = btbOut;\n        next.btbHit = btbHit;\n        \n    end\n\n\nendmodule : BTB\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\nimport BasicTypes::*;\nimport ActiveListIndexTypes::*;\nimport PipelineTypes::*;\nimport BypassTypes::*;\n\n//\n// --- Bypass controller\n//\n// BypassController outputs control information that controlls BypassNetwork.\n// BypassController is connected to a register read stage.\n//\n\ntypedef struct packed // struct BypassCtrlOperand\n{\n    PRegNumPath dstRegNum;\n    logic writeReg;\n} BypassCtrlOperand;\n\n\nmodule BypassCtrlStage(\n    input  logic clk, rst, \n    input  PipelineControll ctrl,\n    input  BypassCtrlOperand in, \n    output BypassCtrlOperand out \n);\n    BypassCtrlOperand body;\n    \n    always_ff@( posedge clk )               // synchronous rst \n    begin\n        if( rst || ctrl.clear ) begin              // rst \n            body.dstRegNum <= 0;\n            body.writeReg  <= FALSE;\n        end\n        else if( ctrl.stall ) begin         // write data\n            body <= body;\n        end\n        else begin\n            body <= in;\n        end\n    end\n    \n    assign out = body;\nendmodule\n\nmodule BypassController( \n    BypassNetworkIF.BypassController port,\n    ControllerIF.BypassController ctrl\n);\n\n    function automatic BypassSelect SelectReg( \n    input\n        PRegNumPath regNum,\n        logic read,\n        BypassCtrlOperand intEX [ INT_ISSUE_WIDTH ],\n        BypassCtrlOperand intWB [ INT_ISSUE_WIDTH ],\n        BypassCtrlOperand memMA [ LOAD_ISSUE_WIDTH ],\n        BypassCtrlOperand memWB [ LOAD_ISSUE_WIDTH ]\n    );\n        BypassSelect ret;\n        ret.valid = FALSE;\n        //ret.stg = BYPASS_STAGE_DEFAULT;\n        ret.stg = BYPASS_STAGE_INT_EX;\n        ret.lane.intLane = 0;\n        ret.lane.memLane = 0;\n        // Not implemented \n        ret.lane.complexLane = 0; \n`ifdef RSD_MARCH_FP_PIPE\n        ret.lane.fpLane = 0; \n`endif\n\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n            if ( read && intEX[i].writeReg && regNum == intEX[i].dstRegNum ) begin\n                ret.valid = TRUE;\n                ret.stg = BYPASS_STAGE_INT_EX;\n                ret.lane.intLane = i;\n                break;\n            end\n            if ( read && intWB[i].writeReg && regNum == intWB[i].dstRegNum ) begin\n                ret.valid = TRUE;\n                ret.stg = BYPASS_STAGE_INT_WB;\n                ret.lane.intLane = i;\n                break;\n            end\n        end\n        \n        for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin\n            if ( read && memMA[i].writeReg && regNum == memMA[i].dstRegNum ) begin\n                ret.valid = TRUE;\n                ret.stg = BYPASS_STAGE_MEM_MA;\n                ret.lane.memLane = i;\n                break;\n            end\n            if ( read && memWB[i].writeReg && regNum == memWB[i].dstRegNum ) begin\n                ret.valid = TRUE;\n                ret.stg = BYPASS_STAGE_MEM_WB;\n                ret.lane.memLane = i;\n                break;\n            end\n        end\n        \n        return ret;\n    endfunction\n\n    logic clk, rst;\n    \n    assign clk = port.clk;\n    assign rst = port.rst;\n    \n    //\n    // Back-end Pipeline Structure\n    //\n    // Int:     IS RR EX WB\n    // Complex: IS RR EX WB\n    // Mem:     IS RR EX MT MA WB\n    BypassCtrlOperand intRR [ INT_ISSUE_WIDTH ];\n    BypassCtrlOperand intEX [ INT_ISSUE_WIDTH ];\n    BypassCtrlOperand intWB [ INT_ISSUE_WIDTH ];\n    BypassCtrlOperand memRR [ LOAD_ISSUE_WIDTH ];\n    BypassCtrlOperand memEX [ LOAD_ISSUE_WIDTH ];\n    BypassCtrlOperand memMT [ LOAD_ISSUE_WIDTH ];\n    BypassCtrlOperand memMA [ LOAD_ISSUE_WIDTH ];\n    BypassCtrlOperand memWB [ LOAD_ISSUE_WIDTH ];\n\n    for ( genvar i = 0; i < INT_ISSUE_WIDTH; i++ ) begin : stgInt\n        BypassCtrlStage stgIntRR( clk, rst, ctrl.backEnd, intRR[i], intEX[i] );\n        BypassCtrlStage stgIntEX( clk, rst, ctrl.backEnd, intEX[i], intWB[i] );\n    end\n\n    for ( genvar i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin : stgMem\n        BypassCtrlStage stgMemRR( clk, rst, ctrl.backEnd, memRR[i], memEX[i] );\n        BypassCtrlStage stgMemEX( clk, rst, ctrl.backEnd, memEX[i], memMT[i] );\n        BypassCtrlStage stgMemMT( clk, rst, ctrl.backEnd, memMT[i], memMA[i] );\n        BypassCtrlStage stgMemMA( clk, rst, ctrl.backEnd, memMA[i], memWB[i] );\n    end\n    \n    BypassControll intBypassCtrl [ INT_ISSUE_WIDTH ];\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    BypassControll complexBypassCtrl [ COMPLEX_ISSUE_WIDTH ];\n`endif\n    BypassControll memBypassCtrl [ MEM_ISSUE_WIDTH ];\n`ifdef  RSD_MARCH_FP_PIPE\n    BypassControll fpBypassCtrl [ FP_ISSUE_WIDTH ];\n`endif\n\n    always_comb begin\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n            intRR[i].dstRegNum = port.intPhyDstRegNum[i];\n            intRR[i].writeReg  = port.intWriteReg[i];\n\n            intBypassCtrl[i].rA   = SelectReg ( port.intPhySrcRegNumA[i], port.intReadRegA[i], intEX, intWB, memMA, memWB );\n            intBypassCtrl[i].rB   = SelectReg ( port.intPhySrcRegNumB[i], port.intReadRegB[i], intEX, intWB, memMA, memWB );\n        end\n        port.intCtrlOut = intBypassCtrl;\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n            complexBypassCtrl[i].rA   = SelectReg ( port.complexPhySrcRegNumA[i], port.complexReadRegA[i], intEX, intWB, memMA, memWB );\n            complexBypassCtrl[i].rB   = SelectReg ( port.complexPhySrcRegNumB[i], port.complexReadRegB[i], intEX, intWB, memMA, memWB );\n        end\n        port.complexCtrlOut = complexBypassCtrl;\n`endif\n\n        for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin\n            memRR[i].dstRegNum = port.memPhyDstRegNum[i];\n            memRR[i].writeReg  = port.memWriteReg[i];\n        end\n\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            memBypassCtrl[i].rA   = SelectReg ( port.memPhySrcRegNumA[i], port.memReadRegA[i], intEX, intWB, memMA, memWB );\n            memBypassCtrl[i].rB   = SelectReg ( port.memPhySrcRegNumB[i], port.memReadRegB[i], intEX, intWB, memMA, memWB );\n        end\n        port.memCtrlOut = memBypassCtrl;\n\n`ifdef RSD_MARCH_FP_PIPE\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n            fpBypassCtrl[i].rA   = SelectReg ( port.fpPhySrcRegNumA[i], port.fpReadRegA[i], intEX, intWB, memMA, memWB );\n            fpBypassCtrl[i].rB   = SelectReg ( port.fpPhySrcRegNumB[i], port.fpReadRegB[i], intEX, intWB, memMA, memWB );\n            fpBypassCtrl[i].rC   = SelectReg ( port.fpPhySrcRegNumC[i], port.fpReadRegC[i], intEX, intWB, memMA, memWB );\n        end\n        port.fpCtrlOut = fpBypassCtrl;\n`endif\n    end\n\nendmodule : BypassController\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- Bypass network\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\nimport BypassTypes::*;\n\ntypedef struct packed // struct BypassOperand\n{\n    PRegDataPath value;\n} BypassOperand;\n\n\nmodule BypassStage(\n    input  logic clk, rst, \n    input  PipelineControll ctrl,\n    input  BypassOperand in, \n    output BypassOperand out \n);\n    BypassOperand body;\n    \n    always_ff@( posedge clk )               // synchronous rst \n    begin\n        if( rst || ctrl.clear ) begin              // rst \n            body.value.data <= 0;\n            body.value.valid <= 0;\n        end\n        else if( ctrl.stall ) begin         // write data\n            body <= body;\n        end\n        else begin\n            body <= in;\n        end\n    end\n    \n    assign out = body;\nendmodule\n\n\nmodule BypassNetwork( \n    BypassNetworkIF.BypassNetwork port,\n    ControllerIF.BypassNetwork ctrl\n);\n    function automatic PRegDataPath SelectData( \n    input\n        BypassSelect sel,\n        BypassOperand intEX [ INT_ISSUE_WIDTH ],\n        BypassOperand intWB [ INT_ISSUE_WIDTH ],\n        BypassOperand memMA [ LOAD_ISSUE_WIDTH ],\n        BypassOperand memWB [ LOAD_ISSUE_WIDTH ]\n    );\n        if( sel.stg == BYPASS_STAGE_INT_EX )\n            return intEX[sel.lane.intLane].value;\n        else   if( sel.stg == BYPASS_STAGE_INT_WB )\n            return intWB[sel.lane.intLane].value;\n        else   if( sel.stg == BYPASS_STAGE_MEM_MA )\n            return memMA[sel.lane.memLane].value;\n        else   if( sel.stg == BYPASS_STAGE_MEM_WB )\n            return memWB[sel.lane.memLane].value;\n        else\n            return '0;\n        \n    endfunction \n\n\n    BypassOperand intDst [ INT_ISSUE_WIDTH ];\n    BypassOperand intEX  [ INT_ISSUE_WIDTH ];\n    BypassOperand intWB  [ INT_ISSUE_WIDTH ];\n    BypassOperand memDst [ LOAD_ISSUE_WIDTH ];\n    BypassOperand memMA  [ LOAD_ISSUE_WIDTH ];\n    BypassOperand memWB  [ LOAD_ISSUE_WIDTH ];\n\n    generate \n        for ( genvar i = 0; i < INT_ISSUE_WIDTH; i++ ) begin : stgInt\n            BypassStage stgIntEX( port.clk, port.rst, ctrl.backEnd, intDst[i], intEX[i] );\n            BypassStage stgIntWB( port.clk, port.rst, ctrl.backEnd, intEX[i],  intWB[i] );\n        end\n        \n        for ( genvar i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin : stgMem\n            BypassStage stgMemMA( port.clk, port.rst, ctrl.backEnd, memDst[i], memMA[i] );\n            BypassStage stgMemWB( port.clk, port.rst, ctrl.backEnd, memMA[i],  memWB[i] );\n        end\n    endgenerate\n    \n    always_comb begin\n\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n            intDst[i].value = port.intDstRegDataOut[i];\n            \n            port.intSrcRegDataOutA[i] = SelectData( port.intCtrlIn[i].rA,   intEX, intWB, memMA, memWB );\n            port.intSrcRegDataOutB[i] = SelectData( port.intCtrlIn[i].rB,   intEX, intWB, memMA, memWB );\n        end\n        \n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n            port.complexSrcRegDataOutA[i] = SelectData( port.complexCtrlIn[i].rA,   intEX, intWB, memMA, memWB );\n            port.complexSrcRegDataOutB[i] = SelectData( port.complexCtrlIn[i].rB,   intEX, intWB, memMA, memWB );\n        end\n`endif\n        \n        for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin\n            memDst[i].value = port.memDstRegDataOut[i];\n        end\n            \n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            port.memSrcRegDataOutA[i] = SelectData( port.memCtrlIn[i].rA,   intEX, intWB, memMA, memWB );\n            port.memSrcRegDataOutB[i] = SelectData( port.memCtrlIn[i].rB,   intEX, intWB, memMA, memWB );\n        end\n\n`ifdef RSD_MARCH_FP_PIPE\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n            port.fpSrcRegDataOutA[i] = SelectData( port.fpCtrlIn[i].rA,   intEX, intWB, memMA, memWB );\n            port.fpSrcRegDataOutB[i] = SelectData( port.fpCtrlIn[i].rB,   intEX, intWB, memMA, memWB );\n            port.fpSrcRegDataOutC[i] = SelectData( port.fpCtrlIn[i].rC,   intEX, intWB, memMA, memWB );\n        end\n`endif\n    end\n\nendmodule : BypassNetwork\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- BypassNetworkIF\n//\n\nimport BasicTypes::*;\nimport BypassTypes::*;\n\n\ninterface BypassNetworkIF(input logic clk, rst, rstStart);\n    \n    //\n    // --- Integer Pipeline\n    //\n    \n    // Register read stage\n    PRegNumPath intPhySrcRegNumA [ INT_ISSUE_WIDTH ];\n    PRegNumPath intPhySrcRegNumB [ INT_ISSUE_WIDTH ];\n    PRegNumPath intPhyDstRegNum  [ INT_ISSUE_WIDTH ];\n\n    \n    logic intReadRegA [ INT_ISSUE_WIDTH ];\n    logic intReadRegB [ INT_ISSUE_WIDTH ];\n\n    logic intWriteReg  [ INT_ISSUE_WIDTH ];\n    \n    BypassControll intCtrlOut [ INT_ISSUE_WIDTH ];\n    \n    // Execution stage\n    BypassControll intCtrlIn [ INT_ISSUE_WIDTH ];\n    \n    PRegDataPath intSrcRegDataOutA  [ INT_ISSUE_WIDTH ];\n    PRegDataPath intSrcRegDataOutB  [ INT_ISSUE_WIDTH ];\n\n    PRegDataPath intDstRegDataOut  [ INT_ISSUE_WIDTH ];\n\n    //\n    // --- Complex Integer Pipeline\n    //\n    \n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    // Register read stage\n    PRegNumPath complexPhySrcRegNumA [ COMPLEX_ISSUE_WIDTH ];\n    PRegNumPath complexPhySrcRegNumB [ COMPLEX_ISSUE_WIDTH ];\n    PRegNumPath complexPhyDstRegNum  [ COMPLEX_ISSUE_WIDTH ];\n\n    logic complexReadRegA [ COMPLEX_ISSUE_WIDTH ];\n    logic complexReadRegB [ COMPLEX_ISSUE_WIDTH ];\n\n    logic complexWriteReg  [ COMPLEX_ISSUE_WIDTH ];\n\n    PRegDataPath complexSrcRegDataA [ COMPLEX_ISSUE_WIDTH ];\n    PRegDataPath complexSrcRegDataB [ COMPLEX_ISSUE_WIDTH ];\n\n    BypassControll complexCtrlOut [ COMPLEX_ISSUE_WIDTH ];\n    \n    // Execution stage\n    BypassControll complexCtrlIn [ COMPLEX_ISSUE_WIDTH ];\n    \n    PRegDataPath  complexSrcRegDataOutA [ COMPLEX_ISSUE_WIDTH ];\n    PRegDataPath  complexSrcRegDataOutB [ COMPLEX_ISSUE_WIDTH ];\n\n    PRegDataPath  complexDstRegDataOut  [ COMPLEX_ISSUE_WIDTH ];\n`endif\n\n    //\n    // --- Memory Pipeline\n    //\n    \n    // Register read stage\n    PRegNumPath memPhySrcRegNumA [ MEM_ISSUE_WIDTH ];\n    PRegNumPath memPhySrcRegNumB [ MEM_ISSUE_WIDTH ];\n    PRegNumPath memPhyDstRegNum  [ MEM_ISSUE_WIDTH ];\n    \n    logic memReadRegA [ MEM_ISSUE_WIDTH ];\n    logic memReadRegB [ MEM_ISSUE_WIDTH ];\n\n    logic memWriteReg  [ MEM_ISSUE_WIDTH ];\n    \n    BypassControll memCtrlOut [ MEM_ISSUE_WIDTH ];\n    \n    // Execution stage\n    BypassControll memCtrlIn [ MEM_ISSUE_WIDTH ];\n    \n    PRegDataPath memSrcRegDataOutA  [ MEM_ISSUE_WIDTH ];\n    PRegDataPath memSrcRegDataOutB  [ MEM_ISSUE_WIDTH ];\n    PRegDataPath  memDstRegDataOut  [ MEM_ISSUE_WIDTH ];\n\n    //\n    // --- FP Pipeline\n    //\n    \n`ifdef RSD_MARCH_FP_PIPE\n    // Register read stage\n    PRegNumPath fpPhySrcRegNumA [ FP_ISSUE_WIDTH ];\n    PRegNumPath fpPhySrcRegNumB [ FP_ISSUE_WIDTH ];\n    PRegNumPath fpPhySrcRegNumC [ FP_ISSUE_WIDTH ];\n    PRegNumPath fpPhyDstRegNum  [ FP_ISSUE_WIDTH ];\n\n    logic fpReadRegA [ FP_ISSUE_WIDTH ];\n    logic fpReadRegB [ FP_ISSUE_WIDTH ];\n    logic fpReadRegC [ FP_ISSUE_WIDTH ];\n\n    logic fpWriteReg  [ FP_ISSUE_WIDTH ];\n\n    PRegDataPath fpSrcRegDataA [ FP_ISSUE_WIDTH ];\n    PRegDataPath fpSrcRegDataB [ FP_ISSUE_WIDTH ];\n    PRegDataPath fpSrcRegDataC [ FP_ISSUE_WIDTH ];\n\n    BypassControll fpCtrlOut [ FP_ISSUE_WIDTH ];\n    \n    // Execution stage\n    BypassControll fpCtrlIn [ FP_ISSUE_WIDTH ];\n    \n    PRegDataPath  fpSrcRegDataOutA [ FP_ISSUE_WIDTH ];\n    PRegDataPath  fpSrcRegDataOutB [ FP_ISSUE_WIDTH ];\n    PRegDataPath  fpSrcRegDataOutC [ FP_ISSUE_WIDTH ];\n\n    PRegDataPath  fpDstRegDataOut  [ FP_ISSUE_WIDTH ];\n`endif\n\n    modport BypassController(\n    input\n        clk,\n        rst,\n        intPhySrcRegNumA,\n        intPhySrcRegNumB,\n        intPhyDstRegNum,\n        intReadRegA,\n        intReadRegB,\n        intWriteReg,\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        complexPhySrcRegNumA,\n        complexPhySrcRegNumB,\n        complexPhyDstRegNum,\n        complexReadRegA,\n        complexReadRegB,\n        complexWriteReg,\n`endif\n        memPhySrcRegNumA,\n        memPhySrcRegNumB,\n        memPhyDstRegNum,\n        memReadRegA,\n        memReadRegB,\n        memWriteReg,\n`ifdef RSD_MARCH_FP_PIPE\n        fpPhySrcRegNumA,\n        fpPhySrcRegNumB,\n        fpPhySrcRegNumC,\n        fpPhyDstRegNum,\n        fpReadRegA,\n        fpReadRegB,\n        fpReadRegC,\n        fpWriteReg,\n`endif\n    output\n        intCtrlOut,\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        complexCtrlOut,\n`endif\n        memCtrlOut\n`ifdef RSD_MARCH_FP_PIPE\n        ,\n        fpCtrlOut\n`endif\n    );\n\n    modport BypassNetwork(\n    input\n        clk,\n        rst,\n        intCtrlIn,\n        intDstRegDataOut,\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        complexCtrlIn,\n        complexDstRegDataOut,\n`endif\n        memCtrlIn,\n        memDstRegDataOut,\n`ifdef RSD_MARCH_FP_PIPE\n        fpCtrlIn,\n        fpDstRegDataOut,\n`endif\n    output\n        intSrcRegDataOutA,\n        intSrcRegDataOutB,\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        complexSrcRegDataOutA,\n        complexSrcRegDataOutB,\n`endif\n        memSrcRegDataOutA,\n        memSrcRegDataOutB\n`ifdef RSD_MARCH_FP_PIPE\n        ,\n        fpSrcRegDataOutA,\n        fpSrcRegDataOutB,\n        fpSrcRegDataOutC\n`endif\n    );\n\n    modport IntegerRegisterReadStage(\n    input\n        clk,\n        rst,\n        intCtrlOut,\n    output\n        intPhySrcRegNumA,\n        intPhySrcRegNumB,\n        intPhyDstRegNum,\n        intReadRegA,\n        intReadRegB,\n        intWriteReg\n    );\n    \n    modport IntegerExecutionStage(\n    input\n        intSrcRegDataOutA,\n        intSrcRegDataOutB,\n    output \n        intCtrlIn,\n        intDstRegDataOut\n    );\n    \n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    modport ComplexIntegerRegisterReadStage(\n    input\n        clk,\n        rst,\n        complexCtrlOut,\n    output\n        complexPhySrcRegNumA,\n        complexPhySrcRegNumB,\n        complexPhyDstRegNum,\n        complexReadRegA,\n        complexReadRegB,\n        complexWriteReg\n    );\n    \n    modport ComplexIntegerExecutionStage(\n    input\n        complexSrcRegDataOutA,\n        complexSrcRegDataOutB,\n    output \n        complexCtrlIn,\n        complexDstRegDataOut\n    );\n`endif\n    \n    modport MemoryRegisterReadStage(\n    input\n        clk,\n        rst,\n        memCtrlOut,\n    output\n        memPhySrcRegNumA,\n        memPhySrcRegNumB,\n        memPhyDstRegNum,\n        memReadRegA,\n        memReadRegB,\n        memWriteReg\n    );\n\n    modport MemoryExecutionStage(\n    input\n        memSrcRegDataOutA,\n        memSrcRegDataOutB,\n    output \n        memCtrlIn\n    );\n\n    modport MemoryAccessStage(\n    output \n        memDstRegDataOut\n    );\n\n`ifdef RSD_MARCH_FP_PIPE\n    modport FPRegisterReadStage(\n    input\n        clk,\n        rst,\n        fpCtrlOut,\n    output\n        fpPhySrcRegNumA,\n        fpPhySrcRegNumB,\n        fpPhySrcRegNumC,\n        fpPhyDstRegNum,\n        fpReadRegA,\n        fpReadRegB,\n        fpReadRegC,\n        fpWriteReg\n    );\n    \n    modport FPExecutionStage(\n    input\n        fpSrcRegDataOutA,\n        fpSrcRegDataOutB,\n        fpSrcRegDataOutC,\n    output \n        fpCtrlIn,\n        fpDstRegDataOut\n    );\n`endif\n\nendinterface : BypassNetworkIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n// \n// --- Types related to bypass network.\n//\n\npackage BypassTypes;\n\nimport BasicTypes::*;\n\ntypedef enum logic unsigned [1:0]   // enum BypassSelect\n{\n    BYPASS_STAGE_INT_EX = 0,\n    BYPASS_STAGE_INT_WB = 1,\n    BYPASS_STAGE_MEM_MA = 2,\n    BYPASS_STAGE_MEM_WB = 3\n} BypassSelectStage;\n\n\ntypedef struct packed {\n    // TODO: union\u3067\u5b9f\u88c5\n    IntIssueLaneIndexPath intLane;\n    ComplexIssueLaneIndexPath complexLane;\n    MemIssueLaneIndexPath memLane;\n`ifdef RSD_MARCH_FP_PIPE\n    FPIssueLaneIndexPath fpLane;\n`endif\n} BypassLane;\n\ntypedef struct packed {\n    logic valid; // \u30d0\u30a4\u30d1\u30b9\u3059\u308b\u304b\u5426\u304b\n    BypassSelectStage stg;\n    BypassLane lane;\n} BypassSelect;\n\ntypedef struct packed {\n    BypassSelect rA;\n    BypassSelect rB;\n`ifdef RSD_MARCH_FP_PIPE\n    BypassSelect rC;\n`endif\n} BypassControll;\n\nendpackage"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Cache flush management unit\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport CacheSystemTypes::*;\nimport OpFormatTypes::*;\nimport MemoryMapTypes::*;\nimport LoadStoreUnitTypes::*;\n\nmodule CacheFlushManager(\n    CacheFlushManagerIF.CacheFlushManager port,\n    CacheSystemIF.CacheFlushManager cacheSystem\n);\n\n    typedef enum logic[1:0]\n    {\n        PHASE_FREE          = 0,  // This unit is free\n        PHASE_SEND_REQUEST  = 1,  // This unit sends flush requests to caches\n        PHASE_PROCESSING    = 2,  // This unit is waiting for completion signals from caches\n        PHASE_WAITING       = 3   // Wait for issuing ifence from replayqueue\n    } CacheFlushPhase;\n\n    // CacheFlushManager <-> ICache, DCache\n    logic icFlushReq, dcFlushReq;\n\n    CacheFlushPhase regPhase, nextPhase;\n    logic regIcFlushComplete, nextIcFlushComplete;\n    logic regDcFlushComplete, nextDcFlushComplete;\n\n    // CacheFlushManager <-> MemExecStage, ReplayQueue\n    logic cacheFlushComplete;\n\n    always_ff @( posedge port.clk ) begin\n        if ( port.rst ) begin\n            regPhase <= PHASE_FREE;\n        end\n        else begin\n            regPhase <= nextPhase;\n        end\n    end\n\n    always_comb begin\n        nextPhase = regPhase;\n        nextIcFlushComplete = regIcFlushComplete;\n        nextDcFlushComplete = regDcFlushComplete;\n\n        // to ICache, DCache\n        icFlushReq = FALSE;\n        dcFlushReq = FALSE;\n\n        // to MemExecStage, ReplayQUeue\n        cacheFlushComplete = FALSE;\n\n        case (regPhase)\n        default: begin\n            nextPhase = PHASE_FREE;\n        end\n        PHASE_FREE: begin\n            if (port.cacheFlushReq) begin\n                nextPhase = PHASE_SEND_REQUEST;\n            end\n        end\n        PHASE_SEND_REQUEST: begin\n            if (cacheSystem.icFlushReqAck && cacheSystem.dcFlushReqAck) begin\n                icFlushReq = TRUE;\n                dcFlushReq = TRUE;\n                nextIcFlushComplete = FALSE;\n                nextDcFlushComplete = FALSE;\n                nextPhase = PHASE_PROCESSING;\n            end\n        end\n        PHASE_PROCESSING: begin\n            if (cacheSystem.icFlushComplete) begin\n                nextIcFlushComplete = TRUE;\n            end\n            if (cacheSystem.dcFlushComplete) begin\n                nextDcFlushComplete = TRUE;\n            end\n\n            if ((nextIcFlushComplete || regIcFlushComplete) &&\n                (nextDcFlushComplete || regDcFlushComplete)) begin\n                nextPhase = PHASE_WAITING;\n            end\n        end\n        PHASE_WAITING: begin\n            cacheFlushComplete = TRUE;\n            if (port.cacheFlushReq) begin\n                nextPhase = PHASE_FREE;\n            end\n        end\n        endcase\n\n        // to ICache, DCache\n        cacheSystem.icFlushReq = icFlushReq;\n        cacheSystem.dcFlushReq = dcFlushReq;\n        cacheSystem.flushComplete = cacheFlushComplete;\n\n        // to MemExecStage, ReplayQUeue\n        port.cacheFlushComplete = cacheFlushComplete;\n    end\n\n    // Cache flush state\n    always_ff @( posedge port.clk ) begin\n        if ( port.rst ) begin\n            regIcFlushComplete <= FALSE;\n            regDcFlushComplete <= FALSE;\n        end\n        else begin\n            regIcFlushComplete <= nextIcFlushComplete;\n            regDcFlushComplete <= nextDcFlushComplete;\n        end\n    end\n\n\nendmodule : CacheFlushManager"}
{"text": "\n\n// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// The interface of a cache flush management unit.\n//\n\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport CacheSystemTypes::*;\nimport OpFormatTypes::*;\nimport LoadStoreUnitTypes::*;\nimport MemoryMapTypes::*;\n\ninterface CacheFlushManagerIF( input logic clk, rst );\n\n    // CacheFlushManagement\n    logic cacheFlushReq;\n    logic cacheFlushComplete;\n\n    modport CacheFlushManager(\n    input\n        clk,\n        rst,\n        cacheFlushReq,\n    output\n        cacheFlushComplete\n    );\n\n    modport MemoryExecutionStage(\n    input\n        cacheFlushComplete,\n    output\n        cacheFlushReq\n    );\n\n    modport ReplayQueue(\n    input\n        cacheFlushComplete\n    );\n\nendinterface : CacheFlushManagerIF\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- MemoryIF\n//\n\nimport BasicTypes::*;\nimport CacheSystemTypes::*;\n\ninterface CacheSystemIF( input logic clk, rst );\n    \n    // ICache\n    MemReadAccessReq icMemAccessReq;\n    MemAccessReqAck icMemAccessReqAck;\n    MemAccessResult icMemAccessResult;\n    \n    // DCache\n    MemAccessReq dcMemAccessReq;\n    MemAccessReqAck dcMemAccessReqAck;\n    MemAccessResult dcMemAccessResult;\n    MemAccessResponse dcMemAccessResponse;\n\n    // CacheFlushManager\n    logic icFlushReqAck;\n    logic icFlushComplete;\n    logic icFlushReq;\n    logic dcFlushReqAck;\n    logic dcFlushComplete;\n    logic dcFlushReq;\n    logic flushComplete;\n    \n    \n    modport ICache(\n    input\n        clk,\n        rst,\n        icMemAccessResult,\n        icMemAccessReqAck,\n        icFlushReq,\n        flushComplete,\n    output\n        icMemAccessReq,\n        icFlushReqAck,\n        icFlushComplete\n    );\n    \n    modport DCache(\n    input\n        clk,\n        rst,\n        dcMemAccessResult,\n        dcMemAccessReqAck,\n        dcMemAccessResponse,\n        dcFlushReq,\n        flushComplete,\n    output\n        dcMemAccessReq,\n        dcFlushReqAck,\n        dcFlushComplete\n    );\n\n    modport MemoryAccessController(\n    input\n        clk,\n        rst,\n        icMemAccessReq,\n        dcMemAccessReq,\n    output\n        icMemAccessResult,\n        dcMemAccessResult,\n        icMemAccessReqAck,\n        dcMemAccessReqAck,\n        dcMemAccessResponse\n    );\n\n    modport CacheFlushManager(\n    input\n        icFlushReqAck,\n        icFlushComplete,\n        dcFlushReqAck,\n        dcFlushComplete,\n    output\n        icFlushReq,\n        dcFlushReq,\n        flushComplete\n    );\n    \nendinterface : CacheSystemIF\n\n"}
{"text": "// Copyright 2020- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n\npackage CacheSystemTypes;\n\n    import MicroArchConf::*;\n    import BasicTypes::*;\n    import MemoryMapTypes::*;\n    import ActiveListIndexTypes::*;\n\n    //\n    // --- DCache\n    //\n\n    // Main cache parameters.\n    // The remaining cache parameters must be fixed or calculated by the following\n    // parameters.\n    localparam DCACHE_WAY_NUM = CONF_DCACHE_WAY_NUM;                 // The number of ways in a single set\n    localparam DCACHE_INDEX_BIT_WIDTH = CONF_DCACHE_INDEX_BIT_WIDTH; // The number of index bits\n    localparam DCACHE_LINE_BYTE_NUM = CONF_DCACHE_LINE_BYTE_NUM;     // Line size\n    localparam MSHR_NUM = CONF_DCACHE_MSHR_NUM;                      // The number of MSHR entries.\n\n    // Index bits\n    localparam DCACHE_INDEX_NUM = 1 << DCACHE_INDEX_BIT_WIDTH;\n    typedef logic [DCACHE_INDEX_BIT_WIDTH-1:0] DCacheIndexPath;\n\n    // The number of the ports of tag/data array.\n    localparam DCACHE_ARRAY_PORT_NUM = 2;    // This parameter must be fixed to 2 because block ram has 2 ports.\n    localparam DCACHE_ARRAY_PORT_NUM_BIT_WIDTH = $clog2(DCACHE_ARRAY_PORT_NUM);\n    typedef logic [DCACHE_ARRAY_PORT_NUM_BIT_WIDTH-1 : 0] DCacheArrayPortIndex;\n\n    // Line size\n    localparam DCACHE_LINE_BYTE_NUM_BIT_WIDTH = $clog2(DCACHE_LINE_BYTE_NUM);\n    localparam DCACHE_LINE_BIT_WIDTH = DCACHE_LINE_BYTE_NUM * 8;\n    typedef logic [DCACHE_LINE_BIT_WIDTH-1:0] DCacheLinePath;\n    typedef logic [DCACHE_LINE_BYTE_NUM-1:0] DCacheByteEnablePath;\n\n    // Tag bits\n    localparam DCACHE_TAG_BIT_WIDTH = \n        PHY_ADDR_WIDTH - DCACHE_INDEX_BIT_WIDTH - DCACHE_LINE_BYTE_NUM_BIT_WIDTH;\n    typedef logic [DCACHE_TAG_BIT_WIDTH-1:0] DCacheTagPath;\n\n    // Tag+Index bits\n    typedef logic [PHY_ADDR_WIDTH-DCACHE_LINE_BYTE_NUM_BIT_WIDTH-1:0] DCacheLineAddr;\n\n    typedef struct packed {\n        logic valid;\n        DCacheTagPath tag;\n    } DCacheTagValidPath;\n\n    // A signal path for a way number\n    localparam DCACHE_WAY_BIT_NUM = (DCACHE_WAY_NUM != 1) ? $clog2(DCACHE_WAY_NUM) : 1;\n    typedef logic [DCACHE_WAY_BIT_NUM-1:0] DCacheWayPath;\n\n    // Tree LRU information\n    // Each bit represents a node in a binary tree\n    // (DCACHE_WAY_NUM - 1) bits are necessary. \n    // DCACHE_TREE_LRU_STATE_BIT_NUM = sum(1+2+4...W/2) = W-1\n    localparam DCACHE_TREE_LRU_STATE_BIT_NUM = (DCACHE_WAY_NUM - 1) > 0 ? (DCACHE_WAY_NUM - 1) : 1;\n    typedef logic [DCACHE_TREE_LRU_STATE_BIT_NUM-1:0] DCacheTreeLRU_StatePath;\n\n    // Subset of index for MSHR identifier in ReplayQueue\n    // This value MUST be less than or equal to DCACHE_INDEX_BIT_WIDTH.\n    localparam DCACHE_INDEX_SUBSET_BIT_WIDTH = DCACHE_INDEX_BIT_WIDTH;\n    typedef logic [DCACHE_INDEX_SUBSET_BIT_WIDTH-1:0] DCacheIndexSubsetPath;\n\n    // Memory Access Serial\n    // \u540c\u6642\u306boutstanding\u53ef\u80fd\u306a\u30ea\u30fc\u30c9\u30c8\u30e9\u30f3\u30b6\u30af\u30b7\u30e7\u30f3\u306e\u6700\u5927\u6570\u3092\u6c7a\u3081\u308b\n    // D-Cache\u304b\u3089\u306e\u8981\u6c42\u306e\u6700\u5927\u6570\u306fMSHR_NUM\uff0cI-Cache\u304b\u3089\u306e\u8981\u6c42\u306f1\uff0c\u6700\u5927\u8981\u6c42\u6570\u306fMSHR_NUM+1\u3068\u306a\u308b\n    // \u4eca\u5f8cI-Cache\u304b\u3089\u306e\u540c\u6642\u767a\u884c\u53ef\u80fd\u306a\u8981\u6c42\u6570\u3092\u5897\u3084\u3059\u306e\u3067\u3042\u308c\u3070\u3053\u3053\u3092\u5909\u66f4\n    // NOTE: if you modify this value, you need to modify \n    // MEMORY_AXI4_READ_ID_WIDTH in SysDeps/XilinxMacros.vh\n    localparam MEM_ACCESS_SERIAL_BIT_SIZE = $clog2( MSHR_NUM+1 );\n    typedef logic [MEM_ACCESS_SERIAL_BIT_SIZE-1 : 0] MemAccessSerial;\n\n    // \u540c\u6642\u306boutstanding\u53ef\u80fd\u306a\u30e9\u30a4\u30c8\u30c8\u30e9\u30f3\u30b6\u30af\u30b7\u30e7\u30f3\u306e\u6700\u5927\u6570\u3092\u6c7a\u3081\u308b\n    // D-Cache\u304b\u3089\u306e\u8981\u6c42\u306e\u6700\u5927\u6570\u306fMSHR_NUM\u306a\u306e\u3067\uff0c\u6700\u5927\u8981\u6c42\u6570\u3082MSHR_NUM\u3068\u306a\u308b\n    // NOTE: if you modify this value, you need to modify \n    // MEMORY_AXI4_WRITE_ID_WIDTH in SysDeps/XilinxMacros.vh\n    localparam MEM_WRITE_SERIAL_BIT_SIZE = $clog2( MSHR_NUM );\n    typedef logic [MEM_WRITE_SERIAL_BIT_SIZE-1 : 0] MemWriteSerial;\n\n    //\n    // Phase of DCache\n    //\n    typedef enum logic [1:0]\n    {\n        DCACHE_PHASE_NORMAL = 0,                // DCache is operating normally.\n        DCACHE_PHASE_FLUSH_PROCESSING = 1,      // DCache is flushing.\n        DCACHE_PHASE_FLUSH_COMPLETE = 2         // DCache flush is completed, waiting for a completion signal from a manager.\n    } DCachePhase;\n\n    //\n    // MSHR\n    //\n    localparam MSHR_NUM_BIT_WIDTH = $clog2(MSHR_NUM);\n    typedef logic [MSHR_NUM_BIT_WIDTH-1:0] MSHR_IndexPath;\n    typedef logic [MSHR_NUM_BIT_WIDTH:0] MSHR_CountPath;\n\n    typedef enum logic [4:0]\n    {\n        MSHR_PHASE_INVALID = 0,                   // This entry is invalid\n\n        // For flush\n        MSHR_PHASE_FLUSH_VICTIM_REQEUST = 1,        //\n        MSHR_PHASE_FLUSH_VICTIM_RECEIVE_TAG   = 2,  //\n        MSHR_PHASE_FLUSH_VICTIM_RECEIVE_DATA  = 3,  // Receive dirty data.\n        MSHR_PHASE_FLUSH_VICTIM_WRITE_TO_MEM  = 4,  // Victim is written to a main memory.\n        MSHR_PHASE_FLUSH_VICTIM_WRITE_COMPLETE = 5, // Wait until victim writeback is complete.\n        MSHR_PHASE_FLUSH_CHECK = 6,                 // Check if flush is completed.\n\n        // Victim is read from the cache.\n        MSHR_PHASE_VICTIM_REQUEST       = 7,        //\n        MSHR_PHASE_VICTIM_RECEIVE_TAG   = 8,        //\n        MSHR_PHASE_VICTIM_RECEIVE_DATA  = 9,        // Receive dirty data.\n        MSHR_PHASE_VICTIM_WRITE_TO_MEM  = 10,       // Victim is written to a main memory.\n        MSHR_PHASE_VICTIM_WRITE_COMPLETE = 11,      // Wait until victim writeback is complete.\n\n        MSHR_PHASE_MISS_MERGE_STORE_DATA = 12,      // Merge the allocator store's data and the fetched line.\n\n        MSHR_PHASE_MISS_READ_MEM_REQUEST = 13,      // Read from a main memory to a cache.\n        MSHR_PHASE_MISS_READ_MEM_RECEIVE = 14,      // Read from a main memory to a cache.\n        MSHR_PHASE_UNCACHABLE_WRITE_TO_MEM = 15,    // (Uncachable store) Write data to a main memory.\n        MSHR_PHASE_UNCACHABLE_WRITE_COMPLETE = 16,  // (Uncachable store) Write data to a main memory.\n        // MSHR_PHASE_MISS_WRITE_CACHE_REQUEST and MSHR_PHASE_MISS_HANDLING_COMPLETE \n        // must be the highest numbers in the following order.\n        MSHR_PHASE_MISS_WRITE_CACHE_REQUEST = 17,   // (Cachable load/store) Write data to a cache.\n        MSHR_PHASE_MISS_HANDLING_COMPLETE = 18\n\n    } MSHR_Phase;\n\n    typedef struct packed   // MissStatusHandlingRegister;\n    {\n        logic valid;\n\n        MSHR_Phase phase;\n\n        logic victimDirty;\n        logic victimValid;\n        logic victimReceived;\n        PhyAddrPath victimAddr;\n\n        // \u30bf\u30b0\u30a2\u30ec\u30a4\u304b\u3089\u30bf\u30b0\u304c\u3088\u3081\u305f\u30bf\u30a4\u30df\u30f3\u30b0\u3067\u306f\u307e\u3060\u8ffd\u3044\u51fa\u3059\u30a6\u30a7\u30a4\u306e\u78ba\u5b9a\u304c\u3067\u304d\u306a\u3044\u305f\u3081\n        // \u5168\u3066\u6301\u3063\u3066\u304a\u304f\n        DCacheTagPath   [DCACHE_WAY_NUM-1 : 0] tagDataOut;\n        logic           [DCACHE_WAY_NUM-1 : 0] tagValidOut;\n\n        logic newValid;\n        PhyAddrPath newAddr;\n\n        MemAccessSerial memSerial; // Read request serial\n        MemWriteSerial memWSerial; // Write request serial\n\n        // Line data is shared by \"new\" and \"victim\".\n        DCacheLinePath line;\n\n        // An MSHR entry can be invalid when\n        // its allocator is load and has bypassed data.\n        logic canBeInvalid;\n\n        // A load that allocates n MSHR entry is flushed.\n        logic isAllocatorLoadFlushed;\n\n        // An MSHR entry which has been allocated by store must integrate the store's data into a fetched cache line.\n        logic isAllocatedByStore;\n\n        // TRUE if this is uncachable access.\n        logic isUncachable;\n\n        // An MSHR entry which is indicating the way to be evicted in DCache.\n        DCacheWayPath evictWay;\n\n        // For flush\n        DCacheIndexPath flushIndex;\n\n        // AL Ptr info to release MSHR entry when allocator load is flushed\n         ActiveListIndexPath activeListPtr;\n    } MissStatusHandlingRegister;\n\n    typedef struct packed   // DCachePortMultiplexerIn\n    {\n        DCacheIndexPath indexIn;\n\n        logic           tagWE;\n        DCacheTagPath   tagDataIn;\n        logic           tagValidIn;\n\n        logic                   dataWE_OnTagHit;\n        logic                   dataWE;\n        DCacheLinePath          dataDataIn;\n        DCacheByteEnablePath    dataByteWE;\n        logic                   dataDirtyIn;\n\n        // To notify DCache which way will be evicted.\n        DCacheWayPath   evictWay;\n\n        // If this signal is asserted, this request is one from MSHR to evict a line.\n        logic           isVictimEviction;\n        // For flush\n        logic           isFlushReq;\n    } DCachePortMultiplexerIn;\n\n    typedef struct packed   // DCachePortMultiplexerTagOut\n    {\n        DCacheTagPath   [DCACHE_WAY_NUM-1 : 0] tagDataOut;\n        logic           [DCACHE_WAY_NUM-1 : 0] tagValidOut;\n        logic           tagHit;\n\n        logic           mshrConflict;\n        logic           mshrAddrHit;\n        MSHR_IndexPath  mshrAddrHitMSHRID;\n        logic           mshrReadHit;\n        DCacheLinePath  mshrReadData;\n    } DCachePortMultiplexerTagOut;\n\n    typedef struct packed   // DCachePortMultiplexerDataOut\n    {\n        DCacheLinePath  dataDataOut;\n        logic           dataDirtyOut;\n        // Data Array \u8aad\u307f\u51fa\u3057\u3068\u540c\u3058\u30bf\u30a4\u30df\u30f3\u30b0\u3067\u7f6e\u304d\u63db\u3048\u5bfe\u8c61\u304c\u53d6\u308c\u308b\u306e\u3067\n        // \u30de\u30eb\u30c1\u30d7\u30ec\u30af\u30b5\u3067\u9078\u629e\u3059\u308b\u305f\u3081\u306b\u3053\u3053\u3067\u51fa\u3057\u3066\u304a\u304f\n        DCacheTreeLRU_StatePath replDataOut;\n    } DCachePortMultiplexerDataOut;\n\n    typedef struct packed   // MemoryPortMultiplexerIn\n    {\n        PhyAddrPath addr;\n        DCacheLinePath data;\n        logic we;\n    } MemoryPortMultiplexerIn;\n\n    typedef struct packed   // MemoryPortMultiplexerOut\n    {\n        logic ack;              // Request is accepted or not.\n        MemAccessSerial serial; // Request serial\n        MemWriteSerial wserial; // Request serial\n    } MemoryPortMultiplexerOut;\n\n\n    // ports\n    // Read: for load[LOAD_ISSUE_WIDTH], for store(commit), read victim[MSHR_NUM]\n    // Write: WriteNew[MSHR_NUM];\n    localparam DCACHE_LSU_READ_PORT_NUM = LOAD_ISSUE_WIDTH;\n    localparam DCACHE_LSU_WRITE_PORT_NUM = 1;       // +1 for store commit.\n    localparam DCACHE_LSU_PORT_NUM = DCACHE_LSU_READ_PORT_NUM + DCACHE_LSU_WRITE_PORT_NUM;\n\n    localparam DCACHE_LSU_READ_PORT_BEGIN  = 0;\n    localparam DCACHE_LSU_WRITE_PORT_BEGIN = DCACHE_LSU_READ_PORT_NUM;\n\n    localparam DCACHE_MUX_PORT_NUM = DCACHE_LSU_PORT_NUM + MSHR_NUM;\n\n    typedef logic [$clog2(DCACHE_MUX_PORT_NUM)-1:0] DCacheMuxPortIndexPath;\n\n\n    //\n    // --- ICache\n    //\n\n    // Main cache parameters.\n    // The remaining cache parameters must be fixed or calculated by the following\n    // parameters.\n    localparam ICACHE_WAY_NUM = CONF_ICACHE_WAY_NUM;           // Way Num\n    localparam ICACHE_INDEX_BIT_WIDTH = CONF_ICACHE_INDEX_BIT_WIDTH;   // The number of index bits\n    localparam ICACHE_LINE_BYTE_NUM = CONF_ICACHE_LINE_BYTE_NUM;    // Line size\n\n    // Index bits\n    localparam ICACHE_INDEX_NUM = 1 << ICACHE_INDEX_BIT_WIDTH;\n    typedef logic [ICACHE_INDEX_BIT_WIDTH-1:0] ICacheIndexPath;\n\n    // Line size\n    localparam ICACHE_LINE_BYTE_NUM_BIT_WIDTH = $clog2(ICACHE_LINE_BYTE_NUM);\n    localparam ICACHE_LINE_BIT_WIDTH = ICACHE_LINE_BYTE_NUM * 8;\n    typedef logic [ICACHE_LINE_BIT_WIDTH-1:0] ICacheLinePath;\n\n    // Line as insn list\n    localparam ICACHE_LINE_INSN_NUM = ICACHE_LINE_BYTE_NUM / INSN_BYTE_WIDTH;\n    typedef logic [$clog2(ICACHE_LINE_INSN_NUM)-1:0] ICacheLineInsnIndexPath;\n    typedef logic [$clog2(ICACHE_LINE_INSN_NUM)  :0] ICacheLineInsnCountPath;\n    typedef InsnPath [ICACHE_LINE_INSN_NUM-1:0] ICacheLineInsnPath;\n\n    // Tag bits\n    localparam ICACHE_TAG_BIT_WIDTH = \n        PHY_ADDR_WIDTH - ICACHE_INDEX_BIT_WIDTH - ICACHE_LINE_BYTE_NUM_BIT_WIDTH;\n    typedef logic [ICACHE_TAG_BIT_WIDTH-1:0] ICacheTagPath;\n\n    // Tag+Index bits\n    typedef logic [PHY_ADDR_WIDTH - ICACHE_LINE_BYTE_NUM_BIT_WIDTH - 1:0] ICacheLineAddr;\n\n    typedef struct packed {\n        logic valid;\n        ICacheTagPath tag;\n    } ICacheTagValidPath;\n\n    // Way bits\n    typedef logic [$clog2(ICACHE_WAY_NUM)-1:0] ICacheWayPath;\n\n    // NRU Access state bits\n    // (N-way NRU -> N bits)\n    // These bits correspond to the cache way:\n    //   if bit[way] == 1 then the way is referenced recently\n    typedef logic [ICACHE_WAY_NUM-1:0] NRUAccessStatePath;\n\n    //\n    // --- Memory Access\n    //\n    typedef struct packed {\n        logic ack;              // Request is accepted or not.\n        MemAccessSerial serial; // Read request serial\n        MemWriteSerial wserial; // Write request serial\n    } MemAccessReqAck;\n\n    typedef struct packed {\n        logic valid;\n        logic we;\n        PhyAddrPath addr;\n        DCacheLinePath data;\n    } MemAccessReq;\n\n    typedef struct packed {\n        logic valid;\n        PhyAddrPath addr;\n    } MemReadAccessReq;\n\n    typedef struct packed {\n        logic valid;\n        MemAccessSerial serial;\n        DCacheLinePath data;\n    } MemAccessResult;\n\n    typedef struct packed {\n        logic valid;\n        MemWriteSerial serial;\n    } MemAccessResponse;\n\nendpackage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Commit stage\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport PipelineTypes::*;\nimport RenameLogicTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport DebugTypes::*;\nimport FetchUnitTypes::*;\n\n// \u5b9f\u884c\u304c\u7d42\u308f\u3063\u3066Insn\u306e\u7bc4\u56f2\u3092\u8abf\u3079\u3001\n// \u305d\u308c\u304c\u30a2\u30af\u30c6\u30a3\u30d6\u30ea\u30b9\u30c8\u306e\u5148\u982d\u304b\u3089op\u4f55\u500b\u5206\u306b\u76f8\u5f53\u3059\u308b\u304b\u3092\u8fd4\u3059\nfunction automatic void GetFinishedInsnRange(\n    output CommitLaneCountPath finishedInsnRange,\n    input  CommitLaneCountPath finishedOpNum,    // the number of ops in an active list.\n    input  ExecutionState      execState[COMMIT_WIDTH], // the execution state of the head ops on an active list.\n    input  logic               last[COMMIT_WIDTH]\n);\n    finishedInsnRange = 0;\n    for (int i = COMMIT_WIDTH - 1; i >= 0; i--) begin\n        if (i < finishedOpNum && last[i]) begin\n            finishedInsnRange = i + 1;\n            break;\n        end\n    end\nendfunction\n\n// \u5b9f\u884c\u304c\u7d42\u308f\u3063\u305fop\u306e\u6570\u3092\u51fa\u529b\u3002\u6700\u5927\u3067COMMIT_WIDTH\nfunction automatic void GetFinishedOpNum(\n    output CommitLaneCountPath finishedOpNum,\n    input  ActiveListCountPath activeListCount,\n    input  ExecutionState      execState[COMMIT_WIDTH] // the execution state of the head ops on an active list.\n);\n    finishedOpNum = 0;\n    for (int i = 0; i < COMMIT_WIDTH; i++) begin\n        if (i < activeListCount && execState[i] != EXEC_STATE_NOT_FINISHED)\n            finishedOpNum = i + 1;\n        else\n            break;\n    end\nendfunction\n\n// \u305d\u306eInsn\u3068\u6b21\u306eInsn\u306e\u6700\u521d\u306e\u30de\u30a4\u30af\u30ed\u547d\u4ee4\u3092\u6307\u3059\u30dd\u30a4\u30f3\u30bf\u3092\u5f97\u308b\nfunction automatic void GetInsnPtr(\n    output CommitLaneIndexPath headOfThisInsn[COMMIT_WIDTH],\n    output CommitLaneIndexPath tailOfThisInsn[COMMIT_WIDTH],\n    input  logic        last [COMMIT_WIDTH]\n);\n    for (int i = 0; i < COMMIT_WIDTH; i++) begin\n        headOfThisInsn[i] = 0;\n        for (int j = i - 1; 0 <= j; j--) begin\n            if (last[j]) begin\n                headOfThisInsn[i] = j + 1;\n                break;\n            end\n        end\n\n        tailOfThisInsn[i] = COMMIT_WIDTH-1;\n        for (int j = i; j < COMMIT_WIDTH; j++) begin\n            if (last[j]) begin\n                tailOfThisInsn[i] = j;\n                break;\n            end\n        end\n    end\nendfunction\n\n// Decide which ops are committed.\nfunction automatic void DecideCommit(\n    output logic commit[COMMIT_WIDTH],         // Whether to commit or not\n    output logic toRecoveryPhase,              // Misprediction is detected and recover the system.\n    output CommitLaneIndexPath recoveredIndex, // The index of mis-predicted op.\n    output RefetchType refetchType,            // Where to refetch from.\n    output ExecutionState recoveryCause,       // Why recovery is caused\n    input logic startCommit,                      // In commit phase or not.\n    input ActiveListCountPath activeListCount,    // the number of ops in an active list.\n    input ExecutionState execState[COMMIT_WIDTH], // the execution state of the head ops on an active list.\n    input logic isBranch [COMMIT_WIDTH],          // Whether the op is BR or RIJ\n    input logic isStore [COMMIT_WIDTH],          // Whether the op is store\n    input logic last[COMMIT_WIDTH],      // Whether the op is last of the insn or not\n    input logic unableToStartRecovery    // Whether to start recovery\n);\n\n\n\n    CommitLaneIndexPath headOfThisInsn[COMMIT_WIDTH];\n    CommitLaneIndexPath tailOfThisInsn[COMMIT_WIDTH];\n\n    logic recovery[COMMIT_WIDTH];\n    CommitLaneIndexPath recoveryPoint[COMMIT_WIDTH];\n    logic recoveryTrigger;\n    CommitLaneCountPath recoveryStart;\n\n    // \u5b9f\u884c\u7d42\u4e86\u3057\u3001\u30b3\u30df\u30c3\u30c8\u53ef\u80fd\u306a\u30de\u30a4\u30af\u30ed\u547d\u4ee4\u306e\u6570\n    CommitLaneCountPath finishedOpNum;\n\n    // \u3059\u3079\u3066\u306e\u30de\u30a4\u30af\u30ed\u547d\u4ee4\u304c\u7d42\u4e86\u3057\u305fInstruction\u306b\u5c5e\u3059\u308b\u30de\u30a4\u30af\u30ed\u547d\u4ee4\u306e\u6570\u306e\u5408\u8a08\u3002\n    // \u5b9f\u884c\u7d42\u4e86\u3057\u305f\u30de\u30a4\u30af\u30ed\u547d\u4ee4\u306f\u3001Instruction\u5358\u4f4d\u3067\u30b3\u30df\u30c3\u30c8\u3055\u308c\u308b\u305f\u3081\u3001\n    // \u3053\u308c\u3092\u8a08\u7b97\u3057\u3066\u304a\u304f\u3053\u3068\u304c\u5fc5\u8981\u3068\u306a\u308b\u3002\n    CommitLaneCountPath finishedInsnRange;\n\n    RefetchType opRefetchType[COMMIT_WIDTH]; // RefetchType of each lane.\n\n    GetInsnPtr(headOfThisInsn, tailOfThisInsn, last);\n\n    GetFinishedOpNum(finishedOpNum, activeListCount, execState);\n\n    GetFinishedInsnRange(finishedInsnRange, finishedOpNum, execState, last);\n\n    for (int i = 0; i < COMMIT_WIDTH; i++) begin\n        if (execState[i] == EXEC_STATE_REFETCH_NEXT) begin\n            recovery[i] = TRUE;\n            recoveryPoint[i] = tailOfThisInsn[i];\n            opRefetchType[i] = (\n                isBranch[i] ?   REFETCH_TYPE_BRANCH_TARGET : \n                isStore[i]  ?   REFETCH_TYPE_STORE_NEXT_PC :\n                                REFETCH_TYPE_NEXT_PC\n            );\n        end\n        else if (execState[i] inside {\n            EXEC_STATE_REFETCH_THIS,\n            EXEC_STATE_STORE_LOAD_FORWARDING_MISS\n        }) begin\n            recovery[i] = TRUE;\n            recoveryPoint[i] = headOfThisInsn[i];\n            opRefetchType[i] = REFETCH_TYPE_THIS_PC;\n        end\n        else if (execState[i] inside{\n            EXEC_STATE_TRAP_ECALL, \n            EXEC_STATE_TRAP_EBREAK, \n            EXEC_STATE_TRAP_MRET,\n            EXEC_STATE_FAULT_INSN_MISALIGNED\n        }) begin\n            recovery[i] = TRUE;\n            recoveryPoint[i] = tailOfThisInsn[i];\n            opRefetchType[i] = REFETCH_TYPE_NEXT_PC_TO_CSR_TARGET;\n        end\n        else if (execState[i] inside{\n            EXEC_STATE_FAULT_LOAD_MISALIGNED,\n            EXEC_STATE_FAULT_LOAD_VIOLATION,\n            EXEC_STATE_FAULT_STORE_MISALIGNED,\n            EXEC_STATE_FAULT_STORE_VIOLATION,\n            EXEC_STATE_FAULT_INSN_ILLEGAL,\n            EXEC_STATE_FAULT_INSN_VIOLATION\n        }) begin\n            recovery[i] = TRUE;\n            recoveryPoint[i] = headOfThisInsn[i];\n            opRefetchType[i] = REFETCH_TYPE_THIS_PC_TO_CSR_TARGET;\n        end\n        else begin\n            // Set dummy values\n            recovery[i] = FALSE;\n            recoveryPoint[i] = 0;\n            opRefetchType[i] = REFETCH_TYPE_THIS_PC;\n        end\n    end\n\n    recoveryTrigger = FALSE;\n    recoveredIndex = 0;\n    recoveryStart = COMMIT_WIDTH; // max value\n    refetchType = REFETCH_TYPE_THIS_PC; // dummy value\n    recoveryCause = EXEC_STATE_SUCCESS;\n    for (int i = 0; i < COMMIT_WIDTH; i++) begin\n        if (i < finishedInsnRange) begin\n            if (recovery[i] && recoveryPoint[i] < recoveryStart) begin\n                recoveryTrigger = TRUE;\n                recoveredIndex = i;\n                recoveryStart = recoveryPoint[i];\n                refetchType = opRefetchType[i];\n                recoveryCause = execState[i];\n            end\n        end\n    end\n\n    toRecoveryPhase = (startCommit && recoveryTrigger && !unableToStartRecovery ? TRUE : FALSE);\n\n    for (int i = 0; i < COMMIT_WIDTH; i++) begin\n        if (startCommit) begin\n            if (recoveryTrigger) begin\n                if (i < recoveryStart) begin\n                    commit[i] = TRUE;\n                end\n                else if (i == recoveryStart) begin\n                    commit[i] =\n                        ( ((execState[i] inside {\n                            EXEC_STATE_REFETCH_THIS,\n                            EXEC_STATE_STORE_LOAD_FORWARDING_MISS,\n                            EXEC_STATE_FAULT_LOAD_MISALIGNED,\n                            EXEC_STATE_FAULT_LOAD_VIOLATION,\n                            EXEC_STATE_FAULT_STORE_MISALIGNED,\n                            EXEC_STATE_FAULT_STORE_VIOLATION,\n                            EXEC_STATE_FAULT_INSN_ILLEGAL,\n                            EXEC_STATE_FAULT_INSN_VIOLATION\n                        }) || unableToStartRecovery) ? FALSE : TRUE);\n                end\n                else begin\n                    commit[i] = FALSE;\n                end\n            end\n            else begin\n                commit[i] = (i < finishedInsnRange ? TRUE : FALSE);\n            end\n        end\n        else begin\n            commit[i] = FALSE;\n        end\n    end\nendfunction\n\n\n\nmodule CommitStage(\n    CommitStageIF.ThisStage port,\n    RenameLogicIF.CommitStage renameLogic,\n    ActiveListIF.CommitStage activeList,\n    LoadStoreUnitIF.CommitStage loadStoreUnit,\n    RecoveryManagerIF.CommitStage recovery,\n    CSR_UnitIF.CommitStage csrUnit,\n    DebugIF.CommitStage debug\n);\n\n    logic toRecoveryPhase;\n\n    logic commit [ COMMIT_WIDTH ] /*verilator public*/;\n    logic last [ COMMIT_WIDTH ];\n    logic isBranch [ COMMIT_WIDTH ];\n    logic isStore [ COMMIT_WIDTH ];\n\n    ActiveListEntry alReadData [ COMMIT_WIDTH ] /*verilator public*/;\n    ExecutionState execState [ COMMIT_WIDTH ];\n\n    CommitLaneIndexPath recoveryOpIndex;\n    RefetchType refetchType;\n    ExecutionState recoveryCause;\n\n    CommitLaneCountPath commitNum;\n    CommitLaneCountPath commitLoadNum;\n    CommitLaneCountPath commitStoreNum;\n`ifdef RSD_MARCH_FP_PIPE\n    logic fflagsWE;\n    FFlags_Path fflagsData;\n`endif\n\n    PipelinePhase phase;\n\n    PC_Path lastCommittedPC, prevLastCommittedPC;\n\n    always_ff@(posedge port.clk) begin\n        prevLastCommittedPC <= lastCommittedPC;\n        /*\n        for (int i=0; i < COMMIT_WIDTH; ++i) begin\n            if(commit[i] & |activeList.fflagsData[i]) begin\n                $display(\"%x %b\", alReadData[i].pc, activeList.fflagsData[i]);\n            end\n        end\n        */\n    end\n\n    always_comb begin\n\n        // The head entries of an active list.\n        alReadData = activeList.readData;\n        execState = activeList.headExecState;\n\n        // Phase of a pipeline\n        phase = recovery.phase;\n\n        for (int i = 0; i < COMMIT_WIDTH; i++) begin\n            last[i] = alReadData[i].last;\n            isBranch[i] = alReadData[i].isBranch;\n            isStore[i] = alReadData[i].isStore;\n        end\n\n        // Decide which instructions are committed.\n        DecideCommit(\n            .commit(commit),\n            .toRecoveryPhase(toRecoveryPhase),\n            .recoveredIndex(recoveryOpIndex),\n            .refetchType(refetchType),\n            .recoveryCause(recoveryCause),\n            .startCommit(phase == PHASE_COMMIT),\n            .activeListCount(activeList.validEntryNum),\n            .execState(execState),\n            .last(last),\n            .isBranch(isBranch),\n            .isStore(isStore),\n            .unableToStartRecovery(recovery.unableToStartRecovery)\n       );\n\n        // Count num of commit instructions.\n        commitNum = 0;\n        commitLoadNum = 0;\n        commitStoreNum = 0;\n        for (int i = 0; i < COMMIT_WIDTH; i++) begin\n            if (commit[i]) begin\n                commitNum++;\n                if (alReadData[i].isLoad)\n                    commitLoadNum++;\n                if (alReadData[i].isStore)\n                    commitStoreNum++;\n            end\n        end\n\n        // To the rename logic.\n        renameLogic.commit = commit[0];\n        renameLogic.commitNum = commitNum;\n\n        for (int i = 0; i < COMMIT_WIDTH; i++) begin\n            if (commit[i]) begin\n                renameLogic.retRMT_WriteReg[i] = alReadData[i].writeReg;\n                renameLogic.retRMT_WriteReg_PhyRegNum[i] = alReadData[i].phyDstRegNum;\n                renameLogic.retRMT_WriteReg_LogRegNum[i] = alReadData[i].logDstRegNum;\n            end\n            else begin\n                renameLogic.retRMT_WriteReg[i] = FALSE;\n                renameLogic.retRMT_WriteReg_PhyRegNum[i] = 0;\n                renameLogic.retRMT_WriteReg_LogRegNum[i] = 0;\n            end\n        end\n\n        // Update load/store unit.\n        loadStoreUnit.releaseLoadQueue = commit[0];\n        loadStoreUnit.releaseLoadQueueEntryNum = commitLoadNum;\n        loadStoreUnit.commitStore = commit[0];\n        loadStoreUnit.commitStoreNum = commitStoreNum;\n\n        // To RecoveryManager\n        recovery.exceptionDetectedInCommitStage = toRecoveryPhase;\n        recovery.refetchTypeFromCommitStage = refetchType;\n        recovery.recoveryOpIndex = recoveryOpIndex;\n        recovery.recoveryCauseFromCommitStage = recoveryCause;\n\n        // lastCommittedPC\n        lastCommittedPC = prevLastCommittedPC;\n        for (int i = 0; i < COMMIT_WIDTH; i++) begin\n            if (commit[i])\n                lastCommittedPC = alReadData[i].pc;\n        end\n\n        // CSR Update\n        csrUnit.commitNum = commitNum;\n    \n`ifdef RSD_MARCH_FP_PIPE\n        // CSR FFLAGS Update\n        fflagsWE = FALSE;\n        fflagsData = '0;\n        for (int i = 0; i < COMMIT_WIDTH; i++) begin\n            if (commit[i]) begin\n                fflagsWE = TRUE;\n                fflagsData |= activeList.fflagsData[i];\n            end\n        end\n        csrUnit.fflagsWE = fflagsWE;\n        csrUnit.fflagsData = fflagsData;\n`endif\n\n        // Debug Register\n        for (int i = 0; i < COMMIT_WIDTH; i++) begin\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            debug.toRecoveryPhase = toRecoveryPhase;\n            debug.cmReg[i].commit = commit[i];\n            debug.cmReg[i].flush =\n                (i < renameLogic.flushNum) && recovery.renameLogicRecoveryRMT;\n\n            debug.cmReg[i].opId = alReadData[i].opId;\n`ifdef RSD_FUNCTIONAL_SIMULATION\n            debug.cmReg[i].releaseReg = renameLogic.releaseReg[i];\n            debug.cmReg[i].phyReleasedReg = renameLogic.phyReleasedReg[i];\n`endif\n`endif\n            debug.lastCommittedPC = lastCommittedPC;\n        end\n    end\n\n    generate\n        for (genvar i = 0; i < COMMIT_WIDTH; i++) begin\n            `RSD_ASSERT_CLK(\n                port.clk,\n                !(commit[i] && phase == PHASE_COMMIT && alReadData[i].undefined),\n                \"An undefined or unsupported op is retired.\"\n            );\n        end\n    endgenerate\n`ifdef RSD_FUNCTIONAL_SIMULATION\n    localparam DEADLOCK_DETECT_CYCLES = 500;\n    integer cycles;\n    always_ff @(posedge port.clk) begin\n        if (port.rst || commit[0]) begin\n            cycles <= 0;\n        end\n        else begin\n            cycles <= cycles + 1;\n        end\n    end\n\n\n    generate\n        `RSD_ASSERT_CLK(\n            port.clk,\n            !(cycles > DEADLOCK_DETECT_CYCLES),\n            \"Deadlock detected\"\n        );\n    endgenerate\n\n`endif\n\nendmodule : CommitStage\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- CommitStageIF\n//\n\ninterface CommitStageIF( input logic clk, rst );\n    \n    modport ThisStage(\n    input \n        clk, \n        rst\n    );\n\nendinterface : CommitStageIF\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Complex Integer Execution stage\n//\n// \u4e57\u7b97/SIMD \u547d\u4ee4\u306e\u6f14\u7b97\u3092\u884c\u3046\n// COMPLEX_EXEC_STAGE_DEPTH \u6bb5\u306b\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5316\u3055\u308c\u3066\u3044\u308b\n//\n\n`include \"BasicMacros.sv\"\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n\nmodule ComplexIntegerExecutionStage(\n    ComplexIntegerExecutionStageIF.ThisStage port,\n    ComplexIntegerRegisterReadStageIF.NextStage prev,\n    MulDivUnitIF.ComplexIntegerExecutionStage mulDivUnit,\n    SchedulerIF.ComplexIntegerExecutionStage scheduler,\n    BypassNetworkIF.ComplexIntegerExecutionStage bypass,\n    RecoveryManagerIF.ComplexIntegerExecutionStage recovery,\n    ControllerIF.ComplexIntegerExecutionStage ctrl,\n    DebugIF.ComplexIntegerExecutionStage debug\n);\n    // Pipeline control\n    logic stall, clear;\n    logic flush[ COMPLEX_ISSUE_WIDTH ][ COMPLEX_EXEC_STAGE_DEPTH ];\n\n    `RSD_STATIC_ASSERT(COMPLEX_ISSUE_WIDTH == MULDIV_ISSUE_WIDTH, \"These muse be same\");\n    `RSD_STATIC_ASSERT(COMPLEX_EXEC_STAGE_DEPTH == MULDIV_STAGE_DEPTH, \"These muse be same\");\n\n    //\n    // --- Local Pipeline Register\n    //\n\n    // \u8907\u6570\u30b5\u30a4\u30af\u30eb\u306b\u308f\u305f\u308b ComplexIntegerExecutionStage \u5185\u3067\n    // \u4f7f\u7528\u3059\u308b\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u30ec\u30b8\u30b9\u30bf\n    typedef struct packed // LocalPipeReg\n    {\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        OpId      opId;\n`endif\n\n        logic valid;  // Valid flag. If this is 0, its op is treated as NOP.\n        logic regValid; // Valid flag of a destination register.\n        ComplexIssueQueueEntry complexQueueData;\n    } LocalPipeReg;\n\n    LocalPipeReg localPipeReg [ COMPLEX_ISSUE_WIDTH ][ COMPLEX_EXEC_STAGE_DEPTH-1 ];\n    LocalPipeReg nextLocalPipeReg [ COMPLEX_ISSUE_WIDTH ][ COMPLEX_EXEC_STAGE_DEPTH-1 ];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < COMPLEX_ISSUE_WIDTH; i++) begin\n            for (int j = 0; j < COMPLEX_EXEC_STAGE_DEPTH-1; j++) begin\n                localPipeReg[i][j] <= '0;\n            end\n        end\n    end\n`endif\n\n    always_ff@( posedge port.clk ) begin\n        if (port.rst || clear) begin\n            for (int i = 0; i < COMPLEX_ISSUE_WIDTH; i++) begin\n                for ( int j = 0; j < COMPLEX_EXEC_STAGE_DEPTH-1; j++ ) begin\n                    localPipeReg[i][j].valid <= '0;\n                    localPipeReg[i][j].regValid <= '0;\n                end\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin   // write data\n            localPipeReg <= nextLocalPipeReg;\n        end\n    end\n\n\n    //\n    // --- Pipeline Register\n    //\n\n    // ComplexIntegerRegisterReadStage \u3068\u306e\u5883\u754c\u306b\u3042\u308b\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u30ec\u30b8\u30b9\u30bf\n    ComplexIntegerExecutionStageRegPath pipeReg[COMPLEX_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < COMPLEX_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n    always_ff@(posedge port.clk)   // synchronous rst\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < COMPLEX_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= '0;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin   // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n    //\n    // Signals\n    //\n    ComplexIssueQueueEntry iqData        [ COMPLEX_ISSUE_WIDTH ] [COMPLEX_EXEC_STAGE_DEPTH];\n    ComplexOpInfo          complexOpInfo [ COMPLEX_ISSUE_WIDTH ];\n    MulOpSubInfo           mulSubInfo    [ COMPLEX_ISSUE_WIDTH ];\n    DivOpSubInfo           divSubInfo    [ COMPLEX_ISSUE_WIDTH ];\n\n    PRegDataPath  fuOpA    [ COMPLEX_ISSUE_WIDTH ];\n    PRegDataPath  fuOpB    [ COMPLEX_ISSUE_WIDTH ];\n    logic         regValid [ COMPLEX_ISSUE_WIDTH ];\n    PRegDataPath  dataOut  [ COMPLEX_ISSUE_WIDTH ];\n\n\n\n    //\n    // DividerUnit\n    //\n    logic isDiv         [ COMPLEX_ISSUE_WIDTH ]; \n    logic finished      [ COMPLEX_ISSUE_WIDTH ];\n\n    always_comb begin\n\n        for (int i = 0; i < COMPLEX_ISSUE_WIDTH; i++) begin\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n            mulDivUnit.dataInA[i] = fuOpA[i].data;\n            mulDivUnit.dataInB[i] = fuOpB[i].data;\n\n            // DIV\n            mulDivUnit.divCode[i] = divSubInfo[i].divCode;\n\n            isDiv[i] =  \n                pipeReg[i].complexQueueData.opType == COMPLEX_MOP_TYPE_DIV;\n\n            // MUL\n            mulDivUnit.mulGetUpper[i] = mulSubInfo[i].mulGetUpper;\n            mulDivUnit.mulCode[i] = mulSubInfo[i].mulCode;\n\n            // DIV\n            mulDivUnit.divCode[i] = divSubInfo[i].divCode;\n\n            mulDivUnit.dataInA[i] = fuOpA[i].data;\n            mulDivUnit.dataInB[i] = fuOpB[i].data;\n\n\n            // Request to the divider\n            // NOT make a request when below situation\n            // 1) When any operands of inst. are invalid\n            // 2) When the divider is waiting for the instruction\n            //    to receive the result of the divider\n            mulDivUnit.divReq[i] = \n                mulDivUnit.divReserved[i] && \n                pipeReg[i].valid && isDiv[i] && \n                fuOpA[i].valid && fuOpB[i].valid;\n\n            if (mulDivUnit.divFinished[i] &&\n                localPipeReg[i][COMPLEX_EXEC_STAGE_DEPTH-2].valid &&\n                localPipeReg[i][COMPLEX_EXEC_STAGE_DEPTH-2].complexQueueData.opType == COMPLEX_MOP_TYPE_DIV && \n                localPipeReg[i][COMPLEX_EXEC_STAGE_DEPTH-2].regValid\n            ) begin \n                // Div\u304c\u9664\u7b97\u5668\u304b\u3089\u7d50\u679c\u3092\u53d6\u5f97\u3067\u304d\u305f\u306e\u3067\uff0c\n                // IQ\u304b\u3089\u306ediv\u306e\u767a\u884c\u3092\u8a31\u53ef\u3059\u308b \n                mulDivUnit.divRelease[i] = TRUE;\n            end\n            else begin\n                mulDivUnit.divRelease[i] = FALSE;\n            end\n`endif\n        end\n    end\n\n    always_comb begin\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n            iqData[i][0] = pipeReg[i].complexQueueData;\n            complexOpInfo[i]  = pipeReg[i].complexQueueData.complexOpInfo;\n            mulSubInfo[i]  = complexOpInfo[i].mulSubInfo;\n            divSubInfo[i]  = complexOpInfo[i].divSubInfo;\n            \n\n            flush[i][0] = SelectiveFlushDetector(\n                recovery.toRecoveryPhase,\n                recovery.flushRangeHeadPtr,\n                recovery.flushRangeTailPtr,\n                recovery.flushAllInsns,\n                pipeReg[i].complexQueueData.activeListPtr\n            );\n\n            // From local pipeline \n            for (int j = 1; j < COMPLEX_EXEC_STAGE_DEPTH; j++) begin \n                iqData[i][j] = localPipeReg[i][j-1].complexQueueData; \n                flush[i][j] = SelectiveFlushDetector( \n                    recovery.toRecoveryPhase, \n                    recovery.flushRangeHeadPtr, \n                    recovery.flushRangeTailPtr, \n                    recovery.flushAllInsns,\n                    localPipeReg[i][j-1].complexQueueData.activeListPtr \n                );\n            end\n\n            // \u30aa\u30da\u30e9\u30f3\u30c9\n            fuOpA[i] = ( pipeReg[i].bCtrl.rA.valid ? bypass.complexSrcRegDataOutA[i] : pipeReg[i].operandA );\n            fuOpB[i] = ( pipeReg[i].bCtrl.rB.valid ? bypass.complexSrcRegDataOutB[i] : pipeReg[i].operandB );\n           \n\n            \n            //\n            // --- regValid\n            //\n\n            // If invalid registers are read, regValid is negated and this op must be replayed.\n            // \u30d9\u30af\u30bf\u4ee5\u5916\u306e\u6f14\u7b97\n            regValid[i] =\n                fuOpA[i].valid &&\n                fuOpB[i].valid;\n\n            //\n            // --- \u30c7\u30fc\u30bf\u30a2\u30a6\u30c8(\u5b9f\u884c\u30b9\u30c6\u30fc\u30b8\u306e\u6700\u7d42\u6bb5\u306e\u51e6\u7406)\n            //\n            dataOut[i].valid\n                = localPipeReg[i][COMPLEX_EXEC_STAGE_DEPTH-2].regValid;\n\n            unique case ( localPipeReg[i][COMPLEX_EXEC_STAGE_DEPTH-2].complexQueueData.opType )\n            COMPLEX_MOP_TYPE_DIV: dataOut[i].data = mulDivUnit.divDataOut[i];\n            default: /* mul */    dataOut[i].data = mulDivUnit.mulDataOut[i];\n            endcase\n\n            //\n            // --- Bypass\n            //\n\n            // \u6700\u521d\u306e\u30b9\u30c6\u30fc\u30b8\u3067\u51fa\u529b\n            bypass.complexCtrlIn[i] = pipeReg[i].bCtrl;\n\n            // \u6700\u5f8c\u306e\u30b9\u30c6\u30fc\u30b8\u3067\u51fa\u529b\n            bypass.complexDstRegDataOut[i] = dataOut[i];\n\n            //\n            // --- Replay\n            //\n\n            // IS\u304b\u30893\u30b9\u30c6\u30fc\u30b8\u5f8c=EX1\u30b9\u30c6\u30fc\u30b8\u3067Replay\u3092\u51fa\u529b\n            // \u3053\u306e\u3068\u304d\u3001localPipeReg[lane][0]\u306e\u30c7\u30fc\u30bf\u3092\u4f7f\u3046\n            scheduler.complexRecordEntry[i] =\n                !stall &&\n                !clear &&\n                !flush[i][1] &&\n                localPipeReg[i][0].valid &&\n                !localPipeReg[i][0].regValid;\n            scheduler.complexRecordData[i] =\n                localPipeReg[i][0].complexQueueData;\n        end\n    end\n\n    //\n    // --- Pipeline \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\n    //\n    ComplexIntegerRegisterWriteStageRegPath nextStage [ COMPLEX_ISSUE_WIDTH ];\n\n    always_comb begin\n        // Local Pipeline Register\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextLocalPipeReg[i][0].opId = pipeReg[i].opId;\n`endif\n\n            nextLocalPipeReg[i][0].valid = flush[i][0] ? FALSE : pipeReg[i].valid;\n            nextLocalPipeReg[i][0].complexQueueData = pipeReg[i].complexQueueData;\n\n            // Reg valid of local pipeline \n            if (isDiv[i]) begin\n                nextLocalPipeReg[i][0].regValid = \n                    pipeReg[i].replay && (mulDivUnit.divFinished[i]);\n            end\n            else begin\n                nextLocalPipeReg[i][0].regValid = regValid[i];\n            end\n            \n\n            for (int j = 1; j < COMPLEX_EXEC_STAGE_DEPTH-1; j++) begin\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n                nextLocalPipeReg[i][j].opId = localPipeReg[i][j-1].opId;\n`endif \n                nextLocalPipeReg[i][j].valid = flush[i][j] ? FALSE : localPipeReg[i][j-1].valid;\n                nextLocalPipeReg[i][j].regValid = localPipeReg[i][j-1].regValid; \n                nextLocalPipeReg[i][j].complexQueueData = localPipeReg[i][j-1].complexQueueData;\n            end \n        end\n\n        // To ComplexIntegerRegisterWriteStage\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId\n                = localPipeReg[i][COMPLEX_EXEC_STAGE_DEPTH-2].opId;\n`endif\n\n            nextStage[i].complexQueueData\n                = localPipeReg[i][COMPLEX_EXEC_STAGE_DEPTH-2].complexQueueData;\n\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            nextStage[i].valid =\n                (stall || clear || port.rst || flush[i][COMPLEX_EXEC_STAGE_DEPTH-1]) ? FALSE : localPipeReg[i][COMPLEX_EXEC_STAGE_DEPTH-2].valid;\n\n            nextStage[i].dataOut = dataOut[i];\n        end\n\n        port.nextStage = nextStage;\n\n        // Debug Register\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n            debug.complexExReg[i].valid[0] = pipeReg[i].valid;\n            debug.complexExReg[i].flush[0] = flush[i][0];\n            debug.complexExReg[i].opId[0] = pipeReg[i].opId;\n            for ( int j = 1; j < COMPLEX_EXEC_STAGE_DEPTH; j++ ) begin\n                debug.complexExReg[i].valid[j] = localPipeReg[i][j-1].valid;\n                debug.complexExReg[i].opId[j] = localPipeReg[i][j-1].opId;\n                debug.complexExReg[i].flush[j] = flush[i][j];\n            end\n`ifdef RSD_FUNCTIONAL_SIMULATION\n            debug.complexExReg[i].dataOut = dataOut[i];\n            debug.complexExReg[i].fuOpA   = fuOpA[i];\n            debug.complexExReg[i].fuOpB   = fuOpB[i];\n\n`endif  // `ifdef RSD_FUNCTIONAL_SIMULATION\n        end //for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n`endif\nend\n\nendmodule : ComplexIntegerExecutionStage\n\n`endif\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- ComplexIntegerExecutionStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\ninterface ComplexIntegerExecutionStageIF( input logic clk, rst );\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n\n    // Pipeline register\n    ComplexIntegerRegisterWriteStageRegPath nextStage [ COMPLEX_ISSUE_WIDTH ];\n    \n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\n`endif\n\nendinterface : ComplexIntegerExecutionStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for issuing ops.\n//\n\n\nimport BasicTypes::*;\nimport MicroOpTypes::*;\nimport PipelineTypes::*;\nimport ActiveListIndexTypes::*;\nimport SchedulerTypes::*;\nimport DebugTypes::*;\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n\nmodule ComplexIntegerIssueStage(\n    ComplexIntegerIssueStageIF.ThisStage port,\n    ScheduleStageIF.ComplexNextStage prev,\n    SchedulerIF.ComplexIntegerIssueStage scheduler,\n    RecoveryManagerIF.ComplexIntegerIssueStage recovery,\n    MulDivUnitIF.ComplexIntegerIssueStage mulDivUnit,\n    ControllerIF.ComplexIntegerIssueStage ctrl,\n    DebugIF.ComplexIntegerIssueStage debug\n);\n\n    // --- Pipeline registers\n    IssueStageRegPath pipeReg [ COMPLEX_ISSUE_WIDTH ];\n    IssueStageRegPath nextPipeReg [ COMPLEX_ISSUE_WIDTH ];\n    always_ff@( posedge port.clk )   // synchronous rst\n    begin\n        if ( port.rst ) begin\n            for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ )\n                pipeReg[i] <= '0;\n        end\n        else if( !ctrl.isStage.stall )              // write data\n            pipeReg <= prev.complexNextStage;\n        else\n            pipeReg <= nextPipeReg;\n    end\n\n    always_comb begin\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++) begin\n            if (recovery.toRecoveryPhase) begin\n                nextPipeReg[i].valid = pipeReg[i].valid &&\n                                    !SelectiveFlushDetector(\n                                        recovery.toRecoveryPhase,\n                                        recovery.flushRangeHeadPtr,\n                                        recovery.flushRangeTailPtr,\n                                        recovery.flushAllInsns,\n                                        scheduler.complexIssuedData[i].activeListPtr\n                                        );\n            end\n            else begin\n                nextPipeReg[i].valid = pipeReg[i].valid;\n            end\n            nextPipeReg[i].issueQueuePtr = pipeReg[i].issueQueuePtr;\n        end\n    end\n\n\n    // Pipeline control\n    logic stall, clear;\n    logic flush[ COMPLEX_ISSUE_WIDTH ];\n    logic valid [ COMPLEX_ISSUE_WIDTH ];\n    ComplexIntegerRegisterReadStageRegPath nextStage [ COMPLEX_ISSUE_WIDTH ];\n    ComplexIssueQueueEntry issuedData [ COMPLEX_ISSUE_WIDTH ];\n    IssueQueueIndexPath issueQueuePtr [ COMPLEX_ISSUE_WIDTH ];\n\n    always_comb begin\n\n        stall = ctrl.isStage.stall;\n        clear = ctrl.isStage.clear;\n\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n\n            if (scheduler.replay) begin\n                // In this cycle, the pipeline replays ops.\n                issuedData[i] = scheduler.complexReplayData[i];\n                valid[i] = scheduler.complexReplayEntry[i];\n            end\n            else begin\n                // In this cycle, the pipeline issues ops.\n                issuedData[i] = scheduler.complexIssuedData[i];\n                valid[i] = !stall && pipeReg[i].valid;\n            end\n\n            issueQueuePtr[i] = pipeReg[i].issueQueuePtr;\n\n            flush[i] = SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        issuedData[i].activeListPtr\n                        );\n\n            // Issue.\n            scheduler.complexIssue[i] = !clear && valid[i] && !flush[i];\n            scheduler.complexIssuePtr[i] = issueQueuePtr[i];\n\n            `ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n                // Lock div units\n                mulDivUnit.divAcquire[i] = \n                    !clear && valid[i] &&\n                    !flush[i] && issuedData[i].opType == COMPLEX_MOP_TYPE_DIV;\n                mulDivUnit.acquireActiveListPtr[i] = issuedData[i].activeListPtr;\n            `endif        \n\n            // --- Pipeline \u30e9\u30c3\u30c1\u66f8\u304d\u8fbc\u307f\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            nextStage[i].valid =\n                (clear || port.rst || flush[i]) ? FALSE : valid[i];\n            nextStage[i].complexQueueData = issuedData[i];\n            nextStage[i].replay = scheduler.replay;\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId = issuedData[i].opId;\n`endif\n        end\n\n        port.nextStage = nextStage;\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        // Debug Register\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n            debug.complexIsReg[i].valid = valid[i];\n            debug.complexIsReg[i].flush = flush[i];\n            debug.complexIsReg[i].opId = issuedData[i].opId;\n        end\n`endif\n    end\n\n\nendmodule : ComplexIntegerIssueStage\n\n`endif\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- ComplexIntegerIssueStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface ComplexIntegerIssueStageIF( input logic clk, rst );\n    \n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    // Pipeline register\n    ComplexIntegerRegisterReadStageRegPath nextStage [ COMPLEX_ISSUE_WIDTH ];\n    \n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\n`endif    \n\n\nendinterface : ComplexIntegerIssueStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for register read.\n//\n\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n\nmodule ComplexIntegerRegisterReadStage(\n    ComplexIntegerRegisterReadStageIF.ThisStage port,\n    ComplexIntegerIssueStageIF.NextStage prev,\n    RegisterFileIF.ComplexIntegerRegisterReadStage registerFile,\n    BypassNetworkIF.ComplexIntegerRegisterReadStage bypass,\n    RecoveryManagerIF.ComplexIntegerRegisterReadStage recovery,\n    ControllerIF.ComplexIntegerRegisterReadStage ctrl,\n    DebugIF.ComplexIntegerRegisterReadStage debug\n);\n\n    // --- Pipeline registers\n    ComplexIntegerRegisterReadStageRegPath pipeReg[COMPLEX_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < COMPLEX_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n\n    always_ff@( posedge port.clk )   // synchronous rst\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < COMPLEX_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= '0;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin              // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n\n\n    // Pipeline controll\n    logic stall, clear;\n    logic flush[ COMPLEX_ISSUE_WIDTH ];\n    ComplexIssueQueueEntry iqData[COMPLEX_ISSUE_WIDTH];\n    MulOpSubInfo mulOpInfo[COMPLEX_ISSUE_WIDTH];\n    OpSrc opSrc[COMPLEX_ISSUE_WIDTH];\n    OpDst opDst[COMPLEX_ISSUE_WIDTH];\n    ComplexIntegerExecutionStageRegPath nextStage[COMPLEX_ISSUE_WIDTH];\n\n    always_comb begin\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n            iqData[i] = pipeReg[i].complexQueueData;\n            mulOpInfo[i] = iqData[i].complexOpInfo.mulSubInfo;\n            opSrc[i] = iqData[i].opSrc;\n            opDst[i] = iqData[i].opDst;\n\n            //\n            // To the register file.\n            //\n\n            registerFile.complexSrcRegNumA[i] = opSrc[i].phySrcRegNumA;\n            registerFile.complexSrcRegNumB[i] = opSrc[i].phySrcRegNumB;\n\n            //\n            // To the bypass network.\n            // \u30b9\u30c8\u30fc\u30eb\u3084\u30d5\u30e9\u30c3\u30b7\u30e5\u306e\u5236\u5fa1\u306f\uff0cBypass \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u5185\u90e8\u3067\n            // \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306e\u4fe1\u53f7\u3092\u53c2\u7167\u3057\u3066\u884c\u308f\u308c\u3066\u3044\u308b\n            //\n            bypass.complexPhySrcRegNumA[i] = opSrc[i].phySrcRegNumA;\n            bypass.complexPhySrcRegNumB[i] = opSrc[i].phySrcRegNumB;\n\n            bypass.complexWriteReg[i]  = opDst[i].writeReg & pipeReg[i].valid;\n            bypass.complexPhyDstRegNum[i] = opDst[i].phyDstRegNum;\n\n            // Complex Integer \u3067\u306f\u3001operandType\u306fOOT_REG\u3057\u304b\u672a\u30b5\u30dd\u30fc\u30c8\n            bypass.complexReadRegA[i] = TRUE;\n            bypass.complexReadRegB[i] = TRUE;\n            //bypass.complexReadRegA[i] = ( iqData[i].complexOpInfo.operandTypeA == OOT_REG );\n            //bypass.complexReadRegB[i] = ( iqData[i].complexOpInfo.operandTypeB == OOT_REG );\n\n            //\n            // --- Pipeline \u30e9\u30c3\u30c1\u66f8\u304d\u8fbc\u307f\n            //\n            `ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId = pipeReg[i].opId;\n            `endif\n\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            flush[i] = SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        iqData[i].activeListPtr\n                        );\n            nextStage[i].valid =\n                (stall || clear || port.rst || flush[i]) ? FALSE : pipeReg[i].valid;\n\n            nextStage[i].replay = pipeReg[i].replay;\n\n            // div\u304c\u3053\u306e\u30b9\u30c6\u30fc\u30b8\u5185\u3067\u30d5\u30e9\u30c3\u30b7\u30e5\u3055\u308c\u305f\u5834\u5408\uff1a\n            // Divider\u3078\u306e\u8981\u6c42\u4e88\u7d04\u3092\u53d6\u308a\u6d88\u3057\uff0c\n            // IQ\u304b\u3089div\u3092\u767a\u884c\u3067\u304d\u308b\u3088\u3046\u306b\u3059\u308b \n            if (iqData[i].opType == COMPLEX_MOP_TYPE_DIV) begin\n                nextStage[i].isFlushed = pipeReg[i].valid && flush[i];\n            end\n            else begin\n                nextStage[i].isFlushed = FALSE;\n            end\n            \n            // \u30ec\u30b8\u30b9\u30bf\u5024&\u30d5\u30e9\u30b0\n            nextStage[i].operandA = registerFile.complexSrcRegDataA[i];\n            nextStage[i].operandB = registerFile.complexSrcRegDataB[i];\n            \n            // Issue queue data\n            nextStage[i].complexQueueData = pipeReg[i].complexQueueData;\n\n            // \u30d0\u30a4\u30d1\u30b9\u5236\u5fa1\n            nextStage[i].bCtrl = bypass.complexCtrlOut[i];\n\n        end\n        port.nextStage = nextStage;\n\n        // Debug Register\n        `ifndef RSD_DISABLE_DEBUG_REGISTER\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n            debug.complexRrReg[i].valid = pipeReg[i].valid;\n            debug.complexRrReg[i].flush = flush[i];\n            debug.complexRrReg[i].opId = pipeReg[i].opId;\n        end\n        `endif\n    end\nendmodule : ComplexIntegerRegisterReadStage\n\n`endif\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface ComplexIntegerRegisterReadStageIF( input logic clk, rst );\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    // Pipeline register\n    ComplexIntegerExecutionStageRegPath nextStage [ COMPLEX_ISSUE_WIDTH ];\n\n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\n`endif\n\nendinterface : ComplexIntegerRegisterReadStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Complex Integer Write back stage\n//\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport RenameLogicTypes::*;\nimport PipelineTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport DebugTypes::*;\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n\nmodule ComplexIntegerRegisterWriteStage(\n    ComplexIntegerExecutionStageIF.NextStage prev,\n    RegisterFileIF.ComplexIntegerRegisterWriteStage registerFile,\n    ActiveListIF.ComplexIntegerRegisterWriteStage activeList,\n    RecoveryManagerIF.ComplexIntegerRegisterWriteStage recovery,\n    ControllerIF.ComplexIntegerRegisterWriteStage ctrl,\n    DebugIF.ComplexIntegerRegisterWriteStage debug\n);\n    ComplexIntegerRegisterWriteStageRegPath pipeReg[COMPLEX_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < COMPLEX_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n    // --- Pipeline registers\n    always_ff@(posedge ctrl.clk)   // synchronous rst\n    begin\n        if (ctrl.rst) begin\n            for (int i = 0; i < COMPLEX_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= '0;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin    // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n    ActiveListWriteData alWriteData[COMPLEX_ISSUE_WIDTH];\n    IntIssueQueueEntry iqData[COMPLEX_ISSUE_WIDTH];\n    logic stall, clear;\n    logic flush[ COMPLEX_ISSUE_WIDTH ];\n    logic update [ COMPLEX_ISSUE_WIDTH ];\n    logic valid [ COMPLEX_ISSUE_WIDTH ];\n    logic regValid [ COMPLEX_ISSUE_WIDTH ];\n\n    always_comb begin\n\n        // Pipeline controll\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n            iqData[i] = pipeReg[i].complexQueueData;\n            regValid[i] = pipeReg[i].dataOut.valid;\n\n            valid[i] = pipeReg[i].valid;\n            flush[i] = SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        iqData[i].activeListPtr\n                        );\n            update[i] = !stall && !clear && valid[i] && !flush[i];\n\n\n            //\n            // Register file\n            //\n\n            registerFile.complexDstRegWE[i] =\n                update[i] && iqData[i].opDst.writeReg;\n\n            registerFile.complexDstRegNum[i] = iqData[i].opDst.phyDstRegNum;\n            registerFile.complexDstRegData[i] = pipeReg[i].dataOut;\n            \n            //\n            // Active list\n            //\n            alWriteData[i].ptr = iqData[i].activeListPtr;\n            alWriteData[i].loadQueuePtr = iqData[i].loadQueueRecoveryPtr;\n            alWriteData[i].storeQueuePtr = iqData[i].storeQueueRecoveryPtr;\n            alWriteData[i].ptr = iqData[i].activeListPtr;\n            alWriteData[i].pc = iqData[i].pc;\n            alWriteData[i].dataAddr = '0;\n            alWriteData[i].isBranch = FALSE;\n            alWriteData[i].isStore = FALSE;\n\n            // ExecState\n            if ( update[i] && regValid[i] ) begin\n                alWriteData[i].state = EXEC_STATE_SUCCESS;\n            end\n            else begin\n                alWriteData[i].state = EXEC_STATE_NOT_FINISHED;\n            end\n\n            activeList.complexWrite[i] = update[i];\n            activeList.complexWriteData[i] = alWriteData[i];\n        end\n\n        // Debug Register\n        `ifndef RSD_DISABLE_DEBUG_REGISTER\n            for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n                debug.complexRwReg[i].valid = valid[i];\n                debug.complexRwReg[i].flush = flush[i];\n                debug.complexRwReg[i].opId = pipeReg[i].opId;\n            end\n        `endif\n    end\nendmodule : ComplexIntegerRegisterWriteStage\n\n`endif\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\n\nmodule Controller(\n    ControllerIF.Controller port,\n    DebugIF.Controller debug\n);\n\n    PipelineControll npStage;\n    PipelineControll ifStage;\n    PipelineControll pdStage;\n    PipelineControll idStage;\n    PipelineControll rnStage;\n    PipelineControll dsStage;\n\n    PipelineControll scStage;\n    PipelineControll isStage;\n    PipelineControll backEnd;\n    PipelineControll cmStage;\n    logic stallByDecodeStage;\n\n    always_comb begin\n\n        //\n        // See comments in ControllerIF for stall/clear\n        //\n\n        stallByDecodeStage = FALSE;\n\n        //\n        // --- Front-end control\n        //\n        if( port.rst ) begin\n            // \u30ea\u30bb\u30c3\u30c8\u6642\u306b\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u30e9\u30c3\u30c1\u306b\u7121\u52b9\u5316\u30d5\u30e9\u30b0\u3092\u66f8\u304f\u305f\u3081\uff0cstall \u306fFALSE \u306b\n            //              stall/ clear\n            npStage = { FALSE, TRUE };\n            ifStage = { FALSE, TRUE };\n            pdStage = { FALSE, TRUE };\n            idStage = { FALSE, TRUE };\n            rnStage = { FALSE, TRUE };\n            dsStage = { FALSE, TRUE };\n\n        end\n        else begin\n            //\n            // \u901a\u5e38\u6642\n            //              stall/ clear\n            npStage = { FALSE, FALSE };\n            ifStage = { FALSE, FALSE };\n            pdStage = { FALSE, FALSE };\n            idStage = { FALSE, FALSE };\n            rnStage = { FALSE, FALSE };\n            dsStage = { FALSE, FALSE };\n\n            //\n            // A request from lower stages has a higher priority.\n            //\n            if( port.cmStageFlushUpper ) begin\n                // Clear ops not in the active list when branch misprediction is detected.\n                //              stall/ clear\n                npStage = { FALSE, FALSE };\n                ifStage = { FALSE, TRUE };\n                pdStage = { FALSE, TRUE };\n                idStage = { FALSE, TRUE };\n                rnStage = { FALSE, TRUE };\n                dsStage = { FALSE, TRUE };\n\n            end\n            else if( port.rnStageSendBubbleLower ) begin\n                //\n                // Stall and send a bubble to lower stages because there are not enough\n                // physical registers\n                //              stall/ clear\n                npStage = { TRUE,  FALSE };\n                ifStage = { TRUE,  FALSE };\n                pdStage = { TRUE,  FALSE };\n                idStage = { TRUE,  FALSE };\n                rnStage = { TRUE,  TRUE  }; // \u5f8c\u7d9a\u30b9\u30c6\u30fc\u30b8\u306b\u30d0\u30d6\u30eb\uff08NOP\uff09\u3092\u9001\u308b\n            end\n            else if( port.rnStageFlushUpper ) begin\n                //\n                // \u30ea\u30cd\u30fc\u30de\u3088\u308a\u4e0a\u6d41\u3092\u30d5\u30e9\u30c3\u30b7\u30e5\n                //              stall/ clear\n                npStage = { FALSE, FALSE };\n                ifStage = { FALSE, TRUE };\n                pdStage = { FALSE, TRUE };\n                idStage = { FALSE, TRUE };\n\n            end\n            else if( port.idStageStallUpper ) begin\n                //\n                // \u30c7\u30b3\u30fc\u30c0\u3088\u308a\u4e0a\u6d41\uff08\u30d5\u30a7\u30c3\u30c1\u30e3\uff09\u3092\u30b9\u30c8\u30fc\u30eb\n                // \u30de\u30a4\u30af\u30edOp \u30c7\u30b3\u30fc\u30c9\u3092\u884c\u3046\u305f\u3081\u306b\u3068\u3081\u3066\u3044\u308b\u305f\u3081\uff0c\n                // \u30d0\u30d6\u30eb\u306f\u4e0d\u8981\n                //              stall/ clear\n                npStage = { TRUE,  FALSE };\n                ifStage = { TRUE,  FALSE };\n                pdStage = { TRUE,  FALSE };\n                idStage = { TRUE,  FALSE };\n\n                stallByDecodeStage = TRUE;\n            end\n            else if(\n                port.ifStageSendBubbleLower\n            ) begin\n                //\n                // I-Cache miss.\n                // Stop PC update and Send NOPs to the lower stages.\n                //          stall/ clear\n                npStage = { TRUE, TRUE };  \n                ifStage = { TRUE, TRUE };  \n            end\n            else if(\n                port.npStageSendBubbleLower || \n                port.npStageSendBubbleLowerForInterrupt\n            ) begin\n                //\n                // Interrupt\n                //\n                npStage = { TRUE, TRUE };  \n            end\n        end\n\n\n        port.npStage = npStage;\n        port.ifStage = ifStage;\n        port.pdStage = pdStage;\n        port.idStage = idStage;\n        port.rnStage = rnStage;\n        port.dsStage = dsStage;\n        port.stallByDecodeStage = stallByDecodeStage;\n\n        //\n        // --- Back-end control\n        //\n\n        if( port.rst ) begin\n            // \u30ea\u30bb\u30c3\u30c8\u6642\u306b\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u30e9\u30c3\u30c1\u306b\u7121\u52b9\u5316\u30d5\u30e9\u30b0\u3092\u66f8\u304f\u305f\u3081\uff0cstall \u306fFALSE \u306b\n            //              stall/ clear\n            scStage = { FALSE, TRUE };\n            isStage = { FALSE, TRUE };\n            backEnd = { FALSE, TRUE };\n            cmStage = { FALSE, TRUE };\n\n        end\n        else begin\n            //\n            // A request from lower stages has a higher priority.\n            //\n            if (port.isStageStallUpper) begin\n                // Stall scheduler\n                scStage = { TRUE, FALSE };\n                isStage = { TRUE, FALSE };\n                backEnd = { FALSE, FALSE };\n                cmStage = { FALSE, FALSE };\n            end\n            else begin\n                //\n                // \u901a\u5e38\u6642\n                //              stall/ clear\n                scStage = { FALSE, FALSE };\n                isStage = { FALSE, FALSE };\n                backEnd = { FALSE, FALSE };\n                cmStage = { FALSE, FALSE };\n            end\n        end\n\n        port.scStage = scStage;\n        port.isStage = isStage;\n        port.backEnd = backEnd;\n        port.cmStage = cmStage;\n\n        // \u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5168\u4f53\u3067\u751f\u304d\u3066\u3044\u308b\u547d\u4ee4\u304c\u3044\u308b\u304b\u3069\u3046\u304b\n        port.wholePipelineEmpty = \n            npStage.clear &&            // IF \u306f clear \u3055\u308c\u306a\u3044\u9650\u308a\u4f55\u304b\u6709\u52b9\u306a\u547d\u4ee4\u3092\u30d5\u30a7\u30c3\u30c1\u3059\u308b\n            port.ifStageEmpty &&\n            port.pdStageEmpty &&\n            port.idStageEmpty && \n            port.rnStageEmpty &&\n            port.activeListEmpty;\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        // Debug Register\n        debug.npStagePipeCtrl = npStage;\n        debug.ifStagePipeCtrl = ifStage;\n        debug.pdStagePipeCtrl = pdStage;\n        debug.idStagePipeCtrl = idStage;\n        debug.rnStagePipeCtrl = rnStage;\n        debug.dsStagePipeCtrl = dsStage;\n        debug.backEndPipeCtrl = backEnd;\n        debug.cmStagePipeCtrl = cmStage;\n        debug.stallByDecodeStage = stallByDecodeStage;\n`endif\n    end\n\nendmodule\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- Controller\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface ControllerIF(\ninput\n    logic clk,\n    logic rst\n);\n\n\n    //\n    // Pipeline\n    //\n    // PipelineControll::stall \u306f\uff0c\u305d\u306e\u30b9\u30c6\u30fc\u30b8\u306e\u982d\u306b\u3042\u308b\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u30ec\u30b8\u30b9\u30bf\u306e\n    // \u66f8\u304d\u8fbc\u307f\u5236\u5fa1\u3092\u884c\u3046\uff0e\u305f\u3068\u3048\u3070 ifStage \u3067\u3042\u308c\u3070 PC \u306e\uff0cidStage \u3067\u3042\u308c\u3070\uff0c\n    // if/id \u30b9\u30c6\u30fc\u30b8\u9593\u306e\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u30ec\u30b8\u30b9\u30bf\u306e WE \u306b\u63a5\u7d9a\u3055\u308c\u308b\uff0e\n    //\n    // PipelineControll::clear \u306f\uff0c\u6709\u52b9\u306a\u5834\u5408\uff0c\u305d\u306e\u30b9\u30c6\u30fc\u30b8\u306e\u6b21\u306e\u30b9\u30c6\u30fc\u30b8\u306b\u9001\u308a\n    // \u8fbc\u3080\u547d\u4ee4\u306e valid \u3092\u5f37\u5236\u7684\u306b\u843d\u3068\u3059\uff08\u6b21\u306e\u30b9\u30c6\u30fc\u30b8\u306bNOP\u3092\u9001\u308b\uff09\uff0e\n    // \u3053\u308c\u306f\uff0c\u305d\u306e\u30b5\u30a4\u30af\u30eb\u306b\u305d\u306e\u30b9\u30c6\u30fc\u30b8\u306b\u3044\u308b\u547d\u4ee4\u3092\u7121\u52b9\u5316\u3057\uff0c\n    // \u6b21\u306e\u30b9\u30c6\u30fc\u30b8\u306bNOP \u3092\u9001\u308a\u8fbc\u3080\u3053\u3068\u3092\u610f\u5473\u3059\u308b\uff0e\n    //\n    PipelineControll npStage;\n    PipelineControll ifStage;\n    PipelineControll pdStage;\n    PipelineControll idStage;\n    PipelineControll rnStage;\n    PipelineControll dsStage;\n\n    PipelineControll scStage;\n    PipelineControll isStage;\n    PipelineControll backEnd;\n    PipelineControll cmStage;\n\n    // \u751f\u304d\u305f\u547d\u4ee4\u304c\u3044\u308b\u304b\u3069\u3046\u304b\n    logic ifStageEmpty;\n    logic pdStageEmpty;\n    logic idStageEmpty;\n    logic rnStageEmpty;\n    logic activeListEmpty;\n    logic wholePipelineEmpty;\n\n    //\n    // --- Requests from pipeline stages.\n    //\n    logic npStageSendBubbleLower;\n    logic npStageSendBubbleLowerForInterrupt;\n    logic ifStageSendBubbleLower;\n    logic idStageStallUpper;\n    logic rnStageFlushUpper;\n    logic rnStageSendBubbleLower;\n    logic cmStageFlushUpper;\n    logic isStageStallUpper;\n\n    //\n    // --- Special signals\n    //\n    logic stallByDecodeStage;\n\n    modport Controller(\n    input\n        clk,\n        rst,\n        cmStageFlushUpper,\n        rnStageSendBubbleLower,\n        idStageStallUpper,\n        rnStageFlushUpper,\n        npStageSendBubbleLower,\n        ifStageSendBubbleLower,\n        npStageSendBubbleLowerForInterrupt,\n        isStageStallUpper,\n        ifStageEmpty,\n        pdStageEmpty,\n        idStageEmpty,\n        rnStageEmpty,\n        activeListEmpty,\n    output\n        npStage,\n        ifStage,\n        pdStage,\n        idStage,\n        rnStage,\n        dsStage,\n        isStage,\n        scStage,\n        backEnd,\n        cmStage,\n        stallByDecodeStage,\n        wholePipelineEmpty\n    );\n\n    modport NextPCStage(\n    input\n        npStage,\n    output\n        npStageSendBubbleLower\n    );\n\n    modport FetchStage(\n    input\n        ifStage,\n    output\n        ifStageSendBubbleLower,\n        ifStageEmpty\n    );\n\n    modport DecodeStage(\n    input\n        idStage,\n        stallByDecodeStage,\n    output\n        idStageStallUpper,\n        idStageEmpty\n    );\n\n    modport PreDecodeStage(\n    input\n        pdStage,\n    output\n        pdStageEmpty\n    );\n\n    modport RenameStage(\n    input\n        rnStage,\n    output\n        rnStageFlushUpper,\n        rnStageSendBubbleLower,\n        rnStageEmpty\n    );\n\n    modport DispatchStage(\n    input\n        clk,\n        rst,\n        dsStage\n    );\n\n    modport ScheduleStage(\n    input\n        scStage\n    );\n\n    modport IntegerIssueStage(\n    input\n        isStage,\n        isStageStallUpper\n    );\n\n    modport IntegerRegisterReadStage(\n    input\n        backEnd\n    );\n\n    modport IntegerExecutionStage(\n    input\n        backEnd\n    );\n\n    modport IntegerRegisterWriteStage(\n    input\n        clk,\n        rst,\n        backEnd\n    );\n\n    modport ComplexIntegerIssueStage(\n    input\n        isStage\n    );\n\n    modport ComplexIntegerRegisterReadStage(\n    input\n        backEnd\n    );\n\n    modport ComplexIntegerExecutionStage(\n    input\n        backEnd\n    );\n\n    modport ComplexIntegerRegisterWriteStage(\n    input\n        clk,\n        rst,\n        backEnd\n    );\n\n    modport MemoryIssueStage(\n    input\n        isStage\n    );\n\n    modport MemoryRegisterReadStage(\n    input\n        backEnd\n    );\n\n    modport MemoryExecutionStage(\n    input\n        backEnd\n    );\n\n    modport MemoryTagAccessStage(\n    input\n        backEnd\n    );\n\n    modport MemoryAccessStage(\n    input\n        backEnd\n    );\n\n    modport MemoryRegisterWriteStage(\n    input\n        clk,\n        rst,\n        backEnd\n    );\n\n    modport FPIssueStage(\n    input\n        isStage\n    );\n\n    modport FPRegisterReadStage(\n    input\n        backEnd\n    );\n\n    modport FPExecutionStage(\n    input\n        backEnd\n    );\n\n    modport FPRegisterWriteStage(\n    input\n        clk,\n        rst,\n        backEnd\n    );\n\n    modport CommitStage(\n    input\n        cmStage\n    );\n\n    modport BypassController(\n    input\n        backEnd\n    );\n\n    modport BypassNetwork(\n    input\n        backEnd\n    );\n\n    modport DCache(\n    input\n        backEnd\n    );\n\n    modport LoadStoreUnit(\n    input\n        backEnd\n    );\n\n    modport ReplayQueue(\n    output\n        isStageStallUpper\n    );\n\n    modport BranchPredictor(\n    input\n        ifStage\n    );\n\n    modport RecoveryManager(\n    output\n        cmStageFlushUpper\n    );\n\n    modport ActiveList(\n    output\n        activeListEmpty\n    );\n\n    modport InterruptController(\n    input \n        wholePipelineEmpty,\n    output \n        npStageSendBubbleLowerForInterrupt\n    );\n\nendinterface : ControllerIF\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// ControlQueue\n//\n\n`include \"SysDeps/XilinxMacros.vh\"\n\nimport BasicTypes::*;\nimport MemoryTypes::*;\n\nmodule ControlQueue ( \ninput \n    logic clk,\n    logic rst,\n    logic push,\n    logic pop,\n    logic [ `PS_PL_CTRL_QUEUE_DATA_BIT_SIZE-1:0 ] pushedData,\noutput\n    logic full,\n    logic empty,\n    logic [ `PS_PL_CTRL_QUEUE_DATA_BIT_SIZE-1:0 ] headData\n);\n\n    typedef logic [`PS_PL_CTRL_QUEUE_ADDR_BIT_SIZE-1:0] IndexPath;\n\n    IndexPath headPtr;\n    IndexPath tailPtr;\n\n    // size, initial head, initial tail, initial count\n    QueuePointer #( `PS_PL_CTRL_QUEUE_SIZE, 0, 0, 0 )\n        pointer(\n            .clk( clk ),\n            .rst( rst ),\n            .push( push ),\n            .pop( pop ),\n            .full( full ),\n            .empty( empty ),\n            .headPtr( headPtr ),\n            .tailPtr( tailPtr )\n        );\n        \n\n    logic [ `PS_PL_CTRL_QUEUE_DATA_BIT_SIZE-1:0 ] controlQueue[ `PS_PL_CTRL_QUEUE_SIZE ]; // synthesis syn_ramstyle = \"select_ram\"\n\n    always_ff @( posedge clk ) begin\n        if( push ) begin\n            controlQueue[ tailPtr ] <= pushedData;\n        end\n    end\n    \n    always_comb begin\n        headData = controlQueue[ headPtr ];\n    end\n\nendmodule : ControlQueue\n\n "}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- Core module\n//\n// \u30d7\u30ed\u30bb\u30c3\u30b5\u30fb\u30b3\u30a2\u306b\u542b\u307e\u308c\u308b\u5168\u3066\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3092\u30a4\u30f3\u30b9\u30bf\u30f3\u30b7\u30a8\u30fc\u30c8\u3057\u3001\n// \u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u3067\u63a5\u7d9a\u3059\u308b\n\nimport BasicTypes::*;\nimport CacheSystemTypes::*;\nimport MemoryTypes::*;\nimport MemoryMapTypes::*;\nimport IO_UnitTypes::*;\nimport DebugTypes::*;\n\nmodule Core (\ninput\n    logic clk,\n    logic rst, rstStart,\n    MemAccessSerial nextMemReadSerial, // RSD\u306e\u6b21\u306e\u8aad\u307f\u51fa\u3057\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb(id)\n    MemWriteSerial nextMemWriteSerial, // RSD\u306e\u6b21\u306e\u66f8\u304d\u8fbc\u307f\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb(id)\n    MemoryEntryDataPath memReadData,\n    logic memReadDataReady,\n    MemAccessSerial memReadSerial, // \u30e1\u30e2\u30ea\u306e\u8aad\u307f\u51fa\u3057\u30c7\u30fc\u30bf\u306e\u30b7\u30ea\u30a2\u30eb\n    MemAccessResponse memAccessResponse, // \u30e1\u30e2\u30ea\u66f8\u304d\u8fbc\u307f\u5b8c\u4e86\u901a\u77e5\n    logic memAccessReadBusy,\n    logic memAccessWriteBusy,\n    logic reqExternalInterrupt,\n    ExternalInterruptCodePath externalInterruptCode,\noutput\n    DebugRegister debugRegister,\n    PC_Path lastCommittedPC,\n    PhyAddrPath memAccessAddr,\n    MemoryEntryDataPath memAccessWriteData,\n    logic memAccessRE,\n    logic memAccessWE,\n    logic serialWE,\n    SerialDataPath serialWriteData\n);\n    //\n    // --- For Debug\n    //\n    DebugIF debugIF( clk, rst );\n    PerformanceCounterIF perfCounterIF( clk, rst );\n\n    assign debugRegister = debugIF.debugRegister;\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    Debug debug ( debugIF, lastCommittedPC );\n`else\n    always_ff @(posedge clk) begin\n        lastCommittedPC <= debugIF.lastCommittedPC;\n    end\n`endif\n\n`ifndef RSD_DISABLE_PERFORMANCE_COUNTER\n    PerformanceCounter perfCounter(perfCounterIF, debugIF);\n`endif\n\n    //\n    // --- Interfaces\n    //\n\n    // Pipeline control logic\n    ControllerIF ctrlIF( clk, rst );\n\n    // Pipeline stages\n    NextPCStageIF npStageIF( clk, rst, rstStart );\n    FetchStageIF ifStageIF( clk, rst, rstStart );\n    PreDecodeStageIF pdStageIF( clk, rst );\n    DecodeStageIF idStageIF( clk, rst );\n    RenameStageIF rnStageIF( clk, rst, rstStart );\n    //DispatchStageIF dsStageIF( clk, rst );\n    ScheduleStageIF scStageIF( clk, rst );\n\n    IntegerIssueStageIF intIsStageIF( clk, rst );\n    IntegerRegisterReadStageIF intRrStageIF( clk, rst );\n    IntegerExecutionStageIF intExStageIF( clk, rst );\n    //IntegerRegisterWriteStageIF intRwStageIF( clk, rst );\n\n    ComplexIntegerIssueStageIF complexIsStageIF( clk, rst );\n    ComplexIntegerRegisterReadStageIF complexRrStageIF( clk, rst );\n    ComplexIntegerExecutionStageIF complexExStageIF( clk, rst );\n\n    MemoryIssueStageIF memIsStageIF( clk, rst );\n    MemoryRegisterReadStageIF memRrStageIF( clk, rst );\n    MemoryExecutionStageIF memExStageIF( clk, rst );\n    MemoryTagAccessStageIF mtStageIF( clk, rst );\n    MemoryAccessStageIF maStageIF( clk, rst );\n    //MemoryRegisterWriteStageIF memRwStageIF( clk, rst );\n    \n    FPIssueStageIF fpIsStageIF( clk, rst );\n    FPRegisterReadStageIF fpRrStageIF( clk, rst );\n    FPExecutionStageIF fpExStageIF( clk, rst );\n    FPDivSqrtUnitIF fpDivSqrtUnitIF(clk, rst);\n\n    CommitStageIF cmStageIF( clk, rst );\n\n    // Other interfaces.\n    CacheSystemIF cacheSystemIF( clk, rst );\n    RenameLogicIF renameLogicIF( clk, rst, rstStart );\n    ActiveListIF activeListIF( clk, rst );\n    SchedulerIF schedulerIF( clk, rst, rstStart );\n    WakeupSelectIF wakeupSelectIF( clk, rst, rstStart );\n    RegisterFileIF registerFileIF( clk, rst, rstStart );\n    BypassNetworkIF bypassNetworkIF( clk, rst, rstStart );\n    LoadStoreUnitIF loadStoreUnitIF( clk, rst, rstStart );\n    RecoveryManagerIF recoveryManagerIF( clk, rst );\n    CSR_UnitIF csrUnitIF(clk, rst, rstStart, reqExternalInterrupt, externalInterruptCode);\n    IO_UnitIF ioUnitIF(clk, rst, rstStart, serialWE, serialWriteData);\n    MulDivUnitIF mulDivUnitIF(clk, rst);\n    CacheFlushManagerIF cacheFlushManagerIF(clk, rst);\n\n    //\n    // --- Modules\n    //\n    Controller controller( ctrlIF, debugIF );\n    MemoryAccessController memoryAccessController(\n        .port( cacheSystemIF.MemoryAccessController ),\n        .memAccessAddr( memAccessAddr ),\n        .memAccessWriteData( memAccessWriteData ),\n        .memAccessRE( memAccessRE ),\n        .memAccessWE( memAccessWE ),\n        .memAccessReadBusy( memAccessReadBusy ),\n        .memAccessWriteBusy( memAccessWriteBusy ),\n        .nextMemReadSerial( nextMemReadSerial ),\n        .nextMemWriteSerial( nextMemWriteSerial ),\n        .memReadDataReady( memReadDataReady ),\n        .memReadData( memReadData ),\n        .memReadSerial( memReadSerial ),\n        .memAccessResponse( memAccessResponse )\n    );\n\n\n    NextPCStage npStage( npStageIF, ifStageIF, recoveryManagerIF, ctrlIF, debugIF );\n        PC pc( npStageIF );\n        BTB btb( npStageIF, ifStageIF );\n        BranchPredictor brPred( npStageIF, ifStageIF, ctrlIF );\n    FetchStage ifStage( ifStageIF, npStageIF, ctrlIF, debugIF, perfCounterIF );\n        ICache iCache( npStageIF, ifStageIF, cacheSystemIF );\n    \n    PreDecodeStage pdStage( pdStageIF, ifStageIF, ctrlIF, debugIF );\n    DecodeStage idStage( idStageIF, pdStageIF, ctrlIF, debugIF, perfCounterIF );\n\n    RenameStage rnStage( rnStageIF, idStageIF, renameLogicIF, activeListIF, schedulerIF, loadStoreUnitIF, recoveryManagerIF, ctrlIF, debugIF );\n        RenameLogic renameLogic( renameLogicIF, activeListIF, recoveryManagerIF );\n        RenameLogicCommitter renameLogicCommitter( renameLogicIF, activeListIF, recoveryManagerIF );\n        ActiveList activeList( activeListIF, recoveryManagerIF, ctrlIF, debugIF );\n        RMT rmt_wat( renameLogicIF );\n        RetirementRMT retirementRMT( renameLogicIF );\n        MemoryDependencyPredictor memoryDependencyPredictor( rnStageIF, loadStoreUnitIF );\n    \n    DispatchStage dsStage( /*dsStageIF,*/ rnStageIF, schedulerIF, ctrlIF, debugIF );\n\n    ScheduleStage scStage( scStageIF, schedulerIF, recoveryManagerIF, ctrlIF );\n        IssueQueue issueQueue( schedulerIF, wakeupSelectIF, recoveryManagerIF, debugIF );\n        ReplayQueue replayQueue( schedulerIF, loadStoreUnitIF, mulDivUnitIF, fpDivSqrtUnitIF, cacheFlushManagerIF, recoveryManagerIF, ctrlIF );\n        Scheduler scheduler( schedulerIF, wakeupSelectIF, recoveryManagerIF, mulDivUnitIF, fpDivSqrtUnitIF, debugIF );\n        WakeupPipelineRegister wakeupPipelineRegister( wakeupSelectIF, recoveryManagerIF );\n        DestinationRAM destinationRAM( wakeupSelectIF );\n        WakeupLogic wakeupLogic( wakeupSelectIF );\n        SelectLogic selectLogic( wakeupSelectIF, recoveryManagerIF );\n\n    IntegerIssueStage intIsStage( intIsStageIF, scStageIF, schedulerIF, recoveryManagerIF, ctrlIF, debugIF );\n    IntegerRegisterReadStage intRrStage( intRrStageIF, intIsStageIF, registerFileIF, bypassNetworkIF, recoveryManagerIF, ctrlIF, debugIF );\n    IntegerExecutionStage intExStage( intExStageIF, intRrStageIF, bypassNetworkIF, recoveryManagerIF, ctrlIF, debugIF );\n    IntegerRegisterWriteStage intRwStage( /*intRwStageIF,*/ intExStageIF, schedulerIF, npStageIF, registerFileIF, activeListIF, recoveryManagerIF, ctrlIF, debugIF );\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    ComplexIntegerIssueStage complexIsStage( complexIsStageIF, scStageIF, schedulerIF, recoveryManagerIF, mulDivUnitIF, ctrlIF, debugIF );\n    ComplexIntegerRegisterReadStage complexRrStage( complexRrStageIF, complexIsStageIF, registerFileIF, bypassNetworkIF, recoveryManagerIF, ctrlIF, debugIF );\n    ComplexIntegerExecutionStage complexExStage( complexExStageIF, complexRrStageIF, mulDivUnitIF, schedulerIF, bypassNetworkIF, recoveryManagerIF, ctrlIF, debugIF );\n    ComplexIntegerRegisterWriteStage complexRwStage( complexExStageIF, registerFileIF, activeListIF, recoveryManagerIF, ctrlIF, debugIF );\n`endif\n        MulDivUnit mulDivUnit(mulDivUnitIF, recoveryManagerIF);\n\n    MemoryIssueStage memIsStage( memIsStageIF, scStageIF, schedulerIF, recoveryManagerIF, mulDivUnitIF, ctrlIF, debugIF );\n    MemoryRegisterReadStage memRrStage( memRrStageIF, memIsStageIF, registerFileIF, bypassNetworkIF, recoveryManagerIF, ctrlIF, debugIF );\n    MemoryExecutionStage memExStage( memExStageIF, memRrStageIF, loadStoreUnitIF, cacheFlushManagerIF, mulDivUnitIF, bypassNetworkIF, recoveryManagerIF, ctrlIF, csrUnitIF, debugIF );\n    MemoryTagAccessStage mtStage( mtStageIF, memExStageIF, schedulerIF, loadStoreUnitIF, mulDivUnitIF, recoveryManagerIF, ctrlIF, debugIF, perfCounterIF );\n    MemoryAccessStage maStage( maStageIF, mtStageIF, loadStoreUnitIF, mulDivUnitIF, bypassNetworkIF, ioUnitIF, recoveryManagerIF, ctrlIF, debugIF );\n        LoadStoreUnit loadStoreUnit( loadStoreUnitIF, ctrlIF );\n        LoadQueue loadQueue( loadStoreUnitIF, recoveryManagerIF );\n        StoreQueue storeQueue( loadStoreUnitIF, recoveryManagerIF );\n        StoreCommitter storeCommitter(loadStoreUnitIF, recoveryManagerIF, ioUnitIF, debugIF, perfCounterIF);\n        DCache dCache( loadStoreUnitIF, cacheSystemIF, ctrlIF, recoveryManagerIF);\n    MemoryRegisterWriteStage memRwStage( /*memRwStageIF,*/ maStageIF, loadStoreUnitIF, registerFileIF, activeListIF, recoveryManagerIF, ctrlIF, debugIF );\n\n`ifdef RSD_MARCH_FP_PIPE\n    FPIssueStage fpIsStage( fpIsStageIF, scStageIF, schedulerIF, recoveryManagerIF, fpDivSqrtUnitIF, ctrlIF, debugIF );\n    FPRegisterReadStage fpRrStage( fpRrStageIF, fpIsStageIF, registerFileIF, bypassNetworkIF, recoveryManagerIF, ctrlIF, debugIF );\n    FPExecutionStage fpExStage( fpExStageIF, fpRrStageIF, fpDivSqrtUnitIF, schedulerIF, bypassNetworkIF, recoveryManagerIF, ctrlIF, debugIF, csrUnitIF);\n    FPRegisterWriteStage fpRwStage( fpExStageIF, registerFileIF, activeListIF, recoveryManagerIF, ctrlIF, debugIF );\n    FPDivSqrtUnit fpDivSqrtUnit(fpDivSqrtUnitIF, recoveryManagerIF);\n`endif\n\n    RegisterFile registerFile( registerFileIF );\n        BypassController bypassController( bypassNetworkIF, ctrlIF );\n        BypassNetwork  bypassNetwork( bypassNetworkIF, ctrlIF );\n    \n    // A commitment stage generates a flush signal and this is send to scheduler.\n    CommitStage cmStage( cmStageIF, renameLogicIF, activeListIF, loadStoreUnitIF, recoveryManagerIF, csrUnitIF, debugIF );\n        RecoveryManager recoveryManager( recoveryManagerIF, activeListIF, csrUnitIF, ctrlIF, perfCounterIF );\n\n    CSR_Unit csrUnit(csrUnitIF, perfCounterIF);\n    CacheFlushManager cacheFlushManager( cacheFlushManagerIF, cacheSystemIF );\n    InterruptController interruptCtrl(csrUnitIF, ctrlIF, npStageIF, recoveryManagerIF);\n    IO_Unit ioUnit(ioUnitIF, csrUnitIF);\n\nendmodule : Core\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// 2-read/write set-associative data cache\n//\n\n// --- Uncachable load/store\n// Uncachable loads always receive data from a data bus. They never update cache.\n// Uncachable stores always write data directly to memory. \n// They first receive data from the data bus in a cache line granularity, \n// update the cache line, and then send it back to the data bus. They never update cache.\n//\n// MSHRs play a key role as below:\n// Every uncachable load/store misses in cache and allocates an MSHR.\n// The MSHR issues a memory read request to the data bus in a cache line granularity.\n// A load receives data from the MSHR and deallocates it.\n// A store merges its data and the loaded cache line, and then the MSHR sends the merged data to the data bus.\n//\n// Uncachable stores must firstly load data from a data bus for simplicity of the current implementation, \n// in which the current implementation always send a write request to the AXI data bus in cache line granularity.\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport CacheSystemTypes::*;\nimport OpFormatTypes::*;\nimport MemoryMapTypes::*;\nimport LoadStoreUnitTypes::*;\nimport ActiveListIndexTypes::*;\n\n// Merge stored data and fetched line.\nfunction automatic void MergeStoreDataToLine(\n    output DCacheLinePath dstLine,\n    input DCacheLinePath fetchedLine,\n    input DCacheLinePath storedLine,\n    input logic [DCACHE_LINE_BYTE_NUM-1:0] storedDirty\n);\n    for (int i = 0; i < DCACHE_LINE_BYTE_NUM; i++) begin\n        for (int b = 0; b < 8; b++) begin\n            dstLine[i*8 + b] = storedDirty[i] ? storedLine[i*8 + b] : fetchedLine[i*8 + b];\n        end\n    end\nendfunction\n\n\n\n// To a line address (index+tag) from a full address.\nfunction automatic PhyAddrPath ToLineAddrFromFullAddr(input PhyAddrPath addr);\n    return {\n        addr[PHY_ADDR_WIDTH-1 : DCACHE_LINE_BYTE_NUM_BIT_WIDTH],\n        { DCACHE_LINE_BYTE_NUM_BIT_WIDTH{1'b0} }\n    };\nendfunction\n\n// To a line address (index+tag) part from a full address.\nfunction automatic DCacheLineAddr ToLinePartFromFullAddr(input PhyAddrPath addr);\n    return addr[PHY_ADDR_WIDTH-1 : DCACHE_LINE_BYTE_NUM_BIT_WIDTH];\nendfunction\n\n// To a line index from a full address.\nfunction automatic DCacheIndexPath ToIndexPartFromFullAddr(input PhyAddrPath addr);\n    return addr[PHY_ADDR_WIDTH-DCACHE_TAG_BIT_WIDTH-1 : DCACHE_LINE_BYTE_NUM_BIT_WIDTH];\nendfunction\n\n// To a line tag from a full address.\nfunction automatic DCacheTagPath ToTagPartFromFullAddr(input PhyAddrPath addr);\n    return addr[PHY_ADDR_WIDTH - 1 : PHY_ADDR_WIDTH - DCACHE_TAG_BIT_WIDTH];\nendfunction\n\n// Build a full address from index and tag parts.\nfunction automatic PhyAddrPath BuildFullAddr(input DCacheIndexPath index, input DCacheTagPath tag);\n    return {\n        tag,\n        index,\n        { DCACHE_LINE_BYTE_NUM_BIT_WIDTH{1'b0} }\n    };\nendfunction\n\n// To a part of a line index from a full address.\nfunction automatic DCacheIndexSubsetPath ToIndexSubsetPartFromFullAddr(input PhyAddrPath addr);\n    return addr[DCACHE_LINE_BYTE_NUM_BIT_WIDTH+DCACHE_INDEX_SUBSET_BIT_WIDTH-1 : DCACHE_LINE_BYTE_NUM_BIT_WIDTH];\nendfunction\n\n// 0-cleared MSHR entry.\nfunction automatic MissStatusHandlingRegister ClearedMSHR();\n    MissStatusHandlingRegister mshr;\n    mshr = '0;\n    return mshr;\nendfunction\n\n//\n// Tree-LRU replacement\n// https://en.wikipedia.org/wiki/Pseudo-LRU\n//\n\n// Calculate an evicted way based on the current state.\nfunction automatic DCacheWayPath \nTreeLRU_CalcEvictedWay(DCacheTreeLRU_StatePath state);\n    DCacheWayPath evicted = 0;  // An evicted way number\n    int pos = 0;                // A head position of the current level\n    for (int i = 0; i < DCACHE_WAY_BIT_NUM; i++) begin\n        evicted = (evicted << 1) + (state[pos + evicted] ? 0 : 1);\n        pos += (1 << i);    // Each level has (1<<i) bits\n    end\n    return evicted;\nendfunction\n\n// Calculate an updated bit vector that represents a binary tree of tree-LRU\nfunction automatic DCacheTreeLRU_StatePath\nTreeLRU_CalcUpdatedState(DCacheWayPath way);\n    DCacheTreeLRU_StatePath next = 0;\n    int pos = 0;    // A head position of the current level\n    // A way number bits are scanned from the MSB\n    for (int i = 0; i < DCACHE_WAY_BIT_NUM; i++) begin\n        for (int j = 0; j < (1 << i); j++) begin\n            next[pos + j] = way[DCACHE_WAY_BIT_NUM - 1 - i];    \n        end\n        pos += (1 << i);\n    end\n    return next;\nendfunction\n\n// Calculate a bit vector that represents write enable signals\nfunction automatic DCacheTreeLRU_StatePath\nTreeLRU_CalcWriteEnable(logic weIn, DCacheWayPath way);\n    int pos = 0;\n    int c = 0;  // The next updated pos\n    DCacheTreeLRU_StatePath we = '0;\n    // A way number bits are scanned from the MSB\n    for (int i = 0; i < DCACHE_WAY_BIT_NUM; i++) begin\n        we[pos + c] = weIn;\n        c = (c << 1) + way[DCACHE_WAY_BIT_NUM - 1 - i];\n        pos += (1 << i);\n    end\n    return we;\nendfunction\n\n//\n// Controller to handle the state of DCache.\n//\nmodule DCacheController(DCacheIF.DCacheController port);\n\n    // DCache state\n    DCachePhase regPhase, nextPhase;\n\n    // For flush\n    logic dcFlushReqAck;\n    logic dcFlushComplete;\n    logic mshrBusy;\n    logic loadStoreBusy;\n\n    // DCache phase\n    always_ff @(posedge port.clk) begin\n        if (port.rst) begin\n            regPhase <= DCACHE_PHASE_NORMAL;\n        end\n        else begin\n            regPhase <= nextPhase;\n        end\n    end\n\n    always_comb begin\n        nextPhase = regPhase;\n        dcFlushReqAck = FALSE;\n        dcFlushComplete = FALSE;\n        mshrBusy = FALSE;\n        loadStoreBusy = FALSE;\n\n        case (regPhase)\n        default: begin\n            nextPhase = DCACHE_PHASE_NORMAL;\n        end\n        DCACHE_PHASE_NORMAL: begin\n            for (int i = 0; i < MSHR_NUM; i++) begin\n                if (port.mshrPhase[i] != MSHR_PHASE_INVALID) begin\n                    // MSHRs are not free\n                    mshrBusy = TRUE;\n                end\n            end\n            for (int i = 0; i < DCACHE_LSU_PORT_NUM; i++) begin\n                if (port.lsuCacheGrtReg[i] || port.lsuCacheGrt[i]) begin\n                    // Load or store inflight\n                    loadStoreBusy = TRUE;\n                end\n            end\n\n            // DCache can enter the flush phase when MSHRs are free.\n            // MSHR can be busy when a preceding load of fence.i allocated the MSHR \n            // but was subsequently flushed.\n            dcFlushReqAck = !mshrBusy;\n            if (port.dcFlushReq && dcFlushReqAck) begin\n                nextPhase = DCACHE_PHASE_FLUSH_PROCESSING;\n            end\n        end\n        DCACHE_PHASE_FLUSH_PROCESSING: begin\n            if (port.mshrFlushComplete) begin\n                nextPhase = DCACHE_PHASE_FLUSH_COMPLETE;\n            end\n        end\n        DCACHE_PHASE_FLUSH_COMPLETE: begin\n            dcFlushComplete = TRUE;\n            if (port.flushComplete) begin\n                nextPhase = DCACHE_PHASE_NORMAL;\n            end\n        end\n        endcase\n\n        // DCache -> cacheFlushManagemer\n        port.dcFlushReqAck = dcFlushReqAck;\n        port.dcFlushComplete = dcFlushComplete;\n\n        // DCache controller -> DCache submodules\n        port.dcFlushing = (regPhase == DCACHE_PHASE_FLUSH_PROCESSING);\n    end\n\n    `RSD_ASSERT_CLK(\n        port.clk,\n        !(loadStoreBusy && port.dcFlushReq && dcFlushReqAck),\n        \"Inflight load or store is found on DC flush request acquirement.\"\n    );\n\nendmodule : DCacheController\n\n//\n// The arbiter of the ports of the main memory.\n//\nmodule DCacheMemoryReqPortArbiter(DCacheIF.DCacheMemoryReqPortArbiter port);\n\n    logic req[MSHR_NUM];\n    logic grant[MSHR_NUM];\n    MSHR_IndexPath memInSel;\n    logic memValid;\n\n    always_comb begin\n        // Clear\n        for (int r = 0; r < MSHR_NUM; r++) begin\n            grant[r] = FALSE;\n            req[r] = port.mshrMemReq[r];\n        end\n\n        // Arbitrate\n        memInSel = '0;\n        memValid = FALSE;\n        for (int r = 0; r < MSHR_NUM; r++) begin\n            if (req[r]) begin\n                grant[r] = TRUE;\n                memInSel = r;\n                memValid = TRUE;\n                break;\n            end\n        end\n\n        // Outputs\n        port.memInSel = memInSel;\n        port.memValid = memValid;\n        for (int r = 0; r < MSHR_NUM; r++) begin\n            port.mshrMemGrt[r] = grant[r];\n        end\n    end\n\nendmodule : DCacheMemoryReqPortArbiter\n\n//\n// Multiplexer for a memory signals\n//\n\nmodule DCacheMemoryReqPortMultiplexer(DCacheIF.DCacheMemoryReqPortMultiplexer port);\n\n    MSHR_IndexPath portIn;\n    always_comb begin\n\n        portIn = port.memInSel;\n\n        port.memAddr = port.mshrMemMuxIn[portIn].addr;\n        port.memData = port.mshrMemMuxIn[portIn].data;\n        port.memWE = port.mshrMemMuxIn[portIn].we;\n\n        for (int i = 0; i < MSHR_NUM; i++) begin\n            port.mshrMemMuxOut[i].ack = port.memReqAck;\n            port.mshrMemMuxOut[i].serial = port.memSerial;\n            port.mshrMemMuxOut[i].wserial = port.memWSerial;\n        end\n\n    end\n\nendmodule : DCacheMemoryReqPortMultiplexer\n\n\n//\n// An arbiter of the ports of the tag/data array.\n//\n// \u4ee5\u4e0b2\u30ab\u6240\u304b\u3089\u6765\u308b\u5408\u8a08 R \u500b\u306e\u30a2\u30af\u30bb\u30b9\u8981\u6c42\u306b\u5bfe\u3057\u3066\uff0c\u6700\u5927 DCache \u306e\u30dd\u30fc\u30c8\u5206\u3060\u3051 grant \u3092\u8fd4\u3059\n//   load unit/store unit: port.lsuCacheReq \n//   mshr \u306e\u5168\u30a8\u30f3\u30c8\u30ea:     mshrCacheReq    \n//\n//   cacheArrayInGrant[p]=TRUE or FALSE \n//     \u5272\u308a\u5f53\u3066\u306e\u7d50\u679c\uff0c\u30ad\u30e3\u30c3\u30b7\u30e5\u306e p \u756a\u76ee\u306e\u30dd\u30fc\u30c8\u306b\u8981\u6c42\u304c\u6765\u305f\u304b\u3069\u3046\u304b\n//   cacheArrayInSel[P] = r: \n//     \u4e0a\u8a18\u306e R \u500b \u30ea\u30af\u30a8\u30b9\u30c8\u306e\u3046\u3061\uff0cr \u756a\u76ee \u304c\n//     \u30ad\u30e3\u30c3\u30b7\u30e5\u306e p \u756a\u76ee\u306e\u30dd\u30fc\u30c8\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u305f\n//   cacheArrayOutSel[r] = p: \n//     \u4e0a\u8a18\u306e R \u500b \u30ea\u30af\u30a8\u30b9\u30c8\u306e\u3046\u3061\uff0cr \u756a\u76ee \u304c\n//     \u30ad\u30e3\u30c3\u30b7\u30e5\u306e p \u756a\u76ee\u306e\u30dd\u30fc\u30c8\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u305f\n//\n// \u5178\u578b\u7684\u306b\u306f\uff0c\n//   grant[0]: load, grant[1]: store, grant[2],grant[3]...: mshr\n//\nmodule DCacheArrayPortArbiter(DCacheIF.DCacheArrayPortArbiter port);\n\n    logic req[DCACHE_MUX_PORT_NUM];\n    logic grant[DCACHE_MUX_PORT_NUM];\n\n    DCacheMuxPortIndexPath cacheArrayInSel[DCACHE_ARRAY_PORT_NUM];\n    DCacheArrayPortIndex   cacheArrayOutSel[DCACHE_MUX_PORT_NUM];\n    logic                  cacheArrayInGrant[DCACHE_ARRAY_PORT_NUM];\n\n    always_comb begin\n        // Clear\n        for (int r = 0; r < DCACHE_MUX_PORT_NUM; r++) begin\n            cacheArrayOutSel[r] = '0;\n            grant[r] = FALSE;\n        end\n\n        // Merge inputs.\n        for (int r = 0; r < DCACHE_LSU_PORT_NUM; r++) begin\n            if (port.dcFlushing) begin\n                // Only MSHRs can be processed during flush.\n                req[r] = FALSE;\n            end\n            else begin\n            req[r] = port.lsuCacheReq[r];\n        end\n        end\n        for (int r = 0; r < MSHR_NUM; r++) begin\n            req[r + DCACHE_LSU_PORT_NUM] = port.mshrCacheReq[r];\n        end\n\n        // Arbitrate\n        for (int p = 0; p < DCACHE_ARRAY_PORT_NUM; p++ ) begin\n            cacheArrayInGrant[p] = FALSE;\n            cacheArrayInSel[p] = '0;\n            for (int r = 0; r < DCACHE_MUX_PORT_NUM; r++) begin\n                if (req[r]) begin\n                    req[r] = FALSE;\n                    grant[r] = TRUE;\n                    cacheArrayInSel[p] = r;\n                    cacheArrayOutSel[r] = p;\n                    cacheArrayInGrant[p] = TRUE;\n                    break;\n                end\n            end\n        end\n\n        // Outputs\n        port.cacheArrayInSel = cacheArrayInSel;\n        port.cacheArrayInGrant = cacheArrayInGrant;\n        port.cacheArrayOutSel = cacheArrayOutSel;\n\n        for (int r = 0; r < DCACHE_LSU_PORT_NUM; r++) begin\n            port.lsuCacheGrt[r] = grant[r];\n        end\n        for (int r = 0; r < MSHR_NUM; r++) begin\n            port.mshrCacheGrt[r] = grant[r + DCACHE_LSU_PORT_NUM];\n        end\n    end\n\nendmodule : DCacheArrayPortArbiter\n\n\n\n//\n// Multiplexer for d-cache signals\n//\n// DCacheArrayPortArbiter \u3067\u30a2\u30fc\u30d3\u30c8\u30ec\u30fc\u30b7\u30e7\u30f3\u3057\u305f\u7d50\u679c\u306b\u57fa\u3065\u304d\uff0c\n// DCache \u306e\u5404\u30dd\u30fc\u30c8\u3068 load/store/mshr \u306e\u5404\u30e6\u30cb\u30c3\u30c8\u3092\u30b9\u30a4\u30c3\u30c1\u3059\u308b\uff0e\n// DCache \u30a2\u30af\u30bb\u30b9\u306f\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5316\u3055\u308c\u3066\u3044\u308b\u305f\u3081\uff0c\u30b9\u30a4\u30c3\u30c1\u3082\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u306e\u5404\u30b9\u30c6\u30fc\u30b8\n// \u306b\u3042\u308f\u305b\u3066\u884c\u308f\u308c\u308b\uff0e\n//\nmodule DCacheArrayPortMultiplexer(DCacheIF.DCacheArrayPortMultiplexer port);\n\n    DCacheMuxPortIndexPath portIn;\n    DCacheMuxPortIndexPath portInRegTagStg[DCACHE_ARRAY_PORT_NUM];\n    logic                  portInRegGrantTagStg[DCACHE_ARRAY_PORT_NUM];\n\n    DCacheArrayPortIndex portOutRegTagStg[DCACHE_MUX_PORT_NUM];\n    DCacheArrayPortIndex portOutRegDataStg[DCACHE_MUX_PORT_NUM];\n\n    // \u30a2\u30c9\u30ec\u30b9\u30b9\u30c6\u30fc\u30b8\u3067 LRU/MSHR \u304b\u3089\u5165\u529b\u3055\u308c\u305f\u8981\u6c42\u3092\u30de\u30fc\u30b8\u3057\u305f\u3082\u306e\n    DCachePortMultiplexerIn muxIn[DCACHE_MUX_PORT_NUM];\n\n    // ADDR<>TAG \u306e\u9593\u306b\u3042\u308b\u30ec\u30b8\u30b9\u30bf\n    // \u30de\u30fc\u30b8\u3057\u305f\u8981\u6c42\u3092\u30a2\u30fc\u30d3\u30c8\u30ec\u30fc\u30b7\u30e7\u30f3\u3057\u3066\u9078\u3093\u3060\u7d50\u679c\n    DCachePortMultiplexerIn muxInReg[DCACHE_ARRAY_PORT_NUM];    // DCACHE_ARRAY_PORT_NUM!\n\n    DCachePortMultiplexerTagOut muxTagOut[DCACHE_MUX_PORT_NUM];\n    DCachePortMultiplexerDataOut muxDataOut[DCACHE_MUX_PORT_NUM];\n\n    logic tagHit[DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n    logic mshrConflict[DCACHE_ARRAY_PORT_NUM];\n\n    logic mshrAddrHit[DCACHE_ARRAY_PORT_NUM];\n    MSHR_IndexPath mshrAddrHitMSHRID[DCACHE_ARRAY_PORT_NUM];\n    logic mshrReadHit[DCACHE_ARRAY_PORT_NUM];\n    DCacheLinePath mshrReadData[DCACHE_ARRAY_PORT_NUM];\n    DCacheLinePath portMSHRData[MSHR_NUM];\n\n    logic           repIsHit[DCACHE_ARRAY_PORT_NUM];\n    DCacheWayPath   repHitWay[DCACHE_ARRAY_PORT_NUM];\n\n    // *** Hack for Synplify...\n    // Signals in an interface are set to temporally signals for avoiding\n    // errors outputted by Synplify.\n    DCacheTagPath   tagArrayDataOutTmp[DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n    logic           tagArrayValidOutTmp[DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n    logic           dataArrayDirtyOutTmp[DCACHE_ARRAY_PORT_NUM];\n    DCacheLinePath  dataArrayDataOutTmp[DCACHE_ARRAY_PORT_NUM];\n    DCacheWayPath   replArrayDataOutTmp[DCACHE_ARRAY_PORT_NUM];\n\n    // \u7f6e\u304d\u63db\u3048\u60c5\u5831\u306e\u30a4\u30f3\u30c7\u30af\u30b9\u304c\u88ab\u3063\u3066\u308b\u304b\u3069\u3046\u304b\n    logic isReplSameIndex[DCACHE_ARRAY_PORT_NUM];\n\n    always_ff @(posedge port.clk) begin\n\n\n        for (int i = 0; i < DCACHE_ARRAY_PORT_NUM; i++) begin\n            if (port.rst) begin\n                portInRegTagStg[i] <= '0;\n                muxInReg[i] <= '0;\n                portInRegGrantTagStg[i] <= FALSE;\n            end\n            else begin\n                portInRegTagStg[i] <= port.cacheArrayInSel[i];\n                muxInReg[i] <= muxIn[ port.cacheArrayInSel[i] ];\n                portInRegGrantTagStg[i] <= port.cacheArrayInGrant[i];\n            end\n\n        end\n\n        for (int i = 0; i < DCACHE_MUX_PORT_NUM; i++) begin\n            if (port.rst) begin\n                portOutRegTagStg[i] <= '0;\n                portOutRegDataStg[i] <= '0;\n            end\n            else begin\n                portOutRegTagStg[i] <= port.cacheArrayOutSel[i];\n                portOutRegDataStg[i] <= portOutRegTagStg[i];\n            end\n        end\n    end\n\n\n    always_comb begin\n\n        // Merge inputs.\n        for (int r = 0; r < DCACHE_LSU_PORT_NUM; r++) begin\n            muxIn[r] = port.lsuMuxIn[r];\n        end\n        for (int r = 0; r < MSHR_NUM; r++) begin\n            muxIn[r + DCACHE_LSU_PORT_NUM] = port.mshrCacheMuxIn[r];\n        end\n\n        for (int r = 0; r < MSHR_NUM; r++) begin\n            portMSHRData[r] = port.mshrData[r];\n        end\n\n\n        //\n        // stage:   | ADDR    | D$TAG    | D$DATA   |\n        // process: | arbiter |          |          |\n        //          | tag-in  | tag-out  |          |\n        //          |         | hit/miss |          |\n        //          |         | data-in  | data-out |\n        //          |         | repl-in  | repl-out |\n        //\n        // Pipeline regs between ADDR<>D$TAG:   portInRegTagStg, portOutRegTagStg, muxInReg\n        // Pipeline regs between D$TAG<>D$DATA: portOutRegDataStg\n        //\n\n        // --- Address calculation stage (ADDR, MemoryExecutionStage).\n        // Tag array inputs\n        for (int p = 0; p < DCACHE_ARRAY_PORT_NUM; p++) begin\n            portIn = port.cacheArrayInSel[p];\n            port.tagArrayWE[p]       = muxIn[ portIn ].tagWE;\n            port.tagArrayWriteWay[p] = muxIn[ portIn ].evictWay;\n            port.tagArrayIndexIn[p]  = muxIn[ portIn ].indexIn;\n            port.tagArrayDataIn[p]   = muxIn[ portIn ].tagDataIn;\n            port.tagArrayValidIn[p]  = muxIn[ portIn ].tagValidIn;\n        end\n\n        // --- Tag access stage (D$TAG, MemoryTagAccessStage).\n        tagArrayDataOutTmp = port.tagArrayDataOut;\n        tagArrayValidOutTmp = port.tagArrayValidOut;\n\n        // Hit/miss detection\n        for (int p = 0; p < DCACHE_ARRAY_PORT_NUM; p++) begin\n            mshrConflict[p] = FALSE;\n            mshrReadHit[p] = FALSE;\n            mshrAddrHit[p] = FALSE;\n            mshrAddrHitMSHRID[p] = '0;\n            mshrReadData[p] = '0;\n            for (int m = 0; m < MSHR_NUM; m++) begin\n                if (port.mshrValid[m] &&\n                    muxInReg[p].indexIn == ToIndexPartFromFullAddr(port.mshrAddr[m])\n                ) begin\n                    mshrConflict[p] = TRUE;\n\n                    // When request addr hits mshr,\n                    // 1. the mshr allocator load must bypass data from MSHR,\n                    // 2. other loads can bypass data from MSHR if possible.\n                    if (muxInReg[p].tagDataIn == ToTagPartFromFullAddr(port.mshrAddr[m])) begin\n                        // To bypass data from MSHR.\n                        if (port.mshrPhase[m] >= MSHR_PHASE_MISS_WRITE_CACHE_REQUEST) begin\n                        //if (port.mshrPhase[m] >= MSHR_PHASE_MISS_WRITE_CACHE_REQUEST) begin\n                            mshrReadHit[p] = TRUE;\n                        end\n                        mshrAddrHit[p] = TRUE;\n                        mshrAddrHitMSHRID[p] = m;\n                        mshrReadData[p] = portMSHRData[m];\n                    end\n                end\n            end\n\n            repHitWay[p] = '0;\n            repIsHit[p] = FALSE;\n            for (int way = 0; way < DCACHE_WAY_NUM; way++) begin\n                tagHit[way][p] =\n                    (tagArrayDataOutTmp[way][p] == muxInReg[p].tagDataIn) &&\n                    tagArrayValidOutTmp[way][p] &&\n                    !mshrConflict[p];\n                if (tagHit[way][p]) begin\n                    repHitWay[p] = way;\n                    repIsHit[p] = TRUE;\n                end\n            end\n        end\n\n        // Tag array outputs\n        for (int r = 0; r < DCACHE_MUX_PORT_NUM; r++) begin\n            for (int w = 0; w < DCACHE_WAY_NUM; w++) begin\n                muxTagOut[r].tagDataOut[w] = tagArrayDataOutTmp[w][ portOutRegTagStg[r] ];\n                muxTagOut[r].tagValidOut[w] = tagArrayValidOutTmp[w][ portOutRegTagStg[r] ];\n            end\n            muxTagOut[r].tagHit = repIsHit[portOutRegTagStg[r]];\n            muxTagOut[r].mshrConflict = mshrConflict[ portOutRegTagStg[r] ];\n            muxTagOut[r].mshrReadHit = mshrReadHit[ portOutRegTagStg[r] ];\n            muxTagOut[r].mshrAddrHit = mshrAddrHit[ portOutRegTagStg[r] ];\n            muxTagOut[r].mshrAddrHitMSHRID = mshrAddrHitMSHRID[ portOutRegTagStg[r] ];\n            muxTagOut[r].mshrReadData = mshrReadData[ portOutRegTagStg[r] ];\n        end\n\n\n        // Data array inputs\n        for (int p = 0; p < DCACHE_ARRAY_PORT_NUM; p++) begin\n            port.dataArrayDataIn[p]    = muxInReg[p].dataDataIn;\n            port.dataArrayDirtyIn[p]   = muxInReg[p].dataDirtyIn;\n            port.dataArrayWriteWay[p]  = muxInReg[p].tagWE ? muxInReg[p].evictWay : repHitWay[p];\n\n            // If dataArrayDoesReadEvictedWay is valid, instead of a way of dataArrayReadWay, \n            // a way specified by a replacement algorithm is read for eviction.\n            port.dataArrayDoesReadEvictedWay[p] = muxInReg[p].isVictimEviction;\n            port.dataArrayReadWay[p] = repHitWay[p];\n            \n            port.dataArrayByteWE_In[p] = muxInReg[p].dataByteWE;\n            port.dataArrayWE[p] =\n                muxInReg[p].dataWE || (muxInReg[p].dataWE_OnTagHit && repIsHit[p]);\n            port.dataArrayIndexIn[p]   = muxInReg[p].indexIn;\n        end\n\n        // \u7f6e\u304d\u63db\u3048\u60c5\u5831\u306e\u66f4\u65b0\n        for (int p = 0; p < DCACHE_ARRAY_PORT_NUM; p++) begin\n            isReplSameIndex[p]"}
{"text": " = FALSE;\n\n            for (int i = 0; i < p; i++) begin\n                if (muxInReg[i].indexIn == muxInReg[p].indexIn) begin\n                    isReplSameIndex[p] = TRUE;\n                end\n            end\n\n            port.replArrayIndexIn[p] = muxInReg[p].indexIn;\n            port.replArrayDataIn[p] = 0;\n            if (isReplSameIndex[p]) begin\n                port.replArrayWE[p] = FALSE;\n            end\n            else begin\n                if (muxInReg[p].tagWE) begin\n                    // \u66f8\u304d\u8fbc\u307f\u6642\u306f\u8ffd\u3044\u51fa\u3057\u5bfe\u8c61\u306e\u30a6\u30a7\u30a4\u3092\u6e21\u3059\n                    port.replArrayWE[p] = TRUE;\n                    port.replArrayDataIn[p] = muxInReg[p].evictWay;\n                end\n                else if (muxInReg[p].isVictimEviction) begin\n                    // MSHR \u304b\u3089\u306e victim \u8aad\u307f\u51fa\u3057\u6642\u306f\uff0c\u7f6e\u304d\u63db\u3048\u60c5\u5831\u306e\u8aad\u307f\u51fa\u3057\n                    port.replArrayWE[p] = FALSE;    \n                end\n                else begin\n                    // \u30d2\u30c3\u30c8\u6642\u306f\u30d2\u30c3\u30c8\u3057\u305f\u30a6\u30a7\u30a4\u3092\u6e21\u3059\n                    port.replArrayWE[p] = repIsHit[p];\n                    port.replArrayDataIn[p] = repHitWay[p];\n                end\n            end\n        end\n\n\n        // ---Data array access stage (D$DATA, MemoryAccessStage).\n        // Data array outputs\n        dataArrayDataOutTmp = port.dataArrayDataOut;\n        dataArrayDirtyOutTmp = port.dataArrayDirtyOut;\n        replArrayDataOutTmp = port.replArrayDataOut;\n        for (int r = 0; r < DCACHE_MUX_PORT_NUM; r++) begin\n            muxDataOut[r].dataDataOut = dataArrayDataOutTmp[ portOutRegDataStg[r] ];\n            muxDataOut[r].dataDirtyOut = dataArrayDirtyOutTmp[ portOutRegDataStg[r] ];\n            muxDataOut[r].replDataOut = replArrayDataOutTmp[ portOutRegDataStg[r] ];\n        end\n    end\n\n    // Output to each port.\n    always_comb begin\n        for (int r = 0; r < DCACHE_LSU_PORT_NUM; r++) begin\n            port.lsuMuxTagOut[r] = muxTagOut[r];\n            port.lsuMuxDataOut[r] = muxDataOut[r];\n        end\n        for (int r = 0; r < MSHR_NUM; r++) begin\n            port.mshrCacheMuxTagOut[r] = muxTagOut[r + DCACHE_LSU_PORT_NUM];\n            port.mshrCacheMuxDataOut[r] = muxDataOut[r + DCACHE_LSU_PORT_NUM];\n        end\n    end\n\nendmodule : DCacheArrayPortMultiplexer\n\n\n//\n// Tag/data/dirty bits array.\n//\nmodule DCacheArray(DCacheIF.DCacheArray port);\n    // Data array signals\n    logic dataArrayWE[DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n    logic dataArrayByteWE[DCACHE_LINE_BYTE_NUM][DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n    DCacheIndexPath dataArrayIndex[DCACHE_ARRAY_PORT_NUM];\n    BytePath        dataArrayIn[DCACHE_LINE_BYTE_NUM][DCACHE_ARRAY_PORT_NUM];\n    BytePath        dataArrayOut[DCACHE_LINE_BYTE_NUM][DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n    logic           dataArrayDirtyIn[DCACHE_ARRAY_PORT_NUM];\n    logic           dataArrayDirtyOut[DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n    DCacheWayPath   dataArrayReadWayReg[DCACHE_ARRAY_PORT_NUM];\n    DCacheWayPath   dataArrayReadWay[DCACHE_ARRAY_PORT_NUM];\n    logic           dataArrayDoesReadEvictedWayReg[DCACHE_ARRAY_PORT_NUM];\n\n    // *** Hack for Synplify...\n    DCacheByteEnablePath dataArrayByteWE_Tmp[DCACHE_ARRAY_PORT_NUM];\n    DCacheLinePath dataArrayInTmp[DCACHE_ARRAY_PORT_NUM];\n    DCacheLinePath dataArrayOutTmp[DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n\n    // Tag array signals\n    logic tagArrayWE[DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n    DCacheIndexPath tagArrayIndex[DCACHE_ARRAY_PORT_NUM];\n    DCacheTagValidPath tagArrayIn[DCACHE_ARRAY_PORT_NUM];\n    DCacheTagValidPath tagArrayOut[DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n    // Temporal signals for Vivado\n    logic [$bits(DCacheTagValidPath)-1:0] tagArrayOutTmp[DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n\n    // Replacement array signals\n    logic replArrayWE[DCACHE_TREE_LRU_STATE_BIT_NUM][DCACHE_ARRAY_PORT_NUM];\n    DCacheTreeLRU_StatePath replArrayWE_Flat[DCACHE_ARRAY_PORT_NUM];\n    DCacheIndexPath replArrayIndex[DCACHE_ARRAY_PORT_NUM];\n    logic replArrayIn[DCACHE_TREE_LRU_STATE_BIT_NUM][DCACHE_ARRAY_PORT_NUM];\n    DCacheTreeLRU_StatePath replArrayInFlat[DCACHE_ARRAY_PORT_NUM];\n    logic replArrayOut[DCACHE_TREE_LRU_STATE_BIT_NUM][DCACHE_ARRAY_PORT_NUM];\n    DCacheTreeLRU_StatePath replArrayOutFlat[DCACHE_ARRAY_PORT_NUM];\n    DCacheWayPath replArrayResult[DCACHE_ARRAY_PORT_NUM];\n\n    // Reset signals\n    DCacheIndexPath rstIndex;\n\n    always_ff @(posedge port.clk) begin\n        if (port.rstStart)\n            rstIndex <= '0;\n        else\n            rstIndex <= rstIndex + 1;\n\n        // \u30c7\u30fc\u30bf\u30a2\u30ec\u30a4\u304b\u3089\u8aad\u307f\u51fa\u3057\u305f\u5f8c\u306b\u9078\u629e\u3059\u308b way \u306f1\u30b5\u30a4\u30af\u30eb\u524d\u306b\u304f\u308b\u306e\u3067 FF \u306b\u3064\u3093\u3067\u304a\u304f\n        for (int p = 0; p < DCACHE_ARRAY_PORT_NUM; p++) begin\n            if (port.rst) begin\n                dataArrayReadWayReg[p] <= '0;\n                dataArrayDoesReadEvictedWayReg[p] <= '0;\n            end\n            else begin\n                dataArrayReadWayReg[p] <= port.dataArrayReadWay[p];\n                dataArrayDoesReadEvictedWayReg[p] <= port.dataArrayDoesReadEvictedWay[p];\n            end\n        end\n    end\n\n\n    generate\n        for (genvar way = 0; way < DCACHE_WAY_NUM; way++) begin\n            // Data array instance\n            for (genvar i = 0; i < DCACHE_LINE_BYTE_NUM; i++) begin\n                BlockTrueDualPortRAM #(\n                    .ENTRY_NUM( DCACHE_INDEX_NUM ),\n                    .ENTRY_BIT_SIZE( $bits(BytePath) )\n                    //.PORT_NUM( DCACHE_ARRAY_PORT_NUM )\n                ) dataArray (\n                    .clk( port.clk ),\n                    .we( dataArrayByteWE[i][way] ),\n                    .rwa( dataArrayIndex ),\n                    .wv( dataArrayIn[i] ),\n                    .rv( dataArrayOut[i][way] )\n                );\n            end\n\n            // Dirty array instance\n            // The dirty array is synchronized with the data array.\n            BlockTrueDualPortRAM #(\n                .ENTRY_NUM( DCACHE_INDEX_NUM ),\n                .ENTRY_BIT_SIZE( 1 )\n                //.PORT_NUM( DCACHE_ARRAY_PORT_NUM )\n            ) dirtyArray (\n                .clk( port.clk ),\n                .we( dataArrayWE[way] ),\n                .rwa( dataArrayIndex ),\n                .wv( dataArrayDirtyIn ),\n                .rv( dataArrayDirtyOut[way] )\n            );\n\n            // Tag array instance\n            BlockTrueDualPortRAM #(\n                .ENTRY_NUM( DCACHE_INDEX_NUM ),\n                .ENTRY_BIT_SIZE( $bits(DCacheTagValidPath) )\n                //.PORT_NUM( DCACHE_ARRAY_PORT_NUM )\n            ) tagArray (\n                .clk( port.clk ),\n                .we( tagArrayWE[way] ),\n                .rwa( tagArrayIndex ),\n                .wv( tagArrayIn ),\n                .rv( tagArrayOutTmp[way] )\n            );\n        end\n\n        // Replacement array instance\n        // This array is not used when the number of ways is oen.\n        for (genvar i = 0; i < DCACHE_TREE_LRU_STATE_BIT_NUM; i++) begin\n            BlockTrueDualPortRAM #(\n                .ENTRY_NUM( DCACHE_INDEX_NUM ),\n                .ENTRY_BIT_SIZE(1)\n                //.PORT_NUM( DCACHE_ARRAY_PORT_NUM )\n            ) replArray (\n                .clk( port.clk ),\n                .we( replArrayWE[i] ),\n                .rwa( replArrayIndex ),\n                .wv( replArrayIn[i] ),\n                .rv( replArrayOut[i] )\n            );\n        end\n    endgenerate\n\n\n    always_comb begin\n\n        // Replacement signals\n        //\n        for (int p = 0; p < DCACHE_ARRAY_PORT_NUM; p++) begin\n            replArrayIndex[p] = port.replArrayIndexIn[p];\n            replArrayWE_Flat[p] = TreeLRU_CalcWriteEnable(port.replArrayWE[p], port.replArrayDataIn[p]);\n            replArrayInFlat[p] = TreeLRU_CalcUpdatedState(port.replArrayDataIn[p]);\n            // Since the replacement information is stored in a different array \n            // for each bit, the bit order is exchanged.\n            for (int i = 0; i < DCACHE_TREE_LRU_STATE_BIT_NUM; i++) begin\n                replArrayWE[i][p] = replArrayWE_Flat[p][i];\n                replArrayIn[i][p] = replArrayInFlat[p][i];\n                replArrayOutFlat[p][i] = replArrayOut[i][p];    \n            end\n            // Do not use the output of replArray\n            replArrayResult[p] = (DCACHE_WAY_NUM == 1) ? 0 : TreeLRU_CalcEvictedWay(replArrayOutFlat[p]);\n            port.replArrayDataOut[p] = replArrayResult[p];\n        end\n\n        // Data array signals\n        for (int p = 0; p < DCACHE_ARRAY_PORT_NUM; p++) begin\n            dataArrayIndex[p] = port.dataArrayIndexIn[p];\n            dataArrayDirtyIn[p] = port.dataArrayDirtyIn[p];\n            for (int way = 0; way < DCACHE_WAY_NUM; way++) begin\n                dataArrayWE[way][p] = (port.dataArrayWriteWay[p] == way) ? port.dataArrayWE[p] : FALSE;\n            end\n        end\n\n        // *** Hack for Synplify...\n        // Signals in an interface must be connected to temporal signals for avoiding\n        // errors outputted by Synplify.\n        dataArrayByteWE_Tmp = port.dataArrayByteWE_In;\n        dataArrayInTmp = port.dataArrayDataIn;\n\n\n        // *** Hack for Vivado...\n        // Assign temporal signal from tagArray\n        tagArrayOut = tagArrayOutTmp;\n\n        for (int p = 0; p < DCACHE_ARRAY_PORT_NUM; p++) begin\n            for (int i = 0; i < DCACHE_LINE_BYTE_NUM; i++) begin\n                for (int way = 0; way < DCACHE_WAY_NUM; way++) begin\n                    dataArrayByteWE[i][way][p] = dataArrayWE[way][p] && dataArrayByteWE_Tmp[p][i];\n                end\n                for (int b = 0; b < 8; b++) begin\n                    dataArrayIn[i][p][b] = dataArrayInTmp[p][i*8 + b];\n                    for (int way = 0; way < DCACHE_WAY_NUM; way++) begin\n                        dataArrayOutTmp[way][p][i*8 + b] = dataArrayOut[i][way][p][b];\n                    end\n                end\n            end\n        end\n\n        // Way select\n        for (int p = 0; p < DCACHE_ARRAY_PORT_NUM; p++) begin\n            dataArrayReadWay[p] = \n                dataArrayDoesReadEvictedWayReg[p] ? replArrayResult[p] : dataArrayReadWayReg[p];\n            port.dataArrayDataOut[p] = dataArrayOutTmp[dataArrayReadWay[p]][p];\n            port.dataArrayDirtyOut[p] = dataArrayDirtyOut[dataArrayReadWay[p]][p];\n        end\n\n\n        // Tag signals\n        for (int p = 0; p < DCACHE_ARRAY_PORT_NUM; p++) begin\n            tagArrayIndex[p]    = port.tagArrayIndexIn[p];\n            tagArrayIn[p].tag   = port.tagArrayDataIn[p];\n            tagArrayIn[p].valid = port.tagArrayValidIn[p];\n\n            for (int way = 0; way < DCACHE_WAY_NUM; way++) begin\n                tagArrayWE[way][p] = \n                    port.tagArrayWE[p] && (way == port.tagArrayWriteWay[p]);\n\n                port.tagArrayDataOut[way][p]  = tagArrayOut[way][p].tag;\n                port.tagArrayValidOut[way][p] = tagArrayOut[way][p].valid;\n            end\n        end\n\n        // Reset\n        if (port.rst) begin\n            for (int p = 0; p < DCACHE_ARRAY_PORT_NUM; p++) begin\n                for (int way = 0; way < DCACHE_WAY_NUM; way++) begin\n                    for (int i = 0; i < DCACHE_LINE_BYTE_NUM; i++) begin\n                        dataArrayByteWE[i][way][p] = FALSE;\n                    end\n                    tagArrayWE[way][p] = FALSE;\n                end\n            end\n\n            // Port 0 is used for reset.\n            for (int i = 0; i < DCACHE_LINE_BYTE_NUM; i++) begin\n                for (int way = 0; way < DCACHE_WAY_NUM; way++) begin\n                    dataArrayByteWE[i][way][0] = TRUE;\n                end\n                dataArrayIn[i][0] = 8'hcd;\n            end\n            for (int way = 0; way < DCACHE_WAY_NUM; way++) begin\n                dataArrayWE[way][0] = TRUE;\n            end\n            dataArrayIndex[0] = rstIndex;\n            dataArrayDirtyIn[0] = FALSE;\n\n            tagArrayIndex[0] = rstIndex;\n            for (int way = 0; way < DCACHE_WAY_NUM; way++) begin\n                tagArrayWE[way][0] = TRUE;\n            end\n            tagArrayIn[0].tag = 0;\n            tagArrayIn[0].valid = FALSE;\n\n            replArrayIndex[0] = rstIndex;\n            for (int i = 0; i < DCACHE_TREE_LRU_STATE_BIT_NUM; i++) begin\n                replArrayWE[i][0] = TRUE;\n                replArrayInFlat[0] = 0;\n                replArrayIn[i][0] = 0;\n            end\n        end\n    end\n\nendmodule : DCacheArray\n\n//\n// Data cache main module.\n//\nmodule DCache(\n    LoadStoreUnitIF.DCache lsu,\n    CacheSystemIF.DCache cacheSystem,\n    ControllerIF.DCache ctrl,\n    RecoveryManagerIF.DCacheMissHandler recovery    // connected to DCacheMissHandler\n);\n\n    logic hit[DCACHE_LSU_PORT_NUM];\n    logic missReq[DCACHE_LSU_PORT_NUM];\n    PhyAddrPath missAddr[DCACHE_LSU_PORT_NUM];\n    logic missIsUncachable[DCACHE_LSU_PORT_NUM];\n    ActiveListIndexPath missActiveListPtr[DCACHE_LSU_PORT_NUM];\n\n\n    // Tag array\n    DCacheIF port(lsu.clk, lsu.rst, lsu.rstStart);\n\n    DCacheController controller(port);\n\n    DCacheArray array(port);\n    DCacheArrayPortArbiter arrayArbiter(port);\n    DCacheArrayPortMultiplexer arrayMux(port);\n\n    DCacheMemoryReqPortArbiter memArbiter(port);\n    DCacheMemoryReqPortMultiplexer memMux(port);\n\n    DCacheMissHandler missHandler(port, recovery);\n\n\n    // Stored data\n    DCacheLinePath storedLineData;\n    logic [DCACHE_LINE_BYTE_NUM-1:0] storedLineByteWE;\n\n    // Pipeline registers\n    //\n    // ----------------------------->\n    // ADDR  | D$TAG | D$DATA  | WB\n    //       |       | D$REP-U |\n    //       |  LSQ  |         |\n    // Addresses are input to the tag array in the ADDR stage (MemoryExecutionStage).\n    // D$REP-W is replacement information update\n    //\n    PhyAddrPath dcReadAddrRegTagStg[DCACHE_LSU_READ_PORT_NUM];\n    PhyAddrPath dcReadAddrRegDataStg[DCACHE_LSU_READ_PORT_NUM];\n    logic dcReadReqReg[DCACHE_LSU_READ_PORT_NUM];\n    logic lsuCacheGrtReg[DCACHE_LSU_PORT_NUM];\n    logic dcReadUncachableReg[DCACHE_LSU_READ_PORT_NUM];\n    ActiveListIndexPath dcReadActiveListPtrReg[DCACHE_LSU_READ_PORT_NUM];\n\n    logic dcWriteReqReg;\n    PhyAddrPath dcWriteAddrReg;\n    logic dcWriteUncachableReg;\n\n\n    logic lsuLoadHasAllocatedMSHR[DCACHE_LSU_READ_PORT_NUM];\n    MSHR_IndexPath lsuLoadMSHRID[DCACHE_LSU_READ_PORT_NUM];\n    logic lsuStoreHasAllocatedMSHR[DCACHE_LSU_WRITE_PORT_NUM];\n    MSHR_IndexPath lsuStoreMSHRID[DCACHE_LSU_WRITE_PORT_NUM];\n\n    // MSHR\u304b\u3089\u306eLoad\n    logic lsuMSHRAddrHit[DCACHE_LSU_READ_PORT_NUM];\n    MSHR_IndexPath lsuMSHRAddrHitMSHRID[DCACHE_LSU_READ_PORT_NUM];\n    logic lsuMSHRReadHit[DCACHE_LSU_READ_PORT_NUM];\n    DCacheLinePath lsuMSHRReadData[DCACHE_LSU_READ_PORT_NUM];\n\n    //\n    logic lsuMakeMSHRCanBeInvalidDirect[MSHR_NUM];\n\n`ifndef RSD_SYNTHESIS\n    `ifndef RSD_VIVADO_SIMULATION\n        // Don't care these values, but avoiding undefined status in Questa.\n        initial begin\n            for (int i = 0; i < DCACHE_LSU_READ_PORT_NUM; i++) begin\n                dcReadAddrRegTagStg[i] = '0;\n                dcReadAddrRegDataStg[i] = '0;\n                dcReadUncachableReg[i] = '0;\n                dcReadActiveListPtrReg[i] = '0;\n            end\n            dcWriteAddrReg = '0;\n            dcWriteUncachableReg = '0;\n        end\n    `endif\n`endif\n\n    always_ff @(posedge port.clk) begin\n        if (port.rst) begin\n            for (int i = 0; i < DCACHE_LSU_READ_PORT_NUM; i++) begin\n                dcReadReqReg[i] <= FALSE;\n            end\n            for (int i = 0; i < DCACHE_LSU_PORT_NUM; i++) begin\n                lsuCacheGrtReg[i] <= FALSE;\n            end\n            dcWriteReqReg <= '0;\n        end\n        else begin\n            lsuCacheGrtReg <= port.lsuCacheGrt;\n\n            for (int i = 0; i < DCACHE_LSU_READ_PORT_NUM; i++) begin\n                dcReadReqReg[i] <= lsu.dcReadReq[i];\n                dcReadAddrRegTagStg[i] <= lsu.dcReadAddr[i];\n                dcReadUncachableReg[i] <= lsu.dcReadUncachable[i];\n                dcReadActiveListPtrReg[i] <= lsu.dcReadActiveListPtr[i];\n            end\n\n            dcReadAddrRegDataStg <= dcReadAddrRegTagStg;\n\n            dcWriteReqReg <= lsu.dcWriteReq;\n            dcWriteAddrReg <= lsu.dcWriteAddr;\n            dcWriteUncachableReg <= lsu.dcWriteUncachable;\n        end\n    end\n\n    `RSD_STATIC_ASSERT(\n        $bits(LSQ_BlockDataPath) <= $bits(DCacheLinePath), \n        \"The width of a DCache line must be same or greater than that of an LSQ block.\"\n    );\n\n    always_comb begin\n\n        // --- In the address execution stage (MemoryExecutionStage)\n        // Load request\n        for (int i = 0; i < DCACHE_LSU_READ_PORT_NUM; i++) begin\n\n            port.lsuCacheReq[(i+DCACHE_LSU_READ_PORT_BEGIN)] = lsu.dcReadReq[i];\n            port.lsuMuxIn[(i+DCACHE_LSU_READ_PORT_BEGIN)].tagWE = FALSE;\n            port.lsuMuxIn[(i+DCACHE_LSU_READ_PORT_BEGIN)].indexIn = ToIndexPartFromFullAddr(lsu.dcReadAddr[i]);\n            port.lsuMuxIn[(i+DCACHE_LSU_READ_PORT_BEGIN)].tagDataIn = ToTagPartFromFullAddr(lsu.dcReadAddr[i]);\n            port.lsuMuxIn[(i+DCACHE_LSU_READ_PORT_BEGIN)].tagValidIn = TRUE;\n            port.lsuMuxIn[(i+DCACHE_LSU_READ_PORT_BEGIN)].dataDataIn = '0;\n            port.lsuMuxIn[(i+DCACHE_LSU_READ_PORT_BEGIN)].dataByteWE = '0;\n            port.lsuMuxIn[(i+DCACHE_LSU_READ_PORT_BEGIN)].dataWE = FALSE;\n            port.lsuMuxIn[(i+DCACHE_LSU_READ_PORT_BEGIN)].dataWE_OnTagHit = FALSE;\n            port.lsuMuxIn[(i+DCACHE_LSU_READ_PORT_BEGIN)].dataDirtyIn = FALSE;\n            port.lsuMuxIn[(i+DCACHE_LSU_READ_PORT_BEGIN)].evictWay = '0;\n            port.lsuMuxIn[(i+DCACHE_LSU_READ_PORT_BEGIN)].isVictimEviction = FALSE;\n            port.lsuMuxIn[(i+DCACHE_LSU_READ_PORT_BEGIN)].isFlushReq = FALSE;\n        end\n\n        // --- In the tag access stage (MemoryTagAccessStage)\n        // Hit/miss detection\n        for (int i = 0; i < DCACHE_LSU_READ_PORT_NUM; i++) begin\n            hit[i] = FALSE;\n            if (port.lsuMuxTagOut[(i+DCACHE_LSU_READ_PORT_BEGIN)].tagHit && lsuCacheGrtReg[(i+DCACHE_LSU_READ_PORT_BEGIN)]) begin\n                hit[i] = TRUE;\n            end\n        end\n\n        //\n        // --- In the data array access stage.\n        // Load data from a cache line.\n        //\n        for (int i = 0; i < DCACHE_LSU_READ_PORT_NUM; i++) begin\n            // Read data address is aligned to word boundary in ReadDataFromLine.\n            lsu.dcReadData[i] = port.lsuMuxDataOut[i].dataDataOut;\n            lsu.dcReadHit[i] = hit[i];\n        end\n/*\n        for (int i = DCACHE_LSU_READ_PORT_NUM; i < MEM_ISSUE_WIDTH; i++) begin\n            lsu.dcReadData[i] = '0;\n            lsu.dcReadHit[i] = FALSE;\n            \n        end\n*/\n\n\n        // --- In the first stage of the commit stages.\n        // Write request\n\n\n        for (int i = 0; i < DCACHE_LSU_WRITE_PORT_NUM; i++) begin\n            assert(DCACHE_LSU_WRITE_PORT_NUM == 1);\n\n            // Write data is not aligned?\n            storedLineData = lsu.dcWriteData;\n            storedLineByteWE = lsu.dcWriteByteWE;\n\n            port.lsuCacheReq[(i+DCACHE_LSU_WRITE_PORT_BEGIN)] = lsu.dcWriteReq;\n            port.lsuMuxIn[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].tagWE = FALSE;    // First, stores read tag.\n            port.lsuMuxIn[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].indexIn = ToIndexPartFromFullAddr(lsu.dcWriteAddr);\n            port.lsuMuxIn[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].tagDataIn = ToTagPartFromFullAddr(lsu.dcWriteAddr);\n            port.lsuMuxIn[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].tagValidIn = TRUE;\n            port.lsuMuxIn[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].dataDataIn = storedLineData;\n            port.lsuMuxIn[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].dataByteWE = storedLineByteWE;\n            port.lsuMuxIn[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].dataWE = FALSE;\n            port.lsuMuxIn[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].dataWE_OnTagHit = TRUE;\n            port.lsuMuxIn[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].dataDirtyIn = TRUE;\n            port.lsuMuxIn[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].evictWay = '0;\n            port.lsuMuxIn[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].isVictimEviction = FALSE;\n            port.lsuMuxIn[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].isFlushReq = FALSE;\n\n            lsu.dcWriteReqAck = port.lsuCacheGrt[(i+DCACHE_LSU_WRITE_PORT_BEGIN)];\n        end\n\n\n        // --- In the first stage "}
{"text": "of the commit stages.\n        // Hit/miss detection\n\n        for (int i = 0; i < DCACHE_LSU_WRITE_PORT_NUM; i++) begin\n            assert(DCACHE_LSU_WRITE_PORT_NUM == 1);\n\n            // Store data to the array after miss handling finishes.\n            hit[(i+DCACHE_LSU_WRITE_PORT_BEGIN)] = FALSE;\n            if (port.lsuMuxTagOut[(i+DCACHE_LSU_WRITE_PORT_BEGIN)].tagHit && lsuCacheGrtReg[(i+DCACHE_LSU_WRITE_PORT_BEGIN)]) begin\n                hit[(i+DCACHE_LSU_WRITE_PORT_BEGIN)] = TRUE;\n            end\n\n            lsu.dcWriteHit = hit[(i+DCACHE_LSU_WRITE_PORT_BEGIN)];\n        end\n\n    end\n\n    always_comb begin\n        port.storedLineData = storedLineData;\n        port.storedLineByteWE = storedLineByteWE;\n    end\n\n    //\n    // --- Miss requests.\n    // In the tag access stage/second commit stage.\n    //\n    always_comb begin\n\n        // Read requests from a memory execution stage.\n        for (int i = 0; i < DCACHE_LSU_READ_PORT_NUM; i++) begin\n            missReq[i] = \n                !hit[i] && \n                !port.lsuMuxTagOut[i].mshrConflict && \n                dcReadReqReg[i] && \n                lsuCacheGrtReg[i];\n            missAddr[i] = dcReadAddrRegTagStg[i];\n            missIsUncachable[i] = dcReadUncachableReg[i];\n            missActiveListPtr[i] = dcReadActiveListPtrReg[i];\n        end\n\n        // Write requests from a store queue committer.\n        for (int i = DCACHE_LSU_WRITE_PORT_BEGIN; i < DCACHE_LSU_WRITE_PORT_NUM + DCACHE_LSU_READ_PORT_NUM; i++) begin\n            assert(DCACHE_LSU_WRITE_PORT_NUM == 1);\n            missReq[i] = !hit[i] && !port.lsuMuxTagOut[i].mshrConflict && dcWriteReqReg && lsuCacheGrtReg[i];\n            missAddr[i] = dcWriteAddrReg;\n            missIsUncachable[i] = dcWriteUncachableReg;\n            missActiveListPtr[i] = '0;\n        end\n\n    end\n\n\n    // 1. MSHR \u767b\u9332\n    //   * \u78ba\u4fdd\u3067\u304d\u306a\u3044\u5834\u5408\uff0c\u5f85\u305f\u305b\u308b\n    //   * \u4ee5\u964d\u306f MSHR \u767b\u9332\u30a2\u30c9\u30ec\u30b9\u3078\u306e\u64cd\u4f5c\u306f\u5168\u90e8\u30d6\u30ed\u30c3\u30af\n    logic mshrConflict[DCACHE_LSU_PORT_NUM];\n\n        // Miss handler\n    logic portInitMSHR[MSHR_NUM];\n    PhyAddrPath portInitMSHR_Addr[MSHR_NUM];\n    ActiveListIndexPath portInitMSHR_ActiveListPtr[MSHR_NUM];\n    logic portIsAllocatedByStore[MSHR_NUM];\n    logic portIsUncachable[MSHR_NUM];\n\n    always_comb begin\n\n        // MSHR allocation signals for ReplayQueue\n        for (int i = 0; i < DCACHE_LSU_READ_PORT_NUM; i++) begin\n            lsuLoadHasAllocatedMSHR[i] = FALSE;\n            lsuLoadMSHRID[i] = '0;\n        end\n\n        // MSHR allocation signals for storeCommitter\n        for (int i = 0; i < DCACHE_LSU_WRITE_PORT_NUM; i++) begin\n            lsuStoreHasAllocatedMSHR[i] = FALSE;\n            lsuStoreMSHRID[i] = '0;\n        end\n\n        // MSHR addr/data hit and data signals for MemoryAccessBackend\n        for (int i = 0; i < DCACHE_LSU_READ_PORT_NUM; i++) begin\n            lsuMSHRAddrHit[i] = port.lsuMuxTagOut[i].mshrAddrHit;\n            lsuMSHRAddrHitMSHRID[i] = port.lsuMuxTagOut[i].mshrAddrHitMSHRID;\n            lsuMSHRReadHit[i] = port.lsuMuxTagOut[i].mshrReadHit;\n            lsuMSHRReadData[i] = port.lsuMuxTagOut[i].mshrReadData;\n        end\n\n        for (int i = 0; i < DCACHE_LSU_PORT_NUM; i++) begin\n            mshrConflict[i] = port.lsuMuxTagOut[i].mshrConflict;\n        end\n\n        // Check address conflict in missed access in this cycle.\n        for (int i = 0; i < DCACHE_LSU_PORT_NUM; i++) begin\n            for (int m = 0; m < i; m++) begin\n                if (missReq[m] &&\n                    ToIndexPartFromFullAddr(missAddr[i]) == ToIndexPartFromFullAddr(missAddr[m])\n                ) begin\n                    // An access with the same index cannot enter to the MSHR.\n                    mshrConflict[i] = TRUE;\n                end\n            end\n        end\n\n        for (int i = 0; i < MSHR_NUM; i++) begin\n            portInitMSHR[i] = FALSE;\n            portInitMSHR_Addr[i] = '0;\n            portInitMSHR_ActiveListPtr[i] = '0;\n            portIsAllocatedByStore[i] = FALSE;\n            portIsUncachable[i] = FALSE;\n        end\n\n        for (int i = 0; i < DCACHE_LSU_PORT_NUM; i++) begin\n            if (!missReq[i] || mshrConflict[i]) begin\n                // This access hits the cache or is invalid.\n                // An access with the same index cannot enter to the MSHR.\n                continue;\n            end\n\n            // Search free MSHR entry and allocate.\n            for (int m = 0; m < MSHR_NUM; m++) begin\n                if (!port.mshrValid[m] && !portInitMSHR[m]) begin\n                    portInitMSHR[m] = TRUE;\n                    portInitMSHR_Addr[m] = missAddr[i];\n                    portInitMSHR_ActiveListPtr[m] = missActiveListPtr[i]; \n                    portIsUncachable[m] = missIsUncachable[i];\n                    if (i < DCACHE_LSU_READ_PORT_NUM) begin\n                        lsuLoadHasAllocatedMSHR[i] = TRUE;\n                        lsuLoadMSHRID[i] = m;\n                    end\n                    else begin\n                        lsuStoreHasAllocatedMSHR[i-DCACHE_LSU_READ_PORT_NUM] = TRUE;\n                        lsuStoreMSHRID[i-DCACHE_LSU_READ_PORT_NUM] = m;\n                        portIsAllocatedByStore[m] = TRUE;\n                    end\n                    break;\n                end\n            end\n        end\n\n        for (int i = 0; i < MSHR_NUM; i++) begin\n            port.initMSHR[i] = portInitMSHR[i];\n            port.initMSHR_Addr[i] = portInitMSHR_Addr[i];\n            port.initMSHR_ActiveListPtr[i] = portInitMSHR_ActiveListPtr[i];\n            port.isAllocatedByStore[i] = portIsAllocatedByStore[i];\n            port.isUncachable[i] = portIsUncachable[i];\n        end\n\n        // DCache top -> DCache controller\n        port.lsuCacheGrtReg = lsuCacheGrtReg;\n\n        // Output control signals\n        for (int i = 0; i < DCACHE_LSU_READ_PORT_NUM; i++) begin\n            lsu.dcReadBusy[i] = mshrConflict[i];\n        end\n        lsu.dcWriteBusy = mshrConflict[DCACHE_LSU_WRITE_PORT_BEGIN];\n\n        // MSHR addr/data hit and data signals for MemoryAccessBackend\n        for (int i = 0; i < DCACHE_LSU_READ_PORT_NUM; i++) begin\n            lsu.mshrAddrHit[i] = lsuMSHRAddrHit[i];\n            lsu.mshrAddrHitMSHRID[i] = lsuMSHRAddrHitMSHRID[i];\n            lsu.mshrReadHit[i] = lsuMSHRReadHit[i];\n            lsu.mshrReadData[i] = lsuMSHRReadData[i];\n        end\n\n        // MSHR allocation signals for ReplayQueue\n        for (int i = 0; i < DCACHE_LSU_READ_PORT_NUM; i++) begin\n            lsu.loadHasAllocatedMSHR[i] = lsuLoadHasAllocatedMSHR[i];\n            lsu.loadMSHRID[i] = lsuLoadMSHRID[i];\n        end\n\n        // MSHR allocation signals for storeCommitter\n        for (int i = 0; i < DCACHE_LSU_WRITE_PORT_NUM; i++) begin\n            lsu.storeHasAllocatedMSHR[i] = lsuStoreHasAllocatedMSHR[i];\n            lsu.storeMSHRID[i] = lsuStoreMSHRID[i];\n        end\n\n    end\n\n    always_comb begin\n        for (int i = 0; i < MSHR_NUM; i++) begin\n            lsuMakeMSHRCanBeInvalidDirect[i] = lsu.makeMSHRCanBeInvalidDirect[i];\n        end\n        for (int i = 0; i < MSHR_NUM; i++) begin\n            port.mshrCanBeInvalidDirect[i] = lsuMakeMSHRCanBeInvalidDirect[i];\n        end\n    end\n\n\n    //\n    // Main memory\n    //\n    always_comb begin\n        cacheSystem.dcMemAccessReq.valid = port.memValid;\n        cacheSystem.dcMemAccessReq.we = port.memWE;\n        cacheSystem.dcMemAccessReq.addr = port.memAddr;\n        cacheSystem.dcMemAccessReq.data = port.memData;\n        // To notice mshr phases and addr subset to ReplayQueue.\n        for (int i = 0; i < MSHR_NUM; i++) begin\n            lsu.mshrPhase[i] = port.mshrPhase[i];\n            lsu.mshrValid[i] = port.mshrValid[i];\n        end\n        port.memReqAck = cacheSystem.dcMemAccessReqAck.ack;\n        port.memSerial = cacheSystem.dcMemAccessReqAck.serial;\n        port.memAccessResult = cacheSystem.dcMemAccessResult;\n        port.memWSerial = cacheSystem.dcMemAccessReqAck.wserial;\n        port.memAccessResponse = cacheSystem.dcMemAccessResponse;\n    end\n\n    //\n    // CacheFlushManager\n    //\n    always_comb begin\n        // DCache -> cacheFlushManagemer\n        cacheSystem.dcFlushReqAck = port.dcFlushReqAck;\n        cacheSystem.dcFlushComplete = port.dcFlushComplete;\n\n        // cacheFlushManagemer -> DCache\n        port.dcFlushReq = cacheSystem.dcFlushReq;\n        port.flushComplete = cacheSystem.flushComplete;\n    end\n\nendmodule : DCache\n\n\nmodule DCacheMissHandler(\n    DCacheIF.DCacheMissHandler port,\n    RecoveryManagerIF.DCacheMissHandler recovery\n);\n\n    MissStatusHandlingRegister nextMSHR[MSHR_NUM];\n    MissStatusHandlingRegister mshr[MSHR_NUM];\n    logic flushMSHR_Entry[MSHR_NUM];\n    logic flushMSHR_Allocation[MSHR_NUM];\n\n    logic portIsAllocatedByStore[MSHR_NUM];\n    DCacheLinePath mergedLine[MSHR_NUM];\n\n    logic mshrFlushComplete[MSHR_NUM];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < MSHR_NUM; i++) begin\n            mshr[i] = '0;\n        end\n    end\n`endif\n\n    // MSHR\n    always_ff@(posedge port.clk) begin\n        if (port.rst) begin\n            for (int i = 0; i < MSHR_NUM; i++) begin\n                mshr[i].valid <= FALSE;\n                mshr[i].phase <= MSHR_PHASE_INVALID;\n                mshr[i].canBeInvalid <= FALSE;\n                mshr[i].isAllocatorLoadFlushed <= FALSE;\n                mshr[i].isAllocatedByStore <= FALSE;\n            end\n        end\n        else begin\n            mshr <= nextMSHR;\n        end\n    end\n\n    always_comb begin\n        for (int i = 0; i < MSHR_NUM; i++) begin\n            // To notice mshr phases to ReplayQueue.\n            port.mshrPhase[i] = mshr[i].phase;\n\n            // To bypass mshr data to load instructions.\n            port.mshrData[i] = mshr[i].line;\n\n            port.mshrValid[i] = mshr[i].valid;\n            port.mshrAddr[i] = mshr[i].newAddr;\n        end\n\n        // Flush operation uses MSHR[0];\n        // therefore the complete signal comes from MSHR[0]. \n        port.mshrFlushComplete = mshrFlushComplete[0];\n    end\n\n    DCacheLinePath portStoredLineData;\n    logic [DCACHE_LINE_BYTE_NUM-1:0] portStoredLineByteWE;\n    always_comb begin\n        portStoredLineData = port.storedLineData;\n        portStoredLineByteWE = port.storedLineByteWE;\n    end\n\n\n    always_comb begin\n\n        for (int i = 0; i < MSHR_NUM; i++) begin\n            portIsAllocatedByStore[i] = port.isAllocatedByStore[i];\n        end\n\n        for (int i = 0; i < MSHR_NUM; i++) begin\n            nextMSHR[i] = mshr[i];\n\n\n            if (port.mshrCanBeInvalidDirect[i]) begin\n                // its allocator load has received data in the RW stage.\n                // Note that a load that has allocated MSHR releases its \n                // allocated MSHR entry even if it receives a value through \n                // store-load forwarding.\n                nextMSHR[i].canBeInvalid = TRUE;\n            end\n\n            // Cancel MSHR allocation on pipeline flush\n            flushMSHR_Allocation[i] = SelectiveFlushDetector(\n                            recovery.toRecoveryPhase,\n                            recovery.flushRangeHeadPtr,\n                            recovery.flushRangeTailPtr,\n                            recovery.flushAllInsns,\n                            port.initMSHR_ActiveListPtr[i]\n                        );\n            // Release MSHR entry\n            flushMSHR_Entry[i] = SelectiveFlushDetector(\n                            recovery.toRecoveryPhase,\n                            recovery.flushRangeHeadPtr,\n                            recovery.flushRangeTailPtr,\n                            recovery.flushAllInsns,\n                            mshr[i].activeListPtr\n                        );\n            if (flushMSHR_Entry[i] && !mshr[i].isAllocatedByStore) begin\n                // Its allocator load is flushed.\n                // When an allocator load is flushed, the allocated entry must be\n                // flushed without filling a fetched line to avoid a live lock to\n                // acquire cache ports between active loads and a dead MSHR entry.\n                nextMSHR[i].isAllocatorLoadFlushed = TRUE;\n                nextMSHR[i].canBeInvalid = TRUE;\n            end\n\n\n            // Both MSHR_PHASE_VICTIM_READ_FROM_CACHE & MSHR_PHASE_MISS_WRITE_CACHE_REQUEST phases\n            // use newAddr for a cache index.\n            // The other phases do not use an index.\n            port.mshrCacheMuxIn[i].indexIn = ToIndexPartFromFullAddr(mshr[i].newAddr);\n\n            // Only MSHR_PHASE_MISS_WRITE_CACHE_REQUEST uses tagDataIn, dataByteWE and dataDataIn.\n            port.mshrCacheMuxIn[i].tagDataIn = ToTagPartFromFullAddr(mshr[i].newAddr);\n            port.mshrCacheMuxIn[i].dataDataIn = mshr[i].line;\n            port.mshrCacheMuxIn[i].dataByteWE = {DCACHE_LINE_BYTE_NUM{1'b1}};\n            port.mshrCacheMuxIn[i].tagValidIn = TRUE;        // Don't care for the other phases.\n\n            // Other cache request signals.\n            port.mshrCacheReq[i] = FALSE;\n            port.mshrCacheMuxIn[i].tagWE = FALSE;\n            port.mshrCacheMuxIn[i].dataWE = FALSE;\n            port.mshrCacheMuxIn[i].dataWE_OnTagHit = FALSE;\n            port.mshrCacheMuxIn[i].dataDirtyIn = FALSE;\n            port.mshrCacheMuxIn[i].evictWay = mshr[i].evictWay;\n            port.mshrCacheMuxIn[i].isVictimEviction = FALSE;\n            port.mshrCacheMuxIn[i].isFlushReq = FALSE;\n\n            // Memory request signals\n            port.mshrMemReq[i] = FALSE;\n            port.mshrMemMuxIn[i].data = mshr[i].line;\n\n            // Don't care\n            port.mshrMemMuxIn[i].we = FALSE;\n            port.mshrMemMuxIn[i].addr = mshr[i].victimAddr;\n\n\n            // For flush\n            mshrFlushComplete[i] = FALSE;\n            // For data merging\n            mergedLine[i] = '0;\n\n            case(mshr[i].phase)\n                default: begin\n\n                    // Initialize or read a  MSHR.\n                    if (port.initMSHR[i] && !flushMSHR_Allocation[i]) begin\n                        // 1. MSHR \u767b\u9332\n                        // Initial phase\n\n                        nextMSHR[i].valid = TRUE;\n                        nextMSHR[i].newAddr = port.initMSHR_Addr[i];\n                        nextMSHR[i].newValid = FALSE;\n                        nextMSHR[i].victimValid = FALSE;\n\n                        nextMSHR[i].victimDirty = FALSE;\n                        nextMSHR[i].victimReceived = FALSE;\n                        nextMSHR[i].memSerial = '0;\n                        nextMSHR[i].memWSerial = '0;\n\n                        nextMSHR[i].canBeInvalid = FALSE;\n                        nextMSHR[i].isAllocatorLoadFlushed = FALSE;\n                        nextMSHR[i].isAllocatedByStore = portIsAllocatedByStore[i];\n                        nextMSHR[i].isUncachable = port.isUncachable[i];\n\n                        nextMSHR[i].evictWay = '0;\n\n                        // Don't care\n                        nextMSHR[i].flushIndex = '0;\n\n                        // Dont'care\n                        //nextMSHR[i].line = '0;\n\n                        if (port.isUncachable[i]) begin\n                            // Uncachable access does not update cache;\n                            // therefore phases for evicting a victim are skipped.\n                            nextMSHR[i].phase = MSHR_PHASE_MISS_READ_MEM_REQUEST;\n                        end\n                        else begin\n                            nextMSHR[i].phase = MSHR_PHASE_VICTIM_REQUEST;\n                        end\n                        nextMSHR[i].activeListPtr = port.initMSHR_ActiveListPtr[i];\n                    end\n                    else if (port.dcFlushing && (i == 0)) begin\n                        // MSHR[0] is used to flush DCache.\n                        nextMSHR[i].valid = TRUE;\n                        nextMSHR[i].newAddr = '0;\n                        nextMSHR[i].newValid = FALSE;\n                        nextMSHR[i].victimValid = FALSE;\n\n                        nextMSHR[i].victimDirty = FALSE;\n                        nextMSHR[i].victimReceived = FALSE;\n                        nextMSHR[i].memSerial = '0;\n                        nextMSHR[i].memWSerial = '0;\n\n                        nextMSHR[i].canBeInvalid = FALSE;\n                        nextMSHR[i].isAllocatorLoadFlushed = FALSE;\n                        nextMSHR[i].isAllocatedByStore = FALSE;\n                        nextMSHR[i].isUncachable = FALSE;\n\n                        nextMSHR[i].flushIndex = '0;\n\n                        nextMSHR[i].line = '0;\n\n                        nextMSHR[i].phase = MSHR_PHASE_FLUSH_VICTIM_REQEUST;\n                        nextMSHR[i].activeListPtr = port.initMSHR_ActiveListPtr[i];\n                end\n                end\n            \n            //\n            // --- States for DCache flush\n            //\n\n                // FLUSH 1.\n                // Send a request to DCache to (1) get a victime line corresponding to flushIndex,\n                // and (2) subsequently reset the corresponding tag and data entry.\n                MSHR_PHASE_FLUSH_VICTIM_REQEUST: begin\n                    // Access the cache array.\n                    port.mshrCacheReq[i] = TRUE;\n                    port.mshrCacheMuxIn[i].indexIn = mshr[i].flushIndex;\n                    port.mshrCacheMuxIn[i].tagValidIn = FALSE;\n                    port.mshrCacheMuxIn[i].tagWE = TRUE;\n                    port.mshrCacheMuxIn[i].dataWE = TRUE;\n                    port.mshrCacheMuxIn[i].dataWE_OnTagHit = FALSE;\n                    port.mshrCacheMuxIn[i].dataDirtyIn = FALSE;\n                    port.mshrCacheMuxIn[i].isFlushReq = TRUE;\n\n                    nextMSHR[i].phase =\n                        port.mshrCacheGrt[i] ?\n                        MSHR_PHASE_FLUSH_VICTIM_RECEIVE_TAG : MSHR_PHASE_FLUSH_VICTIM_REQEUST;\n                end\n\n                // FLUSH 2.\n                // Receive a tag of the victime line.\n                MSHR_PHASE_FLUSH_VICTIM_RECEIVE_TAG: begin\n                    // Read a victim line.\n                    if (port.mshrCacheMuxTagOut[i].tagValidOut) begin\n                        nextMSHR[i].victimAddr =\n                            BuildFullAddr(\n                                mshr[i].flushIndex,\n                                port.mshrCacheMuxTagOut[i].tagDataOut\n                            );\n                        nextMSHR[i].victimValid = TRUE;\n                        nextMSHR[i].phase = MSHR_PHASE_FLUSH_VICTIM_RECEIVE_DATA;\n                    end\n                    else begin\n                        nextMSHR[i].victimValid = FALSE;\n                        // Skip receiving data and writing back.\n                        nextMSHR[i].phase = MSHR_PHASE_FLUSH_CHECK;\n                    end\n                end\n\n                // FLUSH 3.\n                // Receive data and a dirty bit of the victime line.\n                MSHR_PHASE_FLUSH_VICTIM_RECEIVE_DATA: begin\n                    // Receive cache data.\n                    nextMSHR[i].victimReceived = TRUE;\n                    nextMSHR[i].line = port.mshrCacheMuxDataOut[i].dataDataOut;\n                    nextMSHR[i].victimDirty = port.mshrCacheMuxDataOut[i].dataDirtyOut;\n\n                    if (nextMSHR[i].victimDirty) begin\n                        // Write back dirty data\n                        nextMSHR[i].phase = MSHR_PHASE_FLUSH_VICTIM_WRITE_TO_MEM;\n                    end\n                    else begin\n                        nextMSHR[i].phase = MSHR_PHASE_FLUSH_CHECK;\n                    end\n                end\n\n                // FLUSH 4.\n                // Send a write back request of the dirty victime line to the data bus.\n                MSHR_PHASE_FLUSH_VICTIM_WRITE_TO_MEM: begin\n                    port.mshrMemReq[i] = TRUE;\n                    port.mshrMemMuxIn[i].we = TRUE;\n                    port.mshrMemMuxIn[i].addr = mshr[i].victimAddr;\n\n                    if (port.mshrMemGrt[i] && port.mshrMemMuxOut[i].ack) begin\n                        nextMSHR[i].memWSerial = port.mshrMemMuxOut[i].wserial;\n                  "}
{"text": "      nextMSHR[i].phase = MSHR_PHASE_FLUSH_VICTIM_WRITE_COMPLETE;\n                    end\n                    else begin\n                        // Waiting until the request is accepted.\n                        nextMSHR[i].phase = MSHR_PHASE_FLUSH_VICTIM_WRITE_TO_MEM;\n                    end\n                end\n\n                // FLUSH 5.\n                // Wait until the data is written back.\n                MSHR_PHASE_FLUSH_VICTIM_WRITE_COMPLETE: begin\n                    port.mshrMemReq[i] = FALSE;\n                    if (mshr[i].victimValid &&\n                        mshr[i].victimDirty &&\n                        !(port.memAccessResponse.valid &&\n                        mshr[i].memWSerial == port.memAccessResponse.serial)\n                    ) begin\n                        // Wait MSHR_PHASE_FLUSH_VICTIM_WRITE_COMPLETE.\n                        nextMSHR[i].phase = MSHR_PHASE_FLUSH_VICTIM_WRITE_COMPLETE;\n                    end\n                    else begin\n                        nextMSHR[i].phase = MSHR_PHASE_FLUSH_CHECK;\n                    end\n                end\n\n                // FLUSH 6.\n                // Ckeck if all cache lines have been written back.\n                MSHR_PHASE_FLUSH_CHECK: begin\n                    if (&(mshr[i].flushIndex)) begin\n                        nextMSHR[i].flushIndex = '0;\n                        mshrFlushComplete[i] = TRUE;\n                    end\n                    else begin\n                        nextMSHR[i].flushIndex = mshr[i].flushIndex + 1;\n                    end\n\n                    nextMSHR[i].victimValid = FALSE;\n                    nextMSHR[i].victimDirty = FALSE;\n                    nextMSHR[i].victimReceived = FALSE;\n                    nextMSHR[i].memSerial = '0;\n                    nextMSHR[i].memWSerial = '0;\n                    nextMSHR[i].line = '0;\n\n                    if (mshrFlushComplete[i]) begin\n                        nextMSHR[i].phase = MSHR_PHASE_INVALID;\n                        nextMSHR[i].valid = FALSE;\n                    end\n                    else begin\n                        nextMSHR[i].phase = MSHR_PHASE_FLUSH_VICTIM_REQEUST;\n                    end\n                end\n\n            //\n            // --- States for DCache flush (end)\n            //\n\n            //\n            // --- States for DCache miss handling\n            //\n\n                // 2. \u30ea\u30d7\u30ec\u30fc\u30b9\u5bfe\u8c61\u306e\u8aad\u307f\u51fa\u3057\n                MSHR_PHASE_VICTIM_REQUEST: begin\n                    // Access the cache array.\n                    port.mshrCacheReq[i] = TRUE;\n                    port.mshrCacheMuxIn[i].tagWE = FALSE;\n                    port.mshrCacheMuxIn[i].dataWE = FALSE;\n                    port.mshrCacheMuxIn[i].dataWE_OnTagHit = FALSE;\n                    port.mshrCacheMuxIn[i].dataDirtyIn = FALSE;\n                    port.mshrCacheMuxIn[i].isVictimEviction = TRUE;\n\n                    if (port.mshrCacheGrt[i]) begin\n                        nextMSHR[i].phase = MSHR_PHASE_VICTIM_RECEIVE_TAG;\n                    end\n                    else if (mshr[i].isAllocatorLoadFlushed) begin\n                            // If its allocator is flushed, miss handling finishes.\n                            nextMSHR[i].phase = MSHR_PHASE_MISS_HANDLING_COMPLETE;\n                    end\n                    else begin\n                            nextMSHR[i].phase = MSHR_PHASE_VICTIM_REQUEST;\n                    end\n                end\n\n                MSHR_PHASE_VICTIM_RECEIVE_TAG: begin\n                    // Read a victim line and receive tag data.\n                    nextMSHR[i].tagDataOut = port.mshrCacheMuxTagOut[i].tagDataOut;\n                    nextMSHR[i].tagValidOut = port.mshrCacheMuxTagOut[i].tagValidOut;\n                    nextMSHR[i].phase = MSHR_PHASE_VICTIM_RECEIVE_DATA;\n                end\n\n\n                MSHR_PHASE_VICTIM_RECEIVE_DATA: begin\n                    \n                    // \u7f6e\u304d\u63db\u3048\u60c5\u5831\n                    nextMSHR[i].evictWay = port.mshrCacheMuxDataOut[i].replDataOut;\n                    if (mshr[i].tagValidOut[nextMSHR[i].evictWay]) begin\n                        // \u8ffd\u3044\u51fa\u3057\u5bfe\u8c61\u306e\u8aad\u307f\u51fa\u3057\u6e08\u307f\u30bf\u30b0\u3068\u65b0\u3057\u3044\u30a2\u30c9\u30ec\u30b9\u306e\n                        // \u30a4\u30f3\u30c7\u30c3\u30af\u30b9\u304b\u3089\u30d5\u30eb\u30a2\u30c9\u30ec\u30b9\u3092\u4f5c\u308b\n                        nextMSHR[i].victimAddr =\n                            BuildFullAddr(\n                                ToIndexPartFromFullAddr(mshr[i].newAddr),\n                                mshr[i].tagDataOut[\n                                    nextMSHR[i].evictWay\n                                ]\n                            );\n                        nextMSHR[i].victimValid = TRUE;\n                    end\n                    else begin\n                        nextMSHR[i].victimValid = FALSE;\n                    end\n\n\n                    // Receive cache data.\n                    // The data array outputs an evicted way determined in the array.\n                    nextMSHR[i].victimReceived = TRUE;\n                    nextMSHR[i].line = port.mshrCacheMuxDataOut[i].dataDataOut;\n                    nextMSHR[i].victimDirty = port.mshrCacheMuxDataOut[i].dataDirtyOut;\n\n                    if (nextMSHR[i].victimValid && nextMSHR[i].victimDirty) begin\n                        nextMSHR[i].phase = MSHR_PHASE_VICTIM_WRITE_TO_MEM;\n                    end\n                    else begin\n                        nextMSHR[i].phase = MSHR_PHASE_MISS_READ_MEM_REQUEST;\n                    end\n                end\n\n                // 3. \u30ea\u30d7\u30ec\u30fc\u30b9\u5bfe\u8c61\u306e\u66f8\u304d\u51fa\u3057\n                MSHR_PHASE_VICTIM_WRITE_TO_MEM: begin\n                    port.mshrMemReq[i] = TRUE;\n                    port.mshrMemMuxIn[i].we = TRUE;\n                    port.mshrMemMuxIn[i].addr = mshr[i].victimAddr;\n\n                    if (port.mshrMemGrt[i] && port.mshrMemMuxOut[i].ack) begin\n                        nextMSHR[i].memWSerial = port.mshrMemMuxOut[i].wserial;\n                        nextMSHR[i].phase = MSHR_PHASE_VICTIM_WRITE_COMPLETE;\n                    end\n                    else begin\n                        // Waiting until the request is accepted.\n                        nextMSHR[i].phase = MSHR_PHASE_VICTIM_WRITE_TO_MEM;\n                    end\n\n                end\n\n                // 4. \u30ea\u30d7\u30ec\u30fc\u30b9\u5bfe\u8c61\u306e\u66f8\u304d\u8fbc\u307f\u5b8c\u4e86\u307e\u3067\u5f85\u6a5f\n                MSHR_PHASE_VICTIM_WRITE_COMPLETE: begin\n                    port.mshrMemReq[i] = FALSE;\n                    if (mshr[i].victimValid &&\n                        mshr[i].victimDirty &&\n                        !(port.memAccessResponse.valid &&\n                        mshr[i].memWSerial == port.memAccessResponse.serial)\n                    ) begin\n                        // Wait MSHR_PHASE_VICTIM_WRITE_TO_MEM.\n                        nextMSHR[i].phase = MSHR_PHASE_VICTIM_WRITE_COMPLETE;\n                    end\n                    else begin\n                        nextMSHR[i].phase = MSHR_PHASE_MISS_READ_MEM_REQUEST;\n                    end\n                end\n\n                // 5. \u30df\u30b9\u30c7\u30fc\u30bf\u306e\u30e1\u30e2\u30ea\u304b\u3089\u306e\u8aad\u307f\u3060\u3057\n                MSHR_PHASE_MISS_READ_MEM_REQUEST: begin\n                    /* \u30e1\u30e2\u30ea\u66f8\u8fbc\u306fResult\u3092\u5f85\u305f\u306a\u3044\u3088\u3046\u306b\u4ed5\u69d8\u5909\u66f4\n                    if (mshr[i].victimValid &&\n                        mshr[i].victimDirty &&\n                        !(port.memAccessResult.valid &&\n                        mshr[i].memSerial == port.memAccessResult.serial)\n                    ) begin\n                        // Wait MSHR_PHASE_VICTIM_WRITE_TO_MEM.\n                        port.mshrMemReq[i] = FALSE;\n                    end\n                    */\n                    //else begin\n                    if (TRUE) begin\n                        // A victim line has been written to the memory and\n                        // data on an MSHR entry is not valid.\n                        nextMSHR[i].victimValid = FALSE;\n\n                        // Fetch a missed line.\n                        port.mshrMemReq[i] = TRUE;\n                        port.mshrMemMuxIn[i].we = FALSE;\n                        port.mshrMemMuxIn[i].addr = ToLineAddrFromFullAddr(mshr[i].newAddr);\n\n                        if (port.mshrMemGrt[i] && port.mshrMemMuxOut[i].ack) begin\n                            nextMSHR[i].memSerial = port.mshrMemMuxOut[i].serial;\n                            nextMSHR[i].phase = MSHR_PHASE_MISS_READ_MEM_RECEIVE;\n                        end\n                        else begin\n                            // Waiting until the request is accepted.\n                            nextMSHR[i].phase = MSHR_PHASE_MISS_READ_MEM_REQUEST;\n                        end\n                    end\n                end\n\n                // Receive memory data.\n                MSHR_PHASE_MISS_READ_MEM_RECEIVE: begin\n                    if (!(port.memAccessResult.valid &&\n                        mshr[i].memSerial == port.memAccessResult.serial)\n                    ) begin\n                        // Waiting until data is received.\n                        nextMSHR[i].phase = MSHR_PHASE_MISS_READ_MEM_RECEIVE;\n                    end\n                    else begin\n                        // Set a fetched line to a MSHR entry and go to the next phase.\n                        nextMSHR[i].line = port.memAccessResult.data;\n                        nextMSHR[i].newValid = TRUE;\n                        if (mshr[i].isAllocatedByStore) begin\n                            nextMSHR[i].phase = MSHR_PHASE_MISS_MERGE_STORE_DATA;\n                        end\n                        else if (mshr[i].isUncachable) begin\n                            // An uncachable load does not update cache and \n                            // receives data via this MSHR entry directly.\n                            nextMSHR[i].phase = MSHR_PHASE_MISS_HANDLING_COMPLETE;\n                        end\n                        else begin\n                            // A cachable load updates cache using the fetched cache line.\n                            nextMSHR[i].phase = MSHR_PHASE_MISS_WRITE_CACHE_REQUEST;\n                        end\n                    end\n                end\n\n                // 5.5. MSHR\u30a8\u30f3\u30c8\u30ea\u306e\u5272\u308a\u5f53\u3066\u8005\u304cStore\u547d\u4ee4\u306e\u5834\u5408\uff0c\u30df\u30b9\u30c7\u30fc\u30bf\u3068\u30b9\u30c8\u30a2\u547d\u4ee4\u306e\u30c7\u30fc\u30bf\u3092\u7d50\u5408\u3059\u308b\n                MSHR_PHASE_MISS_MERGE_STORE_DATA: begin\n                    // Merge the allocator store data and the fetched line.\n                    MergeStoreDataToLine(mergedLine[i], mshr[i].line,\n                        portStoredLineData, portStoredLineByteWE);\n                    nextMSHR[i].line = mergedLine[i];\n\n                    if (mshr[i].isUncachable) begin\n                        // An uncachable store does not update cache and \n                        // writes the updated cache line back to memory.\n                        nextMSHR[i].phase = MSHR_PHASE_UNCACHABLE_WRITE_TO_MEM;\n                    end\n                    else begin\n                        // A cachable store updates cache using the updated cache line.\n                        nextMSHR[i].phase = MSHR_PHASE_MISS_WRITE_CACHE_REQUEST;\n                    end\n                end\n\n                // 6. (Uncachable store) Issue a write request to write the updated cache line.\n                MSHR_PHASE_UNCACHABLE_WRITE_TO_MEM: begin\n                    port.mshrMemReq[i] = TRUE;\n                    port.mshrMemMuxIn[i].we = TRUE;\n                    port.mshrMemMuxIn[i].addr = ToLineAddrFromFullAddr(mshr[i].newAddr);\n\n                    if (port.mshrMemGrt[i] && port.mshrMemMuxOut[i].ack) begin\n                        nextMSHR[i].memWSerial = port.mshrMemMuxOut[i].wserial;\n                        nextMSHR[i].phase = MSHR_PHASE_UNCACHABLE_WRITE_COMPLETE;\n                    end\n                    else begin\n                        // Waiting until the request is accepted.\n                        nextMSHR[i].phase = MSHR_PHASE_UNCACHABLE_WRITE_TO_MEM;\n                    end\n\n                end\n\n                // 6.5. (Uncachable store) Wait until the updated cache line is written to memory.\n                MSHR_PHASE_UNCACHABLE_WRITE_COMPLETE: begin\n                    port.mshrMemReq[i] = FALSE;\n                    if (mshr[i].newValid &&\n                        !(port.memAccessResponse.valid &&\n                        mshr[i].memWSerial == port.memAccessResponse.serial)\n                    ) begin\n                        // Wait MSHR_PHASE_UNCACHABLE_WRITE_COMPLETE.\n                        nextMSHR[i].phase = MSHR_PHASE_UNCACHABLE_WRITE_COMPLETE;\n                    end\n                    else begin\n                        nextMSHR[i].phase = MSHR_PHASE_MISS_HANDLING_COMPLETE;\n                    end\n                end\n\n                // 6. (Cachable load/store) \u30df\u30b9\u30c7\u30fc\u30bf\u306e\u30ad\u30e3\u30c3\u30b7\u30e5\u3078\u306e\u66f8\u304d\u8fbc\u307f\n                MSHR_PHASE_MISS_WRITE_CACHE_REQUEST: begin\n                    // Fill the cache array.\n                    port.mshrCacheReq[i] = TRUE;\n                    port.mshrCacheMuxIn[i].tagWE = TRUE;\n                    port.mshrCacheMuxIn[i].dataWE = TRUE;\n                    port.mshrCacheMuxIn[i].dataWE_OnTagHit = FALSE;\n                    port.mshrCacheMuxIn[i].dataDirtyIn = mshr[i].isAllocatedByStore;\n                    // Use the saved evict way.\n                    port.mshrCacheMuxIn[i].evictWay = mshr[i].evictWay;\n\n                    if (port.mshrCacheGrt[i]) begin\n                        // If my request is granted, miss handling finishes.\n                        nextMSHR[i].phase = MSHR_PHASE_MISS_HANDLING_COMPLETE;\n                    end\n                    else if (mshr[i].isAllocatorLoadFlushed) begin\n                        // If its allocator is flushed, miss handling finishes.\n                        nextMSHR[i].phase = MSHR_PHASE_MISS_HANDLING_COMPLETE;\n                    end\n                    else begin\n                        nextMSHR[i].phase = MSHR_PHASE_MISS_WRITE_CACHE_REQUEST;\n                    end\n                end\n\n                // 7.\n                // * (Cachable) \u30c7\u30fc\u30bf\u30a2\u30ec\u30a4\u3078\u306e\u66f8\u304d\u8fbc\u307f\u3068\u89e3\u653e\u53ef\u80fd\u6761\u4ef6\u3092\u5f85\u3063\u3066 MSHR \u89e3\u653e\n                // \u73fe\u5728\u306e\u89e3\u653e\u53ef\u80fd\u6761\u4ef6\u306f\n                // \u30fb\u5272\u308a\u5f53\u3066\u8005\u304c Load \u3067\u305d\u306e Load \u3078\u306e\u30c7\u30fc\u30bf\u306e\u53d7\u3051\u6e21\u3057\u304c\u5b8c\u4e86 or \u305d\u306e Load \u304c\u30d5\u30e9\u30c3\u30b7\u30e5\u3055\u308c\u305f\u5834\u5408\n                // \u30fb\u5272\u308a\u5f53\u3066\u8005\u304c Store \u306e\u5834\u5408 (\u8a72\u5f53 Store \u306e\u30c7\u30fc\u30bf\u306f\u3053\u306e\u6642\u70b9\u3067\u30ad\u30e3\u30c3\u30b7\u30e5 or Memory \u306b\u66f8\u304d\u8fbc\u307e\u308c\u3066\u3044\u308b)\n                MSHR_PHASE_MISS_HANDLING_COMPLETE: begin\n                    if (mshr[i].canBeInvalid || mshr[i].isAllocatedByStore) begin\n                        nextMSHR[i].phase = MSHR_PHASE_INVALID;\n                        nextMSHR[i].valid = FALSE;\n                    end\n                end\n            endcase // case(mshr[i].phase)\n\n        end // for (int i = 0; i < MSHR_NUM; i++) begin\n    end\n\n`ifdef RSD_FUNCTIONAL_SIMULATION\n    localparam MSHR_DEADLOCK_DETECT_CYCLES = 500;\n    integer cycles[MSHR_NUM];\n    always_ff @(posedge port.clk) begin\n        for (int i = 0; i < MSHR_NUM; i++) begin\n            if (port.rst || !mshr[i].valid ) begin\n                cycles[i] <= 0;\n            end\n            else begin\n                cycles[i] <= cycles[i] + 1;\n            end\n        end\n    end\n\n    generate\n        for (genvar i = 0; i < MSHR_NUM; i++) begin\n            `RSD_ASSERT_CLK(\n                port.clk,\n                !(cycles[i] > MSHR_DEADLOCK_DETECT_CYCLES),\n                \"MSHR deadlock detected\"\n            );\n        end\n    endgenerate\n`endif\n\n\nendmodule : DCacheMissHandler\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// 2-read/write set-associative data cache\n//\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport CacheSystemTypes::*;\nimport OpFormatTypes::*;\nimport MemoryMapTypes::*;\nimport ActiveListIndexTypes::*;\n\ninterface DCacheIF(\ninput\n    logic clk,\n    logic rst,\n    logic rstStart\n);\n    // Tag array\n    logic           tagArrayWE[DCACHE_ARRAY_PORT_NUM];\n    DCacheWayPath   tagArrayWriteWay[DCACHE_ARRAY_PORT_NUM];\n    DCacheIndexPath tagArrayIndexIn[DCACHE_ARRAY_PORT_NUM];\n    DCacheTagPath   tagArrayDataIn [DCACHE_ARRAY_PORT_NUM];\n    logic           tagArrayValidIn[DCACHE_ARRAY_PORT_NUM];\n    DCacheTagPath   tagArrayDataOut[DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n    logic           tagArrayValidOut[DCACHE_WAY_NUM][DCACHE_ARRAY_PORT_NUM];\n\n    // Data array\n    logic           dataArrayWE[DCACHE_ARRAY_PORT_NUM];\n    DCacheIndexPath dataArrayIndexIn[DCACHE_ARRAY_PORT_NUM];\n    DCacheLinePath  dataArrayDataIn[DCACHE_ARRAY_PORT_NUM];\n    DCacheLinePath  dataArrayDataOut[DCACHE_ARRAY_PORT_NUM];\n    DCacheByteEnablePath dataArrayByteWE_In[DCACHE_ARRAY_PORT_NUM];\n    DCacheWayPath   dataArrayWriteWay[DCACHE_ARRAY_PORT_NUM];\n    DCacheWayPath   dataArrayReadWay[DCACHE_ARRAY_PORT_NUM];\n    logic  dataArrayDoesReadEvictedWay[DCACHE_ARRAY_PORT_NUM];    \n    logic  dataArrayDirtyIn[DCACHE_ARRAY_PORT_NUM];\n    logic  dataArrayDirtyOut[DCACHE_ARRAY_PORT_NUM];\n\n    // Replacement\n    logic           replArrayWE[DCACHE_ARRAY_PORT_NUM];\n    DCacheIndexPath replArrayIndexIn[DCACHE_ARRAY_PORT_NUM];\n    DCacheWayPath  replArrayDataIn[DCACHE_ARRAY_PORT_NUM];\n    DCacheWayPath  replArrayDataOut[DCACHE_ARRAY_PORT_NUM];\n\n    // Port arbiter input/output\n    logic           lsuCacheReq[DCACHE_LSU_PORT_NUM];\n    logic           lsuCacheGrt[DCACHE_LSU_PORT_NUM];\n    DCachePortMultiplexerIn lsuMuxIn[DCACHE_LSU_PORT_NUM];\n    DCachePortMultiplexerTagOut lsuMuxTagOut[DCACHE_LSU_PORT_NUM];\n    DCachePortMultiplexerDataOut lsuMuxDataOut[DCACHE_LSU_PORT_NUM];    // Data array outputs are pipelined.\n\n    // MSHR<>Array\n    logic           mshrCacheReq[MSHR_NUM];\n    logic           mshrCacheGrt[MSHR_NUM];\n    DCachePortMultiplexerIn mshrCacheMuxIn[MSHR_NUM];\n    DCachePortMultiplexerTagOut mshrCacheMuxTagOut[MSHR_NUM];\n    DCachePortMultiplexerDataOut mshrCacheMuxDataOut[MSHR_NUM];    // Data array outputs are pipelined.\n\n    // Multiplexer\n    //\n    // \u4ee5\u4e0b2\u30ab\u6240\u304b\u3089\u6765\u308b\u5408\u8a08 R \u500b\u306e\u30a2\u30af\u30bb\u30b9\u8981\u6c42\u306b\u5bfe\u3057\u3066\uff0c\u6700\u5927 DCache \u306e\u30dd\u30fc\u30c8\u5206\u3060\u3051 grant \u3092\u8fd4\u3059\n    //   load unit/store unit: port.lsuCacheReq \n    //   mshr \u306e\u5168\u30a8\u30f3\u30c8\u30ea:     mshrCacheReq    \n    //\n    //   cacheArrayInGrant[p]=TRUE or FALSE \n    //     \u5272\u308a\u5f53\u3066\u306e\u7d50\u679c\uff0c\u30ad\u30e3\u30c3\u30b7\u30e5\u306e p \u756a\u76ee\u306e\u30dd\u30fc\u30c8\u306b\u8981\u6c42\u304c\u6765\u305f\u304b\u3069\u3046\u304b\n    //   cacheArrayInSel[P] = r: \n    //     \u4e0a\u8a18\u306e R \u500b \u30ea\u30af\u30a8\u30b9\u30c8\u306e\u3046\u3061\uff0cr \u756a\u76ee \u304c\n    //     \u30ad\u30e3\u30c3\u30b7\u30e5\u306e p \u756a\u76ee\u306e\u30dd\u30fc\u30c8\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u305f\n    //   cacheArrayOutSel[r] = p: \n    //     \u4e0a\u8a18\u306e R \u500b \u30ea\u30af\u30a8\u30b9\u30c8\u306e\u3046\u3061\uff0cr \u756a\u76ee \u304c\n    //     \u30ad\u30e3\u30c3\u30b7\u30e5\u306e p \u756a\u76ee\u306e\u30dd\u30fc\u30c8\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u305f\n    logic                   cacheArrayInGrant[DCACHE_ARRAY_PORT_NUM];\n    DCacheMuxPortIndexPath  cacheArrayInSel[DCACHE_ARRAY_PORT_NUM];\n    DCacheArrayPortIndex    cacheArrayOutSel[DCACHE_MUX_PORT_NUM];\n\n    // MSHR<>Memory\n    logic mshrMemReq[MSHR_NUM];\n    logic mshrMemGrt[MSHR_NUM];\n    MemoryPortMultiplexerIn mshrMemMuxIn[MSHR_NUM];\n    MemoryPortMultiplexerOut mshrMemMuxOut[MSHR_NUM];\n    MSHR_IndexPath memInSel;\n\n    // Memory\n    PhyAddrPath memAddr;\n    DCacheLinePath memData;\n    logic memValid;\n    logic memWE;\n    logic memReqAck;           // Request is accpeted or not.\n    MemAccessSerial memSerial; // Read request serial\n    MemAccessResult memAccessResult;\n    MemWriteSerial memWSerial; // Write request serial\n    MemAccessResponse memAccessResponse;\n\n    // Miss handler\n    logic initMSHR[MSHR_NUM];\n    PhyAddrPath initMSHR_Addr[MSHR_NUM];\n    ActiveListIndexPath initMSHR_ActiveListPtr[MSHR_NUM];\n\n    logic mshrValid[MSHR_NUM];\n    PhyAddrPath mshrAddr[MSHR_NUM];\n\n    MSHR_Phase mshrPhase[MSHR_NUM]; // MSHR phase.\n    DCacheLinePath mshrData[MSHR_NUM]; // Data in MSHR.\n\n    logic mshrCanBeInvalidDirect[MSHR_NUM];\n    logic isAllocatedByStore[MSHR_NUM];\n\n    logic isUncachable[MSHR_NUM];\n\n    VectorPath storedLineData;\n    logic [DCACHE_LINE_BYTE_NUM-1:0] storedLineByteWE;\n\n    // Controller\n    logic lsuCacheGrtReg[DCACHE_LSU_PORT_NUM];\n    logic dcFlushing;\n    logic dcFlushReqAck;\n    logic dcFlushComplete;\n    logic dcFlushReq;\n    logic flushComplete;\n    logic mshrFlushComplete;\n\n    modport DCacheController(\n    input\n        clk,\n        rst,\n        dcFlushReq,\n        flushComplete,\n        mshrPhase,\n        lsuCacheGrt,\n        lsuCacheGrtReg,\n        mshrFlushComplete,\n    output\n        dcFlushReqAck,\n        dcFlushComplete,\n        dcFlushing\n    );\n\n    modport DCacheArrayPortArbiter(\n    input\n        lsuCacheReq,\n        mshrCacheReq,\n        dcFlushing,\n    output\n        lsuCacheGrt,\n        mshrCacheGrt,\n        cacheArrayInSel,\n        cacheArrayOutSel,\n        cacheArrayInGrant\n    );\n\n    modport DCacheArrayPortMultiplexer(\n    input\n        clk,\n        rst,\n        rstStart,\n        mshrCacheMuxIn,\n        lsuMuxIn,\n        tagArrayDataOut,\n        tagArrayValidOut,\n        dataArrayDataOut,\n        replArrayDataOut,\n        cacheArrayInSel,\n        cacheArrayOutSel,\n        cacheArrayInGrant,\n        dataArrayDirtyOut,\n        mshrAddr,\n        mshrValid,\n        mshrPhase,\n        mshrData,\n    output\n        mshrCacheMuxTagOut,\n        mshrCacheMuxDataOut,\n        lsuMuxTagOut,\n        lsuMuxDataOut,\n        tagArrayWE,\n        tagArrayWriteWay,\n        tagArrayIndexIn,\n        tagArrayDataIn,\n        tagArrayValidIn,\n        dataArrayWE,\n        dataArrayIndexIn,\n        dataArrayDataIn,\n        dataArrayDirtyIn,\n        dataArrayByteWE_In,\n        dataArrayWriteWay,\n        dataArrayReadWay,\n        dataArrayDoesReadEvictedWay,\n        replArrayWE,\n        replArrayIndexIn,\n        replArrayDataIn\n    );\n\n\n    modport DCacheMemoryReqPortArbiter(\n    input\n        mshrMemReq,\n    output\n        mshrMemGrt,\n        memInSel,\n        memValid\n    );\n\n    modport DCacheMemoryReqPortMultiplexer(\n    input\n        memReqAck,\n        memSerial,\n        memWSerial,\n        mshrMemMuxIn,\n        memInSel,\n    output\n        memAddr,\n        memData,\n        memWE,\n        mshrMemMuxOut\n    );\n\n    modport DCacheMissHandler(\n    input\n        clk,\n        rst,\n        initMSHR,\n        initMSHR_Addr,\n        initMSHR_ActiveListPtr,\n        mshrCacheGrt,\n        mshrCacheMuxTagOut,\n        mshrCacheMuxDataOut,\n        mshrMemGrt,\n        mshrMemMuxOut,\n        memAccessResult,\n        memAccessResponse,\n        mshrCanBeInvalidDirect,\n        isAllocatedByStore,\n        isUncachable,\n        storedLineData,\n        storedLineByteWE,\n        dcFlushing,\n    output\n        mshrCacheReq,\n        mshrCacheMuxIn,\n        mshrMemReq,\n        mshrMemMuxIn,\n        mshrValid,\n        mshrAddr,\n        mshrPhase,\n        mshrData,\n        mshrFlushComplete\n    );\n\n    modport DCacheArray(\n    input\n        clk,\n        rst,\n        rstStart,\n        tagArrayWE,\n        tagArrayWriteWay,\n        tagArrayIndexIn,\n        tagArrayDataIn,\n        tagArrayValidIn,\n        dataArrayDataIn,\n        dataArrayIndexIn,\n        dataArrayDirtyIn,\n        dataArrayByteWE_In,\n        dataArrayWE,\n        dataArrayWriteWay,\n        dataArrayReadWay,\n        dataArrayDoesReadEvictedWay,\n        replArrayWE,\n        replArrayIndexIn,\n        replArrayDataIn,\n    output\n        tagArrayDataOut,\n        tagArrayValidOut,\n        dataArrayDataOut,\n        dataArrayDirtyOut,\n        replArrayDataOut\n    );\n\n\n\n    modport DCache(\n    input\n        clk,\n        rst,\n        lsuCacheGrt,\n        lsuMuxTagOut,\n        lsuMuxDataOut,\n        memAddr,\n        memData,\n        memWE,\n        memValid,\n        mshrValid,\n        mshrAddr,\n        mshrPhase,\n        dcFlushReqAck,\n        dcFlushComplete,\n    output\n        lsuCacheReq,\n        lsuMuxIn,\n        memReqAck,\n        memSerial,\n        memWSerial,\n        memAccessResponse,\n        initMSHR,\n        initMSHR_Addr,\n        initMSHR_ActiveListPtr,\n        isAllocatedByStore,\n        isUncachable,\n        mshrCanBeInvalidDirect,\n        storedLineData,\n        storedLineByteWE,\n        dcFlushReq,\n        flushComplete,\n        lsuCacheGrtReg\n    );\n\nendinterface\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Debug\n//\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport RenameLogicTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport LoadStoreUnitTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\n\nmodule Debug (\n    DebugIF.Debug port,\n    output PC_Path lastCommittedPC\n);\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    DebugRegister next;\n    \n    always_comb begin\n        // Signal from each stage\n        for ( int i = 0; i < FETCH_WIDTH; i++ ) begin\n            next.npReg[i] = port.npReg[i];\n            next.ifReg[i] = port.ifReg[i];\n        end\n        for ( int i = 0; i < DECODE_WIDTH; i++ ) begin\n            next.idReg[i] = port.idReg[i];\n        end\n        for ( int i = 0; i < DECODE_WIDTH; i++ ) begin\n            next.pdReg[i] = port.pdReg[i];\n        end\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            next.rnReg[i] = port.rnReg[i];\n        end\n        for ( int i = 0; i < DISPATCH_WIDTH; i++ ) begin\n            next.dsReg[i] = port.dsReg[i];\n        end\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n            next.intIsReg[i] = port.intIsReg[i];\n            next.intRrReg[i] = port.intRrReg[i];\n            next.intExReg[i] = port.intExReg[i];\n            next.intRwReg[i] = port.intRwReg[i];\n        end\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n            next.complexIsReg[i] = port.complexIsReg[i];\n            next.complexRrReg[i] = port.complexRrReg[i];\n            next.complexExReg[i] = port.complexExReg[i];\n            next.complexRwReg[i] = port.complexRwReg[i];\n        end\n`endif\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            next.memIsReg[i] = port.memIsReg[i];\n            next.memRrReg[i] = port.memRrReg[i];\n            next.memExReg[i] = port.memExReg[i];\n            next.maReg[i] = port.maReg[i];\n            next.mtReg[i] = port.mtReg[i];\n            next.memRwReg[i] = port.memRwReg[i];\n        end\n`ifdef RSD_MARCH_FP_PIPE\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n            next.fpIsReg[i] = port.fpIsReg[i];\n            next.fpRrReg[i] = port.fpRrReg[i];\n            next.fpExReg[i] = port.fpExReg[i];\n            next.fpRwReg[i] = port.fpRwReg[i];\n        end\n`endif\n        for ( int i = 0; i < COMMIT_WIDTH; i++ ) begin\n            next.cmReg[i] = port.cmReg[i];\n        end\n        \n        for ( int i = 0; i < ISSUE_QUEUE_ENTRY_NUM; i++ ) begin\n            next.scheduler[i]  = port.scheduler[i];\n            next.issueQueue[i] = port.issueQueue[i];\n        end\n\n        next.toRecoveryPhase = port.toRecoveryPhase;\n        next.activeListHeadPtr = port.activeListHeadPtr;\n        next.activeListCount = port.activeListCount;\n        \n        // PipelineControl\n        next.npStagePipeCtrl = port.npStagePipeCtrl;\n        next.ifStagePipeCtrl = port.ifStagePipeCtrl;\n        next.pdStagePipeCtrl = port.pdStagePipeCtrl;\n        next.idStagePipeCtrl = port.idStagePipeCtrl;\n        next.rnStagePipeCtrl = port.rnStagePipeCtrl;\n        next.dsStagePipeCtrl = port.dsStagePipeCtrl;\n        next.backEndPipeCtrl = port.backEndPipeCtrl;\n        next.cmStagePipeCtrl = port.cmStagePipeCtrl;\n        next.stallByDecodeStage = port.stallByDecodeStage;\n        \n        // last committed PC\n        lastCommittedPC = port.lastCommittedPC;\n        \n        // Others\n        next.loadStoreUnitAllocatable = port.loadStoreUnitAllocatable;\n        next.storeCommitterPhase = port.storeCommitterPhase;\n        next.storeQueueCount = port.storeQueueCount;\n        next.busyInRecovery = port.busyInRecovery;\n        next.storeQueueEmpty = port.storeQueueEmpty;\n\n`ifdef RSD_FUNCTIONAL_SIMULATION\n        // Performance monitoring counters are exported to DebugRegister only on simulation.\n        next.perfCounter = port.perfCounter;\n`endif\n    end\n\n    DebugRegister debugRegister;\n    always_ff @(posedge port.clk) begin\n        debugRegister <= next;\n    end\n    \n    always_comb begin\n        port.debugRegister = debugRegister;\n    end\n`else\n    always_comb begin\n        port.debugRegister = FALSE; // Suppressing warning.\n    end\n`endif\nendmodule : Debug\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- DebugIF\n//\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport DebugTypes::*;\nimport RenameLogicTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport LoadStoreUnitTypes::*;\nimport PipelineTypes::*;\n\ninterface DebugIF( input logic clk, rst );\n    \n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    // Main\u30e2\u30b8\u30e5\u30fc\u30eb\u5916\u90e8\u3078\u51fa\u529b\u3059\u308b\u4fe1\u53f7\u7fa4\n    DebugRegister debugRegister;\n    \n    // debugRegister\u306e\u5165\u529b\u3068\u306a\u308b\u4fe1\u53f7\u7fa4\n    // \u5404\u30b9\u30c6\u30fc\u30b8\u304b\u3089\u30c7\u30fc\u30bf\u3092\u96c6\u3081\u308b\n    NextPCStageDebugRegister npReg [ FETCH_WIDTH ];\n    FetchStageDebugRegister   ifReg [ FETCH_WIDTH ];\n    PreDecodeStageDebugRegister pdReg [ DECODE_WIDTH ];\n    DecodeStageDebugRegister    idReg [ DECODE_WIDTH ];\n    RenameStageDebugRegister    rnReg [ RENAME_WIDTH ];\n    DispatchStageDebugRegister  dsReg [ DISPATCH_WIDTH ];\n    \n    IntegerIssueStageDebugRegister         intIsReg [ INT_ISSUE_WIDTH ];\n    IntegerRegisterReadStageDebugRegister  intRrReg [ INT_ISSUE_WIDTH ];\n    IntegerExecutionStageDebugRegister     intExReg [ INT_ISSUE_WIDTH ];\n    IntegerRegisterWriteStageDebugRegister intRwReg [ INT_ISSUE_WIDTH ];\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    ComplexIntegerIssueStageDebugRegister         complexIsReg [ COMPLEX_ISSUE_WIDTH ];\n    ComplexIntegerRegisterReadStageDebugRegister  complexRrReg [ COMPLEX_ISSUE_WIDTH ];\n    ComplexIntegerExecutionStageDebugRegister     complexExReg [ COMPLEX_ISSUE_WIDTH ];\n    ComplexIntegerRegisterWriteStageDebugRegister complexRwReg [ COMPLEX_ISSUE_WIDTH ];\n`endif\n\n    MemoryIssueStageDebugRegister          memIsReg [ MEM_ISSUE_WIDTH ];\n    MemoryRegisterReadStageDebugRegister   memRrReg [ MEM_ISSUE_WIDTH ];\n    MemoryExecutionStageDebugRegister      memExReg [ MEM_ISSUE_WIDTH ];\n    MemoryTagAccessStageDebugRegister      mtReg    [ MEM_ISSUE_WIDTH ];\n    MemoryAccessStageDebugRegister         maReg    [ MEM_ISSUE_WIDTH ];\n    MemoryRegisterWriteStageDebugRegister  memRwReg [ MEM_ISSUE_WIDTH ];\n\n`ifdef RSD_MARCH_FP_PIPE\n    FPIssueStageDebugRegister         fpIsReg [ FP_ISSUE_WIDTH ];\n    FPRegisterReadStageDebugRegister  fpRrReg [ FP_ISSUE_WIDTH ];\n    FPExecutionStageDebugRegister     fpExReg [ FP_ISSUE_WIDTH ];\n    FPRegisterWriteStageDebugRegister fpRwReg [ FP_ISSUE_WIDTH ];\n`endif\n\n    CommitStageDebugRegister cmReg [ COMMIT_WIDTH ];\n\n    SchedulerDebugRegister  scheduler [ ISSUE_QUEUE_ENTRY_NUM ];\n    IssueQueueDebugRegister issueQueue [ ISSUE_QUEUE_ENTRY_NUM ];\n\n    PC_Path lastCommittedPC;\n    logic recover, toRecoveryPhase;\n    ActiveListIndexPath activeListHeadPtr;\n    ActiveListCountPath activeListCount;\n    \n    // debugRegister\u306e\u5165\u529b\u3068\u306a\u308b\u4fe1\u53f7\u7fa4\n    // \u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u304b\u3089\u30c7\u30fc\u30bf\u3092\u96c6\u3081\u308b\n    PipelineControll npStagePipeCtrl;\n    PipelineControll ifStagePipeCtrl;\n    PipelineControll pdStagePipeCtrl;\n    PipelineControll idStagePipeCtrl;\n    PipelineControll rnStagePipeCtrl;\n    PipelineControll dsStagePipeCtrl;\n    PipelineControll backEndPipeCtrl;\n    PipelineControll cmStagePipeCtrl;\n    logic stallByDecodeStage;\n\n    logic loadStoreUnitAllocatable;\n    logic storeCommitterPhase;\n    StoreQueueCountPath storeQueueCount;\n    logic busyInRecovery;\n    logic storeQueueEmpty;\n\n    PerfCounterPath perfCounter;\n\n    modport Debug (\n    input \n        clk,\n        rst,\n        npReg,\n        ifReg,\n        pdReg,\n        idReg,\n        rnReg,\n        dsReg,\n        intIsReg,\n        intRrReg,\n        intExReg,\n        intRwReg,\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        complexIsReg,\n        complexRrReg,\n        complexExReg,\n        complexRwReg,\n`endif\n        memIsReg,\n        memRrReg,\n        memExReg,\n        maReg,\n        mtReg,\n        memRwReg,\n`ifdef RSD_MARCH_FP_PIPE\n        fpIsReg,\n        fpRrReg,\n        fpExReg,\n        fpRwReg,\n`endif\n        cmReg,\n        scheduler,\n        issueQueue,\n        recover,\n        toRecoveryPhase,\n        activeListHeadPtr,\n        activeListCount,\n        lastCommittedPC,\n        npStagePipeCtrl,\n        ifStagePipeCtrl,\n        pdStagePipeCtrl,\n        idStagePipeCtrl,\n        rnStagePipeCtrl,\n        dsStagePipeCtrl,\n        backEndPipeCtrl,\n        cmStagePipeCtrl,\n        stallByDecodeStage,\n        loadStoreUnitAllocatable,\n        storeCommitterPhase,\n        storeQueueCount,\n        busyInRecovery,\n        storeQueueEmpty,\n        perfCounter,\n    output\n        debugRegister\n    );\n    \n    modport StoreCommitter (\n    output\n        loadStoreUnitAllocatable,\n        storeCommitterPhase,\n        storeQueueCount,\n        busyInRecovery,\n        storeQueueEmpty\n    );\n    \n    modport Controller (\n    output\n        npStagePipeCtrl,\n        ifStagePipeCtrl,\n        pdStagePipeCtrl,\n        idStagePipeCtrl,\n        rnStagePipeCtrl,\n        dsStagePipeCtrl,\n        backEndPipeCtrl,\n        cmStagePipeCtrl,\n        stallByDecodeStage\n    );\n    \n    modport ActiveList (\n    output\n        activeListHeadPtr,\n        activeListCount\n    );\n    \n    modport Scheduler (\n    output\n        scheduler\n    );\n    \n    modport IssueQueue (\n    output\n        issueQueue\n    );\n\n    modport NextPCStage (\n    output\n        npReg\n    );\n\n    modport FetchStage (\n    output\n        ifReg\n    );\n\n    modport PreDecodeStage (\n    output\n        pdReg\n    );\n\n    modport DecodeStage (\n    output\n        idReg\n    );\n    \n    modport RenameStage (\n    output\n        rnReg\n    );\n\n    modport DispatchStage (\n    output\n        dsReg\n    );\n    \n    modport IntegerIssueStage (\n    output\n        intIsReg\n    );\n    \n    modport IntegerRegisterReadStage (\n    output\n        intRrReg\n    );\n    \n    modport IntegerExecutionStage (\n    output\n        intExReg\n    );\n    \n    modport IntegerRegisterWriteStage (\n    output\n        intRwReg\n    );\n    \n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    modport ComplexIntegerIssueStage (\n    output\n        complexIsReg\n    );\n    \n    modport ComplexIntegerRegisterReadStage (\n    output\n        complexRrReg\n    );\n    \n    modport ComplexIntegerExecutionStage (\n    output\n        complexExReg\n    );\n    \n    modport ComplexIntegerRegisterWriteStage (\n    output\n        complexRwReg\n    );\n`endif\n    \n    modport MemoryIssueStage (\n    output\n        memIsReg\n    );\n    \n    modport MemoryRegisterReadStage (\n    output\n        memRrReg\n    );\n    \n    modport MemoryExecutionStage (\n    output\n        memExReg\n    );\n    \n    modport MemoryTagAccessStage (\n    output\n        mtReg\n    );\n\n    modport MemoryAccessStage (\n    output\n        maReg\n    );\n    \n    modport MemoryRegisterWriteStage (\n    output\n        memRwReg\n    );\n\n`ifdef RSD_MARCH_FP_PIPE\n    modport FPIssueStage (\n    output\n        fpIsReg\n    );\n    \n    modport FPRegisterReadStage (\n    output\n        fpRrReg\n    );\n    \n    modport FPExecutionStage (\n    output\n        fpExReg\n    );\n    \n    modport FPRegisterWriteStage (\n    output\n        fpRwReg\n    );\n`endif\n\n    modport CommitStage (\n    output\n        lastCommittedPC,\n        recover,\n        toRecoveryPhase,\n        cmReg\n    );\n\n    modport PerformanceCounter (\n    output \n        perfCounter\n    );\n    \n`else\n\n    // When debug signals are disabled.\n    PC_Path lastCommittedPC;\n    DebugRegister debugRegister;\n    \n    modport Debug (\n        input clk, lastCommittedPC,\n        output debugRegister\n        \n    );\n    \n    modport StoreCommitter (\n        input clk\n    );\n    \n    modport Controller (\n        input clk\n    );\n    \n    modport ActiveList (\n        input clk\n    );\n    \n    modport Scheduler (\n        input clk\n    );\n    \n    modport IssueQueue (\n        input clk\n    );\n    \n    modport FetchStage (\n        input clk\n    );\n\n    modport NextPCStage (\n        input clk\n    );\n\n    modport PreDecodeStage (\n        input clk\n    );\n\n    modport DecodeStage (\n        input clk\n    );\n    \n    modport RenameStage (\n        input clk\n    );\n\n    modport DispatchStage (\n        input clk\n    );\n    \n    modport IntegerIssueStage (\n        input clk\n    );\n    \n    modport IntegerRegisterReadStage (\n        input clk\n    );\n    \n    modport IntegerExecutionStage (\n        input clk\n    );\n    \n    modport IntegerRegisterWriteStage (\n        input clk\n    );\n    \n    modport ComplexIntegerIssueStage (\n        input clk\n    );\n    \n    modport ComplexIntegerRegisterReadStage (\n        input clk\n    );\n    \n    modport ComplexIntegerExecutionStage (\n        input clk\n    );\n    \n    modport ComplexIntegerRegisterWriteStage (\n        input clk\n    );\n\n`ifdef RSD_MARCH_FP_PIPE\n    modport FPIssueStage (\n        input clk\n    );\n    \n    modport FPRegisterReadStage (\n        input clk\n    );\n    \n    modport FPExecutionStage (\n        input clk\n    );\n    \n    modport FPRegisterWriteStage (\n        input clk\n    );\n`endif\n    \n    modport MemoryIssueStage (\n        input clk\n    );\n    \n    modport MemoryRegisterReadStage (\n        input clk\n    );\n    \n    modport MemoryExecutionStage (\n        input clk\n    );\n    \n    modport MemoryTagAccessStage (\n        input clk\n    );\n    modport MemoryAccessStage (\n        input clk\n    );\n    \n    modport MemoryRegisterWriteStage (\n        input clk\n    );\n\n    modport CommitStage (\n        input clk,\n        output lastCommittedPC\n    );\n\n    modport PerformanceCounter (\n        input clk\n    );\n`endif\n\n\nendinterface : DebugIF\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- Types related to debug.\n//\n\n\npackage DebugTypes;\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport RenameLogicTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport LoadStoreUnitTypes::*;\nimport PipelineTypes::*;\n\n//\n// --- Hardware Counter\n//\n\ntypedef struct packed { // \n    DataPath numIC_Miss;\n    DataPath numLoadMiss;\n    DataPath numStoreMiss;\n    DataPath numBranchPredMiss;\n\n    DataPath numBranchPredMissDetectedOnDecode;\n    DataPath numStoreLoadForwardingFail;\n    DataPath numMemDepPredMiss;\n} PerfCounterPath;\n\n\n//\n// --- Debug Register\n//\n\ntypedef struct packed { // NextPCStageDebugRegister\n    logic valid;\n    OpSerial sid;\n} NextPCStageDebugRegister;\n\ntypedef struct packed { // FetchStageDebugRegister\n    logic valid;\n    OpSerial sid;\n    logic flush;\n    logic icMiss;\n} FetchStageDebugRegister;\n\ntypedef struct packed { // PreDecodeStageDebugRegister\n    logic valid;\n    OpSerial sid;\n`ifdef RSD_FUNCTIONAL_SIMULATION\n    // \u6f14\u7b97\u306e\u30bd\u30fc\u30b9\u3068\u7d50\u679c\u306e\u5024\u306f\u3001\u6a5f\u80fd\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u6642\u306e\u307f\u30c7\u30d0\u30c3\u30b0\u51fa\u529b\u3059\u308b\n    // \u5408\u6210\u6642\u306f\u3001IO\u30dd\u30fc\u30c8\u304c\u8db3\u308a\u306a\u304f\u3066\u4e0d\u53ef\u80fd\u3067\u3042\u308b\u305f\u3081\n    IntALU_Code aluCode;\n    IntMicroOpSubType opType;\n`endif\n} PreDecodeStageDebugRegister;\n\ntypedef struct packed { // DecodeStageDebugRegister\n    logic valid;\n    logic flushed;    // Branch misprediction is detected on instruction decode and flush this instruction.\n    logic flushTriggering;   // This op causes branch misprediction and triggers flush.\n    OpId opId;\n    AddrPath pc;\n    InsnPath insn;\n    logic undefined;\n    logic unsupported;\n} DecodeStageDebugRegister;\n\ntypedef struct packed { // RenameStageDebugRegister\n    logic valid;\n    OpId opId;\n\n    // Physical register numbers are outputted in the next stage, because\n    // The pop flags of the free list is negated and correct physical\n    // register numbers cannot be outputted in this stage when the pipeline\n    // is stalled.\n} RenameStageDebugRegister;\n\ntypedef struct packed { // DispatchStageDebugRegister\n    logic valid;\n    OpId opId;\n\n\n`ifdef RSD_FUNCTIONAL_SIMULATION\n    // \u30ec\u30b8\u30b9\u30bf\u756a\u53f7\u306f\u3001\u6a5f\u80fd\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u6642\u306e\u307f\u30c7\u30d0\u30c3\u30b0\u51fa\u529b\u3059\u308b\n    // \u5408\u6210\u6642\u306f\u3001IO\u30dd\u30fc\u30c8\u304c\u8db3\u308a\u306a\u304f\u3066\u4e0d\u53ef\u80fd\u3067\u3042\u308b\u305f\u3081\n    logic readRegA;\n    LRegNumPath logSrcRegA;\n    PRegNumPath phySrcRegA;\n\n    logic readRegB;\n    LRegNumPath logSrcRegB;\n    PRegNumPath phySrcRegB;\n\n`ifdef RSD_MARCH_FP_PIPE\n    logic readRegC;\n    LRegNumPath logSrcRegC;\n    PRegNumPath phySrcRegC;\n`endif\n\n    logic writeReg;\n    LRegNumPath logDstReg;\n    PRegNumPath phyDstReg;\n    PRegNumPath phyPrevDstReg;\n\n    ActiveListIndexPath activeListPtr;\n    IssueQueueIndexPath issueQueuePtr;\n`endif\n} DispatchStageDebugRegister;\n\ntypedef struct packed { // IntegerIssueStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n} IntegerIssueStageDebugRegister;\n\ntypedef struct packed { // IntegerRegisterReadStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n} IntegerRegisterReadStageDebugRegister;\n\ntypedef struct packed { // IntegerExecutionStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n\n`ifdef RSD_FUNCTIONAL_SIMULATION\n    // Output source values and an execution result only on functional simulation\n    // because actual chips do not have enough IO pins for these signals.\n    DataPath dataOut;\n    DataPath fuOpA;\n    DataPath fuOpB;\n    IntALU_Code aluCode;\n    IntMicroOpSubType opType;\n    logic brPredMiss;\n`endif\n\n} IntegerExecutionStageDebugRegister;\n\ntypedef struct packed { // IntegerRegisterWriteStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n} IntegerRegisterWriteStageDebugRegister;\n\ntypedef struct packed { // ComplexIntegerIssueStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n} ComplexIntegerIssueStageDebugRegister;\n\ntypedef struct packed { // ComplexIntegerRegisterReadStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n} ComplexIntegerRegisterReadStageDebugRegister;\n\ntypedef struct packed { // ComplexIntegerExecutionStageDebugRegister\n    logic [ COMPLEX_EXEC_STAGE_DEPTH-1:0 ] valid;\n    logic [ COMPLEX_EXEC_STAGE_DEPTH-1:0 ] flush;\n    OpId [ COMPLEX_EXEC_STAGE_DEPTH-1:0 ] opId;\n\n`ifdef RSD_FUNCTIONAL_SIMULATION\n    // \u6f14\u7b97\u306e\u30bd\u30fc\u30b9\u3068\u7d50\u679c\u306e\u5024\u306f\u3001\u6a5f\u80fd\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u6642\u306e\u307f\u30c7\u30d0\u30c3\u30b0\u51fa\u529b\u3059\u308b\n    // \u5408\u6210\u6642\u306f\u3001IO\u30dd\u30fc\u30c8\u304c\u8db3\u308a\u306a\u304f\u3066\u4e0d\u53ef\u80fd\u3067\u3042\u308b\u305f\u3081\n    DataPath dataOut;\n    DataPath fuOpA;\n    DataPath fuOpB;\n`endif\n\n} ComplexIntegerExecutionStageDebugRegister;\n\ntypedef struct packed { // ComplexIntegerRegisterWriteStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n} ComplexIntegerRegisterWriteStageDebugRegister;\n\ntypedef struct packed { // MemoryIssueStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n} MemoryIssueStageDebugRegister;\n\ntypedef struct packed { // MemoryRegisterReadStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n} MemoryRegisterReadStageDebugRegister;\n\ntypedef struct packed { // MemoryExecutionStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n\n`ifdef RSD_FUNCTIONAL_SIMULATION\n    // \u6f14\u7b97\u306e\u30bd\u30fc\u30b9\u3068\u7d50\u679c\u306e\u5024\u306f\u3001\u6a5f\u80fd\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u6642\u306e\u307f\u30c7\u30d0\u30c3\u30b0\u51fa\u529b\u3059\u308b\n    // \u5408\u6210\u6642\u306f\u3001IO\u30dd\u30fc\u30c8\u304c\u8db3\u308a\u306a\u304f\u3066\u4e0d\u53ef\u80fd\u3067\u3042\u308b\u305f\u3081\n    AddrPath addrOut;\n    DataPath fuOpA;\n    DataPath fuOpB;\n    MemMicroOpSubType opType;\n    MemAccessSizeType size;\n    logic isSigned;\n`endif\n\n} MemoryExecutionStageDebugRegister;\n\ntypedef struct packed { // MemoryTagAccessStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n`ifdef RSD_FUNCTIONAL_SIMULATION\n    logic executeLoad;\n    AddrPath executedLoadAddr;\n    logic mshrAllocated;\n    logic mshrHit;\n    DataPath mshrEntryID;\n    logic executeStore;\n    AddrPath executedStoreAddr;\n    DataPath executedStoreData;\n    VectorPath executedStoreVectorData;\n`endif\n} MemoryTagAccessStageDebugRegister;\n\ntypedef struct packed { // MemoryAccessStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n`ifdef RSD_FUNCTIONAL_SIMULATION\n    logic executeLoad;\n    DataPath executedLoadData;\n    VectorPath executedLoadVectorData;\n`endif\n} MemoryAccessStageDebugRegister;\n\ntypedef struct packed { // MemoryRegisterWriteStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n} MemoryRegisterWriteStageDebugRegister;\n\n`ifdef RSD_MARCH_FP_PIPE\ntypedef struct packed { // FPIssueStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n} FPIssueStageDebugRegister;\n\ntypedef struct packed { // FPRegisterReadStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n} FPRegisterReadStageDebugRegister;\n\ntypedef struct packed { // FPExecutionStageDebugRegister\n    logic [ FP_EXEC_STAGE_DEPTH-1:0 ] valid;\n    logic [ FP_EXEC_STAGE_DEPTH-1:0 ] flush;\n    OpId [ FP_EXEC_STAGE_DEPTH-1:0 ] opId;\n\n`ifdef RSD_FUNCTIONAL_SIMULATION\n    // \u6f14\u7b97\u306e\u30bd\u30fc\u30b9\u3068\u7d50\u679c\u306e\u5024\u306f\u3001\u6a5f\u80fd\u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u6642\u306e\u307f\u30c7\u30d0\u30c3\u30b0\u51fa\u529b\u3059\u308b\n    // \u5408\u6210\u6642\u306f\u3001IO\u30dd\u30fc\u30c8\u304c\u8db3\u308a\u306a\u304f\u3066\u4e0d\u53ef\u80fd\u3067\u3042\u308b\u305f\u3081\n    DataPath dataOut;\n    DataPath fuOpA;\n    DataPath fuOpB;\n    DataPath fuOpC;\n`endif\n\n} FPExecutionStageDebugRegister;\n\ntypedef struct packed { // FPRegisterWriteStageDebugRegister\n    logic valid;\n    logic flush;\n    OpId opId;\n} FPRegisterWriteStageDebugRegister;\n`endif\n\ntypedef struct packed { // CommitStageDebugRegister\n    logic commit;\n    logic flush;\n    OpId opId;\n\n`ifdef RSD_FUNCTIONAL_SIMULATION\n    logic releaseReg;\n    PRegNumPath phyReleasedReg;\n`endif\n} CommitStageDebugRegister;\n\ntypedef struct packed { // ActiveListDebugRegister\n    logic finished;\n    OpId opId;\n} ActiveListDebugRegister;\n\ntypedef struct packed { // SchedulerDebugRegister\n    logic valid;\n} SchedulerDebugRegister;\n\ntypedef struct packed { // IssueQueueDebugRegister\n    logic flush;\n    OpId opId;\n} IssueQueueDebugRegister;\n\n\n\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\ntypedef struct packed { // DebugRegister\n\n    // DebugRegister of each stage\n    NextPCStageDebugRegister [ FETCH_WIDTH-1:0 ] npReg;\n    FetchStageDebugRegister   [ FETCH_WIDTH-1:0 ] ifReg;\n    PreDecodeStageDebugRegister[ DECODE_WIDTH-1:0 ]   pdReg;\n    DecodeStageDebugRegister   [ DECODE_WIDTH-1:0 ]   idReg;\n    RenameStageDebugRegister   [ RENAME_WIDTH-1:0 ]   rnReg;\n    DispatchStageDebugRegister [ DISPATCH_WIDTH-1:0 ] dsReg;\n\n    IntegerIssueStageDebugRegister         [ INT_ISSUE_WIDTH-1:0 ] intIsReg;\n    IntegerRegisterReadStageDebugRegister  [ INT_ISSUE_WIDTH-1:0 ] intRrReg;\n    IntegerExecutionStageDebugRegister     [ INT_ISSUE_WIDTH-1:0 ] intExReg;\n    IntegerRegisterWriteStageDebugRegister [ INT_ISSUE_WIDTH-1:0 ] intRwReg;\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    ComplexIntegerIssueStageDebugRegister         [ COMPLEX_ISSUE_WIDTH-1:0 ] complexIsReg;\n    ComplexIntegerRegisterReadStageDebugRegister  [ COMPLEX_ISSUE_WIDTH-1:0 ] complexRrReg;\n    ComplexIntegerExecutionStageDebugRegister     [ COMPLEX_ISSUE_WIDTH-1:0 ] complexExReg;\n    ComplexIntegerRegisterWriteStageDebugRegister [ COMPLEX_ISSUE_WIDTH-1:0 ] complexRwReg;\n`endif\n\n    MemoryIssueStageDebugRegister          [ MEM_ISSUE_WIDTH-1:0 ] memIsReg;\n    MemoryRegisterReadStageDebugRegister   [ MEM_ISSUE_WIDTH-1:0 ] memRrReg;\n    MemoryExecutionStageDebugRegister      [ MEM_ISSUE_WIDTH-1:0 ] memExReg;\n    MemoryTagAccessStageDebugRegister      [ MEM_ISSUE_WIDTH-1:0 ] mtReg;\n    MemoryAccessStageDebugRegister         [ MEM_ISSUE_WIDTH-1:0 ] maReg;\n    MemoryRegisterWriteStageDebugRegister  [ MEM_ISSUE_WIDTH-1:0 ] memRwReg;\n\n`ifdef RSD_MARCH_FP_PIPE\n    FPIssueStageDebugRegister         [ FP_ISSUE_WIDTH-1:0 ] fpIsReg;\n    FPRegisterReadStageDebugRegister  [ FP_ISSUE_WIDTH-1:0 ] fpRrReg;\n    FPExecutionStageDebugRegister     [ FP_ISSUE_WIDTH-1:0 ] fpExReg;\n    FPRegisterWriteStageDebugRegister [ FP_ISSUE_WIDTH-1:0 ] fpRwReg;\n`endif\n\n    CommitStageDebugRegister [ COMMIT_WIDTH-1:0 ] cmReg;\n\n    SchedulerDebugRegister  [ ISSUE_QUEUE_ENTRY_NUM-1:0 ] scheduler;\n    IssueQueueDebugRegister [ ISSUE_QUEUE_ENTRY_NUM-1:0 ] issueQueue;\n\n    // Signals related to commit\n    logic toRecoveryPhase;\n    ActiveListIndexPath activeListHeadPtr;\n    ActiveListCountPath activeListCount;\n\n    // Pipeline control signal\n    PipelineControll npStagePipeCtrl;\n    PipelineControll ifStagePipeCtrl;\n    PipelineControll pdStagePipeCtrl;\n    PipelineControll idStagePipeCtrl;\n    PipelineControll rnStagePipeCtrl;\n    PipelineControll dsStagePipeCtrl;\n    PipelineControll backEndPipeCtrl;\n    PipelineControll cmStagePipeCtrl;\n    logic stallByDecodeStage;\n\n    // Others\n    logic loadStoreUnitAllocatable;\n    logic storeCommitterPhase;\n    StoreQueueCountPath storeQueueCount;\n    logic busyInRecovery;\n    logic storeQueueEmpty;\n\n`ifdef RSD_FUNCTIONAL_SIMULATION\n    // Performance monitoring counters are exported to DebugRegister only on simulation.\n    PerfCounterPath perfCounter;\n`endif\n} DebugRegister;\n`else\n    // Dummy definition\n    typedef logic DebugRegister;\n`endif\n\nendpackage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Resolve branch misprediction on the decode stage.\n// This unit includes a simple return address stack.\n//\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\nimport FetchUnitTypes::*;\n\nmodule DecodedBranchResolver(\ninput\n    logic clk, rst, stall, decodeComplete,\n    logic insnValidIn[DECODE_WIDTH],\n    RISCV_ISF_Common [DECODE_WIDTH-1 : 0] isf,      // Unpacked array of structure corrupts in Modelsim.\n    BranchPred [DECODE_WIDTH-1 : 0] brPredIn,\n    PC_Path pc[DECODE_WIDTH],\n    InsnInfo [DECODE_WIDTH-1 : 0] insnInfo,\noutput \n    logic insnValidOut[DECODE_WIDTH],\n    logic insnFlushed[DECODE_WIDTH],\n    logic insnFlushTriggering[DECODE_WIDTH],\n    logic flushTriggered,\n    BranchPred brPredOut[DECODE_WIDTH],\n    PC_Path recoveredPC\n);\n    // Return address stack.\n    parameter RAS_ENTRY_NUM = 4;\n    typedef logic [$clog2(RAS_ENTRY_NUM)-1 : 0] RAS_IndexPath;\n    PC_Path ras[RAS_ENTRY_NUM];\n    PC_Path nextRAS;\n    logic pushRAS;\n    logic popRAS;\n    RAS_IndexPath rasPtr;\n    RAS_IndexPath nextRAS_Ptr;\n\n    always_ff@(posedge clk) begin\n        if (rst) begin\n            for (int i = 0; i < RAS_ENTRY_NUM; i++) begin\n                ras[i] <= '0;\n            end\n            rasPtr <= '0;\n        end\n        else if (!stall && decodeComplete) begin\n            // \u5168 micro op \u306e\u30c7\u30b3\u30fc\u30c9\u5b8c\u4e86\u6642\u306b\u3060\u3051 RAS \u3092\u66f4\u65b0\u3059\u308b\u3088\u3046\u306b\u3057\u306a\u3044\u3068\uff0c\n            // \u6b21\u306e\u30b9\u30c6\u30fc\u30b8\u306b\u9001\u308a\u8fbc\u3093\u3060 micro op \u306e\u30bf\u30fc\u30b2\u30c3\u30c8\u3068\uff0c\u3053\u3053\u304b\u3089\n            // \u51fa\u3057\u3066\u3044\u308b\u30bf\u30fc\u30b2\u30c3\u30c8\u30a2\u30c9\u30ec\u30b9\u304c\u305a\u308c\u3066\uff08ras \u306e ptr \u304c\u66f4\u65b0\u3055\u308c\u308b\u304b\u3089\uff09\n            // \u6b63\u3057\u304f\u52d5\u304b\u306a\u304f\u306a\u308b\n            if (pushRAS) begin\n                ras[nextRAS_Ptr] <= nextRAS;\n            end\n            rasPtr <= nextRAS_Ptr;\n        end\n        // if (pushRAS) begin\n        //     $display(\"Call(%d) flush @%x old:%p new:%p\", nextRAS_Ptr, pc[addrCheckLane], brPredIn[addrCheckLane].predAddr, decodedPC[addrCheckLane]);\n        // end \n        // else if (popRAS) begin\n        //     $display(\"Ret(%d)  @%x old:%p new:%p\", rasPtr, pc[addrCheckLane], brPredIn[addrCheckLane].predAddr, decodedPC[addrCheckLane]);\n        // end\n        // if (flushTriggered) begin\n        //     $display(\"flushTriggered @%x old:%p new:%p\", pc[addrCheckLane], brPredIn[addrCheckLane].predAddr, decodedPC[addrCheckLane]);\n        // end\n    end\n\n    \n    PC_Path decodedPC[DECODE_WIDTH];\n    PC_Path nextPC[DECODE_WIDTH];\n    RISCV_ISF_U isfU[DECODE_WIDTH];\n\n    logic addrCheck;\n    logic addrIncorrect;\n    DecodeLaneIndexPath addrCheckLane;\n    typedef enum logic [1:0] \n    {\n        BTT_NEXT = 0,       // nextPC \n        BTT_PC_RELATIVE = 1,         // BRANCH, JAL\n        BTT_INDIRECT_JUMP  = 2,       // JALR\n\n        // This insn is serialized, so the succeeding insns are flushed\n        BTT_SERIALIZED  = 3 \n    } BranchTargetType;\n    BranchTargetType brTargetType[DECODE_WIDTH];\n    logic addrMismatch[DECODE_WIDTH];\n\n    always_comb begin\n        \n        // Initialize\n        flushTriggered = FALSE;\n        recoveredPC = '0;\n\n        pushRAS = FALSE;\n        popRAS = FALSE;\n        nextRAS = 0;\n        nextRAS_Ptr = rasPtr;\n        \n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            insnValidOut[i] = insnValidIn[i];\n            insnFlushed[i] = FALSE;\n            insnFlushTriggering[i] = FALSE;\n            brPredOut[i] = brPredIn[i];\n            isfU[i] = isf[i];\n        end\n\n        addrCheck = FALSE;\n        addrIncorrect = FALSE;\n        addrCheckLane = '0;\n        \n        // Determine the type of branch\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            \n            if (insnInfo[i].isRelBranch) begin\n                // Normal branch.\n                brTargetType[i] = BTT_PC_RELATIVE;\n            end\n            else if (insnInfo[i].writePC) begin\n                // Indirect branch\n                brTargetType[i] = BTT_INDIRECT_JUMP;\n            end\n            else if (insnInfo[i].isSerialized) begin\n                brTargetType[i] = BTT_SERIALIZED;\n            end\n            else begin\n                brTargetType[i] = BTT_NEXT;\n            end\n        end\n\n        // Detects possible  patterns where flash occurs\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            if (!insnValidIn[i]) begin\n                break;\n            end\n            \n            if (!insnInfo[i].writePC && brPredIn[i].predTaken) begin\n                // Recovery if not branch instructions are predicted as branches.\n                addrCheckLane = i;\n                addrCheck = TRUE;\n                addrIncorrect = TRUE;   // \u30df\u30b9\u304c\u78ba\u5b9a\n                break;\n            end\n            else if ( //JAL || ( Branch && predTaken )\n                brTargetType[i] == BTT_PC_RELATIVE && \n                (isfU[i].opCode == RISCV_JAL || brPredIn[i].predTaken)   \n            ) begin\n                // Update the RAS.\n                pushRAS = insnInfo[i].isCall;\n\n                addrCheckLane = i;\n                addrCheck = TRUE;\n                break;\n            end\n            else if ( // JALR\n                brTargetType[i] == BTT_INDIRECT_JUMP\n            ) begin\n                // Update theRAS.\n                pushRAS = insnInfo[i].isCall;\n                popRAS = insnInfo[i].isReturn;\n\n                if (popRAS) begin\n                    // Resolve branch pred using the PC read from RAS\n                    addrCheckLane = i;\n                    addrCheck = TRUE;\n                    break;\n                end\n                else if (pushRAS) begin\n                    // Push next PC to RAS\uff0eDo not resolve branch pred\n                    addrCheckLane = i;\n                    break;\n                end\n            end\n            else if (brTargetType[i] == BTT_SERIALIZED) begin\n                // The succeeding instructions are flushed.\n                addrCheckLane = i;\n                addrCheck = TRUE;\n                addrIncorrect = TRUE;   // \u30df\u30b9\u304c\u78ba\u5b9a\n                break;\n            end\n        end\n        \n        // Calculate target PC\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            nextPC[i] = pc[i] + INSN_BYTE_WIDTH;\n            if (brTargetType[i] == BTT_PC_RELATIVE) begin\n                // Calculate target PC from displacement\n                if (isfU[i].opCode == RISCV_JAL) begin\n                    decodedPC[i] = pc[i] + ExtendBranchDisplacement( GetJAL_Target(isfU[i]));\n                end\n                else begin\n                    decodedPC[i] = pc[i] + ExtendBranchDisplacement( GetBranchDisplacement(isfU[i]));\n                end\n            end\n            else if (brTargetType[i] == BTT_INDIRECT_JUMP) begin\n                // Read branch target PC from RAS\n                decodedPC[i] = ras[rasPtr];\n            end\n            else begin\n                // non-branch instruction\n                decodedPC[i] = nextPC[i];\n            end\n        end\n        \n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            addrMismatch[i] = brPredIn[i].predAddr != decodedPC[i];\n        end\n        \n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            if (((addrMismatch[i] && addrCheck) || addrIncorrect) && addrCheckLane == i) begin\n                flushTriggered = TRUE;\n                brPredOut[i].predAddr = decodedPC[i];\n                brPredOut[i].predTaken = TRUE;\n                break;\n            end\n        end\n        recoveredPC = decodedPC[addrCheckLane];\n\n        // Update the RAS.\n        nextRAS = nextPC[addrCheckLane];\n        if (pushRAS) begin\n            // $display(\"Call(%d) flush @%x old:%p new:%p\", nextRAS_Ptr, pc[addrCheckLane], brPredIn[addrCheckLane].predAddr, decodedPC[addrCheckLane]);\n            nextRAS_Ptr = rasPtr + 1;\n        end \n        else if (popRAS) begin\n            // $display(\"Ret(%d)  @%x old:%p new:%p\", rasPtr, pc[addrCheckLane], brPredIn[addrCheckLane].predAddr, decodedPC[addrCheckLane]);\n            nextRAS_Ptr = rasPtr - 1;\n        end\n        else begin\n            nextRAS_Ptr = rasPtr;\n        end\n\n        if (flushTriggered) begin\n            for (int i = 0; i < DECODE_WIDTH; i++) begin\n                if (i > addrCheckLane) begin\n                    insnValidOut[i] = FALSE;\n                    insnFlushed[i] = TRUE;\n                end\n            end\n            insnFlushTriggering[addrCheckLane] = TRUE;\n        end\n    end // always_comb\n\nendmodule\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Micro op decoder\n//\n\n\nimport BasicTypes::*;\nimport MicroOpTypes::*;\nimport OpFormatTypes::*;\n\n\nfunction automatic void EmitInvalidOp(\n    output OpInfo op\n);\n    op = '0;\n    op.valid = FALSE;\nendfunction\n\n\n//\n// Modify micro op information.\n//\n\nfunction automatic OpInfo ModifyMicroOp(\n    input OpInfo src,\n    input MicroOpIndex mid,\n    input logic split,\n    input logic last\n);\n    OpInfo op;\n    op = src;\n    op.mid = mid;\n    op.split = split;\n    op.last = last;\n    return op;\nendfunction\n\n\n//\n//  RISCV Instruction Decoder\n//\n\n\n//\n// --- \u5373\u5024\u6574\u6570\u6f14\u7b97, \u30b7\u30d5\u30c8\u542b\u3080\n//\nfunction automatic void RISCV_EmitOpImm(\n    output OpInfo  opInfo,\n    input RISCV_ISF_Common isf,\n    input LScalarRegNumPath srcRegNumA,\n    input LScalarRegNumPath srcRegNumB,\n    input LScalarRegNumPath dstRegNum,\n    input logic unsupported\n);\n    RISCV_ISF_I isfI;\n    RISCV_ISF_R isfR;\n    OpFunct3 opFunct3;\n    ShiftFunct7 shiftFunct7;\n    RISCV_IntOperandImmShift intOperandImmShift;\n    logic isShift;\n\n    IntALU_Code aluCode;\n\n    isfI = isf;\n    isfR = isf;\n    opFunct3 = OpFunct3'(isfR.funct3);\n    shiftFunct7 = ShiftFunct7'(isfR.funct7);\n    isShift = ( ( opFunct3 == OP_FUNCT3_SLL ) || ( opFunct3 == OP_FUNCT3_SRL_SRA ) );\n\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n`ifdef RSD_MARCH_FP_PIPE\n    opInfo.operand.intOp.dstRegNum.isFP  = FALSE;\n    opInfo.operand.intOp.srcRegNumA.isFP = FALSE;\n    opInfo.operand.intOp.srcRegNumB.isFP = FALSE;\n`endif\n    opInfo.operand.intOp.dstRegNum.regNum  = dstRegNum;\n    opInfo.operand.intOp.srcRegNumA.regNum = srcRegNumA;\n    opInfo.operand.intOp.srcRegNumB.regNum = srcRegNumB;\n\n    // \u5373\u5024\n    opInfo.operand.intOp.shiftType = SOT_IMM_SHIFT ;\n\n    intOperandImmShift.shift        =  isShift ? isfR.rs2 : '0;\n    intOperandImmShift.shiftType    =  ( opFunct3 == OP_FUNCT3_SLL ) ? ST_LSL :\n                                    ( ( opFunct3 == OP_FUNCT3_SRL_SRA ) && ( shiftFunct7 == SHIFT_FUNCT7_SRL ) ) ? ST_LSR :\n                                    ( ( opFunct3 == OP_FUNCT3_SRL_SRA ) && ( shiftFunct7 == SHIFT_FUNCT7_SRA ) ) ? ST_ASR :\n                                    ST_ROR;\n    intOperandImmShift.isRegShift   = FALSE;\n    intOperandImmShift.imm          = isShift ? ShamtExtention( isfR ) : I_TypeImmExtention( isfI );\n    intOperandImmShift.immType      = RISCV_IMM_I;\n\n    opInfo.operand.intOp.shiftIn   = intOperandImmShift;\n\n\n    // ALU\n    RISCV_DecodeOpImmFunct3( aluCode, opFunct3 );\n    opInfo.operand.intOp.aluCode = aluCode;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // \u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u3078\u306e\u66f8\u304d\u8fbc\u307f\u306f\u66f8\u304d\u8fbc\u307f\u30d5\u30e9\u30b0\u3092FALSE\u3068\u3059\u308b\n    opInfo.writeReg  = ( dstRegNum != ZERO_REGISTER ) ? TRUE : FALSE;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    opInfo.opTypeA = OOT_REG;\n    opInfo.opTypeB = OOT_IMM;\n`ifdef RSD_MARCH_FP_PIPE \n    opInfo.opTypeC = OOT_IMM;\n`endif\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_INT;\n    opInfo.mopSubType.intType = isShift ? INT_MOP_TYPE_SHIFT : INT_MOP_TYPE_ALU;\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n    // \u672a\u5b9a\u7fa9\u547d\u4ee4\n    opInfo.unsupported = unsupported;\n    opInfo.undefined = FALSE;\n\n    // Serialized\n    opInfo.serialized = FALSE;\n\n    // Control\n    opInfo.valid = TRUE;    // Valid outputs\nendfunction\n\nfunction automatic void RISCV_DecodeOpImm(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo intOp;\n    OpInfo shiftOp;\n    OpInfo rijOp;\n    OpInfo selectOp;\n    MicroOpIndex mid;\n\n    //RISCV\u3067\u306f\u8907\u6570micro op\u3078\u306e\u5206\u5272\u306f\u57fa\u672c\u7684\u306b\u5fc5\u8981\u306a\u3044\u306f\u305a\n\n    RISCV_EmitOpImm(\n        .opInfo( intOp ),\n        .isf( isf ),\n        .srcRegNumA( isf.rs1 ),\n        .srcRegNumB( 0 ),\n        .dstRegNum( isf.rd ),\n        .unsupported( FALSE )\n    );\n\n    mid = 0;\n    for(int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(intOp, mid, FALSE, TRUE);\n    mid += 1;\n\n    insnInfo.writePC = FALSE;\n    insnInfo.isCall = FALSE;\n    insnInfo.isReturn = FALSE;\n    insnInfo.isRelBranch = FALSE;\n    insnInfo.isSerialized = FALSE;\n\nendfunction\n\n\n//\n// --- \u30ec\u30b8\u30b9\u30bf\u6574\u6570\u6f14\u7b97, \u30b7\u30d5\u30c8\u542b\u3080\n//\nfunction automatic void RISCV_EmitOp(\n    output OpInfo  opInfo,\n    input RISCV_ISF_Common isf,\n    input LScalarRegNumPath srcRegNumA,\n    input LScalarRegNumPath srcRegNumB,\n    input LScalarRegNumPath dstRegNum,\n    input logic unsupported\n);\n    RISCV_ISF_R isfR;\n    OpFunct3 opFunct3;\n    OpFunct7 opFunct7;\n    ShiftFunct7 shiftFunct7;\n    RISCV_IntOperandImmShift intOperandImmShift;\n    logic isShift;\n\n    IntALU_Code aluCode;\n\n    isfR = isf;\n    opFunct3 = OpFunct3'(isfR.funct3);\n    opFunct7 = OpFunct7'(isfR.funct7);\n    shiftFunct7 = ShiftFunct7'(isfR.funct7);\n    isShift = ( ( opFunct3 == OP_FUNCT3_SLL ) || ( opFunct3 == OP_FUNCT3_SRL_SRA ) );\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n`ifdef RSD_MARCH_FP_PIPE\n    opInfo.operand.intOp.dstRegNum.isFP  = FALSE;\n    opInfo.operand.intOp.srcRegNumA.isFP = FALSE;\n    opInfo.operand.intOp.srcRegNumB.isFP = FALSE;\n`endif\n    opInfo.operand.intOp.dstRegNum.regNum  = dstRegNum;\n    opInfo.operand.intOp.srcRegNumA.regNum = srcRegNumA;\n    opInfo.operand.intOp.srcRegNumB.regNum = srcRegNumB;\n\n    // \u5373\u5024\n    opInfo.operand.intOp.shiftType = SOT_REG_SHIFT ;\n\n    intOperandImmShift.shift        =  isShift ? isfR.rs2 : '0;\n    intOperandImmShift.shiftType    =  ( opFunct3 == OP_FUNCT3_SLL ) ? ST_LSL :\n                                    ( ( opFunct3 == OP_FUNCT3_SRL_SRA ) && ( shiftFunct7 == SHIFT_FUNCT7_SRL ) ) ? ST_LSR :\n                                    ( ( opFunct3 == OP_FUNCT3_SRL_SRA ) && ( shiftFunct7 == SHIFT_FUNCT7_SRA ) ) ? ST_ASR :\n                                    ST_ROR;\n    intOperandImmShift.isRegShift   = TRUE;\n    intOperandImmShift.imm          = '0;\n    intOperandImmShift.immType      = RISCV_IMM_R;\n\n    opInfo.operand.intOp.shiftIn   = intOperandImmShift;\n\n\n    // ALU\n    //RISCV_DecodeOpFunct3( isfR.funct3, isfR.funct7, opInfo.operand.intOp.aluCode);\n    RISCV_DecodeOpFunct3( aluCode, opFunct3, opFunct7 );\n    opInfo.operand.intOp.aluCode = aluCode;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // \u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u3078\u306e\u66f8\u304d\u8fbc\u307f\u306f\u66f8\u304d\u8fbc\u307f\u30d5\u30e9\u30b0\u3092FALSE\u3068\u3059\u308b\n    opInfo.writeReg  = ( dstRegNum != ZERO_REGISTER ) ? TRUE : FALSE;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    opInfo.opTypeA = OOT_REG;\n    opInfo.opTypeB = OOT_REG;\n`ifdef RSD_MARCH_FP_PIPE \n    opInfo.opTypeC = OOT_IMM;\n`endif\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_INT;\n    opInfo.mopSubType.intType = isShift ? INT_MOP_TYPE_SHIFT : INT_MOP_TYPE_ALU;\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n    // \u672a\u5b9a\u7fa9\u547d\u4ee4\n    opInfo.unsupported = unsupported;\n    opInfo.undefined = FALSE;\n\n    // Serialized\n    opInfo.serialized = FALSE;\n\n    // Control\n    opInfo.valid = TRUE;    // Valid outputs\nendfunction\n\nfunction automatic void RISCV_DecodeOp(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo intOp;\n    OpInfo shiftOp;\n    OpInfo rijOp;\n    OpInfo selectOp;\n    MicroOpIndex mid;\n\n    //RISCV\u3067\u306f\u8907\u6570micro op\u3078\u306e\u5206\u5272\u306f\u57fa\u672c\u7684\u306b\u5fc5\u8981\u306a\u3044\u306f\u305a\n\n    RISCV_EmitOp(\n        .opInfo( intOp ),\n        .isf( isf ),\n        .srcRegNumA( isf.rs1 ),\n        .srcRegNumB( isf.rs2 ),\n        .dstRegNum( isf.rd ),\n        .unsupported( FALSE )\n    );\n\n    mid = 0;\n    for(int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(intOp, mid, FALSE, TRUE);\n    mid += 1;\n\n    insnInfo.writePC = FALSE;\n    insnInfo.isCall = FALSE;\n    insnInfo.isReturn = FALSE;\n    insnInfo.isRelBranch = FALSE;\n    insnInfo.isSerialized = FALSE;\n\nendfunction\n\n\n//\n// --- RISCV LUI, AUIPC\n//\nfunction automatic void RISCV_EmitUTypeInst(\n    output OpInfo  opInfo,\n    input RISCV_ISF_Common isf,\n    input LScalarRegNumPath srcRegNumA,\n    input LScalarRegNumPath srcRegNumB,\n    input LScalarRegNumPath dstRegNum,\n    input logic unsupported\n);\n    RISCV_ISF_U isfU;\n    RISCV_IntOperandImmShift intOperandImmShift;\n\n    isfU = isf;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n`ifdef RSD_MARCH_FP_PIPE\n    opInfo.operand.intOp.dstRegNum.isFP  = FALSE;\n    opInfo.operand.intOp.srcRegNumA.isFP = FALSE;\n    opInfo.operand.intOp.srcRegNumB.isFP = FALSE;\n`endif\n    opInfo.operand.intOp.dstRegNum.regNum  = dstRegNum;\n    opInfo.operand.intOp.srcRegNumA.regNum = srcRegNumA;\n    opInfo.operand.intOp.srcRegNumB.regNum = srcRegNumB;\n\n    // \u5373\u5024\n    opInfo.operand.intOp.shiftType = SOT_REG_SHIFT ;\n\n    intOperandImmShift.shift        = '0;\n    intOperandImmShift.shiftType    = ST_ROR;\n    intOperandImmShift.isRegShift   = TRUE;\n    intOperandImmShift.imm          = isfU.imm;\n    intOperandImmShift.immType      = RISCV_IMM_U;\n\n    opInfo.operand.intOp.shiftIn   = intOperandImmShift;\n\n\n    // ALU\n    opInfo.operand.intOp.aluCode = AC_ADD;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // \u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u3078\u306e\u66f8\u304d\u8fbc\u307f\u306f\u66f8\u304d\u8fbc\u307f\u30d5\u30e9\u30b0\u3092FALSE\u3068\u3059\u308b\n    opInfo.writeReg  = ( dstRegNum != ZERO_REGISTER ) ? TRUE : FALSE;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    opInfo.opTypeA = isf.opCode == RISCV_AUIPC ? OOT_PC : OOT_REG;\n    opInfo.opTypeB = OOT_IMM;\n`ifdef RSD_MARCH_FP_PIPE \n    opInfo.opTypeC = OOT_IMM;\n`endif\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_INT;\n    opInfo.mopSubType.intType = INT_MOP_TYPE_ALU;\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n    // \u672a\u5b9a\u7fa9\u547d\u4ee4\n    opInfo.unsupported = unsupported;\n    opInfo.undefined = FALSE;\n\n    // Serialized\n    opInfo.serialized = FALSE;\n\n    // Control\n    opInfo.valid = TRUE;    // Valid outputs\nendfunction\n\nfunction automatic void RISCV_DecodeUTypeInst(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo intOp;\n    MicroOpIndex mid;\n\n    //RISCV\u3067\u306f\u8907\u6570micro op\u3078\u306e\u5206\u5272\u306f\u57fa\u672c\u7684\u306b\u5fc5\u8981\u306a\u3044\u306f\u305a\n\n    RISCV_EmitUTypeInst(\n        .opInfo( intOp ),\n        .isf( isf ),\n        .srcRegNumA( 0 ),\n        .srcRegNumB( 0 ),\n        .dstRegNum( isf.rd ),\n        .unsupported( FALSE )\n    );\n\n    mid = 0;\n    for(int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(intOp, mid, FALSE, TRUE);\n    mid += 1;\n\n    insnInfo.writePC = FALSE;\n    insnInfo.isCall = FALSE;\n    insnInfo.isReturn = FALSE;\n    insnInfo.isRelBranch = FALSE;\n    insnInfo.isSerialized = FALSE;\n\nendfunction\n\n\n//\n// --- RISCV JAL\n//\nfunction automatic void RISCV_EmitJAL(\n    output OpInfo  opInfo,\n    input RISCV_ISF_Common isf\n);\n    RISCV_ISF_U isfU;\n    isfU = isf;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n`ifdef RSD_MARCH_FP_PIPE\n    opInfo.operand.brOp.dstRegNum.isFP  = FALSE;\n    opInfo.operand.brOp.srcRegNumA.isFP = FALSE;\n    opInfo.operand.brOp.srcRegNumB.isFP = FALSE;\n`endif\n    opInfo.operand.brOp.dstRegNum.regNum  = isfU.rd;\n    opInfo.operand.brOp.srcRegNumA.regNum = '0;\n    opInfo.operand.brOp.srcRegNumB.regNum = '0;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // \u6bd4\u8f03\u7cfb\u306e\u547d\u4ee4\u306f\u30ec\u30b8\u30b9\u30bf\u306b\u66f8\u304d\u8fbc\u307f\u3092\u884c\u308f\u306a\u3044\n    // \u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u3078\u306e\u66f8\u304d\u8fbc\u307f\u306f\u66f8\u304d\u8fbc\u307f\u30d5\u30e9\u30b0\u3092FALSE\u3068\u3059\u308b\n    opInfo.writeReg  = ( isfU.rd != ZERO_REGISTER ) ? TRUE : FALSE;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    opInfo.opTypeA = OOT_PC;\n    opInfo.opTypeB = OOT_IMM;\n`ifdef RSD_MARCH_FP_PIPE \n    opInfo.opTypeC = OOT_IMM;\n`endif\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_INT;\n    opInfo.mopSubType.intType = INT_MOP_TYPE_BR;\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n    // \u5206\u5c90\u30bf\u30fc\u30b2\u30c3\u30c8\n    opInfo.operand.brOp.brDisp = GetJAL_Target( isf );\n    opInfo.operand.brOp.padding = 0;\n\n    // \u672a\u5b9a\u7fa9\u547d\u4ee4\n    opInfo.unsupported = FALSE;\n    opInfo.undefined = FALSE;\n\n    // Serialized\n    opInfo.serialized = FALSE;\n\n    // Control\n    opInfo.valid = TRUE;    // Valid outputs\nendfunction\n\nfunction automatic void RISCV_DecodeJAL(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo brOp;\n    MicroOpIndex mid;\n\n    //RISCV\u3067\u306f\u8907\u6570micro op\u3078\u306e\u5206\u5272\u306f\u57fa\u672c\u7684\u306b\u5fc5\u8981\u306a\u3044\u306f\u305a\n\n    RISCV_EmitJAL(\n        .opInfo( brOp ),\n        .isf( isf )\n    );\n\n    // Initizalize\n    mid = 0;\n    for(int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(brOp, mid, FALSE, TRUE);\n\n    insnInfo.writePC = TRUE;\n    insnInfo.isCall = ( brOp.writeReg && ( brOp.operand.brOp.dstRegNum.regNum == LINK_REGISTER ) ) ? TRUE : FALSE;\n    insnInfo.isReturn = FALSE;\n    insnInfo.isRelBranch = TRUE;\n    insnInfo.isSerialized = FALSE;\n\nendfunction\n\n\n//\n// --- RISCV Decode JALR\n//\nfunction automatic void RISCV_EmitJALR(\n    output OpInfo  opInfo,\n    input RISCV_ISF_Common isf\n);\n\n    RISCV_ISF_I isfI;\n    isfI = isf;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n`ifdef RSD_MARCH_FP_PIPE\n    opInfo.operand.brOp.dstRegNum.isFP  = FALSE;\n    opInfo.operand.brOp.srcRegNumA.isFP = FALSE;\n    opInfo.operand.brOp.srcRegNumB.isFP = FALSE;\n`endif\n    opInfo.operand.brOp.dstRegNum.regNum  = isfI.rd;\n    opInfo.operand.brOp.srcRegNumA.regNum = isfI.rs1;\n    opInfo.operand.brOp.srcRegNumB.regNum = 0;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // \u6bd4\u8f03\u7cfb\u306e\u547d\u4ee4\u306f\u30ec\u30b8\u30b9\u30bf\u306b\u66f8\u304d\u8fbc\u307f\u3092\u884c\u308f\u306a\u3044\n    // \u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u3078\u306e\u66f8\u304d\u8fbc\u307f\u306f\u66f8\u304d\u8fbc\u307f\u30d5\u30e9\u30b0\u3092FALSE\u3068\u3059\u308b\n    opInfo.writeReg  = ( isfI.rd != ZERO_REGISTER ) ? TRUE : FALSE;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    opInfo.opTypeA = OOT_REG;\n    opInfo.opTypeB = OOT_IMM;\n`ifdef RSD_MARCH_FP_PIPE \n    opInfo.opTypeC = OOT_IMM;\n`endif\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_INT;\n    opInfo.mopSubType.intType = INT_MOP_TYPE_RIJ;\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n    // \u5206\u5c90\u30bf\u30fc\u30b2\u30c3\u30c8\n    opInfo.operand.brOp.brDisp = GetJALR_Target( isfI );\n    opInfo.operand.brOp.padding = '0;\n\n    // \u672a\u5b9a\u7fa9\u547d\u4ee4\n    opInfo.unsupported = FALSE;\n    opInfo.undefined = FALSE;\n\n    // Serialized\n    opInfo.serialized = FALSE;\n\n    // Control\n    opInfo.valid = TRUE;    // Valid outputs\nendfunction\n\nfunction automatic void RISCV_DecodeJALR(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo brOp;\n    MicroOpIndex mid;\n\n    //RISCV\u3067\u306f\u8907\u6570micro op\u3078\u306e\u5206\u5272\u306f\u57fa\u672c\u7684\u306b\u5fc5\u8981\u306a\u3044\u306f\u305a\n\n    RISCV_EmitJALR(\n        .opInfo( brOp ),\n        .isf( isf )\n    );\n\n    // Initizalize\n    mid = 0;\n    for(int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(brOp, mid, FALSE, TRUE);\n\n    insnInfo.writePC = TRUE;\n    insnInfo.isCall = ( brOp.writeReg && ( brOp.operand.brOp.dstRegNum.regNum == LINK_REGISTER ) ) ? TRUE : FALSE;\n    insnInfo.isReturn = ( ( brOp.operand.brOp.srcRegNumA.regNum == LINK_REGISTER )\n                        && ( brOp.operand.brOp.dstRegNum.regNum == ZERO_REGISTER ) ) ? TRUE : FALSE;\n    insnInfo.isRelBranch = FALSE;\n    insnInfo.isSerialized = FALSE;\n\nendfunction\n\n\n//\n// --- RISCV BRANCH\n//\nfunction automatic void RISCV_EmitBranch(\n    output OpInfo  opInfo,\n    input RISCV_ISF_Common isf\n);\n    RISCV_ISF_R isfR;\n    BrFunct3 brFunct3;\n    CondCode condCode;\n\n    isfR = isf;\n    brFunct3 = BrFunct3'(isfR.funct3);\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n`ifdef RSD_MARCH_FP_PIPE\n    opInfo.operand.brOp.dstRegNum.isFP  = FALSE;\n    opInfo.operand.brOp.srcRegNumA.isFP = FALSE;\n    opInfo.operand.brOp.srcRegNumB.isFP = FALSE;\n`endif\n    opInfo.operand.brOp.dstRegNum.regNum  = 0;\n    opInfo.operand.brOp.srcRegNumA.regNum = isfR.rs1;\n    opInfo.operand.brOp.srcRegNumB.regNum = isfR.rs2;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // \u6bd4\u8f03\u7cfb\u306e\u547d\u4ee4\u306f\u30ec\u30b8\u30b9\u30bf\u306b\u66f8\u304d\u8fbc\u307f\u3092\u884c\u308f\u306a\u3044\n    // \u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u3078\u306e\u66f8\u304d\u8fbc\u307f\u306f\u66f8\u304d\u8fbc\u307f\u30d5\u30e9\u30b0\u3092FALSE\u3068\u3059\u308b\n    opInfo.writeReg  = FALSE;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    opInfo.opTypeA = OOT_REG;\n    opInfo.opTypeB = OOT_REG;\n`ifdef RSD_MARCH_FP_PIPE \n    opInfo.opTypeC = OOT_IMM;\n`endif\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_INT;\n    opInfo.mopSubType.intType = INT_MOP_TYPE_BR;\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    //RISCV_DecodeBrFunct3(isfR.funct3, opInfo.cond);\n    RISCV_DecodeBrFunct3( condCode, brFunct3 );\n    opInfo.cond = condCode;\n\n    // \u5206\u5c90\u30bf\u30fc\u30b2\u30c3\u30c8\n    opInfo.operand.brOp.brDisp = GetBranchDisplacement( isfR );\n    opInfo.operand.brOp.padding = '0;\n\n    // \u672a\u5b9a\u7fa9\u547d\u4ee4\n    opInfo.unsupported = FALSE;\n    opInfo.undefined = FALSE;\n\n    // Serialized\n    opInfo.serialized = FALSE;\n\n    // Control\n    opInfo.valid = TRUE;    // Valid outputs\nendfunction\n\nfunction automatic void RISCV_DecodeBranch(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo brOp;\n    MicroOpIndex mid;\n\n    //RISCV\u3067\u306f\u8907\u6570micro op\u3078\u306e\u5206\u5272\u306f\u57fa\u672c\u7684\u306b\u5fc5\u8981\u306a\u3044\u306f\u305a\n\n    RISCV_EmitBranch(\n        .opInfo( brOp ),\n        .isf( isf )\n    );\n\n    // Initizalize\n    mid = 0;\n    for(int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(brOp, mid, FALSE, TRUE);\n\n    insnInfo.writePC    = TRUE;\n    insnInfo.isCall     = FALSE;\n    insnInfo.isReturn   = FALSE;\n    insnInfo.isRelBranch = TRUE;\n    insnInfo.isSerialized = FALSE;\n\nendfunction\n\n//\n// --- EISCV MEMORY OP\n//\nfunction automatic void RISCV_EmitMemOp(\n    output OpInfo  opInfo,\n    input RISCV_ISF_Common isf\n);\n    RISCV_ISF_S isfS;\n    RISCV_ISF_I isfI;\n    MemFunct3 memFunct3;\n    logic isLoad;\n\n    MemAccessMode memAccessMode;\n\n    isfS = isf;\n    isfI = isf;\n    memFunct3 = MemFunct3'(isfS.funct3);\n    isLoad = ( isfI.opCode == RISCV_LD );\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n`ifdef RSD_MARCH_FP_PIPE\n    opInfo.operand.memOp.dstRegNum.isFP  = FALSE;\n    opInfo.operand.memOp.srcRegNumA.isFP = FALSE;\n    opInfo.operand.memOp.srcRegNumB.isFP = FALSE;\n`endif\n    opInfo.operand.memOp.dstRegNum.regNum  = isLoad ? isfI.rd : '0;\n    opInfo.operand.memOp.srcRegNumA.regNum = isfI.rs1;\n    opInfo.operand.memOp.srcRegNumB.regNum = isLoad ? '0 : isfS.rs2;\n    opInfo.operand.memOp.csrCtrl = '0; // unused\n    opInfo.operand.memOp.padding = '0;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // \u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u3078\u306e\u66f8\u304d\u8fbc\u307f\u306f\u66f8\u304d\u8fbc\u307f\u30d5\u30e9\u30b0\u3092FALSE\u3068\u3059\u308b\n    opInfo.writeReg  = ( isfI.rd != ZERO_REGISTER ) & isLoad;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    // \u30b9\u30c8\u30a2\u6642\u306fB\u3092\u8aad\u3080\n    opInfo.opTypeA = OOT_REG;\n    opInfo.opTypeB = isLoad ? OOT_IMM : OOT_REG;\n`ifdef RSD_MARCH_FP_PIPE \n    opInfo.opTypeC = OOT_IMM;\n`endif\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_MEM;\n    opInfo.mopSubType.memType = isLoad ? MEM_MOP_TYPE_LOAD : MEM_MOP_TYPE_STORE;\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n    // \u30a2\u30c9\u30ec\u30c3\u30b7\u30f3\u30b0\n    opInfo.operand.memOp.addrIn    = isLoad ? isfI.imm : {isfS.imm2, isfS.imm1};\n    opInfo.operand.memOp.isAddAddr = TRUE;\n    opInfo.operand.memOp.isRegAddr = TRUE;\n    RISCV_DecodeMemAccessMode( memAccessMode, memFunct3 );\n    opInfo.operand.memOp.memAccessMode = memAccessMode;\n\n    opInfo.valid = TRUE;\n\n    opInfo.unsupported = FALSE;\n    opInfo.undefined = FALSE;\n\n    // Serialized\n    opInfo.serialized = FALSE;\nendfunction\n\nfunction automatic void RISCV_DecodeMemOp(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo memOp;\n    MicroOpIndex mid;\n\n    //RISCV\u3067\u306f\u8907\u6570micro op\u3078\u306e\u5206\u5272\u306f\u57fa\u672c\u7684\u306b\u5fc5\u8981\u306a\u3044\u306f\u305a\n\n    RISCV_EmitMemOp(\n        .opInfo( memOp ),\n        .isf( isf )\n    );\n\n    // Initizalize\n    mid = 0;\n    for(int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(memOp, mid, FALSE, TRUE);\n\n    insnInfo.writePC    = FALSE;\n    insnInfo.isCall     = FALSE;\n    insnInfo.isReturn   = FALSE;\n    insnInfo.isRelBranch = FALSE;\n    insnInfo.isSerialized = FALSE;\n\nendfunction\n\n\n//\n// --- Complex Op (RISC-V\u3067\u306fRV32M)\n//\nfunction automatic void RISCV_EmitComplexOp(\n    output OpInfo  opInfo, \n    input RISCV_ISF_Common isf,\n    input LScalarRegNumPath srcRegNumA,\n    input LScalarRegNumPath srcRegNumB,\n    input LScalarRegNumPath dstRegNum,\n    input logic unsupported\n);\n    RISCV_ISF_R isfR;\n    OpFunct3 opFunct3;\n    OpFunct7 opFunct7;\n    RV32MFunct3 rv32mFunct3;\n    RV32MFunct7 rv32mFunct7;\n    logic isMul;\n\n    IntMUL_Code mulCode;\n    IntDIV_Code divCode;\n\n    isfR = isf;\n    opFunct3 = OpFunct3'(isfR.funct3);\n    opFunct7 = OpFunct7'(isfR.funct7);\n    rv32mFunct3 = R"}
{"text": "V32MFunct3'(isfR.funct3);\n    rv32mFunct7 = RV32MFunct7'(isfR.funct7);\n    isMul = ( rv32mFunct3 < RV32M_FUNCT3_DIV );\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n`ifdef RSD_MARCH_FP_PIPE\n    opInfo.operand.complexOp.dstRegNum.isFP  = FALSE;\n    opInfo.operand.complexOp.srcRegNumA.isFP = FALSE;\n    opInfo.operand.complexOp.srcRegNumB.isFP = FALSE;\n`endif\n    opInfo.operand.complexOp.dstRegNum.regNum  = dstRegNum;\n    opInfo.operand.complexOp.srcRegNumA.regNum = srcRegNumA;\n    opInfo.operand.complexOp.srcRegNumB.regNum = srcRegNumB;\n    \n    // \u4e57\u7b97\u306e\u6709\u52b9\u306a\u7d50\u679c\u306e\u4f4d\u7f6e\n    opInfo.operand.complexOp.mulGetUpper = ( rv32mFunct3 > RV32M_FUNCT3_MUL) ;\n\n    // ALU\n    RISCV_DecodeComplexOpFunct3( mulCode, divCode, rv32mFunct3 );\n    opInfo.operand.complexOp.mulCode = mulCode;\n    opInfo.operand.complexOp.divCode = divCode;\n    opInfo.operand.complexOp.padding = '0;\n    opInfo.operand.complexOp.riscv_padding = '0;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // \u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u3078\u306e\u66f8\u304d\u8fbc\u307f\u306f\u66f8\u304d\u8fbc\u307f\u30d5\u30e9\u30b0\u3092FALSE\u3068\u3059\u308b   \n    opInfo.writeReg  = ( dstRegNum != ZERO_REGISTER ) ? TRUE : FALSE;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    opInfo.opTypeA = OOT_REG;\n    opInfo.opTypeB = OOT_REG;\n`ifdef RSD_MARCH_FP_PIPE \n    opInfo.opTypeC = OOT_IMM;\n`endif\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n`ifdef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    // Mem pipe \u3067\u51e6\u7406\n    opInfo.mopType = MOP_TYPE_MEM;\n    opInfo.mopSubType.memType = isMul ? MEM_MOP_TYPE_MUL : MEM_MOP_TYPE_DIV;\n`else\n    // \u5270\u4f59\u306f\u9664\u7b97\u3068\u6f14\u7b97\u5668\u3092\u5171\u6709\u3059\u308b\u305f\u3081COMPLEX_MOP_TYPE_DIV\u3068\u3059\u308b\n    opInfo.mopType = MOP_TYPE_COMPLEX;\n    opInfo.mopSubType.complexType = isMul ? COMPLEX_MOP_TYPE_MUL : COMPLEX_MOP_TYPE_DIV;\n`endif\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n    // \u672a\u5b9a\u7fa9\u547d\u4ee4\n    opInfo.unsupported = unsupported;\n    opInfo.undefined = FALSE;\n\n    // Serialized\n    opInfo.serialized = FALSE;\n\n    // Control\n    opInfo.valid = TRUE;    // Valid outputs\nendfunction\n\nfunction automatic void RISCV_DecodeComplexOp( \n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo complexOp;\n    MicroOpIndex mid;\n\n    //RISCV\u3067\u306f\u8907\u6570micro op\u3078\u306e\u5206\u5272\u306f\u57fa\u672c\u7684\u306b\u5fc5\u8981\u306a\u3044\u306f\u305a\n\n    RISCV_EmitComplexOp(\n        .opInfo( complexOp ),\n        .isf( isf ),\n        .srcRegNumA( isf.rs1 ),\n        .srcRegNumB( isf.rs2 ),\n        .dstRegNum( isf.rd ),\n        .unsupported( FALSE )\n    );\n\n    mid = 0;\n    for(int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(complexOp, mid, FALSE, TRUE);\n    mid += 1;\n\n    insnInfo.writePC = FALSE;\n    insnInfo.isCall = FALSE;\n    insnInfo.isReturn = FALSE;\n    insnInfo.isRelBranch = FALSE;\n    insnInfo.isSerialized = FALSE;\n\nendfunction\n\n//\n// --- Misc-Mem\n//\nfunction automatic void RISCV_EmitMiscMemOp(\n    output OpInfo  opInfo,\n    input RISCV_ISF_Common isf\n);\n    RISCV_ISF_MISC_MEM isfMiscMem;\n    MiscMemFunct3 opFunct3;\n    MiscMemMicroOpOperand miscMemOp;\n\n    isfMiscMem = isf;\n    opFunct3 = MiscMemFunct3'(isfMiscMem.funct3);\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n`ifdef RSD_MARCH_FP_PIPE\n    miscMemOp.dstRegNum.isFP  = FALSE;\n    miscMemOp.srcRegNumA.isFP = FALSE;\n    miscMemOp.srcRegNumB.isFP = FALSE;\n`endif\n    miscMemOp.dstRegNum.regNum  = '0;\n    miscMemOp.srcRegNumA.regNum = '0;\n    miscMemOp.srcRegNumB.regNum = '0;\n    miscMemOp.padding = '0;\n    miscMemOp.riscv_padding = '0;\n\n    if (opFunct3 == MISC_MEM_FUNCT3_FENCE) begin\n        miscMemOp.fence = TRUE;\n        miscMemOp.fenceI = FALSE;\n    end \n    else if (opFunct3 == MISC_MEM_FUNCT3_FENCE_I) begin\n        miscMemOp.fence = TRUE;\n        miscMemOp.fenceI = TRUE;\n    end \n    else begin\n        miscMemOp.fence = FALSE;\n        miscMemOp.fenceI = FALSE;\n    end\n\n    opInfo.operand.miscMemOp = miscMemOp;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // FENCE/FENCE.I Does not write any registers \n    opInfo.writeReg  = FALSE;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    opInfo.opTypeA = OOT_IMM;\n    opInfo.opTypeB = OOT_IMM;\n`ifdef RSD_MARCH_FP_PIPE \n    opInfo.opTypeC = OOT_IMM;\n`endif\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_MEM;\n    opInfo.mopSubType.memType = MEM_MOP_TYPE_FENCE;\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n\n    opInfo.valid = TRUE;\n\n    opInfo.unsupported = FALSE;\n    if (miscMemOp.fence) begin\n        opInfo.undefined = FALSE;\n    end\n    else begin\n        // Unknown misc mem\n        opInfo.undefined = TRUE;\n    end\n\n    // Serialized\n    opInfo.serialized = TRUE;\nendfunction\n\nfunction automatic void RISCV_DecodeMiscMem(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo miscMemOp;\n    MicroOpIndex mid;\n\n    //RISCV\u3067\u306f\u8907\u6570micro op\u3078\u306e\u5206\u5272\u306f\u57fa\u672c\u7684\u306b\u5fc5\u8981\u306a\u3044\u306f\u305a\n\n    RISCV_EmitMiscMemOp(\n        .opInfo(miscMemOp),\n        .isf(isf)\n    );\n\n    // Initizalize\n    mid = 0;\n    for (int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(miscMemOp, mid, FALSE, TRUE);\n\n    insnInfo.writePC    = FALSE;\n    insnInfo.isCall     = FALSE;\n    insnInfo.isReturn   = FALSE;\n    insnInfo.isRelBranch = FALSE;\n    insnInfo.isSerialized = TRUE;\n\nendfunction\n\n\n//\n// --- System\n//\nfunction automatic void RISCV_EmitCSR_Op(\n    output OpInfo opInfo,\n    input RISCV_ISF_Common isf\n);\n    RISCV_ISF_SYSTEM isfSystem;\n    SystemFunct3 opFunct3;\n    MemMicroOpOperand memOp;    // Decoded as a memory op\n\n    isfSystem = isf;\n    opFunct3 = SystemFunct3'(isfSystem.funct3);\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n`ifdef RSD_MARCH_FP_PIPE\n    memOp.dstRegNum.isFP  = FALSE;\n    memOp.srcRegNumA.isFP = FALSE;\n    memOp.srcRegNumB.isFP = FALSE;\n`endif\n    memOp.dstRegNum.regNum  = isfSystem.rd;\n    memOp.srcRegNumA.regNum = isfSystem.rs1;\n    memOp.srcRegNumB.regNum = '0;\n    memOp.padding = '0;\n\n    // Don't care\n    memOp.isAddAddr = FALSE;\n    memOp.isRegAddr = FALSE;\n    memOp.memAccessMode = '0;\n\n    // \u30b3\u30fc\u30c9\u306e\u8a2d\u5b9a\n    unique case (opFunct3)\n        default: begin  // SYSTEM_FUNCT3_PRIV or unknown\n            memOp.csrCtrl.code = CSR_WRITE;\n        end\n        SYSTEM_FUNCT3_CSR_RW, SYSTEM_FUNCT3_CSR_RW_I: begin\n            memOp.csrCtrl.code = CSR_WRITE;\n        end\n        SYSTEM_FUNCT3_CSR_RS, SYSTEM_FUNCT3_CSR_RS_I: begin\n            memOp.csrCtrl.code = CSR_SET;\n        end\n        SYSTEM_FUNCT3_CSR_RC, SYSTEM_FUNCT3_CSR_RC_I: begin\n            memOp.csrCtrl.code = CSR_CLEAR;\n        end\n    endcase\n\n    // CSR number\n    memOp.addrIn = isfSystem.funct12;\n\n    // CSR \u547d\u4ee4\u306e\u5373\u5024\u3060\u3051\u306f\u7279\u6b8a\u306a\u306e\u3067 REG \u306b\u3057\u3066\u304a\u304d\uff0c\u30e6\u30cb\u30c3\u30c8\u5074\u3067\u5bfe\u51e6\u3059\u308b\n    memOp.csrCtrl.isImm = \n        (opFunct3 inside {\n            SYSTEM_FUNCT3_CSR_RW, \n            SYSTEM_FUNCT3_CSR_RS, \n            SYSTEM_FUNCT3_CSR_RC\n        }) ? FALSE : TRUE;\n    memOp.csrCtrl.imm = isfSystem.rs1;   // rs1 \u304c\u3061\u3087\u3046\u3069\u5373\u5024\u306b\u306a\u308b\n\n    opInfo.operand.memOp = memOp;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // CSR \u7cfb\u306f\u57fa\u672c\u5168\u3066\u66f8\u304d\u8fbc\u3080\n    // \u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u3078\u306e\u66f8\u304d\u8fbc\u307f\u306f\u66f8\u304d\u8fbc\u307f\u30d5\u30e9\u30b0\u3092FALSE\u3068\u3059\u308b\n    opInfo.writeReg  = (isfSystem.rd != ZERO_REGISTER) ? TRUE : FALSE;\n\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    // CSR \u547d\u4ee4\u306e\u5373\u5024\u3060\u3051\u306f\u7279\u6b8a\u306a\u306e\u3067 REG \u306b\u3057\u3066\u304a\u304d\uff0c\u30e6\u30cb\u30c3\u30c8\u5074\u3067\u5bfe\u51e6\u3059\u308b\n    opInfo.opTypeA = OOT_REG;  \n    opInfo.opTypeB = OOT_IMM;\n`ifdef RSD_MARCH_FP_PIPE \n    opInfo.opTypeC = OOT_IMM;\n`endif\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_MEM;\n    opInfo.mopSubType.memType = MEM_MOP_TYPE_CSR;\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n    opInfo.valid = TRUE;\n\n    opInfo.unsupported = FALSE;\n    opInfo.undefined = \n        opFunct3 == SYSTEM_FUNCT3_UNDEFINED ? TRUE : FALSE;\n\n    // Serialized\n    opInfo.serialized = TRUE;\nendfunction\n\n\nfunction automatic void RISCV_EmitSystemOp(\n    output OpInfo  opInfo,\n    input RISCV_ISF_Common isf\n);\n    RISCV_ISF_SYSTEM isfSystem;\n    SystemFunct3  opFunct3;\n    SystemFunct12 opFunct12;\n    SystemMicroOpOperand systemOp;\n    logic undefined;\n\n    isfSystem = isf;\n    opFunct3 = SystemFunct3'(isfSystem.funct3);\n    opFunct12 = SystemFunct12'(isfSystem.funct12);\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n`ifdef RSD_MARCH_FP_PIPE\n    systemOp.dstRegNum.isFP  = FALSE;\n    systemOp.srcRegNumA.isFP = FALSE;\n    systemOp.srcRegNumB.isFP = FALSE;\n`endif\n    systemOp.dstRegNum.regNum  = '0;\n    systemOp.srcRegNumA.regNum = '0;\n    systemOp.srcRegNumB.regNum = '0;\n    systemOp.isEnv = TRUE;\n    systemOp.padding = '0;\n    systemOp.imm = '0;\n\n    undefined = FALSE;\n\n    // \u30b3\u30fc\u30c9\u306e\u8a2d\u5b9a\n    if (opFunct12 == SYSTEM_FUNCT12_WFI) begin\n        // NOP \u6271\u3044\u306b\u3057\u3066\u304a\u304f\n        opInfo.mopType = MOP_TYPE_INT;\n        opInfo.mopSubType.intType = INT_MOP_TYPE_ALU;\n        systemOp.envCode = ENV_BREAK;\n    end\n    else begin\n        unique case(SystemFunct12'(isfSystem.funct12))\n            SYSTEM_FUNCT12_ECALL:  systemOp.envCode = ENV_CALL;\n            SYSTEM_FUNCT12_EBREAK: systemOp.envCode = ENV_BREAK;\n            SYSTEM_FUNCT12_MRET:   systemOp.envCode = ENV_MRET;\n            default: begin// Unknown\n                systemOp.envCode = ENV_BREAK;            \n                undefined = TRUE;\n            end\n        endcase\n\n        // \u547d\u4ee4\u306e\u7a2e\u985e\n        opInfo.mopType = MOP_TYPE_MEM;\n        opInfo.mopSubType.memType = MEM_MOP_TYPE_ENV;\n    end\n\n    opInfo.operand.systemOp = systemOp;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    opInfo.writeReg  = FALSE;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    opInfo.opTypeA = OOT_IMM;\n    opInfo.opTypeB = OOT_IMM;\n`ifdef RSD_MARCH_FP_PIPE \n    opInfo.opTypeC = OOT_IMM;\n`endif\n\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n    opInfo.valid = TRUE;\n\n    opInfo.unsupported = FALSE;\n    opInfo.undefined = undefined;\n\n    // Serialized\n    opInfo.serialized = TRUE;\nendfunction\n\n\nfunction automatic void RISCV_DecodeSystem(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo opInfo;\n    MicroOpIndex mid;\n\n    //RISCV\u3067\u306f\u8907\u6570micro op\u3078\u306e\u5206\u5272\u306f\u57fa\u672c\u7684\u306b\u5fc5\u8981\u306a\u3044\u306f\u305a\n\n    if (SystemFunct3'(isf.funct3) == SYSTEM_FUNCT3_PRIV) begin\n        RISCV_EmitSystemOp(.opInfo(opInfo), .isf(isf));\n    end\n    else begin \n        RISCV_EmitCSR_Op(.opInfo(opInfo), .isf(isf));\n    end\n\n    // Initizalize\n    mid = 0;\n    for (int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(opInfo, mid, FALSE, TRUE);\n\n    insnInfo.writePC    = FALSE;\n    insnInfo.isCall     = FALSE;\n    insnInfo.isReturn   = FALSE;\n    insnInfo.isRelBranch = FALSE;\n    insnInfo.isSerialized = TRUE;   // A system instruction must be serialized\n\nendfunction\n\n`ifdef RSD_MARCH_FP_PIPE\n//\n// --- FP ld/st\n//\nfunction automatic void RISCV_EmitFPMemOp(\n    output OpInfo  opInfo,\n    input RISCV_ISF_Common isf\n);\n    RISCV_ISF_S isfS;\n    RISCV_ISF_I isfI;\n    MemFunct3 memFunct3;\n    logic isLoad;\n\n    MemAccessMode memAccessMode;\n\n    isfS = isf;\n    isfI = isf;\n    memFunct3 = MemFunct3'(isfS.funct3);\n    isLoad = ( isfI.opCode == RISCV_F_LD );\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n    opInfo.operand.memOp.dstRegNum.isFP  = TRUE;\n    opInfo.operand.memOp.srcRegNumA.isFP = FALSE;\n    opInfo.operand.memOp.srcRegNumB.isFP = TRUE;\n    opInfo.operand.memOp.dstRegNum.regNum  = isLoad ? isfI.rd : '0;\n    opInfo.operand.memOp.srcRegNumA.regNum = isfI.rs1;\n    opInfo.operand.memOp.srcRegNumB.regNum = isLoad ? '0 : isfS.rs2;\n    \n    opInfo.operand.memOp.csrCtrl = '0; // unused\n    opInfo.operand.memOp.padding = '0;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // fp register\u306b\u306f\u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u304c\u7121\u3044\n    opInfo.writeReg  = isLoad;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    // \u30b9\u30c8\u30a2\u6642\u306fB\u3092\u8aad\u3080\n    opInfo.opTypeA = OOT_REG;\n    opInfo.opTypeB = isLoad ? OOT_IMM : OOT_REG;\n    opInfo.opTypeC = OOT_IMM;\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_MEM;\n    opInfo.mopSubType.memType = isLoad ? MEM_MOP_TYPE_LOAD : MEM_MOP_TYPE_STORE;\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n    // \u30a2\u30c9\u30ec\u30c3\u30b7\u30f3\u30b0\n    opInfo.operand.memOp.addrIn    = isLoad ? isfI.imm : {isfS.imm2, isfS.imm1};\n    opInfo.operand.memOp.isAddAddr = TRUE;\n    opInfo.operand.memOp.isRegAddr = TRUE;\n    RISCV_DecodeMemAccessMode( memAccessMode, memFunct3 );\n    opInfo.operand.memOp.memAccessMode = memAccessMode;\n\n    opInfo.valid = TRUE;\n\n    opInfo.unsupported = FALSE;\n    opInfo.undefined = FALSE;\n\n    // Serialized\n    opInfo.serialized = FALSE;\nendfunction\n\nfunction automatic void RISCV_DecodeFPMemOp(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo memOp;\n    MicroOpIndex mid;\n\n    //RISCV\u3067\u306f\u8907\u6570micro op\u3078\u306e\u5206\u5272\u306f\u57fa\u672c\u7684\u306b\u5fc5\u8981\u306a\u3044\u306f\u305a\n\n    RISCV_EmitFPMemOp(\n        .opInfo( memOp ),\n        .isf( isf )\n    );\n\n    // Initizalize\n    mid = 0;\n    for(int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(memOp, mid, FALSE, TRUE);\n\n    insnInfo.writePC    = FALSE;\n    insnInfo.isCall     = FALSE;\n    insnInfo.isReturn   = FALSE;\n    insnInfo.isRelBranch = FALSE;\n    insnInfo.isSerialized = FALSE;\nendfunction\n\n//\n// --- FP Op\n//\nfunction automatic void RISCV_EmitFPOp(\n    output OpInfo  opInfo,\n    input RISCV_ISF_Common isf,\n    input LScalarRegNumPath srcRegNumA,\n    input LScalarRegNumPath srcRegNumB,\n    input LScalarRegNumPath dstRegNum\n);\n    RISCV_ISF_R isfR;\n    RV32FFunct3 rv32fFunct3;\n    RV32FFunct7 rv32fFunct7;\n    FCVTFunct5  fcvtfunct5;\n    logic dstFP, rs1FP, readrs2;\n\n    FPU_Code fpuCode;\n    Rounding_Mode rm;\n\n    isfR = isf;\n    rv32fFunct3 = RV32FFunct3'(isfR.funct3);\n    rv32fFunct7 = RV32FFunct7'(isfR.funct7);\n    fcvtfunct5  = FCVTFunct5'(isfR.rs2);\n    rm = Rounding_Mode'(isfR.funct3);\n\n    RISCV_DecodeFPOpFunct3( fpuCode, rv32fFunct3, rv32fFunct7, fcvtfunct5);\n    dstFP   = !(fpuCode inside {FC_FCVT_WS, FC_FCVT_WUS, FC_FMV_XW, FC_FEQ, FC_FLT, FC_FLE, FC_FCLASS});\n    rs1FP   = !(fpuCode inside {FC_FCVT_SW, FC_FCVT_SWU, FC_FMV_WX});\n    readrs2 = !(fpuCode inside {FC_SQRT, FC_FCVT_SW, FC_FCVT_SWU, FC_FCVT_WS, FC_FCVT_WUS, FC_FMV_WX, FC_FMV_XW, FC_FCLASS});\n    \n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n    opInfo.operand.fpOp.dstRegNum.isFP  = dstFP;\n    opInfo.operand.fpOp.srcRegNumA.isFP = rs1FP;\n    opInfo.operand.fpOp.srcRegNumB.isFP = TRUE;\n    opInfo.operand.fpOp.srcRegNumC.isFP = TRUE;\n    opInfo.operand.fpOp.dstRegNum.regNum  = dstRegNum;\n    opInfo.operand.fpOp.srcRegNumA.regNum = srcRegNumA;\n    opInfo.operand.fpOp.srcRegNumB.regNum = srcRegNumB;\n    opInfo.operand.fpOp.srcRegNumC.regNum = '0;\n\n    // Rounding Mode\n    opInfo.operand.fpOp.rm = rm;\n\n    // FPU\n    opInfo.operand.fpOp.fpuCode = fpuCode;\n    opInfo.operand.fpOp.padding = '0;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // fp register\u306b\u306f\u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u304c\u7121\u3044\n    opInfo.writeReg  = ( dstFP || dstRegNum != ZERO_REGISTER ) ? TRUE : FALSE;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    opInfo.opTypeA = OOT_REG;\n    opInfo.opTypeB = readrs2 ? OOT_REG : OOT_IMM;\n    opInfo.opTypeC = OOT_IMM;\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_FP;\n    opInfo.mopSubType.fpType = (fpuCode == FC_ADD || fpuCode == FC_SUB ) ? FP_MOP_TYPE_ADD  :\n                                                    (fpuCode == FC_MUL ) ? FP_MOP_TYPE_MUL  :\n                                                    (fpuCode == FC_DIV ) ? FP_MOP_TYPE_DIV  :\n                                                    (fpuCode == FC_SQRT) ? FP_MOP_TYPE_SQRT : FP_MOP_TYPE_OTHER;\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n    // \u672a\u5b9a\u7fa9\u547d\u4ee4\n    opInfo.unsupported = FALSE;\n    opInfo.undefined = FALSE;\n\n    // Serialized\n    opInfo.serialized = FALSE;\n\n    // Control\n    opInfo.valid = TRUE;    // Valid outputs\nendfunction\n\nfunction automatic void RISCV_DecodeFPOp(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo fpOp;\n    MicroOpIndex mid;\n\n    RISCV_EmitFPOp(\n        .opInfo( fpOp ),\n        .isf( isf ),\n        .srcRegNumA( isf.rs1 ),\n        .srcRegNumB( isf.rs2 ),\n        .dstRegNum( isf.rd )\n    );\n\n    mid = 0;\n    for(int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(fpOp, mid, FALSE, TRUE);\n    mid += 1;\n\n    insnInfo.writePC = FALSE;\n    insnInfo.isCall = FALSE;\n    insnInfo.isReturn = FALSE;\n    insnInfo.isRelBranch = FALSE;\n    insnInfo.isSerialized = FALSE;\nendfunction\n\n//\n// --- FP FMA Op\n//\nfunction automatic void RISCV_EmitFPFMAOp(\n    output OpInfo  opInfo,\n    input RISCV_ISF_Common isf\n);\n    RISCV_ISF_R4 isfR4;\n    RISCV_OpCode opCode;\n    FPU_Code fpuCode;\n    Rounding_Mode rm;\n\n    isfR4 = isf;\n    opCode = isfR4.opCode;\n    rm = Rounding_Mode'(isfR4.funct3);\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n    opInfo.operand.fpOp.dstRegNum.isFP  = TRUE;\n    opInfo.operand.fpOp.srcRegNumA.isFP = TRUE;\n    opInfo.operand.fpOp.srcRegNumB.isFP = TRUE;\n    opInfo.operand.fpOp.srcRegNumC.isFP = TRUE;\n    opInfo.operand.fpOp.dstRegNum.regNum  = isfR4.rd;\n    opInfo.operand.fpOp.srcRegNumA.regNum = isfR4.rs1;\n    opInfo.operand.fpOp.srcRegNumB.regNum = isfR4.rs2;\n    opInfo.operand.fpOp.srcRegNumC.regNum = isfR4.rs3;\n\n    // Rounding Mode\n    opInfo.operand.fpOp.rm = rm;\n\n    // FPU\n    RISCV_DecodeFPFMAOpFunct3( fpuCode, opCode);\n    opInfo.operand.fpOp.fpuCode = fpuCode;\n    opInfo.operand.fpOp.padding = '0;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    // fp register\u306b\u306f\u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u304c\u7121\u3044\n    opInfo.writeReg  = TRUE;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    opInfo.opTypeA = OOT_REG;\n    opInfo.opTypeB = OOT_REG;\n    opInfo.opTypeC = OOT_REG;\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_FP;\n    opInfo.mopSubType.fpType = FP_MOP_TYPE_FMA;\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n\n    // \u672a\u5b9a\u7fa9\u547d\u4ee4\n    opInfo.unsupported = FALSE;\n    opInfo.undefined = FALSE;\n\n    // Serialized\n    opInfo.serialized = FALSE;\n\n    // Control\n    opInfo.valid = TRUE;    // Valid outputs\nendfunction\n\nfunction automatic void  RISCV_DecodeFPFMAOp(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf\n);\n    OpInfo fpOp;\n    MicroOpIndex mid;\n\n    RISCV_EmitFPFMAOp(\n        .opInfo( fpOp ),\n        .isf( isf )\n    );\n\n    mid = 0;\n    for(int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1] = ModifyMicroOp(fpOp, mid, FALSE, TRUE);\n    mid += 1;\n\n    insnInfo.writePC = FALSE;\n    insnInfo.isCall = FALSE;\n    insnInfo.isReturn = FALSE;\n    insnInfo.isRelBranch = FALSE;\n    insnInfo.isSerialized = FALSE;\nendfunction\n\n`endif\n\nfunction automatic void RISCV_EmitIllegalOp(\n    output OpInfo opInfo,\n    input logic illegalPC\n);\n    RISCV_ISF_SYSTEM isfSystem;\n    SystemFunct3  opFunct3;\n    SystemFunct12 opFunct12;\n    SystemMicroOpOperand systemOp;\n    logic undefined;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n`ifdef RSD_MARCH_FP_PIPE\n    systemOp.dstRegNum.isFP  = FALSE;\n    systemOp.srcRegNumA.isFP = FALSE;\n    systemOp.srcRegNumB.isFP = FALSE;\n`endif\n    systemOp.dstRegNum.regNum  = '0;\n    systemOp.srcRegNumA.regNum = '0;\n    systemOp.srcRegNumB.regNum = '0;\n    systemOp.isEnv = TRUE;\n    systemOp.padding = '0;\n    systemOp.imm = '0;\n\n    undefined = FALSE;\n\n    // \u30b3\u30fc\u30c9\u306e\u8a2d\u5b9a\n    systemOp.envCode = illegalPC ? ENV_INSN_VIOLATION : ENV_INSN_ILLEGAL;\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    opInfo.mopType = MOP_TYPE_MEM;\n    opInfo.mopSubType.memType = MEM_MOP_TYPE_ENV;\n\n    opInfo.operand.systemOp = systemOp;\n\n    // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    opInfo.writeReg  = FALSE;\n\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u3092\u8aad\u3080\u304b\u3069\u3046\u304b\n    opInfo.opTypeA = OOT_IMM;\n    opInfo.opTypeB = OOT_IMM;\n`ifdef RSD_MARCH_FP_PIPE \n    opInfo.opTypeC = OOT_IMM;\n`endif\n\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    opInfo.cond = COND_AL;\n    opInfo.valid = TRUE;\n    opInfo.unsupported = FALSE;\n    opInfo.undefined = undefined;\n\n    // Serialized\n    opInfo.serialized = TRUE;\nendfunction\n\nfunction automatic void RISCV_DecodeIllegal(\n    output OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,\n    output InsnInfo insnInfo,\n    input RISCV_ISF_Common isf,\n    input illegalPC\n);\n    OpInfo opInfo;\n    MicroOpIndex mid;\n\n    RISCV_EmitIllegalOp(opInfo, illegalPC);\n\n    // Initizalize\n    mid = 0;\n    for (int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n        EmitInvalidOp(microOps[i]);\n    end\n\n    // --- 1\n    // It begins at 1 for aligning outputs to DecodeIntReg.\n    microOps[1]"}
{"text": " = ModifyMicroOp(opInfo, mid, FALSE, TRUE);\n\n    insnInfo.writePC    = FALSE;\n    insnInfo.isCall     = FALSE;\n    insnInfo.isReturn   = FALSE;\n    insnInfo.isRelBranch = FALSE;\n    insnInfo.isSerialized = TRUE;   // A system instruction must be serialized\n\nendfunction\n//\n// --- DecodeStage\u3067\u30a4\u30f3\u30b9\u30bf\u30f3\u30b7\u30a8\u30fc\u30c8\u3055\u308c\u308b\u30e2\u30b8\u30e5\u30fc\u30eb\n//\nmodule Decoder(\ninput\n    InsnPath insn,      // Input instruction\n    logic illegalPC,\noutput\n    OpInfo [MICRO_OP_MAX_NUM-1:0] microOps,  // Outputed micro ops\n    InsnInfo insnInfo  // Whether this instruction is branch or not.\n);\n    RISCV_ISF_Common isf;\n    RV32MFunct7 rv32mFunct7;\n    logic undefined;\n    \n    always_comb begin\n        isf  = insn;\n        rv32mFunct7 = RV32MFunct7'(isf.funct7);\n        \n        insnInfo.writePC = FALSE;\n        insnInfo.isCall = FALSE;\n        insnInfo.isReturn = FALSE;\n        insnInfo.isRelBranch = FALSE;\n        insnInfo.isSerialized = FALSE;\n\n        case (isf.opCode)\n\n            // S: LOAD, STORE\n            RISCV_LD, RISCV_ST : begin\n                RISCV_DecodeMemOp(microOps, insnInfo, insn);\n            end\n\n            // B: BRANCH\n            RISCV_BR : begin\n                RISCV_DecodeBranch(microOps, insnInfo, insn);\n            end\n            // I: JALR\n            RISCV_JALR : begin\n                RISCV_DecodeJALR(microOps, insnInfo, insn);\n            end\n            // J: JAL\n            RISCV_JAL : begin\n                RISCV_DecodeJAL(microOps, insnInfo, insn);\n            end\n\n            // I: OP-IMM\n            RISCV_OP_IMM : begin\n                RISCV_DecodeOpImm(microOps, insnInfo, insn);\n            end\n\n            // R: OP\n            RISCV_OP : begin\n                if (rv32mFunct7 == RV32M_FUNCT7_ALL) begin\n                    RISCV_DecodeComplexOp(microOps, insnInfo, insn);\n                end\n                else begin\n                    RISCV_DecodeOp(microOps, insnInfo, insn);\n                end\n            end\n\n            // U: AUIPC, LUI\n            RISCV_AUIPC, RISCV_LUI : begin\n                RISCV_DecodeUTypeInst(microOps, insnInfo, insn);\n            end\n\n            // I: MISC-MEM (fence/fence.i)\n            RISCV_MISC_MEM : begin\n                RISCV_DecodeMiscMem(microOps, insnInfo, insn);\n            end\n\n            // I: SYSTEM (ebreak/ecall/csr)\n            RISCV_SYSTEM : begin\n                RISCV_DecodeSystem(microOps, insnInfo, insn);\n            end\n`ifdef RSD_MARCH_FP_PIPE\n            RISCV_F_LD, RISCV_F_ST : begin\n                RISCV_DecodeFPMemOp(microOps, insnInfo, insn);\n            end\n\n            RISCV_F_OP : begin\n                RISCV_DecodeFPOp(microOps, insnInfo, insn);\n            end\n\n            RISCV_F_FMADD, RISCV_F_FMSUB, RISCV_F_FNMSUB, RISCV_F_FNMADD : begin\n                RISCV_DecodeFPFMAOp(microOps, insnInfo, insn);\n            end\n`endif\n            default : begin\n                RISCV_DecodeIllegal(microOps, insnInfo, insn, illegalPC);\n            end\n        endcase\n\n        undefined = FALSE;\n        for(int i = 0; i < MICRO_OP_MAX_NUM; i++) begin\n            if(microOps[i].undefined || microOps[i].unsupported) begin\n                undefined = TRUE;\n            end\n        end\n\n        if (undefined || illegalPC) begin\n            RISCV_DecodeIllegal(microOps, insnInfo, insn, illegalPC);\n        end\n\n    end\n\n\n\nendmodule : Decoder\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// DecodeStage\n//\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\nimport FetchUnitTypes::*;\n\n//\n// Pick micro ops for feeding to a next stage from all decoded micro ops.\n//\nmodule MicroOpPicker(\ninput\n    AllDecodedMicroOpPath req,\n    AllDecodedMicroOpPath serialize,\noutput\n    logic picked[DECODE_WIDTH],\n    AllDecodedMicroOpIndex pickedIndex[DECODE_WIDTH],\n    AllDecodedMicroOpPath next\n);\n    logic clear;\n    logic sent;\n    AllDecodedMicroOpPath cur;\n\n    always_comb begin\n        clear = FALSE;\n        sent = FALSE;\n        cur = req;\n\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            picked[i] = FALSE;\n            pickedIndex[i] = 0;\n            for (int mn = 0; mn < ALL_DECODED_MICRO_OP_WIDTH; mn++) begin\n                if (cur[mn] && !clear) begin\n                    // \u30b7\u30ea\u30a2\u30e9\u30a4\u30ba\u304c\u6709\u52b9\u306a\u5834\u5408\uff0c1 mop \u306e\u307f\u6b21\u306e\u30b9\u30c6\u30fc\u30b8\u306b\u9001\u308b\n                    // If this op is serialized one, only a single op is picked.\n                    if (serialize[mn]) begin\n                        clear = TRUE;\n                    end\n                    // \u65e2\u306b\u901a\u5e38\u547d\u4ee4\u3092\u9001\u3063\u3066\u3044\u308b\u5834\u5408\uff0c\u3053\u306e\u30b7\u30ea\u30a2\u30e9\u30a4\u30ba\u547d\u4ee4\u306f\u30d4\u30c3\u30af\u3057\u306a\u3044\n                    if (clear && sent) begin\n                        break;\n                    end\n\n                    sent = TRUE;\n                    picked[i] = TRUE;\n                    pickedIndex[i] = mn;\n                    cur[mn] = FALSE;\n                    break;\n                end\n            end\n            \n        end\n        \n        next = cur;\n    end\nendmodule\n\n\n\nmodule DecodeStage(\n    DecodeStageIF.ThisStage port, \n    PreDecodeStageIF.NextStage prev,\n    ControllerIF.DecodeStage ctrl,\n    DebugIF.DecodeStage debug,\n    PerformanceCounterIF.DecodeStage perfCounter\n);\n    // --- Pipeline registers\n    DecodeStageRegPath pipeReg[DECODE_WIDTH];\n    \n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n\n    always_ff@ (posedge port.clk)\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < DECODE_WIDTH; i++) begin\n                pipeReg[i].valid <= FALSE;\n            end\n        end\n        else if (!ctrl.idStage.stall) begin             // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n    // Pipeline control\n    logic stall, clear;\n    logic empty;\n    RenameStageRegPath nextStage[DECODE_WIDTH];\n    \n    // Micro-op decoder\n    OpInfo [ALL_DECODED_MICRO_OP_WIDTH-1:0] microOps;  // Decoded micro ops\n    InsnInfo [DECODE_WIDTH-1:0] insnInfo;   // Whether a decoded instruction is branch or not.\n    \n    always_comb begin\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            for (int j = 0; j < MICRO_OP_MAX_NUM; j++) begin\n                microOps[i*MICRO_OP_MAX_NUM + j] = pipeReg[i].microOps[j];\n            end\n            insnInfo[i] = pipeReg[i].insnInfo;\n        end\n\n        empty = TRUE;\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            if (pipeReg[i].valid)\n                empty = FALSE;\n        end\n        ctrl.idStageEmpty = empty;\n    end\n    \n    \n    // Control\n    logic initiate;\n    logic complete;\n    \n    // Early branch misprediction detection.\n    RISCV_ISF_Common [DECODE_WIDTH-1:0] isfIn;\n    logic stallBranchResolver;\n    logic insnValidIn[DECODE_WIDTH];\n    BranchPred [DECODE_WIDTH-1:0] brPredIn;\n    PC_Path pcIn[DECODE_WIDTH];\n\n    logic insnValidOut[DECODE_WIDTH];\n    logic insnFlushed[DECODE_WIDTH];\n    logic insnFlushTriggering[DECODE_WIDTH];\n    logic flushTriggered;\n    BranchPred brPredOut[DECODE_WIDTH];\n    PC_Path recoveredPC;\n\n    always_comb begin\n        stallBranchResolver = ctrl.idStage.stall && !ctrl.stallByDecodeStage;\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            insnValidIn[i] = pipeReg[i].valid;\n            isfIn[i] = pipeReg[i].insn;\n            pcIn[i] = pipeReg[i].pc;\n            brPredIn[i] = pipeReg[i].brPred;\n        end\n    end\n\n    DecodedBranchResolver decodeStageBranchResolver(\n        .clk(port.clk),\n        .rst(port.rst),\n        .stall(stallBranchResolver),\n        .decodeComplete(complete),\n        .insnValidIn(insnValidIn),\n        .isf(isfIn),\n        .brPredIn(brPredIn),\n        .pc(pcIn),\n        .insnInfo(insnInfo),\n        .insnValidOut(insnValidOut),\n        .insnFlushed(insnFlushed),\n        .insnFlushTriggering(insnFlushTriggering),\n        .flushTriggered(flushTriggered),\n        .brPredOut(brPredOut),\n        .recoveredPC(recoveredPC)\n    );\n    \n    always_comb begin\n        port.nextFlush = complete && flushTriggered && !clear;\n        port.nextRecoveredPC = recoveredPC;\n    end\n    \n    AllDecodedMicroOpPath remainingValidMOps;\n    AllDecodedMicroOpPath nextValidMOps;\n\n    AllDecodedMicroOpPath curValidMOps;\n    AllDecodedMicroOpPath pickedValidMOps;\n    AllDecodedMicroOpPath serializedMOps;\n    \n    AllDecodedMicroOpIndex mopPickedIndex[DECODE_WIDTH];\n    logic mopPicked[DECODE_WIDTH];\n    DecodeLaneIndexPath orgPickedInsnLane;\n\n\n    always_ff@( posedge port.clk ) begin\n        if (port.rst || ctrl.idStage.clear) begin\n            remainingValidMOps <= 0;\n            initiate <= TRUE;\n        end\n        else begin\n            if (!(ctrl.idStage.stall && !ctrl.stallByDecodeStage)) begin\n                initiate <= complete;\n                remainingValidMOps <= nextValidMOps;\n            end\n        end\n    end\n    \n    // From the index of decoded micro ops lanes to that of instructions.\n    function automatic DecodeLaneIndexPath ToInsnLane(AllDecodedMicroOpIndex mopLane);\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            for (int j = 0; j < MICRO_OP_MAX_NUM; j++) begin\n                if(mopLane == i*MICRO_OP_MAX_NUM + j)\n                    return i;\n            end\n        end\n        return 0;\n    endfunction\n    \n\n    always_comb begin\n        \n        //\n        // Setup current valid bits(=un-decoded bits).\n        //\n        if (initiate) begin\n            for (int i = 0; i < ALL_DECODED_MICRO_OP_WIDTH; i++) begin\n                curValidMOps[i] = microOps[i].valid;\n            end\n        end\n        else begin\n            curValidMOps = remainingValidMOps;\n        end\n\n        // Set a \"serialized\" flag for each micro op.\n        for (int i = 0; i < ALL_DECODED_MICRO_OP_WIDTH; i++) begin\n            serializedMOps[i] = microOps[i].serialized;\n        end\n    end\n\n    MicroOpPicker picker(curValidMOps, serializedMOps, mopPicked, mopPickedIndex, pickedValidMOps);\n\n    always_comb begin\n        // --- The picker picks micro ops\n\n        // Set picked results.\n        nextValidMOps = pickedValidMOps;\n        \n        complete = TRUE;\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            for (int j = 0; j < MICRO_OP_MAX_NUM; j++) begin\n                if(nextValidMOps[i*MICRO_OP_MAX_NUM+j] && insnValidIn[i]) begin\n                    complete = FALSE;\n                end\n            end\n            // \"complete\" does not care \"insnValidOut\" because \"insnValidOut\" is in\n            // a critical path.\n            if(!insnValidOut[i]) begin\n                for (int j = 0; j < MICRO_OP_MAX_NUM; j++) begin\n                    nextValidMOps[i*MICRO_OP_MAX_NUM + j] = FALSE;\n                end\n            end\n        end\n\n        // Stall decision\n        ctrl.idStageStallUpper = !complete;\n        // After idStageStallUpper is received, the Controller returns stall/clear signals.\n        stall = ctrl.idStage.stall;\n        clear = ctrl.idStage.clear;\n        \n        \n        // Pick decoded micro ops.\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            orgPickedInsnLane = ToInsnLane(mopPickedIndex[i]);\n        \n            nextStage[i].opInfo = microOps[ mopPickedIndex[i] ];\n\n            nextStage[i].valid = insnValidOut[orgPickedInsnLane] && mopPicked[i] && !clear;\n            nextStage[i].pc = pipeReg[orgPickedInsnLane].pc;\n            nextStage[i].bPred = brPredOut[orgPickedInsnLane];  \n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId.sid = pipeReg[orgPickedInsnLane].sid;\n            nextStage[i].opId.mid = nextStage[i].opInfo.mid;\n`endif\n        end\n        \n        \n        port.nextStage = nextStage;\n\n`ifndef RSD_DISABLE_PERFORMANCE_COUNTER\n        perfCounter.branchPredMissDetectedOnDecode = complete && flushTriggered && !clear;\n`endif\n        // Debug Register\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            // \u5148\u982d\u304c\u6b21\u306b\u9001\u3089\u308c\u305f\u3089\uff0c\u30c7\u30b3\u30fc\u30c9\u5143\u306f\u6d88\u3048\u308b\uff0e\n            debug.idReg[i].valid = pipeReg[i].valid;\n            debug.idReg[i].flushed = insnFlushed[i];\n            debug.idReg[i].flushTriggering = insnFlushTriggering[i];\n\n            for (int j = 0; j < MICRO_OP_MAX_NUM; j++) begin\n                if(microOps[i*MICRO_OP_MAX_NUM + j].valid && microOps[i*MICRO_OP_MAX_NUM + j].mid == 0) begin\n                    if(!curValidMOps[i*MICRO_OP_MAX_NUM + j]) begin\n                        debug.idReg[i].valid = FALSE;\n                    end\n                    break;\n                end\n            end\n            \n            \n            debug.idReg[i].opId.sid = pipeReg[i].sid;\n            debug.idReg[i].opId.mid = 0;\n            debug.idReg[i].pc = ToAddrFromPC(pipeReg[i].pc);\n            debug.idReg[i].insn = pipeReg[i].insn;\n            \n            debug.idReg[i].undefined = FALSE;\n            debug.idReg[i].unsupported = FALSE;\n            for (int j = 0; j < MICRO_OP_MAX_NUM; j++) begin\n                debug.idReg[i].undefined = debug.idReg[i].undefined | microOps[i*MICRO_OP_MAX_NUM + j].undefined;\n                debug.idReg[i].unsupported = debug.idReg[i].unsupported | microOps[i*MICRO_OP_MAX_NUM + j].unsupported;\n            end\n        end\n`endif\n\n    end\nendmodule : DecodeStage\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- FetchPipe\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\nimport MicroOpTypes::*;\n\ninterface DecodeStageIF( input logic clk, rst );\n\n    // Pipeline registers \n    RenameStageRegPath nextStage[ DECODE_WIDTH ];\n    logic nextFlush;\n    AddrPath nextRecoveredPC;\n    \n    modport ThisStage(\n    input \n        clk, \n        rst,\n    output \n        nextStage,\n        nextFlush,\n        nextRecoveredPC\n    );\n    \n    modport NextStage(\n    input\n        nextStage,\n        nextFlush,\n        nextRecoveredPC\n    );\n    \nendinterface : DecodeStageIF\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for dispatch.\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport MicroOpTypes::*;\nimport PipelineTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport DebugTypes::*;\n\nmodule DispatchStage(\n    //DispatchStageIF.ThisStage port,\n    RenameStageIF.NextStage prev,\n    SchedulerIF.DispatchStage scheduler,\n    ControllerIF.DispatchStage ctrl,\n    DebugIF.DispatchStage debug\n);\n\n    // \u30d1\u30c7\u30a3\u30f3\u30b0\u306f IntOpSubInfo \u306e\u307f\u884c\u3046\uff0e\u5bfe\u5fdc\u3067\u304d\u306a\u3044\u5834\u5408\u306f ASSERT \u306b\u5f15\u3063\u304b\u304b\u308b\n    `RSD_STATIC_ASSERT(\n        INT_SUB_INFO_BIT_WIDTH <= BR_SUB_INFO_BIT_WIDTH, \n        \"Invalid padding at IntOpSubInfo\"\n    );\n\n    // --- Pipeline registers\n    DispatchStageRegPath pipeReg [ DISPATCH_WIDTH ];\n    always_ff @(posedge ctrl.clk) begin\n        if (ctrl.rst) begin\n            for (int i = 0; i < DISPATCH_WIDTH; i++) begin\n                pipeReg[i] <= '0;\n            end\n        end\n        else if (!ctrl.dsStage.stall) begin\n            pipeReg <= prev.nextStage;\n        end\n        else begin\n            pipeReg <= pipeReg;\n        end\n    end\n\n    // Pipeline controll\n    logic stall, clear;\n    logic update  [ DISPATCH_WIDTH ];\n    OpInfo opInfo [ DISPATCH_WIDTH ];\n    IntIssueQueueEntry     intEntry     [ DISPATCH_WIDTH ];\n    ComplexIssueQueueEntry complexEntry [ DISPATCH_WIDTH ];\n    MemIssueQueueEntry     memEntry     [ DISPATCH_WIDTH ];\n`ifdef RSD_MARCH_FP_PIPE\n    FPIssueQueueEntry      fpEntry      [ DISPATCH_WIDTH ];\n`endif\n    SchedulerEntry schedulerEntry [ DISPATCH_WIDTH ];\n    OpSrc opSrc[ DISPATCH_WIDTH ];\n    OpDst opDst[ DISPATCH_WIDTH ];\n\n    IntOpSubInfo intSubInfo[ DISPATCH_WIDTH ];\n    BrOpSubInfo  brSubInfo [ DISPATCH_WIDTH ];\n    MulOpSubInfo mulSubInfo[ DISPATCH_WIDTH ];\n    DivOpSubInfo divSubInfo[ DISPATCH_WIDTH ];\n    always_comb begin\n        stall = ctrl.dsStage.stall;\n        clear = ctrl.dsStage.clear;\n\n        for (int i = 0; i < DISPATCH_WIDTH; i++) begin\n            update[i] = !stall && !clear && pipeReg[i].valid;\n            opInfo[i] = pipeReg[i].opInfo;\n        end\n\n        //\n        // Dispatch an op to the shceduler.\n        //\n        for (int i = 0; i < DISPATCH_WIDTH; i++) begin\n            //\n            // Issue queue payload RAM entry.\n            //\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            intEntry[i].opId     = pipeReg[i].opId;\n            complexEntry[i].opId = pipeReg[i].opId;\n            memEntry[i].opId     = pipeReg[i].opId;\n`ifdef RSD_MARCH_FP_PIPE\n            fpEntry[i].opId      = pipeReg[i].opId;\n`endif\n`endif\n            // OpSrc\n            opSrc[i].phySrcRegNumA = pipeReg[i].phySrcRegNumA;\n            opSrc[i].phySrcRegNumB = pipeReg[i].phySrcRegNumB;\n`ifdef RSD_MARCH_FP_PIPE\n            opSrc[i].phySrcRegNumC = pipeReg[i].phySrcRegNumC;\n`endif\n\n            // OpDst\n            opDst[i].writeReg = pipeReg[i].opInfo.writeReg;\n            opDst[i].phyDstRegNum = pipeReg[i].phyDstRegNum;\n\n            //\n            // --- To an integer queue.\n            //\n            intEntry[i].opType = opInfo[i].mopSubType.intType;\n            intEntry[i].cond = opInfo[i].cond;\n\n            // OpSrc/OpDst\n            intEntry[i].opSrc = opSrc[i];\n            intEntry[i].opDst = opDst[i];\n\n            // ActiveListIndexPath\n            intEntry[i].activeListPtr = pipeReg[i].activeListPtr;\n\n            //LSQ Tail Pointer for one cycle recovery\n            intEntry[i].loadQueueRecoveryPtr = pipeReg[i].loadQueueRecoveryPtr;\n            intEntry[i].storeQueueRecoveryPtr = pipeReg[i].storeQueueRecoveryPtr;\n\n            // PC\n            intEntry[i].pc = pipeReg[i].pc;\n\n            intSubInfo[i].operandTypeA  = opInfo[i].opTypeA;\n            intSubInfo[i].operandTypeB  = opInfo[i].opTypeB;\n            intSubInfo[i].shiftIn       = opInfo[i].operand.intOp.shiftIn;\n            intSubInfo[i].shiftType     = opInfo[i].operand.intOp.shiftType;\n            intSubInfo[i].aluCode       = opInfo[i].operand.intOp.aluCode;\n            intSubInfo[i].padding = '0;\n\n            brSubInfo[i].brDisp = opInfo[i].operand.brOp.brDisp;\n            brSubInfo[i].bPred = pipeReg[i].brPred;\n            brSubInfo[i].operandTypeA = opInfo[i].opTypeA;\n            brSubInfo[i].operandTypeB = opInfo[i].opTypeB;\n\n            if ((intEntry[i].opType == INT_MOP_TYPE_BR) || (intEntry[i].opType == INT_MOP_TYPE_RIJ) ) begin\n                intEntry[i].intOpInfo.brSubInfo = brSubInfo[i];\n            end\n            else begin\n                intEntry[i].intOpInfo.intSubInfo = intSubInfo[i];\n            end\n\n            //\n            // --- To a complex integer queue.\n            //\n            complexEntry[i].opType = opInfo[i].mopSubType.complexType;\n\n            // OpSrc/OpDst\n            complexEntry[i].opSrc = opSrc[i];\n            complexEntry[i].opDst = opDst[i];\n\n            // ActiveListIndexPath\n            complexEntry[i].activeListPtr = pipeReg[i].activeListPtr;\n\n            // PC\n            complexEntry[i].pc = pipeReg[i].pc;\n\n            complexEntry[i].loadQueueRecoveryPtr = pipeReg[i].loadQueueRecoveryPtr;\n            complexEntry[i].storeQueueRecoveryPtr = pipeReg[i].storeQueueRecoveryPtr;\n\n            mulSubInfo[i].mulGetUpper = opInfo[i].operand.complexOp.mulGetUpper;\n            mulSubInfo[i].mulCode = opInfo[i].operand.complexOp.mulCode;\n\n            divSubInfo[i].padding = '0;\n            divSubInfo[i].divCode = opInfo[i].operand.complexOp.divCode;\n            \n            if (complexEntry[i].opType == COMPLEX_MOP_TYPE_MUL) begin\n                complexEntry[i].complexOpInfo.mulSubInfo = mulSubInfo[i];\n            end\n            else begin // \u5c06\u6765Complex\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u306bMul\u3068Div\u4ee5\u5916\u306e\u6f14\u7b97\u5668\u3092\u8ffd\u52a0\u3059\u308b\u5834\u5408\u306f\u3053\u3053\u3092else if (complexEntry[i].opType == COMPLEX_MOP_TYPE_DIV)\u306b\n                complexEntry[i].complexOpInfo.divSubInfo = divSubInfo[i];\n            end\n            \n            //\n            // --- To a memory queue.\n            //\n\n            // MemOpInfo\n            memEntry[i].memOpInfo.opType = opInfo[i].mopSubType.memType;\n\n            memEntry[i].memOpInfo.cond          = opInfo[i].cond;\n            memEntry[i].memOpInfo.operandTypeA  = opInfo[i].opTypeA;\n            memEntry[i].memOpInfo.operandTypeB  = opInfo[i].opTypeB;\n            memEntry[i].memOpInfo.addrIn        = opInfo[i].operand.memOp.addrIn;\n            memEntry[i].memOpInfo.isAddAddr     = opInfo[i].operand.memOp.isAddAddr;\n            memEntry[i].memOpInfo.isRegAddr     = opInfo[i].operand.memOp.isRegAddr;\n            memEntry[i].memOpInfo.memAccessMode = opInfo[i].operand.memOp.memAccessMode;\n\n            memEntry[i].memOpInfo.csrCtrl     = opInfo[i].operand.memOp.csrCtrl;\n            memEntry[i].memOpInfo.envCode     = opInfo[i].operand.systemOp.envCode;\n\n            memEntry[i].memOpInfo.isFenceI    = opInfo[i].operand.miscMemOp.fenceI;\n\n`ifdef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n            // \u3053\u308c\u3089\u306f complex \u306e\u30d5\u30a9\u30fc\u30de\u30c3\u30c8\u304b\u3089\u53d6\u5f97\u3059\u308b\n            memEntry[i].memOpInfo.mulSubInfo = mulSubInfo[i];\n            memEntry[i].memOpInfo.divSubInfo = divSubInfo[i];\n`endif\n\n            memEntry[i].loadQueuePtr  = pipeReg[i].loadQueuePtr;\n            memEntry[i].storeQueuePtr = pipeReg[i].storeQueuePtr;\n\n            memEntry[i].hasAllocatedMSHR = 0;\n            memEntry[i].mshrID = '0;\n\n            // OpSrc\n            memEntry[i].opSrc = opSrc[i];\n            memEntry[i].opDst = opDst[i];\n\n            // ActiveListIndexPath\n            memEntry[i].activeListPtr = pipeReg[i].activeListPtr;\n\n            //LSQ Tail Pointer for one cycle recovery\n            memEntry[i].loadQueueRecoveryPtr = pipeReg[i].loadQueueRecoveryPtr;\n            memEntry[i].storeQueueRecoveryPtr = pipeReg[i].storeQueueRecoveryPtr;\n\n            // PC\n            memEntry[i].pc = pipeReg[i].pc;\n\n`ifdef RSD_MARCH_FP_PIPE\n            //\n            // --- To a FP queue.\n            //\n            fpEntry[i].fpOpInfo.opType = opInfo[i].mopSubType.fpType;\n            fpEntry[i].fpOpInfo.fpuCode = opInfo[i].operand.fpOp.fpuCode;\n            fpEntry[i].fpOpInfo.rm = opInfo[i].operand.fpOp.rm;\n            fpEntry[i].fpOpInfo.operandTypeA = opInfo[i].opTypeA;\n            fpEntry[i].fpOpInfo.operandTypeB = opInfo[i].opTypeB;\n            fpEntry[i].fpOpInfo.operandTypeC = opInfo[i].opTypeC;\n            \n            // OpSrc\n            fpEntry[i].opSrc = opSrc[i];\n            fpEntry[i].opDst = opDst[i];\n            \n            // ActiveListIndexPath\n            fpEntry[i].activeListPtr = pipeReg[i].activeListPtr;\n\n            //LSQ Tail Pointer for one cycle recovery\n            fpEntry[i].loadQueueRecoveryPtr  = pipeReg[i].loadQueuePtr;\n            fpEntry[i].storeQueueRecoveryPtr = pipeReg[i].storeQueuePtr;\n\n            // PC\n            fpEntry[i].pc = pipeReg[i].pc;\n`endif\n \n            //\n            // Scheduler Entry\n            //\n            schedulerEntry[i].opType = opInfo[i].mopType;\n            schedulerEntry[i].opSubType = opInfo[i].mopSubType;\n\n            schedulerEntry[i].srcRegValidA = ( opInfo[i].opTypeA == OOT_REG );\n            schedulerEntry[i].srcRegValidB = ( opInfo[i].opTypeB == OOT_REG );\n`ifdef RSD_MARCH_FP_PIPE\n            schedulerEntry[i].srcRegValidC = ( opInfo[i].opTypeC == OOT_REG );\n`endif\n            schedulerEntry[i].opSrc = opSrc[i];\n            schedulerEntry[i].opDst = opDst[i];\n\n            schedulerEntry[i].srcPtrRegA = pipeReg[i].srcIssueQueuePtrRegA;\n            schedulerEntry[i].srcPtrRegB = pipeReg[i].srcIssueQueuePtrRegB;\n`ifdef RSD_MARCH_FP_PIPE\n            schedulerEntry[i].srcPtrRegC = pipeReg[i].srcIssueQueuePtrRegC;\n`endif\n\n            //\n            // Output to scheduler\n            //\n            scheduler.write[i] = update[i];\n            scheduler.writePtr[i] = pipeReg[i].issueQueuePtr;\n            scheduler.writeAL_Ptr[i] = pipeReg[i].activeListPtr;\n            scheduler.intWriteData[i] = intEntry[i];\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n            scheduler.complexWriteData[i] = complexEntry[i];\n`endif\n            scheduler.memWriteData[i] = memEntry[i];\n`ifdef RSD_MARCH_FP_PIPE\n            scheduler.fpWriteData[i] = fpEntry[i];\n`endif\n            scheduler.writeSchedulerData[i] = schedulerEntry[i];\n            scheduler.allocated[i] = pipeReg[i].valid;\n            scheduler.memDependencyPred[i] = prev.memDependencyPred[i];\n        end\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        // Debug Register\n        for (int i = 0; i < DISPATCH_WIDTH; i++) begin\n            debug.dsReg[i].valid = pipeReg[i].valid;\n            debug.dsReg[i].opId = pipeReg[i].opId;\n\n`ifdef RSD_FUNCTIONAL_SIMULATION\n            debug.dsReg[i].readRegA = opInfo[i].opTypeA == OOT_REG;\n            debug.dsReg[i].logSrcRegA = opInfo[i].operand.intOp.srcRegNumA;\n            debug.dsReg[i].phySrcRegA = pipeReg[i].phySrcRegNumA;\n\n            debug.dsReg[i].readRegB = opInfo[i].opTypeB == OOT_REG;\n            debug.dsReg[i].logSrcRegB = opInfo[i].operand.intOp.srcRegNumB;\n            debug.dsReg[i].phySrcRegB = pipeReg[i].phySrcRegNumB;\n`ifdef RSD_MARCH_FP_PIPE \n            debug.dsReg[i].readRegC = opInfo[i].opTypeC == OOT_REG;\n            debug.dsReg[i].logSrcRegC = opInfo[i].operand.fpOp.srcRegNumC;\n            debug.dsReg[i].phySrcRegC = pipeReg[i].phySrcRegNumC;\n`endif\n\n            debug.dsReg[i].writeReg = opInfo[i].writeReg;\n            debug.dsReg[i].logDstReg = opInfo[i].operand.intOp.dstRegNum;\n            debug.dsReg[i].phyDstReg = pipeReg[i].phyDstRegNum;\n            debug.dsReg[i].phyPrevDstReg = pipeReg[i].phyPrevDstRegNum;\n\n            debug.dsReg[i].activeListPtr = pipeReg[i].activeListPtr;\n            debug.dsReg[i].issueQueuePtr = pipeReg[i].issueQueuePtr;\n`endif\n        end\n`endif\n    end\n\nendmodule : DispatchStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- DispatchStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface DispatchStageIF( input logic clk, rst );\n    \n    modport ThisStage(\n    input\n        clk,\n        rst\n    );\n\nendinterface : DispatchStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- Divider Unit\n//\n// - 32bit/32bit=32bit\u3092\u884c\u3046\u30e2\u30b8\u30e5\u30fc\u30eb\n//\n\nimport BasicTypes::*;\nimport MicroOpTypes::*;\nimport OpFormatTypes::*;\n\n// \u9664\u7b97\u30e6\u30cb\u30c3\u30c8\nmodule DividerUnit (\ninput\n    logic clk, rst,\n    logic req,\n    DataPath fuOpA_In,\n    DataPath fuOpB_In,\n    IntDIV_Code divCode,\noutput\n    logic finished,\n    DataPath dataOut\n);\n\n    logic regIsSigned, nextIsSigned;\n    DataPath regDividend, nextDividend;\n    DataPath regDivisor, nextDivisor;\n    IntDIV_Code regDivCode, nextDivCode;\n    DataPath quotient, remainder;\n    \n    QuickDivider div ( \n        .clk( clk ),\n        .rst( rst ),\n        .req ( req ),\n        .dividend ( nextDividend ),\n        .divisor ( nextDivisor ),\n        .isSigned ( nextIsSigned ),\n        .finished ( finished ),\n        .quotient ( quotient ),\n        .remainder ( remainder )\n    );\n    \n// IntDIV code\n/*\ntypedef enum logic [1:0]    // enum IntDIV_Code\n{\n    AC_DIV    = 2'b00,    // DIV    \n    AC_DIVU   = 2'b01,    // DIVU\n    AC_REM    = 2'b10,    // REM \n    AC_REMU   = 2'b11     // REMU  \n} IntDIV_Code;\n*/\n\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            regIsSigned <= FALSE;\n            regDividend <= '0;\n            regDivisor <= '0;\n            regDivCode <= AC_DIV;\n        end\n        else begin\n            regIsSigned <= nextIsSigned;\n            regDividend <= nextDividend;\n            regDivisor <= nextDivisor;\n            regDivCode <= nextDivCode;\n        end\n    end\n\n    // Make src operands unsigned(plus) value.\n    always_comb begin\n        if (req) begin\n            if (divCode == AC_DIVU || divCode == AC_REMU) begin\n                // DIVU and REMU take srcs as unsigned.\n                nextIsSigned = FALSE;\n            end\n            else begin\n                // DIV and REM take srcs as signed.\n                nextIsSigned = TRUE;\n            end\n            nextDividend = fuOpA_In;\n            nextDivisor = fuOpB_In;\n            nextDivCode = divCode;\n        end\n        else begin\n            // Keep the value \n            nextIsSigned = regIsSigned;\n            nextDividend = regDividend;\n            nextDivisor = regDivisor;\n            nextDivCode = regDivCode;\n        end\n\n        // Choose output from div or rem.\n        if (regDivCode == AC_DIV || regDivCode == AC_DIVU) begin\n            dataOut = quotient;\n        end\n        else begin\n            dataOut = remainder;\n        end\n    end\n\nendmodule : DividerUnit\n\n\n// \u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5316\u3055\u308c\u305f\u9664\u7b97\u30e6\u30cb\u30c3\u30c8\nmodule PipelinedDividerUnit #( \n    parameter BIT_WIDTH = 32,\n    parameter PIPELINE_DEPTH = 3\n)( \ninput\n    logic clk, \n    logic stall,\n    logic req,\n    DataPath fuOpA_In,\n    DataPath fuOpB_In,\n    IntDIV_Code divCode,\noutput\n    logic finished,\n    DataPath dataOut\n);\n    \n    typedef struct packed { // PipeReg\n        logic valid;\n        logic isSigned;\n        IntDIV_Code divCode;\n    } PipeReg;\n    \n    PipeReg pipeReg[ PIPELINE_DEPTH-1 ], nextReg;\n    \n    DataPath quotient, remainder;\n    logic isSigned;\n    DataPath dividend;\n    DataPath divisor;\n\n    PipelinedRefDivider #( \n        .BIT_WIDTH( $bits(DataPath) ),\n        .PIPELINE_DEPTH( PIPELINE_DEPTH )\n    ) div (\n        .clk( clk ),\n        .stall( stall ),\n        .dividend(dividend),\n        .divisor(divisor),\n        .isSigned(isSigned),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    always_ff @(posedge clk) begin\n        if (!stall) begin\n            pipeReg[0] <= nextReg;\n            for (int i = 1; i < PIPELINE_DEPTH-1; i++) begin\n                pipeReg[i] <= pipeReg[i-1];\n            end\n        end\n    end\n\n    // Make src operands unsigned(plus) value.\n    always_comb begin\n        if (divCode == AC_DIVU || divCode == AC_REMU) begin\n            // // MULHU takes srcA as unsigned.\n            // srcA_signed = fuOpA_signed;\n            isSigned = TRUE;\n        end\n        else begin\n            isSigned = FALSE;\n        end\n\n\n        dividend = fuOpA_In;\n        divisor = fuOpB_In;\n\n        nextReg.isSigned = isSigned;\n        nextReg.divCode = divCode;\n        nextReg.valid = req;\n\n        if (pipeReg[PIPELINE_DEPTH-2].valid) begin\n            if (pipeReg[PIPELINE_DEPTH-2].divCode == AC_DIV || pipeReg[PIPELINE_DEPTH-2].divCode == AC_DIVU) begin\n                dataOut = quotient;\n            end\n            else begin\n                dataOut = remainder;\n            end\n\n            finished = TRUE;\n        end\n        else begin\n            dataOut = '0;\n            finished = FALSE;\n        end\n    end\n\n    \n`ifndef RSD_SYNTHESIS\n    initial begin\n        for (int i = 0; i < PIPELINE_DEPTH-1; i++) begin\n            pipeReg[i] <= '0;\n        end\n    end\n`endif\n\nendmodule : PipelinedDividerUnit\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for fetching instructions.\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\nimport FetchUnitTypes::*;\nimport MemoryMapTypes::*;\n\nmodule FetchStage(\n    FetchStageIF.ThisStage port,\n    NextPCStageIF.NextStage prev,\n    ControllerIF.FetchStage ctrl,\n    DebugIF.FetchStage debug,\n    PerformanceCounterIF.FetchStage perfCounter\n);\n\n    // Pipeline Control\n    logic stall, clear;\n    logic empty;\n    logic regStall, beginStall;\n    always_ff @(posedge port.clk) begin\n        if (port.rst) begin\n            regStall <= FALSE;\n        end\n        else begin\n            regStall <= stall;\n        end\n    end\n\n    \n    // --- Pipeline registers\n    FetchStageRegPath pipeReg[FETCH_WIDTH];\n    PreDecodeStageRegPath nextStage[ FETCH_WIDTH ];\n\n    always_comb begin\n        // Stall upper stages if cannot fetch valid instruction \n        // This request sends back ctrl.ifStage.stall/ctrl.ifStage.clear\n        ctrl.ifStageSendBubbleLower = \n            pipeReg[0].valid && !port.icReadHit[0];\n\n        // Control\n        stall = ctrl.ifStage.stall;\n        clear = ctrl.ifStage.clear;\n\n        // Check whether instructions exist in this stage\n        empty = TRUE;\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            if (pipeReg[i].valid)\n                empty = FALSE;\n        end\n        ctrl.ifStageEmpty = empty;\n\n        // Detect beginning of stall\n        beginStall = !regStall && stall;\n\n`ifndef RSD_DISABLE_PERFORMANCE_COUNTER\n        // Stall can be caused by another reason from an i-cache miss.\n        perfCounter.icMiss = beginStall && pipeReg[0].valid && !port.icReadHit[0];\n`endif\n    end\n\n    // Whether instruction is invalidated by branch prediction\n    logic isFlushed[FETCH_WIDTH];\n\n    always_ff @(posedge port.clk) begin\n        if (port.rst) begin\n            for (int i = 0; i < FETCH_WIDTH; i++) begin\n                pipeReg[i] <= '0;\n            end\n        end\n        else if (!stall) begin\n            pipeReg <= prev.nextStage;\n        end\n        else begin\n            for (int i = 0; i < FETCH_WIDTH; i++) begin\n                if (isFlushed[i]) begin                    \n                    // When a branch is predicted as Taken during stall,\n                    // clear the valid bits of the subsequent lanes\n                    pipeReg[i].valid <= FALSE;\n                end\n            end\n        end\n    end\n\n\n    BranchPred brPred[FETCH_WIDTH];\n\n    // Record the result of branch prediction.\n    //\n    // When this stage is stalled, the next instruction's PC is input to \n    // the branch predictor and the output of the branch predictor will change \n    // in the next cycle.\n    // Hence, when stalled, the process of branch prediction must be performed at the beginning cycle of stall.\n    // And more, it is necessary to keep the branch prediction result of the stalled instruction.\n    BranchPred regBrPred[FETCH_WIDTH];\n    always_ff @(posedge port.clk) begin\n        if (port.rst) begin\n            for (int i = 0; i < FETCH_WIDTH; i++) begin\n                regBrPred[i] <= '0;\n            end\n        end\n        else if (beginStall) begin\n            regBrPred <= brPred;\n        end\n    end\n\n\n    //\n    // Branch Prediction\n    //\n    always_comb begin\n\n        // The result of branch prediction\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            brPred[i].predAddr = port.brPredTaken[i] ? \n                port.btbOut[i] : pipeReg[i].pc + INSN_BYTE_WIDTH;\n            brPred[i].predTaken = port.brPredTaken[i];\n            brPred[i].globalHistory = port.brGlobalHistory[i];\n            brPred[i].phtPrevValue = port.phtPrevValue[i];\n        end\n\n        // Check whether instructions are flushed by branch prediction\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            isFlushed[i] = FALSE;\n            if (!regStall && pipeReg[i].valid && brPred[i].predTaken) begin\n                for (int j = i + 1; j < FETCH_WIDTH; j++) begin\n                    isFlushed[j] = pipeReg[j].valid;\n                end\n\n                break;\n            end\n        end\n\n        // Update the branch history\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            port.updateBrHistory[i] = !regStall && pipeReg[i].valid;\n        end\n    end\n\n\n    //\n    // I-cache Access\n    //\n    AddrPath fetchAddrOut;\n    always_comb begin\n        // --- I-cache read\n        port.icRE = pipeReg[0].valid; // read enable: whether check hit/miss\n        fetchAddrOut = ToAddrFromPC(pipeReg[0].pc);\n        // Address for comparing tag\n        port.icReadAddrIn = ToPhyAddrFromLogical(fetchAddrOut);\n\n\n        // Send information about this stage to the previous stage for\n        // deciding the next fetch address\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            port.fetchStageIsValid[i] = pipeReg[i].valid;\n            port.fetchStagePC[i] = pipeReg[i].pc;\n        end\n    end\n\n\n    //\n    // --- Pipeline registers\n    //\n    always_comb begin\n        for ( int i = 0; i < FETCH_WIDTH; i++ ) begin\n            if (stall || clear || port.rst || isFlushed[i]) begin\n                nextStage[i].valid = FALSE;\n            end\n            else begin\n                nextStage[i].valid = pipeReg[i].valid;\n            end\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].sid = pipeReg[i].sid;\n`endif\n            nextStage[i].pc = pipeReg[i].pc;\n            nextStage[i].brPred = regStall ? regBrPred[i] : brPred[i];\n            nextStage[i].insn = pipeReg[i].valid ? \n                port.icReadDataOut[i] : '0;\n        end\n\n        port.nextStage = nextStage;\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        // --- Debug Register\n        for ( int i = 0; i < FETCH_WIDTH; i++ ) begin\n            debug.ifReg[i].valid = pipeReg[i].valid;\n            debug.ifReg[i].sid = pipeReg[i].sid;\n            debug.ifReg[i].flush = isFlushed[i];\n            debug.ifReg[i].icMiss = FALSE;\n        end\n        // it is correct that the index of pipeReg is zero because\n        // an i-cache miss occurs at the head of the fetch group.\n        debug.ifReg[0].icMiss = beginStall && pipeReg[0].valid && !port.icReadHit[0];\n`endif\n    end\n\nendmodule : FetchStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- FetchStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\nimport FetchUnitTypes::*;\nimport MemoryMapTypes::*;\n\ninterface FetchStageIF( input logic clk, rst, rstStart );\n\n    // This Stage\n    logic  fetchStageIsValid[FETCH_WIDTH];\n    PC_Path fetchStagePC[FETCH_WIDTH];\n\n    // BTB\n    PC_Path btbOut[FETCH_WIDTH];\n    logic btbHit[FETCH_WIDTH];\n    logic readIsCondBr[FETCH_WIDTH];\n    \n    // BranchPredictor\n    logic updateBrHistory[FETCH_WIDTH];\n    logic brPredTaken[FETCH_WIDTH];\n    BranchGlobalHistoryPath brGlobalHistory[FETCH_WIDTH];\n    PHT_EntryPath phtPrevValue[FETCH_WIDTH];\n\n    // I-Cache\n    logic     icReadHit [ FETCH_WIDTH ];\n    logic     icRE;\n    InsnPath  icReadDataOut[ FETCH_WIDTH ];\n    PhyAddrPath   icReadAddrIn; // Head addr to fetch\n\n    // Pipeline register\n    PreDecodeStageRegPath nextStage[ FETCH_WIDTH ];\n\n    modport ThisStage(\n    input\n        clk,\n        rst,\n        icReadHit,\n        icReadDataOut,\n        btbOut,\n        brPredTaken,\n        brGlobalHistory,\n        phtPrevValue,\n    output\n        fetchStageIsValid,\n        fetchStagePC,\n        updateBrHistory,\n        nextStage,\n        icRE,\n        icReadAddrIn\n    );\n\n    modport NextPCStage(\n    input\n        fetchStageIsValid,\n        fetchStagePC,\n        btbOut,\n        btbHit,\n        brPredTaken\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\n\n    modport ICache(\n    input\n        icRE, // Read Enable\n        icReadAddrIn,\n    output\n        icReadHit,\n        icReadDataOut\n    );\n\n    modport BTB(\n    output\n        btbOut,\n        btbHit,\n        readIsCondBr\n    );\n\n    modport BranchPredictor(\n    input\n        updateBrHistory,\n        btbOut,\n        btbHit,\n        readIsCondBr,\n    output\n        brPredTaken,\n        brGlobalHistory,\n        phtPrevValue\n    );\n\nendinterface : FetchStageIF\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n// \n// --- Fetch unit types\n//\n\npackage FetchUnitTypes;\n\nimport MicroArchConf::*;\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\n\n//\n// BTB\n//\n\nlocalparam BTB_ENTRY_NUM = CONF_BTB_ENTRY_NUM;\n\n// Entry: 1(valid)+4(BTB_TAG_WIDTH)+13(BTB_TAG_WIDTH) = 18 bits\n// The width of a block ram is 18bits, thus the sum of these parameters is set to 18 bits.\n\n// Tag width, only lower bits are checked and the results of the BTB may incorrect.\nlocalparam BTB_TAG_WIDTH = 4;                \n\n// BTB have bits with BTB_CONTENTS_ADDR_WIDTH. The remaining address bits are made from the PC.\nlocalparam BTB_CONTENTS_ADDR_WIDTH = 13;     \n\n\nlocalparam BTB_ENTRY_NUM_BIT_WIDTH = $clog2(BTB_ENTRY_NUM);\ntypedef logic [BTB_ENTRY_NUM_BIT_WIDTH-1:0] BTB_IndexPath;\ntypedef logic [BTB_CONTENTS_ADDR_WIDTH-1:0] BTB_AddrPath;\ntypedef logic [BTB_TAG_WIDTH-1:0] BTB_TagPath;\n\n\nlocalparam BTB_QUEUE_SIZE = 32;\nlocalparam BTB_QUEUE_SIZE_BIT_WIDTH = $clog2(BTB_QUEUE_SIZE);\ntypedef logic [BTB_QUEUE_SIZE_BIT_WIDTH-1:0] BTBQueuePointerPath;\n\ntypedef struct packed // struct BTB_Entry\n{\n    logic valid;\n    logic [BTB_TAG_WIDTH-1:0] tag;\n    BTB_AddrPath data;\n    logic isCondBr;\n} BTB_Entry;\n\ntypedef struct packed // struct PhtQueueEntry\n{\n    AddrPath btbWA;            // Write Address\n    BTB_Entry btbWV;                        // result of bpred\n} BTBQueueEntry;\n\nfunction automatic BTB_IndexPath ToBTB_Index(PC_Path addr);\n    return addr[\n        BTB_ENTRY_NUM_BIT_WIDTH + INSN_ADDR_BIT_WIDTH - 1: \n        INSN_ADDR_BIT_WIDTH\n    ];\nendfunction\n\nfunction automatic BTB_TagPath ToBTB_Tag(PC_Path addr);\n    return addr[\n        BTB_ENTRY_NUM_BIT_WIDTH + INSN_ADDR_BIT_WIDTH + BTB_TAG_WIDTH - 1:\n        BTB_ENTRY_NUM_BIT_WIDTH + INSN_ADDR_BIT_WIDTH\n    ];\nendfunction\n\nfunction automatic BTB_AddrPath ToBTB_Addr(PC_Path addr);\n    return addr[\n        INSN_ADDR_BIT_WIDTH + BTB_CONTENTS_ADDR_WIDTH - 1:\n        INSN_ADDR_BIT_WIDTH\n    ];\nendfunction\n\nfunction automatic PC_Path ToRawAddrFromBTB_Addr(BTB_AddrPath addr, PC_Path pc);\n    return \n    {\n        pc[PC_WIDTH-1 : BTB_CONTENTS_ADDR_WIDTH + 2],\n        addr[BTB_CONTENTS_ADDR_WIDTH-1 : 0],\n        2'b0\n    };\nendfunction\n\n\n//\n// GShare\n//\n\nlocalparam BRANCH_GLOBAL_HISTORY_BIT_WIDTH = CONF_BRANCH_GLOBAL_HISTORY_BIT_WIDTH;\ntypedef logic [BRANCH_GLOBAL_HISTORY_BIT_WIDTH-1 : 0] BranchGlobalHistoryPath;\n\n\n//\n// PHT\n//\n\nlocalparam PHT_ENTRY_NUM = CONF_PHT_ENTRY_NUM;\nlocalparam PHT_ENTRY_NUM_BIT_WIDTH = $clog2(PHT_ENTRY_NUM);\ntypedef logic [PHT_ENTRY_NUM_BIT_WIDTH-1:0] PHT_IndexPath;\n\nlocalparam PHT_ENTRY_WIDTH = 2;\nlocalparam PHT_ENTRY_MAX = (1 << PHT_ENTRY_WIDTH) - 1;\ntypedef logic [PHT_ENTRY_WIDTH-1:0] PHT_EntryPath;\n\n\nlocalparam PHT_QUEUE_SIZE = 32;\nlocalparam PHT_QUEUE_SIZE_BIT_WIDTH = $clog2(PHT_QUEUE_SIZE);\ntypedef logic [PHT_QUEUE_SIZE_BIT_WIDTH-1:0] PhtQueuePointerPath;\n\ntypedef struct packed // struct PhtQueueEntry\n{\n    AddrPath phtWA;            // Write Address\n    PHT_EntryPath phtWV;                        // result of bpred\n} PhtQueueEntry;\n\n\n//\n// Result/prediction\n//\n\ntypedef struct packed // struct BranchResult\n{\n    PC_Path brAddr;     // The address of a executed branch.\n    PC_Path nextAddr;   // The next address of a executed branch.\n    logic execTaken;    // The execution result of a branch's direction.\n    logic predTaken;    // The prediction result of a branch's direction.\n    logic isCondBr;     // Whether this branch is conditional one or not.\n    logic mispred;      // Whether the prediction result of this branch is incorrect.\n    logic valid;        // Whether this result is valid or not.\n\n    BranchGlobalHistoryPath globalHistory;  // The global history of branches.\n    PHT_EntryPath phtPrevValue;             // PHT's counter value\n} BranchResult;\n\ntypedef struct packed // struct BranchPred\n{\n    PC_Path predAddr;            // Predicted address\n    logic predTaken;                        // result of bpred\n    \n    BranchGlobalHistoryPath globalHistory;  // The global history of branches.\n    PHT_EntryPath phtPrevValue;             // PHT's counter value\n} BranchPred;\n\nendpackage : FetchUnitTypes\n"}
{"text": "import FPUTypes::*;\n\nmodule FP32DivSqrter (\ninput\n    logic clk, rst,\n    logic [31:0] lhs,\n    logic [31:0] rhs,\n    logic is_divide,\n    logic req,\noutput\n    logic finished,\n    logic [31:0] result\n);\n\n    function automatic [2:0] srt_table;\n        input[5:0] rem;\n        input[3:0] div;\n\n        reg[5:0] th12 = div < 1 ? 6 : div < 2 ? 7 : div < 4 ? 8 : div < 5 ? 9 : div < 6 ? 10 : 11;\n        reg[5:0] th01 =               div < 2 ? 2 :                             div < 6 ?  3 :  4;\n\n             if($signed(rem) < $signed(-th12)) srt_table = -2;\n        else if($signed(rem) < $signed(-th01)) srt_table = -1;\n        else if($signed(rem) < $signed( th01)) srt_table =  0;\n        else if($signed(rem) < $signed( th12)) srt_table =  1;\n        else                                   srt_table =  2;\n    endfunction\n    function automatic [9:0] leading_zeros_count;\n        input[22:0] x;\n        for(leading_zeros_count = 0; leading_zeros_count <= 22; leading_zeros_count = leading_zeros_count + 1)\n            if(x >> (22-leading_zeros_count) != 0) break;\n    endfunction\n    typedef enum logic[1:0]\n    {\n        PHASE_FINISHED = 0,      // Division is finished. It outputs results.\n        PHASE_PREPARATION = 1,   // In preparation\n        PHASE_PROCESSING = 2,    // In processing (SRT loop)\n        PHASE_ROUNDING = 3       // In rounding & arrangement\n    } Phase;\n\n    Phase regPhase, nextPhase; \n    logic [4:0] regCounter, nextCounter;\n    FDivSqrtRegPath regData, nextData;\n    logic [31:0] regResult, nextResult;\n\n    wire       lhs_sign = lhs[31];\n    wire       rhs_sign = rhs[31];\n    wire [7:0] lhs_expo = lhs[30:23];\n    wire [7:0] rhs_expo = rhs[30:23];\n    wire[22:0] lhs_mant = lhs[22:0];\n    wire[22:0] rhs_mant = rhs[22:0];\n\n    // NaN handling\n    wire lhs_is_zero = lhs_expo == 8'h00 & lhs_mant == 0;\n    wire rhs_is_zero = rhs_expo == 8'h00 & rhs_mant == 0;\n    wire lhs_is_inf  = lhs_expo == 8'hff & lhs_mant == 0;\n    wire rhs_is_inf  = rhs_expo == 8'hff & rhs_mant == 0;\n    wire lhs_is_nan  = lhs_expo == 8'hff & lhs_mant != 0;\n    wire rhs_is_nan  = rhs_expo == 8'hff & rhs_mant != 0;\n    wire lhs_is_neg  = lhs_sign & lhs != 32'h80000000;\n    wire res_is_nan  = is_divide ? lhs_is_nan | rhs_is_nan | (lhs_is_zero & rhs_is_zero) | (lhs_is_inf & rhs_is_inf)\n                                 : lhs_is_nan | lhs_is_neg;\n    //wire[31:0]  nan  = is_divide ? lhs_is_nan ? lhs | 32'h00400000 : rhs_is_nan ? rhs | 32'h00400000 : 32'hffc00000\n    //                             : lhs_is_nan ? lhs | 32'h00400000 : 32'hffc00000; // qNaN\n    wire[31:0]   nan = 32'h7fc00000;\n\n    // Preparation\n    wire       result_sign  = is_divide & (lhs_sign ^ rhs_sign);\n    wire [9:0] v_lhs_expo   = lhs_expo == 0 ? -leading_zeros_count(lhs_mant) : { 2'b0, lhs_expo }; // virtual exponent (ignores subnormals, but is biased)\n    wire [9:0] v_rhs_expo   = rhs_expo == 0 ? -leading_zeros_count(rhs_mant) : { 2'b0, rhs_expo }; // virtual exponent (ignores subnormals, but is biased)\n    wire[23:0] v_lhs_mant = lhs_expo == 0 ? { lhs_mant, 1'b0 } << leading_zeros_count(lhs_mant) : { 1'b1, lhs_mant };\n    wire[23:0] v_rhs_mant = rhs_expo == 0 ? { rhs_mant, 1'b0 } << leading_zeros_count(rhs_mant) : { 1'b1, rhs_mant };\n\n    wire dividend_normalize = regData.v_lhs_mant < regData.v_rhs_mant;\n    wire [9:0] virtual_expo = regData.v_lhs_expo - regData.v_rhs_expo + 127 - { 8'h0, dividend_normalize }; // new biased virtual exponent (ignores subnormals)\n    wire       subnormal    = regData.is_divide & $signed(virtual_expo) <= 0;\n    wire       res_is_zero  = regData.is_divide ? $signed(virtual_expo) <= -24 | regData.res_is_zero\n                                        : regData.res_is_zero;\n\n    // The SRT loop. rem needs 27 bits. 24(mantissa)+2(x8/3,SRT)+1(sign)\n    wire[26:0] rem_0 = regData.is_divide ? dividend_normalize ? { 2'b00, regData.v_lhs_mant, 1'b0 } : { 3'b000, regData.v_lhs_mant }\n                                 : regData.v_lhs_expo[0] ? { 2'b0, regData.v_lhs_mant, 1'b0 } - 27'h1e40000 : { 1'b0, regData.v_lhs_mant, 2'b0 } - 27'h2400000; // 2 * (x - 1.375^2 or 1.5^2)\n    wire[25:0] quo_0 = regData.is_divide ? 26'h0\n                                 : regData.v_lhs_expo[0] ? 26'h1600000 : 26'h1800000; // magical initial guess: 1.375 or 1.5; this avoids SRT-table defects at ([-4.5,-4-11/36], 1.5) and ([-4,-4+1/144], 1.25)\n\n    logic [2:0] q;\n    logic [3:0] div;\n    logic [26:0] rem;\n    logic [25:0] quo;\n    always_comb begin\n        rem = regData.rem;\n        quo = regData.quo;\n        div = regData.is_divide ? { 1'b0, regData.v_rhs_mant[22:20] } : { quo[25], quo[23:21] };\n        q = srt_table( rem[26:21], div );\n        case(q)\n            3'b010: rem = regData.is_divide ? (rem << 2) - { regData.v_rhs_mant, 3'b000 }\n                                             : (rem << 2) - { quo[24:0], 2'b00 } - (27'd4 << (regCounter));\n            3'b001: rem = regData.is_divide ? (rem << 2) - { 1'b0, regData.v_rhs_mant, 2'b00 }\n                                             : (rem << 2) - { quo, 1'b0 } - (27'd1 << (regCounter));\n            3'b111: rem = regData.is_divide ? (rem << 2) + { 1'b0, regData.v_rhs_mant, 2'b00 }\n                                             : (rem << 2) + { quo, 1'b0 } - (27'd1 << (regCounter));\n            3'b110: rem = regData.is_divide ? (rem << 2) + { regData.v_rhs_mant, 3'b000 }\n                                             : (rem << 2) + { quo[24:0], 2'b00 } - (27'd4 << (regCounter));\n            default: rem = rem << 2;\n        endcase\n        quo = quo + ({ {23{q[2]}}, q } << (regCounter));\n    end\n    \n    wire[47:0] before_round = regData.subnormal ? { 1'b1, regData.quo[23:0], 23'h0 } >> -regData.virtual_expo : { regData.quo[23:0], 24'h0 };\n    wire       round_away   = before_round[24] & ( (before_round[23:0] == 0 & regData.rem == 0 & before_round[25]) | before_round[23:0] != 0 | $signed(regData.rem) > 0 ); // round nearest, ties to even\n    wire       exp_plus_one = before_round[47:25] == 23'h7fffff & round_away;\n    wire[22:0] result_mant  = before_round[47:25] + { 22'h0, round_away }; // No special treatment is required even if a overflow occurs since the answer will be 0 and it will be correct.\n    wire [7:0] result_expo  = regData.is_divide ? (subnormal ? 8'h00 : regData.virtual_expo[7:0]) + { 7'h0, exp_plus_one }\n                                                : regData.v_lhs_expo[8:1] + { 7'b0, regData.v_lhs_expo[0] } + 63;\n    wire       res_is_inf   = regData.is_divide ? $signed(regData.virtual_expo) >= 255 | regData.res_is_inf | result_expo == 8'hff\n                                                : regData.res_is_inf;\n    wire[31:0] inf          = { regData.result_sign, 8'hff, 23'h0 };\n    wire[31:0] zero         = {{ regData.is_divide ? regData.result_sign : regData.lhs_sign }, 8'h00, 23'h0 };\n\n    wire[31:0] final_result = regData.res_is_nan  ? regData.nan :\n                              regData.res_is_zero ? zero :\n                              res_is_inf  ? inf  : { regData.result_sign, result_expo, result_mant };\n    \n    always_ff @(posedge clk) begin\n        if (rst) begin\n            regPhase <= PHASE_FINISHED;\n            regCounter <= '0;\n            regData <= '0;\n            regResult <= '0; \n        end\n        else begin\n            regPhase <= nextPhase;\n            regCounter <= nextCounter;\n            regData <= nextData;\n            regResult <= nextResult; \n        end\n    end\n    always_comb begin\n        nextCounter = regCounter;\n        nextData = regData;\n        nextResult = regResult;\n        if (req && regPhase == PHASE_FINISHED) begin\n            nextData.v_lhs_expo = v_lhs_expo;\n            nextData.v_lhs_mant = v_lhs_mant;\n            nextData.v_rhs_expo = v_rhs_expo;\n            nextData.v_rhs_mant = v_rhs_mant;\n            nextData.result_sign = result_sign;\n            nextData.lhs_sign = lhs_sign;\n            nextData.is_divide = is_divide;\n            nextData.res_is_nan = res_is_nan;\n            nextData.res_is_inf = is_divide ? (lhs_is_inf | rhs_is_zero) : (!lhs_sign & lhs_is_inf);\n            nextData.res_is_zero = is_divide ? (lhs_is_zero | rhs_is_inf) : lhs_is_zero;\n            nextData.nan = nan;\n            nextPhase = PHASE_PREPARATION;\n        end\n        else if (regPhase == PHASE_PREPARATION) begin\n            nextData.virtual_expo = virtual_expo; \n            nextData.subnormal = subnormal;\n            nextData.res_is_zero = res_is_zero;\n            nextData.rem = rem_0;\n            nextData.quo = quo_0;\n            nextPhase = PHASE_PROCESSING;\n            nextCounter = regData.is_divide ? 24 : 22;\n        end\n        else if (regPhase == PHASE_PROCESSING) begin\n            nextData.rem = rem;\n            nextData.quo = quo;\n            nextCounter = regCounter - 2;\n            nextPhase = (regCounter == 0) ? PHASE_ROUNDING : PHASE_PROCESSING;\n        end\n        // Here, quo has a <1/3ULP error.\n        else if (regPhase == PHASE_ROUNDING) begin\n            nextResult = final_result;\n            nextPhase = PHASE_FINISHED;\n            nextCounter = '0;\n            nextData = '0;\n        end\n        else begin\n            nextPhase = regPhase;\n        end\n        finished = regPhase == PHASE_FINISHED;\n        result = regResult;\n    end\n\nendmodule\n\n\n\n\n\n\n\n"}
{"text": "import FPUTypes::*;\nmodule FP32PipelinedAdder #(parameter PIPELINE_DEPTH = 5) (\ninput\n    logic clk,\n    logic [31:0] lhs,\n    logic [31:0] rhs,\noutput \n    logic [31:0] result\n);\n    FAddStage1RegPath stg0Out;\n    FAddStage2RegPath stg1Out;\n    logic [31:0] stg2Out;\n\n    FAddStage0 stg0(lhs, rhs, stg0Out);\n    FAddStage1 stg1(clk, stg0Out, stg1Out);\n    FAddStage2 stg2(clk, stg1Out, stg2Out);\n\n    logic [31:0] pipeReg[PIPELINE_DEPTH - 3];\n    always_comb begin\n        if( PIPELINE_DEPTH > 3) begin\n            result = pipeReg[0];\n        end else begin\n            result = stg2Out;\n        end\n    end\n    always_ff @(posedge clk) begin\n        if (PIPELINE_DEPTH > 3) begin\n            pipeReg[PIPELINE_DEPTH-4] <= stg2Out;\n            for (int i=1; i < PIPELINE_DEPTH - 3; ++i) begin\n                pipeReg[i-1] <= pipeReg[i];\n            end\n        end\n    end\n\nendmodule\n\nmodule FAddStage0(\n    input logic [31:0] lhs,\n    input logic [31:0] rhs,\n    output FAddStage1RegPath stg0Out\n);\n\n    logic lhs_sign, rhs_sign;\n    logic [7:0] lhs_expo, rhs_expo;\n    logic [22:0] lhs_mant, rhs_mant;\n    logic lhs_is_nan, rhs_is_nan, lhs_is_inf, rhs_is_inf, res_is_nan;\n    logic [31:0] s_lhs, s_rhs;\n    logic [7:0] s_lhs_expo, s_rhs_expo, s_lhs_offs, s_rhs_offs;\n    logic [23:0] s_lhs_mant, s_rhs_mant;\n    logic swap_is_needed, prec_loss, is_subtraction;\n    logic [31:0] nan;\n\n    always_comb begin\n        {lhs_sign, lhs_expo, lhs_mant} = lhs;\n        {rhs_sign, rhs_expo, rhs_mant} = rhs;\n\n        // Nan handling\n        lhs_is_nan = lhs_expo == 8'hff & lhs_mant != 0;\n        rhs_is_nan = rhs_expo == 8'hff & rhs_mant != 0;\n        lhs_is_inf = lhs_expo == 8'hff & lhs_mant == 0;\n        rhs_is_inf = rhs_expo == 8'hff & rhs_mant == 0;\n        res_is_nan = lhs_is_nan | rhs_is_nan | (lhs_sign != rhs_sign & lhs_is_inf & rhs_is_inf);\n        //nan = lhs_is_nan ? lhs | 32'h00400000 : rhs_is_nan ? rhs | 32'h00400000: 32'hffc00000; // qNan\n        nan = 32'h7fc00000;\n\n        // Preparation\n        swap_is_needed   = lhs[30:0] < rhs[30:0];\n        is_subtraction   = lhs_sign != rhs_sign;\n        s_lhs = swap_is_needed ? rhs : lhs;\n        s_rhs = swap_is_needed ? lhs : rhs;\n        s_lhs_expo = s_lhs[30:23];\n        s_rhs_expo = s_rhs[30:23];\n        s_lhs_offs = s_lhs_expo == 0 ? 1 : s_lhs_expo;\n        s_rhs_offs = s_rhs_expo == 0 ? 1 : s_rhs_expo;\n        s_lhs_mant = { s_lhs_expo != 8'h00, s_lhs[22:0] }; // s_lhs_expo != 8'h00 is the hidden bit of a normalized number\n        s_rhs_mant = { s_rhs_expo != 8'h00, s_rhs[22:0] }; // s_rhs_expo != 8'h00 is the hidden bit of a normalized number\n        prec_loss = is_subtraction & s_lhs_expo - s_rhs_expo <= 1 & s_lhs_expo != 8'hff;\n\n        // to next stage\n        stg0Out ={{s_lhs[31], s_lhs_expo, s_lhs_offs, s_lhs_mant}, {s_rhs[31], s_rhs_expo, s_rhs_offs, s_rhs_mant}, is_subtraction, prec_loss, res_is_nan, nan};\n    end\nendmodule\n\nmodule FAddStage1(\n    input logic clk,\n    input FAddStage1RegPath stg1In,\n    output FAddStage2RegPath stg1Out\n);\n\n    function automatic logic [4:0] LeadingZeroCounter (input logic [24:0] x);\n        logic [4:0] i;\n        for (i = 0; i <= 24; i++) begin\n            if (x[24-i]) break;\n        end\n        return i;\n    endfunction\n    \n    FAddStage1RegPath pipeReg;\n    always_ff @( posedge clk ) begin\n        pipeReg <= stg1In;\n    end\n\n    FAddDataPath lhs, rhs;\n    logic is_subtraction;\n    logic prec_loss;\n    logic res_is_nan;\n    logic [31:0] nan;\n    logic [26:0] adder_lhs, adder_rhs;\n    logic large_diff;\n    logic [4:0] offs_diff;\n    logic [48:0] shifted_rhs;\n\n    logic [24:0] suber_lhs, suber_rhs, suber_result;\n    logic [4:0] lz_count;\n    always_comb begin\n        {lhs, rhs, is_subtraction, prec_loss, res_is_nan, nan} = pipeReg;\n\n        // When precision loss does not occur\n        adder_lhs   = is_subtraction ? { lhs.mant, 1'b0, 2'b0 } : { 1'b0, lhs.mant, 2'b0 };\n        large_diff  = lhs.expo - rhs.expo > 31;\n        offs_diff   = large_diff ? 31 : lhs.offs[4:0] - rhs.offs[4:0];\n        shifted_rhs = { rhs.mant, 25'h0 } >> offs_diff >> !is_subtraction;\n        adder_rhs   = { shifted_rhs[48:24], shifted_rhs[23], shifted_rhs[22:0] != 0 }; // Last 2 bits are the guard bit and the sticky bit.\n\n        // When precision loss occurs\n        suber_lhs = {lhs.mant, 1'b0};\n        suber_rhs = { rhs.mant, 1'b0 } >> (lhs.offs[0] != rhs.offs[0]); // s_lhs_offs[0] != s_rhs_offs[0] is equal to s_lhs_expo - s_rhs_expo because s_lhs_expo - s_rhs_expo <= 1.\n        suber_result = suber_lhs - suber_rhs;\n        lz_count = LeadingZeroCounter(suber_result);\n\n        // to next stage\n        stg1Out = {is_subtraction, adder_lhs, adder_rhs, lhs.sign, lhs.expo, lhs.offs, suber_result, lz_count, prec_loss, res_is_nan, nan};\n    end\nendmodule\n\nmodule FAddStage2(\n    input logic clk,\n    input FAddStage2RegPath stg2In,\n    output logic [31:0] result\n);\n    FAddStage2RegPath pipeReg;\n    always_ff @( posedge clk ) begin\n        pipeReg <= stg2In;\n    end\n\n    logic [26:0] adder_lhs, adder_rhs;\n    logic lhs_sign;\n    logic [7:0] lhs_expo, lhs_offs;\n    logic [24:0] suber_result;\n    logic [4:0] lz_count;\n    logic is_subtraction;\n    logic prec_loss;\n    logic res_is_nan;\n    logic [31:0] nan;\n    \n    logic [26:0] adder_result;\n    logic round_to_away, exp_plus_one, round_away, subnormal;\n    logic res_is_zero, res_is_inf;\n    logic [31:0] inf, zero;\n    logic [22:0] final_mant_a, final_mant_s;\n    logic [7:0] final_expo_a, final_expo_s;\n    logic [31:0] final_result_a, final_result_s;\n\n    always_comb begin\n        {is_subtraction, adder_lhs, adder_rhs, lhs_sign, lhs_expo, lhs_offs, suber_result, lz_count, prec_loss, res_is_nan, nan} = pipeReg;\n    \n        // When precision loss does not occur\n        adder_result  = is_subtraction ? adder_lhs - adder_rhs : adder_lhs + adder_rhs;\n        round_to_away = adder_result[26] ? adder_result[2] & (adder_result[3] | adder_result[1] | adder_result[0])\n                                         : adder_result[1] & (adder_result[2] |                   adder_result[0]); // round to nearest, ties to even\n        exp_plus_one  = (lhs_expo == 8'h00 & adder_result[25]) | adder_result >= 27'h3fffffe; // when the sum of two subnormal number is a normal number or a carry is generated with rounding taken into account\n\n        final_mant_a  = (adder_result[26] ? adder_result[25:3] : adder_result[24:2]) + { 22'h0, round_to_away }; // No special treatment is required even if a overflow occurs since the answer will be 0 and it will be correct.\n        final_expo_a  = lhs_expo + { 7'h0, exp_plus_one } - { 7'h0, is_subtraction }; // No overflow occurs because 2 <= s_lhs_expo <= 254.\n        res_is_inf    = lhs_expo == 8'hff | final_expo_a == 8'hff;\n        inf           = { lhs_sign, 8'hff, 23'h0 };\n        \n        final_result_a = res_is_inf ? inf : { lhs_sign, final_expo_a, final_mant_a };\n\n        // When precision loss occurs\n        round_away = suber_result[1] & suber_result[0]; // round to nearest, ties to even\n        subnormal  = { 3'b0, lz_count } >= lhs_offs;\n        \n        final_mant_s = lhs_offs == 1 ? suber_result[23:1] :\n                     subnormal       ? suber_result[22:0] << (lhs_offs-2) :\n                     lz_count == 0   ? suber_result[23:1] + { 22'h0, round_away }\n                                     : suber_result[22:0] << (lz_count-1);\n        final_expo_s = subnormal ? 0 : lhs_offs - { 3'b0, lz_count };\n        res_is_zero  = suber_result == 0;\n        zero         = 32'h00000000;\n\n        final_result_s = res_is_zero ? zero : { lhs_sign, final_expo_s, final_mant_s };\n\n        // Ouptut result\n        result = res_is_nan ? nan :\n                 prec_loss  ? final_result_s  : final_result_a;\n    end\nendmodule\n\n"}
{"text": "import FPUTypes::*;\nmodule FP32PipelinedFMA(\n    input  logic clk,\n    input  logic [31:0] mullhs,\n    input  logic [31:0] mulrhs,\n    input  logic [31:0] addend,\n    output logic [31:0] result\n);\n\n    FMAStage1RegPath stg0Out;\n    FMAStage2RegPath stg1Out;\n    FMAStage3RegPath stg2Out;\n    FMAStage4RegPath stg3Out;\n    \n    // Fused-multiply-adder (24bit*24bit<<3+76bit+sign)\n    // The multiplication result is shifted by 2 bits for the guard bit and the sticky bit.\n    // The adder is sufficient for 76 bits + 1 sign bit because |lhs*rhs<<3| ~ 2^51 is <0.5 ULP when subtracted from 2^76. Note: ULP(1-eps) = 2^-24 while ULP(1+eps) = 2^-23.\n    logic [76:0] multiplier_lhs, multiplier_rhs, multiplier_addend, fma_result;\n    logic [76:0] mlhs, mrhs, maddend;\n    logic is_subtract, is_sub;\n    always_ff @(posedge clk) begin\n        multiplier_lhs    <= mlhs;\n        multiplier_rhs    <= mrhs;\n        multiplier_addend <= maddend;\n        is_subtract <= is_sub;\n        fma_result <= is_subtract ? multiplier_lhs * multiplier_rhs - multiplier_addend\n                                  : multiplier_lhs * multiplier_rhs + multiplier_addend;\n    end\n\n    FMAStage0 stg0(clk, stg0Out, mullhs, mulrhs, addend, is_sub, mlhs, mrhs, maddend);\n    FMAStage1 stg1(clk, stg0Out, stg1Out);\n    FMAStage2 stg2(clk, stg1Out, stg2Out, fma_result);\n    FMAStage3 stg3(clk, stg2Out, stg3Out);\n    FMAStage4 stg4(clk, stg3Out, result);\nendmodule\n\nmodule FMAStage0(\n    input logic clk,\n    output FMAStage1RegPath stg0Out,\n    input logic [31:0] mullhs,\n    input logic [31:0] mulrhs,\n    input logic [31:0] addend,\n    output logic is_subtract,\n    output logic [76:0] mlhs,\n    output logic [76:0] mrhs,\n    output logic [76:0] maddend\n);\n    wire       mullhs_sign = mullhs[31];\n    wire       mulrhs_sign = mulrhs[31];\n    wire       addend_sign = addend[31];\n    wire [7:0] mullhs_expo = mullhs[30:23];\n    wire [7:0] mulrhs_expo = mulrhs[30:23];\n    wire [7:0] addend_expo = addend[30:23];\n    wire[22:0] mullhs_mant = mullhs[22:0];\n    wire[22:0] mulrhs_mant = mulrhs[22:0];\n    wire[22:0] addend_mant = addend[22:0];\n    assign is_subtract = mullhs_sign ^ mulrhs_sign ^ addend_sign;\n\n    // NaN handling\n    wire mullhs_is_zero = mullhs_expo == 8'h00 & mullhs_mant == 0;\n    wire mulrhs_is_zero = mulrhs_expo == 8'h00 & mulrhs_mant == 0;\n    wire addend_is_zero = addend_expo == 8'h00 & addend_mant == 0;\n    wire mullhs_is_inf  = mullhs_expo == 8'hff & mullhs_mant == 0;\n    wire mulrhs_is_inf  = mulrhs_expo == 8'hff & mulrhs_mant == 0;\n    wire addend_is_inf  = addend_expo == 8'hff & addend_mant == 0;\n    wire mullhs_is_nan  = mullhs_expo == 8'hff & mullhs_mant != 0;\n    wire mulrhs_is_nan  = mulrhs_expo == 8'hff & mulrhs_mant != 0;\n    wire addend_is_nan  = addend_expo == 8'hff & addend_mant != 0;\n    wire result_is_nan  = mullhs_is_nan | mulrhs_is_nan | addend_is_nan // One of the input is NaN\n                          | (mullhs_is_zero & mulrhs_is_inf) | (mullhs_is_inf & mulrhs_is_zero) // Inf * Zero\n                          | (is_subtract & (mullhs_is_inf | mulrhs_is_inf) & addend_is_inf); // Inf - Inf\n    //wire[31:0]      nan = mullhs_is_nan ? mullhs | 32'h00400000 : mulrhs_is_nan ? mulrhs | 32'h00400000 : addend_is_nan ? addend | 32'h00400000 : 32'hffc00000; // qNan\n    wire[31:0]      nan = 32'h7fc00000;\n\n    // Inf handling\n    wire result_is_inf  = addend_is_inf | mullhs_is_inf | mulrhs_is_inf;\n    wire prop_inf_sign  = addend_is_inf ? addend_sign : mullhs_sign ^ mulrhs_sign;\n    wire mul_sign       = mullhs_sign ^ mulrhs_sign;\n\n    wire [9:0] v_mullhs_expo = { 2'b0, mullhs_expo == 8'h00 ? 8'h01 : mullhs_expo };\n    wire [9:0] v_mulrhs_expo = { 2'b0, mulrhs_expo == 8'h00 ? 8'h01 : mulrhs_expo };\n    wire [9:0] v_addend_expo = { 2'b0, addend_expo == 8'h00 ? 8'h01 : addend_expo };\n    wire [9:0] mulres_expo   = v_mullhs_expo + v_mulrhs_expo - 127;\n    wire [9:0] addend_shift  = v_addend_expo - mulres_expo + 23;\n    wire       res_is_addend = ($signed(addend_shift) > 49 | mullhs_is_zero | mulrhs_is_zero) & !addend_is_zero; // |lhs*rhs| < 0.5ULP(|addend|-eps); assuming round to nearest, result is equal to the addend.\n    wire       addend_sticky = $signed(addend_shift) >=  0 ? 1'b0 :\n                               $signed(addend_shift) < -26 ? { addend_expo != 8'h00, addend_mant } != 0\n                                                           : { addend_expo != 8'h00, addend_mant } << (10'd26 + addend_shift) != 24'h000000; // shifted out part of { mantissa(24bit), guard(1bit), round(1bit) } >> -addend_shift\n    assign maddend = { 1'b0, { addend_expo != 8'h00, addend_mant, 2'b00, 49'b0 } >> (10'd49 - addend_shift), addend_sticky }; // The 1'b0 is the sign bit. The 2'b0 are the gaurd bit and the round bit.\n    assign mlhs    = { 51'b0, mullhs_expo != 8'h00, mullhs_mant, 2'b0 }; // lhs_expo != 8'h00 is the hidden bit of a normalized number\n    assign mrhs    = { 52'b0, mulrhs_expo != 8'h00, mulrhs_mant, 1'b0 }; // rhs_expo != 8'h00 is the hidden bit of a normalized number\n\n    assign stg0Out = {mulres_expo, result_is_inf, result_is_nan,\n                      res_is_addend, mul_sign, prop_inf_sign, addend_sign, is_subtract, nan, addend};\nendmodule\n\nmodule FMAStage1(\n    input logic clk,\n    input FMAStage1RegPath stg1In,\n    output FMAStage2RegPath stg1Out\n);\n    FMAStage1RegPath pipeReg;\n    always_ff @(posedge clk) begin\n        pipeReg <= stg1In; \n    end\n    assign stg1Out = pipeReg;\nendmodule\n\nmodule FMAStage2(\n    input logic clk,\n    input FMAStage2RegPath stg2In,\n    output FMAStage3RegPath stg2Out,\n    input logic [76:0] fma_result\n);\n    FMAStage2RegPath pipeReg;\n    always_ff @(posedge clk) begin\n        pipeReg <= stg2In; \n    end\n\n    wire       mul_sign   = pipeReg.mul_sign;\n    wire       res_is_zero     = fma_result == 77'h0;\n    wire       res_is_negative = fma_result[76];\n    wire[75:0] abs_fma_result  = res_is_negative ? -fma_result[75:0] : fma_result[75:0];\n    wire       result_sign     = mul_sign ^ res_is_negative;\n    \n    assign stg2Out = {abs_fma_result, pipeReg.mulres_expo, res_is_negative, pipeReg.result_is_inf,\n                      pipeReg.result_is_nan, res_is_zero, pipeReg.res_is_addend, result_sign,\n                      pipeReg.prop_inf_sign, pipeReg.addend_sign, pipeReg.is_subtract, pipeReg.nan, pipeReg.addend};\nendmodule\n\nmodule FMAStage3(\n    input logic clk,\n    input FMAStage3RegPath stg3In,\n    output FMAStage4RegPath stg3Out\n);\n    function automatic [6:0] leading_zeros_count;\n        input[75:0] x;\n        for(leading_zeros_count = 0; leading_zeros_count <= 75; leading_zeros_count = leading_zeros_count + 1)\n            if(x[75-leading_zeros_count]) break;\n    endfunction\n    \n    FMAStage3RegPath pipeReg;\n    always_ff @(posedge clk) begin\n        pipeReg <= stg3In; \n    end\n    wire[75:0] abs_fma_result  = pipeReg.abs_fma_result;\n    wire [9:0] mulres_expo     = pipeReg.mulres_expo;\n\n    wire [7:0] leading_zeros   = { 1'b0, leading_zeros_count(abs_fma_result) }; // 0 <= leading_sign_bits <= 74 if !res_is_zero\n    wire [9:0] virtual_expo    = mulres_expo - { 2'b00, leading_zeros } + 26; // There are 26 bits above lhs*rhs<<3, assuming no carryover occurs in lhs*rhs.\n    wire       subnormal       = $signed(virtual_expo) <= 0;\n    wire [7:0] fmares_shift    = subnormal ? 26 - mulres_expo[7:0] // There are 3 bits below lhs*rhs<<3, and 23 bits will be lost due to rounding, assuming no carryover occurs in lhs*rhs.\n                                           : 51 - leading_zeros;   // (75 - addend_sticky(1bit)) - shifter_result(24bit)\n    \n    assign stg3Out = {abs_fma_result, fmares_shift, virtual_expo, subnormal, pipeReg.res_is_negative, pipeReg.result_is_inf,\n                      pipeReg.result_is_nan, pipeReg.res_is_zero, pipeReg.res_is_addend, pipeReg.result_sign,\n                      pipeReg.prop_inf_sign, pipeReg.addend_sign, pipeReg.is_subtract, pipeReg.nan, pipeReg.addend};\nendmodule\n\nmodule FMAStage4(\n    input logic clk,\n    input FMAStage4RegPath stg4In,\n    output logic [31:0] result\n);\n    FMAStage4RegPath pipeReg;\n    always_ff @(posedge clk) begin\n        pipeReg <= stg4In; \n    end\n    wire[75:0] abs_fma_result  = pipeReg.abs_fma_result;\n    wire [7:0] fmares_shift    = pipeReg.fmares_shift;\n    wire [9:0] virtual_expo    = pipeReg.virtual_expo;\n    wire[31:0] nan             = pipeReg.nan;\n    wire[31:0] addend          = pipeReg.addend;\n    wire res_is_negative       = pipeReg.res_is_negative;\n    wire result_is_inf         = pipeReg.result_is_inf;\n    wire result_is_nan         = pipeReg.result_is_nan;\n    wire res_is_zero           = pipeReg.res_is_zero;\n    wire res_is_addend         = pipeReg.res_is_addend;\n    wire result_sign           = pipeReg.result_sign;\n    wire prop_inf_sign         = pipeReg.prop_inf_sign;\n    wire addend_sign           = pipeReg.addend_sign;\n    wire subnormal             = pipeReg.subnormal;\n    wire is_subtract           = pipeReg.is_subtract;\n    \n    /* verilator lint_off WIDTH */\n    wire[23:0] shifter_result = { abs_fma_result, 23'b0 } >> (7'd23 + fmares_shift);\n    /* verilator lint_on WIDTH */\n    wire       sticky         = abs_fma_result << (76 - fmares_shift) != 0; // the part shifted out above\n\n    wire       round_to_away  = shifter_result[0] & (shifter_result[1] | sticky); // round to nearest, ties to even\n    wire       exp_plus_one   = shifter_result >= 24'hffffff; // carry is generated with rounding taken into account\n\n    wire[22:0] result_mant  = shifter_result[23:1] + { 22'h0, round_to_away }; // No special treatment is required even if a overflow occurs since the answer will be 0 and it will be correct.\n    wire [7:0] result_expo  = (subnormal ? 8'h00 : virtual_expo[7:0]) + { 7'b0, exp_plus_one };\n    wire       res_is_inf   = result_is_inf | $signed(virtual_expo) >= 255;\n    wire[31:0] inf          = { result_is_inf ? prop_inf_sign : result_sign, 8'hff, 23'h0 };\n    wire[31:0] zero         = { is_subtract ? 1'b0 : addend_sign, 8'h00, 23'h0 };\n\n    wire[31:0] final_result = res_is_inf    ? inf    :\n                              res_is_addend ? addend :\n                              res_is_zero   ? zero   : { result_sign, result_expo, result_mant };\n    assign result = result_is_nan ? nan : final_result;\nendmodule\n"}
{"text": "module FP32PipelinedFMAer #(parameter PIPELINE_DEPTH = 5)(\ninput\n    logic clk,\n    logic [31:0] mullhs,\n    logic [31:0] mulrhs,\n    logic [31:0] addend,\n    FPU_Code fpuCode,\n    Rounding_Mode rm,\noutput \n    logic [31:0] result\n);\nassign result = 32'h98765432;\nendmodule\n"}
{"text": "import FPUTypes::*;\nmodule FP32PipelinedMultiplier #(parameter PIPELINE_DEPTH = 5) (\ninput\n    logic clk,\n    logic [31:0] lhs,\n    logic [31:0] rhs,\noutput\n    logic [31:0] result\n);\n\n    FMulStage1RegPath stg0Out;\n    FMulStage2RegPath stg1Out;\n    logic [31:0] stg2Out;\n\n    FMulStage0 stg0(lhs, rhs, stg0Out);\n    FMulStage1 stg1(clk, stg0Out, stg1Out);\n    FMulStage2 stg2(clk, stg1Out, stg2Out);\n    \n    logic [31:0] pipeReg[PIPELINE_DEPTH - 3];\n    always_comb begin\n        if( PIPELINE_DEPTH > 3) begin\n            result = pipeReg[0];\n        end else begin\n            result = stg2Out;\n        end\n    end\n    always_ff @(posedge clk) begin\n        if (PIPELINE_DEPTH > 3) begin\n            pipeReg[PIPELINE_DEPTH-4] <= stg2Out;\n            for (int i=1; i < PIPELINE_DEPTH - 3; ++i) begin\n                pipeReg[i-1] <= pipeReg[i];\n            end\n        end\n    end\nendmodule\n\nmodule FMulStage0(\n    input logic [31:0] lhs,\n    input logic [31:0] rhs,\n    output FMulStage1RegPath stg0Out\n);\n    function automatic [9:0] leading_zeros_count;\n        input[22:0] x;\n        for(leading_zeros_count = 0; leading_zeros_count <= 22; leading_zeros_count = leading_zeros_count + 1)\n            if(x >> (22-leading_zeros_count) != 0) break;\n    endfunction\n\n    wire lhs_sign = lhs[31];\n    wire rhs_sign = rhs[31];\n    wire [7:0] lhs_expo = lhs[30:23];\n    wire [7:0] rhs_expo = rhs[30:23];\n    wire[22:0] lhs_mant = lhs[22:0];\n    wire[22:0] rhs_mant = rhs[22:0];\n\n    // NaN handling\n    wire lhs_is_zero = lhs_expo == 8'h00 & lhs_mant == 0;\n    wire rhs_is_zero = rhs_expo == 8'h00 & rhs_mant == 0;\n    wire lhs_is_inf  = lhs_expo == 8'hff & lhs_mant == 0;\n    wire rhs_is_inf  = rhs_expo == 8'hff & rhs_mant == 0;\n    wire lhs_is_nan  = lhs_expo == 8'hff & lhs_mant != 0;\n    wire rhs_is_nan  = rhs_expo == 8'hff & rhs_mant != 0;\n    wire res_is_nan  = lhs_is_nan | rhs_is_nan | (lhs_is_zero & rhs_is_inf) | (lhs_is_inf & rhs_is_zero);\n    //wire[31:0]  nan  = lhs_is_nan ? lhs | 32'h00400000 : rhs_is_nan ? rhs | 32'h00400000 : 32'hffc00000; // qNan\n    wire[31:0]   nan = 32'h7fc00000;  \n    \n    // Preparation\n    wire       result_sign  = lhs_sign ^ rhs_sign;\n    wire [9:0] v_lhs_expo   = lhs_expo == 0 ? -leading_zeros_count(lhs_mant) : { 2'b0, lhs_expo }; // virtual exponent (ignores subnormals, but is biased)\n    wire [9:0] v_rhs_expo   = rhs_expo == 0 ? -leading_zeros_count(rhs_mant) : { 2'b0, rhs_expo }; // virtual exponent (ignores subnormals, but is biased)\n    wire [9:0] virtual_expo = v_lhs_expo + v_rhs_expo - 127; // new biased exponent (ignores subnormals)\n    wire       subnormal    = $signed(virtual_expo) <= 0;\n    wire       res_is_zero  = $signed(virtual_expo) <= -25 | lhs_is_zero | rhs_is_zero;\n    wire       res_is_inf   = $signed(virtual_expo) >= 255 | lhs_is_inf | rhs_is_inf;\n\n    assign stg0Out = {{lhs_expo, v_lhs_expo, lhs_mant}, {rhs_expo, v_rhs_expo, rhs_mant}, virtual_expo, result_sign, subnormal, res_is_zero, res_is_nan, res_is_inf, nan};\n\nendmodule\n\nmodule FMulStage1(\n    input clk,\n    input FMulStage1RegPath stg1In,\n    output FMulStage2RegPath stg1Out\n);\n    FMulStage1RegPath pipeReg;\n    always_ff @(posedge clk) begin\n        pipeReg <= stg1In; \n    end\n\n    wire [7:0] lhs_expo, rhs_expo;\n    wire [9:0] v_lhs_expo, v_rhs_expo;\n    wire[22:0] lhs_mant, rhs_mant;\n    assign {lhs_expo, v_lhs_expo, lhs_mant} = pipeReg.lhs;\n    assign {rhs_expo, v_rhs_expo, rhs_mant} = pipeReg.rhs;\n    wire [9:0] virtual_expo = pipeReg.virtual_expo;\n    wire result_sign = pipeReg.result_sign;\n    wire subnormal = pipeReg.subnormal;\n    wire res_is_zero = pipeReg.res_is_zero;\n    wire res_is_nan = pipeReg.res_is_nan;\n    wire res_is_inf = pipeReg.res_is_inf;\n    wire [31:0] nan = pipeReg.nan;\n\n    // Determine shift amount\n    wire       generate_subnormal  =  subnormal &  lhs_expo != 0 & rhs_expo != 0 ; // normal * normal -> subnormal\n    wire       remaining_subnormal =  subnormal & (lhs_expo == 0 | rhs_expo == 0); // subnormal * normal -> subnormal\n    wire       escape_subnormal    = !subnormal & (lhs_expo == 0 | rhs_expo == 0); // subnormal * normal -> normal\n    /* verilator lint_off WIDTH */\n    wire [5:0] generate_subnormal_shift  = -virtual_expo; // right shift\n    wire [5:0] remaining_subnormal_shift = lhs_expo == 0 ? 126 - rhs_expo : 126 - lhs_expo; // right shift\n    wire [5:0] escape_subnormal_shift    = lhs_expo == 0 ? 1 - v_lhs_expo : 1 - v_rhs_expo; // left shift\n    /* verilator lint_on WIDTH */\n    wire [5:0] subnormal_shift = generate_subnormal  ? 23 + generate_subnormal_shift :\n                                 remaining_subnormal ? 23 + remaining_subnormal_shift :\n                                 escape_subnormal    ? 23 - escape_subnormal_shift\n                                                     : 23 ;\n\n    // Multiplier\n    wire[47:0] multiplier_lhs    = { 24'h0, lhs_expo != 8'h00, lhs_mant }; // lhs_expo != 8'h00 is the hidden bit of a normalized number\n    wire[47:0] multiplier_rhs    = { 24'h0, rhs_expo != 8'h00, rhs_mant }; // rhs_expo != 8'h00 is the hidden bit of a normalized number\n    wire[47:0] multiplier_result = multiplier_lhs * multiplier_rhs;\n\n    assign stg1Out = {multiplier_result, subnormal_shift, virtual_expo, result_sign, subnormal, res_is_zero, res_is_nan, res_is_inf, nan};\n\nendmodule\n\nmodule FMulStage2(\n    input clk,\n    input FMulStage2RegPath stg2In,\n    output logic [31:0] result\n);\n\n    FMulStage2RegPath pipeReg;\n    always_ff @(posedge clk) begin\n        pipeReg <= stg2In; \n    end\n\n    wire[47:0] multiplier_result = pipeReg.multiplier_result;\n    wire [5:0] subnormal_shift = pipeReg.subnormal_shift;\n    wire [9:0] virtual_expo = pipeReg.virtual_expo;\n    wire result_sign = pipeReg.result_sign;\n    wire subnormal = pipeReg.subnormal;\n    wire res_is_zero = pipeReg.res_is_zero;\n    wire res_is_nan = pipeReg.res_is_nan;\n    wire res_is_inf = pipeReg.res_is_inf;\n    wire [31:0] nan = pipeReg.nan;\n\n    /* verilator lint_off WIDTH */\n    wire[25:0] shifter_result = { multiplier_result, 1'b0 } >> subnormal_shift;\n    /* verilator lint_on WIDTH */\n    wire       sticky         = multiplier_result << (49 - subnormal_shift) != 0; // the part shifted out above\n    wire       round_to_away  = subnormal | shifter_result[25] ? shifter_result[1] & (shifter_result[2] | shifter_result[0] | sticky)\n                                                               : shifter_result[0] & (shifter_result[1] |                     sticky); // round to nearest, ties to even\n    wire       exp_plus_one   = subnormal ? shifter_result >= 26'h1fffffe\n                                          : shifter_result >= 26'h1ffffff; // carry is generated with rounding taken into account\n\n    wire[22:0] result_mant   = (subnormal | shifter_result[25] ? shifter_result[24:2] : shifter_result[23:1]) + { 22'h0, round_to_away };\n    wire [7:0] result_expo   = subnormal ? { 7'h0, exp_plus_one } : virtual_expo[7:0] + { 7'h0, exp_plus_one };\n    wire[31:0] inf           = { result_sign, 8'hff, 23'h0 };\n    wire[31:0] zero          = { result_sign, 8'h00, 23'h0 };\n\n    wire[31:0] final_result  = res_is_zero ? zero :\n                               (res_is_inf | result_expo == 8'hff)  ? inf  : { result_sign, result_expo, result_mant };\n    assign result = res_is_nan ? nan : final_result;\n\nendmodule\n"}
{"text": "import OpFormatTypes::*;\nimport BasicTypes::*;\n\nfunction automatic [5:0] leading_zeros_count(\n    input logic [31:0] x\n);\n    for(leading_zeros_count = 0; leading_zeros_count <= 31; leading_zeros_count = leading_zeros_count + 1)\n        if(x >> (31-leading_zeros_count) != 0) break;\nendfunction\n\nfunction automatic void FP32CVT_I2F(\ninput\n    logic [31:0] lhs,\n    logic fmt_unsigned,\n    Rounding_Mode rm,\noutput\n    logic [31:0] result,\n    FFlags_Path fflags\n);\n    logic is_exact, is_valid, lhs_is_neg;\n    logic [5:0] lzc;\n    logic [31:0] abs_lhs, shifted_lhs; // hidden 1(1) + mantissa(23) + lower_bits(8)\n    logic [7:0]  expo;\n    logic [22:0] mant;\n    logic round_up, exp_plus_one;\n    logic lsb, guard, sticky;\n    lhs_is_neg =  ~fmt_unsigned & lhs[31];\n    abs_lhs = lhs_is_neg ? -lhs : lhs;\n    lzc = leading_zeros_count(abs_lhs);\n    shifted_lhs = abs_lhs << lzc;\n    mant = shifted_lhs[30:8];\n    expo = (abs_lhs == '0) ? 0 : 8'd127 + 8'd31 - lzc;\n    {lsb, guard, sticky} = {shifted_lhs[8:7], |shifted_lhs[6:0]};\n    case (rm)\n        RM_RNE:  round_up = guard & (lsb | sticky);\n        RM_RTZ:  round_up = FALSE;\n        RM_RDN:  round_up = (guard | sticky) & lhs_is_neg;\n        RM_RUP:  round_up = (guard | sticky) & ~lhs_is_neg;\n        RM_RMM:  round_up = guard;\n        default: round_up = FALSE; // RTZ\n    endcase\n    exp_plus_one = round_up & (&mant); // 1.111111.. + round_up\n    expo = expo + {7'h0, exp_plus_one};\n    mant = mant + {22'h0, round_up};\n    result = {lhs_is_neg, expo, mant};\n\n    // fflag update\n    fflags = '0;\n    if (guard | sticky) begin\n        fflags.NX = TRUE;\n    end\nendfunction\n\nfunction automatic void FP32CVT_F2I(\ninput\n    logic [31:0] lhs,\n    logic fmt_unsigned,\n    Rounding_Mode rm,\noutput\n    logic [31:0] result,\n    FFlags_Path fflags\n);\n    logic sign;\n    logic [7:0] expo;\n    logic [22:0] mant;\n    logic [4:0] shift_amount;\n    logic [31:0] int_result, abs_result;\n    logic [22:0] lower_bits;\n    logic round_up;\n    logic lsb, guard, sticky;\n    logic is_invalid, lhs_is_neg, lhs_is_nan;\n    \n    {sign, expo, mant} = lhs;\n    /* verilator lint_off WIDTH */\n    shift_amount = 158 - expo;\n    /* verilator lint_on WIDTH */\n    lhs_is_neg = sign;\n    lhs_is_nan = expo == 8'hff & mant != 0;\n    if (expo <= 126) begin // e < 0\n        int_result = 0;\n        lsb = 0;\n        guard = (expo == 126) ? 1 : 0;\n        sticky = (expo == 0 || expo == 126) ? |mant : 1;\n    end\n    else if (expo <= 157) begin // 0 <= e <= 30\n        {int_result, lower_bits} = {1'b1, mant, 31'h0} >> shift_amount;\n        lsb = int_result[0];\n        {guard, sticky} = {lower_bits[22], |lower_bits[21:0]};\n    end\n    else if (expo == 158) begin // e = 31\n        if (fmt_unsigned) begin\n            int_result = lhs_is_neg ? 32'h00000000 : {1'b1, mant, 8'h0};\n        end \n        else begin\n            int_result = lhs_is_neg ? 32'h80000000 : 32'h7fffffff;\n        end\n    end\n    else begin // e > 31(overflow)\n        if(fmt_unsigned) begin\n            int_result = (~lhs_is_nan & lhs_is_neg) ? 32'h00000000 : 32'hffffffff;\n        end\n        else begin\n            int_result = (~lhs_is_nan & lhs_is_neg) ? 32'h80000000 : 32'h7fffffff;\n        end\n    end\n    // rounding\n    case (rm)\n            RM_RNE:  round_up = guard & (lsb | sticky);\n            RM_RTZ:  round_up = FALSE;\n            RM_RDN:  round_up = (guard | sticky) & lhs_is_neg;\n            RM_RUP:  round_up = (guard | sticky) & ~lhs_is_neg;\n            RM_RMM:  round_up = guard;\n            default: round_up = FALSE; // RTZ\n    endcase\n    if (expo <= 157) begin\n        int_result = int_result + {31'h0, round_up};\n        result = lhs_is_neg ? (fmt_unsigned ? 32'h0 : -int_result): int_result;\n    end\n    else begin\n        //result = (fmt_unsigned & lhs_is_neg & ~lhs_is_nan) ? 32'h0 : int_result;\n        result = int_result;\n    end\n\n    fflags = '0;\n    // fflag update\n    is_invalid =  expo >= 159 |  // overflow or nan/inf\n                (~fmt_unsigned & expo == 158 & (~lhs_is_neg | (lhs_is_neg & mant != 0))) |  // overflow in signed conversino\n                (fmt_unsigned & lhs_is_neg & (expo >= 127 | round_up));                     // rounded result is negative in unsigned conversion\n    if (is_invalid) begin\n        fflags.NV = TRUE;\n    end\n    else if (guard | sticky) begin\n        fflags.NX = TRUE;\n    end\nendfunction\n\nmodule FP32PipelinedOther #(parameter PIPELINE_DEPTH = 5)(\ninput\n    logic clk,\n    logic [31:0] lhs,\n    logic [31:0] rhs,\n    FPU_Code fpuCode,\n    Rounding_Mode rm,\noutput \n    logic [31:0] result,\n    FFlags_Path fflags\n);\n    logic [31:0] resultOut;\n    FFlags_Path fflagsOut;\n\n    typedef struct packed {\n        logic [31:0] result;\n        FFlags_Path fflags; \n    } PipeRegPath;\n    PipeRegPath pipeReg[PIPELINE_DEPTH - 1];\n\n    // just a buffer\n    always_comb begin\n        if( PIPELINE_DEPTH > 1) begin\n            {result, fflags} = pipeReg[0];\n        end else begin\n            {result, fflags} = {resultOut, fflagsOut};\n        end\n    end\n    always_ff @(posedge clk) begin\n        if (PIPELINE_DEPTH > 1) begin\n            pipeReg[PIPELINE_DEPTH-2] <= {resultOut, fflagsOut};\n            for (int i=1; i < PIPELINE_DEPTH - 1; ++i) begin\n                pipeReg[i-1] <= pipeReg[i];\n            end\n        end\n    end\n\n    // exec unit\n    logic lhs_sign, rhs_sign;\n    logic [7:0] lhs_expo, rhs_expo;\n    logic [22:0] lhs_mant, rhs_mant;\n    logic lhs_is_zero, rhs_is_zero, lhs_is_inf, rhs_is_inf, lhs_is_nan, rhs_is_nan;\n    logic lhs_is_snan, rhs_is_snan, lhs_is_subnormal, lhs_is_normal;\n    logic lhs_is_smaller, lhs_equal_rhs;\n    logic fmt_unsigned;\n\n\n    always_comb begin\n        {lhs_sign, lhs_expo, lhs_mant} = lhs;\n        {rhs_sign, rhs_expo, rhs_mant} = rhs;\n\n        lhs_is_zero = lhs_expo == 8'h00 & lhs_mant == 0;\n        rhs_is_zero = rhs_expo == 8'h00 & rhs_mant == 0;\n        lhs_is_inf  = lhs_expo == 8'hff & lhs_mant == 0;\n        rhs_is_inf  = rhs_expo == 8'hff & rhs_mant == 0;\n        lhs_is_nan  = lhs_expo == 8'hff & lhs_mant != 0;\n        rhs_is_nan  = rhs_expo == 8'hff & rhs_mant != 0;\n        lhs_is_snan = lhs_is_nan & lhs_mant[22] == 0;\n        rhs_is_snan = rhs_is_nan & rhs_mant[22] == 0;\n        lhs_is_subnormal = lhs_expo == 0 & lhs_mant != 0;\n        lhs_is_normal = ~(lhs_is_zero | lhs_is_inf | lhs_is_nan | lhs_is_subnormal);\n        lhs_is_smaller = (lhs < rhs) ^ ( lhs_sign | rhs_sign);\n        // +0 normally compares as equal to -0\n        lhs_equal_rhs = (lhs == rhs) | (lhs_is_zero && rhs_is_zero);\n        fmt_unsigned = fpuCode inside {FC_FCVT_SWU, FC_FCVT_WUS};\n\n        fflagsOut = '0;\n        unique case(fpuCode)\n            FC_SGNJ: begin\n                resultOut = {rhs_sign, lhs_expo, lhs_mant};\n            end\n            FC_SGNJN: begin\n                resultOut = {~rhs_sign, lhs_expo, lhs_mant};\n            end\n            FC_SGNJX: begin\n                resultOut = {lhs_sign ^ rhs_sign, lhs_expo, lhs_mant};\n            end\n            FC_FMIN: begin\n                if (lhs_is_nan & rhs_is_nan) begin\n                    resultOut = 32'h7fc00000;\n                end\n                else if (lhs_is_nan) begin\n                    resultOut = rhs;\n                end \n                else if (rhs_is_nan) begin\n                    resultOut = lhs;\n                end\n                else begin\n                    resultOut = lhs_is_smaller ? lhs : rhs;\n                end\n                // update fflags\n                if (lhs_is_snan || rhs_is_snan) begin\n                    fflagsOut.NV = TRUE;\n                end\n            end\n            FC_FMAX: begin\n                if (lhs_is_nan & rhs_is_nan) begin\n                    resultOut = 32'h7fc00000;\n                end\n                else if (lhs_is_nan) begin\n                    resultOut = rhs;\n                end \n                else if (rhs_is_nan) begin\n                    resultOut = lhs;\n                end\n                else begin\n                    resultOut = lhs_is_smaller ? rhs : lhs;\n                end\n\n                if (lhs_is_snan || rhs_is_snan) begin\n                    fflagsOut.NV = TRUE;\n                end\n            end\n            FC_FMV_WX, FC_FMV_XW: begin\n                resultOut = lhs;\n            end\n            FC_FCVT_SW, FC_FCVT_SWU: begin\n                FP32CVT_I2F(lhs, fmt_unsigned, rm, resultOut, fflagsOut);\n            end\n            FC_FCVT_WS, FC_FCVT_WUS: begin\n                FP32CVT_F2I(lhs, fmt_unsigned, rm, resultOut, fflagsOut);\n            end\n            FC_FEQ: begin\n                if (lhs_is_nan || rhs_is_nan) begin\n                    resultOut = 0;\n                end\n                else begin\n                    resultOut = lhs_equal_rhs;\n                end\n                // quiet comparsion\n                if (lhs_is_snan || rhs_is_snan) begin\n                    fflagsOut.NV = TRUE;\n                end\n            end\n            FC_FLT: begin\n                if (lhs_is_nan || rhs_is_nan) begin\n                    resultOut = 0;\n                    fflagsOut.NV = TRUE;\n                end\n                else begin\n                    //flt.s -0, +0 = 0\n                    resultOut = lhs_is_smaller & ~lhs_equal_rhs;\n                end\n            end\n            FC_FLE: begin\n                if (lhs_is_nan || rhs_is_nan) begin\n                    resultOut = 0;\n                    fflagsOut.NV = TRUE;\n                end\n                else begin\n                    resultOut = lhs_is_smaller | lhs_equal_rhs;\n                end\n            end\n            FC_FCLASS: begin\n                resultOut = {\n                    22'h0, \n                    lhs_is_nan & ~lhs_is_snan,     // quiet NaN\n                    lhs_is_snan,                   // signaling NaN\n                    ~lhs_sign & lhs_is_inf,        // +inf\n                    ~lhs_sign & lhs_is_normal,     // +subnormal\n                    ~lhs_sign & lhs_is_subnormal,  // +normal\n                    ~lhs_sign & lhs_is_zero,       // +0\n                    lhs_sign & lhs_is_zero,        // -0\n                    lhs_sign & lhs_is_subnormal,   // -subnormal\n                    lhs_sign & lhs_is_normal,      // -normal\n                    lhs_sign & lhs_is_inf          // -inf\n                };\n            end\n            default: begin\n                resultOut = '0;\n                fflagsOut = '0;\n            end\n\n        endcase\n    end\nendmodule\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n`include \"BasicMacros.sv\"\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport ActiveListIndexTypes::*;\n\nmodule FPDivSqrtUnit(FPDivSqrtUnitIF.FPDivSqrtUnit port, RecoveryManagerIF.FPDivSqrtUnit recovery);\n\n    typedef enum logic[1:0]\n    {\n        DIVIDER_PHASE_FREE       = 0,  // Divider is free\n        DIVIDER_PHASE_RESERVED   = 1,  // Divider is not processing but reserved\n        DIVIDER_PHASE_PROCESSING = 2,  // In processing\n        DIVIDER_PHASE_WAITING    = 3   // Wait for issuing div from replay queue\n    } DividerPhase;\n    DividerPhase regPhase  [FP_DIVSQRT_ISSUE_WIDTH];\n    DividerPhase nextPhase [FP_DIVSQRT_ISSUE_WIDTH];\n    logic finished[FP_DIVSQRT_ISSUE_WIDTH];\n\n    logic flush[FP_DIVSQRT_ISSUE_WIDTH];\n    ActiveListIndexPath regActiveListPtr[FP_DIVSQRT_ISSUE_WIDTH];\n    ActiveListIndexPath nextActiveListPtr[FP_DIVSQRT_ISSUE_WIDTH];\n\n    for (genvar i = 0; i < FP_DIVSQRT_ISSUE_WIDTH; i++) begin : BlockDivUnit\n        FP32DivSqrter fpDivSqrter(\n            .clk(port.clk),\n            .rst(port.rst),\n            .lhs(port.dataInA[i]),\n            .rhs(port.dataInB[i]),\n            .is_divide(port.is_divide[i]),\n            .req(port.Req[i]),\n            .finished(finished[i]),\n            .result(port.DataOut[i])\n        );\n    end\n\n    always_ff @(posedge port.clk) begin\n        if (port.rst) begin\n            for (int i = 0; i < FP_DIVSQRT_ISSUE_WIDTH; i++) begin\n                regPhase[i] <= DIVIDER_PHASE_FREE;\n                regActiveListPtr[i] <= 0;\n            end\n        end\n        else begin\n            regPhase <= nextPhase;\n            regActiveListPtr <= nextActiveListPtr;\n        end\n    end\n\n    always_comb begin\n        nextPhase = regPhase;\n        nextActiveListPtr = regActiveListPtr;\n\n        for (int i = 0; i < FP_DIVSQRT_ISSUE_WIDTH; i++) begin\n\n            case (regPhase[i])\n            default: begin\n                nextPhase[i] = DIVIDER_PHASE_FREE;\n            end\n\n            DIVIDER_PHASE_FREE: begin\n                // Reserve divider and do not issue any div after that.\n                if (port.Acquire[i]) begin\n                    nextPhase[i] = DIVIDER_PHASE_RESERVED;\n                    nextActiveListPtr[i] = port.acquireActiveListPtr[i];\n                end\n            end\n\n            DIVIDER_PHASE_RESERVED: begin\n                // Request to the divider\n                // NOT make a request when below situation\n                // 1) When any operands of inst. are invalid\n                // 2) When the divider is waiting for the instruction\n                //    to receive the result of the divider\n                if (port.Req[i]) begin\n                    // Receive the request of div, \n                    // so move to processing phase\n                    nextPhase[i] = DIVIDER_PHASE_PROCESSING;\n                end\n            end\n\n            DIVIDER_PHASE_PROCESSING: begin\n                // Div operation has finished, so we can get result from divider\n                if (finished[i]) begin\n                    nextPhase[i] = DIVIDER_PHASE_WAITING;\n                end\n            end\n\n            DIVIDER_PHASE_WAITING: begin\n                if (port.Release[i]) begin \n                    // Div\u304c\u9664\u7b97\u5668\u304b\u3089\u7d50\u679c\u3092\u53d6\u5f97\u3067\u304d\u305f\u306e\u3067\uff0c\n                    // IQ\u304b\u3089\u306ediv\u306e\u767a\u884c\u3092\u8a31\u53ef\u3059\u308b \n                    nextPhase[i] = DIVIDER_PHASE_FREE;\n                end\n            end\n            endcase // regPhase[i]\n\n            // Cancel divider allocation on pipeline flush\n            flush[i] = SelectiveFlushDetector(\n                recovery.toRecoveryPhase,\n                recovery.flushRangeHeadPtr,\n                recovery.flushRangeTailPtr,\n                recovery.flushAllInsns,\n                regActiveListPtr[i]\n            );\n\n            // \u9664\u7b97\u5668\u306b\u8981\u6c42\u3092\u3057\u305fdiv\u304c\u30d5\u30e9\u30c3\u30b7\u30e5\u3055\u308c\u305f\u306e\u3067\uff0c\u9664\u7b97\u5668\u3092\u89e3\u653e\u3059\u308b\n            if (flush[i]) begin\n                nextPhase[i] = DIVIDER_PHASE_FREE;\n            end\n\n            // \u73fe\u72b6 acquire \u304c issue \u30b9\u30c6\u30fc\u30b8\u304b\u3089\u304f\u308b\u306e\u3067\uff0c\u6b21\u306e\u30b5\u30a4\u30af\u30eb\u306e\u72b6\u614b\u3067\u30d5\u30ea\u30fc\u304b\n            // \u3069\u3046\u304b\u3092\u5224\u5b9a\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\n            port.Free[i]     = nextPhase[i] == DIVIDER_PHASE_FREE ? TRUE : FALSE;   \n            port.Finished[i] = regPhase[i] == DIVIDER_PHASE_WAITING ? TRUE : FALSE;\n            port.Busy[i]     = regPhase[i] == DIVIDER_PHASE_PROCESSING ? TRUE : FALSE;\n            port.Reserved[i] = regPhase[i] == DIVIDER_PHASE_RESERVED ? TRUE : FALSE;\n\n        end // for (int i = 0; i < FP_DIVSQRT_ISSUE_WIDTH; i++) begin\n\n    end // always_comb begin\n\n\nendmodule\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// FP Div/Sqrt Unit\n//\n\n`include \"BasicMacros.sv\"\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport ActiveListIndexTypes::*;\n\ninterface FPDivSqrtUnitIF(input logic clk, rst);\n    logic stall;\n\n    DataPath dataInA[FP_DIVSQRT_ISSUE_WIDTH];\n    DataPath dataInB[FP_DIVSQRT_ISSUE_WIDTH];\n\n    DataPath    DataOut  [FP_DIVSQRT_ISSUE_WIDTH];\n    FFlags_Path FFlagsOut[FP_DIVSQRT_ISSUE_WIDTH];\n    logic is_divide      [FP_DIVSQRT_ISSUE_WIDTH];\n    Rounding_Mode rm     [FP_DIVSQRT_ISSUE_WIDTH];\n    logic       Req      [FP_DIVSQRT_ISSUE_WIDTH];\n    logic       Reserved [FP_DIVSQRT_ISSUE_WIDTH];\n    logic       Finished [FP_DIVSQRT_ISSUE_WIDTH];\n    logic       Busy     [FP_DIVSQRT_ISSUE_WIDTH];\n    logic       Free     [FP_DIVSQRT_ISSUE_WIDTH];\n\n    logic Acquire[FP_DIVSQRT_ISSUE_WIDTH];\n    logic Release[FP_DIVSQRT_ISSUE_WIDTH];\n    ActiveListIndexPath acquireActiveListPtr[FP_DIVSQRT_ISSUE_WIDTH];\n\n    modport FPDivSqrtUnit(\n    input\n        clk,\n        rst,\n        stall,\n        dataInA,\n        dataInB,\n        is_divide,\n        rm,\n        Req,\n        Acquire,\n        Release,\n        acquireActiveListPtr,\n    output\n        DataOut,\n        FFlagsOut,\n        Finished,\n        Busy,\n        Reserved,\n        Free\n    );\n\n    modport FPIssueStage(\n    output\n        Acquire,\n        acquireActiveListPtr\n    );\n\n    modport FPExecutionStage(\n    input\n        DataOut,\n        Finished,\n        Busy,\n        Reserved,\n        Free,\n        FFlagsOut,\n    output\n        stall,\n        dataInA,\n        dataInB,\n        is_divide,\n        rm,\n        Req,\n        Release\n    );\n\n    modport Scheduler(\n    input\n        Free\n    );\n\n    modport ReplayQueue(\n    input\n        Busy\n    );\nendinterface\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// FP Execution stage\n//\n// \u6d6e\u52d5\u5c0f\u6570\u70b9\u6f14\u7b97\u306e\u5b9f\u884c\u3092\u884c\u3046\n// FP_EXEC_STAGE_DEPTH \u6bb5\u306b\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5316\u3055\u308c\u3066\u3044\u308b\n//\n\n`include \"BasicMacros.sv\"\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\n\n`ifdef RSD_MARCH_FP_PIPE\n\nmodule FPExecutionStage(\n    FPExecutionStageIF.ThisStage port,\n    FPRegisterReadStageIF.NextStage prev,\n    FPDivSqrtUnitIF.FPExecutionStage fpDivSqrtUnit,\n    SchedulerIF.FPExecutionStage scheduler,\n    BypassNetworkIF.FPExecutionStage bypass,\n    RecoveryManagerIF.FPExecutionStage recovery,\n    ControllerIF.FPExecutionStage ctrl,\n    DebugIF.FPExecutionStage debug,\n    CSR_UnitIF.FPExecutionStage csrUnit\n);\n    // Pipeline control\n    logic stall, clear;\n    logic flush[ FP_ISSUE_WIDTH ][ FP_EXEC_STAGE_DEPTH ];\n\n    `RSD_STATIC_ASSERT(FP_ISSUE_WIDTH == FP_DIVSQRT_ISSUE_WIDTH, \"These muse be same\");\n\n    //\n    // --- Local Pipeline Register\n    //\n\n    // \u8907\u6570\u30b5\u30a4\u30af\u30eb\u306b\u308f\u305f\u308b FPExecutionStage \u5185\u3067\n    // \u4f7f\u7528\u3059\u308b\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u30ec\u30b8\u30b9\u30bf\n    typedef struct packed // LocalPipeReg\n    {\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        OpId      opId;\n`endif\n\n        logic valid;  // Valid flag. If this is 0, its op is treated as NOP.\n        logic regValid; // Valid flag of a destination register.\n        FPIssueQueueEntry fpQueueData;\n    } LocalPipeReg;\n\n    LocalPipeReg localPipeReg [ FP_ISSUE_WIDTH ][ FP_EXEC_STAGE_DEPTH-1 ];\n    LocalPipeReg nextLocalPipeReg [ FP_ISSUE_WIDTH ][ FP_EXEC_STAGE_DEPTH-1 ];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < FP_ISSUE_WIDTH; i++) begin\n            for (int j = 0; j < FP_EXEC_STAGE_DEPTH-1; j++) begin\n                localPipeReg[i][j] <= '0;\n            end\n        end\n    end\n`endif\n\n    always_ff@( posedge port.clk ) begin\n        if (port.rst || clear) begin\n            for (int i = 0; i < FP_ISSUE_WIDTH; i++) begin\n                for ( int j = 0; j < FP_EXEC_STAGE_DEPTH-1; j++ ) begin\n                    localPipeReg[i][j].valid <= '0;\n                    localPipeReg[i][j].regValid <= '0;\n                end\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin   // write data\n            localPipeReg <= nextLocalPipeReg;\n        end\n    end\n\n\n    //\n    // --- Pipeline Register\n    //\n\n    // FPRegisterReadStage \u3068\u306e\u5883\u754c\u306b\u3042\u308b\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u30ec\u30b8\u30b9\u30bf\n    FPExecutionStageRegPath pipeReg[FP_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < FP_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n    always_ff@(posedge port.clk)   // synchronous rst\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < FP_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= '0;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin   // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n    //\n    // Signals\n    //\n    FPIssueQueueEntry iqData        [ FP_ISSUE_WIDTH ] [FP_EXEC_STAGE_DEPTH];\n    FPOpInfo          fpOpInfo [ FP_ISSUE_WIDTH ];\n    FPMicroOpSubType opType [FP_ISSUE_WIDTH];\n    FPU_Code fpuCode [FP_ISSUE_WIDTH];\n    Rounding_Mode rm [FP_ISSUE_WIDTH];\n    Rounding_Mode stRM [FP_ISSUE_WIDTH];\n    Rounding_Mode dynRM [FP_ISSUE_WIDTH];\n\n    PRegDataPath  fuOpA    [ FP_ISSUE_WIDTH ];\n    PRegDataPath  fuOpB    [ FP_ISSUE_WIDTH ];\n    PRegDataPath  fuOpC    [ FP_ISSUE_WIDTH ];\n    logic         regValid [ FP_ISSUE_WIDTH ];\n    PRegDataPath  dataOut  [ FP_ISSUE_WIDTH ];\n    FFlags_Path   fflagsOut[ FP_ISSUE_WIDTH ];\n\n    DataPath  addDataOut     [ FP_ISSUE_WIDTH ];\n    DataPath  mulDataOut     [ FP_ISSUE_WIDTH ];\n    DataPath  fmaDataOut     [ FP_ISSUE_WIDTH ];\n    DataPath  otherDataOut   [ FP_ISSUE_WIDTH ];\n\n    FFlags_Path   addFFlagsOut [ FP_ISSUE_WIDTH ];\n    FFlags_Path   mulFFlagsOut [ FP_ISSUE_WIDTH ];\n    FFlags_Path   fmaFFlagsOut [ FP_ISSUE_WIDTH ];\n    FFlags_Path   otherFFlagsOut [ FP_ISSUE_WIDTH ];\n\n\n\n    //\n    // Divider/Sqrt Unit\n    //\n    logic isDivSqrt         [ FP_ISSUE_WIDTH ]; \n\n    for ( genvar i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n        FP32PipelinedAdder #(\n            .PIPELINE_DEPTH(FP_EXEC_STAGE_DEPTH)\n        ) fpAdder (\n            .clk (port.clk),\n            .lhs ( fuOpA[i].data ),\n            .rhs ( fpuCode[i] == FC_SUB ? {~fuOpB[i].data[31], fuOpB[i].data[30:0]} : fuOpB[i].data ),\n            //.rm (rm[i]),\n            .result ( addDataOut[i] )\n            //.fflags ( addFFlagsOut[i])\n        );\n        \n        FP32PipelinedMultiplier #(\n            .PIPELINE_DEPTH(FP_EXEC_STAGE_DEPTH)\n        ) fpMultiplier (\n            .clk (port.clk),\n            .lhs ( fuOpA[i].data ),\n            .rhs ( fuOpB[i].data ),\n            //.rm (rm[i]),\n            .result ( mulDataOut[i] )\n            //.fflags ( mulFFlagsOut[i])\n        );\n\n        FP32PipelinedFMA fpFMA (\n            .clk (port.clk),\n            .mullhs ( fpuCode[i] inside {FC_FNMSUB, FC_FNMADD} ? {~fuOpA[i].data[31], fuOpA[i].data[30:0]} : fuOpA[i].data),\n            .mulrhs ( fuOpB[i].data ),\n            .addend ( fpuCode[i] inside {FC_FMSUB, FC_FNMADD} ? {~fuOpC[i].data[31], fuOpC[i].data[30:0]} : fuOpC[i].data ),\n            //.rm (rm[i]),\n            .result ( fmaDataOut[i] )\n            //.fflags ( fmaFFlagsOut[i])\n        );\n        \n        FP32PipelinedOther #(\n            .PIPELINE_DEPTH(FP_EXEC_STAGE_DEPTH)\n        ) fpOther (\n            .clk (port.clk),\n            .lhs ( fuOpA[i].data ),\n            .rhs ( fuOpB[i].data ),\n            .fpuCode (fpuCode[i]),\n            .rm (rm[i]),\n            .result ( otherDataOut[i] ),\n            .fflags ( otherFFlagsOut[i])\n        );\n    end\n\n    always_comb begin\n        // FP Div/Sqrt Unit\n        for (int i = 0; i < FP_ISSUE_WIDTH; i++) begin\n\n            fpDivSqrtUnit.dataInA[i] = fuOpA[i].data;\n            fpDivSqrtUnit.dataInB[i] = fuOpB[i].data;\n\n            // DIV or SQRT\n            fpDivSqrtUnit.is_divide[i] = fpOpInfo[i].fpuCode == FC_DIV;\n            fpDivSqrtUnit.rm[i] = rm[i];\n\n            isDivSqrt[i] =  \n                pipeReg[i].fpQueueData.fpOpInfo.opType inside {FP_MOP_TYPE_DIV, FP_MOP_TYPE_SQRT};\n\n            // Request to the divider/sqrter\n            // NOT make a request when below situation\n            // 1) When any operands of inst. are invalid\n            // 2) When the divider/sqrter is waiting for the instruction\n            //    to receive the result of the divider/sqrter\n            fpDivSqrtUnit.Req[i] = \n                fpDivSqrtUnit.Reserved[i] && \n                pipeReg[i].valid && isDivSqrt[i] && \n                fuOpA[i].valid && fuOpB[i].valid;\n\n            if (fpDivSqrtUnit.Finished[i] &&\n                localPipeReg[i][FP_EXEC_STAGE_DEPTH-2].valid &&\n                (localPipeReg[i][FP_EXEC_STAGE_DEPTH-2].fpQueueData.fpOpInfo.opType inside {FP_MOP_TYPE_DIV, FP_MOP_TYPE_SQRT})&& \n                localPipeReg[i][FP_EXEC_STAGE_DEPTH-2].regValid\n            ) begin \n                // Div/Sqrt Unit\u304b\u3089\u7d50\u679c\u3092\u53d6\u5f97\u3067\u304d\u305f\u306e\u3067\uff0c\n                // IQ\u304b\u3089\u306e\u767a\u884c\u3092\u8a31\u53ef\u3059\u308b \n                fpDivSqrtUnit.Release[i] = TRUE;\n            end\n            else begin\n                fpDivSqrtUnit.Release[i] = FALSE;\n            end\n        end\n    end\n\n    always_comb begin\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n            iqData[i][0] = pipeReg[i].fpQueueData;\n            fpOpInfo[i]  = pipeReg[i].fpQueueData.fpOpInfo;\n            opType[i]    = fpOpInfo[i].opType;\n            fpuCode[i]   = fpOpInfo[i].fpuCode;\n            stRM[i]      = fpOpInfo[i].rm;\n            dynRM[i]     = csrUnit.frm;\n            if (stRM[i] == RM_DYN) begin\n                rm[i] = dynRM[i];\n            end\n            else begin\n                rm[i] = stRM[i];\n            end\n            \n\n            flush[i][0] = SelectiveFlushDetector(\n                recovery.toRecoveryPhase,\n                recovery.flushRangeHeadPtr,\n                recovery.flushRangeTailPtr,\n                recovery.flushAllInsns, \n                pipeReg[i].fpQueueData.activeListPtr\n            );\n\n            // From local pipeline \n            for (int j = 1; j < FP_EXEC_STAGE_DEPTH; j++) begin \n                iqData[i][j] = localPipeReg[i][j-1].fpQueueData; \n                flush[i][j] = SelectiveFlushDetector( \n                    recovery.toRecoveryPhase, \n                    recovery.flushRangeHeadPtr, \n                    recovery.flushRangeTailPtr, \n                    recovery.flushAllInsns, \n                    localPipeReg[i][j-1].fpQueueData.activeListPtr \n                );\n            end\n\n            // \u30aa\u30da\u30e9\u30f3\u30c9\n            fuOpA[i] = ( pipeReg[i].bCtrl.rA.valid ? bypass.fpSrcRegDataOutA[i] : pipeReg[i].operandA );\n            fuOpB[i] = ( pipeReg[i].bCtrl.rB.valid ? bypass.fpSrcRegDataOutB[i] : pipeReg[i].operandB );\n            fuOpC[i] = ( pipeReg[i].bCtrl.rC.valid ? bypass.fpSrcRegDataOutC[i] : pipeReg[i].operandC );\n           \n\n            \n            //\n            // --- regValid\n            //\n\n            // If invalid registers are read, regValid is negated and this op must be replayed.\n            regValid[i] =\n                (fpOpInfo[i].operandTypeA != OOT_REG || fuOpA[i].valid ) &&\n                (fpOpInfo[i].operandTypeB != OOT_REG || fuOpB[i].valid ) &&\n                (fpOpInfo[i].operandTypeC != OOT_REG || fuOpC[i].valid );\n            \n\n            //\n            // --- \u30c7\u30fc\u30bf\u30a2\u30a6\u30c8(\u5b9f\u884c\u30b9\u30c6\u30fc\u30b8\u306e\u6700\u7d42\u6bb5\u306e\u51e6\u7406)\n            //\n            dataOut[i].valid\n                = localPipeReg[i][FP_EXEC_STAGE_DEPTH-2].regValid;\n            // TODO fflags\u3092\u3061\u3083\u3093\u3068\u5b9f\u88c5\n            unique case ( localPipeReg[i][FP_EXEC_STAGE_DEPTH-2].fpQueueData.fpOpInfo.opType )\n                FP_MOP_TYPE_ADD: begin\n                    dataOut[i].data = addDataOut[i];\n                    //fflagsData[i] = addFFlagsOut[i];\n                    fflagsOut[i] = '0;\n                end\n                FP_MOP_TYPE_MUL: begin\n                    dataOut[i].data = mulDataOut[i];\n                    //fflagsData[i] = mulFFlagsOut[i];\n                    fflagsOut[i] = '0;\n                end\n                FP_MOP_TYPE_DIV, FP_MOP_TYPE_SQRT: begin\n                    dataOut[i].data = fpDivSqrtUnit.DataOut[i];\n                    //fflagsData[i] = fpDivSqrtUnit.FFlagsOut[i];\n                    fflagsOut[i] = '0;\n                end \n                FP_MOP_TYPE_FMA: begin\n                    dataOut[i].data = fmaDataOut[i];\n                    //fflagsData[i] = fmaFFlagsOut[i];\n                    fflagsOut[i] = '0;\n                end\n                default: begin /* FP_MOP_TYPE_OTHER */\n                    dataOut[i].data = otherDataOut[i];\n                    fflagsOut[i] = otherFFlagsOut[i];\n                end\n            endcase\n\n            //\n            // --- Bypass\n            //\n\n            // \u6700\u521d\u306e\u30b9\u30c6\u30fc\u30b8\u3067\u51fa\u529b\n            bypass.fpCtrlIn[i] = pipeReg[i].bCtrl;\n\n            // \u6700\u5f8c\u306e\u30b9\u30c6\u30fc\u30b8\u3067\u51fa\u529b\n            bypass.fpDstRegDataOut[i] = dataOut[i];\n\n            //\n            // --- Replay\n            //\n\n            // IS\u304b\u30893\u30b9\u30c6\u30fc\u30b8\u5f8c=EX1\u30b9\u30c6\u30fc\u30b8\u3067Replay\u3092\u51fa\u529b\n            // \u3053\u306e\u3068\u304d\u3001localPipeReg[lane][0]\u306e\u30c7\u30fc\u30bf\u3092\u4f7f\u3046\n            scheduler.fpRecordEntry[i] =\n                !stall &&\n                !clear &&\n                !flush[i][1] &&\n                localPipeReg[i][0].valid &&\n                !localPipeReg[i][0].regValid;\n            scheduler.fpRecordData[i] =\n                localPipeReg[i][0].fpQueueData;\n        end\n    end\n\n    //\n    // --- Pipeline \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\n    //\n    FPRegisterWriteStageRegPath nextStage [ FP_ISSUE_WIDTH ];\n\n    always_comb begin\n        // Local Pipeline Register\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextLocalPipeReg[i][0].opId = pipeReg[i].opId;\n`endif\n\n            nextLocalPipeReg[i][0].valid = flush[i][0] ? FALSE : pipeReg[i].valid;\n            nextLocalPipeReg[i][0].fpQueueData = pipeReg[i].fpQueueData;\n\n            // Reg valid of local pipeline \n            if (isDivSqrt[i]) begin\n                nextLocalPipeReg[i][0].regValid = \n                    pipeReg[i].replay && (fpDivSqrtUnit.Finished[i]);\n            end\n            else begin\n                nextLocalPipeReg[i][0].regValid = regValid[i];\n            end\n            \n\n            for (int j = 1; j < FP_EXEC_STAGE_DEPTH-1; j++) begin\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n                nextLocalPipeReg[i][j].opId = localPipeReg[i][j-1].opId;\n`endif \n                nextLocalPipeReg[i][j].valid = flush[i][j] ? FALSE : localPipeReg[i][j-1].valid;\n                nextLocalPipeReg[i][j].regValid = localPipeReg[i][j-1].regValid; \n                nextLocalPipeReg[i][j].fpQueueData = localPipeReg[i][j-1].fpQueueData;\n            end \n        end\n\n        // To FPRegisterWriteStage\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId\n                = localPipeReg[i][FP_EXEC_STAGE_DEPTH-2].opId;\n`endif\n\n            nextStage[i].fpQueueData\n                = localPipeReg[i][FP_EXEC_STAGE_DEPTH-2].fpQueueData;\n            // TODO implment fflags\n            nextStage[i].fflagsOut = fflagsOut[i];\n\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            nextStage[i].valid =\n                (stall || clear || port.rst || flush[i][FP_EXEC_STAGE_DEPTH-1]) ? FALSE : localPipeReg[i][FP_EXEC_STAGE_DEPTH-2].valid;\n\n            nextStage[i].dataOut = dataOut[i];\n        end\n\n        port.nextStage = nextStage;\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        // Debug Register\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n            debug.fpExReg[i].valid[0] = pipeReg[i].valid;\n            debug.fpExReg[i].flush[0] = flush[i][0];\n            debug.fpExReg[i].opId[0] = pipeReg[i].opId;\n            for ( int j = 1; j < FP_EXEC_STAGE_DEPTH; j++ ) begin\n                debug.fpExReg[i].valid[j] = localPipeReg[i][j-1].valid;\n                debug.fpExReg[i].opId[j] = localPipeReg[i][j-1].opId;\n                debug.fpExReg[i].flush[j] = flush[i][j];\n            end\n`ifdef RSD_FUNCTIONAL_SIMULATION\n            debug.fpExReg[i].dataOut = dataOut[i];\n            debug.fpExReg[i].fuOpA   = fuOpA[i];\n            debug.fpExReg[i].fuOpB   = fuOpB[i];\n            debug.fpExReg[i].fuOpC   = fuOpC[i];\n`endif\n        end\n`endif\n    end\n\nendmodule : FPExecutionStage\n\n`endif\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- FPExecutionStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\ninterface FPExecutionStageIF( input logic clk, rst );\n\n`ifdef RSD_MARCH_FP_PIPE\n\n    // Pipeline register\n    FPRegisterWriteStageRegPath nextStage [ FP_ISSUE_WIDTH ];\n    \n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\n`endif\n\nendinterface : FPExecutionStageIF"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for issuing ops.\n//\n\n\nimport BasicTypes::*;\nimport MicroOpTypes::*;\nimport PipelineTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport DebugTypes::*;\n\n`ifdef RSD_MARCH_FP_PIPE\n\nmodule FPIssueStage(\n    FPIssueStageIF.ThisStage port,\n    ScheduleStageIF.FPNextStage prev,\n    SchedulerIF.FPIssueStage scheduler,\n    RecoveryManagerIF.FPIssueStage recovery,\n    FPDivSqrtUnitIF.FPIssueStage fpDivSqrtUnit,\n    ControllerIF.FPIssueStage ctrl,\n    DebugIF.FPIssueStage debug\n);\n\n    // --- Pipeline registers\n    IssueStageRegPath pipeReg [ FP_ISSUE_WIDTH ];\n    IssueStageRegPath nextPipeReg [ FP_ISSUE_WIDTH ];\n    always_ff@( posedge port.clk )   // synchronous rst\n    begin\n        if ( port.rst ) begin\n            for ( int i = 0; i < FP_ISSUE_WIDTH; i++ )\n                pipeReg[i] <= '0;\n        end\n        else if( !ctrl.isStage.stall )              // write data\n            pipeReg <= prev.fpNextStage;\n        else\n            pipeReg <= nextPipeReg;\n    end\n\n    always_comb begin\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++) begin\n            if (recovery.toRecoveryPhase) begin\n                nextPipeReg[i].valid = pipeReg[i].valid &&\n                                    !SelectiveFlushDetector(\n                                        recovery.toRecoveryPhase,\n                                        recovery.flushRangeHeadPtr,\n                                        recovery.flushRangeTailPtr,\n                                        recovery.flushAllInsns,\n                                        scheduler.fpIssuedData[i].activeListPtr\n                                        );\n            end\n            else begin\n                nextPipeReg[i].valid = pipeReg[i].valid;\n            end\n            nextPipeReg[i].issueQueuePtr = pipeReg[i].issueQueuePtr;\n        end\n    end\n\n\n    // Pipeline control\n    logic stall, clear;\n    logic flush[ FP_ISSUE_WIDTH ];\n    logic valid [ FP_ISSUE_WIDTH ];\n    FPRegisterReadStageRegPath nextStage [ FP_ISSUE_WIDTH ];\n    FPIssueQueueEntry issuedData [ FP_ISSUE_WIDTH ];\n    IssueQueueIndexPath issueQueuePtr [ FP_ISSUE_WIDTH ];\n\n    always_comb begin\n\n        stall = ctrl.isStage.stall;\n        clear = ctrl.isStage.clear;\n\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n\n            if (scheduler.replay) begin\n                // In this cycle, the pipeline replays ops.\n                issuedData[i] = scheduler.fpReplayData[i];\n                valid[i] = scheduler.fpReplayEntry[i];\n            end\n            else begin\n                // In this cycle, the pipeline issues ops.\n                issuedData[i] = scheduler.fpIssuedData[i];\n                valid[i] = !stall && pipeReg[i].valid;\n            end\n\n            issueQueuePtr[i] = pipeReg[i].issueQueuePtr;\n\n            flush[i] = SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        issuedData[i].activeListPtr\n                        );\n\n            // Issue.\n            scheduler.fpIssue[i] = !clear && valid[i] && !flush[i];\n            scheduler.fpIssuePtr[i] = issueQueuePtr[i];\n\n            // Lock div units\n            fpDivSqrtUnit.Acquire[i] = \n                !clear && valid[i] &&\n                !flush[i] && (issuedData[i].fpOpInfo.opType inside {FP_MOP_TYPE_DIV, FP_MOP_TYPE_SQRT});\n            fpDivSqrtUnit.acquireActiveListPtr[i] = issuedData[i].activeListPtr;\n\n            // --- Pipeline \u30e9\u30c3\u30c1\u66f8\u304d\u8fbc\u307f\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            nextStage[i].valid =\n                (clear || port.rst || flush[i]) ? FALSE : valid[i];\n            nextStage[i].fpQueueData = issuedData[i];\n            nextStage[i].replay = scheduler.replay;\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId = issuedData[i].opId;\n`endif\n        end\n\n        port.nextStage = nextStage;\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        // Debug Register\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n            debug.fpIsReg[i].valid = valid[i];\n            debug.fpIsReg[i].flush = flush[i];\n            debug.fpIsReg[i].opId = issuedData[i].opId;\n        end\n`endif\n    end\n\n\nendmodule : FPIssueStage\n\n`endif\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- FPIssueStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface FPIssueStageIF( input logic clk, rst );\n    \n`ifdef RSD_MARCH_FP_PIPE\n    // Pipeline register\n    FPRegisterReadStageRegPath nextStage [ FP_ISSUE_WIDTH ];\n    \n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\n`endif    \n\n\nendinterface : FPIssueStageIF"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for register read.\n//\n\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\n\n`ifdef RSD_MARCH_FP_PIPE\n\nmodule FPRegisterReadStage(\n    FPRegisterReadStageIF.ThisStage port,\n    FPIssueStageIF.NextStage prev,\n    RegisterFileIF.FPRegisterReadStage registerFile,\n    BypassNetworkIF.FPRegisterReadStage bypass,\n    RecoveryManagerIF.FPRegisterReadStage recovery,\n    ControllerIF.FPRegisterReadStage ctrl,\n    DebugIF.FPRegisterReadStage debug\n);\n\n    // --- Pipeline registers\n    FPRegisterReadStageRegPath pipeReg[FP_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < FP_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n\n    always_ff@( posedge port.clk )   // synchronous rst\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < FP_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= '0;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin              // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n\n\n    // Pipeline controll\n    logic stall, clear;\n    logic flush[ FP_ISSUE_WIDTH ];\n    FPIssueQueueEntry iqData[FP_ISSUE_WIDTH];\n    FPOpInfo          fpOpInfo [FP_ISSUE_WIDTH];\n    \n    PRegDataPath operandA [ FP_ISSUE_WIDTH ];\n    PRegDataPath operandB [ FP_ISSUE_WIDTH ];\n    PRegDataPath operandC [ FP_ISSUE_WIDTH ];\n    OpSrc opSrc[FP_ISSUE_WIDTH];\n    OpDst opDst[FP_ISSUE_WIDTH];\n    FPExecutionStageRegPath nextStage[FP_ISSUE_WIDTH];\n\n    always_comb begin\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n            iqData[i] = pipeReg[i].fpQueueData;\n            fpOpInfo[i]  = pipeReg[i].fpQueueData.fpOpInfo;\n            opSrc[i] = iqData[i].opSrc;\n            opDst[i] = iqData[i].opDst;\n\n            //\n            // To the register file.\n            //\n\n            registerFile.fpSrcRegNumA[i] = opSrc[i].phySrcRegNumA;\n            registerFile.fpSrcRegNumB[i] = opSrc[i].phySrcRegNumB;\n            registerFile.fpSrcRegNumC[i] = opSrc[i].phySrcRegNumC;\n\n            //\n            // To the bypass network.\n            // \u30b9\u30c8\u30fc\u30eb\u3084\u30d5\u30e9\u30c3\u30b7\u30e5\u306e\u5236\u5fa1\u306f\uff0cBypass \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u5185\u90e8\u3067\n            // \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306e\u4fe1\u53f7\u3092\u53c2\u7167\u3057\u3066\u884c\u308f\u308c\u3066\u3044\u308b\n            //\n            bypass.fpPhySrcRegNumA[i] = opSrc[i].phySrcRegNumA;\n            bypass.fpPhySrcRegNumB[i] = opSrc[i].phySrcRegNumB;\n            bypass.fpPhySrcRegNumC[i] = opSrc[i].phySrcRegNumC;\n\n            bypass.fpWriteReg[i]  = opDst[i].writeReg & pipeReg[i].valid;\n            bypass.fpPhyDstRegNum[i] = opDst[i].phyDstRegNum;\n\n            bypass.fpReadRegA[i] = fpOpInfo[i].operandTypeA == OOT_REG;\n            bypass.fpReadRegB[i] = fpOpInfo[i].operandTypeB == OOT_REG;\n            bypass.fpReadRegC[i] = fpOpInfo[i].operandTypeC == OOT_REG;\n\n            operandA[i] = registerFile.fpSrcRegDataA[i];\n            operandB[i] = registerFile.fpSrcRegDataB[i];\n            operandC[i] = registerFile.fpSrcRegDataC[i];\n            operandA[i].valid = (fpOpInfo[i].operandTypeA != OOT_REG || registerFile.fpSrcRegDataA[i].valid);\n            operandB[i].valid = (fpOpInfo[i].operandTypeB != OOT_REG || registerFile.fpSrcRegDataB[i].valid);\n            operandC[i].valid = (fpOpInfo[i].operandTypeC != OOT_REG || registerFile.fpSrcRegDataC[i].valid);\n\n            //\n            // --- Pipeline \u30e9\u30c3\u30c1\u66f8\u304d\u8fbc\u307f\n            //\n            `ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId = pipeReg[i].opId;\n            `endif\n\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            flush[i] = SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        iqData[i].activeListPtr\n                        );\n            nextStage[i].valid =\n                (stall || clear || port.rst || flush[i]) ? FALSE : pipeReg[i].valid;\n\n            nextStage[i].replay = pipeReg[i].replay;\n\n            // div\u304c\u3053\u306e\u30b9\u30c6\u30fc\u30b8\u5185\u3067\u30d5\u30e9\u30c3\u30b7\u30e5\u3055\u308c\u305f\u5834\u5408\uff1a\n            // Divider\u3078\u306e\u8981\u6c42\u4e88\u7d04\u3092\u53d6\u308a\u6d88\u3057\uff0c\n            // IQ\u304b\u3089div\u3092\u767a\u884c\u3067\u304d\u308b\u3088\u3046\u306b\u3059\u308b \n            if (iqData[i].fpOpInfo.opType inside {FP_MOP_TYPE_DIV, FP_MOP_TYPE_SQRT}) begin\n                nextStage[i].isFlushed = pipeReg[i].valid && flush[i];\n            end\n            else begin\n                nextStage[i].isFlushed = FALSE;\n            end\n            \n            // \u30ec\u30b8\u30b9\u30bf\u5024&\u30d5\u30e9\u30b0\n            nextStage[i].operandA = operandA[i];\n            nextStage[i].operandB = operandB[i];\n            nextStage[i].operandC = operandC[i];\n            \n            // Issue queue data\n            nextStage[i].fpQueueData = pipeReg[i].fpQueueData;\n\n            // \u30d0\u30a4\u30d1\u30b9\u5236\u5fa1\n            nextStage[i].bCtrl = bypass.fpCtrlOut[i];\n\n        end\n        port.nextStage = nextStage;\n\n        // Debug Register\n        `ifndef RSD_DISABLE_DEBUG_REGISTER\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n            debug.fpRrReg[i].valid = pipeReg[i].valid;\n            debug.fpRrReg[i].flush = flush[i];\n            debug.fpRrReg[i].opId = pipeReg[i].opId;\n        end\n        `endif\n    end\nendmodule : FPRegisterReadStage\n\n`endif\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface FPRegisterReadStageIF( input logic clk, rst );\n\n`ifdef RSD_MARCH_FP_PIPE\n    // Pipeline register\n    FPExecutionStageRegPath nextStage [ FP_ISSUE_WIDTH ];\n\n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\n`endif\n\nendinterface : FPRegisterReadStageIF\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// FP Write back stage\n//\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport RenameLogicTypes::*;\nimport PipelineTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport DebugTypes::*;\n\n`ifdef RSD_MARCH_FP_PIPE\n\nmodule FPRegisterWriteStage(\n    FPExecutionStageIF.NextStage prev,\n    RegisterFileIF.FPRegisterWriteStage registerFile,\n    ActiveListIF.FPRegisterWriteStage activeList,\n    RecoveryManagerIF.FPRegisterWriteStage recovery,\n    ControllerIF.FPRegisterWriteStage ctrl,\n    DebugIF.FPRegisterWriteStage debug\n);\n    FPRegisterWriteStageRegPath pipeReg[FP_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < FP_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n    // --- Pipeline registers\n    always_ff@(posedge ctrl.clk)   // synchronous rst\n    begin\n        if (ctrl.rst) begin\n            for (int i = 0; i < FP_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= '0;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin    // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n    ActiveListWriteData alWriteData[FP_ISSUE_WIDTH];\n    FPIssueQueueEntry iqData[FP_ISSUE_WIDTH];\n    logic stall, clear;\n    logic flush[ FP_ISSUE_WIDTH ];\n    logic update [ FP_ISSUE_WIDTH ];\n    logic valid [ FP_ISSUE_WIDTH ];\n    logic regValid [ FP_ISSUE_WIDTH ];\n\n    always_comb begin\n\n        // Pipeline controll\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n            iqData[i] = pipeReg[i].fpQueueData;\n            regValid[i] = pipeReg[i].dataOut.valid;\n\n            valid[i] = pipeReg[i].valid;\n            flush[i] = SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        iqData[i].activeListPtr\n                        );\n            update[i] = !stall && !clear && valid[i] && !flush[i];\n\n\n            //\n            // Register file\n            //\n\n            registerFile.fpDstRegWE[i] =\n                update[i] && iqData[i].opDst.writeReg;\n\n            registerFile.fpDstRegNum[i] = iqData[i].opDst.phyDstRegNum;\n            registerFile.fpDstRegData[i] = pipeReg[i].dataOut;\n            //\n            // Active list\n            //\n            alWriteData[i].ptr = iqData[i].activeListPtr;\n            alWriteData[i].loadQueuePtr = iqData[i].loadQueueRecoveryPtr;\n            alWriteData[i].storeQueuePtr = iqData[i].storeQueueRecoveryPtr;\n            alWriteData[i].pc = iqData[i].pc;\n            alWriteData[i].dataAddr = '0;\n            alWriteData[i].isBranch = FALSE;\n            alWriteData[i].isStore = FALSE;\n\n            // ExecState\n            if ( update[i] && regValid[i] ) begin\n                alWriteData[i].state = EXEC_STATE_SUCCESS;\n            end\n            else begin\n                alWriteData[i].state = EXEC_STATE_NOT_FINISHED;\n            end\n\n            activeList.fpWrite[i] = update[i];\n            activeList.fpWriteData[i] = alWriteData[i];\n            activeList.fpFFlagsData[i] = pipeReg[i].fflagsOut;\n        end\n\n        // Debug Register\n        `ifndef RSD_DISABLE_DEBUG_REGISTER\n            for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n                debug.fpRwReg[i].valid = valid[i];\n                debug.fpRwReg[i].flush = flush[i];\n                debug.fpRwReg[i].opId = pipeReg[i].opId;\n            end\n        `endif\n    end\nendmodule : FPRegisterWriteStage\n\n`endif\n"}
{"text": "package FPUTypes;\n\ntypedef struct packed {\n    logic sign;\n    logic [7:0] expo;\n    logic [7:0] offs;\n    logic [23:0] mant;\n} FAddDataPath;\n\ntypedef struct packed {\n    FAddDataPath lhs;\n    FAddDataPath rhs;\n    logic is_subtraction;\n    logic prec_loss;\n    logic res_is_nan;\n    logic [31:0] nan;\n} FAddStage1RegPath;\n\ntypedef struct packed {\n    logic is_subtraction;\n    logic [26:0] adder_lhs;\n    logic [26:0] adder_rhs;\n    logic lhs_sign;\n    logic [7:0] lhs_expo;\n    logic [7:0] lhs_offs;\n    logic [24:0] suber_result;\n    logic [4:0] lz_count;\n    logic prec_loss;\n    logic res_is_nan;\n    logic [31:0] nan;\n} FAddStage2RegPath;\n\ntypedef struct packed {\n    //logic sign;\n    logic [7:0] expo;\n    logic [9:0] v_expo;\n    logic [22:0] mant;\n} FMulDataPath;\n\ntypedef struct packed {\n    FMulDataPath lhs;\n    FMulDataPath rhs;\n    logic [9:0] virtual_expo;\n    logic result_sign;\n    logic subnormal;\n    logic res_is_zero;\n    logic res_is_nan;\n    logic res_is_inf;\n    logic [31:0] nan;\n} FMulStage1RegPath;\n\ntypedef struct packed {\n    logic [47:0] multiplier_result;\n    logic [5:0] subnormal_shift;\n    logic [9:0] virtual_expo;\n    logic result_sign;\n    logic subnormal;\n    logic res_is_zero;\n    logic res_is_nan;\n    logic res_is_inf;\n    logic [31:0] nan;\n} FMulStage2RegPath;\n\ntypedef struct packed {\n    logic [9:0] v_expo;\n    logic [22:0] v_mant;\n} FDivDataPath;\n\ntypedef struct packed {\n    FDivDataPath lhs;\n    FDivDataPath rhs;\n    logic [9:0] virtual_expo;\n    logic result_sign;\n    logic subnormal;\n    logic dividend_normalize;\n    logic res_is_zero;\n    logic res_is_nan;\n    logic res_is_inf;\n    logic [31:0] nan;\n    logic [26:0] rem;\n    logic [23:0] quo;\n} FDivRegPath;\n\ntypedef struct packed {\n    logic inp_sign;\n    logic [8:0] v_expo;\n    logic [23:0] v_mant;\n    logic res_is_zero;\n    logic res_is_nan;\n    logic res_is_inf;\n    logic [31:0] nan;\n    logic [26:0] rem;\n    logic [25:0] quo;\n} FSQRTRegPath;\n\ntypedef struct packed {\n    logic [9:0]  v_lhs_expo;\n    logic [9:0]  v_rhs_expo;\n    logic [23:0] v_lhs_mant;\n    logic [23:0] v_rhs_mant;\n    logic [9:0] virtual_expo;\n    logic is_divide;\n    logic result_sign;\n    logic lhs_sign;\n    logic subnormal;\n    logic res_is_zero;\n    logic res_is_nan;\n    logic res_is_inf;\n    logic [31:0] nan;\n    logic [26:0] rem;\n    logic [25:0] quo;\n} FDivSqrtRegPath;\n\ntypedef struct packed {\n    logic [9:0] mulres_expo;\n    logic result_is_inf;\n    logic result_is_nan;\n    logic res_is_addend;\n    logic mul_sign;\n    logic prop_inf_sign;\n    logic addend_sign;\n    logic is_subtract;\n    logic [31:0] nan;\n    logic [31:0] addend;\n} FMAStage1RegPath;\n\ntypedef struct packed {\n    logic [9:0] mulres_expo;\n    logic result_is_inf;\n    logic result_is_nan;\n    logic res_is_addend;\n    logic mul_sign;\n    logic prop_inf_sign;\n    logic addend_sign;\n    logic is_subtract;\n    logic [31:0] nan;\n    logic [31:0] addend;\n} FMAStage2RegPath;\n\ntypedef struct packed {\n    logic [75:0] abs_fma_result;\n    logic [9:0] mulres_expo;\n    logic res_is_negative;\n    logic result_is_inf;\n    logic result_is_nan;\n    logic res_is_zero;\n    logic res_is_addend;\n    logic result_sign;\n    logic prop_inf_sign;\n    logic addend_sign;\n    logic is_subtract;\n    logic [31:0] nan;\n    logic [31:0] addend;\n} FMAStage3RegPath;\n\ntypedef struct packed {\n    logic [75:0] abs_fma_result;\n    logic [7:0] fmares_shift;\n    logic [9:0] virtual_expo;\n    logic subnormal;\n    logic res_is_negative;\n    logic result_is_inf;\n    logic result_is_nan;\n    logic res_is_zero;\n    logic res_is_addend;\n    logic result_sign;\n    logic prop_inf_sign;\n    logic addend_sign;\n    logic is_subtract;\n    logic [31:0] nan;\n    logic [31:0] addend;\n} FMAStage4RegPath;\n\nendpackage"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Gshare Branch Predictor\n//\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport FetchUnitTypes::*;\n\nfunction automatic PHT_IndexPath ToPHT_Index_Global(AddrPath addr, BranchGlobalHistoryPath gh);\n    PHT_IndexPath phtIndex;\n    phtIndex =\n        addr[\n            PHT_ENTRY_NUM_BIT_WIDTH + INSN_ADDR_BIT_WIDTH - 1: \n            INSN_ADDR_BIT_WIDTH\n        ];\n    phtIndex[PHT_ENTRY_NUM_BIT_WIDTH - 1 : PHT_ENTRY_NUM_BIT_WIDTH - BRANCH_GLOBAL_HISTORY_BIT_WIDTH] ^= gh;\n    return phtIndex;\nendfunction\n\nmodule Gshare(\n    NextPCStageIF.BranchPredictor port,\n    FetchStageIF.BranchPredictor next,\n    ControllerIF.BranchPredictor ctrl\n);\n\n    logic stall, clear;\n    PC_Path pcIn;\n\n    // Use combinational logic\n    logic brPredTaken[FETCH_WIDTH];\n    logic updateHistory[FETCH_WIDTH];\n\n    // Logic for read/write PHT\n    logic phtWE[INT_ISSUE_WIDTH];\n    PHT_IndexPath phtWA[INT_ISSUE_WIDTH];\n    PHT_EntryPath phtWV[INT_ISSUE_WIDTH];\n    PHT_EntryPath phtPrevValue[INT_ISSUE_WIDTH];\n\n    // Read port need for branch predict and update counter.\n    PHT_IndexPath phtRA[FETCH_WIDTH];\n    PHT_EntryPath phtRV[FETCH_WIDTH];\n\n    // Branch history for using predict.\n    BranchGlobalHistoryPath nextBrGlobalHistory, regBrGlobalHistory;\n    BranchGlobalHistoryPath brGlobalHistory [ FETCH_WIDTH ];\n\n    // assert when misprediction occured.\n    logic mispred;\n\n    logic pushPhtQueue, popPhtQueue;\n    logic full, empty;\n\n    // Queue for multibank pht\n    PhtQueueEntry phtQueue[PHT_QUEUE_SIZE];\n    PhtQueuePointerPath headPtr, tailPtr;\n\n    // Check for write number in 1cycle.\n    logic updatePht;\n\n    // the body of PHT.\n    generate\n        BlockMultiBankRAM #(\n            .ENTRY_NUM( PHT_ENTRY_NUM ),\n            .ENTRY_BIT_SIZE( $bits( PHT_EntryPath ) ),\n            .READ_NUM( FETCH_WIDTH ),\n            .WRITE_NUM( INT_ISSUE_WIDTH )\n        )\n        pht( \n            .clk(port.clk),\n            .we(phtWE),\n            .wa(phtWA),\n            .wv(phtWV),\n            .ra(phtRA),\n            .rv(phtRV)\n        );\n        \n        QueuePointer #(\n            .SIZE( PHT_QUEUE_SIZE )\n        )\n        phtQueuePointer(\n            .clk(port.clk),\n            .rst(port.rst),\n            .push(pushPhtQueue),\n            .pop(popPhtQueue),\n            .full(full),\n            .empty(empty),\n            .headPtr(headPtr),\n            .tailPtr(tailPtr)    \n        );\n    endgenerate\n    \n    \n    // Counter for reset sequence.\n    PHT_IndexPath resetIndex;\n    always_ff @(posedge port.clk) begin\n        if (port.rstStart) begin\n            resetIndex <= 0;\n        end\n        else begin\n            resetIndex <= resetIndex + 1;\n        end\n    end\n\n    always_ff @(posedge port.clk) begin\n        // update Branch Global History.\n        if (port.rst) begin\n            regBrGlobalHistory <= '0;\n        end\n        else begin\n            regBrGlobalHistory <= nextBrGlobalHistory;\n        end\n\n        // Push Pht Queue\n        if (port.rst) begin\n            phtQueue[resetIndex % PHT_QUEUE_SIZE].phtWA <= '0;\n            phtQueue[resetIndex % PHT_QUEUE_SIZE].phtWV <= PHT_ENTRY_MAX / 2 + 1;\n        end\n        else if (pushPhtQueue) begin\n            phtQueue[headPtr].phtWA <= phtWA[INT_ISSUE_WIDTH-1];\n            phtQueue[headPtr].phtWV <= phtWV[INT_ISSUE_WIDTH-1];\n        end\n    end\n\n\n    always_comb begin\n\n        stall = ctrl.ifStage.stall;\n        clear = ctrl.ifStage.clear;\n    \n        pcIn = port.predNextPC;\n\n        nextBrGlobalHistory = regBrGlobalHistory;\n\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            brPredTaken[i] = FALSE;\n            // Output global history to pipeline for recovery.\n            brGlobalHistory[i] = regBrGlobalHistory;\n            updateHistory[i] = FALSE;\n        end\n\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            // Predict directions (Check the MSB).\n            brPredTaken[i] =\n                phtRV[i][PHT_ENTRY_WIDTH - 1] && next.btbHit[i];\n\n            // Assert BTB is hit, ICache line is valid, and conditional branch.\n            updateHistory[i] = next.btbHit[i] && next.readIsCondBr[i] && \n                next.updateBrHistory[i];\n\n            // Generate next brGlobalHistory.\n            if (updateHistory[i]) begin\n                // Shift history 1 bit to the left and reflect prediction direction in LSB.\n                nextBrGlobalHistory = \n                    (nextBrGlobalHistory << 1) | brPredTaken[i];\n                \n                if (brPredTaken[i]) begin\n                    // If brPred is taken, next instruction don't be executed.\n                    break;\n                end\n            end\n        end\n        \n        next.phtPrevValue = phtRV;\n        next.brPredTaken = brPredTaken;\n        next.brGlobalHistory = brGlobalHistory;\n\n        // Discard the result of previous cycle\n        for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n            phtWE[i] = FALSE;\n            phtWV[i] = '0;\n            // Counter's value.\n            phtPrevValue[i] = port.brResult[i].phtPrevValue; \n            phtWA[i] = ToPHT_Index_Global(\n                port.brResult[i].brAddr,\n                port.brResult[i].globalHistory\n            );\n        end\n\n        updatePht = FALSE;\n        pushPhtQueue = FALSE;\n\n        for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n            // When branch instruction is executed, update PHT.\n            if (updatePht) begin\n                pushPhtQueue = port.brResult[i].valid;\n            end\n            else begin\n                phtWE[i] = port.brResult[i].valid;\n                updatePht |= phtWE[i];\n            end\n\n            mispred = port.brResult[i].mispred && port.brResult[i].valid;\n\n            // Update PHT's counter (saturated up/down counter).\n            if (port.brResult[i].execTaken) begin\n                phtWV[i] = (phtPrevValue[i] == PHT_ENTRY_MAX) ? \n                    PHT_ENTRY_MAX : phtPrevValue[i] + 1;\n            end\n            else begin\n                phtWV[i] = (phtPrevValue[i] == 0) ? \n                    0 : phtPrevValue[i] - 1;\n            end\n\n            // When miss prediction is occured, recovory history.\n            if (mispred) begin\n                if (port.brResult[i].isCondBr) begin\n                    nextBrGlobalHistory = \n                        (port.brResult[i].globalHistory << 1) | port.brResult[i].execTaken;\n                end\n                else begin\n                    nextBrGlobalHistory = port.brResult[i].globalHistory;\n                end\n            end\n        end\n\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            // Read PHT entry for next cycle (use PC ^ brGlobalHistory).\n            phtRA[i] = ToPHT_Index_Global(\n                pcIn + i*INSN_BYTE_WIDTH,\n                nextBrGlobalHistory\n            );\n        end\n\n        // Pop PHT Queue\n        if (!empty && !updatePht) begin\n            popPhtQueue = TRUE;\n            phtWE[0] = TRUE;\n            phtWA[0] = phtQueue[tailPtr].phtWA;\n            phtWV[0] = phtQueue[tailPtr].phtWV;\n        end \n        else begin\n            popPhtQueue = FALSE;\n        end\n\n        // In reset sequence, the write port 0 is used for initializing, and \n        // the other write ports are disabled.\n        if (port.rst) begin\n            for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n                phtWE[i] = (i == 0) ? TRUE : FALSE;\n                phtWA[i] = resetIndex;\n                phtWV[i] = PHT_ENTRY_MAX / 2 + 1;\n            end\n\n            // To avoid writing to the same bank (avoid error message)\n            for (int i = 0; i < FETCH_WIDTH; i++) begin\n                phtRA[i] = i;\n            end\n\n            pushPhtQueue = FALSE;\n            popPhtQueue = FALSE;\n        end\n    end\n\nendmodule : Gshare\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A set-associative instruction cache (non-blocking)\n// Replacement policy: NRU (not-recently used)\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport CacheSystemTypes::*;\nimport MemoryMapTypes::*;\n\nmodule ICacheArray(\n    input  logic           clk, rst, rstStart,\n    input  logic           we,\n    input  ICacheIndexPath writeIndex,\n    input  ICacheTagPath   writeTag,\n    input  ICacheLinePath  writeLineData,\n    input  ICacheIndexPath readIndex, // The result comes after 1 cycle from the request\n    input  ICacheTagPath   readTag,\n    output ICacheLinePath  readLineData,\n    output logic           hit, valid\n);\n\n    typedef struct packed {\n        ICacheLinePath     data;\n        ICacheTagValidPath meta;\n    } WayData;\n\n    logic weWay;\n    ICacheIndexPath rstIndex;\n    ICacheIndexPath writeWayIndex;\n    WayData readWayData, writeWayData;\n\n    // tag + instruction array\n    BlockDualPortRAM #( \n        .ENTRY_NUM( ICACHE_INDEX_NUM ),\n        .ENTRY_BIT_SIZE( $bits(WayData)  )\n    ) tagValidArray ( \n        .clk( clk ),\n        .we( weWay ),\n        .wa( writeWayIndex ),\n        .wv( writeWayData ),\n        .ra( readIndex ),\n        .rv( readWayData )\n    );\n\n    always_comb begin\n        // ICacheTagPath-array write\n        if ( rst ) begin\n            weWay = TRUE;\n            writeWayIndex = rstIndex;\n            writeWayData.meta.valid = FALSE;\n        end\n        else begin\n            weWay = we;\n            writeWayIndex = writeIndex;\n            writeWayData.meta.valid = TRUE;\n        end\n        writeWayData.meta.tag = writeTag;\n        writeWayData.data = writeLineData;\n        readLineData = readWayData.data;\n        // Result of tag-array read\n        valid = readWayData.meta.valid;\n        hit = valid && readWayData.meta.tag == readTag;\n    end\n\n    \n    // Reset Index\n    always_ff @ ( posedge clk ) begin\n        if ( rstStart ) begin\n            rstIndex <= '0;\n        end\n        else begin\n            rstIndex <= rstIndex + 1;\n        end\n    end\n\nendmodule\n\n//\n// NRUStateArray\n//\nmodule ICacheNRUStateArray(\n    input  logic              clk, rst, rstStart,\n    input  ICacheIndexPath    writeIndex,\n    input  ICacheWayPath      writeWay,\n    input  logic              writeHit,\n    input  NRUAccessStatePath writeNRUState,\n    input  ICacheIndexPath    readIndex,\n    output NRUAccessStatePath readNRUState,\n    output ICacheIndexPath rstIndex\n);\n    \n    logic we;\n    ICacheIndexPath writeNRUStateIndex;\n    NRUAccessStatePath writeNRUStateData;\n\n    // NRUStateArray array\n    BlockDualPortRAM #(\n        .ENTRY_NUM( ICACHE_INDEX_NUM ),\n        .ENTRY_BIT_SIZE( $bits( NRUAccessStatePath ) )\n    ) nruStateArray (\n        .clk( clk ),\n        .we( we ),\n        .wa( writeNRUStateIndex ),\n        .wv( writeNRUStateData ),\n        .ra( readIndex ),\n        .rv( readNRUState )\n    );\n\n    always_comb begin\n        if ( rst ) begin\n            we = TRUE;\n            writeNRUStateIndex = rstIndex;\n            writeNRUStateData = '0;\n        end\n        else begin\n            we = writeHit;\n            writeNRUStateIndex = writeIndex;\n            writeNRUStateData = writeNRUState;\n        end\n    end\n    // Reset Index\n    always_ff @ ( posedge clk ) begin\n        if ( rstStart ) begin\n            rstIndex <= '0;\n        end\n        else begin\n            rstIndex <= rstIndex + 1;\n        end\n    end\n\nendmodule\n\n//\n// Generate hit signals for each word.\n//\nmodule ICacheHitLogic(\ninput\n    logic hitIn,\n    ICacheLineInsnIndexPath headWordPtr,\noutput\n    logic hitOut [ FETCH_WIDTH ]\n);\n    ICacheLineInsnCountPath wordPtr [ FETCH_WIDTH ];\n    \n    always_comb begin\n        for ( int i = 0; i < FETCH_WIDTH; i++ ) begin\n            wordPtr[i] = headWordPtr + i;\n            if ( wordPtr[i][ $clog2(ICACHE_LINE_INSN_NUM) ] ) begin\n                // If this condition is satisfied, word[i] is not on the same line as word[0].\n                // It means cache-miss.\n                hitOut[i] = FALSE;\n            end\n            else begin\n                hitOut[i] = hitIn;\n            end\n        end\n    end\n\nendmodule\n\nmodule ICache(\n    NextPCStageIF.ICache port,\n    FetchStageIF.ICache next,\n    CacheSystemIF.ICache cacheSystem\n);\n    \n    //\n    // ICacheIndexPath, ICacheTagPath -> Physical Address\n    //\n    function automatic PhyAddrPath GetFullPhyAddr ( ICacheIndexPath index, ICacheTagPath tag );\n        return { tag, index, { ICACHE_LINE_BYTE_NUM_BIT_WIDTH{1'b0} } };\n    endfunction\n    \n    //\n    // PC -> ICacheIndexPath, ICacheTagPath etc.\n    //\n    function automatic ICacheIndexPath GetICacheIndex( PhyAddrPath addr );\n        return addr [\n            PHY_ADDR_WIDTH - ICACHE_TAG_BIT_WIDTH - 1 : \n            ICACHE_LINE_BYTE_NUM_BIT_WIDTH \n        ];\n    endfunction\n    \n    function automatic ICacheTagPath GetICacheTag( PhyAddrPath addr );\n        return addr [ \n            PHY_ADDR_WIDTH - 1 : \n            PHY_ADDR_WIDTH - ICACHE_TAG_BIT_WIDTH \n        ];\n    endfunction\n    \n    function automatic ICacheLineInsnIndexPath GetICacheLineInsnIndex( PhyAddrPath addr );\n        return addr [ \n            ICACHE_LINE_BYTE_NUM_BIT_WIDTH-1 : \n            INSN_ADDR_BIT_WIDTH \n        ];\n    endfunction\n    \n    //\n    // NRUState, Access -> NRUState\n    // NRUState         -> Evicted way (one-hot)\n    //\n    function automatic NRUAccessStatePath UpdateNRUState( NRUAccessStatePath NRUState, ICacheWayPath way );\n\n        if ( (NRUState | (1 << way)) == (1 << ICACHE_WAY_NUM) - 1 ) begin \n            // if all NRU state bits are high, NRU state needs to clear\n            return 1 << way;\n        end\n        else begin\n            // Update indicated NRU state bit \n            return NRUState | (1 << way);\n        end\n    endfunction\n\n    function automatic NRUAccessStatePath DecideWayToEvictByNRUState( NRUAccessStatePath NRUState );\n        // return the position of the rightmost 0-bit\n        // e.g. NRUState = 10011 -> return 00100\n        return (NRUState | NRUState + 1) ^ NRUState;\n    endfunction\n\n    //\n    // Phase of ICache\n    //\n    typedef enum logic [2:0]\n    {\n        ICACHE_PHASE_READ_CACHE = 0,\n        ICACHE_PHASE_MISS_READ_MEM_REQUEST = 1,   // Read from a main memory to a cache.\n        ICACHE_PHASE_MISS_READ_MEM_RECEIVE = 2,   // Read from a main memory to a cache.\n        ICACHE_PHASE_MISS_WRITE_CACHE = 3,        // Write data to a cache.\n        ICACHE_PHASE_FLUSH_PREPARE = 4,           // Prepare for ICache flush.\n        ICACHE_PHASE_FLUSH_PROCESSING = 5,        // ICache flush is processing.\n        ICACHE_PHASE_FLUSH_COMPLETE = 6           // ICache flush is completed.\n    } ICachePhase;\n    ICachePhase regPhase, nextPhase;\n\n    always_ff @( posedge port.clk ) begin\n        if ( port.rst ) begin\n            regPhase <= ICACHE_PHASE_READ_CACHE;\n        end\n        else begin\n            regPhase <= nextPhase;\n        end\n    end\n    \n    // for flush\n    logic regFlushStart, nextFlushStart;\n    logic regFlush, nextFlush;\n    logic regFlushReqAck, nextFlushReqAck;\n    logic flushComplete;\n\n    //\n    // ICacheArray\n    //\n    logic valid[ICACHE_WAY_NUM];\n    logic hit;\n    logic[ICACHE_WAY_NUM-1:0] hitArray;\n    ICacheWayPath hitWay;\n    logic we[ICACHE_WAY_NUM];\n    ICacheIndexPath readIndex, writeIndex, nextReadIndex;\n    ICacheTagPath readTag, writeTag;\n    ICacheLineInsnPath readLineInsnList[ICACHE_WAY_NUM];\n\n    generate\n        for ( genvar i = 0; i < ICACHE_WAY_NUM; i++ ) begin\n            ICacheArray array(\n                .clk( port.clk ),\n                .rst( (port.rst) ? port.rst : regFlush ),\n                .rstStart( (port.rstStart) ? port.rstStart : regFlushStart ),\n                .we( we[i] ),\n                .writeIndex( writeIndex ),\n                .writeTag( writeTag ),\n                .writeLineData( cacheSystem.icMemAccessResult.data ),\n                .readIndex( nextReadIndex ),\n                .readTag( readTag ),\n                .hit( hitArray[i] ),\n                .valid( valid[i] ),\n                .readLineData( readLineInsnList[i] )\n            );\n        end\n    endgenerate\n    \n    always_comb begin\n        // Set signal about read address.\n        readIndex  = GetICacheIndex( next.icReadAddrIn );\n        readTag = GetICacheTag( next.icReadAddrIn );\n        \n        nextReadIndex = GetICacheIndex( port.icNextReadAddrIn );\n\n        // Check cache hit \n        hit = |hitArray;\n        hitWay = '0;\n        for (int i = 0; i < ICACHE_WAY_NUM; i++) begin\n            if (hitArray[i]) begin\n                // Detect which way is hit\n                hitWay = i;\n                break;\n            end\n        end\n    end\n\n    //\n    // ICacheNRUStateArray\n    //\n    NRUAccessStatePath updatedNRUState, readNRUState;\n    NRUAccessStatePath wayToEvictOneHot;\n    ICacheWayPath wayToEvict;\n    logic nruStateWE;\n    ICacheIndexPath rstIndex;\n    ICacheNRUStateArray nruStateArray(\n        .clk( port.clk ),\n        .rst( (port.rst) ? port.rst : regFlush ),\n        .rstStart( (port.rstStart) ? port.rstStart : regFlushStart ),\n        .writeIndex( readIndex ),\n        .writeWay( hitWay ),\n        .writeHit( nruStateWE ),\n        .writeNRUState( updatedNRUState ),\n        .readIndex( nextReadIndex ),\n        .readNRUState( readNRUState ),\n        .rstIndex( rstIndex )\n    );\n\n    always_comb begin\n        updatedNRUState = UpdateNRUState(readNRUState, hitWay);\n        wayToEvictOneHot = DecideWayToEvictByNRUState(readNRUState);\n        wayToEvict = '0;\n\n        for ( int i = 0; i < ICACHE_WAY_NUM; i++ ) begin\n            if ( wayToEvictOneHot[i] ) begin\n                wayToEvict = i;\n                break;\n            end\n        end\n    end\n\n    //\n    // HitLogic\n    // Check whether each read request is satisfied\n    //\n    ICacheLineInsnIndexPath wordPtr[ FETCH_WIDTH ];\n    ICacheHitLogic iCacheHitLogic (\n        .hitIn( hit && regPhase == ICACHE_PHASE_READ_CACHE && next.icRE ),\n        .headWordPtr( wordPtr[0] ),\n        .hitOut( next.icReadHit )\n    );\n    \n    //\n    // ICache Read\n    //\n    \n    always_comb begin\n        wordPtr[0] = GetICacheLineInsnIndex( next.icReadAddrIn );\n        for ( int i = 1; i < FETCH_WIDTH; i++ ) begin\n            wordPtr[i] = wordPtr[0] + i;\n        end\n        \n        // Send i-cache read data to FetchStage\n        for ( int i = 0; i < FETCH_WIDTH; i++ ) begin\n            next.icReadDataOut[i] = readLineInsnList[hitWay][ wordPtr[i] ];\n        end\n    end\n    \n    \n    //\n    // ICache Miss Handling\n    //\n    logic regMissValid, nextMissValid;\n    ICacheIndexPath regMissIndex, nextMissIndex;\n    ICacheTagPath regMissTag, nextMissTag;\n    MemAccessSerial regSerial, nextSerial;\n    \n    always_comb begin\n        for ( int i = 0; i < ICACHE_WAY_NUM; i++ ) begin\n            we[i] = FALSE;\n        end\n        nruStateWE = FALSE;\n\n        nextPhase = regPhase;\n        \n        nextMissValid = regMissValid;\n        nextMissIndex = regMissIndex;\n        nextMissTag = regMissTag;\n        nextSerial = regSerial;\n\n        // for flush\n        nextFlushStart = regFlushStart;\n        nextFlush = regFlush;\n        nextFlushReqAck = regFlushReqAck;\n        flushComplete = FALSE;\n        \n        // Non-blocking i-cache state machine\n        case (regPhase)\n        default: begin\n            nextPhase = ICACHE_PHASE_READ_CACHE;\n        end\n        ICACHE_PHASE_READ_CACHE: begin\n            // Not processing cache miss now\n            if (cacheSystem.icFlushReq) begin\n                nextPhase = ICACHE_PHASE_FLUSH_PREPARE;\n                nextFlushStart = TRUE;\n                nextFlush = TRUE;\n                nextFlushReqAck = FALSE;\n            end\n            else if ( next.icRE && !hit ) begin\n                // Read request -> i-cache miss:\n                // Change state to process a cache miss\n                nextPhase = ICACHE_PHASE_MISS_READ_MEM_REQUEST;\n                nextMissValid = TRUE;\n                nextMissIndex = readIndex;\n                nextMissTag = readTag;\n                nextFlushReqAck = FALSE;\n            end\n            else if ( next.icRE )begin\n                // Read request -> i-cache hit:\n                // Update nru state\n                nruStateWE = TRUE;\n            end\n        end\n        ICACHE_PHASE_MISS_READ_MEM_REQUEST: begin\n            // Send read request to lower level memory\n            if ( cacheSystem.icMemAccessReqAck.ack ) begin\n                nextPhase = ICACHE_PHASE_MISS_READ_MEM_RECEIVE;\n                nextMissValid = FALSE;\n                nextSerial = cacheSystem.icMemAccessReqAck.serial;\n            end\n        end\n        ICACHE_PHASE_MISS_READ_MEM_RECEIVE: begin\n            // Read response has come\n            if (\n                cacheSystem.icMemAccessResult.valid &&\n                cacheSystem.icMemAccessResult.serial == regSerial\n            ) begin\n                // Receive memory read data and write it to i-cache\n                nextPhase = ICACHE_PHASE_MISS_WRITE_CACHE;\n                we[wayToEvict] = TRUE;\n            end\n        end\n        ICACHE_PHASE_MISS_WRITE_CACHE: begin\n            // Cannot read the write data in the same cycle,\n            // therefore wait 1-cycle\n            nextFlushReqAck = TRUE;\n            nextPhase = ICACHE_PHASE_READ_CACHE;\n        end\n        ICACHE_PHASE_FLUSH_PREPARE: begin\n            // 1 cycle to reset rstIndex.\n            nextFlushStart = FALSE;\n            nextMissTag = '0;\n            nextPhase = ICACHE_PHASE_FLUSH_PROCESSING;\n        end\n        ICACHE_PHASE_FLUSH_PROCESSING: begin\n            if (&rstIndex) begin\n                nextFlush = FALSE;\n                nextPhase = ICACHE_PHASE_FLUSH_COMPLETE;\n            end\n        end\n        ICACHE_PHASE_FLUSH_COMPLETE: begin\n            flushComplete = TRUE;\n            if (cacheSystem.flushComplete) begin\n                nextFlushReqAck = TRUE;\n                nextPhase = ICACHE_PHASE_READ_CACHE;\n            end\n        end\n        endcase // regPhase\n\n        writeIndex = regMissIndex;\n        writeTag = regMissTag;\n\n        cacheSystem.icMemAccessReq.valid = regMissValid;\n        cacheSystem.icMemAccessReq.addr = \n            GetFullPhyAddr( regMissIndex, regMissTag );\n\n        // for flush\n        cacheSystem.icFlushReqAck = regFlushReqAck;\n        cacheSystem.icFlushComplete = flushComplete;\n    end\n    \n    always_ff @( posedge port.clk ) begin\n        if ( port.rst ) begin\n            regMissValid <= FALSE;\n            regMissIndex <= '0;\n            regMissTag <= '0;\n            regSerial <= '0;\n        end\n        else begin\n            regMissValid <= nextMissValid;\n            regMissIndex <= nextMissIndex;\n            regMissTag <= nextMissTag;\n            regSerial <= nextSerial;\n        end\n        \n    end\n\n    // for flush\n    always_ff @( posedge port.clk ) begin\n        if ( port.rst ) begin\n            regFlush <= FALSE;\n            regFlushStart <= FALSE;\n            regFlushReqAck <= TRUE;\n        end\n        else begin\n            regFlush <= nextFlush;\n            regFlushStart <= nextFlushStart;\n            regFlushReqAck <= nextFlushReqAck;\n        end\n    end\n    \n`ifndef RSD_SYNTHESIS\n    `ifndef RSD_VIVADO_SIMULATION\n        initial begin\n            regMissIndex <= '0;\n            regMissTag <= '0;\n            regSerial <= '0;\n        end\n        `RSD_ASSERT_CLK(port.clk, $onehot0(we), \"Signal we is not one-hot or 0.\");\n        `RSD_ASSERT_CLK(port.clk, $onehot0(hit), \"Signal hit is not one-hot or 0.\");\n    `endif\n`endif\n    \n\nendmodule\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// 32bit ARM ALU\n//\n\n\nimport BasicTypes::*;\nimport MicroOpTypes::*;\nimport OpFormatTypes::*;\nimport PipelineTypes::*;\n\n\ntypedef struct packed \n{\n    logic    carry;\n    DataPath data;\n} IntAdderResult;\n\n\n// \u52a0\u7b97\u6a5f\n// inv \u304c\u30a2\u30b5\u30fc\u30c8\u3055\u308c\u305f\u30aa\u30da\u30e9\u30f3\u30c9\u306f\u30d3\u30c3\u30c8\u53cd\u8ee2\u3092\u884c\u3046\nmodule IntAdder(\noutput \n    IntAdderResult dst,\n    logic overflowOut,\ninput\n    DataPath srcA, logic invA,\n    DataPath srcB, logic invB,\n    logic carryIn\n);\n    function automatic DataPath Inv(\n        input DataPath src, logic inv\n    );\n        return inv ? ~src : src;\n    endfunction\n\n    DataPath tmpA, tmpB;\n    always_comb begin\n        tmpA = Inv( srcA, invA );\n        tmpB = Inv( srcB, invB );\n        dst  = tmpA + tmpB + carryIn;\n        overflowOut =\n            ( dst.data[DATA_WIDTH-1] ^ tmpA[DATA_WIDTH-1] ) &&\n            ( dst.data[DATA_WIDTH-1] ^ tmpB[DATA_WIDTH-1] );\n    end\nendmodule\n\n\nmodule IntALU(\n    output\n        DataPath aluDataOut,\n    input \n        IntALU_Code aluCode,\n        DataPath fuOpA_In,\n        DataPath fuOpB_In\n);\n    \n    IntAdderResult opDst;\n    \n    \n    DataPath opA;\n    DataPath opB;\n    SignedDataPath signedOpA;\n    SignedDataPath signedOpB;\n    \n    IntAdderResult adderDst;\n    DataPath adderInA; logic adderInvInA;\n    DataPath adderInB; logic adderInvInB;\n    logic    adderInCarry;\n    logic    adderOutOverflow;\n    \n    IntAdder adder(\n        .dst(adderDst),\n        .srcA(adderInA),\n        .invA(adderInvInA),\n        .srcB(adderInB),\n        .invB(adderInvInB),\n        .carryIn(adderInCarry),\n        .overflowOut(adderOutOverflow)\n    );\n\n    `define Add( a, ia, b, ib, c ) begin \\\n        adderInA     = a;  \\\n        adderInvInA  = ia; \\\n        adderInB     = b;  \\\n        adderInvInB  = ib; \\\n        adderInCarry = c;  \\\n        opDst        = adderDst; \\\n    end \\\n    \n    `define Logic( a ) begin \\\n        adderInA     = '0;  \\\n        adderInvInA  = FALSE; \\\n        adderInB     = '0;  \\\n        adderInvInB  = FALSE; \\\n        adderInCarry = 0;  \\\n        opDst        = { 1'b0, (a) }; \\\n    end \\\n\n\n    // Operation\n    always_comb begin\n        \n        opA     = fuOpA_In;\n        opB     = fuOpB_In;\n        signedOpA = '0;\n        signedOpB = '0;\n        \n        case( aluCode )\n            // AND  \u8ad6\u7406\u7a4d\n            default: `Logic( opA & opB )\n            \n            // EOR  \u6392\u4ed6\u7684\u8ad6\u7406\u548c\n            AC_EOR: `Logic( opA ^ opB )\n            \n            // SUB  \u6e1b\u7b97\n            // a - b = a + ~b + 1\n            AC_SUB: `Add( opA, FALSE, opB, TRUE, 1  )   \n            \n            // ADD  \u52a0\u7b97\n            AC_ADD: `Add( opA, FALSE, opB, FALSE, 0 )       \n            \n            // SLT  \u6bd4\u8f03   Rd = if Rs1 < Rs2 then 1 else 0\n            AC_SLT : begin\n                signedOpA = opA;\n                signedOpB = opB;\n                `Logic( { 31'h0, ( signedOpA < signedOpB) } )\n            end\n            // SLTU  \u7b26\u53f7\u306a\u3057\u6bd4\u8f03\n            AC_SLTU: `Logic( { 31'h0, ( opA < opB ) } )\n            \n            // ORR  \uff08\u5305\u542b\u7684\uff09\u8ad6\u7406\u548c    Rd := Rn OR shifter_operand\n            AC_ORR: `Logic( opA | opB )\n\n        endcase\n\n        aluDataOut   = opDst.data;\n    end\n    \n\n\nendmodule : IntALU\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Execution stage\n//\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\nimport FetchUnitTypes::*;\nimport RenameLogicTypes::*;\n\n\nfunction automatic logic IsConditionEnabledInt( CondCode cond, DataPath opA, DataPath opB );\n    logic ce;\n    SignedDataPath signedOpA;\n    SignedDataPath signedOpB;\n\n    signedOpA = opA;\n    signedOpB = opB;\n\n    case( cond )\n        COND_EQ:  ce = ( opA == opB );\n        COND_NE:  ce = ( opA != opB );\n        COND_LT:  ce = ( signedOpA < signedOpB );\n        COND_LTU: ce = ( opA < opB );\n        COND_GE:  ce = ( signedOpA >= signedOpB );\n        COND_GEU: ce = ( opA >= opB );\n\n        // AL \u5e38\u6642\uff08\u7121\u6761\u4ef6\uff09 -\n        COND_AL: ce = 1;\n\n        default:\n            ce = 1;\n    endcase\n\n    return ce;\n\nendfunction\n\n//\n// \u5b9f\u884c\u30b9\u30c6\u30fc\u30b8\n//\n\nmodule IntegerExecutionStage(\n    IntegerExecutionStageIF.ThisStage port,\n    IntegerRegisterReadStageIF.NextStage prev,\n    BypassNetworkIF.IntegerExecutionStage bypass,\n    RecoveryManagerIF.IntegerExecutionStage recovery,\n    ControllerIF.IntegerExecutionStage ctrl,\n    DebugIF.IntegerExecutionStage debug\n);\n\n    IntegerExecutionStageRegPath pipeReg [INT_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n\n    // --- Pipeline registers\n    always_ff@(posedge port.clk)   // synchronous rst\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= FALSE;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin  // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n    // Pipeline control\n    logic stall, clear;\n    logic flush[ INT_ISSUE_WIDTH ];\n\n    IntIssueQueueEntry iqData[INT_ISSUE_WIDTH];\n    IntOpInfo  intOpInfo [ INT_ISSUE_WIDTH ];\n    BranchPred bPred [ INT_ISSUE_WIDTH ];\n    AddrPath pc [ INT_ISSUE_WIDTH ];\n\n    PRegDataPath fuOpA [ INT_ISSUE_WIDTH ];\n    PRegDataPath fuOpB [ INT_ISSUE_WIDTH ];\n    PRegDataPath dataOut [ INT_ISSUE_WIDTH ];\n\n    // Condition\n    logic isCondEnabled [ INT_ISSUE_WIDTH ];\n\n    // ALU\n    DataPath aluDataOut [ INT_ISSUE_WIDTH ];\n    IntALU_Code aluCode [ INT_ISSUE_WIDTH ];\n\n    for ( genvar i = 0; i < INT_ISSUE_WIDTH; i++ ) begin : BlockALU\n        IntALU intALU(\n            .aluCode ( aluCode[i] ),\n            .fuOpA_In ( fuOpA[i].data ),\n            .fuOpB_In ( fuOpB[i].data ),\n            .aluDataOut ( aluDataOut[i] )\n        );\n    end\n\n    // Shifter\n    ShiftOperandType shiftOperandType [ INT_ISSUE_WIDTH ];\n    RISCV_IntOperandImmShift shiftImmIn [ INT_ISSUE_WIDTH ];\n    DataPath shiftDataOut [ INT_ISSUE_WIDTH ];\n    logic shiftCarryOut [ INT_ISSUE_WIDTH ];\n\n    for ( genvar i = 0; i < INT_ISSUE_WIDTH; i++ ) begin : BlockShifter\n        Shifter shifter(\n            .shiftOperandType( shiftOperandType[i] ),\n            .shiftType( shiftImmIn[i].shiftType ),\n            .immShiftAmount( shiftImmIn[i].shift ),\n            .regShiftAmount( fuOpB[i][SHIFT_AMOUNT_BIT_SIZE-1:0] ),\n            .dataIn( fuOpA[i].data ),\n            .carryIn( 1'b0 ),\n            .dataOut( shiftDataOut[i] ),\n            .carryOut( shiftCarryOut[i] )\n        );\n    end\n\n    // Branch\n    logic isBranch [ INT_ISSUE_WIDTH ];\n    logic isJump [ INT_ISSUE_WIDTH ];\n    logic brTaken  [ INT_ISSUE_WIDTH ];\n    BranchResult brResult [ INT_ISSUE_WIDTH ];\n    logic predMiss [ INT_ISSUE_WIDTH ];\n    logic regValid [ INT_ISSUE_WIDTH ];\n\n    IntOpSubInfo intSubInfo[ INT_ISSUE_WIDTH ];\n    BrOpSubInfo  brSubInfo[ INT_ISSUE_WIDTH ];\n\n    always_comb begin\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n            iqData[i] = pipeReg[i].intQueueData;\n            intOpInfo[i] = iqData[i].intOpInfo;\n            intSubInfo[i] = intOpInfo[i].intSubInfo;\n            brSubInfo[i] = intOpInfo[i].brSubInfo;\n            pc[i] = ToAddrFromPC(iqData[i].pc);\n            flush[i] = SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        iqData[i].activeListPtr\n                        );\n\n            // \u30aa\u30da\u30e9\u30f3\u30c9\n            fuOpA[i] = ( pipeReg[i].bCtrl.rA.valid ? bypass.intSrcRegDataOutA[i] : pipeReg[i].operandA );\n            fuOpB[i] = ( pipeReg[i].bCtrl.rB.valid ? bypass.intSrcRegDataOutB[i] : pipeReg[i].operandB );\n\n            // Condition\n            isCondEnabled[i] = IsConditionEnabledInt( iqData[i].cond, fuOpA[i].data, fuOpB[i].data );\n\n            // Shifter\n            shiftOperandType[i] = intSubInfo[i].shiftType;\n            shiftImmIn[i] = intSubInfo[i].shiftIn;\n\n            // ALU\n            aluCode[i] = intSubInfo[i].aluCode;\n\n            //\n            // \u30c7\u30fc\u30bf\u30a2\u30a6\u30c8\n            //\n            unique case ( iqData[i].opType )\n            INT_MOP_TYPE_ALU:       dataOut[i].data = aluDataOut[i];\n            INT_MOP_TYPE_SHIFT:     dataOut[i].data = shiftDataOut[i];\n            //INT_MOP_TYPE_BR, INT_MOP_TYPE_RIJ :        dataOut[i].data = ToPC_FromAddr(pc[i] + PC_OPERAND_OFFSET);\n            INT_MOP_TYPE_BR, INT_MOP_TYPE_RIJ :        dataOut[i].data = pc[i] + PC_OPERAND_OFFSET;\n            default: /* select */  dataOut[i].data = ( isCondEnabled[i] ? fuOpA[i].data : fuOpB[i].data );\n            endcase\n\n            // If invalid registers are read, regValid is negated and this op must be replayed.\n            regValid[i] =\n                (intSubInfo[i].operandTypeA != OOT_REG || fuOpA[i].valid ) &&\n                (intSubInfo[i].operandTypeB != OOT_REG || fuOpB[i].valid );\n            dataOut[i].valid = regValid[i];\n\n\n            //\n            // --- Bypass\n            //\n            bypass.intCtrlIn[i] = pipeReg[i].bCtrl;\n            bypass.intDstRegDataOut[i] = dataOut[i];\n\n            //\n            // --- \u5206\u5c90\n            //\n            bPred[i] = brSubInfo[i].bPred;\n            isBranch[i] = ( iqData[i].opType inside { INT_MOP_TYPE_BR, INT_MOP_TYPE_RIJ } );\n            isJump[i] = \n                (iqData[i].opType == INT_MOP_TYPE_BR && iqData[i].cond == COND_AL)\n                    || iqData[i].opType == INT_MOP_TYPE_RIJ;\n\n            // \u5206\u5c90or\u30ec\u30b8\u30b9\u30bf\u9593\u63a5\u5206\u5c90\u3067\uff0c\u6761\u4ef6\u304c\u6709\u52b9\u306a\u3089Taken\n            brTaken[i] = pipeReg[i].valid && isBranch[i] && isCondEnabled[i];\n\n            // Whether this branch is conditional one or not.\n            brResult[i].isCondBr = !isJump[i];\n            \n            // The address of a branch.\n            brResult[i].brAddr = ToPC_FromAddr(pc[i]);\n\n            // \u30bf\u30fc\u30b2\u30c3\u30c8\u30a2\u30c9\u30ec\u30b9\u306e\u8a08\u7b97\n            if( brTaken[i] ) begin\n                brResult[i].nextAddr =\n                    ToPC_FromAddr(\n                        (iqData[i].opType == INT_MOP_TYPE_BR) ?  \n                            (pc[i] + ExtendBranchDisplacement(brSubInfo[i].brDisp) ) : // \u65b9\u5411\u5206\u5c90 \n                            (AddJALR_TargetOffset(fuOpA[i].data, brSubInfo[i].brDisp) // \u30ec\u30b8\u30b9\u30bf\u9593\u63a5\u5206\u5c90 \n                        ) \n                    );\n            end\n            else begin\n                brResult[i].nextAddr = ToPC_FromAddr(pc[i] + INSN_BYTE_WIDTH);\n            end\n            brResult[i].execTaken = brTaken[i];\n            brResult[i].predTaken = bPred[i].predTaken;\n            brResult[i].valid = isBranch[i] && pipeReg[i].valid && regValid[i];\n            brResult[i].globalHistory = bPred[i].globalHistory;\n            brResult[i].phtPrevValue = bPred[i].phtPrevValue;\n                    \n            // \u4e88\u6e2c\u30df\u30b9\u5224\u5b9a\n            predMiss[i] =\n                brResult[i].valid &&\n                (\n                     (bPred[i].predTaken != brTaken[i]) ||\n                     (brTaken[i] == TRUE &&\n                      bPred[i].predAddr != brResult[i].nextAddr)\n                );\n\n            brResult[i].mispred = predMiss[i];\n        end\n    end\n\n    //\n    // --- Pipeline \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\n    //\n    IntegerRegisterWriteStageRegPath nextStage [ INT_ISSUE_WIDTH ];\n\n    always_comb begin\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n            `ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId = pipeReg[i].opId;\n            `endif\n\n            nextStage[i].intQueueData = pipeReg[i].intQueueData;\n\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            nextStage[i].valid =\n                (stall || clear || port.rst || flush[i]) ? FALSE : pipeReg[i].valid;\n\n            nextStage[i].dataOut = dataOut[i];\n\n            nextStage[i].brResult    = brResult[i];\n            nextStage[i].brMissPred  = predMiss[i];\n        end\n\n        // Output\n        port.nextStage = nextStage;\n\n        // Debug Register\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n            debug.intExReg[i].valid = pipeReg[i].valid;\n            debug.intExReg[i].flush = flush[i];\n            debug.intExReg[i].opId = pipeReg[i].opId;\n`ifdef RSD_FUNCTIONAL_SIMULATION\n            debug.intExReg[i].dataOut = dataOut[i];\n            debug.intExReg[i].fuOpA   = fuOpA[i].data;\n            debug.intExReg[i].fuOpB   = fuOpB[i].data;\n            debug.intExReg[i].aluCode  = aluCode[i];\n            debug.intExReg[i].opType  = iqData[i].opType;\n            debug.intExReg[i].brPredMiss = predMiss[i];\n`endif\n        end\n    `endif\nend\n\nendmodule : IntegerExecutionStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- IntegerExecutionStageIF\n//\n\nimport BasicTypes::*;\nimport BypassTypes::*;\nimport OpFormatTypes::*;\nimport PipelineTypes::*;\n\n\ninterface IntegerExecutionStageIF( input logic clk, rst );\n\n    // Pipeline register\n    IntegerRegisterWriteStageRegPath nextStage [ INT_ISSUE_WIDTH ];\n    \n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\nendinterface : IntegerExecutionStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for issuing ops.\n//\n\n\nimport BasicTypes::*;\nimport MicroOpTypes::*;\nimport PipelineTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport DebugTypes::*;\n\nmodule IntegerIssueStage(\n    IntegerIssueStageIF.ThisStage port,\n    ScheduleStageIF.IntNextStage prev,\n    SchedulerIF.IntegerIssueStage scheduler,\n    RecoveryManagerIF.IntegerIssueStage recovery,\n    ControllerIF.IntegerIssueStage ctrl,\n    DebugIF.IntegerIssueStage debug\n);\n\n    // --- Pipeline registers\n    IssueStageRegPath pipeReg [ INT_ISSUE_WIDTH ];\n    IssueStageRegPath nextPipeReg [ INT_ISSUE_WIDTH ];\n    always_ff@( posedge port.clk )   // synchronous rst\n    begin\n        if ( port.rst ) begin\n            for ( int i = 0; i < INT_ISSUE_WIDTH; i++ )\n                pipeReg[i] <= '0;\n        end\n        else if( !ctrl.isStage.stall )              // write data\n            pipeReg <= prev.intNextStage;\n        else\n            pipeReg <= nextPipeReg;\n    end\n\n    always_comb begin\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n            if (recovery.toRecoveryPhase) begin\n                nextPipeReg[i].valid = pipeReg[i].valid &&\n                                    !SelectiveFlushDetector(\n                                        recovery.toRecoveryPhase,\n                                        recovery.flushRangeHeadPtr,\n                                        recovery.flushRangeTailPtr,\n                                        recovery.flushAllInsns,\n                                        scheduler.intIssuedData[i].activeListPtr\n                                        );\n            end\n            else begin\n                nextPipeReg[i].valid = pipeReg[i].valid;\n            end\n            nextPipeReg[i].issueQueuePtr = pipeReg[i].issueQueuePtr;\n        end\n    end\n\n    // Pipeline controll\n    logic stall, clear;\n    logic flush[ INT_ISSUE_WIDTH ];\n    logic valid [ INT_ISSUE_WIDTH ];\n    IntegerRegisterReadStageRegPath nextStage [ INT_ISSUE_WIDTH ];\n    IntIssueQueueEntry issuedData [ INT_ISSUE_WIDTH ];\n    IssueQueueIndexPath issueQueuePtr [ INT_ISSUE_WIDTH ];\n\n    always_comb begin\n\n        stall = ctrl.isStage.stall;\n        clear = ctrl.isStage.clear;\n\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n\n            if (scheduler.replay) begin\n                // In this cycle, the pipeline replays ops.\n                issuedData[i] = scheduler.intReplayData[i];\n                valid[i] = scheduler.intReplayEntry[i];\n            end\n            else begin\n                // In this cycle, the pipeline issues ops.\n                issuedData[i] = scheduler.intIssuedData[i];\n                valid[i] = !stall && pipeReg[i].valid;\n            end\n\n            issueQueuePtr[i] = pipeReg[i].issueQueuePtr;\n\n            flush[i] = SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        issuedData[i].activeListPtr\n                        );\n\n            // Issue.\n            scheduler.intIssue[i] = !clear && valid[i] && !flush[i];\n            scheduler.intIssuePtr[i] = issueQueuePtr[i];\n\n            // --- Pipeline \u30e9\u30c3\u30c1\u66f8\u304d\u8fbc\u307f\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            nextStage[i].valid =\n                (clear || port.rst || flush[i]) ? FALSE : valid[i];\n            nextStage[i].intQueueData = issuedData[i];\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId = issuedData[i].opId;\n`endif\n        end\n\n        port.nextStage = nextStage;\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        // Debug Register\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n            debug.intIsReg[i].valid = valid[i];\n            debug.intIsReg[i].flush = flush[i];\n            debug.intIsReg[i].opId = issuedData[i].opId;\n        end\n`endif\n    end\n\n\nendmodule : IntegerIssueStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- IntegerIssueStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface IntegerIssueStageIF( input logic clk, rst );\n    \n    // Pipeline register\n    IntegerRegisterReadStageRegPath nextStage [ INT_ISSUE_WIDTH ];\n    \n    \n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\n\nendinterface : IntegerIssueStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for register read.\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\n\n//\n// --- Immediate\n//\nfunction automatic DataPath RISCV_OpImm(\n    RISCV_IntOperandImmShift intOperandImm\n);\n\n    // Todo: optimize\n    DataPath result;\n    case( intOperandImm.immType )\n        //RISCV_IMM_I : begin\n        default : begin\n            result   = { {12{intOperandImm.imm[19]}}, intOperandImm.imm };\n        end\n        RISCV_IMM_U : begin\n            result   = { intOperandImm.imm, 12'h0 };\n        end\n    endcase // immType\n    return result;\nendfunction : RISCV_OpImm\n\n\n//\n// --- \u30aa\u30da\u30e9\u30f3\u30c9\u306e\u9078\u629e\n//\n\nfunction automatic DataPath SelectOperandIntReg(\ninput\n    OpOperandType opType, DataPath regV, DataPath immV, DataPath pcV\n);\n    case( opType )\n    default:    // OOT_REG\n        return regV;\n    OOT_IMM:\n        return immV;\n    OOT_PC:\n        return pcV;\n    endcase\nendfunction\n\n//\n// --- Integer Register Read Stage\n//\nmodule IntegerRegisterReadStage(\n    IntegerRegisterReadStageIF.ThisStage port,\n    IntegerIssueStageIF.NextStage prev,\n    RegisterFileIF.IntegerRegisterReadStage registerFile,\n    BypassNetworkIF.IntegerRegisterReadStage bypass,\n    RecoveryManagerIF.IntegerRegisterReadStage recovery,\n    ControllerIF.IntegerRegisterReadStage ctrl,\n    DebugIF.IntegerRegisterReadStage debug\n);\n\n    // --- Pipeline registers\n    IntegerRegisterReadStageRegPath pipeReg [INT_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n\n    always_ff@(posedge port.clk)   // synchronous rst\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= FALSE;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin              // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n    // Operand\n    DataPath immOut [ INT_ISSUE_WIDTH ];\n    AddrPath pc [ INT_ISSUE_WIDTH ];\n    PRegDataPath operandA [ INT_ISSUE_WIDTH ];\n    PRegDataPath operandB [ INT_ISSUE_WIDTH ];\n\n    // Pipeline control\n    logic stall, clear;\n    logic flush[ INT_ISSUE_WIDTH ];\n    IntIssueQueueEntry iqData[INT_ISSUE_WIDTH];\n    IntOpSubInfo intSubInfo[INT_ISSUE_WIDTH];\n    OpSrc opSrc[INT_ISSUE_WIDTH];\n    OpDst opDst[INT_ISSUE_WIDTH];\n    IntegerExecutionStageRegPath nextStage[INT_ISSUE_WIDTH];\n\n    always_comb begin\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n            iqData[i] = pipeReg[i].intQueueData;\n            intSubInfo[i] = iqData[i].intOpInfo.intSubInfo;\n            opSrc[i] = iqData[i].opSrc;\n            opDst[i] = iqData[i].opDst;\n            pc[i] = ToAddrFromPC(iqData[i].pc);\n\n            //\n            // To the register file.\n            //\n            registerFile.intSrcRegNumA[i] = opSrc[i].phySrcRegNumA;\n            registerFile.intSrcRegNumB[i] = opSrc[i].phySrcRegNumB;\n\n            //\n            // To the bypass network.\n            // \u30b9\u30c8\u30fc\u30eb\u3084\u30d5\u30e9\u30c3\u30b7\u30e5\u306e\u5236\u5fa1\u306f\uff0cBypass \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u5185\u90e8\u3067\n            // \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306e\u4fe1\u53f7\u3092\u53c2\u7167\u3057\u3066\u884c\u308f\u308c\u3066\u3044\u308b\n            //\n            bypass.intPhySrcRegNumA[i] = opSrc[i].phySrcRegNumA;\n            bypass.intPhySrcRegNumB[i] = opSrc[i].phySrcRegNumB;\n\n            bypass.intWriteReg[i]  = opDst[i].writeReg & pipeReg[i].valid;\n            bypass.intPhyDstRegNum[i] = opDst[i].phyDstRegNum;\n            bypass.intReadRegA[i] = ( intSubInfo[i].operandTypeA == OOT_REG );\n            bypass.intReadRegB[i] = ( intSubInfo[i].operandTypeB == OOT_REG );\n\n            //\n            // --- \u30aa\u30da\u30e9\u30f3\u30c9\u9078\u629e\n            //\n            immOut[i] = RISCV_OpImm(\n                .intOperandImm( intSubInfo[i].shiftIn )\n            );\n            operandA[i].data = SelectOperandIntReg(\n                intSubInfo[i].operandTypeA,\n                registerFile.intSrcRegDataA[i].data,\n                immOut[i],\n                pc[i]\n            );\n            operandB[i].data = SelectOperandIntReg(\n                intSubInfo[i].operandTypeB,\n                registerFile.intSrcRegDataB[i].data,\n                immOut[i],\n                pc[i]\n            );\n            operandA[i].valid = (intSubInfo[i].operandTypeA != OOT_REG || registerFile.intSrcRegDataA[i].valid);\n            operandB[i].valid = (intSubInfo[i].operandTypeB != OOT_REG || registerFile.intSrcRegDataB[i].valid);\n\n            //\n            // --- Pipeline \u30e9\u30c3\u30c1\u66f8\u304d\u8fbc\u307f\n            //\n            `ifndef RSD_DISABLE_DEBUG_REGISTER\n                nextStage[i].opId = pipeReg[i].opId;\n            `endif\n\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            flush[i] = SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        iqData[i].activeListPtr\n                        );\n            nextStage[i].valid =\n                (stall || clear || port.rst || flush[i]) ? FALSE : pipeReg[i].valid;\n\n            // \u30ec\u30b8\u30b9\u30bf\u5024&\u30d5\u30e9\u30b0\n            nextStage[i].operandA = operandA[i];\n            nextStage[i].operandB = operandB[i];\n\n            // Issue queue data\n            nextStage[i].intQueueData = pipeReg[i].intQueueData;\n\n            // \u30d0\u30a4\u30d1\u30b9\u5236\u5fa1\n            nextStage[i].bCtrl = bypass.intCtrlOut[i];\n\n        end\n        port.nextStage = nextStage;\n\n        // Debug Register\n        `ifndef RSD_DISABLE_DEBUG_REGISTER\n            for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n                debug.intRrReg[i].valid = pipeReg[i].valid;\n                debug.intRrReg[i].flush = flush[i];\n                debug.intRrReg[i].opId = pipeReg[i].opId;\n            end\n        `endif\n    end\n\n    generate\n        for (genvar i = 0; i < INT_ISSUE_WIDTH; i++) begin\n            `RSD_ASSERT_CLK(\n                port.clk,\n                intSubInfo[i].operandTypeA == iqData[i].intOpInfo.brSubInfo.operandTypeA && \n                intSubInfo[i].operandTypeB == iqData[i].intOpInfo.brSubInfo.operandTypeB,\n                \"Int sub info and Br sub info are inconsistent\"\n            );\n        end\n    endgenerate\n            \n\nendmodule : IntegerRegisterReadStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\nimport BasicTypes::*;\nimport BypassTypes::*;\nimport PipelineTypes::*;\n\n\ninterface IntegerRegisterReadStageIF( input logic clk, rst );\n    \n    // Pipeline register\n    IntegerExecutionStageRegPath nextStage [ INT_ISSUE_WIDTH ];\n\n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\n\n\nendinterface : IntegerRegisterReadStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Integer Write back stage\n//\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport RenameLogicTypes::*;\nimport PipelineTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport FetchUnitTypes::*;\nimport DebugTypes::*;\n\n\n\n\nmodule IntegerRegisterWriteStage(\n    //IntegerRegisterWriteStageIF.ThisStage port,\n    IntegerExecutionStageIF.NextStage prev,\n    SchedulerIF.IntegerRegisterWriteStage scheduler,\n    NextPCStageIF.IntegerRegisterWriteStage ifStage,\n    RegisterFileIF.IntegerRegisterWriteStage registerFile,\n    ActiveListIF.IntegerRegisterWriteStage activeList,\n    RecoveryManagerIF.IntegerRegisterWriteStage recovery,\n    ControllerIF.IntegerRegisterWriteStage ctrl,\n    DebugIF.IntegerRegisterWriteStage debug\n);\n    IntegerRegisterWriteStageRegPath pipeReg [INT_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n\n    // --- Pipeline registers\n    always_ff@( posedge /*port.clk*/ ctrl.clk )   // synchronous rst\n    begin\n        if (ctrl.rst) begin\n            for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= FALSE;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin   // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n    ActiveListWriteData alWriteData[INT_ISSUE_WIDTH];\n    IntIssueQueueEntry iqData[INT_ISSUE_WIDTH];\n    BranchResult brResult[INT_ISSUE_WIDTH];\n    logic stall, clear;\n    logic flush[ INT_ISSUE_WIDTH ];\n    logic update [ INT_ISSUE_WIDTH ];\n    logic valid [ INT_ISSUE_WIDTH ];\n    logic regValid [ INT_ISSUE_WIDTH ];\n\n    always_comb begin\n\n        // Pipeline control\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n            iqData[i] = pipeReg[i].intQueueData;\n            regValid[i] = pipeReg[i].dataOut.valid;\n\n            valid[i] = pipeReg[i].valid;\n            flush[i] = SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        iqData[i].activeListPtr\n                        );\n            update[i] = !stall && !clear && valid[i] && !flush[i];\n\n            //\n            // Register file\n            //\n            registerFile.intDstRegWE[i] =\n                update[i] && iqData[i].opDst.writeReg;\n\n            registerFile.intDstRegNum[i] = iqData[i].opDst.phyDstRegNum;\n            registerFile.intDstRegData[i] = pipeReg[i].dataOut;\n\n            //\n            // Active list\n            //\n            alWriteData[i].ptr = iqData[i].activeListPtr;\n            alWriteData[i].loadQueuePtr = iqData[i].loadQueueRecoveryPtr;\n            alWriteData[i].storeQueuePtr = iqData[i].storeQueueRecoveryPtr;\n            alWriteData[i].pc = pipeReg[i].brResult.nextAddr;\n            alWriteData[i].dataAddr = '0;\n            alWriteData[i].isBranch = (iqData[i].opType inside { INT_MOP_TYPE_BR, INT_MOP_TYPE_RIJ });\n            alWriteData[i].isStore = FALSE;\n\n            // Branch results.\n            brResult[i] = pipeReg[i].brResult;\n            brResult[i].valid = pipeReg[i].brResult.valid && update[i] && regValid[i];\n            ifStage.brResult = brResult;\n\n            // ExecState\n            if ( update[i] ) begin\n                if (regValid[i]) begin\n                    alWriteData[i].state =\n                        pipeReg[i].brMissPred ? EXEC_STATE_REFETCH_NEXT : EXEC_STATE_SUCCESS;\n                end\n                else begin\n                    alWriteData[i].state = EXEC_STATE_NOT_FINISHED;\n                end\n            end\n            else begin\n                alWriteData[i].state = EXEC_STATE_NOT_FINISHED;\n            end\n\n\n            // \u5b9f\u884c\u304c\u6b63\u3057\u304f\u7d42\u4e86\u3057\u3066\u308b\u5834\u5408\uff0c\u30d5\u30a9\u30fc\u30eb\u30c8\u5224\u5b9a\u3092\u884c\u3046\n            if (alWriteData[i].state inside {EXEC_STATE_REFETCH_NEXT, EXEC_STATE_SUCCESS}) begin\n                if (brResult[i].nextAddr[INSN_ADDR_BIT_WIDTH-1:0] != 0 && brResult[i].valid) begin\n                    alWriteData[i].state = EXEC_STATE_FAULT_INSN_MISALIGNED;\n                    alWriteData[i].dataAddr = brResult[i].nextAddr;\n                end\n            end\n\n            activeList.intWrite[i] = update[i];\n            activeList.intWriteData[i] = alWriteData[i];\n\n            // Replay\n            scheduler.intRecordEntry[i] = update[i] && !regValid[i];\n            scheduler.intRecordData[i] = pipeReg[i].intQueueData;\n        end\n\n        // Debug Register\n        `ifndef RSD_DISABLE_DEBUG_REGISTER\n            for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n                debug.intRwReg[i].valid = valid[i];\n                debug.intRwReg[i].flush = flush[i];\n                debug.intRwReg[i].opId = pipeReg[i].opId;\n            end\n        `endif\n    end\nendmodule : IntegerRegisterWriteStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- IntegerRegisterWritePipeIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface IntegerRegisterWriteStageIF( input logic clk, rst );\n    \n    modport ThisStage(\n    input\n        clk,\n        rst\n    );\n\nendinterface : IntegerRegisterWriteStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// UI Unit\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport LoadStoreUnitTypes::*;\nimport MemoryMapTypes::*;\nimport IO_UnitTypes::*;\nimport DebugTypes::*;\n\nmodule IO_Unit(\n    IO_UnitIF.IO_Unit port,\n    CSR_UnitIF.IO_Unit csrUnit\n);\n\n    // Timer register\n    TimerRegsters tmReg;\n    TimerRegsters tmNext;\n    always_ff@(posedge port.clk) begin\n        if (port.rst) begin\n            tmReg <= '0;\n        end\n        else begin\n            tmReg <= tmNext;\n        end\n    end\n\n    PhyRawAddrPath phyRawReadAddr, phyRawWriteAddr;\n\n    always_comb begin\n        phyRawReadAddr = port.ioReadAddrIn.addr;\n        phyRawWriteAddr = port.ioWriteAddrIn.addr;\n\n        // Update timer\n        tmNext = tmReg;\n        tmNext.mtime.raw = tmNext.mtime.raw + 1;\n\n        // Generate a timer interrupt signal\n        csrUnit.reqTimerInterrupt = \n            tmNext.mtime.raw >= tmNext.mtimecmp.raw ? TRUE : FALSE;\n        //$display(\"time, cmp: %d, %d\", tmNext.mtime.raw, tmNext.mtimecmp.raw);\n\n        // Write a timer regsiter\n        if (port.ioWE) begin\n            //$display(\"IO write %0x: %0x\", port.ioWriteAddrIn, port.ioWriteDataIn);\n            if (phyRawWriteAddr == PHY_ADDR_TIMER_LOW) begin\n                tmNext.mtime.split.low = port.ioWriteDataIn;\n            end\n            else if (phyRawWriteAddr == PHY_ADDR_TIMER_HI) begin\n                tmNext.mtime.split.hi = port.ioWriteDataIn;\n            end\n            else if (phyRawWriteAddr == PHY_ADDR_TIMER_CMP_LOW) begin\n                tmNext.mtimecmp.split.low = port.ioWriteDataIn;\n            end\n            else if (phyRawWriteAddr == PHY_ADDR_TIMER_CMP_HI) begin\n                tmNext.mtimecmp.split.hi = port.ioWriteDataIn;\n            end\n            //$display(tmNext.mtime.raw);\n            //$display(tmNext.mtimecmp.raw);\n        end\n\n        // Read a timer rigister\n        if (phyRawReadAddr == PHY_ADDR_TIMER_LOW) begin\n            port.ioReadDataOut = tmReg.mtime.split.low;\n        end\n        else if (phyRawReadAddr == PHY_ADDR_TIMER_HI) begin\n            port.ioReadDataOut = tmReg.mtime.split.hi;\n        end\n        else if (phyRawReadAddr == PHY_ADDR_TIMER_CMP_LOW) begin\n            port.ioReadDataOut = tmReg.mtimecmp.split.low;\n        end\n        else begin\n            //if (port.ioReadAddrIn == PHY_ADDR_TIMER_CMP_HI) begin\n            port.ioReadDataOut = tmReg.mtimecmp.split.hi;\n        end\n    end\n\n\n    always_comb begin\n        // Serial IO\n        port.serialWE = FALSE;\n        port.serialWriteDataOut = port.ioWriteDataIn[SERIAL_OUTPUT_WIDTH-1 : 0];\n        if (port.ioWE && phyRawWriteAddr == PHY_ADDR_SERIAL_OUTPUT) begin\n            port.serialWE = TRUE;\n        end\n    end\nendmodule\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// The interface of a load/store unit.\n//\n\n\nimport BasicTypes::*;\nimport LoadStoreUnitTypes::*;\nimport IO_UnitTypes::*;\nimport MemoryMapTypes::*;\n\ninterface IO_UnitIF(\n    input \n        logic clk, rst, rstStart,\n    output\n        logic serialWE,\n        SerialDataPath serialWriteDataOut\n);\n    // Write request from a store qeueue \n    logic ioWE;\n    DataPath ioWriteDataIn;\n    PhyAddrPath ioWriteAddrIn;\n\n    // Read request from a load pipeline\n    DataPath ioReadDataOut;\n    PhyAddrPath ioReadAddrIn;\n\n    modport IO_Unit(\n    input \n        clk, rst, rstStart,\n        ioWE,\n        ioWriteDataIn,\n        ioWriteAddrIn,\n        ioReadAddrIn,\n    output\n        ioReadDataOut,\n        serialWE,\n        serialWriteDataOut\n    );\n\n    modport MemoryAccessStage(\n    input \n        ioReadDataOut,\n    output\n        ioReadAddrIn\n    );\n\n    modport StoreCommitter(\n    output\n        ioWE,\n        ioWriteDataIn,\n        ioWriteAddrIn\n    );\n\n\nendinterface : IO_UnitIF\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n// \n// --- Types related to IO_Unit\n//\n\npackage IO_UnitTypes;\n\nimport BasicTypes::*;\n\n// Timer related definitions\nlocalparam TIMER_REGISTER_WIDTH = 64;\ntypedef logic [TIMER_REGISTER_WIDTH-1:0] TimerRegisterRawPath;\n\ntypedef struct packed{    // struct TimerRegisterSplitPath\n    DataPath hi;\n    DataPath low;\n} TimerRegisterSplitPath;\n\ntypedef union packed {\n    TimerRegisterRawPath raw;\n    TimerRegisterSplitPath split;\n} TimerRegisterPath;\n\ntypedef struct packed {\n    TimerRegisterPath mtime;\n    TimerRegisterPath mtimecmp;\n} TimerRegsters;\n\n\n//\n// --- LED IO\n//\n`ifndef RSD_SYNTHESIS\nlocalparam LED_WIDTH = 16;\n`elsif RSD_SYNTHESIS_ZEDBOARD\nlocalparam LED_WIDTH = 8;\n`else\nlocalparam LED_WIDTH = 16;\n`endif\ntypedef logic [ LED_WIDTH-1:0 ] LED_Path;\n\n// Serial IO\n`ifdef RSD_SYNTHESIS_FPGA\n    localparam SERIAL_OUTPUT_WIDTH = 8;\n`else\n    localparam SERIAL_OUTPUT_WIDTH = 32;\n`endif\ntypedef logic [ SERIAL_OUTPUT_WIDTH-1:0 ] SerialDataPath;\n\n\n\nendpackage\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Load queue\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport LoadStoreUnitTypes::*;\n\n// Convert a pointer of an active list to an \"age.\"\n// An \"age\" is directly compared with a comparator.\nfunction automatic LoadQueueCountPath LoadQueuePtrToAge(LoadQueueIndexPath ptr, LoadQueueIndexPath head);\n    LoadQueueCountPath age;\n    age = ptr;\n    if (ptr < head)\n        return age + LOAD_QUEUE_ENTRY_NUM; // Wrap around.\n    else\n        return age;\nendfunction\n\nmodule LoadQueue(\n    LoadStoreUnitIF.LoadQueue port,\n    RecoveryManagerIF.LoadQueue recovery\n);\n\n    logic reset;\n\n    // Head and tail pointers.\n    // This head pointer refers the next entry of the last valid entry.\n    LoadQueueIndexPath headPtr;\n    LoadQueueIndexPath tailPtr;\n\n    // FIFO controller.\n    logic push; // push request.\n    RenameLaneCountPath pushCount;  // pushed count.\n    LoadQueueCountPath curCount;    // current size.\n    SetTailMultiWidthQueuePointer #(LOAD_QUEUE_ENTRY_NUM, 0, 0, 0, RENAME_WIDTH, COMMIT_WIDTH)\n        loadQueuePointer(\n            .clk(port.clk),\n            .rst(reset),\n            .pop(port.releaseLoadQueue),\n            .popCount(port.releaseLoadQueueEntryNum),\n            .push(push),\n            .pushCount(pushCount),\n            .setTail(recovery.toRecoveryPhase),\n            .setTailPtr(recovery.loadQueueRecoveryTailPtr),\n            .count(curCount),\n            .headPtr(headPtr),\n            .tailPtr(tailPtr)\n        );\n\n    always_comb begin\n        // Generate push signals.\n        pushCount = 0;\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            if (tailPtr + pushCount < LOAD_QUEUE_ENTRY_NUM) begin\n                port.allocatedLoadQueuePtr[i] = tailPtr + pushCount;\n            end\n            else begin\n                // Out of range of load queue\n                port.allocatedLoadQueuePtr[i] = \n                    tailPtr + pushCount - LOAD_QUEUE_ENTRY_NUM;\n            end\n            pushCount += port.allocateLoadQueue[i];\n        end\n        push = pushCount > 0;\n\n        // All entries are not used for avoiding head==tail problem.\n        port.loadQueueAllocatable =\n            (curCount <= LOAD_QUEUE_ENTRY_NUM - RENAME_WIDTH - 1) ? TRUE : FALSE;\n\n        recovery.loadQueueHeadPtr = headPtr;\n    end\n\n\n\n    // Address and finish flag storage.\n    LoadQueueEntry      loadQueue[LOAD_QUEUE_ENTRY_NUM];\n    LoadQueueIndexPath  executedLoadQueuePtrByLoad[LOAD_ISSUE_WIDTH];\n    LSQ_BlockAddrPath   executedLoadAddr[LOAD_ISSUE_WIDTH];\n    LSQ_BlockWordEnablePath executedLoadWordRE[LOAD_ISSUE_WIDTH];\n    logic executedLoadRegValid[LOAD_ISSUE_WIDTH];\n    always_ff @(posedge port.clk) begin\n        if (reset) begin\n            for (int i = 0; i < LOAD_QUEUE_ENTRY_NUM; i++) begin\n                loadQueue[i].finished <= FALSE;\n            end\n        end\n        else begin\n            for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n                if (port.executeLoad[i]) begin\n                    loadQueue[ executedLoadQueuePtrByLoad[i] ].regValid <= executedLoadRegValid[i];\n                    loadQueue[ executedLoadQueuePtrByLoad[i] ].finished <= TRUE;\n                    loadQueue[ executedLoadQueuePtrByLoad[i] ].address <= executedLoadAddr[i];\n                    loadQueue[ executedLoadQueuePtrByLoad[i] ].wordRE <= executedLoadWordRE[i];\n                    loadQueue[ executedLoadQueuePtrByLoad[i] ].pc <= port.executedLoadPC[i];\n                end\n            end\n\n            for (int i = 0; i < RENAME_WIDTH; i++) begin\n                if (port.allocateLoadQueue[i]) begin\n                    loadQueue[ port.allocatedLoadQueuePtr[i] ].finished <= FALSE;\n                end\n            end\n        end\n    end\n\n    always_comb begin\n        for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n            executedLoadRegValid[i] = port.executedLoadRegValid[i];\n            executedLoadQueuePtrByLoad[i] = port.executedLoadQueuePtrByLoad[i];\n            executedLoadAddr[i] = LSQ_ToBlockAddr(port.executedLoadAddr[i]);\n            executedLoadWordRE[i] =\n                LSQ_ToBlockWordEnable(\n                    port.executedLoadAddr[i],\n                    port.executedLoadMemAccessMode[i]\n                );\n        end\n    end\n\n\n\n    // Store-load access order violation detector.\n\n    // A picker of violated entries.\n    LoadQueueIndexPath executedLoadQueuePtrByStore[STORE_ISSUE_WIDTH];\n    LoadQueueOneHotPath addrMatch[STORE_ISSUE_WIDTH];    // The outputs of address comparators.\n    LoadQueueIndexPath pickedPtr[STORE_ISSUE_WIDTH];\n    logic picked[STORE_ISSUE_WIDTH];  // This flag is true if violation is detected.\n    generate\n        for(genvar i = 0; i < STORE_ISSUE_WIDTH; i++) begin\n            CircularRangePicker #(\n                .ENTRY_NUM(LOAD_QUEUE_ENTRY_NUM)\n            ) picker(\n                .headPtr(executedLoadQueuePtrByStore[i]),\n                .tailPtr(tailPtr),\n                .request(addrMatch[i]),\n                .grantPtr(pickedPtr[i]),\n                .picked(picked[i])\n            );\n        end\n    endgenerate\n\n    // This flags are TRUE if violation is detected.\n    logic violation[STORE_ISSUE_WIDTH];\n\n    // The addresses of executed stores/loads.\n    LSQ_BlockAddrPath executedStoreAddr[STORE_ISSUE_WIDTH];\n    LSQ_BlockWordEnablePath executedStoreWordWE[STORE_ISSUE_WIDTH];\n\n    // This is assigned with PC of load that caused a violation with store.\n    PC_Path conflictLoadPC[STORE_ISSUE_WIDTH];\n    \n    always_comb begin\n\n        // Generate a reset signal.\n        reset = port.rst;\n\n\n        // Detect access order violation between already executed loads and\n        // a currently executed store.\n        for (int si = 0; si < STORE_ISSUE_WIDTH; si++) begin\n            violation[si] = FALSE;\n            conflictLoadPC[si] = '0;\n            executedStoreAddr[si] = LSQ_ToBlockAddr(port.executedStoreAddr[si]);\n            executedStoreWordWE[si] = LSQ_ToBlockWordEnable(\n                port.executedStoreAddr[si],\n                port.executedStoreMemAccessMode[si]\n            );\n            executedLoadQueuePtrByStore[si] = port.executedLoadQueuePtrByStore[si];\n        end\n\n        // Compares a stored address and already executed load addresses.\n        for (int si = 0; si < STORE_ISSUE_WIDTH; si++) begin\n            for (int lqe = 0; lqe < LOAD_QUEUE_ENTRY_NUM; lqe++) begin\n                addrMatch[si][lqe] =\n                    loadQueue[lqe].finished &&\n                    loadQueue[lqe].regValid &&\n                    loadQueue[lqe].address == executedStoreAddr[si] &&\n                    (loadQueue[lqe].wordRE & executedStoreWordWE[si]) != '0;\n            end\n        end\n\n        // Set address match results.\n        for (int si = 0; si < STORE_ISSUE_WIDTH; si++) begin\n            if (port.executeStore[si]) begin\n                violation[si] = picked[si];\n\n                // Violation is occurred with instruction inside load queue.\n                if (picked[si] && pickedPtr[si] < LOAD_QUEUE_ENTRY_NUM) begin\n                    // Assign write address for Memory dependent predictor\n                    // with inst which caused violation inside load queue.\n                    conflictLoadPC[si] = loadQueue[pickedPtr[si]].pc;\n                end\n            end\n            else begin\n                violation[si] = FALSE;\n            end\n        end\n\n        // Detect violation between executed loads and stores in this cycle.\n        for (int si = 0; si < STORE_ISSUE_WIDTH; si++) begin\n            for (int li = 0; li < LOAD_ISSUE_WIDTH; li++) begin\n\n                // Continue if this slot is not a load.\n                if (!port.executeLoad[li]) begin\n                    continue;\n                end\n\n                // Check an address.\n                // If the addresses of a load and a store are different, violation\n                // does not occur.\n                if (executedLoadAddr[li] != executedStoreAddr[si]) begin\n                    // \u73fe\u5728\u306f\u3001LoadStore\u306e\u30ec\u30fc\u30f3\u304csplit\u3067\u3042\u308b\u3053\u3068\u304c\u524d\u63d0\u3002\n                    // unified\u306b\u623b\u3057\u305f\u5834\u5408\u306f\u3001\u540c\u3058\u30ec\u30fc\u30f3\u306e\u30a2\u30c9\u30ec\u30b9\u3092\u6bd4\u8f03\u3057\u306a\u3044\u3088\u3046\u6ce8\u610f\u3002\n                    continue;\n                end\n\n                if ((executedLoadWordRE[li] & executedStoreWordWE[si]) == '0) begin\n                    // \u4e0a\u306e\u6bd4\u8f03\u5668\u3067\u306f\u30d9\u30af\u30bf\u5358\u4f4d\u3067\u30a2\u30c9\u30ec\u30b9\u3092\u6bd4\u8f03\u3059\u308b\u304c\u3001\n                    // \u30ef\u30fc\u30c9\u5358\u4f4d\u3067\u30a2\u30af\u30bb\u30b9\u7bc4\u56f2\u304c\u88ab\u3063\u3066\u7121\u3051\u308c\u3070\u3001\n                    // \u30d0\u30a4\u30aa\u30ec\u30fc\u30b7\u30e7\u30f3\u3068\u3057\u306a\u3044\u3002\n                    continue;\n                end\n\n                // Check orders.\n                if (LoadQueuePtrToAge(port.executedLoadQueuePtrByLoad[li], headPtr) >=\n                    LoadQueuePtrToAge(executedLoadQueuePtrByStore[si], headPtr)\n                ) begin\n                    // Violation is caused by load & store executed in this cycle.\n                    violation[si] = TRUE;\n                    conflictLoadPC[si] = port.executedLoadPC[li];\n                end\n            end\n        end\n\n        // Send write address of Memory dependent predictor with IF.\n        port.conflictLoadPC = conflictLoadPC;\n        \n        // Output violation information.\n        for (int i = 0; i < STORE_ISSUE_WIDTH; i++) begin\n            port.conflict[i] = violation[i];\n        end\n        /*\n        for (int i = STORE_ISSUE_LANE_BEGIN; i < MEM_ISSUE_WIDTH; i++) begin\n            port.conflict[i] = violation[i - STORE_ISSUE_LANE_BEGIN];\n        end\n        */\n    end\n\n    generate\n        for (genvar i = 0; i < STORE_ISSUE_WIDTH; i++) begin : assertionBlock\n            //  |----S---h***L**t----|\n            `RSD_ASSERT_CLK(\n                port.clk, \n                !(port.executeStore[i] && headPtr < tailPtr && executedLoadQueuePtrByStore[i] < headPtr),\n                \"1: A store's executedLoadQueuePtr is illegal.\"\n            );\n\n            //  |----h***L**t--S----|\n            `RSD_ASSERT_CLK(\n                port.clk, \n                 !(port.executeStore[i] && headPtr < tailPtr && tailPtr < executedLoadQueuePtrByStore[i]),\n                \"2: A store's executedLoadQueuePtr is illegal.\"\n            );\n\n            //  |******t--S--h***L***|\n            `RSD_ASSERT_CLK(\n                port.clk, \n                !(port.executeStore[i] && tailPtr <= headPtr &&\n                tailPtr < executedLoadQueuePtrByStore[i] && executedLoadQueuePtrByStore[i] < headPtr),\n                \"3: A store's executedLoadQueuePtr is illegal.\"\n            );\n        end\n    endgenerate\n\nendmodule : LoadQueue\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Load/store unit.\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport LoadStoreUnitTypes::*;\nimport MemoryMapTypes::*;\nimport DebugTypes::*;\nimport CacheSystemTypes::*;\n\nmodule LoadStoreUnit(\n    LoadStoreUnitIF.LoadStoreUnit port,\n    ControllerIF.LoadStoreUnit ctrl\n);\n    // DCache/MSHR \u306e\u30e9\u30a4\u30f3\u3068\u3057\u3066\u8aad\u3093\u3060\u30ed\u30fc\u30c9\u30c7\u30fc\u30bf\u3092\u3001\n    // \u30a2\u30c9\u30ec\u30b9\u306e\u30aa\u30d5\u30bb\u30c3\u30c8\u306b\u5408\u308f\u305b\u3066\u30b7\u30d5\u30c8\n    function automatic DataPath ShiftCacheLineData(DCacheLinePath srcLine, PhyAddrPath addr);\n        DataPath data;\n        data = srcLine >> (addr[DCACHE_LINE_BYTE_NUM_BIT_WIDTH-1:0] * 8);\n        return data;\n    endfunction\n    function automatic DataPath ShiftForwardedData(LSQ_BlockDataPath srcLine, PhyAddrPath addr);\n        DataPath data;\n        data = srcLine >> (addr[LSQ_BLOCK_BYTE_WIDTH_BIT_SIZE-1:0] * 8);\n        return data;\n    endfunction\n\n    // \u30bc\u30ed\u62e1\u5f35or\u7b26\u53f7\u62e1\u5f35\n    function automatic DataPath ExtendLoadData(DataPath loadData,MemAccessMode mode);\n        case (mode.size)\n        MEM_ACCESS_SIZE_BYTE:\n            return mode.isSigned ?\n                { { 24{ loadData[7] } }, loadData[7:0] }:\n                { { 24{ 1'b0 } }, loadData[7:0] };\n        MEM_ACCESS_SIZE_HALF_WORD:\n            return mode.isSigned ?\n                { { 16{ loadData[15] } }, loadData[15:0] } :\n                { { 16{ 1'b0 } }, loadData[15:0] };\n        default: //MEM_ACCESS_SIZE_WORD,MEM_ACCESS_SIZE_VEC:\n            return loadData;\n        endcase\n    endfunction\n\n\n    // Pipeline:\n    // ----------------------------->\n    // ADDR  | D$TAG | D$DATA | WB\n    //       |  LSQ  |        |\n    //\n    // LSQ is accessed in the D$TAG stage (MemoryTagAccessStage) and D$DATA is accessed\n    // after this stage, thus forwarded results must be latched.\n\n    logic storeLoadForwardedReg[LOAD_ISSUE_WIDTH];\n    LSQ_BlockDataPath forwardedLoadDataReg[LOAD_ISSUE_WIDTH];\n    // MSHR\u304b\u3089\u306eLoad\n    logic mshrReadHitReg[LOAD_ISSUE_WIDTH];\n    DCacheLinePath mshrReadDataReg[LOAD_ISSUE_WIDTH];\n\n    AddrPath loadAddrReg[LOAD_ISSUE_WIDTH];\n    MemAccessMode loadMemAccessSizeReg[LOAD_ISSUE_WIDTH];\n\n    always_ff@(posedge port.clk)\n    begin\n        for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n            if (port.rst) begin\n                storeLoadForwardedReg[i] <= FALSE;\n                forwardedLoadDataReg[i] <= '0;\n                mshrReadHitReg[i] <= FALSE;\n                mshrReadDataReg[i] <= '0;\n                loadAddrReg[i] <= '0;\n                loadMemAccessSizeReg[i] <= MEM_ACCESS_SIZE_BYTE;\n            end\n            else if (!ctrl.backEnd.stall) begin\n                storeLoadForwardedReg[i] <= port.storeLoadForwarded[i];\n                forwardedLoadDataReg[i] <= port.forwardedLoadData[i];\n                mshrReadHitReg[i] <= port.mshrReadHit[i];\n                mshrReadDataReg[i] <= port.mshrReadData[i];\n                loadAddrReg[i] <=  port.executedLoadAddr[i];\n                loadMemAccessSizeReg[i] <= port.executedLoadMemAccessMode[i];\n            end\n        end\n    end\n\n\n    LSQ_BlockDataPath loadLSQ_BlockData[LOAD_ISSUE_WIDTH];\n    DataPath shiftedLoadData[LOAD_ISSUE_WIDTH];\n    DataPath extendedLoadData[LOAD_ISSUE_WIDTH];\n    always_comb begin\n        for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n            port.executedLoadVectorData[i] = 0;\n        end\n        \n        for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n            loadLSQ_BlockData[i] = \n                storeLoadForwardedReg[i] ? forwardedLoadDataReg[i] :\n                mshrReadHitReg[i] ? mshrReadDataReg[i] :\n                                    port.dcReadData[i];\n            port.executedLoadVectorData[i] = loadLSQ_BlockData[i];\n\n            shiftedLoadData[i] = \n                storeLoadForwardedReg[i] ? ShiftForwardedData(forwardedLoadDataReg[i], loadAddrReg[i]) :\n                mshrReadHitReg[i] ? ShiftCacheLineData(mshrReadDataReg[i], loadAddrReg[i]) :\n                                    ShiftCacheLineData(port.dcReadData[i], loadAddrReg[i]);\n            extendedLoadData[i] = ExtendLoadData(shiftedLoadData[i], loadMemAccessSizeReg[i]);\n        end\n\n        port.executedLoadData = extendedLoadData;\n    end\n\n\n    // From the rename stage.\n    always_comb begin\n        port.allocatable = port.loadQueueAllocatable &&    \n            port.storeQueueAllocatable && !port.busyInRecovery;\n    end\n\nendmodule : LoadStoreUnit\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// The interface of a load/store unit.\n//\n\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport CacheSystemTypes::*;\nimport OpFormatTypes::*;\nimport LoadStoreUnitTypes::*;\nimport MemoryMapTypes::*;\nimport ActiveListIndexTypes::*;\n\ninterface LoadStoreUnitIF( input logic clk, rst, rstStart );\n\n    // Allocation\n    logic allocatable;\n    logic loadQueueAllocatable;\n    logic storeQueueAllocatable;\n    logic allocateLoadQueue [ RENAME_WIDTH ];\n    logic allocateStoreQueue [ RENAME_WIDTH ];\n    LoadQueueIndexPath allocatedLoadQueuePtr [ RENAME_WIDTH ];\n    StoreQueueIndexPath allocatedStoreQueuePtr [ RENAME_WIDTH ];\n\n    // Execution\n    logic executeLoad [ LOAD_ISSUE_WIDTH ];\n    logic executedLoadRegValid [LOAD_ISSUE_WIDTH];\n    PhyAddrPath executedLoadAddr [ LOAD_ISSUE_WIDTH ];\n    MemoryMapType executedLoadMemMapType [ LOAD_ISSUE_WIDTH ];\n    DataPath executedLoadData [ LOAD_ISSUE_WIDTH ];\n    PC_Path executedLoadPC  [LOAD_ISSUE_WIDTH ];\n    VectorPath executedLoadVectorData [ LOAD_ISSUE_WIDTH ];\n    MemAccessMode executedLoadMemAccessMode [ LOAD_ISSUE_WIDTH ];\n    StoreQueueIndexPath executedStoreQueuePtrByLoad [ LOAD_ISSUE_WIDTH ];\n    LoadQueueIndexPath executedLoadQueuePtrByLoad[ LOAD_ISSUE_WIDTH ];\n\n    logic executeStore [ STORE_ISSUE_WIDTH ];\n    logic executedStoreCondEnabled [ STORE_ISSUE_WIDTH ];\n    logic executedStoreRegValid [ STORE_ISSUE_WIDTH ];\n    PhyAddrPath executedStoreAddr [ STORE_ISSUE_WIDTH ];\n    DataPath executedStoreData [ STORE_ISSUE_WIDTH ];\n    VectorPath executedStoreVectorData [ STORE_ISSUE_WIDTH ];\n    MemAccessMode executedStoreMemAccessMode [ STORE_ISSUE_WIDTH ];\n    LoadQueueIndexPath executedLoadQueuePtrByStore [ STORE_ISSUE_WIDTH ];\n    StoreQueueIndexPath executedStoreQueuePtrByStore [ STORE_ISSUE_WIDTH ];\n\n    // Commit\n    logic commitStore;\n    CommitLaneCountPath commitStoreNum;\n\n    // Retire\n    logic releaseLoadQueue;\n    CommitLaneCountPath releaseLoadQueueEntryNum;\n\n\n    // Whether to release the head entry(s) of the SQ.\n    logic releaseStoreQueueHead;    // For commit\n\n    // The number of released entries.\n    CommitLaneCountPath releaseStoreQueueHeadEntryNum;  // For commit\n\n\n    // \u30b9\u30c8\u30a2\u7d50\u679c\u3092\u30ad\u30e3\u30c3\u30b7\u30e5\u306b\u66f8\u304d\u8fbc\u3080\u969b\u306b SQ \u304b\u3089\u8aad\u307f\u51fa\u3059\u30c7\u30fc\u30bf\n    StoreQueueIndexPath retiredStoreQueuePtr;\n    LSQ_BlockDataPath retiredStoreData;\n    logic retiredStoreCondEnabled;\n    LSQ_BlockWordEnablePath retiredStoreWordWE;\n    LSQ_WordByteEnablePath retiredStoreByteWE;\n    LSQ_BlockAddrPath retiredStoreLSQ_BlockAddr;\n\n    // SQ status.\n    logic storeQueueEmpty;\n    StoreQueueIndexPath storeQueueHeadPtr;\n    StoreQueueCountPath storeQueueCount;\n\n    // Recover\n    logic busyInRecovery;\n\n\n    // Store-Load Forwarding\n    logic storeLoadForwarded [ LOAD_ISSUE_WIDTH ];\n    LSQ_BlockDataPath forwardedLoadData [ LOAD_ISSUE_WIDTH ];\n    logic forwardMiss[ LOAD_ISSUE_WIDTH ];\n    \n    // DCache\n    logic dcReadReq[LOAD_ISSUE_WIDTH];    // Read request from the LSU.\n    logic dcReadBusy[LOAD_ISSUE_WIDTH];   // Read ports are busy and cannot accept requests.\n    logic dcReadHit[LOAD_ISSUE_WIDTH];\n\n    PhyAddrPath dcReadAddr[LOAD_ISSUE_WIDTH];\n    DCacheLinePath dcReadData[LOAD_ISSUE_WIDTH];\n    logic dcReadUncachable[LOAD_ISSUE_WIDTH];\n    ActiveListIndexPath dcReadActiveListPtr[LOAD_ISSUE_WIDTH];\n\n    // MSHR\u3092Allocate\u3057\u305f\u547d\u4ee4\u304b\u3069\u3046\u304b\n    logic loadHasAllocatedMSHR[DCACHE_LSU_READ_PORT_NUM];\n    MSHR_IndexPath loadMSHRID[DCACHE_LSU_READ_PORT_NUM];\n    logic storeHasAllocatedMSHR[DCACHE_LSU_WRITE_PORT_NUM];\n    MSHR_IndexPath storeMSHRID[DCACHE_LSU_WRITE_PORT_NUM];\n\n    logic dcWriteReq;     // Same as the read signals.\n    logic dcWriteReqAck;\n    logic dcWriteBusy;\n    logic dcWriteHit;\n    PhyAddrPath dcWriteAddr;\n    DCacheLinePath dcWriteData;\n    DCacheByteEnablePath dcWriteByteWE;\n    logic dcWriteUncachable;\n\n    // MSHR\u304b\u3089\u306eLoad\n    logic mshrAddrHit[LOAD_ISSUE_WIDTH];\n    MSHR_IndexPath mshrAddrHitMSHRID[LOAD_ISSUE_WIDTH];\n    logic mshrReadHit[LOAD_ISSUE_WIDTH];\n    DCacheLinePath mshrReadData[LOAD_ISSUE_WIDTH];\n\n    // MSHR\u3092Allocate\u3057\u305f\u547d\u4ee4\u304b\u3089\u306e\u30e1\u30e2\u30ea\u30ea\u30af\u30a8\u30b9\u30c8\u304b\u3069\u3046\u304b\n    // \u305d\u306e\u30ea\u30af\u30a8\u30b9\u30c8\u304c\u30a2\u30af\u30bb\u30b9\u306b\u6210\u529f\u3057\u305f\u5834\u5408\uff0cAllocate\u3055\u308c\u305fMSHR\u306f\u89e3\u653e\u53ef\u80fd\u306b\u306a\u308b\n    logic makeMSHRCanBeInvalidDirect[MSHR_NUM];\n\n    // MSHR\n    logic mshrValid[MSHR_NUM];\n    MSHR_Phase mshrPhase[MSHR_NUM]; // MSHR phase.\n\n    // Memory dependent prediction\n    logic conflict [ STORE_ISSUE_WIDTH ];\n    logic memAccessOrderViolation [ STORE_ISSUE_WIDTH ];\n    PC_Path conflictLoadPC [ STORE_ISSUE_WIDTH ];\n    \n    modport DCache(\n    input\n        clk,\n        rst,\n        rstStart,\n        dcReadReq,\n        dcWriteReq,\n        dcWriteData,\n        dcWriteAddr,\n        dcWriteByteWE,\n        dcWriteUncachable,\n        dcReadAddr,\n        dcReadUncachable,\n        dcReadActiveListPtr,\n        makeMSHRCanBeInvalidDirect,\n    output\n        dcReadHit,\n        dcReadBusy,\n        dcReadData,\n        dcWriteHit,\n        dcWriteBusy,\n        dcWriteReqAck,\n        mshrAddrHit,\n        mshrAddrHitMSHRID,\n        mshrReadHit,\n        mshrReadData,\n        mshrValid,\n        mshrPhase,\n        loadHasAllocatedMSHR,\n        loadMSHRID,\n        storeHasAllocatedMSHR,\n        storeMSHRID\n    );\n\n\n\n    modport LoadQueue(\n    input\n        clk,\n        rst,\n        allocateLoadQueue,\n        executeLoad,\n        executedLoadQueuePtrByLoad,\n        executedLoadQueuePtrByStore,\n        executedLoadAddr,\n        executedLoadPC,\n        executedLoadRegValid,\n        executedStoreAddr,\n        executeStore,\n        executedLoadMemAccessMode,\n        releaseLoadQueue,\n        releaseLoadQueueEntryNum,\n        executedStoreMemAccessMode,\n    output\n        allocatedLoadQueuePtr,\n        loadQueueAllocatable,\n        conflict,\n        conflictLoadPC\n    );\n\n    modport StoreQueue(\n    input\n        clk,\n        rst,\n        allocateStoreQueue,\n        executeLoad,\n        executedLoadAddr,\n        executedLoadMemMapType,\n        executeStore,\n        executedStoreQueuePtrByLoad,\n        executedStoreQueuePtrByStore,\n        executedStoreAddr,\n        executedStoreData,\n        executedStoreVectorData,\n        executedStoreCondEnabled,\n        executedStoreRegValid,\n        executedStoreMemAccessMode,\n        releaseStoreQueueHead,\n        releaseStoreQueueHeadEntryNum,\n        retiredStoreQueuePtr,\n        executedLoadMemAccessMode,\n    output\n        allocatedStoreQueuePtr,\n        storeQueueAllocatable,\n        storeLoadForwarded,\n        forwardedLoadData,\n        forwardMiss,\n        retiredStoreData,\n        retiredStoreCondEnabled,\n        retiredStoreWordWE,\n        retiredStoreByteWE,\n        retiredStoreLSQ_BlockAddr,\n        storeQueueEmpty,\n        storeQueueCount,\n        storeQueueHeadPtr\n    );\n\n    modport StoreCommitter(\n    input\n        clk,\n        rst,\n        commitStore,\n        commitStoreNum,\n        retiredStoreCondEnabled,\n        dcWriteBusy,\n        dcWriteHit,\n        dcWriteReqAck,\n        retiredStoreLSQ_BlockAddr,\n        retiredStoreData,\n        retiredStoreWordWE,\n        retiredStoreByteWE,\n        storeQueueEmpty,\n        storeQueueCount,\n        storeQueueHeadPtr,\n        allocatable,\n        storeHasAllocatedMSHR,\n        storeMSHRID,\n        mshrPhase,\n    output\n        dcWriteReq,\n        dcWriteData,\n        dcWriteAddr,\n        dcWriteByteWE,\n        dcWriteUncachable,\n        retiredStoreQueuePtr,\n        releaseStoreQueueHead,\n        busyInRecovery,\n        releaseStoreQueueHeadEntryNum\n    );\n\n    modport LoadStoreUnit(\n    input\n        clk,\n        rst,\n        loadQueueAllocatable,\n        storeQueueAllocatable,\n        executeLoad,\n        executedLoadAddr,\n        executedLoadMemAccessMode,\n        storeLoadForwarded,\n        forwardedLoadData,\n        dcReadData,\n        busyInRecovery,\n        mshrReadHit,\n        mshrReadData,\n    output\n        executedLoadData,\n        executedLoadVectorData,\n        allocatable\n    );\n\n    modport RenameStage(\n    input\n        allocatable,\n        allocatedLoadQueuePtr,\n        allocatedStoreQueuePtr,\n        storeQueueEmpty,\n    output\n        allocateLoadQueue,\n        allocateStoreQueue\n    );\n\n    modport MemoryExecutionStage(\n    input\n        clk,\n    output\n        dcReadReq,\n        dcReadAddr,\n        dcReadUncachable,\n        dcReadActiveListPtr\n    );\n\n    modport MemoryTagAccessStage(\n    input\n        forwardMiss,\n        storeLoadForwarded,\n        conflict,\n        dcReadHit,\n        mshrAddrHit,\n        mshrAddrHitMSHRID,\n        mshrReadHit,\n        loadHasAllocatedMSHR,\n        loadMSHRID,\n    output\n        executeLoad,\n        executedLoadQueuePtrByLoad,\n        executedLoadQueuePtrByStore,\n        executedLoadAddr,\n        executedLoadMemMapType,\n        executedLoadPC,\n        executedLoadRegValid,\n        executeStore,\n        executedStoreQueuePtrByLoad,\n        executedStoreQueuePtrByStore,\n        executedStoreData,\n        executedStoreVectorData,\n        executedStoreAddr,\n        executedStoreCondEnabled,\n        executedStoreRegValid,\n        executedLoadMemAccessMode,\n        executedStoreMemAccessMode,\n        memAccessOrderViolation\n    );\n\n    modport MemoryAccessStage(\n    input\n        executedLoadData,\n        executedLoadVectorData\n    );\n\n    modport MemoryRegisterWriteStage(\n    output\n        makeMSHRCanBeInvalidDirect\n    );\n\n    modport ReplayQueue(\n    input\n        mshrValid,\n        mshrPhase\n    );\n\n    modport CommitStage(\n    input\n        busyInRecovery,\n    output\n        releaseLoadQueue,\n        releaseLoadQueueEntryNum,\n        commitStore,\n        commitStoreNum\n    );\n\n    modport MemoryDependencyPredictor(\n    input\n        memAccessOrderViolation,\n        conflictLoadPC\n    );\n\nendinterface : LoadStoreUnitIF\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n// \n// --- Types related to a load-store queue.\n//\n\npackage LoadStoreUnitTypes;\n\nimport MicroArchConf::*;\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport CacheSystemTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport MemoryMapTypes::*;\n\n// Load/store queues compare addresses as a word unit.\n\n// LSQ \u5185\u90e8\u306e\u51e6\u7406\u306f\uff0c\u73fe\u5728\u306f\u7269\u7406\u30a2\u30c9\u30ec\u30b9\u5e45\u306b\u63c3\u3048\u308b\nlocalparam LSQ_ADDR_MSB = PHY_ADDR_WIDTH; \nlocalparam LSQ_ADDR_UPPER_PADDING_BIT_SIZE = PHY_ADDR_WIDTH - LSQ_ADDR_MSB;\n\n// LSQ \u5185\u90e8\u306e\u30c7\u30fc\u30bf\u5e45\n//localparam LSQ_BLOCK_WIDTH = DATA_WIDTH;  // \u30ed\u30fc\u30c9\u30b9\u30c8\u30a2\u306e\u6700\u5927\u30c7\u30fc\u30bf\u5e45\u306b\u7b49\u3057\u3044\nlocalparam LSQ_BLOCK_WIDTH = 32;  // \u30ed\u30fc\u30c9\u30b9\u30c8\u30a2\u306e\u6700\u5927\u30c7\u30fc\u30bf\u5e45\u306b\u7b49\u3057\u3044\nlocalparam LSQ_BLOCK_WORD_WIDTH = LSQ_BLOCK_WIDTH / DATA_WIDTH;\nlocalparam LSQ_BLOCK_BYTE_WIDTH = LSQ_BLOCK_WIDTH / BYTE_WIDTH;\nlocalparam LSQ_BLOCK_BYTE_WIDTH_BIT_SIZE = $clog2(LSQ_BLOCK_BYTE_WIDTH);\ntypedef logic [LSQ_BLOCK_WIDTH-1:0] LSQ_BlockDataPath;\n\n\n// LSQ \u5185\u90e8\u30c7\u30fc\u30bf\u5e45\u5358\u4f4d\u306e\u30a2\u30c9\u30ec\u30b9\ntypedef logic [LSQ_ADDR_MSB-1-LSQ_BLOCK_BYTE_WIDTH_BIT_SIZE:0] LSQ_BlockAddrPath;\n\nfunction automatic LSQ_BlockAddrPath LSQ_ToBlockAddr(PhyAddrPath addr);\n    return addr[LSQ_ADDR_MSB-1 : LSQ_BLOCK_BYTE_WIDTH_BIT_SIZE];\nendfunction\n\nfunction automatic PhyAddrPath LSQ_ToFullAddrFromBlockAddr(LSQ_BlockAddrPath blockAddr);\n    return { { LSQ_ADDR_UPPER_PADDING_BIT_SIZE{1'b0} }, blockAddr, {LSQ_BLOCK_BYTE_WIDTH_BIT_SIZE{1'b0}} };\nendfunction\n\n// Load queue\nlocalparam LOAD_QUEUE_ENTRY_NUM = CONF_LOAD_QUEUE_ENTRY_NUM;\nlocalparam LOAD_QUEUE_ENTRY_NUM_BIT_WIDTH = $clog2(LOAD_QUEUE_ENTRY_NUM);\n\ntypedef logic [ LOAD_QUEUE_ENTRY_NUM_BIT_WIDTH-1:0 ] LoadQueueIndexPath;\ntypedef logic [ LOAD_QUEUE_ENTRY_NUM_BIT_WIDTH:0 ] LoadQueueCountPath;\ntypedef logic [ (1<<LOAD_QUEUE_ENTRY_NUM_BIT_WIDTH)-1:0 ] LoadQueueOneHotPath;\n\n// Store queue\nlocalparam STORE_QUEUE_ENTRY_NUM = CONF_STORE_QUEUE_ENTRY_NUM;\nlocalparam STORE_QUEUE_ENTRY_NUM_BIT_WIDTH = $clog2(STORE_QUEUE_ENTRY_NUM);\n\ntypedef logic [ STORE_QUEUE_ENTRY_NUM_BIT_WIDTH-1:0 ] StoreQueueIndexPath;\ntypedef logic [ STORE_QUEUE_ENTRY_NUM_BIT_WIDTH:0 ] StoreQueueCountPath;\ntypedef logic [ (1<<STORE_QUEUE_ENTRY_NUM_BIT_WIDTH)-1:0 ] StoreQueueOneHotPath;\n\n// Read enable signals per word.\ntypedef logic [ LSQ_BLOCK_WORD_WIDTH-1:0 ] LSQ_BlockWordEnablePath;\ntypedef logic [ LSQ_BLOCK_BYTE_WIDTH-1:0 ] LSQ_BlockByteEnablePath;\ntypedef logic [ DATA_BYTE_WIDTH-1:0 ] LSQ_WordByteEnablePath;\n\n// width \u304c 0 \u306e\u5834\u5408\u306f 0 \u3092\u8fd4\u3059\nfunction automatic int LSQ_SelectBits(int data, int offset, int width);\n    int ret;\n    ret = 0;\n    for (int i = 0; i < width; i++) begin\n        ret[i] = data[i + offset];\n    end\n    return ret;\nendfunction\n\n// Generate read / write enable signals for each word\n// from a memory address and an access size.\nfunction automatic LSQ_BlockWordEnablePath LSQ_ToBlockWordEnable(\n    PhyAddrPath addr,\n    MemAccessMode mode\n);\n    LSQ_BlockWordEnablePath wordEnable;\n    case(mode.size)\n        MEM_ACCESS_SIZE_VEC: begin\n            wordEnable = '1;    // All 1\n        end\n        default: begin\n            wordEnable = 1;     // Lowest word\n        end\n    endcase\n\n    return\n        wordEnable << \n        LSQ_SelectBits(\n            addr, DATA_BYTE_WIDTH_BIT_SIZE, LSQ_BLOCK_BYTE_WIDTH_BIT_SIZE - DATA_BYTE_WIDTH_BIT_SIZE\n        );\n    //return wordEnable << addr[ LSQ_BLOCK_BYTE_WIDTH_BIT_SIZE-1:DATA_BYTE_WIDTH_BIT_SIZE ];\nendfunction\n\n// Generate read / write enable signals for each byte\n// from a memory address and an access size.\nfunction automatic LSQ_WordByteEnablePath LSQ_ToWordByteEnable(\n    PhyAddrPath addr,\n    MemAccessMode mode\n);\n    LSQ_WordByteEnablePath byteEnable;\n    \n    case(mode.size)\n        MEM_ACCESS_SIZE_BYTE: begin\n            byteEnable = 'b0001;\n        end\n        MEM_ACCESS_SIZE_HALF_WORD: begin\n            byteEnable = 'b0011;\n        end\n        default: begin\n            byteEnable = '1;\n        end\n    endcase\n    \n    return byteEnable << addr[ DATA_BYTE_WIDTH_BIT_SIZE-1:0 ];\nendfunction\n\n\nfunction automatic PhyAddrPath LSQ_ToFullPhyAddrFromBlockAddrAndWordWE(\n    LSQ_BlockAddrPath blockAddr, LSQ_BlockWordEnablePath wordWE\n);\n    PhyAddrPath ret;\n    ret = {blockAddr, {LSQ_BLOCK_BYTE_WIDTH_BIT_SIZE{1'b0}}};\n    for (int i = 0; i < LSQ_BLOCK_WORD_WIDTH; i++) begin\n        if (wordWE[i]) begin\n            return ret + i*DATA_BYTE_WIDTH;\n        end\n    end\n    return ret;\nendfunction\n\nfunction automatic DataPath LSQ_ToScalarWordDataFromBlockData(\n    LSQ_BlockDataPath data, LSQ_BlockWordEnablePath wordWE\n);\n    DataPath ret;\n    ret = data[DATA_WIDTH-1:0];\n    for (int i = 0; i < LSQ_BLOCK_WORD_WIDTH; i++) begin\n        if (wordWE[i]) begin\n            return (data >> (i*DATA_WIDTH));\n        end\n    end\n    return ret;\nendfunction\n\n//\n// Entries of LSQ\n//\n\ntypedef struct packed // LoadQueueEntry\n{\n    // Whether the load was executed using the correct source operand\n    logic regValid;\n    // This flag indicate whether a load is finished or not.\n    logic finished;\n    \n    // The address of a load.\n    LSQ_BlockAddrPath address;\n    \n    // Read enable signals.\n    LSQ_BlockWordEnablePath wordRE;\n\n    // Addr for memory dependent predictor.\n    PC_Path pc;\n} LoadQueueEntry;\n\ntypedef struct packed // StoreQueueAddrEntry\n{\n    // Whether the store was executed using the correct source operand\n    logic regValid;\n    // This flag indicate whether a load is finished or not.\n    logic finished;\n    \n    // The address of a store.\n    LSQ_BlockAddrPath address;\n    \n    // Write enable signals.\n    LSQ_BlockWordEnablePath wordWE;\n    LSQ_WordByteEnablePath byteWE;\n} StoreQueueAddrEntry;\n\ntypedef struct packed // StoreQueueDataEntry\n{\n    logic condEnabled;\n    LSQ_BlockDataPath data;\n\n    // Write enable signals.\n    LSQ_BlockWordEnablePath wordWE;\n    LSQ_WordByteEnablePath byteWE;\n} StoreQueueDataEntry;\n\n\nendpackage\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n\n// Main \u30e2\u30b8\u30e5\u30fc\u30eb wrapper\n// \u5408\u6210\u5bfe\u8c61\u306e\u30dc\u30fc\u30c9\u306b\u3088\u3063\u3066include\u3059\u308b\u30d5\u30a1\u30a4\u30eb\u304c\u7570\u306a\u308b\uff0e\n// \u30b7\u30df\u30e5\u30ec\u30fc\u30b7\u30e7\u30f3\u6642\u306fMain_Fpga.sv\u3092include\u3059\u308b\uff0e\n//\n\nimport BasicTypes::*;\nimport CacheSystemTypes::*;\nimport MemoryTypes::*;\nimport DebugTypes::*;\nimport IO_UnitTypes::*;\n\nmodule Top #(\n    parameter MEM_INIT_HEX_FILE = \"\"\n)(\n\n`ifndef RSD_SYNTHESIS\ninput\n    logic clk_p, clk_n,\n    logic negResetIn, // \u8ca0\u8ad6\u7406\n    logic rxd,\n`elsif RSD_SYNTHESIS_ATLYS\ninput\n    logic clk_p, clk_n,\n    logic negResetIn, // \u8ca0\u8ad6\u7406\n    logic rxd,\n`elsif RSD_SYNTHESIS_ZEDBOARD\ninput\n    logic clk,\n    logic negResetIn, // \u8ca0\u8ad6\u7406\n`else\n    \"Error!\"\n`endif\n    \n`ifndef RSD_DISABLE_DEBUG_REGISTER\noutput\n    DebugRegister debugRegister,\n`endif\n\n`ifdef RSD_SYNTHESIS_ATLYS\noutput\n    wire DDR2CLK0, DDR2CLK1, DDR2CKE,\n    wire DDR2RASN, DDR2CASN, DDR2WEN,\n    wire DDR2RZQ, DDR2ZIO,\n    wire DDR2LDM, DDR2UDM, DDR2ODT,\n    wire [2:0]  DDR2BA,\n    wire [12:0] DDR2A,\ninout\n    wire [15:0] DDR2DQ,\n    wire DDR2UDQS, DDR2UDQSN, DDR2LDQS, DDR2LDQSN,\n`endif\n\n`ifndef RSD_SYNTHESIS\noutput\n    logic serialWE,\n    SerialDataPath serialWriteData,\n    logic posResetOut, // \u6b63\u8ad6\u7406\n    LED_Path ledOut, // LED Output\n    logic txd\n`elsif RSD_SYNTHESIS_ATLYS\noutput\n    logic serialWE,\n    SerialDataPath serialWriteData,\n    logic posResetOut, // \u6b63\u8ad6\u7406\n    LED_Path ledOut, // LED Output\n    logic txd\n`elsif RSD_SYNTHESIS_ZEDBOARD\noutput\n    LED_Path ledOut, // LED Output\nAxi4LiteControlRegisterIF.Axi4LiteRead axi4LitePlToPsControlRegisterIF,\nAxi4LiteControlRegisterIF.Axi4Lite axi4LitePsToPlControlRegisterIF\n`else\n    \"Error!\"\n`endif\n);\n\n    Main #(.MEM_INIT_HEX_FILE(MEM_INIT_HEX_FILE)) main (\n        .*\n    );\n\nendmodule // Top\n\n`ifndef RSD_SYNTHESIS\n    `include \"Main_Fpga.sv\"\n`elsif RSD_SYNTHESIS_ATLYS\n    `include \"Main_Fpga.sv\"\n`elsif RSD_SYNTHESIS_ZEDBOARD\n    `include \"Main_Zynq.sv\"\n`else\n    \"Error!\"\n`endif"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n\n// Main \u30e2\u30b8\u30e5\u30fc\u30eb\n// \u5168\u3066\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3068\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306e\u6700\u4e0a\u4f4d\u3067\u306e\u63a5\u7d9a\u3092\u884c\u3046\n//\n\n`ifdef RSD_SYNTHESIS_ATLYS\n\nimport BasicTypes::*;\nimport CacheSystemTypes::*;\nimport MemoryTypes::*;\nimport DebugTypes::*;\nimport IO_UnitTypes::*;\n\nmodule Main #(\n    parameter MEM_INIT_HEX_FILE = \"\"\n)(\ninput\n    logic clk_p, clk_n,\n    logic negResetIn, // \u8ca0\u8ad6\u7406\n    logic rxd,\n    \n`ifndef RSD_DISABLE_DEBUG_REGISTER\noutput\n    DebugRegister debugRegister,\n`endif\n\n`ifdef RSD_SYNTHESIS_ATLYS\noutput\n    wire DDR2CLK0, DDR2CLK1, DDR2CKE,\n    wire DDR2RASN, DDR2CASN, DDR2WEN,\n    wire DDR2RZQ, DDR2ZIO,\n    wire DDR2LDM, DDR2UDM, DDR2ODT,\n    wire [2:0]  DDR2BA,\n    wire [12:0] DDR2A,\ninout\n    wire [15:0] DDR2DQ,\n    wire DDR2UDQS, DDR2UDQSN, DDR2LDQS, DDR2LDQSN,\n`endif\n\noutput\n    logic serialWE,\n    SerialDataPath serialWriteData,\n    logic posResetOut, // \u6b63\u8ad6\u7406\n    LED_Path ledOut, // LED Output\n    logic txd\n);\n    \n`ifdef RSD_DISABLE_DEBUG_REGISTER\n    DebugRegister debugRegister; // RSD_DISABLE_DEBUG_REGISTER\u6642\u306f\u3069\u3053\u306b\u3082\u7e4b\u304c\u306a\u3044\n`endif\n    \n    logic programLoaded; // \u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u30ed\u30fc\u30c9\u304c\u6e08\u3093\u3060\u3089TRUE\n\n    //\n    // --- Clock and Reset\n    //\n    logic clk, memCLK;\n    logic locked; // You must disable the reset signal (rst) after the clock generator is locked.\n    logic rst, rstStart, rstTrigger;\n\n`ifdef RSD_SYNTHESIS_TED\n    TED_ClockGenerator clockgen(\n        .clk_p(clk_p),\n        .clk_n(clk_n),\n        .clk(clk)\n    );\n    assign locked = TRUE;\n`elsif RSD_SYNTHESIS_ATLYS\n    logic locked1, locked2;\n    AtlysClockGenerator clockGen(\n        .CLK_IN(clk_p),\n        .CLK_OUT(clk),\n        .LOCKED(locked1)\n    );\n    AtlysMemoryClockGenerator memClockGen(\n        .CLK_IN(clk_p),\n        .CLK_OUT(memCLK),\n        .LOCKED(locked2)\n    );\n    assign locked = locked1 & locked2;\n`else\n    // For Simulation\n    assign clk = clk_p;\n    assign locked = TRUE;\n`endif\n        \n    // Generate a global reset signal 'rst' from 'rstTrigger'.\n    assign rstTrigger = ~negResetIn;\n    assign posResetOut = rst;\n    ResetController rstController(\n        .clk( clk ),\n        .rstTrigger( rstTrigger ),\n        .locked( locked ),\n        .rst( rst ),\n        .rstStart( rstStart )\n    );\n\n    //\n    // --- Memory and Program Loader\n    //\n    logic memCaribrationDone; // \u30e1\u30e2\u30ea\u306e\u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u304c\u7d42\u308f\u3063\u305f\u3089TRUE\n    \n    MemoryEntryDataPath memReadData;\n    logic memReadDataReady;\n    logic memAccessReadBusy;\n    logic memAccessWriteBusy;\n    logic memAccessBusy;\n    \n    MemoryEntryDataPath memAccessWriteData;\n    MemoryEntryDataPath memAccessWriteDataFromCore;\n    MemoryEntryDataPath memAccessWriteDataFromProgramLoader;\n\n    AddrPath memAccessAddr, memAccessAddrFromProgramLoader;\n    PhyAddrPath memAccessAddrFromCore;\n\n    logic memAccessRE, memAccessRE_FromCore;\n    logic memAccessWE, memAccessWE_FromCore, memAccessWE_FromProgramLoader;\n    \n`ifdef RSD_USE_EXTERNAL_MEMORY\n    logic cmd_full, rd_full, wr_full;\n    \n    AtlysDRAM_Controller dramController(\n        .CLK( clk ),\n        .DRAM_CLK( memCLK ),\n        .RST_X( ~rst ),\n        .calib_done( memCaribrationDone ), \n        .D_ADR( memAccessAddr ),\n        .D_DIN( memAccessWriteData ),\n        .D_WE( memAccessWE ), \n        .D_RE( memAccessRE ),\n        .D_BUSY( memAccessBusy ),\n        .D_DOUT( memReadData ),\n        .D_DOUT_RDY( memReadDataReady ),\n        .cmd_full( cmd_full ),\n        .rd_full( rd_full ),\n        .wr_full( wr_full ),\n        \n        // DRAM interface\n       .DDR2CLK0        (DDR2CLK0),\n       .DDR2CLK1        (DDR2CLK1),\n       .DDR2CKE         (DDR2CKE),\n       .DDR2RASN        (DDR2RASN),\n       .DDR2CASN        (DDR2CASN),\n       .DDR2WEN         (DDR2WEN),\n       .DDR2RZQ         (DDR2RZQ),\n       .DDR2ZIO         (DDR2ZIO),\n       .DDR2BA          (DDR2BA),\n       .DDR2A           (DDR2A),\n       .DDR2DQ          (DDR2DQ),\n       .DDR2UDQS        (DDR2UDQS),\n       .DDR2UDQSN       (DDR2UDQSN),\n       .DDR2LDQS        (DDR2LDQS),\n       .DDR2LDQSN       (DDR2LDQSN),\n       .DDR2LDM         (DDR2LDM),\n       .DDR2UDM         (DDR2UDM),\n       .DDR2ODT         (DDR2ODT)\n    );\n`else // Use internal memory\n    Memory #(\n        .INIT_HEX_FILE( MEM_INIT_HEX_FILE )\n    ) memory (\n        .clk( clk ),\n        .rst( rst ),\n        .memAccessAddr( memAccessAddr ),\n        .memAccessWriteData( memAccessWriteData ),\n        .memAccessRE( memAccessRE ),\n        .memAccessWE( memAccessWE ),\n        .memAccessBusy( memAccessBusy ),\n        .memReadData( memReadData ),\n        .memReadDataReady( memReadDataReady )\n    );\n`endif\n\n    assign memAccessReadBusy = memAccessBusy;\n    assign memAccessWriteBusy = memAccessBusy;\n\n`ifdef RSD_USE_PROGRAM_LOADER\n    // Atlys\u30dc\u30fc\u30c9\u3092\u4f7f\u3046\u5834\u5408\u306f\u3001\n    AtlysProgramLoader programLoader(\n        .CLK( clk ),\n        .RST_X( ~rst ), // RST_X is negative logic\n        .RXD( rxd ),\n        .ADDR( memAccessAddrFromProgramLoader ),\n        .DATA( memAccessWriteDataFromProgramLoader ),\n        .WE( memAccessWE_FromProgramLoader ),\n        .DONE( programLoaded )\n    );\n\n    always_comb begin\n        if ( !programLoaded ) begin\n            memAccessAddr = memAccessAddrFromProgramLoader;\n            memAccessWriteData = memAccessWriteDataFromProgramLoader;\n            memAccessRE = FALSE;\n            memAccessWE = memAccessWE_FromProgramLoader;\n        end\n        else begin\n            memAccessAddr = memAccessAddrFromCore;\n            memAccessWriteData = memAccessWriteDataFromCore;\n            memAccessRE = memAccessRE_FromCore;\n            memAccessWE = memAccessWE_FromCore;\n        end\n    end\n`else\n    always_comb begin\n        programLoaded = TRUE;\n        memAccessAddr = memAccessAddrFromCore;\n        memAccessWriteData = memAccessWriteDataFromCore;\n        memAccessRE = memAccessRE_FromCore;\n        memAccessWE = memAccessWE_FromCore;\n    end\n`endif\n    \n    //\n    // --- Serial communication IO\n    //\n    logic txdBuffer, serialReady;\n    \n    always @(posedge clk) begin\n        txd <= txdBuffer;\n    end\n\n    AtlysUartTx serialIO(\n        .CLK(clk),\n        .RST_X(~rst), // RST_X is negative logic\n        .DATA(serialWriteData),\n        .WE(serialWE),\n        .TXD(txdBuffer),\n        .READY(serialReady)\n    );\n\n    //\n    // --- LED IO\n    //\n    PC_Path lastCommittedPC;\n\n`ifdef RSD_SYNTHESIS_ATLYS\n    logic [25:0] ledBlinkCounter; // just for LED\n\n    always @(posedge clk) begin\n        ledBlinkCounter <= ledBlinkCounter + 1;\n        \n        ledOut[7] <= ledBlinkCounter[25];\n        ledOut[6] <= FALSE; // TODO:\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u304c\u52d5\u3044\u3066\u3044\u308b\u304b\u3092\u8868\u793a\u3057\u305f\u3044\n        ledOut[5] <= ( lastCommittedPC == PC_GOAL ? TRUE : FALSE ); \n        ledOut[4] <= memAccessBusy;   // DRAM is working\n        ledOut[3] <= ~txd;      // Uart TXD\n        ledOut[2] <= ~rxd;      // Uart RXD\n        ledOut[1] <= ~memCaribrationDone;  // DRAM calibration done \n        ledOut[0] <= ~programLoaded; // MEMORY IMAGE transfer is done\n    end\n`else\n    assign ledOut = lastCommittedPC[ LED_WIDTH-1:0 ];\n`endif\n\n    logic reqExternalInterrupt;\n    ExternalInterruptCodePath externalInterruptCode; \n    always_comb begin\n        reqExternalInterrupt = FALSE;\n        externalInterruptCode = 0;\n    end\n\n    //\n    // --- Processor core\n    //\n    Core core (\n        .clk( clk ),\n        .rst( rst || !programLoaded ),\n        .memAccessAddr( memAccessAddrFromCore ),\n        .memAccessWriteData( memAccessWriteDataFromCore ),\n        .memAccessRE( memAccessRE_FromCore ),\n        .memAccessWE( memAccessWE_FromCore ),\n        .memAccessReadBusy( memAccessReadBusy ),\n        .memAccessWriteBusy( memAccessWriteBusy ),\n        .reqExternalInterrupt( reqExternalInterrupt ),\n        .externalInterruptCode( externalInterruptCode ),\n        .memReadData( memReadData ),\n        .memReadDataReady( memReadDataReady ),\n        .rstStart( rstStart ),\n        .serialWE( serialWE ),\n        .serialWriteData( serialWriteData ),\n        .lastCommittedPC( lastCommittedPC ),\n        .debugRegister ( debugRegister )\n    );\n    \nendmodule : Main\n\n`endif"}
{"text": "\n`include \"SysDeps/XilinxMacros.vh\"\n\nlocalparam LED_WIDTH = 8;\n\nmodule RSD(\ninput\n    wire clk,\n    wire negResetIn,\noutput\n    wire [LED_WIDTH-1:0] ledOut,\ninput\n    wire  axi4MemoryIF_M_AXI_ACLK,\n    wire  axi4MemoryIF_M_AXI_ARESETN,\noutput\n    wire [`MEMORY_AXI4_WRITE_ID_WIDTH-1 : 0] axi4MemoryIF_M_AXI_AWID,\n    wire [`MEMORY_AXI4_ADDR_BIT_SIZE-1 : 0] axi4MemoryIF_M_AXI_AWADDR,\n    wire [`MEMORY_AXI4_AWLEN_WIDTH-1 : 0] axi4MemoryIF_M_AXI_AWLEN,\n    wire [`MEMORY_AXI4_AWSIZE_WIDTH-1 : 0] axi4MemoryIF_M_AXI_AWSIZE,\n    wire [`MEMORY_AXI4_AWBURST_WIDTH-1 : 0] axi4MemoryIF_M_AXI_AWBURST,\n    wire  axi4MemoryIF_M_AXI_AWLOCK,\n    wire [`MEMORY_AXI4_AWCACHE_WIDTH-1 : 0] axi4MemoryIF_M_AXI_AWCACHE,\n    wire [`MEMORY_AXI4_AWPROT_WIDTH-1 : 0] axi4MemoryIF_M_AXI_AWPROT,\n    wire [`MEMORY_AXI4_AWQOS_WIDTH-1 : 0] axi4MemoryIF_M_AXI_AWQOS,\n    wire [`MEMORY_AXI4_AWUSER_WIDTH-1 : 1] axi4MemoryIF_M_AXI_AWUSER,\n    wire  axi4MemoryIF_M_AXI_AWVALID,\ninput\n    wire  axi4MemoryIF_M_AXI_AWREADY,\noutput\n    wire [`MEMORY_AXI4_DATA_BIT_NUM-1 : 0] axi4MemoryIF_M_AXI_WDATA,\n    wire [`MEMORY_AXI4_DATA_BIT_NUM/8-1 : 0] axi4MemoryIF_M_AXI_WSTRB,\n    wire  axi4MemoryIF_M_AXI_WLAST,\n    wire [`MEMORY_AXI4_WUSER_WIDTH-1 : 1] axi4MemoryIF_M_AXI_WUSER,\n    wire  axi4MemoryIF_M_AXI_WVALID,\ninput\n    wire  axi4MemoryIF_M_AXI_WREADY,\n    wire [`MEMORY_AXI4_WRITE_ID_WIDTH-1 : 0] axi4MemoryIF_M_AXI_BID,\n    wire [`MEMORY_AXI4_BRESP_WIDTH-1 : 0] axi4MemoryIF_M_AXI_BRESP,\n    wire [`MEMORY_AXI4_BUSER_WIDTH-1 : 0] axi4MemoryIF_M_AXI_BUSER,\n    wire  axi4MemoryIF_M_AXI_BVALID,\noutput\n    wire  axi4MemoryIF_M_AXI_BREADY,\n    wire [`MEMORY_AXI4_READ_ID_WIDTH-1 : 0] axi4MemoryIF_M_AXI_ARID,\n    wire [`MEMORY_AXI4_ADDR_BIT_SIZE-1 : 0] axi4MemoryIF_M_AXI_ARADDR,\n    wire [`MEMORY_AXI4_ARLEN_WIDTH-1 : 0] axi4MemoryIF_M_AXI_ARLEN,\n    wire [`MEMORY_AXI4_ARSIZE_WIDTH-1 : 0] axi4MemoryIF_M_AXI_ARSIZE,\n    wire [`MEMORY_AXI4_ARBURST_WIDTH-1 : 0] axi4MemoryIF_M_AXI_ARBURST,\n    wire  axi4MemoryIF_M_AXI_ARLOCK,\n    wire [`MEMORY_AXI4_ARCACHE_WIDTH-1 : 0] axi4MemoryIF_M_AXI_ARCACHE,\n    wire [`MEMORY_AXI4_ARPROT_WIDTH-1 : 0] axi4MemoryIF_M_AXI_ARPROT,\n    wire [`MEMORY_AXI4_ARQOS_WIDTH-1 : 0] axi4MemoryIF_M_AXI_ARQOS,\n    wire [`MEMORY_AXI4_ARUSER_WIDTH-1 : 0] axi4MemoryIF_M_AXI_ARUSER,\n    wire  axi4MemoryIF_M_AXI_ARVALID,\ninput\n    wire  axi4MemoryIF_M_AXI_ARREADY,\n    wire [`MEMORY_AXI4_READ_ID_WIDTH-1 : 0] axi4MemoryIF_M_AXI_RID,\n    wire [`MEMORY_AXI4_DATA_BIT_NUM-1 : 0] axi4MemoryIF_M_AXI_RDATA,\n    wire [`MEMORY_AXI4_RRESP_WIDTH-1 : 0] axi4MemoryIF_M_AXI_RRESP,\n    wire  axi4MemoryIF_M_AXI_RLAST,\n    wire [`MEMORY_AXI4_RUSER_WIDTH-1 : 0] axi4MemoryIF_M_AXI_RUSER,\n    wire  axi4MemoryIF_M_AXI_RVALID,\noutput\n    wire  axi4MemoryIF_M_AXI_RREADY,\ninput\n    wire axi4LitePlToPsControlRegisterIF_S_AXI_ACLK,\n    wire axi4LitePlToPsControlRegisterIF_S_AXI_ARESETN,\n    wire [`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1 : 0] axi4LitePlToPsControlRegisterIF_S_AXI_ARADDR,\n    wire [`PS_PL_CTRL_REG_AWPROT_WIDTH-1 : 0] axi4LitePlToPsControlRegisterIF_S_AXI_ARPROT,\n    wire  axi4LitePlToPsControlRegisterIF_S_AXI_ARVALID,\noutput\n    wire  axi4LitePlToPsControlRegisterIF_S_AXI_ARREADY,\n    wire [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1 : 0] axi4LitePlToPsControlRegisterIF_S_AXI_RDATA,\n    wire [`PS_PL_CTRL_REG_RRESP_WIDTH-1 : 0] axi4LitePlToPsControlRegisterIF_S_AXI_RRESP,\n    wire  axi4LitePlToPsControlRegisterIF_S_AXI_RVALID,\ninput\n    wire  axi4LitePlToPsControlRegisterIF_S_AXI_RREADY,\n    wire axi4LitePsToPlControlRegisterIF_S_AXI_ACLK,\n    wire axi4LitePsToPlControlRegisterIF_S_AXI_ARESETN,\n    wire [`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1 : 0] axi4LitePsToPlControlRegisterIF_S_AXI_AWADDR,\n    wire [`PS_PL_CTRL_REG_AWPROT_WIDTH-1 : 0] axi4LitePsToPlControlRegisterIF_S_AXI_AWPROT,\n    wire  axi4LitePsToPlControlRegisterIF_S_AXI_AWVALID,\noutput\n    wire  axi4LitePsToPlControlRegisterIF_S_AXI_AWREADY,\ninput\n    wire [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1 : 0] axi4LitePsToPlControlRegisterIF_S_AXI_WDATA,\n    wire [(`PS_PL_CTRL_REG_DATA_BIT_SIZE/8)-1 : 0] axi4LitePsToPlControlRegisterIF_S_AXI_WSTRB,\n    wire  axi4LitePsToPlControlRegisterIF_S_AXI_WVALID,\noutput\n    wire  axi4LitePsToPlControlRegisterIF_S_AXI_WREADY,\n    wire [`PS_PL_CTRL_REG_BRESP_WIDTH-1 : 0] axi4LitePsToPlControlRegisterIF_S_AXI_BRESP,\n    wire  axi4LitePsToPlControlRegisterIF_S_AXI_BVALID,\ninput\n    wire  axi4LitePsToPlControlRegisterIF_S_AXI_BREADY,\n    wire [`PS_PL_CTRL_REG_ADDR_BIT_SIZE-1 : 0] axi4LitePsToPlControlRegisterIF_S_AXI_ARADDR,\n    wire [`PS_PL_CTRL_REG_ARPROT_WIDTH-1 : 0] axi4LitePsToPlControlRegisterIF_S_AXI_ARPROT,\n    wire  axi4LitePsToPlControlRegisterIF_S_AXI_ARVALID,\noutput\n    wire  axi4LitePsToPlControlRegisterIF_S_AXI_ARREADY,\n    wire [`PS_PL_CTRL_REG_DATA_BIT_SIZE-1 : 0] axi4LitePsToPlControlRegisterIF_S_AXI_RDATA,\n    wire [`PS_PL_CTRL_REG_RRESP_WIDTH-1 : 0] axi4LitePsToPlControlRegisterIF_S_AXI_RRESP,\n    wire  axi4LitePsToPlControlRegisterIF_S_AXI_RVALID,\ninput\n    wire  axi4LitePsToPlControlRegisterIF_S_AXI_RREADY\n);\n\n    Main_Zynq_Wrapper main(\n        .clk (clk),\n        .negResetIn (negResetIn),\n        .ledOut (ledOut),\n        .axi4MemoryIF_M_AXI_ACLK (axi4MemoryIF_M_AXI_ACLK),\n        .axi4MemoryIF_M_AXI_ARESETN (axi4MemoryIF_M_AXI_ARESETN),\n        .axi4MemoryIF_M_AXI_AWID (axi4MemoryIF_M_AXI_AWID),\n        .axi4MemoryIF_M_AXI_AWADDR (axi4MemoryIF_M_AXI_AWADDR),\n        .axi4MemoryIF_M_AXI_AWLEN (axi4MemoryIF_M_AXI_AWLEN),\n        .axi4MemoryIF_M_AXI_AWSIZE (axi4MemoryIF_M_AXI_AWSIZE),\n        .axi4MemoryIF_M_AXI_AWBURST (axi4MemoryIF_M_AXI_AWBURST),\n        .axi4MemoryIF_M_AXI_AWLOCK (axi4MemoryIF_M_AXI_AWLOCK),\n        .axi4MemoryIF_M_AXI_AWCACHE (axi4MemoryIF_M_AXI_AWCACHE),\n        .axi4MemoryIF_M_AXI_AWPROT (axi4MemoryIF_M_AXI_AWPROT),\n        .axi4MemoryIF_M_AXI_AWQOS (axi4MemoryIF_M_AXI_AWQOS),\n        .axi4MemoryIF_M_AXI_AWUSER (axi4MemoryIF_M_AXI_AWUSER),\n        .axi4MemoryIF_M_AXI_AWVALID (axi4MemoryIF_M_AXI_AWVALID),\n        .axi4MemoryIF_M_AXI_AWREADY (axi4MemoryIF_M_AXI_AWREADY),\n        .axi4MemoryIF_M_AXI_WDATA (axi4MemoryIF_M_AXI_WDATA),\n        .axi4MemoryIF_M_AXI_WSTRB (axi4MemoryIF_M_AXI_WSTRB),\n        .axi4MemoryIF_M_AXI_WLAST (axi4MemoryIF_M_AXI_WLAST),\n        .axi4MemoryIF_M_AXI_WUSER (axi4MemoryIF_M_AXI_WUSER),\n        .axi4MemoryIF_M_AXI_WVALID (axi4MemoryIF_M_AXI_WVALID),\n        .axi4MemoryIF_M_AXI_WREADY (axi4MemoryIF_M_AXI_WREADY),\n        .axi4MemoryIF_M_AXI_BID (axi4MemoryIF_M_AXI_BID),\n        .axi4MemoryIF_M_AXI_BRESP (axi4MemoryIF_M_AXI_BRESP),\n        .axi4MemoryIF_M_AXI_BUSER (axi4MemoryIF_M_AXI_BUSER),\n        .axi4MemoryIF_M_AXI_BVALID (axi4MemoryIF_M_AXI_BVALID),\n        .axi4MemoryIF_M_AXI_BREADY (axi4MemoryIF_M_AXI_BREADY),\n        .axi4MemoryIF_M_AXI_ARID (axi4MemoryIF_M_AXI_ARID),\n        .axi4MemoryIF_M_AXI_ARADDR (axi4MemoryIF_M_AXI_ARADDR),\n        .axi4MemoryIF_M_AXI_ARLEN (axi4MemoryIF_M_AXI_ARLEN),\n        .axi4MemoryIF_M_AXI_ARSIZE (axi4MemoryIF_M_AXI_ARSIZE),\n        .axi4MemoryIF_M_AXI_ARBURST (axi4MemoryIF_M_AXI_ARBURST),\n        .axi4MemoryIF_M_AXI_ARLOCK (axi4MemoryIF_M_AXI_ARLOCK),\n        .axi4MemoryIF_M_AXI_ARCACHE (axi4MemoryIF_M_AXI_ARCACHE),\n        .axi4MemoryIF_M_AXI_ARPROT (axi4MemoryIF_M_AXI_ARPROT),\n        .axi4MemoryIF_M_AXI_ARQOS (axi4MemoryIF_M_AXI_ARQOS),\n        .axi4MemoryIF_M_AXI_ARUSER (axi4MemoryIF_M_AXI_ARUSER),\n        .axi4MemoryIF_M_AXI_ARVALID (axi4MemoryIF_M_AXI_ARVALID),\n        .axi4MemoryIF_M_AXI_ARREADY (axi4MemoryIF_M_AXI_ARREADY),\n        .axi4MemoryIF_M_AXI_RID (axi4MemoryIF_M_AXI_RID),\n        .axi4MemoryIF_M_AXI_RDATA (axi4MemoryIF_M_AXI_RDATA),\n        .axi4MemoryIF_M_AXI_RRESP (axi4MemoryIF_M_AXI_RRESP),\n        .axi4MemoryIF_M_AXI_RLAST (axi4MemoryIF_M_AXI_RLAST),\n        .axi4MemoryIF_M_AXI_RUSER (axi4MemoryIF_M_AXI_RUSER),\n        .axi4MemoryIF_M_AXI_RVALID (axi4MemoryIF_M_AXI_RVALID),\n        .axi4MemoryIF_M_AXI_RREADY (axi4MemoryIF_M_AXI_RREADY),\n        .axi4LitePlToPsControlRegisterIF_S_AXI_ACLK (axi4LitePlToPsControlRegisterIF_S_AXI_ACLK),\n        .axi4LitePlToPsControlRegisterIF_S_AXI_ARESETN (axi4LitePlToPsControlRegisterIF_S_AXI_ARESETN),\n        .axi4LitePlToPsControlRegisterIF_S_AXI_ARADDR (axi4LitePlToPsControlRegisterIF_S_AXI_ARADDR),\n        .axi4LitePlToPsControlRegisterIF_S_AXI_ARPROT (axi4LitePlToPsControlRegisterIF_S_AXI_ARPROT),\n        .axi4LitePlToPsControlRegisterIF_S_AXI_ARVALID (axi4LitePlToPsControlRegisterIF_S_AXI_ARVALID),\n        .axi4LitePlToPsControlRegisterIF_S_AXI_ARREADY (axi4LitePlToPsControlRegisterIF_S_AXI_ARREADY),\n        .axi4LitePlToPsControlRegisterIF_S_AXI_RDATA (axi4LitePlToPsControlRegisterIF_S_AXI_RDATA),\n        .axi4LitePlToPsControlRegisterIF_S_AXI_RRESP (axi4LitePlToPsControlRegisterIF_S_AXI_RRESP),\n        .axi4LitePlToPsControlRegisterIF_S_AXI_RVALID (axi4LitePlToPsControlRegisterIF_S_AXI_RVALID),\n        .axi4LitePlToPsControlRegisterIF_S_AXI_RREADY (axi4LitePlToPsControlRegisterIF_S_AXI_RREADY),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_ACLK (axi4LitePsToPlControlRegisterIF_S_AXI_ACLK),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_ARESETN (axi4LitePsToPlControlRegisterIF_S_AXI_ARESETN),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_AWADDR (axi4LitePsToPlControlRegisterIF_S_AXI_AWADDR),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_AWPROT (axi4LitePsToPlControlRegisterIF_S_AXI_AWPROT),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_AWVALID (axi4LitePsToPlControlRegisterIF_S_AXI_AWVALID),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_AWREADY (axi4LitePsToPlControlRegisterIF_S_AXI_AWREADY),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_WDATA (axi4LitePsToPlControlRegisterIF_S_AXI_WDATA),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_WSTRB (axi4LitePsToPlControlRegisterIF_S_AXI_WSTRB),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_WVALID (axi4LitePsToPlControlRegisterIF_S_AXI_WVALID),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_WREADY (axi4LitePsToPlControlRegisterIF_S_AXI_WREADY),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_BRESP (axi4LitePsToPlControlRegisterIF_S_AXI_BRESP),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_BVALID (axi4LitePsToPlControlRegisterIF_S_AXI_BVALID),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_BREADY (axi4LitePsToPlControlRegisterIF_S_AXI_BREADY),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_ARADDR (axi4LitePsToPlControlRegisterIF_S_AXI_ARADDR),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_ARPROT (axi4LitePsToPlControlRegisterIF_S_AXI_ARPROT),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_ARVALID (axi4LitePsToPlControlRegisterIF_S_AXI_ARVALID),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_ARREADY (axi4LitePsToPlControlRegisterIF_S_AXI_ARREADY),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_RDATA (axi4LitePsToPlControlRegisterIF_S_AXI_RDATA),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_RRESP (axi4LitePsToPlControlRegisterIF_S_AXI_RRESP),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_RVALID (axi4LitePsToPlControlRegisterIF_S_AXI_RVALID),\n        .axi4LitePsToPlControlRegisterIF_S_AXI_RREADY (axi4LitePsToPlControlRegisterIF_S_AXI_RREADY)\n    );\n\nendmodule : RSD\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n\n// Main \u30e2\u30b8\u30e5\u30fc\u30eb\n// \u5168\u3066\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u3068\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9\u306e\u6700\u4e0a\u4f4d\u3067\u306e\u63a5\u7d9a\u3092\u884c\u3046\n//\n\n`ifndef RSD_SYNTHESIS_ATLYS\n\nimport BasicTypes::*;\nimport CacheSystemTypes::*;\nimport MemoryTypes::*;\nimport MemoryMapTypes::*;\nimport IO_UnitTypes::*;\nimport DebugTypes::*;\n\nmodule Main_Zynq #(\n`ifdef RSD_POST_SYNTHESIS\n    parameter MEM_INIT_HEX_FILE = \"code.hex\"\n`else\n    parameter MEM_INIT_HEX_FILE = \"\"\n`endif\n)(\n\n`ifdef RSD_SYNTHESIS_ZEDBOARD\ninput\n    logic clk,\n    logic negResetIn, // \u8ca0\u8ad6\u7406\noutput\n    LED_Path ledOut, // LED Output\n`else\n// RSD_POST_SYNTHESIS\n// RSD_FUNCTIONAL_SIMULATION\ninput\n    logic clk_p, clk_n,\n    logic negResetIn, // \u8ca0\u8ad6\u7406\n    logic rxd,\n`endif\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\noutput\n    DebugRegister debugRegister,\n`endif\n\n`ifdef RSD_USE_EXTERNAL_MEMORY\nAxi4MemoryIF axi4MemoryIF,\n`endif\n\n`ifdef RSD_SYNTHESIS_ZEDBOARD\nAxi4LiteControlRegisterIF axi4LitePlToPsControlRegisterIF,\nAxi4LiteControlRegisterIF axi4LitePsToPlControlRegisterIF\n`else \n// RSD_POST_SYNTHESIS\n// RSD_FUNCTIONAL_SIMULATION\noutput\n    logic serialWE,\n    SerialDataPath serialWriteData,\n    logic posResetOut, // \u6b63\u8ad6\u7406\n    LED_Path ledOut, // LED Output\n    logic txd\n`endif\n);\n\n`ifdef RSD_SYNTHESIS_ZEDBOARD\n//input\nlogic rxd;\n\n//output\nlogic serialWE;\nSerialDataPath serialWriteData;\nlogic posResetOut; // \u6b63\u8ad6\u7406\nlogic txd;\n`else\n// RSD_POST_SYNTHESIS\n// RSD_FUNCTIONAL_SIMULATION\nlogic clk;\n`endif\n\n`ifdef RSD_DISABLE_DEBUG_REGISTER\n    DebugRegister debugRegister; // RSD_DISABLE_DEBUG_REGISTER\u6642\u306f\u3069\u3053\u306b\u3082\u7e4b\u304c\u306a\u3044\n`endif\n    \n    logic programLoaded; // \u30d7\u30ed\u30b0\u30e9\u30e0\u306e\u30ed\u30fc\u30c9\u304c\u6e08\u3093\u3060\u3089TRUE\n\n    //\n    // --- Clock and Reset\n    //\n    logic memCLK;\n    logic locked; // You must disable the reset signal (rst) after the clock generator is locked.\n    logic rst, rstStart, rstTrigger;\n\n`ifndef RSD_SYNTHESIS_ZEDBOARD\n    // RSD_POST_SYNTHESIS\n    // RSD_FUNCTIONAL_SIMULATION\n    // For Simulation\n    assign clk = clk_p;\n`endif\n\n    assign locked = TRUE;\n        \n    // Generate a global reset signal 'rst' from 'rstTrigger'.\n    assign rstTrigger = ~negResetIn;\n    assign posResetOut = rst;\n    ResetController rstController(\n        .clk( clk ),\n        .rstTrigger( rstTrigger ),\n        .locked( locked ),\n        .rst( rst ),\n        .rstStart( rstStart )\n    );\n\n    //\n    // --- Memory and Program Loader\n    //\n    logic memCaribrationDone; // \u30e1\u30e2\u30ea\u306e\u30ad\u30e3\u30ea\u30d6\u30ec\u30fc\u30b7\u30e7\u30f3\u304c\u7d42\u308f\u3063\u305f\u3089TRUE\n    \n    MemoryEntryDataPath memReadData;\n    logic memReadDataReady;\n    logic memAccessReadBusy;\n    logic memAccessWriteBusy;\n    logic memAccessBusy;\n    \n    MemoryEntryDataPath memAccessWriteData;\n    MemoryEntryDataPath memAccessWriteDataFromCore;\n    MemoryEntryDataPath memAccessWriteDataFromProgramLoader;\n\n    AddrPath memAccessAddr, memAccessAddrFromProgramLoader;\n    PhyAddrPath memAccessAddrFromCore;\n\n    logic memAccessRE, memAccessRE_FromCore;\n    logic memAccessWE, memAccessWE_FromCore, memAccessWE_FromProgramLoader;\n\n    MemAccessSerial nextMemReadSerial; // RSD\u306e\u6b21\u306e\u8aad\u307f\u51fa\u3057\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb(id)\n    MemWriteSerial nextMemWriteSerial; // RSD\u306e\u6b21\u306e\u66f8\u304d\u8fbc\u307f\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb(id)\n\n    MemAccessSerial memReadSerial; // \u30e1\u30e2\u30ea\u306e\u8aad\u307f\u51fa\u3057\u30c7\u30fc\u30bf\u306e\u30b7\u30ea\u30a2\u30eb\n    MemAccessResponse memAccessResponse; // \u30e1\u30e2\u30ea\u66f8\u304d\u8fbc\u307f\u5b8c\u4e86\u901a\u77e5\n\n\n`ifdef RSD_USE_EXTERNAL_MEMORY\n    Axi4Memory axi4Memory(\n        .port(axi4MemoryIF),\n        .memAccessAddr( memAccessAddr ),\n        .memAccessWriteData( memAccessWriteData ),\n        .memAccessRE( memAccessRE ),\n        .memAccessWE( memAccessWE ),\n        .memAccessReadBusy( memAccessReadBusy ),\n        .memAccessWriteBusy( memAccessWriteBusy ),\n        .nextMemReadSerial( nextMemReadSerial ),\n        .nextMemWriteSerial( nextMemWriteSerial ),\n        .memReadDataReady( memReadDataReady ),\n        .memReadData( memReadData ),\n        .memReadSerial( memReadSerial ),\n        .memAccessResponse( memAccessResponse )\n    );\n`else // Use internal memory\n    Memory #(\n        .INIT_HEX_FILE( MEM_INIT_HEX_FILE )\n    ) memory (\n        .clk( clk ),\n        .rst( rst ),\n        .memAccessAddr( memAccessAddr ),\n        .memAccessWriteData( memAccessWriteData ),\n        .memAccessRE( memAccessRE ),\n        .memAccessWE( memAccessWE ),\n        .memAccessBusy( memAccessBusy ),\n        .nextMemReadSerial( nextMemReadSerial ),\n        .nextMemWriteSerial( nextMemWriteSerial ),\n        .memReadDataReady( memReadDataReady ),\n        .memReadData( memReadData ),\n        .memReadSerial( memReadSerial ),\n        .memAccessResponse( memAccessResponse )\n    );\n\n    assign memAccessReadBusy = memAccessBusy;\n    assign memAccessWriteBusy = memAccessBusy;\n`endif\n\n`ifdef RSD_USE_PROGRAM_LOADER\n    always_comb begin\n        if ( !programLoaded ) begin\n            memAccessAddr = memAccessAddrFromProgramLoader;\n            memAccessWriteData = memAccessWriteDataFromProgramLoader;\n            memAccessRE = FALSE;\n            memAccessWE = memAccessWE_FromProgramLoader;\n        end\n        else begin\n            memAccessAddr = memAccessAddrFromCore;\n            memAccessWriteData = memAccessWriteDataFromCore;\n            memAccessRE = memAccessRE_FromCore;\n            memAccessWE = memAccessWE_FromCore;\n        end\n    end\n`else\n    always_comb begin\n`ifndef RSD_USE_EXTERNAL_MEMORY\n        programLoaded = TRUE;\n`endif\n        memAccessAddr = memAccessAddrFromCore;\n        memAccessWriteData = memAccessWriteDataFromCore;\n        memAccessRE = memAccessRE_FromCore;\n        memAccessWE = memAccessWE_FromCore;\n    end\n`endif\n    \n    //\n    // --- Serial communication IO\n    //\n    logic txdBuffer, serialReady;\n    \n    always_ff @(posedge clk) begin\n        txd <= txdBuffer;\n    end\n\n    //\n    // --- LED IO\n    //\n    PC_Path lastCommittedPC;\n\n`ifdef RSD_SYNTHESIS_ZEDBOARD\n    logic [25:0] ledBlinkCounter; // just for LED\n\n    always_ff @(posedge clk) begin\n        ledBlinkCounter <= ledBlinkCounter + 1;\n        \n        ledOut[7] <= ledBlinkCounter[25];\n        ledOut[6] <= FALSE; // TODO:\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u304c\u52d5\u3044\u3066\u3044\u308b\u304b\u3092\u8868\u793a\u3057\u305f\u3044\n        ledOut[5] <= ( lastCommittedPC == PC_GOAL ? TRUE : FALSE ); \n        ledOut[4] <= memAccessReadBusy | memAccessWriteBusy;   // DRAM is working\n        ledOut[3] <= ~txd;      // Uart TXD\n        ledOut[2] <= ~rxd;      // Uart RXD\n        ledOut[1] <= ~memCaribrationDone;  // DRAM calibration done \n        ledOut[0] <= ~programLoaded; // MEMORY IMAGE transfer is done\n    end\n`else\n    assign ledOut = lastCommittedPC[ LED_WIDTH-1:0 ];\n`endif\n\n    //\n    // --- AXI4Lite Control Register IO for ZYNQ\n    //\n`ifdef RSD_SYNTHESIS_ZEDBOARD\n    Axi4LitePlToPsControlRegister axi4LitePlToPsControlRegister( \n                            axi4LitePlToPsControlRegisterIF, \n                            serialWE, \n                            serialWriteData,\n                            lastCommittedPC );\n   \n    Axi4LitePsToPlControlRegister axi4LitePsToPlControlRegister( \n                            axi4LitePsToPlControlRegisterIF, \n                            memAccessAddrFromProgramLoader,\n                            memAccessWriteDataFromProgramLoader,\n                            memAccessWE_FromProgramLoader,\n                            programLoaded);\n`endif\n    logic reqExternalInterrupt;\n    ExternalInterruptCodePath externalInterruptCode; \n    always_comb begin\n        reqExternalInterrupt = FALSE;\n        externalInterruptCode = 0;\n    end\n\n    //\n    // --- Processor core\n    //\n    Core core (\n        .clk( clk ),\n        .rst( rst || !programLoaded ),\n        .memAccessAddr( memAccessAddrFromCore ),\n        .memAccessWriteData( memAccessWriteDataFromCore ),\n        .memAccessRE( memAccessRE_FromCore ),\n        .memAccessWE( memAccessWE_FromCore ),\n        .memAccessReadBusy( memAccessReadBusy ),\n        .memAccessWriteBusy( memAccessWriteBusy ),\n        .reqExternalInterrupt( reqExternalInterrupt ),\n        .externalInterruptCode( externalInterruptCode ),\n        .nextMemReadSerial( nextMemReadSerial ),\n        .nextMemWriteSerial( nextMemWriteSerial ),\n        .memReadDataReady( memReadDataReady ),\n        .memReadData( memReadData ),\n        .memReadSerial( memReadSerial ),\n        .memAccessResponse( memAccessResponse ),\n        .rstStart( rstStart ),\n        .serialWE( serialWE ),\n        .serialWriteData( serialWriteData ),\n        .lastCommittedPC( lastCommittedPC ),\n        .debugRegister ( debugRegister )\n    );\n    \nendmodule : Main_Zynq\n\n`endif\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n\n//\n// Main_RSD\n//\n// This is wrapper module for compiling at synplify2017\n\n`ifndef RSD_SYNTHESIS_ATLYS\n\n`include \"SysDeps/XilinxMacros.vh\"\n\nimport BasicTypes::*;\nimport CacheSystemTypes::*;\nimport MemoryTypes::*;\nimport DebugTypes::*;\nimport MemoryMapTypes::*;\nimport IO_UnitTypes::*;\n\nmodule Main_Zynq_Wrapper #(\n`ifdef RSD_POST_SYNTHESIS\n    parameter MEM_INIT_HEX_FILE = \"code.hex\"\n`else\n    parameter MEM_INIT_HEX_FILE = \"\"\n`endif\n)(\n\n`ifdef RSD_SYNTHESIS_ZEDBOARD\ninput\n    logic clk,\n    logic negResetIn, // \u8ca0\u8ad6\u7406\noutput\n    LED_Path ledOut, // LED Output\n`else\n// RSD_POST_SYNTHESIS\n// RSD_FUNCTIONAL_SIMULATION\ninput\n    logic clk_p, clk_n,\n    logic negResetIn, // \u8ca0\u8ad6\u7406\n    logic rxd,\n`endif\n\n`ifndef RSD_SYNTHESIS_VIVADO\noutput\n    DebugRegister debugRegister,\n`endif\n\n`ifdef RSD_USE_EXTERNAL_MEMORY\n    `EXPAND_AXI4MEMORY_PORT\n`endif\n\n`ifdef RSD_SYNTHESIS_ZEDBOARD\n    `EXPAND_CONTROL_REGISTER_PORT\n`else \noutput\n    logic serialWE,\n    SerialDataPath serialWriteData,\n    logic posResetOut, // \u6b63\u8ad6\u7406\n    LED_Path ledOut, // LED Output\n    logic txd\n`endif\n);\n\n`ifdef RSD_SYNTHESIS_VIVADO\n   (* DONT_TOUCH=\"yes\"*) logic [$bits(DebugRegister)-1:0] debugRegister;\n`endif\n\n`ifdef RSD_USE_EXTERNAL_MEMORY\n    Axi4MemoryIF axi4MemoryIF();\n\n    always_comb begin\n        // Combine external ports into IF\n        `CONNECT_AXI4MEMORY_IF\n    end\n`endif\n\n\n\n`ifdef RSD_SYNTHESIS_ZEDBOARD\n    Axi4LiteControlRegisterIF axi4LitePlToPsControlRegisterIF();\n    Axi4LiteControlRegisterIF axi4LitePsToPlControlRegisterIF();\n\n    always_comb begin\n        // Combine external ports into IF\n        `CONNECT_CONTROL_REGISTER_IF\n    end\n`endif\n\n    Main_Zynq #(\n        .MEM_INIT_HEX_FILE (MEM_INIT_HEX_FILE)\n    ) main (\n`ifdef RSD_SYNTHESIS_ZEDBOARD\n        clk,\n        negResetIn,\n        ledOut,\n`else\n        clk_p,\n        clk_n,\n        negResetIn,\n        rxd,\n`endif\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        debugRegister,\n`endif\n\n`ifdef RSD_USE_EXTERNAL_MEMORY\n        axi4MemoryIF,\n`endif\n\n`ifdef RSD_SYNTHESIS_ZEDBOARD\n        axi4LitePlToPsControlRegisterIF,\n        axi4LitePsToPlControlRegisterIF\n`else \n        serialWE,\n        serialWriteData,\n        posResetOut,\n        ledOut,\n        txd\n`endif\n    );\n\n\nendmodule : Main_Zynq_Wrapper\n\n`endif\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Main Memory\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport CacheSystemTypes::*;\nimport MemoryTypes::*;\n\n\n/* \u30e1\u30a4\u30f3\u30e1\u30e2\u30ea\u30e2\u30b8\u30e5\u30fc\u30eb\nSpartan-6\u306eDRAM\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u3092\u6a21\u3057\u3066\u3044\u308b\u3002\n\u8aad\u307f\u51fa\u3057\u306f\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5316\u3055\u308c\u3066\u3044\u3066\u3001DRAM\u30a2\u30af\u30bb\u30b9\u306e\u9045\u5ef6\u3092\u30b7\u30df\u30e5\u30ec\u30fc\u30c8\u3067\u304d\u308b\u3002\n\nmemAccess**\u306b\u306f\u8aad\u51fa/\u66f8\u8fbc\u306e\u8981\u6c42\u3092\u66f8\u304d\u8fbc\u3080\u3002\n\u8981\u6c42\u304c\u53d7\u3051\u4ed8\u3051\u3089\u308c\u306a\u3044\u5834\u5408\u3001\u51fa\u529bmemAccessBusy\u304cTRUE\u306b\u306a\u308b\u3002\n\nmemRead**\u306b\u306f\u3001\u8aad\u51fa\u7d50\u679c\u304c\u6570\u30b5\u30a4\u30af\u30eb\u9045\u308c\u3066\u51fa\u3066\u304f\u308b\u3002\n\n\u8aad\u51fa\u30ec\u30a4\u30c6\u30f3\u30b7\u306f\u3001\u4ee5\u4e0b\u306e\u5f0f\u3067\u8868\u3055\u308c\u308b\u3002\nBlockRAM\u306e\u30ec\u30a4\u30c6\u30f3\u30b7 + \u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u306e\u6df1\u3055\n*/\nmodule Memory #(\n    parameter INIT_HEX_FILE = \"\"    // Memory initialization file path\n)(\ninput\n    logic clk,\n    logic rst,\n    AddrPath memAccessAddr,\n    MemoryEntryDataPath memAccessWriteData,\n    logic memAccessRE,\n    logic memAccessWE,\noutput\n    logic memAccessBusy,    // \u30e1\u30e2\u30ea\u30a2\u30af\u30bb\u30b9\u8981\u6c42\u3092\u53d7\u3051\u4ed8\u3051\u3089\u308c\u306a\u3044\n    MemAccessSerial nextMemReadSerial, // RSD\u306e\u6b21\u306e\u8aad\u307f\u51fa\u3057\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb(id)\n    MemWriteSerial nextMemWriteSerial, // RSD\u306e\u6b21\u306e\u66f8\u304d\u8fbc\u307f\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb(id)\n    logic memReadDataReady, // TRUE\u306a\u3089\u3001\u30e1\u30e2\u30ea\u306e\u8aad\u51fa\u3057\u30c7\u30fc\u30bf\u3042\u308a\n    MemoryEntryDataPath memReadData, // \u30e1\u30e2\u30ea\u306e\u8aad\u51fa\u3057\u30c7\u30fc\u30bf\n    MemAccessSerial memReadSerial, // \u30e1\u30e2\u30ea\u306e\u8aad\u307f\u51fa\u3057\u30c7\u30fc\u30bf\u306e\u30b7\u30ea\u30a2\u30eb\n    MemAccessResponse memAccessResponse // \u30e1\u30e2\u30ea\u66f8\u304d\u8fbc\u307f\u5b8c\u4e86\u901a\u77e5\n);\n\n    // \u30e1\u30e2\u30ea\u8aad\u51fa\n    typedef struct packed { // MemoryPipeReg\n        logic valid;\n        MemoryEntryDataPath data;\n        MemAccessSerial serial;\n        MemWriteSerial wserial;\n        logic wr;\n    } MemoryPipeReg;\n    \n    MemoryPipeReg memPipeReg[ MEMORY_READ_PIPELINE_DEPTH ];\n    MemoryPipeReg nextMemPipeReg; // \u6b21\u30b5\u30a4\u30af\u30eb\u3067\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u306b\u6295\u5165\u3059\u308b\u30c7\u30fc\u30bf\n\n    MemAccessSerial nextNextMemReadSerial; // RSD\u306e\u6b21\u306e\u8aad\u307f\u51fa\u3057\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb(id)\n    MemWriteSerial nextNextMemWriteSerial; // RSD\u306e\u6b21\u306e\u66f8\u304d\u8fbc\u307f\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb(id)\n    \n    logic memReadAccessAck, prevMemReadAccessAck; // \u8aad\u51fa\u8981\u6c42\u3092\u53d7\u3051\u4ed8\u3051\u305f\u304b\u3069\u3046\u304b\n    logic memWriteAccessAck, prevMemWriteAccessAck; // \u8aad\u51fa\u8981\u6c42\u3092\u53d7\u3051\u4ed8\u3051\u305f\u304b\u3069\u3046\u304b\n    \n    // AccessBusy\u3067\u3042\u308b\u6b8b\u308a\u30b5\u30a4\u30af\u30eb\u6570\u3092\u30ab\u30a6\u30f3\u30c8\n    MemoryProcessLatencyCount processLatencyCount, nextProcessLatencyCount;\n    \n    MemoryEntryDataPath ramReadData;\n    \n    logic memoryWE;\n    AddrPath memoryWA;\n    MemoryEntryDataPath memoryWV;\n    AddrPath memoryRA;\n\n    // Body\n    InitializedBlockRAM #( \n        .ENTRY_NUM( MEMORY_ENTRY_NUM ),\n        .INIT_HEX_FILE( INIT_HEX_FILE ),\n        .ENTRY_BIT_SIZE( MEMORY_ENTRY_BIT_NUM )\n    ) body ( \n        .clk( clk ),\n        .we( memoryWE ),\n        .wa( memoryWA[ MEMORY_ADDR_MSB : MEMORY_ADDR_LSB ] ),\n        .wv( memoryWV ),\n        .ra( memoryRA[ MEMORY_ADDR_MSB : MEMORY_ADDR_LSB ] ),\n        .rv( ramReadData )\n    );\n\n    // Push memory request temporarily to queue\n    logic pushRequestQueue;\n    MemoryLatencySimRequestPath pushedData;\n\n    logic hasRequest, hasRequestReg;\n    MemoryLatencySimRequestPath requestData, requestDataReg;\n\n    MemoryLatencySimulator memReqQueue(\n        .clk (clk),\n        .rst (rst),\n        .push (pushRequestQueue),\n        .pushedData (pushedData),\n        .hasRequest (hasRequest),\n        .requestData (requestData)\n    );\n    \n    // ARC\u30b3\u30f3\u30c6\u30b9\u30c8\u306eDDR2\u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306b\u5408\u308f\u305b\u3001\n    // \u30af\u30ed\u30c3\u30af\u306e\u7acb\u3061\u4e0b\u304c\u308a\u3067\u52d5\u304b\u3059\n    always_ff @( posedge clk ) begin\n        if ( rst ) begin\n            processLatencyCount <= FALSE;\n            prevMemReadAccessAck <= FALSE;\n            prevMemWriteAccessAck <= FALSE;\n            nextMemReadSerial <= '0;\n            nextMemWriteSerial <= '0;\n            requestDataReg <= '0;\n            hasRequestReg <= FALSE;\n            \n            for ( int i = 0; i < MEMORY_READ_PIPELINE_DEPTH; i++ ) begin\n                memPipeReg[i] <= '0;\n            end\n        end\n        else begin\n            processLatencyCount <= nextProcessLatencyCount;\n            prevMemReadAccessAck <= memReadAccessAck;\n            prevMemWriteAccessAck <= memWriteAccessAck;\n            nextMemReadSerial <= nextNextMemReadSerial;\n            nextMemWriteSerial <= nextNextMemWriteSerial;\n            requestDataReg <= requestData;\n            hasRequestReg <= hasRequest;\n            \n            memPipeReg[0] <= nextMemPipeReg;\n            for ( int i = 0; i < MEMORY_READ_PIPELINE_DEPTH-1; i++ ) begin\n                memPipeReg[i+1] <= memPipeReg[i];\n            end\n        end\n    end\n    \n    always_comb begin\n        // AccessBusy\u3067\u3042\u308b\u6b8b\u308a\u6642\u9593\u3092\u30ab\u30a6\u30f3\u30c8\n        if ( memAccessBusy ) begin\n            nextProcessLatencyCount = processLatencyCount - 1;\n        end\n        else begin\n            // RE/WE\u304c\u7acb\u3063\u305f\u3089\u3001\u6570\u30b5\u30a4\u30af\u30ebAccessBusy\u306b\u306a\u308b\n            if ( memAccessRE ) begin\n                nextProcessLatencyCount = MEMORY_READ_PROCESS_LATENCY;\n            end\n            else if ( memAccessWE ) begin\n                nextProcessLatencyCount = MEMORY_WRITE_PROCESS_LATENCY;\n            end\n            else begin\n                nextProcessLatencyCount = 0;\n            end\n        end\n\n        if (prevMemReadAccessAck) begin\n            nextNextMemReadSerial = nextMemReadSerial + 1;\n        end\n        else begin\n            nextNextMemReadSerial = nextMemReadSerial;\n        end\n\n        if (prevMemWriteAccessAck) begin\n            nextNextMemWriteSerial = nextMemWriteSerial + 1;\n        end\n        else begin\n            nextNextMemWriteSerial = nextMemWriteSerial;\n        end\n        \n        // \u8aad\u51fa\u8981\u6c42\u304c\u6765\u3066\u3001Busy\u3058\u3083\u306a\u3051\u308c\u3070\u53d7\u3051\u4ed8\u3051\u308b\n        memReadAccessAck = ( memAccessRE && !memAccessBusy ) ? TRUE : FALSE;\n\n        // \u66f8\u8fbc\u8981\u6c42\u304c\u6765\u3066\u3001Busy\u3058\u3083\u306a\u3051\u308c\u3070\u53d7\u3051\u4ed8\u3051\u308b\n        memWriteAccessAck = ( memAccessWE && !memAccessBusy ) ? TRUE : FALSE;\n        \n        // \u524d\u306e\u30b5\u30a4\u30af\u30eb\u3067\u8aad\u51fa\u8981\u6c42\u3092\u53d7\u3051\u4ed8\u3051\u305f\u3089\u3001\u8aad\u51fa\u7d50\u679c\u3092\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u306b\u5165\u529b\n        \n        /* \u4fee\u6b63\u524d\n        nextMemPipeReg.valid = prevMemReadAccessAck;\n        nextMemPipeReg.data = ramReadData;\n        nextMemPipeReg.serial = nextMemReadSerial;\n        nextMemPipeReg.wserial = nextMemWriteSerial;\n        nextMemPipeReg.wr = prevMemWriteAccessAck;\n        */\n        nextMemPipeReg.valid = hasRequestReg ? requestDataReg.isRead : FALSE;\n        nextMemPipeReg.data = ramReadData;\n        nextMemPipeReg.serial = requestDataReg.nextMemReadSerial;\n        nextMemPipeReg.wserial = requestDataReg.nextMemWriteSerial;\n        nextMemPipeReg.wr = requestDataReg.wr;\n\n        pushRequestQueue = memReadAccessAck || memWriteAccessAck;\n        pushedData.isRead = memAccessRE;\n        pushedData.isWrite = memAccessWE;\n        pushedData.memAccessAddr = memAccessAddr;\n        pushedData.memAccessWriteData = memAccessWriteData;\n        pushedData.nextMemReadSerial = nextNextMemReadSerial;\n        pushedData.nextMemWriteSerial = nextNextMemWriteSerial;\n        pushedData.wr = memWriteAccessAck;\n\n        memoryWE = hasRequest ? requestData.isWrite : FALSE;\n        memoryWA = requestData.memAccessAddr;\n        memoryWV = requestData.memAccessWriteData;\n        memoryRA = requestData.memAccessAddr;\n\n    end\n\n    // \u51fa\u529b\u30dd\u30fc\u30c8\n    always_comb begin\n        memReadDataReady = memPipeReg[ MEMORY_READ_PIPELINE_DEPTH-1 ].valid;\n        memReadData = memPipeReg[ MEMORY_READ_PIPELINE_DEPTH-1 ].data;\n        memAccessBusy = ( processLatencyCount != 0 ? TRUE : FALSE );\n        memReadSerial = memPipeReg[ MEMORY_READ_PIPELINE_DEPTH-1 ].serial;\n        memAccessResponse.valid = memPipeReg[ MEMORY_WRITE_PROCESS_LATENCY-1 ].wr;\n        memAccessResponse.serial = memPipeReg[ MEMORY_WRITE_PROCESS_LATENCY-1 ].wserial;\n    end\n\n    `RSD_ASSERT_CLK(\n        clk,\n        !(memAccessRE && memAccessWE),\n        \"Cannot read and write the memory in the same cycle!\"\n    );\n endmodule\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Memory Access Controller\n// \u30ad\u30e3\u30c3\u30b7\u30e5\u3068\u30e1\u30e2\u30ea\u306e\u9593\u306b\u5b58\u5728\u3057\u3001\n// \u30e1\u30e2\u30ea\u30a2\u30af\u30bb\u30b9\u8981\u6c42\u306e\u5f62\u5f0f\u3092\u5909\u63db\u3059\u308b\u3002\n// ICache\u3068DCache\u304b\u3089\u306e\u30a2\u30af\u30bb\u30b9\u306e\u8abf\u505c\u3082\u884c\u3046\u3002\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport CacheSystemTypes::*;\nimport MemoryTypes::*;\nimport MemoryMapTypes::*;\n\nmodule MemoryAccessController (\n    CacheSystemIF.MemoryAccessController port,\ninput\n    MemAccessSerial nextMemReadSerial, // RSD\u306e\u6b21\u306e\u8aad\u307f\u51fa\u3057\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb(id)\n    MemWriteSerial nextMemWriteSerial, // RSD\u306e\u6b21\u306e\u66f8\u304d\u8fbc\u307f\u8981\u6c42\u306b\u5272\u308a\u5f53\u3066\u3089\u308c\u308b\u30b7\u30ea\u30a2\u30eb(id)\n    MemoryEntryDataPath memReadData,\n    logic memReadDataReady,\n    MemAccessSerial memReadSerial, // \u30e1\u30e2\u30ea\u306e\u8aad\u307f\u51fa\u3057\u30c7\u30fc\u30bf\u306e\u30b7\u30ea\u30a2\u30eb\n    MemAccessResponse memAccessResponse, // \u30e1\u30e2\u30ea\u66f8\u304d\u8fbc\u307f\u5b8c\u4e86\u901a\u77e5\n    logic memAccessReadBusy,\n    logic memAccessWriteBusy,\noutput\n    PhyAddrPath memAccessAddr,\n    MemoryEntryDataPath memAccessWriteData,\n    logic memAccessRE,\n    logic memAccessWE\n);\n    // ICache/DCache\u304b\u3089\u306e\u8981\u6c42\u3092\u53d7\u7406\u3059\u308b\u304b\u5426\u304b\n    logic icAck;\n    logic dcAck;\n\n    // \u30e1\u30e2\u30ea\u30a2\u30af\u30bb\u30b9\u306e\u30b7\u30ea\u30a2\u30eb\u756a\u53f7\u3092\u4fdd\u6301\u3059\u308b\u30ab\u30a6\u30f3\u30bf\n    // \u73fe\u5728\u306e\u5b9f\u88c5\u3067\u306f\u3001\u8aad\u51fa\u3057\n    MemAccessSerial reqSerial, nextReqSerial;\n    MemAccessSerial resultSerial, nextResultSerial;\n\n    always_ff @( posedge port.clk ) begin\n        if ( port.rst ) begin\n            reqSerial <= '0;\n            resultSerial <= '0;\n        end\n        else begin\n            reqSerial <= nextReqSerial;\n            resultSerial <= nextResultSerial;\n        end\n    end\n\n    // \u30e1\u30e2\u30ea\u3078\u306e\u30a2\u30af\u30bb\u30b9\u8981\u6c42\n    always_comb begin\n        // ICache/DCache\u306e\u8981\u6c42\u3092\u53d7\u3051\u308bor\u4f55\u3082\u3057\u306a\u3044 \u3092\u6c7a\u5b9a\n        icAck = FALSE;\n        dcAck = FALSE;\n        if ( !memAccessReadBusy && port.icMemAccessReq.valid )\n            icAck = TRUE;\n        else if ( !memAccessReadBusy && port.dcMemAccessReq.valid && ( port.dcMemAccessReq.we == FALSE ) )\n            dcAck = TRUE;\n        else if ( !memAccessWriteBusy && port.dcMemAccessReq.valid  && ( port.dcMemAccessReq.we == TRUE ) )\n            dcAck = TRUE;\n\n        // ICache/DCache\u306e\u8981\u6c42\u3092\u53d7\u3051\u308b\u5834\u5408\u3001\n        // \u305d\u308c\u306b\u5f93\u3063\u3066\u30e1\u30e2\u30ea\u3078\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u9001\u308b\n        if ( icAck ) begin\n            memAccessAddr = port.icMemAccessReq.addr;\n            memAccessWriteData = '0;\n            memAccessRE = TRUE;\n            memAccessWE = FALSE;\n        end\n        else if ( dcAck ) begin\n            memAccessAddr = port.dcMemAccessReq.addr;\n            memAccessWriteData = port.dcMemAccessReq.data;\n            memAccessRE = ( port.dcMemAccessReq.we ? FALSE : TRUE );\n            memAccessWE = ( port.dcMemAccessReq.we ? TRUE : FALSE );\n        end\n        else begin\n            memAccessAddr = '0;\n            memAccessWriteData = '0;\n            memAccessRE = FALSE;\n            memAccessWE = FALSE;\n        end\n\n        // Ack for Request\n        port.icMemAccessReqAck.ack = icAck;\n        port.icMemAccessReqAck.serial = nextMemReadSerial; // I-Cache\u306f\u8aad\u307f\u51fa\u3057\u8981\u6c42\u3057\u304b\u3057\u306a\u3044\n        port.dcMemAccessReqAck.ack = dcAck;\n        // D-Cache\u306e\u8981\u6c42\u306f\u66f8\u304d\u8fbc\u307f\u3068\u8aad\u307f\u51fa\u3057\u306e2\u7a2e\u985e\u3042\u308a\uff0c\u30b7\u30ea\u30a2\u30eb\u306f\u72ec\u7acb\u306b\u7ba1\u7406\u3055\u308c\u3066\u3044\u308b\n        port.dcMemAccessReqAck.serial = nextMemReadSerial;\n        port.dcMemAccessReqAck.wserial = nextMemWriteSerial;\n    end\n\n    // \u30e1\u30e2\u30ea\u306e\u8aad\u51fa\u3057\u7d50\u679c\n    always_comb begin\n        port.icMemAccessResult.valid = memReadDataReady;\n        port.icMemAccessResult.serial = memReadSerial;\n        port.icMemAccessResult.data = memReadData;\n        port.dcMemAccessResult.valid = memReadDataReady;\n        port.dcMemAccessResult.serial = memReadSerial;\n        port.dcMemAccessResult.data = memReadData;\n        port.dcMemAccessResponse = memAccessResponse;\n    end\n\n    // MemAccessSerial\n    always_comb begin\n        nextReqSerial = reqSerial;\n        nextResultSerial = resultSerial;\n\n        // \u8aad\u51fa\u8981\u6c42\u304c\u6765\u305f\u3089\u3001reqSerial\u3092\u30a4\u30f3\u30af\u30ea\u30e1\u30f3\u30c8\n        if ( icAck || ( dcAck && port.dcMemAccessReq.we == FALSE ) ) begin\n            nextReqSerial = reqSerial + 1;\n        end\n\n        // \u8aad\u51fa\u7d50\u679c\u304c\u6765\u305f\u3089\u3001resultSerial\u3092\u30a4\u30f3\u30af\u30ea\u30e1\u30f3\u30c8\n        if ( memReadDataReady ) begin\n            nextResultSerial = resultSerial + 1;\n        end\n    end\n\n    // \u73fe\u5728\u306e\u5b9f\u88c5\u3067\u306f\u3001\u30ad\u30e3\u30c3\u30b7\u30e5\u30e9\u30a4\u30f3\u306e\u30c7\u30fc\u30bf\u5e45\u3068\u30e1\u30e2\u30ea\u306e\u5165\u51fa\u529b\u30c7\u30fc\u30bf\u5e45\u306f\n    // \u540c\u3058\u3067\u3042\u308b\u5fc5\u8981\u304c\u3042\u308b\u3002\n    `RSD_STATIC_ASSERT(\n        $bits(ICacheLinePath) == $bits(MemoryEntryDataPath), \n        (\"The data width of a cache line(%x) and a memory entry(%x) are not matched.\", $bits(ICacheLinePath), $bits(MemoryEntryDataPath))\n    );\n    `RSD_STATIC_ASSERT(\n        $bits(DCacheLinePath) == $bits(MemoryEntryDataPath),\n        (\"The data width of a cache line(%x) and a memory entry(%x) are not matched.\", $bits(DCacheLinePath), $bits(MemoryEntryDataPath))\n    );\nendmodule\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Memory access stage\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport RenameLogicTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\nimport MicroOpTypes::*;\nimport MemoryMapTypes::*;\nimport ActiveListIndexTypes::*;\n\nmodule MemoryAccessStage(\n    MemoryAccessStageIF.ThisStage port,\n    MemoryTagAccessStageIF.NextStage prev,\n    LoadStoreUnitIF.MemoryAccessStage loadStoreUnit,\n    MulDivUnitIF.MemoryAccessStage mulDivUnit,\n    BypassNetworkIF.MemoryAccessStage bypass,\n    IO_UnitIF.MemoryAccessStage ioUnit,\n    RecoveryManagerIF.MemoryAccessStage recovery,\n    ControllerIF.MemoryAccessStage ctrl,\n    DebugIF.MemoryAccessStage debug\n);\n\n    MemoryAccessStageRegPath pipeReg[MEM_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n\n    // --- Pipeline registers\n    always_ff@( posedge port.clk )   // synchronous rst\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= '0;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin              // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n\n\n    logic isStore  [ MEM_ISSUE_WIDTH ];\n    logic isLoad  [ MEM_ISSUE_WIDTH ];\n    logic isCSR   [ MEM_ISSUE_WIDTH ];\n    logic isDiv   [ MEM_ISSUE_WIDTH ];\n    logic isMul   [ MEM_ISSUE_WIDTH ];\n\n\n    logic valid   [ MEM_ISSUE_WIDTH ];\n    logic update  [ MEM_ISSUE_WIDTH ];\n\n    logic regValid[ MEM_ISSUE_WIDTH ];\n\n    // Pipeline controll\n    logic stall, clear;\n    logic flush[ MEM_ISSUE_WIDTH ];\n    MemoryRegisterWriteStageRegPath nextStage [ MEM_ISSUE_WIDTH ];\n\n    PRegDataPath  dataOut[MEM_ISSUE_WIDTH];\n    PRegDataPath  ldDataOut[LOAD_ISSUE_WIDTH];\n    PRegDataPath  stDataOut[STORE_ISSUE_WIDTH];\n\n    always_comb begin\n        \n        // Pipeline controll\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            valid[i]   = pipeReg[i].valid;\n            flush[i] = SelectiveFlushDetector(\n                            recovery.toRecoveryPhase,\n                            recovery.flushRangeHeadPtr,\n                            recovery.flushRangeTailPtr,\n                            recovery.flushAllInsns,\n                            pipeReg[i].activeListPtr\n                        );\n            isStore[i] = pipeReg[i].isStore;\n            isLoad[i]  = pipeReg[i].isLoad;\n            isCSR[i]   = pipeReg[i].isCSR;\n            isDiv[i]   = pipeReg[i].isDiv;\n            isMul[i]   = pipeReg[i].isMul;\n            update[i]  = pipeReg[i].valid && !stall && !clear && !flush[i];\n            regValid[i] = pipeReg[i].regValid;\n        end\n\n        for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin\n            if (i == 0) begin\n                ioUnit.ioReadAddrIn = pipeReg[i].phyAddrOut;\n            end\n\n            if (isLoad[i]) begin\n                if (i == 0 && pipeReg[i].memMapType == MMT_IO) begin\n                    ldDataOut[i].data = ioUnit.ioReadDataOut;\n                end\n                else begin\n                    ldDataOut[i].data = loadStoreUnit.executedLoadData[i];\n                end\n            end\n            else if (isCSR[i])\n                ldDataOut[i].data = pipeReg[i].csrDataOut;\n            else\n                ldDataOut[i].data = pipeReg[i].addrOut;\n\n            `ifdef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n                if (isDiv[i])\n                    ldDataOut[i].data = mulDivUnit.divDataOut[i];\n                else if (isMul[i])\n                    ldDataOut[i].data = mulDivUnit.mulDataOut[i];\n\n                if (mulDivUnit.divFinished[i] &&\n                    update[i] &&\n                    isDiv[i] && \n                    regValid[i]\n                ) begin \n                    // Div\u304c\u9664\u7b97\u5668\u304b\u3089\u7d50\u679c\u3092\u53d6\u5f97\u3067\u304d\u305f\u306e\u3067\uff0c\n                    // IQ\u304b\u3089\u306ediv\u306e\u767a\u884c\u3092\u8a31\u53ef\u3059\u308b \n                    mulDivUnit.divRelease[i] = TRUE;\n                end\n                else begin\n                    mulDivUnit.divRelease[i] = FALSE;\n                end\n\n            `endif\n\n\n            ldDataOut[i].valid = regValid[i];\n        end\n        \n        for ( int i = 0; i < STORE_ISSUE_WIDTH; i++ ) begin\n            stDataOut[i].data = '0;\n            stDataOut[i].valid = FALSE;\n        end\n\n\n        `ifdef RSD_MARCH_UNIFIED_LDST_MEM_PIPE\n            for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n                dataOut[i] = isStore[i] ? stDataOut[i] : ldDataOut[i];\n            end\n        `else\n            for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin\n                dataOut[i] = ldDataOut[i];\n            end\n            for ( int i = 0; i < STORE_ISSUE_WIDTH; i++ ) begin\n                dataOut[i+STORE_ISSUE_LANE_BEGIN] = stDataOut[i];\n            end\n        `endif\n\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            nextStage[i].dataOut = dataOut[i];\n            bypass.memDstRegDataOut[i] = dataOut[i];    // Bypass\n\n            // Pipeline \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId = pipeReg[i].opId;\n`endif\n\n            nextStage[i].opDst = pipeReg[i].opDst;\n\n            nextStage[i].activeListPtr = pipeReg[i].activeListPtr;\n            nextStage[i].loadQueueRecoveryPtr = pipeReg[i].loadQueueRecoveryPtr;\n            nextStage[i].storeQueueRecoveryPtr = pipeReg[i].storeQueueRecoveryPtr;\n            nextStage[i].execState = pipeReg[i].execState;\n            nextStage[i].pc = pipeReg[i].pc;\n            nextStage[i].addrOut = pipeReg[i].addrOut;\n            nextStage[i].isStore = pipeReg[i].isStore;\n            nextStage[i].isLoad = pipeReg[i].isLoad;\n            nextStage[i].hasAllocatedMSHR = pipeReg[i].hasAllocatedMSHR;\n            nextStage[i].mshrID = pipeReg[i].mshrID;\n            nextStage[i].storeForwardMiss = pipeReg[i].storeForwardMiss;\n\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            nextStage[i].valid =\n                (stall || clear || port.rst || flush[i]) ? FALSE : pipeReg[i].valid;\n        end\n\n        port.nextStage = nextStage;\n\n        // Debug Register\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n            debug.maReg[i].valid = pipeReg[i].valid;\n            debug.maReg[i].flush = flush[i];\n            debug.maReg[i].opId = pipeReg[i].opId;\n        end\n`ifdef RSD_FUNCTIONAL_SIMULATION\n        for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n            debug.maReg[i].executeLoad       = update[i] && isLoad[i];\n            debug.maReg[i].executedLoadData  = dataOut[i].data;\n            debug.maReg[i].executedLoadVectorData = loadStoreUnit.executedLoadVectorData[i];\n        end\n`endif\n`endif\n    end\n\n    generate \n        for (genvar i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n            `RSD_ASSERT_CLK(\n                port.clk, \n                !(isLoad[i] && valid[i] && !flush[i] && i != 0 && pipeReg[i].memMapType == MMT_IO),\n                \"IO access cane be accessed in the mem lane 0.\"\n            );\n        end\n    endgenerate\n\n\nendmodule : MemoryAccessStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- RegisterWritePipeIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface MemoryAccessStageIF( input logic clk, rst );\n\n    // Pipeline register\n    MemoryRegisterWriteStageRegPath nextStage[MEM_ISSUE_WIDTH];\n    \n    \n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n    \n    modport NextStage(\n    input\n        nextStage\n    );\n\nendinterface : MemoryAccessStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Execution stage\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport PipelineTypes::*;\nimport RenameLogicTypes::*;\nimport DebugTypes::*;\nimport MemoryMapTypes::*;\n\n\n//\n// \u5b9f\u884c\u30b9\u30c6\u30fc\u30b8\n//\n\nmodule MemoryExecutionStage(\n    MemoryExecutionStageIF.ThisStage port,\n    MemoryRegisterReadStageIF.NextStage prev,\n    LoadStoreUnitIF.MemoryExecutionStage loadStoreUnit,\n    CacheFlushManagerIF.MemoryExecutionStage cacheFlush,\n    MulDivUnitIF.MemoryExecutionStage mulDivUnit,\n    BypassNetworkIF.MemoryExecutionStage bypass,\n    RecoveryManagerIF.MemoryExecutionStage recovery,\n    ControllerIF.MemoryExecutionStage ctrl,\n    CSR_UnitIF.MemoryExecutionStage csrUnit,\n    DebugIF.MemoryExecutionStage debug\n);\n\n    MemoryExecutionStageRegPath pipeReg[MEM_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n\n    // --- Pipeline registers\n    always_ff@( posedge port.clk )   // synchronous rst\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= '0;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin              // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n\n    // Pipeline control\n    logic stall, clear;\n    logic flush[ MEM_ISSUE_WIDTH ];\n\n    MemIssueQueueEntry iqData[MEM_ISSUE_WIDTH];\n    MemOpInfo memOpInfo  [ MEM_ISSUE_WIDTH ];\n\n    PRegDataPath  fuOpA  [ MEM_ISSUE_WIDTH ];\n    PRegDataPath  fuOpB  [ MEM_ISSUE_WIDTH ];\n\n    // Valid bits of registers\n    logic regValid[MEM_ISSUE_WIDTH];\n\n    AddrPath addrOut[ MEM_ISSUE_WIDTH ];\n    MemoryMapType memMapType[MEM_ISSUE_WIDTH];\n    PhyAddrPath phyAddrOut[MEM_ISSUE_WIDTH];\n    logic isUncachable[MEM_ISSUE_WIDTH];\n\n\n    // FENCE.I\n    logic cacheFlushReq;\n\n    always_comb begin\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            iqData[i] = pipeReg[i].memQueueData;\n            flush[i] = SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        iqData[i].activeListPtr\n                        );\n            memOpInfo[i]  = iqData[i].memOpInfo;\n\n      \n            // \u30aa\u30da\u30e9\u30f3\u30c9\n            fuOpA[i] = ( pipeReg[i].bCtrl.rA.valid ? bypass.memSrcRegDataOutA[i] : pipeReg[i].operandA );\n            fuOpB[i] = ( pipeReg[i].bCtrl.rB.valid ? bypass.memSrcRegDataOutB[i] : pipeReg[i].operandB );\n\n            // Address unit\n            addrOut[i] = fuOpA[i].data + { {ADDR_SIGN_EXTENTION_WIDTH{memOpInfo[i].addrIn[ADDR_OPERAND_IMM_WIDTH-1]}}, memOpInfo[i].addrIn };\n            phyAddrOut[i] = ToPhyAddrFromLogical(addrOut[i]);\n            memMapType[i] = GetMemoryMapType(addrOut[i]);\n            isUncachable[i] = IsPhyAddrUncachable(phyAddrOut[i]);\n\n            // --- Bypass\n            // \u5236\u5fa1\n            bypass.memCtrlIn[i] = pipeReg[i].bCtrl;\n\n            // Register valid bits.\n            // If invalid registers are read, regValid is negated and this op must be replayed.\n            regValid[i] =\n                (memOpInfo[i].operandTypeA != OOT_REG || fuOpA[i].valid ) &&\n                (memOpInfo[i].operandTypeB != OOT_REG || fuOpB[i].valid );\n\n        end // for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n\n        for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin\n            // --- DCache access\n            // TODO: \u30e1\u30e2\u30ea\u30de\u30c3\u30d7\u304c MMT_MEMORY \u3058\u3083\u306a\u304b\u3063\u305f\u3068\u3057\u3066\u3082\uff0c\u4e00\u5ea6 MSHR \u3092\u78ba\u4fdd\u3057\u3066\n            // \u3057\u307e\u3063\u305f\u5834\u5408\u306b\u306f\u30c7\u30fc\u30bf\u3092\u53d7\u3051\u53d6\u3089\u306a\u3044\u3068\u884c\u3051\u306a\u3044\u306e\u3067\uff0c\u3068\u308a\u3042\u3048\u305a\u3069\u3093\u306a\n            // \u9818\u57df\u306b\u30a2\u30af\u30bb\u30b9\u3092\u3059\u308b\u3068\u3057\u3066\u3082 DC \u304b\u3089\u30c7\u30fc\u30bf\u3092\u62fe\u3046\u3088\u3046\u306b\u3057\u3066\u304a\u304f\n            loadStoreUnit.dcReadReq[i] =\n                !stall && !clear && pipeReg[i].valid && regValid[i] && !flush[i] &&\n                (memOpInfo[i].opType inside { MEM_MOP_TYPE_LOAD });\n\n            //loadStoreUnit.dcReadAddr[i] = addrOut[i];\n            loadStoreUnit.dcReadAddr[i] = phyAddrOut[i];\n\n            loadStoreUnit.dcReadUncachable[i] = isUncachable[i];\n\n            // AL Ptr to release MSHR entry when allocator load is flushed.\n            loadStoreUnit.dcReadActiveListPtr[i] = pipeReg[i].memQueueData.activeListPtr;\n\n        end\n\n        // FENCE.I (with ICache and DCache flush)\n        // FENCE.I must be issued to the lane 0;\n        cacheFlushReq = FALSE;\n        if (pipeReg[0].valid && (memOpInfo[0].opType == MEM_MOP_TYPE_FENCE) && memOpInfo[0].isFenceI) begin\n            cacheFlushReq = TRUE;\n            if (!cacheFlush.cacheFlushComplete) begin\n                // FENCE.I must be replayed after cache flush is completed.\n                regValid[0] = FALSE;\n            end\n        end\n        cacheFlush.cacheFlushReq = cacheFlushReq;\n    end\n\n    //\n    // CSR access\n    //\n    generate\n        // Since a CSR op is serialized, so multiple CSR ops are not issued.\n        for (genvar i = 1; i < MEM_ISSUE_WIDTH; i++) begin : assertionBlock\n            `RSD_ASSERT_CLK(\n                port.clk, \n                !(memOpInfo[i].opType inside {\n                    MEM_MOP_TYPE_CSR, MEM_MOP_TYPE_FENCE, MEM_MOP_TYPE_ENV\n                } && pipeReg[i].valid),\n                \"A CSR/FENCE/ENV op was issued to a lane other than 0.\"\n            );\n        end\n    endgenerate\n\n    logic isCSR;\n    always_comb begin   // CSR must be issued to the lane 0;\n        isCSR = memOpInfo[0].opType == MEM_MOP_TYPE_CSR;\n\n        // CSR request\n        csrUnit.csrWE = pipeReg[0].valid && isCSR;\n        csrUnit.csrNumber = memOpInfo[0].addrIn;\n        csrUnit.csrWriteIn = \n            memOpInfo[0].csrCtrl.isImm ? memOpInfo[0].csrCtrl.imm : pipeReg[0].operandA;\n        csrUnit.csrCode = memOpInfo[0].csrCtrl.code;\n    end\n\n    //\n    // MulDiv\n    //\n`ifdef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    logic isDiv         [ MULDIV_ISSUE_WIDTH ]; \n    logic finished      [ MULDIV_ISSUE_WIDTH ];\n\n    MulOpSubInfo mulSubInfo[MULDIV_ISSUE_WIDTH];\n    DivOpSubInfo divSubInfo[MULDIV_ISSUE_WIDTH];\n    always_comb begin\n\n        for (int i = 0; i < MULDIV_ISSUE_WIDTH; i++) begin\n            mulDivUnit.dataInA[i] = fuOpA[i].data;\n            mulDivUnit.dataInB[i] = fuOpB[i].data;\n\n            // MUL\n            mulSubInfo[i]  = memOpInfo[i].mulSubInfo;\n            divSubInfo[i]  = memOpInfo[i].divSubInfo;\n            mulDivUnit.mulGetUpper[i] = mulSubInfo[i].mulGetUpper;\n            mulDivUnit.mulCode[i] = mulSubInfo[i].mulCode;\n\n            // DIV\n            mulDivUnit.divCode[i] = divSubInfo[i].divCode;\n\n            isDiv[i] =  \n                memOpInfo[i].opType inside {MEM_MOP_TYPE_DIV};\n\n            // Request to the divider\n            // NOT make a request when below situation\n            // 1) When any operands of inst. are invalid\n            // 2) When the divider is waiting for the instruction\n            //    to receive the result of the divider\n            mulDivUnit.divReq[i] = \n                mulDivUnit.divReserved[i] && \n                pipeReg[i].valid && isDiv[i] && \n                fuOpA[i].valid && fuOpB[i].valid;\n        end\n\n    end\n\n\n`endif\n\n\n\n    //\n    // --- Pipeline \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\n    //\n    MemoryTagAccessStageRegPath nextStage [ MEM_ISSUE_WIDTH ];\n\n    always_comb begin\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            nextStage[i].memQueueData = pipeReg[i].memQueueData;\n            // if (pipeReg[i].memQueueData.memOpInfo.opType != MEM_MOP_TYPE_LOAD)\n            //     nextStage[i].memQueueData.hasAllocatedMSHR = FALSE;\n\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            nextStage[i].valid =\n                (stall || clear || port.rst || flush[i]) ? FALSE : pipeReg[i].valid;\n            nextStage[i].condEnabled = TRUE;\n            nextStage[i].dataIn = (i == 0 && isCSR) ? csrUnit.csrReadOut : fuOpB[i].data;   // CSR must be issued to the lane 0\n            nextStage[i].addrOut = addrOut[i];\n            nextStage[i].regValid = regValid[i];\n            nextStage[i].memMapType = memMapType[i];\n            nextStage[i].phyAddrOut = phyAddrOut[i];\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId = pipeReg[i].opId;\n`endif\n        end\n\n\n        // Output\n        port.nextStage = nextStage;\n\n        // Debug Register\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            debug.memExReg[i].valid = pipeReg[i].valid;\n            debug.memExReg[i].flush = flush[i];\n            debug.memExReg[i].opId = pipeReg[i].opId;\n`ifdef RSD_FUNCTIONAL_SIMULATION\n            if (isCSR && i == 0) begin  // Special case for CSR\n                debug.memExReg[i].addrOut = csrUnit.csrReadOut;\n                debug.memExReg[i].fuOpA   = memOpInfo[0].addrIn;\n                debug.memExReg[i].fuOpB   = memOpInfo[0].csrCtrl.isImm ? memOpInfo[0].csrCtrl.imm : pipeReg[0].operandA;\n            end\n            else begin\n                debug.memExReg[i].addrOut = addrOut[i];\n                debug.memExReg[i].fuOpA   = fuOpA[i].data;\n                debug.memExReg[i].fuOpB   = fuOpB[i].data;\n            end\n            debug.memExReg[i].opType = memOpInfo[i].opType;\n            debug.memExReg[i].size = memOpInfo[i].memAccessMode.size;\n            debug.memExReg[i].isSigned = memOpInfo[i].memAccessMode.isSigned;\n`endif\n        end\n`endif\n    end\n\n    generate \n        for (genvar i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n            `RSD_ASSERT_CLK(\n                port.clk, \n                !(pipeReg[i].valid && \n                pipeReg[i].memQueueData.memOpInfo.opType != MEM_MOP_TYPE_LOAD && \n                pipeReg[i].memQueueData.hasAllocatedMSHR),\n                \"hasAllocatedMSHR is asserted other than a load pipe\"\n            );\n        end\n    endgenerate\n\n\nendmodule : MemoryExecutionStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- MemoryExecutionStageIF\n//\n\nimport BasicTypes::*;\nimport BypassTypes::*;\nimport OpFormatTypes::*;\nimport PipelineTypes::*;\n\n\ninterface MemoryExecutionStageIF( input logic clk, rst );\n\n    // Pipeline register\n    MemoryTagAccessStageRegPath nextStage[MEM_ISSUE_WIDTH];\n    \n    \n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\nendinterface : MemoryExecutionStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for issuing ops.\n//\n\n\nimport BasicTypes::*;\nimport MicroOpTypes::*;\nimport PipelineTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport DebugTypes::*;\n\nmodule MemoryIssueStage(\n    MemoryIssueStageIF.ThisStage port,\n    ScheduleStageIF.MemNextStage prev,\n    SchedulerIF.MemoryIssueStage scheduler,\n    RecoveryManagerIF.MemoryIssueStage recovery,\n    MulDivUnitIF.MemoryIssueStage mulDivUnit,\n    ControllerIF.MemoryIssueStage ctrl,\n    DebugIF.MemoryIssueStage debug\n);\n\n    // --- Pipeline registers\n    IssueStageRegPath pipeReg [ MEM_ISSUE_WIDTH ];\n    IssueStageRegPath nextPipeReg [ MEM_ISSUE_WIDTH ];\n    always_ff@( posedge port.clk )   // synchronous rst\n    begin\n        if ( port.rst ) begin\n            for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ )\n                pipeReg[i] <= '0;\n        end\n        else if( !ctrl.isStage.stall )              // write data\n            pipeReg <= prev.memNextStage;\n        else\n            pipeReg <= nextPipeReg;\n    end\n\n    always_comb begin\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n            if (recovery.toRecoveryPhase) begin\n                nextPipeReg[i].valid = \n                    pipeReg[i].valid &&\n                    !SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        scheduler.memIssuedData[i].activeListPtr\n                    );\n            end\n            else begin\n                nextPipeReg[i].valid = pipeReg[i].valid;\n            end\n            \n            nextPipeReg[i].issueQueuePtr = pipeReg[i].issueQueuePtr;\n        end\n    end\n\n\n\n    // Pipeline controll\n    logic stall, clear;\n    logic flush[ MEM_ISSUE_WIDTH ];\n    logic valid [ MEM_ISSUE_WIDTH ];\n    MemoryRegisterReadStageRegPath nextStage [ MEM_ISSUE_WIDTH ];\n    MemIssueQueueEntry issuedData [ MEM_ISSUE_WIDTH ];\n    IssueQueueIndexPath issueQueuePtr [ MEM_ISSUE_WIDTH ];\n\n    always_comb begin\n\n        stall = ctrl.isStage.stall;\n        clear = ctrl.isStage.clear;\n\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n\n            if (scheduler.replay) begin\n                issuedData[i] = scheduler.memReplayData[i];\n                valid[i] = scheduler.memReplayEntry[i];\n            end\n            else begin\n                issuedData[i] = scheduler.memIssuedData[i];\n                valid[i] = !stall && pipeReg[i].valid;\n            end\n\n            issueQueuePtr[i] = pipeReg[i].issueQueuePtr;\n\n            flush[i] = SelectiveFlushDetector(\n                        recovery.toRecoveryPhase,\n                        recovery.flushRangeHeadPtr,\n                        recovery.flushRangeTailPtr,\n                        recovery.flushAllInsns,\n                        issuedData[i].activeListPtr\n                        );\n\n            // Issue\n            scheduler.memIssue[i] = !clear && valid[i] && !flush[i];\n            scheduler.memIssuePtr[i] = issueQueuePtr[i];\n\n            // Release the entries of the issue queue.\n            nextStage[i].replay = scheduler.replay;\n            nextStage[i].issueQueuePtr = issueQueuePtr[i];\n\n            // --- Pipeline \u30e9\u30c3\u30c1\u66f8\u304d\u8fbc\u307f\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            nextStage[i].valid =\n                (clear || port.rst || flush[i]) ? FALSE : valid[i];\n            nextStage[i].memQueueData = issuedData[i];\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId = issuedData[i].opId;\n`endif\n        end\n\n`ifdef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        for (int i = 0; i < MULDIV_ISSUE_WIDTH; i++) begin\n            // Lock div units\n            mulDivUnit.divAcquire[i] = \n                !clear && valid[i] && !flush[i] && \n                issuedData[i].memOpInfo.opType == MEM_MOP_TYPE_DIV;\n            mulDivUnit.acquireActiveListPtr[i] = issuedData[i].activeListPtr;\n        end\n`endif\n        port.nextStage = nextStage;\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        // Debug Register\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            debug.memIsReg[i].valid = valid[i];\n            debug.memIsReg[i].flush = flush[i];\n            debug.memIsReg[i].opId = issuedData[i].opId;\n        end\n`endif\n    end\n\n\nendmodule : MemoryIssueStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- MemoryIssueStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface MemoryIssueStageIF( input logic clk, rst );\n    \n    // Pipeline register\n    MemoryRegisterReadStageRegPath nextStage [ MEM_ISSUE_WIDTH ];\n    \n    \n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\n\nendinterface : MemoryIssueStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n`include \"BasicMacros.sv\"\n\n//\n// MemoryLatencySimulator\n//\n\nimport BasicTypes::*;\nimport MemoryTypes::*;\n\nmodule MemoryLatencySimulator( \ninput \n    logic clk,\n    logic rst,\n    logic push,\n    MemoryLatencySimRequestPath pushedData,\noutput\n    logic hasRequest,\n    MemoryLatencySimRequestPath requestData\n);\n\n    typedef logic [$clog2(MEM_LATENCY_SIM_QUEUE_SIZE)-1:0] IndexPath;\n    logic pop;\n    logic full, empty;\n\n    IndexPath headPtr;\n    IndexPath tailPtr;\n    LatencyCountPath count, countReg;\n    MemoryRandPath randReg, randNext;\n    integer RANDOM_VALUE;\n\n    // size, initial head, initial tail, initial count\n    QueuePointer #( MEM_LATENCY_SIM_QUEUE_SIZE, 0, 0, 0 )\n        pointer(\n            .clk( clk ),\n            .rst( rst ),\n            .push( push ),\n            .pop( pop ),\n            .full( full ),\n            .empty( empty ),\n            .headPtr( headPtr ),\n            .tailPtr( tailPtr )\n        );\n        \n    MemoryLatencySimRequestPath memoryRequestQueue[ MEM_LATENCY_SIM_QUEUE_SIZE ];\n\n    always_ff @(posedge clk) begin\n        if (push) begin\n            memoryRequestQueue[ tailPtr ] <= pushedData;\n        end\n\n        if (rst) begin\n            countReg <= '0;\n            randReg <= MEM_LATENCY_SIM_RAND_SEED;\n        end\n        else begin\n            countReg <= count;\n            randReg <= randNext;\n        end\n    end\n\n    always_comb begin\n        randNext = randReg;\n        count = countReg;\n\n        if (!empty) begin\n            // There is some request in the queue\n            if (count == (randReg % MEM_LATENCY_SIM_LATENCY_FLUCTUATION_RANGE)) begin\n                // Issue memory request\n                pop = TRUE;\n                count = '0;\n                randNext = randNext ^ (randNext << 13); \n                randNext = randNext ^ (randNext >> 17);\n                randNext = randNext ^ (randNext << 5);\n\n                // for debug\n                //$display(\"Latency set to %d\", randNext % MEM_LATENCY_SIM_LATENCY_FLUCTUATION_RANGE);\n            end\n            else begin\n                // Wait until the determined latency has passed\n                pop = FALSE;\n                count++;\n            end\n        end\n        else begin\n            // There is no request in the queue\n            pop = FALSE;\n        end\n\n        hasRequest = pop;\n        requestData = memoryRequestQueue[ headPtr ];\n    end\n\n    `RSD_ASSERT_CLK(clk, !full, \"Cannot response so many memory request.\");\n\n`ifdef RSD_SYNTHESIS\n    `RSD_STATIC_ASSERT(FALSE, \"This module must not be used in synthesis.\");\n`endif\n\nendmodule : MemoryLatencySimulator\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n// \n// --- Types related to a memory map\n//\n\npackage MemoryMapTypes;\n\nimport BasicTypes::*;\n\n\n//\n// Related to instructions \n//\nlocalparam INSN_RESET_VECTOR = 32'h00001000;\n\n// The processor stops when it reaches PC_GOAL\nlocalparam PC_GOAL = 32'h80001004;\n\n//\n// PC\n//\n\n // This option compresses PC to 19 bits for reducing resource consumption.\n`define RSD_NARROW_PC\n// The PC compression is achieved by leveraging the memory map.\n// The memory map in the logical address space is as follows.\n//       0x0000_1000 --0x0000_FFFF: Section 0 (ROM)\n//       0x8000_0000 --0x8003_FFFF: Section 1 (RAM)\n//       0x8004_0000 --0x8004_FFFF: Section 2 (Uncachable RAM)\n//       0x4000_0000 --0x4000_000F: Timer IO\n//       0x4000_2000: Serial IO\n// In this map, instruction access is not performed in the IO area, so\n// the range of valid instructions is only in the ROM and RAM areas.\n// Within this range, only the most significant 1 bit and the lowest 18 bits are used:\n//       ROM area: Most significant bit is 0, lower 16 bits are used\n//       RAM area: Most significant bit is 1, low 18 bits\n// Therefore, it is possible to compress the PC by discarding unused bits and to close the gap.\n//       Example 1) ROM area: 0x0000_2000-> 0x0_2000\n//       Example 2) RAM area: 0x8000_2000-> 0x4_2000 (extract the most significant 1 bit and the lowest 18 bits)\n// Note that when handling exceptions, it is necessary to handle with a 32-bit address.\n\n`ifdef RSD_NARROW_PC\nlocalparam PC_WIDTH = 19;\n`else\nlocalparam PC_WIDTH = ADDR_WIDTH;\n`endif\n\nlocalparam PC_TAG = ADDR_WIDTH - PC_WIDTH;\ntypedef logic [PC_WIDTH-1:0] PC_Path;\n\n// \u5727\u7e2e\u3055\u308c\u305fPC\u309232\u30d3\u30c3\u30c8\u30a2\u30c9\u30ec\u30b9\u306b\u5909\u63db\u3059\u308b\nfunction automatic AddrPath ToAddrFromPC ( PC_Path pc );\n`ifdef RSD_NARROW_PC\n    return { pc[PC_WIDTH-1], { PC_TAG{1'b0} }, pc[PC_WIDTH-2:0] };\n`else\n    return pc;\n`endif\nendfunction\n\n// 32\u30d3\u30c3\u30c8\u30a2\u30c9\u30ec\u30b9\u3092\u5727\u7e2e\u3059\u308b\nfunction automatic PC_Path ToPC_FromAddr ( AddrPath addr );\n`ifdef RSD_NARROW_PC\n    return { addr[ADDR_WIDTH-1], addr [PC_WIDTH-2:0] };\n`else\n    return addr;\n`endif\nendfunction\n\n\n//\n// Logical address memory type\n//\ntypedef enum logic[1:0]  {\n    MMT_MEMORY  = 2'b00,\n    MMT_IO      = 2'b01,\n    MMT_ILLEGAL = 2'b10\n} MemoryMapType;\n\n//\n// Physical Address\n// The most significant two bits of the physical memory address is used distinguish between \n// accesses to a normal memory region, memory-mapped IO region, and uncachable region.\nlocalparam PHY_ADDR_WIDTH = 22;  // 22 bits: 1bit uncachable flag + 1bit IO flag + 1MB memory space\nlocalparam PHY_ADDR_WIDTH_BIT_SIZE = $clog2(PHY_ADDR_WIDTH);\nlocalparam PHY_ADDR_BYTE_WIDTH = PHY_ADDR_WIDTH / BYTE_WIDTH;\n\nlocalparam PHY_RAW_ADDR_WIDTH = PHY_ADDR_WIDTH - 2;  // 20 + isIO (1 bit) + isUncachable (1 bit)\nlocalparam PHY_RAW_ADDR_WIDTH_BIT_SIZE = $clog2(PHY_RAW_ADDR_WIDTH);\nlocalparam PHY_RAW_ADDR_BYTE_WIDTH = PHY_RAW_ADDR_WIDTH / BYTE_WIDTH;\n\ntypedef logic [PHY_RAW_ADDR_WIDTH-1:0] PhyRawAddrPath;\ntypedef struct packed {\n    logic isUncachable; // True if address points to an uncachable address space.\n    logic isIO; // True if address points to a memory-mapped IO.\n    PhyRawAddrPath addr;\n} PhyAddrPath;\n\n\n//\n// Memory map between logical and physical address spaces\n// \n\n\n//\n// Section 0 (ROM?)\n// logical [0x0000_1000 - 0x0000_ffff] -> physical [0x0_1000 - 0x0_ffff]\n//\nlocalparam LOG_ADDR_SECTION_0_BEGIN = ADDR_WIDTH'('h0000_1000);\nlocalparam LOG_ADDR_SECTION_0_END   = ADDR_WIDTH'('h0001_0000);\nlocalparam LOG_ADDR_SECTION_0_ADDR_BIT_WIDTH = 16;\n\n// Ignore 0x1000 so that the lower address bits can be added as it is\nlocalparam PHY_ADDR_SECTION_0_BASE = PHY_RAW_ADDR_WIDTH'('h0_0000);\n\n\n//\n// Section 1 (RAM?)\n// logical [0x8000_0000 - 0x8003_ffff] -> physical [0x1_0000 - 0x4_ffff]\n//\nlocalparam LOG_ADDR_SECTION_1_BEGIN = ADDR_WIDTH'('h8000_0000);\nlocalparam LOG_ADDR_SECTION_1_END   = ADDR_WIDTH'('h8004_0000);\nlocalparam LOG_ADDR_SECTION_1_ADDR_BIT_WIDTH = 18;\nlocalparam PHY_ADDR_SECTION_1_BASE = PHY_RAW_ADDR_WIDTH'('h1_0000);\n\n//\n// Uncachable section (RAM?)\n// logical [0x8004_0000 - 0x8004_ffff] -> uncachable [0x5_0000 -> 0x5_ffff]\n//\nlocalparam LOG_ADDR_UNCACHABLE_BEGIN = ADDR_WIDTH'('h8004_0000);\nlocalparam LOG_ADDR_UNCACHABLE_END   = ADDR_WIDTH'('h8005_0000);\nlocalparam LOG_ADDR_UNCACHABLE_ADDR_BIT_WIDTH = 19;\n\n// Ignore 0x1000 so that the lower address bits can be added as it is\nlocalparam PHY_ADDR_UNCACHABLE_BASE = PHY_RAW_ADDR_WIDTH'('h1_0000);\n\n//\n// --- Serial IO\n// logical [0x4000_2000] -> io [0x2000]\n//\nlocalparam LOG_ADDR_SERIAL_OUTPUT = ADDR_WIDTH'('h4000_2000);\nlocalparam PHY_ADDR_SERIAL_OUTPUT = PHY_RAW_ADDR_WIDTH'('h0_2000);\n\n\n//\n// --- Timer IO\n//\n\n// Logical addresses for Timer IO \n// 0x4000_0000 - 0x4000_000F\nlocalparam LOG_ADDR_TIMER_BASE    = ADDR_WIDTH'('h4000_0000);\nlocalparam LOG_ADDR_TIMER_LOW     = LOG_ADDR_TIMER_BASE + 0;\nlocalparam LOG_ADDR_TIMER_HI      = LOG_ADDR_TIMER_BASE + 4;\nlocalparam LOG_ADDR_TIMER_CMP_LOW = LOG_ADDR_TIMER_BASE + 8;\nlocalparam LOG_ADDR_TIMER_CMP_HI  = LOG_ADDR_TIMER_BASE + 12;\n\nlocalparam LOG_ADDR_TIMER_BEGIN = LOG_ADDR_TIMER_BASE;\nlocalparam LOG_ADDR_TIMER_END   = LOG_ADDR_TIMER_BASE + 16;\n\n// Physical addresses for Timer IO \n// 0x0_0000 - 0x0_000F\nlocalparam PHY_ADDR_TIMER_BASE    = PHY_RAW_ADDR_WIDTH'('h0_0000);\nlocalparam PHY_ADDR_TIMER_LOW     = PHY_ADDR_TIMER_BASE + 0;\nlocalparam PHY_ADDR_TIMER_HI      = PHY_ADDR_TIMER_BASE + 4;\nlocalparam PHY_ADDR_TIMER_CMP_LOW = PHY_ADDR_TIMER_BASE + 8;\nlocalparam PHY_ADDR_TIMER_CMP_HI  = PHY_ADDR_TIMER_BASE + 12;\n\nlocalparam PHY_ADDR_TIMER_ZONE_BIT_WIDTH = 4;\n\n\n// Get a memory type from a logical address\nfunction automatic MemoryMapType GetMemoryMapType(AddrPath addr);\n    if (addr == LOG_ADDR_SERIAL_OUTPUT) begin\n        return MMT_IO;\n    end\n    else if (LOG_ADDR_TIMER_BEGIN <= addr && addr < LOG_ADDR_TIMER_END) begin\n        return MMT_IO;\n    end\n    else if (LOG_ADDR_UNCACHABLE_BEGIN <= addr && addr < LOG_ADDR_UNCACHABLE_END) begin\n        return MMT_MEMORY;\n    end\n    else if (LOG_ADDR_SECTION_0_BEGIN <= addr && addr < LOG_ADDR_SECTION_0_END) begin\n        return MMT_MEMORY;\n    end\n    else if (LOG_ADDR_SECTION_1_BEGIN <= addr && addr < LOG_ADDR_SECTION_1_END) begin\n        return MMT_MEMORY;\n    end\n    else begin\n        return MMT_ILLEGAL;\n    end\nendfunction\n\n// Convert a logical address to a physical address\nfunction automatic PhyAddrPath ToPhyAddrFromLogical(AddrPath logAddr);\n    PhyAddrPath phyAddr;\n\n    if (logAddr == LOG_ADDR_SERIAL_OUTPUT) begin\n        phyAddr.isUncachable = TRUE;\n        phyAddr.isIO = TRUE;\n        phyAddr.addr = PHY_ADDR_SERIAL_OUTPUT;\n    end\n    else if (LOG_ADDR_TIMER_BEGIN <= logAddr && logAddr < LOG_ADDR_TIMER_END) begin\n        phyAddr.isUncachable = TRUE;\n        phyAddr.isIO = TRUE;\n        phyAddr.addr = PHY_ADDR_TIMER_BASE + \n            logAddr[PHY_ADDR_TIMER_ZONE_BIT_WIDTH-1:0];\n    end\n    else if (LOG_ADDR_UNCACHABLE_BEGIN <= logAddr && logAddr < LOG_ADDR_UNCACHABLE_END) begin\n        // Uncachable region (RAM?)\n        phyAddr.isUncachable = TRUE;\n        phyAddr.isIO = FALSE;\n        phyAddr.addr = PHY_ADDR_UNCACHABLE_BASE + \n            logAddr[LOG_ADDR_UNCACHABLE_ADDR_BIT_WIDTH-1:0];\n    end\n    \n    else if (LOG_ADDR_SECTION_0_BEGIN <= logAddr && logAddr < LOG_ADDR_SECTION_0_END) begin\n        // Section 0 (ROM?)\n        phyAddr.isUncachable = FALSE;\n        phyAddr.isIO = FALSE;\n        phyAddr.addr = PHY_ADDR_SECTION_0_BASE + \n            logAddr[LOG_ADDR_SECTION_0_ADDR_BIT_WIDTH:0];\n    end\n    else if (LOG_ADDR_SECTION_1_BEGIN <= logAddr && logAddr < LOG_ADDR_SECTION_1_END) begin\n        // Section 1 (RAM?)\n        phyAddr.isUncachable = FALSE;\n        phyAddr.isIO = FALSE;\n        phyAddr.addr = PHY_ADDR_SECTION_1_BASE + \n            logAddr[LOG_ADDR_SECTION_1_ADDR_BIT_WIDTH-1:0];\n    end\n    else begin\n        // Invalid\n        phyAddr.isUncachable = FALSE;\n        phyAddr.isIO = FALSE;\n        phyAddr.addr = 32'hCCCC_CCCC;\n    end\n\n    return phyAddr;\nendfunction\n\nfunction automatic logic IsPhyAddrIO(PhyAddrPath phyAddr);\n    return phyAddr.isIO;\nendfunction\n\nfunction automatic logic IsPhyAddrUncachable(PhyAddrPath phyAddr);\n    return phyAddr.isUncachable;\nendfunction\n\nendpackage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// MemoryReadReqQueue\n//\n\n`include \"SysDeps/XilinxMacros.vh\"\n\nimport BasicTypes::*;\nimport MemoryTypes::*;\n\nmodule MemoryReadReqQueue ( \ninput \n    logic clk,\n    logic rst,\n    logic push,\n    logic pop,\n    MemoryReadReq pushedData,\noutput\n    logic full,\n    logic empty,\n    MemoryReadReq headData\n);\n\n    typedef logic [`MEMORY_AXI4_READ_ID_WIDTH-1: 0] IndexPath;\n\n    IndexPath headPtr;\n    IndexPath tailPtr;\n\n    // size, initial head, initial tail, initial count\n    QueuePointer #( `MEMORY_AXI4_READ_ID_NUM, 0, 0, 0 )\n        pointer(\n            .clk( clk ),\n            .rst( rst ),\n            .push( push ),\n            .pop( pop ),\n            .full( full ),\n            .empty( empty ),\n            .headPtr( headPtr ),\n            .tailPtr( tailPtr )\n        );\n        \n\n    logic [ `MEMORY_AXI4_READ_ID_WIDTH+`MEMORY_AXI4_ADDR_BIT_SIZE-1:0 ] memoryReadReqQueue[ `MEMORY_AXI4_READ_ID_NUM ]; // synthesis syn_ramstyle = \"select_ram\"\n\n    always_ff @( posedge clk ) begin\n        if( push ) begin\n            memoryReadReqQueue[ tailPtr ] <= pushedData;\n        end\n    end\n    \n    always_comb begin\n        headData = memoryReadReqQueue[ headPtr ];\n    end\n\nendmodule : MemoryReadReqQueue\n\n "}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for register read.\n//\n\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport CacheSystemTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\n\n//\n// --- \u30aa\u30da\u30e9\u30f3\u30c9\u306e\u9078\u629e\n//\nfunction automatic DataPath SelectOperand(\ninput\n    OpOperandType opType, DataPath regV, DataPath immV, DataPath pcV\n);\n    case( opType )\n    default:    // OOT_REG\n        return regV;\n    OOT_IMM:\n        return immV;\n    OOT_PC:\n        return pcV;\n    endcase\nendfunction\n\n//\n// --- Memory Register Read Stage\n//\nmodule MemoryRegisterReadStage(\n    MemoryRegisterReadStageIF.ThisStage port,\n    MemoryIssueStageIF.NextStage prev,\n    RegisterFileIF.MemoryRegisterReadStage registerFile,\n    BypassNetworkIF.MemoryRegisterReadStage bypass,\n    RecoveryManagerIF.MemoryRegisterReadStage recovery,\n    ControllerIF.MemoryRegisterReadStage ctrl,\n    DebugIF.MemoryRegisterReadStage debug\n);\n\n    // --- Pipeline registers\n    MemoryRegisterReadStageRegPath pipeReg [MEM_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n\n    always_ff@( posedge port.clk )   // synchronous rst\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= '0;\n            end\n        end\n        else if (!ctrl.backEnd.stall) begin             // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n\n    // Operand\n    DataPath immOut [ MEM_ISSUE_WIDTH ];\n    AddrPath pc [ MEM_ISSUE_WIDTH ];\n    PRegDataPath operandA [ MEM_ISSUE_WIDTH ];\n    PRegDataPath operandB [ MEM_ISSUE_WIDTH ];\n\n    // Pipeline controll\n    logic stall, clear;\n    logic flush[ MEM_ISSUE_WIDTH ];\n    MemIssueQueueEntry iqData[MEM_ISSUE_WIDTH];\n    MemOpInfo memOpInfo[MEM_ISSUE_WIDTH];\n    OpSrc opSrc[MEM_ISSUE_WIDTH];\n    OpDst opDst[MEM_ISSUE_WIDTH];\n    MemoryExecutionStageRegPath nextStage [MEM_ISSUE_WIDTH];\n    MSHR_IndexPath mshrID;\n\n    always_comb begin\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n            iqData[i] = pipeReg[i].memQueueData;\n            memOpInfo[i] = iqData[i].memOpInfo;\n            opSrc[i] = iqData[i].opSrc;\n            opDst[i] = iqData[i].opDst;\n            pc[i] = iqData[i].pc;\n\n            //\n            // Register file\n            //\n\n            registerFile.memSrcRegNumA[i] = opSrc[i].phySrcRegNumA;\n            registerFile.memSrcRegNumB[i] = opSrc[i].phySrcRegNumB;\n\n\n            //\n            // To a bypass network.\n            // \u30b9\u30c8\u30fc\u30eb\u3084\u30d5\u30e9\u30c3\u30b7\u30e5\u306e\u5236\u5fa1\u306f\uff0cBypass \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u5185\u90e8\u3067\n            // \u30b3\u30f3\u30c8\u30ed\u30fc\u30e9\u306e\u4fe1\u53f7\u3092\u53c2\u7167\u3057\u3066\u884c\u308f\u308c\u3066\u3044\u308b\n            //\n            bypass.memPhySrcRegNumA[i] = opSrc[i].phySrcRegNumA;\n            bypass.memPhySrcRegNumB[i] = opSrc[i].phySrcRegNumB;\n\n            bypass.memWriteReg[i]  = opDst[i].writeReg & pipeReg[i].valid;\n            bypass.memPhyDstRegNum[i] = opDst[i].phyDstRegNum;\n            bypass.memReadRegA[i] = ( memOpInfo[i].operandTypeA == OOT_REG );\n            bypass.memReadRegB[i] = ( memOpInfo[i].operandTypeB == OOT_REG );\n\n            //\n            // --- \u30aa\u30da\u30e9\u30f3\u30c9\u9078\u629e\n            //\n            immOut[i] = '0; //RISCV\u306b\u304a\u3044\u3066\u5373\u5024\u3092\u30aa\u30da\u30e9\u30f3\u30c9\u306b\u3068\u308b\u3088\u3046\u306a\u30ed\u30fc\u30c9/\u30b9\u30c8\u30a2\u306f\u306a\u3044(\u30a2\u30c9\u30ec\u30b9\u8a08\u7b97\u306fExecutionStage)\n            operandA[i].data = SelectOperand(\n                memOpInfo[i].operandTypeA,\n                registerFile.memSrcRegDataA[i].data,\n                immOut[i],\n                pc[i]\n            );\n            operandB[i].data = SelectOperand(\n                memOpInfo[i].operandTypeB,\n                registerFile.memSrcRegDataB[i].data,\n                immOut[i],\n                pc[i]\n            );\n            operandA[i].valid = (memOpInfo[i].operandTypeA != OOT_REG || registerFile.memSrcRegDataA[i].valid);\n            operandB[i].valid = (memOpInfo[i].operandTypeB != OOT_REG || registerFile.memSrcRegDataB[i].valid);\n\n            //\n            // --- Pipeline \u30e9\u30c3\u30c1\u66f8\u304d\u8fbc\u307f\n            //\n            `ifndef RSD_DISABLE_DEBUG_REGISTER\n                nextStage[i].opId = pipeReg[i].opId;\n            `endif\n\n\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            flush[i] = SelectiveFlushDetector(\n                recovery.toRecoveryPhase,\n                recovery.flushRangeHeadPtr,\n                recovery.flushRangeTailPtr,\n                recovery.flushAllInsns,\n                iqData[i].activeListPtr\n            );\n            nextStage[i].valid =\n                (stall || clear || port.rst || flush[i]) ? FALSE : pipeReg[i].valid;\n\n            nextStage[i].memQueueData = pipeReg[i].memQueueData;\n\n            // \u30ec\u30b8\u30b9\u30bf\u5024&\u30d5\u30e9\u30b0\n            nextStage[i].operandA = operandA[i];\n            nextStage[i].operandB = operandB[i];\n\n            // \u30d0\u30a4\u30d1\u30b9\u5236\u5fa1\n            nextStage[i].bCtrl = bypass.memCtrlOut[i];\n\n            // Release the entries of the issue queue.\n            nextStage[i].replay = pipeReg[i].replay && pipeReg[i].valid;\n            nextStage[i].issueQueuePtr = pipeReg[i].issueQueuePtr;\n        end\n\n        port.nextStage = nextStage;\n\n        // Debug Register\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n            debug.memRrReg[i].valid = pipeReg[i].valid;\n            debug.memRrReg[i].flush = flush[i];\n            debug.memRrReg[i].opId = pipeReg[i].opId;\n        end\n`endif\n    end\nendmodule : MemoryRegisterReadStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- FetchPipeIF\n//\n\nimport BasicTypes::*;\nimport BypassTypes::*;\nimport PipelineTypes::*;\n\n\ninterface MemoryRegisterReadStageIF( input logic clk, rst );\n    \n    // Pipeline register\n    MemoryExecutionStageRegPath nextStage [ MEM_ISSUE_WIDTH ];\n    \n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        nextStage\n    );\n\nendinterface : MemoryRegisterReadStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Memory Write back stage\n//\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport RenameLogicTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\nimport CacheSystemTypes::*;\n\n\n\nmodule MemoryRegisterWriteStage(\n    //MemoryRegisterWriteStageIF.ThisStage port,\n    MemoryAccessStageIF.NextStage prev,\n    LoadStoreUnitIF.MemoryRegisterWriteStage loadStoreUnit,\n    RegisterFileIF.MemoryRegisterWriteStage registerFile,\n    ActiveListIF.MemoryRegisterWriteStage activeList,\n    RecoveryManagerIF.MemoryRegisterWriteStage recovery,\n    ControllerIF.MemoryRegisterWriteStage ctrl,\n    DebugIF.MemoryRegisterWriteStage debug\n);\n    MemoryRegisterWriteStageRegPath pipeReg[MEM_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n\n    // --- Pipeline registers\n    always_ff@( posedge /*port.clk*/ ctrl.clk )   // synchronous rst\n    begin\n        if (ctrl.rst) begin\n            for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= '0;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin    // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n\n    logic stall, clear;\n    logic flush[ MEM_ISSUE_WIDTH ];\n    logic update [ MEM_ISSUE_WIDTH ];\n    logic valid [ MEM_ISSUE_WIDTH ];\n    ActiveListWriteData alWriteData[MEM_ISSUE_WIDTH];\n\n    ExecutionState execState[MEM_ISSUE_WIDTH];\n    MSHR_IndexPath mshrID;\n    logic makeMSHRCanBeInvalid[MSHR_NUM];\n\n    always_comb begin\n\n        // Pipeline controll\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n        // \u4ee5\u4e0b\u306e\u3044\u305a\u308c\u304b\u306e\u5834\u5408\uff0c\u63e1\u3063\u3066\u3044\u308b MSHR \u3092\u89e3\u653e\u3059\u308b\n        // 1. MSHR \u3092\u78ba\u4fdd\u3057\u305f\u547d\u4ee4\u304c\u30e9\u30a4\u30c8\u30d0\u30c3\u30af\u307e\u3067\u9054\u3057\u305f\u5834\u5408\n        // 2. MSHR \u3092\u78ba\u4fdd\u3057\u305f\u547d\u4ee4\u304c\u5f8c\u304b\u3089 SQ \u304b\u3089\u306e\u30d5\u30a9\u30ef\u30fc\u30c9\u30df\u30b9\u304c\u767a\u751f\u3057\u305f\u5834\u5408\n        //      \u30d5\u30a9\u30ef\u30fc\u30c9\u5143\u306e\u30b9\u30c8\u30a2\u304c\u30df\u30b9\u3057\u3066\u3044\u305f\u5834\u5408\uff0cMSHR \u3092\u3066\u3070\u306a\u3055\u3044\u3068\u30c7\u30c3\u30c9\u30ed\u30c3\u30af\u3059\u308b\n        for (int j = 0; j < MSHR_NUM; j++) begin\n            loadStoreUnit.makeMSHRCanBeInvalidDirect[j] = FALSE;\n            for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n                if (j == pipeReg[i].mshrID && \n                    ((pipeReg[i].dataOut.valid && pipeReg[i].hasAllocatedMSHR) || pipeReg[i].storeForwardMiss) &&\n                    pipeReg[i].valid && \n                    pipeReg[i].isLoad\n                ) begin\n                    loadStoreUnit.makeMSHRCanBeInvalidDirect[j] = TRUE;\n                end\n            end\n        end\n\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            valid[i] = pipeReg[i].valid;\n            flush[i] = SelectiveFlushDetector(\n                recovery.toRecoveryPhase,\n                recovery.flushRangeHeadPtr,\n                recovery.flushRangeTailPtr,\n                recovery.flushAllInsns,\n                pipeReg[i].activeListPtr\n            );\n            update[i] = !stall && !clear && valid[i] && !flush[i];\n\n            //\n            // Active list\n            //\n            alWriteData[i].ptr = pipeReg[i].activeListPtr;\n            alWriteData[i].loadQueuePtr = pipeReg[i].loadQueueRecoveryPtr;\n            alWriteData[i].storeQueuePtr = pipeReg[i].storeQueueRecoveryPtr;\n\n            alWriteData[i].isBranch = FALSE;\n            alWriteData[i].isStore = pipeReg[i].isStore;\n\n            // ExecState\n            if ( update[i] ) begin\n                alWriteData[i].state = pipeReg[i].execState;\n            end\n            else begin\n                alWriteData[i].state = EXEC_STATE_NOT_FINISHED;\n            end\n            execState[i] = alWriteData[i].state;\n\n            alWriteData[i].pc = pipeReg[i].pc;\n            alWriteData[i].dataAddr = pipeReg[i].addrOut;\n\n            activeList.memWrite[i] = update[i];\n            activeList.memWriteData[i] = alWriteData[i];\n        end\n\n\n        //\n        // Register file\n        //\n        for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin\n\n            registerFile.memDstRegWE[i] =\n                update[i] && pipeReg[i].opDst.writeReg;\n\n            registerFile.memDstRegNum[i] = pipeReg[i].opDst.phyDstRegNum;\n            registerFile.memDstRegData[i] = pipeReg[i].dataOut;\n        end\n\n\n        // Debug Register\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            debug.memRwReg[i].valid = valid[i];\n            debug.memRwReg[i].flush = flush[i];\n            debug.memRwReg[i].opId = pipeReg[i].opId;\n        end\n`endif\n    end\nendmodule : MemoryRegisterWriteStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- MemoryRegisterWriteStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface MemoryRegisterWriteStageIF( input logic clk, rst );\n\n    modport ThisStage(\n    input\n        clk,\n        rst\n    );\n\nendinterface : MemoryRegisterWriteStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Tag access stage\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport RenameLogicTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\nimport MicroOpTypes::*;\nimport CacheSystemTypes::*;\nimport MemoryMapTypes::*;\n\n// When this switch is enabled, instructions are re-issued from the issue queue.\n// Otherwise, instructions are refetched.\n`define RSD_ENABLE_REISSUE_ON_CACHE_MISS\n\nmodule MemoryTagAccessStage(\n    MemoryTagAccessStageIF.ThisStage port,\n    MemoryExecutionStageIF.NextStage prev,\n    SchedulerIF.MemoryTagAccessStage scheduler,\n    LoadStoreUnitIF.MemoryTagAccessStage loadStoreUnit,\n    MulDivUnitIF.MemoryTagAccessStage mulDivUnit,    \n    RecoveryManagerIF.MemoryTagAccessStage recovery,\n    ControllerIF.MemoryTagAccessStage ctrl,\n    DebugIF.MemoryTagAccessStage debug,\n    PerformanceCounterIF.MemoryTagAccessStage perfCounter\n);\n\n    MemoryTagAccessStageRegPath pipeReg[MEM_ISSUE_WIDTH];\n    MemoryTagAccessStageRegPath ldPipeReg[LOAD_ISSUE_WIDTH];\n    MemoryTagAccessStageRegPath stPipeReg[STORE_ISSUE_WIDTH];\n\n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n\n    // --- Pipeline registers\n    always_ff@( posedge port.clk )   // synchronous rst\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n                pipeReg[i].valid <= '0;\n            end\n        end\n        else if(!ctrl.backEnd.stall) begin              // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n    // Pipeline control\n    logic stall, clear;\n\n    MemIssueQueueEntry ldIqData[LOAD_ISSUE_WIDTH];\n    MemIssueQueueEntry stIqData[STORE_ISSUE_WIDTH];\n\n    always_comb begin\n        // Pipeline control\n        stall = ctrl.backEnd.stall;\n        clear = ctrl.backEnd.clear;\n\n\n        for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n            ldPipeReg[i] = pipeReg[i];\n            ldIqData[i] = pipeReg[i].memQueueData;\n        end\n        for (int i = 0; i < STORE_ISSUE_WIDTH; i++) begin\n            stPipeReg[i] = pipeReg[i + STORE_ISSUE_LANE_BEGIN];\n            stIqData[i] = pipeReg[i + STORE_ISSUE_LANE_BEGIN].memQueueData;\n        end\n\n    end\n\n    // Load pipe\n    logic isLoad    [LOAD_ISSUE_WIDTH];\n    logic isCSR     [LOAD_ISSUE_WIDTH];\n    logic isENV     [LOAD_ISSUE_WIDTH];\n    logic ldUpdate  [LOAD_ISSUE_WIDTH];\n    logic ldRegValid[LOAD_ISSUE_WIDTH];\n    logic ldFlush   [LOAD_ISSUE_WIDTH];\n    logic isDiv     [LOAD_ISSUE_WIDTH];\n    logic isMul     [LOAD_ISSUE_WIDTH];\n    logic isFenceI  [LOAD_ISSUE_WIDTH];\n    logic storeForwardMiss[LOAD_ISSUE_WIDTH];\n    MemoryAccessStageRegPath ldNextStage[LOAD_ISSUE_WIDTH];\n    MemIssueQueueEntry ldRecordData[LOAD_ISSUE_WIDTH];  // for ReplayQueue\n\n    logic ldMSHR_Allocated[LOAD_ISSUE_WIDTH];\n    logic ldMSHR_Hit[LOAD_ISSUE_WIDTH];\n    DataPath ldMSHR_EntryID[LOAD_ISSUE_WIDTH];\n\n    always_comb begin\n        for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin\n\n            ldFlush[i] = SelectiveFlushDetector(\n                            recovery.toRecoveryPhase,\n                            recovery.flushRangeHeadPtr,\n                            recovery.flushRangeTailPtr,\n                            recovery.flushAllInsns,\n                            ldIqData[i].activeListPtr\n                        );\n            ldUpdate[i]  = ldPipeReg[i].valid && !stall && !clear && !ldFlush[i];\n            isLoad[i] = ( ldIqData[i].memOpInfo.opType == MEM_MOP_TYPE_LOAD );\n            isCSR[i] = ( ldIqData[i].memOpInfo.opType == MEM_MOP_TYPE_CSR );\n            isENV[i] = ( ldIqData[i].memOpInfo.opType == MEM_MOP_TYPE_ENV );\n            isDiv[i] = ( ldIqData[i].memOpInfo.opType == MEM_MOP_TYPE_DIV );\n            isMul[i] = ( ldIqData[i].memOpInfo.opType == MEM_MOP_TYPE_MUL );\n            isFenceI[i] = ( ldIqData[i].memOpInfo.opType == MEM_MOP_TYPE_FENCE ) && ldIqData[i].memOpInfo.isFenceI;\n\n            // Load store unit\n            loadStoreUnit.executeLoad[i] = ldUpdate[i] && isLoad[i];\n            loadStoreUnit.executedLoadAddr[i] = ldPipeReg[i].phyAddrOut;\n            loadStoreUnit.executedLoadMemMapType[i] = ldPipeReg[i].memMapType;\n            loadStoreUnit.executedLoadPC[i] = ldIqData[i].pc;\n            loadStoreUnit.executedLoadMemAccessMode[i] = ldIqData[i].memOpInfo.memAccessMode;\n            loadStoreUnit.executedStoreQueuePtrByLoad[i] = ldIqData[i].storeQueuePtr;\n            loadStoreUnit.executedLoadQueuePtrByLoad[i] = ldIqData[i].loadQueuePtr;\n\n            // Set hasAllocatedMSHR and mshrID info to notice ReplayQueue\n            // whether missed loads have allocated MSHRs or not.\n`ifndef RSD_DISABLE_DEBUG_REGISTER // Debug info\n            ldRecordData[i].opId = ldIqData[i].opId;\n`endif\n            ldRecordData[i].activeListPtr = ldIqData[i].activeListPtr;\n            ldRecordData[i].opSrc         = ldIqData[i].opSrc;\n            ldRecordData[i].opDst         = ldIqData[i].opDst;\n            ldRecordData[i].pc            = ldIqData[i].pc;\n            ldRecordData[i].memOpInfo     = ldIqData[i].memOpInfo;\n            ldRecordData[i].storeQueueRecoveryPtr = ldIqData[i].storeQueueRecoveryPtr;\n            ldRecordData[i].loadQueueRecoveryPtr  = ldIqData[i].loadQueueRecoveryPtr;\n            ldRecordData[i].loadQueuePtr  = ldIqData[i].loadQueuePtr;\n            ldRecordData[i].storeQueuePtr  = ldIqData[i].storeQueuePtr;\n\n            // For performance counters\n            ldMSHR_Allocated[i] = FALSE;\n            ldMSHR_Hit[i] = FALSE;\n            ldMSHR_EntryID[i] = 0;\n\n            storeForwardMiss[i] = FALSE;\n\n            // Set MSHR id if the load instruction allocated a MSHR entry.\n            if (ldIqData[i].hasAllocatedMSHR) begin\n                ldRecordData[i].hasAllocatedMSHR = ldIqData[i].hasAllocatedMSHR;\n                ldRecordData[i].mshrID = ldIqData[i].mshrID;\n\n                // \u524d\u56de\u5b9f\u884c\u6642\u306b MSHR \u3092\u78ba\u4fdd\u3057\u305f\u304c\u30ea\u30d7\u30ec\u30a4\u6642\u306b SQ \u304b\u3089\u306e\u30d5\u30a9\u30ef\u30fc\u30c9\u30df\u30b9\u304c\u767a\u751f\u3057\u305f\u5834\u5408\n                // MSHR \u3092\u624b\u653e\u3055\u306a\u3044\u3068\u5148\u884c\u3059\u308b\u30b9\u30c8\u30a2\u304c\u30b3\u30df\u30c3\u30c8\u3067\u304d\u305a\u30c7\u30c3\u30c9\u30ed\u30c3\u30af\u3059\u308b\n                // storeForwardMiss \u3092\u5f8c\u6bb5\u306b\u4f1d\u3048\u3066 RW \u30b9\u30c6\u30fc\u30b8\u3067 MSHR \u3092\u89e3\u653e\u3057\uff0cMSHR \u3092\u78ba\u4fdd\u3057\u305f\u30d5\u30e9\u30b0\u3092\u3053\u3053\u3067\u843d\u3068\u3059\n                if (loadStoreUnit.storeLoadForwarded[i] && loadStoreUnit.forwardMiss[i]) begin\n                    storeForwardMiss[i] = TRUE;\n                    ldRecordData[i].hasAllocatedMSHR = FALSE;\n                end\n            end\n            else begin\n                if (i < LOAD_ISSUE_WIDTH) begin\n                    ldRecordData[i].hasAllocatedMSHR = loadStoreUnit.loadHasAllocatedMSHR[i];\n\n                    // There are two sources of MSHR ID to memorize,\n                    // 1. when a load hits a MSHR entry, the hit MSHR ID,\n                    // 2. when a load allocates a MSHR entry, the allocated MSHR ID.\n                    // 3. when otherwise (no hit and no allocate), don't ldUpdate.\n                    if (loadStoreUnit.loadHasAllocatedMSHR[i]) begin\n                        ldRecordData[i].mshrID = loadStoreUnit.loadMSHRID[i];\n                        // MSHR allocation is performed \n                        ldMSHR_Allocated[i] = TRUE;\n                        ldMSHR_EntryID[i] = loadStoreUnit.loadMSHRID[i];\n                    end\n                    else if (loadStoreUnit.mshrAddrHit[i]) begin\n                        ldRecordData[i].mshrID = loadStoreUnit.mshrAddrHitMSHRID[i];\n                        // MSHR Hit?\n                        ldMSHR_Hit[i] = loadStoreUnit.mshrReadHit[i];\n                        ldMSHR_EntryID[i] = loadStoreUnit.mshrAddrHitMSHRID[i];\n                    end\n                    else begin\n                        ldRecordData[i].mshrID = ldIqData[i].mshrID;\n                    end\n                end\n                else begin\n                    ldRecordData[i].hasAllocatedMSHR = FALSE;\n                    ldRecordData[i].mshrID = '0;\n                end\n            end\n\n           \n\n`ifdef RSD_ENABLE_REISSUE_ON_CACHE_MISS\n            if (isLoad[i]) begin\n                if (loadStoreUnit.storeLoadForwarded[i]) begin\n                    ldRegValid[i] = ldPipeReg[i].regValid;\n                end\n                else if (ldRecordData[i].hasAllocatedMSHR) begin\n                    // When the load has allocated an MSHR entry,\n                    // The data will come from MSHR.\n                    ldRegValid[i] = loadStoreUnit.mshrReadHit[i] ? ldPipeReg[i].regValid : FALSE;\n                end\n                else if (loadStoreUnit.mshrReadHit[i]) begin\n                    ldRegValid[i] = ldPipeReg[i].regValid;\n                end\n                else begin\n                    // The consumers of a missed load is invalidate.\n                    ldRegValid[i] = loadStoreUnit.dcReadHit[i] ? ldPipeReg[i].regValid : FALSE;\n                end\n            end\n            else if (ldRecordData[i].hasAllocatedMSHR) begin\n                // When the prefetch load has allocated an MSHR entry,\n                // The data will come from MSHR.\n                ldRegValid[i] = loadStoreUnit.mshrReadHit[i] ? ldPipeReg[i].regValid : FALSE;\n            end\n            else begin\n                ldRegValid[i] = ldPipeReg[i].regValid;\n            end\n`else\n            ldRegValid[i] = TRUE;\n`endif\n\n            // Sends to the load queue whether the load executed in this cycle is valid.\n            loadStoreUnit.executedLoadRegValid[i] = ldRegValid[i];\n            \n            `ifdef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n                if (isDiv[i] && ldRegValid[i]) begin\n                    /*ldPipeReg[i].replay && */\n                    ldRegValid[i] = mulDivUnit.divFinished[i];\n                end\n            `endif\n\n            // Pipeline \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\n            ldNextStage[i].regValid = ldRegValid[i];\n            ldNextStage[i].addrOut = ldPipeReg[i].addrOut;\n            ldNextStage[i].memMapType = ldPipeReg[i].memMapType;\n            ldNextStage[i].phyAddrOut = ldPipeReg[i].phyAddrOut;\n            ldNextStage[i].csrDataOut = ldPipeReg[i].dataIn;\n\n            ldNextStage[i].isLoad  = isLoad[i];\n            ldNextStage[i].isStore = FALSE;\n            ldNextStage[i].isCSR   = isCSR[i];\n            ldNextStage[i].isDiv   = isDiv[i];\n            ldNextStage[i].isMul   = isMul[i];\n\n            ldNextStage[i].opDst = ldIqData[i].opDst;\n            ldNextStage[i].activeListPtr = ldIqData[i].activeListPtr;\n            ldNextStage[i].loadQueueRecoveryPtr  = ldIqData[i].loadQueueRecoveryPtr;\n            ldNextStage[i].storeQueueRecoveryPtr = ldIqData[i].storeQueueRecoveryPtr;\n            ldNextStage[i].pc = ldIqData[i].pc;\n\n            ldNextStage[i].hasAllocatedMSHR = ldRecordData[i].hasAllocatedMSHR;\n            ldNextStage[i].mshrID = ldRecordData[i].mshrID;\n            ldNextStage[i].storeForwardMiss = storeForwardMiss[i];\n\n\n            // ExecState\n            // \u547d\u4ee4\u306e\u5b9f\u884c\u7d50\u679c\u306b\u3088\u3063\u3066\u3001\u518d\u30d5\u30a7\u30c3\u30c1\u304c\u5fc5\u8981\u304b\u3069\u3046\u304b\u306a\u3069\u3092\u5224\u5b9a\u3059\u308b\n            if (!ldUpdate[i] || (ldUpdate[i] && !ldRegValid[i])) begin\n                ldNextStage[i].execState = EXEC_STATE_NOT_FINISHED;\n            end\n            else if ( isLoad[i] ) begin\n                // \u30ed\u30fc\u30c9\u306e\u5b9f\u884c\u306b\u5931\u6557\u3057\u305f\u5834\u5408\u306f\u3001\n                // \u6b63\u3057\u3044\u5b9f\u884c\u7d50\u679c\u304c\u5f97\u3089\u308c\u3066\u3044\u306a\u3044\u306e\u3067\u3001\n                // \u305d\u306e\u30ed\u30fc\u30c9\u547d\u4ee4\u304b\u3089\u3084\u308a\u76f4\u3059\n                if ( loadStoreUnit.storeLoadForwarded[i] ) begin\n                    // \u30d5\u30a9\u30ef\u30fc\u30c9\u3055\u308c\u305f\u5834\u5408\n                    // A load instruction that caused a store-load forwarding miss is not replayed but flushed to prevent a deadlock due to replay.\n                    // To wait for the commit of the dependent store instruction, The flush is performed in commit stage.\n                    ldNextStage[i].execState =\n                        loadStoreUnit.forwardMiss[i] ? EXEC_STATE_STORE_LOAD_FORWARDING_MISS : EXEC_STATE_SUCCESS;\n                end\n                else if (ldRecordData[i].hasAllocatedMSHR) begin\n                    ldNextStage[i].execState =\n                            loadStoreUnit.mshrReadHit[i] ? EXEC_STATE_SUCCESS : EXEC_STATE_REFETCH_THIS;\n                end\n                else if (loadStoreUnit.mshrReadHit[i]) begin\n                    ldNextStage[i].execState = EXEC_STATE_SUCCESS;\n                end\n                else begin\n                    // DCache\n                    ldNextStage[i].execState =\n                        loadStoreUnit.dcReadHit[i] ? EXEC_STATE_SUCCESS : EXEC_STATE_REFETCH_THIS;\n                end\n            end\n            else if (ldRecordData[i].hasAllocatedMSHR) begin\n                ldNextStage[i].execState =\n                        loadStoreUnit.mshrReadHit[i] ? EXEC_STATE_SUCCESS : EXEC_STATE_REFETCH_THIS;\n            end\n            else if (isENV[i]) begin\n                // EBREAK/ECALL/MRET \u306f\u30c8\u30e9\u30c3\u30d7\u6271\u3044\n                unique case (ldIqData[i].memOpInfo.envCode)\n                ENV_BREAK:          ldNextStage[i].execState = EXEC_STATE_TRAP_EBREAK;\n                ENV_CALL:           ldNextStage[i].execState = EXEC_STATE_TRAP_ECALL;\n                ENV_MRET:           ldNextStage[i].execState = EXEC_STATE_TRAP_MRET;\n                ENV_INSN_ILLEGAL:   ldNextStage[i].execState = EXEC_STATE_FAULT_INSN_ILLEGAL;\n                ENV_INSN_VIOLATION: ldNextStage[i].execState = EXEC_STATE_FAULT_INSN_VIOLATION;\n                default:\n                    ldNextStage[i].execState = EXEC_STATE_TRAP_EBREAK;\n                endcase\n            end\n            else if (isFenceI[i]) begin\n                // FENCE.I flush all following ops when it is committed\n                // not to use the expired data from ICache.\n                ldNextStage[i].execState = EXEC_STATE_REFETCH_NEXT;\n            end\n`ifdef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n            else if (isDiv[i]) begin\n                ldNextStage[i].execState = mulDivUnit.divFinished[i] ? EXEC_STATE_SUCCESS : EXEC_STATE_NOT_FINISHED;\n            end\n`endif \n            else begin\n                ldNextStage[i].execState = EXEC_STATE_SUCCESS;\n            end\n\n            // \u5b9f\u884c\u304c\u6b63\u3057\u304f\u7d42\u4e86\u3057\u3066\u308b\u5834\u5408\uff0c\u30d5\u30a9\u30fc\u30eb\u30c8\u5224\u5b9a\u3092\u884c\u3046\n            // \u30b9\u30c8\u30a2\u306e\u4f9d\u5b58\u4e88\u6e2c\u3067\u306f\u3053\u3061\u3089\u306e\u65b9\u304c\u512a\u5148\u3055\u308c\u308b\n            if (ldNextStage[i].execState inside {EXEC_STATE_SUCCESS, EXEC_STATE_REFETCH_NEXT}) begin\n                if (isLoad[i]) begin\n                    if (ldPipeReg[i].memMapType == MMT_ILLEGAL)\n                        ldNextStage[i].execState = EXEC_STATE_FAULT_LOAD_VIOLATION;\n                    else if (IsMisalignedAddress(ldPipeReg[i].addrOut, ldIqData[i].memOpInfo.memAccessMode.size))\n                        ldNextStage[i].execState = EXEC_STATE_FAULT_LOAD_MISALIGNED;\n                end\n            end\n\n\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            ldNextStage[i].valid =\n                (stall || clear || port.rst || ldFlush[i]) ? FALSE : ldPipeReg[i].valid;\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            ldNextStage[i].opId = ldPipeReg[i].opId;\n`endif\n        end // for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin\n\n\n    end // always_comb\n\n\n    logic isStore   [STORE_ISSUE_WIDTH];\n    logic stUpdate  [STORE_ISSUE_WIDTH];\n    logic stRegValid[STORE_ISSUE_WIDTH];\n    logic stFlush   [STORE_ISSUE_WIDTH];\n    MemoryAccessStageRegPath stNextStage[STORE_ISSUE_WIDTH];\n    MemIssueQueueEntry stRecordData[STORE_ISSUE_WIDTH];  // for ReplayQueue\n\n    // For memory dependency prediction (only for STORE)\n    logic memAccessOrderViolation[STORE_ISSUE_WIDTH];\n\n    always_comb begin\n\n        for (int i = 0; i < STORE_ISSUE_WIDTH; i++) begin\n            memAccessOrderViolation[i] = FALSE;\n            stFlush[i] = SelectiveFlushDetector(\n                            recovery.toRecoveryPhase,\n                            recovery.flushRangeHeadPtr,\n                            recovery.flushRangeTailPtr,\n                            recovery.flushAllInsns,\n                            stIqData[i].activeListPtr\n                        );\n            stUpdate[i]  = stPipeReg[i].valid && !stall && !clear && !stFlush[i];\n            isStore[i] = (stIqData[i].memOpInfo.opType == MEM_MOP_TYPE_STORE);\n\n            // Load store unit\n            loadStoreUnit.executeStore[i] = stUpdate[i] && isStore[i];\n            loadStoreUnit.executedStoreData[i] = stPipeReg[i].dataIn;\n            loadStoreUnit.executedStoreVectorData[i] = '0;\n            loadStoreUnit.executedStoreAddr[i] = stPipeReg[i].phyAddrOut;\n            loadStoreUnit.executedStoreCondEnabled[i]   = stPipeReg[i].condEnabled;\n            loadStoreUnit.executedStoreRegValid[i] = stPipeReg[i].regValid;\n            loadStoreUnit.executedStoreMemAccessMode[i] = stIqData[i].memOpInfo.memAccessMode;\n            loadStoreUnit.executedLoadQueuePtrByStore[i] = stIqData[i].loadQueuePtr;\n            loadStoreUnit.executedStoreQueuePtrByStore[i] = stIqData[i].storeQueuePtr;\n\n            // Set hasAllocatedMSHR and mshrID info to notice ReplayQueue\n            // whether missed loads have allocated MSHRs or not.\n`ifndef RSD_DISABLE_DEBUG_REGISTER // Debug info\n            stRecordData[i].opId = stIqData[i].opId;\n`endif\n            stRecordData[i].activeListPtr = stIqData[i].activeListPtr;\n            stRecordData[i].opSrc         = stIqData[i].opSrc;\n            stRecordData[i].opDst         = stIqData[i].opDst;\n            stRecordData[i].pc = stIqData[i].pc;\n            stRecordData[i].storeQueueRecoveryPtr = stIqData[i].storeQueueRecoveryPtr;\n            stRecordData[i].loadQueueRecoveryPtr  = stIqData[i].loadQueueRecoveryPtr;\n            stRecordData[i].memOpInfo = stIqData[i].memOpInfo;\n            stRecordData[i].loadQueuePtr  = stIqData[i].loadQueuePtr;\n            stRecordData[i].storeQueuePtr  = stIqData[i].storeQueuePtr;\n            stRecordData[i].hasAllocatedMSHR = FALSE;\n            stRecordData[i].mshrID = '0;\n\n`ifdef RSD_ENABLE_REISSUE_ON_CACHE_MISS\n            stRegValid[i] = stPipeReg[i].regValid;\n`else\n            stRegValid[i] = TRUE;\n`endif\n\n\n            // Pipeline \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\n            stNextStage[i].regValid   = stRegValid[i];\n            stNextStage[i].addrOut    = stPipeReg[i].addrOut;\n            stNextStage[i].memMapType = stPipeReg[i].memMapType;\n            stNextStage[i].phyAddrOut = stPipeReg[i].phyAddrOut;\n            stNextStage[i].csrDataOut = stPipeReg[i].dataIn;\n\n            stNextStage[i].isLoad = FALSE;\n            stNextStage[i].isStore = isStore[i];\n            stNextStage[i].isCSR = FALSE;\n            stNextStage[i].isDiv = FALSE;\n            stNextStage[i].isMul = FALSE;\n\n            stNextStage[i].opDst = stIqData[i].opDst;\n            stNextStage[i].activeListPtr  = stIqData[i].activeListPtr;\n            stNextStage[i].loadQueueRecoveryPtr = stIqData[i].loadQueueRecoveryPtr;\n            stNextStage[i].storeQueueRecoveryPtr = stIqData[i].storeQueueRecoveryPtr;\n            stNextStage[i].pc  = stIqData[i].pc;\n\n            stNextStage[i].hasAllocatedMSHR = FALSE;\n            stNextStage[i].mshrID = 0;\n            stNextStage[i].storeForwardMiss = storeForwardMiss[i];\n\n            // ExecState\n            // \u547d\u4ee4\u306e\u5b9f\u884c\u7d50\u679c\u306b\u3088\u3063\u3066\u3001\u518d\u30d5\u30a7\u30c3\u30c1\u304c\u5fc5\u8981\u304b\u3069\u3046\u304b\u306a\u3069\u3092\u5224\u5b9a\u3059\u308b\n            if (!stUpdate[i] || (stUpdate[i] && !stRegValid[i])) begin\n                stNextStage[i].execState = EXEC_STATE_NOT_FINISHED;\n            end\n            else if ( isStore[i] && loadStoreUnit.conflict[i] ) begin\n                // memAccessOrderViolation\n                // \u30b9\u30c8\u30a2\u547d\u4ee4\u81ea\u8eab\u306f\u6b63\u3057\u304f\u5b9f\u884c\u3067\u304d\u3066\u3044\u308b\u305f\u3081\u3001\n                // \u6b21\u306e\u547d\u4ee4\u304b\u3089\u3084\u308a\u76f4\u3059\n                stNextStage[i].execState = EXEC_STATE_REFETCH_NEXT;\n                // Make request for studying violation instruction to Memory dependent predictor.\n                memAccessOrderViolation[i] = TRUE;\n            end\n            else begin\n                stNextStage[i].execState = EXEC_STATE_SUCCESS;\n            end\n\n            // \u5b9f\u884c\u304c\u6b63\u3057\u304f\u7d42\u4e86\u3057\u3066\u308b\u5834\u5408\uff0c\u30d5\u30a9\u30fc\u30eb\u30c8\u5224\u5b9a\u3092\u884c\u3046\n            // \u30b9\u30c8\u30a2\u306e\u4f9d\u5b58\u4e88\u6e2c\u3067\u306f\u3053\u3061\u3089\u306e\u65b9\u304c\u512a\u5148\u3055\u308c\u308b\n            if (stNextStage[i].execState inside {EXEC_STATE_SUCCESS, EXEC_STATE_REFETCH_NEXT}) begin\n                if (isStore[i]) begin\n                    if (stPipeReg[i].memMapType == MMT_ILLEGAL)\n        "}
{"text": "                stNextStage[i].execState = EXEC_STATE_FAULT_STORE_VIOLATION;\n                    else if (IsMisalignedAddress(stPipeReg[i].addrOut, stIqData[i].memOpInfo.memAccessMode.size))\n                        stNextStage[i].execState = EXEC_STATE_FAULT_STORE_MISALIGNED;\n                end\n            end\n\n\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            stNextStage[i].valid =\n                (stall || clear || port.rst || stFlush[i]) ? FALSE : stPipeReg[i].valid;\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            stNextStage[i].opId = stPipeReg[i].opId;\n`endif\n        end // for (int i = 0; i < STORE_ISSUE_WIDTH; i++) begin\n    end // always_comb begin\n\n\n    logic flush   [ MEM_ISSUE_WIDTH ];\n    MemoryAccessStageRegPath nextStage[MEM_ISSUE_WIDTH];\n\n    always_comb begin\n        loadStoreUnit.memAccessOrderViolation = memAccessOrderViolation;\n\n        `ifdef RSD_MARCH_UNIFIED_LDST_MEM_PIPE\n            for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n                // Record instructions to the replay queue.\n                if (isStore[i]) begin\n                    scheduler.memRecordEntry[i] = stUpdate[i] && !stRegValid[i];\n                    scheduler.memRecordData[i] = stRecordData[i];\n                    nextStage[i] = stNextStage[i];\n                    flush[i] = stFlush[i];\n                end\n                else begin\n                    scheduler.memRecordEntry[i] = ldUpdate[i] && !ldRegValid[i];\n                    scheduler.memRecordData[i] = ldRecordData[i];\n                    nextStage[i] = ldNextStage[i];\n                    flush[i] = ldFlush[i];\n                end\n            end\n        `else\n            for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n                // Record instructions to the replay queue.\n                scheduler.memRecordEntry[i] = ldUpdate[i] && !ldRegValid[i];\n                scheduler.memRecordData[i] = ldRecordData[i];\n                nextStage[i] = ldNextStage[i];\n                flush[i] = ldFlush[i];\n            end\n            for (int i = 0; i < STORE_ISSUE_WIDTH; i++) begin\n                // Record instructions to the replay queue.\n                scheduler.memRecordEntry[i+STORE_ISSUE_LANE_BEGIN] = stUpdate[i] && !stRegValid[i];\n                scheduler.memRecordData[i+STORE_ISSUE_LANE_BEGIN] = stRecordData[i];\n                nextStage[i+STORE_ISSUE_LANE_BEGIN] = stNextStage[i];\n                flush[i+STORE_ISSUE_LANE_BEGIN] = stFlush[i];\n            end\n        `endif\n\n        port.nextStage = nextStage;\n\n    end\n\n    always_comb begin\n\n        // Debug Register\n`ifndef RSD_DISABLE_PERFORMANCE_COUNTER\n        for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin\n            // Record misses only when a MSHR entry is allocated.\n            perfCounter.loadMiss[i] =\n                ldUpdate[i] && isLoad[i] && ldMSHR_Allocated[i];\n        end\n`endif\n\n        // Debug Register\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            debug.mtReg[i].valid = pipeReg[i].valid;\n            debug.mtReg[i].flush = flush[i];\n            debug.mtReg[i].opId = pipeReg[i].opId;\n        end\n`ifdef RSD_FUNCTIONAL_SIMULATION\n\n        `ifdef RSD_MARCH_UNIFIED_LDST_MEM_PIPE\n            for (int i = 0; i < MEM_ISSUE_WIDTH; i++) begin\n                debug.mtReg[i].executeLoad = isLoad[i] ? loadStoreUnit.executeLoad[i] : FALSE;\n                debug.mtReg[i].executedLoadAddr  = loadStoreUnit.executedLoadAddr[i];\n                debug.mtReg[i].mshrAllocated = ldMSHR_Allocated[i] && ldUpdate[i] && isLoad[i];\n                debug.mtReg[i].mshrHit = ldMSHR_Hit[i] && ldUpdate[i] && isLoad[i];\n                debug.mtReg[i].mshrEntryID = (ldMSHR_Allocated[i] || ldMSHR_Hit[i]) ? ldMSHR_EntryID[i] : 0;\n\n                debug.mtReg[i].executeStore      = isStore[i] ? loadStoreUnit.executeStore[i] : FALSE;\n                debug.mtReg[i].executedStoreAddr = loadStoreUnit.executedStoreAddr[i];\n                debug.mtReg[i].executedStoreData = loadStoreUnit.executedStoreData[i];\n                debug.mtReg[i].executedStoreVectorData = loadStoreUnit.executedStoreVectorData[i];\n            end\n\n        `else\n            for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n                debug.mtReg[i].executeLoad       = loadStoreUnit.executeLoad[i];\n                debug.mtReg[i].executedLoadAddr  = loadStoreUnit.executedLoadAddr[i];\n                debug.mtReg[i].mshrAllocated = ldMSHR_Allocated[i] && ldUpdate[i] && isLoad[i];\n                debug.mtReg[i].mshrHit = ldMSHR_Hit[i] && ldUpdate[i] && isLoad[i];\n                debug.mtReg[i].mshrEntryID = (ldMSHR_Allocated[i] || ldMSHR_Hit[i]) ? ldMSHR_EntryID[i] : 0;\n            end\n            for (int i = 0; i < STORE_ISSUE_WIDTH; i++) begin\n                debug.mtReg[i+STORE_ISSUE_LANE_BEGIN].executeStore      = loadStoreUnit.executeStore[i];\n                debug.mtReg[i+STORE_ISSUE_LANE_BEGIN].executedStoreAddr = loadStoreUnit.executedStoreAddr[i];\n                debug.mtReg[i+STORE_ISSUE_LANE_BEGIN].executedStoreData = loadStoreUnit.executedStoreData[i];\n                debug.mtReg[i+STORE_ISSUE_LANE_BEGIN].executedStoreVectorData = loadStoreUnit.executedStoreVectorData[i];\n            end\n        `endif // `ifdef RSD_FUNCTIONAL_SIMULATION\n`endif // `ifdef RSD_FUNCTIONAL_SIMULATION\n\n`endif  // `ifndef RSD_DISABLE_DEBUG_REGISTER\n    end\n\n\nendmodule : MemoryTagAccessStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- MemoryTagAccessStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface MemoryTagAccessStageIF(input logic clk, rst);\n\n    // Pipeline register\n    MemoryAccessStageRegPath nextStage[MEM_ISSUE_WIDTH];\n    \n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage\n    );\n    \n    modport NextStage(\n    input\n        nextStage\n    );\n\nendinterface : MemoryTagAccessStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n`include \"SysDeps/XilinxMacros.vh\"\n\npackage MemoryTypes;\n\nimport BasicTypes::*;\nimport CacheSystemTypes::*;\nimport MemoryMapTypes::*;\n\n//\n// Size of Main Memory\n//\n`ifdef RSD_SYNTHESIS\n    `ifdef RSD_USE_EXTERNAL_MEMORY\n        localparam MEMORY_ADDR_BIT_SIZE = 32;\n    `else\n        localparam MEMORY_ADDR_BIT_SIZE = 18; // 256KB\n    `endif\n`else\n        localparam MEMORY_ADDR_BIT_SIZE = 25; // 512KB\n`endif\n\nlocalparam MEMORY_BYTE_SIZE = 1 << MEMORY_ADDR_BIT_SIZE;\n\n// Specify the number of rows of the dummy data (one row corresponds to one entry in the memory) \n// for initializing the memory. \n// If the memory entry is larger than this value, the dummy data is repeatedly read and initialized.\nlocalparam DUMMY_HEX_ENTRY_NUM = 256;\n\n\n// Memory Entry Size\nlocalparam MEMORY_ENTRY_BIT_NUM /*verilator public*/ = 64; // Bit width of each memory entry\nlocalparam MEMORY_ENTRY_BYTE_NUM = MEMORY_ENTRY_BIT_NUM / BYTE_WIDTH;\nlocalparam MEMORY_ADDR_MSB = MEMORY_ADDR_BIT_SIZE - 1;\nlocalparam MEMORY_ADDR_LSB = $clog2( MEMORY_ENTRY_BYTE_NUM );\nlocalparam MEMORY_INDEX_BIT_WIDTH = MEMORY_ADDR_MSB - MEMORY_ADDR_LSB + 1;\nlocalparam MEMORY_ENTRY_NUM /*verilator public*/ = (1 << MEMORY_INDEX_BIT_WIDTH);\ntypedef logic [ MEMORY_ENTRY_BIT_NUM-1:0 ] MemoryEntryDataPath;\n\n// Latency\n\n// The pipeline length of memory read processing\nlocalparam MEMORY_READ_PIPELINE_DEPTH = 5;\n\n// The latency of memory write process\nlocalparam MEMORY_WRITE_PROCESS_LATENCY = 2;\n\n// The latency of memory read process.\n// This value indicates # of cycles from the read access \n// to the next read/write access.\n// Note that this value is not # of cycles to read data. \nlocalparam MEMORY_READ_PROCESS_LATENCY = 2;\n\n// For counting the latency of memory read/write accrss\ntypedef logic [1:0] MemoryProcessLatencyCount;\n\ntypedef struct packed {\n    logic [`MEMORY_AXI4_READ_ID_WIDTH-1: 0] id; // Request id for AXI4\n    logic [`MEMORY_AXI4_ADDR_BIT_SIZE-1: 0] addr;\n} MemoryReadReq;\n\n// To simulate variable latency memory access\nlocalparam MEM_LATENCY_SIM_QUEUE_SIZE = 128;\nlocalparam MEM_LATENCY_SIM_LATENCY_FLUCTUATION_RANGE = 10;\nlocalparam MEM_LATENCY_SIM_RAND_BIT_WIDTH = 32;\nlocalparam MEM_LATENCY_SIM_RAND_SEED = 1987534242;\ntypedef logic [$clog2(MEM_LATENCY_SIM_LATENCY_FLUCTUATION_RANGE):0] LatencyCountPath;\ntypedef logic [MEM_LATENCY_SIM_RAND_BIT_WIDTH-1:0] MemoryRandPath;\ntypedef struct packed {\n    logic isRead;\n    logic isWrite;\n    AddrPath memAccessAddr;\n    MemoryEntryDataPath memAccessWriteData;\n    MemAccessSerial nextMemReadSerial; // Serial ID assigned to the next read request\n    MemWriteSerial nextMemWriteSerial; // Serial ID assigned to the next write request\n    logic wr;\n} MemoryLatencySimRequestPath;\n\nendpackage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// MemoryWriteDataQueue\n//\n\n`include \"SysDeps/XilinxMacros.vh\"\n\nimport BasicTypes::*;\nimport MemoryTypes::*;\n\nmodule MemoryWriteDataQueue ( \ninput \n    logic clk,\n    logic rst,\n    logic push,\n    logic pop,\n    MemoryEntryDataPath pushedData,\noutput\n    logic full,\n    logic empty,\n    MemoryEntryDataPath headData,\n    logic [`MEMORY_AXI4_WRITE_ID_WIDTH-1: 0] headPtr,\n    logic [`MEMORY_AXI4_WRITE_ID_WIDTH-1: 0] tailPtr\n);\n\n    // typedef logic [`MEMORY_AXI4_WRITE_ID_WIDTH-1: 0] IndexPath;\n\n    // IndexPath headPtr;\n    // IndexPath tailPtr;\n\n    // size, initial head, initial tail, initial count\n    QueuePointer #( `MEMORY_AXI4_WRITE_ID_NUM, 0, 0, 0 )\n        pointer(\n            .clk( clk ),\n            .rst( rst ),\n            .push( push ),\n            .pop( pop ),\n            .full( full ),\n            .empty( empty ),\n            .headPtr( headPtr ),\n            .tailPtr( tailPtr )\n        );\n        \n\n    logic [ MEMORY_ENTRY_BIT_NUM-1:0 ] memoryWriteDataQueue[ `MEMORY_AXI4_WRITE_ID_NUM ]; // synthesis syn_ramstyle = \"select_ram\"\n\n    always_ff @( posedge clk ) begin\n        if( push ) begin\n            memoryWriteDataQueue[ tailPtr ] <= pushedData;\n        end\n    end\n    \n    always_comb begin\n        headData = memoryWriteDataQueue[ headPtr ];\n    end\n\nendmodule : MemoryWriteDataQueue\n\n "}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Definitions related to micro ops.\n//\n\n\npackage MicroOpTypes;\n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\n\n\nlocalparam LINK_REGISTER = 5'h 1;\nlocalparam MICRO_OP_TMP_REGISTER = 4'h f;\nlocalparam ZERO_REGISTER = 5'h 0;\n\nlocalparam MICRO_OP_MAX_NUM = 3;     // An instruction is decoded to up to 3 micro ops.\nlocalparam MICRO_OP_INDEX_BITS = 2;  \ntypedef logic [MICRO_OP_INDEX_BITS-1:0] MicroOpIndex;   // \u30de\u30a4\u30af\u30edOp \u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\ntypedef logic [MICRO_OP_INDEX_BITS  :0] MicroOpCount;\n\n\nlocalparam ALL_DECODED_MICRO_OP_WIDTH = MICRO_OP_MAX_NUM * DECODE_WIDTH;\nlocalparam ALL_DECODED_MICRO_OP_WIDTH_BIT_SIZE = MICRO_OP_INDEX_BITS + DECODE_WIDTH_BIT_SIZE;\n\ntypedef logic [ALL_DECODED_MICRO_OP_WIDTH-1:0] AllDecodedMicroOpPath;\ntypedef logic [ALL_DECODED_MICRO_OP_WIDTH-DECODE_WIDTH-1:0] RemainingDecodedMicroOpPath;\ntypedef logic [ALL_DECODED_MICRO_OP_WIDTH_BIT_SIZE-1:0] AllDecodedMicroOpIndex;\n\n\n`ifdef RSD_MARCH_FP_PIPE\nlocalparam MICRO_OP_SOURCE_REG_NUM = 3;\n`else\nlocalparam MICRO_OP_SOURCE_REG_NUM = 2;\n`endif\n\ntypedef enum logic [1:0]\n{\n    MOP_TYPE_INT     = 2'b00,\n    MOP_TYPE_COMPLEX = 2'b01,\n    MOP_TYPE_MEM     = 2'b10\n`ifdef RSD_MARCH_FP_PIPE\n    ,\n    MOP_TYPE_FP      = 2'b11\n`endif\n} MicroOpType;\n\n// \u5404\u30b5\u30d6\u30bf\u30a4\u30d7\u306f\uff0c\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u4e2d\u3067\u51e6\u7406\u3092\u898b\u5206\u3051\u308b\u305f\u3081\u306b\u4f7f\u7528\u3055\u308c\u308b\ntypedef enum logic [2:0]\n{\n    INT_MOP_TYPE_ALU       = 3'b000,\n    INT_MOP_TYPE_SHIFT     = 3'b001,\n\n    INT_MOP_TYPE_BR        = 3'b010,\n    INT_MOP_TYPE_RIJ       = 3'b011\n} IntMicroOpSubType;\n\ntypedef enum logic [2:0]\n{\n    COMPLEX_MOP_TYPE_MUL       = 3'b000,\n    COMPLEX_MOP_TYPE_DIV       = 3'b001   // DIV\u6f14\u7b97\u5668\u3092\u4f7f\u3046\u3082\u306e(DIV\u3068REM)\n} ComplexMicroOpSubType;\n\ntypedef enum logic [2:0]\n{\n    MEM_MOP_TYPE_LOAD      = 3'b000,\n    MEM_MOP_TYPE_STORE     = 3'b001,\n\n    // Mem \u30d1\u30a4\u30d7\u3067\u4e57\u9664\u7b97\u3092\u3084\u308b\u5834\u5408\u306e\u30b3\u30fc\u30c9\n    MEM_MOP_TYPE_MUL       = 3'b010,\n    MEM_MOP_TYPE_DIV       = 3'b011,\n\n    MEM_MOP_TYPE_CSR       = 3'b100, // CSR access\n    MEM_MOP_TYPE_FENCE     = 3'b101, // fence\n    MEM_MOP_TYPE_ENV       = 3'b110  // env\n\n} MemMicroOpSubType;\n\ntypedef enum logic [2:0]\n{\n    FP_MOP_TYPE_ADD    = 3'b000,\n    FP_MOP_TYPE_MUL    = 3'b001,\n    FP_MOP_TYPE_DIV    = 3'b010,\n    FP_MOP_TYPE_SQRT   = 3'b011,\n    FP_MOP_TYPE_FMA    = 3'b100,\n    FP_MOP_TYPE_OTHER  = 3'b101\n} FPMicroOpSubType;\n\ntypedef union packed    // OpSubType\n{\n    IntMicroOpSubType     intType;\n    ComplexMicroOpSubType complexType;\n    MemMicroOpSubType     memType;\n`ifdef RSD_MARCH_FP_PIPE\n    FPMicroOpSubType     fpType;\n`endif\n} MicroOpSubType;\n\ntypedef struct packed // OpId\n{\n    OpSerial sid;\n    MicroOpIndex mid;\n} OpId;\n\n// The type of operand.\ntypedef enum logic [1:0]    // enum OperandType\n{\n    OOT_REG = 2'b00,   // Register\n    OOT_IMM = 2'b01,   // Immediate\n    OOT_PC  = 2'b10    // PC\n} OpOperandType;\n\n\n//\n// The eperands of micro-ops\n// The order of fields is important. The order must be fixed for simplifying a decoder.\n//\n\n// Int: 6+6+6+ 4+ 1+ 30=53 bits\ntypedef struct packed // IntMicroOpOperand\n{\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n    LRegNumPath dstRegNum;\n    LRegNumPath srcRegNumA;    // \u30ec\u30b8\u30b9\u30bfN \u76f8\u5f53\n    LRegNumPath srcRegNumB;    // \u7b2c2\u30aa\u30da\u30e9\u30f3\u30c9\n\n    // ALU\n    IntALU_Code aluCode;\n\n    // Shift\n    ShiftOperandType shiftType;\n\n    // Shifter operand and imm\n    ShifterPath shiftIn;\n} IntMicroOpOperand;\n\n// Mem: 6+6+6 +1+1+3 +8 +15 +12 = 18+5+8+10+12 = 53 bits\ntypedef struct packed // MemMicroOpOperand\n{\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n    LRegNumPath dstRegNum;\n    LRegNumPath srcRegNumA;    // \u30ec\u30b8\u30b9\u30bfN \u76f8\u5f53\n    LRegNumPath srcRegNumB;    // \u7b2c2\u30aa\u30da\u30e9\u30f3\u30c9\n\n    logic isAddAddr;    // \u30aa\u30d5\u30bb\u30c3\u30c8\u52a0\u7b97\n    logic isRegAddr;    // \u30ec\u30b8\u30b9\u30bf\u30a2\u30c9\u30ec\u30c3\u30b7\u30f3\u30b0\n    MemAccessMode memAccessMode; // signed/unsigned and access size\n\n    CSR_CtrlPath csrCtrl;\n    logic [9:0] padding; //\u3000padding\n\n    // Address offset or CSR number\n    AddrOperandImm addrIn;\n} MemMicroOpOperand;\n\n// Branch:6+6+6 +15 +20=53 bits\ntypedef struct packed // BrMicroOpOperand\n{\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n    LRegNumPath dstRegNum;\n    LRegNumPath srcRegNumA;    // \u30ec\u30b8\u30b9\u30bfN \u76f8\u5f53\n    LRegNumPath srcRegNumB;    // \u7b2c2\u30aa\u30da\u30e9\u30f3\u30c9\n    logic [14:0] padding;       // padding\n    BranchDisplacement brDisp;  // Branch offset.\n} BrMicroOpOperand;\n\n// Complex Integer: 6+6+6 +1 +16 +18 = 35+18= 53 bits\ntypedef struct packed // ComplexMicroOpOperand\n{\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n    LRegNumPath dstRegNum;\n    LRegNumPath srcRegNumA;    // \u30ec\u30b8\u30b9\u30bfN \u76f8\u5f53\n    LRegNumPath srcRegNumB;    // \u7b2c2\u30aa\u30da\u30e9\u30f3\u30c9\n\n    logic mulGetUpper;  // \u4e57\u7b97\u7d50\u679c\u306e33-64bit\u76ee\u3092\u4f7f\u7528\n    IntMUL_Code mulCode;\n    IntDIV_Code divCode;\n\n    logic [15:0] padding;        // Padding field.\n    logic [13:0] riscv_padding; // RISCV\u7528\u306epadding\n} ComplexMicroOpOperand;\n\n// MiscMem: 6+6+6 +1 +16 +18 = 35+18= 53 bits\ntypedef struct packed // MiscMemMicroOpOperand\n{\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n    LRegNumPath dstRegNum;\n    LRegNumPath srcRegNumA;    // \u30ec\u30b8\u30b9\u30bfN \u76f8\u5f53\n    LRegNumPath srcRegNumB;    // \u7b2c2\u30aa\u30da\u30e9\u30f3\u30c9\n\n    logic fence;\n    logic fenceI;\n\n    logic [14:0] padding;        // Padding field.\n    logic [17:0] riscv_padding; // RISCV\u7528\u306epadding\n} MiscMemMicroOpOperand;\n\n// MiscMem: 6+6+6 +3+1 +19 +12 = 18+4+19+12= 53 bits\ntypedef struct packed // SystemMicroOpOperand\n{\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n    LRegNumPath dstRegNum;\n    LRegNumPath srcRegNumA;    // \u30ec\u30b8\u30b9\u30bfN \u76f8\u5f53\n    LRegNumPath srcRegNumB;    // \u7b2c2\u30aa\u30da\u30e9\u30f3\u30c9\n\n    ENV_Code envCode;\n    logic isEnv;\n\n    logic [18:0] padding;        // Padding field.\n\n    logic [11:0] imm;\n} SystemMicroOpOperand;\n\n//FPMicroOpOperand: 6+6+6+6 +5+3 +21 = 53 bits\ntypedef struct packed // FPMicroOpOperand\n{\n    // \u8ad6\u7406\u30ec\u30b8\u30b9\u30bf\u756a\u53f7\n    LRegNumPath dstRegNum;\n    LRegNumPath srcRegNumA;    // \u7b2c1\u30aa\u30da\u30e9\u30f3\u30c9\n    LRegNumPath srcRegNumB;    // \u7b2c2\u30aa\u30da\u30e9\u30f3\u30c9\n    LRegNumPath srcRegNumC;    // \u7b2c3\u30aa\u30da\u30e9\u30f3\u30c9\n\n    FPU_Code fpuCode;\n    Rounding_Mode rm;\n    logic [20:0] padding;        // Padding field.\n} FPMicroOpOperand;\n\ntypedef union packed    // MicroOpOperand\n{\n    IntMicroOpOperand     intOp;\n    MemMicroOpOperand     memOp;\n    BrMicroOpOperand      brOp;\n    ComplexMicroOpOperand complexOp;\n    MiscMemMicroOpOperand miscMemOp;\n    SystemMicroOpOperand  systemOp;\n`ifdef RSD_MARCH_FP_PIPE\n    FPMicroOpOperand fpOp;\n`endif\n} MicroOpOperand;\n\n\ntypedef struct packed // OpInfo\n{\n    // \u6761\u4ef6\u30b3\u30fc\u30c9\n    CondCode cond;\n\n    // \u547d\u4ee4\u306e\u7a2e\u985e\n    MicroOpType mopType;\n    MicroOpSubType mopSubType;\n    \n    // The operands of this micro op.\n    MicroOpOperand operand;\n\n    OpOperandType opTypeA;\n    OpOperandType opTypeB;\n`ifdef RSD_MARCH_FP_PIPE\n    OpOperandType opTypeC;\n`endif\n\n    logic writeReg;     // \u30ec\u30b8\u30b9\u30bf\u66f8\u304d\u8fbc\u307f\u3092\u884c\u3046\u304b\u3069\u3046\u304b\n    \n    // \u7121\u52b9\u306a\u547d\u4ee4\n    logic undefined;    // Undefined op.\n    logic unsupported;  // Defined, but unsuported.\n    \n    // \u30de\u30a4\u30af\u30edOp \u306b\u5206\u5272\u3055\u308c\u3066\u3044\u308b\u304b\u3069\u3046\u304b\n    logic split;\n    \n    // Whether this micro op is valid or not.\n    logic valid;\n\n    // Whether this micro op is the last micro op in an original instruction.\n    logic last;\n    \n    // \u30de\u30a4\u30af\u30edOp \u306e\u30a4\u30f3\u30c7\u30c3\u30af\u30b9\n    MicroOpIndex mid;\n\n    // This instruction needs serialization.\n    // That is, \n    // * this instruction is not fed to the succeeding stages until all the \n    // preceding instructions are retired. \n    // * The succeeding instructions are never fetched until this instruction \n    // is retired. \n    // * Already fetched succeeding instructions are flushed when this \n    // instruction is decoded.\n    logic serialized;    \n} OpInfo;\n\ntypedef struct packed { // InsnInfo\n    logic writePC;  // This instruction writes the PC.\n\n    // call/return\n    logic isCall;\n    logic isReturn;\n    \n    // PC relative (JAL, branch)\n    logic isRelBranch;\n\n    // See comments of \"serialized\" in OpInfo\n    logic isSerialized;    \n} InsnInfo;\n\n\nendpackage\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Complex Integer Execution stage\n//\n// \u4e57\u7b97/SIMD \u547d\u4ee4\u306e\u6f14\u7b97\u3092\u884c\u3046\n// COMPLEX_EXEC_STAGE_DEPTH \u6bb5\u306b\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5316\u3055\u308c\u3066\u3044\u308b\n//\n\n`include \"BasicMacros.sv\"\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport ActiveListIndexTypes::*;\n\nmodule MulDivUnit(MulDivUnitIF.MulDivUnit port, RecoveryManagerIF.MulDivUnit recovery);\n\n    for (genvar i = 0; i < MULDIV_ISSUE_WIDTH; i++) begin : BlockMulUnit\n        // MultiplierUnit\n        PipelinedMultiplierUnit #(\n            .BIT_WIDTH(DATA_WIDTH),\n            .PIPELINE_DEPTH(MULDIV_STAGE_DEPTH)\n        ) mulUnit (\n            .clk(port.clk),\n            .stall(port.stall),\n            .fuOpA_In(port.dataInA[i]),\n            .fuOpB_In(port.dataInB[i]),\n            .getUpper(port.mulGetUpper[i]),\n            .mulCode(port.mulCode[i]),\n            .dataOut(port.mulDataOut[i])\n        );\n    end\n\n\n    //\n    // DividerUnit\n    //\n\n    typedef enum logic[1:0]\n    {\n        DIVIDER_PHASE_FREE       = 0,  // Divider is free\n        DIVIDER_PHASE_RESERVED   = 1,  // Divider is not processing but reserved\n        DIVIDER_PHASE_PROCESSING = 2,  // In processing\n        DIVIDER_PHASE_WAITING    = 3   // Wait for issuing div from the replay queue\n    } DividerPhase;\n    DividerPhase regPhase  [MULDIV_ISSUE_WIDTH];\n    DividerPhase nextPhase [MULDIV_ISSUE_WIDTH];\n    logic finished[MULDIV_ISSUE_WIDTH];\n\n    logic flush[MULDIV_ISSUE_WIDTH];\n    ActiveListIndexPath regActiveListPtr[MULDIV_ISSUE_WIDTH];\n    ActiveListIndexPath nextActiveListPtr[MULDIV_ISSUE_WIDTH];\n\n    for (genvar i = 0; i < MULDIV_ISSUE_WIDTH; i++) begin : BlockDivUnit\n        DividerUnit divUnit(\n            .clk(port.clk),\n            .rst(port.rst),\n            .req(port.divReq[i]),\n            .fuOpA_In(port.dataInA[i]),\n            .fuOpB_In(port.dataInB[i]),\n            .divCode(port.divCode[i]),\n            .finished(finished[i]),\n            .dataOut(port.divDataOut[i])\n        );\n    end\n\n    always_ff @(posedge port.clk) begin\n        if (port.rst) begin\n            for (int i = 0; i < MULDIV_ISSUE_WIDTH; i++) begin\n                regPhase[i] <= DIVIDER_PHASE_FREE;\n                regActiveListPtr[i] <= 0;\n            end\n        end\n        else begin\n            regPhase <= nextPhase;\n            regActiveListPtr <= nextActiveListPtr;\n        end\n    end\n\n    always_comb begin\n        nextPhase = regPhase;\n        nextActiveListPtr = regActiveListPtr;\n\n        for (int i = 0; i < MULDIV_ISSUE_WIDTH; i++) begin\n\n            case (regPhase[i])\n            default: begin\n                nextPhase[i] = DIVIDER_PHASE_FREE;\n            end\n\n            DIVIDER_PHASE_FREE: begin\n                // Reserve divider and do not issue any div after that.\n                if (port.divAcquire[i]) begin\n                    nextPhase[i] = DIVIDER_PHASE_RESERVED;\n                    nextActiveListPtr[i] = port.acquireActiveListPtr[i];\n                end\n            end\n\n            DIVIDER_PHASE_RESERVED: begin\n                // Request to the divider\n                // NOT make a request when below situation\n                // 1) When any operands of inst. are invalid\n                // 2) When the divider is waiting for the instruction\n                //    to receive the result of the divider\n                if (port.divReq[i]) begin\n                    // Receive the request of div, \n                    // so move to processing phase\n                    nextPhase[i] = DIVIDER_PHASE_PROCESSING;\n                end\n            end\n\n            DIVIDER_PHASE_PROCESSING: begin\n                // Div operation has finished, so we can get result from divider\n                if (finished[i]) begin\n                    nextPhase[i] = DIVIDER_PHASE_WAITING;\n                end\n            end\n\n            DIVIDER_PHASE_WAITING: begin\n                if (port.divRelease[i]) begin \n                    // Div\u304c\u9664\u7b97\u5668\u304b\u3089\u7d50\u679c\u3092\u53d6\u5f97\u3067\u304d\u305f\u306e\u3067\uff0c\n                    // IQ\u304b\u3089\u306ediv\u306e\u767a\u884c\u3092\u8a31\u53ef\u3059\u308b \n                    nextPhase[i] = DIVIDER_PHASE_FREE;\n                end\n            end\n            endcase // regPhase[i]\n\n\n            // Cancel divider allocation on pipeline flush\n            flush[i] = SelectiveFlushDetector(\n                recovery.toRecoveryPhase,\n                recovery.flushRangeHeadPtr,\n                recovery.flushRangeTailPtr,\n                recovery.flushAllInsns,\n                regActiveListPtr[i]\n            );\n\n            // \u9664\u7b97\u5668\u306b\u8981\u6c42\u3092\u3057\u305fdiv\u304c\u30d5\u30e9\u30c3\u30b7\u30e5\u3055\u308c\u305f\u306e\u3067\uff0c\u9664\u7b97\u5668\u3092\u89e3\u653e\u3059\u308b\n            if (flush[i]) begin\n                nextPhase[i] = DIVIDER_PHASE_FREE;\n            end\n\n            // \u73fe\u72b6 acquire \u304c issue \u30b9\u30c6\u30fc\u30b8\u304b\u3089\u304f\u308b\u306e\u3067\uff0c\u6b21\u306e\u30b5\u30a4\u30af\u30eb\u306e\u72b6\u614b\u3067\u30d5\u30ea\u30fc\u304b\n            // \u3069\u3046\u304b\u3092\u5224\u5b9a\u3059\u308b\u5fc5\u8981\u304c\u3042\u308b\n            port.divFree[i]     = nextPhase[i] == DIVIDER_PHASE_FREE ? TRUE : FALSE;   \n            port.divFinished[i] = regPhase[i] == DIVIDER_PHASE_WAITING ? TRUE : FALSE;\n            port.divBusy[i]     = regPhase[i] == DIVIDER_PHASE_PROCESSING ? TRUE : FALSE;\n            port.divReserved[i] = regPhase[i] == DIVIDER_PHASE_RESERVED ? TRUE : FALSE;\n\n        end // for (int i = 0; i < MULDIV_ISSUE_WIDTH; i++) begin\n\n    end // always_comb begin\n\n\nendmodule\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Complex Integer Execution stage\n//\n// \u4e57\u7b97/SIMD \u547d\u4ee4\u306e\u6f14\u7b97\u3092\u884c\u3046\n// COMPLEX_EXEC_STAGE_DEPTH \u6bb5\u306b\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5316\u3055\u308c\u3066\u3044\u308b\n//\n\n`include \"BasicMacros.sv\"\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport ActiveListIndexTypes::*;\n\n\ninterface MulDivUnitIF(input logic clk, rst);\n\n    // dummy signal to prevent that some modports become empty\n    logic dummy;\n    logic stall;\n\n    DataPath dataInA[MULDIV_ISSUE_WIDTH];\n    DataPath dataInB[MULDIV_ISSUE_WIDTH];\n\n    DataPath    mulDataOut  [MULDIV_ISSUE_WIDTH];\n    logic       mulGetUpper [MULDIV_ISSUE_WIDTH];\n    IntMUL_Code mulCode     [MULDIV_ISSUE_WIDTH];\n\n    DataPath    divDataOut  [MULDIV_ISSUE_WIDTH];\n    IntDIV_Code divCode     [MULDIV_ISSUE_WIDTH];\n    logic       divReq      [MULDIV_ISSUE_WIDTH];\n    logic       divReserved [MULDIV_ISSUE_WIDTH];\n    logic       divFinished [MULDIV_ISSUE_WIDTH];\n    logic       divBusy     [MULDIV_ISSUE_WIDTH];\n    logic       divFree     [MULDIV_ISSUE_WIDTH];\n\n    logic divAcquire[MULDIV_ISSUE_WIDTH];\n    logic divRelease[MULDIV_ISSUE_WIDTH];\n\n    ActiveListIndexPath acquireActiveListPtr[MULDIV_ISSUE_WIDTH];\n\n    modport MulDivUnit(\n    input\n        clk,\n        rst,\n        stall,\n        dataInA,\n        dataInB,\n        mulGetUpper,\n        mulCode,\n        divCode,\n        divReq,\n        divAcquire,\n        divRelease,\n        acquireActiveListPtr,\n    output\n        mulDataOut,\n        divDataOut,\n        divFinished,\n        divBusy,\n        divReserved,\n        divFree\n    );\n\n    modport ComplexIntegerIssueStage(\n    input\n        dummy\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        ,\n    output\n        divAcquire,\n        acquireActiveListPtr\n`endif\n    );\n\n    modport ComplexIntegerExecutionStage(\n    input\n        mulDataOut,\n        divDataOut,\n        divFinished,\n        divBusy,\n        divReserved,\n        divFree\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        ,\n    output\n        stall,\n        dataInA,\n        dataInB,\n        mulGetUpper,\n        mulCode,\n        divCode,\n        divReq,\n        divRelease\n`endif\n    );\n\n    modport MemoryIssueStage(\n    input\n        dummy\n`ifdef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        ,\n    output\n        divAcquire,\n        acquireActiveListPtr\n`endif\n    );\n\n    modport MemoryExecutionStage(\n    input\n        divBusy,\n        divReserved,\n        divFree\n`ifdef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        ,\n    output\n        stall,\n        dataInA,\n        dataInB,\n        mulGetUpper,\n        mulCode,\n        divCode,\n        divReq\n`endif\n    );\n\n    modport MemoryTagAccessStage(\n    input\n        divFinished\n    );\n\n    modport MemoryAccessStage(\n    input\n        mulDataOut,\n        divDataOut,\n        divFinished\n`ifdef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        ,\n    output\n        divRelease\n`endif\n    );\n\n\n    modport Scheduler(\n    input\n        divFree\n    );\n\n    modport ReplayQueue(\n    input\n        divBusy\n    );\n\nendinterface\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- Multiplier Unit\n// This unit performs 32bit*32bit = 32bit,\n// and return upper or lower 32 bit\n//\n\nimport BasicTypes::*;\nimport MicroOpTypes::*;\nimport OpFormatTypes::*;\n\n// Multiplier Unit\nmodule MultiplierUnit (\ninput\n    DataPath fuOpA_In,\n    DataPath fuOpB_In,\n    logic getUpper, // If TRUE, the multiplication result 33-64 bit is set to mulDataOut\noutput\n    DataPath dataOut\n);\n    logic [ 2*DATA_WIDTH-1:0 ] mulResult;\n    \n    Multiplier #( \n        .BIT_WIDTH( $bits(DataPath) )\n    ) mul ( \n        .srcA(fuOpA_In),\n        .srcB(fuOpB_In),\n        .dst(mulResult)\n    );\n    \n    always_comb begin\n        if (getUpper)\n            dataOut = mulResult[ 2*DATA_WIDTH-1:DATA_WIDTH ];\n        else\n            dataOut = mulResult[ DATA_WIDTH-1:0 ];\n    end\n    \nendmodule : MultiplierUnit\n\n\n// Pipelined Multiplier Unit\nmodule PipelinedMultiplierUnit #( \n    parameter BIT_WIDTH = 32,\n    parameter PIPELINE_DEPTH = 3\n)( \ninput\n    logic clk, stall,\n    DataPath fuOpA_In,\n    DataPath fuOpB_In,\n    logic getUpper, // If TRUE, the multiplication result 33-64 bit is set to mulDataOut\n    IntMUL_Code mulCode,\noutput\n    DataPath dataOut\n);\n    \n    typedef struct packed { // PipeReg\n        logic getUpper;\n        IntMUL_Code mulCode;\n        logic fuOpA_sign;\n        logic fuOpB_sign;\n    } PipeReg;\n    \n    PipeReg pipeReg[ PIPELINE_DEPTH-1 ];\n    \n    logic [ 2*DATA_WIDTH-1:0 ] mulResult;\n    //logic signed [ 2*DATA_WIDTH-1:0 ] mulResult_signed;\n    //logic signed [ 2*DATA_WIDTH-1:0 ] dataOut_signed;\n    logic signed [ DATA_WIDTH-1:0 ] fuOpA_signed;\n    logic signed [ DATA_WIDTH-1:0 ] fuOpB_signed;\n    logic fuOpA_sign;\n    logic fuOpB_sign;\n    //logic signed [ DATA_WIDTH-1:0 ] srcA_signed;\n    //logic signed [ DATA_WIDTH-1:0 ] srcB_signed;\n    logic signA;\n    logic signB;\n    logic [ DATA_WIDTH-1:0 ] srcA;\n    logic [ DATA_WIDTH-1:0 ] srcB;\n\n    PipelinedMultiplier #( \n        .BIT_WIDTH( $bits(DataPath) ),\n        .PIPELINE_DEPTH( PIPELINE_DEPTH )\n    ) mul (\n        .clk( clk ),\n        .stall( stall ),\n        .srcA(srcA),\n        .srcB(srcB),\n        .signA(signA),\n        .signB(signB),\n        .dst(mulResult)\n    );\n\n    // Make src operands unsigned(plus) value.\n    always_comb begin\n        // fuOpA_signed = fuOpA_In;\n        // fuOpB_signed = fuOpB_In;\n        // fuOpA_sign = (fuOpA_signed < 0);\n        // fuOpB_sign = (fuOpB_signed < 0);\n\n        if ( mulCode == AC_MULHU ) begin\n            // // MULHU takes srcA as unsigned.\n            // srcA_signed = fuOpA_signed;\n            signA = '0;\n        end\n        else begin\n            // // Make fuOpA_In plus value when it is minus value. \n            // if (fuOpA_sign) begin\n            //     srcA_signed = -fuOpA_signed;\n            // end\n            // else begin\n            //     srcA_signed = fuOpA_signed;\n            // end\n            signA = '1;\n        end\n\n        if ( (mulCode == AC_MULHU) || (mulCode == AC_MULHSU) ) begin\n            // // MULHU and MULHSU take srcB as unsigned.\n            // srcB_signed = fuOpB_signed;\n            signB = '0;\n        end\n        else begin\n            // // Make fuOpB_In plus value when it is minus value. \n            // if (fuOpB_sign) begin\n            //     srcB_signed = -fuOpB_signed;\n            // end\n            // else begin\n            //     srcB_signed = fuOpB_signed;\n            // end\n            signB = '1;\n        end\n\n        // srcA = srcA_signed;\n        // srcB = srcB_signed;\n        srcA = fuOpA_In;\n        srcB = fuOpB_In;\n    end\n\n    always_comb begin\n        // mulResult_signed = mulResult;\n\n        // case (pipeReg[ PIPELINE_DEPTH-2 ].mulCode)\n        //     AC_MUL, AC_MULH: begin\n        //         if (pipeReg[ PIPELINE_DEPTH-2 ].fuOpA_sign ^ pipeReg[ PIPELINE_DEPTH-2 ].fuOpA_sign) begin\n        //             dataOut_signed = -mulResult_signed;\n        //         end\n        //         else begin\n        //             dataOut_signed = mulResult_signed;\n        //         end\n        //     end\n        //     AC_MULHSU: begin\n        //         if (pipeReg[ PIPELINE_DEPTH-2 ].fuOpA_sign) begin\n        //             dataOut_signed = -mulResult_signed;\n        //         end\n        //         else begin\n        //             dataOut_signed = mulResult_signed;\n        //         end\n        //     end\n        //     AC_MULHU: begin\n        //         dataOut_signed = mulResult_signed;\n        //     end\n        //     default: begin\n        //         dataOut_signed = mulResult_signed;\n        //     end\n        // endcase\n\n        // if ( pipeReg[ PIPELINE_DEPTH-2 ].getUpper ) begin\n        //     dataOut = dataOut_signed[ 2*DATA_WIDTH-1:DATA_WIDTH ];\n        // end\n        // else begin\n        //     dataOut = dataOut_signed[ DATA_WIDTH-1:0 ];\n        // end\n\n        if ( pipeReg[ PIPELINE_DEPTH-2 ].getUpper ) begin\n            dataOut = mulResult[ 2*DATA_WIDTH-1:DATA_WIDTH ];\n        end\n        else begin\n            dataOut = mulResult[ DATA_WIDTH-1:0 ];\n        end\n    end\n    \n    always_ff @(posedge clk) begin\n        if ( stall ) begin\n            for ( int i = 0; i < PIPELINE_DEPTH-1; i++)\n                pipeReg[i] <= pipeReg[i];\n        end\n        else begin\n            pipeReg[0].getUpper <= getUpper;\n            pipeReg[0].mulCode  <= mulCode;\n            pipeReg[0].fuOpA_sign <= fuOpA_sign;\n            pipeReg[0].fuOpB_sign <= fuOpB_sign;\n            for ( int i = 1; i < PIPELINE_DEPTH-1; i++)\n                pipeReg[i] <= pipeReg[i-1];\n        end\n    end\n    \n`ifndef RSD_SYNTHESIS\n    initial begin\n        for ( int i = 0; i < PIPELINE_DEPTH-1; i++)\n            pipeReg[i] <= '0;\n    end\n`endif\n\nendmodule : PipelinedMultiplierUnit\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for updating PC\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\nimport MemoryMapTypes::*;\nimport CacheSystemTypes::*;\nimport FetchUnitTypes::*;\n\n//`define RSD_STOP_FETCH_ON_PRED_MISS\n\n// Detect the cache line boundary in sequential access\nfunction automatic logic StepOverCacheLine (PC_Path pc1, PC_Path pc2);\n    return pc1[ICACHE_LINE_BYTE_NUM_BIT_WIDTH] != pc2[ICACHE_LINE_BYTE_NUM_BIT_WIDTH];\nendfunction\n\nmodule NextPCStage(\n    NextPCStageIF.ThisStage port,\n    FetchStageIF.NextPCStage next,\n    RecoveryManagerIF.NextPCStage recovery,\n    ControllerIF.NextPCStage ctrl,\n    DebugIF.NextPCStage debug\n);\n\n`ifdef RSD_STOP_FETCH_ON_PRED_MISS\n    typedef enum logic {\n        PHASE_FETCH,\n        PHASE_WAIT\n    } Phase;\n\n    parameter PHASE_DELAY = 2;\n    Phase phase[PHASE_DELAY];\n    Phase nextPhase;\n    always_ff @(posedge port.clk) begin\n        if (port.rst) begin\n            for (int i = 0; i < PHASE_DELAY; i++) begin\n                phase[i] <= PHASE_FETCH;\n            end\n        end\n        else if (recovery.toRecoveryPhase || recovery.toCommitPhase) begin\n            for (int i = 0; i < PHASE_DELAY; i++) begin\n                phase[i] <= PHASE_FETCH;\n            end\n        end\n        else begin\n            for (int i = 0; i < PHASE_DELAY - 1; i++) begin\n                phase[i+1] <= phase[i];\n            end\n            phase[0] <= nextPhase;\n        end\n    end\n\n    always_comb begin\n        if (recovery.toRecoveryPhase) begin\n            nextPhase = PHASE_FETCH;\n        end\n        else begin\n\n            nextPhase = phase[0];\n            for (int i = 0; i < INT_ISSUE_WIDTH; i++) begin\n                if (port.brResult[i].valid && port.brResult[i].mispred) begin\n                    nextPhase = PHASE_WAIT;\n                end\n            end\n        end\n    end\n`endif\n\n    // \u30c7\u30d0\u30c3\u30b0\u7528SID\n    // \u5185\u90e8\u4e8b\u60c5\u306b\u3088\u308a\uff0c1 \u304b\u3089\u306f\u3058\u3081\u308b\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpSerial curSID, nextSID;\n    FlipFlop#( .FF_WIDTH(OP_SERIAL_WIDTH), .RESET_VALUE(1) )\n        sidFF(\n            .out( curSID ),\n            .in ( nextSID ),\n            .clk( port.clk ),\n            .rst( port.rst )\n        );\n`endif\n\n    PC_Path predNextPC;\n    FetchStageRegPath nextStage[ FETCH_WIDTH ];\n\n    // Pipeline Control\n    logic stall, clear;\n    logic regStall, beginStall;\n    logic writePC_FromOuter;\n    always_ff @(posedge port.clk) begin\n        if (port.rst) begin\n            regStall <= FALSE;\n        end\n        else begin\n            regStall <= stall;\n        end\n    end\n\n    always_comb begin\n        // Control\n        stall = ctrl.npStage.stall;\n        clear = ctrl.npStage.clear;\n`ifdef RSD_STOP_FETCH_ON_PRED_MISS\n        ctrl.npStageSendBubbleLower =\n            (!recovery.toRecoveryPhase && phase[PHASE_DELAY - 1] == PHASE_WAIT);\n`else\n        ctrl.npStageSendBubbleLower = FALSE;\n`endif\n\n        beginStall = !regStall && stall;\n\n        // Whether PC is written from outside\n        if (recovery.toRecoveryPhase || recovery.recoverFromRename\n                                     || port.interruptAddrWE) begin\n            writePC_FromOuter = TRUE;\n        end\n        else begin\n            writePC_FromOuter = FALSE;\n        end\n        \n        // Update PC if not stalled.\n        // NOTE: Update even during stall in the next cases:\n        //   1) if PC is written from outside\n        //   2) if it is beginning of stall\n        //   (see the comment of regBrPred in FetchStage.sv)\n        port.pcWE = \n            (writePC_FromOuter || !stall || beginStall) && !port.rst;\n    end\n\n\n    //\n    // Branch Prediction\n    //\n    always_comb begin\n\n        // Decide the address to input to the branch predictor\n        if (recovery.toRecoveryPhase) begin\n            // Branch misprediction or an exception etc. is detected\n            // Refetch instruction specified by Rw, Cm stage\n            predNextPC = recovery.recoveredPC_FromRwCommit;\n        end\n        else if (recovery.recoverFromRename) begin\n            // Detect branch misprediction in decode stage\n            predNextPC = recovery.recoveredPC_FromRename;\n        end\n        else begin\n            // Use current PC\n            predNextPC = port.pcOut;\n\n            for (int i = 0; i < FETCH_WIDTH; i++) begin\n                // Process of branch prediction:\n                // If BTB is hit, the instruction is predicted to be a branch. \n                // In addition, if the branch is predicted as Taken, \n                // the address read from BTB is used as next PC.\n                if (!regStall && next.fetchStageIsValid[i] && \n                        next.btbHit[i] && next.brPredTaken[i]) begin\n                    // Use PC from BTB\n                    predNextPC = next.btbOut[i];\n                    break;\n                end\n            end\n        end\n        // To Branch predictor\n        port.predNextPC = predNextPC;\n    end\n\n\n    //\n    //  Updating PC\n    //\n    always_comb begin\n\n        // --- PC\n        if (port.interruptAddrWE) begin\n            // When an interrupt occurs, use interrupt address.\n            // NOTE: This input can be a critical path.\n            // Hence, interrupt address is input to PC first rather than \n            // input to the branch predictor directly.\n            port.pcIn = port.interruptAddrIn;\n        end\n        else if (beginStall) begin\n            // Update PC based on the branch prediction result accessed\n            // immediately before the stall if it is beginning of stall.\n            // (see the comment of regBrPred in FetchStage.sv)\n            port.pcIn = predNextPC;\n        end\n        else begin\n            // Increment PC\n            port.pcIn = predNextPC + FETCH_WIDTH*INSN_BYTE_WIDTH;\n            for (int i = 1; i < FETCH_WIDTH; i++) begin\n                if (StepOverCacheLine(predNextPC, \n                                     predNextPC+i*INSN_BYTE_WIDTH)) begin\n                    // When PC stepped over the border of cache line, stop there\n                    port.pcIn = predNextPC+i*INSN_BYTE_WIDTH;\n                    break;\n                end\n            end\n        end\n\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            // Generate serial id for dumping\n            nextStage[i].sid = curSID + i;\n`endif\n            nextStage[i].pc = predNextPC + i * INSN_BYTE_WIDTH;\n            if (port.interruptAddrWE || clear ||\n                StepOverCacheLine(predNextPC, nextStage[i].pc)) begin\n                nextStage[i].valid = FALSE;\n            end\n            else begin\n                nextStage[i].valid = TRUE;\n            end\n        end\n\n        port.nextStage = nextStage;\n    end\n\n\n    //\n    // I-cache Access\n    //\n    AddrPath fetchAddr;\n    always_comb begin\n        // Decide input address of I-cache\n        if (next.fetchStageIsValid[0] && stall) begin\n            // Use the PC of the IF stage\n            fetchAddr = ToAddrFromPC(next.fetchStagePC[0]);\n        end\n        else begin\n            // Use the PC of this stage\n            fetchAddr = ToAddrFromPC(predNextPC);\n        end\n        \n        // To I-cache\n        port.icNextReadAddrIn = ToPhyAddrFromLogical(fetchAddr);\n    end\n\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    logic [FETCH_WIDTH : 0] numValidInsns;\n    always_comb begin\n        numValidInsns = 0; // Count valid instructions in this stage\n        for (int i = 0; i < FETCH_WIDTH; i++) begin\n            if (!nextStage[i].valid) begin\n                break;\n            end\n            else begin\n                numValidInsns++;\n            end\n        end\n\n        // Update serial ID.\n        nextSID = ( stall || clear) ? \n            curSID : (curSID + numValidInsns);\n\n        // --- Debug Register\n        for ( int i = 0; i < FETCH_WIDTH; i++ ) begin\n            debug.npReg[i].valid = stall ? FALSE : nextStage[i].valid;\n            debug.npReg[i].sid = nextStage[i].sid;\n        end\n    end\n`endif\n\nendmodule : NextPCStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- NextPCStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\nimport FetchUnitTypes::*;\nimport MemoryMapTypes::*;\n\ninterface NextPCStageIF( input logic clk, rst, rstStart );\n    \n    // PC\n    logic    pcWE;\n    PC_Path  pcOut;\n    PC_Path  pcIn;\n\n    PC_Path  predNextPC;\n\n    // Executed branch results for updating a branch predictor.\n    // This signal is written back from a write back stage.\n    BranchResult brResult[ INT_ISSUE_WIDTH ];\n\n    // Interrupt\n    PC_Path interruptAddrIn;\n    logic interruptAddrWE;\n\n    // I-cache\n    PhyAddrPath   icNextReadAddrIn; // Value of icReadAddrIn in next cycle.\n\n    // Pipeline register\n    FetchStageRegPath nextStage[ FETCH_WIDTH ];\n\n    modport PC(\n    input\n        clk, rst, pcWE, pcIn,\n    output\n        pcOut\n    );\n\n    modport ThisStage(\n    input\n        clk,\n        rst,\n        pcOut,\n        brResult,\n        interruptAddrIn,\n        interruptAddrWE,\n    output\n        pcWE,\n        pcIn,\n        predNextPC,\n        icNextReadAddrIn,\n        nextStage\n    );\n\n    modport NextStage(\n    input\n        predNextPC,\n        nextStage\n    );\n\n    modport IntegerRegisterWriteStage(\n    output\n        brResult\n    );\n\n    modport BTB(\n    input\n        clk,\n        rst,\n        rstStart,\n        predNextPC,\n        brResult\n    );\n\n    modport BranchPredictor(\n    input\n        clk,\n        rst,\n        rstStart,\n        predNextPC,\n        brResult\n    );\n\n    modport ICache(\n    input\n        clk,\n        rst,\n        rstStart,\n        icNextReadAddrIn\n    );\n\n    modport InterruptController(\n    input\n        pcOut,\n    output\n        interruptAddrIn,\n        interruptAddrWE\n    );\n\n\nendinterface : NextPCStageIF\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\npackage OpFormatTypes;\n\nimport BasicTypes::*;\n\n// JAL, JALR uses PC+4 as operands\nlocalparam PC_OPERAND_OFFSET = 4;\n\n//\n// --- \u6761\u4ef6\u30b3\u30fc\u30c9\u306e\u5b9a\u7fa9\n//\ntypedef enum logic [2:0]    // enum CondCode\n{\n    COND_EQ  = 3'b000, // EQ  '='\n    COND_NE  = 3'b001, // NE  '!='\n    COND_LT  = 3'b100, // LT  \u7b26\u53f7\u4ed8\u304d'<'\n    COND_GE  = 3'b101, // GE  \u7b26\u53f7\u4ed8\u304d'>'\n    COND_LTU = 3'b110, // LTU \u7b26\u53f7\u306a\u3057'<'\n    COND_GEU = 3'b111, // GEU \u7b26\u53f7\u306a\u3057'>'\n    COND_AL  = 3'b010  // AL \u5e38\u6642\uff08\u7121\u6761\u4ef6\uff09\n} CondCode;\n\n//\n// \u547d\u4ee4\u30bf\u30a4\u30d7 obsolete\n//\ntypedef enum logic [2:0]    // enum OpCode\n{\n    OC_INT_REG = 3'b000,    // \u6574\u6570\u6f14\u7b97\uff08\u30ec\u30b8\u30b9\u30bf\uff09\n    OC_INT_IMM = 3'b001,    // \u6574\u6570\u6f14\u7b97\uff08\u5373\u5024\uff09\n    OC_MEM_IMM = 3'b010,    // \u30ed\u30fc\u30c9/\u30b9\u30c8\u30a2\uff08\u5373\u5024\u30aa\u30d5\u30bb\u30c3\u30c8\u30fb\u30a2\u30c9\u30ec\u30c3\u30b7\u30f3\u30b0\uff09\n    OC_MEM_REG = 3'b011,    // \u30ed\u30fc\u30c9/\u30b9\u30c8\u30a2\uff08\u30ec\u30b8\u30b9\u30bf\u30aa\u30d5\u30bb\u30c3\u30c8\u30fb\u30a2\u30c9\u30ec\u30c3\u30b7\u30f3\u30b0\uff09\n    OC_MEM_MUL = 3'b100,    // \u8907\u6570\u30ed\u30fc\u30c9/\u30b9\u30c8\u30a2\n    OC_BR      = 3'b101        // \u5206\u5c90\n} OpCode;\n\n\n//\n// Op\u547d\u4ee4\u3068OpImm\u547d\u4ee4\u306efunct3\n//\ntypedef enum logic [2:0]    // enum OpFunct3\n{\n    OP_FUNCT3_ADD_SUB   = 3'b000,\n    OP_FUNCT3_SLT       = 3'b010,\n    OP_FUNCT3_SLTU      = 3'b011,\n    OP_FUNCT3_EOR       = 3'b100,\n    OP_FUNCT3_OR        = 3'b110,\n    OP_FUNCT3_AND       = 3'b111,\n    OP_FUNCT3_SLL       = 3'b001,\n    OP_FUNCT3_SRL_SRA   = 3'b101\n} OpFunct3;\n\n//\n// Op\u547d\u4ee4\u306efunct7\n//\ntypedef enum logic [6:0]    // enum OpFunct7\n{\n    OP_FUNCT7_ADD = 7'b0000000,\n    OP_FUNCT7_SUB = 7'b0100000\n} OpFunct7;\n\n//\n// \u30b7\u30d5\u30c8\u547d\u4ee4\u306efunct7\n//\ntypedef enum logic [6:0]    // enum ShiftFunct7\n{\n    SHIFT_FUNCT7_SRL = 7'b0000000,\n    SHIFT_FUNCT7_SRA = 7'b0100000\n} ShiftFunct7;\n\n//\n// RV32M\u306efunct7\n//\ntypedef enum logic [6:0]    // enum RV32MFunct7\n{\n    RV32M_FUNCT7_ALL = 7'b0000001\n} RV32MFunct7;\n\n//\n// \u5206\u5c90\u547d\u4ee4\u306efunct3\n//\ntypedef enum logic [2:0]    // enum BrFunct3\n{\n    BRANCH_FUNCT3_BEQ     = 3'b000,\n    BRANCH_FUNCT3_BNE     = 3'b001,\n    BRANCH_FUNCT3_BLT     = 3'b100,\n    BRANCH_FUNCT3_BGE     = 3'b101,\n    BRANCH_FUNCT3_BLTU    = 3'b110,\n    BRANCH_FUNCT3_BGEU    = 3'b111\n} BrFunct3;\n\n//\n// Mem\u547d\u4ee4\u306efunct3\n//\ntypedef enum logic [2:0]    // enum MemFunct3\n{\n    MEM_FUNCT3_SIGNED_BYTE          = 3'b000,\n    MEM_FUNCT3_SIGNED_HALF_WORD     = 3'b001,\n    MEM_FUNCT3_WORD                 = 3'b010,\n    MEM_FUNCT3_UNSIGNED_BYTE        = 3'b100,\n    MEM_FUNCT3_UNSIGNED_HALF_WORD   = 3'b101\n} MemFunct3;\n\n//\n// RV32M(\u4e57\u7b97\u30fb\u9664\u7b97\u30fb\u5270\u4f59)\u547d\u4ee4\u306efunct3\n//\ntypedef enum logic [2:0]    // enum RV32MFunct3\n{\n    RV32M_FUNCT3_MUL     = 3'b000,\n    RV32M_FUNCT3_MULH    = 3'b001,\n    RV32M_FUNCT3_MULHSU  = 3'b010,\n    RV32M_FUNCT3_MULHU   = 3'b011,\n    RV32M_FUNCT3_DIV     = 3'b100,\n    RV32M_FUNCT3_DIVU    = 3'b101,\n    RV32M_FUNCT3_REM     = 3'b110,\n    RV32M_FUNCT3_REMU    = 3'b111\n} RV32MFunct3;\n\n//\n// Misc-Mem\u547d\u4ee4\u306efunct3\n//\ntypedef enum logic [2:0]    // enum MiscMemFunct3\n{\n    MISC_MEM_FUNCT3_FENCE   = 3'b000, // FENCE\n    MISC_MEM_FUNCT3_FENCE_I = 3'b001  // FENCE.I\n} MiscMemFunct3;\n\n//\n// System \u547d\u4ee4\u306e funct3, funct12\n//\ntypedef enum logic [2:0]    // enum SystemFunct3\n{\n    SYSTEM_FUNCT3_PRIV  = 3'b000,     // Privileged (ecall/ebreak/mret\n\n    SYSTEM_FUNCT3_CSR_RW    = 3'b001, // CSRRW\n    SYSTEM_FUNCT3_CSR_RS    = 3'b010, // CSRRS\n    SYSTEM_FUNCT3_CSR_RC    = 3'b011, // CSRRC\n\n    SYSTEM_FUNCT3_UNDEFINED = 3'b100,  // ???\n\n    SYSTEM_FUNCT3_CSR_RW_I  = 3'b101, // CSRRWI\n    SYSTEM_FUNCT3_CSR_RS_I  = 3'b110, // CSRRSI\n    SYSTEM_FUNCT3_CSR_RC_I  = 3'b111  // CSRRCI\n\n} SystemFunct3;\n\ntypedef enum logic [11:0]    // enum SystemFunct12\n{\n    SYSTEM_FUNCT12_ECALL  = 12'b0000_0000_0000, // ECALL\n    SYSTEM_FUNCT12_EBREAK = 12'b0000_0000_0001, // EBREAK\n    SYSTEM_FUNCT12_MRET   = 12'b0011_0000_0010, // MRET\n    SYSTEM_FUNCT12_WFI    = 12'b0001_0000_0101  // WFI\n} SystemFunct12;\n\ntypedef enum logic [6:0]    // enum RV32FFunct7\n{\n    RV32F_FUNCT7_FADD           = 7'b0000000,\n    RV32F_FUNCT7_FSUB           = 7'b0000100,\n    RV32F_FUNCT7_FMUL           = 7'b0001000,\n    RV32F_FUNCT7_FDIV           = 7'b0001100,\n    RV32F_FUNCT7_FSQRT          = 7'b0101100,\n    RV32F_FUNCT7_FSGNJ          = 7'b0010000,\n    RV32F_FUNCT7_FMIN_FMAX      = 7'b0010100,\n    RV32F_FUNCT7_FCVT_WS        = 7'b1100000,\n    RV32F_FUNCT7_FCLASS_FMV_XW  = 7'b1110000,\n    RV32F_FUNCT7_FEQ_FLT_FLE    = 7'b1010000,\n    RV32F_FUNCT7_FCVT_SW        = 7'b1101000,\n    RV32F_FUNCT7_FMV_WX         = 7'b1111000\n} RV32FFunct7;\n\ntypedef enum logic [2:0]  // enum FSGNJFunct3\n{\n    FSGNJ_FUNCT3_FSGNJ  = 3'b000,\n    FSGNJ_FUNCT3_FSGNJN = 3'b001,\n    FSGNJ_FUNCT3_FSGNJX = 3'b010\n} FSGNJFunct3;\n\ntypedef enum logic [2:0] // enum FMINFMAXFunct3\n{\n    FMIN_FMAX_FUNCT3_FMIN = 3'b000,\n    FMIN_FMAX_FUNCT3_FMAX = 3'b001\n} FMINFMAXFunct3;\n\ntypedef enum logic [4:0] // enum FCVTFunct5\n{\n    FCVT_FUNCT5_SIGNED   = 5'b00000,\n    FCVT_FUNCT5_UNSIGNED = 5'b00001\n} FCVTFunct5;\n\ntypedef enum logic [2:0] // enum FCLASSFMVFunct3\n{\n    FCLASS_FMV_FUNCT3_FMV_XW = 3'b000,\n    FCLASS_FMV_FUNCT3_FCLASS = 3'b001\n} FCLASSFMVFunct3;\n\ntypedef enum logic [2:0] // enum FCMPFunct3\n{\n    FCMP_FEQ = 3'b010,\n    FCMP_FLT = 3'b001,\n    FCMP_FLE = 3'b000\n} FCMPFunct3;\n\ntypedef union packed // RV32FFunct3\n{\n    FSGNJFunct3     fsgnjFunct3;\n    FMINFMAXFunct3  fminfmaxFunct3;\n    FCLASSFMVFunct3 fclassfmvFunct3;\n    FCMPFunct3      fcmpFunct3;\n} RV32FFunct3;\n\n//\n// --- shifter_operand \u306e\u5b9a\u7fa9\n//\n\n\n// Shift operand type\ntypedef enum logic    // enum ShiftOperandType\n{\n    SOT_IMM_SHIFT = 1'b0,   // Immediate shift\n    SOT_REG_SHIFT = 1'b1    // Register shift\n} ShiftOperandType;\n\ntypedef enum logic [1:0]    // enum ShiftType\n{\n    ST_LSL = 2'b00, // Logical shift left\n    ST_LSR = 2'b01, // Logical shift right\n    ST_ASR = 2'b10, // Arithmetic shift right\n    ST_ROR = 2'b11  // Rotate\n} ShiftType;\n\ntypedef enum logic [1:0]    // Imm\n{\n    RISCV_IMM_R    = 2'b00,\n    RISCV_IMM_I    = 2'b01,\n    RISCV_IMM_S    = 2'b10,\n    RISCV_IMM_U    = 2'b11\n} RISCV_ImmType;\n\n\n//\u5373\u5024 : 5+2+1+20+2 = 30 bit \u2192 SHIFTER_WIDTH\ntypedef struct packed    // struct RISCV_IntOperandImmShift\n{\n    logic [4:0] shift;\n    ShiftType   shiftType;\n    logic       isRegShift;\n    logic [19:0] imm;\n    RISCV_ImmType immType;\n} RISCV_IntOperandImmShift;\n\n\n//\n// --- \u30a2\u30c9\u30ec\u30c3\u30b7\u30f3\u30b0\n//\n\n// \u5373\u5024\nlocalparam ADDR_OPERAND_IMM_WIDTH = 12;\nlocalparam ADDR_SIGN_EXTENTION_WIDTH = ADDR_WIDTH - ADDR_OPERAND_IMM_WIDTH;\n\ntypedef struct packed    // struct AddrOperandImm\n{\n    logic [11:0] imm;    // [11:0] offset\n} AddrOperandImm;\n\n\n// Memory Access Mode (signed / access size)\ntypedef enum logic [1:0]\n{\n    MEM_ACCESS_SIZE_BYTE = 2'b00,\n    MEM_ACCESS_SIZE_HALF_WORD = 2'b01,\n    MEM_ACCESS_SIZE_WORD = 2'b10,\n    MEM_ACCESS_SIZE_VEC  = 2'b11\n} MemAccessSizeType;\n\nfunction automatic logic IsMisalignedAddress(input AddrPath addr, input MemAccessSizeType size);\n    if (size == MEM_ACCESS_SIZE_BYTE || size == MEM_ACCESS_SIZE_VEC) begin\n        return FALSE;\n    end\n    else if (size == MEM_ACCESS_SIZE_HALF_WORD) begin\n        return addr[0:0] != 0 ? TRUE : FALSE;\n    end\n    else if (size == MEM_ACCESS_SIZE_WORD) begin\n        return addr[1:0] != 0 ? TRUE : FALSE;\n    end\n    else \n        return FALSE;\nendfunction\n\ntypedef struct packed\n{\n    logic isSigned;\n    MemAccessSizeType size;\n} MemAccessMode;\n\n// \u30c7\u30a3\u30b9\u30d7\u30ec\u30fc\u30b9\u30e1\u30f3\u30c8\u5e45: \u5404\u5206\u5c90\u547d\u4ee4\u306e\u30c7\u30a3\u30b9\u30d7\u30ec\u30fc\u30b9\u30e1\u30f3\u30c8\u306f\u305d\u308c\u305e\u308c\n// Branch: 12\u30d3\u30c3\u30c8\uff0cJAL: 20\u30d3\u30c3\u30c8\uff0c JALR: 12\u30d3\u30c3\u30c8\n// \u306e\u30d3\u30c3\u30c8\u5e45\u3067\u30a8\u30f3\u30b3\u30fc\u30c9\u3055\u308c\u308b\uff0e\nlocalparam BR_DISP_WIDTH = 20;\ntypedef logic [BR_DISP_WIDTH-1:0] BranchDisplacement;\n// \u7b26\u53f7\u62e1\u5f35\u7528\nlocalparam BR_DISP_SIGN_EXTENTION_WIDTH = ADDR_WIDTH - BR_DISP_WIDTH;\n\n\n// ALU code\ntypedef enum logic [3:0]    // enum ALU_Code\n{\n    AC_ADD  = 4'b0000,    // ADD    \u52a0\u7b97\n    AC_SLT  = 4'b0010,    // SLT    \u6bd4\u8f03 Rd = if Rs1 < Rs2 then 1 else 0\n    AC_SLTU = 4'b0011,    // SLTU   \u7b26\u53f7\u306a\u3057\u6bd4\u8f03\n    AC_EOR  = 4'b0100,    // EOR    \u6392\u4ed6\u7684\u8ad6\u7406\u548c\n    AC_ORR  = 4'b0110,    // ORR    \uff08\u5305\u542b\u7684\uff09\u8ad6\u7406\u548c\n    AC_AND  = 4'b0111,    // AND    \u8ad6\u7406\u7a4d\n    AC_SUB  = 4'b0001    // SUB    \u6e1b\u7b97\n} IntALU_Code;\n\n\n// IntMUL code\ntypedef enum logic [1:0]    // enum IntMUL_Code\n{\n    AC_MUL    = 2'b00,    // MUL    \n    AC_MULH   = 2'b01,    // MULH\n    AC_MULHSU = 2'b10,    // MULHSU \n    AC_MULHU  = 2'b11     // MULHU  \n} IntMUL_Code;\n\n\n// IntDIV code\ntypedef enum logic [1:0]    // enum IntDIV_Code\n{\n    AC_DIV    = 2'b00,    // DIV    \n    AC_DIVU   = 2'b01,    // DIVU\n    AC_REM    = 2'b10,    // REM \n    AC_REMU   = 2'b11     // REMU  \n} IntDIV_Code;\n\n// CSR operation code\ntypedef enum logic [1:0]    // enum CSR_Code\n{\n    CSR_UNKNOWN = 2'b00,    // ???\n    CSR_WRITE   = 2'b01,    // WRITE\n    CSR_SET     = 2'b10,    // SET\n    CSR_CLEAR   = 2'b11     // CLEAR\n} CSR_Code;\n\nlocalparam CSR_NUMBER_WIDTH = 12;\ntypedef logic [CSR_NUMBER_WIDTH-1:0] CSR_NumberPath;\n\nlocalparam CSR_IMM_WIDTH = 5;\ntypedef logic [CSR_IMM_WIDTH-1:0] CSR_ImmPath;\n\ntypedef struct packed // 5+1+2=8\n{\n    CSR_ImmPath imm;\n    logic isImm;\n    CSR_Code code;\n} CSR_CtrlPath;\n\n// Environment operation code\ntypedef enum logic [2:0]      // enum ENV_Code\n{\n    ENV_CALL            = 3'b000,    // ECALL\n    ENV_BREAK           = 3'b001,    // EBREAK\n    ENV_MRET            = 3'b010,    // MRET\n    ENV_INSN_ILLEGAL    = 3'b011,    // Executes illegal insturction\n    ENV_INSN_VIOLATION  = 3'b100,    // Insturction access violation\n\n    ENV_UNKNOWN         = 3'b101     //\n} ENV_Code;\n\n// FPU code\ntypedef enum logic [4:0]    // enum FPU_Code\n{\n    FC_ADD      = 5'b00000,\n    FC_SUB      = 5'b00001,\n    FC_MUL      = 5'b00010,\n    FC_DIV      = 5'b00011,\n    FC_SQRT     = 5'b00100,\n    FC_SGNJ     = 5'b00101,\n    FC_SGNJN    = 5'b00110,\n    FC_SGNJX    = 5'b00111,\n    FC_FMIN     = 5'b01000,\n    FC_FMAX     = 5'b01001,\n    FC_FCVT_WS  = 5'b01010,\n    FC_FCVT_WUS = 5'b01011,\n    FC_FMV_XW   = 5'b01100,\n    FC_FEQ      = 5'b01101,\n    FC_FLT      = 5'b01110,\n    FC_FLE      = 5'b01111,\n    FC_FCLASS   = 5'b10000,\n    FC_FCVT_SW  = 5'b10001,\n    FC_FCVT_SWU = 5'b10010,\n    FC_FMV_WX   = 5'b10011,\n    FC_FMADD    = 5'b10100,\n    FC_FMSUB    = 5'b10101,\n    FC_FNMSUB   = 5'b10110,\n    FC_FNMADD   = 5'b10111\n} FPU_Code;\n\n// Rounding mode\ntypedef enum logic [2:0]    // enum Rounding_Mode\n{\n    RM_RNE = 3'b000,    // Round to Nearest, ties to Even\n    RM_RTZ = 3'b001,    // Round towards Zero\n    RM_RDN = 3'b010,    // Round Down (towards -infnity)\n    RM_RUP = 3'b011,    // Round Up (towards +infnity)\n    RM_RMM = 3'b100,    // Round to Nearest, ties to Max Magnitude\n    RM_DYN = 3'b111     // Dynamic Rounding Mode held in frm\n} Rounding_Mode;\n\ntypedef struct packed {\n    logic NV;\n    logic DZ;\n    logic OF;\n    logic UF;\n    logic NX;\n} FFlags_Path;\n\n\n//RISCV Instruction Format\n\n//\n// RISCV \u547d\u4ee4\u30bf\u30a4\u30d7\n//\ntypedef enum logic [6:0]    // enum OpCode\n{\n    RISCV_OP_IMM    = 7'b0010011,\n    RISCV_OP        = 7'b0110011,\n    RISCV_LUI       = 7'b0110111,\n    RISCV_AUIPC     = 7'b0010111,\n    RISCV_JAL       = 7'b1101111,\n    RISCV_JALR      = 7'b1100111,\n    RISCV_BR        = 7'b1100011,\n    RISCV_LD        = 7'b0000011,\n    RISCV_ST        = 7'b0100011,\n    RISCV_MISC_MEM  = 7'b0001111,\n    RISCV_SYSTEM    = 7'b1110011,\n    RISCV_F_OP      = 7'b1010011,\n    RISCV_F_FMADD   = 7'b1000011,\n    RISCV_F_FMSUB   = 7'b1000111,\n    RISCV_F_FNMSUB  = 7'b1001011,\n    RISCV_F_FNMADD  = 7'b1001111,\n    RISCV_F_LD      = 7'b0000111,\n    RISCV_F_ST      = 7'b0100111\n} RISCV_OpCode;\n\n\n// R-Type\ntypedef struct packed\n{\n    logic [6:0]     funct7;     // [31:25] funct7\n    logic [4:0]     rs2;        // [24:20] Rs2\n    logic [4:0]     rs1;        // [19:15] Rs1\n    logic [2:0]     funct3;     // [14:12] funct3\n    logic [4:0]     rd;         // [11: 7] Rd\n    RISCV_OpCode    opCode;     // [ 6: 0] \u547d\u4ee4\u30bf\u30a4\u30d7\n} RISCV_ISF_Common;\n\n// R-Type\ntypedef struct packed\n{\n    logic [6:0]     funct7;     // [31:25] funct7\n    logic [4:0]     rs2;        // [24:20] Rs2\n    logic [4:0]     rs1;        // [19:15] Rs1\n    logic [2:0]     funct3;     // [14:12] funct3\n    logic [4:0]     rd;         // [11: 7] Rd\n    RISCV_OpCode    opCode;     // [ 6: 0] \u547d\u4ee4\u30bf\u30a4\u30d7\n} RISCV_ISF_R;\n\n// I-Type\ntypedef struct packed\n{\n    logic [11:0]    imm;        // [31:20] Imm\n    logic [4:0]     rs1;        // [19:15] Rs1\n    logic [2:0]     funct3;     // [14:12] funct3\n    logic [4:0]     rd;         // [11: 7] Rd\n    RISCV_OpCode    opCode;     // [ 6: 0] \u547d\u4ee4\u30bf\u30a4\u30d7\n} RISCV_ISF_I;\n\n// S-Type\ntypedef struct packed\n{\n    logic [6:0]     imm2;       // [31:25] imm[11:5]\n    logic [4:0]     rs2;        // [24:20] Rs2\n    logic [4:0]     rs1;        // [19:15] Rs1\n    logic [2:0]     funct3;     // [14:12] funct3\n    logic [4:0]     imm1;       // [11: 7] imm[4:0]\n    RISCV_OpCode    opCode;     // [ 6: 0] \u547d\u4ee4\u30bf\u30a4\u30d7\n} RISCV_ISF_S;\n\n// U-Type\ntypedef struct packed\n{\n    logic [19:0]    imm;        // [31:12] imm\n    logic [4:0]     rd;         // [11: 7] Rd\n    RISCV_OpCode    opCode;     // [ 6: 0] \u547d\u4ee4\u30bf\u30a4\u30d7\n} RISCV_ISF_U;\n\n// B-Type \ntypedef struct packed \n{ \n    logic           imm12;      // [31:31] imm[12] \n    logic [5:0]     imm10_5;    // [30:25] imm[10:5] \n    logic [4:0]     rs2;        // [24:20] Rs2 \n    logic [4:0]     rs1;        // [19:15] Rs1 \n    logic [2:0]     funct3;     // [14:12] funct3 \n    logic [3:0]     imm4_1;     // [11:8]  imm[4:1] \n    logic           imm11;      // [7:7]   imm[11] \n    RISCV_OpCode    opCode;     // [ 6: 0] \u547d\u4ee4\u30bf\u30a4\u30d7 \n} RISCV_ISF_B;\n\n// J-Type \ntypedef struct packed \n{ \n    logic           imm20;      // [31:31] imm[20] \n    logic [9:0]     imm10_1;    // [30:21] imm[10:1] \n    logic           imm11;      // [20:20] imm[11] \n    logic [7:0]     imm19_12;   // [19:12] imm[19:12] \n    logic [4:0]     rd;         // [11: 7] Rd \n    RISCV_OpCode    opCode;     // [ 6: 0] \u547d\u4ee4\u30bf\u30a4\u30d7 \n} RISCV_ISF_J;\n\n// MISC-MEM \ntypedef struct packed \n{ \n    logic [3:0] reserved;       // [31:28] reserved\n    logic pi;                   // [27:27] pi\n    logic po;                   // [26:26] po\n    logic pr;                   // [25:25] pr\n    logic pw;                   // [24:24] pw\n    logic si;                   // [23:23] si\n    logic so;                   // [22:22] so\n    logic sr;                   // [21:21] sr\n    logic sw;                   // [20:20] sw\n    logic [4:0]     rs1;        // [19:15] Rs1\n    logic [2:0]     funct3;     // [14:12] funct3\n    logic [4:0]     rd;         // [11: 7] Rd \n    RISCV_OpCode    opCode;     // [ 6: 0] \u547d\u4ee4\u30bf\u30a4\u30d7 \n} RISCV_ISF_MISC_MEM;\n\n// SYSTEM\ntypedef struct packed \n{ \n    logic [11:0]    funct12;    // [31:20] csr\n    logic [4:0]     rs1;        // [19:15] Rs1\n    logic [2:0]     funct3;     // [14:12] funct3\n    logic [4:0]     rd;         // [11: 7] Rd \n    RISCV_OpCode    opCode;     // [ 6: 0] \u547d\u4ee4\u30bf\u30a4\u30d7 \n} RISCV_ISF_SYSTEM;\n\ntypedef struct packed \n{\n    logic [4:0]     rs3;        // [31:27] Rs3\n    logic [1:0]     funct2;     // [26:25] funct2\n    logic [4:0]     rs2;        // [24:20] Rs2\n    logic [4:0]     rs1;        // [19:15] Rs1\n    logic [2:0]     funct3;     // [14:12] funct3\n    logic [4:0]     rd;         // [11: 7] Rd\n    RISCV_OpCode    opCode;     // [ 6: 0] \u547d\u4ee4\u30bf\u30a4\u30d7\n} RISCV_ISF_R4;\n\n\n//\n// ---RISCV\u2192ALUCODE \u306e\u5909\u63db\n//\nfunction automatic void RISCV_DecodeOpImmFunct3(\n    output IntALU_Code aluCode,\n    input OpFunct3 funct3\n);\n    case(funct3)\n        OP_FUNCT3_ADD_SUB : begin  //ADDI\n            aluCode = AC_ADD;\n        end\n        OP_FUNCT3_SLT : begin  //SLTI\n            aluCode = AC_SLT;\n        end\n        OP_FUNCT3_SLTU : begin  //SLTUI\n            aluCode = AC_SLTU;\n        end\n        OP_FUNCT3_EOR : begin  //EORI\n            aluCode = AC_EOR;\n        end\n        OP_FUNCT3_OR : begin  //ORI\n            aluCode = AC_ORR;\n        end\n        OP_FUNCT3_AND : begin  //ANDI\n            aluCode = AC_AND;\n        end\n        OP_FUNCT3_SLL : begin //SLLI\n            aluCode = AC_AND;\n        end\n        OP_FUNCT3_SRL_SRA : begin //SRLI, SRAI\n            aluCode = AC_AND;\n        end\n        default : begin\n            aluCode = AC_AND; \n        end\n    endcase // funct3\nendfunction\n\nfunction automatic void RISCV_DecodeOpFunct3(\n    output IntALU_Code aluCode,\n    input OpFunct3 funct3,\n    input OpFunct7 funct7\n);\n    case(funct3)\n        OP_FUNCT3_ADD_SUB : begin  //ADD or SUB\n            if(funct7==OP_FUNCT7_ADD) begin\n                aluCode = AC_ADD;\n            end else begin\n                aluCode = AC_SUB;\n            end\n        end\n        OP_FUNCT3_SLT : begin  //SLT\n            aluCode = AC_SLT;\n        end\n        OP_FUNCT3_SLTU : begin  //SLTU\n            aluCode = AC_SLTU;\n        end\n        OP_FUNCT3_EOR : begin  //EOR\n            aluCode = AC_EOR;\n        end\n        OP_FUNCT3_OR : begin  //OR\n            aluCode = AC_ORR;\n        end\n        OP_FUNCT3_AND : begin  //AND\n            aluCode = AC_AND;\n        end\n        OP_FUNCT3_SLL : begin //SLL\n            aluCode = AC_AND;\n        end\n        OP_FUNCT3_SRL_SRA : begin //SRL, SRA\n            aluCode = AC_AND;\n        end\n        default : begin\n            aluCode = AC_AND;\n        end\n    endcase // funct3\nendfunction\n\n\n//\n// ---RISCV\u2192ConditionCode \u306e\u5909\u63db\n//      ConditionCode\u306fARM\u306e\u3082\u306e\u3092\u5909\u66f4\u3057\u3066\u4f7f\u3046\nfunction automatic void RISCV_DecodeBrFunct3(\n    output CondCode condCode,\n    input BrFunct3 funct3\n);\n    case(funct3)\n        BRANCH_FUNCT3_BEQ : begin  //BEQ\n            condCode = COND_EQ;\n        end\n        BRANCH_FUNCT3_BNE : begin  //BNE\n            condCode = COND_NE;\n        end\n        BRANCH_FUNCT3_BLT : begin  //BLT\n            condCode = COND_LT;\n        end\n        BRANCH_FUNCT3_BGE : begin  //BGE\n            condCode = COND_GE;\n        end\n        BRANCH_FUNCT3_BLTU : begin  //BLTU\n            condCode = COND_LTU;\n        end\n        BRANCH_FUNCT3_BGEU : begin  //BGEU\n            condCode = COND_GEU;\n        end\n        default : begin\n            condCode = COND_AL;\n        end\n    endcase // funct3\nendfunction\n\n//\n// ---LD/ST \u306e\u30b5\u30a4\u30ba\u306e\u5909\u63db\n//\nfunction automatic void RISCV_DecodeMemAccessMode(\n    output MemAccessMode memAccessMode,\n    input MemFunct3 funct3\n);\n    case(funct3)\n        MEM_FUNCT3_SIGNED_BYTE : begin  //LB, SB\n            memAccessMode.isSigned = TRUE;\n            memAccessMode.size = MEM_ACCESS_SIZE_BYTE;\n        end\n        MEM_FUNCT3_SIGNED_HALF_WORD : begin  //LH, SH\n            memAccessMode.isSigned = TRUE;\n            memAccessMode.size = MEM_ACCESS_SIZE_HALF_WORD;\n        end\n        MEM_FUNCT3_WORD : begin  //LW, SW\n            memAccessMode.isSigned = TRUE;\n            memAccessMode.size = MEM_ACCESS_SIZE_WORD;\n        end\n        MEM_FUNCT3_UNSIGNED_BYTE : begin  //LBU\n            memAccessMode.isSigned = FALSE;\n            memAccessMode.size = MEM_ACCESS_SIZE_BYTE;\n        end\n        MEM_FUNCT3_UNSIGNED_HALF_WORD : begin  //LHU\n            memAccessMode.isSigned = FALSE;\n            memAccessMode.size = MEM_ACCESS_SIZE_HALF_WORD;\n        end\n        default : begin  //WORD\n            memAccessMode.isSigned = TRUE;\n            memAccessMode.size = MEM_ACCESS_SIZE_BYTE;\n        end\n    endcase\nendfunction\n\nfunction automatic void RISCV_DecodeComplexOpFunct3(\n    output IntMUL_Code mulCode,\n    output IntDIV_Code divCode,\n    input RV32MFunct3 funct3\n);\n    case(funct3)\n        RV32M_FUNCT3_MUL : begin  //ADD or SUB\n            mulCode = AC_MUL;\n            divCode = AC_DIV;\n        end\n        RV32M_FUNCT3_MULH : begin  //SLT\n            mulCode = AC_MULH;\n            divCode = AC_DIV;\n        end\n        RV32M_FUNCT3_MULHSU : begin  //SLTU\n            mulCode = AC_MULHSU;\n            divCode = AC_DIV;\n        end\n        RV32M_FUNCT3_MULHU : begin  //EOR\n            mulCode = AC_MULHU;\n            divCode = AC_DIV;\n        end\n        RV32M_FUNCT3_DIV : begin  //OR\n            mulCode = AC_MUL;\n            divCode = AC_DIV;\n        end\n        RV32M_FUNCT3_DIVU : begin  //AND\n            mulCode = AC_MUL;\n            divCode = AC_DIVU;\n        end\n        RV32M_FUNCT3_REM : begin //SLL\n            mulCode = AC_MUL;\n            divCode = AC_REM;\n        end\n        RV32M_FUNCT3_REMU : begin //SRL, SRA\n            mulCode = AC_MUL;\n            divCode = AC_REMU;\n        end\n        default : begin\n            mulCode = AC_MUL;\n            divCode = AC_DIV;\n        end\n    endcase // funct3\nendfunction\n\n//\n// brDisp\u306e\u30c7\u30b3\u30fc\u30c9\n//\nfunction automatic "}
{"text": "BranchDisplacement GetBranchDisplacement(\n    input RISCV_ISF_B isfBr\n);\n    return\n    {\n        {9{isfBr.imm12}},   // 9 bits sign extention\n        isfBr.imm11,    // 1 bits\n        isfBr.imm10_5,  // 6 bits\n        isfBr.imm4_1    // 4 bits\n    };\nendfunction\n\nfunction automatic BranchDisplacement GetJAL_Target(\n    input RISCV_ISF_J isfJAL\n);\n    return\n    {\n        isfJAL.imm20,    //  1 bits\n        isfJAL.imm19_12, //  8 bits\n        isfJAL.imm11,    //  1 bits\n        isfJAL.imm10_1   // 10 bits\n    };\nendfunction\n\nfunction automatic BranchDisplacement GetJALR_Target(\n    input RISCV_ISF_I isfJALR\n);\n    return\n    {\n        {8{isfJALR.imm[11]}},   // 8 bits sign extention\n        isfJALR.imm             // 12 bits\n    };\nendfunction\n\n//\n// signed extention\n//\nfunction automatic logic [19:0] ShamtExtention(\n    input RISCV_ISF_R isfR\n);\n    return { 15'h0, isfR.rs2 };\nendfunction\n\nfunction automatic logic [19:0] I_TypeImmExtention(\n    input RISCV_ISF_I isfI\n);\n    return { {8{isfI.imm[11]}}, isfI.imm };\nendfunction\n\nfunction automatic AddrPath ExtendBranchDisplacement(\n    input BranchDisplacement brDisp\n);\n    return\n    {\n        { (ADDR_WIDTH-BR_DISP_WIDTH-1){brDisp[BR_DISP_WIDTH-1]} },\n        brDisp,\n        1'b0\n    };\nendfunction\n\nfunction automatic AddrPath ExtendJALR_Target(\n    input BranchDisplacement brDisp\n);\n    return\n    {\n        { (ADDR_WIDTH-BR_DISP_WIDTH){brDisp[BR_DISP_WIDTH-1]} },\n        brDisp\n    };\nendfunction\n\n\nfunction automatic AddrPath AddJALR_TargetOffset(    \n    input AddrPath data, input BranchDisplacement disp\n);\n    AddrPath target;\n    target = data + ExtendJALR_Target(disp);\n    target[0] = 1'b0;   // Mask the LSB\n    return target;\nendfunction\n\nfunction automatic void RISCV_DecodeFPOpFunct3(\n    output FPU_Code fpuCode,\n    input RV32FFunct3 rv32ffunct3,\n    input RV32FFunct7 rv32ffunct7,\n    input FCVTFunct5  fcvtfunct5\n);\n    case(rv32ffunct7)\n        RV32F_FUNCT7_FADD : begin\n            fpuCode = FC_ADD;\n        end\n        RV32F_FUNCT7_FSUB : begin\n            fpuCode = FC_SUB;\n        end\n        RV32F_FUNCT7_FMUL : begin\n            fpuCode = FC_MUL;\n        end\n        RV32F_FUNCT7_FDIV : begin\n            fpuCode = FC_DIV;\n        end\n        RV32F_FUNCT7_FSQRT : begin\n            fpuCode = FC_SQRT;\n        end\n        RV32F_FUNCT7_FSGNJ : begin\n            //Todo: \u3053\u3053\u306bfpType\u306e\u4ee3\u5165\u304b\u3051\u308b\u306e\u304b\n            case (rv32ffunct3.fsgnjFunct3)\n                FSGNJ_FUNCT3_FSGNJ : begin\n                    fpuCode = FC_SGNJ;\n                end\n                FSGNJ_FUNCT3_FSGNJN : begin\n                    fpuCode = FC_SGNJN;\n                end\n                FSGNJ_FUNCT3_FSGNJX : begin\n                    fpuCode = FC_SGNJX;\n                end\n                default: begin\n                    fpuCode = FC_SGNJX;\n                end\n            endcase\n        end\n        RV32F_FUNCT7_FMIN_FMAX : begin\n            if (rv32ffunct3.fminfmaxFunct3 == FMIN_FMAX_FUNCT3_FMIN) begin\n                fpuCode = FC_FMIN;\n            end\n            else begin\n                fpuCode = FC_FMAX;\n            end\n        end\n        RV32F_FUNCT7_FCVT_WS : begin\n            if (fcvtfunct5 == FCVT_FUNCT5_SIGNED) begin\n                fpuCode = FC_FCVT_WS;\n            end\n            else begin\n                fpuCode = FC_FCVT_WUS;\n            end\n        end\n        RV32F_FUNCT7_FCLASS_FMV_XW : begin\n            if (rv32ffunct3.fclassfmvFunct3 == FCLASS_FMV_FUNCT3_FCLASS) begin\n                fpuCode = FC_FCLASS;\n            end\n            else begin\n                fpuCode = FC_FMV_XW;\n            end\n        end\n        RV32F_FUNCT7_FEQ_FLT_FLE : begin\n            case(rv32ffunct3.fcmpFunct3)\n                FCMP_FEQ : begin\n                    fpuCode = FC_FEQ;\n                end\n                FCMP_FLT : begin\n                    fpuCode = FC_FLT;\n                end\n                FCMP_FLE : begin\n                    fpuCode = FC_FLE;\n                end\n                default: begin\n                    fpuCode = FC_FLE;\n                end\n            endcase\n        end\n        RV32F_FUNCT7_FCVT_SW : begin\n            if (fcvtfunct5 == FCVT_FUNCT5_SIGNED) begin\n                fpuCode = FC_FCVT_SW;\n            end\n            else begin\n                fpuCode = FC_FCVT_SWU;\n            end\n        end\n        RV32F_FUNCT7_FMV_WX : begin\n            fpuCode = FC_FMV_WX;\n        end\n        default: begin\n            fpuCode = FC_FMV_WX;\n        end\n    endcase\nendfunction\n\nfunction automatic void RISCV_DecodeFPFMAOpFunct3(\n    output FPU_Code fpuCode,\n    input RISCV_OpCode opCode\n);\n    case (opCode)\n        RISCV_F_FMADD : begin\n            fpuCode = FC_FMADD;\n        end\n        RISCV_F_FMSUB : begin\n            fpuCode = FC_FMSUB;\n        end\n        RISCV_F_FNMSUB : begin\n            fpuCode = FC_FNMSUB;\n        end\n        RISCV_F_FNMADD : begin\n            fpuCode = FC_FNMADD;\n        end\n        default: begin\n            fpuCode = FC_FMADD;\n        end\n    endcase\nendfunction\n\nendpackage\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// PC\n// PC has INSN_RESET_VECTOR and cannot use AddrReg.\n//\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\n\nmodule PC( NextPCStageIF.PC port );\n    \n    FlipFlopWE#( PC_WIDTH, INSN_RESET_VECTOR ) \n        body( \n            .out( port.pcOut ), \n            .in ( port.pcIn ),\n            .we ( port.pcWE ), \n            .clk( port.clk ),\n            .rst( port.rst )\n        );\n        \nendmodule : PC\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n`ifndef RSD_DISABLE_PERFORMANCE_COUNTER\n\nimport BasicTypes::*;\nimport DebugTypes::*;\n\nmodule PerformanceCounter (\n    PerformanceCounterIF.PerformanceCounter port,\n    DebugIF.PerformanceCounter debug\n);\n    PerfCounterPath cur, next;\n    always_ff @(posedge port.clk) begin\n        cur <= port.rst ? '0 : next;\n    end\n    \n    always_comb begin\n        next = cur;\n        for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin\n            if (port.loadMiss[i]) begin\n                next.numLoadMiss++;\n            end\n        end\n        for ( int i = 0; i < STORE_ISSUE_WIDTH; i++ ) begin\n            if (port.storeMiss[i]) begin\n                next.numStoreMiss++;\n            end\n        end\n        next.numIC_Miss += port.icMiss ? 1 : 0;\n        next.numStoreLoadForwardingFail += port.storeLoadForwardingFail ? 1 : 0;\n        next.numMemDepPredMiss += port.memDepPredMiss ? 1 : 0;\n        next.numBranchPredMiss += port.branchPredMiss ? 1 : 0;\n        next.numBranchPredMissDetectedOnDecode += port.branchPredMissDetectedOnDecode ? 1 : 0;\n\n        port.perfCounter = cur;  // Export current values\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        debug.perfCounter = next;    // Export next values for updating registers in debug\n`endif\n    end\n    \n\nendmodule : PerformanceCounter\n\n`else\n\nmodule PerformanceCounter (\n    PerformanceCounterIF.PerformanceCounter port\n);\n    always_comb begin\n        port.perfCounter = '0; // Suppressing warning.\n    end\nendmodule : PerformanceCounter\n\n`endif\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- PerformanceCounterIF\n//\n\nimport BasicTypes::*;\nimport DebugTypes::*;\n\ninterface PerformanceCounterIF( input logic clk, rst );\n    \n`ifndef RSD_DISABLE_PERFORMANCE_COUNTER\n    \n    // Hardware counter exported to CSR\n    PerfCounterPath perfCounter;\n    \n    // I Cache misses\n    logic icMiss;\n\n    // D cache misses\n    logic loadMiss[LOAD_ISSUE_WIDTH];\n    logic storeMiss[STORE_ISSUE_WIDTH];\n    \n    // Speculative memory access\n    logic storeLoadForwardingFail;\n    logic memDepPredMiss;\n\n    // Branch prediction miss\n    logic branchPredMiss;\n    logic branchPredMissDetectedOnDecode;\n    \n    modport PerformanceCounter (\n    input\n        clk,\n        rst,\n        icMiss,\n        loadMiss,\n        storeMiss,\n        storeLoadForwardingFail,\n        memDepPredMiss,\n        branchPredMiss,\n        branchPredMissDetectedOnDecode,\n    output\n        perfCounter\n    );\n\n    modport FetchStage(\n    output\n        icMiss\n    );\n\n    modport DecodeStage(\n    output\n        branchPredMissDetectedOnDecode\n    );\n\n    modport MemoryTagAccessStage (\n    output\n        loadMiss\n    );\n    \n    modport RecoveryManager (\n    output\n        storeLoadForwardingFail,\n        memDepPredMiss,\n        branchPredMiss\n    );\n\n    modport StoreCommitter (\n    output\n        storeMiss\n    );\n\n    modport CSR (\n    input\n        perfCounter\n    );\n`else\n    // Dummy to suppress warning.\n    PerfCounterPath perfCounter;\n\n    modport PerformanceCounter (\n    input\n        clk,\n    output\n        perfCounter\n    );\n    \n    modport FetchStage(input clk);\n    modport DecodeStage(input clk);\n    modport LoadStoreUnit(input clk);\n    modport MemoryTagAccessStage(input clk);\n    modport RecoveryManager(input clk);\n    modport CSR(input clk);\n    modport StoreCommitter(input clk);\n`endif\n\n\nendinterface : PerformanceCounterIF\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- Pipelined Reference Divider Unit\n// This unit performs signed/unsigned divisiton with arbitrary cycles\n//\n\nimport BasicTypes::*;\n \nmodule PipelinedRefDivider # (\n    parameter BIT_WIDTH = 32,\n    parameter PIPELINE_DEPTH = 3\n)(\ninput\n    logic clk,         // clock, reset\n    //logic req,              // request a new operation\n    logic stall,\n    DataPath dividend,\n    DataPath divisor,\n    logic isSigned,          // operation is performed in a singed mode\noutput\n    //logic finished,\n    DataPath quotient,\n    DataPath remainder\n);\n\n    parameter DATA_MINUS_ONE = (1 << DATA_WIDTH) - 1;\n    parameter DATA_MINIMUM = (1 << (DATA_WIDTH - 1));\n\n    typedef enum logic[1:0]\n    {\n        PHASE_FINISHED = 0,     // Division is finished. It outputs results to quotient, remainder \n        PHASE_PROCESSING = 1,   // In processing\n        PHASE_COMPENSATING = 2,  // In processing for compensating results\n        PHASE_NOTHING_TO_DO = 3\n    } Phase;\n    Phase regPhase, nextPhase;\n\n\n    typedef struct packed { // PipeReg\n        DataPath dividend;\n        DataPath divisor;\n        logic isSigned;          // operation is performed in a singed mode\n        DataPath quotient;\n        DataPath remainder;\n        Phase phase;\n    } PipeReg;\n\n    PipeReg pipeReg[ PIPELINE_DEPTH-1 ], nextReg;\n\n    always_ff @(posedge clk) begin\n        if (!stall) begin \n            pipeReg[0] <= nextReg;\n            for ( int i = 1; i < PIPELINE_DEPTH-1; i++) begin\n                pipeReg[i] <= pipeReg[i-1];\n            end\n        end\n    end\n\n\n    always_comb begin\n        //finished = (pipeReg[PIPELINE_DEPTH-2].phase == PHASE_FINISHED) ? TRUE : FALSE;\n        quotient = pipeReg[PIPELINE_DEPTH-2].quotient;\n        remainder = pipeReg[PIPELINE_DEPTH-2].remainder;\n\n        //if (req) begin\n            // A request is accepted regardless of the current phase\n            nextReg.dividend = dividend;\n            nextReg.divisor = divisor;\n            nextReg.isSigned = isSigned;\n\n            if (divisor == 0) begin\n                // Division by zero\n                nextReg.quotient = -1;\n                nextReg.remainder = dividend;\n            end\n            else begin\n                if (!isSigned) begin\n                    if (dividend == DATA_MINIMUM && divisor == DATA_MINUS_ONE) begin\n                        // Sigined division can cause overflow\n                        // ex. 8 bits signed division \"-0x80 / -1 = 0x80\"\n                        // causes overflow because the resulst 0x80 > 0x7f\n                        nextReg.quotient = dividend;\n                        nextReg.remainder = '0;\n                    end\n                    else begin\n                        nextReg.quotient = $signed(dividend) / $signed(divisor);\n                        nextReg.remainder = $signed(dividend) % $signed(divisor);\n                    end\n                end\n                else begin\n                    nextReg.quotient = dividend / divisor;\n                    nextReg.remainder = dividend % divisor;\n                end\n            end\n            nextReg.phase = PHASE_FINISHED;\n        /*end\n        else begin \n            nextReg.dividend = '0;\n            nextReg.divisor = '0;\n            nextReg.isSigned = '0;\n            nextReg.quotient = '0;\n            nextReg.remainder = '0;\n            nextReg.phase = PHASE_NOTHING_TO_DO;\n        end*/\n    end\n\n\n`ifndef RSD_SYNTHESIS\n    initial begin\n        for ( int i = 0; i < PIPELINE_DEPTH-1; i++)\n            pipeReg[i] <= '0;\n    end\n`endif\n\nendmodule : PipelinedRefDivider\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// ---Pipeline Registers\n//\n\npackage PipelineTypes;\n\nimport MicroOpTypes::*;\nimport BasicTypes::*;\nimport OpFormatTypes::*;\nimport BypassTypes::*;\nimport RenameLogicTypes::*;\nimport LoadStoreUnitTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport FetchUnitTypes::*;\nimport MemoryMapTypes::*;\nimport CacheSystemTypes::*;\n\n// Controll of a pipeline\n// See comments in Controller\ntypedef struct packed// struct PipelineControll\n{\n    logic stall;\n    logic clear;\n} PipelineControll;\n\n\n// For Recovery\n// Phase of a pipeline\n// See code of RecoveryManager.sv\ntypedef enum logic[1:0]\n{\n    PHASE_COMMIT = 0,\n    PHASE_RECOVER_0 = 1,    // The first cycle of a recovery phase.\n    PHASE_RECOVER_1 = 2\n} PipelinePhase;\n\n// Exception Type\ntypedef enum logic [2:0] { // RefetchType\n    // Re-fetch starts from the PC of an instruction that causes an exception.\n    // This re-fetch occurs on store-load-forwarding miss when a load attempts \n    // to read data whose range is outside the range of the stored data.\n    // It is determined in MemoryTagAccessStage.\n    REFETCH_TYPE_THIS_PC                = 3'b000,   \n\n    // Re-fetch starts from the next PC of an instruction that causes an exception.\n    // This re-fetch occurs on a load speculation miss when a load speculatively \n    // reads a value before the dependent store is executed (memAccessOrderViolation).\n    // Is is determined in MemoryTagAccessStage.\n    REFETCH_TYPE_NEXT_PC                = 3'b001,\n    REFETCH_TYPE_STORE_NEXT_PC          = 3'b010,\n\n    // Re-fetch from a correct branch target.\n    // This re-fetch occurs on a branch prediction miss.\n    REFETCH_TYPE_BRANCH_TARGET          = 3'b011,\n\n    // Re-fetch from a PC specified by CSR.\n    // This refetch occurs on a trap or an exception.\n    REFETCH_TYPE_NEXT_PC_TO_CSR_TARGET  = 3'b100,\n    REFETCH_TYPE_THIS_PC_TO_CSR_TARGET  = 3'b101\n} RefetchType;\n\n//\n// Pipeline registers.\n// These registers put at the head of each stage.\n// For example, DecodeStageRegPath is put at the head of a decode stage, and\n// they are written by a fetch stage.\n//\n\ntypedef struct packed { // FetchStageRegPath\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpSerial sid;\n`endif\n    logic valid;\n    PC_Path pc;\n} FetchStageRegPath;\n\ntypedef struct packed // PreDecodeStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpSerial sid;\n`endif\n\n    logic    valid;     // Valid flag. If this is 0, this op is treated as NOP.\n    InsnPath insn;      // Instruction code\n    PC_Path pc;\n    BranchPred brPred;\n} PreDecodeStageRegPath;\n\ntypedef struct packed // DecodeStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpSerial sid;\n`endif\n\n    logic    valid;     // Valid flag. If this is 0, this op is treated as NOP.\n    InsnPath insn;      // Instruction code\n    PC_Path pc;\n    BranchPred brPred;\n\n    OpInfo [MICRO_OP_MAX_NUM-1:0] microOps;  // Decoded micro ops\n    InsnInfo insnInfo;   // Whether a decoded instruction is branch or not.\n} DecodeStageRegPath;\n\n\ntypedef struct packed // RenameStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic    valid;     // Valid flag. If this is 0, this op is treated as NOP.\n    OpInfo   opInfo;    // Decoded micro op.\n    PC_Path pc;\n    BranchPred bPred;\n} RenameStageRegPath;\n\ntypedef struct packed // DispatchStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic    valid;     // Valid flag. If this is 0, this op is treated as NOP.\n    OpInfo   opInfo;    // Decoded micro op.\n\n    PC_Path pc;        // Program counter\n    BranchPred brPred;  // Branch prediction result.\n\n    // Renamed physical register numbers.\n    PRegNumPath phySrcRegNumA;\n    PRegNumPath phySrcRegNumB;\n`ifdef RSD_MARCH_FP_PIPE\n    PRegNumPath phySrcRegNumC;\n`endif\n    PRegNumPath phyDstRegNum;\n    PRegNumPath phyPrevDstRegNum;  // For releasing a register.\n\n    // Source pointer for a matrix scheduler.\n    IssueQueueIndexPath srcIssueQueuePtrRegA;\n    IssueQueueIndexPath srcIssueQueuePtrRegB;\n`ifdef RSD_MARCH_FP_PIPE\n    IssueQueueIndexPath srcIssueQueuePtrRegC;\n`endif\n\n    IssueQueueIndexPath issueQueuePtr;\n    ActiveListIndexPath activeListPtr;\n    LoadQueueIndexPath loadQueuePtr;\n    StoreQueueIndexPath storeQueuePtr;\n    LoadQueueIndexPath loadQueueRecoveryPtr;\n    StoreQueueIndexPath storeQueueRecoveryPtr;\n} DispatchStageRegPath;\n\ntypedef struct packed // IssueStageRegPath\n{\n    logic    valid;     // Valid flag. If this is 0, this op is treated as NOP.\n    IssueQueueIndexPath issueQueuePtr;\n} IssueStageRegPath;\n\n//\n// Integer back end\n//\ntypedef struct packed // IntegerRegisterReadStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic valid;     // Valid flag. If this is 0, its op is treated as NOP.\n    IntIssueQueueEntry intQueueData;\n} IntegerRegisterReadStageRegPath;\n\n\ntypedef struct packed // IntegerExecutionStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic valid;      // Valid flag. If this is 0, its op is treated as NOP.\n    IntIssueQueueEntry intQueueData;\n\n    // register read out\n    PRegDataPath operandA;\n    PRegDataPath operandB;\n\n    // Bypass control\n    BypassControll bCtrl;\n} IntegerExecutionStageRegPath;\n\n\ntypedef struct packed // IntegerRegisterWriteStageRegPath\n{\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic valid;  // Valid flag. If this is 0, its op is treated as NOP.\n    IntIssueQueueEntry intQueueData;\n\n    PRegDataPath dataOut;   // Result of ALU/shifter/Load\n\n    logic brMissPred;\n    BranchResult brResult;  // Result of branch\n} IntegerRegisterWriteStageRegPath;\n\n//\n// ComplexInteger back end\n//\ntypedef struct packed // ComplexIntegerRegisterReadStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic valid;     // Valid flag. If this is 0, its op is treated as NOP.\n    logic replay;\n    ComplexIssueQueueEntry complexQueueData;\n} ComplexIntegerRegisterReadStageRegPath;\n\n\ntypedef struct packed // ComplexIntegerExecutionStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic valid;      // Valid flag. If this is 0, its op is treated as NOP.\n    logic replay;\n    logic isFlushed;\n    ComplexIssueQueueEntry complexQueueData;\n\n    // register read out\n    PRegDataPath operandA;\n    PRegDataPath operandB;\n\n    // Bypass control\n    BypassControll bCtrl;\n} ComplexIntegerExecutionStageRegPath;\n\n\ntypedef struct packed // ComplexIntegerRegisterWriteStageRegPath\n{\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic valid;  // Valid flag. If this is 0, its op is treated as NOP.\n    ComplexIssueQueueEntry complexQueueData;\n\n    PRegDataPath dataOut;   // Result of Execution\n} ComplexIntegerRegisterWriteStageRegPath;\n\n\n//\n// Memory back end\n//\ntypedef struct packed // MemoryRegisterReadStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic valid;     // Valid flag. If this is 0, its op is treated as NOP.\n    MemIssueQueueEntry memQueueData;\n\n    // For release of the entries of an issue queue. See comments in MemoryExecutionStage.\n    IssueQueueIndexPath issueQueuePtr;\n    logic replay;\n} MemoryRegisterReadStageRegPath;\n\n\ntypedef struct packed // MemoryExecutionStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic valid;      // Valid flag. If this is 0, its op is treated as NOP.\n    MemIssueQueueEntry memQueueData;\n\n    // register read out\n    PRegDataPath operandA;\n    PRegDataPath operandB;\n\n    // Bypass control\n    BypassControll bCtrl;\n\n    // For release of the entries of an issue queue. See comments in MemoryExecutionStage.\n    IssueQueueIndexPath issueQueuePtr;\n    logic replay;\n\n} MemoryExecutionStageRegPath;\n\n\ntypedef struct packed // MemoryTagAccessStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic valid;      // Valid flag. If this is 0, its op is treated as NOP.\n    MemIssueQueueEntry memQueueData;\n\n    logic condEnabled;      // \u6761\u4ef6\u30b3\u30fc\u30c9\u306f\u6709\u52b9\u304b\n    logic regValid;         // Whether source operands are valid or not.\n\n    DataPath addrOut;       // The result of address calculation.\n    DataPath dataIn;        // The input data for store or CSR data out\n    MemoryMapType memMapType;  // Memory map type: mem/io\n    PhyAddrPath phyAddrOut;\n\n} MemoryTagAccessStageRegPath;\n\n\ntypedef struct packed // MemoryAccessStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic    valid;      // Valid flag. If this is 0, its op is treated as NOP.\n\n    logic isStore;\n    logic isLoad;\n    logic isCSR;\n    logic isDiv;\n    logic isMul;\n    OpDst opDst;\n\n    ActiveListIndexPath activeListPtr;  // Use to write recovery reg\n    LoadQueueIndexPath loadQueueRecoveryPtr;\n    StoreQueueIndexPath storeQueueRecoveryPtr;\n    AddrPath pc;\n\n    logic regValid;             // Whether source operands are valid or not.\n    ExecutionState execState;   // Execution status. See RenameLogicTypes.sv\n    \n    AddrPath addrOut;    // The result of address calculation.\n    MemoryMapType memMapType;  // Memory map type: mem/io\n    PhyAddrPath phyAddrOut;    // The result of address calculation.\n    \n    // CSR data out. csrDataOut is from dataIn in MemoryTagAccessStageRegPath\n    // TODO: addrOut and csrDataOut is exclusively used, these can be unified.\n    DataPath csrDataOut; \n\n    logic hasAllocatedMSHR; // This op allocated an MSHR entry or not\n    MSHR_IndexPath mshrID;\n    logic storeForwardMiss;      // Store-load forwarding miss occurs\n} MemoryAccessStageRegPath;\n\n\ntypedef struct packed // MemoryRegisterWriteStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic    valid;     // Valid flag. If this is 0, its op is treated as NOP.\n    ActiveListIndexPath activeListPtr;\n    LoadQueueIndexPath loadQueueRecoveryPtr;\n    StoreQueueIndexPath storeQueueRecoveryPtr;\n    AddrPath pc;\n    AddrPath addrOut;\n\n    OpDst    opDst;\n    ExecutionState execState; // Execution status. See RenameLogicTypes.sv\n    logic isStore;\n    logic isLoad;\n\n    PRegDataPath dataOut;    // Result of Load\n\n    logic hasAllocatedMSHR; // This op allocated an MSHR entry or not\n    MSHR_IndexPath mshrID;\n    logic storeForwardMiss;      // Store-load forwarding miss occurs\n} MemoryRegisterWriteStageRegPath;\n\n//\n// FP back end\n//\ntypedef struct packed // FPRegisterReadStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic valid;     // Valid flag. If this is 0, its op is treated as NOP.\n    logic replay;\n    FPIssueQueueEntry fpQueueData;\n} FPRegisterReadStageRegPath;\n\n\ntypedef struct packed // FPExecutionStageRegPath\n{\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic valid;      // Valid flag. If this is 0, its op is treated as NOP.\n    logic replay;\n    logic isFlushed;\n    FPIssueQueueEntry fpQueueData;\n\n    // register read out\n    PRegDataPath operandA;\n    PRegDataPath operandB;\n    PRegDataPath operandC;\n\n    // Bypass control\n    BypassControll bCtrl;\n} FPExecutionStageRegPath;\n\n\ntypedef struct packed // FPRegisterWriteStageRegPath\n{\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    OpId      opId;\n`endif\n\n    logic valid;  // Valid flag. If this is 0, its op is treated as NOP.\n    FPIssueQueueEntry fpQueueData;\n\n    PRegDataPath dataOut;   // Result of Execution\n    FFlags_Path fflagsOut;\n} FPRegisterWriteStageRegPath;\n\nendpackage\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// DecodeStage\n//\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport OpFormatTypes::*;\nimport MicroOpTypes::*;\nimport PipelineTypes::*;\nimport DebugTypes::*;\nimport FetchUnitTypes::*;\nimport MemoryMapTypes::*;\n\n\nmodule PreDecodeStage(\n    PreDecodeStageIF.ThisStage port, \n    FetchStageIF.NextStage prev,\n    ControllerIF.PreDecodeStage ctrl,\n    DebugIF.PreDecodeStage debug\n);\n    // --- Pipeline registers\n    PreDecodeStageRegPath pipeReg[DECODE_WIDTH];\n    \n`ifndef RSD_SYNTHESIS\n    // Don't care these values, but avoiding undefined status in Questa.\n    initial begin\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            pipeReg[i] = '0;\n        end\n    end\n`endif\n\n    always_ff@ (posedge port.clk)\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < DECODE_WIDTH; i++) begin\n                pipeReg[i].valid <= FALSE;\n            end\n        end\n        else if (!ctrl.pdStage.stall) begin             // write data\n            pipeReg <= prev.nextStage;\n        end\n    end\n\n    AddrPath pc[DECODE_WIDTH];\n    logic illegalPC[DECODE_WIDTH];\n    always_comb begin\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            pc[i] = ToAddrFromPC(pipeReg[i].pc);\n            illegalPC[i] =\n                GetMemoryMapType(pc[i]) == MMT_ILLEGAL ? TRUE : FALSE;\n        end\n    end\n\n    // Micro op decoder\n    OpInfo [DECODE_WIDTH-1:0][MICRO_OP_MAX_NUM-1:0] microOps;  // Decoded micro ops\n    InsnInfo [DECODE_WIDTH-1:0] insnInfo;   // Whether a decoded instruction is branch or not.\n    for (genvar i = 0; i < DECODE_WIDTH; i++) begin\n        Decoder decoder(\n            .insn(pipeReg[i].insn),\n            .insnInfo(insnInfo[i]),\n            .microOps(microOps[i]),\n            .illegalPC(illegalPC[i])\n        );\n    end\n\n    // Pipeline control\n    logic stall, clear;\n    logic empty;\n    DecodeStageRegPath nextStage[DECODE_WIDTH];\n    \n    \n    always_comb begin\n        stall = ctrl.pdStage.stall;\n        clear = ctrl.pdStage.clear;\n\n        empty = TRUE;\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            nextStage[i].valid = \n                (stall || clear || port.rst) ? FALSE : pipeReg[i].valid;\n            \n            // Decoded micro-op and context.\n            nextStage[i].insn = pipeReg[i].insn;\n            nextStage[i].pc = pipeReg[i].pc;\n            nextStage[i].brPred = pipeReg[i].brPred;\n\n            nextStage[i].insnInfo = insnInfo[i];\n            nextStage[i].microOps = microOps[i];\n\n            if (pipeReg[i].valid)\n                empty = FALSE;\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].sid = pipeReg[i].sid;\n`endif\n        end\n        \n        port.nextStage = nextStage;\n        ctrl.pdStageEmpty = empty;\n\n        // Debug Register\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            // \u5148\u982d\u304c\u6b21\u306b\u9001\u3089\u308c\u305f\u3089\uff0c\u30c7\u30b3\u30fc\u30c9\u5143\u306f\u6d88\u3048\u308b\uff0e\n            debug.pdReg[i].valid = pipeReg[i].valid;\n            debug.pdReg[i].sid = pipeReg[i].sid;\n`ifdef RSD_FUNCTIONAL_SIMULATION\n            debug.pdReg[i].aluCode = microOps[i][1].operand.intOp.aluCode;\n            debug.pdReg[i].opType = microOps[i][1].mopSubType.intType;\n`endif\n        end\n`endif\n\n    end\nendmodule : PreDecodeStage\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- PreDecodeStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\nimport MicroOpTypes::*;\n\ninterface PreDecodeStageIF(input logic clk, rst);\n\n    // Pipeline registers \n    DecodeStageRegPath nextStage[DECODE_WIDTH];\n    \n    modport ThisStage(\n    input \n        clk, \n        rst,\n    output \n        nextStage\n    );\n    \n    modport NextStage(\n    input\n        nextStage\n    );\n    \nendinterface : PreDecodeStageIF\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Recovery Manager\n//   \u30ea\u30ab\u30d0\u30ea\u306b\u9077\u79fb\u3059\u308b\u4fe1\u53f7\u3092\u5404\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\u3059\u308b\u30e2\u30b8\u30e5\u30fc\u30eb\n//   \u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30ea\u30ab\u30d0\u30ea\u81ea\u4f53\u306f\u305d\u308c\u305e\u308c\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u4e2d\u3067\u8a18\u8ff0\u3055\u308c\u308b\n//\n// \u4f8b\u5916\u304c\u8d77\u304d\u3066\u30ea\u30ab\u30d0\u30ea\u304c\u884c\u308f\u308c\u308b\u69d8\u5b50\u306f\u4ee5\u4e0b\u306e\u3088\u3046\u306b\u306a\u3063\u3066\u3044\u308b\n// 1. RwStage\u3082\u3057\u304f\u306fCmStage\u304b\u3089exceptionDetected\u4fe1\u53f7\u304c, RecoveryManager\u306b\u767a\u4fe1\u3055\u308c\u308b\n// 2. exceptionDetected\u4fe1\u53f7\u304c\u3042\u3055\u30fc\u3068\u3055\u308c\u305f\u6b21\u306e\u30b5\u30a4\u30af\u30eb\u306b, \u5404\u30e2\u30b8\u30e5\u30fc\u30eb\u306btoRecoveryPhase\u4fe1\u53f7\u304c\u767a\u4fe1\u3055\u308c\u308b(PHASE_RECOVER_0)\n// 3. \u3059\u3079\u3066\u306e\u30e2\u30b8\u30e5\u30fc\u30eb\u306e\u30ea\u30ab\u30d0\u30ea\u304c\u7d42\u308f\u3063\u305f\u3053\u3068\u3092\u78ba\u8a8d\u3057\u305f\u3089, \u5404\u30e2\u30b8\u30e5\u30fc\u30eb\u306btoCommitPhase\u4fe1\u53f7\u3092\u9001\u308a, \u30ea\u30ab\u30d0\u30ea\u7d42\u4e86\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport PipelineTypes::*;\nimport RenameLogicTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\n\nmodule RecoveryManager(\n    RecoveryManagerIF.RecoveryManager port,\n    ActiveListIF.RecoveryManager activeList,\n    CSR_UnitIF.RecoveryManager csrUnit,\n    ControllerIF.RecoveryManager ctrl,\n    PerformanceCounterIF.RecoveryManager perfCounter\n);\n    typedef struct packed\n    {\n        // \u30ea\u30ab\u30d0\u30ea\u306e\u30d5\u30a7\u30fc\u30ba\n        // \u5b9f\u884c\u30b9\u30c6\u30fc\u30b8\u304b\u3089\u30ea\u30ab\u30d0\u30ea\u304c\u304b\u304b\u308b\u5834\u5408\u3082\u3042\u308b\u306e\u3067\uff0c\n        // \u30b3\u30df\u30c3\u30c8\u30b9\u30c6\u30fc\u30b8\u306e\u30d5\u30a7\u30fc\u30ba\u3068\u540c\u671f\u3057\u3066\u3044\u308b\u308f\u3051\u3067\u306f\u306a\u3044\n        PipelinePhase phase;\n\n        // \u30ea\u30ab\u30d0\u30ea\u8981\u6c42\n        // \u3053\u308c\u3089\u306f\u30b9\u30c6\u30fc\u30b8\u306e\u7d42\u308f\u308a\u306e\u3042\u305f\u308a\u3067\u6765\u308b\u3053\u3068\u304c\u591a\u3044\u306e\u3067\uff0c\u4e00\u65e6\u30ec\u30b8\u30b9\u30bf\u306b\u7a4d\u3093\u3067\n        // \u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5316\u3059\u308b\n        logic exceptionDetectedInCommitStage;\n        AddrPath recoveredPC_FromRwStage;\n        AddrPath recoveredPC_FromCommitStage;\n\n        // Related to CSR \n        // \u3053\u308c\u3089\u3082\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u5316\u306e\u305f\u3081\n        ExecutionState excptCause;      // Trap vector or MRET return target\n        AddrPath excptCauseDataAddr;    // fault \u767a\u751f\u6642\u306e\u30c7\u30fc\u30bf\u30a2\u30c9\u30ec\u30b9\n\n        // ActiveList\u4e2d\u306e\u3069\u306e\u30a8\u30f3\u30c8\u30ea\u304c\u3069\u306e\u30a8\u30f3\u30c8\u30ea\u307e\u3067\u3092\u30d5\u30e9\u30c3\u30b7\u30e5\u3059\u308b\u304b\u3092\u793a\u3059\u30dd\u30a4\u30f3\u30bf\n        ActiveListIndexPath flushRangeHeadPtr;\n        ActiveListIndexPath flushRangeTailPtr;\n     \n        logic recoveryFromRwStage;  // \u4f8b\u5916\u304c\u3069\u3053\u306e\u30b9\u30c6\u30fc\u30b8\u3067\u691c\u51fa\u3055\u308c\u305f\u304b\n        RefetchType refetchType;    // \u30ea\u30d5\u30a7\u30c3\u30c1\u306e\u30bf\u30a4\u30d7\n\n    } RecoveryManagerStatePath;\n    RecoveryManagerStatePath regState;\n    RecoveryManagerStatePath nextState;\n\n    // \u5404\u30e2\u30b8\u30e5\u30fc\u30eb\u306b\u9001\u3089\u308c\u308b\u4fe1\u53f7\n    // \u30ea\u30ab\u30d0\u30ea\u6642\u306e\u52d5\u4f5c\u81ea\u4f53\u306f\u5404\u30e2\u30b8\u30e5\u30fc\u30eb\u3067\u8a18\u8ff0\u3055\u308c\u308b\n    logic toRecoveryPhase, toCommitPhase;\n\n    // CSR \u304b\u3089\u30ea\u30d5\u30a7\u30c3\u30c1\u3059\u308b\u304b\u3069\u3046\u304b\n    logic refetchFromCSR;\n\n    //\u30ea\u30ab\u30d0\u30ea\u306b\u3088\u3063\u3066\u56de\u5fa9\u3055\u308c\u308bPC\n    PC_Path recoveredPC;\n\n    // \u4f8b\u5916\u3092\u8d77\u3053\u3057\u305f\u547d\u4ee4\u306eActiveList\u306e\u30dd\u30a4\u30f3\u30bf\n    ActiveListIndexPath exceptionOpPtr;\n\n    // \u4f8b\u5916\u304c\u691c\u51fa\u3055\u308c\u305f\u5f8c\u30ea\u30ab\u30d0\u30ea\u72b6\u614b\u306b\u79fb\u884c\u3059\u308b\n    logic exceptionDetected;\n\n    always_ff@(posedge port.clk) begin  // synchronous rst\n        if (!port.rst) begin\n            regState <= nextState;\n        end\n        else begin\n            regState.phase <= PHASE_COMMIT;\n            regState.flushRangeHeadPtr <= '0;\n            regState.flushRangeTailPtr <= '0;\n            regState.recoveryFromRwStage <= FALSE;\n            regState.refetchType <= REFETCH_TYPE_THIS_PC;\n\n            regState.exceptionDetectedInCommitStage <= '0;\n            regState.recoveredPC_FromRwStage <= '0;\n            regState.recoveredPC_FromCommitStage <= '0;\n\n            regState.excptCause <= EXEC_STATE_NOT_FINISHED;\n            regState.excptCauseDataAddr <= '0;\n        end\n    end\n\n\n    always_comb begin\n        // To Recovery 0\n        toRecoveryPhase = \n            port.exceptionDetectedInCommitStage || \n            port.exceptionDetectedInRwStage;\n        if (toRecoveryPhase) begin\n            nextState.recoveryFromRwStage = port.exceptionDetectedInRwStage;\n        end\n        else begin\n            nextState.recoveryFromRwStage = FALSE;\n        end\n\n        // Return to COMMIT_PHASE\n        toCommitPhase =\n            (regState.phase == PHASE_RECOVER_1) &&  // must be PHASE_RECOVER_1 because PHASE_RECOVER_0 procedures has been finished\n            !(port.renameLogicRecoveryRMT || port.issueQueueReturnIndex); // LSQ \u306f1\u30b5\u30a4\u30af\u30eb\u3067\u30ea\u30ab\u30d0\u30ea\u304c\u884c\u308f\u308c\u308b\u306e\u3067\u5f85\u3064\u3079\u304d\u306f RMT \u3068 IQ\n        nextState.refetchType = \n            port.exceptionDetectedInCommitStage ? \n                port.refetchTypeFromCommitStage : \n                port.refetchTypeFromRwStage;\n\n        // Trap/fault origin\n        // \u3053\u308c\u3089\u306e\u8981\u6c42\u306f\u4e00\u65e6\u30ec\u30b8\u30b9\u30bf\u306b\u7a4d\u3080\n        nextState.excptCause = port.recoveryCauseFromCommitStage;\n        nextState.excptCauseDataAddr = port.faultingDataAddr;\n        nextState.exceptionDetectedInCommitStage = port.exceptionDetectedInCommitStage;\n        nextState.recoveredPC_FromRwStage = port.recoveredPC_FromRwStage;\n        nextState.recoveredPC_FromCommitStage = port.recoveredPC_FromCommitStage;\n\n        // CSR \u3078\u306e\u8981\u6c42\u306f\u3059\u3079\u3066 PHASE_RECOVER_0 \u306b\u884c\u3046\n        refetchFromCSR = regState.refetchType inside {\n            REFETCH_TYPE_NEXT_PC_TO_CSR_TARGET, REFETCH_TYPE_THIS_PC_TO_CSR_TARGET\n        };\n        csrUnit.triggerExcpt = (regState.phase == PHASE_RECOVER_0) && refetchFromCSR;\n        csrUnit.excptCauseAddr = ToPC_FromAddr(regState.recoveredPC_FromCommitStage);\n        csrUnit.excptCause = regState.excptCause;\n        csrUnit.excptCauseDataAddr = regState.excptCauseDataAddr;\n\n        // Recovered PC\n        if(regState.phase == PHASE_RECOVER_0) begin\n            if (refetchFromCSR) begin\n                recoveredPC = ToPC_FromAddr(csrUnit.excptTargetAddr);\n            end\n            else begin\n                if (regState.refetchType == REFETCH_TYPE_THIS_PC) begin\n                    recoveredPC = regState.exceptionDetectedInCommitStage ?\n                        ToPC_FromAddr(regState.recoveredPC_FromCommitStage) : \n                        ToPC_FromAddr(regState.recoveredPC_FromRwStage);\n                end\n                else if (regState.refetchType inside{REFETCH_TYPE_NEXT_PC, REFETCH_TYPE_STORE_NEXT_PC}) begin\n                    recoveredPC = regState.exceptionDetectedInCommitStage ?\n                        ToPC_FromAddr(regState.recoveredPC_FromCommitStage) + INSN_BYTE_WIDTH : \n                        ToPC_FromAddr(regState.recoveredPC_FromRwStage) + INSN_BYTE_WIDTH;\n                end\n                else begin // REFETCH_TYPE_BRANCH_TARGET\n                    recoveredPC = regState.exceptionDetectedInCommitStage ?\n                        ToPC_FromAddr(regState.recoveredPC_FromCommitStage) : \n                        ToPC_FromAddr(regState.recoveredPC_FromRwStage);\n                end\n            end\n        end\n        else begin\n            recoveredPC = '0;\n        end\n\n        if(port.rst) begin\n            nextState.phase = PHASE_COMMIT;\n        end\n        else if(regState.phase == PHASE_COMMIT) begin\n            nextState.phase = toRecoveryPhase ? PHASE_RECOVER_0 : PHASE_COMMIT;\n        end\n        else if(regState.phase == PHASE_RECOVER_0) begin\n            nextState.phase = PHASE_RECOVER_1;\n        end\n        else begin\n            nextState.phase = toCommitPhase ? PHASE_COMMIT : regState.phase;\n        end\n\n        port.phase = regState.phase;\n\n        // Update a PC in a fetcher if branch misprediction occurs.\n        port.recoveredPC_FromRwCommit = recoveredPC;\n        port.toCommitPhase = toCommitPhase;\n\n        // To each logic to be recovered.\n        port.toRecoveryPhase = regState.phase == PHASE_RECOVER_0;\n        port.recoveryFromRwStage = regState.recoveryFromRwStage;\n\n        // \u9078\u629e\u7684\u30d5\u30e9\u30c3\u30b7\u30e5\u306b\u304a\u3044\u3066\u3082\uff0c\u30d5\u30ed\u30f3\u30c8\u30a8\u30f3\u30c9\u306f\u5168\u3066\u30d5\u30e9\u30c3\u30b7\u30e5\u3055\u308c\u308b\n        ctrl.cmStageFlushUpper = regState.phase == PHASE_RECOVER_0;\n\n        // \u30d5\u30e9\u30c3\u30b7\u30e5\u3059\u308b\u547d\u4ee4\u306e\u7bc4\u56f2\u306e\u7ba1\u7406\n        exceptionDetected = port.exceptionDetectedInCommitStage || port.exceptionDetectedInRwStage;\n        exceptionOpPtr = activeList.exceptionOpPtr;\n\n        nextState.flushRangeHeadPtr = \n            (nextState.refetchType inside {REFETCH_TYPE_THIS_PC, REFETCH_TYPE_THIS_PC_TO_CSR_TARGET}) ?\n                exceptionOpPtr : exceptionOpPtr + 1;\n        nextState.flushRangeTailPtr = activeList.detectedFlushRangeTailPtr;\n        port.loadQueueRecoveryTailPtr = activeList.loadQueueRecoveryTailPtr;\n        port.storeQueueRecoveryTailPtr = \n            regState.refetchType == REFETCH_TYPE_STORE_NEXT_PC ? \n                (activeList.storeQueueRecoveryTailPtr + 1): activeList.storeQueueRecoveryTailPtr;\n\n        port.flushRangeHeadPtr = regState.flushRangeHeadPtr;\n        port.flushRangeTailPtr = regState.flushRangeTailPtr;\n\n        // \n        port.unableToStartRecovery = \n            (regState.phase != PHASE_COMMIT) || \n            port.renameLogicRecoveryRMT || \n            port.issueQueueReturnIndex || \n            port.replayQueueFlushedOpExist || \n            port.wakeupPipelineRegFlushedOpExist;\n\n\n        // Hardware Counter\n`ifndef RSD_DISABLE_PERFORMANCE_COUNTER\n        perfCounter.storeLoadForwardingFail =\n            regState.phase == PHASE_RECOVER_0 && (regState.refetchType == REFETCH_TYPE_THIS_PC);\n        perfCounter.memDepPredMiss =\n            regState.phase == PHASE_RECOVER_0 && (regState.refetchType inside {REFETCH_TYPE_NEXT_PC, REFETCH_TYPE_STORE_NEXT_PC});\n        perfCounter.branchPredMiss =\n            regState.phase == PHASE_RECOVER_0 && (regState.refetchType == REFETCH_TYPE_BRANCH_TARGET);\n`endif\n    end\n\n    \n    // Commit/Recovery state manage\n    `RSD_ASSERT_CLK(\n        port.clk,\n        !(toCommitPhase && toRecoveryPhase),\n        \"Tried to start the commit phase and the recovery phase at the same time\"\n    );\n\n    `RSD_ASSERT_CLK(\n        port.clk,\n        !(port.exceptionDetectedInRwStage && nextState.refetchType inside {REFETCH_TYPE_NEXT_PC_TO_CSR_TARGET, REFETCH_TYPE_THIS_PC_TO_CSR_TARGET} ),\n        \"RW stage recovery is not allowed in REFETCH_TYPE_CSR_UNIT_TARGET\"\n    );\n\nendmodule : RecoveryManager"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- RecoveryManagerIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\nimport RenameLogicTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport LoadStoreUnitTypes::*;\n\ninterface RecoveryManagerIF( input logic clk, rst );\n\n    // Phase of a pipeline\n    PipelinePhase phase;\n\n    // A type of exception from CommitStage\n    RefetchType refetchTypeFromCommitStage;\n\n    // A type of exception from CommitStage\n    RefetchType refetchTypeFromRwStage;\n\n    // Index of detected exception op in CommitStage\n    CommitLaneIndexPath recoveryOpIndex;\n\n    // Exception detected in CommitStage\n    logic exceptionDetectedInCommitStage;\n\n    // Exception detected in RwStage\n    logic exceptionDetectedInRwStage;\n\n    // PC control\n    logic    toCommitPhase;\n    AddrPath recoveredPC_FromCommitStage;\n    AddrPath recoveredPC_FromRwStage;\n    AddrPath recoveredPC_FromRwCommit;      // Correct PC\n\n    // For fault handling\n    AddrPath faultingDataAddr;\n\n    //\u3000Miss prediction detected in RenameStage\n    logic    recoverFromRename;\n    AddrPath recoveredPC_FromRename;\n\n    // Trigger recovery of each module\n    logic toRecoveryPhase;\n\n    // Flush range to broadcast\n    ActiveListIndexPath flushRangeHeadPtr;\n    ActiveListIndexPath flushRangeTailPtr;\n    // Whether flush all instructions in ActiveList\n    // This is necessary to distinguish when ActiveList is full or empty, \n    logic flushAllInsns;\n\n    // ActiveList/LSQ TailPtr for recovery\n    LoadQueueIndexPath loadQueueRecoveryTailPtr;\n    LoadQueueIndexPath loadQueueHeadPtr;\n    StoreQueueIndexPath storeQueueRecoveryTailPtr;\n    StoreQueueIndexPath storeQueueHeadPtr;\n\n    // IssueQueueEntryPtr to be flushed at recovery\n    IssueQueueOneHotPath flushIQ_Entry;\n\n    // In IQ returning index to freelist\n    logic issueQueueReturnIndex;\n\n    // In AL recovery\n    logic inRecoveryAL;\n\n    // In RMT recovery\n    logic renameLogicRecoveryRMT;\n\n    // In ReplayQueue flushing\n    logic replayQueueFlushedOpExist;\n\n    // In wakeupPipelineReg flushing\n    logic wakeupPipelineRegFlushedOpExist;\n\n    // Unable to detect exception and start recovery\n    logic unableToStartRecovery;\n\n    // IssueQueue\u306eflush\u304c\u5fc5\u8981\u306a\u30a8\u30f3\u30c8\u30ea\u304b\u3069\u3046\u304b\u306e\u5224\u5b9a\u306b\u4f7f\u3046\n    IssueQueueOneHotPath notIssued;\n\n    // wakeupPipelineRegister\u5185\u306e\u547d\u4ee4\u306e\u30d5\u30e9\u30c3\u30b7\u30e5\u306b\u4f7f\u3046\n    logic selected [ ISSUE_WIDTH ];\n    IssueQueueIndexPath selectedPtr [ ISSUE_WIDTH ];\n    ActiveListIndexPath selectedActiveListPtr [ ISSUE_WIDTH ];\n\n    // RwStage\u304b\u3089\u306e\u30ea\u30ab\u30d0\u30ea\u304b\u3069\u3046\u304b\n    //toRecoveryPhase\u3068\u540c\u6642\u306b\u7acb\u3061True\u3067\u306a\u3044\u3068\u304dCommitStage\u304b\u3089\u306e\u30ea\u30ab\u30d0\u30ea\n    logic recoveryFromRwStage;\n\n    // Why recovery is caused\n    ExecutionState recoveryCauseFromCommitStage;\n\n    modport RecoveryManager(\n    input\n        clk,\n        rst,\n        exceptionDetectedInCommitStage,\n        refetchTypeFromCommitStage,\n        exceptionDetectedInRwStage,\n        refetchTypeFromRwStage,\n        renameLogicRecoveryRMT,\n        issueQueueReturnIndex,\n        replayQueueFlushedOpExist,\n        wakeupPipelineRegFlushedOpExist,\n        recoveredPC_FromCommitStage,\n        recoveredPC_FromRwStage,\n        faultingDataAddr,\n        notIssued,\n        flushIQ_Entry,\n        recoveryCauseFromCommitStage,\n    output\n        phase,\n        toRecoveryPhase,\n        recoveredPC_FromRwCommit,\n        toCommitPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        unableToStartRecovery,\n        recoveryFromRwStage,\n        loadQueueRecoveryTailPtr,\n        storeQueueRecoveryTailPtr\n    );\n\n    modport RenameStage(\n    output\n        recoverFromRename,\n        recoveredPC_FromRename\n    );\n\n    modport CommitStage(\n    input\n        phase,\n        unableToStartRecovery,\n        renameLogicRecoveryRMT,\n    output\n        exceptionDetectedInCommitStage,\n        recoveryOpIndex,\n        refetchTypeFromCommitStage,\n        recoveryCauseFromCommitStage\n    );\n\n    modport NextPCStage(\n    input\n        toCommitPhase,\n        toRecoveryPhase,\n        recoveredPC_FromRwCommit,\n        recoverFromRename,\n        recoveredPC_FromRename\n    );\n\n    modport RenameLogic(\n    input\n        toRecoveryPhase,\n        inRecoveryAL,\n    output\n        renameLogicRecoveryRMT\n    );\n\n    modport RenameLogicCommitter(\n    input\n        toRecoveryPhase,\n        toCommitPhase,\n    output\n        inRecoveryAL\n    );\n\n    modport IssueQueue(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns,\n        notIssued,\n        selected,\n        selectedPtr,\n        recoveryFromRwStage,\n    output\n        flushIQ_Entry,\n        issueQueueReturnIndex,\n        selectedActiveListPtr\n    );\n\n    modport Scheduler(\n    input\n        toRecoveryPhase,\n        flushIQ_Entry,\n    output\n        notIssued\n    );\n\n    modport ScheduleStage(\n    input\n        toRecoveryPhase,\n        flushIQ_Entry\n    );\n\n    modport SelectLogic(\n    output\n        selected,\n        selectedPtr\n    );\n\n    modport ReplayQueue(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns,\n        recoveryFromRwStage,\n    output\n        replayQueueFlushedOpExist\n    );\n\n    modport WakeupPipelineRegister(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns,\n        selectedActiveListPtr,\n        flushIQ_Entry,\n        recoveryFromRwStage,\n    output\n        wakeupPipelineRegFlushedOpExist\n    );\n\n    modport LoadQueue(\n    input\n        toRecoveryPhase,\n        loadQueueRecoveryTailPtr,\n    output\n        loadQueueHeadPtr\n    );\n\n    modport StoreQueue(\n    input\n        toRecoveryPhase,\n        storeQueueRecoveryTailPtr,\n    output\n        storeQueueHeadPtr\n    );\n\n    modport StoreCommitter(\n    input\n        toRecoveryPhase\n    );\n\n    modport DCacheMissHandler(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport MulDivUnit(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport IntegerIssueStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport IntegerRegisterReadStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport IntegerExecutionStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport IntegerRegisterWriteStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport ComplexIntegerIssueStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport ComplexIntegerRegisterReadStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport ComplexIntegerExecutionStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport ComplexIntegerRegisterWriteStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport MemoryIssueStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport MemoryRegisterReadStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport MemoryExecutionStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport MemoryTagAccessStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport MemoryAccessStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport MemoryRegisterWriteStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n`ifdef RSD_MARCH_FP_PIPE \n    modport FPIssueStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport FPRegisterReadStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport FPExecutionStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport FPRegisterWriteStage(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n\n    modport FPDivSqrtUnit(\n    input\n        toRecoveryPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        flushAllInsns\n    );\n`endif\n\n    modport ActiveList(\n    input\n        toRecoveryPhase,\n        toCommitPhase,\n        flushRangeHeadPtr,\n        flushRangeTailPtr,\n        unableToStartRecovery,\n    output\n        exceptionDetectedInRwStage,\n        refetchTypeFromRwStage,\n        recoveredPC_FromCommitStage,\n        recoveredPC_FromRwStage,\n        faultingDataAddr,\n        flushAllInsns\n    );\n\n    modport InterruptController(\n    input\n        unableToStartRecovery\n    );\n\nendinterface : RecoveryManagerIF\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Register file\n//\n\nimport BasicTypes::*;\n\nmodule RegisterFile(\n    RegisterFileIF.RegisterFile port\n);\n    //\n    // Register\n    //\n    parameter REG_READ_NUM = (INT_ISSUE_WIDTH + COMPLEX_ISSUE_WIDTH + MEM_ISSUE_WIDTH) * 2 + FP_ISSUE_WIDTH;\n    parameter REG_WRITE_NUM = INT_ISSUE_WIDTH + COMPLEX_ISSUE_WIDTH + LOAD_ISSUE_WIDTH + FP_ISSUE_WIDTH;\n\n    logic       regWE      [ REG_WRITE_NUM ];\n    PScalarRegNumPath dstRegNum  [ REG_WRITE_NUM ];\n    PRegDataPath dstRegData [ REG_WRITE_NUM ];\n    PScalarRegNumPath srcRegNum  [ REG_READ_NUM ];\n    PRegDataPath srcRegData [ REG_READ_NUM ];\n\n`ifdef RSD_MARCH_FP_PIPE\n    //\n    // FP Register\n    //\n    parameter FP_READ_NUM = FP_ISSUE_WIDTH * 3 + MEM_ISSUE_WIDTH;\n    parameter FP_WRITE_NUM = FP_ISSUE_WIDTH + LOAD_ISSUE_WIDTH;\n\n    logic             fpRegWE      [ FP_WRITE_NUM ];\n    PScalarFPRegNumPath       dstFPRegNum  [ FP_WRITE_NUM ];\n    PRegDataPath      dstFPRegData [ FP_WRITE_NUM ];\n    PScalarFPRegNumPath       srcFPRegNum  [ FP_READ_NUM ];\n    PRegDataPath      srcFPRegData [ FP_READ_NUM ];\n`endif\n    \n    DistributedMultiPortRAM #(\n        .ENTRY_NUM( PSCALAR_NUM ),\n        .ENTRY_BIT_SIZE( $bits(PRegDataPath) ),\n        .READ_NUM( REG_READ_NUM ),\n        .WRITE_NUM( REG_WRITE_NUM )\n    ) phyReg (\n        .clk( port.clk ),\n        .we( regWE ),\n        .wa( dstRegNum ),\n        .wv( dstRegData ),\n        .ra( srcRegNum ),\n        .rv( srcRegData )\n    );\n\n    // - Initialization logic\n    PRegNumPath regRstIndex;\n    always_ff @( posedge port.clk ) begin\n        if (port.rstStart)\n            regRstIndex <= 0;\n        else\n            regRstIndex <= regRstIndex + REG_WRITE_NUM;\n    end\n\n    always_comb begin\n        for ( int i = 0; i < INT_ISSUE_WIDTH; i++ ) begin\n`ifdef RSD_MARCH_FP_PIPE\n            regWE     [i] = port.intDstRegWE[i] && !port.intDstRegNum[i].isFP;\n`else\n            regWE     [i] = port.intDstRegWE[i];\n`endif\n            dstRegNum [i] = port.intDstRegNum[i].regNum;\n            dstRegData[i] = port.intDstRegData[i];\n\n            srcRegNum[i*2  ] = port.intSrcRegNumA[i].regNum;\n            srcRegNum[i*2+1] = port.intSrcRegNumB[i].regNum;\n            port.intSrcRegDataA[i] = srcRegData[i*2  ];\n            port.intSrcRegDataB[i] = srcRegData[i*2+1];\n        end\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        for ( int i = 0; i < COMPLEX_ISSUE_WIDTH; i++ ) begin\n`ifdef RSD_MARCH_FP_PIPE\n            regWE     [i+INT_ISSUE_WIDTH] = port.complexDstRegWE[i] && !port.complexDstRegNum[i].isFP;\n`else\n            regWE     [i+INT_ISSUE_WIDTH] = port.complexDstRegWE[i];\n`endif\n            dstRegNum [i+INT_ISSUE_WIDTH] = port.complexDstRegNum[i].regNum;\n            dstRegData[i+INT_ISSUE_WIDTH] = port.complexDstRegData[i];\n\n            srcRegNum[(i+INT_ISSUE_WIDTH)*2  ] = port.complexSrcRegNumA[i].regNum;\n            srcRegNum[(i+INT_ISSUE_WIDTH)*2+1] = port.complexSrcRegNumB[i].regNum;\n            port.complexSrcRegDataA[i] = srcRegData[(i+INT_ISSUE_WIDTH)*2  ];\n            port.complexSrcRegDataB[i] = srcRegData[(i+INT_ISSUE_WIDTH)*2+1];\n        end\n`endif\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            srcRegNum[(i+INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH)*2  ] = port.memSrcRegNumA[i].regNum;\n            srcRegNum[(i+INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH)*2+1] = port.memSrcRegNumB[i].regNum;\n            port.memSrcRegDataA[i] = srcRegData[(i+INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH)*2  ];\n`ifndef RSD_MARCH_FP_PIPE\n            port.memSrcRegDataB[i] = srcRegData[(i+INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH)*2+1];\n`else\n            port.memSrcRegDataB[i] = port.memSrcRegNumB[i].isFP ? srcFPRegData[i+FP_ISSUE_WIDTH*3] : srcRegData[(i+INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH)*2+1];\n`endif\n        end\n\n        for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n`ifdef RSD_MARCH_FP_PIPE\n            regWE     [(i+INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH)] = port.memDstRegWE[i] && !port.memDstRegNum[i].isFP;\n`else\n            regWE     [(i+INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH)] = port.memDstRegWE[i];\n`endif\n\n            dstRegNum [(i+INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH)] = port.memDstRegNum[i].regNum;\n            dstRegData[(i+INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH)] = port.memDstRegData[i];\n        end\n\n`ifdef RSD_MARCH_FP_PIPE \n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n            srcRegNum[i+(INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH+MEM_ISSUE_WIDTH)*2  ] = port.fpSrcRegNumA[i].regNum;\n            //port.fpSrcRegDataA[i] = srcRegData[i+(INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH+MEM_ISSUE_WIDTH)*2  ];\n            regWE     [(i+INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH+LOAD_ISSUE_WIDTH)] = port.fpDstRegWE[i] && !port.fpDstRegNum[i].isFP;\n            dstRegNum [(i+INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH+LOAD_ISSUE_WIDTH)] = port.fpDstRegNum[i].regNum;\n            dstRegData[(i+INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH+LOAD_ISSUE_WIDTH)] = port.fpDstRegData[i];\n        end\n`endif\n        // \u4ee5\u4e0b\u306e\u30ea\u30bb\u30c3\u30c8\u5f8c\u306e\u521d\u671f\u5316\u51e6\u7406\u3067\u5168\u3066\u306e\u30ec\u30b8\u30b9\u30bf\u306b0x0\u3092\u4ee3\u5165\u3059\u308b.\n        // \u30bc\u30ed\u30ec\u30b8\u30b9\u30bf\u306f, \u66f8\u304d\u8fbc\u307f\u6642\u306b\u306fDecoder\u3067write\u30d5\u30e9\u30b0\u3092\u843d\u3068\u3057,\n        // \u8aad\u307f\u8fbc\u307f\u6642\u306f,RMT\u306e\u521d\u671f\u5316\u306b\u3088\u3063\u3066\u5272\u308a\u5f53\u3066\u3089\u308c\u308b,\n        // 0x0\u3067\u521d\u671f\u5316\u3055\u308c\u305f\u7269\u7406\u30ec\u30b8\u30b9\u30bf\u306e0\u756a\u30a8\u30f3\u30c8\u30ea\u3092\u5b9f\u969b\u306b\u53c2\u7167\u3059\u308b\u3053\u3068\u3067\u5b9f\u73fe\u3057\u3066\u3044\u308b.\n        // \u3088\u3063\u3066, \u4ee5\u4e0b\u306e\u521d\u671f\u5316\u51e6\u7406\u3092\u8ad6\u7406\u5408\u6210\u6642\u3082\u7701\u7565\u3057\u3066\u306f\u306a\u3089\u306a\u3044\n        if (port.rst) begin\n            for (int i = 0; i < REG_WRITE_NUM; i++) begin\n                regWE     [i] = TRUE;\n                dstRegNum [i] = regRstIndex + i;\n                dstRegData[i].data = 'h00000000;\n                dstRegData[i].valid = TRUE;\n            end\n        end\n    end\n\n    //\n    // FP\n    //\n`ifdef RSD_MARCH_FP_PIPE\n    DistributedMultiPortRAM #(\n        .ENTRY_NUM( PSCALAR_FP_NUM ),\n        .ENTRY_BIT_SIZE( $bits(PRegDataPath) ),\n        .READ_NUM( FP_READ_NUM ),\n        .WRITE_NUM( FP_WRITE_NUM )\n    ) phyFPReg (\n        .clk( port.clk ),\n        .we( fpRegWE ),\n        .wa( dstFPRegNum ),\n        .wv( dstFPRegData ),\n        .ra( srcFPRegNum ),\n        .rv( srcFPRegData )\n    );\n\n    // - Initialization logic\n    PRegNumPath fpRstIndex;\n    always_ff @( posedge port.clk ) begin\n        if (port.rstStart)\n            fpRstIndex <= 0;\n        else\n            fpRstIndex <= fpRstIndex + FP_WRITE_NUM;\n    end\n\n    always_comb begin\n        for ( int i = 0; i < FP_ISSUE_WIDTH; i++ ) begin\n            fpRegWE     [i] = port.fpDstRegWE[i] && port.fpDstRegNum[i].isFP;\n            dstFPRegNum [i] = port.fpDstRegNum[i].regNum;\n            dstFPRegData[i] = port.fpDstRegData[i];\n\n            srcFPRegNum[i*3  ] = port.fpSrcRegNumA[i].regNum;\n            srcFPRegNum[i*3+1] = port.fpSrcRegNumB[i].regNum;\n            srcFPRegNum[i*3+2] = port.fpSrcRegNumC[i].regNum;\n            port.fpSrcRegDataA[i] = port.fpSrcRegNumA[i].isFP ? srcFPRegData[i*3] : srcRegData[i+(INT_ISSUE_WIDTH+COMPLEX_ISSUE_WIDTH+MEM_ISSUE_WIDTH)*2];\n            port.fpSrcRegDataB[i] = srcFPRegData[i*3+1];\n            port.fpSrcRegDataC[i] = srcFPRegData[i*3+2];\n        end\n\n        for ( int i = 0; i < MEM_ISSUE_WIDTH; i++ ) begin\n            srcFPRegNum[i+FP_ISSUE_WIDTH*3] = port.memSrcRegNumB[i].regNum;\n        end\n\n        for ( int i = 0; i < LOAD_ISSUE_WIDTH; i++ ) begin\n            fpRegWE     [i+FP_ISSUE_WIDTH] = port.memDstRegWE[i] && port.memDstRegNum[i].isFP;\n            dstFPRegNum [i+FP_ISSUE_WIDTH] = port.memDstRegNum[i].regNum;\n            dstFPRegData[i+FP_ISSUE_WIDTH] = port.memDstRegData[i];\n        end\n        \n        if (port.rst) begin\n            for (int i = 0; i < FP_WRITE_NUM; i++) begin\n                fpRegWE     [i] = TRUE;\n                dstFPRegNum [i] = fpRstIndex + i;\n                dstFPRegData[i].data = 'h00000000;\n                dstFPRegData[i].valid = TRUE;\n            end\n        end\n    end\n`endif\n\nendmodule : RegisterFile\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- RegisterFileIF\n//\n\nimport BasicTypes::*;\n\n\ninterface RegisterFileIF( input logic clk, rst, rstStart );\n    \n    /* Integer Register Read */\n    PRegNumPath intSrcRegNumA [ INT_ISSUE_WIDTH ];\n    PRegNumPath intSrcRegNumB [ INT_ISSUE_WIDTH ];\n    \n    PRegDataPath intSrcRegDataA [ INT_ISSUE_WIDTH ];\n    PRegDataPath intSrcRegDataB [ INT_ISSUE_WIDTH ];\n    \n    /* Integer Register Write */\n    logic intDstRegWE  [ INT_ISSUE_WIDTH ];\n    PRegNumPath intDstRegNum  [ INT_ISSUE_WIDTH ];    \n    PRegDataPath intDstRegData  [ INT_ISSUE_WIDTH ];\n    \n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    /* Complex Integer Register Read */\n    PRegNumPath  complexSrcRegNumA [ COMPLEX_ISSUE_WIDTH ];\n    PRegNumPath  complexSrcRegNumB [ COMPLEX_ISSUE_WIDTH ];\n    \n    PRegDataPath  complexSrcRegDataA [ COMPLEX_ISSUE_WIDTH ];\n    PRegDataPath  complexSrcRegDataB [ COMPLEX_ISSUE_WIDTH ];\n\n\n    /* Complex Integer Register Write */\n    logic complexDstRegWE  [ COMPLEX_ISSUE_WIDTH ];\n\n    PRegNumPath  complexDstRegNum  [ COMPLEX_ISSUE_WIDTH ];\n    \n    PRegDataPath  complexDstRegData  [ COMPLEX_ISSUE_WIDTH ];\n`endif\n\n    /* Memory Register Read */\n    PRegNumPath memSrcRegNumA [ MEM_ISSUE_WIDTH ];\n    PRegNumPath memSrcRegNumB [ MEM_ISSUE_WIDTH ];\n    \n    PRegDataPath  memSrcRegDataA [ MEM_ISSUE_WIDTH ];\n    PRegDataPath  memSrcRegDataB [ MEM_ISSUE_WIDTH ];\n    \n    /* Memory Register Write */\n    logic memDstRegWE  [ LOAD_ISSUE_WIDTH ];\n\n    PRegNumPath memDstRegNum [ LOAD_ISSUE_WIDTH ];\n    \n    PRegDataPath memDstRegData  [ LOAD_ISSUE_WIDTH ];\n\n`ifdef RSD_MARCH_FP_PIPE\n    /* FP Register Read */\n    PRegNumPath  fpSrcRegNumA [ FP_ISSUE_WIDTH ];\n    PRegNumPath  fpSrcRegNumB [ FP_ISSUE_WIDTH ];\n    PRegNumPath  fpSrcRegNumC [ FP_ISSUE_WIDTH ];\n    \n    PRegDataPath  fpSrcRegDataA [ FP_ISSUE_WIDTH ];\n    PRegDataPath  fpSrcRegDataB [ FP_ISSUE_WIDTH ];\n    PRegDataPath  fpSrcRegDataC [ FP_ISSUE_WIDTH ];\n\n\n    /* FP Integer Register Write */\n    logic fpDstRegWE  [ FP_ISSUE_WIDTH ];\n\n    PRegNumPath  fpDstRegNum  [ FP_ISSUE_WIDTH ];\n    \n    PRegDataPath  fpDstRegData  [ FP_ISSUE_WIDTH ];\n`endif\n\n    modport RegisterFile(\n    input \n        clk,\n        rst,\n        rstStart,\n        intSrcRegNumA,\n        intSrcRegNumB,\n        memSrcRegNumA,\n        memSrcRegNumB,\n        intDstRegWE,\n        intDstRegNum,\n        intDstRegData,\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        complexSrcRegNumA,\n        complexSrcRegNumB,\n        complexDstRegWE,\n        complexDstRegNum,\n        complexDstRegData,\n`endif\n        memDstRegWE,\n        memDstRegNum,\n        memDstRegData,\n`ifdef RSD_MARCH_FP_PIPE\n        fpSrcRegNumA,\n        fpSrcRegNumB,\n        fpSrcRegNumC,\n        fpDstRegWE,\n        fpDstRegNum,\n        fpDstRegData,\n`endif\n    output\n        intSrcRegDataA,\n        intSrcRegDataB,\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        complexSrcRegDataA,\n        complexSrcRegDataB,\n`endif\n        memSrcRegDataA,\n        memSrcRegDataB\n`ifdef RSD_MARCH_FP_PIPE\n        ,\n        fpSrcRegDataA,\n        fpSrcRegDataB,\n        fpSrcRegDataC\n`endif\n    );\n    \n    modport IntegerRegisterReadStage(\n    input\n        intSrcRegDataA,\n        intSrcRegDataB,\n    output\n        intSrcRegNumA,\n        intSrcRegNumB\n    );\n    \n    modport IntegerRegisterWriteStage(\n    output\n        intDstRegWE,\n        intDstRegNum,\n        intDstRegData\n    );\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE    \n    modport ComplexIntegerRegisterReadStage(\n    input\n        complexSrcRegDataA,\n        complexSrcRegDataB,\n    output\n        complexSrcRegNumA,\n        complexSrcRegNumB\n    );\n    \n    modport ComplexIntegerRegisterWriteStage(\n    output\n        complexDstRegWE,\n        complexDstRegNum,\n        complexDstRegData\n    );\n`endif\n\n`ifdef RSD_MARCH_FP_PIPE\n    modport FPRegisterReadStage(\n    input\n        fpSrcRegDataA,\n        fpSrcRegDataB,\n        fpSrcRegDataC,\n    output\n        fpSrcRegNumA,\n        fpSrcRegNumB,\n        fpSrcRegNumC\n    );\n    \n    modport FPRegisterWriteStage(\n    output\n        fpDstRegWE,\n        fpDstRegNum,\n        fpDstRegData\n    );\n`endif\n\n    modport MemoryRegisterReadStage(\n    input\n        memSrcRegDataA,\n        memSrcRegDataB,\n    output\n        memSrcRegNumA,\n        memSrcRegNumB\n    );\n    \n    modport MemoryRegisterWriteStage(\n    output\n        memDstRegWE,\n        memDstRegNum,\n        memDstRegData\n    );\n    \nendinterface : RegisterFileIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for register read.\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport MicroOpTypes::*;\nimport PipelineTypes::*;\nimport RenameLogicTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport LoadStoreUnitTypes::*;\nimport DebugTypes::*;\n\n// \u30b7\u30ea\u30a2\u30e9\u30a4\u30ba\u547d\u4ee4\u304c\u9001\u3089\u308c\u3066\u6765\u305f\u5834\u5408\uff0c\u30d1\u30a4\u30d7\u30e9\u30a4\u30f3\u3092\u9069\u5207\u306b\u30b9\u30c8\u30fc\u30eb\u3055\u305b\u308b\n// \u30b7\u30ea\u30a2\u30e9\u30a4\u30ba\u547d\u4ee4\u306e\u524d\u306e\u547d\u4ee4\u304c\u30b3\u30df\u30c3\u30c8\u3057\u3066 ROB \u304c\u7a7a\u306b\u306a\u308b\u307e\u3067\u5f85\u3063\u3066\uff0c\n// \u3055\u3089\u306b\u30b7\u30ea\u30a2\u30e9\u30a4\u30ba\u547d\u4ee4\u81ea\u8eab\u304c\u30b3\u30df\u30c3\u30c8\u3055\u308c\u308b\u307e\u3067\u4e0a\u6d41\u3092\u30b9\u30c8\u30fc\u30eb\u3055\u305b\u7d9a\u3051\u308b\n//\n// DecodeStage \u304c\u30b7\u30ea\u30a2\u30e9\u30a4\u30ba\u547d\u4ee4\u306e\u307f\u3092\u5fc5\u305a\u5358\u72ec\u3067\u9001\u3063\u3066\u304f\u308b\u3088\u3046\u306b\u3057\u3066\u3044\u308b\u305f\u3081\uff0c\n// \u5148\u982d\u3057\u304b\u307f\u3066\u3044\u306a\u3044\nmodule RenameStageSerializer(\ninput \n    logic clk, rst, stall, clear, activeListEmpty, storeQueueEmpty,\n    OpInfo [RENAME_WIDTH-1:0] opInfo, // Unpacked array of structure corrupts in Modelsim.\n    logic [RENAME_WIDTH-1:0] valid,\noutput \n    logic serialize\n);\n    generate\n        for (genvar i = 1; i < RENAME_WIDTH; i++) begin : assertionBlock\n            `RSD_ASSERT_CLK_FMT(\n                clk, \n                !(opInfo[i].serialized && valid[i]), \n                (\"Multiple serialized ops were sent to RenameStage. (%x, %x)\", opInfo[i].serialized, valid[i])\n            ); \n        end\n    endgenerate\n\n    // Serialize phase\n    typedef enum logic[1:0]\n    {\n        PHASE_NORMAL = 0,               // \u30d5\u30a7\u30c3\u30c1\u7d99\u7d9a\n        PHASE_WAIT_OWN = 2              // \u81ea\u5206\u81ea\u8eab\u306e\u30b3\u30df\u30c3\u30c8\u5f85\u3061\n    } Phase;\n    Phase regPhase, nextPhase;\n\n    always_ff@(posedge clk)   // synchronous rst\n    begin\n        if (rst) begin\n            regPhase <= PHASE_NORMAL;\n        end\n        else if(!stall) begin             // write data\n            regPhase <= nextPhase;\n        end\n    end\n\n    always_comb begin\n        // multiple serialized ops must not be sent to this stage.\n        serialize = FALSE;\n        nextPhase = PHASE_NORMAL;\n        if (clear) begin\n            nextPhase = PHASE_NORMAL; // force reset \n        end\n        if (regPhase == PHASE_NORMAL) begin\n            if (opInfo[0].serialized && valid[0]) begin\n                if (opInfo[0].operand.miscMemOp.fence) begin // Fence\n                    if (!activeListEmpty || !storeQueueEmpty) begin\n                        // Fence must wait for all previous ops to be committed\n                        // AND all committed stores in SQ to be written back\n                        serialize = TRUE;   \n                        nextPhase = PHASE_NORMAL;\n                    end\n                    else begin\n                        // deassert serialize\" for dispatch    \n                        nextPhase = PHASE_WAIT_OWN;\n                    end\n                end \n                else begin // Non-fence\n                    if (!activeListEmpty) begin\n                        // Wait for all previous ops to be committed\n                        serialize = TRUE;   \n                        nextPhase = PHASE_NORMAL;\n                    end\n                    else begin\n                        // deassert serialize\" for dispatch  \n                        nextPhase = PHASE_WAIT_OWN;\n                    end\n                end\n            end\n        end\n        else begin\n            // Wait for a serialized op to be committed\n            if (!activeListEmpty || !storeQueueEmpty) begin\n                serialize = TRUE;\n                nextPhase = PHASE_WAIT_OWN;\n            end\n            else begin\n                nextPhase = PHASE_NORMAL;\n            end\n        end\n    end\n\nendmodule\n\nmodule RenameStage(\n    RenameStageIF.ThisStage port,\n    DecodeStageIF.NextStage prev,\n    RenameLogicIF.RenameStage renameLogic,\n    ActiveListIF.RenameStage activeList,\n    SchedulerIF.RenameStage scheduler,\n    LoadStoreUnitIF.RenameStage loadStoreUnit,\n    RecoveryManagerIF.RenameStage recovery,\n    ControllerIF.RenameStage ctrl,\n    DebugIF.RenameStage debug\n);\n\n    // --- Pipeline registers\n    RenameStageRegPath pipeReg[RENAME_WIDTH];\n    logic regFlush;\n    PC_Path regRecoveredPC;\n\n\n`ifndef RSD_SYNTHESIS\n    `ifndef RSD_VIVADO_SIMULATION\n        // Don't care these values, but avoiding undefined status in Questa.\n        initial begin\n            for (int i = 0; i < RENAME_WIDTH; i++) begin\n                pipeReg[i] = '0;\n            end\n            regRecoveredPC = '0;\n        end\n    `endif\n`endif\n\n    always_ff@( posedge port.clk )   // synchronous rst\n    begin\n        if (port.rst) begin\n            for (int i = 0; i < RENAME_WIDTH; i++) begin\n                pipeReg[i].valid <= FALSE;\n            end\n            regFlush <= '0;\n            regRecoveredPC <= '0;\n        end\n        else if(!ctrl.rnStage.stall) begin             // write data\n            pipeReg <= prev.nextStage;\n            regFlush <= prev.nextFlush;\n            regRecoveredPC <= prev.nextRecoveredPC;\n        end\n    end\n\n    always_comb begin\n        recovery.recoverFromRename = regFlush;\n        recovery.recoveredPC_FromRename = regRecoveredPC;\n        ctrl.rnStageFlushUpper = regFlush;\n    end\n\n\n    // Pipeline controll\n    logic stall, clear;\n    logic empty;\n    logic serialize;\n\n    logic [ RENAME_WIDTH-1:0 ] valid;\n    logic update [ RENAME_WIDTH ];\n    OpInfo [RENAME_WIDTH-1:0] opInfo;\n    ActiveListEntry alEntry [ RENAME_WIDTH ];\n    DispatchStageRegPath nextStage [ RENAME_WIDTH ];\n\n    logic isLoad[RENAME_WIDTH];\n    logic isStore[RENAME_WIDTH];\n    logic isBranch[RENAME_WIDTH];\n\n    logic activeListEmpty;\n    logic storeQueueEmpty;\n\n    always_comb begin\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            valid[i] = pipeReg[i].valid;\n            opInfo[i] = pipeReg[i].opInfo;\n        end\n\n        // The rename stage stalls when resources cannot be allocated.\n        // Inputs of stall/flush requests to the controller must not dependend\n        // on stall/clear signals for avoiding a race condition.\n        ctrl.rnStageSendBubbleLower =\n            (\n                ( |valid ) &&\n                (\n                    !renameLogic.allocatable ||\n                    !scheduler.allocatable ||\n                    !activeList.allocatable ||\n                    !loadStoreUnit.allocatable\n                )\n            ) || serialize;\n\n        stall = ctrl.rnStage.stall;\n        clear = ctrl.rnStage.clear;\n        activeListEmpty = activeList.validEntryNum == 0;\n        storeQueueEmpty = loadStoreUnit.storeQueueEmpty;\n    end\n\n    RenameStageSerializer serializer(\n        port.clk, port.rst, stall, clear, activeListEmpty, storeQueueEmpty,\n        opInfo, \n        valid,\n        serialize\n    );\n\n    logic isEnv[RENAME_WIDTH];\n    always_comb begin\n        //\n        // --- Data to Rename logic\n        //\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            // The rename stage stalls when resources cannot be allocated.\n            update[i] =\n                valid[i] && !stall && !clear;\n        end\n\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            isLoad[i] = \n                (opInfo[i].mopType == MOP_TYPE_MEM) && \n                (opInfo[i].mopSubType.memType == MEM_MOP_TYPE_LOAD);\n            isStore[i] = \n                (opInfo[i].mopType == MOP_TYPE_MEM) && \n                (opInfo[i].mopSubType.memType == MEM_MOP_TYPE_STORE);\n            isEnv[i] = \n                (opInfo[i].mopType == MOP_TYPE_MEM) && \n                (opInfo[i].mopSubType.memType == MEM_MOP_TYPE_ENV);\n            isBranch[i] =\n                (opInfo[i].mopType == MOP_TYPE_INT) &&\n                (opInfo[i].mopSubType.intType inside {INT_MOP_TYPE_BR, INT_MOP_TYPE_RIJ});\n        end\n\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            renameLogic.updateRMT[i] = update[i];\n\n            // Logical register numbers\n            renameLogic.logSrcRegA[i] = isBranch[i] ? opInfo[i].operand.brOp.srcRegNumA : opInfo[i].operand.intOp.srcRegNumA;\n            renameLogic.logSrcRegB[i] = isBranch[i] ? opInfo[i].operand.brOp.srcRegNumB : opInfo[i].operand.intOp.srcRegNumB;\n`ifdef RSD_MARCH_FP_PIPE\n            renameLogic.logSrcRegC[i] = opInfo[i].operand.fpOp.srcRegNumC;\n`endif\n            renameLogic.logDstReg[i] = isBranch[i] ? opInfo[i].operand.brOp.dstRegNum : opInfo[i].operand.intOp.dstRegNum;\n\n            // Read/Write control\n            renameLogic.readRegA[i] = opInfo[i].opTypeA == OOT_REG;\n            renameLogic.readRegB[i] = opInfo[i].opTypeB == OOT_REG;\n`ifdef RSD_MARCH_FP_PIPE\n            renameLogic.readRegC[i] = opInfo[i].opTypeC == OOT_REG;\n`endif\n\n            renameLogic.writeReg[i] = opInfo[i].writeReg;\n\n            // to WAT\n            renameLogic.watWriteRegFromPipeReg[i] = opInfo[i].writeReg && update[i];\n            renameLogic.watWriteIssueQueuePtrFromPipeReg[i] = scheduler.allocatedPtr[i];\n        end\n\n\n        //\n        // --- Renamed operands\n        //\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            // Renamed physical register numbers.\n            nextStage[i].phySrcRegNumA = renameLogic.phySrcRegA[i];\n            nextStage[i].phySrcRegNumB = renameLogic.phySrcRegB[i];\n`ifdef RSD_MARCH_FP_PIPE\n            nextStage[i].phySrcRegNumC = renameLogic.phySrcRegC[i];\n`endif\n            nextStage[i].phyDstRegNum = renameLogic.phyDstReg[i];\n            nextStage[i].phyPrevDstRegNum = renameLogic.phyPrevDstReg[i];\n\n        end\n\n        // Source pointer for a matrix scheduler.\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            // Renamed physical register numbers.\n            nextStage[i].srcIssueQueuePtrRegA = renameLogic.srcIssueQueuePtrRegA[i];\n            nextStage[i].srcIssueQueuePtrRegB = renameLogic.srcIssueQueuePtrRegB[i];\n`ifdef RSD_MARCH_FP_PIPE\n            nextStage[i].srcIssueQueuePtrRegC = renameLogic.srcIssueQueuePtrRegC[i];\n`endif\n        end\n\n\n        //\n        // Active list allocation\n        //\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            activeList.pushTail[i] = update[i];\n\n            `ifndef RSD_DISABLE_DEBUG_REGISTER\n                alEntry[i].opId = pipeReg[i].opId;\n            `endif\n\n            alEntry[i].pc = pipeReg[i].pc;\n\n            alEntry[i].phyPrevDstRegNum = nextStage[i].phyPrevDstRegNum;\n            alEntry[i].phyDstRegNum = nextStage[i].phyDstRegNum;\n            alEntry[i].logDstRegNum = opInfo[i].operand.intOp.dstRegNum;\n            alEntry[i].writeReg = opInfo[i].writeReg;\n            alEntry[i].isLoad = isLoad[i];\n            alEntry[i].isStore = isStore[i];\n            alEntry[i].isBranch = isBranch[i];\n            alEntry[i].isEnv = opInfo[i].operand.systemOp.isEnv;\n            alEntry[i].undefined = opInfo[i].undefined || opInfo[i].unsupported;\n            alEntry[i].last = opInfo[i].last;\n            alEntry[i].prevDependIssueQueuePtr = renameLogic.prevDependIssueQueuePtr[i];\n\n            nextStage[i].activeListPtr = activeList.pushedTailPtr[i];\n        end\n        activeList.pushedTailData = alEntry;\n\n        //\n        // Issue queue allocation\n        //\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            scheduler.allocate[i] = update[i];\n            nextStage[i].issueQueuePtr = scheduler.allocatedPtr[i];\n        end\n\n\n        //\n        // Load/store unit allocation\n        //\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            loadStoreUnit.allocateLoadQueue[i] = update[i] && isLoad[i];\n            loadStoreUnit.allocateStoreQueue[i] = update[i] && isStore[i];\n\n            nextStage[i].loadQueuePtr = loadStoreUnit.allocatedLoadQueuePtr[i];\n            nextStage[i].storeQueuePtr = loadStoreUnit.allocatedStoreQueuePtr[i];\n        end\n\n        // Make read request to Memory Dependent Prediction\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            port.pc[i] = pipeReg[i].pc;\n        end\n        \n        //\n        // --- Pipeline control\n        //\n\n        // 'valid' is invalidate, if 'stall' or 'clear' or 'rst' is enabled.\n        // That is, a op is treated as a NOP.\n        // Otherwise 'valid' is set to a previous stage's 'valid.'\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n            nextStage[i].opId = pipeReg[i].opId;\n`endif\n\n            nextStage[i].valid =\n                ( stall || clear || port.rst ) ? FALSE : valid[i];\n\n            // Decoded micr-op and context.\n            nextStage[i].pc = pipeReg[i].pc;\n            nextStage[i].brPred = pipeReg[i].bPred;\n            nextStage[i].opInfo = opInfo[i];\n\n            // \u4ee5\u4e0b\u306eLSQ\u306e\u30dd\u30a4\u30f3\u30bf\u306fLSQ\u306e\u30ea\u30ab\u30d0\u30ea\u306b\u7528\u3044\u308b\n            nextStage[i].loadQueueRecoveryPtr = loadStoreUnit.allocatedLoadQueuePtr[i];\n            nextStage[i].storeQueueRecoveryPtr = loadStoreUnit.allocatedStoreQueuePtr[i];\n\n        end\n        port.nextStage = nextStage;\n\n        empty = TRUE;\n        for (int i = 0; i < DECODE_WIDTH; i++) begin\n            if (pipeReg[i].valid)\n                empty = FALSE;\n        end\n        ctrl.rnStageEmpty = empty;\n\n        // Debug Register\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n        for ( int i = 0; i < RENAME_WIDTH; i++ ) begin\n            debug.rnReg[i].valid = valid[i];\n            debug.rnReg[i].opId = pipeReg[i].opId;\n        end\n`endif\n    end\n\n\n\nendmodule : RenameStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- RenameStageIF\n// The interface of a rename stage.\n//\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport PipelineTypes::*;\n\n\ninterface RenameStageIF( input logic clk, rst, rstStart );\n    \n    // Paths to the pipeline registers of a next stage.\n    DispatchStageRegPath nextStage [ RENAME_WIDTH ];\n\n    PC_Path pc [ RENAME_WIDTH ];\n    logic memDependencyPred [ RENAME_WIDTH ];\n\n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        nextStage,\n        pc\n    );\n\n    modport NextStage(\n    input\n        nextStage,\n        memDependencyPred\n    );\n\n    modport MemoryDependencyPredictor(\n    input\n        clk,\n        rst,\n        rstStart,\n        pc,\n    output\n        memDependencyPred\n    );\n\n\nendinterface : RenameStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// A pipeline stage for scheduling.\n//\n\n\nimport BasicTypes::*;\nimport MemoryMapTypes::*;\nimport MicroOpTypes::*;\nimport PipelineTypes::*;\nimport SchedulerTypes::*;\nimport ActiveListIndexTypes::*;\nimport DebugTypes::*;\n\nmodule ScheduleStage(\n    ScheduleStageIF.ThisStage port,\n    SchedulerIF.ScheduleStage scheduler,\n    RecoveryManagerIF.ScheduleStage recovery,\n    ControllerIF.ScheduleStage ctrl\n);\n    // Pipeline controll\n    logic stall, clear;\n    logic flush [ ISSUE_WIDTH ];\n    logic valid [ ISSUE_WIDTH ];\n    logic update [ ISSUE_WIDTH ];\n    IssueStageRegPath nextStage [ ISSUE_WIDTH ];\n    IssueQueueIndexPath issueQueuePtr [ ISSUE_WIDTH ];\n    IssueQueueOneHotPath flushIQ_Entry;\n\n    always_comb begin\n\n        stall = ctrl.scStage.stall;\n        clear = ctrl.scStage.clear;\n\n        // Scheduling\n        scheduler.stall = stall;\n\n        flushIQ_Entry = recovery.flushIQ_Entry;\n\n        for (int i = 0; i < ISSUE_WIDTH; i++) begin\n            valid[i] = scheduler.selected[i];\n            issueQueuePtr[i] = scheduler.selectedPtr[i];\n            flush[i] = flushIQ_Entry[issueQueuePtr[i]];\n            update[i] = !stall && !clear && valid[i] && !flush[i];\n\n            // --- Pipeline \u30e9\u30c3\u30c1\u66f8\u304d\u8fbc\u307f\n            // \u30ea\u30bb\u30c3\u30c8or\u30d5\u30e9\u30c3\u30b7\u30e5\u6642\u306fNOP\n            nextStage[i].valid =\n                (stall || clear || port.rst || flush[i]) ? FALSE : valid[i];\n\n            nextStage[i].issueQueuePtr = scheduler.selectedPtr[i];\n\n            if ( i < INT_ISSUE_WIDTH )\n                port.intNextStage[i] = nextStage[i];\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n            else if ( i < INT_ISSUE_WIDTH + COMPLEX_ISSUE_WIDTH )\n                port.complexNextStage[ i-INT_ISSUE_WIDTH ] = nextStage[i];\n`endif\n            else if ( i < INT_ISSUE_WIDTH + COMPLEX_ISSUE_WIDTH + MEM_ISSUE_WIDTH)\n                port.memNextStage[ i-INT_ISSUE_WIDTH-COMPLEX_ISSUE_WIDTH ] = nextStage[i];\n`ifdef RSD_MARCH_FP_PIPE\n            else\n                port.fpNextStage[ i-INT_ISSUE_WIDTH-COMPLEX_ISSUE_WIDTH-MEM_ISSUE_WIDTH] = nextStage[i];\n`endif\n        end\n    end\n\n\nendmodule : ScheduleStage\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// --- DispatchStageIF\n//\n\nimport BasicTypes::*;\nimport PipelineTypes::*;\n\n\ninterface ScheduleStageIF( input logic clk, rst );\n    \n    // Pipeline register\n    IssueStageRegPath intNextStage     [ INT_ISSUE_WIDTH ];\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    IssueStageRegPath complexNextStage [ COMPLEX_ISSUE_WIDTH ];\n`endif\n    IssueStageRegPath memNextStage     [ MEM_ISSUE_WIDTH ];\n`ifdef RSD_MARCH_FP_PIPE\n    IssueStageRegPath fpNextStage     [ FP_ISSUE_WIDTH ];\n`endif\n    \n    modport ThisStage(\n    input\n        clk,\n        rst,\n    output\n        intNextStage,\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n        complexNextStage,\n`endif\n        memNextStage\n`ifdef RSD_MARCH_FP_PIPE\n        ,\n        fpNextStage\n`endif\n    );\n    \n    modport IntNextStage(\n    input\n        intNextStage\n    );\n\n`ifndef RSD_MARCH_UNIFIED_MULDIV_MEM_PIPE\n    modport ComplexNextStage(\n    input\n        complexNextStage\n    );\n`endif\n\n    modport MemNextStage(\n    input\n        memNextStage\n    );\n\n`ifdef RSD_MARCH_FP_PIPE\n    modport FPNextStage(\n    input\n        fpNextStage\n    );\n`endif\n\nendinterface : ScheduleStageIF\n\n\n\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// ARM shifter unit (32bit)\n//\n// Todo: Rotation operation in a register mode when its shift amount is zero is \n// not implemented correctly and must be fixed.\n// \n\nimport BasicTypes::*;\nimport OpFormatTypes::*;\n\n\n//\n// An straightforward implementation of a shifter unit.\n// Do not remove this implementation because this implementation is used for\n// verification.\n//\nmodule OrgShifter(\ninput\n    ShiftOperandType shiftOperandType,\n    ShiftType shiftType,\n    ShiftAmountPath immShiftAmount,\n    ShiftAmountPath regShiftAmount,\n    DataPath dataIn,\n    logic carryIn,\noutput\n    DataPath dataOut,\n    logic carryOut\n);\n\n    typedef struct {\n        DataPath dataOut; \n        logic    carryOut;\n    } ShiftResult;\n    \n    //\n    // --- Immediate shift\n    //\n    function automatic ShiftResult OpImmShift(\n        ShiftType shiftType, \n        ShiftAmountPath shiftAmount,\n        DataPath dataIn,\n        logic    carryIn \n    );\n        logic [DATA_WIDTH:0] shiftTmp;  // not DataPath\n        ShiftResult result;\n        DataPath dataOut;\n        logic    carryOut;\n        \n        case( shiftType ) \n\n        // Logical shift left\n        default: begin\n        //ST_LSL: begin\n            if( shiftAmount == 0 ) begin\n                dataOut  = dataIn;\n                carryOut = carryIn;\n            end\n            else begin\n                shiftTmp = dataIn << shiftAmount;\n                dataOut  = shiftTmp[DATA_WIDTH-1:0];\n                carryOut = shiftTmp[DATA_WIDTH];\n            end\n        end\n        \n        // Logical shift right\n        ST_LSR: begin\n            if( shiftAmount == 0 ) begin\n                dataOut  = 0;\n                carryOut = dataIn[DATA_WIDTH-1];\n            end\n            else begin\n                shiftTmp = {dataIn, 1'b0} >> shiftAmount;\n                dataOut  = shiftTmp[DATA_WIDTH:1];\n                carryOut = shiftTmp[0];\n            end\n        end\n                    \n        // Arithmetic shift right\n        ST_ASR: begin\n            if( shiftAmount == 0 ) begin\n                if( dataIn[DATA_WIDTH-1] == 0 ) begin\n                    dataOut  = 0;\n                    carryOut = dataIn[DATA_WIDTH-1];\n                end\n                else begin\n                    dataOut  = 32'hffffffff;\n                    carryOut = dataIn[DATA_WIDTH-1];\n                end\n            end \n            else begin\n                shiftTmp = {{DATA_WIDTH{dataIn[DATA_WIDTH-1]}}, dataIn, 1'b0} >> shiftAmount;\n                dataOut  = shiftTmp[DATA_WIDTH:1];\n                carryOut = shiftTmp[0];\n            end\n        end\n\n        // RRX/Rotate\n        ST_ROR: begin\n            if( shiftAmount == 0 ) begin\n                dataOut  = {carryIn, dataIn[DATA_WIDTH-1:1]};\n                carryOut = dataIn[0];\n            end\n            else begin\n                shiftTmp = {dataIn, dataIn, 1'b0} >> shiftAmount;\n                dataOut  = shiftTmp[DATA_WIDTH:1];\n                carryOut = shiftTmp[0];\n            end\n        end\n        endcase\n        \n        result.dataOut = dataOut;\n        result.carryOut = carryOut;\n        return result;\n    endfunction : OpImmShift\n    \n    \n    \n    //\n    // --- Register shift\n    // \n    //  Todo:\u30b7\u30d5\u30c8\u91cf\u304c32\u3092\u8d85\u3048\u305f\u5834\u5408\u306e\u6319\u52d5\u304c\u304a\u304b\u3057\u3044\n    //\n    function automatic ShiftResult OpRegShift(\n    input\n        ShiftType shiftType, \n        ShiftAmountPath shiftAmount,\n        DataPath           dataIn,\n        logic [4:0]        shiftIn,\n        logic              carryIn \n    );\n\n        logic [DATA_WIDTH:0] shiftTmp;  // not DataPath\n        DataPath    dataOut;\n        logic       carryOut;\n        ShiftResult result;\n        \n        case( shiftType ) \n\n        // Logical shift left\n        //ST_LSL: begin\n        default: begin\n            if( shiftIn == 0 ) begin\n                dataOut  = dataIn;\n                carryOut = carryIn;\n            end\n            else begin\n                shiftTmp = dataIn << shiftIn;\n                dataOut  = shiftTmp[DATA_WIDTH-1:0];\n                carryOut = shiftTmp[DATA_WIDTH];\n            end\n        end\n        \n        // Logical shift right\n        ST_LSR: begin\n            if( shiftIn == 0 ) begin\n                dataOut  = 0;\n                carryOut = dataIn[DATA_WIDTH-1];\n            end\n            else begin\n                shiftTmp = {dataIn, 1'b0} >> shiftIn;\n                dataOut  = shiftTmp[DATA_WIDTH:1];\n                carryOut = shiftTmp[0];\n            end\n        end\n                    \n        // Arithmetic shift right\n        ST_ASR: begin\n            if( shiftIn == 0 ) begin\n                if( dataIn[DATA_WIDTH-1] == 0 ) begin\n                    dataOut  = 0;\n                    carryOut = dataIn[DATA_WIDTH-1];\n                end\n                else begin\n                    dataOut  = 32'hffffffff;\n                    carryOut = dataIn[DATA_WIDTH-1];\n                end\n            end \n            else begin\n                shiftTmp = {{DATA_WIDTH{dataIn[DATA_WIDTH-1]}}, dataIn, 1'b0} >> shiftAmount;\n                dataOut  = shiftTmp[DATA_WIDTH:1];\n                carryOut = shiftTmp[0];\n            end\n        end\n\n        // Rotate\n        ST_ROR: begin\n            if( shiftIn == 0 ) begin\n                dataOut  = {carryIn, dataIn[DATA_WIDTH-1:1]};\n                carryOut = dataIn[0];\n            end\n            else begin\n                shiftTmp = {dataIn, dataIn, 1'b0} >> shiftIn;\n                dataOut  = shiftTmp[DATA_WIDTH:1];\n                carryOut = shiftTmp[0];\n            end\n        end\n        endcase\n\n        result.dataOut = dataOut;\n        result.carryOut = carryOut;\n        return result;\n    endfunction : OpRegShift\n\n    \n    ShiftResult shiftResult;\n    always_comb begin\n        case( shiftType )\n\n        // Immediate\n        //SOT_IMM: begin\n\n        // Immediate shift\n        default: begin\n        //SOT_IMM_SHIFT: begin\n            shiftResult = OpImmShift( shiftType, immShiftAmount, dataIn, carryIn );\n        end\n        \n        // Register shift\n        SOT_REG_SHIFT: begin\n            shiftResult = OpRegShift( shiftType, immShiftAmount, dataIn, regShiftAmount, carryIn );\n        end\n\n        endcase\n        \n        dataOut = shiftResult.dataOut;\n        carryOut = shiftResult.carryOut;\n    end\n    \n\nendmodule : OrgShifter\n\n\n\n//\n// --- An optimized implementation of a shifter unit.\n//\nmodule Shifter(\ninput\n    ShiftOperandType shiftOperandType,\n    ShiftType shiftType,\n    ShiftAmountPath immShiftAmount,\n    ShiftAmountPath regShiftAmount,\n    DataPath dataIn,\n    logic carryIn,\noutput\n    DataPath dataOut,\n    logic carryOut\n);\n\n    ShiftAmountPath shiftAmount;\n\n    // This shifter unit is implemented with an unified 65-to-33 right shifter.\n    logic [DATA_WIDTH*2+1:0] unifiedShiftTmp;\n    DataPath unifiedShiftHighIn;\n    DataPath unifiedShiftLowIn;\n    logic [DATA_WIDTH+1:0] unifiedShiftOut;\n    logic [SHIFT_AMOUNT_BIT_SIZE:0] unifiedShiftAmount;\n    logic isShiftZero;\n\n    always_comb begin\n        \n        //\n        // --- Select a shift amount.\n        //\n        case( shiftOperandType )\n\n            // Immediate shift\n            default: begin        //SOT_IMM_SHIFT: begin\n                shiftAmount = immShiftAmount;\n            end\n            \n            // Register shift\n            SOT_REG_SHIFT: begin\n                shiftAmount = regShiftAmount;\n            end\n\n        endcase\n        \n\n        isShiftZero = (shiftAmount == 0) ? TRUE : FALSE;\n        \n\n        case( shiftType ) \n\n        // Logical shift left\n        ST_LSL: begin\n            //if( shiftAmount == 0 ) begin\n            //    dataOut  = dataIn;\n            //    carryOut = carryIn;\n            //end\n            //else begin\n            //    shiftTmp = dataIn << shiftAmount;\n            //    dataOut  = shiftTmp[DATA_WIDTH-1:0];\n            //    carryOut = shiftTmp[DATA_WIDTH];\n            //end        \n            unifiedShiftAmount = DATA_WIDTH - shiftAmount;\n            unifiedShiftHighIn = dataIn;\n            unifiedShiftLowIn = 0;\n        end\n        \n        // Logical shift right\n        ST_LSR: begin\n        \n            //if( shiftAmount == 0 ) begin\n            //    dataOut  = 0;\n            //    carryOut = dataIn[DATA_WIDTH-1];\n            //end\n            //else begin\n            //    shiftTmp = {dataIn, 1'b0} >> shiftAmount;\n            //    dataOut  = shiftTmp[DATA_WIDTH:1];\n            //    carryOut = shiftTmp[0];\n            //end        \n        \n            //unifiedShiftAmount = isShiftZero ? DATA_WIDTH : shiftAmount;\n            unifiedShiftAmount = shiftAmount;\n            unifiedShiftHighIn = 0;\n            unifiedShiftLowIn = dataIn;\n        end\n                    \n        // Arithmetic shift right\n        ST_ASR: begin\n            //if( shiftAmount == 0 ) begin\n            //    if( dataIn[DATA_WIDTH-1] == 0 ) begin\n            //        dataOut  = 0;\n            //        carryOut = dataIn[DATA_WIDTH-1];\n            //    end\n            //    else begin\n            //        dataOut  = 32'hffffffff;\n            //        carryOut = dataIn[DATA_WIDTH-1];\n            //    end\n            //end \n            //else begin\n            //    shiftTmp = {dataIn, 1'b0} >>> shiftAmount;\n            //    dataOut  = shiftTmp[DATA_WIDTH:1];\n            //    carryOut = shiftTmp[0];\n            //end\n            //unifiedShiftAmount = isShiftZero ? DATA_WIDTH : shiftAmount;\n            unifiedShiftAmount = shiftAmount;\n            unifiedShiftHighIn = {DATA_WIDTH{dataIn[DATA_WIDTH-1]}};\n            unifiedShiftLowIn = dataIn;\n        end\n\n        // RRX/Rotate\n        ST_ROR: begin\n            //if( shiftAmount == 0 ) begin\n            //    dataOut  = {carryIn, dataIn[DATA_WIDTH-1:1]};\n            //    carryOut = dataIn[0];\n            //end\n            //else begin\n            //    shiftTmp = {dataIn, dataIn, 1'b0} >> shiftAmount;\n            //    dataOut  = shiftTmp[DATA_WIDTH:1];\n            //    carryOut = shiftTmp[0];\n            //end\n            //unifiedShiftAmount = isShiftZero ? 1 : shiftAmount;\n            unifiedShiftAmount = shiftAmount;\n            unifiedShiftHighIn = {dataIn[DATA_WIDTH-1:1], (isShiftZero ? carryIn : dataIn[0])};\n            unifiedShiftLowIn = dataIn;\n        end\n        endcase\n\n\n        // Source of a 65-to-33 right shifter.\n        unifiedShiftTmp = {carryIn, unifiedShiftHighIn, unifiedShiftLowIn, 1'b0};\n        \n\n        // Optimized implementation of 65-to-33 right shifter.\n        // Original implementation:\n        //   unifiedShiftOut = unifiedShiftTmp >> unifiedShiftAmount;\n        /*\n        unifiedShiftTmp = unifiedShiftAmount[5] ? unifiedShiftTmp[65:32] : unifiedShiftTmp[64:0];\n        unifiedShiftTmp = unifiedShiftAmount[4] ? unifiedShiftTmp[64:16] : unifiedShiftTmp[48:0];\n        unifiedShiftTmp = unifiedShiftAmount[3] ? unifiedShiftTmp[48:8] :  unifiedShiftTmp[40:0];\n        unifiedShiftTmp = unifiedShiftAmount[2] ? unifiedShiftTmp[40:4] :  unifiedShiftTmp[36:0];\n        unifiedShiftTmp = unifiedShiftAmount[1] ? unifiedShiftTmp[36:2] :  unifiedShiftTmp[34:0];\n        unifiedShiftTmp = unifiedShiftAmount[0] ? unifiedShiftTmp[34:1] :  unifiedShiftTmp[33:0];\n        */\n        \n        // Each 4:1 selector will be synthesized to 6:1 LUT.\n        case(unifiedShiftAmount[5:4])\n            2'h3: unifiedShiftTmp = 49'hx;\n            2'h2: unifiedShiftTmp = {15'hx, unifiedShiftTmp[65:32]};\n            2'h1: unifiedShiftTmp = unifiedShiftTmp[64:16];\n            2'h0: unifiedShiftTmp = unifiedShiftTmp[48:0];\n        endcase\n        case(unifiedShiftAmount[3:2])\n            2'h3: unifiedShiftTmp = unifiedShiftTmp[48:12];\n            2'h2: unifiedShiftTmp = unifiedShiftTmp[44:8];\n            2'h1: unifiedShiftTmp = unifiedShiftTmp[40:4];\n            2'h0: unifiedShiftTmp = unifiedShiftTmp[36:0];\n        endcase\n        case(unifiedShiftAmount[1:0])\n            2'h3: unifiedShiftTmp = unifiedShiftTmp[36:3];\n            2'h2: unifiedShiftTmp = unifiedShiftTmp[35:2];\n            2'h1: unifiedShiftTmp = unifiedShiftTmp[34:1];\n            2'h0: unifiedShiftTmp = unifiedShiftTmp[33:0];\n        endcase\n\n        unifiedShiftOut = unifiedShiftTmp;\n        \n        \n        // Output results.\n        dataOut = unifiedShiftOut[DATA_WIDTH:1];\n        \n        case( shiftType ) \n            // Logical shift left\n            ST_LSL: carryOut = unifiedShiftOut[DATA_WIDTH+1];\n            \n            // Logical shift right\n            // Arithmetic shift right\n            // RRX/Rotate\n            default: carryOut = unifiedShiftOut[0];\n        endcase\n    end\n    \n\nendmodule : Shifter\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Store queue\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport CacheSystemTypes::*;\nimport OpFormatTypes::*;\nimport LoadStoreUnitTypes::*;\nimport MemoryMapTypes::*;\nimport DebugTypes::*;\n\nmodule StoreCommitter(\n    LoadStoreUnitIF.StoreCommitter port,\n    RecoveryManagerIF.StoreCommitter recovery,\n    IO_UnitIF.StoreCommitter ioUnit,\n    DebugIF.StoreCommitter debug,\n    PerformanceCounterIF.StoreCommitter perfCounter\n);\n\n    // State machine\n    typedef enum logic\n    {\n        PHASE_COMMIT = 0,\n        PHASE_RECOVER = 1\n    } Phase;\n    Phase phase;\n    Phase nextPhase;\n\n    StoreQueueCountPath unfinishedStoreNum;\n    StoreQueueCountPath nextUnfinishedStoreNum;\n\n    always_ff @( posedge port.clk ) begin\n        if (port.rst) begin\n            phase <= PHASE_COMMIT;\n            unfinishedStoreNum <= '0;\n        end\n        else begin\n            phase <= nextPhase;\n            unfinishedStoreNum <= nextUnfinishedStoreNum;\n        end\n    end\n\n    always_comb begin\n        // Decide a next phase.\n        if(port.rst) begin\n            nextPhase = PHASE_COMMIT;\n        end\n        else if (recovery.toRecoveryPhase) begin\n            nextPhase = PHASE_RECOVER;\n        end\n        else if (phase == PHASE_RECOVER ) begin\n            // All entries are released.\n            // Store Queue is recovered in one cycle.\n            nextPhase = PHASE_COMMIT;\n        end\n        else begin\n            nextPhase = phase;\n        end\n    end\n\n    MSHR_Phase portMSHRPhase[MSHR_NUM];\n    logic portStoreHasAllocatedMSHR;\n    MSHR_IndexPath portStoreMSHRID;\n    always_comb begin\n        for (int i = 0; i < MSHR_NUM; i++) begin\n            portMSHRPhase[i] = port.mshrPhase[i];\n        end\n        portStoreHasAllocatedMSHR = port.storeHasAllocatedMSHR[0];\n        portStoreMSHRID = port.storeMSHRID[0];\n    end\n\n\n    // The pipeline register of store commit pipeline.\n    logic stallStoreTagStage;\n    typedef struct packed {\n        logic valid;\n        logic condEnabled;\n        LSQ_BlockDataPath data;\n        LSQ_BlockAddrPath blockAddr;\n        LSQ_BlockWordEnablePath wordWE;\n        LSQ_WordByteEnablePath byteWE;\n        logic isIO;\n        logic isUncachable;\n    } StgReg;\n\n    StgReg tagStagePipeReg;\n    StgReg nextTagStagePipeReg;\n    StgReg dataStagePipeReg;\n    StgReg nextDataStagePipeReg;\n    logic headStoreHasAllocatedMSHRPipeReg;\n    MSHR_IndexPath storeMSHRID;\n\n    always_ff @( posedge port.clk ) begin\n        if (port.rst) begin\n            tagStagePipeReg <= '0;\n            dataStagePipeReg <= '0;\n            headStoreHasAllocatedMSHRPipeReg <= FALSE;\n            storeMSHRID <= '0;\n        end\n        else begin\n            if (!stallStoreTagStage) begin\n                tagStagePipeReg <= nextTagStagePipeReg;\n            end\n            dataStagePipeReg <= nextDataStagePipeReg;\n\n            // Memorize whether a head store has allocated a MSHR entry or not.\n            if (!stallStoreTagStage) begin\n                headStoreHasAllocatedMSHRPipeReg <= FALSE;\n            end\n            else if (!headStoreHasAllocatedMSHRPipeReg) begin\n                headStoreHasAllocatedMSHRPipeReg <= portStoreHasAllocatedMSHR;\n            end\n\n            // Memorize the allocated mshr id when the head store allocates a mshr entry.\n            if (portStoreHasAllocatedMSHR) begin\n                storeMSHRID <= portStoreMSHRID;\n            end\n        end\n    end\n\n    // Generate DCache write enable signals.\n    function automatic DCacheByteEnablePath GenerateDCacheWriteEnable(\n        LSQ_BlockWordEnablePath wordWE,\n        LSQ_WordByteEnablePath byteWE, \n        LSQ_BlockAddrPath blockAddr\n    );\n        DCacheByteEnablePath ret;\n        LSQ_WordByteEnablePath [LSQ_BLOCK_WORD_WIDTH-1:0] we;\n\n        for (int i = 0; i < LSQ_BLOCK_WORD_WIDTH; i++) begin\n            if (wordWE[i])\n                we[i] = byteWE;\n            else\n                we[i] = '0;\n        end\n\n        // LSQ block to DCache\n        ret = we;\n        ret = ret << (\n            LSQ_BLOCK_BYTE_WIDTH * \n            LSQ_SelectBits(blockAddr, 0, DCACHE_LINE_BYTE_NUM_BIT_WIDTH-LSQ_BLOCK_BYTE_WIDTH_BIT_SIZE)\n        );\n        return ret;\n    endfunction\n\n    function automatic DCacheLinePath GenerateDCacheLine(\n        LSQ_BlockDataPath data\n    );\n        // WE \u3067\u4e0d\u8981\u306a\u90e8\u5206\u306f\u843d\u3068\u3055\u308c\u308b\u306e\u3067\uff0c\u5358\u7d14\u306b\u30c7\u30e5\u30d7\u30ea\u30b1\u30fc\u30c8\u3059\u308b\n        DCacheLinePath line;\n        line = '0;\n        for (int i = 0; i < DCACHE_LINE_BYTE_NUM/LSQ_BLOCK_BYTE_WIDTH; i++) begin\n             line[i*LSQ_BLOCK_WIDTH +: LSQ_BLOCK_WIDTH] = data;\n        end\n        return line;\n    endfunction\n\n\n    // Pipeline stage structure:\n    // | Commit | SQ | Tag | Data\n    //\n    // Commit: The processor commit stage.\n    //\n    // SQ:      Read a store queue entry.\n    // Tag:     Access tag array & hit/miss detection.\n    // Data:    Write data array.\n\n\n    logic dcWriteReq;\n    PhyAddrPath dcWriteAddr;\n    DCacheLinePath dcWriteData;\n    logic dcWriteUncachable;\n    logic isIO;\n    logic [DCACHE_LINE_BYTE_NUM-1:0] dcWriteByteWE;\n    logic isUncachable;\n    StoreQueueIndexPath retiredStoreQueuePtr;\n    // --- SQ stage.\n    always_comb begin\n        retiredStoreQueuePtr =\n            port.storeQueueHeadPtr +\n            (tagStagePipeReg.valid ? 1 : 0) +\n            (dataStagePipeReg.valid ? 1 : 0);\n        if (retiredStoreQueuePtr >= STORE_QUEUE_ENTRY_NUM) begin\n            // Compensate the index to point in the store queue\n            retiredStoreQueuePtr -= STORE_QUEUE_ENTRY_NUM;\n        end\n\n        port.retiredStoreQueuePtr = retiredStoreQueuePtr;\n\n        nextUnfinishedStoreNum = unfinishedStoreNum;\n        if (port.commitStore) begin\n            nextUnfinishedStoreNum += port.commitStoreNum;\n        end\n\n        isIO = \n            IsPhyAddrIO(\n                LSQ_ToFullPhyAddrFromBlockAddrAndWordWE(\n                    port.retiredStoreLSQ_BlockAddr, port.retiredStoreWordWE\n                )\n            );\n        \n        isUncachable =\n            IsPhyAddrUncachable(\n                LSQ_ToFullPhyAddrFromBlockAddrAndWordWE(\n                    port.retiredStoreLSQ_BlockAddr, port.retiredStoreWordWE\n                )\n            );\n\n        port.busyInRecovery = phase == PHASE_RECOVER;\n\n        if (unfinishedStoreNum == 0) begin\n            // There is no entry for pushing to the store commit pipeline.\n            nextTagStagePipeReg = '0;\n            nextTagStagePipeReg.valid = FALSE;\n            dcWriteReq = FALSE;\n        end\n        else begin\n            nextTagStagePipeReg.isIO = isIO;\n            nextTagStagePipeReg.isUncachable = isUncachable;\n\n            // Push an store access to the store commit pipeline.\n            if (!port.retiredStoreCondEnabled || isIO) begin\n                dcWriteReq = FALSE;\n                nextTagStagePipeReg.valid = TRUE;   // Push for releasing an entry..\n            end\n            else begin\n                dcWriteReq = !stallStoreTagStage;\n                nextTagStagePipeReg.valid = port.dcWriteReqAck;\n            end\n\n            nextTagStagePipeReg.condEnabled = port.retiredStoreCondEnabled;\n            nextTagStagePipeReg.blockAddr = port.retiredStoreLSQ_BlockAddr;\n            nextTagStagePipeReg.data = port.retiredStoreData;\n            nextTagStagePipeReg.wordWE = port.retiredStoreWordWE;\n            nextTagStagePipeReg.byteWE = port.retiredStoreByteWE;\n\n            if (!stallStoreTagStage && nextTagStagePipeReg.valid) begin\n                nextUnfinishedStoreNum--;\n            end\n\n        end\n\n        if (stallStoreTagStage) begin\n            // When a head store has allocated a mshr entry, it skips writebacking its data.\n            if (headStoreHasAllocatedMSHRPipeReg) begin\n                dcWriteReq = FALSE;\n            end\n            else begin\n                dcWriteReq = tagStagePipeReg.condEnabled;\n            end\n\n            dcWriteAddr =\n                LSQ_ToFullAddrFromBlockAddr(tagStagePipeReg.blockAddr);\n            dcWriteData =\n                GenerateDCacheLine(tagStagePipeReg.data);\n            dcWriteByteWE =\n                GenerateDCacheWriteEnable(tagStagePipeReg.wordWE, tagStagePipeReg.byteWE, tagStagePipeReg.blockAddr);\n            dcWriteUncachable = \n                tagStagePipeReg.isUncachable;\n        end\n        else begin\n            dcWriteAddr =\n                LSQ_ToFullAddrFromBlockAddr(port.retiredStoreLSQ_BlockAddr);\n            dcWriteData = \n                GenerateDCacheLine(port.retiredStoreData);\n            dcWriteByteWE =\n                GenerateDCacheWriteEnable(port.retiredStoreWordWE, port.retiredStoreByteWE, port.retiredStoreLSQ_BlockAddr);\n            dcWriteUncachable =\n                isUncachable;\n        end\n\n        port.dcWriteReq = dcWriteReq;\n        port.dcWriteData = dcWriteData;\n        port.dcWriteByteWE = dcWriteByteWE;\n        port.dcWriteAddr = dcWriteAddr;\n        port.dcWriteUncachable = dcWriteUncachable;\n    end\n\n    // --- Tag stage\n    logic finishWriteBack;\n    always_comb begin\n        finishWriteBack = FALSE;\n        if (tagStagePipeReg.valid) begin\n            if(!tagStagePipeReg.condEnabled || tagStagePipeReg.isIO) begin\n                stallStoreTagStage = FALSE;\n            end\n            else if (headStoreHasAllocatedMSHRPipeReg) begin\n                // When a head store has allocated a mshr entry, stall until its data is written to cache by MSHR.\n                if (portMSHRPhase[storeMSHRID] > MSHR_PHASE_MISS_WRITE_CACHE_REQUEST) begin\n                    stallStoreTagStage = FALSE;\n                    finishWriteBack = TRUE;\n                end\n                else begin\n                    stallStoreTagStage = TRUE;\n                end\n            end\n            else begin\n                stallStoreTagStage = !port.dcWriteHit;   // Stall if miss!\n            end\n        end\n        else begin\n            stallStoreTagStage = FALSE;\n        end\n\n        nextDataStagePipeReg = tagStagePipeReg;\n        if (stallStoreTagStage) begin\n            nextDataStagePipeReg.valid = FALSE;\n        end\n\n`ifndef RSD_DISABLE_PERFORMANCE_COUNTER\n        for (int i = 0; i < STORE_ISSUE_WIDTH; i++) begin\n            perfCounter.storeMiss[i] = i == 0 ? finishWriteBack : FALSE;  // Only supports a single store port \n        end\n`endif\n    end\n\n    // Whether to release the head entry(s) of the SQ.\n    logic releaseStoreQueueHead;\n    // The number of released entries.\n    CommitLaneCountPath releaseStoreQueueHeadEntryNum;\n    // --- Data stage\n    always_comb begin\n        ioUnit.ioWE = FALSE;\n        ioUnit.ioWriteDataIn = \n            LSQ_ToScalarWordDataFromBlockData(dataStagePipeReg.data, dataStagePipeReg.wordWE);\n        ioUnit.ioWriteAddrIn = \n            LSQ_ToFullPhyAddrFromBlockAddrAndWordWE(dataStagePipeReg.blockAddr, dataStagePipeReg.wordWE);\n        if (dataStagePipeReg.valid) begin\n            releaseStoreQueueHeadEntryNum = 1;\n            releaseStoreQueueHead = TRUE;  // Ops whose conditions are not invalid must be released.\n            if (dataStagePipeReg.condEnabled && dataStagePipeReg.isIO) begin\n                ioUnit.ioWE = TRUE;\n            end\n        end\n        else begin\n            releaseStoreQueueHeadEntryNum = 0;\n            releaseStoreQueueHead = FALSE;\n        end\n\n        port.releaseStoreQueueHeadEntryNum = releaseStoreQueueHeadEntryNum;\n        port.releaseStoreQueueHead = releaseStoreQueueHead;\n    end\n\n`ifndef RSD_DISABLE_DEBUG_REGISTER\n    always_comb begin\n        debug.loadStoreUnitAllocatable = port.allocatable;\n        debug.storeCommitterPhase = phase;\n        debug.storeQueueCount = port.storeQueueCount;\n        debug.busyInRecovery = port.busyInRecovery;\n        debug.storeQueueEmpty = port.storeQueueEmpty;\n    end\n`endif\n\n    `RSD_ASSERT_CLK(\n        port.clk,\n        port.rst || (unfinishedStoreNum <= STORE_QUEUE_ENTRY_NUM),\n        \"Committed store num is larger than store queue entry num.\" \n    );\n\n\n    `RSD_ASSERT_CLK(\n        port.clk,\n        port.rst || !(phase == PHASE_RECOVER && port.commitStore && port.commitStoreNum > 0),\n        \"Stores are committed in recovery phase.\" \n    );\n\nendmodule : StoreCommitter\n\n"}
{"text": "// Copyright 2019- RSD contributors.\n// Licensed under the Apache License, Version 2.0, see LICENSE for details.\n\n\n//\n// Store queue\n//\n\n`include \"BasicMacros.sv\"\n\nimport BasicTypes::*;\nimport CacheSystemTypes::*;\nimport OpFormatTypes::*;\nimport LoadStoreUnitTypes::*;\nimport MemoryMapTypes::*;\n\n\n\nmodule StoreQueue(\n    LoadStoreUnitIF.StoreQueue port,\n    RecoveryManagerIF.StoreQueue recovery\n);\n\n    // \u30b9\u30c8\u30a2\u30c7\u30fc\u30bf\u3092\u30a2\u30c9\u30ec\u30b9\u306e\u30aa\u30d5\u30bb\u30c3\u30c8\u306b\u5408\u308f\u305b\u3066\u30b7\u30d5\u30c8\n    // \u30d9\u30af\u30c8\u30eb\u30c7\u30fc\u30bf\u306e\u5834\u5408\u306f\u3001\u305d\u306e\u307e\u307e\n    function automatic void GenerateStoreData(\n        output LSQ_BlockDataPath dataOut,\n        input DataPath dataIn,\n        input LSQ_BlockDataPath blockDataIn,\n        input PhyAddrPath addr,\n        input MemAccessMode mode\n    );\n        dataOut = dataIn;\n        dataOut = dataOut << ( addr[ LSQ_BLOCK_BYTE_WIDTH_BIT_SIZE-1:0 ] * BYTE_WIDTH );\n    endfunction\n\n    //\n    // Signals\n    //\n\n    // The content of the head of a SQ.\n    StoreQueueAddrEntry headAddrEntry;\n    StoreQueueDataEntry headDataEntry;\n\n    // The pointer of released entry.\n    StoreQueueIndexPath releasedStoreQueuePtr;\n\n    // The head/tail pointers of a store queue.\n    StoreQueueIndexPath headPtr;\n    StoreQueueIndexPath tailPtr;\n\n    // FIFO controller.\n    RenameLaneCountPath pushCount;\n    StoreQueueCountPath curCount;\n    logic push;\n\n    // Parameter: Size, Initial head pos., Initial tail pos., Initial count\n    SetTailMultiWidthQueuePointer #( STORE_QUEUE_ENTRY_NUM, 0, 0, 0, RENAME_WIDTH, COMMIT_WIDTH )\n        storeQueuePointer(\n            .clk(port.clk),\n            .rst(port.rst), // On flush, pointers are recovered by the store committer.\n            .pop(port.releaseStoreQueueHead),\n            .popCount(port.releaseStoreQueueHeadEntryNum),\n            .push(push),\n            .pushCount(pushCount),\n            .setTail(recovery.toRecoveryPhase),\n            .setTailPtr(recovery.storeQueueRecoveryTailPtr),\n            .count(curCount),\n            .headPtr(headPtr),\n            .tailPtr(tailPtr)\n        );\n\n    always_comb begin\n\n        pushCount = 0;\n        for (int i = 0; i < RENAME_WIDTH; i++) begin\n            if (tailPtr + pushCount < STORE_QUEUE_ENTRY_NUM) begin\n                port.allocatedStoreQueuePtr[i] = tailPtr + pushCount;\n            end\n            else begin\n                // Out of range of store queue\n                port.allocatedStoreQueuePtr[i] = \n                    tailPtr + pushCount - STORE_QUEUE_ENTRY_NUM;\n            end\n            pushCount += port.allocateStoreQueue[i];\n        end\n        push = pushCount > 0;\n\n        port.storeQueueCount = curCount;\n        port.storeQueueAllocatable =\n            (curCount <= STORE_QUEUE_ENTRY_NUM - RENAME_WIDTH - 1) ? TRUE : FALSE;\n        port.storeQueueEmpty = curCount == 0;\n\n        recovery.storeQueueHeadPtr = headPtr;\n    end\n\n\n    //\n    // SQ's address and data storage.\n    //\n\n    // The address part of a SQ.\n    StoreQueueAddrEntry storeQueue[STORE_QUEUE_ENTRY_NUM-1:0];\n\n    logic  executeStore[STORE_ISSUE_WIDTH];\n    LSQ_BlockAddrPath executedStoreAddr[STORE_ISSUE_WIDTH];\n    LSQ_BlockWordEnablePath executedStoreWordWE[STORE_ISSUE_WIDTH];\n    LSQ_WordByteEnablePath executedStoreByteWE[STORE_ISSUE_WIDTH];\n    logic executedStoreCondEnabled[STORE_ISSUE_WIDTH];\n    logic executedStoreRegValid[STORE_ISSUE_WIDTH];\n    StoreQueueIndexPath executedStoreQueuePtrByStore[STORE_ISSUE_WIDTH];\n\n    always_ff @(posedge port.clk) begin\n        if(port.rst) begin\n            for( int i = 0; i < STORE_QUEUE_ENTRY_NUM; i++) begin\n                storeQueue[i].finished <= FALSE;\n                storeQueue[i].address <= '0;\n                storeQueue[i].wordWE <= '0;\n                storeQueue[i].byteWE <= '0;\n            end\n        end\n        else begin\n            for (int i = 0; i < STORE_ISSUE_WIDTH; i++) begin\n                if( executeStore[i] ) begin\n                    storeQueue[ executedStoreQueuePtrByStore[i] ].regValid <= executedStoreRegValid[i];\n                    storeQueue[ executedStoreQueuePtrByStore[i] ].finished <= executedStoreCondEnabled[i];\n                    storeQueue[ executedStoreQueuePtrByStore[i] ].address <= executedStoreAddr[i];\n                    storeQueue[ executedStoreQueuePtrByStore[i] ].wordWE <= executedStoreWordWE[i];\n                    storeQueue[ executedStoreQueuePtrByStore[i] ].byteWE <= executedStoreByteWE[i];\n                end\n            end\n\n            for (int i = 0; i < RENAME_WIDTH; i++) begin\n                if (port.allocateStoreQueue[i]) begin\n                    storeQueue[ port.allocatedStoreQueuePtr[i] ].finished <= FALSE;\n                end\n            end\n        end\n    end\n\n    always_comb begin\n        // Pick store execution results.\n        for (int i = 0; i < STORE_ISSUE_WIDTH; i++) begin\n            executeStore[i] = port.executeStore[i];\n            executedStoreAddr[i] =\n                LSQ_ToBlockAddr(port.executedStoreAddr[i]);\n            executedStoreCondEnabled[i] = port.executedStoreCondEnabled[i];\n            executedStoreRegValid[i] = port.executedStoreRegValid[i];\n            executedStoreQueuePtrByStore[i] = port.executedStoreQueuePtrByStore[i];\n\n            executedStoreWordWE[i] =\n                LSQ_ToBlockWordEnable(\n                    port.executedStoreAddr[i],\n                    port.executedStoreMemAccessMode[i]\n                );\n            executedStoreByteWE[i] =\n                LSQ_ToWordByteEnable(\n                    port.executedStoreAddr[i],\n                    port.executedStoreMemAccessMode[i]\n                );\n        end\n    end\n\n\n\n    // Forwarding from a store queue.\n    StoreQueueDataEntry forwardedDataEntry[LOAD_ISSUE_WIDTH];\n    LSQ_BlockWordEnablePath executedLoadWordRE[LOAD_ISSUE_WIDTH];\n    LSQ_WordByteEnablePath executedLoadByteRE[LOAD_ISSUE_WIDTH];\n\n    // A picker of forwarded entries.\n    StoreQueueOneHotPath addrMatch[LOAD_ISSUE_WIDTH];\n    StoreQueueIndexPath pickedPtr[LOAD_ISSUE_WIDTH];\n    logic picked[LOAD_ISSUE_WIDTH];\n    StoreQueueIndexPath executedStoreQueuePtrByLoad[LOAD_ISSUE_WIDTH];\n\n    generate\n        for(genvar i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n            CircularRangePicker #(\n                .ENTRY_NUM( STORE_QUEUE_ENTRY_NUM )\n            ) picker(\n                .headPtr(headPtr),\n                .tailPtr(executedStoreQueuePtrByLoad[i]),\n                .request(addrMatch[i]),\n                .grantPtr(pickedPtr[i]),\n                .picked(picked[i])\n            );\n        end\n    endgenerate\n\n    always_comb begin\n        for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n            executedStoreQueuePtrByLoad[i] = port.executedStoreQueuePtrByLoad[i];\n        end\n    end\n\n\n    // The data part of the SQ.\n    StoreQueueIndexPath sqReadPtr[LOAD_ISSUE_WIDTH + 1];  // +1 for commit.\n    StoreQueueDataEntry sqReadData[LOAD_ISSUE_WIDTH + 1];\n    logic sqWE[STORE_ISSUE_WIDTH];\n    StoreQueueDataEntry sqWriteData[STORE_ISSUE_WIDTH];\n\n    LSQ_BlockDataPath sqWriteStoreData[STORE_ISSUE_WIDTH];\n\n    DistributedMultiPortRAM #(\n        .ENTRY_NUM( STORE_QUEUE_ENTRY_NUM ),\n        .ENTRY_BIT_SIZE( $bits(StoreQueueDataEntry) ),\n        .READ_NUM(LOAD_ISSUE_WIDTH + 1),    // +1 for commit.\n        .WRITE_NUM(STORE_ISSUE_WIDTH)\n    ) storeQueueData (\n        .clk(port.clk),\n        .we(sqWE),\n        .wa(executedStoreQueuePtrByStore),\n        .wv(sqWriteData),\n        .ra(sqReadPtr),\n        .rv(sqReadData)\n    );\n\n    // Write\n    always_comb begin\n        for (int i = 0; i < STORE_ISSUE_WIDTH; i++) begin\n            GenerateStoreData(\n                sqWriteStoreData[i],\n                port.executedStoreData[i],\n                port.executedStoreVectorData[i],\n                port.executedStoreAddr[i],\n                port.executedStoreMemAccessMode[i]\n            );\n\n            sqWE[i] = executeStore[i];\n            sqWriteData[i].data = sqWriteStoreData[i];\n            sqWriteData[i].condEnabled = executedStoreCondEnabled[i];\n            sqWriteData[i].wordWE = executedStoreWordWE[i];\n            sqWriteData[i].byteWE = executedStoreByteWE[i];\n        end\n    end\n\n    // Store-Load Forwarding\n    logic storeLoadForwarded [ LOAD_ISSUE_WIDTH ];\n    LSQ_BlockDataPath forwardedLoadData [ LOAD_ISSUE_WIDTH ];\n    logic forwardMiss[ LOAD_ISSUE_WIDTH ];\n\n    always_comb begin\n\n        // --- Commit\n        // A read pointer is specified by a store commit unit.\n        releasedStoreQueuePtr = port.retiredStoreQueuePtr;\n\n        // The last read port is used for commitment.\n        sqReadPtr[LOAD_ISSUE_WIDTH] = releasedStoreQueuePtr;\n        headDataEntry = sqReadData[LOAD_ISSUE_WIDTH];\n        headAddrEntry = storeQueue[releasedStoreQueuePtr];\n\n        port.retiredStoreLSQ_BlockAddr = headAddrEntry.address;\n\n        port.retiredStoreData = headDataEntry.data;\n        port.retiredStoreCondEnabled = headDataEntry.condEnabled;\n        port.retiredStoreWordWE = headDataEntry.wordWE;\n        port.retiredStoreByteWE = headDataEntry.byteWE;\n\n        port.storeQueueHeadPtr = headPtr;\n\n\n        // --- Forwarding\n        for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n            sqReadPtr[i] = pickedPtr[i] >= STORE_QUEUE_ENTRY_NUM ?\n                pickedPtr[i] - STORE_QUEUE_ENTRY_NUM : pickedPtr[i];\n            forwardedDataEntry[i] = sqReadData[i];\n\n            executedLoadWordRE[i] =\n                LSQ_ToBlockWordEnable(\n                    port.executedLoadAddr[i],\n                    port.executedLoadMemAccessMode[i]\n                );\n            executedLoadByteRE[i] =\n                LSQ_ToWordByteEnable(\n                    port.executedLoadAddr[i],\n                    port.executedLoadMemAccessMode[i]\n                );\n        end\n\n        // Detect store-load forwarding between already executed stores and\n        // a currently executed load.\n        for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n            for (int j = 0; j < STORE_QUEUE_ENTRY_NUM; j++) begin\n                addrMatch[i][j] =\n                    storeQueue[j].finished &&\n                    port.executedLoadMemMapType[i] != MMT_ILLEGAL && \n                    storeQueue[j].address == LSQ_ToBlockAddr(port.executedLoadAddr[i]) &&\n                    ((storeQueue[j].wordWE & executedLoadWordRE[i]) != '0) &&\n                    ((storeQueue[j].byteWE & executedLoadByteRE[i]) != '0);\n            end\n        end\n\n        for (int i = 0; i < LOAD_ISSUE_WIDTH; i++) begin\n            // \u30ed\u30fc\u30c9\u306e\u30d5\u30a9\u30ef\u30fc\u30c7\u30a3\u30f3\u30b0\u306e\u4f9d\u5b58\u5143\u3068\u306a\u308b\u30b9\u30c8\u30a2\u306f1\u3064\u306b\u9650\u3089\u308c\u308b\u3002\n            // \u30b9\u30c8\u30a2\u304cwrite\u3057\u3066\u306a\u3044\u30d0\u30a4\u30c8\u3092\u3001\u30ed\u30fc\u30c9\u304cread\u3057\u3088\u3046\u3068\u3057\u305f\u5834\u5408\u3001\n            // \u30d5\u30a9\u30ef\u30fc\u30c7\u30a3\u30f3\u30b0\u306f\u5931\u6557\u3068\u306a\u308b\u3002\n            if (pickedPtr[i] < STORE_QUEUE_ENTRY_NUM) begin\n                forwardMiss[i] = !storeQueue[pickedPtr[i]].regValid ||\n                    ((~forwardedDataEntry[i].wordWE & executedLoadWordRE[i]) != '0) ||\n                    ((~forwardedDataEntry[i].byteWE & executedLoadByteRE[i]) != '0);\n                forwardedLoadData[i] = forwardedDataEntry[i].data;\n            end\n            else begin\n                // Out of range of store queue\n                forwardMiss[i] = FALSE;\n                forwardedLoadData[i] = '0;\n            end\n            storeLoadForwarded[i] = port.executeLoad[i] && picked[i];\n        end\n\n        port.forwardedLoadData = forwardedLoadData;\n        port.forwardMiss = forwardMiss;\n        port.storeLoadForwarded = storeLoadForwarded;\n    end\n\n    //\n    // Assertions\n    //\n    generate\n        for (genvar i = 0; i < LOAD_ISSUE_WIDTH; i++) begin : assertionBlock\n            //  |-L--h***S***t-------|\n            `RSD_ASSERT_CLK(\n                port.clk,\n                !(port.executeLoad[i] && headPtr < tailPtr && port.executedStoreQueuePtrByLoad[i] < headPtr),\n                \"1:A load's executedStoreQueuePtr is illegal.\"\n            );\n\n            //  |----h******t--L----|\n            `RSD_ASSERT_CLK(\n                port.clk,\n                !(port.executeLoad[i] && headPtr < tailPtr && tailPtr < port.executedStoreQueuePtrByLoad[i]),\n                \"2:A load's executedStoreQueuePtr is illegal.\"\n            );\n\n            //  |******t--L--h*******|\n            `RSD_ASSERT_CLK(\n                port.clk,\n                !(port.executeLoad[i] && tailPtr <= headPtr &&\n                tailPtr < port.executedStoreQueuePtrByLoad[i] && port.executedStoreQueuePtrByLoad[i] < headPtr),\n                \"3:A load's executedStoreQueuePtr is illegal.\"\n            );\n        end\n    endgenerate\n\n    `RSD_ASSERT_CLK(\n        port.clk,\n        port.rst || !((port.releaseStoreQueueHead ) && curCount == 0),\n        \"Pop from a empty store queue.\"\n    );\n\n\nendmodule : StoreQueue\n\n"}
