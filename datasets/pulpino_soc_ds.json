{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\n`ifndef APB_BUS_SV\n`define APB_BUS_SV\n\n`include \"config.sv\"\n\n// SOC PERIPHERALS APB BUS PARAMETRES\n`define NB_MASTER  9\n\n// MASTER PORT TO CVP\n`define UART_START_ADDR       32'h1A10_0000\n`define UART_END_ADDR         32'h1A10_0FFF\n\n// MASTER PORT TO GPIO\n`define GPIO_START_ADDR       32'h1A10_1000\n`define GPIO_END_ADDR         32'h1A10_1FFF\n\n// MASTER PORT TO SPI MASTER\n`define SPI_START_ADDR        32'h1A10_2000\n`define SPI_END_ADDR          32'h1A10_2FFF\n\n// MASTER PORT TO TIMER\n`define TIMER_START_ADDR      32'h1A10_3000\n`define TIMER_END_ADDR        32'h1A10_3FFF\n\n// MASTER PORT TO EVENT UNIT\n`define EVENT_UNIT_START_ADDR 32'h1A10_4000\n`define EVENT_UNIT_END_ADDR   32'h1A10_4FFF\n\n// MASTER PORT TO I2C\n`define I2C_START_ADDR        32'h1A10_5000\n`define I2C_END_ADDR          32'h1A10_5FFF\n\n// MASTER PORT TO FLL\n`define FLL_START_ADDR        32'h1A10_6000\n`define FLL_END_ADDR          32'h1A10_6FFF\n\n// MASTER PORT TO SOC CTRL\n`define SOC_CTRL_START_ADDR   32'h1A10_7000\n`define SOC_CTRL_END_ADDR     32'h1A10_7FFF\n\n// MASTER PORT TO DEBUG\n`define DEBUG_START_ADDR      32'h1A11_0000\n`define DEBUG_END_ADDR        32'h1A11_7FFF\n\n`define APB_ASSIGN_SLAVE(lhs, rhs)     \\\n    assign lhs.paddr    = rhs.paddr;   \\\n    assign lhs.pwdata   = rhs.pwdata;  \\\n    assign lhs.pwrite   = rhs.pwrite;  \\\n    assign lhs.psel     = rhs.psel;    \\\n    assign lhs.penable  = rhs.penable; \\\n    assign rhs.prdata   = lhs.prdata;  \\\n    assign rhs.pready   = lhs.pready;  \\\n    assign rhs.pslverr  = lhs.pslverr;\n\n`define APB_ASSIGN_MASTER(lhs, rhs) `APB_ASSIGN_SLAVE(rhs, lhs)\n\n////////////////////////////////////////////////////////////////////////////////\n//          Only general functions and definitions are defined here           //\n//              These functions are not intended to be modified               //\n////////////////////////////////////////////////////////////////////////////////\n\ninterface APB_BUS\n#(\n    parameter APB_ADDR_WIDTH = 32,\n    parameter APB_DATA_WIDTH = 32\n);\n\n    logic [APB_ADDR_WIDTH-1:0]                                        paddr;\n    logic [APB_DATA_WIDTH-1:0]                                        pwdata;\n    logic                                                             pwrite;\n    logic                                                             psel;\n    logic                                                             penable;\n    logic [APB_DATA_WIDTH-1:0]                                        prdata;\n    logic                                                             pready;\n    logic                                                             pslverr;\n\n\n   // Master Side\n   //***************************************\n   modport Master\n   (\n      output      paddr,  pwdata,  pwrite, psel,  penable,\n      input       prdata,          pready,        pslverr\n   );\n\n   // Slave Side\n   //***************************************\n   modport Slave\n   (\n      input      paddr,  pwdata,  pwrite, psel,  penable,\n      output     prdata,          pready,        pslverr\n   );\n\nendinterface\n\n`endif\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule apb_mock_uart\n#(\n    parameter APB_ADDR_WIDTH = 12  //APB slaves are 4KB by default\n)\n(\n    input  logic                      CLK,\n    input  logic                      RSTN,\n    input  logic [APB_ADDR_WIDTH-1:0] PADDR,\n    input  logic               [31:0] PWDATA,\n    input  logic                      PWRITE,\n    input  logic                      PSEL,\n    input  logic                      PENABLE,\n    output logic               [31:0] PRDATA,\n    output logic                      PREADY,\n    output logic                      PSLVERR,\n\n    output logic                      INT,       //Interrupt output\n\n    output logic                      OUT1N,     // Output 1\n    output logic                      OUT2N,     // Output 2\n    output logic                      RTSN,      // RTS output\n    output logic                      DTRN,      // DTR output\n    input  logic                      CTSN,      // CTS input\n    input  logic                      DSRN,      // DSR input\n    input  logic                      DCDN,      // DCD input\n    input  logic                      RIN,       // RI input\n    input  logic                      SIN,       // Receiver input\n    output logic                      SOUT       // Transmitter output\n);\n    // enum { THR = 0, RBR = 0, DLL = 0, IER = 1, DLM = 1, IIR = 2, FCR = 2, LCR = 3, MCR, LSR, MSR, SCR} uart_regs;\n\n    logic [3:0]       register_adr;\n    logic [7:0][7:0]  regs_q, regs_n;\n\n    assign register_adr = PADDR[2:0];\n\n    // UART Registers\n\n    // register write logic\n    always_comb\n    begin\n        regs_n = regs_q;\n\n        if (PSEL && PENABLE && PWRITE)\n        begin\n            regs_n[$unsigned(register_adr)] = PWDATA[7:0];\n        end\n\tregs_n[8'h5] = 32'h60;\n    end\n\n    // register read logic\n    always_comb\n    begin\n        PRDATA = 'b0;\n\n        if (PSEL && PENABLE && !PWRITE)\n        begin\n            PRDATA = {24'b0, regs_q[$unsigned(register_adr)] };\n        end\n    end\n\n    // synchronouse part\n    always_ff @(posedge CLK, negedge RSTN)\n    begin\n        if(~RSTN)\n        begin\n            regs_q <= '{8{8'b0}};\n        end\n        else\n        begin\n            regs_q <= regs_n;\n            if (PSEL && PENABLE && PWRITE)\n            begin\n                if ($unsigned(register_adr) == 0)\n                begin\n                    $write(\"%C\", PWDATA[7:0]);\n                end\n            end\n        end\n    end\n\n    // APB logic: we are always ready to capture the data into our regs\n    // not supporting transfare failure\n    assign PREADY  = 1'b1;\n    assign PSLVERR = 1'b0;\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n//`define SHARED_APU\n`define APU"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"axi_bus.sv\"\n\nmodule axi2apb_wrap\n#(\n    parameter AXI_ADDR_WIDTH   = 32,\n    parameter AXI_DATA_WIDTH   = 32,\n    parameter AXI_USER_WIDTH   = 6,\n    parameter AXI_ID_WIDTH     = 6,\n    parameter APB_ADDR_WIDTH   = 32\n)\n(\n    input logic                                 clk_i,\n    input logic                                 rst_ni,\n    input logic                                 test_en_i,\n\n    AXI_BUS.Slave                               axi_slave,\n\n    APB_BUS.Master                              apb_master\n\n);\n\n\n  //********************************************************\n  //************** AXI2APB WRAPER **************************\n  //********************************************************\n\n  generate if (AXI_DATA_WIDTH == 32)\n    begin\n      axi2apb32\n      #(\n        .AXI4_ADDRESS_WIDTH ( AXI_ADDR_WIDTH ),\n        .AXI4_RDATA_WIDTH   ( AXI_DATA_WIDTH ),\n        .AXI4_WDATA_WIDTH   ( AXI_DATA_WIDTH ),\n        .AXI4_ID_WIDTH      ( AXI_ID_WIDTH   ),\n        .AXI4_USER_WIDTH    ( 1              ),\n\n        .BUFF_DEPTH_SLAVE   ( 2              ),\n        .APB_ADDR_WIDTH     ( APB_ADDR_WIDTH )\n      )\n      axi2apb_i\n      (\n        .ACLK       ( clk_i               ),\n        .ARESETn    ( rst_ni              ),\n        .test_en_i  ( test_en_i           ),\n\n        .AWID_i     ( axi_slave.aw_id     ),\n        .AWADDR_i   ( axi_slave.aw_addr   ),\n        .AWLEN_i    ( axi_slave.aw_len    ),\n        .AWSIZE_i   ( axi_slave.aw_size   ),\n        .AWBURST_i  ( axi_slave.aw_burst  ),\n        .AWLOCK_i   ( axi_slave.aw_lock   ),\n        .AWCACHE_i  ( axi_slave.aw_cache  ),\n        .AWPROT_i   ( axi_slave.aw_prot   ),\n        .AWREGION_i ( axi_slave.aw_region ),\n        .AWUSER_i   ( axi_slave.aw_user   ),\n        .AWQOS_i    ( axi_slave.aw_qos    ),\n        .AWVALID_i  ( axi_slave.aw_valid  ),\n        .AWREADY_o  ( axi_slave.aw_ready  ),\n\n        .WDATA_i    ( axi_slave.w_data    ),\n        .WSTRB_i    ( axi_slave.w_strb    ),\n        .WLAST_i    ( axi_slave.w_last    ),\n        .WUSER_i    ( axi_slave.w_user    ),\n        .WVALID_i   ( axi_slave.w_valid   ),\n        .WREADY_o   ( axi_slave.w_ready   ),\n\n        .BID_o      ( axi_slave.b_id      ),\n        .BRESP_o    ( axi_slave.b_resp    ),\n        .BVALID_o   ( axi_slave.b_valid   ),\n        .BUSER_o    ( axi_slave.b_user    ),\n        .BREADY_i   ( axi_slave.b_ready   ),\n\n        .ARID_i     ( axi_slave.ar_id     ),\n        .ARADDR_i   ( axi_slave.ar_addr   ),\n        .ARLEN_i    ( axi_slave.ar_len    ),\n        .ARSIZE_i   ( axi_slave.ar_size   ),\n        .ARBURST_i  ( axi_slave.ar_burst  ),\n        .ARLOCK_i   ( axi_slave.ar_lock   ),\n        .ARCACHE_i  ( axi_slave.ar_cache  ),\n        .ARPROT_i   ( axi_slave.ar_prot   ),\n        .ARREGION_i ( axi_slave.ar_region ),\n        .ARUSER_i   ( axi_slave.ar_user   ),\n        .ARQOS_i    ( axi_slave.ar_qos    ),\n        .ARVALID_i  ( axi_slave.ar_valid  ),\n        .ARREADY_o  ( axi_slave.ar_ready  ),\n\n        .RID_o      ( axi_slave.r_id      ),\n        .RDATA_o    ( axi_slave.r_data    ),\n        .RRESP_o    ( axi_slave.r_resp    ),\n        .RLAST_o    ( axi_slave.r_last    ),\n        .RUSER_o    ( axi_slave.r_user    ),\n        .RVALID_o   ( axi_slave.r_valid   ),\n        .RREADY_i   ( axi_slave.r_ready   ),\n\n        .PENABLE    ( apb_master.penable  ),\n        .PWRITE     ( apb_master.pwrite   ),\n        .PADDR      ( apb_master.paddr    ),\n        .PSEL       ( apb_master.psel     ),\n        .PWDATA     ( apb_master.pwdata   ),\n        .PRDATA     ( apb_master.prdata   ),\n        .PREADY     ( apb_master.pready   ),\n        .PSLVERR    ( apb_master.pslverr  )\n      );\n    end\n    else if (AXI_DATA_WIDTH == 64)\n    begin\n      axi2apb\n      #(\n        .AXI4_ADDRESS_WIDTH ( AXI_ADDR_WIDTH ),\n        .AXI4_RDATA_WIDTH   ( AXI_DATA_WIDTH ),\n        .AXI4_WDATA_WIDTH   ( AXI_DATA_WIDTH ),\n        .AXI4_ID_WIDTH      ( AXI_ID_WIDTH   ),\n        .AXI4_USER_WIDTH    ( 1              ),\n\n        .BUFF_DEPTH_SLAVE   ( 2              ),\n        .APB_ADDR_WIDTH     ( APB_ADDR_WIDTH )\n      )\n      axi2apb_i\n      (\n        .ACLK       ( clk_i               ),\n        .ARESETn    ( rst_ni              ),\n        .test_en_i  ( test_en_i           ),\n\n        .AWID_i     ( axi_slave.aw_id     ),\n        .AWADDR_i   ( axi_slave.aw_addr   ),\n        .AWLEN_i    ( axi_slave.aw_len    ),\n        .AWSIZE_i   ( axi_slave.aw_size   ),\n        .AWBURST_i  ( axi_slave.aw_burst  ),\n        .AWLOCK_i   ( axi_slave.aw_lock   ),\n        .AWCACHE_i  ( axi_slave.aw_cache  ),\n        .AWPROT_i   ( axi_slave.aw_prot   ),\n        .AWREGION_i ( axi_slave.aw_region ),\n        .AWUSER_i   ( axi_slave.aw_user   ),\n        .AWQOS_i    ( axi_slave.aw_qos    ),\n        .AWVALID_i  ( axi_slave.aw_valid  ),\n        .AWREADY_o  ( axi_slave.aw_ready  ),\n\n        .WDATA_i    ( axi_slave.w_data    ),\n        .WSTRB_i    ( axi_slave.w_strb    ),\n        .WLAST_i    ( axi_slave.w_last    ),\n        .WUSER_i    ( axi_slave.w_user    ),\n        .WVALID_i   ( axi_slave.w_valid   ),\n        .WREADY_o   ( axi_slave.w_ready   ),\n\n        .BID_o      ( axi_slave.b_id      ),\n        .BRESP_o    ( axi_slave.b_resp    ),\n        .BVALID_o   ( axi_slave.b_valid   ),\n        .BUSER_o    ( axi_slave.b_user    ),\n        .BREADY_i   ( axi_slave.b_ready   ),\n\n        .ARID_i     ( axi_slave.ar_id     ),\n        .ARADDR_i   ( axi_slave.ar_addr   ),\n        .ARLEN_i    ( axi_slave.ar_len    ),\n        .ARSIZE_i   ( axi_slave.ar_size   ),\n        .ARBURST_i  ( axi_slave.ar_burst  ),\n        .ARLOCK_i   ( axi_slave.ar_lock   ),\n        .ARCACHE_i  ( axi_slave.ar_cache  ),\n        .ARPROT_i   ( axi_slave.ar_prot   ),\n        .ARREGION_i ( axi_slave.ar_region ),\n        .ARUSER_i   ( axi_slave.ar_user   ),\n        .ARQOS_i    ( axi_slave.ar_qos    ),\n        .ARVALID_i  ( axi_slave.ar_valid  ),\n        .ARREADY_o  ( axi_slave.ar_ready  ),\n\n        .RID_o      ( axi_slave.r_id      ),\n        .RDATA_o    ( axi_slave.r_data    ),\n        .RRESP_o    ( axi_slave.r_resp    ),\n        .RLAST_o    ( axi_slave.r_last    ),\n        .RUSER_o    ( axi_slave.r_user    ),\n        .RVALID_o   ( axi_slave.r_valid   ),\n        .RREADY_i   ( axi_slave.r_ready   ),\n\n        .PENABLE    ( apb_master.penable  ),\n        .PWRITE     ( apb_master.pwrite   ),\n        .PADDR      ( apb_master.paddr    ),\n        .PSEL       ( apb_master.psel     ),\n        .PWDATA     ( apb_master.pwdata   ),\n        .PRDATA     ( apb_master.prdata   ),\n        .PREADY     ( apb_master.pready   ),\n        .PSLVERR    ( apb_master.pslverr  )\n      );\n    end\n  endgenerate\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`ifndef AXI_BUS_SV\n`define AXI_BUS_SV\n\n`include \"config.sv\"\n\n////////////////////////////////////////////////////////////////////////////////\n//          Only general functions and definitions are defined here           //\n//              These functions are not intended to be modified               //\n////////////////////////////////////////////////////////////////////////////////\n\n`define OKAY   2'b00\n\ninterface AXI_BUS\n#(\n    parameter AXI_ADDR_WIDTH = 32,\n    parameter AXI_DATA_WIDTH = 64,\n    parameter AXI_ID_WIDTH   = 10,\n    parameter AXI_USER_WIDTH = 6\n);\n\n  localparam AXI_STRB_WIDTH = AXI_DATA_WIDTH/8;\n\n  logic [AXI_ADDR_WIDTH-1:0] aw_addr;\n  logic [2:0]                aw_prot;\n  logic [3:0]                aw_region;\n  logic [7:0]                aw_len;\n  logic [2:0]                aw_size;\n  logic [1:0]                aw_burst;\n  logic                      aw_lock;\n  logic [3:0]                aw_cache;\n  logic [3:0]                aw_qos;\n  logic [AXI_ID_WIDTH-1:0]   aw_id;\n  logic [AXI_USER_WIDTH-1:0] aw_user;\n  logic                      aw_ready;\n  logic                      aw_valid;\n\n  logic [AXI_ADDR_WIDTH-1:0] ar_addr;\n  logic [2:0]                ar_prot;\n  logic [3:0]                ar_region;\n  logic [7:0]                ar_len;\n  logic [2:0]                ar_size;\n  logic [1:0]                ar_burst;\n  logic                      ar_lock;\n  logic [3:0]                ar_cache;\n  logic [3:0]                ar_qos;\n  logic [AXI_ID_WIDTH-1:0]   ar_id;\n  logic [AXI_USER_WIDTH-1:0] ar_user;\n  logic                      ar_ready;\n  logic                      ar_valid;\n\n  logic                      w_valid;\n  logic [AXI_DATA_WIDTH-1:0] w_data;\n  logic [AXI_STRB_WIDTH-1:0] w_strb;\n  logic [AXI_USER_WIDTH-1:0] w_user;\n  logic                      w_last;\n  logic                      w_ready;\n\n  logic [AXI_DATA_WIDTH-1:0] r_data;\n  logic [1:0]                r_resp;\n  logic                      r_last;\n  logic [AXI_ID_WIDTH-1:0]   r_id;\n  logic [AXI_USER_WIDTH-1:0] r_user;\n  logic                      r_ready;\n  logic                      r_valid;\n\n  logic [1:0]                b_resp;\n  logic [AXI_ID_WIDTH-1:0]   b_id;\n  logic [AXI_USER_WIDTH-1:0] b_user;\n  logic                      b_ready;\n  logic                      b_valid;\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n\n    output aw_valid, output aw_addr, output aw_prot, output aw_region,\n    output aw_len, output aw_size, output aw_burst, output aw_lock,\n    output aw_cache, output aw_qos, output aw_id, output aw_user,\n    input aw_ready,\n\n    output ar_valid, output ar_addr, output ar_prot, output ar_region,\n    output ar_len, output ar_size, output ar_burst, output ar_lock,\n    output ar_cache, output ar_qos, output ar_id, output ar_user,\n    input ar_ready,\n\n    output w_valid, output w_data, output w_strb,  output w_user, output w_last,\n    input w_ready,\n\n    input r_valid, input r_data, input r_resp, input r_last, input r_id, input r_user,\n    output r_ready,\n\n    input b_valid, input b_resp, input b_id, input b_user,\n    output b_ready\n\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n\n    input aw_valid, input aw_addr, input aw_prot, input aw_region,\n    input aw_len, input aw_size, input aw_burst, input aw_lock,\n    input aw_cache, input aw_qos, input aw_id, input aw_user,\n    output aw_ready,\n\n    input ar_valid, input ar_addr, input ar_prot, input ar_region,\n    input ar_len, input ar_size, input ar_burst, input ar_lock,\n    input ar_cache, input ar_qos, input ar_id, input ar_user,\n    output ar_ready,\n\n    input w_valid, input w_data, input w_strb, input w_user, input w_last,\n    output w_ready,\n\n    output r_valid, output r_data, output r_resp, output r_last, output r_id, output r_user,\n    input r_ready,\n\n    output b_valid, output b_resp, output b_id, output b_user,\n    input b_ready\n\n  );\n\nendinterface\n\n`endif\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"axi_bus.sv\"\n\nmodule axi_mem_if_SP_wrap\n  #(\n    parameter AXI_ADDR_WIDTH = 32,\n    parameter AXI_DATA_WIDTH = 64,\n    parameter AXI_ID_WIDTH   = 10,\n    parameter AXI_USER_WIDTH = 10,\n    parameter MEM_ADDR_WIDTH = 10\n  )(\n    // Clock and Reset\n    input logic                         clk,\n    input logic                         rst_n,\n    input logic                         test_en_i,\n\n    output logic                        mem_req_o,\n    output logic [MEM_ADDR_WIDTH-1:0]   mem_addr_o,\n    output logic                        mem_we_o,\n    output logic [AXI_DATA_WIDTH/8-1:0] mem_be_o,\n    input  logic [AXI_DATA_WIDTH-1:0]   mem_rdata_i,\n    output logic [AXI_DATA_WIDTH-1:0]   mem_wdata_o,\n\n    AXI_BUS.Slave  slave\n  );\n\n  logic       cen;\n  logic       wen;\n\n  axi_mem_if_SP\n  #(\n    .AXI4_ADDRESS_WIDTH  ( AXI_ADDR_WIDTH  ),\n    .AXI4_RDATA_WIDTH    ( AXI_DATA_WIDTH  ),\n    .AXI4_WDATA_WIDTH    ( AXI_DATA_WIDTH  ),\n    .AXI4_ID_WIDTH       ( AXI_ID_WIDTH    ),\n    .AXI4_USER_WIDTH     ( AXI_USER_WIDTH  ),\n    .MEM_ADDR_WIDTH      ( MEM_ADDR_WIDTH  )\n  )\n  axi_mem_if_SP_i\n  (\n    .ACLK       ( clk             ),\n    .ARESETn    ( rst_n           ),\n    .test_en_i  ( test_en_i       ),\n\n    .AWID_i     ( slave.aw_id     ),\n    .AWADDR_i   ( slave.aw_addr   ),\n    .AWLEN_i    ( slave.aw_len    ),\n    .AWSIZE_i   ( slave.aw_size   ),\n    .AWBURST_i  ( slave.aw_burst  ),\n    .AWLOCK_i   ( slave.aw_lock   ),\n    .AWCACHE_i  ( slave.aw_cache  ),\n    .AWPROT_i   ( slave.aw_prot   ),\n    .AWREGION_i ( slave.aw_region ),\n    .AWUSER_i   ( slave.aw_user   ),\n    .AWQOS_i    ( slave.aw_qos    ),\n    .AWVALID_i  ( slave.aw_valid  ),\n    .AWREADY_o  ( slave.aw_ready  ),\n\n    .WDATA_i    ( slave.w_data    ),\n    .WSTRB_i    ( slave.w_strb    ),\n    .WLAST_i    ( slave.w_last    ),\n    .WUSER_i    ( slave.w_user    ),\n    .WVALID_i   ( slave.w_valid   ),\n    .WREADY_o   ( slave.w_ready   ),\n\n    .BID_o      ( slave.b_id      ),\n    .BRESP_o    ( slave.b_resp    ),\n    .BVALID_o   ( slave.b_valid   ),\n    .BUSER_o    ( slave.b_user    ),\n    .BREADY_i   ( slave.b_ready   ),\n\n    .ARID_i     ( slave.ar_id     ),\n    .ARADDR_i   ( slave.ar_addr   ),\n    .ARLEN_i    ( slave.ar_len    ),\n    .ARSIZE_i   ( slave.ar_size   ),\n    .ARBURST_i  ( slave.ar_burst  ),\n    .ARLOCK_i   ( slave.ar_lock   ),\n    .ARCACHE_i  ( slave.ar_cache  ),\n    .ARPROT_i   ( slave.ar_prot   ),\n    .ARREGION_i ( slave.ar_region ),\n    .ARUSER_i   ( slave.ar_user   ),\n    .ARQOS_i    ( slave.ar_qos    ),\n    .ARVALID_i  ( slave.ar_valid  ),\n    .ARREADY_o  ( slave.ar_ready  ),\n\n    .RID_o      ( slave.r_id      ),\n    .RDATA_o    ( slave.r_data    ),\n    .RRESP_o    ( slave.r_resp    ),\n    .RLAST_o    ( slave.r_last    ),\n    .RUSER_o    ( slave.r_user    ),\n    .RVALID_o   ( slave.r_valid   ),\n    .RREADY_i   ( slave.r_ready   ),\n\n    .CEN_o      ( cen             ),\n    .WEN_o      ( wen             ),\n    .A_o        ( mem_addr_o      ),\n    .D_o        ( mem_wdata_o     ),\n    .BE_o       ( mem_be_o        ),\n    .Q_i        ( mem_rdata_i     )\n  );\n\n  assign mem_req_o = ~cen;\n  assign mem_we_o  = ~wen;\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\n`include \"axi_bus.sv\"\n\nmodule axi_node_intf_wrap\n  #(\n    parameter NB_MASTER      = 4,\n    parameter NB_SLAVE       = 4,\n    parameter AXI_ADDR_WIDTH = 32,\n    parameter AXI_DATA_WIDTH = 32,\n    parameter AXI_ID_WIDTH   = 10,\n    parameter AXI_USER_WIDTH = 0\n    )\n  (\n    // Clock and Reset\n    input logic clk,\n    input logic rst_n,\n    input logic test_en_i,\n\n    AXI_BUS.Slave slave[NB_SLAVE-1:0],\n\n    AXI_BUS.Master master[NB_MASTER-1:0],\n\n    // Memory map\n    input  logic [NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0]  start_addr_i,\n    input  logic [NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0]  end_addr_i\n  );\n\n  localparam AXI_STRB_WIDTH = AXI_DATA_WIDTH/8;\n  localparam NB_REGION      = 1;\n\n  // AXI ID WIDTHs for master and slave IPS\n  localparam AXI_ID_WIDTH_TARG =   AXI_ID_WIDTH;\n  localparam AXI_ID_WIDTH_INIT =   AXI_ID_WIDTH_TARG + $clog2(NB_SLAVE);\n\n\n  // Signals to slave periperhals\n  logic [NB_MASTER-1:0][AXI_ID_WIDTH_INIT-1:0] s_master_aw_id;\n  logic [NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0]    s_master_aw_addr;\n  logic [NB_MASTER-1:0][7:0]                   s_master_aw_len;\n  logic [NB_MASTER-1:0][2:0]                   s_master_aw_size;\n  logic [NB_MASTER-1:0][1:0]                   s_master_aw_burst;\n  logic [NB_MASTER-1:0]                        s_master_aw_lock;\n  logic [NB_MASTER-1:0][3:0]                   s_master_aw_cache;\n  logic [NB_MASTER-1:0][2:0]                   s_master_aw_prot;\n  logic [NB_MASTER-1:0][3:0]                   s_master_aw_region;\n  logic [NB_MASTER-1:0][AXI_USER_WIDTH-1:0]    s_master_aw_user;\n  logic [NB_MASTER-1:0][3:0]                   s_master_aw_qos;\n  logic [NB_MASTER-1:0]                        s_master_aw_valid;\n  logic [NB_MASTER-1:0]                        s_master_aw_ready;\n\n  logic [NB_MASTER-1:0][AXI_ID_WIDTH_INIT-1:0] s_master_ar_id;\n  logic [NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0]    s_master_ar_addr;\n  logic [NB_MASTER-1:0][7:0]                   s_master_ar_len;\n  logic [NB_MASTER-1:0][2:0]                   s_master_ar_size;\n  logic [NB_MASTER-1:0][1:0]                   s_master_ar_burst;\n  logic [NB_MASTER-1:0]                        s_master_ar_lock;\n  logic [NB_MASTER-1:0][3:0]                   s_master_ar_cache;\n  logic [NB_MASTER-1:0][2:0]                   s_master_ar_prot;\n  logic [NB_MASTER-1:0][3:0]                   s_master_ar_region;\n  logic [NB_MASTER-1:0][AXI_USER_WIDTH-1:0]    s_master_ar_user;\n  logic [NB_MASTER-1:0][3:0]                   s_master_ar_qos;\n  logic [NB_MASTER-1:0]                        s_master_ar_valid;\n  logic [NB_MASTER-1:0]                        s_master_ar_ready;\n\n  logic [NB_MASTER-1:0][AXI_DATA_WIDTH-1:0]    s_master_w_data;\n  logic [NB_MASTER-1:0][AXI_STRB_WIDTH-1:0]    s_master_w_strb;\n  logic [NB_MASTER-1:0]                        s_master_w_last;\n  logic [NB_MASTER-1:0][AXI_USER_WIDTH-1:0]    s_master_w_user;\n  logic [NB_MASTER-1:0]                        s_master_w_valid;\n  logic [NB_MASTER-1:0]                        s_master_w_ready;\n\n  logic [NB_MASTER-1:0][AXI_ID_WIDTH_INIT-1:0] s_master_b_id;\n  logic [NB_MASTER-1:0][1:0]                   s_master_b_resp;\n  logic [NB_MASTER-1:0]                        s_master_b_valid;\n  logic [NB_MASTER-1:0][AXI_USER_WIDTH-1:0]    s_master_b_user;\n  logic [NB_MASTER-1:0]                        s_master_b_ready;\n\n  logic [NB_MASTER-1:0][AXI_ID_WIDTH_INIT-1:0] s_master_r_id;\n  logic [NB_MASTER-1:0][AXI_DATA_WIDTH-1:0]    s_master_r_data;\n  logic [NB_MASTER-1:0][1:0]                   s_master_r_resp;\n  logic [NB_MASTER-1:0]                        s_master_r_last;\n  logic [NB_MASTER-1:0][AXI_USER_WIDTH-1:0]    s_master_r_user;\n  logic [NB_MASTER-1:0]                        s_master_r_valid;\n  logic [NB_MASTER-1:0]                        s_master_r_ready;\n\n  // Signals from AXI masters\n  logic [NB_SLAVE-1:0][AXI_ID_WIDTH_TARG-1:0] s_slave_aw_id;\n  logic [NB_SLAVE-1:0][AXI_ADDR_WIDTH-1:0]    s_slave_aw_addr;\n  logic [NB_SLAVE-1:0][7:0]                   s_slave_aw_len;\n  logic [NB_SLAVE-1:0][2:0]                   s_slave_aw_size;\n  logic [NB_SLAVE-1:0][1:0]                   s_slave_aw_burst;\n  logic [NB_SLAVE-1:0]                        s_slave_aw_lock;\n  logic [NB_SLAVE-1:0][3:0]                   s_slave_aw_cache;\n  logic [NB_SLAVE-1:0][2:0]                   s_slave_aw_prot;\n  logic [NB_SLAVE-1:0][3:0]                   s_slave_aw_region;\n  logic [NB_SLAVE-1:0][AXI_USER_WIDTH-1:0]    s_slave_aw_user;\n  logic [NB_SLAVE-1:0][3:0]                   s_slave_aw_qos;\n  logic [NB_SLAVE-1:0]                        s_slave_aw_valid;\n  logic [NB_SLAVE-1:0]                        s_slave_aw_ready;\n\n  logic [NB_SLAVE-1:0][AXI_ID_WIDTH_TARG-1:0] s_slave_ar_id;\n  logic [NB_SLAVE-1:0][AXI_ADDR_WIDTH-1:0]    s_slave_ar_addr;\n  logic [NB_SLAVE-1:0][7:0]                   s_slave_ar_len;\n  logic [NB_SLAVE-1:0][2:0]                   s_slave_ar_size;\n  logic [NB_SLAVE-1:0][1:0]                   s_slave_ar_burst;\n  logic [NB_SLAVE-1:0]                        s_slave_ar_lock;\n  logic [NB_SLAVE-1:0][3:0]                   s_slave_ar_cache;\n  logic [NB_SLAVE-1:0][2:0]                   s_slave_ar_prot;\n  logic [NB_SLAVE-1:0][3:0]                   s_slave_ar_region;\n  logic [NB_SLAVE-1:0][AXI_USER_WIDTH-1:0]    s_slave_ar_user;\n  logic [NB_SLAVE-1:0][3:0]                   s_slave_ar_qos;\n  logic [NB_SLAVE-1:0]                        s_slave_ar_valid;\n  logic [NB_SLAVE-1:0]                        s_slave_ar_ready;\n\n  logic [NB_SLAVE-1:0][AXI_DATA_WIDTH-1:0]    s_slave_w_data;\n  logic [NB_SLAVE-1:0][AXI_STRB_WIDTH-1:0]    s_slave_w_strb;\n  logic [NB_SLAVE-1:0]                        s_slave_w_last;\n  logic [NB_SLAVE-1:0][AXI_USER_WIDTH-1:0]    s_slave_w_user;\n  logic [NB_SLAVE-1:0]                        s_slave_w_valid;\n  logic [NB_SLAVE-1:0]                        s_slave_w_ready;\n\n  logic [NB_SLAVE-1:0][AXI_ID_WIDTH_TARG-1:0] s_slave_b_id;\n  logic [NB_SLAVE-1:0][1:0]                   s_slave_b_resp;\n  logic [NB_SLAVE-1:0]                        s_slave_b_valid;\n  logic [NB_SLAVE-1:0][AXI_USER_WIDTH-1:0]    s_slave_b_user;\n  logic [NB_SLAVE-1:0]                        s_slave_b_ready;\n\n  logic [NB_SLAVE-1:0][AXI_ID_WIDTH_TARG-1:0] s_slave_r_id;\n  logic [NB_SLAVE-1:0][AXI_DATA_WIDTH-1:0]    s_slave_r_data;\n  logic [NB_SLAVE-1:0][1:0]                   s_slave_r_resp;\n  logic [NB_SLAVE-1:0]                        s_slave_r_last;\n  logic [NB_SLAVE-1:0][AXI_USER_WIDTH-1:0]    s_slave_r_user;\n  logic [NB_SLAVE-1:0]                        s_slave_r_valid;\n  logic [NB_SLAVE-1:0]                        s_slave_r_ready;\n\n  // Signals Used to configure the AXI node\n  logic [NB_REGION-1:0][NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0] s_start_addr;\n  logic [NB_REGION-1:0][NB_MASTER-1:0][AXI_ADDR_WIDTH-1:0] s_end_addr;\n  logic [NB_REGION-1:0][NB_MASTER-1:0]                     s_valid_rule;\n  logic [NB_SLAVE-1:0][NB_MASTER-1:0]                      s_connectivity_map;\n\n\n  generate\n    genvar i;\n    for(i = 0; i < NB_MASTER; i++)\n    begin\n      assign                        master[i].aw_id[AXI_ID_WIDTH_INIT-1:0] = s_master_aw_id[i];\n      assign                        master[i].aw_addr                      = s_master_aw_addr[i];\n      assign                        master[i].aw_len                       = s_master_aw_len[i];\n      assign                        master[i].aw_size                      = s_master_aw_size[i];\n      assign                        master[i].aw_burst                     = s_master_aw_burst[i];\n      assign                        master[i].aw_lock                      = s_master_aw_lock[i];\n      assign                        master[i].aw_cache                     = s_master_aw_cache[i];\n      assign                        master[i].aw_prot                      = s_master_aw_prot[i];\n      assign                        master[i].aw_region                    = s_master_aw_region[i];\n      assign                        master[i].aw_user                      = s_master_aw_user[i];\n      assign                        master[i].aw_qos                       = s_master_aw_qos[i];\n      assign                        master[i].aw_valid                     = s_master_aw_valid[i];\n      assign s_master_aw_ready[i] = master[i].aw_ready;\n\n      assign                        master[i].ar_id[AXI_ID_WIDTH_INIT-1:0] = s_master_ar_id[i];\n      assign                        master[i].ar_addr                      = s_master_ar_addr[i];\n      assign                        master[i].ar_len                       = s_master_ar_len[i];\n      assign                        master[i].ar_size                      = s_master_ar_size[i];\n      assign                        master[i].ar_burst                     = s_master_ar_burst[i];\n      assign                        master[i].ar_lock                      = s_master_ar_lock[i];\n      assign                        master[i].ar_cache                     = s_master_ar_cache[i];\n      assign                        master[i].ar_prot                      = s_master_ar_prot[i];\n      assign                        master[i].ar_region                    = s_master_ar_region[i];\n      assign                        master[i].ar_user                      = s_master_ar_user[i];\n      assign                        master[i].ar_qos                       = s_master_ar_qos[i];\n      assign                        master[i].ar_valid                     = s_master_ar_valid[i];\n      assign s_master_ar_ready[i] = master[i].ar_ready;\n\n      assign                        master[i].w_data  = s_master_w_data[i];\n      assign                        master[i].w_strb  = s_master_w_strb[i];\n      assign                        master[i].w_last  = s_master_w_last[i];\n      assign                        master[i].w_user  = s_master_w_user[i];\n      assign                        master[i].w_valid = s_master_w_valid[i];\n      assign s_master_w_ready[i]  = master[i].w_ready;\n\n      assign s_master_b_id[i]     = master[i].b_id[AXI_ID_WIDTH_INIT-1:0];\n      assign s_master_b_resp[i]   = master[i].b_resp;\n      assign s_master_b_valid[i]  = master[i].b_valid;\n      assign s_master_b_user[i]   = master[i].b_user;\n      assign                        master[i].b_ready = s_master_b_ready[i];\n\n      assign s_master_r_id[i]     = master[i].r_id[AXI_ID_WIDTH_INIT-1:0];\n      assign s_master_r_data[i]   = master[i].r_data;\n      assign s_master_r_resp[i]   = master[i].r_resp;\n      assign s_master_r_last[i]   = master[i].r_last;\n      assign s_master_r_user[i]   = master[i].r_user;\n      assign s_master_r_valid[i]  = master[i].r_valid;\n      assign                        master[i].r_ready = s_master_r_ready[i];\n\n      assign s_start_addr[0][i] = start_addr_i[i];\n      assign s_end_addr[0][i]   = end_addr_i[i];\n    end\n  endgenerate\n\n  generate\n    genvar j;\n    for(j = 0; j < NB_SLAVE; j++)\n    begin\n      assign s_slave_aw_id[j]     = slave[j].aw_id[AXI_ID_WIDTH_TARG-1:0];\n      assign s_slave_aw_addr[j]   = slave[j].aw_addr;\n      assign s_slave_aw_len[j]    = slave[j].aw_len;\n      assign s_slave_aw_size[j]   = slave[j].aw_size;\n      assign s_slave_aw_burst[j]  = slave[j].aw_burst;\n      assign s_slave_aw_lock[j]   = slave[j].aw_lock;\n      assign s_slave_aw_cache[j]  = slave[j].aw_cache;\n      assign s_slave_aw_prot[j]   = slave[j].aw_prot;\n      assign s_slave_aw_region[j] = slave[j].aw_region;\n      assign s_slave_aw_user[j]   = slave[j].aw_user;\n      assign s_slave_aw_qos[j]    = slave[j].aw_qos;\n      assign s_slave_aw_valid[j]  = slave[j].aw_valid;\n      assign                        slave[j].aw_ready = s_slave_aw_ready[j];\n\n      assign s_slave_ar_id[j]     = slave[j].ar_id[AXI_ID_WIDTH_TARG-1:0];\n      assign s_slave_ar_addr[j]   = slave[j].ar_addr;\n      assign s_slave_ar_len[j]    = slave[j].ar_len;\n      assign s_slave_ar_size[j]   = slave[j].ar_size;\n      assign s_slave_ar_burst[j]  = slave[j].ar_burst;\n      assign s_slave_ar_lock[j]   = slave[j].ar_lock;\n      assign s_slave_ar_cache[j]  = slave[j].ar_cache;\n      assign s_slave_ar_prot[j]   = slave[j].ar_prot;\n      assign s_slave_ar_region[j] = slave[j].ar_region;\n      assign s_slave_ar_user[j]   = slave[j].ar_user;\n      assign s_slave_ar_qos[j]    = slave[j].ar_qos;\n      assign s_slave_ar_valid[j]  = slave[j].ar_valid;\n      assign                        slave[j].ar_ready = s_slave_ar_ready[j];\n\n      assign s_slave_w_data[j]    = slave[j].w_data;\n      assign s_slave_w_strb[j]    = slave[j].w_strb;\n      assign s_slave_w_last[j]    = slave[j].w_last;\n      assign s_slave_w_user[j]    = slave[j].w_user;\n      assign s_slave_w_valid[j]   = slave[j].w_valid;\n      assign                        slave[j].w_ready = s_slave_w_ready[j];\n\n      assign                        slave[j].b_id[AXI_ID_WIDTH_TARG-1:0] = s_slave_b_id[j];\n      assign                        slave[j].b_resp                      = s_slave_b_resp[j];\n      assign                        slave[j].b_valid                     = s_slave_b_valid[j];\n      assign                        slave[j].b_user                      = s_slave_b_user[j];\n      assign s_slave_b_ready[j]   = slave[j].b_ready;\n\n      assign                        slave[j].r_id[AXI_ID_WIDTH_TARG-1:0] = s_slave_r_id[j];\n      assign                        slave[j].r_data                      = s_slave_r_data[j];\n      assign                        slave[j].r_resp                      = s_slave_r_resp[j];\n      assign                        slave[j].r_last                      = s_slave_r_last[j];\n      assign                        slave[j].r_user                      = s_slave_r_user[j];\n      assign                        slave[j].r_valid                     = s_slave_r_valid[j];\n      assign s_slave_r_ready[j]   = slave[j].r_ready;\n    end\n  endgenerate\n\n  axi_node\n  #(\n    .AXI_ADDRESS_W      ( AXI_ADDR_WIDTH    ),\n    .AXI_DATA_W         ( AXI_DATA_WIDTH    ),\n    .N_MASTER_PORT      ( NB_MASTER         ),\n    .N_SLAVE_PORT       ( NB_SLAVE          ),\n    .AXI_ID_IN          ( AXI_ID_WIDTH_TARG ),\n    .AXI_USER_W         ( AXI_USER_WIDTH    ),\n    .N_REGION           ( NB_REGION         )\n  )\n  axi_node_i\n  (\n    .clk                    ( clk                ),\n    .rst_n                  ( rst_n              ),\n    .test_en_i              ( test_en_i          ),\n\n    .slave_awid_i           ( s_slave_aw_id      ),\n    .slave_awaddr_i         ( s_slave_aw_addr    ),\n    .slave_awlen_i          ( s_slave_aw_len     ),\n    .slave_awsize_i         ( s_slave_aw_size    ),\n    .slave_awburst_i        ( s_slave_aw_burst   ),\n    .slave_awlock_i         ( s_slave_aw_lock    ),\n    .slave_awcache_i        ( s_slave_aw_cache   ),\n    .slave_awprot_i         ( s_slave_aw_prot    ),\n    .slave_awregion_i       ( s_slave_aw_region  ),\n    .slave_awqos_i          ( s_slave_aw_qos     ),\n    .slave_awuser_i         ( s_slave_aw_user    ),\n    .slave_awvalid_i        ( s_slave_aw_valid   ),\n    .slave_awready_o        ( s_slave_aw_ready   ),\n\n    .slave_wdata_i          ( s_slave_w_data     ),\n    .slave_wstrb_i          ( s_slave_w_strb     ),\n    .slave_wlast_i          ( s_slave_w_last     ),\n    .slave_wuser_i          ( s_slave_w_user     ),\n    .slave_wvalid_i         ( s_slave_w_valid    ),\n    .slave_wready_o         ( s_slave_w_ready    ),\n\n    .slave_bid_o            ( s_slave_b_id       ),\n    .slave_bresp_o          ( s_slave_b_resp     ),\n    .slave_buser_o          ( s_slave_b_user     ),\n    .slave_bvalid_o         ( s_slave_b_valid    ),\n    .slave_bready_i         ( s_slave_b_ready    ),\n\n    .slave_arid_i           ( s_slave_ar_id      ),\n    .slave_araddr_i         ( s_slave_ar_addr    ),\n    .slave_arlen_i          ( s_slave_ar_len     ),\n    .slave_arsize_i         ( s_slave_ar_size    ),\n    .slave_arburst_i        ( s_slave_ar_burst   ),\n    .slave_arlock_i         ( s_slave_ar_lock    ),\n    .slave_arcache_i        ( s_slave_ar_cache   ),\n    .slave_arprot_i         ( s_slave_ar_prot    ),\n    .slave_arregion_i       ( s_slave_ar_region  ),\n    .slave_aruser_i         ( s_slave_ar_user    ),\n    .slave_arqos_i          ( s_slave_ar_qos     ),\n    .slave_arvalid_i        ( s_slave_ar_valid   ),\n    .slave_arready_o        ( s_slave_ar_ready   ),\n\n    .slave_rid_o            ( s_slave_r_id       ),\n    .slave_rdata_o          ( s_slave_r_data     ),\n    .slave_rresp_o          ( s_slave_r_resp     ),\n    .slave_rlast_o          ( s_slave_r_last     ),\n    .slave_ruser_o          ( s_slave_r_user     ),\n    .slave_rvalid_o         ( s_slave_r_valid    ),\n    .slave_rready_i         ( s_slave_r_ready    ),\n\n    .master_awid_o          ( s_master_aw_id     ),\n    .master_awaddr_o        ( s_master_aw_addr   ),\n    .master_awlen_o         ( s_master_aw_len    ),\n    .master_awsize_o        ( s_master_aw_size   ),\n    .master_awburst_o       ( s_master_aw_burst  ),\n    .master_awlock_o        ( s_master_aw_lock   ),\n    .master_awcache_o       ( s_master_aw_cache  ),\n    .master_awprot_o        ( s_master_aw_prot   ),\n    .master_awregion_o      ( s_master_aw_region ),\n    .master_awqos_o         ( s_master_aw_qos    ),\n    .master_awuser_o        ( s_master_aw_user   ),\n    .master_awvalid_o       ( s_master_aw_valid  ),\n    .master_awready_i       ( s_master_aw_ready  ),\n\n    .master_wdata_o         ( s_master_w_data    ),\n    .master_wstrb_o         ( s_master_w_strb    ),\n    .master_wlast_o         ( s_master_w_last    ),\n    .master_wuser_o         ( s_master_w_user    ),\n    .master_wvalid_o        ( s_master_w_valid   ),\n    .master_wready_i        ( s_master_w_ready   ),\n\n    .master_bid_i           ( s_master_b_id      ),\n    .master_bresp_i         ( s_master_b_resp    ),\n    .master_buser_i         ( s_master_b_user    ),\n    .master_bvalid_i        ( s_master_b_valid   ),\n    .master_bready_o        ( s_master_b_ready   ),\n\n    .master_arid_o          ( s_master_ar_id     ),\n    .master_araddr_o        ( s_master_ar_addr   ),\n    .master_arlen_o         ( s_master_ar_len    ),\n    .master_arsize_o        ( s_master_ar_size   ),\n    .master_arburst_o       ( s_master_ar_burst  ),\n    .master_arlock_o        ( s_master_ar_lock   ),\n    .master_arcache_o       ( s_master_ar_cache  ),\n    .master_arprot_o        ( s_master_ar_prot   ),\n    .master_arregion_o      ( s_master_ar_region ),\n    .master_aruser_o        ( s_master_ar_user   ),\n    .master_arqos_o         ( s_master_ar_qos    ),\n    .master_arvalid_o       ( s_master_ar_valid  ),\n    .master_arready_i       ( s_master_ar_ready  ),\n\n    .master_rid_i           ( s_master_r_id      ),\n    .master_rdata_i         ( s_master_r_data    ),\n    .master_rresp_i         ( s_master_r_resp    ),\n    .master_rlast_i         ( s_master_r_last    ),\n    .master_ruser_i         ( s_master_r_user    ),\n    .master_rvalid_i        ( s_master_r_valid   ),\n    .master_rready_o        ( s_master_r_ready   ),\n\n    .cfg_START_ADDR_i       ( s_start_addr       ),\n    .cfg_END_ADDR_i         ( s_end_addr         ),\n    .cfg_valid_rule_i       ( s_valid_rule       ),\n    .cfg_connectivity_map_i ( s_connectivity_map )\n  );\n\n\n  assign s_valid_rule       = '1;\n\n  assign s_connectivity_map = '1;\n\nendmodule\n\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\nmodule axi_slice_wrap\n#(\n    parameter AXI_ADDR_WIDTH = 32,\n    parameter AXI_DATA_WIDTH = 64,\n    parameter AXI_USER_WIDTH = 6,\n    parameter AXI_ID_WIDTH   = 6,\n    parameter SLICE_DEPTH    = 2\n)\n(\n    input logic    clk_i,\n    input logic    rst_ni,\n    input logic    test_en_i,\n\n    AXI_BUS.Slave  axi_slave,\n    AXI_BUS.Master axi_master\n);\n\n  generate\n    if( SLICE_DEPTH > 1)\n    begin : WITH_SLICE\n      axi_slice\n      #(\n        .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH ),\n        .AXI_DATA_WIDTH ( AXI_DATA_WIDTH ),\n        .AXI_USER_WIDTH ( AXI_USER_WIDTH ),\n        .AXI_ID_WIDTH   ( AXI_ID_WIDTH   ),\n        .SLICE_DEPTH    ( SLICE_DEPTH    )\n      )\n      axi_slice_i\n      (\n        .clk_i                 ( clk_i                            ),\n        .rst_ni                ( rst_ni                           ),\n        .test_en_i             ( test_en_i                        ),\n\n        .axi_slave_aw_valid_i  ( axi_slave.aw_valid               ),\n        .axi_slave_aw_addr_i   ( axi_slave.aw_addr                ),\n        .axi_slave_aw_prot_i   ( axi_slave.aw_prot                ),\n        .axi_slave_aw_region_i ( axi_slave.aw_region              ),\n        .axi_slave_aw_len_i    ( axi_slave.aw_len                 ),\n        .axi_slave_aw_size_i   ( axi_slave.aw_size                ),\n        .axi_slave_aw_burst_i  ( axi_slave.aw_burst               ),\n        .axi_slave_aw_lock_i   ( axi_slave.aw_lock                ),\n        .axi_slave_aw_cache_i  ( axi_slave.aw_cache               ),\n        .axi_slave_aw_qos_i    ( axi_slave.aw_qos                 ),\n        .axi_slave_aw_id_i     ( axi_slave.aw_id[AXI_ID_WIDTH-1:0]),\n        .axi_slave_aw_user_i   ( axi_slave.aw_user                ),\n        .axi_slave_aw_ready_o  ( axi_slave.aw_ready               ),\n\n        .axi_slave_ar_valid_i  ( axi_slave.ar_valid               ),\n        .axi_slave_ar_addr_i   ( axi_slave.ar_addr                ),\n        .axi_slave_ar_prot_i   ( axi_slave.ar_prot                ),\n        .axi_slave_ar_region_i ( axi_slave.ar_region              ),\n        .axi_slave_ar_len_i    ( axi_slave.ar_len                 ),\n        .axi_slave_ar_size_i   ( axi_slave.ar_size                ),\n        .axi_slave_ar_burst_i  ( axi_slave.ar_burst               ),\n        .axi_slave_ar_lock_i   ( axi_slave.ar_lock                ),\n        .axi_slave_ar_cache_i  ( axi_slave.ar_cache               ),\n        .axi_slave_ar_qos_i    ( axi_slave.ar_qos                 ),\n        .axi_slave_ar_id_i     ( axi_slave.ar_id[AXI_ID_WIDTH-1:0]),\n        .axi_slave_ar_user_i   ( axi_slave.ar_user                ),\n        .axi_slave_ar_ready_o  ( axi_slave.ar_ready               ),\n\n        .axi_slave_w_valid_i   ( axi_slave.w_valid                ),\n        .axi_slave_w_data_i    ( axi_slave.w_data                 ),\n        .axi_slave_w_strb_i    ( axi_slave.w_strb                 ),\n        .axi_slave_w_user_i    ( axi_slave.w_user                 ),\n        .axi_slave_w_last_i    ( axi_slave.w_last                 ),\n        .axi_slave_w_ready_o   ( axi_slave.w_ready                ),\n\n        .axi_slave_r_valid_o   ( axi_slave.r_valid                ),\n        .axi_slave_r_data_o    ( axi_slave.r_data                 ),\n        .axi_slave_r_resp_o    ( axi_slave.r_resp                 ),\n        .axi_slave_r_last_o    ( axi_slave.r_last                 ),\n        .axi_slave_r_id_o      ( axi_slave.r_id[AXI_ID_WIDTH-1:0] ),\n        .axi_slave_r_user_o    ( axi_slave.r_user                 ),\n        .axi_slave_r_ready_i   ( axi_slave.r_ready                ),\n\n        .axi_slave_b_valid_o   ( axi_slave.b_valid                ),\n        .axi_slave_b_resp_o    ( axi_slave.b_resp                 ),\n        .axi_slave_b_id_o      ( axi_slave.b_id[AXI_ID_WIDTH-1:0] ),\n        .axi_slave_b_user_o    ( axi_slave.b_user                 ),\n        .axi_slave_b_ready_i   ( axi_slave.b_ready                ),\n\n        .axi_master_aw_valid_o ( axi_master.aw_valid               ),\n        .axi_master_aw_addr_o  ( axi_master.aw_addr                ),\n        .axi_master_aw_prot_o  ( axi_master.aw_prot                ),\n        .axi_master_aw_region_o( axi_master.aw_region              ),\n        .axi_master_aw_len_o   ( axi_master.aw_len                 ),\n        .axi_master_aw_size_o  ( axi_master.aw_size                ),\n        .axi_master_aw_burst_o ( axi_master.aw_burst               ),\n        .axi_master_aw_lock_o  ( axi_master.aw_lock                ),\n        .axi_master_aw_cache_o ( axi_master.aw_cache               ),\n        .axi_master_aw_qos_o   ( axi_master.aw_qos                 ),\n        .axi_master_aw_id_o    ( axi_master.aw_id[AXI_ID_WIDTH-1:0]),\n        .axi_master_aw_user_o  ( axi_master.aw_user                ),\n        .axi_master_aw_ready_i ( axi_master.aw_ready               ),\n\n        .axi_master_ar_valid_o ( axi_master.ar_valid               ),\n        .axi_master_ar_addr_o  ( axi_master.ar_addr                ),\n        .axi_master_ar_prot_o  ( axi_master.ar_prot                ),\n        .axi_master_ar_region_o( axi_master.ar_region              ),\n        .axi_master_ar_len_o   ( axi_master.ar_len                 ),\n        .axi_master_ar_size_o  ( axi_master.ar_size                ),\n        .axi_master_ar_burst_o ( axi_master.ar_burst               ),\n        .axi_master_ar_lock_o  ( axi_master.ar_lock                ),\n        .axi_master_ar_cache_o ( axi_master.ar_cache               ),\n        .axi_master_ar_qos_o   ( axi_master.ar_qos                 ),\n        .axi_master_ar_id_o    ( axi_master.ar_id[AXI_ID_WIDTH-1:0]),\n        .axi_master_ar_user_o  ( axi_master.ar_user                ),\n        .axi_master_ar_ready_i ( axi_master.ar_ready               ),\n\n        .axi_master_w_valid_o  ( axi_master.w_valid                ),\n        .axi_master_w_data_o   ( axi_master.w_data                 ),\n        .axi_master_w_strb_o   ( axi_master.w_strb                 ),\n        .axi_master_w_user_o   ( axi_master.w_user                 ),\n        .axi_master_w_last_o   ( axi_master.w_last                 ),\n        .axi_master_w_ready_i  ( axi_master.w_ready                ),\n\n        .axi_master_r_valid_i  ( axi_master.r_valid                ),\n        .axi_master_r_data_i   ( axi_master.r_data                 ),\n        .axi_master_r_resp_i   ( axi_master.r_resp                 ),\n        .axi_master_r_last_i   ( axi_master.r_last                 ),\n        .axi_master_r_id_i     ( axi_master.r_id[AXI_ID_WIDTH-1:0] ),\n        .axi_master_r_user_i   ( axi_master.r_user                 ),\n        .axi_master_r_ready_o  ( axi_master.r_ready                ),\n\n        .axi_master_b_valid_i  ( axi_master.b_valid                ),\n        .axi_master_b_resp_i   ( axi_master.b_resp                 ),\n        .axi_master_b_id_i     ( axi_master.b_id[AXI_ID_WIDTH-1:0] ),\n        .axi_master_b_user_i   ( axi_master.b_user                 ),\n        .axi_master_b_ready_o  ( axi_master.b_ready                )\n      );\n    end\n    else\n    begin : NO_SLICE\n      assign axi_master.aw_valid  =  axi_slave.aw_valid;\n      assign axi_master.aw_addr   =  axi_slave.aw_addr;\n      assign axi_master.aw_prot   =  axi_slave.aw_prot;\n      assign axi_master.aw_region =  axi_slave.aw_region;\n      assign axi_master.aw_len    =  axi_slave.aw_len;\n      assign axi_master.aw_size   =  axi_slave.aw_size;\n      assign axi_master.aw_burst  =  axi_slave.aw_burst;\n      assign axi_master.aw_lock   =  axi_slave.aw_lock;\n      assign axi_master.aw_cache  =  axi_slave.aw_cache;\n      assign axi_master.aw_qos    =  axi_slave.aw_qos;\n      assign axi_master.aw_id     =  axi_slave.aw_id;\n      assign axi_master.aw_user   =  axi_slave.aw_user;\n      assign axi_slave.aw_ready   =  axi_master.aw_ready;\n\n      assign axi_master.ar_valid  =  axi_slave.ar_valid;\n      assign axi_master.ar_addr   =  axi_slave.ar_addr;\n      assign axi_master.ar_prot   =  axi_slave.ar_prot;\n      assign axi_master.ar_region =  axi_slave.ar_region;\n      assign axi_master.ar_len    =  axi_slave.ar_len;\n      assign axi_master.ar_size   =  axi_slave.ar_size;\n      assign axi_master.ar_burst  =  axi_slave.ar_burst;\n      assign axi_master.ar_lock   =  axi_slave.ar_lock;\n      assign axi_master.ar_cache  =  axi_slave.ar_cache;\n      assign axi_master.ar_qos    =  axi_slave.ar_qos;\n      assign axi_master.ar_id     =  axi_slave.ar_id;\n      assign axi_master.ar_user   =  axi_slave.ar_user;\n      assign axi_slave.ar_ready   =  axi_master.ar_ready;\n\n      assign axi_master.w_valid   =  axi_slave.w_valid;\n      assign axi_master.w_data    =  axi_slave.w_data;\n      assign axi_master.w_strb    =  axi_slave.w_strb;\n      assign axi_master.w_user    =  axi_slave.w_user;\n      assign axi_master.w_last    =  axi_slave.w_last;\n      assign axi_slave.w_ready    =  axi_master.w_ready;\n\n      assign axi_slave.r_valid    =  axi_master.r_valid;\n      assign axi_slave.r_data     =  axi_master.r_data;\n      assign axi_slave.r_resp     =  axi_master.r_resp;\n      assign axi_slave.r_last     =  axi_master.r_last;\n      assign axi_slave.r_id       =  axi_master.r_id;\n      assign axi_slave.r_user     =  axi_master.r_user;\n      assign axi_master.r_ready   =  axi_slave.r_ready;\n\n      assign axi_slave.b_valid    = axi_master.b_valid;\n      assign axi_slave.b_resp     = axi_master.b_resp;\n      assign axi_slave.b_id       = axi_master.b_id;\n      assign axi_slave.b_user     = axi_master.b_user;\n      assign axi_master.b_ready   = axi_slave.b_ready;\n    end\n  endgenerate\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\nmodule axi_spi_slave_wrap\n#(\n    parameter AXI_ADDRESS_WIDTH = 32,\n    parameter AXI_DATA_WIDTH    = 64,\n    parameter AXI_ID_WIDTH      = 16,\n    parameter AXI_USER_WIDTH    = 10\n  )\n(\n    input logic              clk_i,\n    input logic              rst_ni,\n\n    input logic              test_mode,\n\n    AXI_BUS.Master           axi_master,\n\n    input  logic             spi_clk,\n    input  logic             spi_cs,\n    output logic [1:0]       spi_mode,\n    output logic             spi_sdo0,\n    output logic             spi_sdo1,\n    output logic             spi_sdo2,\n    output logic             spi_sdo3,\n    input  logic             spi_sdi0,\n    input  logic             spi_sdi1,\n    input  logic             spi_sdi2,\n    input  logic             spi_sdi3\n  );\n\n  axi_spi_slave\n  #(\n    .AXI_ADDR_WIDTH ( AXI_ADDRESS_WIDTH ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH    ),\n    .AXI_ID_WIDTH   ( AXI_ID_WIDTH      ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH    )\n    )\n  axi_spi_slave_i\n  (\n    .axi_aclk             ( clk_i                ),\n    .axi_aresetn          ( rst_ni               ),\n\n    .axi_master_aw_valid  ( axi_master.aw_valid  ),\n    .axi_master_aw_id     ( axi_master.aw_id     ),\n    .axi_master_aw_prot   ( axi_master.aw_prot   ),\n    .axi_master_aw_region ( axi_master.aw_region ),\n    .axi_master_aw_qos    ( axi_master.aw_qos    ),\n    .axi_master_aw_cache  ( axi_master.aw_cache  ),\n    .axi_master_aw_lock   ( axi_master.aw_lock   ),\n    .axi_master_aw_burst  ( axi_master.aw_burst  ),\n    .axi_master_aw_size   ( axi_master.aw_size   ),\n    .axi_master_aw_len    ( axi_master.aw_len    ),\n    .axi_master_aw_addr   ( axi_master.aw_addr   ),\n    .axi_master_aw_user   ( axi_master.aw_user   ),\n    .axi_master_aw_ready  ( axi_master.aw_ready  ),\n\n    .axi_master_w_valid   ( axi_master.w_valid   ),\n    .axi_master_w_data    ( axi_master.w_data    ),\n    .axi_master_w_strb    ( axi_master.w_strb    ),\n    .axi_master_w_last    ( axi_master.w_last    ),\n    .axi_master_w_user    ( axi_master.w_user    ),\n    .axi_master_w_ready   ( axi_master.w_ready   ),\n\n    .axi_master_b_valid   ( axi_master.b_valid   ),\n    .axi_master_b_id      ( axi_master.b_id      ),\n    .axi_master_b_resp    ( axi_master.b_resp    ),\n    .axi_master_b_user    ( axi_master.b_user    ),\n    .axi_master_b_ready   ( axi_master.b_ready   ),\n\n    .axi_master_ar_valid  ( axi_master.ar_valid  ),\n    .axi_master_ar_id     ( axi_master.ar_id     ),\n    .axi_master_ar_prot   ( axi_master.ar_prot   ),\n    .axi_master_ar_region ( axi_master.ar_region ),\n    .axi_master_ar_qos    ( axi_master.ar_qos    ),\n    .axi_master_ar_cache  ( axi_master.ar_cache  ),\n    .axi_master_ar_lock   ( axi_master.ar_lock   ),\n    .axi_master_ar_burst  ( axi_master.ar_burst  ),\n    .axi_master_ar_size   ( axi_master.ar_size   ),\n    .axi_master_ar_len    ( axi_master.ar_len    ),\n    .axi_master_ar_addr   ( axi_master.ar_addr   ),\n    .axi_master_ar_user   ( axi_master.ar_user   ),\n    .axi_master_ar_ready  ( axi_master.ar_ready  ),\n\n    .axi_master_r_valid   ( axi_master.r_valid   ),\n    .axi_master_r_id      ( axi_master.r_id      ),\n    .axi_master_r_data    ( axi_master.r_data    ),\n    .axi_master_r_resp    ( axi_master.r_resp    ),\n    .axi_master_r_last    ( axi_master.r_last    ),\n    .axi_master_r_user    ( axi_master.r_user    ),\n    .axi_master_r_ready   ( axi_master.r_ready   ),\n\n    .test_mode            ( test_mode            ),\n\n    .spi_sclk             ( spi_clk              ),\n    .spi_cs               ( spi_cs               ),\n    .spi_mode             ( spi_mode             ),\n    .spi_sdo0             ( spi_sdo0             ),\n    .spi_sdo1             ( spi_sdo1             ),\n    .spi_sdo2             ( spi_sdo2             ),\n    .spi_sdo3             ( spi_sdo3             ),\n    .spi_sdi0             ( spi_sdi0             ),\n    .spi_sdi1             ( spi_sdi1             ),\n    .spi_sdi2             ( spi_sdi2             ),\n    .spi_sdi3             ( spi_sdi3             )\n  );\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule boot_code\n(\n    input  logic        CLK,\n    input  logic        RSTN,\n\n    input  logic        CSN,\n    input  logic [9:0]  A,\n    output logic [31:0] Q\n  );\n\n  const logic [0:547] [31:0] mem = {\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h00000013,\n    32'h0100006F,\n    32'h0100006F,\n    32'h0080006F,\n    32'h0040006F,\n    32'h0000006F,\n    32'h00000093,\n    32'h00008113,\n    32'h00008193,\n    32'h00008213,\n    32'h00008293,\n    32'h00008313,\n    32'h00008393,\n    32'h00008413,\n    32'h00008493,\n    32'h00008513,\n    32'h00008593,\n    32'h00008613,\n    32'h00008693,\n    32'h00008713,\n    32'h00008793,\n    32'h00008813,\n    32'h00008893,\n    32'h00008913,\n    32'h00008993,\n    32'h00008A13,\n    32'h00008A93,\n    32'h00008B13,\n    32'h00008B93,\n    32'h00008C13,\n    32'h00008C93,\n    32'h00008D13,\n    32'h00008D93,\n    32'h00008E13,\n    32'h00008E93,\n    32'h00008F13,\n    32'h00008F93,\n    32'h00100117,\n    32'hEF410113,\n    32'h00000D17,\n    32'h7F8D0D13,\n    32'h00000D97,\n    32'h7F0D8D93,\n    32'h01BD5863,\n    32'h000D2023,\n    32'h004D0D13,\n    32'hFFADDCE3,\n    32'h00000513,\n    32'h00000593,\n    32'h072000EF,\n    32'h00000000,\n    32'h00000000,\n    32'h00000000,\n    32'h00000000,\n    32'h46811101,\n    32'h45A14601,\n    32'h09F00513,\n    32'h00EFCE06,\n    32'h05133620,\n    32'h00EF0400,\n    32'h45813B60,\n    32'h00EF4501,\n    32'h45813960,\n    32'h00EF4501,\n    32'h00283DE0,\n    32'h04000593,\n    32'h420000EF,\n    32'h55134722,\n    32'h157D0187,\n    32'hDE8717B3,\n    32'h21900713,\n    32'h00A03533,\n    32'h00E78863,\n    32'h07616709,\n    32'h37B38F99,\n    32'h953E00F0,\n    32'h610540F2,\n    32'h715D8082,\n    32'hC6864505,\n    32'hC2A6C4A2,\n    32'hDE4EC0CA,\n    32'hDA56DC52,\n    32'hD65ED85A,\n    32'hD266D462,\n    32'h00EFD06A,\n    32'h458525A0,\n    32'h00EF4501,\n    32'h67854460,\n    32'hBB878793,\n    32'h0037C0FB,\n    32'h00010001,\n    32'h27B74711,\n    32'hC3D81A10,\n    32'hF65FF0EF,\n    32'h8537C911,\n    32'h05930000,\n    32'h05130240,\n    32'h00EF7185,\n    32'hA0014760,\n    32'h00008537,\n    32'h051345C5,\n    32'h00EF7405,\n    32'h45A14660,\n    32'h46014681,\n    32'h00EF4519,\n    32'h45012A60,\n    32'h2FC000EF,\n    32'h45054581,\n    32'h32C000EF,\n    32'h358000EF,\n    32'h10055433,\n    32'hFE143CE3,\n    32'h80000637,\n    32'h069345A1,\n    32'h06130200,\n    32'h05133486,\n    32'h00EF0710,\n    32'h45012760,\n    32'h2CC000EF,\n    32'h85224581,\n    32'h2FC000EF,\n    32'h328000EF,\n    32'h10055533,\n    32'hFE153CE3,\n    32'h45214581,\n    32'h298000EF,\n    32'h02000693,\n    32'h45A14601,\n    32'h0EB00513,\n    32'h244000EF,\n    32'h10000513,\n    32'h298000EF,\n    32'h45094581,\n    32'h2C8000EF,\n    32'h10000593,\n    32'h00EF850A,\n    32'h853730A0,\n    32'h45D50000,\n    32'h75450513,\n    32'h49024CB2,\n    32'h44C24C12,\n    32'h4B724AD2,\n    32'h3C4000EF,\n    32'h45214581,\n    32'h24C000EF,\n    32'h07905E63,\n    32'h49816421,\n    32'h412C0C33,\n    32'h00008BB7,\n    32'h7B040413,\n    32'h00008A37,\n    32'h16136D05,\n    32'h06930089,\n    32'h45A10200,\n    32'h0EB00513,\n    32'h1DC000EF,\n    32'h00EF6521,\n    32'h45812320,\n    32'h00EF4509,\n    32'h05332620,\n    32'h65A1012C,\n    32'h2A4000EF,\n    32'h85134599,\n    32'h00EF76CB,\n    32'hD51336E0,\n    32'h45850049,\n    32'h00EF9522,\n    32'hB5333620,\n    32'h4585F649,\n    32'h00EF9522,\n    32'h09853560,\n    32'h05134599,\n    32'h00EF774A,\n    32'h996A34A0,\n    32'h388000EF,\n    32'hFB3C91E3,\n    32'h24C000EF,\n    32'h10055533,\n    32'hFE153CE3,\n    32'h00008537,\n    32'h051345B5,\n    32'h00EF77C5,\n    32'h00EF3260,\n    32'h45813660,\n    32'h00EF4521,\n    32'h5E631AA0,\n    32'h64210760,\n    32'h409A89B3,\n    32'h8BB74901,\n    32'h04130000,\n    32'h8A377B04,\n    32'h6A850000,\n    32'h00849613,\n    32'h02000693,\n    32'h051345A1,\n    32'h00EF0EB0,\n    32'h652113A0,\n    32'h190000EF,\n    32'h45094581,\n    32'h1C0000EF,\n    32'h00998533,\n    32'h00EF65A1,\n    32'h45992020,\n    32'h76CB8513,\n    32'h2CC000EF,\n    32'h00495513,\n    32'h95224585,\n    32'h2C0000EF,\n    32'hF6493533,\n    32'h95224585,\n    32'h2B4000EF,\n    32'h45990905,\n    32'h774A0513,\n    32'h2A8000EF,\n    32'h00EF94D6,\n    32'h11E32E60,\n    32'h8537FB2B,\n    32'h05930000,\n    32'h05130220,\n    32'h00EF78C5,\n    32'h00EF28E0,\n    32'h77B72CE0,\n    32'hA4231A10,\n    32'h07930007,\n    32'h80670800,\n    32'h00010007,\n    32'h00010001,\n    32'h450140B6,\n    32'h44964426,\n    32'h59F24906,\n    32'h5AD25A62,\n    32'h5BB25B42,\n    32'h5C925C22,\n    32'h61615D02,\n    32'h00008082,\n    32'hFF010113,\n    32'h00812423,\n    32'h00000593,\n    32'h00050413,\n    32'h00F00513,\n    32'h00112623,\n    32'h294000EF,\n    32'h00000593,\n    32'h00E00513,\n    32'h288000EF,\n    32'h00000593,\n    32'h00D00513,\n    32'h27C000EF,\n    32'h00000593,\n    32'h00C00513,\n    32'h270000EF,\n    32'h04805663,\n    32'h00000593,\n    32'h01000513,\n    32'h260000EF,\n    32'h02142E63,\n    32'h00000593,\n    32'h00B00513,\n    32'h250000EF,\n    32'h02242663,\n    32'h00000593,\n    32'h00000513,\n    32'h240000EF,\n    32'h00342E63,\n    32'h00C12083,\n    32'h00812403,\n    32'h00000593,\n    32'h00100513,\n    32'h01010113,\n    32'h2240006F,\n    32'h00C12083,\n    32'h00812403,\n    32'h01010113,\n    32'h00008067,\n    32'h00004837,\n    32'hF0080813,\n    32'h00869693,\n    32'h02000713,\n    32'h1A1027B7,\n    32'h40B70733,\n    32'h0106F6B3,\n    32'hF265B5B3,\n    32'h00E51533,\n    32'h00878813,\n    32'h00C78713,\n    32'h00B6E5B3,\n    32'h01078793,\n    32'h00A82023,\n    32'h00C72023,\n    32'h00B7A023,\n    32'h00008067,\n    32'h01059593,\n    32'h10055533,\n    32'h00A5E5B3,\n    32'h1A1027B7,\n    32'h00B7AA23,\n    32'h00008067,\n    32'h1A102737,\n    32'h01070713,\n    32'h00072783,\n    32'hFF010113,\n    32'h00F12623,\n    32'h00C12783,\n    32'h1007D7B3,\n    32'h01051513,\n    32'h00F56533,\n    32'h00A12623,\n    32'h00C12783,\n    32'h00F72023,\n    32'h01010113,\n    32'h00008067,\n    32'h00100793,\n    32'h00858593,\n    32'h00B795B3,\n    32'h00A79533,\n    32'h000017B7,\n    32'hF0078793,\n    32'h00F5F5B3,\n    32'hEE853533,\n    32'h00A5E533,\n    32'h1A1027B7,\n    32'h00A7A023,\n    32'h00008067,\n    32'h1A1027B7,\n    32'h0007A783,\n    32'hFF010113,\n    32'h00F12623,\n    32'h00C12503,\n    32'h01010113,\n    32'h00008067,\n    32'hD45597B3,\n    32'hFF010113,\n    32'hF455B5B3,\n    32'h00F12423,\n    32'h00058863,\n    32'h00812783,\n    32'h00178793,\n    32'h00F12423,\n    32'h00012623,\n    32'h00C12683,\n    32'h1A102737,\n    32'h00812783,\n    32'h02070813,\n    32'h02F6DE63,\n    32'h00072783,\n    32'hCF0797B3,\n    32'hFE078CE3,\n    32'h00C12783,\n    32'h00082583,\n    32'h00C12683,\n    32'h00168693,\n    32'h00D12623,\n    32'h01010613,\n    32'h00279793,\n    32'hFFC62603,\n    32'h00812683,\n    32'h00B567A3,\n    32'hFCD646E3,\n    32'h01010113,\n    32'h00008067,\n    32'h1A107737,\n    32'h00470713,\n    32'h00072603,\n    32'h1A1007B7,\n    32'hC0164633,\n    32'h00C72023,\n    32'h00478693,\n    32'h00C78513,\n    32'h0085D813,\n    32'h08300713,\n    32'h0FF5F593,\n    32'h00E52023,\n    32'h0106A023,\n    32'h0A700713,\n    32'h00B7A42B,\n    32'h00E7A023,\n    32'h00300793,\n    32'h00F52023,\n    32'h0006A783,\n    32'h0F07F793,\n    32'hC017C7B3,\n    32'h00F6A023,\n    32'h00008067,\n    32'h1A100737,\n    32'h01470713,\n    32'h02058863,\n    32'h04000693,\n    32'h00072783,\n    32'h0207F793,\n    32'hFE078CE3,\n    32'h0015460B,\n    32'h1A1007B7,\n    32'hFFF58593,\n    32'h00C7A023,\n    32'hFFF68693,\n    32'h00069663,\n    32'hFC059CE3,\n    32'h00008067,\n    32'hFC059AE3,\n    32'h00008067,\n    32'h1A100737,\n    32'h01470713,\n    32'h00072783,\n    32'h0407F793,\n    32'hFE078CE3,\n    32'h00008067,\n    32'h1A1076B7,\n    32'h0006A783,\n    32'hFF010113,\n    32'h00F12623,\n    32'h00100793,\n    32'h00A797B3,\n    32'h00C12703,\n    32'hFFF7C793,\n    32'h00E7F7B3,\n    32'h00F12623,\n    32'h00C12783,\n    32'h00A595B3,\n    32'h00F5E533,\n    32'h00A12623,\n    32'h00C12783,\n    32'h00F6A023,\n    32'h01010113,\n    32'h00008067,\n    32'h4F525245,\n    32'h53203A52,\n    32'h736E6170,\n    32'h206E6F69,\n    32'h20495053,\n    32'h73616C66,\n    32'h6F6E2068,\n    32'h6F662074,\n    32'h0A646E75,\n    32'h00000000,\n    32'h64616F4C,\n    32'h20676E69,\n    32'h6D6F7266,\n    32'h49505320,\n    32'h0000000A,\n    32'h79706F43,\n    32'h20676E69,\n    32'h74736E49,\n    32'h74637572,\n    32'h736E6F69,\n    32'h0000000A,\n    32'h636F6C42,\n    32'h0000206B,\n    32'h6E6F6420,\n    32'h00000A65,\n    32'h79706F43,\n    32'h20676E69,\n    32'h61746144,\n    32'h0000000A,\n    32'h656E6F44,\n    32'h756A202C,\n    32'h6E69706D,\n    32'h6F742067,\n    32'h736E4920,\n    32'h63757274,\n    32'h6E6F6974,\n    32'h4D415220,\n    32'h00000A2E,\n    32'h33323130,\n    32'h37363534,\n    32'h42413938,\n    32'h46454443,\n    32'h00000010,\n    32'h00000000,\n    32'h00527A01,\n    32'h01010401,\n    32'h00020D1B,\n    32'h00000014,\n    32'h00000018,\n    32'hFFFFF974,\n    32'h0000005E,\n    32'h200E4200,\n    32'h7F01114C,\n    32'h00000038,\n    32'h00000030,\n    32'hFFFFF9BA,\n    32'h00000274,\n    32'h500E4200,\n    32'h7F01115A,\n    32'h117E0811,\n    32'h12117D09,\n    32'h7B13117C,\n    32'h117A1411,\n    32'h16117915,\n    32'h77171178,\n    32'h11761811,\n    32'h1A117519,\n    32'h00000074,\n    32'h00000018,\n    32'h0000006C,\n    32'hFFFFFBF4,\n    32'h0000009C,\n    32'h100E4400,\n    32'h7E081148,\n    32'h7F01114C,\n    32'h00000010,\n    32'h00000088,\n    32'hFFFFFC74,\n    32'h00000044,\n    32'h00000000,\n    32'h00000010,\n    32'h0000009C,\n    32'hFFFFFCA4,\n    32'h00000018,\n    32'h00000000,\n    32'h00000010,\n    32'h000000B0,\n    32'hFFFFFCA8,\n    32'h00000038,\n    32'h100E5000,\n    32'h00000010,\n    32'h000000C4,\n    32'hFFFFFCCC,\n    32'h00000030};\n\n  logic [9:0] A_Q;\n\n  always_ff @(posedge CLK, negedge RSTN)\n  begin\n    if (~RSTN)\n      A_Q <= '0;\n    else\n      if (~CSN)\n        A_Q <= A;\n  end\n\n  assign Q = mem[A_Q];\n\nendmodule"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\n`include \"config.sv\"\n\nmodule boot_rom_wrap\n  #(\n    parameter ADDR_WIDTH = `ROM_ADDR_WIDTH,\n    parameter DATA_WIDTH = 32\n  )(\n    // Clock and Reset\n    input  logic                  clk,\n    input  logic                  rst_n,\n    input  logic                  en_i,\n    input  logic [ADDR_WIDTH-1:0] addr_i,\n    output logic [DATA_WIDTH-1:0] rdata_o\n  );\n\n  boot_code\n  boot_code_i\n  (\n    .CLK   ( clk                    ),\n    .RSTN  ( rst_n                  ),\n    .CSN   ( ~en_i                  ),\n    .A     ( addr_i[ADDR_WIDTH-1:2] ),\n    .Q     ( rdata_o                )\n  );\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\nmodule clk_rst_gen\n(\n    input  logic                            clk_i,\n    input  logic                            rstn_i,\n\n    input  logic                            clk_sel_i,\n    input  logic                            clk_standalone_i,\n    input  logic                            testmode_i,\n    input  logic                            scan_en_i,\n    input  logic                            scan_i,\n    output logic                            scan_o,\n\n    input  logic                            fll_req_i,\n    input  logic                            fll_wrn_i,\n    input  logic                [1:0]       fll_add_i,\n    input  logic               [31:0]       fll_data_i,\n    output logic                            fll_ack_o,\n    output logic               [31:0]       fll_r_data_o,\n    output logic                            fll_lock_o,\n\n    output logic                            clk_o,\n    output logic                            rstn_o\n);\n\n  logic clk_fll_int;\n  logic clk_int;\n\n  cluster_clock_mux2\n  clk_mux_i\n  (\n      .clk_sel_i ( clk_sel_i     ),\n      .clk0_i    ( clk_i         ),\n      .clk1_i    ( clk_fll_int   ),\n      .clk_o     ( clk_int       )\n  );\n\n  //----------------------------------------------------------------------------//\n  // FLL\n  //----------------------------------------------------------------------------//\n\n`ifdef ASIC\n  umcL65_LL_FLL\n  fll_i\n  (\n    .FLLCLK     ( clk_fll_int       ),\n    .FLLOE      ( 1'b1              ),\n    .REFCLK     ( clk_i             ),\n    .LOCK       ( fll_lock_o        ),\n    .CFGREQ     ( fll_req_i         ),\n    .CFGACK     ( fll_ack_o         ),\n    .CFGAD      ( fll_add_i         ),\n    .CFGD       ( fll_data_i        ),\n    .CFGQ       ( fll_r_data_o      ),\n    .CFGWEB     ( fll_wrn_i         ),\n    .RSTB       ( rstn_i            ),\n    .PWDB       ( clk_sel_i         ),\n    .STAB       ( clk_standalone_i  ),\n    .TM         ( testmode_i        ),\n    .TE         ( scan_en_i         ),\n    .TD         ( scan_i            ),\n    .TQ         ( scan_o            )\n  );\n`else\n  assign fll_ack_o    = fll_req_i;\n  assign fll_r_data_o = 1'b0;\n  assign fll_lock_o   = 1'b0;\n  assign scan_o       = 1'b0;\n`endif\n\n  //----------------------------------------------------------------------------//\n  // Reset synchronizer\n  //----------------------------------------------------------------------------//\n  rstgen i_rst_gen_soc\n  (\n      // PAD FRAME SIGNALS\n      .clk_i               ( clk_int         ),\n      .rst_ni              ( rstn_i          ),\n\n      // TEST MODE\n      .test_mode_i         ( testmode_i      ),\n\n      // OUTPUT RESET\n      .rst_no              ( rstn_o          ),\n      .init_no             (                 )\n  );\n\n\n  assign clk_o = clk_int;\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule clk_rst_gen\n(\n    input         ref_clk_i,\n    input         rst_ni,\n\n    input         clking_axi_aclk,\n    input         clking_axi_aresetn,\n    input  [10:0] clking_axi_awaddr,\n    input         clking_axi_awvalid,\n    output        clking_axi_awready,\n    input  [31:0] clking_axi_wdata,\n    input   [3:0] clking_axi_wstrb,\n    input         clking_axi_wvalid,\n    output        clking_axi_wready,\n    output  [1:0] clking_axi_bresp,\n    output        clking_axi_bvalid,\n    input         clking_axi_bready,\n    input  [10:0] clking_axi_araddr,\n    input         clking_axi_arvalid,\n    output        clking_axi_arready,\n    output [31:0] clking_axi_rdata,\n    output  [1:0] clking_axi_rresp,\n    output        clking_axi_rvalid,\n    input         clking_axi_rready,\n\n    output        rstn_pulpino_o,\n    output        clk_pulpino_o\n);\n\n    wire s_clk_int;\n\n    xilinx_clock_manager clk_manager_i\n    (\n        .s_axi_aclk    ( clking_axi_aclk    ),\n        .s_axi_aresetn ( clking_axi_aresetn ),\n        .s_axi_awaddr  ( clking_axi_awaddr  ),\n        .s_axi_awvalid ( clking_axi_awvalid ),\n        .s_axi_awready ( clking_axi_awready ),\n        .s_axi_wdata   ( clking_axi_wdata   ),\n        .s_axi_wstrb   ( clking_axi_wstrb   ),\n        .s_axi_wvalid  ( clking_axi_wvalid  ),\n        .s_axi_wready  ( clking_axi_wready  ),\n        .s_axi_bresp   ( clking_axi_bresp   ),\n        .s_axi_bvalid  ( clking_axi_bvalid  ),\n        .s_axi_bready  ( clking_axi_bready  ),\n        .s_axi_araddr  ( clking_axi_araddr  ),\n        .s_axi_arvalid ( clking_axi_arvalid ),\n        .s_axi_arready ( clking_axi_arready ),\n        .s_axi_rdata   ( clking_axi_rdata   ),\n        .s_axi_rresp   ( clking_axi_rresp   ),\n        .s_axi_rvalid  ( clking_axi_rvalid  ),\n        .s_axi_rready  ( clking_axi_rready  ),\n        .clk50_i       ( ref_clk_i          ),\n        .clk_o         ( s_clk_int          ),\n        .rst_no        (                    )\n    );\n\n    assign rstn_pulpino_o          = rst_ni;\n    assign clk_pulpino_o           = s_clk_int;\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule cluster_clock_gating\n(\n    input  logic clk_i,\n    input  logic en_i,\n    input  logic test_en_i,\n    output logic clk_o\n  );\n\n`ifdef PULP_FPGA_EMUL\n  // no clock gates in FPGA flow\n  assign clk_o = clk_i;\n`else\n  logic clk_en;\n\n  always_latch\n  begin\n     if (clk_i == 1'b0)\n       clk_en <= en_i | test_en_i;\n  end\n\n  assign clk_o = clk_i & clk_en;\n`endif\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule cluster_clock_inverter\n(\n    input  logic clk_i,\n    output logic clk_o\n  );\n\n  assign clk_o = ~clk_i;\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule cluster_clock_mux2\n(\n    input  logic clk0_i,\n    input  logic clk1_i,\n    input  logic clk_sel_i,\n    output logic clk_o\n  );\n\n  always_comb\n  begin\n    if (clk_sel_i == 1'b0)\n      clk_o = clk0_i;\n    else\n      clk_o = clk1_i;\n  end\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`ifndef CONFIG_SV\n`define CONFIG_SV\n`define RISCV\n// always define ASIC when we do a synthesis run\n`ifndef PULP_FPGA_EMUL\n`ifdef SYNTHESIS\n`define ASIC\n`endif\n`endif\n\n// data and instruction RAM address and word width\n`define ROM_ADDR_WIDTH      12\n`define ROM_START_ADDR      32'h8000\n\n// Simulation only stuff\n`ifndef SYNTHESIS\n//`define DATA_STALL_RANDOM\n//`define INSTR_STALL_RANDOM\n`endif\n\n`endif\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\n`include \"axi_bus.sv\"\n\nmodule core2axi_wrap\n#(\n    parameter AXI_ADDR_WIDTH   = 32,\n    parameter AXI_DATA_WIDTH   = 32,\n    parameter AXI_USER_WIDTH   = 6,\n    parameter AXI_ID_WIDTH     = 6,\n    parameter REGISTERED_GRANT = \"FALSE\"\n)\n(\n    input logic                       clk_i,\n    input logic                       rst_ni,\n\n    input  logic                      data_req_i,\n    output logic                      data_gnt_o,\n    output logic                      data_rvalid_o,\n    input  logic [AXI_ADDR_WIDTH-1:0] data_addr_i,\n    input  logic                      data_we_i,\n    input  logic [3:0]                data_be_i,\n    output logic [31:0]               data_rdata_o,\n    input  logic [31:0]               data_wdata_i,\n\n    AXI_BUS.Master                    master\n);\n\n\n  //********************************************************\n  //************** AXI2APB WRAPER **************************\n  //********************************************************\n  core2axi\n  #(\n    .AXI4_ADDRESS_WIDTH ( AXI_ADDR_WIDTH   ),\n    .AXI4_RDATA_WIDTH   ( AXI_DATA_WIDTH   ),\n    .AXI4_WDATA_WIDTH   ( AXI_DATA_WIDTH   ),\n    .AXI4_ID_WIDTH      ( AXI_ID_WIDTH     ),\n    .AXI4_USER_WIDTH    ( AXI_USER_WIDTH   ),\n    .REGISTERED_GRANT   ( REGISTERED_GRANT )\n  )\n  core2axi_i\n  (\n    .clk_i         ( clk_i               ),\n    .rst_ni        ( rst_ni              ),\n\n    .data_req_i    ( data_req_i          ),\n    .data_gnt_o    ( data_gnt_o          ),\n    .data_rvalid_o ( data_rvalid_o       ),\n    .data_addr_i   ( data_addr_i         ),\n    .data_we_i     ( data_we_i           ),\n    .data_be_i     ( data_be_i           ),\n    .data_rdata_o  ( data_rdata_o        ),\n    .data_wdata_i  ( data_wdata_i        ),\n\n    .aw_id_o       ( master.aw_id        ),\n    .aw_addr_o     ( master.aw_addr      ),\n    .aw_len_o      ( master.aw_len       ),\n    .aw_size_o     ( master.aw_size      ),\n    .aw_burst_o    ( master.aw_burst     ),\n    .aw_lock_o     ( master.aw_lock      ),\n    .aw_cache_o    ( master.aw_cache     ),\n    .aw_prot_o     ( master.aw_prot      ),\n    .aw_region_o   ( master.aw_region    ),\n    .aw_user_o     ( master.aw_user      ),\n    .aw_qos_o      ( master.aw_qos       ),\n    .aw_valid_o    ( master.aw_valid     ),\n    .aw_ready_i    ( master.aw_ready     ),\n\n    .w_data_o      ( master.w_data       ),\n    .w_strb_o      ( master.w_strb       ),\n    .w_last_o      ( master.w_last       ),\n    .w_user_o      ( master.w_user       ),\n    .w_valid_o     ( master.w_valid      ),\n    .w_ready_i     ( master.w_ready      ),\n\n    .b_id_i        ( master.b_id         ),\n    .b_resp_i      ( master.b_resp       ),\n    .b_valid_i     ( master.b_valid      ),\n    .b_user_i      ( master.b_user       ),\n    .b_ready_o     ( master.b_ready      ),\n\n    .ar_id_o       ( master.ar_id        ),\n    .ar_addr_o     ( master.ar_addr      ),\n    .ar_len_o      ( master.ar_len       ),\n    .ar_size_o     ( master.ar_size      ),\n    .ar_burst_o    ( master.ar_burst     ),\n    .ar_lock_o     ( master.ar_lock      ),\n    .ar_cache_o    ( master.ar_cache     ),\n    .ar_prot_o     ( master.ar_prot      ),\n    .ar_region_o   ( master.ar_region    ),\n    .ar_user_o     ( master.ar_user      ),\n    .ar_qos_o      ( master.ar_qos       ),\n    .ar_valid_o    ( master.ar_valid     ),\n    .ar_ready_i    ( master.ar_ready     ),\n\n    .r_id_i        ( master.r_id         ),\n    .r_data_i      ( master.r_data       ),\n    .r_resp_i      ( master.r_resp       ),\n    .r_last_i      ( master.r_last       ),\n    .r_user_i      ( master.r_user       ),\n    .r_valid_i     ( master.r_valid      ),\n    .r_ready_o     ( master.r_ready      )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\n`include \"axi_bus.sv\"\n`include \"config.sv\"\n\nmodule core_region\n#(\n    parameter AXI_ADDR_WIDTH       = 32,\n    parameter AXI_DATA_WIDTH       = 64,\n    parameter AXI_ID_MASTER_WIDTH  = 10,\n    parameter AXI_ID_SLAVE_WIDTH   = 10,\n    parameter AXI_USER_WIDTH       = 0,\n    parameter DATA_RAM_SIZE        = 32768, // in bytes\n    parameter INSTR_RAM_SIZE       = 32768, // in bytes\n    parameter USE_ZERO_RISCY       = 0,\n    parameter RISCY_RV32F          = 0,\n    parameter ZERO_RV32M           = 1,\n    parameter ZERO_RV32E           = 0\n\n  )\n(\n    // Clock and Reset\n    input logic         clk,\n    input logic         rst_n,\n\n    input  logic        testmode_i,\n    input  logic        fetch_enable_i,\n    input  logic [31:0] irq_i,\n    output logic        core_busy_o,\n    input  logic        clock_gating_i,\n    input  logic [31:0] boot_addr_i,\n\n    AXI_BUS.Master      core_master,\n    AXI_BUS.Master      dbg_master,\n    AXI_BUS.Slave       data_slave,\n    AXI_BUS.Slave       instr_slave,\n    DEBUG_BUS.Slave     debug,\n\n    // JTAG signals\n    input  logic        tck_i,\n    input  logic        trstn_i,\n    input  logic        tms_i,\n    input  logic        tdi_i,\n    output logic        tdo_o\n  );\n\n  localparam INSTR_ADDR_WIDTH = $clog2(INSTR_RAM_SIZE)+1; // to make space for the boot rom\n  localparam DATA_ADDR_WIDTH  = $clog2(DATA_RAM_SIZE);\n\n  localparam AXI_B_WIDTH      = $clog2(AXI_DATA_WIDTH/8); // AXI \"Byte\" width\n\n  // signals from/to core\n  logic         core_instr_req;\n  logic         core_instr_gnt;\n  logic         core_instr_rvalid;\n  logic [31:0]  core_instr_addr;\n  logic [31:0]  core_instr_rdata;\n\n  logic         core_lsu_req;\n  logic         core_lsu_gnt;\n  logic         core_lsu_rvalid;\n  logic [31:0]  core_lsu_addr;\n  logic         core_lsu_we;\n  logic [3:0]   core_lsu_be;\n  logic [31:0]  core_lsu_rdata;\n  logic [31:0]  core_lsu_wdata;\n\n  logic         core_data_req;\n  logic         core_data_gnt;\n  logic         core_data_rvalid;\n  logic [31:0]  core_data_addr;\n  logic         core_data_we;\n  logic [3:0]   core_data_be;\n  logic [31:0]  core_data_rdata;\n  logic [31:0]  core_data_wdata;\n\n  // signals to/from AXI mem\n  logic                        is_axi_addr;\n  logic                        axi_mem_req;\n  logic [DATA_ADDR_WIDTH-1:0]  axi_mem_addr;\n  logic                        axi_mem_we;\n  logic [AXI_DATA_WIDTH/8-1:0] axi_mem_be;\n  logic [AXI_DATA_WIDTH-1:0]   axi_mem_rdata;\n  logic [AXI_DATA_WIDTH-1:0]   axi_mem_wdata;\n\n  // signals to/from AXI instr\n  logic                        axi_instr_req;\n  logic [INSTR_ADDR_WIDTH-1:0] axi_instr_addr;\n  logic                        axi_instr_we;\n  logic [AXI_DATA_WIDTH/8-1:0] axi_instr_be;\n  logic [AXI_DATA_WIDTH-1:0]   axi_instr_rdata;\n  logic [AXI_DATA_WIDTH-1:0]   axi_instr_wdata;\n\n\n  // signals to/from instr mem\n  logic                        instr_mem_en;\n  logic [INSTR_ADDR_WIDTH-1:0] instr_mem_addr;\n  logic                        instr_mem_we;\n  logic [AXI_DATA_WIDTH/8-1:0] instr_mem_be;\n  logic [AXI_DATA_WIDTH-1:0]   instr_mem_rdata;\n  logic [AXI_DATA_WIDTH-1:0]   instr_mem_wdata;\n\n  // signals to/from data mem\n  logic                        data_mem_en;\n  logic [DATA_ADDR_WIDTH-1:0]  data_mem_addr;\n  logic                        data_mem_we;\n  logic [AXI_DATA_WIDTH/8-1:0] data_mem_be;\n  logic [AXI_DATA_WIDTH-1:0]   data_mem_rdata;\n  logic [AXI_DATA_WIDTH-1:0]   data_mem_wdata;\n\n\n\n  enum logic [0:0] { AXI, RAM } lsu_resp_CS, lsu_resp_NS;\n\n  // signals to/from core2axi\n  logic         core_axi_req;\n  logic         core_axi_gnt;\n  logic         core_axi_rvalid;\n  logic [31:0]  core_axi_addr;\n  logic         core_axi_we;\n  logic [3:0]   core_axi_be;\n  logic [31:0]  core_axi_rdata;\n  logic [31:0]  core_axi_wdata;\n\n  AXI_BUS\n  #(\n    .AXI_ADDR_WIDTH   ( AXI_ADDR_WIDTH      ),\n    .AXI_DATA_WIDTH   ( AXI_DATA_WIDTH      ),\n    .AXI_ID_WIDTH     ( AXI_ID_MASTER_WIDTH ),\n    .AXI_USER_WIDTH   ( AXI_USER_WIDTH      )\n  )\n  core_master_int();\n\n  //----------------------------------------------------------------------------//\n  // Core Instantiation\n  //----------------------------------------------------------------------------//\n\n  logic [4:0] irq_id;\n  always_comb begin\n    irq_id = '0;\n    for (int i = 0; i < 32; i+=1) begin\n      if(irq_i[i]) begin\n        irq_id = i[4:0];\n      end\n    end\n  end\n\n  if(USE_ZERO_RISCY) begin: CORE\n      zeroriscy_core\n      #(\n        .N_EXT_PERF_COUNTERS (     0      ),\n        .RV32E               ( ZERO_RV32E ),\n        .RV32M               ( ZERO_RV32M )\n      )\n      RISCV_CORE\n      (\n        .clk_i           ( clk               ),\n        .rst_ni          ( rst_n             ),\n\n        .clock_en_i      ( clock_gating_i    ),\n        .test_en_i       ( testmode_i        ),\n\n        .boot_addr_i     ( boot_addr_i       ),\n        .core_id_i       ( 4'h0              ),\n        .cluster_id_i    ( 6'h0              ),\n\n        .instr_addr_o    ( core_instr_addr   ),\n        .instr_req_o     ( core_instr_req    ),\n        .instr_rdata_i   ( core_instr_rdata  ),\n        .instr_gnt_i     ( core_instr_gnt    ),\n        .instr_rvalid_i  ( core_instr_rvalid ),\n\n        .data_addr_o     ( core_lsu_addr     ),\n        .data_wdata_o    ( core_lsu_wdata    ),\n        .data_we_o       ( core_lsu_we       ),\n        .data_req_o      ( core_lsu_req      ),\n        .data_be_o       ( core_lsu_be       ),\n        .data_rdata_i    ( core_lsu_rdata    ),\n        .data_gnt_i      ( core_lsu_gnt      ),\n        .data_rvalid_i   ( core_lsu_rvalid   ),\n        .data_err_i      ( 1'b0              ),\n\n        .irq_i           ( (|irq_i)          ),\n        .irq_id_i        ( irq_id            ),\n        .irq_ack_o       (                   ),\n        .irq_id_o        (                   ),\n\n        .debug_req_i     ( debug.req         ),\n        .debug_gnt_o     ( debug.gnt         ),\n        .debug_rvalid_o  ( debug.rvalid      ),\n        .debug_addr_i    ( debug.addr        ),\n        .debug_we_i      ( debug.we          ),\n        .debug_wdata_i   ( debug.wdata       ),\n        .debug_rdata_o   ( debug.rdata       ),\n        .debug_halted_o  (                   ),\n        .debug_halt_i    ( 1'b0              ),\n        .debug_resume_i  ( 1'b0              ),\n\n        .fetch_enable_i  ( fetch_enable_i    ),\n        .core_busy_o     ( core_busy_o       ),\n        .ext_perf_counters_i (               )\n      );\n  end else begin: CORE\n\n    riscv_core\n    #(\n      .N_EXT_PERF_COUNTERS (     0       ),\n      .FPU                 ( RISCY_RV32F ),\n      .SHARED_FP           (     0       ),\n      .SHARED_FP_DIVSQRT   (     2       )\n    )\n    RISCV_CORE\n    (\n      .clk_i           ( clk               ),\n      .rst_ni          ( rst_n             ),\n\n      .clock_en_i      ( clock_gating_i    ),\n      .test_en_i       ( testmode_i        ),\n\n      .boot_addr_i     ( boot_addr_i       ),\n      .core_id_i       ( 4'h0              ),\n      .cluster_id_i    ( 6'h0              ),\n\n      .instr_addr_o    ( core_instr_addr   ),\n      .instr_req_o     ( core_instr_req    ),\n      .instr_rdata_i   ( core_instr_rdata  ),\n      .instr_gnt_i     ( core_instr_gnt    ),\n      .instr_rvalid_i  ( core_instr_rvalid ),\n\n      .data_addr_o     ( core_lsu_addr     ),\n      .data_wdata_o    ( core_lsu_wdata    ),\n      .data_we_o       ( core_lsu_we       ),\n      .data_req_o      ( core_lsu_req      ),\n      .data_be_o       ( core_lsu_be       ),\n      .data_rdata_i    ( core_lsu_rdata    ),\n      .data_gnt_i      ( core_lsu_gnt      ),\n      .data_rvalid_i   ( core_lsu_rvalid   ),\n      .data_err_i      ( 1'b0              ),\n\n      .irq_i           ( (|irq_i)          ),\n      .irq_id_i        ( irq_id            ),\n      .irq_ack_o       (                   ),\n      .irq_id_o        (                   ),\n      .irq_sec_i       ( 1'b0              ),\n      .sec_lvl_o       (                   ),\n\n      .debug_req_i     ( debug.req         ),\n      .debug_gnt_o     ( debug.gnt         ),\n      .debug_rvalid_o  ( debug.rvalid      ),\n      .debug_addr_i    ( debug.addr        ),\n      .debug_we_i      ( debug.we          ),\n      .debug_wdata_i   ( debug.wdata       ),\n      .debug_rdata_o   ( debug.rdata       ),\n      .debug_halted_o  (                   ),\n      .debug_halt_i    ( 1'b0              ),\n      .debug_resume_i  ( 1'b0              ),\n\n      .fetch_enable_i  ( fetch_enable_i    ),\n      .core_busy_o     ( core_busy_o       ),\n\n      // apu-interconnect\n      // handshake signals\n      .apu_master_req_o      (             ),\n      .apu_master_ready_o    (             ),\n      .apu_master_gnt_i      ( 1'b1        ),\n      // request channel\n      .apu_master_operands_o (             ),\n      .apu_master_op_o       (             ),\n      .apu_master_type_o     (             ),\n      .apu_master_flags_o    (             ),\n      // response channel\n      .apu_master_valid_i    ( '0          ),\n      .apu_master_result_i   ( '0          ),\n      .apu_master_flags_i    ( '0          ),\n\n      .ext_perf_counters_i (               )\n      );\n  end\n\n  core2axi_wrap\n  #(\n    .AXI_ADDR_WIDTH   ( AXI_ADDR_WIDTH      ),\n    .AXI_DATA_WIDTH   ( AXI_DATA_WIDTH      ),\n    .AXI_ID_WIDTH     ( AXI_ID_MASTER_WIDTH ),\n    .AXI_USER_WIDTH   ( AXI_USER_WIDTH      ),\n    .REGISTERED_GRANT ( \"FALSE\"             )\n  )\n  core2axi_i\n  (\n    .clk_i         ( clk             ),\n    .rst_ni        ( rst_n           ),\n\n    .data_req_i    ( core_axi_req    ),\n    .data_gnt_o    ( core_axi_gnt    ),\n    .data_rvalid_o ( core_axi_rvalid ),\n    .data_addr_i   ( core_axi_addr   ),\n    .data_we_i     ( core_axi_we     ),\n    .data_be_i     ( core_axi_be     ),\n    .data_rdata_o  ( core_axi_rdata  ),\n    .data_wdata_i  ( core_axi_wdata  ),\n\n    .master        ( core_master_int )\n  );\n\n  //----------------------------------------------------------------------------//\n  // AXI Slices\n  //----------------------------------------------------------------------------//\n\n  axi_slice_wrap\n  #(\n    .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH       ),\n    .AXI_DATA_WIDTH ( AXI_DATA_WIDTH       ),\n    .AXI_USER_WIDTH ( AXI_USER_WIDTH       ),\n    .AXI_ID_WIDTH   ( AXI_ID_MASTER_WIDTH  ),\n    .SLICE_DEPTH    ( 2                    )\n  )\n  axi_slice_core2axi\n  (\n    .clk_i      ( clk             ),\n    .rst_ni     ( rst_n           ),\n\n    .test_en_i  ( testmode_i      ),\n\n    .axi_slave  ( core_master_int ),\n    .axi_master ( core_master     )\n  );\n\n\n  //----------------------------------------------------------------------------//\n  // DEMUX\n  //----------------------------------------------------------------------------//\n  assign is_axi_addr     = (core_lsu_addr[31:20] != 12'h001);\n  assign core_data_req   = (~is_axi_addr) & core_lsu_req;\n  assign core_axi_req    =   is_axi_addr  & core_lsu_req;\n\n  assign core_data_addr  = core_lsu_addr;\n  assign core_data_we    = core_lsu_we;\n  assign core_data_be    = core_lsu_be;\n  assign core_data_wdata = core_lsu_wdata;\n\n  assign core_axi_addr   = core_lsu_addr;\n  assign core_axi_we     = core_lsu_we;\n  assign core_axi_be     = core_lsu_be;\n  assign core_axi_wdata  = core_lsu_wdata;\n\n  always_ff @(posedge clk, negedge rst_n)\n  begin\n    if (rst_n == 1'b0)\n      lsu_resp_CS <= RAM;\n    else\n      lsu_resp_CS <= lsu_resp_NS;\n  end\n\n  // figure out where the next response will be coming from\n  always_comb\n  begin\n    lsu_resp_NS = lsu_resp_CS;\n    core_lsu_gnt = 1'b0;\n\n    if (core_axi_req)\n    begin\n      core_lsu_gnt = core_axi_gnt;\n      lsu_resp_NS = AXI;\n    end\n    else if (core_data_req)\n    begin\n      core_lsu_gnt = core_data_gnt;\n      lsu_resp_NS = RAM;\n    end\n  end\n\n  // route response back to LSU\n  assign core_lsu_rdata  = (lsu_resp_CS == AXI) ? core_axi_rdata : core_data_rdata;\n  assign core_lsu_rvalid = core_axi_rvalid | core_data_rvalid;\n\n\n\n  //----------------------------------------------------------------------------//\n  // Instruction RAM\n  //----------------------------------------------------------------------------//\n\n  instr_ram_wrap\n  #(\n    .RAM_SIZE   ( INSTR_RAM_SIZE ),\n    .DATA_WIDTH ( AXI_DATA_WIDTH )\n  )\n  instr_mem\n  (\n    .clk         ( clk             ),\n    .rst_n       ( rst_n           ),\n    .en_i        ( instr_mem_en    ),\n    .addr_i      ( instr_mem_addr  ),\n    .wdata_i     ( instr_mem_wdata ),\n    .rdata_o     ( instr_mem_rdata ),\n    .we_i        ( instr_mem_we    ),\n    .be_i        ( instr_mem_be    ),\n    .bypass_en_i ( testmode_i      )\n  );\n\n  axi_mem_if_SP_wrap\n  #(\n    .AXI_ADDR_WIDTH  ( AXI_ADDR_WIDTH         ),\n    .AXI_DATA_WIDTH  ( AXI_DATA_WIDTH         ),\n    .AXI_ID_WIDTH    ( AXI_ID_SLAVE_WIDTH     ),\n    .AXI_USER_WIDTH  ( AXI_USER_WIDTH         ),\n    .MEM_ADDR_WIDTH  ( INSTR_ADDR_WIDTH       )\n  )\n  instr_mem_axi_if\n  (\n    .clk         ( clk               ),\n    .rst_n       ( rst_n             ),\n    .test_en_i   ( testmode_i        ),\n\n    .mem_req_o   ( axi_instr_req     ),\n    .mem_addr_o  ( axi_instr_addr    ),\n    .mem_we_o    ( axi_instr_we      ),\n    .mem_be_o    ( axi_instr_be      ),\n    .mem_rdata_i ( axi_instr_rdata   ),\n    .mem_wdata_o ( axi_instr_wdata   ),\n\n    .slave       ( instr_slave       )\n  );\n\n\n  ram_mux\n  #(\n    .ADDR_WIDTH ( INSTR_ADDR_WIDTH ),\n    .IN0_WIDTH  ( AXI_DATA_WIDTH   ),\n    .IN1_WIDTH  ( 32               ),\n    .OUT_WIDTH  ( AXI_DATA_WIDTH   )\n  )\n  instr_ram_mux_i\n  (\n    .clk            ( clk               ),\n    .rst_n          ( rst_n             ),\n\n    .port0_req_i    ( axi_instr_req     ),\n    .port0_gnt_o    (                   ),\n    .port0_rvalid_o (                   ),\n    .port0_addr_i   ( {axi_instr_addr[INSTR_ADDR_WIDTH-AXI_B_WIDTH-1:0], {AXI_B_WIDTH{1'b0}}} ),\n    .port0_we_i     ( axi_instr_we      ),\n    .port0_be_i     ( axi_instr_be      ),\n    .port0_rdata_o  ( axi_instr_rdata   ),\n    .port0_wdata_i  ( axi_instr_wdata   ),\n\n    .port1_req_i    ( core_instr_req    ),\n    .port1_gnt_o    ( core_instr_gnt    ),\n    .port1_rvalid_o ( core_instr_rvalid ),\n    .port1_addr_i   ( core_instr_addr[INSTR_ADDR_WIDTH-1:0] ),\n    .port1_we_i     ( 1'b0              ),\n    .port1_be_i     ( '1                ),\n    .port1_rdata_o  ( core_instr_rdata  ),\n    .port1_wdata_i  ( '0                ),\n\n    .ram_en_o       ( instr_mem_en      ),\n    .ram_addr_o     ( instr_mem_addr    ),\n    .ram_we_o       ( instr_mem_we      ),\n    .ram_be_o       ( instr_mem_be      ),\n    .ram_rdata_i    ( instr_mem_rdata   ),\n    .ram_wdata_o    ( instr_mem_wdata   )\n  );\n\n\n  //----------------------------------------------------------------------------//\n  // Data RAM\n  //----------------------------------------------------------------------------//\n  sp_ram_wrap\n  #(\n    .RAM_SIZE   ( DATA_RAM_SIZE  ),\n    .DATA_WIDTH ( AXI_DATA_WIDTH )\n  )\n  data_mem\n  (\n    .clk          ( clk            ),\n    .rstn_i       ( rst_n          ),\n    .en_i         ( data_mem_en    ),\n    .addr_i       ( data_mem_addr  ),\n    .wdata_i      ( data_mem_wdata ),\n    .rdata_o      ( data_mem_rdata ),\n    .we_i         ( data_mem_we    ),\n    .be_i         ( data_mem_be    ),\n    .bypass_en_i  ( testmode_i     )\n  );\n\n  axi_mem_if_SP_wrap\n  #(\n    .AXI_ADDR_WIDTH  ( AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH  ( AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH    ( AXI_ID_SLAVE_WIDTH ),\n    .AXI_USER_WIDTH  ( AXI_USER_WIDTH     ),\n    .MEM_ADDR_WIDTH  ( DATA_ADDR_WIDTH    )\n  )\n  data_mem_axi_if\n  (\n    .clk         ( clk               ),\n    .rst_n       ( rst_n             ),\n    .test_en_i   ( testmode_i        ),\n\n    .mem_req_o   ( axi_mem_req       ),\n    .mem_addr_o  ( axi_mem_addr      ),\n    .mem_we_o    ( axi_mem_we        ),\n    .mem_be_o    ( axi_mem_be        ),\n    .mem_rdata_i ( axi_mem_rdata     ),\n    .mem_wdata_o ( axi_mem_wdata     ),\n\n    .slave       ( data_slave        )\n  );\n\n\n  ram_mux\n  #(\n    .ADDR_WIDTH ( DATA_ADDR_WIDTH ),\n    .IN0_WIDTH  ( AXI_DATA_WIDTH  ),\n    .IN1_WIDTH  ( 32              ),\n    .OUT_WIDTH  ( AXI_DATA_WIDTH  )\n  )\n  data_ram_mux_i\n  (\n    .clk            ( clk              ),\n    .rst_n          ( rst_n            ),\n\n    .port0_req_i    ( axi_mem_req      ),\n    .port0_gnt_o    (                  ),\n    .port0_rvalid_o (                  ),\n    .port0_addr_i   ( {axi_mem_addr[DATA_ADDR_WIDTH-AXI_B_WIDTH-1:0], {AXI_B_WIDTH{1'b0}}} ),\n    .port0_we_i     ( axi_mem_we       ),\n    .port0_be_i     ( axi_mem_be       ),\n    .port0_rdata_o  ( axi_mem_rdata    ),\n    .port0_wdata_i  ( axi_mem_wdata    ),\n\n    .port1_req_i    ( core_data_req    ),\n    .port1_gnt_o    ( core_data_gnt    ),\n    .port1_rvalid_o ( core_data_rvalid ),\n    .port1_addr_i   ( core_data_addr[DATA_ADDR_WIDTH-1:0] ),\n    .port1_we_i     ( core_data_we     ),\n    .port1_be_i     ( core_data_be     ),\n    .port1_rdata_o  ( core_data_rdata  ),\n    .port1_wdata_i  ( core_data_wdata  ),\n\n    .ram_en_o       ( data_mem_en      ),\n    .ram_addr_o     ( data_mem_addr    ),\n    .ram_we_o       ( data_mem_we      ),\n    .ram_be_o       ( data_mem_be      ),\n    .ram_rdata_i    ( data_mem_rdata   ),\n    .ram_wdata_o    ( data_mem_wdata   )\n  );\n\n\n  //----------------------------------------------------------------------------//\n  // Advanced Debug Unit\n  //----------------------------------------------------------------------------//\n\n  // TODO: remove the debug connections to the core\n  adv_dbg_if\n  #(\n    .NB_CORES           ( 1                   ),\n    .AXI_ADDR_WIDTH     ( AXI_ADDR_WIDTH      ),\n    .AXI_DATA_WIDTH     ( AXI_DATA_WIDTH      ),\n    .AXI_USER_WIDTH     ( AXI_USER_WIDTH      ),\n    .AXI_ID_WIDTH       ( AXI_ID_MASTER_WIDTH )\n    )\n  adv_dbg_if_i\n  (\n    .tms_pad_i   ( tms_i           ),\n    .tck_pad_i   ( tck_i           ),\n    .trstn_pad_i ( trstn_i         ),\n    .tdi_pad_i   ( tdi_i           ),\n    .tdo_pad_o   ( tdo_o           ),\n\n    .test_mode_i ( testmode_i      ),\n\n    .cpu_addr_o  (                 ),\n    .cpu_data_i  ( '0              ),\n    .cpu_data_o  (                 ),\n    .cpu_bp_i    ( '0              ),\n    .cpu_stall_o (                 ),\n    .cpu_stb_o   (                 ),\n    .cpu_we_o    (                 ),\n    .cpu_ack_i   ( '1              ),\n    .cpu_rst_o   (                 ),\n\n    .axi_aclk             ( clk                  ),\n    .axi_aresetn          ( rst_n                ),\n\n    .axi_master_aw_valid  ( dbg_master.aw_valid  ),\n    .axi_master_aw_addr   ( dbg_master.aw_addr   ),\n    .axi_master_aw_prot   ( dbg_master.aw_prot   ),\n    .axi_master_aw_region ( dbg_master.aw_region ),\n    .axi_master_aw_len    ( dbg_master.aw_len    ),\n    .axi_master_aw_size   ( dbg_master.aw_size   ),\n    .axi_master_aw_burst  ( dbg_master.aw_burst  ),\n    .axi_master_aw_lock   ( dbg_master.aw_lock   ),\n    .axi_master_aw_cache  ( dbg_master.aw_cache  ),\n    .axi_master_aw_qos    ( dbg_master.aw_qos    ),\n    .axi_master_aw_id     ( dbg_master.aw_id     ),\n    .axi_master_aw_user   ( dbg_master.aw_user   ),\n    .axi_master_aw_ready  ( dbg_master.aw_ready  ),\n\n    .axi_master_ar_valid  ( dbg_master.ar_valid  ),\n    .axi_master_ar_addr   ( dbg_master.ar_addr   ),\n    .axi_master_ar_prot   ( dbg_master.ar_prot   ),\n    .axi_master_ar_region ( dbg_master.ar_region ),\n    .axi_master_ar_len    ( dbg_master.ar_len    ),\n    .axi_master_ar_size   ( dbg_master.ar_size   ),\n    .axi_master_ar_burst  ( dbg_master.ar_burst  "}
{"text": "),\n    .axi_master_ar_lock   ( dbg_master.ar_lock   ),\n    .axi_master_ar_cache  ( dbg_master.ar_cache  ),\n    .axi_master_ar_qos    ( dbg_master.ar_qos    ),\n    .axi_master_ar_id     ( dbg_master.ar_id     ),\n    .axi_master_ar_user   ( dbg_master.ar_user   ),\n    .axi_master_ar_ready  ( dbg_master.ar_ready  ),\n\n    .axi_master_w_valid   ( dbg_master.w_valid   ),\n    .axi_master_w_data    ( dbg_master.w_data    ),\n    .axi_master_w_strb    ( dbg_master.w_strb    ),\n    .axi_master_w_user    ( dbg_master.w_user    ),\n    .axi_master_w_last    ( dbg_master.w_last    ),\n    .axi_master_w_ready   ( dbg_master.w_ready   ),\n\n    .axi_master_r_valid   ( dbg_master.r_valid   ),\n    .axi_master_r_data    ( dbg_master.r_data    ),\n    .axi_master_r_resp    ( dbg_master.r_resp    ),\n    .axi_master_r_last    ( dbg_master.r_last    ),\n    .axi_master_r_id      ( dbg_master.r_id      ),\n    .axi_master_r_user    ( dbg_master.r_user    ),\n    .axi_master_r_ready   ( dbg_master.r_ready   ),\n\n    .axi_master_b_valid   ( dbg_master.b_valid   ),\n    .axi_master_b_resp    ( dbg_master.b_resp    ),\n    .axi_master_b_id      ( dbg_master.b_id      ),\n    .axi_master_b_user    ( dbg_master.b_user    ),\n    .axi_master_b_ready   ( dbg_master.b_ready   )\n    );\n\n\n  //----------------------------------------------------------------------------//\n  // Test Code\n  //----------------------------------------------------------------------------//\n\n  // introduce random stalls for data access to stress LSU\n`ifdef DATA_STALL_RANDOM\n  random_stalls data_stalls_i\n  (\n    .clk           ( clk                     ),\n\n    .core_req_i    ( CORE.RISCV_CORE.data_req_o   ),\n    .core_addr_i   ( CORE.RISCV_CORE.data_addr_o  ),\n    .core_we_i     ( CORE.RISCV_CORE.data_we_o    ),\n    .core_be_i     ( CORE.RISCV_CORE.data_be_o    ),\n    .core_wdata_i  ( CORE.RISCV_CORE.data_wdata_o ),\n    .core_gnt_o    (                         ),\n    .core_rdata_o  (                         ),\n    .core_rvalid_o (                         ),\n\n    .data_req_o    (                         ),\n    .data_addr_o   (                         ),\n    .data_we_o     (                         ),\n    .data_be_o     (                         ),\n    .data_wdata_o  (                         ),\n    .data_gnt_i    ( core_lsu_gnt            ),\n    .data_rdata_i  ( core_lsu_rdata          ),\n    .data_rvalid_i ( core_lsu_rvalid         )\n  );\n\n  initial begin\n    force CORE.RISCV_CORE.data_gnt_i    = data_stalls_i.core_gnt_o;\n    force CORE.RISCV_CORE.data_rvalid_i = data_stalls_i.core_rvalid_o;\n    force CORE.RISCV_CORE.data_rdata_i  = data_stalls_i.core_rdata_o;\n\n    force core_lsu_req   = data_stalls_i.data_req_o;\n    force core_lsu_addr  = data_stalls_i.data_addr_o;\n    force core_lsu_we    = data_stalls_i.data_we_o;\n    force core_lsu_be    = data_stalls_i.data_be_o;\n    force core_lsu_wdata = data_stalls_i.data_wdata_o;\n  end\n`endif\n\n  // introduce random stalls for instruction access to stress instruction\n  // fetcher\n`ifdef INSTR_STALL_RANDOM\n  random_stalls instr_stalls_i\n  (\n    .clk           ( clk                     ),\n\n    .core_req_i    ( CORE.RISCV_CORE.instr_req_o  ),\n    .core_addr_i   ( CORE.RISCV_CORE.instr_addr_o ),\n    .core_we_i     (                         ),\n    .core_be_i     (                         ),\n    .core_wdata_i  (                         ),\n    .core_gnt_o    (                         ),\n    .core_rdata_o  (                         ),\n    .core_rvalid_o (                         ),\n\n    .data_req_o    (                         ),\n    .data_addr_o   (                         ),\n    .data_we_o     (                         ),\n    .data_be_o     (                         ),\n    .data_wdata_o  (                         ),\n    .data_gnt_i    ( core_instr_gnt          ),\n    .data_rdata_i  ( core_instr_rdata        ),\n    .data_rvalid_i ( core_instr_rvalid       )\n  );\n\n  initial begin\n    force CORE.RISCV_CORE.instr_gnt_i    = instr_stalls_i.core_gnt_o;\n    force CORE.RISCV_CORE.instr_rvalid_i = instr_stalls_i.core_rvalid_o;\n    force CORE.RISCV_CORE.instr_rdata_i  = instr_stalls_i.core_rdata_o;\n\n    force core_instr_req   = instr_stalls_i.data_req_o;\n    force core_instr_addr  = instr_stalls_i.data_addr_o;\n  end\n`endif\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`ifndef DEBUG_BUS_SV\n`define DEBUG_BUS_SV\n\n`include \"config.sv\"\n\ninterface DEBUG_BUS\n#(\n    parameter ADDR_WIDTH = 15\n);\n\n  logic                  req;\n  logic                  gnt;\n  logic                  rvalid;\n  logic [ADDR_WIDTH-1:0] addr;\n  logic                  we;\n  logic [31: 0]          wdata;\n  logic [31: 0]          rdata;\n\n\n  // Master Side\n  //***************************************\n  modport Master\n  (\n    output      req,  addr,   we, wdata,\n    input       gnt,  rvalid,     rdata\n  );\n\n  // Slave Side\n  //***************************************\n  modport Slave\n  (\n    input       req,  addr,   we, wdata,\n    output      gnt,  rvalid,     rdata\n  );\n\nendinterface\n\n`endif\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule dp_ram\n  #(\n    parameter ADDR_WIDTH = 8\n  )(\n    // Clock and Reset\n    input  logic clk,\n\n    input  logic                   en_a_i,\n    input  logic [ADDR_WIDTH-1:0]  addr_a_i,\n    input  logic [31:0]            wdata_a_i,\n    output logic [31:0]            rdata_a_o,\n    input  logic                   we_a_i,\n    input  logic [3:0]             be_a_i,\n\n    input  logic                   en_b_i,\n    input  logic [ADDR_WIDTH-1:0]  addr_b_i,\n    input  logic [31:0]            wdata_b_i,\n    output logic [31:0]            rdata_b_o,\n    input  logic                   we_b_i,\n    input  logic [3:0]             be_b_i\n  );\n\n  localparam words = 2**ADDR_WIDTH;\n\n  logic [3:0][7:0] mem[words];\n\n  always @(posedge clk)\n  begin\n    if (en_a_i && we_a_i)\n    begin\n      if (be_a_i[0])\n        mem[addr_a_i][0] <= wdata_a_i[7:0];\n      if (be_a_i[1])\n        mem[addr_a_i][1] <= wdata_a_i[15:8];\n      if (be_a_i[2])\n        mem[addr_a_i][2] <= wdata_a_i[23:16];\n      if (be_a_i[3])\n        mem[addr_a_i][3] <= wdata_a_i[31:24];\n    end\n\n    rdata_a_o <= mem[addr_a_i];\n\n    if (en_b_i && we_b_i)\n    begin\n      if (be_b_i[0])\n        mem[addr_b_i][0] <= wdata_b_i[7:0];\n      if (be_b_i[1])\n        mem[addr_b_i][1] <= wdata_b_i[15:8];\n      if (be_b_i[2])\n        mem[addr_b_i][2] <= wdata_b_i[23:16];\n      if (be_b_i[3])\n        mem[addr_b_i][3] <= wdata_b_i[31:24];\n    end\n\n    rdata_b_o <= mem[addr_b_i];\n  end\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\n`include \"config.sv\"\n\nmodule dp_ram_wrap\n  #(\n    parameter ADDR_WIDTH = 8\n  )(\n    // Clock and Reset\n    input  logic clk,\n\n    input  logic                   en_a_i,\n    input  logic [ADDR_WIDTH-1:0]  addr_a_i,\n    input  logic [31:0]            wdata_a_i,\n    output logic [31:0]            rdata_a_o,\n    input  logic                   we_a_i,\n    input  logic [3:0]             be_a_i,\n\n    input  logic                   en_b_i,\n    input  logic [ADDR_WIDTH-1:0]  addr_b_i,\n    input  logic [31:0]            wdata_b_i,\n    output logic [31:0]            rdata_b_o,\n    input  logic                   we_b_i,\n    input  logic [3:0]             be_b_i\n  );\n\n`ifdef PULP_FPGA_EMUL\n  xilinx_mem_32768x32_dp\n  dp_ram_i\n  (\n    .clka   ( clk                  ),\n    .rsta   ( 1'b1                 ),\n\n    .clkb   ( clk                  ),\n    .rstb   ( 1'b1                 ),\n\n    .ena    ( en_a_i               ),\n    .addra  ( addr_a_i             ),\n    .dina   ( wdata_a_i            ),\n    .douta  ( rdata_a_o            ),\n    .wea    ( be_a_i & {4{we_a_i}} ),\n\n    .enb    ( en_b_i               ),\n    .addrb  ( addr_b_i             ),\n    .dinb   ( wdata_b_i            ),\n    .doutb  ( rdata_b_o            ),\n    .web    ( be_b_i & {4{we_b_i}} )\n    );\n`else\n  dp_ram\n  #(\n    .ADDR_WIDTH ( ADDR_WIDTH )\n    )\n  dp_ram_i\n  (\n    .clk       ( clk       ),\n\n    .en_a_i    ( en_a_i    ),\n    .addr_a_i  ( addr_a_i  ),\n    .wdata_a_i ( wdata_a_i ),\n    .rdata_a_o ( rdata_a_o ),\n    .we_a_i    ( we_a_i    ),\n    .be_a_i    ( be_a_i    ),\n\n    .en_b_i    ( en_b_i    ),\n    .addr_b_i  ( addr_b_i  ),\n    .wdata_b_i ( wdata_b_i ),\n    .rdata_b_o ( rdata_b_o ),\n    .we_b_i    ( we_b_i    ),\n    .be_b_i    ( be_b_i    )\n    );\n`endif\n\nendmodule\n\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule generic_fifo\n#(\n   parameter                       DATA_WIDTH = 32,\n   parameter                       DATA_DEPTH = 8\n)\n(\n   input  logic                                    clk,\n   input  logic                                    rst_n,\n   //PUSH SIDE\n   input  logic [DATA_WIDTH-1:0]                   data_i,\n   input  logic                                    valid_i,\n   output logic                                    grant_o,\n   //POP SIDE\n   output logic [DATA_WIDTH-1:0]                   data_o,\n   output logic                                    valid_o,\n   input  logic                                    grant_i,\n\n   input  logic                                    test_mode_i\n);\n\n\n   // Local Parameter\n   localparam  ADDR_DEPTH = $clog2(DATA_DEPTH);\n   enum logic [1:0] { EMPTY, FULL, MIDDLE } CS, NS;\n   // Internal Signals\n\n   logic       gate_clock;\n   logic       clk_gated;\n\n   logic [ADDR_DEPTH-1:0]          Pop_Pointer_CS,  Pop_Pointer_NS;\n   logic [ADDR_DEPTH-1:0]          Push_Pointer_CS, Push_Pointer_NS;\n   logic [DATA_WIDTH-1:0]          FIFO_REGISTERS[DATA_DEPTH-1:0];\n   integer                         i;\n\n\n\n   // Parameter Check\n   // synopsys translate_off\n   initial\n   begin : parameter_check\n      integer param_err_flg;\n      param_err_flg = 0;\n\n      if (DATA_WIDTH < 1)\n      begin\n         param_err_flg = 1;\n         $display(\"ERROR: %m :\\n  Invalid value (%d) for parameter DATA_WIDTH (legal range: greater than 1)\", DATA_WIDTH );\n      end\n\n      if (DATA_DEPTH < 1)\n      begin\n         param_err_flg = 1;\n         $display(\"ERROR: %m :\\n  Invalid value (%d) for parameter DATA_DEPTH (legal range: greater than 1)\", DATA_DEPTH );\n      end\n   end\n   // synopsys translate_on\n\n`ifndef PULP_FPGA_EMUL\n   cluster_clock_gating cg_cell\n   (\n     .clk_i     ( clk         ),\n     .en_i      (~gate_clock  ),\n     .test_en_i ( test_mode_i ),\n     .clk_o     ( clk_gated   )\n   );\n`else\n   assign clk_gated = clk;\n`endif\n\n   // UPDATE THE STATE\n   always_ff @(posedge clk, negedge rst_n)\n   begin\n       if(rst_n == 1'b0)\n       begin\n               CS              <= EMPTY;\n               Pop_Pointer_CS  <= {ADDR_DEPTH {1'b0}};\n               Push_Pointer_CS <= {ADDR_DEPTH {1'b0}};\n       end\n       else\n       begin\n               CS              <= NS;\n               Pop_Pointer_CS  <= Pop_Pointer_NS;\n               Push_Pointer_CS <= Push_Pointer_NS;\n       end\n   end\n\n\n   // Compute Next State\n   always_comb\n   begin\n      gate_clock      = 1'b0;\n\n      case(CS)\n\n      EMPTY:\n      begin\n          grant_o = 1'b1;\n          valid_o = 1'b0;\n\n          case(valid_i)\n          1'b0 :\n          begin\n                  NS                      = EMPTY;\n                  Push_Pointer_NS = Push_Pointer_CS;\n                  Pop_Pointer_NS  = Pop_Pointer_CS;\n                  gate_clock      = 1'b1;\n          end\n\n          1'b1:\n          begin\n                  NS                      = MIDDLE;\n                  Push_Pointer_NS = Push_Pointer_CS + 1'b1;\n                  Pop_Pointer_NS  = Pop_Pointer_CS;\n          end\n\n          endcase\n      end//~EMPTY\n\n      MIDDLE:\n      begin\n          grant_o = 1'b1;\n          valid_o = 1'b1;\n\n          case({valid_i,grant_i})\n\n          2'b01:\n          begin\n                  gate_clock      = 1'b1;\n\n                  if((Pop_Pointer_CS == Push_Pointer_CS -1 ) || ((Pop_Pointer_CS == DATA_DEPTH-1) && (Push_Pointer_CS == 0) ))\n                          NS              = EMPTY;\n                  else\n                          NS              = MIDDLE;\n\n                  Push_Pointer_NS = Push_Pointer_CS;\n\n                  if(Pop_Pointer_CS == DATA_DEPTH-1)\n                          Pop_Pointer_NS  = 0;\n                  else\n                          Pop_Pointer_NS  = Pop_Pointer_CS + 1'b1;\n          end\n\n          2'b00 :\n          begin\n                  gate_clock      = 1'b1;\n                  NS                      = MIDDLE;\n                  Push_Pointer_NS = Push_Pointer_CS;\n                  Pop_Pointer_NS  = Pop_Pointer_CS;\n          end\n\n          2'b11:\n          begin\n                  NS              = MIDDLE;\n\n                  if(Push_Pointer_CS == DATA_DEPTH-1)\n                          Push_Pointer_NS = 0;\n                  else\n                          Push_Pointer_NS = Push_Pointer_CS + 1'b1;\n\n                  if(Pop_Pointer_CS == DATA_DEPTH-1)\n                          Pop_Pointer_NS  = 0;\n                  else\n                          Pop_Pointer_NS  = Pop_Pointer_CS  + 1'b1;\n          end\n\n          2'b10:\n          begin\n                  if(( Push_Pointer_CS == Pop_Pointer_CS - 1) || ( (Push_Pointer_CS == DATA_DEPTH-1) && (Pop_Pointer_CS == 0) ))\n                          NS              = FULL;\n                  else\n                          NS        = MIDDLE;\n\n                  if(Push_Pointer_CS == DATA_DEPTH - 1)\n                          Push_Pointer_NS = 0;\n                  else\n                          Push_Pointer_NS = Push_Pointer_CS + 1'b1;\n\n                  Pop_Pointer_NS  = Pop_Pointer_CS;\n          end\n\n          endcase\n      end\n\n      FULL:\n      begin\n          grant_o = 1'b0;\n          valid_o = 1'b1;\n          gate_clock      = 1'b1;\n\n          case(grant_i)\n          1'b1:\n          begin\n                  NS              = MIDDLE;\n\n                  Push_Pointer_NS = Push_Pointer_CS;\n\n                  if(Pop_Pointer_CS == DATA_DEPTH-1)\n                          Pop_Pointer_NS  = 0;\n                  else\n                          Pop_Pointer_NS  = Pop_Pointer_CS  + 1'b1;\n          end\n\n          1'b0:\n          begin\n                  NS              = FULL;\n                  Push_Pointer_NS = Push_Pointer_CS;\n                  Pop_Pointer_NS  = Pop_Pointer_CS;\n          end\n          endcase\n\n      end // end of FULL\n\n      default :\n      begin\n          gate_clock      = 1'b1;\n          grant_o       = 1'b0;\n          valid_o       = 1'b0;\n          NS              = EMPTY;\n          Pop_Pointer_NS  = 0;\n          Push_Pointer_NS = 0;\n      end\n\n      endcase\n   end\n\n   always_ff @(posedge clk_gated, negedge rst_n)\n   begin\n      if(rst_n == 1'b0)\n      begin\n      for (i=0; i< DATA_DEPTH; i++)\n         FIFO_REGISTERS[i] <= {DATA_WIDTH {1'b0}};\n      end\n      else\n      begin\n         if((grant_o == 1'b1) && (valid_i == 1'b1))\n            FIFO_REGISTERS[Push_Pointer_CS] <= data_i;\n      end\n   end\n\n   assign data_o = FIFO_REGISTERS[Pop_Pointer_CS];\n\nendmodule // generic_fifo\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n\n`include \"config.sv\"\n\nmodule instr_ram_wrap\n  #(\n    parameter RAM_SIZE   = 32768,                // in bytes\n    parameter ADDR_WIDTH = $clog2(RAM_SIZE) + 1, // one bit more than necessary, for the boot rom\n    parameter DATA_WIDTH = 32\n  )(\n    // Clock and Reset\n    input  logic                    clk,\n    input  logic                    rst_n,\n\n    input  logic                    en_i,\n    input  logic [ADDR_WIDTH-1:0]   addr_i,\n    input  logic [DATA_WIDTH-1:0]   wdata_i,\n    output logic [DATA_WIDTH-1:0]   rdata_o,\n    input  logic                    we_i,\n    input  logic [DATA_WIDTH/8-1:0] be_i,\n    input  logic                    bypass_en_i\n  );\n\n  logic is_boot, is_boot_q;\n  logic [DATA_WIDTH-1:0] rdata_boot;\n  logic [DATA_WIDTH-1:0] rdata_ram;\n\n\n  assign is_boot = (addr_i[ADDR_WIDTH-1] == 1'b1);\n\n\n  sp_ram_wrap\n  #(\n    .RAM_SIZE   ( RAM_SIZE   ),\n    .DATA_WIDTH ( DATA_WIDTH )\n  )\n  sp_ram_wrap_i\n  (\n    .clk         ( clk                        ),\n    .rstn_i      ( rst_n                      ),\n\n    .en_i        ( en_i & (~is_boot)          ),\n    .addr_i      ( addr_i[ADDR_WIDTH-2:0]     ),\n    .wdata_i     ( wdata_i                    ),\n    .rdata_o     ( rdata_ram                  ),\n    .we_i        ( we_i                       ),\n    .be_i        ( be_i                       ),\n    .bypass_en_i ( bypass_en_i                )\n  );\n\n  boot_rom_wrap\n  #(\n    .DATA_WIDTH ( DATA_WIDTH )\n  )\n  boot_rom_wrap_i\n  (\n    .clk     ( clk                         ),\n    .rst_n   ( rst_n                       ),\n    .en_i    ( en_i & is_boot              ),\n    .addr_i  ( addr_i[`ROM_ADDR_WIDTH-1:0] ),\n    .rdata_o ( rdata_boot                  )\n  );\n\n\n  assign rdata_o = (is_boot_q == 1'b1) ? rdata_boot : rdata_ram;\n\n\n  // Delay the boot signal for one clock cycle to correctly select the rdata\n  // from boot rom vs normal ram\n  always_ff @(posedge clk, negedge rst_n)\n  begin\n    if (rst_n == 1'b0)\n      is_boot_q <= 1'b0;\n    else\n      is_boot_q <= is_boot;\n  end\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"axi_bus.sv\"\n`include \"apb_bus.sv\"\n`include \"debug_bus.sv\"\n`include \"config.sv\"\n\nmodule peripherals\n  #(\n    parameter AXI_ADDR_WIDTH       = 32,\n    parameter AXI_DATA_WIDTH       = 64,\n    parameter AXI_USER_WIDTH       = 6,\n    parameter AXI_SLAVE_ID_WIDTH   = 6,\n    parameter AXI_MASTER_ID_WIDTH  = 6,\n    parameter ROM_START_ADDR       = 32'h8000\n  )\n  (\n    // Clock and Reset\n    input logic clk_i,\n    input logic rst_n,\n\n    AXI_BUS.Master axi_spi_master,\n\n    DEBUG_BUS.Master debug,\n\n    input  logic             spi_clk_i,\n    input  logic             testmode_i,\n    input  logic             spi_cs_i,\n    output logic [1:0]       spi_mode_o,\n    output logic             spi_sdo0_o,\n    output logic             spi_sdo1_o,\n    output logic             spi_sdo2_o,\n    output logic             spi_sdo3_o,\n    input  logic             spi_sdi0_i,\n    input  logic             spi_sdi1_i,\n    input  logic             spi_sdi2_i,\n    input  logic             spi_sdi3_i,\n\n    AXI_BUS.Slave  slave,\n\n    output logic              uart_tx,\n    input  logic              uart_rx,\n    output logic              uart_rts,\n    output logic              uart_dtr,\n    input  logic              uart_cts,\n    input  logic              uart_dsr,\n\n    output logic              spi_master_clk,\n    output logic              spi_master_csn0,\n    output logic              spi_master_csn1,\n    output logic              spi_master_csn2,\n    output logic              spi_master_csn3,\n    output logic       [1:0]  spi_master_mode,\n    output logic              spi_master_sdo0,\n    output logic              spi_master_sdo1,\n    output logic              spi_master_sdo2,\n    output logic              spi_master_sdo3,\n    input  logic              spi_master_sdi0,\n    input  logic              spi_master_sdi1,\n    input  logic              spi_master_sdi2,\n    input  logic              spi_master_sdi3,\n\n    input  logic              scl_pad_i,\n    output logic              scl_pad_o,\n    output logic              scl_padoen_o,\n    input  logic              sda_pad_i,\n    output logic              sda_pad_o,\n    output logic              sda_padoen_o,\n\n    input  logic       [31:0] gpio_in,\n    output logic       [31:0] gpio_out,\n    output logic       [31:0] gpio_dir,\n    output logic [31:0] [5:0] gpio_padcfg,\n\n    input  logic              core_busy_i,\n    output logic [31:0]       irq_o,\n    input  logic              fetch_enable_i,\n    output logic              fetch_enable_o,\n    output logic              clk_gate_core_o,\n\n    output logic              fll1_req_o,\n    output logic              fll1_wrn_o,\n    output logic [1:0]        fll1_add_o,\n    output logic [31:0]       fll1_wdata_o,\n    input  logic              fll1_ack_i,\n    input  logic [31:0]       fll1_rdata_i,\n    input  logic              fll1_lock_i,\n\n    output logic [31:0] [5:0] pad_cfg_o,\n    output logic       [31:0] pad_mux_o,\n    output logic       [31:0] boot_addr_o\n  );\n\n  localparam APB_ADDR_WIDTH  = 32;\n  localparam APB_NUM_SLAVES  = 8;\n\n  APB_BUS s_apb_bus();\n\n  APB_BUS s_uart_bus();\n  APB_BUS s_gpio_bus();\n  APB_BUS s_spi_bus();\n  APB_BUS s_timer_bus();\n  APB_BUS s_event_unit_bus();\n  APB_BUS s_i2c_bus();\n  APB_BUS s_fll_bus();\n  APB_BUS s_soc_ctrl_bus();\n  APB_BUS s_debug_bus();\n\n  logic [1:0]   s_spim_event;\n  logic [3:0]   timer_irq;\n  logic [31:0]  peripheral_clock_gate_ctrl;\n  logic [31:0]  clk_int;\n  logic         s_uart_event;\n  logic         i2c_event;\n  logic         s_gpio_event;\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// Peripheral Clock Gating                                    ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n  generate\n     genvar i;\n       for (i = 0; i < APB_NUM_SLAVES; i = i + 1) begin\n        cluster_clock_gating core_clock_gate\n        (\n          .clk_o     ( clk_int[i]                    ),\n          .en_i      ( peripheral_clock_gate_ctrl[i] ),\n          .test_en_i ( testmode_i                    ),\n          .clk_i     ( clk_i                         )\n        );\n      end\n   endgenerate\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// SPI Slave, AXI Master                                      ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n  axi_spi_slave_wrap\n  #(\n    .AXI_ADDRESS_WIDTH  ( AXI_ADDR_WIDTH       ),\n    .AXI_DATA_WIDTH     ( AXI_DATA_WIDTH       ),\n    .AXI_USER_WIDTH     ( AXI_USER_WIDTH       ),\n    .AXI_ID_WIDTH       ( AXI_MASTER_ID_WIDTH  )\n  )\n  axi_spi_slave_i\n  (\n    .clk_i      ( clk_int[0]     ),\n    .rst_ni     ( rst_n          ),\n\n    .test_mode  ( testmode_i     ),\n\n    .axi_master ( axi_spi_master ),\n\n    .spi_clk    ( spi_clk_i      ),\n    .spi_cs     ( spi_cs_i       ),\n    .spi_mode   ( spi_mode_o     ),\n    .spi_sdo0   ( spi_sdo0_o     ),\n    .spi_sdo1   ( spi_sdo1_o     ),\n    .spi_sdo2   ( spi_sdo2_o     ),\n    .spi_sdo3   ( spi_sdo3_o     ),\n    .spi_sdi0   ( spi_sdi0_i     ),\n    .spi_sdi1   ( spi_sdi1_i     ),\n    .spi_sdi2   ( spi_sdi2_i     ),\n    .spi_sdi3   ( spi_sdi3_i     )\n  );\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// AXI2APB Bridge                                             ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n  axi2apb_wrap\n  #(\n      .AXI_ADDR_WIDTH ( AXI_ADDR_WIDTH     ),\n      .AXI_DATA_WIDTH ( AXI_DATA_WIDTH     ),\n      .AXI_USER_WIDTH ( AXI_USER_WIDTH     ),\n      .AXI_ID_WIDTH   ( AXI_SLAVE_ID_WIDTH ),\n      .APB_ADDR_WIDTH ( APB_ADDR_WIDTH     )\n  )\n  axi2apb_i\n  (\n    .clk_i     ( clk_i      ),\n    .rst_ni    ( rst_n      ),\n    .test_en_i ( testmode_i ),\n\n    .axi_slave ( slave      ),\n\n    .apb_master( s_apb_bus  )\n  );\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// APB Bus                                                    ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n  periph_bus_wrap\n  #(\n     .APB_ADDR_WIDTH( APB_ADDR_WIDTH ),\n     .APB_DATA_WIDTH( 32             )\n  )\n  periph_bus_i\n  (\n     .clk_i             ( clk_i            ),\n     .rst_ni            ( rst_n            ),\n\n     .apb_slave         ( s_apb_bus        ),\n\n     .uart_master       ( s_uart_bus       ),\n     .gpio_master       ( s_gpio_bus       ),\n     .spi_master        ( s_spi_bus        ),\n     .timer_master      ( s_timer_bus      ),\n     .event_unit_master ( s_event_unit_bus ),\n     .i2c_master        ( s_i2c_bus        ),\n     .fll_master        ( s_fll_bus        ),\n     .soc_ctrl_master   ( s_soc_ctrl_bus   ),\n     .debug_master      ( s_debug_bus      )\n  );\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// APB Slave 0: APB UART interface                            ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n  `ifndef VERILATOR\n  apb_uart apb_uart_i (\n    .CLK      ( clk_int[1]   ),\n    .RSTN     ( rst_n        ),\n\n    .PSEL     ( s_uart_bus.psel    ),\n    .PENABLE  ( s_uart_bus.penable    ),\n    .PWRITE   ( s_uart_bus.pwrite     ),\n    .PADDR    ( s_uart_bus.paddr[4:2] ),\n    .PWDATA   ( s_uart_bus.pwdata     ),\n    .PRDATA   ( s_uart_bus.prdata  ),\n    .PREADY   ( s_uart_bus.pready  ),\n    .PSLVERR  ( s_uart_bus.pslverr ),\n\n    .INT      ( s_uart_event ),   //Interrupt output\n\n    .OUT1N    (),                    //Output 1\n    .OUT2N    (),                    //Output 2\n    .RTSN     ( uart_rts    ),       //RTS output\n    .DTRN     ( uart_dtr    ),       //DTR output\n    .CTSN     ( uart_cts    ),       //CTS input\n    .DSRN     ( uart_dsr    ),       //DSR input\n    .DCDN     ( 1'b1        ),       //DCD input\n    .RIN      ( 1'b1        ),       //RI input\n    .SIN      ( uart_rx     ),\n    .SOUT     ( uart_tx     )\n  );\n  `else\n  apb_uart_sv\n    #(\n       .APB_ADDR_WIDTH( 3 )\n    )\n    apb_uart_i\n    (\n      .CLK      ( clk_int[1]            ),\n      .RSTN     ( rst_n                 ),\n\n      .PSEL     ( s_uart_bus.psel       ),\n      .PENABLE  ( s_uart_bus.penable    ),\n      .PWRITE   ( s_uart_bus.pwrite     ),\n      .PADDR    ( s_uart_bus.paddr[4:2] ),\n      .PWDATA   ( s_uart_bus.pwdata     ),\n      .PRDATA   ( s_uart_bus.prdata     ),\n      .PREADY   ( s_uart_bus.pready     ),\n      .PSLVERR  ( s_uart_bus.pslverr    ),\n\n      .rx_i     ( uart_rx               ),\n      .tx_o     ( uart_tx               ),\n      .event_o  ( s_uart_event          )\n    );\n  `endif\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// APB Slave 1: APB GPIO interface                            ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n  apb_gpio apb_gpio_i\n  (\n    .HCLK       ( clk_int[2]   ),\n    .HRESETn    ( rst_n        ),\n\n    .PADDR      ( s_gpio_bus.paddr[11:0]),\n    .PWDATA     ( s_gpio_bus.pwdata     ),\n    .PWRITE     ( s_gpio_bus.pwrite     ),\n    .PSEL       ( s_gpio_bus.psel       ),\n    .PENABLE    ( s_gpio_bus.penable    ),\n    .PRDATA     ( s_gpio_bus.prdata     ),\n    .PREADY     ( s_gpio_bus.pready     ),\n    .PSLVERR    ( s_gpio_bus.pslverr    ),\n\n    .gpio_in      ( gpio_in       ),\n    .gpio_out     ( gpio_out      ),\n    .gpio_dir     ( gpio_dir      ),\n    .gpio_padcfg  ( gpio_padcfg   ),\n    .interrupt    ( s_gpio_event  )\n  );\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// APB Slave 2: APB SPI Master interface                      ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n  apb_spi_master\n  #(\n      .BUFFER_DEPTH(8)\n  )\n  apb_spi_master_i\n  (\n    .HCLK         ( clk_int[3]   ),\n    .HRESETn      ( rst_n        ),\n\n    .PADDR        ( s_spi_bus.paddr[11:0]),\n    .PWDATA       ( s_spi_bus.pwdata     ),\n    .PWRITE       ( s_spi_bus.pwrite     ),\n    .PSEL         ( s_spi_bus.psel       ),\n    .PENABLE      ( s_spi_bus.penable    ),\n    .PRDATA       ( s_spi_bus.prdata     ),\n    .PREADY       ( s_spi_bus.pready     ),\n    .PSLVERR      ( s_spi_bus.pslverr    ),\n\n    .events_o     ( s_spim_event ),\n\n    .spi_clk      ( spi_master_clk  ),\n    .spi_csn0     ( spi_master_csn0 ),\n    .spi_csn1     ( spi_master_csn1 ),\n    .spi_csn2     ( spi_master_csn2 ),\n    .spi_csn3     ( spi_master_csn3 ),\n    .spi_mode     ( spi_master_mode ),\n    .spi_sdo0     ( spi_master_sdo0 ),\n    .spi_sdo1     ( spi_master_sdo1 ),\n    .spi_sdo2     ( spi_master_sdo2 ),\n    .spi_sdo3     ( spi_master_sdo3 ),\n    .spi_sdi0     ( spi_master_sdi0 ),\n    .spi_sdi1     ( spi_master_sdi1 ),\n    .spi_sdi2     ( spi_master_sdi2 ),\n    .spi_sdi3     ( spi_master_sdi3 )\n  );\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// APB Slave 3: Timer Unit                                    ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n  apb_timer\n  apb_timer_i\n  (\n    .HCLK       ( clk_int[4]   ),\n    .HRESETn    ( rst_n        ),\n\n    .PADDR      ( s_timer_bus.paddr[11:0]),\n    .PWDATA     ( s_timer_bus.pwdata     ),\n    .PWRITE     ( s_timer_bus.pwrite     ),\n    .PSEL       ( s_timer_bus.psel       ),\n    .PENABLE    ( s_timer_bus.penable    ),\n    .PRDATA     ( s_timer_bus.prdata     ),\n    .PREADY     ( s_timer_bus.pready     ),\n    .PSLVERR    ( s_timer_bus.pslverr    ),\n\n    .irq_o      ( timer_irq    )\n  );\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// APB Slave 4: Event Unit                                    ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n  apb_event_unit\n  apb_event_unit_i\n  (\n    .clk_i            ( clk_i        ),\n    .HCLK             ( clk_int[5]   ),\n    .HRESETn          ( rst_n        ),\n\n    .PADDR            ( s_event_unit_bus.paddr[11:0]),\n    .PWDATA           ( s_event_unit_bus.pwdata     ),\n    .PWRITE           ( s_event_unit_bus.pwrite     ),\n    .PSEL             ( s_event_unit_bus.psel       ),\n    .PENABLE          ( s_event_unit_bus.penable    ),\n    .PRDATA           ( s_event_unit_bus.prdata     ),\n    .PREADY           ( s_event_unit_bus.pready     ),\n    .PSLVERR          ( s_event_unit_bus.pslverr    ),\n\n    .irq_i            ( {timer_irq, s_spim_event, s_gpio_event, s_uart_event, i2c_event, 23'b0} ),\n    .event_i          ( {timer_irq, s_spim_event, s_gpio_event, s_uart_event, i2c_event, 23'b0} ),\n    .irq_o            ( irq_o              ),\n\n    .fetch_enable_i   ( fetch_enable_i     ),\n    .fetch_enable_o   ( fetch_enable_o     ),\n    .clk_gate_core_o  ( clk_gate_core_o    ),\n    .core_busy_i      ( core_busy_i        )\n  );\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// APB Slave 5: I2C                                           ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n  apb_i2c\n  apb_i2c_i\n  (\n    .HCLK         ( clk_int[6]    ),\n    .HRESETn      ( rst_n         ),\n\n    .PADDR        ( s_i2c_bus.paddr[11:0] ),\n    .PWDATA       ( s_i2c_bus.pwdata      ),\n    .PWRITE       ( s_i2c_bus.pwrite      ),\n    .PSEL         ( s_i2c_bus.psel        ),\n    .PENABLE      ( s_i2c_bus.penable     ),\n    .PRDATA       ( s_i2c_bus.prdata      ),\n    .PREADY       ( s_i2c_bus.pready      ),\n    .PSLVERR      ( s_i2c_bus.pslverr     ),\n    .interrupt_o  ( i2c_event     ),\n    .scl_pad_i    ( scl_pad_i     ),\n    .scl_pad_o    ( scl_pad_o     ),\n    .scl_padoen_o ( scl_padoen_o  ),\n    .sda_pad_i    ( sda_pad_i     ),\n    .sda_pad_o    ( sda_pad_o     ),\n    .sda_padoen_o ( sda_padoen_o  )\n  );\n\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// APB Slave 6: FLL Ctrl                                      ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n    apb_fll_if apb_fll_if_i\n    (\n      .HCLK        ( clk_int[7]   ),\n      .HRESETn     ( rst_n        ),\n\n      .PADDR       ( s_fll_bus.paddr[11:0]),\n      .PWDATA      ( s_fll_bus.pwdata     ),\n      .PWRITE      ( s_fll_bus.pwrite     ),\n      .PSEL        ( s_fll_bus.psel       ),\n      .PENABLE     ( s_fll_bus.penable    ),\n      .PRDATA      ( s_fll_bus.prdata     ),\n      .PREADY      ( s_fll_bus.pready     ),\n      .PSLVERR     ( s_fll_bus.pslverr    ),\n\n      .fll1_req    ( fll1_req_o   ),\n      .fll1_wrn    ( fll1_wrn_o   ),\n      .fll1_add    ( fll1_add_o   ),\n      .fll1_data   ( fll1_wdata_o ),\n      .fll1_ack    ( fll1_ack_i   ),\n      .fll1_r_data ( fll1_rdata_i ),\n      .fll1_lock   ( fll1_lock_i  ),\n\n      .fll2_req    (              ),\n      .fll2_wrn    (              ),\n      .fll2_add    (              ),\n      .fll2_data   (              ),\n      .fll2_ack    ( 1'b0         ),\n      .fll2_r_data ( '0           ),\n      .fll2_lock   ( 1'b0         )\n      );\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// APB Slave 7: PULPino control                               ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n    apb_pulpino\n    #(\n      .BOOT_ADDR ( ROM_START_ADDR )\n    )\n    apb_pulpino_i\n    (\n      .HCLK        ( clk_i        ),\n      .HRESETn     ( rst_n        ),\n\n      .PADDR       ( s_soc_ctrl_bus.paddr[11:0]),\n      .PWDATA      ( s_soc_ctrl_bus.pwdata     ),\n      .PWRITE      ( s_soc_ctrl_bus.pwrite     ),\n      .PSEL        ( s_soc_ctrl_bus.psel       ),\n      .PENABLE     ( s_soc_ctrl_bus.penable    ),\n      .PRDATA      ( s_soc_ctrl_bus.prdata     ),\n      .PREADY      ( s_soc_ctrl_bus.pready     ),\n      .PSLVERR     ( s_soc_ctrl_bus.pslverr    ),\n\n      .pad_cfg_o   ( pad_cfg_o                  ),\n      .clk_gate_o  ( peripheral_clock_gate_ctrl ),\n      .pad_mux_o   ( pad_mux_o                  ),\n      .boot_addr_o ( boot_addr_o                )\n    );\n\n  //////////////////////////////////////////////////////////////////\n  ///                                                            ///\n  /// APB Slave 8: APB2PER for debug                             ///\n  ///                                                            ///\n  //////////////////////////////////////////////////////////////////\n\n  apb2per\n  #(\n    .PER_ADDR_WIDTH ( 15             ),\n    .APB_ADDR_WIDTH ( APB_ADDR_WIDTH )\n  )\n  apb2per_debug_i\n  (\n    .clk_i                ( clk_i                   ),\n    .rst_ni               ( rst_n                   ),\n\n    .PADDR                ( s_debug_bus.paddr       ),\n    .PWDATA               ( s_debug_bus.pwdata      ),\n    .PWRITE               ( s_debug_bus.pwrite      ),\n    .PSEL                 ( s_debug_bus.psel        ),\n    .PENABLE              ( s_debug_bus.penable     ),\n    .PRDATA               ( s_debug_bus.prdata      ),\n    .PREADY               ( s_debug_bus.pready      ),\n    .PSLVERR              ( s_debug_bus.pslverr     ),\n\n    .per_master_req_o     ( debug.req               ),\n    .per_master_add_o     ( debug.addr              ),\n    .per_master_we_o      ( debug.we                ),\n    .per_master_wdata_o   ( debug.wdata             ),\n    .per_master_be_o      (                         ),\n    .per_master_gnt_i     ( debug.gnt               ),\n\n    .per_master_r_valid_i ( debug.rvalid            ),\n    .per_master_r_opc_i   ( '0                      ),\n    .per_master_r_rdata_i ( debug.rdata             )\n  );\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"apb_bus.sv\"\n\nmodule periph_bus_wrap\n  #(\n    parameter APB_ADDR_WIDTH = 32,\n    parameter APB_DATA_WIDTH = 32\n    )\n   (\n    input logic       clk_i,\n    input logic       rst_ni,\n\n    APB_BUS.Slave     apb_slave,\n\n    APB_BUS.Master    uart_master,\n    APB_BUS.Master    gpio_master,\n    APB_BUS.Master    spi_master,\n    APB_BUS.Master    timer_master,\n    APB_BUS.Master    event_unit_master,\n    APB_BUS.Master    i2c_master,\n    APB_BUS.Master    fll_master,\n    APB_BUS.Master    soc_ctrl_master,\n    APB_BUS.Master    debug_master\n\n    );\n\n  localparam NB_MASTER      = `NB_MASTER;\n\n  logic [NB_MASTER-1:0][APB_ADDR_WIDTH-1:0] s_start_addr;\n  logic [NB_MASTER-1:0][APB_ADDR_WIDTH-1:0] s_end_addr;\n\n  APB_BUS\n    #(\n      .APB_ADDR_WIDTH(APB_ADDR_WIDTH),\n      .APB_DATA_WIDTH(APB_DATA_WIDTH)\n      )\n  s_masters[NB_MASTER-1:0]();\n\n  APB_BUS\n    #(\n      .APB_ADDR_WIDTH(APB_ADDR_WIDTH),\n      .APB_DATA_WIDTH(APB_DATA_WIDTH)\n      )\n  s_slave();\n\n  `APB_ASSIGN_SLAVE(s_slave, apb_slave);\n\n  `APB_ASSIGN_MASTER(s_masters[0], uart_master);\n  assign s_start_addr[0] = `UART_START_ADDR;\n  assign s_end_addr[0]   = `UART_END_ADDR;\n\n  `APB_ASSIGN_MASTER(s_masters[1], gpio_master);\n  assign s_start_addr[1] = `GPIO_START_ADDR;\n  assign s_end_addr[1]   = `GPIO_END_ADDR;\n\n  `APB_ASSIGN_MASTER(s_masters[2], spi_master);\n  assign s_start_addr[2] = `SPI_START_ADDR;\n  assign s_end_addr[2]   = `SPI_END_ADDR;\n\n  `APB_ASSIGN_MASTER(s_masters[3], timer_master);\n  assign s_start_addr[3] = `TIMER_START_ADDR;\n  assign s_end_addr[3]   = `TIMER_END_ADDR;\n\n  `APB_ASSIGN_MASTER(s_masters[4], event_unit_master);\n  assign s_start_addr[4] = `EVENT_UNIT_START_ADDR;\n  assign s_end_addr[4]   = `EVENT_UNIT_END_ADDR;\n\n  `APB_ASSIGN_MASTER(s_masters[5], i2c_master);\n  assign s_start_addr[5] = `I2C_START_ADDR;\n  assign s_end_addr[5]   = `I2C_END_ADDR;\n\n  `APB_ASSIGN_MASTER(s_masters[6], fll_master);\n  assign s_start_addr[6] = `FLL_START_ADDR;\n  assign s_end_addr[6]   = `FLL_END_ADDR;\n\n  `APB_ASSIGN_MASTER(s_masters[7], soc_ctrl_master);\n  assign s_start_addr[7] = `SOC_CTRL_START_ADDR;\n  assign s_end_addr[7]   = `SOC_CTRL_END_ADDR;\n\n  `APB_ASSIGN_MASTER(s_masters[8], debug_master);\n  assign s_start_addr[8] = `DEBUG_START_ADDR;\n  assign s_end_addr[8]   = `DEBUG_END_ADDR;\n\n  //********************************************************\n  //**************** SOC BUS *******************************\n  //********************************************************\n\n  apb_node_wrap\n  #(\n    .NB_MASTER      ( NB_MASTER      ),\n    .APB_ADDR_WIDTH ( APB_ADDR_WIDTH ),\n    .APB_DATA_WIDTH ( APB_DATA_WIDTH )\n  )\n  apb_node_wrap_i\n  (\n    .clk_i        ( clk_i        ),\n    .rst_ni       ( rst_ni       ),\n\n    .apb_slave    ( s_slave      ),\n    .apb_masters  ( s_masters    ),\n\n    .start_addr_i ( s_start_addr ),\n    .end_addr_i   ( s_end_addr   )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule pulpemu_top(\n  DDR_addr,\n  DDR_ba,\n  DDR_cas_n,\n  DDR_ck_n,\n  DDR_ck_p,\n  DDR_cke,\n  DDR_cs_n,\n  DDR_dm,\n  DDR_dq,\n  DDR_dqs_n,\n  DDR_dqs_p,\n  DDR_odt,\n  DDR_ras_n,\n  DDR_reset_n,\n  DDR_we_n,\n  FIXED_IO_ddr_vrn,\n  FIXED_IO_ddr_vrp,\n  FIXED_IO_mio,\n  FIXED_IO_ps_clk,\n  FIXED_IO_ps_porb,\n  FIXED_IO_ps_srstb,\n  LD_o,\n  sw_i,\n  btn_i,\n  oled_sclk_io,\n  oled_sdin_io,\n  oled_dc_o,\n  oled_res_o,\n  oled_vbat_o,\n  oled_vdd_o,\n  ext_tck_i,\n  ext_trstn_i,\n  ext_tdi_i,\n  ext_tms_i,\n  ext_tdo_o\n  );\n\n  inout  [14:0] DDR_addr;\n  inout  [2:0]  DDR_ba;\n  inout         DDR_cas_n;\n  inout         DDR_ck_n;\n  inout         DDR_ck_p;\n  inout         DDR_cke;\n  inout         DDR_cs_n;\n  inout  [3:0]  DDR_dm;\n  inout  [31:0] DDR_dq;\n  inout  [3:0]  DDR_dqs_n;\n  inout  [3:0]  DDR_dqs_p;\n  inout         DDR_odt;\n  inout         DDR_ras_n;\n  inout         DDR_reset_n;\n  inout         DDR_we_n;\n  inout         FIXED_IO_ddr_vrn;\n  inout         FIXED_IO_ddr_vrp;\n  inout  [53:0] FIXED_IO_mio;\n  inout         FIXED_IO_ps_clk;\n  inout         FIXED_IO_ps_porb;\n  inout         FIXED_IO_ps_srstb;\n\n  output  [7:0] LD_o;\n  input   [7:0] sw_i;\n  input   [4:0] btn_i;\n  inout         oled_sclk_io;\n  inout         oled_sdin_io;\n  output        oled_dc_o;\n  output        oled_res_o;\n  output        oled_vbat_o;\n  output        oled_vdd_o;\n\n  input         ext_tck_i;\n  input         ext_trstn_i;\n  input         ext_tdi_i;\n  input         ext_tms_i;\n  output        ext_tdo_o;\n\n\n  wire [14:0] DDR_addr;\n  wire [2:0]  DDR_ba;\n  wire        DDR_cas_n;\n  wire        DDR_ck_n;\n  wire        DDR_ck_p;\n  wire        DDR_cke;\n  wire        DDR_cs_n;\n  wire [3:0]  DDR_dm;\n  wire [31:0] DDR_dq;\n  wire [3:0]  DDR_dqs_n;\n  wire [3:0]  DDR_dqs_p;\n  wire        DDR_odt;\n  wire        DDR_ras_n;\n  wire        DDR_reset_n;\n  wire        DDR_we_n;\n  wire        FIXED_IO_ddr_vrn;\n  wire        FIXED_IO_ddr_vrp;\n  wire [53:0] FIXED_IO_mio;\n  wire        FIXED_IO_ps_clk;\n  wire        FIXED_IO_ps_porb;\n  wire        FIXED_IO_ps_srstb;\n\n  wire        ps7_clk;\n  wire        ps7_rst_n;\n  wire        ps7_rst_clking_n;\n\n  wire        ref_clk_i;               // input\n  wire        rst_ni;                  // input\n  wire        fetch_en;                // input\n\n  wire [31:0] fetch_enable;\n\n  wire [31:0] jtag_emu_i; // input to PS\n  wire [31:0] jtag_emu_o; // output from PS\n  wire        tck_i;                   // input\n  wire        trst_ni;                 // input\n  wire        tms_i;                   // input\n  wire        td_i;                    // input\n  wire        td_o;                    // output\n\n  wire        spi_mosi;\n  wire        spi_miso;\n  wire        spi_sck;\n  wire        spi_cs;\n\n  wire [31:0] gpio_dir;                // output\n  wire [31:0] gpio_in;                 // input\n  wire [31:0] gpio_in_ps7;             // output of ps7 => to pulpino\n  wire [31:0] gpio_out;                // output\n\n  wire        scl_oen;\n  wire        scl_in;\n  wire        scl_out;\n  wire        sda_oen;\n  wire        sda_in;\n  wire        sda_out;\n\n  reg   [7:0] LD_q;\n\n  wire        clking_axi_aclk;    // input\n  wire        clking_axi_aresetn; // input\n  wire [10:0] clking_axi_awaddr;  // input\n  wire  [2:0] clking_axi_awprot;  // input\n  wire        clking_axi_awvalid; // input\n  wire        clking_axi_awready; // output\n  wire [31:0] clking_axi_wdata;   // input\n  wire  [3:0] clking_axi_wstrb;   // input\n  wire        clking_axi_wvalid;  // input\n  wire        clking_axi_wready;  // output\n  wire  [1:0] clking_axi_bresp;   // output\n  wire        clking_axi_bvalid;  // output\n  wire        clking_axi_bready;  // input\n  wire [10:0] clking_axi_araddr;  // input\n  wire  [2:0] clking_axi_arprot;  // input\n  wire        clking_axi_arvalid; // input\n  wire        clking_axi_arready; // output\n  wire [31:0] clking_axi_rdata;   // output\n  wire  [1:0] clking_axi_rresp;   // output\n  wire        clking_axi_rvalid;  // output\n  wire        clking_axi_rready;  // input\n\n  wire        uart_tx;            // output\n  wire        uart_rx;            // input\n\n  // clock generator signals\n  wire s_rstn_pulpino;\n  wire s_clk_pulpino;\n\n  assign ref_clk_i          = ps7_clk;\n  assign clking_axi_aclk    = ps7_clk;\n  assign clking_axi_aresetn = ps7_rst_clking_n;\n  assign rst_ni             = fetch_enable[31];\n  assign ps7_rst_pulp_n     = ps7_rst_n;\n  assign ps7_rst_clking_n   = ps7_rst_n;\n\n  reg fetch_en_r;\n\n  assign fetch_en = fetch_en_r;\n\n  always @(posedge ps7_clk or negedge ps7_rst_n)\n  begin\n    if(ps7_rst_n == 1'b0)\n      fetch_en_r = 1'b0;\n    else\n      fetch_en_r = fetch_enable[0];\n  end\n\n  // JTAG signals\n  // for JTAG EMU\n  // assign tck_i            = jtag_emu_o[0];\n  // assign trst_ni          = jtag_emu_o[1];\n  // assign td_i             = jtag_emu_o[2];\n  // assign tms_i            = jtag_emu_o[3];\n  assign jtag_emu_i[3:0]  = 4'b0;\n  assign jtag_emu_i[4]    = td_o;\n  assign jtag_emu_i[31:5] = 27'b0;\n\n  // for external JTAG\n  assign tck_i   = ext_tck_i;\n  assign trst_ni = ext_trstn_i;\n  assign td_i    = ext_tdi_i;\n  assign tms_i   = ext_tms_i;\n\n  assign ext_tdo_o = td_o;\n\n\n  // GPIO signals\n  always @(posedge s_clk_pulpino or negedge s_rstn_pulpino)\n  begin\n    if (~s_rstn_pulpino)\n      LD_q <= 8'b0;\n    else\n      LD_q <= gpio_out[15:8];\n  end\n\n  assign LD_o = LD_q;\n\n  assign gpio_in[7:0]   = sw_i;\n  assign gpio_in[15:8]  = 8'b0;\n  assign gpio_in[20:16] = btn_i;\n  assign gpio_in[31:21] = gpio_in_ps7[31:21];\n\n\n  // I2C for LCD\n  assign oled_sclk_io = (~scl_oen) ? scl_out : 1'bz;\n  assign scl_in       = oled_sclk_io;\n  assign oled_sdin_io = (~sda_oen) ? sda_out : 1'bz;\n  assign sda_in       = oled_sdin_io;\n\n  assign oled_vbat_o  = 1'b1;\n  assign oled_vdd_o   = 1'b1;\n\n  assign oled_dc_o    = gpio_out[16];\n  assign oled_res_o   = gpio_out[17];\n\n  // Zynq Processing System\n  ps7_wrapper ps7_wrapper_i (\n    .DDR_addr           ( DDR_addr           ),\n    .DDR_ba             ( DDR_ba             ),\n    .DDR_cas_n          ( DDR_cas_n          ),\n    .DDR_ck_n           ( DDR_ck_n           ),\n    .DDR_ck_p           ( DDR_ck_p           ),\n    .DDR_cke            ( DDR_cke            ),\n    .DDR_cs_n           ( DDR_cs_n           ),\n    .DDR_dm             ( DDR_dm             ),\n    .DDR_dq             ( DDR_dq             ),\n    .DDR_dqs_n          ( DDR_dqs_n          ),\n    .DDR_dqs_p          ( DDR_dqs_p          ),\n    .DDR_odt            ( DDR_odt            ),\n    .DDR_ras_n          ( DDR_ras_n          ),\n    .DDR_reset_n        ( DDR_reset_n        ),\n    .DDR_we_n           ( DDR_we_n           ),\n\n    .FIXED_IO_ddr_vrn   ( FIXED_IO_ddr_vrn   ),\n    .FIXED_IO_ddr_vrp   ( FIXED_IO_ddr_vrp   ),\n    .FIXED_IO_mio       ( FIXED_IO_mio       ),\n    .FIXED_IO_ps_clk    ( FIXED_IO_ps_clk    ),\n    .FIXED_IO_ps_porb   ( FIXED_IO_ps_porb   ),\n    .FIXED_IO_ps_srstb  ( FIXED_IO_ps_srstb  ),\n\n    .clking_axi_awaddr  ( clking_axi_awaddr  ),\n    .clking_axi_awprot  ( clking_axi_awprot  ),\n    .clking_axi_awvalid ( clking_axi_awvalid ),\n    .clking_axi_awready ( clking_axi_awready ),\n    .clking_axi_wdata   ( clking_axi_wdata   ),\n    .clking_axi_wstrb   ( clking_axi_wstrb   ),\n    .clking_axi_wvalid  ( clking_axi_wvalid  ),\n    .clking_axi_wready  ( clking_axi_wready  ),\n    .clking_axi_bresp   ( clking_axi_bresp   ),\n    .clking_axi_bvalid  ( clking_axi_bvalid  ),\n    .clking_axi_bready  ( clking_axi_bready  ),\n    .clking_axi_araddr  ( clking_axi_araddr  ),\n    .clking_axi_arprot  ( clking_axi_arprot  ),\n    .clking_axi_arvalid ( clking_axi_arvalid ),\n    .clking_axi_arready ( clking_axi_arready ),\n    .clking_axi_rdata   ( clking_axi_rdata   ),\n    .clking_axi_rresp   ( clking_axi_rresp   ),\n    .clking_axi_rvalid  ( clking_axi_rvalid  ),\n    .clking_axi_rready  ( clking_axi_rready  ),\n\n    .fetch_enable       ( fetch_enable       ),\n    .ps7_clk            ( ps7_clk            ),\n    .ps7_rst_n          ( ps7_rst_n          ),\n\n    .UART_0_rxd         ( uart_tx            ),\n    .UART_0_txd         ( uart_rx            ),\n\n    .gpio_io_i          ( gpio_out           ),\n    .gpio_io_o          ( gpio_in_ps7        ),\n    .jtag_emu_i         ( jtag_emu_i         ),\n    .jtag_emu_o         ( jtag_emu_o         ),\n\n    .SPI0_MISO_I        ( spi_miso           ),\n    .SPI0_MOSI_O        ( spi_mosi           ),\n    .SPI0_MOSI_I        ( 1'b0               ),\n    .SPI0_SCLK_O        ( spi_sck            ),\n    .SPI0_SCLK_I        ( 1'b0               ),\n    .SPI0_SS_O          ( spi_cs             ),\n    .SPI0_SS_I          ( 1'b1               )\n  );\n\n\n  clk_rst_gen clk_rst_gen_i (\n    .ref_clk_i               ( ref_clk_i               ),\n    .rst_ni                  ( rst_ni                  ),\n\n    .clking_axi_aclk         ( clking_axi_aclk         ),\n    .clking_axi_aresetn      ( clking_axi_aresetn      ),\n    .clking_axi_awaddr       ( clking_axi_awaddr       ),\n    .clking_axi_awvalid      ( clking_axi_awvalid      ),\n    .clking_axi_awready      ( clking_axi_awready      ),\n    .clking_axi_wdata        ( clking_axi_wdata        ),\n    .clking_axi_wstrb        ( clking_axi_wstrb        ),\n    .clking_axi_wvalid       ( clking_axi_wvalid       ),\n    .clking_axi_wready       ( clking_axi_wready       ),\n    .clking_axi_bresp        ( clking_axi_bresp        ),\n    .clking_axi_bvalid       ( clking_axi_bvalid       ),\n    .clking_axi_bready       ( clking_axi_bready       ),\n    .clking_axi_araddr       ( clking_axi_araddr       ),\n    .clking_axi_arvalid      ( clking_axi_arvalid      ),\n    .clking_axi_arready      ( clking_axi_arready      ),\n    .clking_axi_rdata        ( clking_axi_rdata        ),\n    .clking_axi_rresp        ( clking_axi_rresp        ),\n    .clking_axi_rvalid       ( clking_axi_rvalid       ),\n    .clking_axi_rready       ( clking_axi_rready       ),\n\n    .rstn_pulpino_o          ( s_rstn_pulpino          ),\n    .clk_pulpino_o           ( s_clk_pulpino           )\n);\n\n  // PULPino SoC\n  pulpino  pulpino_wrap_i (\n    .clk               ( s_clk_pulpino  ),\n    .rst_n             ( s_rstn_pulpino ),\n\n    .fetch_enable_i    ( fetch_en       ),\n\n    .tck_i             ( tck_i          ),\n    .trstn_i           ( trst_ni        ),\n    .tms_i             ( tms_i          ),\n    .tdi_i             ( td_i           ),\n    .tdo_o             ( td_o           ),\n\n    .spi_clk_i         ( spi_sck        ),\n    .spi_cs_i          ( spi_cs         ),\n    .spi_mode_o        (                ),\n    .spi_sdi0_i        ( spi_mosi       ),\n    .spi_sdi1_i        ( 1'b0           ),\n    .spi_sdi2_i        ( 1'b0           ),\n    .spi_sdi3_i        ( 1'b0           ),\n    .spi_sdo0_o        ( spi_miso       ),\n    .spi_sdo1_o        (                ),\n    .spi_sdo2_o        (                ),\n    .spi_sdo3_o        (                ),\n\n    .spi_master_clk_o  (                ),\n    .spi_master_csn0_o (                ),\n    .spi_master_csn1_o (                ),\n    .spi_master_csn2_o (                ),\n    .spi_master_csn3_o (                ),\n    .spi_master_mode_o (                ),\n    .spi_master_sdi0_i ( 1'b0           ),\n    .spi_master_sdi1_i ( 1'b0           ),\n    .spi_master_sdi2_i ( 1'b0           ),\n    .spi_master_sdi3_i ( 1'b0           ),\n    .spi_master_sdo0_o (                ),\n    .spi_master_sdo1_o (                ),\n    .spi_master_sdo2_o (                ),\n    .spi_master_sdo3_o (                ),\n\n    .scl_i             ( scl_in         ),\n    .scl_o             ( scl_out        ),\n    .scl_oen_o         ( scl_oen        ),\n    .sda_i             ( sda_in         ),\n    .sda_o             ( sda_out        ),\n    .sda_oen_o         ( sda_oen        ),\n\n    .gpio_in           ( gpio_in        ),\n    .gpio_out          ( gpio_out       ),\n    .gpio_dir          ( gpio_dir       ),\n\n    .uart_tx           ( uart_tx        ), // output\n    .uart_rx           ( uart_rx        ), // input\n    .uart_rts          (                ), // output\n    .uart_dtr          (                ), // output\n    .uart_cts          ( 1'b0           ), // input\n    .uart_dsr          ( 1'b0           )  // input\n  );\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"axi_bus.sv\"\n`include \"debug_bus.sv\"\n\n`define AXI_ADDR_WIDTH         32\n`define AXI_DATA_WIDTH         32\n`define AXI_ID_MASTER_WIDTH     2\n`define AXI_ID_SLAVE_WIDTH      4\n`define AXI_USER_WIDTH          1\n\nmodule pulpino_top\n  #(\n    parameter USE_ZERO_RISCY       = 0,\n    parameter RISCY_RV32F          = 0,\n    parameter ZERO_RV32M           = 1,\n    parameter ZERO_RV32E           = 0\n  )\n  (\n    // Clock and Reset\n    input logic               clk /*verilator clocker*/,\n    input logic               rst_n,\n\n    input  logic              clk_sel_i,\n    input  logic              clk_standalone_i,\n    input  logic              testmode_i,\n    input  logic              fetch_enable_i,\n    input  logic              scan_enable_i,\n\n    //SPI Slave\n    input  logic              spi_clk_i /*verilator clocker*/,\n    input  logic              spi_cs_i /*verilator clocker*/,\n    output logic [1:0]        spi_mode_o,\n    output logic              spi_sdo0_o,\n    output logic              spi_sdo1_o,\n    output logic              spi_sdo2_o,\n    output logic              spi_sdo3_o,\n    input  logic              spi_sdi0_i,\n    input  logic              spi_sdi1_i,\n    input  logic              spi_sdi2_i,\n    input  logic              spi_sdi3_i,\n\n    //SPI Master\n    output logic              spi_master_clk_o,\n    output logic              spi_master_csn0_o,\n    output logic              spi_master_csn1_o,\n    output logic              spi_master_csn2_o,\n    output logic              spi_master_csn3_o,\n    output logic [1:0]        spi_master_mode_o,\n    output logic              spi_master_sdo0_o,\n    output logic              spi_master_sdo1_o,\n    output logic              spi_master_sdo2_o,\n    output logic              spi_master_sdo3_o,\n    input  logic              spi_master_sdi0_i,\n    input  logic              spi_master_sdi1_i,\n    input  logic              spi_master_sdi2_i,\n    input  logic              spi_master_sdi3_i,\n\n    input  logic              scl_pad_i,\n    output logic              scl_pad_o,\n    output logic              scl_padoen_o,\n    input  logic              sda_pad_i,\n    output logic              sda_pad_o,\n    output logic              sda_padoen_o,\n\n    output logic              uart_tx,\n    input  logic              uart_rx,\n    output logic              uart_rts,\n    output logic              uart_dtr,\n    input  logic              uart_cts,\n    input  logic              uart_dsr,\n\n    input  logic       [31:0] gpio_in,\n    output logic       [31:0] gpio_out,\n    output logic       [31:0] gpio_dir,\n    output logic [31:0] [5:0] gpio_padcfg,\n\n    // JTAG signals\n    input  logic              tck_i,\n    input  logic              trstn_i,\n    input  logic              tms_i,\n    input  logic              tdi_i,\n    output logic              tdo_o,\n\n    // PULPino specific pad config\n    output logic [31:0] [5:0] pad_cfg_o,\n    output logic       [31:0] pad_mux_o\n  );\n\n  logic        clk_int;\n\n  logic        fetch_enable_int;\n  logic        core_busy_int;\n  logic        clk_gate_core_int;\n  logic [31:0] irq_to_core_int;\n\n  logic        lock_fll_int;\n  logic        cfgreq_fll_int;\n  logic        cfgack_fll_int;\n  logic [1:0]  cfgad_fll_int;\n  logic [31:0] cfgd_fll_int;\n  logic [31:0] cfgq_fll_int;\n  logic        cfgweb_n_fll_int;\n  logic        rstn_int;\n  logic [31:0] boot_addr_int;\n\n  AXI_BUS\n  #(\n    .AXI_ADDR_WIDTH ( `AXI_ADDR_WIDTH     ),\n    .AXI_DATA_WIDTH ( `AXI_DATA_WIDTH     ),\n    .AXI_ID_WIDTH   ( `AXI_ID_SLAVE_WIDTH ),\n    .AXI_USER_WIDTH ( `AXI_USER_WIDTH     )\n  )\n  slaves[2:0]();\n\n  AXI_BUS\n  #(\n    .AXI_ADDR_WIDTH ( `AXI_ADDR_WIDTH      ),\n    .AXI_DATA_WIDTH ( `AXI_DATA_WIDTH      ),\n    .AXI_ID_WIDTH   ( `AXI_ID_MASTER_WIDTH ),\n    .AXI_USER_WIDTH ( `AXI_USER_WIDTH      )\n  )\n  masters[2:0]();\n\n  DEBUG_BUS\n  debug();\n\n  //----------------------------------------------------------------------------//\n  // Clock and reset generation\n  //----------------------------------------------------------------------------//\n  clk_rst_gen\n  clk_rst_gen_i\n  (\n      .clk_i            ( clk              ),\n      .rstn_i           ( rst_n            ),\n\n      .clk_sel_i        ( clk_sel_i        ),\n      .clk_standalone_i ( clk_standalone_i ),\n      .testmode_i       ( testmode_i       ),\n      .scan_i           ( 1'b0             ),\n      .scan_o           (                  ),\n      .scan_en_i        ( scan_enable_i    ),\n\n      .fll_req_i        ( cfgreq_fll_int   ),\n      .fll_wrn_i        ( cfgweb_n_fll_int ),\n      .fll_add_i        ( cfgad_fll_int    ),\n      .fll_data_i       ( cfgd_fll_int     ),\n      .fll_ack_o        ( cfgack_fll_int   ),\n      .fll_r_data_o     ( cfgq_fll_int     ),\n      .fll_lock_o       ( lock_fll_int     ),\n\n      .clk_o            ( clk_int          ),\n      .rstn_o           ( rstn_int         )\n\n    );\n\n  //----------------------------------------------------------------------------//\n  // Core region\n  //----------------------------------------------------------------------------//\n  core_region\n  #(\n    .AXI_ADDR_WIDTH       ( `AXI_ADDR_WIDTH      ),\n    .AXI_DATA_WIDTH       ( `AXI_DATA_WIDTH      ),\n    .AXI_ID_MASTER_WIDTH  ( `AXI_ID_MASTER_WIDTH ),\n    .AXI_ID_SLAVE_WIDTH   ( `AXI_ID_SLAVE_WIDTH  ),\n    .AXI_USER_WIDTH       ( `AXI_USER_WIDTH      ),\n    .USE_ZERO_RISCY       (  USE_ZERO_RISCY      ),\n    .RISCY_RV32F          (  RISCY_RV32F         ),\n    .ZERO_RV32M           (  ZERO_RV32M          ),\n    .ZERO_RV32E           (  ZERO_RV32E          )\n  )\n  core_region_i\n  (\n    .clk            ( clk_int           ),\n    .rst_n          ( rstn_int          ),\n\n    .testmode_i     ( testmode_i        ),\n    .fetch_enable_i ( fetch_enable_int  ),\n    .irq_i          ( irq_to_core_int   ),\n    .core_busy_o    ( core_busy_int     ),\n    .clock_gating_i ( clk_gate_core_int ),\n    .boot_addr_i    ( boot_addr_int     ),\n\n    .core_master    ( masters[0]        ),\n    .dbg_master     ( masters[1]        ),\n    .data_slave     ( slaves[1]         ),\n    .instr_slave    ( slaves[0]         ),\n    .debug          ( debug             ),\n\n    .tck_i          ( tck_i             ),\n    .trstn_i        ( trstn_i           ),\n    .tms_i          ( tms_i             ),\n    .tdi_i          ( tdi_i             ),\n    .tdo_o          ( tdo_o             )\n  );\n\n  //----------------------------------------------------------------------------//\n  // Peripherals\n  //----------------------------------------------------------------------------//\n  peripherals\n  #(\n    .AXI_ADDR_WIDTH      ( `AXI_ADDR_WIDTH      ),\n    .AXI_DATA_WIDTH      ( `AXI_DATA_WIDTH      ),\n    .AXI_SLAVE_ID_WIDTH  ( `AXI_ID_SLAVE_WIDTH  ),\n    .AXI_MASTER_ID_WIDTH ( `AXI_ID_MASTER_WIDTH ),\n    .AXI_USER_WIDTH      ( `AXI_USER_WIDTH      )\n  )\n  peripherals_i\n  (\n    .clk_i           ( clk_int           ),\n    .rst_n           ( rstn_int          ),\n\n    .axi_spi_master  ( masters[2]        ),\n    .debug           ( debug             ),\n\n    .spi_clk_i       ( spi_clk_i         ),\n    .testmode_i      ( testmode_i        ),\n    .spi_cs_i        ( spi_cs_i          ),\n    .spi_mode_o      ( spi_mode_o        ),\n    .spi_sdo0_o      ( spi_sdo0_o        ),\n    .spi_sdo1_o      ( spi_sdo1_o        ),\n    .spi_sdo2_o      ( spi_sdo2_o        ),\n    .spi_sdo3_o      ( spi_sdo3_o        ),\n    .spi_sdi0_i      ( spi_sdi0_i        ),\n    .spi_sdi1_i      ( spi_sdi1_i        ),\n    .spi_sdi2_i      ( spi_sdi2_i        ),\n    .spi_sdi3_i      ( spi_sdi3_i        ),\n\n    .slave           ( slaves[2]         ),\n\n    .uart_tx         ( uart_tx           ),\n    .uart_rx         ( uart_rx           ),\n    .uart_rts        ( uart_rts          ),\n    .uart_dtr        ( uart_dtr          ),\n    .uart_cts        ( uart_cts          ),\n    .uart_dsr        ( uart_dsr          ),\n\n    .spi_master_clk  ( spi_master_clk_o  ),\n    .spi_master_csn0 ( spi_master_csn0_o ),\n    .spi_master_csn1 ( spi_master_csn1_o ),\n    .spi_master_csn2 ( spi_master_csn2_o ),\n    .spi_master_csn3 ( spi_master_csn3_o ),\n    .spi_master_mode ( spi_master_mode_o ),\n    .spi_master_sdo0 ( spi_master_sdo0_o ),\n    .spi_master_sdo1 ( spi_master_sdo1_o ),\n    .spi_master_sdo2 ( spi_master_sdo2_o ),\n    .spi_master_sdo3 ( spi_master_sdo3_o ),\n    .spi_master_sdi0 ( spi_master_sdi0_i ),\n    .spi_master_sdi1 ( spi_master_sdi1_i ),\n    .spi_master_sdi2 ( spi_master_sdi2_i ),\n    .spi_master_sdi3 ( spi_master_sdi3_i ),\n\n    .scl_pad_i       ( scl_pad_i         ),\n    .scl_pad_o       ( scl_pad_o         ),\n    .scl_padoen_o    ( scl_padoen_o      ),\n    .sda_pad_i       ( sda_pad_i         ),\n    .sda_pad_o       ( sda_pad_o         ),\n    .sda_padoen_o    ( sda_padoen_o      ),\n\n    .gpio_in         ( gpio_in           ),\n    .gpio_out        ( gpio_out          ),\n    .gpio_dir        ( gpio_dir          ),\n    .gpio_padcfg     ( gpio_padcfg       ),\n\n    .core_busy_i     ( core_busy_int     ),\n    .irq_o           ( irq_to_core_int   ),\n    .fetch_enable_i  ( fetch_enable_i    ),\n    .fetch_enable_o  ( fetch_enable_int  ),\n    .clk_gate_core_o ( clk_gate_core_int ),\n\n    .fll1_req_o      ( cfgreq_fll_int    ),\n    .fll1_wrn_o      ( cfgweb_n_fll_int  ),\n    .fll1_add_o      ( cfgad_fll_int     ),\n    .fll1_wdata_o    ( cfgd_fll_int      ),\n    .fll1_ack_i      ( cfgack_fll_int    ),\n    .fll1_rdata_i    ( cfgq_fll_int      ),\n    .fll1_lock_i     ( lock_fll_int      ),\n    .pad_cfg_o       ( pad_cfg_o         ),\n    .pad_mux_o       ( pad_mux_o         ),\n    .boot_addr_o     ( boot_addr_int     )\n  );\n\n\n  //----------------------------------------------------------------------------//\n  // Axi node\n  //----------------------------------------------------------------------------//\n\n  axi_node_intf_wrap\n  #(\n    .NB_MASTER      ( 3                    ),\n    .NB_SLAVE       ( 3                    ),\n    .AXI_ADDR_WIDTH ( `AXI_ADDR_WIDTH      ),\n    .AXI_DATA_WIDTH ( `AXI_DATA_WIDTH      ),\n    .AXI_ID_WIDTH   ( `AXI_ID_MASTER_WIDTH ),\n    .AXI_USER_WIDTH ( `AXI_USER_WIDTH      )\n  )\n  axi_interconnect_i\n  (\n    .clk       ( clk_int    ),\n    .rst_n     ( rstn_int   ),\n    .test_en_i ( testmode_i ),\n\n    .master    ( slaves     ),\n    .slave     ( masters    ),\n\n    .start_addr_i ( { 32'h1A10_0000, 32'h0010_0000, 32'h0000_0000 } ),\n    .end_addr_i   ( { 32'h1A11_FFFF, 32'h001F_FFFF, 32'h000F_FFFF } )\n  );\n\nendmodule\n\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule pulpino(\n  clk,\n  rst_n,\n\n  fetch_enable_i,\n\n  spi_clk_i,\n  spi_cs_i,\n  spi_mode_o,\n  spi_sdo0_o,\n  spi_sdo1_o,\n  spi_sdo2_o,\n  spi_sdo3_o,\n  spi_sdi0_i,\n  spi_sdi1_i,\n  spi_sdi2_i,\n  spi_sdi3_i,\n\n  spi_master_clk_o,\n  spi_master_csn0_o,\n  spi_master_csn1_o,\n  spi_master_csn2_o,\n  spi_master_csn3_o,\n  spi_master_mode_o,\n  spi_master_sdo0_o,\n  spi_master_sdo1_o,\n  spi_master_sdo2_o,\n  spi_master_sdo3_o,\n  spi_master_sdi0_i,\n  spi_master_sdi1_i,\n  spi_master_sdi2_i,\n  spi_master_sdi3_i,\n\n  uart_tx,\n  uart_rx,\n  uart_rts,\n  uart_dtr,\n  uart_cts,\n  uart_dsr,\n\n  scl_i,\n  scl_o,\n  scl_oen_o,\n  sda_i,\n  sda_o,\n  sda_oen_o,\n\n  gpio_in,\n  gpio_out,\n  gpio_dir,\n\n  tck_i,\n  trstn_i,\n  tms_i,\n  tdi_i,\n  tdo_o\n  );\n\n  // Clock and Reset\n  input         clk;\n  input         rst_n;\n\n  input         fetch_enable_i;\n\n  input         spi_clk_i;\n  input         spi_cs_i;\n  output  [1:0] spi_mode_o;\n  output        spi_sdo0_o;\n  output        spi_sdo1_o;\n  output        spi_sdo2_o;\n  output        spi_sdo3_o;\n  input         spi_sdi0_i;\n  input         spi_sdi1_i;\n  input         spi_sdi2_i;\n  input         spi_sdi3_i;\n\n  output        spi_master_clk_o;\n  output        spi_master_csn0_o;\n  output        spi_master_csn1_o;\n  output        spi_master_csn2_o;\n  output        spi_master_csn3_o;\n  output  [1:0] spi_master_mode_o;\n  output        spi_master_sdo0_o;\n  output        spi_master_sdo1_o;\n  output        spi_master_sdo2_o;\n  output        spi_master_sdo3_o;\n  input         spi_master_sdi0_i;\n  input         spi_master_sdi1_i;\n  input         spi_master_sdi2_i;\n  input         spi_master_sdi3_i;\n\n  output        uart_tx;\n  input         uart_rx;\n  output        uart_rts;\n  output        uart_dtr;\n  input         uart_cts;\n  input         uart_dsr;\n\n  input         scl_i;\n  output        scl_o;\n  output        scl_oen_o;\n  input         sda_i;\n  output        sda_o;\n  output        sda_oen_o;\n\n  input  [31:0] gpio_in;\n  output [31:0] gpio_out;\n  output [31:0] gpio_dir;\n\n  // JTAG signals\n  input  tck_i;\n  input  trstn_i;\n  input  tms_i;\n  input  tdi_i;\n  output tdo_o;\n\n  parameter USE_ZERO_RISCY = 0;\n  parameter RISCY_RV32F = 0;\n  parameter ZERO_RV32M = 0;\n  parameter ZERO_RV32E = 0;\n   \n  // PULP SoC\n  pulpino_top\n  #(\n    .USE_ZERO_RISCY    ( USE_ZERO_RISCY ),\n    .RISCY_RV32F       ( RISCY_RV32F    ),\n    .ZERO_RV32M        ( ZERO_RV32M     ),\n    .ZERO_RV32E        ( ZERO_RV32E     )\n  )\n  pulpino_i\n  (\n    .clk               ( clk               ),\n    .rst_n             ( rst_n             ),\n\n    .clk_sel_i         ( 1'b0              ),\n    .clk_standalone_i  ( 1'b0              ),\n\n    .testmode_i        ( 1'b0              ),\n    .fetch_enable_i    ( fetch_enable_i    ),\n    .scan_enable_i     ( 1'b0              ),\n\n    .spi_clk_i         ( spi_clk_i         ),\n    .spi_cs_i          ( spi_cs_i          ),\n    .spi_mode_o        ( spi_mode_o        ),\n    .spi_sdo0_o        ( spi_sdo0_o        ),\n    .spi_sdo1_o        ( spi_sdo1_o        ),\n    .spi_sdo2_o        ( spi_sdo2_o        ),\n    .spi_sdo3_o        ( spi_sdo3_o        ),\n    .spi_sdi0_i        ( spi_sdi0_i        ),\n    .spi_sdi1_i        ( spi_sdi1_i        ),\n    .spi_sdi2_i        ( spi_sdi2_i        ),\n    .spi_sdi3_i        ( spi_sdi3_i        ),\n\n    .spi_master_clk_o  ( spi_master_clk_o  ),\n    .spi_master_csn0_o ( spi_master_csn0_o ),\n    .spi_master_csn1_o ( spi_master_csn1_o ),\n    .spi_master_csn2_o ( spi_master_csn2_o ),\n    .spi_master_csn3_o ( spi_master_csn3_o ),\n    .spi_master_mode_o ( spi_master_mode_o ),\n    .spi_master_sdo0_o ( spi_master_sdo0_o ),\n    .spi_master_sdo1_o ( spi_master_sdo1_o ),\n    .spi_master_sdo2_o ( spi_master_sdo2_o ),\n    .spi_master_sdo3_o ( spi_master_sdo3_o ),\n    .spi_master_sdi0_i ( spi_master_sdi0_i ),\n    .spi_master_sdi1_i ( spi_master_sdi1_i ),\n    .spi_master_sdi2_i ( spi_master_sdi2_i ),\n    .spi_master_sdi3_i ( spi_master_sdi3_i ),\n\n    .uart_tx           ( uart_tx           ), // output\n    .uart_rx           ( uart_rx           ), // input\n    .uart_rts          ( uart_rts          ), // output\n    .uart_dtr          ( uart_dtr          ), // output\n    .uart_cts          ( uart_cts          ), // input\n    .uart_dsr          ( uart_dsr          ), // input\n\n    .scl_pad_i         ( scl_i             ),\n    .scl_pad_o         ( scl_o             ),\n    .scl_padoen_o      ( scl_oen_o         ),\n    .sda_pad_i         ( sda_i             ),\n    .sda_pad_o         ( sda_o             ),\n    .sda_padoen_o      ( sda_oen_o         ),\n\n    .gpio_in           ( gpio_in           ),\n    .gpio_out          ( gpio_out          ),\n    .gpio_dir          ( gpio_dir          ),\n    .gpio_padcfg       (                   ),\n\n    .tck_i             ( tck_i             ),\n    .trstn_i           ( trstn_i           ),\n    .tms_i             ( tms_i             ),\n    .tdi_i             ( tdi_i             ),\n    .tdo_o             ( tdo_o             ),\n\n    .pad_cfg_o         (                   ),\n    .pad_mux_o         (                   )\n  );\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule pulp_clock_gating\n(\n    input  logic clk_i,\n    input  logic en_i,\n    input  logic test_en_i,\n    output logic clk_o\n  );\n\n`ifdef PULP_FPGA_EMUL\n  // no clock gates in FPGA flow\n  assign clk_o = clk_i;\n`else\n  logic clk_en;\n\n  always_latch\n  begin\n     if (clk_i == 1'b0)\n       clk_en <= en_i | test_en_i;\n  end\n\n  assign clk_o = clk_i & clk_en;\n`endif\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule pulp_clock_inverter\n(\n    input  logic clk_i,\n    output logic clk_o\n  );\n\n  assign clk_o = ~clk_i;\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule pulp_clock_mux2\n(\n    input  logic clk0_i,\n    input  logic clk1_i,\n    input  logic clk_sel_i,\n    output logic clk_o\n  );\n\n  always_comb\n  begin\n    if (clk_sel_i == 1'b0)\n      clk_o = clk0_i;\n    else\n      clk_o = clk1_i;\n  end\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule ram_mux\n  #(\n    parameter ADDR_WIDTH = 32,\n    parameter OUT_WIDTH = 32,\n    parameter IN0_WIDTH = 32, // in widths cannot be bigger than out width\n    parameter IN1_WIDTH = 32\n  )(\n    // Clock and Reset\n    input logic                     clk,\n    input logic                     rst_n,\n\n    // port0 has priority\n    input  logic                    port0_req_i,\n    output logic                    port0_gnt_o,\n    output logic                    port0_rvalid_o,\n    input  logic [ADDR_WIDTH-1:0]   port0_addr_i,\n    input  logic                    port0_we_i,\n    input  logic [IN0_WIDTH/8-1:0]  port0_be_i,\n    output logic [IN0_WIDTH-1:0]    port0_rdata_o,\n    input  logic [IN0_WIDTH-1:0]    port0_wdata_i,\n\n    input  logic                    port1_req_i,\n    output logic                    port1_gnt_o,\n    output logic                    port1_rvalid_o,\n    input  logic [ADDR_WIDTH-1:0]   port1_addr_i,\n    input  logic                    port1_we_i,\n    input  logic [IN1_WIDTH/8-1:0]  port1_be_i,\n    output logic [IN1_WIDTH-1:0]    port1_rdata_o,\n    input  logic [IN1_WIDTH-1:0]    port1_wdata_i,\n\n    // to RAM\n    output logic                    ram_en_o,\n    output logic [ADDR_WIDTH-1:0]   ram_addr_o,\n    output logic                    ram_we_o,\n    output logic [OUT_WIDTH/8-1:0]  ram_be_o,\n    input  logic [OUT_WIDTH-1:0]    ram_rdata_i,\n    output logic [OUT_WIDTH-1:0]    ram_wdata_o\n  );\n\n  localparam IN0_ADDR_HIGH = $clog2(OUT_WIDTH/8) - 1;\n  localparam IN0_ADDR_LOW  = $clog2(IN0_WIDTH/8);\n  localparam IN0_RATIO     = OUT_WIDTH/IN0_WIDTH;\n\n  logic [OUT_WIDTH/8-1:0] port0_be;\n\n  // size adaptation\n  genvar i0;\n  generate\n    if (IN0_ADDR_HIGH >= IN0_ADDR_LOW)\n    begin\n\n      logic                                port0_addr_q;\n      logic [IN0_RATIO-1:0][IN0_WIDTH-1:0] port0_rdata;\n\n      always_ff @(posedge clk, negedge rst_n)\n      begin\n        if (~rst_n)\n          port0_addr_q <= '0;\n        else\n          if (port0_gnt_o)\n            port0_addr_q <= port0_addr_i[IN0_ADDR_HIGH:IN0_ADDR_LOW];\n      end\n\n      for(i0 = 0; i0 < IN0_RATIO; i0++)\n      begin\n        assign port0_be[(i0+1) * IN0_WIDTH/8 -1:i0*IN0_WIDTH/8] =\n                (i0 == port0_addr_i[IN0_ADDR_HIGH:IN0_ADDR_LOW]) ? port0_be_i : '0;\n\n        assign port0_rdata[i0] = ram_rdata_i[(i0+1)*IN0_WIDTH-1:i0*IN0_WIDTH];\n      end\n\n      assign port0_rdata_o = port0_rdata[port0_addr_q];\n    end else begin\n      // nothing to be done, just pass through\n      assign port0_be = port0_be_i;\n      assign port0_rdata_o = ram_rdata_i;\n    end\n  endgenerate\n\n\n  localparam IN1_ADDR_HIGH = $clog2(OUT_WIDTH/8) - 1;\n  localparam IN1_ADDR_LOW  = $clog2(IN1_WIDTH/8);\n  localparam IN1_RATIO     = OUT_WIDTH/IN1_WIDTH;\n\n  logic [OUT_WIDTH/8-1:0] port1_be;\n\n  // size adaptation\n  genvar i1;\n  generate\n    if (IN1_ADDR_HIGH >= IN1_ADDR_LOW)\n    begin\n      logic                                port1_addr_q;\n      logic [IN1_RATIO-1:0][IN1_WIDTH-1:0] port1_rdata;\n\n      always_ff @(posedge clk, negedge rst_n)\n      begin\n        if (~rst_n)\n          port1_addr_q <= '0;\n        else\n          if (port1_gnt_o)\n            port1_addr_q <= port1_addr_i[IN1_ADDR_HIGH:IN1_ADDR_LOW];\n      end\n\n      for(i1 = 0; i1 < OUT_WIDTH/IN1_WIDTH; i1++)\n      begin\n        assign port1_be[(i1+1) * IN1_WIDTH/8 -1:i1*IN1_WIDTH/8] =\n                (i1 == port1_addr_i[IN1_ADDR_HIGH:IN1_ADDR_LOW]) ? port1_be_i : '0;\n\n        assign port1_rdata[i1] = ram_rdata_i[(i1+1)*IN1_WIDTH-1:i1*IN1_WIDTH];\n      end\n\n      assign port1_rdata_o = port1_rdata[port1_addr_q];\n    end else begin\n      // nothing to be done, just pass through\n      assign port1_be = port1_be_i;\n      assign port1_rdata_o = ram_rdata_i;\n    end\n  endgenerate\n\n\n  // RAM mux for data port of core and AXI interface\n  always_comb\n  begin\n    port0_gnt_o = 1'b0;\n    port1_gnt_o = 1'b0;\n\n    // port0 has priority\n    if(port0_req_i)\n      port0_gnt_o   = 1'b1;\n    else if(port1_req_i)\n      port1_gnt_o   = 1'b1;\n  end\n\n  assign ram_en_o    = port0_req_i | port1_req_i;\n  assign ram_addr_o  = port0_req_i ? port0_addr_i  : port1_addr_i;\n  assign ram_wdata_o = port0_req_i ? {OUT_WIDTH/IN0_WIDTH{port0_wdata_i}} : {OUT_WIDTH/IN1_WIDTH{port1_wdata_i}};\n  assign ram_we_o    = port0_req_i ? port0_we_i    : port1_we_i;\n  assign ram_be_o    = port0_req_i ? port0_be      : port1_be;\n\n  // generate rvalid signals from gnt signals\n  always_ff @(posedge clk, negedge rst_n)\n  begin\n    if (rst_n == 1'b0)\n    begin\n      port0_rvalid_o <= 1'b0;\n      port1_rvalid_o <= 1'b0;\n    end\n    else\n    begin\n      port0_rvalid_o <= port0_gnt_o;\n      port1_rvalid_o <= port1_gnt_o;\n    end\n  end\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule random_stalls\n(\n    input  logic         clk,\n\n    input  logic         core_req_i,\n    output logic         core_gnt_o,\n    input  logic [31:0]  core_addr_i,\n    input  logic         core_we_i,\n    input  logic [ 3:0]  core_be_i,\n    input  logic [31:0]  core_wdata_i,\n    output logic [31:0]  core_rdata_o,\n    output logic         core_rvalid_o,\n\n    output logic         data_req_o,\n    input  logic         data_gnt_i,\n    output logic [31:0]  data_addr_o,\n    output logic         data_we_o,\n    output logic [ 3:0]  data_be_o,\n    output logic [31:0]  data_wdata_o,\n    input  logic [31:0]  data_rdata_i,\n    input  logic         data_rvalid_i\n  );\n\n  class rand_wait_cycles;\n    rand int n;\n    constraint default_c { n >= 0 ; n < 6;}\n  endclass\n\n  // random staller\n  typedef struct {\n    logic [31:0] addr;\n    logic        we;\n    logic [ 3:0] be;\n    logic [31:0] wdata;\n    logic [31:0] rdata;\n  } stall_mem_t;\n\n  mailbox core_reqs          = new (4);\n  mailbox core_resps         = new (4);\n  mailbox core_resps_granted = new (4);\n  mailbox platform_transfers = new (4);\n\n  // Core Request Side\n  // Waits for requests and puts them in a queue, does not perform actual\n  // requests to the platform\n  initial\n  begin\n    stall_mem_t mem_acc;\n    automatic rand_wait_cycles wait_cycles = new ();\n    int temp;\n\n    while(1) begin\n      core_gnt_o = 1'b0;\n\n      #1;\n      if (!core_req_i)\n        continue;\n\n\n      // we got a request, now let's wait for a random number of cycles before\n      // we give the grant\n      temp = wait_cycles.randomize();\n\n      while(wait_cycles.n != 0) begin\n        @(posedge clk);\n        wait_cycles.n--;\n        #1;\n      end\n\n      // we waited for a random number of cycles, let's give the grant\n      core_gnt_o = 1'b1;\n\n      mem_acc.addr  = core_addr_i;\n      mem_acc.be    = core_be_i;\n      mem_acc.we    = core_we_i;\n      mem_acc.wdata = core_wdata_i;\n\n      core_reqs.put(mem_acc);\n\n      @(posedge clk);\n\n      core_resps_granted.put(1'b1);\n    end\n  end\n\n  // Core Response Side\n  // Waits for a response from the platform and then waits for a random number\n  // of cycles before giving the rvalid\n  initial\n  begin\n    stall_mem_t mem_acc;\n    automatic rand_wait_cycles wait_cycles = new ();\n    logic granted;\n    int temp;\n\n    while(1) begin\n      @(posedge clk);\n      core_rvalid_o = 1'b0;\n      core_rdata_o = 'x;\n\n      core_resps_granted.get(granted);\n      core_resps.get(mem_acc);\n\n      // we got a response, now let's wait for a random amount of cycles\n      // we give the grant\n      temp = wait_cycles.randomize();\n\n      while(wait_cycles.n != 0) begin\n        @(posedge clk);\n        wait_cycles.n--;\n      end\n\n      // we waited for a random number of cycles, let's give the rvalid\n      core_rdata_o  = mem_acc.rdata;\n      core_rvalid_o = 1'b1;\n    end\n  end\n\n  // platform request side\n  // Waits for requests from the core and then performs the request on the\n  // platform immediately\n  // Simulates a \"virtual\" core\n  initial\n  begin\n    stall_mem_t mem_acc;\n\n    while(1) begin\n      @(posedge clk);\n      data_req_o   = 1'b0;\n      data_addr_o  = '0;\n      data_we_o    = 1'b0;\n      data_be_o    = 4'b0;\n      data_wdata_o = 'x;\n\n      core_reqs.get(mem_acc);\n\n      data_req_o   = 1'b1;\n      data_addr_o  = mem_acc.addr;\n      data_we_o    = mem_acc.we;\n      data_be_o    = mem_acc.be;\n      data_wdata_o = mem_acc.wdata;\n\n      #1;\n      while(!data_gnt_i) begin\n        @(posedge clk);\n        #1;\n      end\n\n      platform_transfers.put(mem_acc);\n    end\n  end\n\n  // platform response side\n  // Waits for rvalids and puts the responses into the core response mailbox\n  initial\n  begin\n    stall_mem_t mem_acc;\n\n    while(1) begin\n      @(posedge clk);\n\n      platform_transfers.get(mem_acc);\n\n      while(!data_rvalid_i) begin\n        @(posedge clk);\n      end\n\n      mem_acc.rdata = data_rdata_i;\n\n      core_resps.put(mem_acc);\n    end\n  end\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule rstgen\n(\n    // PAD FRAME SIGNALS\n    input  logic clk_i,\n    input  logic rst_ni,\n\n    // TEST MODE\n    input  logic test_mode_i,\n\n    // OUTPUT RESET\n    output logic rst_no,\n    output logic init_no\n  );\n\n  logic   s_rst_ff3,s_rst_ff2,s_rst_ff1,s_rst_ff0,s_rst_n;\n\n  //\n  // RESET GENERATION\n  //\n\n  always_ff @(posedge clk_i, negedge rst_ni)\n  begin\n    if (~rst_ni)\n    begin\n      s_rst_ff0  <= 1'b0;\n      s_rst_ff1  <= 1'b0;\n      s_rst_ff2  <= 1'b0;\n      s_rst_ff3  <= 1'b0;\n      s_rst_n    <= 1'b0;\n    end\n    else\n    begin\n      s_rst_ff3  <= 1'b1;\n      s_rst_ff2  <= s_rst_ff3;\n      s_rst_ff1  <= s_rst_ff2;\n      s_rst_ff0  <= s_rst_ff1;\n      s_rst_n    <= s_rst_ff0;\n    end\n  end\n\n  always_comb\n  begin\n    if (test_mode_i == 1'b0)\n      rst_no  = s_rst_n;\n    else\n      rst_no  = rst_ni;\n  end\n\n  always_comb\n  begin\n    if (test_mode_i == 1'b0)\n      init_no = s_rst_n;\n    else\n      init_no = 1'b1;\n  end\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\nmodule sp_ram\n  #(\n    parameter ADDR_WIDTH = 8,\n    parameter DATA_WIDTH = 32,\n    parameter NUM_WORDS  = 256\n  )(\n    // Clock and Reset\n    input  logic                    clk,\n\n    input  logic                    en_i,\n    input  logic [ADDR_WIDTH-1:0]   addr_i,\n    input  logic [DATA_WIDTH-1:0]   wdata_i,\n    output logic [DATA_WIDTH-1:0]   rdata_o,\n    input  logic                    we_i,\n    input  logic [DATA_WIDTH/8-1:0] be_i\n  );\n\n  localparam words = NUM_WORDS/(DATA_WIDTH/8);\n\n  logic [DATA_WIDTH/8-1:0][7:0] mem[words];\n  logic [DATA_WIDTH/8-1:0][7:0] wdata;\n  logic [ADDR_WIDTH-1-$clog2(DATA_WIDTH/8):0] addr;\n\n  integer i;\n\n\n  assign addr = addr_i[ADDR_WIDTH-1:$clog2(DATA_WIDTH/8)];\n\n\n  always @(posedge clk)\n  begin\n    if (en_i && we_i)\n    begin\n      for (i = 0; i < DATA_WIDTH/8; i++) begin\n        if (be_i[i])\n          mem[addr][i] <= wdata[i];\n      end\n    end\n\n    rdata_o <= mem[addr];\n  end\n\n  genvar w;\n  generate for(w = 0; w < DATA_WIDTH/8; w++)\n    begin\n      assign wdata[w] = wdata_i[(w+1)*8-1:w*8];\n    end\n  endgenerate\n\nendmodule\n"}
{"text": "// Copyright 2017 ETH Zurich and University of Bologna.\n// Copyright and related rights are licensed under the Solderpad Hardware\n// License, Version 0.51 (the \u201cLicense\u201d); you may not use this file except in\n// compliance with the License.  You may obtain a copy of the License at\n// http://solderpad.org/licenses/SHL-0.51. Unless required by applicable law\n// or agreed to in writing, software, hardware and materials distributed under\n// this License is distributed on an \u201cAS IS\u201d BASIS, WITHOUT WARRANTIES OR\n// CONDITIONS OF ANY KIND, either express or implied. See the License for the\n// specific language governing permissions and limitations under the License.\n\n`include \"config.sv\"\n\nmodule sp_ram_wrap\n  #(\n    parameter RAM_SIZE   = 32768,              // in bytes\n    parameter ADDR_WIDTH = $clog2(RAM_SIZE),\n    parameter DATA_WIDTH = 32\n  )(\n    // Clock and Reset\n    input  logic                    clk,\n    input  logic                    rstn_i,\n    input  logic                    en_i,\n    input  logic [ADDR_WIDTH-1:0]   addr_i,\n    input  logic [DATA_WIDTH-1:0]   wdata_i,\n    output logic [DATA_WIDTH-1:0]   rdata_o,\n    input  logic                    we_i,\n    input  logic [DATA_WIDTH/8-1:0] be_i,\n    input  logic                    bypass_en_i\n  );\n\n`ifdef PULP_FPGA_EMUL\n  xilinx_mem_8192x32\n  sp_ram_i\n  (\n    .clka   ( clk                    ),\n    .rsta   ( 1'b0                   ), // reset is active high\n\n    .ena    ( en_i                   ),\n    .addra  ( addr_i[ADDR_WIDTH-1:2] ),\n    .dina   ( wdata_i                ),\n    .douta  ( rdata_o                ),\n    .wea    ( be_i & {4{we_i}}       )\n  );\n\n  // TODO: we should kill synthesis when the ram size is larger than what we\n  // have here\n\n`elsif ASIC\n   // RAM bypass logic\n   logic [31:0] ram_out_int;\n   // assign rdata_o = (bypass_en_i) ? wdata_i : ram_out_int;\n   assign rdata_o = ram_out_int;\n\n   sp_ram_bank\n   #(\n    .NUM_BANKS  ( RAM_SIZE/4096 ),\n    .BANK_SIZE  ( 1024          )\n   )\n   sp_ram_bank_i\n   (\n    .clk_i   ( clk                     ),\n    .rstn_i  ( rstn_i                  ),\n    .en_i    ( en_i                    ),\n    .addr_i  ( addr_i                  ),\n    .wdata_i ( wdata_i                 ),\n    .rdata_o ( ram_out_int             ),\n    .we_i    ( (we_i & ~bypass_en_i)   ),\n    .be_i    ( be_i                    )\n   );\n\n`else\n  sp_ram\n  #(\n    .ADDR_WIDTH ( ADDR_WIDTH ),\n    .DATA_WIDTH ( DATA_WIDTH ),\n    .NUM_WORDS  ( RAM_SIZE   )\n  )\n  sp_ram_i\n  (\n    .clk     ( clk       ),\n\n    .en_i    ( en_i      ),\n    .addr_i  ( addr_i    ),\n    .wdata_i ( wdata_i   ),\n    .rdata_o ( rdata_o   ),\n    .we_i    ( we_i      ),\n    .be_i    ( be_i      )\n  );\n`endif\n\nendmodule\n"}
